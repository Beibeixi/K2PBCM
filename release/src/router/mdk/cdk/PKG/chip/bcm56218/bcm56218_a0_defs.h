#ifndef __BCM56218_A0_DEFS_H__
#define __BCM56218_A0_DEFS_H__
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated from the registers file.
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Copyright 2013 Broadcom Corporation.
 * This program is the proprietary software of Broadcom Corporation
 * and/or its licensors, and may only be used, duplicated, modified
 * or distributed pursuant to the terms and conditions of a separate,
 * written license agreement executed between you and Broadcom
 * (an "Authorized License").  Except as set forth in an Authorized
 * License, Broadcom grants no license (express or implied), right
 * to use, or waiver of any kind with respect to the Software, and
 * Broadcom expressly reserves all rights in and to the Software
 * and all intellectual property rights therein.  IF YOU HAVE
 * NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
 * IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
 * ALL USE OF THE SOFTWARE.  
 *  
 * Except as expressly set forth in the Authorized License,
 *  
 * 1.     This program, including its structure, sequence and organization,
 * constitutes the valuable trade secrets of Broadcom, and you shall use
 * all reasonable efforts to protect the confidentiality thereof,
 * and to use this information only in connection with your use of
 * Broadcom integrated circuit products.
 *  
 * 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
 * PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
 * REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
 * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
 * DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
 * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
 * ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
 * CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
 * OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
 * 
 * 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
 * BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
 * INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
 * ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
 * TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
 * THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR USD 1.00,
 * WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
 * ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
 *
 * Definition file for the BCM56218_A0.
 * This file provides all basic definitions required to program the BCM56218_A0.
 *
 ******************************************************************************/

#include <cdk/cdk_string.h>
#include <cdk/cdk_field.h>
#include <cdk/arch/xgs_reg.h>
#include <cdk/arch/xgs_mem.h>

/*******************************************************************************
 *
 *                    CHIP DEFINITIONS BEGIN HERE
 *
 ******************************************************************************/



/* CMIC physical block/port */
#define BCM56218_A0_CMIC_BLOCK          0
#define BCM56218_A0_CMIC_PORT           0

/* Additional block types */
#define BCM56218_A0_BLKTYPE_BSAFE       0
#define BCM56218_A0_BLKTYPE_CMIC        1
#define BCM56218_A0_BLKTYPE_EPIPE       2
#define BCM56218_A0_BLKTYPE_EPIPE_HI    3
#define BCM56218_A0_BLKTYPE_GPORT       4
#define BCM56218_A0_BLKTYPE_IPIPE       5
#define BCM56218_A0_BLKTYPE_IPIPE_HI    6
#define BCM56218_A0_BLKTYPE_MMU         7

/* Chip-specific flags */
#define BCM56218_A0_CHIP_FLAG_FE_ONLY   0x80000000

#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_BLOCK                      BCM56218_A0_CMIC_BLOCK
#define CMIC_PORT                       BCM56218_A0_CMIC_PORT

#define BLKTYPE_BSAFE                   BCM56218_A0_BLKTYPE_BSAFE
#define BLKTYPE_CMIC                    BCM56218_A0_BLKTYPE_CMIC
#define BLKTYPE_EPIPE                   BCM56218_A0_BLKTYPE_EPIPE
#define BLKTYPE_EPIPE_HI                BCM56218_A0_BLKTYPE_EPIPE_HI
#define BLKTYPE_GPORT                   BCM56218_A0_BLKTYPE_GPORT
#define BLKTYPE_IPIPE                   BCM56218_A0_BLKTYPE_IPIPE
#define BLKTYPE_IPIPE_HI                BCM56218_A0_BLKTYPE_IPIPE_HI
#define BLKTYPE_MMU                     BCM56218_A0_BLKTYPE_MMU

#define CHIP_FLAG_FE_ONLY               BCM56218_A0_CHIP_FLAG_FE_ONLY

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */



#if CDK_CONFIG_CHIP_DEFS_USE_DSYMS == 1
/* Use DSYM all_defs.h instead of static chip definitions */
#include "all_defs.h"
#else

/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  AGINGCTRMEMDEBUG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     SAM              sam registers.
 *     CT0              ct0 registers.
 *     CT1              ct1 registers.
 *     CT2              ct2 registers.
 *
 ******************************************************************************/
#define BCM56218_A0_AGINGCTRMEMDEBUGr 0x00680042

#define BCM56218_A0_AGINGCTRMEMDEBUGr_SIZE 4

/*
 * This structure should be used to declare and program AGINGCTRMEMDEBUG.
 *
 */
typedef union BCM56218_A0_AGINGCTRMEMDEBUGr_s {
	uint32_t v[1];
	uint32_t agingctrmemdebug[1];
	uint32_t _agingctrmemdebug;
} BCM56218_A0_AGINGCTRMEMDEBUGr_t;

#define BCM56218_A0_AGINGCTRMEMDEBUGr_CLR(r) (r).agingctrmemdebug[0] = 0
#define BCM56218_A0_AGINGCTRMEMDEBUGr_SET(r,d) (r).agingctrmemdebug[0] = d
#define BCM56218_A0_AGINGCTRMEMDEBUGr_GET(r) (r).agingctrmemdebug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_AGINGCTRMEMDEBUGr_SAMf_GET(r) (((r).agingctrmemdebug[0]) & 0x3)
#define BCM56218_A0_AGINGCTRMEMDEBUGr_SAMf_SET(r,f) (r).agingctrmemdebug[0]=(((r).agingctrmemdebug[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56218_A0_AGINGCTRMEMDEBUGr_CT0f_GET(r) ((((r).agingctrmemdebug[0]) >> 2) & 0x1)
#define BCM56218_A0_AGINGCTRMEMDEBUGr_CT0f_SET(r,f) (r).agingctrmemdebug[0]=(((r).agingctrmemdebug[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_AGINGCTRMEMDEBUGr_CT1f_GET(r) ((((r).agingctrmemdebug[0]) >> 3) & 0x1)
#define BCM56218_A0_AGINGCTRMEMDEBUGr_CT1f_SET(r,f) (r).agingctrmemdebug[0]=(((r).agingctrmemdebug[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56218_A0_AGINGCTRMEMDEBUGr_CT2f_GET(r) ((((r).agingctrmemdebug[0]) >> 4) & 0x1)
#define BCM56218_A0_AGINGCTRMEMDEBUGr_CT2f_SET(r,f) (r).agingctrmemdebug[0]=(((r).agingctrmemdebug[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))

/*
 * These macros can be used to access AGINGCTRMEMDEBUG.
 *
 */
#define BCM56218_A0_READ_AGINGCTRMEMDEBUGr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_AGINGCTRMEMDEBUGr,(r._agingctrmemdebug))
#define BCM56218_A0_WRITE_AGINGCTRMEMDEBUGr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_AGINGCTRMEMDEBUGr,&(r._agingctrmemdebug))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define AGINGCTRMEMDEBUGr BCM56218_A0_AGINGCTRMEMDEBUGr
#define AGINGCTRMEMDEBUGr_SIZE BCM56218_A0_AGINGCTRMEMDEBUGr_SIZE
typedef BCM56218_A0_AGINGCTRMEMDEBUGr_t AGINGCTRMEMDEBUGr_t;
#define AGINGCTRMEMDEBUGr_CLR BCM56218_A0_AGINGCTRMEMDEBUGr_CLR
#define AGINGCTRMEMDEBUGr_SET BCM56218_A0_AGINGCTRMEMDEBUGr_SET
#define AGINGCTRMEMDEBUGr_GET BCM56218_A0_AGINGCTRMEMDEBUGr_GET
#define AGINGCTRMEMDEBUGr_SAMf_GET BCM56218_A0_AGINGCTRMEMDEBUGr_SAMf_GET
#define AGINGCTRMEMDEBUGr_SAMf_SET BCM56218_A0_AGINGCTRMEMDEBUGr_SAMf_SET
#define AGINGCTRMEMDEBUGr_CT0f_GET BCM56218_A0_AGINGCTRMEMDEBUGr_CT0f_GET
#define AGINGCTRMEMDEBUGr_CT0f_SET BCM56218_A0_AGINGCTRMEMDEBUGr_CT0f_SET
#define AGINGCTRMEMDEBUGr_CT1f_GET BCM56218_A0_AGINGCTRMEMDEBUGr_CT1f_GET
#define AGINGCTRMEMDEBUGr_CT1f_SET BCM56218_A0_AGINGCTRMEMDEBUGr_CT1f_SET
#define AGINGCTRMEMDEBUGr_CT2f_GET BCM56218_A0_AGINGCTRMEMDEBUGr_CT2f_GET
#define AGINGCTRMEMDEBUGr_CT2f_SET BCM56218_A0_AGINGCTRMEMDEBUGr_CT2f_SET
#define READ_AGINGCTRMEMDEBUGr BCM56218_A0_READ_AGINGCTRMEMDEBUGr
#define WRITE_AGINGCTRMEMDEBUGr BCM56218_A0_WRITE_AGINGCTRMEMDEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_AGINGCTRMEMDEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  AGINGEXPMEMDEBUG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CCM              ccm registers.
 *     RM               rm registers.
 *
 ******************************************************************************/
#define BCM56218_A0_AGINGEXPMEMDEBUGr 0x00680043

#define BCM56218_A0_AGINGEXPMEMDEBUGr_SIZE 4

/*
 * This structure should be used to declare and program AGINGEXPMEMDEBUG.
 *
 */
typedef union BCM56218_A0_AGINGEXPMEMDEBUGr_s {
	uint32_t v[1];
	uint32_t agingexpmemdebug[1];
	uint32_t _agingexpmemdebug;
} BCM56218_A0_AGINGEXPMEMDEBUGr_t;

#define BCM56218_A0_AGINGEXPMEMDEBUGr_CLR(r) (r).agingexpmemdebug[0] = 0
#define BCM56218_A0_AGINGEXPMEMDEBUGr_SET(r,d) (r).agingexpmemdebug[0] = d
#define BCM56218_A0_AGINGEXPMEMDEBUGr_GET(r) (r).agingexpmemdebug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_AGINGEXPMEMDEBUGr_CCMf_GET(r) (((r).agingexpmemdebug[0]) & 0x1)
#define BCM56218_A0_AGINGEXPMEMDEBUGr_CCMf_SET(r,f) (r).agingexpmemdebug[0]=(((r).agingexpmemdebug[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_AGINGEXPMEMDEBUGr_RMf_GET(r) ((((r).agingexpmemdebug[0]) >> 1) & 0x1)
#define BCM56218_A0_AGINGEXPMEMDEBUGr_RMf_SET(r,f) (r).agingexpmemdebug[0]=(((r).agingexpmemdebug[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access AGINGEXPMEMDEBUG.
 *
 */
#define BCM56218_A0_READ_AGINGEXPMEMDEBUGr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_AGINGEXPMEMDEBUGr,(r._agingexpmemdebug))
#define BCM56218_A0_WRITE_AGINGEXPMEMDEBUGr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_AGINGEXPMEMDEBUGr,&(r._agingexpmemdebug))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define AGINGEXPMEMDEBUGr BCM56218_A0_AGINGEXPMEMDEBUGr
#define AGINGEXPMEMDEBUGr_SIZE BCM56218_A0_AGINGEXPMEMDEBUGr_SIZE
typedef BCM56218_A0_AGINGEXPMEMDEBUGr_t AGINGEXPMEMDEBUGr_t;
#define AGINGEXPMEMDEBUGr_CLR BCM56218_A0_AGINGEXPMEMDEBUGr_CLR
#define AGINGEXPMEMDEBUGr_SET BCM56218_A0_AGINGEXPMEMDEBUGr_SET
#define AGINGEXPMEMDEBUGr_GET BCM56218_A0_AGINGEXPMEMDEBUGr_GET
#define AGINGEXPMEMDEBUGr_CCMf_GET BCM56218_A0_AGINGEXPMEMDEBUGr_CCMf_GET
#define AGINGEXPMEMDEBUGr_CCMf_SET BCM56218_A0_AGINGEXPMEMDEBUGr_CCMf_SET
#define AGINGEXPMEMDEBUGr_RMf_GET BCM56218_A0_AGINGEXPMEMDEBUGr_RMf_GET
#define AGINGEXPMEMDEBUGr_RMf_SET BCM56218_A0_AGINGEXPMEMDEBUGr_RMf_SET
#define READ_AGINGEXPMEMDEBUGr BCM56218_A0_READ_AGINGEXPMEMDEBUGr
#define WRITE_AGINGEXPMEMDEBUGr BCM56218_A0_WRITE_AGINGEXPMEMDEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_AGINGEXPMEMDEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  AUX_ARB_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     IP auxilary arbiter control register
 * SIZE:     32
 * FIELDS:
 *     L2_MOD_FIFO_LOCK Set to 1 to lock the L2_MOD_FIFO, clearing empties the L2_MOD_FIFO
 *     L2_MOD_FIFO_ENABLE Enables tracking the L2_MOD_FIFO, this cause learns/ages to get blocked when full
 *     FP_REFRESH_ENABLE Enables sending FP refreshes down the pipeline
 *     CLK_GRAN         clock granularity for ages (speed up for simulation use only)
 *
 ******************************************************************************/
#define BCM56218_A0_AUX_ARB_CONTROLr 0x00780000

#define BCM56218_A0_AUX_ARB_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program AUX_ARB_CONTROL.
 *
 */
typedef union BCM56218_A0_AUX_ARB_CONTROLr_s {
	uint32_t v[1];
	uint32_t aux_arb_control[1];
	uint32_t _aux_arb_control;
} BCM56218_A0_AUX_ARB_CONTROLr_t;

#define BCM56218_A0_AUX_ARB_CONTROLr_CLR(r) (r).aux_arb_control[0] = 0
#define BCM56218_A0_AUX_ARB_CONTROLr_SET(r,d) (r).aux_arb_control[0] = d
#define BCM56218_A0_AUX_ARB_CONTROLr_GET(r) (r).aux_arb_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_AUX_ARB_CONTROLr_L2_MOD_FIFO_LOCKf_GET(r) (((r).aux_arb_control[0]) & 0x1)
#define BCM56218_A0_AUX_ARB_CONTROLr_L2_MOD_FIFO_LOCKf_SET(r,f) (r).aux_arb_control[0]=(((r).aux_arb_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_AUX_ARB_CONTROLr_L2_MOD_FIFO_ENABLEf_GET(r) ((((r).aux_arb_control[0]) >> 1) & 0x1)
#define BCM56218_A0_AUX_ARB_CONTROLr_L2_MOD_FIFO_ENABLEf_SET(r,f) (r).aux_arb_control[0]=(((r).aux_arb_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_AUX_ARB_CONTROLr_FP_REFRESH_ENABLEf_GET(r) ((((r).aux_arb_control[0]) >> 2) & 0x1)
#define BCM56218_A0_AUX_ARB_CONTROLr_FP_REFRESH_ENABLEf_SET(r,f) (r).aux_arb_control[0]=(((r).aux_arb_control[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_AUX_ARB_CONTROLr_CLK_GRANf_GET(r) ((((r).aux_arb_control[0]) >> 3) & 0x3)
#define BCM56218_A0_AUX_ARB_CONTROLr_CLK_GRANf_SET(r,f) (r).aux_arb_control[0]=(((r).aux_arb_control[0] & ~((uint32_t)0x3 << 3)) | ((((uint32_t)f) & 0x3) << 3))

/*
 * These macros can be used to access AUX_ARB_CONTROL.
 *
 */
#define BCM56218_A0_READ_AUX_ARB_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_AUX_ARB_CONTROLr,(r._aux_arb_control))
#define BCM56218_A0_WRITE_AUX_ARB_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_AUX_ARB_CONTROLr,&(r._aux_arb_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define AUX_ARB_CONTROLr BCM56218_A0_AUX_ARB_CONTROLr
#define AUX_ARB_CONTROLr_SIZE BCM56218_A0_AUX_ARB_CONTROLr_SIZE
typedef BCM56218_A0_AUX_ARB_CONTROLr_t AUX_ARB_CONTROLr_t;
#define AUX_ARB_CONTROLr_CLR BCM56218_A0_AUX_ARB_CONTROLr_CLR
#define AUX_ARB_CONTROLr_SET BCM56218_A0_AUX_ARB_CONTROLr_SET
#define AUX_ARB_CONTROLr_GET BCM56218_A0_AUX_ARB_CONTROLr_GET
#define AUX_ARB_CONTROLr_L2_MOD_FIFO_LOCKf_GET BCM56218_A0_AUX_ARB_CONTROLr_L2_MOD_FIFO_LOCKf_GET
#define AUX_ARB_CONTROLr_L2_MOD_FIFO_LOCKf_SET BCM56218_A0_AUX_ARB_CONTROLr_L2_MOD_FIFO_LOCKf_SET
#define AUX_ARB_CONTROLr_L2_MOD_FIFO_ENABLEf_GET BCM56218_A0_AUX_ARB_CONTROLr_L2_MOD_FIFO_ENABLEf_GET
#define AUX_ARB_CONTROLr_L2_MOD_FIFO_ENABLEf_SET BCM56218_A0_AUX_ARB_CONTROLr_L2_MOD_FIFO_ENABLEf_SET
#define AUX_ARB_CONTROLr_FP_REFRESH_ENABLEf_GET BCM56218_A0_AUX_ARB_CONTROLr_FP_REFRESH_ENABLEf_GET
#define AUX_ARB_CONTROLr_FP_REFRESH_ENABLEf_SET BCM56218_A0_AUX_ARB_CONTROLr_FP_REFRESH_ENABLEf_SET
#define AUX_ARB_CONTROLr_CLK_GRANf_GET BCM56218_A0_AUX_ARB_CONTROLr_CLK_GRANf_GET
#define AUX_ARB_CONTROLr_CLK_GRANf_SET BCM56218_A0_AUX_ARB_CONTROLr_CLK_GRANf_SET
#define READ_AUX_ARB_CONTROLr BCM56218_A0_READ_AUX_ARB_CONTROLr
#define WRITE_AUX_ARB_CONTROLr BCM56218_A0_WRITE_AUX_ARB_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_AUX_ARB_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  BCAST_BLOCK_MASK
 * BLOCKS:   IPIPE
 * DESC:     Broadcast Block Mask - Lower Bitmap
 * SIZE:     32
 * FIELDS:
 *     BLK_BITMAP       Bitmap of ports to be blocked
 *
 ******************************************************************************/
#define BCM56218_A0_BCAST_BLOCK_MASKr 0x0e700104

#define BCM56218_A0_BCAST_BLOCK_MASKr_SIZE 4

/*
 * This structure should be used to declare and program BCAST_BLOCK_MASK.
 *
 */
typedef union BCM56218_A0_BCAST_BLOCK_MASKr_s {
	uint32_t v[1];
	uint32_t bcast_block_mask[1];
	uint32_t _bcast_block_mask;
} BCM56218_A0_BCAST_BLOCK_MASKr_t;

#define BCM56218_A0_BCAST_BLOCK_MASKr_CLR(r) (r).bcast_block_mask[0] = 0
#define BCM56218_A0_BCAST_BLOCK_MASKr_SET(r,d) (r).bcast_block_mask[0] = d
#define BCM56218_A0_BCAST_BLOCK_MASKr_GET(r) (r).bcast_block_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_BCAST_BLOCK_MASKr_BLK_BITMAPf_GET(r) ((r).bcast_block_mask[0])
#define BCM56218_A0_BCAST_BLOCK_MASKr_BLK_BITMAPf_SET(r,f) (r).bcast_block_mask[0]=((uint32_t)f)

/*
 * These macros can be used to access BCAST_BLOCK_MASK.
 *
 */
#define BCM56218_A0_READ_BCAST_BLOCK_MASKr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_BCAST_BLOCK_MASKr,(r._bcast_block_mask))
#define BCM56218_A0_WRITE_BCAST_BLOCK_MASKr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_BCAST_BLOCK_MASKr,&(r._bcast_block_mask))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BCAST_BLOCK_MASKr BCM56218_A0_BCAST_BLOCK_MASKr
#define BCAST_BLOCK_MASKr_SIZE BCM56218_A0_BCAST_BLOCK_MASKr_SIZE
typedef BCM56218_A0_BCAST_BLOCK_MASKr_t BCAST_BLOCK_MASKr_t;
#define BCAST_BLOCK_MASKr_CLR BCM56218_A0_BCAST_BLOCK_MASKr_CLR
#define BCAST_BLOCK_MASKr_SET BCM56218_A0_BCAST_BLOCK_MASKr_SET
#define BCAST_BLOCK_MASKr_GET BCM56218_A0_BCAST_BLOCK_MASKr_GET
#define BCAST_BLOCK_MASKr_BLK_BITMAPf_GET BCM56218_A0_BCAST_BLOCK_MASKr_BLK_BITMAPf_GET
#define BCAST_BLOCK_MASKr_BLK_BITMAPf_SET BCM56218_A0_BCAST_BLOCK_MASKr_BLK_BITMAPf_SET
#define READ_BCAST_BLOCK_MASKr BCM56218_A0_READ_BCAST_BLOCK_MASKr
#define WRITE_BCAST_BLOCK_MASKr BCM56218_A0_WRITE_BCAST_BLOCK_MASKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_BCAST_BLOCK_MASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  BCAST_BLOCK_MASK_HI
 * BLOCKS:   IPIPE
 * DESC:     Broadcast Block Mask - Upper Bitmap
 * SIZE:     32
 * FIELDS:
 *     BLK_BITMAP       Bitmap of ports to be blocked
 *
 ******************************************************************************/
#define BCM56218_A0_BCAST_BLOCK_MASK_HIr 0x0e700105

#define BCM56218_A0_BCAST_BLOCK_MASK_HIr_SIZE 4

/*
 * This structure should be used to declare and program BCAST_BLOCK_MASK_HI.
 *
 */
typedef union BCM56218_A0_BCAST_BLOCK_MASK_HIr_s {
	uint32_t v[1];
	uint32_t bcast_block_mask_hi[1];
	uint32_t _bcast_block_mask_hi;
} BCM56218_A0_BCAST_BLOCK_MASK_HIr_t;

#define BCM56218_A0_BCAST_BLOCK_MASK_HIr_CLR(r) (r).bcast_block_mask_hi[0] = 0
#define BCM56218_A0_BCAST_BLOCK_MASK_HIr_SET(r,d) (r).bcast_block_mask_hi[0] = d
#define BCM56218_A0_BCAST_BLOCK_MASK_HIr_GET(r) (r).bcast_block_mask_hi[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_BCAST_BLOCK_MASK_HIr_BLK_BITMAPf_GET(r) (((r).bcast_block_mask_hi[0]) & 0x3fffff)
#define BCM56218_A0_BCAST_BLOCK_MASK_HIr_BLK_BITMAPf_SET(r,f) (r).bcast_block_mask_hi[0]=(((r).bcast_block_mask_hi[0] & ~((uint32_t)0x3fffff)) | (((uint32_t)f) & 0x3fffff))

/*
 * These macros can be used to access BCAST_BLOCK_MASK_HI.
 *
 */
#define BCM56218_A0_READ_BCAST_BLOCK_MASK_HIr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_BCAST_BLOCK_MASK_HIr,(r._bcast_block_mask_hi))
#define BCM56218_A0_WRITE_BCAST_BLOCK_MASK_HIr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_BCAST_BLOCK_MASK_HIr,&(r._bcast_block_mask_hi))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BCAST_BLOCK_MASK_HIr BCM56218_A0_BCAST_BLOCK_MASK_HIr
#define BCAST_BLOCK_MASK_HIr_SIZE BCM56218_A0_BCAST_BLOCK_MASK_HIr_SIZE
typedef BCM56218_A0_BCAST_BLOCK_MASK_HIr_t BCAST_BLOCK_MASK_HIr_t;
#define BCAST_BLOCK_MASK_HIr_CLR BCM56218_A0_BCAST_BLOCK_MASK_HIr_CLR
#define BCAST_BLOCK_MASK_HIr_SET BCM56218_A0_BCAST_BLOCK_MASK_HIr_SET
#define BCAST_BLOCK_MASK_HIr_GET BCM56218_A0_BCAST_BLOCK_MASK_HIr_GET
#define BCAST_BLOCK_MASK_HIr_BLK_BITMAPf_GET BCM56218_A0_BCAST_BLOCK_MASK_HIr_BLK_BITMAPf_GET
#define BCAST_BLOCK_MASK_HIr_BLK_BITMAPf_SET BCM56218_A0_BCAST_BLOCK_MASK_HIr_BLK_BITMAPf_SET
#define READ_BCAST_BLOCK_MASK_HIr BCM56218_A0_READ_BCAST_BLOCK_MASK_HIr
#define WRITE_BCAST_BLOCK_MASK_HIr BCM56218_A0_WRITE_BCAST_BLOCK_MASK_HIr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_BCAST_BLOCK_MASK_HIr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  BCAST_STORM_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     Ethernet Broadcast Rate Control Registers
 * SIZE:     32
 * FIELDS:
 *     THRESHOLD        Rate Limit, count as number of packets
 *     ENABLE           Broadcast rate control enable
 *
 ******************************************************************************/
#define BCM56218_A0_BCAST_STORM_CONTROLr 0x0b700001

#define BCM56218_A0_BCAST_STORM_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program BCAST_STORM_CONTROL.
 *
 */
typedef union BCM56218_A0_BCAST_STORM_CONTROLr_s {
	uint32_t v[1];
	uint32_t bcast_storm_control[1];
	uint32_t _bcast_storm_control;
} BCM56218_A0_BCAST_STORM_CONTROLr_t;

#define BCM56218_A0_BCAST_STORM_CONTROLr_CLR(r) (r).bcast_storm_control[0] = 0
#define BCM56218_A0_BCAST_STORM_CONTROLr_SET(r,d) (r).bcast_storm_control[0] = d
#define BCM56218_A0_BCAST_STORM_CONTROLr_GET(r) (r).bcast_storm_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_BCAST_STORM_CONTROLr_THRESHOLDf_GET(r) (((r).bcast_storm_control[0]) & 0x1ffffff)
#define BCM56218_A0_BCAST_STORM_CONTROLr_THRESHOLDf_SET(r,f) (r).bcast_storm_control[0]=(((r).bcast_storm_control[0] & ~((uint32_t)0x1ffffff)) | (((uint32_t)f) & 0x1ffffff))
#define BCM56218_A0_BCAST_STORM_CONTROLr_ENABLEf_GET(r) ((((r).bcast_storm_control[0]) >> 25) & 0x1)
#define BCM56218_A0_BCAST_STORM_CONTROLr_ENABLEf_SET(r,f) (r).bcast_storm_control[0]=(((r).bcast_storm_control[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))

/*
 * These macros can be used to access BCAST_STORM_CONTROL.
 *
 */
#define BCM56218_A0_READ_BCAST_STORM_CONTROLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_BCAST_STORM_CONTROLr,(r._bcast_storm_control))
#define BCM56218_A0_WRITE_BCAST_STORM_CONTROLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_BCAST_STORM_CONTROLr,&(r._bcast_storm_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BCAST_STORM_CONTROLr BCM56218_A0_BCAST_STORM_CONTROLr
#define BCAST_STORM_CONTROLr_SIZE BCM56218_A0_BCAST_STORM_CONTROLr_SIZE
typedef BCM56218_A0_BCAST_STORM_CONTROLr_t BCAST_STORM_CONTROLr_t;
#define BCAST_STORM_CONTROLr_CLR BCM56218_A0_BCAST_STORM_CONTROLr_CLR
#define BCAST_STORM_CONTROLr_SET BCM56218_A0_BCAST_STORM_CONTROLr_SET
#define BCAST_STORM_CONTROLr_GET BCM56218_A0_BCAST_STORM_CONTROLr_GET
#define BCAST_STORM_CONTROLr_THRESHOLDf_GET BCM56218_A0_BCAST_STORM_CONTROLr_THRESHOLDf_GET
#define BCAST_STORM_CONTROLr_THRESHOLDf_SET BCM56218_A0_BCAST_STORM_CONTROLr_THRESHOLDf_SET
#define BCAST_STORM_CONTROLr_ENABLEf_GET BCM56218_A0_BCAST_STORM_CONTROLr_ENABLEf_GET
#define BCAST_STORM_CONTROLr_ENABLEf_SET BCM56218_A0_BCAST_STORM_CONTROLr_ENABLEf_SET
#define READ_BCAST_STORM_CONTROLr BCM56218_A0_READ_BCAST_STORM_CONTROLr
#define WRITE_BCAST_STORM_CONTROLr BCM56218_A0_WRITE_BCAST_STORM_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_BCAST_STORM_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  BKPMETERINGBUCKET
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     BUCKET_COUNT     Pause Metering\'s Bucket Count for each ingress port
 *     IN_PROFILE_FLAG  IN_PROFILE_FLAG inidcates the current state of Back Pressure Metering bucket1: out of profile0: In profile
 *
 ******************************************************************************/
#define BCM56218_A0_BKPMETERINGBUCKETr 0x00600006

#define BCM56218_A0_BKPMETERINGBUCKETr_SIZE 4

/*
 * This structure should be used to declare and program BKPMETERINGBUCKET.
 *
 */
typedef union BCM56218_A0_BKPMETERINGBUCKETr_s {
	uint32_t v[1];
	uint32_t bkpmeteringbucket[1];
	uint32_t _bkpmeteringbucket;
} BCM56218_A0_BKPMETERINGBUCKETr_t;

#define BCM56218_A0_BKPMETERINGBUCKETr_CLR(r) (r).bkpmeteringbucket[0] = 0
#define BCM56218_A0_BKPMETERINGBUCKETr_SET(r,d) (r).bkpmeteringbucket[0] = d
#define BCM56218_A0_BKPMETERINGBUCKETr_GET(r) (r).bkpmeteringbucket[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_BKPMETERINGBUCKETr_BUCKET_COUNTf_GET(r) (((r).bkpmeteringbucket[0]) & 0x1fffffff)
#define BCM56218_A0_BKPMETERINGBUCKETr_BUCKET_COUNTf_SET(r,f) (r).bkpmeteringbucket[0]=(((r).bkpmeteringbucket[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM56218_A0_BKPMETERINGBUCKETr_IN_PROFILE_FLAGf_GET(r) ((((r).bkpmeteringbucket[0]) >> 29) & 0x1)
#define BCM56218_A0_BKPMETERINGBUCKETr_IN_PROFILE_FLAGf_SET(r,f) (r).bkpmeteringbucket[0]=(((r).bkpmeteringbucket[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))

/*
 * These macros can be used to access BKPMETERINGBUCKET.
 *
 */
#define BCM56218_A0_READ_BKPMETERINGBUCKETr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_BKPMETERINGBUCKETr,(r._bkpmeteringbucket))
#define BCM56218_A0_WRITE_BKPMETERINGBUCKETr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_BKPMETERINGBUCKETr,&(r._bkpmeteringbucket))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BKPMETERINGBUCKETr BCM56218_A0_BKPMETERINGBUCKETr
#define BKPMETERINGBUCKETr_SIZE BCM56218_A0_BKPMETERINGBUCKETr_SIZE
typedef BCM56218_A0_BKPMETERINGBUCKETr_t BKPMETERINGBUCKETr_t;
#define BKPMETERINGBUCKETr_CLR BCM56218_A0_BKPMETERINGBUCKETr_CLR
#define BKPMETERINGBUCKETr_SET BCM56218_A0_BKPMETERINGBUCKETr_SET
#define BKPMETERINGBUCKETr_GET BCM56218_A0_BKPMETERINGBUCKETr_GET
#define BKPMETERINGBUCKETr_BUCKET_COUNTf_GET BCM56218_A0_BKPMETERINGBUCKETr_BUCKET_COUNTf_GET
#define BKPMETERINGBUCKETr_BUCKET_COUNTf_SET BCM56218_A0_BKPMETERINGBUCKETr_BUCKET_COUNTf_SET
#define BKPMETERINGBUCKETr_IN_PROFILE_FLAGf_GET BCM56218_A0_BKPMETERINGBUCKETr_IN_PROFILE_FLAGf_GET
#define BKPMETERINGBUCKETr_IN_PROFILE_FLAGf_SET BCM56218_A0_BKPMETERINGBUCKETr_IN_PROFILE_FLAGf_SET
#define READ_BKPMETERINGBUCKETr BCM56218_A0_READ_BKPMETERINGBUCKETr
#define WRITE_BKPMETERINGBUCKETr BCM56218_A0_WRITE_BKPMETERINGBUCKETr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_BKPMETERINGBUCKETr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  BKPMETERINGCONFIG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     PAUSE_THD        Pause Threshold for start pause on pause metering of an ingress port:When Bucket Count fells below Pause Threshold, it sends out Back PressureWarning Status Message. This threshold must not over the size of Bucket Count. (256 Mbits)0x0: Disable, BKP Metering function is disabled.0x1:  32k bits, (32*1024),0x2:  64k bits, (64*1024),0x3: 128k bits, (128*1024),0x4: 256k bits, (256*1024),0x5: 512k bits, (512*1024),0x6:   1M bits, (1024*1024),0x7:   2M bits, (2*1024*1024),0x8:   4M bits, (4*1024*1024),0x9:   8M bits, (8*1024*1024),0xa:  16M bits, (16*1024*1024),0xb:  32M bits, (32*1024*1024),0xc:  64M bits, (64*1024*1024),0xd: 128M bits, (128*1024*1024),0xe: 128M bits, (128*1024*1024), Bucket saturated at 128M bits,0xf: 128M bits, (128*1024*1024), Bucket saturated at 128M bits,
 *     RESUME_THD       Resume Threshold for resume reception on pause metering of an ingress port:When Bucket Count reqain above Resume Threshold, it sends out Back PressureWarning Status Clearing Message. 0x0:  75% of PAUSE_THD.0x1:  50% of PAUSE_THD.0x2:  25% of PAUSE_THD.0x3:  12.5% of PAUSE_THD.
 *     DISCARD_THD      Discard Threshold for discarding packet on Back Pressure Metering bucket of an ingress port:When Bucket Count reqain above Resume Threshold, it sends out Back PressureWarning Status Clearing Message. This Threshold must not over the size of Bucket Count. (256 Mbits)0x0:  75% of PAUSE_THD above PAUSE_THD.0x1:  50% of PAUSE_THD above PAUSE_THD.0x2:  25% of PAUSE_THD above PAUSE_THD.0x3:  12.5% of PAUSE_THD above PAUSE_THD.
 *     REFRESHCOUNT     Refresh count for Back Pressure Metering bucket. Every unit of REFRESH represents 64,000 bps, (bits per second).Example 1:  To set metering rate to 500 Mbps (500,000,000 bps),             should set REFRESH = 7812,Example 2:  To set metering rate to 1 Gbps (1,000,000,000 bps),             should set REFRESH = 15624.
 *     BKPDISCARD_EN    Back Pressure Metering Discard Message Enable:Enable Back Pressure Warning Message to discard packet formthis ingress port when Back Pressure Metering bucket count is above Discard Threshold.   
 *     BKPDISCARD_ACCT_EN Back Pressure Metering Discard Accounting Enable:Enable to account for incoming packet length when a port'sBack Pressure Metering bucket is above its Discard Threshold.
 *     IFG_ACCT_SEL     Inter Frame Gap Accounting Select:0: No extra Inter Frame Gap bytes added.1: Account for Inter Frame Gap of 16 Bytes for a incoming packet2: Account for Inter Frame Gap of 20 Bytes for a incoming packet3: Account for Inter Frame Gap of 24 Bytes for a incoming packet
 *
 ******************************************************************************/
#define BCM56218_A0_BKPMETERINGCONFIGr 0x00600005

#define BCM56218_A0_BKPMETERINGCONFIGr_SIZE 4

/*
 * This structure should be used to declare and program BKPMETERINGCONFIG.
 *
 */
typedef union BCM56218_A0_BKPMETERINGCONFIGr_s {
	uint32_t v[1];
	uint32_t bkpmeteringconfig[1];
	uint32_t _bkpmeteringconfig;
} BCM56218_A0_BKPMETERINGCONFIGr_t;

#define BCM56218_A0_BKPMETERINGCONFIGr_CLR(r) (r).bkpmeteringconfig[0] = 0
#define BCM56218_A0_BKPMETERINGCONFIGr_SET(r,d) (r).bkpmeteringconfig[0] = d
#define BCM56218_A0_BKPMETERINGCONFIGr_GET(r) (r).bkpmeteringconfig[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_BKPMETERINGCONFIGr_PAUSE_THDf_GET(r) (((r).bkpmeteringconfig[0]) & 0xf)
#define BCM56218_A0_BKPMETERINGCONFIGr_PAUSE_THDf_SET(r,f) (r).bkpmeteringconfig[0]=(((r).bkpmeteringconfig[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56218_A0_BKPMETERINGCONFIGr_RESUME_THDf_GET(r) ((((r).bkpmeteringconfig[0]) >> 4) & 0x3)
#define BCM56218_A0_BKPMETERINGCONFIGr_RESUME_THDf_SET(r,f) (r).bkpmeteringconfig[0]=(((r).bkpmeteringconfig[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM56218_A0_BKPMETERINGCONFIGr_DISCARD_THDf_GET(r) ((((r).bkpmeteringconfig[0]) >> 6) & 0x3)
#define BCM56218_A0_BKPMETERINGCONFIGr_DISCARD_THDf_SET(r,f) (r).bkpmeteringconfig[0]=(((r).bkpmeteringconfig[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM56218_A0_BKPMETERINGCONFIGr_REFRESHCOUNTf_GET(r) ((((r).bkpmeteringconfig[0]) >> 8) & 0x3ffff)
#define BCM56218_A0_BKPMETERINGCONFIGr_REFRESHCOUNTf_SET(r,f) (r).bkpmeteringconfig[0]=(((r).bkpmeteringconfig[0] & ~((uint32_t)0x3ffff << 8)) | ((((uint32_t)f) & 0x3ffff) << 8))
#define BCM56218_A0_BKPMETERINGCONFIGr_BKPDISCARD_ENf_GET(r) ((((r).bkpmeteringconfig[0]) >> 26) & 0x1)
#define BCM56218_A0_BKPMETERINGCONFIGr_BKPDISCARD_ENf_SET(r,f) (r).bkpmeteringconfig[0]=(((r).bkpmeteringconfig[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM56218_A0_BKPMETERINGCONFIGr_BKPDISCARD_ACCT_ENf_GET(r) ((((r).bkpmeteringconfig[0]) >> 27) & 0x1)
#define BCM56218_A0_BKPMETERINGCONFIGr_BKPDISCARD_ACCT_ENf_SET(r,f) (r).bkpmeteringconfig[0]=(((r).bkpmeteringconfig[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM56218_A0_BKPMETERINGCONFIGr_IFG_ACCT_SELf_GET(r) ((((r).bkpmeteringconfig[0]) >> 28) & 0x3)
#define BCM56218_A0_BKPMETERINGCONFIGr_IFG_ACCT_SELf_SET(r,f) (r).bkpmeteringconfig[0]=(((r).bkpmeteringconfig[0] & ~((uint32_t)0x3 << 28)) | ((((uint32_t)f) & 0x3) << 28))

/*
 * These macros can be used to access BKPMETERINGCONFIG.
 *
 */
#define BCM56218_A0_READ_BKPMETERINGCONFIGr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_BKPMETERINGCONFIGr,(r._bkpmeteringconfig))
#define BCM56218_A0_WRITE_BKPMETERINGCONFIGr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_BKPMETERINGCONFIGr,&(r._bkpmeteringconfig))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BKPMETERINGCONFIGr BCM56218_A0_BKPMETERINGCONFIGr
#define BKPMETERINGCONFIGr_SIZE BCM56218_A0_BKPMETERINGCONFIGr_SIZE
typedef BCM56218_A0_BKPMETERINGCONFIGr_t BKPMETERINGCONFIGr_t;
#define BKPMETERINGCONFIGr_CLR BCM56218_A0_BKPMETERINGCONFIGr_CLR
#define BKPMETERINGCONFIGr_SET BCM56218_A0_BKPMETERINGCONFIGr_SET
#define BKPMETERINGCONFIGr_GET BCM56218_A0_BKPMETERINGCONFIGr_GET
#define BKPMETERINGCONFIGr_PAUSE_THDf_GET BCM56218_A0_BKPMETERINGCONFIGr_PAUSE_THDf_GET
#define BKPMETERINGCONFIGr_PAUSE_THDf_SET BCM56218_A0_BKPMETERINGCONFIGr_PAUSE_THDf_SET
#define BKPMETERINGCONFIGr_RESUME_THDf_GET BCM56218_A0_BKPMETERINGCONFIGr_RESUME_THDf_GET
#define BKPMETERINGCONFIGr_RESUME_THDf_SET BCM56218_A0_BKPMETERINGCONFIGr_RESUME_THDf_SET
#define BKPMETERINGCONFIGr_DISCARD_THDf_GET BCM56218_A0_BKPMETERINGCONFIGr_DISCARD_THDf_GET
#define BKPMETERINGCONFIGr_DISCARD_THDf_SET BCM56218_A0_BKPMETERINGCONFIGr_DISCARD_THDf_SET
#define BKPMETERINGCONFIGr_REFRESHCOUNTf_GET BCM56218_A0_BKPMETERINGCONFIGr_REFRESHCOUNTf_GET
#define BKPMETERINGCONFIGr_REFRESHCOUNTf_SET BCM56218_A0_BKPMETERINGCONFIGr_REFRESHCOUNTf_SET
#define BKPMETERINGCONFIGr_BKPDISCARD_ENf_GET BCM56218_A0_BKPMETERINGCONFIGr_BKPDISCARD_ENf_GET
#define BKPMETERINGCONFIGr_BKPDISCARD_ENf_SET BCM56218_A0_BKPMETERINGCONFIGr_BKPDISCARD_ENf_SET
#define BKPMETERINGCONFIGr_BKPDISCARD_ACCT_ENf_GET BCM56218_A0_BKPMETERINGCONFIGr_BKPDISCARD_ACCT_ENf_GET
#define BKPMETERINGCONFIGr_BKPDISCARD_ACCT_ENf_SET BCM56218_A0_BKPMETERINGCONFIGr_BKPDISCARD_ACCT_ENf_SET
#define BKPMETERINGCONFIGr_IFG_ACCT_SELf_GET BCM56218_A0_BKPMETERINGCONFIGr_IFG_ACCT_SELf_GET
#define BKPMETERINGCONFIGr_IFG_ACCT_SELf_SET BCM56218_A0_BKPMETERINGCONFIGr_IFG_ACCT_SELf_SET
#define READ_BKPMETERINGCONFIGr BCM56218_A0_READ_BKPMETERINGCONFIGr
#define WRITE_BKPMETERINGCONFIGr BCM56218_A0_WRITE_BKPMETERINGCONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_BKPMETERINGCONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  BKPMETERINGDISCSTATUS
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     PORT_BITMAP      Current Back Pressure Metering discard status
 *
 ******************************************************************************/
#define BCM56218_A0_BKPMETERINGDISCSTATUSr 0x00680008

#define BCM56218_A0_BKPMETERINGDISCSTATUSr_SIZE 4

/*
 * This structure should be used to declare and program BKPMETERINGDISCSTATUS.
 *
 */
typedef union BCM56218_A0_BKPMETERINGDISCSTATUSr_s {
	uint32_t v[1];
	uint32_t bkpmeteringdiscstatus[1];
	uint32_t _bkpmeteringdiscstatus;
} BCM56218_A0_BKPMETERINGDISCSTATUSr_t;

#define BCM56218_A0_BKPMETERINGDISCSTATUSr_CLR(r) (r).bkpmeteringdiscstatus[0] = 0
#define BCM56218_A0_BKPMETERINGDISCSTATUSr_SET(r,d) (r).bkpmeteringdiscstatus[0] = d
#define BCM56218_A0_BKPMETERINGDISCSTATUSr_GET(r) (r).bkpmeteringdiscstatus[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_BKPMETERINGDISCSTATUSr_PORT_BITMAPf_GET(r) ((r).bkpmeteringdiscstatus[0])
#define BCM56218_A0_BKPMETERINGDISCSTATUSr_PORT_BITMAPf_SET(r,f) (r).bkpmeteringdiscstatus[0]=((uint32_t)f)

/*
 * These macros can be used to access BKPMETERINGDISCSTATUS.
 *
 */
#define BCM56218_A0_READ_BKPMETERINGDISCSTATUSr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_BKPMETERINGDISCSTATUSr,(r._bkpmeteringdiscstatus))
#define BCM56218_A0_WRITE_BKPMETERINGDISCSTATUSr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_BKPMETERINGDISCSTATUSr,&(r._bkpmeteringdiscstatus))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BKPMETERINGDISCSTATUSr BCM56218_A0_BKPMETERINGDISCSTATUSr
#define BKPMETERINGDISCSTATUSr_SIZE BCM56218_A0_BKPMETERINGDISCSTATUSr_SIZE
typedef BCM56218_A0_BKPMETERINGDISCSTATUSr_t BKPMETERINGDISCSTATUSr_t;
#define BKPMETERINGDISCSTATUSr_CLR BCM56218_A0_BKPMETERINGDISCSTATUSr_CLR
#define BKPMETERINGDISCSTATUSr_SET BCM56218_A0_BKPMETERINGDISCSTATUSr_SET
#define BKPMETERINGDISCSTATUSr_GET BCM56218_A0_BKPMETERINGDISCSTATUSr_GET
#define BKPMETERINGDISCSTATUSr_PORT_BITMAPf_GET BCM56218_A0_BKPMETERINGDISCSTATUSr_PORT_BITMAPf_GET
#define BKPMETERINGDISCSTATUSr_PORT_BITMAPf_SET BCM56218_A0_BKPMETERINGDISCSTATUSr_PORT_BITMAPf_SET
#define READ_BKPMETERINGDISCSTATUSr BCM56218_A0_READ_BKPMETERINGDISCSTATUSr
#define WRITE_BKPMETERINGDISCSTATUSr BCM56218_A0_WRITE_BKPMETERINGDISCSTATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_BKPMETERINGDISCSTATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  BKPMETERINGDISCSTATUS_HI
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     PORT_BITMAP      Current Back Pressure Metering discard status for port 53-32
 *
 ******************************************************************************/
#define BCM56218_A0_BKPMETERINGDISCSTATUS_HIr 0x00680009

#define BCM56218_A0_BKPMETERINGDISCSTATUS_HIr_SIZE 4

/*
 * This structure should be used to declare and program BKPMETERINGDISCSTATUS_HI.
 *
 */
typedef union BCM56218_A0_BKPMETERINGDISCSTATUS_HIr_s {
	uint32_t v[1];
	uint32_t bkpmeteringdiscstatus_hi[1];
	uint32_t _bkpmeteringdiscstatus_hi;
} BCM56218_A0_BKPMETERINGDISCSTATUS_HIr_t;

#define BCM56218_A0_BKPMETERINGDISCSTATUS_HIr_CLR(r) (r).bkpmeteringdiscstatus_hi[0] = 0
#define BCM56218_A0_BKPMETERINGDISCSTATUS_HIr_SET(r,d) (r).bkpmeteringdiscstatus_hi[0] = d
#define BCM56218_A0_BKPMETERINGDISCSTATUS_HIr_GET(r) (r).bkpmeteringdiscstatus_hi[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_BKPMETERINGDISCSTATUS_HIr_PORT_BITMAPf_GET(r) (((r).bkpmeteringdiscstatus_hi[0]) & 0x3fffff)
#define BCM56218_A0_BKPMETERINGDISCSTATUS_HIr_PORT_BITMAPf_SET(r,f) (r).bkpmeteringdiscstatus_hi[0]=(((r).bkpmeteringdiscstatus_hi[0] & ~((uint32_t)0x3fffff)) | (((uint32_t)f) & 0x3fffff))

/*
 * These macros can be used to access BKPMETERINGDISCSTATUS_HI.
 *
 */
#define BCM56218_A0_READ_BKPMETERINGDISCSTATUS_HIr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_BKPMETERINGDISCSTATUS_HIr,(r._bkpmeteringdiscstatus_hi))
#define BCM56218_A0_WRITE_BKPMETERINGDISCSTATUS_HIr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_BKPMETERINGDISCSTATUS_HIr,&(r._bkpmeteringdiscstatus_hi))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BKPMETERINGDISCSTATUS_HIr BCM56218_A0_BKPMETERINGDISCSTATUS_HIr
#define BKPMETERINGDISCSTATUS_HIr_SIZE BCM56218_A0_BKPMETERINGDISCSTATUS_HIr_SIZE
typedef BCM56218_A0_BKPMETERINGDISCSTATUS_HIr_t BKPMETERINGDISCSTATUS_HIr_t;
#define BKPMETERINGDISCSTATUS_HIr_CLR BCM56218_A0_BKPMETERINGDISCSTATUS_HIr_CLR
#define BKPMETERINGDISCSTATUS_HIr_SET BCM56218_A0_BKPMETERINGDISCSTATUS_HIr_SET
#define BKPMETERINGDISCSTATUS_HIr_GET BCM56218_A0_BKPMETERINGDISCSTATUS_HIr_GET
#define BKPMETERINGDISCSTATUS_HIr_PORT_BITMAPf_GET BCM56218_A0_BKPMETERINGDISCSTATUS_HIr_PORT_BITMAPf_GET
#define BKPMETERINGDISCSTATUS_HIr_PORT_BITMAPf_SET BCM56218_A0_BKPMETERINGDISCSTATUS_HIr_PORT_BITMAPf_SET
#define READ_BKPMETERINGDISCSTATUS_HIr BCM56218_A0_READ_BKPMETERINGDISCSTATUS_HIr
#define WRITE_BKPMETERINGDISCSTATUS_HIr BCM56218_A0_WRITE_BKPMETERINGDISCSTATUS_HIr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_BKPMETERINGDISCSTATUS_HIr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  BKPMETERINGSTATUS
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     PORT_BITMAP      Current Back Pressure Metering status
 *
 ******************************************************************************/
#define BCM56218_A0_BKPMETERINGSTATUSr 0x00680004

#define BCM56218_A0_BKPMETERINGSTATUSr_SIZE 4

/*
 * This structure should be used to declare and program BKPMETERINGSTATUS.
 *
 */
typedef union BCM56218_A0_BKPMETERINGSTATUSr_s {
	uint32_t v[1];
	uint32_t bkpmeteringstatus[1];
	uint32_t _bkpmeteringstatus;
} BCM56218_A0_BKPMETERINGSTATUSr_t;

#define BCM56218_A0_BKPMETERINGSTATUSr_CLR(r) (r).bkpmeteringstatus[0] = 0
#define BCM56218_A0_BKPMETERINGSTATUSr_SET(r,d) (r).bkpmeteringstatus[0] = d
#define BCM56218_A0_BKPMETERINGSTATUSr_GET(r) (r).bkpmeteringstatus[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_BKPMETERINGSTATUSr_PORT_BITMAPf_GET(r) ((r).bkpmeteringstatus[0])
#define BCM56218_A0_BKPMETERINGSTATUSr_PORT_BITMAPf_SET(r,f) (r).bkpmeteringstatus[0]=((uint32_t)f)

/*
 * These macros can be used to access BKPMETERINGSTATUS.
 *
 */
#define BCM56218_A0_READ_BKPMETERINGSTATUSr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_BKPMETERINGSTATUSr,(r._bkpmeteringstatus))
#define BCM56218_A0_WRITE_BKPMETERINGSTATUSr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_BKPMETERINGSTATUSr,&(r._bkpmeteringstatus))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BKPMETERINGSTATUSr BCM56218_A0_BKPMETERINGSTATUSr
#define BKPMETERINGSTATUSr_SIZE BCM56218_A0_BKPMETERINGSTATUSr_SIZE
typedef BCM56218_A0_BKPMETERINGSTATUSr_t BKPMETERINGSTATUSr_t;
#define BKPMETERINGSTATUSr_CLR BCM56218_A0_BKPMETERINGSTATUSr_CLR
#define BKPMETERINGSTATUSr_SET BCM56218_A0_BKPMETERINGSTATUSr_SET
#define BKPMETERINGSTATUSr_GET BCM56218_A0_BKPMETERINGSTATUSr_GET
#define BKPMETERINGSTATUSr_PORT_BITMAPf_GET BCM56218_A0_BKPMETERINGSTATUSr_PORT_BITMAPf_GET
#define BKPMETERINGSTATUSr_PORT_BITMAPf_SET BCM56218_A0_BKPMETERINGSTATUSr_PORT_BITMAPf_SET
#define READ_BKPMETERINGSTATUSr BCM56218_A0_READ_BKPMETERINGSTATUSr
#define WRITE_BKPMETERINGSTATUSr BCM56218_A0_WRITE_BKPMETERINGSTATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_BKPMETERINGSTATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  BKPMETERINGSTATUS_HI
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     PORT_BITMAP      Current Back Pressure Metering status for port 53-32
 *
 ******************************************************************************/
#define BCM56218_A0_BKPMETERINGSTATUS_HIr 0x00680005

#define BCM56218_A0_BKPMETERINGSTATUS_HIr_SIZE 4

/*
 * This structure should be used to declare and program BKPMETERINGSTATUS_HI.
 *
 */
typedef union BCM56218_A0_BKPMETERINGSTATUS_HIr_s {
	uint32_t v[1];
	uint32_t bkpmeteringstatus_hi[1];
	uint32_t _bkpmeteringstatus_hi;
} BCM56218_A0_BKPMETERINGSTATUS_HIr_t;

#define BCM56218_A0_BKPMETERINGSTATUS_HIr_CLR(r) (r).bkpmeteringstatus_hi[0] = 0
#define BCM56218_A0_BKPMETERINGSTATUS_HIr_SET(r,d) (r).bkpmeteringstatus_hi[0] = d
#define BCM56218_A0_BKPMETERINGSTATUS_HIr_GET(r) (r).bkpmeteringstatus_hi[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_BKPMETERINGSTATUS_HIr_PORT_BITMAPf_GET(r) (((r).bkpmeteringstatus_hi[0]) & 0x3fffff)
#define BCM56218_A0_BKPMETERINGSTATUS_HIr_PORT_BITMAPf_SET(r,f) (r).bkpmeteringstatus_hi[0]=(((r).bkpmeteringstatus_hi[0] & ~((uint32_t)0x3fffff)) | (((uint32_t)f) & 0x3fffff))

/*
 * These macros can be used to access BKPMETERINGSTATUS_HI.
 *
 */
#define BCM56218_A0_READ_BKPMETERINGSTATUS_HIr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_BKPMETERINGSTATUS_HIr,(r._bkpmeteringstatus_hi))
#define BCM56218_A0_WRITE_BKPMETERINGSTATUS_HIr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_BKPMETERINGSTATUS_HIr,&(r._bkpmeteringstatus_hi))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BKPMETERINGSTATUS_HIr BCM56218_A0_BKPMETERINGSTATUS_HIr
#define BKPMETERINGSTATUS_HIr_SIZE BCM56218_A0_BKPMETERINGSTATUS_HIr_SIZE
typedef BCM56218_A0_BKPMETERINGSTATUS_HIr_t BKPMETERINGSTATUS_HIr_t;
#define BKPMETERINGSTATUS_HIr_CLR BCM56218_A0_BKPMETERINGSTATUS_HIr_CLR
#define BKPMETERINGSTATUS_HIr_SET BCM56218_A0_BKPMETERINGSTATUS_HIr_SET
#define BKPMETERINGSTATUS_HIr_GET BCM56218_A0_BKPMETERINGSTATUS_HIr_GET
#define BKPMETERINGSTATUS_HIr_PORT_BITMAPf_GET BCM56218_A0_BKPMETERINGSTATUS_HIr_PORT_BITMAPf_GET
#define BKPMETERINGSTATUS_HIr_PORT_BITMAPf_SET BCM56218_A0_BKPMETERINGSTATUS_HIr_PORT_BITMAPf_SET
#define READ_BKPMETERINGSTATUS_HIr BCM56218_A0_READ_BKPMETERINGSTATUS_HIr
#define WRITE_BKPMETERINGSTATUS_HIr BCM56218_A0_WRITE_BKPMETERINGSTATUS_HIr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_BKPMETERINGSTATUS_HIr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  BKP_DISC_BMAP
 * BLOCKS:   IPIPE
 * DESC:     Back Pressure Discard Register - Lower Bitmap
 * SIZE:     32
 * FIELDS:
 *     PORT_BITMAP      Back Pressure Discard Bitmap 
 *
 ******************************************************************************/
#define BCM56218_A0_BKP_DISC_BMAPr 0x0e780112

#define BCM56218_A0_BKP_DISC_BMAPr_SIZE 4

/*
 * This structure should be used to declare and program BKP_DISC_BMAP.
 *
 */
typedef union BCM56218_A0_BKP_DISC_BMAPr_s {
	uint32_t v[1];
	uint32_t bkp_disc_bmap[1];
	uint32_t _bkp_disc_bmap;
} BCM56218_A0_BKP_DISC_BMAPr_t;

#define BCM56218_A0_BKP_DISC_BMAPr_CLR(r) (r).bkp_disc_bmap[0] = 0
#define BCM56218_A0_BKP_DISC_BMAPr_SET(r,d) (r).bkp_disc_bmap[0] = d
#define BCM56218_A0_BKP_DISC_BMAPr_GET(r) (r).bkp_disc_bmap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_BKP_DISC_BMAPr_PORT_BITMAPf_GET(r) ((r).bkp_disc_bmap[0])
#define BCM56218_A0_BKP_DISC_BMAPr_PORT_BITMAPf_SET(r,f) (r).bkp_disc_bmap[0]=((uint32_t)f)

/*
 * These macros can be used to access BKP_DISC_BMAP.
 *
 */
#define BCM56218_A0_READ_BKP_DISC_BMAPr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_BKP_DISC_BMAPr,(r._bkp_disc_bmap))
#define BCM56218_A0_WRITE_BKP_DISC_BMAPr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_BKP_DISC_BMAPr,&(r._bkp_disc_bmap))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BKP_DISC_BMAPr BCM56218_A0_BKP_DISC_BMAPr
#define BKP_DISC_BMAPr_SIZE BCM56218_A0_BKP_DISC_BMAPr_SIZE
typedef BCM56218_A0_BKP_DISC_BMAPr_t BKP_DISC_BMAPr_t;
#define BKP_DISC_BMAPr_CLR BCM56218_A0_BKP_DISC_BMAPr_CLR
#define BKP_DISC_BMAPr_SET BCM56218_A0_BKP_DISC_BMAPr_SET
#define BKP_DISC_BMAPr_GET BCM56218_A0_BKP_DISC_BMAPr_GET
#define BKP_DISC_BMAPr_PORT_BITMAPf_GET BCM56218_A0_BKP_DISC_BMAPr_PORT_BITMAPf_GET
#define BKP_DISC_BMAPr_PORT_BITMAPf_SET BCM56218_A0_BKP_DISC_BMAPr_PORT_BITMAPf_SET
#define READ_BKP_DISC_BMAPr BCM56218_A0_READ_BKP_DISC_BMAPr
#define WRITE_BKP_DISC_BMAPr BCM56218_A0_WRITE_BKP_DISC_BMAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_BKP_DISC_BMAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  BKP_DISC_BMAP_HI
 * BLOCKS:   IPIPE
 * DESC:     Back Pressure Discard Register - Upper Bitmap
 * SIZE:     32
 * FIELDS:
 *     PORT_BITMAP      Back Pressure Discard Bitmap 
 *
 ******************************************************************************/
#define BCM56218_A0_BKP_DISC_BMAP_HIr 0x0e780113

#define BCM56218_A0_BKP_DISC_BMAP_HIr_SIZE 4

/*
 * This structure should be used to declare and program BKP_DISC_BMAP_HI.
 *
 */
typedef union BCM56218_A0_BKP_DISC_BMAP_HIr_s {
	uint32_t v[1];
	uint32_t bkp_disc_bmap_hi[1];
	uint32_t _bkp_disc_bmap_hi;
} BCM56218_A0_BKP_DISC_BMAP_HIr_t;

#define BCM56218_A0_BKP_DISC_BMAP_HIr_CLR(r) (r).bkp_disc_bmap_hi[0] = 0
#define BCM56218_A0_BKP_DISC_BMAP_HIr_SET(r,d) (r).bkp_disc_bmap_hi[0] = d
#define BCM56218_A0_BKP_DISC_BMAP_HIr_GET(r) (r).bkp_disc_bmap_hi[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_BKP_DISC_BMAP_HIr_PORT_BITMAPf_GET(r) (((r).bkp_disc_bmap_hi[0]) & 0x3fffff)
#define BCM56218_A0_BKP_DISC_BMAP_HIr_PORT_BITMAPf_SET(r,f) (r).bkp_disc_bmap_hi[0]=(((r).bkp_disc_bmap_hi[0] & ~((uint32_t)0x3fffff)) | (((uint32_t)f) & 0x3fffff))

/*
 * These macros can be used to access BKP_DISC_BMAP_HI.
 *
 */
#define BCM56218_A0_READ_BKP_DISC_BMAP_HIr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_BKP_DISC_BMAP_HIr,(r._bkp_disc_bmap_hi))
#define BCM56218_A0_WRITE_BKP_DISC_BMAP_HIr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_BKP_DISC_BMAP_HIr,&(r._bkp_disc_bmap_hi))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BKP_DISC_BMAP_HIr BCM56218_A0_BKP_DISC_BMAP_HIr
#define BKP_DISC_BMAP_HIr_SIZE BCM56218_A0_BKP_DISC_BMAP_HIr_SIZE
typedef BCM56218_A0_BKP_DISC_BMAP_HIr_t BKP_DISC_BMAP_HIr_t;
#define BKP_DISC_BMAP_HIr_CLR BCM56218_A0_BKP_DISC_BMAP_HIr_CLR
#define BKP_DISC_BMAP_HIr_SET BCM56218_A0_BKP_DISC_BMAP_HIr_SET
#define BKP_DISC_BMAP_HIr_GET BCM56218_A0_BKP_DISC_BMAP_HIr_GET
#define BKP_DISC_BMAP_HIr_PORT_BITMAPf_GET BCM56218_A0_BKP_DISC_BMAP_HIr_PORT_BITMAPf_GET
#define BKP_DISC_BMAP_HIr_PORT_BITMAPf_SET BCM56218_A0_BKP_DISC_BMAP_HIr_PORT_BITMAPf_SET
#define READ_BKP_DISC_BMAP_HIr BCM56218_A0_READ_BKP_DISC_BMAP_HIr
#define WRITE_BKP_DISC_BMAP_HIr BCM56218_A0_WRITE_BKP_DISC_BMAP_HIr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_BKP_DISC_BMAP_HIr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  BSAFE_CMD_DATA_IN
 * BLOCKS:   BSAFE
 * DESC:     Command Data Out Register
 * SIZE:     32
 * FIELDS:
 *     CMD_DIN          Input data for command processing to the uHSM.
 *
 ******************************************************************************/
#define BCM56218_A0_BSAFE_CMD_DATA_INm 0x00b10000

#define BCM56218_A0_BSAFE_CMD_DATA_INm_MIN 0
#define BCM56218_A0_BSAFE_CMD_DATA_INm_MAX 255
#define BCM56218_A0_BSAFE_CMD_DATA_INm_CMAX(u) 255
#define BCM56218_A0_BSAFE_CMD_DATA_INm_SIZE 4

/*
 * This structure should be used to declare and program BSAFE_CMD_DATA_IN.
 *
 */
typedef union BCM56218_A0_BSAFE_CMD_DATA_INm_s {
	uint32_t v[1];
	uint32_t bsafe_cmd_data_in[1];
	uint32_t _bsafe_cmd_data_in;
} BCM56218_A0_BSAFE_CMD_DATA_INm_t;

#define BCM56218_A0_BSAFE_CMD_DATA_INm_CLR(r) (r).bsafe_cmd_data_in[0] = 0
#define BCM56218_A0_BSAFE_CMD_DATA_INm_SET(r,d) (r).bsafe_cmd_data_in[0] = d
#define BCM56218_A0_BSAFE_CMD_DATA_INm_GET(r) (r).bsafe_cmd_data_in[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_BSAFE_CMD_DATA_INm_CMD_DINf_GET(r) ((r).bsafe_cmd_data_in[0])
#define BCM56218_A0_BSAFE_CMD_DATA_INm_CMD_DINf_SET(r,f) (r).bsafe_cmd_data_in[0]=((uint32_t)f)

/*
 * These macros can be used to access BSAFE_CMD_DATA_IN.
 *
 */
#define BCM56218_A0_READ_BSAFE_CMD_DATA_INm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_BSAFE_CMD_DATA_INm,i,(m._bsafe_cmd_data_in),1)
#define BCM56218_A0_WRITE_BSAFE_CMD_DATA_INm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_BSAFE_CMD_DATA_INm,i,&(m._bsafe_cmd_data_in),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BSAFE_CMD_DATA_INm BCM56218_A0_BSAFE_CMD_DATA_INm
#define BSAFE_CMD_DATA_INm_MIN BCM56218_A0_BSAFE_CMD_DATA_INm_MIN
#define BSAFE_CMD_DATA_INm_MAX BCM56218_A0_BSAFE_CMD_DATA_INm_MAX
#define BSAFE_CMD_DATA_INm_CMAX(u) BCM56218_A0_BSAFE_CMD_DATA_INm_CMAX(u)
#define BSAFE_CMD_DATA_INm_SIZE BCM56218_A0_BSAFE_CMD_DATA_INm_SIZE
typedef BCM56218_A0_BSAFE_CMD_DATA_INm_t BSAFE_CMD_DATA_INm_t;
#define BSAFE_CMD_DATA_INm_CLR BCM56218_A0_BSAFE_CMD_DATA_INm_CLR
#define BSAFE_CMD_DATA_INm_SET BCM56218_A0_BSAFE_CMD_DATA_INm_SET
#define BSAFE_CMD_DATA_INm_GET BCM56218_A0_BSAFE_CMD_DATA_INm_GET
#define BSAFE_CMD_DATA_INm_CMD_DINf_GET BCM56218_A0_BSAFE_CMD_DATA_INm_CMD_DINf_GET
#define BSAFE_CMD_DATA_INm_CMD_DINf_SET BCM56218_A0_BSAFE_CMD_DATA_INm_CMD_DINf_SET
#define READ_BSAFE_CMD_DATA_INm BCM56218_A0_READ_BSAFE_CMD_DATA_INm
#define WRITE_BSAFE_CMD_DATA_INm BCM56218_A0_WRITE_BSAFE_CMD_DATA_INm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_BSAFE_CMD_DATA_INm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  BSAFE_CMD_DATA_OUT
 * BLOCKS:   BSAFE
 * DESC:     Command Data Out Register
 * SIZE:     32
 * FIELDS:
 *     CMD_DOUT         Output data for command processing from the uHSM.
 *
 ******************************************************************************/
#define BCM56218_A0_BSAFE_CMD_DATA_OUTm 0x00b20000

#define BCM56218_A0_BSAFE_CMD_DATA_OUTm_MIN 0
#define BCM56218_A0_BSAFE_CMD_DATA_OUTm_MAX 255
#define BCM56218_A0_BSAFE_CMD_DATA_OUTm_CMAX(u) 255
#define BCM56218_A0_BSAFE_CMD_DATA_OUTm_SIZE 4

/*
 * This structure should be used to declare and program BSAFE_CMD_DATA_OUT.
 *
 */
typedef union BCM56218_A0_BSAFE_CMD_DATA_OUTm_s {
	uint32_t v[1];
	uint32_t bsafe_cmd_data_out[1];
	uint32_t _bsafe_cmd_data_out;
} BCM56218_A0_BSAFE_CMD_DATA_OUTm_t;

#define BCM56218_A0_BSAFE_CMD_DATA_OUTm_CLR(r) (r).bsafe_cmd_data_out[0] = 0
#define BCM56218_A0_BSAFE_CMD_DATA_OUTm_SET(r,d) (r).bsafe_cmd_data_out[0] = d
#define BCM56218_A0_BSAFE_CMD_DATA_OUTm_GET(r) (r).bsafe_cmd_data_out[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_BSAFE_CMD_DATA_OUTm_CMD_DOUTf_GET(r) ((r).bsafe_cmd_data_out[0])
#define BCM56218_A0_BSAFE_CMD_DATA_OUTm_CMD_DOUTf_SET(r,f) (r).bsafe_cmd_data_out[0]=((uint32_t)f)

/*
 * These macros can be used to access BSAFE_CMD_DATA_OUT.
 *
 */
#define BCM56218_A0_READ_BSAFE_CMD_DATA_OUTm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_BSAFE_CMD_DATA_OUTm,i,(m._bsafe_cmd_data_out),1)
#define BCM56218_A0_WRITE_BSAFE_CMD_DATA_OUTm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_BSAFE_CMD_DATA_OUTm,i,&(m._bsafe_cmd_data_out),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BSAFE_CMD_DATA_OUTm BCM56218_A0_BSAFE_CMD_DATA_OUTm
#define BSAFE_CMD_DATA_OUTm_MIN BCM56218_A0_BSAFE_CMD_DATA_OUTm_MIN
#define BSAFE_CMD_DATA_OUTm_MAX BCM56218_A0_BSAFE_CMD_DATA_OUTm_MAX
#define BSAFE_CMD_DATA_OUTm_CMAX(u) BCM56218_A0_BSAFE_CMD_DATA_OUTm_CMAX(u)
#define BSAFE_CMD_DATA_OUTm_SIZE BCM56218_A0_BSAFE_CMD_DATA_OUTm_SIZE
typedef BCM56218_A0_BSAFE_CMD_DATA_OUTm_t BSAFE_CMD_DATA_OUTm_t;
#define BSAFE_CMD_DATA_OUTm_CLR BCM56218_A0_BSAFE_CMD_DATA_OUTm_CLR
#define BSAFE_CMD_DATA_OUTm_SET BCM56218_A0_BSAFE_CMD_DATA_OUTm_SET
#define BSAFE_CMD_DATA_OUTm_GET BCM56218_A0_BSAFE_CMD_DATA_OUTm_GET
#define BSAFE_CMD_DATA_OUTm_CMD_DOUTf_GET BCM56218_A0_BSAFE_CMD_DATA_OUTm_CMD_DOUTf_GET
#define BSAFE_CMD_DATA_OUTm_CMD_DOUTf_SET BCM56218_A0_BSAFE_CMD_DATA_OUTm_CMD_DOUTf_SET
#define READ_BSAFE_CMD_DATA_OUTm BCM56218_A0_READ_BSAFE_CMD_DATA_OUTm
#define WRITE_BSAFE_CMD_DATA_OUTm BCM56218_A0_WRITE_BSAFE_CMD_DATA_OUTm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_BSAFE_CMD_DATA_OUTm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  BSAFE_GLB_CMD_CTRL
 * BLOCKS:   BSAFE
 * DESC:     This register is used to control the command interface for the uHSM. The 
values in this register are used to control the GLB_CMD_DATA_IN and 
GLB_CMD_DATA_OUT data input registers.

 * SIZE:     32
 * FIELDS:
 *     CMD_IRDY         COMMAND INPUT READY: Indicates that the GLB_CMD_DATA_IN register is ready to accept data from the local interface.
 *     CMD_ISYNC        COMMAND INPUT SYNC: This bit is set high to indicate the start of a command packet to the uHSM. It is lowered to zero on the last word of the command packet.
 *     CMD_ORDY         COMMAND OUTPUT READY: Indicates that the GLB_CMD_DATA_OUT register contains valid data.
 *     CMD_OSYNC        COMMAND OUTPUT SYNC: This bit is set high by to indicate the start of a command packet response from the uHSM. It is lowered on the last word of the command packet to indicate the end of the response.
 *     RESERVED_4       Reserved.
 *     SOFT_RST         Initiates a soft reset of the uHSM block. The state of the entire block is cleared to the power on reset values.  The soft reset can be initiated by the local host via the external interface OR the master controller.
 *     GPI              General Purpose Input: The input value of the GPIO[2:0] pins.
 *     RESERVED_3       Reserved.
 *     GPO              General Purpose Output: The output value that the GPIO[2:0] are set to by the master controller.
 *     RESERVED_2       Reserved.
 *     GPEN             General Purpose Enable: Controls the enable signal on the bi-directional GPIO[2:0] pins.
 *     RESERVED_1       Reserved.
 *     REVID            The uHSM revision identification based on the RTL netlist/ROM version. This revision identifier can potentially be the same for multiple chips as it identifies the version of the uHSM only.  The uHSM master controller sets these bits from a value stored in ROM.
 *
 ******************************************************************************/
#define BCM56218_A0_BSAFE_GLB_CMD_CTRLr 0x00b80214

#define BCM56218_A0_BSAFE_GLB_CMD_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program BSAFE_GLB_CMD_CTRL.
 *
 */
typedef union BCM56218_A0_BSAFE_GLB_CMD_CTRLr_s {
	uint32_t v[1];
	uint32_t bsafe_glb_cmd_ctrl[1];
	uint32_t _bsafe_glb_cmd_ctrl;
} BCM56218_A0_BSAFE_GLB_CMD_CTRLr_t;

#define BCM56218_A0_BSAFE_GLB_CMD_CTRLr_CLR(r) (r).bsafe_glb_cmd_ctrl[0] = 0
#define BCM56218_A0_BSAFE_GLB_CMD_CTRLr_SET(r,d) (r).bsafe_glb_cmd_ctrl[0] = d
#define BCM56218_A0_BSAFE_GLB_CMD_CTRLr_GET(r) (r).bsafe_glb_cmd_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_BSAFE_GLB_CMD_CTRLr_CMD_IRDYf_GET(r) (((r).bsafe_glb_cmd_ctrl[0]) & 0x1)
#define BCM56218_A0_BSAFE_GLB_CMD_CTRLr_CMD_IRDYf_SET(r,f) (r).bsafe_glb_cmd_ctrl[0]=(((r).bsafe_glb_cmd_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_BSAFE_GLB_CMD_CTRLr_CMD_ISYNCf_GET(r) ((((r).bsafe_glb_cmd_ctrl[0]) >> 1) & 0x1)
#define BCM56218_A0_BSAFE_GLB_CMD_CTRLr_CMD_ISYNCf_SET(r,f) (r).bsafe_glb_cmd_ctrl[0]=(((r).bsafe_glb_cmd_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_BSAFE_GLB_CMD_CTRLr_CMD_ORDYf_GET(r) ((((r).bsafe_glb_cmd_ctrl[0]) >> 2) & 0x1)
#define BCM56218_A0_BSAFE_GLB_CMD_CTRLr_CMD_ORDYf_SET(r,f) (r).bsafe_glb_cmd_ctrl[0]=(((r).bsafe_glb_cmd_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_BSAFE_GLB_CMD_CTRLr_CMD_OSYNCf_GET(r) ((((r).bsafe_glb_cmd_ctrl[0]) >> 3) & 0x1)
#define BCM56218_A0_BSAFE_GLB_CMD_CTRLr_CMD_OSYNCf_SET(r,f) (r).bsafe_glb_cmd_ctrl[0]=(((r).bsafe_glb_cmd_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56218_A0_BSAFE_GLB_CMD_CTRLr_RESERVED_4f_GET(r) ((((r).bsafe_glb_cmd_ctrl[0]) >> 4) & 0x7)
#define BCM56218_A0_BSAFE_GLB_CMD_CTRLr_RESERVED_4f_SET(r,f) (r).bsafe_glb_cmd_ctrl[0]=(((r).bsafe_glb_cmd_ctrl[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4))
#define BCM56218_A0_BSAFE_GLB_CMD_CTRLr_SOFT_RSTf_GET(r) ((((r).bsafe_glb_cmd_ctrl[0]) >> 7) & 0x1)
#define BCM56218_A0_BSAFE_GLB_CMD_CTRLr_SOFT_RSTf_SET(r,f) (r).bsafe_glb_cmd_ctrl[0]=(((r).bsafe_glb_cmd_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56218_A0_BSAFE_GLB_CMD_CTRLr_GPIf_GET(r) ((((r).bsafe_glb_cmd_ctrl[0]) >> 8) & 0x7)
#define BCM56218_A0_BSAFE_GLB_CMD_CTRLr_GPIf_SET(r,f) (r).bsafe_glb_cmd_ctrl[0]=(((r).bsafe_glb_cmd_ctrl[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8))
#define BCM56218_A0_BSAFE_GLB_CMD_CTRLr_RESERVED_3f_GET(r) ((((r).bsafe_glb_cmd_ctrl[0]) >> 11) & 0x1)
#define BCM56218_A0_BSAFE_GLB_CMD_CTRLr_RESERVED_3f_SET(r,f) (r).bsafe_glb_cmd_ctrl[0]=(((r).bsafe_glb_cmd_ctrl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56218_A0_BSAFE_GLB_CMD_CTRLr_GPOf_GET(r) ((((r).bsafe_glb_cmd_ctrl[0]) >> 12) & 0x7)
#define BCM56218_A0_BSAFE_GLB_CMD_CTRLr_GPOf_SET(r,f) (r).bsafe_glb_cmd_ctrl[0]=(((r).bsafe_glb_cmd_ctrl[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM56218_A0_BSAFE_GLB_CMD_CTRLr_RESERVED_2f_GET(r) ((((r).bsafe_glb_cmd_ctrl[0]) >> 15) & 0x1)
#define BCM56218_A0_BSAFE_GLB_CMD_CTRLr_RESERVED_2f_SET(r,f) (r).bsafe_glb_cmd_ctrl[0]=(((r).bsafe_glb_cmd_ctrl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56218_A0_BSAFE_GLB_CMD_CTRLr_GPENf_GET(r) ((((r).bsafe_glb_cmd_ctrl[0]) >> 16) & 0x7)
#define BCM56218_A0_BSAFE_GLB_CMD_CTRLr_GPENf_SET(r,f) (r).bsafe_glb_cmd_ctrl[0]=(((r).bsafe_glb_cmd_ctrl[0] & ~((uint32_t)0x7 << 16)) | ((((uint32_t)f) & 0x7) << 16))
#define BCM56218_A0_BSAFE_GLB_CMD_CTRLr_RESERVED_1f_GET(r) ((((r).bsafe_glb_cmd_ctrl[0]) >> 19) & 0x1f)
#define BCM56218_A0_BSAFE_GLB_CMD_CTRLr_RESERVED_1f_SET(r,f) (r).bsafe_glb_cmd_ctrl[0]=(((r).bsafe_glb_cmd_ctrl[0] & ~((uint32_t)0x1f << 19)) | ((((uint32_t)f) & 0x1f) << 19))
#define BCM56218_A0_BSAFE_GLB_CMD_CTRLr_REVIDf_GET(r) ((((r).bsafe_glb_cmd_ctrl[0]) >> 24) & 0xff)
#define BCM56218_A0_BSAFE_GLB_CMD_CTRLr_REVIDf_SET(r,f) (r).bsafe_glb_cmd_ctrl[0]=(((r).bsafe_glb_cmd_ctrl[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access BSAFE_GLB_CMD_CTRL.
 *
 */
#define BCM56218_A0_READ_BSAFE_GLB_CMD_CTRLr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_BSAFE_GLB_CMD_CTRLr,(r._bsafe_glb_cmd_ctrl))
#define BCM56218_A0_WRITE_BSAFE_GLB_CMD_CTRLr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_BSAFE_GLB_CMD_CTRLr,&(r._bsafe_glb_cmd_ctrl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BSAFE_GLB_CMD_CTRLr BCM56218_A0_BSAFE_GLB_CMD_CTRLr
#define BSAFE_GLB_CMD_CTRLr_SIZE BCM56218_A0_BSAFE_GLB_CMD_CTRLr_SIZE
typedef BCM56218_A0_BSAFE_GLB_CMD_CTRLr_t BSAFE_GLB_CMD_CTRLr_t;
#define BSAFE_GLB_CMD_CTRLr_CLR BCM56218_A0_BSAFE_GLB_CMD_CTRLr_CLR
#define BSAFE_GLB_CMD_CTRLr_SET BCM56218_A0_BSAFE_GLB_CMD_CTRLr_SET
#define BSAFE_GLB_CMD_CTRLr_GET BCM56218_A0_BSAFE_GLB_CMD_CTRLr_GET
#define BSAFE_GLB_CMD_CTRLr_CMD_IRDYf_GET BCM56218_A0_BSAFE_GLB_CMD_CTRLr_CMD_IRDYf_GET
#define BSAFE_GLB_CMD_CTRLr_CMD_IRDYf_SET BCM56218_A0_BSAFE_GLB_CMD_CTRLr_CMD_IRDYf_SET
#define BSAFE_GLB_CMD_CTRLr_CMD_ISYNCf_GET BCM56218_A0_BSAFE_GLB_CMD_CTRLr_CMD_ISYNCf_GET
#define BSAFE_GLB_CMD_CTRLr_CMD_ISYNCf_SET BCM56218_A0_BSAFE_GLB_CMD_CTRLr_CMD_ISYNCf_SET
#define BSAFE_GLB_CMD_CTRLr_CMD_ORDYf_GET BCM56218_A0_BSAFE_GLB_CMD_CTRLr_CMD_ORDYf_GET
#define BSAFE_GLB_CMD_CTRLr_CMD_ORDYf_SET BCM56218_A0_BSAFE_GLB_CMD_CTRLr_CMD_ORDYf_SET
#define BSAFE_GLB_CMD_CTRLr_CMD_OSYNCf_GET BCM56218_A0_BSAFE_GLB_CMD_CTRLr_CMD_OSYNCf_GET
#define BSAFE_GLB_CMD_CTRLr_CMD_OSYNCf_SET BCM56218_A0_BSAFE_GLB_CMD_CTRLr_CMD_OSYNCf_SET
#define BSAFE_GLB_CMD_CTRLr_RESERVED_4f_GET BCM56218_A0_BSAFE_GLB_CMD_CTRLr_RESERVED_4f_GET
#define BSAFE_GLB_CMD_CTRLr_RESERVED_4f_SET BCM56218_A0_BSAFE_GLB_CMD_CTRLr_RESERVED_4f_SET
#define BSAFE_GLB_CMD_CTRLr_SOFT_RSTf_GET BCM56218_A0_BSAFE_GLB_CMD_CTRLr_SOFT_RSTf_GET
#define BSAFE_GLB_CMD_CTRLr_SOFT_RSTf_SET BCM56218_A0_BSAFE_GLB_CMD_CTRLr_SOFT_RSTf_SET
#define BSAFE_GLB_CMD_CTRLr_GPIf_GET BCM56218_A0_BSAFE_GLB_CMD_CTRLr_GPIf_GET
#define BSAFE_GLB_CMD_CTRLr_GPIf_SET BCM56218_A0_BSAFE_GLB_CMD_CTRLr_GPIf_SET
#define BSAFE_GLB_CMD_CTRLr_RESERVED_3f_GET BCM56218_A0_BSAFE_GLB_CMD_CTRLr_RESERVED_3f_GET
#define BSAFE_GLB_CMD_CTRLr_RESERVED_3f_SET BCM56218_A0_BSAFE_GLB_CMD_CTRLr_RESERVED_3f_SET
#define BSAFE_GLB_CMD_CTRLr_GPOf_GET BCM56218_A0_BSAFE_GLB_CMD_CTRLr_GPOf_GET
#define BSAFE_GLB_CMD_CTRLr_GPOf_SET BCM56218_A0_BSAFE_GLB_CMD_CTRLr_GPOf_SET
#define BSAFE_GLB_CMD_CTRLr_RESERVED_2f_GET BCM56218_A0_BSAFE_GLB_CMD_CTRLr_RESERVED_2f_GET
#define BSAFE_GLB_CMD_CTRLr_RESERVED_2f_SET BCM56218_A0_BSAFE_GLB_CMD_CTRLr_RESERVED_2f_SET
#define BSAFE_GLB_CMD_CTRLr_GPENf_GET BCM56218_A0_BSAFE_GLB_CMD_CTRLr_GPENf_GET
#define BSAFE_GLB_CMD_CTRLr_GPENf_SET BCM56218_A0_BSAFE_GLB_CMD_CTRLr_GPENf_SET
#define BSAFE_GLB_CMD_CTRLr_RESERVED_1f_GET BCM56218_A0_BSAFE_GLB_CMD_CTRLr_RESERVED_1f_GET
#define BSAFE_GLB_CMD_CTRLr_RESERVED_1f_SET BCM56218_A0_BSAFE_GLB_CMD_CTRLr_RESERVED_1f_SET
#define BSAFE_GLB_CMD_CTRLr_REVIDf_GET BCM56218_A0_BSAFE_GLB_CMD_CTRLr_REVIDf_GET
#define BSAFE_GLB_CMD_CTRLr_REVIDf_SET BCM56218_A0_BSAFE_GLB_CMD_CTRLr_REVIDf_SET
#define READ_BSAFE_GLB_CMD_CTRLr BCM56218_A0_READ_BSAFE_GLB_CMD_CTRLr
#define WRITE_BSAFE_GLB_CMD_CTRLr BCM56218_A0_WRITE_BSAFE_GLB_CMD_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_BSAFE_GLB_CMD_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  BSAFE_GLB_CMD_DATA_IN
 * BLOCKS:   BSAFE
 * DESC:     Command Data In Register.

 * SIZE:     32
 * FIELDS:
 *     CMD_DIN          Input data for command processing to the uHSM.
 *
 ******************************************************************************/
#define BCM56218_A0_BSAFE_GLB_CMD_DATA_INr 0x00b80218

#define BCM56218_A0_BSAFE_GLB_CMD_DATA_INr_SIZE 4

/*
 * This structure should be used to declare and program BSAFE_GLB_CMD_DATA_IN.
 *
 */
typedef union BCM56218_A0_BSAFE_GLB_CMD_DATA_INr_s {
	uint32_t v[1];
	uint32_t bsafe_glb_cmd_data_in[1];
	uint32_t _bsafe_glb_cmd_data_in;
} BCM56218_A0_BSAFE_GLB_CMD_DATA_INr_t;

#define BCM56218_A0_BSAFE_GLB_CMD_DATA_INr_CLR(r) (r).bsafe_glb_cmd_data_in[0] = 0
#define BCM56218_A0_BSAFE_GLB_CMD_DATA_INr_SET(r,d) (r).bsafe_glb_cmd_data_in[0] = d
#define BCM56218_A0_BSAFE_GLB_CMD_DATA_INr_GET(r) (r).bsafe_glb_cmd_data_in[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_BSAFE_GLB_CMD_DATA_INr_CMD_DINf_GET(r) ((r).bsafe_glb_cmd_data_in[0])
#define BCM56218_A0_BSAFE_GLB_CMD_DATA_INr_CMD_DINf_SET(r,f) (r).bsafe_glb_cmd_data_in[0]=((uint32_t)f)

/*
 * These macros can be used to access BSAFE_GLB_CMD_DATA_IN.
 *
 */
#define BCM56218_A0_READ_BSAFE_GLB_CMD_DATA_INr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_BSAFE_GLB_CMD_DATA_INr,(r._bsafe_glb_cmd_data_in))
#define BCM56218_A0_WRITE_BSAFE_GLB_CMD_DATA_INr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_BSAFE_GLB_CMD_DATA_INr,&(r._bsafe_glb_cmd_data_in))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BSAFE_GLB_CMD_DATA_INr BCM56218_A0_BSAFE_GLB_CMD_DATA_INr
#define BSAFE_GLB_CMD_DATA_INr_SIZE BCM56218_A0_BSAFE_GLB_CMD_DATA_INr_SIZE
typedef BCM56218_A0_BSAFE_GLB_CMD_DATA_INr_t BSAFE_GLB_CMD_DATA_INr_t;
#define BSAFE_GLB_CMD_DATA_INr_CLR BCM56218_A0_BSAFE_GLB_CMD_DATA_INr_CLR
#define BSAFE_GLB_CMD_DATA_INr_SET BCM56218_A0_BSAFE_GLB_CMD_DATA_INr_SET
#define BSAFE_GLB_CMD_DATA_INr_GET BCM56218_A0_BSAFE_GLB_CMD_DATA_INr_GET
#define BSAFE_GLB_CMD_DATA_INr_CMD_DINf_GET BCM56218_A0_BSAFE_GLB_CMD_DATA_INr_CMD_DINf_GET
#define BSAFE_GLB_CMD_DATA_INr_CMD_DINf_SET BCM56218_A0_BSAFE_GLB_CMD_DATA_INr_CMD_DINf_SET
#define READ_BSAFE_GLB_CMD_DATA_INr BCM56218_A0_READ_BSAFE_GLB_CMD_DATA_INr
#define WRITE_BSAFE_GLB_CMD_DATA_INr BCM56218_A0_WRITE_BSAFE_GLB_CMD_DATA_INr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_BSAFE_GLB_CMD_DATA_INr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  BSAFE_GLB_CMD_DATA_OUT
 * BLOCKS:   BSAFE
 * DESC:     Command Data Out Register.

 * SIZE:     32
 * FIELDS:
 *     CMD_DIN          Output data for command processing from the uHSM.
 *
 ******************************************************************************/
#define BCM56218_A0_BSAFE_GLB_CMD_DATA_OUTr 0x00b8021c

#define BCM56218_A0_BSAFE_GLB_CMD_DATA_OUTr_SIZE 4

/*
 * This structure should be used to declare and program BSAFE_GLB_CMD_DATA_OUT.
 *
 */
typedef union BCM56218_A0_BSAFE_GLB_CMD_DATA_OUTr_s {
	uint32_t v[1];
	uint32_t bsafe_glb_cmd_data_out[1];
	uint32_t _bsafe_glb_cmd_data_out;
} BCM56218_A0_BSAFE_GLB_CMD_DATA_OUTr_t;

#define BCM56218_A0_BSAFE_GLB_CMD_DATA_OUTr_CLR(r) (r).bsafe_glb_cmd_data_out[0] = 0
#define BCM56218_A0_BSAFE_GLB_CMD_DATA_OUTr_SET(r,d) (r).bsafe_glb_cmd_data_out[0] = d
#define BCM56218_A0_BSAFE_GLB_CMD_DATA_OUTr_GET(r) (r).bsafe_glb_cmd_data_out[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_BSAFE_GLB_CMD_DATA_OUTr_CMD_DINf_GET(r) ((r).bsafe_glb_cmd_data_out[0])
#define BCM56218_A0_BSAFE_GLB_CMD_DATA_OUTr_CMD_DINf_SET(r,f) (r).bsafe_glb_cmd_data_out[0]=((uint32_t)f)

/*
 * These macros can be used to access BSAFE_GLB_CMD_DATA_OUT.
 *
 */
#define BCM56218_A0_READ_BSAFE_GLB_CMD_DATA_OUTr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_BSAFE_GLB_CMD_DATA_OUTr,(r._bsafe_glb_cmd_data_out))
#define BCM56218_A0_WRITE_BSAFE_GLB_CMD_DATA_OUTr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_BSAFE_GLB_CMD_DATA_OUTr,&(r._bsafe_glb_cmd_data_out))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BSAFE_GLB_CMD_DATA_OUTr BCM56218_A0_BSAFE_GLB_CMD_DATA_OUTr
#define BSAFE_GLB_CMD_DATA_OUTr_SIZE BCM56218_A0_BSAFE_GLB_CMD_DATA_OUTr_SIZE
typedef BCM56218_A0_BSAFE_GLB_CMD_DATA_OUTr_t BSAFE_GLB_CMD_DATA_OUTr_t;
#define BSAFE_GLB_CMD_DATA_OUTr_CLR BCM56218_A0_BSAFE_GLB_CMD_DATA_OUTr_CLR
#define BSAFE_GLB_CMD_DATA_OUTr_SET BCM56218_A0_BSAFE_GLB_CMD_DATA_OUTr_SET
#define BSAFE_GLB_CMD_DATA_OUTr_GET BCM56218_A0_BSAFE_GLB_CMD_DATA_OUTr_GET
#define BSAFE_GLB_CMD_DATA_OUTr_CMD_DINf_GET BCM56218_A0_BSAFE_GLB_CMD_DATA_OUTr_CMD_DINf_GET
#define BSAFE_GLB_CMD_DATA_OUTr_CMD_DINf_SET BCM56218_A0_BSAFE_GLB_CMD_DATA_OUTr_CMD_DINf_SET
#define READ_BSAFE_GLB_CMD_DATA_OUTr BCM56218_A0_READ_BSAFE_GLB_CMD_DATA_OUTr
#define WRITE_BSAFE_GLB_CMD_DATA_OUTr BCM56218_A0_WRITE_BSAFE_GLB_CMD_DATA_OUTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_BSAFE_GLB_CMD_DATA_OUTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  BSAFE_GLB_DEV_STATUS
 * BLOCKS:   BSAFE
 * DESC:     The status register is accessible by the local host at any time to indicate 
the current status of the uHSM. The local host must use the GLB_STATUS.BUSY 
bits to determine when it can access the data buffer via external interface.

 * SIZE:     32
 * FIELDS:
 *     BUSY             These bits lock out access to the command registers.  It indicates that the uHSM block is busy processing a command.  On reset, these bits will indicate busy until the master controller is ready to accept commands (INIT_DONE=1).
 *     INIT_KEY         Indicates directly from the security bits of the OTP array that the device keyis initialized.
 *     INIT_DONE        Indicates that initialization has competed.
 *     KS_ACTIVE        Key session setup have been completed and the session is active.
 *     RESERVED_2       Reserved.
 *     PROD_CFG_VLD     This flag is set when the prod_config register is initializedwith the value stored in NVM. Setting this flag informsthe external world that the content of theprod_config register is good to be sampled.
 *     RESERVED_1       Reserved.
 *
 ******************************************************************************/
#define BCM56218_A0_BSAFE_GLB_DEV_STATUSr 0x00b80210

#define BCM56218_A0_BSAFE_GLB_DEV_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program BSAFE_GLB_DEV_STATUS.
 *
 */
typedef union BCM56218_A0_BSAFE_GLB_DEV_STATUSr_s {
	uint32_t v[1];
	uint32_t bsafe_glb_dev_status[1];
	uint32_t _bsafe_glb_dev_status;
} BCM56218_A0_BSAFE_GLB_DEV_STATUSr_t;

#define BCM56218_A0_BSAFE_GLB_DEV_STATUSr_CLR(r) (r).bsafe_glb_dev_status[0] = 0
#define BCM56218_A0_BSAFE_GLB_DEV_STATUSr_SET(r,d) (r).bsafe_glb_dev_status[0] = d
#define BCM56218_A0_BSAFE_GLB_DEV_STATUSr_GET(r) (r).bsafe_glb_dev_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_BSAFE_GLB_DEV_STATUSr_BUSYf_GET(r) (((r).bsafe_glb_dev_status[0]) & 0x3)
#define BCM56218_A0_BSAFE_GLB_DEV_STATUSr_BUSYf_SET(r,f) (r).bsafe_glb_dev_status[0]=(((r).bsafe_glb_dev_status[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56218_A0_BSAFE_GLB_DEV_STATUSr_INIT_KEYf_GET(r) ((((r).bsafe_glb_dev_status[0]) >> 2) & 0x3)
#define BCM56218_A0_BSAFE_GLB_DEV_STATUSr_INIT_KEYf_SET(r,f) (r).bsafe_glb_dev_status[0]=(((r).bsafe_glb_dev_status[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM56218_A0_BSAFE_GLB_DEV_STATUSr_INIT_DONEf_GET(r) ((((r).bsafe_glb_dev_status[0]) >> 4) & 0x1)
#define BCM56218_A0_BSAFE_GLB_DEV_STATUSr_INIT_DONEf_SET(r,f) (r).bsafe_glb_dev_status[0]=(((r).bsafe_glb_dev_status[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56218_A0_BSAFE_GLB_DEV_STATUSr_KS_ACTIVEf_GET(r) ((((r).bsafe_glb_dev_status[0]) >> 5) & 0x1)
#define BCM56218_A0_BSAFE_GLB_DEV_STATUSr_KS_ACTIVEf_SET(r,f) (r).bsafe_glb_dev_status[0]=(((r).bsafe_glb_dev_status[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56218_A0_BSAFE_GLB_DEV_STATUSr_RESERVED_2f_GET(r) ((((r).bsafe_glb_dev_status[0]) >> 6) & 0x1)
#define BCM56218_A0_BSAFE_GLB_DEV_STATUSr_RESERVED_2f_SET(r,f) (r).bsafe_glb_dev_status[0]=(((r).bsafe_glb_dev_status[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56218_A0_BSAFE_GLB_DEV_STATUSr_PROD_CFG_VLDf_GET(r) ((((r).bsafe_glb_dev_status[0]) >> 7) & 0x1)
#define BCM56218_A0_BSAFE_GLB_DEV_STATUSr_PROD_CFG_VLDf_SET(r,f) (r).bsafe_glb_dev_status[0]=(((r).bsafe_glb_dev_status[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56218_A0_BSAFE_GLB_DEV_STATUSr_RESERVED_1f_GET(r) ((((r).bsafe_glb_dev_status[0]) >> 8) & 0xffffff)
#define BCM56218_A0_BSAFE_GLB_DEV_STATUSr_RESERVED_1f_SET(r,f) (r).bsafe_glb_dev_status[0]=(((r).bsafe_glb_dev_status[0] & ~((uint32_t)0xffffff << 8)) | ((((uint32_t)f) & 0xffffff) << 8))

/*
 * These macros can be used to access BSAFE_GLB_DEV_STATUS.
 *
 */
#define BCM56218_A0_READ_BSAFE_GLB_DEV_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_BSAFE_GLB_DEV_STATUSr,(r._bsafe_glb_dev_status))
#define BCM56218_A0_WRITE_BSAFE_GLB_DEV_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_BSAFE_GLB_DEV_STATUSr,&(r._bsafe_glb_dev_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BSAFE_GLB_DEV_STATUSr BCM56218_A0_BSAFE_GLB_DEV_STATUSr
#define BSAFE_GLB_DEV_STATUSr_SIZE BCM56218_A0_BSAFE_GLB_DEV_STATUSr_SIZE
typedef BCM56218_A0_BSAFE_GLB_DEV_STATUSr_t BSAFE_GLB_DEV_STATUSr_t;
#define BSAFE_GLB_DEV_STATUSr_CLR BCM56218_A0_BSAFE_GLB_DEV_STATUSr_CLR
#define BSAFE_GLB_DEV_STATUSr_SET BCM56218_A0_BSAFE_GLB_DEV_STATUSr_SET
#define BSAFE_GLB_DEV_STATUSr_GET BCM56218_A0_BSAFE_GLB_DEV_STATUSr_GET
#define BSAFE_GLB_DEV_STATUSr_BUSYf_GET BCM56218_A0_BSAFE_GLB_DEV_STATUSr_BUSYf_GET
#define BSAFE_GLB_DEV_STATUSr_BUSYf_SET BCM56218_A0_BSAFE_GLB_DEV_STATUSr_BUSYf_SET
#define BSAFE_GLB_DEV_STATUSr_INIT_KEYf_GET BCM56218_A0_BSAFE_GLB_DEV_STATUSr_INIT_KEYf_GET
#define BSAFE_GLB_DEV_STATUSr_INIT_KEYf_SET BCM56218_A0_BSAFE_GLB_DEV_STATUSr_INIT_KEYf_SET
#define BSAFE_GLB_DEV_STATUSr_INIT_DONEf_GET BCM56218_A0_BSAFE_GLB_DEV_STATUSr_INIT_DONEf_GET
#define BSAFE_GLB_DEV_STATUSr_INIT_DONEf_SET BCM56218_A0_BSAFE_GLB_DEV_STATUSr_INIT_DONEf_SET
#define BSAFE_GLB_DEV_STATUSr_KS_ACTIVEf_GET BCM56218_A0_BSAFE_GLB_DEV_STATUSr_KS_ACTIVEf_GET
#define BSAFE_GLB_DEV_STATUSr_KS_ACTIVEf_SET BCM56218_A0_BSAFE_GLB_DEV_STATUSr_KS_ACTIVEf_SET
#define BSAFE_GLB_DEV_STATUSr_RESERVED_2f_GET BCM56218_A0_BSAFE_GLB_DEV_STATUSr_RESERVED_2f_GET
#define BSAFE_GLB_DEV_STATUSr_RESERVED_2f_SET BCM56218_A0_BSAFE_GLB_DEV_STATUSr_RESERVED_2f_SET
#define BSAFE_GLB_DEV_STATUSr_PROD_CFG_VLDf_GET BCM56218_A0_BSAFE_GLB_DEV_STATUSr_PROD_CFG_VLDf_GET
#define BSAFE_GLB_DEV_STATUSr_PROD_CFG_VLDf_SET BCM56218_A0_BSAFE_GLB_DEV_STATUSr_PROD_CFG_VLDf_SET
#define BSAFE_GLB_DEV_STATUSr_RESERVED_1f_GET BCM56218_A0_BSAFE_GLB_DEV_STATUSr_RESERVED_1f_GET
#define BSAFE_GLB_DEV_STATUSr_RESERVED_1f_SET BCM56218_A0_BSAFE_GLB_DEV_STATUSr_RESERVED_1f_SET
#define READ_BSAFE_GLB_DEV_STATUSr BCM56218_A0_READ_BSAFE_GLB_DEV_STATUSr
#define WRITE_BSAFE_GLB_DEV_STATUSr BCM56218_A0_WRITE_BSAFE_GLB_DEV_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_BSAFE_GLB_DEV_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  BSAFE_GLB_INT_CTRL
 * BLOCKS:   BSAFE
 * DESC:     Command Data Out Register.

 * SIZE:     32
 * FIELDS:
 *     SRC_CDONE        COMMAND DONE: Indicates that the uHSM has completed a command.
 *     SRC_CERR         COMMAND ERROR: Indicates that the uHSM has completed a command that returns a non-zero returnCode.
 *     SRC_RDY          READY: Indicates that the uHSM is ready to accept a command.
 *     RESERVED_3       Reserved.
 *     SRC_SAL          SECURITY ASSURANCE LOGIC: Indicates that the SAL has triggered an interrupt. The SAL status register should be read for more information.
 *     RESERVED_2       Reserved.
 *     INT_SRC_EN       INTERRUPT SOURCE ENABLE: The interrupt mask register. Each bit corresponds to an individual interrupt source defined in SRC_xxxx[3:0]
 *     RESERVED_1       Reserved.
 *
 ******************************************************************************/
#define BCM56218_A0_BSAFE_GLB_INT_CTRLr 0x00b80220

#define BCM56218_A0_BSAFE_GLB_INT_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program BSAFE_GLB_INT_CTRL.
 *
 */
typedef union BCM56218_A0_BSAFE_GLB_INT_CTRLr_s {
	uint32_t v[1];
	uint32_t bsafe_glb_int_ctrl[1];
	uint32_t _bsafe_glb_int_ctrl;
} BCM56218_A0_BSAFE_GLB_INT_CTRLr_t;

#define BCM56218_A0_BSAFE_GLB_INT_CTRLr_CLR(r) (r).bsafe_glb_int_ctrl[0] = 0
#define BCM56218_A0_BSAFE_GLB_INT_CTRLr_SET(r,d) (r).bsafe_glb_int_ctrl[0] = d
#define BCM56218_A0_BSAFE_GLB_INT_CTRLr_GET(r) (r).bsafe_glb_int_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_BSAFE_GLB_INT_CTRLr_SRC_CDONEf_GET(r) (((r).bsafe_glb_int_ctrl[0]) & 0x1)
#define BCM56218_A0_BSAFE_GLB_INT_CTRLr_SRC_CDONEf_SET(r,f) (r).bsafe_glb_int_ctrl[0]=(((r).bsafe_glb_int_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_BSAFE_GLB_INT_CTRLr_SRC_CERRf_GET(r) ((((r).bsafe_glb_int_ctrl[0]) >> 1) & 0x1)
#define BCM56218_A0_BSAFE_GLB_INT_CTRLr_SRC_CERRf_SET(r,f) (r).bsafe_glb_int_ctrl[0]=(((r).bsafe_glb_int_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_BSAFE_GLB_INT_CTRLr_SRC_RDYf_GET(r) ((((r).bsafe_glb_int_ctrl[0]) >> 2) & 0x1)
#define BCM56218_A0_BSAFE_GLB_INT_CTRLr_SRC_RDYf_SET(r,f) (r).bsafe_glb_int_ctrl[0]=(((r).bsafe_glb_int_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_BSAFE_GLB_INT_CTRLr_RESERVED_3f_GET(r) ((((r).bsafe_glb_int_ctrl[0]) >> 3) & 0x1)
#define BCM56218_A0_BSAFE_GLB_INT_CTRLr_RESERVED_3f_SET(r,f) (r).bsafe_glb_int_ctrl[0]=(((r).bsafe_glb_int_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56218_A0_BSAFE_GLB_INT_CTRLr_SRC_SALf_GET(r) ((((r).bsafe_glb_int_ctrl[0]) >> 4) & 0x1)
#define BCM56218_A0_BSAFE_GLB_INT_CTRLr_SRC_SALf_SET(r,f) (r).bsafe_glb_int_ctrl[0]=(((r).bsafe_glb_int_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56218_A0_BSAFE_GLB_INT_CTRLr_RESERVED_2f_GET(r) ((((r).bsafe_glb_int_ctrl[0]) >> 5) & 0x7)
#define BCM56218_A0_BSAFE_GLB_INT_CTRLr_RESERVED_2f_SET(r,f) (r).bsafe_glb_int_ctrl[0]=(((r).bsafe_glb_int_ctrl[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))
#define BCM56218_A0_BSAFE_GLB_INT_CTRLr_INT_SRC_ENf_GET(r) ((((r).bsafe_glb_int_ctrl[0]) >> 8) & 0x1f)
#define BCM56218_A0_BSAFE_GLB_INT_CTRLr_INT_SRC_ENf_SET(r,f) (r).bsafe_glb_int_ctrl[0]=(((r).bsafe_glb_int_ctrl[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56218_A0_BSAFE_GLB_INT_CTRLr_RESERVED_1f_GET(r) ((((r).bsafe_glb_int_ctrl[0]) >> 13) & 0x7ffff)
#define BCM56218_A0_BSAFE_GLB_INT_CTRLr_RESERVED_1f_SET(r,f) (r).bsafe_glb_int_ctrl[0]=(((r).bsafe_glb_int_ctrl[0] & ~((uint32_t)0x7ffff << 13)) | ((((uint32_t)f) & 0x7ffff) << 13))

/*
 * These macros can be used to access BSAFE_GLB_INT_CTRL.
 *
 */
#define BCM56218_A0_READ_BSAFE_GLB_INT_CTRLr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_BSAFE_GLB_INT_CTRLr,(r._bsafe_glb_int_ctrl))
#define BCM56218_A0_WRITE_BSAFE_GLB_INT_CTRLr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_BSAFE_GLB_INT_CTRLr,&(r._bsafe_glb_int_ctrl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BSAFE_GLB_INT_CTRLr BCM56218_A0_BSAFE_GLB_INT_CTRLr
#define BSAFE_GLB_INT_CTRLr_SIZE BCM56218_A0_BSAFE_GLB_INT_CTRLr_SIZE
typedef BCM56218_A0_BSAFE_GLB_INT_CTRLr_t BSAFE_GLB_INT_CTRLr_t;
#define BSAFE_GLB_INT_CTRLr_CLR BCM56218_A0_BSAFE_GLB_INT_CTRLr_CLR
#define BSAFE_GLB_INT_CTRLr_SET BCM56218_A0_BSAFE_GLB_INT_CTRLr_SET
#define BSAFE_GLB_INT_CTRLr_GET BCM56218_A0_BSAFE_GLB_INT_CTRLr_GET
#define BSAFE_GLB_INT_CTRLr_SRC_CDONEf_GET BCM56218_A0_BSAFE_GLB_INT_CTRLr_SRC_CDONEf_GET
#define BSAFE_GLB_INT_CTRLr_SRC_CDONEf_SET BCM56218_A0_BSAFE_GLB_INT_CTRLr_SRC_CDONEf_SET
#define BSAFE_GLB_INT_CTRLr_SRC_CERRf_GET BCM56218_A0_BSAFE_GLB_INT_CTRLr_SRC_CERRf_GET
#define BSAFE_GLB_INT_CTRLr_SRC_CERRf_SET BCM56218_A0_BSAFE_GLB_INT_CTRLr_SRC_CERRf_SET
#define BSAFE_GLB_INT_CTRLr_SRC_RDYf_GET BCM56218_A0_BSAFE_GLB_INT_CTRLr_SRC_RDYf_GET
#define BSAFE_GLB_INT_CTRLr_SRC_RDYf_SET BCM56218_A0_BSAFE_GLB_INT_CTRLr_SRC_RDYf_SET
#define BSAFE_GLB_INT_CTRLr_RESERVED_3f_GET BCM56218_A0_BSAFE_GLB_INT_CTRLr_RESERVED_3f_GET
#define BSAFE_GLB_INT_CTRLr_RESERVED_3f_SET BCM56218_A0_BSAFE_GLB_INT_CTRLr_RESERVED_3f_SET
#define BSAFE_GLB_INT_CTRLr_SRC_SALf_GET BCM56218_A0_BSAFE_GLB_INT_CTRLr_SRC_SALf_GET
#define BSAFE_GLB_INT_CTRLr_SRC_SALf_SET BCM56218_A0_BSAFE_GLB_INT_CTRLr_SRC_SALf_SET
#define BSAFE_GLB_INT_CTRLr_RESERVED_2f_GET BCM56218_A0_BSAFE_GLB_INT_CTRLr_RESERVED_2f_GET
#define BSAFE_GLB_INT_CTRLr_RESERVED_2f_SET BCM56218_A0_BSAFE_GLB_INT_CTRLr_RESERVED_2f_SET
#define BSAFE_GLB_INT_CTRLr_INT_SRC_ENf_GET BCM56218_A0_BSAFE_GLB_INT_CTRLr_INT_SRC_ENf_GET
#define BSAFE_GLB_INT_CTRLr_INT_SRC_ENf_SET BCM56218_A0_BSAFE_GLB_INT_CTRLr_INT_SRC_ENf_SET
#define BSAFE_GLB_INT_CTRLr_RESERVED_1f_GET BCM56218_A0_BSAFE_GLB_INT_CTRLr_RESERVED_1f_GET
#define BSAFE_GLB_INT_CTRLr_RESERVED_1f_SET BCM56218_A0_BSAFE_GLB_INT_CTRLr_RESERVED_1f_SET
#define READ_BSAFE_GLB_INT_CTRLr BCM56218_A0_READ_BSAFE_GLB_INT_CTRLr
#define WRITE_BSAFE_GLB_INT_CTRLr BCM56218_A0_WRITE_BSAFE_GLB_INT_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_BSAFE_GLB_INT_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  BSAFE_GLB_PRESCALE
 * BLOCKS:   BSAFE
 * DESC:     The reference clock (refclk) input is pre-scaled to provide a nominal 1 second 
clock tick used to increment the GLB_TIMER register. The reference clock is 
divided by four in the reference clock domain, then synchronized to the core 
clock domain.  The core clock input must be equal to or greater than the 
reference clock input for all frequencies. The divide by four ensures that 
the reference clock is sampled properly. Therefore, the time tick is calculated
as follows: period = (refclk period * PRESCALE * 4)
When the refclk is 6.25MHz, the prescalar should have the value 0x17D784. When 
the refclk is 62.5MHz, the prescalar should have the value 0xEE6B28.
This register is write-once protected. It can only be written one time
by an sbus write access. Further write attempts are ignored by uHSM.

 * SIZE:     32
 * FIELDS:
 *     PRESCALE         Pre-scalar value for the system time tick. The defaultvalue assumes a 6.25MHz reference system clock input.The value of this register can only be initialized onceafter each hardware reset. Subsequent write operations tothis register through the register access interface will nothave any effect.
 *     RESERVED_1       Reserved.
 *
 ******************************************************************************/
#define BCM56218_A0_BSAFE_GLB_PRESCALEr 0x00b80204

#define BCM56218_A0_BSAFE_GLB_PRESCALEr_SIZE 4

/*
 * This structure should be used to declare and program BSAFE_GLB_PRESCALE.
 *
 */
typedef union BCM56218_A0_BSAFE_GLB_PRESCALEr_s {
	uint32_t v[1];
	uint32_t bsafe_glb_prescale[1];
	uint32_t _bsafe_glb_prescale;
} BCM56218_A0_BSAFE_GLB_PRESCALEr_t;

#define BCM56218_A0_BSAFE_GLB_PRESCALEr_CLR(r) (r).bsafe_glb_prescale[0] = 0
#define BCM56218_A0_BSAFE_GLB_PRESCALEr_SET(r,d) (r).bsafe_glb_prescale[0] = d
#define BCM56218_A0_BSAFE_GLB_PRESCALEr_GET(r) (r).bsafe_glb_prescale[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_BSAFE_GLB_PRESCALEr_PRESCALEf_GET(r) (((r).bsafe_glb_prescale[0]) & 0xffffff)
#define BCM56218_A0_BSAFE_GLB_PRESCALEr_PRESCALEf_SET(r,f) (r).bsafe_glb_prescale[0]=(((r).bsafe_glb_prescale[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))
#define BCM56218_A0_BSAFE_GLB_PRESCALEr_RESERVED_1f_GET(r) ((((r).bsafe_glb_prescale[0]) >> 24) & 0xff)
#define BCM56218_A0_BSAFE_GLB_PRESCALEr_RESERVED_1f_SET(r,f) (r).bsafe_glb_prescale[0]=(((r).bsafe_glb_prescale[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access BSAFE_GLB_PRESCALE.
 *
 */
#define BCM56218_A0_READ_BSAFE_GLB_PRESCALEr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_BSAFE_GLB_PRESCALEr,(r._bsafe_glb_prescale))
#define BCM56218_A0_WRITE_BSAFE_GLB_PRESCALEr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_BSAFE_GLB_PRESCALEr,&(r._bsafe_glb_prescale))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BSAFE_GLB_PRESCALEr BCM56218_A0_BSAFE_GLB_PRESCALEr
#define BSAFE_GLB_PRESCALEr_SIZE BCM56218_A0_BSAFE_GLB_PRESCALEr_SIZE
typedef BCM56218_A0_BSAFE_GLB_PRESCALEr_t BSAFE_GLB_PRESCALEr_t;
#define BSAFE_GLB_PRESCALEr_CLR BCM56218_A0_BSAFE_GLB_PRESCALEr_CLR
#define BSAFE_GLB_PRESCALEr_SET BCM56218_A0_BSAFE_GLB_PRESCALEr_SET
#define BSAFE_GLB_PRESCALEr_GET BCM56218_A0_BSAFE_GLB_PRESCALEr_GET
#define BSAFE_GLB_PRESCALEr_PRESCALEf_GET BCM56218_A0_BSAFE_GLB_PRESCALEr_PRESCALEf_GET
#define BSAFE_GLB_PRESCALEr_PRESCALEf_SET BCM56218_A0_BSAFE_GLB_PRESCALEr_PRESCALEf_SET
#define BSAFE_GLB_PRESCALEr_RESERVED_1f_GET BCM56218_A0_BSAFE_GLB_PRESCALEr_RESERVED_1f_GET
#define BSAFE_GLB_PRESCALEr_RESERVED_1f_SET BCM56218_A0_BSAFE_GLB_PRESCALEr_RESERVED_1f_SET
#define READ_BSAFE_GLB_PRESCALEr BCM56218_A0_READ_BSAFE_GLB_PRESCALEr
#define WRITE_BSAFE_GLB_PRESCALEr BCM56218_A0_WRITE_BSAFE_GLB_PRESCALEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_BSAFE_GLB_PRESCALEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  BSAFE_GLB_PROD_CFG
 * BLOCKS:   BSAFE
 * DESC:     The device configuration register allows the system to be configured securely 
by the HSM. For example, a higher performance capability can be shipped 
disabled, then upgraded via a secure communication message in the field to 
increase perforamnce.  These bits would be used to disable the feature or 
performance capability in the system (or on chip).  Upon each power on reset 
or hardware reset of the uHSM, the embedded microcontroller will read the 
default initial value of this register from the NVM and set the register 
content. The register content can be subsequently updated via uHSM_LD_CFG 
command. The functionality of the uHSM is determined by the current value of 
the register.  The content of this register is brought out to the uHSM 
interface so that external system hardware can be configured.

 * SIZE:     32
 * FIELDS:
 *     PROD_CFG         The secure product configuration values. The usage is system dependent for eachbit.  The initial values of these bits are set via the "uHSM_INIT_DEVICEKEY (uhsm_config, prod_config, authorization)" command in the "configuration" input field. The values of these bits can be changed in-field by a manufacturer's authorized signature.
 *
 ******************************************************************************/
#define BCM56218_A0_BSAFE_GLB_PROD_CFGr 0x00b8020c

#define BCM56218_A0_BSAFE_GLB_PROD_CFGr_SIZE 4

/*
 * This structure should be used to declare and program BSAFE_GLB_PROD_CFG.
 *
 */
typedef union BCM56218_A0_BSAFE_GLB_PROD_CFGr_s {
	uint32_t v[1];
	uint32_t bsafe_glb_prod_cfg[1];
	uint32_t _bsafe_glb_prod_cfg;
} BCM56218_A0_BSAFE_GLB_PROD_CFGr_t;

#define BCM56218_A0_BSAFE_GLB_PROD_CFGr_CLR(r) (r).bsafe_glb_prod_cfg[0] = 0
#define BCM56218_A0_BSAFE_GLB_PROD_CFGr_SET(r,d) (r).bsafe_glb_prod_cfg[0] = d
#define BCM56218_A0_BSAFE_GLB_PROD_CFGr_GET(r) (r).bsafe_glb_prod_cfg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_BSAFE_GLB_PROD_CFGr_PROD_CFGf_GET(r) ((r).bsafe_glb_prod_cfg[0])
#define BCM56218_A0_BSAFE_GLB_PROD_CFGr_PROD_CFGf_SET(r,f) (r).bsafe_glb_prod_cfg[0]=((uint32_t)f)

/*
 * These macros can be used to access BSAFE_GLB_PROD_CFG.
 *
 */
#define BCM56218_A0_READ_BSAFE_GLB_PROD_CFGr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_BSAFE_GLB_PROD_CFGr,(r._bsafe_glb_prod_cfg))
#define BCM56218_A0_WRITE_BSAFE_GLB_PROD_CFGr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_BSAFE_GLB_PROD_CFGr,&(r._bsafe_glb_prod_cfg))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BSAFE_GLB_PROD_CFGr BCM56218_A0_BSAFE_GLB_PROD_CFGr
#define BSAFE_GLB_PROD_CFGr_SIZE BCM56218_A0_BSAFE_GLB_PROD_CFGr_SIZE
typedef BCM56218_A0_BSAFE_GLB_PROD_CFGr_t BSAFE_GLB_PROD_CFGr_t;
#define BSAFE_GLB_PROD_CFGr_CLR BCM56218_A0_BSAFE_GLB_PROD_CFGr_CLR
#define BSAFE_GLB_PROD_CFGr_SET BCM56218_A0_BSAFE_GLB_PROD_CFGr_SET
#define BSAFE_GLB_PROD_CFGr_GET BCM56218_A0_BSAFE_GLB_PROD_CFGr_GET
#define BSAFE_GLB_PROD_CFGr_PROD_CFGf_GET BCM56218_A0_BSAFE_GLB_PROD_CFGr_PROD_CFGf_GET
#define BSAFE_GLB_PROD_CFGr_PROD_CFGf_SET BCM56218_A0_BSAFE_GLB_PROD_CFGr_PROD_CFGf_SET
#define READ_BSAFE_GLB_PROD_CFGr BCM56218_A0_READ_BSAFE_GLB_PROD_CFGr
#define WRITE_BSAFE_GLB_PROD_CFGr BCM56218_A0_WRITE_BSAFE_GLB_PROD_CFGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_BSAFE_GLB_PROD_CFGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  BSAFE_GLB_TIMER
 * BLOCKS:   BSAFE
 * DESC:     System Time Register.
The timer register is used to determine when time based keys are expired
by the uHSM. The time tick is stored in this register and is set to zero 
at reset. The time tick increments in one second increments continuously 
from reset.
The value of this register can only be initialized once
after each hardware reset. Subsequent write operations to
this register through the register access interface will not
have any effect.

 * SIZE:     32
 * FIELDS:
 *     TIME_TICK        The relative time tick register. This register is disabled at reset. It remains at zero, until it is being programmed to a non-zero value.The value of this registers can only be initialized once after each hardware reset. Subsequent write operations to this register through the register access interface will not have any effect.This field is write-once protected. It can only be written one timeby an sbus write access. Further write attempts are ignored by uHSM.
 *
 ******************************************************************************/
#define BCM56218_A0_BSAFE_GLB_TIMERr 0x00b80200

#define BCM56218_A0_BSAFE_GLB_TIMERr_SIZE 4

/*
 * This structure should be used to declare and program BSAFE_GLB_TIMER.
 *
 */
typedef union BCM56218_A0_BSAFE_GLB_TIMERr_s {
	uint32_t v[1];
	uint32_t bsafe_glb_timer[1];
	uint32_t _bsafe_glb_timer;
} BCM56218_A0_BSAFE_GLB_TIMERr_t;

#define BCM56218_A0_BSAFE_GLB_TIMERr_CLR(r) (r).bsafe_glb_timer[0] = 0
#define BCM56218_A0_BSAFE_GLB_TIMERr_SET(r,d) (r).bsafe_glb_timer[0] = d
#define BCM56218_A0_BSAFE_GLB_TIMERr_GET(r) (r).bsafe_glb_timer[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_BSAFE_GLB_TIMERr_TIME_TICKf_GET(r) ((r).bsafe_glb_timer[0])
#define BCM56218_A0_BSAFE_GLB_TIMERr_TIME_TICKf_SET(r,f) (r).bsafe_glb_timer[0]=((uint32_t)f)

/*
 * These macros can be used to access BSAFE_GLB_TIMER.
 *
 */
#define BCM56218_A0_READ_BSAFE_GLB_TIMERr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_BSAFE_GLB_TIMERr,(r._bsafe_glb_timer))
#define BCM56218_A0_WRITE_BSAFE_GLB_TIMERr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_BSAFE_GLB_TIMERr,&(r._bsafe_glb_timer))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BSAFE_GLB_TIMERr BCM56218_A0_BSAFE_GLB_TIMERr
#define BSAFE_GLB_TIMERr_SIZE BCM56218_A0_BSAFE_GLB_TIMERr_SIZE
typedef BCM56218_A0_BSAFE_GLB_TIMERr_t BSAFE_GLB_TIMERr_t;
#define BSAFE_GLB_TIMERr_CLR BCM56218_A0_BSAFE_GLB_TIMERr_CLR
#define BSAFE_GLB_TIMERr_SET BCM56218_A0_BSAFE_GLB_TIMERr_SET
#define BSAFE_GLB_TIMERr_GET BCM56218_A0_BSAFE_GLB_TIMERr_GET
#define BSAFE_GLB_TIMERr_TIME_TICKf_GET BCM56218_A0_BSAFE_GLB_TIMERr_TIME_TICKf_GET
#define BSAFE_GLB_TIMERr_TIME_TICKf_SET BCM56218_A0_BSAFE_GLB_TIMERr_TIME_TICKf_SET
#define READ_BSAFE_GLB_TIMERr BCM56218_A0_READ_BSAFE_GLB_TIMERr
#define WRITE_BSAFE_GLB_TIMERr BCM56218_A0_WRITE_BSAFE_GLB_TIMERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_BSAFE_GLB_TIMERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  BSAFE_GLB_UHSM_CFG
 * BLOCKS:   BSAFE
 * DESC:     The uHSM configuration register allows the uHSM to be configured securely by 
the HSM. The most common use for this function is the in field upgrade 
capability for export controls.  Upon each power on reset or hardware reset 
of the uHSM, the embedded microcontroller will read the default initial value 
of this register from the NVM and set the register content. The register 
content can be subsequently updated via uHSM_LD_CFG command. The 
functionality of the uHSM is determined by the current value of the register.

 * SIZE:     32
 * FIELDS:
 *     UHSM_CFG         The secure uHSM configuration values. The pre-defined flags are specified in the uHSM_INIT_DEVICEKEY command.  The initial values of these bits are set via the "uHSM_INIT_DEVICEKEY (uhsm_config, prod_config, authorization)" command in the "configuration" input field. The values of these bits can be changed in-field by a manufacturer's authorized signature.
 *
 ******************************************************************************/
#define BCM56218_A0_BSAFE_GLB_UHSM_CFGr 0x00b80208

#define BCM56218_A0_BSAFE_GLB_UHSM_CFGr_SIZE 4

/*
 * This structure should be used to declare and program BSAFE_GLB_UHSM_CFG.
 *
 */
typedef union BCM56218_A0_BSAFE_GLB_UHSM_CFGr_s {
	uint32_t v[1];
	uint32_t bsafe_glb_uhsm_cfg[1];
	uint32_t _bsafe_glb_uhsm_cfg;
} BCM56218_A0_BSAFE_GLB_UHSM_CFGr_t;

#define BCM56218_A0_BSAFE_GLB_UHSM_CFGr_CLR(r) (r).bsafe_glb_uhsm_cfg[0] = 0
#define BCM56218_A0_BSAFE_GLB_UHSM_CFGr_SET(r,d) (r).bsafe_glb_uhsm_cfg[0] = d
#define BCM56218_A0_BSAFE_GLB_UHSM_CFGr_GET(r) (r).bsafe_glb_uhsm_cfg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_BSAFE_GLB_UHSM_CFGr_UHSM_CFGf_GET(r) ((r).bsafe_glb_uhsm_cfg[0])
#define BCM56218_A0_BSAFE_GLB_UHSM_CFGr_UHSM_CFGf_SET(r,f) (r).bsafe_glb_uhsm_cfg[0]=((uint32_t)f)

/*
 * These macros can be used to access BSAFE_GLB_UHSM_CFG.
 *
 */
#define BCM56218_A0_READ_BSAFE_GLB_UHSM_CFGr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_BSAFE_GLB_UHSM_CFGr,(r._bsafe_glb_uhsm_cfg))
#define BCM56218_A0_WRITE_BSAFE_GLB_UHSM_CFGr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_BSAFE_GLB_UHSM_CFGr,&(r._bsafe_glb_uhsm_cfg))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BSAFE_GLB_UHSM_CFGr BCM56218_A0_BSAFE_GLB_UHSM_CFGr
#define BSAFE_GLB_UHSM_CFGr_SIZE BCM56218_A0_BSAFE_GLB_UHSM_CFGr_SIZE
typedef BCM56218_A0_BSAFE_GLB_UHSM_CFGr_t BSAFE_GLB_UHSM_CFGr_t;
#define BSAFE_GLB_UHSM_CFGr_CLR BCM56218_A0_BSAFE_GLB_UHSM_CFGr_CLR
#define BSAFE_GLB_UHSM_CFGr_SET BCM56218_A0_BSAFE_GLB_UHSM_CFGr_SET
#define BSAFE_GLB_UHSM_CFGr_GET BCM56218_A0_BSAFE_GLB_UHSM_CFGr_GET
#define BSAFE_GLB_UHSM_CFGr_UHSM_CFGf_GET BCM56218_A0_BSAFE_GLB_UHSM_CFGr_UHSM_CFGf_GET
#define BSAFE_GLB_UHSM_CFGr_UHSM_CFGf_SET BCM56218_A0_BSAFE_GLB_UHSM_CFGr_UHSM_CFGf_SET
#define READ_BSAFE_GLB_UHSM_CFGr BCM56218_A0_READ_BSAFE_GLB_UHSM_CFGr
#define WRITE_BSAFE_GLB_UHSM_CFGr BCM56218_A0_WRITE_BSAFE_GLB_UHSM_CFGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_BSAFE_GLB_UHSM_CFGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CBPCELLCRCERRPTR
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     ERRORPOINTER     CBP Cell Data Memory cell CRC error pointer tells first failured memory entry.
 *
 ******************************************************************************/
#define BCM56218_A0_CBPCELLCRCERRPTRr 0x00680037

#define BCM56218_A0_CBPCELLCRCERRPTRr_SIZE 4

/*
 * This structure should be used to declare and program CBPCELLCRCERRPTR.
 *
 */
typedef union BCM56218_A0_CBPCELLCRCERRPTRr_s {
	uint32_t v[1];
	uint32_t cbpcellcrcerrptr[1];
	uint32_t _cbpcellcrcerrptr;
} BCM56218_A0_CBPCELLCRCERRPTRr_t;

#define BCM56218_A0_CBPCELLCRCERRPTRr_CLR(r) (r).cbpcellcrcerrptr[0] = 0
#define BCM56218_A0_CBPCELLCRCERRPTRr_SET(r,d) (r).cbpcellcrcerrptr[0] = d
#define BCM56218_A0_CBPCELLCRCERRPTRr_GET(r) (r).cbpcellcrcerrptr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CBPCELLCRCERRPTRr_ERRORPOINTERf_GET(r) (((r).cbpcellcrcerrptr[0]) & 0x3fff)
#define BCM56218_A0_CBPCELLCRCERRPTRr_ERRORPOINTERf_SET(r,f) (r).cbpcellcrcerrptr[0]=(((r).cbpcellcrcerrptr[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access CBPCELLCRCERRPTR.
 *
 */
#define BCM56218_A0_READ_CBPCELLCRCERRPTRr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_CBPCELLCRCERRPTRr,(r._cbpcellcrcerrptr))
#define BCM56218_A0_WRITE_CBPCELLCRCERRPTRr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_CBPCELLCRCERRPTRr,&(r._cbpcellcrcerrptr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CBPCELLCRCERRPTRr BCM56218_A0_CBPCELLCRCERRPTRr
#define CBPCELLCRCERRPTRr_SIZE BCM56218_A0_CBPCELLCRCERRPTRr_SIZE
typedef BCM56218_A0_CBPCELLCRCERRPTRr_t CBPCELLCRCERRPTRr_t;
#define CBPCELLCRCERRPTRr_CLR BCM56218_A0_CBPCELLCRCERRPTRr_CLR
#define CBPCELLCRCERRPTRr_SET BCM56218_A0_CBPCELLCRCERRPTRr_SET
#define CBPCELLCRCERRPTRr_GET BCM56218_A0_CBPCELLCRCERRPTRr_GET
#define CBPCELLCRCERRPTRr_ERRORPOINTERf_GET BCM56218_A0_CBPCELLCRCERRPTRr_ERRORPOINTERf_GET
#define CBPCELLCRCERRPTRr_ERRORPOINTERf_SET BCM56218_A0_CBPCELLCRCERRPTRr_ERRORPOINTERf_SET
#define READ_CBPCELLCRCERRPTRr BCM56218_A0_READ_CBPCELLCRCERRPTRr
#define WRITE_CBPCELLCRCERRPTRr BCM56218_A0_WRITE_CBPCELLCRCERRPTRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CBPCELLCRCERRPTRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CBPCELLHDRMEMDEBUG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     SAM              sam registers.
 *     CT0              ct0 registers.
 *     CT1              ct1 registers.
 *     CT2              ct2 registers.
 *
 ******************************************************************************/
#define BCM56218_A0_CBPCELLHDRMEMDEBUGr 0x0068004e

#define BCM56218_A0_CBPCELLHDRMEMDEBUGr_SIZE 4

/*
 * This structure should be used to declare and program CBPCELLHDRMEMDEBUG.
 *
 */
typedef union BCM56218_A0_CBPCELLHDRMEMDEBUGr_s {
	uint32_t v[1];
	uint32_t cbpcellhdrmemdebug[1];
	uint32_t _cbpcellhdrmemdebug;
} BCM56218_A0_CBPCELLHDRMEMDEBUGr_t;

#define BCM56218_A0_CBPCELLHDRMEMDEBUGr_CLR(r) (r).cbpcellhdrmemdebug[0] = 0
#define BCM56218_A0_CBPCELLHDRMEMDEBUGr_SET(r,d) (r).cbpcellhdrmemdebug[0] = d
#define BCM56218_A0_CBPCELLHDRMEMDEBUGr_GET(r) (r).cbpcellhdrmemdebug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CBPCELLHDRMEMDEBUGr_SAMf_GET(r) (((r).cbpcellhdrmemdebug[0]) & 0x3)
#define BCM56218_A0_CBPCELLHDRMEMDEBUGr_SAMf_SET(r,f) (r).cbpcellhdrmemdebug[0]=(((r).cbpcellhdrmemdebug[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56218_A0_CBPCELLHDRMEMDEBUGr_CT0f_GET(r) ((((r).cbpcellhdrmemdebug[0]) >> 2) & 0x1)
#define BCM56218_A0_CBPCELLHDRMEMDEBUGr_CT0f_SET(r,f) (r).cbpcellhdrmemdebug[0]=(((r).cbpcellhdrmemdebug[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_CBPCELLHDRMEMDEBUGr_CT1f_GET(r) ((((r).cbpcellhdrmemdebug[0]) >> 3) & 0x1)
#define BCM56218_A0_CBPCELLHDRMEMDEBUGr_CT1f_SET(r,f) (r).cbpcellhdrmemdebug[0]=(((r).cbpcellhdrmemdebug[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56218_A0_CBPCELLHDRMEMDEBUGr_CT2f_GET(r) ((((r).cbpcellhdrmemdebug[0]) >> 4) & 0x1)
#define BCM56218_A0_CBPCELLHDRMEMDEBUGr_CT2f_SET(r,f) (r).cbpcellhdrmemdebug[0]=(((r).cbpcellhdrmemdebug[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))

/*
 * These macros can be used to access CBPCELLHDRMEMDEBUG.
 *
 */
#define BCM56218_A0_READ_CBPCELLHDRMEMDEBUGr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_CBPCELLHDRMEMDEBUGr,(r._cbpcellhdrmemdebug))
#define BCM56218_A0_WRITE_CBPCELLHDRMEMDEBUGr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_CBPCELLHDRMEMDEBUGr,&(r._cbpcellhdrmemdebug))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CBPCELLHDRMEMDEBUGr BCM56218_A0_CBPCELLHDRMEMDEBUGr
#define CBPCELLHDRMEMDEBUGr_SIZE BCM56218_A0_CBPCELLHDRMEMDEBUGr_SIZE
typedef BCM56218_A0_CBPCELLHDRMEMDEBUGr_t CBPCELLHDRMEMDEBUGr_t;
#define CBPCELLHDRMEMDEBUGr_CLR BCM56218_A0_CBPCELLHDRMEMDEBUGr_CLR
#define CBPCELLHDRMEMDEBUGr_SET BCM56218_A0_CBPCELLHDRMEMDEBUGr_SET
#define CBPCELLHDRMEMDEBUGr_GET BCM56218_A0_CBPCELLHDRMEMDEBUGr_GET
#define CBPCELLHDRMEMDEBUGr_SAMf_GET BCM56218_A0_CBPCELLHDRMEMDEBUGr_SAMf_GET
#define CBPCELLHDRMEMDEBUGr_SAMf_SET BCM56218_A0_CBPCELLHDRMEMDEBUGr_SAMf_SET
#define CBPCELLHDRMEMDEBUGr_CT0f_GET BCM56218_A0_CBPCELLHDRMEMDEBUGr_CT0f_GET
#define CBPCELLHDRMEMDEBUGr_CT0f_SET BCM56218_A0_CBPCELLHDRMEMDEBUGr_CT0f_SET
#define CBPCELLHDRMEMDEBUGr_CT1f_GET BCM56218_A0_CBPCELLHDRMEMDEBUGr_CT1f_GET
#define CBPCELLHDRMEMDEBUGr_CT1f_SET BCM56218_A0_CBPCELLHDRMEMDEBUGr_CT1f_SET
#define CBPCELLHDRMEMDEBUGr_CT2f_GET BCM56218_A0_CBPCELLHDRMEMDEBUGr_CT2f_GET
#define CBPCELLHDRMEMDEBUGr_CT2f_SET BCM56218_A0_CBPCELLHDRMEMDEBUGr_CT2f_SET
#define READ_CBPCELLHDRMEMDEBUGr BCM56218_A0_READ_CBPCELLHDRMEMDEBUGr
#define WRITE_CBPCELLHDRMEMDEBUGr BCM56218_A0_WRITE_CBPCELLHDRMEMDEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CBPCELLHDRMEMDEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CBPCELLHDRPARITYERRPTR
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     ERRORPOINTER     CBP Cell Header Memory parity error pointer is the errored cell header pointer.
 *     ERROREDNEXTCELLPOINTER CBP Cell Header Memory parity error next cell pointer is the abandoned next cellpointer.
 *
 ******************************************************************************/
#define BCM56218_A0_CBPCELLHDRPARITYERRPTRr 0x00680038

#define BCM56218_A0_CBPCELLHDRPARITYERRPTRr_SIZE 4

/*
 * This structure should be used to declare and program CBPCELLHDRPARITYERRPTR.
 *
 */
typedef union BCM56218_A0_CBPCELLHDRPARITYERRPTRr_s {
	uint32_t v[1];
	uint32_t cbpcellhdrparityerrptr[1];
	uint32_t _cbpcellhdrparityerrptr;
} BCM56218_A0_CBPCELLHDRPARITYERRPTRr_t;

#define BCM56218_A0_CBPCELLHDRPARITYERRPTRr_CLR(r) (r).cbpcellhdrparityerrptr[0] = 0
#define BCM56218_A0_CBPCELLHDRPARITYERRPTRr_SET(r,d) (r).cbpcellhdrparityerrptr[0] = d
#define BCM56218_A0_CBPCELLHDRPARITYERRPTRr_GET(r) (r).cbpcellhdrparityerrptr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CBPCELLHDRPARITYERRPTRr_ERRORPOINTERf_GET(r) (((r).cbpcellhdrparityerrptr[0]) & 0x3fff)
#define BCM56218_A0_CBPCELLHDRPARITYERRPTRr_ERRORPOINTERf_SET(r,f) (r).cbpcellhdrparityerrptr[0]=(((r).cbpcellhdrparityerrptr[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM56218_A0_CBPCELLHDRPARITYERRPTRr_ERROREDNEXTCELLPOINTERf_GET(r) ((((r).cbpcellhdrparityerrptr[0]) >> 14) & 0x3fff)
#define BCM56218_A0_CBPCELLHDRPARITYERRPTRr_ERROREDNEXTCELLPOINTERf_SET(r,f) (r).cbpcellhdrparityerrptr[0]=(((r).cbpcellhdrparityerrptr[0] & ~((uint32_t)0x3fff << 14)) | ((((uint32_t)f) & 0x3fff) << 14))

/*
 * These macros can be used to access CBPCELLHDRPARITYERRPTR.
 *
 */
#define BCM56218_A0_READ_CBPCELLHDRPARITYERRPTRr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_CBPCELLHDRPARITYERRPTRr,(r._cbpcellhdrparityerrptr))
#define BCM56218_A0_WRITE_CBPCELLHDRPARITYERRPTRr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_CBPCELLHDRPARITYERRPTRr,&(r._cbpcellhdrparityerrptr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CBPCELLHDRPARITYERRPTRr BCM56218_A0_CBPCELLHDRPARITYERRPTRr
#define CBPCELLHDRPARITYERRPTRr_SIZE BCM56218_A0_CBPCELLHDRPARITYERRPTRr_SIZE
typedef BCM56218_A0_CBPCELLHDRPARITYERRPTRr_t CBPCELLHDRPARITYERRPTRr_t;
#define CBPCELLHDRPARITYERRPTRr_CLR BCM56218_A0_CBPCELLHDRPARITYERRPTRr_CLR
#define CBPCELLHDRPARITYERRPTRr_SET BCM56218_A0_CBPCELLHDRPARITYERRPTRr_SET
#define CBPCELLHDRPARITYERRPTRr_GET BCM56218_A0_CBPCELLHDRPARITYERRPTRr_GET
#define CBPCELLHDRPARITYERRPTRr_ERRORPOINTERf_GET BCM56218_A0_CBPCELLHDRPARITYERRPTRr_ERRORPOINTERf_GET
#define CBPCELLHDRPARITYERRPTRr_ERRORPOINTERf_SET BCM56218_A0_CBPCELLHDRPARITYERRPTRr_ERRORPOINTERf_SET
#define CBPCELLHDRPARITYERRPTRr_ERROREDNEXTCELLPOINTERf_GET BCM56218_A0_CBPCELLHDRPARITYERRPTRr_ERROREDNEXTCELLPOINTERf_GET
#define CBPCELLHDRPARITYERRPTRr_ERROREDNEXTCELLPOINTERf_SET BCM56218_A0_CBPCELLHDRPARITYERRPTRr_ERROREDNEXTCELLPOINTERf_SET
#define READ_CBPCELLHDRPARITYERRPTRr BCM56218_A0_READ_CBPCELLHDRPARITYERRPTRr
#define WRITE_CBPCELLHDRPARITYERRPTRr BCM56218_A0_WRITE_CBPCELLHDRPARITYERRPTRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CBPCELLHDRPARITYERRPTRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CBPDATAMEMDEBUG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     SAM              sam registers.
 *     CT0              ct0 registers.
 *     CT1              ct1 registers.
 *     CT2              ct2 registers.
 *
 ******************************************************************************/
#define BCM56218_A0_CBPDATAMEMDEBUGr 0x00680044

#define BCM56218_A0_CBPDATAMEMDEBUGr_SIZE 4

/*
 * This structure should be used to declare and program CBPDATAMEMDEBUG.
 *
 */
typedef union BCM56218_A0_CBPDATAMEMDEBUGr_s {
	uint32_t v[1];
	uint32_t cbpdatamemdebug[1];
	uint32_t _cbpdatamemdebug;
} BCM56218_A0_CBPDATAMEMDEBUGr_t;

#define BCM56218_A0_CBPDATAMEMDEBUGr_CLR(r) (r).cbpdatamemdebug[0] = 0
#define BCM56218_A0_CBPDATAMEMDEBUGr_SET(r,d) (r).cbpdatamemdebug[0] = d
#define BCM56218_A0_CBPDATAMEMDEBUGr_GET(r) (r).cbpdatamemdebug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CBPDATAMEMDEBUGr_SAMf_GET(r) (((r).cbpdatamemdebug[0]) & 0x3)
#define BCM56218_A0_CBPDATAMEMDEBUGr_SAMf_SET(r,f) (r).cbpdatamemdebug[0]=(((r).cbpdatamemdebug[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56218_A0_CBPDATAMEMDEBUGr_CT0f_GET(r) ((((r).cbpdatamemdebug[0]) >> 2) & 0x1)
#define BCM56218_A0_CBPDATAMEMDEBUGr_CT0f_SET(r,f) (r).cbpdatamemdebug[0]=(((r).cbpdatamemdebug[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_CBPDATAMEMDEBUGr_CT1f_GET(r) ((((r).cbpdatamemdebug[0]) >> 3) & 0x1)
#define BCM56218_A0_CBPDATAMEMDEBUGr_CT1f_SET(r,f) (r).cbpdatamemdebug[0]=(((r).cbpdatamemdebug[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56218_A0_CBPDATAMEMDEBUGr_CT2f_GET(r) ((((r).cbpdatamemdebug[0]) >> 4) & 0x1)
#define BCM56218_A0_CBPDATAMEMDEBUGr_CT2f_SET(r,f) (r).cbpdatamemdebug[0]=(((r).cbpdatamemdebug[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))

/*
 * These macros can be used to access CBPDATAMEMDEBUG.
 *
 */
#define BCM56218_A0_READ_CBPDATAMEMDEBUGr(u,i,r) cdk_xgs_reg32_read(u,BCM56218_A0_CBPDATAMEMDEBUGr+(i),(r._cbpdatamemdebug))
#define BCM56218_A0_WRITE_CBPDATAMEMDEBUGr(u,i,r) cdk_xgs_reg32_write(u,BCM56218_A0_CBPDATAMEMDEBUGr+(i),&(r._cbpdatamemdebug))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CBPDATAMEMDEBUGr BCM56218_A0_CBPDATAMEMDEBUGr
#define CBPDATAMEMDEBUGr_SIZE BCM56218_A0_CBPDATAMEMDEBUGr_SIZE
typedef BCM56218_A0_CBPDATAMEMDEBUGr_t CBPDATAMEMDEBUGr_t;
#define CBPDATAMEMDEBUGr_CLR BCM56218_A0_CBPDATAMEMDEBUGr_CLR
#define CBPDATAMEMDEBUGr_SET BCM56218_A0_CBPDATAMEMDEBUGr_SET
#define CBPDATAMEMDEBUGr_GET BCM56218_A0_CBPDATAMEMDEBUGr_GET
#define CBPDATAMEMDEBUGr_SAMf_GET BCM56218_A0_CBPDATAMEMDEBUGr_SAMf_GET
#define CBPDATAMEMDEBUGr_SAMf_SET BCM56218_A0_CBPDATAMEMDEBUGr_SAMf_SET
#define CBPDATAMEMDEBUGr_CT0f_GET BCM56218_A0_CBPDATAMEMDEBUGr_CT0f_GET
#define CBPDATAMEMDEBUGr_CT0f_SET BCM56218_A0_CBPDATAMEMDEBUGr_CT0f_SET
#define CBPDATAMEMDEBUGr_CT1f_GET BCM56218_A0_CBPDATAMEMDEBUGr_CT1f_GET
#define CBPDATAMEMDEBUGr_CT1f_SET BCM56218_A0_CBPDATAMEMDEBUGr_CT1f_SET
#define CBPDATAMEMDEBUGr_CT2f_GET BCM56218_A0_CBPDATAMEMDEBUGr_CT2f_GET
#define CBPDATAMEMDEBUGr_CT2f_SET BCM56218_A0_CBPDATAMEMDEBUGr_CT2f_SET
#define READ_CBPDATAMEMDEBUGr BCM56218_A0_READ_CBPDATAMEMDEBUGr
#define WRITE_CBPDATAMEMDEBUGr BCM56218_A0_WRITE_CBPDATAMEMDEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CBPDATAMEMDEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CBPPKTHDRMEM0DEBUG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     SAM              sam registers.
 *     CT0              ct0 registers.
 *     CT1              ct1 registers.
 *     CT2              ct2 registers.
 *
 ******************************************************************************/
#define BCM56218_A0_CBPPKTHDRMEM0DEBUGr 0x0068004c

#define BCM56218_A0_CBPPKTHDRMEM0DEBUGr_SIZE 4

/*
 * This structure should be used to declare and program CBPPKTHDRMEM0DEBUG.
 *
 */
typedef union BCM56218_A0_CBPPKTHDRMEM0DEBUGr_s {
	uint32_t v[1];
	uint32_t cbppkthdrmem0debug[1];
	uint32_t _cbppkthdrmem0debug;
} BCM56218_A0_CBPPKTHDRMEM0DEBUGr_t;

#define BCM56218_A0_CBPPKTHDRMEM0DEBUGr_CLR(r) (r).cbppkthdrmem0debug[0] = 0
#define BCM56218_A0_CBPPKTHDRMEM0DEBUGr_SET(r,d) (r).cbppkthdrmem0debug[0] = d
#define BCM56218_A0_CBPPKTHDRMEM0DEBUGr_GET(r) (r).cbppkthdrmem0debug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CBPPKTHDRMEM0DEBUGr_SAMf_GET(r) (((r).cbppkthdrmem0debug[0]) & 0x3)
#define BCM56218_A0_CBPPKTHDRMEM0DEBUGr_SAMf_SET(r,f) (r).cbppkthdrmem0debug[0]=(((r).cbppkthdrmem0debug[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56218_A0_CBPPKTHDRMEM0DEBUGr_CT0f_GET(r) ((((r).cbppkthdrmem0debug[0]) >> 2) & 0x1)
#define BCM56218_A0_CBPPKTHDRMEM0DEBUGr_CT0f_SET(r,f) (r).cbppkthdrmem0debug[0]=(((r).cbppkthdrmem0debug[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_CBPPKTHDRMEM0DEBUGr_CT1f_GET(r) ((((r).cbppkthdrmem0debug[0]) >> 3) & 0x1)
#define BCM56218_A0_CBPPKTHDRMEM0DEBUGr_CT1f_SET(r,f) (r).cbppkthdrmem0debug[0]=(((r).cbppkthdrmem0debug[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56218_A0_CBPPKTHDRMEM0DEBUGr_CT2f_GET(r) ((((r).cbppkthdrmem0debug[0]) >> 4) & 0x1)
#define BCM56218_A0_CBPPKTHDRMEM0DEBUGr_CT2f_SET(r,f) (r).cbppkthdrmem0debug[0]=(((r).cbppkthdrmem0debug[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))

/*
 * These macros can be used to access CBPPKTHDRMEM0DEBUG.
 *
 */
#define BCM56218_A0_READ_CBPPKTHDRMEM0DEBUGr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_CBPPKTHDRMEM0DEBUGr,(r._cbppkthdrmem0debug))
#define BCM56218_A0_WRITE_CBPPKTHDRMEM0DEBUGr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_CBPPKTHDRMEM0DEBUGr,&(r._cbppkthdrmem0debug))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CBPPKTHDRMEM0DEBUGr BCM56218_A0_CBPPKTHDRMEM0DEBUGr
#define CBPPKTHDRMEM0DEBUGr_SIZE BCM56218_A0_CBPPKTHDRMEM0DEBUGr_SIZE
typedef BCM56218_A0_CBPPKTHDRMEM0DEBUGr_t CBPPKTHDRMEM0DEBUGr_t;
#define CBPPKTHDRMEM0DEBUGr_CLR BCM56218_A0_CBPPKTHDRMEM0DEBUGr_CLR
#define CBPPKTHDRMEM0DEBUGr_SET BCM56218_A0_CBPPKTHDRMEM0DEBUGr_SET
#define CBPPKTHDRMEM0DEBUGr_GET BCM56218_A0_CBPPKTHDRMEM0DEBUGr_GET
#define CBPPKTHDRMEM0DEBUGr_SAMf_GET BCM56218_A0_CBPPKTHDRMEM0DEBUGr_SAMf_GET
#define CBPPKTHDRMEM0DEBUGr_SAMf_SET BCM56218_A0_CBPPKTHDRMEM0DEBUGr_SAMf_SET
#define CBPPKTHDRMEM0DEBUGr_CT0f_GET BCM56218_A0_CBPPKTHDRMEM0DEBUGr_CT0f_GET
#define CBPPKTHDRMEM0DEBUGr_CT0f_SET BCM56218_A0_CBPPKTHDRMEM0DEBUGr_CT0f_SET
#define CBPPKTHDRMEM0DEBUGr_CT1f_GET BCM56218_A0_CBPPKTHDRMEM0DEBUGr_CT1f_GET
#define CBPPKTHDRMEM0DEBUGr_CT1f_SET BCM56218_A0_CBPPKTHDRMEM0DEBUGr_CT1f_SET
#define CBPPKTHDRMEM0DEBUGr_CT2f_GET BCM56218_A0_CBPPKTHDRMEM0DEBUGr_CT2f_GET
#define CBPPKTHDRMEM0DEBUGr_CT2f_SET BCM56218_A0_CBPPKTHDRMEM0DEBUGr_CT2f_SET
#define READ_CBPPKTHDRMEM0DEBUGr BCM56218_A0_READ_CBPPKTHDRMEM0DEBUGr
#define WRITE_CBPPKTHDRMEM0DEBUGr BCM56218_A0_WRITE_CBPPKTHDRMEM0DEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CBPPKTHDRMEM0DEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CBPPKTHDRMEM1DEBUG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     SAM              sam registers.
 *     CT0              ct0 registers.
 *     CT1              ct1 registers.
 *     CT2              ct2 registers.
 *
 ******************************************************************************/
#define BCM56218_A0_CBPPKTHDRMEM1DEBUGr 0x0068004d

#define BCM56218_A0_CBPPKTHDRMEM1DEBUGr_SIZE 4

/*
 * This structure should be used to declare and program CBPPKTHDRMEM1DEBUG.
 *
 */
typedef union BCM56218_A0_CBPPKTHDRMEM1DEBUGr_s {
	uint32_t v[1];
	uint32_t cbppkthdrmem1debug[1];
	uint32_t _cbppkthdrmem1debug;
} BCM56218_A0_CBPPKTHDRMEM1DEBUGr_t;

#define BCM56218_A0_CBPPKTHDRMEM1DEBUGr_CLR(r) (r).cbppkthdrmem1debug[0] = 0
#define BCM56218_A0_CBPPKTHDRMEM1DEBUGr_SET(r,d) (r).cbppkthdrmem1debug[0] = d
#define BCM56218_A0_CBPPKTHDRMEM1DEBUGr_GET(r) (r).cbppkthdrmem1debug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CBPPKTHDRMEM1DEBUGr_SAMf_GET(r) (((r).cbppkthdrmem1debug[0]) & 0x3)
#define BCM56218_A0_CBPPKTHDRMEM1DEBUGr_SAMf_SET(r,f) (r).cbppkthdrmem1debug[0]=(((r).cbppkthdrmem1debug[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56218_A0_CBPPKTHDRMEM1DEBUGr_CT0f_GET(r) ((((r).cbppkthdrmem1debug[0]) >> 2) & 0x1)
#define BCM56218_A0_CBPPKTHDRMEM1DEBUGr_CT0f_SET(r,f) (r).cbppkthdrmem1debug[0]=(((r).cbppkthdrmem1debug[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_CBPPKTHDRMEM1DEBUGr_CT1f_GET(r) ((((r).cbppkthdrmem1debug[0]) >> 3) & 0x1)
#define BCM56218_A0_CBPPKTHDRMEM1DEBUGr_CT1f_SET(r,f) (r).cbppkthdrmem1debug[0]=(((r).cbppkthdrmem1debug[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56218_A0_CBPPKTHDRMEM1DEBUGr_CT2f_GET(r) ((((r).cbppkthdrmem1debug[0]) >> 4) & 0x1)
#define BCM56218_A0_CBPPKTHDRMEM1DEBUGr_CT2f_SET(r,f) (r).cbppkthdrmem1debug[0]=(((r).cbppkthdrmem1debug[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))

/*
 * These macros can be used to access CBPPKTHDRMEM1DEBUG.
 *
 */
#define BCM56218_A0_READ_CBPPKTHDRMEM1DEBUGr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_CBPPKTHDRMEM1DEBUGr,(r._cbppkthdrmem1debug))
#define BCM56218_A0_WRITE_CBPPKTHDRMEM1DEBUGr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_CBPPKTHDRMEM1DEBUGr,&(r._cbppkthdrmem1debug))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CBPPKTHDRMEM1DEBUGr BCM56218_A0_CBPPKTHDRMEM1DEBUGr
#define CBPPKTHDRMEM1DEBUGr_SIZE BCM56218_A0_CBPPKTHDRMEM1DEBUGr_SIZE
typedef BCM56218_A0_CBPPKTHDRMEM1DEBUGr_t CBPPKTHDRMEM1DEBUGr_t;
#define CBPPKTHDRMEM1DEBUGr_CLR BCM56218_A0_CBPPKTHDRMEM1DEBUGr_CLR
#define CBPPKTHDRMEM1DEBUGr_SET BCM56218_A0_CBPPKTHDRMEM1DEBUGr_SET
#define CBPPKTHDRMEM1DEBUGr_GET BCM56218_A0_CBPPKTHDRMEM1DEBUGr_GET
#define CBPPKTHDRMEM1DEBUGr_SAMf_GET BCM56218_A0_CBPPKTHDRMEM1DEBUGr_SAMf_GET
#define CBPPKTHDRMEM1DEBUGr_SAMf_SET BCM56218_A0_CBPPKTHDRMEM1DEBUGr_SAMf_SET
#define CBPPKTHDRMEM1DEBUGr_CT0f_GET BCM56218_A0_CBPPKTHDRMEM1DEBUGr_CT0f_GET
#define CBPPKTHDRMEM1DEBUGr_CT0f_SET BCM56218_A0_CBPPKTHDRMEM1DEBUGr_CT0f_SET
#define CBPPKTHDRMEM1DEBUGr_CT1f_GET BCM56218_A0_CBPPKTHDRMEM1DEBUGr_CT1f_GET
#define CBPPKTHDRMEM1DEBUGr_CT1f_SET BCM56218_A0_CBPPKTHDRMEM1DEBUGr_CT1f_SET
#define CBPPKTHDRMEM1DEBUGr_CT2f_GET BCM56218_A0_CBPPKTHDRMEM1DEBUGr_CT2f_GET
#define CBPPKTHDRMEM1DEBUGr_CT2f_SET BCM56218_A0_CBPPKTHDRMEM1DEBUGr_CT2f_SET
#define READ_CBPPKTHDRMEM1DEBUGr BCM56218_A0_READ_CBPPKTHDRMEM1DEBUGr
#define WRITE_CBPPKTHDRMEM1DEBUGr BCM56218_A0_WRITE_CBPPKTHDRMEM1DEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CBPPKTHDRMEM1DEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CBPPKTHDRPARITYERRPTR
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     ERRORPOINTER     CBP Packet Header Memory parity error pointer is the errored cell header pointer.
 *
 ******************************************************************************/
#define BCM56218_A0_CBPPKTHDRPARITYERRPTRr 0x00680039

#define BCM56218_A0_CBPPKTHDRPARITYERRPTRr_SIZE 4

/*
 * This structure should be used to declare and program CBPPKTHDRPARITYERRPTR.
 *
 */
typedef union BCM56218_A0_CBPPKTHDRPARITYERRPTRr_s {
	uint32_t v[1];
	uint32_t cbppkthdrparityerrptr[1];
	uint32_t _cbppkthdrparityerrptr;
} BCM56218_A0_CBPPKTHDRPARITYERRPTRr_t;

#define BCM56218_A0_CBPPKTHDRPARITYERRPTRr_CLR(r) (r).cbppkthdrparityerrptr[0] = 0
#define BCM56218_A0_CBPPKTHDRPARITYERRPTRr_SET(r,d) (r).cbppkthdrparityerrptr[0] = d
#define BCM56218_A0_CBPPKTHDRPARITYERRPTRr_GET(r) (r).cbppkthdrparityerrptr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CBPPKTHDRPARITYERRPTRr_ERRORPOINTERf_GET(r) (((r).cbppkthdrparityerrptr[0]) & 0x3fff)
#define BCM56218_A0_CBPPKTHDRPARITYERRPTRr_ERRORPOINTERf_SET(r,f) (r).cbppkthdrparityerrptr[0]=(((r).cbppkthdrparityerrptr[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access CBPPKTHDRPARITYERRPTR.
 *
 */
#define BCM56218_A0_READ_CBPPKTHDRPARITYERRPTRr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_CBPPKTHDRPARITYERRPTRr,(r._cbppkthdrparityerrptr))
#define BCM56218_A0_WRITE_CBPPKTHDRPARITYERRPTRr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_CBPPKTHDRPARITYERRPTRr,&(r._cbppkthdrparityerrptr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CBPPKTHDRPARITYERRPTRr BCM56218_A0_CBPPKTHDRPARITYERRPTRr
#define CBPPKTHDRPARITYERRPTRr_SIZE BCM56218_A0_CBPPKTHDRPARITYERRPTRr_SIZE
typedef BCM56218_A0_CBPPKTHDRPARITYERRPTRr_t CBPPKTHDRPARITYERRPTRr_t;
#define CBPPKTHDRPARITYERRPTRr_CLR BCM56218_A0_CBPPKTHDRPARITYERRPTRr_CLR
#define CBPPKTHDRPARITYERRPTRr_SET BCM56218_A0_CBPPKTHDRPARITYERRPTRr_SET
#define CBPPKTHDRPARITYERRPTRr_GET BCM56218_A0_CBPPKTHDRPARITYERRPTRr_GET
#define CBPPKTHDRPARITYERRPTRr_ERRORPOINTERf_GET BCM56218_A0_CBPPKTHDRPARITYERRPTRr_ERRORPOINTERf_GET
#define CBPPKTHDRPARITYERRPTRr_ERRORPOINTERf_SET BCM56218_A0_CBPPKTHDRPARITYERRPTRr_ERRORPOINTERf_SET
#define READ_CBPPKTHDRPARITYERRPTRr BCM56218_A0_READ_CBPPKTHDRPARITYERRPTRr
#define WRITE_CBPPKTHDRPARITYERRPTRr BCM56218_A0_WRITE_CBPPKTHDRPARITYERRPTRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CBPPKTHDRPARITYERRPTRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CCPMEMDEBUG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CCM              ccm registers.
 *     RM               rm registers.
 *
 ******************************************************************************/
#define BCM56218_A0_CCPMEMDEBUGr 0x00680040

#define BCM56218_A0_CCPMEMDEBUGr_SIZE 4

/*
 * This structure should be used to declare and program CCPMEMDEBUG.
 *
 */
typedef union BCM56218_A0_CCPMEMDEBUGr_s {
	uint32_t v[1];
	uint32_t ccpmemdebug[1];
	uint32_t _ccpmemdebug;
} BCM56218_A0_CCPMEMDEBUGr_t;

#define BCM56218_A0_CCPMEMDEBUGr_CLR(r) (r).ccpmemdebug[0] = 0
#define BCM56218_A0_CCPMEMDEBUGr_SET(r,d) (r).ccpmemdebug[0] = d
#define BCM56218_A0_CCPMEMDEBUGr_GET(r) (r).ccpmemdebug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CCPMEMDEBUGr_CCMf_GET(r) (((r).ccpmemdebug[0]) & 0x1)
#define BCM56218_A0_CCPMEMDEBUGr_CCMf_SET(r,f) (r).ccpmemdebug[0]=(((r).ccpmemdebug[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_CCPMEMDEBUGr_RMf_GET(r) ((((r).ccpmemdebug[0]) >> 1) & 0x1)
#define BCM56218_A0_CCPMEMDEBUGr_RMf_SET(r,f) (r).ccpmemdebug[0]=(((r).ccpmemdebug[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access CCPMEMDEBUG.
 *
 */
#define BCM56218_A0_READ_CCPMEMDEBUGr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_CCPMEMDEBUGr,(r._ccpmemdebug))
#define BCM56218_A0_WRITE_CCPMEMDEBUGr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_CCPMEMDEBUGr,&(r._ccpmemdebug))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CCPMEMDEBUGr BCM56218_A0_CCPMEMDEBUGr
#define CCPMEMDEBUGr_SIZE BCM56218_A0_CCPMEMDEBUGr_SIZE
typedef BCM56218_A0_CCPMEMDEBUGr_t CCPMEMDEBUGr_t;
#define CCPMEMDEBUGr_CLR BCM56218_A0_CCPMEMDEBUGr_CLR
#define CCPMEMDEBUGr_SET BCM56218_A0_CCPMEMDEBUGr_SET
#define CCPMEMDEBUGr_GET BCM56218_A0_CCPMEMDEBUGr_GET
#define CCPMEMDEBUGr_CCMf_GET BCM56218_A0_CCPMEMDEBUGr_CCMf_GET
#define CCPMEMDEBUGr_CCMf_SET BCM56218_A0_CCPMEMDEBUGr_CCMf_SET
#define CCPMEMDEBUGr_RMf_GET BCM56218_A0_CCPMEMDEBUGr_RMf_GET
#define CCPMEMDEBUGr_RMf_SET BCM56218_A0_CCPMEMDEBUGr_RMf_SET
#define READ_CCPMEMDEBUGr BCM56218_A0_READ_CCPMEMDEBUGr
#define WRITE_CCPMEMDEBUGr BCM56218_A0_WRITE_CCPMEMDEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CCPMEMDEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CCPPARITYERRORPTR
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CCPPARITYERRORPTR MMU CCP memory parity error pointer indicats.this register only keeps the most current ccp parity error pointer.
 *
 ******************************************************************************/
#define BCM56218_A0_CCPPARITYERRORPTRr 0x0068003f

#define BCM56218_A0_CCPPARITYERRORPTRr_SIZE 4

/*
 * This structure should be used to declare and program CCPPARITYERRORPTR.
 *
 */
typedef union BCM56218_A0_CCPPARITYERRORPTRr_s {
	uint32_t v[1];
	uint32_t ccpparityerrorptr[1];
	uint32_t _ccpparityerrorptr;
} BCM56218_A0_CCPPARITYERRORPTRr_t;

#define BCM56218_A0_CCPPARITYERRORPTRr_CLR(r) (r).ccpparityerrorptr[0] = 0
#define BCM56218_A0_CCPPARITYERRORPTRr_SET(r,d) (r).ccpparityerrorptr[0] = d
#define BCM56218_A0_CCPPARITYERRORPTRr_GET(r) (r).ccpparityerrorptr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CCPPARITYERRORPTRr_CCPPARITYERRORPTRf_GET(r) (((r).ccpparityerrorptr[0]) & 0x3fff)
#define BCM56218_A0_CCPPARITYERRORPTRr_CCPPARITYERRORPTRf_SET(r,f) (r).ccpparityerrorptr[0]=(((r).ccpparityerrorptr[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access CCPPARITYERRORPTR.
 *
 */
#define BCM56218_A0_READ_CCPPARITYERRORPTRr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_CCPPARITYERRORPTRr,(r._ccpparityerrorptr))
#define BCM56218_A0_WRITE_CCPPARITYERRORPTRr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_CCPPARITYERRORPTRr,&(r._ccpparityerrorptr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CCPPARITYERRORPTRr BCM56218_A0_CCPPARITYERRORPTRr
#define CCPPARITYERRORPTRr_SIZE BCM56218_A0_CCPPARITYERRORPTRr_SIZE
typedef BCM56218_A0_CCPPARITYERRORPTRr_t CCPPARITYERRORPTRr_t;
#define CCPPARITYERRORPTRr_CLR BCM56218_A0_CCPPARITYERRORPTRr_CLR
#define CCPPARITYERRORPTRr_SET BCM56218_A0_CCPPARITYERRORPTRr_SET
#define CCPPARITYERRORPTRr_GET BCM56218_A0_CCPPARITYERRORPTRr_GET
#define CCPPARITYERRORPTRr_CCPPARITYERRORPTRf_GET BCM56218_A0_CCPPARITYERRORPTRr_CCPPARITYERRORPTRf_GET
#define CCPPARITYERRORPTRr_CCPPARITYERRORPTRf_SET BCM56218_A0_CCPPARITYERRORPTRr_CCPPARITYERRORPTRf_SET
#define READ_CCPPARITYERRORPTRr BCM56218_A0_READ_CCPPARITYERRORPTRr
#define WRITE_CCPPARITYERRORPTRr BCM56218_A0_WRITE_CCPPARITYERRORPTRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CCPPARITYERRORPTRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CFAPCONFIG
 * BLOCKS:   MMU
 * DESC:     Controls the CFAP behavior
 * SIZE:     32
 * FIELDS:
 *     CFAPPOOLSIZE     Maximum number of cell pointers of CBP memory.Do NOT set this above the RESET VALUE. It will cause unexpected behavior of MMU. 
 *     CFAPINIT         Re-Initialize CFAP Memory.When write 1 to Set this bit mmu will re-initialize CFAP pointer pre-fetchprocess after user had rearranged CFAP memory. 
 *
 ******************************************************************************/
#define BCM56218_A0_CFAPCONFIGr 0x0068001a

#define BCM56218_A0_CFAPCONFIGr_SIZE 4

/*
 * This structure should be used to declare and program CFAPCONFIG.
 *
 */
typedef union BCM56218_A0_CFAPCONFIGr_s {
	uint32_t v[1];
	uint32_t cfapconfig[1];
	uint32_t _cfapconfig;
} BCM56218_A0_CFAPCONFIGr_t;

#define BCM56218_A0_CFAPCONFIGr_CLR(r) (r).cfapconfig[0] = 0
#define BCM56218_A0_CFAPCONFIGr_SET(r,d) (r).cfapconfig[0] = d
#define BCM56218_A0_CFAPCONFIGr_GET(r) (r).cfapconfig[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CFAPCONFIGr_CFAPPOOLSIZEf_GET(r) (((r).cfapconfig[0]) & 0x3fff)
#define BCM56218_A0_CFAPCONFIGr_CFAPPOOLSIZEf_SET(r,f) (r).cfapconfig[0]=(((r).cfapconfig[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM56218_A0_CFAPCONFIGr_CFAPINITf_GET(r) ((((r).cfapconfig[0]) >> 14) & 0x1)
#define BCM56218_A0_CFAPCONFIGr_CFAPINITf_SET(r,f) (r).cfapconfig[0]=(((r).cfapconfig[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))

/*
 * These macros can be used to access CFAPCONFIG.
 *
 */
#define BCM56218_A0_READ_CFAPCONFIGr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_CFAPCONFIGr,(r._cfapconfig))
#define BCM56218_A0_WRITE_CFAPCONFIGr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_CFAPCONFIGr,&(r._cfapconfig))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFAPCONFIGr BCM56218_A0_CFAPCONFIGr
#define CFAPCONFIGr_SIZE BCM56218_A0_CFAPCONFIGr_SIZE
typedef BCM56218_A0_CFAPCONFIGr_t CFAPCONFIGr_t;
#define CFAPCONFIGr_CLR BCM56218_A0_CFAPCONFIGr_CLR
#define CFAPCONFIGr_SET BCM56218_A0_CFAPCONFIGr_SET
#define CFAPCONFIGr_GET BCM56218_A0_CFAPCONFIGr_GET
#define CFAPCONFIGr_CFAPPOOLSIZEf_GET BCM56218_A0_CFAPCONFIGr_CFAPPOOLSIZEf_GET
#define CFAPCONFIGr_CFAPPOOLSIZEf_SET BCM56218_A0_CFAPCONFIGr_CFAPPOOLSIZEf_SET
#define CFAPCONFIGr_CFAPINITf_GET BCM56218_A0_CFAPCONFIGr_CFAPINITf_GET
#define CFAPCONFIGr_CFAPINITf_SET BCM56218_A0_CFAPCONFIGr_CFAPINITf_SET
#define READ_CFAPCONFIGr BCM56218_A0_READ_CFAPCONFIGr
#define WRITE_CFAPCONFIGr BCM56218_A0_WRITE_CFAPCONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CFAPCONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CFAPFULLTHRESHOLD
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CFAPFULLSETPOINT CFAP FULL Set Point define the threshold of entering CFAP FULL condition. CFAP is full when CFAP Read Pointer is above this limit.
 *     CFAPFULLRESETPOINT CFAP FULL Reset Point define the threshold of exiting CFAP FULL condition. CFAP is not full when CFAP Read Pointeris below this limit.
 *
 ******************************************************************************/
#define BCM56218_A0_CFAPFULLTHRESHOLDr 0x0068001c

#define BCM56218_A0_CFAPFULLTHRESHOLDr_SIZE 4

/*
 * This structure should be used to declare and program CFAPFULLTHRESHOLD.
 *
 */
typedef union BCM56218_A0_CFAPFULLTHRESHOLDr_s {
	uint32_t v[1];
	uint32_t cfapfullthreshold[1];
	uint32_t _cfapfullthreshold;
} BCM56218_A0_CFAPFULLTHRESHOLDr_t;

#define BCM56218_A0_CFAPFULLTHRESHOLDr_CLR(r) (r).cfapfullthreshold[0] = 0
#define BCM56218_A0_CFAPFULLTHRESHOLDr_SET(r,d) (r).cfapfullthreshold[0] = d
#define BCM56218_A0_CFAPFULLTHRESHOLDr_GET(r) (r).cfapfullthreshold[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CFAPFULLTHRESHOLDr_CFAPFULLSETPOINTf_GET(r) (((r).cfapfullthreshold[0]) & 0x3fff)
#define BCM56218_A0_CFAPFULLTHRESHOLDr_CFAPFULLSETPOINTf_SET(r,f) (r).cfapfullthreshold[0]=(((r).cfapfullthreshold[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM56218_A0_CFAPFULLTHRESHOLDr_CFAPFULLRESETPOINTf_GET(r) ((((r).cfapfullthreshold[0]) >> 14) & 0x3fff)
#define BCM56218_A0_CFAPFULLTHRESHOLDr_CFAPFULLRESETPOINTf_SET(r,f) (r).cfapfullthreshold[0]=(((r).cfapfullthreshold[0] & ~((uint32_t)0x3fff << 14)) | ((((uint32_t)f) & 0x3fff) << 14))

/*
 * These macros can be used to access CFAPFULLTHRESHOLD.
 *
 */
#define BCM56218_A0_READ_CFAPFULLTHRESHOLDr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_CFAPFULLTHRESHOLDr,(r._cfapfullthreshold))
#define BCM56218_A0_WRITE_CFAPFULLTHRESHOLDr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_CFAPFULLTHRESHOLDr,&(r._cfapfullthreshold))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFAPFULLTHRESHOLDr BCM56218_A0_CFAPFULLTHRESHOLDr
#define CFAPFULLTHRESHOLDr_SIZE BCM56218_A0_CFAPFULLTHRESHOLDr_SIZE
typedef BCM56218_A0_CFAPFULLTHRESHOLDr_t CFAPFULLTHRESHOLDr_t;
#define CFAPFULLTHRESHOLDr_CLR BCM56218_A0_CFAPFULLTHRESHOLDr_CLR
#define CFAPFULLTHRESHOLDr_SET BCM56218_A0_CFAPFULLTHRESHOLDr_SET
#define CFAPFULLTHRESHOLDr_GET BCM56218_A0_CFAPFULLTHRESHOLDr_GET
#define CFAPFULLTHRESHOLDr_CFAPFULLSETPOINTf_GET BCM56218_A0_CFAPFULLTHRESHOLDr_CFAPFULLSETPOINTf_GET
#define CFAPFULLTHRESHOLDr_CFAPFULLSETPOINTf_SET BCM56218_A0_CFAPFULLTHRESHOLDr_CFAPFULLSETPOINTf_SET
#define CFAPFULLTHRESHOLDr_CFAPFULLRESETPOINTf_GET BCM56218_A0_CFAPFULLTHRESHOLDr_CFAPFULLRESETPOINTf_GET
#define CFAPFULLTHRESHOLDr_CFAPFULLRESETPOINTf_SET BCM56218_A0_CFAPFULLTHRESHOLDr_CFAPFULLRESETPOINTf_SET
#define READ_CFAPFULLTHRESHOLDr BCM56218_A0_READ_CFAPFULLTHRESHOLDr
#define WRITE_CFAPFULLTHRESHOLDr BCM56218_A0_WRITE_CFAPFULLTHRESHOLDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CFAPFULLTHRESHOLDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CFAPMEMDEBUG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     SAM              sam registers.
 *     CT0              ct0 registers.
 *     CT1              ct1 registers.
 *     CT2              ct2 registers.
 *
 ******************************************************************************/
#define BCM56218_A0_CFAPMEMDEBUGr 0x00680041

#define BCM56218_A0_CFAPMEMDEBUGr_SIZE 4

/*
 * This structure should be used to declare and program CFAPMEMDEBUG.
 *
 */
typedef union BCM56218_A0_CFAPMEMDEBUGr_s {
	uint32_t v[1];
	uint32_t cfapmemdebug[1];
	uint32_t _cfapmemdebug;
} BCM56218_A0_CFAPMEMDEBUGr_t;

#define BCM56218_A0_CFAPMEMDEBUGr_CLR(r) (r).cfapmemdebug[0] = 0
#define BCM56218_A0_CFAPMEMDEBUGr_SET(r,d) (r).cfapmemdebug[0] = d
#define BCM56218_A0_CFAPMEMDEBUGr_GET(r) (r).cfapmemdebug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CFAPMEMDEBUGr_SAMf_GET(r) (((r).cfapmemdebug[0]) & 0x3)
#define BCM56218_A0_CFAPMEMDEBUGr_SAMf_SET(r,f) (r).cfapmemdebug[0]=(((r).cfapmemdebug[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56218_A0_CFAPMEMDEBUGr_CT0f_GET(r) ((((r).cfapmemdebug[0]) >> 2) & 0x1)
#define BCM56218_A0_CFAPMEMDEBUGr_CT0f_SET(r,f) (r).cfapmemdebug[0]=(((r).cfapmemdebug[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_CFAPMEMDEBUGr_CT1f_GET(r) ((((r).cfapmemdebug[0]) >> 3) & 0x1)
#define BCM56218_A0_CFAPMEMDEBUGr_CT1f_SET(r,f) (r).cfapmemdebug[0]=(((r).cfapmemdebug[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56218_A0_CFAPMEMDEBUGr_CT2f_GET(r) ((((r).cfapmemdebug[0]) >> 4) & 0x1)
#define BCM56218_A0_CFAPMEMDEBUGr_CT2f_SET(r,f) (r).cfapmemdebug[0]=(((r).cfapmemdebug[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))

/*
 * These macros can be used to access CFAPMEMDEBUG.
 *
 */
#define BCM56218_A0_READ_CFAPMEMDEBUGr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_CFAPMEMDEBUGr,(r._cfapmemdebug))
#define BCM56218_A0_WRITE_CFAPMEMDEBUGr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_CFAPMEMDEBUGr,&(r._cfapmemdebug))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFAPMEMDEBUGr BCM56218_A0_CFAPMEMDEBUGr
#define CFAPMEMDEBUGr_SIZE BCM56218_A0_CFAPMEMDEBUGr_SIZE
typedef BCM56218_A0_CFAPMEMDEBUGr_t CFAPMEMDEBUGr_t;
#define CFAPMEMDEBUGr_CLR BCM56218_A0_CFAPMEMDEBUGr_CLR
#define CFAPMEMDEBUGr_SET BCM56218_A0_CFAPMEMDEBUGr_SET
#define CFAPMEMDEBUGr_GET BCM56218_A0_CFAPMEMDEBUGr_GET
#define CFAPMEMDEBUGr_SAMf_GET BCM56218_A0_CFAPMEMDEBUGr_SAMf_GET
#define CFAPMEMDEBUGr_SAMf_SET BCM56218_A0_CFAPMEMDEBUGr_SAMf_SET
#define CFAPMEMDEBUGr_CT0f_GET BCM56218_A0_CFAPMEMDEBUGr_CT0f_GET
#define CFAPMEMDEBUGr_CT0f_SET BCM56218_A0_CFAPMEMDEBUGr_CT0f_SET
#define CFAPMEMDEBUGr_CT1f_GET BCM56218_A0_CFAPMEMDEBUGr_CT1f_GET
#define CFAPMEMDEBUGr_CT1f_SET BCM56218_A0_CFAPMEMDEBUGr_CT1f_SET
#define CFAPMEMDEBUGr_CT2f_GET BCM56218_A0_CFAPMEMDEBUGr_CT2f_GET
#define CFAPMEMDEBUGr_CT2f_SET BCM56218_A0_CFAPMEMDEBUGr_CT2f_SET
#define READ_CFAPMEMDEBUGr BCM56218_A0_READ_CFAPMEMDEBUGr
#define WRITE_CFAPMEMDEBUGr BCM56218_A0_WRITE_CFAPMEMDEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CFAPMEMDEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CFAPPARITYERRORPTR
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CFAPPARITYERRORPTR MMU CFAP memory parity error pointer indicats.this register only keeps the most current cfap parity error pointer.
 *
 ******************************************************************************/
#define BCM56218_A0_CFAPPARITYERRORPTRr 0x0068003e

#define BCM56218_A0_CFAPPARITYERRORPTRr_SIZE 4

/*
 * This structure should be used to declare and program CFAPPARITYERRORPTR.
 *
 */
typedef union BCM56218_A0_CFAPPARITYERRORPTRr_s {
	uint32_t v[1];
	uint32_t cfapparityerrorptr[1];
	uint32_t _cfapparityerrorptr;
} BCM56218_A0_CFAPPARITYERRORPTRr_t;

#define BCM56218_A0_CFAPPARITYERRORPTRr_CLR(r) (r).cfapparityerrorptr[0] = 0
#define BCM56218_A0_CFAPPARITYERRORPTRr_SET(r,d) (r).cfapparityerrorptr[0] = d
#define BCM56218_A0_CFAPPARITYERRORPTRr_GET(r) (r).cfapparityerrorptr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CFAPPARITYERRORPTRr_CFAPPARITYERRORPTRf_GET(r) (((r).cfapparityerrorptr[0]) & 0x3fff)
#define BCM56218_A0_CFAPPARITYERRORPTRr_CFAPPARITYERRORPTRf_SET(r,f) (r).cfapparityerrorptr[0]=(((r).cfapparityerrorptr[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access CFAPPARITYERRORPTR.
 *
 */
#define BCM56218_A0_READ_CFAPPARITYERRORPTRr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_CFAPPARITYERRORPTRr,(r._cfapparityerrorptr))
#define BCM56218_A0_WRITE_CFAPPARITYERRORPTRr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_CFAPPARITYERRORPTRr,&(r._cfapparityerrorptr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFAPPARITYERRORPTRr BCM56218_A0_CFAPPARITYERRORPTRr
#define CFAPPARITYERRORPTRr_SIZE BCM56218_A0_CFAPPARITYERRORPTRr_SIZE
typedef BCM56218_A0_CFAPPARITYERRORPTRr_t CFAPPARITYERRORPTRr_t;
#define CFAPPARITYERRORPTRr_CLR BCM56218_A0_CFAPPARITYERRORPTRr_CLR
#define CFAPPARITYERRORPTRr_SET BCM56218_A0_CFAPPARITYERRORPTRr_SET
#define CFAPPARITYERRORPTRr_GET BCM56218_A0_CFAPPARITYERRORPTRr_GET
#define CFAPPARITYERRORPTRr_CFAPPARITYERRORPTRf_GET BCM56218_A0_CFAPPARITYERRORPTRr_CFAPPARITYERRORPTRf_GET
#define CFAPPARITYERRORPTRr_CFAPPARITYERRORPTRf_SET BCM56218_A0_CFAPPARITYERRORPTRr_CFAPPARITYERRORPTRf_SET
#define READ_CFAPPARITYERRORPTRr BCM56218_A0_READ_CFAPPARITYERRORPTRr
#define WRITE_CFAPPARITYERRORPTRr BCM56218_A0_WRITE_CFAPPARITYERRORPTRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CFAPPARITYERRORPTRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CFAPREADPOINTER
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CFAPREADPOINTER  The current number of cells that are outstanding in the CBP memory.
 *     CBPFULLSTATUS    Current CBP FULL Status
 *
 ******************************************************************************/
#define BCM56218_A0_CFAPREADPOINTERr 0x0068001b

#define BCM56218_A0_CFAPREADPOINTERr_SIZE 4

/*
 * This structure should be used to declare and program CFAPREADPOINTER.
 *
 */
typedef union BCM56218_A0_CFAPREADPOINTERr_s {
	uint32_t v[1];
	uint32_t cfapreadpointer[1];
	uint32_t _cfapreadpointer;
} BCM56218_A0_CFAPREADPOINTERr_t;

#define BCM56218_A0_CFAPREADPOINTERr_CLR(r) (r).cfapreadpointer[0] = 0
#define BCM56218_A0_CFAPREADPOINTERr_SET(r,d) (r).cfapreadpointer[0] = d
#define BCM56218_A0_CFAPREADPOINTERr_GET(r) (r).cfapreadpointer[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CFAPREADPOINTERr_CFAPREADPOINTERf_GET(r) (((r).cfapreadpointer[0]) & 0x3fff)
#define BCM56218_A0_CFAPREADPOINTERr_CFAPREADPOINTERf_SET(r,f) (r).cfapreadpointer[0]=(((r).cfapreadpointer[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM56218_A0_CFAPREADPOINTERr_CBPFULLSTATUSf_GET(r) ((((r).cfapreadpointer[0]) >> 14) & 0x1)
#define BCM56218_A0_CFAPREADPOINTERr_CBPFULLSTATUSf_SET(r,f) (r).cfapreadpointer[0]=(((r).cfapreadpointer[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))

/*
 * These macros can be used to access CFAPREADPOINTER.
 *
 */
#define BCM56218_A0_READ_CFAPREADPOINTERr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_CFAPREADPOINTERr,(r._cfapreadpointer))
#define BCM56218_A0_WRITE_CFAPREADPOINTERr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_CFAPREADPOINTERr,&(r._cfapreadpointer))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFAPREADPOINTERr BCM56218_A0_CFAPREADPOINTERr
#define CFAPREADPOINTERr_SIZE BCM56218_A0_CFAPREADPOINTERr_SIZE
typedef BCM56218_A0_CFAPREADPOINTERr_t CFAPREADPOINTERr_t;
#define CFAPREADPOINTERr_CLR BCM56218_A0_CFAPREADPOINTERr_CLR
#define CFAPREADPOINTERr_SET BCM56218_A0_CFAPREADPOINTERr_SET
#define CFAPREADPOINTERr_GET BCM56218_A0_CFAPREADPOINTERr_GET
#define CFAPREADPOINTERr_CFAPREADPOINTERf_GET BCM56218_A0_CFAPREADPOINTERr_CFAPREADPOINTERf_GET
#define CFAPREADPOINTERr_CFAPREADPOINTERf_SET BCM56218_A0_CFAPREADPOINTERr_CFAPREADPOINTERf_SET
#define CFAPREADPOINTERr_CBPFULLSTATUSf_GET BCM56218_A0_CFAPREADPOINTERr_CBPFULLSTATUSf_GET
#define CFAPREADPOINTERr_CBPFULLSTATUSf_SET BCM56218_A0_CFAPREADPOINTERr_CBPFULLSTATUSf_SET
#define READ_CFAPREADPOINTERr BCM56218_A0_READ_CFAPREADPOINTERr
#define WRITE_CFAPREADPOINTERr BCM56218_A0_WRITE_CFAPREADPOINTERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CFAPREADPOINTERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMICTXCOSMASK
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CMICTXCOSMASK    COS Mask sends from CMIC to MMU in order to control which COS packets cpu wants to receive.
 *
 ******************************************************************************/
#define BCM56218_A0_CMICTXCOSMASKr 0x00680022

#define BCM56218_A0_CMICTXCOSMASKr_SIZE 4

/*
 * This structure should be used to declare and program CMICTXCOSMASK.
 *
 */
typedef union BCM56218_A0_CMICTXCOSMASKr_s {
	uint32_t v[1];
	uint32_t cmictxcosmask[1];
	uint32_t _cmictxcosmask;
} BCM56218_A0_CMICTXCOSMASKr_t;

#define BCM56218_A0_CMICTXCOSMASKr_CLR(r) (r).cmictxcosmask[0] = 0
#define BCM56218_A0_CMICTXCOSMASKr_SET(r,d) (r).cmictxcosmask[0] = d
#define BCM56218_A0_CMICTXCOSMASKr_GET(r) (r).cmictxcosmask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMICTXCOSMASKr_CMICTXCOSMASKf_GET(r) (((r).cmictxcosmask[0]) & 0xff)
#define BCM56218_A0_CMICTXCOSMASKr_CMICTXCOSMASKf_SET(r,f) (r).cmictxcosmask[0]=(((r).cmictxcosmask[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access CMICTXCOSMASK.
 *
 */
#define BCM56218_A0_READ_CMICTXCOSMASKr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_CMICTXCOSMASKr,(r._cmictxcosmask))
#define BCM56218_A0_WRITE_CMICTXCOSMASKr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_CMICTXCOSMASKr,&(r._cmictxcosmask))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMICTXCOSMASKr BCM56218_A0_CMICTXCOSMASKr
#define CMICTXCOSMASKr_SIZE BCM56218_A0_CMICTXCOSMASKr_SIZE
typedef BCM56218_A0_CMICTXCOSMASKr_t CMICTXCOSMASKr_t;
#define CMICTXCOSMASKr_CLR BCM56218_A0_CMICTXCOSMASKr_CLR
#define CMICTXCOSMASKr_SET BCM56218_A0_CMICTXCOSMASKr_SET
#define CMICTXCOSMASKr_GET BCM56218_A0_CMICTXCOSMASKr_GET
#define CMICTXCOSMASKr_CMICTXCOSMASKf_GET BCM56218_A0_CMICTXCOSMASKr_CMICTXCOSMASKf_GET
#define CMICTXCOSMASKr_CMICTXCOSMASKf_SET BCM56218_A0_CMICTXCOSMASKr_CMICTXCOSMASKf_SET
#define READ_CMICTXCOSMASKr BCM56218_A0_READ_CMICTXCOSMASKr
#define WRITE_CMICTXCOSMASKr BCM56218_A0_WRITE_CMICTXCOSMASKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMICTXCOSMASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_CONFIG
 * BLOCKS:   CMIC
 * DESC:     Configuration Register
 * SIZE:     32
 * FIELDS:
 *     RD_BRST_EN       When set (1), CMIC supports PIO Read Bursts
 *     WR_BRST_EN       When set (1), CMIC supports PIO Write Bursts
 *     BE_CHECK_EN      When set (1), CMIC Does BE Check (32-bit) on PCI writes
 *     MSTR_Q_MAX_EN    When set (1), CMIC can queue up to 4 PCI master requests
 *     IGNORE_MMU_BKP_TXDMA_PKT If set, CMIC will not honour MMU backpressure signal for TxDMA packets.
 *     RESET_CPS        When set CMIC drives CPS-Channel reset
 *     ACT_LOW_INT      When set CMIC drives INTR pin as Active LOW (0) - Default is Active low
 *     SCHAN_ABORT      When set CMIC aborts any pending SCH operation
 *     UNTAG_ALL_RCV_EN When set CMIC removes the TAG field from all received Packets
 *     UNTAG_EN         When set CMIC can remove the TAG field
 *     LE_DMA_EN        When set CMIC the DMA data transfer will be done in Little Endian format
 *     I2C_EN           When set CMIC PCI access to I2C interface is Enabled
 *     IGNORE_MMU_BKP_REMOTE_PKT If set, CMIC will not honour MMU backpressure signal for remote packets.
 *     IGNORE_ADR_ALIGN_EN When set, allow DMA (PCI->SOC) to be aligned to any address boundary.
 *     RESERVED_3       Reserved
 *     DMA_GARBAGE_COLLECT_EN When set CMIC collects packets with Purge bit set
 *     RESET_PCI_EN     If set, CPS reset will also  reset the internal CMIC PCI interface.
 *     TIME_STAMP_UPD_DIS Disable packet time stamp update operation.  DEBUG ONLY.
 *     SG_ENABLE        Enable scatter/gather operation.
 *     SG_RELOAD_ENABLE Enable scatter/gather reload operation.
 *     RLD_STS_UPD_DIS  When set, do not update status fields on reload operation.
 *     STOP_LS_ON_CHANGE When set, on link change detection, stop link scanning
 *     ABORT_STAT_DMA   Abort the current stat DMA operation.  Not for normal operation.
 *     RESERVED_4       Reserved
 *     COS_RX_EN        When set, packet DMA is based on received COS.  Multiple write channels can be active. 
 *     RESERVED_5       Reserved
 *     OVER_RIDE_EXT_MDIO_MSTR_CNTRL When set, external MDIO master access is disabled,and CMIC becomes the MDIO master, allowing hardware link scan. MUST BE 1 FOR NORMAL OPERATION. Set to 0x0 by default to allow ATE tests to access XAUI/SERDES cores.
 *     MIIM_ADDR_MAP_ENABLE When set, use the MDIO Address Map Table to get the Phy IDfrom the port number for both Wr/Rd and link scan.Else, use the Phy ID as-is.
 *     RESERVED_6       Reserved
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_CONFIGr 0x0000010c

#define BCM56218_A0_CMIC_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CONFIG.
 *
 */
typedef union BCM56218_A0_CMIC_CONFIGr_s {
	uint32_t v[1];
	uint32_t cmic_config[1];
	uint32_t _cmic_config;
} BCM56218_A0_CMIC_CONFIGr_t;

#define BCM56218_A0_CMIC_CONFIGr_CLR(r) (r).cmic_config[0] = 0
#define BCM56218_A0_CMIC_CONFIGr_SET(r,d) (r).cmic_config[0] = d
#define BCM56218_A0_CMIC_CONFIGr_GET(r) (r).cmic_config[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_CONFIGr_RD_BRST_ENf_GET(r) (((r).cmic_config[0]) & 0x1)
#define BCM56218_A0_CMIC_CONFIGr_RD_BRST_ENf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_CMIC_CONFIGr_WR_BRST_ENf_GET(r) ((((r).cmic_config[0]) >> 1) & 0x1)
#define BCM56218_A0_CMIC_CONFIGr_WR_BRST_ENf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_CMIC_CONFIGr_BE_CHECK_ENf_GET(r) ((((r).cmic_config[0]) >> 2) & 0x1)
#define BCM56218_A0_CMIC_CONFIGr_BE_CHECK_ENf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_CMIC_CONFIGr_MSTR_Q_MAX_ENf_GET(r) ((((r).cmic_config[0]) >> 3) & 0x1)
#define BCM56218_A0_CMIC_CONFIGr_MSTR_Q_MAX_ENf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56218_A0_CMIC_CONFIGr_IGNORE_MMU_BKP_TXDMA_PKTf_GET(r) ((((r).cmic_config[0]) >> 4) & 0x1)
#define BCM56218_A0_CMIC_CONFIGr_IGNORE_MMU_BKP_TXDMA_PKTf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56218_A0_CMIC_CONFIGr_RESET_CPSf_GET(r) ((((r).cmic_config[0]) >> 5) & 0x1)
#define BCM56218_A0_CMIC_CONFIGr_RESET_CPSf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56218_A0_CMIC_CONFIGr_ACT_LOW_INTf_GET(r) ((((r).cmic_config[0]) >> 6) & 0x1)
#define BCM56218_A0_CMIC_CONFIGr_ACT_LOW_INTf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56218_A0_CMIC_CONFIGr_SCHAN_ABORTf_GET(r) ((((r).cmic_config[0]) >> 7) & 0x1)
#define BCM56218_A0_CMIC_CONFIGr_SCHAN_ABORTf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56218_A0_CMIC_CONFIGr_UNTAG_ALL_RCV_ENf_GET(r) ((((r).cmic_config[0]) >> 8) & 0x1)
#define BCM56218_A0_CMIC_CONFIGr_UNTAG_ALL_RCV_ENf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56218_A0_CMIC_CONFIGr_UNTAG_ENf_GET(r) ((((r).cmic_config[0]) >> 9) & 0x1)
#define BCM56218_A0_CMIC_CONFIGr_UNTAG_ENf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56218_A0_CMIC_CONFIGr_LE_DMA_ENf_GET(r) ((((r).cmic_config[0]) >> 10) & 0x1)
#define BCM56218_A0_CMIC_CONFIGr_LE_DMA_ENf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56218_A0_CMIC_CONFIGr_I2C_ENf_GET(r) ((((r).cmic_config[0]) >> 11) & 0x1)
#define BCM56218_A0_CMIC_CONFIGr_I2C_ENf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56218_A0_CMIC_CONFIGr_IGNORE_MMU_BKP_REMOTE_PKTf_GET(r) ((((r).cmic_config[0]) >> 12) & 0x1)
#define BCM56218_A0_CMIC_CONFIGr_IGNORE_MMU_BKP_REMOTE_PKTf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM56218_A0_CMIC_CONFIGr_IGNORE_ADR_ALIGN_ENf_GET(r) ((((r).cmic_config[0]) >> 13) & 0x1)
#define BCM56218_A0_CMIC_CONFIGr_IGNORE_ADR_ALIGN_ENf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56218_A0_CMIC_CONFIGr_RESERVED_3f_GET(r) ((((r).cmic_config[0]) >> 14) & 0x1)
#define BCM56218_A0_CMIC_CONFIGr_RESERVED_3f_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM56218_A0_CMIC_CONFIGr_DMA_GARBAGE_COLLECT_ENf_GET(r) ((((r).cmic_config[0]) >> 15) & 0x1)
#define BCM56218_A0_CMIC_CONFIGr_DMA_GARBAGE_COLLECT_ENf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56218_A0_CMIC_CONFIGr_RESET_PCI_ENf_GET(r) ((((r).cmic_config[0]) >> 16) & 0x1)
#define BCM56218_A0_CMIC_CONFIGr_RESET_PCI_ENf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56218_A0_CMIC_CONFIGr_TIME_STAMP_UPD_DISf_GET(r) ((((r).cmic_config[0]) >> 17) & 0x1)
#define BCM56218_A0_CMIC_CONFIGr_TIME_STAMP_UPD_DISf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_CMIC_CONFIGr_SG_ENABLEf_GET(r) ((((r).cmic_config[0]) >> 18) & 0x1)
#define BCM56218_A0_CMIC_CONFIGr_SG_ENABLEf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_CMIC_CONFIGr_SG_RELOAD_ENABLEf_GET(r) ((((r).cmic_config[0]) >> 19) & 0x1)
#define BCM56218_A0_CMIC_CONFIGr_SG_RELOAD_ENABLEf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56218_A0_CMIC_CONFIGr_RLD_STS_UPD_DISf_GET(r) ((((r).cmic_config[0]) >> 20) & 0x1)
#define BCM56218_A0_CMIC_CONFIGr_RLD_STS_UPD_DISf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM56218_A0_CMIC_CONFIGr_STOP_LS_ON_CHANGEf_GET(r) ((((r).cmic_config[0]) >> 21) & 0x1)
#define BCM56218_A0_CMIC_CONFIGr_STOP_LS_ON_CHANGEf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM56218_A0_CMIC_CONFIGr_ABORT_STAT_DMAf_GET(r) ((((r).cmic_config[0]) >> 22) & 0x1)
#define BCM56218_A0_CMIC_CONFIGr_ABORT_STAT_DMAf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM56218_A0_CMIC_CONFIGr_RESERVED_4f_GET(r) ((((r).cmic_config[0]) >> 23) & 0x1)
#define BCM56218_A0_CMIC_CONFIGr_RESERVED_4f_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM56218_A0_CMIC_CONFIGr_COS_RX_ENf_GET(r) ((((r).cmic_config[0]) >> 24) & 0x1)
#define BCM56218_A0_CMIC_CONFIGr_COS_RX_ENf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM56218_A0_CMIC_CONFIGr_RESERVED_5f_GET(r) ((((r).cmic_config[0]) >> 25) & 0x1)
#define BCM56218_A0_CMIC_CONFIGr_RESERVED_5f_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM56218_A0_CMIC_CONFIGr_OVER_RIDE_EXT_MDIO_MSTR_CNTRLf_GET(r) ((((r).cmic_config[0]) >> 26) & 0x1)
#define BCM56218_A0_CMIC_CONFIGr_OVER_RIDE_EXT_MDIO_MSTR_CNTRLf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM56218_A0_CMIC_CONFIGr_MIIM_ADDR_MAP_ENABLEf_GET(r) ((((r).cmic_config[0]) >> 27) & 0x1)
#define BCM56218_A0_CMIC_CONFIGr_MIIM_ADDR_MAP_ENABLEf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM56218_A0_CMIC_CONFIGr_RESERVED_6f_GET(r) ((((r).cmic_config[0]) >> 28) & 0xf)
#define BCM56218_A0_CMIC_CONFIGr_RESERVED_6f_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access CMIC_CONFIG.
 *
 */
#define BCM56218_A0_READ_CMIC_CONFIGr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_CONFIGr,r._cmic_config)
#define BCM56218_A0_WRITE_CMIC_CONFIGr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_CONFIGr,r._cmic_config)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_CONFIGr BCM56218_A0_CMIC_CONFIGr
#define CMIC_CONFIGr_SIZE BCM56218_A0_CMIC_CONFIGr_SIZE
typedef BCM56218_A0_CMIC_CONFIGr_t CMIC_CONFIGr_t;
#define CMIC_CONFIGr_CLR BCM56218_A0_CMIC_CONFIGr_CLR
#define CMIC_CONFIGr_SET BCM56218_A0_CMIC_CONFIGr_SET
#define CMIC_CONFIGr_GET BCM56218_A0_CMIC_CONFIGr_GET
#define CMIC_CONFIGr_RD_BRST_ENf_GET BCM56218_A0_CMIC_CONFIGr_RD_BRST_ENf_GET
#define CMIC_CONFIGr_RD_BRST_ENf_SET BCM56218_A0_CMIC_CONFIGr_RD_BRST_ENf_SET
#define CMIC_CONFIGr_WR_BRST_ENf_GET BCM56218_A0_CMIC_CONFIGr_WR_BRST_ENf_GET
#define CMIC_CONFIGr_WR_BRST_ENf_SET BCM56218_A0_CMIC_CONFIGr_WR_BRST_ENf_SET
#define CMIC_CONFIGr_BE_CHECK_ENf_GET BCM56218_A0_CMIC_CONFIGr_BE_CHECK_ENf_GET
#define CMIC_CONFIGr_BE_CHECK_ENf_SET BCM56218_A0_CMIC_CONFIGr_BE_CHECK_ENf_SET
#define CMIC_CONFIGr_MSTR_Q_MAX_ENf_GET BCM56218_A0_CMIC_CONFIGr_MSTR_Q_MAX_ENf_GET
#define CMIC_CONFIGr_MSTR_Q_MAX_ENf_SET BCM56218_A0_CMIC_CONFIGr_MSTR_Q_MAX_ENf_SET
#define CMIC_CONFIGr_IGNORE_MMU_BKP_TXDMA_PKTf_GET BCM56218_A0_CMIC_CONFIGr_IGNORE_MMU_BKP_TXDMA_PKTf_GET
#define CMIC_CONFIGr_IGNORE_MMU_BKP_TXDMA_PKTf_SET BCM56218_A0_CMIC_CONFIGr_IGNORE_MMU_BKP_TXDMA_PKTf_SET
#define CMIC_CONFIGr_RESET_CPSf_GET BCM56218_A0_CMIC_CONFIGr_RESET_CPSf_GET
#define CMIC_CONFIGr_RESET_CPSf_SET BCM56218_A0_CMIC_CONFIGr_RESET_CPSf_SET
#define CMIC_CONFIGr_ACT_LOW_INTf_GET BCM56218_A0_CMIC_CONFIGr_ACT_LOW_INTf_GET
#define CMIC_CONFIGr_ACT_LOW_INTf_SET BCM56218_A0_CMIC_CONFIGr_ACT_LOW_INTf_SET
#define CMIC_CONFIGr_SCHAN_ABORTf_GET BCM56218_A0_CMIC_CONFIGr_SCHAN_ABORTf_GET
#define CMIC_CONFIGr_SCHAN_ABORTf_SET BCM56218_A0_CMIC_CONFIGr_SCHAN_ABORTf_SET
#define CMIC_CONFIGr_UNTAG_ALL_RCV_ENf_GET BCM56218_A0_CMIC_CONFIGr_UNTAG_ALL_RCV_ENf_GET
#define CMIC_CONFIGr_UNTAG_ALL_RCV_ENf_SET BCM56218_A0_CMIC_CONFIGr_UNTAG_ALL_RCV_ENf_SET
#define CMIC_CONFIGr_UNTAG_ENf_GET BCM56218_A0_CMIC_CONFIGr_UNTAG_ENf_GET
#define CMIC_CONFIGr_UNTAG_ENf_SET BCM56218_A0_CMIC_CONFIGr_UNTAG_ENf_SET
#define CMIC_CONFIGr_LE_DMA_ENf_GET BCM56218_A0_CMIC_CONFIGr_LE_DMA_ENf_GET
#define CMIC_CONFIGr_LE_DMA_ENf_SET BCM56218_A0_CMIC_CONFIGr_LE_DMA_ENf_SET
#define CMIC_CONFIGr_I2C_ENf_GET BCM56218_A0_CMIC_CONFIGr_I2C_ENf_GET
#define CMIC_CONFIGr_I2C_ENf_SET BCM56218_A0_CMIC_CONFIGr_I2C_ENf_SET
#define CMIC_CONFIGr_IGNORE_MMU_BKP_REMOTE_PKTf_GET BCM56218_A0_CMIC_CONFIGr_IGNORE_MMU_BKP_REMOTE_PKTf_GET
#define CMIC_CONFIGr_IGNORE_MMU_BKP_REMOTE_PKTf_SET BCM56218_A0_CMIC_CONFIGr_IGNORE_MMU_BKP_REMOTE_PKTf_SET
#define CMIC_CONFIGr_IGNORE_ADR_ALIGN_ENf_GET BCM56218_A0_CMIC_CONFIGr_IGNORE_ADR_ALIGN_ENf_GET
#define CMIC_CONFIGr_IGNORE_ADR_ALIGN_ENf_SET BCM56218_A0_CMIC_CONFIGr_IGNORE_ADR_ALIGN_ENf_SET
#define CMIC_CONFIGr_RESERVED_3f_GET BCM56218_A0_CMIC_CONFIGr_RESERVED_3f_GET
#define CMIC_CONFIGr_RESERVED_3f_SET BCM56218_A0_CMIC_CONFIGr_RESERVED_3f_SET
#define CMIC_CONFIGr_DMA_GARBAGE_COLLECT_ENf_GET BCM56218_A0_CMIC_CONFIGr_DMA_GARBAGE_COLLECT_ENf_GET
#define CMIC_CONFIGr_DMA_GARBAGE_COLLECT_ENf_SET BCM56218_A0_CMIC_CONFIGr_DMA_GARBAGE_COLLECT_ENf_SET
#define CMIC_CONFIGr_RESET_PCI_ENf_GET BCM56218_A0_CMIC_CONFIGr_RESET_PCI_ENf_GET
#define CMIC_CONFIGr_RESET_PCI_ENf_SET BCM56218_A0_CMIC_CONFIGr_RESET_PCI_ENf_SET
#define CMIC_CONFIGr_TIME_STAMP_UPD_DISf_GET BCM56218_A0_CMIC_CONFIGr_TIME_STAMP_UPD_DISf_GET
#define CMIC_CONFIGr_TIME_STAMP_UPD_DISf_SET BCM56218_A0_CMIC_CONFIGr_TIME_STAMP_UPD_DISf_SET
#define CMIC_CONFIGr_SG_ENABLEf_GET BCM56218_A0_CMIC_CONFIGr_SG_ENABLEf_GET
#define CMIC_CONFIGr_SG_ENABLEf_SET BCM56218_A0_CMIC_CONFIGr_SG_ENABLEf_SET
#define CMIC_CONFIGr_SG_RELOAD_ENABLEf_GET BCM56218_A0_CMIC_CONFIGr_SG_RELOAD_ENABLEf_GET
#define CMIC_CONFIGr_SG_RELOAD_ENABLEf_SET BCM56218_A0_CMIC_CONFIGr_SG_RELOAD_ENABLEf_SET
#define CMIC_CONFIGr_RLD_STS_UPD_DISf_GET BCM56218_A0_CMIC_CONFIGr_RLD_STS_UPD_DISf_GET
#define CMIC_CONFIGr_RLD_STS_UPD_DISf_SET BCM56218_A0_CMIC_CONFIGr_RLD_STS_UPD_DISf_SET
#define CMIC_CONFIGr_STOP_LS_ON_CHANGEf_GET BCM56218_A0_CMIC_CONFIGr_STOP_LS_ON_CHANGEf_GET
#define CMIC_CONFIGr_STOP_LS_ON_CHANGEf_SET BCM56218_A0_CMIC_CONFIGr_STOP_LS_ON_CHANGEf_SET
#define CMIC_CONFIGr_ABORT_STAT_DMAf_GET BCM56218_A0_CMIC_CONFIGr_ABORT_STAT_DMAf_GET
#define CMIC_CONFIGr_ABORT_STAT_DMAf_SET BCM56218_A0_CMIC_CONFIGr_ABORT_STAT_DMAf_SET
#define CMIC_CONFIGr_RESERVED_4f_GET BCM56218_A0_CMIC_CONFIGr_RESERVED_4f_GET
#define CMIC_CONFIGr_RESERVED_4f_SET BCM56218_A0_CMIC_CONFIGr_RESERVED_4f_SET
#define CMIC_CONFIGr_COS_RX_ENf_GET BCM56218_A0_CMIC_CONFIGr_COS_RX_ENf_GET
#define CMIC_CONFIGr_COS_RX_ENf_SET BCM56218_A0_CMIC_CONFIGr_COS_RX_ENf_SET
#define CMIC_CONFIGr_RESERVED_5f_GET BCM56218_A0_CMIC_CONFIGr_RESERVED_5f_GET
#define CMIC_CONFIGr_RESERVED_5f_SET BCM56218_A0_CMIC_CONFIGr_RESERVED_5f_SET
#define CMIC_CONFIGr_OVER_RIDE_EXT_MDIO_MSTR_CNTRLf_GET BCM56218_A0_CMIC_CONFIGr_OVER_RIDE_EXT_MDIO_MSTR_CNTRLf_GET
#define CMIC_CONFIGr_OVER_RIDE_EXT_MDIO_MSTR_CNTRLf_SET BCM56218_A0_CMIC_CONFIGr_OVER_RIDE_EXT_MDIO_MSTR_CNTRLf_SET
#define CMIC_CONFIGr_MIIM_ADDR_MAP_ENABLEf_GET BCM56218_A0_CMIC_CONFIGr_MIIM_ADDR_MAP_ENABLEf_GET
#define CMIC_CONFIGr_MIIM_ADDR_MAP_ENABLEf_SET BCM56218_A0_CMIC_CONFIGr_MIIM_ADDR_MAP_ENABLEf_SET
#define CMIC_CONFIGr_RESERVED_6f_GET BCM56218_A0_CMIC_CONFIGr_RESERVED_6f_GET
#define CMIC_CONFIGr_RESERVED_6f_SET BCM56218_A0_CMIC_CONFIGr_RESERVED_6f_SET
#define READ_CMIC_CONFIGr BCM56218_A0_READ_CMIC_CONFIGr
#define WRITE_CMIC_CONFIGr BCM56218_A0_WRITE_CMIC_CONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_COS_CTRL_RX
 * BLOCKS:   CMIC
 * DESC:     When COS_RX_EN of CMIC_CONFIG is set, this register
indicates which cos are admitted by channel 

 * SIZE:     32
 * FIELDS:
 *     CH0_COS_BMP      Channel 0 COS bitmap
 *     CH1_COS_BMP      Channel 1 COS bitmap
 *     CH2_COS_BMP      Channel 2 COS bitmap
 *     CH3_COS_BMP      Channel 3 COS bitmap
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_COS_CTRL_RXr 0x00000180

#define BCM56218_A0_CMIC_COS_CTRL_RXr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_COS_CTRL_RX.
 *
 */
typedef union BCM56218_A0_CMIC_COS_CTRL_RXr_s {
	uint32_t v[1];
	uint32_t cmic_cos_ctrl_rx[1];
	uint32_t _cmic_cos_ctrl_rx;
} BCM56218_A0_CMIC_COS_CTRL_RXr_t;

#define BCM56218_A0_CMIC_COS_CTRL_RXr_CLR(r) (r).cmic_cos_ctrl_rx[0] = 0
#define BCM56218_A0_CMIC_COS_CTRL_RXr_SET(r,d) (r).cmic_cos_ctrl_rx[0] = d
#define BCM56218_A0_CMIC_COS_CTRL_RXr_GET(r) (r).cmic_cos_ctrl_rx[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_COS_CTRL_RXr_CH0_COS_BMPf_GET(r) (((r).cmic_cos_ctrl_rx[0]) & 0xff)
#define BCM56218_A0_CMIC_COS_CTRL_RXr_CH0_COS_BMPf_SET(r,f) (r).cmic_cos_ctrl_rx[0]=(((r).cmic_cos_ctrl_rx[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56218_A0_CMIC_COS_CTRL_RXr_CH1_COS_BMPf_GET(r) ((((r).cmic_cos_ctrl_rx[0]) >> 8) & 0xff)
#define BCM56218_A0_CMIC_COS_CTRL_RXr_CH1_COS_BMPf_SET(r,f) (r).cmic_cos_ctrl_rx[0]=(((r).cmic_cos_ctrl_rx[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCM56218_A0_CMIC_COS_CTRL_RXr_CH2_COS_BMPf_GET(r) ((((r).cmic_cos_ctrl_rx[0]) >> 16) & 0xff)
#define BCM56218_A0_CMIC_COS_CTRL_RXr_CH2_COS_BMPf_SET(r,f) (r).cmic_cos_ctrl_rx[0]=(((r).cmic_cos_ctrl_rx[0] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define BCM56218_A0_CMIC_COS_CTRL_RXr_CH3_COS_BMPf_GET(r) ((((r).cmic_cos_ctrl_rx[0]) >> 24) & 0xff)
#define BCM56218_A0_CMIC_COS_CTRL_RXr_CH3_COS_BMPf_SET(r,f) (r).cmic_cos_ctrl_rx[0]=(((r).cmic_cos_ctrl_rx[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access CMIC_COS_CTRL_RX.
 *
 */
#define BCM56218_A0_READ_CMIC_COS_CTRL_RXr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_COS_CTRL_RXr,r._cmic_cos_ctrl_rx)
#define BCM56218_A0_WRITE_CMIC_COS_CTRL_RXr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_COS_CTRL_RXr,r._cmic_cos_ctrl_rx)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_COS_CTRL_RXr BCM56218_A0_CMIC_COS_CTRL_RXr
#define CMIC_COS_CTRL_RXr_SIZE BCM56218_A0_CMIC_COS_CTRL_RXr_SIZE
typedef BCM56218_A0_CMIC_COS_CTRL_RXr_t CMIC_COS_CTRL_RXr_t;
#define CMIC_COS_CTRL_RXr_CLR BCM56218_A0_CMIC_COS_CTRL_RXr_CLR
#define CMIC_COS_CTRL_RXr_SET BCM56218_A0_CMIC_COS_CTRL_RXr_SET
#define CMIC_COS_CTRL_RXr_GET BCM56218_A0_CMIC_COS_CTRL_RXr_GET
#define CMIC_COS_CTRL_RXr_CH0_COS_BMPf_GET BCM56218_A0_CMIC_COS_CTRL_RXr_CH0_COS_BMPf_GET
#define CMIC_COS_CTRL_RXr_CH0_COS_BMPf_SET BCM56218_A0_CMIC_COS_CTRL_RXr_CH0_COS_BMPf_SET
#define CMIC_COS_CTRL_RXr_CH1_COS_BMPf_GET BCM56218_A0_CMIC_COS_CTRL_RXr_CH1_COS_BMPf_GET
#define CMIC_COS_CTRL_RXr_CH1_COS_BMPf_SET BCM56218_A0_CMIC_COS_CTRL_RXr_CH1_COS_BMPf_SET
#define CMIC_COS_CTRL_RXr_CH2_COS_BMPf_GET BCM56218_A0_CMIC_COS_CTRL_RXr_CH2_COS_BMPf_GET
#define CMIC_COS_CTRL_RXr_CH2_COS_BMPf_SET BCM56218_A0_CMIC_COS_CTRL_RXr_CH2_COS_BMPf_SET
#define CMIC_COS_CTRL_RXr_CH3_COS_BMPf_GET BCM56218_A0_CMIC_COS_CTRL_RXr_CH3_COS_BMPf_GET
#define CMIC_COS_CTRL_RXr_CH3_COS_BMPf_SET BCM56218_A0_CMIC_COS_CTRL_RXr_CH3_COS_BMPf_SET
#define READ_CMIC_COS_CTRL_RXr BCM56218_A0_READ_CMIC_COS_CTRL_RXr
#define WRITE_CMIC_COS_CTRL_RXr BCM56218_A0_WRITE_CMIC_COS_CTRL_RXr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_COS_CTRL_RXr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_COS_CTRL_RX_HI
 * BLOCKS:   CMIC
 * DESC:     When COS_RX_EN of CMIC_CONFIG is set, this register
indicates which cos are admitted by channel 

 * SIZE:     32
 * FIELDS:
 *     CH0_COS_BMP      Channel 0 COS bitmap upper byte
 *     CH1_COS_BMP      Channel 1 COS bitmap upper byte
 *     CH2_COS_BMP      Channel 2 COS bitmap upper byte
 *     CH3_COS_BMP      Channel 3 COS bitmap upper byte
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_COS_CTRL_RX_HIr 0x00000184

#define BCM56218_A0_CMIC_COS_CTRL_RX_HIr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_COS_CTRL_RX_HI.
 *
 */
typedef union BCM56218_A0_CMIC_COS_CTRL_RX_HIr_s {
	uint32_t v[1];
	uint32_t cmic_cos_ctrl_rx_hi[1];
	uint32_t _cmic_cos_ctrl_rx_hi;
} BCM56218_A0_CMIC_COS_CTRL_RX_HIr_t;

#define BCM56218_A0_CMIC_COS_CTRL_RX_HIr_CLR(r) (r).cmic_cos_ctrl_rx_hi[0] = 0
#define BCM56218_A0_CMIC_COS_CTRL_RX_HIr_SET(r,d) (r).cmic_cos_ctrl_rx_hi[0] = d
#define BCM56218_A0_CMIC_COS_CTRL_RX_HIr_GET(r) (r).cmic_cos_ctrl_rx_hi[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_COS_CTRL_RX_HIr_CH0_COS_BMPf_GET(r) (((r).cmic_cos_ctrl_rx_hi[0]) & 0xff)
#define BCM56218_A0_CMIC_COS_CTRL_RX_HIr_CH0_COS_BMPf_SET(r,f) (r).cmic_cos_ctrl_rx_hi[0]=(((r).cmic_cos_ctrl_rx_hi[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56218_A0_CMIC_COS_CTRL_RX_HIr_CH1_COS_BMPf_GET(r) ((((r).cmic_cos_ctrl_rx_hi[0]) >> 8) & 0xff)
#define BCM56218_A0_CMIC_COS_CTRL_RX_HIr_CH1_COS_BMPf_SET(r,f) (r).cmic_cos_ctrl_rx_hi[0]=(((r).cmic_cos_ctrl_rx_hi[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCM56218_A0_CMIC_COS_CTRL_RX_HIr_CH2_COS_BMPf_GET(r) ((((r).cmic_cos_ctrl_rx_hi[0]) >> 16) & 0xff)
#define BCM56218_A0_CMIC_COS_CTRL_RX_HIr_CH2_COS_BMPf_SET(r,f) (r).cmic_cos_ctrl_rx_hi[0]=(((r).cmic_cos_ctrl_rx_hi[0] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define BCM56218_A0_CMIC_COS_CTRL_RX_HIr_CH3_COS_BMPf_GET(r) ((((r).cmic_cos_ctrl_rx_hi[0]) >> 24) & 0xff)
#define BCM56218_A0_CMIC_COS_CTRL_RX_HIr_CH3_COS_BMPf_SET(r,f) (r).cmic_cos_ctrl_rx_hi[0]=(((r).cmic_cos_ctrl_rx_hi[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access CMIC_COS_CTRL_RX_HI.
 *
 */
#define BCM56218_A0_READ_CMIC_COS_CTRL_RX_HIr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_COS_CTRL_RX_HIr,r._cmic_cos_ctrl_rx_hi)
#define BCM56218_A0_WRITE_CMIC_COS_CTRL_RX_HIr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_COS_CTRL_RX_HIr,r._cmic_cos_ctrl_rx_hi)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_COS_CTRL_RX_HIr BCM56218_A0_CMIC_COS_CTRL_RX_HIr
#define CMIC_COS_CTRL_RX_HIr_SIZE BCM56218_A0_CMIC_COS_CTRL_RX_HIr_SIZE
typedef BCM56218_A0_CMIC_COS_CTRL_RX_HIr_t CMIC_COS_CTRL_RX_HIr_t;
#define CMIC_COS_CTRL_RX_HIr_CLR BCM56218_A0_CMIC_COS_CTRL_RX_HIr_CLR
#define CMIC_COS_CTRL_RX_HIr_SET BCM56218_A0_CMIC_COS_CTRL_RX_HIr_SET
#define CMIC_COS_CTRL_RX_HIr_GET BCM56218_A0_CMIC_COS_CTRL_RX_HIr_GET
#define CMIC_COS_CTRL_RX_HIr_CH0_COS_BMPf_GET BCM56218_A0_CMIC_COS_CTRL_RX_HIr_CH0_COS_BMPf_GET
#define CMIC_COS_CTRL_RX_HIr_CH0_COS_BMPf_SET BCM56218_A0_CMIC_COS_CTRL_RX_HIr_CH0_COS_BMPf_SET
#define CMIC_COS_CTRL_RX_HIr_CH1_COS_BMPf_GET BCM56218_A0_CMIC_COS_CTRL_RX_HIr_CH1_COS_BMPf_GET
#define CMIC_COS_CTRL_RX_HIr_CH1_COS_BMPf_SET BCM56218_A0_CMIC_COS_CTRL_RX_HIr_CH1_COS_BMPf_SET
#define CMIC_COS_CTRL_RX_HIr_CH2_COS_BMPf_GET BCM56218_A0_CMIC_COS_CTRL_RX_HIr_CH2_COS_BMPf_GET
#define CMIC_COS_CTRL_RX_HIr_CH2_COS_BMPf_SET BCM56218_A0_CMIC_COS_CTRL_RX_HIr_CH2_COS_BMPf_SET
#define CMIC_COS_CTRL_RX_HIr_CH3_COS_BMPf_GET BCM56218_A0_CMIC_COS_CTRL_RX_HIr_CH3_COS_BMPf_GET
#define CMIC_COS_CTRL_RX_HIr_CH3_COS_BMPf_SET BCM56218_A0_CMIC_COS_CTRL_RX_HIr_CH3_COS_BMPf_SET
#define READ_CMIC_COS_CTRL_RX_HIr BCM56218_A0_READ_CMIC_COS_CTRL_RX_HIr
#define WRITE_CMIC_COS_CTRL_RX_HIr BCM56218_A0_WRITE_CMIC_COS_CTRL_RX_HIr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_COS_CTRL_RX_HIr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_DEV_REV_ID
 * BLOCKS:   CMIC
 * DESC:     Device/revision ID
 * SIZE:     32
 * FIELDS:
 *     DEV_ID           Device ID
 *     REV_ID           Revision ID
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_DEV_REV_IDr 0x00000178

#define BCM56218_A0_CMIC_DEV_REV_IDr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_DEV_REV_ID.
 *
 */
typedef union BCM56218_A0_CMIC_DEV_REV_IDr_s {
	uint32_t v[1];
	uint32_t cmic_dev_rev_id[1];
	uint32_t _cmic_dev_rev_id;
} BCM56218_A0_CMIC_DEV_REV_IDr_t;

#define BCM56218_A0_CMIC_DEV_REV_IDr_CLR(r) (r).cmic_dev_rev_id[0] = 0
#define BCM56218_A0_CMIC_DEV_REV_IDr_SET(r,d) (r).cmic_dev_rev_id[0] = d
#define BCM56218_A0_CMIC_DEV_REV_IDr_GET(r) (r).cmic_dev_rev_id[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_DEV_REV_IDr_DEV_IDf_GET(r) (((r).cmic_dev_rev_id[0]) & 0xffff)
#define BCM56218_A0_CMIC_DEV_REV_IDr_DEV_IDf_SET(r,f) (r).cmic_dev_rev_id[0]=(((r).cmic_dev_rev_id[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56218_A0_CMIC_DEV_REV_IDr_REV_IDf_GET(r) ((((r).cmic_dev_rev_id[0]) >> 16) & 0xff)
#define BCM56218_A0_CMIC_DEV_REV_IDr_REV_IDf_SET(r,f) (r).cmic_dev_rev_id[0]=(((r).cmic_dev_rev_id[0] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define BCM56218_A0_CMIC_DEV_REV_IDr_RESERVED_1f_GET(r) ((((r).cmic_dev_rev_id[0]) >> 24) & 0xff)
#define BCM56218_A0_CMIC_DEV_REV_IDr_RESERVED_1f_SET(r,f) (r).cmic_dev_rev_id[0]=(((r).cmic_dev_rev_id[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access CMIC_DEV_REV_ID.
 *
 */
#define BCM56218_A0_READ_CMIC_DEV_REV_IDr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_DEV_REV_IDr,r._cmic_dev_rev_id)
#define BCM56218_A0_WRITE_CMIC_DEV_REV_IDr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_DEV_REV_IDr,r._cmic_dev_rev_id)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_DEV_REV_IDr BCM56218_A0_CMIC_DEV_REV_IDr
#define CMIC_DEV_REV_IDr_SIZE BCM56218_A0_CMIC_DEV_REV_IDr_SIZE
typedef BCM56218_A0_CMIC_DEV_REV_IDr_t CMIC_DEV_REV_IDr_t;
#define CMIC_DEV_REV_IDr_CLR BCM56218_A0_CMIC_DEV_REV_IDr_CLR
#define CMIC_DEV_REV_IDr_SET BCM56218_A0_CMIC_DEV_REV_IDr_SET
#define CMIC_DEV_REV_IDr_GET BCM56218_A0_CMIC_DEV_REV_IDr_GET
#define CMIC_DEV_REV_IDr_DEV_IDf_GET BCM56218_A0_CMIC_DEV_REV_IDr_DEV_IDf_GET
#define CMIC_DEV_REV_IDr_DEV_IDf_SET BCM56218_A0_CMIC_DEV_REV_IDr_DEV_IDf_SET
#define CMIC_DEV_REV_IDr_REV_IDf_GET BCM56218_A0_CMIC_DEV_REV_IDr_REV_IDf_GET
#define CMIC_DEV_REV_IDr_REV_IDf_SET BCM56218_A0_CMIC_DEV_REV_IDr_REV_IDf_SET
#define CMIC_DEV_REV_IDr_RESERVED_1f_GET BCM56218_A0_CMIC_DEV_REV_IDr_RESERVED_1f_GET
#define CMIC_DEV_REV_IDr_RESERVED_1f_SET BCM56218_A0_CMIC_DEV_REV_IDr_RESERVED_1f_SET
#define READ_CMIC_DEV_REV_IDr BCM56218_A0_READ_CMIC_DEV_REV_IDr
#define WRITE_CMIC_DEV_REV_IDr BCM56218_A0_WRITE_CMIC_DEV_REV_IDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_DEV_REV_IDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_DMA_CTRL
 * BLOCKS:   CMIC
 * DESC:     DMA Control Register
 * SIZE:     32
 * FIELDS:
 *     CH0_DIRECTION    DMA channel 0 direction:1=Mem->SOC, 0=SOC->Mem
 *     RESERVED_1_CH0   Reserved
 *     CH0_ABORT_DMA    DMA channel 0 abort
 *     CH0_SEL_INTR_ON_DESC_OR_PKT DMA channel 0 interrupt select:1=after descriptor, 0=after packet
 *     RESERVED_2_CH0   Reserved
 *     RESERVED_3_CH0   Reserved
 *     CH0_DROP_RX_PKT_ON_CHAIN_END DMA channel 0 setting for handling packet received after hittingend of chain (and hence no descriptors are available)1=drop the packet, 0=block, waiting for descriptor to be available
 *     CH1_DIRECTION    DMA channel 1 direction:1=Mem->SOC, 0=SOC->Mem
 *     RESERVED_1_CH1   Reserved
 *     CH1_ABORT_DMA    DMA channel 1 abort
 *     CH1_SEL_INTR_ON_DESC_OR_PKT DMA channel 1 interrupt select:1=after descriptor, 0=after packet
 *     RESERVED_2_CH1   Reserved
 *     RESERVED_3_CH1   Reserved
 *     CH1_DROP_RX_PKT_ON_CHAIN_END DMA channel 1 setting for handling packet received after hittingend of chain (and hence no descriptors are available)1=drop the packet, 0=block, waiting for descriptor to be available
 *     CH2_DIRECTION    DMA channel 2 direction:1=Mem->SOC, 0=SOC->Mem
 *     RESERVED_1_CH2   Reserved
 *     CH2_ABORT_DMA    DMA channel 2 abort
 *     CH2_SEL_INTR_ON_DESC_OR_PKT DMA channel 2 interrupt select:1=after descriptor, 0=after packet
 *     RESERVED_2_CH2   Reserved
 *     RESERVED_3_CH2   Reserved
 *     CH2_DROP_RX_PKT_ON_CHAIN_END DMA channel 2 setting for handling packet received after hittingend of chain (and hence no descriptors are available)1=drop the packet, 0=block, waiting for descriptor to be available
 *     CH3_DIRECTION    DMA channel 3 direction:1=Mem->SOC, 0=SOC->Mem
 *     RESERVED_1_CH3   Reserved
 *     CH3_ABORT_DMA    DMA channel 3 abort
 *     CH3_SEL_INTR_ON_DESC_OR_PKT DMA channel 3 interrupt select:1=after descriptor, 0=after packet
 *     RESERVED_2_CH3   Reserved
 *     RESERVED_3_CH3   Reserved
 *     CH3_DROP_RX_PKT_ON_CHAIN_END DMA channel 3 setting for handling packet received after hittingend of chain (and hence no descriptors are available)1=drop the packet, 0=block, waiting for descriptor to be available
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_DMA_CTRLr 0x00000100

#define BCM56218_A0_CMIC_DMA_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_DMA_CTRL.
 *
 */
typedef union BCM56218_A0_CMIC_DMA_CTRLr_s {
	uint32_t v[1];
	uint32_t cmic_dma_ctrl[1];
	uint32_t _cmic_dma_ctrl;
} BCM56218_A0_CMIC_DMA_CTRLr_t;

#define BCM56218_A0_CMIC_DMA_CTRLr_CLR(r) (r).cmic_dma_ctrl[0] = 0
#define BCM56218_A0_CMIC_DMA_CTRLr_SET(r,d) (r).cmic_dma_ctrl[0] = d
#define BCM56218_A0_CMIC_DMA_CTRLr_GET(r) (r).cmic_dma_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_DMA_CTRLr_CH0_DIRECTIONf_GET(r) (((r).cmic_dma_ctrl[0]) & 0x1)
#define BCM56218_A0_CMIC_DMA_CTRLr_CH0_DIRECTIONf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_CMIC_DMA_CTRLr_RESERVED_1_CH0f_GET(r) ((((r).cmic_dma_ctrl[0]) >> 1) & 0x1)
#define BCM56218_A0_CMIC_DMA_CTRLr_RESERVED_1_CH0f_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_CMIC_DMA_CTRLr_CH0_ABORT_DMAf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 2) & 0x1)
#define BCM56218_A0_CMIC_DMA_CTRLr_CH0_ABORT_DMAf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_CMIC_DMA_CTRLr_CH0_SEL_INTR_ON_DESC_OR_PKTf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 3) & 0x1)
#define BCM56218_A0_CMIC_DMA_CTRLr_CH0_SEL_INTR_ON_DESC_OR_PKTf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56218_A0_CMIC_DMA_CTRLr_RESERVED_2_CH0f_GET(r) ((((r).cmic_dma_ctrl[0]) >> 4) & 0x1)
#define BCM56218_A0_CMIC_DMA_CTRLr_RESERVED_2_CH0f_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56218_A0_CMIC_DMA_CTRLr_RESERVED_3_CH0f_GET(r) ((((r).cmic_dma_ctrl[0]) >> 5) & 0x3)
#define BCM56218_A0_CMIC_DMA_CTRLr_RESERVED_3_CH0f_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5))
#define BCM56218_A0_CMIC_DMA_CTRLr_CH0_DROP_RX_PKT_ON_CHAIN_ENDf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 7) & 0x1)
#define BCM56218_A0_CMIC_DMA_CTRLr_CH0_DROP_RX_PKT_ON_CHAIN_ENDf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56218_A0_CMIC_DMA_CTRLr_CH1_DIRECTIONf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 8) & 0x1)
#define BCM56218_A0_CMIC_DMA_CTRLr_CH1_DIRECTIONf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56218_A0_CMIC_DMA_CTRLr_RESERVED_1_CH1f_GET(r) ((((r).cmic_dma_ctrl[0]) >> 9) & 0x1)
#define BCM56218_A0_CMIC_DMA_CTRLr_RESERVED_1_CH1f_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56218_A0_CMIC_DMA_CTRLr_CH1_ABORT_DMAf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 10) & 0x1)
#define BCM56218_A0_CMIC_DMA_CTRLr_CH1_ABORT_DMAf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56218_A0_CMIC_DMA_CTRLr_CH1_SEL_INTR_ON_DESC_OR_PKTf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 11) & 0x1)
#define BCM56218_A0_CMIC_DMA_CTRLr_CH1_SEL_INTR_ON_DESC_OR_PKTf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56218_A0_CMIC_DMA_CTRLr_RESERVED_2_CH1f_GET(r) ((((r).cmic_dma_ctrl[0]) >> 12) & 0x1)
#define BCM56218_A0_CMIC_DMA_CTRLr_RESERVED_2_CH1f_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM56218_A0_CMIC_DMA_CTRLr_RESERVED_3_CH1f_GET(r) ((((r).cmic_dma_ctrl[0]) >> 13) & 0x3)
#define BCM56218_A0_CMIC_DMA_CTRLr_RESERVED_3_CH1f_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13))
#define BCM56218_A0_CMIC_DMA_CTRLr_CH1_DROP_RX_PKT_ON_CHAIN_ENDf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 15) & 0x1)
#define BCM56218_A0_CMIC_DMA_CTRLr_CH1_DROP_RX_PKT_ON_CHAIN_ENDf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56218_A0_CMIC_DMA_CTRLr_CH2_DIRECTIONf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 16) & 0x1)
#define BCM56218_A0_CMIC_DMA_CTRLr_CH2_DIRECTIONf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56218_A0_CMIC_DMA_CTRLr_RESERVED_1_CH2f_GET(r) ((((r).cmic_dma_ctrl[0]) >> 17) & 0x1)
#define BCM56218_A0_CMIC_DMA_CTRLr_RESERVED_1_CH2f_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_CMIC_DMA_CTRLr_CH2_ABORT_DMAf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 18) & 0x1)
#define BCM56218_A0_CMIC_DMA_CTRLr_CH2_ABORT_DMAf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_CMIC_DMA_CTRLr_CH2_SEL_INTR_ON_DESC_OR_PKTf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 19) & 0x1)
#define BCM56218_A0_CMIC_DMA_CTRLr_CH2_SEL_INTR_ON_DESC_OR_PKTf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56218_A0_CMIC_DMA_CTRLr_RESERVED_2_CH2f_GET(r) ((((r).cmic_dma_ctrl[0]) >> 20) & 0x1)
#define BCM56218_A0_CMIC_DMA_CTRLr_RESERVED_2_CH2f_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM56218_A0_CMIC_DMA_CTRLr_RESERVED_3_CH2f_GET(r) ((((r).cmic_dma_ctrl[0]) >> 21) & 0x3)
#define BCM56218_A0_CMIC_DMA_CTRLr_RESERVED_3_CH2f_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x3 << 21)) | ((((uint32_t)f) & 0x3) << 21))
#define BCM56218_A0_CMIC_DMA_CTRLr_CH2_DROP_RX_PKT_ON_CHAIN_ENDf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 23) & 0x1)
#define BCM56218_A0_CMIC_DMA_CTRLr_CH2_DROP_RX_PKT_ON_CHAIN_ENDf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM56218_A0_CMIC_DMA_CTRLr_CH3_DIRECTIONf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 24) & 0x1)
#define BCM56218_A0_CMIC_DMA_CTRLr_CH3_DIRECTIONf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM56218_A0_CMIC_DMA_CTRLr_RESERVED_1_CH3f_GET(r) ((((r).cmic_dma_ctrl[0]) >> 25) & 0x1)
#define BCM56218_A0_CMIC_DMA_CTRLr_RESERVED_1_CH3f_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM56218_A0_CMIC_DMA_CTRLr_CH3_ABORT_DMAf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 26) & 0x1)
#define BCM56218_A0_CMIC_DMA_CTRLr_CH3_ABORT_DMAf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM56218_A0_CMIC_DMA_CTRLr_CH3_SEL_INTR_ON_DESC_OR_PKTf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 27) & 0x1)
#define BCM56218_A0_CMIC_DMA_CTRLr_CH3_SEL_INTR_ON_DESC_OR_PKTf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM56218_A0_CMIC_DMA_CTRLr_RESERVED_2_CH3f_GET(r) ((((r).cmic_dma_ctrl[0]) >> 28) & 0x1)
#define BCM56218_A0_CMIC_DMA_CTRLr_RESERVED_2_CH3f_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM56218_A0_CMIC_DMA_CTRLr_RESERVED_3_CH3f_GET(r) ((((r).cmic_dma_ctrl[0]) >> 29) & 0x3)
#define BCM56218_A0_CMIC_DMA_CTRLr_RESERVED_3_CH3f_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x3 << 29)) | ((((uint32_t)f) & 0x3) << 29))
#define BCM56218_A0_CMIC_DMA_CTRLr_CH3_DROP_RX_PKT_ON_CHAIN_ENDf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 31) & 0x1)
#define BCM56218_A0_CMIC_DMA_CTRLr_CH3_DROP_RX_PKT_ON_CHAIN_ENDf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access CMIC_DMA_CTRL.
 *
 */
#define BCM56218_A0_READ_CMIC_DMA_CTRLr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_DMA_CTRLr,r._cmic_dma_ctrl)
#define BCM56218_A0_WRITE_CMIC_DMA_CTRLr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_DMA_CTRLr,r._cmic_dma_ctrl)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_DMA_CTRLr BCM56218_A0_CMIC_DMA_CTRLr
#define CMIC_DMA_CTRLr_SIZE BCM56218_A0_CMIC_DMA_CTRLr_SIZE
typedef BCM56218_A0_CMIC_DMA_CTRLr_t CMIC_DMA_CTRLr_t;
#define CMIC_DMA_CTRLr_CLR BCM56218_A0_CMIC_DMA_CTRLr_CLR
#define CMIC_DMA_CTRLr_SET BCM56218_A0_CMIC_DMA_CTRLr_SET
#define CMIC_DMA_CTRLr_GET BCM56218_A0_CMIC_DMA_CTRLr_GET
#define CMIC_DMA_CTRLr_CH0_DIRECTIONf_GET BCM56218_A0_CMIC_DMA_CTRLr_CH0_DIRECTIONf_GET
#define CMIC_DMA_CTRLr_CH0_DIRECTIONf_SET BCM56218_A0_CMIC_DMA_CTRLr_CH0_DIRECTIONf_SET
#define CMIC_DMA_CTRLr_RESERVED_1_CH0f_GET BCM56218_A0_CMIC_DMA_CTRLr_RESERVED_1_CH0f_GET
#define CMIC_DMA_CTRLr_RESERVED_1_CH0f_SET BCM56218_A0_CMIC_DMA_CTRLr_RESERVED_1_CH0f_SET
#define CMIC_DMA_CTRLr_CH0_ABORT_DMAf_GET BCM56218_A0_CMIC_DMA_CTRLr_CH0_ABORT_DMAf_GET
#define CMIC_DMA_CTRLr_CH0_ABORT_DMAf_SET BCM56218_A0_CMIC_DMA_CTRLr_CH0_ABORT_DMAf_SET
#define CMIC_DMA_CTRLr_CH0_SEL_INTR_ON_DESC_OR_PKTf_GET BCM56218_A0_CMIC_DMA_CTRLr_CH0_SEL_INTR_ON_DESC_OR_PKTf_GET
#define CMIC_DMA_CTRLr_CH0_SEL_INTR_ON_DESC_OR_PKTf_SET BCM56218_A0_CMIC_DMA_CTRLr_CH0_SEL_INTR_ON_DESC_OR_PKTf_SET
#define CMIC_DMA_CTRLr_RESERVED_2_CH0f_GET BCM56218_A0_CMIC_DMA_CTRLr_RESERVED_2_CH0f_GET
#define CMIC_DMA_CTRLr_RESERVED_2_CH0f_SET BCM56218_A0_CMIC_DMA_CTRLr_RESERVED_2_CH0f_SET
#define CMIC_DMA_CTRLr_RESERVED_3_CH0f_GET BCM56218_A0_CMIC_DMA_CTRLr_RESERVED_3_CH0f_GET
#define CMIC_DMA_CTRLr_RESERVED_3_CH0f_SET BCM56218_A0_CMIC_DMA_CTRLr_RESERVED_3_CH0f_SET
#define CMIC_DMA_CTRLr_CH0_DROP_RX_PKT_ON_CHAIN_ENDf_GET BCM56218_A0_CMIC_DMA_CTRLr_CH0_DROP_RX_PKT_ON_CHAIN_ENDf_GET
#define CMIC_DMA_CTRLr_CH0_DROP_RX_PKT_ON_CHAIN_ENDf_SET BCM56218_A0_CMIC_DMA_CTRLr_CH0_DROP_RX_PKT_ON_CHAIN_ENDf_SET
#define CMIC_DMA_CTRLr_CH1_DIRECTIONf_GET BCM56218_A0_CMIC_DMA_CTRLr_CH1_DIRECTIONf_GET
#define CMIC_DMA_CTRLr_CH1_DIRECTIONf_SET BCM56218_A0_CMIC_DMA_CTRLr_CH1_DIRECTIONf_SET
#define CMIC_DMA_CTRLr_RESERVED_1_CH1f_GET BCM56218_A0_CMIC_DMA_CTRLr_RESERVED_1_CH1f_GET
#define CMIC_DMA_CTRLr_RESERVED_1_CH1f_SET BCM56218_A0_CMIC_DMA_CTRLr_RESERVED_1_CH1f_SET
#define CMIC_DMA_CTRLr_CH1_ABORT_DMAf_GET BCM56218_A0_CMIC_DMA_CTRLr_CH1_ABORT_DMAf_GET
#define CMIC_DMA_CTRLr_CH1_ABORT_DMAf_SET BCM56218_A0_CMIC_DMA_CTRLr_CH1_ABORT_DMAf_SET
#define CMIC_DMA_CTRLr_CH1_SEL_INTR_ON_DESC_OR_PKTf_GET BCM56218_A0_CMIC_DMA_CTRLr_CH1_SEL_INTR_ON_DESC_OR_PKTf_GET
#define CMIC_DMA_CTRLr_CH1_SEL_INTR_ON_DESC_OR_PKTf_SET BCM56218_A0_CMIC_DMA_CTRLr_CH1_SEL_INTR_ON_DESC_OR_PKTf_SET
#define CMIC_DMA_CTRLr_RESERVED_2_CH1f_GET BCM56218_A0_CMIC_DMA_CTRLr_RESERVED_2_CH1f_GET
#define CMIC_DMA_CTRLr_RESERVED_2_CH1f_SET BCM56218_A0_CMIC_DMA_CTRLr_RESERVED_2_CH1f_SET
#define CMIC_DMA_CTRLr_RESERVED_3_CH1f_GET BCM56218_A0_CMIC_DMA_CTRLr_RESERVED_3_CH1f_GET
#define CMIC_DMA_CTRLr_RESERVED_3_CH1f_SET BCM56218_A0_CMIC_DMA_CTRLr_RESERVED_3_CH1f_SET
#define CMIC_DMA_CTRLr_CH1_DROP_RX_PKT_ON_CHAIN_ENDf_GET BCM56218_A0_CMIC_DMA_CTRLr_CH1_DROP_RX_PKT_ON_CHAIN_ENDf_GET
#define CMIC_DMA_CTRLr_CH1_DROP_RX_PKT_ON_CHAIN_ENDf_SET BCM56218_A0_CMIC_DMA_CTRLr_CH1_DROP_RX_PKT_ON_CHAIN_ENDf_SET
#define CMIC_DMA_CTRLr_CH2_DIRECTIONf_GET BCM56218_A0_CMIC_DMA_CTRLr_CH2_DIRECTIONf_GET
#define CMIC_DMA_CTRLr_CH2_DIRECTIONf_SET BCM56218_A0_CMIC_DMA_CTRLr_CH2_DIRECTIONf_SET
#define CMIC_DMA_CTRLr_RESERVED_1_CH2f_GET BCM56218_A0_CMIC_DMA_CTRLr_RESERVED_1_CH2f_GET
#define CMIC_DMA_CTRLr_RESERVED_1_CH2f_SET BCM56218_A0_CMIC_DMA_CTRLr_RESERVED_1_CH2f_SET
#define CMIC_DMA_CTRLr_CH2_ABORT_DMAf_GET BCM56218_A0_CMIC_DMA_CTRLr_CH2_ABORT_DMAf_GET
#define CMIC_DMA_CTRLr_CH2_ABORT_DMAf_SET BCM56218_A0_CMIC_DMA_CTRLr_CH2_ABORT_DMAf_SET
#define CMIC_DMA_CTRLr_CH2_SEL_INTR_ON_DESC_OR_PKTf_GET BCM56218_A0_CMIC_DMA_CTRLr_CH2_SEL_INTR_ON_DESC_OR_PKTf_GET
#define CMIC_DMA_CTRLr_CH2_SEL_INTR_ON_DESC_OR_PKTf_SET BCM56218_A0_CMIC_DMA_CTRLr_CH2_SEL_INTR_ON_DESC_OR_PKTf_SET
#define CMIC_DMA_CTRLr_RESERVED_2_CH2f_GET BCM56218_A0_CMIC_DMA_CTRLr_RESERVED_2_CH2f_GET
#define CMIC_DMA_CTRLr_RESERVED_2_CH2f_SET BCM56218_A0_CMIC_DMA_CTRLr_RESERVED_2_CH2f_SET
#define CMIC_DMA_CTRLr_RESERVED_3_CH2f_GET BCM56218_A0_CMIC_DMA_CTRLr_RESERVED_3_CH2f_GET
#define CMIC_DMA_CTRLr_RESERVED_3_CH2f_SET BCM56218_A0_CMIC_DMA_CTRLr_RESERVED_3_CH2f_SET
#define CMIC_DMA_CTRLr_CH2_DROP_RX_PKT_ON_CHAIN_ENDf_GET BCM56218_A0_CMIC_DMA_CTRLr_CH2_DROP_RX_PKT_ON_CHAIN_ENDf_GET
#define CMIC_DMA_CTRLr_CH2_DROP_RX_PKT_ON_CHAIN_ENDf_SET BCM56218_A0_CMIC_DMA_CTRLr_CH2_DROP_RX_PKT_ON_CHAIN_ENDf_SET
#define CMIC_DMA_CTRLr_CH3_DIRECTIONf_GET BCM56218_A0_CMIC_DMA_CTRLr_CH3_DIRECTIONf_GET
#define CMIC_DMA_CTRLr_CH3_DIRECTIONf_SET BCM56218_A0_CMIC_DMA_CTRLr_CH3_DIRECTIONf_SET
#define CMIC_DMA_CTRLr_RESERVED_1_CH3f_GET BCM56218_A0_CMIC_DMA_CTRLr_RESERVED_1_CH3f_GET
#define CMIC_DMA_CTRLr_RESERVED_1_CH3f_SET BCM56218_A0_CMIC_DMA_CTRLr_RESERVED_1_CH3f_SET
#define CMIC_DMA_CTRLr_CH3_ABORT_DMAf_GET BCM56218_A0_CMIC_DMA_CTRLr_CH3_ABORT_DMAf_GET
#define CMIC_DMA_CTRLr_CH3_ABORT_DMAf_SET BCM56218_A0_CMIC_DMA_CTRLr_CH3_ABORT_DMAf_SET
#define CMIC_DMA_CTRLr_CH3_SEL_INTR_ON_DESC_OR_PKTf_GET BCM56218_A0_CMIC_DMA_CTRLr_CH3_SEL_INTR_ON_DESC_OR_PKTf_GET
#define CMIC_DMA_CTRLr_CH3_SEL_INTR_ON_DESC_OR_PKTf_SET BCM56218_A0_CMIC_DMA_CTRLr_CH3_SEL_INTR_ON_DESC_OR_PKTf_SET
#define CMIC_DMA_CTRLr_RESERVED_2_CH3f_GET BCM56218_A0_CMIC_DMA_CTRLr_RESERVED_2_CH3f_GET
#define CMIC_DMA_CTRLr_RESERVED_2_CH3f_SET BCM56218_A0_CMIC_DMA_CTRLr_RESERVED_2_CH3f_SET
#define CMIC_DMA_CTRLr_RESERVED_3_CH3f_GET BCM56218_A0_CMIC_DMA_CTRLr_RESERVED_3_CH3f_GET
#define CMIC_DMA_CTRLr_RESERVED_3_CH3f_SET BCM56218_A0_CMIC_DMA_CTRLr_RESERVED_3_CH3f_SET
#define CMIC_DMA_CTRLr_CH3_DROP_RX_PKT_ON_CHAIN_ENDf_GET BCM56218_A0_CMIC_DMA_CTRLr_CH3_DROP_RX_PKT_ON_CHAIN_ENDf_GET
#define CMIC_DMA_CTRLr_CH3_DROP_RX_PKT_ON_CHAIN_ENDf_SET BCM56218_A0_CMIC_DMA_CTRLr_CH3_DROP_RX_PKT_ON_CHAIN_ENDf_SET
#define READ_CMIC_DMA_CTRLr BCM56218_A0_READ_CMIC_DMA_CTRLr
#define WRITE_CMIC_DMA_CTRLr BCM56218_A0_WRITE_CMIC_DMA_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_DMA_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_DMA_DESC0
 * BLOCKS:   CMIC
 * DESC:     DMA Channel 0 Descriptor Address
 * SIZE:     32
 * FIELDS:
 *     ADDR             DMA CH0 DESCRIPTOR ADDRESS REGISTER
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_DMA_DESC0r 0x00000110

#define BCM56218_A0_CMIC_DMA_DESC0r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_DMA_DESC0.
 *
 */
typedef union BCM56218_A0_CMIC_DMA_DESC0r_s {
	uint32_t v[1];
	uint32_t cmic_dma_desc0[1];
	uint32_t _cmic_dma_desc0;
} BCM56218_A0_CMIC_DMA_DESC0r_t;

#define BCM56218_A0_CMIC_DMA_DESC0r_CLR(r) (r).cmic_dma_desc0[0] = 0
#define BCM56218_A0_CMIC_DMA_DESC0r_SET(r,d) (r).cmic_dma_desc0[0] = d
#define BCM56218_A0_CMIC_DMA_DESC0r_GET(r) (r).cmic_dma_desc0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_DMA_DESC0r_ADDRf_GET(r) ((r).cmic_dma_desc0[0])
#define BCM56218_A0_CMIC_DMA_DESC0r_ADDRf_SET(r,f) (r).cmic_dma_desc0[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_DMA_DESC0.
 *
 */
#define BCM56218_A0_READ_CMIC_DMA_DESC0r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_DMA_DESC0r,r._cmic_dma_desc0)
#define BCM56218_A0_WRITE_CMIC_DMA_DESC0r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_DMA_DESC0r,r._cmic_dma_desc0)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_DMA_DESC0r BCM56218_A0_CMIC_DMA_DESC0r
#define CMIC_DMA_DESC0r_SIZE BCM56218_A0_CMIC_DMA_DESC0r_SIZE
typedef BCM56218_A0_CMIC_DMA_DESC0r_t CMIC_DMA_DESC0r_t;
#define CMIC_DMA_DESC0r_CLR BCM56218_A0_CMIC_DMA_DESC0r_CLR
#define CMIC_DMA_DESC0r_SET BCM56218_A0_CMIC_DMA_DESC0r_SET
#define CMIC_DMA_DESC0r_GET BCM56218_A0_CMIC_DMA_DESC0r_GET
#define CMIC_DMA_DESC0r_ADDRf_GET BCM56218_A0_CMIC_DMA_DESC0r_ADDRf_GET
#define CMIC_DMA_DESC0r_ADDRf_SET BCM56218_A0_CMIC_DMA_DESC0r_ADDRf_SET
#define READ_CMIC_DMA_DESC0r BCM56218_A0_READ_CMIC_DMA_DESC0r
#define WRITE_CMIC_DMA_DESC0r BCM56218_A0_WRITE_CMIC_DMA_DESC0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_DMA_DESC0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_DMA_DESC1
 * BLOCKS:   CMIC
 * DESC:     DMA Channel 1 Descriptor Address
 * SIZE:     32
 * FIELDS:
 *     ADDR             DMA CH1 DESCRIPTOR ADDRESS REGISTER
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_DMA_DESC1r 0x00000114

#define BCM56218_A0_CMIC_DMA_DESC1r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_DMA_DESC1.
 *
 */
typedef union BCM56218_A0_CMIC_DMA_DESC1r_s {
	uint32_t v[1];
	uint32_t cmic_dma_desc1[1];
	uint32_t _cmic_dma_desc1;
} BCM56218_A0_CMIC_DMA_DESC1r_t;

#define BCM56218_A0_CMIC_DMA_DESC1r_CLR(r) (r).cmic_dma_desc1[0] = 0
#define BCM56218_A0_CMIC_DMA_DESC1r_SET(r,d) (r).cmic_dma_desc1[0] = d
#define BCM56218_A0_CMIC_DMA_DESC1r_GET(r) (r).cmic_dma_desc1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_DMA_DESC1r_ADDRf_GET(r) ((r).cmic_dma_desc1[0])
#define BCM56218_A0_CMIC_DMA_DESC1r_ADDRf_SET(r,f) (r).cmic_dma_desc1[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_DMA_DESC1.
 *
 */
#define BCM56218_A0_READ_CMIC_DMA_DESC1r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_DMA_DESC1r,r._cmic_dma_desc1)
#define BCM56218_A0_WRITE_CMIC_DMA_DESC1r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_DMA_DESC1r,r._cmic_dma_desc1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_DMA_DESC1r BCM56218_A0_CMIC_DMA_DESC1r
#define CMIC_DMA_DESC1r_SIZE BCM56218_A0_CMIC_DMA_DESC1r_SIZE
typedef BCM56218_A0_CMIC_DMA_DESC1r_t CMIC_DMA_DESC1r_t;
#define CMIC_DMA_DESC1r_CLR BCM56218_A0_CMIC_DMA_DESC1r_CLR
#define CMIC_DMA_DESC1r_SET BCM56218_A0_CMIC_DMA_DESC1r_SET
#define CMIC_DMA_DESC1r_GET BCM56218_A0_CMIC_DMA_DESC1r_GET
#define CMIC_DMA_DESC1r_ADDRf_GET BCM56218_A0_CMIC_DMA_DESC1r_ADDRf_GET
#define CMIC_DMA_DESC1r_ADDRf_SET BCM56218_A0_CMIC_DMA_DESC1r_ADDRf_SET
#define READ_CMIC_DMA_DESC1r BCM56218_A0_READ_CMIC_DMA_DESC1r
#define WRITE_CMIC_DMA_DESC1r BCM56218_A0_WRITE_CMIC_DMA_DESC1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_DMA_DESC1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_DMA_DESC2
 * BLOCKS:   CMIC
 * DESC:     DMA Channel 2 Descriptor Address
 * SIZE:     32
 * FIELDS:
 *     ADDR             DMA CH2 DESCRIPTOR ADDRESS REGISTER
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_DMA_DESC2r 0x00000118

#define BCM56218_A0_CMIC_DMA_DESC2r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_DMA_DESC2.
 *
 */
typedef union BCM56218_A0_CMIC_DMA_DESC2r_s {
	uint32_t v[1];
	uint32_t cmic_dma_desc2[1];
	uint32_t _cmic_dma_desc2;
} BCM56218_A0_CMIC_DMA_DESC2r_t;

#define BCM56218_A0_CMIC_DMA_DESC2r_CLR(r) (r).cmic_dma_desc2[0] = 0
#define BCM56218_A0_CMIC_DMA_DESC2r_SET(r,d) (r).cmic_dma_desc2[0] = d
#define BCM56218_A0_CMIC_DMA_DESC2r_GET(r) (r).cmic_dma_desc2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_DMA_DESC2r_ADDRf_GET(r) ((r).cmic_dma_desc2[0])
#define BCM56218_A0_CMIC_DMA_DESC2r_ADDRf_SET(r,f) (r).cmic_dma_desc2[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_DMA_DESC2.
 *
 */
#define BCM56218_A0_READ_CMIC_DMA_DESC2r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_DMA_DESC2r,r._cmic_dma_desc2)
#define BCM56218_A0_WRITE_CMIC_DMA_DESC2r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_DMA_DESC2r,r._cmic_dma_desc2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_DMA_DESC2r BCM56218_A0_CMIC_DMA_DESC2r
#define CMIC_DMA_DESC2r_SIZE BCM56218_A0_CMIC_DMA_DESC2r_SIZE
typedef BCM56218_A0_CMIC_DMA_DESC2r_t CMIC_DMA_DESC2r_t;
#define CMIC_DMA_DESC2r_CLR BCM56218_A0_CMIC_DMA_DESC2r_CLR
#define CMIC_DMA_DESC2r_SET BCM56218_A0_CMIC_DMA_DESC2r_SET
#define CMIC_DMA_DESC2r_GET BCM56218_A0_CMIC_DMA_DESC2r_GET
#define CMIC_DMA_DESC2r_ADDRf_GET BCM56218_A0_CMIC_DMA_DESC2r_ADDRf_GET
#define CMIC_DMA_DESC2r_ADDRf_SET BCM56218_A0_CMIC_DMA_DESC2r_ADDRf_SET
#define READ_CMIC_DMA_DESC2r BCM56218_A0_READ_CMIC_DMA_DESC2r
#define WRITE_CMIC_DMA_DESC2r BCM56218_A0_WRITE_CMIC_DMA_DESC2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_DMA_DESC2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_DMA_DESC3
 * BLOCKS:   CMIC
 * DESC:     DMA Channel 3 Descriptor Address
 * SIZE:     32
 * FIELDS:
 *     ADDR             DMA CH3 DESCRIPTOR ADDRESS REGISTER
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_DMA_DESC3r 0x0000011c

#define BCM56218_A0_CMIC_DMA_DESC3r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_DMA_DESC3.
 *
 */
typedef union BCM56218_A0_CMIC_DMA_DESC3r_s {
	uint32_t v[1];
	uint32_t cmic_dma_desc3[1];
	uint32_t _cmic_dma_desc3;
} BCM56218_A0_CMIC_DMA_DESC3r_t;

#define BCM56218_A0_CMIC_DMA_DESC3r_CLR(r) (r).cmic_dma_desc3[0] = 0
#define BCM56218_A0_CMIC_DMA_DESC3r_SET(r,d) (r).cmic_dma_desc3[0] = d
#define BCM56218_A0_CMIC_DMA_DESC3r_GET(r) (r).cmic_dma_desc3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_DMA_DESC3r_ADDRf_GET(r) ((r).cmic_dma_desc3[0])
#define BCM56218_A0_CMIC_DMA_DESC3r_ADDRf_SET(r,f) (r).cmic_dma_desc3[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_DMA_DESC3.
 *
 */
#define BCM56218_A0_READ_CMIC_DMA_DESC3r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_DMA_DESC3r,r._cmic_dma_desc3)
#define BCM56218_A0_WRITE_CMIC_DMA_DESC3r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_DMA_DESC3r,r._cmic_dma_desc3)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_DMA_DESC3r BCM56218_A0_CMIC_DMA_DESC3r
#define CMIC_DMA_DESC3r_SIZE BCM56218_A0_CMIC_DMA_DESC3r_SIZE
typedef BCM56218_A0_CMIC_DMA_DESC3r_t CMIC_DMA_DESC3r_t;
#define CMIC_DMA_DESC3r_CLR BCM56218_A0_CMIC_DMA_DESC3r_CLR
#define CMIC_DMA_DESC3r_SET BCM56218_A0_CMIC_DMA_DESC3r_SET
#define CMIC_DMA_DESC3r_GET BCM56218_A0_CMIC_DMA_DESC3r_GET
#define CMIC_DMA_DESC3r_ADDRf_GET BCM56218_A0_CMIC_DMA_DESC3r_ADDRf_GET
#define CMIC_DMA_DESC3r_ADDRf_SET BCM56218_A0_CMIC_DMA_DESC3r_ADDRf_SET
#define READ_CMIC_DMA_DESC3r BCM56218_A0_READ_CMIC_DMA_DESC3r
#define WRITE_CMIC_DMA_DESC3r BCM56218_A0_WRITE_CMIC_DMA_DESC3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_DMA_DESC3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_DMA_STAT
 * BLOCKS:   CMIC
 * DESC:     DMA Status and Control Register
 * SIZE:     32
 * FIELDS:
 *     BIT_POS          Selects one of 32 bits positions to be Set/Reset
 *     CH0_DMA_EN       Set by CPU to start a DMA on CH0 
 *     CH1_DMA_EN       Set by CPU to start a DMA on CH1 
 *     CH2_DMA_EN       Set by CPU to start a DMA on CH2 
 *     CH3_DMA_EN       Set by CPU to start a DMA on CH3 
 *     CH0_CHAIN_DONE   Set by CMIC indicating DMA Completion 
 *     CH1_CHAIN_DONE   Set by CMIC indicating DMA Completion 
 *     CH2_CHAIN_DONE   Set by CMIC indicating DMA Completion 
 *     BIT_VAL          Set to 1 to set a bit, 0 to reset a bit
 *     CH3_CHAIN_DONE   Set by CMIC indicating DMA Completion 
 *     CH0_DESC_DONE    Set by CMIC indicating Current DMA DES Completion 
 *     CH1_DESC_DONE    Set by CMIC indicating Current DMA DES Completion 
 *     CH2_DESC_DONE    Set by CMIC indicating Current DMA DES Completion 
 *     CH3_DESC_DONE    Set by CMIC indicating Current DMA DES Completion 
 *     DMA_RESET        Set by CPU to reset DMA Controller
 *     STATS_DMA_OPN_COMPLETE Set by CPU to indicate Stats DMA operation complete
 *     STATS_DMA_ITER_DONE Set by CPU to indicate Stats DMA iteration done
 *     TX_DMA_ABORT_NEEDS_CLEANUP Set by CPU to indicate that the previous TX DMA was aborted inthe middle of a packet (i.e., not at packet boundary). The CPU needs to clean up by forcing an eop packet with purge bit set.
 *     STATS_DMA_ERROR  Set by CPU to indicate Stats DMA resulted in an error
 *     STATS_DMA_ACTIVE Set by CPU to indicate Stats DMA currently active
 *     CH0_DMA_ACTIVE   Set by CMIC to indicate DMA channel is Active
 *     CH1_DMA_ACTIVE   Set by CMIC to indicate DMA channel is Active
 *     CH2_DMA_ACTIVE   Set by CMIC to indicate DMA channel is Active
 *     CH3_DMA_ACTIVE   Set by CMIC to indicate DMA channel is Active
 *     PCI_PARITY_ERR   Set by CMIC to indicate DMA Resulting in PCI Parity Error
 *     PCI_FATAL_ERR    Set by CMIC to indicate DMA Resulting in PCI Fatal Error
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_DMA_STATr 0x00000104

#define BCM56218_A0_CMIC_DMA_STATr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_DMA_STAT.
 *
 */
typedef union BCM56218_A0_CMIC_DMA_STATr_s {
	uint32_t v[1];
	uint32_t cmic_dma_stat[1];
	uint32_t _cmic_dma_stat;
} BCM56218_A0_CMIC_DMA_STATr_t;

#define BCM56218_A0_CMIC_DMA_STATr_CLR(r) (r).cmic_dma_stat[0] = 0
#define BCM56218_A0_CMIC_DMA_STATr_SET(r,d) (r).cmic_dma_stat[0] = d
#define BCM56218_A0_CMIC_DMA_STATr_GET(r) (r).cmic_dma_stat[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_DMA_STATr_BIT_POSf_GET(r) (((r).cmic_dma_stat[0]) & 0x1f)
#define BCM56218_A0_CMIC_DMA_STATr_BIT_POSf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56218_A0_CMIC_DMA_STATr_CH0_DMA_ENf_GET(r) (((r).cmic_dma_stat[0]) & 0x1)
#define BCM56218_A0_CMIC_DMA_STATr_CH0_DMA_ENf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_CMIC_DMA_STATr_CH1_DMA_ENf_GET(r) ((((r).cmic_dma_stat[0]) >> 1) & 0x1)
#define BCM56218_A0_CMIC_DMA_STATr_CH1_DMA_ENf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_CMIC_DMA_STATr_CH2_DMA_ENf_GET(r) ((((r).cmic_dma_stat[0]) >> 2) & 0x1)
#define BCM56218_A0_CMIC_DMA_STATr_CH2_DMA_ENf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_CMIC_DMA_STATr_CH3_DMA_ENf_GET(r) ((((r).cmic_dma_stat[0]) >> 3) & 0x1)
#define BCM56218_A0_CMIC_DMA_STATr_CH3_DMA_ENf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56218_A0_CMIC_DMA_STATr_CH0_CHAIN_DONEf_GET(r) ((((r).cmic_dma_stat[0]) >> 4) & 0x1)
#define BCM56218_A0_CMIC_DMA_STATr_CH0_CHAIN_DONEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56218_A0_CMIC_DMA_STATr_CH1_CHAIN_DONEf_GET(r) ((((r).cmic_dma_stat[0]) >> 5) & 0x1)
#define BCM56218_A0_CMIC_DMA_STATr_CH1_CHAIN_DONEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56218_A0_CMIC_DMA_STATr_CH2_CHAIN_DONEf_GET(r) ((((r).cmic_dma_stat[0]) >> 6) & 0x1)
#define BCM56218_A0_CMIC_DMA_STATr_CH2_CHAIN_DONEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56218_A0_CMIC_DMA_STATr_BIT_VALf_GET(r) ((((r).cmic_dma_stat[0]) >> 7) & 0x1)
#define BCM56218_A0_CMIC_DMA_STATr_BIT_VALf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56218_A0_CMIC_DMA_STATr_CH3_CHAIN_DONEf_GET(r) ((((r).cmic_dma_stat[0]) >> 7) & 0x1)
#define BCM56218_A0_CMIC_DMA_STATr_CH3_CHAIN_DONEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56218_A0_CMIC_DMA_STATr_CH0_DESC_DONEf_GET(r) ((((r).cmic_dma_stat[0]) >> 8) & 0x1)
#define BCM56218_A0_CMIC_DMA_STATr_CH0_DESC_DONEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56218_A0_CMIC_DMA_STATr_CH1_DESC_DONEf_GET(r) ((((r).cmic_dma_stat[0]) >> 9) & 0x1)
#define BCM56218_A0_CMIC_DMA_STATr_CH1_DESC_DONEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56218_A0_CMIC_DMA_STATr_CH2_DESC_DONEf_GET(r) ((((r).cmic_dma_stat[0]) >> 10) & 0x1)
#define BCM56218_A0_CMIC_DMA_STATr_CH2_DESC_DONEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56218_A0_CMIC_DMA_STATr_CH3_DESC_DONEf_GET(r) ((((r).cmic_dma_stat[0]) >> 11) & 0x1)
#define BCM56218_A0_CMIC_DMA_STATr_CH3_DESC_DONEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56218_A0_CMIC_DMA_STATr_DMA_RESETf_GET(r) ((((r).cmic_dma_stat[0]) >> 12) & 0x1)
#define BCM56218_A0_CMIC_DMA_STATr_DMA_RESETf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM56218_A0_CMIC_DMA_STATr_STATS_DMA_OPN_COMPLETEf_GET(r) ((((r).cmic_dma_stat[0]) >> 13) & 0x1)
#define BCM56218_A0_CMIC_DMA_STATr_STATS_DMA_OPN_COMPLETEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56218_A0_CMIC_DMA_STATr_STATS_DMA_ITER_DONEf_GET(r) ((((r).cmic_dma_stat[0]) >> 14) & 0x1)
#define BCM56218_A0_CMIC_DMA_STATr_STATS_DMA_ITER_DONEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM56218_A0_CMIC_DMA_STATr_TX_DMA_ABORT_NEEDS_CLEANUPf_GET(r) ((((r).cmic_dma_stat[0]) >> 15) & 0x1)
#define BCM56218_A0_CMIC_DMA_STATr_TX_DMA_ABORT_NEEDS_CLEANUPf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56218_A0_CMIC_DMA_STATr_STATS_DMA_ERRORf_GET(r) ((((r).cmic_dma_stat[0]) >> 16) & 0x1)
#define BCM56218_A0_CMIC_DMA_STATr_STATS_DMA_ERRORf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56218_A0_CMIC_DMA_STATr_STATS_DMA_ACTIVEf_GET(r) ((((r).cmic_dma_stat[0]) >> 17) & 0x1)
#define BCM56218_A0_CMIC_DMA_STATr_STATS_DMA_ACTIVEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_CMIC_DMA_STATr_CH0_DMA_ACTIVEf_GET(r) ((((r).cmic_dma_stat[0]) >> 18) & 0x1)
#define BCM56218_A0_CMIC_DMA_STATr_CH0_DMA_ACTIVEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_CMIC_DMA_STATr_CH1_DMA_ACTIVEf_GET(r) ((((r).cmic_dma_stat[0]) >> 19) & 0x1)
#define BCM56218_A0_CMIC_DMA_STATr_CH1_DMA_ACTIVEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56218_A0_CMIC_DMA_STATr_CH2_DMA_ACTIVEf_GET(r) ((((r).cmic_dma_stat[0]) >> 20) & 0x1)
#define BCM56218_A0_CMIC_DMA_STATr_CH2_DMA_ACTIVEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM56218_A0_CMIC_DMA_STATr_CH3_DMA_ACTIVEf_GET(r) ((((r).cmic_dma_stat[0]) >> 21) & 0x1)
#define BCM56218_A0_CMIC_DMA_STATr_CH3_DMA_ACTIVEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM56218_A0_CMIC_DMA_STATr_PCI_PARITY_ERRf_GET(r) ((((r).cmic_dma_stat[0]) >> 22) & 0x1f)
#define BCM56218_A0_CMIC_DMA_STATr_PCI_PARITY_ERRf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1f << 22)) | ((((uint32_t)f) & 0x1f) << 22))
#define BCM56218_A0_CMIC_DMA_STATr_PCI_FATAL_ERRf_GET(r) ((((r).cmic_dma_stat[0]) >> 27) & 0x1f)
#define BCM56218_A0_CMIC_DMA_STATr_PCI_FATAL_ERRf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1f << 27)) | ((((uint32_t)f) & 0x1f) << 27))

/*
 * These macros can be used to access CMIC_DMA_STAT.
 *
 */
#define BCM56218_A0_READ_CMIC_DMA_STATr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_DMA_STATr,r._cmic_dma_stat)
#define BCM56218_A0_WRITE_CMIC_DMA_STATr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_DMA_STATr,r._cmic_dma_stat)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_DMA_STATr BCM56218_A0_CMIC_DMA_STATr
#define CMIC_DMA_STATr_SIZE BCM56218_A0_CMIC_DMA_STATr_SIZE
typedef BCM56218_A0_CMIC_DMA_STATr_t CMIC_DMA_STATr_t;
#define CMIC_DMA_STATr_CLR BCM56218_A0_CMIC_DMA_STATr_CLR
#define CMIC_DMA_STATr_SET BCM56218_A0_CMIC_DMA_STATr_SET
#define CMIC_DMA_STATr_GET BCM56218_A0_CMIC_DMA_STATr_GET
#define CMIC_DMA_STATr_BIT_POSf_GET BCM56218_A0_CMIC_DMA_STATr_BIT_POSf_GET
#define CMIC_DMA_STATr_BIT_POSf_SET BCM56218_A0_CMIC_DMA_STATr_BIT_POSf_SET
#define CMIC_DMA_STATr_CH0_DMA_ENf_GET BCM56218_A0_CMIC_DMA_STATr_CH0_DMA_ENf_GET
#define CMIC_DMA_STATr_CH0_DMA_ENf_SET BCM56218_A0_CMIC_DMA_STATr_CH0_DMA_ENf_SET
#define CMIC_DMA_STATr_CH1_DMA_ENf_GET BCM56218_A0_CMIC_DMA_STATr_CH1_DMA_ENf_GET
#define CMIC_DMA_STATr_CH1_DMA_ENf_SET BCM56218_A0_CMIC_DMA_STATr_CH1_DMA_ENf_SET
#define CMIC_DMA_STATr_CH2_DMA_ENf_GET BCM56218_A0_CMIC_DMA_STATr_CH2_DMA_ENf_GET
#define CMIC_DMA_STATr_CH2_DMA_ENf_SET BCM56218_A0_CMIC_DMA_STATr_CH2_DMA_ENf_SET
#define CMIC_DMA_STATr_CH3_DMA_ENf_GET BCM56218_A0_CMIC_DMA_STATr_CH3_DMA_ENf_GET
#define CMIC_DMA_STATr_CH3_DMA_ENf_SET BCM56218_A0_CMIC_DMA_STATr_CH3_DMA_ENf_SET
#define CMIC_DMA_STATr_CH0_CHAIN_DONEf_GET BCM56218_A0_CMIC_DMA_STATr_CH0_CHAIN_DONEf_GET
#define CMIC_DMA_STATr_CH0_CHAIN_DONEf_SET BCM56218_A0_CMIC_DMA_STATr_CH0_CHAIN_DONEf_SET
#define CMIC_DMA_STATr_CH1_CHAIN_DONEf_GET BCM56218_A0_CMIC_DMA_STATr_CH1_CHAIN_DONEf_GET
#define CMIC_DMA_STATr_CH1_CHAIN_DONEf_SET BCM56218_A0_CMIC_DMA_STATr_CH1_CHAIN_DONEf_SET
#define CMIC_DMA_STATr_CH2_CHAIN_DONEf_GET BCM56218_A0_CMIC_DMA_STATr_CH2_CHAIN_DONEf_GET
#define CMIC_DMA_STATr_CH2_CHAIN_DONEf_SET BCM56218_A0_CMIC_DMA_STATr_CH2_CHAIN_DONEf_SET
#define CMIC_DMA_STATr_BIT_VALf_GET BCM56218_A0_CMIC_DMA_STATr_BIT_VALf_GET
#define CMIC_DMA_STATr_BIT_VALf_SET BCM56218_A0_CMIC_DMA_STATr_BIT_VALf_SET
#define CMIC_DMA_STATr_CH3_CHAIN_DONEf_GET BCM56218_A0_CMIC_DMA_STATr_CH3_CHAIN_DONEf_GET
#define CMIC_DMA_STATr_CH3_CHAIN_DONEf_SET BCM56218_A0_CMIC_DMA_STATr_CH3_CHAIN_DONEf_SET
#define CMIC_DMA_STATr_CH0_DESC_DONEf_GET BCM56218_A0_CMIC_DMA_STATr_CH0_DESC_DONEf_GET
#define CMIC_DMA_STATr_CH0_DESC_DONEf_SET BCM56218_A0_CMIC_DMA_STATr_CH0_DESC_DONEf_SET
#define CMIC_DMA_STATr_CH1_DESC_DONEf_GET BCM56218_A0_CMIC_DMA_STATr_CH1_DESC_DONEf_GET
#define CMIC_DMA_STATr_CH1_DESC_DONEf_SET BCM56218_A0_CMIC_DMA_STATr_CH1_DESC_DONEf_SET
#define CMIC_DMA_STATr_CH2_DESC_DONEf_GET BCM56218_A0_CMIC_DMA_STATr_CH2_DESC_DONEf_GET
#define CMIC_DMA_STATr_CH2_DESC_DONEf_SET BCM56218_A0_CMIC_DMA_STATr_CH2_DESC_DONEf_SET
#define CMIC_DMA_STATr_CH3_DESC_DONEf_GET BCM56218_A0_CMIC_DMA_STATr_CH3_DESC_DONEf_GET
#define CMIC_DMA_STATr_CH3_DESC_DONEf_SET BCM56218_A0_CMIC_DMA_STATr_CH3_DESC_DONEf_SET
#define CMIC_DMA_STATr_DMA_RESETf_GET BCM56218_A0_CMIC_DMA_STATr_DMA_RESETf_GET
#define CMIC_DMA_STATr_DMA_RESETf_SET BCM56218_A0_CMIC_DMA_STATr_DMA_RESETf_SET
#define CMIC_DMA_STATr_STATS_DMA_OPN_COMPLETEf_GET BCM56218_A0_CMIC_DMA_STATr_STATS_DMA_OPN_COMPLETEf_GET
#define CMIC_DMA_STATr_STATS_DMA_OPN_COMPLETEf_SET BCM56218_A0_CMIC_DMA_STATr_STATS_DMA_OPN_COMPLETEf_SET
#define CMIC_DMA_STATr_STATS_DMA_ITER_DONEf_GET BCM56218_A0_CMIC_DMA_STATr_STATS_DMA_ITER_DONEf_GET
#define CMIC_DMA_STATr_STATS_DMA_ITER_DONEf_SET BCM56218_A0_CMIC_DMA_STATr_STATS_DMA_ITER_DONEf_SET
#define CMIC_DMA_STATr_TX_DMA_ABORT_NEEDS_CLEANUPf_GET BCM56218_A0_CMIC_DMA_STATr_TX_DMA_ABORT_NEEDS_CLEANUPf_GET
#define CMIC_DMA_STATr_TX_DMA_ABORT_NEEDS_CLEANUPf_SET BCM56218_A0_CMIC_DMA_STATr_TX_DMA_ABORT_NEEDS_CLEANUPf_SET
#define CMIC_DMA_STATr_STATS_DMA_ERRORf_GET BCM56218_A0_CMIC_DMA_STATr_STATS_DMA_ERRORf_GET
#define CMIC_DMA_STATr_STATS_DMA_ERRORf_SET BCM56218_A0_CMIC_DMA_STATr_STATS_DMA_ERRORf_SET
#define CMIC_DMA_STATr_STATS_DMA_ACTIVEf_GET BCM56218_A0_CMIC_DMA_STATr_STATS_DMA_ACTIVEf_GET
#define CMIC_DMA_STATr_STATS_DMA_ACTIVEf_SET BCM56218_A0_CMIC_DMA_STATr_STATS_DMA_ACTIVEf_SET
#define CMIC_DMA_STATr_CH0_DMA_ACTIVEf_GET BCM56218_A0_CMIC_DMA_STATr_CH0_DMA_ACTIVEf_GET
#define CMIC_DMA_STATr_CH0_DMA_ACTIVEf_SET BCM56218_A0_CMIC_DMA_STATr_CH0_DMA_ACTIVEf_SET
#define CMIC_DMA_STATr_CH1_DMA_ACTIVEf_GET BCM56218_A0_CMIC_DMA_STATr_CH1_DMA_ACTIVEf_GET
#define CMIC_DMA_STATr_CH1_DMA_ACTIVEf_SET BCM56218_A0_CMIC_DMA_STATr_CH1_DMA_ACTIVEf_SET
#define CMIC_DMA_STATr_CH2_DMA_ACTIVEf_GET BCM56218_A0_CMIC_DMA_STATr_CH2_DMA_ACTIVEf_GET
#define CMIC_DMA_STATr_CH2_DMA_ACTIVEf_SET BCM56218_A0_CMIC_DMA_STATr_CH2_DMA_ACTIVEf_SET
#define CMIC_DMA_STATr_CH3_DMA_ACTIVEf_GET BCM56218_A0_CMIC_DMA_STATr_CH3_DMA_ACTIVEf_GET
#define CMIC_DMA_STATr_CH3_DMA_ACTIVEf_SET BCM56218_A0_CMIC_DMA_STATr_CH3_DMA_ACTIVEf_SET
#define CMIC_DMA_STATr_PCI_PARITY_ERRf_GET BCM56218_A0_CMIC_DMA_STATr_PCI_PARITY_ERRf_GET
#define CMIC_DMA_STATr_PCI_PARITY_ERRf_SET BCM56218_A0_CMIC_DMA_STATr_PCI_PARITY_ERRf_SET
#define CMIC_DMA_STATr_PCI_FATAL_ERRf_GET BCM56218_A0_CMIC_DMA_STATr_PCI_FATAL_ERRf_GET
#define CMIC_DMA_STATr_PCI_FATAL_ERRf_SET BCM56218_A0_CMIC_DMA_STATr_PCI_FATAL_ERRf_SET
#define READ_CMIC_DMA_STATr BCM56218_A0_READ_CMIC_DMA_STATr
#define WRITE_CMIC_DMA_STATr BCM56218_A0_WRITE_CMIC_DMA_STATr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_DMA_STATr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_ENDIANESS_SEL
 * BLOCKS:   CMIC
 * DESC:     Endianness selection register (for various CMIC operations)

 * SIZE:     32
 * FIELDS:
 *     BYTELANE0        Each byte lane must carry the same data value,especially the MSB byte and the LSB byte.The various bits in the byte are interpretedas explained below:
 *     BYTELANE1        Byte Lane 1 (see BYTELANE0)Each byte lane must carry the same data value.
 *     BYTELANE2        Byte Lane 2 (see BYTELANE0)Each byte lane must carry the same data value.
 *     BYTELANE3        Byte Lane 3 (see BYTELANE0)Each byte lane must carry the same data value.
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_ENDIANESS_SELr 0x00000174

#define BCM56218_A0_CMIC_ENDIANESS_SELr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_ENDIANESS_SEL.
 *
 */
typedef union BCM56218_A0_CMIC_ENDIANESS_SELr_s {
	uint32_t v[1];
	uint32_t cmic_endianess_sel[1];
	uint32_t _cmic_endianess_sel;
} BCM56218_A0_CMIC_ENDIANESS_SELr_t;

#define BCM56218_A0_CMIC_ENDIANESS_SELr_CLR(r) (r).cmic_endianess_sel[0] = 0
#define BCM56218_A0_CMIC_ENDIANESS_SELr_SET(r,d) (r).cmic_endianess_sel[0] = d
#define BCM56218_A0_CMIC_ENDIANESS_SELr_GET(r) (r).cmic_endianess_sel[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_ENDIANESS_SELr_BYTELANE0f_GET(r) (((r).cmic_endianess_sel[0]) & 0xff)
#define BCM56218_A0_CMIC_ENDIANESS_SELr_BYTELANE0f_SET(r,f) (r).cmic_endianess_sel[0]=(((r).cmic_endianess_sel[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56218_A0_CMIC_ENDIANESS_SELr_BYTELANE1f_GET(r) ((((r).cmic_endianess_sel[0]) >> 8) & 0xff)
#define BCM56218_A0_CMIC_ENDIANESS_SELr_BYTELANE1f_SET(r,f) (r).cmic_endianess_sel[0]=(((r).cmic_endianess_sel[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCM56218_A0_CMIC_ENDIANESS_SELr_BYTELANE2f_GET(r) ((((r).cmic_endianess_sel[0]) >> 16) & 0xff)
#define BCM56218_A0_CMIC_ENDIANESS_SELr_BYTELANE2f_SET(r,f) (r).cmic_endianess_sel[0]=(((r).cmic_endianess_sel[0] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define BCM56218_A0_CMIC_ENDIANESS_SELr_BYTELANE3f_GET(r) ((((r).cmic_endianess_sel[0]) >> 24) & 0xff)
#define BCM56218_A0_CMIC_ENDIANESS_SELr_BYTELANE3f_SET(r,f) (r).cmic_endianess_sel[0]=(((r).cmic_endianess_sel[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access CMIC_ENDIANESS_SEL.
 *
 */
#define BCM56218_A0_READ_CMIC_ENDIANESS_SELr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_ENDIANESS_SELr,r._cmic_endianess_sel)
#define BCM56218_A0_WRITE_CMIC_ENDIANESS_SELr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_ENDIANESS_SELr,r._cmic_endianess_sel)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_ENDIANESS_SELr BCM56218_A0_CMIC_ENDIANESS_SELr
#define CMIC_ENDIANESS_SELr_SIZE BCM56218_A0_CMIC_ENDIANESS_SELr_SIZE
typedef BCM56218_A0_CMIC_ENDIANESS_SELr_t CMIC_ENDIANESS_SELr_t;
#define CMIC_ENDIANESS_SELr_CLR BCM56218_A0_CMIC_ENDIANESS_SELr_CLR
#define CMIC_ENDIANESS_SELr_SET BCM56218_A0_CMIC_ENDIANESS_SELr_SET
#define CMIC_ENDIANESS_SELr_GET BCM56218_A0_CMIC_ENDIANESS_SELr_GET
#define CMIC_ENDIANESS_SELr_BYTELANE0f_GET BCM56218_A0_CMIC_ENDIANESS_SELr_BYTELANE0f_GET
#define CMIC_ENDIANESS_SELr_BYTELANE0f_SET BCM56218_A0_CMIC_ENDIANESS_SELr_BYTELANE0f_SET
#define CMIC_ENDIANESS_SELr_BYTELANE1f_GET BCM56218_A0_CMIC_ENDIANESS_SELr_BYTELANE1f_GET
#define CMIC_ENDIANESS_SELr_BYTELANE1f_SET BCM56218_A0_CMIC_ENDIANESS_SELr_BYTELANE1f_SET
#define CMIC_ENDIANESS_SELr_BYTELANE2f_GET BCM56218_A0_CMIC_ENDIANESS_SELr_BYTELANE2f_GET
#define CMIC_ENDIANESS_SELr_BYTELANE2f_SET BCM56218_A0_CMIC_ENDIANESS_SELr_BYTELANE2f_SET
#define CMIC_ENDIANESS_SELr_BYTELANE3f_GET BCM56218_A0_CMIC_ENDIANESS_SELr_BYTELANE3f_GET
#define CMIC_ENDIANESS_SELr_BYTELANE3f_SET BCM56218_A0_CMIC_ENDIANESS_SELr_BYTELANE3f_SET
#define READ_CMIC_ENDIANESS_SELr BCM56218_A0_READ_CMIC_ENDIANESS_SELr
#define WRITE_CMIC_ENDIANESS_SELr BCM56218_A0_WRITE_CMIC_ENDIANESS_SELr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_ENDIANESS_SELr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_GFPORT_CLOCK_CONFIG
 * BLOCKS:   CMIC
 * DESC:     GFPort Clock Config
 * SIZE:     32
 * FIELDS:
 *     GFPORT_CLOCK_CONFIG GFPort Clock Config
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_GFPORT_CLOCK_CONFIGr 0x0000014c

#define BCM56218_A0_CMIC_GFPORT_CLOCK_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_GFPORT_CLOCK_CONFIG.
 *
 */
typedef union BCM56218_A0_CMIC_GFPORT_CLOCK_CONFIGr_s {
	uint32_t v[1];
	uint32_t cmic_gfport_clock_config[1];
	uint32_t _cmic_gfport_clock_config;
} BCM56218_A0_CMIC_GFPORT_CLOCK_CONFIGr_t;

#define BCM56218_A0_CMIC_GFPORT_CLOCK_CONFIGr_CLR(r) (r).cmic_gfport_clock_config[0] = 0
#define BCM56218_A0_CMIC_GFPORT_CLOCK_CONFIGr_SET(r,d) (r).cmic_gfport_clock_config[0] = d
#define BCM56218_A0_CMIC_GFPORT_CLOCK_CONFIGr_GET(r) (r).cmic_gfport_clock_config[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_GFPORT_CLOCK_CONFIGr_GFPORT_CLOCK_CONFIGf_GET(r) (((r).cmic_gfport_clock_config[0]) & 0xff)
#define BCM56218_A0_CMIC_GFPORT_CLOCK_CONFIGr_GFPORT_CLOCK_CONFIGf_SET(r,f) (r).cmic_gfport_clock_config[0]=(((r).cmic_gfport_clock_config[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56218_A0_CMIC_GFPORT_CLOCK_CONFIGr_RESERVED_1f_GET(r) ((((r).cmic_gfport_clock_config[0]) >> 8) & 0xffffff)
#define BCM56218_A0_CMIC_GFPORT_CLOCK_CONFIGr_RESERVED_1f_SET(r,f) (r).cmic_gfport_clock_config[0]=(((r).cmic_gfport_clock_config[0] & ~((uint32_t)0xffffff << 8)) | ((((uint32_t)f) & 0xffffff) << 8))

/*
 * These macros can be used to access CMIC_GFPORT_CLOCK_CONFIG.
 *
 */
#define BCM56218_A0_READ_CMIC_GFPORT_CLOCK_CONFIGr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_GFPORT_CLOCK_CONFIGr,r._cmic_gfport_clock_config)
#define BCM56218_A0_WRITE_CMIC_GFPORT_CLOCK_CONFIGr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_GFPORT_CLOCK_CONFIGr,r._cmic_gfport_clock_config)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_GFPORT_CLOCK_CONFIGr BCM56218_A0_CMIC_GFPORT_CLOCK_CONFIGr
#define CMIC_GFPORT_CLOCK_CONFIGr_SIZE BCM56218_A0_CMIC_GFPORT_CLOCK_CONFIGr_SIZE
typedef BCM56218_A0_CMIC_GFPORT_CLOCK_CONFIGr_t CMIC_GFPORT_CLOCK_CONFIGr_t;
#define CMIC_GFPORT_CLOCK_CONFIGr_CLR BCM56218_A0_CMIC_GFPORT_CLOCK_CONFIGr_CLR
#define CMIC_GFPORT_CLOCK_CONFIGr_SET BCM56218_A0_CMIC_GFPORT_CLOCK_CONFIGr_SET
#define CMIC_GFPORT_CLOCK_CONFIGr_GET BCM56218_A0_CMIC_GFPORT_CLOCK_CONFIGr_GET
#define CMIC_GFPORT_CLOCK_CONFIGr_GFPORT_CLOCK_CONFIGf_GET BCM56218_A0_CMIC_GFPORT_CLOCK_CONFIGr_GFPORT_CLOCK_CONFIGf_GET
#define CMIC_GFPORT_CLOCK_CONFIGr_GFPORT_CLOCK_CONFIGf_SET BCM56218_A0_CMIC_GFPORT_CLOCK_CONFIGr_GFPORT_CLOCK_CONFIGf_SET
#define CMIC_GFPORT_CLOCK_CONFIGr_RESERVED_1f_GET BCM56218_A0_CMIC_GFPORT_CLOCK_CONFIGr_RESERVED_1f_GET
#define CMIC_GFPORT_CLOCK_CONFIGr_RESERVED_1f_SET BCM56218_A0_CMIC_GFPORT_CLOCK_CONFIGr_RESERVED_1f_SET
#define READ_CMIC_GFPORT_CLOCK_CONFIGr BCM56218_A0_READ_CMIC_GFPORT_CLOCK_CONFIGr
#define WRITE_CMIC_GFPORT_CLOCK_CONFIGr BCM56218_A0_WRITE_CMIC_GFPORT_CLOCK_CONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_GFPORT_CLOCK_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_I2C_CTRL
 * BLOCKS:   CMIC
 * DESC:     I2C Status and Control Register
 * SIZE:     32
 * FIELDS:
 *     RESERVED_1       Reserved
 *     AAAK             When set (1), asserts an ACKNOWLEDGE clock pulse (SDA LOW) on the I2C bus 
 *     INT_FLAG         When set, indicates an interrupt has occurred due to one of the status conditions 
 *     MM_STP           When set, controls entering the Master mode and send a STOP condition on the bus, when it is free. This bit is automatically cleared after the STOP condition has been sent. 
 *     MM_STRT          When set, controls entering the Master mode and send a START condition on the bus, when it is free. This bit is automatically cleared after the START condition has been sent. 
 *     BUS_EN           When set, Enable I2C bus and respond to calls to the slave address and the General Call Address ability. 
 *     INT_EN           When set, enables generation of interrupts.
 *     RESERVED_2       Reserved
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_I2C_CTRLr 0x00000128

#define BCM56218_A0_CMIC_I2C_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_I2C_CTRL.
 *
 */
typedef union BCM56218_A0_CMIC_I2C_CTRLr_s {
	uint32_t v[1];
	uint32_t cmic_i2c_ctrl[1];
	uint32_t _cmic_i2c_ctrl;
} BCM56218_A0_CMIC_I2C_CTRLr_t;

#define BCM56218_A0_CMIC_I2C_CTRLr_CLR(r) (r).cmic_i2c_ctrl[0] = 0
#define BCM56218_A0_CMIC_I2C_CTRLr_SET(r,d) (r).cmic_i2c_ctrl[0] = d
#define BCM56218_A0_CMIC_I2C_CTRLr_GET(r) (r).cmic_i2c_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_I2C_CTRLr_RESERVED_1f_GET(r) (((r).cmic_i2c_ctrl[0]) & 0x3)
#define BCM56218_A0_CMIC_I2C_CTRLr_RESERVED_1f_SET(r,f) (r).cmic_i2c_ctrl[0]=(((r).cmic_i2c_ctrl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56218_A0_CMIC_I2C_CTRLr_AAAKf_GET(r) ((((r).cmic_i2c_ctrl[0]) >> 2) & 0x1)
#define BCM56218_A0_CMIC_I2C_CTRLr_AAAKf_SET(r,f) (r).cmic_i2c_ctrl[0]=(((r).cmic_i2c_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_CMIC_I2C_CTRLr_INT_FLAGf_GET(r) ((((r).cmic_i2c_ctrl[0]) >> 3) & 0x1)
#define BCM56218_A0_CMIC_I2C_CTRLr_INT_FLAGf_SET(r,f) (r).cmic_i2c_ctrl[0]=(((r).cmic_i2c_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56218_A0_CMIC_I2C_CTRLr_MM_STPf_GET(r) ((((r).cmic_i2c_ctrl[0]) >> 4) & 0x1)
#define BCM56218_A0_CMIC_I2C_CTRLr_MM_STPf_SET(r,f) (r).cmic_i2c_ctrl[0]=(((r).cmic_i2c_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56218_A0_CMIC_I2C_CTRLr_MM_STRTf_GET(r) ((((r).cmic_i2c_ctrl[0]) >> 5) & 0x1)
#define BCM56218_A0_CMIC_I2C_CTRLr_MM_STRTf_SET(r,f) (r).cmic_i2c_ctrl[0]=(((r).cmic_i2c_ctrl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56218_A0_CMIC_I2C_CTRLr_BUS_ENf_GET(r) ((((r).cmic_i2c_ctrl[0]) >> 6) & 0x1)
#define BCM56218_A0_CMIC_I2C_CTRLr_BUS_ENf_SET(r,f) (r).cmic_i2c_ctrl[0]=(((r).cmic_i2c_ctrl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56218_A0_CMIC_I2C_CTRLr_INT_ENf_GET(r) ((((r).cmic_i2c_ctrl[0]) >> 7) & 0x1)
#define BCM56218_A0_CMIC_I2C_CTRLr_INT_ENf_SET(r,f) (r).cmic_i2c_ctrl[0]=(((r).cmic_i2c_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56218_A0_CMIC_I2C_CTRLr_RESERVED_2f_GET(r) ((((r).cmic_i2c_ctrl[0]) >> 8) & 0xffffff)
#define BCM56218_A0_CMIC_I2C_CTRLr_RESERVED_2f_SET(r,f) (r).cmic_i2c_ctrl[0]=(((r).cmic_i2c_ctrl[0] & ~((uint32_t)0xffffff << 8)) | ((((uint32_t)f) & 0xffffff) << 8))

/*
 * These macros can be used to access CMIC_I2C_CTRL.
 *
 */
#define BCM56218_A0_READ_CMIC_I2C_CTRLr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_I2C_CTRLr,r._cmic_i2c_ctrl)
#define BCM56218_A0_WRITE_CMIC_I2C_CTRLr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_I2C_CTRLr,r._cmic_i2c_ctrl)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_I2C_CTRLr BCM56218_A0_CMIC_I2C_CTRLr
#define CMIC_I2C_CTRLr_SIZE BCM56218_A0_CMIC_I2C_CTRLr_SIZE
typedef BCM56218_A0_CMIC_I2C_CTRLr_t CMIC_I2C_CTRLr_t;
#define CMIC_I2C_CTRLr_CLR BCM56218_A0_CMIC_I2C_CTRLr_CLR
#define CMIC_I2C_CTRLr_SET BCM56218_A0_CMIC_I2C_CTRLr_SET
#define CMIC_I2C_CTRLr_GET BCM56218_A0_CMIC_I2C_CTRLr_GET
#define CMIC_I2C_CTRLr_RESERVED_1f_GET BCM56218_A0_CMIC_I2C_CTRLr_RESERVED_1f_GET
#define CMIC_I2C_CTRLr_RESERVED_1f_SET BCM56218_A0_CMIC_I2C_CTRLr_RESERVED_1f_SET
#define CMIC_I2C_CTRLr_AAAKf_GET BCM56218_A0_CMIC_I2C_CTRLr_AAAKf_GET
#define CMIC_I2C_CTRLr_AAAKf_SET BCM56218_A0_CMIC_I2C_CTRLr_AAAKf_SET
#define CMIC_I2C_CTRLr_INT_FLAGf_GET BCM56218_A0_CMIC_I2C_CTRLr_INT_FLAGf_GET
#define CMIC_I2C_CTRLr_INT_FLAGf_SET BCM56218_A0_CMIC_I2C_CTRLr_INT_FLAGf_SET
#define CMIC_I2C_CTRLr_MM_STPf_GET BCM56218_A0_CMIC_I2C_CTRLr_MM_STPf_GET
#define CMIC_I2C_CTRLr_MM_STPf_SET BCM56218_A0_CMIC_I2C_CTRLr_MM_STPf_SET
#define CMIC_I2C_CTRLr_MM_STRTf_GET BCM56218_A0_CMIC_I2C_CTRLr_MM_STRTf_GET
#define CMIC_I2C_CTRLr_MM_STRTf_SET BCM56218_A0_CMIC_I2C_CTRLr_MM_STRTf_SET
#define CMIC_I2C_CTRLr_BUS_ENf_GET BCM56218_A0_CMIC_I2C_CTRLr_BUS_ENf_GET
#define CMIC_I2C_CTRLr_BUS_ENf_SET BCM56218_A0_CMIC_I2C_CTRLr_BUS_ENf_SET
#define CMIC_I2C_CTRLr_INT_ENf_GET BCM56218_A0_CMIC_I2C_CTRLr_INT_ENf_GET
#define CMIC_I2C_CTRLr_INT_ENf_SET BCM56218_A0_CMIC_I2C_CTRLr_INT_ENf_SET
#define CMIC_I2C_CTRLr_RESERVED_2f_GET BCM56218_A0_CMIC_I2C_CTRLr_RESERVED_2f_GET
#define CMIC_I2C_CTRLr_RESERVED_2f_SET BCM56218_A0_CMIC_I2C_CTRLr_RESERVED_2f_SET
#define READ_CMIC_I2C_CTRLr BCM56218_A0_READ_CMIC_I2C_CTRLr
#define WRITE_CMIC_I2C_CTRLr BCM56218_A0_WRITE_CMIC_I2C_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_I2C_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_I2C_DATA
 * BLOCKS:   CMIC
 * DESC:     I2C Data Register
 * SIZE:     32
 * FIELDS:
 *     DATA             Data that is read from or written to the I2C interface.
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_I2C_DATAr 0x00000124

#define BCM56218_A0_CMIC_I2C_DATAr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_I2C_DATA.
 *
 */
typedef union BCM56218_A0_CMIC_I2C_DATAr_s {
	uint32_t v[1];
	uint32_t cmic_i2c_data[1];
	uint32_t _cmic_i2c_data;
} BCM56218_A0_CMIC_I2C_DATAr_t;

#define BCM56218_A0_CMIC_I2C_DATAr_CLR(r) (r).cmic_i2c_data[0] = 0
#define BCM56218_A0_CMIC_I2C_DATAr_SET(r,d) (r).cmic_i2c_data[0] = d
#define BCM56218_A0_CMIC_I2C_DATAr_GET(r) (r).cmic_i2c_data[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_I2C_DATAr_DATAf_GET(r) (((r).cmic_i2c_data[0]) & 0xff)
#define BCM56218_A0_CMIC_I2C_DATAr_DATAf_SET(r,f) (r).cmic_i2c_data[0]=(((r).cmic_i2c_data[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56218_A0_CMIC_I2C_DATAr_RESERVED_1f_GET(r) ((((r).cmic_i2c_data[0]) >> 8) & 0xffffff)
#define BCM56218_A0_CMIC_I2C_DATAr_RESERVED_1f_SET(r,f) (r).cmic_i2c_data[0]=(((r).cmic_i2c_data[0] & ~((uint32_t)0xffffff << 8)) | ((((uint32_t)f) & 0xffffff) << 8))

/*
 * These macros can be used to access CMIC_I2C_DATA.
 *
 */
#define BCM56218_A0_READ_CMIC_I2C_DATAr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_I2C_DATAr,r._cmic_i2c_data)
#define BCM56218_A0_WRITE_CMIC_I2C_DATAr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_I2C_DATAr,r._cmic_i2c_data)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_I2C_DATAr BCM56218_A0_CMIC_I2C_DATAr
#define CMIC_I2C_DATAr_SIZE BCM56218_A0_CMIC_I2C_DATAr_SIZE
typedef BCM56218_A0_CMIC_I2C_DATAr_t CMIC_I2C_DATAr_t;
#define CMIC_I2C_DATAr_CLR BCM56218_A0_CMIC_I2C_DATAr_CLR
#define CMIC_I2C_DATAr_SET BCM56218_A0_CMIC_I2C_DATAr_SET
#define CMIC_I2C_DATAr_GET BCM56218_A0_CMIC_I2C_DATAr_GET
#define CMIC_I2C_DATAr_DATAf_GET BCM56218_A0_CMIC_I2C_DATAr_DATAf_GET
#define CMIC_I2C_DATAr_DATAf_SET BCM56218_A0_CMIC_I2C_DATAr_DATAf_SET
#define CMIC_I2C_DATAr_RESERVED_1f_GET BCM56218_A0_CMIC_I2C_DATAr_RESERVED_1f_GET
#define CMIC_I2C_DATAr_RESERVED_1f_SET BCM56218_A0_CMIC_I2C_DATAr_RESERVED_1f_SET
#define READ_CMIC_I2C_DATAr BCM56218_A0_READ_CMIC_I2C_DATAr
#define WRITE_CMIC_I2C_DATAr BCM56218_A0_WRITE_CMIC_I2C_DATAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_I2C_DATAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_I2C_RESET
 * BLOCKS:   CMIC
 * DESC:     I2C Soft Reset Register
 * SIZE:     32
 * FIELDS:
 *     RESET            A write operation to this register with any data will perform a soft reset to the I2C interface.  The bus is set to idle state and the MM_STOP, MM_STRT and INT_FLAG in the I2C Status and Control Register are set to 0. 
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_I2C_RESETr 0x0000013c

#define BCM56218_A0_CMIC_I2C_RESETr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_I2C_RESET.
 *
 */
typedef union BCM56218_A0_CMIC_I2C_RESETr_s {
	uint32_t v[1];
	uint32_t cmic_i2c_reset[1];
	uint32_t _cmic_i2c_reset;
} BCM56218_A0_CMIC_I2C_RESETr_t;

#define BCM56218_A0_CMIC_I2C_RESETr_CLR(r) (r).cmic_i2c_reset[0] = 0
#define BCM56218_A0_CMIC_I2C_RESETr_SET(r,d) (r).cmic_i2c_reset[0] = d
#define BCM56218_A0_CMIC_I2C_RESETr_GET(r) (r).cmic_i2c_reset[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_I2C_RESETr_RESETf_GET(r) (((r).cmic_i2c_reset[0]) & 0xff)
#define BCM56218_A0_CMIC_I2C_RESETr_RESETf_SET(r,f) (r).cmic_i2c_reset[0]=(((r).cmic_i2c_reset[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56218_A0_CMIC_I2C_RESETr_RESERVED_1f_GET(r) ((((r).cmic_i2c_reset[0]) >> 8) & 0xffffff)
#define BCM56218_A0_CMIC_I2C_RESETr_RESERVED_1f_SET(r,f) (r).cmic_i2c_reset[0]=(((r).cmic_i2c_reset[0] & ~((uint32_t)0xffffff << 8)) | ((((uint32_t)f) & 0xffffff) << 8))

/*
 * These macros can be used to access CMIC_I2C_RESET.
 *
 */
#define BCM56218_A0_READ_CMIC_I2C_RESETr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_I2C_RESETr,r._cmic_i2c_reset)
#define BCM56218_A0_WRITE_CMIC_I2C_RESETr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_I2C_RESETr,r._cmic_i2c_reset)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_I2C_RESETr BCM56218_A0_CMIC_I2C_RESETr
#define CMIC_I2C_RESETr_SIZE BCM56218_A0_CMIC_I2C_RESETr_SIZE
typedef BCM56218_A0_CMIC_I2C_RESETr_t CMIC_I2C_RESETr_t;
#define CMIC_I2C_RESETr_CLR BCM56218_A0_CMIC_I2C_RESETr_CLR
#define CMIC_I2C_RESETr_SET BCM56218_A0_CMIC_I2C_RESETr_SET
#define CMIC_I2C_RESETr_GET BCM56218_A0_CMIC_I2C_RESETr_GET
#define CMIC_I2C_RESETr_RESETf_GET BCM56218_A0_CMIC_I2C_RESETr_RESETf_GET
#define CMIC_I2C_RESETr_RESETf_SET BCM56218_A0_CMIC_I2C_RESETr_RESETf_SET
#define CMIC_I2C_RESETr_RESERVED_1f_GET BCM56218_A0_CMIC_I2C_RESETr_RESERVED_1f_GET
#define CMIC_I2C_RESETr_RESERVED_1f_SET BCM56218_A0_CMIC_I2C_RESETr_RESERVED_1f_SET
#define READ_CMIC_I2C_RESETr BCM56218_A0_READ_CMIC_I2C_RESETr
#define WRITE_CMIC_I2C_RESETr BCM56218_A0_WRITE_CMIC_I2C_RESETr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_I2C_RESETr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_I2C_SLAVE_ADDR
 * BLOCKS:   CMIC
 * DESC:     I2C Slave Address Register
 * SIZE:     32
 * FIELDS:
 *     GEN_CALL_EN      Controls recognition of the General Call Address of 00H.0 = Disable General Call Address recognition1 = Enable General Call Address recognition
 *     ADDR             I2C SLAVE Address 6:0
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_I2C_SLAVE_ADDRr 0x00000120

#define BCM56218_A0_CMIC_I2C_SLAVE_ADDRr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_I2C_SLAVE_ADDR.
 *
 */
typedef union BCM56218_A0_CMIC_I2C_SLAVE_ADDRr_s {
	uint32_t v[1];
	uint32_t cmic_i2c_slave_addr[1];
	uint32_t _cmic_i2c_slave_addr;
} BCM56218_A0_CMIC_I2C_SLAVE_ADDRr_t;

#define BCM56218_A0_CMIC_I2C_SLAVE_ADDRr_CLR(r) (r).cmic_i2c_slave_addr[0] = 0
#define BCM56218_A0_CMIC_I2C_SLAVE_ADDRr_SET(r,d) (r).cmic_i2c_slave_addr[0] = d
#define BCM56218_A0_CMIC_I2C_SLAVE_ADDRr_GET(r) (r).cmic_i2c_slave_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_I2C_SLAVE_ADDRr_GEN_CALL_ENf_GET(r) (((r).cmic_i2c_slave_addr[0]) & 0x1)
#define BCM56218_A0_CMIC_I2C_SLAVE_ADDRr_GEN_CALL_ENf_SET(r,f) (r).cmic_i2c_slave_addr[0]=(((r).cmic_i2c_slave_addr[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_CMIC_I2C_SLAVE_ADDRr_ADDRf_GET(r) ((((r).cmic_i2c_slave_addr[0]) >> 1) & 0x7f)
#define BCM56218_A0_CMIC_I2C_SLAVE_ADDRr_ADDRf_SET(r,f) (r).cmic_i2c_slave_addr[0]=(((r).cmic_i2c_slave_addr[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))
#define BCM56218_A0_CMIC_I2C_SLAVE_ADDRr_RESERVED_1f_GET(r) ((((r).cmic_i2c_slave_addr[0]) >> 8) & 0xffffff)
#define BCM56218_A0_CMIC_I2C_SLAVE_ADDRr_RESERVED_1f_SET(r,f) (r).cmic_i2c_slave_addr[0]=(((r).cmic_i2c_slave_addr[0] & ~((uint32_t)0xffffff << 8)) | ((((uint32_t)f) & 0xffffff) << 8))

/*
 * These macros can be used to access CMIC_I2C_SLAVE_ADDR.
 *
 */
#define BCM56218_A0_READ_CMIC_I2C_SLAVE_ADDRr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_I2C_SLAVE_ADDRr,r._cmic_i2c_slave_addr)
#define BCM56218_A0_WRITE_CMIC_I2C_SLAVE_ADDRr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_I2C_SLAVE_ADDRr,r._cmic_i2c_slave_addr)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_I2C_SLAVE_ADDRr BCM56218_A0_CMIC_I2C_SLAVE_ADDRr
#define CMIC_I2C_SLAVE_ADDRr_SIZE BCM56218_A0_CMIC_I2C_SLAVE_ADDRr_SIZE
typedef BCM56218_A0_CMIC_I2C_SLAVE_ADDRr_t CMIC_I2C_SLAVE_ADDRr_t;
#define CMIC_I2C_SLAVE_ADDRr_CLR BCM56218_A0_CMIC_I2C_SLAVE_ADDRr_CLR
#define CMIC_I2C_SLAVE_ADDRr_SET BCM56218_A0_CMIC_I2C_SLAVE_ADDRr_SET
#define CMIC_I2C_SLAVE_ADDRr_GET BCM56218_A0_CMIC_I2C_SLAVE_ADDRr_GET
#define CMIC_I2C_SLAVE_ADDRr_GEN_CALL_ENf_GET BCM56218_A0_CMIC_I2C_SLAVE_ADDRr_GEN_CALL_ENf_GET
#define CMIC_I2C_SLAVE_ADDRr_GEN_CALL_ENf_SET BCM56218_A0_CMIC_I2C_SLAVE_ADDRr_GEN_CALL_ENf_SET
#define CMIC_I2C_SLAVE_ADDRr_ADDRf_GET BCM56218_A0_CMIC_I2C_SLAVE_ADDRr_ADDRf_GET
#define CMIC_I2C_SLAVE_ADDRr_ADDRf_SET BCM56218_A0_CMIC_I2C_SLAVE_ADDRr_ADDRf_SET
#define CMIC_I2C_SLAVE_ADDRr_RESERVED_1f_GET BCM56218_A0_CMIC_I2C_SLAVE_ADDRr_RESERVED_1f_GET
#define CMIC_I2C_SLAVE_ADDRr_RESERVED_1f_SET BCM56218_A0_CMIC_I2C_SLAVE_ADDRr_RESERVED_1f_SET
#define READ_CMIC_I2C_SLAVE_ADDRr BCM56218_A0_READ_CMIC_I2C_SLAVE_ADDRr
#define WRITE_CMIC_I2C_SLAVE_ADDRr BCM56218_A0_WRITE_CMIC_I2C_SLAVE_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_I2C_SLAVE_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_I2C_SLAVE_XADDR
 * BLOCKS:   CMIC
 * DESC:     I2C Slave Extended Address Register
 * SIZE:     32
 * FIELDS:
 *     ADDR             Slave address 7-0 for the extended slave addressing mode.  When the address received starts with F7-F0H, the two LSBs are recognized as slave address 9-8 and the content of this register are used as address 7-0 to form the 10-bit address used in extended addressing mode. 
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_I2C_SLAVE_XADDRr 0x00000130

#define BCM56218_A0_CMIC_I2C_SLAVE_XADDRr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_I2C_SLAVE_XADDR.
 *
 */
typedef union BCM56218_A0_CMIC_I2C_SLAVE_XADDRr_s {
	uint32_t v[1];
	uint32_t cmic_i2c_slave_xaddr[1];
	uint32_t _cmic_i2c_slave_xaddr;
} BCM56218_A0_CMIC_I2C_SLAVE_XADDRr_t;

#define BCM56218_A0_CMIC_I2C_SLAVE_XADDRr_CLR(r) (r).cmic_i2c_slave_xaddr[0] = 0
#define BCM56218_A0_CMIC_I2C_SLAVE_XADDRr_SET(r,d) (r).cmic_i2c_slave_xaddr[0] = d
#define BCM56218_A0_CMIC_I2C_SLAVE_XADDRr_GET(r) (r).cmic_i2c_slave_xaddr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_I2C_SLAVE_XADDRr_ADDRf_GET(r) (((r).cmic_i2c_slave_xaddr[0]) & 0xff)
#define BCM56218_A0_CMIC_I2C_SLAVE_XADDRr_ADDRf_SET(r,f) (r).cmic_i2c_slave_xaddr[0]=(((r).cmic_i2c_slave_xaddr[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56218_A0_CMIC_I2C_SLAVE_XADDRr_RESERVED_1f_GET(r) ((((r).cmic_i2c_slave_xaddr[0]) >> 8) & 0xffffff)
#define BCM56218_A0_CMIC_I2C_SLAVE_XADDRr_RESERVED_1f_SET(r,f) (r).cmic_i2c_slave_xaddr[0]=(((r).cmic_i2c_slave_xaddr[0] & ~((uint32_t)0xffffff << 8)) | ((((uint32_t)f) & 0xffffff) << 8))

/*
 * These macros can be used to access CMIC_I2C_SLAVE_XADDR.
 *
 */
#define BCM56218_A0_READ_CMIC_I2C_SLAVE_XADDRr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_I2C_SLAVE_XADDRr,r._cmic_i2c_slave_xaddr)
#define BCM56218_A0_WRITE_CMIC_I2C_SLAVE_XADDRr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_I2C_SLAVE_XADDRr,r._cmic_i2c_slave_xaddr)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_I2C_SLAVE_XADDRr BCM56218_A0_CMIC_I2C_SLAVE_XADDRr
#define CMIC_I2C_SLAVE_XADDRr_SIZE BCM56218_A0_CMIC_I2C_SLAVE_XADDRr_SIZE
typedef BCM56218_A0_CMIC_I2C_SLAVE_XADDRr_t CMIC_I2C_SLAVE_XADDRr_t;
#define CMIC_I2C_SLAVE_XADDRr_CLR BCM56218_A0_CMIC_I2C_SLAVE_XADDRr_CLR
#define CMIC_I2C_SLAVE_XADDRr_SET BCM56218_A0_CMIC_I2C_SLAVE_XADDRr_SET
#define CMIC_I2C_SLAVE_XADDRr_GET BCM56218_A0_CMIC_I2C_SLAVE_XADDRr_GET
#define CMIC_I2C_SLAVE_XADDRr_ADDRf_GET BCM56218_A0_CMIC_I2C_SLAVE_XADDRr_ADDRf_GET
#define CMIC_I2C_SLAVE_XADDRr_ADDRf_SET BCM56218_A0_CMIC_I2C_SLAVE_XADDRr_ADDRf_SET
#define CMIC_I2C_SLAVE_XADDRr_RESERVED_1f_GET BCM56218_A0_CMIC_I2C_SLAVE_XADDRr_RESERVED_1f_GET
#define CMIC_I2C_SLAVE_XADDRr_RESERVED_1f_SET BCM56218_A0_CMIC_I2C_SLAVE_XADDRr_RESERVED_1f_SET
#define READ_CMIC_I2C_SLAVE_XADDRr BCM56218_A0_READ_CMIC_I2C_SLAVE_XADDRr
#define WRITE_CMIC_I2C_SLAVE_XADDRr BCM56218_A0_WRITE_CMIC_I2C_SLAVE_XADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_I2C_SLAVE_XADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_I2C_STAT
 * BLOCKS:   CMIC
 * DESC:     I2C Condition Status Register
 * SIZE:     32
 * FIELDS:
 *     RESERVED_1       Reserved
 *     COND             Five bit condition codes defined as follows: I2C Status Register
 *     RESERVED_2       Reserved
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_I2C_STATr 0x0000012c

#define BCM56218_A0_CMIC_I2C_STATr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_I2C_STAT.
 *
 */
typedef union BCM56218_A0_CMIC_I2C_STATr_s {
	uint32_t v[1];
	uint32_t cmic_i2c_stat[1];
	uint32_t _cmic_i2c_stat;
} BCM56218_A0_CMIC_I2C_STATr_t;

#define BCM56218_A0_CMIC_I2C_STATr_CLR(r) (r).cmic_i2c_stat[0] = 0
#define BCM56218_A0_CMIC_I2C_STATr_SET(r,d) (r).cmic_i2c_stat[0] = d
#define BCM56218_A0_CMIC_I2C_STATr_GET(r) (r).cmic_i2c_stat[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_I2C_STATr_RESERVED_1f_GET(r) (((r).cmic_i2c_stat[0]) & 0x7)
#define BCM56218_A0_CMIC_I2C_STATr_RESERVED_1f_SET(r,f) (r).cmic_i2c_stat[0]=(((r).cmic_i2c_stat[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM56218_A0_CMIC_I2C_STATr_CONDf_GET(r) ((((r).cmic_i2c_stat[0]) >> 3) & 0x1f)
#define BCM56218_A0_CMIC_I2C_STATr_CONDf_SET(r,f) (r).cmic_i2c_stat[0]=(((r).cmic_i2c_stat[0] & ~((uint32_t)0x1f << 3)) | ((((uint32_t)f) & 0x1f) << 3))
#define BCM56218_A0_CMIC_I2C_STATr_RESERVED_2f_GET(r) ((((r).cmic_i2c_stat[0]) >> 8) & 0xffffff)
#define BCM56218_A0_CMIC_I2C_STATr_RESERVED_2f_SET(r,f) (r).cmic_i2c_stat[0]=(((r).cmic_i2c_stat[0] & ~((uint32_t)0xffffff << 8)) | ((((uint32_t)f) & 0xffffff) << 8))

/*
 * These macros can be used to access CMIC_I2C_STAT.
 *
 */
#define BCM56218_A0_READ_CMIC_I2C_STATr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_I2C_STATr,r._cmic_i2c_stat)
#define BCM56218_A0_WRITE_CMIC_I2C_STATr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_I2C_STATr,r._cmic_i2c_stat)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_I2C_STATr BCM56218_A0_CMIC_I2C_STATr
#define CMIC_I2C_STATr_SIZE BCM56218_A0_CMIC_I2C_STATr_SIZE
typedef BCM56218_A0_CMIC_I2C_STATr_t CMIC_I2C_STATr_t;
#define CMIC_I2C_STATr_CLR BCM56218_A0_CMIC_I2C_STATr_CLR
#define CMIC_I2C_STATr_SET BCM56218_A0_CMIC_I2C_STATr_SET
#define CMIC_I2C_STATr_GET BCM56218_A0_CMIC_I2C_STATr_GET
#define CMIC_I2C_STATr_RESERVED_1f_GET BCM56218_A0_CMIC_I2C_STATr_RESERVED_1f_GET
#define CMIC_I2C_STATr_RESERVED_1f_SET BCM56218_A0_CMIC_I2C_STATr_RESERVED_1f_SET
#define CMIC_I2C_STATr_CONDf_GET BCM56218_A0_CMIC_I2C_STATr_CONDf_GET
#define CMIC_I2C_STATr_CONDf_SET BCM56218_A0_CMIC_I2C_STATr_CONDf_SET
#define CMIC_I2C_STATr_RESERVED_2f_GET BCM56218_A0_CMIC_I2C_STATr_RESERVED_2f_GET
#define CMIC_I2C_STATr_RESERVED_2f_SET BCM56218_A0_CMIC_I2C_STATr_RESERVED_2f_SET
#define READ_CMIC_I2C_STATr BCM56218_A0_READ_CMIC_I2C_STATr
#define WRITE_CMIC_I2C_STATr BCM56218_A0_WRITE_CMIC_I2C_STATr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_I2C_STATr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_IRQ_MASK
 * BLOCKS:   CMIC
 * DESC:     Interrupt Mask Register
 * SIZE:     32
 * FIELDS:
 *     SCH_MSG_DONE     SCH Message Operation Complete Mask
 *     RESERVED_1       Reserved
 *     LINK_STAT_MOD    Link Status Change Mask
 *     L2_MOD_FIFO_NOT_EMPTY L2 MOD Fifo is full
 *     RESERVED_2       Reserved
 *     CH0_DESC_DONE    DMA CH0 Next Descriptor Execution Complete Mask
 *     CH0_CHAIN_DONE   DMA CH0 End Of Chain Mask
 *     CH1_DESC_DONE    DMA CH1 Next Descriptor Execution Complete Mask
 *     CH1_CHAIN_DONE   DMA CH1 ENd Of Chain Mask
 *     CH2_DESC_DONE    DMA CH2 Next Descriptor Execution Complete Mask
 *     CH2_CHAIN_DONE   DMA CH2 End Of Chain Mask
 *     CH3_DESC_DONE    DMA CH3 Next Descriptor Execution Complete Mask
 *     CH3_CHAIN_DONE   DMA CH3 End Of Chain Mask
 *     PCI_PARITY_ERR   PCI Bus Parity Error Mask
 *     PCI_FATAL_ERR    PCI Bus Fatal Error Mask
 *     SCHAN_ERR        SCH Bus Error Mask
 *     I2C_INTR         I2C Mask
 *     MIIM_OP_DONE     MIIM Operation Complete Mask
 *     STAT_DMA_DONE    Stats DMA Iteration Complete Mask
 *     RESERVED_3       Reserved
 *     BSE_CMDMEM_DONE  BSE CMDMEM DONE
 *     CSE_CMDMEM_DONE  CSE CMDMEM DONE
 *     HSE_CMDMEM_DONE  HSE CMDMEM DONE
 *     MEM_FAIL         MMU Memory Failed
 *     TABLE_DMA_COMPLETE Table DMA operation complete Mask
 *     SLAM_DMA_COMPLETE Slam DMA operation complete Mask
 *     BSAFE_OP_DONE    Broadsafe operation complete
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_IRQ_MASKr 0x00000148

#define BCM56218_A0_CMIC_IRQ_MASKr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_IRQ_MASK.
 *
 */
typedef union BCM56218_A0_CMIC_IRQ_MASKr_s {
	uint32_t v[1];
	uint32_t cmic_irq_mask[1];
	uint32_t _cmic_irq_mask;
} BCM56218_A0_CMIC_IRQ_MASKr_t;

#define BCM56218_A0_CMIC_IRQ_MASKr_CLR(r) (r).cmic_irq_mask[0] = 0
#define BCM56218_A0_CMIC_IRQ_MASKr_SET(r,d) (r).cmic_irq_mask[0] = d
#define BCM56218_A0_CMIC_IRQ_MASKr_GET(r) (r).cmic_irq_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_IRQ_MASKr_SCH_MSG_DONEf_GET(r) (((r).cmic_irq_mask[0]) & 0x1)
#define BCM56218_A0_CMIC_IRQ_MASKr_SCH_MSG_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_CMIC_IRQ_MASKr_RESERVED_1f_GET(r) ((((r).cmic_irq_mask[0]) >> 1) & 0x7)
#define BCM56218_A0_CMIC_IRQ_MASKr_RESERVED_1f_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define BCM56218_A0_CMIC_IRQ_MASKr_LINK_STAT_MODf_GET(r) ((((r).cmic_irq_mask[0]) >> 4) & 0x1)
#define BCM56218_A0_CMIC_IRQ_MASKr_LINK_STAT_MODf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56218_A0_CMIC_IRQ_MASKr_L2_MOD_FIFO_NOT_EMPTYf_GET(r) ((((r).cmic_irq_mask[0]) >> 5) & 0x1)
#define BCM56218_A0_CMIC_IRQ_MASKr_L2_MOD_FIFO_NOT_EMPTYf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56218_A0_CMIC_IRQ_MASKr_RESERVED_2f_GET(r) ((((r).cmic_irq_mask[0]) >> 6) & 0x1)
#define BCM56218_A0_CMIC_IRQ_MASKr_RESERVED_2f_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56218_A0_CMIC_IRQ_MASKr_CH0_DESC_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 7) & 0x1)
#define BCM56218_A0_CMIC_IRQ_MASKr_CH0_DESC_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56218_A0_CMIC_IRQ_MASKr_CH0_CHAIN_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 8) & 0x1)
#define BCM56218_A0_CMIC_IRQ_MASKr_CH0_CHAIN_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56218_A0_CMIC_IRQ_MASKr_CH1_DESC_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 9) & 0x1)
#define BCM56218_A0_CMIC_IRQ_MASKr_CH1_DESC_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56218_A0_CMIC_IRQ_MASKr_CH1_CHAIN_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 10) & 0x1)
#define BCM56218_A0_CMIC_IRQ_MASKr_CH1_CHAIN_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56218_A0_CMIC_IRQ_MASKr_CH2_DESC_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 11) & 0x1)
#define BCM56218_A0_CMIC_IRQ_MASKr_CH2_DESC_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56218_A0_CMIC_IRQ_MASKr_CH2_CHAIN_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 12) & 0x1)
#define BCM56218_A0_CMIC_IRQ_MASKr_CH2_CHAIN_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM56218_A0_CMIC_IRQ_MASKr_CH3_DESC_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 13) & 0x1)
#define BCM56218_A0_CMIC_IRQ_MASKr_CH3_DESC_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56218_A0_CMIC_IRQ_MASKr_CH3_CHAIN_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 14) & 0x1)
#define BCM56218_A0_CMIC_IRQ_MASKr_CH3_CHAIN_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM56218_A0_CMIC_IRQ_MASKr_PCI_PARITY_ERRf_GET(r) ((((r).cmic_irq_mask[0]) >> 15) & 0x1)
#define BCM56218_A0_CMIC_IRQ_MASKr_PCI_PARITY_ERRf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56218_A0_CMIC_IRQ_MASKr_PCI_FATAL_ERRf_GET(r) ((((r).cmic_irq_mask[0]) >> 16) & 0x1)
#define BCM56218_A0_CMIC_IRQ_MASKr_PCI_FATAL_ERRf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56218_A0_CMIC_IRQ_MASKr_SCHAN_ERRf_GET(r) ((((r).cmic_irq_mask[0]) >> 17) & 0x1)
#define BCM56218_A0_CMIC_IRQ_MASKr_SCHAN_ERRf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_CMIC_IRQ_MASKr_I2C_INTRf_GET(r) ((((r).cmic_irq_mask[0]) >> 18) & 0x1)
#define BCM56218_A0_CMIC_IRQ_MASKr_I2C_INTRf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_CMIC_IRQ_MASKr_MIIM_OP_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 19) & 0x1)
#define BCM56218_A0_CMIC_IRQ_MASKr_MIIM_OP_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56218_A0_CMIC_IRQ_MASKr_STAT_DMA_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 20) & 0x1)
#define BCM56218_A0_CMIC_IRQ_MASKr_STAT_DMA_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM56218_A0_CMIC_IRQ_MASKr_RESERVED_3f_GET(r) ((((r).cmic_irq_mask[0]) >> 21) & 0xf)
#define BCM56218_A0_CMIC_IRQ_MASKr_RESERVED_3f_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0xf << 21)) | ((((uint32_t)f) & 0xf) << 21))
#define BCM56218_A0_CMIC_IRQ_MASKr_BSE_CMDMEM_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 25) & 0x1)
#define BCM56218_A0_CMIC_IRQ_MASKr_BSE_CMDMEM_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM56218_A0_CMIC_IRQ_MASKr_CSE_CMDMEM_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 26) & 0x1)
#define BCM56218_A0_CMIC_IRQ_MASKr_CSE_CMDMEM_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM56218_A0_CMIC_IRQ_MASKr_HSE_CMDMEM_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 27) & 0x1)
#define BCM56218_A0_CMIC_IRQ_MASKr_HSE_CMDMEM_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM56218_A0_CMIC_IRQ_MASKr_MEM_FAILf_GET(r) ((((r).cmic_irq_mask[0]) >> 28) & 0x1)
#define BCM56218_A0_CMIC_IRQ_MASKr_MEM_FAILf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM56218_A0_CMIC_IRQ_MASKr_TABLE_DMA_COMPLETEf_GET(r) ((((r).cmic_irq_mask[0]) >> 29) & 0x1)
#define BCM56218_A0_CMIC_IRQ_MASKr_TABLE_DMA_COMPLETEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM56218_A0_CMIC_IRQ_MASKr_SLAM_DMA_COMPLETEf_GET(r) ((((r).cmic_irq_mask[0]) >> 30) & 0x1)
#define BCM56218_A0_CMIC_IRQ_MASKr_SLAM_DMA_COMPLETEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM56218_A0_CMIC_IRQ_MASKr_BSAFE_OP_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 31) & 0x1)
#define BCM56218_A0_CMIC_IRQ_MASKr_BSAFE_OP_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access CMIC_IRQ_MASK.
 *
 */
#define BCM56218_A0_READ_CMIC_IRQ_MASKr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_IRQ_MASKr,r._cmic_irq_mask)
#define BCM56218_A0_WRITE_CMIC_IRQ_MASKr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_IRQ_MASKr,r._cmic_irq_mask)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_IRQ_MASKr BCM56218_A0_CMIC_IRQ_MASKr
#define CMIC_IRQ_MASKr_SIZE BCM56218_A0_CMIC_IRQ_MASKr_SIZE
typedef BCM56218_A0_CMIC_IRQ_MASKr_t CMIC_IRQ_MASKr_t;
#define CMIC_IRQ_MASKr_CLR BCM56218_A0_CMIC_IRQ_MASKr_CLR
#define CMIC_IRQ_MASKr_SET BCM56218_A0_CMIC_IRQ_MASKr_SET
#define CMIC_IRQ_MASKr_GET BCM56218_A0_CMIC_IRQ_MASKr_GET
#define CMIC_IRQ_MASKr_SCH_MSG_DONEf_GET BCM56218_A0_CMIC_IRQ_MASKr_SCH_MSG_DONEf_GET
#define CMIC_IRQ_MASKr_SCH_MSG_DONEf_SET BCM56218_A0_CMIC_IRQ_MASKr_SCH_MSG_DONEf_SET
#define CMIC_IRQ_MASKr_RESERVED_1f_GET BCM56218_A0_CMIC_IRQ_MASKr_RESERVED_1f_GET
#define CMIC_IRQ_MASKr_RESERVED_1f_SET BCM56218_A0_CMIC_IRQ_MASKr_RESERVED_1f_SET
#define CMIC_IRQ_MASKr_LINK_STAT_MODf_GET BCM56218_A0_CMIC_IRQ_MASKr_LINK_STAT_MODf_GET
#define CMIC_IRQ_MASKr_LINK_STAT_MODf_SET BCM56218_A0_CMIC_IRQ_MASKr_LINK_STAT_MODf_SET
#define CMIC_IRQ_MASKr_L2_MOD_FIFO_NOT_EMPTYf_GET BCM56218_A0_CMIC_IRQ_MASKr_L2_MOD_FIFO_NOT_EMPTYf_GET
#define CMIC_IRQ_MASKr_L2_MOD_FIFO_NOT_EMPTYf_SET BCM56218_A0_CMIC_IRQ_MASKr_L2_MOD_FIFO_NOT_EMPTYf_SET
#define CMIC_IRQ_MASKr_RESERVED_2f_GET BCM56218_A0_CMIC_IRQ_MASKr_RESERVED_2f_GET
#define CMIC_IRQ_MASKr_RESERVED_2f_SET BCM56218_A0_CMIC_IRQ_MASKr_RESERVED_2f_SET
#define CMIC_IRQ_MASKr_CH0_DESC_DONEf_GET BCM56218_A0_CMIC_IRQ_MASKr_CH0_DESC_DONEf_GET
#define CMIC_IRQ_MASKr_CH0_DESC_DONEf_SET BCM56218_A0_CMIC_IRQ_MASKr_CH0_DESC_DONEf_SET
#define CMIC_IRQ_MASKr_CH0_CHAIN_DONEf_GET BCM56218_A0_CMIC_IRQ_MASKr_CH0_CHAIN_DONEf_GET
#define CMIC_IRQ_MASKr_CH0_CHAIN_DONEf_SET BCM56218_A0_CMIC_IRQ_MASKr_CH0_CHAIN_DONEf_SET
#define CMIC_IRQ_MASKr_CH1_DESC_DONEf_GET BCM56218_A0_CMIC_IRQ_MASKr_CH1_DESC_DONEf_GET
#define CMIC_IRQ_MASKr_CH1_DESC_DONEf_SET BCM56218_A0_CMIC_IRQ_MASKr_CH1_DESC_DONEf_SET
#define CMIC_IRQ_MASKr_CH1_CHAIN_DONEf_GET BCM56218_A0_CMIC_IRQ_MASKr_CH1_CHAIN_DONEf_GET
#define CMIC_IRQ_MASKr_CH1_CHAIN_DONEf_SET BCM56218_A0_CMIC_IRQ_MASKr_CH1_CHAIN_DONEf_SET
#define CMIC_IRQ_MASKr_CH2_DESC_DONEf_GET BCM56218_A0_CMIC_IRQ_MASKr_CH2_DESC_DONEf_GET
#define CMIC_IRQ_MASKr_CH2_DESC_DONEf_SET BCM56218_A0_CMIC_IRQ_MASKr_CH2_DESC_DONEf_SET
#define CMIC_IRQ_MASKr_CH2_CHAIN_DONEf_GET BCM56218_A0_CMIC_IRQ_MASKr_CH2_CHAIN_DONEf_GET
#define CMIC_IRQ_MASKr_CH2_CHAIN_DONEf_SET BCM56218_A0_CMIC_IRQ_MASKr_CH2_CHAIN_DONEf_SET
#define CMIC_IRQ_MASKr_CH3_DESC_DONEf_GET BCM56218_A0_CMIC_IRQ_MASKr_CH3_DESC_DONEf_GET
#define CMIC_IRQ_MASKr_CH3_DESC_DONEf_SET BCM56218_A0_CMIC_IRQ_MASKr_CH3_DESC_DONEf_SET
#define CMIC_IRQ_MASKr_CH3_CHAIN_DONEf_GET BCM56218_A0_CMIC_IRQ_MASKr_CH3_CHAIN_DONEf_GET
#define CMIC_IRQ_MASKr_CH3_CHAIN_DONEf_SET BCM56218_A0_CMIC_IRQ_MASKr_CH3_CHAIN_DONEf_SET
#define CMIC_IRQ_MASKr_PCI_PARITY_ERRf_GET BCM56218_A0_CMIC_IRQ_MASKr_PCI_PARITY_ERRf_GET
#define CMIC_IRQ_MASKr_PCI_PARITY_ERRf_SET BCM56218_A0_CMIC_IRQ_MASKr_PCI_PARITY_ERRf_SET
#define CMIC_IRQ_MASKr_PCI_FATAL_ERRf_GET BCM56218_A0_CMIC_IRQ_MASKr_PCI_FATAL_ERRf_GET
#define CMIC_IRQ_MASKr_PCI_FATAL_ERRf_SET BCM56218_A0_CMIC_IRQ_MASKr_PCI_FATAL_ERRf_SET
#define CMIC_IRQ_MASKr_SCHAN_ERRf_GET BCM56218_A0_CMIC_IRQ_MASKr_SCHAN_ERRf_GET
#define CMIC_IRQ_MASKr_SCHAN_ERRf_SET BCM56218_A0_CMIC_IRQ_MASKr_SCHAN_ERRf_SET
#define CMIC_IRQ_MASKr_I2C_INTRf_GET BCM56218_A0_CMIC_IRQ_MASKr_I2C_INTRf_GET
#define CMIC_IRQ_MASKr_I2C_INTRf_SET BCM56218_A0_CMIC_IRQ_MASKr_I2C_INTRf_SET
#define CMIC_IRQ_MASKr_MIIM_OP_DONEf_GET BCM56218_A0_CMIC_IRQ_MASKr_MIIM_OP_DONEf_GET
#define CMIC_IRQ_MASKr_MIIM_OP_DONEf_SET BCM56218_A0_CMIC_IRQ_MASKr_MIIM_OP_DONEf_SET
#define CMIC_IRQ_MASKr_STAT_DMA_DONEf_GET BCM56218_A0_CMIC_IRQ_MASKr_STAT_DMA_DONEf_GET
#define CMIC_IRQ_MASKr_STAT_DMA_DONEf_SET BCM56218_A0_CMIC_IRQ_MASKr_STAT_DMA_DONEf_SET
#define CMIC_IRQ_MASKr_RESERVED_3f_GET BCM56218_A0_CMIC_IRQ_MASKr_RESERVED_3f_GET
#define CMIC_IRQ_MASKr_RESERVED_3f_SET BCM56218_A0_CMIC_IRQ_MASKr_RESERVED_3f_SET
#define CMIC_IRQ_MASKr_BSE_CMDMEM_DONEf_GET BCM56218_A0_CMIC_IRQ_MASKr_BSE_CMDMEM_DONEf_GET
#define CMIC_IRQ_MASKr_BSE_CMDMEM_DONEf_SET BCM56218_A0_CMIC_IRQ_MASKr_BSE_CMDMEM_DONEf_SET
#define CMIC_IRQ_MASKr_CSE_CMDMEM_DONEf_GET BCM56218_A0_CMIC_IRQ_MASKr_CSE_CMDMEM_DONEf_GET
#define CMIC_IRQ_MASKr_CSE_CMDMEM_DONEf_SET BCM56218_A0_CMIC_IRQ_MASKr_CSE_CMDMEM_DONEf_SET
#define CMIC_IRQ_MASKr_HSE_CMDMEM_DONEf_GET BCM56218_A0_CMIC_IRQ_MASKr_HSE_CMDMEM_DONEf_GET
#define CMIC_IRQ_MASKr_HSE_CMDMEM_DONEf_SET BCM56218_A0_CMIC_IRQ_MASKr_HSE_CMDMEM_DONEf_SET
#define CMIC_IRQ_MASKr_MEM_FAILf_GET BCM56218_A0_CMIC_IRQ_MASKr_MEM_FAILf_GET
#define CMIC_IRQ_MASKr_MEM_FAILf_SET BCM56218_A0_CMIC_IRQ_MASKr_MEM_FAILf_SET
#define CMIC_IRQ_MASKr_TABLE_DMA_COMPLETEf_GET BCM56218_A0_CMIC_IRQ_MASKr_TABLE_DMA_COMPLETEf_GET
#define CMIC_IRQ_MASKr_TABLE_DMA_COMPLETEf_SET BCM56218_A0_CMIC_IRQ_MASKr_TABLE_DMA_COMPLETEf_SET
#define CMIC_IRQ_MASKr_SLAM_DMA_COMPLETEf_GET BCM56218_A0_CMIC_IRQ_MASKr_SLAM_DMA_COMPLETEf_GET
#define CMIC_IRQ_MASKr_SLAM_DMA_COMPLETEf_SET BCM56218_A0_CMIC_IRQ_MASKr_SLAM_DMA_COMPLETEf_SET
#define CMIC_IRQ_MASKr_BSAFE_OP_DONEf_GET BCM56218_A0_CMIC_IRQ_MASKr_BSAFE_OP_DONEf_GET
#define CMIC_IRQ_MASKr_BSAFE_OP_DONEf_SET BCM56218_A0_CMIC_IRQ_MASKr_BSAFE_OP_DONEf_SET
#define READ_CMIC_IRQ_MASKr BCM56218_A0_READ_CMIC_IRQ_MASKr
#define WRITE_CMIC_IRQ_MASKr BCM56218_A0_WRITE_CMIC_IRQ_MASKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_IRQ_MASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_IRQ_STAT
 * BLOCKS:   CMIC
 * DESC:     Interrupt Status Register
 * SIZE:     32
 * FIELDS:
 *     SCH_MSG_DONE     SCH Message Operation Complete Interrupt
 *     RESERVED_1       Reserved
 *     LINK_STAT_MOD    Link Status Change Interrupt
 *     L2_MOD_FIFO_NOT_EMPTY L2 MOD Fifo is full
 *     RESERVED_2       Reserved
 *     CH0_DESC_DONE    DMA CH0 Next Descriptor Execution Complete Interrupt
 *     CH0_CHAIN_DONE   DMA CH0 End Of Chain Interrupt
 *     CH1_DESC_DONE    DMA CH1 Next Descriptor Execution Complete Interrupt
 *     CH1_CHAIN_DONE   DMA CH1 End Of Chain Interrupt
 *     CH2_DESC_DONE    DMA CH2 Next Descriptor Execution Complete Interrupt
 *     CH2_CHAIN_DONE   DMA CH2 End Of Chain Interrupt
 *     CH3_DESC_DONE    DMA CH3 Next Descriptor Execution Complete Interrupt
 *     CH3_CHAIN_DONE   DMA CH3 End Of Chain Interrupt
 *     PCI_PARITY_ERR   PCI Bus Parity Error Interrupt
 *     PCI_FATAL_ERR    PCI Bus Fatal Error Interrupt
 *     SCHAN_ERR        SCH Bus Error Interrupt
 *     I2C_INTR         I2C Interrupt
 *     MIIM_OP_DONE     MIIM Operation Complete Interrupt
 *     STAT_DMA_DONE    Stats DMA Iteration Complete Interrupt
 *     RESERVED_3       Reserved
 *     BSE_CMDMEM_DONE  BSE CMDMEM DONE
 *     CSE_CMDMEM_DONE  CSE CMDMEM DONE
 *     HSE_CMDMEM_DONE  HSE CMDMEM DONE
 *     MEM_FAIL         MMU Memory Failed or a parity error was seen in an Ingress Pipe table.
 *     TABLE_DMA_COMPLETE Table DMA operation complete
 *     SLAM_DMA_COMPLETE Slam DMA operation complete
 *     BSAFE_OP_DONE    Broadsafe operation complete
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_IRQ_STATr 0x00000144

#define BCM56218_A0_CMIC_IRQ_STATr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_IRQ_STAT.
 *
 */
typedef union BCM56218_A0_CMIC_IRQ_STATr_s {
	uint32_t v[1];
	uint32_t cmic_irq_stat[1];
	uint32_t _cmic_irq_stat;
} BCM56218_A0_CMIC_IRQ_STATr_t;

#define BCM56218_A0_CMIC_IRQ_STATr_CLR(r) (r).cmic_irq_stat[0] = 0
#define BCM56218_A0_CMIC_IRQ_STATr_SET(r,d) (r).cmic_irq_stat[0] = d
#define BCM56218_A0_CMIC_IRQ_STATr_GET(r) (r).cmic_irq_stat[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_IRQ_STATr_SCH_MSG_DONEf_GET(r) (((r).cmic_irq_stat[0]) & 0x1)
#define BCM56218_A0_CMIC_IRQ_STATr_SCH_MSG_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_CMIC_IRQ_STATr_RESERVED_1f_GET(r) ((((r).cmic_irq_stat[0]) >> 1) & 0x7)
#define BCM56218_A0_CMIC_IRQ_STATr_RESERVED_1f_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define BCM56218_A0_CMIC_IRQ_STATr_LINK_STAT_MODf_GET(r) ((((r).cmic_irq_stat[0]) >> 4) & 0x1)
#define BCM56218_A0_CMIC_IRQ_STATr_LINK_STAT_MODf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56218_A0_CMIC_IRQ_STATr_L2_MOD_FIFO_NOT_EMPTYf_GET(r) ((((r).cmic_irq_stat[0]) >> 5) & 0x1)
#define BCM56218_A0_CMIC_IRQ_STATr_L2_MOD_FIFO_NOT_EMPTYf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56218_A0_CMIC_IRQ_STATr_RESERVED_2f_GET(r) ((((r).cmic_irq_stat[0]) >> 6) & 0x1)
#define BCM56218_A0_CMIC_IRQ_STATr_RESERVED_2f_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56218_A0_CMIC_IRQ_STATr_CH0_DESC_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 7) & 0x1)
#define BCM56218_A0_CMIC_IRQ_STATr_CH0_DESC_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56218_A0_CMIC_IRQ_STATr_CH0_CHAIN_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 8) & 0x1)
#define BCM56218_A0_CMIC_IRQ_STATr_CH0_CHAIN_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56218_A0_CMIC_IRQ_STATr_CH1_DESC_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 9) & 0x1)
#define BCM56218_A0_CMIC_IRQ_STATr_CH1_DESC_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56218_A0_CMIC_IRQ_STATr_CH1_CHAIN_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 10) & 0x1)
#define BCM56218_A0_CMIC_IRQ_STATr_CH1_CHAIN_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56218_A0_CMIC_IRQ_STATr_CH2_DESC_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 11) & 0x1)
#define BCM56218_A0_CMIC_IRQ_STATr_CH2_DESC_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56218_A0_CMIC_IRQ_STATr_CH2_CHAIN_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 12) & 0x1)
#define BCM56218_A0_CMIC_IRQ_STATr_CH2_CHAIN_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM56218_A0_CMIC_IRQ_STATr_CH3_DESC_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 13) & 0x1)
#define BCM56218_A0_CMIC_IRQ_STATr_CH3_DESC_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56218_A0_CMIC_IRQ_STATr_CH3_CHAIN_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 14) & 0x1)
#define BCM56218_A0_CMIC_IRQ_STATr_CH3_CHAIN_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM56218_A0_CMIC_IRQ_STATr_PCI_PARITY_ERRf_GET(r) ((((r).cmic_irq_stat[0]) >> 15) & 0x1)
#define BCM56218_A0_CMIC_IRQ_STATr_PCI_PARITY_ERRf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56218_A0_CMIC_IRQ_STATr_PCI_FATAL_ERRf_GET(r) ((((r).cmic_irq_stat[0]) >> 16) & 0x1)
#define BCM56218_A0_CMIC_IRQ_STATr_PCI_FATAL_ERRf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56218_A0_CMIC_IRQ_STATr_SCHAN_ERRf_GET(r) ((((r).cmic_irq_stat[0]) >> 17) & 0x1)
#define BCM56218_A0_CMIC_IRQ_STATr_SCHAN_ERRf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_CMIC_IRQ_STATr_I2C_INTRf_GET(r) ((((r).cmic_irq_stat[0]) >> 18) & 0x1)
#define BCM56218_A0_CMIC_IRQ_STATr_I2C_INTRf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_CMIC_IRQ_STATr_MIIM_OP_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 19) & 0x1)
#define BCM56218_A0_CMIC_IRQ_STATr_MIIM_OP_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56218_A0_CMIC_IRQ_STATr_STAT_DMA_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 20) & 0x1)
#define BCM56218_A0_CMIC_IRQ_STATr_STAT_DMA_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM56218_A0_CMIC_IRQ_STATr_RESERVED_3f_GET(r) ((((r).cmic_irq_stat[0]) >> 21) & 0xf)
#define BCM56218_A0_CMIC_IRQ_STATr_RESERVED_3f_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0xf << 21)) | ((((uint32_t)f) & 0xf) << 21))
#define BCM56218_A0_CMIC_IRQ_STATr_BSE_CMDMEM_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 25) & 0x1)
#define BCM56218_A0_CMIC_IRQ_STATr_BSE_CMDMEM_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM56218_A0_CMIC_IRQ_STATr_CSE_CMDMEM_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 26) & 0x1)
#define BCM56218_A0_CMIC_IRQ_STATr_CSE_CMDMEM_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM56218_A0_CMIC_IRQ_STATr_HSE_CMDMEM_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 27) & 0x1)
#define BCM56218_A0_CMIC_IRQ_STATr_HSE_CMDMEM_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM56218_A0_CMIC_IRQ_STATr_MEM_FAILf_GET(r) ((((r).cmic_irq_stat[0]) >> 28) & 0x1)
#define BCM56218_A0_CMIC_IRQ_STATr_MEM_FAILf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM56218_A0_CMIC_IRQ_STATr_TABLE_DMA_COMPLETEf_GET(r) ((((r).cmic_irq_stat[0]) >> 29) & 0x1)
#define BCM56218_A0_CMIC_IRQ_STATr_TABLE_DMA_COMPLETEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM56218_A0_CMIC_IRQ_STATr_SLAM_DMA_COMPLETEf_GET(r) ((((r).cmic_irq_stat[0]) >> 30) & 0x1)
#define BCM56218_A0_CMIC_IRQ_STATr_SLAM_DMA_COMPLETEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM56218_A0_CMIC_IRQ_STATr_BSAFE_OP_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 31) & 0x1)
#define BCM56218_A0_CMIC_IRQ_STATr_BSAFE_OP_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access CMIC_IRQ_STAT.
 *
 */
#define BCM56218_A0_READ_CMIC_IRQ_STATr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_IRQ_STATr,r._cmic_irq_stat)
#define BCM56218_A0_WRITE_CMIC_IRQ_STATr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_IRQ_STATr,r._cmic_irq_stat)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_IRQ_STATr BCM56218_A0_CMIC_IRQ_STATr
#define CMIC_IRQ_STATr_SIZE BCM56218_A0_CMIC_IRQ_STATr_SIZE
typedef BCM56218_A0_CMIC_IRQ_STATr_t CMIC_IRQ_STATr_t;
#define CMIC_IRQ_STATr_CLR BCM56218_A0_CMIC_IRQ_STATr_CLR
#define CMIC_IRQ_STATr_SET BCM56218_A0_CMIC_IRQ_STATr_SET
#define CMIC_IRQ_STATr_GET BCM56218_A0_CMIC_IRQ_STATr_GET
#define CMIC_IRQ_STATr_SCH_MSG_DONEf_GET BCM56218_A0_CMIC_IRQ_STATr_SCH_MSG_DONEf_GET
#define CMIC_IRQ_STATr_SCH_MSG_DONEf_SET BCM56218_A0_CMIC_IRQ_STATr_SCH_MSG_DONEf_SET
#define CMIC_IRQ_STATr_RESERVED_1f_GET BCM56218_A0_CMIC_IRQ_STATr_RESERVED_1f_GET
#define CMIC_IRQ_STATr_RESERVED_1f_SET BCM56218_A0_CMIC_IRQ_STATr_RESERVED_1f_SET
#define CMIC_IRQ_STATr_LINK_STAT_MODf_GET BCM56218_A0_CMIC_IRQ_STATr_LINK_STAT_MODf_GET
#define CMIC_IRQ_STATr_LINK_STAT_MODf_SET BCM56218_A0_CMIC_IRQ_STATr_LINK_STAT_MODf_SET
#define CMIC_IRQ_STATr_L2_MOD_FIFO_NOT_EMPTYf_GET BCM56218_A0_CMIC_IRQ_STATr_L2_MOD_FIFO_NOT_EMPTYf_GET
#define CMIC_IRQ_STATr_L2_MOD_FIFO_NOT_EMPTYf_SET BCM56218_A0_CMIC_IRQ_STATr_L2_MOD_FIFO_NOT_EMPTYf_SET
#define CMIC_IRQ_STATr_RESERVED_2f_GET BCM56218_A0_CMIC_IRQ_STATr_RESERVED_2f_GET
#define CMIC_IRQ_STATr_RESERVED_2f_SET BCM56218_A0_CMIC_IRQ_STATr_RESERVED_2f_SET
#define CMIC_IRQ_STATr_CH0_DESC_DONEf_GET BCM56218_A0_CMIC_IRQ_STATr_CH0_DESC_DONEf_GET
#define CMIC_IRQ_STATr_CH0_DESC_DONEf_SET BCM56218_A0_CMIC_IRQ_STATr_CH0_DESC_DONEf_SET
#define CMIC_IRQ_STATr_CH0_CHAIN_DONEf_GET BCM56218_A0_CMIC_IRQ_STATr_CH0_CHAIN_DONEf_GET
#define CMIC_IRQ_STATr_CH0_CHAIN_DONEf_SET BCM56218_A0_CMIC_IRQ_STATr_CH0_CHAIN_DONEf_SET
#define CMIC_IRQ_STATr_CH1_DESC_DONEf_GET BCM56218_A0_CMIC_IRQ_STATr_CH1_DESC_DONEf_GET
#define CMIC_IRQ_STATr_CH1_DESC_DONEf_SET BCM56218_A0_CMIC_IRQ_STATr_CH1_DESC_DONEf_SET
#define CMIC_IRQ_STATr_CH1_CHAIN_DONEf_GET BCM56218_A0_CMIC_IRQ_STATr_CH1_CHAIN_DONEf_GET
#define CMIC_IRQ_STATr_CH1_CHAIN_DONEf_SET BCM56218_A0_CMIC_IRQ_STATr_CH1_CHAIN_DONEf_SET
#define CMIC_IRQ_STATr_CH2_DESC_DONEf_GET BCM56218_A0_CMIC_IRQ_STATr_CH2_DESC_DONEf_GET
#define CMIC_IRQ_STATr_CH2_DESC_DONEf_SET BCM56218_A0_CMIC_IRQ_STATr_CH2_DESC_DONEf_SET
#define CMIC_IRQ_STATr_CH2_CHAIN_DONEf_GET BCM56218_A0_CMIC_IRQ_STATr_CH2_CHAIN_DONEf_GET
#define CMIC_IRQ_STATr_CH2_CHAIN_DONEf_SET BCM56218_A0_CMIC_IRQ_STATr_CH2_CHAIN_DONEf_SET
#define CMIC_IRQ_STATr_CH3_DESC_DONEf_GET BCM56218_A0_CMIC_IRQ_STATr_CH3_DESC_DONEf_GET
#define CMIC_IRQ_STATr_CH3_DESC_DONEf_SET BCM56218_A0_CMIC_IRQ_STATr_CH3_DESC_DONEf_SET
#define CMIC_IRQ_STATr_CH3_CHAIN_DONEf_GET BCM56218_A0_CMIC_IRQ_STATr_CH3_CHAIN_DONEf_GET
#define CMIC_IRQ_STATr_CH3_CHAIN_DONEf_SET BCM56218_A0_CMIC_IRQ_STATr_CH3_CHAIN_DONEf_SET
#define CMIC_IRQ_STATr_PCI_PARITY_ERRf_GET BCM56218_A0_CMIC_IRQ_STATr_PCI_PARITY_ERRf_GET
#define CMIC_IRQ_STATr_PCI_PARITY_ERRf_SET BCM56218_A0_CMIC_IRQ_STATr_PCI_PARITY_ERRf_SET
#define CMIC_IRQ_STATr_PCI_FATAL_ERRf_GET BCM56218_A0_CMIC_IRQ_STATr_PCI_FATAL_ERRf_GET
#define CMIC_IRQ_STATr_PCI_FATAL_ERRf_SET BCM56218_A0_CMIC_IRQ_STATr_PCI_FATAL_ERRf_SET
#define CMIC_IRQ_STATr_SCHAN_ERRf_GET BCM56218_A0_CMIC_IRQ_STATr_SCHAN_ERRf_GET
#define CMIC_IRQ_STATr_SCHAN_ERRf_SET BCM56218_A0_CMIC_IRQ_STATr_SCHAN_ERRf_SET
#define CMIC_IRQ_STATr_I2C_INTRf_GET BCM56218_A0_CMIC_IRQ_STATr_I2C_INTRf_GET
#define CMIC_IRQ_STATr_I2C_INTRf_SET BCM56218_A0_CMIC_IRQ_STATr_I2C_INTRf_SET
#define CMIC_IRQ_STATr_MIIM_OP_DONEf_GET BCM56218_A0_CMIC_IRQ_STATr_MIIM_OP_DONEf_GET
#define CMIC_IRQ_STATr_MIIM_OP_DONEf_SET BCM56218_A0_CMIC_IRQ_STATr_MIIM_OP_DONEf_SET
#define CMIC_IRQ_STATr_STAT_DMA_DONEf_GET BCM56218_A0_CMIC_IRQ_STATr_STAT_DMA_DONEf_GET
#define CMIC_IRQ_STATr_STAT_DMA_DONEf_SET BCM56218_A0_CMIC_IRQ_STATr_STAT_DMA_DONEf_SET
#define CMIC_IRQ_STATr_RESERVED_3f_GET BCM56218_A0_CMIC_IRQ_STATr_RESERVED_3f_GET
#define CMIC_IRQ_STATr_RESERVED_3f_SET BCM56218_A0_CMIC_IRQ_STATr_RESERVED_3f_SET
#define CMIC_IRQ_STATr_BSE_CMDMEM_DONEf_GET BCM56218_A0_CMIC_IRQ_STATr_BSE_CMDMEM_DONEf_GET
#define CMIC_IRQ_STATr_BSE_CMDMEM_DONEf_SET BCM56218_A0_CMIC_IRQ_STATr_BSE_CMDMEM_DONEf_SET
#define CMIC_IRQ_STATr_CSE_CMDMEM_DONEf_GET BCM56218_A0_CMIC_IRQ_STATr_CSE_CMDMEM_DONEf_GET
#define CMIC_IRQ_STATr_CSE_CMDMEM_DONEf_SET BCM56218_A0_CMIC_IRQ_STATr_CSE_CMDMEM_DONEf_SET
#define CMIC_IRQ_STATr_HSE_CMDMEM_DONEf_GET BCM56218_A0_CMIC_IRQ_STATr_HSE_CMDMEM_DONEf_GET
#define CMIC_IRQ_STATr_HSE_CMDMEM_DONEf_SET BCM56218_A0_CMIC_IRQ_STATr_HSE_CMDMEM_DONEf_SET
#define CMIC_IRQ_STATr_MEM_FAILf_GET BCM56218_A0_CMIC_IRQ_STATr_MEM_FAILf_GET
#define CMIC_IRQ_STATr_MEM_FAILf_SET BCM56218_A0_CMIC_IRQ_STATr_MEM_FAILf_SET
#define CMIC_IRQ_STATr_TABLE_DMA_COMPLETEf_GET BCM56218_A0_CMIC_IRQ_STATr_TABLE_DMA_COMPLETEf_GET
#define CMIC_IRQ_STATr_TABLE_DMA_COMPLETEf_SET BCM56218_A0_CMIC_IRQ_STATr_TABLE_DMA_COMPLETEf_SET
#define CMIC_IRQ_STATr_SLAM_DMA_COMPLETEf_GET BCM56218_A0_CMIC_IRQ_STATr_SLAM_DMA_COMPLETEf_GET
#define CMIC_IRQ_STATr_SLAM_DMA_COMPLETEf_SET BCM56218_A0_CMIC_IRQ_STATr_SLAM_DMA_COMPLETEf_SET
#define CMIC_IRQ_STATr_BSAFE_OP_DONEf_GET BCM56218_A0_CMIC_IRQ_STATr_BSAFE_OP_DONEf_GET
#define CMIC_IRQ_STATr_BSAFE_OP_DONEf_SET BCM56218_A0_CMIC_IRQ_STATr_BSAFE_OP_DONEf_SET
#define READ_CMIC_IRQ_STATr BCM56218_A0_READ_CMIC_IRQ_STATr
#define WRITE_CMIC_IRQ_STATr BCM56218_A0_WRITE_CMIC_IRQ_STATr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_IRQ_STATr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_LEDUP_CTRL
 * BLOCKS:   CMIC
 * DESC:     LEDUP Control
 * SIZE:     32
 * FIELDS:
 *     LEDUP_EN         LEDUP Enable
 *     LEDUP_SKIP_SCAN_OUT If set, skip Data Scan-out step
 *     LEDUP_SKIP_PROCESSOR If set, skip LED Processor run
 *     LEDUP_SKIP_SCAN_IN If set, skip MAC Data Scan-in step
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_LEDUP_CTRLr 0x00001000

#define BCM56218_A0_CMIC_LEDUP_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_LEDUP_CTRL.
 *
 */
typedef union BCM56218_A0_CMIC_LEDUP_CTRLr_s {
	uint32_t v[1];
	uint32_t cmic_ledup_ctrl[1];
	uint32_t _cmic_ledup_ctrl;
} BCM56218_A0_CMIC_LEDUP_CTRLr_t;

#define BCM56218_A0_CMIC_LEDUP_CTRLr_CLR(r) (r).cmic_ledup_ctrl[0] = 0
#define BCM56218_A0_CMIC_LEDUP_CTRLr_SET(r,d) (r).cmic_ledup_ctrl[0] = d
#define BCM56218_A0_CMIC_LEDUP_CTRLr_GET(r) (r).cmic_ledup_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_LEDUP_CTRLr_LEDUP_ENf_GET(r) (((r).cmic_ledup_ctrl[0]) & 0x1)
#define BCM56218_A0_CMIC_LEDUP_CTRLr_LEDUP_ENf_SET(r,f) (r).cmic_ledup_ctrl[0]=(((r).cmic_ledup_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_CMIC_LEDUP_CTRLr_LEDUP_SKIP_SCAN_OUTf_GET(r) ((((r).cmic_ledup_ctrl[0]) >> 1) & 0x1)
#define BCM56218_A0_CMIC_LEDUP_CTRLr_LEDUP_SKIP_SCAN_OUTf_SET(r,f) (r).cmic_ledup_ctrl[0]=(((r).cmic_ledup_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_CMIC_LEDUP_CTRLr_LEDUP_SKIP_PROCESSORf_GET(r) ((((r).cmic_ledup_ctrl[0]) >> 2) & 0x1)
#define BCM56218_A0_CMIC_LEDUP_CTRLr_LEDUP_SKIP_PROCESSORf_SET(r,f) (r).cmic_ledup_ctrl[0]=(((r).cmic_ledup_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_CMIC_LEDUP_CTRLr_LEDUP_SKIP_SCAN_INf_GET(r) ((((r).cmic_ledup_ctrl[0]) >> 3) & 0x1)
#define BCM56218_A0_CMIC_LEDUP_CTRLr_LEDUP_SKIP_SCAN_INf_SET(r,f) (r).cmic_ledup_ctrl[0]=(((r).cmic_ledup_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))

/*
 * These macros can be used to access CMIC_LEDUP_CTRL.
 *
 */
#define BCM56218_A0_READ_CMIC_LEDUP_CTRLr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_LEDUP_CTRLr,r._cmic_ledup_ctrl)
#define BCM56218_A0_WRITE_CMIC_LEDUP_CTRLr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_LEDUP_CTRLr,r._cmic_ledup_ctrl)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_LEDUP_CTRLr BCM56218_A0_CMIC_LEDUP_CTRLr
#define CMIC_LEDUP_CTRLr_SIZE BCM56218_A0_CMIC_LEDUP_CTRLr_SIZE
typedef BCM56218_A0_CMIC_LEDUP_CTRLr_t CMIC_LEDUP_CTRLr_t;
#define CMIC_LEDUP_CTRLr_CLR BCM56218_A0_CMIC_LEDUP_CTRLr_CLR
#define CMIC_LEDUP_CTRLr_SET BCM56218_A0_CMIC_LEDUP_CTRLr_SET
#define CMIC_LEDUP_CTRLr_GET BCM56218_A0_CMIC_LEDUP_CTRLr_GET
#define CMIC_LEDUP_CTRLr_LEDUP_ENf_GET BCM56218_A0_CMIC_LEDUP_CTRLr_LEDUP_ENf_GET
#define CMIC_LEDUP_CTRLr_LEDUP_ENf_SET BCM56218_A0_CMIC_LEDUP_CTRLr_LEDUP_ENf_SET
#define CMIC_LEDUP_CTRLr_LEDUP_SKIP_SCAN_OUTf_GET BCM56218_A0_CMIC_LEDUP_CTRLr_LEDUP_SKIP_SCAN_OUTf_GET
#define CMIC_LEDUP_CTRLr_LEDUP_SKIP_SCAN_OUTf_SET BCM56218_A0_CMIC_LEDUP_CTRLr_LEDUP_SKIP_SCAN_OUTf_SET
#define CMIC_LEDUP_CTRLr_LEDUP_SKIP_PROCESSORf_GET BCM56218_A0_CMIC_LEDUP_CTRLr_LEDUP_SKIP_PROCESSORf_GET
#define CMIC_LEDUP_CTRLr_LEDUP_SKIP_PROCESSORf_SET BCM56218_A0_CMIC_LEDUP_CTRLr_LEDUP_SKIP_PROCESSORf_SET
#define CMIC_LEDUP_CTRLr_LEDUP_SKIP_SCAN_INf_GET BCM56218_A0_CMIC_LEDUP_CTRLr_LEDUP_SKIP_SCAN_INf_GET
#define CMIC_LEDUP_CTRLr_LEDUP_SKIP_SCAN_INf_SET BCM56218_A0_CMIC_LEDUP_CTRLr_LEDUP_SKIP_SCAN_INf_SET
#define READ_CMIC_LEDUP_CTRLr BCM56218_A0_READ_CMIC_LEDUP_CTRLr
#define WRITE_CMIC_LEDUP_CTRLr BCM56218_A0_WRITE_CMIC_LEDUP_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_LEDUP_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_LEDUP_DATA_RAM
 * BLOCKS:   CMIC
 * DESC:     LEDUP Data RAM
 * SIZE:     32
 * FIELDS:
 *     DATA             LEDUP DATA RAM data (Rd/Wr) word
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_LEDUP_DATA_RAMr 0x00001c00

#define BCM56218_A0_CMIC_LEDUP_DATA_RAMr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_LEDUP_DATA_RAM.
 *
 */
typedef union BCM56218_A0_CMIC_LEDUP_DATA_RAMr_s {
	uint32_t v[1];
	uint32_t cmic_ledup_data_ram[1];
	uint32_t _cmic_ledup_data_ram;
} BCM56218_A0_CMIC_LEDUP_DATA_RAMr_t;

#define BCM56218_A0_CMIC_LEDUP_DATA_RAMr_CLR(r) (r).cmic_ledup_data_ram[0] = 0
#define BCM56218_A0_CMIC_LEDUP_DATA_RAMr_SET(r,d) (r).cmic_ledup_data_ram[0] = d
#define BCM56218_A0_CMIC_LEDUP_DATA_RAMr_GET(r) (r).cmic_ledup_data_ram[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_LEDUP_DATA_RAMr_DATAf_GET(r) (((r).cmic_ledup_data_ram[0]) & 0xff)
#define BCM56218_A0_CMIC_LEDUP_DATA_RAMr_DATAf_SET(r,f) (r).cmic_ledup_data_ram[0]=(((r).cmic_ledup_data_ram[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access CMIC_LEDUP_DATA_RAM.
 *
 */
#define BCM56218_A0_READ_CMIC_LEDUP_DATA_RAMr(u,i,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_LEDUP_DATA_RAMr+(4*(i)),r._cmic_ledup_data_ram)
#define BCM56218_A0_WRITE_CMIC_LEDUP_DATA_RAMr(u,i,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_LEDUP_DATA_RAMr+(4*(i)),r._cmic_ledup_data_ram)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_LEDUP_DATA_RAMr BCM56218_A0_CMIC_LEDUP_DATA_RAMr
#define CMIC_LEDUP_DATA_RAMr_SIZE BCM56218_A0_CMIC_LEDUP_DATA_RAMr_SIZE
typedef BCM56218_A0_CMIC_LEDUP_DATA_RAMr_t CMIC_LEDUP_DATA_RAMr_t;
#define CMIC_LEDUP_DATA_RAMr_CLR BCM56218_A0_CMIC_LEDUP_DATA_RAMr_CLR
#define CMIC_LEDUP_DATA_RAMr_SET BCM56218_A0_CMIC_LEDUP_DATA_RAMr_SET
#define CMIC_LEDUP_DATA_RAMr_GET BCM56218_A0_CMIC_LEDUP_DATA_RAMr_GET
#define CMIC_LEDUP_DATA_RAMr_DATAf_GET BCM56218_A0_CMIC_LEDUP_DATA_RAMr_DATAf_GET
#define CMIC_LEDUP_DATA_RAMr_DATAf_SET BCM56218_A0_CMIC_LEDUP_DATA_RAMr_DATAf_SET
#define READ_CMIC_LEDUP_DATA_RAMr BCM56218_A0_READ_CMIC_LEDUP_DATA_RAMr
#define WRITE_CMIC_LEDUP_DATA_RAMr BCM56218_A0_WRITE_CMIC_LEDUP_DATA_RAMr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_LEDUP_DATA_RAMr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_LEDUP_PROGRAM_RAM
 * BLOCKS:   CMIC
 * DESC:     LEDUP Program RAM
 * SIZE:     32
 * FIELDS:
 *     DATA             LEDUP PROGRAM RAM data (Rd/Wr) word
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_LEDUP_PROGRAM_RAMr 0x00001800

#define BCM56218_A0_CMIC_LEDUP_PROGRAM_RAMr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_LEDUP_PROGRAM_RAM.
 *
 */
typedef union BCM56218_A0_CMIC_LEDUP_PROGRAM_RAMr_s {
	uint32_t v[1];
	uint32_t cmic_ledup_program_ram[1];
	uint32_t _cmic_ledup_program_ram;
} BCM56218_A0_CMIC_LEDUP_PROGRAM_RAMr_t;

#define BCM56218_A0_CMIC_LEDUP_PROGRAM_RAMr_CLR(r) (r).cmic_ledup_program_ram[0] = 0
#define BCM56218_A0_CMIC_LEDUP_PROGRAM_RAMr_SET(r,d) (r).cmic_ledup_program_ram[0] = d
#define BCM56218_A0_CMIC_LEDUP_PROGRAM_RAMr_GET(r) (r).cmic_ledup_program_ram[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_LEDUP_PROGRAM_RAMr_DATAf_GET(r) (((r).cmic_ledup_program_ram[0]) & 0xff)
#define BCM56218_A0_CMIC_LEDUP_PROGRAM_RAMr_DATAf_SET(r,f) (r).cmic_ledup_program_ram[0]=(((r).cmic_ledup_program_ram[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access CMIC_LEDUP_PROGRAM_RAM.
 *
 */
#define BCM56218_A0_READ_CMIC_LEDUP_PROGRAM_RAMr(u,i,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_LEDUP_PROGRAM_RAMr+(4*(i)),r._cmic_ledup_program_ram)
#define BCM56218_A0_WRITE_CMIC_LEDUP_PROGRAM_RAMr(u,i,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_LEDUP_PROGRAM_RAMr+(4*(i)),r._cmic_ledup_program_ram)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_LEDUP_PROGRAM_RAMr BCM56218_A0_CMIC_LEDUP_PROGRAM_RAMr
#define CMIC_LEDUP_PROGRAM_RAMr_SIZE BCM56218_A0_CMIC_LEDUP_PROGRAM_RAMr_SIZE
typedef BCM56218_A0_CMIC_LEDUP_PROGRAM_RAMr_t CMIC_LEDUP_PROGRAM_RAMr_t;
#define CMIC_LEDUP_PROGRAM_RAMr_CLR BCM56218_A0_CMIC_LEDUP_PROGRAM_RAMr_CLR
#define CMIC_LEDUP_PROGRAM_RAMr_SET BCM56218_A0_CMIC_LEDUP_PROGRAM_RAMr_SET
#define CMIC_LEDUP_PROGRAM_RAMr_GET BCM56218_A0_CMIC_LEDUP_PROGRAM_RAMr_GET
#define CMIC_LEDUP_PROGRAM_RAMr_DATAf_GET BCM56218_A0_CMIC_LEDUP_PROGRAM_RAMr_DATAf_GET
#define CMIC_LEDUP_PROGRAM_RAMr_DATAf_SET BCM56218_A0_CMIC_LEDUP_PROGRAM_RAMr_DATAf_SET
#define READ_CMIC_LEDUP_PROGRAM_RAMr BCM56218_A0_READ_CMIC_LEDUP_PROGRAM_RAMr
#define WRITE_CMIC_LEDUP_PROGRAM_RAMr BCM56218_A0_WRITE_CMIC_LEDUP_PROGRAM_RAMr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_LEDUP_PROGRAM_RAMr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_LEDUP_STATUS
 * BLOCKS:   CMIC
 * DESC:     LEDUP Status
 * SIZE:     32
 * FIELDS:
 *     PROGRAM_COUNTER  LEDUP Program Counter
 *     LEDUP_RUNNING    LEDUP Running
 *     LEDUP_INITIALISING LEDUP Initialising
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_LEDUP_STATUSr 0x00001004

#define BCM56218_A0_CMIC_LEDUP_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_LEDUP_STATUS.
 *
 */
typedef union BCM56218_A0_CMIC_LEDUP_STATUSr_s {
	uint32_t v[1];
	uint32_t cmic_ledup_status[1];
	uint32_t _cmic_ledup_status;
} BCM56218_A0_CMIC_LEDUP_STATUSr_t;

#define BCM56218_A0_CMIC_LEDUP_STATUSr_CLR(r) (r).cmic_ledup_status[0] = 0
#define BCM56218_A0_CMIC_LEDUP_STATUSr_SET(r,d) (r).cmic_ledup_status[0] = d
#define BCM56218_A0_CMIC_LEDUP_STATUSr_GET(r) (r).cmic_ledup_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_LEDUP_STATUSr_PROGRAM_COUNTERf_GET(r) (((r).cmic_ledup_status[0]) & 0xff)
#define BCM56218_A0_CMIC_LEDUP_STATUSr_PROGRAM_COUNTERf_SET(r,f) (r).cmic_ledup_status[0]=(((r).cmic_ledup_status[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56218_A0_CMIC_LEDUP_STATUSr_LEDUP_RUNNINGf_GET(r) ((((r).cmic_ledup_status[0]) >> 8) & 0x1)
#define BCM56218_A0_CMIC_LEDUP_STATUSr_LEDUP_RUNNINGf_SET(r,f) (r).cmic_ledup_status[0]=(((r).cmic_ledup_status[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56218_A0_CMIC_LEDUP_STATUSr_LEDUP_INITIALISINGf_GET(r) ((((r).cmic_ledup_status[0]) >> 9) & 0x1)
#define BCM56218_A0_CMIC_LEDUP_STATUSr_LEDUP_INITIALISINGf_SET(r,f) (r).cmic_ledup_status[0]=(((r).cmic_ledup_status[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))

/*
 * These macros can be used to access CMIC_LEDUP_STATUS.
 *
 */
#define BCM56218_A0_READ_CMIC_LEDUP_STATUSr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_LEDUP_STATUSr,r._cmic_ledup_status)
#define BCM56218_A0_WRITE_CMIC_LEDUP_STATUSr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_LEDUP_STATUSr,r._cmic_ledup_status)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_LEDUP_STATUSr BCM56218_A0_CMIC_LEDUP_STATUSr
#define CMIC_LEDUP_STATUSr_SIZE BCM56218_A0_CMIC_LEDUP_STATUSr_SIZE
typedef BCM56218_A0_CMIC_LEDUP_STATUSr_t CMIC_LEDUP_STATUSr_t;
#define CMIC_LEDUP_STATUSr_CLR BCM56218_A0_CMIC_LEDUP_STATUSr_CLR
#define CMIC_LEDUP_STATUSr_SET BCM56218_A0_CMIC_LEDUP_STATUSr_SET
#define CMIC_LEDUP_STATUSr_GET BCM56218_A0_CMIC_LEDUP_STATUSr_GET
#define CMIC_LEDUP_STATUSr_PROGRAM_COUNTERf_GET BCM56218_A0_CMIC_LEDUP_STATUSr_PROGRAM_COUNTERf_GET
#define CMIC_LEDUP_STATUSr_PROGRAM_COUNTERf_SET BCM56218_A0_CMIC_LEDUP_STATUSr_PROGRAM_COUNTERf_SET
#define CMIC_LEDUP_STATUSr_LEDUP_RUNNINGf_GET BCM56218_A0_CMIC_LEDUP_STATUSr_LEDUP_RUNNINGf_GET
#define CMIC_LEDUP_STATUSr_LEDUP_RUNNINGf_SET BCM56218_A0_CMIC_LEDUP_STATUSr_LEDUP_RUNNINGf_SET
#define CMIC_LEDUP_STATUSr_LEDUP_INITIALISINGf_GET BCM56218_A0_CMIC_LEDUP_STATUSr_LEDUP_INITIALISINGf_GET
#define CMIC_LEDUP_STATUSr_LEDUP_INITIALISINGf_SET BCM56218_A0_CMIC_LEDUP_STATUSr_LEDUP_INITIALISINGf_SET
#define READ_CMIC_LEDUP_STATUSr BCM56218_A0_READ_CMIC_LEDUP_STATUSr
#define WRITE_CMIC_LEDUP_STATUSr BCM56218_A0_WRITE_CMIC_LEDUP_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_LEDUP_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_LED_PORT_ORDER_REMAP_0_4
 * BLOCKS:   CMIC
 * DESC:     LEDUP SCan Data Remap register for ports 0-4
 * SIZE:     32
 * FIELDS:
 *     REMAP_PORT_0     Remapping for Port 0
 *     REMAP_PORT_1     Remapping for Port 1
 *     REMAP_PORT_2     Remapping for Port 2
 *     REMAP_PORT_3     Remapping for Port 3
 *     REMAP_PORT_4     Remapping for Port 4
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r 0x00000d00

#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_LED_PORT_ORDER_REMAP_0_4.
 *
 */
typedef union BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_s {
	uint32_t v[1];
	uint32_t cmic_led_port_order_remap_0_4[1];
	uint32_t _cmic_led_port_order_remap_0_4;
} BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_t;

#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_CLR(r) (r).cmic_led_port_order_remap_0_4[0] = 0
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_SET(r,d) (r).cmic_led_port_order_remap_0_4[0] = d
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_GET(r) (r).cmic_led_port_order_remap_0_4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_REMAP_PORT_0f_GET(r) (((r).cmic_led_port_order_remap_0_4[0]) & 0x3f)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_REMAP_PORT_0f_SET(r,f) (r).cmic_led_port_order_remap_0_4[0]=(((r).cmic_led_port_order_remap_0_4[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_REMAP_PORT_1f_GET(r) ((((r).cmic_led_port_order_remap_0_4[0]) >> 6) & 0x3f)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_REMAP_PORT_1f_SET(r,f) (r).cmic_led_port_order_remap_0_4[0]=(((r).cmic_led_port_order_remap_0_4[0] & ~((uint32_t)0x3f << 6)) | ((((uint32_t)f) & 0x3f) << 6))
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_REMAP_PORT_2f_GET(r) ((((r).cmic_led_port_order_remap_0_4[0]) >> 12) & 0x3f)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_REMAP_PORT_2f_SET(r,f) (r).cmic_led_port_order_remap_0_4[0]=(((r).cmic_led_port_order_remap_0_4[0] & ~((uint32_t)0x3f << 12)) | ((((uint32_t)f) & 0x3f) << 12))
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_REMAP_PORT_3f_GET(r) ((((r).cmic_led_port_order_remap_0_4[0]) >> 18) & 0x3f)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_REMAP_PORT_3f_SET(r,f) (r).cmic_led_port_order_remap_0_4[0]=(((r).cmic_led_port_order_remap_0_4[0] & ~((uint32_t)0x3f << 18)) | ((((uint32_t)f) & 0x3f) << 18))
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_REMAP_PORT_4f_GET(r) ((((r).cmic_led_port_order_remap_0_4[0]) >> 24) & 0x3f)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_REMAP_PORT_4f_SET(r,f) (r).cmic_led_port_order_remap_0_4[0]=(((r).cmic_led_port_order_remap_0_4[0] & ~((uint32_t)0x3f << 24)) | ((((uint32_t)f) & 0x3f) << 24))
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_RESERVED_0f_GET(r) ((((r).cmic_led_port_order_remap_0_4[0]) >> 30) & 0x3)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_RESERVED_0f_SET(r,f) (r).cmic_led_port_order_remap_0_4[0]=(((r).cmic_led_port_order_remap_0_4[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))

/*
 * These macros can be used to access CMIC_LED_PORT_ORDER_REMAP_0_4.
 *
 */
#define BCM56218_A0_READ_CMIC_LED_PORT_ORDER_REMAP_0_4r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r,r._cmic_led_port_order_remap_0_4)
#define BCM56218_A0_WRITE_CMIC_LED_PORT_ORDER_REMAP_0_4r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r,r._cmic_led_port_order_remap_0_4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_LED_PORT_ORDER_REMAP_0_4r BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r
#define CMIC_LED_PORT_ORDER_REMAP_0_4r_SIZE BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_SIZE
typedef BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_t CMIC_LED_PORT_ORDER_REMAP_0_4r_t;
#define CMIC_LED_PORT_ORDER_REMAP_0_4r_CLR BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_CLR
#define CMIC_LED_PORT_ORDER_REMAP_0_4r_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_SET
#define CMIC_LED_PORT_ORDER_REMAP_0_4r_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_GET
#define CMIC_LED_PORT_ORDER_REMAP_0_4r_REMAP_PORT_0f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_REMAP_PORT_0f_GET
#define CMIC_LED_PORT_ORDER_REMAP_0_4r_REMAP_PORT_0f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_REMAP_PORT_0f_SET
#define CMIC_LED_PORT_ORDER_REMAP_0_4r_REMAP_PORT_1f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_REMAP_PORT_1f_GET
#define CMIC_LED_PORT_ORDER_REMAP_0_4r_REMAP_PORT_1f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_REMAP_PORT_1f_SET
#define CMIC_LED_PORT_ORDER_REMAP_0_4r_REMAP_PORT_2f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_REMAP_PORT_2f_GET
#define CMIC_LED_PORT_ORDER_REMAP_0_4r_REMAP_PORT_2f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_REMAP_PORT_2f_SET
#define CMIC_LED_PORT_ORDER_REMAP_0_4r_REMAP_PORT_3f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_REMAP_PORT_3f_GET
#define CMIC_LED_PORT_ORDER_REMAP_0_4r_REMAP_PORT_3f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_REMAP_PORT_3f_SET
#define CMIC_LED_PORT_ORDER_REMAP_0_4r_REMAP_PORT_4f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_REMAP_PORT_4f_GET
#define CMIC_LED_PORT_ORDER_REMAP_0_4r_REMAP_PORT_4f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_REMAP_PORT_4f_SET
#define CMIC_LED_PORT_ORDER_REMAP_0_4r_RESERVED_0f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_RESERVED_0f_GET
#define CMIC_LED_PORT_ORDER_REMAP_0_4r_RESERVED_0f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_RESERVED_0f_SET
#define READ_CMIC_LED_PORT_ORDER_REMAP_0_4r BCM56218_A0_READ_CMIC_LED_PORT_ORDER_REMAP_0_4r
#define WRITE_CMIC_LED_PORT_ORDER_REMAP_0_4r BCM56218_A0_WRITE_CMIC_LED_PORT_ORDER_REMAP_0_4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_LED_PORT_ORDER_REMAP_10_14
 * BLOCKS:   CMIC
 * DESC:     LEDUP SCan Data Remap register for ports 10-14
 * SIZE:     32
 * FIELDS:
 *     REMAP_PORT_10    Remapping for Port 10
 *     REMAP_PORT_11    Remapping for Port 11
 *     REMAP_PORT_12    Remapping for Port 12
 *     REMAP_PORT_13    Remapping for Port 13
 *     REMAP_PORT_14    Remapping for Port 14
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r 0x00000d08

#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_LED_PORT_ORDER_REMAP_10_14.
 *
 */
typedef union BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_s {
	uint32_t v[1];
	uint32_t cmic_led_port_order_remap_10_14[1];
	uint32_t _cmic_led_port_order_remap_10_14;
} BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_t;

#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_CLR(r) (r).cmic_led_port_order_remap_10_14[0] = 0
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_SET(r,d) (r).cmic_led_port_order_remap_10_14[0] = d
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_GET(r) (r).cmic_led_port_order_remap_10_14[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_REMAP_PORT_10f_GET(r) (((r).cmic_led_port_order_remap_10_14[0]) & 0x3f)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_REMAP_PORT_10f_SET(r,f) (r).cmic_led_port_order_remap_10_14[0]=(((r).cmic_led_port_order_remap_10_14[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_REMAP_PORT_11f_GET(r) ((((r).cmic_led_port_order_remap_10_14[0]) >> 6) & 0x3f)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_REMAP_PORT_11f_SET(r,f) (r).cmic_led_port_order_remap_10_14[0]=(((r).cmic_led_port_order_remap_10_14[0] & ~((uint32_t)0x3f << 6)) | ((((uint32_t)f) & 0x3f) << 6))
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_REMAP_PORT_12f_GET(r) ((((r).cmic_led_port_order_remap_10_14[0]) >> 12) & 0x3f)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_REMAP_PORT_12f_SET(r,f) (r).cmic_led_port_order_remap_10_14[0]=(((r).cmic_led_port_order_remap_10_14[0] & ~((uint32_t)0x3f << 12)) | ((((uint32_t)f) & 0x3f) << 12))
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_REMAP_PORT_13f_GET(r) ((((r).cmic_led_port_order_remap_10_14[0]) >> 18) & 0x3f)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_REMAP_PORT_13f_SET(r,f) (r).cmic_led_port_order_remap_10_14[0]=(((r).cmic_led_port_order_remap_10_14[0] & ~((uint32_t)0x3f << 18)) | ((((uint32_t)f) & 0x3f) << 18))
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_REMAP_PORT_14f_GET(r) ((((r).cmic_led_port_order_remap_10_14[0]) >> 24) & 0x3f)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_REMAP_PORT_14f_SET(r,f) (r).cmic_led_port_order_remap_10_14[0]=(((r).cmic_led_port_order_remap_10_14[0] & ~((uint32_t)0x3f << 24)) | ((((uint32_t)f) & 0x3f) << 24))
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_RESERVED_0f_GET(r) ((((r).cmic_led_port_order_remap_10_14[0]) >> 30) & 0x3)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_RESERVED_0f_SET(r,f) (r).cmic_led_port_order_remap_10_14[0]=(((r).cmic_led_port_order_remap_10_14[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))

/*
 * These macros can be used to access CMIC_LED_PORT_ORDER_REMAP_10_14.
 *
 */
#define BCM56218_A0_READ_CMIC_LED_PORT_ORDER_REMAP_10_14r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r,r._cmic_led_port_order_remap_10_14)
#define BCM56218_A0_WRITE_CMIC_LED_PORT_ORDER_REMAP_10_14r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r,r._cmic_led_port_order_remap_10_14)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_LED_PORT_ORDER_REMAP_10_14r BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r
#define CMIC_LED_PORT_ORDER_REMAP_10_14r_SIZE BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_SIZE
typedef BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_t CMIC_LED_PORT_ORDER_REMAP_10_14r_t;
#define CMIC_LED_PORT_ORDER_REMAP_10_14r_CLR BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_CLR
#define CMIC_LED_PORT_ORDER_REMAP_10_14r_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_SET
#define CMIC_LED_PORT_ORDER_REMAP_10_14r_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_GET
#define CMIC_LED_PORT_ORDER_REMAP_10_14r_REMAP_PORT_10f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_REMAP_PORT_10f_GET
#define CMIC_LED_PORT_ORDER_REMAP_10_14r_REMAP_PORT_10f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_REMAP_PORT_10f_SET
#define CMIC_LED_PORT_ORDER_REMAP_10_14r_REMAP_PORT_11f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_REMAP_PORT_11f_GET
#define CMIC_LED_PORT_ORDER_REMAP_10_14r_REMAP_PORT_11f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_REMAP_PORT_11f_SET
#define CMIC_LED_PORT_ORDER_REMAP_10_14r_REMAP_PORT_12f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_REMAP_PORT_12f_GET
#define CMIC_LED_PORT_ORDER_REMAP_10_14r_REMAP_PORT_12f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_REMAP_PORT_12f_SET
#define CMIC_LED_PORT_ORDER_REMAP_10_14r_REMAP_PORT_13f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_REMAP_PORT_13f_GET
#define CMIC_LED_PORT_ORDER_REMAP_10_14r_REMAP_PORT_13f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_REMAP_PORT_13f_SET
#define CMIC_LED_PORT_ORDER_REMAP_10_14r_REMAP_PORT_14f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_REMAP_PORT_14f_GET
#define CMIC_LED_PORT_ORDER_REMAP_10_14r_REMAP_PORT_14f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_REMAP_PORT_14f_SET
#define CMIC_LED_PORT_ORDER_REMAP_10_14r_RESERVED_0f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_RESERVED_0f_GET
#define CMIC_LED_PORT_ORDER_REMAP_10_14r_RESERVED_0f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_RESERVED_0f_SET
#define READ_CMIC_LED_PORT_ORDER_REMAP_10_14r BCM56218_A0_READ_CMIC_LED_PORT_ORDER_REMAP_10_14r
#define WRITE_CMIC_LED_PORT_ORDER_REMAP_10_14r BCM56218_A0_WRITE_CMIC_LED_PORT_ORDER_REMAP_10_14r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_LED_PORT_ORDER_REMAP_15_19
 * BLOCKS:   CMIC
 * DESC:     LEDUP SCan Data Remap register for ports 15-19
 * SIZE:     32
 * FIELDS:
 *     REMAP_PORT_15    Remapping for Port 15
 *     REMAP_PORT_16    Remapping for Port 16
 *     REMAP_PORT_17    Remapping for Port 17
 *     REMAP_PORT_18    Remapping for Port 18
 *     REMAP_PORT_19    Remapping for Port 19
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r 0x00000d0c

#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_LED_PORT_ORDER_REMAP_15_19.
 *
 */
typedef union BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_s {
	uint32_t v[1];
	uint32_t cmic_led_port_order_remap_15_19[1];
	uint32_t _cmic_led_port_order_remap_15_19;
} BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_t;

#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_CLR(r) (r).cmic_led_port_order_remap_15_19[0] = 0
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_SET(r,d) (r).cmic_led_port_order_remap_15_19[0] = d
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_GET(r) (r).cmic_led_port_order_remap_15_19[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_REMAP_PORT_15f_GET(r) (((r).cmic_led_port_order_remap_15_19[0]) & 0x3f)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_REMAP_PORT_15f_SET(r,f) (r).cmic_led_port_order_remap_15_19[0]=(((r).cmic_led_port_order_remap_15_19[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_REMAP_PORT_16f_GET(r) ((((r).cmic_led_port_order_remap_15_19[0]) >> 6) & 0x3f)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_REMAP_PORT_16f_SET(r,f) (r).cmic_led_port_order_remap_15_19[0]=(((r).cmic_led_port_order_remap_15_19[0] & ~((uint32_t)0x3f << 6)) | ((((uint32_t)f) & 0x3f) << 6))
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_REMAP_PORT_17f_GET(r) ((((r).cmic_led_port_order_remap_15_19[0]) >> 12) & 0x3f)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_REMAP_PORT_17f_SET(r,f) (r).cmic_led_port_order_remap_15_19[0]=(((r).cmic_led_port_order_remap_15_19[0] & ~((uint32_t)0x3f << 12)) | ((((uint32_t)f) & 0x3f) << 12))
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_REMAP_PORT_18f_GET(r) ((((r).cmic_led_port_order_remap_15_19[0]) >> 18) & 0x3f)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_REMAP_PORT_18f_SET(r,f) (r).cmic_led_port_order_remap_15_19[0]=(((r).cmic_led_port_order_remap_15_19[0] & ~((uint32_t)0x3f << 18)) | ((((uint32_t)f) & 0x3f) << 18))
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_REMAP_PORT_19f_GET(r) ((((r).cmic_led_port_order_remap_15_19[0]) >> 24) & 0x3f)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_REMAP_PORT_19f_SET(r,f) (r).cmic_led_port_order_remap_15_19[0]=(((r).cmic_led_port_order_remap_15_19[0] & ~((uint32_t)0x3f << 24)) | ((((uint32_t)f) & 0x3f) << 24))
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_RESERVED_0f_GET(r) ((((r).cmic_led_port_order_remap_15_19[0]) >> 30) & 0x3)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_RESERVED_0f_SET(r,f) (r).cmic_led_port_order_remap_15_19[0]=(((r).cmic_led_port_order_remap_15_19[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))

/*
 * These macros can be used to access CMIC_LED_PORT_ORDER_REMAP_15_19.
 *
 */
#define BCM56218_A0_READ_CMIC_LED_PORT_ORDER_REMAP_15_19r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r,r._cmic_led_port_order_remap_15_19)
#define BCM56218_A0_WRITE_CMIC_LED_PORT_ORDER_REMAP_15_19r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r,r._cmic_led_port_order_remap_15_19)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_LED_PORT_ORDER_REMAP_15_19r BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r
#define CMIC_LED_PORT_ORDER_REMAP_15_19r_SIZE BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_SIZE
typedef BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_t CMIC_LED_PORT_ORDER_REMAP_15_19r_t;
#define CMIC_LED_PORT_ORDER_REMAP_15_19r_CLR BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_CLR
#define CMIC_LED_PORT_ORDER_REMAP_15_19r_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_SET
#define CMIC_LED_PORT_ORDER_REMAP_15_19r_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_GET
#define CMIC_LED_PORT_ORDER_REMAP_15_19r_REMAP_PORT_15f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_REMAP_PORT_15f_GET
#define CMIC_LED_PORT_ORDER_REMAP_15_19r_REMAP_PORT_15f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_REMAP_PORT_15f_SET
#define CMIC_LED_PORT_ORDER_REMAP_15_19r_REMAP_PORT_16f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_REMAP_PORT_16f_GET
#define CMIC_LED_PORT_ORDER_REMAP_15_19r_REMAP_PORT_16f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_REMAP_PORT_16f_SET
#define CMIC_LED_PORT_ORDER_REMAP_15_19r_REMAP_PORT_17f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_REMAP_PORT_17f_GET
#define CMIC_LED_PORT_ORDER_REMAP_15_19r_REMAP_PORT_17f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_REMAP_PORT_17f_SET
#define CMIC_LED_PORT_ORDER_REMAP_15_19r_REMAP_PORT_18f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_REMAP_PORT_18f_GET
#define CMIC_LED_PORT_ORDER_REMAP_15_19r_REMAP_PORT_18f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_REMAP_PORT_18f_SET
#define CMIC_LED_PORT_ORDER_REMAP_15_19r_REMAP_PORT_19f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_REMAP_PORT_19f_GET
#define CMIC_LED_PORT_ORDER_REMAP_15_19r_REMAP_PORT_19f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_REMAP_PORT_19f_SET
#define CMIC_LED_PORT_ORDER_REMAP_15_19r_RESERVED_0f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_RESERVED_0f_GET
#define CMIC_LED_PORT_ORDER_REMAP_15_19r_RESERVED_0f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_RESERVED_0f_SET
#define READ_CMIC_LED_PORT_ORDER_REMAP_15_19r BCM56218_A0_READ_CMIC_LED_PORT_ORDER_REMAP_15_19r
#define WRITE_CMIC_LED_PORT_ORDER_REMAP_15_19r BCM56218_A0_WRITE_CMIC_LED_PORT_ORDER_REMAP_15_19r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_LED_PORT_ORDER_REMAP_20_24
 * BLOCKS:   CMIC
 * DESC:     LEDUP SCan Data Remap register for ports 20-24
 * SIZE:     32
 * FIELDS:
 *     REMAP_PORT_20    Remapping for Port 20
 *     REMAP_PORT_21    Remapping for Port 21
 *     REMAP_PORT_22    Remapping for Port 22
 *     REMAP_PORT_23    Remapping for Port 23
 *     REMAP_PORT_24    Remapping for Port 24
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r 0x00000d10

#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_LED_PORT_ORDER_REMAP_20_24.
 *
 */
typedef union BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_s {
	uint32_t v[1];
	uint32_t cmic_led_port_order_remap_20_24[1];
	uint32_t _cmic_led_port_order_remap_20_24;
} BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_t;

#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_CLR(r) (r).cmic_led_port_order_remap_20_24[0] = 0
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_SET(r,d) (r).cmic_led_port_order_remap_20_24[0] = d
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_GET(r) (r).cmic_led_port_order_remap_20_24[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_REMAP_PORT_20f_GET(r) (((r).cmic_led_port_order_remap_20_24[0]) & 0x3f)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_REMAP_PORT_20f_SET(r,f) (r).cmic_led_port_order_remap_20_24[0]=(((r).cmic_led_port_order_remap_20_24[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_REMAP_PORT_21f_GET(r) ((((r).cmic_led_port_order_remap_20_24[0]) >> 6) & 0x3f)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_REMAP_PORT_21f_SET(r,f) (r).cmic_led_port_order_remap_20_24[0]=(((r).cmic_led_port_order_remap_20_24[0] & ~((uint32_t)0x3f << 6)) | ((((uint32_t)f) & 0x3f) << 6))
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_REMAP_PORT_22f_GET(r) ((((r).cmic_led_port_order_remap_20_24[0]) >> 12) & 0x3f)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_REMAP_PORT_22f_SET(r,f) (r).cmic_led_port_order_remap_20_24[0]=(((r).cmic_led_port_order_remap_20_24[0] & ~((uint32_t)0x3f << 12)) | ((((uint32_t)f) & 0x3f) << 12))
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_REMAP_PORT_23f_GET(r) ((((r).cmic_led_port_order_remap_20_24[0]) >> 18) & 0x3f)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_REMAP_PORT_23f_SET(r,f) (r).cmic_led_port_order_remap_20_24[0]=(((r).cmic_led_port_order_remap_20_24[0] & ~((uint32_t)0x3f << 18)) | ((((uint32_t)f) & 0x3f) << 18))
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_REMAP_PORT_24f_GET(r) ((((r).cmic_led_port_order_remap_20_24[0]) >> 24) & 0x3f)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_REMAP_PORT_24f_SET(r,f) (r).cmic_led_port_order_remap_20_24[0]=(((r).cmic_led_port_order_remap_20_24[0] & ~((uint32_t)0x3f << 24)) | ((((uint32_t)f) & 0x3f) << 24))
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_RESERVED_0f_GET(r) ((((r).cmic_led_port_order_remap_20_24[0]) >> 30) & 0x3)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_RESERVED_0f_SET(r,f) (r).cmic_led_port_order_remap_20_24[0]=(((r).cmic_led_port_order_remap_20_24[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))

/*
 * These macros can be used to access CMIC_LED_PORT_ORDER_REMAP_20_24.
 *
 */
#define BCM56218_A0_READ_CMIC_LED_PORT_ORDER_REMAP_20_24r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r,r._cmic_led_port_order_remap_20_24)
#define BCM56218_A0_WRITE_CMIC_LED_PORT_ORDER_REMAP_20_24r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r,r._cmic_led_port_order_remap_20_24)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_LED_PORT_ORDER_REMAP_20_24r BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r
#define CMIC_LED_PORT_ORDER_REMAP_20_24r_SIZE BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_SIZE
typedef BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_t CMIC_LED_PORT_ORDER_REMAP_20_24r_t;
#define CMIC_LED_PORT_ORDER_REMAP_20_24r_CLR BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_CLR
#define CMIC_LED_PORT_ORDER_REMAP_20_24r_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_SET
#define CMIC_LED_PORT_ORDER_REMAP_20_24r_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_GET
#define CMIC_LED_PORT_ORDER_REMAP_20_24r_REMAP_PORT_20f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_REMAP_PORT_20f_GET
#define CMIC_LED_PORT_ORDER_REMAP_20_24r_REMAP_PORT_20f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_REMAP_PORT_20f_SET
#define CMIC_LED_PORT_ORDER_REMAP_20_24r_REMAP_PORT_21f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_REMAP_PORT_21f_GET
#define CMIC_LED_PORT_ORDER_REMAP_20_24r_REMAP_PORT_21f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_REMAP_PORT_21f_SET
#define CMIC_LED_PORT_ORDER_REMAP_20_24r_REMAP_PORT_22f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_REMAP_PORT_22f_GET
#define CMIC_LED_PORT_ORDER_REMAP_20_24r_REMAP_PORT_22f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_REMAP_PORT_22f_SET
#define CMIC_LED_PORT_ORDER_REMAP_20_24r_REMAP_PORT_23f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_REMAP_PORT_23f_GET
#define CMIC_LED_PORT_ORDER_REMAP_20_24r_REMAP_PORT_23f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_REMAP_PORT_23f_SET
#define CMIC_LED_PORT_ORDER_REMAP_20_24r_REMAP_PORT_24f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_REMAP_PORT_24f_GET
#define CMIC_LED_PORT_ORDER_REMAP_20_24r_REMAP_PORT_24f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_REMAP_PORT_24f_SET
#define CMIC_LED_PORT_ORDER_REMAP_20_24r_RESERVED_0f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_RESERVED_0f_GET
#define CMIC_LED_PORT_ORDER_REMAP_20_24r_RESERVED_0f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_RESERVED_0f_SET
#define READ_CMIC_LED_PORT_ORDER_REMAP_20_24r BCM56218_A0_READ_CMIC_LED_PORT_ORDER_REMAP_20_24r
#define WRITE_CMIC_LED_PORT_ORDER_REMAP_20_24r BCM56218_A0_WRITE_CMIC_LED_PORT_ORDER_REMAP_20_24r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_LED_PORT_ORDER_REMAP_25_29
 * BLOCKS:   CMIC
 * DESC:     LEDUP SCan Data Remap register for ports 25-29
 * SIZE:     32
 * FIELDS:
 *     REMAP_PORT_25    Remapping for Port 25
 *     REMAP_PORT_26    Remapping for Port 26
 *     REMAP_PORT_27    Remapping for Port 27
 *     REMAP_PORT_28    Remapping for Port 28
 *     REMAP_PORT_29    Remapping for Port 29
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r 0x00000d14

#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_LED_PORT_ORDER_REMAP_25_29.
 *
 */
typedef union BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_s {
	uint32_t v[1];
	uint32_t cmic_led_port_order_remap_25_29[1];
	uint32_t _cmic_led_port_order_remap_25_29;
} BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_t;

#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_CLR(r) (r).cmic_led_port_order_remap_25_29[0] = 0
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_SET(r,d) (r).cmic_led_port_order_remap_25_29[0] = d
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_GET(r) (r).cmic_led_port_order_remap_25_29[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_REMAP_PORT_25f_GET(r) (((r).cmic_led_port_order_remap_25_29[0]) & 0x3f)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_REMAP_PORT_25f_SET(r,f) (r).cmic_led_port_order_remap_25_29[0]=(((r).cmic_led_port_order_remap_25_29[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_REMAP_PORT_26f_GET(r) ((((r).cmic_led_port_order_remap_25_29[0]) >> 6) & 0x3f)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_REMAP_PORT_26f_SET(r,f) (r).cmic_led_port_order_remap_25_29[0]=(((r).cmic_led_port_order_remap_25_29[0] & ~((uint32_t)0x3f << 6)) | ((((uint32_t)f) & 0x3f) << 6))
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_REMAP_PORT_27f_GET(r) ((((r).cmic_led_port_order_remap_25_29[0]) >> 12) & 0x3f)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_REMAP_PORT_27f_SET(r,f) (r).cmic_led_port_order_remap_25_29[0]=(((r).cmic_led_port_order_remap_25_29[0] & ~((uint32_t)0x3f << 12)) | ((((uint32_t)f) & 0x3f) << 12))
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_REMAP_PORT_28f_GET(r) ((((r).cmic_led_port_order_remap_25_29[0]) >> 18) & 0x3f)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_REMAP_PORT_28f_SET(r,f) (r).cmic_led_port_order_remap_25_29[0]=(((r).cmic_led_port_order_remap_25_29[0] & ~((uint32_t)0x3f << 18)) | ((((uint32_t)f) & 0x3f) << 18))
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_REMAP_PORT_29f_GET(r) ((((r).cmic_led_port_order_remap_25_29[0]) >> 24) & 0x3f)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_REMAP_PORT_29f_SET(r,f) (r).cmic_led_port_order_remap_25_29[0]=(((r).cmic_led_port_order_remap_25_29[0] & ~((uint32_t)0x3f << 24)) | ((((uint32_t)f) & 0x3f) << 24))
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_RESERVED_0f_GET(r) ((((r).cmic_led_port_order_remap_25_29[0]) >> 30) & 0x3)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_RESERVED_0f_SET(r,f) (r).cmic_led_port_order_remap_25_29[0]=(((r).cmic_led_port_order_remap_25_29[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))

/*
 * These macros can be used to access CMIC_LED_PORT_ORDER_REMAP_25_29.
 *
 */
#define BCM56218_A0_READ_CMIC_LED_PORT_ORDER_REMAP_25_29r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r,r._cmic_led_port_order_remap_25_29)
#define BCM56218_A0_WRITE_CMIC_LED_PORT_ORDER_REMAP_25_29r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r,r._cmic_led_port_order_remap_25_29)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_LED_PORT_ORDER_REMAP_25_29r BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r
#define CMIC_LED_PORT_ORDER_REMAP_25_29r_SIZE BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_SIZE
typedef BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_t CMIC_LED_PORT_ORDER_REMAP_25_29r_t;
#define CMIC_LED_PORT_ORDER_REMAP_25_29r_CLR BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_CLR
#define CMIC_LED_PORT_ORDER_REMAP_25_29r_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_SET
#define CMIC_LED_PORT_ORDER_REMAP_25_29r_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_GET
#define CMIC_LED_PORT_ORDER_REMAP_25_29r_REMAP_PORT_25f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_REMAP_PORT_25f_GET
#define CMIC_LED_PORT_ORDER_REMAP_25_29r_REMAP_PORT_25f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_REMAP_PORT_25f_SET
#define CMIC_LED_PORT_ORDER_REMAP_25_29r_REMAP_PORT_26f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_REMAP_PORT_26f_GET
#define CMIC_LED_PORT_ORDER_REMAP_25_29r_REMAP_PORT_26f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_REMAP_PORT_26f_SET
#define CMIC_LED_PORT_ORDER_REMAP_25_29r_REMAP_PORT_27f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_REMAP_PORT_27f_GET
#define CMIC_LED_PORT_ORDER_REMAP_25_29r_REMAP_PORT_27f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_REMAP_PORT_27f_SET
#define CMIC_LED_PORT_ORDER_REMAP_25_29r_REMAP_PORT_28f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_REMAP_PORT_28f_GET
#define CMIC_LED_PORT_ORDER_REMAP_25_29r_REMAP_PORT_28f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_REMAP_PORT_28f_SET
#define CMIC_LED_PORT_ORDER_REMAP_25_29r_REMAP_PORT_29f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_REMAP_PORT_29f_GET
#define CMIC_LED_PORT_ORDER_REMAP_25_29r_REMAP_PORT_29f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_REMAP_PORT_29f_SET
#define CMIC_LED_PORT_ORDER_REMAP_25_29r_RESERVED_0f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_RESERVED_0f_GET
#define CMIC_LED_PORT_ORDER_REMAP_25_29r_RESERVED_0f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_RESERVED_0f_SET
#define READ_CMIC_LED_PORT_ORDER_REMAP_25_29r BCM56218_A0_READ_CMIC_LED_PORT_ORDER_REMAP_25_29r
#define WRITE_CMIC_LED_PORT_ORDER_REMAP_25_29r BCM56218_A0_WRITE_CMIC_LED_PORT_ORDER_REMAP_25_29r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_LED_PORT_ORDER_REMAP_30_34
 * BLOCKS:   CMIC
 * DESC:     LEDUP SCan Data Remap register for ports 30-34
 * SIZE:     32
 * FIELDS:
 *     REMAP_PORT_30    Remapping for Port 30
 *     REMAP_PORT_31    Remapping for Port 31
 *     REMAP_PORT_32    Remapping for Port 32
 *     REMAP_PORT_33    Remapping for Port 33
 *     REMAP_PORT_34    Remapping for Port 34
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r 0x00000d18

#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_LED_PORT_ORDER_REMAP_30_34.
 *
 */
typedef union BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_s {
	uint32_t v[1];
	uint32_t cmic_led_port_order_remap_30_34[1];
	uint32_t _cmic_led_port_order_remap_30_34;
} BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_t;

#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_CLR(r) (r).cmic_led_port_order_remap_30_34[0] = 0
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_SET(r,d) (r).cmic_led_port_order_remap_30_34[0] = d
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_GET(r) (r).cmic_led_port_order_remap_30_34[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_REMAP_PORT_30f_GET(r) (((r).cmic_led_port_order_remap_30_34[0]) & 0x3f)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_REMAP_PORT_30f_SET(r,f) (r).cmic_led_port_order_remap_30_34[0]=(((r).cmic_led_port_order_remap_30_34[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_REMAP_PORT_31f_GET(r) ((((r).cmic_led_port_order_remap_30_34[0]) >> 6) & 0x3f)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_REMAP_PORT_31f_SET(r,f) (r).cmic_led_port_order_remap_30_34[0]=(((r).cmic_led_port_order_remap_30_34[0] & ~((uint32_t)0x3f << 6)) | ((((uint32_t)f) & 0x3f) << 6))
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_REMAP_PORT_32f_GET(r) ((((r).cmic_led_port_order_remap_30_34[0]) >> 12) & 0x3f)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_REMAP_PORT_32f_SET(r,f) (r).cmic_led_port_order_remap_30_34[0]=(((r).cmic_led_port_order_remap_30_34[0] & ~((uint32_t)0x3f << 12)) | ((((uint32_t)f) & 0x3f) << 12))
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_REMAP_PORT_33f_GET(r) ((((r).cmic_led_port_order_remap_30_34[0]) >> 18) & 0x3f)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_REMAP_PORT_33f_SET(r,f) (r).cmic_led_port_order_remap_30_34[0]=(((r).cmic_led_port_order_remap_30_34[0] & ~((uint32_t)0x3f << 18)) | ((((uint32_t)f) & 0x3f) << 18))
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_REMAP_PORT_34f_GET(r) ((((r).cmic_led_port_order_remap_30_34[0]) >> 24) & 0x3f)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_REMAP_PORT_34f_SET(r,f) (r).cmic_led_port_order_remap_30_34[0]=(((r).cmic_led_port_order_remap_30_34[0] & ~((uint32_t)0x3f << 24)) | ((((uint32_t)f) & 0x3f) << 24))
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_RESERVED_0f_GET(r) ((((r).cmic_led_port_order_remap_30_34[0]) >> 30) & 0x3)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_RESERVED_0f_SET(r,f) (r).cmic_led_port_order_remap_30_34[0]=(((r).cmic_led_port_order_remap_30_34[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))

/*
 * These macros can be used to access CMIC_LED_PORT_ORDER_REMAP_30_34.
 *
 */
#define BCM56218_A0_READ_CMIC_LED_PORT_ORDER_REMAP_30_34r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r,r._cmic_led_port_order_remap_30_34)
#define BCM56218_A0_WRITE_CMIC_LED_PORT_ORDER_REMAP_30_34r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r,r._cmic_led_port_order_remap_30_34)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_LED_PORT_ORDER_REMAP_30_34r BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r
#define CMIC_LED_PORT_ORDER_REMAP_30_34r_SIZE BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_SIZE
typedef BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_t CMIC_LED_PORT_ORDER_REMAP_30_34r_t;
#define CMIC_LED_PORT_ORDER_REMAP_30_34r_CLR BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_CLR
#define CMIC_LED_PORT_ORDER_REMAP_30_34r_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_SET
#define CMIC_LED_PORT_ORDER_REMAP_30_34r_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_GET
#define CMIC_LED_PORT_ORDER_REMAP_30_34r_REMAP_PORT_30f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_REMAP_PORT_30f_GET
#define CMIC_LED_PORT_ORDER_REMAP_30_34r_REMAP_PORT_30f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_REMAP_PORT_30f_SET
#define CMIC_LED_PORT_ORDER_REMAP_30_34r_REMAP_PORT_31f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_REMAP_PORT_31f_GET
#define CMIC_LED_PORT_ORDER_REMAP_30_34r_REMAP_PORT_31f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_REMAP_PORT_31f_SET
#define CMIC_LED_PORT_ORDER_REMAP_30_34r_REMAP_PORT_32f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_REMAP_PORT_32f_GET
#define CMIC_LED_PORT_ORDER_REMAP_30_34r_REMAP_PORT_32f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_REMAP_PORT_32f_SET
#define CMIC_LED_PORT_ORDER_REMAP_30_34r_REMAP_PORT_33f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_REMAP_PORT_33f_GET
#define CMIC_LED_PORT_ORDER_REMAP_30_34r_REMAP_PORT_33f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_REMAP_PORT_33f_SET
#define CMIC_LED_PORT_ORDER_REMAP_30_34r_REMAP_PORT_34f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_REMAP_PORT_34f_GET
#define CMIC_LED_PORT_ORDER_REMAP_30_34r_REMAP_PORT_34f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_REMAP_PORT_34f_SET
#define CMIC_LED_PORT_ORDER_REMAP_30_34r_RESERVED_0f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_RESERVED_0f_GET
#define CMIC_LED_PORT_ORDER_REMAP_30_34r_RESERVED_0f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_RESERVED_0f_SET
#define READ_CMIC_LED_PORT_ORDER_REMAP_30_34r BCM56218_A0_READ_CMIC_LED_PORT_ORDER_REMAP_30_34r
#define WRITE_CMIC_LED_PORT_ORDER_REMAP_30_34r BCM56218_A0_WRITE_CMIC_LED_PORT_ORDER_REMAP_30_34r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_LED_PORT_ORDER_REMAP_35_39
 * BLOCKS:   CMIC
 * DESC:     LEDUP SCan Data Remap register for ports 35-39
 * SIZE:     32
 * FIELDS:
 *     REMAP_PORT_35    Remapping for Port 35
 *     REMAP_PORT_36    Remapping for Port 36
 *     REMAP_PORT_37    Remapping for Port 37
 *     REMAP_PORT_38    Remapping for Port 38
 *     REMAP_PORT_39    Remapping for Port 39
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r 0x00000d1c

#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_LED_PORT_ORDER_REMAP_35_39.
 *
 */
typedef union BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_s {
	uint32_t v[1];
	uint32_t cmic_led_port_order_remap_35_39[1];
	uint32_t _cmic_led_port_order_remap_35_39;
} BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_t;

#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_CLR(r) (r).cmic_led_port_order_remap_35_39[0] = 0
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_SET(r,d) (r).cmic_led_port_order_remap_35_39[0] = d
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_GET(r) (r).cmic_led_port_order_remap_35_39[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_REMAP_PORT_35f_GET(r) (((r).cmic_led_port_order_remap_35_39[0]) & 0x3f)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_REMAP_PORT_35f_SET(r,f) (r).cmic_led_port_order_remap_35_39[0]=(((r).cmic_led_port_order_remap_35_39[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_REMAP_PORT_36f_GET(r) ((((r).cmic_led_port_order_remap_35_39[0]) >> 6) & 0x3f)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_REMAP_PORT_36f_SET(r,f) (r).cmic_led_port_order_remap_35_39[0]=(((r).cmic_led_port_order_remap_35_39[0] & ~((uint32_t)0x3f << 6)) | ((((uint32_t)f) & 0x3f) << 6))
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_REMAP_PORT_37f_GET(r) ((((r).cmic_led_port_order_remap_35_39[0]) >> 12) & 0x3f)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_REMAP_PORT_37f_SET(r,f) (r).cmic_led_port_order_remap_35_39[0]=(((r).cmic_led_port_order_remap_35_39[0] & ~((uint32_t)0x3f << 12)) | ((((uint32_t)f) & 0x3f) << 12))
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_REMAP_PORT_38f_GET(r) ((((r).cmic_led_port_order_remap_35_39[0]) >> 18) & 0x3f)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_REMAP_PORT_38f_SET(r,f) (r).cmic_led_port_order_remap_35_39[0]=(((r).cmic_led_port_order_remap_35_39[0] & ~((uint32_t)0x3f << 18)) | ((((uint32_t)f) & 0x3f) << 18))
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_REMAP_PORT_39f_GET(r) ((((r).cmic_led_port_order_remap_35_39[0]) >> 24) & 0x3f)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_REMAP_PORT_39f_SET(r,f) (r).cmic_led_port_order_remap_35_39[0]=(((r).cmic_led_port_order_remap_35_39[0] & ~((uint32_t)0x3f << 24)) | ((((uint32_t)f) & 0x3f) << 24))
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_RESERVED_0f_GET(r) ((((r).cmic_led_port_order_remap_35_39[0]) >> 30) & 0x3)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_RESERVED_0f_SET(r,f) (r).cmic_led_port_order_remap_35_39[0]=(((r).cmic_led_port_order_remap_35_39[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))

/*
 * These macros can be used to access CMIC_LED_PORT_ORDER_REMAP_35_39.
 *
 */
#define BCM56218_A0_READ_CMIC_LED_PORT_ORDER_REMAP_35_39r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r,r._cmic_led_port_order_remap_35_39)
#define BCM56218_A0_WRITE_CMIC_LED_PORT_ORDER_REMAP_35_39r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r,r._cmic_led_port_order_remap_35_39)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_LED_PORT_ORDER_REMAP_35_39r BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r
#define CMIC_LED_PORT_ORDER_REMAP_35_39r_SIZE BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_SIZE
typedef BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_t CMIC_LED_PORT_ORDER_REMAP_35_39r_t;
#define CMIC_LED_PORT_ORDER_REMAP_35_39r_CLR BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_CLR
#define CMIC_LED_PORT_ORDER_REMAP_35_39r_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_SET
#define CMIC_LED_PORT_ORDER_REMAP_35_39r_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_GET
#define CMIC_LED_PORT_ORDER_REMAP_35_39r_REMAP_PORT_35f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_REMAP_PORT_35f_GET
#define CMIC_LED_PORT_ORDER_REMAP_35_39r_REMAP_PORT_35f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_REMAP_PORT_35f_SET
#define CMIC_LED_PORT_ORDER_REMAP_35_39r_REMAP_PORT_36f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_REMAP_PORT_36f_GET
#define CMIC_LED_PORT_ORDER_REMAP_35_39r_REMAP_PORT_36f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_REMAP_PORT_36f_SET
#define CMIC_LED_PORT_ORDER_REMAP_35_39r_REMAP_PORT_37f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_REMAP_PORT_37f_GET
#define CMIC_LED_PORT_ORDER_REMAP_35_39r_REMAP_PORT_37f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_REMAP_PORT_37f_SET
#define CMIC_LED_PORT_ORDER_REMAP_35_39r_REMAP_PORT_38f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_REMAP_PORT_38f_GET
#define CMIC_LED_PORT_ORDER_REMAP_35_39r_REMAP_PORT_38f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_REMAP_PORT_38f_SET
#define CMIC_LED_PORT_ORDER_REMAP_35_39r_REMAP_PORT_39f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_REMAP_PORT_39f_GET
#define CMIC_LED_PORT_ORDER_REMAP_35_39r_REMAP_PORT_39f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_REMAP_PORT_39f_SET
#define CMIC_LED_PORT_ORDER_REMAP_35_39r_RESERVED_0f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_RESERVED_0f_GET
#define CMIC_LED_PORT_ORDER_REMAP_35_39r_RESERVED_0f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_RESERVED_0f_SET
#define READ_CMIC_LED_PORT_ORDER_REMAP_35_39r BCM56218_A0_READ_CMIC_LED_PORT_ORDER_REMAP_35_39r
#define WRITE_CMIC_LED_PORT_ORDER_REMAP_35_39r BCM56218_A0_WRITE_CMIC_LED_PORT_ORDER_REMAP_35_39r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_LED_PORT_ORDER_REMAP_40_44
 * BLOCKS:   CMIC
 * DESC:     LEDUP SCan Data Remap register for ports 40-44
 * SIZE:     32
 * FIELDS:
 *     REMAP_PORT_40    Remapping for Port 40
 *     REMAP_PORT_41    Remapping for Port 41
 *     REMAP_PORT_42    Remapping for Port 42
 *     REMAP_PORT_43    Remapping for Port 43
 *     REMAP_PORT_44    Remapping for Port 44
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r 0x00000d20

#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_LED_PORT_ORDER_REMAP_40_44.
 *
 */
typedef union BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_s {
	uint32_t v[1];
	uint32_t cmic_led_port_order_remap_40_44[1];
	uint32_t _cmic_led_port_order_remap_40_44;
} BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_t;

#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_CLR(r) (r).cmic_led_port_order_remap_40_44[0] = 0
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_SET(r,d) (r).cmic_led_port_order_remap_40_44[0] = d
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_GET(r) (r).cmic_led_port_order_remap_40_44[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_REMAP_PORT_40f_GET(r) (((r).cmic_led_port_order_remap_40_44[0]) & 0x3f)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_REMAP_PORT_40f_SET(r,f) (r).cmic_led_port_order_remap_40_44[0]=(((r).cmic_led_port_order_remap_40_44[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_REMAP_PORT_41f_GET(r) ((((r).cmic_led_port_order_remap_40_44[0]) >> 6) & 0x3f)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_REMAP_PORT_41f_SET(r,f) (r).cmic_led_port_order_remap_40_44[0]=(((r).cmic_led_port_order_remap_40_44[0] & ~((uint32_t)0x3f << 6)) | ((((uint32_t)f) & 0x3f) << 6))
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_REMAP_PORT_42f_GET(r) ((((r).cmic_led_port_order_remap_40_44[0]) >> 12) & 0x3f)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_REMAP_PORT_42f_SET(r,f) (r).cmic_led_port_order_remap_40_44[0]=(((r).cmic_led_port_order_remap_40_44[0] & ~((uint32_t)0x3f << 12)) | ((((uint32_t)f) & 0x3f) << 12))
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_REMAP_PORT_43f_GET(r) ((((r).cmic_led_port_order_remap_40_44[0]) >> 18) & 0x3f)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_REMAP_PORT_43f_SET(r,f) (r).cmic_led_port_order_remap_40_44[0]=(((r).cmic_led_port_order_remap_40_44[0] & ~((uint32_t)0x3f << 18)) | ((((uint32_t)f) & 0x3f) << 18))
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_REMAP_PORT_44f_GET(r) ((((r).cmic_led_port_order_remap_40_44[0]) >> 24) & 0x3f)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_REMAP_PORT_44f_SET(r,f) (r).cmic_led_port_order_remap_40_44[0]=(((r).cmic_led_port_order_remap_40_44[0] & ~((uint32_t)0x3f << 24)) | ((((uint32_t)f) & 0x3f) << 24))
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_RESERVED_0f_GET(r) ((((r).cmic_led_port_order_remap_40_44[0]) >> 30) & 0x3)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_RESERVED_0f_SET(r,f) (r).cmic_led_port_order_remap_40_44[0]=(((r).cmic_led_port_order_remap_40_44[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))

/*
 * These macros can be used to access CMIC_LED_PORT_ORDER_REMAP_40_44.
 *
 */
#define BCM56218_A0_READ_CMIC_LED_PORT_ORDER_REMAP_40_44r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r,r._cmic_led_port_order_remap_40_44)
#define BCM56218_A0_WRITE_CMIC_LED_PORT_ORDER_REMAP_40_44r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r,r._cmic_led_port_order_remap_40_44)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_LED_PORT_ORDER_REMAP_40_44r BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r
#define CMIC_LED_PORT_ORDER_REMAP_40_44r_SIZE BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_SIZE
typedef BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_t CMIC_LED_PORT_ORDER_REMAP_40_44r_t;
#define CMIC_LED_PORT_ORDER_REMAP_40_44r_CLR BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_CLR
#define CMIC_LED_PORT_ORDER_REMAP_40_44r_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_SET
#define CMIC_LED_PORT_ORDER_REMAP_40_44r_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_GET
#define CMIC_LED_PORT_ORDER_REMAP_40_44r_REMAP_PORT_40f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_REMAP_PORT_40f_GET
#define CMIC_LED_PORT_ORDER_REMAP_40_44r_REMAP_PORT_40f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_REMAP_PORT_40f_SET
#define CMIC_LED_PORT_ORDER_REMAP_40_44r_REMAP_PORT_41f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_REMAP_PORT_41f_GET
#define CMIC_LED_PORT_ORDER_REMAP_40_44r_REMAP_PORT_41f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_REMAP_PORT_41f_SET
#define CMIC_LED_PORT_ORDER_REMAP_40_44r_REMAP_PORT_42f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_REMAP_PORT_42f_GET
#define CMIC_LED_PORT_ORDER_REMAP_40_44r_REMAP_PORT_42f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_REMAP_PORT_42f_SET
#define CMIC_LED_PORT_ORDER_REMAP_40_44r_REMAP_PORT_43f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_REMAP_PORT_43f_GET
#define CMIC_LED_PORT_ORDER_REMAP_40_44r_REMAP_PORT_43f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_REMAP_PORT_43f_SET
#define CMIC_LED_PORT_ORDER_REMAP_40_44r_REMAP_PORT_44f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_REMAP_PORT_44f_GET
#define CMIC_LED_PORT_ORDER_REMAP_40_44r_REMAP_PORT_44f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_REMAP_PORT_44f_SET
#define CMIC_LED_PORT_ORDER_REMAP_40_44r_RESERVED_0f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_RESERVED_0f_GET
#define CMIC_LED_PORT_ORDER_REMAP_40_44r_RESERVED_0f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_RESERVED_0f_SET
#define READ_CMIC_LED_PORT_ORDER_REMAP_40_44r BCM56218_A0_READ_CMIC_LED_PORT_ORDER_REMAP_40_44r
#define WRITE_CMIC_LED_PORT_ORDER_REMAP_40_44r BCM56218_A0_WRITE_CMIC_LED_PORT_ORDER_REMAP_40_44r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_LED_PORT_ORDER_REMAP_45_49
 * BLOCKS:   CMIC
 * DESC:     LEDUP SCan Data Remap register for ports 45-49
 * SIZE:     32
 * FIELDS:
 *     REMAP_PORT_45    Remapping for Port 45
 *     REMAP_PORT_46    Remapping for Port 46
 *     REMAP_PORT_47    Remapping for Port 47
 *     REMAP_PORT_48    Remapping for Port 48
 *     REMAP_PORT_49    Remapping for Port 49
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r 0x00000d24

#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_LED_PORT_ORDER_REMAP_45_49.
 *
 */
typedef union BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_s {
	uint32_t v[1];
	uint32_t cmic_led_port_order_remap_45_49[1];
	uint32_t _cmic_led_port_order_remap_45_49;
} BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_t;

#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_CLR(r) (r).cmic_led_port_order_remap_45_49[0] = 0
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_SET(r,d) (r).cmic_led_port_order_remap_45_49[0] = d
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_GET(r) (r).cmic_led_port_order_remap_45_49[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_REMAP_PORT_45f_GET(r) (((r).cmic_led_port_order_remap_45_49[0]) & 0x3f)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_REMAP_PORT_45f_SET(r,f) (r).cmic_led_port_order_remap_45_49[0]=(((r).cmic_led_port_order_remap_45_49[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_REMAP_PORT_46f_GET(r) ((((r).cmic_led_port_order_remap_45_49[0]) >> 6) & 0x3f)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_REMAP_PORT_46f_SET(r,f) (r).cmic_led_port_order_remap_45_49[0]=(((r).cmic_led_port_order_remap_45_49[0] & ~((uint32_t)0x3f << 6)) | ((((uint32_t)f) & 0x3f) << 6))
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_REMAP_PORT_47f_GET(r) ((((r).cmic_led_port_order_remap_45_49[0]) >> 12) & 0x3f)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_REMAP_PORT_47f_SET(r,f) (r).cmic_led_port_order_remap_45_49[0]=(((r).cmic_led_port_order_remap_45_49[0] & ~((uint32_t)0x3f << 12)) | ((((uint32_t)f) & 0x3f) << 12))
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_REMAP_PORT_48f_GET(r) ((((r).cmic_led_port_order_remap_45_49[0]) >> 18) & 0x3f)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_REMAP_PORT_48f_SET(r,f) (r).cmic_led_port_order_remap_45_49[0]=(((r).cmic_led_port_order_remap_45_49[0] & ~((uint32_t)0x3f << 18)) | ((((uint32_t)f) & 0x3f) << 18))
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_REMAP_PORT_49f_GET(r) ((((r).cmic_led_port_order_remap_45_49[0]) >> 24) & 0x3f)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_REMAP_PORT_49f_SET(r,f) (r).cmic_led_port_order_remap_45_49[0]=(((r).cmic_led_port_order_remap_45_49[0] & ~((uint32_t)0x3f << 24)) | ((((uint32_t)f) & 0x3f) << 24))
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_RESERVED_0f_GET(r) ((((r).cmic_led_port_order_remap_45_49[0]) >> 30) & 0x3)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_RESERVED_0f_SET(r,f) (r).cmic_led_port_order_remap_45_49[0]=(((r).cmic_led_port_order_remap_45_49[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))

/*
 * These macros can be used to access CMIC_LED_PORT_ORDER_REMAP_45_49.
 *
 */
#define BCM56218_A0_READ_CMIC_LED_PORT_ORDER_REMAP_45_49r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r,r._cmic_led_port_order_remap_45_49)
#define BCM56218_A0_WRITE_CMIC_LED_PORT_ORDER_REMAP_45_49r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r,r._cmic_led_port_order_remap_45_49)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_LED_PORT_ORDER_REMAP_45_49r BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r
#define CMIC_LED_PORT_ORDER_REMAP_45_49r_SIZE BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_SIZE
typedef BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_t CMIC_LED_PORT_ORDER_REMAP_45_49r_t;
#define CMIC_LED_PORT_ORDER_REMAP_45_49r_CLR BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_CLR
#define CMIC_LED_PORT_ORDER_REMAP_45_49r_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_SET
#define CMIC_LED_PORT_ORDER_REMAP_45_49r_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_GET
#define CMIC_LED_PORT_ORDER_REMAP_45_49r_REMAP_PORT_45f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_REMAP_PORT_45f_GET
#define CMIC_LED_PORT_ORDER_REMAP_45_49r_REMAP_PORT_45f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_REMAP_PORT_45f_SET
#define CMIC_LED_PORT_ORDER_REMAP_45_49r_REMAP_PORT_46f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_REMAP_PORT_46f_GET
#define CMIC_LED_PORT_ORDER_REMAP_45_49r_REMAP_PORT_46f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_REMAP_PORT_46f_SET
#define CMIC_LED_PORT_ORDER_REMAP_45_49r_REMAP_PORT_47f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_REMAP_PORT_47f_GET
#define CMIC_LED_PORT_ORDER_REMAP_45_49r_REMAP_PORT_47f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_REMAP_PORT_47f_SET
#define CMIC_LED_PORT_ORDER_REMAP_45_49r_REMAP_PORT_48f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_REMAP_PORT_48f_GET
#define CMIC_LED_PORT_ORDER_REMAP_45_49r_REMAP_PORT_48f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_REMAP_PORT_48f_SET
#define CMIC_LED_PORT_ORDER_REMAP_45_49r_REMAP_PORT_49f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_REMAP_PORT_49f_GET
#define CMIC_LED_PORT_ORDER_REMAP_45_49r_REMAP_PORT_49f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_REMAP_PORT_49f_SET
#define CMIC_LED_PORT_ORDER_REMAP_45_49r_RESERVED_0f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_RESERVED_0f_GET
#define CMIC_LED_PORT_ORDER_REMAP_45_49r_RESERVED_0f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_RESERVED_0f_SET
#define READ_CMIC_LED_PORT_ORDER_REMAP_45_49r BCM56218_A0_READ_CMIC_LED_PORT_ORDER_REMAP_45_49r
#define WRITE_CMIC_LED_PORT_ORDER_REMAP_45_49r BCM56218_A0_WRITE_CMIC_LED_PORT_ORDER_REMAP_45_49r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_LED_PORT_ORDER_REMAP_50_54
 * BLOCKS:   CMIC
 * DESC:     LEDUP SCan Data Remap register for ports 50-54
 * SIZE:     32
 * FIELDS:
 *     REMAP_PORT_50    Remapping for Port 50
 *     REMAP_PORT_51    Remapping for Port 51
 *     REMAP_PORT_52    Remapping for Port 52
 *     REMAP_PORT_53    Remapping for Port 53
 *     REMAP_PORT_54    Remapping for Port 54
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r 0x00000d28

#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_LED_PORT_ORDER_REMAP_50_54.
 *
 */
typedef union BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_s {
	uint32_t v[1];
	uint32_t cmic_led_port_order_remap_50_54[1];
	uint32_t _cmic_led_port_order_remap_50_54;
} BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_t;

#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_CLR(r) (r).cmic_led_port_order_remap_50_54[0] = 0
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_SET(r,d) (r).cmic_led_port_order_remap_50_54[0] = d
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_GET(r) (r).cmic_led_port_order_remap_50_54[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_REMAP_PORT_50f_GET(r) (((r).cmic_led_port_order_remap_50_54[0]) & 0x3f)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_REMAP_PORT_50f_SET(r,f) (r).cmic_led_port_order_remap_50_54[0]=(((r).cmic_led_port_order_remap_50_54[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_REMAP_PORT_51f_GET(r) ((((r).cmic_led_port_order_remap_50_54[0]) >> 6) & 0x3f)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_REMAP_PORT_51f_SET(r,f) (r).cmic_led_port_order_remap_50_54[0]=(((r).cmic_led_port_order_remap_50_54[0] & ~((uint32_t)0x3f << 6)) | ((((uint32_t)f) & 0x3f) << 6))
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_REMAP_PORT_52f_GET(r) ((((r).cmic_led_port_order_remap_50_54[0]) >> 12) & 0x3f)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_REMAP_PORT_52f_SET(r,f) (r).cmic_led_port_order_remap_50_54[0]=(((r).cmic_led_port_order_remap_50_54[0] & ~((uint32_t)0x3f << 12)) | ((((uint32_t)f) & 0x3f) << 12))
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_REMAP_PORT_53f_GET(r) ((((r).cmic_led_port_order_remap_50_54[0]) >> 18) & 0x3f)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_REMAP_PORT_53f_SET(r,f) (r).cmic_led_port_order_remap_50_54[0]=(((r).cmic_led_port_order_remap_50_54[0] & ~((uint32_t)0x3f << 18)) | ((((uint32_t)f) & 0x3f) << 18))
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_REMAP_PORT_54f_GET(r) ((((r).cmic_led_port_order_remap_50_54[0]) >> 24) & 0x3f)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_REMAP_PORT_54f_SET(r,f) (r).cmic_led_port_order_remap_50_54[0]=(((r).cmic_led_port_order_remap_50_54[0] & ~((uint32_t)0x3f << 24)) | ((((uint32_t)f) & 0x3f) << 24))
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_RESERVED_0f_GET(r) ((((r).cmic_led_port_order_remap_50_54[0]) >> 30) & 0x3)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_RESERVED_0f_SET(r,f) (r).cmic_led_port_order_remap_50_54[0]=(((r).cmic_led_port_order_remap_50_54[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))

/*
 * These macros can be used to access CMIC_LED_PORT_ORDER_REMAP_50_54.
 *
 */
#define BCM56218_A0_READ_CMIC_LED_PORT_ORDER_REMAP_50_54r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r,r._cmic_led_port_order_remap_50_54)
#define BCM56218_A0_WRITE_CMIC_LED_PORT_ORDER_REMAP_50_54r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r,r._cmic_led_port_order_remap_50_54)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_LED_PORT_ORDER_REMAP_50_54r BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r
#define CMIC_LED_PORT_ORDER_REMAP_50_54r_SIZE BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_SIZE
typedef BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_t CMIC_LED_PORT_ORDER_REMAP_50_54r_t;
#define CMIC_LED_PORT_ORDER_REMAP_50_54r_CLR BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_CLR
#define CMIC_LED_PORT_ORDER_REMAP_50_54r_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_SET
#define CMIC_LED_PORT_ORDER_REMAP_50_54r_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_GET
#define CMIC_LED_PORT_ORDER_REMAP_50_54r_REMAP_PORT_50f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_REMAP_PORT_50f_GET
#define CMIC_LED_PORT_ORDER_REMAP_50_54r_REMAP_PORT_50f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_REMAP_PORT_50f_SET
#define CMIC_LED_PORT_ORDER_REMAP_50_54r_REMAP_PORT_51f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_REMAP_PORT_51f_GET
#define CMIC_LED_PORT_ORDER_REMAP_50_54r_REMAP_PORT_51f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_REMAP_PORT_51f_SET
#define CMIC_LED_PORT_ORDER_REMAP_50_54r_REMAP_PORT_52f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_REMAP_PORT_52f_GET
#define CMIC_LED_PORT_ORDER_REMAP_50_54r_REMAP_PORT_52f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_REMAP_PORT_52f_SET
#define CMIC_LED_PORT_ORDER_REMAP_50_54r_REMAP_PORT_53f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_REMAP_PORT_53f_GET
#define CMIC_LED_PORT_ORDER_REMAP_50_54r_REMAP_PORT_53f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_REMAP_PORT_53f_SET
#define CMIC_LED_PORT_ORDER_REMAP_50_54r_REMAP_PORT_54f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_REMAP_PORT_54f_GET
#define CMIC_LED_PORT_ORDER_REMAP_50_54r_REMAP_PORT_54f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_REMAP_PORT_54f_SET
#define CMIC_LED_PORT_ORDER_REMAP_50_54r_RESERVED_0f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_RESERVED_0f_GET
#define CMIC_LED_PORT_ORDER_REMAP_50_54r_RESERVED_0f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_RESERVED_0f_SET
#define READ_CMIC_LED_PORT_ORDER_REMAP_50_54r BCM56218_A0_READ_CMIC_LED_PORT_ORDER_REMAP_50_54r
#define WRITE_CMIC_LED_PORT_ORDER_REMAP_50_54r BCM56218_A0_WRITE_CMIC_LED_PORT_ORDER_REMAP_50_54r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_LED_PORT_ORDER_REMAP_5_9
 * BLOCKS:   CMIC
 * DESC:     LEDUP SCan Data Remap register for ports 5-9
 * SIZE:     32
 * FIELDS:
 *     REMAP_PORT_5     Remapping for Port 5
 *     REMAP_PORT_6     Remapping for Port 6
 *     REMAP_PORT_7     Remapping for Port 7
 *     REMAP_PORT_8     Remapping for Port 8
 *     REMAP_PORT_9     Remapping for Port 9
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r 0x00000d04

#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_LED_PORT_ORDER_REMAP_5_9.
 *
 */
typedef union BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_s {
	uint32_t v[1];
	uint32_t cmic_led_port_order_remap_5_9[1];
	uint32_t _cmic_led_port_order_remap_5_9;
} BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_t;

#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_CLR(r) (r).cmic_led_port_order_remap_5_9[0] = 0
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_SET(r,d) (r).cmic_led_port_order_remap_5_9[0] = d
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_GET(r) (r).cmic_led_port_order_remap_5_9[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_REMAP_PORT_5f_GET(r) (((r).cmic_led_port_order_remap_5_9[0]) & 0x3f)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_REMAP_PORT_5f_SET(r,f) (r).cmic_led_port_order_remap_5_9[0]=(((r).cmic_led_port_order_remap_5_9[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_REMAP_PORT_6f_GET(r) ((((r).cmic_led_port_order_remap_5_9[0]) >> 6) & 0x3f)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_REMAP_PORT_6f_SET(r,f) (r).cmic_led_port_order_remap_5_9[0]=(((r).cmic_led_port_order_remap_5_9[0] & ~((uint32_t)0x3f << 6)) | ((((uint32_t)f) & 0x3f) << 6))
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_REMAP_PORT_7f_GET(r) ((((r).cmic_led_port_order_remap_5_9[0]) >> 12) & 0x3f)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_REMAP_PORT_7f_SET(r,f) (r).cmic_led_port_order_remap_5_9[0]=(((r).cmic_led_port_order_remap_5_9[0] & ~((uint32_t)0x3f << 12)) | ((((uint32_t)f) & 0x3f) << 12))
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_REMAP_PORT_8f_GET(r) ((((r).cmic_led_port_order_remap_5_9[0]) >> 18) & 0x3f)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_REMAP_PORT_8f_SET(r,f) (r).cmic_led_port_order_remap_5_9[0]=(((r).cmic_led_port_order_remap_5_9[0] & ~((uint32_t)0x3f << 18)) | ((((uint32_t)f) & 0x3f) << 18))
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_REMAP_PORT_9f_GET(r) ((((r).cmic_led_port_order_remap_5_9[0]) >> 24) & 0x3f)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_REMAP_PORT_9f_SET(r,f) (r).cmic_led_port_order_remap_5_9[0]=(((r).cmic_led_port_order_remap_5_9[0] & ~((uint32_t)0x3f << 24)) | ((((uint32_t)f) & 0x3f) << 24))
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_RESERVED_0f_GET(r) ((((r).cmic_led_port_order_remap_5_9[0]) >> 30) & 0x3)
#define BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_RESERVED_0f_SET(r,f) (r).cmic_led_port_order_remap_5_9[0]=(((r).cmic_led_port_order_remap_5_9[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))

/*
 * These macros can be used to access CMIC_LED_PORT_ORDER_REMAP_5_9.
 *
 */
#define BCM56218_A0_READ_CMIC_LED_PORT_ORDER_REMAP_5_9r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r,r._cmic_led_port_order_remap_5_9)
#define BCM56218_A0_WRITE_CMIC_LED_PORT_ORDER_REMAP_5_9r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r,r._cmic_led_port_order_remap_5_9)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_LED_PORT_ORDER_REMAP_5_9r BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r
#define CMIC_LED_PORT_ORDER_REMAP_5_9r_SIZE BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_SIZE
typedef BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_t CMIC_LED_PORT_ORDER_REMAP_5_9r_t;
#define CMIC_LED_PORT_ORDER_REMAP_5_9r_CLR BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_CLR
#define CMIC_LED_PORT_ORDER_REMAP_5_9r_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_SET
#define CMIC_LED_PORT_ORDER_REMAP_5_9r_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_GET
#define CMIC_LED_PORT_ORDER_REMAP_5_9r_REMAP_PORT_5f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_REMAP_PORT_5f_GET
#define CMIC_LED_PORT_ORDER_REMAP_5_9r_REMAP_PORT_5f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_REMAP_PORT_5f_SET
#define CMIC_LED_PORT_ORDER_REMAP_5_9r_REMAP_PORT_6f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_REMAP_PORT_6f_GET
#define CMIC_LED_PORT_ORDER_REMAP_5_9r_REMAP_PORT_6f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_REMAP_PORT_6f_SET
#define CMIC_LED_PORT_ORDER_REMAP_5_9r_REMAP_PORT_7f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_REMAP_PORT_7f_GET
#define CMIC_LED_PORT_ORDER_REMAP_5_9r_REMAP_PORT_7f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_REMAP_PORT_7f_SET
#define CMIC_LED_PORT_ORDER_REMAP_5_9r_REMAP_PORT_8f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_REMAP_PORT_8f_GET
#define CMIC_LED_PORT_ORDER_REMAP_5_9r_REMAP_PORT_8f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_REMAP_PORT_8f_SET
#define CMIC_LED_PORT_ORDER_REMAP_5_9r_REMAP_PORT_9f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_REMAP_PORT_9f_GET
#define CMIC_LED_PORT_ORDER_REMAP_5_9r_REMAP_PORT_9f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_REMAP_PORT_9f_SET
#define CMIC_LED_PORT_ORDER_REMAP_5_9r_RESERVED_0f_GET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_RESERVED_0f_GET
#define CMIC_LED_PORT_ORDER_REMAP_5_9r_RESERVED_0f_SET BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_RESERVED_0f_SET
#define READ_CMIC_LED_PORT_ORDER_REMAP_5_9r BCM56218_A0_READ_CMIC_LED_PORT_ORDER_REMAP_5_9r
#define WRITE_CMIC_LED_PORT_ORDER_REMAP_5_9r BCM56218_A0_WRITE_CMIC_LED_PORT_ORDER_REMAP_5_9r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_LINK_STAT
 * BLOCKS:   CMIC
 * DESC:     Link Status Register
 * SIZE:     32
 * FIELDS:
 *     PORT_BITMAP      Link Up / Down Register
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_LINK_STATr 0x00000140

#define BCM56218_A0_CMIC_LINK_STATr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_LINK_STAT.
 *
 */
typedef union BCM56218_A0_CMIC_LINK_STATr_s {
	uint32_t v[1];
	uint32_t cmic_link_stat[1];
	uint32_t _cmic_link_stat;
} BCM56218_A0_CMIC_LINK_STATr_t;

#define BCM56218_A0_CMIC_LINK_STATr_CLR(r) (r).cmic_link_stat[0] = 0
#define BCM56218_A0_CMIC_LINK_STATr_SET(r,d) (r).cmic_link_stat[0] = d
#define BCM56218_A0_CMIC_LINK_STATr_GET(r) (r).cmic_link_stat[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_LINK_STATr_PORT_BITMAPf_GET(r) ((r).cmic_link_stat[0])
#define BCM56218_A0_CMIC_LINK_STATr_PORT_BITMAPf_SET(r,f) (r).cmic_link_stat[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_LINK_STAT.
 *
 */
#define BCM56218_A0_READ_CMIC_LINK_STATr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_LINK_STATr,r._cmic_link_stat)
#define BCM56218_A0_WRITE_CMIC_LINK_STATr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_LINK_STATr,r._cmic_link_stat)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_LINK_STATr BCM56218_A0_CMIC_LINK_STATr
#define CMIC_LINK_STATr_SIZE BCM56218_A0_CMIC_LINK_STATr_SIZE
typedef BCM56218_A0_CMIC_LINK_STATr_t CMIC_LINK_STATr_t;
#define CMIC_LINK_STATr_CLR BCM56218_A0_CMIC_LINK_STATr_CLR
#define CMIC_LINK_STATr_SET BCM56218_A0_CMIC_LINK_STATr_SET
#define CMIC_LINK_STATr_GET BCM56218_A0_CMIC_LINK_STATr_GET
#define CMIC_LINK_STATr_PORT_BITMAPf_GET BCM56218_A0_CMIC_LINK_STATr_PORT_BITMAPf_GET
#define CMIC_LINK_STATr_PORT_BITMAPf_SET BCM56218_A0_CMIC_LINK_STATr_PORT_BITMAPf_SET
#define READ_CMIC_LINK_STATr BCM56218_A0_READ_CMIC_LINK_STATr
#define WRITE_CMIC_LINK_STATr BCM56218_A0_WRITE_CMIC_LINK_STATr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_LINK_STATr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_LINK_STAT_HI
 * BLOCKS:   CMIC
 * DESC:     Link Status Register, upper 32-bits
 * SIZE:     32
 * FIELDS:
 *     PORT_BITMAP      Link Up / Down Register
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_LINK_STAT_HIr 0x00000700

#define BCM56218_A0_CMIC_LINK_STAT_HIr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_LINK_STAT_HI.
 *
 */
typedef union BCM56218_A0_CMIC_LINK_STAT_HIr_s {
	uint32_t v[1];
	uint32_t cmic_link_stat_hi[1];
	uint32_t _cmic_link_stat_hi;
} BCM56218_A0_CMIC_LINK_STAT_HIr_t;

#define BCM56218_A0_CMIC_LINK_STAT_HIr_CLR(r) (r).cmic_link_stat_hi[0] = 0
#define BCM56218_A0_CMIC_LINK_STAT_HIr_SET(r,d) (r).cmic_link_stat_hi[0] = d
#define BCM56218_A0_CMIC_LINK_STAT_HIr_GET(r) (r).cmic_link_stat_hi[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_LINK_STAT_HIr_PORT_BITMAPf_GET(r) ((r).cmic_link_stat_hi[0])
#define BCM56218_A0_CMIC_LINK_STAT_HIr_PORT_BITMAPf_SET(r,f) (r).cmic_link_stat_hi[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_LINK_STAT_HI.
 *
 */
#define BCM56218_A0_READ_CMIC_LINK_STAT_HIr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_LINK_STAT_HIr,r._cmic_link_stat_hi)
#define BCM56218_A0_WRITE_CMIC_LINK_STAT_HIr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_LINK_STAT_HIr,r._cmic_link_stat_hi)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_LINK_STAT_HIr BCM56218_A0_CMIC_LINK_STAT_HIr
#define CMIC_LINK_STAT_HIr_SIZE BCM56218_A0_CMIC_LINK_STAT_HIr_SIZE
typedef BCM56218_A0_CMIC_LINK_STAT_HIr_t CMIC_LINK_STAT_HIr_t;
#define CMIC_LINK_STAT_HIr_CLR BCM56218_A0_CMIC_LINK_STAT_HIr_CLR
#define CMIC_LINK_STAT_HIr_SET BCM56218_A0_CMIC_LINK_STAT_HIr_SET
#define CMIC_LINK_STAT_HIr_GET BCM56218_A0_CMIC_LINK_STAT_HIr_GET
#define CMIC_LINK_STAT_HIr_PORT_BITMAPf_GET BCM56218_A0_CMIC_LINK_STAT_HIr_PORT_BITMAPf_GET
#define CMIC_LINK_STAT_HIr_PORT_BITMAPf_SET BCM56218_A0_CMIC_LINK_STAT_HIr_PORT_BITMAPf_SET
#define READ_CMIC_LINK_STAT_HIr BCM56218_A0_READ_CMIC_LINK_STAT_HIr
#define WRITE_CMIC_LINK_STAT_HIr BCM56218_A0_WRITE_CMIC_LINK_STAT_HIr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_LINK_STAT_HIr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_MIIM_ADDRESS
 * BLOCKS:   CMIC
 * DESC:     Supplies the register address of MIIM reads and writes.
For clause 22 devices, bits [4:0] supply the REGAD.
For clause 45 devices, bits [20:16] supply the DTYPE,
                   and bits [15: 0] supply the reg address

 * SIZE:     32
 * FIELDS:
 *     CLAUSE_45_REGADR Register address for associated read or write
 *     CLAUSE_22_REGADR Register address for associated read or write
 *     CLAUSE_45_DTYPE  Block-within-PHY address for associated read or write
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_MIIM_ADDRESSr 0x000004a0

#define BCM56218_A0_CMIC_MIIM_ADDRESSr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_ADDRESS.
 *
 */
typedef union BCM56218_A0_CMIC_MIIM_ADDRESSr_s {
	uint32_t v[1];
	uint32_t cmic_miim_address[1];
	uint32_t _cmic_miim_address;
} BCM56218_A0_CMIC_MIIM_ADDRESSr_t;

#define BCM56218_A0_CMIC_MIIM_ADDRESSr_CLR(r) (r).cmic_miim_address[0] = 0
#define BCM56218_A0_CMIC_MIIM_ADDRESSr_SET(r,d) (r).cmic_miim_address[0] = d
#define BCM56218_A0_CMIC_MIIM_ADDRESSr_GET(r) (r).cmic_miim_address[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_MIIM_ADDRESSr_CLAUSE_45_REGADRf_GET(r) (((r).cmic_miim_address[0]) & 0xffff)
#define BCM56218_A0_CMIC_MIIM_ADDRESSr_CLAUSE_45_REGADRf_SET(r,f) (r).cmic_miim_address[0]=(((r).cmic_miim_address[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56218_A0_CMIC_MIIM_ADDRESSr_CLAUSE_22_REGADRf_GET(r) (((r).cmic_miim_address[0]) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_ADDRESSr_CLAUSE_22_REGADRf_SET(r,f) (r).cmic_miim_address[0]=(((r).cmic_miim_address[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56218_A0_CMIC_MIIM_ADDRESSr_CLAUSE_45_DTYPEf_GET(r) ((((r).cmic_miim_address[0]) >> 16) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_ADDRESSr_CLAUSE_45_DTYPEf_SET(r,f) (r).cmic_miim_address[0]=(((r).cmic_miim_address[0] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define BCM56218_A0_CMIC_MIIM_ADDRESSr_RESERVED_1f_GET(r) ((((r).cmic_miim_address[0]) >> 21) & 0x7ff)
#define BCM56218_A0_CMIC_MIIM_ADDRESSr_RESERVED_1f_SET(r,f) (r).cmic_miim_address[0]=(((r).cmic_miim_address[0] & ~((uint32_t)0x7ff << 21)) | ((((uint32_t)f) & 0x7ff) << 21))

/*
 * These macros can be used to access CMIC_MIIM_ADDRESS.
 *
 */
#define BCM56218_A0_READ_CMIC_MIIM_ADDRESSr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_MIIM_ADDRESSr,r._cmic_miim_address)
#define BCM56218_A0_WRITE_CMIC_MIIM_ADDRESSr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_MIIM_ADDRESSr,r._cmic_miim_address)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_ADDRESSr BCM56218_A0_CMIC_MIIM_ADDRESSr
#define CMIC_MIIM_ADDRESSr_SIZE BCM56218_A0_CMIC_MIIM_ADDRESSr_SIZE
typedef BCM56218_A0_CMIC_MIIM_ADDRESSr_t CMIC_MIIM_ADDRESSr_t;
#define CMIC_MIIM_ADDRESSr_CLR BCM56218_A0_CMIC_MIIM_ADDRESSr_CLR
#define CMIC_MIIM_ADDRESSr_SET BCM56218_A0_CMIC_MIIM_ADDRESSr_SET
#define CMIC_MIIM_ADDRESSr_GET BCM56218_A0_CMIC_MIIM_ADDRESSr_GET
#define CMIC_MIIM_ADDRESSr_CLAUSE_45_REGADRf_GET BCM56218_A0_CMIC_MIIM_ADDRESSr_CLAUSE_45_REGADRf_GET
#define CMIC_MIIM_ADDRESSr_CLAUSE_45_REGADRf_SET BCM56218_A0_CMIC_MIIM_ADDRESSr_CLAUSE_45_REGADRf_SET
#define CMIC_MIIM_ADDRESSr_CLAUSE_22_REGADRf_GET BCM56218_A0_CMIC_MIIM_ADDRESSr_CLAUSE_22_REGADRf_GET
#define CMIC_MIIM_ADDRESSr_CLAUSE_22_REGADRf_SET BCM56218_A0_CMIC_MIIM_ADDRESSr_CLAUSE_22_REGADRf_SET
#define CMIC_MIIM_ADDRESSr_CLAUSE_45_DTYPEf_GET BCM56218_A0_CMIC_MIIM_ADDRESSr_CLAUSE_45_DTYPEf_GET
#define CMIC_MIIM_ADDRESSr_CLAUSE_45_DTYPEf_SET BCM56218_A0_CMIC_MIIM_ADDRESSr_CLAUSE_45_DTYPEf_SET
#define CMIC_MIIM_ADDRESSr_RESERVED_1f_GET BCM56218_A0_CMIC_MIIM_ADDRESSr_RESERVED_1f_GET
#define CMIC_MIIM_ADDRESSr_RESERVED_1f_SET BCM56218_A0_CMIC_MIIM_ADDRESSr_RESERVED_1f_SET
#define READ_CMIC_MIIM_ADDRESSr BCM56218_A0_READ_CMIC_MIIM_ADDRESSr
#define WRITE_CMIC_MIIM_ADDRESSr BCM56218_A0_WRITE_CMIC_MIIM_ADDRESSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_MIIM_ADDRESSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8
 * BLOCKS:   CMIC
 * DESC:     MIIM Phy Address map, Port 11:8
 * SIZE:     32
 * FIELDS:
 *     PHY_ID_8         Phy ID of external phy for Port 8
 *     PHY_ID_9         Phy ID of external phy for Port 9
 *     PHY_ID_10        Phy ID of external phy for Port 10
 *     PHY_ID_11        Phy ID of external phy for Port 11
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r 0x000004c8

#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8.
 *
 */
typedef union BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_s {
	uint32_t v[1];
	uint32_t cmic_miim_ext_phy_addr_map_11_8[1];
	uint32_t _cmic_miim_ext_phy_addr_map_11_8;
} BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_t;

#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_CLR(r) (r).cmic_miim_ext_phy_addr_map_11_8[0] = 0
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_SET(r,d) (r).cmic_miim_ext_phy_addr_map_11_8[0] = d
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_GET(r) (r).cmic_miim_ext_phy_addr_map_11_8[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_8f_GET(r) (((r).cmic_miim_ext_phy_addr_map_11_8[0]) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_8f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_11_8[0]=(((r).cmic_miim_ext_phy_addr_map_11_8[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_9f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_11_8[0]) >> 8) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_9f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_11_8[0]=(((r).cmic_miim_ext_phy_addr_map_11_8[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_10f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_11_8[0]) >> 16) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_10f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_11_8[0]=(((r).cmic_miim_ext_phy_addr_map_11_8[0] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_11f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_11_8[0]) >> 24) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_11f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_11_8[0]=(((r).cmic_miim_ext_phy_addr_map_11_8[0] & ~((uint32_t)0x1f << 24)) | ((((uint32_t)f) & 0x1f) << 24))

/*
 * These macros can be used to access CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8.
 *
 */
#define BCM56218_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r,r._cmic_miim_ext_phy_addr_map_11_8)
#define BCM56218_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r,r._cmic_miim_ext_phy_addr_map_11_8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_SIZE BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_SIZE
typedef BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_t CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_t;
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_CLR BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_CLR
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_8f_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_8f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_8f_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_8f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_9f_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_9f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_9f_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_9f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_10f_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_10f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_10f_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_10f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_11f_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_11f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_11f_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_11f_SET
#define READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r BCM56218_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r
#define WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r BCM56218_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12
 * BLOCKS:   CMIC
 * DESC:     MIIM Phy Address map, Port 15:12
 * SIZE:     32
 * FIELDS:
 *     PHY_ID_12        Phy ID of external phy for Port 12
 *     PHY_ID_13        Phy ID of external phy for Port 13
 *     PHY_ID_14        Phy ID of external phy for Port 14
 *     PHY_ID_15        Phy ID of external phy for Port 15
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r 0x000004cc

#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12.
 *
 */
typedef union BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_s {
	uint32_t v[1];
	uint32_t cmic_miim_ext_phy_addr_map_15_12[1];
	uint32_t _cmic_miim_ext_phy_addr_map_15_12;
} BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_t;

#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_CLR(r) (r).cmic_miim_ext_phy_addr_map_15_12[0] = 0
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_SET(r,d) (r).cmic_miim_ext_phy_addr_map_15_12[0] = d
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_GET(r) (r).cmic_miim_ext_phy_addr_map_15_12[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_12f_GET(r) (((r).cmic_miim_ext_phy_addr_map_15_12[0]) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_12f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_15_12[0]=(((r).cmic_miim_ext_phy_addr_map_15_12[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_13f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_15_12[0]) >> 8) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_13f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_15_12[0]=(((r).cmic_miim_ext_phy_addr_map_15_12[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_14f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_15_12[0]) >> 16) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_14f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_15_12[0]=(((r).cmic_miim_ext_phy_addr_map_15_12[0] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_15f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_15_12[0]) >> 24) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_15f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_15_12[0]=(((r).cmic_miim_ext_phy_addr_map_15_12[0] & ~((uint32_t)0x1f << 24)) | ((((uint32_t)f) & 0x1f) << 24))

/*
 * These macros can be used to access CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12.
 *
 */
#define BCM56218_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r,r._cmic_miim_ext_phy_addr_map_15_12)
#define BCM56218_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r,r._cmic_miim_ext_phy_addr_map_15_12)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_SIZE BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_SIZE
typedef BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_t CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_t;
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_CLR BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_CLR
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_12f_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_12f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_12f_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_12f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_13f_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_13f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_13f_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_13f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_14f_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_14f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_14f_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_14f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_15f_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_15f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_15f_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_15f_SET
#define READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r BCM56218_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r
#define WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r BCM56218_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16
 * BLOCKS:   CMIC
 * DESC:     MIIM Phy Address map, Port 19:16
 * SIZE:     32
 * FIELDS:
 *     PHY_ID_16        Phy ID of external phy for Port 16
 *     PHY_ID_17        Phy ID of external phy for Port 17
 *     PHY_ID_18        Phy ID of external phy for Port 18
 *     PHY_ID_19        Phy ID of external phy for Port 19
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r 0x000004d0

#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16.
 *
 */
typedef union BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_s {
	uint32_t v[1];
	uint32_t cmic_miim_ext_phy_addr_map_19_16[1];
	uint32_t _cmic_miim_ext_phy_addr_map_19_16;
} BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_t;

#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_CLR(r) (r).cmic_miim_ext_phy_addr_map_19_16[0] = 0
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_SET(r,d) (r).cmic_miim_ext_phy_addr_map_19_16[0] = d
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_GET(r) (r).cmic_miim_ext_phy_addr_map_19_16[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_16f_GET(r) (((r).cmic_miim_ext_phy_addr_map_19_16[0]) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_16f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_19_16[0]=(((r).cmic_miim_ext_phy_addr_map_19_16[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_17f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_19_16[0]) >> 8) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_17f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_19_16[0]=(((r).cmic_miim_ext_phy_addr_map_19_16[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_18f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_19_16[0]) >> 16) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_18f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_19_16[0]=(((r).cmic_miim_ext_phy_addr_map_19_16[0] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_19f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_19_16[0]) >> 24) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_19f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_19_16[0]=(((r).cmic_miim_ext_phy_addr_map_19_16[0] & ~((uint32_t)0x1f << 24)) | ((((uint32_t)f) & 0x1f) << 24))

/*
 * These macros can be used to access CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16.
 *
 */
#define BCM56218_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r,r._cmic_miim_ext_phy_addr_map_19_16)
#define BCM56218_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r,r._cmic_miim_ext_phy_addr_map_19_16)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_SIZE BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_SIZE
typedef BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_t CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_t;
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_CLR BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_CLR
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_16f_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_16f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_16f_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_16f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_17f_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_17f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_17f_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_17f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_18f_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_18f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_18f_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_18f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_19f_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_19f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_19f_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_19f_SET
#define READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r BCM56218_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r
#define WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r BCM56218_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20
 * BLOCKS:   CMIC
 * DESC:     MIIM Phy Address map, Port 23:20
 * SIZE:     32
 * FIELDS:
 *     PHY_ID_20        Phy ID of external phy for Port 20
 *     PHY_ID_21        Phy ID of external phy for Port 21
 *     PHY_ID_22        Phy ID of external phy for Port 22
 *     PHY_ID_23        Phy ID of external phy for Port 23
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r 0x000004d4

#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20.
 *
 */
typedef union BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_s {
	uint32_t v[1];
	uint32_t cmic_miim_ext_phy_addr_map_23_20[1];
	uint32_t _cmic_miim_ext_phy_addr_map_23_20;
} BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_t;

#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_CLR(r) (r).cmic_miim_ext_phy_addr_map_23_20[0] = 0
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_SET(r,d) (r).cmic_miim_ext_phy_addr_map_23_20[0] = d
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_GET(r) (r).cmic_miim_ext_phy_addr_map_23_20[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_20f_GET(r) (((r).cmic_miim_ext_phy_addr_map_23_20[0]) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_20f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_23_20[0]=(((r).cmic_miim_ext_phy_addr_map_23_20[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_21f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_23_20[0]) >> 8) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_21f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_23_20[0]=(((r).cmic_miim_ext_phy_addr_map_23_20[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_22f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_23_20[0]) >> 16) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_22f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_23_20[0]=(((r).cmic_miim_ext_phy_addr_map_23_20[0] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_23f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_23_20[0]) >> 24) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_23f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_23_20[0]=(((r).cmic_miim_ext_phy_addr_map_23_20[0] & ~((uint32_t)0x1f << 24)) | ((((uint32_t)f) & 0x1f) << 24))

/*
 * These macros can be used to access CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20.
 *
 */
#define BCM56218_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r,r._cmic_miim_ext_phy_addr_map_23_20)
#define BCM56218_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r,r._cmic_miim_ext_phy_addr_map_23_20)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_SIZE BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_SIZE
typedef BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_t CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_t;
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_CLR BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_CLR
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_20f_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_20f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_20f_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_20f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_21f_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_21f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_21f_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_21f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_22f_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_22f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_22f_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_22f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_23f_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_23f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_23f_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_23f_SET
#define READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r BCM56218_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r
#define WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r BCM56218_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24
 * BLOCKS:   CMIC
 * DESC:     MIIM Phy Address map, Port 27:24
 * SIZE:     32
 * FIELDS:
 *     PHY_ID_24        Phy ID of external phy for Port 24
 *     PHY_ID_25        Phy ID of external phy for Port 25
 *     PHY_ID_26        Phy ID of external phy for Port 26
 *     PHY_ID_27        Phy ID of external phy for Port 27
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r 0x000004d8

#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24.
 *
 */
typedef union BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_s {
	uint32_t v[1];
	uint32_t cmic_miim_ext_phy_addr_map_27_24[1];
	uint32_t _cmic_miim_ext_phy_addr_map_27_24;
} BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_t;

#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_CLR(r) (r).cmic_miim_ext_phy_addr_map_27_24[0] = 0
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_SET(r,d) (r).cmic_miim_ext_phy_addr_map_27_24[0] = d
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_GET(r) (r).cmic_miim_ext_phy_addr_map_27_24[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_24f_GET(r) (((r).cmic_miim_ext_phy_addr_map_27_24[0]) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_24f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_27_24[0]=(((r).cmic_miim_ext_phy_addr_map_27_24[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_25f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_27_24[0]) >> 8) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_25f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_27_24[0]=(((r).cmic_miim_ext_phy_addr_map_27_24[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_26f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_27_24[0]) >> 16) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_26f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_27_24[0]=(((r).cmic_miim_ext_phy_addr_map_27_24[0] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_27f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_27_24[0]) >> 24) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_27f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_27_24[0]=(((r).cmic_miim_ext_phy_addr_map_27_24[0] & ~((uint32_t)0x1f << 24)) | ((((uint32_t)f) & 0x1f) << 24))

/*
 * These macros can be used to access CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24.
 *
 */
#define BCM56218_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r,r._cmic_miim_ext_phy_addr_map_27_24)
#define BCM56218_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r,r._cmic_miim_ext_phy_addr_map_27_24)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_SIZE BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_SIZE
typedef BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_t CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_t;
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_CLR BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_CLR
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_24f_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_24f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_24f_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_24f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_25f_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_25f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_25f_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_25f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_26f_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_26f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_26f_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_26f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_27f_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_27f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_27f_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_27f_SET
#define READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r BCM56218_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r
#define WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r BCM56218_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28
 * BLOCKS:   CMIC
 * DESC:     MIIM Phy Address map, Port 31:28
 * SIZE:     32
 * FIELDS:
 *     PHY_ID_28        Phy ID of external phy for Port 28
 *     PHY_ID_29        Phy ID of external phy for Port 29
 *     PHY_ID_30        Phy ID of external phy for Port 30
 *     PHY_ID_31        Phy ID of external phy for Port 31
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r 0x000004dc

#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28.
 *
 */
typedef union BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_s {
	uint32_t v[1];
	uint32_t cmic_miim_ext_phy_addr_map_31_28[1];
	uint32_t _cmic_miim_ext_phy_addr_map_31_28;
} BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_t;

#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_CLR(r) (r).cmic_miim_ext_phy_addr_map_31_28[0] = 0
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_SET(r,d) (r).cmic_miim_ext_phy_addr_map_31_28[0] = d
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_GET(r) (r).cmic_miim_ext_phy_addr_map_31_28[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_28f_GET(r) (((r).cmic_miim_ext_phy_addr_map_31_28[0]) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_28f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_31_28[0]=(((r).cmic_miim_ext_phy_addr_map_31_28[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_29f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_31_28[0]) >> 8) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_29f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_31_28[0]=(((r).cmic_miim_ext_phy_addr_map_31_28[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_30f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_31_28[0]) >> 16) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_30f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_31_28[0]=(((r).cmic_miim_ext_phy_addr_map_31_28[0] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_31f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_31_28[0]) >> 24) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_31f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_31_28[0]=(((r).cmic_miim_ext_phy_addr_map_31_28[0] & ~((uint32_t)0x1f << 24)) | ((((uint32_t)f) & 0x1f) << 24))

/*
 * These macros can be used to access CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28.
 *
 */
#define BCM56218_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r,r._cmic_miim_ext_phy_addr_map_31_28)
#define BCM56218_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r,r._cmic_miim_ext_phy_addr_map_31_28)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_SIZE BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_SIZE
typedef BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_t CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_t;
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_CLR BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_CLR
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_28f_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_28f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_28f_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_28f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_29f_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_29f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_29f_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_29f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_30f_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_30f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_30f_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_30f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_31f_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_31f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_31f_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_31f_SET
#define READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r BCM56218_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r
#define WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r BCM56218_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_MIIM_EXT_PHY_ADDR_MAP_35_32
 * BLOCKS:   CMIC
 * DESC:     MIIM Phy Address map, Port 35:32
 * SIZE:     32
 * FIELDS:
 *     PHY_ID_32        Phy ID of external phy for Port 32
 *     PHY_ID_33        Phy ID of external phy for Port 33
 *     PHY_ID_34        Phy ID of external phy for Port 34
 *     PHY_ID_35        Phy ID of external phy for Port 35
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_35_32r 0x000004e0

#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_35_32r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_EXT_PHY_ADDR_MAP_35_32.
 *
 */
typedef union BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_35_32r_s {
	uint32_t v[1];
	uint32_t cmic_miim_ext_phy_addr_map_35_32[1];
	uint32_t _cmic_miim_ext_phy_addr_map_35_32;
} BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_35_32r_t;

#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_35_32r_CLR(r) (r).cmic_miim_ext_phy_addr_map_35_32[0] = 0
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_35_32r_SET(r,d) (r).cmic_miim_ext_phy_addr_map_35_32[0] = d
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_35_32r_GET(r) (r).cmic_miim_ext_phy_addr_map_35_32[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_35_32r_PHY_ID_32f_GET(r) (((r).cmic_miim_ext_phy_addr_map_35_32[0]) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_35_32r_PHY_ID_32f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_35_32[0]=(((r).cmic_miim_ext_phy_addr_map_35_32[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_35_32r_PHY_ID_33f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_35_32[0]) >> 8) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_35_32r_PHY_ID_33f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_35_32[0]=(((r).cmic_miim_ext_phy_addr_map_35_32[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_35_32r_PHY_ID_34f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_35_32[0]) >> 16) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_35_32r_PHY_ID_34f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_35_32[0]=(((r).cmic_miim_ext_phy_addr_map_35_32[0] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_35_32r_PHY_ID_35f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_35_32[0]) >> 24) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_35_32r_PHY_ID_35f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_35_32[0]=(((r).cmic_miim_ext_phy_addr_map_35_32[0] & ~((uint32_t)0x1f << 24)) | ((((uint32_t)f) & 0x1f) << 24))

/*
 * These macros can be used to access CMIC_MIIM_EXT_PHY_ADDR_MAP_35_32.
 *
 */
#define BCM56218_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_35_32r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_35_32r,r._cmic_miim_ext_phy_addr_map_35_32)
#define BCM56218_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_35_32r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_35_32r,r._cmic_miim_ext_phy_addr_map_35_32)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_EXT_PHY_ADDR_MAP_35_32r BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_35_32r
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_35_32r_SIZE BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_35_32r_SIZE
typedef BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_35_32r_t CMIC_MIIM_EXT_PHY_ADDR_MAP_35_32r_t;
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_35_32r_CLR BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_35_32r_CLR
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_35_32r_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_35_32r_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_35_32r_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_35_32r_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_35_32r_PHY_ID_32f_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_35_32r_PHY_ID_32f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_35_32r_PHY_ID_32f_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_35_32r_PHY_ID_32f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_35_32r_PHY_ID_33f_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_35_32r_PHY_ID_33f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_35_32r_PHY_ID_33f_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_35_32r_PHY_ID_33f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_35_32r_PHY_ID_34f_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_35_32r_PHY_ID_34f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_35_32r_PHY_ID_34f_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_35_32r_PHY_ID_34f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_35_32r_PHY_ID_35f_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_35_32r_PHY_ID_35f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_35_32r_PHY_ID_35f_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_35_32r_PHY_ID_35f_SET
#define READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_35_32r BCM56218_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_35_32r
#define WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_35_32r BCM56218_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_35_32r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_35_32r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_MIIM_EXT_PHY_ADDR_MAP_39_36
 * BLOCKS:   CMIC
 * DESC:     MIIM Phy Address map, Port 39:26
 * SIZE:     32
 * FIELDS:
 *     PHY_ID_36        Phy ID of external phy for Port 36
 *     PHY_ID_37        Phy ID of external phy for Port 37
 *     PHY_ID_38        Phy ID of external phy for Port 38
 *     PHY_ID_39        Phy ID of external phy for Port 39
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_39_36r 0x000004e4

#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_39_36r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_EXT_PHY_ADDR_MAP_39_36.
 *
 */
typedef union BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_39_36r_s {
	uint32_t v[1];
	uint32_t cmic_miim_ext_phy_addr_map_39_36[1];
	uint32_t _cmic_miim_ext_phy_addr_map_39_36;
} BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_39_36r_t;

#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_39_36r_CLR(r) (r).cmic_miim_ext_phy_addr_map_39_36[0] = 0
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_39_36r_SET(r,d) (r).cmic_miim_ext_phy_addr_map_39_36[0] = d
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_39_36r_GET(r) (r).cmic_miim_ext_phy_addr_map_39_36[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_39_36r_PHY_ID_36f_GET(r) (((r).cmic_miim_ext_phy_addr_map_39_36[0]) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_39_36r_PHY_ID_36f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_39_36[0]=(((r).cmic_miim_ext_phy_addr_map_39_36[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_39_36r_PHY_ID_37f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_39_36[0]) >> 8) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_39_36r_PHY_ID_37f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_39_36[0]=(((r).cmic_miim_ext_phy_addr_map_39_36[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_39_36r_PHY_ID_38f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_39_36[0]) >> 16) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_39_36r_PHY_ID_38f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_39_36[0]=(((r).cmic_miim_ext_phy_addr_map_39_36[0] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_39_36r_PHY_ID_39f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_39_36[0]) >> 24) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_39_36r_PHY_ID_39f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_39_36[0]=(((r).cmic_miim_ext_phy_addr_map_39_36[0] & ~((uint32_t)0x1f << 24)) | ((((uint32_t)f) & 0x1f) << 24))

/*
 * These macros can be used to access CMIC_MIIM_EXT_PHY_ADDR_MAP_39_36.
 *
 */
#define BCM56218_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_39_36r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_39_36r,r._cmic_miim_ext_phy_addr_map_39_36)
#define BCM56218_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_39_36r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_39_36r,r._cmic_miim_ext_phy_addr_map_39_36)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_EXT_PHY_ADDR_MAP_39_36r BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_39_36r
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_39_36r_SIZE BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_39_36r_SIZE
typedef BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_39_36r_t CMIC_MIIM_EXT_PHY_ADDR_MAP_39_36r_t;
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_39_36r_CLR BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_39_36r_CLR
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_39_36r_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_39_36r_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_39_36r_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_39_36r_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_39_36r_PHY_ID_36f_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_39_36r_PHY_ID_36f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_39_36r_PHY_ID_36f_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_39_36r_PHY_ID_36f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_39_36r_PHY_ID_37f_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_39_36r_PHY_ID_37f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_39_36r_PHY_ID_37f_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_39_36r_PHY_ID_37f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_39_36r_PHY_ID_38f_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_39_36r_PHY_ID_38f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_39_36r_PHY_ID_38f_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_39_36r_PHY_ID_38f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_39_36r_PHY_ID_39f_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_39_36r_PHY_ID_39f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_39_36r_PHY_ID_39f_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_39_36r_PHY_ID_39f_SET
#define READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_39_36r BCM56218_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_39_36r
#define WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_39_36r BCM56218_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_39_36r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_39_36r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0
 * BLOCKS:   CMIC
 * DESC:     MIIM Phy Address map, Port 3:0
 * SIZE:     32
 * FIELDS:
 *     PHY_ID_0         Phy ID of external phy for Port 0
 *     PHY_ID_1         Phy ID of external phy for Port 1
 *     PHY_ID_2         Phy ID of external phy for Port 2
 *     PHY_ID_3         Phy ID of external phy for Port 3
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r 0x000004c0

#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0.
 *
 */
typedef union BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_s {
	uint32_t v[1];
	uint32_t cmic_miim_ext_phy_addr_map_3_0[1];
	uint32_t _cmic_miim_ext_phy_addr_map_3_0;
} BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_t;

#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_CLR(r) (r).cmic_miim_ext_phy_addr_map_3_0[0] = 0
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_SET(r,d) (r).cmic_miim_ext_phy_addr_map_3_0[0] = d
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_GET(r) (r).cmic_miim_ext_phy_addr_map_3_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_0f_GET(r) (((r).cmic_miim_ext_phy_addr_map_3_0[0]) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_0f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_3_0[0]=(((r).cmic_miim_ext_phy_addr_map_3_0[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_1f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_3_0[0]) >> 8) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_1f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_3_0[0]=(((r).cmic_miim_ext_phy_addr_map_3_0[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_2f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_3_0[0]) >> 16) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_2f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_3_0[0]=(((r).cmic_miim_ext_phy_addr_map_3_0[0] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_3f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_3_0[0]) >> 24) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_3f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_3_0[0]=(((r).cmic_miim_ext_phy_addr_map_3_0[0] & ~((uint32_t)0x1f << 24)) | ((((uint32_t)f) & 0x1f) << 24))

/*
 * These macros can be used to access CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0.
 *
 */
#define BCM56218_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r,r._cmic_miim_ext_phy_addr_map_3_0)
#define BCM56218_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r,r._cmic_miim_ext_phy_addr_map_3_0)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_SIZE BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_SIZE
typedef BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_t CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_t;
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_CLR BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_CLR
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_0f_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_0f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_0f_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_0f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_1f_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_1f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_1f_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_1f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_2f_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_2f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_2f_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_2f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_3f_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_3f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_3f_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_3f_SET
#define READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r BCM56218_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r
#define WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r BCM56218_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_MIIM_EXT_PHY_ADDR_MAP_43_40
 * BLOCKS:   CMIC
 * DESC:     MIIM Phy Address map, Port 43:40
 * SIZE:     32
 * FIELDS:
 *     PHY_ID_40        Phy ID of external phy for Port 40
 *     PHY_ID_41        Phy ID of external phy for Port 41
 *     PHY_ID_42        Phy ID of external phy for Port 42
 *     PHY_ID_43        Phy ID of external phy for Port 43
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_43_40r 0x000004e8

#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_43_40r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_EXT_PHY_ADDR_MAP_43_40.
 *
 */
typedef union BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_43_40r_s {
	uint32_t v[1];
	uint32_t cmic_miim_ext_phy_addr_map_43_40[1];
	uint32_t _cmic_miim_ext_phy_addr_map_43_40;
} BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_43_40r_t;

#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_43_40r_CLR(r) (r).cmic_miim_ext_phy_addr_map_43_40[0] = 0
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_43_40r_SET(r,d) (r).cmic_miim_ext_phy_addr_map_43_40[0] = d
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_43_40r_GET(r) (r).cmic_miim_ext_phy_addr_map_43_40[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_43_40r_PHY_ID_40f_GET(r) (((r).cmic_miim_ext_phy_addr_map_43_40[0]) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_43_40r_PHY_ID_40f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_43_40[0]=(((r).cmic_miim_ext_phy_addr_map_43_40[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_43_40r_PHY_ID_41f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_43_40[0]) >> 8) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_43_40r_PHY_ID_41f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_43_40[0]=(((r).cmic_miim_ext_phy_addr_map_43_40[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_43_40r_PHY_ID_42f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_43_40[0]) >> 16) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_43_40r_PHY_ID_42f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_43_40[0]=(((r).cmic_miim_ext_phy_addr_map_43_40[0] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_43_40r_PHY_ID_43f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_43_40[0]) >> 24) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_43_40r_PHY_ID_43f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_43_40[0]=(((r).cmic_miim_ext_phy_addr_map_43_40[0] & ~((uint32_t)0x1f << 24)) | ((((uint32_t)f) & 0x1f) << 24))

/*
 * These macros can be used to access CMIC_MIIM_EXT_PHY_ADDR_MAP_43_40.
 *
 */
#define BCM56218_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_43_40r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_43_40r,r._cmic_miim_ext_phy_addr_map_43_40)
#define BCM56218_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_43_40r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_43_40r,r._cmic_miim_ext_phy_addr_map_43_40)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_EXT_PHY_ADDR_MAP_43_40r BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_43_40r
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_43_40r_SIZE BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_43_40r_SIZE
typedef BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_43_40r_t CMIC_MIIM_EXT_PHY_ADDR_MAP_43_40r_t;
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_43_40r_CLR BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_43_40r_CLR
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_43_40r_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_43_40r_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_43_40r_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_43_40r_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_43_40r_PHY_ID_40f_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_43_40r_PHY_ID_40f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_43_40r_PHY_ID_40f_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_43_40r_PHY_ID_40f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_43_40r_PHY_ID_41f_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_43_40r_PHY_ID_41f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_43_40r_PHY_ID_41f_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_43_40r_PHY_ID_41f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_43_40r_PHY_ID_42f_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_43_40r_PHY_ID_42f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_43_40r_PHY_ID_42f_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_43_40r_PHY_ID_42f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_43_40r_PHY_ID_43f_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_43_40r_PHY_ID_43f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_43_40r_PHY_ID_43f_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_43_40r_PHY_ID_43f_SET
#define READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_43_40r BCM56218_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_43_40r
#define WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_43_40r BCM56218_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_43_40r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_43_40r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_MIIM_EXT_PHY_ADDR_MAP_47_44
 * BLOCKS:   CMIC
 * DESC:     MIIM Phy Address map, Port 47:44
 * SIZE:     32
 * FIELDS:
 *     PHY_ID_44        Phy ID of external phy for Port 44
 *     PHY_ID_45        Phy ID of external phy for Port 45
 *     PHY_ID_46        Phy ID of external phy for Port 46
 *     PHY_ID_47        Phy ID of external phy for Port 47
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_47_44r 0x000004ec

#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_47_44r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_EXT_PHY_ADDR_MAP_47_44.
 *
 */
typedef union BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_47_44r_s {
	uint32_t v[1];
	uint32_t cmic_miim_ext_phy_addr_map_47_44[1];
	uint32_t _cmic_miim_ext_phy_addr_map_47_44;
} BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_47_44r_t;

#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_47_44r_CLR(r) (r).cmic_miim_ext_phy_addr_map_47_44[0] = 0
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_47_44r_SET(r,d) (r).cmic_miim_ext_phy_addr_map_47_44[0] = d
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_47_44r_GET(r) (r).cmic_miim_ext_phy_addr_map_47_44[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_47_44r_PHY_ID_44f_GET(r) (((r).cmic_miim_ext_phy_addr_map_47_44[0]) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_47_44r_PHY_ID_44f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_47_44[0]=(((r).cmic_miim_ext_phy_addr_map_47_44[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_47_44r_PHY_ID_45f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_47_44[0]) >> 8) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_47_44r_PHY_ID_45f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_47_44[0]=(((r).cmic_miim_ext_phy_addr_map_47_44[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_47_44r_PHY_ID_46f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_47_44[0]) >> 16) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_47_44r_PHY_ID_46f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_47_44[0]=(((r).cmic_miim_ext_phy_addr_map_47_44[0] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_47_44r_PHY_ID_47f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_47_44[0]) >> 24) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_47_44r_PHY_ID_47f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_47_44[0]=(((r).cmic_miim_ext_phy_addr_map_47_44[0] & ~((uint32_t)0x1f << 24)) | ((((uint32_t)f) & 0x1f) << 24))

/*
 * These macros can be used to access CMIC_MIIM_EXT_PHY_ADDR_MAP_47_44.
 *
 */
#define BCM56218_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_47_44r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_47_44r,r._cmic_miim_ext_phy_addr_map_47_44)
#define BCM56218_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_47_44r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_47_44r,r._cmic_miim_ext_phy_addr_map_47_44)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_EXT_PHY_ADDR_MAP_47_44r BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_47_44r
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_47_44r_SIZE BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_47_44r_SIZE
typedef BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_47_44r_t CMIC_MIIM_EXT_PHY_ADDR_MAP_47_44r_t;
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_47_44r_CLR BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_47_44r_CLR
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_47_44r_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_47_44r_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_47_44r_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_47_44r_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_47_44r_PHY_ID_44f_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_47_44r_PHY_ID_44f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_47_44r_PHY_ID_44f_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_47_44r_PHY_ID_44f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_47_44r_PHY_ID_45f_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_47_44r_PHY_ID_45f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_47_44r_PHY_ID_45f_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_47_44r_PHY_ID_45f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_47_44r_PHY_ID_46f_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_47_44r_PHY_ID_46f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_47_44r_PHY_ID_46f_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_47_44r_PHY_ID_46f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_47_44r_PHY_ID_47f_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_47_44r_PHY_ID_47f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_47_44r_PHY_ID_47f_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_47_44r_PHY_ID_47f_SET
#define READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_47_44r BCM56218_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_47_44r
#define WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_47_44r BCM56218_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_47_44r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_47_44r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_MIIM_EXT_PHY_ADDR_MAP_51_48
 * BLOCKS:   CMIC
 * DESC:     MIIM Phy Address map, Port 51:48
 * SIZE:     32
 * FIELDS:
 *     PHY_ID_48        Phy ID of external phy for Port 48
 *     PHY_ID_49        Phy ID of external phy for Port 49
 *     PHY_ID_50        Phy ID of external phy for Port 50
 *     PHY_ID_51        Phy ID of external phy for Port 51
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_51_48r 0x000004f0

#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_51_48r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_EXT_PHY_ADDR_MAP_51_48.
 *
 */
typedef union BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_51_48r_s {
	uint32_t v[1];
	uint32_t cmic_miim_ext_phy_addr_map_51_48[1];
	uint32_t _cmic_miim_ext_phy_addr_map_51_48;
} BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_51_48r_t;

#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_51_48r_CLR(r) (r).cmic_miim_ext_phy_addr_map_51_48[0] = 0
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_51_48r_SET(r,d) (r).cmic_miim_ext_phy_addr_map_51_48[0] = d
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_51_48r_GET(r) (r).cmic_miim_ext_phy_addr_map_51_48[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_51_48r_PHY_ID_48f_GET(r) (((r).cmic_miim_ext_phy_addr_map_51_48[0]) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_51_48r_PHY_ID_48f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_51_48[0]=(((r).cmic_miim_ext_phy_addr_map_51_48[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_51_48r_PHY_ID_49f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_51_48[0]) >> 8) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_51_48r_PHY_ID_49f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_51_48[0]=(((r).cmic_miim_ext_phy_addr_map_51_48[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_51_48r_PHY_ID_50f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_51_48[0]) >> 16) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_51_48r_PHY_ID_50f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_51_48[0]=(((r).cmic_miim_ext_phy_addr_map_51_48[0] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_51_48r_PHY_ID_51f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_51_48[0]) >> 24) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_51_48r_PHY_ID_51f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_51_48[0]=(((r).cmic_miim_ext_phy_addr_map_51_48[0] & ~((uint32_t)0x1f << 24)) | ((((uint32_t)f) & 0x1f) << 24))

/*
 * These macros can be used to access CMIC_MIIM_EXT_PHY_ADDR_MAP_51_48.
 *
 */
#define BCM56218_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_51_48r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_51_48r,r._cmic_miim_ext_phy_addr_map_51_48)
#define BCM56218_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_51_48r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_51_48r,r._cmic_miim_ext_phy_addr_map_51_48)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_EXT_PHY_ADDR_MAP_51_48r BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_51_48r
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_51_48r_SIZE BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_51_48r_SIZE
typedef BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_51_48r_t CMIC_MIIM_EXT_PHY_ADDR_MAP_51_48r_t;
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_51_48r_CLR BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_51_48r_CLR
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_51_48r_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_51_48r_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_51_48r_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_51_48r_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_51_48r_PHY_ID_48f_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_51_48r_PHY_ID_48f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_51_48r_PHY_ID_48f_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_51_48r_PHY_ID_48f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_51_48r_PHY_ID_49f_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_51_48r_PHY_ID_49f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_51_48r_PHY_ID_49f_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_51_48r_PHY_ID_49f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_51_48r_PHY_ID_50f_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_51_48r_PHY_ID_50f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_51_48r_PHY_ID_50f_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_51_48r_PHY_ID_50f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_51_48r_PHY_ID_51f_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_51_48r_PHY_ID_51f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_51_48r_PHY_ID_51f_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_51_48r_PHY_ID_51f_SET
#define READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_51_48r BCM56218_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_51_48r
#define WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_51_48r BCM56218_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_51_48r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_51_48r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_MIIM_EXT_PHY_ADDR_MAP_55_52
 * BLOCKS:   CMIC
 * DESC:     MIIM Phy Address map, Port 55:52
 * SIZE:     32
 * FIELDS:
 *     PHY_ID_52        Phy ID of external phy for Port 52
 *     PHY_ID_53        Phy ID of external phy for Port 53
 *     PHY_ID_54        Phy ID of external phy for Port 54
 *     PHY_ID_55        Phy ID of external phy for Port 55
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_55_52r 0x000004f4

#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_55_52r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_EXT_PHY_ADDR_MAP_55_52.
 *
 */
typedef union BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_55_52r_s {
	uint32_t v[1];
	uint32_t cmic_miim_ext_phy_addr_map_55_52[1];
	uint32_t _cmic_miim_ext_phy_addr_map_55_52;
} BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_55_52r_t;

#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_55_52r_CLR(r) (r).cmic_miim_ext_phy_addr_map_55_52[0] = 0
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_55_52r_SET(r,d) (r).cmic_miim_ext_phy_addr_map_55_52[0] = d
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_55_52r_GET(r) (r).cmic_miim_ext_phy_addr_map_55_52[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_55_52r_PHY_ID_52f_GET(r) (((r).cmic_miim_ext_phy_addr_map_55_52[0]) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_55_52r_PHY_ID_52f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_55_52[0]=(((r).cmic_miim_ext_phy_addr_map_55_52[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_55_52r_PHY_ID_53f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_55_52[0]) >> 8) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_55_52r_PHY_ID_53f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_55_52[0]=(((r).cmic_miim_ext_phy_addr_map_55_52[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_55_52r_PHY_ID_54f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_55_52[0]) >> 16) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_55_52r_PHY_ID_54f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_55_52[0]=(((r).cmic_miim_ext_phy_addr_map_55_52[0] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_55_52r_PHY_ID_55f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_55_52[0]) >> 24) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_55_52r_PHY_ID_55f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_55_52[0]=(((r).cmic_miim_ext_phy_addr_map_55_52[0] & ~((uint32_t)0x1f << 24)) | ((((uint32_t)f) & 0x1f) << 24))

/*
 * These macros can be used to access CMIC_MIIM_EXT_PHY_ADDR_MAP_55_52.
 *
 */
#define BCM56218_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_55_52r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_55_52r,r._cmic_miim_ext_phy_addr_map_55_52)
#define BCM56218_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_55_52r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_55_52r,r._cmic_miim_ext_phy_addr_map_55_52)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_EXT_PHY_ADDR_MAP_55_52r BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_55_52r
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_55_52r_SIZE BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_55_52r_SIZE
typedef BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_55_52r_t CMIC_MIIM_EXT_PHY_ADDR_MAP_55_52r_t;
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_55_52r_CLR BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_55_52r_CLR
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_55_52r_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_55_52r_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_55_52r_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_55_52r_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_55_52r_PHY_ID_52f_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_55_52r_PHY_ID_52f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_55_52r_PHY_ID_52f_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_55_52r_PHY_ID_52f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_55_52r_PHY_ID_53f_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_55_52r_PHY_ID_53f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_55_52r_PHY_ID_53f_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_55_52r_PHY_ID_53f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_55_52r_PHY_ID_54f_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_55_52r_PHY_ID_54f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_55_52r_PHY_ID_54f_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_55_52r_PHY_ID_54f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_55_52r_PHY_ID_55f_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_55_52r_PHY_ID_55f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_55_52r_PHY_ID_55f_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_55_52r_PHY_ID_55f_SET
#define READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_55_52r BCM56218_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_55_52r
#define WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_55_52r BCM56218_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_55_52r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_55_52r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_MIIM_EXT_PHY_ADDR_MAP_59_56
 * BLOCKS:   CMIC
 * DESC:     MIIM Phy Address map, Port 59:56
 * SIZE:     32
 * FIELDS:
 *     PHY_ID_56        Phy ID of external phy for Port 56
 *     PHY_ID_57        Phy ID of external phy for Port 57
 *     PHY_ID_58        Phy ID of external phy for Port 58
 *     PHY_ID_59        Phy ID of external phy for Port 59
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_59_56r 0x000004f8

#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_59_56r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_EXT_PHY_ADDR_MAP_59_56.
 *
 */
typedef union BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_59_56r_s {
	uint32_t v[1];
	uint32_t cmic_miim_ext_phy_addr_map_59_56[1];
	uint32_t _cmic_miim_ext_phy_addr_map_59_56;
} BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_59_56r_t;

#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_59_56r_CLR(r) (r).cmic_miim_ext_phy_addr_map_59_56[0] = 0
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_59_56r_SET(r,d) (r).cmic_miim_ext_phy_addr_map_59_56[0] = d
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_59_56r_GET(r) (r).cmic_miim_ext_phy_addr_map_59_56[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_59_56r_PHY_ID_56f_GET(r) (((r).cmic_miim_ext_phy_addr_map_59_56[0]) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_59_56r_PHY_ID_56f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_59_56[0]=(((r).cmic_miim_ext_phy_addr_map_59_56[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_59_56r_PHY_ID_57f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_59_56[0]) >> 8) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_59_56r_PHY_ID_57f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_59_56[0]=(((r).cmic_miim_ext_phy_addr_map_59_56[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_59_56r_PHY_ID_58f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_59_56[0]) >> 16) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_59_56r_PHY_ID_58f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_59_56[0]=(((r).cmic_miim_ext_phy_addr_map_59_56[0] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_59_56r_PHY_ID_59f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_59_56[0]) >> 24) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_59_56r_PHY_ID_59f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_59_56[0]=(((r).cmic_miim_ext_phy_addr_map_59_56[0] & ~((uint32_t)0x1f << 24)) | ((((uint32_t)f) & 0x1f) << 24))

/*
 * These macros can be used to access CMIC_MIIM_EXT_PHY_ADDR_MAP_59_56.
 *
 */
#define BCM56218_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_59_56r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_59_56r,r._cmic_miim_ext_phy_addr_map_59_56)
#define BCM56218_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_59_56r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_59_56r,r._cmic_miim_ext_phy_addr_map_59_56)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_EXT_PHY_ADDR_MAP_59_56r BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_59_56r
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_59_56r_SIZE BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_59_56r_SIZE
typedef BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_59_56r_t CMIC_MIIM_EXT_PHY_ADDR_MAP_59_56r_t;
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_59_56r_CLR BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_59_56r_CLR
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_59_56r_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_59_56r_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_59_56r_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_59_56r_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_59_56r_PHY_ID_56f_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_59_56r_PHY_ID_56f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_59_56r_PHY_ID_56f_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_59_56r_PHY_ID_56f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_59_56r_PHY_ID_57f_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_59_56r_PHY_ID_57f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_59_56r_PHY_ID_57f_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_59_56r_PHY_ID_57f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_59_56r_PHY_ID_58f_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_59_56r_PHY_ID_58f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_59_56r_PHY_ID_58f_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_59_56r_PHY_ID_58f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_59_56r_PHY_ID_59f_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_59_56r_PHY_ID_59f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_59_56r_PHY_ID_59f_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_59_56r_PHY_ID_59f_SET
#define READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_59_56r BCM56218_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_59_56r
#define WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_59_56r BCM56218_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_59_56r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_59_56r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_MIIM_EXT_PHY_ADDR_MAP_63_60
 * BLOCKS:   CMIC
 * DESC:     MIIM Phy Address map, Port 63:60
 * SIZE:     32
 * FIELDS:
 *     PHY_ID_60        Phy ID of external phy for Port 60
 *     PHY_ID_61        Phy ID of external phy for Port 61
 *     PHY_ID_62        Phy ID of external phy for Port 62
 *     PHY_ID_63        Phy ID of external phy for Port 63
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_63_60r 0x000004fc

#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_63_60r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_EXT_PHY_ADDR_MAP_63_60.
 *
 */
typedef union BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_63_60r_s {
	uint32_t v[1];
	uint32_t cmic_miim_ext_phy_addr_map_63_60[1];
	uint32_t _cmic_miim_ext_phy_addr_map_63_60;
} BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_63_60r_t;

#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_63_60r_CLR(r) (r).cmic_miim_ext_phy_addr_map_63_60[0] = 0
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_63_60r_SET(r,d) (r).cmic_miim_ext_phy_addr_map_63_60[0] = d
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_63_60r_GET(r) (r).cmic_miim_ext_phy_addr_map_63_60[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_63_60r_PHY_ID_60f_GET(r) (((r).cmic_miim_ext_phy_addr_map_63_60[0]) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_63_60r_PHY_ID_60f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_63_60[0]=(((r).cmic_miim_ext_phy_addr_map_63_60[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_63_60r_PHY_ID_61f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_63_60[0]) >> 8) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_63_60r_PHY_ID_61f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_63_60[0]=(((r).cmic_miim_ext_phy_addr_map_63_60[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_63_60r_PHY_ID_62f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_63_60[0]) >> 16) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_63_60r_PHY_ID_62f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_63_60[0]=(((r).cmic_miim_ext_phy_addr_map_63_60[0] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_63_60r_PHY_ID_63f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_63_60[0]) >> 24) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_63_60r_PHY_ID_63f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_63_60[0]=(((r).cmic_miim_ext_phy_addr_map_63_60[0] & ~((uint32_t)0x1f << 24)) | ((((uint32_t)f) & 0x1f) << 24))

/*
 * These macros can be used to access CMIC_MIIM_EXT_PHY_ADDR_MAP_63_60.
 *
 */
#define BCM56218_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_63_60r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_63_60r,r._cmic_miim_ext_phy_addr_map_63_60)
#define BCM56218_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_63_60r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_63_60r,r._cmic_miim_ext_phy_addr_map_63_60)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_EXT_PHY_ADDR_MAP_63_60r BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_63_60r
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_63_60r_SIZE BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_63_60r_SIZE
typedef BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_63_60r_t CMIC_MIIM_EXT_PHY_ADDR_MAP_63_60r_t;
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_63_60r_CLR BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_63_60r_CLR
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_63_60r_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_63_60r_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_63_60r_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_63_60r_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_63_60r_PHY_ID_60f_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_63_60r_PHY_ID_60f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_63_60r_PHY_ID_60f_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_63_60r_PHY_ID_60f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_63_60r_PHY_ID_61f_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_63_60r_PHY_ID_61f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_63_60r_PHY_ID_61f_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_63_60r_PHY_ID_61f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_63_60r_PHY_ID_62f_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_63_60r_PHY_ID_62f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_63_60r_PHY_ID_62f_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_63_60r_PHY_ID_62f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_63_60r_PHY_ID_63f_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_63_60r_PHY_ID_63f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_63_60r_PHY_ID_63f_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_63_60r_PHY_ID_63f_SET
#define READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_63_60r BCM56218_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_63_60r
#define WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_63_60r BCM56218_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_63_60r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_63_60r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4
 * BLOCKS:   CMIC
 * DESC:     MIIM Phy Address map, Port 7:4
 * SIZE:     32
 * FIELDS:
 *     PHY_ID_4         Phy ID of external phy for Port 4
 *     PHY_ID_5         Phy ID of external phy for Port 5
 *     PHY_ID_6         Phy ID of external phy for Port 6
 *     PHY_ID_7         Phy ID of external phy for Port 7
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r 0x000004c4

#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4.
 *
 */
typedef union BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_s {
	uint32_t v[1];
	uint32_t cmic_miim_ext_phy_addr_map_7_4[1];
	uint32_t _cmic_miim_ext_phy_addr_map_7_4;
} BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_t;

#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_CLR(r) (r).cmic_miim_ext_phy_addr_map_7_4[0] = 0
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_SET(r,d) (r).cmic_miim_ext_phy_addr_map_7_4[0] = d
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_GET(r) (r).cmic_miim_ext_phy_addr_map_7_4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_4f_GET(r) (((r).cmic_miim_ext_phy_addr_map_7_4[0]) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_4f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_7_4[0]=(((r).cmic_miim_ext_phy_addr_map_7_4[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_5f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_7_4[0]) >> 8) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_5f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_7_4[0]=(((r).cmic_miim_ext_phy_addr_map_7_4[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_6f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_7_4[0]) >> 16) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_6f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_7_4[0]=(((r).cmic_miim_ext_phy_addr_map_7_4[0] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_7f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_7_4[0]) >> 24) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_7f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_7_4[0]=(((r).cmic_miim_ext_phy_addr_map_7_4[0] & ~((uint32_t)0x1f << 24)) | ((((uint32_t)f) & 0x1f) << 24))

/*
 * These macros can be used to access CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4.
 *
 */
#define BCM56218_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r,r._cmic_miim_ext_phy_addr_map_7_4)
#define BCM56218_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r,r._cmic_miim_ext_phy_addr_map_7_4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_SIZE BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_SIZE
typedef BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_t CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_t;
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_CLR BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_CLR
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_4f_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_4f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_4f_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_4f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_5f_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_5f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_5f_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_5f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_6f_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_6f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_6f_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_6f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_7f_GET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_7f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_7f_SET BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_7f_SET
#define READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r BCM56218_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r
#define WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r BCM56218_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_MIIM_INT_SEL_MAP
 * BLOCKS:   CMIC
 * DESC:     Port bitmap specifying whether scan should be done
from internal or external phy.
0=external phy, 1=internal phy
Note: The bitmap is index by port number.

 * SIZE:     32
 * FIELDS:
 *     PORT_BITMAP      0 bits imply get link status by scanning external phy1 bits imply get link status directly from internal phy
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_MIIM_INT_SEL_MAPr 0x000004ac

#define BCM56218_A0_CMIC_MIIM_INT_SEL_MAPr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_INT_SEL_MAP.
 *
 */
typedef union BCM56218_A0_CMIC_MIIM_INT_SEL_MAPr_s {
	uint32_t v[1];
	uint32_t cmic_miim_int_sel_map[1];
	uint32_t _cmic_miim_int_sel_map;
} BCM56218_A0_CMIC_MIIM_INT_SEL_MAPr_t;

#define BCM56218_A0_CMIC_MIIM_INT_SEL_MAPr_CLR(r) (r).cmic_miim_int_sel_map[0] = 0
#define BCM56218_A0_CMIC_MIIM_INT_SEL_MAPr_SET(r,d) (r).cmic_miim_int_sel_map[0] = d
#define BCM56218_A0_CMIC_MIIM_INT_SEL_MAPr_GET(r) (r).cmic_miim_int_sel_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_MIIM_INT_SEL_MAPr_PORT_BITMAPf_GET(r) ((r).cmic_miim_int_sel_map[0])
#define BCM56218_A0_CMIC_MIIM_INT_SEL_MAPr_PORT_BITMAPf_SET(r,f) (r).cmic_miim_int_sel_map[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_MIIM_INT_SEL_MAP.
 *
 */
#define BCM56218_A0_READ_CMIC_MIIM_INT_SEL_MAPr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_MIIM_INT_SEL_MAPr,r._cmic_miim_int_sel_map)
#define BCM56218_A0_WRITE_CMIC_MIIM_INT_SEL_MAPr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_MIIM_INT_SEL_MAPr,r._cmic_miim_int_sel_map)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_INT_SEL_MAPr BCM56218_A0_CMIC_MIIM_INT_SEL_MAPr
#define CMIC_MIIM_INT_SEL_MAPr_SIZE BCM56218_A0_CMIC_MIIM_INT_SEL_MAPr_SIZE
typedef BCM56218_A0_CMIC_MIIM_INT_SEL_MAPr_t CMIC_MIIM_INT_SEL_MAPr_t;
#define CMIC_MIIM_INT_SEL_MAPr_CLR BCM56218_A0_CMIC_MIIM_INT_SEL_MAPr_CLR
#define CMIC_MIIM_INT_SEL_MAPr_SET BCM56218_A0_CMIC_MIIM_INT_SEL_MAPr_SET
#define CMIC_MIIM_INT_SEL_MAPr_GET BCM56218_A0_CMIC_MIIM_INT_SEL_MAPr_GET
#define CMIC_MIIM_INT_SEL_MAPr_PORT_BITMAPf_GET BCM56218_A0_CMIC_MIIM_INT_SEL_MAPr_PORT_BITMAPf_GET
#define CMIC_MIIM_INT_SEL_MAPr_PORT_BITMAPf_SET BCM56218_A0_CMIC_MIIM_INT_SEL_MAPr_PORT_BITMAPf_SET
#define READ_CMIC_MIIM_INT_SEL_MAPr BCM56218_A0_READ_CMIC_MIIM_INT_SEL_MAPr
#define WRITE_CMIC_MIIM_INT_SEL_MAPr BCM56218_A0_WRITE_CMIC_MIIM_INT_SEL_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_MIIM_INT_SEL_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_MIIM_INT_SEL_MAP_HI
 * BLOCKS:   CMIC
 * DESC:     Port bitmap specifying whether scan should be done
from internal or external phy.
0=external phy, 1=internal phy
Note: The bitmap is index by port number. (upper 32-bits)

 * SIZE:     32
 * FIELDS:
 *     PORT_BITMAP      0 bits imply get link status by scanning external phy1 bits imply get link status directly from internal phy
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_MIIM_INT_SEL_MAP_HIr 0x00000710

#define BCM56218_A0_CMIC_MIIM_INT_SEL_MAP_HIr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_INT_SEL_MAP_HI.
 *
 */
typedef union BCM56218_A0_CMIC_MIIM_INT_SEL_MAP_HIr_s {
	uint32_t v[1];
	uint32_t cmic_miim_int_sel_map_hi[1];
	uint32_t _cmic_miim_int_sel_map_hi;
} BCM56218_A0_CMIC_MIIM_INT_SEL_MAP_HIr_t;

#define BCM56218_A0_CMIC_MIIM_INT_SEL_MAP_HIr_CLR(r) (r).cmic_miim_int_sel_map_hi[0] = 0
#define BCM56218_A0_CMIC_MIIM_INT_SEL_MAP_HIr_SET(r,d) (r).cmic_miim_int_sel_map_hi[0] = d
#define BCM56218_A0_CMIC_MIIM_INT_SEL_MAP_HIr_GET(r) (r).cmic_miim_int_sel_map_hi[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_MIIM_INT_SEL_MAP_HIr_PORT_BITMAPf_GET(r) ((r).cmic_miim_int_sel_map_hi[0])
#define BCM56218_A0_CMIC_MIIM_INT_SEL_MAP_HIr_PORT_BITMAPf_SET(r,f) (r).cmic_miim_int_sel_map_hi[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_MIIM_INT_SEL_MAP_HI.
 *
 */
#define BCM56218_A0_READ_CMIC_MIIM_INT_SEL_MAP_HIr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_MIIM_INT_SEL_MAP_HIr,r._cmic_miim_int_sel_map_hi)
#define BCM56218_A0_WRITE_CMIC_MIIM_INT_SEL_MAP_HIr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_MIIM_INT_SEL_MAP_HIr,r._cmic_miim_int_sel_map_hi)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_INT_SEL_MAP_HIr BCM56218_A0_CMIC_MIIM_INT_SEL_MAP_HIr
#define CMIC_MIIM_INT_SEL_MAP_HIr_SIZE BCM56218_A0_CMIC_MIIM_INT_SEL_MAP_HIr_SIZE
typedef BCM56218_A0_CMIC_MIIM_INT_SEL_MAP_HIr_t CMIC_MIIM_INT_SEL_MAP_HIr_t;
#define CMIC_MIIM_INT_SEL_MAP_HIr_CLR BCM56218_A0_CMIC_MIIM_INT_SEL_MAP_HIr_CLR
#define CMIC_MIIM_INT_SEL_MAP_HIr_SET BCM56218_A0_CMIC_MIIM_INT_SEL_MAP_HIr_SET
#define CMIC_MIIM_INT_SEL_MAP_HIr_GET BCM56218_A0_CMIC_MIIM_INT_SEL_MAP_HIr_GET
#define CMIC_MIIM_INT_SEL_MAP_HIr_PORT_BITMAPf_GET BCM56218_A0_CMIC_MIIM_INT_SEL_MAP_HIr_PORT_BITMAPf_GET
#define CMIC_MIIM_INT_SEL_MAP_HIr_PORT_BITMAPf_SET BCM56218_A0_CMIC_MIIM_INT_SEL_MAP_HIr_PORT_BITMAPf_SET
#define READ_CMIC_MIIM_INT_SEL_MAP_HIr BCM56218_A0_READ_CMIC_MIIM_INT_SEL_MAP_HIr
#define WRITE_CMIC_MIIM_INT_SEL_MAP_HIr BCM56218_A0_WRITE_CMIC_MIIM_INT_SEL_MAP_HIr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_MIIM_INT_SEL_MAP_HIr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_MIIM_PARAM
 * BLOCKS:   CMIC
 * DESC:     MIIM Parameter Register
 * SIZE:     32
 * FIELDS:
 *     PHY_DATA         PHY register data
 *     PHY_ID           Port number (Phy ID is looked up from port number)
 *     C45_SEL          When set, send MIIM transaction using Clause 45.Otherwise, send as Clause 22 transaction.
 *     HG_SEL           When set, send MIIM transaction on Higig MDIO bus.Otherwise, send on Gig MDIO bus.
 *     INTERNAL_SEL     When set, send MIIM transaction on Internal MDIO bus.Otherwise, send on External MDIO bus.
 *     RESERVED_2       Reserved
 *     MIIM_CYCLE       This field is used to select which type of MIIM cycle to run.Normally, it should just be set to 000.    000: Automatically runs the proper read or write cycle based         on the ports' protocol preference, and whether a read         or write cycle was requested.  If the port is clause 45         enabled, then the read or write will be preceeded by         an address cycle.    001: requests a clause 22 write cycle;         use MIIM_WR_REG_EN control    010: requests a clause 22 read cycle;         use MIIM_RD_REG_EN control    100: requests a clause 45 address cycle;         use MIIM_WR_REG_EN control    101: requests a clause 45 write cycle;         use MIIM_WR_REG_EN control    110: requests a clause 45 read cycle w/addr increment;         use MIIM_RD_REG_EN control    111: requests a clause 45 read cycle;         use MIIM_RD_REG_EN control
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_MIIM_PARAMr 0x00000158

#define BCM56218_A0_CMIC_MIIM_PARAMr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_PARAM.
 *
 */
typedef union BCM56218_A0_CMIC_MIIM_PARAMr_s {
	uint32_t v[1];
	uint32_t cmic_miim_param[1];
	uint32_t _cmic_miim_param;
} BCM56218_A0_CMIC_MIIM_PARAMr_t;

#define BCM56218_A0_CMIC_MIIM_PARAMr_CLR(r) (r).cmic_miim_param[0] = 0
#define BCM56218_A0_CMIC_MIIM_PARAMr_SET(r,d) (r).cmic_miim_param[0] = d
#define BCM56218_A0_CMIC_MIIM_PARAMr_GET(r) (r).cmic_miim_param[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_MIIM_PARAMr_PHY_DATAf_GET(r) (((r).cmic_miim_param[0]) & 0xffff)
#define BCM56218_A0_CMIC_MIIM_PARAMr_PHY_DATAf_SET(r,f) (r).cmic_miim_param[0]=(((r).cmic_miim_param[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56218_A0_CMIC_MIIM_PARAMr_PHY_IDf_GET(r) ((((r).cmic_miim_param[0]) >> 16) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_PARAMr_PHY_IDf_SET(r,f) (r).cmic_miim_param[0]=(((r).cmic_miim_param[0] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define BCM56218_A0_CMIC_MIIM_PARAMr_C45_SELf_GET(r) ((((r).cmic_miim_param[0]) >> 21) & 0x1)
#define BCM56218_A0_CMIC_MIIM_PARAMr_C45_SELf_SET(r,f) (r).cmic_miim_param[0]=(((r).cmic_miim_param[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM56218_A0_CMIC_MIIM_PARAMr_HG_SELf_GET(r) ((((r).cmic_miim_param[0]) >> 22) & 0x1)
#define BCM56218_A0_CMIC_MIIM_PARAMr_HG_SELf_SET(r,f) (r).cmic_miim_param[0]=(((r).cmic_miim_param[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM56218_A0_CMIC_MIIM_PARAMr_INTERNAL_SELf_GET(r) ((((r).cmic_miim_param[0]) >> 23) & 0x1)
#define BCM56218_A0_CMIC_MIIM_PARAMr_INTERNAL_SELf_SET(r,f) (r).cmic_miim_param[0]=(((r).cmic_miim_param[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM56218_A0_CMIC_MIIM_PARAMr_RESERVED_2f_GET(r) ((((r).cmic_miim_param[0]) >> 24) & 0x1f)
#define BCM56218_A0_CMIC_MIIM_PARAMr_RESERVED_2f_SET(r,f) (r).cmic_miim_param[0]=(((r).cmic_miim_param[0] & ~((uint32_t)0x1f << 24)) | ((((uint32_t)f) & 0x1f) << 24))
#define BCM56218_A0_CMIC_MIIM_PARAMr_MIIM_CYCLEf_GET(r) ((((r).cmic_miim_param[0]) >> 29) & 0x7)
#define BCM56218_A0_CMIC_MIIM_PARAMr_MIIM_CYCLEf_SET(r,f) (r).cmic_miim_param[0]=(((r).cmic_miim_param[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access CMIC_MIIM_PARAM.
 *
 */
#define BCM56218_A0_READ_CMIC_MIIM_PARAMr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_MIIM_PARAMr,r._cmic_miim_param)
#define BCM56218_A0_WRITE_CMIC_MIIM_PARAMr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_MIIM_PARAMr,r._cmic_miim_param)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_PARAMr BCM56218_A0_CMIC_MIIM_PARAMr
#define CMIC_MIIM_PARAMr_SIZE BCM56218_A0_CMIC_MIIM_PARAMr_SIZE
typedef BCM56218_A0_CMIC_MIIM_PARAMr_t CMIC_MIIM_PARAMr_t;
#define CMIC_MIIM_PARAMr_CLR BCM56218_A0_CMIC_MIIM_PARAMr_CLR
#define CMIC_MIIM_PARAMr_SET BCM56218_A0_CMIC_MIIM_PARAMr_SET
#define CMIC_MIIM_PARAMr_GET BCM56218_A0_CMIC_MIIM_PARAMr_GET
#define CMIC_MIIM_PARAMr_PHY_DATAf_GET BCM56218_A0_CMIC_MIIM_PARAMr_PHY_DATAf_GET
#define CMIC_MIIM_PARAMr_PHY_DATAf_SET BCM56218_A0_CMIC_MIIM_PARAMr_PHY_DATAf_SET
#define CMIC_MIIM_PARAMr_PHY_IDf_GET BCM56218_A0_CMIC_MIIM_PARAMr_PHY_IDf_GET
#define CMIC_MIIM_PARAMr_PHY_IDf_SET BCM56218_A0_CMIC_MIIM_PARAMr_PHY_IDf_SET
#define CMIC_MIIM_PARAMr_C45_SELf_GET BCM56218_A0_CMIC_MIIM_PARAMr_C45_SELf_GET
#define CMIC_MIIM_PARAMr_C45_SELf_SET BCM56218_A0_CMIC_MIIM_PARAMr_C45_SELf_SET
#define CMIC_MIIM_PARAMr_HG_SELf_GET BCM56218_A0_CMIC_MIIM_PARAMr_HG_SELf_GET
#define CMIC_MIIM_PARAMr_HG_SELf_SET BCM56218_A0_CMIC_MIIM_PARAMr_HG_SELf_SET
#define CMIC_MIIM_PARAMr_INTERNAL_SELf_GET BCM56218_A0_CMIC_MIIM_PARAMr_INTERNAL_SELf_GET
#define CMIC_MIIM_PARAMr_INTERNAL_SELf_SET BCM56218_A0_CMIC_MIIM_PARAMr_INTERNAL_SELf_SET
#define CMIC_MIIM_PARAMr_RESERVED_2f_GET BCM56218_A0_CMIC_MIIM_PARAMr_RESERVED_2f_GET
#define CMIC_MIIM_PARAMr_RESERVED_2f_SET BCM56218_A0_CMIC_MIIM_PARAMr_RESERVED_2f_SET
#define CMIC_MIIM_PARAMr_MIIM_CYCLEf_GET BCM56218_A0_CMIC_MIIM_PARAMr_MIIM_CYCLEf_GET
#define CMIC_MIIM_PARAMr_MIIM_CYCLEf_SET BCM56218_A0_CMIC_MIIM_PARAMr_MIIM_CYCLEf_SET
#define READ_CMIC_MIIM_PARAMr BCM56218_A0_READ_CMIC_MIIM_PARAMr
#define WRITE_CMIC_MIIM_PARAMr BCM56218_A0_WRITE_CMIC_MIIM_PARAMr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_MIIM_PARAMr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_MIIM_PORT_TYPE_MAP
 * BLOCKS:   CMIC
 * DESC:     Port type bitmap: 0=Gig port, 1=Higig port
Note: The bitmap is index by port number.

 * SIZE:     32
 * FIELDS:
 *     BITMAP           0 bits are   Gig ports, so access   Gig MIIM interface1 bits are HG/XE ports, so access Higig MIIM interface
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_MIIM_PORT_TYPE_MAPr 0x000004a8

#define BCM56218_A0_CMIC_MIIM_PORT_TYPE_MAPr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_PORT_TYPE_MAP.
 *
 */
typedef union BCM56218_A0_CMIC_MIIM_PORT_TYPE_MAPr_s {
	uint32_t v[1];
	uint32_t cmic_miim_port_type_map[1];
	uint32_t _cmic_miim_port_type_map;
} BCM56218_A0_CMIC_MIIM_PORT_TYPE_MAPr_t;

#define BCM56218_A0_CMIC_MIIM_PORT_TYPE_MAPr_CLR(r) (r).cmic_miim_port_type_map[0] = 0
#define BCM56218_A0_CMIC_MIIM_PORT_TYPE_MAPr_SET(r,d) (r).cmic_miim_port_type_map[0] = d
#define BCM56218_A0_CMIC_MIIM_PORT_TYPE_MAPr_GET(r) (r).cmic_miim_port_type_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_MIIM_PORT_TYPE_MAPr_BITMAPf_GET(r) ((r).cmic_miim_port_type_map[0])
#define BCM56218_A0_CMIC_MIIM_PORT_TYPE_MAPr_BITMAPf_SET(r,f) (r).cmic_miim_port_type_map[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_MIIM_PORT_TYPE_MAP.
 *
 */
#define BCM56218_A0_READ_CMIC_MIIM_PORT_TYPE_MAPr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_MIIM_PORT_TYPE_MAPr,r._cmic_miim_port_type_map)
#define BCM56218_A0_WRITE_CMIC_MIIM_PORT_TYPE_MAPr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_MIIM_PORT_TYPE_MAPr,r._cmic_miim_port_type_map)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_PORT_TYPE_MAPr BCM56218_A0_CMIC_MIIM_PORT_TYPE_MAPr
#define CMIC_MIIM_PORT_TYPE_MAPr_SIZE BCM56218_A0_CMIC_MIIM_PORT_TYPE_MAPr_SIZE
typedef BCM56218_A0_CMIC_MIIM_PORT_TYPE_MAPr_t CMIC_MIIM_PORT_TYPE_MAPr_t;
#define CMIC_MIIM_PORT_TYPE_MAPr_CLR BCM56218_A0_CMIC_MIIM_PORT_TYPE_MAPr_CLR
#define CMIC_MIIM_PORT_TYPE_MAPr_SET BCM56218_A0_CMIC_MIIM_PORT_TYPE_MAPr_SET
#define CMIC_MIIM_PORT_TYPE_MAPr_GET BCM56218_A0_CMIC_MIIM_PORT_TYPE_MAPr_GET
#define CMIC_MIIM_PORT_TYPE_MAPr_BITMAPf_GET BCM56218_A0_CMIC_MIIM_PORT_TYPE_MAPr_BITMAPf_GET
#define CMIC_MIIM_PORT_TYPE_MAPr_BITMAPf_SET BCM56218_A0_CMIC_MIIM_PORT_TYPE_MAPr_BITMAPf_SET
#define READ_CMIC_MIIM_PORT_TYPE_MAPr BCM56218_A0_READ_CMIC_MIIM_PORT_TYPE_MAPr
#define WRITE_CMIC_MIIM_PORT_TYPE_MAPr BCM56218_A0_WRITE_CMIC_MIIM_PORT_TYPE_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_MIIM_PORT_TYPE_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_MIIM_PORT_TYPE_MAP_HI
 * BLOCKS:   CMIC
 * DESC:     Port type bitmap: 0=Gig port, 1=Higig port
Note: The bitmap is index by port number. (upper 32-bits)

 * SIZE:     32
 * FIELDS:
 *     BITMAP           0 bits are   Gig ports, so access   Gig MIIM interface1 bits are HG/XE ports, so access Higig MIIM interface
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_MIIM_PORT_TYPE_MAP_HIr 0x0000070c

#define BCM56218_A0_CMIC_MIIM_PORT_TYPE_MAP_HIr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_PORT_TYPE_MAP_HI.
 *
 */
typedef union BCM56218_A0_CMIC_MIIM_PORT_TYPE_MAP_HIr_s {
	uint32_t v[1];
	uint32_t cmic_miim_port_type_map_hi[1];
	uint32_t _cmic_miim_port_type_map_hi;
} BCM56218_A0_CMIC_MIIM_PORT_TYPE_MAP_HIr_t;

#define BCM56218_A0_CMIC_MIIM_PORT_TYPE_MAP_HIr_CLR(r) (r).cmic_miim_port_type_map_hi[0] = 0
#define BCM56218_A0_CMIC_MIIM_PORT_TYPE_MAP_HIr_SET(r,d) (r).cmic_miim_port_type_map_hi[0] = d
#define BCM56218_A0_CMIC_MIIM_PORT_TYPE_MAP_HIr_GET(r) (r).cmic_miim_port_type_map_hi[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_MIIM_PORT_TYPE_MAP_HIr_BITMAPf_GET(r) ((r).cmic_miim_port_type_map_hi[0])
#define BCM56218_A0_CMIC_MIIM_PORT_TYPE_MAP_HIr_BITMAPf_SET(r,f) (r).cmic_miim_port_type_map_hi[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_MIIM_PORT_TYPE_MAP_HI.
 *
 */
#define BCM56218_A0_READ_CMIC_MIIM_PORT_TYPE_MAP_HIr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_MIIM_PORT_TYPE_MAP_HIr,r._cmic_miim_port_type_map_hi)
#define BCM56218_A0_WRITE_CMIC_MIIM_PORT_TYPE_MAP_HIr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_MIIM_PORT_TYPE_MAP_HIr,r._cmic_miim_port_type_map_hi)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_PORT_TYPE_MAP_HIr BCM56218_A0_CMIC_MIIM_PORT_TYPE_MAP_HIr
#define CMIC_MIIM_PORT_TYPE_MAP_HIr_SIZE BCM56218_A0_CMIC_MIIM_PORT_TYPE_MAP_HIr_SIZE
typedef BCM56218_A0_CMIC_MIIM_PORT_TYPE_MAP_HIr_t CMIC_MIIM_PORT_TYPE_MAP_HIr_t;
#define CMIC_MIIM_PORT_TYPE_MAP_HIr_CLR BCM56218_A0_CMIC_MIIM_PORT_TYPE_MAP_HIr_CLR
#define CMIC_MIIM_PORT_TYPE_MAP_HIr_SET BCM56218_A0_CMIC_MIIM_PORT_TYPE_MAP_HIr_SET
#define CMIC_MIIM_PORT_TYPE_MAP_HIr_GET BCM56218_A0_CMIC_MIIM_PORT_TYPE_MAP_HIr_GET
#define CMIC_MIIM_PORT_TYPE_MAP_HIr_BITMAPf_GET BCM56218_A0_CMIC_MIIM_PORT_TYPE_MAP_HIr_BITMAPf_GET
#define CMIC_MIIM_PORT_TYPE_MAP_HIr_BITMAPf_SET BCM56218_A0_CMIC_MIIM_PORT_TYPE_MAP_HIr_BITMAPf_SET
#define READ_CMIC_MIIM_PORT_TYPE_MAP_HIr BCM56218_A0_READ_CMIC_MIIM_PORT_TYPE_MAP_HIr
#define WRITE_CMIC_MIIM_PORT_TYPE_MAP_HIr BCM56218_A0_WRITE_CMIC_MIIM_PORT_TYPE_MAP_HIr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_MIIM_PORT_TYPE_MAP_HIr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_MIIM_PROTOCOL_MAP
 * BLOCKS:   CMIC
 * DESC:     Port bitmap of MIIM protocol: 0=clause 22, 1=clause 45
Note: The bitmap is index by port number.

 * SIZE:     32
 * FIELDS:
 *     BITMAP           0 bits are ports that use clause 22;1 bits are ports that use clause 45.Note: This register is shared by external and internal phy's, so it should be programmed appropriately beforelaunching MIIM wr/rd or link scan commands.
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_MIIM_PROTOCOL_MAPr 0x000004a4

#define BCM56218_A0_CMIC_MIIM_PROTOCOL_MAPr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_PROTOCOL_MAP.
 *
 */
typedef union BCM56218_A0_CMIC_MIIM_PROTOCOL_MAPr_s {
	uint32_t v[1];
	uint32_t cmic_miim_protocol_map[1];
	uint32_t _cmic_miim_protocol_map;
} BCM56218_A0_CMIC_MIIM_PROTOCOL_MAPr_t;

#define BCM56218_A0_CMIC_MIIM_PROTOCOL_MAPr_CLR(r) (r).cmic_miim_protocol_map[0] = 0
#define BCM56218_A0_CMIC_MIIM_PROTOCOL_MAPr_SET(r,d) (r).cmic_miim_protocol_map[0] = d
#define BCM56218_A0_CMIC_MIIM_PROTOCOL_MAPr_GET(r) (r).cmic_miim_protocol_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_MIIM_PROTOCOL_MAPr_BITMAPf_GET(r) ((r).cmic_miim_protocol_map[0])
#define BCM56218_A0_CMIC_MIIM_PROTOCOL_MAPr_BITMAPf_SET(r,f) (r).cmic_miim_protocol_map[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_MIIM_PROTOCOL_MAP.
 *
 */
#define BCM56218_A0_READ_CMIC_MIIM_PROTOCOL_MAPr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_MIIM_PROTOCOL_MAPr,r._cmic_miim_protocol_map)
#define BCM56218_A0_WRITE_CMIC_MIIM_PROTOCOL_MAPr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_MIIM_PROTOCOL_MAPr,r._cmic_miim_protocol_map)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_PROTOCOL_MAPr BCM56218_A0_CMIC_MIIM_PROTOCOL_MAPr
#define CMIC_MIIM_PROTOCOL_MAPr_SIZE BCM56218_A0_CMIC_MIIM_PROTOCOL_MAPr_SIZE
typedef BCM56218_A0_CMIC_MIIM_PROTOCOL_MAPr_t CMIC_MIIM_PROTOCOL_MAPr_t;
#define CMIC_MIIM_PROTOCOL_MAPr_CLR BCM56218_A0_CMIC_MIIM_PROTOCOL_MAPr_CLR
#define CMIC_MIIM_PROTOCOL_MAPr_SET BCM56218_A0_CMIC_MIIM_PROTOCOL_MAPr_SET
#define CMIC_MIIM_PROTOCOL_MAPr_GET BCM56218_A0_CMIC_MIIM_PROTOCOL_MAPr_GET
#define CMIC_MIIM_PROTOCOL_MAPr_BITMAPf_GET BCM56218_A0_CMIC_MIIM_PROTOCOL_MAPr_BITMAPf_GET
#define CMIC_MIIM_PROTOCOL_MAPr_BITMAPf_SET BCM56218_A0_CMIC_MIIM_PROTOCOL_MAPr_BITMAPf_SET
#define READ_CMIC_MIIM_PROTOCOL_MAPr BCM56218_A0_READ_CMIC_MIIM_PROTOCOL_MAPr
#define WRITE_CMIC_MIIM_PROTOCOL_MAPr BCM56218_A0_WRITE_CMIC_MIIM_PROTOCOL_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_MIIM_PROTOCOL_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_MIIM_PROTOCOL_MAP_HI
 * BLOCKS:   CMIC
 * DESC:     Port bitmap of MIIM protocol: 0=clause 22, 1=clause 45
Note: The bitmap is index by port number. (upper 32 bits)

 * SIZE:     32
 * FIELDS:
 *     BITMAP           0 bits are ports that use clause 22;1 bits are ports that use clause 45.Note: This register is shared by external and internal phy's, so it should be programmed appropriately beforelaunching MIIM wr/rd or link scan commands.
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_MIIM_PROTOCOL_MAP_HIr 0x00000708

#define BCM56218_A0_CMIC_MIIM_PROTOCOL_MAP_HIr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_PROTOCOL_MAP_HI.
 *
 */
typedef union BCM56218_A0_CMIC_MIIM_PROTOCOL_MAP_HIr_s {
	uint32_t v[1];
	uint32_t cmic_miim_protocol_map_hi[1];
	uint32_t _cmic_miim_protocol_map_hi;
} BCM56218_A0_CMIC_MIIM_PROTOCOL_MAP_HIr_t;

#define BCM56218_A0_CMIC_MIIM_PROTOCOL_MAP_HIr_CLR(r) (r).cmic_miim_protocol_map_hi[0] = 0
#define BCM56218_A0_CMIC_MIIM_PROTOCOL_MAP_HIr_SET(r,d) (r).cmic_miim_protocol_map_hi[0] = d
#define BCM56218_A0_CMIC_MIIM_PROTOCOL_MAP_HIr_GET(r) (r).cmic_miim_protocol_map_hi[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_MIIM_PROTOCOL_MAP_HIr_BITMAPf_GET(r) ((r).cmic_miim_protocol_map_hi[0])
#define BCM56218_A0_CMIC_MIIM_PROTOCOL_MAP_HIr_BITMAPf_SET(r,f) (r).cmic_miim_protocol_map_hi[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_MIIM_PROTOCOL_MAP_HI.
 *
 */
#define BCM56218_A0_READ_CMIC_MIIM_PROTOCOL_MAP_HIr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_MIIM_PROTOCOL_MAP_HIr,r._cmic_miim_protocol_map_hi)
#define BCM56218_A0_WRITE_CMIC_MIIM_PROTOCOL_MAP_HIr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_MIIM_PROTOCOL_MAP_HIr,r._cmic_miim_protocol_map_hi)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_PROTOCOL_MAP_HIr BCM56218_A0_CMIC_MIIM_PROTOCOL_MAP_HIr
#define CMIC_MIIM_PROTOCOL_MAP_HIr_SIZE BCM56218_A0_CMIC_MIIM_PROTOCOL_MAP_HIr_SIZE
typedef BCM56218_A0_CMIC_MIIM_PROTOCOL_MAP_HIr_t CMIC_MIIM_PROTOCOL_MAP_HIr_t;
#define CMIC_MIIM_PROTOCOL_MAP_HIr_CLR BCM56218_A0_CMIC_MIIM_PROTOCOL_MAP_HIr_CLR
#define CMIC_MIIM_PROTOCOL_MAP_HIr_SET BCM56218_A0_CMIC_MIIM_PROTOCOL_MAP_HIr_SET
#define CMIC_MIIM_PROTOCOL_MAP_HIr_GET BCM56218_A0_CMIC_MIIM_PROTOCOL_MAP_HIr_GET
#define CMIC_MIIM_PROTOCOL_MAP_HIr_BITMAPf_GET BCM56218_A0_CMIC_MIIM_PROTOCOL_MAP_HIr_BITMAPf_GET
#define CMIC_MIIM_PROTOCOL_MAP_HIr_BITMAPf_SET BCM56218_A0_CMIC_MIIM_PROTOCOL_MAP_HIr_BITMAPf_SET
#define READ_CMIC_MIIM_PROTOCOL_MAP_HIr BCM56218_A0_READ_CMIC_MIIM_PROTOCOL_MAP_HIr
#define WRITE_CMIC_MIIM_PROTOCOL_MAP_HIr BCM56218_A0_WRITE_CMIC_MIIM_PROTOCOL_MAP_HIr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_MIIM_PROTOCOL_MAP_HIr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_MIIM_READ_DATA
 * BLOCKS:   CMIC
 * DESC:     MIIM Read Data Register
 * SIZE:     32
 * FIELDS:
 *     DATA             MIIM Read Data Register
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_MIIM_READ_DATAr 0x0000015c

#define BCM56218_A0_CMIC_MIIM_READ_DATAr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_READ_DATA.
 *
 */
typedef union BCM56218_A0_CMIC_MIIM_READ_DATAr_s {
	uint32_t v[1];
	uint32_t cmic_miim_read_data[1];
	uint32_t _cmic_miim_read_data;
} BCM56218_A0_CMIC_MIIM_READ_DATAr_t;

#define BCM56218_A0_CMIC_MIIM_READ_DATAr_CLR(r) (r).cmic_miim_read_data[0] = 0
#define BCM56218_A0_CMIC_MIIM_READ_DATAr_SET(r,d) (r).cmic_miim_read_data[0] = d
#define BCM56218_A0_CMIC_MIIM_READ_DATAr_GET(r) (r).cmic_miim_read_data[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_MIIM_READ_DATAr_DATAf_GET(r) (((r).cmic_miim_read_data[0]) & 0xffff)
#define BCM56218_A0_CMIC_MIIM_READ_DATAr_DATAf_SET(r,f) (r).cmic_miim_read_data[0]=(((r).cmic_miim_read_data[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access CMIC_MIIM_READ_DATA.
 *
 */
#define BCM56218_A0_READ_CMIC_MIIM_READ_DATAr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_MIIM_READ_DATAr,r._cmic_miim_read_data)
#define BCM56218_A0_WRITE_CMIC_MIIM_READ_DATAr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_MIIM_READ_DATAr,r._cmic_miim_read_data)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_READ_DATAr BCM56218_A0_CMIC_MIIM_READ_DATAr
#define CMIC_MIIM_READ_DATAr_SIZE BCM56218_A0_CMIC_MIIM_READ_DATAr_SIZE
typedef BCM56218_A0_CMIC_MIIM_READ_DATAr_t CMIC_MIIM_READ_DATAr_t;
#define CMIC_MIIM_READ_DATAr_CLR BCM56218_A0_CMIC_MIIM_READ_DATAr_CLR
#define CMIC_MIIM_READ_DATAr_SET BCM56218_A0_CMIC_MIIM_READ_DATAr_SET
#define CMIC_MIIM_READ_DATAr_GET BCM56218_A0_CMIC_MIIM_READ_DATAr_GET
#define CMIC_MIIM_READ_DATAr_DATAf_GET BCM56218_A0_CMIC_MIIM_READ_DATAr_DATAf_GET
#define CMIC_MIIM_READ_DATAr_DATAf_SET BCM56218_A0_CMIC_MIIM_READ_DATAr_DATAf_SET
#define READ_CMIC_MIIM_READ_DATAr BCM56218_A0_READ_CMIC_MIIM_READ_DATAr
#define WRITE_CMIC_MIIM_READ_DATAr BCM56218_A0_WRITE_CMIC_MIIM_READ_DATAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_MIIM_READ_DATAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_PKT_COS
 * BLOCKS:   CMIC
 * DESC:     CMIC Packet COS Bitmap

 * SIZE:     32
 * FIELDS:
 *     COS              COS values of aceptable CMIC packets. Only lower 8 bits are used for Raptor.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_PKT_COSr 0x00000730

#define BCM56218_A0_CMIC_PKT_COSr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_PKT_COS.
 *
 */
typedef union BCM56218_A0_CMIC_PKT_COSr_s {
	uint32_t v[1];
	uint32_t cmic_pkt_cos[1];
	uint32_t _cmic_pkt_cos;
} BCM56218_A0_CMIC_PKT_COSr_t;

#define BCM56218_A0_CMIC_PKT_COSr_CLR(r) (r).cmic_pkt_cos[0] = 0
#define BCM56218_A0_CMIC_PKT_COSr_SET(r,d) (r).cmic_pkt_cos[0] = d
#define BCM56218_A0_CMIC_PKT_COSr_GET(r) (r).cmic_pkt_cos[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_PKT_COSr_COSf_GET(r) (((r).cmic_pkt_cos[0]) & 0xffff)
#define BCM56218_A0_CMIC_PKT_COSr_COSf_SET(r,f) (r).cmic_pkt_cos[0]=(((r).cmic_pkt_cos[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56218_A0_CMIC_PKT_COSr_RESERVEDf_GET(r) ((((r).cmic_pkt_cos[0]) >> 16) & 0xffff)
#define BCM56218_A0_CMIC_PKT_COSr_RESERVEDf_SET(r,f) (r).cmic_pkt_cos[0]=(((r).cmic_pkt_cos[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access CMIC_PKT_COS.
 *
 */
#define BCM56218_A0_READ_CMIC_PKT_COSr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_PKT_COSr,r._cmic_pkt_cos)
#define BCM56218_A0_WRITE_CMIC_PKT_COSr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_PKT_COSr,r._cmic_pkt_cos)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_PKT_COSr BCM56218_A0_CMIC_PKT_COSr
#define CMIC_PKT_COSr_SIZE BCM56218_A0_CMIC_PKT_COSr_SIZE
typedef BCM56218_A0_CMIC_PKT_COSr_t CMIC_PKT_COSr_t;
#define CMIC_PKT_COSr_CLR BCM56218_A0_CMIC_PKT_COSr_CLR
#define CMIC_PKT_COSr_SET BCM56218_A0_CMIC_PKT_COSr_SET
#define CMIC_PKT_COSr_GET BCM56218_A0_CMIC_PKT_COSr_GET
#define CMIC_PKT_COSr_COSf_GET BCM56218_A0_CMIC_PKT_COSr_COSf_GET
#define CMIC_PKT_COSr_COSf_SET BCM56218_A0_CMIC_PKT_COSr_COSf_SET
#define CMIC_PKT_COSr_RESERVEDf_GET BCM56218_A0_CMIC_PKT_COSr_RESERVEDf_GET
#define CMIC_PKT_COSr_RESERVEDf_SET BCM56218_A0_CMIC_PKT_COSr_RESERVEDf_SET
#define READ_CMIC_PKT_COSr BCM56218_A0_READ_CMIC_PKT_COSr
#define WRITE_CMIC_PKT_COSr BCM56218_A0_WRITE_CMIC_PKT_COSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_PKT_COSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_PKT_COUNT_FROMCPU
 * BLOCKS:   CMIC
 * DESC:     Counter: number of FROMCPU_PACKET packets received
        (without module header)

 * SIZE:     32
 * FIELDS:
 *     COUNT            Count
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_PKT_COUNT_FROMCPUr 0x000001cc

#define BCM56218_A0_CMIC_PKT_COUNT_FROMCPUr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_PKT_COUNT_FROMCPU.
 *
 */
typedef union BCM56218_A0_CMIC_PKT_COUNT_FROMCPUr_s {
	uint32_t v[1];
	uint32_t cmic_pkt_count_fromcpu[1];
	uint32_t _cmic_pkt_count_fromcpu;
} BCM56218_A0_CMIC_PKT_COUNT_FROMCPUr_t;

#define BCM56218_A0_CMIC_PKT_COUNT_FROMCPUr_CLR(r) (r).cmic_pkt_count_fromcpu[0] = 0
#define BCM56218_A0_CMIC_PKT_COUNT_FROMCPUr_SET(r,d) (r).cmic_pkt_count_fromcpu[0] = d
#define BCM56218_A0_CMIC_PKT_COUNT_FROMCPUr_GET(r) (r).cmic_pkt_count_fromcpu[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_PKT_COUNT_FROMCPUr_COUNTf_GET(r) ((r).cmic_pkt_count_fromcpu[0])
#define BCM56218_A0_CMIC_PKT_COUNT_FROMCPUr_COUNTf_SET(r,f) (r).cmic_pkt_count_fromcpu[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_PKT_COUNT_FROMCPU.
 *
 */
#define BCM56218_A0_READ_CMIC_PKT_COUNT_FROMCPUr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_PKT_COUNT_FROMCPUr,r._cmic_pkt_count_fromcpu)
#define BCM56218_A0_WRITE_CMIC_PKT_COUNT_FROMCPUr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_PKT_COUNT_FROMCPUr,r._cmic_pkt_count_fromcpu)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_PKT_COUNT_FROMCPUr BCM56218_A0_CMIC_PKT_COUNT_FROMCPUr
#define CMIC_PKT_COUNT_FROMCPUr_SIZE BCM56218_A0_CMIC_PKT_COUNT_FROMCPUr_SIZE
typedef BCM56218_A0_CMIC_PKT_COUNT_FROMCPUr_t CMIC_PKT_COUNT_FROMCPUr_t;
#define CMIC_PKT_COUNT_FROMCPUr_CLR BCM56218_A0_CMIC_PKT_COUNT_FROMCPUr_CLR
#define CMIC_PKT_COUNT_FROMCPUr_SET BCM56218_A0_CMIC_PKT_COUNT_FROMCPUr_SET
#define CMIC_PKT_COUNT_FROMCPUr_GET BCM56218_A0_CMIC_PKT_COUNT_FROMCPUr_GET
#define CMIC_PKT_COUNT_FROMCPUr_COUNTf_GET BCM56218_A0_CMIC_PKT_COUNT_FROMCPUr_COUNTf_GET
#define CMIC_PKT_COUNT_FROMCPUr_COUNTf_SET BCM56218_A0_CMIC_PKT_COUNT_FROMCPUr_COUNTf_SET
#define READ_CMIC_PKT_COUNT_FROMCPUr BCM56218_A0_READ_CMIC_PKT_COUNT_FROMCPUr
#define WRITE_CMIC_PKT_COUNT_FROMCPUr BCM56218_A0_WRITE_CMIC_PKT_COUNT_FROMCPUr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_PKT_COUNT_FROMCPUr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_PKT_COUNT_FROMCPU_MH
 * BLOCKS:   CMIC
 * DESC:     Counter: number of FROMCPU_PACKET packets received
        (with module header)

 * SIZE:     32
 * FIELDS:
 *     COUNT            Count
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_PKT_COUNT_FROMCPU_MHr 0x000001c8

#define BCM56218_A0_CMIC_PKT_COUNT_FROMCPU_MHr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_PKT_COUNT_FROMCPU_MH.
 *
 */
typedef union BCM56218_A0_CMIC_PKT_COUNT_FROMCPU_MHr_s {
	uint32_t v[1];
	uint32_t cmic_pkt_count_fromcpu_mh[1];
	uint32_t _cmic_pkt_count_fromcpu_mh;
} BCM56218_A0_CMIC_PKT_COUNT_FROMCPU_MHr_t;

#define BCM56218_A0_CMIC_PKT_COUNT_FROMCPU_MHr_CLR(r) (r).cmic_pkt_count_fromcpu_mh[0] = 0
#define BCM56218_A0_CMIC_PKT_COUNT_FROMCPU_MHr_SET(r,d) (r).cmic_pkt_count_fromcpu_mh[0] = d
#define BCM56218_A0_CMIC_PKT_COUNT_FROMCPU_MHr_GET(r) (r).cmic_pkt_count_fromcpu_mh[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_PKT_COUNT_FROMCPU_MHr_COUNTf_GET(r) ((r).cmic_pkt_count_fromcpu_mh[0])
#define BCM56218_A0_CMIC_PKT_COUNT_FROMCPU_MHr_COUNTf_SET(r,f) (r).cmic_pkt_count_fromcpu_mh[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_PKT_COUNT_FROMCPU_MH.
 *
 */
#define BCM56218_A0_READ_CMIC_PKT_COUNT_FROMCPU_MHr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_PKT_COUNT_FROMCPU_MHr,r._cmic_pkt_count_fromcpu_mh)
#define BCM56218_A0_WRITE_CMIC_PKT_COUNT_FROMCPU_MHr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_PKT_COUNT_FROMCPU_MHr,r._cmic_pkt_count_fromcpu_mh)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_PKT_COUNT_FROMCPU_MHr BCM56218_A0_CMIC_PKT_COUNT_FROMCPU_MHr
#define CMIC_PKT_COUNT_FROMCPU_MHr_SIZE BCM56218_A0_CMIC_PKT_COUNT_FROMCPU_MHr_SIZE
typedef BCM56218_A0_CMIC_PKT_COUNT_FROMCPU_MHr_t CMIC_PKT_COUNT_FROMCPU_MHr_t;
#define CMIC_PKT_COUNT_FROMCPU_MHr_CLR BCM56218_A0_CMIC_PKT_COUNT_FROMCPU_MHr_CLR
#define CMIC_PKT_COUNT_FROMCPU_MHr_SET BCM56218_A0_CMIC_PKT_COUNT_FROMCPU_MHr_SET
#define CMIC_PKT_COUNT_FROMCPU_MHr_GET BCM56218_A0_CMIC_PKT_COUNT_FROMCPU_MHr_GET
#define CMIC_PKT_COUNT_FROMCPU_MHr_COUNTf_GET BCM56218_A0_CMIC_PKT_COUNT_FROMCPU_MHr_COUNTf_GET
#define CMIC_PKT_COUNT_FROMCPU_MHr_COUNTf_SET BCM56218_A0_CMIC_PKT_COUNT_FROMCPU_MHr_COUNTf_SET
#define READ_CMIC_PKT_COUNT_FROMCPU_MHr BCM56218_A0_READ_CMIC_PKT_COUNT_FROMCPU_MHr
#define WRITE_CMIC_PKT_COUNT_FROMCPU_MHr BCM56218_A0_WRITE_CMIC_PKT_COUNT_FROMCPU_MHr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_PKT_COUNT_FROMCPU_MHr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_PKT_COUNT_SCHAN
 * BLOCKS:   CMIC
 * DESC:     Counter: number of SCHAN_REQUEST packets received

 * SIZE:     32
 * FIELDS:
 *     COUNT            Count
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_PKT_COUNT_SCHANr 0x000001c0

#define BCM56218_A0_CMIC_PKT_COUNT_SCHANr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_PKT_COUNT_SCHAN.
 *
 */
typedef union BCM56218_A0_CMIC_PKT_COUNT_SCHANr_s {
	uint32_t v[1];
	uint32_t cmic_pkt_count_schan[1];
	uint32_t _cmic_pkt_count_schan;
} BCM56218_A0_CMIC_PKT_COUNT_SCHANr_t;

#define BCM56218_A0_CMIC_PKT_COUNT_SCHANr_CLR(r) (r).cmic_pkt_count_schan[0] = 0
#define BCM56218_A0_CMIC_PKT_COUNT_SCHANr_SET(r,d) (r).cmic_pkt_count_schan[0] = d
#define BCM56218_A0_CMIC_PKT_COUNT_SCHANr_GET(r) (r).cmic_pkt_count_schan[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_PKT_COUNT_SCHANr_COUNTf_GET(r) ((r).cmic_pkt_count_schan[0])
#define BCM56218_A0_CMIC_PKT_COUNT_SCHANr_COUNTf_SET(r,f) (r).cmic_pkt_count_schan[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_PKT_COUNT_SCHAN.
 *
 */
#define BCM56218_A0_READ_CMIC_PKT_COUNT_SCHANr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_PKT_COUNT_SCHANr,r._cmic_pkt_count_schan)
#define BCM56218_A0_WRITE_CMIC_PKT_COUNT_SCHANr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_PKT_COUNT_SCHANr,r._cmic_pkt_count_schan)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_PKT_COUNT_SCHANr BCM56218_A0_CMIC_PKT_COUNT_SCHANr
#define CMIC_PKT_COUNT_SCHANr_SIZE BCM56218_A0_CMIC_PKT_COUNT_SCHANr_SIZE
typedef BCM56218_A0_CMIC_PKT_COUNT_SCHANr_t CMIC_PKT_COUNT_SCHANr_t;
#define CMIC_PKT_COUNT_SCHANr_CLR BCM56218_A0_CMIC_PKT_COUNT_SCHANr_CLR
#define CMIC_PKT_COUNT_SCHANr_SET BCM56218_A0_CMIC_PKT_COUNT_SCHANr_SET
#define CMIC_PKT_COUNT_SCHANr_GET BCM56218_A0_CMIC_PKT_COUNT_SCHANr_GET
#define CMIC_PKT_COUNT_SCHANr_COUNTf_GET BCM56218_A0_CMIC_PKT_COUNT_SCHANr_COUNTf_GET
#define CMIC_PKT_COUNT_SCHANr_COUNTf_SET BCM56218_A0_CMIC_PKT_COUNT_SCHANr_COUNTf_SET
#define READ_CMIC_PKT_COUNT_SCHANr BCM56218_A0_READ_CMIC_PKT_COUNT_SCHANr
#define WRITE_CMIC_PKT_COUNT_SCHANr BCM56218_A0_WRITE_CMIC_PKT_COUNT_SCHANr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_PKT_COUNT_SCHANr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_PKT_COUNT_SCHAN_REP
 * BLOCKS:   CMIC
 * DESC:     Counter: number of SCHAN_REPLY packets sent

 * SIZE:     32
 * FIELDS:
 *     COUNT            Count
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_PKT_COUNT_SCHAN_REPr 0x000001c4

#define BCM56218_A0_CMIC_PKT_COUNT_SCHAN_REPr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_PKT_COUNT_SCHAN_REP.
 *
 */
typedef union BCM56218_A0_CMIC_PKT_COUNT_SCHAN_REPr_s {
	uint32_t v[1];
	uint32_t cmic_pkt_count_schan_rep[1];
	uint32_t _cmic_pkt_count_schan_rep;
} BCM56218_A0_CMIC_PKT_COUNT_SCHAN_REPr_t;

#define BCM56218_A0_CMIC_PKT_COUNT_SCHAN_REPr_CLR(r) (r).cmic_pkt_count_schan_rep[0] = 0
#define BCM56218_A0_CMIC_PKT_COUNT_SCHAN_REPr_SET(r,d) (r).cmic_pkt_count_schan_rep[0] = d
#define BCM56218_A0_CMIC_PKT_COUNT_SCHAN_REPr_GET(r) (r).cmic_pkt_count_schan_rep[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_PKT_COUNT_SCHAN_REPr_COUNTf_GET(r) ((r).cmic_pkt_count_schan_rep[0])
#define BCM56218_A0_CMIC_PKT_COUNT_SCHAN_REPr_COUNTf_SET(r,f) (r).cmic_pkt_count_schan_rep[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_PKT_COUNT_SCHAN_REP.
 *
 */
#define BCM56218_A0_READ_CMIC_PKT_COUNT_SCHAN_REPr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_PKT_COUNT_SCHAN_REPr,r._cmic_pkt_count_schan_rep)
#define BCM56218_A0_WRITE_CMIC_PKT_COUNT_SCHAN_REPr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_PKT_COUNT_SCHAN_REPr,r._cmic_pkt_count_schan_rep)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_PKT_COUNT_SCHAN_REPr BCM56218_A0_CMIC_PKT_COUNT_SCHAN_REPr
#define CMIC_PKT_COUNT_SCHAN_REPr_SIZE BCM56218_A0_CMIC_PKT_COUNT_SCHAN_REPr_SIZE
typedef BCM56218_A0_CMIC_PKT_COUNT_SCHAN_REPr_t CMIC_PKT_COUNT_SCHAN_REPr_t;
#define CMIC_PKT_COUNT_SCHAN_REPr_CLR BCM56218_A0_CMIC_PKT_COUNT_SCHAN_REPr_CLR
#define CMIC_PKT_COUNT_SCHAN_REPr_SET BCM56218_A0_CMIC_PKT_COUNT_SCHAN_REPr_SET
#define CMIC_PKT_COUNT_SCHAN_REPr_GET BCM56218_A0_CMIC_PKT_COUNT_SCHAN_REPr_GET
#define CMIC_PKT_COUNT_SCHAN_REPr_COUNTf_GET BCM56218_A0_CMIC_PKT_COUNT_SCHAN_REPr_COUNTf_GET
#define CMIC_PKT_COUNT_SCHAN_REPr_COUNTf_SET BCM56218_A0_CMIC_PKT_COUNT_SCHAN_REPr_COUNTf_SET
#define READ_CMIC_PKT_COUNT_SCHAN_REPr BCM56218_A0_READ_CMIC_PKT_COUNT_SCHAN_REPr
#define WRITE_CMIC_PKT_COUNT_SCHAN_REPr BCM56218_A0_WRITE_CMIC_PKT_COUNT_SCHAN_REPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_PKT_COUNT_SCHAN_REPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_PKT_COUNT_TOCPUD
 * BLOCKS:   CMIC
 * DESC:     Counter: number of packets sent by means of
        CMIC_PKT_REASON_DIRECT matching (full length)

 * SIZE:     32
 * FIELDS:
 *     COUNT            Count
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_PKT_COUNT_TOCPUDr 0x000001d4

#define BCM56218_A0_CMIC_PKT_COUNT_TOCPUDr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_PKT_COUNT_TOCPUD.
 *
 */
typedef union BCM56218_A0_CMIC_PKT_COUNT_TOCPUDr_s {
	uint32_t v[1];
	uint32_t cmic_pkt_count_tocpud[1];
	uint32_t _cmic_pkt_count_tocpud;
} BCM56218_A0_CMIC_PKT_COUNT_TOCPUDr_t;

#define BCM56218_A0_CMIC_PKT_COUNT_TOCPUDr_CLR(r) (r).cmic_pkt_count_tocpud[0] = 0
#define BCM56218_A0_CMIC_PKT_COUNT_TOCPUDr_SET(r,d) (r).cmic_pkt_count_tocpud[0] = d
#define BCM56218_A0_CMIC_PKT_COUNT_TOCPUDr_GET(r) (r).cmic_pkt_count_tocpud[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_PKT_COUNT_TOCPUDr_COUNTf_GET(r) ((r).cmic_pkt_count_tocpud[0])
#define BCM56218_A0_CMIC_PKT_COUNT_TOCPUDr_COUNTf_SET(r,f) (r).cmic_pkt_count_tocpud[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_PKT_COUNT_TOCPUD.
 *
 */
#define BCM56218_A0_READ_CMIC_PKT_COUNT_TOCPUDr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_PKT_COUNT_TOCPUDr,r._cmic_pkt_count_tocpud)
#define BCM56218_A0_WRITE_CMIC_PKT_COUNT_TOCPUDr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_PKT_COUNT_TOCPUDr,r._cmic_pkt_count_tocpud)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_PKT_COUNT_TOCPUDr BCM56218_A0_CMIC_PKT_COUNT_TOCPUDr
#define CMIC_PKT_COUNT_TOCPUDr_SIZE BCM56218_A0_CMIC_PKT_COUNT_TOCPUDr_SIZE
typedef BCM56218_A0_CMIC_PKT_COUNT_TOCPUDr_t CMIC_PKT_COUNT_TOCPUDr_t;
#define CMIC_PKT_COUNT_TOCPUDr_CLR BCM56218_A0_CMIC_PKT_COUNT_TOCPUDr_CLR
#define CMIC_PKT_COUNT_TOCPUDr_SET BCM56218_A0_CMIC_PKT_COUNT_TOCPUDr_SET
#define CMIC_PKT_COUNT_TOCPUDr_GET BCM56218_A0_CMIC_PKT_COUNT_TOCPUDr_GET
#define CMIC_PKT_COUNT_TOCPUDr_COUNTf_GET BCM56218_A0_CMIC_PKT_COUNT_TOCPUDr_COUNTf_GET
#define CMIC_PKT_COUNT_TOCPUDr_COUNTf_SET BCM56218_A0_CMIC_PKT_COUNT_TOCPUDr_COUNTf_SET
#define READ_CMIC_PKT_COUNT_TOCPUDr BCM56218_A0_READ_CMIC_PKT_COUNT_TOCPUDr
#define WRITE_CMIC_PKT_COUNT_TOCPUDr BCM56218_A0_WRITE_CMIC_PKT_COUNT_TOCPUDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_PKT_COUNT_TOCPUDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_PKT_COUNT_TOCPUDM
 * BLOCKS:   CMIC
 * DESC:     Counter: number of packets sent by means of
        CMIC_PKT_REASON_DIRECT matching (mini length)

 * SIZE:     32
 * FIELDS:
 *     COUNT            Count
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_PKT_COUNT_TOCPUDMr 0x000001d0

#define BCM56218_A0_CMIC_PKT_COUNT_TOCPUDMr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_PKT_COUNT_TOCPUDM.
 *
 */
typedef union BCM56218_A0_CMIC_PKT_COUNT_TOCPUDMr_s {
	uint32_t v[1];
	uint32_t cmic_pkt_count_tocpudm[1];
	uint32_t _cmic_pkt_count_tocpudm;
} BCM56218_A0_CMIC_PKT_COUNT_TOCPUDMr_t;

#define BCM56218_A0_CMIC_PKT_COUNT_TOCPUDMr_CLR(r) (r).cmic_pkt_count_tocpudm[0] = 0
#define BCM56218_A0_CMIC_PKT_COUNT_TOCPUDMr_SET(r,d) (r).cmic_pkt_count_tocpudm[0] = d
#define BCM56218_A0_CMIC_PKT_COUNT_TOCPUDMr_GET(r) (r).cmic_pkt_count_tocpudm[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_PKT_COUNT_TOCPUDMr_COUNTf_GET(r) ((r).cmic_pkt_count_tocpudm[0])
#define BCM56218_A0_CMIC_PKT_COUNT_TOCPUDMr_COUNTf_SET(r,f) (r).cmic_pkt_count_tocpudm[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_PKT_COUNT_TOCPUDM.
 *
 */
#define BCM56218_A0_READ_CMIC_PKT_COUNT_TOCPUDMr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_PKT_COUNT_TOCPUDMr,r._cmic_pkt_count_tocpudm)
#define BCM56218_A0_WRITE_CMIC_PKT_COUNT_TOCPUDMr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_PKT_COUNT_TOCPUDMr,r._cmic_pkt_count_tocpudm)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_PKT_COUNT_TOCPUDMr BCM56218_A0_CMIC_PKT_COUNT_TOCPUDMr
#define CMIC_PKT_COUNT_TOCPUDMr_SIZE BCM56218_A0_CMIC_PKT_COUNT_TOCPUDMr_SIZE
typedef BCM56218_A0_CMIC_PKT_COUNT_TOCPUDMr_t CMIC_PKT_COUNT_TOCPUDMr_t;
#define CMIC_PKT_COUNT_TOCPUDMr_CLR BCM56218_A0_CMIC_PKT_COUNT_TOCPUDMr_CLR
#define CMIC_PKT_COUNT_TOCPUDMr_SET BCM56218_A0_CMIC_PKT_COUNT_TOCPUDMr_SET
#define CMIC_PKT_COUNT_TOCPUDMr_GET BCM56218_A0_CMIC_PKT_COUNT_TOCPUDMr_GET
#define CMIC_PKT_COUNT_TOCPUDMr_COUNTf_GET BCM56218_A0_CMIC_PKT_COUNT_TOCPUDMr_COUNTf_GET
#define CMIC_PKT_COUNT_TOCPUDMr_COUNTf_SET BCM56218_A0_CMIC_PKT_COUNT_TOCPUDMr_COUNTf_SET
#define READ_CMIC_PKT_COUNT_TOCPUDMr BCM56218_A0_READ_CMIC_PKT_COUNT_TOCPUDMr
#define WRITE_CMIC_PKT_COUNT_TOCPUDMr BCM56218_A0_WRITE_CMIC_PKT_COUNT_TOCPUDMr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_PKT_COUNT_TOCPUDMr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_PKT_COUNT_TOCPUE
 * BLOCKS:   CMIC
 * DESC:     Counter: number of packets sent by means of
        CMIC_PKT_REASON matching (full length)

 * SIZE:     32
 * FIELDS:
 *     COUNT            Count
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_PKT_COUNT_TOCPUEr 0x000001dc

#define BCM56218_A0_CMIC_PKT_COUNT_TOCPUEr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_PKT_COUNT_TOCPUE.
 *
 */
typedef union BCM56218_A0_CMIC_PKT_COUNT_TOCPUEr_s {
	uint32_t v[1];
	uint32_t cmic_pkt_count_tocpue[1];
	uint32_t _cmic_pkt_count_tocpue;
} BCM56218_A0_CMIC_PKT_COUNT_TOCPUEr_t;

#define BCM56218_A0_CMIC_PKT_COUNT_TOCPUEr_CLR(r) (r).cmic_pkt_count_tocpue[0] = 0
#define BCM56218_A0_CMIC_PKT_COUNT_TOCPUEr_SET(r,d) (r).cmic_pkt_count_tocpue[0] = d
#define BCM56218_A0_CMIC_PKT_COUNT_TOCPUEr_GET(r) (r).cmic_pkt_count_tocpue[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_PKT_COUNT_TOCPUEr_COUNTf_GET(r) ((r).cmic_pkt_count_tocpue[0])
#define BCM56218_A0_CMIC_PKT_COUNT_TOCPUEr_COUNTf_SET(r,f) (r).cmic_pkt_count_tocpue[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_PKT_COUNT_TOCPUE.
 *
 */
#define BCM56218_A0_READ_CMIC_PKT_COUNT_TOCPUEr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_PKT_COUNT_TOCPUEr,r._cmic_pkt_count_tocpue)
#define BCM56218_A0_WRITE_CMIC_PKT_COUNT_TOCPUEr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_PKT_COUNT_TOCPUEr,r._cmic_pkt_count_tocpue)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_PKT_COUNT_TOCPUEr BCM56218_A0_CMIC_PKT_COUNT_TOCPUEr
#define CMIC_PKT_COUNT_TOCPUEr_SIZE BCM56218_A0_CMIC_PKT_COUNT_TOCPUEr_SIZE
typedef BCM56218_A0_CMIC_PKT_COUNT_TOCPUEr_t CMIC_PKT_COUNT_TOCPUEr_t;
#define CMIC_PKT_COUNT_TOCPUEr_CLR BCM56218_A0_CMIC_PKT_COUNT_TOCPUEr_CLR
#define CMIC_PKT_COUNT_TOCPUEr_SET BCM56218_A0_CMIC_PKT_COUNT_TOCPUEr_SET
#define CMIC_PKT_COUNT_TOCPUEr_GET BCM56218_A0_CMIC_PKT_COUNT_TOCPUEr_GET
#define CMIC_PKT_COUNT_TOCPUEr_COUNTf_GET BCM56218_A0_CMIC_PKT_COUNT_TOCPUEr_COUNTf_GET
#define CMIC_PKT_COUNT_TOCPUEr_COUNTf_SET BCM56218_A0_CMIC_PKT_COUNT_TOCPUEr_COUNTf_SET
#define READ_CMIC_PKT_COUNT_TOCPUEr BCM56218_A0_READ_CMIC_PKT_COUNT_TOCPUEr
#define WRITE_CMIC_PKT_COUNT_TOCPUEr BCM56218_A0_WRITE_CMIC_PKT_COUNT_TOCPUEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_PKT_COUNT_TOCPUEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_PKT_COUNT_TOCPUEM
 * BLOCKS:   CMIC
 * DESC:     Counter: number of packets sent by means of
        CMIC_PKT_REASON matching (mini length)

 * SIZE:     32
 * FIELDS:
 *     COUNT            Count
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_PKT_COUNT_TOCPUEMr 0x000001d8

#define BCM56218_A0_CMIC_PKT_COUNT_TOCPUEMr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_PKT_COUNT_TOCPUEM.
 *
 */
typedef union BCM56218_A0_CMIC_PKT_COUNT_TOCPUEMr_s {
	uint32_t v[1];
	uint32_t cmic_pkt_count_tocpuem[1];
	uint32_t _cmic_pkt_count_tocpuem;
} BCM56218_A0_CMIC_PKT_COUNT_TOCPUEMr_t;

#define BCM56218_A0_CMIC_PKT_COUNT_TOCPUEMr_CLR(r) (r).cmic_pkt_count_tocpuem[0] = 0
#define BCM56218_A0_CMIC_PKT_COUNT_TOCPUEMr_SET(r,d) (r).cmic_pkt_count_tocpuem[0] = d
#define BCM56218_A0_CMIC_PKT_COUNT_TOCPUEMr_GET(r) (r).cmic_pkt_count_tocpuem[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_PKT_COUNT_TOCPUEMr_COUNTf_GET(r) ((r).cmic_pkt_count_tocpuem[0])
#define BCM56218_A0_CMIC_PKT_COUNT_TOCPUEMr_COUNTf_SET(r,f) (r).cmic_pkt_count_tocpuem[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_PKT_COUNT_TOCPUEM.
 *
 */
#define BCM56218_A0_READ_CMIC_PKT_COUNT_TOCPUEMr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_PKT_COUNT_TOCPUEMr,r._cmic_pkt_count_tocpuem)
#define BCM56218_A0_WRITE_CMIC_PKT_COUNT_TOCPUEMr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_PKT_COUNT_TOCPUEMr,r._cmic_pkt_count_tocpuem)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_PKT_COUNT_TOCPUEMr BCM56218_A0_CMIC_PKT_COUNT_TOCPUEMr
#define CMIC_PKT_COUNT_TOCPUEMr_SIZE BCM56218_A0_CMIC_PKT_COUNT_TOCPUEMr_SIZE
typedef BCM56218_A0_CMIC_PKT_COUNT_TOCPUEMr_t CMIC_PKT_COUNT_TOCPUEMr_t;
#define CMIC_PKT_COUNT_TOCPUEMr_CLR BCM56218_A0_CMIC_PKT_COUNT_TOCPUEMr_CLR
#define CMIC_PKT_COUNT_TOCPUEMr_SET BCM56218_A0_CMIC_PKT_COUNT_TOCPUEMr_SET
#define CMIC_PKT_COUNT_TOCPUEMr_GET BCM56218_A0_CMIC_PKT_COUNT_TOCPUEMr_GET
#define CMIC_PKT_COUNT_TOCPUEMr_COUNTf_GET BCM56218_A0_CMIC_PKT_COUNT_TOCPUEMr_COUNTf_GET
#define CMIC_PKT_COUNT_TOCPUEMr_COUNTf_SET BCM56218_A0_CMIC_PKT_COUNT_TOCPUEMr_COUNTf_SET
#define READ_CMIC_PKT_COUNT_TOCPUEMr BCM56218_A0_READ_CMIC_PKT_COUNT_TOCPUEMr
#define WRITE_CMIC_PKT_COUNT_TOCPUEMr BCM56218_A0_WRITE_CMIC_PKT_COUNT_TOCPUEMr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_PKT_COUNT_TOCPUEMr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_PKT_COUNT_TOCPUN
 * BLOCKS:   CMIC
 * DESC:     Counter: number of packets dropped because they did not match
        CMIC_PKT_REASON* and there was no PCI bus or internal bus
        available.


 * SIZE:     32
 * FIELDS:
 *     COUNT            Count
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_PKT_COUNT_TOCPUNr 0x000001e0

#define BCM56218_A0_CMIC_PKT_COUNT_TOCPUNr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_PKT_COUNT_TOCPUN.
 *
 */
typedef union BCM56218_A0_CMIC_PKT_COUNT_TOCPUNr_s {
	uint32_t v[1];
	uint32_t cmic_pkt_count_tocpun[1];
	uint32_t _cmic_pkt_count_tocpun;
} BCM56218_A0_CMIC_PKT_COUNT_TOCPUNr_t;

#define BCM56218_A0_CMIC_PKT_COUNT_TOCPUNr_CLR(r) (r).cmic_pkt_count_tocpun[0] = 0
#define BCM56218_A0_CMIC_PKT_COUNT_TOCPUNr_SET(r,d) (r).cmic_pkt_count_tocpun[0] = d
#define BCM56218_A0_CMIC_PKT_COUNT_TOCPUNr_GET(r) (r).cmic_pkt_count_tocpun[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_PKT_COUNT_TOCPUNr_COUNTf_GET(r) ((r).cmic_pkt_count_tocpun[0])
#define BCM56218_A0_CMIC_PKT_COUNT_TOCPUNr_COUNTf_SET(r,f) (r).cmic_pkt_count_tocpun[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_PKT_COUNT_TOCPUN.
 *
 */
#define BCM56218_A0_READ_CMIC_PKT_COUNT_TOCPUNr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_PKT_COUNT_TOCPUNr,r._cmic_pkt_count_tocpun)
#define BCM56218_A0_WRITE_CMIC_PKT_COUNT_TOCPUNr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_PKT_COUNT_TOCPUNr,r._cmic_pkt_count_tocpun)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_PKT_COUNT_TOCPUNr BCM56218_A0_CMIC_PKT_COUNT_TOCPUNr
#define CMIC_PKT_COUNT_TOCPUNr_SIZE BCM56218_A0_CMIC_PKT_COUNT_TOCPUNr_SIZE
typedef BCM56218_A0_CMIC_PKT_COUNT_TOCPUNr_t CMIC_PKT_COUNT_TOCPUNr_t;
#define CMIC_PKT_COUNT_TOCPUNr_CLR BCM56218_A0_CMIC_PKT_COUNT_TOCPUNr_CLR
#define CMIC_PKT_COUNT_TOCPUNr_SET BCM56218_A0_CMIC_PKT_COUNT_TOCPUNr_SET
#define CMIC_PKT_COUNT_TOCPUNr_GET BCM56218_A0_CMIC_PKT_COUNT_TOCPUNr_GET
#define CMIC_PKT_COUNT_TOCPUNr_COUNTf_GET BCM56218_A0_CMIC_PKT_COUNT_TOCPUNr_COUNTf_GET
#define CMIC_PKT_COUNT_TOCPUNr_COUNTf_SET BCM56218_A0_CMIC_PKT_COUNT_TOCPUNr_COUNTf_SET
#define READ_CMIC_PKT_COUNT_TOCPUNr BCM56218_A0_READ_CMIC_PKT_COUNT_TOCPUNr
#define WRITE_CMIC_PKT_COUNT_TOCPUNr BCM56218_A0_WRITE_CMIC_PKT_COUNT_TOCPUNr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_PKT_COUNT_TOCPUNr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_PKT_CTRL
 * BLOCKS:   CMIC
 * DESC:     CMIC Remote packet Control Register

 * SIZE:     32
 * FIELDS:
 *     ENABLE_SCHAN_REQUEST Enable Remote PIO
 *     ENABLE_FROMCPU_PACKET Enable Remote packets
 *     ENABLE_TOCPU_PACKET Enable reinjection to Remote CPU
 *     VLAN_MATCH       Enable match/check VLAN Tag of CMIC Packet
 *     LMAC0_MATCH      Enable match/check of CMIC Packet MAC Address to Local MAC Address 0
 *     LMAC1_MATCH      Enable match/check of CMIC Packet MAC Address to Local MAC Address 1
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_PKT_CTRLr 0x00000714

#define BCM56218_A0_CMIC_PKT_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_PKT_CTRL.
 *
 */
typedef union BCM56218_A0_CMIC_PKT_CTRLr_s {
	uint32_t v[1];
	uint32_t cmic_pkt_ctrl[1];
	uint32_t _cmic_pkt_ctrl;
} BCM56218_A0_CMIC_PKT_CTRLr_t;

#define BCM56218_A0_CMIC_PKT_CTRLr_CLR(r) (r).cmic_pkt_ctrl[0] = 0
#define BCM56218_A0_CMIC_PKT_CTRLr_SET(r,d) (r).cmic_pkt_ctrl[0] = d
#define BCM56218_A0_CMIC_PKT_CTRLr_GET(r) (r).cmic_pkt_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_PKT_CTRLr_ENABLE_SCHAN_REQUESTf_GET(r) (((r).cmic_pkt_ctrl[0]) & 0x1)
#define BCM56218_A0_CMIC_PKT_CTRLr_ENABLE_SCHAN_REQUESTf_SET(r,f) (r).cmic_pkt_ctrl[0]=(((r).cmic_pkt_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_CMIC_PKT_CTRLr_ENABLE_FROMCPU_PACKETf_GET(r) ((((r).cmic_pkt_ctrl[0]) >> 1) & 0x1)
#define BCM56218_A0_CMIC_PKT_CTRLr_ENABLE_FROMCPU_PACKETf_SET(r,f) (r).cmic_pkt_ctrl[0]=(((r).cmic_pkt_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_CMIC_PKT_CTRLr_ENABLE_TOCPU_PACKETf_GET(r) ((((r).cmic_pkt_ctrl[0]) >> 2) & 0x1)
#define BCM56218_A0_CMIC_PKT_CTRLr_ENABLE_TOCPU_PACKETf_SET(r,f) (r).cmic_pkt_ctrl[0]=(((r).cmic_pkt_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_CMIC_PKT_CTRLr_VLAN_MATCHf_GET(r) ((((r).cmic_pkt_ctrl[0]) >> 3) & 0x1)
#define BCM56218_A0_CMIC_PKT_CTRLr_VLAN_MATCHf_SET(r,f) (r).cmic_pkt_ctrl[0]=(((r).cmic_pkt_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56218_A0_CMIC_PKT_CTRLr_LMAC0_MATCHf_GET(r) ((((r).cmic_pkt_ctrl[0]) >> 4) & 0x1)
#define BCM56218_A0_CMIC_PKT_CTRLr_LMAC0_MATCHf_SET(r,f) (r).cmic_pkt_ctrl[0]=(((r).cmic_pkt_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56218_A0_CMIC_PKT_CTRLr_LMAC1_MATCHf_GET(r) ((((r).cmic_pkt_ctrl[0]) >> 5) & 0x1)
#define BCM56218_A0_CMIC_PKT_CTRLr_LMAC1_MATCHf_SET(r,f) (r).cmic_pkt_ctrl[0]=(((r).cmic_pkt_ctrl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))

/*
 * These macros can be used to access CMIC_PKT_CTRL.
 *
 */
#define BCM56218_A0_READ_CMIC_PKT_CTRLr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_PKT_CTRLr,r._cmic_pkt_ctrl)
#define BCM56218_A0_WRITE_CMIC_PKT_CTRLr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_PKT_CTRLr,r._cmic_pkt_ctrl)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_PKT_CTRLr BCM56218_A0_CMIC_PKT_CTRLr
#define CMIC_PKT_CTRLr_SIZE BCM56218_A0_CMIC_PKT_CTRLr_SIZE
typedef BCM56218_A0_CMIC_PKT_CTRLr_t CMIC_PKT_CTRLr_t;
#define CMIC_PKT_CTRLr_CLR BCM56218_A0_CMIC_PKT_CTRLr_CLR
#define CMIC_PKT_CTRLr_SET BCM56218_A0_CMIC_PKT_CTRLr_SET
#define CMIC_PKT_CTRLr_GET BCM56218_A0_CMIC_PKT_CTRLr_GET
#define CMIC_PKT_CTRLr_ENABLE_SCHAN_REQUESTf_GET BCM56218_A0_CMIC_PKT_CTRLr_ENABLE_SCHAN_REQUESTf_GET
#define CMIC_PKT_CTRLr_ENABLE_SCHAN_REQUESTf_SET BCM56218_A0_CMIC_PKT_CTRLr_ENABLE_SCHAN_REQUESTf_SET
#define CMIC_PKT_CTRLr_ENABLE_FROMCPU_PACKETf_GET BCM56218_A0_CMIC_PKT_CTRLr_ENABLE_FROMCPU_PACKETf_GET
#define CMIC_PKT_CTRLr_ENABLE_FROMCPU_PACKETf_SET BCM56218_A0_CMIC_PKT_CTRLr_ENABLE_FROMCPU_PACKETf_SET
#define CMIC_PKT_CTRLr_ENABLE_TOCPU_PACKETf_GET BCM56218_A0_CMIC_PKT_CTRLr_ENABLE_TOCPU_PACKETf_GET
#define CMIC_PKT_CTRLr_ENABLE_TOCPU_PACKETf_SET BCM56218_A0_CMIC_PKT_CTRLr_ENABLE_TOCPU_PACKETf_SET
#define CMIC_PKT_CTRLr_VLAN_MATCHf_GET BCM56218_A0_CMIC_PKT_CTRLr_VLAN_MATCHf_GET
#define CMIC_PKT_CTRLr_VLAN_MATCHf_SET BCM56218_A0_CMIC_PKT_CTRLr_VLAN_MATCHf_SET
#define CMIC_PKT_CTRLr_LMAC0_MATCHf_GET BCM56218_A0_CMIC_PKT_CTRLr_LMAC0_MATCHf_GET
#define CMIC_PKT_CTRLr_LMAC0_MATCHf_SET BCM56218_A0_CMIC_PKT_CTRLr_LMAC0_MATCHf_SET
#define CMIC_PKT_CTRLr_LMAC1_MATCHf_GET BCM56218_A0_CMIC_PKT_CTRLr_LMAC1_MATCHf_GET
#define CMIC_PKT_CTRLr_LMAC1_MATCHf_SET BCM56218_A0_CMIC_PKT_CTRLr_LMAC1_MATCHf_SET
#define READ_CMIC_PKT_CTRLr BCM56218_A0_READ_CMIC_PKT_CTRLr
#define WRITE_CMIC_PKT_CTRLr BCM56218_A0_WRITE_CMIC_PKT_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_PKT_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_PKT_ETHER_SIG
 * BLOCKS:   CMIC
 * DESC:     CMIC Packet Ethertype and Signature

 * SIZE:     32
 * FIELDS:
 *     SIGNATURE        Signature
 *     ETHERTYPE        Ethertype Value
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_PKT_ETHER_SIGr 0x0000072c

#define BCM56218_A0_CMIC_PKT_ETHER_SIGr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_PKT_ETHER_SIG.
 *
 */
typedef union BCM56218_A0_CMIC_PKT_ETHER_SIGr_s {
	uint32_t v[1];
	uint32_t cmic_pkt_ether_sig[1];
	uint32_t _cmic_pkt_ether_sig;
} BCM56218_A0_CMIC_PKT_ETHER_SIGr_t;

#define BCM56218_A0_CMIC_PKT_ETHER_SIGr_CLR(r) (r).cmic_pkt_ether_sig[0] = 0
#define BCM56218_A0_CMIC_PKT_ETHER_SIGr_SET(r,d) (r).cmic_pkt_ether_sig[0] = d
#define BCM56218_A0_CMIC_PKT_ETHER_SIGr_GET(r) (r).cmic_pkt_ether_sig[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_PKT_ETHER_SIGr_SIGNATUREf_GET(r) (((r).cmic_pkt_ether_sig[0]) & 0xffff)
#define BCM56218_A0_CMIC_PKT_ETHER_SIGr_SIGNATUREf_SET(r,f) (r).cmic_pkt_ether_sig[0]=(((r).cmic_pkt_ether_sig[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56218_A0_CMIC_PKT_ETHER_SIGr_ETHERTYPEf_GET(r) ((((r).cmic_pkt_ether_sig[0]) >> 16) & 0xffff)
#define BCM56218_A0_CMIC_PKT_ETHER_SIGr_ETHERTYPEf_SET(r,f) (r).cmic_pkt_ether_sig[0]=(((r).cmic_pkt_ether_sig[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access CMIC_PKT_ETHER_SIG.
 *
 */
#define BCM56218_A0_READ_CMIC_PKT_ETHER_SIGr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_PKT_ETHER_SIGr,r._cmic_pkt_ether_sig)
#define BCM56218_A0_WRITE_CMIC_PKT_ETHER_SIGr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_PKT_ETHER_SIGr,r._cmic_pkt_ether_sig)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_PKT_ETHER_SIGr BCM56218_A0_CMIC_PKT_ETHER_SIGr
#define CMIC_PKT_ETHER_SIGr_SIZE BCM56218_A0_CMIC_PKT_ETHER_SIGr_SIZE
typedef BCM56218_A0_CMIC_PKT_ETHER_SIGr_t CMIC_PKT_ETHER_SIGr_t;
#define CMIC_PKT_ETHER_SIGr_CLR BCM56218_A0_CMIC_PKT_ETHER_SIGr_CLR
#define CMIC_PKT_ETHER_SIGr_SET BCM56218_A0_CMIC_PKT_ETHER_SIGr_SET
#define CMIC_PKT_ETHER_SIGr_GET BCM56218_A0_CMIC_PKT_ETHER_SIGr_GET
#define CMIC_PKT_ETHER_SIGr_SIGNATUREf_GET BCM56218_A0_CMIC_PKT_ETHER_SIGr_SIGNATUREf_GET
#define CMIC_PKT_ETHER_SIGr_SIGNATUREf_SET BCM56218_A0_CMIC_PKT_ETHER_SIGr_SIGNATUREf_SET
#define CMIC_PKT_ETHER_SIGr_ETHERTYPEf_GET BCM56218_A0_CMIC_PKT_ETHER_SIGr_ETHERTYPEf_GET
#define CMIC_PKT_ETHER_SIGr_ETHERTYPEf_SET BCM56218_A0_CMIC_PKT_ETHER_SIGr_ETHERTYPEf_SET
#define READ_CMIC_PKT_ETHER_SIGr BCM56218_A0_READ_CMIC_PKT_ETHER_SIGr
#define WRITE_CMIC_PKT_ETHER_SIGr BCM56218_A0_WRITE_CMIC_PKT_ETHER_SIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_PKT_ETHER_SIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_PKT_LMAC0_HI
 * BLOCKS:   CMIC
 * DESC:     CMIC Local MAC 0 Register Hi

 * SIZE:     32
 * FIELDS:
 *     MAC0_HI          Higher 15 bits of CMIC Local MAC Address 0
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_PKT_LMAC0_HIr 0x00000718

#define BCM56218_A0_CMIC_PKT_LMAC0_HIr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_PKT_LMAC0_HI.
 *
 */
typedef union BCM56218_A0_CMIC_PKT_LMAC0_HIr_s {
	uint32_t v[1];
	uint32_t cmic_pkt_lmac0_hi[1];
	uint32_t _cmic_pkt_lmac0_hi;
} BCM56218_A0_CMIC_PKT_LMAC0_HIr_t;

#define BCM56218_A0_CMIC_PKT_LMAC0_HIr_CLR(r) (r).cmic_pkt_lmac0_hi[0] = 0
#define BCM56218_A0_CMIC_PKT_LMAC0_HIr_SET(r,d) (r).cmic_pkt_lmac0_hi[0] = d
#define BCM56218_A0_CMIC_PKT_LMAC0_HIr_GET(r) (r).cmic_pkt_lmac0_hi[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_PKT_LMAC0_HIr_MAC0_HIf_GET(r) (((r).cmic_pkt_lmac0_hi[0]) & 0xffff)
#define BCM56218_A0_CMIC_PKT_LMAC0_HIr_MAC0_HIf_SET(r,f) (r).cmic_pkt_lmac0_hi[0]=(((r).cmic_pkt_lmac0_hi[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56218_A0_CMIC_PKT_LMAC0_HIr_RESERVEDf_GET(r) ((((r).cmic_pkt_lmac0_hi[0]) >> 16) & 0xffff)
#define BCM56218_A0_CMIC_PKT_LMAC0_HIr_RESERVEDf_SET(r,f) (r).cmic_pkt_lmac0_hi[0]=(((r).cmic_pkt_lmac0_hi[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access CMIC_PKT_LMAC0_HI.
 *
 */
#define BCM56218_A0_READ_CMIC_PKT_LMAC0_HIr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_PKT_LMAC0_HIr,r._cmic_pkt_lmac0_hi)
#define BCM56218_A0_WRITE_CMIC_PKT_LMAC0_HIr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_PKT_LMAC0_HIr,r._cmic_pkt_lmac0_hi)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_PKT_LMAC0_HIr BCM56218_A0_CMIC_PKT_LMAC0_HIr
#define CMIC_PKT_LMAC0_HIr_SIZE BCM56218_A0_CMIC_PKT_LMAC0_HIr_SIZE
typedef BCM56218_A0_CMIC_PKT_LMAC0_HIr_t CMIC_PKT_LMAC0_HIr_t;
#define CMIC_PKT_LMAC0_HIr_CLR BCM56218_A0_CMIC_PKT_LMAC0_HIr_CLR
#define CMIC_PKT_LMAC0_HIr_SET BCM56218_A0_CMIC_PKT_LMAC0_HIr_SET
#define CMIC_PKT_LMAC0_HIr_GET BCM56218_A0_CMIC_PKT_LMAC0_HIr_GET
#define CMIC_PKT_LMAC0_HIr_MAC0_HIf_GET BCM56218_A0_CMIC_PKT_LMAC0_HIr_MAC0_HIf_GET
#define CMIC_PKT_LMAC0_HIr_MAC0_HIf_SET BCM56218_A0_CMIC_PKT_LMAC0_HIr_MAC0_HIf_SET
#define CMIC_PKT_LMAC0_HIr_RESERVEDf_GET BCM56218_A0_CMIC_PKT_LMAC0_HIr_RESERVEDf_GET
#define CMIC_PKT_LMAC0_HIr_RESERVEDf_SET BCM56218_A0_CMIC_PKT_LMAC0_HIr_RESERVEDf_SET
#define READ_CMIC_PKT_LMAC0_HIr BCM56218_A0_READ_CMIC_PKT_LMAC0_HIr
#define WRITE_CMIC_PKT_LMAC0_HIr BCM56218_A0_WRITE_CMIC_PKT_LMAC0_HIr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_PKT_LMAC0_HIr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_PKT_LMAC0_LO
 * BLOCKS:   CMIC
 * DESC:     CMIC Local MAC 0 Register Lo

 * SIZE:     32
 * FIELDS:
 *     MAC0_LO          Lower 32 bits of CMIC Local MAC Address 0
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_PKT_LMAC0_LOr 0x0000071c

#define BCM56218_A0_CMIC_PKT_LMAC0_LOr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_PKT_LMAC0_LO.
 *
 */
typedef union BCM56218_A0_CMIC_PKT_LMAC0_LOr_s {
	uint32_t v[1];
	uint32_t cmic_pkt_lmac0_lo[1];
	uint32_t _cmic_pkt_lmac0_lo;
} BCM56218_A0_CMIC_PKT_LMAC0_LOr_t;

#define BCM56218_A0_CMIC_PKT_LMAC0_LOr_CLR(r) (r).cmic_pkt_lmac0_lo[0] = 0
#define BCM56218_A0_CMIC_PKT_LMAC0_LOr_SET(r,d) (r).cmic_pkt_lmac0_lo[0] = d
#define BCM56218_A0_CMIC_PKT_LMAC0_LOr_GET(r) (r).cmic_pkt_lmac0_lo[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_PKT_LMAC0_LOr_MAC0_LOf_GET(r) ((r).cmic_pkt_lmac0_lo[0])
#define BCM56218_A0_CMIC_PKT_LMAC0_LOr_MAC0_LOf_SET(r,f) (r).cmic_pkt_lmac0_lo[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_PKT_LMAC0_LO.
 *
 */
#define BCM56218_A0_READ_CMIC_PKT_LMAC0_LOr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_PKT_LMAC0_LOr,r._cmic_pkt_lmac0_lo)
#define BCM56218_A0_WRITE_CMIC_PKT_LMAC0_LOr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_PKT_LMAC0_LOr,r._cmic_pkt_lmac0_lo)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_PKT_LMAC0_LOr BCM56218_A0_CMIC_PKT_LMAC0_LOr
#define CMIC_PKT_LMAC0_LOr_SIZE BCM56218_A0_CMIC_PKT_LMAC0_LOr_SIZE
typedef BCM56218_A0_CMIC_PKT_LMAC0_LOr_t CMIC_PKT_LMAC0_LOr_t;
#define CMIC_PKT_LMAC0_LOr_CLR BCM56218_A0_CMIC_PKT_LMAC0_LOr_CLR
#define CMIC_PKT_LMAC0_LOr_SET BCM56218_A0_CMIC_PKT_LMAC0_LOr_SET
#define CMIC_PKT_LMAC0_LOr_GET BCM56218_A0_CMIC_PKT_LMAC0_LOr_GET
#define CMIC_PKT_LMAC0_LOr_MAC0_LOf_GET BCM56218_A0_CMIC_PKT_LMAC0_LOr_MAC0_LOf_GET
#define CMIC_PKT_LMAC0_LOr_MAC0_LOf_SET BCM56218_A0_CMIC_PKT_LMAC0_LOr_MAC0_LOf_SET
#define READ_CMIC_PKT_LMAC0_LOr BCM56218_A0_READ_CMIC_PKT_LMAC0_LOr
#define WRITE_CMIC_PKT_LMAC0_LOr BCM56218_A0_WRITE_CMIC_PKT_LMAC0_LOr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_PKT_LMAC0_LOr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_PKT_LMAC1_HI
 * BLOCKS:   CMIC
 * DESC:     CMIC Local MAC 0 Register Hi

 * SIZE:     32
 * FIELDS:
 *     MAC1_HI          Higher 15 bits of CMIC Local MAC Address 1
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_PKT_LMAC1_HIr 0x00000720

#define BCM56218_A0_CMIC_PKT_LMAC1_HIr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_PKT_LMAC1_HI.
 *
 */
typedef union BCM56218_A0_CMIC_PKT_LMAC1_HIr_s {
	uint32_t v[1];
	uint32_t cmic_pkt_lmac1_hi[1];
	uint32_t _cmic_pkt_lmac1_hi;
} BCM56218_A0_CMIC_PKT_LMAC1_HIr_t;

#define BCM56218_A0_CMIC_PKT_LMAC1_HIr_CLR(r) (r).cmic_pkt_lmac1_hi[0] = 0
#define BCM56218_A0_CMIC_PKT_LMAC1_HIr_SET(r,d) (r).cmic_pkt_lmac1_hi[0] = d
#define BCM56218_A0_CMIC_PKT_LMAC1_HIr_GET(r) (r).cmic_pkt_lmac1_hi[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_PKT_LMAC1_HIr_MAC1_HIf_GET(r) (((r).cmic_pkt_lmac1_hi[0]) & 0xffff)
#define BCM56218_A0_CMIC_PKT_LMAC1_HIr_MAC1_HIf_SET(r,f) (r).cmic_pkt_lmac1_hi[0]=(((r).cmic_pkt_lmac1_hi[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56218_A0_CMIC_PKT_LMAC1_HIr_RESERVEDf_GET(r) ((((r).cmic_pkt_lmac1_hi[0]) >> 16) & 0xffff)
#define BCM56218_A0_CMIC_PKT_LMAC1_HIr_RESERVEDf_SET(r,f) (r).cmic_pkt_lmac1_hi[0]=(((r).cmic_pkt_lmac1_hi[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access CMIC_PKT_LMAC1_HI.
 *
 */
#define BCM56218_A0_READ_CMIC_PKT_LMAC1_HIr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_PKT_LMAC1_HIr,r._cmic_pkt_lmac1_hi)
#define BCM56218_A0_WRITE_CMIC_PKT_LMAC1_HIr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_PKT_LMAC1_HIr,r._cmic_pkt_lmac1_hi)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_PKT_LMAC1_HIr BCM56218_A0_CMIC_PKT_LMAC1_HIr
#define CMIC_PKT_LMAC1_HIr_SIZE BCM56218_A0_CMIC_PKT_LMAC1_HIr_SIZE
typedef BCM56218_A0_CMIC_PKT_LMAC1_HIr_t CMIC_PKT_LMAC1_HIr_t;
#define CMIC_PKT_LMAC1_HIr_CLR BCM56218_A0_CMIC_PKT_LMAC1_HIr_CLR
#define CMIC_PKT_LMAC1_HIr_SET BCM56218_A0_CMIC_PKT_LMAC1_HIr_SET
#define CMIC_PKT_LMAC1_HIr_GET BCM56218_A0_CMIC_PKT_LMAC1_HIr_GET
#define CMIC_PKT_LMAC1_HIr_MAC1_HIf_GET BCM56218_A0_CMIC_PKT_LMAC1_HIr_MAC1_HIf_GET
#define CMIC_PKT_LMAC1_HIr_MAC1_HIf_SET BCM56218_A0_CMIC_PKT_LMAC1_HIr_MAC1_HIf_SET
#define CMIC_PKT_LMAC1_HIr_RESERVEDf_GET BCM56218_A0_CMIC_PKT_LMAC1_HIr_RESERVEDf_GET
#define CMIC_PKT_LMAC1_HIr_RESERVEDf_SET BCM56218_A0_CMIC_PKT_LMAC1_HIr_RESERVEDf_SET
#define READ_CMIC_PKT_LMAC1_HIr BCM56218_A0_READ_CMIC_PKT_LMAC1_HIr
#define WRITE_CMIC_PKT_LMAC1_HIr BCM56218_A0_WRITE_CMIC_PKT_LMAC1_HIr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_PKT_LMAC1_HIr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_PKT_LMAC1_LO
 * BLOCKS:   CMIC
 * DESC:     CMIC Local MAC 0 Register Lo

 * SIZE:     32
 * FIELDS:
 *     MAC1_LO          Lower 32 bits of CMIC Local MAC Address 1
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_PKT_LMAC1_LOr 0x00000724

#define BCM56218_A0_CMIC_PKT_LMAC1_LOr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_PKT_LMAC1_LO.
 *
 */
typedef union BCM56218_A0_CMIC_PKT_LMAC1_LOr_s {
	uint32_t v[1];
	uint32_t cmic_pkt_lmac1_lo[1];
	uint32_t _cmic_pkt_lmac1_lo;
} BCM56218_A0_CMIC_PKT_LMAC1_LOr_t;

#define BCM56218_A0_CMIC_PKT_LMAC1_LOr_CLR(r) (r).cmic_pkt_lmac1_lo[0] = 0
#define BCM56218_A0_CMIC_PKT_LMAC1_LOr_SET(r,d) (r).cmic_pkt_lmac1_lo[0] = d
#define BCM56218_A0_CMIC_PKT_LMAC1_LOr_GET(r) (r).cmic_pkt_lmac1_lo[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_PKT_LMAC1_LOr_MAC1_LOf_GET(r) ((r).cmic_pkt_lmac1_lo[0])
#define BCM56218_A0_CMIC_PKT_LMAC1_LOr_MAC1_LOf_SET(r,f) (r).cmic_pkt_lmac1_lo[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_PKT_LMAC1_LO.
 *
 */
#define BCM56218_A0_READ_CMIC_PKT_LMAC1_LOr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_PKT_LMAC1_LOr,r._cmic_pkt_lmac1_lo)
#define BCM56218_A0_WRITE_CMIC_PKT_LMAC1_LOr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_PKT_LMAC1_LOr,r._cmic_pkt_lmac1_lo)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_PKT_LMAC1_LOr BCM56218_A0_CMIC_PKT_LMAC1_LOr
#define CMIC_PKT_LMAC1_LOr_SIZE BCM56218_A0_CMIC_PKT_LMAC1_LOr_SIZE
typedef BCM56218_A0_CMIC_PKT_LMAC1_LOr_t CMIC_PKT_LMAC1_LOr_t;
#define CMIC_PKT_LMAC1_LOr_CLR BCM56218_A0_CMIC_PKT_LMAC1_LOr_CLR
#define CMIC_PKT_LMAC1_LOr_SET BCM56218_A0_CMIC_PKT_LMAC1_LOr_SET
#define CMIC_PKT_LMAC1_LOr_GET BCM56218_A0_CMIC_PKT_LMAC1_LOr_GET
#define CMIC_PKT_LMAC1_LOr_MAC1_LOf_GET BCM56218_A0_CMIC_PKT_LMAC1_LOr_MAC1_LOf_GET
#define CMIC_PKT_LMAC1_LOr_MAC1_LOf_SET BCM56218_A0_CMIC_PKT_LMAC1_LOr_MAC1_LOf_SET
#define READ_CMIC_PKT_LMAC1_LOr BCM56218_A0_READ_CMIC_PKT_LMAC1_LOr
#define WRITE_CMIC_PKT_LMAC1_LOr BCM56218_A0_WRITE_CMIC_PKT_LMAC1_LOr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_PKT_LMAC1_LOr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_PKT_PORTS
 * BLOCKS:   CMIC
 * DESC:     CMIC Packet Port Bitmap Low 32 bits

 * SIZE:     32
 * FIELDS:
 *     PORTS            Lower 32 bits of port bitmap for ports allowed for Remote Packet operations.
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_PKT_PORTSr 0x00000734

#define BCM56218_A0_CMIC_PKT_PORTSr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_PKT_PORTS.
 *
 */
typedef union BCM56218_A0_CMIC_PKT_PORTSr_s {
	uint32_t v[1];
	uint32_t cmic_pkt_ports[1];
	uint32_t _cmic_pkt_ports;
} BCM56218_A0_CMIC_PKT_PORTSr_t;

#define BCM56218_A0_CMIC_PKT_PORTSr_CLR(r) (r).cmic_pkt_ports[0] = 0
#define BCM56218_A0_CMIC_PKT_PORTSr_SET(r,d) (r).cmic_pkt_ports[0] = d
#define BCM56218_A0_CMIC_PKT_PORTSr_GET(r) (r).cmic_pkt_ports[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_PKT_PORTSr_PORTSf_GET(r) ((r).cmic_pkt_ports[0])
#define BCM56218_A0_CMIC_PKT_PORTSr_PORTSf_SET(r,f) (r).cmic_pkt_ports[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_PKT_PORTS.
 *
 */
#define BCM56218_A0_READ_CMIC_PKT_PORTSr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_PKT_PORTSr,r._cmic_pkt_ports)
#define BCM56218_A0_WRITE_CMIC_PKT_PORTSr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_PKT_PORTSr,r._cmic_pkt_ports)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_PKT_PORTSr BCM56218_A0_CMIC_PKT_PORTSr
#define CMIC_PKT_PORTSr_SIZE BCM56218_A0_CMIC_PKT_PORTSr_SIZE
typedef BCM56218_A0_CMIC_PKT_PORTSr_t CMIC_PKT_PORTSr_t;
#define CMIC_PKT_PORTSr_CLR BCM56218_A0_CMIC_PKT_PORTSr_CLR
#define CMIC_PKT_PORTSr_SET BCM56218_A0_CMIC_PKT_PORTSr_SET
#define CMIC_PKT_PORTSr_GET BCM56218_A0_CMIC_PKT_PORTSr_GET
#define CMIC_PKT_PORTSr_PORTSf_GET BCM56218_A0_CMIC_PKT_PORTSr_PORTSf_GET
#define CMIC_PKT_PORTSr_PORTSf_SET BCM56218_A0_CMIC_PKT_PORTSr_PORTSf_SET
#define READ_CMIC_PKT_PORTSr BCM56218_A0_READ_CMIC_PKT_PORTSr
#define WRITE_CMIC_PKT_PORTSr BCM56218_A0_WRITE_CMIC_PKT_PORTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_PKT_PORTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_PKT_PORTS_HI
 * BLOCKS:   CMIC
 * DESC:     CMIC Packet Port Bitmap High 32 bits

 * SIZE:     32
 * FIELDS:
 *     PORTS_HI         Higher 32 bits of port bitmap for ports allowed for Remote Packet operations.
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_PKT_PORTS_HIr 0x00000738

#define BCM56218_A0_CMIC_PKT_PORTS_HIr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_PKT_PORTS_HI.
 *
 */
typedef union BCM56218_A0_CMIC_PKT_PORTS_HIr_s {
	uint32_t v[1];
	uint32_t cmic_pkt_ports_hi[1];
	uint32_t _cmic_pkt_ports_hi;
} BCM56218_A0_CMIC_PKT_PORTS_HIr_t;

#define BCM56218_A0_CMIC_PKT_PORTS_HIr_CLR(r) (r).cmic_pkt_ports_hi[0] = 0
#define BCM56218_A0_CMIC_PKT_PORTS_HIr_SET(r,d) (r).cmic_pkt_ports_hi[0] = d
#define BCM56218_A0_CMIC_PKT_PORTS_HIr_GET(r) (r).cmic_pkt_ports_hi[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_PKT_PORTS_HIr_PORTS_HIf_GET(r) ((r).cmic_pkt_ports_hi[0])
#define BCM56218_A0_CMIC_PKT_PORTS_HIr_PORTS_HIf_SET(r,f) (r).cmic_pkt_ports_hi[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_PKT_PORTS_HI.
 *
 */
#define BCM56218_A0_READ_CMIC_PKT_PORTS_HIr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_PKT_PORTS_HIr,r._cmic_pkt_ports_hi)
#define BCM56218_A0_WRITE_CMIC_PKT_PORTS_HIr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_PKT_PORTS_HIr,r._cmic_pkt_ports_hi)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_PKT_PORTS_HIr BCM56218_A0_CMIC_PKT_PORTS_HIr
#define CMIC_PKT_PORTS_HIr_SIZE BCM56218_A0_CMIC_PKT_PORTS_HIr_SIZE
typedef BCM56218_A0_CMIC_PKT_PORTS_HIr_t CMIC_PKT_PORTS_HIr_t;
#define CMIC_PKT_PORTS_HIr_CLR BCM56218_A0_CMIC_PKT_PORTS_HIr_CLR
#define CMIC_PKT_PORTS_HIr_SET BCM56218_A0_CMIC_PKT_PORTS_HIr_SET
#define CMIC_PKT_PORTS_HIr_GET BCM56218_A0_CMIC_PKT_PORTS_HIr_GET
#define CMIC_PKT_PORTS_HIr_PORTS_HIf_GET BCM56218_A0_CMIC_PKT_PORTS_HIr_PORTS_HIf_GET
#define CMIC_PKT_PORTS_HIr_PORTS_HIf_SET BCM56218_A0_CMIC_PKT_PORTS_HIr_PORTS_HIf_SET
#define READ_CMIC_PKT_PORTS_HIr BCM56218_A0_READ_CMIC_PKT_PORTS_HIr
#define WRITE_CMIC_PKT_PORTS_HIr BCM56218_A0_WRITE_CMIC_PKT_PORTS_HIr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_PKT_PORTS_HIr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_PKT_REASON
 * BLOCKS:   CMIC
 * DESC:     A bitmap of reason codes (sometimes called CPU opcodes) that cause
CMIC to reinject packets.

 * SIZE:     32
 * FIELDS:
 *     REASONS          Reason code bitmap
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_PKT_REASONr 0x00000750

#define BCM56218_A0_CMIC_PKT_REASONr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_PKT_REASON.
 *
 */
typedef union BCM56218_A0_CMIC_PKT_REASONr_s {
	uint32_t v[1];
	uint32_t cmic_pkt_reason[1];
	uint32_t _cmic_pkt_reason;
} BCM56218_A0_CMIC_PKT_REASONr_t;

#define BCM56218_A0_CMIC_PKT_REASONr_CLR(r) (r).cmic_pkt_reason[0] = 0
#define BCM56218_A0_CMIC_PKT_REASONr_SET(r,d) (r).cmic_pkt_reason[0] = d
#define BCM56218_A0_CMIC_PKT_REASONr_GET(r) (r).cmic_pkt_reason[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_PKT_REASONr_REASONSf_GET(r) ((r).cmic_pkt_reason[0])
#define BCM56218_A0_CMIC_PKT_REASONr_REASONSf_SET(r,f) (r).cmic_pkt_reason[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_PKT_REASON.
 *
 */
#define BCM56218_A0_READ_CMIC_PKT_REASONr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_PKT_REASONr,r._cmic_pkt_reason)
#define BCM56218_A0_WRITE_CMIC_PKT_REASONr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_PKT_REASONr,r._cmic_pkt_reason)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_PKT_REASONr BCM56218_A0_CMIC_PKT_REASONr
#define CMIC_PKT_REASONr_SIZE BCM56218_A0_CMIC_PKT_REASONr_SIZE
typedef BCM56218_A0_CMIC_PKT_REASONr_t CMIC_PKT_REASONr_t;
#define CMIC_PKT_REASONr_CLR BCM56218_A0_CMIC_PKT_REASONr_CLR
#define CMIC_PKT_REASONr_SET BCM56218_A0_CMIC_PKT_REASONr_SET
#define CMIC_PKT_REASONr_GET BCM56218_A0_CMIC_PKT_REASONr_GET
#define CMIC_PKT_REASONr_REASONSf_GET BCM56218_A0_CMIC_PKT_REASONr_REASONSf_GET
#define CMIC_PKT_REASONr_REASONSf_SET BCM56218_A0_CMIC_PKT_REASONr_REASONSf_SET
#define READ_CMIC_PKT_REASONr BCM56218_A0_READ_CMIC_PKT_REASONr
#define WRITE_CMIC_PKT_REASONr BCM56218_A0_WRITE_CMIC_PKT_REASONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_PKT_REASONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_PKT_REASON_DIRECT
 * BLOCKS:   CMIC
 * DESC:     A bitmap of reason codes (sometimes called CPU opcodes) that cause
CMIC to reinject Higig packets.

 * SIZE:     32
 * FIELDS:
 *     REASONS          Reason code bitmap
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_PKT_REASON_DIRECTr 0x00000754

#define BCM56218_A0_CMIC_PKT_REASON_DIRECTr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_PKT_REASON_DIRECT.
 *
 */
typedef union BCM56218_A0_CMIC_PKT_REASON_DIRECTr_s {
	uint32_t v[1];
	uint32_t cmic_pkt_reason_direct[1];
	uint32_t _cmic_pkt_reason_direct;
} BCM56218_A0_CMIC_PKT_REASON_DIRECTr_t;

#define BCM56218_A0_CMIC_PKT_REASON_DIRECTr_CLR(r) (r).cmic_pkt_reason_direct[0] = 0
#define BCM56218_A0_CMIC_PKT_REASON_DIRECTr_SET(r,d) (r).cmic_pkt_reason_direct[0] = d
#define BCM56218_A0_CMIC_PKT_REASON_DIRECTr_GET(r) (r).cmic_pkt_reason_direct[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_PKT_REASON_DIRECTr_REASONSf_GET(r) ((r).cmic_pkt_reason_direct[0])
#define BCM56218_A0_CMIC_PKT_REASON_DIRECTr_REASONSf_SET(r,f) (r).cmic_pkt_reason_direct[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_PKT_REASON_DIRECT.
 *
 */
#define BCM56218_A0_READ_CMIC_PKT_REASON_DIRECTr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_PKT_REASON_DIRECTr,r._cmic_pkt_reason_direct)
#define BCM56218_A0_WRITE_CMIC_PKT_REASON_DIRECTr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_PKT_REASON_DIRECTr,r._cmic_pkt_reason_direct)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_PKT_REASON_DIRECTr BCM56218_A0_CMIC_PKT_REASON_DIRECTr
#define CMIC_PKT_REASON_DIRECTr_SIZE BCM56218_A0_CMIC_PKT_REASON_DIRECTr_SIZE
typedef BCM56218_A0_CMIC_PKT_REASON_DIRECTr_t CMIC_PKT_REASON_DIRECTr_t;
#define CMIC_PKT_REASON_DIRECTr_CLR BCM56218_A0_CMIC_PKT_REASON_DIRECTr_CLR
#define CMIC_PKT_REASON_DIRECTr_SET BCM56218_A0_CMIC_PKT_REASON_DIRECTr_SET
#define CMIC_PKT_REASON_DIRECTr_GET BCM56218_A0_CMIC_PKT_REASON_DIRECTr_GET
#define CMIC_PKT_REASON_DIRECTr_REASONSf_GET BCM56218_A0_CMIC_PKT_REASON_DIRECTr_REASONSf_GET
#define CMIC_PKT_REASON_DIRECTr_REASONSf_SET BCM56218_A0_CMIC_PKT_REASON_DIRECTr_REASONSf_SET
#define READ_CMIC_PKT_REASON_DIRECTr BCM56218_A0_READ_CMIC_PKT_REASON_DIRECTr
#define WRITE_CMIC_PKT_REASON_DIRECTr BCM56218_A0_WRITE_CMIC_PKT_REASON_DIRECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_PKT_REASON_DIRECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_PKT_REASON_MINI
 * BLOCKS:   CMIC
 * DESC:     A bitmap of reason codes (sometimes called CPU opcodes) that cause
CMIC to truncate reinjected packets to a size of 128-bytes.

 * SIZE:     32
 * FIELDS:
 *     REASONS          Reason code bitmap
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_PKT_REASON_MINIr 0x00000758

#define BCM56218_A0_CMIC_PKT_REASON_MINIr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_PKT_REASON_MINI.
 *
 */
typedef union BCM56218_A0_CMIC_PKT_REASON_MINIr_s {
	uint32_t v[1];
	uint32_t cmic_pkt_reason_mini[1];
	uint32_t _cmic_pkt_reason_mini;
} BCM56218_A0_CMIC_PKT_REASON_MINIr_t;

#define BCM56218_A0_CMIC_PKT_REASON_MINIr_CLR(r) (r).cmic_pkt_reason_mini[0] = 0
#define BCM56218_A0_CMIC_PKT_REASON_MINIr_SET(r,d) (r).cmic_pkt_reason_mini[0] = d
#define BCM56218_A0_CMIC_PKT_REASON_MINIr_GET(r) (r).cmic_pkt_reason_mini[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_PKT_REASON_MINIr_REASONSf_GET(r) ((r).cmic_pkt_reason_mini[0])
#define BCM56218_A0_CMIC_PKT_REASON_MINIr_REASONSf_SET(r,f) (r).cmic_pkt_reason_mini[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_PKT_REASON_MINI.
 *
 */
#define BCM56218_A0_READ_CMIC_PKT_REASON_MINIr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_PKT_REASON_MINIr,r._cmic_pkt_reason_mini)
#define BCM56218_A0_WRITE_CMIC_PKT_REASON_MINIr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_PKT_REASON_MINIr,r._cmic_pkt_reason_mini)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_PKT_REASON_MINIr BCM56218_A0_CMIC_PKT_REASON_MINIr
#define CMIC_PKT_REASON_MINIr_SIZE BCM56218_A0_CMIC_PKT_REASON_MINIr_SIZE
typedef BCM56218_A0_CMIC_PKT_REASON_MINIr_t CMIC_PKT_REASON_MINIr_t;
#define CMIC_PKT_REASON_MINIr_CLR BCM56218_A0_CMIC_PKT_REASON_MINIr_CLR
#define CMIC_PKT_REASON_MINIr_SET BCM56218_A0_CMIC_PKT_REASON_MINIr_SET
#define CMIC_PKT_REASON_MINIr_GET BCM56218_A0_CMIC_PKT_REASON_MINIr_GET
#define CMIC_PKT_REASON_MINIr_REASONSf_GET BCM56218_A0_CMIC_PKT_REASON_MINIr_REASONSf_GET
#define CMIC_PKT_REASON_MINIr_REASONSf_SET BCM56218_A0_CMIC_PKT_REASON_MINIr_REASONSf_SET
#define READ_CMIC_PKT_REASON_MINIr BCM56218_A0_READ_CMIC_PKT_REASON_MINIr
#define WRITE_CMIC_PKT_REASON_MINIr BCM56218_A0_WRITE_CMIC_PKT_REASON_MINIr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_PKT_REASON_MINIr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_PKT_RMAC
 * BLOCKS:   CMIC
 * DESC:     Lower 32 bits of the destination MAC address for all packets that the CMIC generates except for Remote
PIO replies.

 * SIZE:     32
 * FIELDS:
 *     MAC_LO           MAC DA bits 31:0.
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_PKT_RMACr 0x0000073c

#define BCM56218_A0_CMIC_PKT_RMACr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_PKT_RMAC.
 *
 */
typedef union BCM56218_A0_CMIC_PKT_RMACr_s {
	uint32_t v[1];
	uint32_t cmic_pkt_rmac[1];
	uint32_t _cmic_pkt_rmac;
} BCM56218_A0_CMIC_PKT_RMACr_t;

#define BCM56218_A0_CMIC_PKT_RMACr_CLR(r) (r).cmic_pkt_rmac[0] = 0
#define BCM56218_A0_CMIC_PKT_RMACr_SET(r,d) (r).cmic_pkt_rmac[0] = d
#define BCM56218_A0_CMIC_PKT_RMACr_GET(r) (r).cmic_pkt_rmac[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_PKT_RMACr_MAC_LOf_GET(r) ((r).cmic_pkt_rmac[0])
#define BCM56218_A0_CMIC_PKT_RMACr_MAC_LOf_SET(r,f) (r).cmic_pkt_rmac[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_PKT_RMAC.
 *
 */
#define BCM56218_A0_READ_CMIC_PKT_RMACr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_PKT_RMACr,r._cmic_pkt_rmac)
#define BCM56218_A0_WRITE_CMIC_PKT_RMACr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_PKT_RMACr,r._cmic_pkt_rmac)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_PKT_RMACr BCM56218_A0_CMIC_PKT_RMACr
#define CMIC_PKT_RMACr_SIZE BCM56218_A0_CMIC_PKT_RMACr_SIZE
typedef BCM56218_A0_CMIC_PKT_RMACr_t CMIC_PKT_RMACr_t;
#define CMIC_PKT_RMACr_CLR BCM56218_A0_CMIC_PKT_RMACr_CLR
#define CMIC_PKT_RMACr_SET BCM56218_A0_CMIC_PKT_RMACr_SET
#define CMIC_PKT_RMACr_GET BCM56218_A0_CMIC_PKT_RMACr_GET
#define CMIC_PKT_RMACr_MAC_LOf_GET BCM56218_A0_CMIC_PKT_RMACr_MAC_LOf_GET
#define CMIC_PKT_RMACr_MAC_LOf_SET BCM56218_A0_CMIC_PKT_RMACr_MAC_LOf_SET
#define READ_CMIC_PKT_RMACr BCM56218_A0_READ_CMIC_PKT_RMACr
#define WRITE_CMIC_PKT_RMACr BCM56218_A0_WRITE_CMIC_PKT_RMACr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_PKT_RMACr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_PKT_RMAC_HI
 * BLOCKS:   CMIC
 * DESC:     Higher 16 bits of the destination MAC address for all packets that the CMIC generates except for Remote
PIO replies.

 * SIZE:     32
 * FIELDS:
 *     MAC_HI           MAC DA bits 47:32.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_PKT_RMAC_HIr 0x00000740

#define BCM56218_A0_CMIC_PKT_RMAC_HIr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_PKT_RMAC_HI.
 *
 */
typedef union BCM56218_A0_CMIC_PKT_RMAC_HIr_s {
	uint32_t v[1];
	uint32_t cmic_pkt_rmac_hi[1];
	uint32_t _cmic_pkt_rmac_hi;
} BCM56218_A0_CMIC_PKT_RMAC_HIr_t;

#define BCM56218_A0_CMIC_PKT_RMAC_HIr_CLR(r) (r).cmic_pkt_rmac_hi[0] = 0
#define BCM56218_A0_CMIC_PKT_RMAC_HIr_SET(r,d) (r).cmic_pkt_rmac_hi[0] = d
#define BCM56218_A0_CMIC_PKT_RMAC_HIr_GET(r) (r).cmic_pkt_rmac_hi[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_PKT_RMAC_HIr_MAC_HIf_GET(r) (((r).cmic_pkt_rmac_hi[0]) & 0xffff)
#define BCM56218_A0_CMIC_PKT_RMAC_HIr_MAC_HIf_SET(r,f) (r).cmic_pkt_rmac_hi[0]=(((r).cmic_pkt_rmac_hi[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56218_A0_CMIC_PKT_RMAC_HIr_RESERVEDf_GET(r) ((((r).cmic_pkt_rmac_hi[0]) >> 16) & 0xffff)
#define BCM56218_A0_CMIC_PKT_RMAC_HIr_RESERVEDf_SET(r,f) (r).cmic_pkt_rmac_hi[0]=(((r).cmic_pkt_rmac_hi[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access CMIC_PKT_RMAC_HI.
 *
 */
#define BCM56218_A0_READ_CMIC_PKT_RMAC_HIr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_PKT_RMAC_HIr,r._cmic_pkt_rmac_hi)
#define BCM56218_A0_WRITE_CMIC_PKT_RMAC_HIr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_PKT_RMAC_HIr,r._cmic_pkt_rmac_hi)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_PKT_RMAC_HIr BCM56218_A0_CMIC_PKT_RMAC_HIr
#define CMIC_PKT_RMAC_HIr_SIZE BCM56218_A0_CMIC_PKT_RMAC_HIr_SIZE
typedef BCM56218_A0_CMIC_PKT_RMAC_HIr_t CMIC_PKT_RMAC_HIr_t;
#define CMIC_PKT_RMAC_HIr_CLR BCM56218_A0_CMIC_PKT_RMAC_HIr_CLR
#define CMIC_PKT_RMAC_HIr_SET BCM56218_A0_CMIC_PKT_RMAC_HIr_SET
#define CMIC_PKT_RMAC_HIr_GET BCM56218_A0_CMIC_PKT_RMAC_HIr_GET
#define CMIC_PKT_RMAC_HIr_MAC_HIf_GET BCM56218_A0_CMIC_PKT_RMAC_HIr_MAC_HIf_GET
#define CMIC_PKT_RMAC_HIr_MAC_HIf_SET BCM56218_A0_CMIC_PKT_RMAC_HIr_MAC_HIf_SET
#define CMIC_PKT_RMAC_HIr_RESERVEDf_GET BCM56218_A0_CMIC_PKT_RMAC_HIr_RESERVEDf_GET
#define CMIC_PKT_RMAC_HIr_RESERVEDf_SET BCM56218_A0_CMIC_PKT_RMAC_HIr_RESERVEDf_SET
#define READ_CMIC_PKT_RMAC_HIr BCM56218_A0_READ_CMIC_PKT_RMAC_HIr
#define WRITE_CMIC_PKT_RMAC_HIr BCM56218_A0_WRITE_CMIC_PKT_RMAC_HIr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_PKT_RMAC_HIr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_PKT_RMH0
 * BLOCKS:   CMIC
 * DESC:     First DWord of the Module Header on an outpoing CMIC packet.

 * SIZE:     32
 * FIELDS:
 *     MH0              Module Header DWord 0
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_PKT_RMH0r 0x00000744

#define BCM56218_A0_CMIC_PKT_RMH0r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_PKT_RMH0.
 *
 */
typedef union BCM56218_A0_CMIC_PKT_RMH0r_s {
	uint32_t v[1];
	uint32_t cmic_pkt_rmh0[1];
	uint32_t _cmic_pkt_rmh0;
} BCM56218_A0_CMIC_PKT_RMH0r_t;

#define BCM56218_A0_CMIC_PKT_RMH0r_CLR(r) (r).cmic_pkt_rmh0[0] = 0
#define BCM56218_A0_CMIC_PKT_RMH0r_SET(r,d) (r).cmic_pkt_rmh0[0] = d
#define BCM56218_A0_CMIC_PKT_RMH0r_GET(r) (r).cmic_pkt_rmh0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_PKT_RMH0r_MH0f_GET(r) ((r).cmic_pkt_rmh0[0])
#define BCM56218_A0_CMIC_PKT_RMH0r_MH0f_SET(r,f) (r).cmic_pkt_rmh0[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_PKT_RMH0.
 *
 */
#define BCM56218_A0_READ_CMIC_PKT_RMH0r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_PKT_RMH0r,r._cmic_pkt_rmh0)
#define BCM56218_A0_WRITE_CMIC_PKT_RMH0r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_PKT_RMH0r,r._cmic_pkt_rmh0)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_PKT_RMH0r BCM56218_A0_CMIC_PKT_RMH0r
#define CMIC_PKT_RMH0r_SIZE BCM56218_A0_CMIC_PKT_RMH0r_SIZE
typedef BCM56218_A0_CMIC_PKT_RMH0r_t CMIC_PKT_RMH0r_t;
#define CMIC_PKT_RMH0r_CLR BCM56218_A0_CMIC_PKT_RMH0r_CLR
#define CMIC_PKT_RMH0r_SET BCM56218_A0_CMIC_PKT_RMH0r_SET
#define CMIC_PKT_RMH0r_GET BCM56218_A0_CMIC_PKT_RMH0r_GET
#define CMIC_PKT_RMH0r_MH0f_GET BCM56218_A0_CMIC_PKT_RMH0r_MH0f_GET
#define CMIC_PKT_RMH0r_MH0f_SET BCM56218_A0_CMIC_PKT_RMH0r_MH0f_SET
#define READ_CMIC_PKT_RMH0r BCM56218_A0_READ_CMIC_PKT_RMH0r
#define WRITE_CMIC_PKT_RMH0r BCM56218_A0_WRITE_CMIC_PKT_RMH0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_PKT_RMH0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_PKT_RMH1
 * BLOCKS:   CMIC
 * DESC:     Second DWord of the Module Header on an outpoing CMIC packet.

 * SIZE:     32
 * FIELDS:
 *     MH1              Module Header DWord 1
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_PKT_RMH1r 0x00000748

#define BCM56218_A0_CMIC_PKT_RMH1r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_PKT_RMH1.
 *
 */
typedef union BCM56218_A0_CMIC_PKT_RMH1r_s {
	uint32_t v[1];
	uint32_t cmic_pkt_rmh1[1];
	uint32_t _cmic_pkt_rmh1;
} BCM56218_A0_CMIC_PKT_RMH1r_t;

#define BCM56218_A0_CMIC_PKT_RMH1r_CLR(r) (r).cmic_pkt_rmh1[0] = 0
#define BCM56218_A0_CMIC_PKT_RMH1r_SET(r,d) (r).cmic_pkt_rmh1[0] = d
#define BCM56218_A0_CMIC_PKT_RMH1r_GET(r) (r).cmic_pkt_rmh1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_PKT_RMH1r_MH1f_GET(r) ((r).cmic_pkt_rmh1[0])
#define BCM56218_A0_CMIC_PKT_RMH1r_MH1f_SET(r,f) (r).cmic_pkt_rmh1[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_PKT_RMH1.
 *
 */
#define BCM56218_A0_READ_CMIC_PKT_RMH1r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_PKT_RMH1r,r._cmic_pkt_rmh1)
#define BCM56218_A0_WRITE_CMIC_PKT_RMH1r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_PKT_RMH1r,r._cmic_pkt_rmh1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_PKT_RMH1r BCM56218_A0_CMIC_PKT_RMH1r
#define CMIC_PKT_RMH1r_SIZE BCM56218_A0_CMIC_PKT_RMH1r_SIZE
typedef BCM56218_A0_CMIC_PKT_RMH1r_t CMIC_PKT_RMH1r_t;
#define CMIC_PKT_RMH1r_CLR BCM56218_A0_CMIC_PKT_RMH1r_CLR
#define CMIC_PKT_RMH1r_SET BCM56218_A0_CMIC_PKT_RMH1r_SET
#define CMIC_PKT_RMH1r_GET BCM56218_A0_CMIC_PKT_RMH1r_GET
#define CMIC_PKT_RMH1r_MH1f_GET BCM56218_A0_CMIC_PKT_RMH1r_MH1f_GET
#define CMIC_PKT_RMH1r_MH1f_SET BCM56218_A0_CMIC_PKT_RMH1r_MH1f_SET
#define READ_CMIC_PKT_RMH1r BCM56218_A0_READ_CMIC_PKT_RMH1r
#define WRITE_CMIC_PKT_RMH1r BCM56218_A0_WRITE_CMIC_PKT_RMH1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_PKT_RMH1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_PKT_RMH2
 * BLOCKS:   CMIC
 * DESC:     Third DWord of the Module Header on an outpoing CMIC packet.

 * SIZE:     32
 * FIELDS:
 *     MH2              Module Header DWord 2
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_PKT_RMH2r 0x0000074c

#define BCM56218_A0_CMIC_PKT_RMH2r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_PKT_RMH2.
 *
 */
typedef union BCM56218_A0_CMIC_PKT_RMH2r_s {
	uint32_t v[1];
	uint32_t cmic_pkt_rmh2[1];
	uint32_t _cmic_pkt_rmh2;
} BCM56218_A0_CMIC_PKT_RMH2r_t;

#define BCM56218_A0_CMIC_PKT_RMH2r_CLR(r) (r).cmic_pkt_rmh2[0] = 0
#define BCM56218_A0_CMIC_PKT_RMH2r_SET(r,d) (r).cmic_pkt_rmh2[0] = d
#define BCM56218_A0_CMIC_PKT_RMH2r_GET(r) (r).cmic_pkt_rmh2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_PKT_RMH2r_MH2f_GET(r) ((r).cmic_pkt_rmh2[0])
#define BCM56218_A0_CMIC_PKT_RMH2r_MH2f_SET(r,f) (r).cmic_pkt_rmh2[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_PKT_RMH2.
 *
 */
#define BCM56218_A0_READ_CMIC_PKT_RMH2r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_PKT_RMH2r,r._cmic_pkt_rmh2)
#define BCM56218_A0_WRITE_CMIC_PKT_RMH2r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_PKT_RMH2r,r._cmic_pkt_rmh2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_PKT_RMH2r BCM56218_A0_CMIC_PKT_RMH2r
#define CMIC_PKT_RMH2r_SIZE BCM56218_A0_CMIC_PKT_RMH2r_SIZE
typedef BCM56218_A0_CMIC_PKT_RMH2r_t CMIC_PKT_RMH2r_t;
#define CMIC_PKT_RMH2r_CLR BCM56218_A0_CMIC_PKT_RMH2r_CLR
#define CMIC_PKT_RMH2r_SET BCM56218_A0_CMIC_PKT_RMH2r_SET
#define CMIC_PKT_RMH2r_GET BCM56218_A0_CMIC_PKT_RMH2r_GET
#define CMIC_PKT_RMH2r_MH2f_GET BCM56218_A0_CMIC_PKT_RMH2r_MH2f_GET
#define CMIC_PKT_RMH2r_MH2f_SET BCM56218_A0_CMIC_PKT_RMH2r_MH2f_SET
#define READ_CMIC_PKT_RMH2r BCM56218_A0_READ_CMIC_PKT_RMH2r
#define WRITE_CMIC_PKT_RMH2r BCM56218_A0_WRITE_CMIC_PKT_RMH2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_PKT_RMH2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_PKT_RMH3
 * BLOCKS:   CMIC
 * DESC:     Fourth DWord of the Module Header on an outpoing CMIC packet.

 * SIZE:     32
 * FIELDS:
 *     MH2              Module Header DWord 3
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_PKT_RMH3r 0x00000788

#define BCM56218_A0_CMIC_PKT_RMH3r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_PKT_RMH3.
 *
 */
typedef union BCM56218_A0_CMIC_PKT_RMH3r_s {
	uint32_t v[1];
	uint32_t cmic_pkt_rmh3[1];
	uint32_t _cmic_pkt_rmh3;
} BCM56218_A0_CMIC_PKT_RMH3r_t;

#define BCM56218_A0_CMIC_PKT_RMH3r_CLR(r) (r).cmic_pkt_rmh3[0] = 0
#define BCM56218_A0_CMIC_PKT_RMH3r_SET(r,d) (r).cmic_pkt_rmh3[0] = d
#define BCM56218_A0_CMIC_PKT_RMH3r_GET(r) (r).cmic_pkt_rmh3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_PKT_RMH3r_MH2f_GET(r) ((r).cmic_pkt_rmh3[0])
#define BCM56218_A0_CMIC_PKT_RMH3r_MH2f_SET(r,f) (r).cmic_pkt_rmh3[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_PKT_RMH3.
 *
 */
#define BCM56218_A0_READ_CMIC_PKT_RMH3r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_PKT_RMH3r,r._cmic_pkt_rmh3)
#define BCM56218_A0_WRITE_CMIC_PKT_RMH3r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_PKT_RMH3r,r._cmic_pkt_rmh3)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_PKT_RMH3r BCM56218_A0_CMIC_PKT_RMH3r
#define CMIC_PKT_RMH3r_SIZE BCM56218_A0_CMIC_PKT_RMH3r_SIZE
typedef BCM56218_A0_CMIC_PKT_RMH3r_t CMIC_PKT_RMH3r_t;
#define CMIC_PKT_RMH3r_CLR BCM56218_A0_CMIC_PKT_RMH3r_CLR
#define CMIC_PKT_RMH3r_SET BCM56218_A0_CMIC_PKT_RMH3r_SET
#define CMIC_PKT_RMH3r_GET BCM56218_A0_CMIC_PKT_RMH3r_GET
#define CMIC_PKT_RMH3r_MH2f_GET BCM56218_A0_CMIC_PKT_RMH3r_MH2f_GET
#define CMIC_PKT_RMH3r_MH2f_SET BCM56218_A0_CMIC_PKT_RMH3r_MH2f_SET
#define READ_CMIC_PKT_RMH3r BCM56218_A0_READ_CMIC_PKT_RMH3r
#define WRITE_CMIC_PKT_RMH3r BCM56218_A0_WRITE_CMIC_PKT_RMH3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_PKT_RMH3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_PKT_VLAN
 * BLOCKS:   CMIC
 * DESC:     CMIC Packet TPID and VLAN Tag

 * SIZE:     32
 * FIELDS:
 *     VLAN_ID          VLAN Tag
 *     TPID             TPID Value
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_PKT_VLANr 0x00000728

#define BCM56218_A0_CMIC_PKT_VLANr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_PKT_VLAN.
 *
 */
typedef union BCM56218_A0_CMIC_PKT_VLANr_s {
	uint32_t v[1];
	uint32_t cmic_pkt_vlan[1];
	uint32_t _cmic_pkt_vlan;
} BCM56218_A0_CMIC_PKT_VLANr_t;

#define BCM56218_A0_CMIC_PKT_VLANr_CLR(r) (r).cmic_pkt_vlan[0] = 0
#define BCM56218_A0_CMIC_PKT_VLANr_SET(r,d) (r).cmic_pkt_vlan[0] = d
#define BCM56218_A0_CMIC_PKT_VLANr_GET(r) (r).cmic_pkt_vlan[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_PKT_VLANr_VLAN_IDf_GET(r) (((r).cmic_pkt_vlan[0]) & 0xffff)
#define BCM56218_A0_CMIC_PKT_VLANr_VLAN_IDf_SET(r,f) (r).cmic_pkt_vlan[0]=(((r).cmic_pkt_vlan[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56218_A0_CMIC_PKT_VLANr_TPIDf_GET(r) ((((r).cmic_pkt_vlan[0]) >> 16) & 0xffff)
#define BCM56218_A0_CMIC_PKT_VLANr_TPIDf_SET(r,f) (r).cmic_pkt_vlan[0]=(((r).cmic_pkt_vlan[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access CMIC_PKT_VLAN.
 *
 */
#define BCM56218_A0_READ_CMIC_PKT_VLANr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_PKT_VLANr,r._cmic_pkt_vlan)
#define BCM56218_A0_WRITE_CMIC_PKT_VLANr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_PKT_VLANr,r._cmic_pkt_vlan)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_PKT_VLANr BCM56218_A0_CMIC_PKT_VLANr
#define CMIC_PKT_VLANr_SIZE BCM56218_A0_CMIC_PKT_VLANr_SIZE
typedef BCM56218_A0_CMIC_PKT_VLANr_t CMIC_PKT_VLANr_t;
#define CMIC_PKT_VLANr_CLR BCM56218_A0_CMIC_PKT_VLANr_CLR
#define CMIC_PKT_VLANr_SET BCM56218_A0_CMIC_PKT_VLANr_SET
#define CMIC_PKT_VLANr_GET BCM56218_A0_CMIC_PKT_VLANr_GET
#define CMIC_PKT_VLANr_VLAN_IDf_GET BCM56218_A0_CMIC_PKT_VLANr_VLAN_IDf_GET
#define CMIC_PKT_VLANr_VLAN_IDf_SET BCM56218_A0_CMIC_PKT_VLANr_VLAN_IDf_SET
#define CMIC_PKT_VLANr_TPIDf_GET BCM56218_A0_CMIC_PKT_VLANr_TPIDf_GET
#define CMIC_PKT_VLANr_TPIDf_SET BCM56218_A0_CMIC_PKT_VLANr_TPIDf_SET
#define READ_CMIC_PKT_VLANr BCM56218_A0_READ_CMIC_PKT_VLANr
#define WRITE_CMIC_PKT_VLANr BCM56218_A0_WRITE_CMIC_PKT_VLANr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_PKT_VLANr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_RATE_ADJUST
 * BLOCKS:   CMIC
 * DESC:     The clock divider configuration register for External MDIO.

Various parts of the chip involved in rate control 
require a constant, known frequency. This reference 
frequency is based off of the chip 's core clock.
However, the core clock can be different in different
designs, thus the need for this register.

The core clock frequency is multiplied by the rational
quantity (DIVIDEND/DIVISOR), and the further divided
down by 2 to produce the actual MDIO operation freqeuncy.

To avoid skew, it is recommended that the DIVIDEND value
usually be set to 1.

The default values are for 133MHz operation:
DIVIDEND=1, DIVISOR=6, 
MDIO operation freq = 133MHz/(6*2) =~ 11MHz

For 157MHz core clock chips, set:
DIVIDEND=1, DIVISOR=7, 
MDIO operation freq = 133MHz/(7*2) =~ 11MHz


 * SIZE:     32
 * FIELDS:
 *     DIVISOR          Denominator of clock scale factor.
 *     DIVIDEND         Numerator of clock scale factor.
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_RATE_ADJUSTr 0x000001b8

#define BCM56218_A0_CMIC_RATE_ADJUSTr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_RATE_ADJUST.
 *
 */
typedef union BCM56218_A0_CMIC_RATE_ADJUSTr_s {
	uint32_t v[1];
	uint32_t cmic_rate_adjust[1];
	uint32_t _cmic_rate_adjust;
} BCM56218_A0_CMIC_RATE_ADJUSTr_t;

#define BCM56218_A0_CMIC_RATE_ADJUSTr_CLR(r) (r).cmic_rate_adjust[0] = 0
#define BCM56218_A0_CMIC_RATE_ADJUSTr_SET(r,d) (r).cmic_rate_adjust[0] = d
#define BCM56218_A0_CMIC_RATE_ADJUSTr_GET(r) (r).cmic_rate_adjust[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_RATE_ADJUSTr_DIVISORf_GET(r) (((r).cmic_rate_adjust[0]) & 0xffff)
#define BCM56218_A0_CMIC_RATE_ADJUSTr_DIVISORf_SET(r,f) (r).cmic_rate_adjust[0]=(((r).cmic_rate_adjust[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56218_A0_CMIC_RATE_ADJUSTr_DIVIDENDf_GET(r) ((((r).cmic_rate_adjust[0]) >> 16) & 0xffff)
#define BCM56218_A0_CMIC_RATE_ADJUSTr_DIVIDENDf_SET(r,f) (r).cmic_rate_adjust[0]=(((r).cmic_rate_adjust[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access CMIC_RATE_ADJUST.
 *
 */
#define BCM56218_A0_READ_CMIC_RATE_ADJUSTr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_RATE_ADJUSTr,r._cmic_rate_adjust)
#define BCM56218_A0_WRITE_CMIC_RATE_ADJUSTr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_RATE_ADJUSTr,r._cmic_rate_adjust)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_RATE_ADJUSTr BCM56218_A0_CMIC_RATE_ADJUSTr
#define CMIC_RATE_ADJUSTr_SIZE BCM56218_A0_CMIC_RATE_ADJUSTr_SIZE
typedef BCM56218_A0_CMIC_RATE_ADJUSTr_t CMIC_RATE_ADJUSTr_t;
#define CMIC_RATE_ADJUSTr_CLR BCM56218_A0_CMIC_RATE_ADJUSTr_CLR
#define CMIC_RATE_ADJUSTr_SET BCM56218_A0_CMIC_RATE_ADJUSTr_SET
#define CMIC_RATE_ADJUSTr_GET BCM56218_A0_CMIC_RATE_ADJUSTr_GET
#define CMIC_RATE_ADJUSTr_DIVISORf_GET BCM56218_A0_CMIC_RATE_ADJUSTr_DIVISORf_GET
#define CMIC_RATE_ADJUSTr_DIVISORf_SET BCM56218_A0_CMIC_RATE_ADJUSTr_DIVISORf_SET
#define CMIC_RATE_ADJUSTr_DIVIDENDf_GET BCM56218_A0_CMIC_RATE_ADJUSTr_DIVIDENDf_GET
#define CMIC_RATE_ADJUSTr_DIVIDENDf_SET BCM56218_A0_CMIC_RATE_ADJUSTr_DIVIDENDf_SET
#define READ_CMIC_RATE_ADJUSTr BCM56218_A0_READ_CMIC_RATE_ADJUSTr
#define WRITE_CMIC_RATE_ADJUSTr BCM56218_A0_WRITE_CMIC_RATE_ADJUSTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_RATE_ADJUSTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_RATE_ADJUST_I2C
 * BLOCKS:   CMIC
 * DESC:     The clock divider configuration register for I2C.

Various parts of the chip involved in rate control 
require a constant, known frequency. This reference 
frequency is based off of the chip 's core clock.
However, the core clock can be different in different
designs, thus the need for this register.

The core clock frequency is multiplied by the rational
quantity (DIVIDEND/DIVISOR), and the further divided
down by 2 to produce the actual MDIO operation freqeuncy.

To avoid skew, it is recommended that the DIVIDEND value
usually be set to 1.

The default values are for 133MHz operation:
DIVIDEND=1, DIVISOR=6, 
MDIO operation freq = 133MHz/(6*2) =~ 11MHz

For 157MHz core clock chips, set:
DIVIDEND=1, DIVISOR=7, 
MDIO operation freq = 133MHz/(7*2) =~ 11MHz


 * SIZE:     32
 * FIELDS:
 *     DIVISOR          Denominator of clock scale factor.
 *     DIVIDEND         Numerator of clock scale factor.
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_RATE_ADJUST_I2Cr 0x000001b4

#define BCM56218_A0_CMIC_RATE_ADJUST_I2Cr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_RATE_ADJUST_I2C.
 *
 */
typedef union BCM56218_A0_CMIC_RATE_ADJUST_I2Cr_s {
	uint32_t v[1];
	uint32_t cmic_rate_adjust_i2c[1];
	uint32_t _cmic_rate_adjust_i2c;
} BCM56218_A0_CMIC_RATE_ADJUST_I2Cr_t;

#define BCM56218_A0_CMIC_RATE_ADJUST_I2Cr_CLR(r) (r).cmic_rate_adjust_i2c[0] = 0
#define BCM56218_A0_CMIC_RATE_ADJUST_I2Cr_SET(r,d) (r).cmic_rate_adjust_i2c[0] = d
#define BCM56218_A0_CMIC_RATE_ADJUST_I2Cr_GET(r) (r).cmic_rate_adjust_i2c[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_RATE_ADJUST_I2Cr_DIVISORf_GET(r) (((r).cmic_rate_adjust_i2c[0]) & 0xffff)
#define BCM56218_A0_CMIC_RATE_ADJUST_I2Cr_DIVISORf_SET(r,f) (r).cmic_rate_adjust_i2c[0]=(((r).cmic_rate_adjust_i2c[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56218_A0_CMIC_RATE_ADJUST_I2Cr_DIVIDENDf_GET(r) ((((r).cmic_rate_adjust_i2c[0]) >> 16) & 0xffff)
#define BCM56218_A0_CMIC_RATE_ADJUST_I2Cr_DIVIDENDf_SET(r,f) (r).cmic_rate_adjust_i2c[0]=(((r).cmic_rate_adjust_i2c[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access CMIC_RATE_ADJUST_I2C.
 *
 */
#define BCM56218_A0_READ_CMIC_RATE_ADJUST_I2Cr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_RATE_ADJUST_I2Cr,r._cmic_rate_adjust_i2c)
#define BCM56218_A0_WRITE_CMIC_RATE_ADJUST_I2Cr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_RATE_ADJUST_I2Cr,r._cmic_rate_adjust_i2c)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_RATE_ADJUST_I2Cr BCM56218_A0_CMIC_RATE_ADJUST_I2Cr
#define CMIC_RATE_ADJUST_I2Cr_SIZE BCM56218_A0_CMIC_RATE_ADJUST_I2Cr_SIZE
typedef BCM56218_A0_CMIC_RATE_ADJUST_I2Cr_t CMIC_RATE_ADJUST_I2Cr_t;
#define CMIC_RATE_ADJUST_I2Cr_CLR BCM56218_A0_CMIC_RATE_ADJUST_I2Cr_CLR
#define CMIC_RATE_ADJUST_I2Cr_SET BCM56218_A0_CMIC_RATE_ADJUST_I2Cr_SET
#define CMIC_RATE_ADJUST_I2Cr_GET BCM56218_A0_CMIC_RATE_ADJUST_I2Cr_GET
#define CMIC_RATE_ADJUST_I2Cr_DIVISORf_GET BCM56218_A0_CMIC_RATE_ADJUST_I2Cr_DIVISORf_GET
#define CMIC_RATE_ADJUST_I2Cr_DIVISORf_SET BCM56218_A0_CMIC_RATE_ADJUST_I2Cr_DIVISORf_SET
#define CMIC_RATE_ADJUST_I2Cr_DIVIDENDf_GET BCM56218_A0_CMIC_RATE_ADJUST_I2Cr_DIVIDENDf_GET
#define CMIC_RATE_ADJUST_I2Cr_DIVIDENDf_SET BCM56218_A0_CMIC_RATE_ADJUST_I2Cr_DIVIDENDf_SET
#define READ_CMIC_RATE_ADJUST_I2Cr BCM56218_A0_READ_CMIC_RATE_ADJUST_I2Cr
#define WRITE_CMIC_RATE_ADJUST_I2Cr BCM56218_A0_WRITE_CMIC_RATE_ADJUST_I2Cr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_RATE_ADJUST_I2Cr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_RATE_ADJUST_INT_MDIO
 * BLOCKS:   CMIC
 * DESC:     The clock divider configuration register for Internal MDIO.

Various parts of the chip involved in rate control 
require a constant, known frequency. This reference 
frequency is based off of the chip 's core clock.
However, the core clock can be different in different
designs, thus the need for this register.

The core clock frequency is multiplied by the rational
quantity (DIVIDEND/DIVISOR), and the further divided
down by 2 to produce the actual MDIO operation freqeuncy.

To avoid skew, it is recommended that the DIVIDEND value
usually be set to 1.

The default values are for 133MHz operation:
DIVIDEND=1, DIVISOR=6, 
MDIO operation freq = 133MHz/(6*2) =~ 11MHz

For 157MHz core clock chips, set:
DIVIDEND=1, DIVISOR=7, 
MDIO operation freq = 133MHz/(7*2) =~ 11MHz


 * SIZE:     32
 * FIELDS:
 *     DIVISOR          Denominator of clock scale factor.
 *     DIVIDEND         Numerator of clock scale factor.
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_RATE_ADJUST_INT_MDIOr 0x000001bc

#define BCM56218_A0_CMIC_RATE_ADJUST_INT_MDIOr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_RATE_ADJUST_INT_MDIO.
 *
 */
typedef union BCM56218_A0_CMIC_RATE_ADJUST_INT_MDIOr_s {
	uint32_t v[1];
	uint32_t cmic_rate_adjust_int_mdio[1];
	uint32_t _cmic_rate_adjust_int_mdio;
} BCM56218_A0_CMIC_RATE_ADJUST_INT_MDIOr_t;

#define BCM56218_A0_CMIC_RATE_ADJUST_INT_MDIOr_CLR(r) (r).cmic_rate_adjust_int_mdio[0] = 0
#define BCM56218_A0_CMIC_RATE_ADJUST_INT_MDIOr_SET(r,d) (r).cmic_rate_adjust_int_mdio[0] = d
#define BCM56218_A0_CMIC_RATE_ADJUST_INT_MDIOr_GET(r) (r).cmic_rate_adjust_int_mdio[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_RATE_ADJUST_INT_MDIOr_DIVISORf_GET(r) (((r).cmic_rate_adjust_int_mdio[0]) & 0xffff)
#define BCM56218_A0_CMIC_RATE_ADJUST_INT_MDIOr_DIVISORf_SET(r,f) (r).cmic_rate_adjust_int_mdio[0]=(((r).cmic_rate_adjust_int_mdio[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56218_A0_CMIC_RATE_ADJUST_INT_MDIOr_DIVIDENDf_GET(r) ((((r).cmic_rate_adjust_int_mdio[0]) >> 16) & 0xffff)
#define BCM56218_A0_CMIC_RATE_ADJUST_INT_MDIOr_DIVIDENDf_SET(r,f) (r).cmic_rate_adjust_int_mdio[0]=(((r).cmic_rate_adjust_int_mdio[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access CMIC_RATE_ADJUST_INT_MDIO.
 *
 */
#define BCM56218_A0_READ_CMIC_RATE_ADJUST_INT_MDIOr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_RATE_ADJUST_INT_MDIOr,r._cmic_rate_adjust_int_mdio)
#define BCM56218_A0_WRITE_CMIC_RATE_ADJUST_INT_MDIOr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_RATE_ADJUST_INT_MDIOr,r._cmic_rate_adjust_int_mdio)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_RATE_ADJUST_INT_MDIOr BCM56218_A0_CMIC_RATE_ADJUST_INT_MDIOr
#define CMIC_RATE_ADJUST_INT_MDIOr_SIZE BCM56218_A0_CMIC_RATE_ADJUST_INT_MDIOr_SIZE
typedef BCM56218_A0_CMIC_RATE_ADJUST_INT_MDIOr_t CMIC_RATE_ADJUST_INT_MDIOr_t;
#define CMIC_RATE_ADJUST_INT_MDIOr_CLR BCM56218_A0_CMIC_RATE_ADJUST_INT_MDIOr_CLR
#define CMIC_RATE_ADJUST_INT_MDIOr_SET BCM56218_A0_CMIC_RATE_ADJUST_INT_MDIOr_SET
#define CMIC_RATE_ADJUST_INT_MDIOr_GET BCM56218_A0_CMIC_RATE_ADJUST_INT_MDIOr_GET
#define CMIC_RATE_ADJUST_INT_MDIOr_DIVISORf_GET BCM56218_A0_CMIC_RATE_ADJUST_INT_MDIOr_DIVISORf_GET
#define CMIC_RATE_ADJUST_INT_MDIOr_DIVISORf_SET BCM56218_A0_CMIC_RATE_ADJUST_INT_MDIOr_DIVISORf_SET
#define CMIC_RATE_ADJUST_INT_MDIOr_DIVIDENDf_GET BCM56218_A0_CMIC_RATE_ADJUST_INT_MDIOr_DIVIDENDf_GET
#define CMIC_RATE_ADJUST_INT_MDIOr_DIVIDENDf_SET BCM56218_A0_CMIC_RATE_ADJUST_INT_MDIOr_DIVIDENDf_SET
#define READ_CMIC_RATE_ADJUST_INT_MDIOr BCM56218_A0_READ_CMIC_RATE_ADJUST_INT_MDIOr
#define WRITE_CMIC_RATE_ADJUST_INT_MDIOr BCM56218_A0_WRITE_CMIC_RATE_ADJUST_INT_MDIOr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_RATE_ADJUST_INT_MDIOr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_RATE_ADJUST_STDMA
 * BLOCKS:   CMIC
 * DESC:     
The clock divider configuration register for Stats DMA.

Various parts of the chip involved in rate control 
require a constant, known frequency. This reference 
frequency is based off of the chip 's core clock.
However, the core clock can be different in different
designs, thus the need for this register.

The core clock frequency is multiplied by the rational
quantity (DIVIDEND/DIVISOR), and the further divided
down by 2 to produce the actual MDIO operation freqeuncy.

To avoid skew, it is recommended that the DIVIDEND value
usually be set to 1.

The default values are for 133MHz operation:
DIVIDEND=1, DIVISOR=6, 
MDIO operation freq = 133MHz/(6*2) =~ 11MHz

For 157MHz core clock chips, set:
DIVIDEND=1, DIVISOR=7, 
MDIO operation freq = 133MHz/(7*2) =~ 11MHz


 * SIZE:     32
 * FIELDS:
 *     DIVISOR          Denominator of clock scale factor.
 *     DIVIDEND         Numerator of clock scale factor.
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_RATE_ADJUST_STDMAr 0x000001b0

#define BCM56218_A0_CMIC_RATE_ADJUST_STDMAr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_RATE_ADJUST_STDMA.
 *
 */
typedef union BCM56218_A0_CMIC_RATE_ADJUST_STDMAr_s {
	uint32_t v[1];
	uint32_t cmic_rate_adjust_stdma[1];
	uint32_t _cmic_rate_adjust_stdma;
} BCM56218_A0_CMIC_RATE_ADJUST_STDMAr_t;

#define BCM56218_A0_CMIC_RATE_ADJUST_STDMAr_CLR(r) (r).cmic_rate_adjust_stdma[0] = 0
#define BCM56218_A0_CMIC_RATE_ADJUST_STDMAr_SET(r,d) (r).cmic_rate_adjust_stdma[0] = d
#define BCM56218_A0_CMIC_RATE_ADJUST_STDMAr_GET(r) (r).cmic_rate_adjust_stdma[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_RATE_ADJUST_STDMAr_DIVISORf_GET(r) (((r).cmic_rate_adjust_stdma[0]) & 0xffff)
#define BCM56218_A0_CMIC_RATE_ADJUST_STDMAr_DIVISORf_SET(r,f) (r).cmic_rate_adjust_stdma[0]=(((r).cmic_rate_adjust_stdma[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56218_A0_CMIC_RATE_ADJUST_STDMAr_DIVIDENDf_GET(r) ((((r).cmic_rate_adjust_stdma[0]) >> 16) & 0xffff)
#define BCM56218_A0_CMIC_RATE_ADJUST_STDMAr_DIVIDENDf_SET(r,f) (r).cmic_rate_adjust_stdma[0]=(((r).cmic_rate_adjust_stdma[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access CMIC_RATE_ADJUST_STDMA.
 *
 */
#define BCM56218_A0_READ_CMIC_RATE_ADJUST_STDMAr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_RATE_ADJUST_STDMAr,r._cmic_rate_adjust_stdma)
#define BCM56218_A0_WRITE_CMIC_RATE_ADJUST_STDMAr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_RATE_ADJUST_STDMAr,r._cmic_rate_adjust_stdma)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_RATE_ADJUST_STDMAr BCM56218_A0_CMIC_RATE_ADJUST_STDMAr
#define CMIC_RATE_ADJUST_STDMAr_SIZE BCM56218_A0_CMIC_RATE_ADJUST_STDMAr_SIZE
typedef BCM56218_A0_CMIC_RATE_ADJUST_STDMAr_t CMIC_RATE_ADJUST_STDMAr_t;
#define CMIC_RATE_ADJUST_STDMAr_CLR BCM56218_A0_CMIC_RATE_ADJUST_STDMAr_CLR
#define CMIC_RATE_ADJUST_STDMAr_SET BCM56218_A0_CMIC_RATE_ADJUST_STDMAr_SET
#define CMIC_RATE_ADJUST_STDMAr_GET BCM56218_A0_CMIC_RATE_ADJUST_STDMAr_GET
#define CMIC_RATE_ADJUST_STDMAr_DIVISORf_GET BCM56218_A0_CMIC_RATE_ADJUST_STDMAr_DIVISORf_GET
#define CMIC_RATE_ADJUST_STDMAr_DIVISORf_SET BCM56218_A0_CMIC_RATE_ADJUST_STDMAr_DIVISORf_SET
#define CMIC_RATE_ADJUST_STDMAr_DIVIDENDf_GET BCM56218_A0_CMIC_RATE_ADJUST_STDMAr_DIVIDENDf_GET
#define CMIC_RATE_ADJUST_STDMAr_DIVIDENDf_SET BCM56218_A0_CMIC_RATE_ADJUST_STDMAr_DIVIDENDf_SET
#define READ_CMIC_RATE_ADJUST_STDMAr BCM56218_A0_READ_CMIC_RATE_ADJUST_STDMAr
#define WRITE_CMIC_RATE_ADJUST_STDMAr BCM56218_A0_WRITE_CMIC_RATE_ADJUST_STDMAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_RATE_ADJUST_STDMAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_SBUS_RING_MAP
 * BLOCKS:   CMIC
 * DESC:     Map of S-bus agents on all 3 S-bus rings in the chip
 * SIZE:     32
 * FIELDS:
 *     RING_NUM_SBUS_ID_0 S-bus ring number for agent with S-bus ID  0
 *     RING_NUM_SBUS_ID_1 S-bus ring number for agent with S-bus ID  1
 *     RING_NUM_SBUS_ID_2 S-bus ring number for agent with S-bus ID  2
 *     RING_NUM_SBUS_ID_3 S-bus ring number for agent with S-bus ID  3
 *     RING_NUM_SBUS_ID_4 S-bus ring number for agent with S-bus ID  4
 *     RING_NUM_SBUS_ID_5 S-bus ring number for agent with S-bus ID  5
 *     RING_NUM_SBUS_ID_6 S-bus ring number for agent with S-bus ID  6
 *     RING_NUM_SBUS_ID_7 S-bus ring number for agent with S-bus ID  7
 *     RING_NUM_SBUS_ID_8 S-bus ring number for agent with S-bus ID  8
 *     RING_NUM_SBUS_ID_9 S-bus ring number for agent with S-bus ID  9
 *     RING_NUM_SBUS_ID_10 S-bus ring number for agent with S-bus ID 10
 *     RING_NUM_SBUS_ID_11 S-bus ring number for agent with S-bus ID 11
 *     RING_NUM_SBUS_ID_12 S-bus ring number for agent with S-bus ID 12
 *     RING_NUM_SBUS_ID_13 S-bus ring number for agent with S-bus ID 13
 *     RING_NUM_SBUS_ID_14 S-bus ring number for agent with S-bus ID 14
 *     RING_NUM_SBUS_ID_15 S-bus ring number for agent with S-bus ID 15
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_SBUS_RING_MAPr 0x00000400

#define BCM56218_A0_CMIC_SBUS_RING_MAPr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SBUS_RING_MAP.
 *
 */
typedef union BCM56218_A0_CMIC_SBUS_RING_MAPr_s {
	uint32_t v[1];
	uint32_t cmic_sbus_ring_map[1];
	uint32_t _cmic_sbus_ring_map;
} BCM56218_A0_CMIC_SBUS_RING_MAPr_t;

#define BCM56218_A0_CMIC_SBUS_RING_MAPr_CLR(r) (r).cmic_sbus_ring_map[0] = 0
#define BCM56218_A0_CMIC_SBUS_RING_MAPr_SET(r,d) (r).cmic_sbus_ring_map[0] = d
#define BCM56218_A0_CMIC_SBUS_RING_MAPr_GET(r) (r).cmic_sbus_ring_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_0f_GET(r) (((r).cmic_sbus_ring_map[0]) & 0x3)
#define BCM56218_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_0f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56218_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_1f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 2) & 0x3)
#define BCM56218_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_1f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM56218_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_2f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 4) & 0x3)
#define BCM56218_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_2f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM56218_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_3f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 6) & 0x3)
#define BCM56218_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_3f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM56218_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_4f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 8) & 0x3)
#define BCM56218_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_4f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM56218_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_5f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 10) & 0x3)
#define BCM56218_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_5f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCM56218_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_6f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 12) & 0x3)
#define BCM56218_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_6f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM56218_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_7f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 14) & 0x3)
#define BCM56218_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_7f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCM56218_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_8f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 16) & 0x3)
#define BCM56218_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_8f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM56218_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_9f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 18) & 0x3)
#define BCM56218_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_9f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32_t)0x3 << 18)) | ((((uint32_t)f) & 0x3) << 18))
#define BCM56218_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_10f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 20) & 0x3)
#define BCM56218_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_10f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32_t)0x3 << 20)) | ((((uint32_t)f) & 0x3) << 20))
#define BCM56218_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_11f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 22) & 0x3)
#define BCM56218_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_11f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32_t)0x3 << 22)) | ((((uint32_t)f) & 0x3) << 22))
#define BCM56218_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_12f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 24) & 0x3)
#define BCM56218_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_12f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32_t)0x3 << 24)) | ((((uint32_t)f) & 0x3) << 24))
#define BCM56218_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_13f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 26) & 0x3)
#define BCM56218_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_13f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32_t)0x3 << 26)) | ((((uint32_t)f) & 0x3) << 26))
#define BCM56218_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_14f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 28) & 0x3)
#define BCM56218_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_14f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32_t)0x3 << 28)) | ((((uint32_t)f) & 0x3) << 28))
#define BCM56218_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_15f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 30) & 0x3)
#define BCM56218_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_15f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))

/*
 * These macros can be used to access CMIC_SBUS_RING_MAP.
 *
 */
#define BCM56218_A0_READ_CMIC_SBUS_RING_MAPr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_SBUS_RING_MAPr,r._cmic_sbus_ring_map)
#define BCM56218_A0_WRITE_CMIC_SBUS_RING_MAPr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_SBUS_RING_MAPr,r._cmic_sbus_ring_map)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_SBUS_RING_MAPr BCM56218_A0_CMIC_SBUS_RING_MAPr
#define CMIC_SBUS_RING_MAPr_SIZE BCM56218_A0_CMIC_SBUS_RING_MAPr_SIZE
typedef BCM56218_A0_CMIC_SBUS_RING_MAPr_t CMIC_SBUS_RING_MAPr_t;
#define CMIC_SBUS_RING_MAPr_CLR BCM56218_A0_CMIC_SBUS_RING_MAPr_CLR
#define CMIC_SBUS_RING_MAPr_SET BCM56218_A0_CMIC_SBUS_RING_MAPr_SET
#define CMIC_SBUS_RING_MAPr_GET BCM56218_A0_CMIC_SBUS_RING_MAPr_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_0f_GET BCM56218_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_0f_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_0f_SET BCM56218_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_0f_SET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_1f_GET BCM56218_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_1f_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_1f_SET BCM56218_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_1f_SET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_2f_GET BCM56218_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_2f_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_2f_SET BCM56218_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_2f_SET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_3f_GET BCM56218_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_3f_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_3f_SET BCM56218_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_3f_SET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_4f_GET BCM56218_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_4f_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_4f_SET BCM56218_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_4f_SET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_5f_GET BCM56218_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_5f_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_5f_SET BCM56218_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_5f_SET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_6f_GET BCM56218_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_6f_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_6f_SET BCM56218_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_6f_SET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_7f_GET BCM56218_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_7f_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_7f_SET BCM56218_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_7f_SET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_8f_GET BCM56218_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_8f_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_8f_SET BCM56218_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_8f_SET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_9f_GET BCM56218_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_9f_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_9f_SET BCM56218_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_9f_SET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_10f_GET BCM56218_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_10f_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_10f_SET BCM56218_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_10f_SET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_11f_GET BCM56218_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_11f_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_11f_SET BCM56218_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_11f_SET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_12f_GET BCM56218_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_12f_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_12f_SET BCM56218_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_12f_SET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_13f_GET BCM56218_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_13f_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_13f_SET BCM56218_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_13f_SET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_14f_GET BCM56218_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_14f_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_14f_SET BCM56218_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_14f_SET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_15f_GET BCM56218_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_15f_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_15f_SET BCM56218_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_15f_SET
#define READ_CMIC_SBUS_RING_MAPr BCM56218_A0_READ_CMIC_SBUS_RING_MAPr
#define WRITE_CMIC_SBUS_RING_MAPr BCM56218_A0_WRITE_CMIC_SBUS_RING_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_SBUS_RING_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_SBUS_TIMEOUT
 * BLOCKS:   CMIC
 * DESC:     Secret register that allows software to program the
S-bus operation completion time limit (in terms of 
number of core clocks).
If this limit is exceeded, the CMIC will set the SW PIO
"DONE" bit and the "ERROR" bit to indicate the timeout.

 * SIZE:     32
 * FIELDS:
 *     TIMEOUT_VAL      Timeout value in core clocks
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_SBUS_TIMEOUTr 0x00000408

#define BCM56218_A0_CMIC_SBUS_TIMEOUTr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SBUS_TIMEOUT.
 *
 */
typedef union BCM56218_A0_CMIC_SBUS_TIMEOUTr_s {
	uint32_t v[1];
	uint32_t cmic_sbus_timeout[1];
	uint32_t _cmic_sbus_timeout;
} BCM56218_A0_CMIC_SBUS_TIMEOUTr_t;

#define BCM56218_A0_CMIC_SBUS_TIMEOUTr_CLR(r) (r).cmic_sbus_timeout[0] = 0
#define BCM56218_A0_CMIC_SBUS_TIMEOUTr_SET(r,d) (r).cmic_sbus_timeout[0] = d
#define BCM56218_A0_CMIC_SBUS_TIMEOUTr_GET(r) (r).cmic_sbus_timeout[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_SBUS_TIMEOUTr_TIMEOUT_VALf_GET(r) ((r).cmic_sbus_timeout[0])
#define BCM56218_A0_CMIC_SBUS_TIMEOUTr_TIMEOUT_VALf_SET(r,f) (r).cmic_sbus_timeout[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_SBUS_TIMEOUT.
 *
 */
#define BCM56218_A0_READ_CMIC_SBUS_TIMEOUTr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_SBUS_TIMEOUTr,r._cmic_sbus_timeout)
#define BCM56218_A0_WRITE_CMIC_SBUS_TIMEOUTr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_SBUS_TIMEOUTr,r._cmic_sbus_timeout)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_SBUS_TIMEOUTr BCM56218_A0_CMIC_SBUS_TIMEOUTr
#define CMIC_SBUS_TIMEOUTr_SIZE BCM56218_A0_CMIC_SBUS_TIMEOUTr_SIZE
typedef BCM56218_A0_CMIC_SBUS_TIMEOUTr_t CMIC_SBUS_TIMEOUTr_t;
#define CMIC_SBUS_TIMEOUTr_CLR BCM56218_A0_CMIC_SBUS_TIMEOUTr_CLR
#define CMIC_SBUS_TIMEOUTr_SET BCM56218_A0_CMIC_SBUS_TIMEOUTr_SET
#define CMIC_SBUS_TIMEOUTr_GET BCM56218_A0_CMIC_SBUS_TIMEOUTr_GET
#define CMIC_SBUS_TIMEOUTr_TIMEOUT_VALf_GET BCM56218_A0_CMIC_SBUS_TIMEOUTr_TIMEOUT_VALf_GET
#define CMIC_SBUS_TIMEOUTr_TIMEOUT_VALf_SET BCM56218_A0_CMIC_SBUS_TIMEOUTr_TIMEOUT_VALf_SET
#define READ_CMIC_SBUS_TIMEOUTr BCM56218_A0_READ_CMIC_SBUS_TIMEOUTr
#define WRITE_CMIC_SBUS_TIMEOUTr BCM56218_A0_WRITE_CMIC_SBUS_TIMEOUTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_SBUS_TIMEOUTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_SCAN_PORTS
 * BLOCKS:   CMIC
 * DESC:     Scan Ports Register
 * SIZE:     32
 * FIELDS:
 *     PORT_BITMAP      SCAN ports Register
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_SCAN_PORTSr 0x00000160

#define BCM56218_A0_CMIC_SCAN_PORTSr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SCAN_PORTS.
 *
 */
typedef union BCM56218_A0_CMIC_SCAN_PORTSr_s {
	uint32_t v[1];
	uint32_t cmic_scan_ports[1];
	uint32_t _cmic_scan_ports;
} BCM56218_A0_CMIC_SCAN_PORTSr_t;

#define BCM56218_A0_CMIC_SCAN_PORTSr_CLR(r) (r).cmic_scan_ports[0] = 0
#define BCM56218_A0_CMIC_SCAN_PORTSr_SET(r,d) (r).cmic_scan_ports[0] = d
#define BCM56218_A0_CMIC_SCAN_PORTSr_GET(r) (r).cmic_scan_ports[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_SCAN_PORTSr_PORT_BITMAPf_GET(r) ((r).cmic_scan_ports[0])
#define BCM56218_A0_CMIC_SCAN_PORTSr_PORT_BITMAPf_SET(r,f) (r).cmic_scan_ports[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_SCAN_PORTS.
 *
 */
#define BCM56218_A0_READ_CMIC_SCAN_PORTSr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_SCAN_PORTSr,r._cmic_scan_ports)
#define BCM56218_A0_WRITE_CMIC_SCAN_PORTSr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_SCAN_PORTSr,r._cmic_scan_ports)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_SCAN_PORTSr BCM56218_A0_CMIC_SCAN_PORTSr
#define CMIC_SCAN_PORTSr_SIZE BCM56218_A0_CMIC_SCAN_PORTSr_SIZE
typedef BCM56218_A0_CMIC_SCAN_PORTSr_t CMIC_SCAN_PORTSr_t;
#define CMIC_SCAN_PORTSr_CLR BCM56218_A0_CMIC_SCAN_PORTSr_CLR
#define CMIC_SCAN_PORTSr_SET BCM56218_A0_CMIC_SCAN_PORTSr_SET
#define CMIC_SCAN_PORTSr_GET BCM56218_A0_CMIC_SCAN_PORTSr_GET
#define CMIC_SCAN_PORTSr_PORT_BITMAPf_GET BCM56218_A0_CMIC_SCAN_PORTSr_PORT_BITMAPf_GET
#define CMIC_SCAN_PORTSr_PORT_BITMAPf_SET BCM56218_A0_CMIC_SCAN_PORTSr_PORT_BITMAPf_SET
#define READ_CMIC_SCAN_PORTSr BCM56218_A0_READ_CMIC_SCAN_PORTSr
#define WRITE_CMIC_SCAN_PORTSr BCM56218_A0_WRITE_CMIC_SCAN_PORTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_SCAN_PORTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_SCAN_PORTS_HI
 * BLOCKS:   CMIC
 * DESC:     Scan Ports Register, upper 32 bits
 * SIZE:     32
 * FIELDS:
 *     PORT_BITMAP      SCAN ports Register
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_SCAN_PORTS_HIr 0x00000704

#define BCM56218_A0_CMIC_SCAN_PORTS_HIr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SCAN_PORTS_HI.
 *
 */
typedef union BCM56218_A0_CMIC_SCAN_PORTS_HIr_s {
	uint32_t v[1];
	uint32_t cmic_scan_ports_hi[1];
	uint32_t _cmic_scan_ports_hi;
} BCM56218_A0_CMIC_SCAN_PORTS_HIr_t;

#define BCM56218_A0_CMIC_SCAN_PORTS_HIr_CLR(r) (r).cmic_scan_ports_hi[0] = 0
#define BCM56218_A0_CMIC_SCAN_PORTS_HIr_SET(r,d) (r).cmic_scan_ports_hi[0] = d
#define BCM56218_A0_CMIC_SCAN_PORTS_HIr_GET(r) (r).cmic_scan_ports_hi[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_SCAN_PORTS_HIr_PORT_BITMAPf_GET(r) ((r).cmic_scan_ports_hi[0])
#define BCM56218_A0_CMIC_SCAN_PORTS_HIr_PORT_BITMAPf_SET(r,f) (r).cmic_scan_ports_hi[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_SCAN_PORTS_HI.
 *
 */
#define BCM56218_A0_READ_CMIC_SCAN_PORTS_HIr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_SCAN_PORTS_HIr,r._cmic_scan_ports_hi)
#define BCM56218_A0_WRITE_CMIC_SCAN_PORTS_HIr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_SCAN_PORTS_HIr,r._cmic_scan_ports_hi)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_SCAN_PORTS_HIr BCM56218_A0_CMIC_SCAN_PORTS_HIr
#define CMIC_SCAN_PORTS_HIr_SIZE BCM56218_A0_CMIC_SCAN_PORTS_HIr_SIZE
typedef BCM56218_A0_CMIC_SCAN_PORTS_HIr_t CMIC_SCAN_PORTS_HIr_t;
#define CMIC_SCAN_PORTS_HIr_CLR BCM56218_A0_CMIC_SCAN_PORTS_HIr_CLR
#define CMIC_SCAN_PORTS_HIr_SET BCM56218_A0_CMIC_SCAN_PORTS_HIr_SET
#define CMIC_SCAN_PORTS_HIr_GET BCM56218_A0_CMIC_SCAN_PORTS_HIr_GET
#define CMIC_SCAN_PORTS_HIr_PORT_BITMAPf_GET BCM56218_A0_CMIC_SCAN_PORTS_HIr_PORT_BITMAPf_GET
#define CMIC_SCAN_PORTS_HIr_PORT_BITMAPf_SET BCM56218_A0_CMIC_SCAN_PORTS_HIr_PORT_BITMAPf_SET
#define READ_CMIC_SCAN_PORTS_HIr BCM56218_A0_READ_CMIC_SCAN_PORTS_HIr
#define WRITE_CMIC_SCAN_PORTS_HIr BCM56218_A0_WRITE_CMIC_SCAN_PORTS_HIr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_SCAN_PORTS_HIr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_SCHAN_CTRL
 * BLOCKS:   CMIC
 * DESC:     Status and Control Register
 * SIZE:     32
 * FIELDS:
 *     BIT_POS          Selects one of 32 bits positions to be Set/Reset
 *     MSG_START        Set by CPU to start an SCH operation
 *     MSG_DONE         Set by CMIC to indicate an SCH operation completion
 *     RESERVED_1       Reserved
 *     BIT_VAL          Set to 1 to set a bit, 0 to reset a bit
 *     LINK_STATUS_CHANGE Set by CMIC to indicate Link status changed
 *     PCI_FATAL_ERR    Set by CMIC to indicate a Fatal Error during PCI master Operation
 *     PCI_PARITY_ERR   Set by CMIC to indicate a Parity Error during PCI master Operation
 *     RESERVED_3       Reserved
 *     MIIM_SCAN_BUSY   Set by CMIC indicating that MIIM scan cycle is in progress
 *     RESERVED_4       Reserved
 *     MIIM_RD_START    Set by CPU to start a Read operation on MIIM Interface
 *     MIIM_WR_START    Set by CPU to start a Write operation on MIIM Interface
 *     MIIM_OP_DONE     Set by CMIC to indicate Completion of MIIM Rd/Wr Operation
 *     MIIM_LINK_SCAN_EN Set by CPU to start automatic Link Status scanning
 *     RESERVED_5       Reserved
 *     NACK             Set by CMIC to indicate last S-bus operation resulted in a NACK(i.e., command was legal, but could not be serviced due tohardware resource limitations)Clearing the SCH_PIO_OPN_COMPLETE bit or starting a new SCH operation will automatically clear this bit
 *     RESERVED_6       Reserved
 *     TIMEOUT          Set by CMIC to indicate last S-bus operation resulted in a TIMEOUT.(i.e., no ACK was received by CMIC within the TIMEOUT intervalspecified in CMIC_SBUS_TIMEOUT)Clearing the SCH_PIO_OPN_COMPLETE bit or starting a new SCH operation will automatically clear this bit
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_SCHAN_CTRLr 0x00000050

#define BCM56218_A0_CMIC_SCHAN_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SCHAN_CTRL.
 *
 */
typedef union BCM56218_A0_CMIC_SCHAN_CTRLr_s {
	uint32_t v[1];
	uint32_t cmic_schan_ctrl[1];
	uint32_t _cmic_schan_ctrl;
} BCM56218_A0_CMIC_SCHAN_CTRLr_t;

#define BCM56218_A0_CMIC_SCHAN_CTRLr_CLR(r) (r).cmic_schan_ctrl[0] = 0
#define BCM56218_A0_CMIC_SCHAN_CTRLr_SET(r,d) (r).cmic_schan_ctrl[0] = d
#define BCM56218_A0_CMIC_SCHAN_CTRLr_GET(r) (r).cmic_schan_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_SCHAN_CTRLr_BIT_POSf_GET(r) (((r).cmic_schan_ctrl[0]) & 0x1f)
#define BCM56218_A0_CMIC_SCHAN_CTRLr_BIT_POSf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56218_A0_CMIC_SCHAN_CTRLr_MSG_STARTf_GET(r) (((r).cmic_schan_ctrl[0]) & 0x1)
#define BCM56218_A0_CMIC_SCHAN_CTRLr_MSG_STARTf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_CMIC_SCHAN_CTRLr_MSG_DONEf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 1) & 0x1)
#define BCM56218_A0_CMIC_SCHAN_CTRLr_MSG_DONEf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_CMIC_SCHAN_CTRLr_RESERVED_1f_GET(r) ((((r).cmic_schan_ctrl[0]) >> 2) & 0x3f)
#define BCM56218_A0_CMIC_SCHAN_CTRLr_RESERVED_1f_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x3f << 2)) | ((((uint32_t)f) & 0x3f) << 2))
#define BCM56218_A0_CMIC_SCHAN_CTRLr_BIT_VALf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 7) & 0x1)
#define BCM56218_A0_CMIC_SCHAN_CTRLr_BIT_VALf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56218_A0_CMIC_SCHAN_CTRLr_LINK_STATUS_CHANGEf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 8) & 0x1)
#define BCM56218_A0_CMIC_SCHAN_CTRLr_LINK_STATUS_CHANGEf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56218_A0_CMIC_SCHAN_CTRLr_PCI_FATAL_ERRf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 9) & 0x1)
#define BCM56218_A0_CMIC_SCHAN_CTRLr_PCI_FATAL_ERRf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56218_A0_CMIC_SCHAN_CTRLr_PCI_PARITY_ERRf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 10) & 0x1)
#define BCM56218_A0_CMIC_SCHAN_CTRLr_PCI_PARITY_ERRf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56218_A0_CMIC_SCHAN_CTRLr_RESERVED_3f_GET(r) ((((r).cmic_schan_ctrl[0]) >> 11) & 0x7)
#define BCM56218_A0_CMIC_SCHAN_CTRLr_RESERVED_3f_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11))
#define BCM56218_A0_CMIC_SCHAN_CTRLr_MIIM_SCAN_BUSYf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 14) & 0x1)
#define BCM56218_A0_CMIC_SCHAN_CTRLr_MIIM_SCAN_BUSYf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM56218_A0_CMIC_SCHAN_CTRLr_RESERVED_4f_GET(r) ((((r).cmic_schan_ctrl[0]) >> 15) & 0x1)
#define BCM56218_A0_CMIC_SCHAN_CTRLr_RESERVED_4f_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56218_A0_CMIC_SCHAN_CTRLr_MIIM_RD_STARTf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 16) & 0x1)
#define BCM56218_A0_CMIC_SCHAN_CTRLr_MIIM_RD_STARTf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56218_A0_CMIC_SCHAN_CTRLr_MIIM_WR_STARTf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 17) & 0x1)
#define BCM56218_A0_CMIC_SCHAN_CTRLr_MIIM_WR_STARTf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_CMIC_SCHAN_CTRLr_MIIM_OP_DONEf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 18) & 0x1)
#define BCM56218_A0_CMIC_SCHAN_CTRLr_MIIM_OP_DONEf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_CMIC_SCHAN_CTRLr_MIIM_LINK_SCAN_ENf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 19) & 0x1)
#define BCM56218_A0_CMIC_SCHAN_CTRLr_MIIM_LINK_SCAN_ENf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56218_A0_CMIC_SCHAN_CTRLr_RESERVED_5f_GET(r) ((((r).cmic_schan_ctrl[0]) >> 20) & 0x1)
#define BCM56218_A0_CMIC_SCHAN_CTRLr_RESERVED_5f_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM56218_A0_CMIC_SCHAN_CTRLr_NACKf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 21) & 0x1)
#define BCM56218_A0_CMIC_SCHAN_CTRLr_NACKf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM56218_A0_CMIC_SCHAN_CTRLr_RESERVED_6f_GET(r) ((((r).cmic_schan_ctrl[0]) >> 22) & 0x3ff)
#define BCM56218_A0_CMIC_SCHAN_CTRLr_RESERVED_6f_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x3ff << 22)) | ((((uint32_t)f) & 0x3ff) << 22))
#define BCM56218_A0_CMIC_SCHAN_CTRLr_TIMEOUTf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 22) & 0x1)
#define BCM56218_A0_CMIC_SCHAN_CTRLr_TIMEOUTf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))

/*
 * These macros can be used to access CMIC_SCHAN_CTRL.
 *
 */
#define BCM56218_A0_READ_CMIC_SCHAN_CTRLr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_SCHAN_CTRLr,r._cmic_schan_ctrl)
#define BCM56218_A0_WRITE_CMIC_SCHAN_CTRLr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_SCHAN_CTRLr,r._cmic_schan_ctrl)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_SCHAN_CTRLr BCM56218_A0_CMIC_SCHAN_CTRLr
#define CMIC_SCHAN_CTRLr_SIZE BCM56218_A0_CMIC_SCHAN_CTRLr_SIZE
typedef BCM56218_A0_CMIC_SCHAN_CTRLr_t CMIC_SCHAN_CTRLr_t;
#define CMIC_SCHAN_CTRLr_CLR BCM56218_A0_CMIC_SCHAN_CTRLr_CLR
#define CMIC_SCHAN_CTRLr_SET BCM56218_A0_CMIC_SCHAN_CTRLr_SET
#define CMIC_SCHAN_CTRLr_GET BCM56218_A0_CMIC_SCHAN_CTRLr_GET
#define CMIC_SCHAN_CTRLr_BIT_POSf_GET BCM56218_A0_CMIC_SCHAN_CTRLr_BIT_POSf_GET
#define CMIC_SCHAN_CTRLr_BIT_POSf_SET BCM56218_A0_CMIC_SCHAN_CTRLr_BIT_POSf_SET
#define CMIC_SCHAN_CTRLr_MSG_STARTf_GET BCM56218_A0_CMIC_SCHAN_CTRLr_MSG_STARTf_GET
#define CMIC_SCHAN_CTRLr_MSG_STARTf_SET BCM56218_A0_CMIC_SCHAN_CTRLr_MSG_STARTf_SET
#define CMIC_SCHAN_CTRLr_MSG_DONEf_GET BCM56218_A0_CMIC_SCHAN_CTRLr_MSG_DONEf_GET
#define CMIC_SCHAN_CTRLr_MSG_DONEf_SET BCM56218_A0_CMIC_SCHAN_CTRLr_MSG_DONEf_SET
#define CMIC_SCHAN_CTRLr_RESERVED_1f_GET BCM56218_A0_CMIC_SCHAN_CTRLr_RESERVED_1f_GET
#define CMIC_SCHAN_CTRLr_RESERVED_1f_SET BCM56218_A0_CMIC_SCHAN_CTRLr_RESERVED_1f_SET
#define CMIC_SCHAN_CTRLr_BIT_VALf_GET BCM56218_A0_CMIC_SCHAN_CTRLr_BIT_VALf_GET
#define CMIC_SCHAN_CTRLr_BIT_VALf_SET BCM56218_A0_CMIC_SCHAN_CTRLr_BIT_VALf_SET
#define CMIC_SCHAN_CTRLr_LINK_STATUS_CHANGEf_GET BCM56218_A0_CMIC_SCHAN_CTRLr_LINK_STATUS_CHANGEf_GET
#define CMIC_SCHAN_CTRLr_LINK_STATUS_CHANGEf_SET BCM56218_A0_CMIC_SCHAN_CTRLr_LINK_STATUS_CHANGEf_SET
#define CMIC_SCHAN_CTRLr_PCI_FATAL_ERRf_GET BCM56218_A0_CMIC_SCHAN_CTRLr_PCI_FATAL_ERRf_GET
#define CMIC_SCHAN_CTRLr_PCI_FATAL_ERRf_SET BCM56218_A0_CMIC_SCHAN_CTRLr_PCI_FATAL_ERRf_SET
#define CMIC_SCHAN_CTRLr_PCI_PARITY_ERRf_GET BCM56218_A0_CMIC_SCHAN_CTRLr_PCI_PARITY_ERRf_GET
#define CMIC_SCHAN_CTRLr_PCI_PARITY_ERRf_SET BCM56218_A0_CMIC_SCHAN_CTRLr_PCI_PARITY_ERRf_SET
#define CMIC_SCHAN_CTRLr_RESERVED_3f_GET BCM56218_A0_CMIC_SCHAN_CTRLr_RESERVED_3f_GET
#define CMIC_SCHAN_CTRLr_RESERVED_3f_SET BCM56218_A0_CMIC_SCHAN_CTRLr_RESERVED_3f_SET
#define CMIC_SCHAN_CTRLr_MIIM_SCAN_BUSYf_GET BCM56218_A0_CMIC_SCHAN_CTRLr_MIIM_SCAN_BUSYf_GET
#define CMIC_SCHAN_CTRLr_MIIM_SCAN_BUSYf_SET BCM56218_A0_CMIC_SCHAN_CTRLr_MIIM_SCAN_BUSYf_SET
#define CMIC_SCHAN_CTRLr_RESERVED_4f_GET BCM56218_A0_CMIC_SCHAN_CTRLr_RESERVED_4f_GET
#define CMIC_SCHAN_CTRLr_RESERVED_4f_SET BCM56218_A0_CMIC_SCHAN_CTRLr_RESERVED_4f_SET
#define CMIC_SCHAN_CTRLr_MIIM_RD_STARTf_GET BCM56218_A0_CMIC_SCHAN_CTRLr_MIIM_RD_STARTf_GET
#define CMIC_SCHAN_CTRLr_MIIM_RD_STARTf_SET BCM56218_A0_CMIC_SCHAN_CTRLr_MIIM_RD_STARTf_SET
#define CMIC_SCHAN_CTRLr_MIIM_WR_STARTf_GET BCM56218_A0_CMIC_SCHAN_CTRLr_MIIM_WR_STARTf_GET
#define CMIC_SCHAN_CTRLr_MIIM_WR_STARTf_SET BCM56218_A0_CMIC_SCHAN_CTRLr_MIIM_WR_STARTf_SET
#define CMIC_SCHAN_CTRLr_MIIM_OP_DONEf_GET BCM56218_A0_CMIC_SCHAN_CTRLr_MIIM_OP_DONEf_GET
#define CMIC_SCHAN_CTRLr_MIIM_OP_DONEf_SET BCM56218_A0_CMIC_SCHAN_CTRLr_MIIM_OP_DONEf_SET
#define CMIC_SCHAN_CTRLr_MIIM_LINK_SCAN_ENf_GET BCM56218_A0_CMIC_SCHAN_CTRLr_MIIM_LINK_SCAN_ENf_GET
#define CMIC_SCHAN_CTRLr_MIIM_LINK_SCAN_ENf_SET BCM56218_A0_CMIC_SCHAN_CTRLr_MIIM_LINK_SCAN_ENf_SET
#define CMIC_SCHAN_CTRLr_RESERVED_5f_GET BCM56218_A0_CMIC_SCHAN_CTRLr_RESERVED_5f_GET
#define CMIC_SCHAN_CTRLr_RESERVED_5f_SET BCM56218_A0_CMIC_SCHAN_CTRLr_RESERVED_5f_SET
#define CMIC_SCHAN_CTRLr_NACKf_GET BCM56218_A0_CMIC_SCHAN_CTRLr_NACKf_GET
#define CMIC_SCHAN_CTRLr_NACKf_SET BCM56218_A0_CMIC_SCHAN_CTRLr_NACKf_SET
#define CMIC_SCHAN_CTRLr_RESERVED_6f_GET BCM56218_A0_CMIC_SCHAN_CTRLr_RESERVED_6f_GET
#define CMIC_SCHAN_CTRLr_RESERVED_6f_SET BCM56218_A0_CMIC_SCHAN_CTRLr_RESERVED_6f_SET
#define CMIC_SCHAN_CTRLr_TIMEOUTf_GET BCM56218_A0_CMIC_SCHAN_CTRLr_TIMEOUTf_GET
#define CMIC_SCHAN_CTRLr_TIMEOUTf_SET BCM56218_A0_CMIC_SCHAN_CTRLr_TIMEOUTf_SET
#define READ_CMIC_SCHAN_CTRLr BCM56218_A0_READ_CMIC_SCHAN_CTRLr
#define WRITE_CMIC_SCHAN_CTRLr BCM56218_A0_WRITE_CMIC_SCHAN_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_SCHAN_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_SCHAN_ERR
 * BLOCKS:   CMIC
 * DESC:     Error Status Register
 * SIZE:     32
 * FIELDS:
 *     NACK             When set, indicates the last S-bus command resulted in an NACK(i.e., could not be fulfilled due to hardware resource limitations).
 *     RESERVED_1       Reserved
 *     ERR_CODE         Error code in the SCH Error message
 *     ERRBIT           When set, indicates the last S-bus command resulted in an error(i.e., the command was illegal, or accessed an invalid address)
 *     DATA_LEN         Data length in the SCH Error ACK message
 *     SRC_PORT         Source port in the SCH Error ACK message(not guaranteed to be set by all blocks)
 *     DST_PORT         Dest port in the SCH Error ACK message
 *     OP_CODE          Opcode in the SCH Error ACK message
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_SCHAN_ERRr 0x0000005c

#define BCM56218_A0_CMIC_SCHAN_ERRr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SCHAN_ERR.
 *
 */
typedef union BCM56218_A0_CMIC_SCHAN_ERRr_s {
	uint32_t v[1];
	uint32_t cmic_schan_err[1];
	uint32_t _cmic_schan_err;
} BCM56218_A0_CMIC_SCHAN_ERRr_t;

#define BCM56218_A0_CMIC_SCHAN_ERRr_CLR(r) (r).cmic_schan_err[0] = 0
#define BCM56218_A0_CMIC_SCHAN_ERRr_SET(r,d) (r).cmic_schan_err[0] = d
#define BCM56218_A0_CMIC_SCHAN_ERRr_GET(r) (r).cmic_schan_err[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_SCHAN_ERRr_NACKf_GET(r) (((r).cmic_schan_err[0]) & 0x1)
#define BCM56218_A0_CMIC_SCHAN_ERRr_NACKf_SET(r,f) (r).cmic_schan_err[0]=(((r).cmic_schan_err[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_CMIC_SCHAN_ERRr_RESERVED_1f_GET(r) ((((r).cmic_schan_err[0]) >> 1) & 0x7)
#define BCM56218_A0_CMIC_SCHAN_ERRr_RESERVED_1f_SET(r,f) (r).cmic_schan_err[0]=(((r).cmic_schan_err[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define BCM56218_A0_CMIC_SCHAN_ERRr_ERR_CODEf_GET(r) ((((r).cmic_schan_err[0]) >> 4) & 0x3)
#define BCM56218_A0_CMIC_SCHAN_ERRr_ERR_CODEf_SET(r,f) (r).cmic_schan_err[0]=(((r).cmic_schan_err[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM56218_A0_CMIC_SCHAN_ERRr_ERRBITf_GET(r) ((((r).cmic_schan_err[0]) >> 6) & 0x1)
#define BCM56218_A0_CMIC_SCHAN_ERRr_ERRBITf_SET(r,f) (r).cmic_schan_err[0]=(((r).cmic_schan_err[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56218_A0_CMIC_SCHAN_ERRr_DATA_LENf_GET(r) ((((r).cmic_schan_err[0]) >> 7) & 0x7f)
#define BCM56218_A0_CMIC_SCHAN_ERRr_DATA_LENf_SET(r,f) (r).cmic_schan_err[0]=(((r).cmic_schan_err[0] & ~((uint32_t)0x7f << 7)) | ((((uint32_t)f) & 0x7f) << 7))
#define BCM56218_A0_CMIC_SCHAN_ERRr_SRC_PORTf_GET(r) ((((r).cmic_schan_err[0]) >> 14) & 0x3f)
#define BCM56218_A0_CMIC_SCHAN_ERRr_SRC_PORTf_SET(r,f) (r).cmic_schan_err[0]=(((r).cmic_schan_err[0] & ~((uint32_t)0x3f << 14)) | ((((uint32_t)f) & 0x3f) << 14))
#define BCM56218_A0_CMIC_SCHAN_ERRr_DST_PORTf_GET(r) ((((r).cmic_schan_err[0]) >> 20) & 0x3f)
#define BCM56218_A0_CMIC_SCHAN_ERRr_DST_PORTf_SET(r,f) (r).cmic_schan_err[0]=(((r).cmic_schan_err[0] & ~((uint32_t)0x3f << 20)) | ((((uint32_t)f) & 0x3f) << 20))
#define BCM56218_A0_CMIC_SCHAN_ERRr_OP_CODEf_GET(r) ((((r).cmic_schan_err[0]) >> 26) & 0x3f)
#define BCM56218_A0_CMIC_SCHAN_ERRr_OP_CODEf_SET(r,f) (r).cmic_schan_err[0]=(((r).cmic_schan_err[0] & ~((uint32_t)0x3f << 26)) | ((((uint32_t)f) & 0x3f) << 26))

/*
 * These macros can be used to access CMIC_SCHAN_ERR.
 *
 */
#define BCM56218_A0_READ_CMIC_SCHAN_ERRr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_SCHAN_ERRr,r._cmic_schan_err)
#define BCM56218_A0_WRITE_CMIC_SCHAN_ERRr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_SCHAN_ERRr,r._cmic_schan_err)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_SCHAN_ERRr BCM56218_A0_CMIC_SCHAN_ERRr
#define CMIC_SCHAN_ERRr_SIZE BCM56218_A0_CMIC_SCHAN_ERRr_SIZE
typedef BCM56218_A0_CMIC_SCHAN_ERRr_t CMIC_SCHAN_ERRr_t;
#define CMIC_SCHAN_ERRr_CLR BCM56218_A0_CMIC_SCHAN_ERRr_CLR
#define CMIC_SCHAN_ERRr_SET BCM56218_A0_CMIC_SCHAN_ERRr_SET
#define CMIC_SCHAN_ERRr_GET BCM56218_A0_CMIC_SCHAN_ERRr_GET
#define CMIC_SCHAN_ERRr_NACKf_GET BCM56218_A0_CMIC_SCHAN_ERRr_NACKf_GET
#define CMIC_SCHAN_ERRr_NACKf_SET BCM56218_A0_CMIC_SCHAN_ERRr_NACKf_SET
#define CMIC_SCHAN_ERRr_RESERVED_1f_GET BCM56218_A0_CMIC_SCHAN_ERRr_RESERVED_1f_GET
#define CMIC_SCHAN_ERRr_RESERVED_1f_SET BCM56218_A0_CMIC_SCHAN_ERRr_RESERVED_1f_SET
#define CMIC_SCHAN_ERRr_ERR_CODEf_GET BCM56218_A0_CMIC_SCHAN_ERRr_ERR_CODEf_GET
#define CMIC_SCHAN_ERRr_ERR_CODEf_SET BCM56218_A0_CMIC_SCHAN_ERRr_ERR_CODEf_SET
#define CMIC_SCHAN_ERRr_ERRBITf_GET BCM56218_A0_CMIC_SCHAN_ERRr_ERRBITf_GET
#define CMIC_SCHAN_ERRr_ERRBITf_SET BCM56218_A0_CMIC_SCHAN_ERRr_ERRBITf_SET
#define CMIC_SCHAN_ERRr_DATA_LENf_GET BCM56218_A0_CMIC_SCHAN_ERRr_DATA_LENf_GET
#define CMIC_SCHAN_ERRr_DATA_LENf_SET BCM56218_A0_CMIC_SCHAN_ERRr_DATA_LENf_SET
#define CMIC_SCHAN_ERRr_SRC_PORTf_GET BCM56218_A0_CMIC_SCHAN_ERRr_SRC_PORTf_GET
#define CMIC_SCHAN_ERRr_SRC_PORTf_SET BCM56218_A0_CMIC_SCHAN_ERRr_SRC_PORTf_SET
#define CMIC_SCHAN_ERRr_DST_PORTf_GET BCM56218_A0_CMIC_SCHAN_ERRr_DST_PORTf_GET
#define CMIC_SCHAN_ERRr_DST_PORTf_SET BCM56218_A0_CMIC_SCHAN_ERRr_DST_PORTf_SET
#define CMIC_SCHAN_ERRr_OP_CODEf_GET BCM56218_A0_CMIC_SCHAN_ERRr_OP_CODEf_GET
#define CMIC_SCHAN_ERRr_OP_CODEf_SET BCM56218_A0_CMIC_SCHAN_ERRr_OP_CODEf_SET
#define READ_CMIC_SCHAN_ERRr BCM56218_A0_READ_CMIC_SCHAN_ERRr
#define WRITE_CMIC_SCHAN_ERRr BCM56218_A0_WRITE_CMIC_SCHAN_ERRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_SCHAN_ERRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_SCHAN_MESSAGE
 * BLOCKS:   CMIC
 * DESC:     S-bus PIO Message Register Set
 * SIZE:     32
 * FIELDS:
 *     DATA             S-channel data (Rd/Wr) word
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_SCHAN_MESSAGEr 0x00000000

#define BCM56218_A0_CMIC_SCHAN_MESSAGEr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SCHAN_MESSAGE.
 *
 */
typedef union BCM56218_A0_CMIC_SCHAN_MESSAGEr_s {
	uint32_t v[1];
	uint32_t cmic_schan_message[1];
	uint32_t _cmic_schan_message;
} BCM56218_A0_CMIC_SCHAN_MESSAGEr_t;

#define BCM56218_A0_CMIC_SCHAN_MESSAGEr_CLR(r) (r).cmic_schan_message[0] = 0
#define BCM56218_A0_CMIC_SCHAN_MESSAGEr_SET(r,d) (r).cmic_schan_message[0] = d
#define BCM56218_A0_CMIC_SCHAN_MESSAGEr_GET(r) (r).cmic_schan_message[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_SCHAN_MESSAGEr_DATAf_GET(r) ((r).cmic_schan_message[0])
#define BCM56218_A0_CMIC_SCHAN_MESSAGEr_DATAf_SET(r,f) (r).cmic_schan_message[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_SCHAN_MESSAGE.
 *
 */
#define BCM56218_A0_READ_CMIC_SCHAN_MESSAGEr(u,i,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_SCHAN_MESSAGEr+(4*(i)),r._cmic_schan_message)
#define BCM56218_A0_WRITE_CMIC_SCHAN_MESSAGEr(u,i,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_SCHAN_MESSAGEr+(4*(i)),r._cmic_schan_message)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_SCHAN_MESSAGEr BCM56218_A0_CMIC_SCHAN_MESSAGEr
#define CMIC_SCHAN_MESSAGEr_SIZE BCM56218_A0_CMIC_SCHAN_MESSAGEr_SIZE
typedef BCM56218_A0_CMIC_SCHAN_MESSAGEr_t CMIC_SCHAN_MESSAGEr_t;
#define CMIC_SCHAN_MESSAGEr_CLR BCM56218_A0_CMIC_SCHAN_MESSAGEr_CLR
#define CMIC_SCHAN_MESSAGEr_SET BCM56218_A0_CMIC_SCHAN_MESSAGEr_SET
#define CMIC_SCHAN_MESSAGEr_GET BCM56218_A0_CMIC_SCHAN_MESSAGEr_GET
#define CMIC_SCHAN_MESSAGEr_DATAf_GET BCM56218_A0_CMIC_SCHAN_MESSAGEr_DATAf_GET
#define CMIC_SCHAN_MESSAGEr_DATAf_SET BCM56218_A0_CMIC_SCHAN_MESSAGEr_DATAf_SET
#define READ_CMIC_SCHAN_MESSAGEr BCM56218_A0_READ_CMIC_SCHAN_MESSAGEr
#define WRITE_CMIC_SCHAN_MESSAGEr BCM56218_A0_WRITE_CMIC_SCHAN_MESSAGEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_SCHAN_MESSAGEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_SCHAN_MESSAGE_EXT
 * BLOCKS:   CMIC
 * DESC:     S-bus PIO Message Register Set (extended)
 * SIZE:     32
 * FIELDS:
 *     DATA             S-channel data (Rd/Wr) word
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_SCHAN_MESSAGE_EXTr 0x00000800

#define BCM56218_A0_CMIC_SCHAN_MESSAGE_EXTr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SCHAN_MESSAGE_EXT.
 *
 */
typedef union BCM56218_A0_CMIC_SCHAN_MESSAGE_EXTr_s {
	uint32_t v[1];
	uint32_t cmic_schan_message_ext[1];
	uint32_t _cmic_schan_message_ext;
} BCM56218_A0_CMIC_SCHAN_MESSAGE_EXTr_t;

#define BCM56218_A0_CMIC_SCHAN_MESSAGE_EXTr_CLR(r) (r).cmic_schan_message_ext[0] = 0
#define BCM56218_A0_CMIC_SCHAN_MESSAGE_EXTr_SET(r,d) (r).cmic_schan_message_ext[0] = d
#define BCM56218_A0_CMIC_SCHAN_MESSAGE_EXTr_GET(r) (r).cmic_schan_message_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_SCHAN_MESSAGE_EXTr_DATAf_GET(r) ((r).cmic_schan_message_ext[0])
#define BCM56218_A0_CMIC_SCHAN_MESSAGE_EXTr_DATAf_SET(r,f) (r).cmic_schan_message_ext[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_SCHAN_MESSAGE_EXT.
 *
 */
#define BCM56218_A0_READ_CMIC_SCHAN_MESSAGE_EXTr(u,i,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_SCHAN_MESSAGE_EXTr+(4*(i)),r._cmic_schan_message_ext)
#define BCM56218_A0_WRITE_CMIC_SCHAN_MESSAGE_EXTr(u,i,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_SCHAN_MESSAGE_EXTr+(4*(i)),r._cmic_schan_message_ext)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_SCHAN_MESSAGE_EXTr BCM56218_A0_CMIC_SCHAN_MESSAGE_EXTr
#define CMIC_SCHAN_MESSAGE_EXTr_SIZE BCM56218_A0_CMIC_SCHAN_MESSAGE_EXTr_SIZE
typedef BCM56218_A0_CMIC_SCHAN_MESSAGE_EXTr_t CMIC_SCHAN_MESSAGE_EXTr_t;
#define CMIC_SCHAN_MESSAGE_EXTr_CLR BCM56218_A0_CMIC_SCHAN_MESSAGE_EXTr_CLR
#define CMIC_SCHAN_MESSAGE_EXTr_SET BCM56218_A0_CMIC_SCHAN_MESSAGE_EXTr_SET
#define CMIC_SCHAN_MESSAGE_EXTr_GET BCM56218_A0_CMIC_SCHAN_MESSAGE_EXTr_GET
#define CMIC_SCHAN_MESSAGE_EXTr_DATAf_GET BCM56218_A0_CMIC_SCHAN_MESSAGE_EXTr_DATAf_GET
#define CMIC_SCHAN_MESSAGE_EXTr_DATAf_SET BCM56218_A0_CMIC_SCHAN_MESSAGE_EXTr_DATAf_SET
#define READ_CMIC_SCHAN_MESSAGE_EXTr BCM56218_A0_READ_CMIC_SCHAN_MESSAGE_EXTr
#define WRITE_CMIC_SCHAN_MESSAGE_EXTr BCM56218_A0_WRITE_CMIC_SCHAN_MESSAGE_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_SCHAN_MESSAGE_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_SCHAN_RCPU_RPIO_MESSAGE
 * BLOCKS:   CMIC
 * DESC:     S-bus Remote PIO Message Register Set
 * SIZE:     32
 * FIELDS:
 *     DATA             S-channel data (Rd/Wr) word
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_SCHAN_RCPU_RPIO_MESSAGEr 0x00000900

#define BCM56218_A0_CMIC_SCHAN_RCPU_RPIO_MESSAGEr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SCHAN_RCPU_RPIO_MESSAGE.
 *
 */
typedef union BCM56218_A0_CMIC_SCHAN_RCPU_RPIO_MESSAGEr_s {
	uint32_t v[1];
	uint32_t cmic_schan_rcpu_rpio_message[1];
	uint32_t _cmic_schan_rcpu_rpio_message;
} BCM56218_A0_CMIC_SCHAN_RCPU_RPIO_MESSAGEr_t;

#define BCM56218_A0_CMIC_SCHAN_RCPU_RPIO_MESSAGEr_CLR(r) (r).cmic_schan_rcpu_rpio_message[0] = 0
#define BCM56218_A0_CMIC_SCHAN_RCPU_RPIO_MESSAGEr_SET(r,d) (r).cmic_schan_rcpu_rpio_message[0] = d
#define BCM56218_A0_CMIC_SCHAN_RCPU_RPIO_MESSAGEr_GET(r) (r).cmic_schan_rcpu_rpio_message[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_SCHAN_RCPU_RPIO_MESSAGEr_DATAf_GET(r) ((r).cmic_schan_rcpu_rpio_message[0])
#define BCM56218_A0_CMIC_SCHAN_RCPU_RPIO_MESSAGEr_DATAf_SET(r,f) (r).cmic_schan_rcpu_rpio_message[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_SCHAN_RCPU_RPIO_MESSAGE.
 *
 */
#define BCM56218_A0_READ_CMIC_SCHAN_RCPU_RPIO_MESSAGEr(u,i,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_SCHAN_RCPU_RPIO_MESSAGEr+(4*(i)),r._cmic_schan_rcpu_rpio_message)
#define BCM56218_A0_WRITE_CMIC_SCHAN_RCPU_RPIO_MESSAGEr(u,i,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_SCHAN_RCPU_RPIO_MESSAGEr+(4*(i)),r._cmic_schan_rcpu_rpio_message)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_SCHAN_RCPU_RPIO_MESSAGEr BCM56218_A0_CMIC_SCHAN_RCPU_RPIO_MESSAGEr
#define CMIC_SCHAN_RCPU_RPIO_MESSAGEr_SIZE BCM56218_A0_CMIC_SCHAN_RCPU_RPIO_MESSAGEr_SIZE
typedef BCM56218_A0_CMIC_SCHAN_RCPU_RPIO_MESSAGEr_t CMIC_SCHAN_RCPU_RPIO_MESSAGEr_t;
#define CMIC_SCHAN_RCPU_RPIO_MESSAGEr_CLR BCM56218_A0_CMIC_SCHAN_RCPU_RPIO_MESSAGEr_CLR
#define CMIC_SCHAN_RCPU_RPIO_MESSAGEr_SET BCM56218_A0_CMIC_SCHAN_RCPU_RPIO_MESSAGEr_SET
#define CMIC_SCHAN_RCPU_RPIO_MESSAGEr_GET BCM56218_A0_CMIC_SCHAN_RCPU_RPIO_MESSAGEr_GET
#define CMIC_SCHAN_RCPU_RPIO_MESSAGEr_DATAf_GET BCM56218_A0_CMIC_SCHAN_RCPU_RPIO_MESSAGEr_DATAf_GET
#define CMIC_SCHAN_RCPU_RPIO_MESSAGEr_DATAf_SET BCM56218_A0_CMIC_SCHAN_RCPU_RPIO_MESSAGEr_DATAf_SET
#define READ_CMIC_SCHAN_RCPU_RPIO_MESSAGEr BCM56218_A0_READ_CMIC_SCHAN_RCPU_RPIO_MESSAGEr
#define WRITE_CMIC_SCHAN_RCPU_RPIO_MESSAGEr BCM56218_A0_WRITE_CMIC_SCHAN_RCPU_RPIO_MESSAGEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_SCHAN_RCPU_RPIO_MESSAGEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_SLAM_DMA_CFG
 * BLOCKS:   CMIC
 * DESC:     Slam DMA Config Register
 * SIZE:     32
 * FIELDS:
 *     EN               Set by CPU to Enable Slam DMA Transfer
 *     ABORT            Set by CPU to Abort Slam DMA Transfer
 *     DONE             Set by CMIC to indicate Slam DMA Transfer CompletionCan be cleared (but not set) by CPU.
 *     ERROR            Set by CMIC to indicate Slam DMA Transfer wasaborted due to an error (most probably due to a NACK).Can be cleared (but not set) by CPU.
 *     RESERVED_1       Reserved
 *     BEATS            Written by CPU indicating number of data beats.For Slam DMA purposes, each table entry is 32-bit aligned.The widest S-bus table wr/rd supported is 640 bits.So, the valid values for this field are 1-20 (beats).
 *     ORDER            Set by CPU to specify Slam DMA order:'0' =>  forward (used for DELETE operations)'1' => backward (used for INSERT operations)
 *     REV_MODULO_COUNT Set by CPU to specify 'Entry count for the first iteration ofa Reverse Slam DMA operation'. The formula for this value is:( CMIC_SLAM_DMA_ENTRY_COUNT[23:0] % ( 64 / BEATS[4:0] ) )
 *     RESERVED_2       Reserved
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_SLAM_DMA_CFGr 0x0000044c

#define BCM56218_A0_CMIC_SLAM_DMA_CFGr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SLAM_DMA_CFG.
 *
 */
typedef union BCM56218_A0_CMIC_SLAM_DMA_CFGr_s {
	uint32_t v[1];
	uint32_t cmic_slam_dma_cfg[1];
	uint32_t _cmic_slam_dma_cfg;
} BCM56218_A0_CMIC_SLAM_DMA_CFGr_t;

#define BCM56218_A0_CMIC_SLAM_DMA_CFGr_CLR(r) (r).cmic_slam_dma_cfg[0] = 0
#define BCM56218_A0_CMIC_SLAM_DMA_CFGr_SET(r,d) (r).cmic_slam_dma_cfg[0] = d
#define BCM56218_A0_CMIC_SLAM_DMA_CFGr_GET(r) (r).cmic_slam_dma_cfg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_SLAM_DMA_CFGr_ENf_GET(r) (((r).cmic_slam_dma_cfg[0]) & 0x1)
#define BCM56218_A0_CMIC_SLAM_DMA_CFGr_ENf_SET(r,f) (r).cmic_slam_dma_cfg[0]=(((r).cmic_slam_dma_cfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_CMIC_SLAM_DMA_CFGr_ABORTf_GET(r) ((((r).cmic_slam_dma_cfg[0]) >> 1) & 0x1)
#define BCM56218_A0_CMIC_SLAM_DMA_CFGr_ABORTf_SET(r,f) (r).cmic_slam_dma_cfg[0]=(((r).cmic_slam_dma_cfg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_CMIC_SLAM_DMA_CFGr_DONEf_GET(r) ((((r).cmic_slam_dma_cfg[0]) >> 2) & 0x1)
#define BCM56218_A0_CMIC_SLAM_DMA_CFGr_DONEf_SET(r,f) (r).cmic_slam_dma_cfg[0]=(((r).cmic_slam_dma_cfg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_CMIC_SLAM_DMA_CFGr_ERRORf_GET(r) ((((r).cmic_slam_dma_cfg[0]) >> 3) & 0x1)
#define BCM56218_A0_CMIC_SLAM_DMA_CFGr_ERRORf_SET(r,f) (r).cmic_slam_dma_cfg[0]=(((r).cmic_slam_dma_cfg[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56218_A0_CMIC_SLAM_DMA_CFGr_RESERVED_1f_GET(r) ((((r).cmic_slam_dma_cfg[0]) >> 4) & 0xfff)
#define BCM56218_A0_CMIC_SLAM_DMA_CFGr_RESERVED_1f_SET(r,f) (r).cmic_slam_dma_cfg[0]=(((r).cmic_slam_dma_cfg[0] & ~((uint32_t)0xfff << 4)) | ((((uint32_t)f) & 0xfff) << 4))
#define BCM56218_A0_CMIC_SLAM_DMA_CFGr_BEATSf_GET(r) ((((r).cmic_slam_dma_cfg[0]) >> 16) & 0x1f)
#define BCM56218_A0_CMIC_SLAM_DMA_CFGr_BEATSf_SET(r,f) (r).cmic_slam_dma_cfg[0]=(((r).cmic_slam_dma_cfg[0] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define BCM56218_A0_CMIC_SLAM_DMA_CFGr_ORDERf_GET(r) ((((r).cmic_slam_dma_cfg[0]) >> 21) & 0x1)
#define BCM56218_A0_CMIC_SLAM_DMA_CFGr_ORDERf_SET(r,f) (r).cmic_slam_dma_cfg[0]=(((r).cmic_slam_dma_cfg[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM56218_A0_CMIC_SLAM_DMA_CFGr_REV_MODULO_COUNTf_GET(r) ((((r).cmic_slam_dma_cfg[0]) >> 22) & 0x3f)
#define BCM56218_A0_CMIC_SLAM_DMA_CFGr_REV_MODULO_COUNTf_SET(r,f) (r).cmic_slam_dma_cfg[0]=(((r).cmic_slam_dma_cfg[0] & ~((uint32_t)0x3f << 22)) | ((((uint32_t)f) & 0x3f) << 22))
#define BCM56218_A0_CMIC_SLAM_DMA_CFGr_RESERVED_2f_GET(r) ((((r).cmic_slam_dma_cfg[0]) >> 28) & 0xf)
#define BCM56218_A0_CMIC_SLAM_DMA_CFGr_RESERVED_2f_SET(r,f) (r).cmic_slam_dma_cfg[0]=(((r).cmic_slam_dma_cfg[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access CMIC_SLAM_DMA_CFG.
 *
 */
#define BCM56218_A0_READ_CMIC_SLAM_DMA_CFGr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_SLAM_DMA_CFGr,r._cmic_slam_dma_cfg)
#define BCM56218_A0_WRITE_CMIC_SLAM_DMA_CFGr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_SLAM_DMA_CFGr,r._cmic_slam_dma_cfg)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_SLAM_DMA_CFGr BCM56218_A0_CMIC_SLAM_DMA_CFGr
#define CMIC_SLAM_DMA_CFGr_SIZE BCM56218_A0_CMIC_SLAM_DMA_CFGr_SIZE
typedef BCM56218_A0_CMIC_SLAM_DMA_CFGr_t CMIC_SLAM_DMA_CFGr_t;
#define CMIC_SLAM_DMA_CFGr_CLR BCM56218_A0_CMIC_SLAM_DMA_CFGr_CLR
#define CMIC_SLAM_DMA_CFGr_SET BCM56218_A0_CMIC_SLAM_DMA_CFGr_SET
#define CMIC_SLAM_DMA_CFGr_GET BCM56218_A0_CMIC_SLAM_DMA_CFGr_GET
#define CMIC_SLAM_DMA_CFGr_ENf_GET BCM56218_A0_CMIC_SLAM_DMA_CFGr_ENf_GET
#define CMIC_SLAM_DMA_CFGr_ENf_SET BCM56218_A0_CMIC_SLAM_DMA_CFGr_ENf_SET
#define CMIC_SLAM_DMA_CFGr_ABORTf_GET BCM56218_A0_CMIC_SLAM_DMA_CFGr_ABORTf_GET
#define CMIC_SLAM_DMA_CFGr_ABORTf_SET BCM56218_A0_CMIC_SLAM_DMA_CFGr_ABORTf_SET
#define CMIC_SLAM_DMA_CFGr_DONEf_GET BCM56218_A0_CMIC_SLAM_DMA_CFGr_DONEf_GET
#define CMIC_SLAM_DMA_CFGr_DONEf_SET BCM56218_A0_CMIC_SLAM_DMA_CFGr_DONEf_SET
#define CMIC_SLAM_DMA_CFGr_ERRORf_GET BCM56218_A0_CMIC_SLAM_DMA_CFGr_ERRORf_GET
#define CMIC_SLAM_DMA_CFGr_ERRORf_SET BCM56218_A0_CMIC_SLAM_DMA_CFGr_ERRORf_SET
#define CMIC_SLAM_DMA_CFGr_RESERVED_1f_GET BCM56218_A0_CMIC_SLAM_DMA_CFGr_RESERVED_1f_GET
#define CMIC_SLAM_DMA_CFGr_RESERVED_1f_SET BCM56218_A0_CMIC_SLAM_DMA_CFGr_RESERVED_1f_SET
#define CMIC_SLAM_DMA_CFGr_BEATSf_GET BCM56218_A0_CMIC_SLAM_DMA_CFGr_BEATSf_GET
#define CMIC_SLAM_DMA_CFGr_BEATSf_SET BCM56218_A0_CMIC_SLAM_DMA_CFGr_BEATSf_SET
#define CMIC_SLAM_DMA_CFGr_ORDERf_GET BCM56218_A0_CMIC_SLAM_DMA_CFGr_ORDERf_GET
#define CMIC_SLAM_DMA_CFGr_ORDERf_SET BCM56218_A0_CMIC_SLAM_DMA_CFGr_ORDERf_SET
#define CMIC_SLAM_DMA_CFGr_REV_MODULO_COUNTf_GET BCM56218_A0_CMIC_SLAM_DMA_CFGr_REV_MODULO_COUNTf_GET
#define CMIC_SLAM_DMA_CFGr_REV_MODULO_COUNTf_SET BCM56218_A0_CMIC_SLAM_DMA_CFGr_REV_MODULO_COUNTf_SET
#define CMIC_SLAM_DMA_CFGr_RESERVED_2f_GET BCM56218_A0_CMIC_SLAM_DMA_CFGr_RESERVED_2f_GET
#define CMIC_SLAM_DMA_CFGr_RESERVED_2f_SET BCM56218_A0_CMIC_SLAM_DMA_CFGr_RESERVED_2f_SET
#define READ_CMIC_SLAM_DMA_CFGr BCM56218_A0_READ_CMIC_SLAM_DMA_CFGr
#define WRITE_CMIC_SLAM_DMA_CFGr BCM56218_A0_WRITE_CMIC_SLAM_DMA_CFGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_SLAM_DMA_CFGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDR
 * BLOCKS:   CMIC
 * DESC:     Slam DMA Current Entry S-bus Address Register
 * SIZE:     32
 * FIELDS:
 *     ADDR             Written by CMIC indicating S-bus address of the Table Entrycurrently being processed
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr 0x00000454

#define BCM56218_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDR.
 *
 */
typedef union BCM56218_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_s {
	uint32_t v[1];
	uint32_t cmic_slam_dma_cur_entry_sbus_addr[1];
	uint32_t _cmic_slam_dma_cur_entry_sbus_addr;
} BCM56218_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_t;

#define BCM56218_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_CLR(r) (r).cmic_slam_dma_cur_entry_sbus_addr[0] = 0
#define BCM56218_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_SET(r,d) (r).cmic_slam_dma_cur_entry_sbus_addr[0] = d
#define BCM56218_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_GET(r) (r).cmic_slam_dma_cur_entry_sbus_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_ADDRf_GET(r) ((r).cmic_slam_dma_cur_entry_sbus_addr[0])
#define BCM56218_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_ADDRf_SET(r,f) (r).cmic_slam_dma_cur_entry_sbus_addr[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDR.
 *
 */
#define BCM56218_A0_READ_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr,r._cmic_slam_dma_cur_entry_sbus_addr)
#define BCM56218_A0_WRITE_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr,r._cmic_slam_dma_cur_entry_sbus_addr)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr BCM56218_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr
#define CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_SIZE BCM56218_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_SIZE
typedef BCM56218_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_t CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_t;
#define CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_CLR BCM56218_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_CLR
#define CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_SET BCM56218_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_SET
#define CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_GET BCM56218_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_GET
#define CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_ADDRf_GET BCM56218_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_ADDRf_GET
#define CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_ADDRf_SET BCM56218_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_ADDRf_SET
#define READ_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr BCM56218_A0_READ_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr
#define WRITE_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr BCM56218_A0_WRITE_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_SLAM_DMA_ENTRY_COUNT
 * BLOCKS:   CMIC
 * DESC:     Slam DMA Entry Count Register
 * SIZE:     32
 * FIELDS:
 *     COUNT            Written by CPU indicating number of Slam entries for Slam DMA.
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_SLAM_DMA_ENTRY_COUNTr 0x00000448

#define BCM56218_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SLAM_DMA_ENTRY_COUNT.
 *
 */
typedef union BCM56218_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_s {
	uint32_t v[1];
	uint32_t cmic_slam_dma_entry_count[1];
	uint32_t _cmic_slam_dma_entry_count;
} BCM56218_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_t;

#define BCM56218_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_CLR(r) (r).cmic_slam_dma_entry_count[0] = 0
#define BCM56218_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_SET(r,d) (r).cmic_slam_dma_entry_count[0] = d
#define BCM56218_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_GET(r) (r).cmic_slam_dma_entry_count[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_COUNTf_GET(r) (((r).cmic_slam_dma_entry_count[0]) & 0xffffff)
#define BCM56218_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_COUNTf_SET(r,f) (r).cmic_slam_dma_entry_count[0]=(((r).cmic_slam_dma_entry_count[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))
#define BCM56218_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_RESERVED_1f_GET(r) ((((r).cmic_slam_dma_entry_count[0]) >> 24) & 0xff)
#define BCM56218_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_RESERVED_1f_SET(r,f) (r).cmic_slam_dma_entry_count[0]=(((r).cmic_slam_dma_entry_count[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access CMIC_SLAM_DMA_ENTRY_COUNT.
 *
 */
#define BCM56218_A0_READ_CMIC_SLAM_DMA_ENTRY_COUNTr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_SLAM_DMA_ENTRY_COUNTr,r._cmic_slam_dma_entry_count)
#define BCM56218_A0_WRITE_CMIC_SLAM_DMA_ENTRY_COUNTr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_SLAM_DMA_ENTRY_COUNTr,r._cmic_slam_dma_entry_count)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_SLAM_DMA_ENTRY_COUNTr BCM56218_A0_CMIC_SLAM_DMA_ENTRY_COUNTr
#define CMIC_SLAM_DMA_ENTRY_COUNTr_SIZE BCM56218_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_SIZE
typedef BCM56218_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_t CMIC_SLAM_DMA_ENTRY_COUNTr_t;
#define CMIC_SLAM_DMA_ENTRY_COUNTr_CLR BCM56218_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_CLR
#define CMIC_SLAM_DMA_ENTRY_COUNTr_SET BCM56218_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_SET
#define CMIC_SLAM_DMA_ENTRY_COUNTr_GET BCM56218_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_GET
#define CMIC_SLAM_DMA_ENTRY_COUNTr_COUNTf_GET BCM56218_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_COUNTf_GET
#define CMIC_SLAM_DMA_ENTRY_COUNTr_COUNTf_SET BCM56218_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_COUNTf_SET
#define CMIC_SLAM_DMA_ENTRY_COUNTr_RESERVED_1f_GET BCM56218_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_RESERVED_1f_GET
#define CMIC_SLAM_DMA_ENTRY_COUNTr_RESERVED_1f_SET BCM56218_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_RESERVED_1f_SET
#define READ_CMIC_SLAM_DMA_ENTRY_COUNTr BCM56218_A0_READ_CMIC_SLAM_DMA_ENTRY_COUNTr
#define WRITE_CMIC_SLAM_DMA_ENTRY_COUNTr BCM56218_A0_WRITE_CMIC_SLAM_DMA_ENTRY_COUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_SLAM_DMA_ENTRY_COUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_SLAM_DMA_PCIMEM_START_ADDR
 * BLOCKS:   CMIC
 * DESC:     Slam DMA PCI Memory Start Address Register

 * SIZE:     32
 * FIELDS:
 *     ADDR             Written by CPU indicating Slam DMA Physical (PCI) Memory Start Address
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr 0x00000440

#define BCM56218_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SLAM_DMA_PCIMEM_START_ADDR.
 *
 */
typedef union BCM56218_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr_s {
	uint32_t v[1];
	uint32_t cmic_slam_dma_pcimem_start_addr[1];
	uint32_t _cmic_slam_dma_pcimem_start_addr;
} BCM56218_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr_t;

#define BCM56218_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr_CLR(r) (r).cmic_slam_dma_pcimem_start_addr[0] = 0
#define BCM56218_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr_SET(r,d) (r).cmic_slam_dma_pcimem_start_addr[0] = d
#define BCM56218_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr_GET(r) (r).cmic_slam_dma_pcimem_start_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr_ADDRf_GET(r) ((r).cmic_slam_dma_pcimem_start_addr[0])
#define BCM56218_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr_ADDRf_SET(r,f) (r).cmic_slam_dma_pcimem_start_addr[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_SLAM_DMA_PCIMEM_START_ADDR.
 *
 */
#define BCM56218_A0_READ_CMIC_SLAM_DMA_PCIMEM_START_ADDRr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr,r._cmic_slam_dma_pcimem_start_addr)
#define BCM56218_A0_WRITE_CMIC_SLAM_DMA_PCIMEM_START_ADDRr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr,r._cmic_slam_dma_pcimem_start_addr)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_SLAM_DMA_PCIMEM_START_ADDRr BCM56218_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr
#define CMIC_SLAM_DMA_PCIMEM_START_ADDRr_SIZE BCM56218_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr_SIZE
typedef BCM56218_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr_t CMIC_SLAM_DMA_PCIMEM_START_ADDRr_t;
#define CMIC_SLAM_DMA_PCIMEM_START_ADDRr_CLR BCM56218_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr_CLR
#define CMIC_SLAM_DMA_PCIMEM_START_ADDRr_SET BCM56218_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr_SET
#define CMIC_SLAM_DMA_PCIMEM_START_ADDRr_GET BCM56218_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr_GET
#define CMIC_SLAM_DMA_PCIMEM_START_ADDRr_ADDRf_GET BCM56218_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr_ADDRf_GET
#define CMIC_SLAM_DMA_PCIMEM_START_ADDRr_ADDRf_SET BCM56218_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr_ADDRf_SET
#define READ_CMIC_SLAM_DMA_PCIMEM_START_ADDRr BCM56218_A0_READ_CMIC_SLAM_DMA_PCIMEM_START_ADDRr
#define WRITE_CMIC_SLAM_DMA_PCIMEM_START_ADDRr BCM56218_A0_WRITE_CMIC_SLAM_DMA_PCIMEM_START_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_SLAM_DMA_SBUS_START_ADDR
 * BLOCKS:   CMIC
 * DESC:     Slam DMA S-bus Start Address Register

 * SIZE:     32
 * FIELDS:
 *     ADDR             Written by CPU indicating Slam DMA Logical (S-bus) Memory Start Address. This address has the followingfields: table (6b), block (4b) and region+index (20b)
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr 0x00000444

#define BCM56218_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SLAM_DMA_SBUS_START_ADDR.
 *
 */
typedef union BCM56218_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr_s {
	uint32_t v[1];
	uint32_t cmic_slam_dma_sbus_start_addr[1];
	uint32_t _cmic_slam_dma_sbus_start_addr;
} BCM56218_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr_t;

#define BCM56218_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr_CLR(r) (r).cmic_slam_dma_sbus_start_addr[0] = 0
#define BCM56218_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr_SET(r,d) (r).cmic_slam_dma_sbus_start_addr[0] = d
#define BCM56218_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr_GET(r) (r).cmic_slam_dma_sbus_start_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr_ADDRf_GET(r) ((r).cmic_slam_dma_sbus_start_addr[0])
#define BCM56218_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr_ADDRf_SET(r,f) (r).cmic_slam_dma_sbus_start_addr[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_SLAM_DMA_SBUS_START_ADDR.
 *
 */
#define BCM56218_A0_READ_CMIC_SLAM_DMA_SBUS_START_ADDRr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr,r._cmic_slam_dma_sbus_start_addr)
#define BCM56218_A0_WRITE_CMIC_SLAM_DMA_SBUS_START_ADDRr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr,r._cmic_slam_dma_sbus_start_addr)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_SLAM_DMA_SBUS_START_ADDRr BCM56218_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr
#define CMIC_SLAM_DMA_SBUS_START_ADDRr_SIZE BCM56218_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr_SIZE
typedef BCM56218_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr_t CMIC_SLAM_DMA_SBUS_START_ADDRr_t;
#define CMIC_SLAM_DMA_SBUS_START_ADDRr_CLR BCM56218_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr_CLR
#define CMIC_SLAM_DMA_SBUS_START_ADDRr_SET BCM56218_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr_SET
#define CMIC_SLAM_DMA_SBUS_START_ADDRr_GET BCM56218_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr_GET
#define CMIC_SLAM_DMA_SBUS_START_ADDRr_ADDRf_GET BCM56218_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr_ADDRf_GET
#define CMIC_SLAM_DMA_SBUS_START_ADDRr_ADDRf_SET BCM56218_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr_ADDRf_SET
#define READ_CMIC_SLAM_DMA_SBUS_START_ADDRr BCM56218_A0_READ_CMIC_SLAM_DMA_SBUS_START_ADDRr
#define WRITE_CMIC_SLAM_DMA_SBUS_START_ADDRr BCM56218_A0_WRITE_CMIC_SLAM_DMA_SBUS_START_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_SOFT_RESET_REG
 * BLOCKS:   CMIC
 * DESC:     CMIC Soft Reset register
 * SIZE:     32
 * FIELDS:
 *     CMIC_GP_RST_L    Gport Reset (active low)
 *     CMIC_FP_RST_L    FPort Reset (active low)
 *     CMIC_GX12_RST_L  GX12 SERDES Reset (active low)
 *     CMIC_GX2_RST_L   GX2 SERDES Reset (active low)
 *     CMIC_G2P50_RST_L 2.5G SERDES 0 Reset (active low)
 *     CMIC_G2P51_RST_L 2.5G SERDES 1 Reset (active low)
 *     CMIC_MMU_RST_L   MMU Reset (active low)
 *     CMIC_IP_RST_L    IP Reset (active low)
 *     CMIC_EP_RST_L    EP Reset (active low)
 *     CMIC_XG_PLL_RST_L XG PLL Reset (active low)
 *     CMIC_BSAFE_RST_L Reserved, left here for SW
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_SOFT_RESET_REGr 0x00000580

#define BCM56218_A0_CMIC_SOFT_RESET_REGr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SOFT_RESET_REG.
 *
 */
typedef union BCM56218_A0_CMIC_SOFT_RESET_REGr_s {
	uint32_t v[1];
	uint32_t cmic_soft_reset_reg[1];
	uint32_t _cmic_soft_reset_reg;
} BCM56218_A0_CMIC_SOFT_RESET_REGr_t;

#define BCM56218_A0_CMIC_SOFT_RESET_REGr_CLR(r) (r).cmic_soft_reset_reg[0] = 0
#define BCM56218_A0_CMIC_SOFT_RESET_REGr_SET(r,d) (r).cmic_soft_reset_reg[0] = d
#define BCM56218_A0_CMIC_SOFT_RESET_REGr_GET(r) (r).cmic_soft_reset_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_SOFT_RESET_REGr_CMIC_GP_RST_Lf_GET(r) (((r).cmic_soft_reset_reg[0]) & 0x1)
#define BCM56218_A0_CMIC_SOFT_RESET_REGr_CMIC_GP_RST_Lf_SET(r,f) (r).cmic_soft_reset_reg[0]=(((r).cmic_soft_reset_reg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_CMIC_SOFT_RESET_REGr_CMIC_FP_RST_Lf_GET(r) ((((r).cmic_soft_reset_reg[0]) >> 1) & 0x1)
#define BCM56218_A0_CMIC_SOFT_RESET_REGr_CMIC_FP_RST_Lf_SET(r,f) (r).cmic_soft_reset_reg[0]=(((r).cmic_soft_reset_reg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_CMIC_SOFT_RESET_REGr_CMIC_GX12_RST_Lf_GET(r) ((((r).cmic_soft_reset_reg[0]) >> 2) & 0x1)
#define BCM56218_A0_CMIC_SOFT_RESET_REGr_CMIC_GX12_RST_Lf_SET(r,f) (r).cmic_soft_reset_reg[0]=(((r).cmic_soft_reset_reg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_CMIC_SOFT_RESET_REGr_CMIC_GX2_RST_Lf_GET(r) ((((r).cmic_soft_reset_reg[0]) >> 3) & 0x1)
#define BCM56218_A0_CMIC_SOFT_RESET_REGr_CMIC_GX2_RST_Lf_SET(r,f) (r).cmic_soft_reset_reg[0]=(((r).cmic_soft_reset_reg[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56218_A0_CMIC_SOFT_RESET_REGr_CMIC_G2P50_RST_Lf_GET(r) ((((r).cmic_soft_reset_reg[0]) >> 4) & 0x1)
#define BCM56218_A0_CMIC_SOFT_RESET_REGr_CMIC_G2P50_RST_Lf_SET(r,f) (r).cmic_soft_reset_reg[0]=(((r).cmic_soft_reset_reg[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56218_A0_CMIC_SOFT_RESET_REGr_CMIC_G2P51_RST_Lf_GET(r) ((((r).cmic_soft_reset_reg[0]) >> 5) & 0x1)
#define BCM56218_A0_CMIC_SOFT_RESET_REGr_CMIC_G2P51_RST_Lf_SET(r,f) (r).cmic_soft_reset_reg[0]=(((r).cmic_soft_reset_reg[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56218_A0_CMIC_SOFT_RESET_REGr_CMIC_MMU_RST_Lf_GET(r) ((((r).cmic_soft_reset_reg[0]) >> 6) & 0x1)
#define BCM56218_A0_CMIC_SOFT_RESET_REGr_CMIC_MMU_RST_Lf_SET(r,f) (r).cmic_soft_reset_reg[0]=(((r).cmic_soft_reset_reg[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56218_A0_CMIC_SOFT_RESET_REGr_CMIC_IP_RST_Lf_GET(r) ((((r).cmic_soft_reset_reg[0]) >> 7) & 0x1)
#define BCM56218_A0_CMIC_SOFT_RESET_REGr_CMIC_IP_RST_Lf_SET(r,f) (r).cmic_soft_reset_reg[0]=(((r).cmic_soft_reset_reg[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56218_A0_CMIC_SOFT_RESET_REGr_CMIC_EP_RST_Lf_GET(r) ((((r).cmic_soft_reset_reg[0]) >> 8) & 0x1)
#define BCM56218_A0_CMIC_SOFT_RESET_REGr_CMIC_EP_RST_Lf_SET(r,f) (r).cmic_soft_reset_reg[0]=(((r).cmic_soft_reset_reg[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56218_A0_CMIC_SOFT_RESET_REGr_CMIC_XG_PLL_RST_Lf_GET(r) ((((r).cmic_soft_reset_reg[0]) >> 9) & 0x1)
#define BCM56218_A0_CMIC_SOFT_RESET_REGr_CMIC_XG_PLL_RST_Lf_SET(r,f) (r).cmic_soft_reset_reg[0]=(((r).cmic_soft_reset_reg[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56218_A0_CMIC_SOFT_RESET_REGr_CMIC_BSAFE_RST_Lf_GET(r) ((((r).cmic_soft_reset_reg[0]) >> 10) & 0x1)
#define BCM56218_A0_CMIC_SOFT_RESET_REGr_CMIC_BSAFE_RST_Lf_SET(r,f) (r).cmic_soft_reset_reg[0]=(((r).cmic_soft_reset_reg[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56218_A0_CMIC_SOFT_RESET_REGr_RESERVED_1f_GET(r) ((((r).cmic_soft_reset_reg[0]) >> 11) & 0x1fffff)
#define BCM56218_A0_CMIC_SOFT_RESET_REGr_RESERVED_1f_SET(r,f) (r).cmic_soft_reset_reg[0]=(((r).cmic_soft_reset_reg[0] & ~((uint32_t)0x1fffff << 11)) | ((((uint32_t)f) & 0x1fffff) << 11))

/*
 * These macros can be used to access CMIC_SOFT_RESET_REG.
 *
 */
#define BCM56218_A0_READ_CMIC_SOFT_RESET_REGr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_SOFT_RESET_REGr,r._cmic_soft_reset_reg)
#define BCM56218_A0_WRITE_CMIC_SOFT_RESET_REGr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_SOFT_RESET_REGr,r._cmic_soft_reset_reg)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_SOFT_RESET_REGr BCM56218_A0_CMIC_SOFT_RESET_REGr
#define CMIC_SOFT_RESET_REGr_SIZE BCM56218_A0_CMIC_SOFT_RESET_REGr_SIZE
typedef BCM56218_A0_CMIC_SOFT_RESET_REGr_t CMIC_SOFT_RESET_REGr_t;
#define CMIC_SOFT_RESET_REGr_CLR BCM56218_A0_CMIC_SOFT_RESET_REGr_CLR
#define CMIC_SOFT_RESET_REGr_SET BCM56218_A0_CMIC_SOFT_RESET_REGr_SET
#define CMIC_SOFT_RESET_REGr_GET BCM56218_A0_CMIC_SOFT_RESET_REGr_GET
#define CMIC_SOFT_RESET_REGr_CMIC_GP_RST_Lf_GET BCM56218_A0_CMIC_SOFT_RESET_REGr_CMIC_GP_RST_Lf_GET
#define CMIC_SOFT_RESET_REGr_CMIC_GP_RST_Lf_SET BCM56218_A0_CMIC_SOFT_RESET_REGr_CMIC_GP_RST_Lf_SET
#define CMIC_SOFT_RESET_REGr_CMIC_FP_RST_Lf_GET BCM56218_A0_CMIC_SOFT_RESET_REGr_CMIC_FP_RST_Lf_GET
#define CMIC_SOFT_RESET_REGr_CMIC_FP_RST_Lf_SET BCM56218_A0_CMIC_SOFT_RESET_REGr_CMIC_FP_RST_Lf_SET
#define CMIC_SOFT_RESET_REGr_CMIC_GX12_RST_Lf_GET BCM56218_A0_CMIC_SOFT_RESET_REGr_CMIC_GX12_RST_Lf_GET
#define CMIC_SOFT_RESET_REGr_CMIC_GX12_RST_Lf_SET BCM56218_A0_CMIC_SOFT_RESET_REGr_CMIC_GX12_RST_Lf_SET
#define CMIC_SOFT_RESET_REGr_CMIC_GX2_RST_Lf_GET BCM56218_A0_CMIC_SOFT_RESET_REGr_CMIC_GX2_RST_Lf_GET
#define CMIC_SOFT_RESET_REGr_CMIC_GX2_RST_Lf_SET BCM56218_A0_CMIC_SOFT_RESET_REGr_CMIC_GX2_RST_Lf_SET
#define CMIC_SOFT_RESET_REGr_CMIC_G2P50_RST_Lf_GET BCM56218_A0_CMIC_SOFT_RESET_REGr_CMIC_G2P50_RST_Lf_GET
#define CMIC_SOFT_RESET_REGr_CMIC_G2P50_RST_Lf_SET BCM56218_A0_CMIC_SOFT_RESET_REGr_CMIC_G2P50_RST_Lf_SET
#define CMIC_SOFT_RESET_REGr_CMIC_G2P51_RST_Lf_GET BCM56218_A0_CMIC_SOFT_RESET_REGr_CMIC_G2P51_RST_Lf_GET
#define CMIC_SOFT_RESET_REGr_CMIC_G2P51_RST_Lf_SET BCM56218_A0_CMIC_SOFT_RESET_REGr_CMIC_G2P51_RST_Lf_SET
#define CMIC_SOFT_RESET_REGr_CMIC_MMU_RST_Lf_GET BCM56218_A0_CMIC_SOFT_RESET_REGr_CMIC_MMU_RST_Lf_GET
#define CMIC_SOFT_RESET_REGr_CMIC_MMU_RST_Lf_SET BCM56218_A0_CMIC_SOFT_RESET_REGr_CMIC_MMU_RST_Lf_SET
#define CMIC_SOFT_RESET_REGr_CMIC_IP_RST_Lf_GET BCM56218_A0_CMIC_SOFT_RESET_REGr_CMIC_IP_RST_Lf_GET
#define CMIC_SOFT_RESET_REGr_CMIC_IP_RST_Lf_SET BCM56218_A0_CMIC_SOFT_RESET_REGr_CMIC_IP_RST_Lf_SET
#define CMIC_SOFT_RESET_REGr_CMIC_EP_RST_Lf_GET BCM56218_A0_CMIC_SOFT_RESET_REGr_CMIC_EP_RST_Lf_GET
#define CMIC_SOFT_RESET_REGr_CMIC_EP_RST_Lf_SET BCM56218_A0_CMIC_SOFT_RESET_REGr_CMIC_EP_RST_Lf_SET
#define CMIC_SOFT_RESET_REGr_CMIC_XG_PLL_RST_Lf_GET BCM56218_A0_CMIC_SOFT_RESET_REGr_CMIC_XG_PLL_RST_Lf_GET
#define CMIC_SOFT_RESET_REGr_CMIC_XG_PLL_RST_Lf_SET BCM56218_A0_CMIC_SOFT_RESET_REGr_CMIC_XG_PLL_RST_Lf_SET
#define CMIC_SOFT_RESET_REGr_CMIC_BSAFE_RST_Lf_GET BCM56218_A0_CMIC_SOFT_RESET_REGr_CMIC_BSAFE_RST_Lf_GET
#define CMIC_SOFT_RESET_REGr_CMIC_BSAFE_RST_Lf_SET BCM56218_A0_CMIC_SOFT_RESET_REGr_CMIC_BSAFE_RST_Lf_SET
#define CMIC_SOFT_RESET_REGr_RESERVED_1f_GET BCM56218_A0_CMIC_SOFT_RESET_REGr_RESERVED_1f_GET
#define CMIC_SOFT_RESET_REGr_RESERVED_1f_SET BCM56218_A0_CMIC_SOFT_RESET_REGr_RESERVED_1f_SET
#define READ_CMIC_SOFT_RESET_REGr BCM56218_A0_READ_CMIC_SOFT_RESET_REGr
#define WRITE_CMIC_SOFT_RESET_REGr BCM56218_A0_WRITE_CMIC_SOFT_RESET_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_SOFT_RESET_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_STAT_DMA_ADDR
 * BLOCKS:   CMIC
 * DESC:     Stats memory start address

 * SIZE:     32
 * FIELDS:
 *     ADDR             Start memory address where the stats counters willbe written to
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_STAT_DMA_ADDRr 0x00000164

#define BCM56218_A0_CMIC_STAT_DMA_ADDRr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_ADDR.
 *
 */
typedef union BCM56218_A0_CMIC_STAT_DMA_ADDRr_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_addr[1];
	uint32_t _cmic_stat_dma_addr;
} BCM56218_A0_CMIC_STAT_DMA_ADDRr_t;

#define BCM56218_A0_CMIC_STAT_DMA_ADDRr_CLR(r) (r).cmic_stat_dma_addr[0] = 0
#define BCM56218_A0_CMIC_STAT_DMA_ADDRr_SET(r,d) (r).cmic_stat_dma_addr[0] = d
#define BCM56218_A0_CMIC_STAT_DMA_ADDRr_GET(r) (r).cmic_stat_dma_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_STAT_DMA_ADDRr_ADDRf_GET(r) ((r).cmic_stat_dma_addr[0])
#define BCM56218_A0_CMIC_STAT_DMA_ADDRr_ADDRf_SET(r,f) (r).cmic_stat_dma_addr[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_STAT_DMA_ADDR.
 *
 */
#define BCM56218_A0_READ_CMIC_STAT_DMA_ADDRr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_STAT_DMA_ADDRr,r._cmic_stat_dma_addr)
#define BCM56218_A0_WRITE_CMIC_STAT_DMA_ADDRr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_STAT_DMA_ADDRr,r._cmic_stat_dma_addr)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_ADDRr BCM56218_A0_CMIC_STAT_DMA_ADDRr
#define CMIC_STAT_DMA_ADDRr_SIZE BCM56218_A0_CMIC_STAT_DMA_ADDRr_SIZE
typedef BCM56218_A0_CMIC_STAT_DMA_ADDRr_t CMIC_STAT_DMA_ADDRr_t;
#define CMIC_STAT_DMA_ADDRr_CLR BCM56218_A0_CMIC_STAT_DMA_ADDRr_CLR
#define CMIC_STAT_DMA_ADDRr_SET BCM56218_A0_CMIC_STAT_DMA_ADDRr_SET
#define CMIC_STAT_DMA_ADDRr_GET BCM56218_A0_CMIC_STAT_DMA_ADDRr_GET
#define CMIC_STAT_DMA_ADDRr_ADDRf_GET BCM56218_A0_CMIC_STAT_DMA_ADDRr_ADDRf_GET
#define CMIC_STAT_DMA_ADDRr_ADDRf_SET BCM56218_A0_CMIC_STAT_DMA_ADDRr_ADDRf_SET
#define READ_CMIC_STAT_DMA_ADDRr BCM56218_A0_READ_CMIC_STAT_DMA_ADDRr
#define WRITE_CMIC_STAT_DMA_ADDRr BCM56218_A0_WRITE_CMIC_STAT_DMA_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_STAT_DMA_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_STAT_DMA_BLKNUM_MAP_15_8
 * BLOCKS:   CMIC
 * DESC:     Stats DMA port <-> block-number map, ports 15 to 8

 * SIZE:     32
 * FIELDS:
 *     SBUS_BLKNUM_8    S-bus block number for port  8
 *     SBUS_BLKNUM_9    S-bus block number for port  9
 *     SBUS_BLKNUM_10   S-bus block number for port 10
 *     SBUS_BLKNUM_11   S-bus block number for port 11
 *     SBUS_BLKNUM_12   S-bus block number for port 12
 *     SBUS_BLKNUM_13   S-bus block number for port 13
 *     SBUS_BLKNUM_14   S-bus block number for port 14
 *     SBUS_BLKNUM_15   S-bus block number for port 15
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r 0x00000484

#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_BLKNUM_MAP_15_8.
 *
 */
typedef union BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_blknum_map_15_8[1];
	uint32_t _cmic_stat_dma_blknum_map_15_8;
} BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_t;

#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_CLR(r) (r).cmic_stat_dma_blknum_map_15_8[0] = 0
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SET(r,d) (r).cmic_stat_dma_blknum_map_15_8[0] = d
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_GET(r) (r).cmic_stat_dma_blknum_map_15_8[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_8f_GET(r) (((r).cmic_stat_dma_blknum_map_15_8[0]) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_8f_SET(r,f) (r).cmic_stat_dma_blknum_map_15_8[0]=(((r).cmic_stat_dma_blknum_map_15_8[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_9f_GET(r) ((((r).cmic_stat_dma_blknum_map_15_8[0]) >> 4) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_9f_SET(r,f) (r).cmic_stat_dma_blknum_map_15_8[0]=(((r).cmic_stat_dma_blknum_map_15_8[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_10f_GET(r) ((((r).cmic_stat_dma_blknum_map_15_8[0]) >> 8) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_10f_SET(r,f) (r).cmic_stat_dma_blknum_map_15_8[0]=(((r).cmic_stat_dma_blknum_map_15_8[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_11f_GET(r) ((((r).cmic_stat_dma_blknum_map_15_8[0]) >> 12) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_11f_SET(r,f) (r).cmic_stat_dma_blknum_map_15_8[0]=(((r).cmic_stat_dma_blknum_map_15_8[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_12f_GET(r) ((((r).cmic_stat_dma_blknum_map_15_8[0]) >> 16) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_12f_SET(r,f) (r).cmic_stat_dma_blknum_map_15_8[0]=(((r).cmic_stat_dma_blknum_map_15_8[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_13f_GET(r) ((((r).cmic_stat_dma_blknum_map_15_8[0]) >> 20) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_13f_SET(r,f) (r).cmic_stat_dma_blknum_map_15_8[0]=(((r).cmic_stat_dma_blknum_map_15_8[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_14f_GET(r) ((((r).cmic_stat_dma_blknum_map_15_8[0]) >> 24) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_14f_SET(r,f) (r).cmic_stat_dma_blknum_map_15_8[0]=(((r).cmic_stat_dma_blknum_map_15_8[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_15f_GET(r) ((((r).cmic_stat_dma_blknum_map_15_8[0]) >> 28) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_15f_SET(r,f) (r).cmic_stat_dma_blknum_map_15_8[0]=(((r).cmic_stat_dma_blknum_map_15_8[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access CMIC_STAT_DMA_BLKNUM_MAP_15_8.
 *
 */
#define BCM56218_A0_READ_CMIC_STAT_DMA_BLKNUM_MAP_15_8r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r,r._cmic_stat_dma_blknum_map_15_8)
#define BCM56218_A0_WRITE_CMIC_STAT_DMA_BLKNUM_MAP_15_8r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r,r._cmic_stat_dma_blknum_map_15_8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SIZE BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SIZE
typedef BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_t CMIC_STAT_DMA_BLKNUM_MAP_15_8r_t;
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_CLR BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_CLR
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_8f_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_8f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_8f_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_8f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_9f_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_9f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_9f_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_9f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_10f_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_10f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_10f_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_10f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_11f_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_11f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_11f_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_11f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_12f_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_12f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_12f_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_12f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_13f_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_13f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_13f_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_13f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_14f_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_14f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_14f_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_14f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_15f_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_15f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_15f_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_15f_SET
#define READ_CMIC_STAT_DMA_BLKNUM_MAP_15_8r BCM56218_A0_READ_CMIC_STAT_DMA_BLKNUM_MAP_15_8r
#define WRITE_CMIC_STAT_DMA_BLKNUM_MAP_15_8r BCM56218_A0_WRITE_CMIC_STAT_DMA_BLKNUM_MAP_15_8r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_STAT_DMA_BLKNUM_MAP_23_16
 * BLOCKS:   CMIC
 * DESC:     Stats DMA port <-> block-number map, ports 23 to 16

 * SIZE:     32
 * FIELDS:
 *     SBUS_BLKNUM_16   S-bus block number for port 16
 *     SBUS_BLKNUM_17   S-bus block number for port 17
 *     SBUS_BLKNUM_18   S-bus block number for port 18
 *     SBUS_BLKNUM_19   S-bus block number for port 19
 *     SBUS_BLKNUM_20   S-bus block number for port 20
 *     SBUS_BLKNUM_21   S-bus block number for port 21
 *     SBUS_BLKNUM_22   S-bus block number for port 22
 *     SBUS_BLKNUM_23   S-bus block number for port 23
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r 0x00000488

#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_BLKNUM_MAP_23_16.
 *
 */
typedef union BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_blknum_map_23_16[1];
	uint32_t _cmic_stat_dma_blknum_map_23_16;
} BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_t;

#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_CLR(r) (r).cmic_stat_dma_blknum_map_23_16[0] = 0
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SET(r,d) (r).cmic_stat_dma_blknum_map_23_16[0] = d
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_GET(r) (r).cmic_stat_dma_blknum_map_23_16[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_16f_GET(r) (((r).cmic_stat_dma_blknum_map_23_16[0]) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_16f_SET(r,f) (r).cmic_stat_dma_blknum_map_23_16[0]=(((r).cmic_stat_dma_blknum_map_23_16[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_17f_GET(r) ((((r).cmic_stat_dma_blknum_map_23_16[0]) >> 4) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_17f_SET(r,f) (r).cmic_stat_dma_blknum_map_23_16[0]=(((r).cmic_stat_dma_blknum_map_23_16[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_18f_GET(r) ((((r).cmic_stat_dma_blknum_map_23_16[0]) >> 8) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_18f_SET(r,f) (r).cmic_stat_dma_blknum_map_23_16[0]=(((r).cmic_stat_dma_blknum_map_23_16[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_19f_GET(r) ((((r).cmic_stat_dma_blknum_map_23_16[0]) >> 12) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_19f_SET(r,f) (r).cmic_stat_dma_blknum_map_23_16[0]=(((r).cmic_stat_dma_blknum_map_23_16[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_20f_GET(r) ((((r).cmic_stat_dma_blknum_map_23_16[0]) >> 16) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_20f_SET(r,f) (r).cmic_stat_dma_blknum_map_23_16[0]=(((r).cmic_stat_dma_blknum_map_23_16[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_21f_GET(r) ((((r).cmic_stat_dma_blknum_map_23_16[0]) >> 20) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_21f_SET(r,f) (r).cmic_stat_dma_blknum_map_23_16[0]=(((r).cmic_stat_dma_blknum_map_23_16[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_22f_GET(r) ((((r).cmic_stat_dma_blknum_map_23_16[0]) >> 24) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_22f_SET(r,f) (r).cmic_stat_dma_blknum_map_23_16[0]=(((r).cmic_stat_dma_blknum_map_23_16[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_23f_GET(r) ((((r).cmic_stat_dma_blknum_map_23_16[0]) >> 28) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_23f_SET(r,f) (r).cmic_stat_dma_blknum_map_23_16[0]=(((r).cmic_stat_dma_blknum_map_23_16[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access CMIC_STAT_DMA_BLKNUM_MAP_23_16.
 *
 */
#define BCM56218_A0_READ_CMIC_STAT_DMA_BLKNUM_MAP_23_16r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r,r._cmic_stat_dma_blknum_map_23_16)
#define BCM56218_A0_WRITE_CMIC_STAT_DMA_BLKNUM_MAP_23_16r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r,r._cmic_stat_dma_blknum_map_23_16)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SIZE BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SIZE
typedef BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_t CMIC_STAT_DMA_BLKNUM_MAP_23_16r_t;
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_CLR BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_CLR
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_16f_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_16f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_16f_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_16f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_17f_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_17f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_17f_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_17f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_18f_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_18f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_18f_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_18f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_19f_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_19f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_19f_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_19f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_20f_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_20f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_20f_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_20f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_21f_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_21f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_21f_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_21f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_22f_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_22f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_22f_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_22f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_23f_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_23f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_23f_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_23f_SET
#define READ_CMIC_STAT_DMA_BLKNUM_MAP_23_16r BCM56218_A0_READ_CMIC_STAT_DMA_BLKNUM_MAP_23_16r
#define WRITE_CMIC_STAT_DMA_BLKNUM_MAP_23_16r BCM56218_A0_WRITE_CMIC_STAT_DMA_BLKNUM_MAP_23_16r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_STAT_DMA_BLKNUM_MAP_31_24
 * BLOCKS:   CMIC
 * DESC:     Stats DMA port <-> block-number map, ports 31 to 24

 * SIZE:     32
 * FIELDS:
 *     SBUS_BLKNUM_24   S-bus block number for port 24
 *     SBUS_BLKNUM_25   S-bus block number for port 25
 *     SBUS_BLKNUM_26   S-bus block number for port 26
 *     SBUS_BLKNUM_27   S-bus block number for port 27
 *     SBUS_BLKNUM_28   S-bus block number for port 28
 *     SBUS_BLKNUM_29   S-bus block number for port 29
 *     SBUS_BLKNUM_30   S-bus block number for port 30
 *     SBUS_BLKNUM_31   S-bus block number for port 31
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r 0x0000048c

#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_BLKNUM_MAP_31_24.
 *
 */
typedef union BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_blknum_map_31_24[1];
	uint32_t _cmic_stat_dma_blknum_map_31_24;
} BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_t;

#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_CLR(r) (r).cmic_stat_dma_blknum_map_31_24[0] = 0
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SET(r,d) (r).cmic_stat_dma_blknum_map_31_24[0] = d
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_GET(r) (r).cmic_stat_dma_blknum_map_31_24[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_24f_GET(r) (((r).cmic_stat_dma_blknum_map_31_24[0]) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_24f_SET(r,f) (r).cmic_stat_dma_blknum_map_31_24[0]=(((r).cmic_stat_dma_blknum_map_31_24[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_25f_GET(r) ((((r).cmic_stat_dma_blknum_map_31_24[0]) >> 4) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_25f_SET(r,f) (r).cmic_stat_dma_blknum_map_31_24[0]=(((r).cmic_stat_dma_blknum_map_31_24[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_26f_GET(r) ((((r).cmic_stat_dma_blknum_map_31_24[0]) >> 8) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_26f_SET(r,f) (r).cmic_stat_dma_blknum_map_31_24[0]=(((r).cmic_stat_dma_blknum_map_31_24[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_27f_GET(r) ((((r).cmic_stat_dma_blknum_map_31_24[0]) >> 12) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_27f_SET(r,f) (r).cmic_stat_dma_blknum_map_31_24[0]=(((r).cmic_stat_dma_blknum_map_31_24[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_28f_GET(r) ((((r).cmic_stat_dma_blknum_map_31_24[0]) >> 16) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_28f_SET(r,f) (r).cmic_stat_dma_blknum_map_31_24[0]=(((r).cmic_stat_dma_blknum_map_31_24[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_29f_GET(r) ((((r).cmic_stat_dma_blknum_map_31_24[0]) >> 20) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_29f_SET(r,f) (r).cmic_stat_dma_blknum_map_31_24[0]=(((r).cmic_stat_dma_blknum_map_31_24[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_30f_GET(r) ((((r).cmic_stat_dma_blknum_map_31_24[0]) >> 24) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_30f_SET(r,f) (r).cmic_stat_dma_blknum_map_31_24[0]=(((r).cmic_stat_dma_blknum_map_31_24[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_31f_GET(r) ((((r).cmic_stat_dma_blknum_map_31_24[0]) >> 28) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_31f_SET(r,f) (r).cmic_stat_dma_blknum_map_31_24[0]=(((r).cmic_stat_dma_blknum_map_31_24[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access CMIC_STAT_DMA_BLKNUM_MAP_31_24.
 *
 */
#define BCM56218_A0_READ_CMIC_STAT_DMA_BLKNUM_MAP_31_24r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r,r._cmic_stat_dma_blknum_map_31_24)
#define BCM56218_A0_WRITE_CMIC_STAT_DMA_BLKNUM_MAP_31_24r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r,r._cmic_stat_dma_blknum_map_31_24)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SIZE BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SIZE
typedef BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_t CMIC_STAT_DMA_BLKNUM_MAP_31_24r_t;
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_CLR BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_CLR
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_24f_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_24f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_24f_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_24f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_25f_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_25f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_25f_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_25f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_26f_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_26f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_26f_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_26f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_27f_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_27f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_27f_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_27f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_28f_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_28f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_28f_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_28f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_29f_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_29f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_29f_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_29f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_30f_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_30f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_30f_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_30f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_31f_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_31f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_31f_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_31f_SET
#define READ_CMIC_STAT_DMA_BLKNUM_MAP_31_24r BCM56218_A0_READ_CMIC_STAT_DMA_BLKNUM_MAP_31_24r
#define WRITE_CMIC_STAT_DMA_BLKNUM_MAP_31_24r BCM56218_A0_WRITE_CMIC_STAT_DMA_BLKNUM_MAP_31_24r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_STAT_DMA_BLKNUM_MAP_39_32
 * BLOCKS:   CMIC
 * DESC:     Stats DMA port <-> block-number map, ports 39 to 32

 * SIZE:     32
 * FIELDS:
 *     SBUS_BLKNUM_32   S-bus block number for port 32
 *     SBUS_BLKNUM_33   S-bus block number for port 33
 *     SBUS_BLKNUM_34   S-bus block number for port 34
 *     SBUS_BLKNUM_35   S-bus block number for port 35
 *     SBUS_BLKNUM_36   S-bus block number for port 36
 *     SBUS_BLKNUM_37   S-bus block number for port 37
 *     SBUS_BLKNUM_38   S-bus block number for port 38
 *     SBUS_BLKNUM_39   S-bus block number for port 39
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r 0x00000490

#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_BLKNUM_MAP_39_32.
 *
 */
typedef union BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_blknum_map_39_32[1];
	uint32_t _cmic_stat_dma_blknum_map_39_32;
} BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_t;

#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_CLR(r) (r).cmic_stat_dma_blknum_map_39_32[0] = 0
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SET(r,d) (r).cmic_stat_dma_blknum_map_39_32[0] = d
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_GET(r) (r).cmic_stat_dma_blknum_map_39_32[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_32f_GET(r) (((r).cmic_stat_dma_blknum_map_39_32[0]) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_32f_SET(r,f) (r).cmic_stat_dma_blknum_map_39_32[0]=(((r).cmic_stat_dma_blknum_map_39_32[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_33f_GET(r) ((((r).cmic_stat_dma_blknum_map_39_32[0]) >> 4) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_33f_SET(r,f) (r).cmic_stat_dma_blknum_map_39_32[0]=(((r).cmic_stat_dma_blknum_map_39_32[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_34f_GET(r) ((((r).cmic_stat_dma_blknum_map_39_32[0]) >> 8) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_34f_SET(r,f) (r).cmic_stat_dma_blknum_map_39_32[0]=(((r).cmic_stat_dma_blknum_map_39_32[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_35f_GET(r) ((((r).cmic_stat_dma_blknum_map_39_32[0]) >> 12) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_35f_SET(r,f) (r).cmic_stat_dma_blknum_map_39_32[0]=(((r).cmic_stat_dma_blknum_map_39_32[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_36f_GET(r) ((((r).cmic_stat_dma_blknum_map_39_32[0]) >> 16) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_36f_SET(r,f) (r).cmic_stat_dma_blknum_map_39_32[0]=(((r).cmic_stat_dma_blknum_map_39_32[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_37f_GET(r) ((((r).cmic_stat_dma_blknum_map_39_32[0]) >> 20) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_37f_SET(r,f) (r).cmic_stat_dma_blknum_map_39_32[0]=(((r).cmic_stat_dma_blknum_map_39_32[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_38f_GET(r) ((((r).cmic_stat_dma_blknum_map_39_32[0]) >> 24) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_38f_SET(r,f) (r).cmic_stat_dma_blknum_map_39_32[0]=(((r).cmic_stat_dma_blknum_map_39_32[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_39f_GET(r) ((((r).cmic_stat_dma_blknum_map_39_32[0]) >> 28) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_39f_SET(r,f) (r).cmic_stat_dma_blknum_map_39_32[0]=(((r).cmic_stat_dma_blknum_map_39_32[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access CMIC_STAT_DMA_BLKNUM_MAP_39_32.
 *
 */
#define BCM56218_A0_READ_CMIC_STAT_DMA_BLKNUM_MAP_39_32r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r,r._cmic_stat_dma_blknum_map_39_32)
#define BCM56218_A0_WRITE_CMIC_STAT_DMA_BLKNUM_MAP_39_32r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r,r._cmic_stat_dma_blknum_map_39_32)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_BLKNUM_MAP_39_32r BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r
#define CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SIZE BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SIZE
typedef BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_t CMIC_STAT_DMA_BLKNUM_MAP_39_32r_t;
#define CMIC_STAT_DMA_BLKNUM_MAP_39_32r_CLR BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_CLR
#define CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_39_32r_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_32f_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_32f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_32f_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_32f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_33f_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_33f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_33f_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_33f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_34f_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_34f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_34f_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_34f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_35f_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_35f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_35f_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_35f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_36f_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_36f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_36f_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_36f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_37f_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_37f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_37f_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_37f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_38f_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_38f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_38f_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_38f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_39f_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_39f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_39f_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_39f_SET
#define READ_CMIC_STAT_DMA_BLKNUM_MAP_39_32r BCM56218_A0_READ_CMIC_STAT_DMA_BLKNUM_MAP_39_32r
#define WRITE_CMIC_STAT_DMA_BLKNUM_MAP_39_32r BCM56218_A0_WRITE_CMIC_STAT_DMA_BLKNUM_MAP_39_32r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_STAT_DMA_BLKNUM_MAP_47_40
 * BLOCKS:   CMIC
 * DESC:     Stats DMA port <-> block-number map, ports 47 to 40

 * SIZE:     32
 * FIELDS:
 *     SBUS_BLKNUM_40   S-bus block number for port 40
 *     SBUS_BLKNUM_41   S-bus block number for port 41
 *     SBUS_BLKNUM_42   S-bus block number for port 42
 *     SBUS_BLKNUM_43   S-bus block number for port 43
 *     SBUS_BLKNUM_44   S-bus block number for port 44
 *     SBUS_BLKNUM_45   S-bus block number for port 45
 *     SBUS_BLKNUM_46   S-bus block number for port 46
 *     SBUS_BLKNUM_47   S-bus block number for port 47
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r 0x00000494

#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_BLKNUM_MAP_47_40.
 *
 */
typedef union BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_blknum_map_47_40[1];
	uint32_t _cmic_stat_dma_blknum_map_47_40;
} BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_t;

#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_CLR(r) (r).cmic_stat_dma_blknum_map_47_40[0] = 0
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SET(r,d) (r).cmic_stat_dma_blknum_map_47_40[0] = d
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_GET(r) (r).cmic_stat_dma_blknum_map_47_40[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_40f_GET(r) (((r).cmic_stat_dma_blknum_map_47_40[0]) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_40f_SET(r,f) (r).cmic_stat_dma_blknum_map_47_40[0]=(((r).cmic_stat_dma_blknum_map_47_40[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_41f_GET(r) ((((r).cmic_stat_dma_blknum_map_47_40[0]) >> 4) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_41f_SET(r,f) (r).cmic_stat_dma_blknum_map_47_40[0]=(((r).cmic_stat_dma_blknum_map_47_40[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_42f_GET(r) ((((r).cmic_stat_dma_blknum_map_47_40[0]) >> 8) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_42f_SET(r,f) (r).cmic_stat_dma_blknum_map_47_40[0]=(((r).cmic_stat_dma_blknum_map_47_40[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_43f_GET(r) ((((r).cmic_stat_dma_blknum_map_47_40[0]) >> 12) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_43f_SET(r,f) (r).cmic_stat_dma_blknum_map_47_40[0]=(((r).cmic_stat_dma_blknum_map_47_40[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_44f_GET(r) ((((r).cmic_stat_dma_blknum_map_47_40[0]) >> 16) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_44f_SET(r,f) (r).cmic_stat_dma_blknum_map_47_40[0]=(((r).cmic_stat_dma_blknum_map_47_40[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_45f_GET(r) ((((r).cmic_stat_dma_blknum_map_47_40[0]) >> 20) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_45f_SET(r,f) (r).cmic_stat_dma_blknum_map_47_40[0]=(((r).cmic_stat_dma_blknum_map_47_40[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_46f_GET(r) ((((r).cmic_stat_dma_blknum_map_47_40[0]) >> 24) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_46f_SET(r,f) (r).cmic_stat_dma_blknum_map_47_40[0]=(((r).cmic_stat_dma_blknum_map_47_40[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_47f_GET(r) ((((r).cmic_stat_dma_blknum_map_47_40[0]) >> 28) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_47f_SET(r,f) (r).cmic_stat_dma_blknum_map_47_40[0]=(((r).cmic_stat_dma_blknum_map_47_40[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access CMIC_STAT_DMA_BLKNUM_MAP_47_40.
 *
 */
#define BCM56218_A0_READ_CMIC_STAT_DMA_BLKNUM_MAP_47_40r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r,r._cmic_stat_dma_blknum_map_47_40)
#define BCM56218_A0_WRITE_CMIC_STAT_DMA_BLKNUM_MAP_47_40r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r,r._cmic_stat_dma_blknum_map_47_40)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_BLKNUM_MAP_47_40r BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r
#define CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SIZE BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SIZE
typedef BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_t CMIC_STAT_DMA_BLKNUM_MAP_47_40r_t;
#define CMIC_STAT_DMA_BLKNUM_MAP_47_40r_CLR BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_CLR
#define CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_47_40r_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_40f_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_40f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_40f_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_40f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_41f_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_41f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_41f_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_41f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_42f_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_42f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_42f_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_42f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_43f_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_43f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_43f_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_43f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_44f_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_44f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_44f_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_44f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_45f_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_45f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_45f_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_45f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_46f_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_46f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_46f_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_46f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_47f_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_47f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_47f_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_47f_SET
#define READ_CMIC_STAT_DMA_BLKNUM_MAP_47_40r BCM56218_A0_READ_CMIC_STAT_DMA_BLKNUM_MAP_47_40r
#define WRITE_CMIC_STAT_DMA_BLKNUM_MAP_47_40r BCM56218_A0_WRITE_CMIC_STAT_DMA_BLKNUM_MAP_47_40r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_STAT_DMA_BLKNUM_MAP_55_48
 * BLOCKS:   CMIC
 * DESC:     Stats DMA port <-> block-number map, ports 55 to 48

 * SIZE:     32
 * FIELDS:
 *     SBUS_BLKNUM_48   S-bus block number for port 48
 *     SBUS_BLKNUM_49   S-bus block number for port 49
 *     SBUS_BLKNUM_50   S-bus block number for port 50
 *     SBUS_BLKNUM_51   S-bus block number for port 51
 *     SBUS_BLKNUM_52   S-bus block number for port 52
 *     SBUS_BLKNUM_53   S-bus block number for port 53
 *     SBUS_BLKNUM_54   S-bus block number for port 54
 *     SBUS_BLKNUM_55   S-bus block number for port 55
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r 0x00000498

#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_BLKNUM_MAP_55_48.
 *
 */
typedef union BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_blknum_map_55_48[1];
	uint32_t _cmic_stat_dma_blknum_map_55_48;
} BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_t;

#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_CLR(r) (r).cmic_stat_dma_blknum_map_55_48[0] = 0
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SET(r,d) (r).cmic_stat_dma_blknum_map_55_48[0] = d
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_GET(r) (r).cmic_stat_dma_blknum_map_55_48[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_48f_GET(r) (((r).cmic_stat_dma_blknum_map_55_48[0]) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_48f_SET(r,f) (r).cmic_stat_dma_blknum_map_55_48[0]=(((r).cmic_stat_dma_blknum_map_55_48[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_49f_GET(r) ((((r).cmic_stat_dma_blknum_map_55_48[0]) >> 4) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_49f_SET(r,f) (r).cmic_stat_dma_blknum_map_55_48[0]=(((r).cmic_stat_dma_blknum_map_55_48[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_50f_GET(r) ((((r).cmic_stat_dma_blknum_map_55_48[0]) >> 8) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_50f_SET(r,f) (r).cmic_stat_dma_blknum_map_55_48[0]=(((r).cmic_stat_dma_blknum_map_55_48[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_51f_GET(r) ((((r).cmic_stat_dma_blknum_map_55_48[0]) >> 12) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_51f_SET(r,f) (r).cmic_stat_dma_blknum_map_55_48[0]=(((r).cmic_stat_dma_blknum_map_55_48[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_52f_GET(r) ((((r).cmic_stat_dma_blknum_map_55_48[0]) >> 16) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_52f_SET(r,f) (r).cmic_stat_dma_blknum_map_55_48[0]=(((r).cmic_stat_dma_blknum_map_55_48[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_53f_GET(r) ((((r).cmic_stat_dma_blknum_map_55_48[0]) >> 20) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_53f_SET(r,f) (r).cmic_stat_dma_blknum_map_55_48[0]=(((r).cmic_stat_dma_blknum_map_55_48[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_54f_GET(r) ((((r).cmic_stat_dma_blknum_map_55_48[0]) >> 24) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_54f_SET(r,f) (r).cmic_stat_dma_blknum_map_55_48[0]=(((r).cmic_stat_dma_blknum_map_55_48[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_55f_GET(r) ((((r).cmic_stat_dma_blknum_map_55_48[0]) >> 28) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_55f_SET(r,f) (r).cmic_stat_dma_blknum_map_55_48[0]=(((r).cmic_stat_dma_blknum_map_55_48[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access CMIC_STAT_DMA_BLKNUM_MAP_55_48.
 *
 */
#define BCM56218_A0_READ_CMIC_STAT_DMA_BLKNUM_MAP_55_48r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r,r._cmic_stat_dma_blknum_map_55_48)
#define BCM56218_A0_WRITE_CMIC_STAT_DMA_BLKNUM_MAP_55_48r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r,r._cmic_stat_dma_blknum_map_55_48)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_BLKNUM_MAP_55_48r BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r
#define CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SIZE BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SIZE
typedef BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_t CMIC_STAT_DMA_BLKNUM_MAP_55_48r_t;
#define CMIC_STAT_DMA_BLKNUM_MAP_55_48r_CLR BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_CLR
#define CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_55_48r_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_48f_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_48f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_48f_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_48f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_49f_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_49f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_49f_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_49f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_50f_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_50f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_50f_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_50f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_51f_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_51f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_51f_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_51f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_52f_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_52f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_52f_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_52f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_53f_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_53f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_53f_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_53f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_54f_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_54f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_54f_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_54f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_55f_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_55f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_55f_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_55f_SET
#define READ_CMIC_STAT_DMA_BLKNUM_MAP_55_48r BCM56218_A0_READ_CMIC_STAT_DMA_BLKNUM_MAP_55_48r
#define WRITE_CMIC_STAT_DMA_BLKNUM_MAP_55_48r BCM56218_A0_WRITE_CMIC_STAT_DMA_BLKNUM_MAP_55_48r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_STAT_DMA_BLKNUM_MAP_63_56
 * BLOCKS:   CMIC
 * DESC:     Stats DMA port <-> block-number map, ports 63 to 56

 * SIZE:     32
 * FIELDS:
 *     SBUS_BLKNUM_56   S-bus block number for port 56
 *     SBUS_BLKNUM_57   S-bus block number for port 57
 *     SBUS_BLKNUM_58   S-bus block number for port 58
 *     SBUS_BLKNUM_59   S-bus block number for port 59
 *     SBUS_BLKNUM_60   S-bus block number for port 60
 *     SBUS_BLKNUM_61   S-bus block number for port 61
 *     SBUS_BLKNUM_62   S-bus block number for port 62
 *     SBUS_BLKNUM_63   S-bus block number for port 63
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r 0x0000049c

#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_BLKNUM_MAP_63_56.
 *
 */
typedef union BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_blknum_map_63_56[1];
	uint32_t _cmic_stat_dma_blknum_map_63_56;
} BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_t;

#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_CLR(r) (r).cmic_stat_dma_blknum_map_63_56[0] = 0
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SET(r,d) (r).cmic_stat_dma_blknum_map_63_56[0] = d
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_GET(r) (r).cmic_stat_dma_blknum_map_63_56[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_56f_GET(r) (((r).cmic_stat_dma_blknum_map_63_56[0]) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_56f_SET(r,f) (r).cmic_stat_dma_blknum_map_63_56[0]=(((r).cmic_stat_dma_blknum_map_63_56[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_57f_GET(r) ((((r).cmic_stat_dma_blknum_map_63_56[0]) >> 4) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_57f_SET(r,f) (r).cmic_stat_dma_blknum_map_63_56[0]=(((r).cmic_stat_dma_blknum_map_63_56[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_58f_GET(r) ((((r).cmic_stat_dma_blknum_map_63_56[0]) >> 8) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_58f_SET(r,f) (r).cmic_stat_dma_blknum_map_63_56[0]=(((r).cmic_stat_dma_blknum_map_63_56[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_59f_GET(r) ((((r).cmic_stat_dma_blknum_map_63_56[0]) >> 12) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_59f_SET(r,f) (r).cmic_stat_dma_blknum_map_63_56[0]=(((r).cmic_stat_dma_blknum_map_63_56[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_60f_GET(r) ((((r).cmic_stat_dma_blknum_map_63_56[0]) >> 16) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_60f_SET(r,f) (r).cmic_stat_dma_blknum_map_63_56[0]=(((r).cmic_stat_dma_blknum_map_63_56[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_61f_GET(r) ((((r).cmic_stat_dma_blknum_map_63_56[0]) >> 20) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_61f_SET(r,f) (r).cmic_stat_dma_blknum_map_63_56[0]=(((r).cmic_stat_dma_blknum_map_63_56[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_62f_GET(r) ((((r).cmic_stat_dma_blknum_map_63_56[0]) >> 24) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_62f_SET(r,f) (r).cmic_stat_dma_blknum_map_63_56[0]=(((r).cmic_stat_dma_blknum_map_63_56[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_63f_GET(r) ((((r).cmic_stat_dma_blknum_map_63_56[0]) >> 28) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_63f_SET(r,f) (r).cmic_stat_dma_blknum_map_63_56[0]=(((r).cmic_stat_dma_blknum_map_63_56[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access CMIC_STAT_DMA_BLKNUM_MAP_63_56.
 *
 */
#define BCM56218_A0_READ_CMIC_STAT_DMA_BLKNUM_MAP_63_56r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r,r._cmic_stat_dma_blknum_map_63_56)
#define BCM56218_A0_WRITE_CMIC_STAT_DMA_BLKNUM_MAP_63_56r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r,r._cmic_stat_dma_blknum_map_63_56)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_BLKNUM_MAP_63_56r BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r
#define CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SIZE BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SIZE
typedef BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_t CMIC_STAT_DMA_BLKNUM_MAP_63_56r_t;
#define CMIC_STAT_DMA_BLKNUM_MAP_63_56r_CLR BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_CLR
#define CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_63_56r_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_56f_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_56f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_56f_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_56f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_57f_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_57f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_57f_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_57f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_58f_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_58f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_58f_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_58f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_59f_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_59f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_59f_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_59f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_60f_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_60f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_60f_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_60f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_61f_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_61f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_61f_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_61f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_62f_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_62f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_62f_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_62f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_63f_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_63f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_63f_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_63f_SET
#define READ_CMIC_STAT_DMA_BLKNUM_MAP_63_56r BCM56218_A0_READ_CMIC_STAT_DMA_BLKNUM_MAP_63_56r
#define WRITE_CMIC_STAT_DMA_BLKNUM_MAP_63_56r BCM56218_A0_WRITE_CMIC_STAT_DMA_BLKNUM_MAP_63_56r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_STAT_DMA_BLKNUM_MAP_7_0
 * BLOCKS:   CMIC
 * DESC:     Stats DMA port <-> block-number map, ports 7 to 0

 * SIZE:     32
 * FIELDS:
 *     SBUS_BLKNUM_0    S-bus block number for port 0
 *     SBUS_BLKNUM_1    S-bus block number for port 1
 *     SBUS_BLKNUM_2    S-bus block number for port 2
 *     SBUS_BLKNUM_3    S-bus block number for port 3
 *     SBUS_BLKNUM_4    S-bus block number for port 4
 *     SBUS_BLKNUM_5    S-bus block number for port 5
 *     SBUS_BLKNUM_6    S-bus block number for port 6
 *     SBUS_BLKNUM_7    S-bus block number for port 7
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r 0x00000480

#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_BLKNUM_MAP_7_0.
 *
 */
typedef union BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_blknum_map_7_0[1];
	uint32_t _cmic_stat_dma_blknum_map_7_0;
} BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_t;

#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_CLR(r) (r).cmic_stat_dma_blknum_map_7_0[0] = 0
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SET(r,d) (r).cmic_stat_dma_blknum_map_7_0[0] = d
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_GET(r) (r).cmic_stat_dma_blknum_map_7_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_0f_GET(r) (((r).cmic_stat_dma_blknum_map_7_0[0]) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_0f_SET(r,f) (r).cmic_stat_dma_blknum_map_7_0[0]=(((r).cmic_stat_dma_blknum_map_7_0[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_1f_GET(r) ((((r).cmic_stat_dma_blknum_map_7_0[0]) >> 4) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_1f_SET(r,f) (r).cmic_stat_dma_blknum_map_7_0[0]=(((r).cmic_stat_dma_blknum_map_7_0[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_2f_GET(r) ((((r).cmic_stat_dma_blknum_map_7_0[0]) >> 8) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_2f_SET(r,f) (r).cmic_stat_dma_blknum_map_7_0[0]=(((r).cmic_stat_dma_blknum_map_7_0[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_3f_GET(r) ((((r).cmic_stat_dma_blknum_map_7_0[0]) >> 12) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_3f_SET(r,f) (r).cmic_stat_dma_blknum_map_7_0[0]=(((r).cmic_stat_dma_blknum_map_7_0[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_4f_GET(r) ((((r).cmic_stat_dma_blknum_map_7_0[0]) >> 16) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_4f_SET(r,f) (r).cmic_stat_dma_blknum_map_7_0[0]=(((r).cmic_stat_dma_blknum_map_7_0[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_5f_GET(r) ((((r).cmic_stat_dma_blknum_map_7_0[0]) >> 20) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_5f_SET(r,f) (r).cmic_stat_dma_blknum_map_7_0[0]=(((r).cmic_stat_dma_blknum_map_7_0[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_6f_GET(r) ((((r).cmic_stat_dma_blknum_map_7_0[0]) >> 24) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_6f_SET(r,f) (r).cmic_stat_dma_blknum_map_7_0[0]=(((r).cmic_stat_dma_blknum_map_7_0[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_7f_GET(r) ((((r).cmic_stat_dma_blknum_map_7_0[0]) >> 28) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_7f_SET(r,f) (r).cmic_stat_dma_blknum_map_7_0[0]=(((r).cmic_stat_dma_blknum_map_7_0[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access CMIC_STAT_DMA_BLKNUM_MAP_7_0.
 *
 */
#define BCM56218_A0_READ_CMIC_STAT_DMA_BLKNUM_MAP_7_0r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r,r._cmic_stat_dma_blknum_map_7_0)
#define BCM56218_A0_WRITE_CMIC_STAT_DMA_BLKNUM_MAP_7_0r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r,r._cmic_stat_dma_blknum_map_7_0)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SIZE BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SIZE
typedef BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_t CMIC_STAT_DMA_BLKNUM_MAP_7_0r_t;
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_CLR BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_CLR
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_0f_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_0f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_0f_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_0f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_1f_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_1f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_1f_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_1f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_2f_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_2f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_2f_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_2f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_3f_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_3f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_3f_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_3f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_4f_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_4f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_4f_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_4f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_5f_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_5f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_5f_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_5f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_6f_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_6f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_6f_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_6f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_7f_GET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_7f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_7f_SET BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_7f_SET
#define READ_CMIC_STAT_DMA_BLKNUM_MAP_7_0r BCM56218_A0_READ_CMIC_STAT_DMA_BLKNUM_MAP_7_0r
#define WRITE_CMIC_STAT_DMA_BLKNUM_MAP_7_0r BCM56218_A0_WRITE_CMIC_STAT_DMA_BLKNUM_MAP_7_0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_STAT_DMA_CURRENT
 * BLOCKS:   CMIC
 * DESC:     Current Stat Counter Value Register
 * SIZE:     32
 * FIELDS:
 *     DATA             Address of Stat counter currently being processed bythe Stats DMA engine
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_STAT_DMA_CURRENTr 0x00000170

#define BCM56218_A0_CMIC_STAT_DMA_CURRENTr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_CURRENT.
 *
 */
typedef union BCM56218_A0_CMIC_STAT_DMA_CURRENTr_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_current[1];
	uint32_t _cmic_stat_dma_current;
} BCM56218_A0_CMIC_STAT_DMA_CURRENTr_t;

#define BCM56218_A0_CMIC_STAT_DMA_CURRENTr_CLR(r) (r).cmic_stat_dma_current[0] = 0
#define BCM56218_A0_CMIC_STAT_DMA_CURRENTr_SET(r,d) (r).cmic_stat_dma_current[0] = d
#define BCM56218_A0_CMIC_STAT_DMA_CURRENTr_GET(r) (r).cmic_stat_dma_current[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_STAT_DMA_CURRENTr_DATAf_GET(r) ((r).cmic_stat_dma_current[0])
#define BCM56218_A0_CMIC_STAT_DMA_CURRENTr_DATAf_SET(r,f) (r).cmic_stat_dma_current[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_STAT_DMA_CURRENT.
 *
 */
#define BCM56218_A0_READ_CMIC_STAT_DMA_CURRENTr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_STAT_DMA_CURRENTr,r._cmic_stat_dma_current)
#define BCM56218_A0_WRITE_CMIC_STAT_DMA_CURRENTr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_STAT_DMA_CURRENTr,r._cmic_stat_dma_current)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_CURRENTr BCM56218_A0_CMIC_STAT_DMA_CURRENTr
#define CMIC_STAT_DMA_CURRENTr_SIZE BCM56218_A0_CMIC_STAT_DMA_CURRENTr_SIZE
typedef BCM56218_A0_CMIC_STAT_DMA_CURRENTr_t CMIC_STAT_DMA_CURRENTr_t;
#define CMIC_STAT_DMA_CURRENTr_CLR BCM56218_A0_CMIC_STAT_DMA_CURRENTr_CLR
#define CMIC_STAT_DMA_CURRENTr_SET BCM56218_A0_CMIC_STAT_DMA_CURRENTr_SET
#define CMIC_STAT_DMA_CURRENTr_GET BCM56218_A0_CMIC_STAT_DMA_CURRENTr_GET
#define CMIC_STAT_DMA_CURRENTr_DATAf_GET BCM56218_A0_CMIC_STAT_DMA_CURRENTr_DATAf_GET
#define CMIC_STAT_DMA_CURRENTr_DATAf_SET BCM56218_A0_CMIC_STAT_DMA_CURRENTr_DATAf_SET
#define READ_CMIC_STAT_DMA_CURRENTr BCM56218_A0_READ_CMIC_STAT_DMA_CURRENTr
#define WRITE_CMIC_STAT_DMA_CURRENTr BCM56218_A0_WRITE_CMIC_STAT_DMA_CURRENTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_STAT_DMA_CURRENTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_STAT_DMA_EGR_STATS_CFG
 * BLOCKS:   CMIC
 * DESC:     Stats DMA Egress stats config register
 * SIZE:     32
 * FIELDS:
 *     EGR_ETH_BLK_NUM  S-bus block number of Egress for stats counters
 *     RESERVED_1       Reserved
 *     EGR_STAT_COUNTERS_NUM Number of Egress Stats counters per port
 *     RESERVED_2       Reserved
 *     EGR_STATS_PIPELINE_STAGE_NUM Egress pipeline stats counter stage number (if any), 
 *     RESERVED_3       Reserved
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_STAT_DMA_EGR_STATS_CFGr 0x00000464

#define BCM56218_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_EGR_STATS_CFG.
 *
 */
typedef union BCM56218_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_egr_stats_cfg[1];
	uint32_t _cmic_stat_dma_egr_stats_cfg;
} BCM56218_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_t;

#define BCM56218_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_CLR(r) (r).cmic_stat_dma_egr_stats_cfg[0] = 0
#define BCM56218_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_SET(r,d) (r).cmic_stat_dma_egr_stats_cfg[0] = d
#define BCM56218_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_GET(r) (r).cmic_stat_dma_egr_stats_cfg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_ETH_BLK_NUMf_GET(r) (((r).cmic_stat_dma_egr_stats_cfg[0]) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_ETH_BLK_NUMf_SET(r,f) (r).cmic_stat_dma_egr_stats_cfg[0]=(((r).cmic_stat_dma_egr_stats_cfg[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56218_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_1f_GET(r) ((((r).cmic_stat_dma_egr_stats_cfg[0]) >> 4) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_1f_SET(r,f) (r).cmic_stat_dma_egr_stats_cfg[0]=(((r).cmic_stat_dma_egr_stats_cfg[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56218_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_STAT_COUNTERS_NUMf_GET(r) ((((r).cmic_stat_dma_egr_stats_cfg[0]) >> 8) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_STAT_COUNTERS_NUMf_SET(r,f) (r).cmic_stat_dma_egr_stats_cfg[0]=(((r).cmic_stat_dma_egr_stats_cfg[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define BCM56218_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_2f_GET(r) ((((r).cmic_stat_dma_egr_stats_cfg[0]) >> 14) & 0x3)
#define BCM56218_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_2f_SET(r,f) (r).cmic_stat_dma_egr_stats_cfg[0]=(((r).cmic_stat_dma_egr_stats_cfg[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCM56218_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_STATS_PIPELINE_STAGE_NUMf_GET(r) ((((r).cmic_stat_dma_egr_stats_cfg[0]) >> 16) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_STATS_PIPELINE_STAGE_NUMf_SET(r,f) (r).cmic_stat_dma_egr_stats_cfg[0]=(((r).cmic_stat_dma_egr_stats_cfg[0] & ~((uint32_t)0x3f << 16)) | ((((uint32_t)f) & 0x3f) << 16))
#define BCM56218_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_3f_GET(r) ((((r).cmic_stat_dma_egr_stats_cfg[0]) >> 22) & 0x3ff)
#define BCM56218_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_3f_SET(r,f) (r).cmic_stat_dma_egr_stats_cfg[0]=(((r).cmic_stat_dma_egr_stats_cfg[0] & ~((uint32_t)0x3ff << 22)) | ((((uint32_t)f) & 0x3ff) << 22))

/*
 * These macros can be used to access CMIC_STAT_DMA_EGR_STATS_CFG.
 *
 */
#define BCM56218_A0_READ_CMIC_STAT_DMA_EGR_STATS_CFGr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_STAT_DMA_EGR_STATS_CFGr,r._cmic_stat_dma_egr_stats_cfg)
#define BCM56218_A0_WRITE_CMIC_STAT_DMA_EGR_STATS_CFGr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_STAT_DMA_EGR_STATS_CFGr,r._cmic_stat_dma_egr_stats_cfg)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_EGR_STATS_CFGr BCM56218_A0_CMIC_STAT_DMA_EGR_STATS_CFGr
#define CMIC_STAT_DMA_EGR_STATS_CFGr_SIZE BCM56218_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_SIZE
typedef BCM56218_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_t CMIC_STAT_DMA_EGR_STATS_CFGr_t;
#define CMIC_STAT_DMA_EGR_STATS_CFGr_CLR BCM56218_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_CLR
#define CMIC_STAT_DMA_EGR_STATS_CFGr_SET BCM56218_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_SET
#define CMIC_STAT_DMA_EGR_STATS_CFGr_GET BCM56218_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_GET
#define CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_ETH_BLK_NUMf_GET BCM56218_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_ETH_BLK_NUMf_GET
#define CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_ETH_BLK_NUMf_SET BCM56218_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_ETH_BLK_NUMf_SET
#define CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_1f_GET BCM56218_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_1f_GET
#define CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_1f_SET BCM56218_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_1f_SET
#define CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_STAT_COUNTERS_NUMf_GET BCM56218_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_STAT_COUNTERS_NUMf_GET
#define CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_STAT_COUNTERS_NUMf_SET BCM56218_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_STAT_COUNTERS_NUMf_SET
#define CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_2f_GET BCM56218_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_2f_GET
#define CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_2f_SET BCM56218_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_2f_SET
#define CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_STATS_PIPELINE_STAGE_NUMf_GET BCM56218_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_STATS_PIPELINE_STAGE_NUMf_GET
#define CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_STATS_PIPELINE_STAGE_NUMf_SET BCM56218_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_STATS_PIPELINE_STAGE_NUMf_SET
#define CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_3f_GET BCM56218_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_3f_GET
#define CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_3f_SET BCM56218_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_3f_SET
#define READ_CMIC_STAT_DMA_EGR_STATS_CFGr BCM56218_A0_READ_CMIC_STAT_DMA_EGR_STATS_CFGr
#define WRITE_CMIC_STAT_DMA_EGR_STATS_CFGr BCM56218_A0_WRITE_CMIC_STAT_DMA_EGR_STATS_CFGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_STAT_DMA_EGR_STATS_CFGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_STAT_DMA_ING_STATS_CFG
 * BLOCKS:   CMIC
 * DESC:     Stats DMA Ingress stats config register
 * SIZE:     32
 * FIELDS:
 *     ING_ETH_BLK_NUM  S-bus block number of Ingress for stats counters
 *     RESERVED_1       Reserved
 *     ING_STAT_COUNTERS_NUM Number of Ingress Stats counters per port
 *     RESERVED_2       Reserved
 *     ING_STATS_PIPELINE_STAGE_NUM Ingress pipeline stats counter stage number (if any), 
 *     RESERVED_3       Reserved
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_STAT_DMA_ING_STATS_CFGr 0x00000460

#define BCM56218_A0_CMIC_STAT_DMA_ING_STATS_CFGr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_ING_STATS_CFG.
 *
 */
typedef union BCM56218_A0_CMIC_STAT_DMA_ING_STATS_CFGr_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_ing_stats_cfg[1];
	uint32_t _cmic_stat_dma_ing_stats_cfg;
} BCM56218_A0_CMIC_STAT_DMA_ING_STATS_CFGr_t;

#define BCM56218_A0_CMIC_STAT_DMA_ING_STATS_CFGr_CLR(r) (r).cmic_stat_dma_ing_stats_cfg[0] = 0
#define BCM56218_A0_CMIC_STAT_DMA_ING_STATS_CFGr_SET(r,d) (r).cmic_stat_dma_ing_stats_cfg[0] = d
#define BCM56218_A0_CMIC_STAT_DMA_ING_STATS_CFGr_GET(r) (r).cmic_stat_dma_ing_stats_cfg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_STAT_DMA_ING_STATS_CFGr_ING_ETH_BLK_NUMf_GET(r) (((r).cmic_stat_dma_ing_stats_cfg[0]) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_ING_STATS_CFGr_ING_ETH_BLK_NUMf_SET(r,f) (r).cmic_stat_dma_ing_stats_cfg[0]=(((r).cmic_stat_dma_ing_stats_cfg[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56218_A0_CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_1f_GET(r) ((((r).cmic_stat_dma_ing_stats_cfg[0]) >> 4) & 0xf)
#define BCM56218_A0_CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_1f_SET(r,f) (r).cmic_stat_dma_ing_stats_cfg[0]=(((r).cmic_stat_dma_ing_stats_cfg[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56218_A0_CMIC_STAT_DMA_ING_STATS_CFGr_ING_STAT_COUNTERS_NUMf_GET(r) ((((r).cmic_stat_dma_ing_stats_cfg[0]) >> 8) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_ING_STATS_CFGr_ING_STAT_COUNTERS_NUMf_SET(r,f) (r).cmic_stat_dma_ing_stats_cfg[0]=(((r).cmic_stat_dma_ing_stats_cfg[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define BCM56218_A0_CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_2f_GET(r) ((((r).cmic_stat_dma_ing_stats_cfg[0]) >> 14) & 0x3)
#define BCM56218_A0_CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_2f_SET(r,f) (r).cmic_stat_dma_ing_stats_cfg[0]=(((r).cmic_stat_dma_ing_stats_cfg[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCM56218_A0_CMIC_STAT_DMA_ING_STATS_CFGr_ING_STATS_PIPELINE_STAGE_NUMf_GET(r) ((((r).cmic_stat_dma_ing_stats_cfg[0]) >> 16) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_ING_STATS_CFGr_ING_STATS_PIPELINE_STAGE_NUMf_SET(r,f) (r).cmic_stat_dma_ing_stats_cfg[0]=(((r).cmic_stat_dma_ing_stats_cfg[0] & ~((uint32_t)0x3f << 16)) | ((((uint32_t)f) & 0x3f) << 16))
#define BCM56218_A0_CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_3f_GET(r) ((((r).cmic_stat_dma_ing_stats_cfg[0]) >> 22) & 0x3ff)
#define BCM56218_A0_CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_3f_SET(r,f) (r).cmic_stat_dma_ing_stats_cfg[0]=(((r).cmic_stat_dma_ing_stats_cfg[0] & ~((uint32_t)0x3ff << 22)) | ((((uint32_t)f) & 0x3ff) << 22))

/*
 * These macros can be used to access CMIC_STAT_DMA_ING_STATS_CFG.
 *
 */
#define BCM56218_A0_READ_CMIC_STAT_DMA_ING_STATS_CFGr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_STAT_DMA_ING_STATS_CFGr,r._cmic_stat_dma_ing_stats_cfg)
#define BCM56218_A0_WRITE_CMIC_STAT_DMA_ING_STATS_CFGr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_STAT_DMA_ING_STATS_CFGr,r._cmic_stat_dma_ing_stats_cfg)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_ING_STATS_CFGr BCM56218_A0_CMIC_STAT_DMA_ING_STATS_CFGr
#define CMIC_STAT_DMA_ING_STATS_CFGr_SIZE BCM56218_A0_CMIC_STAT_DMA_ING_STATS_CFGr_SIZE
typedef BCM56218_A0_CMIC_STAT_DMA_ING_STATS_CFGr_t CMIC_STAT_DMA_ING_STATS_CFGr_t;
#define CMIC_STAT_DMA_ING_STATS_CFGr_CLR BCM56218_A0_CMIC_STAT_DMA_ING_STATS_CFGr_CLR
#define CMIC_STAT_DMA_ING_STATS_CFGr_SET BCM56218_A0_CMIC_STAT_DMA_ING_STATS_CFGr_SET
#define CMIC_STAT_DMA_ING_STATS_CFGr_GET BCM56218_A0_CMIC_STAT_DMA_ING_STATS_CFGr_GET
#define CMIC_STAT_DMA_ING_STATS_CFGr_ING_ETH_BLK_NUMf_GET BCM56218_A0_CMIC_STAT_DMA_ING_STATS_CFGr_ING_ETH_BLK_NUMf_GET
#define CMIC_STAT_DMA_ING_STATS_CFGr_ING_ETH_BLK_NUMf_SET BCM56218_A0_CMIC_STAT_DMA_ING_STATS_CFGr_ING_ETH_BLK_NUMf_SET
#define CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_1f_GET BCM56218_A0_CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_1f_GET
#define CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_1f_SET BCM56218_A0_CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_1f_SET
#define CMIC_STAT_DMA_ING_STATS_CFGr_ING_STAT_COUNTERS_NUMf_GET BCM56218_A0_CMIC_STAT_DMA_ING_STATS_CFGr_ING_STAT_COUNTERS_NUMf_GET
#define CMIC_STAT_DMA_ING_STATS_CFGr_ING_STAT_COUNTERS_NUMf_SET BCM56218_A0_CMIC_STAT_DMA_ING_STATS_CFGr_ING_STAT_COUNTERS_NUMf_SET
#define CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_2f_GET BCM56218_A0_CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_2f_GET
#define CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_2f_SET BCM56218_A0_CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_2f_SET
#define CMIC_STAT_DMA_ING_STATS_CFGr_ING_STATS_PIPELINE_STAGE_NUMf_GET BCM56218_A0_CMIC_STAT_DMA_ING_STATS_CFGr_ING_STATS_PIPELINE_STAGE_NUMf_GET
#define CMIC_STAT_DMA_ING_STATS_CFGr_ING_STATS_PIPELINE_STAGE_NUMf_SET BCM56218_A0_CMIC_STAT_DMA_ING_STATS_CFGr_ING_STATS_PIPELINE_STAGE_NUMf_SET
#define CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_3f_GET BCM56218_A0_CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_3f_GET
#define CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_3f_SET BCM56218_A0_CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_3f_SET
#define READ_CMIC_STAT_DMA_ING_STATS_CFGr BCM56218_A0_READ_CMIC_STAT_DMA_ING_STATS_CFGr
#define WRITE_CMIC_STAT_DMA_ING_STATS_CFGr BCM56218_A0_WRITE_CMIC_STAT_DMA_ING_STATS_CFGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_STAT_DMA_ING_STATS_CFGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_STAT_DMA_MAC_STATS_CFG
 * BLOCKS:   CMIC
 * DESC:     Stats DMA MAC stats config register
 * SIZE:     32
 * FIELDS:
 *     MAC_G_STAT_COUNTERS_NUM Number of MAC GPORT Stats counters per port
 *     MAC_X_STAT_COUNTERS_NUM Number of MAC XPORT Stats counters per port
 *     MAC_STATS_PIPELINE_STAGE_NUM MAC stats counter stage number (if any), 
 *     CPU_STATS_PORT_NUM CPU Port number (for Stats DMA purposes), 
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_STAT_DMA_MAC_STATS_CFGr 0x00000468

#define BCM56218_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_MAC_STATS_CFG.
 *
 */
typedef union BCM56218_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_mac_stats_cfg[1];
	uint32_t _cmic_stat_dma_mac_stats_cfg;
} BCM56218_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_t;

#define BCM56218_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_CLR(r) (r).cmic_stat_dma_mac_stats_cfg[0] = 0
#define BCM56218_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_SET(r,d) (r).cmic_stat_dma_mac_stats_cfg[0] = d
#define BCM56218_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_GET(r) (r).cmic_stat_dma_mac_stats_cfg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_G_STAT_COUNTERS_NUMf_GET(r) (((r).cmic_stat_dma_mac_stats_cfg[0]) & 0xff)
#define BCM56218_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_G_STAT_COUNTERS_NUMf_SET(r,f) (r).cmic_stat_dma_mac_stats_cfg[0]=(((r).cmic_stat_dma_mac_stats_cfg[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56218_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_X_STAT_COUNTERS_NUMf_GET(r) ((((r).cmic_stat_dma_mac_stats_cfg[0]) >> 8) & 0xff)
#define BCM56218_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_X_STAT_COUNTERS_NUMf_SET(r,f) (r).cmic_stat_dma_mac_stats_cfg[0]=(((r).cmic_stat_dma_mac_stats_cfg[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCM56218_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_STATS_PIPELINE_STAGE_NUMf_GET(r) ((((r).cmic_stat_dma_mac_stats_cfg[0]) >> 16) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_STATS_PIPELINE_STAGE_NUMf_SET(r,f) (r).cmic_stat_dma_mac_stats_cfg[0]=(((r).cmic_stat_dma_mac_stats_cfg[0] & ~((uint32_t)0x3f << 16)) | ((((uint32_t)f) & 0x3f) << 16))
#define BCM56218_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_CPU_STATS_PORT_NUMf_GET(r) ((((r).cmic_stat_dma_mac_stats_cfg[0]) >> 24) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_CPU_STATS_PORT_NUMf_SET(r,f) (r).cmic_stat_dma_mac_stats_cfg[0]=(((r).cmic_stat_dma_mac_stats_cfg[0] & ~((uint32_t)0x3f << 24)) | ((((uint32_t)f) & 0x3f) << 24))

/*
 * These macros can be used to access CMIC_STAT_DMA_MAC_STATS_CFG.
 *
 */
#define BCM56218_A0_READ_CMIC_STAT_DMA_MAC_STATS_CFGr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_STAT_DMA_MAC_STATS_CFGr,r._cmic_stat_dma_mac_stats_cfg)
#define BCM56218_A0_WRITE_CMIC_STAT_DMA_MAC_STATS_CFGr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_STAT_DMA_MAC_STATS_CFGr,r._cmic_stat_dma_mac_stats_cfg)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_MAC_STATS_CFGr BCM56218_A0_CMIC_STAT_DMA_MAC_STATS_CFGr
#define CMIC_STAT_DMA_MAC_STATS_CFGr_SIZE BCM56218_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_SIZE
typedef BCM56218_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_t CMIC_STAT_DMA_MAC_STATS_CFGr_t;
#define CMIC_STAT_DMA_MAC_STATS_CFGr_CLR BCM56218_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_CLR
#define CMIC_STAT_DMA_MAC_STATS_CFGr_SET BCM56218_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_SET
#define CMIC_STAT_DMA_MAC_STATS_CFGr_GET BCM56218_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_GET
#define CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_G_STAT_COUNTERS_NUMf_GET BCM56218_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_G_STAT_COUNTERS_NUMf_GET
#define CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_G_STAT_COUNTERS_NUMf_SET BCM56218_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_G_STAT_COUNTERS_NUMf_SET
#define CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_X_STAT_COUNTERS_NUMf_GET BCM56218_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_X_STAT_COUNTERS_NUMf_GET
#define CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_X_STAT_COUNTERS_NUMf_SET BCM56218_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_X_STAT_COUNTERS_NUMf_SET
#define CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_STATS_PIPELINE_STAGE_NUMf_GET BCM56218_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_STATS_PIPELINE_STAGE_NUMf_GET
#define CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_STATS_PIPELINE_STAGE_NUMf_SET BCM56218_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_STATS_PIPELINE_STAGE_NUMf_SET
#define CMIC_STAT_DMA_MAC_STATS_CFGr_CPU_STATS_PORT_NUMf_GET BCM56218_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_CPU_STATS_PORT_NUMf_GET
#define CMIC_STAT_DMA_MAC_STATS_CFGr_CPU_STATS_PORT_NUMf_SET BCM56218_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_CPU_STATS_PORT_NUMf_SET
#define READ_CMIC_STAT_DMA_MAC_STATS_CFGr BCM56218_A0_READ_CMIC_STAT_DMA_MAC_STATS_CFGr
#define WRITE_CMIC_STAT_DMA_MAC_STATS_CFGr BCM56218_A0_WRITE_CMIC_STAT_DMA_MAC_STATS_CFGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_STAT_DMA_MAC_STATS_CFGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_STAT_DMA_PORTNUM_MAP_11_8
 * BLOCKS:   CMIC
 * DESC:     Stats DMA port <-> port-number map, ports 11_8

 * SIZE:     32
 * FIELDS:
 *     SBUS_PORTNUM_8   S-bus port number for port 8
 *     SBUS_PORTNUM_9   S-bus port number for port 9
 *     SBUS_PORTNUM_10  S-bus port number for port 10
 *     SBUS_PORTNUM_11  S-bus port number for port 11
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_8r 0x000005c8

#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_8r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_PORTNUM_MAP_11_8.
 *
 */
typedef union BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_8r_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_portnum_map_11_8[1];
	uint32_t _cmic_stat_dma_portnum_map_11_8;
} BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_8r_t;

#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_8r_CLR(r) (r).cmic_stat_dma_portnum_map_11_8[0] = 0
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_8r_SET(r,d) (r).cmic_stat_dma_portnum_map_11_8[0] = d
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_8r_GET(r) (r).cmic_stat_dma_portnum_map_11_8[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_8r_SBUS_PORTNUM_8f_GET(r) (((r).cmic_stat_dma_portnum_map_11_8[0]) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_8r_SBUS_PORTNUM_8f_SET(r,f) (r).cmic_stat_dma_portnum_map_11_8[0]=(((r).cmic_stat_dma_portnum_map_11_8[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_8r_SBUS_PORTNUM_9f_GET(r) ((((r).cmic_stat_dma_portnum_map_11_8[0]) >> 8) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_8r_SBUS_PORTNUM_9f_SET(r,f) (r).cmic_stat_dma_portnum_map_11_8[0]=(((r).cmic_stat_dma_portnum_map_11_8[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_8r_SBUS_PORTNUM_10f_GET(r) ((((r).cmic_stat_dma_portnum_map_11_8[0]) >> 16) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_8r_SBUS_PORTNUM_10f_SET(r,f) (r).cmic_stat_dma_portnum_map_11_8[0]=(((r).cmic_stat_dma_portnum_map_11_8[0] & ~((uint32_t)0x3f << 16)) | ((((uint32_t)f) & 0x3f) << 16))
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_8r_SBUS_PORTNUM_11f_GET(r) ((((r).cmic_stat_dma_portnum_map_11_8[0]) >> 24) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_8r_SBUS_PORTNUM_11f_SET(r,f) (r).cmic_stat_dma_portnum_map_11_8[0]=(((r).cmic_stat_dma_portnum_map_11_8[0] & ~((uint32_t)0x3f << 24)) | ((((uint32_t)f) & 0x3f) << 24))

/*
 * These macros can be used to access CMIC_STAT_DMA_PORTNUM_MAP_11_8.
 *
 */
#define BCM56218_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_11_8r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_8r,r._cmic_stat_dma_portnum_map_11_8)
#define BCM56218_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_11_8r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_8r,r._cmic_stat_dma_portnum_map_11_8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_PORTNUM_MAP_11_8r BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_8r
#define CMIC_STAT_DMA_PORTNUM_MAP_11_8r_SIZE BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_8r_SIZE
typedef BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_8r_t CMIC_STAT_DMA_PORTNUM_MAP_11_8r_t;
#define CMIC_STAT_DMA_PORTNUM_MAP_11_8r_CLR BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_8r_CLR
#define CMIC_STAT_DMA_PORTNUM_MAP_11_8r_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_8r_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_11_8r_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_8r_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_11_8r_SBUS_PORTNUM_8f_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_8r_SBUS_PORTNUM_8f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_11_8r_SBUS_PORTNUM_8f_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_8r_SBUS_PORTNUM_8f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_11_8r_SBUS_PORTNUM_9f_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_8r_SBUS_PORTNUM_9f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_11_8r_SBUS_PORTNUM_9f_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_8r_SBUS_PORTNUM_9f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_11_8r_SBUS_PORTNUM_10f_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_8r_SBUS_PORTNUM_10f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_11_8r_SBUS_PORTNUM_10f_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_8r_SBUS_PORTNUM_10f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_11_8r_SBUS_PORTNUM_11f_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_8r_SBUS_PORTNUM_11f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_11_8r_SBUS_PORTNUM_11f_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_8r_SBUS_PORTNUM_11f_SET
#define READ_CMIC_STAT_DMA_PORTNUM_MAP_11_8r BCM56218_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_11_8r
#define WRITE_CMIC_STAT_DMA_PORTNUM_MAP_11_8r BCM56218_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_11_8r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_STAT_DMA_PORTNUM_MAP_15_12
 * BLOCKS:   CMIC
 * DESC:     Stats DMA port <-> port-number map, ports 15_12

 * SIZE:     32
 * FIELDS:
 *     SBUS_PORTNUM_12  S-bus port number for port 12
 *     SBUS_PORTNUM_13  S-bus port number for port 13
 *     SBUS_PORTNUM_14  S-bus port number for port 14
 *     SBUS_PORTNUM_15  S-bus port number for port 15
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_12r 0x000005cc

#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_12r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_PORTNUM_MAP_15_12.
 *
 */
typedef union BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_12r_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_portnum_map_15_12[1];
	uint32_t _cmic_stat_dma_portnum_map_15_12;
} BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_12r_t;

#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_12r_CLR(r) (r).cmic_stat_dma_portnum_map_15_12[0] = 0
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_12r_SET(r,d) (r).cmic_stat_dma_portnum_map_15_12[0] = d
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_12r_GET(r) (r).cmic_stat_dma_portnum_map_15_12[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_12r_SBUS_PORTNUM_12f_GET(r) (((r).cmic_stat_dma_portnum_map_15_12[0]) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_12r_SBUS_PORTNUM_12f_SET(r,f) (r).cmic_stat_dma_portnum_map_15_12[0]=(((r).cmic_stat_dma_portnum_map_15_12[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_12r_SBUS_PORTNUM_13f_GET(r) ((((r).cmic_stat_dma_portnum_map_15_12[0]) >> 8) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_12r_SBUS_PORTNUM_13f_SET(r,f) (r).cmic_stat_dma_portnum_map_15_12[0]=(((r).cmic_stat_dma_portnum_map_15_12[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_12r_SBUS_PORTNUM_14f_GET(r) ((((r).cmic_stat_dma_portnum_map_15_12[0]) >> 16) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_12r_SBUS_PORTNUM_14f_SET(r,f) (r).cmic_stat_dma_portnum_map_15_12[0]=(((r).cmic_stat_dma_portnum_map_15_12[0] & ~((uint32_t)0x3f << 16)) | ((((uint32_t)f) & 0x3f) << 16))
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_12r_SBUS_PORTNUM_15f_GET(r) ((((r).cmic_stat_dma_portnum_map_15_12[0]) >> 24) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_12r_SBUS_PORTNUM_15f_SET(r,f) (r).cmic_stat_dma_portnum_map_15_12[0]=(((r).cmic_stat_dma_portnum_map_15_12[0] & ~((uint32_t)0x3f << 24)) | ((((uint32_t)f) & 0x3f) << 24))

/*
 * These macros can be used to access CMIC_STAT_DMA_PORTNUM_MAP_15_12.
 *
 */
#define BCM56218_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_15_12r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_12r,r._cmic_stat_dma_portnum_map_15_12)
#define BCM56218_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_15_12r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_12r,r._cmic_stat_dma_portnum_map_15_12)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_PORTNUM_MAP_15_12r BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_12r
#define CMIC_STAT_DMA_PORTNUM_MAP_15_12r_SIZE BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_12r_SIZE
typedef BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_12r_t CMIC_STAT_DMA_PORTNUM_MAP_15_12r_t;
#define CMIC_STAT_DMA_PORTNUM_MAP_15_12r_CLR BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_12r_CLR
#define CMIC_STAT_DMA_PORTNUM_MAP_15_12r_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_12r_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_15_12r_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_12r_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_15_12r_SBUS_PORTNUM_12f_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_12r_SBUS_PORTNUM_12f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_15_12r_SBUS_PORTNUM_12f_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_12r_SBUS_PORTNUM_12f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_15_12r_SBUS_PORTNUM_13f_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_12r_SBUS_PORTNUM_13f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_15_12r_SBUS_PORTNUM_13f_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_12r_SBUS_PORTNUM_13f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_15_12r_SBUS_PORTNUM_14f_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_12r_SBUS_PORTNUM_14f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_15_12r_SBUS_PORTNUM_14f_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_12r_SBUS_PORTNUM_14f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_15_12r_SBUS_PORTNUM_15f_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_12r_SBUS_PORTNUM_15f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_15_12r_SBUS_PORTNUM_15f_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_12r_SBUS_PORTNUM_15f_SET
#define READ_CMIC_STAT_DMA_PORTNUM_MAP_15_12r BCM56218_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_15_12r
#define WRITE_CMIC_STAT_DMA_PORTNUM_MAP_15_12r BCM56218_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_15_12r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_12r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_STAT_DMA_PORTNUM_MAP_19_16
 * BLOCKS:   CMIC
 * DESC:     Stats DMA port <-> port-number map, ports 19_16

 * SIZE:     32
 * FIELDS:
 *     SBUS_PORTNUM_16  S-bus port number for port 16
 *     SBUS_PORTNUM_17  S-bus port number for port 17
 *     SBUS_PORTNUM_18  S-bus port number for port 18
 *     SBUS_PORTNUM_19  S-bus port number for port 19
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_19_16r 0x000005d0

#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_19_16r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_PORTNUM_MAP_19_16.
 *
 */
typedef union BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_19_16r_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_portnum_map_19_16[1];
	uint32_t _cmic_stat_dma_portnum_map_19_16;
} BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_19_16r_t;

#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_19_16r_CLR(r) (r).cmic_stat_dma_portnum_map_19_16[0] = 0
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_19_16r_SET(r,d) (r).cmic_stat_dma_portnum_map_19_16[0] = d
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_19_16r_GET(r) (r).cmic_stat_dma_portnum_map_19_16[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_19_16r_SBUS_PORTNUM_16f_GET(r) (((r).cmic_stat_dma_portnum_map_19_16[0]) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_19_16r_SBUS_PORTNUM_16f_SET(r,f) (r).cmic_stat_dma_portnum_map_19_16[0]=(((r).cmic_stat_dma_portnum_map_19_16[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_19_16r_SBUS_PORTNUM_17f_GET(r) ((((r).cmic_stat_dma_portnum_map_19_16[0]) >> 8) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_19_16r_SBUS_PORTNUM_17f_SET(r,f) (r).cmic_stat_dma_portnum_map_19_16[0]=(((r).cmic_stat_dma_portnum_map_19_16[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_19_16r_SBUS_PORTNUM_18f_GET(r) ((((r).cmic_stat_dma_portnum_map_19_16[0]) >> 16) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_19_16r_SBUS_PORTNUM_18f_SET(r,f) (r).cmic_stat_dma_portnum_map_19_16[0]=(((r).cmic_stat_dma_portnum_map_19_16[0] & ~((uint32_t)0x3f << 16)) | ((((uint32_t)f) & 0x3f) << 16))
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_19_16r_SBUS_PORTNUM_19f_GET(r) ((((r).cmic_stat_dma_portnum_map_19_16[0]) >> 24) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_19_16r_SBUS_PORTNUM_19f_SET(r,f) (r).cmic_stat_dma_portnum_map_19_16[0]=(((r).cmic_stat_dma_portnum_map_19_16[0] & ~((uint32_t)0x3f << 24)) | ((((uint32_t)f) & 0x3f) << 24))

/*
 * These macros can be used to access CMIC_STAT_DMA_PORTNUM_MAP_19_16.
 *
 */
#define BCM56218_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_19_16r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_19_16r,r._cmic_stat_dma_portnum_map_19_16)
#define BCM56218_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_19_16r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_19_16r,r._cmic_stat_dma_portnum_map_19_16)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_PORTNUM_MAP_19_16r BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_19_16r
#define CMIC_STAT_DMA_PORTNUM_MAP_19_16r_SIZE BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_19_16r_SIZE
typedef BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_19_16r_t CMIC_STAT_DMA_PORTNUM_MAP_19_16r_t;
#define CMIC_STAT_DMA_PORTNUM_MAP_19_16r_CLR BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_19_16r_CLR
#define CMIC_STAT_DMA_PORTNUM_MAP_19_16r_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_19_16r_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_19_16r_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_19_16r_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_19_16r_SBUS_PORTNUM_16f_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_19_16r_SBUS_PORTNUM_16f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_19_16r_SBUS_PORTNUM_16f_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_19_16r_SBUS_PORTNUM_16f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_19_16r_SBUS_PORTNUM_17f_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_19_16r_SBUS_PORTNUM_17f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_19_16r_SBUS_PORTNUM_17f_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_19_16r_SBUS_PORTNUM_17f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_19_16r_SBUS_PORTNUM_18f_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_19_16r_SBUS_PORTNUM_18f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_19_16r_SBUS_PORTNUM_18f_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_19_16r_SBUS_PORTNUM_18f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_19_16r_SBUS_PORTNUM_19f_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_19_16r_SBUS_PORTNUM_19f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_19_16r_SBUS_PORTNUM_19f_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_19_16r_SBUS_PORTNUM_19f_SET
#define READ_CMIC_STAT_DMA_PORTNUM_MAP_19_16r BCM56218_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_19_16r
#define WRITE_CMIC_STAT_DMA_PORTNUM_MAP_19_16r BCM56218_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_19_16r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_19_16r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_STAT_DMA_PORTNUM_MAP_23_20
 * BLOCKS:   CMIC
 * DESC:     Stats DMA port <-> port-number map, ports 23_20

 * SIZE:     32
 * FIELDS:
 *     SBUS_PORTNUM_20  S-bus port number for port 20
 *     SBUS_PORTNUM_21  S-bus port number for port 21
 *     SBUS_PORTNUM_22  S-bus port number for port 22
 *     SBUS_PORTNUM_23  S-bus port number for port 23
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_20r 0x000005d4

#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_20r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_PORTNUM_MAP_23_20.
 *
 */
typedef union BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_20r_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_portnum_map_23_20[1];
	uint32_t _cmic_stat_dma_portnum_map_23_20;
} BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_20r_t;

#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_20r_CLR(r) (r).cmic_stat_dma_portnum_map_23_20[0] = 0
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_20r_SET(r,d) (r).cmic_stat_dma_portnum_map_23_20[0] = d
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_20r_GET(r) (r).cmic_stat_dma_portnum_map_23_20[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_20r_SBUS_PORTNUM_20f_GET(r) (((r).cmic_stat_dma_portnum_map_23_20[0]) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_20r_SBUS_PORTNUM_20f_SET(r,f) (r).cmic_stat_dma_portnum_map_23_20[0]=(((r).cmic_stat_dma_portnum_map_23_20[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_20r_SBUS_PORTNUM_21f_GET(r) ((((r).cmic_stat_dma_portnum_map_23_20[0]) >> 8) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_20r_SBUS_PORTNUM_21f_SET(r,f) (r).cmic_stat_dma_portnum_map_23_20[0]=(((r).cmic_stat_dma_portnum_map_23_20[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_20r_SBUS_PORTNUM_22f_GET(r) ((((r).cmic_stat_dma_portnum_map_23_20[0]) >> 16) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_20r_SBUS_PORTNUM_22f_SET(r,f) (r).cmic_stat_dma_portnum_map_23_20[0]=(((r).cmic_stat_dma_portnum_map_23_20[0] & ~((uint32_t)0x3f << 16)) | ((((uint32_t)f) & 0x3f) << 16))
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_20r_SBUS_PORTNUM_23f_GET(r) ((((r).cmic_stat_dma_portnum_map_23_20[0]) >> 24) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_20r_SBUS_PORTNUM_23f_SET(r,f) (r).cmic_stat_dma_portnum_map_23_20[0]=(((r).cmic_stat_dma_portnum_map_23_20[0] & ~((uint32_t)0x3f << 24)) | ((((uint32_t)f) & 0x3f) << 24))

/*
 * These macros can be used to access CMIC_STAT_DMA_PORTNUM_MAP_23_20.
 *
 */
#define BCM56218_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_23_20r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_20r,r._cmic_stat_dma_portnum_map_23_20)
#define BCM56218_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_23_20r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_20r,r._cmic_stat_dma_portnum_map_23_20)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_PORTNUM_MAP_23_20r BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_20r
#define CMIC_STAT_DMA_PORTNUM_MAP_23_20r_SIZE BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_20r_SIZE
typedef BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_20r_t CMIC_STAT_DMA_PORTNUM_MAP_23_20r_t;
#define CMIC_STAT_DMA_PORTNUM_MAP_23_20r_CLR BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_20r_CLR
#define CMIC_STAT_DMA_PORTNUM_MAP_23_20r_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_20r_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_23_20r_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_20r_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_23_20r_SBUS_PORTNUM_20f_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_20r_SBUS_PORTNUM_20f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_23_20r_SBUS_PORTNUM_20f_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_20r_SBUS_PORTNUM_20f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_23_20r_SBUS_PORTNUM_21f_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_20r_SBUS_PORTNUM_21f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_23_20r_SBUS_PORTNUM_21f_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_20r_SBUS_PORTNUM_21f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_23_20r_SBUS_PORTNUM_22f_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_20r_SBUS_PORTNUM_22f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_23_20r_SBUS_PORTNUM_22f_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_20r_SBUS_PORTNUM_22f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_23_20r_SBUS_PORTNUM_23f_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_20r_SBUS_PORTNUM_23f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_23_20r_SBUS_PORTNUM_23f_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_20r_SBUS_PORTNUM_23f_SET
#define READ_CMIC_STAT_DMA_PORTNUM_MAP_23_20r BCM56218_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_23_20r
#define WRITE_CMIC_STAT_DMA_PORTNUM_MAP_23_20r BCM56218_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_23_20r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_20r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_STAT_DMA_PORTNUM_MAP_27_24
 * BLOCKS:   CMIC
 * DESC:     Stats DMA port <-> port-number map, ports 27_24

 * SIZE:     32
 * FIELDS:
 *     SBUS_PORTNUM_24  S-bus port number for port 24
 *     SBUS_PORTNUM_25  S-bus port number for port 25
 *     SBUS_PORTNUM_26  S-bus port number for port 26
 *     SBUS_PORTNUM_27  S-bus port number for port 27
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_27_24r 0x000005d8

#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_27_24r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_PORTNUM_MAP_27_24.
 *
 */
typedef union BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_27_24r_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_portnum_map_27_24[1];
	uint32_t _cmic_stat_dma_portnum_map_27_24;
} BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_27_24r_t;

#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_27_24r_CLR(r) (r).cmic_stat_dma_portnum_map_27_24[0] = 0
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_27_24r_SET(r,d) (r).cmic_stat_dma_portnum_map_27_24[0] = d
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_27_24r_GET(r) (r).cmic_stat_dma_portnum_map_27_24[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_27_24r_SBUS_PORTNUM_24f_GET(r) (((r).cmic_stat_dma_portnum_map_27_24[0]) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_27_24r_SBUS_PORTNUM_24f_SET(r,f) (r).cmic_stat_dma_portnum_map_27_24[0]=(((r).cmic_stat_dma_portnum_map_27_24[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_27_24r_SBUS_PORTNUM_25f_GET(r) ((((r).cmic_stat_dma_portnum_map_27_24[0]) >> 8) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_27_24r_SBUS_PORTNUM_25f_SET(r,f) (r).cmic_stat_dma_portnum_map_27_24[0]=(((r).cmic_stat_dma_portnum_map_27_24[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_27_24r_SBUS_PORTNUM_26f_GET(r) ((((r).cmic_stat_dma_portnum_map_27_24[0]) >> 16) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_27_24r_SBUS_PORTNUM_26f_SET(r,f) (r).cmic_stat_dma_portnum_map_27_24[0]=(((r).cmic_stat_dma_portnum_map_27_24[0] & ~((uint32_t)0x3f << 16)) | ((((uint32_t)f) & 0x3f) << 16))
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_27_24r_SBUS_PORTNUM_27f_GET(r) ((((r).cmic_stat_dma_portnum_map_27_24[0]) >> 24) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_27_24r_SBUS_PORTNUM_27f_SET(r,f) (r).cmic_stat_dma_portnum_map_27_24[0]=(((r).cmic_stat_dma_portnum_map_27_24[0] & ~((uint32_t)0x3f << 24)) | ((((uint32_t)f) & 0x3f) << 24))

/*
 * These macros can be used to access CMIC_STAT_DMA_PORTNUM_MAP_27_24.
 *
 */
#define BCM56218_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_27_24r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_27_24r,r._cmic_stat_dma_portnum_map_27_24)
#define BCM56218_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_27_24r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_27_24r,r._cmic_stat_dma_portnum_map_27_24)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_PORTNUM_MAP_27_24r BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_27_24r
#define CMIC_STAT_DMA_PORTNUM_MAP_27_24r_SIZE BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_27_24r_SIZE
typedef BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_27_24r_t CMIC_STAT_DMA_PORTNUM_MAP_27_24r_t;
#define CMIC_STAT_DMA_PORTNUM_MAP_27_24r_CLR BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_27_24r_CLR
#define CMIC_STAT_DMA_PORTNUM_MAP_27_24r_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_27_24r_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_27_24r_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_27_24r_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_27_24r_SBUS_PORTNUM_24f_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_27_24r_SBUS_PORTNUM_24f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_27_24r_SBUS_PORTNUM_24f_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_27_24r_SBUS_PORTNUM_24f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_27_24r_SBUS_PORTNUM_25f_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_27_24r_SBUS_PORTNUM_25f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_27_24r_SBUS_PORTNUM_25f_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_27_24r_SBUS_PORTNUM_25f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_27_24r_SBUS_PORTNUM_26f_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_27_24r_SBUS_PORTNUM_26f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_27_24r_SBUS_PORTNUM_26f_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_27_24r_SBUS_PORTNUM_26f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_27_24r_SBUS_PORTNUM_27f_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_27_24r_SBUS_PORTNUM_27f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_27_24r_SBUS_PORTNUM_27f_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_27_24r_SBUS_PORTNUM_27f_SET
#define READ_CMIC_STAT_DMA_PORTNUM_MAP_27_24r BCM56218_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_27_24r
#define WRITE_CMIC_STAT_DMA_PORTNUM_MAP_27_24r BCM56218_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_27_24r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_27_24r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_STAT_DMA_PORTNUM_MAP_31_28
 * BLOCKS:   CMIC
 * DESC:     Stats DMA port <-> port-number map, ports 31_28

 * SIZE:     32
 * FIELDS:
 *     SBUS_PORTNUM_28  S-bus port number for port 28
 *     SBUS_PORTNUM_29  S-bus port number for port 29
 *     SBUS_PORTNUM_30  S-bus port number for port 30
 *     SBUS_PORTNUM_31  S-bus port number for port 31
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_28r 0x000005dc

#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_28r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_PORTNUM_MAP_31_28.
 *
 */
typedef union BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_28r_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_portnum_map_31_28[1];
	uint32_t _cmic_stat_dma_portnum_map_31_28;
} BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_28r_t;

#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_28r_CLR(r) (r).cmic_stat_dma_portnum_map_31_28[0] = 0
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_28r_SET(r,d) (r).cmic_stat_dma_portnum_map_31_28[0] = d
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_28r_GET(r) (r).cmic_stat_dma_portnum_map_31_28[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_28r_SBUS_PORTNUM_28f_GET(r) (((r).cmic_stat_dma_portnum_map_31_28[0]) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_28r_SBUS_PORTNUM_28f_SET(r,f) (r).cmic_stat_dma_portnum_map_31_28[0]=(((r).cmic_stat_dma_portnum_map_31_28[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_28r_SBUS_PORTNUM_29f_GET(r) ((((r).cmic_stat_dma_portnum_map_31_28[0]) >> 8) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_28r_SBUS_PORTNUM_29f_SET(r,f) (r).cmic_stat_dma_portnum_map_31_28[0]=(((r).cmic_stat_dma_portnum_map_31_28[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_28r_SBUS_PORTNUM_30f_GET(r) ((((r).cmic_stat_dma_portnum_map_31_28[0]) >> 16) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_28r_SBUS_PORTNUM_30f_SET(r,f) (r).cmic_stat_dma_portnum_map_31_28[0]=(((r).cmic_stat_dma_portnum_map_31_28[0] & ~((uint32_t)0x3f << 16)) | ((((uint32_t)f) & 0x3f) << 16))
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_28r_SBUS_PORTNUM_31f_GET(r) ((((r).cmic_stat_dma_portnum_map_31_28[0]) >> 24) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_28r_SBUS_PORTNUM_31f_SET(r,f) (r).cmic_stat_dma_portnum_map_31_28[0]=(((r).cmic_stat_dma_portnum_map_31_28[0] & ~((uint32_t)0x3f << 24)) | ((((uint32_t)f) & 0x3f) << 24))

/*
 * These macros can be used to access CMIC_STAT_DMA_PORTNUM_MAP_31_28.
 *
 */
#define BCM56218_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_31_28r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_28r,r._cmic_stat_dma_portnum_map_31_28)
#define BCM56218_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_31_28r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_28r,r._cmic_stat_dma_portnum_map_31_28)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_PORTNUM_MAP_31_28r BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_28r
#define CMIC_STAT_DMA_PORTNUM_MAP_31_28r_SIZE BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_28r_SIZE
typedef BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_28r_t CMIC_STAT_DMA_PORTNUM_MAP_31_28r_t;
#define CMIC_STAT_DMA_PORTNUM_MAP_31_28r_CLR BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_28r_CLR
#define CMIC_STAT_DMA_PORTNUM_MAP_31_28r_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_28r_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_31_28r_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_28r_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_31_28r_SBUS_PORTNUM_28f_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_28r_SBUS_PORTNUM_28f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_31_28r_SBUS_PORTNUM_28f_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_28r_SBUS_PORTNUM_28f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_31_28r_SBUS_PORTNUM_29f_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_28r_SBUS_PORTNUM_29f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_31_28r_SBUS_PORTNUM_29f_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_28r_SBUS_PORTNUM_29f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_31_28r_SBUS_PORTNUM_30f_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_28r_SBUS_PORTNUM_30f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_31_28r_SBUS_PORTNUM_30f_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_28r_SBUS_PORTNUM_30f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_31_28r_SBUS_PORTNUM_31f_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_28r_SBUS_PORTNUM_31f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_31_28r_SBUS_PORTNUM_31f_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_28r_SBUS_PORTNUM_31f_SET
#define READ_CMIC_STAT_DMA_PORTNUM_MAP_31_28r BCM56218_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_31_28r
#define WRITE_CMIC_STAT_DMA_PORTNUM_MAP_31_28r BCM56218_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_31_28r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_28r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_STAT_DMA_PORTNUM_MAP_35_32
 * BLOCKS:   CMIC
 * DESC:     Stats DMA port <-> port-number map, ports 35_32

 * SIZE:     32
 * FIELDS:
 *     SBUS_PORTNUM_32  S-bus port number for port 32
 *     SBUS_PORTNUM_33  S-bus port number for port 33
 *     SBUS_PORTNUM_34  S-bus port number for port 34
 *     SBUS_PORTNUM_35  S-bus port number for port 35
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_35_32r 0x000005e0

#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_35_32r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_PORTNUM_MAP_35_32.
 *
 */
typedef union BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_35_32r_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_portnum_map_35_32[1];
	uint32_t _cmic_stat_dma_portnum_map_35_32;
} BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_35_32r_t;

#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_35_32r_CLR(r) (r).cmic_stat_dma_portnum_map_35_32[0] = 0
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_35_32r_SET(r,d) (r).cmic_stat_dma_portnum_map_35_32[0] = d
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_35_32r_GET(r) (r).cmic_stat_dma_portnum_map_35_32[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_35_32r_SBUS_PORTNUM_32f_GET(r) (((r).cmic_stat_dma_portnum_map_35_32[0]) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_35_32r_SBUS_PORTNUM_32f_SET(r,f) (r).cmic_stat_dma_portnum_map_35_32[0]=(((r).cmic_stat_dma_portnum_map_35_32[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_35_32r_SBUS_PORTNUM_33f_GET(r) ((((r).cmic_stat_dma_portnum_map_35_32[0]) >> 8) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_35_32r_SBUS_PORTNUM_33f_SET(r,f) (r).cmic_stat_dma_portnum_map_35_32[0]=(((r).cmic_stat_dma_portnum_map_35_32[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_35_32r_SBUS_PORTNUM_34f_GET(r) ((((r).cmic_stat_dma_portnum_map_35_32[0]) >> 16) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_35_32r_SBUS_PORTNUM_34f_SET(r,f) (r).cmic_stat_dma_portnum_map_35_32[0]=(((r).cmic_stat_dma_portnum_map_35_32[0] & ~((uint32_t)0x3f << 16)) | ((((uint32_t)f) & 0x3f) << 16))
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_35_32r_SBUS_PORTNUM_35f_GET(r) ((((r).cmic_stat_dma_portnum_map_35_32[0]) >> 24) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_35_32r_SBUS_PORTNUM_35f_SET(r,f) (r).cmic_stat_dma_portnum_map_35_32[0]=(((r).cmic_stat_dma_portnum_map_35_32[0] & ~((uint32_t)0x3f << 24)) | ((((uint32_t)f) & 0x3f) << 24))

/*
 * These macros can be used to access CMIC_STAT_DMA_PORTNUM_MAP_35_32.
 *
 */
#define BCM56218_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_35_32r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_35_32r,r._cmic_stat_dma_portnum_map_35_32)
#define BCM56218_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_35_32r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_35_32r,r._cmic_stat_dma_portnum_map_35_32)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_PORTNUM_MAP_35_32r BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_35_32r
#define CMIC_STAT_DMA_PORTNUM_MAP_35_32r_SIZE BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_35_32r_SIZE
typedef BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_35_32r_t CMIC_STAT_DMA_PORTNUM_MAP_35_32r_t;
#define CMIC_STAT_DMA_PORTNUM_MAP_35_32r_CLR BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_35_32r_CLR
#define CMIC_STAT_DMA_PORTNUM_MAP_35_32r_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_35_32r_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_35_32r_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_35_32r_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_35_32r_SBUS_PORTNUM_32f_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_35_32r_SBUS_PORTNUM_32f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_35_32r_SBUS_PORTNUM_32f_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_35_32r_SBUS_PORTNUM_32f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_35_32r_SBUS_PORTNUM_33f_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_35_32r_SBUS_PORTNUM_33f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_35_32r_SBUS_PORTNUM_33f_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_35_32r_SBUS_PORTNUM_33f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_35_32r_SBUS_PORTNUM_34f_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_35_32r_SBUS_PORTNUM_34f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_35_32r_SBUS_PORTNUM_34f_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_35_32r_SBUS_PORTNUM_34f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_35_32r_SBUS_PORTNUM_35f_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_35_32r_SBUS_PORTNUM_35f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_35_32r_SBUS_PORTNUM_35f_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_35_32r_SBUS_PORTNUM_35f_SET
#define READ_CMIC_STAT_DMA_PORTNUM_MAP_35_32r BCM56218_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_35_32r
#define WRITE_CMIC_STAT_DMA_PORTNUM_MAP_35_32r BCM56218_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_35_32r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_35_32r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_STAT_DMA_PORTNUM_MAP_39_36
 * BLOCKS:   CMIC
 * DESC:     Stats DMA port <-> port-number map, ports 39_36

 * SIZE:     32
 * FIELDS:
 *     SBUS_PORTNUM_36  S-bus port number for port 36
 *     SBUS_PORTNUM_37  S-bus port number for port 37
 *     SBUS_PORTNUM_38  S-bus port number for port 38
 *     SBUS_PORTNUM_39  S-bus port number for port 39
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_39_36r 0x000005e4

#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_39_36r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_PORTNUM_MAP_39_36.
 *
 */
typedef union BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_39_36r_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_portnum_map_39_36[1];
	uint32_t _cmic_stat_dma_portnum_map_39_36;
} BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_39_36r_t;

#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_39_36r_CLR(r) (r).cmic_stat_dma_portnum_map_39_36[0] = 0
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_39_36r_SET(r,d) (r).cmic_stat_dma_portnum_map_39_36[0] = d
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_39_36r_GET(r) (r).cmic_stat_dma_portnum_map_39_36[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_39_36r_SBUS_PORTNUM_36f_GET(r) (((r).cmic_stat_dma_portnum_map_39_36[0]) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_39_36r_SBUS_PORTNUM_36f_SET(r,f) (r).cmic_stat_dma_portnum_map_39_36[0]=(((r).cmic_stat_dma_portnum_map_39_36[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_39_36r_SBUS_PORTNUM_37f_GET(r) ((((r).cmic_stat_dma_portnum_map_39_36[0]) >> 8) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_39_36r_SBUS_PORTNUM_37f_SET(r,f) (r).cmic_stat_dma_portnum_map_39_36[0]=(((r).cmic_stat_dma_portnum_map_39_36[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_39_36r_SBUS_PORTNUM_38f_GET(r) ((((r).cmic_stat_dma_portnum_map_39_36[0]) >> 16) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_39_36r_SBUS_PORTNUM_38f_SET(r,f) (r).cmic_stat_dma_portnum_map_39_36[0]=(((r).cmic_stat_dma_portnum_map_39_36[0] & ~((uint32_t)0x3f << 16)) | ((((uint32_t)f) & 0x3f) << 16))
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_39_36r_SBUS_PORTNUM_39f_GET(r) ((((r).cmic_stat_dma_portnum_map_39_36[0]) >> 24) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_39_36r_SBUS_PORTNUM_39f_SET(r,f) (r).cmic_stat_dma_portnum_map_39_36[0]=(((r).cmic_stat_dma_portnum_map_39_36[0] & ~((uint32_t)0x3f << 24)) | ((((uint32_t)f) & 0x3f) << 24))

/*
 * These macros can be used to access CMIC_STAT_DMA_PORTNUM_MAP_39_36.
 *
 */
#define BCM56218_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_39_36r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_39_36r,r._cmic_stat_dma_portnum_map_39_36)
#define BCM56218_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_39_36r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_39_36r,r._cmic_stat_dma_portnum_map_39_36)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_PORTNUM_MAP_39_36r BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_39_36r
#define CMIC_STAT_DMA_PORTNUM_MAP_39_36r_SIZE BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_39_36r_SIZE
typedef BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_39_36r_t CMIC_STAT_DMA_PORTNUM_MAP_39_36r_t;
#define CMIC_STAT_DMA_PORTNUM_MAP_39_36r_CLR BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_39_36r_CLR
#define CMIC_STAT_DMA_PORTNUM_MAP_39_36r_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_39_36r_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_39_36r_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_39_36r_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_39_36r_SBUS_PORTNUM_36f_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_39_36r_SBUS_PORTNUM_36f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_39_36r_SBUS_PORTNUM_36f_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_39_36r_SBUS_PORTNUM_36f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_39_36r_SBUS_PORTNUM_37f_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_39_36r_SBUS_PORTNUM_37f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_39_36r_SBUS_PORTNUM_37f_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_39_36r_SBUS_PORTNUM_37f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_39_36r_SBUS_PORTNUM_38f_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_39_36r_SBUS_PORTNUM_38f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_39_36r_SBUS_PORTNUM_38f_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_39_36r_SBUS_PORTNUM_38f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_39_36r_SBUS_PORTNUM_39f_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_39_36r_SBUS_PORTNUM_39f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_39_36r_SBUS_PORTNUM_39f_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_39_36r_SBUS_PORTNUM_39f_SET
#define READ_CMIC_STAT_DMA_PORTNUM_MAP_39_36r BCM56218_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_39_36r
#define WRITE_CMIC_STAT_DMA_PORTNUM_MAP_39_36r BCM56218_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_39_36r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_39_36r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_STAT_DMA_PORTNUM_MAP_3_0
 * BLOCKS:   CMIC
 * DESC:     Stats DMA port <-> port-number map, ports 3_0

 * SIZE:     32
 * FIELDS:
 *     SBUS_PORTNUM_0   S-bus port number for port 0
 *     SBUS_PORTNUM_1   S-bus port number for port 1
 *     SBUS_PORTNUM_2   S-bus port number for port 2
 *     SBUS_PORTNUM_3   S-bus port number for port 3
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_3_0r 0x000005c0

#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_3_0r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_PORTNUM_MAP_3_0.
 *
 */
typedef union BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_3_0r_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_portnum_map_3_0[1];
	uint32_t _cmic_stat_dma_portnum_map_3_0;
} BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_3_0r_t;

#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_3_0r_CLR(r) (r).cmic_stat_dma_portnum_map_3_0[0] = 0
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_3_0r_SET(r,d) (r).cmic_stat_dma_portnum_map_3_0[0] = d
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_3_0r_GET(r) (r).cmic_stat_dma_portnum_map_3_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_3_0r_SBUS_PORTNUM_0f_GET(r) (((r).cmic_stat_dma_portnum_map_3_0[0]) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_3_0r_SBUS_PORTNUM_0f_SET(r,f) (r).cmic_stat_dma_portnum_map_3_0[0]=(((r).cmic_stat_dma_portnum_map_3_0[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_3_0r_SBUS_PORTNUM_1f_GET(r) ((((r).cmic_stat_dma_portnum_map_3_0[0]) >> 8) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_3_0r_SBUS_PORTNUM_1f_SET(r,f) (r).cmic_stat_dma_portnum_map_3_0[0]=(((r).cmic_stat_dma_portnum_map_3_0[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_3_0r_SBUS_PORTNUM_2f_GET(r) ((((r).cmic_stat_dma_portnum_map_3_0[0]) >> 16) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_3_0r_SBUS_PORTNUM_2f_SET(r,f) (r).cmic_stat_dma_portnum_map_3_0[0]=(((r).cmic_stat_dma_portnum_map_3_0[0] & ~((uint32_t)0x3f << 16)) | ((((uint32_t)f) & 0x3f) << 16))
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_3_0r_SBUS_PORTNUM_3f_GET(r) ((((r).cmic_stat_dma_portnum_map_3_0[0]) >> 24) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_3_0r_SBUS_PORTNUM_3f_SET(r,f) (r).cmic_stat_dma_portnum_map_3_0[0]=(((r).cmic_stat_dma_portnum_map_3_0[0] & ~((uint32_t)0x3f << 24)) | ((((uint32_t)f) & 0x3f) << 24))

/*
 * These macros can be used to access CMIC_STAT_DMA_PORTNUM_MAP_3_0.
 *
 */
#define BCM56218_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_3_0r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_3_0r,r._cmic_stat_dma_portnum_map_3_0)
#define BCM56218_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_3_0r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_3_0r,r._cmic_stat_dma_portnum_map_3_0)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_PORTNUM_MAP_3_0r BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_3_0r
#define CMIC_STAT_DMA_PORTNUM_MAP_3_0r_SIZE BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_3_0r_SIZE
typedef BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_3_0r_t CMIC_STAT_DMA_PORTNUM_MAP_3_0r_t;
#define CMIC_STAT_DMA_PORTNUM_MAP_3_0r_CLR BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_3_0r_CLR
#define CMIC_STAT_DMA_PORTNUM_MAP_3_0r_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_3_0r_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_3_0r_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_3_0r_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_3_0r_SBUS_PORTNUM_0f_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_3_0r_SBUS_PORTNUM_0f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_3_0r_SBUS_PORTNUM_0f_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_3_0r_SBUS_PORTNUM_0f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_3_0r_SBUS_PORTNUM_1f_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_3_0r_SBUS_PORTNUM_1f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_3_0r_SBUS_PORTNUM_1f_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_3_0r_SBUS_PORTNUM_1f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_3_0r_SBUS_PORTNUM_2f_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_3_0r_SBUS_PORTNUM_2f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_3_0r_SBUS_PORTNUM_2f_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_3_0r_SBUS_PORTNUM_2f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_3_0r_SBUS_PORTNUM_3f_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_3_0r_SBUS_PORTNUM_3f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_3_0r_SBUS_PORTNUM_3f_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_3_0r_SBUS_PORTNUM_3f_SET
#define READ_CMIC_STAT_DMA_PORTNUM_MAP_3_0r BCM56218_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_3_0r
#define WRITE_CMIC_STAT_DMA_PORTNUM_MAP_3_0r BCM56218_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_3_0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_3_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_STAT_DMA_PORTNUM_MAP_43_40
 * BLOCKS:   CMIC
 * DESC:     Stats DMA port <-> port-number map, ports 43_40

 * SIZE:     32
 * FIELDS:
 *     SBUS_PORTNUM_40  S-bus port number for port 40
 *     SBUS_PORTNUM_41  S-bus port number for port 41
 *     SBUS_PORTNUM_42  S-bus port number for port 42
 *     SBUS_PORTNUM_43  S-bus port number for port 43
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_43_40r 0x000005e8

#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_43_40r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_PORTNUM_MAP_43_40.
 *
 */
typedef union BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_43_40r_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_portnum_map_43_40[1];
	uint32_t _cmic_stat_dma_portnum_map_43_40;
} BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_43_40r_t;

#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_43_40r_CLR(r) (r).cmic_stat_dma_portnum_map_43_40[0] = 0
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_43_40r_SET(r,d) (r).cmic_stat_dma_portnum_map_43_40[0] = d
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_43_40r_GET(r) (r).cmic_stat_dma_portnum_map_43_40[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_43_40r_SBUS_PORTNUM_40f_GET(r) (((r).cmic_stat_dma_portnum_map_43_40[0]) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_43_40r_SBUS_PORTNUM_40f_SET(r,f) (r).cmic_stat_dma_portnum_map_43_40[0]=(((r).cmic_stat_dma_portnum_map_43_40[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_43_40r_SBUS_PORTNUM_41f_GET(r) ((((r).cmic_stat_dma_portnum_map_43_40[0]) >> 8) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_43_40r_SBUS_PORTNUM_41f_SET(r,f) (r).cmic_stat_dma_portnum_map_43_40[0]=(((r).cmic_stat_dma_portnum_map_43_40[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_43_40r_SBUS_PORTNUM_42f_GET(r) ((((r).cmic_stat_dma_portnum_map_43_40[0]) >> 16) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_43_40r_SBUS_PORTNUM_42f_SET(r,f) (r).cmic_stat_dma_portnum_map_43_40[0]=(((r).cmic_stat_dma_portnum_map_43_40[0] & ~((uint32_t)0x3f << 16)) | ((((uint32_t)f) & 0x3f) << 16))
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_43_40r_SBUS_PORTNUM_43f_GET(r) ((((r).cmic_stat_dma_portnum_map_43_40[0]) >> 24) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_43_40r_SBUS_PORTNUM_43f_SET(r,f) (r).cmic_stat_dma_portnum_map_43_40[0]=(((r).cmic_stat_dma_portnum_map_43_40[0] & ~((uint32_t)0x3f << 24)) | ((((uint32_t)f) & 0x3f) << 24))

/*
 * These macros can be used to access CMIC_STAT_DMA_PORTNUM_MAP_43_40.
 *
 */
#define BCM56218_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_43_40r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_43_40r,r._cmic_stat_dma_portnum_map_43_40)
#define BCM56218_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_43_40r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_43_40r,r._cmic_stat_dma_portnum_map_43_40)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_PORTNUM_MAP_43_40r BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_43_40r
#define CMIC_STAT_DMA_PORTNUM_MAP_43_40r_SIZE BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_43_40r_SIZE
typedef BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_43_40r_t CMIC_STAT_DMA_PORTNUM_MAP_43_40r_t;
#define CMIC_STAT_DMA_PORTNUM_MAP_43_40r_CLR BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_43_40r_CLR
#define CMIC_STAT_DMA_PORTNUM_MAP_43_40r_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_43_40r_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_43_40r_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_43_40r_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_43_40r_SBUS_PORTNUM_40f_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_43_40r_SBUS_PORTNUM_40f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_43_40r_SBUS_PORTNUM_40f_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_43_40r_SBUS_PORTNUM_40f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_43_40r_SBUS_PORTNUM_41f_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_43_40r_SBUS_PORTNUM_41f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_43_40r_SBUS_PORTNUM_41f_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_43_40r_SBUS_PORTNUM_41f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_43_40r_SBUS_PORTNUM_42f_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_43_40r_SBUS_PORTNUM_42f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_43_40r_SBUS_PORTNUM_42f_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_43_40r_SBUS_PORTNUM_42f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_43_40r_SBUS_PORTNUM_43f_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_43_40r_SBUS_PORTNUM_43f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_43_40r_SBUS_PORTNUM_43f_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_43_40r_SBUS_PORTNUM_43f_SET
#define READ_CMIC_STAT_DMA_PORTNUM_MAP_43_40r BCM56218_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_43_40r
#define WRITE_CMIC_STAT_DMA_PORTNUM_MAP_43_40r BCM56218_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_43_40r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_43_40r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_STAT_DMA_PORTNUM_MAP_47_44
 * BLOCKS:   CMIC
 * DESC:     Stats DMA port <-> port-number map, ports 47_44

 * SIZE:     32
 * FIELDS:
 *     SBUS_PORTNUM_44  S-bus port number for port 44
 *     SBUS_PORTNUM_45  S-bus port number for port 45
 *     SBUS_PORTNUM_46  S-bus port number for port 46
 *     SBUS_PORTNUM_47  S-bus port number for port 47
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_47_44r 0x000005ec

#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_47_44r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_PORTNUM_MAP_47_44.
 *
 */
typedef union BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_47_44r_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_portnum_map_47_44[1];
	uint32_t _cmic_stat_dma_portnum_map_47_44;
} BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_47_44r_t;

#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_47_44r_CLR(r) (r).cmic_stat_dma_portnum_map_47_44[0] = 0
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_47_44r_SET(r,d) (r).cmic_stat_dma_portnum_map_47_44[0] = d
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_47_44r_GET(r) (r).cmic_stat_dma_portnum_map_47_44[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_47_44r_SBUS_PORTNUM_44f_GET(r) (((r).cmic_stat_dma_portnum_map_47_44[0]) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_47_44r_SBUS_PORTNUM_44f_SET(r,f) (r).cmic_stat_dma_portnum_map_47_44[0]=(((r).cmic_stat_dma_portnum_map_47_44[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_47_44r_SBUS_PORTNUM_45f_GET(r) ((((r).cmic_stat_dma_portnum_map_47_44[0]) >> 8) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_47_44r_SBUS_PORTNUM_45f_SET(r,f) (r).cmic_stat_dma_portnum_map_47_44[0]=(((r).cmic_stat_dma_portnum_map_47_44[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_47_44r_SBUS_PORTNUM_46f_GET(r) ((((r).cmic_stat_dma_portnum_map_47_44[0]) >> 16) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_47_44r_SBUS_PORTNUM_46f_SET(r,f) (r).cmic_stat_dma_portnum_map_47_44[0]=(((r).cmic_stat_dma_portnum_map_47_44[0] & ~((uint32_t)0x3f << 16)) | ((((uint32_t)f) & 0x3f) << 16))
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_47_44r_SBUS_PORTNUM_47f_GET(r) ((((r).cmic_stat_dma_portnum_map_47_44[0]) >> 24) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_47_44r_SBUS_PORTNUM_47f_SET(r,f) (r).cmic_stat_dma_portnum_map_47_44[0]=(((r).cmic_stat_dma_portnum_map_47_44[0] & ~((uint32_t)0x3f << 24)) | ((((uint32_t)f) & 0x3f) << 24))

/*
 * These macros can be used to access CMIC_STAT_DMA_PORTNUM_MAP_47_44.
 *
 */
#define BCM56218_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_47_44r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_47_44r,r._cmic_stat_dma_portnum_map_47_44)
#define BCM56218_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_47_44r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_47_44r,r._cmic_stat_dma_portnum_map_47_44)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_PORTNUM_MAP_47_44r BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_47_44r
#define CMIC_STAT_DMA_PORTNUM_MAP_47_44r_SIZE BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_47_44r_SIZE
typedef BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_47_44r_t CMIC_STAT_DMA_PORTNUM_MAP_47_44r_t;
#define CMIC_STAT_DMA_PORTNUM_MAP_47_44r_CLR BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_47_44r_CLR
#define CMIC_STAT_DMA_PORTNUM_MAP_47_44r_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_47_44r_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_47_44r_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_47_44r_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_47_44r_SBUS_PORTNUM_44f_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_47_44r_SBUS_PORTNUM_44f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_47_44r_SBUS_PORTNUM_44f_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_47_44r_SBUS_PORTNUM_44f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_47_44r_SBUS_PORTNUM_45f_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_47_44r_SBUS_PORTNUM_45f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_47_44r_SBUS_PORTNUM_45f_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_47_44r_SBUS_PORTNUM_45f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_47_44r_SBUS_PORTNUM_46f_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_47_44r_SBUS_PORTNUM_46f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_47_44r_SBUS_PORTNUM_46f_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_47_44r_SBUS_PORTNUM_46f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_47_44r_SBUS_PORTNUM_47f_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_47_44r_SBUS_PORTNUM_47f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_47_44r_SBUS_PORTNUM_47f_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_47_44r_SBUS_PORTNUM_47f_SET
#define READ_CMIC_STAT_DMA_PORTNUM_MAP_47_44r BCM56218_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_47_44r
#define WRITE_CMIC_STAT_DMA_PORTNUM_MAP_47_44r BCM56218_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_47_44r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_47_44r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_STAT_DMA_PORTNUM_MAP_51_48
 * BLOCKS:   CMIC
 * DESC:     Stats DMA port <-> port-number map, ports 51_48

 * SIZE:     32
 * FIELDS:
 *     SBUS_PORTNUM_48  S-bus port number for port 48
 *     SBUS_PORTNUM_49  S-bus port number for port 49
 *     SBUS_PORTNUM_50  S-bus port number for port 50
 *     SBUS_PORTNUM_51  S-bus port number for port 51
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_51_48r 0x000005f0

#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_51_48r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_PORTNUM_MAP_51_48.
 *
 */
typedef union BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_51_48r_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_portnum_map_51_48[1];
	uint32_t _cmic_stat_dma_portnum_map_51_48;
} BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_51_48r_t;

#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_51_48r_CLR(r) (r).cmic_stat_dma_portnum_map_51_48[0] = 0
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_51_48r_SET(r,d) (r).cmic_stat_dma_portnum_map_51_48[0] = d
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_51_48r_GET(r) (r).cmic_stat_dma_portnum_map_51_48[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_51_48r_SBUS_PORTNUM_48f_GET(r) (((r).cmic_stat_dma_portnum_map_51_48[0]) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_51_48r_SBUS_PORTNUM_48f_SET(r,f) (r).cmic_stat_dma_portnum_map_51_48[0]=(((r).cmic_stat_dma_portnum_map_51_48[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_51_48r_SBUS_PORTNUM_49f_GET(r) ((((r).cmic_stat_dma_portnum_map_51_48[0]) >> 8) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_51_48r_SBUS_PORTNUM_49f_SET(r,f) (r).cmic_stat_dma_portnum_map_51_48[0]=(((r).cmic_stat_dma_portnum_map_51_48[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_51_48r_SBUS_PORTNUM_50f_GET(r) ((((r).cmic_stat_dma_portnum_map_51_48[0]) >> 16) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_51_48r_SBUS_PORTNUM_50f_SET(r,f) (r).cmic_stat_dma_portnum_map_51_48[0]=(((r).cmic_stat_dma_portnum_map_51_48[0] & ~((uint32_t)0x3f << 16)) | ((((uint32_t)f) & 0x3f) << 16))
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_51_48r_SBUS_PORTNUM_51f_GET(r) ((((r).cmic_stat_dma_portnum_map_51_48[0]) >> 24) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_51_48r_SBUS_PORTNUM_51f_SET(r,f) (r).cmic_stat_dma_portnum_map_51_48[0]=(((r).cmic_stat_dma_portnum_map_51_48[0] & ~((uint32_t)0x3f << 24)) | ((((uint32_t)f) & 0x3f) << 24))

/*
 * These macros can be used to access CMIC_STAT_DMA_PORTNUM_MAP_51_48.
 *
 */
#define BCM56218_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_51_48r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_51_48r,r._cmic_stat_dma_portnum_map_51_48)
#define BCM56218_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_51_48r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_51_48r,r._cmic_stat_dma_portnum_map_51_48)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_PORTNUM_MAP_51_48r BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_51_48r
#define CMIC_STAT_DMA_PORTNUM_MAP_51_48r_SIZE BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_51_48r_SIZE
typedef BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_51_48r_t CMIC_STAT_DMA_PORTNUM_MAP_51_48r_t;
#define CMIC_STAT_DMA_PORTNUM_MAP_51_48r_CLR BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_51_48r_CLR
#define CMIC_STAT_DMA_PORTNUM_MAP_51_48r_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_51_48r_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_51_48r_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_51_48r_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_51_48r_SBUS_PORTNUM_48f_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_51_48r_SBUS_PORTNUM_48f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_51_48r_SBUS_PORTNUM_48f_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_51_48r_SBUS_PORTNUM_48f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_51_48r_SBUS_PORTNUM_49f_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_51_48r_SBUS_PORTNUM_49f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_51_48r_SBUS_PORTNUM_49f_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_51_48r_SBUS_PORTNUM_49f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_51_48r_SBUS_PORTNUM_50f_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_51_48r_SBUS_PORTNUM_50f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_51_48r_SBUS_PORTNUM_50f_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_51_48r_SBUS_PORTNUM_50f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_51_48r_SBUS_PORTNUM_51f_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_51_48r_SBUS_PORTNUM_51f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_51_48r_SBUS_PORTNUM_51f_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_51_48r_SBUS_PORTNUM_51f_SET
#define READ_CMIC_STAT_DMA_PORTNUM_MAP_51_48r BCM56218_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_51_48r
#define WRITE_CMIC_STAT_DMA_PORTNUM_MAP_51_48r BCM56218_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_51_48r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_51_48r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_STAT_DMA_PORTNUM_MAP_55_52
 * BLOCKS:   CMIC
 * DESC:     Stats DMA port <-> port-number map, ports 55_52

 * SIZE:     32
 * FIELDS:
 *     SBUS_PORTNUM_52  S-bus port number for port 52
 *     SBUS_PORTNUM_53  S-bus port number for port 53
 *     SBUS_PORTNUM_54  S-bus port number for port 54
 *     SBUS_PORTNUM_55  S-bus port number for port 55
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_55_52r 0x000005f4

#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_55_52r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_PORTNUM_MAP_55_52.
 *
 */
typedef union BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_55_52r_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_portnum_map_55_52[1];
	uint32_t _cmic_stat_dma_portnum_map_55_52;
} BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_55_52r_t;

#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_55_52r_CLR(r) (r).cmic_stat_dma_portnum_map_55_52[0] = 0
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_55_52r_SET(r,d) (r).cmic_stat_dma_portnum_map_55_52[0] = d
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_55_52r_GET(r) (r).cmic_stat_dma_portnum_map_55_52[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_55_52r_SBUS_PORTNUM_52f_GET(r) (((r).cmic_stat_dma_portnum_map_55_52[0]) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_55_52r_SBUS_PORTNUM_52f_SET(r,f) (r).cmic_stat_dma_portnum_map_55_52[0]=(((r).cmic_stat_dma_portnum_map_55_52[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_55_52r_SBUS_PORTNUM_53f_GET(r) ((((r).cmic_stat_dma_portnum_map_55_52[0]) >> 8) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_55_52r_SBUS_PORTNUM_53f_SET(r,f) (r).cmic_stat_dma_portnum_map_55_52[0]=(((r).cmic_stat_dma_portnum_map_55_52[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_55_52r_SBUS_PORTNUM_54f_GET(r) ((((r).cmic_stat_dma_portnum_map_55_52[0]) >> 16) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_55_52r_SBUS_PORTNUM_54f_SET(r,f) (r).cmic_stat_dma_portnum_map_55_52[0]=(((r).cmic_stat_dma_portnum_map_55_52[0] & ~((uint32_t)0x3f << 16)) | ((((uint32_t)f) & 0x3f) << 16))
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_55_52r_SBUS_PORTNUM_55f_GET(r) ((((r).cmic_stat_dma_portnum_map_55_52[0]) >> 24) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_55_52r_SBUS_PORTNUM_55f_SET(r,f) (r).cmic_stat_dma_portnum_map_55_52[0]=(((r).cmic_stat_dma_portnum_map_55_52[0] & ~((uint32_t)0x3f << 24)) | ((((uint32_t)f) & 0x3f) << 24))

/*
 * These macros can be used to access CMIC_STAT_DMA_PORTNUM_MAP_55_52.
 *
 */
#define BCM56218_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_55_52r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_55_52r,r._cmic_stat_dma_portnum_map_55_52)
#define BCM56218_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_55_52r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_55_52r,r._cmic_stat_dma_portnum_map_55_52)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_PORTNUM_MAP_55_52r BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_55_52r
#define CMIC_STAT_DMA_PORTNUM_MAP_55_52r_SIZE BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_55_52r_SIZE
typedef BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_55_52r_t CMIC_STAT_DMA_PORTNUM_MAP_55_52r_t;
#define CMIC_STAT_DMA_PORTNUM_MAP_55_52r_CLR BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_55_52r_CLR
#define CMIC_STAT_DMA_PORTNUM_MAP_55_52r_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_55_52r_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_55_52r_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_55_52r_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_55_52r_SBUS_PORTNUM_52f_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_55_52r_SBUS_PORTNUM_52f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_55_52r_SBUS_PORTNUM_52f_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_55_52r_SBUS_PORTNUM_52f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_55_52r_SBUS_PORTNUM_53f_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_55_52r_SBUS_PORTNUM_53f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_55_52r_SBUS_PORTNUM_53f_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_55_52r_SBUS_PORTNUM_53f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_55_52r_SBUS_PORTNUM_54f_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_55_52r_SBUS_PORTNUM_54f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_55_52r_SBUS_PORTNUM_54f_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_55_52r_SBUS_PORTNUM_54f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_55_52r_SBUS_PORTNUM_55f_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_55_52r_SBUS_PORTNUM_55f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_55_52r_SBUS_PORTNUM_55f_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_55_52r_SBUS_PORTNUM_55f_SET
#define READ_CMIC_STAT_DMA_PORTNUM_MAP_55_52r BCM56218_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_55_52r
#define WRITE_CMIC_STAT_DMA_PORTNUM_MAP_55_52r BCM56218_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_55_52r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_55_52r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_STAT_DMA_PORTNUM_MAP_59_56
 * BLOCKS:   CMIC
 * DESC:     Stats DMA port <-> port-number map, ports 59_56

 * SIZE:     32
 * FIELDS:
 *     SBUS_PORTNUM_56  S-bus port number for port 56
 *     SBUS_PORTNUM_57  S-bus port number for port 57
 *     SBUS_PORTNUM_58  S-bus port number for port 58
 *     SBUS_PORTNUM_59  S-bus port number for port 59
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_59_56r 0x000005f8

#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_59_56r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_PORTNUM_MAP_59_56.
 *
 */
typedef union BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_59_56r_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_portnum_map_59_56[1];
	uint32_t _cmic_stat_dma_portnum_map_59_56;
} BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_59_56r_t;

#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_59_56r_CLR(r) (r).cmic_stat_dma_portnum_map_59_56[0] = 0
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_59_56r_SET(r,d) (r).cmic_stat_dma_portnum_map_59_56[0] = d
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_59_56r_GET(r) (r).cmic_stat_dma_portnum_map_59_56[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_59_56r_SBUS_PORTNUM_56f_GET(r) (((r).cmic_stat_dma_portnum_map_59_56[0]) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_59_56r_SBUS_PORTNUM_56f_SET(r,f) (r).cmic_stat_dma_portnum_map_59_56[0]=(((r).cmic_stat_dma_portnum_map_59_56[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_59_56r_SBUS_PORTNUM_57f_GET(r) ((((r).cmic_stat_dma_portnum_map_59_56[0]) >> 8) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_59_56r_SBUS_PORTNUM_57f_SET(r,f) (r).cmic_stat_dma_portnum_map_59_56[0]=(((r).cmic_stat_dma_portnum_map_59_56[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_59_56r_SBUS_PORTNUM_58f_GET(r) ((((r).cmic_stat_dma_portnum_map_59_56[0]) >> 16) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_59_56r_SBUS_PORTNUM_58f_SET(r,f) (r).cmic_stat_dma_portnum_map_59_56[0]=(((r).cmic_stat_dma_portnum_map_59_56[0] & ~((uint32_t)0x3f << 16)) | ((((uint32_t)f) & 0x3f) << 16))
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_59_56r_SBUS_PORTNUM_59f_GET(r) ((((r).cmic_stat_dma_portnum_map_59_56[0]) >> 24) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_59_56r_SBUS_PORTNUM_59f_SET(r,f) (r).cmic_stat_dma_portnum_map_59_56[0]=(((r).cmic_stat_dma_portnum_map_59_56[0] & ~((uint32_t)0x3f << 24)) | ((((uint32_t)f) & 0x3f) << 24))

/*
 * These macros can be used to access CMIC_STAT_DMA_PORTNUM_MAP_59_56.
 *
 */
#define BCM56218_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_59_56r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_59_56r,r._cmic_stat_dma_portnum_map_59_56)
#define BCM56218_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_59_56r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_59_56r,r._cmic_stat_dma_portnum_map_59_56)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_PORTNUM_MAP_59_56r BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_59_56r
#define CMIC_STAT_DMA_PORTNUM_MAP_59_56r_SIZE BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_59_56r_SIZE
typedef BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_59_56r_t CMIC_STAT_DMA_PORTNUM_MAP_59_56r_t;
#define CMIC_STAT_DMA_PORTNUM_MAP_59_56r_CLR BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_59_56r_CLR
#define CMIC_STAT_DMA_PORTNUM_MAP_59_56r_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_59_56r_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_59_56r_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_59_56r_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_59_56r_SBUS_PORTNUM_56f_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_59_56r_SBUS_PORTNUM_56f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_59_56r_SBUS_PORTNUM_56f_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_59_56r_SBUS_PORTNUM_56f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_59_56r_SBUS_PORTNUM_57f_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_59_56r_SBUS_PORTNUM_57f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_59_56r_SBUS_PORTNUM_57f_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_59_56r_SBUS_PORTNUM_57f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_59_56r_SBUS_PORTNUM_58f_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_59_56r_SBUS_PORTNUM_58f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_59_56r_SBUS_PORTNUM_58f_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_59_56r_SBUS_PORTNUM_58f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_59_56r_SBUS_PORTNUM_59f_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_59_56r_SBUS_PORTNUM_59f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_59_56r_SBUS_PORTNUM_59f_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_59_56r_SBUS_PORTNUM_59f_SET
#define READ_CMIC_STAT_DMA_PORTNUM_MAP_59_56r BCM56218_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_59_56r
#define WRITE_CMIC_STAT_DMA_PORTNUM_MAP_59_56r BCM56218_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_59_56r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_59_56r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_STAT_DMA_PORTNUM_MAP_63_60
 * BLOCKS:   CMIC
 * DESC:     Stats DMA port <-> port-number map, ports 63_60

 * SIZE:     32
 * FIELDS:
 *     SBUS_PORTNUM_60  S-bus port number for port 60
 *     SBUS_PORTNUM_61  S-bus port number for port 61
 *     SBUS_PORTNUM_62  S-bus port number for port 62
 *     SBUS_PORTNUM_63  S-bus port number for port 63
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_63_60r 0x000005fc

#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_63_60r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_PORTNUM_MAP_63_60.
 *
 */
typedef union BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_63_60r_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_portnum_map_63_60[1];
	uint32_t _cmic_stat_dma_portnum_map_63_60;
} BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_63_60r_t;

#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_63_60r_CLR(r) (r).cmic_stat_dma_portnum_map_63_60[0] = 0
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_63_60r_SET(r,d) (r).cmic_stat_dma_portnum_map_63_60[0] = d
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_63_60r_GET(r) (r).cmic_stat_dma_portnum_map_63_60[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_63_60r_SBUS_PORTNUM_60f_GET(r) (((r).cmic_stat_dma_portnum_map_63_60[0]) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_63_60r_SBUS_PORTNUM_60f_SET(r,f) (r).cmic_stat_dma_portnum_map_63_60[0]=(((r).cmic_stat_dma_portnum_map_63_60[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_63_60r_SBUS_PORTNUM_61f_GET(r) ((((r).cmic_stat_dma_portnum_map_63_60[0]) >> 8) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_63_60r_SBUS_PORTNUM_61f_SET(r,f) (r).cmic_stat_dma_portnum_map_63_60[0]=(((r).cmic_stat_dma_portnum_map_63_60[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_63_60r_SBUS_PORTNUM_62f_GET(r) ((((r).cmic_stat_dma_portnum_map_63_60[0]) >> 16) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_63_60r_SBUS_PORTNUM_62f_SET(r,f) (r).cmic_stat_dma_portnum_map_63_60[0]=(((r).cmic_stat_dma_portnum_map_63_60[0] & ~((uint32_t)0x3f << 16)) | ((((uint32_t)f) & 0x3f) << 16))
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_63_60r_SBUS_PORTNUM_63f_GET(r) ((((r).cmic_stat_dma_portnum_map_63_60[0]) >> 24) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_63_60r_SBUS_PORTNUM_63f_SET(r,f) (r).cmic_stat_dma_portnum_map_63_60[0]=(((r).cmic_stat_dma_portnum_map_63_60[0] & ~((uint32_t)0x3f << 24)) | ((((uint32_t)f) & 0x3f) << 24))

/*
 * These macros can be used to access CMIC_STAT_DMA_PORTNUM_MAP_63_60.
 *
 */
#define BCM56218_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_63_60r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_63_60r,r._cmic_stat_dma_portnum_map_63_60)
#define BCM56218_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_63_60r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_63_60r,r._cmic_stat_dma_portnum_map_63_60)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_PORTNUM_MAP_63_60r BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_63_60r
#define CMIC_STAT_DMA_PORTNUM_MAP_63_60r_SIZE BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_63_60r_SIZE
typedef BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_63_60r_t CMIC_STAT_DMA_PORTNUM_MAP_63_60r_t;
#define CMIC_STAT_DMA_PORTNUM_MAP_63_60r_CLR BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_63_60r_CLR
#define CMIC_STAT_DMA_PORTNUM_MAP_63_60r_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_63_60r_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_63_60r_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_63_60r_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_63_60r_SBUS_PORTNUM_60f_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_63_60r_SBUS_PORTNUM_60f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_63_60r_SBUS_PORTNUM_60f_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_63_60r_SBUS_PORTNUM_60f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_63_60r_SBUS_PORTNUM_61f_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_63_60r_SBUS_PORTNUM_61f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_63_60r_SBUS_PORTNUM_61f_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_63_60r_SBUS_PORTNUM_61f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_63_60r_SBUS_PORTNUM_62f_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_63_60r_SBUS_PORTNUM_62f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_63_60r_SBUS_PORTNUM_62f_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_63_60r_SBUS_PORTNUM_62f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_63_60r_SBUS_PORTNUM_63f_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_63_60r_SBUS_PORTNUM_63f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_63_60r_SBUS_PORTNUM_63f_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_63_60r_SBUS_PORTNUM_63f_SET
#define READ_CMIC_STAT_DMA_PORTNUM_MAP_63_60r BCM56218_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_63_60r
#define WRITE_CMIC_STAT_DMA_PORTNUM_MAP_63_60r BCM56218_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_63_60r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_63_60r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_STAT_DMA_PORTNUM_MAP_7_4
 * BLOCKS:   CMIC
 * DESC:     Stats DMA port <-> port-number map, ports 7_4

 * SIZE:     32
 * FIELDS:
 *     SBUS_PORTNUM_4   S-bus port number for port 4
 *     SBUS_PORTNUM_5   S-bus port number for port 5
 *     SBUS_PORTNUM_6   S-bus port number for port 6
 *     SBUS_PORTNUM_7   S-bus port number for port 7
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_4r 0x000005c4

#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_4r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_PORTNUM_MAP_7_4.
 *
 */
typedef union BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_4r_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_portnum_map_7_4[1];
	uint32_t _cmic_stat_dma_portnum_map_7_4;
} BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_4r_t;

#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_4r_CLR(r) (r).cmic_stat_dma_portnum_map_7_4[0] = 0
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_4r_SET(r,d) (r).cmic_stat_dma_portnum_map_7_4[0] = d
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_4r_GET(r) (r).cmic_stat_dma_portnum_map_7_4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_4r_SBUS_PORTNUM_4f_GET(r) (((r).cmic_stat_dma_portnum_map_7_4[0]) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_4r_SBUS_PORTNUM_4f_SET(r,f) (r).cmic_stat_dma_portnum_map_7_4[0]=(((r).cmic_stat_dma_portnum_map_7_4[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_4r_SBUS_PORTNUM_5f_GET(r) ((((r).cmic_stat_dma_portnum_map_7_4[0]) >> 8) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_4r_SBUS_PORTNUM_5f_SET(r,f) (r).cmic_stat_dma_portnum_map_7_4[0]=(((r).cmic_stat_dma_portnum_map_7_4[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_4r_SBUS_PORTNUM_6f_GET(r) ((((r).cmic_stat_dma_portnum_map_7_4[0]) >> 16) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_4r_SBUS_PORTNUM_6f_SET(r,f) (r).cmic_stat_dma_portnum_map_7_4[0]=(((r).cmic_stat_dma_portnum_map_7_4[0] & ~((uint32_t)0x3f << 16)) | ((((uint32_t)f) & 0x3f) << 16))
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_4r_SBUS_PORTNUM_7f_GET(r) ((((r).cmic_stat_dma_portnum_map_7_4[0]) >> 24) & 0x3f)
#define BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_4r_SBUS_PORTNUM_7f_SET(r,f) (r).cmic_stat_dma_portnum_map_7_4[0]=(((r).cmic_stat_dma_portnum_map_7_4[0] & ~((uint32_t)0x3f << 24)) | ((((uint32_t)f) & 0x3f) << 24))

/*
 * These macros can be used to access CMIC_STAT_DMA_PORTNUM_MAP_7_4.
 *
 */
#define BCM56218_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_7_4r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_4r,r._cmic_stat_dma_portnum_map_7_4)
#define BCM56218_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_7_4r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_4r,r._cmic_stat_dma_portnum_map_7_4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_PORTNUM_MAP_7_4r BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_4r
#define CMIC_STAT_DMA_PORTNUM_MAP_7_4r_SIZE BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_4r_SIZE
typedef BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_4r_t CMIC_STAT_DMA_PORTNUM_MAP_7_4r_t;
#define CMIC_STAT_DMA_PORTNUM_MAP_7_4r_CLR BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_4r_CLR
#define CMIC_STAT_DMA_PORTNUM_MAP_7_4r_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_4r_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_7_4r_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_4r_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_7_4r_SBUS_PORTNUM_4f_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_4r_SBUS_PORTNUM_4f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_7_4r_SBUS_PORTNUM_4f_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_4r_SBUS_PORTNUM_4f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_7_4r_SBUS_PORTNUM_5f_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_4r_SBUS_PORTNUM_5f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_7_4r_SBUS_PORTNUM_5f_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_4r_SBUS_PORTNUM_5f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_7_4r_SBUS_PORTNUM_6f_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_4r_SBUS_PORTNUM_6f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_7_4r_SBUS_PORTNUM_6f_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_4r_SBUS_PORTNUM_6f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_7_4r_SBUS_PORTNUM_7f_GET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_4r_SBUS_PORTNUM_7f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_7_4r_SBUS_PORTNUM_7f_SET BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_4r_SBUS_PORTNUM_7f_SET
#define READ_CMIC_STAT_DMA_PORTNUM_MAP_7_4r BCM56218_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_7_4r
#define WRITE_CMIC_STAT_DMA_PORTNUM_MAP_7_4r BCM56218_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_7_4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_STAT_DMA_PORTS
 * BLOCKS:   CMIC
 * DESC:     Stat Counter Port Bit Map Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           Stat Counter Port Bit Map
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_STAT_DMA_PORTSr 0x0000016c

#define BCM56218_A0_CMIC_STAT_DMA_PORTSr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_PORTS.
 *
 */
typedef union BCM56218_A0_CMIC_STAT_DMA_PORTSr_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_ports[1];
	uint32_t _cmic_stat_dma_ports;
} BCM56218_A0_CMIC_STAT_DMA_PORTSr_t;

#define BCM56218_A0_CMIC_STAT_DMA_PORTSr_CLR(r) (r).cmic_stat_dma_ports[0] = 0
#define BCM56218_A0_CMIC_STAT_DMA_PORTSr_SET(r,d) (r).cmic_stat_dma_ports[0] = d
#define BCM56218_A0_CMIC_STAT_DMA_PORTSr_GET(r) (r).cmic_stat_dma_ports[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_STAT_DMA_PORTSr_BITMAPf_GET(r) ((r).cmic_stat_dma_ports[0])
#define BCM56218_A0_CMIC_STAT_DMA_PORTSr_BITMAPf_SET(r,f) (r).cmic_stat_dma_ports[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_STAT_DMA_PORTS.
 *
 */
#define BCM56218_A0_READ_CMIC_STAT_DMA_PORTSr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_STAT_DMA_PORTSr,r._cmic_stat_dma_ports)
#define BCM56218_A0_WRITE_CMIC_STAT_DMA_PORTSr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_STAT_DMA_PORTSr,r._cmic_stat_dma_ports)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_PORTSr BCM56218_A0_CMIC_STAT_DMA_PORTSr
#define CMIC_STAT_DMA_PORTSr_SIZE BCM56218_A0_CMIC_STAT_DMA_PORTSr_SIZE
typedef BCM56218_A0_CMIC_STAT_DMA_PORTSr_t CMIC_STAT_DMA_PORTSr_t;
#define CMIC_STAT_DMA_PORTSr_CLR BCM56218_A0_CMIC_STAT_DMA_PORTSr_CLR
#define CMIC_STAT_DMA_PORTSr_SET BCM56218_A0_CMIC_STAT_DMA_PORTSr_SET
#define CMIC_STAT_DMA_PORTSr_GET BCM56218_A0_CMIC_STAT_DMA_PORTSr_GET
#define CMIC_STAT_DMA_PORTSr_BITMAPf_GET BCM56218_A0_CMIC_STAT_DMA_PORTSr_BITMAPf_GET
#define CMIC_STAT_DMA_PORTSr_BITMAPf_SET BCM56218_A0_CMIC_STAT_DMA_PORTSr_BITMAPf_SET
#define READ_CMIC_STAT_DMA_PORTSr BCM56218_A0_READ_CMIC_STAT_DMA_PORTSr
#define WRITE_CMIC_STAT_DMA_PORTSr BCM56218_A0_WRITE_CMIC_STAT_DMA_PORTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_STAT_DMA_PORTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_STAT_DMA_PORTS_HI
 * BLOCKS:   CMIC
 * DESC:     Stat Counter Port Bit Map Register, upper 32 bits
 * SIZE:     32
 * FIELDS:
 *     BITMAP           Stat Counter Port Bit Map
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_STAT_DMA_PORTS_HIr 0x00000780

#define BCM56218_A0_CMIC_STAT_DMA_PORTS_HIr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_PORTS_HI.
 *
 */
typedef union BCM56218_A0_CMIC_STAT_DMA_PORTS_HIr_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_ports_hi[1];
	uint32_t _cmic_stat_dma_ports_hi;
} BCM56218_A0_CMIC_STAT_DMA_PORTS_HIr_t;

#define BCM56218_A0_CMIC_STAT_DMA_PORTS_HIr_CLR(r) (r).cmic_stat_dma_ports_hi[0] = 0
#define BCM56218_A0_CMIC_STAT_DMA_PORTS_HIr_SET(r,d) (r).cmic_stat_dma_ports_hi[0] = d
#define BCM56218_A0_CMIC_STAT_DMA_PORTS_HIr_GET(r) (r).cmic_stat_dma_ports_hi[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_STAT_DMA_PORTS_HIr_BITMAPf_GET(r) ((r).cmic_stat_dma_ports_hi[0])
#define BCM56218_A0_CMIC_STAT_DMA_PORTS_HIr_BITMAPf_SET(r,f) (r).cmic_stat_dma_ports_hi[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_STAT_DMA_PORTS_HI.
 *
 */
#define BCM56218_A0_READ_CMIC_STAT_DMA_PORTS_HIr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_STAT_DMA_PORTS_HIr,r._cmic_stat_dma_ports_hi)
#define BCM56218_A0_WRITE_CMIC_STAT_DMA_PORTS_HIr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_STAT_DMA_PORTS_HIr,r._cmic_stat_dma_ports_hi)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_PORTS_HIr BCM56218_A0_CMIC_STAT_DMA_PORTS_HIr
#define CMIC_STAT_DMA_PORTS_HIr_SIZE BCM56218_A0_CMIC_STAT_DMA_PORTS_HIr_SIZE
typedef BCM56218_A0_CMIC_STAT_DMA_PORTS_HIr_t CMIC_STAT_DMA_PORTS_HIr_t;
#define CMIC_STAT_DMA_PORTS_HIr_CLR BCM56218_A0_CMIC_STAT_DMA_PORTS_HIr_CLR
#define CMIC_STAT_DMA_PORTS_HIr_SET BCM56218_A0_CMIC_STAT_DMA_PORTS_HIr_SET
#define CMIC_STAT_DMA_PORTS_HIr_GET BCM56218_A0_CMIC_STAT_DMA_PORTS_HIr_GET
#define CMIC_STAT_DMA_PORTS_HIr_BITMAPf_GET BCM56218_A0_CMIC_STAT_DMA_PORTS_HIr_BITMAPf_GET
#define CMIC_STAT_DMA_PORTS_HIr_BITMAPf_SET BCM56218_A0_CMIC_STAT_DMA_PORTS_HIr_BITMAPf_SET
#define READ_CMIC_STAT_DMA_PORTS_HIr BCM56218_A0_READ_CMIC_STAT_DMA_PORTS_HIr
#define WRITE_CMIC_STAT_DMA_PORTS_HIr BCM56218_A0_WRITE_CMIC_STAT_DMA_PORTS_HIr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_STAT_DMA_PORTS_HIr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_STAT_DMA_PORT_TYPE_MAP
 * BLOCKS:   CMIC
 * DESC:     Port type bitmap for Stat DMA: 0=Gig port, 1=Higig port
Note: The bitmap is index by port number.

 * SIZE:     32
 * FIELDS:
 *     BITMAP           0 bits are   Gig ports, so get MAC_G_STAT_COUNTERS_NUM counters1 bits are Higig ports, so get MAC_X_STAT_COUNTERS_NUM counters
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr 0x0000046c

#define BCM56218_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_PORT_TYPE_MAP.
 *
 */
typedef union BCM56218_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_port_type_map[1];
	uint32_t _cmic_stat_dma_port_type_map;
} BCM56218_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr_t;

#define BCM56218_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr_CLR(r) (r).cmic_stat_dma_port_type_map[0] = 0
#define BCM56218_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr_SET(r,d) (r).cmic_stat_dma_port_type_map[0] = d
#define BCM56218_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr_GET(r) (r).cmic_stat_dma_port_type_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr_BITMAPf_GET(r) ((r).cmic_stat_dma_port_type_map[0])
#define BCM56218_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr_BITMAPf_SET(r,f) (r).cmic_stat_dma_port_type_map[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_STAT_DMA_PORT_TYPE_MAP.
 *
 */
#define BCM56218_A0_READ_CMIC_STAT_DMA_PORT_TYPE_MAPr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr,r._cmic_stat_dma_port_type_map)
#define BCM56218_A0_WRITE_CMIC_STAT_DMA_PORT_TYPE_MAPr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr,r._cmic_stat_dma_port_type_map)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_PORT_TYPE_MAPr BCM56218_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr
#define CMIC_STAT_DMA_PORT_TYPE_MAPr_SIZE BCM56218_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr_SIZE
typedef BCM56218_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr_t CMIC_STAT_DMA_PORT_TYPE_MAPr_t;
#define CMIC_STAT_DMA_PORT_TYPE_MAPr_CLR BCM56218_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr_CLR
#define CMIC_STAT_DMA_PORT_TYPE_MAPr_SET BCM56218_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr_SET
#define CMIC_STAT_DMA_PORT_TYPE_MAPr_GET BCM56218_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr_GET
#define CMIC_STAT_DMA_PORT_TYPE_MAPr_BITMAPf_GET BCM56218_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr_BITMAPf_GET
#define CMIC_STAT_DMA_PORT_TYPE_MAPr_BITMAPf_SET BCM56218_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr_BITMAPf_SET
#define READ_CMIC_STAT_DMA_PORT_TYPE_MAPr BCM56218_A0_READ_CMIC_STAT_DMA_PORT_TYPE_MAPr
#define WRITE_CMIC_STAT_DMA_PORT_TYPE_MAPr BCM56218_A0_WRITE_CMIC_STAT_DMA_PORT_TYPE_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_STAT_DMA_PORT_TYPE_MAP_HI
 * BLOCKS:   CMIC
 * DESC:     Port type bitmap for Stat DMA: 0=Gig port, 1=Higig port
Note: The bitmap is index by port number. (upper 32-bits)

 * SIZE:     32
 * FIELDS:
 *     BITMAP           0 bits are   Gig ports, so get MAC_G_STAT_COUNTERS_NUM counters1 bits are Higig ports, so get MAC_X_STAT_COUNTERS_NUM counters
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_STAT_DMA_PORT_TYPE_MAP_HIr 0x00000784

#define BCM56218_A0_CMIC_STAT_DMA_PORT_TYPE_MAP_HIr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_PORT_TYPE_MAP_HI.
 *
 */
typedef union BCM56218_A0_CMIC_STAT_DMA_PORT_TYPE_MAP_HIr_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_port_type_map_hi[1];
	uint32_t _cmic_stat_dma_port_type_map_hi;
} BCM56218_A0_CMIC_STAT_DMA_PORT_TYPE_MAP_HIr_t;

#define BCM56218_A0_CMIC_STAT_DMA_PORT_TYPE_MAP_HIr_CLR(r) (r).cmic_stat_dma_port_type_map_hi[0] = 0
#define BCM56218_A0_CMIC_STAT_DMA_PORT_TYPE_MAP_HIr_SET(r,d) (r).cmic_stat_dma_port_type_map_hi[0] = d
#define BCM56218_A0_CMIC_STAT_DMA_PORT_TYPE_MAP_HIr_GET(r) (r).cmic_stat_dma_port_type_map_hi[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_STAT_DMA_PORT_TYPE_MAP_HIr_BITMAPf_GET(r) ((r).cmic_stat_dma_port_type_map_hi[0])
#define BCM56218_A0_CMIC_STAT_DMA_PORT_TYPE_MAP_HIr_BITMAPf_SET(r,f) (r).cmic_stat_dma_port_type_map_hi[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_STAT_DMA_PORT_TYPE_MAP_HI.
 *
 */
#define BCM56218_A0_READ_CMIC_STAT_DMA_PORT_TYPE_MAP_HIr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_STAT_DMA_PORT_TYPE_MAP_HIr,r._cmic_stat_dma_port_type_map_hi)
#define BCM56218_A0_WRITE_CMIC_STAT_DMA_PORT_TYPE_MAP_HIr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_STAT_DMA_PORT_TYPE_MAP_HIr,r._cmic_stat_dma_port_type_map_hi)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_PORT_TYPE_MAP_HIr BCM56218_A0_CMIC_STAT_DMA_PORT_TYPE_MAP_HIr
#define CMIC_STAT_DMA_PORT_TYPE_MAP_HIr_SIZE BCM56218_A0_CMIC_STAT_DMA_PORT_TYPE_MAP_HIr_SIZE
typedef BCM56218_A0_CMIC_STAT_DMA_PORT_TYPE_MAP_HIr_t CMIC_STAT_DMA_PORT_TYPE_MAP_HIr_t;
#define CMIC_STAT_DMA_PORT_TYPE_MAP_HIr_CLR BCM56218_A0_CMIC_STAT_DMA_PORT_TYPE_MAP_HIr_CLR
#define CMIC_STAT_DMA_PORT_TYPE_MAP_HIr_SET BCM56218_A0_CMIC_STAT_DMA_PORT_TYPE_MAP_HIr_SET
#define CMIC_STAT_DMA_PORT_TYPE_MAP_HIr_GET BCM56218_A0_CMIC_STAT_DMA_PORT_TYPE_MAP_HIr_GET
#define CMIC_STAT_DMA_PORT_TYPE_MAP_HIr_BITMAPf_GET BCM56218_A0_CMIC_STAT_DMA_PORT_TYPE_MAP_HIr_BITMAPf_GET
#define CMIC_STAT_DMA_PORT_TYPE_MAP_HIr_BITMAPf_SET BCM56218_A0_CMIC_STAT_DMA_PORT_TYPE_MAP_HIr_BITMAPf_SET
#define READ_CMIC_STAT_DMA_PORT_TYPE_MAP_HIr BCM56218_A0_READ_CMIC_STAT_DMA_PORT_TYPE_MAP_HIr
#define WRITE_CMIC_STAT_DMA_PORT_TYPE_MAP_HIr BCM56218_A0_WRITE_CMIC_STAT_DMA_PORT_TYPE_MAP_HIr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_STAT_DMA_PORT_TYPE_MAP_HIr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_STAT_DMA_SETUP
 * BLOCKS:   CMIC
 * DESC:     Stat Counter DMA Access Setup Register
 * SIZE:     32
 * FIELDS:
 *     RESERVED_1       Reserved
 *     TIME_VAL         Timer Value
 *     E_T              Enable Timer
 *     EN               Enable DMA
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_STAT_DMA_SETUPr 0x00000168

#define BCM56218_A0_CMIC_STAT_DMA_SETUPr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_SETUP.
 *
 */
typedef union BCM56218_A0_CMIC_STAT_DMA_SETUPr_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_setup[1];
	uint32_t _cmic_stat_dma_setup;
} BCM56218_A0_CMIC_STAT_DMA_SETUPr_t;

#define BCM56218_A0_CMIC_STAT_DMA_SETUPr_CLR(r) (r).cmic_stat_dma_setup[0] = 0
#define BCM56218_A0_CMIC_STAT_DMA_SETUPr_SET(r,d) (r).cmic_stat_dma_setup[0] = d
#define BCM56218_A0_CMIC_STAT_DMA_SETUPr_GET(r) (r).cmic_stat_dma_setup[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_STAT_DMA_SETUPr_RESERVED_1f_GET(r) (((r).cmic_stat_dma_setup[0]) & 0xffff)
#define BCM56218_A0_CMIC_STAT_DMA_SETUPr_RESERVED_1f_SET(r,f) (r).cmic_stat_dma_setup[0]=(((r).cmic_stat_dma_setup[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56218_A0_CMIC_STAT_DMA_SETUPr_TIME_VALf_GET(r) ((((r).cmic_stat_dma_setup[0]) >> 16) & 0x3fff)
#define BCM56218_A0_CMIC_STAT_DMA_SETUPr_TIME_VALf_SET(r,f) (r).cmic_stat_dma_setup[0]=(((r).cmic_stat_dma_setup[0] & ~((uint32_t)0x3fff << 16)) | ((((uint32_t)f) & 0x3fff) << 16))
#define BCM56218_A0_CMIC_STAT_DMA_SETUPr_E_Tf_GET(r) ((((r).cmic_stat_dma_setup[0]) >> 30) & 0x1)
#define BCM56218_A0_CMIC_STAT_DMA_SETUPr_E_Tf_SET(r,f) (r).cmic_stat_dma_setup[0]=(((r).cmic_stat_dma_setup[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM56218_A0_CMIC_STAT_DMA_SETUPr_ENf_GET(r) ((((r).cmic_stat_dma_setup[0]) >> 31) & 0x1)
#define BCM56218_A0_CMIC_STAT_DMA_SETUPr_ENf_SET(r,f) (r).cmic_stat_dma_setup[0]=(((r).cmic_stat_dma_setup[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access CMIC_STAT_DMA_SETUP.
 *
 */
#define BCM56218_A0_READ_CMIC_STAT_DMA_SETUPr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_STAT_DMA_SETUPr,r._cmic_stat_dma_setup)
#define BCM56218_A0_WRITE_CMIC_STAT_DMA_SETUPr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_STAT_DMA_SETUPr,r._cmic_stat_dma_setup)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_SETUPr BCM56218_A0_CMIC_STAT_DMA_SETUPr
#define CMIC_STAT_DMA_SETUPr_SIZE BCM56218_A0_CMIC_STAT_DMA_SETUPr_SIZE
typedef BCM56218_A0_CMIC_STAT_DMA_SETUPr_t CMIC_STAT_DMA_SETUPr_t;
#define CMIC_STAT_DMA_SETUPr_CLR BCM56218_A0_CMIC_STAT_DMA_SETUPr_CLR
#define CMIC_STAT_DMA_SETUPr_SET BCM56218_A0_CMIC_STAT_DMA_SETUPr_SET
#define CMIC_STAT_DMA_SETUPr_GET BCM56218_A0_CMIC_STAT_DMA_SETUPr_GET
#define CMIC_STAT_DMA_SETUPr_RESERVED_1f_GET BCM56218_A0_CMIC_STAT_DMA_SETUPr_RESERVED_1f_GET
#define CMIC_STAT_DMA_SETUPr_RESERVED_1f_SET BCM56218_A0_CMIC_STAT_DMA_SETUPr_RESERVED_1f_SET
#define CMIC_STAT_DMA_SETUPr_TIME_VALf_GET BCM56218_A0_CMIC_STAT_DMA_SETUPr_TIME_VALf_GET
#define CMIC_STAT_DMA_SETUPr_TIME_VALf_SET BCM56218_A0_CMIC_STAT_DMA_SETUPr_TIME_VALf_SET
#define CMIC_STAT_DMA_SETUPr_E_Tf_GET BCM56218_A0_CMIC_STAT_DMA_SETUPr_E_Tf_GET
#define CMIC_STAT_DMA_SETUPr_E_Tf_SET BCM56218_A0_CMIC_STAT_DMA_SETUPr_E_Tf_SET
#define CMIC_STAT_DMA_SETUPr_ENf_GET BCM56218_A0_CMIC_STAT_DMA_SETUPr_ENf_GET
#define CMIC_STAT_DMA_SETUPr_ENf_SET BCM56218_A0_CMIC_STAT_DMA_SETUPr_ENf_SET
#define READ_CMIC_STAT_DMA_SETUPr BCM56218_A0_READ_CMIC_STAT_DMA_SETUPr
#define WRITE_CMIC_STAT_DMA_SETUPr BCM56218_A0_WRITE_CMIC_STAT_DMA_SETUPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_STAT_DMA_SETUPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_STRAP_OPTIONS
 * BLOCKS:   CMIC
 * DESC:     Strap option bits as descripbed below:
0 -  strap_mips_big_endian
1 -  strap_memc_iotype
2 -  strap_mips_async_clk_ctrl
3 -  strap_mips_enable_clk_ratio
[5:4] -  strap_mips_clk_ratio [1:0]
6 - strap_mips_pll_bypass
7 - strap_mips_pll_pwrdn
8 - strap_flash_8bit_mode
9 - strap_ics_endian_compat/strap_pci_eb_sel
10 - strap_ics_disable
11 - strap_rvmii_mode_in
12 - strap_i2c_mode_in
13 - s3mii_mode_sel_in

 * SIZE:     32
 * FIELDS:
 *     STRAP_OPTIONS    Chip strap options.
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_STRAP_OPTIONSr 0x00000188

#define BCM56218_A0_CMIC_STRAP_OPTIONSr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STRAP_OPTIONS.
 *
 */
typedef union BCM56218_A0_CMIC_STRAP_OPTIONSr_s {
	uint32_t v[1];
	uint32_t cmic_strap_options[1];
	uint32_t _cmic_strap_options;
} BCM56218_A0_CMIC_STRAP_OPTIONSr_t;

#define BCM56218_A0_CMIC_STRAP_OPTIONSr_CLR(r) (r).cmic_strap_options[0] = 0
#define BCM56218_A0_CMIC_STRAP_OPTIONSr_SET(r,d) (r).cmic_strap_options[0] = d
#define BCM56218_A0_CMIC_STRAP_OPTIONSr_GET(r) (r).cmic_strap_options[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_STRAP_OPTIONSr_STRAP_OPTIONSf_GET(r) (((r).cmic_strap_options[0]) & 0x3fff)
#define BCM56218_A0_CMIC_STRAP_OPTIONSr_STRAP_OPTIONSf_SET(r,f) (r).cmic_strap_options[0]=(((r).cmic_strap_options[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM56218_A0_CMIC_STRAP_OPTIONSr_RESERVED_1f_GET(r) ((((r).cmic_strap_options[0]) >> 14) & 0x3)
#define BCM56218_A0_CMIC_STRAP_OPTIONSr_RESERVED_1f_SET(r,f) (r).cmic_strap_options[0]=(((r).cmic_strap_options[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))

/*
 * These macros can be used to access CMIC_STRAP_OPTIONS.
 *
 */
#define BCM56218_A0_READ_CMIC_STRAP_OPTIONSr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_STRAP_OPTIONSr,r._cmic_strap_options)
#define BCM56218_A0_WRITE_CMIC_STRAP_OPTIONSr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_STRAP_OPTIONSr,r._cmic_strap_options)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STRAP_OPTIONSr BCM56218_A0_CMIC_STRAP_OPTIONSr
#define CMIC_STRAP_OPTIONSr_SIZE BCM56218_A0_CMIC_STRAP_OPTIONSr_SIZE
typedef BCM56218_A0_CMIC_STRAP_OPTIONSr_t CMIC_STRAP_OPTIONSr_t;
#define CMIC_STRAP_OPTIONSr_CLR BCM56218_A0_CMIC_STRAP_OPTIONSr_CLR
#define CMIC_STRAP_OPTIONSr_SET BCM56218_A0_CMIC_STRAP_OPTIONSr_SET
#define CMIC_STRAP_OPTIONSr_GET BCM56218_A0_CMIC_STRAP_OPTIONSr_GET
#define CMIC_STRAP_OPTIONSr_STRAP_OPTIONSf_GET BCM56218_A0_CMIC_STRAP_OPTIONSr_STRAP_OPTIONSf_GET
#define CMIC_STRAP_OPTIONSr_STRAP_OPTIONSf_SET BCM56218_A0_CMIC_STRAP_OPTIONSr_STRAP_OPTIONSf_SET
#define CMIC_STRAP_OPTIONSr_RESERVED_1f_GET BCM56218_A0_CMIC_STRAP_OPTIONSr_RESERVED_1f_GET
#define CMIC_STRAP_OPTIONSr_RESERVED_1f_SET BCM56218_A0_CMIC_STRAP_OPTIONSr_RESERVED_1f_SET
#define READ_CMIC_STRAP_OPTIONSr BCM56218_A0_READ_CMIC_STRAP_OPTIONSr
#define WRITE_CMIC_STRAP_OPTIONSr BCM56218_A0_WRITE_CMIC_STRAP_OPTIONSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_STRAP_OPTIONSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_SWITCH_FEATURE_ENABLE
 * BLOCKS:   CMIC
 * DESC:     Bond feature enable
 * SIZE:     32
 * FIELDS:
 *     BOND_FEATURE_EN  Bond options for feature enable
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_SWITCH_FEATURE_ENABLEr 0x0000017c

#define BCM56218_A0_CMIC_SWITCH_FEATURE_ENABLEr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SWITCH_FEATURE_ENABLE.
 *
 */
typedef union BCM56218_A0_CMIC_SWITCH_FEATURE_ENABLEr_s {
	uint32_t v[1];
	uint32_t cmic_switch_feature_enable[1];
	uint32_t _cmic_switch_feature_enable;
} BCM56218_A0_CMIC_SWITCH_FEATURE_ENABLEr_t;

#define BCM56218_A0_CMIC_SWITCH_FEATURE_ENABLEr_CLR(r) (r).cmic_switch_feature_enable[0] = 0
#define BCM56218_A0_CMIC_SWITCH_FEATURE_ENABLEr_SET(r,d) (r).cmic_switch_feature_enable[0] = d
#define BCM56218_A0_CMIC_SWITCH_FEATURE_ENABLEr_GET(r) (r).cmic_switch_feature_enable[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_SWITCH_FEATURE_ENABLEr_BOND_FEATURE_ENf_GET(r) (((r).cmic_switch_feature_enable[0]) & 0xff)
#define BCM56218_A0_CMIC_SWITCH_FEATURE_ENABLEr_BOND_FEATURE_ENf_SET(r,f) (r).cmic_switch_feature_enable[0]=(((r).cmic_switch_feature_enable[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56218_A0_CMIC_SWITCH_FEATURE_ENABLEr_RESERVEDf_GET(r) ((((r).cmic_switch_feature_enable[0]) >> 8) & 0xffffff)
#define BCM56218_A0_CMIC_SWITCH_FEATURE_ENABLEr_RESERVEDf_SET(r,f) (r).cmic_switch_feature_enable[0]=(((r).cmic_switch_feature_enable[0] & ~((uint32_t)0xffffff << 8)) | ((((uint32_t)f) & 0xffffff) << 8))

/*
 * These macros can be used to access CMIC_SWITCH_FEATURE_ENABLE.
 *
 */
#define BCM56218_A0_READ_CMIC_SWITCH_FEATURE_ENABLEr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_SWITCH_FEATURE_ENABLEr,r._cmic_switch_feature_enable)
#define BCM56218_A0_WRITE_CMIC_SWITCH_FEATURE_ENABLEr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_SWITCH_FEATURE_ENABLEr,r._cmic_switch_feature_enable)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_SWITCH_FEATURE_ENABLEr BCM56218_A0_CMIC_SWITCH_FEATURE_ENABLEr
#define CMIC_SWITCH_FEATURE_ENABLEr_SIZE BCM56218_A0_CMIC_SWITCH_FEATURE_ENABLEr_SIZE
typedef BCM56218_A0_CMIC_SWITCH_FEATURE_ENABLEr_t CMIC_SWITCH_FEATURE_ENABLEr_t;
#define CMIC_SWITCH_FEATURE_ENABLEr_CLR BCM56218_A0_CMIC_SWITCH_FEATURE_ENABLEr_CLR
#define CMIC_SWITCH_FEATURE_ENABLEr_SET BCM56218_A0_CMIC_SWITCH_FEATURE_ENABLEr_SET
#define CMIC_SWITCH_FEATURE_ENABLEr_GET BCM56218_A0_CMIC_SWITCH_FEATURE_ENABLEr_GET
#define CMIC_SWITCH_FEATURE_ENABLEr_BOND_FEATURE_ENf_GET BCM56218_A0_CMIC_SWITCH_FEATURE_ENABLEr_BOND_FEATURE_ENf_GET
#define CMIC_SWITCH_FEATURE_ENABLEr_BOND_FEATURE_ENf_SET BCM56218_A0_CMIC_SWITCH_FEATURE_ENABLEr_BOND_FEATURE_ENf_SET
#define CMIC_SWITCH_FEATURE_ENABLEr_RESERVEDf_GET BCM56218_A0_CMIC_SWITCH_FEATURE_ENABLEr_RESERVEDf_GET
#define CMIC_SWITCH_FEATURE_ENABLEr_RESERVEDf_SET BCM56218_A0_CMIC_SWITCH_FEATURE_ENABLEr_RESERVEDf_SET
#define READ_CMIC_SWITCH_FEATURE_ENABLEr BCM56218_A0_READ_CMIC_SWITCH_FEATURE_ENABLEr
#define WRITE_CMIC_SWITCH_FEATURE_ENABLEr BCM56218_A0_WRITE_CMIC_SWITCH_FEATURE_ENABLEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_SWITCH_FEATURE_ENABLEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_SW_PIO_ACK_DATA_BEAT_COUNT
 * BLOCKS:   CMIC
 * DESC:     Debug register that provides the number of data
beats in the last SW PIO S-bus ACK

 * SIZE:     32
 * FIELDS:
 *     BEAT_COUNT       Beat count
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr 0x00000404

#define BCM56218_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SW_PIO_ACK_DATA_BEAT_COUNT.
 *
 */
typedef union BCM56218_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_s {
	uint32_t v[1];
	uint32_t cmic_sw_pio_ack_data_beat_count[1];
	uint32_t _cmic_sw_pio_ack_data_beat_count;
} BCM56218_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_t;

#define BCM56218_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_CLR(r) (r).cmic_sw_pio_ack_data_beat_count[0] = 0
#define BCM56218_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_SET(r,d) (r).cmic_sw_pio_ack_data_beat_count[0] = d
#define BCM56218_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_GET(r) (r).cmic_sw_pio_ack_data_beat_count[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_BEAT_COUNTf_GET(r) (((r).cmic_sw_pio_ack_data_beat_count[0]) & 0x1f)
#define BCM56218_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_BEAT_COUNTf_SET(r,f) (r).cmic_sw_pio_ack_data_beat_count[0]=(((r).cmic_sw_pio_ack_data_beat_count[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56218_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_RESERVED_0f_GET(r) ((((r).cmic_sw_pio_ack_data_beat_count[0]) >> 5) & 0x7ffffff)
#define BCM56218_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_RESERVED_0f_SET(r,f) (r).cmic_sw_pio_ack_data_beat_count[0]=(((r).cmic_sw_pio_ack_data_beat_count[0] & ~((uint32_t)0x7ffffff << 5)) | ((((uint32_t)f) & 0x7ffffff) << 5))

/*
 * These macros can be used to access CMIC_SW_PIO_ACK_DATA_BEAT_COUNT.
 *
 */
#define BCM56218_A0_READ_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr,r._cmic_sw_pio_ack_data_beat_count)
#define BCM56218_A0_WRITE_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr,r._cmic_sw_pio_ack_data_beat_count)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr BCM56218_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr
#define CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_SIZE BCM56218_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_SIZE
typedef BCM56218_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_t CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_t;
#define CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_CLR BCM56218_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_CLR
#define CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_SET BCM56218_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_SET
#define CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_GET BCM56218_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_GET
#define CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_BEAT_COUNTf_GET BCM56218_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_BEAT_COUNTf_GET
#define CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_BEAT_COUNTf_SET BCM56218_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_BEAT_COUNTf_SET
#define CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_RESERVED_0f_GET BCM56218_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_RESERVED_0f_GET
#define CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_RESERVED_0f_SET BCM56218_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_RESERVED_0f_SET
#define READ_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr BCM56218_A0_READ_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr
#define WRITE_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr BCM56218_A0_WRITE_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_TABLE_DMA_CFG
 * BLOCKS:   CMIC
 * DESC:     Table DMA Config Register
 * SIZE:     32
 * FIELDS:
 *     EN               Set by CPU to Enable Table DMA Transfer
 *     ABORT            Set by CPU to Abort Table DMA Transfer
 *     DONE             Set by CMIC to indicate Table DMA Transfer Completion.Can be cleared (but not set) by CPU.
 *     ERROR            Set by CMIC to indicate Table DMA Transfer wasaborted due to an error (most probably due to a NACK).Can be cleared (but not set) by CPU.
 *     RESERVED_1       Reserved
 *     BEATS            Written by CPU indicating number of data beats.For Table DMA purposes, each table entry is 32-bit aligned.The widest S-bus table wr/rd supported is 640 bits.So, the valid values for this field are 1-20 (beats).
 *     RESERVED_2       Reserved
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_TABLE_DMA_CFGr 0x0000042c

#define BCM56218_A0_CMIC_TABLE_DMA_CFGr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_TABLE_DMA_CFG.
 *
 */
typedef union BCM56218_A0_CMIC_TABLE_DMA_CFGr_s {
	uint32_t v[1];
	uint32_t cmic_table_dma_cfg[1];
	uint32_t _cmic_table_dma_cfg;
} BCM56218_A0_CMIC_TABLE_DMA_CFGr_t;

#define BCM56218_A0_CMIC_TABLE_DMA_CFGr_CLR(r) (r).cmic_table_dma_cfg[0] = 0
#define BCM56218_A0_CMIC_TABLE_DMA_CFGr_SET(r,d) (r).cmic_table_dma_cfg[0] = d
#define BCM56218_A0_CMIC_TABLE_DMA_CFGr_GET(r) (r).cmic_table_dma_cfg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_TABLE_DMA_CFGr_ENf_GET(r) (((r).cmic_table_dma_cfg[0]) & 0x1)
#define BCM56218_A0_CMIC_TABLE_DMA_CFGr_ENf_SET(r,f) (r).cmic_table_dma_cfg[0]=(((r).cmic_table_dma_cfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_CMIC_TABLE_DMA_CFGr_ABORTf_GET(r) ((((r).cmic_table_dma_cfg[0]) >> 1) & 0x1)
#define BCM56218_A0_CMIC_TABLE_DMA_CFGr_ABORTf_SET(r,f) (r).cmic_table_dma_cfg[0]=(((r).cmic_table_dma_cfg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_CMIC_TABLE_DMA_CFGr_DONEf_GET(r) ((((r).cmic_table_dma_cfg[0]) >> 2) & 0x1)
#define BCM56218_A0_CMIC_TABLE_DMA_CFGr_DONEf_SET(r,f) (r).cmic_table_dma_cfg[0]=(((r).cmic_table_dma_cfg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_CMIC_TABLE_DMA_CFGr_ERRORf_GET(r) ((((r).cmic_table_dma_cfg[0]) >> 3) & 0x1)
#define BCM56218_A0_CMIC_TABLE_DMA_CFGr_ERRORf_SET(r,f) (r).cmic_table_dma_cfg[0]=(((r).cmic_table_dma_cfg[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56218_A0_CMIC_TABLE_DMA_CFGr_RESERVED_1f_GET(r) ((((r).cmic_table_dma_cfg[0]) >> 4) & 0xfff)
#define BCM56218_A0_CMIC_TABLE_DMA_CFGr_RESERVED_1f_SET(r,f) (r).cmic_table_dma_cfg[0]=(((r).cmic_table_dma_cfg[0] & ~((uint32_t)0xfff << 4)) | ((((uint32_t)f) & 0xfff) << 4))
#define BCM56218_A0_CMIC_TABLE_DMA_CFGr_BEATSf_GET(r) ((((r).cmic_table_dma_cfg[0]) >> 16) & 0x1f)
#define BCM56218_A0_CMIC_TABLE_DMA_CFGr_BEATSf_SET(r,f) (r).cmic_table_dma_cfg[0]=(((r).cmic_table_dma_cfg[0] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define BCM56218_A0_CMIC_TABLE_DMA_CFGr_RESERVED_2f_GET(r) ((((r).cmic_table_dma_cfg[0]) >> 21) & 0x7ff)
#define BCM56218_A0_CMIC_TABLE_DMA_CFGr_RESERVED_2f_SET(r,f) (r).cmic_table_dma_cfg[0]=(((r).cmic_table_dma_cfg[0] & ~((uint32_t)0x7ff << 21)) | ((((uint32_t)f) & 0x7ff) << 21))

/*
 * These macros can be used to access CMIC_TABLE_DMA_CFG.
 *
 */
#define BCM56218_A0_READ_CMIC_TABLE_DMA_CFGr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_TABLE_DMA_CFGr,r._cmic_table_dma_cfg)
#define BCM56218_A0_WRITE_CMIC_TABLE_DMA_CFGr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_TABLE_DMA_CFGr,r._cmic_table_dma_cfg)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_TABLE_DMA_CFGr BCM56218_A0_CMIC_TABLE_DMA_CFGr
#define CMIC_TABLE_DMA_CFGr_SIZE BCM56218_A0_CMIC_TABLE_DMA_CFGr_SIZE
typedef BCM56218_A0_CMIC_TABLE_DMA_CFGr_t CMIC_TABLE_DMA_CFGr_t;
#define CMIC_TABLE_DMA_CFGr_CLR BCM56218_A0_CMIC_TABLE_DMA_CFGr_CLR
#define CMIC_TABLE_DMA_CFGr_SET BCM56218_A0_CMIC_TABLE_DMA_CFGr_SET
#define CMIC_TABLE_DMA_CFGr_GET BCM56218_A0_CMIC_TABLE_DMA_CFGr_GET
#define CMIC_TABLE_DMA_CFGr_ENf_GET BCM56218_A0_CMIC_TABLE_DMA_CFGr_ENf_GET
#define CMIC_TABLE_DMA_CFGr_ENf_SET BCM56218_A0_CMIC_TABLE_DMA_CFGr_ENf_SET
#define CMIC_TABLE_DMA_CFGr_ABORTf_GET BCM56218_A0_CMIC_TABLE_DMA_CFGr_ABORTf_GET
#define CMIC_TABLE_DMA_CFGr_ABORTf_SET BCM56218_A0_CMIC_TABLE_DMA_CFGr_ABORTf_SET
#define CMIC_TABLE_DMA_CFGr_DONEf_GET BCM56218_A0_CMIC_TABLE_DMA_CFGr_DONEf_GET
#define CMIC_TABLE_DMA_CFGr_DONEf_SET BCM56218_A0_CMIC_TABLE_DMA_CFGr_DONEf_SET
#define CMIC_TABLE_DMA_CFGr_ERRORf_GET BCM56218_A0_CMIC_TABLE_DMA_CFGr_ERRORf_GET
#define CMIC_TABLE_DMA_CFGr_ERRORf_SET BCM56218_A0_CMIC_TABLE_DMA_CFGr_ERRORf_SET
#define CMIC_TABLE_DMA_CFGr_RESERVED_1f_GET BCM56218_A0_CMIC_TABLE_DMA_CFGr_RESERVED_1f_GET
#define CMIC_TABLE_DMA_CFGr_RESERVED_1f_SET BCM56218_A0_CMIC_TABLE_DMA_CFGr_RESERVED_1f_SET
#define CMIC_TABLE_DMA_CFGr_BEATSf_GET BCM56218_A0_CMIC_TABLE_DMA_CFGr_BEATSf_GET
#define CMIC_TABLE_DMA_CFGr_BEATSf_SET BCM56218_A0_CMIC_TABLE_DMA_CFGr_BEATSf_SET
#define CMIC_TABLE_DMA_CFGr_RESERVED_2f_GET BCM56218_A0_CMIC_TABLE_DMA_CFGr_RESERVED_2f_GET
#define CMIC_TABLE_DMA_CFGr_RESERVED_2f_SET BCM56218_A0_CMIC_TABLE_DMA_CFGr_RESERVED_2f_SET
#define READ_CMIC_TABLE_DMA_CFGr BCM56218_A0_READ_CMIC_TABLE_DMA_CFGr
#define WRITE_CMIC_TABLE_DMA_CFGr BCM56218_A0_WRITE_CMIC_TABLE_DMA_CFGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_TABLE_DMA_CFGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDR
 * BLOCKS:   CMIC
 * DESC:     Table DMA Current Entry S-bus Address Register
 * SIZE:     32
 * FIELDS:
 *     ADDR             Written by CMIC indicating S-bus address of the Table Entrycurrently being processed
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr 0x00000434

#define BCM56218_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDR.
 *
 */
typedef union BCM56218_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_s {
	uint32_t v[1];
	uint32_t cmic_table_dma_cur_entry_sbus_addr[1];
	uint32_t _cmic_table_dma_cur_entry_sbus_addr;
} BCM56218_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_t;

#define BCM56218_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_CLR(r) (r).cmic_table_dma_cur_entry_sbus_addr[0] = 0
#define BCM56218_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_SET(r,d) (r).cmic_table_dma_cur_entry_sbus_addr[0] = d
#define BCM56218_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_GET(r) (r).cmic_table_dma_cur_entry_sbus_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_ADDRf_GET(r) ((r).cmic_table_dma_cur_entry_sbus_addr[0])
#define BCM56218_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_ADDRf_SET(r,f) (r).cmic_table_dma_cur_entry_sbus_addr[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDR.
 *
 */
#define BCM56218_A0_READ_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr,r._cmic_table_dma_cur_entry_sbus_addr)
#define BCM56218_A0_WRITE_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr,r._cmic_table_dma_cur_entry_sbus_addr)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr BCM56218_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr
#define CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_SIZE BCM56218_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_SIZE
typedef BCM56218_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_t CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_t;
#define CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_CLR BCM56218_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_CLR
#define CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_SET BCM56218_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_SET
#define CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_GET BCM56218_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_GET
#define CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_ADDRf_GET BCM56218_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_ADDRf_GET
#define CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_ADDRf_SET BCM56218_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_ADDRf_SET
#define READ_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr BCM56218_A0_READ_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr
#define WRITE_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr BCM56218_A0_WRITE_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_TABLE_DMA_ENTRY_COUNT
 * BLOCKS:   CMIC
 * DESC:     Table DMA Entry Count Register
 * SIZE:     32
 * FIELDS:
 *     COUNT            Written by CPU indicating number of Table entries for Table DMA.
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_TABLE_DMA_ENTRY_COUNTr 0x00000428

#define BCM56218_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_TABLE_DMA_ENTRY_COUNT.
 *
 */
typedef union BCM56218_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_s {
	uint32_t v[1];
	uint32_t cmic_table_dma_entry_count[1];
	uint32_t _cmic_table_dma_entry_count;
} BCM56218_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_t;

#define BCM56218_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_CLR(r) (r).cmic_table_dma_entry_count[0] = 0
#define BCM56218_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_SET(r,d) (r).cmic_table_dma_entry_count[0] = d
#define BCM56218_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_GET(r) (r).cmic_table_dma_entry_count[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_COUNTf_GET(r) (((r).cmic_table_dma_entry_count[0]) & 0xffffff)
#define BCM56218_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_COUNTf_SET(r,f) (r).cmic_table_dma_entry_count[0]=(((r).cmic_table_dma_entry_count[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))
#define BCM56218_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_RESERVED_1f_GET(r) ((((r).cmic_table_dma_entry_count[0]) >> 24) & 0xff)
#define BCM56218_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_RESERVED_1f_SET(r,f) (r).cmic_table_dma_entry_count[0]=(((r).cmic_table_dma_entry_count[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access CMIC_TABLE_DMA_ENTRY_COUNT.
 *
 */
#define BCM56218_A0_READ_CMIC_TABLE_DMA_ENTRY_COUNTr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_TABLE_DMA_ENTRY_COUNTr,r._cmic_table_dma_entry_count)
#define BCM56218_A0_WRITE_CMIC_TABLE_DMA_ENTRY_COUNTr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_TABLE_DMA_ENTRY_COUNTr,r._cmic_table_dma_entry_count)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_TABLE_DMA_ENTRY_COUNTr BCM56218_A0_CMIC_TABLE_DMA_ENTRY_COUNTr
#define CMIC_TABLE_DMA_ENTRY_COUNTr_SIZE BCM56218_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_SIZE
typedef BCM56218_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_t CMIC_TABLE_DMA_ENTRY_COUNTr_t;
#define CMIC_TABLE_DMA_ENTRY_COUNTr_CLR BCM56218_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_CLR
#define CMIC_TABLE_DMA_ENTRY_COUNTr_SET BCM56218_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_SET
#define CMIC_TABLE_DMA_ENTRY_COUNTr_GET BCM56218_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_GET
#define CMIC_TABLE_DMA_ENTRY_COUNTr_COUNTf_GET BCM56218_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_COUNTf_GET
#define CMIC_TABLE_DMA_ENTRY_COUNTr_COUNTf_SET BCM56218_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_COUNTf_SET
#define CMIC_TABLE_DMA_ENTRY_COUNTr_RESERVED_1f_GET BCM56218_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_RESERVED_1f_GET
#define CMIC_TABLE_DMA_ENTRY_COUNTr_RESERVED_1f_SET BCM56218_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_RESERVED_1f_SET
#define READ_CMIC_TABLE_DMA_ENTRY_COUNTr BCM56218_A0_READ_CMIC_TABLE_DMA_ENTRY_COUNTr
#define WRITE_CMIC_TABLE_DMA_ENTRY_COUNTr BCM56218_A0_WRITE_CMIC_TABLE_DMA_ENTRY_COUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_TABLE_DMA_ENTRY_COUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_TABLE_DMA_PCIMEM_START_ADDR
 * BLOCKS:   CMIC
 * DESC:     Table DMA PCI Memory Start Address Register

 * SIZE:     32
 * FIELDS:
 *     ADDR             Written by CPU indicating Table DMA Physical (PCI) Memory Start Address
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr 0x00000420

#define BCM56218_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_TABLE_DMA_PCIMEM_START_ADDR.
 *
 */
typedef union BCM56218_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr_s {
	uint32_t v[1];
	uint32_t cmic_table_dma_pcimem_start_addr[1];
	uint32_t _cmic_table_dma_pcimem_start_addr;
} BCM56218_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr_t;

#define BCM56218_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr_CLR(r) (r).cmic_table_dma_pcimem_start_addr[0] = 0
#define BCM56218_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr_SET(r,d) (r).cmic_table_dma_pcimem_start_addr[0] = d
#define BCM56218_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr_GET(r) (r).cmic_table_dma_pcimem_start_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr_ADDRf_GET(r) ((r).cmic_table_dma_pcimem_start_addr[0])
#define BCM56218_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr_ADDRf_SET(r,f) (r).cmic_table_dma_pcimem_start_addr[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_TABLE_DMA_PCIMEM_START_ADDR.
 *
 */
#define BCM56218_A0_READ_CMIC_TABLE_DMA_PCIMEM_START_ADDRr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr,r._cmic_table_dma_pcimem_start_addr)
#define BCM56218_A0_WRITE_CMIC_TABLE_DMA_PCIMEM_START_ADDRr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr,r._cmic_table_dma_pcimem_start_addr)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_TABLE_DMA_PCIMEM_START_ADDRr BCM56218_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr
#define CMIC_TABLE_DMA_PCIMEM_START_ADDRr_SIZE BCM56218_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr_SIZE
typedef BCM56218_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr_t CMIC_TABLE_DMA_PCIMEM_START_ADDRr_t;
#define CMIC_TABLE_DMA_PCIMEM_START_ADDRr_CLR BCM56218_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr_CLR
#define CMIC_TABLE_DMA_PCIMEM_START_ADDRr_SET BCM56218_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr_SET
#define CMIC_TABLE_DMA_PCIMEM_START_ADDRr_GET BCM56218_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr_GET
#define CMIC_TABLE_DMA_PCIMEM_START_ADDRr_ADDRf_GET BCM56218_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr_ADDRf_GET
#define CMIC_TABLE_DMA_PCIMEM_START_ADDRr_ADDRf_SET BCM56218_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr_ADDRf_SET
#define READ_CMIC_TABLE_DMA_PCIMEM_START_ADDRr BCM56218_A0_READ_CMIC_TABLE_DMA_PCIMEM_START_ADDRr
#define WRITE_CMIC_TABLE_DMA_PCIMEM_START_ADDRr BCM56218_A0_WRITE_CMIC_TABLE_DMA_PCIMEM_START_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_TABLE_DMA_SBUS_START_ADDR
 * BLOCKS:   CMIC
 * DESC:     Table DMA S-bus Start Address Register

 * SIZE:     32
 * FIELDS:
 *     ADDR             Written by CPU indicating Table DMA Logical (S-bus) Memory Start Address. This address has the followingfields: table (6b), block (4b) and region+index (20b)
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr 0x00000424

#define BCM56218_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_TABLE_DMA_SBUS_START_ADDR.
 *
 */
typedef union BCM56218_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr_s {
	uint32_t v[1];
	uint32_t cmic_table_dma_sbus_start_addr[1];
	uint32_t _cmic_table_dma_sbus_start_addr;
} BCM56218_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr_t;

#define BCM56218_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr_CLR(r) (r).cmic_table_dma_sbus_start_addr[0] = 0
#define BCM56218_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr_SET(r,d) (r).cmic_table_dma_sbus_start_addr[0] = d
#define BCM56218_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr_GET(r) (r).cmic_table_dma_sbus_start_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr_ADDRf_GET(r) ((r).cmic_table_dma_sbus_start_addr[0])
#define BCM56218_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr_ADDRf_SET(r,f) (r).cmic_table_dma_sbus_start_addr[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_TABLE_DMA_SBUS_START_ADDR.
 *
 */
#define BCM56218_A0_READ_CMIC_TABLE_DMA_SBUS_START_ADDRr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr,r._cmic_table_dma_sbus_start_addr)
#define BCM56218_A0_WRITE_CMIC_TABLE_DMA_SBUS_START_ADDRr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr,r._cmic_table_dma_sbus_start_addr)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_TABLE_DMA_SBUS_START_ADDRr BCM56218_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr
#define CMIC_TABLE_DMA_SBUS_START_ADDRr_SIZE BCM56218_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr_SIZE
typedef BCM56218_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr_t CMIC_TABLE_DMA_SBUS_START_ADDRr_t;
#define CMIC_TABLE_DMA_SBUS_START_ADDRr_CLR BCM56218_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr_CLR
#define CMIC_TABLE_DMA_SBUS_START_ADDRr_SET BCM56218_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr_SET
#define CMIC_TABLE_DMA_SBUS_START_ADDRr_GET BCM56218_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr_GET
#define CMIC_TABLE_DMA_SBUS_START_ADDRr_ADDRf_GET BCM56218_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr_ADDRf_GET
#define CMIC_TABLE_DMA_SBUS_START_ADDRr_ADDRf_SET BCM56218_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr_ADDRf_SET
#define READ_CMIC_TABLE_DMA_SBUS_START_ADDRr BCM56218_A0_READ_CMIC_TABLE_DMA_SBUS_START_ADDRr
#define WRITE_CMIC_TABLE_DMA_SBUS_START_ADDRr BCM56218_A0_WRITE_CMIC_TABLE_DMA_SBUS_START_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_TAP_CONTROL
 * BLOCKS:   CMIC
 * DESC:     Must follow TAP protocol to initiate BIST and read BIST results

 * SIZE:     32
 * FIELDS:
 *     TDI              Tap control data in
 *     TMS              Test mode select
 *     TCK              TAP clock
 *     TRST             TAP reset
 *     TDO              TAP data out
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_TAP_CONTROLr 0x00000194

#define BCM56218_A0_CMIC_TAP_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_TAP_CONTROL.
 *
 */
typedef union BCM56218_A0_CMIC_TAP_CONTROLr_s {
	uint32_t v[1];
	uint32_t cmic_tap_control[1];
	uint32_t _cmic_tap_control;
} BCM56218_A0_CMIC_TAP_CONTROLr_t;

#define BCM56218_A0_CMIC_TAP_CONTROLr_CLR(r) (r).cmic_tap_control[0] = 0
#define BCM56218_A0_CMIC_TAP_CONTROLr_SET(r,d) (r).cmic_tap_control[0] = d
#define BCM56218_A0_CMIC_TAP_CONTROLr_GET(r) (r).cmic_tap_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_TAP_CONTROLr_TDIf_GET(r) (((r).cmic_tap_control[0]) & 0x1)
#define BCM56218_A0_CMIC_TAP_CONTROLr_TDIf_SET(r,f) (r).cmic_tap_control[0]=(((r).cmic_tap_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_CMIC_TAP_CONTROLr_TMSf_GET(r) ((((r).cmic_tap_control[0]) >> 1) & 0x1)
#define BCM56218_A0_CMIC_TAP_CONTROLr_TMSf_SET(r,f) (r).cmic_tap_control[0]=(((r).cmic_tap_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_CMIC_TAP_CONTROLr_TCKf_GET(r) ((((r).cmic_tap_control[0]) >> 2) & 0x1)
#define BCM56218_A0_CMIC_TAP_CONTROLr_TCKf_SET(r,f) (r).cmic_tap_control[0]=(((r).cmic_tap_control[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_CMIC_TAP_CONTROLr_TRSTf_GET(r) ((((r).cmic_tap_control[0]) >> 3) & 0x1)
#define BCM56218_A0_CMIC_TAP_CONTROLr_TRSTf_SET(r,f) (r).cmic_tap_control[0]=(((r).cmic_tap_control[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56218_A0_CMIC_TAP_CONTROLr_TDOf_GET(r) ((((r).cmic_tap_control[0]) >> 4) & 0x1)
#define BCM56218_A0_CMIC_TAP_CONTROLr_TDOf_SET(r,f) (r).cmic_tap_control[0]=(((r).cmic_tap_control[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56218_A0_CMIC_TAP_CONTROLr_RESERVED_1f_GET(r) ((((r).cmic_tap_control[0]) >> 5) & 0x7ffffff)
#define BCM56218_A0_CMIC_TAP_CONTROLr_RESERVED_1f_SET(r,f) (r).cmic_tap_control[0]=(((r).cmic_tap_control[0] & ~((uint32_t)0x7ffffff << 5)) | ((((uint32_t)f) & 0x7ffffff) << 5))

/*
 * These macros can be used to access CMIC_TAP_CONTROL.
 *
 */
#define BCM56218_A0_READ_CMIC_TAP_CONTROLr(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_TAP_CONTROLr,r._cmic_tap_control)
#define BCM56218_A0_WRITE_CMIC_TAP_CONTROLr(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_TAP_CONTROLr,r._cmic_tap_control)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_TAP_CONTROLr BCM56218_A0_CMIC_TAP_CONTROLr
#define CMIC_TAP_CONTROLr_SIZE BCM56218_A0_CMIC_TAP_CONTROLr_SIZE
typedef BCM56218_A0_CMIC_TAP_CONTROLr_t CMIC_TAP_CONTROLr_t;
#define CMIC_TAP_CONTROLr_CLR BCM56218_A0_CMIC_TAP_CONTROLr_CLR
#define CMIC_TAP_CONTROLr_SET BCM56218_A0_CMIC_TAP_CONTROLr_SET
#define CMIC_TAP_CONTROLr_GET BCM56218_A0_CMIC_TAP_CONTROLr_GET
#define CMIC_TAP_CONTROLr_TDIf_GET BCM56218_A0_CMIC_TAP_CONTROLr_TDIf_GET
#define CMIC_TAP_CONTROLr_TDIf_SET BCM56218_A0_CMIC_TAP_CONTROLr_TDIf_SET
#define CMIC_TAP_CONTROLr_TMSf_GET BCM56218_A0_CMIC_TAP_CONTROLr_TMSf_GET
#define CMIC_TAP_CONTROLr_TMSf_SET BCM56218_A0_CMIC_TAP_CONTROLr_TMSf_SET
#define CMIC_TAP_CONTROLr_TCKf_GET BCM56218_A0_CMIC_TAP_CONTROLr_TCKf_GET
#define CMIC_TAP_CONTROLr_TCKf_SET BCM56218_A0_CMIC_TAP_CONTROLr_TCKf_SET
#define CMIC_TAP_CONTROLr_TRSTf_GET BCM56218_A0_CMIC_TAP_CONTROLr_TRSTf_GET
#define CMIC_TAP_CONTROLr_TRSTf_SET BCM56218_A0_CMIC_TAP_CONTROLr_TRSTf_SET
#define CMIC_TAP_CONTROLr_TDOf_GET BCM56218_A0_CMIC_TAP_CONTROLr_TDOf_GET
#define CMIC_TAP_CONTROLr_TDOf_SET BCM56218_A0_CMIC_TAP_CONTROLr_TDOf_SET
#define CMIC_TAP_CONTROLr_RESERVED_1f_GET BCM56218_A0_CMIC_TAP_CONTROLr_RESERVED_1f_GET
#define CMIC_TAP_CONTROLr_RESERVED_1f_SET BCM56218_A0_CMIC_TAP_CONTROLr_RESERVED_1f_SET
#define READ_CMIC_TAP_CONTROLr BCM56218_A0_READ_CMIC_TAP_CONTROLr
#define WRITE_CMIC_TAP_CONTROLr BCM56218_A0_WRITE_CMIC_TAP_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_TAP_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_XGXS_MDIO_CONFIG_0
 * BLOCKS:   CMIC
 * DESC:     CMIC XGXS MDIO Config 0 register
 * SIZE:     32
 * FIELDS:
 *     IEEE_DEVICES_IN_PKG IEEE devices in XGXS package
 *     MD_DEVAD         MDIO Device address
 *     MD_ST            Internal phy clause 45 select bitWhen 0, use clause 22 MIIM (historic)  addressing.When 1, use clause 45 MIIM (new style) addressing.
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_0r 0x00000500

#define BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_0r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_XGXS_MDIO_CONFIG_0.
 *
 */
typedef union BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_0r_s {
	uint32_t v[1];
	uint32_t cmic_xgxs_mdio_config_0[1];
	uint32_t _cmic_xgxs_mdio_config_0;
} BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_0r_t;

#define BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_0r_CLR(r) (r).cmic_xgxs_mdio_config_0[0] = 0
#define BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_0r_SET(r,d) (r).cmic_xgxs_mdio_config_0[0] = d
#define BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_0r_GET(r) (r).cmic_xgxs_mdio_config_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_0r_IEEE_DEVICES_IN_PKGf_GET(r) (((r).cmic_xgxs_mdio_config_0[0]) & 0xff)
#define BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_0r_IEEE_DEVICES_IN_PKGf_SET(r,f) (r).cmic_xgxs_mdio_config_0[0]=(((r).cmic_xgxs_mdio_config_0[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_0r_MD_DEVADf_GET(r) ((((r).cmic_xgxs_mdio_config_0[0]) >> 8) & 0x1f)
#define BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_0r_MD_DEVADf_SET(r,f) (r).cmic_xgxs_mdio_config_0[0]=(((r).cmic_xgxs_mdio_config_0[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_0r_MD_STf_GET(r) ((((r).cmic_xgxs_mdio_config_0[0]) >> 13) & 0x1)
#define BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_0r_MD_STf_SET(r,f) (r).cmic_xgxs_mdio_config_0[0]=(((r).cmic_xgxs_mdio_config_0[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_0r_RESERVED_0f_GET(r) ((((r).cmic_xgxs_mdio_config_0[0]) >> 14) & 0x3ffff)
#define BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_0r_RESERVED_0f_SET(r,f) (r).cmic_xgxs_mdio_config_0[0]=(((r).cmic_xgxs_mdio_config_0[0] & ~((uint32_t)0x3ffff << 14)) | ((((uint32_t)f) & 0x3ffff) << 14))

/*
 * These macros can be used to access CMIC_XGXS_MDIO_CONFIG_0.
 *
 */
#define BCM56218_A0_READ_CMIC_XGXS_MDIO_CONFIG_0r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_0r,r._cmic_xgxs_mdio_config_0)
#define BCM56218_A0_WRITE_CMIC_XGXS_MDIO_CONFIG_0r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_0r,r._cmic_xgxs_mdio_config_0)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_XGXS_MDIO_CONFIG_0r BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_0r
#define CMIC_XGXS_MDIO_CONFIG_0r_SIZE BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_0r_SIZE
typedef BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_0r_t CMIC_XGXS_MDIO_CONFIG_0r_t;
#define CMIC_XGXS_MDIO_CONFIG_0r_CLR BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_0r_CLR
#define CMIC_XGXS_MDIO_CONFIG_0r_SET BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_0r_SET
#define CMIC_XGXS_MDIO_CONFIG_0r_GET BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_0r_GET
#define CMIC_XGXS_MDIO_CONFIG_0r_IEEE_DEVICES_IN_PKGf_GET BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_0r_IEEE_DEVICES_IN_PKGf_GET
#define CMIC_XGXS_MDIO_CONFIG_0r_IEEE_DEVICES_IN_PKGf_SET BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_0r_IEEE_DEVICES_IN_PKGf_SET
#define CMIC_XGXS_MDIO_CONFIG_0r_MD_DEVADf_GET BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_0r_MD_DEVADf_GET
#define CMIC_XGXS_MDIO_CONFIG_0r_MD_DEVADf_SET BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_0r_MD_DEVADf_SET
#define CMIC_XGXS_MDIO_CONFIG_0r_MD_STf_GET BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_0r_MD_STf_GET
#define CMIC_XGXS_MDIO_CONFIG_0r_MD_STf_SET BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_0r_MD_STf_SET
#define CMIC_XGXS_MDIO_CONFIG_0r_RESERVED_0f_GET BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_0r_RESERVED_0f_GET
#define CMIC_XGXS_MDIO_CONFIG_0r_RESERVED_0f_SET BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_0r_RESERVED_0f_SET
#define READ_CMIC_XGXS_MDIO_CONFIG_0r BCM56218_A0_READ_CMIC_XGXS_MDIO_CONFIG_0r
#define WRITE_CMIC_XGXS_MDIO_CONFIG_0r BCM56218_A0_WRITE_CMIC_XGXS_MDIO_CONFIG_0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_XGXS_MDIO_CONFIG_1
 * BLOCKS:   CMIC
 * DESC:     CMIC XGXS MDIO Config 1 register
 * SIZE:     32
 * FIELDS:
 *     IEEE_DEVICES_IN_PKG IEEE devices in XGXS package
 *     MD_DEVAD         MDIO Device address
 *     MD_ST            Internal phy clause 45 select bitWhen 0, use clause 22 MIIM (historic)  addressing.When 1, use clause 45 MIIM (new style) addressing.
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_1r 0x00000504

#define BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_1r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_XGXS_MDIO_CONFIG_1.
 *
 */
typedef union BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_1r_s {
	uint32_t v[1];
	uint32_t cmic_xgxs_mdio_config_1[1];
	uint32_t _cmic_xgxs_mdio_config_1;
} BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_1r_t;

#define BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_1r_CLR(r) (r).cmic_xgxs_mdio_config_1[0] = 0
#define BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_1r_SET(r,d) (r).cmic_xgxs_mdio_config_1[0] = d
#define BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_1r_GET(r) (r).cmic_xgxs_mdio_config_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_1r_IEEE_DEVICES_IN_PKGf_GET(r) (((r).cmic_xgxs_mdio_config_1[0]) & 0xff)
#define BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_1r_IEEE_DEVICES_IN_PKGf_SET(r,f) (r).cmic_xgxs_mdio_config_1[0]=(((r).cmic_xgxs_mdio_config_1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_1r_MD_DEVADf_GET(r) ((((r).cmic_xgxs_mdio_config_1[0]) >> 8) & 0x1f)
#define BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_1r_MD_DEVADf_SET(r,f) (r).cmic_xgxs_mdio_config_1[0]=(((r).cmic_xgxs_mdio_config_1[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_1r_MD_STf_GET(r) ((((r).cmic_xgxs_mdio_config_1[0]) >> 13) & 0x1)
#define BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_1r_MD_STf_SET(r,f) (r).cmic_xgxs_mdio_config_1[0]=(((r).cmic_xgxs_mdio_config_1[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_1r_RESERVED_0f_GET(r) ((((r).cmic_xgxs_mdio_config_1[0]) >> 14) & 0x3ffff)
#define BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_1r_RESERVED_0f_SET(r,f) (r).cmic_xgxs_mdio_config_1[0]=(((r).cmic_xgxs_mdio_config_1[0] & ~((uint32_t)0x3ffff << 14)) | ((((uint32_t)f) & 0x3ffff) << 14))

/*
 * These macros can be used to access CMIC_XGXS_MDIO_CONFIG_1.
 *
 */
#define BCM56218_A0_READ_CMIC_XGXS_MDIO_CONFIG_1r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_1r,r._cmic_xgxs_mdio_config_1)
#define BCM56218_A0_WRITE_CMIC_XGXS_MDIO_CONFIG_1r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_1r,r._cmic_xgxs_mdio_config_1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_XGXS_MDIO_CONFIG_1r BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_1r
#define CMIC_XGXS_MDIO_CONFIG_1r_SIZE BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_1r_SIZE
typedef BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_1r_t CMIC_XGXS_MDIO_CONFIG_1r_t;
#define CMIC_XGXS_MDIO_CONFIG_1r_CLR BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_1r_CLR
#define CMIC_XGXS_MDIO_CONFIG_1r_SET BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_1r_SET
#define CMIC_XGXS_MDIO_CONFIG_1r_GET BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_1r_GET
#define CMIC_XGXS_MDIO_CONFIG_1r_IEEE_DEVICES_IN_PKGf_GET BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_1r_IEEE_DEVICES_IN_PKGf_GET
#define CMIC_XGXS_MDIO_CONFIG_1r_IEEE_DEVICES_IN_PKGf_SET BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_1r_IEEE_DEVICES_IN_PKGf_SET
#define CMIC_XGXS_MDIO_CONFIG_1r_MD_DEVADf_GET BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_1r_MD_DEVADf_GET
#define CMIC_XGXS_MDIO_CONFIG_1r_MD_DEVADf_SET BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_1r_MD_DEVADf_SET
#define CMIC_XGXS_MDIO_CONFIG_1r_MD_STf_GET BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_1r_MD_STf_GET
#define CMIC_XGXS_MDIO_CONFIG_1r_MD_STf_SET BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_1r_MD_STf_SET
#define CMIC_XGXS_MDIO_CONFIG_1r_RESERVED_0f_GET BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_1r_RESERVED_0f_GET
#define CMIC_XGXS_MDIO_CONFIG_1r_RESERVED_0f_SET BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_1r_RESERVED_0f_SET
#define READ_CMIC_XGXS_MDIO_CONFIG_1r BCM56218_A0_READ_CMIC_XGXS_MDIO_CONFIG_1r
#define WRITE_CMIC_XGXS_MDIO_CONFIG_1r BCM56218_A0_WRITE_CMIC_XGXS_MDIO_CONFIG_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_XGXS_MDIO_CONFIG_2
 * BLOCKS:   CMIC
 * DESC:     CMIC XGXS MDIO Config 2 register
 * SIZE:     32
 * FIELDS:
 *     IEEE_DEVICES_IN_PKG IEEE devices in XGXS package
 *     MD_DEVAD         MDIO Device address
 *     MD_ST            Internal phy clause 45 select bitWhen 0, use clause 22 MIIM (historic)  addressing.When 1, use clause 45 MIIM (new style) addressing.
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_2r 0x00000508

#define BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_2r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_XGXS_MDIO_CONFIG_2.
 *
 */
typedef union BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_2r_s {
	uint32_t v[1];
	uint32_t cmic_xgxs_mdio_config_2[1];
	uint32_t _cmic_xgxs_mdio_config_2;
} BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_2r_t;

#define BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_2r_CLR(r) (r).cmic_xgxs_mdio_config_2[0] = 0
#define BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_2r_SET(r,d) (r).cmic_xgxs_mdio_config_2[0] = d
#define BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_2r_GET(r) (r).cmic_xgxs_mdio_config_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_2r_IEEE_DEVICES_IN_PKGf_GET(r) (((r).cmic_xgxs_mdio_config_2[0]) & 0xff)
#define BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_2r_IEEE_DEVICES_IN_PKGf_SET(r,f) (r).cmic_xgxs_mdio_config_2[0]=(((r).cmic_xgxs_mdio_config_2[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_2r_MD_DEVADf_GET(r) ((((r).cmic_xgxs_mdio_config_2[0]) >> 8) & 0x1f)
#define BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_2r_MD_DEVADf_SET(r,f) (r).cmic_xgxs_mdio_config_2[0]=(((r).cmic_xgxs_mdio_config_2[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_2r_MD_STf_GET(r) ((((r).cmic_xgxs_mdio_config_2[0]) >> 13) & 0x1)
#define BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_2r_MD_STf_SET(r,f) (r).cmic_xgxs_mdio_config_2[0]=(((r).cmic_xgxs_mdio_config_2[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_2r_RESERVED_0f_GET(r) ((((r).cmic_xgxs_mdio_config_2[0]) >> 14) & 0x3ffff)
#define BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_2r_RESERVED_0f_SET(r,f) (r).cmic_xgxs_mdio_config_2[0]=(((r).cmic_xgxs_mdio_config_2[0] & ~((uint32_t)0x3ffff << 14)) | ((((uint32_t)f) & 0x3ffff) << 14))

/*
 * These macros can be used to access CMIC_XGXS_MDIO_CONFIG_2.
 *
 */
#define BCM56218_A0_READ_CMIC_XGXS_MDIO_CONFIG_2r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_2r,r._cmic_xgxs_mdio_config_2)
#define BCM56218_A0_WRITE_CMIC_XGXS_MDIO_CONFIG_2r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_2r,r._cmic_xgxs_mdio_config_2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_XGXS_MDIO_CONFIG_2r BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_2r
#define CMIC_XGXS_MDIO_CONFIG_2r_SIZE BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_2r_SIZE
typedef BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_2r_t CMIC_XGXS_MDIO_CONFIG_2r_t;
#define CMIC_XGXS_MDIO_CONFIG_2r_CLR BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_2r_CLR
#define CMIC_XGXS_MDIO_CONFIG_2r_SET BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_2r_SET
#define CMIC_XGXS_MDIO_CONFIG_2r_GET BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_2r_GET
#define CMIC_XGXS_MDIO_CONFIG_2r_IEEE_DEVICES_IN_PKGf_GET BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_2r_IEEE_DEVICES_IN_PKGf_GET
#define CMIC_XGXS_MDIO_CONFIG_2r_IEEE_DEVICES_IN_PKGf_SET BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_2r_IEEE_DEVICES_IN_PKGf_SET
#define CMIC_XGXS_MDIO_CONFIG_2r_MD_DEVADf_GET BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_2r_MD_DEVADf_GET
#define CMIC_XGXS_MDIO_CONFIG_2r_MD_DEVADf_SET BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_2r_MD_DEVADf_SET
#define CMIC_XGXS_MDIO_CONFIG_2r_MD_STf_GET BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_2r_MD_STf_GET
#define CMIC_XGXS_MDIO_CONFIG_2r_MD_STf_SET BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_2r_MD_STf_SET
#define CMIC_XGXS_MDIO_CONFIG_2r_RESERVED_0f_GET BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_2r_RESERVED_0f_GET
#define CMIC_XGXS_MDIO_CONFIG_2r_RESERVED_0f_SET BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_2r_RESERVED_0f_SET
#define READ_CMIC_XGXS_MDIO_CONFIG_2r BCM56218_A0_READ_CMIC_XGXS_MDIO_CONFIG_2r
#define WRITE_CMIC_XGXS_MDIO_CONFIG_2r BCM56218_A0_WRITE_CMIC_XGXS_MDIO_CONFIG_2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_XGXS_MDIO_CONFIG_3
 * BLOCKS:   CMIC
 * DESC:     CMIC XGXS MDIO Config 3 register
 * SIZE:     32
 * FIELDS:
 *     IEEE_DEVICES_IN_PKG IEEE devices in XGXS package
 *     MD_DEVAD         MDIO Device address
 *     MD_ST            Internal phy clause 45 select bitWhen 0, use clause 22 MIIM (historic)  addressing.When 1, use clause 45 MIIM (new style) addressing.
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_3r 0x0000050c

#define BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_3r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_XGXS_MDIO_CONFIG_3.
 *
 */
typedef union BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_3r_s {
	uint32_t v[1];
	uint32_t cmic_xgxs_mdio_config_3[1];
	uint32_t _cmic_xgxs_mdio_config_3;
} BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_3r_t;

#define BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_3r_CLR(r) (r).cmic_xgxs_mdio_config_3[0] = 0
#define BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_3r_SET(r,d) (r).cmic_xgxs_mdio_config_3[0] = d
#define BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_3r_GET(r) (r).cmic_xgxs_mdio_config_3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_3r_IEEE_DEVICES_IN_PKGf_GET(r) (((r).cmic_xgxs_mdio_config_3[0]) & 0xff)
#define BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_3r_IEEE_DEVICES_IN_PKGf_SET(r,f) (r).cmic_xgxs_mdio_config_3[0]=(((r).cmic_xgxs_mdio_config_3[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_3r_MD_DEVADf_GET(r) ((((r).cmic_xgxs_mdio_config_3[0]) >> 8) & 0x1f)
#define BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_3r_MD_DEVADf_SET(r,f) (r).cmic_xgxs_mdio_config_3[0]=(((r).cmic_xgxs_mdio_config_3[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_3r_MD_STf_GET(r) ((((r).cmic_xgxs_mdio_config_3[0]) >> 13) & 0x1)
#define BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_3r_MD_STf_SET(r,f) (r).cmic_xgxs_mdio_config_3[0]=(((r).cmic_xgxs_mdio_config_3[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_3r_RESERVED_0f_GET(r) ((((r).cmic_xgxs_mdio_config_3[0]) >> 14) & 0x3ffff)
#define BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_3r_RESERVED_0f_SET(r,f) (r).cmic_xgxs_mdio_config_3[0]=(((r).cmic_xgxs_mdio_config_3[0] & ~((uint32_t)0x3ffff << 14)) | ((((uint32_t)f) & 0x3ffff) << 14))

/*
 * These macros can be used to access CMIC_XGXS_MDIO_CONFIG_3.
 *
 */
#define BCM56218_A0_READ_CMIC_XGXS_MDIO_CONFIG_3r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_3r,r._cmic_xgxs_mdio_config_3)
#define BCM56218_A0_WRITE_CMIC_XGXS_MDIO_CONFIG_3r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_3r,r._cmic_xgxs_mdio_config_3)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_XGXS_MDIO_CONFIG_3r BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_3r
#define CMIC_XGXS_MDIO_CONFIG_3r_SIZE BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_3r_SIZE
typedef BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_3r_t CMIC_XGXS_MDIO_CONFIG_3r_t;
#define CMIC_XGXS_MDIO_CONFIG_3r_CLR BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_3r_CLR
#define CMIC_XGXS_MDIO_CONFIG_3r_SET BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_3r_SET
#define CMIC_XGXS_MDIO_CONFIG_3r_GET BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_3r_GET
#define CMIC_XGXS_MDIO_CONFIG_3r_IEEE_DEVICES_IN_PKGf_GET BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_3r_IEEE_DEVICES_IN_PKGf_GET
#define CMIC_XGXS_MDIO_CONFIG_3r_IEEE_DEVICES_IN_PKGf_SET BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_3r_IEEE_DEVICES_IN_PKGf_SET
#define CMIC_XGXS_MDIO_CONFIG_3r_MD_DEVADf_GET BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_3r_MD_DEVADf_GET
#define CMIC_XGXS_MDIO_CONFIG_3r_MD_DEVADf_SET BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_3r_MD_DEVADf_SET
#define CMIC_XGXS_MDIO_CONFIG_3r_MD_STf_GET BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_3r_MD_STf_GET
#define CMIC_XGXS_MDIO_CONFIG_3r_MD_STf_SET BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_3r_MD_STf_SET
#define CMIC_XGXS_MDIO_CONFIG_3r_RESERVED_0f_GET BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_3r_RESERVED_0f_GET
#define CMIC_XGXS_MDIO_CONFIG_3r_RESERVED_0f_SET BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_3r_RESERVED_0f_SET
#define READ_CMIC_XGXS_MDIO_CONFIG_3r BCM56218_A0_READ_CMIC_XGXS_MDIO_CONFIG_3r
#define WRITE_CMIC_XGXS_MDIO_CONFIG_3r BCM56218_A0_WRITE_CMIC_XGXS_MDIO_CONFIG_3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_XGXS_MDIO_CONFIG_3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_XGXS_PLL_CONTROL_1
 * BLOCKS:   CMIC
 * DESC:     CMIC XGXS PLL 0 Control register 1
 * SIZE:     32
 * FIELDS:
 *     SEL_DIFF_CLOCK   1: Select Differential clock, 0: Select Xtal clock
 *     PLL_CONTROL_9_1  XAUI PLLCONTROL register bits [9:1]
 *     PLL_CONTROL_10   Reserved.
 *     PLL_CONTROL_11   Reserved.
 *     PLL_CONTROL_12   Reserved.
 *     PLL_CONTROL_13   Reserved.
 *     PLL_CONTROL_31_14 XAUI PLLCONTROL register bits [31:14]
 *     RESET            Reset for VCO sequencer.0=de-asserted. 1=asserted, starts VCO sequencer
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_XGXS_PLL_CONTROL_1r 0x00000584

#define BCM56218_A0_CMIC_XGXS_PLL_CONTROL_1r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_XGXS_PLL_CONTROL_1.
 *
 */
typedef union BCM56218_A0_CMIC_XGXS_PLL_CONTROL_1r_s {
	uint32_t v[1];
	uint32_t cmic_xgxs_pll_control_1[1];
	uint32_t _cmic_xgxs_pll_control_1;
} BCM56218_A0_CMIC_XGXS_PLL_CONTROL_1r_t;

#define BCM56218_A0_CMIC_XGXS_PLL_CONTROL_1r_CLR(r) (r).cmic_xgxs_pll_control_1[0] = 0
#define BCM56218_A0_CMIC_XGXS_PLL_CONTROL_1r_SET(r,d) (r).cmic_xgxs_pll_control_1[0] = d
#define BCM56218_A0_CMIC_XGXS_PLL_CONTROL_1r_GET(r) (r).cmic_xgxs_pll_control_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_XGXS_PLL_CONTROL_1r_SEL_DIFF_CLOCKf_GET(r) (((r).cmic_xgxs_pll_control_1[0]) & 0x1)
#define BCM56218_A0_CMIC_XGXS_PLL_CONTROL_1r_SEL_DIFF_CLOCKf_SET(r,f) (r).cmic_xgxs_pll_control_1[0]=(((r).cmic_xgxs_pll_control_1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_9_1f_GET(r) ((((r).cmic_xgxs_pll_control_1[0]) >> 1) & 0x1ff)
#define BCM56218_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_9_1f_SET(r,f) (r).cmic_xgxs_pll_control_1[0]=(((r).cmic_xgxs_pll_control_1[0] & ~((uint32_t)0x1ff << 1)) | ((((uint32_t)f) & 0x1ff) << 1))
#define BCM56218_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_10f_GET(r) ((((r).cmic_xgxs_pll_control_1[0]) >> 10) & 0x1)
#define BCM56218_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_10f_SET(r,f) (r).cmic_xgxs_pll_control_1[0]=(((r).cmic_xgxs_pll_control_1[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56218_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_11f_GET(r) ((((r).cmic_xgxs_pll_control_1[0]) >> 11) & 0x1)
#define BCM56218_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_11f_SET(r,f) (r).cmic_xgxs_pll_control_1[0]=(((r).cmic_xgxs_pll_control_1[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56218_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_12f_GET(r) ((((r).cmic_xgxs_pll_control_1[0]) >> 12) & 0x1)
#define BCM56218_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_12f_SET(r,f) (r).cmic_xgxs_pll_control_1[0]=(((r).cmic_xgxs_pll_control_1[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM56218_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_13f_GET(r) ((((r).cmic_xgxs_pll_control_1[0]) >> 13) & 0x1)
#define BCM56218_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_13f_SET(r,f) (r).cmic_xgxs_pll_control_1[0]=(((r).cmic_xgxs_pll_control_1[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56218_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_31_14f_GET(r) ((((r).cmic_xgxs_pll_control_1[0]) >> 14) & 0x3ffff)
#define BCM56218_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_31_14f_SET(r,f) (r).cmic_xgxs_pll_control_1[0]=(((r).cmic_xgxs_pll_control_1[0] & ~((uint32_t)0x3ffff << 14)) | ((((uint32_t)f) & 0x3ffff) << 14))
#define BCM56218_A0_CMIC_XGXS_PLL_CONTROL_1r_RESETf_GET(r) ((((r).cmic_xgxs_pll_control_1[0]) >> 20) & 0x1)
#define BCM56218_A0_CMIC_XGXS_PLL_CONTROL_1r_RESETf_SET(r,f) (r).cmic_xgxs_pll_control_1[0]=(((r).cmic_xgxs_pll_control_1[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))

/*
 * These macros can be used to access CMIC_XGXS_PLL_CONTROL_1.
 *
 */
#define BCM56218_A0_READ_CMIC_XGXS_PLL_CONTROL_1r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_XGXS_PLL_CONTROL_1r,r._cmic_xgxs_pll_control_1)
#define BCM56218_A0_WRITE_CMIC_XGXS_PLL_CONTROL_1r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_XGXS_PLL_CONTROL_1r,r._cmic_xgxs_pll_control_1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_XGXS_PLL_CONTROL_1r BCM56218_A0_CMIC_XGXS_PLL_CONTROL_1r
#define CMIC_XGXS_PLL_CONTROL_1r_SIZE BCM56218_A0_CMIC_XGXS_PLL_CONTROL_1r_SIZE
typedef BCM56218_A0_CMIC_XGXS_PLL_CONTROL_1r_t CMIC_XGXS_PLL_CONTROL_1r_t;
#define CMIC_XGXS_PLL_CONTROL_1r_CLR BCM56218_A0_CMIC_XGXS_PLL_CONTROL_1r_CLR
#define CMIC_XGXS_PLL_CONTROL_1r_SET BCM56218_A0_CMIC_XGXS_PLL_CONTROL_1r_SET
#define CMIC_XGXS_PLL_CONTROL_1r_GET BCM56218_A0_CMIC_XGXS_PLL_CONTROL_1r_GET
#define CMIC_XGXS_PLL_CONTROL_1r_SEL_DIFF_CLOCKf_GET BCM56218_A0_CMIC_XGXS_PLL_CONTROL_1r_SEL_DIFF_CLOCKf_GET
#define CMIC_XGXS_PLL_CONTROL_1r_SEL_DIFF_CLOCKf_SET BCM56218_A0_CMIC_XGXS_PLL_CONTROL_1r_SEL_DIFF_CLOCKf_SET
#define CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_9_1f_GET BCM56218_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_9_1f_GET
#define CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_9_1f_SET BCM56218_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_9_1f_SET
#define CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_10f_GET BCM56218_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_10f_GET
#define CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_10f_SET BCM56218_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_10f_SET
#define CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_11f_GET BCM56218_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_11f_GET
#define CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_11f_SET BCM56218_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_11f_SET
#define CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_12f_GET BCM56218_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_12f_GET
#define CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_12f_SET BCM56218_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_12f_SET
#define CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_13f_GET BCM56218_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_13f_GET
#define CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_13f_SET BCM56218_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_13f_SET
#define CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_31_14f_GET BCM56218_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_31_14f_GET
#define CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_31_14f_SET BCM56218_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_31_14f_SET
#define CMIC_XGXS_PLL_CONTROL_1r_RESETf_GET BCM56218_A0_CMIC_XGXS_PLL_CONTROL_1r_RESETf_GET
#define CMIC_XGXS_PLL_CONTROL_1r_RESETf_SET BCM56218_A0_CMIC_XGXS_PLL_CONTROL_1r_RESETf_SET
#define READ_CMIC_XGXS_PLL_CONTROL_1r BCM56218_A0_READ_CMIC_XGXS_PLL_CONTROL_1r
#define WRITE_CMIC_XGXS_PLL_CONTROL_1r BCM56218_A0_WRITE_CMIC_XGXS_PLL_CONTROL_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_XGXS_PLL_CONTROL_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CMIC_XGXS_PLL_CONTROL_2
 * BLOCKS:   CMIC
 * DESC:     CMIC XGXS 0 PLL Control register 2
 * SIZE:     32
 * FIELDS:
 *     PLL_CONTROL_43_32 XAUI PLLCONTROL register bits [43:32]
 *     XGPLL_CONTROL_PWRDN_INDEX XG PLL Control power down index
 *     PLL_STATUS       XAUI PLL Status bits [17:0]
 *     PLL_SM_FREQ_PASS Frequency lock
 *     CMIC_XG_PLL_LOCK XG PLL Lock
 *
 ******************************************************************************/
#define BCM56218_A0_CMIC_XGXS_PLL_CONTROL_2r 0x00000588

#define BCM56218_A0_CMIC_XGXS_PLL_CONTROL_2r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_XGXS_PLL_CONTROL_2.
 *
 */
typedef union BCM56218_A0_CMIC_XGXS_PLL_CONTROL_2r_s {
	uint32_t v[1];
	uint32_t cmic_xgxs_pll_control_2[1];
	uint32_t _cmic_xgxs_pll_control_2;
} BCM56218_A0_CMIC_XGXS_PLL_CONTROL_2r_t;

#define BCM56218_A0_CMIC_XGXS_PLL_CONTROL_2r_CLR(r) (r).cmic_xgxs_pll_control_2[0] = 0
#define BCM56218_A0_CMIC_XGXS_PLL_CONTROL_2r_SET(r,d) (r).cmic_xgxs_pll_control_2[0] = d
#define BCM56218_A0_CMIC_XGXS_PLL_CONTROL_2r_GET(r) (r).cmic_xgxs_pll_control_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CMIC_XGXS_PLL_CONTROL_2r_PLL_CONTROL_43_32f_GET(r) (((r).cmic_xgxs_pll_control_2[0]) & 0xfff)
#define BCM56218_A0_CMIC_XGXS_PLL_CONTROL_2r_PLL_CONTROL_43_32f_SET(r,f) (r).cmic_xgxs_pll_control_2[0]=(((r).cmic_xgxs_pll_control_2[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM56218_A0_CMIC_XGXS_PLL_CONTROL_2r_XGPLL_CONTROL_PWRDN_INDEXf_GET(r) ((((r).cmic_xgxs_pll_control_2[0]) >> 12) & 0x1)
#define BCM56218_A0_CMIC_XGXS_PLL_CONTROL_2r_XGPLL_CONTROL_PWRDN_INDEXf_SET(r,f) (r).cmic_xgxs_pll_control_2[0]=(((r).cmic_xgxs_pll_control_2[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM56218_A0_CMIC_XGXS_PLL_CONTROL_2r_PLL_STATUSf_GET(r) ((((r).cmic_xgxs_pll_control_2[0]) >> 13) & 0x3ffff)
#define BCM56218_A0_CMIC_XGXS_PLL_CONTROL_2r_PLL_STATUSf_SET(r,f) (r).cmic_xgxs_pll_control_2[0]=(((r).cmic_xgxs_pll_control_2[0] & ~((uint32_t)0x3ffff << 13)) | ((((uint32_t)f) & 0x3ffff) << 13))
#define BCM56218_A0_CMIC_XGXS_PLL_CONTROL_2r_PLL_SM_FREQ_PASSf_GET(r) ((((r).cmic_xgxs_pll_control_2[0]) >> 14) & 0x1)
#define BCM56218_A0_CMIC_XGXS_PLL_CONTROL_2r_PLL_SM_FREQ_PASSf_SET(r,f) (r).cmic_xgxs_pll_control_2[0]=(((r).cmic_xgxs_pll_control_2[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM56218_A0_CMIC_XGXS_PLL_CONTROL_2r_CMIC_XG_PLL_LOCKf_GET(r) ((((r).cmic_xgxs_pll_control_2[0]) >> 31) & 0x1)
#define BCM56218_A0_CMIC_XGXS_PLL_CONTROL_2r_CMIC_XG_PLL_LOCKf_SET(r,f) (r).cmic_xgxs_pll_control_2[0]=(((r).cmic_xgxs_pll_control_2[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access CMIC_XGXS_PLL_CONTROL_2.
 *
 */
#define BCM56218_A0_READ_CMIC_XGXS_PLL_CONTROL_2r(u,r) CDK_DEV_READ32(u,BCM56218_A0_CMIC_XGXS_PLL_CONTROL_2r,r._cmic_xgxs_pll_control_2)
#define BCM56218_A0_WRITE_CMIC_XGXS_PLL_CONTROL_2r(u,r) CDK_DEV_WRITE32(u,BCM56218_A0_CMIC_XGXS_PLL_CONTROL_2r,r._cmic_xgxs_pll_control_2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_XGXS_PLL_CONTROL_2r BCM56218_A0_CMIC_XGXS_PLL_CONTROL_2r
#define CMIC_XGXS_PLL_CONTROL_2r_SIZE BCM56218_A0_CMIC_XGXS_PLL_CONTROL_2r_SIZE
typedef BCM56218_A0_CMIC_XGXS_PLL_CONTROL_2r_t CMIC_XGXS_PLL_CONTROL_2r_t;
#define CMIC_XGXS_PLL_CONTROL_2r_CLR BCM56218_A0_CMIC_XGXS_PLL_CONTROL_2r_CLR
#define CMIC_XGXS_PLL_CONTROL_2r_SET BCM56218_A0_CMIC_XGXS_PLL_CONTROL_2r_SET
#define CMIC_XGXS_PLL_CONTROL_2r_GET BCM56218_A0_CMIC_XGXS_PLL_CONTROL_2r_GET
#define CMIC_XGXS_PLL_CONTROL_2r_PLL_CONTROL_43_32f_GET BCM56218_A0_CMIC_XGXS_PLL_CONTROL_2r_PLL_CONTROL_43_32f_GET
#define CMIC_XGXS_PLL_CONTROL_2r_PLL_CONTROL_43_32f_SET BCM56218_A0_CMIC_XGXS_PLL_CONTROL_2r_PLL_CONTROL_43_32f_SET
#define CMIC_XGXS_PLL_CONTROL_2r_XGPLL_CONTROL_PWRDN_INDEXf_GET BCM56218_A0_CMIC_XGXS_PLL_CONTROL_2r_XGPLL_CONTROL_PWRDN_INDEXf_GET
#define CMIC_XGXS_PLL_CONTROL_2r_XGPLL_CONTROL_PWRDN_INDEXf_SET BCM56218_A0_CMIC_XGXS_PLL_CONTROL_2r_XGPLL_CONTROL_PWRDN_INDEXf_SET
#define CMIC_XGXS_PLL_CONTROL_2r_PLL_STATUSf_GET BCM56218_A0_CMIC_XGXS_PLL_CONTROL_2r_PLL_STATUSf_GET
#define CMIC_XGXS_PLL_CONTROL_2r_PLL_STATUSf_SET BCM56218_A0_CMIC_XGXS_PLL_CONTROL_2r_PLL_STATUSf_SET
#define CMIC_XGXS_PLL_CONTROL_2r_PLL_SM_FREQ_PASSf_GET BCM56218_A0_CMIC_XGXS_PLL_CONTROL_2r_PLL_SM_FREQ_PASSf_GET
#define CMIC_XGXS_PLL_CONTROL_2r_PLL_SM_FREQ_PASSf_SET BCM56218_A0_CMIC_XGXS_PLL_CONTROL_2r_PLL_SM_FREQ_PASSf_SET
#define CMIC_XGXS_PLL_CONTROL_2r_CMIC_XG_PLL_LOCKf_GET BCM56218_A0_CMIC_XGXS_PLL_CONTROL_2r_CMIC_XG_PLL_LOCKf_GET
#define CMIC_XGXS_PLL_CONTROL_2r_CMIC_XG_PLL_LOCKf_SET BCM56218_A0_CMIC_XGXS_PLL_CONTROL_2r_CMIC_XG_PLL_LOCKf_SET
#define READ_CMIC_XGXS_PLL_CONTROL_2r BCM56218_A0_READ_CMIC_XGXS_PLL_CONTROL_2r
#define WRITE_CMIC_XGXS_PLL_CONTROL_2r BCM56218_A0_WRITE_CMIC_XGXS_PLL_CONTROL_2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CMIC_XGXS_PLL_CONTROL_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CNGCOSPKTLIMIT0
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CNGPKTSETLIMIT0  CNG0 Set Limit for COS n for an egress port.When packet count is above this limit, incoming packet carried congestion color red (CNG[1:0]==2'b01) will be dropped. This limit is needed to be set lower than HOLCOSPKTSETLIMIT of the same port to ensure dropping CNG0 packet mechanism will take effect early than HOL. Number of packet allowed for CNG0 packet per egress port of COS 0.
 *
 ******************************************************************************/
#define BCM56218_A0_CNGCOSPKTLIMIT0r 0x0060000f

#define BCM56218_A0_CNGCOSPKTLIMIT0r_SIZE 4

/*
 * This structure should be used to declare and program CNGCOSPKTLIMIT0.
 *
 */
typedef union BCM56218_A0_CNGCOSPKTLIMIT0r_s {
	uint32_t v[1];
	uint32_t cngcospktlimit0[1];
	uint32_t _cngcospktlimit0;
} BCM56218_A0_CNGCOSPKTLIMIT0r_t;

#define BCM56218_A0_CNGCOSPKTLIMIT0r_CLR(r) (r).cngcospktlimit0[0] = 0
#define BCM56218_A0_CNGCOSPKTLIMIT0r_SET(r,d) (r).cngcospktlimit0[0] = d
#define BCM56218_A0_CNGCOSPKTLIMIT0r_GET(r) (r).cngcospktlimit0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CNGCOSPKTLIMIT0r_CNGPKTSETLIMIT0f_GET(r) (((r).cngcospktlimit0[0]) & 0x7ff)
#define BCM56218_A0_CNGCOSPKTLIMIT0r_CNGPKTSETLIMIT0f_SET(r,f) (r).cngcospktlimit0[0]=(((r).cngcospktlimit0[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))

/*
 * These macros can be used to access CNGCOSPKTLIMIT0.
 *
 */
#define BCM56218_A0_READ_CNGCOSPKTLIMIT0r(u,p,i,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_CNGCOSPKTLIMIT0r+(i),(r._cngcospktlimit0))
#define BCM56218_A0_WRITE_CNGCOSPKTLIMIT0r(u,p,i,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_CNGCOSPKTLIMIT0r+(i),&(r._cngcospktlimit0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CNGCOSPKTLIMIT0r BCM56218_A0_CNGCOSPKTLIMIT0r
#define CNGCOSPKTLIMIT0r_SIZE BCM56218_A0_CNGCOSPKTLIMIT0r_SIZE
typedef BCM56218_A0_CNGCOSPKTLIMIT0r_t CNGCOSPKTLIMIT0r_t;
#define CNGCOSPKTLIMIT0r_CLR BCM56218_A0_CNGCOSPKTLIMIT0r_CLR
#define CNGCOSPKTLIMIT0r_SET BCM56218_A0_CNGCOSPKTLIMIT0r_SET
#define CNGCOSPKTLIMIT0r_GET BCM56218_A0_CNGCOSPKTLIMIT0r_GET
#define CNGCOSPKTLIMIT0r_CNGPKTSETLIMIT0f_GET BCM56218_A0_CNGCOSPKTLIMIT0r_CNGPKTSETLIMIT0f_GET
#define CNGCOSPKTLIMIT0r_CNGPKTSETLIMIT0f_SET BCM56218_A0_CNGCOSPKTLIMIT0r_CNGPKTSETLIMIT0f_SET
#define READ_CNGCOSPKTLIMIT0r BCM56218_A0_READ_CNGCOSPKTLIMIT0r
#define WRITE_CNGCOSPKTLIMIT0r BCM56218_A0_WRITE_CNGCOSPKTLIMIT0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CNGCOSPKTLIMIT0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CNGCOSPKTLIMIT1
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CNGPKTSETLIMIT1  CNG1 Set Limit for COS n for an egress port.When packet count is above this limit, incoming packet carried congestion color yellow (CNG[1:0]==2'b11) will be dropped. This limit is needed to be set lower than HOLCOSPKTSETLIMIT of the same port to ensure dropping CNG1 packet mechanism will take effect early than HOL. Number of packet allowed for CNG1 packet per egress port of COS 0.
 *
 ******************************************************************************/
#define BCM56218_A0_CNGCOSPKTLIMIT1r 0x00600017

#define BCM56218_A0_CNGCOSPKTLIMIT1r_SIZE 4

/*
 * This structure should be used to declare and program CNGCOSPKTLIMIT1.
 *
 */
typedef union BCM56218_A0_CNGCOSPKTLIMIT1r_s {
	uint32_t v[1];
	uint32_t cngcospktlimit1[1];
	uint32_t _cngcospktlimit1;
} BCM56218_A0_CNGCOSPKTLIMIT1r_t;

#define BCM56218_A0_CNGCOSPKTLIMIT1r_CLR(r) (r).cngcospktlimit1[0] = 0
#define BCM56218_A0_CNGCOSPKTLIMIT1r_SET(r,d) (r).cngcospktlimit1[0] = d
#define BCM56218_A0_CNGCOSPKTLIMIT1r_GET(r) (r).cngcospktlimit1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CNGCOSPKTLIMIT1r_CNGPKTSETLIMIT1f_GET(r) (((r).cngcospktlimit1[0]) & 0x7ff)
#define BCM56218_A0_CNGCOSPKTLIMIT1r_CNGPKTSETLIMIT1f_SET(r,f) (r).cngcospktlimit1[0]=(((r).cngcospktlimit1[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))

/*
 * These macros can be used to access CNGCOSPKTLIMIT1.
 *
 */
#define BCM56218_A0_READ_CNGCOSPKTLIMIT1r(u,p,i,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_CNGCOSPKTLIMIT1r+(i),(r._cngcospktlimit1))
#define BCM56218_A0_WRITE_CNGCOSPKTLIMIT1r(u,p,i,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_CNGCOSPKTLIMIT1r+(i),&(r._cngcospktlimit1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CNGCOSPKTLIMIT1r BCM56218_A0_CNGCOSPKTLIMIT1r
#define CNGCOSPKTLIMIT1r_SIZE BCM56218_A0_CNGCOSPKTLIMIT1r_SIZE
typedef BCM56218_A0_CNGCOSPKTLIMIT1r_t CNGCOSPKTLIMIT1r_t;
#define CNGCOSPKTLIMIT1r_CLR BCM56218_A0_CNGCOSPKTLIMIT1r_CLR
#define CNGCOSPKTLIMIT1r_SET BCM56218_A0_CNGCOSPKTLIMIT1r_SET
#define CNGCOSPKTLIMIT1r_GET BCM56218_A0_CNGCOSPKTLIMIT1r_GET
#define CNGCOSPKTLIMIT1r_CNGPKTSETLIMIT1f_GET BCM56218_A0_CNGCOSPKTLIMIT1r_CNGPKTSETLIMIT1f_GET
#define CNGCOSPKTLIMIT1r_CNGPKTSETLIMIT1f_SET BCM56218_A0_CNGCOSPKTLIMIT1r_CNGPKTSETLIMIT1f_SET
#define READ_CNGCOSPKTLIMIT1r BCM56218_A0_READ_CNGCOSPKTLIMIT1r
#define WRITE_CNGCOSPKTLIMIT1r BCM56218_A0_WRITE_CNGCOSPKTLIMIT1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CNGCOSPKTLIMIT1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CNGDROPCOUNT0
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     DROPPKTCOUNT     Dropped Packet Count accounts for congestion color red dropped packets for eachegress port after its HOLPktCount over CNG0 Packet Set limit. This is per port based counter collecting all packets for this port on different COS. Number of packets per egress port.
 *
 ******************************************************************************/
#define BCM56218_A0_CNGDROPCOUNT0r 0x0060004c

#define BCM56218_A0_CNGDROPCOUNT0r_SIZE 4

/*
 * This structure should be used to declare and program CNGDROPCOUNT0.
 *
 */
typedef union BCM56218_A0_CNGDROPCOUNT0r_s {
	uint32_t v[1];
	uint32_t cngdropcount0[1];
	uint32_t _cngdropcount0;
} BCM56218_A0_CNGDROPCOUNT0r_t;

#define BCM56218_A0_CNGDROPCOUNT0r_CLR(r) (r).cngdropcount0[0] = 0
#define BCM56218_A0_CNGDROPCOUNT0r_SET(r,d) (r).cngdropcount0[0] = d
#define BCM56218_A0_CNGDROPCOUNT0r_GET(r) (r).cngdropcount0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CNGDROPCOUNT0r_DROPPKTCOUNTf_GET(r) ((r).cngdropcount0[0])
#define BCM56218_A0_CNGDROPCOUNT0r_DROPPKTCOUNTf_SET(r,f) (r).cngdropcount0[0]=((uint32_t)f)

/*
 * These macros can be used to access CNGDROPCOUNT0.
 *
 */
#define BCM56218_A0_READ_CNGDROPCOUNT0r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_CNGDROPCOUNT0r,(r._cngdropcount0))
#define BCM56218_A0_WRITE_CNGDROPCOUNT0r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_CNGDROPCOUNT0r,&(r._cngdropcount0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CNGDROPCOUNT0r BCM56218_A0_CNGDROPCOUNT0r
#define CNGDROPCOUNT0r_SIZE BCM56218_A0_CNGDROPCOUNT0r_SIZE
typedef BCM56218_A0_CNGDROPCOUNT0r_t CNGDROPCOUNT0r_t;
#define CNGDROPCOUNT0r_CLR BCM56218_A0_CNGDROPCOUNT0r_CLR
#define CNGDROPCOUNT0r_SET BCM56218_A0_CNGDROPCOUNT0r_SET
#define CNGDROPCOUNT0r_GET BCM56218_A0_CNGDROPCOUNT0r_GET
#define CNGDROPCOUNT0r_DROPPKTCOUNTf_GET BCM56218_A0_CNGDROPCOUNT0r_DROPPKTCOUNTf_GET
#define CNGDROPCOUNT0r_DROPPKTCOUNTf_SET BCM56218_A0_CNGDROPCOUNT0r_DROPPKTCOUNTf_SET
#define READ_CNGDROPCOUNT0r BCM56218_A0_READ_CNGDROPCOUNT0r
#define WRITE_CNGDROPCOUNT0r BCM56218_A0_WRITE_CNGDROPCOUNT0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CNGDROPCOUNT0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CNGDROPCOUNT1
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     DROPPKTCOUNT     Dropped Packet Count accounts for congestion color yellow dropped packets for eachegress port after its HOLPktCount over CNG1 Packet Set limit. This is per port based counter collecting all packets for this port on different COS. Number of packets per egress port.
 *
 ******************************************************************************/
#define BCM56218_A0_CNGDROPCOUNT1r 0x0060004d

#define BCM56218_A0_CNGDROPCOUNT1r_SIZE 4

/*
 * This structure should be used to declare and program CNGDROPCOUNT1.
 *
 */
typedef union BCM56218_A0_CNGDROPCOUNT1r_s {
	uint32_t v[1];
	uint32_t cngdropcount1[1];
	uint32_t _cngdropcount1;
} BCM56218_A0_CNGDROPCOUNT1r_t;

#define BCM56218_A0_CNGDROPCOUNT1r_CLR(r) (r).cngdropcount1[0] = 0
#define BCM56218_A0_CNGDROPCOUNT1r_SET(r,d) (r).cngdropcount1[0] = d
#define BCM56218_A0_CNGDROPCOUNT1r_GET(r) (r).cngdropcount1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CNGDROPCOUNT1r_DROPPKTCOUNTf_GET(r) ((r).cngdropcount1[0])
#define BCM56218_A0_CNGDROPCOUNT1r_DROPPKTCOUNTf_SET(r,f) (r).cngdropcount1[0]=((uint32_t)f)

/*
 * These macros can be used to access CNGDROPCOUNT1.
 *
 */
#define BCM56218_A0_READ_CNGDROPCOUNT1r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_CNGDROPCOUNT1r,(r._cngdropcount1))
#define BCM56218_A0_WRITE_CNGDROPCOUNT1r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_CNGDROPCOUNT1r,&(r._cngdropcount1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CNGDROPCOUNT1r BCM56218_A0_CNGDROPCOUNT1r
#define CNGDROPCOUNT1r_SIZE BCM56218_A0_CNGDROPCOUNT1r_SIZE
typedef BCM56218_A0_CNGDROPCOUNT1r_t CNGDROPCOUNT1r_t;
#define CNGDROPCOUNT1r_CLR BCM56218_A0_CNGDROPCOUNT1r_CLR
#define CNGDROPCOUNT1r_SET BCM56218_A0_CNGDROPCOUNT1r_SET
#define CNGDROPCOUNT1r_GET BCM56218_A0_CNGDROPCOUNT1r_GET
#define CNGDROPCOUNT1r_DROPPKTCOUNTf_GET BCM56218_A0_CNGDROPCOUNT1r_DROPPKTCOUNTf_GET
#define CNGDROPCOUNT1r_DROPPKTCOUNTf_SET BCM56218_A0_CNGDROPCOUNT1r_DROPPKTCOUNTf_SET
#define READ_CNGDROPCOUNT1r BCM56218_A0_READ_CNGDROPCOUNT1r
#define WRITE_CNGDROPCOUNT1r BCM56218_A0_WRITE_CNGDROPCOUNT1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CNGDROPCOUNT1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CNG_MAP
 * BLOCKS:   IPIPE
 * DESC:     CNG Mapping Register
 * SIZE:     32
 * FIELDS:
 *     PRIORITY0_CNG    Maps the packet priority(0) to a default CNG (congestion value for untrusted ports)
 *     PRIORITY1_CNG    Maps the packet priority(1) to a default CNG (congestion value for untrusted ports)
 *     PRIORITY2_CNG    Maps the packet priority(2) to a default CNG (congestion value for untrusted ports)
 *     PRIORITY3_CNG    Maps the packet priority(3) to a default CNG (congestion value for untrusted ports)
 *     PRIORITY4_CNG    Maps the packet priority(4) to a default CNG (congestion value for untrusted ports)
 *     PRIORITY5_CNG    Maps the packet priority(5) to a default CNG (congestion value for untrusted ports)
 *     PRIORITY6_CNG    Maps the packet priority(6) to a default CNG (congestion value for untrusted ports)
 *     PRIORITY7_CNG    Maps the packet priority(7) to a default CNG (congestion value for untrusted ports)
 *     CFI0_CNG         Maps the incoming CFI(0) to a default CNG (if CFI_AS_CNG is set in ING_CONFIG)
 *     CFI1_CNG         Maps the incoming CFI(1) to a default CNG (if CFI_AS_CNG is set in ING_CONFIG)
 *
 ******************************************************************************/
#define BCM56218_A0_CNG_MAPr 0x0b700000

#define BCM56218_A0_CNG_MAPr_SIZE 4

/*
 * This structure should be used to declare and program CNG_MAP.
 *
 */
typedef union BCM56218_A0_CNG_MAPr_s {
	uint32_t v[1];
	uint32_t cng_map[1];
	uint32_t _cng_map;
} BCM56218_A0_CNG_MAPr_t;

#define BCM56218_A0_CNG_MAPr_CLR(r) (r).cng_map[0] = 0
#define BCM56218_A0_CNG_MAPr_SET(r,d) (r).cng_map[0] = d
#define BCM56218_A0_CNG_MAPr_GET(r) (r).cng_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CNG_MAPr_PRIORITY0_CNGf_GET(r) (((r).cng_map[0]) & 0x3)
#define BCM56218_A0_CNG_MAPr_PRIORITY0_CNGf_SET(r,f) (r).cng_map[0]=(((r).cng_map[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56218_A0_CNG_MAPr_PRIORITY1_CNGf_GET(r) ((((r).cng_map[0]) >> 2) & 0x3)
#define BCM56218_A0_CNG_MAPr_PRIORITY1_CNGf_SET(r,f) (r).cng_map[0]=(((r).cng_map[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM56218_A0_CNG_MAPr_PRIORITY2_CNGf_GET(r) ((((r).cng_map[0]) >> 4) & 0x3)
#define BCM56218_A0_CNG_MAPr_PRIORITY2_CNGf_SET(r,f) (r).cng_map[0]=(((r).cng_map[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM56218_A0_CNG_MAPr_PRIORITY3_CNGf_GET(r) ((((r).cng_map[0]) >> 6) & 0x3)
#define BCM56218_A0_CNG_MAPr_PRIORITY3_CNGf_SET(r,f) (r).cng_map[0]=(((r).cng_map[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM56218_A0_CNG_MAPr_PRIORITY4_CNGf_GET(r) ((((r).cng_map[0]) >> 8) & 0x3)
#define BCM56218_A0_CNG_MAPr_PRIORITY4_CNGf_SET(r,f) (r).cng_map[0]=(((r).cng_map[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM56218_A0_CNG_MAPr_PRIORITY5_CNGf_GET(r) ((((r).cng_map[0]) >> 10) & 0x3)
#define BCM56218_A0_CNG_MAPr_PRIORITY5_CNGf_SET(r,f) (r).cng_map[0]=(((r).cng_map[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCM56218_A0_CNG_MAPr_PRIORITY6_CNGf_GET(r) ((((r).cng_map[0]) >> 12) & 0x3)
#define BCM56218_A0_CNG_MAPr_PRIORITY6_CNGf_SET(r,f) (r).cng_map[0]=(((r).cng_map[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM56218_A0_CNG_MAPr_PRIORITY7_CNGf_GET(r) ((((r).cng_map[0]) >> 14) & 0x3)
#define BCM56218_A0_CNG_MAPr_PRIORITY7_CNGf_SET(r,f) (r).cng_map[0]=(((r).cng_map[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCM56218_A0_CNG_MAPr_CFI0_CNGf_GET(r) ((((r).cng_map[0]) >> 16) & 0x3)
#define BCM56218_A0_CNG_MAPr_CFI0_CNGf_SET(r,f) (r).cng_map[0]=(((r).cng_map[0] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM56218_A0_CNG_MAPr_CFI1_CNGf_GET(r) ((((r).cng_map[0]) >> 18) & 0x3)
#define BCM56218_A0_CNG_MAPr_CFI1_CNGf_SET(r,f) (r).cng_map[0]=(((r).cng_map[0] & ~((uint32_t)0x3 << 18)) | ((((uint32_t)f) & 0x3) << 18))

/*
 * These macros can be used to access CNG_MAP.
 *
 */
#define BCM56218_A0_READ_CNG_MAPr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_CNG_MAPr,(r._cng_map))
#define BCM56218_A0_WRITE_CNG_MAPr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_CNG_MAPr,&(r._cng_map))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CNG_MAPr BCM56218_A0_CNG_MAPr
#define CNG_MAPr_SIZE BCM56218_A0_CNG_MAPr_SIZE
typedef BCM56218_A0_CNG_MAPr_t CNG_MAPr_t;
#define CNG_MAPr_CLR BCM56218_A0_CNG_MAPr_CLR
#define CNG_MAPr_SET BCM56218_A0_CNG_MAPr_SET
#define CNG_MAPr_GET BCM56218_A0_CNG_MAPr_GET
#define CNG_MAPr_PRIORITY0_CNGf_GET BCM56218_A0_CNG_MAPr_PRIORITY0_CNGf_GET
#define CNG_MAPr_PRIORITY0_CNGf_SET BCM56218_A0_CNG_MAPr_PRIORITY0_CNGf_SET
#define CNG_MAPr_PRIORITY1_CNGf_GET BCM56218_A0_CNG_MAPr_PRIORITY1_CNGf_GET
#define CNG_MAPr_PRIORITY1_CNGf_SET BCM56218_A0_CNG_MAPr_PRIORITY1_CNGf_SET
#define CNG_MAPr_PRIORITY2_CNGf_GET BCM56218_A0_CNG_MAPr_PRIORITY2_CNGf_GET
#define CNG_MAPr_PRIORITY2_CNGf_SET BCM56218_A0_CNG_MAPr_PRIORITY2_CNGf_SET
#define CNG_MAPr_PRIORITY3_CNGf_GET BCM56218_A0_CNG_MAPr_PRIORITY3_CNGf_GET
#define CNG_MAPr_PRIORITY3_CNGf_SET BCM56218_A0_CNG_MAPr_PRIORITY3_CNGf_SET
#define CNG_MAPr_PRIORITY4_CNGf_GET BCM56218_A0_CNG_MAPr_PRIORITY4_CNGf_GET
#define CNG_MAPr_PRIORITY4_CNGf_SET BCM56218_A0_CNG_MAPr_PRIORITY4_CNGf_SET
#define CNG_MAPr_PRIORITY5_CNGf_GET BCM56218_A0_CNG_MAPr_PRIORITY5_CNGf_GET
#define CNG_MAPr_PRIORITY5_CNGf_SET BCM56218_A0_CNG_MAPr_PRIORITY5_CNGf_SET
#define CNG_MAPr_PRIORITY6_CNGf_GET BCM56218_A0_CNG_MAPr_PRIORITY6_CNGf_GET
#define CNG_MAPr_PRIORITY6_CNGf_SET BCM56218_A0_CNG_MAPr_PRIORITY6_CNGf_SET
#define CNG_MAPr_PRIORITY7_CNGf_GET BCM56218_A0_CNG_MAPr_PRIORITY7_CNGf_GET
#define CNG_MAPr_PRIORITY7_CNGf_SET BCM56218_A0_CNG_MAPr_PRIORITY7_CNGf_SET
#define CNG_MAPr_CFI0_CNGf_GET BCM56218_A0_CNG_MAPr_CFI0_CNGf_GET
#define CNG_MAPr_CFI0_CNGf_SET BCM56218_A0_CNG_MAPr_CFI0_CNGf_SET
#define CNG_MAPr_CFI1_CNGf_GET BCM56218_A0_CNG_MAPr_CFI1_CNGf_GET
#define CNG_MAPr_CFI1_CNGf_SET BCM56218_A0_CNG_MAPr_CFI1_CNGf_SET
#define READ_CNG_MAPr BCM56218_A0_READ_CNG_MAPr
#define WRITE_CNG_MAPr BCM56218_A0_WRITE_CNG_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CNG_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  COSLCCOUNT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     LCCOUNT          Cell Count for egress port packet of COS n: Number of cells per egress port of COS n.
 *
 ******************************************************************************/
#define BCM56218_A0_COSLCCOUNTr 0x0060002f

#define BCM56218_A0_COSLCCOUNTr_SIZE 4

/*
 * This structure should be used to declare and program COSLCCOUNT.
 *
 */
typedef union BCM56218_A0_COSLCCOUNTr_s {
	uint32_t v[1];
	uint32_t coslccount[1];
	uint32_t _coslccount;
} BCM56218_A0_COSLCCOUNTr_t;

#define BCM56218_A0_COSLCCOUNTr_CLR(r) (r).coslccount[0] = 0
#define BCM56218_A0_COSLCCOUNTr_SET(r,d) (r).coslccount[0] = d
#define BCM56218_A0_COSLCCOUNTr_GET(r) (r).coslccount[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_COSLCCOUNTr_LCCOUNTf_GET(r) (((r).coslccount[0]) & 0xfff)
#define BCM56218_A0_COSLCCOUNTr_LCCOUNTf_SET(r,f) (r).coslccount[0]=(((r).coslccount[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))

/*
 * These macros can be used to access COSLCCOUNT.
 *
 */
#define BCM56218_A0_READ_COSLCCOUNTr(u,p,i,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_COSLCCOUNTr+(i),(r._coslccount))
#define BCM56218_A0_WRITE_COSLCCOUNTr(u,p,i,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_COSLCCOUNTr+(i),&(r._coslccount))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define COSLCCOUNTr BCM56218_A0_COSLCCOUNTr
#define COSLCCOUNTr_SIZE BCM56218_A0_COSLCCOUNTr_SIZE
typedef BCM56218_A0_COSLCCOUNTr_t COSLCCOUNTr_t;
#define COSLCCOUNTr_CLR BCM56218_A0_COSLCCOUNTr_CLR
#define COSLCCOUNTr_SET BCM56218_A0_COSLCCOUNTr_SET
#define COSLCCOUNTr_GET BCM56218_A0_COSLCCOUNTr_GET
#define COSLCCOUNTr_LCCOUNTf_GET BCM56218_A0_COSLCCOUNTr_LCCOUNTf_GET
#define COSLCCOUNTr_LCCOUNTf_SET BCM56218_A0_COSLCCOUNTr_LCCOUNTf_SET
#define READ_COSLCCOUNTr BCM56218_A0_READ_COSLCCOUNTr
#define WRITE_COSLCCOUNTr BCM56218_A0_WRITE_COSLCCOUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_COSLCCOUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  COSPKTCOUNT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     PKTCOUNT         Packet Count for egress port packet for COS n: This is current nuumber of entries in XQ of COS n for this egress port.Number of packets per egress port for COS n.
 *
 ******************************************************************************/
#define BCM56218_A0_COSPKTCOUNTr 0x0060001f

#define BCM56218_A0_COSPKTCOUNTr_SIZE 4

/*
 * This structure should be used to declare and program COSPKTCOUNT.
 *
 */
typedef union BCM56218_A0_COSPKTCOUNTr_s {
	uint32_t v[1];
	uint32_t cospktcount[1];
	uint32_t _cospktcount;
} BCM56218_A0_COSPKTCOUNTr_t;

#define BCM56218_A0_COSPKTCOUNTr_CLR(r) (r).cospktcount[0] = 0
#define BCM56218_A0_COSPKTCOUNTr_SET(r,d) (r).cospktcount[0] = d
#define BCM56218_A0_COSPKTCOUNTr_GET(r) (r).cospktcount[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_COSPKTCOUNTr_PKTCOUNTf_GET(r) (((r).cospktcount[0]) & 0x7ff)
#define BCM56218_A0_COSPKTCOUNTr_PKTCOUNTf_SET(r,f) (r).cospktcount[0]=(((r).cospktcount[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))

/*
 * These macros can be used to access COSPKTCOUNT.
 *
 */
#define BCM56218_A0_READ_COSPKTCOUNTr(u,p,i,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_COSPKTCOUNTr+(i),(r._cospktcount))
#define BCM56218_A0_WRITE_COSPKTCOUNTr(u,p,i,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_COSPKTCOUNTr+(i),&(r._cospktcount))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define COSPKTCOUNTr BCM56218_A0_COSPKTCOUNTr
#define COSPKTCOUNTr_SIZE BCM56218_A0_COSPKTCOUNTr_SIZE
typedef BCM56218_A0_COSPKTCOUNTr_t COSPKTCOUNTr_t;
#define COSPKTCOUNTr_CLR BCM56218_A0_COSPKTCOUNTr_CLR
#define COSPKTCOUNTr_SET BCM56218_A0_COSPKTCOUNTr_SET
#define COSPKTCOUNTr_GET BCM56218_A0_COSPKTCOUNTr_GET
#define COSPKTCOUNTr_PKTCOUNTf_GET BCM56218_A0_COSPKTCOUNTr_PKTCOUNTf_GET
#define COSPKTCOUNTr_PKTCOUNTf_SET BCM56218_A0_COSPKTCOUNTr_PKTCOUNTf_SET
#define READ_COSPKTCOUNTr BCM56218_A0_READ_COSPKTCOUNTr
#define WRITE_COSPKTCOUNTr BCM56218_A0_WRITE_COSPKTCOUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_COSPKTCOUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  COS_SEL
 * BLOCKS:   IPIPE
 * DESC:     COS Queue Mapping Register based on internal priority
 * SIZE:     32
 * FIELDS:
 *     COS0             COS-0 Value
 *     COS1             COS-1 Value
 *     COS2             COS-2 Value
 *     COS3             COS-3 Value
 *     COS4             COS-4 Value
 *     COS5             COS-5 Value
 *     COS6             COS-6 Value
 *     COS7             COS-7 Value
 *
 ******************************************************************************/
#define BCM56218_A0_COS_SELr 0x0e70010f

#define BCM56218_A0_COS_SELr_SIZE 4

/*
 * This structure should be used to declare and program COS_SEL.
 *
 */
typedef union BCM56218_A0_COS_SELr_s {
	uint32_t v[1];
	uint32_t cos_sel[1];
	uint32_t _cos_sel;
} BCM56218_A0_COS_SELr_t;

#define BCM56218_A0_COS_SELr_CLR(r) (r).cos_sel[0] = 0
#define BCM56218_A0_COS_SELr_SET(r,d) (r).cos_sel[0] = d
#define BCM56218_A0_COS_SELr_GET(r) (r).cos_sel[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_COS_SELr_COS0f_GET(r) (((r).cos_sel[0]) & 0x7)
#define BCM56218_A0_COS_SELr_COS0f_SET(r,f) (r).cos_sel[0]=(((r).cos_sel[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM56218_A0_COS_SELr_COS1f_GET(r) ((((r).cos_sel[0]) >> 3) & 0x7)
#define BCM56218_A0_COS_SELr_COS1f_SET(r,f) (r).cos_sel[0]=(((r).cos_sel[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM56218_A0_COS_SELr_COS2f_GET(r) ((((r).cos_sel[0]) >> 6) & 0x7)
#define BCM56218_A0_COS_SELr_COS2f_SET(r,f) (r).cos_sel[0]=(((r).cos_sel[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM56218_A0_COS_SELr_COS3f_GET(r) ((((r).cos_sel[0]) >> 9) & 0x7)
#define BCM56218_A0_COS_SELr_COS3f_SET(r,f) (r).cos_sel[0]=(((r).cos_sel[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM56218_A0_COS_SELr_COS4f_GET(r) ((((r).cos_sel[0]) >> 12) & 0x7)
#define BCM56218_A0_COS_SELr_COS4f_SET(r,f) (r).cos_sel[0]=(((r).cos_sel[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM56218_A0_COS_SELr_COS5f_GET(r) ((((r).cos_sel[0]) >> 15) & 0x7)
#define BCM56218_A0_COS_SELr_COS5f_SET(r,f) (r).cos_sel[0]=(((r).cos_sel[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM56218_A0_COS_SELr_COS6f_GET(r) ((((r).cos_sel[0]) >> 18) & 0x7)
#define BCM56218_A0_COS_SELr_COS6f_SET(r,f) (r).cos_sel[0]=(((r).cos_sel[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM56218_A0_COS_SELr_COS7f_GET(r) ((((r).cos_sel[0]) >> 21) & 0x7)
#define BCM56218_A0_COS_SELr_COS7f_SET(r,f) (r).cos_sel[0]=(((r).cos_sel[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))

/*
 * These macros can be used to access COS_SEL.
 *
 */
#define BCM56218_A0_READ_COS_SELr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_COS_SELr,(r._cos_sel))
#define BCM56218_A0_WRITE_COS_SELr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_COS_SELr,&(r._cos_sel))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define COS_SELr BCM56218_A0_COS_SELr
#define COS_SELr_SIZE BCM56218_A0_COS_SELr_SIZE
typedef BCM56218_A0_COS_SELr_t COS_SELr_t;
#define COS_SELr_CLR BCM56218_A0_COS_SELr_CLR
#define COS_SELr_SET BCM56218_A0_COS_SELr_SET
#define COS_SELr_GET BCM56218_A0_COS_SELr_GET
#define COS_SELr_COS0f_GET BCM56218_A0_COS_SELr_COS0f_GET
#define COS_SELr_COS0f_SET BCM56218_A0_COS_SELr_COS0f_SET
#define COS_SELr_COS1f_GET BCM56218_A0_COS_SELr_COS1f_GET
#define COS_SELr_COS1f_SET BCM56218_A0_COS_SELr_COS1f_SET
#define COS_SELr_COS2f_GET BCM56218_A0_COS_SELr_COS2f_GET
#define COS_SELr_COS2f_SET BCM56218_A0_COS_SELr_COS2f_SET
#define COS_SELr_COS3f_GET BCM56218_A0_COS_SELr_COS3f_GET
#define COS_SELr_COS3f_SET BCM56218_A0_COS_SELr_COS3f_SET
#define COS_SELr_COS4f_GET BCM56218_A0_COS_SELr_COS4f_GET
#define COS_SELr_COS4f_SET BCM56218_A0_COS_SELr_COS4f_SET
#define COS_SELr_COS5f_GET BCM56218_A0_COS_SELr_COS5f_GET
#define COS_SELr_COS5f_SET BCM56218_A0_COS_SELr_COS5f_SET
#define COS_SELr_COS6f_GET BCM56218_A0_COS_SELr_COS6f_GET
#define COS_SELr_COS6f_SET BCM56218_A0_COS_SELr_COS6f_SET
#define COS_SELr_COS7f_GET BCM56218_A0_COS_SELr_COS7f_GET
#define COS_SELr_COS7f_SET BCM56218_A0_COS_SELr_COS7f_SET
#define READ_COS_SELr BCM56218_A0_READ_COS_SELr
#define WRITE_COS_SELr BCM56218_A0_WRITE_COS_SELr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_COS_SELr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  COS_SEL_2
 * BLOCKS:   IPIPE
 * DESC:     COS Queue Mapping Register based on internal priority.
 * SIZE:     32
 * FIELDS:
 *     COS8             COS value for priority-8 Value
 *     COS9             COS value for priority-9 Value
 *     COS10            COS value for priority-10 Value
 *     COS11            COS value for priority-11 Value
 *     COS12            COS value for priority-12 Value
 *     COS13            COS value for priority-13 Value
 *     COS14            COS value for priority-14 Value
 *     COS15            COS value for priority-15 Value
 *
 ******************************************************************************/
#define BCM56218_A0_COS_SEL_2r 0x0e70012f

#define BCM56218_A0_COS_SEL_2r_SIZE 4

/*
 * This structure should be used to declare and program COS_SEL_2.
 *
 */
typedef union BCM56218_A0_COS_SEL_2r_s {
	uint32_t v[1];
	uint32_t cos_sel_2[1];
	uint32_t _cos_sel_2;
} BCM56218_A0_COS_SEL_2r_t;

#define BCM56218_A0_COS_SEL_2r_CLR(r) (r).cos_sel_2[0] = 0
#define BCM56218_A0_COS_SEL_2r_SET(r,d) (r).cos_sel_2[0] = d
#define BCM56218_A0_COS_SEL_2r_GET(r) (r).cos_sel_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_COS_SEL_2r_COS8f_GET(r) (((r).cos_sel_2[0]) & 0x7)
#define BCM56218_A0_COS_SEL_2r_COS8f_SET(r,f) (r).cos_sel_2[0]=(((r).cos_sel_2[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM56218_A0_COS_SEL_2r_COS9f_GET(r) ((((r).cos_sel_2[0]) >> 3) & 0x7)
#define BCM56218_A0_COS_SEL_2r_COS9f_SET(r,f) (r).cos_sel_2[0]=(((r).cos_sel_2[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM56218_A0_COS_SEL_2r_COS10f_GET(r) ((((r).cos_sel_2[0]) >> 6) & 0x7)
#define BCM56218_A0_COS_SEL_2r_COS10f_SET(r,f) (r).cos_sel_2[0]=(((r).cos_sel_2[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM56218_A0_COS_SEL_2r_COS11f_GET(r) ((((r).cos_sel_2[0]) >> 9) & 0x7)
#define BCM56218_A0_COS_SEL_2r_COS11f_SET(r,f) (r).cos_sel_2[0]=(((r).cos_sel_2[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM56218_A0_COS_SEL_2r_COS12f_GET(r) ((((r).cos_sel_2[0]) >> 12) & 0x7)
#define BCM56218_A0_COS_SEL_2r_COS12f_SET(r,f) (r).cos_sel_2[0]=(((r).cos_sel_2[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM56218_A0_COS_SEL_2r_COS13f_GET(r) ((((r).cos_sel_2[0]) >> 15) & 0x7)
#define BCM56218_A0_COS_SEL_2r_COS13f_SET(r,f) (r).cos_sel_2[0]=(((r).cos_sel_2[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM56218_A0_COS_SEL_2r_COS14f_GET(r) ((((r).cos_sel_2[0]) >> 18) & 0x7)
#define BCM56218_A0_COS_SEL_2r_COS14f_SET(r,f) (r).cos_sel_2[0]=(((r).cos_sel_2[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM56218_A0_COS_SEL_2r_COS15f_GET(r) ((((r).cos_sel_2[0]) >> 21) & 0x7)
#define BCM56218_A0_COS_SEL_2r_COS15f_SET(r,f) (r).cos_sel_2[0]=(((r).cos_sel_2[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))

/*
 * These macros can be used to access COS_SEL_2.
 *
 */
#define BCM56218_A0_READ_COS_SEL_2r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_COS_SEL_2r,(r._cos_sel_2))
#define BCM56218_A0_WRITE_COS_SEL_2r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_COS_SEL_2r,&(r._cos_sel_2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define COS_SEL_2r BCM56218_A0_COS_SEL_2r
#define COS_SEL_2r_SIZE BCM56218_A0_COS_SEL_2r_SIZE
typedef BCM56218_A0_COS_SEL_2r_t COS_SEL_2r_t;
#define COS_SEL_2r_CLR BCM56218_A0_COS_SEL_2r_CLR
#define COS_SEL_2r_SET BCM56218_A0_COS_SEL_2r_SET
#define COS_SEL_2r_GET BCM56218_A0_COS_SEL_2r_GET
#define COS_SEL_2r_COS8f_GET BCM56218_A0_COS_SEL_2r_COS8f_GET
#define COS_SEL_2r_COS8f_SET BCM56218_A0_COS_SEL_2r_COS8f_SET
#define COS_SEL_2r_COS9f_GET BCM56218_A0_COS_SEL_2r_COS9f_GET
#define COS_SEL_2r_COS9f_SET BCM56218_A0_COS_SEL_2r_COS9f_SET
#define COS_SEL_2r_COS10f_GET BCM56218_A0_COS_SEL_2r_COS10f_GET
#define COS_SEL_2r_COS10f_SET BCM56218_A0_COS_SEL_2r_COS10f_SET
#define COS_SEL_2r_COS11f_GET BCM56218_A0_COS_SEL_2r_COS11f_GET
#define COS_SEL_2r_COS11f_SET BCM56218_A0_COS_SEL_2r_COS11f_SET
#define COS_SEL_2r_COS12f_GET BCM56218_A0_COS_SEL_2r_COS12f_GET
#define COS_SEL_2r_COS12f_SET BCM56218_A0_COS_SEL_2r_COS12f_SET
#define COS_SEL_2r_COS13f_GET BCM56218_A0_COS_SEL_2r_COS13f_GET
#define COS_SEL_2r_COS13f_SET BCM56218_A0_COS_SEL_2r_COS13f_SET
#define COS_SEL_2r_COS14f_GET BCM56218_A0_COS_SEL_2r_COS14f_GET
#define COS_SEL_2r_COS14f_SET BCM56218_A0_COS_SEL_2r_COS14f_SET
#define COS_SEL_2r_COS15f_GET BCM56218_A0_COS_SEL_2r_COS15f_GET
#define COS_SEL_2r_COS15f_SET BCM56218_A0_COS_SEL_2r_COS15f_SET
#define READ_COS_SEL_2r BCM56218_A0_READ_COS_SEL_2r
#define WRITE_COS_SEL_2r BCM56218_A0_WRITE_COS_SEL_2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_COS_SEL_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CPU_CONTROL_1
 * BLOCKS:   IPIPE
 * DESC:     Control Register for Packets sent to the CPU
 * SIZE:     32
 * FIELDS:
 *     STATICMOVE_TOCPU Static move send to CPU enable
 *     NONSTATICMOVE_TOCPU Non-static move send to CPU enable
 *     UIPMC_TOCPU      Unknown IPMC (IPMC miss) send to CPU enable
 *     UMC_TOCPU        Unknown multicast (L2MC miss) send to CPU enable
 *     UUCAST_TOCPU     Unknown unicast send to CPU enable
 *     V4L3ERR_TOCPU    IPv4 L3 error send to CPU enable
 *     IPMCERR_TOCPU    IPMC error send to CPU enable
 *     UVLAN_TOCPU      Unknown VLAN send to CPU enable
 *     UNRESOLVEDL3SRC_TOCPU Unresolved source for L3 send to CPU enable
 *     V6L3DSTMISS_TOCPU IPv6 L3 unicast destination miss send to CPU enable
 *     V4L3DSTMISS_TOCPU IPv4 L3 unicast destination miss send to CPU enable
 *     IPMCPORTMISS_TOCPU IPMC port mismatch send to CPU enable
 *     SRCROUTE_TOCPU   If SA[40] set, send to CPU enable
 *     V6L3ERR_TOCPU    IPv6 L3 error send to CPU enable
 *     MARTIAN_ADDR_TOCPU Martian address send to CPU enable
 *     TUNNEL_ERR_TOCPU Tunnel error send to CPU enable
 *     DOSATTACK_TOCPU  DOS attack send to CPU enable
 *     L3UC_TTL_ERR_TOCPU L3 unicast TTL error send to CPU enable
 *     IPMC_TTL_ERR_TOCPU L3 multicast TTL error send to CPU enable
 *     ICMP_REDIRECT_TOCPU ICMP redirect send to CPU enable
 *     L3_SLOWPATH_TOCPU L3 slow path to CPU enable
 *     PARITY_ERR_TOCPU Parity Error to CPU enable
 *     IPMC_TUNNEL_TO_CPU IPMC Tunnel pkt to CPU enable
 *     HG_HDR_ERROR_TOCPU HG Header Error Packet to CPU enable
 *     MC_INDEX_ERROR_TOCPU MC INDEX Error to CPU enable
 *     HG_HDR_TYPE1_TOCPU HiGig header type = 1 to CPU enable
 *     NIP_L3ERR_TOCPU  NON IP L3 error send to CPU enable
 *     MACLMT_STNMV_TOCPU Station Movement case alongwith Mac Limit Learn enable and counters exceeded
 *
 ******************************************************************************/
#define BCM56218_A0_CPU_CONTROL_1r 0x0b780004

#define BCM56218_A0_CPU_CONTROL_1r_SIZE 4

/*
 * This structure should be used to declare and program CPU_CONTROL_1.
 *
 */
typedef union BCM56218_A0_CPU_CONTROL_1r_s {
	uint32_t v[1];
	uint32_t cpu_control_1[1];
	uint32_t _cpu_control_1;
} BCM56218_A0_CPU_CONTROL_1r_t;

#define BCM56218_A0_CPU_CONTROL_1r_CLR(r) (r).cpu_control_1[0] = 0
#define BCM56218_A0_CPU_CONTROL_1r_SET(r,d) (r).cpu_control_1[0] = d
#define BCM56218_A0_CPU_CONTROL_1r_GET(r) (r).cpu_control_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CPU_CONTROL_1r_STATICMOVE_TOCPUf_GET(r) (((r).cpu_control_1[0]) & 0x1)
#define BCM56218_A0_CPU_CONTROL_1r_STATICMOVE_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_CPU_CONTROL_1r_NONSTATICMOVE_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 1) & 0x1)
#define BCM56218_A0_CPU_CONTROL_1r_NONSTATICMOVE_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_CPU_CONTROL_1r_UIPMC_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 2) & 0x1)
#define BCM56218_A0_CPU_CONTROL_1r_UIPMC_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_CPU_CONTROL_1r_UMC_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 3) & 0x1)
#define BCM56218_A0_CPU_CONTROL_1r_UMC_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56218_A0_CPU_CONTROL_1r_UUCAST_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 4) & 0x1)
#define BCM56218_A0_CPU_CONTROL_1r_UUCAST_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56218_A0_CPU_CONTROL_1r_V4L3ERR_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 5) & 0x1)
#define BCM56218_A0_CPU_CONTROL_1r_V4L3ERR_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56218_A0_CPU_CONTROL_1r_IPMCERR_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 6) & 0x1)
#define BCM56218_A0_CPU_CONTROL_1r_IPMCERR_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56218_A0_CPU_CONTROL_1r_UVLAN_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 7) & 0x1)
#define BCM56218_A0_CPU_CONTROL_1r_UVLAN_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56218_A0_CPU_CONTROL_1r_UNRESOLVEDL3SRC_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 8) & 0x1)
#define BCM56218_A0_CPU_CONTROL_1r_UNRESOLVEDL3SRC_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56218_A0_CPU_CONTROL_1r_V6L3DSTMISS_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 9) & 0x1)
#define BCM56218_A0_CPU_CONTROL_1r_V6L3DSTMISS_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56218_A0_CPU_CONTROL_1r_V4L3DSTMISS_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 10) & 0x1)
#define BCM56218_A0_CPU_CONTROL_1r_V4L3DSTMISS_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56218_A0_CPU_CONTROL_1r_IPMCPORTMISS_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 11) & 0x1)
#define BCM56218_A0_CPU_CONTROL_1r_IPMCPORTMISS_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56218_A0_CPU_CONTROL_1r_SRCROUTE_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 12) & 0x1)
#define BCM56218_A0_CPU_CONTROL_1r_SRCROUTE_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM56218_A0_CPU_CONTROL_1r_V6L3ERR_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 13) & 0x1)
#define BCM56218_A0_CPU_CONTROL_1r_V6L3ERR_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56218_A0_CPU_CONTROL_1r_MARTIAN_ADDR_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 14) & 0x1)
#define BCM56218_A0_CPU_CONTROL_1r_MARTIAN_ADDR_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM56218_A0_CPU_CONTROL_1r_TUNNEL_ERR_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 15) & 0x1)
#define BCM56218_A0_CPU_CONTROL_1r_TUNNEL_ERR_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56218_A0_CPU_CONTROL_1r_DOSATTACK_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 16) & 0x1)
#define BCM56218_A0_CPU_CONTROL_1r_DOSATTACK_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56218_A0_CPU_CONTROL_1r_L3UC_TTL_ERR_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 17) & 0x1)
#define BCM56218_A0_CPU_CONTROL_1r_L3UC_TTL_ERR_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_CPU_CONTROL_1r_IPMC_TTL_ERR_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 18) & 0x1)
#define BCM56218_A0_CPU_CONTROL_1r_IPMC_TTL_ERR_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_CPU_CONTROL_1r_ICMP_REDIRECT_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 19) & 0x1)
#define BCM56218_A0_CPU_CONTROL_1r_ICMP_REDIRECT_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56218_A0_CPU_CONTROL_1r_L3_SLOWPATH_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 20) & 0x1)
#define BCM56218_A0_CPU_CONTROL_1r_L3_SLOWPATH_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM56218_A0_CPU_CONTROL_1r_PARITY_ERR_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 21) & 0x1)
#define BCM56218_A0_CPU_CONTROL_1r_PARITY_ERR_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM56218_A0_CPU_CONTROL_1r_IPMC_TUNNEL_TO_CPUf_GET(r) ((((r).cpu_control_1[0]) >> 22) & 0x1)
#define BCM56218_A0_CPU_CONTROL_1r_IPMC_TUNNEL_TO_CPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM56218_A0_CPU_CONTROL_1r_HG_HDR_ERROR_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 23) & 0x1)
#define BCM56218_A0_CPU_CONTROL_1r_HG_HDR_ERROR_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM56218_A0_CPU_CONTROL_1r_MC_INDEX_ERROR_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 24) & 0x1)
#define BCM56218_A0_CPU_CONTROL_1r_MC_INDEX_ERROR_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM56218_A0_CPU_CONTROL_1r_HG_HDR_TYPE1_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 25) & 0x1)
#define BCM56218_A0_CPU_CONTROL_1r_HG_HDR_TYPE1_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM56218_A0_CPU_CONTROL_1r_NIP_L3ERR_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 26) & 0x1)
#define BCM56218_A0_CPU_CONTROL_1r_NIP_L3ERR_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM56218_A0_CPU_CONTROL_1r_MACLMT_STNMV_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 27) & 0x1)
#define BCM56218_A0_CPU_CONTROL_1r_MACLMT_STNMV_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))

/*
 * These macros can be used to access CPU_CONTROL_1.
 *
 */
#define BCM56218_A0_READ_CPU_CONTROL_1r(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_CPU_CONTROL_1r,(r._cpu_control_1))
#define BCM56218_A0_WRITE_CPU_CONTROL_1r(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_CPU_CONTROL_1r,&(r._cpu_control_1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CPU_CONTROL_1r BCM56218_A0_CPU_CONTROL_1r
#define CPU_CONTROL_1r_SIZE BCM56218_A0_CPU_CONTROL_1r_SIZE
typedef BCM56218_A0_CPU_CONTROL_1r_t CPU_CONTROL_1r_t;
#define CPU_CONTROL_1r_CLR BCM56218_A0_CPU_CONTROL_1r_CLR
#define CPU_CONTROL_1r_SET BCM56218_A0_CPU_CONTROL_1r_SET
#define CPU_CONTROL_1r_GET BCM56218_A0_CPU_CONTROL_1r_GET
#define CPU_CONTROL_1r_STATICMOVE_TOCPUf_GET BCM56218_A0_CPU_CONTROL_1r_STATICMOVE_TOCPUf_GET
#define CPU_CONTROL_1r_STATICMOVE_TOCPUf_SET BCM56218_A0_CPU_CONTROL_1r_STATICMOVE_TOCPUf_SET
#define CPU_CONTROL_1r_NONSTATICMOVE_TOCPUf_GET BCM56218_A0_CPU_CONTROL_1r_NONSTATICMOVE_TOCPUf_GET
#define CPU_CONTROL_1r_NONSTATICMOVE_TOCPUf_SET BCM56218_A0_CPU_CONTROL_1r_NONSTATICMOVE_TOCPUf_SET
#define CPU_CONTROL_1r_UIPMC_TOCPUf_GET BCM56218_A0_CPU_CONTROL_1r_UIPMC_TOCPUf_GET
#define CPU_CONTROL_1r_UIPMC_TOCPUf_SET BCM56218_A0_CPU_CONTROL_1r_UIPMC_TOCPUf_SET
#define CPU_CONTROL_1r_UMC_TOCPUf_GET BCM56218_A0_CPU_CONTROL_1r_UMC_TOCPUf_GET
#define CPU_CONTROL_1r_UMC_TOCPUf_SET BCM56218_A0_CPU_CONTROL_1r_UMC_TOCPUf_SET
#define CPU_CONTROL_1r_UUCAST_TOCPUf_GET BCM56218_A0_CPU_CONTROL_1r_UUCAST_TOCPUf_GET
#define CPU_CONTROL_1r_UUCAST_TOCPUf_SET BCM56218_A0_CPU_CONTROL_1r_UUCAST_TOCPUf_SET
#define CPU_CONTROL_1r_V4L3ERR_TOCPUf_GET BCM56218_A0_CPU_CONTROL_1r_V4L3ERR_TOCPUf_GET
#define CPU_CONTROL_1r_V4L3ERR_TOCPUf_SET BCM56218_A0_CPU_CONTROL_1r_V4L3ERR_TOCPUf_SET
#define CPU_CONTROL_1r_IPMCERR_TOCPUf_GET BCM56218_A0_CPU_CONTROL_1r_IPMCERR_TOCPUf_GET
#define CPU_CONTROL_1r_IPMCERR_TOCPUf_SET BCM56218_A0_CPU_CONTROL_1r_IPMCERR_TOCPUf_SET
#define CPU_CONTROL_1r_UVLAN_TOCPUf_GET BCM56218_A0_CPU_CONTROL_1r_UVLAN_TOCPUf_GET
#define CPU_CONTROL_1r_UVLAN_TOCPUf_SET BCM56218_A0_CPU_CONTROL_1r_UVLAN_TOCPUf_SET
#define CPU_CONTROL_1r_UNRESOLVEDL3SRC_TOCPUf_GET BCM56218_A0_CPU_CONTROL_1r_UNRESOLVEDL3SRC_TOCPUf_GET
#define CPU_CONTROL_1r_UNRESOLVEDL3SRC_TOCPUf_SET BCM56218_A0_CPU_CONTROL_1r_UNRESOLVEDL3SRC_TOCPUf_SET
#define CPU_CONTROL_1r_V6L3DSTMISS_TOCPUf_GET BCM56218_A0_CPU_CONTROL_1r_V6L3DSTMISS_TOCPUf_GET
#define CPU_CONTROL_1r_V6L3DSTMISS_TOCPUf_SET BCM56218_A0_CPU_CONTROL_1r_V6L3DSTMISS_TOCPUf_SET
#define CPU_CONTROL_1r_V4L3DSTMISS_TOCPUf_GET BCM56218_A0_CPU_CONTROL_1r_V4L3DSTMISS_TOCPUf_GET
#define CPU_CONTROL_1r_V4L3DSTMISS_TOCPUf_SET BCM56218_A0_CPU_CONTROL_1r_V4L3DSTMISS_TOCPUf_SET
#define CPU_CONTROL_1r_IPMCPORTMISS_TOCPUf_GET BCM56218_A0_CPU_CONTROL_1r_IPMCPORTMISS_TOCPUf_GET
#define CPU_CONTROL_1r_IPMCPORTMISS_TOCPUf_SET BCM56218_A0_CPU_CONTROL_1r_IPMCPORTMISS_TOCPUf_SET
#define CPU_CONTROL_1r_SRCROUTE_TOCPUf_GET BCM56218_A0_CPU_CONTROL_1r_SRCROUTE_TOCPUf_GET
#define CPU_CONTROL_1r_SRCROUTE_TOCPUf_SET BCM56218_A0_CPU_CONTROL_1r_SRCROUTE_TOCPUf_SET
#define CPU_CONTROL_1r_V6L3ERR_TOCPUf_GET BCM56218_A0_CPU_CONTROL_1r_V6L3ERR_TOCPUf_GET
#define CPU_CONTROL_1r_V6L3ERR_TOCPUf_SET BCM56218_A0_CPU_CONTROL_1r_V6L3ERR_TOCPUf_SET
#define CPU_CONTROL_1r_MARTIAN_ADDR_TOCPUf_GET BCM56218_A0_CPU_CONTROL_1r_MARTIAN_ADDR_TOCPUf_GET
#define CPU_CONTROL_1r_MARTIAN_ADDR_TOCPUf_SET BCM56218_A0_CPU_CONTROL_1r_MARTIAN_ADDR_TOCPUf_SET
#define CPU_CONTROL_1r_TUNNEL_ERR_TOCPUf_GET BCM56218_A0_CPU_CONTROL_1r_TUNNEL_ERR_TOCPUf_GET
#define CPU_CONTROL_1r_TUNNEL_ERR_TOCPUf_SET BCM56218_A0_CPU_CONTROL_1r_TUNNEL_ERR_TOCPUf_SET
#define CPU_CONTROL_1r_DOSATTACK_TOCPUf_GET BCM56218_A0_CPU_CONTROL_1r_DOSATTACK_TOCPUf_GET
#define CPU_CONTROL_1r_DOSATTACK_TOCPUf_SET BCM56218_A0_CPU_CONTROL_1r_DOSATTACK_TOCPUf_SET
#define CPU_CONTROL_1r_L3UC_TTL_ERR_TOCPUf_GET BCM56218_A0_CPU_CONTROL_1r_L3UC_TTL_ERR_TOCPUf_GET
#define CPU_CONTROL_1r_L3UC_TTL_ERR_TOCPUf_SET BCM56218_A0_CPU_CONTROL_1r_L3UC_TTL_ERR_TOCPUf_SET
#define CPU_CONTROL_1r_IPMC_TTL_ERR_TOCPUf_GET BCM56218_A0_CPU_CONTROL_1r_IPMC_TTL_ERR_TOCPUf_GET
#define CPU_CONTROL_1r_IPMC_TTL_ERR_TOCPUf_SET BCM56218_A0_CPU_CONTROL_1r_IPMC_TTL_ERR_TOCPUf_SET
#define CPU_CONTROL_1r_ICMP_REDIRECT_TOCPUf_GET BCM56218_A0_CPU_CONTROL_1r_ICMP_REDIRECT_TOCPUf_GET
#define CPU_CONTROL_1r_ICMP_REDIRECT_TOCPUf_SET BCM56218_A0_CPU_CONTROL_1r_ICMP_REDIRECT_TOCPUf_SET
#define CPU_CONTROL_1r_L3_SLOWPATH_TOCPUf_GET BCM56218_A0_CPU_CONTROL_1r_L3_SLOWPATH_TOCPUf_GET
#define CPU_CONTROL_1r_L3_SLOWPATH_TOCPUf_SET BCM56218_A0_CPU_CONTROL_1r_L3_SLOWPATH_TOCPUf_SET
#define CPU_CONTROL_1r_PARITY_ERR_TOCPUf_GET BCM56218_A0_CPU_CONTROL_1r_PARITY_ERR_TOCPUf_GET
#define CPU_CONTROL_1r_PARITY_ERR_TOCPUf_SET BCM56218_A0_CPU_CONTROL_1r_PARITY_ERR_TOCPUf_SET
#define CPU_CONTROL_1r_IPMC_TUNNEL_TO_CPUf_GET BCM56218_A0_CPU_CONTROL_1r_IPMC_TUNNEL_TO_CPUf_GET
#define CPU_CONTROL_1r_IPMC_TUNNEL_TO_CPUf_SET BCM56218_A0_CPU_CONTROL_1r_IPMC_TUNNEL_TO_CPUf_SET
#define CPU_CONTROL_1r_HG_HDR_ERROR_TOCPUf_GET BCM56218_A0_CPU_CONTROL_1r_HG_HDR_ERROR_TOCPUf_GET
#define CPU_CONTROL_1r_HG_HDR_ERROR_TOCPUf_SET BCM56218_A0_CPU_CONTROL_1r_HG_HDR_ERROR_TOCPUf_SET
#define CPU_CONTROL_1r_MC_INDEX_ERROR_TOCPUf_GET BCM56218_A0_CPU_CONTROL_1r_MC_INDEX_ERROR_TOCPUf_GET
#define CPU_CONTROL_1r_MC_INDEX_ERROR_TOCPUf_SET BCM56218_A0_CPU_CONTROL_1r_MC_INDEX_ERROR_TOCPUf_SET
#define CPU_CONTROL_1r_HG_HDR_TYPE1_TOCPUf_GET BCM56218_A0_CPU_CONTROL_1r_HG_HDR_TYPE1_TOCPUf_GET
#define CPU_CONTROL_1r_HG_HDR_TYPE1_TOCPUf_SET BCM56218_A0_CPU_CONTROL_1r_HG_HDR_TYPE1_TOCPUf_SET
#define CPU_CONTROL_1r_NIP_L3ERR_TOCPUf_GET BCM56218_A0_CPU_CONTROL_1r_NIP_L3ERR_TOCPUf_GET
#define CPU_CONTROL_1r_NIP_L3ERR_TOCPUf_SET BCM56218_A0_CPU_CONTROL_1r_NIP_L3ERR_TOCPUf_SET
#define CPU_CONTROL_1r_MACLMT_STNMV_TOCPUf_GET BCM56218_A0_CPU_CONTROL_1r_MACLMT_STNMV_TOCPUf_GET
#define CPU_CONTROL_1r_MACLMT_STNMV_TOCPUf_SET BCM56218_A0_CPU_CONTROL_1r_MACLMT_STNMV_TOCPUf_SET
#define READ_CPU_CONTROL_1r BCM56218_A0_READ_CPU_CONTROL_1r
#define WRITE_CPU_CONTROL_1r BCM56218_A0_WRITE_CPU_CONTROL_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CPU_CONTROL_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CPU_CONTROL_2
 * BLOCKS:   IPIPE
 * DESC:     Control Register for Packets sent to the CPU. All Priorities are internal priorities.
 * SIZE:     32
 * FIELDS:
 *     CPU_MH_CONTROL_PRIORITY CPU OPCODE CONTROL Priority
 *     CPU_LKUPFAIL_PRIORITY CPU Lookup Fail Priority
 *     CPU_SFLOW_PRIORITY CPU SFLOW Priority
 *     CPU_DEFAULT_PRIORITY CPU Default Priority
 *     CPU_MTUFAIL_PRIORITY CPU MTU fail Priority
 *     CPU_FPCOPY_PRIORITY CPU FP copy to cpu Priority
 *     CPU_ICMP_REDIRECT_PRIORITY CPU ICMP Redirect Priority
 *     CPU_MIRROR_PRIORITY CPU Mirror Priority
 *
 ******************************************************************************/
#define BCM56218_A0_CPU_CONTROL_2r 0x0e780125

#define BCM56218_A0_CPU_CONTROL_2r_SIZE 4

/*
 * This structure should be used to declare and program CPU_CONTROL_2.
 *
 */
typedef union BCM56218_A0_CPU_CONTROL_2r_s {
	uint32_t v[1];
	uint32_t cpu_control_2[1];
	uint32_t _cpu_control_2;
} BCM56218_A0_CPU_CONTROL_2r_t;

#define BCM56218_A0_CPU_CONTROL_2r_CLR(r) (r).cpu_control_2[0] = 0
#define BCM56218_A0_CPU_CONTROL_2r_SET(r,d) (r).cpu_control_2[0] = d
#define BCM56218_A0_CPU_CONTROL_2r_GET(r) (r).cpu_control_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CPU_CONTROL_2r_CPU_MH_CONTROL_PRIORITYf_GET(r) (((r).cpu_control_2[0]) & 0xf)
#define BCM56218_A0_CPU_CONTROL_2r_CPU_MH_CONTROL_PRIORITYf_SET(r,f) (r).cpu_control_2[0]=(((r).cpu_control_2[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56218_A0_CPU_CONTROL_2r_CPU_LKUPFAIL_PRIORITYf_GET(r) ((((r).cpu_control_2[0]) >> 4) & 0xf)
#define BCM56218_A0_CPU_CONTROL_2r_CPU_LKUPFAIL_PRIORITYf_SET(r,f) (r).cpu_control_2[0]=(((r).cpu_control_2[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56218_A0_CPU_CONTROL_2r_CPU_SFLOW_PRIORITYf_GET(r) ((((r).cpu_control_2[0]) >> 8) & 0xf)
#define BCM56218_A0_CPU_CONTROL_2r_CPU_SFLOW_PRIORITYf_SET(r,f) (r).cpu_control_2[0]=(((r).cpu_control_2[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM56218_A0_CPU_CONTROL_2r_CPU_DEFAULT_PRIORITYf_GET(r) ((((r).cpu_control_2[0]) >> 12) & 0xf)
#define BCM56218_A0_CPU_CONTROL_2r_CPU_DEFAULT_PRIORITYf_SET(r,f) (r).cpu_control_2[0]=(((r).cpu_control_2[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM56218_A0_CPU_CONTROL_2r_CPU_MTUFAIL_PRIORITYf_GET(r) ((((r).cpu_control_2[0]) >> 16) & 0xf)
#define BCM56218_A0_CPU_CONTROL_2r_CPU_MTUFAIL_PRIORITYf_SET(r,f) (r).cpu_control_2[0]=(((r).cpu_control_2[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM56218_A0_CPU_CONTROL_2r_CPU_FPCOPY_PRIORITYf_GET(r) ((((r).cpu_control_2[0]) >> 20) & 0xf)
#define BCM56218_A0_CPU_CONTROL_2r_CPU_FPCOPY_PRIORITYf_SET(r,f) (r).cpu_control_2[0]=(((r).cpu_control_2[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM56218_A0_CPU_CONTROL_2r_CPU_ICMP_REDIRECT_PRIORITYf_GET(r) ((((r).cpu_control_2[0]) >> 24) & 0xf)
#define BCM56218_A0_CPU_CONTROL_2r_CPU_ICMP_REDIRECT_PRIORITYf_SET(r,f) (r).cpu_control_2[0]=(((r).cpu_control_2[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM56218_A0_CPU_CONTROL_2r_CPU_MIRROR_PRIORITYf_GET(r) ((((r).cpu_control_2[0]) >> 28) & 0xf)
#define BCM56218_A0_CPU_CONTROL_2r_CPU_MIRROR_PRIORITYf_SET(r,f) (r).cpu_control_2[0]=(((r).cpu_control_2[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access CPU_CONTROL_2.
 *
 */
#define BCM56218_A0_READ_CPU_CONTROL_2r(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_CPU_CONTROL_2r,(r._cpu_control_2))
#define BCM56218_A0_WRITE_CPU_CONTROL_2r(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_CPU_CONTROL_2r,&(r._cpu_control_2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CPU_CONTROL_2r BCM56218_A0_CPU_CONTROL_2r
#define CPU_CONTROL_2r_SIZE BCM56218_A0_CPU_CONTROL_2r_SIZE
typedef BCM56218_A0_CPU_CONTROL_2r_t CPU_CONTROL_2r_t;
#define CPU_CONTROL_2r_CLR BCM56218_A0_CPU_CONTROL_2r_CLR
#define CPU_CONTROL_2r_SET BCM56218_A0_CPU_CONTROL_2r_SET
#define CPU_CONTROL_2r_GET BCM56218_A0_CPU_CONTROL_2r_GET
#define CPU_CONTROL_2r_CPU_MH_CONTROL_PRIORITYf_GET BCM56218_A0_CPU_CONTROL_2r_CPU_MH_CONTROL_PRIORITYf_GET
#define CPU_CONTROL_2r_CPU_MH_CONTROL_PRIORITYf_SET BCM56218_A0_CPU_CONTROL_2r_CPU_MH_CONTROL_PRIORITYf_SET
#define CPU_CONTROL_2r_CPU_LKUPFAIL_PRIORITYf_GET BCM56218_A0_CPU_CONTROL_2r_CPU_LKUPFAIL_PRIORITYf_GET
#define CPU_CONTROL_2r_CPU_LKUPFAIL_PRIORITYf_SET BCM56218_A0_CPU_CONTROL_2r_CPU_LKUPFAIL_PRIORITYf_SET
#define CPU_CONTROL_2r_CPU_SFLOW_PRIORITYf_GET BCM56218_A0_CPU_CONTROL_2r_CPU_SFLOW_PRIORITYf_GET
#define CPU_CONTROL_2r_CPU_SFLOW_PRIORITYf_SET BCM56218_A0_CPU_CONTROL_2r_CPU_SFLOW_PRIORITYf_SET
#define CPU_CONTROL_2r_CPU_DEFAULT_PRIORITYf_GET BCM56218_A0_CPU_CONTROL_2r_CPU_DEFAULT_PRIORITYf_GET
#define CPU_CONTROL_2r_CPU_DEFAULT_PRIORITYf_SET BCM56218_A0_CPU_CONTROL_2r_CPU_DEFAULT_PRIORITYf_SET
#define CPU_CONTROL_2r_CPU_MTUFAIL_PRIORITYf_GET BCM56218_A0_CPU_CONTROL_2r_CPU_MTUFAIL_PRIORITYf_GET
#define CPU_CONTROL_2r_CPU_MTUFAIL_PRIORITYf_SET BCM56218_A0_CPU_CONTROL_2r_CPU_MTUFAIL_PRIORITYf_SET
#define CPU_CONTROL_2r_CPU_FPCOPY_PRIORITYf_GET BCM56218_A0_CPU_CONTROL_2r_CPU_FPCOPY_PRIORITYf_GET
#define CPU_CONTROL_2r_CPU_FPCOPY_PRIORITYf_SET BCM56218_A0_CPU_CONTROL_2r_CPU_FPCOPY_PRIORITYf_SET
#define CPU_CONTROL_2r_CPU_ICMP_REDIRECT_PRIORITYf_GET BCM56218_A0_CPU_CONTROL_2r_CPU_ICMP_REDIRECT_PRIORITYf_GET
#define CPU_CONTROL_2r_CPU_ICMP_REDIRECT_PRIORITYf_SET BCM56218_A0_CPU_CONTROL_2r_CPU_ICMP_REDIRECT_PRIORITYf_SET
#define CPU_CONTROL_2r_CPU_MIRROR_PRIORITYf_GET BCM56218_A0_CPU_CONTROL_2r_CPU_MIRROR_PRIORITYf_GET
#define CPU_CONTROL_2r_CPU_MIRROR_PRIORITYf_SET BCM56218_A0_CPU_CONTROL_2r_CPU_MIRROR_PRIORITYf_SET
#define READ_CPU_CONTROL_2r BCM56218_A0_READ_CPU_CONTROL_2r
#define WRITE_CPU_CONTROL_2r BCM56218_A0_WRITE_CPU_CONTROL_2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CPU_CONTROL_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CPU_CONTROL_3
 * BLOCKS:   IPIPE
 * DESC:     Control Register for Packets sent to the CPU. All priorities are internal priorities
 * SIZE:     32
 * FIELDS:
 *     CPU_PROTO_EXCEPTIONS_PRIORITY Priority for IPv4/IPv6 pkts with TTL=1 when it is copied/trapped to CPU.
 *     CPU_PROTO_IP_OPTIONS_PRIORITY Priority for IPv4/IPv6 pkts with options or IPv6 pkts with payload len zero (jumbo option) when it is copied/trapped to CPU.
 *     CPU_PROTO_IPMC_RESERVED_PRIORITY Priority for IPv4/IPv6 reserved multicast pkts when it is copied/trapped to CPU.
 *     CPU_PROTO_DHCP_PRIORITY Priority for DHCP pkts when it is copied/trapped to CPU.
 *     CPU_PROTO_IGMP_PRIORITY Priority for IGMP/MLD pkts when it is copied/trapped to CPU.
 *     CPU_PROTO_ARP_PRIORITY Priority for ARP/ND pkts when it is copied/trapped to CPU.
 *     CPU_PROTO_BPDU_PRIORITY Priority for BPDU pkts when it is copied/trapped to CPU.
 *     CPU_MAC_LIMIT_PRIORITY CPU priority for mac limit exceeded pkts that are copied to CPU
 *
 ******************************************************************************/
#define BCM56218_A0_CPU_CONTROL_3r 0x0e780132

#define BCM56218_A0_CPU_CONTROL_3r_SIZE 4

/*
 * This structure should be used to declare and program CPU_CONTROL_3.
 *
 */
typedef union BCM56218_A0_CPU_CONTROL_3r_s {
	uint32_t v[1];
	uint32_t cpu_control_3[1];
	uint32_t _cpu_control_3;
} BCM56218_A0_CPU_CONTROL_3r_t;

#define BCM56218_A0_CPU_CONTROL_3r_CLR(r) (r).cpu_control_3[0] = 0
#define BCM56218_A0_CPU_CONTROL_3r_SET(r,d) (r).cpu_control_3[0] = d
#define BCM56218_A0_CPU_CONTROL_3r_GET(r) (r).cpu_control_3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CPU_CONTROL_3r_CPU_PROTO_EXCEPTIONS_PRIORITYf_GET(r) (((r).cpu_control_3[0]) & 0xf)
#define BCM56218_A0_CPU_CONTROL_3r_CPU_PROTO_EXCEPTIONS_PRIORITYf_SET(r,f) (r).cpu_control_3[0]=(((r).cpu_control_3[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56218_A0_CPU_CONTROL_3r_CPU_PROTO_IP_OPTIONS_PRIORITYf_GET(r) ((((r).cpu_control_3[0]) >> 4) & 0xf)
#define BCM56218_A0_CPU_CONTROL_3r_CPU_PROTO_IP_OPTIONS_PRIORITYf_SET(r,f) (r).cpu_control_3[0]=(((r).cpu_control_3[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56218_A0_CPU_CONTROL_3r_CPU_PROTO_IPMC_RESERVED_PRIORITYf_GET(r) ((((r).cpu_control_3[0]) >> 8) & 0xf)
#define BCM56218_A0_CPU_CONTROL_3r_CPU_PROTO_IPMC_RESERVED_PRIORITYf_SET(r,f) (r).cpu_control_3[0]=(((r).cpu_control_3[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM56218_A0_CPU_CONTROL_3r_CPU_PROTO_DHCP_PRIORITYf_GET(r) ((((r).cpu_control_3[0]) >> 12) & 0xf)
#define BCM56218_A0_CPU_CONTROL_3r_CPU_PROTO_DHCP_PRIORITYf_SET(r,f) (r).cpu_control_3[0]=(((r).cpu_control_3[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM56218_A0_CPU_CONTROL_3r_CPU_PROTO_IGMP_PRIORITYf_GET(r) ((((r).cpu_control_3[0]) >> 16) & 0xf)
#define BCM56218_A0_CPU_CONTROL_3r_CPU_PROTO_IGMP_PRIORITYf_SET(r,f) (r).cpu_control_3[0]=(((r).cpu_control_3[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM56218_A0_CPU_CONTROL_3r_CPU_PROTO_ARP_PRIORITYf_GET(r) ((((r).cpu_control_3[0]) >> 20) & 0xf)
#define BCM56218_A0_CPU_CONTROL_3r_CPU_PROTO_ARP_PRIORITYf_SET(r,f) (r).cpu_control_3[0]=(((r).cpu_control_3[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM56218_A0_CPU_CONTROL_3r_CPU_PROTO_BPDU_PRIORITYf_GET(r) ((((r).cpu_control_3[0]) >> 24) & 0xf)
#define BCM56218_A0_CPU_CONTROL_3r_CPU_PROTO_BPDU_PRIORITYf_SET(r,f) (r).cpu_control_3[0]=(((r).cpu_control_3[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM56218_A0_CPU_CONTROL_3r_CPU_MAC_LIMIT_PRIORITYf_GET(r) ((((r).cpu_control_3[0]) >> 28) & 0xf)
#define BCM56218_A0_CPU_CONTROL_3r_CPU_MAC_LIMIT_PRIORITYf_SET(r,f) (r).cpu_control_3[0]=(((r).cpu_control_3[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access CPU_CONTROL_3.
 *
 */
#define BCM56218_A0_READ_CPU_CONTROL_3r(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_CPU_CONTROL_3r,(r._cpu_control_3))
#define BCM56218_A0_WRITE_CPU_CONTROL_3r(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_CPU_CONTROL_3r,&(r._cpu_control_3))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CPU_CONTROL_3r BCM56218_A0_CPU_CONTROL_3r
#define CPU_CONTROL_3r_SIZE BCM56218_A0_CPU_CONTROL_3r_SIZE
typedef BCM56218_A0_CPU_CONTROL_3r_t CPU_CONTROL_3r_t;
#define CPU_CONTROL_3r_CLR BCM56218_A0_CPU_CONTROL_3r_CLR
#define CPU_CONTROL_3r_SET BCM56218_A0_CPU_CONTROL_3r_SET
#define CPU_CONTROL_3r_GET BCM56218_A0_CPU_CONTROL_3r_GET
#define CPU_CONTROL_3r_CPU_PROTO_EXCEPTIONS_PRIORITYf_GET BCM56218_A0_CPU_CONTROL_3r_CPU_PROTO_EXCEPTIONS_PRIORITYf_GET
#define CPU_CONTROL_3r_CPU_PROTO_EXCEPTIONS_PRIORITYf_SET BCM56218_A0_CPU_CONTROL_3r_CPU_PROTO_EXCEPTIONS_PRIORITYf_SET
#define CPU_CONTROL_3r_CPU_PROTO_IP_OPTIONS_PRIORITYf_GET BCM56218_A0_CPU_CONTROL_3r_CPU_PROTO_IP_OPTIONS_PRIORITYf_GET
#define CPU_CONTROL_3r_CPU_PROTO_IP_OPTIONS_PRIORITYf_SET BCM56218_A0_CPU_CONTROL_3r_CPU_PROTO_IP_OPTIONS_PRIORITYf_SET
#define CPU_CONTROL_3r_CPU_PROTO_IPMC_RESERVED_PRIORITYf_GET BCM56218_A0_CPU_CONTROL_3r_CPU_PROTO_IPMC_RESERVED_PRIORITYf_GET
#define CPU_CONTROL_3r_CPU_PROTO_IPMC_RESERVED_PRIORITYf_SET BCM56218_A0_CPU_CONTROL_3r_CPU_PROTO_IPMC_RESERVED_PRIORITYf_SET
#define CPU_CONTROL_3r_CPU_PROTO_DHCP_PRIORITYf_GET BCM56218_A0_CPU_CONTROL_3r_CPU_PROTO_DHCP_PRIORITYf_GET
#define CPU_CONTROL_3r_CPU_PROTO_DHCP_PRIORITYf_SET BCM56218_A0_CPU_CONTROL_3r_CPU_PROTO_DHCP_PRIORITYf_SET
#define CPU_CONTROL_3r_CPU_PROTO_IGMP_PRIORITYf_GET BCM56218_A0_CPU_CONTROL_3r_CPU_PROTO_IGMP_PRIORITYf_GET
#define CPU_CONTROL_3r_CPU_PROTO_IGMP_PRIORITYf_SET BCM56218_A0_CPU_CONTROL_3r_CPU_PROTO_IGMP_PRIORITYf_SET
#define CPU_CONTROL_3r_CPU_PROTO_ARP_PRIORITYf_GET BCM56218_A0_CPU_CONTROL_3r_CPU_PROTO_ARP_PRIORITYf_GET
#define CPU_CONTROL_3r_CPU_PROTO_ARP_PRIORITYf_SET BCM56218_A0_CPU_CONTROL_3r_CPU_PROTO_ARP_PRIORITYf_SET
#define CPU_CONTROL_3r_CPU_PROTO_BPDU_PRIORITYf_GET BCM56218_A0_CPU_CONTROL_3r_CPU_PROTO_BPDU_PRIORITYf_GET
#define CPU_CONTROL_3r_CPU_PROTO_BPDU_PRIORITYf_SET BCM56218_A0_CPU_CONTROL_3r_CPU_PROTO_BPDU_PRIORITYf_SET
#define CPU_CONTROL_3r_CPU_MAC_LIMIT_PRIORITYf_GET BCM56218_A0_CPU_CONTROL_3r_CPU_MAC_LIMIT_PRIORITYf_GET
#define CPU_CONTROL_3r_CPU_MAC_LIMIT_PRIORITYf_SET BCM56218_A0_CPU_CONTROL_3r_CPU_MAC_LIMIT_PRIORITYf_SET
#define READ_CPU_CONTROL_3r BCM56218_A0_READ_CPU_CONTROL_3r
#define WRITE_CPU_CONTROL_3r BCM56218_A0_WRITE_CPU_CONTROL_3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CPU_CONTROL_3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CPU_COS_SEL
 * BLOCKS:   IPIPE
 * DESC:     CPU COS Select Register based on internal priority
 * SIZE:     32
 * FIELDS:
 *     COS0             COS 0 value
 *     COS1             COS 1 value
 *     COS2             COS 2 value
 *     COS3             COS 3 value
 *     COS4             COS 4 value
 *     COS5             COS 5 value
 *     COS6             COS 6 value
 *     COS7             COS 7 value
 *
 ******************************************************************************/
#define BCM56218_A0_CPU_COS_SELr 0x0e78012a

#define BCM56218_A0_CPU_COS_SELr_SIZE 4

/*
 * This structure should be used to declare and program CPU_COS_SEL.
 *
 */
typedef union BCM56218_A0_CPU_COS_SELr_s {
	uint32_t v[1];
	uint32_t cpu_cos_sel[1];
	uint32_t _cpu_cos_sel;
} BCM56218_A0_CPU_COS_SELr_t;

#define BCM56218_A0_CPU_COS_SELr_CLR(r) (r).cpu_cos_sel[0] = 0
#define BCM56218_A0_CPU_COS_SELr_SET(r,d) (r).cpu_cos_sel[0] = d
#define BCM56218_A0_CPU_COS_SELr_GET(r) (r).cpu_cos_sel[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CPU_COS_SELr_COS0f_GET(r) (((r).cpu_cos_sel[0]) & 0x7)
#define BCM56218_A0_CPU_COS_SELr_COS0f_SET(r,f) (r).cpu_cos_sel[0]=(((r).cpu_cos_sel[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM56218_A0_CPU_COS_SELr_COS1f_GET(r) ((((r).cpu_cos_sel[0]) >> 3) & 0x7)
#define BCM56218_A0_CPU_COS_SELr_COS1f_SET(r,f) (r).cpu_cos_sel[0]=(((r).cpu_cos_sel[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM56218_A0_CPU_COS_SELr_COS2f_GET(r) ((((r).cpu_cos_sel[0]) >> 6) & 0x7)
#define BCM56218_A0_CPU_COS_SELr_COS2f_SET(r,f) (r).cpu_cos_sel[0]=(((r).cpu_cos_sel[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM56218_A0_CPU_COS_SELr_COS3f_GET(r) ((((r).cpu_cos_sel[0]) >> 9) & 0x7)
#define BCM56218_A0_CPU_COS_SELr_COS3f_SET(r,f) (r).cpu_cos_sel[0]=(((r).cpu_cos_sel[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM56218_A0_CPU_COS_SELr_COS4f_GET(r) ((((r).cpu_cos_sel[0]) >> 12) & 0x7)
#define BCM56218_A0_CPU_COS_SELr_COS4f_SET(r,f) (r).cpu_cos_sel[0]=(((r).cpu_cos_sel[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM56218_A0_CPU_COS_SELr_COS5f_GET(r) ((((r).cpu_cos_sel[0]) >> 15) & 0x7)
#define BCM56218_A0_CPU_COS_SELr_COS5f_SET(r,f) (r).cpu_cos_sel[0]=(((r).cpu_cos_sel[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM56218_A0_CPU_COS_SELr_COS6f_GET(r) ((((r).cpu_cos_sel[0]) >> 18) & 0x7)
#define BCM56218_A0_CPU_COS_SELr_COS6f_SET(r,f) (r).cpu_cos_sel[0]=(((r).cpu_cos_sel[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM56218_A0_CPU_COS_SELr_COS7f_GET(r) ((((r).cpu_cos_sel[0]) >> 21) & 0x7)
#define BCM56218_A0_CPU_COS_SELr_COS7f_SET(r,f) (r).cpu_cos_sel[0]=(((r).cpu_cos_sel[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))

/*
 * These macros can be used to access CPU_COS_SEL.
 *
 */
#define BCM56218_A0_READ_CPU_COS_SELr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_CPU_COS_SELr,(r._cpu_cos_sel))
#define BCM56218_A0_WRITE_CPU_COS_SELr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_CPU_COS_SELr,&(r._cpu_cos_sel))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CPU_COS_SELr BCM56218_A0_CPU_COS_SELr
#define CPU_COS_SELr_SIZE BCM56218_A0_CPU_COS_SELr_SIZE
typedef BCM56218_A0_CPU_COS_SELr_t CPU_COS_SELr_t;
#define CPU_COS_SELr_CLR BCM56218_A0_CPU_COS_SELr_CLR
#define CPU_COS_SELr_SET BCM56218_A0_CPU_COS_SELr_SET
#define CPU_COS_SELr_GET BCM56218_A0_CPU_COS_SELr_GET
#define CPU_COS_SELr_COS0f_GET BCM56218_A0_CPU_COS_SELr_COS0f_GET
#define CPU_COS_SELr_COS0f_SET BCM56218_A0_CPU_COS_SELr_COS0f_SET
#define CPU_COS_SELr_COS1f_GET BCM56218_A0_CPU_COS_SELr_COS1f_GET
#define CPU_COS_SELr_COS1f_SET BCM56218_A0_CPU_COS_SELr_COS1f_SET
#define CPU_COS_SELr_COS2f_GET BCM56218_A0_CPU_COS_SELr_COS2f_GET
#define CPU_COS_SELr_COS2f_SET BCM56218_A0_CPU_COS_SELr_COS2f_SET
#define CPU_COS_SELr_COS3f_GET BCM56218_A0_CPU_COS_SELr_COS3f_GET
#define CPU_COS_SELr_COS3f_SET BCM56218_A0_CPU_COS_SELr_COS3f_SET
#define CPU_COS_SELr_COS4f_GET BCM56218_A0_CPU_COS_SELr_COS4f_GET
#define CPU_COS_SELr_COS4f_SET BCM56218_A0_CPU_COS_SELr_COS4f_SET
#define CPU_COS_SELr_COS5f_GET BCM56218_A0_CPU_COS_SELr_COS5f_GET
#define CPU_COS_SELr_COS5f_SET BCM56218_A0_CPU_COS_SELr_COS5f_SET
#define CPU_COS_SELr_COS6f_GET BCM56218_A0_CPU_COS_SELr_COS6f_GET
#define CPU_COS_SELr_COS6f_SET BCM56218_A0_CPU_COS_SELr_COS6f_SET
#define CPU_COS_SELr_COS7f_GET BCM56218_A0_CPU_COS_SELr_COS7f_GET
#define CPU_COS_SELr_COS7f_SET BCM56218_A0_CPU_COS_SELr_COS7f_SET
#define READ_CPU_COS_SELr BCM56218_A0_READ_CPU_COS_SELr
#define WRITE_CPU_COS_SELr BCM56218_A0_WRITE_CPU_COS_SELr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CPU_COS_SELr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CPU_COS_SEL_2
 * BLOCKS:   IPIPE
 * DESC:     CPU COS Select Register based on internal priority
 * SIZE:     32
 * FIELDS:
 *     COS8             COS value for priority 8 value
 *     COS9             COS value for priority 9 value
 *     COS10            COS value for priority 10 value
 *     COS11            COS value for priority 11 value
 *     COS12            COS value for priority 12 value
 *     COS13            COS value for priority 13 value
 *     COS14            COS value for priority 14 value
 *     COS15            COS value for priority 15 value
 *
 ******************************************************************************/
#define BCM56218_A0_CPU_COS_SEL_2r 0x0e780130

#define BCM56218_A0_CPU_COS_SEL_2r_SIZE 4

/*
 * This structure should be used to declare and program CPU_COS_SEL_2.
 *
 */
typedef union BCM56218_A0_CPU_COS_SEL_2r_s {
	uint32_t v[1];
	uint32_t cpu_cos_sel_2[1];
	uint32_t _cpu_cos_sel_2;
} BCM56218_A0_CPU_COS_SEL_2r_t;

#define BCM56218_A0_CPU_COS_SEL_2r_CLR(r) (r).cpu_cos_sel_2[0] = 0
#define BCM56218_A0_CPU_COS_SEL_2r_SET(r,d) (r).cpu_cos_sel_2[0] = d
#define BCM56218_A0_CPU_COS_SEL_2r_GET(r) (r).cpu_cos_sel_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CPU_COS_SEL_2r_COS8f_GET(r) (((r).cpu_cos_sel_2[0]) & 0x7)
#define BCM56218_A0_CPU_COS_SEL_2r_COS8f_SET(r,f) (r).cpu_cos_sel_2[0]=(((r).cpu_cos_sel_2[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM56218_A0_CPU_COS_SEL_2r_COS9f_GET(r) ((((r).cpu_cos_sel_2[0]) >> 3) & 0x7)
#define BCM56218_A0_CPU_COS_SEL_2r_COS9f_SET(r,f) (r).cpu_cos_sel_2[0]=(((r).cpu_cos_sel_2[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM56218_A0_CPU_COS_SEL_2r_COS10f_GET(r) ((((r).cpu_cos_sel_2[0]) >> 6) & 0x7)
#define BCM56218_A0_CPU_COS_SEL_2r_COS10f_SET(r,f) (r).cpu_cos_sel_2[0]=(((r).cpu_cos_sel_2[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM56218_A0_CPU_COS_SEL_2r_COS11f_GET(r) ((((r).cpu_cos_sel_2[0]) >> 9) & 0x7)
#define BCM56218_A0_CPU_COS_SEL_2r_COS11f_SET(r,f) (r).cpu_cos_sel_2[0]=(((r).cpu_cos_sel_2[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM56218_A0_CPU_COS_SEL_2r_COS12f_GET(r) ((((r).cpu_cos_sel_2[0]) >> 12) & 0x7)
#define BCM56218_A0_CPU_COS_SEL_2r_COS12f_SET(r,f) (r).cpu_cos_sel_2[0]=(((r).cpu_cos_sel_2[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM56218_A0_CPU_COS_SEL_2r_COS13f_GET(r) ((((r).cpu_cos_sel_2[0]) >> 15) & 0x7)
#define BCM56218_A0_CPU_COS_SEL_2r_COS13f_SET(r,f) (r).cpu_cos_sel_2[0]=(((r).cpu_cos_sel_2[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM56218_A0_CPU_COS_SEL_2r_COS14f_GET(r) ((((r).cpu_cos_sel_2[0]) >> 18) & 0x7)
#define BCM56218_A0_CPU_COS_SEL_2r_COS14f_SET(r,f) (r).cpu_cos_sel_2[0]=(((r).cpu_cos_sel_2[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM56218_A0_CPU_COS_SEL_2r_COS15f_GET(r) ((((r).cpu_cos_sel_2[0]) >> 21) & 0x7)
#define BCM56218_A0_CPU_COS_SEL_2r_COS15f_SET(r,f) (r).cpu_cos_sel_2[0]=(((r).cpu_cos_sel_2[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))

/*
 * These macros can be used to access CPU_COS_SEL_2.
 *
 */
#define BCM56218_A0_READ_CPU_COS_SEL_2r(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_CPU_COS_SEL_2r,(r._cpu_cos_sel_2))
#define BCM56218_A0_WRITE_CPU_COS_SEL_2r(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_CPU_COS_SEL_2r,&(r._cpu_cos_sel_2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CPU_COS_SEL_2r BCM56218_A0_CPU_COS_SEL_2r
#define CPU_COS_SEL_2r_SIZE BCM56218_A0_CPU_COS_SEL_2r_SIZE
typedef BCM56218_A0_CPU_COS_SEL_2r_t CPU_COS_SEL_2r_t;
#define CPU_COS_SEL_2r_CLR BCM56218_A0_CPU_COS_SEL_2r_CLR
#define CPU_COS_SEL_2r_SET BCM56218_A0_CPU_COS_SEL_2r_SET
#define CPU_COS_SEL_2r_GET BCM56218_A0_CPU_COS_SEL_2r_GET
#define CPU_COS_SEL_2r_COS8f_GET BCM56218_A0_CPU_COS_SEL_2r_COS8f_GET
#define CPU_COS_SEL_2r_COS8f_SET BCM56218_A0_CPU_COS_SEL_2r_COS8f_SET
#define CPU_COS_SEL_2r_COS9f_GET BCM56218_A0_CPU_COS_SEL_2r_COS9f_GET
#define CPU_COS_SEL_2r_COS9f_SET BCM56218_A0_CPU_COS_SEL_2r_COS9f_SET
#define CPU_COS_SEL_2r_COS10f_GET BCM56218_A0_CPU_COS_SEL_2r_COS10f_GET
#define CPU_COS_SEL_2r_COS10f_SET BCM56218_A0_CPU_COS_SEL_2r_COS10f_SET
#define CPU_COS_SEL_2r_COS11f_GET BCM56218_A0_CPU_COS_SEL_2r_COS11f_GET
#define CPU_COS_SEL_2r_COS11f_SET BCM56218_A0_CPU_COS_SEL_2r_COS11f_SET
#define CPU_COS_SEL_2r_COS12f_GET BCM56218_A0_CPU_COS_SEL_2r_COS12f_GET
#define CPU_COS_SEL_2r_COS12f_SET BCM56218_A0_CPU_COS_SEL_2r_COS12f_SET
#define CPU_COS_SEL_2r_COS13f_GET BCM56218_A0_CPU_COS_SEL_2r_COS13f_GET
#define CPU_COS_SEL_2r_COS13f_SET BCM56218_A0_CPU_COS_SEL_2r_COS13f_SET
#define CPU_COS_SEL_2r_COS14f_GET BCM56218_A0_CPU_COS_SEL_2r_COS14f_GET
#define CPU_COS_SEL_2r_COS14f_SET BCM56218_A0_CPU_COS_SEL_2r_COS14f_SET
#define CPU_COS_SEL_2r_COS15f_GET BCM56218_A0_CPU_COS_SEL_2r_COS15f_GET
#define CPU_COS_SEL_2r_COS15f_SET BCM56218_A0_CPU_COS_SEL_2r_COS15f_SET
#define READ_CPU_COS_SEL_2r BCM56218_A0_READ_CPU_COS_SEL_2r
#define WRITE_CPU_COS_SEL_2r BCM56218_A0_WRITE_CPU_COS_SEL_2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CPU_COS_SEL_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CPU_PRIORITY_SEL
 * BLOCKS:   IPIPE
 * DESC:     CPU Internal Priority Select Register
 * SIZE:     32
 * FIELDS:
 *     PRI0             Priority 0 value
 *     PRI1             Priority 1 value
 *     PRI2             Priority 2 value
 *     PRI3             Priority 3 value
 *     PRI4             Priority 4 value
 *     PRI5             Priority 5 value
 *     PRI6             Priority 6 value
 *     PRI7             Priority 7 value
 *
 ******************************************************************************/
#define BCM56218_A0_CPU_PRIORITY_SELr 0x0e780129

#define BCM56218_A0_CPU_PRIORITY_SELr_SIZE 4

/*
 * This structure should be used to declare and program CPU_PRIORITY_SEL.
 *
 */
typedef union BCM56218_A0_CPU_PRIORITY_SELr_s {
	uint32_t v[1];
	uint32_t cpu_priority_sel[1];
	uint32_t _cpu_priority_sel;
} BCM56218_A0_CPU_PRIORITY_SELr_t;

#define BCM56218_A0_CPU_PRIORITY_SELr_CLR(r) (r).cpu_priority_sel[0] = 0
#define BCM56218_A0_CPU_PRIORITY_SELr_SET(r,d) (r).cpu_priority_sel[0] = d
#define BCM56218_A0_CPU_PRIORITY_SELr_GET(r) (r).cpu_priority_sel[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CPU_PRIORITY_SELr_PRI0f_GET(r) (((r).cpu_priority_sel[0]) & 0xf)
#define BCM56218_A0_CPU_PRIORITY_SELr_PRI0f_SET(r,f) (r).cpu_priority_sel[0]=(((r).cpu_priority_sel[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56218_A0_CPU_PRIORITY_SELr_PRI1f_GET(r) ((((r).cpu_priority_sel[0]) >> 4) & 0xf)
#define BCM56218_A0_CPU_PRIORITY_SELr_PRI1f_SET(r,f) (r).cpu_priority_sel[0]=(((r).cpu_priority_sel[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56218_A0_CPU_PRIORITY_SELr_PRI2f_GET(r) ((((r).cpu_priority_sel[0]) >> 8) & 0xf)
#define BCM56218_A0_CPU_PRIORITY_SELr_PRI2f_SET(r,f) (r).cpu_priority_sel[0]=(((r).cpu_priority_sel[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM56218_A0_CPU_PRIORITY_SELr_PRI3f_GET(r) ((((r).cpu_priority_sel[0]) >> 12) & 0xf)
#define BCM56218_A0_CPU_PRIORITY_SELr_PRI3f_SET(r,f) (r).cpu_priority_sel[0]=(((r).cpu_priority_sel[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM56218_A0_CPU_PRIORITY_SELr_PRI4f_GET(r) ((((r).cpu_priority_sel[0]) >> 16) & 0xf)
#define BCM56218_A0_CPU_PRIORITY_SELr_PRI4f_SET(r,f) (r).cpu_priority_sel[0]=(((r).cpu_priority_sel[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM56218_A0_CPU_PRIORITY_SELr_PRI5f_GET(r) ((((r).cpu_priority_sel[0]) >> 20) & 0xf)
#define BCM56218_A0_CPU_PRIORITY_SELr_PRI5f_SET(r,f) (r).cpu_priority_sel[0]=(((r).cpu_priority_sel[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM56218_A0_CPU_PRIORITY_SELr_PRI6f_GET(r) ((((r).cpu_priority_sel[0]) >> 24) & 0xf)
#define BCM56218_A0_CPU_PRIORITY_SELr_PRI6f_SET(r,f) (r).cpu_priority_sel[0]=(((r).cpu_priority_sel[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM56218_A0_CPU_PRIORITY_SELr_PRI7f_GET(r) ((((r).cpu_priority_sel[0]) >> 28) & 0xf)
#define BCM56218_A0_CPU_PRIORITY_SELr_PRI7f_SET(r,f) (r).cpu_priority_sel[0]=(((r).cpu_priority_sel[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access CPU_PRIORITY_SEL.
 *
 */
#define BCM56218_A0_READ_CPU_PRIORITY_SELr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_CPU_PRIORITY_SELr,(r._cpu_priority_sel))
#define BCM56218_A0_WRITE_CPU_PRIORITY_SELr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_CPU_PRIORITY_SELr,&(r._cpu_priority_sel))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CPU_PRIORITY_SELr BCM56218_A0_CPU_PRIORITY_SELr
#define CPU_PRIORITY_SELr_SIZE BCM56218_A0_CPU_PRIORITY_SELr_SIZE
typedef BCM56218_A0_CPU_PRIORITY_SELr_t CPU_PRIORITY_SELr_t;
#define CPU_PRIORITY_SELr_CLR BCM56218_A0_CPU_PRIORITY_SELr_CLR
#define CPU_PRIORITY_SELr_SET BCM56218_A0_CPU_PRIORITY_SELr_SET
#define CPU_PRIORITY_SELr_GET BCM56218_A0_CPU_PRIORITY_SELr_GET
#define CPU_PRIORITY_SELr_PRI0f_GET BCM56218_A0_CPU_PRIORITY_SELr_PRI0f_GET
#define CPU_PRIORITY_SELr_PRI0f_SET BCM56218_A0_CPU_PRIORITY_SELr_PRI0f_SET
#define CPU_PRIORITY_SELr_PRI1f_GET BCM56218_A0_CPU_PRIORITY_SELr_PRI1f_GET
#define CPU_PRIORITY_SELr_PRI1f_SET BCM56218_A0_CPU_PRIORITY_SELr_PRI1f_SET
#define CPU_PRIORITY_SELr_PRI2f_GET BCM56218_A0_CPU_PRIORITY_SELr_PRI2f_GET
#define CPU_PRIORITY_SELr_PRI2f_SET BCM56218_A0_CPU_PRIORITY_SELr_PRI2f_SET
#define CPU_PRIORITY_SELr_PRI3f_GET BCM56218_A0_CPU_PRIORITY_SELr_PRI3f_GET
#define CPU_PRIORITY_SELr_PRI3f_SET BCM56218_A0_CPU_PRIORITY_SELr_PRI3f_SET
#define CPU_PRIORITY_SELr_PRI4f_GET BCM56218_A0_CPU_PRIORITY_SELr_PRI4f_GET
#define CPU_PRIORITY_SELr_PRI4f_SET BCM56218_A0_CPU_PRIORITY_SELr_PRI4f_SET
#define CPU_PRIORITY_SELr_PRI5f_GET BCM56218_A0_CPU_PRIORITY_SELr_PRI5f_GET
#define CPU_PRIORITY_SELr_PRI5f_SET BCM56218_A0_CPU_PRIORITY_SELr_PRI5f_SET
#define CPU_PRIORITY_SELr_PRI6f_GET BCM56218_A0_CPU_PRIORITY_SELr_PRI6f_GET
#define CPU_PRIORITY_SELr_PRI6f_SET BCM56218_A0_CPU_PRIORITY_SELr_PRI6f_SET
#define CPU_PRIORITY_SELr_PRI7f_GET BCM56218_A0_CPU_PRIORITY_SELr_PRI7f_GET
#define CPU_PRIORITY_SELr_PRI7f_SET BCM56218_A0_CPU_PRIORITY_SELr_PRI7f_SET
#define READ_CPU_PRIORITY_SELr BCM56218_A0_READ_CPU_PRIORITY_SELr
#define WRITE_CPU_PRIORITY_SELr BCM56218_A0_WRITE_CPU_PRIORITY_SELr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CPU_PRIORITY_SELr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  CPU_PRIORITY_SEL_2
 * BLOCKS:   IPIPE
 * DESC:     CPU Internal Priority Select Register
 * SIZE:     32
 * FIELDS:
 *     PRI8             Priority 8 value
 *     PRI9             Priority 9 value
 *     PRI10            Priority 10 value
 *     PRI11            Priority 11 value
 *     PRI12            Priority 12 value
 *     PRI13            Priority 13 value
 *     PRI14            Priority 14 value
 *     PRI15            Priority 15 value
 *
 ******************************************************************************/
#define BCM56218_A0_CPU_PRIORITY_SEL_2r 0x0e78012e

#define BCM56218_A0_CPU_PRIORITY_SEL_2r_SIZE 4

/*
 * This structure should be used to declare and program CPU_PRIORITY_SEL_2.
 *
 */
typedef union BCM56218_A0_CPU_PRIORITY_SEL_2r_s {
	uint32_t v[1];
	uint32_t cpu_priority_sel_2[1];
	uint32_t _cpu_priority_sel_2;
} BCM56218_A0_CPU_PRIORITY_SEL_2r_t;

#define BCM56218_A0_CPU_PRIORITY_SEL_2r_CLR(r) (r).cpu_priority_sel_2[0] = 0
#define BCM56218_A0_CPU_PRIORITY_SEL_2r_SET(r,d) (r).cpu_priority_sel_2[0] = d
#define BCM56218_A0_CPU_PRIORITY_SEL_2r_GET(r) (r).cpu_priority_sel_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_CPU_PRIORITY_SEL_2r_PRI8f_GET(r) (((r).cpu_priority_sel_2[0]) & 0xf)
#define BCM56218_A0_CPU_PRIORITY_SEL_2r_PRI8f_SET(r,f) (r).cpu_priority_sel_2[0]=(((r).cpu_priority_sel_2[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56218_A0_CPU_PRIORITY_SEL_2r_PRI9f_GET(r) ((((r).cpu_priority_sel_2[0]) >> 4) & 0xf)
#define BCM56218_A0_CPU_PRIORITY_SEL_2r_PRI9f_SET(r,f) (r).cpu_priority_sel_2[0]=(((r).cpu_priority_sel_2[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56218_A0_CPU_PRIORITY_SEL_2r_PRI10f_GET(r) ((((r).cpu_priority_sel_2[0]) >> 8) & 0xf)
#define BCM56218_A0_CPU_PRIORITY_SEL_2r_PRI10f_SET(r,f) (r).cpu_priority_sel_2[0]=(((r).cpu_priority_sel_2[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM56218_A0_CPU_PRIORITY_SEL_2r_PRI11f_GET(r) ((((r).cpu_priority_sel_2[0]) >> 12) & 0xf)
#define BCM56218_A0_CPU_PRIORITY_SEL_2r_PRI11f_SET(r,f) (r).cpu_priority_sel_2[0]=(((r).cpu_priority_sel_2[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM56218_A0_CPU_PRIORITY_SEL_2r_PRI12f_GET(r) ((((r).cpu_priority_sel_2[0]) >> 16) & 0xf)
#define BCM56218_A0_CPU_PRIORITY_SEL_2r_PRI12f_SET(r,f) (r).cpu_priority_sel_2[0]=(((r).cpu_priority_sel_2[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM56218_A0_CPU_PRIORITY_SEL_2r_PRI13f_GET(r) ((((r).cpu_priority_sel_2[0]) >> 20) & 0xf)
#define BCM56218_A0_CPU_PRIORITY_SEL_2r_PRI13f_SET(r,f) (r).cpu_priority_sel_2[0]=(((r).cpu_priority_sel_2[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM56218_A0_CPU_PRIORITY_SEL_2r_PRI14f_GET(r) ((((r).cpu_priority_sel_2[0]) >> 24) & 0xf)
#define BCM56218_A0_CPU_PRIORITY_SEL_2r_PRI14f_SET(r,f) (r).cpu_priority_sel_2[0]=(((r).cpu_priority_sel_2[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM56218_A0_CPU_PRIORITY_SEL_2r_PRI15f_GET(r) ((((r).cpu_priority_sel_2[0]) >> 28) & 0xf)
#define BCM56218_A0_CPU_PRIORITY_SEL_2r_PRI15f_SET(r,f) (r).cpu_priority_sel_2[0]=(((r).cpu_priority_sel_2[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access CPU_PRIORITY_SEL_2.
 *
 */
#define BCM56218_A0_READ_CPU_PRIORITY_SEL_2r(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_CPU_PRIORITY_SEL_2r,(r._cpu_priority_sel_2))
#define BCM56218_A0_WRITE_CPU_PRIORITY_SEL_2r(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_CPU_PRIORITY_SEL_2r,&(r._cpu_priority_sel_2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CPU_PRIORITY_SEL_2r BCM56218_A0_CPU_PRIORITY_SEL_2r
#define CPU_PRIORITY_SEL_2r_SIZE BCM56218_A0_CPU_PRIORITY_SEL_2r_SIZE
typedef BCM56218_A0_CPU_PRIORITY_SEL_2r_t CPU_PRIORITY_SEL_2r_t;
#define CPU_PRIORITY_SEL_2r_CLR BCM56218_A0_CPU_PRIORITY_SEL_2r_CLR
#define CPU_PRIORITY_SEL_2r_SET BCM56218_A0_CPU_PRIORITY_SEL_2r_SET
#define CPU_PRIORITY_SEL_2r_GET BCM56218_A0_CPU_PRIORITY_SEL_2r_GET
#define CPU_PRIORITY_SEL_2r_PRI8f_GET BCM56218_A0_CPU_PRIORITY_SEL_2r_PRI8f_GET
#define CPU_PRIORITY_SEL_2r_PRI8f_SET BCM56218_A0_CPU_PRIORITY_SEL_2r_PRI8f_SET
#define CPU_PRIORITY_SEL_2r_PRI9f_GET BCM56218_A0_CPU_PRIORITY_SEL_2r_PRI9f_GET
#define CPU_PRIORITY_SEL_2r_PRI9f_SET BCM56218_A0_CPU_PRIORITY_SEL_2r_PRI9f_SET
#define CPU_PRIORITY_SEL_2r_PRI10f_GET BCM56218_A0_CPU_PRIORITY_SEL_2r_PRI10f_GET
#define CPU_PRIORITY_SEL_2r_PRI10f_SET BCM56218_A0_CPU_PRIORITY_SEL_2r_PRI10f_SET
#define CPU_PRIORITY_SEL_2r_PRI11f_GET BCM56218_A0_CPU_PRIORITY_SEL_2r_PRI11f_GET
#define CPU_PRIORITY_SEL_2r_PRI11f_SET BCM56218_A0_CPU_PRIORITY_SEL_2r_PRI11f_SET
#define CPU_PRIORITY_SEL_2r_PRI12f_GET BCM56218_A0_CPU_PRIORITY_SEL_2r_PRI12f_GET
#define CPU_PRIORITY_SEL_2r_PRI12f_SET BCM56218_A0_CPU_PRIORITY_SEL_2r_PRI12f_SET
#define CPU_PRIORITY_SEL_2r_PRI13f_GET BCM56218_A0_CPU_PRIORITY_SEL_2r_PRI13f_GET
#define CPU_PRIORITY_SEL_2r_PRI13f_SET BCM56218_A0_CPU_PRIORITY_SEL_2r_PRI13f_SET
#define CPU_PRIORITY_SEL_2r_PRI14f_GET BCM56218_A0_CPU_PRIORITY_SEL_2r_PRI14f_GET
#define CPU_PRIORITY_SEL_2r_PRI14f_SET BCM56218_A0_CPU_PRIORITY_SEL_2r_PRI14f_SET
#define CPU_PRIORITY_SEL_2r_PRI15f_GET BCM56218_A0_CPU_PRIORITY_SEL_2r_PRI15f_GET
#define CPU_PRIORITY_SEL_2r_PRI15f_SET BCM56218_A0_CPU_PRIORITY_SEL_2r_PRI15f_SET
#define READ_CPU_PRIORITY_SEL_2r BCM56218_A0_READ_CPU_PRIORITY_SEL_2r
#define WRITE_CPU_PRIORITY_SEL_2r BCM56218_A0_WRITE_CPU_PRIORITY_SEL_2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_CPU_PRIORITY_SEL_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  DLFBC_STORM_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     Ethernet DLF Rate Control Registers
 * SIZE:     32
 * FIELDS:
 *     THRESHOLD        Rate Limit, count as number of packets
 *     ENABLE           DLF rate control enable
 *
 ******************************************************************************/
#define BCM56218_A0_DLFBC_STORM_CONTROLr 0x0b700003

#define BCM56218_A0_DLFBC_STORM_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program DLFBC_STORM_CONTROL.
 *
 */
typedef union BCM56218_A0_DLFBC_STORM_CONTROLr_s {
	uint32_t v[1];
	uint32_t dlfbc_storm_control[1];
	uint32_t _dlfbc_storm_control;
} BCM56218_A0_DLFBC_STORM_CONTROLr_t;

#define BCM56218_A0_DLFBC_STORM_CONTROLr_CLR(r) (r).dlfbc_storm_control[0] = 0
#define BCM56218_A0_DLFBC_STORM_CONTROLr_SET(r,d) (r).dlfbc_storm_control[0] = d
#define BCM56218_A0_DLFBC_STORM_CONTROLr_GET(r) (r).dlfbc_storm_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_DLFBC_STORM_CONTROLr_THRESHOLDf_GET(r) (((r).dlfbc_storm_control[0]) & 0x1ffffff)
#define BCM56218_A0_DLFBC_STORM_CONTROLr_THRESHOLDf_SET(r,f) (r).dlfbc_storm_control[0]=(((r).dlfbc_storm_control[0] & ~((uint32_t)0x1ffffff)) | (((uint32_t)f) & 0x1ffffff))
#define BCM56218_A0_DLFBC_STORM_CONTROLr_ENABLEf_GET(r) ((((r).dlfbc_storm_control[0]) >> 25) & 0x1)
#define BCM56218_A0_DLFBC_STORM_CONTROLr_ENABLEf_SET(r,f) (r).dlfbc_storm_control[0]=(((r).dlfbc_storm_control[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))

/*
 * These macros can be used to access DLFBC_STORM_CONTROL.
 *
 */
#define BCM56218_A0_READ_DLFBC_STORM_CONTROLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_DLFBC_STORM_CONTROLr,(r._dlfbc_storm_control))
#define BCM56218_A0_WRITE_DLFBC_STORM_CONTROLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_DLFBC_STORM_CONTROLr,&(r._dlfbc_storm_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DLFBC_STORM_CONTROLr BCM56218_A0_DLFBC_STORM_CONTROLr
#define DLFBC_STORM_CONTROLr_SIZE BCM56218_A0_DLFBC_STORM_CONTROLr_SIZE
typedef BCM56218_A0_DLFBC_STORM_CONTROLr_t DLFBC_STORM_CONTROLr_t;
#define DLFBC_STORM_CONTROLr_CLR BCM56218_A0_DLFBC_STORM_CONTROLr_CLR
#define DLFBC_STORM_CONTROLr_SET BCM56218_A0_DLFBC_STORM_CONTROLr_SET
#define DLFBC_STORM_CONTROLr_GET BCM56218_A0_DLFBC_STORM_CONTROLr_GET
#define DLFBC_STORM_CONTROLr_THRESHOLDf_GET BCM56218_A0_DLFBC_STORM_CONTROLr_THRESHOLDf_GET
#define DLFBC_STORM_CONTROLr_THRESHOLDf_SET BCM56218_A0_DLFBC_STORM_CONTROLr_THRESHOLDf_SET
#define DLFBC_STORM_CONTROLr_ENABLEf_GET BCM56218_A0_DLFBC_STORM_CONTROLr_ENABLEf_GET
#define DLFBC_STORM_CONTROLr_ENABLEf_SET BCM56218_A0_DLFBC_STORM_CONTROLr_ENABLEf_SET
#define READ_DLFBC_STORM_CONTROLr BCM56218_A0_READ_DLFBC_STORM_CONTROLr
#define WRITE_DLFBC_STORM_CONTROLr BCM56218_A0_WRITE_DLFBC_STORM_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_DLFBC_STORM_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  DOS_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     DOS (Denial of Service) Attack Control Register
 * SIZE:     32
 * FIELDS:
 *     RESERVED0        RESERVED Enable ICMP DOS attack checks
 *     RESERVED1        RESERVED Enable checking TCP DOS fragment attack
 *     RESERVED2        RESERVED Enable checking TCP/UDP DOS attack for dropping packet if TCP/UDP source port == destination port
 *     MACSA_EQUALS_MACDA_DROP Drop MACSA == MACDA
 *     IPV4_FIRST_FRAG_CHECK_ENABLE Enable checking DOS attacks on IP first fragments
 *     BIG_ICMP_PKT_SIZE Maximum length ICMP packet allowed before dropping (maximum 16k bytes)
 *     MIN_TCPHDR_SIZE  Minimum TCP header length allowed (minimum 0 bytes, maximum 255 bytes)
 *     DROP_IF_SIP_EQUALS_DIP Drop IPv4/IPv6 packets if the SIP == DIP
 *     TCP_FLAGS_SYN_FRAG_ENABLE TCP SYN Packet with Source Port 0-1023 for non-first fragments tcp/udp port values are always zero and will match this condition and WILL BE DROPPED
 *     TCP_FLAGS_CTRL0_SEQ0_ENABLE TCP Packets with control flags == 0 && sequence number == 0 will be dropped
 *
 ******************************************************************************/
#define BCM56218_A0_DOS_CONTROLr 0x01780001

#define BCM56218_A0_DOS_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program DOS_CONTROL.
 *
 */
typedef union BCM56218_A0_DOS_CONTROLr_s {
	uint32_t v[1];
	uint32_t dos_control[1];
	uint32_t _dos_control;
} BCM56218_A0_DOS_CONTROLr_t;

#define BCM56218_A0_DOS_CONTROLr_CLR(r) (r).dos_control[0] = 0
#define BCM56218_A0_DOS_CONTROLr_SET(r,d) (r).dos_control[0] = d
#define BCM56218_A0_DOS_CONTROLr_GET(r) (r).dos_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_DOS_CONTROLr_RESERVED0f_GET(r) (((r).dos_control[0]) & 0x1)
#define BCM56218_A0_DOS_CONTROLr_RESERVED0f_SET(r,f) (r).dos_control[0]=(((r).dos_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_DOS_CONTROLr_RESERVED1f_GET(r) ((((r).dos_control[0]) >> 1) & 0x1)
#define BCM56218_A0_DOS_CONTROLr_RESERVED1f_SET(r,f) (r).dos_control[0]=(((r).dos_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_DOS_CONTROLr_RESERVED2f_GET(r) ((((r).dos_control[0]) >> 2) & 0x1)
#define BCM56218_A0_DOS_CONTROLr_RESERVED2f_SET(r,f) (r).dos_control[0]=(((r).dos_control[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_DOS_CONTROLr_MACSA_EQUALS_MACDA_DROPf_GET(r) ((((r).dos_control[0]) >> 3) & 0x1)
#define BCM56218_A0_DOS_CONTROLr_MACSA_EQUALS_MACDA_DROPf_SET(r,f) (r).dos_control[0]=(((r).dos_control[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56218_A0_DOS_CONTROLr_IPV4_FIRST_FRAG_CHECK_ENABLEf_GET(r) ((((r).dos_control[0]) >> 4) & 0x1)
#define BCM56218_A0_DOS_CONTROLr_IPV4_FIRST_FRAG_CHECK_ENABLEf_SET(r,f) (r).dos_control[0]=(((r).dos_control[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56218_A0_DOS_CONTROLr_BIG_ICMP_PKT_SIZEf_GET(r) ((((r).dos_control[0]) >> 5) & 0xffff)
#define BCM56218_A0_DOS_CONTROLr_BIG_ICMP_PKT_SIZEf_SET(r,f) (r).dos_control[0]=(((r).dos_control[0] & ~((uint32_t)0xffff << 5)) | ((((uint32_t)f) & 0xffff) << 5))
#define BCM56218_A0_DOS_CONTROLr_MIN_TCPHDR_SIZEf_GET(r) ((((r).dos_control[0]) >> 21) & 0xff)
#define BCM56218_A0_DOS_CONTROLr_MIN_TCPHDR_SIZEf_SET(r,f) (r).dos_control[0]=(((r).dos_control[0] & ~((uint32_t)0xff << 21)) | ((((uint32_t)f) & 0xff) << 21))
#define BCM56218_A0_DOS_CONTROLr_DROP_IF_SIP_EQUALS_DIPf_GET(r) ((((r).dos_control[0]) >> 29) & 0x1)
#define BCM56218_A0_DOS_CONTROLr_DROP_IF_SIP_EQUALS_DIPf_SET(r,f) (r).dos_control[0]=(((r).dos_control[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM56218_A0_DOS_CONTROLr_TCP_FLAGS_SYN_FRAG_ENABLEf_GET(r) ((((r).dos_control[0]) >> 30) & 0x1)
#define BCM56218_A0_DOS_CONTROLr_TCP_FLAGS_SYN_FRAG_ENABLEf_SET(r,f) (r).dos_control[0]=(((r).dos_control[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM56218_A0_DOS_CONTROLr_TCP_FLAGS_CTRL0_SEQ0_ENABLEf_GET(r) ((((r).dos_control[0]) >> 31) & 0x1)
#define BCM56218_A0_DOS_CONTROLr_TCP_FLAGS_CTRL0_SEQ0_ENABLEf_SET(r,f) (r).dos_control[0]=(((r).dos_control[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access DOS_CONTROL.
 *
 */
#define BCM56218_A0_READ_DOS_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_DOS_CONTROLr,(r._dos_control))
#define BCM56218_A0_WRITE_DOS_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_DOS_CONTROLr,&(r._dos_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DOS_CONTROLr BCM56218_A0_DOS_CONTROLr
#define DOS_CONTROLr_SIZE BCM56218_A0_DOS_CONTROLr_SIZE
typedef BCM56218_A0_DOS_CONTROLr_t DOS_CONTROLr_t;
#define DOS_CONTROLr_CLR BCM56218_A0_DOS_CONTROLr_CLR
#define DOS_CONTROLr_SET BCM56218_A0_DOS_CONTROLr_SET
#define DOS_CONTROLr_GET BCM56218_A0_DOS_CONTROLr_GET
#define DOS_CONTROLr_RESERVED0f_GET BCM56218_A0_DOS_CONTROLr_RESERVED0f_GET
#define DOS_CONTROLr_RESERVED0f_SET BCM56218_A0_DOS_CONTROLr_RESERVED0f_SET
#define DOS_CONTROLr_RESERVED1f_GET BCM56218_A0_DOS_CONTROLr_RESERVED1f_GET
#define DOS_CONTROLr_RESERVED1f_SET BCM56218_A0_DOS_CONTROLr_RESERVED1f_SET
#define DOS_CONTROLr_RESERVED2f_GET BCM56218_A0_DOS_CONTROLr_RESERVED2f_GET
#define DOS_CONTROLr_RESERVED2f_SET BCM56218_A0_DOS_CONTROLr_RESERVED2f_SET
#define DOS_CONTROLr_MACSA_EQUALS_MACDA_DROPf_GET BCM56218_A0_DOS_CONTROLr_MACSA_EQUALS_MACDA_DROPf_GET
#define DOS_CONTROLr_MACSA_EQUALS_MACDA_DROPf_SET BCM56218_A0_DOS_CONTROLr_MACSA_EQUALS_MACDA_DROPf_SET
#define DOS_CONTROLr_IPV4_FIRST_FRAG_CHECK_ENABLEf_GET BCM56218_A0_DOS_CONTROLr_IPV4_FIRST_FRAG_CHECK_ENABLEf_GET
#define DOS_CONTROLr_IPV4_FIRST_FRAG_CHECK_ENABLEf_SET BCM56218_A0_DOS_CONTROLr_IPV4_FIRST_FRAG_CHECK_ENABLEf_SET
#define DOS_CONTROLr_BIG_ICMP_PKT_SIZEf_GET BCM56218_A0_DOS_CONTROLr_BIG_ICMP_PKT_SIZEf_GET
#define DOS_CONTROLr_BIG_ICMP_PKT_SIZEf_SET BCM56218_A0_DOS_CONTROLr_BIG_ICMP_PKT_SIZEf_SET
#define DOS_CONTROLr_MIN_TCPHDR_SIZEf_GET BCM56218_A0_DOS_CONTROLr_MIN_TCPHDR_SIZEf_GET
#define DOS_CONTROLr_MIN_TCPHDR_SIZEf_SET BCM56218_A0_DOS_CONTROLr_MIN_TCPHDR_SIZEf_SET
#define DOS_CONTROLr_DROP_IF_SIP_EQUALS_DIPf_GET BCM56218_A0_DOS_CONTROLr_DROP_IF_SIP_EQUALS_DIPf_GET
#define DOS_CONTROLr_DROP_IF_SIP_EQUALS_DIPf_SET BCM56218_A0_DOS_CONTROLr_DROP_IF_SIP_EQUALS_DIPf_SET
#define DOS_CONTROLr_TCP_FLAGS_SYN_FRAG_ENABLEf_GET BCM56218_A0_DOS_CONTROLr_TCP_FLAGS_SYN_FRAG_ENABLEf_GET
#define DOS_CONTROLr_TCP_FLAGS_SYN_FRAG_ENABLEf_SET BCM56218_A0_DOS_CONTROLr_TCP_FLAGS_SYN_FRAG_ENABLEf_SET
#define DOS_CONTROLr_TCP_FLAGS_CTRL0_SEQ0_ENABLEf_GET BCM56218_A0_DOS_CONTROLr_TCP_FLAGS_CTRL0_SEQ0_ENABLEf_GET
#define DOS_CONTROLr_TCP_FLAGS_CTRL0_SEQ0_ENABLEf_SET BCM56218_A0_DOS_CONTROLr_TCP_FLAGS_CTRL0_SEQ0_ENABLEf_SET
#define READ_DOS_CONTROLr BCM56218_A0_READ_DOS_CONTROLr
#define WRITE_DOS_CONTROLr BCM56218_A0_WRITE_DOS_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_DOS_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  DOS_CONTROL_2
 * BLOCKS:   IPIPE
 * DESC:     DOS (Denial of Service) Attack Control Register #2
 * SIZE:     32
 * FIELDS:
 *     BIG_ICMPV6_PKT_SIZE Maximum length ICMPv6 ping packet allowed before dropping (maximum 16k bytes)
 *     TCP_FLAGS_FIN_URG_PSH_SEQ0_ENABLE TCP Packets with FIN,URG & PSH bits set & seq. number == 0
 *     TCP_FLAGS_SYN_FIN_ENABLE TCP Packets with SYN & FIN bits set
 *     TCP_SPORT_EQ_DPORT_ENABLE BLAT - TCP Packets with SPORT = DPORT
 *     UDP_SPORT_EQ_DPORT_ENABLE BLAT - UDP Packets with SPORT = DPORT
 *     TCP_HDR_PARTIAL_ENABLE FIRST TCP fragments that don't have the full TCP header. defined as the smaller than DOS_CONTROL.MIN_TCPHDR_SIZE programmed
 *     TCP_HDR_OFFSET_EQ1_ENABLE TCP fragments with offset value of 1 fragment offset values are programmed in 8byte increments. The value of 1 means 8bytes
 *     ICMP_V6_PING_SIZE_ENABLE ICMPV6 ping packets with payload size greater than the programmable value in DOS_CONTROL.BIG_ICMP_PKT_SIZE.
 *     ICMP_V4_PING_SIZE_ENABLE ICMPV6 ping packets with payload size greater than the programmable value in DOS_CONTROL.BIG_ICMP_PKT_SIZE
 *     ICMP_FRAG_PKTS_ENABLE Fragmented ICMP packets
 *
 ******************************************************************************/
#define BCM56218_A0_DOS_CONTROL_2r 0x01780002

#define BCM56218_A0_DOS_CONTROL_2r_SIZE 4

/*
 * This structure should be used to declare and program DOS_CONTROL_2.
 *
 */
typedef union BCM56218_A0_DOS_CONTROL_2r_s {
	uint32_t v[1];
	uint32_t dos_control_2[1];
	uint32_t _dos_control_2;
} BCM56218_A0_DOS_CONTROL_2r_t;

#define BCM56218_A0_DOS_CONTROL_2r_CLR(r) (r).dos_control_2[0] = 0
#define BCM56218_A0_DOS_CONTROL_2r_SET(r,d) (r).dos_control_2[0] = d
#define BCM56218_A0_DOS_CONTROL_2r_GET(r) (r).dos_control_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_DOS_CONTROL_2r_BIG_ICMPV6_PKT_SIZEf_GET(r) (((r).dos_control_2[0]) & 0xffff)
#define BCM56218_A0_DOS_CONTROL_2r_BIG_ICMPV6_PKT_SIZEf_SET(r,f) (r).dos_control_2[0]=(((r).dos_control_2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56218_A0_DOS_CONTROL_2r_TCP_FLAGS_FIN_URG_PSH_SEQ0_ENABLEf_GET(r) ((((r).dos_control_2[0]) >> 16) & 0x1)
#define BCM56218_A0_DOS_CONTROL_2r_TCP_FLAGS_FIN_URG_PSH_SEQ0_ENABLEf_SET(r,f) (r).dos_control_2[0]=(((r).dos_control_2[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56218_A0_DOS_CONTROL_2r_TCP_FLAGS_SYN_FIN_ENABLEf_GET(r) ((((r).dos_control_2[0]) >> 17) & 0x1)
#define BCM56218_A0_DOS_CONTROL_2r_TCP_FLAGS_SYN_FIN_ENABLEf_SET(r,f) (r).dos_control_2[0]=(((r).dos_control_2[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_DOS_CONTROL_2r_TCP_SPORT_EQ_DPORT_ENABLEf_GET(r) ((((r).dos_control_2[0]) >> 18) & 0x1)
#define BCM56218_A0_DOS_CONTROL_2r_TCP_SPORT_EQ_DPORT_ENABLEf_SET(r,f) (r).dos_control_2[0]=(((r).dos_control_2[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_DOS_CONTROL_2r_UDP_SPORT_EQ_DPORT_ENABLEf_GET(r) ((((r).dos_control_2[0]) >> 19) & 0x1)
#define BCM56218_A0_DOS_CONTROL_2r_UDP_SPORT_EQ_DPORT_ENABLEf_SET(r,f) (r).dos_control_2[0]=(((r).dos_control_2[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56218_A0_DOS_CONTROL_2r_TCP_HDR_PARTIAL_ENABLEf_GET(r) ((((r).dos_control_2[0]) >> 20) & 0x1)
#define BCM56218_A0_DOS_CONTROL_2r_TCP_HDR_PARTIAL_ENABLEf_SET(r,f) (r).dos_control_2[0]=(((r).dos_control_2[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM56218_A0_DOS_CONTROL_2r_TCP_HDR_OFFSET_EQ1_ENABLEf_GET(r) ((((r).dos_control_2[0]) >> 21) & 0x1)
#define BCM56218_A0_DOS_CONTROL_2r_TCP_HDR_OFFSET_EQ1_ENABLEf_SET(r,f) (r).dos_control_2[0]=(((r).dos_control_2[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM56218_A0_DOS_CONTROL_2r_ICMP_V6_PING_SIZE_ENABLEf_GET(r) ((((r).dos_control_2[0]) >> 22) & 0x1)
#define BCM56218_A0_DOS_CONTROL_2r_ICMP_V6_PING_SIZE_ENABLEf_SET(r,f) (r).dos_control_2[0]=(((r).dos_control_2[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM56218_A0_DOS_CONTROL_2r_ICMP_V4_PING_SIZE_ENABLEf_GET(r) ((((r).dos_control_2[0]) >> 23) & 0x1)
#define BCM56218_A0_DOS_CONTROL_2r_ICMP_V4_PING_SIZE_ENABLEf_SET(r,f) (r).dos_control_2[0]=(((r).dos_control_2[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM56218_A0_DOS_CONTROL_2r_ICMP_FRAG_PKTS_ENABLEf_GET(r) ((((r).dos_control_2[0]) >> 24) & 0x1)
#define BCM56218_A0_DOS_CONTROL_2r_ICMP_FRAG_PKTS_ENABLEf_SET(r,f) (r).dos_control_2[0]=(((r).dos_control_2[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))

/*
 * These macros can be used to access DOS_CONTROL_2.
 *
 */
#define BCM56218_A0_READ_DOS_CONTROL_2r(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_DOS_CONTROL_2r,(r._dos_control_2))
#define BCM56218_A0_WRITE_DOS_CONTROL_2r(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_DOS_CONTROL_2r,&(r._dos_control_2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DOS_CONTROL_2r BCM56218_A0_DOS_CONTROL_2r
#define DOS_CONTROL_2r_SIZE BCM56218_A0_DOS_CONTROL_2r_SIZE
typedef BCM56218_A0_DOS_CONTROL_2r_t DOS_CONTROL_2r_t;
#define DOS_CONTROL_2r_CLR BCM56218_A0_DOS_CONTROL_2r_CLR
#define DOS_CONTROL_2r_SET BCM56218_A0_DOS_CONTROL_2r_SET
#define DOS_CONTROL_2r_GET BCM56218_A0_DOS_CONTROL_2r_GET
#define DOS_CONTROL_2r_BIG_ICMPV6_PKT_SIZEf_GET BCM56218_A0_DOS_CONTROL_2r_BIG_ICMPV6_PKT_SIZEf_GET
#define DOS_CONTROL_2r_BIG_ICMPV6_PKT_SIZEf_SET BCM56218_A0_DOS_CONTROL_2r_BIG_ICMPV6_PKT_SIZEf_SET
#define DOS_CONTROL_2r_TCP_FLAGS_FIN_URG_PSH_SEQ0_ENABLEf_GET BCM56218_A0_DOS_CONTROL_2r_TCP_FLAGS_FIN_URG_PSH_SEQ0_ENABLEf_GET
#define DOS_CONTROL_2r_TCP_FLAGS_FIN_URG_PSH_SEQ0_ENABLEf_SET BCM56218_A0_DOS_CONTROL_2r_TCP_FLAGS_FIN_URG_PSH_SEQ0_ENABLEf_SET
#define DOS_CONTROL_2r_TCP_FLAGS_SYN_FIN_ENABLEf_GET BCM56218_A0_DOS_CONTROL_2r_TCP_FLAGS_SYN_FIN_ENABLEf_GET
#define DOS_CONTROL_2r_TCP_FLAGS_SYN_FIN_ENABLEf_SET BCM56218_A0_DOS_CONTROL_2r_TCP_FLAGS_SYN_FIN_ENABLEf_SET
#define DOS_CONTROL_2r_TCP_SPORT_EQ_DPORT_ENABLEf_GET BCM56218_A0_DOS_CONTROL_2r_TCP_SPORT_EQ_DPORT_ENABLEf_GET
#define DOS_CONTROL_2r_TCP_SPORT_EQ_DPORT_ENABLEf_SET BCM56218_A0_DOS_CONTROL_2r_TCP_SPORT_EQ_DPORT_ENABLEf_SET
#define DOS_CONTROL_2r_UDP_SPORT_EQ_DPORT_ENABLEf_GET BCM56218_A0_DOS_CONTROL_2r_UDP_SPORT_EQ_DPORT_ENABLEf_GET
#define DOS_CONTROL_2r_UDP_SPORT_EQ_DPORT_ENABLEf_SET BCM56218_A0_DOS_CONTROL_2r_UDP_SPORT_EQ_DPORT_ENABLEf_SET
#define DOS_CONTROL_2r_TCP_HDR_PARTIAL_ENABLEf_GET BCM56218_A0_DOS_CONTROL_2r_TCP_HDR_PARTIAL_ENABLEf_GET
#define DOS_CONTROL_2r_TCP_HDR_PARTIAL_ENABLEf_SET BCM56218_A0_DOS_CONTROL_2r_TCP_HDR_PARTIAL_ENABLEf_SET
#define DOS_CONTROL_2r_TCP_HDR_OFFSET_EQ1_ENABLEf_GET BCM56218_A0_DOS_CONTROL_2r_TCP_HDR_OFFSET_EQ1_ENABLEf_GET
#define DOS_CONTROL_2r_TCP_HDR_OFFSET_EQ1_ENABLEf_SET BCM56218_A0_DOS_CONTROL_2r_TCP_HDR_OFFSET_EQ1_ENABLEf_SET
#define DOS_CONTROL_2r_ICMP_V6_PING_SIZE_ENABLEf_GET BCM56218_A0_DOS_CONTROL_2r_ICMP_V6_PING_SIZE_ENABLEf_GET
#define DOS_CONTROL_2r_ICMP_V6_PING_SIZE_ENABLEf_SET BCM56218_A0_DOS_CONTROL_2r_ICMP_V6_PING_SIZE_ENABLEf_SET
#define DOS_CONTROL_2r_ICMP_V4_PING_SIZE_ENABLEf_GET BCM56218_A0_DOS_CONTROL_2r_ICMP_V4_PING_SIZE_ENABLEf_GET
#define DOS_CONTROL_2r_ICMP_V4_PING_SIZE_ENABLEf_SET BCM56218_A0_DOS_CONTROL_2r_ICMP_V4_PING_SIZE_ENABLEf_SET
#define DOS_CONTROL_2r_ICMP_FRAG_PKTS_ENABLEf_GET BCM56218_A0_DOS_CONTROL_2r_ICMP_FRAG_PKTS_ENABLEf_GET
#define DOS_CONTROL_2r_ICMP_FRAG_PKTS_ENABLEf_SET BCM56218_A0_DOS_CONTROL_2r_ICMP_FRAG_PKTS_ENABLEf_SET
#define READ_DOS_CONTROL_2r BCM56218_A0_READ_DOS_CONTROL_2r
#define WRITE_DOS_CONTROL_2r BCM56218_A0_WRITE_DOS_CONTROL_2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_DOS_CONTROL_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  DSCP_TABLE
 * BLOCKS:   IPIPE
 * DESC:     Diff Serv Code Point Table. This table is divided on Per Ingress Port basis. The index is constructed as [ingress_port[5:0], dscp[5:0]]
 * SIZE:     11
 * FIELDS:
 *     DSCP             New Diff Serv Code Point
 *     PRI              Priority
 *     CNG              Congestion bits
 *
 ******************************************************************************/
#define BCM56218_A0_DSCP_TABLEm 0x0b710000

#define BCM56218_A0_DSCP_TABLEm_MIN 0
#define BCM56218_A0_DSCP_TABLEm_MAX 3455
#define BCM56218_A0_DSCP_TABLEm_CMAX(u) 3455
#define BCM56218_A0_DSCP_TABLEm_SIZE 2

/*
 * This structure should be used to declare and program DSCP_TABLE.
 *
 */
typedef union BCM56218_A0_DSCP_TABLEm_s {
	uint32_t v[1];
	uint32_t dscp_table[1];
	uint32_t _dscp_table;
} BCM56218_A0_DSCP_TABLEm_t;

#define BCM56218_A0_DSCP_TABLEm_CLR(r) (r).dscp_table[0] = 0
#define BCM56218_A0_DSCP_TABLEm_SET(r,d) (r).dscp_table[0] = d
#define BCM56218_A0_DSCP_TABLEm_GET(r) (r).dscp_table[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_DSCP_TABLEm_DSCPf_GET(r) (((r).dscp_table[0]) & 0x3f)
#define BCM56218_A0_DSCP_TABLEm_DSCPf_SET(r,f) (r).dscp_table[0]=(((r).dscp_table[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM56218_A0_DSCP_TABLEm_PRIf_GET(r) ((((r).dscp_table[0]) >> 6) & 0x7)
#define BCM56218_A0_DSCP_TABLEm_PRIf_SET(r,f) (r).dscp_table[0]=(((r).dscp_table[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM56218_A0_DSCP_TABLEm_CNGf_GET(r) ((((r).dscp_table[0]) >> 9) & 0x3)
#define BCM56218_A0_DSCP_TABLEm_CNGf_SET(r,f) (r).dscp_table[0]=(((r).dscp_table[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9))

/*
 * These macros can be used to access DSCP_TABLE.
 *
 */
#define BCM56218_A0_READ_DSCP_TABLEm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_DSCP_TABLEm,i,(m._dscp_table),1)
#define BCM56218_A0_WRITE_DSCP_TABLEm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_DSCP_TABLEm,i,&(m._dscp_table),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DSCP_TABLEm BCM56218_A0_DSCP_TABLEm
#define DSCP_TABLEm_MIN BCM56218_A0_DSCP_TABLEm_MIN
#define DSCP_TABLEm_MAX BCM56218_A0_DSCP_TABLEm_MAX
#define DSCP_TABLEm_CMAX(u) BCM56218_A0_DSCP_TABLEm_CMAX(u)
#define DSCP_TABLEm_SIZE BCM56218_A0_DSCP_TABLEm_SIZE
typedef BCM56218_A0_DSCP_TABLEm_t DSCP_TABLEm_t;
#define DSCP_TABLEm_CLR BCM56218_A0_DSCP_TABLEm_CLR
#define DSCP_TABLEm_SET BCM56218_A0_DSCP_TABLEm_SET
#define DSCP_TABLEm_GET BCM56218_A0_DSCP_TABLEm_GET
#define DSCP_TABLEm_DSCPf_GET BCM56218_A0_DSCP_TABLEm_DSCPf_GET
#define DSCP_TABLEm_DSCPf_SET BCM56218_A0_DSCP_TABLEm_DSCPf_SET
#define DSCP_TABLEm_PRIf_GET BCM56218_A0_DSCP_TABLEm_PRIf_GET
#define DSCP_TABLEm_PRIf_SET BCM56218_A0_DSCP_TABLEm_PRIf_SET
#define DSCP_TABLEm_CNGf_GET BCM56218_A0_DSCP_TABLEm_CNGf_GET
#define DSCP_TABLEm_CNGf_SET BCM56218_A0_DSCP_TABLEm_CNGf_SET
#define READ_DSCP_TABLEm BCM56218_A0_READ_DSCP_TABLEm
#define WRITE_DSCP_TABLEm BCM56218_A0_WRITE_DSCP_TABLEm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_DSCP_TABLEm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  DYNCELLCOUNT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     DYNAMICCELLCOUNT Dynamic Cell Count for each egress port: 
 *
 ******************************************************************************/
#define BCM56218_A0_DYNCELLCOUNTr 0x00600038

#define BCM56218_A0_DYNCELLCOUNTr_SIZE 4

/*
 * This structure should be used to declare and program DYNCELLCOUNT.
 *
 */
typedef union BCM56218_A0_DYNCELLCOUNTr_s {
	uint32_t v[1];
	uint32_t dyncellcount[1];
	uint32_t _dyncellcount;
} BCM56218_A0_DYNCELLCOUNTr_t;

#define BCM56218_A0_DYNCELLCOUNTr_CLR(r) (r).dyncellcount[0] = 0
#define BCM56218_A0_DYNCELLCOUNTr_SET(r,d) (r).dyncellcount[0] = d
#define BCM56218_A0_DYNCELLCOUNTr_GET(r) (r).dyncellcount[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_DYNCELLCOUNTr_DYNAMICCELLCOUNTf_GET(r) (((r).dyncellcount[0]) & 0xfff)
#define BCM56218_A0_DYNCELLCOUNTr_DYNAMICCELLCOUNTf_SET(r,f) (r).dyncellcount[0]=(((r).dyncellcount[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))

/*
 * These macros can be used to access DYNCELLCOUNT.
 *
 */
#define BCM56218_A0_READ_DYNCELLCOUNTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_DYNCELLCOUNTr,(r._dyncellcount))
#define BCM56218_A0_WRITE_DYNCELLCOUNTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_DYNCELLCOUNTr,&(r._dyncellcount))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DYNCELLCOUNTr BCM56218_A0_DYNCELLCOUNTr
#define DYNCELLCOUNTr_SIZE BCM56218_A0_DYNCELLCOUNTr_SIZE
typedef BCM56218_A0_DYNCELLCOUNTr_t DYNCELLCOUNTr_t;
#define DYNCELLCOUNTr_CLR BCM56218_A0_DYNCELLCOUNTr_CLR
#define DYNCELLCOUNTr_SET BCM56218_A0_DYNCELLCOUNTr_SET
#define DYNCELLCOUNTr_GET BCM56218_A0_DYNCELLCOUNTr_GET
#define DYNCELLCOUNTr_DYNAMICCELLCOUNTf_GET BCM56218_A0_DYNCELLCOUNTr_DYNAMICCELLCOUNTf_GET
#define DYNCELLCOUNTr_DYNAMICCELLCOUNTf_SET BCM56218_A0_DYNCELLCOUNTr_DYNAMICCELLCOUNTf_SET
#define READ_DYNCELLCOUNTr BCM56218_A0_READ_DYNCELLCOUNTr
#define WRITE_DYNCELLCOUNTr BCM56218_A0_WRITE_DYNCELLCOUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_DYNCELLCOUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  DYNCELLLIMIT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     DYNCELLSETLIMIT  In Dynamic Memory mode:This regs represent the total dynamic cells that can be used by a port for all COSs. This CBP cells (LCCOUNT>LWM) that are used above the LWM limit are compared against this limit. Effectivelythis limit represents the HOL cell limit for a port. This limit is usedonly if Draco_1.5_mode is enabled.This limit is not used in Draco 1.0 mode.Modify this register during the traffic is an illeagal opreation, will cause unrecoverable damage on MMU.
 *     DYNCELLRESETLIMIT In Dynamic Memory mode:This regs represent maximum port dynamic cells usage for its 8 COS queue.When a port is already in dropping state, and when its Dynamic cell countis less than this dyncellresetlimit or its LCCOUNT is less than its LWM. If all above conditions met, a COS queue will get back cell admission state.This limit is used only if Dynamic mode is enabled.This limit is not used in Draco 1.0 mode.Modify this register during the traffic is an illeagal opreation, will cause unrecoverable damage on MMU.
 *
 ******************************************************************************/
#define BCM56218_A0_DYNCELLLIMITr 0x00600037

#define BCM56218_A0_DYNCELLLIMITr_SIZE 4

/*
 * This structure should be used to declare and program DYNCELLLIMIT.
 *
 */
typedef union BCM56218_A0_DYNCELLLIMITr_s {
	uint32_t v[1];
	uint32_t dyncelllimit[1];
	uint32_t _dyncelllimit;
} BCM56218_A0_DYNCELLLIMITr_t;

#define BCM56218_A0_DYNCELLLIMITr_CLR(r) (r).dyncelllimit[0] = 0
#define BCM56218_A0_DYNCELLLIMITr_SET(r,d) (r).dyncelllimit[0] = d
#define BCM56218_A0_DYNCELLLIMITr_GET(r) (r).dyncelllimit[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_DYNCELLLIMITr_DYNCELLSETLIMITf_GET(r) (((r).dyncelllimit[0]) & 0xfff)
#define BCM56218_A0_DYNCELLLIMITr_DYNCELLSETLIMITf_SET(r,f) (r).dyncelllimit[0]=(((r).dyncelllimit[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM56218_A0_DYNCELLLIMITr_DYNCELLRESETLIMITf_GET(r) ((((r).dyncelllimit[0]) >> 12) & 0xfff)
#define BCM56218_A0_DYNCELLLIMITr_DYNCELLRESETLIMITf_SET(r,f) (r).dyncelllimit[0]=(((r).dyncelllimit[0] & ~((uint32_t)0xfff << 12)) | ((((uint32_t)f) & 0xfff) << 12))

/*
 * These macros can be used to access DYNCELLLIMIT.
 *
 */
#define BCM56218_A0_READ_DYNCELLLIMITr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_DYNCELLLIMITr,(r._dyncelllimit))
#define BCM56218_A0_WRITE_DYNCELLLIMITr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_DYNCELLLIMITr,&(r._dyncelllimit))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DYNCELLLIMITr BCM56218_A0_DYNCELLLIMITr
#define DYNCELLLIMITr_SIZE BCM56218_A0_DYNCELLLIMITr_SIZE
typedef BCM56218_A0_DYNCELLLIMITr_t DYNCELLLIMITr_t;
#define DYNCELLLIMITr_CLR BCM56218_A0_DYNCELLLIMITr_CLR
#define DYNCELLLIMITr_SET BCM56218_A0_DYNCELLLIMITr_SET
#define DYNCELLLIMITr_GET BCM56218_A0_DYNCELLLIMITr_GET
#define DYNCELLLIMITr_DYNCELLSETLIMITf_GET BCM56218_A0_DYNCELLLIMITr_DYNCELLSETLIMITf_GET
#define DYNCELLLIMITr_DYNCELLSETLIMITf_SET BCM56218_A0_DYNCELLLIMITr_DYNCELLSETLIMITf_SET
#define DYNCELLLIMITr_DYNCELLRESETLIMITf_GET BCM56218_A0_DYNCELLLIMITr_DYNCELLRESETLIMITf_GET
#define DYNCELLLIMITr_DYNCELLRESETLIMITf_SET BCM56218_A0_DYNCELLLIMITr_DYNCELLRESETLIMITf_SET
#define READ_DYNCELLLIMITr BCM56218_A0_READ_DYNCELLLIMITr
#define WRITE_DYNCELLLIMITr BCM56218_A0_WRITE_DYNCELLLIMITr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_DYNCELLLIMITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  EGRDROPPKTCOUNT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     DROPPEDPKTCOUNT  This is per egress port based counter and it counts the number of whole packets dropped by MMU and will not pass to egress port. MMU counts packets only if the portbitmap of the received packet is non-zero and not purgedThe reasons for mmu to drop packet:1. CBP memory Full,2. IBP Cell count over IBPDISCARDSETLIMIT,3. HOL Cell count over HOLCOSxCELLSETLIMIT,4. HOL Packet count over HOLCOSxPKTSETLIMIT,5. HOL Packet count over CNGCOSxPKTSETLIMIT0 and Packet with CNG[1:0]=2'b01,6. HOL Packet count over CNGCOSxPKTSETLIMIT1 and Packet with CNG[1:0]=2'b11,7. Single cell packet (64~128 bytes) purged by Ingress Pipeline.For packet just dropped when the some cells of the packet are already beenadmitted by mmu, this packet will not get counted by MMU EGRDROPPKTCOUNT. 
 *
 ******************************************************************************/
#define BCM56218_A0_EGRDROPPKTCOUNTr 0x0060004b

#define BCM56218_A0_EGRDROPPKTCOUNTr_SIZE 4

/*
 * This structure should be used to declare and program EGRDROPPKTCOUNT.
 *
 */
typedef union BCM56218_A0_EGRDROPPKTCOUNTr_s {
	uint32_t v[1];
	uint32_t egrdroppktcount[1];
	uint32_t _egrdroppktcount;
} BCM56218_A0_EGRDROPPKTCOUNTr_t;

#define BCM56218_A0_EGRDROPPKTCOUNTr_CLR(r) (r).egrdroppktcount[0] = 0
#define BCM56218_A0_EGRDROPPKTCOUNTr_SET(r,d) (r).egrdroppktcount[0] = d
#define BCM56218_A0_EGRDROPPKTCOUNTr_GET(r) (r).egrdroppktcount[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_EGRDROPPKTCOUNTr_DROPPEDPKTCOUNTf_GET(r) ((r).egrdroppktcount[0])
#define BCM56218_A0_EGRDROPPKTCOUNTr_DROPPEDPKTCOUNTf_SET(r,f) (r).egrdroppktcount[0]=((uint32_t)f)

/*
 * These macros can be used to access EGRDROPPKTCOUNT.
 *
 */
#define BCM56218_A0_READ_EGRDROPPKTCOUNTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_EGRDROPPKTCOUNTr,(r._egrdroppktcount))
#define BCM56218_A0_WRITE_EGRDROPPKTCOUNTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_EGRDROPPKTCOUNTr,&(r._egrdroppktcount))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGRDROPPKTCOUNTr BCM56218_A0_EGRDROPPKTCOUNTr
#define EGRDROPPKTCOUNTr_SIZE BCM56218_A0_EGRDROPPKTCOUNTr_SIZE
typedef BCM56218_A0_EGRDROPPKTCOUNTr_t EGRDROPPKTCOUNTr_t;
#define EGRDROPPKTCOUNTr_CLR BCM56218_A0_EGRDROPPKTCOUNTr_CLR
#define EGRDROPPKTCOUNTr_SET BCM56218_A0_EGRDROPPKTCOUNTr_SET
#define EGRDROPPKTCOUNTr_GET BCM56218_A0_EGRDROPPKTCOUNTr_GET
#define EGRDROPPKTCOUNTr_DROPPEDPKTCOUNTf_GET BCM56218_A0_EGRDROPPKTCOUNTr_DROPPEDPKTCOUNTf_GET
#define EGRDROPPKTCOUNTr_DROPPEDPKTCOUNTf_SET BCM56218_A0_EGRDROPPKTCOUNTr_DROPPEDPKTCOUNTf_SET
#define READ_EGRDROPPKTCOUNTr BCM56218_A0_READ_EGRDROPPKTCOUNTr
#define WRITE_EGRDROPPKTCOUNTr BCM56218_A0_WRITE_EGRDROPPKTCOUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_EGRDROPPKTCOUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  EGRESSCELLREQUESTCOUNT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     REQUESTCOUNT     Egress Cell request Counter.Counter needs to reset when reseting Egress port.
 *
 ******************************************************************************/
#define BCM56218_A0_EGRESSCELLREQUESTCOUNTr 0x00600041

#define BCM56218_A0_EGRESSCELLREQUESTCOUNTr_SIZE 4

/*
 * This structure should be used to declare and program EGRESSCELLREQUESTCOUNT.
 *
 */
typedef union BCM56218_A0_EGRESSCELLREQUESTCOUNTr_s {
	uint32_t v[1];
	uint32_t egresscellrequestcount[1];
	uint32_t _egresscellrequestcount;
} BCM56218_A0_EGRESSCELLREQUESTCOUNTr_t;

#define BCM56218_A0_EGRESSCELLREQUESTCOUNTr_CLR(r) (r).egresscellrequestcount[0] = 0
#define BCM56218_A0_EGRESSCELLREQUESTCOUNTr_SET(r,d) (r).egresscellrequestcount[0] = d
#define BCM56218_A0_EGRESSCELLREQUESTCOUNTr_GET(r) (r).egresscellrequestcount[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_EGRESSCELLREQUESTCOUNTr_REQUESTCOUNTf_GET(r) (((r).egresscellrequestcount[0]) & 0xf)
#define BCM56218_A0_EGRESSCELLREQUESTCOUNTr_REQUESTCOUNTf_SET(r,f) (r).egresscellrequestcount[0]=(((r).egresscellrequestcount[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access EGRESSCELLREQUESTCOUNT.
 *
 */
#define BCM56218_A0_READ_EGRESSCELLREQUESTCOUNTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_EGRESSCELLREQUESTCOUNTr,(r._egresscellrequestcount))
#define BCM56218_A0_WRITE_EGRESSCELLREQUESTCOUNTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_EGRESSCELLREQUESTCOUNTr,&(r._egresscellrequestcount))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGRESSCELLREQUESTCOUNTr BCM56218_A0_EGRESSCELLREQUESTCOUNTr
#define EGRESSCELLREQUESTCOUNTr_SIZE BCM56218_A0_EGRESSCELLREQUESTCOUNTr_SIZE
typedef BCM56218_A0_EGRESSCELLREQUESTCOUNTr_t EGRESSCELLREQUESTCOUNTr_t;
#define EGRESSCELLREQUESTCOUNTr_CLR BCM56218_A0_EGRESSCELLREQUESTCOUNTr_CLR
#define EGRESSCELLREQUESTCOUNTr_SET BCM56218_A0_EGRESSCELLREQUESTCOUNTr_SET
#define EGRESSCELLREQUESTCOUNTr_GET BCM56218_A0_EGRESSCELLREQUESTCOUNTr_GET
#define EGRESSCELLREQUESTCOUNTr_REQUESTCOUNTf_GET BCM56218_A0_EGRESSCELLREQUESTCOUNTr_REQUESTCOUNTf_GET
#define EGRESSCELLREQUESTCOUNTr_REQUESTCOUNTf_SET BCM56218_A0_EGRESSCELLREQUESTCOUNTr_REQUESTCOUNTf_SET
#define READ_EGRESSCELLREQUESTCOUNTr BCM56218_A0_READ_EGRESSCELLREQUESTCOUNTr
#define WRITE_EGRESSCELLREQUESTCOUNTr BCM56218_A0_WRITE_EGRESSCELLREQUESTCOUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_EGRESSCELLREQUESTCOUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  EGRMETERINGBUCKET
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     BUCKET           Maximum rate bucket with unit is 0.5 bit.
 *     IN_PROFILE_FLAG  IN_PROFILE_FLAG inidcates the current state of metering bucket1: out of profile0: In profileDefault value is in profile.
 *
 ******************************************************************************/
#define BCM56218_A0_EGRMETERINGBUCKETr 0x0060004f

#define BCM56218_A0_EGRMETERINGBUCKETr_SIZE 4

/*
 * This structure should be used to declare and program EGRMETERINGBUCKET.
 *
 */
typedef union BCM56218_A0_EGRMETERINGBUCKETr_s {
	uint32_t v[1];
	uint32_t egrmeteringbucket[1];
	uint32_t _egrmeteringbucket;
} BCM56218_A0_EGRMETERINGBUCKETr_t;

#define BCM56218_A0_EGRMETERINGBUCKETr_CLR(r) (r).egrmeteringbucket[0] = 0
#define BCM56218_A0_EGRMETERINGBUCKETr_SET(r,d) (r).egrmeteringbucket[0] = d
#define BCM56218_A0_EGRMETERINGBUCKETr_GET(r) (r).egrmeteringbucket[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_EGRMETERINGBUCKETr_BUCKETf_GET(r) (((r).egrmeteringbucket[0]) & 0x1fffffff)
#define BCM56218_A0_EGRMETERINGBUCKETr_BUCKETf_SET(r,f) (r).egrmeteringbucket[0]=(((r).egrmeteringbucket[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM56218_A0_EGRMETERINGBUCKETr_IN_PROFILE_FLAGf_GET(r) ((((r).egrmeteringbucket[0]) >> 29) & 0x1)
#define BCM56218_A0_EGRMETERINGBUCKETr_IN_PROFILE_FLAGf_SET(r,f) (r).egrmeteringbucket[0]=(((r).egrmeteringbucket[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))

/*
 * These macros can be used to access EGRMETERINGBUCKET.
 *
 */
#define BCM56218_A0_READ_EGRMETERINGBUCKETr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_EGRMETERINGBUCKETr,(r._egrmeteringbucket))
#define BCM56218_A0_WRITE_EGRMETERINGBUCKETr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_EGRMETERINGBUCKETr,&(r._egrmeteringbucket))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGRMETERINGBUCKETr BCM56218_A0_EGRMETERINGBUCKETr
#define EGRMETERINGBUCKETr_SIZE BCM56218_A0_EGRMETERINGBUCKETr_SIZE
typedef BCM56218_A0_EGRMETERINGBUCKETr_t EGRMETERINGBUCKETr_t;
#define EGRMETERINGBUCKETr_CLR BCM56218_A0_EGRMETERINGBUCKETr_CLR
#define EGRMETERINGBUCKETr_SET BCM56218_A0_EGRMETERINGBUCKETr_SET
#define EGRMETERINGBUCKETr_GET BCM56218_A0_EGRMETERINGBUCKETr_GET
#define EGRMETERINGBUCKETr_BUCKETf_GET BCM56218_A0_EGRMETERINGBUCKETr_BUCKETf_GET
#define EGRMETERINGBUCKETr_BUCKETf_SET BCM56218_A0_EGRMETERINGBUCKETr_BUCKETf_SET
#define EGRMETERINGBUCKETr_IN_PROFILE_FLAGf_GET BCM56218_A0_EGRMETERINGBUCKETr_IN_PROFILE_FLAGf_GET
#define EGRMETERINGBUCKETr_IN_PROFILE_FLAGf_SET BCM56218_A0_EGRMETERINGBUCKETr_IN_PROFILE_FLAGf_SET
#define READ_EGRMETERINGBUCKETr BCM56218_A0_READ_EGRMETERINGBUCKETr
#define WRITE_EGRMETERINGBUCKETr BCM56218_A0_WRITE_EGRMETERINGBUCKETr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_EGRMETERINGBUCKETr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  EGRMETERINGCONFIG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     THD_SEL          Threshold for metering bucket.The setting of Threshold determines the size ofbucket and not related to rate. It also determines how burstness of traffic is.0x0: Disable, Egress Metering function is disabled.0x1:  32k bits, (32*1024),0x2:  64k bits, (64*1024),0x3: 128k bits, (128*1024),0x4: 256k bits, (256*1024),0x5: 512k bits, (512*1024),0x6:   1M bits, (1024*1024),0x7:   2M bits, (2*1024*1024),0x8:   4M bits, (4*1024*1024),0x9:   8M bits, (8*1024*1024),0xa:  16M bits, (16*1024*1024),0xb:  32M bits, (32*1024*1024),0xc:  64M bits, (64*1024*1024),0xd: 128M bits, (128*1024*1024),0xe: 128M bits, (128*1024*1024), Bucket saturated at 128M bits,0xf: 128M bits, (128*1024*1024), Bucket saturated at 128M bits,
 *     REFRESH          Refresh count for metering bucket. Every unit of REFRESH represents 64,000 bps, (bits per second).Example 1:  To set metering rate to 500 Mbps (500,000,000 bps),             should set REFRESH = 7812,Example 2:  To set metering rate to 1 Gbps (1,000,000,000 bps),             should set REFRESH = 15624.
 *
 ******************************************************************************/
#define BCM56218_A0_EGRMETERINGCONFIGr 0x0060004e

#define BCM56218_A0_EGRMETERINGCONFIGr_SIZE 4

/*
 * This structure should be used to declare and program EGRMETERINGCONFIG.
 *
 */
typedef union BCM56218_A0_EGRMETERINGCONFIGr_s {
	uint32_t v[1];
	uint32_t egrmeteringconfig[1];
	uint32_t _egrmeteringconfig;
} BCM56218_A0_EGRMETERINGCONFIGr_t;

#define BCM56218_A0_EGRMETERINGCONFIGr_CLR(r) (r).egrmeteringconfig[0] = 0
#define BCM56218_A0_EGRMETERINGCONFIGr_SET(r,d) (r).egrmeteringconfig[0] = d
#define BCM56218_A0_EGRMETERINGCONFIGr_GET(r) (r).egrmeteringconfig[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_EGRMETERINGCONFIGr_THD_SELf_GET(r) (((r).egrmeteringconfig[0]) & 0xf)
#define BCM56218_A0_EGRMETERINGCONFIGr_THD_SELf_SET(r,f) (r).egrmeteringconfig[0]=(((r).egrmeteringconfig[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56218_A0_EGRMETERINGCONFIGr_REFRESHf_GET(r) ((((r).egrmeteringconfig[0]) >> 4) & 0x3ffff)
#define BCM56218_A0_EGRMETERINGCONFIGr_REFRESHf_SET(r,f) (r).egrmeteringconfig[0]=(((r).egrmeteringconfig[0] & ~((uint32_t)0x3ffff << 4)) | ((((uint32_t)f) & 0x3ffff) << 4))

/*
 * These macros can be used to access EGRMETERINGCONFIG.
 *
 */
#define BCM56218_A0_READ_EGRMETERINGCONFIGr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_EGRMETERINGCONFIGr,(r._egrmeteringconfig))
#define BCM56218_A0_WRITE_EGRMETERINGCONFIGr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_EGRMETERINGCONFIGr,&(r._egrmeteringconfig))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGRMETERINGCONFIGr BCM56218_A0_EGRMETERINGCONFIGr
#define EGRMETERINGCONFIGr_SIZE BCM56218_A0_EGRMETERINGCONFIGr_SIZE
typedef BCM56218_A0_EGRMETERINGCONFIGr_t EGRMETERINGCONFIGr_t;
#define EGRMETERINGCONFIGr_CLR BCM56218_A0_EGRMETERINGCONFIGr_CLR
#define EGRMETERINGCONFIGr_SET BCM56218_A0_EGRMETERINGCONFIGr_SET
#define EGRMETERINGCONFIGr_GET BCM56218_A0_EGRMETERINGCONFIGr_GET
#define EGRMETERINGCONFIGr_THD_SELf_GET BCM56218_A0_EGRMETERINGCONFIGr_THD_SELf_GET
#define EGRMETERINGCONFIGr_THD_SELf_SET BCM56218_A0_EGRMETERINGCONFIGr_THD_SELf_SET
#define EGRMETERINGCONFIGr_REFRESHf_GET BCM56218_A0_EGRMETERINGCONFIGr_REFRESHf_GET
#define EGRMETERINGCONFIGr_REFRESHf_SET BCM56218_A0_EGRMETERINGCONFIGr_REFRESHf_SET
#define READ_EGRMETERINGCONFIGr BCM56218_A0_READ_EGRMETERINGCONFIGr
#define WRITE_EGRMETERINGCONFIGr BCM56218_A0_WRITE_EGRMETERINGCONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_EGRMETERINGCONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  EGRTXPKTCTR
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     TXPKTCOUNT       Transmit Packet Counter: When TXPKTCOUNT_SEL in EGRTXPKTCTR is selected, this packet tranmit counter will count all the packets to be tranmitted topre-configured egress port with pre-configurated cos on EGRTXPKTCTRCONFIG0.  
 *
 ******************************************************************************/
#define BCM56218_A0_EGRTXPKTCTRr 0x0068002d

#define BCM56218_A0_EGRTXPKTCTRr_SIZE 4

/*
 * This structure should be used to declare and program EGRTXPKTCTR.
 *
 */
typedef union BCM56218_A0_EGRTXPKTCTRr_s {
	uint32_t v[1];
	uint32_t egrtxpktctr[1];
	uint32_t _egrtxpktctr;
} BCM56218_A0_EGRTXPKTCTRr_t;

#define BCM56218_A0_EGRTXPKTCTRr_CLR(r) (r).egrtxpktctr[0] = 0
#define BCM56218_A0_EGRTXPKTCTRr_SET(r,d) (r).egrtxpktctr[0] = d
#define BCM56218_A0_EGRTXPKTCTRr_GET(r) (r).egrtxpktctr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_EGRTXPKTCTRr_TXPKTCOUNTf_GET(r) ((r).egrtxpktctr[0])
#define BCM56218_A0_EGRTXPKTCTRr_TXPKTCOUNTf_SET(r,f) (r).egrtxpktctr[0]=((uint32_t)f)

/*
 * These macros can be used to access EGRTXPKTCTR.
 *
 */
#define BCM56218_A0_READ_EGRTXPKTCTRr(u,i,r) cdk_xgs_reg32_read(u,BCM56218_A0_EGRTXPKTCTRr+(i),(r._egrtxpktctr))
#define BCM56218_A0_WRITE_EGRTXPKTCTRr(u,i,r) cdk_xgs_reg32_write(u,BCM56218_A0_EGRTXPKTCTRr+(i),&(r._egrtxpktctr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGRTXPKTCTRr BCM56218_A0_EGRTXPKTCTRr
#define EGRTXPKTCTRr_SIZE BCM56218_A0_EGRTXPKTCTRr_SIZE
typedef BCM56218_A0_EGRTXPKTCTRr_t EGRTXPKTCTRr_t;
#define EGRTXPKTCTRr_CLR BCM56218_A0_EGRTXPKTCTRr_CLR
#define EGRTXPKTCTRr_SET BCM56218_A0_EGRTXPKTCTRr_SET
#define EGRTXPKTCTRr_GET BCM56218_A0_EGRTXPKTCTRr_GET
#define EGRTXPKTCTRr_TXPKTCOUNTf_GET BCM56218_A0_EGRTXPKTCTRr_TXPKTCOUNTf_GET
#define EGRTXPKTCTRr_TXPKTCOUNTf_SET BCM56218_A0_EGRTXPKTCTRr_TXPKTCOUNTf_SET
#define READ_EGRTXPKTCTRr BCM56218_A0_READ_EGRTXPKTCTRr
#define WRITE_EGRTXPKTCTRr BCM56218_A0_WRITE_EGRTXPKTCTRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_EGRTXPKTCTRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  EGRTXPKTCTRCONFIG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     TXEPORTNUM       Egress port number: When TXPKTCOUNT_EN is selected, this packet tranmitcounter EGRTXPKTCTR0 will count all the packets to be tranmitted to this egress port.  
 *     TXIPORTNUM       Ingress port number: When TXPKTCOUNT_IPORTEN is selected, this packet tranmitcounter EGRTXPKTCTR0 will count all the packets received from this ingress port.  
 *     TXCOSNUM         Egress cos number: When TXPKTCOUNT_EN is aseerted, this packet tranmitcounter EGRTXPKTCTR0 will count all the packets to be tranmitted to pre-configured cos.  
 *     TXPKTCOUNT_SEL   Transmit Packet Counter Select: Select the way EGRTXPKTCTR count the packet:2'b00: Disable, not counting.2'b01: Count packets transmit to egress port with cos defined in        TXEPORTNUM and TXCOSNUM2'b10: Count packets receive from ingress port with cos defined in       TXIPORTNUM and TXCOSNUM2'b11: Count packets receive from ingress port and transmit to egress port       with cos defined in TXIPORTNUM, TXEPORTNUM and TXCOSNUM.
 *
 ******************************************************************************/
#define BCM56218_A0_EGRTXPKTCTRCONFIGr 0x00680025

#define BCM56218_A0_EGRTXPKTCTRCONFIGr_SIZE 4

/*
 * This structure should be used to declare and program EGRTXPKTCTRCONFIG.
 *
 */
typedef union BCM56218_A0_EGRTXPKTCTRCONFIGr_s {
	uint32_t v[1];
	uint32_t egrtxpktctrconfig[1];
	uint32_t _egrtxpktctrconfig;
} BCM56218_A0_EGRTXPKTCTRCONFIGr_t;

#define BCM56218_A0_EGRTXPKTCTRCONFIGr_CLR(r) (r).egrtxpktctrconfig[0] = 0
#define BCM56218_A0_EGRTXPKTCTRCONFIGr_SET(r,d) (r).egrtxpktctrconfig[0] = d
#define BCM56218_A0_EGRTXPKTCTRCONFIGr_GET(r) (r).egrtxpktctrconfig[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_EGRTXPKTCTRCONFIGr_TXEPORTNUMf_GET(r) (((r).egrtxpktctrconfig[0]) & 0x3f)
#define BCM56218_A0_EGRTXPKTCTRCONFIGr_TXEPORTNUMf_SET(r,f) (r).egrtxpktctrconfig[0]=(((r).egrtxpktctrconfig[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM56218_A0_EGRTXPKTCTRCONFIGr_TXIPORTNUMf_GET(r) ((((r).egrtxpktctrconfig[0]) >> 6) & 0x3f)
#define BCM56218_A0_EGRTXPKTCTRCONFIGr_TXIPORTNUMf_SET(r,f) (r).egrtxpktctrconfig[0]=(((r).egrtxpktctrconfig[0] & ~((uint32_t)0x3f << 6)) | ((((uint32_t)f) & 0x3f) << 6))
#define BCM56218_A0_EGRTXPKTCTRCONFIGr_TXCOSNUMf_GET(r) ((((r).egrtxpktctrconfig[0]) >> 12) & 0x7)
#define BCM56218_A0_EGRTXPKTCTRCONFIGr_TXCOSNUMf_SET(r,f) (r).egrtxpktctrconfig[0]=(((r).egrtxpktctrconfig[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM56218_A0_EGRTXPKTCTRCONFIGr_TXPKTCOUNT_SELf_GET(r) ((((r).egrtxpktctrconfig[0]) >> 15) & 0x3)
#define BCM56218_A0_EGRTXPKTCTRCONFIGr_TXPKTCOUNT_SELf_SET(r,f) (r).egrtxpktctrconfig[0]=(((r).egrtxpktctrconfig[0] & ~((uint32_t)0x3 << 15)) | ((((uint32_t)f) & 0x3) << 15))

/*
 * These macros can be used to access EGRTXPKTCTRCONFIG.
 *
 */
#define BCM56218_A0_READ_EGRTXPKTCTRCONFIGr(u,i,r) cdk_xgs_reg32_read(u,BCM56218_A0_EGRTXPKTCTRCONFIGr+(i),(r._egrtxpktctrconfig))
#define BCM56218_A0_WRITE_EGRTXPKTCTRCONFIGr(u,i,r) cdk_xgs_reg32_write(u,BCM56218_A0_EGRTXPKTCTRCONFIGr+(i),&(r._egrtxpktctrconfig))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGRTXPKTCTRCONFIGr BCM56218_A0_EGRTXPKTCTRCONFIGr
#define EGRTXPKTCTRCONFIGr_SIZE BCM56218_A0_EGRTXPKTCTRCONFIGr_SIZE
typedef BCM56218_A0_EGRTXPKTCTRCONFIGr_t EGRTXPKTCTRCONFIGr_t;
#define EGRTXPKTCTRCONFIGr_CLR BCM56218_A0_EGRTXPKTCTRCONFIGr_CLR
#define EGRTXPKTCTRCONFIGr_SET BCM56218_A0_EGRTXPKTCTRCONFIGr_SET
#define EGRTXPKTCTRCONFIGr_GET BCM56218_A0_EGRTXPKTCTRCONFIGr_GET
#define EGRTXPKTCTRCONFIGr_TXEPORTNUMf_GET BCM56218_A0_EGRTXPKTCTRCONFIGr_TXEPORTNUMf_GET
#define EGRTXPKTCTRCONFIGr_TXEPORTNUMf_SET BCM56218_A0_EGRTXPKTCTRCONFIGr_TXEPORTNUMf_SET
#define EGRTXPKTCTRCONFIGr_TXIPORTNUMf_GET BCM56218_A0_EGRTXPKTCTRCONFIGr_TXIPORTNUMf_GET
#define EGRTXPKTCTRCONFIGr_TXIPORTNUMf_SET BCM56218_A0_EGRTXPKTCTRCONFIGr_TXIPORTNUMf_SET
#define EGRTXPKTCTRCONFIGr_TXCOSNUMf_GET BCM56218_A0_EGRTXPKTCTRCONFIGr_TXCOSNUMf_GET
#define EGRTXPKTCTRCONFIGr_TXCOSNUMf_SET BCM56218_A0_EGRTXPKTCTRCONFIGr_TXCOSNUMf_SET
#define EGRTXPKTCTRCONFIGr_TXPKTCOUNT_SELf_GET BCM56218_A0_EGRTXPKTCTRCONFIGr_TXPKTCOUNT_SELf_GET
#define EGRTXPKTCTRCONFIGr_TXPKTCOUNT_SELf_SET BCM56218_A0_EGRTXPKTCTRCONFIGr_TXPKTCOUNT_SELf_SET
#define READ_EGRTXPKTCTRCONFIGr BCM56218_A0_READ_EGRTXPKTCTRCONFIGr
#define WRITE_EGRTXPKTCTRCONFIGr BCM56218_A0_WRITE_EGRTXPKTCTRCONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_EGRTXPKTCTRCONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  EGR_CONFIG
 * BLOCKS:   EPIPE
 * DESC:     Configuration Register for the entire chip. 


 * SIZE:     32
 * FIELDS:
 *     DT_MODE          Double Tagging Mode is enabled or not.
 *     CFI_AS_CNG       CFI-CNG mapping enabled. If this bit is set, Packet Modification stages will map the incoming CNG bits to CFI bits in the packet vlan tag. This bit is per chip.
 *     USE_LEARN_VID    Use the learn_vid for vid membership and stg state check.
 *     LEARN_VID        Vid to be used for vid membership and stg state check when USE_LEARN_VID is set.
 *     INNER_TPID       TPID to identify inner vlan tag of the packet when switch is operating in DT mode, i.e. DT_MODE bit is set.
 *
 ******************************************************************************/
#define BCM56218_A0_EGR_CONFIGr 0x01980000

#define BCM56218_A0_EGR_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program EGR_CONFIG.
 *
 */
typedef union BCM56218_A0_EGR_CONFIGr_s {
	uint32_t v[1];
	uint32_t egr_config[1];
	uint32_t _egr_config;
} BCM56218_A0_EGR_CONFIGr_t;

#define BCM56218_A0_EGR_CONFIGr_CLR(r) (r).egr_config[0] = 0
#define BCM56218_A0_EGR_CONFIGr_SET(r,d) (r).egr_config[0] = d
#define BCM56218_A0_EGR_CONFIGr_GET(r) (r).egr_config[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_EGR_CONFIGr_DT_MODEf_GET(r) (((r).egr_config[0]) & 0x1)
#define BCM56218_A0_EGR_CONFIGr_DT_MODEf_SET(r,f) (r).egr_config[0]=(((r).egr_config[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_EGR_CONFIGr_CFI_AS_CNGf_GET(r) ((((r).egr_config[0]) >> 1) & 0x1)
#define BCM56218_A0_EGR_CONFIGr_CFI_AS_CNGf_SET(r,f) (r).egr_config[0]=(((r).egr_config[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_EGR_CONFIGr_USE_LEARN_VIDf_GET(r) ((((r).egr_config[0]) >> 2) & 0x1)
#define BCM56218_A0_EGR_CONFIGr_USE_LEARN_VIDf_SET(r,f) (r).egr_config[0]=(((r).egr_config[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_EGR_CONFIGr_LEARN_VIDf_GET(r) ((((r).egr_config[0]) >> 3) & 0xfff)
#define BCM56218_A0_EGR_CONFIGr_LEARN_VIDf_SET(r,f) (r).egr_config[0]=(((r).egr_config[0] & ~((uint32_t)0xfff << 3)) | ((((uint32_t)f) & 0xfff) << 3))
#define BCM56218_A0_EGR_CONFIGr_INNER_TPIDf_GET(r) ((((r).egr_config[0]) >> 15) & 0xffff)
#define BCM56218_A0_EGR_CONFIGr_INNER_TPIDf_SET(r,f) (r).egr_config[0]=(((r).egr_config[0] & ~((uint32_t)0xffff << 15)) | ((((uint32_t)f) & 0xffff) << 15))

/*
 * These macros can be used to access EGR_CONFIG.
 *
 */
#define BCM56218_A0_READ_EGR_CONFIGr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_EGR_CONFIGr,(r._egr_config))
#define BCM56218_A0_WRITE_EGR_CONFIGr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_EGR_CONFIGr,&(r._egr_config))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_CONFIGr BCM56218_A0_EGR_CONFIGr
#define EGR_CONFIGr_SIZE BCM56218_A0_EGR_CONFIGr_SIZE
typedef BCM56218_A0_EGR_CONFIGr_t EGR_CONFIGr_t;
#define EGR_CONFIGr_CLR BCM56218_A0_EGR_CONFIGr_CLR
#define EGR_CONFIGr_SET BCM56218_A0_EGR_CONFIGr_SET
#define EGR_CONFIGr_GET BCM56218_A0_EGR_CONFIGr_GET
#define EGR_CONFIGr_DT_MODEf_GET BCM56218_A0_EGR_CONFIGr_DT_MODEf_GET
#define EGR_CONFIGr_DT_MODEf_SET BCM56218_A0_EGR_CONFIGr_DT_MODEf_SET
#define EGR_CONFIGr_CFI_AS_CNGf_GET BCM56218_A0_EGR_CONFIGr_CFI_AS_CNGf_GET
#define EGR_CONFIGr_CFI_AS_CNGf_SET BCM56218_A0_EGR_CONFIGr_CFI_AS_CNGf_SET
#define EGR_CONFIGr_USE_LEARN_VIDf_GET BCM56218_A0_EGR_CONFIGr_USE_LEARN_VIDf_GET
#define EGR_CONFIGr_USE_LEARN_VIDf_SET BCM56218_A0_EGR_CONFIGr_USE_LEARN_VIDf_SET
#define EGR_CONFIGr_LEARN_VIDf_GET BCM56218_A0_EGR_CONFIGr_LEARN_VIDf_GET
#define EGR_CONFIGr_LEARN_VIDf_SET BCM56218_A0_EGR_CONFIGr_LEARN_VIDf_SET
#define EGR_CONFIGr_INNER_TPIDf_GET BCM56218_A0_EGR_CONFIGr_INNER_TPIDf_GET
#define EGR_CONFIGr_INNER_TPIDf_SET BCM56218_A0_EGR_CONFIGr_INNER_TPIDf_SET
#define READ_EGR_CONFIGr BCM56218_A0_READ_EGR_CONFIGr
#define WRITE_EGR_CONFIGr BCM56218_A0_WRITE_EGR_CONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_EGR_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  EGR_CONFIG_1
 * BLOCKS:   EPIPE
 * DESC:     Configuration Register Extension for the entire chip. 


 * SIZE:     32
 * FIELDS:
 *     RING_MODE        User should set it when switches are cascaded in a ring fashion
 *     FORCE_STATIC_MH_PFM Forces MH_PFM in the module header for pkts going to Higig Port.
 *     MH_PFM           PFM to be used to construct the Module Header.
 *     RESERVED_5_4     Reserved
 *     MIRROR_INVALID_VLAN_DROP Will control whether packets are dropped or forwarded for the mirror-to-port when the packet going out contains an invalid VLAN.  A '1' will force the packet to be dropped, while a '0' will allow it to forward.
 *     IGNORE_HG_HDR_DONOT_LEARN If set, HiGig hdrs DONOT_LEARN bit will be ignored and will be treated as reserved bit.
 *     BPDU_INVALID_VLAN_DROP Will control whether BPDU packets are dropped or forwarded when the packet going out contains an invalid VLAN.  A '1' will force the packet to be dropped, while a '0' will allow it to forward.
 *
 ******************************************************************************/
#define BCM56218_A0_EGR_CONFIG_1r 0x01980001

#define BCM56218_A0_EGR_CONFIG_1r_SIZE 4

/*
 * This structure should be used to declare and program EGR_CONFIG_1.
 *
 */
typedef union BCM56218_A0_EGR_CONFIG_1r_s {
	uint32_t v[1];
	uint32_t egr_config_1[1];
	uint32_t _egr_config_1;
} BCM56218_A0_EGR_CONFIG_1r_t;

#define BCM56218_A0_EGR_CONFIG_1r_CLR(r) (r).egr_config_1[0] = 0
#define BCM56218_A0_EGR_CONFIG_1r_SET(r,d) (r).egr_config_1[0] = d
#define BCM56218_A0_EGR_CONFIG_1r_GET(r) (r).egr_config_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_EGR_CONFIG_1r_RING_MODEf_GET(r) (((r).egr_config_1[0]) & 0x1)
#define BCM56218_A0_EGR_CONFIG_1r_RING_MODEf_SET(r,f) (r).egr_config_1[0]=(((r).egr_config_1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_EGR_CONFIG_1r_FORCE_STATIC_MH_PFMf_GET(r) ((((r).egr_config_1[0]) >> 1) & 0x1)
#define BCM56218_A0_EGR_CONFIG_1r_FORCE_STATIC_MH_PFMf_SET(r,f) (r).egr_config_1[0]=(((r).egr_config_1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_EGR_CONFIG_1r_MH_PFMf_GET(r) ((((r).egr_config_1[0]) >> 2) & 0x3)
#define BCM56218_A0_EGR_CONFIG_1r_MH_PFMf_SET(r,f) (r).egr_config_1[0]=(((r).egr_config_1[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM56218_A0_EGR_CONFIG_1r_RESERVED_5_4f_GET(r) ((((r).egr_config_1[0]) >> 4) & 0x3)
#define BCM56218_A0_EGR_CONFIG_1r_RESERVED_5_4f_SET(r,f) (r).egr_config_1[0]=(((r).egr_config_1[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM56218_A0_EGR_CONFIG_1r_MIRROR_INVALID_VLAN_DROPf_GET(r) ((((r).egr_config_1[0]) >> 6) & 0x1)
#define BCM56218_A0_EGR_CONFIG_1r_MIRROR_INVALID_VLAN_DROPf_SET(r,f) (r).egr_config_1[0]=(((r).egr_config_1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56218_A0_EGR_CONFIG_1r_IGNORE_HG_HDR_DONOT_LEARNf_GET(r) ((((r).egr_config_1[0]) >> 7) & 0x1)
#define BCM56218_A0_EGR_CONFIG_1r_IGNORE_HG_HDR_DONOT_LEARNf_SET(r,f) (r).egr_config_1[0]=(((r).egr_config_1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56218_A0_EGR_CONFIG_1r_BPDU_INVALID_VLAN_DROPf_GET(r) ((((r).egr_config_1[0]) >> 8) & 0x1)
#define BCM56218_A0_EGR_CONFIG_1r_BPDU_INVALID_VLAN_DROPf_SET(r,f) (r).egr_config_1[0]=(((r).egr_config_1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))

/*
 * These macros can be used to access EGR_CONFIG_1.
 *
 */
#define BCM56218_A0_READ_EGR_CONFIG_1r(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_EGR_CONFIG_1r,(r._egr_config_1))
#define BCM56218_A0_WRITE_EGR_CONFIG_1r(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_EGR_CONFIG_1r,&(r._egr_config_1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_CONFIG_1r BCM56218_A0_EGR_CONFIG_1r
#define EGR_CONFIG_1r_SIZE BCM56218_A0_EGR_CONFIG_1r_SIZE
typedef BCM56218_A0_EGR_CONFIG_1r_t EGR_CONFIG_1r_t;
#define EGR_CONFIG_1r_CLR BCM56218_A0_EGR_CONFIG_1r_CLR
#define EGR_CONFIG_1r_SET BCM56218_A0_EGR_CONFIG_1r_SET
#define EGR_CONFIG_1r_GET BCM56218_A0_EGR_CONFIG_1r_GET
#define EGR_CONFIG_1r_RING_MODEf_GET BCM56218_A0_EGR_CONFIG_1r_RING_MODEf_GET
#define EGR_CONFIG_1r_RING_MODEf_SET BCM56218_A0_EGR_CONFIG_1r_RING_MODEf_SET
#define EGR_CONFIG_1r_FORCE_STATIC_MH_PFMf_GET BCM56218_A0_EGR_CONFIG_1r_FORCE_STATIC_MH_PFMf_GET
#define EGR_CONFIG_1r_FORCE_STATIC_MH_PFMf_SET BCM56218_A0_EGR_CONFIG_1r_FORCE_STATIC_MH_PFMf_SET
#define EGR_CONFIG_1r_MH_PFMf_GET BCM56218_A0_EGR_CONFIG_1r_MH_PFMf_GET
#define EGR_CONFIG_1r_MH_PFMf_SET BCM56218_A0_EGR_CONFIG_1r_MH_PFMf_SET
#define EGR_CONFIG_1r_RESERVED_5_4f_GET BCM56218_A0_EGR_CONFIG_1r_RESERVED_5_4f_GET
#define EGR_CONFIG_1r_RESERVED_5_4f_SET BCM56218_A0_EGR_CONFIG_1r_RESERVED_5_4f_SET
#define EGR_CONFIG_1r_MIRROR_INVALID_VLAN_DROPf_GET BCM56218_A0_EGR_CONFIG_1r_MIRROR_INVALID_VLAN_DROPf_GET
#define EGR_CONFIG_1r_MIRROR_INVALID_VLAN_DROPf_SET BCM56218_A0_EGR_CONFIG_1r_MIRROR_INVALID_VLAN_DROPf_SET
#define EGR_CONFIG_1r_IGNORE_HG_HDR_DONOT_LEARNf_GET BCM56218_A0_EGR_CONFIG_1r_IGNORE_HG_HDR_DONOT_LEARNf_GET
#define EGR_CONFIG_1r_IGNORE_HG_HDR_DONOT_LEARNf_SET BCM56218_A0_EGR_CONFIG_1r_IGNORE_HG_HDR_DONOT_LEARNf_SET
#define EGR_CONFIG_1r_BPDU_INVALID_VLAN_DROPf_GET BCM56218_A0_EGR_CONFIG_1r_BPDU_INVALID_VLAN_DROPf_GET
#define EGR_CONFIG_1r_BPDU_INVALID_VLAN_DROPf_SET BCM56218_A0_EGR_CONFIG_1r_BPDU_INVALID_VLAN_DROPf_SET
#define READ_EGR_CONFIG_1r BCM56218_A0_READ_EGR_CONFIG_1r
#define WRITE_EGR_CONFIG_1r BCM56218_A0_WRITE_EGR_CONFIG_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_EGR_CONFIG_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  EGR_DBG
 * BLOCKS:   EPIPE
 * DESC:     Configuration Register for a Port. This is same for GE, 10GE, Higig Ports.


 * SIZE:     32
 * FIELDS:
 *     RESURRECT        Enable the resurrect feature for purge, aged and cell_error packets.If this bit is set, the packets marked as Purge, Aged, Cell_error are not dropped in the chip.
 *     DISABLE_CRC_REGEN Disable CRC regeneration for GE ports only. In case of Higig or 10GE, theCRC regeration is config based in the mac.
 *     ALWAYS_CRC_REGEN Always regenrate the CRC for GE ports only. In case of Higig or 10GE, theCRC regeration is config based in the mac.
 *
 ******************************************************************************/
#define BCM56218_A0_EGR_DBGr 0x06900000

#define BCM56218_A0_EGR_DBGr_SIZE 4

/*
 * This structure should be used to declare and program EGR_DBG.
 *
 */
typedef union BCM56218_A0_EGR_DBGr_s {
	uint32_t v[1];
	uint32_t egr_dbg[1];
	uint32_t _egr_dbg;
} BCM56218_A0_EGR_DBGr_t;

#define BCM56218_A0_EGR_DBGr_CLR(r) (r).egr_dbg[0] = 0
#define BCM56218_A0_EGR_DBGr_SET(r,d) (r).egr_dbg[0] = d
#define BCM56218_A0_EGR_DBGr_GET(r) (r).egr_dbg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_EGR_DBGr_RESURRECTf_GET(r) (((r).egr_dbg[0]) & 0x1)
#define BCM56218_A0_EGR_DBGr_RESURRECTf_SET(r,f) (r).egr_dbg[0]=(((r).egr_dbg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_EGR_DBGr_DISABLE_CRC_REGENf_GET(r) ((((r).egr_dbg[0]) >> 1) & 0x1)
#define BCM56218_A0_EGR_DBGr_DISABLE_CRC_REGENf_SET(r,f) (r).egr_dbg[0]=(((r).egr_dbg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_EGR_DBGr_ALWAYS_CRC_REGENf_GET(r) ((((r).egr_dbg[0]) >> 2) & 0x1)
#define BCM56218_A0_EGR_DBGr_ALWAYS_CRC_REGENf_SET(r,f) (r).egr_dbg[0]=(((r).egr_dbg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))

/*
 * These macros can be used to access EGR_DBG.
 *
 */
#define BCM56218_A0_READ_EGR_DBGr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_EGR_DBGr,(r._egr_dbg))
#define BCM56218_A0_WRITE_EGR_DBGr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_EGR_DBGr,&(r._egr_dbg))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_DBGr BCM56218_A0_EGR_DBGr
#define EGR_DBGr_SIZE BCM56218_A0_EGR_DBGr_SIZE
typedef BCM56218_A0_EGR_DBGr_t EGR_DBGr_t;
#define EGR_DBGr_CLR BCM56218_A0_EGR_DBGr_CLR
#define EGR_DBGr_SET BCM56218_A0_EGR_DBGr_SET
#define EGR_DBGr_GET BCM56218_A0_EGR_DBGr_GET
#define EGR_DBGr_RESURRECTf_GET BCM56218_A0_EGR_DBGr_RESURRECTf_GET
#define EGR_DBGr_RESURRECTf_SET BCM56218_A0_EGR_DBGr_RESURRECTf_SET
#define EGR_DBGr_DISABLE_CRC_REGENf_GET BCM56218_A0_EGR_DBGr_DISABLE_CRC_REGENf_GET
#define EGR_DBGr_DISABLE_CRC_REGENf_SET BCM56218_A0_EGR_DBGr_DISABLE_CRC_REGENf_SET
#define EGR_DBGr_ALWAYS_CRC_REGENf_GET BCM56218_A0_EGR_DBGr_ALWAYS_CRC_REGENf_GET
#define EGR_DBGr_ALWAYS_CRC_REGENf_SET BCM56218_A0_EGR_DBGr_ALWAYS_CRC_REGENf_SET
#define READ_EGR_DBGr BCM56218_A0_READ_EGR_DBGr
#define WRITE_EGR_DBGr BCM56218_A0_WRITE_EGR_DBGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_EGR_DBGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  EGR_DSCP_ECN_MAP
 * BLOCKS:   EPIPE
 * DESC:     Egress ECN Map Table to select the ECN interpretation mode based on DSCP.
 * SIZE:     1
 * FIELDS:
 *     ECN_MODE         Select for mode of interpreation of ECN bits, either based on RFC or Draft.
 *
 ******************************************************************************/
#define BCM56218_A0_EGR_DSCP_ECN_MAPm 0x05950000

#define BCM56218_A0_EGR_DSCP_ECN_MAPm_MIN 0
#define BCM56218_A0_EGR_DSCP_ECN_MAPm_MAX 63
#define BCM56218_A0_EGR_DSCP_ECN_MAPm_CMAX(u) 63
#define BCM56218_A0_EGR_DSCP_ECN_MAPm_SIZE 1

/*
 * This structure should be used to declare and program EGR_DSCP_ECN_MAP.
 *
 */
typedef union BCM56218_A0_EGR_DSCP_ECN_MAPm_s {
	uint32_t v[1];
	uint32_t egr_dscp_ecn_map[1];
	uint32_t _egr_dscp_ecn_map;
} BCM56218_A0_EGR_DSCP_ECN_MAPm_t;

#define BCM56218_A0_EGR_DSCP_ECN_MAPm_CLR(r) (r).egr_dscp_ecn_map[0] = 0
#define BCM56218_A0_EGR_DSCP_ECN_MAPm_SET(r,d) (r).egr_dscp_ecn_map[0] = d
#define BCM56218_A0_EGR_DSCP_ECN_MAPm_GET(r) (r).egr_dscp_ecn_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_EGR_DSCP_ECN_MAPm_ECN_MODEf_GET(r) (((r).egr_dscp_ecn_map[0]) & 0x1)
#define BCM56218_A0_EGR_DSCP_ECN_MAPm_ECN_MODEf_SET(r,f) (r).egr_dscp_ecn_map[0]=(((r).egr_dscp_ecn_map[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access EGR_DSCP_ECN_MAP.
 *
 */
#define BCM56218_A0_READ_EGR_DSCP_ECN_MAPm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_EGR_DSCP_ECN_MAPm,i,(m._egr_dscp_ecn_map),1)
#define BCM56218_A0_WRITE_EGR_DSCP_ECN_MAPm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_EGR_DSCP_ECN_MAPm,i,&(m._egr_dscp_ecn_map),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_DSCP_ECN_MAPm BCM56218_A0_EGR_DSCP_ECN_MAPm
#define EGR_DSCP_ECN_MAPm_MIN BCM56218_A0_EGR_DSCP_ECN_MAPm_MIN
#define EGR_DSCP_ECN_MAPm_MAX BCM56218_A0_EGR_DSCP_ECN_MAPm_MAX
#define EGR_DSCP_ECN_MAPm_CMAX(u) BCM56218_A0_EGR_DSCP_ECN_MAPm_CMAX(u)
#define EGR_DSCP_ECN_MAPm_SIZE BCM56218_A0_EGR_DSCP_ECN_MAPm_SIZE
typedef BCM56218_A0_EGR_DSCP_ECN_MAPm_t EGR_DSCP_ECN_MAPm_t;
#define EGR_DSCP_ECN_MAPm_CLR BCM56218_A0_EGR_DSCP_ECN_MAPm_CLR
#define EGR_DSCP_ECN_MAPm_SET BCM56218_A0_EGR_DSCP_ECN_MAPm_SET
#define EGR_DSCP_ECN_MAPm_GET BCM56218_A0_EGR_DSCP_ECN_MAPm_GET
#define EGR_DSCP_ECN_MAPm_ECN_MODEf_GET BCM56218_A0_EGR_DSCP_ECN_MAPm_ECN_MODEf_GET
#define EGR_DSCP_ECN_MAPm_ECN_MODEf_SET BCM56218_A0_EGR_DSCP_ECN_MAPm_ECN_MODEf_SET
#define READ_EGR_DSCP_ECN_MAPm BCM56218_A0_READ_EGR_DSCP_ECN_MAPm
#define WRITE_EGR_DSCP_ECN_MAPm BCM56218_A0_WRITE_EGR_DSCP_ECN_MAPm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_EGR_DSCP_ECN_MAPm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  EGR_DSCP_TABLE
 * BLOCKS:   EPIPE
 * DESC:     Egress DSCP Table to select the new dscp for outer tunnel header packets.
 * SIZE:     6
 * FIELDS:
 *     DSCP             New DSCP to be used for the outer tunnel header based on the incoming mmu priority and the DSCP_SEL field from the EGR_IP_TUNNEL table.
 *
 ******************************************************************************/
#define BCM56218_A0_EGR_DSCP_TABLEm 0x05940000

#define BCM56218_A0_EGR_DSCP_TABLEm_MIN 0
#define BCM56218_A0_EGR_DSCP_TABLEm_MAX 63
#define BCM56218_A0_EGR_DSCP_TABLEm_CMAX(u) 63
#define BCM56218_A0_EGR_DSCP_TABLEm_SIZE 1

/*
 * This structure should be used to declare and program EGR_DSCP_TABLE.
 *
 */
typedef union BCM56218_A0_EGR_DSCP_TABLEm_s {
	uint32_t v[1];
	uint32_t egr_dscp_table[1];
	uint32_t _egr_dscp_table;
} BCM56218_A0_EGR_DSCP_TABLEm_t;

#define BCM56218_A0_EGR_DSCP_TABLEm_CLR(r) (r).egr_dscp_table[0] = 0
#define BCM56218_A0_EGR_DSCP_TABLEm_SET(r,d) (r).egr_dscp_table[0] = d
#define BCM56218_A0_EGR_DSCP_TABLEm_GET(r) (r).egr_dscp_table[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_EGR_DSCP_TABLEm_DSCPf_GET(r) (((r).egr_dscp_table[0]) & 0x3f)
#define BCM56218_A0_EGR_DSCP_TABLEm_DSCPf_SET(r,f) (r).egr_dscp_table[0]=(((r).egr_dscp_table[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))

/*
 * These macros can be used to access EGR_DSCP_TABLE.
 *
 */
#define BCM56218_A0_READ_EGR_DSCP_TABLEm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_EGR_DSCP_TABLEm,i,(m._egr_dscp_table),1)
#define BCM56218_A0_WRITE_EGR_DSCP_TABLEm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_EGR_DSCP_TABLEm,i,&(m._egr_dscp_table),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_DSCP_TABLEm BCM56218_A0_EGR_DSCP_TABLEm
#define EGR_DSCP_TABLEm_MIN BCM56218_A0_EGR_DSCP_TABLEm_MIN
#define EGR_DSCP_TABLEm_MAX BCM56218_A0_EGR_DSCP_TABLEm_MAX
#define EGR_DSCP_TABLEm_CMAX(u) BCM56218_A0_EGR_DSCP_TABLEm_CMAX(u)
#define EGR_DSCP_TABLEm_SIZE BCM56218_A0_EGR_DSCP_TABLEm_SIZE
typedef BCM56218_A0_EGR_DSCP_TABLEm_t EGR_DSCP_TABLEm_t;
#define EGR_DSCP_TABLEm_CLR BCM56218_A0_EGR_DSCP_TABLEm_CLR
#define EGR_DSCP_TABLEm_SET BCM56218_A0_EGR_DSCP_TABLEm_SET
#define EGR_DSCP_TABLEm_GET BCM56218_A0_EGR_DSCP_TABLEm_GET
#define EGR_DSCP_TABLEm_DSCPf_GET BCM56218_A0_EGR_DSCP_TABLEm_DSCPf_GET
#define EGR_DSCP_TABLEm_DSCPf_SET BCM56218_A0_EGR_DSCP_TABLEm_DSCPf_SET
#define READ_EGR_DSCP_TABLEm BCM56218_A0_READ_EGR_DSCP_TABLEm
#define WRITE_EGR_DSCP_TABLEm BCM56218_A0_WRITE_EGR_DSCP_TABLEm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_EGR_DSCP_TABLEm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  EGR_EM_MTP_INDEX
 * BLOCKS:   EPIPE
 * DESC:     Mirror to Port Table. 
Index is constructed using pbe.mtp_index[6:0] field.
We use {pbe.mtp_index[5:4],pbe.mtp_index[2:0]} as index into this table.

 * SIZE:     10
 * FIELDS:
 *     MTP_DST_MODID    DST_MODID field to be used in the module header in case of mirroring.
 *     MTP_DST_PORT     DST_PORT field to be used in module header in case of mirroring.
 *
 ******************************************************************************/
#define BCM56218_A0_EGR_EM_MTP_INDEXm 0x05930000

#define BCM56218_A0_EGR_EM_MTP_INDEXm_MIN 0
#define BCM56218_A0_EGR_EM_MTP_INDEXm_MAX 31
#define BCM56218_A0_EGR_EM_MTP_INDEXm_CMAX(u) 31
#define BCM56218_A0_EGR_EM_MTP_INDEXm_SIZE 2

/*
 * This structure should be used to declare and program EGR_EM_MTP_INDEX.
 *
 */
typedef union BCM56218_A0_EGR_EM_MTP_INDEXm_s {
	uint32_t v[1];
	uint32_t egr_em_mtp_index[1];
	uint32_t _egr_em_mtp_index;
} BCM56218_A0_EGR_EM_MTP_INDEXm_t;

#define BCM56218_A0_EGR_EM_MTP_INDEXm_CLR(r) (r).egr_em_mtp_index[0] = 0
#define BCM56218_A0_EGR_EM_MTP_INDEXm_SET(r,d) (r).egr_em_mtp_index[0] = d
#define BCM56218_A0_EGR_EM_MTP_INDEXm_GET(r) (r).egr_em_mtp_index[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_EGR_EM_MTP_INDEXm_MTP_DST_MODIDf_GET(r) (((r).egr_em_mtp_index[0]) & 0xf)
#define BCM56218_A0_EGR_EM_MTP_INDEXm_MTP_DST_MODIDf_SET(r,f) (r).egr_em_mtp_index[0]=(((r).egr_em_mtp_index[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56218_A0_EGR_EM_MTP_INDEXm_MTP_DST_PORTf_GET(r) ((((r).egr_em_mtp_index[0]) >> 4) & 0x3f)
#define BCM56218_A0_EGR_EM_MTP_INDEXm_MTP_DST_PORTf_SET(r,f) (r).egr_em_mtp_index[0]=(((r).egr_em_mtp_index[0] & ~((uint32_t)0x3f << 4)) | ((((uint32_t)f) & 0x3f) << 4))

/*
 * These macros can be used to access EGR_EM_MTP_INDEX.
 *
 */
#define BCM56218_A0_READ_EGR_EM_MTP_INDEXm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_EGR_EM_MTP_INDEXm,i,(m._egr_em_mtp_index),1)
#define BCM56218_A0_WRITE_EGR_EM_MTP_INDEXm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_EGR_EM_MTP_INDEXm,i,&(m._egr_em_mtp_index),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_EM_MTP_INDEXm BCM56218_A0_EGR_EM_MTP_INDEXm
#define EGR_EM_MTP_INDEXm_MIN BCM56218_A0_EGR_EM_MTP_INDEXm_MIN
#define EGR_EM_MTP_INDEXm_MAX BCM56218_A0_EGR_EM_MTP_INDEXm_MAX
#define EGR_EM_MTP_INDEXm_CMAX(u) BCM56218_A0_EGR_EM_MTP_INDEXm_CMAX(u)
#define EGR_EM_MTP_INDEXm_SIZE BCM56218_A0_EGR_EM_MTP_INDEXm_SIZE
typedef BCM56218_A0_EGR_EM_MTP_INDEXm_t EGR_EM_MTP_INDEXm_t;
#define EGR_EM_MTP_INDEXm_CLR BCM56218_A0_EGR_EM_MTP_INDEXm_CLR
#define EGR_EM_MTP_INDEXm_SET BCM56218_A0_EGR_EM_MTP_INDEXm_SET
#define EGR_EM_MTP_INDEXm_GET BCM56218_A0_EGR_EM_MTP_INDEXm_GET
#define EGR_EM_MTP_INDEXm_MTP_DST_MODIDf_GET BCM56218_A0_EGR_EM_MTP_INDEXm_MTP_DST_MODIDf_GET
#define EGR_EM_MTP_INDEXm_MTP_DST_MODIDf_SET BCM56218_A0_EGR_EM_MTP_INDEXm_MTP_DST_MODIDf_SET
#define EGR_EM_MTP_INDEXm_MTP_DST_PORTf_GET BCM56218_A0_EGR_EM_MTP_INDEXm_MTP_DST_PORTf_GET
#define EGR_EM_MTP_INDEXm_MTP_DST_PORTf_SET BCM56218_A0_EGR_EM_MTP_INDEXm_MTP_DST_PORTf_SET
#define READ_EGR_EM_MTP_INDEXm BCM56218_A0_READ_EGR_EM_MTP_INDEXm
#define WRITE_EGR_EM_MTP_INDEXm BCM56218_A0_WRITE_EGR_EM_MTP_INDEXm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_EGR_EM_MTP_INDEXm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  EGR_ENABLE
 * BLOCKS:   EPIPE
 * DESC:     Enables the Egress Port for transmission.

 * SIZE:     32
 * FIELDS:
 *     PRT_ENABLE       Port is enabled. If this bit is set, the requests to MMU will be made from this port to the MMU.
 *
 ******************************************************************************/
#define BCM56218_A0_EGR_ENABLEr 0x0a900100

#define BCM56218_A0_EGR_ENABLEr_SIZE 4

/*
 * This structure should be used to declare and program EGR_ENABLE.
 *
 */
typedef union BCM56218_A0_EGR_ENABLEr_s {
	uint32_t v[1];
	uint32_t egr_enable[1];
	uint32_t _egr_enable;
} BCM56218_A0_EGR_ENABLEr_t;

#define BCM56218_A0_EGR_ENABLEr_CLR(r) (r).egr_enable[0] = 0
#define BCM56218_A0_EGR_ENABLEr_SET(r,d) (r).egr_enable[0] = d
#define BCM56218_A0_EGR_ENABLEr_GET(r) (r).egr_enable[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_EGR_ENABLEr_PRT_ENABLEf_GET(r) (((r).egr_enable[0]) & 0x1)
#define BCM56218_A0_EGR_ENABLEr_PRT_ENABLEf_SET(r,f) (r).egr_enable[0]=(((r).egr_enable[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access EGR_ENABLE.
 *
 */
#define BCM56218_A0_READ_EGR_ENABLEr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_EGR_ENABLEr,(r._egr_enable))
#define BCM56218_A0_WRITE_EGR_ENABLEr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_EGR_ENABLEr,&(r._egr_enable))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_ENABLEr BCM56218_A0_EGR_ENABLEr
#define EGR_ENABLEr_SIZE BCM56218_A0_EGR_ENABLEr_SIZE
typedef BCM56218_A0_EGR_ENABLEr_t EGR_ENABLEr_t;
#define EGR_ENABLEr_CLR BCM56218_A0_EGR_ENABLEr_CLR
#define EGR_ENABLEr_SET BCM56218_A0_EGR_ENABLEr_SET
#define EGR_ENABLEr_GET BCM56218_A0_EGR_ENABLEr_GET
#define EGR_ENABLEr_PRT_ENABLEf_GET BCM56218_A0_EGR_ENABLEr_PRT_ENABLEf_GET
#define EGR_ENABLEr_PRT_ENABLEf_SET BCM56218_A0_EGR_ENABLEr_PRT_ENABLEf_SET
#define READ_EGR_ENABLEr BCM56218_A0_READ_EGR_ENABLEr
#define WRITE_EGR_ENABLEr BCM56218_A0_WRITE_EGR_ENABLEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_EGR_ENABLEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  EGR_EVENT_DEBUG
 * BLOCKS:   EPIPE
 * DESC:     Sticky stats bits. This register is updated with the reasons for which a pkt is dropped or transmitted. This is a sticky register, so once a bit is set, it'll stay set till the software clears it.

 * SIZE:     32
 * FIELDS:
 *     TGIP4            Bit 0 - Transmit Good IPv4 L3 UC packet counter
 *     TIPD4            Bit 1 - Transmit IPv4 L3 UC Aged and Drop packet counter
 *     TGIPMC4          Bit 2 - Transmit Good IPv4 IPMC packet counter
 *     TIPMCD4          Bit 3 - Transmit IPv4 IPMC Aged and Drop packet counter
 *     TGIP6            Bit 4 - Transmit Good IPv6 L3 UC packet counter
 *     TIPD6            Bit 5 - Transmit IPv6 L3 UC Aged and Drop Packet counter
 *     TGIPMC6          Bit 6 - Transmit Good IPv6 IPMC packet counter
 *     TIPMCD6          Bit 7 - Transmit IPv6 IPMC Aged and Drop packet counter
 *     TTNL             Bit 8 - Transmit Tunnel packet counter
 *     TTNLE            Bit 9 - Transmit Tunnel error packet counter (inner v6 is not 6to4 or ISATAP for automatic tunnel encapsulation)
 *     TTTLD            Bit 10 - Packets dropped due to TTL threshold counter
 *     TCFID            Bit 11 - Packets dropped when CFI bit set and packet is untagged or L3_switched for IPMC counter
 *     TVLAN            Bit 12 - Transmit VLAN tagged packet counter
 *     TVLAND           Bit 13 - Packet dropped due to invalid VLAN counter
 *     TVXLTMD          Bit 14 - Packet dropped due to miss in VXLT table counter
 *     TSTGD            Bit 15 - Packet dropped due to Spanning Tree State not in forwarding state counter
 *     TAGED            Bit 16 - Packet dropped due to packet aged counter
 *     TL2MCD           Bit 17 - L2 MC packet drop counter
 *     TPKTD            Bit 17 - Packet dropped due to any condition
 *     TMIRR            Bit 19 - mirroring flag.
 *     TSIPL            Bit 20 - SIP Link Local Drop flag.
 *
 ******************************************************************************/
#define BCM56218_A0_EGR_EVENT_DEBUGr 0x09980003

#define BCM56218_A0_EGR_EVENT_DEBUGr_SIZE 4

/*
 * This structure should be used to declare and program EGR_EVENT_DEBUG.
 *
 */
typedef union BCM56218_A0_EGR_EVENT_DEBUGr_s {
	uint32_t v[1];
	uint32_t egr_event_debug[1];
	uint32_t _egr_event_debug;
} BCM56218_A0_EGR_EVENT_DEBUGr_t;

#define BCM56218_A0_EGR_EVENT_DEBUGr_CLR(r) (r).egr_event_debug[0] = 0
#define BCM56218_A0_EGR_EVENT_DEBUGr_SET(r,d) (r).egr_event_debug[0] = d
#define BCM56218_A0_EGR_EVENT_DEBUGr_GET(r) (r).egr_event_debug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_EGR_EVENT_DEBUGr_TGIP4f_GET(r) (((r).egr_event_debug[0]) & 0x1)
#define BCM56218_A0_EGR_EVENT_DEBUGr_TGIP4f_SET(r,f) (r).egr_event_debug[0]=(((r).egr_event_debug[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_EGR_EVENT_DEBUGr_TIPD4f_GET(r) ((((r).egr_event_debug[0]) >> 1) & 0x1)
#define BCM56218_A0_EGR_EVENT_DEBUGr_TIPD4f_SET(r,f) (r).egr_event_debug[0]=(((r).egr_event_debug[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_EGR_EVENT_DEBUGr_TGIPMC4f_GET(r) ((((r).egr_event_debug[0]) >> 2) & 0x1)
#define BCM56218_A0_EGR_EVENT_DEBUGr_TGIPMC4f_SET(r,f) (r).egr_event_debug[0]=(((r).egr_event_debug[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_EGR_EVENT_DEBUGr_TIPMCD4f_GET(r) ((((r).egr_event_debug[0]) >> 3) & 0x1)
#define BCM56218_A0_EGR_EVENT_DEBUGr_TIPMCD4f_SET(r,f) (r).egr_event_debug[0]=(((r).egr_event_debug[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56218_A0_EGR_EVENT_DEBUGr_TGIP6f_GET(r) ((((r).egr_event_debug[0]) >> 4) & 0x1)
#define BCM56218_A0_EGR_EVENT_DEBUGr_TGIP6f_SET(r,f) (r).egr_event_debug[0]=(((r).egr_event_debug[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56218_A0_EGR_EVENT_DEBUGr_TIPD6f_GET(r) ((((r).egr_event_debug[0]) >> 5) & 0x1)
#define BCM56218_A0_EGR_EVENT_DEBUGr_TIPD6f_SET(r,f) (r).egr_event_debug[0]=(((r).egr_event_debug[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56218_A0_EGR_EVENT_DEBUGr_TGIPMC6f_GET(r) ((((r).egr_event_debug[0]) >> 6) & 0x1)
#define BCM56218_A0_EGR_EVENT_DEBUGr_TGIPMC6f_SET(r,f) (r).egr_event_debug[0]=(((r).egr_event_debug[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56218_A0_EGR_EVENT_DEBUGr_TIPMCD6f_GET(r) ((((r).egr_event_debug[0]) >> 7) & 0x1)
#define BCM56218_A0_EGR_EVENT_DEBUGr_TIPMCD6f_SET(r,f) (r).egr_event_debug[0]=(((r).egr_event_debug[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56218_A0_EGR_EVENT_DEBUGr_TTNLf_GET(r) ((((r).egr_event_debug[0]) >> 8) & 0x1)
#define BCM56218_A0_EGR_EVENT_DEBUGr_TTNLf_SET(r,f) (r).egr_event_debug[0]=(((r).egr_event_debug[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56218_A0_EGR_EVENT_DEBUGr_TTNLEf_GET(r) ((((r).egr_event_debug[0]) >> 9) & 0x1)
#define BCM56218_A0_EGR_EVENT_DEBUGr_TTNLEf_SET(r,f) (r).egr_event_debug[0]=(((r).egr_event_debug[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56218_A0_EGR_EVENT_DEBUGr_TTTLDf_GET(r) ((((r).egr_event_debug[0]) >> 10) & 0x1)
#define BCM56218_A0_EGR_EVENT_DEBUGr_TTTLDf_SET(r,f) (r).egr_event_debug[0]=(((r).egr_event_debug[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56218_A0_EGR_EVENT_DEBUGr_TCFIDf_GET(r) ((((r).egr_event_debug[0]) >> 11) & 0x1)
#define BCM56218_A0_EGR_EVENT_DEBUGr_TCFIDf_SET(r,f) (r).egr_event_debug[0]=(((r).egr_event_debug[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56218_A0_EGR_EVENT_DEBUGr_TVLANf_GET(r) ((((r).egr_event_debug[0]) >> 12) & 0x1)
#define BCM56218_A0_EGR_EVENT_DEBUGr_TVLANf_SET(r,f) (r).egr_event_debug[0]=(((r).egr_event_debug[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM56218_A0_EGR_EVENT_DEBUGr_TVLANDf_GET(r) ((((r).egr_event_debug[0]) >> 13) & 0x1)
#define BCM56218_A0_EGR_EVENT_DEBUGr_TVLANDf_SET(r,f) (r).egr_event_debug[0]=(((r).egr_event_debug[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56218_A0_EGR_EVENT_DEBUGr_TVXLTMDf_GET(r) ((((r).egr_event_debug[0]) >> 14) & 0x1)
#define BCM56218_A0_EGR_EVENT_DEBUGr_TVXLTMDf_SET(r,f) (r).egr_event_debug[0]=(((r).egr_event_debug[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM56218_A0_EGR_EVENT_DEBUGr_TSTGDf_GET(r) ((((r).egr_event_debug[0]) >> 15) & 0x1)
#define BCM56218_A0_EGR_EVENT_DEBUGr_TSTGDf_SET(r,f) (r).egr_event_debug[0]=(((r).egr_event_debug[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56218_A0_EGR_EVENT_DEBUGr_TAGEDf_GET(r) ((((r).egr_event_debug[0]) >> 16) & 0x1)
#define BCM56218_A0_EGR_EVENT_DEBUGr_TAGEDf_SET(r,f) (r).egr_event_debug[0]=(((r).egr_event_debug[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56218_A0_EGR_EVENT_DEBUGr_TL2MCDf_GET(r) ((((r).egr_event_debug[0]) >> 17) & 0x1)
#define BCM56218_A0_EGR_EVENT_DEBUGr_TL2MCDf_SET(r,f) (r).egr_event_debug[0]=(((r).egr_event_debug[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_EGR_EVENT_DEBUGr_TPKTDf_GET(r) ((((r).egr_event_debug[0]) >> 18) & 0x1)
#define BCM56218_A0_EGR_EVENT_DEBUGr_TPKTDf_SET(r,f) (r).egr_event_debug[0]=(((r).egr_event_debug[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_EGR_EVENT_DEBUGr_TMIRRf_GET(r) ((((r).egr_event_debug[0]) >> 19) & 0x1)
#define BCM56218_A0_EGR_EVENT_DEBUGr_TMIRRf_SET(r,f) (r).egr_event_debug[0]=(((r).egr_event_debug[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56218_A0_EGR_EVENT_DEBUGr_TSIPLf_GET(r) ((((r).egr_event_debug[0]) >> 20) & 0x1)
#define BCM56218_A0_EGR_EVENT_DEBUGr_TSIPLf_SET(r,f) (r).egr_event_debug[0]=(((r).egr_event_debug[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))

/*
 * These macros can be used to access EGR_EVENT_DEBUG.
 *
 */
#define BCM56218_A0_READ_EGR_EVENT_DEBUGr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_EGR_EVENT_DEBUGr,(r._egr_event_debug))
#define BCM56218_A0_WRITE_EGR_EVENT_DEBUGr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_EGR_EVENT_DEBUGr,&(r._egr_event_debug))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_EVENT_DEBUGr BCM56218_A0_EGR_EVENT_DEBUGr
#define EGR_EVENT_DEBUGr_SIZE BCM56218_A0_EGR_EVENT_DEBUGr_SIZE
typedef BCM56218_A0_EGR_EVENT_DEBUGr_t EGR_EVENT_DEBUGr_t;
#define EGR_EVENT_DEBUGr_CLR BCM56218_A0_EGR_EVENT_DEBUGr_CLR
#define EGR_EVENT_DEBUGr_SET BCM56218_A0_EGR_EVENT_DEBUGr_SET
#define EGR_EVENT_DEBUGr_GET BCM56218_A0_EGR_EVENT_DEBUGr_GET
#define EGR_EVENT_DEBUGr_TGIP4f_GET BCM56218_A0_EGR_EVENT_DEBUGr_TGIP4f_GET
#define EGR_EVENT_DEBUGr_TGIP4f_SET BCM56218_A0_EGR_EVENT_DEBUGr_TGIP4f_SET
#define EGR_EVENT_DEBUGr_TIPD4f_GET BCM56218_A0_EGR_EVENT_DEBUGr_TIPD4f_GET
#define EGR_EVENT_DEBUGr_TIPD4f_SET BCM56218_A0_EGR_EVENT_DEBUGr_TIPD4f_SET
#define EGR_EVENT_DEBUGr_TGIPMC4f_GET BCM56218_A0_EGR_EVENT_DEBUGr_TGIPMC4f_GET
#define EGR_EVENT_DEBUGr_TGIPMC4f_SET BCM56218_A0_EGR_EVENT_DEBUGr_TGIPMC4f_SET
#define EGR_EVENT_DEBUGr_TIPMCD4f_GET BCM56218_A0_EGR_EVENT_DEBUGr_TIPMCD4f_GET
#define EGR_EVENT_DEBUGr_TIPMCD4f_SET BCM56218_A0_EGR_EVENT_DEBUGr_TIPMCD4f_SET
#define EGR_EVENT_DEBUGr_TGIP6f_GET BCM56218_A0_EGR_EVENT_DEBUGr_TGIP6f_GET
#define EGR_EVENT_DEBUGr_TGIP6f_SET BCM56218_A0_EGR_EVENT_DEBUGr_TGIP6f_SET
#define EGR_EVENT_DEBUGr_TIPD6f_GET BCM56218_A0_EGR_EVENT_DEBUGr_TIPD6f_GET
#define EGR_EVENT_DEBUGr_TIPD6f_SET BCM56218_A0_EGR_EVENT_DEBUGr_TIPD6f_SET
#define EGR_EVENT_DEBUGr_TGIPMC6f_GET BCM56218_A0_EGR_EVENT_DEBUGr_TGIPMC6f_GET
#define EGR_EVENT_DEBUGr_TGIPMC6f_SET BCM56218_A0_EGR_EVENT_DEBUGr_TGIPMC6f_SET
#define EGR_EVENT_DEBUGr_TIPMCD6f_GET BCM56218_A0_EGR_EVENT_DEBUGr_TIPMCD6f_GET
#define EGR_EVENT_DEBUGr_TIPMCD6f_SET BCM56218_A0_EGR_EVENT_DEBUGr_TIPMCD6f_SET
#define EGR_EVENT_DEBUGr_TTNLf_GET BCM56218_A0_EGR_EVENT_DEBUGr_TTNLf_GET
#define EGR_EVENT_DEBUGr_TTNLf_SET BCM56218_A0_EGR_EVENT_DEBUGr_TTNLf_SET
#define EGR_EVENT_DEBUGr_TTNLEf_GET BCM56218_A0_EGR_EVENT_DEBUGr_TTNLEf_GET
#define EGR_EVENT_DEBUGr_TTNLEf_SET BCM56218_A0_EGR_EVENT_DEBUGr_TTNLEf_SET
#define EGR_EVENT_DEBUGr_TTTLDf_GET BCM56218_A0_EGR_EVENT_DEBUGr_TTTLDf_GET
#define EGR_EVENT_DEBUGr_TTTLDf_SET BCM56218_A0_EGR_EVENT_DEBUGr_TTTLDf_SET
#define EGR_EVENT_DEBUGr_TCFIDf_GET BCM56218_A0_EGR_EVENT_DEBUGr_TCFIDf_GET
#define EGR_EVENT_DEBUGr_TCFIDf_SET BCM56218_A0_EGR_EVENT_DEBUGr_TCFIDf_SET
#define EGR_EVENT_DEBUGr_TVLANf_GET BCM56218_A0_EGR_EVENT_DEBUGr_TVLANf_GET
#define EGR_EVENT_DEBUGr_TVLANf_SET BCM56218_A0_EGR_EVENT_DEBUGr_TVLANf_SET
#define EGR_EVENT_DEBUGr_TVLANDf_GET BCM56218_A0_EGR_EVENT_DEBUGr_TVLANDf_GET
#define EGR_EVENT_DEBUGr_TVLANDf_SET BCM56218_A0_EGR_EVENT_DEBUGr_TVLANDf_SET
#define EGR_EVENT_DEBUGr_TVXLTMDf_GET BCM56218_A0_EGR_EVENT_DEBUGr_TVXLTMDf_GET
#define EGR_EVENT_DEBUGr_TVXLTMDf_SET BCM56218_A0_EGR_EVENT_DEBUGr_TVXLTMDf_SET
#define EGR_EVENT_DEBUGr_TSTGDf_GET BCM56218_A0_EGR_EVENT_DEBUGr_TSTGDf_GET
#define EGR_EVENT_DEBUGr_TSTGDf_SET BCM56218_A0_EGR_EVENT_DEBUGr_TSTGDf_SET
#define EGR_EVENT_DEBUGr_TAGEDf_GET BCM56218_A0_EGR_EVENT_DEBUGr_TAGEDf_GET
#define EGR_EVENT_DEBUGr_TAGEDf_SET BCM56218_A0_EGR_EVENT_DEBUGr_TAGEDf_SET
#define EGR_EVENT_DEBUGr_TL2MCDf_GET BCM56218_A0_EGR_EVENT_DEBUGr_TL2MCDf_GET
#define EGR_EVENT_DEBUGr_TL2MCDf_SET BCM56218_A0_EGR_EVENT_DEBUGr_TL2MCDf_SET
#define EGR_EVENT_DEBUGr_TPKTDf_GET BCM56218_A0_EGR_EVENT_DEBUGr_TPKTDf_GET
#define EGR_EVENT_DEBUGr_TPKTDf_SET BCM56218_A0_EGR_EVENT_DEBUGr_TPKTDf_SET
#define EGR_EVENT_DEBUGr_TMIRRf_GET BCM56218_A0_EGR_EVENT_DEBUGr_TMIRRf_GET
#define EGR_EVENT_DEBUGr_TMIRRf_SET BCM56218_A0_EGR_EVENT_DEBUGr_TMIRRf_SET
#define EGR_EVENT_DEBUGr_TSIPLf_GET BCM56218_A0_EGR_EVENT_DEBUGr_TSIPLf_GET
#define EGR_EVENT_DEBUGr_TSIPLf_SET BCM56218_A0_EGR_EVENT_DEBUGr_TSIPLf_SET
#define READ_EGR_EVENT_DEBUGr BCM56218_A0_READ_EGR_EVENT_DEBUGr
#define WRITE_EGR_EVENT_DEBUGr BCM56218_A0_WRITE_EGR_EVENT_DEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_EGR_EVENT_DEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  EGR_HW_RESET_CONTROL_0
 * BLOCKS:   EPIPE
 * DESC:     This register is for controlling the HW Table Initialization Feature of the Egress Pipeline.
This register should be programmed before programming EGR_HW_RESET_CONTROL_1 register.

 * SIZE:     32
 * FIELDS:
 *     STAGE_NUMBER     Stage Number where table to be reset is located. This is NOT used when EGR_HW_RESET_CONTROL_1.RESET_ALL bit is set.
 *     START_ADDRESS    20 bit starting address for the memory. HW starts incrementing from this address until EGR_HW_RESET_CONTROL_1.COUNT is completed.  START_ADDRESS is relevant even when EGR_HW_RESET_CONTROL_1.RESET_ALL bit is set.
 *
 ******************************************************************************/
#define BCM56218_A0_EGR_HW_RESET_CONTROL_0r 0x00980000

#define BCM56218_A0_EGR_HW_RESET_CONTROL_0r_SIZE 4

/*
 * This structure should be used to declare and program EGR_HW_RESET_CONTROL_0.
 *
 */
typedef union BCM56218_A0_EGR_HW_RESET_CONTROL_0r_s {
	uint32_t v[1];
	uint32_t egr_hw_reset_control_0[1];
	uint32_t _egr_hw_reset_control_0;
} BCM56218_A0_EGR_HW_RESET_CONTROL_0r_t;

#define BCM56218_A0_EGR_HW_RESET_CONTROL_0r_CLR(r) (r).egr_hw_reset_control_0[0] = 0
#define BCM56218_A0_EGR_HW_RESET_CONTROL_0r_SET(r,d) (r).egr_hw_reset_control_0[0] = d
#define BCM56218_A0_EGR_HW_RESET_CONTROL_0r_GET(r) (r).egr_hw_reset_control_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_EGR_HW_RESET_CONTROL_0r_STAGE_NUMBERf_GET(r) (((r).egr_hw_reset_control_0[0]) & 0x3f)
#define BCM56218_A0_EGR_HW_RESET_CONTROL_0r_STAGE_NUMBERf_SET(r,f) (r).egr_hw_reset_control_0[0]=(((r).egr_hw_reset_control_0[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM56218_A0_EGR_HW_RESET_CONTROL_0r_START_ADDRESSf_GET(r) ((((r).egr_hw_reset_control_0[0]) >> 6) & 0xfffff)
#define BCM56218_A0_EGR_HW_RESET_CONTROL_0r_START_ADDRESSf_SET(r,f) (r).egr_hw_reset_control_0[0]=(((r).egr_hw_reset_control_0[0] & ~((uint32_t)0xfffff << 6)) | ((((uint32_t)f) & 0xfffff) << 6))

/*
 * These macros can be used to access EGR_HW_RESET_CONTROL_0.
 *
 */
#define BCM56218_A0_READ_EGR_HW_RESET_CONTROL_0r(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_EGR_HW_RESET_CONTROL_0r,(r._egr_hw_reset_control_0))
#define BCM56218_A0_WRITE_EGR_HW_RESET_CONTROL_0r(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_EGR_HW_RESET_CONTROL_0r,&(r._egr_hw_reset_control_0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_HW_RESET_CONTROL_0r BCM56218_A0_EGR_HW_RESET_CONTROL_0r
#define EGR_HW_RESET_CONTROL_0r_SIZE BCM56218_A0_EGR_HW_RESET_CONTROL_0r_SIZE
typedef BCM56218_A0_EGR_HW_RESET_CONTROL_0r_t EGR_HW_RESET_CONTROL_0r_t;
#define EGR_HW_RESET_CONTROL_0r_CLR BCM56218_A0_EGR_HW_RESET_CONTROL_0r_CLR
#define EGR_HW_RESET_CONTROL_0r_SET BCM56218_A0_EGR_HW_RESET_CONTROL_0r_SET
#define EGR_HW_RESET_CONTROL_0r_GET BCM56218_A0_EGR_HW_RESET_CONTROL_0r_GET
#define EGR_HW_RESET_CONTROL_0r_STAGE_NUMBERf_GET BCM56218_A0_EGR_HW_RESET_CONTROL_0r_STAGE_NUMBERf_GET
#define EGR_HW_RESET_CONTROL_0r_STAGE_NUMBERf_SET BCM56218_A0_EGR_HW_RESET_CONTROL_0r_STAGE_NUMBERf_SET
#define EGR_HW_RESET_CONTROL_0r_START_ADDRESSf_GET BCM56218_A0_EGR_HW_RESET_CONTROL_0r_START_ADDRESSf_GET
#define EGR_HW_RESET_CONTROL_0r_START_ADDRESSf_SET BCM56218_A0_EGR_HW_RESET_CONTROL_0r_START_ADDRESSf_SET
#define READ_EGR_HW_RESET_CONTROL_0r BCM56218_A0_READ_EGR_HW_RESET_CONTROL_0r
#define WRITE_EGR_HW_RESET_CONTROL_0r BCM56218_A0_WRITE_EGR_HW_RESET_CONTROL_0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_EGR_HW_RESET_CONTROL_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  EGR_HW_RESET_CONTROL_1
 * BLOCKS:   EPIPE
 * DESC:     This register is for controlling the HW Table Initialization Feature of the Egress Pipeline.

 * SIZE:     32
 * FIELDS:
 *     COUNT            Count of entries which need to be resetted starting from EGR_HW_RESET_CONTROL_0.START_ADDRESS.
 *     RESET_ALL        If set, then ALL Tables in the Egress Pipeline will be resetted for COUNT entries. STAGE_NUMBER is ignored when this bit is set. 
 *     VALID            The HW table initialization will start after Logic sees this bit as set.
 *     DONE             After HW has issued memory reset commands equal to COUNT times, it will set DONE bit,SW can poll this bit from time to time and whenever it is set, SW should reset DONE and VALIDbits to 0. This will end the HW Reset Sequence of memories in the HW.
 *
 ******************************************************************************/
#define BCM56218_A0_EGR_HW_RESET_CONTROL_1r 0x00980001

#define BCM56218_A0_EGR_HW_RESET_CONTROL_1r_SIZE 4

/*
 * This structure should be used to declare and program EGR_HW_RESET_CONTROL_1.
 *
 */
typedef union BCM56218_A0_EGR_HW_RESET_CONTROL_1r_s {
	uint32_t v[1];
	uint32_t egr_hw_reset_control_1[1];
	uint32_t _egr_hw_reset_control_1;
} BCM56218_A0_EGR_HW_RESET_CONTROL_1r_t;

#define BCM56218_A0_EGR_HW_RESET_CONTROL_1r_CLR(r) (r).egr_hw_reset_control_1[0] = 0
#define BCM56218_A0_EGR_HW_RESET_CONTROL_1r_SET(r,d) (r).egr_hw_reset_control_1[0] = d
#define BCM56218_A0_EGR_HW_RESET_CONTROL_1r_GET(r) (r).egr_hw_reset_control_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_EGR_HW_RESET_CONTROL_1r_COUNTf_GET(r) (((r).egr_hw_reset_control_1[0]) & 0xffff)
#define BCM56218_A0_EGR_HW_RESET_CONTROL_1r_COUNTf_SET(r,f) (r).egr_hw_reset_control_1[0]=(((r).egr_hw_reset_control_1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56218_A0_EGR_HW_RESET_CONTROL_1r_RESET_ALLf_GET(r) ((((r).egr_hw_reset_control_1[0]) >> 16) & 0x1)
#define BCM56218_A0_EGR_HW_RESET_CONTROL_1r_RESET_ALLf_SET(r,f) (r).egr_hw_reset_control_1[0]=(((r).egr_hw_reset_control_1[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56218_A0_EGR_HW_RESET_CONTROL_1r_VALIDf_GET(r) ((((r).egr_hw_reset_control_1[0]) >> 17) & 0x1)
#define BCM56218_A0_EGR_HW_RESET_CONTROL_1r_VALIDf_SET(r,f) (r).egr_hw_reset_control_1[0]=(((r).egr_hw_reset_control_1[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_EGR_HW_RESET_CONTROL_1r_DONEf_GET(r) ((((r).egr_hw_reset_control_1[0]) >> 18) & 0x1)
#define BCM56218_A0_EGR_HW_RESET_CONTROL_1r_DONEf_SET(r,f) (r).egr_hw_reset_control_1[0]=(((r).egr_hw_reset_control_1[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))

/*
 * These macros can be used to access EGR_HW_RESET_CONTROL_1.
 *
 */
#define BCM56218_A0_READ_EGR_HW_RESET_CONTROL_1r(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_EGR_HW_RESET_CONTROL_1r,(r._egr_hw_reset_control_1))
#define BCM56218_A0_WRITE_EGR_HW_RESET_CONTROL_1r(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_EGR_HW_RESET_CONTROL_1r,&(r._egr_hw_reset_control_1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_HW_RESET_CONTROL_1r BCM56218_A0_EGR_HW_RESET_CONTROL_1r
#define EGR_HW_RESET_CONTROL_1r_SIZE BCM56218_A0_EGR_HW_RESET_CONTROL_1r_SIZE
typedef BCM56218_A0_EGR_HW_RESET_CONTROL_1r_t EGR_HW_RESET_CONTROL_1r_t;
#define EGR_HW_RESET_CONTROL_1r_CLR BCM56218_A0_EGR_HW_RESET_CONTROL_1r_CLR
#define EGR_HW_RESET_CONTROL_1r_SET BCM56218_A0_EGR_HW_RESET_CONTROL_1r_SET
#define EGR_HW_RESET_CONTROL_1r_GET BCM56218_A0_EGR_HW_RESET_CONTROL_1r_GET
#define EGR_HW_RESET_CONTROL_1r_COUNTf_GET BCM56218_A0_EGR_HW_RESET_CONTROL_1r_COUNTf_GET
#define EGR_HW_RESET_CONTROL_1r_COUNTf_SET BCM56218_A0_EGR_HW_RESET_CONTROL_1r_COUNTf_SET
#define EGR_HW_RESET_CONTROL_1r_RESET_ALLf_GET BCM56218_A0_EGR_HW_RESET_CONTROL_1r_RESET_ALLf_GET
#define EGR_HW_RESET_CONTROL_1r_RESET_ALLf_SET BCM56218_A0_EGR_HW_RESET_CONTROL_1r_RESET_ALLf_SET
#define EGR_HW_RESET_CONTROL_1r_VALIDf_GET BCM56218_A0_EGR_HW_RESET_CONTROL_1r_VALIDf_GET
#define EGR_HW_RESET_CONTROL_1r_VALIDf_SET BCM56218_A0_EGR_HW_RESET_CONTROL_1r_VALIDf_SET
#define EGR_HW_RESET_CONTROL_1r_DONEf_GET BCM56218_A0_EGR_HW_RESET_CONTROL_1r_DONEf_GET
#define EGR_HW_RESET_CONTROL_1r_DONEf_SET BCM56218_A0_EGR_HW_RESET_CONTROL_1r_DONEf_SET
#define READ_EGR_HW_RESET_CONTROL_1r BCM56218_A0_READ_EGR_HW_RESET_CONTROL_1r
#define WRITE_EGR_HW_RESET_CONTROL_1r BCM56218_A0_WRITE_EGR_HW_RESET_CONTROL_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_EGR_HW_RESET_CONTROL_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  EGR_IM_MTP_INDEX
 * BLOCKS:   EPIPE
 * DESC:     Mirror to Port Table to be used for IM tagged packets. 
Index is constructed using pbe.mtp_index[6:0] field.
We use {pbe.mtp_index[4:3],pbe.mtp_index[2:0]} as index into this table.

 * SIZE:     10
 * FIELDS:
 *     MTP_DST_MODID    DST_MODID field to be used in the module header in case of mirroring.
 *     MTP_DST_PORT     DST_PORT field to be used in module header in case of mirroring.
 *
 ******************************************************************************/
#define BCM56218_A0_EGR_IM_MTP_INDEXm 0x05920000

#define BCM56218_A0_EGR_IM_MTP_INDEXm_MIN 0
#define BCM56218_A0_EGR_IM_MTP_INDEXm_MAX 31
#define BCM56218_A0_EGR_IM_MTP_INDEXm_CMAX(u) 31
#define BCM56218_A0_EGR_IM_MTP_INDEXm_SIZE 2

/*
 * This structure should be used to declare and program EGR_IM_MTP_INDEX.
 *
 */
typedef union BCM56218_A0_EGR_IM_MTP_INDEXm_s {
	uint32_t v[1];
	uint32_t egr_im_mtp_index[1];
	uint32_t _egr_im_mtp_index;
} BCM56218_A0_EGR_IM_MTP_INDEXm_t;

#define BCM56218_A0_EGR_IM_MTP_INDEXm_CLR(r) (r).egr_im_mtp_index[0] = 0
#define BCM56218_A0_EGR_IM_MTP_INDEXm_SET(r,d) (r).egr_im_mtp_index[0] = d
#define BCM56218_A0_EGR_IM_MTP_INDEXm_GET(r) (r).egr_im_mtp_index[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_EGR_IM_MTP_INDEXm_MTP_DST_MODIDf_GET(r) (((r).egr_im_mtp_index[0]) & 0xf)
#define BCM56218_A0_EGR_IM_MTP_INDEXm_MTP_DST_MODIDf_SET(r,f) (r).egr_im_mtp_index[0]=(((r).egr_im_mtp_index[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56218_A0_EGR_IM_MTP_INDEXm_MTP_DST_PORTf_GET(r) ((((r).egr_im_mtp_index[0]) >> 4) & 0x3f)
#define BCM56218_A0_EGR_IM_MTP_INDEXm_MTP_DST_PORTf_SET(r,f) (r).egr_im_mtp_index[0]=(((r).egr_im_mtp_index[0] & ~((uint32_t)0x3f << 4)) | ((((uint32_t)f) & 0x3f) << 4))

/*
 * These macros can be used to access EGR_IM_MTP_INDEX.
 *
 */
#define BCM56218_A0_READ_EGR_IM_MTP_INDEXm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_EGR_IM_MTP_INDEXm,i,(m._egr_im_mtp_index),1)
#define BCM56218_A0_WRITE_EGR_IM_MTP_INDEXm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_EGR_IM_MTP_INDEXm,i,&(m._egr_im_mtp_index),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_IM_MTP_INDEXm BCM56218_A0_EGR_IM_MTP_INDEXm
#define EGR_IM_MTP_INDEXm_MIN BCM56218_A0_EGR_IM_MTP_INDEXm_MIN
#define EGR_IM_MTP_INDEXm_MAX BCM56218_A0_EGR_IM_MTP_INDEXm_MAX
#define EGR_IM_MTP_INDEXm_CMAX(u) BCM56218_A0_EGR_IM_MTP_INDEXm_CMAX(u)
#define EGR_IM_MTP_INDEXm_SIZE BCM56218_A0_EGR_IM_MTP_INDEXm_SIZE
typedef BCM56218_A0_EGR_IM_MTP_INDEXm_t EGR_IM_MTP_INDEXm_t;
#define EGR_IM_MTP_INDEXm_CLR BCM56218_A0_EGR_IM_MTP_INDEXm_CLR
#define EGR_IM_MTP_INDEXm_SET BCM56218_A0_EGR_IM_MTP_INDEXm_SET
#define EGR_IM_MTP_INDEXm_GET BCM56218_A0_EGR_IM_MTP_INDEXm_GET
#define EGR_IM_MTP_INDEXm_MTP_DST_MODIDf_GET BCM56218_A0_EGR_IM_MTP_INDEXm_MTP_DST_MODIDf_GET
#define EGR_IM_MTP_INDEXm_MTP_DST_MODIDf_SET BCM56218_A0_EGR_IM_MTP_INDEXm_MTP_DST_MODIDf_SET
#define EGR_IM_MTP_INDEXm_MTP_DST_PORTf_GET BCM56218_A0_EGR_IM_MTP_INDEXm_MTP_DST_PORTf_GET
#define EGR_IM_MTP_INDEXm_MTP_DST_PORTf_SET BCM56218_A0_EGR_IM_MTP_INDEXm_MTP_DST_PORTf_SET
#define READ_EGR_IM_MTP_INDEXm BCM56218_A0_READ_EGR_IM_MTP_INDEXm
#define WRITE_EGR_IM_MTP_INDEXm BCM56218_A0_WRITE_EGR_IM_MTP_INDEXm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_EGR_IM_MTP_INDEXm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  EGR_IP_TUNNEL
 * BLOCKS:   EPIPE
 * DESC:     Egress IP Tunnel Table. Used to Make new Tunnel Header.
 * SIZE:     134
 * FIELDS:
 *     DEST_ADDR        MAC DA to be used to change the pkt mac da in case of IP Tunneling.
 *     TTL              TTL to be used in the IP Tunnel Header.
 *     SIP              Source IP Address to be used in the IP Tunnel Header.
 *     DIP              Destination IP Address to be used in the IP Tunnel Header.
 *     TUNNEL_TYPE      Specifies which Tunnel Protocol is Supported by this entry.
 *     DSCP             Specifies what should be the new DSCP to be put int he tunnel header.
 *     DSCP_SEL         Specifies which dscp to choose to put in the outer tunnel header.               DSCP_SEL                Defines selection of DSCP               00 - Pick up from Tunnel Table               01 - Pick up from Packet (PICK_FROM_PACKET)               10 - Pick up from DSCP table (PICK_FROM_DSCP_TABLE)               11 - Reserved
 *     IPV4_DF_SEL      Specifies how to construct DF field if tunnel initiation is done for a v4 packet.		00 - Set DF to 0		01 - Set DF to 1		10 - Copy Inner IP Header DF field to tunnel header		11 - Copy Inner IP Header DF field to tunnel header
 *     IPV6_DF_SEL      Specifies how to construct DF field if tunnel initiation is done for a v6 packet.		0 - Set DF to 0		1 - Set DF to 1
 *
 ******************************************************************************/
#define BCM56218_A0_EGR_IP_TUNNELm 0x05910000

#define BCM56218_A0_EGR_IP_TUNNELm_MIN 0
#define BCM56218_A0_EGR_IP_TUNNELm_MAX 7
#define BCM56218_A0_EGR_IP_TUNNELm_CMAX(u) 7
#define BCM56218_A0_EGR_IP_TUNNELm_SIZE 17

/*
 * This structure should be used to declare and program EGR_IP_TUNNEL.
 *
 */
typedef union BCM56218_A0_EGR_IP_TUNNELm_s {
	uint32_t v[5];
	uint32_t egr_ip_tunnel[5];
	uint32_t _egr_ip_tunnel;
} BCM56218_A0_EGR_IP_TUNNELm_t;

#define BCM56218_A0_EGR_IP_TUNNELm_CLR(r) CDK_MEMSET(&((r)._egr_ip_tunnel), 0, sizeof(BCM56218_A0_EGR_IP_TUNNELm_t))
#define BCM56218_A0_EGR_IP_TUNNELm_SET(r,i,d) (r).egr_ip_tunnel[i] = d
#define BCM56218_A0_EGR_IP_TUNNELm_GET(r,i) (r).egr_ip_tunnel[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_EGR_IP_TUNNELm_DEST_ADDRf_GET(r,a) cdk_field_get((r).egr_ip_tunnel,0,47,a)
#define BCM56218_A0_EGR_IP_TUNNELm_DEST_ADDRf_SET(r,a) cdk_field_set((r).egr_ip_tunnel,0,47,a)
#define BCM56218_A0_EGR_IP_TUNNELm_TTLf_GET(r) ((((r).egr_ip_tunnel[1]) >> 16) & 0xff)
#define BCM56218_A0_EGR_IP_TUNNELm_TTLf_SET(r,f) (r).egr_ip_tunnel[1]=(((r).egr_ip_tunnel[1] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define BCM56218_A0_EGR_IP_TUNNELm_SIPf_GET(r) cdk_field32_get((r).egr_ip_tunnel,56,87)
#define BCM56218_A0_EGR_IP_TUNNELm_SIPf_SET(r,f) cdk_field32_set((r).egr_ip_tunnel,56,87,f)
#define BCM56218_A0_EGR_IP_TUNNELm_DIPf_GET(r) cdk_field32_get((r).egr_ip_tunnel,88,119)
#define BCM56218_A0_EGR_IP_TUNNELm_DIPf_SET(r,f) cdk_field32_set((r).egr_ip_tunnel,88,119,f)
#define BCM56218_A0_EGR_IP_TUNNELm_TUNNEL_TYPEf_GET(r) ((((r).egr_ip_tunnel[3]) >> 24) & 0x7)
#define BCM56218_A0_EGR_IP_TUNNELm_TUNNEL_TYPEf_SET(r,f) (r).egr_ip_tunnel[3]=(((r).egr_ip_tunnel[3] & ~((uint32_t)0x7 << 24)) | ((((uint32_t)f) & 0x7) << 24))
#define BCM56218_A0_EGR_IP_TUNNELm_DSCPf_GET(r) cdk_field32_get((r).egr_ip_tunnel,123,128)
#define BCM56218_A0_EGR_IP_TUNNELm_DSCPf_SET(r,f) cdk_field32_set((r).egr_ip_tunnel,123,128,f)
#define BCM56218_A0_EGR_IP_TUNNELm_DSCP_SELf_GET(r) ((((r).egr_ip_tunnel[4]) >> 1) & 0x3)
#define BCM56218_A0_EGR_IP_TUNNELm_DSCP_SELf_SET(r,f) (r).egr_ip_tunnel[4]=(((r).egr_ip_tunnel[4] & ~((uint32_t)0x3 << 1)) | ((((uint32_t)f) & 0x3) << 1))
#define BCM56218_A0_EGR_IP_TUNNELm_IPV4_DF_SELf_GET(r) ((((r).egr_ip_tunnel[4]) >> 3) & 0x3)
#define BCM56218_A0_EGR_IP_TUNNELm_IPV4_DF_SELf_SET(r,f) (r).egr_ip_tunnel[4]=(((r).egr_ip_tunnel[4] & ~((uint32_t)0x3 << 3)) | ((((uint32_t)f) & 0x3) << 3))
#define BCM56218_A0_EGR_IP_TUNNELm_IPV6_DF_SELf_GET(r) ((((r).egr_ip_tunnel[4]) >> 5) & 0x1)
#define BCM56218_A0_EGR_IP_TUNNELm_IPV6_DF_SELf_SET(r,f) (r).egr_ip_tunnel[4]=(((r).egr_ip_tunnel[4] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))

/*
 * These macros can be used to access EGR_IP_TUNNEL.
 *
 */
#define BCM56218_A0_READ_EGR_IP_TUNNELm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_EGR_IP_TUNNELm,i,(m._egr_ip_tunnel),5)
#define BCM56218_A0_WRITE_EGR_IP_TUNNELm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_EGR_IP_TUNNELm,i,&(m._egr_ip_tunnel),5)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_IP_TUNNELm BCM56218_A0_EGR_IP_TUNNELm
#define EGR_IP_TUNNELm_MIN BCM56218_A0_EGR_IP_TUNNELm_MIN
#define EGR_IP_TUNNELm_MAX BCM56218_A0_EGR_IP_TUNNELm_MAX
#define EGR_IP_TUNNELm_CMAX(u) BCM56218_A0_EGR_IP_TUNNELm_CMAX(u)
#define EGR_IP_TUNNELm_SIZE BCM56218_A0_EGR_IP_TUNNELm_SIZE
typedef BCM56218_A0_EGR_IP_TUNNELm_t EGR_IP_TUNNELm_t;
#define EGR_IP_TUNNELm_CLR BCM56218_A0_EGR_IP_TUNNELm_CLR
#define EGR_IP_TUNNELm_SET BCM56218_A0_EGR_IP_TUNNELm_SET
#define EGR_IP_TUNNELm_GET BCM56218_A0_EGR_IP_TUNNELm_GET
#define EGR_IP_TUNNELm_DEST_ADDRf_GET BCM56218_A0_EGR_IP_TUNNELm_DEST_ADDRf_GET
#define EGR_IP_TUNNELm_DEST_ADDRf_SET BCM56218_A0_EGR_IP_TUNNELm_DEST_ADDRf_SET
#define EGR_IP_TUNNELm_TTLf_GET BCM56218_A0_EGR_IP_TUNNELm_TTLf_GET
#define EGR_IP_TUNNELm_TTLf_SET BCM56218_A0_EGR_IP_TUNNELm_TTLf_SET
#define EGR_IP_TUNNELm_SIPf_GET BCM56218_A0_EGR_IP_TUNNELm_SIPf_GET
#define EGR_IP_TUNNELm_SIPf_SET BCM56218_A0_EGR_IP_TUNNELm_SIPf_SET
#define EGR_IP_TUNNELm_DIPf_GET BCM56218_A0_EGR_IP_TUNNELm_DIPf_GET
#define EGR_IP_TUNNELm_DIPf_SET BCM56218_A0_EGR_IP_TUNNELm_DIPf_SET
#define EGR_IP_TUNNELm_TUNNEL_TYPEf_GET BCM56218_A0_EGR_IP_TUNNELm_TUNNEL_TYPEf_GET
#define EGR_IP_TUNNELm_TUNNEL_TYPEf_SET BCM56218_A0_EGR_IP_TUNNELm_TUNNEL_TYPEf_SET
#define EGR_IP_TUNNELm_DSCPf_GET BCM56218_A0_EGR_IP_TUNNELm_DSCPf_GET
#define EGR_IP_TUNNELm_DSCPf_SET BCM56218_A0_EGR_IP_TUNNELm_DSCPf_SET
#define EGR_IP_TUNNELm_DSCP_SELf_GET BCM56218_A0_EGR_IP_TUNNELm_DSCP_SELf_GET
#define EGR_IP_TUNNELm_DSCP_SELf_SET BCM56218_A0_EGR_IP_TUNNELm_DSCP_SELf_SET
#define EGR_IP_TUNNELm_IPV4_DF_SELf_GET BCM56218_A0_EGR_IP_TUNNELm_IPV4_DF_SELf_GET
#define EGR_IP_TUNNELm_IPV4_DF_SELf_SET BCM56218_A0_EGR_IP_TUNNELm_IPV4_DF_SELf_SET
#define EGR_IP_TUNNELm_IPV6_DF_SELf_GET BCM56218_A0_EGR_IP_TUNNELm_IPV6_DF_SELf_GET
#define EGR_IP_TUNNELm_IPV6_DF_SELf_SET BCM56218_A0_EGR_IP_TUNNELm_IPV6_DF_SELf_SET
#define READ_EGR_IP_TUNNELm BCM56218_A0_READ_EGR_IP_TUNNELm
#define WRITE_EGR_IP_TUNNELm BCM56218_A0_WRITE_EGR_IP_TUNNELm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_EGR_IP_TUNNELm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  EGR_L3_INTF
 * BLOCKS:   EPIPE
 * DESC:     L3 Interface Table
 * SIZE:     64
 * FIELDS:
 *     TUNNEL_INDEX     Tunnel Index to be used to index EGR_IP_TUNNEL table.
 *     L2_SWITCH        Indicates if the packet needs to be only L2 Switched and only L2 modifications needs to be done.
 *     VID              VID to be used for L3 replacement
 *     MAC_ADDRESS      MAC Address to be used for SA Replacement in the L3 modifications.
 *
 ******************************************************************************/
#define BCM56218_A0_EGR_L3_INTFm 0x03920000

#define BCM56218_A0_EGR_L3_INTFm_MIN 0
#define BCM56218_A0_EGR_L3_INTFm_MAX 255
#define BCM56218_A0_EGR_L3_INTFm_CMAX(u) 255
#define BCM56218_A0_EGR_L3_INTFm_SIZE 8

/*
 * This structure should be used to declare and program EGR_L3_INTF.
 *
 */
typedef union BCM56218_A0_EGR_L3_INTFm_s {
	uint32_t v[2];
	uint32_t egr_l3_intf[2];
	uint32_t _egr_l3_intf;
} BCM56218_A0_EGR_L3_INTFm_t;

#define BCM56218_A0_EGR_L3_INTFm_CLR(r) CDK_MEMSET(&((r)._egr_l3_intf), 0, sizeof(BCM56218_A0_EGR_L3_INTFm_t))
#define BCM56218_A0_EGR_L3_INTFm_SET(r,i,d) (r).egr_l3_intf[i] = d
#define BCM56218_A0_EGR_L3_INTFm_GET(r,i) (r).egr_l3_intf[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_EGR_L3_INTFm_TUNNEL_INDEXf_GET(r) (((r).egr_l3_intf[0]) & 0x7)
#define BCM56218_A0_EGR_L3_INTFm_TUNNEL_INDEXf_SET(r,f) (r).egr_l3_intf[0]=(((r).egr_l3_intf[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM56218_A0_EGR_L3_INTFm_L2_SWITCHf_GET(r) ((((r).egr_l3_intf[0]) >> 3) & 0x1)
#define BCM56218_A0_EGR_L3_INTFm_L2_SWITCHf_SET(r,f) (r).egr_l3_intf[0]=(((r).egr_l3_intf[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56218_A0_EGR_L3_INTFm_VIDf_GET(r) ((((r).egr_l3_intf[0]) >> 4) & 0xfff)
#define BCM56218_A0_EGR_L3_INTFm_VIDf_SET(r,f) (r).egr_l3_intf[0]=(((r).egr_l3_intf[0] & ~((uint32_t)0xfff << 4)) | ((((uint32_t)f) & 0xfff) << 4))
#define BCM56218_A0_EGR_L3_INTFm_MAC_ADDRESSf_GET(r,a) cdk_field_get((r).egr_l3_intf,16,63,a)
#define BCM56218_A0_EGR_L3_INTFm_MAC_ADDRESSf_SET(r,a) cdk_field_set((r).egr_l3_intf,16,63,a)

/*
 * These macros can be used to access EGR_L3_INTF.
 *
 */
#define BCM56218_A0_READ_EGR_L3_INTFm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_EGR_L3_INTFm,i,(m._egr_l3_intf),2)
#define BCM56218_A0_WRITE_EGR_L3_INTFm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_EGR_L3_INTFm,i,&(m._egr_l3_intf),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_L3_INTFm BCM56218_A0_EGR_L3_INTFm
#define EGR_L3_INTFm_MIN BCM56218_A0_EGR_L3_INTFm_MIN
#define EGR_L3_INTFm_MAX BCM56218_A0_EGR_L3_INTFm_MAX
#define EGR_L3_INTFm_CMAX(u) BCM56218_A0_EGR_L3_INTFm_CMAX(u)
#define EGR_L3_INTFm_SIZE BCM56218_A0_EGR_L3_INTFm_SIZE
typedef BCM56218_A0_EGR_L3_INTFm_t EGR_L3_INTFm_t;
#define EGR_L3_INTFm_CLR BCM56218_A0_EGR_L3_INTFm_CLR
#define EGR_L3_INTFm_SET BCM56218_A0_EGR_L3_INTFm_SET
#define EGR_L3_INTFm_GET BCM56218_A0_EGR_L3_INTFm_GET
#define EGR_L3_INTFm_TUNNEL_INDEXf_GET BCM56218_A0_EGR_L3_INTFm_TUNNEL_INDEXf_GET
#define EGR_L3_INTFm_TUNNEL_INDEXf_SET BCM56218_A0_EGR_L3_INTFm_TUNNEL_INDEXf_SET
#define EGR_L3_INTFm_L2_SWITCHf_GET BCM56218_A0_EGR_L3_INTFm_L2_SWITCHf_GET
#define EGR_L3_INTFm_L2_SWITCHf_SET BCM56218_A0_EGR_L3_INTFm_L2_SWITCHf_SET
#define EGR_L3_INTFm_VIDf_GET BCM56218_A0_EGR_L3_INTFm_VIDf_GET
#define EGR_L3_INTFm_VIDf_SET BCM56218_A0_EGR_L3_INTFm_VIDf_SET
#define EGR_L3_INTFm_MAC_ADDRESSf_GET BCM56218_A0_EGR_L3_INTFm_MAC_ADDRESSf_GET
#define EGR_L3_INTFm_MAC_ADDRESSf_SET BCM56218_A0_EGR_L3_INTFm_MAC_ADDRESSf_SET
#define READ_EGR_L3_INTFm BCM56218_A0_READ_EGR_L3_INTFm
#define WRITE_EGR_L3_INTFm BCM56218_A0_WRITE_EGR_L3_INTFm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_EGR_L3_INTFm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  EGR_L3_NEXT_HOP
 * BLOCKS:   EPIPE
 * DESC:     Next Hop Table
 * SIZE:     60
 * FIELDS:
 *     INTF_NUM         Interface Number to be used as index for L3_INTF table if a pkt is L3 routed.In case FP indicates change_vid and pkt is NOT l3 routed, this field will give new vid.
 *     MAC_ADDRESS      Mac Address to be used for DA replacement by L3UC or FP modified packets.
 *
 ******************************************************************************/
#define BCM56218_A0_EGR_L3_NEXT_HOPm 0x03910000

#define BCM56218_A0_EGR_L3_NEXT_HOPm_MIN 0
#define BCM56218_A0_EGR_L3_NEXT_HOPm_MAX 255
#define BCM56218_A0_EGR_L3_NEXT_HOPm_CMAX(u) 255
#define BCM56218_A0_EGR_L3_NEXT_HOPm_SIZE 8

/*
 * This structure should be used to declare and program EGR_L3_NEXT_HOP.
 *
 */
typedef union BCM56218_A0_EGR_L3_NEXT_HOPm_s {
	uint32_t v[2];
	uint32_t egr_l3_next_hop[2];
	uint32_t _egr_l3_next_hop;
} BCM56218_A0_EGR_L3_NEXT_HOPm_t;

#define BCM56218_A0_EGR_L3_NEXT_HOPm_CLR(r) CDK_MEMSET(&((r)._egr_l3_next_hop), 0, sizeof(BCM56218_A0_EGR_L3_NEXT_HOPm_t))
#define BCM56218_A0_EGR_L3_NEXT_HOPm_SET(r,i,d) (r).egr_l3_next_hop[i] = d
#define BCM56218_A0_EGR_L3_NEXT_HOPm_GET(r,i) (r).egr_l3_next_hop[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_EGR_L3_NEXT_HOPm_INTF_NUMf_GET(r) (((r).egr_l3_next_hop[0]) & 0xfff)
#define BCM56218_A0_EGR_L3_NEXT_HOPm_INTF_NUMf_SET(r,f) (r).egr_l3_next_hop[0]=(((r).egr_l3_next_hop[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM56218_A0_EGR_L3_NEXT_HOPm_MAC_ADDRESSf_GET(r,a) cdk_field_get((r).egr_l3_next_hop,12,59,a)
#define BCM56218_A0_EGR_L3_NEXT_HOPm_MAC_ADDRESSf_SET(r,a) cdk_field_set((r).egr_l3_next_hop,12,59,a)

/*
 * These macros can be used to access EGR_L3_NEXT_HOP.
 *
 */
#define BCM56218_A0_READ_EGR_L3_NEXT_HOPm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_EGR_L3_NEXT_HOPm,i,(m._egr_l3_next_hop),2)
#define BCM56218_A0_WRITE_EGR_L3_NEXT_HOPm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_EGR_L3_NEXT_HOPm,i,&(m._egr_l3_next_hop),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_L3_NEXT_HOPm BCM56218_A0_EGR_L3_NEXT_HOPm
#define EGR_L3_NEXT_HOPm_MIN BCM56218_A0_EGR_L3_NEXT_HOPm_MIN
#define EGR_L3_NEXT_HOPm_MAX BCM56218_A0_EGR_L3_NEXT_HOPm_MAX
#define EGR_L3_NEXT_HOPm_CMAX(u) BCM56218_A0_EGR_L3_NEXT_HOPm_CMAX(u)
#define EGR_L3_NEXT_HOPm_SIZE BCM56218_A0_EGR_L3_NEXT_HOPm_SIZE
typedef BCM56218_A0_EGR_L3_NEXT_HOPm_t EGR_L3_NEXT_HOPm_t;
#define EGR_L3_NEXT_HOPm_CLR BCM56218_A0_EGR_L3_NEXT_HOPm_CLR
#define EGR_L3_NEXT_HOPm_SET BCM56218_A0_EGR_L3_NEXT_HOPm_SET
#define EGR_L3_NEXT_HOPm_GET BCM56218_A0_EGR_L3_NEXT_HOPm_GET
#define EGR_L3_NEXT_HOPm_INTF_NUMf_GET BCM56218_A0_EGR_L3_NEXT_HOPm_INTF_NUMf_GET
#define EGR_L3_NEXT_HOPm_INTF_NUMf_SET BCM56218_A0_EGR_L3_NEXT_HOPm_INTF_NUMf_SET
#define EGR_L3_NEXT_HOPm_MAC_ADDRESSf_GET BCM56218_A0_EGR_L3_NEXT_HOPm_MAC_ADDRESSf_GET
#define EGR_L3_NEXT_HOPm_MAC_ADDRESSf_SET BCM56218_A0_EGR_L3_NEXT_HOPm_MAC_ADDRESSf_SET
#define READ_EGR_L3_NEXT_HOPm BCM56218_A0_READ_EGR_L3_NEXT_HOPm
#define WRITE_EGR_L3_NEXT_HOPm BCM56218_A0_WRITE_EGR_L3_NEXT_HOPm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_EGR_L3_NEXT_HOPm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  EGR_MASK
 * BLOCKS:   IPIPE
 * DESC:     Egress Mask Table. index is (modid,port_tgid)
 * SIZE:     54
 * FIELDS:
 *     EGRESS_MASK      Egress mask block mask for source port
 *     EGRESS_MASK_LO   Egress mask block mask for source port
 *     EGRESS_MASK_HI   Egress mask block mask for source port
 *
 ******************************************************************************/
#define BCM56218_A0_EGR_MASKm 0x0e700000

#define BCM56218_A0_EGR_MASKm_MIN 0
#define BCM56218_A0_EGR_MASKm_MAX 1023
#define BCM56218_A0_EGR_MASKm_CMAX(u) 1023
#define BCM56218_A0_EGR_MASKm_SIZE 7

/*
 * This structure should be used to declare and program EGR_MASK.
 *
 */
typedef union BCM56218_A0_EGR_MASKm_s {
	uint32_t v[2];
	uint32_t egr_mask[2];
	uint32_t _egr_mask;
} BCM56218_A0_EGR_MASKm_t;

#define BCM56218_A0_EGR_MASKm_CLR(r) CDK_MEMSET(&((r)._egr_mask), 0, sizeof(BCM56218_A0_EGR_MASKm_t))
#define BCM56218_A0_EGR_MASKm_SET(r,i,d) (r).egr_mask[i] = d
#define BCM56218_A0_EGR_MASKm_GET(r,i) (r).egr_mask[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_EGR_MASKm_EGRESS_MASKf_GET(r,a) cdk_field_get((r).egr_mask,0,53,a)
#define BCM56218_A0_EGR_MASKm_EGRESS_MASKf_SET(r,a) cdk_field_set((r).egr_mask,0,53,a)
#define BCM56218_A0_EGR_MASKm_EGRESS_MASK_LOf_GET(r) ((r).egr_mask[0])
#define BCM56218_A0_EGR_MASKm_EGRESS_MASK_LOf_SET(r,f) (r).egr_mask[0]=((uint32_t)f)
#define BCM56218_A0_EGR_MASKm_EGRESS_MASK_HIf_GET(r) (((r).egr_mask[1]) & 0x3fffff)
#define BCM56218_A0_EGR_MASKm_EGRESS_MASK_HIf_SET(r,f) (r).egr_mask[1]=(((r).egr_mask[1] & ~((uint32_t)0x3fffff)) | (((uint32_t)f) & 0x3fffff))

/*
 * These macros can be used to access EGR_MASK.
 *
 */
#define BCM56218_A0_READ_EGR_MASKm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_EGR_MASKm,i,(m._egr_mask),2)
#define BCM56218_A0_WRITE_EGR_MASKm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_EGR_MASKm,i,&(m._egr_mask),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_MASKm BCM56218_A0_EGR_MASKm
#define EGR_MASKm_MIN BCM56218_A0_EGR_MASKm_MIN
#define EGR_MASKm_MAX BCM56218_A0_EGR_MASKm_MAX
#define EGR_MASKm_CMAX(u) BCM56218_A0_EGR_MASKm_CMAX(u)
#define EGR_MASKm_SIZE BCM56218_A0_EGR_MASKm_SIZE
typedef BCM56218_A0_EGR_MASKm_t EGR_MASKm_t;
#define EGR_MASKm_CLR BCM56218_A0_EGR_MASKm_CLR
#define EGR_MASKm_SET BCM56218_A0_EGR_MASKm_SET
#define EGR_MASKm_GET BCM56218_A0_EGR_MASKm_GET
#define EGR_MASKm_EGRESS_MASKf_GET BCM56218_A0_EGR_MASKm_EGRESS_MASKf_GET
#define EGR_MASKm_EGRESS_MASKf_SET BCM56218_A0_EGR_MASKm_EGRESS_MASKf_SET
#define EGR_MASKm_EGRESS_MASK_LOf_GET BCM56218_A0_EGR_MASKm_EGRESS_MASK_LOf_GET
#define EGR_MASKm_EGRESS_MASK_LOf_SET BCM56218_A0_EGR_MASKm_EGRESS_MASK_LOf_SET
#define EGR_MASKm_EGRESS_MASK_HIf_GET BCM56218_A0_EGR_MASKm_EGRESS_MASK_HIf_GET
#define EGR_MASKm_EGRESS_MASK_HIf_SET BCM56218_A0_EGR_MASKm_EGRESS_MASK_HIf_SET
#define READ_EGR_MASKm BCM56218_A0_READ_EGR_MASKm
#define WRITE_EGR_MASKm BCM56218_A0_WRITE_EGR_MASKm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_EGR_MASKm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  EGR_MC_CONTROL_1
 * BLOCKS:   EPIPE
 * DESC:     Used to locate the mc index on MGID={dst_mod,dst_port} combination from HG2. 
 * SIZE:     32
 * FIELDS:
 *     HIGIG2_BC_SIZE   Size of the index.
 *     HIGIG2_BC_BASE_OFFSET offset to locate the index.
 *
 ******************************************************************************/
#define BCM56218_A0_EGR_MC_CONTROL_1r 0x09980001

#define BCM56218_A0_EGR_MC_CONTROL_1r_SIZE 4

/*
 * This structure should be used to declare and program EGR_MC_CONTROL_1.
 *
 */
typedef union BCM56218_A0_EGR_MC_CONTROL_1r_s {
	uint32_t v[1];
	uint32_t egr_mc_control_1[1];
	uint32_t _egr_mc_control_1;
} BCM56218_A0_EGR_MC_CONTROL_1r_t;

#define BCM56218_A0_EGR_MC_CONTROL_1r_CLR(r) (r).egr_mc_control_1[0] = 0
#define BCM56218_A0_EGR_MC_CONTROL_1r_SET(r,d) (r).egr_mc_control_1[0] = d
#define BCM56218_A0_EGR_MC_CONTROL_1r_GET(r) (r).egr_mc_control_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_EGR_MC_CONTROL_1r_HIGIG2_BC_SIZEf_GET(r) (((r).egr_mc_control_1[0]) & 0xffff)
#define BCM56218_A0_EGR_MC_CONTROL_1r_HIGIG2_BC_SIZEf_SET(r,f) (r).egr_mc_control_1[0]=(((r).egr_mc_control_1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56218_A0_EGR_MC_CONTROL_1r_HIGIG2_BC_BASE_OFFSETf_GET(r) ((((r).egr_mc_control_1[0]) >> 16) & 0xffff)
#define BCM56218_A0_EGR_MC_CONTROL_1r_HIGIG2_BC_BASE_OFFSETf_SET(r,f) (r).egr_mc_control_1[0]=(((r).egr_mc_control_1[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access EGR_MC_CONTROL_1.
 *
 */
#define BCM56218_A0_READ_EGR_MC_CONTROL_1r(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_EGR_MC_CONTROL_1r,(r._egr_mc_control_1))
#define BCM56218_A0_WRITE_EGR_MC_CONTROL_1r(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_EGR_MC_CONTROL_1r,&(r._egr_mc_control_1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_MC_CONTROL_1r BCM56218_A0_EGR_MC_CONTROL_1r
#define EGR_MC_CONTROL_1r_SIZE BCM56218_A0_EGR_MC_CONTROL_1r_SIZE
typedef BCM56218_A0_EGR_MC_CONTROL_1r_t EGR_MC_CONTROL_1r_t;
#define EGR_MC_CONTROL_1r_CLR BCM56218_A0_EGR_MC_CONTROL_1r_CLR
#define EGR_MC_CONTROL_1r_SET BCM56218_A0_EGR_MC_CONTROL_1r_SET
#define EGR_MC_CONTROL_1r_GET BCM56218_A0_EGR_MC_CONTROL_1r_GET
#define EGR_MC_CONTROL_1r_HIGIG2_BC_SIZEf_GET BCM56218_A0_EGR_MC_CONTROL_1r_HIGIG2_BC_SIZEf_GET
#define EGR_MC_CONTROL_1r_HIGIG2_BC_SIZEf_SET BCM56218_A0_EGR_MC_CONTROL_1r_HIGIG2_BC_SIZEf_SET
#define EGR_MC_CONTROL_1r_HIGIG2_BC_BASE_OFFSETf_GET BCM56218_A0_EGR_MC_CONTROL_1r_HIGIG2_BC_BASE_OFFSETf_GET
#define EGR_MC_CONTROL_1r_HIGIG2_BC_BASE_OFFSETf_SET BCM56218_A0_EGR_MC_CONTROL_1r_HIGIG2_BC_BASE_OFFSETf_SET
#define READ_EGR_MC_CONTROL_1r BCM56218_A0_READ_EGR_MC_CONTROL_1r
#define WRITE_EGR_MC_CONTROL_1r BCM56218_A0_WRITE_EGR_MC_CONTROL_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_EGR_MC_CONTROL_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  EGR_MC_CONTROL_2
 * BLOCKS:   EPIPE
 * DESC:     Used to locate the mc index on mgid={dst_mod,dst_port} combination from HG2. 
 * SIZE:     32
 * FIELDS:
 *     HIGIG2_MC_SIZE   Size of the index.
 *     HIGIG2_MC_BASE_OFFSET offset to locate the index.
 *
 ******************************************************************************/
#define BCM56218_A0_EGR_MC_CONTROL_2r 0x09980002

#define BCM56218_A0_EGR_MC_CONTROL_2r_SIZE 4

/*
 * This structure should be used to declare and program EGR_MC_CONTROL_2.
 *
 */
typedef union BCM56218_A0_EGR_MC_CONTROL_2r_s {
	uint32_t v[1];
	uint32_t egr_mc_control_2[1];
	uint32_t _egr_mc_control_2;
} BCM56218_A0_EGR_MC_CONTROL_2r_t;

#define BCM56218_A0_EGR_MC_CONTROL_2r_CLR(r) (r).egr_mc_control_2[0] = 0
#define BCM56218_A0_EGR_MC_CONTROL_2r_SET(r,d) (r).egr_mc_control_2[0] = d
#define BCM56218_A0_EGR_MC_CONTROL_2r_GET(r) (r).egr_mc_control_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_EGR_MC_CONTROL_2r_HIGIG2_MC_SIZEf_GET(r) (((r).egr_mc_control_2[0]) & 0xffff)
#define BCM56218_A0_EGR_MC_CONTROL_2r_HIGIG2_MC_SIZEf_SET(r,f) (r).egr_mc_control_2[0]=(((r).egr_mc_control_2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56218_A0_EGR_MC_CONTROL_2r_HIGIG2_MC_BASE_OFFSETf_GET(r) ((((r).egr_mc_control_2[0]) >> 16) & 0xffff)
#define BCM56218_A0_EGR_MC_CONTROL_2r_HIGIG2_MC_BASE_OFFSETf_SET(r,f) (r).egr_mc_control_2[0]=(((r).egr_mc_control_2[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access EGR_MC_CONTROL_2.
 *
 */
#define BCM56218_A0_READ_EGR_MC_CONTROL_2r(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_EGR_MC_CONTROL_2r,(r._egr_mc_control_2))
#define BCM56218_A0_WRITE_EGR_MC_CONTROL_2r(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_EGR_MC_CONTROL_2r,&(r._egr_mc_control_2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_MC_CONTROL_2r BCM56218_A0_EGR_MC_CONTROL_2r
#define EGR_MC_CONTROL_2r_SIZE BCM56218_A0_EGR_MC_CONTROL_2r_SIZE
typedef BCM56218_A0_EGR_MC_CONTROL_2r_t EGR_MC_CONTROL_2r_t;
#define EGR_MC_CONTROL_2r_CLR BCM56218_A0_EGR_MC_CONTROL_2r_CLR
#define EGR_MC_CONTROL_2r_SET BCM56218_A0_EGR_MC_CONTROL_2r_SET
#define EGR_MC_CONTROL_2r_GET BCM56218_A0_EGR_MC_CONTROL_2r_GET
#define EGR_MC_CONTROL_2r_HIGIG2_MC_SIZEf_GET BCM56218_A0_EGR_MC_CONTROL_2r_HIGIG2_MC_SIZEf_GET
#define EGR_MC_CONTROL_2r_HIGIG2_MC_SIZEf_SET BCM56218_A0_EGR_MC_CONTROL_2r_HIGIG2_MC_SIZEf_SET
#define EGR_MC_CONTROL_2r_HIGIG2_MC_BASE_OFFSETf_GET BCM56218_A0_EGR_MC_CONTROL_2r_HIGIG2_MC_BASE_OFFSETf_GET
#define EGR_MC_CONTROL_2r_HIGIG2_MC_BASE_OFFSETf_SET BCM56218_A0_EGR_MC_CONTROL_2r_HIGIG2_MC_BASE_OFFSETf_SET
#define READ_EGR_MC_CONTROL_2r BCM56218_A0_READ_EGR_MC_CONTROL_2r
#define WRITE_EGR_MC_CONTROL_2r BCM56218_A0_WRITE_EGR_MC_CONTROL_2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_EGR_MC_CONTROL_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  EGR_MMU_REQUESTS
 * BLOCKS:   EPIPE
 * DESC:     This register contains the cell requests asserted by TP for individual ports to MMU.
Meaning of cell request is 1024 bits data. All it shows is the number of times cell_request signal
was asserted by TP to MMU for each port. 

 * SIZE:     32
 * FIELDS:
 *     OUTSTANDING_PORT_REQUESTS Number of cell requests.
 *
 ******************************************************************************/
#define BCM56218_A0_EGR_MMU_REQUESTSr 0x0a900102

#define BCM56218_A0_EGR_MMU_REQUESTSr_SIZE 4

/*
 * This structure should be used to declare and program EGR_MMU_REQUESTS.
 *
 */
typedef union BCM56218_A0_EGR_MMU_REQUESTSr_s {
	uint32_t v[1];
	uint32_t egr_mmu_requests[1];
	uint32_t _egr_mmu_requests;
} BCM56218_A0_EGR_MMU_REQUESTSr_t;

#define BCM56218_A0_EGR_MMU_REQUESTSr_CLR(r) (r).egr_mmu_requests[0] = 0
#define BCM56218_A0_EGR_MMU_REQUESTSr_SET(r,d) (r).egr_mmu_requests[0] = d
#define BCM56218_A0_EGR_MMU_REQUESTSr_GET(r) (r).egr_mmu_requests[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_EGR_MMU_REQUESTSr_OUTSTANDING_PORT_REQUESTSf_GET(r) (((r).egr_mmu_requests[0]) & 0xf)
#define BCM56218_A0_EGR_MMU_REQUESTSr_OUTSTANDING_PORT_REQUESTSf_SET(r,f) (r).egr_mmu_requests[0]=(((r).egr_mmu_requests[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access EGR_MMU_REQUESTS.
 *
 */
#define BCM56218_A0_READ_EGR_MMU_REQUESTSr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_EGR_MMU_REQUESTSr,(r._egr_mmu_requests))
#define BCM56218_A0_WRITE_EGR_MMU_REQUESTSr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_EGR_MMU_REQUESTSr,&(r._egr_mmu_requests))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_MMU_REQUESTSr BCM56218_A0_EGR_MMU_REQUESTSr
#define EGR_MMU_REQUESTSr_SIZE BCM56218_A0_EGR_MMU_REQUESTSr_SIZE
typedef BCM56218_A0_EGR_MMU_REQUESTSr_t EGR_MMU_REQUESTSr_t;
#define EGR_MMU_REQUESTSr_CLR BCM56218_A0_EGR_MMU_REQUESTSr_CLR
#define EGR_MMU_REQUESTSr_SET BCM56218_A0_EGR_MMU_REQUESTSr_SET
#define EGR_MMU_REQUESTSr_GET BCM56218_A0_EGR_MMU_REQUESTSr_GET
#define EGR_MMU_REQUESTSr_OUTSTANDING_PORT_REQUESTSf_GET BCM56218_A0_EGR_MMU_REQUESTSr_OUTSTANDING_PORT_REQUESTSf_GET
#define EGR_MMU_REQUESTSr_OUTSTANDING_PORT_REQUESTSf_SET BCM56218_A0_EGR_MMU_REQUESTSr_OUTSTANDING_PORT_REQUESTSf_SET
#define READ_EGR_MMU_REQUESTSr BCM56218_A0_READ_EGR_MMU_REQUESTSr
#define WRITE_EGR_MMU_REQUESTSr BCM56218_A0_WRITE_EGR_MMU_REQUESTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_EGR_MMU_REQUESTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  EGR_MTU_SIZE
 * BLOCKS:   IPIPE
 * DESC:     Egress MTU Size Register
 * SIZE:     32
 * FIELDS:
 *     MTU_SIZE         Egress ports MTU limit
 *
 ******************************************************************************/
#define BCM56218_A0_EGR_MTU_SIZEr 0x0e700124

#define BCM56218_A0_EGR_MTU_SIZEr_SIZE 4

/*
 * This structure should be used to declare and program EGR_MTU_SIZE.
 *
 */
typedef union BCM56218_A0_EGR_MTU_SIZEr_s {
	uint32_t v[1];
	uint32_t egr_mtu_size[1];
	uint32_t _egr_mtu_size;
} BCM56218_A0_EGR_MTU_SIZEr_t;

#define BCM56218_A0_EGR_MTU_SIZEr_CLR(r) (r).egr_mtu_size[0] = 0
#define BCM56218_A0_EGR_MTU_SIZEr_SET(r,d) (r).egr_mtu_size[0] = d
#define BCM56218_A0_EGR_MTU_SIZEr_GET(r) (r).egr_mtu_size[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_EGR_MTU_SIZEr_MTU_SIZEf_GET(r) (((r).egr_mtu_size[0]) & 0x3fff)
#define BCM56218_A0_EGR_MTU_SIZEr_MTU_SIZEf_SET(r,f) (r).egr_mtu_size[0]=(((r).egr_mtu_size[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access EGR_MTU_SIZE.
 *
 */
#define BCM56218_A0_READ_EGR_MTU_SIZEr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_EGR_MTU_SIZEr,(r._egr_mtu_size))
#define BCM56218_A0_WRITE_EGR_MTU_SIZEr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_EGR_MTU_SIZEr,&(r._egr_mtu_size))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_MTU_SIZEr BCM56218_A0_EGR_MTU_SIZEr
#define EGR_MTU_SIZEr_SIZE BCM56218_A0_EGR_MTU_SIZEr_SIZE
typedef BCM56218_A0_EGR_MTU_SIZEr_t EGR_MTU_SIZEr_t;
#define EGR_MTU_SIZEr_CLR BCM56218_A0_EGR_MTU_SIZEr_CLR
#define EGR_MTU_SIZEr_SET BCM56218_A0_EGR_MTU_SIZEr_SET
#define EGR_MTU_SIZEr_GET BCM56218_A0_EGR_MTU_SIZEr_GET
#define EGR_MTU_SIZEr_MTU_SIZEf_GET BCM56218_A0_EGR_MTU_SIZEr_MTU_SIZEf_GET
#define EGR_MTU_SIZEr_MTU_SIZEf_SET BCM56218_A0_EGR_MTU_SIZEr_MTU_SIZEf_SET
#define READ_EGR_MTU_SIZEr BCM56218_A0_READ_EGR_MTU_SIZEr
#define WRITE_EGR_MTU_SIZEr BCM56218_A0_WRITE_EGR_MTU_SIZEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_EGR_MTU_SIZEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  EGR_PORT
 * BLOCKS:   EPIPE
 * DESC:     Configuration Register for a Port. This is different for each GE, 10GE port.


 * SIZE:     32
 * FIELDS:
 *     PORT_TYPE        Specifies the type of the port. Bit[0] of PORT_TYPE field is HIGIG_BIT. If it is set, then the port is in Higig Mode.	0 = GE/10GE/CPU Port.	1 = HIGIG Port.Bit[1] of PORT_TYPE field is NNI_BIT. If it is set, then the port is NNI port, else UNI Port.	0 = UNI Port.	1 = NNI Port.
 *     HIGIG_PACKET     This port is a higig port.
 *     NNI_PORT         Port is NNI port if set to 1, otherwise UNI port.
 *     EN_EFILTER       RESERVED This feature is not supported for Raptor. This bit is don't care.
 *     PRESERVE_CPU_TAG Preserve the tag of the packet destines to CPU.
 *     CFI              If CFI-CNG mapping is enabled for the chip, i.e. EGR_CONFIG.CFI_AS_CNG bit is set, then thisfield corresponds to the values of CNG coming from MMU. e.g. If MMU.CNG = 0, then Packet.CFI = CFI[0]     If MMU.CNG = 1, then Packet.CFI = CFI[1] and so on.
 *     EM_SRCMOD_CHANGE Set to change the src_modid for the egress mirrored pkts going out of the higig port.
 *     MY_MODID         Module ID of this chip.
 *
 ******************************************************************************/
#define BCM56218_A0_EGR_PORTr 0x01900002

#define BCM56218_A0_EGR_PORTr_SIZE 4

/*
 * This structure should be used to declare and program EGR_PORT.
 *
 */
typedef union BCM56218_A0_EGR_PORTr_s {
	uint32_t v[1];
	uint32_t egr_port[1];
	uint32_t _egr_port;
} BCM56218_A0_EGR_PORTr_t;

#define BCM56218_A0_EGR_PORTr_CLR(r) (r).egr_port[0] = 0
#define BCM56218_A0_EGR_PORTr_SET(r,d) (r).egr_port[0] = d
#define BCM56218_A0_EGR_PORTr_GET(r) (r).egr_port[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_EGR_PORTr_PORT_TYPEf_GET(r) (((r).egr_port[0]) & 0x3)
#define BCM56218_A0_EGR_PORTr_PORT_TYPEf_SET(r,f) (r).egr_port[0]=(((r).egr_port[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56218_A0_EGR_PORTr_HIGIG_PACKETf_GET(r) (((r).egr_port[0]) & 0x1)
#define BCM56218_A0_EGR_PORTr_HIGIG_PACKETf_SET(r,f) (r).egr_port[0]=(((r).egr_port[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_EGR_PORTr_NNI_PORTf_GET(r) ((((r).egr_port[0]) >> 1) & 0x1)
#define BCM56218_A0_EGR_PORTr_NNI_PORTf_SET(r,f) (r).egr_port[0]=(((r).egr_port[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_EGR_PORTr_EN_EFILTERf_GET(r) ((((r).egr_port[0]) >> 2) & 0x1)
#define BCM56218_A0_EGR_PORTr_EN_EFILTERf_SET(r,f) (r).egr_port[0]=(((r).egr_port[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_EGR_PORTr_PRESERVE_CPU_TAGf_GET(r) ((((r).egr_port[0]) >> 3) & 0x1)
#define BCM56218_A0_EGR_PORTr_PRESERVE_CPU_TAGf_SET(r,f) (r).egr_port[0]=(((r).egr_port[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56218_A0_EGR_PORTr_CFIf_GET(r) ((((r).egr_port[0]) >> 4) & 0xf)
#define BCM56218_A0_EGR_PORTr_CFIf_SET(r,f) (r).egr_port[0]=(((r).egr_port[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56218_A0_EGR_PORTr_EM_SRCMOD_CHANGEf_GET(r) ((((r).egr_port[0]) >> 8) & 0x1)
#define BCM56218_A0_EGR_PORTr_EM_SRCMOD_CHANGEf_SET(r,f) (r).egr_port[0]=(((r).egr_port[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56218_A0_EGR_PORTr_MY_MODIDf_GET(r) ((((r).egr_port[0]) >> 9) & 0xf)
#define BCM56218_A0_EGR_PORTr_MY_MODIDf_SET(r,f) (r).egr_port[0]=(((r).egr_port[0] & ~((uint32_t)0xf << 9)) | ((((uint32_t)f) & 0xf) << 9))

/*
 * These macros can be used to access EGR_PORT.
 *
 */
#define BCM56218_A0_READ_EGR_PORTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_EGR_PORTr,(r._egr_port))
#define BCM56218_A0_WRITE_EGR_PORTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_EGR_PORTr,&(r._egr_port))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_PORTr BCM56218_A0_EGR_PORTr
#define EGR_PORTr_SIZE BCM56218_A0_EGR_PORTr_SIZE
typedef BCM56218_A0_EGR_PORTr_t EGR_PORTr_t;
#define EGR_PORTr_CLR BCM56218_A0_EGR_PORTr_CLR
#define EGR_PORTr_SET BCM56218_A0_EGR_PORTr_SET
#define EGR_PORTr_GET BCM56218_A0_EGR_PORTr_GET
#define EGR_PORTr_PORT_TYPEf_GET BCM56218_A0_EGR_PORTr_PORT_TYPEf_GET
#define EGR_PORTr_PORT_TYPEf_SET BCM56218_A0_EGR_PORTr_PORT_TYPEf_SET
#define EGR_PORTr_HIGIG_PACKETf_GET BCM56218_A0_EGR_PORTr_HIGIG_PACKETf_GET
#define EGR_PORTr_HIGIG_PACKETf_SET BCM56218_A0_EGR_PORTr_HIGIG_PACKETf_SET
#define EGR_PORTr_NNI_PORTf_GET BCM56218_A0_EGR_PORTr_NNI_PORTf_GET
#define EGR_PORTr_NNI_PORTf_SET BCM56218_A0_EGR_PORTr_NNI_PORTf_SET
#define EGR_PORTr_EN_EFILTERf_GET BCM56218_A0_EGR_PORTr_EN_EFILTERf_GET
#define EGR_PORTr_EN_EFILTERf_SET BCM56218_A0_EGR_PORTr_EN_EFILTERf_SET
#define EGR_PORTr_PRESERVE_CPU_TAGf_GET BCM56218_A0_EGR_PORTr_PRESERVE_CPU_TAGf_GET
#define EGR_PORTr_PRESERVE_CPU_TAGf_SET BCM56218_A0_EGR_PORTr_PRESERVE_CPU_TAGf_SET
#define EGR_PORTr_CFIf_GET BCM56218_A0_EGR_PORTr_CFIf_GET
#define EGR_PORTr_CFIf_SET BCM56218_A0_EGR_PORTr_CFIf_SET
#define EGR_PORTr_EM_SRCMOD_CHANGEf_GET BCM56218_A0_EGR_PORTr_EM_SRCMOD_CHANGEf_GET
#define EGR_PORTr_EM_SRCMOD_CHANGEf_SET BCM56218_A0_EGR_PORTr_EM_SRCMOD_CHANGEf_SET
#define EGR_PORTr_MY_MODIDf_GET BCM56218_A0_EGR_PORTr_MY_MODIDf_GET
#define EGR_PORTr_MY_MODIDf_SET BCM56218_A0_EGR_PORTr_MY_MODIDf_SET
#define READ_EGR_PORTr BCM56218_A0_READ_EGR_PORTr
#define WRITE_EGR_PORTr BCM56218_A0_WRITE_EGR_PORTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_EGR_PORTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  EGR_PORT_L3UC_MODS
 * BLOCKS:   EPIPE
 * DESC:     Configuration Register for IPMC related modifications.


 * SIZE:     32
 * FIELDS:
 *     L3_UC_SA_DISABLE Disable the SA replacement for L3UC packets coming from a particular port. This register is indexed in EP based on the src_port_num.
 *     L3_UC_DA_DISABLE Disable the DA replacement for L3UC packets coming from a particular port. This register is indexed in EP based on the src_port_num.
 *     L3_UC_TTL_DISABLE Disable the TTL decrement for L3UC packets coming from a particular port. This register is indexed in EP based on the src_port_num.
 *     L3_UC_VLAN_DISABLE Disable the outer VID replacement for L3UC packets coming from a particular port. This register is indexed in EP based on the src_port_num.
 *
 ******************************************************************************/
#define BCM56218_A0_EGR_PORT_L3UC_MODSr 0x01900004

#define BCM56218_A0_EGR_PORT_L3UC_MODSr_SIZE 4

/*
 * This structure should be used to declare and program EGR_PORT_L3UC_MODS.
 *
 */
typedef union BCM56218_A0_EGR_PORT_L3UC_MODSr_s {
	uint32_t v[1];
	uint32_t egr_port_l3uc_mods[1];
	uint32_t _egr_port_l3uc_mods;
} BCM56218_A0_EGR_PORT_L3UC_MODSr_t;

#define BCM56218_A0_EGR_PORT_L3UC_MODSr_CLR(r) (r).egr_port_l3uc_mods[0] = 0
#define BCM56218_A0_EGR_PORT_L3UC_MODSr_SET(r,d) (r).egr_port_l3uc_mods[0] = d
#define BCM56218_A0_EGR_PORT_L3UC_MODSr_GET(r) (r).egr_port_l3uc_mods[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_EGR_PORT_L3UC_MODSr_L3_UC_SA_DISABLEf_GET(r) (((r).egr_port_l3uc_mods[0]) & 0x1)
#define BCM56218_A0_EGR_PORT_L3UC_MODSr_L3_UC_SA_DISABLEf_SET(r,f) (r).egr_port_l3uc_mods[0]=(((r).egr_port_l3uc_mods[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_EGR_PORT_L3UC_MODSr_L3_UC_DA_DISABLEf_GET(r) ((((r).egr_port_l3uc_mods[0]) >> 1) & 0x1)
#define BCM56218_A0_EGR_PORT_L3UC_MODSr_L3_UC_DA_DISABLEf_SET(r,f) (r).egr_port_l3uc_mods[0]=(((r).egr_port_l3uc_mods[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_EGR_PORT_L3UC_MODSr_L3_UC_TTL_DISABLEf_GET(r) ((((r).egr_port_l3uc_mods[0]) >> 2) & 0x1)
#define BCM56218_A0_EGR_PORT_L3UC_MODSr_L3_UC_TTL_DISABLEf_SET(r,f) (r).egr_port_l3uc_mods[0]=(((r).egr_port_l3uc_mods[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_EGR_PORT_L3UC_MODSr_L3_UC_VLAN_DISABLEf_GET(r) ((((r).egr_port_l3uc_mods[0]) >> 3) & 0x1)
#define BCM56218_A0_EGR_PORT_L3UC_MODSr_L3_UC_VLAN_DISABLEf_SET(r,f) (r).egr_port_l3uc_mods[0]=(((r).egr_port_l3uc_mods[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))

/*
 * These macros can be used to access EGR_PORT_L3UC_MODS.
 *
 */
#define BCM56218_A0_READ_EGR_PORT_L3UC_MODSr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_EGR_PORT_L3UC_MODSr,(r._egr_port_l3uc_mods))
#define BCM56218_A0_WRITE_EGR_PORT_L3UC_MODSr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_EGR_PORT_L3UC_MODSr,&(r._egr_port_l3uc_mods))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_PORT_L3UC_MODSr BCM56218_A0_EGR_PORT_L3UC_MODSr
#define EGR_PORT_L3UC_MODSr_SIZE BCM56218_A0_EGR_PORT_L3UC_MODSr_SIZE
typedef BCM56218_A0_EGR_PORT_L3UC_MODSr_t EGR_PORT_L3UC_MODSr_t;
#define EGR_PORT_L3UC_MODSr_CLR BCM56218_A0_EGR_PORT_L3UC_MODSr_CLR
#define EGR_PORT_L3UC_MODSr_SET BCM56218_A0_EGR_PORT_L3UC_MODSr_SET
#define EGR_PORT_L3UC_MODSr_GET BCM56218_A0_EGR_PORT_L3UC_MODSr_GET
#define EGR_PORT_L3UC_MODSr_L3_UC_SA_DISABLEf_GET BCM56218_A0_EGR_PORT_L3UC_MODSr_L3_UC_SA_DISABLEf_GET
#define EGR_PORT_L3UC_MODSr_L3_UC_SA_DISABLEf_SET BCM56218_A0_EGR_PORT_L3UC_MODSr_L3_UC_SA_DISABLEf_SET
#define EGR_PORT_L3UC_MODSr_L3_UC_DA_DISABLEf_GET BCM56218_A0_EGR_PORT_L3UC_MODSr_L3_UC_DA_DISABLEf_GET
#define EGR_PORT_L3UC_MODSr_L3_UC_DA_DISABLEf_SET BCM56218_A0_EGR_PORT_L3UC_MODSr_L3_UC_DA_DISABLEf_SET
#define EGR_PORT_L3UC_MODSr_L3_UC_TTL_DISABLEf_GET BCM56218_A0_EGR_PORT_L3UC_MODSr_L3_UC_TTL_DISABLEf_GET
#define EGR_PORT_L3UC_MODSr_L3_UC_TTL_DISABLEf_SET BCM56218_A0_EGR_PORT_L3UC_MODSr_L3_UC_TTL_DISABLEf_SET
#define EGR_PORT_L3UC_MODSr_L3_UC_VLAN_DISABLEf_GET BCM56218_A0_EGR_PORT_L3UC_MODSr_L3_UC_VLAN_DISABLEf_GET
#define EGR_PORT_L3UC_MODSr_L3_UC_VLAN_DISABLEf_SET BCM56218_A0_EGR_PORT_L3UC_MODSr_L3_UC_VLAN_DISABLEf_SET
#define READ_EGR_PORT_L3UC_MODSr BCM56218_A0_READ_EGR_PORT_L3UC_MODSr
#define WRITE_EGR_PORT_L3UC_MODSr BCM56218_A0_WRITE_EGR_PORT_L3UC_MODSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_EGR_PORT_L3UC_MODSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  EGR_PORT_REQUESTS
 * BLOCKS:   EPIPE
 * DESC:     This register contains the cell requests asserted by individual ports from GPORT, XPORT, CMIC
blocks. Meaning of cell request is different for different ports, but this register has no
understanding of those meanings. All it shows is the number of times cell_request signal
was asserted by each port to TP. 

 * SIZE:     32
 * FIELDS:
 *     OUTSTANDING_PORT_REQUESTS Number of cell requests.
 *
 ******************************************************************************/
#define BCM56218_A0_EGR_PORT_REQUESTSr 0x0a900101

#define BCM56218_A0_EGR_PORT_REQUESTSr_SIZE 4

/*
 * This structure should be used to declare and program EGR_PORT_REQUESTS.
 *
 */
typedef union BCM56218_A0_EGR_PORT_REQUESTSr_s {
	uint32_t v[1];
	uint32_t egr_port_requests[1];
	uint32_t _egr_port_requests;
} BCM56218_A0_EGR_PORT_REQUESTSr_t;

#define BCM56218_A0_EGR_PORT_REQUESTSr_CLR(r) (r).egr_port_requests[0] = 0
#define BCM56218_A0_EGR_PORT_REQUESTSr_SET(r,d) (r).egr_port_requests[0] = d
#define BCM56218_A0_EGR_PORT_REQUESTSr_GET(r) (r).egr_port_requests[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_EGR_PORT_REQUESTSr_OUTSTANDING_PORT_REQUESTSf_GET(r) (((r).egr_port_requests[0]) & 0xf)
#define BCM56218_A0_EGR_PORT_REQUESTSr_OUTSTANDING_PORT_REQUESTSf_SET(r,f) (r).egr_port_requests[0]=(((r).egr_port_requests[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access EGR_PORT_REQUESTS.
 *
 */
#define BCM56218_A0_READ_EGR_PORT_REQUESTSr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_EGR_PORT_REQUESTSr,(r._egr_port_requests))
#define BCM56218_A0_WRITE_EGR_PORT_REQUESTSr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_EGR_PORT_REQUESTSr,&(r._egr_port_requests))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_PORT_REQUESTSr BCM56218_A0_EGR_PORT_REQUESTSr
#define EGR_PORT_REQUESTSr_SIZE BCM56218_A0_EGR_PORT_REQUESTSr_SIZE
typedef BCM56218_A0_EGR_PORT_REQUESTSr_t EGR_PORT_REQUESTSr_t;
#define EGR_PORT_REQUESTSr_CLR BCM56218_A0_EGR_PORT_REQUESTSr_CLR
#define EGR_PORT_REQUESTSr_SET BCM56218_A0_EGR_PORT_REQUESTSr_SET
#define EGR_PORT_REQUESTSr_GET BCM56218_A0_EGR_PORT_REQUESTSr_GET
#define EGR_PORT_REQUESTSr_OUTSTANDING_PORT_REQUESTSf_GET BCM56218_A0_EGR_PORT_REQUESTSr_OUTSTANDING_PORT_REQUESTSf_GET
#define EGR_PORT_REQUESTSr_OUTSTANDING_PORT_REQUESTSf_SET BCM56218_A0_EGR_PORT_REQUESTSr_OUTSTANDING_PORT_REQUESTSf_SET
#define READ_EGR_PORT_REQUESTSr BCM56218_A0_READ_EGR_PORT_REQUESTSr
#define WRITE_EGR_PORT_REQUESTSr BCM56218_A0_WRITE_EGR_PORT_REQUESTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_EGR_PORT_REQUESTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  EGR_Q_BEGIN
 * BLOCKS:   EPIPE
 * DESC:     Register starts an EQ Bus which is provided for later ECO reasons, if any.

 * SIZE:     32
 * FIELDS:
 *     QBUS             Debug BUS introduced for later ECO provisions.
 *
 ******************************************************************************/
#define BCM56218_A0_EGR_Q_BEGINr 0x00980002

#define BCM56218_A0_EGR_Q_BEGINr_SIZE 4

/*
 * This structure should be used to declare and program EGR_Q_BEGIN.
 *
 */
typedef union BCM56218_A0_EGR_Q_BEGINr_s {
	uint32_t v[1];
	uint32_t egr_q_begin[1];
	uint32_t _egr_q_begin;
} BCM56218_A0_EGR_Q_BEGINr_t;

#define BCM56218_A0_EGR_Q_BEGINr_CLR(r) (r).egr_q_begin[0] = 0
#define BCM56218_A0_EGR_Q_BEGINr_SET(r,d) (r).egr_q_begin[0] = d
#define BCM56218_A0_EGR_Q_BEGINr_GET(r) (r).egr_q_begin[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_EGR_Q_BEGINr_QBUSf_GET(r) ((r).egr_q_begin[0])
#define BCM56218_A0_EGR_Q_BEGINr_QBUSf_SET(r,f) (r).egr_q_begin[0]=((uint32_t)f)

/*
 * These macros can be used to access EGR_Q_BEGIN.
 *
 */
#define BCM56218_A0_READ_EGR_Q_BEGINr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_EGR_Q_BEGINr,(r._egr_q_begin))
#define BCM56218_A0_WRITE_EGR_Q_BEGINr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_EGR_Q_BEGINr,&(r._egr_q_begin))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_Q_BEGINr BCM56218_A0_EGR_Q_BEGINr
#define EGR_Q_BEGINr_SIZE BCM56218_A0_EGR_Q_BEGINr_SIZE
typedef BCM56218_A0_EGR_Q_BEGINr_t EGR_Q_BEGINr_t;
#define EGR_Q_BEGINr_CLR BCM56218_A0_EGR_Q_BEGINr_CLR
#define EGR_Q_BEGINr_SET BCM56218_A0_EGR_Q_BEGINr_SET
#define EGR_Q_BEGINr_GET BCM56218_A0_EGR_Q_BEGINr_GET
#define EGR_Q_BEGINr_QBUSf_GET BCM56218_A0_EGR_Q_BEGINr_QBUSf_GET
#define EGR_Q_BEGINr_QBUSf_SET BCM56218_A0_EGR_Q_BEGINr_QBUSf_SET
#define READ_EGR_Q_BEGINr BCM56218_A0_READ_EGR_Q_BEGINr
#define WRITE_EGR_Q_BEGINr BCM56218_A0_WRITE_EGR_Q_BEGINr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_EGR_Q_BEGINr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  EGR_Q_END
 * BLOCKS:   EPIPE
 * DESC:     Register starts an EQ Bus which is provided for later ECO reasons, if any.

 * SIZE:     32
 * FIELDS:
 *     QBUS             Debug BUS introduced for later ECO provisions.
 *
 ******************************************************************************/
#define BCM56218_A0_EGR_Q_ENDr 0x0a980103

#define BCM56218_A0_EGR_Q_ENDr_SIZE 4

/*
 * This structure should be used to declare and program EGR_Q_END.
 *
 */
typedef union BCM56218_A0_EGR_Q_ENDr_s {
	uint32_t v[1];
	uint32_t egr_q_end[1];
	uint32_t _egr_q_end;
} BCM56218_A0_EGR_Q_ENDr_t;

#define BCM56218_A0_EGR_Q_ENDr_CLR(r) (r).egr_q_end[0] = 0
#define BCM56218_A0_EGR_Q_ENDr_SET(r,d) (r).egr_q_end[0] = d
#define BCM56218_A0_EGR_Q_ENDr_GET(r) (r).egr_q_end[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_EGR_Q_ENDr_QBUSf_GET(r) ((r).egr_q_end[0])
#define BCM56218_A0_EGR_Q_ENDr_QBUSf_SET(r,f) (r).egr_q_end[0]=((uint32_t)f)

/*
 * These macros can be used to access EGR_Q_END.
 *
 */
#define BCM56218_A0_READ_EGR_Q_ENDr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_EGR_Q_ENDr,(r._egr_q_end))
#define BCM56218_A0_WRITE_EGR_Q_ENDr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_EGR_Q_ENDr,&(r._egr_q_end))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_Q_ENDr BCM56218_A0_EGR_Q_ENDr
#define EGR_Q_ENDr_SIZE BCM56218_A0_EGR_Q_ENDr_SIZE
typedef BCM56218_A0_EGR_Q_ENDr_t EGR_Q_ENDr_t;
#define EGR_Q_ENDr_CLR BCM56218_A0_EGR_Q_ENDr_CLR
#define EGR_Q_ENDr_SET BCM56218_A0_EGR_Q_ENDr_SET
#define EGR_Q_ENDr_GET BCM56218_A0_EGR_Q_ENDr_GET
#define EGR_Q_ENDr_QBUSf_GET BCM56218_A0_EGR_Q_ENDr_QBUSf_GET
#define EGR_Q_ENDr_QBUSf_SET BCM56218_A0_EGR_Q_ENDr_QBUSf_SET
#define READ_EGR_Q_ENDr BCM56218_A0_READ_EGR_Q_ENDr
#define WRITE_EGR_Q_ENDr BCM56218_A0_WRITE_EGR_Q_ENDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_EGR_Q_ENDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  EGR_RSPAN_VLAN_TAG
 * BLOCKS:   EPIPE
 * DESC:     For RSPAN feature, the vlan tag is picked up from here.


 * SIZE:     32
 * FIELDS:
 *     TAG              This field contains the entire 4 bytes (32 bits wide) tag to be added to the packet for RSPAN.The way it should be programmed is, 	TAG[31:16] = TPID,Tpid to be used when rspan tag will be added in the packet modifier. 	TAG[15:13] = Priority to be used when rspan tag will be added in the packet modifier. 	TAG[12]    = CFI to be used when rspan tag will be added in the packet modifier. 	TAG[11:0]  = VID to be used when rspan tag will be added in the packet modifier. If TAG is all zero then it means we do not add the rspan tag.
 *
 ******************************************************************************/
#define BCM56218_A0_EGR_RSPAN_VLAN_TAGr 0x09900000

#define BCM56218_A0_EGR_RSPAN_VLAN_TAGr_SIZE 4

/*
 * This structure should be used to declare and program EGR_RSPAN_VLAN_TAG.
 *
 */
typedef union BCM56218_A0_EGR_RSPAN_VLAN_TAGr_s {
	uint32_t v[1];
	uint32_t egr_rspan_vlan_tag[1];
	uint32_t _egr_rspan_vlan_tag;
} BCM56218_A0_EGR_RSPAN_VLAN_TAGr_t;

#define BCM56218_A0_EGR_RSPAN_VLAN_TAGr_CLR(r) (r).egr_rspan_vlan_tag[0] = 0
#define BCM56218_A0_EGR_RSPAN_VLAN_TAGr_SET(r,d) (r).egr_rspan_vlan_tag[0] = d
#define BCM56218_A0_EGR_RSPAN_VLAN_TAGr_GET(r) (r).egr_rspan_vlan_tag[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_EGR_RSPAN_VLAN_TAGr_TAGf_GET(r) ((r).egr_rspan_vlan_tag[0])
#define BCM56218_A0_EGR_RSPAN_VLAN_TAGr_TAGf_SET(r,f) (r).egr_rspan_vlan_tag[0]=((uint32_t)f)

/*
 * These macros can be used to access EGR_RSPAN_VLAN_TAG.
 *
 */
#define BCM56218_A0_READ_EGR_RSPAN_VLAN_TAGr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_EGR_RSPAN_VLAN_TAGr,(r._egr_rspan_vlan_tag))
#define BCM56218_A0_WRITE_EGR_RSPAN_VLAN_TAGr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_EGR_RSPAN_VLAN_TAGr,&(r._egr_rspan_vlan_tag))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_RSPAN_VLAN_TAGr BCM56218_A0_EGR_RSPAN_VLAN_TAGr
#define EGR_RSPAN_VLAN_TAGr_SIZE BCM56218_A0_EGR_RSPAN_VLAN_TAGr_SIZE
typedef BCM56218_A0_EGR_RSPAN_VLAN_TAGr_t EGR_RSPAN_VLAN_TAGr_t;
#define EGR_RSPAN_VLAN_TAGr_CLR BCM56218_A0_EGR_RSPAN_VLAN_TAGr_CLR
#define EGR_RSPAN_VLAN_TAGr_SET BCM56218_A0_EGR_RSPAN_VLAN_TAGr_SET
#define EGR_RSPAN_VLAN_TAGr_GET BCM56218_A0_EGR_RSPAN_VLAN_TAGr_GET
#define EGR_RSPAN_VLAN_TAGr_TAGf_GET BCM56218_A0_EGR_RSPAN_VLAN_TAGr_TAGf_GET
#define EGR_RSPAN_VLAN_TAGr_TAGf_SET BCM56218_A0_EGR_RSPAN_VLAN_TAGr_TAGf_SET
#define READ_EGR_RSPAN_VLAN_TAGr BCM56218_A0_READ_EGR_RSPAN_VLAN_TAGr
#define WRITE_EGR_RSPAN_VLAN_TAGr BCM56218_A0_WRITE_EGR_RSPAN_VLAN_TAGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_EGR_RSPAN_VLAN_TAGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  EGR_SHAPING_CONTROL
 * BLOCKS:   EPIPE
 * DESC:     Specifies control fields Egress for the Shaping Counters.

 * SIZE:     32
 * FIELDS:
 *     PACKET_IFG_BYTES Number of Preamble and IFG bytes to be added in the Shaping counters.
 *
 ******************************************************************************/
#define BCM56218_A0_EGR_SHAPING_CONTROLr 0x0a980104

#define BCM56218_A0_EGR_SHAPING_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program EGR_SHAPING_CONTROL.
 *
 */
typedef union BCM56218_A0_EGR_SHAPING_CONTROLr_s {
	uint32_t v[1];
	uint32_t egr_shaping_control[1];
	uint32_t _egr_shaping_control;
} BCM56218_A0_EGR_SHAPING_CONTROLr_t;

#define BCM56218_A0_EGR_SHAPING_CONTROLr_CLR(r) (r).egr_shaping_control[0] = 0
#define BCM56218_A0_EGR_SHAPING_CONTROLr_SET(r,d) (r).egr_shaping_control[0] = d
#define BCM56218_A0_EGR_SHAPING_CONTROLr_GET(r) (r).egr_shaping_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_EGR_SHAPING_CONTROLr_PACKET_IFG_BYTESf_GET(r) (((r).egr_shaping_control[0]) & 0x1f)
#define BCM56218_A0_EGR_SHAPING_CONTROLr_PACKET_IFG_BYTESf_SET(r,f) (r).egr_shaping_control[0]=(((r).egr_shaping_control[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))

/*
 * These macros can be used to access EGR_SHAPING_CONTROL.
 *
 */
#define BCM56218_A0_READ_EGR_SHAPING_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_EGR_SHAPING_CONTROLr,(r._egr_shaping_control))
#define BCM56218_A0_WRITE_EGR_SHAPING_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_EGR_SHAPING_CONTROLr,&(r._egr_shaping_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_SHAPING_CONTROLr BCM56218_A0_EGR_SHAPING_CONTROLr
#define EGR_SHAPING_CONTROLr_SIZE BCM56218_A0_EGR_SHAPING_CONTROLr_SIZE
typedef BCM56218_A0_EGR_SHAPING_CONTROLr_t EGR_SHAPING_CONTROLr_t;
#define EGR_SHAPING_CONTROLr_CLR BCM56218_A0_EGR_SHAPING_CONTROLr_CLR
#define EGR_SHAPING_CONTROLr_SET BCM56218_A0_EGR_SHAPING_CONTROLr_SET
#define EGR_SHAPING_CONTROLr_GET BCM56218_A0_EGR_SHAPING_CONTROLr_GET
#define EGR_SHAPING_CONTROLr_PACKET_IFG_BYTESf_GET BCM56218_A0_EGR_SHAPING_CONTROLr_PACKET_IFG_BYTESf_GET
#define EGR_SHAPING_CONTROLr_PACKET_IFG_BYTESf_SET BCM56218_A0_EGR_SHAPING_CONTROLr_PACKET_IFG_BYTESf_SET
#define READ_EGR_SHAPING_CONTROLr BCM56218_A0_READ_EGR_SHAPING_CONTROLr
#define WRITE_EGR_SHAPING_CONTROLr BCM56218_A0_WRITE_EGR_SHAPING_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_EGR_SHAPING_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  EGR_TUNNEL_CONTROL
 * BLOCKS:   EPIPE
 * DESC:     Global ID value for Tunnel Pkts. This value is passed in the pkt whenever tunnel
is encapsulated in a packet in Transmit Pipeline.


 * SIZE:     32
 * FIELDS:
 *     IPV4_ID          Global id to be inserted in the packet. This is the running ID, i.e. whenever a pkt is transmitted, the value is incremented here.
 *     START_IPV4_ID    Global ID written by CPU. This is written by logic when CPU writes to the IPV4_ID field. After that START_IPV4_ID field remains constant, which is useful for debugging to see what was the starting id for this chip, as IPV4_ID keeps on changing with each encapped packet.
 *
 ******************************************************************************/
#define BCM56218_A0_EGR_TUNNEL_CONTROLr 0x07980000

#define BCM56218_A0_EGR_TUNNEL_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program EGR_TUNNEL_CONTROL.
 *
 */
typedef union BCM56218_A0_EGR_TUNNEL_CONTROLr_s {
	uint32_t v[1];
	uint32_t egr_tunnel_control[1];
	uint32_t _egr_tunnel_control;
} BCM56218_A0_EGR_TUNNEL_CONTROLr_t;

#define BCM56218_A0_EGR_TUNNEL_CONTROLr_CLR(r) (r).egr_tunnel_control[0] = 0
#define BCM56218_A0_EGR_TUNNEL_CONTROLr_SET(r,d) (r).egr_tunnel_control[0] = d
#define BCM56218_A0_EGR_TUNNEL_CONTROLr_GET(r) (r).egr_tunnel_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_EGR_TUNNEL_CONTROLr_IPV4_IDf_GET(r) (((r).egr_tunnel_control[0]) & 0xffff)
#define BCM56218_A0_EGR_TUNNEL_CONTROLr_IPV4_IDf_SET(r,f) (r).egr_tunnel_control[0]=(((r).egr_tunnel_control[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56218_A0_EGR_TUNNEL_CONTROLr_START_IPV4_IDf_GET(r) ((((r).egr_tunnel_control[0]) >> 16) & 0xffff)
#define BCM56218_A0_EGR_TUNNEL_CONTROLr_START_IPV4_IDf_SET(r,f) (r).egr_tunnel_control[0]=(((r).egr_tunnel_control[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access EGR_TUNNEL_CONTROL.
 *
 */
#define BCM56218_A0_READ_EGR_TUNNEL_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_EGR_TUNNEL_CONTROLr,(r._egr_tunnel_control))
#define BCM56218_A0_WRITE_EGR_TUNNEL_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_EGR_TUNNEL_CONTROLr,&(r._egr_tunnel_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_TUNNEL_CONTROLr BCM56218_A0_EGR_TUNNEL_CONTROLr
#define EGR_TUNNEL_CONTROLr_SIZE BCM56218_A0_EGR_TUNNEL_CONTROLr_SIZE
typedef BCM56218_A0_EGR_TUNNEL_CONTROLr_t EGR_TUNNEL_CONTROLr_t;
#define EGR_TUNNEL_CONTROLr_CLR BCM56218_A0_EGR_TUNNEL_CONTROLr_CLR
#define EGR_TUNNEL_CONTROLr_SET BCM56218_A0_EGR_TUNNEL_CONTROLr_SET
#define EGR_TUNNEL_CONTROLr_GET BCM56218_A0_EGR_TUNNEL_CONTROLr_GET
#define EGR_TUNNEL_CONTROLr_IPV4_IDf_GET BCM56218_A0_EGR_TUNNEL_CONTROLr_IPV4_IDf_GET
#define EGR_TUNNEL_CONTROLr_IPV4_IDf_SET BCM56218_A0_EGR_TUNNEL_CONTROLr_IPV4_IDf_SET
#define EGR_TUNNEL_CONTROLr_START_IPV4_IDf_GET BCM56218_A0_EGR_TUNNEL_CONTROLr_START_IPV4_IDf_GET
#define EGR_TUNNEL_CONTROLr_START_IPV4_IDf_SET BCM56218_A0_EGR_TUNNEL_CONTROLr_START_IPV4_IDf_SET
#define READ_EGR_TUNNEL_CONTROLr BCM56218_A0_READ_EGR_TUNNEL_CONTROLr
#define WRITE_EGR_TUNNEL_CONTROLr BCM56218_A0_WRITE_EGR_TUNNEL_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_EGR_TUNNEL_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  EGR_TUNNEL_ID_MASK
 * BLOCKS:   EPIPE
 * DESC:     Global ID mask value for Tunnel Pkts. 


 * SIZE:     32
 * FIELDS:
 *     IPV4_ID_MASK     Global id mask to be used before inserting the tag in the packet.
 *
 ******************************************************************************/
#define BCM56218_A0_EGR_TUNNEL_ID_MASKr 0x07980001

#define BCM56218_A0_EGR_TUNNEL_ID_MASKr_SIZE 4

/*
 * This structure should be used to declare and program EGR_TUNNEL_ID_MASK.
 *
 */
typedef union BCM56218_A0_EGR_TUNNEL_ID_MASKr_s {
	uint32_t v[1];
	uint32_t egr_tunnel_id_mask[1];
	uint32_t _egr_tunnel_id_mask;
} BCM56218_A0_EGR_TUNNEL_ID_MASKr_t;

#define BCM56218_A0_EGR_TUNNEL_ID_MASKr_CLR(r) (r).egr_tunnel_id_mask[0] = 0
#define BCM56218_A0_EGR_TUNNEL_ID_MASKr_SET(r,d) (r).egr_tunnel_id_mask[0] = d
#define BCM56218_A0_EGR_TUNNEL_ID_MASKr_GET(r) (r).egr_tunnel_id_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_EGR_TUNNEL_ID_MASKr_IPV4_ID_MASKf_GET(r) (((r).egr_tunnel_id_mask[0]) & 0xffff)
#define BCM56218_A0_EGR_TUNNEL_ID_MASKr_IPV4_ID_MASKf_SET(r,f) (r).egr_tunnel_id_mask[0]=(((r).egr_tunnel_id_mask[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access EGR_TUNNEL_ID_MASK.
 *
 */
#define BCM56218_A0_READ_EGR_TUNNEL_ID_MASKr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_EGR_TUNNEL_ID_MASKr,(r._egr_tunnel_id_mask))
#define BCM56218_A0_WRITE_EGR_TUNNEL_ID_MASKr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_EGR_TUNNEL_ID_MASKr,&(r._egr_tunnel_id_mask))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_TUNNEL_ID_MASKr BCM56218_A0_EGR_TUNNEL_ID_MASKr
#define EGR_TUNNEL_ID_MASKr_SIZE BCM56218_A0_EGR_TUNNEL_ID_MASKr_SIZE
typedef BCM56218_A0_EGR_TUNNEL_ID_MASKr_t EGR_TUNNEL_ID_MASKr_t;
#define EGR_TUNNEL_ID_MASKr_CLR BCM56218_A0_EGR_TUNNEL_ID_MASKr_CLR
#define EGR_TUNNEL_ID_MASKr_SET BCM56218_A0_EGR_TUNNEL_ID_MASKr_SET
#define EGR_TUNNEL_ID_MASKr_GET BCM56218_A0_EGR_TUNNEL_ID_MASKr_GET
#define EGR_TUNNEL_ID_MASKr_IPV4_ID_MASKf_GET BCM56218_A0_EGR_TUNNEL_ID_MASKr_IPV4_ID_MASKf_GET
#define EGR_TUNNEL_ID_MASKr_IPV4_ID_MASKf_SET BCM56218_A0_EGR_TUNNEL_ID_MASKr_IPV4_ID_MASKf_SET
#define READ_EGR_TUNNEL_ID_MASKr BCM56218_A0_READ_EGR_TUNNEL_ID_MASKr
#define WRITE_EGR_TUNNEL_ID_MASKr BCM56218_A0_WRITE_EGR_TUNNEL_ID_MASKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_EGR_TUNNEL_ID_MASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  EGR_TUNNEL_PIMDR1_CFG0
 * BLOCKS:   EPIPE
 * DESC:     RESERVED for raptor. For PIMSM-DR1 type of tunnel pkts, MS 4 bytes are specified here, so that they
can be inserted in the packet.

 * SIZE:     32
 * FIELDS:
 *     MS_PIMSM_HDR     Specifies the MS 32 bits of the PIMSM-DR1 Header, which needs to be inserted in the packet, if tunnel table search results in pkt encap.
 *
 ******************************************************************************/
#define BCM56218_A0_EGR_TUNNEL_PIMDR1_CFG0r 0x08980000

#define BCM56218_A0_EGR_TUNNEL_PIMDR1_CFG0r_SIZE 4

/*
 * This structure should be used to declare and program EGR_TUNNEL_PIMDR1_CFG0.
 *
 */
typedef union BCM56218_A0_EGR_TUNNEL_PIMDR1_CFG0r_s {
	uint32_t v[1];
	uint32_t egr_tunnel_pimdr1_cfg0[1];
	uint32_t _egr_tunnel_pimdr1_cfg0;
} BCM56218_A0_EGR_TUNNEL_PIMDR1_CFG0r_t;

#define BCM56218_A0_EGR_TUNNEL_PIMDR1_CFG0r_CLR(r) (r).egr_tunnel_pimdr1_cfg0[0] = 0
#define BCM56218_A0_EGR_TUNNEL_PIMDR1_CFG0r_SET(r,d) (r).egr_tunnel_pimdr1_cfg0[0] = d
#define BCM56218_A0_EGR_TUNNEL_PIMDR1_CFG0r_GET(r) (r).egr_tunnel_pimdr1_cfg0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_EGR_TUNNEL_PIMDR1_CFG0r_MS_PIMSM_HDRf_GET(r) ((r).egr_tunnel_pimdr1_cfg0[0])
#define BCM56218_A0_EGR_TUNNEL_PIMDR1_CFG0r_MS_PIMSM_HDRf_SET(r,f) (r).egr_tunnel_pimdr1_cfg0[0]=((uint32_t)f)

/*
 * These macros can be used to access EGR_TUNNEL_PIMDR1_CFG0.
 *
 */
#define BCM56218_A0_READ_EGR_TUNNEL_PIMDR1_CFG0r(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_EGR_TUNNEL_PIMDR1_CFG0r,(r._egr_tunnel_pimdr1_cfg0))
#define BCM56218_A0_WRITE_EGR_TUNNEL_PIMDR1_CFG0r(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_EGR_TUNNEL_PIMDR1_CFG0r,&(r._egr_tunnel_pimdr1_cfg0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_TUNNEL_PIMDR1_CFG0r BCM56218_A0_EGR_TUNNEL_PIMDR1_CFG0r
#define EGR_TUNNEL_PIMDR1_CFG0r_SIZE BCM56218_A0_EGR_TUNNEL_PIMDR1_CFG0r_SIZE
typedef BCM56218_A0_EGR_TUNNEL_PIMDR1_CFG0r_t EGR_TUNNEL_PIMDR1_CFG0r_t;
#define EGR_TUNNEL_PIMDR1_CFG0r_CLR BCM56218_A0_EGR_TUNNEL_PIMDR1_CFG0r_CLR
#define EGR_TUNNEL_PIMDR1_CFG0r_SET BCM56218_A0_EGR_TUNNEL_PIMDR1_CFG0r_SET
#define EGR_TUNNEL_PIMDR1_CFG0r_GET BCM56218_A0_EGR_TUNNEL_PIMDR1_CFG0r_GET
#define EGR_TUNNEL_PIMDR1_CFG0r_MS_PIMSM_HDRf_GET BCM56218_A0_EGR_TUNNEL_PIMDR1_CFG0r_MS_PIMSM_HDRf_GET
#define EGR_TUNNEL_PIMDR1_CFG0r_MS_PIMSM_HDRf_SET BCM56218_A0_EGR_TUNNEL_PIMDR1_CFG0r_MS_PIMSM_HDRf_SET
#define READ_EGR_TUNNEL_PIMDR1_CFG0r BCM56218_A0_READ_EGR_TUNNEL_PIMDR1_CFG0r
#define WRITE_EGR_TUNNEL_PIMDR1_CFG0r BCM56218_A0_WRITE_EGR_TUNNEL_PIMDR1_CFG0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_EGR_TUNNEL_PIMDR1_CFG0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  EGR_TUNNEL_PIMDR1_CFG1
 * BLOCKS:   EPIPE
 * DESC:     RESERVED for raptor. For PIMSM-DR1 type of tunnel pkts, LS 4 bytes are specified here, so that they
can be inserted in the packet.

 * SIZE:     32
 * FIELDS:
 *     LS_PIMSM_HDR     Specifies the LS 32 bits of the PIMSM-DR1 Header, which needs to be inserted in the packet, if tunnel table search results in pkt encap.
 *
 ******************************************************************************/
#define BCM56218_A0_EGR_TUNNEL_PIMDR1_CFG1r 0x08980001

#define BCM56218_A0_EGR_TUNNEL_PIMDR1_CFG1r_SIZE 4

/*
 * This structure should be used to declare and program EGR_TUNNEL_PIMDR1_CFG1.
 *
 */
typedef union BCM56218_A0_EGR_TUNNEL_PIMDR1_CFG1r_s {
	uint32_t v[1];
	uint32_t egr_tunnel_pimdr1_cfg1[1];
	uint32_t _egr_tunnel_pimdr1_cfg1;
} BCM56218_A0_EGR_TUNNEL_PIMDR1_CFG1r_t;

#define BCM56218_A0_EGR_TUNNEL_PIMDR1_CFG1r_CLR(r) (r).egr_tunnel_pimdr1_cfg1[0] = 0
#define BCM56218_A0_EGR_TUNNEL_PIMDR1_CFG1r_SET(r,d) (r).egr_tunnel_pimdr1_cfg1[0] = d
#define BCM56218_A0_EGR_TUNNEL_PIMDR1_CFG1r_GET(r) (r).egr_tunnel_pimdr1_cfg1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_EGR_TUNNEL_PIMDR1_CFG1r_LS_PIMSM_HDRf_GET(r) ((r).egr_tunnel_pimdr1_cfg1[0])
#define BCM56218_A0_EGR_TUNNEL_PIMDR1_CFG1r_LS_PIMSM_HDRf_SET(r,f) (r).egr_tunnel_pimdr1_cfg1[0]=((uint32_t)f)

/*
 * These macros can be used to access EGR_TUNNEL_PIMDR1_CFG1.
 *
 */
#define BCM56218_A0_READ_EGR_TUNNEL_PIMDR1_CFG1r(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_EGR_TUNNEL_PIMDR1_CFG1r,(r._egr_tunnel_pimdr1_cfg1))
#define BCM56218_A0_WRITE_EGR_TUNNEL_PIMDR1_CFG1r(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_EGR_TUNNEL_PIMDR1_CFG1r,&(r._egr_tunnel_pimdr1_cfg1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_TUNNEL_PIMDR1_CFG1r BCM56218_A0_EGR_TUNNEL_PIMDR1_CFG1r
#define EGR_TUNNEL_PIMDR1_CFG1r_SIZE BCM56218_A0_EGR_TUNNEL_PIMDR1_CFG1r_SIZE
typedef BCM56218_A0_EGR_TUNNEL_PIMDR1_CFG1r_t EGR_TUNNEL_PIMDR1_CFG1r_t;
#define EGR_TUNNEL_PIMDR1_CFG1r_CLR BCM56218_A0_EGR_TUNNEL_PIMDR1_CFG1r_CLR
#define EGR_TUNNEL_PIMDR1_CFG1r_SET BCM56218_A0_EGR_TUNNEL_PIMDR1_CFG1r_SET
#define EGR_TUNNEL_PIMDR1_CFG1r_GET BCM56218_A0_EGR_TUNNEL_PIMDR1_CFG1r_GET
#define EGR_TUNNEL_PIMDR1_CFG1r_LS_PIMSM_HDRf_GET BCM56218_A0_EGR_TUNNEL_PIMDR1_CFG1r_LS_PIMSM_HDRf_GET
#define EGR_TUNNEL_PIMDR1_CFG1r_LS_PIMSM_HDRf_SET BCM56218_A0_EGR_TUNNEL_PIMDR1_CFG1r_LS_PIMSM_HDRf_SET
#define READ_EGR_TUNNEL_PIMDR1_CFG1r BCM56218_A0_READ_EGR_TUNNEL_PIMDR1_CFG1r
#define WRITE_EGR_TUNNEL_PIMDR1_CFG1r BCM56218_A0_WRITE_EGR_TUNNEL_PIMDR1_CFG1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_EGR_TUNNEL_PIMDR1_CFG1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  EGR_TUNNEL_PIMDR2_CFG0
 * BLOCKS:   EPIPE
 * DESC:     RESERVED for Raptor. For PIMSM-DR2 type of tunnel pkts, MS 4 bytes are specified here, so that they
can be inserted in the packet.

 * SIZE:     32
 * FIELDS:
 *     MS_PIMSM_HDR     Specifies the MS 32 bits PIMSM-DR2 Header, which needs to be inserted in the packet, if tunnel table search results in pkt encap.
 *
 ******************************************************************************/
#define BCM56218_A0_EGR_TUNNEL_PIMDR2_CFG0r 0x08980002

#define BCM56218_A0_EGR_TUNNEL_PIMDR2_CFG0r_SIZE 4

/*
 * This structure should be used to declare and program EGR_TUNNEL_PIMDR2_CFG0.
 *
 */
typedef union BCM56218_A0_EGR_TUNNEL_PIMDR2_CFG0r_s {
	uint32_t v[1];
	uint32_t egr_tunnel_pimdr2_cfg0[1];
	uint32_t _egr_tunnel_pimdr2_cfg0;
} BCM56218_A0_EGR_TUNNEL_PIMDR2_CFG0r_t;

#define BCM56218_A0_EGR_TUNNEL_PIMDR2_CFG0r_CLR(r) (r).egr_tunnel_pimdr2_cfg0[0] = 0
#define BCM56218_A0_EGR_TUNNEL_PIMDR2_CFG0r_SET(r,d) (r).egr_tunnel_pimdr2_cfg0[0] = d
#define BCM56218_A0_EGR_TUNNEL_PIMDR2_CFG0r_GET(r) (r).egr_tunnel_pimdr2_cfg0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_EGR_TUNNEL_PIMDR2_CFG0r_MS_PIMSM_HDRf_GET(r) ((r).egr_tunnel_pimdr2_cfg0[0])
#define BCM56218_A0_EGR_TUNNEL_PIMDR2_CFG0r_MS_PIMSM_HDRf_SET(r,f) (r).egr_tunnel_pimdr2_cfg0[0]=((uint32_t)f)

/*
 * These macros can be used to access EGR_TUNNEL_PIMDR2_CFG0.
 *
 */
#define BCM56218_A0_READ_EGR_TUNNEL_PIMDR2_CFG0r(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_EGR_TUNNEL_PIMDR2_CFG0r,(r._egr_tunnel_pimdr2_cfg0))
#define BCM56218_A0_WRITE_EGR_TUNNEL_PIMDR2_CFG0r(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_EGR_TUNNEL_PIMDR2_CFG0r,&(r._egr_tunnel_pimdr2_cfg0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_TUNNEL_PIMDR2_CFG0r BCM56218_A0_EGR_TUNNEL_PIMDR2_CFG0r
#define EGR_TUNNEL_PIMDR2_CFG0r_SIZE BCM56218_A0_EGR_TUNNEL_PIMDR2_CFG0r_SIZE
typedef BCM56218_A0_EGR_TUNNEL_PIMDR2_CFG0r_t EGR_TUNNEL_PIMDR2_CFG0r_t;
#define EGR_TUNNEL_PIMDR2_CFG0r_CLR BCM56218_A0_EGR_TUNNEL_PIMDR2_CFG0r_CLR
#define EGR_TUNNEL_PIMDR2_CFG0r_SET BCM56218_A0_EGR_TUNNEL_PIMDR2_CFG0r_SET
#define EGR_TUNNEL_PIMDR2_CFG0r_GET BCM56218_A0_EGR_TUNNEL_PIMDR2_CFG0r_GET
#define EGR_TUNNEL_PIMDR2_CFG0r_MS_PIMSM_HDRf_GET BCM56218_A0_EGR_TUNNEL_PIMDR2_CFG0r_MS_PIMSM_HDRf_GET
#define EGR_TUNNEL_PIMDR2_CFG0r_MS_PIMSM_HDRf_SET BCM56218_A0_EGR_TUNNEL_PIMDR2_CFG0r_MS_PIMSM_HDRf_SET
#define READ_EGR_TUNNEL_PIMDR2_CFG0r BCM56218_A0_READ_EGR_TUNNEL_PIMDR2_CFG0r
#define WRITE_EGR_TUNNEL_PIMDR2_CFG0r BCM56218_A0_WRITE_EGR_TUNNEL_PIMDR2_CFG0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_EGR_TUNNEL_PIMDR2_CFG0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  EGR_TUNNEL_PIMDR2_CFG1
 * BLOCKS:   EPIPE
 * DESC:     RESERVED for Raptor. For PIMSM-DR2 type of tunnel pkts, LS 4 bytes are specified here, so that they
can be inserted in the packet.

 * SIZE:     32
 * FIELDS:
 *     LS_PIMSM_HDR     Specifies the LS 32 bits PIMSM-DR2 Header, which needs to be inserted in the packet, if tunnel table search results in pkt encap.
 *
 ******************************************************************************/
#define BCM56218_A0_EGR_TUNNEL_PIMDR2_CFG1r 0x08980003

#define BCM56218_A0_EGR_TUNNEL_PIMDR2_CFG1r_SIZE 4

/*
 * This structure should be used to declare and program EGR_TUNNEL_PIMDR2_CFG1.
 *
 */
typedef union BCM56218_A0_EGR_TUNNEL_PIMDR2_CFG1r_s {
	uint32_t v[1];
	uint32_t egr_tunnel_pimdr2_cfg1[1];
	uint32_t _egr_tunnel_pimdr2_cfg1;
} BCM56218_A0_EGR_TUNNEL_PIMDR2_CFG1r_t;

#define BCM56218_A0_EGR_TUNNEL_PIMDR2_CFG1r_CLR(r) (r).egr_tunnel_pimdr2_cfg1[0] = 0
#define BCM56218_A0_EGR_TUNNEL_PIMDR2_CFG1r_SET(r,d) (r).egr_tunnel_pimdr2_cfg1[0] = d
#define BCM56218_A0_EGR_TUNNEL_PIMDR2_CFG1r_GET(r) (r).egr_tunnel_pimdr2_cfg1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_EGR_TUNNEL_PIMDR2_CFG1r_LS_PIMSM_HDRf_GET(r) ((r).egr_tunnel_pimdr2_cfg1[0])
#define BCM56218_A0_EGR_TUNNEL_PIMDR2_CFG1r_LS_PIMSM_HDRf_SET(r,f) (r).egr_tunnel_pimdr2_cfg1[0]=((uint32_t)f)

/*
 * These macros can be used to access EGR_TUNNEL_PIMDR2_CFG1.
 *
 */
#define BCM56218_A0_READ_EGR_TUNNEL_PIMDR2_CFG1r(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_EGR_TUNNEL_PIMDR2_CFG1r,(r._egr_tunnel_pimdr2_cfg1))
#define BCM56218_A0_WRITE_EGR_TUNNEL_PIMDR2_CFG1r(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_EGR_TUNNEL_PIMDR2_CFG1r,&(r._egr_tunnel_pimdr2_cfg1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_TUNNEL_PIMDR2_CFG1r BCM56218_A0_EGR_TUNNEL_PIMDR2_CFG1r
#define EGR_TUNNEL_PIMDR2_CFG1r_SIZE BCM56218_A0_EGR_TUNNEL_PIMDR2_CFG1r_SIZE
typedef BCM56218_A0_EGR_TUNNEL_PIMDR2_CFG1r_t EGR_TUNNEL_PIMDR2_CFG1r_t;
#define EGR_TUNNEL_PIMDR2_CFG1r_CLR BCM56218_A0_EGR_TUNNEL_PIMDR2_CFG1r_CLR
#define EGR_TUNNEL_PIMDR2_CFG1r_SET BCM56218_A0_EGR_TUNNEL_PIMDR2_CFG1r_SET
#define EGR_TUNNEL_PIMDR2_CFG1r_GET BCM56218_A0_EGR_TUNNEL_PIMDR2_CFG1r_GET
#define EGR_TUNNEL_PIMDR2_CFG1r_LS_PIMSM_HDRf_GET BCM56218_A0_EGR_TUNNEL_PIMDR2_CFG1r_LS_PIMSM_HDRf_GET
#define EGR_TUNNEL_PIMDR2_CFG1r_LS_PIMSM_HDRf_SET BCM56218_A0_EGR_TUNNEL_PIMDR2_CFG1r_LS_PIMSM_HDRf_SET
#define READ_EGR_TUNNEL_PIMDR2_CFG1r BCM56218_A0_READ_EGR_TUNNEL_PIMDR2_CFG1r
#define WRITE_EGR_TUNNEL_PIMDR2_CFG1r BCM56218_A0_WRITE_EGR_TUNNEL_PIMDR2_CFG1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_EGR_TUNNEL_PIMDR2_CFG1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  EGR_VLAN
 * BLOCKS:   EPIPE
 * DESC:     Vlan Membership Table for Egress
 * SIZE:     62
 * FIELDS:
 *     UT_BITMAP        Untag Port Bitmap. Indicates on which port the packet needs to be sent untagged. A bit for CPU is not needed.
 *     UT_PORT_BITMAP   Untag Port Bitmap. Indicates on which port the packet needs to be sent untagged. A bit for CPU is not needed.
 *     UT_BITMAP_LO     Untag Port Bitmap. Indicates on which port the packet needs to be sent untagged. A bit for CPU is not needed.
 *     UT_PORT_BITMAP_LO Untag Port Bitmap. Indicates on which port the packet needs to be sent untagged. A bit for CPU is not needed.
 *     UT_BITMAP_HI     Untag Port Bitmap. Indicates on which port the packet needs to be sent untagged. A bit for CPU is not needed.
 *     UT_PORT_BITMAP_HI Untag Port Bitmap. Indicates on which port the packet needs to be sent untagged. A bit for CPU is not needed.
 *     STG              Spanning Tree Group Number. To be used for indexing VLAN_STG table.
 *     VALID            Indicates if the entry is valid.
 *
 ******************************************************************************/
#define BCM56218_A0_EGR_VLANm 0x04910000

#define BCM56218_A0_EGR_VLANm_MIN 0
#define BCM56218_A0_EGR_VLANm_MAX 4095
#define BCM56218_A0_EGR_VLANm_CMAX(u) 4095
#define BCM56218_A0_EGR_VLANm_SIZE 8

/*
 * This structure should be used to declare and program EGR_VLAN.
 *
 */
typedef union BCM56218_A0_EGR_VLANm_s {
	uint32_t v[2];
	uint32_t egr_vlan[2];
	uint32_t _egr_vlan;
} BCM56218_A0_EGR_VLANm_t;

#define BCM56218_A0_EGR_VLANm_CLR(r) CDK_MEMSET(&((r)._egr_vlan), 0, sizeof(BCM56218_A0_EGR_VLANm_t))
#define BCM56218_A0_EGR_VLANm_SET(r,i,d) (r).egr_vlan[i] = d
#define BCM56218_A0_EGR_VLANm_GET(r,i) (r).egr_vlan[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_EGR_VLANm_UT_BITMAPf_GET(r,a) cdk_field_get((r).egr_vlan,0,53,a)
#define BCM56218_A0_EGR_VLANm_UT_BITMAPf_SET(r,a) cdk_field_set((r).egr_vlan,0,53,a)
#define BCM56218_A0_EGR_VLANm_UT_PORT_BITMAPf_GET(r,a) cdk_field_get((r).egr_vlan,0,53,a)
#define BCM56218_A0_EGR_VLANm_UT_PORT_BITMAPf_SET(r,a) cdk_field_set((r).egr_vlan,0,53,a)
#define BCM56218_A0_EGR_VLANm_UT_BITMAP_LOf_GET(r) ((r).egr_vlan[0])
#define BCM56218_A0_EGR_VLANm_UT_BITMAP_LOf_SET(r,f) (r).egr_vlan[0]=((uint32_t)f)
#define BCM56218_A0_EGR_VLANm_UT_PORT_BITMAP_LOf_GET(r) ((r).egr_vlan[0])
#define BCM56218_A0_EGR_VLANm_UT_PORT_BITMAP_LOf_SET(r,f) (r).egr_vlan[0]=((uint32_t)f)
#define BCM56218_A0_EGR_VLANm_UT_BITMAP_HIf_GET(r) (((r).egr_vlan[1]) & 0x3fffff)
#define BCM56218_A0_EGR_VLANm_UT_BITMAP_HIf_SET(r,f) (r).egr_vlan[1]=(((r).egr_vlan[1] & ~((uint32_t)0x3fffff)) | (((uint32_t)f) & 0x3fffff))
#define BCM56218_A0_EGR_VLANm_UT_PORT_BITMAP_HIf_GET(r) (((r).egr_vlan[1]) & 0x3fffff)
#define BCM56218_A0_EGR_VLANm_UT_PORT_BITMAP_HIf_SET(r,f) (r).egr_vlan[1]=(((r).egr_vlan[1] & ~((uint32_t)0x3fffff)) | (((uint32_t)f) & 0x3fffff))
#define BCM56218_A0_EGR_VLANm_STGf_GET(r) ((((r).egr_vlan[1]) >> 22) & 0x7f)
#define BCM56218_A0_EGR_VLANm_STGf_SET(r,f) (r).egr_vlan[1]=(((r).egr_vlan[1] & ~((uint32_t)0x7f << 22)) | ((((uint32_t)f) & 0x7f) << 22))
#define BCM56218_A0_EGR_VLANm_VALIDf_GET(r) ((((r).egr_vlan[1]) >> 29) & 0x1)
#define BCM56218_A0_EGR_VLANm_VALIDf_SET(r,f) (r).egr_vlan[1]=(((r).egr_vlan[1] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))

/*
 * These macros can be used to access EGR_VLAN.
 *
 */
#define BCM56218_A0_READ_EGR_VLANm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_EGR_VLANm,i,(m._egr_vlan),2)
#define BCM56218_A0_WRITE_EGR_VLANm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_EGR_VLANm,i,&(m._egr_vlan),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_VLANm BCM56218_A0_EGR_VLANm
#define EGR_VLANm_MIN BCM56218_A0_EGR_VLANm_MIN
#define EGR_VLANm_MAX BCM56218_A0_EGR_VLANm_MAX
#define EGR_VLANm_CMAX(u) BCM56218_A0_EGR_VLANm_CMAX(u)
#define EGR_VLANm_SIZE BCM56218_A0_EGR_VLANm_SIZE
typedef BCM56218_A0_EGR_VLANm_t EGR_VLANm_t;
#define EGR_VLANm_CLR BCM56218_A0_EGR_VLANm_CLR
#define EGR_VLANm_SET BCM56218_A0_EGR_VLANm_SET
#define EGR_VLANm_GET BCM56218_A0_EGR_VLANm_GET
#define EGR_VLANm_UT_BITMAPf_GET BCM56218_A0_EGR_VLANm_UT_BITMAPf_GET
#define EGR_VLANm_UT_BITMAPf_SET BCM56218_A0_EGR_VLANm_UT_BITMAPf_SET
#define EGR_VLANm_UT_PORT_BITMAPf_GET BCM56218_A0_EGR_VLANm_UT_PORT_BITMAPf_GET
#define EGR_VLANm_UT_PORT_BITMAPf_SET BCM56218_A0_EGR_VLANm_UT_PORT_BITMAPf_SET
#define EGR_VLANm_UT_BITMAP_LOf_GET BCM56218_A0_EGR_VLANm_UT_BITMAP_LOf_GET
#define EGR_VLANm_UT_BITMAP_LOf_SET BCM56218_A0_EGR_VLANm_UT_BITMAP_LOf_SET
#define EGR_VLANm_UT_PORT_BITMAP_LOf_GET BCM56218_A0_EGR_VLANm_UT_PORT_BITMAP_LOf_GET
#define EGR_VLANm_UT_PORT_BITMAP_LOf_SET BCM56218_A0_EGR_VLANm_UT_PORT_BITMAP_LOf_SET
#define EGR_VLANm_UT_BITMAP_HIf_GET BCM56218_A0_EGR_VLANm_UT_BITMAP_HIf_GET
#define EGR_VLANm_UT_BITMAP_HIf_SET BCM56218_A0_EGR_VLANm_UT_BITMAP_HIf_SET
#define EGR_VLANm_UT_PORT_BITMAP_HIf_GET BCM56218_A0_EGR_VLANm_UT_PORT_BITMAP_HIf_GET
#define EGR_VLANm_UT_PORT_BITMAP_HIf_SET BCM56218_A0_EGR_VLANm_UT_PORT_BITMAP_HIf_SET
#define EGR_VLANm_STGf_GET BCM56218_A0_EGR_VLANm_STGf_GET
#define EGR_VLANm_STGf_SET BCM56218_A0_EGR_VLANm_STGf_SET
#define EGR_VLANm_VALIDf_GET BCM56218_A0_EGR_VLANm_VALIDf_GET
#define EGR_VLANm_VALIDf_SET BCM56218_A0_EGR_VLANm_VALIDf_SET
#define READ_EGR_VLANm BCM56218_A0_READ_EGR_VLANm
#define WRITE_EGR_VLANm BCM56218_A0_WRITE_EGR_VLANm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_EGR_VLANm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  EGR_VLAN_CONTROL_1
 * BLOCKS:   EPIPE
 * DESC:     Controls Vlan Translate and VLAN membership related functions.

 * SIZE:     32
 * FIELDS:
 *     OUTER_TPID       TPID to identify the outer tag. Also this tpid is used when packet modification stages add a vlan tag in the packet. 
 *
 ******************************************************************************/
#define BCM56218_A0_EGR_VLAN_CONTROL_1r 0x01900003

#define BCM56218_A0_EGR_VLAN_CONTROL_1r_SIZE 4

/*
 * This structure should be used to declare and program EGR_VLAN_CONTROL_1.
 *
 */
typedef union BCM56218_A0_EGR_VLAN_CONTROL_1r_s {
	uint32_t v[1];
	uint32_t egr_vlan_control_1[1];
	uint32_t _egr_vlan_control_1;
} BCM56218_A0_EGR_VLAN_CONTROL_1r_t;

#define BCM56218_A0_EGR_VLAN_CONTROL_1r_CLR(r) (r).egr_vlan_control_1[0] = 0
#define BCM56218_A0_EGR_VLAN_CONTROL_1r_SET(r,d) (r).egr_vlan_control_1[0] = d
#define BCM56218_A0_EGR_VLAN_CONTROL_1r_GET(r) (r).egr_vlan_control_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_EGR_VLAN_CONTROL_1r_OUTER_TPIDf_GET(r) (((r).egr_vlan_control_1[0]) & 0xffff)
#define BCM56218_A0_EGR_VLAN_CONTROL_1r_OUTER_TPIDf_SET(r,f) (r).egr_vlan_control_1[0]=(((r).egr_vlan_control_1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access EGR_VLAN_CONTROL_1.
 *
 */
#define BCM56218_A0_READ_EGR_VLAN_CONTROL_1r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_EGR_VLAN_CONTROL_1r,(r._egr_vlan_control_1))
#define BCM56218_A0_WRITE_EGR_VLAN_CONTROL_1r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_EGR_VLAN_CONTROL_1r,&(r._egr_vlan_control_1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_VLAN_CONTROL_1r BCM56218_A0_EGR_VLAN_CONTROL_1r
#define EGR_VLAN_CONTROL_1r_SIZE BCM56218_A0_EGR_VLAN_CONTROL_1r_SIZE
typedef BCM56218_A0_EGR_VLAN_CONTROL_1r_t EGR_VLAN_CONTROL_1r_t;
#define EGR_VLAN_CONTROL_1r_CLR BCM56218_A0_EGR_VLAN_CONTROL_1r_CLR
#define EGR_VLAN_CONTROL_1r_SET BCM56218_A0_EGR_VLAN_CONTROL_1r_SET
#define EGR_VLAN_CONTROL_1r_GET BCM56218_A0_EGR_VLAN_CONTROL_1r_GET
#define EGR_VLAN_CONTROL_1r_OUTER_TPIDf_GET BCM56218_A0_EGR_VLAN_CONTROL_1r_OUTER_TPIDf_GET
#define EGR_VLAN_CONTROL_1r_OUTER_TPIDf_SET BCM56218_A0_EGR_VLAN_CONTROL_1r_OUTER_TPIDf_SET
#define READ_EGR_VLAN_CONTROL_1r BCM56218_A0_READ_EGR_VLAN_CONTROL_1r
#define WRITE_EGR_VLAN_CONTROL_1r BCM56218_A0_WRITE_EGR_VLAN_CONTROL_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_EGR_VLAN_CONTROL_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  EGR_VLAN_STG
 * BLOCKS:   EPIPE
 * DESC:     Egress Spanning Tree Stage Table
 * SIZE:     108
 * FIELDS:
 *     SP_TREE_PORT0    Spanning Tree State for Port 0.
 *     SP_TREE_PORT1    Spanning Tree State for Port 1.
 *     SP_TREE_PORT2    Spanning Tree State for Port 2.
 *     SP_TREE_PORT3    Spanning Tree State for Port 3.
 *     SP_TREE_PORT4    Spanning Tree State for Port 4.
 *     SP_TREE_PORT5    Spanning Tree State for Port 5.
 *     SP_TREE_PORT6    Spanning Tree State for Port 6.
 *     SP_TREE_PORT7    Spanning Tree State for Port 7.
 *     SP_TREE_PORT8    Spanning Tree State for Port 8.
 *     SP_TREE_PORT9    Spanning Tree State for Port 9.
 *     SP_TREE_PORT10   Spanning Tree State for Port 10.
 *     SP_TREE_PORT11   Spanning Tree State for Port 11.
 *     SP_TREE_PORT12   Spanning Tree State for Port 12.
 *     SP_TREE_PORT13   Spanning Tree State for Port 13.
 *     SP_TREE_PORT14   Spanning Tree State for Port 14.
 *     SP_TREE_PORT15   Spanning Tree State for Port 15.
 *     SP_TREE_PORT16   Spanning Tree State for Port 16.
 *     SP_TREE_PORT17   Spanning Tree State for Port 17.
 *     SP_TREE_PORT18   Spanning Tree State for Port 18.
 *     SP_TREE_PORT19   Spanning Tree State for Port 19.
 *     SP_TREE_PORT20   Spanning Tree State for Port 20.
 *     SP_TREE_PORT21   Spanning Tree State for Port 21.
 *     SP_TREE_PORT22   Spanning Tree State for Port 22.
 *     SP_TREE_PORT23   Spanning Tree State for Port 23.
 *     SP_TREE_PORT24   Spanning Tree State for Port 24.
 *     SP_TREE_PORT25   Spanning Tree State for Port 25.
 *     SP_TREE_PORT26   Spanning Tree State for Port 26.
 *     SP_TREE_PORT27   Spanning Tree State for Port 27.
 *     SP_TREE_PORT28   Spanning Tree State for Port 28.
 *     SP_TREE_PORT29   Spanning Tree State for Port 29.
 *     SP_TREE_PORT30   Spanning Tree State for Port 30.
 *     SP_TREE_PORT31   Spanning Tree State for Port 31.
 *     SP_TREE_PORT32   Spanning Tree State for Port 32.
 *     SP_TREE_PORT33   Spanning Tree State for Port 33.
 *     SP_TREE_PORT34   Spanning Tree State for Port 34.
 *     SP_TREE_PORT35   Spanning Tree State for Port 35.
 *     SP_TREE_PORT36   Spanning Tree State for Port 36.
 *     SP_TREE_PORT37   Spanning Tree State for Port 37.
 *     SP_TREE_PORT38   Spanning Tree State for Port 38.
 *     SP_TREE_PORT39   Spanning Tree State for Port 39.
 *     SP_TREE_PORT40   Spanning Tree State for Port 40.
 *     SP_TREE_PORT41   Spanning Tree State for Port 41.
 *     SP_TREE_PORT42   Spanning Tree State for Port 42.
 *     SP_TREE_PORT43   Spanning Tree State for Port 43.
 *     SP_TREE_PORT44   Spanning Tree State for Port 44.
 *     SP_TREE_PORT45   Spanning Tree State for Port 45.
 *     SP_TREE_PORT46   Spanning Tree State for Port 46.
 *     SP_TREE_PORT47   Spanning Tree State for Port 47.
 *     SP_TREE_PORT48   Spanning Tree State for Port 48.
 *     SP_TREE_PORT49   Spanning Tree State for Port 49.
 *     SP_TREE_PORT50   Spanning Tree State for Port 50.
 *     SP_TREE_PORT51   Spanning Tree State for Port 51.
 *     SP_TREE_PORT52   Spanning Tree State for Port 52.
 *     SP_TREE_PORT53   Spanning Tree State for Port 53.
 *
 ******************************************************************************/
#define BCM56218_A0_EGR_VLAN_STGm 0x04920000

#define BCM56218_A0_EGR_VLAN_STGm_MIN 0
#define BCM56218_A0_EGR_VLAN_STGm_MAX 127
#define BCM56218_A0_EGR_VLAN_STGm_CMAX(u) 127
#define BCM56218_A0_EGR_VLAN_STGm_SIZE 14

/*
 * This structure should be used to declare and program EGR_VLAN_STG.
 *
 */
typedef union BCM56218_A0_EGR_VLAN_STGm_s {
	uint32_t v[4];
	uint32_t egr_vlan_stg[4];
	uint32_t _egr_vlan_stg;
} BCM56218_A0_EGR_VLAN_STGm_t;

#define BCM56218_A0_EGR_VLAN_STGm_CLR(r) CDK_MEMSET(&((r)._egr_vlan_stg), 0, sizeof(BCM56218_A0_EGR_VLAN_STGm_t))
#define BCM56218_A0_EGR_VLAN_STGm_SET(r,i,d) (r).egr_vlan_stg[i] = d
#define BCM56218_A0_EGR_VLAN_STGm_GET(r,i) (r).egr_vlan_stg[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT0f_GET(r) (((r).egr_vlan_stg[0]) & 0x3)
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT0f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT1f_GET(r) ((((r).egr_vlan_stg[0]) >> 2) & 0x3)
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT1f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT2f_GET(r) ((((r).egr_vlan_stg[0]) >> 4) & 0x3)
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT2f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT3f_GET(r) ((((r).egr_vlan_stg[0]) >> 6) & 0x3)
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT3f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT4f_GET(r) ((((r).egr_vlan_stg[0]) >> 8) & 0x3)
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT4f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT5f_GET(r) ((((r).egr_vlan_stg[0]) >> 10) & 0x3)
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT5f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT6f_GET(r) ((((r).egr_vlan_stg[0]) >> 12) & 0x3)
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT6f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT7f_GET(r) ((((r).egr_vlan_stg[0]) >> 14) & 0x3)
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT7f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT8f_GET(r) ((((r).egr_vlan_stg[0]) >> 16) & 0x3)
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT8f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT9f_GET(r) ((((r).egr_vlan_stg[0]) >> 18) & 0x3)
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT9f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32_t)0x3 << 18)) | ((((uint32_t)f) & 0x3) << 18))
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT10f_GET(r) ((((r).egr_vlan_stg[0]) >> 20) & 0x3)
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT10f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32_t)0x3 << 20)) | ((((uint32_t)f) & 0x3) << 20))
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT11f_GET(r) ((((r).egr_vlan_stg[0]) >> 22) & 0x3)
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT11f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32_t)0x3 << 22)) | ((((uint32_t)f) & 0x3) << 22))
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT12f_GET(r) ((((r).egr_vlan_stg[0]) >> 24) & 0x3)
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT12f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32_t)0x3 << 24)) | ((((uint32_t)f) & 0x3) << 24))
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT13f_GET(r) ((((r).egr_vlan_stg[0]) >> 26) & 0x3)
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT13f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32_t)0x3 << 26)) | ((((uint32_t)f) & 0x3) << 26))
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT14f_GET(r) ((((r).egr_vlan_stg[0]) >> 28) & 0x3)
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT14f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32_t)0x3 << 28)) | ((((uint32_t)f) & 0x3) << 28))
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT15f_GET(r) ((((r).egr_vlan_stg[0]) >> 30) & 0x3)
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT15f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT16f_GET(r) (((r).egr_vlan_stg[1]) & 0x3)
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT16f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT17f_GET(r) ((((r).egr_vlan_stg[1]) >> 2) & 0x3)
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT17f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT18f_GET(r) ((((r).egr_vlan_stg[1]) >> 4) & 0x3)
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT18f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT19f_GET(r) ((((r).egr_vlan_stg[1]) >> 6) & 0x3)
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT19f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT20f_GET(r) ((((r).egr_vlan_stg[1]) >> 8) & 0x3)
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT20f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT21f_GET(r) ((((r).egr_vlan_stg[1]) >> 10) & 0x3)
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT21f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT22f_GET(r) ((((r).egr_vlan_stg[1]) >> 12) & 0x3)
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT22f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT23f_GET(r) ((((r).egr_vlan_stg[1]) >> 14) & 0x3)
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT23f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT24f_GET(r) ((((r).egr_vlan_stg[1]) >> 16) & 0x3)
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT24f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT25f_GET(r) ((((r).egr_vlan_stg[1]) >> 18) & 0x3)
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT25f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32_t)0x3 << 18)) | ((((uint32_t)f) & 0x3) << 18))
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT26f_GET(r) ((((r).egr_vlan_stg[1]) >> 20) & 0x3)
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT26f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32_t)0x3 << 20)) | ((((uint32_t)f) & 0x3) << 20))
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT27f_GET(r) ((((r).egr_vlan_stg[1]) >> 22) & 0x3)
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT27f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32_t)0x3 << 22)) | ((((uint32_t)f) & 0x3) << 22))
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT28f_GET(r) ((((r).egr_vlan_stg[1]) >> 24) & 0x3)
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT28f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32_t)0x3 << 24)) | ((((uint32_t)f) & 0x3) << 24))
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT29f_GET(r) ((((r).egr_vlan_stg[1]) >> 26) & 0x3)
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT29f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32_t)0x3 << 26)) | ((((uint32_t)f) & 0x3) << 26))
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT30f_GET(r) ((((r).egr_vlan_stg[1]) >> 28) & 0x3)
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT30f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32_t)0x3 << 28)) | ((((uint32_t)f) & 0x3) << 28))
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT31f_GET(r) ((((r).egr_vlan_stg[1]) >> 30) & 0x3)
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT31f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT32f_GET(r) (((r).egr_vlan_stg[2]) & 0x3)
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT32f_SET(r,f) (r).egr_vlan_stg[2]=(((r).egr_vlan_stg[2] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT33f_GET(r) ((((r).egr_vlan_stg[2]) >> 2) & 0x3)
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT33f_SET(r,f) (r).egr_vlan_stg[2]=(((r).egr_vlan_stg[2] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT34f_GET(r) ((((r).egr_vlan_stg[2]) >> 4) & 0x3)
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT34f_SET(r,f) (r).egr_vlan_stg[2]=(((r).egr_vlan_stg[2] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT35f_GET(r) ((((r).egr_vlan_stg[2]) >> 6) & 0x3)
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT35f_SET(r,f) (r).egr_vlan_stg[2]=(((r).egr_vlan_stg[2] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT36f_GET(r) ((((r).egr_vlan_stg[2]) >> 8) & 0x3)
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT36f_SET(r,f) (r).egr_vlan_stg[2]=(((r).egr_vlan_stg[2] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT37f_GET(r) ((((r).egr_vlan_stg[2]) >> 10) & 0x3)
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT37f_SET(r,f) (r).egr_vlan_stg[2]=(((r).egr_vlan_stg[2] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT38f_GET(r) ((((r).egr_vlan_stg[2]) >> 12) & 0x3)
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT38f_SET(r,f) (r).egr_vlan_stg[2]=(((r).egr_vlan_stg[2] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT39f_GET(r) ((((r).egr_vlan_stg[2]) >> 14) & 0x3)
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT39f_SET(r,f) (r).egr_vlan_stg[2]=(((r).egr_vlan_stg[2] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT40f_GET(r) ((((r).egr_vlan_stg[2]) >> 16) & 0x3)
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT40f_SET(r,f) (r).egr_vlan_stg[2]=(((r).egr_vlan_stg[2] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT41f_GET(r) ((((r).egr_vlan_stg[2]) >> 18) & 0x3)
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT41f_SET(r,f) (r).egr_vlan_stg[2]=(((r).egr_vlan_stg[2] & ~((uint32_t)0x3 << 18)) | ((((uint32_t)f) & 0x3) << 18))
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT42f_GET(r) ((((r).egr_vlan_stg[2]) >> 20) & 0x3)
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT42f_SET(r,f) (r).egr_vlan_stg[2]=(((r).egr_vlan_stg[2] & ~((uint32_t)0x3 << 20)) | ((((uint32_t)f) & 0x3) << 20))
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT43f_GET(r) ((((r).egr_vlan_stg[2]) >> 22) & 0x3)
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT43f_SET(r,f) (r).egr_vlan_stg[2]=(((r).egr_vlan_stg[2] & ~((uint32_t)0x3 << 22)) | ((((uint32_t)f) & 0x3) << 22))
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT44f_GET(r) ((((r).egr_vlan_stg[2]) >> 24) & 0x3)
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT44f_SET(r,f) (r).egr_vlan_stg[2]=(((r).egr_vlan_stg[2] & ~((uint32_t)0x3 << 24)) | ((((uint32_t)f) & 0x3) << 24))
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT45f_GET(r) ((((r).egr_vlan_stg[2]) >> 26) & 0x3)
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT45f_SET(r,f) (r).egr_vlan_stg[2]=(((r).egr_vlan_stg[2] & ~((uint32_t)0x3 << 26)) | ((((uint32_t)f) & 0x3) << 26))
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT46f_GET(r) ((((r).egr_vlan_stg[2]) >> 28) & 0x3)
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT46f_SET(r,f) (r).egr_vlan_stg[2]=(((r).egr_vlan_stg[2] & ~((uint32_t)0x3 << 28)) | ((((uint32_t)f) & 0x3) << 28))
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT47f_GET(r) ((((r).egr_vlan_stg[2]) >> 30) & 0x3)
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT47f_SET(r,f) (r).egr_vlan_stg[2]=(((r).egr_vlan_stg[2] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT48f_GET(r) (((r).egr_vlan_stg[3]) & 0x3)
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT48f_SET(r,f) (r).egr_vlan_stg[3]=(((r).egr_vlan_stg[3] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT49f_GET(r) ((((r).egr_vlan_stg[3]) >> 2) & 0x3)
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT49f_SET(r,f) (r).egr_vlan_stg[3]=(((r).egr_vlan_stg[3] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT50f_GET(r) ((((r).egr_vlan_stg[3]) >> 4) & 0x3)
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT50f_SET(r,f) (r).egr_vlan_stg[3]=(((r).egr_vlan_stg[3] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT51f_GET(r) ((((r).egr_vlan_stg[3]) >> 6) & 0x3)
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT51f_SET(r,f) (r).egr_vlan_stg[3]=(((r).egr_vlan_stg[3] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT52f_GET(r) ((((r).egr_vlan_stg[3]) >> 8) & 0x3)
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT52f_SET(r,f) (r).egr_vlan_stg[3]=(((r).egr_vlan_stg[3] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT53f_GET(r) ((((r).egr_vlan_stg[3]) >> 10) & 0x3)
#define BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT53f_SET(r,f) (r).egr_vlan_stg[3]=(((r).egr_vlan_stg[3] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))

/*
 * These macros can be used to access EGR_VLAN_STG.
 *
 */
#define BCM56218_A0_READ_EGR_VLAN_STGm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_EGR_VLAN_STGm,i,(m._egr_vlan_stg),4)
#define BCM56218_A0_WRITE_EGR_VLAN_STGm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_EGR_VLAN_STGm,i,&(m._egr_vlan_stg),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_VLAN_STGm BCM56218_A0_EGR_VLAN_STGm
#define EGR_VLAN_STGm_MIN BCM56218_A0_EGR_VLAN_STGm_MIN
#define EGR_VLAN_STGm_MAX BCM56218_A0_EGR_VLAN_STGm_MAX
#define EGR_VLAN_STGm_CMAX(u) BCM56218_A0_EGR_VLAN_STGm_CMAX(u)
#define EGR_VLAN_STGm_SIZE BCM56218_A0_EGR_VLAN_STGm_SIZE
typedef BCM56218_A0_EGR_VLAN_STGm_t EGR_VLAN_STGm_t;
#define EGR_VLAN_STGm_CLR BCM56218_A0_EGR_VLAN_STGm_CLR
#define EGR_VLAN_STGm_SET BCM56218_A0_EGR_VLAN_STGm_SET
#define EGR_VLAN_STGm_GET BCM56218_A0_EGR_VLAN_STGm_GET
#define EGR_VLAN_STGm_SP_TREE_PORT0f_GET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT0f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT0f_SET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT0f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT1f_GET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT1f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT1f_SET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT1f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT2f_GET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT2f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT2f_SET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT2f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT3f_GET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT3f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT3f_SET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT3f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT4f_GET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT4f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT4f_SET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT4f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT5f_GET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT5f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT5f_SET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT5f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT6f_GET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT6f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT6f_SET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT6f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT7f_GET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT7f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT7f_SET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT7f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT8f_GET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT8f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT8f_SET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT8f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT9f_GET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT9f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT9f_SET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT9f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT10f_GET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT10f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT10f_SET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT10f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT11f_GET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT11f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT11f_SET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT11f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT12f_GET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT12f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT12f_SET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT12f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT13f_GET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT13f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT13f_SET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT13f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT14f_GET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT14f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT14f_SET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT14f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT15f_GET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT15f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT15f_SET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT15f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT16f_GET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT16f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT16f_SET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT16f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT17f_GET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT17f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT17f_SET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT17f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT18f_GET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT18f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT18f_SET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT18f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT19f_GET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT19f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT19f_SET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT19f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT20f_GET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT20f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT20f_SET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT20f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT21f_GET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT21f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT21f_SET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT21f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT22f_GET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT22f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT22f_SET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT22f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT23f_GET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT23f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT23f_SET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT23f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT24f_GET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT24f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT24f_SET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT24f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT25f_GET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT25f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT25f_SET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT25f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT26f_GET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT26f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT26f_SET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT26f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT27f_GET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT27f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT27f_SET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT27f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT28f_GET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT28f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT28f_SET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT28f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT29f_GET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT29f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT29f_SET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT29f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT30f_GET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT30f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT30f_SET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT30f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT31f_GET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT31f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT31f_SET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT31f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT32f_GET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT32f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT32f_SET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT32f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT33f_GET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT33f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT33f_SET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT33f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT34f_GET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT34f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT34f_SET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT34f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT35f_GET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT35f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT35f_SET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT35f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT36f_GET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT36f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT36f_SET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT36f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT37f_GET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT37f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT37f_SET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT37f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT38f_GET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT38f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT38f_SET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT38f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT39f_GET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT39f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT39f_SET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT39f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT40f_GET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT40f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT40f_SET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT40f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT41f_GET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT41f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT41f_SET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT41f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT42f_GET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT42f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT42f_SET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT42f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT43f_GET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT43f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT43f_SET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT43f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT44f_GET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT44f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT44f_SET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT44f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT45f_GET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT45f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT45f_SET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT45f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT46f_GET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT46f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT46f_SET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT46f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT47f_GET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT47f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT47f_SET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT47f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT48f_GET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT48f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT48f_SET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT48f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT49f_GET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT49f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT49f_SET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT49f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT50f_GET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT50f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT50f_SET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT50f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT51f_GET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT51f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT51f_SET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT51f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT52f_GET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT52f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT52f_SET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT52f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT53f_GET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT53f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT53f_SET BCM56218_A0_EGR_VLAN_STGm_SP_TREE_PORT53f_SET
#define READ_EGR_VLAN_STGm BCM56218_A0_READ_EGR_VLAN_STGm
#define WRITE_EGR_VLAN_STGm BCM56218_A0_WRITE_EGR_VLAN_STGm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_EGR_VLAN_STGm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  EMIRROR_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     Egress mirror bitmap register - Lower Bitmap
 * SIZE:     32
 * FIELDS:
 *     BITMAP           Egress mirror bitmap
 *
 ******************************************************************************/
#define BCM56218_A0_EMIRROR_CONTROLr 0x0e700109

#define BCM56218_A0_EMIRROR_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program EMIRROR_CONTROL.
 *
 */
typedef union BCM56218_A0_EMIRROR_CONTROLr_s {
	uint32_t v[1];
	uint32_t emirror_control[1];
	uint32_t _emirror_control;
} BCM56218_A0_EMIRROR_CONTROLr_t;

#define BCM56218_A0_EMIRROR_CONTROLr_CLR(r) (r).emirror_control[0] = 0
#define BCM56218_A0_EMIRROR_CONTROLr_SET(r,d) (r).emirror_control[0] = d
#define BCM56218_A0_EMIRROR_CONTROLr_GET(r) (r).emirror_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_EMIRROR_CONTROLr_BITMAPf_GET(r) ((r).emirror_control[0])
#define BCM56218_A0_EMIRROR_CONTROLr_BITMAPf_SET(r,f) (r).emirror_control[0]=((uint32_t)f)

/*
 * These macros can be used to access EMIRROR_CONTROL.
 *
 */
#define BCM56218_A0_READ_EMIRROR_CONTROLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_EMIRROR_CONTROLr,(r._emirror_control))
#define BCM56218_A0_WRITE_EMIRROR_CONTROLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_EMIRROR_CONTROLr,&(r._emirror_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EMIRROR_CONTROLr BCM56218_A0_EMIRROR_CONTROLr
#define EMIRROR_CONTROLr_SIZE BCM56218_A0_EMIRROR_CONTROLr_SIZE
typedef BCM56218_A0_EMIRROR_CONTROLr_t EMIRROR_CONTROLr_t;
#define EMIRROR_CONTROLr_CLR BCM56218_A0_EMIRROR_CONTROLr_CLR
#define EMIRROR_CONTROLr_SET BCM56218_A0_EMIRROR_CONTROLr_SET
#define EMIRROR_CONTROLr_GET BCM56218_A0_EMIRROR_CONTROLr_GET
#define EMIRROR_CONTROLr_BITMAPf_GET BCM56218_A0_EMIRROR_CONTROLr_BITMAPf_GET
#define EMIRROR_CONTROLr_BITMAPf_SET BCM56218_A0_EMIRROR_CONTROLr_BITMAPf_SET
#define READ_EMIRROR_CONTROLr BCM56218_A0_READ_EMIRROR_CONTROLr
#define WRITE_EMIRROR_CONTROLr BCM56218_A0_WRITE_EMIRROR_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_EMIRROR_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  EMIRROR_CONTROL_HI
 * BLOCKS:   IPIPE
 * DESC:     Egress mirror bitmap register - Upper Bitmap
 * SIZE:     32
 * FIELDS:
 *     BITMAP           Egress mirror bitmap
 *
 ******************************************************************************/
#define BCM56218_A0_EMIRROR_CONTROL_HIr 0x0e70010a

#define BCM56218_A0_EMIRROR_CONTROL_HIr_SIZE 4

/*
 * This structure should be used to declare and program EMIRROR_CONTROL_HI.
 *
 */
typedef union BCM56218_A0_EMIRROR_CONTROL_HIr_s {
	uint32_t v[1];
	uint32_t emirror_control_hi[1];
	uint32_t _emirror_control_hi;
} BCM56218_A0_EMIRROR_CONTROL_HIr_t;

#define BCM56218_A0_EMIRROR_CONTROL_HIr_CLR(r) (r).emirror_control_hi[0] = 0
#define BCM56218_A0_EMIRROR_CONTROL_HIr_SET(r,d) (r).emirror_control_hi[0] = d
#define BCM56218_A0_EMIRROR_CONTROL_HIr_GET(r) (r).emirror_control_hi[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_EMIRROR_CONTROL_HIr_BITMAPf_GET(r) (((r).emirror_control_hi[0]) & 0x3fffff)
#define BCM56218_A0_EMIRROR_CONTROL_HIr_BITMAPf_SET(r,f) (r).emirror_control_hi[0]=(((r).emirror_control_hi[0] & ~((uint32_t)0x3fffff)) | (((uint32_t)f) & 0x3fffff))

/*
 * These macros can be used to access EMIRROR_CONTROL_HI.
 *
 */
#define BCM56218_A0_READ_EMIRROR_CONTROL_HIr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_EMIRROR_CONTROL_HIr,(r._emirror_control_hi))
#define BCM56218_A0_WRITE_EMIRROR_CONTROL_HIr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_EMIRROR_CONTROL_HIr,&(r._emirror_control_hi))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EMIRROR_CONTROL_HIr BCM56218_A0_EMIRROR_CONTROL_HIr
#define EMIRROR_CONTROL_HIr_SIZE BCM56218_A0_EMIRROR_CONTROL_HIr_SIZE
typedef BCM56218_A0_EMIRROR_CONTROL_HIr_t EMIRROR_CONTROL_HIr_t;
#define EMIRROR_CONTROL_HIr_CLR BCM56218_A0_EMIRROR_CONTROL_HIr_CLR
#define EMIRROR_CONTROL_HIr_SET BCM56218_A0_EMIRROR_CONTROL_HIr_SET
#define EMIRROR_CONTROL_HIr_GET BCM56218_A0_EMIRROR_CONTROL_HIr_GET
#define EMIRROR_CONTROL_HIr_BITMAPf_GET BCM56218_A0_EMIRROR_CONTROL_HIr_BITMAPf_GET
#define EMIRROR_CONTROL_HIr_BITMAPf_SET BCM56218_A0_EMIRROR_CONTROL_HIr_BITMAPf_SET
#define READ_EMIRROR_CONTROL_HIr BCM56218_A0_READ_EMIRROR_CONTROL_HIr
#define WRITE_EMIRROR_CONTROL_HIr BCM56218_A0_WRITE_EMIRROR_CONTROL_HIr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_EMIRROR_CONTROL_HIr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  EM_MTP_INDEX
 * BLOCKS:   IPIPE
 * DESC:     Egress Mirror to Port Table
 * SIZE:     11
 * FIELDS:
 *     PORT_TGID        Mirror to port port/TGID
 *     MODULE_ID        Mirror to port module ID
 *
 ******************************************************************************/
#define BCM56218_A0_EM_MTP_INDEXm 0x0e7b0000

#define BCM56218_A0_EM_MTP_INDEXm_MIN 0
#define BCM56218_A0_EM_MTP_INDEXm_MAX 3
#define BCM56218_A0_EM_MTP_INDEXm_CMAX(u) 3
#define BCM56218_A0_EM_MTP_INDEXm_SIZE 2

/*
 * This structure should be used to declare and program EM_MTP_INDEX.
 *
 */
typedef union BCM56218_A0_EM_MTP_INDEXm_s {
	uint32_t v[1];
	uint32_t em_mtp_index[1];
	uint32_t _em_mtp_index;
} BCM56218_A0_EM_MTP_INDEXm_t;

#define BCM56218_A0_EM_MTP_INDEXm_CLR(r) (r).em_mtp_index[0] = 0
#define BCM56218_A0_EM_MTP_INDEXm_SET(r,d) (r).em_mtp_index[0] = d
#define BCM56218_A0_EM_MTP_INDEXm_GET(r) (r).em_mtp_index[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_EM_MTP_INDEXm_PORT_TGIDf_GET(r) (((r).em_mtp_index[0]) & 0x7f)
#define BCM56218_A0_EM_MTP_INDEXm_PORT_TGIDf_SET(r,f) (r).em_mtp_index[0]=(((r).em_mtp_index[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f))
#define BCM56218_A0_EM_MTP_INDEXm_MODULE_IDf_GET(r) ((((r).em_mtp_index[0]) >> 7) & 0xf)
#define BCM56218_A0_EM_MTP_INDEXm_MODULE_IDf_SET(r,f) (r).em_mtp_index[0]=(((r).em_mtp_index[0] & ~((uint32_t)0xf << 7)) | ((((uint32_t)f) & 0xf) << 7))

/*
 * These macros can be used to access EM_MTP_INDEX.
 *
 */
#define BCM56218_A0_READ_EM_MTP_INDEXm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_EM_MTP_INDEXm,i,(m._em_mtp_index),1)
#define BCM56218_A0_WRITE_EM_MTP_INDEXm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_EM_MTP_INDEXm,i,&(m._em_mtp_index),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EM_MTP_INDEXm BCM56218_A0_EM_MTP_INDEXm
#define EM_MTP_INDEXm_MIN BCM56218_A0_EM_MTP_INDEXm_MIN
#define EM_MTP_INDEXm_MAX BCM56218_A0_EM_MTP_INDEXm_MAX
#define EM_MTP_INDEXm_CMAX(u) BCM56218_A0_EM_MTP_INDEXm_CMAX(u)
#define EM_MTP_INDEXm_SIZE BCM56218_A0_EM_MTP_INDEXm_SIZE
typedef BCM56218_A0_EM_MTP_INDEXm_t EM_MTP_INDEXm_t;
#define EM_MTP_INDEXm_CLR BCM56218_A0_EM_MTP_INDEXm_CLR
#define EM_MTP_INDEXm_SET BCM56218_A0_EM_MTP_INDEXm_SET
#define EM_MTP_INDEXm_GET BCM56218_A0_EM_MTP_INDEXm_GET
#define EM_MTP_INDEXm_PORT_TGIDf_GET BCM56218_A0_EM_MTP_INDEXm_PORT_TGIDf_GET
#define EM_MTP_INDEXm_PORT_TGIDf_SET BCM56218_A0_EM_MTP_INDEXm_PORT_TGIDf_SET
#define EM_MTP_INDEXm_MODULE_IDf_GET BCM56218_A0_EM_MTP_INDEXm_MODULE_IDf_GET
#define EM_MTP_INDEXm_MODULE_IDf_SET BCM56218_A0_EM_MTP_INDEXm_MODULE_IDf_SET
#define READ_EM_MTP_INDEXm BCM56218_A0_READ_EM_MTP_INDEXm
#define WRITE_EM_MTP_INDEXm BCM56218_A0_WRITE_EM_MTP_INDEXm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_EM_MTP_INDEXm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  EPC_LINK_BMAP
 * BLOCKS:   IPIPE
 * DESC:     Link status register - Lower Bitmap
 * SIZE:     32
 * FIELDS:
 *     PORT_BITMAP      Link status bitmap 
 *
 ******************************************************************************/
#define BCM56218_A0_EPC_LINK_BMAPr 0x0e780110

#define BCM56218_A0_EPC_LINK_BMAPr_SIZE 4

/*
 * This structure should be used to declare and program EPC_LINK_BMAP.
 *
 */
typedef union BCM56218_A0_EPC_LINK_BMAPr_s {
	uint32_t v[1];
	uint32_t epc_link_bmap[1];
	uint32_t _epc_link_bmap;
} BCM56218_A0_EPC_LINK_BMAPr_t;

#define BCM56218_A0_EPC_LINK_BMAPr_CLR(r) (r).epc_link_bmap[0] = 0
#define BCM56218_A0_EPC_LINK_BMAPr_SET(r,d) (r).epc_link_bmap[0] = d
#define BCM56218_A0_EPC_LINK_BMAPr_GET(r) (r).epc_link_bmap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_EPC_LINK_BMAPr_PORT_BITMAPf_GET(r) ((r).epc_link_bmap[0])
#define BCM56218_A0_EPC_LINK_BMAPr_PORT_BITMAPf_SET(r,f) (r).epc_link_bmap[0]=((uint32_t)f)

/*
 * These macros can be used to access EPC_LINK_BMAP.
 *
 */
#define BCM56218_A0_READ_EPC_LINK_BMAPr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_EPC_LINK_BMAPr,(r._epc_link_bmap))
#define BCM56218_A0_WRITE_EPC_LINK_BMAPr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_EPC_LINK_BMAPr,&(r._epc_link_bmap))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EPC_LINK_BMAPr BCM56218_A0_EPC_LINK_BMAPr
#define EPC_LINK_BMAPr_SIZE BCM56218_A0_EPC_LINK_BMAPr_SIZE
typedef BCM56218_A0_EPC_LINK_BMAPr_t EPC_LINK_BMAPr_t;
#define EPC_LINK_BMAPr_CLR BCM56218_A0_EPC_LINK_BMAPr_CLR
#define EPC_LINK_BMAPr_SET BCM56218_A0_EPC_LINK_BMAPr_SET
#define EPC_LINK_BMAPr_GET BCM56218_A0_EPC_LINK_BMAPr_GET
#define EPC_LINK_BMAPr_PORT_BITMAPf_GET BCM56218_A0_EPC_LINK_BMAPr_PORT_BITMAPf_GET
#define EPC_LINK_BMAPr_PORT_BITMAPf_SET BCM56218_A0_EPC_LINK_BMAPr_PORT_BITMAPf_SET
#define READ_EPC_LINK_BMAPr BCM56218_A0_READ_EPC_LINK_BMAPr
#define WRITE_EPC_LINK_BMAPr BCM56218_A0_WRITE_EPC_LINK_BMAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_EPC_LINK_BMAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  EPC_LINK_BMAP_HI
 * BLOCKS:   IPIPE
 * DESC:     Link status register - Upper Bitmap
 * SIZE:     32
 * FIELDS:
 *     PORT_BITMAP      Link status bitmap 
 *
 ******************************************************************************/
#define BCM56218_A0_EPC_LINK_BMAP_HIr 0x0e780111

#define BCM56218_A0_EPC_LINK_BMAP_HIr_SIZE 4

/*
 * This structure should be used to declare and program EPC_LINK_BMAP_HI.
 *
 */
typedef union BCM56218_A0_EPC_LINK_BMAP_HIr_s {
	uint32_t v[1];
	uint32_t epc_link_bmap_hi[1];
	uint32_t _epc_link_bmap_hi;
} BCM56218_A0_EPC_LINK_BMAP_HIr_t;

#define BCM56218_A0_EPC_LINK_BMAP_HIr_CLR(r) (r).epc_link_bmap_hi[0] = 0
#define BCM56218_A0_EPC_LINK_BMAP_HIr_SET(r,d) (r).epc_link_bmap_hi[0] = d
#define BCM56218_A0_EPC_LINK_BMAP_HIr_GET(r) (r).epc_link_bmap_hi[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_EPC_LINK_BMAP_HIr_PORT_BITMAPf_GET(r) (((r).epc_link_bmap_hi[0]) & 0x3fffff)
#define BCM56218_A0_EPC_LINK_BMAP_HIr_PORT_BITMAPf_SET(r,f) (r).epc_link_bmap_hi[0]=(((r).epc_link_bmap_hi[0] & ~((uint32_t)0x3fffff)) | (((uint32_t)f) & 0x3fffff))

/*
 * These macros can be used to access EPC_LINK_BMAP_HI.
 *
 */
#define BCM56218_A0_READ_EPC_LINK_BMAP_HIr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_EPC_LINK_BMAP_HIr,(r._epc_link_bmap_hi))
#define BCM56218_A0_WRITE_EPC_LINK_BMAP_HIr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_EPC_LINK_BMAP_HIr,&(r._epc_link_bmap_hi))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EPC_LINK_BMAP_HIr BCM56218_A0_EPC_LINK_BMAP_HIr
#define EPC_LINK_BMAP_HIr_SIZE BCM56218_A0_EPC_LINK_BMAP_HIr_SIZE
typedef BCM56218_A0_EPC_LINK_BMAP_HIr_t EPC_LINK_BMAP_HIr_t;
#define EPC_LINK_BMAP_HIr_CLR BCM56218_A0_EPC_LINK_BMAP_HIr_CLR
#define EPC_LINK_BMAP_HIr_SET BCM56218_A0_EPC_LINK_BMAP_HIr_SET
#define EPC_LINK_BMAP_HIr_GET BCM56218_A0_EPC_LINK_BMAP_HIr_GET
#define EPC_LINK_BMAP_HIr_PORT_BITMAPf_GET BCM56218_A0_EPC_LINK_BMAP_HIr_PORT_BITMAPf_GET
#define EPC_LINK_BMAP_HIr_PORT_BITMAPf_SET BCM56218_A0_EPC_LINK_BMAP_HIr_PORT_BITMAPf_SET
#define READ_EPC_LINK_BMAP_HIr BCM56218_A0_READ_EPC_LINK_BMAP_HIr
#define WRITE_EPC_LINK_BMAP_HIr BCM56218_A0_WRITE_EPC_LINK_BMAP_HIr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_EPC_LINK_BMAP_HIr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  ESA0
 * BLOCKS:   GPORT0
 * DESC:     Station Adress[15:0]
 * SIZE:     32
 * FIELDS:
 *     STAD0            Station Address [15:0]
 *
 ******************************************************************************/
#define BCM56218_A0_ESA0r 0x00000210

#define BCM56218_A0_ESA0r_SIZE 4

/*
 * This structure should be used to declare and program ESA0.
 *
 */
typedef union BCM56218_A0_ESA0r_s {
	uint32_t v[1];
	uint32_t esa0[1];
	uint32_t _esa0;
} BCM56218_A0_ESA0r_t;

#define BCM56218_A0_ESA0r_CLR(r) (r).esa0[0] = 0
#define BCM56218_A0_ESA0r_SET(r,d) (r).esa0[0] = d
#define BCM56218_A0_ESA0r_GET(r) (r).esa0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_ESA0r_STAD0f_GET(r) (((r).esa0[0]) & 0xffff)
#define BCM56218_A0_ESA0r_STAD0f_SET(r,f) (r).esa0[0]=(((r).esa0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access ESA0.
 *
 */
#define BCM56218_A0_READ_ESA0r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_ESA0r,(r._esa0))
#define BCM56218_A0_WRITE_ESA0r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_ESA0r,&(r._esa0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ESA0r BCM56218_A0_ESA0r
#define ESA0r_SIZE BCM56218_A0_ESA0r_SIZE
typedef BCM56218_A0_ESA0r_t ESA0r_t;
#define ESA0r_CLR BCM56218_A0_ESA0r_CLR
#define ESA0r_SET BCM56218_A0_ESA0r_SET
#define ESA0r_GET BCM56218_A0_ESA0r_GET
#define ESA0r_STAD0f_GET BCM56218_A0_ESA0r_STAD0f_GET
#define ESA0r_STAD0f_SET BCM56218_A0_ESA0r_STAD0f_SET
#define READ_ESA0r BCM56218_A0_READ_ESA0r
#define WRITE_ESA0r BCM56218_A0_WRITE_ESA0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_ESA0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  ESA1
 * BLOCKS:   GPORT0
 * DESC:     Station Adress[31:16]
 * SIZE:     32
 * FIELDS:
 *     STAD0            Station Address [31:16]
 *
 ******************************************************************************/
#define BCM56218_A0_ESA1r 0x00000211

#define BCM56218_A0_ESA1r_SIZE 4

/*
 * This structure should be used to declare and program ESA1.
 *
 */
typedef union BCM56218_A0_ESA1r_s {
	uint32_t v[1];
	uint32_t esa1[1];
	uint32_t _esa1;
} BCM56218_A0_ESA1r_t;

#define BCM56218_A0_ESA1r_CLR(r) (r).esa1[0] = 0
#define BCM56218_A0_ESA1r_SET(r,d) (r).esa1[0] = d
#define BCM56218_A0_ESA1r_GET(r) (r).esa1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_ESA1r_STAD0f_GET(r) (((r).esa1[0]) & 0xffff)
#define BCM56218_A0_ESA1r_STAD0f_SET(r,f) (r).esa1[0]=(((r).esa1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access ESA1.
 *
 */
#define BCM56218_A0_READ_ESA1r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_ESA1r,(r._esa1))
#define BCM56218_A0_WRITE_ESA1r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_ESA1r,&(r._esa1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ESA1r BCM56218_A0_ESA1r
#define ESA1r_SIZE BCM56218_A0_ESA1r_SIZE
typedef BCM56218_A0_ESA1r_t ESA1r_t;
#define ESA1r_CLR BCM56218_A0_ESA1r_CLR
#define ESA1r_SET BCM56218_A0_ESA1r_SET
#define ESA1r_GET BCM56218_A0_ESA1r_GET
#define ESA1r_STAD0f_GET BCM56218_A0_ESA1r_STAD0f_GET
#define ESA1r_STAD0f_SET BCM56218_A0_ESA1r_STAD0f_SET
#define READ_ESA1r BCM56218_A0_READ_ESA1r
#define WRITE_ESA1r BCM56218_A0_WRITE_ESA1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_ESA1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  ESA2
 * BLOCKS:   GPORT0
 * DESC:     Station Adress[47:32]
 * SIZE:     32
 * FIELDS:
 *     STAD0            Station Address [47:32]
 *
 ******************************************************************************/
#define BCM56218_A0_ESA2r 0x00000212

#define BCM56218_A0_ESA2r_SIZE 4

/*
 * This structure should be used to declare and program ESA2.
 *
 */
typedef union BCM56218_A0_ESA2r_s {
	uint32_t v[1];
	uint32_t esa2[1];
	uint32_t _esa2;
} BCM56218_A0_ESA2r_t;

#define BCM56218_A0_ESA2r_CLR(r) (r).esa2[0] = 0
#define BCM56218_A0_ESA2r_SET(r,d) (r).esa2[0] = d
#define BCM56218_A0_ESA2r_GET(r) (r).esa2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_ESA2r_STAD0f_GET(r) (((r).esa2[0]) & 0xffff)
#define BCM56218_A0_ESA2r_STAD0f_SET(r,f) (r).esa2[0]=(((r).esa2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access ESA2.
 *
 */
#define BCM56218_A0_READ_ESA2r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_ESA2r,(r._esa2))
#define BCM56218_A0_WRITE_ESA2r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_ESA2r,&(r._esa2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ESA2r BCM56218_A0_ESA2r
#define ESA2r_SIZE BCM56218_A0_ESA2r_SIZE
typedef BCM56218_A0_ESA2r_t ESA2r_t;
#define ESA2r_CLR BCM56218_A0_ESA2r_CLR
#define ESA2r_SET BCM56218_A0_ESA2r_SET
#define ESA2r_GET BCM56218_A0_ESA2r_GET
#define ESA2r_STAD0f_GET BCM56218_A0_ESA2r_STAD0f_GET
#define ESA2r_STAD0f_SET BCM56218_A0_ESA2r_STAD0f_SET
#define READ_ESA2r BCM56218_A0_READ_ESA2r
#define WRITE_ESA2r BCM56218_A0_WRITE_ESA2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_ESA2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  FE_CLRT
 * BLOCKS:   GPORT0
 * DESC:     Fast Ethernet Collision Window/Retry Register.
 * SIZE:     32
 * FIELDS:
 *     RETRY            Number of retransmit attempts before aborting due to excessive collisions 
 *     COL_WIN          Slot time or collision window during which collisions occur
 *
 ******************************************************************************/
#define BCM56218_A0_FE_CLRTr 0x00000204

#define BCM56218_A0_FE_CLRTr_SIZE 4

/*
 * This structure should be used to declare and program FE_CLRT.
 *
 */
typedef union BCM56218_A0_FE_CLRTr_s {
	uint32_t v[1];
	uint32_t fe_clrt[1];
	uint32_t _fe_clrt;
} BCM56218_A0_FE_CLRTr_t;

#define BCM56218_A0_FE_CLRTr_CLR(r) (r).fe_clrt[0] = 0
#define BCM56218_A0_FE_CLRTr_SET(r,d) (r).fe_clrt[0] = d
#define BCM56218_A0_FE_CLRTr_GET(r) (r).fe_clrt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_FE_CLRTr_RETRYf_GET(r) (((r).fe_clrt[0]) & 0xf)
#define BCM56218_A0_FE_CLRTr_RETRYf_SET(r,f) (r).fe_clrt[0]=(((r).fe_clrt[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56218_A0_FE_CLRTr_COL_WINf_GET(r) ((((r).fe_clrt[0]) >> 8) & 0x3f)
#define BCM56218_A0_FE_CLRTr_COL_WINf_SET(r,f) (r).fe_clrt[0]=(((r).fe_clrt[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))

/*
 * These macros can be used to access FE_CLRT.
 *
 */
#define BCM56218_A0_READ_FE_CLRTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_FE_CLRTr,(r._fe_clrt))
#define BCM56218_A0_WRITE_FE_CLRTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_FE_CLRTr,&(r._fe_clrt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FE_CLRTr BCM56218_A0_FE_CLRTr
#define FE_CLRTr_SIZE BCM56218_A0_FE_CLRTr_SIZE
typedef BCM56218_A0_FE_CLRTr_t FE_CLRTr_t;
#define FE_CLRTr_CLR BCM56218_A0_FE_CLRTr_CLR
#define FE_CLRTr_SET BCM56218_A0_FE_CLRTr_SET
#define FE_CLRTr_GET BCM56218_A0_FE_CLRTr_GET
#define FE_CLRTr_RETRYf_GET BCM56218_A0_FE_CLRTr_RETRYf_GET
#define FE_CLRTr_RETRYf_SET BCM56218_A0_FE_CLRTr_RETRYf_SET
#define FE_CLRTr_COL_WINf_GET BCM56218_A0_FE_CLRTr_COL_WINf_GET
#define FE_CLRTr_COL_WINf_SET BCM56218_A0_FE_CLRTr_COL_WINf_SET
#define READ_FE_CLRTr BCM56218_A0_READ_FE_CLRTr
#define WRITE_FE_CLRTr BCM56218_A0_WRITE_FE_CLRTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_FE_CLRTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  FE_EXCESSIVE_DEFER_LIMIT
 * BLOCKS:   GPORT0
 * DESC:     Fast Ethernet Excessive Deferral Limit Register
 * SIZE:     32
 * FIELDS:
 *     LIMIT            Excessive Deferral Limit Value (programmed to (4*MAX_FRAME-1)If FE_SUPP.BIT_MODE is set to 1'b1, then this register should be programmed to 16*(MAX_FRAME)-1
 *
 ******************************************************************************/
#define BCM56218_A0_FE_EXCESSIVE_DEFER_LIMITr 0x0000020f

#define BCM56218_A0_FE_EXCESSIVE_DEFER_LIMITr_SIZE 4

/*
 * This structure should be used to declare and program FE_EXCESSIVE_DEFER_LIMIT.
 *
 */
typedef union BCM56218_A0_FE_EXCESSIVE_DEFER_LIMITr_s {
	uint32_t v[1];
	uint32_t fe_excessive_defer_limit[1];
	uint32_t _fe_excessive_defer_limit;
} BCM56218_A0_FE_EXCESSIVE_DEFER_LIMITr_t;

#define BCM56218_A0_FE_EXCESSIVE_DEFER_LIMITr_CLR(r) (r).fe_excessive_defer_limit[0] = 0
#define BCM56218_A0_FE_EXCESSIVE_DEFER_LIMITr_SET(r,d) (r).fe_excessive_defer_limit[0] = d
#define BCM56218_A0_FE_EXCESSIVE_DEFER_LIMITr_GET(r) (r).fe_excessive_defer_limit[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_FE_EXCESSIVE_DEFER_LIMITr_LIMITf_GET(r) (((r).fe_excessive_defer_limit[0]) & 0xffff)
#define BCM56218_A0_FE_EXCESSIVE_DEFER_LIMITr_LIMITf_SET(r,f) (r).fe_excessive_defer_limit[0]=(((r).fe_excessive_defer_limit[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access FE_EXCESSIVE_DEFER_LIMIT.
 *
 */
#define BCM56218_A0_READ_FE_EXCESSIVE_DEFER_LIMITr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_FE_EXCESSIVE_DEFER_LIMITr,(r._fe_excessive_defer_limit))
#define BCM56218_A0_WRITE_FE_EXCESSIVE_DEFER_LIMITr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_FE_EXCESSIVE_DEFER_LIMITr,&(r._fe_excessive_defer_limit))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FE_EXCESSIVE_DEFER_LIMITr BCM56218_A0_FE_EXCESSIVE_DEFER_LIMITr
#define FE_EXCESSIVE_DEFER_LIMITr_SIZE BCM56218_A0_FE_EXCESSIVE_DEFER_LIMITr_SIZE
typedef BCM56218_A0_FE_EXCESSIVE_DEFER_LIMITr_t FE_EXCESSIVE_DEFER_LIMITr_t;
#define FE_EXCESSIVE_DEFER_LIMITr_CLR BCM56218_A0_FE_EXCESSIVE_DEFER_LIMITr_CLR
#define FE_EXCESSIVE_DEFER_LIMITr_SET BCM56218_A0_FE_EXCESSIVE_DEFER_LIMITr_SET
#define FE_EXCESSIVE_DEFER_LIMITr_GET BCM56218_A0_FE_EXCESSIVE_DEFER_LIMITr_GET
#define FE_EXCESSIVE_DEFER_LIMITr_LIMITf_GET BCM56218_A0_FE_EXCESSIVE_DEFER_LIMITr_LIMITf_GET
#define FE_EXCESSIVE_DEFER_LIMITr_LIMITf_SET BCM56218_A0_FE_EXCESSIVE_DEFER_LIMITr_LIMITf_SET
#define READ_FE_EXCESSIVE_DEFER_LIMITr BCM56218_A0_READ_FE_EXCESSIVE_DEFER_LIMITr
#define WRITE_FE_EXCESSIVE_DEFER_LIMITr BCM56218_A0_WRITE_FE_EXCESSIVE_DEFER_LIMITr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_FE_EXCESSIVE_DEFER_LIMITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  FE_IPGR
 * BLOCKS:   GPORT0
 * DESC:     Fast Ethernet IPGR Register for non back to back transmit.
 * SIZE:     32
 * FIELDS:
 *     IPGR2            IPG Part 2 for non-back to back transmit
 *     IPGR1            IPG Part 1 for non-back to back transmit
 *
 ******************************************************************************/
#define BCM56218_A0_FE_IPGRr 0x00000203

#define BCM56218_A0_FE_IPGRr_SIZE 4

/*
 * This structure should be used to declare and program FE_IPGR.
 *
 */
typedef union BCM56218_A0_FE_IPGRr_s {
	uint32_t v[1];
	uint32_t fe_ipgr[1];
	uint32_t _fe_ipgr;
} BCM56218_A0_FE_IPGRr_t;

#define BCM56218_A0_FE_IPGRr_CLR(r) (r).fe_ipgr[0] = 0
#define BCM56218_A0_FE_IPGRr_SET(r,d) (r).fe_ipgr[0] = d
#define BCM56218_A0_FE_IPGRr_GET(r) (r).fe_ipgr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_FE_IPGRr_IPGR2f_GET(r) (((r).fe_ipgr[0]) & 0x7f)
#define BCM56218_A0_FE_IPGRr_IPGR2f_SET(r,f) (r).fe_ipgr[0]=(((r).fe_ipgr[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f))
#define BCM56218_A0_FE_IPGRr_IPGR1f_GET(r) ((((r).fe_ipgr[0]) >> 8) & 0x7f)
#define BCM56218_A0_FE_IPGRr_IPGR1f_SET(r,f) (r).fe_ipgr[0]=(((r).fe_ipgr[0] & ~((uint32_t)0x7f << 8)) | ((((uint32_t)f) & 0x7f) << 8))

/*
 * These macros can be used to access FE_IPGR.
 *
 */
#define BCM56218_A0_READ_FE_IPGRr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_FE_IPGRr,(r._fe_ipgr))
#define BCM56218_A0_WRITE_FE_IPGRr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_FE_IPGRr,&(r._fe_ipgr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FE_IPGRr BCM56218_A0_FE_IPGRr
#define FE_IPGRr_SIZE BCM56218_A0_FE_IPGRr_SIZE
typedef BCM56218_A0_FE_IPGRr_t FE_IPGRr_t;
#define FE_IPGRr_CLR BCM56218_A0_FE_IPGRr_CLR
#define FE_IPGRr_SET BCM56218_A0_FE_IPGRr_SET
#define FE_IPGRr_GET BCM56218_A0_FE_IPGRr_GET
#define FE_IPGRr_IPGR2f_GET BCM56218_A0_FE_IPGRr_IPGR2f_GET
#define FE_IPGRr_IPGR2f_SET BCM56218_A0_FE_IPGRr_IPGR2f_SET
#define FE_IPGRr_IPGR1f_GET BCM56218_A0_FE_IPGRr_IPGR1f_GET
#define FE_IPGRr_IPGR1f_SET BCM56218_A0_FE_IPGRr_IPGR1f_SET
#define READ_FE_IPGRr BCM56218_A0_READ_FE_IPGRr
#define WRITE_FE_IPGRr BCM56218_A0_WRITE_FE_IPGRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_FE_IPGRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  FE_IPGT
 * BLOCKS:   GPORT0
 * DESC:     Fast Ethernet IPGT Register for back to back transmit.
 * SIZE:     32
 * FIELDS:
 *     IPGT             IPG between back to back transmit packets in units of bytes
 *
 ******************************************************************************/
#define BCM56218_A0_FE_IPGTr 0x00000202

#define BCM56218_A0_FE_IPGTr_SIZE 4

/*
 * This structure should be used to declare and program FE_IPGT.
 *
 */
typedef union BCM56218_A0_FE_IPGTr_s {
	uint32_t v[1];
	uint32_t fe_ipgt[1];
	uint32_t _fe_ipgt;
} BCM56218_A0_FE_IPGTr_t;

#define BCM56218_A0_FE_IPGTr_CLR(r) (r).fe_ipgt[0] = 0
#define BCM56218_A0_FE_IPGTr_SET(r,d) (r).fe_ipgt[0] = d
#define BCM56218_A0_FE_IPGTr_GET(r) (r).fe_ipgt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_FE_IPGTr_IPGTf_GET(r) (((r).fe_ipgt[0]) & 0x7f)
#define BCM56218_A0_FE_IPGTr_IPGTf_SET(r,f) (r).fe_ipgt[0]=(((r).fe_ipgt[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f))

/*
 * These macros can be used to access FE_IPGT.
 *
 */
#define BCM56218_A0_READ_FE_IPGTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_FE_IPGTr,(r._fe_ipgt))
#define BCM56218_A0_WRITE_FE_IPGTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_FE_IPGTr,&(r._fe_ipgt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FE_IPGTr BCM56218_A0_FE_IPGTr
#define FE_IPGTr_SIZE BCM56218_A0_FE_IPGTr_SIZE
typedef BCM56218_A0_FE_IPGTr_t FE_IPGTr_t;
#define FE_IPGTr_CLR BCM56218_A0_FE_IPGTr_CLR
#define FE_IPGTr_SET BCM56218_A0_FE_IPGTr_SET
#define FE_IPGTr_GET BCM56218_A0_FE_IPGTr_GET
#define FE_IPGTr_IPGTf_GET BCM56218_A0_FE_IPGTr_IPGTf_GET
#define FE_IPGTr_IPGTf_SET BCM56218_A0_FE_IPGTr_IPGTf_SET
#define READ_FE_IPGTr BCM56218_A0_READ_FE_IPGTr
#define WRITE_FE_IPGTr BCM56218_A0_WRITE_FE_IPGTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_FE_IPGTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  FE_MAC1
 * BLOCKS:   GPORT0
 * DESC:     Fast Ethernet MAC Configuration 1 Register.
 * SIZE:     32
 * FIELDS:
 *     RX_EN            RX Enable
 *     PASSALL          Pass All Rx Frames
 *     RX_PAU           RX Flow control
 *     TX_PAU           TX Flow control
 *     LBACK            Loopback
 *     HRTFN            reset for transmit blocks
 *     HRRFN            reset for receive blocks
 *     R_EXTEND_RANDOM_NUMBER_GENERATOR If 0, randon number generator in FE mac is unchanged.  If 1, random number generator in mac is extended to 23 bits with a new polynomial
 *     R_RNG_GATE       Disable (0) or enable (1) inclusion of state bits into random number generator in FE mac.
 *     RST_SIM          Reset Simulation
 *     SRST             Soft reset (Not used, control from GMACC0)
 *
 ******************************************************************************/
#define BCM56218_A0_FE_MAC1r 0x00000200

#define BCM56218_A0_FE_MAC1r_SIZE 4

/*
 * This structure should be used to declare and program FE_MAC1.
 *
 */
typedef union BCM56218_A0_FE_MAC1r_s {
	uint32_t v[1];
	uint32_t fe_mac1[1];
	uint32_t _fe_mac1;
} BCM56218_A0_FE_MAC1r_t;

#define BCM56218_A0_FE_MAC1r_CLR(r) (r).fe_mac1[0] = 0
#define BCM56218_A0_FE_MAC1r_SET(r,d) (r).fe_mac1[0] = d
#define BCM56218_A0_FE_MAC1r_GET(r) (r).fe_mac1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_FE_MAC1r_RX_ENf_GET(r) (((r).fe_mac1[0]) & 0x1)
#define BCM56218_A0_FE_MAC1r_RX_ENf_SET(r,f) (r).fe_mac1[0]=(((r).fe_mac1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_FE_MAC1r_PASSALLf_GET(r) ((((r).fe_mac1[0]) >> 1) & 0x1)
#define BCM56218_A0_FE_MAC1r_PASSALLf_SET(r,f) (r).fe_mac1[0]=(((r).fe_mac1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_FE_MAC1r_RX_PAUf_GET(r) ((((r).fe_mac1[0]) >> 2) & 0x1)
#define BCM56218_A0_FE_MAC1r_RX_PAUf_SET(r,f) (r).fe_mac1[0]=(((r).fe_mac1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_FE_MAC1r_TX_PAUf_GET(r) ((((r).fe_mac1[0]) >> 3) & 0x1)
#define BCM56218_A0_FE_MAC1r_TX_PAUf_SET(r,f) (r).fe_mac1[0]=(((r).fe_mac1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56218_A0_FE_MAC1r_LBACKf_GET(r) ((((r).fe_mac1[0]) >> 4) & 0x1)
#define BCM56218_A0_FE_MAC1r_LBACKf_SET(r,f) (r).fe_mac1[0]=(((r).fe_mac1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56218_A0_FE_MAC1r_HRTFNf_GET(r) ((((r).fe_mac1[0]) >> 8) & 0x1)
#define BCM56218_A0_FE_MAC1r_HRTFNf_SET(r,f) (r).fe_mac1[0]=(((r).fe_mac1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56218_A0_FE_MAC1r_HRRFNf_GET(r) ((((r).fe_mac1[0]) >> 10) & 0x1)
#define BCM56218_A0_FE_MAC1r_HRRFNf_SET(r,f) (r).fe_mac1[0]=(((r).fe_mac1[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56218_A0_FE_MAC1r_R_EXTEND_RANDOM_NUMBER_GENERATORf_GET(r) ((((r).fe_mac1[0]) >> 12) & 0x1)
#define BCM56218_A0_FE_MAC1r_R_EXTEND_RANDOM_NUMBER_GENERATORf_SET(r,f) (r).fe_mac1[0]=(((r).fe_mac1[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM56218_A0_FE_MAC1r_R_RNG_GATEf_GET(r) ((((r).fe_mac1[0]) >> 13) & 0x1)
#define BCM56218_A0_FE_MAC1r_R_RNG_GATEf_SET(r,f) (r).fe_mac1[0]=(((r).fe_mac1[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56218_A0_FE_MAC1r_RST_SIMf_GET(r) ((((r).fe_mac1[0]) >> 14) & 0x1)
#define BCM56218_A0_FE_MAC1r_RST_SIMf_SET(r,f) (r).fe_mac1[0]=(((r).fe_mac1[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM56218_A0_FE_MAC1r_SRSTf_GET(r) ((((r).fe_mac1[0]) >> 15) & 0x1)
#define BCM56218_A0_FE_MAC1r_SRSTf_SET(r,f) (r).fe_mac1[0]=(((r).fe_mac1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access FE_MAC1.
 *
 */
#define BCM56218_A0_READ_FE_MAC1r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_FE_MAC1r,(r._fe_mac1))
#define BCM56218_A0_WRITE_FE_MAC1r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_FE_MAC1r,&(r._fe_mac1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FE_MAC1r BCM56218_A0_FE_MAC1r
#define FE_MAC1r_SIZE BCM56218_A0_FE_MAC1r_SIZE
typedef BCM56218_A0_FE_MAC1r_t FE_MAC1r_t;
#define FE_MAC1r_CLR BCM56218_A0_FE_MAC1r_CLR
#define FE_MAC1r_SET BCM56218_A0_FE_MAC1r_SET
#define FE_MAC1r_GET BCM56218_A0_FE_MAC1r_GET
#define FE_MAC1r_RX_ENf_GET BCM56218_A0_FE_MAC1r_RX_ENf_GET
#define FE_MAC1r_RX_ENf_SET BCM56218_A0_FE_MAC1r_RX_ENf_SET
#define FE_MAC1r_PASSALLf_GET BCM56218_A0_FE_MAC1r_PASSALLf_GET
#define FE_MAC1r_PASSALLf_SET BCM56218_A0_FE_MAC1r_PASSALLf_SET
#define FE_MAC1r_RX_PAUf_GET BCM56218_A0_FE_MAC1r_RX_PAUf_GET
#define FE_MAC1r_RX_PAUf_SET BCM56218_A0_FE_MAC1r_RX_PAUf_SET
#define FE_MAC1r_TX_PAUf_GET BCM56218_A0_FE_MAC1r_TX_PAUf_GET
#define FE_MAC1r_TX_PAUf_SET BCM56218_A0_FE_MAC1r_TX_PAUf_SET
#define FE_MAC1r_LBACKf_GET BCM56218_A0_FE_MAC1r_LBACKf_GET
#define FE_MAC1r_LBACKf_SET BCM56218_A0_FE_MAC1r_LBACKf_SET
#define FE_MAC1r_HRTFNf_GET BCM56218_A0_FE_MAC1r_HRTFNf_GET
#define FE_MAC1r_HRTFNf_SET BCM56218_A0_FE_MAC1r_HRTFNf_SET
#define FE_MAC1r_HRRFNf_GET BCM56218_A0_FE_MAC1r_HRRFNf_GET
#define FE_MAC1r_HRRFNf_SET BCM56218_A0_FE_MAC1r_HRRFNf_SET
#define FE_MAC1r_R_EXTEND_RANDOM_NUMBER_GENERATORf_GET BCM56218_A0_FE_MAC1r_R_EXTEND_RANDOM_NUMBER_GENERATORf_GET
#define FE_MAC1r_R_EXTEND_RANDOM_NUMBER_GENERATORf_SET BCM56218_A0_FE_MAC1r_R_EXTEND_RANDOM_NUMBER_GENERATORf_SET
#define FE_MAC1r_R_RNG_GATEf_GET BCM56218_A0_FE_MAC1r_R_RNG_GATEf_GET
#define FE_MAC1r_R_RNG_GATEf_SET BCM56218_A0_FE_MAC1r_R_RNG_GATEf_SET
#define FE_MAC1r_RST_SIMf_GET BCM56218_A0_FE_MAC1r_RST_SIMf_GET
#define FE_MAC1r_RST_SIMf_SET BCM56218_A0_FE_MAC1r_RST_SIMf_SET
#define FE_MAC1r_SRSTf_GET BCM56218_A0_FE_MAC1r_SRSTf_GET
#define FE_MAC1r_SRSTf_SET BCM56218_A0_FE_MAC1r_SRSTf_SET
#define READ_FE_MAC1r BCM56218_A0_READ_FE_MAC1r
#define WRITE_FE_MAC1r BCM56218_A0_WRITE_FE_MAC1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_FE_MAC1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  FE_MAC2
 * BLOCKS:   GPORT0
 * DESC:     Fast Ethernet MAC Configuration 2 Register.
 * SIZE:     32
 * FIELDS:
 *     FULL_DUP         Full Duplex Operation 0 = Enable Half Duplex 1 = Enable Full Duplex operation
 *     LG_CHK           Frame Length Checking 0 = Do not perform Frame Length checking 1 = Perform Frame Length checking if length/type field indicates one and report mismatches on xmit/recv statistics vector 
 *     HUGE_FR          Huge Frame Enable 0 = Huge frames are neither transmitted nor received 1 = Huge frames of any length are both transmitted and received
 *     DEL_CRC          Delayed CRC - determines the number of bytes of proprietary header information on the front of IEEE802.3 frames 0 = No proprietary header 1 = 4 bytes of proprietary header (ignored by CRC function)
 *     CRC_EN           Append CRC to frames 0 = Do not append CRC. Frame presented to MAC contains a CRC 1 = Append CRC to every frame, irrespective of padding requirement
 *     PAD_EN           Pad and add CRC to all short frames using bit setting of VLAN_PAD and AUTO_PAD 
 *     VLAN_PAD         Pad all short frames to 64 bytes and append a valid CRC
 *     AUTO_PAD         Automatic Detection of tagged and un-tagged frames and padding is performed accordingly 
 *     PURE_PAD         Pure Preamble Enforcement 0 = No preamble checking is performed 1 = Verify preamble contains 0x55 and is error free. Otherwise, discard the packet 
 *     LONG_PRE         Long Preamble Enforcement 0 = Receive packets with any length preamble per standard 1 = Receive packets with preamble fields less than 12 bytes in length 
 *     NO_BOFF          Backoff after collision. 0 = Use Binary exponential backoff algorithm 1 = Retransmit immediately
 *     BP_NO_BOFF       Back Pressure Backoff after collision. 0 = Use Binary exponential backoff algorithm 1 = Retransmit immediately
 *     EXC_DEF          Deferral to carrier. 0 = Abort when excessive deferral limit is reached and provide feedback to the host system 1 = Defer to carrier indefinitely as per standard
 *
 ******************************************************************************/
#define BCM56218_A0_FE_MAC2r 0x00000201

#define BCM56218_A0_FE_MAC2r_SIZE 4

/*
 * This structure should be used to declare and program FE_MAC2.
 *
 */
typedef union BCM56218_A0_FE_MAC2r_s {
	uint32_t v[1];
	uint32_t fe_mac2[1];
	uint32_t _fe_mac2;
} BCM56218_A0_FE_MAC2r_t;

#define BCM56218_A0_FE_MAC2r_CLR(r) (r).fe_mac2[0] = 0
#define BCM56218_A0_FE_MAC2r_SET(r,d) (r).fe_mac2[0] = d
#define BCM56218_A0_FE_MAC2r_GET(r) (r).fe_mac2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_FE_MAC2r_FULL_DUPf_GET(r) (((r).fe_mac2[0]) & 0x1)
#define BCM56218_A0_FE_MAC2r_FULL_DUPf_SET(r,f) (r).fe_mac2[0]=(((r).fe_mac2[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_FE_MAC2r_LG_CHKf_GET(r) ((((r).fe_mac2[0]) >> 1) & 0x1)
#define BCM56218_A0_FE_MAC2r_LG_CHKf_SET(r,f) (r).fe_mac2[0]=(((r).fe_mac2[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_FE_MAC2r_HUGE_FRf_GET(r) ((((r).fe_mac2[0]) >> 2) & 0x1)
#define BCM56218_A0_FE_MAC2r_HUGE_FRf_SET(r,f) (r).fe_mac2[0]=(((r).fe_mac2[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_FE_MAC2r_DEL_CRCf_GET(r) ((((r).fe_mac2[0]) >> 3) & 0x1)
#define BCM56218_A0_FE_MAC2r_DEL_CRCf_SET(r,f) (r).fe_mac2[0]=(((r).fe_mac2[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56218_A0_FE_MAC2r_CRC_ENf_GET(r) ((((r).fe_mac2[0]) >> 4) & 0x1)
#define BCM56218_A0_FE_MAC2r_CRC_ENf_SET(r,f) (r).fe_mac2[0]=(((r).fe_mac2[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56218_A0_FE_MAC2r_PAD_ENf_GET(r) ((((r).fe_mac2[0]) >> 5) & 0x1)
#define BCM56218_A0_FE_MAC2r_PAD_ENf_SET(r,f) (r).fe_mac2[0]=(((r).fe_mac2[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56218_A0_FE_MAC2r_VLAN_PADf_GET(r) ((((r).fe_mac2[0]) >> 6) & 0x1)
#define BCM56218_A0_FE_MAC2r_VLAN_PADf_SET(r,f) (r).fe_mac2[0]=(((r).fe_mac2[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56218_A0_FE_MAC2r_AUTO_PADf_GET(r) ((((r).fe_mac2[0]) >> 7) & 0x1)
#define BCM56218_A0_FE_MAC2r_AUTO_PADf_SET(r,f) (r).fe_mac2[0]=(((r).fe_mac2[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56218_A0_FE_MAC2r_PURE_PADf_GET(r) ((((r).fe_mac2[0]) >> 8) & 0x1)
#define BCM56218_A0_FE_MAC2r_PURE_PADf_SET(r,f) (r).fe_mac2[0]=(((r).fe_mac2[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56218_A0_FE_MAC2r_LONG_PREf_GET(r) ((((r).fe_mac2[0]) >> 9) & 0x1)
#define BCM56218_A0_FE_MAC2r_LONG_PREf_SET(r,f) (r).fe_mac2[0]=(((r).fe_mac2[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56218_A0_FE_MAC2r_NO_BOFFf_GET(r) ((((r).fe_mac2[0]) >> 12) & 0x1)
#define BCM56218_A0_FE_MAC2r_NO_BOFFf_SET(r,f) (r).fe_mac2[0]=(((r).fe_mac2[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM56218_A0_FE_MAC2r_BP_NO_BOFFf_GET(r) ((((r).fe_mac2[0]) >> 13) & 0x1)
#define BCM56218_A0_FE_MAC2r_BP_NO_BOFFf_SET(r,f) (r).fe_mac2[0]=(((r).fe_mac2[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56218_A0_FE_MAC2r_EXC_DEFf_GET(r) ((((r).fe_mac2[0]) >> 14) & 0x1)
#define BCM56218_A0_FE_MAC2r_EXC_DEFf_SET(r,f) (r).fe_mac2[0]=(((r).fe_mac2[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))

/*
 * These macros can be used to access FE_MAC2.
 *
 */
#define BCM56218_A0_READ_FE_MAC2r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_FE_MAC2r,(r._fe_mac2))
#define BCM56218_A0_WRITE_FE_MAC2r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_FE_MAC2r,&(r._fe_mac2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FE_MAC2r BCM56218_A0_FE_MAC2r
#define FE_MAC2r_SIZE BCM56218_A0_FE_MAC2r_SIZE
typedef BCM56218_A0_FE_MAC2r_t FE_MAC2r_t;
#define FE_MAC2r_CLR BCM56218_A0_FE_MAC2r_CLR
#define FE_MAC2r_SET BCM56218_A0_FE_MAC2r_SET
#define FE_MAC2r_GET BCM56218_A0_FE_MAC2r_GET
#define FE_MAC2r_FULL_DUPf_GET BCM56218_A0_FE_MAC2r_FULL_DUPf_GET
#define FE_MAC2r_FULL_DUPf_SET BCM56218_A0_FE_MAC2r_FULL_DUPf_SET
#define FE_MAC2r_LG_CHKf_GET BCM56218_A0_FE_MAC2r_LG_CHKf_GET
#define FE_MAC2r_LG_CHKf_SET BCM56218_A0_FE_MAC2r_LG_CHKf_SET
#define FE_MAC2r_HUGE_FRf_GET BCM56218_A0_FE_MAC2r_HUGE_FRf_GET
#define FE_MAC2r_HUGE_FRf_SET BCM56218_A0_FE_MAC2r_HUGE_FRf_SET
#define FE_MAC2r_DEL_CRCf_GET BCM56218_A0_FE_MAC2r_DEL_CRCf_GET
#define FE_MAC2r_DEL_CRCf_SET BCM56218_A0_FE_MAC2r_DEL_CRCf_SET
#define FE_MAC2r_CRC_ENf_GET BCM56218_A0_FE_MAC2r_CRC_ENf_GET
#define FE_MAC2r_CRC_ENf_SET BCM56218_A0_FE_MAC2r_CRC_ENf_SET
#define FE_MAC2r_PAD_ENf_GET BCM56218_A0_FE_MAC2r_PAD_ENf_GET
#define FE_MAC2r_PAD_ENf_SET BCM56218_A0_FE_MAC2r_PAD_ENf_SET
#define FE_MAC2r_VLAN_PADf_GET BCM56218_A0_FE_MAC2r_VLAN_PADf_GET
#define FE_MAC2r_VLAN_PADf_SET BCM56218_A0_FE_MAC2r_VLAN_PADf_SET
#define FE_MAC2r_AUTO_PADf_GET BCM56218_A0_FE_MAC2r_AUTO_PADf_GET
#define FE_MAC2r_AUTO_PADf_SET BCM56218_A0_FE_MAC2r_AUTO_PADf_SET
#define FE_MAC2r_PURE_PADf_GET BCM56218_A0_FE_MAC2r_PURE_PADf_GET
#define FE_MAC2r_PURE_PADf_SET BCM56218_A0_FE_MAC2r_PURE_PADf_SET
#define FE_MAC2r_LONG_PREf_GET BCM56218_A0_FE_MAC2r_LONG_PREf_GET
#define FE_MAC2r_LONG_PREf_SET BCM56218_A0_FE_MAC2r_LONG_PREf_SET
#define FE_MAC2r_NO_BOFFf_GET BCM56218_A0_FE_MAC2r_NO_BOFFf_GET
#define FE_MAC2r_NO_BOFFf_SET BCM56218_A0_FE_MAC2r_NO_BOFFf_SET
#define FE_MAC2r_BP_NO_BOFFf_GET BCM56218_A0_FE_MAC2r_BP_NO_BOFFf_GET
#define FE_MAC2r_BP_NO_BOFFf_SET BCM56218_A0_FE_MAC2r_BP_NO_BOFFf_SET
#define FE_MAC2r_EXC_DEFf_GET BCM56218_A0_FE_MAC2r_EXC_DEFf_GET
#define FE_MAC2r_EXC_DEFf_SET BCM56218_A0_FE_MAC2r_EXC_DEFf_SET
#define READ_FE_MAC2r BCM56218_A0_READ_FE_MAC2r
#define WRITE_FE_MAC2r BCM56218_A0_WRITE_FE_MAC2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_FE_MAC2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  FE_MAXF
 * BLOCKS:   GPORT0
 * DESC:     Fast Ethernet Maximum Frame Length Register.
 * SIZE:     32
 * FIELDS:
 *     MAXFR            Maximum frame length in bytes (default to 1518 Decimal). Note, the actual Maximum Frame Length can be accepted by the system is MAXFR - 1.
 *
 ******************************************************************************/
#define BCM56218_A0_FE_MAXFr 0x00000205

#define BCM56218_A0_FE_MAXFr_SIZE 4

/*
 * This structure should be used to declare and program FE_MAXF.
 *
 */
typedef union BCM56218_A0_FE_MAXFr_s {
	uint32_t v[1];
	uint32_t fe_maxf[1];
	uint32_t _fe_maxf;
} BCM56218_A0_FE_MAXFr_t;

#define BCM56218_A0_FE_MAXFr_CLR(r) (r).fe_maxf[0] = 0
#define BCM56218_A0_FE_MAXFr_SET(r,d) (r).fe_maxf[0] = d
#define BCM56218_A0_FE_MAXFr_GET(r) (r).fe_maxf[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_FE_MAXFr_MAXFRf_GET(r) (((r).fe_maxf[0]) & 0xffff)
#define BCM56218_A0_FE_MAXFr_MAXFRf_SET(r,f) (r).fe_maxf[0]=(((r).fe_maxf[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access FE_MAXF.
 *
 */
#define BCM56218_A0_READ_FE_MAXFr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_FE_MAXFr,(r._fe_maxf))
#define BCM56218_A0_WRITE_FE_MAXFr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_FE_MAXFr,&(r._fe_maxf))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FE_MAXFr BCM56218_A0_FE_MAXFr
#define FE_MAXFr_SIZE BCM56218_A0_FE_MAXFr_SIZE
typedef BCM56218_A0_FE_MAXFr_t FE_MAXFr_t;
#define FE_MAXFr_CLR BCM56218_A0_FE_MAXFr_CLR
#define FE_MAXFr_SET BCM56218_A0_FE_MAXFr_SET
#define FE_MAXFr_GET BCM56218_A0_FE_MAXFr_GET
#define FE_MAXFr_MAXFRf_GET BCM56218_A0_FE_MAXFr_MAXFRf_GET
#define FE_MAXFr_MAXFRf_SET BCM56218_A0_FE_MAXFr_MAXFRf_SET
#define READ_FE_MAXFr BCM56218_A0_READ_FE_MAXFr
#define WRITE_FE_MAXFr BCM56218_A0_WRITE_FE_MAXFr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_FE_MAXFr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  FE_SUPP
 * BLOCKS:   GPORT0
 * DESC:     Fast Ethernet Support Register.
 * SIZE:     32
 * FIELDS:
 *     BIT_MODE         ENDEC Mode where clock is the bit clock 0 = Disable ENDEC mode 1 = Enable ENDEC mode
 *     SPEED            Operating speed of the RMII 0 = 10Mb/sec mode 1 = 100Mb/sec mode
 *     PHYMOD           This bit controls whether the MAC is in MAC-to-MAC (0), or MAC-to-PHY (1) mode
 *
 ******************************************************************************/
#define BCM56218_A0_FE_SUPPr 0x00000206

#define BCM56218_A0_FE_SUPPr_SIZE 4

/*
 * This structure should be used to declare and program FE_SUPP.
 *
 */
typedef union BCM56218_A0_FE_SUPPr_s {
	uint32_t v[1];
	uint32_t fe_supp[1];
	uint32_t _fe_supp;
} BCM56218_A0_FE_SUPPr_t;

#define BCM56218_A0_FE_SUPPr_CLR(r) (r).fe_supp[0] = 0
#define BCM56218_A0_FE_SUPPr_SET(r,d) (r).fe_supp[0] = d
#define BCM56218_A0_FE_SUPPr_GET(r) (r).fe_supp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_FE_SUPPr_BIT_MODEf_GET(r) (((r).fe_supp[0]) & 0x1)
#define BCM56218_A0_FE_SUPPr_BIT_MODEf_SET(r,f) (r).fe_supp[0]=(((r).fe_supp[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_FE_SUPPr_SPEEDf_GET(r) ((((r).fe_supp[0]) >> 8) & 0x1)
#define BCM56218_A0_FE_SUPPr_SPEEDf_SET(r,f) (r).fe_supp[0]=(((r).fe_supp[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56218_A0_FE_SUPPr_PHYMODf_GET(r) ((((r).fe_supp[0]) >> 12) & 0x1)
#define BCM56218_A0_FE_SUPPr_PHYMODf_SET(r,f) (r).fe_supp[0]=(((r).fe_supp[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))

/*
 * These macros can be used to access FE_SUPP.
 *
 */
#define BCM56218_A0_READ_FE_SUPPr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_FE_SUPPr,(r._fe_supp))
#define BCM56218_A0_WRITE_FE_SUPPr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_FE_SUPPr,&(r._fe_supp))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FE_SUPPr BCM56218_A0_FE_SUPPr
#define FE_SUPPr_SIZE BCM56218_A0_FE_SUPPr_SIZE
typedef BCM56218_A0_FE_SUPPr_t FE_SUPPr_t;
#define FE_SUPPr_CLR BCM56218_A0_FE_SUPPr_CLR
#define FE_SUPPr_SET BCM56218_A0_FE_SUPPr_SET
#define FE_SUPPr_GET BCM56218_A0_FE_SUPPr_GET
#define FE_SUPPr_BIT_MODEf_GET BCM56218_A0_FE_SUPPr_BIT_MODEf_GET
#define FE_SUPPr_BIT_MODEf_SET BCM56218_A0_FE_SUPPr_BIT_MODEf_SET
#define FE_SUPPr_SPEEDf_GET BCM56218_A0_FE_SUPPr_SPEEDf_GET
#define FE_SUPPr_SPEEDf_SET BCM56218_A0_FE_SUPPr_SPEEDf_SET
#define FE_SUPPr_PHYMODf_GET BCM56218_A0_FE_SUPPr_PHYMODf_GET
#define FE_SUPPr_PHYMODf_SET BCM56218_A0_FE_SUPPr_PHYMODf_SET
#define READ_FE_SUPPr BCM56218_A0_READ_FE_SUPPr
#define WRITE_FE_SUPPr BCM56218_A0_WRITE_FE_SUPPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_FE_SUPPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  FE_TEST
 * BLOCKS:   GPORT0
 * DESC:     Fast Ethernet Test Register.
 * SIZE:     32
 * FIELDS:
 *     SHORT_QNTA       Shortcut Pause Quanta 0 = Do not configure ENDEC mode (clock is nibble clock) 1 = Configure ENDEC mode (clock is bit clock)
 *     TEST_PAUSE       Test Pause 0 = Do not reset RMII logic 1 = Reset RMII logic
 *     TEST_BACK        Test Back Pressure 0 = Do not assert backpressure 1 = Assert backpressure, causing preamble to be transmitted
 *
 ******************************************************************************/
#define BCM56218_A0_FE_TESTr 0x00000207

#define BCM56218_A0_FE_TESTr_SIZE 4

/*
 * This structure should be used to declare and program FE_TEST.
 *
 */
typedef union BCM56218_A0_FE_TESTr_s {
	uint32_t v[1];
	uint32_t fe_test[1];
	uint32_t _fe_test;
} BCM56218_A0_FE_TESTr_t;

#define BCM56218_A0_FE_TESTr_CLR(r) (r).fe_test[0] = 0
#define BCM56218_A0_FE_TESTr_SET(r,d) (r).fe_test[0] = d
#define BCM56218_A0_FE_TESTr_GET(r) (r).fe_test[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_FE_TESTr_SHORT_QNTAf_GET(r) (((r).fe_test[0]) & 0x1)
#define BCM56218_A0_FE_TESTr_SHORT_QNTAf_SET(r,f) (r).fe_test[0]=(((r).fe_test[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_FE_TESTr_TEST_PAUSEf_GET(r) ((((r).fe_test[0]) >> 1) & 0x1)
#define BCM56218_A0_FE_TESTr_TEST_PAUSEf_SET(r,f) (r).fe_test[0]=(((r).fe_test[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_FE_TESTr_TEST_BACKf_GET(r) ((((r).fe_test[0]) >> 2) & 0x1)
#define BCM56218_A0_FE_TESTr_TEST_BACKf_SET(r,f) (r).fe_test[0]=(((r).fe_test[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))

/*
 * These macros can be used to access FE_TEST.
 *
 */
#define BCM56218_A0_READ_FE_TESTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_FE_TESTr,(r._fe_test))
#define BCM56218_A0_WRITE_FE_TESTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_FE_TESTr,&(r._fe_test))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FE_TESTr BCM56218_A0_FE_TESTr
#define FE_TESTr_SIZE BCM56218_A0_FE_TESTr_SIZE
typedef BCM56218_A0_FE_TESTr_t FE_TESTr_t;
#define FE_TESTr_CLR BCM56218_A0_FE_TESTr_CLR
#define FE_TESTr_SET BCM56218_A0_FE_TESTr_SET
#define FE_TESTr_GET BCM56218_A0_FE_TESTr_GET
#define FE_TESTr_SHORT_QNTAf_GET BCM56218_A0_FE_TESTr_SHORT_QNTAf_GET
#define FE_TESTr_SHORT_QNTAf_SET BCM56218_A0_FE_TESTr_SHORT_QNTAf_SET
#define FE_TESTr_TEST_PAUSEf_GET BCM56218_A0_FE_TESTr_TEST_PAUSEf_GET
#define FE_TESTr_TEST_PAUSEf_SET BCM56218_A0_FE_TESTr_TEST_PAUSEf_SET
#define FE_TESTr_TEST_BACKf_GET BCM56218_A0_FE_TESTr_TEST_BACKf_GET
#define FE_TESTr_TEST_BACKf_SET BCM56218_A0_FE_TESTr_TEST_BACKf_SET
#define READ_FE_TESTr BCM56218_A0_READ_FE_TESTr
#define WRITE_FE_TESTr BCM56218_A0_WRITE_FE_TESTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_FE_TESTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  FP_CAM_BIST_ENABLE
 * BLOCKS:   IPIPE
 * DESC:     FP_CAM_BIST_ENABLE
 * SIZE:     32
 * FIELDS:
 *     FP_CAM_BIST_ENABLE_SLICE_0 FP_CAM_BIST_ENABLE FOR FP SLICE 0
 *     FP_CAM_BIST_ENABLE_SLICE_1 FP_CAM_BIST_ENABLE FOR FP SLICE 1
 *     FP_CAM_BIST_ENABLE_SLICE_2 FP_CAM_BIST_ENABLE FOR FP SLICE 2
 *     FP_CAM_BIST_ENABLE_SLICE_3 FP_CAM_BIST_ENABLE FOR FP SLICE 3
 *     FP_CAM_BIST_ENABLE_SLICE_4 FP_CAM_BIST_ENABLE FOR FP SLICE 4
 *     FP_CAM_BIST_ENABLE_SLICE_5 FP_CAM_BIST_ENABLE FOR FP SLICE 5
 *     FP_CAM_BIST_ENABLE_SLICE_6 FP_CAM_BIST_ENABLE FOR FP SLICE 6
 *     FP_CAM_BIST_ENABLE_SLICE_7 FP_CAM_BIST_ENABLE FOR FP SLICE 7
 *     FP_CAM_DEBUG_ENABLE_SLICE_0 FP_CAM_DEBUG_ENABLE FOR FP SLICE 0
 *     FP_CAM_DEBUG_ENABLE_SLICE_1 FP_CAM_DEBUG_ENABLE FOR FP SLICE 1
 *     FP_CAM_DEBUG_ENABLE_SLICE_2 FP_CAM_DEBUG_ENABLE FOR FP SLICE 2
 *     FP_CAM_DEBUG_ENABLE_SLICE_3 FP_CAM_DEBUG_ENABLE FOR FP SLICE 3
 *     FP_CAM_DEBUG_ENABLE_SLICE_4 FP_CAM_DEBUG_ENABLE FOR FP SLICE 4
 *     FP_CAM_DEBUG_ENABLE_SLICE_5 FP_CAM_DEBUG_ENABLE FOR FP SLICE 5
 *     FP_CAM_DEBUG_ENABLE_SLICE_6 FP_CAM_DEBUG_ENABLE FOR FP SLICE 6
 *     FP_CAM_DEBUG_ENABLE_SLICE_7 FP_CAM_DEBUG_ENABLE FOR FP SLICE 7
 *
 ******************************************************************************/
#define BCM56218_A0_FP_CAM_BIST_ENABLEr 0x0c78000a

#define BCM56218_A0_FP_CAM_BIST_ENABLEr_SIZE 4

/*
 * This structure should be used to declare and program FP_CAM_BIST_ENABLE.
 *
 */
typedef union BCM56218_A0_FP_CAM_BIST_ENABLEr_s {
	uint32_t v[1];
	uint32_t fp_cam_bist_enable[1];
	uint32_t _fp_cam_bist_enable;
} BCM56218_A0_FP_CAM_BIST_ENABLEr_t;

#define BCM56218_A0_FP_CAM_BIST_ENABLEr_CLR(r) (r).fp_cam_bist_enable[0] = 0
#define BCM56218_A0_FP_CAM_BIST_ENABLEr_SET(r,d) (r).fp_cam_bist_enable[0] = d
#define BCM56218_A0_FP_CAM_BIST_ENABLEr_GET(r) (r).fp_cam_bist_enable[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_0f_GET(r) (((r).fp_cam_bist_enable[0]) & 0x1)
#define BCM56218_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_0f_SET(r,f) (r).fp_cam_bist_enable[0]=(((r).fp_cam_bist_enable[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_1f_GET(r) ((((r).fp_cam_bist_enable[0]) >> 1) & 0x1)
#define BCM56218_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_1f_SET(r,f) (r).fp_cam_bist_enable[0]=(((r).fp_cam_bist_enable[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_2f_GET(r) ((((r).fp_cam_bist_enable[0]) >> 2) & 0x1)
#define BCM56218_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_2f_SET(r,f) (r).fp_cam_bist_enable[0]=(((r).fp_cam_bist_enable[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_3f_GET(r) ((((r).fp_cam_bist_enable[0]) >> 3) & 0x1)
#define BCM56218_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_3f_SET(r,f) (r).fp_cam_bist_enable[0]=(((r).fp_cam_bist_enable[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56218_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_4f_GET(r) ((((r).fp_cam_bist_enable[0]) >> 4) & 0x1)
#define BCM56218_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_4f_SET(r,f) (r).fp_cam_bist_enable[0]=(((r).fp_cam_bist_enable[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56218_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_5f_GET(r) ((((r).fp_cam_bist_enable[0]) >> 5) & 0x1)
#define BCM56218_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_5f_SET(r,f) (r).fp_cam_bist_enable[0]=(((r).fp_cam_bist_enable[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56218_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_6f_GET(r) ((((r).fp_cam_bist_enable[0]) >> 6) & 0x1)
#define BCM56218_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_6f_SET(r,f) (r).fp_cam_bist_enable[0]=(((r).fp_cam_bist_enable[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56218_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_7f_GET(r) ((((r).fp_cam_bist_enable[0]) >> 7) & 0x1)
#define BCM56218_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_7f_SET(r,f) (r).fp_cam_bist_enable[0]=(((r).fp_cam_bist_enable[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56218_A0_FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_0f_GET(r) ((((r).fp_cam_bist_enable[0]) >> 8) & 0x1)
#define BCM56218_A0_FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_0f_SET(r,f) (r).fp_cam_bist_enable[0]=(((r).fp_cam_bist_enable[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56218_A0_FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_1f_GET(r) ((((r).fp_cam_bist_enable[0]) >> 9) & 0x1)
#define BCM56218_A0_FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_1f_SET(r,f) (r).fp_cam_bist_enable[0]=(((r).fp_cam_bist_enable[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56218_A0_FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_2f_GET(r) ((((r).fp_cam_bist_enable[0]) >> 10) & 0x1)
#define BCM56218_A0_FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_2f_SET(r,f) (r).fp_cam_bist_enable[0]=(((r).fp_cam_bist_enable[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56218_A0_FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_3f_GET(r) ((((r).fp_cam_bist_enable[0]) >> 11) & 0x1)
#define BCM56218_A0_FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_3f_SET(r,f) (r).fp_cam_bist_enable[0]=(((r).fp_cam_bist_enable[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56218_A0_FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_4f_GET(r) ((((r).fp_cam_bist_enable[0]) >> 12) & 0x1)
#define BCM56218_A0_FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_4f_SET(r,f) (r).fp_cam_bist_enable[0]=(((r).fp_cam_bist_enable[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM56218_A0_FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_5f_GET(r) ((((r).fp_cam_bist_enable[0]) >> 13) & 0x1)
#define BCM56218_A0_FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_5f_SET(r,f) (r).fp_cam_bist_enable[0]=(((r).fp_cam_bist_enable[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56218_A0_FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_6f_GET(r) ((((r).fp_cam_bist_enable[0]) >> 14) & 0x1)
#define BCM56218_A0_FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_6f_SET(r,f) (r).fp_cam_bist_enable[0]=(((r).fp_cam_bist_enable[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM56218_A0_FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_7f_GET(r) ((((r).fp_cam_bist_enable[0]) >> 15) & 0x1)
#define BCM56218_A0_FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_7f_SET(r,f) (r).fp_cam_bist_enable[0]=(((r).fp_cam_bist_enable[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access FP_CAM_BIST_ENABLE.
 *
 */
#define BCM56218_A0_READ_FP_CAM_BIST_ENABLEr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_FP_CAM_BIST_ENABLEr,(r._fp_cam_bist_enable))
#define BCM56218_A0_WRITE_FP_CAM_BIST_ENABLEr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_FP_CAM_BIST_ENABLEr,&(r._fp_cam_bist_enable))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_CAM_BIST_ENABLEr BCM56218_A0_FP_CAM_BIST_ENABLEr
#define FP_CAM_BIST_ENABLEr_SIZE BCM56218_A0_FP_CAM_BIST_ENABLEr_SIZE
typedef BCM56218_A0_FP_CAM_BIST_ENABLEr_t FP_CAM_BIST_ENABLEr_t;
#define FP_CAM_BIST_ENABLEr_CLR BCM56218_A0_FP_CAM_BIST_ENABLEr_CLR
#define FP_CAM_BIST_ENABLEr_SET BCM56218_A0_FP_CAM_BIST_ENABLEr_SET
#define FP_CAM_BIST_ENABLEr_GET BCM56218_A0_FP_CAM_BIST_ENABLEr_GET
#define FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_0f_GET BCM56218_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_0f_GET
#define FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_0f_SET BCM56218_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_0f_SET
#define FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_1f_GET BCM56218_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_1f_GET
#define FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_1f_SET BCM56218_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_1f_SET
#define FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_2f_GET BCM56218_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_2f_GET
#define FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_2f_SET BCM56218_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_2f_SET
#define FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_3f_GET BCM56218_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_3f_GET
#define FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_3f_SET BCM56218_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_3f_SET
#define FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_4f_GET BCM56218_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_4f_GET
#define FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_4f_SET BCM56218_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_4f_SET
#define FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_5f_GET BCM56218_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_5f_GET
#define FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_5f_SET BCM56218_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_5f_SET
#define FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_6f_GET BCM56218_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_6f_GET
#define FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_6f_SET BCM56218_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_6f_SET
#define FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_7f_GET BCM56218_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_7f_GET
#define FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_7f_SET BCM56218_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_7f_SET
#define FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_0f_GET BCM56218_A0_FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_0f_GET
#define FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_0f_SET BCM56218_A0_FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_0f_SET
#define FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_1f_GET BCM56218_A0_FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_1f_GET
#define FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_1f_SET BCM56218_A0_FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_1f_SET
#define FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_2f_GET BCM56218_A0_FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_2f_GET
#define FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_2f_SET BCM56218_A0_FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_2f_SET
#define FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_3f_GET BCM56218_A0_FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_3f_GET
#define FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_3f_SET BCM56218_A0_FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_3f_SET
#define FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_4f_GET BCM56218_A0_FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_4f_GET
#define FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_4f_SET BCM56218_A0_FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_4f_SET
#define FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_5f_GET BCM56218_A0_FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_5f_GET
#define FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_5f_SET BCM56218_A0_FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_5f_SET
#define FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_6f_GET BCM56218_A0_FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_6f_GET
#define FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_6f_SET BCM56218_A0_FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_6f_SET
#define FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_7f_GET BCM56218_A0_FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_7f_GET
#define FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_7f_SET BCM56218_A0_FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_7f_SET
#define READ_FP_CAM_BIST_ENABLEr BCM56218_A0_READ_FP_CAM_BIST_ENABLEr
#define WRITE_FP_CAM_BIST_ENABLEr BCM56218_A0_WRITE_FP_CAM_BIST_ENABLEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_FP_CAM_BIST_ENABLEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  FP_CAM_BIST_S10_STATUS
 * BLOCKS:   IPIPE
 * DESC:     FP_CAM_BIST_S10_STATUS
 * SIZE:     32
 * FIELDS:
 *     FP_CAM_S10_STATUS FP_CAM_BIST_S10_STATUS
 *
 ******************************************************************************/
#define BCM56218_A0_FP_CAM_BIST_S10_STATUSr 0x0c780005

#define BCM56218_A0_FP_CAM_BIST_S10_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program FP_CAM_BIST_S10_STATUS.
 *
 */
typedef union BCM56218_A0_FP_CAM_BIST_S10_STATUSr_s {
	uint32_t v[1];
	uint32_t fp_cam_bist_s10_status[1];
	uint32_t _fp_cam_bist_s10_status;
} BCM56218_A0_FP_CAM_BIST_S10_STATUSr_t;

#define BCM56218_A0_FP_CAM_BIST_S10_STATUSr_CLR(r) (r).fp_cam_bist_s10_status[0] = 0
#define BCM56218_A0_FP_CAM_BIST_S10_STATUSr_SET(r,d) (r).fp_cam_bist_s10_status[0] = d
#define BCM56218_A0_FP_CAM_BIST_S10_STATUSr_GET(r) (r).fp_cam_bist_s10_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_FP_CAM_BIST_S10_STATUSr_FP_CAM_S10_STATUSf_GET(r) (((r).fp_cam_bist_s10_status[0]) & 0xff)
#define BCM56218_A0_FP_CAM_BIST_S10_STATUSr_FP_CAM_S10_STATUSf_SET(r,f) (r).fp_cam_bist_s10_status[0]=(((r).fp_cam_bist_s10_status[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access FP_CAM_BIST_S10_STATUS.
 *
 */
#define BCM56218_A0_READ_FP_CAM_BIST_S10_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_FP_CAM_BIST_S10_STATUSr,(r._fp_cam_bist_s10_status))
#define BCM56218_A0_WRITE_FP_CAM_BIST_S10_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_FP_CAM_BIST_S10_STATUSr,&(r._fp_cam_bist_s10_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_CAM_BIST_S10_STATUSr BCM56218_A0_FP_CAM_BIST_S10_STATUSr
#define FP_CAM_BIST_S10_STATUSr_SIZE BCM56218_A0_FP_CAM_BIST_S10_STATUSr_SIZE
typedef BCM56218_A0_FP_CAM_BIST_S10_STATUSr_t FP_CAM_BIST_S10_STATUSr_t;
#define FP_CAM_BIST_S10_STATUSr_CLR BCM56218_A0_FP_CAM_BIST_S10_STATUSr_CLR
#define FP_CAM_BIST_S10_STATUSr_SET BCM56218_A0_FP_CAM_BIST_S10_STATUSr_SET
#define FP_CAM_BIST_S10_STATUSr_GET BCM56218_A0_FP_CAM_BIST_S10_STATUSr_GET
#define FP_CAM_BIST_S10_STATUSr_FP_CAM_S10_STATUSf_GET BCM56218_A0_FP_CAM_BIST_S10_STATUSr_FP_CAM_S10_STATUSf_GET
#define FP_CAM_BIST_S10_STATUSr_FP_CAM_S10_STATUSf_SET BCM56218_A0_FP_CAM_BIST_S10_STATUSr_FP_CAM_S10_STATUSf_SET
#define READ_FP_CAM_BIST_S10_STATUSr BCM56218_A0_READ_FP_CAM_BIST_S10_STATUSr
#define WRITE_FP_CAM_BIST_S10_STATUSr BCM56218_A0_WRITE_FP_CAM_BIST_S10_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_FP_CAM_BIST_S10_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  FP_CAM_BIST_S12_STATUS
 * BLOCKS:   IPIPE
 * DESC:     FP_CAM_BIST_S12_STATUS
 * SIZE:     32
 * FIELDS:
 *     FP_CAM_S12_STATUS FP_CAM_BIST_S12_STATUS
 *
 ******************************************************************************/
#define BCM56218_A0_FP_CAM_BIST_S12_STATUSr 0x0c780006

#define BCM56218_A0_FP_CAM_BIST_S12_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program FP_CAM_BIST_S12_STATUS.
 *
 */
typedef union BCM56218_A0_FP_CAM_BIST_S12_STATUSr_s {
	uint32_t v[1];
	uint32_t fp_cam_bist_s12_status[1];
	uint32_t _fp_cam_bist_s12_status;
} BCM56218_A0_FP_CAM_BIST_S12_STATUSr_t;

#define BCM56218_A0_FP_CAM_BIST_S12_STATUSr_CLR(r) (r).fp_cam_bist_s12_status[0] = 0
#define BCM56218_A0_FP_CAM_BIST_S12_STATUSr_SET(r,d) (r).fp_cam_bist_s12_status[0] = d
#define BCM56218_A0_FP_CAM_BIST_S12_STATUSr_GET(r) (r).fp_cam_bist_s12_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_FP_CAM_BIST_S12_STATUSr_FP_CAM_S12_STATUSf_GET(r) (((r).fp_cam_bist_s12_status[0]) & 0xffff)
#define BCM56218_A0_FP_CAM_BIST_S12_STATUSr_FP_CAM_S12_STATUSf_SET(r,f) (r).fp_cam_bist_s12_status[0]=(((r).fp_cam_bist_s12_status[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access FP_CAM_BIST_S12_STATUS.
 *
 */
#define BCM56218_A0_READ_FP_CAM_BIST_S12_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_FP_CAM_BIST_S12_STATUSr,(r._fp_cam_bist_s12_status))
#define BCM56218_A0_WRITE_FP_CAM_BIST_S12_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_FP_CAM_BIST_S12_STATUSr,&(r._fp_cam_bist_s12_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_CAM_BIST_S12_STATUSr BCM56218_A0_FP_CAM_BIST_S12_STATUSr
#define FP_CAM_BIST_S12_STATUSr_SIZE BCM56218_A0_FP_CAM_BIST_S12_STATUSr_SIZE
typedef BCM56218_A0_FP_CAM_BIST_S12_STATUSr_t FP_CAM_BIST_S12_STATUSr_t;
#define FP_CAM_BIST_S12_STATUSr_CLR BCM56218_A0_FP_CAM_BIST_S12_STATUSr_CLR
#define FP_CAM_BIST_S12_STATUSr_SET BCM56218_A0_FP_CAM_BIST_S12_STATUSr_SET
#define FP_CAM_BIST_S12_STATUSr_GET BCM56218_A0_FP_CAM_BIST_S12_STATUSr_GET
#define FP_CAM_BIST_S12_STATUSr_FP_CAM_S12_STATUSf_GET BCM56218_A0_FP_CAM_BIST_S12_STATUSr_FP_CAM_S12_STATUSf_GET
#define FP_CAM_BIST_S12_STATUSr_FP_CAM_S12_STATUSf_SET BCM56218_A0_FP_CAM_BIST_S12_STATUSr_FP_CAM_S12_STATUSf_SET
#define READ_FP_CAM_BIST_S12_STATUSr BCM56218_A0_READ_FP_CAM_BIST_S12_STATUSr
#define WRITE_FP_CAM_BIST_S12_STATUSr BCM56218_A0_WRITE_FP_CAM_BIST_S12_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_FP_CAM_BIST_S12_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  FP_CAM_BIST_S14_STATUS
 * BLOCKS:   IPIPE
 * DESC:     FP_CAM_BIST_S14_STATUS
 * SIZE:     32
 * FIELDS:
 *     FP_CAM_S14_STATUS FP_CAM_BIST_S14_STATUS
 *
 ******************************************************************************/
#define BCM56218_A0_FP_CAM_BIST_S14_STATUSr 0x0c780007

#define BCM56218_A0_FP_CAM_BIST_S14_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program FP_CAM_BIST_S14_STATUS.
 *
 */
typedef union BCM56218_A0_FP_CAM_BIST_S14_STATUSr_s {
	uint32_t v[1];
	uint32_t fp_cam_bist_s14_status[1];
	uint32_t _fp_cam_bist_s14_status;
} BCM56218_A0_FP_CAM_BIST_S14_STATUSr_t;

#define BCM56218_A0_FP_CAM_BIST_S14_STATUSr_CLR(r) (r).fp_cam_bist_s14_status[0] = 0
#define BCM56218_A0_FP_CAM_BIST_S14_STATUSr_SET(r,d) (r).fp_cam_bist_s14_status[0] = d
#define BCM56218_A0_FP_CAM_BIST_S14_STATUSr_GET(r) (r).fp_cam_bist_s14_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_FP_CAM_BIST_S14_STATUSr_FP_CAM_S14_STATUSf_GET(r) (((r).fp_cam_bist_s14_status[0]) & 0xffff)
#define BCM56218_A0_FP_CAM_BIST_S14_STATUSr_FP_CAM_S14_STATUSf_SET(r,f) (r).fp_cam_bist_s14_status[0]=(((r).fp_cam_bist_s14_status[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access FP_CAM_BIST_S14_STATUS.
 *
 */
#define BCM56218_A0_READ_FP_CAM_BIST_S14_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_FP_CAM_BIST_S14_STATUSr,(r._fp_cam_bist_s14_status))
#define BCM56218_A0_WRITE_FP_CAM_BIST_S14_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_FP_CAM_BIST_S14_STATUSr,&(r._fp_cam_bist_s14_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_CAM_BIST_S14_STATUSr BCM56218_A0_FP_CAM_BIST_S14_STATUSr
#define FP_CAM_BIST_S14_STATUSr_SIZE BCM56218_A0_FP_CAM_BIST_S14_STATUSr_SIZE
typedef BCM56218_A0_FP_CAM_BIST_S14_STATUSr_t FP_CAM_BIST_S14_STATUSr_t;
#define FP_CAM_BIST_S14_STATUSr_CLR BCM56218_A0_FP_CAM_BIST_S14_STATUSr_CLR
#define FP_CAM_BIST_S14_STATUSr_SET BCM56218_A0_FP_CAM_BIST_S14_STATUSr_SET
#define FP_CAM_BIST_S14_STATUSr_GET BCM56218_A0_FP_CAM_BIST_S14_STATUSr_GET
#define FP_CAM_BIST_S14_STATUSr_FP_CAM_S14_STATUSf_GET BCM56218_A0_FP_CAM_BIST_S14_STATUSr_FP_CAM_S14_STATUSf_GET
#define FP_CAM_BIST_S14_STATUSr_FP_CAM_S14_STATUSf_SET BCM56218_A0_FP_CAM_BIST_S14_STATUSr_FP_CAM_S14_STATUSf_SET
#define READ_FP_CAM_BIST_S14_STATUSr BCM56218_A0_READ_FP_CAM_BIST_S14_STATUSr
#define WRITE_FP_CAM_BIST_S14_STATUSr BCM56218_A0_WRITE_FP_CAM_BIST_S14_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_FP_CAM_BIST_S14_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  FP_CAM_BIST_S15_STATUS
 * BLOCKS:   IPIPE
 * DESC:     FP_CAM_BIST_S15_STATUS
 * SIZE:     32
 * FIELDS:
 *     FP_CAM_S15_STATUS FP_CAM_BIST_S15_STATUS
 *
 ******************************************************************************/
#define BCM56218_A0_FP_CAM_BIST_S15_STATUSr 0x0c780008

#define BCM56218_A0_FP_CAM_BIST_S15_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program FP_CAM_BIST_S15_STATUS.
 *
 */
typedef union BCM56218_A0_FP_CAM_BIST_S15_STATUSr_s {
	uint32_t v[1];
	uint32_t fp_cam_bist_s15_status[1];
	uint32_t _fp_cam_bist_s15_status;
} BCM56218_A0_FP_CAM_BIST_S15_STATUSr_t;

#define BCM56218_A0_FP_CAM_BIST_S15_STATUSr_CLR(r) (r).fp_cam_bist_s15_status[0] = 0
#define BCM56218_A0_FP_CAM_BIST_S15_STATUSr_SET(r,d) (r).fp_cam_bist_s15_status[0] = d
#define BCM56218_A0_FP_CAM_BIST_S15_STATUSr_GET(r) (r).fp_cam_bist_s15_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_FP_CAM_BIST_S15_STATUSr_FP_CAM_S15_STATUSf_GET(r) (((r).fp_cam_bist_s15_status[0]) & 0xff)
#define BCM56218_A0_FP_CAM_BIST_S15_STATUSr_FP_CAM_S15_STATUSf_SET(r,f) (r).fp_cam_bist_s15_status[0]=(((r).fp_cam_bist_s15_status[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access FP_CAM_BIST_S15_STATUS.
 *
 */
#define BCM56218_A0_READ_FP_CAM_BIST_S15_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_FP_CAM_BIST_S15_STATUSr,(r._fp_cam_bist_s15_status))
#define BCM56218_A0_WRITE_FP_CAM_BIST_S15_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_FP_CAM_BIST_S15_STATUSr,&(r._fp_cam_bist_s15_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_CAM_BIST_S15_STATUSr BCM56218_A0_FP_CAM_BIST_S15_STATUSr
#define FP_CAM_BIST_S15_STATUSr_SIZE BCM56218_A0_FP_CAM_BIST_S15_STATUSr_SIZE
typedef BCM56218_A0_FP_CAM_BIST_S15_STATUSr_t FP_CAM_BIST_S15_STATUSr_t;
#define FP_CAM_BIST_S15_STATUSr_CLR BCM56218_A0_FP_CAM_BIST_S15_STATUSr_CLR
#define FP_CAM_BIST_S15_STATUSr_SET BCM56218_A0_FP_CAM_BIST_S15_STATUSr_SET
#define FP_CAM_BIST_S15_STATUSr_GET BCM56218_A0_FP_CAM_BIST_S15_STATUSr_GET
#define FP_CAM_BIST_S15_STATUSr_FP_CAM_S15_STATUSf_GET BCM56218_A0_FP_CAM_BIST_S15_STATUSr_FP_CAM_S15_STATUSf_GET
#define FP_CAM_BIST_S15_STATUSr_FP_CAM_S15_STATUSf_SET BCM56218_A0_FP_CAM_BIST_S15_STATUSr_FP_CAM_S15_STATUSf_SET
#define READ_FP_CAM_BIST_S15_STATUSr BCM56218_A0_READ_FP_CAM_BIST_S15_STATUSr
#define WRITE_FP_CAM_BIST_S15_STATUSr BCM56218_A0_WRITE_FP_CAM_BIST_S15_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_FP_CAM_BIST_S15_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  FP_CAM_BIST_S2_STATUS
 * BLOCKS:   IPIPE
 * DESC:     FP_CAM_BIST_S2_STATUS
 * SIZE:     32
 * FIELDS:
 *     FP_CAM_S2_STATUS FP_CAM_BIST_S2_STATUS
 *
 ******************************************************************************/
#define BCM56218_A0_FP_CAM_BIST_S2_STATUSr 0x0c780000

#define BCM56218_A0_FP_CAM_BIST_S2_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program FP_CAM_BIST_S2_STATUS.
 *
 */
typedef union BCM56218_A0_FP_CAM_BIST_S2_STATUSr_s {
	uint32_t v[1];
	uint32_t fp_cam_bist_s2_status[1];
	uint32_t _fp_cam_bist_s2_status;
} BCM56218_A0_FP_CAM_BIST_S2_STATUSr_t;

#define BCM56218_A0_FP_CAM_BIST_S2_STATUSr_CLR(r) (r).fp_cam_bist_s2_status[0] = 0
#define BCM56218_A0_FP_CAM_BIST_S2_STATUSr_SET(r,d) (r).fp_cam_bist_s2_status[0] = d
#define BCM56218_A0_FP_CAM_BIST_S2_STATUSr_GET(r) (r).fp_cam_bist_s2_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_FP_CAM_BIST_S2_STATUSr_FP_CAM_S2_STATUSf_GET(r) (((r).fp_cam_bist_s2_status[0]) & 0xffff)
#define BCM56218_A0_FP_CAM_BIST_S2_STATUSr_FP_CAM_S2_STATUSf_SET(r,f) (r).fp_cam_bist_s2_status[0]=(((r).fp_cam_bist_s2_status[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access FP_CAM_BIST_S2_STATUS.
 *
 */
#define BCM56218_A0_READ_FP_CAM_BIST_S2_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_FP_CAM_BIST_S2_STATUSr,(r._fp_cam_bist_s2_status))
#define BCM56218_A0_WRITE_FP_CAM_BIST_S2_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_FP_CAM_BIST_S2_STATUSr,&(r._fp_cam_bist_s2_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_CAM_BIST_S2_STATUSr BCM56218_A0_FP_CAM_BIST_S2_STATUSr
#define FP_CAM_BIST_S2_STATUSr_SIZE BCM56218_A0_FP_CAM_BIST_S2_STATUSr_SIZE
typedef BCM56218_A0_FP_CAM_BIST_S2_STATUSr_t FP_CAM_BIST_S2_STATUSr_t;
#define FP_CAM_BIST_S2_STATUSr_CLR BCM56218_A0_FP_CAM_BIST_S2_STATUSr_CLR
#define FP_CAM_BIST_S2_STATUSr_SET BCM56218_A0_FP_CAM_BIST_S2_STATUSr_SET
#define FP_CAM_BIST_S2_STATUSr_GET BCM56218_A0_FP_CAM_BIST_S2_STATUSr_GET
#define FP_CAM_BIST_S2_STATUSr_FP_CAM_S2_STATUSf_GET BCM56218_A0_FP_CAM_BIST_S2_STATUSr_FP_CAM_S2_STATUSf_GET
#define FP_CAM_BIST_S2_STATUSr_FP_CAM_S2_STATUSf_SET BCM56218_A0_FP_CAM_BIST_S2_STATUSr_FP_CAM_S2_STATUSf_SET
#define READ_FP_CAM_BIST_S2_STATUSr BCM56218_A0_READ_FP_CAM_BIST_S2_STATUSr
#define WRITE_FP_CAM_BIST_S2_STATUSr BCM56218_A0_WRITE_FP_CAM_BIST_S2_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_FP_CAM_BIST_S2_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  FP_CAM_BIST_S3_STATUS
 * BLOCKS:   IPIPE
 * DESC:     FP_CAM_BIST_S3_STATUS
 * SIZE:     32
 * FIELDS:
 *     FP_CAM_S3_STATUS FP_CAM_BIST_S3_STATUS
 *
 ******************************************************************************/
#define BCM56218_A0_FP_CAM_BIST_S3_STATUSr 0x0c780001

#define BCM56218_A0_FP_CAM_BIST_S3_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program FP_CAM_BIST_S3_STATUS.
 *
 */
typedef union BCM56218_A0_FP_CAM_BIST_S3_STATUSr_s {
	uint32_t v[1];
	uint32_t fp_cam_bist_s3_status[1];
	uint32_t _fp_cam_bist_s3_status;
} BCM56218_A0_FP_CAM_BIST_S3_STATUSr_t;

#define BCM56218_A0_FP_CAM_BIST_S3_STATUSr_CLR(r) (r).fp_cam_bist_s3_status[0] = 0
#define BCM56218_A0_FP_CAM_BIST_S3_STATUSr_SET(r,d) (r).fp_cam_bist_s3_status[0] = d
#define BCM56218_A0_FP_CAM_BIST_S3_STATUSr_GET(r) (r).fp_cam_bist_s3_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_FP_CAM_BIST_S3_STATUSr_FP_CAM_S3_STATUSf_GET(r) (((r).fp_cam_bist_s3_status[0]) & 0xffff)
#define BCM56218_A0_FP_CAM_BIST_S3_STATUSr_FP_CAM_S3_STATUSf_SET(r,f) (r).fp_cam_bist_s3_status[0]=(((r).fp_cam_bist_s3_status[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access FP_CAM_BIST_S3_STATUS.
 *
 */
#define BCM56218_A0_READ_FP_CAM_BIST_S3_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_FP_CAM_BIST_S3_STATUSr,(r._fp_cam_bist_s3_status))
#define BCM56218_A0_WRITE_FP_CAM_BIST_S3_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_FP_CAM_BIST_S3_STATUSr,&(r._fp_cam_bist_s3_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_CAM_BIST_S3_STATUSr BCM56218_A0_FP_CAM_BIST_S3_STATUSr
#define FP_CAM_BIST_S3_STATUSr_SIZE BCM56218_A0_FP_CAM_BIST_S3_STATUSr_SIZE
typedef BCM56218_A0_FP_CAM_BIST_S3_STATUSr_t FP_CAM_BIST_S3_STATUSr_t;
#define FP_CAM_BIST_S3_STATUSr_CLR BCM56218_A0_FP_CAM_BIST_S3_STATUSr_CLR
#define FP_CAM_BIST_S3_STATUSr_SET BCM56218_A0_FP_CAM_BIST_S3_STATUSr_SET
#define FP_CAM_BIST_S3_STATUSr_GET BCM56218_A0_FP_CAM_BIST_S3_STATUSr_GET
#define FP_CAM_BIST_S3_STATUSr_FP_CAM_S3_STATUSf_GET BCM56218_A0_FP_CAM_BIST_S3_STATUSr_FP_CAM_S3_STATUSf_GET
#define FP_CAM_BIST_S3_STATUSr_FP_CAM_S3_STATUSf_SET BCM56218_A0_FP_CAM_BIST_S3_STATUSr_FP_CAM_S3_STATUSf_SET
#define READ_FP_CAM_BIST_S3_STATUSr BCM56218_A0_READ_FP_CAM_BIST_S3_STATUSr
#define WRITE_FP_CAM_BIST_S3_STATUSr BCM56218_A0_WRITE_FP_CAM_BIST_S3_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_FP_CAM_BIST_S3_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  FP_CAM_BIST_S5_STATUS
 * BLOCKS:   IPIPE
 * DESC:     FP_CAM_BIST_S5_STATUS
 * SIZE:     32
 * FIELDS:
 *     FP_CAM_S5_STATUS FP_CAM_BIST_S5_STATUS
 *
 ******************************************************************************/
#define BCM56218_A0_FP_CAM_BIST_S5_STATUSr 0x0c780002

#define BCM56218_A0_FP_CAM_BIST_S5_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program FP_CAM_BIST_S5_STATUS.
 *
 */
typedef union BCM56218_A0_FP_CAM_BIST_S5_STATUSr_s {
	uint32_t v[1];
	uint32_t fp_cam_bist_s5_status[1];
	uint32_t _fp_cam_bist_s5_status;
} BCM56218_A0_FP_CAM_BIST_S5_STATUSr_t;

#define BCM56218_A0_FP_CAM_BIST_S5_STATUSr_CLR(r) (r).fp_cam_bist_s5_status[0] = 0
#define BCM56218_A0_FP_CAM_BIST_S5_STATUSr_SET(r,d) (r).fp_cam_bist_s5_status[0] = d
#define BCM56218_A0_FP_CAM_BIST_S5_STATUSr_GET(r) (r).fp_cam_bist_s5_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_FP_CAM_BIST_S5_STATUSr_FP_CAM_S5_STATUSf_GET(r) (((r).fp_cam_bist_s5_status[0]) & 0xffff)
#define BCM56218_A0_FP_CAM_BIST_S5_STATUSr_FP_CAM_S5_STATUSf_SET(r,f) (r).fp_cam_bist_s5_status[0]=(((r).fp_cam_bist_s5_status[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access FP_CAM_BIST_S5_STATUS.
 *
 */
#define BCM56218_A0_READ_FP_CAM_BIST_S5_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_FP_CAM_BIST_S5_STATUSr,(r._fp_cam_bist_s5_status))
#define BCM56218_A0_WRITE_FP_CAM_BIST_S5_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_FP_CAM_BIST_S5_STATUSr,&(r._fp_cam_bist_s5_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_CAM_BIST_S5_STATUSr BCM56218_A0_FP_CAM_BIST_S5_STATUSr
#define FP_CAM_BIST_S5_STATUSr_SIZE BCM56218_A0_FP_CAM_BIST_S5_STATUSr_SIZE
typedef BCM56218_A0_FP_CAM_BIST_S5_STATUSr_t FP_CAM_BIST_S5_STATUSr_t;
#define FP_CAM_BIST_S5_STATUSr_CLR BCM56218_A0_FP_CAM_BIST_S5_STATUSr_CLR
#define FP_CAM_BIST_S5_STATUSr_SET BCM56218_A0_FP_CAM_BIST_S5_STATUSr_SET
#define FP_CAM_BIST_S5_STATUSr_GET BCM56218_A0_FP_CAM_BIST_S5_STATUSr_GET
#define FP_CAM_BIST_S5_STATUSr_FP_CAM_S5_STATUSf_GET BCM56218_A0_FP_CAM_BIST_S5_STATUSr_FP_CAM_S5_STATUSf_GET
#define FP_CAM_BIST_S5_STATUSr_FP_CAM_S5_STATUSf_SET BCM56218_A0_FP_CAM_BIST_S5_STATUSr_FP_CAM_S5_STATUSf_SET
#define READ_FP_CAM_BIST_S5_STATUSr BCM56218_A0_READ_FP_CAM_BIST_S5_STATUSr
#define WRITE_FP_CAM_BIST_S5_STATUSr BCM56218_A0_WRITE_FP_CAM_BIST_S5_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_FP_CAM_BIST_S5_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  FP_CAM_BIST_S6_STATUS
 * BLOCKS:   IPIPE
 * DESC:     FP_CAM_BIST_S6_STATUS
 * SIZE:     32
 * FIELDS:
 *     FP_CAM_S6_STATUS FP_CAM_BIST_S6_STATUS
 *
 ******************************************************************************/
#define BCM56218_A0_FP_CAM_BIST_S6_STATUSr 0x0c780003

#define BCM56218_A0_FP_CAM_BIST_S6_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program FP_CAM_BIST_S6_STATUS.
 *
 */
typedef union BCM56218_A0_FP_CAM_BIST_S6_STATUSr_s {
	uint32_t v[1];
	uint32_t fp_cam_bist_s6_status[1];
	uint32_t _fp_cam_bist_s6_status;
} BCM56218_A0_FP_CAM_BIST_S6_STATUSr_t;

#define BCM56218_A0_FP_CAM_BIST_S6_STATUSr_CLR(r) (r).fp_cam_bist_s6_status[0] = 0
#define BCM56218_A0_FP_CAM_BIST_S6_STATUSr_SET(r,d) (r).fp_cam_bist_s6_status[0] = d
#define BCM56218_A0_FP_CAM_BIST_S6_STATUSr_GET(r) (r).fp_cam_bist_s6_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_FP_CAM_BIST_S6_STATUSr_FP_CAM_S6_STATUSf_GET(r) (((r).fp_cam_bist_s6_status[0]) & 0xffff)
#define BCM56218_A0_FP_CAM_BIST_S6_STATUSr_FP_CAM_S6_STATUSf_SET(r,f) (r).fp_cam_bist_s6_status[0]=(((r).fp_cam_bist_s6_status[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access FP_CAM_BIST_S6_STATUS.
 *
 */
#define BCM56218_A0_READ_FP_CAM_BIST_S6_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_FP_CAM_BIST_S6_STATUSr,(r._fp_cam_bist_s6_status))
#define BCM56218_A0_WRITE_FP_CAM_BIST_S6_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_FP_CAM_BIST_S6_STATUSr,&(r._fp_cam_bist_s6_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_CAM_BIST_S6_STATUSr BCM56218_A0_FP_CAM_BIST_S6_STATUSr
#define FP_CAM_BIST_S6_STATUSr_SIZE BCM56218_A0_FP_CAM_BIST_S6_STATUSr_SIZE
typedef BCM56218_A0_FP_CAM_BIST_S6_STATUSr_t FP_CAM_BIST_S6_STATUSr_t;
#define FP_CAM_BIST_S6_STATUSr_CLR BCM56218_A0_FP_CAM_BIST_S6_STATUSr_CLR
#define FP_CAM_BIST_S6_STATUSr_SET BCM56218_A0_FP_CAM_BIST_S6_STATUSr_SET
#define FP_CAM_BIST_S6_STATUSr_GET BCM56218_A0_FP_CAM_BIST_S6_STATUSr_GET
#define FP_CAM_BIST_S6_STATUSr_FP_CAM_S6_STATUSf_GET BCM56218_A0_FP_CAM_BIST_S6_STATUSr_FP_CAM_S6_STATUSf_GET
#define FP_CAM_BIST_S6_STATUSr_FP_CAM_S6_STATUSf_SET BCM56218_A0_FP_CAM_BIST_S6_STATUSr_FP_CAM_S6_STATUSf_SET
#define READ_FP_CAM_BIST_S6_STATUSr BCM56218_A0_READ_FP_CAM_BIST_S6_STATUSr
#define WRITE_FP_CAM_BIST_S6_STATUSr BCM56218_A0_WRITE_FP_CAM_BIST_S6_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_FP_CAM_BIST_S6_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  FP_CAM_BIST_S8_STATUS
 * BLOCKS:   IPIPE
 * DESC:     FP_CAM_BIST_S8_STATUS
 * SIZE:     32
 * FIELDS:
 *     FP_CAM_S8_STATUS FP_CAM_BIST_S8_STATUS
 *
 ******************************************************************************/
#define BCM56218_A0_FP_CAM_BIST_S8_STATUSr 0x0c780004

#define BCM56218_A0_FP_CAM_BIST_S8_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program FP_CAM_BIST_S8_STATUS.
 *
 */
typedef union BCM56218_A0_FP_CAM_BIST_S8_STATUSr_s {
	uint32_t v[1];
	uint32_t fp_cam_bist_s8_status[1];
	uint32_t _fp_cam_bist_s8_status;
} BCM56218_A0_FP_CAM_BIST_S8_STATUSr_t;

#define BCM56218_A0_FP_CAM_BIST_S8_STATUSr_CLR(r) (r).fp_cam_bist_s8_status[0] = 0
#define BCM56218_A0_FP_CAM_BIST_S8_STATUSr_SET(r,d) (r).fp_cam_bist_s8_status[0] = d
#define BCM56218_A0_FP_CAM_BIST_S8_STATUSr_GET(r) (r).fp_cam_bist_s8_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_FP_CAM_BIST_S8_STATUSr_FP_CAM_S8_STATUSf_GET(r) (((r).fp_cam_bist_s8_status[0]) & 0xffff)
#define BCM56218_A0_FP_CAM_BIST_S8_STATUSr_FP_CAM_S8_STATUSf_SET(r,f) (r).fp_cam_bist_s8_status[0]=(((r).fp_cam_bist_s8_status[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access FP_CAM_BIST_S8_STATUS.
 *
 */
#define BCM56218_A0_READ_FP_CAM_BIST_S8_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_FP_CAM_BIST_S8_STATUSr,(r._fp_cam_bist_s8_status))
#define BCM56218_A0_WRITE_FP_CAM_BIST_S8_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_FP_CAM_BIST_S8_STATUSr,&(r._fp_cam_bist_s8_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_CAM_BIST_S8_STATUSr BCM56218_A0_FP_CAM_BIST_S8_STATUSr
#define FP_CAM_BIST_S8_STATUSr_SIZE BCM56218_A0_FP_CAM_BIST_S8_STATUSr_SIZE
typedef BCM56218_A0_FP_CAM_BIST_S8_STATUSr_t FP_CAM_BIST_S8_STATUSr_t;
#define FP_CAM_BIST_S8_STATUSr_CLR BCM56218_A0_FP_CAM_BIST_S8_STATUSr_CLR
#define FP_CAM_BIST_S8_STATUSr_SET BCM56218_A0_FP_CAM_BIST_S8_STATUSr_SET
#define FP_CAM_BIST_S8_STATUSr_GET BCM56218_A0_FP_CAM_BIST_S8_STATUSr_GET
#define FP_CAM_BIST_S8_STATUSr_FP_CAM_S8_STATUSf_GET BCM56218_A0_FP_CAM_BIST_S8_STATUSr_FP_CAM_S8_STATUSf_GET
#define FP_CAM_BIST_S8_STATUSr_FP_CAM_S8_STATUSf_SET BCM56218_A0_FP_CAM_BIST_S8_STATUSr_FP_CAM_S8_STATUSf_SET
#define READ_FP_CAM_BIST_S8_STATUSr BCM56218_A0_READ_FP_CAM_BIST_S8_STATUSr
#define WRITE_FP_CAM_BIST_S8_STATUSr BCM56218_A0_WRITE_FP_CAM_BIST_S8_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_FP_CAM_BIST_S8_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  FP_CAM_BIST_STATUS
 * BLOCKS:   IPIPE
 * DESC:     FP_CAM_BIST_STATUS
 * SIZE:     32
 * FIELDS:
 *     FP_CAM_BIST_GO   CAM_BIST_GO_STATUS
 *     FP_CAM_BIST_DONE CAM_BIST_DONE_STATUS
 *
 ******************************************************************************/
#define BCM56218_A0_FP_CAM_BIST_STATUSr 0x0c780009

#define BCM56218_A0_FP_CAM_BIST_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program FP_CAM_BIST_STATUS.
 *
 */
typedef union BCM56218_A0_FP_CAM_BIST_STATUSr_s {
	uint32_t v[1];
	uint32_t fp_cam_bist_status[1];
	uint32_t _fp_cam_bist_status;
} BCM56218_A0_FP_CAM_BIST_STATUSr_t;

#define BCM56218_A0_FP_CAM_BIST_STATUSr_CLR(r) (r).fp_cam_bist_status[0] = 0
#define BCM56218_A0_FP_CAM_BIST_STATUSr_SET(r,d) (r).fp_cam_bist_status[0] = d
#define BCM56218_A0_FP_CAM_BIST_STATUSr_GET(r) (r).fp_cam_bist_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_FP_CAM_BIST_STATUSr_FP_CAM_BIST_GOf_GET(r) (((r).fp_cam_bist_status[0]) & 0x1)
#define BCM56218_A0_FP_CAM_BIST_STATUSr_FP_CAM_BIST_GOf_SET(r,f) (r).fp_cam_bist_status[0]=(((r).fp_cam_bist_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_FP_CAM_BIST_STATUSr_FP_CAM_BIST_DONEf_GET(r) ((((r).fp_cam_bist_status[0]) >> 1) & 0x1)
#define BCM56218_A0_FP_CAM_BIST_STATUSr_FP_CAM_BIST_DONEf_SET(r,f) (r).fp_cam_bist_status[0]=(((r).fp_cam_bist_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access FP_CAM_BIST_STATUS.
 *
 */
#define BCM56218_A0_READ_FP_CAM_BIST_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_FP_CAM_BIST_STATUSr,(r._fp_cam_bist_status))
#define BCM56218_A0_WRITE_FP_CAM_BIST_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_FP_CAM_BIST_STATUSr,&(r._fp_cam_bist_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_CAM_BIST_STATUSr BCM56218_A0_FP_CAM_BIST_STATUSr
#define FP_CAM_BIST_STATUSr_SIZE BCM56218_A0_FP_CAM_BIST_STATUSr_SIZE
typedef BCM56218_A0_FP_CAM_BIST_STATUSr_t FP_CAM_BIST_STATUSr_t;
#define FP_CAM_BIST_STATUSr_CLR BCM56218_A0_FP_CAM_BIST_STATUSr_CLR
#define FP_CAM_BIST_STATUSr_SET BCM56218_A0_FP_CAM_BIST_STATUSr_SET
#define FP_CAM_BIST_STATUSr_GET BCM56218_A0_FP_CAM_BIST_STATUSr_GET
#define FP_CAM_BIST_STATUSr_FP_CAM_BIST_GOf_GET BCM56218_A0_FP_CAM_BIST_STATUSr_FP_CAM_BIST_GOf_GET
#define FP_CAM_BIST_STATUSr_FP_CAM_BIST_GOf_SET BCM56218_A0_FP_CAM_BIST_STATUSr_FP_CAM_BIST_GOf_SET
#define FP_CAM_BIST_STATUSr_FP_CAM_BIST_DONEf_GET BCM56218_A0_FP_CAM_BIST_STATUSr_FP_CAM_BIST_DONEf_GET
#define FP_CAM_BIST_STATUSr_FP_CAM_BIST_DONEf_SET BCM56218_A0_FP_CAM_BIST_STATUSr_FP_CAM_BIST_DONEf_SET
#define READ_FP_CAM_BIST_STATUSr BCM56218_A0_READ_FP_CAM_BIST_STATUSr
#define WRITE_FP_CAM_BIST_STATUSr BCM56218_A0_WRITE_FP_CAM_BIST_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_FP_CAM_BIST_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  FP_CAM_CONTROL_LOWER
 * BLOCKS:   IPIPE
 * DESC:     FP_CAM_CONTROL_LOWER
 * SIZE:     32
 * FIELDS:
 *     FP_CAM_CONTROL_SLICE_0 FP_CAM_CONTROL FOR FP SLICE 0
 *     FP_CAM_CONTROL_SLICE_1 FP_CAM_CONTROL FOR FP SLICE 1
 *     FP_CAM_CONTROL_SLICE_2 FP_CAM_CONTROL FOR FP SLICE 2
 *     FP_CAM_CONTROL_SLICE_3 FP_CAM_CONTROL FOR FP SLICE 3
 *     FP_CAM_CONTROL_SLICE_4 FP_CAM_CONTROL FOR FP SLICE 4
 *     FP_CAM_CONTROL_SLICE_5 FP_CAM_CONTROL FOR FP SLICE 5
 *     FP_CAM_CONTROL_SLICE_6 FP_CAM_CONTROL FOR FP SLICE 6
 *     FP_CAM_CONTROL_SLICE_7 FP_CAM_CONTROL FOR FP SLICE 7
 *     FP_CAM_BIST_SKIP_COUNT SKIP COUNT FOR THE FP CAM BIST CONTROLLER
 *
 ******************************************************************************/
#define BCM56218_A0_FP_CAM_CONTROL_LOWERr 0x0c78000d

#define BCM56218_A0_FP_CAM_CONTROL_LOWERr_SIZE 4

/*
 * This structure should be used to declare and program FP_CAM_CONTROL_LOWER.
 *
 */
typedef union BCM56218_A0_FP_CAM_CONTROL_LOWERr_s {
	uint32_t v[1];
	uint32_t fp_cam_control_lower[1];
	uint32_t _fp_cam_control_lower;
} BCM56218_A0_FP_CAM_CONTROL_LOWERr_t;

#define BCM56218_A0_FP_CAM_CONTROL_LOWERr_CLR(r) (r).fp_cam_control_lower[0] = 0
#define BCM56218_A0_FP_CAM_CONTROL_LOWERr_SET(r,d) (r).fp_cam_control_lower[0] = d
#define BCM56218_A0_FP_CAM_CONTROL_LOWERr_GET(r) (r).fp_cam_control_lower[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_0f_GET(r) (((r).fp_cam_control_lower[0]) & 0x7)
#define BCM56218_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_0f_SET(r,f) (r).fp_cam_control_lower[0]=(((r).fp_cam_control_lower[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM56218_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_1f_GET(r) ((((r).fp_cam_control_lower[0]) >> 3) & 0x7)
#define BCM56218_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_1f_SET(r,f) (r).fp_cam_control_lower[0]=(((r).fp_cam_control_lower[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM56218_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_2f_GET(r) ((((r).fp_cam_control_lower[0]) >> 6) & 0x7)
#define BCM56218_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_2f_SET(r,f) (r).fp_cam_control_lower[0]=(((r).fp_cam_control_lower[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM56218_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_3f_GET(r) ((((r).fp_cam_control_lower[0]) >> 9) & 0x7)
#define BCM56218_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_3f_SET(r,f) (r).fp_cam_control_lower[0]=(((r).fp_cam_control_lower[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM56218_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_4f_GET(r) ((((r).fp_cam_control_lower[0]) >> 12) & 0x7)
#define BCM56218_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_4f_SET(r,f) (r).fp_cam_control_lower[0]=(((r).fp_cam_control_lower[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM56218_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_5f_GET(r) ((((r).fp_cam_control_lower[0]) >> 15) & 0x7)
#define BCM56218_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_5f_SET(r,f) (r).fp_cam_control_lower[0]=(((r).fp_cam_control_lower[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM56218_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_6f_GET(r) ((((r).fp_cam_control_lower[0]) >> 18) & 0x7)
#define BCM56218_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_6f_SET(r,f) (r).fp_cam_control_lower[0]=(((r).fp_cam_control_lower[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM56218_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_7f_GET(r) ((((r).fp_cam_control_lower[0]) >> 21) & 0x7)
#define BCM56218_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_7f_SET(r,f) (r).fp_cam_control_lower[0]=(((r).fp_cam_control_lower[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM56218_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_BIST_SKIP_COUNTf_GET(r) ((((r).fp_cam_control_lower[0]) >> 24) & 0xff)
#define BCM56218_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_BIST_SKIP_COUNTf_SET(r,f) (r).fp_cam_control_lower[0]=(((r).fp_cam_control_lower[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access FP_CAM_CONTROL_LOWER.
 *
 */
#define BCM56218_A0_READ_FP_CAM_CONTROL_LOWERr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_FP_CAM_CONTROL_LOWERr,(r._fp_cam_control_lower))
#define BCM56218_A0_WRITE_FP_CAM_CONTROL_LOWERr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_FP_CAM_CONTROL_LOWERr,&(r._fp_cam_control_lower))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_CAM_CONTROL_LOWERr BCM56218_A0_FP_CAM_CONTROL_LOWERr
#define FP_CAM_CONTROL_LOWERr_SIZE BCM56218_A0_FP_CAM_CONTROL_LOWERr_SIZE
typedef BCM56218_A0_FP_CAM_CONTROL_LOWERr_t FP_CAM_CONTROL_LOWERr_t;
#define FP_CAM_CONTROL_LOWERr_CLR BCM56218_A0_FP_CAM_CONTROL_LOWERr_CLR
#define FP_CAM_CONTROL_LOWERr_SET BCM56218_A0_FP_CAM_CONTROL_LOWERr_SET
#define FP_CAM_CONTROL_LOWERr_GET BCM56218_A0_FP_CAM_CONTROL_LOWERr_GET
#define FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_0f_GET BCM56218_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_0f_GET
#define FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_0f_SET BCM56218_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_0f_SET
#define FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_1f_GET BCM56218_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_1f_GET
#define FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_1f_SET BCM56218_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_1f_SET
#define FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_2f_GET BCM56218_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_2f_GET
#define FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_2f_SET BCM56218_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_2f_SET
#define FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_3f_GET BCM56218_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_3f_GET
#define FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_3f_SET BCM56218_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_3f_SET
#define FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_4f_GET BCM56218_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_4f_GET
#define FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_4f_SET BCM56218_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_4f_SET
#define FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_5f_GET BCM56218_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_5f_GET
#define FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_5f_SET BCM56218_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_5f_SET
#define FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_6f_GET BCM56218_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_6f_GET
#define FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_6f_SET BCM56218_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_6f_SET
#define FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_7f_GET BCM56218_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_7f_GET
#define FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_7f_SET BCM56218_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_7f_SET
#define FP_CAM_CONTROL_LOWERr_FP_CAM_BIST_SKIP_COUNTf_GET BCM56218_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_BIST_SKIP_COUNTf_GET
#define FP_CAM_CONTROL_LOWERr_FP_CAM_BIST_SKIP_COUNTf_SET BCM56218_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_BIST_SKIP_COUNTf_SET
#define READ_FP_CAM_CONTROL_LOWERr BCM56218_A0_READ_FP_CAM_CONTROL_LOWERr
#define WRITE_FP_CAM_CONTROL_LOWERr BCM56218_A0_WRITE_FP_CAM_CONTROL_LOWERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_FP_CAM_CONTROL_LOWERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  FP_CAM_DEBUG_DATA_0
 * BLOCKS:   IPIPE
 * DESC:     FP_CAM_DEBUG_DATA_0
 * SIZE:     32
 * FIELDS:
 *     LOAD_DATA        RESULTS IN LOADING INPUT DATA[29:0] AND THE TWO VALID BITS
 *
 ******************************************************************************/
#define BCM56218_A0_FP_CAM_DEBUG_DATA_0r 0x0c78000e

#define BCM56218_A0_FP_CAM_DEBUG_DATA_0r_SIZE 4

/*
 * This structure should be used to declare and program FP_CAM_DEBUG_DATA_0.
 *
 */
typedef union BCM56218_A0_FP_CAM_DEBUG_DATA_0r_s {
	uint32_t v[1];
	uint32_t fp_cam_debug_data_0[1];
	uint32_t _fp_cam_debug_data_0;
} BCM56218_A0_FP_CAM_DEBUG_DATA_0r_t;

#define BCM56218_A0_FP_CAM_DEBUG_DATA_0r_CLR(r) (r).fp_cam_debug_data_0[0] = 0
#define BCM56218_A0_FP_CAM_DEBUG_DATA_0r_SET(r,d) (r).fp_cam_debug_data_0[0] = d
#define BCM56218_A0_FP_CAM_DEBUG_DATA_0r_GET(r) (r).fp_cam_debug_data_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_FP_CAM_DEBUG_DATA_0r_LOAD_DATAf_GET(r) ((r).fp_cam_debug_data_0[0])
#define BCM56218_A0_FP_CAM_DEBUG_DATA_0r_LOAD_DATAf_SET(r,f) (r).fp_cam_debug_data_0[0]=((uint32_t)f)

/*
 * These macros can be used to access FP_CAM_DEBUG_DATA_0.
 *
 */
#define BCM56218_A0_READ_FP_CAM_DEBUG_DATA_0r(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_FP_CAM_DEBUG_DATA_0r,(r._fp_cam_debug_data_0))
#define BCM56218_A0_WRITE_FP_CAM_DEBUG_DATA_0r(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_FP_CAM_DEBUG_DATA_0r,&(r._fp_cam_debug_data_0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_CAM_DEBUG_DATA_0r BCM56218_A0_FP_CAM_DEBUG_DATA_0r
#define FP_CAM_DEBUG_DATA_0r_SIZE BCM56218_A0_FP_CAM_DEBUG_DATA_0r_SIZE
typedef BCM56218_A0_FP_CAM_DEBUG_DATA_0r_t FP_CAM_DEBUG_DATA_0r_t;
#define FP_CAM_DEBUG_DATA_0r_CLR BCM56218_A0_FP_CAM_DEBUG_DATA_0r_CLR
#define FP_CAM_DEBUG_DATA_0r_SET BCM56218_A0_FP_CAM_DEBUG_DATA_0r_SET
#define FP_CAM_DEBUG_DATA_0r_GET BCM56218_A0_FP_CAM_DEBUG_DATA_0r_GET
#define FP_CAM_DEBUG_DATA_0r_LOAD_DATAf_GET BCM56218_A0_FP_CAM_DEBUG_DATA_0r_LOAD_DATAf_GET
#define FP_CAM_DEBUG_DATA_0r_LOAD_DATAf_SET BCM56218_A0_FP_CAM_DEBUG_DATA_0r_LOAD_DATAf_SET
#define READ_FP_CAM_DEBUG_DATA_0r BCM56218_A0_READ_FP_CAM_DEBUG_DATA_0r
#define WRITE_FP_CAM_DEBUG_DATA_0r BCM56218_A0_WRITE_FP_CAM_DEBUG_DATA_0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_FP_CAM_DEBUG_DATA_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  FP_CAM_DEBUG_DATA_1
 * BLOCKS:   IPIPE
 * DESC:     FP_CAM_DEBUG_DATA_1
 * SIZE:     32
 * FIELDS:
 *     LOAD_DATA        RESULTS IN LOADING INPUT DATA[61:30] 
 *
 ******************************************************************************/
#define BCM56218_A0_FP_CAM_DEBUG_DATA_1r 0x0c78000f

#define BCM56218_A0_FP_CAM_DEBUG_DATA_1r_SIZE 4

/*
 * This structure should be used to declare and program FP_CAM_DEBUG_DATA_1.
 *
 */
typedef union BCM56218_A0_FP_CAM_DEBUG_DATA_1r_s {
	uint32_t v[1];
	uint32_t fp_cam_debug_data_1[1];
	uint32_t _fp_cam_debug_data_1;
} BCM56218_A0_FP_CAM_DEBUG_DATA_1r_t;

#define BCM56218_A0_FP_CAM_DEBUG_DATA_1r_CLR(r) (r).fp_cam_debug_data_1[0] = 0
#define BCM56218_A0_FP_CAM_DEBUG_DATA_1r_SET(r,d) (r).fp_cam_debug_data_1[0] = d
#define BCM56218_A0_FP_CAM_DEBUG_DATA_1r_GET(r) (r).fp_cam_debug_data_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_FP_CAM_DEBUG_DATA_1r_LOAD_DATAf_GET(r) ((r).fp_cam_debug_data_1[0])
#define BCM56218_A0_FP_CAM_DEBUG_DATA_1r_LOAD_DATAf_SET(r,f) (r).fp_cam_debug_data_1[0]=((uint32_t)f)

/*
 * These macros can be used to access FP_CAM_DEBUG_DATA_1.
 *
 */
#define BCM56218_A0_READ_FP_CAM_DEBUG_DATA_1r(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_FP_CAM_DEBUG_DATA_1r,(r._fp_cam_debug_data_1))
#define BCM56218_A0_WRITE_FP_CAM_DEBUG_DATA_1r(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_FP_CAM_DEBUG_DATA_1r,&(r._fp_cam_debug_data_1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_CAM_DEBUG_DATA_1r BCM56218_A0_FP_CAM_DEBUG_DATA_1r
#define FP_CAM_DEBUG_DATA_1r_SIZE BCM56218_A0_FP_CAM_DEBUG_DATA_1r_SIZE
typedef BCM56218_A0_FP_CAM_DEBUG_DATA_1r_t FP_CAM_DEBUG_DATA_1r_t;
#define FP_CAM_DEBUG_DATA_1r_CLR BCM56218_A0_FP_CAM_DEBUG_DATA_1r_CLR
#define FP_CAM_DEBUG_DATA_1r_SET BCM56218_A0_FP_CAM_DEBUG_DATA_1r_SET
#define FP_CAM_DEBUG_DATA_1r_GET BCM56218_A0_FP_CAM_DEBUG_DATA_1r_GET
#define FP_CAM_DEBUG_DATA_1r_LOAD_DATAf_GET BCM56218_A0_FP_CAM_DEBUG_DATA_1r_LOAD_DATAf_GET
#define FP_CAM_DEBUG_DATA_1r_LOAD_DATAf_SET BCM56218_A0_FP_CAM_DEBUG_DATA_1r_LOAD_DATAf_SET
#define READ_FP_CAM_DEBUG_DATA_1r BCM56218_A0_READ_FP_CAM_DEBUG_DATA_1r
#define WRITE_FP_CAM_DEBUG_DATA_1r BCM56218_A0_WRITE_FP_CAM_DEBUG_DATA_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_FP_CAM_DEBUG_DATA_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  FP_CAM_DEBUG_DATA_2
 * BLOCKS:   IPIPE
 * DESC:     FP_CAM_DEBUG_DATA_2
 * SIZE:     32
 * FIELDS:
 *     LOAD_DATA        RESULTS IN LOADING INPUT DATA[93:62] 
 *
 ******************************************************************************/
#define BCM56218_A0_FP_CAM_DEBUG_DATA_2r 0x0c780010

#define BCM56218_A0_FP_CAM_DEBUG_DATA_2r_SIZE 4

/*
 * This structure should be used to declare and program FP_CAM_DEBUG_DATA_2.
 *
 */
typedef union BCM56218_A0_FP_CAM_DEBUG_DATA_2r_s {
	uint32_t v[1];
	uint32_t fp_cam_debug_data_2[1];
	uint32_t _fp_cam_debug_data_2;
} BCM56218_A0_FP_CAM_DEBUG_DATA_2r_t;

#define BCM56218_A0_FP_CAM_DEBUG_DATA_2r_CLR(r) (r).fp_cam_debug_data_2[0] = 0
#define BCM56218_A0_FP_CAM_DEBUG_DATA_2r_SET(r,d) (r).fp_cam_debug_data_2[0] = d
#define BCM56218_A0_FP_CAM_DEBUG_DATA_2r_GET(r) (r).fp_cam_debug_data_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_FP_CAM_DEBUG_DATA_2r_LOAD_DATAf_GET(r) ((r).fp_cam_debug_data_2[0])
#define BCM56218_A0_FP_CAM_DEBUG_DATA_2r_LOAD_DATAf_SET(r,f) (r).fp_cam_debug_data_2[0]=((uint32_t)f)

/*
 * These macros can be used to access FP_CAM_DEBUG_DATA_2.
 *
 */
#define BCM56218_A0_READ_FP_CAM_DEBUG_DATA_2r(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_FP_CAM_DEBUG_DATA_2r,(r._fp_cam_debug_data_2))
#define BCM56218_A0_WRITE_FP_CAM_DEBUG_DATA_2r(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_FP_CAM_DEBUG_DATA_2r,&(r._fp_cam_debug_data_2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_CAM_DEBUG_DATA_2r BCM56218_A0_FP_CAM_DEBUG_DATA_2r
#define FP_CAM_DEBUG_DATA_2r_SIZE BCM56218_A0_FP_CAM_DEBUG_DATA_2r_SIZE
typedef BCM56218_A0_FP_CAM_DEBUG_DATA_2r_t FP_CAM_DEBUG_DATA_2r_t;
#define FP_CAM_DEBUG_DATA_2r_CLR BCM56218_A0_FP_CAM_DEBUG_DATA_2r_CLR
#define FP_CAM_DEBUG_DATA_2r_SET BCM56218_A0_FP_CAM_DEBUG_DATA_2r_SET
#define FP_CAM_DEBUG_DATA_2r_GET BCM56218_A0_FP_CAM_DEBUG_DATA_2r_GET
#define FP_CAM_DEBUG_DATA_2r_LOAD_DATAf_GET BCM56218_A0_FP_CAM_DEBUG_DATA_2r_LOAD_DATAf_GET
#define FP_CAM_DEBUG_DATA_2r_LOAD_DATAf_SET BCM56218_A0_FP_CAM_DEBUG_DATA_2r_LOAD_DATAf_SET
#define READ_FP_CAM_DEBUG_DATA_2r BCM56218_A0_READ_FP_CAM_DEBUG_DATA_2r
#define WRITE_FP_CAM_DEBUG_DATA_2r BCM56218_A0_WRITE_FP_CAM_DEBUG_DATA_2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_FP_CAM_DEBUG_DATA_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  FP_CAM_DEBUG_DATA_3
 * BLOCKS:   IPIPE
 * DESC:     FP_CAM_DEBUG_DATA_3
 * SIZE:     32
 * FIELDS:
 *     LOAD_DATA        RESULTS IN LOADING INPUT DATA[125:94] 
 *
 ******************************************************************************/
#define BCM56218_A0_FP_CAM_DEBUG_DATA_3r 0x0c780011

#define BCM56218_A0_FP_CAM_DEBUG_DATA_3r_SIZE 4

/*
 * This structure should be used to declare and program FP_CAM_DEBUG_DATA_3.
 *
 */
typedef union BCM56218_A0_FP_CAM_DEBUG_DATA_3r_s {
	uint32_t v[1];
	uint32_t fp_cam_debug_data_3[1];
	uint32_t _fp_cam_debug_data_3;
} BCM56218_A0_FP_CAM_DEBUG_DATA_3r_t;

#define BCM56218_A0_FP_CAM_DEBUG_DATA_3r_CLR(r) (r).fp_cam_debug_data_3[0] = 0
#define BCM56218_A0_FP_CAM_DEBUG_DATA_3r_SET(r,d) (r).fp_cam_debug_data_3[0] = d
#define BCM56218_A0_FP_CAM_DEBUG_DATA_3r_GET(r) (r).fp_cam_debug_data_3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_FP_CAM_DEBUG_DATA_3r_LOAD_DATAf_GET(r) ((r).fp_cam_debug_data_3[0])
#define BCM56218_A0_FP_CAM_DEBUG_DATA_3r_LOAD_DATAf_SET(r,f) (r).fp_cam_debug_data_3[0]=((uint32_t)f)

/*
 * These macros can be used to access FP_CAM_DEBUG_DATA_3.
 *
 */
#define BCM56218_A0_READ_FP_CAM_DEBUG_DATA_3r(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_FP_CAM_DEBUG_DATA_3r,(r._fp_cam_debug_data_3))
#define BCM56218_A0_WRITE_FP_CAM_DEBUG_DATA_3r(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_FP_CAM_DEBUG_DATA_3r,&(r._fp_cam_debug_data_3))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_CAM_DEBUG_DATA_3r BCM56218_A0_FP_CAM_DEBUG_DATA_3r
#define FP_CAM_DEBUG_DATA_3r_SIZE BCM56218_A0_FP_CAM_DEBUG_DATA_3r_SIZE
typedef BCM56218_A0_FP_CAM_DEBUG_DATA_3r_t FP_CAM_DEBUG_DATA_3r_t;
#define FP_CAM_DEBUG_DATA_3r_CLR BCM56218_A0_FP_CAM_DEBUG_DATA_3r_CLR
#define FP_CAM_DEBUG_DATA_3r_SET BCM56218_A0_FP_CAM_DEBUG_DATA_3r_SET
#define FP_CAM_DEBUG_DATA_3r_GET BCM56218_A0_FP_CAM_DEBUG_DATA_3r_GET
#define FP_CAM_DEBUG_DATA_3r_LOAD_DATAf_GET BCM56218_A0_FP_CAM_DEBUG_DATA_3r_LOAD_DATAf_GET
#define FP_CAM_DEBUG_DATA_3r_LOAD_DATAf_SET BCM56218_A0_FP_CAM_DEBUG_DATA_3r_LOAD_DATAf_SET
#define READ_FP_CAM_DEBUG_DATA_3r BCM56218_A0_READ_FP_CAM_DEBUG_DATA_3r
#define WRITE_FP_CAM_DEBUG_DATA_3r BCM56218_A0_WRITE_FP_CAM_DEBUG_DATA_3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_FP_CAM_DEBUG_DATA_3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  FP_CAM_DEBUG_DATA_4
 * BLOCKS:   IPIPE
 * DESC:     FP_CAM_DEBUG_DATA_4
 * SIZE:     32
 * FIELDS:
 *     LOAD_DATA        RESULTS IN LOADING INPUT DATA[157:126] 
 *
 ******************************************************************************/
#define BCM56218_A0_FP_CAM_DEBUG_DATA_4r 0x0c780012

#define BCM56218_A0_FP_CAM_DEBUG_DATA_4r_SIZE 4

/*
 * This structure should be used to declare and program FP_CAM_DEBUG_DATA_4.
 *
 */
typedef union BCM56218_A0_FP_CAM_DEBUG_DATA_4r_s {
	uint32_t v[1];
	uint32_t fp_cam_debug_data_4[1];
	uint32_t _fp_cam_debug_data_4;
} BCM56218_A0_FP_CAM_DEBUG_DATA_4r_t;

#define BCM56218_A0_FP_CAM_DEBUG_DATA_4r_CLR(r) (r).fp_cam_debug_data_4[0] = 0
#define BCM56218_A0_FP_CAM_DEBUG_DATA_4r_SET(r,d) (r).fp_cam_debug_data_4[0] = d
#define BCM56218_A0_FP_CAM_DEBUG_DATA_4r_GET(r) (r).fp_cam_debug_data_4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_FP_CAM_DEBUG_DATA_4r_LOAD_DATAf_GET(r) ((r).fp_cam_debug_data_4[0])
#define BCM56218_A0_FP_CAM_DEBUG_DATA_4r_LOAD_DATAf_SET(r,f) (r).fp_cam_debug_data_4[0]=((uint32_t)f)

/*
 * These macros can be used to access FP_CAM_DEBUG_DATA_4.
 *
 */
#define BCM56218_A0_READ_FP_CAM_DEBUG_DATA_4r(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_FP_CAM_DEBUG_DATA_4r,(r._fp_cam_debug_data_4))
#define BCM56218_A0_WRITE_FP_CAM_DEBUG_DATA_4r(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_FP_CAM_DEBUG_DATA_4r,&(r._fp_cam_debug_data_4))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_CAM_DEBUG_DATA_4r BCM56218_A0_FP_CAM_DEBUG_DATA_4r
#define FP_CAM_DEBUG_DATA_4r_SIZE BCM56218_A0_FP_CAM_DEBUG_DATA_4r_SIZE
typedef BCM56218_A0_FP_CAM_DEBUG_DATA_4r_t FP_CAM_DEBUG_DATA_4r_t;
#define FP_CAM_DEBUG_DATA_4r_CLR BCM56218_A0_FP_CAM_DEBUG_DATA_4r_CLR
#define FP_CAM_DEBUG_DATA_4r_SET BCM56218_A0_FP_CAM_DEBUG_DATA_4r_SET
#define FP_CAM_DEBUG_DATA_4r_GET BCM56218_A0_FP_CAM_DEBUG_DATA_4r_GET
#define FP_CAM_DEBUG_DATA_4r_LOAD_DATAf_GET BCM56218_A0_FP_CAM_DEBUG_DATA_4r_LOAD_DATAf_GET
#define FP_CAM_DEBUG_DATA_4r_LOAD_DATAf_SET BCM56218_A0_FP_CAM_DEBUG_DATA_4r_LOAD_DATAf_SET
#define READ_FP_CAM_DEBUG_DATA_4r BCM56218_A0_READ_FP_CAM_DEBUG_DATA_4r
#define WRITE_FP_CAM_DEBUG_DATA_4r BCM56218_A0_WRITE_FP_CAM_DEBUG_DATA_4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_FP_CAM_DEBUG_DATA_4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  FP_CAM_DEBUG_DATA_5
 * BLOCKS:   IPIPE
 * DESC:     FP_CAM_DEBUG_DATA_5
 * SIZE:     32
 * FIELDS:
 *     LOAD_DATA        RESULTS IN LOADING INPUT DATA[183:158] 
 *
 ******************************************************************************/
#define BCM56218_A0_FP_CAM_DEBUG_DATA_5r 0x0c780013

#define BCM56218_A0_FP_CAM_DEBUG_DATA_5r_SIZE 4

/*
 * This structure should be used to declare and program FP_CAM_DEBUG_DATA_5.
 *
 */
typedef union BCM56218_A0_FP_CAM_DEBUG_DATA_5r_s {
	uint32_t v[1];
	uint32_t fp_cam_debug_data_5[1];
	uint32_t _fp_cam_debug_data_5;
} BCM56218_A0_FP_CAM_DEBUG_DATA_5r_t;

#define BCM56218_A0_FP_CAM_DEBUG_DATA_5r_CLR(r) (r).fp_cam_debug_data_5[0] = 0
#define BCM56218_A0_FP_CAM_DEBUG_DATA_5r_SET(r,d) (r).fp_cam_debug_data_5[0] = d
#define BCM56218_A0_FP_CAM_DEBUG_DATA_5r_GET(r) (r).fp_cam_debug_data_5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_FP_CAM_DEBUG_DATA_5r_LOAD_DATAf_GET(r) (((r).fp_cam_debug_data_5[0]) & 0x3ffffff)
#define BCM56218_A0_FP_CAM_DEBUG_DATA_5r_LOAD_DATAf_SET(r,f) (r).fp_cam_debug_data_5[0]=(((r).fp_cam_debug_data_5[0] & ~((uint32_t)0x3ffffff)) | (((uint32_t)f) & 0x3ffffff))

/*
 * These macros can be used to access FP_CAM_DEBUG_DATA_5.
 *
 */
#define BCM56218_A0_READ_FP_CAM_DEBUG_DATA_5r(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_FP_CAM_DEBUG_DATA_5r,(r._fp_cam_debug_data_5))
#define BCM56218_A0_WRITE_FP_CAM_DEBUG_DATA_5r(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_FP_CAM_DEBUG_DATA_5r,&(r._fp_cam_debug_data_5))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_CAM_DEBUG_DATA_5r BCM56218_A0_FP_CAM_DEBUG_DATA_5r
#define FP_CAM_DEBUG_DATA_5r_SIZE BCM56218_A0_FP_CAM_DEBUG_DATA_5r_SIZE
typedef BCM56218_A0_FP_CAM_DEBUG_DATA_5r_t FP_CAM_DEBUG_DATA_5r_t;
#define FP_CAM_DEBUG_DATA_5r_CLR BCM56218_A0_FP_CAM_DEBUG_DATA_5r_CLR
#define FP_CAM_DEBUG_DATA_5r_SET BCM56218_A0_FP_CAM_DEBUG_DATA_5r_SET
#define FP_CAM_DEBUG_DATA_5r_GET BCM56218_A0_FP_CAM_DEBUG_DATA_5r_GET
#define FP_CAM_DEBUG_DATA_5r_LOAD_DATAf_GET BCM56218_A0_FP_CAM_DEBUG_DATA_5r_LOAD_DATAf_GET
#define FP_CAM_DEBUG_DATA_5r_LOAD_DATAf_SET BCM56218_A0_FP_CAM_DEBUG_DATA_5r_LOAD_DATAf_SET
#define READ_FP_CAM_DEBUG_DATA_5r BCM56218_A0_READ_FP_CAM_DEBUG_DATA_5r
#define WRITE_FP_CAM_DEBUG_DATA_5r BCM56218_A0_WRITE_FP_CAM_DEBUG_DATA_5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_FP_CAM_DEBUG_DATA_5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  FP_CAM_DEBUG_SEND
 * BLOCKS:   IPIPE
 * DESC:     FP_CAM_DEBUG_SEND
 * SIZE:     32
 * FIELDS:
 *     LOAD_DATA        RESULTS IN SENDING CAM DEBUG COMPARE CYCLE
 *
 ******************************************************************************/
#define BCM56218_A0_FP_CAM_DEBUG_SENDr 0x0c780015

#define BCM56218_A0_FP_CAM_DEBUG_SENDr_SIZE 4

/*
 * This structure should be used to declare and program FP_CAM_DEBUG_SEND.
 *
 */
typedef union BCM56218_A0_FP_CAM_DEBUG_SENDr_s {
	uint32_t v[1];
	uint32_t fp_cam_debug_send[1];
	uint32_t _fp_cam_debug_send;
} BCM56218_A0_FP_CAM_DEBUG_SENDr_t;

#define BCM56218_A0_FP_CAM_DEBUG_SENDr_CLR(r) (r).fp_cam_debug_send[0] = 0
#define BCM56218_A0_FP_CAM_DEBUG_SENDr_SET(r,d) (r).fp_cam_debug_send[0] = d
#define BCM56218_A0_FP_CAM_DEBUG_SENDr_GET(r) (r).fp_cam_debug_send[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_FP_CAM_DEBUG_SENDr_LOAD_DATAf_GET(r) (((r).fp_cam_debug_send[0]) & 0x1)
#define BCM56218_A0_FP_CAM_DEBUG_SENDr_LOAD_DATAf_SET(r,f) (r).fp_cam_debug_send[0]=(((r).fp_cam_debug_send[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access FP_CAM_DEBUG_SEND.
 *
 */
#define BCM56218_A0_READ_FP_CAM_DEBUG_SENDr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_FP_CAM_DEBUG_SENDr,(r._fp_cam_debug_send))
#define BCM56218_A0_WRITE_FP_CAM_DEBUG_SENDr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_FP_CAM_DEBUG_SENDr,&(r._fp_cam_debug_send))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_CAM_DEBUG_SENDr BCM56218_A0_FP_CAM_DEBUG_SENDr
#define FP_CAM_DEBUG_SENDr_SIZE BCM56218_A0_FP_CAM_DEBUG_SENDr_SIZE
typedef BCM56218_A0_FP_CAM_DEBUG_SENDr_t FP_CAM_DEBUG_SENDr_t;
#define FP_CAM_DEBUG_SENDr_CLR BCM56218_A0_FP_CAM_DEBUG_SENDr_CLR
#define FP_CAM_DEBUG_SENDr_SET BCM56218_A0_FP_CAM_DEBUG_SENDr_SET
#define FP_CAM_DEBUG_SENDr_GET BCM56218_A0_FP_CAM_DEBUG_SENDr_GET
#define FP_CAM_DEBUG_SENDr_LOAD_DATAf_GET BCM56218_A0_FP_CAM_DEBUG_SENDr_LOAD_DATAf_GET
#define FP_CAM_DEBUG_SENDr_LOAD_DATAf_SET BCM56218_A0_FP_CAM_DEBUG_SENDr_LOAD_DATAf_SET
#define READ_FP_CAM_DEBUG_SENDr BCM56218_A0_READ_FP_CAM_DEBUG_SENDr
#define WRITE_FP_CAM_DEBUG_SENDr BCM56218_A0_WRITE_FP_CAM_DEBUG_SENDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_FP_CAM_DEBUG_SENDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  FP_COUNTER_TABLE
 * BLOCKS:   IPIPE
 * DESC:     COUNTER TABLE FOR THE FP
 * SIZE:     32
 * FIELDS:
 *     COUNTER          COUNTER
 *
 ******************************************************************************/
#define BCM56218_A0_FP_COUNTER_TABLEm 0x0c770000

#define BCM56218_A0_FP_COUNTER_TABLEm_MIN 0
#define BCM56218_A0_FP_COUNTER_TABLEm_MAX 1023
#define BCM56218_A0_FP_COUNTER_TABLEm_CMAX(u) cdk_xgs_mem_maxidx(u,BCM56218_A0_FP_COUNTER_TABLEm,1023)
#define BCM56218_A0_FP_COUNTER_TABLEm_SIZE 4

/*
 * This structure should be used to declare and program FP_COUNTER_TABLE.
 *
 */
typedef union BCM56218_A0_FP_COUNTER_TABLEm_s {
	uint32_t v[1];
	uint32_t fp_counter_table[1];
	uint32_t _fp_counter_table;
} BCM56218_A0_FP_COUNTER_TABLEm_t;

#define BCM56218_A0_FP_COUNTER_TABLEm_CLR(r) (r).fp_counter_table[0] = 0
#define BCM56218_A0_FP_COUNTER_TABLEm_SET(r,d) (r).fp_counter_table[0] = d
#define BCM56218_A0_FP_COUNTER_TABLEm_GET(r) (r).fp_counter_table[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_FP_COUNTER_TABLEm_COUNTERf_GET(r) ((r).fp_counter_table[0])
#define BCM56218_A0_FP_COUNTER_TABLEm_COUNTERf_SET(r,f) (r).fp_counter_table[0]=((uint32_t)f)

/*
 * These macros can be used to access FP_COUNTER_TABLE.
 *
 */
#define BCM56218_A0_READ_FP_COUNTER_TABLEm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_FP_COUNTER_TABLEm,i,(m._fp_counter_table),1)
#define BCM56218_A0_WRITE_FP_COUNTER_TABLEm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_FP_COUNTER_TABLEm,i,&(m._fp_counter_table),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_COUNTER_TABLEm BCM56218_A0_FP_COUNTER_TABLEm
#define FP_COUNTER_TABLEm_MIN BCM56218_A0_FP_COUNTER_TABLEm_MIN
#define FP_COUNTER_TABLEm_MAX BCM56218_A0_FP_COUNTER_TABLEm_MAX
#define FP_COUNTER_TABLEm_CMAX(u) BCM56218_A0_FP_COUNTER_TABLEm_CMAX(u)
#define FP_COUNTER_TABLEm_SIZE BCM56218_A0_FP_COUNTER_TABLEm_SIZE
typedef BCM56218_A0_FP_COUNTER_TABLEm_t FP_COUNTER_TABLEm_t;
#define FP_COUNTER_TABLEm_CLR BCM56218_A0_FP_COUNTER_TABLEm_CLR
#define FP_COUNTER_TABLEm_SET BCM56218_A0_FP_COUNTER_TABLEm_SET
#define FP_COUNTER_TABLEm_GET BCM56218_A0_FP_COUNTER_TABLEm_GET
#define FP_COUNTER_TABLEm_COUNTERf_GET BCM56218_A0_FP_COUNTER_TABLEm_COUNTERf_GET
#define FP_COUNTER_TABLEm_COUNTERf_SET BCM56218_A0_FP_COUNTER_TABLEm_COUNTERf_SET
#define READ_FP_COUNTER_TABLEm BCM56218_A0_READ_FP_COUNTER_TABLEm
#define WRITE_FP_COUNTER_TABLEm BCM56218_A0_WRITE_FP_COUNTER_TABLEm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_FP_COUNTER_TABLEm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  FP_METER_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     FP_METER_CONTROL
 * SIZE:     32
 * FIELDS:
 *     PACKET_IFG_BYTES BYTES TO ADD IN ADDITION TO THE PACKET BYTE COUNT FOR METERING
 *
 ******************************************************************************/
#define BCM56218_A0_FP_METER_CONTROLr 0x0c78000c

#define BCM56218_A0_FP_METER_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program FP_METER_CONTROL.
 *
 */
typedef union BCM56218_A0_FP_METER_CONTROLr_s {
	uint32_t v[1];
	uint32_t fp_meter_control[1];
	uint32_t _fp_meter_control;
} BCM56218_A0_FP_METER_CONTROLr_t;

#define BCM56218_A0_FP_METER_CONTROLr_CLR(r) (r).fp_meter_control[0] = 0
#define BCM56218_A0_FP_METER_CONTROLr_SET(r,d) (r).fp_meter_control[0] = d
#define BCM56218_A0_FP_METER_CONTROLr_GET(r) (r).fp_meter_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_FP_METER_CONTROLr_PACKET_IFG_BYTESf_GET(r) (((r).fp_meter_control[0]) & 0x1f)
#define BCM56218_A0_FP_METER_CONTROLr_PACKET_IFG_BYTESf_SET(r,f) (r).fp_meter_control[0]=(((r).fp_meter_control[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))

/*
 * These macros can be used to access FP_METER_CONTROL.
 *
 */
#define BCM56218_A0_READ_FP_METER_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_FP_METER_CONTROLr,(r._fp_meter_control))
#define BCM56218_A0_WRITE_FP_METER_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_FP_METER_CONTROLr,&(r._fp_meter_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_METER_CONTROLr BCM56218_A0_FP_METER_CONTROLr
#define FP_METER_CONTROLr_SIZE BCM56218_A0_FP_METER_CONTROLr_SIZE
typedef BCM56218_A0_FP_METER_CONTROLr_t FP_METER_CONTROLr_t;
#define FP_METER_CONTROLr_CLR BCM56218_A0_FP_METER_CONTROLr_CLR
#define FP_METER_CONTROLr_SET BCM56218_A0_FP_METER_CONTROLr_SET
#define FP_METER_CONTROLr_GET BCM56218_A0_FP_METER_CONTROLr_GET
#define FP_METER_CONTROLr_PACKET_IFG_BYTESf_GET BCM56218_A0_FP_METER_CONTROLr_PACKET_IFG_BYTESf_GET
#define FP_METER_CONTROLr_PACKET_IFG_BYTESf_SET BCM56218_A0_FP_METER_CONTROLr_PACKET_IFG_BYTESf_SET
#define READ_FP_METER_CONTROLr BCM56218_A0_READ_FP_METER_CONTROLr
#define WRITE_FP_METER_CONTROLr BCM56218_A0_WRITE_FP_METER_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_FP_METER_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  FP_METER_TABLE
 * BLOCKS:   IPIPE
 * DESC:     METER TABLE STRUCTURES FOR THE FP
 * SIZE:     54
 * FIELDS:
 *     BUCKETCOUNT      BUCKETCOUNT
 *     BUCKETSIZE       BUCKETSIZE
 *     REFRESHCOUNT     REFRESHCOUNT
 *     REFRESH_MODE     REFRESH_MODE
 *
 ******************************************************************************/
#define BCM56218_A0_FP_METER_TABLEm 0x0c760000

#define BCM56218_A0_FP_METER_TABLEm_MIN 0
#define BCM56218_A0_FP_METER_TABLEm_MAX 1023
#define BCM56218_A0_FP_METER_TABLEm_CMAX(u) cdk_xgs_mem_maxidx(u,BCM56218_A0_FP_METER_TABLEm,1023)
#define BCM56218_A0_FP_METER_TABLEm_SIZE 7

/*
 * This structure should be used to declare and program FP_METER_TABLE.
 *
 */
typedef union BCM56218_A0_FP_METER_TABLEm_s {
	uint32_t v[2];
	uint32_t fp_meter_table[2];
	uint32_t _fp_meter_table;
} BCM56218_A0_FP_METER_TABLEm_t;

#define BCM56218_A0_FP_METER_TABLEm_CLR(r) CDK_MEMSET(&((r)._fp_meter_table), 0, sizeof(BCM56218_A0_FP_METER_TABLEm_t))
#define BCM56218_A0_FP_METER_TABLEm_SET(r,i,d) (r).fp_meter_table[i] = d
#define BCM56218_A0_FP_METER_TABLEm_GET(r,i) (r).fp_meter_table[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_FP_METER_TABLEm_BUCKETCOUNTf_GET(r) (((r).fp_meter_table[0]) & 0x3fffffff)
#define BCM56218_A0_FP_METER_TABLEm_BUCKETCOUNTf_SET(r,f) (r).fp_meter_table[0]=(((r).fp_meter_table[0] & ~((uint32_t)0x3fffffff)) | (((uint32_t)f) & 0x3fffffff))
#define BCM56218_A0_FP_METER_TABLEm_BUCKETSIZEf_GET(r) cdk_field32_get((r).fp_meter_table,30,33)
#define BCM56218_A0_FP_METER_TABLEm_BUCKETSIZEf_SET(r,f) cdk_field32_set((r).fp_meter_table,30,33,f)
#define BCM56218_A0_FP_METER_TABLEm_REFRESHCOUNTf_GET(r) ((((r).fp_meter_table[1]) >> 2) & 0x7ffff)
#define BCM56218_A0_FP_METER_TABLEm_REFRESHCOUNTf_SET(r,f) (r).fp_meter_table[1]=(((r).fp_meter_table[1] & ~((uint32_t)0x7ffff << 2)) | ((((uint32_t)f) & 0x7ffff) << 2))
#define BCM56218_A0_FP_METER_TABLEm_REFRESH_MODEf_GET(r) ((((r).fp_meter_table[1]) >> 21) & 0x1)
#define BCM56218_A0_FP_METER_TABLEm_REFRESH_MODEf_SET(r,f) (r).fp_meter_table[1]=(((r).fp_meter_table[1] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))

/*
 * These macros can be used to access FP_METER_TABLE.
 *
 */
#define BCM56218_A0_READ_FP_METER_TABLEm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_FP_METER_TABLEm,i,(m._fp_meter_table),2)
#define BCM56218_A0_WRITE_FP_METER_TABLEm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_FP_METER_TABLEm,i,&(m._fp_meter_table),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_METER_TABLEm BCM56218_A0_FP_METER_TABLEm
#define FP_METER_TABLEm_MIN BCM56218_A0_FP_METER_TABLEm_MIN
#define FP_METER_TABLEm_MAX BCM56218_A0_FP_METER_TABLEm_MAX
#define FP_METER_TABLEm_CMAX(u) BCM56218_A0_FP_METER_TABLEm_CMAX(u)
#define FP_METER_TABLEm_SIZE BCM56218_A0_FP_METER_TABLEm_SIZE
typedef BCM56218_A0_FP_METER_TABLEm_t FP_METER_TABLEm_t;
#define FP_METER_TABLEm_CLR BCM56218_A0_FP_METER_TABLEm_CLR
#define FP_METER_TABLEm_SET BCM56218_A0_FP_METER_TABLEm_SET
#define FP_METER_TABLEm_GET BCM56218_A0_FP_METER_TABLEm_GET
#define FP_METER_TABLEm_BUCKETCOUNTf_GET BCM56218_A0_FP_METER_TABLEm_BUCKETCOUNTf_GET
#define FP_METER_TABLEm_BUCKETCOUNTf_SET BCM56218_A0_FP_METER_TABLEm_BUCKETCOUNTf_SET
#define FP_METER_TABLEm_BUCKETSIZEf_GET BCM56218_A0_FP_METER_TABLEm_BUCKETSIZEf_GET
#define FP_METER_TABLEm_BUCKETSIZEf_SET BCM56218_A0_FP_METER_TABLEm_BUCKETSIZEf_SET
#define FP_METER_TABLEm_REFRESHCOUNTf_GET BCM56218_A0_FP_METER_TABLEm_REFRESHCOUNTf_GET
#define FP_METER_TABLEm_REFRESHCOUNTf_SET BCM56218_A0_FP_METER_TABLEm_REFRESHCOUNTf_SET
#define FP_METER_TABLEm_REFRESH_MODEf_GET BCM56218_A0_FP_METER_TABLEm_REFRESH_MODEf_GET
#define FP_METER_TABLEm_REFRESH_MODEf_SET BCM56218_A0_FP_METER_TABLEm_REFRESH_MODEf_SET
#define READ_FP_METER_TABLEm BCM56218_A0_READ_FP_METER_TABLEm
#define WRITE_FP_METER_TABLEm BCM56218_A0_WRITE_FP_METER_TABLEm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_FP_METER_TABLEm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  FP_POLICY_TABLE
 * BLOCKS:   IPIPE
 * DESC:     POLICY TABLE FOR DETERMINING ACTIONS IN THE FP
 * SIZE:     168
 * FIELDS:
 *     EM_MTP_INDEX     EM_MTP_INDEX
 *     IM_MTP_INDEX     IM_MTP_INDEX
 *     MTP_INDEX_SPARE  MTP_INDEX_SPARE
 *     REDIRECTION      REDIRECTION
 *     REDIRECTION_LO   REDIRECTION
 *     REDIRECTION_HI   REDIRECTION
 *     CHAIN_INDEX      CHAIN_INDEX
 *     CHAIN_VALID      CHAIN_VALID
 *     CLASSIFICATION_TAG CLASSIFICATION_TAG
 *     ECMP_PTR         ECMP_PTR
 *     NEXT_HOP_INDEX   NEXT_HOP_INDEX
 *     MATCHED_RULE     MATCHED_RULE
 *     ECMP_COUNT       ECMP_COUNT
 *     ECMP             ECMP
 *     DO_NOT_CHANGE_TTL DO_NOT_CHANGE_TTL
 *     YP_DSCP          YP_DSCP
 *     RP_DSCP          RP_DSCP
 *     NEWDSCP_TOS      NEWDSCP_TOS
 *     NEWPRI           NEWPRI
 *     METER_PAIR_MODE  METER_PAIR_MODE
 *     METER_TEST_EVEN  METER_TEST_EVEN
 *     METER_TEST_ODD   METER_TEST_ODD
 *     METER_UPDATE_EVEN METER_UPDATE_EVEN
 *     METER_UPDATE_ODD METER_UPDATE_ODD
 *     METER_INDEX_EVEN METER_INDEX_EVEN
 *     METER_INDEX_ODD  METER_INDEX_ODD
 *     COUNTER_MODE     COUNTER_MODE
 *     COUNTER_INDEX    COUNTER_INDEX
 *     YP_CHANGE_DSCP   YP_CHANGE_DSCP
 *     YP_COPY_TO_CPU   YP_COPY_TO_CPU
 *     YP_DROP_PRECEDENCE YP_DROP_PRECEDENCE
 *     YP_DROP          YP_DROP
 *     RP_CHANGE_DSCP   RP_CHANGE_DSCP
 *     RP_COPY_TO_CPU   RP_COPY_TO_CPU
 *     RP_DROP_PRECEDENCE RP_DROP_PRECEDENCE
 *     RP_DROP          RP_DROP
 *     DROP_PRECEDENCE  DROP_PRECEDENCE
 *     L3SW_CHANGE_MACDA_OR_VLAN L3SW_CHANGE_MACDA_OR_VLAN
 *     MIRROR           MIRROR
 *     MIRROR_OVERRIDE  CONTROLS OVERRIDING MIRROR PROCESSING IN SW2 STAGE
 *     DROP             DROP
 *     CHAIN            CHAIN
 *     PACKET_REDIRECTION PACKET_REDIRECTION
 *     COPY_TO_CPU      COPY_TO_CPU
 *     CHANGE_DSCP_TOS  CHANGE_DSCP_TOS
 *     CHANGE_PRIORITY  CHANGE_PRIORITY
 *     ECN_CNG          CONTROL WHETHER DROP PRECEDENCE SETS ECN OR CNG BITS
 *     GREEN_TO_PID     GREEN_TO_PID CONTROLS WHETHER PACKET_REDIRECTION and L3SW_CHANGE_MACDA_OR_VLAN  are Green (0) or Color Independent (1) actions
 *     RESERVED_NC_1    RESERVED - SPARE BIT
 *
 ******************************************************************************/
#define BCM56218_A0_FP_POLICY_TABLEm 0x0c750000

#define BCM56218_A0_FP_POLICY_TABLEm_MIN 0
#define BCM56218_A0_FP_POLICY_TABLEm_MAX 1023
#define BCM56218_A0_FP_POLICY_TABLEm_CMAX(u) cdk_xgs_mem_maxidx(u,BCM56218_A0_FP_POLICY_TABLEm,1023)
#define BCM56218_A0_FP_POLICY_TABLEm_SIZE 21

/*
 * This structure should be used to declare and program FP_POLICY_TABLE.
 *
 */
typedef union BCM56218_A0_FP_POLICY_TABLEm_s {
	uint32_t v[6];
	uint32_t fp_policy_table[6];
	uint32_t _fp_policy_table;
} BCM56218_A0_FP_POLICY_TABLEm_t;

#define BCM56218_A0_FP_POLICY_TABLEm_CLR(r) CDK_MEMSET(&((r)._fp_policy_table), 0, sizeof(BCM56218_A0_FP_POLICY_TABLEm_t))
#define BCM56218_A0_FP_POLICY_TABLEm_SET(r,i,d) (r).fp_policy_table[i] = d
#define BCM56218_A0_FP_POLICY_TABLEm_GET(r,i) (r).fp_policy_table[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_FP_POLICY_TABLEm_EM_MTP_INDEXf_GET(r) (((r).fp_policy_table[0]) & 0x3)
#define BCM56218_A0_FP_POLICY_TABLEm_EM_MTP_INDEXf_SET(r,f) (r).fp_policy_table[0]=(((r).fp_policy_table[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56218_A0_FP_POLICY_TABLEm_IM_MTP_INDEXf_GET(r) ((((r).fp_policy_table[0]) >> 2) & 0x3)
#define BCM56218_A0_FP_POLICY_TABLEm_IM_MTP_INDEXf_SET(r,f) (r).fp_policy_table[0]=(((r).fp_policy_table[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM56218_A0_FP_POLICY_TABLEm_MTP_INDEX_SPAREf_GET(r) ((((r).fp_policy_table[0]) >> 4) & 0x1)
#define BCM56218_A0_FP_POLICY_TABLEm_MTP_INDEX_SPAREf_SET(r,f) (r).fp_policy_table[0]=(((r).fp_policy_table[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56218_A0_FP_POLICY_TABLEm_REDIRECTIONf_GET(r,a) cdk_field_get((r).fp_policy_table,5,58,a)
#define BCM56218_A0_FP_POLICY_TABLEm_REDIRECTIONf_SET(r,a) cdk_field_set((r).fp_policy_table,5,58,a)
#define BCM56218_A0_FP_POLICY_TABLEm_REDIRECTION_LOf_GET(r) cdk_field32_get((r).fp_policy_table,5,36)
#define BCM56218_A0_FP_POLICY_TABLEm_REDIRECTION_LOf_SET(r,f) cdk_field32_set((r).fp_policy_table,5,36,f)
#define BCM56218_A0_FP_POLICY_TABLEm_REDIRECTION_HIf_GET(r) ((((r).fp_policy_table[1]) >> 5) & 0x3fffff)
#define BCM56218_A0_FP_POLICY_TABLEm_REDIRECTION_HIf_SET(r,f) (r).fp_policy_table[1]=(((r).fp_policy_table[1] & ~((uint32_t)0x3fffff << 5)) | ((((uint32_t)f) & 0x3fffff) << 5))
#define BCM56218_A0_FP_POLICY_TABLEm_CHAIN_INDEXf_GET(r) ((((r).fp_policy_table[1]) >> 19) & 0x7f)
#define BCM56218_A0_FP_POLICY_TABLEm_CHAIN_INDEXf_SET(r,f) (r).fp_policy_table[1]=(((r).fp_policy_table[1] & ~((uint32_t)0x7f << 19)) | ((((uint32_t)f) & 0x7f) << 19))
#define BCM56218_A0_FP_POLICY_TABLEm_CHAIN_VALIDf_GET(r) ((((r).fp_policy_table[1]) >> 26) & 0x1)
#define BCM56218_A0_FP_POLICY_TABLEm_CHAIN_VALIDf_SET(r,f) (r).fp_policy_table[1]=(((r).fp_policy_table[1] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM56218_A0_FP_POLICY_TABLEm_CLASSIFICATION_TAGf_GET(r) cdk_field32_get((r).fp_policy_table,59,69)
#define BCM56218_A0_FP_POLICY_TABLEm_CLASSIFICATION_TAGf_SET(r,f) cdk_field32_set((r).fp_policy_table,59,69,f)
#define BCM56218_A0_FP_POLICY_TABLEm_ECMP_PTRf_GET(r) cdk_field32_get((r).fp_policy_table,59,69)
#define BCM56218_A0_FP_POLICY_TABLEm_ECMP_PTRf_SET(r,f) cdk_field32_set((r).fp_policy_table,59,69,f)
#define BCM56218_A0_FP_POLICY_TABLEm_NEXT_HOP_INDEXf_GET(r) cdk_field32_get((r).fp_policy_table,59,66)
#define BCM56218_A0_FP_POLICY_TABLEm_NEXT_HOP_INDEXf_SET(r,f) cdk_field32_set((r).fp_policy_table,59,66,f)
#define BCM56218_A0_FP_POLICY_TABLEm_MATCHED_RULEf_GET(r) ((((r).fp_policy_table[2]) >> 6) & 0xff)
#define BCM56218_A0_FP_POLICY_TABLEm_MATCHED_RULEf_SET(r,f) (r).fp_policy_table[2]=(((r).fp_policy_table[2] & ~((uint32_t)0xff << 6)) | ((((uint32_t)f) & 0xff) << 6))
#define BCM56218_A0_FP_POLICY_TABLEm_ECMP_COUNTf_GET(r) ((((r).fp_policy_table[2]) >> 6) & 0x1f)
#define BCM56218_A0_FP_POLICY_TABLEm_ECMP_COUNTf_SET(r,f) (r).fp_policy_table[2]=(((r).fp_policy_table[2] & ~((uint32_t)0x1f << 6)) | ((((uint32_t)f) & 0x1f) << 6))
#define BCM56218_A0_FP_POLICY_TABLEm_ECMPf_GET(r) ((((r).fp_policy_table[2]) >> 11) & 0x1)
#define BCM56218_A0_FP_POLICY_TABLEm_ECMPf_SET(r,f) (r).fp_policy_table[2]=(((r).fp_policy_table[2] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56218_A0_FP_POLICY_TABLEm_DO_NOT_CHANGE_TTLf_GET(r) ((((r).fp_policy_table[2]) >> 13) & 0x1)
#define BCM56218_A0_FP_POLICY_TABLEm_DO_NOT_CHANGE_TTLf_SET(r,f) (r).fp_policy_table[2]=(((r).fp_policy_table[2] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56218_A0_FP_POLICY_TABLEm_YP_DSCPf_GET(r) ((((r).fp_policy_table[2]) >> 14) & 0x3f)
#define BCM56218_A0_FP_POLICY_TABLEm_YP_DSCPf_SET(r,f) (r).fp_policy_table[2]=(((r).fp_policy_table[2] & ~((uint32_t)0x3f << 14)) | ((((uint32_t)f) & 0x3f) << 14))
#define BCM56218_A0_FP_POLICY_TABLEm_RP_DSCPf_GET(r) ((((r).fp_policy_table[2]) >> 20) & 0x3f)
#define BCM56218_A0_FP_POLICY_TABLEm_RP_DSCPf_SET(r,f) (r).fp_policy_table[2]=(((r).fp_policy_table[2] & ~((uint32_t)0x3f << 20)) | ((((uint32_t)f) & 0x3f) << 20))
#define BCM56218_A0_FP_POLICY_TABLEm_NEWDSCP_TOSf_GET(r) ((((r).fp_policy_table[2]) >> 26) & 0x3f)
#define BCM56218_A0_FP_POLICY_TABLEm_NEWDSCP_TOSf_SET(r,f) (r).fp_policy_table[2]=(((r).fp_policy_table[2] & ~((uint32_t)0x3f << 26)) | ((((uint32_t)f) & 0x3f) << 26))
#define BCM56218_A0_FP_POLICY_TABLEm_NEWPRIf_GET(r) (((r).fp_policy_table[3]) & 0x7)
#define BCM56218_A0_FP_POLICY_TABLEm_NEWPRIf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM56218_A0_FP_POLICY_TABLEm_METER_PAIR_MODEf_GET(r) ((((r).fp_policy_table[3]) >> 3) & 0x7)
#define BCM56218_A0_FP_POLICY_TABLEm_METER_PAIR_MODEf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM56218_A0_FP_POLICY_TABLEm_METER_TEST_EVENf_GET(r) ((((r).fp_policy_table[3]) >> 6) & 0x1)
#define BCM56218_A0_FP_POLICY_TABLEm_METER_TEST_EVENf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56218_A0_FP_POLICY_TABLEm_METER_TEST_ODDf_GET(r) ((((r).fp_policy_table[3]) >> 7) & 0x1)
#define BCM56218_A0_FP_POLICY_TABLEm_METER_TEST_ODDf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56218_A0_FP_POLICY_TABLEm_METER_UPDATE_EVENf_GET(r) ((((r).fp_policy_table[3]) >> 8) & 0x1)
#define BCM56218_A0_FP_POLICY_TABLEm_METER_UPDATE_EVENf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56218_A0_FP_POLICY_TABLEm_METER_UPDATE_ODDf_GET(r) ((((r).fp_policy_table[3]) >> 9) & 0x1)
#define BCM56218_A0_FP_POLICY_TABLEm_METER_UPDATE_ODDf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56218_A0_FP_POLICY_TABLEm_METER_INDEX_EVENf_GET(r) ((((r).fp_policy_table[3]) >> 10) & 0x3f)
#define BCM56218_A0_FP_POLICY_TABLEm_METER_INDEX_EVENf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))
#define BCM56218_A0_FP_POLICY_TABLEm_METER_INDEX_ODDf_GET(r) ((((r).fp_policy_table[3]) >> 16) & 0x3f)
#define BCM56218_A0_FP_POLICY_TABLEm_METER_INDEX_ODDf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32_t)0x3f << 16)) | ((((uint32_t)f) & 0x3f) << 16))
#define BCM56218_A0_FP_POLICY_TABLEm_COUNTER_MODEf_GET(r) ((((r).fp_policy_table[3]) >> 22) & 0xf)
#define BCM56218_A0_FP_POLICY_TABLEm_COUNTER_MODEf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32_t)0xf << 22)) | ((((uint32_t)f) & 0xf) << 22))
#define BCM56218_A0_FP_POLICY_TABLEm_COUNTER_INDEXf_GET(r) ((((r).fp_policy_table[3]) >> 26) & 0x3f)
#define BCM56218_A0_FP_POLICY_TABLEm_COUNTER_INDEXf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32_t)0x3f << 26)) | ((((uint32_t)f) & 0x3f) << 26))
#define BCM56218_A0_FP_POLICY_TABLEm_YP_CHANGE_DSCPf_GET(r) (((r).fp_policy_table[4]) & 0x1)
#define BCM56218_A0_FP_POLICY_TABLEm_YP_CHANGE_DSCPf_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_FP_POLICY_TABLEm_YP_COPY_TO_CPUf_GET(r) ((((r).fp_policy_table[4]) >> 1) & 0x3)
#define BCM56218_A0_FP_POLICY_TABLEm_YP_COPY_TO_CPUf_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32_t)0x3 << 1)) | ((((uint32_t)f) & 0x3) << 1))
#define BCM56218_A0_FP_POLICY_TABLEm_YP_DROP_PRECEDENCEf_GET(r) ((((r).fp_policy_table[4]) >> 3) & 0x3)
#define BCM56218_A0_FP_POLICY_TABLEm_YP_DROP_PRECEDENCEf_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32_t)0x3 << 3)) | ((((uint32_t)f) & 0x3) << 3))
#define BCM56218_A0_FP_POLICY_TABLEm_YP_DROPf_GET(r) ((((r).fp_policy_table[4]) >> 5) & 0x3)
#define BCM56218_A0_FP_POLICY_TABLEm_YP_DROPf_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5))
#define BCM56218_A0_FP_POLICY_TABLEm_RP_CHANGE_DSCPf_GET(r) ((((r).fp_policy_table[4]) >> 7) & 0x1)
#define BCM56218_A0_FP_POLICY_TABLEm_RP_CHANGE_DSCPf_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56218_A0_FP_POLICY_TABLEm_RP_COPY_TO_CPUf_GET(r) ((((r).fp_policy_table[4]) >> 8) & 0x3)
#define BCM56218_A0_FP_POLICY_TABLEm_RP_COPY_TO_CPUf_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM56218_A0_FP_POLICY_TABLEm_RP_DROP_PRECEDENCEf_GET(r) ((((r).fp_policy_table[4]) >> 10) & 0x3)
#define BCM56218_A0_FP_POLICY_TABLEm_RP_DROP_PRECEDENCEf_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCM56218_A0_FP_POLICY_TABLEm_RP_DROPf_GET(r) ((((r).fp_policy_table[4]) >> 12) & 0x3)
#define BCM56218_A0_FP_POLICY_TABLEm_RP_DROPf_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM56218_A0_FP_POLICY_TABLEm_DROP_PRECEDENCEf_GET(r) ((((r).fp_policy_table[4]) >> 14) & 0x3)
#define BCM56218_A0_FP_POLICY_TABLEm_DROP_PRECEDENCEf_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCM56218_A0_FP_POLICY_TABLEm_L3SW_CHANGE_MACDA_OR_VLANf_GET(r) ((((r).fp_policy_table[4]) >> 16) & 0x7)
#define BCM56218_A0_FP_POLICY_TABLEm_L3SW_CHANGE_MACDA_OR_VLANf_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32_t)0x7 << 16)) | ((((uint32_t)f) & 0x7) << 16))
#define BCM56218_A0_FP_POLICY_TABLEm_MIRRORf_GET(r) ((((r).fp_policy_table[4]) >> 19) & 0x3)
#define BCM56218_A0_FP_POLICY_TABLEm_MIRRORf_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32_t)0x3 << 19)) | ((((uint32_t)f) & 0x3) << 19))
#define BCM56218_A0_FP_POLICY_TABLEm_MIRROR_OVERRIDEf_GET(r) ((((r).fp_policy_table[4]) >> 21) & 0x1)
#define BCM56218_A0_FP_POLICY_TABLEm_MIRROR_OVERRIDEf_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM56218_A0_FP_POLICY_TABLEm_DROPf_GET(r) ((((r).fp_policy_table[4]) >> 22) & 0x3)
#define BCM56218_A0_FP_POLICY_TABLEm_DROPf_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32_t)0x3 << 22)) | ((((uint32_t)f) & 0x3) << 22))
#define BCM56218_A0_FP_POLICY_TABLEm_CHAINf_GET(r) ((((r).fp_policy_table[4]) >> 24) & 0x1)
#define BCM56218_A0_FP_POLICY_TABLEm_CHAINf_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM56218_A0_FP_POLICY_TABLEm_PACKET_REDIRECTIONf_GET(r) ((((r).fp_policy_table[4]) >> 25) & 0x7)
#define BCM56218_A0_FP_POLICY_TABLEm_PACKET_REDIRECTIONf_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32_t)0x7 << 25)) | ((((uint32_t)f) & 0x7) << 25))
#define BCM56218_A0_FP_POLICY_TABLEm_COPY_TO_CPUf_GET(r) ((((r).fp_policy_table[4]) >> 28) & 0x3)
#define BCM56218_A0_FP_POLICY_TABLEm_COPY_TO_CPUf_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32_t)0x3 << 28)) | ((((uint32_t)f) & 0x3) << 28))
#define BCM56218_A0_FP_POLICY_TABLEm_CHANGE_DSCP_TOSf_GET(r) cdk_field32_get((r).fp_policy_table,158,160)
#define BCM56218_A0_FP_POLICY_TABLEm_CHANGE_DSCP_TOSf_SET(r,f) cdk_field32_set((r).fp_policy_table,158,160,f)
#define BCM56218_A0_FP_POLICY_TABLEm_CHANGE_PRIORITYf_GET(r) ((((r).fp_policy_table[5]) >> 1) & 0xf)
#define BCM56218_A0_FP_POLICY_TABLEm_CHANGE_PRIORITYf_SET(r,f) (r).fp_policy_table[5]=(((r).fp_policy_table[5] & ~((uint32_t)0xf << 1)) | ((((uint32_t)f) & 0xf) << 1))
#define BCM56218_A0_FP_POLICY_TABLEm_ECN_CNGf_GET(r) ((((r).fp_policy_table[5]) >> 5) & 0x1)
#define BCM56218_A0_FP_POLICY_TABLEm_ECN_CNGf_SET(r,f) (r).fp_policy_table[5]=(((r).fp_policy_table[5] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56218_A0_FP_POLICY_TABLEm_GREEN_TO_PIDf_GET(r) ((((r).fp_policy_table[5]) >> 6) & 0x1)
#define BCM56218_A0_FP_POLICY_TABLEm_GREEN_TO_PIDf_SET(r,f) (r).fp_policy_table[5]=(((r).fp_policy_table[5] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56218_A0_FP_POLICY_TABLEm_RESERVED_NC_1f_GET(r) ((((r).fp_policy_table[5]) >> 7) & 0x1)
#define BCM56218_A0_FP_POLICY_TABLEm_RESERVED_NC_1f_SET(r,f) (r).fp_policy_table[5]=(((r).fp_policy_table[5] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access FP_POLICY_TABLE.
 *
 */
#define BCM56218_A0_READ_FP_POLICY_TABLEm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_FP_POLICY_TABLEm,i,(m._fp_policy_table),6)
#define BCM56218_A0_WRITE_FP_POLICY_TABLEm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_FP_POLICY_TABLEm,i,&(m._fp_policy_table),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_POLICY_TABLEm BCM56218_A0_FP_POLICY_TABLEm
#define FP_POLICY_TABLEm_MIN BCM56218_A0_FP_POLICY_TABLEm_MIN
#define FP_POLICY_TABLEm_MAX BCM56218_A0_FP_POLICY_TABLEm_MAX
#define FP_POLICY_TABLEm_CMAX(u) BCM56218_A0_FP_POLICY_TABLEm_CMAX(u)
#define FP_POLICY_TABLEm_SIZE BCM56218_A0_FP_POLICY_TABLEm_SIZE
typedef BCM56218_A0_FP_POLICY_TABLEm_t FP_POLICY_TABLEm_t;
#define FP_POLICY_TABLEm_CLR BCM56218_A0_FP_POLICY_TABLEm_CLR
#define FP_POLICY_TABLEm_SET BCM56218_A0_FP_POLICY_TABLEm_SET
#define FP_POLICY_TABLEm_GET BCM56218_A0_FP_POLICY_TABLEm_GET
#define FP_POLICY_TABLEm_EM_MTP_INDEXf_GET BCM56218_A0_FP_POLICY_TABLEm_EM_MTP_INDEXf_GET
#define FP_POLICY_TABLEm_EM_MTP_INDEXf_SET BCM56218_A0_FP_POLICY_TABLEm_EM_MTP_INDEXf_SET
#define FP_POLICY_TABLEm_IM_MTP_INDEXf_GET BCM56218_A0_FP_POLICY_TABLEm_IM_MTP_INDEXf_GET
#define FP_POLICY_TABLEm_IM_MTP_INDEXf_SET BCM56218_A0_FP_POLICY_TABLEm_IM_MTP_INDEXf_SET
#define FP_POLICY_TABLEm_MTP_INDEX_SPAREf_GET BCM56218_A0_FP_POLICY_TABLEm_MTP_INDEX_SPAREf_GET
#define FP_POLICY_TABLEm_MTP_INDEX_SPAREf_SET BCM56218_A0_FP_POLICY_TABLEm_MTP_INDEX_SPAREf_SET
#define FP_POLICY_TABLEm_REDIRECTIONf_GET BCM56218_A0_FP_POLICY_TABLEm_REDIRECTIONf_GET
#define FP_POLICY_TABLEm_REDIRECTIONf_SET BCM56218_A0_FP_POLICY_TABLEm_REDIRECTIONf_SET
#define FP_POLICY_TABLEm_REDIRECTION_LOf_GET BCM56218_A0_FP_POLICY_TABLEm_REDIRECTION_LOf_GET
#define FP_POLICY_TABLEm_REDIRECTION_LOf_SET BCM56218_A0_FP_POLICY_TABLEm_REDIRECTION_LOf_SET
#define FP_POLICY_TABLEm_REDIRECTION_HIf_GET BCM56218_A0_FP_POLICY_TABLEm_REDIRECTION_HIf_GET
#define FP_POLICY_TABLEm_REDIRECTION_HIf_SET BCM56218_A0_FP_POLICY_TABLEm_REDIRECTION_HIf_SET
#define FP_POLICY_TABLEm_CHAIN_INDEXf_GET BCM56218_A0_FP_POLICY_TABLEm_CHAIN_INDEXf_GET
#define FP_POLICY_TABLEm_CHAIN_INDEXf_SET BCM56218_A0_FP_POLICY_TABLEm_CHAIN_INDEXf_SET
#define FP_POLICY_TABLEm_CHAIN_VALIDf_GET BCM56218_A0_FP_POLICY_TABLEm_CHAIN_VALIDf_GET
#define FP_POLICY_TABLEm_CHAIN_VALIDf_SET BCM56218_A0_FP_POLICY_TABLEm_CHAIN_VALIDf_SET
#define FP_POLICY_TABLEm_CLASSIFICATION_TAGf_GET BCM56218_A0_FP_POLICY_TABLEm_CLASSIFICATION_TAGf_GET
#define FP_POLICY_TABLEm_CLASSIFICATION_TAGf_SET BCM56218_A0_FP_POLICY_TABLEm_CLASSIFICATION_TAGf_SET
#define FP_POLICY_TABLEm_ECMP_PTRf_GET BCM56218_A0_FP_POLICY_TABLEm_ECMP_PTRf_GET
#define FP_POLICY_TABLEm_ECMP_PTRf_SET BCM56218_A0_FP_POLICY_TABLEm_ECMP_PTRf_SET
#define FP_POLICY_TABLEm_NEXT_HOP_INDEXf_GET BCM56218_A0_FP_POLICY_TABLEm_NEXT_HOP_INDEXf_GET
#define FP_POLICY_TABLEm_NEXT_HOP_INDEXf_SET BCM56218_A0_FP_POLICY_TABLEm_NEXT_HOP_INDEXf_SET
#define FP_POLICY_TABLEm_MATCHED_RULEf_GET BCM56218_A0_FP_POLICY_TABLEm_MATCHED_RULEf_GET
#define FP_POLICY_TABLEm_MATCHED_RULEf_SET BCM56218_A0_FP_POLICY_TABLEm_MATCHED_RULEf_SET
#define FP_POLICY_TABLEm_ECMP_COUNTf_GET BCM56218_A0_FP_POLICY_TABLEm_ECMP_COUNTf_GET
#define FP_POLICY_TABLEm_ECMP_COUNTf_SET BCM56218_A0_FP_POLICY_TABLEm_ECMP_COUNTf_SET
#define FP_POLICY_TABLEm_ECMPf_GET BCM56218_A0_FP_POLICY_TABLEm_ECMPf_GET
#define FP_POLICY_TABLEm_ECMPf_SET BCM56218_A0_FP_POLICY_TABLEm_ECMPf_SET
#define FP_POLICY_TABLEm_DO_NOT_CHANGE_TTLf_GET BCM56218_A0_FP_POLICY_TABLEm_DO_NOT_CHANGE_TTLf_GET
#define FP_POLICY_TABLEm_DO_NOT_CHANGE_TTLf_SET BCM56218_A0_FP_POLICY_TABLEm_DO_NOT_CHANGE_TTLf_SET
#define FP_POLICY_TABLEm_YP_DSCPf_GET BCM56218_A0_FP_POLICY_TABLEm_YP_DSCPf_GET
#define FP_POLICY_TABLEm_YP_DSCPf_SET BCM56218_A0_FP_POLICY_TABLEm_YP_DSCPf_SET
#define FP_POLICY_TABLEm_RP_DSCPf_GET BCM56218_A0_FP_POLICY_TABLEm_RP_DSCPf_GET
#define FP_POLICY_TABLEm_RP_DSCPf_SET BCM56218_A0_FP_POLICY_TABLEm_RP_DSCPf_SET
#define FP_POLICY_TABLEm_NEWDSCP_TOSf_GET BCM56218_A0_FP_POLICY_TABLEm_NEWDSCP_TOSf_GET
#define FP_POLICY_TABLEm_NEWDSCP_TOSf_SET BCM56218_A0_FP_POLICY_TABLEm_NEWDSCP_TOSf_SET
#define FP_POLICY_TABLEm_NEWPRIf_GET BCM56218_A0_FP_POLICY_TABLEm_NEWPRIf_GET
#define FP_POLICY_TABLEm_NEWPRIf_SET BCM56218_A0_FP_POLICY_TABLEm_NEWPRIf_SET
#define FP_POLICY_TABLEm_METER_PAIR_MODEf_GET BCM56218_A0_FP_POLICY_TABLEm_METER_PAIR_MODEf_GET
#define FP_POLICY_TABLEm_METER_PAIR_MODEf_SET BCM56218_A0_FP_POLICY_TABLEm_METER_PAIR_MODEf_SET
#define FP_POLICY_TABLEm_METER_TEST_EVENf_GET BCM56218_A0_FP_POLICY_TABLEm_METER_TEST_EVENf_GET
#define FP_POLICY_TABLEm_METER_TEST_EVENf_SET BCM56218_A0_FP_POLICY_TABLEm_METER_TEST_EVENf_SET
#define FP_POLICY_TABLEm_METER_TEST_ODDf_GET BCM56218_A0_FP_POLICY_TABLEm_METER_TEST_ODDf_GET
#define FP_POLICY_TABLEm_METER_TEST_ODDf_SET BCM56218_A0_FP_POLICY_TABLEm_METER_TEST_ODDf_SET
#define FP_POLICY_TABLEm_METER_UPDATE_EVENf_GET BCM56218_A0_FP_POLICY_TABLEm_METER_UPDATE_EVENf_GET
#define FP_POLICY_TABLEm_METER_UPDATE_EVENf_SET BCM56218_A0_FP_POLICY_TABLEm_METER_UPDATE_EVENf_SET
#define FP_POLICY_TABLEm_METER_UPDATE_ODDf_GET BCM56218_A0_FP_POLICY_TABLEm_METER_UPDATE_ODDf_GET
#define FP_POLICY_TABLEm_METER_UPDATE_ODDf_SET BCM56218_A0_FP_POLICY_TABLEm_METER_UPDATE_ODDf_SET
#define FP_POLICY_TABLEm_METER_INDEX_EVENf_GET BCM56218_A0_FP_POLICY_TABLEm_METER_INDEX_EVENf_GET
#define FP_POLICY_TABLEm_METER_INDEX_EVENf_SET BCM56218_A0_FP_POLICY_TABLEm_METER_INDEX_EVENf_SET
#define FP_POLICY_TABLEm_METER_INDEX_ODDf_GET BCM56218_A0_FP_POLICY_TABLEm_METER_INDEX_ODDf_GET
#define FP_POLICY_TABLEm_METER_INDEX_ODDf_SET BCM56218_A0_FP_POLICY_TABLEm_METER_INDEX_ODDf_SET
#define FP_POLICY_TABLEm_COUNTER_MODEf_GET BCM56218_A0_FP_POLICY_TABLEm_COUNTER_MODEf_GET
#define FP_POLICY_TABLEm_COUNTER_MODEf_SET BCM56218_A0_FP_POLICY_TABLEm_COUNTER_MODEf_SET
#define FP_POLICY_TABLEm_COUNTER_INDEXf_GET BCM56218_A0_FP_POLICY_TABLEm_COUNTER_INDEXf_GET
#define FP_POLICY_TABLEm_COUNTER_INDEXf_SET BCM56218_A0_FP_POLICY_TABLEm_COUNTER_INDEXf_SET
#define FP_POLICY_TABLEm_YP_CHANGE_DSCPf_GET BCM56218_A0_FP_POLICY_TABLEm_YP_CHANGE_DSCPf_GET
#define FP_POLICY_TABLEm_YP_CHANGE_DSCPf_SET BCM56218_A0_FP_POLICY_TABLEm_YP_CHANGE_DSCPf_SET
#define FP_POLICY_TABLEm_YP_COPY_TO_CPUf_GET BCM56218_A0_FP_POLICY_TABLEm_YP_COPY_TO_CPUf_GET
#define FP_POLICY_TABLEm_YP_COPY_TO_CPUf_SET BCM56218_A0_FP_POLICY_TABLEm_YP_COPY_TO_CPUf_SET
#define FP_POLICY_TABLEm_YP_DROP_PRECEDENCEf_GET BCM56218_A0_FP_POLICY_TABLEm_YP_DROP_PRECEDENCEf_GET
#define FP_POLICY_TABLEm_YP_DROP_PRECEDENCEf_SET BCM56218_A0_FP_POLICY_TABLEm_YP_DROP_PRECEDENCEf_SET
#define FP_POLICY_TABLEm_YP_DROPf_GET BCM56218_A0_FP_POLICY_TABLEm_YP_DROPf_GET
#define FP_POLICY_TABLEm_YP_DROPf_SET BCM56218_A0_FP_POLICY_TABLEm_YP_DROPf_SET
#define FP_POLICY_TABLEm_RP_CHANGE_DSCPf_GET BCM56218_A0_FP_POLICY_TABLEm_RP_CHANGE_DSCPf_GET
#define FP_POLICY_TABLEm_RP_CHANGE_DSCPf_SET BCM56218_A0_FP_POLICY_TABLEm_RP_CHANGE_DSCPf_SET
#define FP_POLICY_TABLEm_RP_COPY_TO_CPUf_GET BCM56218_A0_FP_POLICY_TABLEm_RP_COPY_TO_CPUf_GET
#define FP_POLICY_TABLEm_RP_COPY_TO_CPUf_SET BCM56218_A0_FP_POLICY_TABLEm_RP_COPY_TO_CPUf_SET
#define FP_POLICY_TABLEm_RP_DROP_PRECEDENCEf_GET BCM56218_A0_FP_POLICY_TABLEm_RP_DROP_PRECEDENCEf_GET
#define FP_POLICY_TABLEm_RP_DROP_PRECEDENCEf_SET BCM56218_A0_FP_POLICY_TABLEm_RP_DROP_PRECEDENCEf_SET
#define FP_POLICY_TABLEm_RP_DROPf_GET BCM56218_A0_FP_POLICY_TABLEm_RP_DROPf_GET
#define FP_POLICY_TABLEm_RP_DROPf_SET BCM56218_A0_FP_POLICY_TABLEm_RP_DROPf_SET
#define FP_POLICY_TABLEm_DROP_PRECEDENCEf_GET BCM56218_A0_FP_POLICY_TABLEm_DROP_PRECEDENCEf_GET
#define FP_POLICY_TABLEm_DROP_PRECEDENCEf_SET BCM56218_A0_FP_POLICY_TABLEm_DROP_PRECEDENCEf_SET
#define FP_POLICY_TABLEm_L3SW_CHANGE_MACDA_OR_VLANf_GET BCM56218_A0_FP_POLICY_TABLEm_L3SW_CHANGE_MACDA_OR_VLANf_GET
#define FP_POLICY_TABLEm_L3SW_CHANGE_MACDA_OR_VLANf_SET BCM56218_A0_FP_POLICY_TABLEm_L3SW_CHANGE_MACDA_OR_VLANf_SET
#define FP_POLICY_TABLEm_MIRRORf_GET BCM56218_A0_FP_POLICY_TABLEm_MIRRORf_GET
#define FP_POLICY_TABLEm_MIRRORf_SET BCM56218_A0_FP_POLICY_TABLEm_MIRRORf_SET
#define FP_POLICY_TABLEm_MIRROR_OVERRIDEf_GET BCM56218_A0_FP_POLICY_TABLEm_MIRROR_OVERRIDEf_GET
#define FP_POLICY_TABLEm_MIRROR_OVERRIDEf_SET BCM56218_A0_FP_POLICY_TABLEm_MIRROR_OVERRIDEf_SET
#define FP_POLICY_TABLEm_DROPf_GET BCM56218_A0_FP_POLICY_TABLEm_DROPf_GET
#define FP_POLICY_TABLEm_DROPf_SET BCM56218_A0_FP_POLICY_TABLEm_DROPf_SET
#define FP_POLICY_TABLEm_CHAINf_GET BCM56218_A0_FP_POLICY_TABLEm_CHAINf_GET
#define FP_POLICY_TABLEm_CHAINf_SET BCM56218_A0_FP_POLICY_TABLEm_CHAINf_SET
#define FP_POLICY_TABLEm_PACKET_REDIRECTIONf_GET BCM56218_A0_FP_POLICY_TABLEm_PACKET_REDIRECTIONf_GET
#define FP_POLICY_TABLEm_PACKET_REDIRECTIONf_SET BCM56218_A0_FP_POLICY_TABLEm_PACKET_REDIRECTIONf_SET
#define FP_POLICY_TABLEm_COPY_TO_CPUf_GET BCM56218_A0_FP_POLICY_TABLEm_COPY_TO_CPUf_GET
#define FP_POLICY_TABLEm_COPY_TO_CPUf_SET BCM56218_A0_FP_POLICY_TABLEm_COPY_TO_CPUf_SET
#define FP_POLICY_TABLEm_CHANGE_DSCP_TOSf_GET BCM56218_A0_FP_POLICY_TABLEm_CHANGE_DSCP_TOSf_GET
#define FP_POLICY_TABLEm_CHANGE_DSCP_TOSf_SET BCM56218_A0_FP_POLICY_TABLEm_CHANGE_DSCP_TOSf_SET
#define FP_POLICY_TABLEm_CHANGE_PRIORITYf_GET BCM56218_A0_FP_POLICY_TABLEm_CHANGE_PRIORITYf_GET
#define FP_POLICY_TABLEm_CHANGE_PRIORITYf_SET BCM56218_A0_FP_POLICY_TABLEm_CHANGE_PRIORITYf_SET
#define FP_POLICY_TABLEm_ECN_CNGf_GET BCM56218_A0_FP_POLICY_TABLEm_ECN_CNGf_GET
#define FP_POLICY_TABLEm_ECN_CNGf_SET BCM56218_A0_FP_POLICY_TABLEm_ECN_CNGf_SET
#define FP_POLICY_TABLEm_GREEN_TO_PIDf_GET BCM56218_A0_FP_POLICY_TABLEm_GREEN_TO_PIDf_GET
#define FP_POLICY_TABLEm_GREEN_TO_PIDf_SET BCM56218_A0_FP_POLICY_TABLEm_GREEN_TO_PIDf_SET
#define FP_POLICY_TABLEm_RESERVED_NC_1f_GET BCM56218_A0_FP_POLICY_TABLEm_RESERVED_NC_1f_GET
#define FP_POLICY_TABLEm_RESERVED_NC_1f_SET BCM56218_A0_FP_POLICY_TABLEm_RESERVED_NC_1f_SET
#define READ_FP_POLICY_TABLEm BCM56218_A0_READ_FP_POLICY_TABLEm
#define WRITE_FP_POLICY_TABLEm BCM56218_A0_WRITE_FP_POLICY_TABLEm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_FP_POLICY_TABLEm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  FP_PORT_FIELD_SEL
 * BLOCKS:   IPIPE
 * DESC:     FIELD SELECT VALUE FOR EACH SLICE IN THE FP
 * SIZE:     88
 * FIELDS:
 *     SLICE0_F1        F1 field for slice 0.
 *     SLICE0_F2        F2 field for slice 0
 *     SLICE0_F3        F3 field for slice 0
 *     SLICE0_F4        CONTROL for F4 selector for SLICE 1. 0=SRC_PORT_NUMBER, 1=PKT_FORMAT
 *     SLICE1_F1        F1 field for slice 1.
 *     SLICE1_F2        F2 field for slice 1
 *     SLICE1_F3        F3 field for slice 1
 *     SLICE1_F4        CONTROL for F4 selector for SLICE 2. 0=SRC_PORT_NUMBER, 1=PKT_FORMAT
 *     SLICE2_F1        F1 field for slice 2.
 *     SLICE2_F2        F2 field for slice 2
 *     SLICE2_F3        F3 field for slice 2
 *     SLICE2_F4        CONTROL for F4 selector for SLICE 3. 0=SRC_PORT_NUMBER, 1=PKT_FORMAT
 *     SLICE3_F1        F1 field for slice 3.
 *     SLICE3_F2        F2 field for slice 3
 *     SLICE3_F3        F3 field for slice 3
 *     SLICE3_F4        CONTROL for F4 selector for SLICE 3. 0=SRC_PORT_NUMBER, 1=PKT_FORMAT
 *     SLICE4_F1        F1 field for slice 4.
 *     SLICE4_F2        F2 field for slice 4
 *     SLICE4_F3        F3 field for slice 4
 *     SLICE4_F4        CONTROL for F4 selector for SLICE 4. 0=SRC_PORT_NUMBER, 1=PKT_FORMAT
 *     SLICE5_F1        F1 field for slice 5.
 *     SLICE5_F2        F2 field for slice 5
 *     SLICE5_F3        F3 field for slice 5
 *     SLICE5_F4        CONTROL for F4 selector for SLICE 5. 0=SRC_PORT_NUMBER, 1=PKT_FORMAT
 *     SLICE6_F1        F1 field for slice 6.
 *     SLICE6_F2        F2 field for slice 6
 *     SLICE6_F3        F3 field for slice 6
 *     SLICE6_F4        CONTROL for F4 selector for SLICE 6. 0=SRC_PORT_NUMBER, 1=PKT_FORMAT
 *     SLICE7_F1        F1 field for slice 7.
 *     SLICE7_F2        F2 field for slice 7
 *     SLICE7_F3        F3 field for slice 7
 *     SLICE7_F4        CONTROL for F4 selector for SLICE 7. 0=SRC_PORT_NUMBER, 1=PKT_FORMAT
 *
 ******************************************************************************/
#define BCM56218_A0_FP_PORT_FIELD_SELm 0x0b700000

#define BCM56218_A0_FP_PORT_FIELD_SELm_MIN 0
#define BCM56218_A0_FP_PORT_FIELD_SELm_MAX 53
#define BCM56218_A0_FP_PORT_FIELD_SELm_CMAX(u) 53
#define BCM56218_A0_FP_PORT_FIELD_SELm_SIZE 11

/*
 * This structure should be used to declare and program FP_PORT_FIELD_SEL.
 *
 */
typedef union BCM56218_A0_FP_PORT_FIELD_SELm_s {
	uint32_t v[3];
	uint32_t fp_port_field_sel[3];
	uint32_t _fp_port_field_sel;
} BCM56218_A0_FP_PORT_FIELD_SELm_t;

#define BCM56218_A0_FP_PORT_FIELD_SELm_CLR(r) CDK_MEMSET(&((r)._fp_port_field_sel), 0, sizeof(BCM56218_A0_FP_PORT_FIELD_SELm_t))
#define BCM56218_A0_FP_PORT_FIELD_SELm_SET(r,i,d) (r).fp_port_field_sel[i] = d
#define BCM56218_A0_FP_PORT_FIELD_SELm_GET(r,i) (r).fp_port_field_sel[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_FP_PORT_FIELD_SELm_SLICE0_F1f_GET(r) (((r).fp_port_field_sel[0]) & 0x7)
#define BCM56218_A0_FP_PORT_FIELD_SELm_SLICE0_F1f_SET(r,f) (r).fp_port_field_sel[0]=(((r).fp_port_field_sel[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM56218_A0_FP_PORT_FIELD_SELm_SLICE0_F2f_GET(r) ((((r).fp_port_field_sel[0]) >> 3) & 0xf)
#define BCM56218_A0_FP_PORT_FIELD_SELm_SLICE0_F2f_SET(r,f) (r).fp_port_field_sel[0]=(((r).fp_port_field_sel[0] & ~((uint32_t)0xf << 3)) | ((((uint32_t)f) & 0xf) << 3))
#define BCM56218_A0_FP_PORT_FIELD_SELm_SLICE0_F3f_GET(r) ((((r).fp_port_field_sel[0]) >> 7) & 0x7)
#define BCM56218_A0_FP_PORT_FIELD_SELm_SLICE0_F3f_SET(r,f) (r).fp_port_field_sel[0]=(((r).fp_port_field_sel[0] & ~((uint32_t)0x7 << 7)) | ((((uint32_t)f) & 0x7) << 7))
#define BCM56218_A0_FP_PORT_FIELD_SELm_SLICE0_F4f_GET(r) ((((r).fp_port_field_sel[0]) >> 10) & 0x1)
#define BCM56218_A0_FP_PORT_FIELD_SELm_SLICE0_F4f_SET(r,f) (r).fp_port_field_sel[0]=(((r).fp_port_field_sel[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56218_A0_FP_PORT_FIELD_SELm_SLICE1_F1f_GET(r) ((((r).fp_port_field_sel[0]) >> 11) & 0x7)
#define BCM56218_A0_FP_PORT_FIELD_SELm_SLICE1_F1f_SET(r,f) (r).fp_port_field_sel[0]=(((r).fp_port_field_sel[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11))
#define BCM56218_A0_FP_PORT_FIELD_SELm_SLICE1_F2f_GET(r) ((((r).fp_port_field_sel[0]) >> 14) & 0xf)
#define BCM56218_A0_FP_PORT_FIELD_SELm_SLICE1_F2f_SET(r,f) (r).fp_port_field_sel[0]=(((r).fp_port_field_sel[0] & ~((uint32_t)0xf << 14)) | ((((uint32_t)f) & 0xf) << 14))
#define BCM56218_A0_FP_PORT_FIELD_SELm_SLICE1_F3f_GET(r) ((((r).fp_port_field_sel[0]) >> 18) & 0x7)
#define BCM56218_A0_FP_PORT_FIELD_SELm_SLICE1_F3f_SET(r,f) (r).fp_port_field_sel[0]=(((r).fp_port_field_sel[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM56218_A0_FP_PORT_FIELD_SELm_SLICE1_F4f_GET(r) ((((r).fp_port_field_sel[0]) >> 21) & 0x1)
#define BCM56218_A0_FP_PORT_FIELD_SELm_SLICE1_F4f_SET(r,f) (r).fp_port_field_sel[0]=(((r).fp_port_field_sel[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM56218_A0_FP_PORT_FIELD_SELm_SLICE2_F1f_GET(r) ((((r).fp_port_field_sel[0]) >> 22) & 0x7)
#define BCM56218_A0_FP_PORT_FIELD_SELm_SLICE2_F1f_SET(r,f) (r).fp_port_field_sel[0]=(((r).fp_port_field_sel[0] & ~((uint32_t)0x7 << 22)) | ((((uint32_t)f) & 0x7) << 22))
#define BCM56218_A0_FP_PORT_FIELD_SELm_SLICE2_F2f_GET(r) ((((r).fp_port_field_sel[0]) >> 25) & 0xf)
#define BCM56218_A0_FP_PORT_FIELD_SELm_SLICE2_F2f_SET(r,f) (r).fp_port_field_sel[0]=(((r).fp_port_field_sel[0] & ~((uint32_t)0xf << 25)) | ((((uint32_t)f) & 0xf) << 25))
#define BCM56218_A0_FP_PORT_FIELD_SELm_SLICE2_F3f_GET(r) ((((r).fp_port_field_sel[0]) >> 29) & 0x7)
#define BCM56218_A0_FP_PORT_FIELD_SELm_SLICE2_F3f_SET(r,f) (r).fp_port_field_sel[0]=(((r).fp_port_field_sel[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))
#define BCM56218_A0_FP_PORT_FIELD_SELm_SLICE2_F4f_GET(r) (((r).fp_port_field_sel[1]) & 0x1)
#define BCM56218_A0_FP_PORT_FIELD_SELm_SLICE2_F4f_SET(r,f) (r).fp_port_field_sel[1]=(((r).fp_port_field_sel[1] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_FP_PORT_FIELD_SELm_SLICE3_F1f_GET(r) ((((r).fp_port_field_sel[1]) >> 1) & 0x7)
#define BCM56218_A0_FP_PORT_FIELD_SELm_SLICE3_F1f_SET(r,f) (r).fp_port_field_sel[1]=(((r).fp_port_field_sel[1] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define BCM56218_A0_FP_PORT_FIELD_SELm_SLICE3_F2f_GET(r) ((((r).fp_port_field_sel[1]) >> 4) & 0xf)
#define BCM56218_A0_FP_PORT_FIELD_SELm_SLICE3_F2f_SET(r,f) (r).fp_port_field_sel[1]=(((r).fp_port_field_sel[1] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56218_A0_FP_PORT_FIELD_SELm_SLICE3_F3f_GET(r) ((((r).fp_port_field_sel[1]) >> 8) & 0x7)
#define BCM56218_A0_FP_PORT_FIELD_SELm_SLICE3_F3f_SET(r,f) (r).fp_port_field_sel[1]=(((r).fp_port_field_sel[1] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8))
#define BCM56218_A0_FP_PORT_FIELD_SELm_SLICE3_F4f_GET(r) ((((r).fp_port_field_sel[1]) >> 11) & 0x1)
#define BCM56218_A0_FP_PORT_FIELD_SELm_SLICE3_F4f_SET(r,f) (r).fp_port_field_sel[1]=(((r).fp_port_field_sel[1] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56218_A0_FP_PORT_FIELD_SELm_SLICE4_F1f_GET(r) ((((r).fp_port_field_sel[1]) >> 12) & 0x7)
#define BCM56218_A0_FP_PORT_FIELD_SELm_SLICE4_F1f_SET(r,f) (r).fp_port_field_sel[1]=(((r).fp_port_field_sel[1] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM56218_A0_FP_PORT_FIELD_SELm_SLICE4_F2f_GET(r) ((((r).fp_port_field_sel[1]) >> 15) & 0xf)
#define BCM56218_A0_FP_PORT_FIELD_SELm_SLICE4_F2f_SET(r,f) (r).fp_port_field_sel[1]=(((r).fp_port_field_sel[1] & ~((uint32_t)0xf << 15)) | ((((uint32_t)f) & 0xf) << 15))
#define BCM56218_A0_FP_PORT_FIELD_SELm_SLICE4_F3f_GET(r) ((((r).fp_port_field_sel[1]) >> 19) & 0x7)
#define BCM56218_A0_FP_PORT_FIELD_SELm_SLICE4_F3f_SET(r,f) (r).fp_port_field_sel[1]=(((r).fp_port_field_sel[1] & ~((uint32_t)0x7 << 19)) | ((((uint32_t)f) & 0x7) << 19))
#define BCM56218_A0_FP_PORT_FIELD_SELm_SLICE4_F4f_GET(r) ((((r).fp_port_field_sel[1]) >> 22) & 0x1)
#define BCM56218_A0_FP_PORT_FIELD_SELm_SLICE4_F4f_SET(r,f) (r).fp_port_field_sel[1]=(((r).fp_port_field_sel[1] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM56218_A0_FP_PORT_FIELD_SELm_SLICE5_F1f_GET(r) ((((r).fp_port_field_sel[1]) >> 23) & 0x7)
#define BCM56218_A0_FP_PORT_FIELD_SELm_SLICE5_F1f_SET(r,f) (r).fp_port_field_sel[1]=(((r).fp_port_field_sel[1] & ~((uint32_t)0x7 << 23)) | ((((uint32_t)f) & 0x7) << 23))
#define BCM56218_A0_FP_PORT_FIELD_SELm_SLICE5_F2f_GET(r) ((((r).fp_port_field_sel[1]) >> 26) & 0xf)
#define BCM56218_A0_FP_PORT_FIELD_SELm_SLICE5_F2f_SET(r,f) (r).fp_port_field_sel[1]=(((r).fp_port_field_sel[1] & ~((uint32_t)0xf << 26)) | ((((uint32_t)f) & 0xf) << 26))
#define BCM56218_A0_FP_PORT_FIELD_SELm_SLICE5_F3f_GET(r) cdk_field32_get((r).fp_port_field_sel,62,64)
#define BCM56218_A0_FP_PORT_FIELD_SELm_SLICE5_F3f_SET(r,f) cdk_field32_set((r).fp_port_field_sel,62,64,f)
#define BCM56218_A0_FP_PORT_FIELD_SELm_SLICE5_F4f_GET(r) ((((r).fp_port_field_sel[2]) >> 1) & 0x1)
#define BCM56218_A0_FP_PORT_FIELD_SELm_SLICE5_F4f_SET(r,f) (r).fp_port_field_sel[2]=(((r).fp_port_field_sel[2] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_FP_PORT_FIELD_SELm_SLICE6_F1f_GET(r) ((((r).fp_port_field_sel[2]) >> 2) & 0x7)
#define BCM56218_A0_FP_PORT_FIELD_SELm_SLICE6_F1f_SET(r,f) (r).fp_port_field_sel[2]=(((r).fp_port_field_sel[2] & ~((uint32_t)0x7 << 2)) | ((((uint32_t)f) & 0x7) << 2))
#define BCM56218_A0_FP_PORT_FIELD_SELm_SLICE6_F2f_GET(r) ((((r).fp_port_field_sel[2]) >> 5) & 0xf)
#define BCM56218_A0_FP_PORT_FIELD_SELm_SLICE6_F2f_SET(r,f) (r).fp_port_field_sel[2]=(((r).fp_port_field_sel[2] & ~((uint32_t)0xf << 5)) | ((((uint32_t)f) & 0xf) << 5))
#define BCM56218_A0_FP_PORT_FIELD_SELm_SLICE6_F3f_GET(r) ((((r).fp_port_field_sel[2]) >> 9) & 0x7)
#define BCM56218_A0_FP_PORT_FIELD_SELm_SLICE6_F3f_SET(r,f) (r).fp_port_field_sel[2]=(((r).fp_port_field_sel[2] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM56218_A0_FP_PORT_FIELD_SELm_SLICE6_F4f_GET(r) ((((r).fp_port_field_sel[2]) >> 12) & 0x1)
#define BCM56218_A0_FP_PORT_FIELD_SELm_SLICE6_F4f_SET(r,f) (r).fp_port_field_sel[2]=(((r).fp_port_field_sel[2] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM56218_A0_FP_PORT_FIELD_SELm_SLICE7_F1f_GET(r) ((((r).fp_port_field_sel[2]) >> 13) & 0x7)
#define BCM56218_A0_FP_PORT_FIELD_SELm_SLICE7_F1f_SET(r,f) (r).fp_port_field_sel[2]=(((r).fp_port_field_sel[2] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))
#define BCM56218_A0_FP_PORT_FIELD_SELm_SLICE7_F2f_GET(r) ((((r).fp_port_field_sel[2]) >> 16) & 0xf)
#define BCM56218_A0_FP_PORT_FIELD_SELm_SLICE7_F2f_SET(r,f) (r).fp_port_field_sel[2]=(((r).fp_port_field_sel[2] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM56218_A0_FP_PORT_FIELD_SELm_SLICE7_F3f_GET(r) ((((r).fp_port_field_sel[2]) >> 20) & 0x7)
#define BCM56218_A0_FP_PORT_FIELD_SELm_SLICE7_F3f_SET(r,f) (r).fp_port_field_sel[2]=(((r).fp_port_field_sel[2] & ~((uint32_t)0x7 << 20)) | ((((uint32_t)f) & 0x7) << 20))
#define BCM56218_A0_FP_PORT_FIELD_SELm_SLICE7_F4f_GET(r) ((((r).fp_port_field_sel[2]) >> 23) & 0x1)
#define BCM56218_A0_FP_PORT_FIELD_SELm_SLICE7_F4f_SET(r,f) (r).fp_port_field_sel[2]=(((r).fp_port_field_sel[2] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))

/*
 * These macros can be used to access FP_PORT_FIELD_SEL.
 *
 */
#define BCM56218_A0_READ_FP_PORT_FIELD_SELm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_FP_PORT_FIELD_SELm,i,(m._fp_port_field_sel),3)
#define BCM56218_A0_WRITE_FP_PORT_FIELD_SELm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_FP_PORT_FIELD_SELm,i,&(m._fp_port_field_sel),3)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_PORT_FIELD_SELm BCM56218_A0_FP_PORT_FIELD_SELm
#define FP_PORT_FIELD_SELm_MIN BCM56218_A0_FP_PORT_FIELD_SELm_MIN
#define FP_PORT_FIELD_SELm_MAX BCM56218_A0_FP_PORT_FIELD_SELm_MAX
#define FP_PORT_FIELD_SELm_CMAX(u) BCM56218_A0_FP_PORT_FIELD_SELm_CMAX(u)
#define FP_PORT_FIELD_SELm_SIZE BCM56218_A0_FP_PORT_FIELD_SELm_SIZE
typedef BCM56218_A0_FP_PORT_FIELD_SELm_t FP_PORT_FIELD_SELm_t;
#define FP_PORT_FIELD_SELm_CLR BCM56218_A0_FP_PORT_FIELD_SELm_CLR
#define FP_PORT_FIELD_SELm_SET BCM56218_A0_FP_PORT_FIELD_SELm_SET
#define FP_PORT_FIELD_SELm_GET BCM56218_A0_FP_PORT_FIELD_SELm_GET
#define FP_PORT_FIELD_SELm_SLICE0_F1f_GET BCM56218_A0_FP_PORT_FIELD_SELm_SLICE0_F1f_GET
#define FP_PORT_FIELD_SELm_SLICE0_F1f_SET BCM56218_A0_FP_PORT_FIELD_SELm_SLICE0_F1f_SET
#define FP_PORT_FIELD_SELm_SLICE0_F2f_GET BCM56218_A0_FP_PORT_FIELD_SELm_SLICE0_F2f_GET
#define FP_PORT_FIELD_SELm_SLICE0_F2f_SET BCM56218_A0_FP_PORT_FIELD_SELm_SLICE0_F2f_SET
#define FP_PORT_FIELD_SELm_SLICE0_F3f_GET BCM56218_A0_FP_PORT_FIELD_SELm_SLICE0_F3f_GET
#define FP_PORT_FIELD_SELm_SLICE0_F3f_SET BCM56218_A0_FP_PORT_FIELD_SELm_SLICE0_F3f_SET
#define FP_PORT_FIELD_SELm_SLICE0_F4f_GET BCM56218_A0_FP_PORT_FIELD_SELm_SLICE0_F4f_GET
#define FP_PORT_FIELD_SELm_SLICE0_F4f_SET BCM56218_A0_FP_PORT_FIELD_SELm_SLICE0_F4f_SET
#define FP_PORT_FIELD_SELm_SLICE1_F1f_GET BCM56218_A0_FP_PORT_FIELD_SELm_SLICE1_F1f_GET
#define FP_PORT_FIELD_SELm_SLICE1_F1f_SET BCM56218_A0_FP_PORT_FIELD_SELm_SLICE1_F1f_SET
#define FP_PORT_FIELD_SELm_SLICE1_F2f_GET BCM56218_A0_FP_PORT_FIELD_SELm_SLICE1_F2f_GET
#define FP_PORT_FIELD_SELm_SLICE1_F2f_SET BCM56218_A0_FP_PORT_FIELD_SELm_SLICE1_F2f_SET
#define FP_PORT_FIELD_SELm_SLICE1_F3f_GET BCM56218_A0_FP_PORT_FIELD_SELm_SLICE1_F3f_GET
#define FP_PORT_FIELD_SELm_SLICE1_F3f_SET BCM56218_A0_FP_PORT_FIELD_SELm_SLICE1_F3f_SET
#define FP_PORT_FIELD_SELm_SLICE1_F4f_GET BCM56218_A0_FP_PORT_FIELD_SELm_SLICE1_F4f_GET
#define FP_PORT_FIELD_SELm_SLICE1_F4f_SET BCM56218_A0_FP_PORT_FIELD_SELm_SLICE1_F4f_SET
#define FP_PORT_FIELD_SELm_SLICE2_F1f_GET BCM56218_A0_FP_PORT_FIELD_SELm_SLICE2_F1f_GET
#define FP_PORT_FIELD_SELm_SLICE2_F1f_SET BCM56218_A0_FP_PORT_FIELD_SELm_SLICE2_F1f_SET
#define FP_PORT_FIELD_SELm_SLICE2_F2f_GET BCM56218_A0_FP_PORT_FIELD_SELm_SLICE2_F2f_GET
#define FP_PORT_FIELD_SELm_SLICE2_F2f_SET BCM56218_A0_FP_PORT_FIELD_SELm_SLICE2_F2f_SET
#define FP_PORT_FIELD_SELm_SLICE2_F3f_GET BCM56218_A0_FP_PORT_FIELD_SELm_SLICE2_F3f_GET
#define FP_PORT_FIELD_SELm_SLICE2_F3f_SET BCM56218_A0_FP_PORT_FIELD_SELm_SLICE2_F3f_SET
#define FP_PORT_FIELD_SELm_SLICE2_F4f_GET BCM56218_A0_FP_PORT_FIELD_SELm_SLICE2_F4f_GET
#define FP_PORT_FIELD_SELm_SLICE2_F4f_SET BCM56218_A0_FP_PORT_FIELD_SELm_SLICE2_F4f_SET
#define FP_PORT_FIELD_SELm_SLICE3_F1f_GET BCM56218_A0_FP_PORT_FIELD_SELm_SLICE3_F1f_GET
#define FP_PORT_FIELD_SELm_SLICE3_F1f_SET BCM56218_A0_FP_PORT_FIELD_SELm_SLICE3_F1f_SET
#define FP_PORT_FIELD_SELm_SLICE3_F2f_GET BCM56218_A0_FP_PORT_FIELD_SELm_SLICE3_F2f_GET
#define FP_PORT_FIELD_SELm_SLICE3_F2f_SET BCM56218_A0_FP_PORT_FIELD_SELm_SLICE3_F2f_SET
#define FP_PORT_FIELD_SELm_SLICE3_F3f_GET BCM56218_A0_FP_PORT_FIELD_SELm_SLICE3_F3f_GET
#define FP_PORT_FIELD_SELm_SLICE3_F3f_SET BCM56218_A0_FP_PORT_FIELD_SELm_SLICE3_F3f_SET
#define FP_PORT_FIELD_SELm_SLICE3_F4f_GET BCM56218_A0_FP_PORT_FIELD_SELm_SLICE3_F4f_GET
#define FP_PORT_FIELD_SELm_SLICE3_F4f_SET BCM56218_A0_FP_PORT_FIELD_SELm_SLICE3_F4f_SET
#define FP_PORT_FIELD_SELm_SLICE4_F1f_GET BCM56218_A0_FP_PORT_FIELD_SELm_SLICE4_F1f_GET
#define FP_PORT_FIELD_SELm_SLICE4_F1f_SET BCM56218_A0_FP_PORT_FIELD_SELm_SLICE4_F1f_SET
#define FP_PORT_FIELD_SELm_SLICE4_F2f_GET BCM56218_A0_FP_PORT_FIELD_SELm_SLICE4_F2f_GET
#define FP_PORT_FIELD_SELm_SLICE4_F2f_SET BCM56218_A0_FP_PORT_FIELD_SELm_SLICE4_F2f_SET
#define FP_PORT_FIELD_SELm_SLICE4_F3f_GET BCM56218_A0_FP_PORT_FIELD_SELm_SLICE4_F3f_GET
#define FP_PORT_FIELD_SELm_SLICE4_F3f_SET BCM56218_A0_FP_PORT_FIELD_SELm_SLICE4_F3f_SET
#define FP_PORT_FIELD_SELm_SLICE4_F4f_GET BCM56218_A0_FP_PORT_FIELD_SELm_SLICE4_F4f_GET
#define FP_PORT_FIELD_SELm_SLICE4_F4f_SET BCM56218_A0_FP_PORT_FIELD_SELm_SLICE4_F4f_SET
#define FP_PORT_FIELD_SELm_SLICE5_F1f_GET BCM56218_A0_FP_PORT_FIELD_SELm_SLICE5_F1f_GET
#define FP_PORT_FIELD_SELm_SLICE5_F1f_SET BCM56218_A0_FP_PORT_FIELD_SELm_SLICE5_F1f_SET
#define FP_PORT_FIELD_SELm_SLICE5_F2f_GET BCM56218_A0_FP_PORT_FIELD_SELm_SLICE5_F2f_GET
#define FP_PORT_FIELD_SELm_SLICE5_F2f_SET BCM56218_A0_FP_PORT_FIELD_SELm_SLICE5_F2f_SET
#define FP_PORT_FIELD_SELm_SLICE5_F3f_GET BCM56218_A0_FP_PORT_FIELD_SELm_SLICE5_F3f_GET
#define FP_PORT_FIELD_SELm_SLICE5_F3f_SET BCM56218_A0_FP_PORT_FIELD_SELm_SLICE5_F3f_SET
#define FP_PORT_FIELD_SELm_SLICE5_F4f_GET BCM56218_A0_FP_PORT_FIELD_SELm_SLICE5_F4f_GET
#define FP_PORT_FIELD_SELm_SLICE5_F4f_SET BCM56218_A0_FP_PORT_FIELD_SELm_SLICE5_F4f_SET
#define FP_PORT_FIELD_SELm_SLICE6_F1f_GET BCM56218_A0_FP_PORT_FIELD_SELm_SLICE6_F1f_GET
#define FP_PORT_FIELD_SELm_SLICE6_F1f_SET BCM56218_A0_FP_PORT_FIELD_SELm_SLICE6_F1f_SET
#define FP_PORT_FIELD_SELm_SLICE6_F2f_GET BCM56218_A0_FP_PORT_FIELD_SELm_SLICE6_F2f_GET
#define FP_PORT_FIELD_SELm_SLICE6_F2f_SET BCM56218_A0_FP_PORT_FIELD_SELm_SLICE6_F2f_SET
#define FP_PORT_FIELD_SELm_SLICE6_F3f_GET BCM56218_A0_FP_PORT_FIELD_SELm_SLICE6_F3f_GET
#define FP_PORT_FIELD_SELm_SLICE6_F3f_SET BCM56218_A0_FP_PORT_FIELD_SELm_SLICE6_F3f_SET
#define FP_PORT_FIELD_SELm_SLICE6_F4f_GET BCM56218_A0_FP_PORT_FIELD_SELm_SLICE6_F4f_GET
#define FP_PORT_FIELD_SELm_SLICE6_F4f_SET BCM56218_A0_FP_PORT_FIELD_SELm_SLICE6_F4f_SET
#define FP_PORT_FIELD_SELm_SLICE7_F1f_GET BCM56218_A0_FP_PORT_FIELD_SELm_SLICE7_F1f_GET
#define FP_PORT_FIELD_SELm_SLICE7_F1f_SET BCM56218_A0_FP_PORT_FIELD_SELm_SLICE7_F1f_SET
#define FP_PORT_FIELD_SELm_SLICE7_F2f_GET BCM56218_A0_FP_PORT_FIELD_SELm_SLICE7_F2f_GET
#define FP_PORT_FIELD_SELm_SLICE7_F2f_SET BCM56218_A0_FP_PORT_FIELD_SELm_SLICE7_F2f_SET
#define FP_PORT_FIELD_SELm_SLICE7_F3f_GET BCM56218_A0_FP_PORT_FIELD_SELm_SLICE7_F3f_GET
#define FP_PORT_FIELD_SELm_SLICE7_F3f_SET BCM56218_A0_FP_PORT_FIELD_SELm_SLICE7_F3f_SET
#define FP_PORT_FIELD_SELm_SLICE7_F4f_GET BCM56218_A0_FP_PORT_FIELD_SELm_SLICE7_F4f_GET
#define FP_PORT_FIELD_SELm_SLICE7_F4f_SET BCM56218_A0_FP_PORT_FIELD_SELm_SLICE7_F4f_SET
#define READ_FP_PORT_FIELD_SELm BCM56218_A0_READ_FP_PORT_FIELD_SELm
#define WRITE_FP_PORT_FIELD_SELm BCM56218_A0_WRITE_FP_PORT_FIELD_SELm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_FP_PORT_FIELD_SELm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  FP_RANGE_CHECK
 * BLOCKS:   IPIPE
 * DESC:     RANGE CHECK VALUES FOR FP
 * SIZE:     34
 * FIELDS:
 *     LOWER_BOUNDS     Lower bounds of range to be checked.
 *     UPPER_BOUNDS     Upper bounds of range to be checked.
 *     ENABLE           Enable range check
 *     SOURCE_DESTINATION_SELECT Selects whether the Source or Destination Port is range checked.
 *
 ******************************************************************************/
#define BCM56218_A0_FP_RANGE_CHECKm 0x0c700000

#define BCM56218_A0_FP_RANGE_CHECKm_MIN 0
#define BCM56218_A0_FP_RANGE_CHECKm_MAX 15
#define BCM56218_A0_FP_RANGE_CHECKm_CMAX(u) 15
#define BCM56218_A0_FP_RANGE_CHECKm_SIZE 5

/*
 * This structure should be used to declare and program FP_RANGE_CHECK.
 *
 */
typedef union BCM56218_A0_FP_RANGE_CHECKm_s {
	uint32_t v[2];
	uint32_t fp_range_check[2];
	uint32_t _fp_range_check;
} BCM56218_A0_FP_RANGE_CHECKm_t;

#define BCM56218_A0_FP_RANGE_CHECKm_CLR(r) CDK_MEMSET(&((r)._fp_range_check), 0, sizeof(BCM56218_A0_FP_RANGE_CHECKm_t))
#define BCM56218_A0_FP_RANGE_CHECKm_SET(r,i,d) (r).fp_range_check[i] = d
#define BCM56218_A0_FP_RANGE_CHECKm_GET(r,i) (r).fp_range_check[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_FP_RANGE_CHECKm_LOWER_BOUNDSf_GET(r) (((r).fp_range_check[0]) & 0xffff)
#define BCM56218_A0_FP_RANGE_CHECKm_LOWER_BOUNDSf_SET(r,f) (r).fp_range_check[0]=(((r).fp_range_check[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56218_A0_FP_RANGE_CHECKm_UPPER_BOUNDSf_GET(r) ((((r).fp_range_check[0]) >> 16) & 0xffff)
#define BCM56218_A0_FP_RANGE_CHECKm_UPPER_BOUNDSf_SET(r,f) (r).fp_range_check[0]=(((r).fp_range_check[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))
#define BCM56218_A0_FP_RANGE_CHECKm_ENABLEf_GET(r) (((r).fp_range_check[1]) & 0x1)
#define BCM56218_A0_FP_RANGE_CHECKm_ENABLEf_SET(r,f) (r).fp_range_check[1]=(((r).fp_range_check[1] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_FP_RANGE_CHECKm_SOURCE_DESTINATION_SELECTf_GET(r) ((((r).fp_range_check[1]) >> 1) & 0x1)
#define BCM56218_A0_FP_RANGE_CHECKm_SOURCE_DESTINATION_SELECTf_SET(r,f) (r).fp_range_check[1]=(((r).fp_range_check[1] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access FP_RANGE_CHECK.
 *
 */
#define BCM56218_A0_READ_FP_RANGE_CHECKm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_FP_RANGE_CHECKm,i,(m._fp_range_check),2)
#define BCM56218_A0_WRITE_FP_RANGE_CHECKm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_FP_RANGE_CHECKm,i,&(m._fp_range_check),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_RANGE_CHECKm BCM56218_A0_FP_RANGE_CHECKm
#define FP_RANGE_CHECKm_MIN BCM56218_A0_FP_RANGE_CHECKm_MIN
#define FP_RANGE_CHECKm_MAX BCM56218_A0_FP_RANGE_CHECKm_MAX
#define FP_RANGE_CHECKm_CMAX(u) BCM56218_A0_FP_RANGE_CHECKm_CMAX(u)
#define FP_RANGE_CHECKm_SIZE BCM56218_A0_FP_RANGE_CHECKm_SIZE
typedef BCM56218_A0_FP_RANGE_CHECKm_t FP_RANGE_CHECKm_t;
#define FP_RANGE_CHECKm_CLR BCM56218_A0_FP_RANGE_CHECKm_CLR
#define FP_RANGE_CHECKm_SET BCM56218_A0_FP_RANGE_CHECKm_SET
#define FP_RANGE_CHECKm_GET BCM56218_A0_FP_RANGE_CHECKm_GET
#define FP_RANGE_CHECKm_LOWER_BOUNDSf_GET BCM56218_A0_FP_RANGE_CHECKm_LOWER_BOUNDSf_GET
#define FP_RANGE_CHECKm_LOWER_BOUNDSf_SET BCM56218_A0_FP_RANGE_CHECKm_LOWER_BOUNDSf_SET
#define FP_RANGE_CHECKm_UPPER_BOUNDSf_GET BCM56218_A0_FP_RANGE_CHECKm_UPPER_BOUNDSf_GET
#define FP_RANGE_CHECKm_UPPER_BOUNDSf_SET BCM56218_A0_FP_RANGE_CHECKm_UPPER_BOUNDSf_SET
#define FP_RANGE_CHECKm_ENABLEf_GET BCM56218_A0_FP_RANGE_CHECKm_ENABLEf_GET
#define FP_RANGE_CHECKm_ENABLEf_SET BCM56218_A0_FP_RANGE_CHECKm_ENABLEf_SET
#define FP_RANGE_CHECKm_SOURCE_DESTINATION_SELECTf_GET BCM56218_A0_FP_RANGE_CHECKm_SOURCE_DESTINATION_SELECTf_GET
#define FP_RANGE_CHECKm_SOURCE_DESTINATION_SELECTf_SET BCM56218_A0_FP_RANGE_CHECKm_SOURCE_DESTINATION_SELECTf_SET
#define READ_FP_RANGE_CHECKm BCM56218_A0_READ_FP_RANGE_CHECKm
#define WRITE_FP_RANGE_CHECKm BCM56218_A0_WRITE_FP_RANGE_CHECKm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_FP_RANGE_CHECKm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  FP_SC_BCAST_METER_TABLE
 * BLOCKS:   IPIPE
 * DESC:     SC METER TABLE STRUCTURES FOR THE FP
 * SIZE:     53
 * FIELDS:
 *     BUCKETCOUNT      BUCKETCOUNT
 *     BUCKETSIZE       BUCKETSIZE
 *     REFRESHCOUNT     REFRESHCOUNT
 *
 ******************************************************************************/
#define BCM56218_A0_FP_SC_BCAST_METER_TABLEm 0x0c780000

#define BCM56218_A0_FP_SC_BCAST_METER_TABLEm_MIN 0
#define BCM56218_A0_FP_SC_BCAST_METER_TABLEm_MAX 53
#define BCM56218_A0_FP_SC_BCAST_METER_TABLEm_CMAX(u) 53
#define BCM56218_A0_FP_SC_BCAST_METER_TABLEm_SIZE 7

/*
 * This structure should be used to declare and program FP_SC_BCAST_METER_TABLE.
 *
 */
typedef union BCM56218_A0_FP_SC_BCAST_METER_TABLEm_s {
	uint32_t v[2];
	uint32_t fp_sc_bcast_meter_table[2];
	uint32_t _fp_sc_bcast_meter_table;
} BCM56218_A0_FP_SC_BCAST_METER_TABLEm_t;

#define BCM56218_A0_FP_SC_BCAST_METER_TABLEm_CLR(r) CDK_MEMSET(&((r)._fp_sc_bcast_meter_table), 0, sizeof(BCM56218_A0_FP_SC_BCAST_METER_TABLEm_t))
#define BCM56218_A0_FP_SC_BCAST_METER_TABLEm_SET(r,i,d) (r).fp_sc_bcast_meter_table[i] = d
#define BCM56218_A0_FP_SC_BCAST_METER_TABLEm_GET(r,i) (r).fp_sc_bcast_meter_table[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_FP_SC_BCAST_METER_TABLEm_BUCKETCOUNTf_GET(r) (((r).fp_sc_bcast_meter_table[0]) & 0x3fffffff)
#define BCM56218_A0_FP_SC_BCAST_METER_TABLEm_BUCKETCOUNTf_SET(r,f) (r).fp_sc_bcast_meter_table[0]=(((r).fp_sc_bcast_meter_table[0] & ~((uint32_t)0x3fffffff)) | (((uint32_t)f) & 0x3fffffff))
#define BCM56218_A0_FP_SC_BCAST_METER_TABLEm_BUCKETSIZEf_GET(r) cdk_field32_get((r).fp_sc_bcast_meter_table,30,33)
#define BCM56218_A0_FP_SC_BCAST_METER_TABLEm_BUCKETSIZEf_SET(r,f) cdk_field32_set((r).fp_sc_bcast_meter_table,30,33,f)
#define BCM56218_A0_FP_SC_BCAST_METER_TABLEm_REFRESHCOUNTf_GET(r) ((((r).fp_sc_bcast_meter_table[1]) >> 2) & 0x7ffff)
#define BCM56218_A0_FP_SC_BCAST_METER_TABLEm_REFRESHCOUNTf_SET(r,f) (r).fp_sc_bcast_meter_table[1]=(((r).fp_sc_bcast_meter_table[1] & ~((uint32_t)0x7ffff << 2)) | ((((uint32_t)f) & 0x7ffff) << 2))

/*
 * These macros can be used to access FP_SC_BCAST_METER_TABLE.
 *
 */
#define BCM56218_A0_READ_FP_SC_BCAST_METER_TABLEm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_FP_SC_BCAST_METER_TABLEm,i,(m._fp_sc_bcast_meter_table),2)
#define BCM56218_A0_WRITE_FP_SC_BCAST_METER_TABLEm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_FP_SC_BCAST_METER_TABLEm,i,&(m._fp_sc_bcast_meter_table),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_SC_BCAST_METER_TABLEm BCM56218_A0_FP_SC_BCAST_METER_TABLEm
#define FP_SC_BCAST_METER_TABLEm_MIN BCM56218_A0_FP_SC_BCAST_METER_TABLEm_MIN
#define FP_SC_BCAST_METER_TABLEm_MAX BCM56218_A0_FP_SC_BCAST_METER_TABLEm_MAX
#define FP_SC_BCAST_METER_TABLEm_CMAX(u) BCM56218_A0_FP_SC_BCAST_METER_TABLEm_CMAX(u)
#define FP_SC_BCAST_METER_TABLEm_SIZE BCM56218_A0_FP_SC_BCAST_METER_TABLEm_SIZE
typedef BCM56218_A0_FP_SC_BCAST_METER_TABLEm_t FP_SC_BCAST_METER_TABLEm_t;
#define FP_SC_BCAST_METER_TABLEm_CLR BCM56218_A0_FP_SC_BCAST_METER_TABLEm_CLR
#define FP_SC_BCAST_METER_TABLEm_SET BCM56218_A0_FP_SC_BCAST_METER_TABLEm_SET
#define FP_SC_BCAST_METER_TABLEm_GET BCM56218_A0_FP_SC_BCAST_METER_TABLEm_GET
#define FP_SC_BCAST_METER_TABLEm_BUCKETCOUNTf_GET BCM56218_A0_FP_SC_BCAST_METER_TABLEm_BUCKETCOUNTf_GET
#define FP_SC_BCAST_METER_TABLEm_BUCKETCOUNTf_SET BCM56218_A0_FP_SC_BCAST_METER_TABLEm_BUCKETCOUNTf_SET
#define FP_SC_BCAST_METER_TABLEm_BUCKETSIZEf_GET BCM56218_A0_FP_SC_BCAST_METER_TABLEm_BUCKETSIZEf_GET
#define FP_SC_BCAST_METER_TABLEm_BUCKETSIZEf_SET BCM56218_A0_FP_SC_BCAST_METER_TABLEm_BUCKETSIZEf_SET
#define FP_SC_BCAST_METER_TABLEm_REFRESHCOUNTf_GET BCM56218_A0_FP_SC_BCAST_METER_TABLEm_REFRESHCOUNTf_GET
#define FP_SC_BCAST_METER_TABLEm_REFRESHCOUNTf_SET BCM56218_A0_FP_SC_BCAST_METER_TABLEm_REFRESHCOUNTf_SET
#define READ_FP_SC_BCAST_METER_TABLEm BCM56218_A0_READ_FP_SC_BCAST_METER_TABLEm
#define WRITE_FP_SC_BCAST_METER_TABLEm BCM56218_A0_WRITE_FP_SC_BCAST_METER_TABLEm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_FP_SC_BCAST_METER_TABLEm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  FP_SC_DLF_METER_TABLE
 * BLOCKS:   IPIPE
 * DESC:     SC METER TABLE STRUCTURES FOR THE FP
 * SIZE:     53
 * FIELDS:
 *     BUCKETCOUNT      BUCKETCOUNT
 *     BUCKETSIZE       BUCKETSIZE
 *     REFRESHCOUNT     REFRESHCOUNT
 *
 ******************************************************************************/
#define BCM56218_A0_FP_SC_DLF_METER_TABLEm 0x0c78006c

#define BCM56218_A0_FP_SC_DLF_METER_TABLEm_MIN 0
#define BCM56218_A0_FP_SC_DLF_METER_TABLEm_MAX 53
#define BCM56218_A0_FP_SC_DLF_METER_TABLEm_CMAX(u) 53
#define BCM56218_A0_FP_SC_DLF_METER_TABLEm_SIZE 7

/*
 * This structure should be used to declare and program FP_SC_DLF_METER_TABLE.
 *
 */
typedef union BCM56218_A0_FP_SC_DLF_METER_TABLEm_s {
	uint32_t v[2];
	uint32_t fp_sc_dlf_meter_table[2];
	uint32_t _fp_sc_dlf_meter_table;
} BCM56218_A0_FP_SC_DLF_METER_TABLEm_t;

#define BCM56218_A0_FP_SC_DLF_METER_TABLEm_CLR(r) CDK_MEMSET(&((r)._fp_sc_dlf_meter_table), 0, sizeof(BCM56218_A0_FP_SC_DLF_METER_TABLEm_t))
#define BCM56218_A0_FP_SC_DLF_METER_TABLEm_SET(r,i,d) (r).fp_sc_dlf_meter_table[i] = d
#define BCM56218_A0_FP_SC_DLF_METER_TABLEm_GET(r,i) (r).fp_sc_dlf_meter_table[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_FP_SC_DLF_METER_TABLEm_BUCKETCOUNTf_GET(r) (((r).fp_sc_dlf_meter_table[0]) & 0x3fffffff)
#define BCM56218_A0_FP_SC_DLF_METER_TABLEm_BUCKETCOUNTf_SET(r,f) (r).fp_sc_dlf_meter_table[0]=(((r).fp_sc_dlf_meter_table[0] & ~((uint32_t)0x3fffffff)) | (((uint32_t)f) & 0x3fffffff))
#define BCM56218_A0_FP_SC_DLF_METER_TABLEm_BUCKETSIZEf_GET(r) cdk_field32_get((r).fp_sc_dlf_meter_table,30,33)
#define BCM56218_A0_FP_SC_DLF_METER_TABLEm_BUCKETSIZEf_SET(r,f) cdk_field32_set((r).fp_sc_dlf_meter_table,30,33,f)
#define BCM56218_A0_FP_SC_DLF_METER_TABLEm_REFRESHCOUNTf_GET(r) ((((r).fp_sc_dlf_meter_table[1]) >> 2) & 0x7ffff)
#define BCM56218_A0_FP_SC_DLF_METER_TABLEm_REFRESHCOUNTf_SET(r,f) (r).fp_sc_dlf_meter_table[1]=(((r).fp_sc_dlf_meter_table[1] & ~((uint32_t)0x7ffff << 2)) | ((((uint32_t)f) & 0x7ffff) << 2))

/*
 * These macros can be used to access FP_SC_DLF_METER_TABLE.
 *
 */
#define BCM56218_A0_READ_FP_SC_DLF_METER_TABLEm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_FP_SC_DLF_METER_TABLEm,i,(m._fp_sc_dlf_meter_table),2)
#define BCM56218_A0_WRITE_FP_SC_DLF_METER_TABLEm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_FP_SC_DLF_METER_TABLEm,i,&(m._fp_sc_dlf_meter_table),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_SC_DLF_METER_TABLEm BCM56218_A0_FP_SC_DLF_METER_TABLEm
#define FP_SC_DLF_METER_TABLEm_MIN BCM56218_A0_FP_SC_DLF_METER_TABLEm_MIN
#define FP_SC_DLF_METER_TABLEm_MAX BCM56218_A0_FP_SC_DLF_METER_TABLEm_MAX
#define FP_SC_DLF_METER_TABLEm_CMAX(u) BCM56218_A0_FP_SC_DLF_METER_TABLEm_CMAX(u)
#define FP_SC_DLF_METER_TABLEm_SIZE BCM56218_A0_FP_SC_DLF_METER_TABLEm_SIZE
typedef BCM56218_A0_FP_SC_DLF_METER_TABLEm_t FP_SC_DLF_METER_TABLEm_t;
#define FP_SC_DLF_METER_TABLEm_CLR BCM56218_A0_FP_SC_DLF_METER_TABLEm_CLR
#define FP_SC_DLF_METER_TABLEm_SET BCM56218_A0_FP_SC_DLF_METER_TABLEm_SET
#define FP_SC_DLF_METER_TABLEm_GET BCM56218_A0_FP_SC_DLF_METER_TABLEm_GET
#define FP_SC_DLF_METER_TABLEm_BUCKETCOUNTf_GET BCM56218_A0_FP_SC_DLF_METER_TABLEm_BUCKETCOUNTf_GET
#define FP_SC_DLF_METER_TABLEm_BUCKETCOUNTf_SET BCM56218_A0_FP_SC_DLF_METER_TABLEm_BUCKETCOUNTf_SET
#define FP_SC_DLF_METER_TABLEm_BUCKETSIZEf_GET BCM56218_A0_FP_SC_DLF_METER_TABLEm_BUCKETSIZEf_GET
#define FP_SC_DLF_METER_TABLEm_BUCKETSIZEf_SET BCM56218_A0_FP_SC_DLF_METER_TABLEm_BUCKETSIZEf_SET
#define FP_SC_DLF_METER_TABLEm_REFRESHCOUNTf_GET BCM56218_A0_FP_SC_DLF_METER_TABLEm_REFRESHCOUNTf_GET
#define FP_SC_DLF_METER_TABLEm_REFRESHCOUNTf_SET BCM56218_A0_FP_SC_DLF_METER_TABLEm_REFRESHCOUNTf_SET
#define READ_FP_SC_DLF_METER_TABLEm BCM56218_A0_READ_FP_SC_DLF_METER_TABLEm
#define WRITE_FP_SC_DLF_METER_TABLEm BCM56218_A0_WRITE_FP_SC_DLF_METER_TABLEm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_FP_SC_DLF_METER_TABLEm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  FP_SC_MCAST_METER_TABLE
 * BLOCKS:   IPIPE
 * DESC:     SC METER TABLE STRUCTURES FOR THE FP
 * SIZE:     53
 * FIELDS:
 *     BUCKETCOUNT      BUCKETCOUNT
 *     BUCKETSIZE       BUCKETSIZE
 *     REFRESHCOUNT     REFRESHCOUNT
 *
 ******************************************************************************/
#define BCM56218_A0_FP_SC_MCAST_METER_TABLEm 0x0c780036

#define BCM56218_A0_FP_SC_MCAST_METER_TABLEm_MIN 0
#define BCM56218_A0_FP_SC_MCAST_METER_TABLEm_MAX 53
#define BCM56218_A0_FP_SC_MCAST_METER_TABLEm_CMAX(u) 53
#define BCM56218_A0_FP_SC_MCAST_METER_TABLEm_SIZE 7

/*
 * This structure should be used to declare and program FP_SC_MCAST_METER_TABLE.
 *
 */
typedef union BCM56218_A0_FP_SC_MCAST_METER_TABLEm_s {
	uint32_t v[2];
	uint32_t fp_sc_mcast_meter_table[2];
	uint32_t _fp_sc_mcast_meter_table;
} BCM56218_A0_FP_SC_MCAST_METER_TABLEm_t;

#define BCM56218_A0_FP_SC_MCAST_METER_TABLEm_CLR(r) CDK_MEMSET(&((r)._fp_sc_mcast_meter_table), 0, sizeof(BCM56218_A0_FP_SC_MCAST_METER_TABLEm_t))
#define BCM56218_A0_FP_SC_MCAST_METER_TABLEm_SET(r,i,d) (r).fp_sc_mcast_meter_table[i] = d
#define BCM56218_A0_FP_SC_MCAST_METER_TABLEm_GET(r,i) (r).fp_sc_mcast_meter_table[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_FP_SC_MCAST_METER_TABLEm_BUCKETCOUNTf_GET(r) (((r).fp_sc_mcast_meter_table[0]) & 0x3fffffff)
#define BCM56218_A0_FP_SC_MCAST_METER_TABLEm_BUCKETCOUNTf_SET(r,f) (r).fp_sc_mcast_meter_table[0]=(((r).fp_sc_mcast_meter_table[0] & ~((uint32_t)0x3fffffff)) | (((uint32_t)f) & 0x3fffffff))
#define BCM56218_A0_FP_SC_MCAST_METER_TABLEm_BUCKETSIZEf_GET(r) cdk_field32_get((r).fp_sc_mcast_meter_table,30,33)
#define BCM56218_A0_FP_SC_MCAST_METER_TABLEm_BUCKETSIZEf_SET(r,f) cdk_field32_set((r).fp_sc_mcast_meter_table,30,33,f)
#define BCM56218_A0_FP_SC_MCAST_METER_TABLEm_REFRESHCOUNTf_GET(r) ((((r).fp_sc_mcast_meter_table[1]) >> 2) & 0x7ffff)
#define BCM56218_A0_FP_SC_MCAST_METER_TABLEm_REFRESHCOUNTf_SET(r,f) (r).fp_sc_mcast_meter_table[1]=(((r).fp_sc_mcast_meter_table[1] & ~((uint32_t)0x7ffff << 2)) | ((((uint32_t)f) & 0x7ffff) << 2))

/*
 * These macros can be used to access FP_SC_MCAST_METER_TABLE.
 *
 */
#define BCM56218_A0_READ_FP_SC_MCAST_METER_TABLEm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_FP_SC_MCAST_METER_TABLEm,i,(m._fp_sc_mcast_meter_table),2)
#define BCM56218_A0_WRITE_FP_SC_MCAST_METER_TABLEm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_FP_SC_MCAST_METER_TABLEm,i,&(m._fp_sc_mcast_meter_table),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_SC_MCAST_METER_TABLEm BCM56218_A0_FP_SC_MCAST_METER_TABLEm
#define FP_SC_MCAST_METER_TABLEm_MIN BCM56218_A0_FP_SC_MCAST_METER_TABLEm_MIN
#define FP_SC_MCAST_METER_TABLEm_MAX BCM56218_A0_FP_SC_MCAST_METER_TABLEm_MAX
#define FP_SC_MCAST_METER_TABLEm_CMAX(u) BCM56218_A0_FP_SC_MCAST_METER_TABLEm_CMAX(u)
#define FP_SC_MCAST_METER_TABLEm_SIZE BCM56218_A0_FP_SC_MCAST_METER_TABLEm_SIZE
typedef BCM56218_A0_FP_SC_MCAST_METER_TABLEm_t FP_SC_MCAST_METER_TABLEm_t;
#define FP_SC_MCAST_METER_TABLEm_CLR BCM56218_A0_FP_SC_MCAST_METER_TABLEm_CLR
#define FP_SC_MCAST_METER_TABLEm_SET BCM56218_A0_FP_SC_MCAST_METER_TABLEm_SET
#define FP_SC_MCAST_METER_TABLEm_GET BCM56218_A0_FP_SC_MCAST_METER_TABLEm_GET
#define FP_SC_MCAST_METER_TABLEm_BUCKETCOUNTf_GET BCM56218_A0_FP_SC_MCAST_METER_TABLEm_BUCKETCOUNTf_GET
#define FP_SC_MCAST_METER_TABLEm_BUCKETCOUNTf_SET BCM56218_A0_FP_SC_MCAST_METER_TABLEm_BUCKETCOUNTf_SET
#define FP_SC_MCAST_METER_TABLEm_BUCKETSIZEf_GET BCM56218_A0_FP_SC_MCAST_METER_TABLEm_BUCKETSIZEf_GET
#define FP_SC_MCAST_METER_TABLEm_BUCKETSIZEf_SET BCM56218_A0_FP_SC_MCAST_METER_TABLEm_BUCKETSIZEf_SET
#define FP_SC_MCAST_METER_TABLEm_REFRESHCOUNTf_GET BCM56218_A0_FP_SC_MCAST_METER_TABLEm_REFRESHCOUNTf_GET
#define FP_SC_MCAST_METER_TABLEm_REFRESHCOUNTf_SET BCM56218_A0_FP_SC_MCAST_METER_TABLEm_REFRESHCOUNTf_SET
#define READ_FP_SC_MCAST_METER_TABLEm BCM56218_A0_READ_FP_SC_MCAST_METER_TABLEm
#define WRITE_FP_SC_MCAST_METER_TABLEm BCM56218_A0_WRITE_FP_SC_MCAST_METER_TABLEm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_FP_SC_MCAST_METER_TABLEm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  FP_SC_METER_TABLE
 * BLOCKS:   IPIPE
 * DESC:     SC METER TABLE STRUCTURES FOR THE FP
 * SIZE:     53
 * FIELDS:
 *     BUCKETCOUNT      BUCKETCOUNT
 *     BUCKETSIZE       BUCKETSIZE
 *     REFRESHCOUNT     REFRESHCOUNT
 *
 ******************************************************************************/
#define BCM56218_A0_FP_SC_METER_TABLEm 0x0c780000

#define BCM56218_A0_FP_SC_METER_TABLEm_MIN 0
#define BCM56218_A0_FP_SC_METER_TABLEm_MAX 161
#define BCM56218_A0_FP_SC_METER_TABLEm_CMAX(u) 161
#define BCM56218_A0_FP_SC_METER_TABLEm_SIZE 7

/*
 * This structure should be used to declare and program FP_SC_METER_TABLE.
 *
 */
typedef union BCM56218_A0_FP_SC_METER_TABLEm_s {
	uint32_t v[2];
	uint32_t fp_sc_meter_table[2];
	uint32_t _fp_sc_meter_table;
} BCM56218_A0_FP_SC_METER_TABLEm_t;

#define BCM56218_A0_FP_SC_METER_TABLEm_CLR(r) CDK_MEMSET(&((r)._fp_sc_meter_table), 0, sizeof(BCM56218_A0_FP_SC_METER_TABLEm_t))
#define BCM56218_A0_FP_SC_METER_TABLEm_SET(r,i,d) (r).fp_sc_meter_table[i] = d
#define BCM56218_A0_FP_SC_METER_TABLEm_GET(r,i) (r).fp_sc_meter_table[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_FP_SC_METER_TABLEm_BUCKETCOUNTf_GET(r) (((r).fp_sc_meter_table[0]) & 0x3fffffff)
#define BCM56218_A0_FP_SC_METER_TABLEm_BUCKETCOUNTf_SET(r,f) (r).fp_sc_meter_table[0]=(((r).fp_sc_meter_table[0] & ~((uint32_t)0x3fffffff)) | (((uint32_t)f) & 0x3fffffff))
#define BCM56218_A0_FP_SC_METER_TABLEm_BUCKETSIZEf_GET(r) cdk_field32_get((r).fp_sc_meter_table,30,33)
#define BCM56218_A0_FP_SC_METER_TABLEm_BUCKETSIZEf_SET(r,f) cdk_field32_set((r).fp_sc_meter_table,30,33,f)
#define BCM56218_A0_FP_SC_METER_TABLEm_REFRESHCOUNTf_GET(r) ((((r).fp_sc_meter_table[1]) >> 2) & 0x7ffff)
#define BCM56218_A0_FP_SC_METER_TABLEm_REFRESHCOUNTf_SET(r,f) (r).fp_sc_meter_table[1]=(((r).fp_sc_meter_table[1] & ~((uint32_t)0x7ffff << 2)) | ((((uint32_t)f) & 0x7ffff) << 2))

/*
 * These macros can be used to access FP_SC_METER_TABLE.
 *
 */
#define BCM56218_A0_READ_FP_SC_METER_TABLEm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_FP_SC_METER_TABLEm,i,(m._fp_sc_meter_table),2)
#define BCM56218_A0_WRITE_FP_SC_METER_TABLEm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_FP_SC_METER_TABLEm,i,&(m._fp_sc_meter_table),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_SC_METER_TABLEm BCM56218_A0_FP_SC_METER_TABLEm
#define FP_SC_METER_TABLEm_MIN BCM56218_A0_FP_SC_METER_TABLEm_MIN
#define FP_SC_METER_TABLEm_MAX BCM56218_A0_FP_SC_METER_TABLEm_MAX
#define FP_SC_METER_TABLEm_CMAX(u) BCM56218_A0_FP_SC_METER_TABLEm_CMAX(u)
#define FP_SC_METER_TABLEm_SIZE BCM56218_A0_FP_SC_METER_TABLEm_SIZE
typedef BCM56218_A0_FP_SC_METER_TABLEm_t FP_SC_METER_TABLEm_t;
#define FP_SC_METER_TABLEm_CLR BCM56218_A0_FP_SC_METER_TABLEm_CLR
#define FP_SC_METER_TABLEm_SET BCM56218_A0_FP_SC_METER_TABLEm_SET
#define FP_SC_METER_TABLEm_GET BCM56218_A0_FP_SC_METER_TABLEm_GET
#define FP_SC_METER_TABLEm_BUCKETCOUNTf_GET BCM56218_A0_FP_SC_METER_TABLEm_BUCKETCOUNTf_GET
#define FP_SC_METER_TABLEm_BUCKETCOUNTf_SET BCM56218_A0_FP_SC_METER_TABLEm_BUCKETCOUNTf_SET
#define FP_SC_METER_TABLEm_BUCKETSIZEf_GET BCM56218_A0_FP_SC_METER_TABLEm_BUCKETSIZEf_GET
#define FP_SC_METER_TABLEm_BUCKETSIZEf_SET BCM56218_A0_FP_SC_METER_TABLEm_BUCKETSIZEf_SET
#define FP_SC_METER_TABLEm_REFRESHCOUNTf_GET BCM56218_A0_FP_SC_METER_TABLEm_REFRESHCOUNTf_GET
#define FP_SC_METER_TABLEm_REFRESHCOUNTf_SET BCM56218_A0_FP_SC_METER_TABLEm_REFRESHCOUNTf_SET
#define READ_FP_SC_METER_TABLEm BCM56218_A0_READ_FP_SC_METER_TABLEm
#define WRITE_FP_SC_METER_TABLEm BCM56218_A0_WRITE_FP_SC_METER_TABLEm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_FP_SC_METER_TABLEm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  FP_SLICE_CONFIG
 * BLOCKS:   IPIPE
 * DESC:     FP_SLICE_CONFIG
 * SIZE:     32
 * FIELDS:
 *     SLICE_0_MODE     CONFIG FOR SLICE 0: 00=Single Wide 01=Double Wide (with SLICE 1) 10=Triple Wide (with SLICES 1 & 2)  11=N/A
 *     SLICE_1_MODE     CONFIG FOR SLICE 1: 00=Single Wide 01=Double Wide (with SLICE 0) 10=Triple Wide ( with SLICES 0 & 2 ) 11=N/A
 *     SLICE_2_MODE     CONFIG FOR SLICE 2: 00=Single Wide 01=Double Wide (with SLICE 3) 10=Triple Wide ( with SLICES 0 & 1 ) 11=N/A
 *     SLICE_3_MODE     CONFIG FOR SLICE 3: 0=Single Wide 1=Double Wide (with SLICE 2) 
 *     SLICE_4_MODE     CONFIG FOR SLICE 4: 00=Single Wide 01=Double Wide (with SLICE 5) 10=Triple Wide ( with SLICES 5 & 6 ) 11=N/A
 *     SLICE_5_MODE     CONFIG FOR SLICE 5: 00=Single Wide 01=Double Wide (with SLICE 4) 10=Triple Wide ( with SLICES 4 & 6 ) 11=N/A
 *     SLICE_6_MODE     CONFIG FOR SLICE 6: 00=Single Wide 01=Double Wide (with SLICE 7) 10=Triple Wide ( with SLICES 4 & 5 ) 11=N/A
 *     SLICE_7_MODE     CONFIG FOR SLICE 7: 0=Single Wide 1=Double Wide (with SLICE 6) 
 *
 ******************************************************************************/
#define BCM56218_A0_FP_SLICE_CONFIGr 0x0c780017

#define BCM56218_A0_FP_SLICE_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program FP_SLICE_CONFIG.
 *
 */
typedef union BCM56218_A0_FP_SLICE_CONFIGr_s {
	uint32_t v[1];
	uint32_t fp_slice_config[1];
	uint32_t _fp_slice_config;
} BCM56218_A0_FP_SLICE_CONFIGr_t;

#define BCM56218_A0_FP_SLICE_CONFIGr_CLR(r) (r).fp_slice_config[0] = 0
#define BCM56218_A0_FP_SLICE_CONFIGr_SET(r,d) (r).fp_slice_config[0] = d
#define BCM56218_A0_FP_SLICE_CONFIGr_GET(r) (r).fp_slice_config[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_FP_SLICE_CONFIGr_SLICE_0_MODEf_GET(r) (((r).fp_slice_config[0]) & 0x3)
#define BCM56218_A0_FP_SLICE_CONFIGr_SLICE_0_MODEf_SET(r,f) (r).fp_slice_config[0]=(((r).fp_slice_config[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56218_A0_FP_SLICE_CONFIGr_SLICE_1_MODEf_GET(r) ((((r).fp_slice_config[0]) >> 2) & 0x3)
#define BCM56218_A0_FP_SLICE_CONFIGr_SLICE_1_MODEf_SET(r,f) (r).fp_slice_config[0]=(((r).fp_slice_config[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM56218_A0_FP_SLICE_CONFIGr_SLICE_2_MODEf_GET(r) ((((r).fp_slice_config[0]) >> 4) & 0x3)
#define BCM56218_A0_FP_SLICE_CONFIGr_SLICE_2_MODEf_SET(r,f) (r).fp_slice_config[0]=(((r).fp_slice_config[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM56218_A0_FP_SLICE_CONFIGr_SLICE_3_MODEf_GET(r) ((((r).fp_slice_config[0]) >> 6) & 0x1)
#define BCM56218_A0_FP_SLICE_CONFIGr_SLICE_3_MODEf_SET(r,f) (r).fp_slice_config[0]=(((r).fp_slice_config[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56218_A0_FP_SLICE_CONFIGr_SLICE_4_MODEf_GET(r) ((((r).fp_slice_config[0]) >> 8) & 0x3)
#define BCM56218_A0_FP_SLICE_CONFIGr_SLICE_4_MODEf_SET(r,f) (r).fp_slice_config[0]=(((r).fp_slice_config[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM56218_A0_FP_SLICE_CONFIGr_SLICE_5_MODEf_GET(r) ((((r).fp_slice_config[0]) >> 10) & 0x3)
#define BCM56218_A0_FP_SLICE_CONFIGr_SLICE_5_MODEf_SET(r,f) (r).fp_slice_config[0]=(((r).fp_slice_config[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCM56218_A0_FP_SLICE_CONFIGr_SLICE_6_MODEf_GET(r) ((((r).fp_slice_config[0]) >> 12) & 0x3)
#define BCM56218_A0_FP_SLICE_CONFIGr_SLICE_6_MODEf_SET(r,f) (r).fp_slice_config[0]=(((r).fp_slice_config[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM56218_A0_FP_SLICE_CONFIGr_SLICE_7_MODEf_GET(r) ((((r).fp_slice_config[0]) >> 14) & 0x1)
#define BCM56218_A0_FP_SLICE_CONFIGr_SLICE_7_MODEf_SET(r,f) (r).fp_slice_config[0]=(((r).fp_slice_config[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))

/*
 * These macros can be used to access FP_SLICE_CONFIG.
 *
 */
#define BCM56218_A0_READ_FP_SLICE_CONFIGr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_FP_SLICE_CONFIGr,(r._fp_slice_config))
#define BCM56218_A0_WRITE_FP_SLICE_CONFIGr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_FP_SLICE_CONFIGr,&(r._fp_slice_config))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_SLICE_CONFIGr BCM56218_A0_FP_SLICE_CONFIGr
#define FP_SLICE_CONFIGr_SIZE BCM56218_A0_FP_SLICE_CONFIGr_SIZE
typedef BCM56218_A0_FP_SLICE_CONFIGr_t FP_SLICE_CONFIGr_t;
#define FP_SLICE_CONFIGr_CLR BCM56218_A0_FP_SLICE_CONFIGr_CLR
#define FP_SLICE_CONFIGr_SET BCM56218_A0_FP_SLICE_CONFIGr_SET
#define FP_SLICE_CONFIGr_GET BCM56218_A0_FP_SLICE_CONFIGr_GET
#define FP_SLICE_CONFIGr_SLICE_0_MODEf_GET BCM56218_A0_FP_SLICE_CONFIGr_SLICE_0_MODEf_GET
#define FP_SLICE_CONFIGr_SLICE_0_MODEf_SET BCM56218_A0_FP_SLICE_CONFIGr_SLICE_0_MODEf_SET
#define FP_SLICE_CONFIGr_SLICE_1_MODEf_GET BCM56218_A0_FP_SLICE_CONFIGr_SLICE_1_MODEf_GET
#define FP_SLICE_CONFIGr_SLICE_1_MODEf_SET BCM56218_A0_FP_SLICE_CONFIGr_SLICE_1_MODEf_SET
#define FP_SLICE_CONFIGr_SLICE_2_MODEf_GET BCM56218_A0_FP_SLICE_CONFIGr_SLICE_2_MODEf_GET
#define FP_SLICE_CONFIGr_SLICE_2_MODEf_SET BCM56218_A0_FP_SLICE_CONFIGr_SLICE_2_MODEf_SET
#define FP_SLICE_CONFIGr_SLICE_3_MODEf_GET BCM56218_A0_FP_SLICE_CONFIGr_SLICE_3_MODEf_GET
#define FP_SLICE_CONFIGr_SLICE_3_MODEf_SET BCM56218_A0_FP_SLICE_CONFIGr_SLICE_3_MODEf_SET
#define FP_SLICE_CONFIGr_SLICE_4_MODEf_GET BCM56218_A0_FP_SLICE_CONFIGr_SLICE_4_MODEf_GET
#define FP_SLICE_CONFIGr_SLICE_4_MODEf_SET BCM56218_A0_FP_SLICE_CONFIGr_SLICE_4_MODEf_SET
#define FP_SLICE_CONFIGr_SLICE_5_MODEf_GET BCM56218_A0_FP_SLICE_CONFIGr_SLICE_5_MODEf_GET
#define FP_SLICE_CONFIGr_SLICE_5_MODEf_SET BCM56218_A0_FP_SLICE_CONFIGr_SLICE_5_MODEf_SET
#define FP_SLICE_CONFIGr_SLICE_6_MODEf_GET BCM56218_A0_FP_SLICE_CONFIGr_SLICE_6_MODEf_GET
#define FP_SLICE_CONFIGr_SLICE_6_MODEf_SET BCM56218_A0_FP_SLICE_CONFIGr_SLICE_6_MODEf_SET
#define FP_SLICE_CONFIGr_SLICE_7_MODEf_GET BCM56218_A0_FP_SLICE_CONFIGr_SLICE_7_MODEf_GET
#define FP_SLICE_CONFIGr_SLICE_7_MODEf_SET BCM56218_A0_FP_SLICE_CONFIGr_SLICE_7_MODEf_SET
#define READ_FP_SLICE_CONFIGr BCM56218_A0_READ_FP_SLICE_CONFIGr
#define WRITE_FP_SLICE_CONFIGr BCM56218_A0_WRITE_FP_SLICE_CONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_FP_SLICE_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  FP_SLICE_ENABLE
 * BLOCKS:   IPIPE
 * DESC:     FP_SLICE_ENABLE
 * SIZE:     32
 * FIELDS:
 *     FP_SLICE_ENABLE_SLICE_0 FP_SLICE_ENABLE FOR FP SLICE 0
 *     FP_SLICE_ENABLE_SLICE_1 FP_SLICE_ENABLE FOR FP SLICE 1
 *     FP_SLICE_ENABLE_SLICE_2 FP_SLICE_ENABLE FOR FP SLICE 2
 *     FP_SLICE_ENABLE_SLICE_3 FP_SLICE_ENABLE FOR FP SLICE 3
 *     FP_SLICE_ENABLE_SLICE_4 FP_SLICE_ENABLE FOR FP SLICE 4
 *     FP_SLICE_ENABLE_SLICE_5 FP_SLICE_ENABLE FOR FP SLICE 5
 *     FP_SLICE_ENABLE_SLICE_6 FP_SLICE_ENABLE FOR FP SLICE 6
 *     FP_SLICE_ENABLE_SLICE_7 FP_SLICE_ENABLE FOR FP SLICE 7
 *     FP_LOOKUP_ENABLE_SLICE_0 LOOKUP ENABLE FOR FP SLICE 0
 *     FP_LOOKUP_ENABLE_SLICE_1 LOOKUP ENABLE FOR FP SLICE 1
 *     FP_LOOKUP_ENABLE_SLICE_2 LOOKUP ENABLE FOR FP SLICE 2
 *     FP_LOOKUP_ENABLE_SLICE_3 LOOKUP ENABLE FOR FP SLICE 3
 *     FP_LOOKUP_ENABLE_SLICE_4 LOOKUP ENABLE FOR FP SLICE 4
 *     FP_LOOKUP_ENABLE_SLICE_5 LOOKUP ENABLE FOR FP SLICE 5
 *     FP_LOOKUP_ENABLE_SLICE_6 LOOKUP ENABLE FOR FP SLICE 6
 *     FP_LOOKUP_ENABLE_SLICE_7 LOOKUP ENABLE FOR FP SLICE 7
 *
 ******************************************************************************/
#define BCM56218_A0_FP_SLICE_ENABLEr 0x0c78000b

#define BCM56218_A0_FP_SLICE_ENABLEr_SIZE 4

/*
 * This structure should be used to declare and program FP_SLICE_ENABLE.
 *
 */
typedef union BCM56218_A0_FP_SLICE_ENABLEr_s {
	uint32_t v[1];
	uint32_t fp_slice_enable[1];
	uint32_t _fp_slice_enable;
} BCM56218_A0_FP_SLICE_ENABLEr_t;

#define BCM56218_A0_FP_SLICE_ENABLEr_CLR(r) (r).fp_slice_enable[0] = 0
#define BCM56218_A0_FP_SLICE_ENABLEr_SET(r,d) (r).fp_slice_enable[0] = d
#define BCM56218_A0_FP_SLICE_ENABLEr_GET(r) (r).fp_slice_enable[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_0f_GET(r) (((r).fp_slice_enable[0]) & 0x1)
#define BCM56218_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_0f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_1f_GET(r) ((((r).fp_slice_enable[0]) >> 1) & 0x1)
#define BCM56218_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_1f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_2f_GET(r) ((((r).fp_slice_enable[0]) >> 2) & 0x1)
#define BCM56218_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_2f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_3f_GET(r) ((((r).fp_slice_enable[0]) >> 3) & 0x1)
#define BCM56218_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_3f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56218_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_4f_GET(r) ((((r).fp_slice_enable[0]) >> 4) & 0x1)
#define BCM56218_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_4f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56218_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_5f_GET(r) ((((r).fp_slice_enable[0]) >> 5) & 0x1)
#define BCM56218_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_5f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56218_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_6f_GET(r) ((((r).fp_slice_enable[0]) >> 6) & 0x1)
#define BCM56218_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_6f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56218_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_7f_GET(r) ((((r).fp_slice_enable[0]) >> 7) & 0x1)
#define BCM56218_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_7f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56218_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_0f_GET(r) ((((r).fp_slice_enable[0]) >> 8) & 0x1)
#define BCM56218_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_0f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56218_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_1f_GET(r) ((((r).fp_slice_enable[0]) >> 9) & 0x1)
#define BCM56218_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_1f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56218_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_2f_GET(r) ((((r).fp_slice_enable[0]) >> 10) & 0x1)
#define BCM56218_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_2f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56218_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_3f_GET(r) ((((r).fp_slice_enable[0]) >> 11) & 0x1)
#define BCM56218_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_3f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56218_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_4f_GET(r) ((((r).fp_slice_enable[0]) >> 12) & 0x1)
#define BCM56218_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_4f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM56218_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_5f_GET(r) ((((r).fp_slice_enable[0]) >> 13) & 0x1)
#define BCM56218_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_5f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56218_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_6f_GET(r) ((((r).fp_slice_enable[0]) >> 14) & 0x1)
#define BCM56218_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_6f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM56218_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_7f_GET(r) ((((r).fp_slice_enable[0]) >> 15) & 0x1)
#define BCM56218_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_7f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access FP_SLICE_ENABLE.
 *
 */
#define BCM56218_A0_READ_FP_SLICE_ENABLEr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_FP_SLICE_ENABLEr,(r._fp_slice_enable))
#define BCM56218_A0_WRITE_FP_SLICE_ENABLEr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_FP_SLICE_ENABLEr,&(r._fp_slice_enable))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_SLICE_ENABLEr BCM56218_A0_FP_SLICE_ENABLEr
#define FP_SLICE_ENABLEr_SIZE BCM56218_A0_FP_SLICE_ENABLEr_SIZE
typedef BCM56218_A0_FP_SLICE_ENABLEr_t FP_SLICE_ENABLEr_t;
#define FP_SLICE_ENABLEr_CLR BCM56218_A0_FP_SLICE_ENABLEr_CLR
#define FP_SLICE_ENABLEr_SET BCM56218_A0_FP_SLICE_ENABLEr_SET
#define FP_SLICE_ENABLEr_GET BCM56218_A0_FP_SLICE_ENABLEr_GET
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_0f_GET BCM56218_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_0f_GET
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_0f_SET BCM56218_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_0f_SET
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_1f_GET BCM56218_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_1f_GET
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_1f_SET BCM56218_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_1f_SET
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_2f_GET BCM56218_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_2f_GET
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_2f_SET BCM56218_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_2f_SET
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_3f_GET BCM56218_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_3f_GET
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_3f_SET BCM56218_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_3f_SET
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_4f_GET BCM56218_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_4f_GET
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_4f_SET BCM56218_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_4f_SET
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_5f_GET BCM56218_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_5f_GET
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_5f_SET BCM56218_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_5f_SET
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_6f_GET BCM56218_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_6f_GET
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_6f_SET BCM56218_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_6f_SET
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_7f_GET BCM56218_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_7f_GET
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_7f_SET BCM56218_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_7f_SET
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_0f_GET BCM56218_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_0f_GET
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_0f_SET BCM56218_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_0f_SET
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_1f_GET BCM56218_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_1f_GET
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_1f_SET BCM56218_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_1f_SET
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_2f_GET BCM56218_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_2f_GET
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_2f_SET BCM56218_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_2f_SET
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_3f_GET BCM56218_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_3f_GET
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_3f_SET BCM56218_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_3f_SET
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_4f_GET BCM56218_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_4f_GET
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_4f_SET BCM56218_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_4f_SET
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_5f_GET BCM56218_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_5f_GET
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_5f_SET BCM56218_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_5f_SET
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_6f_GET BCM56218_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_6f_GET
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_6f_SET BCM56218_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_6f_SET
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_7f_GET BCM56218_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_7f_GET
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_7f_SET BCM56218_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_7f_SET
#define READ_FP_SLICE_ENABLEr BCM56218_A0_READ_FP_SLICE_ENABLEr
#define WRITE_FP_SLICE_ENABLEr BCM56218_A0_WRITE_FP_SLICE_ENABLEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_FP_SLICE_ENABLEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  FP_SLICE_ENTRY_PORT_SEL
 * BLOCKS:   IPIPE
 * DESC:     ENTRIES ENABLED FOR EACH SOURCE PORT FOR EACH SLICE. The index for this table is created by concatenating {Ingress Port(6bits) and Slice Number(3bits)}.
 * SIZE:     128
 * FIELDS:
 *     ENTRIES_PER_PORT 1 bit for each entry in the TCAM of each slice to indicate if that entry should hit
 *     ENTRIES_PER_PORT_31_0 for entries from 31 to 0.
 *     ENTRIES_PER_PORT_63_32 for entries from 63 to 32.
 *     ENTRIES_PER_PORT_95_64 for entries from 95 to 64.
 *     ENTRIES_PER_PORT_127_96 for entries from 127 to 96.
 *
 ******************************************************************************/
#define BCM56218_A0_FP_SLICE_ENTRY_PORT_SELm 0x0c710000

#define BCM56218_A0_FP_SLICE_ENTRY_PORT_SELm_MIN 0
#define BCM56218_A0_FP_SLICE_ENTRY_PORT_SELm_MAX 431
#define BCM56218_A0_FP_SLICE_ENTRY_PORT_SELm_CMAX(u) 431
#define BCM56218_A0_FP_SLICE_ENTRY_PORT_SELm_SIZE 16

/*
 * This structure should be used to declare and program FP_SLICE_ENTRY_PORT_SEL.
 *
 */
typedef union BCM56218_A0_FP_SLICE_ENTRY_PORT_SELm_s {
	uint32_t v[4];
	uint32_t fp_slice_entry_port_sel[4];
	uint32_t _fp_slice_entry_port_sel;
} BCM56218_A0_FP_SLICE_ENTRY_PORT_SELm_t;

#define BCM56218_A0_FP_SLICE_ENTRY_PORT_SELm_CLR(r) CDK_MEMSET(&((r)._fp_slice_entry_port_sel), 0, sizeof(BCM56218_A0_FP_SLICE_ENTRY_PORT_SELm_t))
#define BCM56218_A0_FP_SLICE_ENTRY_PORT_SELm_SET(r,i,d) (r).fp_slice_entry_port_sel[i] = d
#define BCM56218_A0_FP_SLICE_ENTRY_PORT_SELm_GET(r,i) (r).fp_slice_entry_port_sel[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_FP_SLICE_ENTRY_PORT_SELm_ENTRIES_PER_PORTf_GET(r,a) cdk_field_get((r).fp_slice_entry_port_sel,0,127,a)
#define BCM56218_A0_FP_SLICE_ENTRY_PORT_SELm_ENTRIES_PER_PORTf_SET(r,a) cdk_field_set((r).fp_slice_entry_port_sel,0,127,a)
#define BCM56218_A0_FP_SLICE_ENTRY_PORT_SELm_ENTRIES_PER_PORT_31_0f_GET(r) ((r).fp_slice_entry_port_sel[0])
#define BCM56218_A0_FP_SLICE_ENTRY_PORT_SELm_ENTRIES_PER_PORT_31_0f_SET(r,f) (r).fp_slice_entry_port_sel[0]=((uint32_t)f)
#define BCM56218_A0_FP_SLICE_ENTRY_PORT_SELm_ENTRIES_PER_PORT_63_32f_GET(r) ((r).fp_slice_entry_port_sel[1])
#define BCM56218_A0_FP_SLICE_ENTRY_PORT_SELm_ENTRIES_PER_PORT_63_32f_SET(r,f) (r).fp_slice_entry_port_sel[1]=((uint32_t)f)
#define BCM56218_A0_FP_SLICE_ENTRY_PORT_SELm_ENTRIES_PER_PORT_95_64f_GET(r) ((r).fp_slice_entry_port_sel[2])
#define BCM56218_A0_FP_SLICE_ENTRY_PORT_SELm_ENTRIES_PER_PORT_95_64f_SET(r,f) (r).fp_slice_entry_port_sel[2]=((uint32_t)f)
#define BCM56218_A0_FP_SLICE_ENTRY_PORT_SELm_ENTRIES_PER_PORT_127_96f_GET(r) ((r).fp_slice_entry_port_sel[3])
#define BCM56218_A0_FP_SLICE_ENTRY_PORT_SELm_ENTRIES_PER_PORT_127_96f_SET(r,f) (r).fp_slice_entry_port_sel[3]=((uint32_t)f)

/*
 * These macros can be used to access FP_SLICE_ENTRY_PORT_SEL.
 *
 */
#define BCM56218_A0_READ_FP_SLICE_ENTRY_PORT_SELm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_FP_SLICE_ENTRY_PORT_SELm,i,(m._fp_slice_entry_port_sel),4)
#define BCM56218_A0_WRITE_FP_SLICE_ENTRY_PORT_SELm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_FP_SLICE_ENTRY_PORT_SELm,i,&(m._fp_slice_entry_port_sel),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_SLICE_ENTRY_PORT_SELm BCM56218_A0_FP_SLICE_ENTRY_PORT_SELm
#define FP_SLICE_ENTRY_PORT_SELm_MIN BCM56218_A0_FP_SLICE_ENTRY_PORT_SELm_MIN
#define FP_SLICE_ENTRY_PORT_SELm_MAX BCM56218_A0_FP_SLICE_ENTRY_PORT_SELm_MAX
#define FP_SLICE_ENTRY_PORT_SELm_CMAX(u) BCM56218_A0_FP_SLICE_ENTRY_PORT_SELm_CMAX(u)
#define FP_SLICE_ENTRY_PORT_SELm_SIZE BCM56218_A0_FP_SLICE_ENTRY_PORT_SELm_SIZE
typedef BCM56218_A0_FP_SLICE_ENTRY_PORT_SELm_t FP_SLICE_ENTRY_PORT_SELm_t;
#define FP_SLICE_ENTRY_PORT_SELm_CLR BCM56218_A0_FP_SLICE_ENTRY_PORT_SELm_CLR
#define FP_SLICE_ENTRY_PORT_SELm_SET BCM56218_A0_FP_SLICE_ENTRY_PORT_SELm_SET
#define FP_SLICE_ENTRY_PORT_SELm_GET BCM56218_A0_FP_SLICE_ENTRY_PORT_SELm_GET
#define FP_SLICE_ENTRY_PORT_SELm_ENTRIES_PER_PORTf_GET BCM56218_A0_FP_SLICE_ENTRY_PORT_SELm_ENTRIES_PER_PORTf_GET
#define FP_SLICE_ENTRY_PORT_SELm_ENTRIES_PER_PORTf_SET BCM56218_A0_FP_SLICE_ENTRY_PORT_SELm_ENTRIES_PER_PORTf_SET
#define FP_SLICE_ENTRY_PORT_SELm_ENTRIES_PER_PORT_31_0f_GET BCM56218_A0_FP_SLICE_ENTRY_PORT_SELm_ENTRIES_PER_PORT_31_0f_GET
#define FP_SLICE_ENTRY_PORT_SELm_ENTRIES_PER_PORT_31_0f_SET BCM56218_A0_FP_SLICE_ENTRY_PORT_SELm_ENTRIES_PER_PORT_31_0f_SET
#define FP_SLICE_ENTRY_PORT_SELm_ENTRIES_PER_PORT_63_32f_GET BCM56218_A0_FP_SLICE_ENTRY_PORT_SELm_ENTRIES_PER_PORT_63_32f_GET
#define FP_SLICE_ENTRY_PORT_SELm_ENTRIES_PER_PORT_63_32f_SET BCM56218_A0_FP_SLICE_ENTRY_PORT_SELm_ENTRIES_PER_PORT_63_32f_SET
#define FP_SLICE_ENTRY_PORT_SELm_ENTRIES_PER_PORT_95_64f_GET BCM56218_A0_FP_SLICE_ENTRY_PORT_SELm_ENTRIES_PER_PORT_95_64f_GET
#define FP_SLICE_ENTRY_PORT_SELm_ENTRIES_PER_PORT_95_64f_SET BCM56218_A0_FP_SLICE_ENTRY_PORT_SELm_ENTRIES_PER_PORT_95_64f_SET
#define FP_SLICE_ENTRY_PORT_SELm_ENTRIES_PER_PORT_127_96f_GET BCM56218_A0_FP_SLICE_ENTRY_PORT_SELm_ENTRIES_PER_PORT_127_96f_GET
#define FP_SLICE_ENTRY_PORT_SELm_ENTRIES_PER_PORT_127_96f_SET BCM56218_A0_FP_SLICE_ENTRY_PORT_SELm_ENTRIES_PER_PORT_127_96f_SET
#define READ_FP_SLICE_ENTRY_PORT_SELm BCM56218_A0_READ_FP_SLICE_ENTRY_PORT_SELm
#define WRITE_FP_SLICE_ENTRY_PORT_SELm BCM56218_A0_WRITE_FP_SLICE_ENTRY_PORT_SELm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_FP_SLICE_ENTRY_PORT_SELm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  FP_SLICE_MAP
 * BLOCKS:   IPIPE
 * DESC:     SLICE MAPPING CONTROLS FOR IFP
 * SIZE:     48
 * FIELDS:
 *     VIRTUAL_SLICE_0_PHYSICAL_SLICE_NUMBER MAPS VIRTUAL SLICE 0 TO A PHYSICAL SLICE NUMBER
 *     VIRTUAL_SLICE_1_PHYSICAL_SLICE_NUMBER MAPS VIRTUAL SLICE 1 TO A PHYSICAL SLICE NUMBER
 *     VIRTUAL_SLICE_2_PHYSICAL_SLICE_NUMBER MAPS VIRTUAL SLICE 2 TO A PHYSICAL SLICE NUMBER
 *     VIRTUAL_SLICE_3_PHYSICAL_SLICE_NUMBER MAPS VIRTUAL SLICE 3 TO A PHYSICAL SLICE NUMBER
 *     VIRTUAL_SLICE_4_PHYSICAL_SLICE_NUMBER MAPS VIRTUAL SLICE 4 TO A PHYSICAL SLICE NUMBER
 *     VIRTUAL_SLICE_5_PHYSICAL_SLICE_NUMBER MAPS VIRTUAL SLICE 5 TO A PHYSICAL SLICE NUMBER
 *     VIRTUAL_SLICE_6_PHYSICAL_SLICE_NUMBER MAPS VIRTUAL SLICE 6 TO A PHYSICAL SLICE NUMBER
 *     VIRTUAL_SLICE_7_PHYSICAL_SLICE_NUMBER MAPS VIRTUAL SLICE 7 TO A PHYSICAL SLICE NUMBER
 *     VIRTUAL_SLICE_0_VIRTUAL_SLICE_GROUP MAPS VIRTUAL SLICE 0 TO A VIRTUAL SLICE GROUP
 *     VIRTUAL_SLICE_1_VIRTUAL_SLICE_GROUP MAPS VIRTUAL SLICE 1 TO A VIRTUAL SLICE GROUP
 *     VIRTUAL_SLICE_2_VIRTUAL_SLICE_GROUP MAPS VIRTUAL SLICE 2 TO A VIRTUAL SLICE GROUP
 *     VIRTUAL_SLICE_3_VIRTUAL_SLICE_GROUP MAPS VIRTUAL SLICE 3 TO A VIRTUAL SLICE GROUP
 *     VIRTUAL_SLICE_4_VIRTUAL_SLICE_GROUP MAPS VIRTUAL SLICE 4 TO A VIRTUAL SLICE GROUP
 *     VIRTUAL_SLICE_5_VIRTUAL_SLICE_GROUP MAPS VIRTUAL SLICE 5 TO A VIRTUAL SLICE GROUP
 *     VIRTUAL_SLICE_6_VIRTUAL_SLICE_GROUP MAPS VIRTUAL SLICE 6 TO A VIRTUAL SLICE GROUP
 *     VIRTUAL_SLICE_7_VIRTUAL_SLICE_GROUP MAPS VIRTUAL SLICE 7 TO A VIRTUAL SLICE GROUP
 *
 ******************************************************************************/
#define BCM56218_A0_FP_SLICE_MAPm 0x0c730000

#define BCM56218_A0_FP_SLICE_MAPm_MIN 0
#define BCM56218_A0_FP_SLICE_MAPm_MAX 0
#define BCM56218_A0_FP_SLICE_MAPm_CMAX(u) 0
#define BCM56218_A0_FP_SLICE_MAPm_SIZE 6

/*
 * This structure should be used to declare and program FP_SLICE_MAP.
 *
 */
typedef union BCM56218_A0_FP_SLICE_MAPm_s {
	uint32_t v[2];
	uint32_t fp_slice_map[2];
	uint32_t _fp_slice_map;
} BCM56218_A0_FP_SLICE_MAPm_t;

#define BCM56218_A0_FP_SLICE_MAPm_CLR(r) CDK_MEMSET(&((r)._fp_slice_map), 0, sizeof(BCM56218_A0_FP_SLICE_MAPm_t))
#define BCM56218_A0_FP_SLICE_MAPm_SET(r,i,d) (r).fp_slice_map[i] = d
#define BCM56218_A0_FP_SLICE_MAPm_GET(r,i) (r).fp_slice_map[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_0_PHYSICAL_SLICE_NUMBERf_GET(r) (((r).fp_slice_map[0]) & 0x7)
#define BCM56218_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_0_PHYSICAL_SLICE_NUMBERf_SET(r,f) (r).fp_slice_map[0]=(((r).fp_slice_map[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM56218_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_1_PHYSICAL_SLICE_NUMBERf_GET(r) ((((r).fp_slice_map[0]) >> 3) & 0x7)
#define BCM56218_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_1_PHYSICAL_SLICE_NUMBERf_SET(r,f) (r).fp_slice_map[0]=(((r).fp_slice_map[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM56218_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_2_PHYSICAL_SLICE_NUMBERf_GET(r) ((((r).fp_slice_map[0]) >> 6) & 0x7)
#define BCM56218_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_2_PHYSICAL_SLICE_NUMBERf_SET(r,f) (r).fp_slice_map[0]=(((r).fp_slice_map[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM56218_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_3_PHYSICAL_SLICE_NUMBERf_GET(r) ((((r).fp_slice_map[0]) >> 9) & 0x7)
#define BCM56218_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_3_PHYSICAL_SLICE_NUMBERf_SET(r,f) (r).fp_slice_map[0]=(((r).fp_slice_map[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM56218_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_4_PHYSICAL_SLICE_NUMBERf_GET(r) ((((r).fp_slice_map[0]) >> 12) & 0x7)
#define BCM56218_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_4_PHYSICAL_SLICE_NUMBERf_SET(r,f) (r).fp_slice_map[0]=(((r).fp_slice_map[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM56218_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_5_PHYSICAL_SLICE_NUMBERf_GET(r) ((((r).fp_slice_map[0]) >> 15) & 0x7)
#define BCM56218_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_5_PHYSICAL_SLICE_NUMBERf_SET(r,f) (r).fp_slice_map[0]=(((r).fp_slice_map[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM56218_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_6_PHYSICAL_SLICE_NUMBERf_GET(r) ((((r).fp_slice_map[0]) >> 18) & 0x7)
#define BCM56218_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_6_PHYSICAL_SLICE_NUMBERf_SET(r,f) (r).fp_slice_map[0]=(((r).fp_slice_map[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM56218_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_7_PHYSICAL_SLICE_NUMBERf_GET(r) ((((r).fp_slice_map[0]) >> 21) & 0x7)
#define BCM56218_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_7_PHYSICAL_SLICE_NUMBERf_SET(r,f) (r).fp_slice_map[0]=(((r).fp_slice_map[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM56218_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_0_VIRTUAL_SLICE_GROUPf_GET(r) ((((r).fp_slice_map[0]) >> 24) & 0x7)
#define BCM56218_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_0_VIRTUAL_SLICE_GROUPf_SET(r,f) (r).fp_slice_map[0]=(((r).fp_slice_map[0] & ~((uint32_t)0x7 << 24)) | ((((uint32_t)f) & 0x7) << 24))
#define BCM56218_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_1_VIRTUAL_SLICE_GROUPf_GET(r) ((((r).fp_slice_map[0]) >> 27) & 0x7)
#define BCM56218_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_1_VIRTUAL_SLICE_GROUPf_SET(r,f) (r).fp_slice_map[0]=(((r).fp_slice_map[0] & ~((uint32_t)0x7 << 27)) | ((((uint32_t)f) & 0x7) << 27))
#define BCM56218_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_2_VIRTUAL_SLICE_GROUPf_GET(r) cdk_field32_get((r).fp_slice_map,30,32)
#define BCM56218_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_2_VIRTUAL_SLICE_GROUPf_SET(r,f) cdk_field32_set((r).fp_slice_map,30,32,f)
#define BCM56218_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_3_VIRTUAL_SLICE_GROUPf_GET(r) ((((r).fp_slice_map[1]) >> 1) & 0x7)
#define BCM56218_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_3_VIRTUAL_SLICE_GROUPf_SET(r,f) (r).fp_slice_map[1]=(((r).fp_slice_map[1] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define BCM56218_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_4_VIRTUAL_SLICE_GROUPf_GET(r) ((((r).fp_slice_map[1]) >> 4) & 0x7)
#define BCM56218_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_4_VIRTUAL_SLICE_GROUPf_SET(r,f) (r).fp_slice_map[1]=(((r).fp_slice_map[1] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4))
#define BCM56218_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_5_VIRTUAL_SLICE_GROUPf_GET(r) ((((r).fp_slice_map[1]) >> 7) & 0x7)
#define BCM56218_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_5_VIRTUAL_SLICE_GROUPf_SET(r,f) (r).fp_slice_map[1]=(((r).fp_slice_map[1] & ~((uint32_t)0x7 << 7)) | ((((uint32_t)f) & 0x7) << 7))
#define BCM56218_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_6_VIRTUAL_SLICE_GROUPf_GET(r) ((((r).fp_slice_map[1]) >> 10) & 0x7)
#define BCM56218_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_6_VIRTUAL_SLICE_GROUPf_SET(r,f) (r).fp_slice_map[1]=(((r).fp_slice_map[1] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10))
#define BCM56218_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_7_VIRTUAL_SLICE_GROUPf_GET(r) ((((r).fp_slice_map[1]) >> 13) & 0x7)
#define BCM56218_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_7_VIRTUAL_SLICE_GROUPf_SET(r,f) (r).fp_slice_map[1]=(((r).fp_slice_map[1] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access FP_SLICE_MAP.
 *
 */
#define BCM56218_A0_READ_FP_SLICE_MAPm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_FP_SLICE_MAPm,i,(m._fp_slice_map),2)
#define BCM56218_A0_WRITE_FP_SLICE_MAPm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_FP_SLICE_MAPm,i,&(m._fp_slice_map),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_SLICE_MAPm BCM56218_A0_FP_SLICE_MAPm
#define FP_SLICE_MAPm_MIN BCM56218_A0_FP_SLICE_MAPm_MIN
#define FP_SLICE_MAPm_MAX BCM56218_A0_FP_SLICE_MAPm_MAX
#define FP_SLICE_MAPm_CMAX(u) BCM56218_A0_FP_SLICE_MAPm_CMAX(u)
#define FP_SLICE_MAPm_SIZE BCM56218_A0_FP_SLICE_MAPm_SIZE
typedef BCM56218_A0_FP_SLICE_MAPm_t FP_SLICE_MAPm_t;
#define FP_SLICE_MAPm_CLR BCM56218_A0_FP_SLICE_MAPm_CLR
#define FP_SLICE_MAPm_SET BCM56218_A0_FP_SLICE_MAPm_SET
#define FP_SLICE_MAPm_GET BCM56218_A0_FP_SLICE_MAPm_GET
#define FP_SLICE_MAPm_VIRTUAL_SLICE_0_PHYSICAL_SLICE_NUMBERf_GET BCM56218_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_0_PHYSICAL_SLICE_NUMBERf_GET
#define FP_SLICE_MAPm_VIRTUAL_SLICE_0_PHYSICAL_SLICE_NUMBERf_SET BCM56218_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_0_PHYSICAL_SLICE_NUMBERf_SET
#define FP_SLICE_MAPm_VIRTUAL_SLICE_1_PHYSICAL_SLICE_NUMBERf_GET BCM56218_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_1_PHYSICAL_SLICE_NUMBERf_GET
#define FP_SLICE_MAPm_VIRTUAL_SLICE_1_PHYSICAL_SLICE_NUMBERf_SET BCM56218_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_1_PHYSICAL_SLICE_NUMBERf_SET
#define FP_SLICE_MAPm_VIRTUAL_SLICE_2_PHYSICAL_SLICE_NUMBERf_GET BCM56218_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_2_PHYSICAL_SLICE_NUMBERf_GET
#define FP_SLICE_MAPm_VIRTUAL_SLICE_2_PHYSICAL_SLICE_NUMBERf_SET BCM56218_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_2_PHYSICAL_SLICE_NUMBERf_SET
#define FP_SLICE_MAPm_VIRTUAL_SLICE_3_PHYSICAL_SLICE_NUMBERf_GET BCM56218_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_3_PHYSICAL_SLICE_NUMBERf_GET
#define FP_SLICE_MAPm_VIRTUAL_SLICE_3_PHYSICAL_SLICE_NUMBERf_SET BCM56218_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_3_PHYSICAL_SLICE_NUMBERf_SET
#define FP_SLICE_MAPm_VIRTUAL_SLICE_4_PHYSICAL_SLICE_NUMBERf_GET BCM56218_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_4_PHYSICAL_SLICE_NUMBERf_GET
#define FP_SLICE_MAPm_VIRTUAL_SLICE_4_PHYSICAL_SLICE_NUMBERf_SET BCM56218_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_4_PHYSICAL_SLICE_NUMBERf_SET
#define FP_SLICE_MAPm_VIRTUAL_SLICE_5_PHYSICAL_SLICE_NUMBERf_GET BCM56218_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_5_PHYSICAL_SLICE_NUMBERf_GET
#define FP_SLICE_MAPm_VIRTUAL_SLICE_5_PHYSICAL_SLICE_NUMBERf_SET BCM56218_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_5_PHYSICAL_SLICE_NUMBERf_SET
#define FP_SLICE_MAPm_VIRTUAL_SLICE_6_PHYSICAL_SLICE_NUMBERf_GET BCM56218_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_6_PHYSICAL_SLICE_NUMBERf_GET
#define FP_SLICE_MAPm_VIRTUAL_SLICE_6_PHYSICAL_SLICE_NUMBERf_SET BCM56218_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_6_PHYSICAL_SLICE_NUMBERf_SET
#define FP_SLICE_MAPm_VIRTUAL_SLICE_7_PHYSICAL_SLICE_NUMBERf_GET BCM56218_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_7_PHYSICAL_SLICE_NUMBERf_GET
#define FP_SLICE_MAPm_VIRTUAL_SLICE_7_PHYSICAL_SLICE_NUMBERf_SET BCM56218_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_7_PHYSICAL_SLICE_NUMBERf_SET
#define FP_SLICE_MAPm_VIRTUAL_SLICE_0_VIRTUAL_SLICE_GROUPf_GET BCM56218_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_0_VIRTUAL_SLICE_GROUPf_GET
#define FP_SLICE_MAPm_VIRTUAL_SLICE_0_VIRTUAL_SLICE_GROUPf_SET BCM56218_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_0_VIRTUAL_SLICE_GROUPf_SET
#define FP_SLICE_MAPm_VIRTUAL_SLICE_1_VIRTUAL_SLICE_GROUPf_GET BCM56218_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_1_VIRTUAL_SLICE_GROUPf_GET
#define FP_SLICE_MAPm_VIRTUAL_SLICE_1_VIRTUAL_SLICE_GROUPf_SET BCM56218_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_1_VIRTUAL_SLICE_GROUPf_SET
#define FP_SLICE_MAPm_VIRTUAL_SLICE_2_VIRTUAL_SLICE_GROUPf_GET BCM56218_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_2_VIRTUAL_SLICE_GROUPf_GET
#define FP_SLICE_MAPm_VIRTUAL_SLICE_2_VIRTUAL_SLICE_GROUPf_SET BCM56218_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_2_VIRTUAL_SLICE_GROUPf_SET
#define FP_SLICE_MAPm_VIRTUAL_SLICE_3_VIRTUAL_SLICE_GROUPf_GET BCM56218_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_3_VIRTUAL_SLICE_GROUPf_GET
#define FP_SLICE_MAPm_VIRTUAL_SLICE_3_VIRTUAL_SLICE_GROUPf_SET BCM56218_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_3_VIRTUAL_SLICE_GROUPf_SET
#define FP_SLICE_MAPm_VIRTUAL_SLICE_4_VIRTUAL_SLICE_GROUPf_GET BCM56218_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_4_VIRTUAL_SLICE_GROUPf_GET
#define FP_SLICE_MAPm_VIRTUAL_SLICE_4_VIRTUAL_SLICE_GROUPf_SET BCM56218_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_4_VIRTUAL_SLICE_GROUPf_SET
#define FP_SLICE_MAPm_VIRTUAL_SLICE_5_VIRTUAL_SLICE_GROUPf_GET BCM56218_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_5_VIRTUAL_SLICE_GROUPf_GET
#define FP_SLICE_MAPm_VIRTUAL_SLICE_5_VIRTUAL_SLICE_GROUPf_SET BCM56218_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_5_VIRTUAL_SLICE_GROUPf_SET
#define FP_SLICE_MAPm_VIRTUAL_SLICE_6_VIRTUAL_SLICE_GROUPf_GET BCM56218_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_6_VIRTUAL_SLICE_GROUPf_GET
#define FP_SLICE_MAPm_VIRTUAL_SLICE_6_VIRTUAL_SLICE_GROUPf_SET BCM56218_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_6_VIRTUAL_SLICE_GROUPf_SET
#define FP_SLICE_MAPm_VIRTUAL_SLICE_7_VIRTUAL_SLICE_GROUPf_GET BCM56218_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_7_VIRTUAL_SLICE_GROUPf_GET
#define FP_SLICE_MAPm_VIRTUAL_SLICE_7_VIRTUAL_SLICE_GROUPf_SET BCM56218_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_7_VIRTUAL_SLICE_GROUPf_SET
#define READ_FP_SLICE_MAPm BCM56218_A0_READ_FP_SLICE_MAPm
#define WRITE_FP_SLICE_MAPm BCM56218_A0_WRITE_FP_SLICE_MAPm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_FP_SLICE_MAPm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  FP_TCAM
 * BLOCKS:   IPIPE
 * DESC:     TCAM FOR FP
 * SIZE:     370
 * FIELDS:
 *     VALID            VALID BIT
 *     HIGIG_PKT        Indicates if the packet is a HIGIG (1) or non HIGIG (0) packet
 *     IP_TYPE          IP TYPE
 *     F4               F4
 *     RESERVED_KEY1    RESERVED
 *     KEY              F1,F2,F3 fields 
 *     F3               F3 field
 *     F2               F2 field
 *     F1               F1 field
 *     HIGIG_PKT_MASK   HIGIG PACKET MASK
 *     IP_TYPE_MASK     IP_TYPE MASK
 *     F4_MASK          F4 MASK
 *     RESERVED_MASK    Reserved bit
 *     MASK             F1,F2,F3 field MASK
 *     F3_MASK          F3 field MASK
 *     F2_MASK          F2 field MASK
 *     F1_MASK          F1 field MASK
 *
 ******************************************************************************/
#define BCM56218_A0_FP_TCAMm 0x0c720000

#define BCM56218_A0_FP_TCAMm_MIN 0
#define BCM56218_A0_FP_TCAMm_MAX 1023
#define BCM56218_A0_FP_TCAMm_CMAX(u) cdk_xgs_mem_maxidx(u,BCM56218_A0_FP_TCAMm,1023)
#define BCM56218_A0_FP_TCAMm_SIZE 47

/*
 * This structure should be used to declare and program FP_TCAM.
 *
 */
typedef union BCM56218_A0_FP_TCAMm_s {
	uint32_t v[12];
	uint32_t fp_tcam[12];
	uint32_t _fp_tcam;
} BCM56218_A0_FP_TCAMm_t;

#define BCM56218_A0_FP_TCAMm_CLR(r) CDK_MEMSET(&((r)._fp_tcam), 0, sizeof(BCM56218_A0_FP_TCAMm_t))
#define BCM56218_A0_FP_TCAMm_SET(r,i,d) (r).fp_tcam[i] = d
#define BCM56218_A0_FP_TCAMm_GET(r,i) (r).fp_tcam[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_FP_TCAMm_VALIDf_GET(r) (((r).fp_tcam[0]) & 0x3)
#define BCM56218_A0_FP_TCAMm_VALIDf_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56218_A0_FP_TCAMm_HIGIG_PKTf_GET(r) ((((r).fp_tcam[0]) >> 2) & 0x1)
#define BCM56218_A0_FP_TCAMm_HIGIG_PKTf_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_FP_TCAMm_IP_TYPEf_GET(r) ((((r).fp_tcam[0]) >> 3) & 0x3)
#define BCM56218_A0_FP_TCAMm_IP_TYPEf_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32_t)0x3 << 3)) | ((((uint32_t)f) & 0x3) << 3))
#define BCM56218_A0_FP_TCAMm_F4f_GET(r) ((((r).fp_tcam[0]) >> 5) & 0xf)
#define BCM56218_A0_FP_TCAMm_F4f_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32_t)0xf << 5)) | ((((uint32_t)f) & 0xf) << 5))
#define BCM56218_A0_FP_TCAMm_RESERVED_KEY1f_GET(r) ((((r).fp_tcam[0]) >> 9) & 0x1)
#define BCM56218_A0_FP_TCAMm_RESERVED_KEY1f_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56218_A0_FP_TCAMm_KEYf_GET(r,a) cdk_field_get((r).fp_tcam,10,185,a)
#define BCM56218_A0_FP_TCAMm_KEYf_SET(r,a) cdk_field_set((r).fp_tcam,10,185,a)
#define BCM56218_A0_FP_TCAMm_F3f_GET(r) ((((r).fp_tcam[0]) >> 10) & 0xffff)
#define BCM56218_A0_FP_TCAMm_F3f_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32_t)0xffff << 10)) | ((((uint32_t)f) & 0xffff) << 10))
#define BCM56218_A0_FP_TCAMm_F2f_GET(r,a) cdk_field_get((r).fp_tcam,26,153,a)
#define BCM56218_A0_FP_TCAMm_F2f_SET(r,a) cdk_field_set((r).fp_tcam,26,153,a)
#define BCM56218_A0_FP_TCAMm_F1f_GET(r) cdk_field32_get((r).fp_tcam,154,185)
#define BCM56218_A0_FP_TCAMm_F1f_SET(r,f) cdk_field32_set((r).fp_tcam,154,185,f)
#define BCM56218_A0_FP_TCAMm_HIGIG_PKT_MASKf_GET(r) ((((r).fp_tcam[5]) >> 26) & 0x1)
#define BCM56218_A0_FP_TCAMm_HIGIG_PKT_MASKf_SET(r,f) (r).fp_tcam[5]=(((r).fp_tcam[5] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM56218_A0_FP_TCAMm_IP_TYPE_MASKf_GET(r) ((((r).fp_tcam[5]) >> 27) & 0x3)
#define BCM56218_A0_FP_TCAMm_IP_TYPE_MASKf_SET(r,f) (r).fp_tcam[5]=(((r).fp_tcam[5] & ~((uint32_t)0x3 << 27)) | ((((uint32_t)f) & 0x3) << 27))
#define BCM56218_A0_FP_TCAMm_F4_MASKf_GET(r) cdk_field32_get((r).fp_tcam,189,192)
#define BCM56218_A0_FP_TCAMm_F4_MASKf_SET(r,f) cdk_field32_set((r).fp_tcam,189,192,f)
#define BCM56218_A0_FP_TCAMm_RESERVED_MASKf_GET(r) ((((r).fp_tcam[6]) >> 1) & 0x1)
#define BCM56218_A0_FP_TCAMm_RESERVED_MASKf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_FP_TCAMm_MASKf_GET(r,a) cdk_field_get((r).fp_tcam,194,369,a)
#define BCM56218_A0_FP_TCAMm_MASKf_SET(r,a) cdk_field_set((r).fp_tcam,194,369,a)
#define BCM56218_A0_FP_TCAMm_F3_MASKf_GET(r) ((((r).fp_tcam[6]) >> 2) & 0xffff)
#define BCM56218_A0_FP_TCAMm_F3_MASKf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32_t)0xffff << 2)) | ((((uint32_t)f) & 0xffff) << 2))
#define BCM56218_A0_FP_TCAMm_F2_MASKf_GET(r,a) cdk_field_get((r).fp_tcam,210,337,a)
#define BCM56218_A0_FP_TCAMm_F2_MASKf_SET(r,a) cdk_field_set((r).fp_tcam,210,337,a)
#define BCM56218_A0_FP_TCAMm_F1_MASKf_GET(r) cdk_field32_get((r).fp_tcam,338,369)
#define BCM56218_A0_FP_TCAMm_F1_MASKf_SET(r,f) cdk_field32_set((r).fp_tcam,338,369,f)

/*
 * These macros can be used to access FP_TCAM.
 *
 */
#define BCM56218_A0_READ_FP_TCAMm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_FP_TCAMm,i,(m._fp_tcam),12)
#define BCM56218_A0_WRITE_FP_TCAMm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_FP_TCAMm,i,&(m._fp_tcam),12)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_TCAMm BCM56218_A0_FP_TCAMm
#define FP_TCAMm_MIN BCM56218_A0_FP_TCAMm_MIN
#define FP_TCAMm_MAX BCM56218_A0_FP_TCAMm_MAX
#define FP_TCAMm_CMAX(u) BCM56218_A0_FP_TCAMm_CMAX(u)
#define FP_TCAMm_SIZE BCM56218_A0_FP_TCAMm_SIZE
typedef BCM56218_A0_FP_TCAMm_t FP_TCAMm_t;
#define FP_TCAMm_CLR BCM56218_A0_FP_TCAMm_CLR
#define FP_TCAMm_SET BCM56218_A0_FP_TCAMm_SET
#define FP_TCAMm_GET BCM56218_A0_FP_TCAMm_GET
#define FP_TCAMm_VALIDf_GET BCM56218_A0_FP_TCAMm_VALIDf_GET
#define FP_TCAMm_VALIDf_SET BCM56218_A0_FP_TCAMm_VALIDf_SET
#define FP_TCAMm_HIGIG_PKTf_GET BCM56218_A0_FP_TCAMm_HIGIG_PKTf_GET
#define FP_TCAMm_HIGIG_PKTf_SET BCM56218_A0_FP_TCAMm_HIGIG_PKTf_SET
#define FP_TCAMm_IP_TYPEf_GET BCM56218_A0_FP_TCAMm_IP_TYPEf_GET
#define FP_TCAMm_IP_TYPEf_SET BCM56218_A0_FP_TCAMm_IP_TYPEf_SET
#define FP_TCAMm_F4f_GET BCM56218_A0_FP_TCAMm_F4f_GET
#define FP_TCAMm_F4f_SET BCM56218_A0_FP_TCAMm_F4f_SET
#define FP_TCAMm_RESERVED_KEY1f_GET BCM56218_A0_FP_TCAMm_RESERVED_KEY1f_GET
#define FP_TCAMm_RESERVED_KEY1f_SET BCM56218_A0_FP_TCAMm_RESERVED_KEY1f_SET
#define FP_TCAMm_KEYf_GET BCM56218_A0_FP_TCAMm_KEYf_GET
#define FP_TCAMm_KEYf_SET BCM56218_A0_FP_TCAMm_KEYf_SET
#define FP_TCAMm_F3f_GET BCM56218_A0_FP_TCAMm_F3f_GET
#define FP_TCAMm_F3f_SET BCM56218_A0_FP_TCAMm_F3f_SET
#define FP_TCAMm_F2f_GET BCM56218_A0_FP_TCAMm_F2f_GET
#define FP_TCAMm_F2f_SET BCM56218_A0_FP_TCAMm_F2f_SET
#define FP_TCAMm_F1f_GET BCM56218_A0_FP_TCAMm_F1f_GET
#define FP_TCAMm_F1f_SET BCM56218_A0_FP_TCAMm_F1f_SET
#define FP_TCAMm_HIGIG_PKT_MASKf_GET BCM56218_A0_FP_TCAMm_HIGIG_PKT_MASKf_GET
#define FP_TCAMm_HIGIG_PKT_MASKf_SET BCM56218_A0_FP_TCAMm_HIGIG_PKT_MASKf_SET
#define FP_TCAMm_IP_TYPE_MASKf_GET BCM56218_A0_FP_TCAMm_IP_TYPE_MASKf_GET
#define FP_TCAMm_IP_TYPE_MASKf_SET BCM56218_A0_FP_TCAMm_IP_TYPE_MASKf_SET
#define FP_TCAMm_F4_MASKf_GET BCM56218_A0_FP_TCAMm_F4_MASKf_GET
#define FP_TCAMm_F4_MASKf_SET BCM56218_A0_FP_TCAMm_F4_MASKf_SET
#define FP_TCAMm_RESERVED_MASKf_GET BCM56218_A0_FP_TCAMm_RESERVED_MASKf_GET
#define FP_TCAMm_RESERVED_MASKf_SET BCM56218_A0_FP_TCAMm_RESERVED_MASKf_SET
#define FP_TCAMm_MASKf_GET BCM56218_A0_FP_TCAMm_MASKf_GET
#define FP_TCAMm_MASKf_SET BCM56218_A0_FP_TCAMm_MASKf_SET
#define FP_TCAMm_F3_MASKf_GET BCM56218_A0_FP_TCAMm_F3_MASKf_GET
#define FP_TCAMm_F3_MASKf_SET BCM56218_A0_FP_TCAMm_F3_MASKf_SET
#define FP_TCAMm_F2_MASKf_GET BCM56218_A0_FP_TCAMm_F2_MASKf_GET
#define FP_TCAMm_F2_MASKf_SET BCM56218_A0_FP_TCAMm_F2_MASKf_SET
#define FP_TCAMm_F1_MASKf_GET BCM56218_A0_FP_TCAMm_F1_MASKf_GET
#define FP_TCAMm_F1_MASKf_SET BCM56218_A0_FP_TCAMm_F1_MASKf_SET
#define READ_FP_TCAMm BCM56218_A0_READ_FP_TCAMm
#define WRITE_FP_TCAMm BCM56218_A0_WRITE_FP_TCAMm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_FP_TCAMm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  FP_UDF_OFFSET
 * BLOCKS:   IPIPE
 * DESC:     FP UDF offset table
 * SIZE:     48
 * FIELDS:
 *     UDF1_OFFSET0     Offset value for UDF1.0
 *     UDF1_ADD_IPV4_OPTIONS0 Control bit to enable adding the IPv4 header option length
 *     UDF1_OFFSET1     Offset value for UDF1.1
 *     UDF1_ADD_IPV4_OPTIONS1 Control bit to enable adding the IPv4 header option length
 *     UDF1_OFFSET2     Offset value for UDF1.2
 *     UDF1_ADD_IPV4_OPTIONS2 Control bit to enable adding the IPv4 header option length
 *     UDF1_OFFSET3     Offset value for UDF1.3
 *     UDF1_ADD_IPV4_OPTIONS3 Control bit to enable adding the IPv4 header option length
 *     UDF2_OFFSET0     Offset value for UDF2.0
 *     UDF2_ADD_IPV4_OPTIONS0 Control bit to enable adding the IPv4 header option length
 *     UDF2_OFFSET1     Offset value for UDF2.1
 *     UDF2_ADD_IPV4_OPTIONS1 Control bit to enable adding the IPv4 header option length
 *     UDF2_OFFSET2     Offset value for UDF2.2
 *     UDF2_ADD_IPV4_OPTIONS2 Control bit to enable adding the IPv4 header option length
 *     UDF2_OFFSET3     Offset value for UDF2.3
 *     UDF2_ADD_IPV4_OPTIONS3 Control bit to enable adding the IPv4 header option length
 *
 ******************************************************************************/
#define BCM56218_A0_FP_UDF_OFFSETm 0x02720000

#define BCM56218_A0_FP_UDF_OFFSETm_MIN 0
#define BCM56218_A0_FP_UDF_OFFSETm_MAX 95
#define BCM56218_A0_FP_UDF_OFFSETm_CMAX(u) 95
#define BCM56218_A0_FP_UDF_OFFSETm_SIZE 6

/*
 * This structure should be used to declare and program FP_UDF_OFFSET.
 *
 */
typedef union BCM56218_A0_FP_UDF_OFFSETm_s {
	uint32_t v[2];
	uint32_t fp_udf_offset[2];
	uint32_t _fp_udf_offset;
} BCM56218_A0_FP_UDF_OFFSETm_t;

#define BCM56218_A0_FP_UDF_OFFSETm_CLR(r) CDK_MEMSET(&((r)._fp_udf_offset), 0, sizeof(BCM56218_A0_FP_UDF_OFFSETm_t))
#define BCM56218_A0_FP_UDF_OFFSETm_SET(r,i,d) (r).fp_udf_offset[i] = d
#define BCM56218_A0_FP_UDF_OFFSETm_GET(r,i) (r).fp_udf_offset[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_FP_UDF_OFFSETm_UDF1_OFFSET0f_GET(r) (((r).fp_udf_offset[0]) & 0x1f)
#define BCM56218_A0_FP_UDF_OFFSETm_UDF1_OFFSET0f_SET(r,f) (r).fp_udf_offset[0]=(((r).fp_udf_offset[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56218_A0_FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS0f_GET(r) ((((r).fp_udf_offset[0]) >> 5) & 0x1)
#define BCM56218_A0_FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS0f_SET(r,f) (r).fp_udf_offset[0]=(((r).fp_udf_offset[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56218_A0_FP_UDF_OFFSETm_UDF1_OFFSET1f_GET(r) ((((r).fp_udf_offset[0]) >> 6) & 0x1f)
#define BCM56218_A0_FP_UDF_OFFSETm_UDF1_OFFSET1f_SET(r,f) (r).fp_udf_offset[0]=(((r).fp_udf_offset[0] & ~((uint32_t)0x1f << 6)) | ((((uint32_t)f) & 0x1f) << 6))
#define BCM56218_A0_FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS1f_GET(r) ((((r).fp_udf_offset[0]) >> 11) & 0x1)
#define BCM56218_A0_FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS1f_SET(r,f) (r).fp_udf_offset[0]=(((r).fp_udf_offset[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56218_A0_FP_UDF_OFFSETm_UDF1_OFFSET2f_GET(r) ((((r).fp_udf_offset[0]) >> 12) & 0x1f)
#define BCM56218_A0_FP_UDF_OFFSETm_UDF1_OFFSET2f_SET(r,f) (r).fp_udf_offset[0]=(((r).fp_udf_offset[0] & ~((uint32_t)0x1f << 12)) | ((((uint32_t)f) & 0x1f) << 12))
#define BCM56218_A0_FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS2f_GET(r) ((((r).fp_udf_offset[0]) >> 17) & 0x1)
#define BCM56218_A0_FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS2f_SET(r,f) (r).fp_udf_offset[0]=(((r).fp_udf_offset[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_FP_UDF_OFFSETm_UDF1_OFFSET3f_GET(r) ((((r).fp_udf_offset[0]) >> 18) & 0x1f)
#define BCM56218_A0_FP_UDF_OFFSETm_UDF1_OFFSET3f_SET(r,f) (r).fp_udf_offset[0]=(((r).fp_udf_offset[0] & ~((uint32_t)0x1f << 18)) | ((((uint32_t)f) & 0x1f) << 18))
#define BCM56218_A0_FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS3f_GET(r) ((((r).fp_udf_offset[0]) >> 23) & 0x1)
#define BCM56218_A0_FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS3f_SET(r,f) (r).fp_udf_offset[0]=(((r).fp_udf_offset[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM56218_A0_FP_UDF_OFFSETm_UDF2_OFFSET0f_GET(r) ((((r).fp_udf_offset[0]) >> 24) & 0x1f)
#define BCM56218_A0_FP_UDF_OFFSETm_UDF2_OFFSET0f_SET(r,f) (r).fp_udf_offset[0]=(((r).fp_udf_offset[0] & ~((uint32_t)0x1f << 24)) | ((((uint32_t)f) & 0x1f) << 24))
#define BCM56218_A0_FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS0f_GET(r) ((((r).fp_udf_offset[0]) >> 29) & 0x1)
#define BCM56218_A0_FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS0f_SET(r,f) (r).fp_udf_offset[0]=(((r).fp_udf_offset[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM56218_A0_FP_UDF_OFFSETm_UDF2_OFFSET1f_GET(r) cdk_field32_get((r).fp_udf_offset,30,34)
#define BCM56218_A0_FP_UDF_OFFSETm_UDF2_OFFSET1f_SET(r,f) cdk_field32_set((r).fp_udf_offset,30,34,f)
#define BCM56218_A0_FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS1f_GET(r) ((((r).fp_udf_offset[1]) >> 3) & 0x1)
#define BCM56218_A0_FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS1f_SET(r,f) (r).fp_udf_offset[1]=(((r).fp_udf_offset[1] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56218_A0_FP_UDF_OFFSETm_UDF2_OFFSET2f_GET(r) ((((r).fp_udf_offset[1]) >> 4) & 0x1f)
#define BCM56218_A0_FP_UDF_OFFSETm_UDF2_OFFSET2f_SET(r,f) (r).fp_udf_offset[1]=(((r).fp_udf_offset[1] & ~((uint32_t)0x1f << 4)) | ((((uint32_t)f) & 0x1f) << 4))
#define BCM56218_A0_FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS2f_GET(r) ((((r).fp_udf_offset[1]) >> 9) & 0x1)
#define BCM56218_A0_FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS2f_SET(r,f) (r).fp_udf_offset[1]=(((r).fp_udf_offset[1] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56218_A0_FP_UDF_OFFSETm_UDF2_OFFSET3f_GET(r) ((((r).fp_udf_offset[1]) >> 10) & 0x1f)
#define BCM56218_A0_FP_UDF_OFFSETm_UDF2_OFFSET3f_SET(r,f) (r).fp_udf_offset[1]=(((r).fp_udf_offset[1] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10))
#define BCM56218_A0_FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS3f_GET(r) ((((r).fp_udf_offset[1]) >> 15) & 0x1)
#define BCM56218_A0_FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS3f_SET(r,f) (r).fp_udf_offset[1]=(((r).fp_udf_offset[1] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access FP_UDF_OFFSET.
 *
 */
#define BCM56218_A0_READ_FP_UDF_OFFSETm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_FP_UDF_OFFSETm,i,(m._fp_udf_offset),2)
#define BCM56218_A0_WRITE_FP_UDF_OFFSETm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_FP_UDF_OFFSETm,i,&(m._fp_udf_offset),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_UDF_OFFSETm BCM56218_A0_FP_UDF_OFFSETm
#define FP_UDF_OFFSETm_MIN BCM56218_A0_FP_UDF_OFFSETm_MIN
#define FP_UDF_OFFSETm_MAX BCM56218_A0_FP_UDF_OFFSETm_MAX
#define FP_UDF_OFFSETm_CMAX(u) BCM56218_A0_FP_UDF_OFFSETm_CMAX(u)
#define FP_UDF_OFFSETm_SIZE BCM56218_A0_FP_UDF_OFFSETm_SIZE
typedef BCM56218_A0_FP_UDF_OFFSETm_t FP_UDF_OFFSETm_t;
#define FP_UDF_OFFSETm_CLR BCM56218_A0_FP_UDF_OFFSETm_CLR
#define FP_UDF_OFFSETm_SET BCM56218_A0_FP_UDF_OFFSETm_SET
#define FP_UDF_OFFSETm_GET BCM56218_A0_FP_UDF_OFFSETm_GET
#define FP_UDF_OFFSETm_UDF1_OFFSET0f_GET BCM56218_A0_FP_UDF_OFFSETm_UDF1_OFFSET0f_GET
#define FP_UDF_OFFSETm_UDF1_OFFSET0f_SET BCM56218_A0_FP_UDF_OFFSETm_UDF1_OFFSET0f_SET
#define FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS0f_GET BCM56218_A0_FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS0f_GET
#define FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS0f_SET BCM56218_A0_FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS0f_SET
#define FP_UDF_OFFSETm_UDF1_OFFSET1f_GET BCM56218_A0_FP_UDF_OFFSETm_UDF1_OFFSET1f_GET
#define FP_UDF_OFFSETm_UDF1_OFFSET1f_SET BCM56218_A0_FP_UDF_OFFSETm_UDF1_OFFSET1f_SET
#define FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS1f_GET BCM56218_A0_FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS1f_GET
#define FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS1f_SET BCM56218_A0_FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS1f_SET
#define FP_UDF_OFFSETm_UDF1_OFFSET2f_GET BCM56218_A0_FP_UDF_OFFSETm_UDF1_OFFSET2f_GET
#define FP_UDF_OFFSETm_UDF1_OFFSET2f_SET BCM56218_A0_FP_UDF_OFFSETm_UDF1_OFFSET2f_SET
#define FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS2f_GET BCM56218_A0_FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS2f_GET
#define FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS2f_SET BCM56218_A0_FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS2f_SET
#define FP_UDF_OFFSETm_UDF1_OFFSET3f_GET BCM56218_A0_FP_UDF_OFFSETm_UDF1_OFFSET3f_GET
#define FP_UDF_OFFSETm_UDF1_OFFSET3f_SET BCM56218_A0_FP_UDF_OFFSETm_UDF1_OFFSET3f_SET
#define FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS3f_GET BCM56218_A0_FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS3f_GET
#define FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS3f_SET BCM56218_A0_FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS3f_SET
#define FP_UDF_OFFSETm_UDF2_OFFSET0f_GET BCM56218_A0_FP_UDF_OFFSETm_UDF2_OFFSET0f_GET
#define FP_UDF_OFFSETm_UDF2_OFFSET0f_SET BCM56218_A0_FP_UDF_OFFSETm_UDF2_OFFSET0f_SET
#define FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS0f_GET BCM56218_A0_FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS0f_GET
#define FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS0f_SET BCM56218_A0_FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS0f_SET
#define FP_UDF_OFFSETm_UDF2_OFFSET1f_GET BCM56218_A0_FP_UDF_OFFSETm_UDF2_OFFSET1f_GET
#define FP_UDF_OFFSETm_UDF2_OFFSET1f_SET BCM56218_A0_FP_UDF_OFFSETm_UDF2_OFFSET1f_SET
#define FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS1f_GET BCM56218_A0_FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS1f_GET
#define FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS1f_SET BCM56218_A0_FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS1f_SET
#define FP_UDF_OFFSETm_UDF2_OFFSET2f_GET BCM56218_A0_FP_UDF_OFFSETm_UDF2_OFFSET2f_GET
#define FP_UDF_OFFSETm_UDF2_OFFSET2f_SET BCM56218_A0_FP_UDF_OFFSETm_UDF2_OFFSET2f_SET
#define FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS2f_GET BCM56218_A0_FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS2f_GET
#define FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS2f_SET BCM56218_A0_FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS2f_SET
#define FP_UDF_OFFSETm_UDF2_OFFSET3f_GET BCM56218_A0_FP_UDF_OFFSETm_UDF2_OFFSET3f_GET
#define FP_UDF_OFFSETm_UDF2_OFFSET3f_SET BCM56218_A0_FP_UDF_OFFSETm_UDF2_OFFSET3f_SET
#define FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS3f_GET BCM56218_A0_FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS3f_GET
#define FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS3f_SET BCM56218_A0_FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS3f_SET
#define READ_FP_UDF_OFFSETm BCM56218_A0_READ_FP_UDF_OFFSETm
#define WRITE_FP_UDF_OFFSETm BCM56218_A0_WRITE_FP_UDF_OFFSETm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_FP_UDF_OFFSETm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GE0_GBODE_CELL_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell count register for GE0 
 * SIZE:     32
 * FIELDS:
 *     CELL_CNT         Number of cell counts in GBODE tx fifo.
 *
 ******************************************************************************/
#define BCM56218_A0_GE0_GBODE_CELL_CNTr 0x00080010

#define BCM56218_A0_GE0_GBODE_CELL_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE0_GBODE_CELL_CNT.
 *
 */
typedef union BCM56218_A0_GE0_GBODE_CELL_CNTr_s {
	uint32_t v[1];
	uint32_t ge0_gbode_cell_cnt[1];
	uint32_t _ge0_gbode_cell_cnt;
} BCM56218_A0_GE0_GBODE_CELL_CNTr_t;

#define BCM56218_A0_GE0_GBODE_CELL_CNTr_CLR(r) (r).ge0_gbode_cell_cnt[0] = 0
#define BCM56218_A0_GE0_GBODE_CELL_CNTr_SET(r,d) (r).ge0_gbode_cell_cnt[0] = d
#define BCM56218_A0_GE0_GBODE_CELL_CNTr_GET(r) (r).ge0_gbode_cell_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_GE0_GBODE_CELL_CNTr_CELL_CNTf_GET(r) (((r).ge0_gbode_cell_cnt[0]) & 0xf)
#define BCM56218_A0_GE0_GBODE_CELL_CNTr_CELL_CNTf_SET(r,f) (r).ge0_gbode_cell_cnt[0]=(((r).ge0_gbode_cell_cnt[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access GE0_GBODE_CELL_CNT.
 *
 */
#define BCM56218_A0_READ_GE0_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE0_GBODE_CELL_CNTr,(r._ge0_gbode_cell_cnt))
#define BCM56218_A0_WRITE_GE0_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE0_GBODE_CELL_CNTr,&(r._ge0_gbode_cell_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE0_GBODE_CELL_CNTr BCM56218_A0_GE0_GBODE_CELL_CNTr
#define GE0_GBODE_CELL_CNTr_SIZE BCM56218_A0_GE0_GBODE_CELL_CNTr_SIZE
typedef BCM56218_A0_GE0_GBODE_CELL_CNTr_t GE0_GBODE_CELL_CNTr_t;
#define GE0_GBODE_CELL_CNTr_CLR BCM56218_A0_GE0_GBODE_CELL_CNTr_CLR
#define GE0_GBODE_CELL_CNTr_SET BCM56218_A0_GE0_GBODE_CELL_CNTr_SET
#define GE0_GBODE_CELL_CNTr_GET BCM56218_A0_GE0_GBODE_CELL_CNTr_GET
#define GE0_GBODE_CELL_CNTr_CELL_CNTf_GET BCM56218_A0_GE0_GBODE_CELL_CNTr_CELL_CNTf_GET
#define GE0_GBODE_CELL_CNTr_CELL_CNTf_SET BCM56218_A0_GE0_GBODE_CELL_CNTr_CELL_CNTf_SET
#define READ_GE0_GBODE_CELL_CNTr BCM56218_A0_READ_GE0_GBODE_CELL_CNTr
#define WRITE_GE0_GBODE_CELL_CNTr BCM56218_A0_WRITE_GE0_GBODE_CELL_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GE0_GBODE_CELL_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GE0_GBODE_CELL_REQ_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell request count register for GE0 
 * SIZE:     32
 * FIELDS:
 *     REQ_CNT          Number of cell request made to Egress Pipeline, MAX is 4 in FB mode. In Felix mode, MAX is 8.
 *
 ******************************************************************************/
#define BCM56218_A0_GE0_GBODE_CELL_REQ_CNTr 0x0008001c

#define BCM56218_A0_GE0_GBODE_CELL_REQ_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE0_GBODE_CELL_REQ_CNT.
 *
 */
typedef union BCM56218_A0_GE0_GBODE_CELL_REQ_CNTr_s {
	uint32_t v[1];
	uint32_t ge0_gbode_cell_req_cnt[1];
	uint32_t _ge0_gbode_cell_req_cnt;
} BCM56218_A0_GE0_GBODE_CELL_REQ_CNTr_t;

#define BCM56218_A0_GE0_GBODE_CELL_REQ_CNTr_CLR(r) (r).ge0_gbode_cell_req_cnt[0] = 0
#define BCM56218_A0_GE0_GBODE_CELL_REQ_CNTr_SET(r,d) (r).ge0_gbode_cell_req_cnt[0] = d
#define BCM56218_A0_GE0_GBODE_CELL_REQ_CNTr_GET(r) (r).ge0_gbode_cell_req_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_GE0_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET(r) (((r).ge0_gbode_cell_req_cnt[0]) & 0xf)
#define BCM56218_A0_GE0_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET(r,f) (r).ge0_gbode_cell_req_cnt[0]=(((r).ge0_gbode_cell_req_cnt[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access GE0_GBODE_CELL_REQ_CNT.
 *
 */
#define BCM56218_A0_READ_GE0_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE0_GBODE_CELL_REQ_CNTr,(r._ge0_gbode_cell_req_cnt))
#define BCM56218_A0_WRITE_GE0_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE0_GBODE_CELL_REQ_CNTr,&(r._ge0_gbode_cell_req_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE0_GBODE_CELL_REQ_CNTr BCM56218_A0_GE0_GBODE_CELL_REQ_CNTr
#define GE0_GBODE_CELL_REQ_CNTr_SIZE BCM56218_A0_GE0_GBODE_CELL_REQ_CNTr_SIZE
typedef BCM56218_A0_GE0_GBODE_CELL_REQ_CNTr_t GE0_GBODE_CELL_REQ_CNTr_t;
#define GE0_GBODE_CELL_REQ_CNTr_CLR BCM56218_A0_GE0_GBODE_CELL_REQ_CNTr_CLR
#define GE0_GBODE_CELL_REQ_CNTr_SET BCM56218_A0_GE0_GBODE_CELL_REQ_CNTr_SET
#define GE0_GBODE_CELL_REQ_CNTr_GET BCM56218_A0_GE0_GBODE_CELL_REQ_CNTr_GET
#define GE0_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET BCM56218_A0_GE0_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET
#define GE0_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET BCM56218_A0_GE0_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET
#define READ_GE0_GBODE_CELL_REQ_CNTr BCM56218_A0_READ_GE0_GBODE_CELL_REQ_CNTr
#define WRITE_GE0_GBODE_CELL_REQ_CNTr BCM56218_A0_WRITE_GE0_GBODE_CELL_REQ_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GE0_GBODE_CELL_REQ_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GE0_GBOD_OVRFLW
 * BLOCKS:   GPORT0
 * DESC:     GBOD RX fifo overflow for GE0 
 * SIZE:     32
 * FIELDS:
 *     OVRFLW           GBOD RX fifo overflow flag.
 *
 ******************************************************************************/
#define BCM56218_A0_GE0_GBOD_OVRFLWr 0x00080004

#define BCM56218_A0_GE0_GBOD_OVRFLWr_SIZE 4

/*
 * This structure should be used to declare and program GE0_GBOD_OVRFLW.
 *
 */
typedef union BCM56218_A0_GE0_GBOD_OVRFLWr_s {
	uint32_t v[1];
	uint32_t ge0_gbod_ovrflw[1];
	uint32_t _ge0_gbod_ovrflw;
} BCM56218_A0_GE0_GBOD_OVRFLWr_t;

#define BCM56218_A0_GE0_GBOD_OVRFLWr_CLR(r) (r).ge0_gbod_ovrflw[0] = 0
#define BCM56218_A0_GE0_GBOD_OVRFLWr_SET(r,d) (r).ge0_gbod_ovrflw[0] = d
#define BCM56218_A0_GE0_GBOD_OVRFLWr_GET(r) (r).ge0_gbod_ovrflw[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_GE0_GBOD_OVRFLWr_OVRFLWf_GET(r) (((r).ge0_gbod_ovrflw[0]) & 0x1)
#define BCM56218_A0_GE0_GBOD_OVRFLWr_OVRFLWf_SET(r,f) (r).ge0_gbod_ovrflw[0]=(((r).ge0_gbod_ovrflw[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access GE0_GBOD_OVRFLW.
 *
 */
#define BCM56218_A0_READ_GE0_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE0_GBOD_OVRFLWr,(r._ge0_gbod_ovrflw))
#define BCM56218_A0_WRITE_GE0_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE0_GBOD_OVRFLWr,&(r._ge0_gbod_ovrflw))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE0_GBOD_OVRFLWr BCM56218_A0_GE0_GBOD_OVRFLWr
#define GE0_GBOD_OVRFLWr_SIZE BCM56218_A0_GE0_GBOD_OVRFLWr_SIZE
typedef BCM56218_A0_GE0_GBOD_OVRFLWr_t GE0_GBOD_OVRFLWr_t;
#define GE0_GBOD_OVRFLWr_CLR BCM56218_A0_GE0_GBOD_OVRFLWr_CLR
#define GE0_GBOD_OVRFLWr_SET BCM56218_A0_GE0_GBOD_OVRFLWr_SET
#define GE0_GBOD_OVRFLWr_GET BCM56218_A0_GE0_GBOD_OVRFLWr_GET
#define GE0_GBOD_OVRFLWr_OVRFLWf_GET BCM56218_A0_GE0_GBOD_OVRFLWr_OVRFLWf_GET
#define GE0_GBOD_OVRFLWr_OVRFLWf_SET BCM56218_A0_GE0_GBOD_OVRFLWr_OVRFLWf_SET
#define READ_GE0_GBOD_OVRFLWr BCM56218_A0_READ_GE0_GBOD_OVRFLWr
#define WRITE_GE0_GBOD_OVRFLWr BCM56218_A0_WRITE_GE0_GBOD_OVRFLWr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GE0_GBOD_OVRFLWr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GE10_GBODE_CELL_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell count register for GE10 
 * SIZE:     32
 * FIELDS:
 *     CELL_CNT         Number of cell counts in GBODE tx fifo.
 *
 ******************************************************************************/
#define BCM56218_A0_GE10_GBODE_CELL_CNTr 0x0008001a

#define BCM56218_A0_GE10_GBODE_CELL_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE10_GBODE_CELL_CNT.
 *
 */
typedef union BCM56218_A0_GE10_GBODE_CELL_CNTr_s {
	uint32_t v[1];
	uint32_t ge10_gbode_cell_cnt[1];
	uint32_t _ge10_gbode_cell_cnt;
} BCM56218_A0_GE10_GBODE_CELL_CNTr_t;

#define BCM56218_A0_GE10_GBODE_CELL_CNTr_CLR(r) (r).ge10_gbode_cell_cnt[0] = 0
#define BCM56218_A0_GE10_GBODE_CELL_CNTr_SET(r,d) (r).ge10_gbode_cell_cnt[0] = d
#define BCM56218_A0_GE10_GBODE_CELL_CNTr_GET(r) (r).ge10_gbode_cell_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_GE10_GBODE_CELL_CNTr_CELL_CNTf_GET(r) (((r).ge10_gbode_cell_cnt[0]) & 0xf)
#define BCM56218_A0_GE10_GBODE_CELL_CNTr_CELL_CNTf_SET(r,f) (r).ge10_gbode_cell_cnt[0]=(((r).ge10_gbode_cell_cnt[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access GE10_GBODE_CELL_CNT.
 *
 */
#define BCM56218_A0_READ_GE10_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE10_GBODE_CELL_CNTr,(r._ge10_gbode_cell_cnt))
#define BCM56218_A0_WRITE_GE10_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE10_GBODE_CELL_CNTr,&(r._ge10_gbode_cell_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE10_GBODE_CELL_CNTr BCM56218_A0_GE10_GBODE_CELL_CNTr
#define GE10_GBODE_CELL_CNTr_SIZE BCM56218_A0_GE10_GBODE_CELL_CNTr_SIZE
typedef BCM56218_A0_GE10_GBODE_CELL_CNTr_t GE10_GBODE_CELL_CNTr_t;
#define GE10_GBODE_CELL_CNTr_CLR BCM56218_A0_GE10_GBODE_CELL_CNTr_CLR
#define GE10_GBODE_CELL_CNTr_SET BCM56218_A0_GE10_GBODE_CELL_CNTr_SET
#define GE10_GBODE_CELL_CNTr_GET BCM56218_A0_GE10_GBODE_CELL_CNTr_GET
#define GE10_GBODE_CELL_CNTr_CELL_CNTf_GET BCM56218_A0_GE10_GBODE_CELL_CNTr_CELL_CNTf_GET
#define GE10_GBODE_CELL_CNTr_CELL_CNTf_SET BCM56218_A0_GE10_GBODE_CELL_CNTr_CELL_CNTf_SET
#define READ_GE10_GBODE_CELL_CNTr BCM56218_A0_READ_GE10_GBODE_CELL_CNTr
#define WRITE_GE10_GBODE_CELL_CNTr BCM56218_A0_WRITE_GE10_GBODE_CELL_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GE10_GBODE_CELL_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GE10_GBODE_CELL_REQ_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell request count register for GE10 
 * SIZE:     32
 * FIELDS:
 *     REQ_CNT          Number of cell request made to Egress Pipeline, MAX is 4 in FB mode. In Felix mode, MAX is 8.
 *
 ******************************************************************************/
#define BCM56218_A0_GE10_GBODE_CELL_REQ_CNTr 0x00080026

#define BCM56218_A0_GE10_GBODE_CELL_REQ_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE10_GBODE_CELL_REQ_CNT.
 *
 */
typedef union BCM56218_A0_GE10_GBODE_CELL_REQ_CNTr_s {
	uint32_t v[1];
	uint32_t ge10_gbode_cell_req_cnt[1];
	uint32_t _ge10_gbode_cell_req_cnt;
} BCM56218_A0_GE10_GBODE_CELL_REQ_CNTr_t;

#define BCM56218_A0_GE10_GBODE_CELL_REQ_CNTr_CLR(r) (r).ge10_gbode_cell_req_cnt[0] = 0
#define BCM56218_A0_GE10_GBODE_CELL_REQ_CNTr_SET(r,d) (r).ge10_gbode_cell_req_cnt[0] = d
#define BCM56218_A0_GE10_GBODE_CELL_REQ_CNTr_GET(r) (r).ge10_gbode_cell_req_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_GE10_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET(r) (((r).ge10_gbode_cell_req_cnt[0]) & 0xf)
#define BCM56218_A0_GE10_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET(r,f) (r).ge10_gbode_cell_req_cnt[0]=(((r).ge10_gbode_cell_req_cnt[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access GE10_GBODE_CELL_REQ_CNT.
 *
 */
#define BCM56218_A0_READ_GE10_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE10_GBODE_CELL_REQ_CNTr,(r._ge10_gbode_cell_req_cnt))
#define BCM56218_A0_WRITE_GE10_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE10_GBODE_CELL_REQ_CNTr,&(r._ge10_gbode_cell_req_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE10_GBODE_CELL_REQ_CNTr BCM56218_A0_GE10_GBODE_CELL_REQ_CNTr
#define GE10_GBODE_CELL_REQ_CNTr_SIZE BCM56218_A0_GE10_GBODE_CELL_REQ_CNTr_SIZE
typedef BCM56218_A0_GE10_GBODE_CELL_REQ_CNTr_t GE10_GBODE_CELL_REQ_CNTr_t;
#define GE10_GBODE_CELL_REQ_CNTr_CLR BCM56218_A0_GE10_GBODE_CELL_REQ_CNTr_CLR
#define GE10_GBODE_CELL_REQ_CNTr_SET BCM56218_A0_GE10_GBODE_CELL_REQ_CNTr_SET
#define GE10_GBODE_CELL_REQ_CNTr_GET BCM56218_A0_GE10_GBODE_CELL_REQ_CNTr_GET
#define GE10_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET BCM56218_A0_GE10_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET
#define GE10_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET BCM56218_A0_GE10_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET
#define READ_GE10_GBODE_CELL_REQ_CNTr BCM56218_A0_READ_GE10_GBODE_CELL_REQ_CNTr
#define WRITE_GE10_GBODE_CELL_REQ_CNTr BCM56218_A0_WRITE_GE10_GBODE_CELL_REQ_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GE10_GBODE_CELL_REQ_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GE10_GBOD_OVRFLW
 * BLOCKS:   GPORT0
 * DESC:     GBOD RX fifo overflow for GE10 
 * SIZE:     32
 * FIELDS:
 *     OVRFLW           GBOD RX fifo overflow flag.
 *
 ******************************************************************************/
#define BCM56218_A0_GE10_GBOD_OVRFLWr 0x0008000e

#define BCM56218_A0_GE10_GBOD_OVRFLWr_SIZE 4

/*
 * This structure should be used to declare and program GE10_GBOD_OVRFLW.
 *
 */
typedef union BCM56218_A0_GE10_GBOD_OVRFLWr_s {
	uint32_t v[1];
	uint32_t ge10_gbod_ovrflw[1];
	uint32_t _ge10_gbod_ovrflw;
} BCM56218_A0_GE10_GBOD_OVRFLWr_t;

#define BCM56218_A0_GE10_GBOD_OVRFLWr_CLR(r) (r).ge10_gbod_ovrflw[0] = 0
#define BCM56218_A0_GE10_GBOD_OVRFLWr_SET(r,d) (r).ge10_gbod_ovrflw[0] = d
#define BCM56218_A0_GE10_GBOD_OVRFLWr_GET(r) (r).ge10_gbod_ovrflw[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_GE10_GBOD_OVRFLWr_OVRFLWf_GET(r) (((r).ge10_gbod_ovrflw[0]) & 0x1)
#define BCM56218_A0_GE10_GBOD_OVRFLWr_OVRFLWf_SET(r,f) (r).ge10_gbod_ovrflw[0]=(((r).ge10_gbod_ovrflw[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access GE10_GBOD_OVRFLW.
 *
 */
#define BCM56218_A0_READ_GE10_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE10_GBOD_OVRFLWr,(r._ge10_gbod_ovrflw))
#define BCM56218_A0_WRITE_GE10_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE10_GBOD_OVRFLWr,&(r._ge10_gbod_ovrflw))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE10_GBOD_OVRFLWr BCM56218_A0_GE10_GBOD_OVRFLWr
#define GE10_GBOD_OVRFLWr_SIZE BCM56218_A0_GE10_GBOD_OVRFLWr_SIZE
typedef BCM56218_A0_GE10_GBOD_OVRFLWr_t GE10_GBOD_OVRFLWr_t;
#define GE10_GBOD_OVRFLWr_CLR BCM56218_A0_GE10_GBOD_OVRFLWr_CLR
#define GE10_GBOD_OVRFLWr_SET BCM56218_A0_GE10_GBOD_OVRFLWr_SET
#define GE10_GBOD_OVRFLWr_GET BCM56218_A0_GE10_GBOD_OVRFLWr_GET
#define GE10_GBOD_OVRFLWr_OVRFLWf_GET BCM56218_A0_GE10_GBOD_OVRFLWr_OVRFLWf_GET
#define GE10_GBOD_OVRFLWr_OVRFLWf_SET BCM56218_A0_GE10_GBOD_OVRFLWr_OVRFLWf_SET
#define READ_GE10_GBOD_OVRFLWr BCM56218_A0_READ_GE10_GBOD_OVRFLWr
#define WRITE_GE10_GBOD_OVRFLWr BCM56218_A0_WRITE_GE10_GBOD_OVRFLWr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GE10_GBOD_OVRFLWr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GE11_GBODE_CELL_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell count register for GE11 
 * SIZE:     32
 * FIELDS:
 *     CELL_CNT         Number of cell counts in GBODE tx fifo.
 *
 ******************************************************************************/
#define BCM56218_A0_GE11_GBODE_CELL_CNTr 0x0008001b

#define BCM56218_A0_GE11_GBODE_CELL_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE11_GBODE_CELL_CNT.
 *
 */
typedef union BCM56218_A0_GE11_GBODE_CELL_CNTr_s {
	uint32_t v[1];
	uint32_t ge11_gbode_cell_cnt[1];
	uint32_t _ge11_gbode_cell_cnt;
} BCM56218_A0_GE11_GBODE_CELL_CNTr_t;

#define BCM56218_A0_GE11_GBODE_CELL_CNTr_CLR(r) (r).ge11_gbode_cell_cnt[0] = 0
#define BCM56218_A0_GE11_GBODE_CELL_CNTr_SET(r,d) (r).ge11_gbode_cell_cnt[0] = d
#define BCM56218_A0_GE11_GBODE_CELL_CNTr_GET(r) (r).ge11_gbode_cell_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_GE11_GBODE_CELL_CNTr_CELL_CNTf_GET(r) (((r).ge11_gbode_cell_cnt[0]) & 0xf)
#define BCM56218_A0_GE11_GBODE_CELL_CNTr_CELL_CNTf_SET(r,f) (r).ge11_gbode_cell_cnt[0]=(((r).ge11_gbode_cell_cnt[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access GE11_GBODE_CELL_CNT.
 *
 */
#define BCM56218_A0_READ_GE11_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE11_GBODE_CELL_CNTr,(r._ge11_gbode_cell_cnt))
#define BCM56218_A0_WRITE_GE11_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE11_GBODE_CELL_CNTr,&(r._ge11_gbode_cell_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE11_GBODE_CELL_CNTr BCM56218_A0_GE11_GBODE_CELL_CNTr
#define GE11_GBODE_CELL_CNTr_SIZE BCM56218_A0_GE11_GBODE_CELL_CNTr_SIZE
typedef BCM56218_A0_GE11_GBODE_CELL_CNTr_t GE11_GBODE_CELL_CNTr_t;
#define GE11_GBODE_CELL_CNTr_CLR BCM56218_A0_GE11_GBODE_CELL_CNTr_CLR
#define GE11_GBODE_CELL_CNTr_SET BCM56218_A0_GE11_GBODE_CELL_CNTr_SET
#define GE11_GBODE_CELL_CNTr_GET BCM56218_A0_GE11_GBODE_CELL_CNTr_GET
#define GE11_GBODE_CELL_CNTr_CELL_CNTf_GET BCM56218_A0_GE11_GBODE_CELL_CNTr_CELL_CNTf_GET
#define GE11_GBODE_CELL_CNTr_CELL_CNTf_SET BCM56218_A0_GE11_GBODE_CELL_CNTr_CELL_CNTf_SET
#define READ_GE11_GBODE_CELL_CNTr BCM56218_A0_READ_GE11_GBODE_CELL_CNTr
#define WRITE_GE11_GBODE_CELL_CNTr BCM56218_A0_WRITE_GE11_GBODE_CELL_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GE11_GBODE_CELL_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GE11_GBODE_CELL_REQ_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell request count register for GE11 
 * SIZE:     32
 * FIELDS:
 *     REQ_CNT          Number of cell request made to Egress Pipeline, MAX is 4 in FB mode. In Felix mode, MAX is 8.
 *
 ******************************************************************************/
#define BCM56218_A0_GE11_GBODE_CELL_REQ_CNTr 0x00080027

#define BCM56218_A0_GE11_GBODE_CELL_REQ_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE11_GBODE_CELL_REQ_CNT.
 *
 */
typedef union BCM56218_A0_GE11_GBODE_CELL_REQ_CNTr_s {
	uint32_t v[1];
	uint32_t ge11_gbode_cell_req_cnt[1];
	uint32_t _ge11_gbode_cell_req_cnt;
} BCM56218_A0_GE11_GBODE_CELL_REQ_CNTr_t;

#define BCM56218_A0_GE11_GBODE_CELL_REQ_CNTr_CLR(r) (r).ge11_gbode_cell_req_cnt[0] = 0
#define BCM56218_A0_GE11_GBODE_CELL_REQ_CNTr_SET(r,d) (r).ge11_gbode_cell_req_cnt[0] = d
#define BCM56218_A0_GE11_GBODE_CELL_REQ_CNTr_GET(r) (r).ge11_gbode_cell_req_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_GE11_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET(r) (((r).ge11_gbode_cell_req_cnt[0]) & 0xf)
#define BCM56218_A0_GE11_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET(r,f) (r).ge11_gbode_cell_req_cnt[0]=(((r).ge11_gbode_cell_req_cnt[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access GE11_GBODE_CELL_REQ_CNT.
 *
 */
#define BCM56218_A0_READ_GE11_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE11_GBODE_CELL_REQ_CNTr,(r._ge11_gbode_cell_req_cnt))
#define BCM56218_A0_WRITE_GE11_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE11_GBODE_CELL_REQ_CNTr,&(r._ge11_gbode_cell_req_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE11_GBODE_CELL_REQ_CNTr BCM56218_A0_GE11_GBODE_CELL_REQ_CNTr
#define GE11_GBODE_CELL_REQ_CNTr_SIZE BCM56218_A0_GE11_GBODE_CELL_REQ_CNTr_SIZE
typedef BCM56218_A0_GE11_GBODE_CELL_REQ_CNTr_t GE11_GBODE_CELL_REQ_CNTr_t;
#define GE11_GBODE_CELL_REQ_CNTr_CLR BCM56218_A0_GE11_GBODE_CELL_REQ_CNTr_CLR
#define GE11_GBODE_CELL_REQ_CNTr_SET BCM56218_A0_GE11_GBODE_CELL_REQ_CNTr_SET
#define GE11_GBODE_CELL_REQ_CNTr_GET BCM56218_A0_GE11_GBODE_CELL_REQ_CNTr_GET
#define GE11_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET BCM56218_A0_GE11_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET
#define GE11_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET BCM56218_A0_GE11_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET
#define READ_GE11_GBODE_CELL_REQ_CNTr BCM56218_A0_READ_GE11_GBODE_CELL_REQ_CNTr
#define WRITE_GE11_GBODE_CELL_REQ_CNTr BCM56218_A0_WRITE_GE11_GBODE_CELL_REQ_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GE11_GBODE_CELL_REQ_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GE11_GBOD_OVRFLW
 * BLOCKS:   GPORT0
 * DESC:     GBOD RX fifo overflow for GE11 
 * SIZE:     32
 * FIELDS:
 *     OVRFLW           GBOD RX fifo overflow flag.
 *
 ******************************************************************************/
#define BCM56218_A0_GE11_GBOD_OVRFLWr 0x0008000f

#define BCM56218_A0_GE11_GBOD_OVRFLWr_SIZE 4

/*
 * This structure should be used to declare and program GE11_GBOD_OVRFLW.
 *
 */
typedef union BCM56218_A0_GE11_GBOD_OVRFLWr_s {
	uint32_t v[1];
	uint32_t ge11_gbod_ovrflw[1];
	uint32_t _ge11_gbod_ovrflw;
} BCM56218_A0_GE11_GBOD_OVRFLWr_t;

#define BCM56218_A0_GE11_GBOD_OVRFLWr_CLR(r) (r).ge11_gbod_ovrflw[0] = 0
#define BCM56218_A0_GE11_GBOD_OVRFLWr_SET(r,d) (r).ge11_gbod_ovrflw[0] = d
#define BCM56218_A0_GE11_GBOD_OVRFLWr_GET(r) (r).ge11_gbod_ovrflw[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_GE11_GBOD_OVRFLWr_OVRFLWf_GET(r) (((r).ge11_gbod_ovrflw[0]) & 0x1)
#define BCM56218_A0_GE11_GBOD_OVRFLWr_OVRFLWf_SET(r,f) (r).ge11_gbod_ovrflw[0]=(((r).ge11_gbod_ovrflw[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access GE11_GBOD_OVRFLW.
 *
 */
#define BCM56218_A0_READ_GE11_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE11_GBOD_OVRFLWr,(r._ge11_gbod_ovrflw))
#define BCM56218_A0_WRITE_GE11_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE11_GBOD_OVRFLWr,&(r._ge11_gbod_ovrflw))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE11_GBOD_OVRFLWr BCM56218_A0_GE11_GBOD_OVRFLWr
#define GE11_GBOD_OVRFLWr_SIZE BCM56218_A0_GE11_GBOD_OVRFLWr_SIZE
typedef BCM56218_A0_GE11_GBOD_OVRFLWr_t GE11_GBOD_OVRFLWr_t;
#define GE11_GBOD_OVRFLWr_CLR BCM56218_A0_GE11_GBOD_OVRFLWr_CLR
#define GE11_GBOD_OVRFLWr_SET BCM56218_A0_GE11_GBOD_OVRFLWr_SET
#define GE11_GBOD_OVRFLWr_GET BCM56218_A0_GE11_GBOD_OVRFLWr_GET
#define GE11_GBOD_OVRFLWr_OVRFLWf_GET BCM56218_A0_GE11_GBOD_OVRFLWr_OVRFLWf_GET
#define GE11_GBOD_OVRFLWr_OVRFLWf_SET BCM56218_A0_GE11_GBOD_OVRFLWr_OVRFLWf_SET
#define READ_GE11_GBOD_OVRFLWr BCM56218_A0_READ_GE11_GBOD_OVRFLWr
#define WRITE_GE11_GBOD_OVRFLWr BCM56218_A0_WRITE_GE11_GBOD_OVRFLWr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GE11_GBOD_OVRFLWr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GE1_GBODE_CELL_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell count register for GE1 
 * SIZE:     32
 * FIELDS:
 *     CELL_CNT         Number of cell counts in GBODE tx fifo.
 *
 ******************************************************************************/
#define BCM56218_A0_GE1_GBODE_CELL_CNTr 0x00080011

#define BCM56218_A0_GE1_GBODE_CELL_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE1_GBODE_CELL_CNT.
 *
 */
typedef union BCM56218_A0_GE1_GBODE_CELL_CNTr_s {
	uint32_t v[1];
	uint32_t ge1_gbode_cell_cnt[1];
	uint32_t _ge1_gbode_cell_cnt;
} BCM56218_A0_GE1_GBODE_CELL_CNTr_t;

#define BCM56218_A0_GE1_GBODE_CELL_CNTr_CLR(r) (r).ge1_gbode_cell_cnt[0] = 0
#define BCM56218_A0_GE1_GBODE_CELL_CNTr_SET(r,d) (r).ge1_gbode_cell_cnt[0] = d
#define BCM56218_A0_GE1_GBODE_CELL_CNTr_GET(r) (r).ge1_gbode_cell_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_GE1_GBODE_CELL_CNTr_CELL_CNTf_GET(r) (((r).ge1_gbode_cell_cnt[0]) & 0xf)
#define BCM56218_A0_GE1_GBODE_CELL_CNTr_CELL_CNTf_SET(r,f) (r).ge1_gbode_cell_cnt[0]=(((r).ge1_gbode_cell_cnt[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access GE1_GBODE_CELL_CNT.
 *
 */
#define BCM56218_A0_READ_GE1_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE1_GBODE_CELL_CNTr,(r._ge1_gbode_cell_cnt))
#define BCM56218_A0_WRITE_GE1_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE1_GBODE_CELL_CNTr,&(r._ge1_gbode_cell_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE1_GBODE_CELL_CNTr BCM56218_A0_GE1_GBODE_CELL_CNTr
#define GE1_GBODE_CELL_CNTr_SIZE BCM56218_A0_GE1_GBODE_CELL_CNTr_SIZE
typedef BCM56218_A0_GE1_GBODE_CELL_CNTr_t GE1_GBODE_CELL_CNTr_t;
#define GE1_GBODE_CELL_CNTr_CLR BCM56218_A0_GE1_GBODE_CELL_CNTr_CLR
#define GE1_GBODE_CELL_CNTr_SET BCM56218_A0_GE1_GBODE_CELL_CNTr_SET
#define GE1_GBODE_CELL_CNTr_GET BCM56218_A0_GE1_GBODE_CELL_CNTr_GET
#define GE1_GBODE_CELL_CNTr_CELL_CNTf_GET BCM56218_A0_GE1_GBODE_CELL_CNTr_CELL_CNTf_GET
#define GE1_GBODE_CELL_CNTr_CELL_CNTf_SET BCM56218_A0_GE1_GBODE_CELL_CNTr_CELL_CNTf_SET
#define READ_GE1_GBODE_CELL_CNTr BCM56218_A0_READ_GE1_GBODE_CELL_CNTr
#define WRITE_GE1_GBODE_CELL_CNTr BCM56218_A0_WRITE_GE1_GBODE_CELL_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GE1_GBODE_CELL_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GE1_GBODE_CELL_REQ_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell request count register for GE1 
 * SIZE:     32
 * FIELDS:
 *     REQ_CNT          Number of cell request made to Egress Pipeline, MAX is 4 in FB mode. In Felix mode, MAX is 8.
 *
 ******************************************************************************/
#define BCM56218_A0_GE1_GBODE_CELL_REQ_CNTr 0x0008001d

#define BCM56218_A0_GE1_GBODE_CELL_REQ_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE1_GBODE_CELL_REQ_CNT.
 *
 */
typedef union BCM56218_A0_GE1_GBODE_CELL_REQ_CNTr_s {
	uint32_t v[1];
	uint32_t ge1_gbode_cell_req_cnt[1];
	uint32_t _ge1_gbode_cell_req_cnt;
} BCM56218_A0_GE1_GBODE_CELL_REQ_CNTr_t;

#define BCM56218_A0_GE1_GBODE_CELL_REQ_CNTr_CLR(r) (r).ge1_gbode_cell_req_cnt[0] = 0
#define BCM56218_A0_GE1_GBODE_CELL_REQ_CNTr_SET(r,d) (r).ge1_gbode_cell_req_cnt[0] = d
#define BCM56218_A0_GE1_GBODE_CELL_REQ_CNTr_GET(r) (r).ge1_gbode_cell_req_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_GE1_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET(r) (((r).ge1_gbode_cell_req_cnt[0]) & 0xf)
#define BCM56218_A0_GE1_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET(r,f) (r).ge1_gbode_cell_req_cnt[0]=(((r).ge1_gbode_cell_req_cnt[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access GE1_GBODE_CELL_REQ_CNT.
 *
 */
#define BCM56218_A0_READ_GE1_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE1_GBODE_CELL_REQ_CNTr,(r._ge1_gbode_cell_req_cnt))
#define BCM56218_A0_WRITE_GE1_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE1_GBODE_CELL_REQ_CNTr,&(r._ge1_gbode_cell_req_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE1_GBODE_CELL_REQ_CNTr BCM56218_A0_GE1_GBODE_CELL_REQ_CNTr
#define GE1_GBODE_CELL_REQ_CNTr_SIZE BCM56218_A0_GE1_GBODE_CELL_REQ_CNTr_SIZE
typedef BCM56218_A0_GE1_GBODE_CELL_REQ_CNTr_t GE1_GBODE_CELL_REQ_CNTr_t;
#define GE1_GBODE_CELL_REQ_CNTr_CLR BCM56218_A0_GE1_GBODE_CELL_REQ_CNTr_CLR
#define GE1_GBODE_CELL_REQ_CNTr_SET BCM56218_A0_GE1_GBODE_CELL_REQ_CNTr_SET
#define GE1_GBODE_CELL_REQ_CNTr_GET BCM56218_A0_GE1_GBODE_CELL_REQ_CNTr_GET
#define GE1_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET BCM56218_A0_GE1_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET
#define GE1_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET BCM56218_A0_GE1_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET
#define READ_GE1_GBODE_CELL_REQ_CNTr BCM56218_A0_READ_GE1_GBODE_CELL_REQ_CNTr
#define WRITE_GE1_GBODE_CELL_REQ_CNTr BCM56218_A0_WRITE_GE1_GBODE_CELL_REQ_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GE1_GBODE_CELL_REQ_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GE1_GBOD_OVRFLW
 * BLOCKS:   GPORT0
 * DESC:     GBOD RX fifo overflow for GE1 
 * SIZE:     32
 * FIELDS:
 *     OVRFLW           GBOD RX fifo overflow flag.
 *
 ******************************************************************************/
#define BCM56218_A0_GE1_GBOD_OVRFLWr 0x00080005

#define BCM56218_A0_GE1_GBOD_OVRFLWr_SIZE 4

/*
 * This structure should be used to declare and program GE1_GBOD_OVRFLW.
 *
 */
typedef union BCM56218_A0_GE1_GBOD_OVRFLWr_s {
	uint32_t v[1];
	uint32_t ge1_gbod_ovrflw[1];
	uint32_t _ge1_gbod_ovrflw;
} BCM56218_A0_GE1_GBOD_OVRFLWr_t;

#define BCM56218_A0_GE1_GBOD_OVRFLWr_CLR(r) (r).ge1_gbod_ovrflw[0] = 0
#define BCM56218_A0_GE1_GBOD_OVRFLWr_SET(r,d) (r).ge1_gbod_ovrflw[0] = d
#define BCM56218_A0_GE1_GBOD_OVRFLWr_GET(r) (r).ge1_gbod_ovrflw[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_GE1_GBOD_OVRFLWr_OVRFLWf_GET(r) (((r).ge1_gbod_ovrflw[0]) & 0x1)
#define BCM56218_A0_GE1_GBOD_OVRFLWr_OVRFLWf_SET(r,f) (r).ge1_gbod_ovrflw[0]=(((r).ge1_gbod_ovrflw[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access GE1_GBOD_OVRFLW.
 *
 */
#define BCM56218_A0_READ_GE1_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE1_GBOD_OVRFLWr,(r._ge1_gbod_ovrflw))
#define BCM56218_A0_WRITE_GE1_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE1_GBOD_OVRFLWr,&(r._ge1_gbod_ovrflw))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE1_GBOD_OVRFLWr BCM56218_A0_GE1_GBOD_OVRFLWr
#define GE1_GBOD_OVRFLWr_SIZE BCM56218_A0_GE1_GBOD_OVRFLWr_SIZE
typedef BCM56218_A0_GE1_GBOD_OVRFLWr_t GE1_GBOD_OVRFLWr_t;
#define GE1_GBOD_OVRFLWr_CLR BCM56218_A0_GE1_GBOD_OVRFLWr_CLR
#define GE1_GBOD_OVRFLWr_SET BCM56218_A0_GE1_GBOD_OVRFLWr_SET
#define GE1_GBOD_OVRFLWr_GET BCM56218_A0_GE1_GBOD_OVRFLWr_GET
#define GE1_GBOD_OVRFLWr_OVRFLWf_GET BCM56218_A0_GE1_GBOD_OVRFLWr_OVRFLWf_GET
#define GE1_GBOD_OVRFLWr_OVRFLWf_SET BCM56218_A0_GE1_GBOD_OVRFLWr_OVRFLWf_SET
#define READ_GE1_GBOD_OVRFLWr BCM56218_A0_READ_GE1_GBOD_OVRFLWr
#define WRITE_GE1_GBOD_OVRFLWr BCM56218_A0_WRITE_GE1_GBOD_OVRFLWr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GE1_GBOD_OVRFLWr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GE2_GBODE_CELL_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell count register for GE2 
 * SIZE:     32
 * FIELDS:
 *     CELL_CNT         Number of cell counts in GBODE tx fifo.
 *
 ******************************************************************************/
#define BCM56218_A0_GE2_GBODE_CELL_CNTr 0x00080012

#define BCM56218_A0_GE2_GBODE_CELL_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE2_GBODE_CELL_CNT.
 *
 */
typedef union BCM56218_A0_GE2_GBODE_CELL_CNTr_s {
	uint32_t v[1];
	uint32_t ge2_gbode_cell_cnt[1];
	uint32_t _ge2_gbode_cell_cnt;
} BCM56218_A0_GE2_GBODE_CELL_CNTr_t;

#define BCM56218_A0_GE2_GBODE_CELL_CNTr_CLR(r) (r).ge2_gbode_cell_cnt[0] = 0
#define BCM56218_A0_GE2_GBODE_CELL_CNTr_SET(r,d) (r).ge2_gbode_cell_cnt[0] = d
#define BCM56218_A0_GE2_GBODE_CELL_CNTr_GET(r) (r).ge2_gbode_cell_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_GE2_GBODE_CELL_CNTr_CELL_CNTf_GET(r) (((r).ge2_gbode_cell_cnt[0]) & 0xf)
#define BCM56218_A0_GE2_GBODE_CELL_CNTr_CELL_CNTf_SET(r,f) (r).ge2_gbode_cell_cnt[0]=(((r).ge2_gbode_cell_cnt[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access GE2_GBODE_CELL_CNT.
 *
 */
#define BCM56218_A0_READ_GE2_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE2_GBODE_CELL_CNTr,(r._ge2_gbode_cell_cnt))
#define BCM56218_A0_WRITE_GE2_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE2_GBODE_CELL_CNTr,&(r._ge2_gbode_cell_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE2_GBODE_CELL_CNTr BCM56218_A0_GE2_GBODE_CELL_CNTr
#define GE2_GBODE_CELL_CNTr_SIZE BCM56218_A0_GE2_GBODE_CELL_CNTr_SIZE
typedef BCM56218_A0_GE2_GBODE_CELL_CNTr_t GE2_GBODE_CELL_CNTr_t;
#define GE2_GBODE_CELL_CNTr_CLR BCM56218_A0_GE2_GBODE_CELL_CNTr_CLR
#define GE2_GBODE_CELL_CNTr_SET BCM56218_A0_GE2_GBODE_CELL_CNTr_SET
#define GE2_GBODE_CELL_CNTr_GET BCM56218_A0_GE2_GBODE_CELL_CNTr_GET
#define GE2_GBODE_CELL_CNTr_CELL_CNTf_GET BCM56218_A0_GE2_GBODE_CELL_CNTr_CELL_CNTf_GET
#define GE2_GBODE_CELL_CNTr_CELL_CNTf_SET BCM56218_A0_GE2_GBODE_CELL_CNTr_CELL_CNTf_SET
#define READ_GE2_GBODE_CELL_CNTr BCM56218_A0_READ_GE2_GBODE_CELL_CNTr
#define WRITE_GE2_GBODE_CELL_CNTr BCM56218_A0_WRITE_GE2_GBODE_CELL_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GE2_GBODE_CELL_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GE2_GBODE_CELL_REQ_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell request count register for GE2 
 * SIZE:     32
 * FIELDS:
 *     REQ_CNT          Number of cell request made to Egress Pipeline, MAX is 4 in FB mode. In Felix mode, MAX is 8.
 *
 ******************************************************************************/
#define BCM56218_A0_GE2_GBODE_CELL_REQ_CNTr 0x0008001e

#define BCM56218_A0_GE2_GBODE_CELL_REQ_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE2_GBODE_CELL_REQ_CNT.
 *
 */
typedef union BCM56218_A0_GE2_GBODE_CELL_REQ_CNTr_s {
	uint32_t v[1];
	uint32_t ge2_gbode_cell_req_cnt[1];
	uint32_t _ge2_gbode_cell_req_cnt;
} BCM56218_A0_GE2_GBODE_CELL_REQ_CNTr_t;

#define BCM56218_A0_GE2_GBODE_CELL_REQ_CNTr_CLR(r) (r).ge2_gbode_cell_req_cnt[0] = 0
#define BCM56218_A0_GE2_GBODE_CELL_REQ_CNTr_SET(r,d) (r).ge2_gbode_cell_req_cnt[0] = d
#define BCM56218_A0_GE2_GBODE_CELL_REQ_CNTr_GET(r) (r).ge2_gbode_cell_req_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_GE2_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET(r) (((r).ge2_gbode_cell_req_cnt[0]) & 0xf)
#define BCM56218_A0_GE2_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET(r,f) (r).ge2_gbode_cell_req_cnt[0]=(((r).ge2_gbode_cell_req_cnt[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access GE2_GBODE_CELL_REQ_CNT.
 *
 */
#define BCM56218_A0_READ_GE2_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE2_GBODE_CELL_REQ_CNTr,(r._ge2_gbode_cell_req_cnt))
#define BCM56218_A0_WRITE_GE2_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE2_GBODE_CELL_REQ_CNTr,&(r._ge2_gbode_cell_req_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE2_GBODE_CELL_REQ_CNTr BCM56218_A0_GE2_GBODE_CELL_REQ_CNTr
#define GE2_GBODE_CELL_REQ_CNTr_SIZE BCM56218_A0_GE2_GBODE_CELL_REQ_CNTr_SIZE
typedef BCM56218_A0_GE2_GBODE_CELL_REQ_CNTr_t GE2_GBODE_CELL_REQ_CNTr_t;
#define GE2_GBODE_CELL_REQ_CNTr_CLR BCM56218_A0_GE2_GBODE_CELL_REQ_CNTr_CLR
#define GE2_GBODE_CELL_REQ_CNTr_SET BCM56218_A0_GE2_GBODE_CELL_REQ_CNTr_SET
#define GE2_GBODE_CELL_REQ_CNTr_GET BCM56218_A0_GE2_GBODE_CELL_REQ_CNTr_GET
#define GE2_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET BCM56218_A0_GE2_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET
#define GE2_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET BCM56218_A0_GE2_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET
#define READ_GE2_GBODE_CELL_REQ_CNTr BCM56218_A0_READ_GE2_GBODE_CELL_REQ_CNTr
#define WRITE_GE2_GBODE_CELL_REQ_CNTr BCM56218_A0_WRITE_GE2_GBODE_CELL_REQ_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GE2_GBODE_CELL_REQ_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GE2_GBOD_OVRFLW
 * BLOCKS:   GPORT0
 * DESC:     GBOD RX fifo overflow for GE2 
 * SIZE:     32
 * FIELDS:
 *     OVRFLW           GBOD RX fifo overflow flag.
 *
 ******************************************************************************/
#define BCM56218_A0_GE2_GBOD_OVRFLWr 0x00080006

#define BCM56218_A0_GE2_GBOD_OVRFLWr_SIZE 4

/*
 * This structure should be used to declare and program GE2_GBOD_OVRFLW.
 *
 */
typedef union BCM56218_A0_GE2_GBOD_OVRFLWr_s {
	uint32_t v[1];
	uint32_t ge2_gbod_ovrflw[1];
	uint32_t _ge2_gbod_ovrflw;
} BCM56218_A0_GE2_GBOD_OVRFLWr_t;

#define BCM56218_A0_GE2_GBOD_OVRFLWr_CLR(r) (r).ge2_gbod_ovrflw[0] = 0
#define BCM56218_A0_GE2_GBOD_OVRFLWr_SET(r,d) (r).ge2_gbod_ovrflw[0] = d
#define BCM56218_A0_GE2_GBOD_OVRFLWr_GET(r) (r).ge2_gbod_ovrflw[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_GE2_GBOD_OVRFLWr_OVRFLWf_GET(r) (((r).ge2_gbod_ovrflw[0]) & 0x1)
#define BCM56218_A0_GE2_GBOD_OVRFLWr_OVRFLWf_SET(r,f) (r).ge2_gbod_ovrflw[0]=(((r).ge2_gbod_ovrflw[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access GE2_GBOD_OVRFLW.
 *
 */
#define BCM56218_A0_READ_GE2_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE2_GBOD_OVRFLWr,(r._ge2_gbod_ovrflw))
#define BCM56218_A0_WRITE_GE2_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE2_GBOD_OVRFLWr,&(r._ge2_gbod_ovrflw))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE2_GBOD_OVRFLWr BCM56218_A0_GE2_GBOD_OVRFLWr
#define GE2_GBOD_OVRFLWr_SIZE BCM56218_A0_GE2_GBOD_OVRFLWr_SIZE
typedef BCM56218_A0_GE2_GBOD_OVRFLWr_t GE2_GBOD_OVRFLWr_t;
#define GE2_GBOD_OVRFLWr_CLR BCM56218_A0_GE2_GBOD_OVRFLWr_CLR
#define GE2_GBOD_OVRFLWr_SET BCM56218_A0_GE2_GBOD_OVRFLWr_SET
#define GE2_GBOD_OVRFLWr_GET BCM56218_A0_GE2_GBOD_OVRFLWr_GET
#define GE2_GBOD_OVRFLWr_OVRFLWf_GET BCM56218_A0_GE2_GBOD_OVRFLWr_OVRFLWf_GET
#define GE2_GBOD_OVRFLWr_OVRFLWf_SET BCM56218_A0_GE2_GBOD_OVRFLWr_OVRFLWf_SET
#define READ_GE2_GBOD_OVRFLWr BCM56218_A0_READ_GE2_GBOD_OVRFLWr
#define WRITE_GE2_GBOD_OVRFLWr BCM56218_A0_WRITE_GE2_GBOD_OVRFLWr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GE2_GBOD_OVRFLWr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GE3_GBODE_CELL_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell count register for GE3 
 * SIZE:     32
 * FIELDS:
 *     CELL_CNT         Number of cell counts in GBODE tx fifo.
 *
 ******************************************************************************/
#define BCM56218_A0_GE3_GBODE_CELL_CNTr 0x00080013

#define BCM56218_A0_GE3_GBODE_CELL_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE3_GBODE_CELL_CNT.
 *
 */
typedef union BCM56218_A0_GE3_GBODE_CELL_CNTr_s {
	uint32_t v[1];
	uint32_t ge3_gbode_cell_cnt[1];
	uint32_t _ge3_gbode_cell_cnt;
} BCM56218_A0_GE3_GBODE_CELL_CNTr_t;

#define BCM56218_A0_GE3_GBODE_CELL_CNTr_CLR(r) (r).ge3_gbode_cell_cnt[0] = 0
#define BCM56218_A0_GE3_GBODE_CELL_CNTr_SET(r,d) (r).ge3_gbode_cell_cnt[0] = d
#define BCM56218_A0_GE3_GBODE_CELL_CNTr_GET(r) (r).ge3_gbode_cell_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_GE3_GBODE_CELL_CNTr_CELL_CNTf_GET(r) (((r).ge3_gbode_cell_cnt[0]) & 0xf)
#define BCM56218_A0_GE3_GBODE_CELL_CNTr_CELL_CNTf_SET(r,f) (r).ge3_gbode_cell_cnt[0]=(((r).ge3_gbode_cell_cnt[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access GE3_GBODE_CELL_CNT.
 *
 */
#define BCM56218_A0_READ_GE3_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE3_GBODE_CELL_CNTr,(r._ge3_gbode_cell_cnt))
#define BCM56218_A0_WRITE_GE3_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE3_GBODE_CELL_CNTr,&(r._ge3_gbode_cell_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE3_GBODE_CELL_CNTr BCM56218_A0_GE3_GBODE_CELL_CNTr
#define GE3_GBODE_CELL_CNTr_SIZE BCM56218_A0_GE3_GBODE_CELL_CNTr_SIZE
typedef BCM56218_A0_GE3_GBODE_CELL_CNTr_t GE3_GBODE_CELL_CNTr_t;
#define GE3_GBODE_CELL_CNTr_CLR BCM56218_A0_GE3_GBODE_CELL_CNTr_CLR
#define GE3_GBODE_CELL_CNTr_SET BCM56218_A0_GE3_GBODE_CELL_CNTr_SET
#define GE3_GBODE_CELL_CNTr_GET BCM56218_A0_GE3_GBODE_CELL_CNTr_GET
#define GE3_GBODE_CELL_CNTr_CELL_CNTf_GET BCM56218_A0_GE3_GBODE_CELL_CNTr_CELL_CNTf_GET
#define GE3_GBODE_CELL_CNTr_CELL_CNTf_SET BCM56218_A0_GE3_GBODE_CELL_CNTr_CELL_CNTf_SET
#define READ_GE3_GBODE_CELL_CNTr BCM56218_A0_READ_GE3_GBODE_CELL_CNTr
#define WRITE_GE3_GBODE_CELL_CNTr BCM56218_A0_WRITE_GE3_GBODE_CELL_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GE3_GBODE_CELL_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GE3_GBODE_CELL_REQ_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell request count register for GE3 
 * SIZE:     32
 * FIELDS:
 *     REQ_CNT          Number of cell request made to Egress Pipeline, MAX is 4 in FB mode. In Felix mode, MAX is 8.
 *
 ******************************************************************************/
#define BCM56218_A0_GE3_GBODE_CELL_REQ_CNTr 0x0008001f

#define BCM56218_A0_GE3_GBODE_CELL_REQ_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE3_GBODE_CELL_REQ_CNT.
 *
 */
typedef union BCM56218_A0_GE3_GBODE_CELL_REQ_CNTr_s {
	uint32_t v[1];
	uint32_t ge3_gbode_cell_req_cnt[1];
	uint32_t _ge3_gbode_cell_req_cnt;
} BCM56218_A0_GE3_GBODE_CELL_REQ_CNTr_t;

#define BCM56218_A0_GE3_GBODE_CELL_REQ_CNTr_CLR(r) (r).ge3_gbode_cell_req_cnt[0] = 0
#define BCM56218_A0_GE3_GBODE_CELL_REQ_CNTr_SET(r,d) (r).ge3_gbode_cell_req_cnt[0] = d
#define BCM56218_A0_GE3_GBODE_CELL_REQ_CNTr_GET(r) (r).ge3_gbode_cell_req_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_GE3_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET(r) (((r).ge3_gbode_cell_req_cnt[0]) & 0xf)
#define BCM56218_A0_GE3_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET(r,f) (r).ge3_gbode_cell_req_cnt[0]=(((r).ge3_gbode_cell_req_cnt[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access GE3_GBODE_CELL_REQ_CNT.
 *
 */
#define BCM56218_A0_READ_GE3_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE3_GBODE_CELL_REQ_CNTr,(r._ge3_gbode_cell_req_cnt))
#define BCM56218_A0_WRITE_GE3_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE3_GBODE_CELL_REQ_CNTr,&(r._ge3_gbode_cell_req_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE3_GBODE_CELL_REQ_CNTr BCM56218_A0_GE3_GBODE_CELL_REQ_CNTr
#define GE3_GBODE_CELL_REQ_CNTr_SIZE BCM56218_A0_GE3_GBODE_CELL_REQ_CNTr_SIZE
typedef BCM56218_A0_GE3_GBODE_CELL_REQ_CNTr_t GE3_GBODE_CELL_REQ_CNTr_t;
#define GE3_GBODE_CELL_REQ_CNTr_CLR BCM56218_A0_GE3_GBODE_CELL_REQ_CNTr_CLR
#define GE3_GBODE_CELL_REQ_CNTr_SET BCM56218_A0_GE3_GBODE_CELL_REQ_CNTr_SET
#define GE3_GBODE_CELL_REQ_CNTr_GET BCM56218_A0_GE3_GBODE_CELL_REQ_CNTr_GET
#define GE3_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET BCM56218_A0_GE3_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET
#define GE3_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET BCM56218_A0_GE3_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET
#define READ_GE3_GBODE_CELL_REQ_CNTr BCM56218_A0_READ_GE3_GBODE_CELL_REQ_CNTr
#define WRITE_GE3_GBODE_CELL_REQ_CNTr BCM56218_A0_WRITE_GE3_GBODE_CELL_REQ_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GE3_GBODE_CELL_REQ_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GE3_GBOD_OVRFLW
 * BLOCKS:   GPORT0
 * DESC:     GBOD RX fifo overflow for GE3 
 * SIZE:     32
 * FIELDS:
 *     OVRFLW           GBOD RX fifo overflow flag.
 *
 ******************************************************************************/
#define BCM56218_A0_GE3_GBOD_OVRFLWr 0x00080007

#define BCM56218_A0_GE3_GBOD_OVRFLWr_SIZE 4

/*
 * This structure should be used to declare and program GE3_GBOD_OVRFLW.
 *
 */
typedef union BCM56218_A0_GE3_GBOD_OVRFLWr_s {
	uint32_t v[1];
	uint32_t ge3_gbod_ovrflw[1];
	uint32_t _ge3_gbod_ovrflw;
} BCM56218_A0_GE3_GBOD_OVRFLWr_t;

#define BCM56218_A0_GE3_GBOD_OVRFLWr_CLR(r) (r).ge3_gbod_ovrflw[0] = 0
#define BCM56218_A0_GE3_GBOD_OVRFLWr_SET(r,d) (r).ge3_gbod_ovrflw[0] = d
#define BCM56218_A0_GE3_GBOD_OVRFLWr_GET(r) (r).ge3_gbod_ovrflw[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_GE3_GBOD_OVRFLWr_OVRFLWf_GET(r) (((r).ge3_gbod_ovrflw[0]) & 0x1)
#define BCM56218_A0_GE3_GBOD_OVRFLWr_OVRFLWf_SET(r,f) (r).ge3_gbod_ovrflw[0]=(((r).ge3_gbod_ovrflw[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access GE3_GBOD_OVRFLW.
 *
 */
#define BCM56218_A0_READ_GE3_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE3_GBOD_OVRFLWr,(r._ge3_gbod_ovrflw))
#define BCM56218_A0_WRITE_GE3_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE3_GBOD_OVRFLWr,&(r._ge3_gbod_ovrflw))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE3_GBOD_OVRFLWr BCM56218_A0_GE3_GBOD_OVRFLWr
#define GE3_GBOD_OVRFLWr_SIZE BCM56218_A0_GE3_GBOD_OVRFLWr_SIZE
typedef BCM56218_A0_GE3_GBOD_OVRFLWr_t GE3_GBOD_OVRFLWr_t;
#define GE3_GBOD_OVRFLWr_CLR BCM56218_A0_GE3_GBOD_OVRFLWr_CLR
#define GE3_GBOD_OVRFLWr_SET BCM56218_A0_GE3_GBOD_OVRFLWr_SET
#define GE3_GBOD_OVRFLWr_GET BCM56218_A0_GE3_GBOD_OVRFLWr_GET
#define GE3_GBOD_OVRFLWr_OVRFLWf_GET BCM56218_A0_GE3_GBOD_OVRFLWr_OVRFLWf_GET
#define GE3_GBOD_OVRFLWr_OVRFLWf_SET BCM56218_A0_GE3_GBOD_OVRFLWr_OVRFLWf_SET
#define READ_GE3_GBOD_OVRFLWr BCM56218_A0_READ_GE3_GBOD_OVRFLWr
#define WRITE_GE3_GBOD_OVRFLWr BCM56218_A0_WRITE_GE3_GBOD_OVRFLWr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GE3_GBOD_OVRFLWr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GE4_GBODE_CELL_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell count register for GE4 
 * SIZE:     32
 * FIELDS:
 *     CELL_CNT         Number of cell counts in GBODE tx fifo.
 *
 ******************************************************************************/
#define BCM56218_A0_GE4_GBODE_CELL_CNTr 0x00080014

#define BCM56218_A0_GE4_GBODE_CELL_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE4_GBODE_CELL_CNT.
 *
 */
typedef union BCM56218_A0_GE4_GBODE_CELL_CNTr_s {
	uint32_t v[1];
	uint32_t ge4_gbode_cell_cnt[1];
	uint32_t _ge4_gbode_cell_cnt;
} BCM56218_A0_GE4_GBODE_CELL_CNTr_t;

#define BCM56218_A0_GE4_GBODE_CELL_CNTr_CLR(r) (r).ge4_gbode_cell_cnt[0] = 0
#define BCM56218_A0_GE4_GBODE_CELL_CNTr_SET(r,d) (r).ge4_gbode_cell_cnt[0] = d
#define BCM56218_A0_GE4_GBODE_CELL_CNTr_GET(r) (r).ge4_gbode_cell_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_GE4_GBODE_CELL_CNTr_CELL_CNTf_GET(r) (((r).ge4_gbode_cell_cnt[0]) & 0xf)
#define BCM56218_A0_GE4_GBODE_CELL_CNTr_CELL_CNTf_SET(r,f) (r).ge4_gbode_cell_cnt[0]=(((r).ge4_gbode_cell_cnt[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access GE4_GBODE_CELL_CNT.
 *
 */
#define BCM56218_A0_READ_GE4_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE4_GBODE_CELL_CNTr,(r._ge4_gbode_cell_cnt))
#define BCM56218_A0_WRITE_GE4_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE4_GBODE_CELL_CNTr,&(r._ge4_gbode_cell_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE4_GBODE_CELL_CNTr BCM56218_A0_GE4_GBODE_CELL_CNTr
#define GE4_GBODE_CELL_CNTr_SIZE BCM56218_A0_GE4_GBODE_CELL_CNTr_SIZE
typedef BCM56218_A0_GE4_GBODE_CELL_CNTr_t GE4_GBODE_CELL_CNTr_t;
#define GE4_GBODE_CELL_CNTr_CLR BCM56218_A0_GE4_GBODE_CELL_CNTr_CLR
#define GE4_GBODE_CELL_CNTr_SET BCM56218_A0_GE4_GBODE_CELL_CNTr_SET
#define GE4_GBODE_CELL_CNTr_GET BCM56218_A0_GE4_GBODE_CELL_CNTr_GET
#define GE4_GBODE_CELL_CNTr_CELL_CNTf_GET BCM56218_A0_GE4_GBODE_CELL_CNTr_CELL_CNTf_GET
#define GE4_GBODE_CELL_CNTr_CELL_CNTf_SET BCM56218_A0_GE4_GBODE_CELL_CNTr_CELL_CNTf_SET
#define READ_GE4_GBODE_CELL_CNTr BCM56218_A0_READ_GE4_GBODE_CELL_CNTr
#define WRITE_GE4_GBODE_CELL_CNTr BCM56218_A0_WRITE_GE4_GBODE_CELL_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GE4_GBODE_CELL_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GE4_GBODE_CELL_REQ_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell request count register for GE4 
 * SIZE:     32
 * FIELDS:
 *     REQ_CNT          Number of cell request made to Egress Pipeline, MAX is 4 in FB mode. In Felix mode, MAX is 8.
 *
 ******************************************************************************/
#define BCM56218_A0_GE4_GBODE_CELL_REQ_CNTr 0x00080020

#define BCM56218_A0_GE4_GBODE_CELL_REQ_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE4_GBODE_CELL_REQ_CNT.
 *
 */
typedef union BCM56218_A0_GE4_GBODE_CELL_REQ_CNTr_s {
	uint32_t v[1];
	uint32_t ge4_gbode_cell_req_cnt[1];
	uint32_t _ge4_gbode_cell_req_cnt;
} BCM56218_A0_GE4_GBODE_CELL_REQ_CNTr_t;

#define BCM56218_A0_GE4_GBODE_CELL_REQ_CNTr_CLR(r) (r).ge4_gbode_cell_req_cnt[0] = 0
#define BCM56218_A0_GE4_GBODE_CELL_REQ_CNTr_SET(r,d) (r).ge4_gbode_cell_req_cnt[0] = d
#define BCM56218_A0_GE4_GBODE_CELL_REQ_CNTr_GET(r) (r).ge4_gbode_cell_req_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_GE4_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET(r) (((r).ge4_gbode_cell_req_cnt[0]) & 0xf)
#define BCM56218_A0_GE4_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET(r,f) (r).ge4_gbode_cell_req_cnt[0]=(((r).ge4_gbode_cell_req_cnt[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access GE4_GBODE_CELL_REQ_CNT.
 *
 */
#define BCM56218_A0_READ_GE4_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE4_GBODE_CELL_REQ_CNTr,(r._ge4_gbode_cell_req_cnt))
#define BCM56218_A0_WRITE_GE4_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE4_GBODE_CELL_REQ_CNTr,&(r._ge4_gbode_cell_req_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE4_GBODE_CELL_REQ_CNTr BCM56218_A0_GE4_GBODE_CELL_REQ_CNTr
#define GE4_GBODE_CELL_REQ_CNTr_SIZE BCM56218_A0_GE4_GBODE_CELL_REQ_CNTr_SIZE
typedef BCM56218_A0_GE4_GBODE_CELL_REQ_CNTr_t GE4_GBODE_CELL_REQ_CNTr_t;
#define GE4_GBODE_CELL_REQ_CNTr_CLR BCM56218_A0_GE4_GBODE_CELL_REQ_CNTr_CLR
#define GE4_GBODE_CELL_REQ_CNTr_SET BCM56218_A0_GE4_GBODE_CELL_REQ_CNTr_SET
#define GE4_GBODE_CELL_REQ_CNTr_GET BCM56218_A0_GE4_GBODE_CELL_REQ_CNTr_GET
#define GE4_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET BCM56218_A0_GE4_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET
#define GE4_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET BCM56218_A0_GE4_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET
#define READ_GE4_GBODE_CELL_REQ_CNTr BCM56218_A0_READ_GE4_GBODE_CELL_REQ_CNTr
#define WRITE_GE4_GBODE_CELL_REQ_CNTr BCM56218_A0_WRITE_GE4_GBODE_CELL_REQ_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GE4_GBODE_CELL_REQ_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GE4_GBOD_OVRFLW
 * BLOCKS:   GPORT0
 * DESC:     GBOD RX fifo overflow for GE4 
 * SIZE:     32
 * FIELDS:
 *     OVRFLW           GBOD RX fifo overflow flag.
 *
 ******************************************************************************/
#define BCM56218_A0_GE4_GBOD_OVRFLWr 0x00080008

#define BCM56218_A0_GE4_GBOD_OVRFLWr_SIZE 4

/*
 * This structure should be used to declare and program GE4_GBOD_OVRFLW.
 *
 */
typedef union BCM56218_A0_GE4_GBOD_OVRFLWr_s {
	uint32_t v[1];
	uint32_t ge4_gbod_ovrflw[1];
	uint32_t _ge4_gbod_ovrflw;
} BCM56218_A0_GE4_GBOD_OVRFLWr_t;

#define BCM56218_A0_GE4_GBOD_OVRFLWr_CLR(r) (r).ge4_gbod_ovrflw[0] = 0
#define BCM56218_A0_GE4_GBOD_OVRFLWr_SET(r,d) (r).ge4_gbod_ovrflw[0] = d
#define BCM56218_A0_GE4_GBOD_OVRFLWr_GET(r) (r).ge4_gbod_ovrflw[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_GE4_GBOD_OVRFLWr_OVRFLWf_GET(r) (((r).ge4_gbod_ovrflw[0]) & 0x1)
#define BCM56218_A0_GE4_GBOD_OVRFLWr_OVRFLWf_SET(r,f) (r).ge4_gbod_ovrflw[0]=(((r).ge4_gbod_ovrflw[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access GE4_GBOD_OVRFLW.
 *
 */
#define BCM56218_A0_READ_GE4_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE4_GBOD_OVRFLWr,(r._ge4_gbod_ovrflw))
#define BCM56218_A0_WRITE_GE4_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE4_GBOD_OVRFLWr,&(r._ge4_gbod_ovrflw))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE4_GBOD_OVRFLWr BCM56218_A0_GE4_GBOD_OVRFLWr
#define GE4_GBOD_OVRFLWr_SIZE BCM56218_A0_GE4_GBOD_OVRFLWr_SIZE
typedef BCM56218_A0_GE4_GBOD_OVRFLWr_t GE4_GBOD_OVRFLWr_t;
#define GE4_GBOD_OVRFLWr_CLR BCM56218_A0_GE4_GBOD_OVRFLWr_CLR
#define GE4_GBOD_OVRFLWr_SET BCM56218_A0_GE4_GBOD_OVRFLWr_SET
#define GE4_GBOD_OVRFLWr_GET BCM56218_A0_GE4_GBOD_OVRFLWr_GET
#define GE4_GBOD_OVRFLWr_OVRFLWf_GET BCM56218_A0_GE4_GBOD_OVRFLWr_OVRFLWf_GET
#define GE4_GBOD_OVRFLWr_OVRFLWf_SET BCM56218_A0_GE4_GBOD_OVRFLWr_OVRFLWf_SET
#define READ_GE4_GBOD_OVRFLWr BCM56218_A0_READ_GE4_GBOD_OVRFLWr
#define WRITE_GE4_GBOD_OVRFLWr BCM56218_A0_WRITE_GE4_GBOD_OVRFLWr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GE4_GBOD_OVRFLWr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GE5_GBODE_CELL_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell count register for GE5 
 * SIZE:     32
 * FIELDS:
 *     CELL_CNT         Number of cell counts in GBODE tx fifo.
 *
 ******************************************************************************/
#define BCM56218_A0_GE5_GBODE_CELL_CNTr 0x00080015

#define BCM56218_A0_GE5_GBODE_CELL_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE5_GBODE_CELL_CNT.
 *
 */
typedef union BCM56218_A0_GE5_GBODE_CELL_CNTr_s {
	uint32_t v[1];
	uint32_t ge5_gbode_cell_cnt[1];
	uint32_t _ge5_gbode_cell_cnt;
} BCM56218_A0_GE5_GBODE_CELL_CNTr_t;

#define BCM56218_A0_GE5_GBODE_CELL_CNTr_CLR(r) (r).ge5_gbode_cell_cnt[0] = 0
#define BCM56218_A0_GE5_GBODE_CELL_CNTr_SET(r,d) (r).ge5_gbode_cell_cnt[0] = d
#define BCM56218_A0_GE5_GBODE_CELL_CNTr_GET(r) (r).ge5_gbode_cell_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_GE5_GBODE_CELL_CNTr_CELL_CNTf_GET(r) (((r).ge5_gbode_cell_cnt[0]) & 0xf)
#define BCM56218_A0_GE5_GBODE_CELL_CNTr_CELL_CNTf_SET(r,f) (r).ge5_gbode_cell_cnt[0]=(((r).ge5_gbode_cell_cnt[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access GE5_GBODE_CELL_CNT.
 *
 */
#define BCM56218_A0_READ_GE5_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE5_GBODE_CELL_CNTr,(r._ge5_gbode_cell_cnt))
#define BCM56218_A0_WRITE_GE5_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE5_GBODE_CELL_CNTr,&(r._ge5_gbode_cell_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE5_GBODE_CELL_CNTr BCM56218_A0_GE5_GBODE_CELL_CNTr
#define GE5_GBODE_CELL_CNTr_SIZE BCM56218_A0_GE5_GBODE_CELL_CNTr_SIZE
typedef BCM56218_A0_GE5_GBODE_CELL_CNTr_t GE5_GBODE_CELL_CNTr_t;
#define GE5_GBODE_CELL_CNTr_CLR BCM56218_A0_GE5_GBODE_CELL_CNTr_CLR
#define GE5_GBODE_CELL_CNTr_SET BCM56218_A0_GE5_GBODE_CELL_CNTr_SET
#define GE5_GBODE_CELL_CNTr_GET BCM56218_A0_GE5_GBODE_CELL_CNTr_GET
#define GE5_GBODE_CELL_CNTr_CELL_CNTf_GET BCM56218_A0_GE5_GBODE_CELL_CNTr_CELL_CNTf_GET
#define GE5_GBODE_CELL_CNTr_CELL_CNTf_SET BCM56218_A0_GE5_GBODE_CELL_CNTr_CELL_CNTf_SET
#define READ_GE5_GBODE_CELL_CNTr BCM56218_A0_READ_GE5_GBODE_CELL_CNTr
#define WRITE_GE5_GBODE_CELL_CNTr BCM56218_A0_WRITE_GE5_GBODE_CELL_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GE5_GBODE_CELL_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GE5_GBODE_CELL_REQ_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell request count register for GE5 
 * SIZE:     32
 * FIELDS:
 *     REQ_CNT          Number of cell request made to Egress Pipeline, MAX is 4 in FB mode. In Felix mode, MAX is 8.
 *
 ******************************************************************************/
#define BCM56218_A0_GE5_GBODE_CELL_REQ_CNTr 0x00080021

#define BCM56218_A0_GE5_GBODE_CELL_REQ_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE5_GBODE_CELL_REQ_CNT.
 *
 */
typedef union BCM56218_A0_GE5_GBODE_CELL_REQ_CNTr_s {
	uint32_t v[1];
	uint32_t ge5_gbode_cell_req_cnt[1];
	uint32_t _ge5_gbode_cell_req_cnt;
} BCM56218_A0_GE5_GBODE_CELL_REQ_CNTr_t;

#define BCM56218_A0_GE5_GBODE_CELL_REQ_CNTr_CLR(r) (r).ge5_gbode_cell_req_cnt[0] = 0
#define BCM56218_A0_GE5_GBODE_CELL_REQ_CNTr_SET(r,d) (r).ge5_gbode_cell_req_cnt[0] = d
#define BCM56218_A0_GE5_GBODE_CELL_REQ_CNTr_GET(r) (r).ge5_gbode_cell_req_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_GE5_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET(r) (((r).ge5_gbode_cell_req_cnt[0]) & 0xf)
#define BCM56218_A0_GE5_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET(r,f) (r).ge5_gbode_cell_req_cnt[0]=(((r).ge5_gbode_cell_req_cnt[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access GE5_GBODE_CELL_REQ_CNT.
 *
 */
#define BCM56218_A0_READ_GE5_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE5_GBODE_CELL_REQ_CNTr,(r._ge5_gbode_cell_req_cnt))
#define BCM56218_A0_WRITE_GE5_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE5_GBODE_CELL_REQ_CNTr,&(r._ge5_gbode_cell_req_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE5_GBODE_CELL_REQ_CNTr BCM56218_A0_GE5_GBODE_CELL_REQ_CNTr
#define GE5_GBODE_CELL_REQ_CNTr_SIZE BCM56218_A0_GE5_GBODE_CELL_REQ_CNTr_SIZE
typedef BCM56218_A0_GE5_GBODE_CELL_REQ_CNTr_t GE5_GBODE_CELL_REQ_CNTr_t;
#define GE5_GBODE_CELL_REQ_CNTr_CLR BCM56218_A0_GE5_GBODE_CELL_REQ_CNTr_CLR
#define GE5_GBODE_CELL_REQ_CNTr_SET BCM56218_A0_GE5_GBODE_CELL_REQ_CNTr_SET
#define GE5_GBODE_CELL_REQ_CNTr_GET BCM56218_A0_GE5_GBODE_CELL_REQ_CNTr_GET
#define GE5_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET BCM56218_A0_GE5_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET
#define GE5_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET BCM56218_A0_GE5_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET
#define READ_GE5_GBODE_CELL_REQ_CNTr BCM56218_A0_READ_GE5_GBODE_CELL_REQ_CNTr
#define WRITE_GE5_GBODE_CELL_REQ_CNTr BCM56218_A0_WRITE_GE5_GBODE_CELL_REQ_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GE5_GBODE_CELL_REQ_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GE5_GBOD_OVRFLW
 * BLOCKS:   GPORT0
 * DESC:     GBOD RX fifo overflow for GE5 
 * SIZE:     32
 * FIELDS:
 *     OVRFLW           GBOD RX fifo overflow flag.
 *
 ******************************************************************************/
#define BCM56218_A0_GE5_GBOD_OVRFLWr 0x00080009

#define BCM56218_A0_GE5_GBOD_OVRFLWr_SIZE 4

/*
 * This structure should be used to declare and program GE5_GBOD_OVRFLW.
 *
 */
typedef union BCM56218_A0_GE5_GBOD_OVRFLWr_s {
	uint32_t v[1];
	uint32_t ge5_gbod_ovrflw[1];
	uint32_t _ge5_gbod_ovrflw;
} BCM56218_A0_GE5_GBOD_OVRFLWr_t;

#define BCM56218_A0_GE5_GBOD_OVRFLWr_CLR(r) (r).ge5_gbod_ovrflw[0] = 0
#define BCM56218_A0_GE5_GBOD_OVRFLWr_SET(r,d) (r).ge5_gbod_ovrflw[0] = d
#define BCM56218_A0_GE5_GBOD_OVRFLWr_GET(r) (r).ge5_gbod_ovrflw[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_GE5_GBOD_OVRFLWr_OVRFLWf_GET(r) (((r).ge5_gbod_ovrflw[0]) & 0x1)
#define BCM56218_A0_GE5_GBOD_OVRFLWr_OVRFLWf_SET(r,f) (r).ge5_gbod_ovrflw[0]=(((r).ge5_gbod_ovrflw[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access GE5_GBOD_OVRFLW.
 *
 */
#define BCM56218_A0_READ_GE5_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE5_GBOD_OVRFLWr,(r._ge5_gbod_ovrflw))
#define BCM56218_A0_WRITE_GE5_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE5_GBOD_OVRFLWr,&(r._ge5_gbod_ovrflw))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE5_GBOD_OVRFLWr BCM56218_A0_GE5_GBOD_OVRFLWr
#define GE5_GBOD_OVRFLWr_SIZE BCM56218_A0_GE5_GBOD_OVRFLWr_SIZE
typedef BCM56218_A0_GE5_GBOD_OVRFLWr_t GE5_GBOD_OVRFLWr_t;
#define GE5_GBOD_OVRFLWr_CLR BCM56218_A0_GE5_GBOD_OVRFLWr_CLR
#define GE5_GBOD_OVRFLWr_SET BCM56218_A0_GE5_GBOD_OVRFLWr_SET
#define GE5_GBOD_OVRFLWr_GET BCM56218_A0_GE5_GBOD_OVRFLWr_GET
#define GE5_GBOD_OVRFLWr_OVRFLWf_GET BCM56218_A0_GE5_GBOD_OVRFLWr_OVRFLWf_GET
#define GE5_GBOD_OVRFLWr_OVRFLWf_SET BCM56218_A0_GE5_GBOD_OVRFLWr_OVRFLWf_SET
#define READ_GE5_GBOD_OVRFLWr BCM56218_A0_READ_GE5_GBOD_OVRFLWr
#define WRITE_GE5_GBOD_OVRFLWr BCM56218_A0_WRITE_GE5_GBOD_OVRFLWr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GE5_GBOD_OVRFLWr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GE6_GBODE_CELL_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell count register for GE6 
 * SIZE:     32
 * FIELDS:
 *     CELL_CNT         Number of cell counts in GBODE tx fifo.
 *
 ******************************************************************************/
#define BCM56218_A0_GE6_GBODE_CELL_CNTr 0x00080016

#define BCM56218_A0_GE6_GBODE_CELL_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE6_GBODE_CELL_CNT.
 *
 */
typedef union BCM56218_A0_GE6_GBODE_CELL_CNTr_s {
	uint32_t v[1];
	uint32_t ge6_gbode_cell_cnt[1];
	uint32_t _ge6_gbode_cell_cnt;
} BCM56218_A0_GE6_GBODE_CELL_CNTr_t;

#define BCM56218_A0_GE6_GBODE_CELL_CNTr_CLR(r) (r).ge6_gbode_cell_cnt[0] = 0
#define BCM56218_A0_GE6_GBODE_CELL_CNTr_SET(r,d) (r).ge6_gbode_cell_cnt[0] = d
#define BCM56218_A0_GE6_GBODE_CELL_CNTr_GET(r) (r).ge6_gbode_cell_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_GE6_GBODE_CELL_CNTr_CELL_CNTf_GET(r) (((r).ge6_gbode_cell_cnt[0]) & 0xf)
#define BCM56218_A0_GE6_GBODE_CELL_CNTr_CELL_CNTf_SET(r,f) (r).ge6_gbode_cell_cnt[0]=(((r).ge6_gbode_cell_cnt[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access GE6_GBODE_CELL_CNT.
 *
 */
#define BCM56218_A0_READ_GE6_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE6_GBODE_CELL_CNTr,(r._ge6_gbode_cell_cnt))
#define BCM56218_A0_WRITE_GE6_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE6_GBODE_CELL_CNTr,&(r._ge6_gbode_cell_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE6_GBODE_CELL_CNTr BCM56218_A0_GE6_GBODE_CELL_CNTr
#define GE6_GBODE_CELL_CNTr_SIZE BCM56218_A0_GE6_GBODE_CELL_CNTr_SIZE
typedef BCM56218_A0_GE6_GBODE_CELL_CNTr_t GE6_GBODE_CELL_CNTr_t;
#define GE6_GBODE_CELL_CNTr_CLR BCM56218_A0_GE6_GBODE_CELL_CNTr_CLR
#define GE6_GBODE_CELL_CNTr_SET BCM56218_A0_GE6_GBODE_CELL_CNTr_SET
#define GE6_GBODE_CELL_CNTr_GET BCM56218_A0_GE6_GBODE_CELL_CNTr_GET
#define GE6_GBODE_CELL_CNTr_CELL_CNTf_GET BCM56218_A0_GE6_GBODE_CELL_CNTr_CELL_CNTf_GET
#define GE6_GBODE_CELL_CNTr_CELL_CNTf_SET BCM56218_A0_GE6_GBODE_CELL_CNTr_CELL_CNTf_SET
#define READ_GE6_GBODE_CELL_CNTr BCM56218_A0_READ_GE6_GBODE_CELL_CNTr
#define WRITE_GE6_GBODE_CELL_CNTr BCM56218_A0_WRITE_GE6_GBODE_CELL_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GE6_GBODE_CELL_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GE6_GBODE_CELL_REQ_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell request count register for GE6 
 * SIZE:     32
 * FIELDS:
 *     REQ_CNT          Number of cell request made to Egress Pipeline, MAX is 4 in FB mode. In Felix mode, MAX is 8.
 *
 ******************************************************************************/
#define BCM56218_A0_GE6_GBODE_CELL_REQ_CNTr 0x00080022

#define BCM56218_A0_GE6_GBODE_CELL_REQ_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE6_GBODE_CELL_REQ_CNT.
 *
 */
typedef union BCM56218_A0_GE6_GBODE_CELL_REQ_CNTr_s {
	uint32_t v[1];
	uint32_t ge6_gbode_cell_req_cnt[1];
	uint32_t _ge6_gbode_cell_req_cnt;
} BCM56218_A0_GE6_GBODE_CELL_REQ_CNTr_t;

#define BCM56218_A0_GE6_GBODE_CELL_REQ_CNTr_CLR(r) (r).ge6_gbode_cell_req_cnt[0] = 0
#define BCM56218_A0_GE6_GBODE_CELL_REQ_CNTr_SET(r,d) (r).ge6_gbode_cell_req_cnt[0] = d
#define BCM56218_A0_GE6_GBODE_CELL_REQ_CNTr_GET(r) (r).ge6_gbode_cell_req_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_GE6_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET(r) (((r).ge6_gbode_cell_req_cnt[0]) & 0xf)
#define BCM56218_A0_GE6_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET(r,f) (r).ge6_gbode_cell_req_cnt[0]=(((r).ge6_gbode_cell_req_cnt[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access GE6_GBODE_CELL_REQ_CNT.
 *
 */
#define BCM56218_A0_READ_GE6_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE6_GBODE_CELL_REQ_CNTr,(r._ge6_gbode_cell_req_cnt))
#define BCM56218_A0_WRITE_GE6_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE6_GBODE_CELL_REQ_CNTr,&(r._ge6_gbode_cell_req_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE6_GBODE_CELL_REQ_CNTr BCM56218_A0_GE6_GBODE_CELL_REQ_CNTr
#define GE6_GBODE_CELL_REQ_CNTr_SIZE BCM56218_A0_GE6_GBODE_CELL_REQ_CNTr_SIZE
typedef BCM56218_A0_GE6_GBODE_CELL_REQ_CNTr_t GE6_GBODE_CELL_REQ_CNTr_t;
#define GE6_GBODE_CELL_REQ_CNTr_CLR BCM56218_A0_GE6_GBODE_CELL_REQ_CNTr_CLR
#define GE6_GBODE_CELL_REQ_CNTr_SET BCM56218_A0_GE6_GBODE_CELL_REQ_CNTr_SET
#define GE6_GBODE_CELL_REQ_CNTr_GET BCM56218_A0_GE6_GBODE_CELL_REQ_CNTr_GET
#define GE6_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET BCM56218_A0_GE6_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET
#define GE6_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET BCM56218_A0_GE6_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET
#define READ_GE6_GBODE_CELL_REQ_CNTr BCM56218_A0_READ_GE6_GBODE_CELL_REQ_CNTr
#define WRITE_GE6_GBODE_CELL_REQ_CNTr BCM56218_A0_WRITE_GE6_GBODE_CELL_REQ_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GE6_GBODE_CELL_REQ_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GE6_GBOD_OVRFLW
 * BLOCKS:   GPORT0
 * DESC:     GBOD RX fifo overflow for GE6 
 * SIZE:     32
 * FIELDS:
 *     OVRFLW           GBOD RX fifo overflow flag.
 *
 ******************************************************************************/
#define BCM56218_A0_GE6_GBOD_OVRFLWr 0x0008000a

#define BCM56218_A0_GE6_GBOD_OVRFLWr_SIZE 4

/*
 * This structure should be used to declare and program GE6_GBOD_OVRFLW.
 *
 */
typedef union BCM56218_A0_GE6_GBOD_OVRFLWr_s {
	uint32_t v[1];
	uint32_t ge6_gbod_ovrflw[1];
	uint32_t _ge6_gbod_ovrflw;
} BCM56218_A0_GE6_GBOD_OVRFLWr_t;

#define BCM56218_A0_GE6_GBOD_OVRFLWr_CLR(r) (r).ge6_gbod_ovrflw[0] = 0
#define BCM56218_A0_GE6_GBOD_OVRFLWr_SET(r,d) (r).ge6_gbod_ovrflw[0] = d
#define BCM56218_A0_GE6_GBOD_OVRFLWr_GET(r) (r).ge6_gbod_ovrflw[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_GE6_GBOD_OVRFLWr_OVRFLWf_GET(r) (((r).ge6_gbod_ovrflw[0]) & 0x1)
#define BCM56218_A0_GE6_GBOD_OVRFLWr_OVRFLWf_SET(r,f) (r).ge6_gbod_ovrflw[0]=(((r).ge6_gbod_ovrflw[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access GE6_GBOD_OVRFLW.
 *
 */
#define BCM56218_A0_READ_GE6_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE6_GBOD_OVRFLWr,(r._ge6_gbod_ovrflw))
#define BCM56218_A0_WRITE_GE6_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE6_GBOD_OVRFLWr,&(r._ge6_gbod_ovrflw))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE6_GBOD_OVRFLWr BCM56218_A0_GE6_GBOD_OVRFLWr
#define GE6_GBOD_OVRFLWr_SIZE BCM56218_A0_GE6_GBOD_OVRFLWr_SIZE
typedef BCM56218_A0_GE6_GBOD_OVRFLWr_t GE6_GBOD_OVRFLWr_t;
#define GE6_GBOD_OVRFLWr_CLR BCM56218_A0_GE6_GBOD_OVRFLWr_CLR
#define GE6_GBOD_OVRFLWr_SET BCM56218_A0_GE6_GBOD_OVRFLWr_SET
#define GE6_GBOD_OVRFLWr_GET BCM56218_A0_GE6_GBOD_OVRFLWr_GET
#define GE6_GBOD_OVRFLWr_OVRFLWf_GET BCM56218_A0_GE6_GBOD_OVRFLWr_OVRFLWf_GET
#define GE6_GBOD_OVRFLWr_OVRFLWf_SET BCM56218_A0_GE6_GBOD_OVRFLWr_OVRFLWf_SET
#define READ_GE6_GBOD_OVRFLWr BCM56218_A0_READ_GE6_GBOD_OVRFLWr
#define WRITE_GE6_GBOD_OVRFLWr BCM56218_A0_WRITE_GE6_GBOD_OVRFLWr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GE6_GBOD_OVRFLWr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GE7_GBODE_CELL_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell count register for GE7 
 * SIZE:     32
 * FIELDS:
 *     CELL_CNT         Number of cell counts in GBODE tx fifo.
 *
 ******************************************************************************/
#define BCM56218_A0_GE7_GBODE_CELL_CNTr 0x00080017

#define BCM56218_A0_GE7_GBODE_CELL_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE7_GBODE_CELL_CNT.
 *
 */
typedef union BCM56218_A0_GE7_GBODE_CELL_CNTr_s {
	uint32_t v[1];
	uint32_t ge7_gbode_cell_cnt[1];
	uint32_t _ge7_gbode_cell_cnt;
} BCM56218_A0_GE7_GBODE_CELL_CNTr_t;

#define BCM56218_A0_GE7_GBODE_CELL_CNTr_CLR(r) (r).ge7_gbode_cell_cnt[0] = 0
#define BCM56218_A0_GE7_GBODE_CELL_CNTr_SET(r,d) (r).ge7_gbode_cell_cnt[0] = d
#define BCM56218_A0_GE7_GBODE_CELL_CNTr_GET(r) (r).ge7_gbode_cell_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_GE7_GBODE_CELL_CNTr_CELL_CNTf_GET(r) (((r).ge7_gbode_cell_cnt[0]) & 0xf)
#define BCM56218_A0_GE7_GBODE_CELL_CNTr_CELL_CNTf_SET(r,f) (r).ge7_gbode_cell_cnt[0]=(((r).ge7_gbode_cell_cnt[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access GE7_GBODE_CELL_CNT.
 *
 */
#define BCM56218_A0_READ_GE7_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE7_GBODE_CELL_CNTr,(r._ge7_gbode_cell_cnt))
#define BCM56218_A0_WRITE_GE7_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE7_GBODE_CELL_CNTr,&(r._ge7_gbode_cell_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE7_GBODE_CELL_CNTr BCM56218_A0_GE7_GBODE_CELL_CNTr
#define GE7_GBODE_CELL_CNTr_SIZE BCM56218_A0_GE7_GBODE_CELL_CNTr_SIZE
typedef BCM56218_A0_GE7_GBODE_CELL_CNTr_t GE7_GBODE_CELL_CNTr_t;
#define GE7_GBODE_CELL_CNTr_CLR BCM56218_A0_GE7_GBODE_CELL_CNTr_CLR
#define GE7_GBODE_CELL_CNTr_SET BCM56218_A0_GE7_GBODE_CELL_CNTr_SET
#define GE7_GBODE_CELL_CNTr_GET BCM56218_A0_GE7_GBODE_CELL_CNTr_GET
#define GE7_GBODE_CELL_CNTr_CELL_CNTf_GET BCM56218_A0_GE7_GBODE_CELL_CNTr_CELL_CNTf_GET
#define GE7_GBODE_CELL_CNTr_CELL_CNTf_SET BCM56218_A0_GE7_GBODE_CELL_CNTr_CELL_CNTf_SET
#define READ_GE7_GBODE_CELL_CNTr BCM56218_A0_READ_GE7_GBODE_CELL_CNTr
#define WRITE_GE7_GBODE_CELL_CNTr BCM56218_A0_WRITE_GE7_GBODE_CELL_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GE7_GBODE_CELL_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GE7_GBODE_CELL_REQ_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell request count register for GE7 
 * SIZE:     32
 * FIELDS:
 *     REQ_CNT          Number of cell request made to Egress Pipeline, MAX is 4 in FB mode. In Felix mode, MAX is 8.
 *
 ******************************************************************************/
#define BCM56218_A0_GE7_GBODE_CELL_REQ_CNTr 0x00080023

#define BCM56218_A0_GE7_GBODE_CELL_REQ_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE7_GBODE_CELL_REQ_CNT.
 *
 */
typedef union BCM56218_A0_GE7_GBODE_CELL_REQ_CNTr_s {
	uint32_t v[1];
	uint32_t ge7_gbode_cell_req_cnt[1];
	uint32_t _ge7_gbode_cell_req_cnt;
} BCM56218_A0_GE7_GBODE_CELL_REQ_CNTr_t;

#define BCM56218_A0_GE7_GBODE_CELL_REQ_CNTr_CLR(r) (r).ge7_gbode_cell_req_cnt[0] = 0
#define BCM56218_A0_GE7_GBODE_CELL_REQ_CNTr_SET(r,d) (r).ge7_gbode_cell_req_cnt[0] = d
#define BCM56218_A0_GE7_GBODE_CELL_REQ_CNTr_GET(r) (r).ge7_gbode_cell_req_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_GE7_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET(r) (((r).ge7_gbode_cell_req_cnt[0]) & 0xf)
#define BCM56218_A0_GE7_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET(r,f) (r).ge7_gbode_cell_req_cnt[0]=(((r).ge7_gbode_cell_req_cnt[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access GE7_GBODE_CELL_REQ_CNT.
 *
 */
#define BCM56218_A0_READ_GE7_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE7_GBODE_CELL_REQ_CNTr,(r._ge7_gbode_cell_req_cnt))
#define BCM56218_A0_WRITE_GE7_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE7_GBODE_CELL_REQ_CNTr,&(r._ge7_gbode_cell_req_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE7_GBODE_CELL_REQ_CNTr BCM56218_A0_GE7_GBODE_CELL_REQ_CNTr
#define GE7_GBODE_CELL_REQ_CNTr_SIZE BCM56218_A0_GE7_GBODE_CELL_REQ_CNTr_SIZE
typedef BCM56218_A0_GE7_GBODE_CELL_REQ_CNTr_t GE7_GBODE_CELL_REQ_CNTr_t;
#define GE7_GBODE_CELL_REQ_CNTr_CLR BCM56218_A0_GE7_GBODE_CELL_REQ_CNTr_CLR
#define GE7_GBODE_CELL_REQ_CNTr_SET BCM56218_A0_GE7_GBODE_CELL_REQ_CNTr_SET
#define GE7_GBODE_CELL_REQ_CNTr_GET BCM56218_A0_GE7_GBODE_CELL_REQ_CNTr_GET
#define GE7_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET BCM56218_A0_GE7_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET
#define GE7_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET BCM56218_A0_GE7_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET
#define READ_GE7_GBODE_CELL_REQ_CNTr BCM56218_A0_READ_GE7_GBODE_CELL_REQ_CNTr
#define WRITE_GE7_GBODE_CELL_REQ_CNTr BCM56218_A0_WRITE_GE7_GBODE_CELL_REQ_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GE7_GBODE_CELL_REQ_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GE7_GBOD_OVRFLW
 * BLOCKS:   GPORT0
 * DESC:     GBOD RX fifo overflow for GE7 
 * SIZE:     32
 * FIELDS:
 *     OVRFLW           GBOD RX fifo overflow flag.
 *
 ******************************************************************************/
#define BCM56218_A0_GE7_GBOD_OVRFLWr 0x0008000b

#define BCM56218_A0_GE7_GBOD_OVRFLWr_SIZE 4

/*
 * This structure should be used to declare and program GE7_GBOD_OVRFLW.
 *
 */
typedef union BCM56218_A0_GE7_GBOD_OVRFLWr_s {
	uint32_t v[1];
	uint32_t ge7_gbod_ovrflw[1];
	uint32_t _ge7_gbod_ovrflw;
} BCM56218_A0_GE7_GBOD_OVRFLWr_t;

#define BCM56218_A0_GE7_GBOD_OVRFLWr_CLR(r) (r).ge7_gbod_ovrflw[0] = 0
#define BCM56218_A0_GE7_GBOD_OVRFLWr_SET(r,d) (r).ge7_gbod_ovrflw[0] = d
#define BCM56218_A0_GE7_GBOD_OVRFLWr_GET(r) (r).ge7_gbod_ovrflw[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_GE7_GBOD_OVRFLWr_OVRFLWf_GET(r) (((r).ge7_gbod_ovrflw[0]) & 0x1)
#define BCM56218_A0_GE7_GBOD_OVRFLWr_OVRFLWf_SET(r,f) (r).ge7_gbod_ovrflw[0]=(((r).ge7_gbod_ovrflw[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access GE7_GBOD_OVRFLW.
 *
 */
#define BCM56218_A0_READ_GE7_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE7_GBOD_OVRFLWr,(r._ge7_gbod_ovrflw))
#define BCM56218_A0_WRITE_GE7_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE7_GBOD_OVRFLWr,&(r._ge7_gbod_ovrflw))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE7_GBOD_OVRFLWr BCM56218_A0_GE7_GBOD_OVRFLWr
#define GE7_GBOD_OVRFLWr_SIZE BCM56218_A0_GE7_GBOD_OVRFLWr_SIZE
typedef BCM56218_A0_GE7_GBOD_OVRFLWr_t GE7_GBOD_OVRFLWr_t;
#define GE7_GBOD_OVRFLWr_CLR BCM56218_A0_GE7_GBOD_OVRFLWr_CLR
#define GE7_GBOD_OVRFLWr_SET BCM56218_A0_GE7_GBOD_OVRFLWr_SET
#define GE7_GBOD_OVRFLWr_GET BCM56218_A0_GE7_GBOD_OVRFLWr_GET
#define GE7_GBOD_OVRFLWr_OVRFLWf_GET BCM56218_A0_GE7_GBOD_OVRFLWr_OVRFLWf_GET
#define GE7_GBOD_OVRFLWr_OVRFLWf_SET BCM56218_A0_GE7_GBOD_OVRFLWr_OVRFLWf_SET
#define READ_GE7_GBOD_OVRFLWr BCM56218_A0_READ_GE7_GBOD_OVRFLWr
#define WRITE_GE7_GBOD_OVRFLWr BCM56218_A0_WRITE_GE7_GBOD_OVRFLWr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GE7_GBOD_OVRFLWr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GE8_GBODE_CELL_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell count register for GE8 
 * SIZE:     32
 * FIELDS:
 *     CELL_CNT         Number of cell counts in GBODE tx fifo.
 *
 ******************************************************************************/
#define BCM56218_A0_GE8_GBODE_CELL_CNTr 0x00080018

#define BCM56218_A0_GE8_GBODE_CELL_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE8_GBODE_CELL_CNT.
 *
 */
typedef union BCM56218_A0_GE8_GBODE_CELL_CNTr_s {
	uint32_t v[1];
	uint32_t ge8_gbode_cell_cnt[1];
	uint32_t _ge8_gbode_cell_cnt;
} BCM56218_A0_GE8_GBODE_CELL_CNTr_t;

#define BCM56218_A0_GE8_GBODE_CELL_CNTr_CLR(r) (r).ge8_gbode_cell_cnt[0] = 0
#define BCM56218_A0_GE8_GBODE_CELL_CNTr_SET(r,d) (r).ge8_gbode_cell_cnt[0] = d
#define BCM56218_A0_GE8_GBODE_CELL_CNTr_GET(r) (r).ge8_gbode_cell_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_GE8_GBODE_CELL_CNTr_CELL_CNTf_GET(r) (((r).ge8_gbode_cell_cnt[0]) & 0xf)
#define BCM56218_A0_GE8_GBODE_CELL_CNTr_CELL_CNTf_SET(r,f) (r).ge8_gbode_cell_cnt[0]=(((r).ge8_gbode_cell_cnt[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access GE8_GBODE_CELL_CNT.
 *
 */
#define BCM56218_A0_READ_GE8_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE8_GBODE_CELL_CNTr,(r._ge8_gbode_cell_cnt))
#define BCM56218_A0_WRITE_GE8_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE8_GBODE_CELL_CNTr,&(r._ge8_gbode_cell_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE8_GBODE_CELL_CNTr BCM56218_A0_GE8_GBODE_CELL_CNTr
#define GE8_GBODE_CELL_CNTr_SIZE BCM56218_A0_GE8_GBODE_CELL_CNTr_SIZE
typedef BCM56218_A0_GE8_GBODE_CELL_CNTr_t GE8_GBODE_CELL_CNTr_t;
#define GE8_GBODE_CELL_CNTr_CLR BCM56218_A0_GE8_GBODE_CELL_CNTr_CLR
#define GE8_GBODE_CELL_CNTr_SET BCM56218_A0_GE8_GBODE_CELL_CNTr_SET
#define GE8_GBODE_CELL_CNTr_GET BCM56218_A0_GE8_GBODE_CELL_CNTr_GET
#define GE8_GBODE_CELL_CNTr_CELL_CNTf_GET BCM56218_A0_GE8_GBODE_CELL_CNTr_CELL_CNTf_GET
#define GE8_GBODE_CELL_CNTr_CELL_CNTf_SET BCM56218_A0_GE8_GBODE_CELL_CNTr_CELL_CNTf_SET
#define READ_GE8_GBODE_CELL_CNTr BCM56218_A0_READ_GE8_GBODE_CELL_CNTr
#define WRITE_GE8_GBODE_CELL_CNTr BCM56218_A0_WRITE_GE8_GBODE_CELL_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GE8_GBODE_CELL_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GE8_GBODE_CELL_REQ_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell request count register for GE8 
 * SIZE:     32
 * FIELDS:
 *     REQ_CNT          Number of cell request made to Egress Pipeline, MAX is 4 in FB mode. In Felix mode, MAX is 8.
 *
 ******************************************************************************/
#define BCM56218_A0_GE8_GBODE_CELL_REQ_CNTr 0x00080024

#define BCM56218_A0_GE8_GBODE_CELL_REQ_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE8_GBODE_CELL_REQ_CNT.
 *
 */
typedef union BCM56218_A0_GE8_GBODE_CELL_REQ_CNTr_s {
	uint32_t v[1];
	uint32_t ge8_gbode_cell_req_cnt[1];
	uint32_t _ge8_gbode_cell_req_cnt;
} BCM56218_A0_GE8_GBODE_CELL_REQ_CNTr_t;

#define BCM56218_A0_GE8_GBODE_CELL_REQ_CNTr_CLR(r) (r).ge8_gbode_cell_req_cnt[0] = 0
#define BCM56218_A0_GE8_GBODE_CELL_REQ_CNTr_SET(r,d) (r).ge8_gbode_cell_req_cnt[0] = d
#define BCM56218_A0_GE8_GBODE_CELL_REQ_CNTr_GET(r) (r).ge8_gbode_cell_req_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_GE8_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET(r) (((r).ge8_gbode_cell_req_cnt[0]) & 0xf)
#define BCM56218_A0_GE8_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET(r,f) (r).ge8_gbode_cell_req_cnt[0]=(((r).ge8_gbode_cell_req_cnt[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access GE8_GBODE_CELL_REQ_CNT.
 *
 */
#define BCM56218_A0_READ_GE8_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE8_GBODE_CELL_REQ_CNTr,(r._ge8_gbode_cell_req_cnt))
#define BCM56218_A0_WRITE_GE8_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE8_GBODE_CELL_REQ_CNTr,&(r._ge8_gbode_cell_req_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE8_GBODE_CELL_REQ_CNTr BCM56218_A0_GE8_GBODE_CELL_REQ_CNTr
#define GE8_GBODE_CELL_REQ_CNTr_SIZE BCM56218_A0_GE8_GBODE_CELL_REQ_CNTr_SIZE
typedef BCM56218_A0_GE8_GBODE_CELL_REQ_CNTr_t GE8_GBODE_CELL_REQ_CNTr_t;
#define GE8_GBODE_CELL_REQ_CNTr_CLR BCM56218_A0_GE8_GBODE_CELL_REQ_CNTr_CLR
#define GE8_GBODE_CELL_REQ_CNTr_SET BCM56218_A0_GE8_GBODE_CELL_REQ_CNTr_SET
#define GE8_GBODE_CELL_REQ_CNTr_GET BCM56218_A0_GE8_GBODE_CELL_REQ_CNTr_GET
#define GE8_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET BCM56218_A0_GE8_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET
#define GE8_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET BCM56218_A0_GE8_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET
#define READ_GE8_GBODE_CELL_REQ_CNTr BCM56218_A0_READ_GE8_GBODE_CELL_REQ_CNTr
#define WRITE_GE8_GBODE_CELL_REQ_CNTr BCM56218_A0_WRITE_GE8_GBODE_CELL_REQ_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GE8_GBODE_CELL_REQ_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GE8_GBOD_OVRFLW
 * BLOCKS:   GPORT0
 * DESC:     GBOD RX fifo overflow for GE8 
 * SIZE:     32
 * FIELDS:
 *     OVRFLW           GBOD RX fifo overflow flag.
 *
 ******************************************************************************/
#define BCM56218_A0_GE8_GBOD_OVRFLWr 0x0008000c

#define BCM56218_A0_GE8_GBOD_OVRFLWr_SIZE 4

/*
 * This structure should be used to declare and program GE8_GBOD_OVRFLW.
 *
 */
typedef union BCM56218_A0_GE8_GBOD_OVRFLWr_s {
	uint32_t v[1];
	uint32_t ge8_gbod_ovrflw[1];
	uint32_t _ge8_gbod_ovrflw;
} BCM56218_A0_GE8_GBOD_OVRFLWr_t;

#define BCM56218_A0_GE8_GBOD_OVRFLWr_CLR(r) (r).ge8_gbod_ovrflw[0] = 0
#define BCM56218_A0_GE8_GBOD_OVRFLWr_SET(r,d) (r).ge8_gbod_ovrflw[0] = d
#define BCM56218_A0_GE8_GBOD_OVRFLWr_GET(r) (r).ge8_gbod_ovrflw[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_GE8_GBOD_OVRFLWr_OVRFLWf_GET(r) (((r).ge8_gbod_ovrflw[0]) & 0x1)
#define BCM56218_A0_GE8_GBOD_OVRFLWr_OVRFLWf_SET(r,f) (r).ge8_gbod_ovrflw[0]=(((r).ge8_gbod_ovrflw[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access GE8_GBOD_OVRFLW.
 *
 */
#define BCM56218_A0_READ_GE8_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE8_GBOD_OVRFLWr,(r._ge8_gbod_ovrflw))
#define BCM56218_A0_WRITE_GE8_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE8_GBOD_OVRFLWr,&(r._ge8_gbod_ovrflw))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE8_GBOD_OVRFLWr BCM56218_A0_GE8_GBOD_OVRFLWr
#define GE8_GBOD_OVRFLWr_SIZE BCM56218_A0_GE8_GBOD_OVRFLWr_SIZE
typedef BCM56218_A0_GE8_GBOD_OVRFLWr_t GE8_GBOD_OVRFLWr_t;
#define GE8_GBOD_OVRFLWr_CLR BCM56218_A0_GE8_GBOD_OVRFLWr_CLR
#define GE8_GBOD_OVRFLWr_SET BCM56218_A0_GE8_GBOD_OVRFLWr_SET
#define GE8_GBOD_OVRFLWr_GET BCM56218_A0_GE8_GBOD_OVRFLWr_GET
#define GE8_GBOD_OVRFLWr_OVRFLWf_GET BCM56218_A0_GE8_GBOD_OVRFLWr_OVRFLWf_GET
#define GE8_GBOD_OVRFLWr_OVRFLWf_SET BCM56218_A0_GE8_GBOD_OVRFLWr_OVRFLWf_SET
#define READ_GE8_GBOD_OVRFLWr BCM56218_A0_READ_GE8_GBOD_OVRFLWr
#define WRITE_GE8_GBOD_OVRFLWr BCM56218_A0_WRITE_GE8_GBOD_OVRFLWr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GE8_GBOD_OVRFLWr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GE9_GBODE_CELL_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell count register for GE9 
 * SIZE:     32
 * FIELDS:
 *     CELL_CNT         Number of cell counts in GBODE tx fifo.
 *
 ******************************************************************************/
#define BCM56218_A0_GE9_GBODE_CELL_CNTr 0x00080019

#define BCM56218_A0_GE9_GBODE_CELL_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE9_GBODE_CELL_CNT.
 *
 */
typedef union BCM56218_A0_GE9_GBODE_CELL_CNTr_s {
	uint32_t v[1];
	uint32_t ge9_gbode_cell_cnt[1];
	uint32_t _ge9_gbode_cell_cnt;
} BCM56218_A0_GE9_GBODE_CELL_CNTr_t;

#define BCM56218_A0_GE9_GBODE_CELL_CNTr_CLR(r) (r).ge9_gbode_cell_cnt[0] = 0
#define BCM56218_A0_GE9_GBODE_CELL_CNTr_SET(r,d) (r).ge9_gbode_cell_cnt[0] = d
#define BCM56218_A0_GE9_GBODE_CELL_CNTr_GET(r) (r).ge9_gbode_cell_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_GE9_GBODE_CELL_CNTr_CELL_CNTf_GET(r) (((r).ge9_gbode_cell_cnt[0]) & 0xf)
#define BCM56218_A0_GE9_GBODE_CELL_CNTr_CELL_CNTf_SET(r,f) (r).ge9_gbode_cell_cnt[0]=(((r).ge9_gbode_cell_cnt[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access GE9_GBODE_CELL_CNT.
 *
 */
#define BCM56218_A0_READ_GE9_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE9_GBODE_CELL_CNTr,(r._ge9_gbode_cell_cnt))
#define BCM56218_A0_WRITE_GE9_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE9_GBODE_CELL_CNTr,&(r._ge9_gbode_cell_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE9_GBODE_CELL_CNTr BCM56218_A0_GE9_GBODE_CELL_CNTr
#define GE9_GBODE_CELL_CNTr_SIZE BCM56218_A0_GE9_GBODE_CELL_CNTr_SIZE
typedef BCM56218_A0_GE9_GBODE_CELL_CNTr_t GE9_GBODE_CELL_CNTr_t;
#define GE9_GBODE_CELL_CNTr_CLR BCM56218_A0_GE9_GBODE_CELL_CNTr_CLR
#define GE9_GBODE_CELL_CNTr_SET BCM56218_A0_GE9_GBODE_CELL_CNTr_SET
#define GE9_GBODE_CELL_CNTr_GET BCM56218_A0_GE9_GBODE_CELL_CNTr_GET
#define GE9_GBODE_CELL_CNTr_CELL_CNTf_GET BCM56218_A0_GE9_GBODE_CELL_CNTr_CELL_CNTf_GET
#define GE9_GBODE_CELL_CNTr_CELL_CNTf_SET BCM56218_A0_GE9_GBODE_CELL_CNTr_CELL_CNTf_SET
#define READ_GE9_GBODE_CELL_CNTr BCM56218_A0_READ_GE9_GBODE_CELL_CNTr
#define WRITE_GE9_GBODE_CELL_CNTr BCM56218_A0_WRITE_GE9_GBODE_CELL_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GE9_GBODE_CELL_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GE9_GBODE_CELL_REQ_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell request count register for GE9 
 * SIZE:     32
 * FIELDS:
 *     REQ_CNT          Number of cell request made to Egress Pipeline, MAX is 4 in FB mode. In Felix mode, MAX is 8.
 *
 ******************************************************************************/
#define BCM56218_A0_GE9_GBODE_CELL_REQ_CNTr 0x00080025

#define BCM56218_A0_GE9_GBODE_CELL_REQ_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE9_GBODE_CELL_REQ_CNT.
 *
 */
typedef union BCM56218_A0_GE9_GBODE_CELL_REQ_CNTr_s {
	uint32_t v[1];
	uint32_t ge9_gbode_cell_req_cnt[1];
	uint32_t _ge9_gbode_cell_req_cnt;
} BCM56218_A0_GE9_GBODE_CELL_REQ_CNTr_t;

#define BCM56218_A0_GE9_GBODE_CELL_REQ_CNTr_CLR(r) (r).ge9_gbode_cell_req_cnt[0] = 0
#define BCM56218_A0_GE9_GBODE_CELL_REQ_CNTr_SET(r,d) (r).ge9_gbode_cell_req_cnt[0] = d
#define BCM56218_A0_GE9_GBODE_CELL_REQ_CNTr_GET(r) (r).ge9_gbode_cell_req_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_GE9_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET(r) (((r).ge9_gbode_cell_req_cnt[0]) & 0xf)
#define BCM56218_A0_GE9_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET(r,f) (r).ge9_gbode_cell_req_cnt[0]=(((r).ge9_gbode_cell_req_cnt[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access GE9_GBODE_CELL_REQ_CNT.
 *
 */
#define BCM56218_A0_READ_GE9_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE9_GBODE_CELL_REQ_CNTr,(r._ge9_gbode_cell_req_cnt))
#define BCM56218_A0_WRITE_GE9_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE9_GBODE_CELL_REQ_CNTr,&(r._ge9_gbode_cell_req_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE9_GBODE_CELL_REQ_CNTr BCM56218_A0_GE9_GBODE_CELL_REQ_CNTr
#define GE9_GBODE_CELL_REQ_CNTr_SIZE BCM56218_A0_GE9_GBODE_CELL_REQ_CNTr_SIZE
typedef BCM56218_A0_GE9_GBODE_CELL_REQ_CNTr_t GE9_GBODE_CELL_REQ_CNTr_t;
#define GE9_GBODE_CELL_REQ_CNTr_CLR BCM56218_A0_GE9_GBODE_CELL_REQ_CNTr_CLR
#define GE9_GBODE_CELL_REQ_CNTr_SET BCM56218_A0_GE9_GBODE_CELL_REQ_CNTr_SET
#define GE9_GBODE_CELL_REQ_CNTr_GET BCM56218_A0_GE9_GBODE_CELL_REQ_CNTr_GET
#define GE9_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET BCM56218_A0_GE9_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET
#define GE9_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET BCM56218_A0_GE9_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET
#define READ_GE9_GBODE_CELL_REQ_CNTr BCM56218_A0_READ_GE9_GBODE_CELL_REQ_CNTr
#define WRITE_GE9_GBODE_CELL_REQ_CNTr BCM56218_A0_WRITE_GE9_GBODE_CELL_REQ_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GE9_GBODE_CELL_REQ_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GE9_GBOD_OVRFLW
 * BLOCKS:   GPORT0
 * DESC:     GBOD RX fifo overflow for GE9 
 * SIZE:     32
 * FIELDS:
 *     OVRFLW           GBOD RX fifo overflow flag.
 *
 ******************************************************************************/
#define BCM56218_A0_GE9_GBOD_OVRFLWr 0x0008000d

#define BCM56218_A0_GE9_GBOD_OVRFLWr_SIZE 4

/*
 * This structure should be used to declare and program GE9_GBOD_OVRFLW.
 *
 */
typedef union BCM56218_A0_GE9_GBOD_OVRFLWr_s {
	uint32_t v[1];
	uint32_t ge9_gbod_ovrflw[1];
	uint32_t _ge9_gbod_ovrflw;
} BCM56218_A0_GE9_GBOD_OVRFLWr_t;

#define BCM56218_A0_GE9_GBOD_OVRFLWr_CLR(r) (r).ge9_gbod_ovrflw[0] = 0
#define BCM56218_A0_GE9_GBOD_OVRFLWr_SET(r,d) (r).ge9_gbod_ovrflw[0] = d
#define BCM56218_A0_GE9_GBOD_OVRFLWr_GET(r) (r).ge9_gbod_ovrflw[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_GE9_GBOD_OVRFLWr_OVRFLWf_GET(r) (((r).ge9_gbod_ovrflw[0]) & 0x1)
#define BCM56218_A0_GE9_GBOD_OVRFLWr_OVRFLWf_SET(r,f) (r).ge9_gbod_ovrflw[0]=(((r).ge9_gbod_ovrflw[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access GE9_GBOD_OVRFLW.
 *
 */
#define BCM56218_A0_READ_GE9_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE9_GBOD_OVRFLWr,(r._ge9_gbod_ovrflw))
#define BCM56218_A0_WRITE_GE9_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GE9_GBOD_OVRFLWr,&(r._ge9_gbod_ovrflw))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE9_GBOD_OVRFLWr BCM56218_A0_GE9_GBOD_OVRFLWr
#define GE9_GBOD_OVRFLWr_SIZE BCM56218_A0_GE9_GBOD_OVRFLWr_SIZE
typedef BCM56218_A0_GE9_GBOD_OVRFLWr_t GE9_GBOD_OVRFLWr_t;
#define GE9_GBOD_OVRFLWr_CLR BCM56218_A0_GE9_GBOD_OVRFLWr_CLR
#define GE9_GBOD_OVRFLWr_SET BCM56218_A0_GE9_GBOD_OVRFLWr_SET
#define GE9_GBOD_OVRFLWr_GET BCM56218_A0_GE9_GBOD_OVRFLWr_GET
#define GE9_GBOD_OVRFLWr_OVRFLWf_GET BCM56218_A0_GE9_GBOD_OVRFLWr_OVRFLWf_GET
#define GE9_GBOD_OVRFLWr_OVRFLWf_SET BCM56218_A0_GE9_GBOD_OVRFLWr_OVRFLWf_SET
#define READ_GE9_GBOD_OVRFLWr BCM56218_A0_READ_GE9_GBOD_OVRFLWr
#define WRITE_GE9_GBOD_OVRFLWr BCM56218_A0_WRITE_GE9_GBOD_OVRFLWr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GE9_GBOD_OVRFLWr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GE_EGR_PKT_DROP_CTL
 * BLOCKS:   GPORT0
 * DESC:     Flush enable control for each egress port of GPORT
 * SIZE:     32
 * FIELDS:
 *     FLUSH            Flush enable bit to drop the packets within GPORT for each GE port
 *
 ******************************************************************************/
#define BCM56218_A0_GE_EGR_PKT_DROP_CTLr 0x00000301

#define BCM56218_A0_GE_EGR_PKT_DROP_CTLr_SIZE 4

/*
 * This structure should be used to declare and program GE_EGR_PKT_DROP_CTL.
 *
 */
typedef union BCM56218_A0_GE_EGR_PKT_DROP_CTLr_s {
	uint32_t v[1];
	uint32_t ge_egr_pkt_drop_ctl[1];
	uint32_t _ge_egr_pkt_drop_ctl;
} BCM56218_A0_GE_EGR_PKT_DROP_CTLr_t;

#define BCM56218_A0_GE_EGR_PKT_DROP_CTLr_CLR(r) (r).ge_egr_pkt_drop_ctl[0] = 0
#define BCM56218_A0_GE_EGR_PKT_DROP_CTLr_SET(r,d) (r).ge_egr_pkt_drop_ctl[0] = d
#define BCM56218_A0_GE_EGR_PKT_DROP_CTLr_GET(r) (r).ge_egr_pkt_drop_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_GE_EGR_PKT_DROP_CTLr_FLUSHf_GET(r) (((r).ge_egr_pkt_drop_ctl[0]) & 0x1)
#define BCM56218_A0_GE_EGR_PKT_DROP_CTLr_FLUSHf_SET(r,f) (r).ge_egr_pkt_drop_ctl[0]=(((r).ge_egr_pkt_drop_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access GE_EGR_PKT_DROP_CTL.
 *
 */
#define BCM56218_A0_READ_GE_EGR_PKT_DROP_CTLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GE_EGR_PKT_DROP_CTLr,(r._ge_egr_pkt_drop_ctl))
#define BCM56218_A0_WRITE_GE_EGR_PKT_DROP_CTLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GE_EGR_PKT_DROP_CTLr,&(r._ge_egr_pkt_drop_ctl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE_EGR_PKT_DROP_CTLr BCM56218_A0_GE_EGR_PKT_DROP_CTLr
#define GE_EGR_PKT_DROP_CTLr_SIZE BCM56218_A0_GE_EGR_PKT_DROP_CTLr_SIZE
typedef BCM56218_A0_GE_EGR_PKT_DROP_CTLr_t GE_EGR_PKT_DROP_CTLr_t;
#define GE_EGR_PKT_DROP_CTLr_CLR BCM56218_A0_GE_EGR_PKT_DROP_CTLr_CLR
#define GE_EGR_PKT_DROP_CTLr_SET BCM56218_A0_GE_EGR_PKT_DROP_CTLr_SET
#define GE_EGR_PKT_DROP_CTLr_GET BCM56218_A0_GE_EGR_PKT_DROP_CTLr_GET
#define GE_EGR_PKT_DROP_CTLr_FLUSHf_GET BCM56218_A0_GE_EGR_PKT_DROP_CTLr_FLUSHf_GET
#define GE_EGR_PKT_DROP_CTLr_FLUSHf_SET BCM56218_A0_GE_EGR_PKT_DROP_CTLr_FLUSHf_SET
#define READ_GE_EGR_PKT_DROP_CTLr BCM56218_A0_READ_GE_EGR_PKT_DROP_CTLr
#define WRITE_GE_EGR_PKT_DROP_CTLr BCM56218_A0_WRITE_GE_EGR_PKT_DROP_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GE_EGR_PKT_DROP_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GE_PORT_CONFIG
 * BLOCKS:   GPORT0
 * DESC:     GE port configuration
 * SIZE:     32
 * FIELDS:
 *     JAM_EN           Enable Jamming
 *     SPEED_SELECT     00=Gig, 01=100Mbps, 10=10Mbps, 11=N/A
 *     MAC_CRS_SEL      When set, connect the carrier sense (CRS) from external PHY. Default is from internal Serdes output.
 *     SGN_DET_SEL      When set, connect signal detect from external Fiber module.
 *     CLK_OUT_EN       When set, enable the clock output to SERDES. This bit does a glitch free disable of the clocks being fed to serdes. SO MAC can be programmed during speed mode change and clock change is not seen by serdes until MAC programming is done.
 *
 ******************************************************************************/
#define BCM56218_A0_GE_PORT_CONFIGr 0x00000300

#define BCM56218_A0_GE_PORT_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program GE_PORT_CONFIG.
 *
 */
typedef union BCM56218_A0_GE_PORT_CONFIGr_s {
	uint32_t v[1];
	uint32_t ge_port_config[1];
	uint32_t _ge_port_config;
} BCM56218_A0_GE_PORT_CONFIGr_t;

#define BCM56218_A0_GE_PORT_CONFIGr_CLR(r) (r).ge_port_config[0] = 0
#define BCM56218_A0_GE_PORT_CONFIGr_SET(r,d) (r).ge_port_config[0] = d
#define BCM56218_A0_GE_PORT_CONFIGr_GET(r) (r).ge_port_config[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_GE_PORT_CONFIGr_JAM_ENf_GET(r) (((r).ge_port_config[0]) & 0x1)
#define BCM56218_A0_GE_PORT_CONFIGr_JAM_ENf_SET(r,f) (r).ge_port_config[0]=(((r).ge_port_config[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_GE_PORT_CONFIGr_SPEED_SELECTf_GET(r) ((((r).ge_port_config[0]) >> 1) & 0x3)
#define BCM56218_A0_GE_PORT_CONFIGr_SPEED_SELECTf_SET(r,f) (r).ge_port_config[0]=(((r).ge_port_config[0] & ~((uint32_t)0x3 << 1)) | ((((uint32_t)f) & 0x3) << 1))
#define BCM56218_A0_GE_PORT_CONFIGr_MAC_CRS_SELf_GET(r) ((((r).ge_port_config[0]) >> 3) & 0x1)
#define BCM56218_A0_GE_PORT_CONFIGr_MAC_CRS_SELf_SET(r,f) (r).ge_port_config[0]=(((r).ge_port_config[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56218_A0_GE_PORT_CONFIGr_SGN_DET_SELf_GET(r) ((((r).ge_port_config[0]) >> 4) & 0x1)
#define BCM56218_A0_GE_PORT_CONFIGr_SGN_DET_SELf_SET(r,f) (r).ge_port_config[0]=(((r).ge_port_config[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56218_A0_GE_PORT_CONFIGr_CLK_OUT_ENf_GET(r) ((((r).ge_port_config[0]) >> 5) & 0x1)
#define BCM56218_A0_GE_PORT_CONFIGr_CLK_OUT_ENf_SET(r,f) (r).ge_port_config[0]=(((r).ge_port_config[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))

/*
 * These macros can be used to access GE_PORT_CONFIG.
 *
 */
#define BCM56218_A0_READ_GE_PORT_CONFIGr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GE_PORT_CONFIGr,(r._ge_port_config))
#define BCM56218_A0_WRITE_GE_PORT_CONFIGr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GE_PORT_CONFIGr,&(r._ge_port_config))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE_PORT_CONFIGr BCM56218_A0_GE_PORT_CONFIGr
#define GE_PORT_CONFIGr_SIZE BCM56218_A0_GE_PORT_CONFIGr_SIZE
typedef BCM56218_A0_GE_PORT_CONFIGr_t GE_PORT_CONFIGr_t;
#define GE_PORT_CONFIGr_CLR BCM56218_A0_GE_PORT_CONFIGr_CLR
#define GE_PORT_CONFIGr_SET BCM56218_A0_GE_PORT_CONFIGr_SET
#define GE_PORT_CONFIGr_GET BCM56218_A0_GE_PORT_CONFIGr_GET
#define GE_PORT_CONFIGr_JAM_ENf_GET BCM56218_A0_GE_PORT_CONFIGr_JAM_ENf_GET
#define GE_PORT_CONFIGr_JAM_ENf_SET BCM56218_A0_GE_PORT_CONFIGr_JAM_ENf_SET
#define GE_PORT_CONFIGr_SPEED_SELECTf_GET BCM56218_A0_GE_PORT_CONFIGr_SPEED_SELECTf_GET
#define GE_PORT_CONFIGr_SPEED_SELECTf_SET BCM56218_A0_GE_PORT_CONFIGr_SPEED_SELECTf_SET
#define GE_PORT_CONFIGr_MAC_CRS_SELf_GET BCM56218_A0_GE_PORT_CONFIGr_MAC_CRS_SELf_GET
#define GE_PORT_CONFIGr_MAC_CRS_SELf_SET BCM56218_A0_GE_PORT_CONFIGr_MAC_CRS_SELf_SET
#define GE_PORT_CONFIGr_SGN_DET_SELf_GET BCM56218_A0_GE_PORT_CONFIGr_SGN_DET_SELf_GET
#define GE_PORT_CONFIGr_SGN_DET_SELf_SET BCM56218_A0_GE_PORT_CONFIGr_SGN_DET_SELf_SET
#define GE_PORT_CONFIGr_CLK_OUT_ENf_GET BCM56218_A0_GE_PORT_CONFIGr_CLK_OUT_ENf_GET
#define GE_PORT_CONFIGr_CLK_OUT_ENf_SET BCM56218_A0_GE_PORT_CONFIGr_CLK_OUT_ENf_SET
#define READ_GE_PORT_CONFIGr BCM56218_A0_READ_GE_PORT_CONFIGr
#define WRITE_GE_PORT_CONFIGr BCM56218_A0_WRITE_GE_PORT_CONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GE_PORT_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GMACC0
 * BLOCKS:   GPORT0
 * DESC:     GIG Port Control Reg 0
 * SIZE:     32
 * FIELDS:
 *     TMDS             Mode select between TBI & MII interfaces. If '1', chooses MII. Applicable to 1G mode only.
 *     L32B             Loopback 32B Data
 *     L10B             Loopback 10B Symbols. Not supported.
 *     SRST             Soft Reset
 *
 ******************************************************************************/
#define BCM56218_A0_GMACC0r 0x00000100

#define BCM56218_A0_GMACC0r_SIZE 4

/*
 * This structure should be used to declare and program GMACC0.
 *
 */
typedef union BCM56218_A0_GMACC0r_s {
	uint32_t v[1];
	uint32_t gmacc0[1];
	uint32_t _gmacc0;
} BCM56218_A0_GMACC0r_t;

#define BCM56218_A0_GMACC0r_CLR(r) (r).gmacc0[0] = 0
#define BCM56218_A0_GMACC0r_SET(r,d) (r).gmacc0[0] = d
#define BCM56218_A0_GMACC0r_GET(r) (r).gmacc0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_GMACC0r_TMDSf_GET(r) (((r).gmacc0[0]) & 0xff)
#define BCM56218_A0_GMACC0r_TMDSf_SET(r,f) (r).gmacc0[0]=(((r).gmacc0[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56218_A0_GMACC0r_L32Bf_GET(r) ((((r).gmacc0[0]) >> 8) & 0x1)
#define BCM56218_A0_GMACC0r_L32Bf_SET(r,f) (r).gmacc0[0]=(((r).gmacc0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56218_A0_GMACC0r_L10Bf_GET(r) ((((r).gmacc0[0]) >> 9) & 0x1)
#define BCM56218_A0_GMACC0r_L10Bf_SET(r,f) (r).gmacc0[0]=(((r).gmacc0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56218_A0_GMACC0r_SRSTf_GET(r) ((((r).gmacc0[0]) >> 31) & 0x1)
#define BCM56218_A0_GMACC0r_SRSTf_SET(r,f) (r).gmacc0[0]=(((r).gmacc0[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access GMACC0.
 *
 */
#define BCM56218_A0_READ_GMACC0r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GMACC0r,(r._gmacc0))
#define BCM56218_A0_WRITE_GMACC0r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GMACC0r,&(r._gmacc0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GMACC0r BCM56218_A0_GMACC0r
#define GMACC0r_SIZE BCM56218_A0_GMACC0r_SIZE
typedef BCM56218_A0_GMACC0r_t GMACC0r_t;
#define GMACC0r_CLR BCM56218_A0_GMACC0r_CLR
#define GMACC0r_SET BCM56218_A0_GMACC0r_SET
#define GMACC0r_GET BCM56218_A0_GMACC0r_GET
#define GMACC0r_TMDSf_GET BCM56218_A0_GMACC0r_TMDSf_GET
#define GMACC0r_TMDSf_SET BCM56218_A0_GMACC0r_TMDSf_SET
#define GMACC0r_L32Bf_GET BCM56218_A0_GMACC0r_L32Bf_GET
#define GMACC0r_L32Bf_SET BCM56218_A0_GMACC0r_L32Bf_SET
#define GMACC0r_L10Bf_GET BCM56218_A0_GMACC0r_L10Bf_GET
#define GMACC0r_L10Bf_SET BCM56218_A0_GMACC0r_L10Bf_SET
#define GMACC0r_SRSTf_GET BCM56218_A0_GMACC0r_SRSTf_GET
#define GMACC0r_SRSTf_SET BCM56218_A0_GMACC0r_SRSTf_SET
#define READ_GMACC0r BCM56218_A0_READ_GMACC0r
#define WRITE_GMACC0r BCM56218_A0_WRITE_GMACC0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GMACC0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GMACC1
 * BLOCKS:   GPORT0
 * DESC:     GIG Port Control Reg 1
 * SIZE:     32
 * FIELDS:
 *     FULLD            Full-Duplex (Tied to 1)
 *     PADEN            Pad Enable
 *     VLPAD            VLAN Pad
 *     ADPAD            Auto Detect Pad
 *     CRCEN            CRC Enable
 *     FLCHK            Frame Length Check
 *     HUGEN            Huge Frame Enable
 *     JUMBO            JUMBO Frame Enable
 *     PUREP            Pure Preamble
 *     FCTX             Flow Control: Transmit Capable
 *     FCRX             Flow Control: Receive Capable
 *     PARF             Pass All Receive Frames
 *     LONGP            Accept Preambles over 11 bytes
 *     MIFG             Minimum IFG
 *     GLVR             Gulliver
 *     DCRC12           Delayed CRC = 12 bytes
 *     RXEN0            Receive Enable
 *     TXEN0            Transmit Enable
 *
 ******************************************************************************/
#define BCM56218_A0_GMACC1r 0x00000101

#define BCM56218_A0_GMACC1r_SIZE 4

/*
 * This structure should be used to declare and program GMACC1.
 *
 */
typedef union BCM56218_A0_GMACC1r_s {
	uint32_t v[1];
	uint32_t gmacc1[1];
	uint32_t _gmacc1;
} BCM56218_A0_GMACC1r_t;

#define BCM56218_A0_GMACC1r_CLR(r) (r).gmacc1[0] = 0
#define BCM56218_A0_GMACC1r_SET(r,d) (r).gmacc1[0] = d
#define BCM56218_A0_GMACC1r_GET(r) (r).gmacc1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_GMACC1r_FULLDf_GET(r) (((r).gmacc1[0]) & 0x1)
#define BCM56218_A0_GMACC1r_FULLDf_SET(r,f) (r).gmacc1[0]=(((r).gmacc1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_GMACC1r_PADENf_GET(r) ((((r).gmacc1[0]) >> 1) & 0x1)
#define BCM56218_A0_GMACC1r_PADENf_SET(r,f) (r).gmacc1[0]=(((r).gmacc1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_GMACC1r_VLPADf_GET(r) ((((r).gmacc1[0]) >> 2) & 0x1)
#define BCM56218_A0_GMACC1r_VLPADf_SET(r,f) (r).gmacc1[0]=(((r).gmacc1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_GMACC1r_ADPADf_GET(r) ((((r).gmacc1[0]) >> 3) & 0x1)
#define BCM56218_A0_GMACC1r_ADPADf_SET(r,f) (r).gmacc1[0]=(((r).gmacc1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56218_A0_GMACC1r_CRCENf_GET(r) ((((r).gmacc1[0]) >> 4) & 0x1)
#define BCM56218_A0_GMACC1r_CRCENf_SET(r,f) (r).gmacc1[0]=(((r).gmacc1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56218_A0_GMACC1r_FLCHKf_GET(r) ((((r).gmacc1[0]) >> 5) & 0x1)
#define BCM56218_A0_GMACC1r_FLCHKf_SET(r,f) (r).gmacc1[0]=(((r).gmacc1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56218_A0_GMACC1r_HUGENf_GET(r) ((((r).gmacc1[0]) >> 6) & 0x1)
#define BCM56218_A0_GMACC1r_HUGENf_SET(r,f) (r).gmacc1[0]=(((r).gmacc1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56218_A0_GMACC1r_JUMBOf_GET(r) ((((r).gmacc1[0]) >> 7) & 0x1)
#define BCM56218_A0_GMACC1r_JUMBOf_SET(r,f) (r).gmacc1[0]=(((r).gmacc1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56218_A0_GMACC1r_PUREPf_GET(r) ((((r).gmacc1[0]) >> 8) & 0x1)
#define BCM56218_A0_GMACC1r_PUREPf_SET(r,f) (r).gmacc1[0]=(((r).gmacc1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56218_A0_GMACC1r_FCTXf_GET(r) ((((r).gmacc1[0]) >> 9) & 0x1)
#define BCM56218_A0_GMACC1r_FCTXf_SET(r,f) (r).gmacc1[0]=(((r).gmacc1[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56218_A0_GMACC1r_FCRXf_GET(r) ((((r).gmacc1[0]) >> 10) & 0x1)
#define BCM56218_A0_GMACC1r_FCRXf_SET(r,f) (r).gmacc1[0]=(((r).gmacc1[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56218_A0_GMACC1r_PARFf_GET(r) ((((r).gmacc1[0]) >> 11) & 0x1)
#define BCM56218_A0_GMACC1r_PARFf_SET(r,f) (r).gmacc1[0]=(((r).gmacc1[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56218_A0_GMACC1r_LONGPf_GET(r) ((((r).gmacc1[0]) >> 12) & 0x1)
#define BCM56218_A0_GMACC1r_LONGPf_SET(r,f) (r).gmacc1[0]=(((r).gmacc1[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM56218_A0_GMACC1r_MIFGf_GET(r) ((((r).gmacc1[0]) >> 16) & 0x7)
#define BCM56218_A0_GMACC1r_MIFGf_SET(r,f) (r).gmacc1[0]=(((r).gmacc1[0] & ~((uint32_t)0x7 << 16)) | ((((uint32_t)f) & 0x7) << 16))
#define BCM56218_A0_GMACC1r_GLVRf_GET(r) ((((r).gmacc1[0]) >> 19) & 0x1)
#define BCM56218_A0_GMACC1r_GLVRf_SET(r,f) (r).gmacc1[0]=(((r).gmacc1[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56218_A0_GMACC1r_DCRC12f_GET(r) ((((r).gmacc1[0]) >> 22) & 0x3)
#define BCM56218_A0_GMACC1r_DCRC12f_SET(r,f) (r).gmacc1[0]=(((r).gmacc1[0] & ~((uint32_t)0x3 << 22)) | ((((uint32_t)f) & 0x3) << 22))
#define BCM56218_A0_GMACC1r_RXEN0f_GET(r) ((((r).gmacc1[0]) >> 28) & 0x1)
#define BCM56218_A0_GMACC1r_RXEN0f_SET(r,f) (r).gmacc1[0]=(((r).gmacc1[0] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM56218_A0_GMACC1r_TXEN0f_GET(r) ((((r).gmacc1[0]) >> 30) & 0x1)
#define BCM56218_A0_GMACC1r_TXEN0f_SET(r,f) (r).gmacc1[0]=(((r).gmacc1[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))

/*
 * These macros can be used to access GMACC1.
 *
 */
#define BCM56218_A0_READ_GMACC1r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GMACC1r,(r._gmacc1))
#define BCM56218_A0_WRITE_GMACC1r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GMACC1r,&(r._gmacc1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GMACC1r BCM56218_A0_GMACC1r
#define GMACC1r_SIZE BCM56218_A0_GMACC1r_SIZE
typedef BCM56218_A0_GMACC1r_t GMACC1r_t;
#define GMACC1r_CLR BCM56218_A0_GMACC1r_CLR
#define GMACC1r_SET BCM56218_A0_GMACC1r_SET
#define GMACC1r_GET BCM56218_A0_GMACC1r_GET
#define GMACC1r_FULLDf_GET BCM56218_A0_GMACC1r_FULLDf_GET
#define GMACC1r_FULLDf_SET BCM56218_A0_GMACC1r_FULLDf_SET
#define GMACC1r_PADENf_GET BCM56218_A0_GMACC1r_PADENf_GET
#define GMACC1r_PADENf_SET BCM56218_A0_GMACC1r_PADENf_SET
#define GMACC1r_VLPADf_GET BCM56218_A0_GMACC1r_VLPADf_GET
#define GMACC1r_VLPADf_SET BCM56218_A0_GMACC1r_VLPADf_SET
#define GMACC1r_ADPADf_GET BCM56218_A0_GMACC1r_ADPADf_GET
#define GMACC1r_ADPADf_SET BCM56218_A0_GMACC1r_ADPADf_SET
#define GMACC1r_CRCENf_GET BCM56218_A0_GMACC1r_CRCENf_GET
#define GMACC1r_CRCENf_SET BCM56218_A0_GMACC1r_CRCENf_SET
#define GMACC1r_FLCHKf_GET BCM56218_A0_GMACC1r_FLCHKf_GET
#define GMACC1r_FLCHKf_SET BCM56218_A0_GMACC1r_FLCHKf_SET
#define GMACC1r_HUGENf_GET BCM56218_A0_GMACC1r_HUGENf_GET
#define GMACC1r_HUGENf_SET BCM56218_A0_GMACC1r_HUGENf_SET
#define GMACC1r_JUMBOf_GET BCM56218_A0_GMACC1r_JUMBOf_GET
#define GMACC1r_JUMBOf_SET BCM56218_A0_GMACC1r_JUMBOf_SET
#define GMACC1r_PUREPf_GET BCM56218_A0_GMACC1r_PUREPf_GET
#define GMACC1r_PUREPf_SET BCM56218_A0_GMACC1r_PUREPf_SET
#define GMACC1r_FCTXf_GET BCM56218_A0_GMACC1r_FCTXf_GET
#define GMACC1r_FCTXf_SET BCM56218_A0_GMACC1r_FCTXf_SET
#define GMACC1r_FCRXf_GET BCM56218_A0_GMACC1r_FCRXf_GET
#define GMACC1r_FCRXf_SET BCM56218_A0_GMACC1r_FCRXf_SET
#define GMACC1r_PARFf_GET BCM56218_A0_GMACC1r_PARFf_GET
#define GMACC1r_PARFf_SET BCM56218_A0_GMACC1r_PARFf_SET
#define GMACC1r_LONGPf_GET BCM56218_A0_GMACC1r_LONGPf_GET
#define GMACC1r_LONGPf_SET BCM56218_A0_GMACC1r_LONGPf_SET
#define GMACC1r_MIFGf_GET BCM56218_A0_GMACC1r_MIFGf_GET
#define GMACC1r_MIFGf_SET BCM56218_A0_GMACC1r_MIFGf_SET
#define GMACC1r_GLVRf_GET BCM56218_A0_GMACC1r_GLVRf_GET
#define GMACC1r_GLVRf_SET BCM56218_A0_GMACC1r_GLVRf_SET
#define GMACC1r_DCRC12f_GET BCM56218_A0_GMACC1r_DCRC12f_GET
#define GMACC1r_DCRC12f_SET BCM56218_A0_GMACC1r_DCRC12f_SET
#define GMACC1r_RXEN0f_GET BCM56218_A0_GMACC1r_RXEN0f_GET
#define GMACC1r_RXEN0f_SET BCM56218_A0_GMACC1r_RXEN0f_SET
#define GMACC1r_TXEN0f_GET BCM56218_A0_GMACC1r_TXEN0f_GET
#define GMACC1r_TXEN0f_SET BCM56218_A0_GMACC1r_TXEN0f_SET
#define READ_GMACC1r BCM56218_A0_READ_GMACC1r
#define WRITE_GMACC1r BCM56218_A0_WRITE_GMACC1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GMACC1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GMACC2
 * BLOCKS:   GPORT0
 * DESC:     GIG Port Control Reg 2
 * SIZE:     32
 * FIELDS:
 *     IPGT             Back-to-Back Transmit IPG
 *
 ******************************************************************************/
#define BCM56218_A0_GMACC2r 0x00000102

#define BCM56218_A0_GMACC2r_SIZE 4

/*
 * This structure should be used to declare and program GMACC2.
 *
 */
typedef union BCM56218_A0_GMACC2r_s {
	uint32_t v[1];
	uint32_t gmacc2[1];
	uint32_t _gmacc2;
} BCM56218_A0_GMACC2r_t;

#define BCM56218_A0_GMACC2r_CLR(r) (r).gmacc2[0] = 0
#define BCM56218_A0_GMACC2r_SET(r,d) (r).gmacc2[0] = d
#define BCM56218_A0_GMACC2r_GET(r) (r).gmacc2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_GMACC2r_IPGTf_GET(r) (((r).gmacc2[0]) & 0x3f)
#define BCM56218_A0_GMACC2r_IPGTf_SET(r,f) (r).gmacc2[0]=(((r).gmacc2[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))

/*
 * These macros can be used to access GMACC2.
 *
 */
#define BCM56218_A0_READ_GMACC2r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GMACC2r,(r._gmacc2))
#define BCM56218_A0_WRITE_GMACC2r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GMACC2r,&(r._gmacc2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GMACC2r BCM56218_A0_GMACC2r
#define GMACC2r_SIZE BCM56218_A0_GMACC2r_SIZE
typedef BCM56218_A0_GMACC2r_t GMACC2r_t;
#define GMACC2r_CLR BCM56218_A0_GMACC2r_CLR
#define GMACC2r_SET BCM56218_A0_GMACC2r_SET
#define GMACC2r_GET BCM56218_A0_GMACC2r_GET
#define GMACC2r_IPGTf_GET BCM56218_A0_GMACC2r_IPGTf_GET
#define GMACC2r_IPGTf_SET BCM56218_A0_GMACC2r_IPGTf_SET
#define READ_GMACC2r BCM56218_A0_READ_GMACC2r
#define WRITE_GMACC2r BCM56218_A0_WRITE_GMACC2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GMACC2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GPCSC
 * BLOCKS:   GPORT0
 * DESC:     Jitter Reg
 * SIZE:     32
 * FIELDS:
 *     EWRAP            Loopback SERDES
 *     RCSEL            Clock select for Receive. 0=TBI(8b10b), 1=GMII
 *
 ******************************************************************************/
#define BCM56218_A0_GPCSCr 0x00000103

#define BCM56218_A0_GPCSCr_SIZE 4

/*
 * This structure should be used to declare and program GPCSC.
 *
 */
typedef union BCM56218_A0_GPCSCr_s {
	uint32_t v[1];
	uint32_t gpcsc[1];
	uint32_t _gpcsc;
} BCM56218_A0_GPCSCr_t;

#define BCM56218_A0_GPCSCr_CLR(r) (r).gpcsc[0] = 0
#define BCM56218_A0_GPCSCr_SET(r,d) (r).gpcsc[0] = d
#define BCM56218_A0_GPCSCr_GET(r) (r).gpcsc[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_GPCSCr_EWRAPf_GET(r) ((((r).gpcsc[0]) >> 1) & 0x1)
#define BCM56218_A0_GPCSCr_EWRAPf_SET(r,f) (r).gpcsc[0]=(((r).gpcsc[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_GPCSCr_RCSELf_GET(r) ((((r).gpcsc[0]) >> 2) & 0x1)
#define BCM56218_A0_GPCSCr_RCSELf_SET(r,f) (r).gpcsc[0]=(((r).gpcsc[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))

/*
 * These macros can be used to access GPCSC.
 *
 */
#define BCM56218_A0_READ_GPCSCr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GPCSCr,(r._gpcsc))
#define BCM56218_A0_WRITE_GPCSCr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GPCSCr,&(r._gpcsc))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GPCSCr BCM56218_A0_GPCSCr
#define GPCSCr_SIZE BCM56218_A0_GPCSCr_SIZE
typedef BCM56218_A0_GPCSCr_t GPCSCr_t;
#define GPCSCr_CLR BCM56218_A0_GPCSCr_CLR
#define GPCSCr_SET BCM56218_A0_GPCSCr_SET
#define GPCSCr_GET BCM56218_A0_GPCSCr_GET
#define GPCSCr_EWRAPf_GET BCM56218_A0_GPCSCr_EWRAPf_GET
#define GPCSCr_EWRAPf_SET BCM56218_A0_GPCSCr_EWRAPf_SET
#define GPCSCr_RCSELf_GET BCM56218_A0_GPCSCr_RCSELf_GET
#define GPCSCr_RCSELf_SET BCM56218_A0_GPCSCr_RCSELf_SET
#define READ_GPCSCr BCM56218_A0_READ_GPCSCr
#define WRITE_GPCSCr BCM56218_A0_WRITE_GPCSCr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GPCSCr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GPORT_CNTMAXSIZE
 * BLOCKS:   GPORT0
 * DESC:     GPORT CNTMAXSIZE register
 * SIZE:     32
 * FIELDS:
 *     CNTMAXSIZE       The max packet size that is used in statistic counter update. Default to 1518.
 *
 ******************************************************************************/
#define BCM56218_A0_GPORT_CNTMAXSIZEr 0x00080003

#define BCM56218_A0_GPORT_CNTMAXSIZEr_SIZE 4

/*
 * This structure should be used to declare and program GPORT_CNTMAXSIZE.
 *
 */
typedef union BCM56218_A0_GPORT_CNTMAXSIZEr_s {
	uint32_t v[1];
	uint32_t gport_cntmaxsize[1];
	uint32_t _gport_cntmaxsize;
} BCM56218_A0_GPORT_CNTMAXSIZEr_t;

#define BCM56218_A0_GPORT_CNTMAXSIZEr_CLR(r) (r).gport_cntmaxsize[0] = 0
#define BCM56218_A0_GPORT_CNTMAXSIZEr_SET(r,d) (r).gport_cntmaxsize[0] = d
#define BCM56218_A0_GPORT_CNTMAXSIZEr_GET(r) (r).gport_cntmaxsize[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_GPORT_CNTMAXSIZEr_CNTMAXSIZEf_GET(r) (((r).gport_cntmaxsize[0]) & 0x3fff)
#define BCM56218_A0_GPORT_CNTMAXSIZEr_CNTMAXSIZEf_SET(r,f) (r).gport_cntmaxsize[0]=(((r).gport_cntmaxsize[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access GPORT_CNTMAXSIZE.
 *
 */
#define BCM56218_A0_READ_GPORT_CNTMAXSIZEr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GPORT_CNTMAXSIZEr,(r._gport_cntmaxsize))
#define BCM56218_A0_WRITE_GPORT_CNTMAXSIZEr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GPORT_CNTMAXSIZEr,&(r._gport_cntmaxsize))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GPORT_CNTMAXSIZEr BCM56218_A0_GPORT_CNTMAXSIZEr
#define GPORT_CNTMAXSIZEr_SIZE BCM56218_A0_GPORT_CNTMAXSIZEr_SIZE
typedef BCM56218_A0_GPORT_CNTMAXSIZEr_t GPORT_CNTMAXSIZEr_t;
#define GPORT_CNTMAXSIZEr_CLR BCM56218_A0_GPORT_CNTMAXSIZEr_CLR
#define GPORT_CNTMAXSIZEr_SET BCM56218_A0_GPORT_CNTMAXSIZEr_SET
#define GPORT_CNTMAXSIZEr_GET BCM56218_A0_GPORT_CNTMAXSIZEr_GET
#define GPORT_CNTMAXSIZEr_CNTMAXSIZEf_GET BCM56218_A0_GPORT_CNTMAXSIZEr_CNTMAXSIZEf_GET
#define GPORT_CNTMAXSIZEr_CNTMAXSIZEf_SET BCM56218_A0_GPORT_CNTMAXSIZEr_CNTMAXSIZEf_SET
#define READ_GPORT_CNTMAXSIZEr BCM56218_A0_READ_GPORT_CNTMAXSIZEr
#define WRITE_GPORT_CNTMAXSIZEr BCM56218_A0_WRITE_GPORT_CNTMAXSIZEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GPORT_CNTMAXSIZEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GPORT_CONFIG
 * BLOCKS:   GPORT0
 * DESC:     GPORT configuration Register
 * SIZE:     32
 * FIELDS:
 *     GPORT_EN         Enable GPORT.
 *     CLR_CNT          Clear all 12 GE port statistic Counters.
 *     HGIG2_EN_S0      Enable HGIG2 FOR SPORT0.
 *     HGIG2_EN_S1      Enable HGIG2 FOR SPORT1.
 *     SEL_LCPLL_S0     If set, selects LCPLL output as the reference clock for TxPLL, otherwise Ext refclk.
 *     SEL_LCPLL_S1     If set, selects LCPLL output as the reference clock for TxPLL, otherwise Ext refclk.
 *     PLL_MODE_DEF_S0  If set, selects selects 2.5 gbps mode. Default is 1 gbps mode.
 *     PLL_MODE_DEF_S1  If set, selects selects 2.5 gbps mode. Default is 1 gbps mode.
 *     DROP_ON_WRONG_SOP_EN_S0 If set, drops the packet with wrong SOP BYTE for S0.
 *     DROP_ON_WRONG_SOP_EN_S1 If set, drops the packet with wrong SOP BYTE for S1.
 *
 ******************************************************************************/
#define BCM56218_A0_GPORT_CONFIGr 0x00080000

#define BCM56218_A0_GPORT_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program GPORT_CONFIG.
 *
 */
typedef union BCM56218_A0_GPORT_CONFIGr_s {
	uint32_t v[1];
	uint32_t gport_config[1];
	uint32_t _gport_config;
} BCM56218_A0_GPORT_CONFIGr_t;

#define BCM56218_A0_GPORT_CONFIGr_CLR(r) (r).gport_config[0] = 0
#define BCM56218_A0_GPORT_CONFIGr_SET(r,d) (r).gport_config[0] = d
#define BCM56218_A0_GPORT_CONFIGr_GET(r) (r).gport_config[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_GPORT_CONFIGr_GPORT_ENf_GET(r) (((r).gport_config[0]) & 0x1)
#define BCM56218_A0_GPORT_CONFIGr_GPORT_ENf_SET(r,f) (r).gport_config[0]=(((r).gport_config[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_GPORT_CONFIGr_CLR_CNTf_GET(r) ((((r).gport_config[0]) >> 1) & 0x1)
#define BCM56218_A0_GPORT_CONFIGr_CLR_CNTf_SET(r,f) (r).gport_config[0]=(((r).gport_config[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_GPORT_CONFIGr_HGIG2_EN_S0f_GET(r) ((((r).gport_config[0]) >> 2) & 0x1)
#define BCM56218_A0_GPORT_CONFIGr_HGIG2_EN_S0f_SET(r,f) (r).gport_config[0]=(((r).gport_config[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_GPORT_CONFIGr_HGIG2_EN_S1f_GET(r) ((((r).gport_config[0]) >> 3) & 0x1)
#define BCM56218_A0_GPORT_CONFIGr_HGIG2_EN_S1f_SET(r,f) (r).gport_config[0]=(((r).gport_config[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56218_A0_GPORT_CONFIGr_SEL_LCPLL_S0f_GET(r) ((((r).gport_config[0]) >> 4) & 0x1)
#define BCM56218_A0_GPORT_CONFIGr_SEL_LCPLL_S0f_SET(r,f) (r).gport_config[0]=(((r).gport_config[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56218_A0_GPORT_CONFIGr_SEL_LCPLL_S1f_GET(r) ((((r).gport_config[0]) >> 5) & 0x1)
#define BCM56218_A0_GPORT_CONFIGr_SEL_LCPLL_S1f_SET(r,f) (r).gport_config[0]=(((r).gport_config[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56218_A0_GPORT_CONFIGr_PLL_MODE_DEF_S0f_GET(r) ((((r).gport_config[0]) >> 6) & 0x1)
#define BCM56218_A0_GPORT_CONFIGr_PLL_MODE_DEF_S0f_SET(r,f) (r).gport_config[0]=(((r).gport_config[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56218_A0_GPORT_CONFIGr_PLL_MODE_DEF_S1f_GET(r) ((((r).gport_config[0]) >> 7) & 0x1)
#define BCM56218_A0_GPORT_CONFIGr_PLL_MODE_DEF_S1f_SET(r,f) (r).gport_config[0]=(((r).gport_config[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56218_A0_GPORT_CONFIGr_DROP_ON_WRONG_SOP_EN_S0f_GET(r) ((((r).gport_config[0]) >> 8) & 0x1)
#define BCM56218_A0_GPORT_CONFIGr_DROP_ON_WRONG_SOP_EN_S0f_SET(r,f) (r).gport_config[0]=(((r).gport_config[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56218_A0_GPORT_CONFIGr_DROP_ON_WRONG_SOP_EN_S1f_GET(r) ((((r).gport_config[0]) >> 9) & 0x1)
#define BCM56218_A0_GPORT_CONFIGr_DROP_ON_WRONG_SOP_EN_S1f_SET(r,f) (r).gport_config[0]=(((r).gport_config[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))

/*
 * These macros can be used to access GPORT_CONFIG.
 *
 */
#define BCM56218_A0_READ_GPORT_CONFIGr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GPORT_CONFIGr,(r._gport_config))
#define BCM56218_A0_WRITE_GPORT_CONFIGr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GPORT_CONFIGr,&(r._gport_config))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GPORT_CONFIGr BCM56218_A0_GPORT_CONFIGr
#define GPORT_CONFIGr_SIZE BCM56218_A0_GPORT_CONFIGr_SIZE
typedef BCM56218_A0_GPORT_CONFIGr_t GPORT_CONFIGr_t;
#define GPORT_CONFIGr_CLR BCM56218_A0_GPORT_CONFIGr_CLR
#define GPORT_CONFIGr_SET BCM56218_A0_GPORT_CONFIGr_SET
#define GPORT_CONFIGr_GET BCM56218_A0_GPORT_CONFIGr_GET
#define GPORT_CONFIGr_GPORT_ENf_GET BCM56218_A0_GPORT_CONFIGr_GPORT_ENf_GET
#define GPORT_CONFIGr_GPORT_ENf_SET BCM56218_A0_GPORT_CONFIGr_GPORT_ENf_SET
#define GPORT_CONFIGr_CLR_CNTf_GET BCM56218_A0_GPORT_CONFIGr_CLR_CNTf_GET
#define GPORT_CONFIGr_CLR_CNTf_SET BCM56218_A0_GPORT_CONFIGr_CLR_CNTf_SET
#define GPORT_CONFIGr_HGIG2_EN_S0f_GET BCM56218_A0_GPORT_CONFIGr_HGIG2_EN_S0f_GET
#define GPORT_CONFIGr_HGIG2_EN_S0f_SET BCM56218_A0_GPORT_CONFIGr_HGIG2_EN_S0f_SET
#define GPORT_CONFIGr_HGIG2_EN_S1f_GET BCM56218_A0_GPORT_CONFIGr_HGIG2_EN_S1f_GET
#define GPORT_CONFIGr_HGIG2_EN_S1f_SET BCM56218_A0_GPORT_CONFIGr_HGIG2_EN_S1f_SET
#define GPORT_CONFIGr_SEL_LCPLL_S0f_GET BCM56218_A0_GPORT_CONFIGr_SEL_LCPLL_S0f_GET
#define GPORT_CONFIGr_SEL_LCPLL_S0f_SET BCM56218_A0_GPORT_CONFIGr_SEL_LCPLL_S0f_SET
#define GPORT_CONFIGr_SEL_LCPLL_S1f_GET BCM56218_A0_GPORT_CONFIGr_SEL_LCPLL_S1f_GET
#define GPORT_CONFIGr_SEL_LCPLL_S1f_SET BCM56218_A0_GPORT_CONFIGr_SEL_LCPLL_S1f_SET
#define GPORT_CONFIGr_PLL_MODE_DEF_S0f_GET BCM56218_A0_GPORT_CONFIGr_PLL_MODE_DEF_S0f_GET
#define GPORT_CONFIGr_PLL_MODE_DEF_S0f_SET BCM56218_A0_GPORT_CONFIGr_PLL_MODE_DEF_S0f_SET
#define GPORT_CONFIGr_PLL_MODE_DEF_S1f_GET BCM56218_A0_GPORT_CONFIGr_PLL_MODE_DEF_S1f_GET
#define GPORT_CONFIGr_PLL_MODE_DEF_S1f_SET BCM56218_A0_GPORT_CONFIGr_PLL_MODE_DEF_S1f_SET
#define GPORT_CONFIGr_DROP_ON_WRONG_SOP_EN_S0f_GET BCM56218_A0_GPORT_CONFIGr_DROP_ON_WRONG_SOP_EN_S0f_GET
#define GPORT_CONFIGr_DROP_ON_WRONG_SOP_EN_S0f_SET BCM56218_A0_GPORT_CONFIGr_DROP_ON_WRONG_SOP_EN_S0f_SET
#define GPORT_CONFIGr_DROP_ON_WRONG_SOP_EN_S1f_GET BCM56218_A0_GPORT_CONFIGr_DROP_ON_WRONG_SOP_EN_S1f_GET
#define GPORT_CONFIGr_DROP_ON_WRONG_SOP_EN_S1f_SET BCM56218_A0_GPORT_CONFIGr_DROP_ON_WRONG_SOP_EN_S1f_SET
#define READ_GPORT_CONFIGr BCM56218_A0_READ_GPORT_CONFIGr
#define WRITE_GPORT_CONFIGr BCM56218_A0_WRITE_GPORT_CONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GPORT_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GPORT_DROP_ON_WRONG_SOP_S0_CNT
 * BLOCKS:   GPORT0
 * DESC:     Drop Counter against wrong K.SOP for FPORT-S0
 * SIZE:     32
 * FIELDS:
 *     S0_CNT           Counts the dropped packets because of wrong SOP Byte in FPORT-S0.
 *
 ******************************************************************************/
#define BCM56218_A0_GPORT_DROP_ON_WRONG_SOP_S0_CNTr 0x0008002c

#define BCM56218_A0_GPORT_DROP_ON_WRONG_SOP_S0_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GPORT_DROP_ON_WRONG_SOP_S0_CNT.
 *
 */
typedef union BCM56218_A0_GPORT_DROP_ON_WRONG_SOP_S0_CNTr_s {
	uint32_t v[1];
	uint32_t gport_drop_on_wrong_sop_s0_cnt[1];
	uint32_t _gport_drop_on_wrong_sop_s0_cnt;
} BCM56218_A0_GPORT_DROP_ON_WRONG_SOP_S0_CNTr_t;

#define BCM56218_A0_GPORT_DROP_ON_WRONG_SOP_S0_CNTr_CLR(r) (r).gport_drop_on_wrong_sop_s0_cnt[0] = 0
#define BCM56218_A0_GPORT_DROP_ON_WRONG_SOP_S0_CNTr_SET(r,d) (r).gport_drop_on_wrong_sop_s0_cnt[0] = d
#define BCM56218_A0_GPORT_DROP_ON_WRONG_SOP_S0_CNTr_GET(r) (r).gport_drop_on_wrong_sop_s0_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_GPORT_DROP_ON_WRONG_SOP_S0_CNTr_S0_CNTf_GET(r) (((r).gport_drop_on_wrong_sop_s0_cnt[0]) & 0xffffff)
#define BCM56218_A0_GPORT_DROP_ON_WRONG_SOP_S0_CNTr_S0_CNTf_SET(r,f) (r).gport_drop_on_wrong_sop_s0_cnt[0]=(((r).gport_drop_on_wrong_sop_s0_cnt[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))

/*
 * These macros can be used to access GPORT_DROP_ON_WRONG_SOP_S0_CNT.
 *
 */
#define BCM56218_A0_READ_GPORT_DROP_ON_WRONG_SOP_S0_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GPORT_DROP_ON_WRONG_SOP_S0_CNTr,(r._gport_drop_on_wrong_sop_s0_cnt))
#define BCM56218_A0_WRITE_GPORT_DROP_ON_WRONG_SOP_S0_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GPORT_DROP_ON_WRONG_SOP_S0_CNTr,&(r._gport_drop_on_wrong_sop_s0_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GPORT_DROP_ON_WRONG_SOP_S0_CNTr BCM56218_A0_GPORT_DROP_ON_WRONG_SOP_S0_CNTr
#define GPORT_DROP_ON_WRONG_SOP_S0_CNTr_SIZE BCM56218_A0_GPORT_DROP_ON_WRONG_SOP_S0_CNTr_SIZE
typedef BCM56218_A0_GPORT_DROP_ON_WRONG_SOP_S0_CNTr_t GPORT_DROP_ON_WRONG_SOP_S0_CNTr_t;
#define GPORT_DROP_ON_WRONG_SOP_S0_CNTr_CLR BCM56218_A0_GPORT_DROP_ON_WRONG_SOP_S0_CNTr_CLR
#define GPORT_DROP_ON_WRONG_SOP_S0_CNTr_SET BCM56218_A0_GPORT_DROP_ON_WRONG_SOP_S0_CNTr_SET
#define GPORT_DROP_ON_WRONG_SOP_S0_CNTr_GET BCM56218_A0_GPORT_DROP_ON_WRONG_SOP_S0_CNTr_GET
#define GPORT_DROP_ON_WRONG_SOP_S0_CNTr_S0_CNTf_GET BCM56218_A0_GPORT_DROP_ON_WRONG_SOP_S0_CNTr_S0_CNTf_GET
#define GPORT_DROP_ON_WRONG_SOP_S0_CNTr_S0_CNTf_SET BCM56218_A0_GPORT_DROP_ON_WRONG_SOP_S0_CNTr_S0_CNTf_SET
#define READ_GPORT_DROP_ON_WRONG_SOP_S0_CNTr BCM56218_A0_READ_GPORT_DROP_ON_WRONG_SOP_S0_CNTr
#define WRITE_GPORT_DROP_ON_WRONG_SOP_S0_CNTr BCM56218_A0_WRITE_GPORT_DROP_ON_WRONG_SOP_S0_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GPORT_DROP_ON_WRONG_SOP_S0_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GPORT_DROP_ON_WRONG_SOP_S1_CNT
 * BLOCKS:   GPORT0
 * DESC:     Drop Counter against wrong K.SOP for FPORT-S1
 * SIZE:     32
 * FIELDS:
 *     S1_CNT           Counts the dropped packets because of wrong SOP Byte in FPORT-S1.
 *
 ******************************************************************************/
#define BCM56218_A0_GPORT_DROP_ON_WRONG_SOP_S1_CNTr 0x0008002b

#define BCM56218_A0_GPORT_DROP_ON_WRONG_SOP_S1_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GPORT_DROP_ON_WRONG_SOP_S1_CNT.
 *
 */
typedef union BCM56218_A0_GPORT_DROP_ON_WRONG_SOP_S1_CNTr_s {
	uint32_t v[1];
	uint32_t gport_drop_on_wrong_sop_s1_cnt[1];
	uint32_t _gport_drop_on_wrong_sop_s1_cnt;
} BCM56218_A0_GPORT_DROP_ON_WRONG_SOP_S1_CNTr_t;

#define BCM56218_A0_GPORT_DROP_ON_WRONG_SOP_S1_CNTr_CLR(r) (r).gport_drop_on_wrong_sop_s1_cnt[0] = 0
#define BCM56218_A0_GPORT_DROP_ON_WRONG_SOP_S1_CNTr_SET(r,d) (r).gport_drop_on_wrong_sop_s1_cnt[0] = d
#define BCM56218_A0_GPORT_DROP_ON_WRONG_SOP_S1_CNTr_GET(r) (r).gport_drop_on_wrong_sop_s1_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_GPORT_DROP_ON_WRONG_SOP_S1_CNTr_S1_CNTf_GET(r) (((r).gport_drop_on_wrong_sop_s1_cnt[0]) & 0xffffff)
#define BCM56218_A0_GPORT_DROP_ON_WRONG_SOP_S1_CNTr_S1_CNTf_SET(r,f) (r).gport_drop_on_wrong_sop_s1_cnt[0]=(((r).gport_drop_on_wrong_sop_s1_cnt[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))

/*
 * These macros can be used to access GPORT_DROP_ON_WRONG_SOP_S1_CNT.
 *
 */
#define BCM56218_A0_READ_GPORT_DROP_ON_WRONG_SOP_S1_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GPORT_DROP_ON_WRONG_SOP_S1_CNTr,(r._gport_drop_on_wrong_sop_s1_cnt))
#define BCM56218_A0_WRITE_GPORT_DROP_ON_WRONG_SOP_S1_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GPORT_DROP_ON_WRONG_SOP_S1_CNTr,&(r._gport_drop_on_wrong_sop_s1_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GPORT_DROP_ON_WRONG_SOP_S1_CNTr BCM56218_A0_GPORT_DROP_ON_WRONG_SOP_S1_CNTr
#define GPORT_DROP_ON_WRONG_SOP_S1_CNTr_SIZE BCM56218_A0_GPORT_DROP_ON_WRONG_SOP_S1_CNTr_SIZE
typedef BCM56218_A0_GPORT_DROP_ON_WRONG_SOP_S1_CNTr_t GPORT_DROP_ON_WRONG_SOP_S1_CNTr_t;
#define GPORT_DROP_ON_WRONG_SOP_S1_CNTr_CLR BCM56218_A0_GPORT_DROP_ON_WRONG_SOP_S1_CNTr_CLR
#define GPORT_DROP_ON_WRONG_SOP_S1_CNTr_SET BCM56218_A0_GPORT_DROP_ON_WRONG_SOP_S1_CNTr_SET
#define GPORT_DROP_ON_WRONG_SOP_S1_CNTr_GET BCM56218_A0_GPORT_DROP_ON_WRONG_SOP_S1_CNTr_GET
#define GPORT_DROP_ON_WRONG_SOP_S1_CNTr_S1_CNTf_GET BCM56218_A0_GPORT_DROP_ON_WRONG_SOP_S1_CNTr_S1_CNTf_GET
#define GPORT_DROP_ON_WRONG_SOP_S1_CNTr_S1_CNTf_SET BCM56218_A0_GPORT_DROP_ON_WRONG_SOP_S1_CNTr_S1_CNTf_SET
#define READ_GPORT_DROP_ON_WRONG_SOP_S1_CNTr BCM56218_A0_READ_GPORT_DROP_ON_WRONG_SOP_S1_CNTr
#define WRITE_GPORT_DROP_ON_WRONG_SOP_S1_CNTr BCM56218_A0_WRITE_GPORT_DROP_ON_WRONG_SOP_S1_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GPORT_DROP_ON_WRONG_SOP_S1_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GPORT_RSV_MASK
 * BLOCKS:   GPORT0
 * DESC:     GPORT RSV MASK register, used to purge packet data received from the MACs
 * SIZE:     32
 * FIELDS:
 *     MASK             Control which RSV bits cause packets to be purged
 *
 ******************************************************************************/
#define BCM56218_A0_GPORT_RSV_MASKr 0x00080001

#define BCM56218_A0_GPORT_RSV_MASKr_SIZE 4

/*
 * This structure should be used to declare and program GPORT_RSV_MASK.
 *
 */
typedef union BCM56218_A0_GPORT_RSV_MASKr_s {
	uint32_t v[1];
	uint32_t gport_rsv_mask[1];
	uint32_t _gport_rsv_mask;
} BCM56218_A0_GPORT_RSV_MASKr_t;

#define BCM56218_A0_GPORT_RSV_MASKr_CLR(r) (r).gport_rsv_mask[0] = 0
#define BCM56218_A0_GPORT_RSV_MASKr_SET(r,d) (r).gport_rsv_mask[0] = d
#define BCM56218_A0_GPORT_RSV_MASKr_GET(r) (r).gport_rsv_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_GPORT_RSV_MASKr_MASKf_GET(r) ((((r).gport_rsv_mask[0]) >> 16) & 0x7fff)
#define BCM56218_A0_GPORT_RSV_MASKr_MASKf_SET(r,f) (r).gport_rsv_mask[0]=(((r).gport_rsv_mask[0] & ~((uint32_t)0x7fff << 16)) | ((((uint32_t)f) & 0x7fff) << 16))

/*
 * These macros can be used to access GPORT_RSV_MASK.
 *
 */
#define BCM56218_A0_READ_GPORT_RSV_MASKr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GPORT_RSV_MASKr,(r._gport_rsv_mask))
#define BCM56218_A0_WRITE_GPORT_RSV_MASKr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GPORT_RSV_MASKr,&(r._gport_rsv_mask))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GPORT_RSV_MASKr BCM56218_A0_GPORT_RSV_MASKr
#define GPORT_RSV_MASKr_SIZE BCM56218_A0_GPORT_RSV_MASKr_SIZE
typedef BCM56218_A0_GPORT_RSV_MASKr_t GPORT_RSV_MASKr_t;
#define GPORT_RSV_MASKr_CLR BCM56218_A0_GPORT_RSV_MASKr_CLR
#define GPORT_RSV_MASKr_SET BCM56218_A0_GPORT_RSV_MASKr_SET
#define GPORT_RSV_MASKr_GET BCM56218_A0_GPORT_RSV_MASKr_GET
#define GPORT_RSV_MASKr_MASKf_GET BCM56218_A0_GPORT_RSV_MASKr_MASKf_GET
#define GPORT_RSV_MASKr_MASKf_SET BCM56218_A0_GPORT_RSV_MASKr_MASKf_SET
#define READ_GPORT_RSV_MASKr BCM56218_A0_READ_GPORT_RSV_MASKr
#define WRITE_GPORT_RSV_MASKr BCM56218_A0_WRITE_GPORT_RSV_MASKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GPORT_RSV_MASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GPORT_SOP_S0
 * BLOCKS:   GPORT0
 * DESC:     GPORT K.SOP used in stacking port FPORT-S0
 * SIZE:     32
 * FIELDS:
 *     K_SOP_S0         Used in FPORT-S0 for dropping packets against wrong SOP.
 *
 ******************************************************************************/
#define BCM56218_A0_GPORT_SOP_S0r 0x0008002a

#define BCM56218_A0_GPORT_SOP_S0r_SIZE 4

/*
 * This structure should be used to declare and program GPORT_SOP_S0.
 *
 */
typedef union BCM56218_A0_GPORT_SOP_S0r_s {
	uint32_t v[1];
	uint32_t gport_sop_s0[1];
	uint32_t _gport_sop_s0;
} BCM56218_A0_GPORT_SOP_S0r_t;

#define BCM56218_A0_GPORT_SOP_S0r_CLR(r) (r).gport_sop_s0[0] = 0
#define BCM56218_A0_GPORT_SOP_S0r_SET(r,d) (r).gport_sop_s0[0] = d
#define BCM56218_A0_GPORT_SOP_S0r_GET(r) (r).gport_sop_s0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_GPORT_SOP_S0r_K_SOP_S0f_GET(r) (((r).gport_sop_s0[0]) & 0xff)
#define BCM56218_A0_GPORT_SOP_S0r_K_SOP_S0f_SET(r,f) (r).gport_sop_s0[0]=(((r).gport_sop_s0[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access GPORT_SOP_S0.
 *
 */
#define BCM56218_A0_READ_GPORT_SOP_S0r(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GPORT_SOP_S0r,(r._gport_sop_s0))
#define BCM56218_A0_WRITE_GPORT_SOP_S0r(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GPORT_SOP_S0r,&(r._gport_sop_s0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GPORT_SOP_S0r BCM56218_A0_GPORT_SOP_S0r
#define GPORT_SOP_S0r_SIZE BCM56218_A0_GPORT_SOP_S0r_SIZE
typedef BCM56218_A0_GPORT_SOP_S0r_t GPORT_SOP_S0r_t;
#define GPORT_SOP_S0r_CLR BCM56218_A0_GPORT_SOP_S0r_CLR
#define GPORT_SOP_S0r_SET BCM56218_A0_GPORT_SOP_S0r_SET
#define GPORT_SOP_S0r_GET BCM56218_A0_GPORT_SOP_S0r_GET
#define GPORT_SOP_S0r_K_SOP_S0f_GET BCM56218_A0_GPORT_SOP_S0r_K_SOP_S0f_GET
#define GPORT_SOP_S0r_K_SOP_S0f_SET BCM56218_A0_GPORT_SOP_S0r_K_SOP_S0f_SET
#define READ_GPORT_SOP_S0r BCM56218_A0_READ_GPORT_SOP_S0r
#define WRITE_GPORT_SOP_S0r BCM56218_A0_WRITE_GPORT_SOP_S0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GPORT_SOP_S0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GPORT_SOP_S1
 * BLOCKS:   GPORT0
 * DESC:     GPORT K.SOP used in stacking port FPORT-S1
 * SIZE:     32
 * FIELDS:
 *     K_SOP_S1         Used in FPORT-S1 for dropping packets against wrong SOP.
 *
 ******************************************************************************/
#define BCM56218_A0_GPORT_SOP_S1r 0x00080029

#define BCM56218_A0_GPORT_SOP_S1r_SIZE 4

/*
 * This structure should be used to declare and program GPORT_SOP_S1.
 *
 */
typedef union BCM56218_A0_GPORT_SOP_S1r_s {
	uint32_t v[1];
	uint32_t gport_sop_s1[1];
	uint32_t _gport_sop_s1;
} BCM56218_A0_GPORT_SOP_S1r_t;

#define BCM56218_A0_GPORT_SOP_S1r_CLR(r) (r).gport_sop_s1[0] = 0
#define BCM56218_A0_GPORT_SOP_S1r_SET(r,d) (r).gport_sop_s1[0] = d
#define BCM56218_A0_GPORT_SOP_S1r_GET(r) (r).gport_sop_s1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_GPORT_SOP_S1r_K_SOP_S1f_GET(r) (((r).gport_sop_s1[0]) & 0xff)
#define BCM56218_A0_GPORT_SOP_S1r_K_SOP_S1f_SET(r,f) (r).gport_sop_s1[0]=(((r).gport_sop_s1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access GPORT_SOP_S1.
 *
 */
#define BCM56218_A0_READ_GPORT_SOP_S1r(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GPORT_SOP_S1r,(r._gport_sop_s1))
#define BCM56218_A0_WRITE_GPORT_SOP_S1r(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GPORT_SOP_S1r,&(r._gport_sop_s1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GPORT_SOP_S1r BCM56218_A0_GPORT_SOP_S1r
#define GPORT_SOP_S1r_SIZE BCM56218_A0_GPORT_SOP_S1r_SIZE
typedef BCM56218_A0_GPORT_SOP_S1r_t GPORT_SOP_S1r_t;
#define GPORT_SOP_S1r_CLR BCM56218_A0_GPORT_SOP_S1r_CLR
#define GPORT_SOP_S1r_SET BCM56218_A0_GPORT_SOP_S1r_SET
#define GPORT_SOP_S1r_GET BCM56218_A0_GPORT_SOP_S1r_GET
#define GPORT_SOP_S1r_K_SOP_S1f_GET BCM56218_A0_GPORT_SOP_S1r_K_SOP_S1f_GET
#define GPORT_SOP_S1r_K_SOP_S1f_SET BCM56218_A0_GPORT_SOP_S1r_K_SOP_S1f_SET
#define READ_GPORT_SOP_S1r BCM56218_A0_READ_GPORT_SOP_S1r
#define WRITE_GPORT_SOP_S1r BCM56218_A0_WRITE_GPORT_SOP_S1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GPORT_SOP_S1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GPORT_STAT_UPDATE_MASK
 * BLOCKS:   GPORT0
 * DESC:     GPORT STAT_UPDATE MASK register, used to control the statistic counter update in the Ingress
 * SIZE:     32
 * FIELDS:
 *     MASK             Control which RSV event should have the statistic counter updated in the Ingress.
 *
 ******************************************************************************/
#define BCM56218_A0_GPORT_STAT_UPDATE_MASKr 0x00080002

#define BCM56218_A0_GPORT_STAT_UPDATE_MASKr_SIZE 4

/*
 * This structure should be used to declare and program GPORT_STAT_UPDATE_MASK.
 *
 */
typedef union BCM56218_A0_GPORT_STAT_UPDATE_MASKr_s {
	uint32_t v[1];
	uint32_t gport_stat_update_mask[1];
	uint32_t _gport_stat_update_mask;
} BCM56218_A0_GPORT_STAT_UPDATE_MASKr_t;

#define BCM56218_A0_GPORT_STAT_UPDATE_MASKr_CLR(r) (r).gport_stat_update_mask[0] = 0
#define BCM56218_A0_GPORT_STAT_UPDATE_MASKr_SET(r,d) (r).gport_stat_update_mask[0] = d
#define BCM56218_A0_GPORT_STAT_UPDATE_MASKr_GET(r) (r).gport_stat_update_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_GPORT_STAT_UPDATE_MASKr_MASKf_GET(r) ((((r).gport_stat_update_mask[0]) >> 16) & 0x7fff)
#define BCM56218_A0_GPORT_STAT_UPDATE_MASKr_MASKf_SET(r,f) (r).gport_stat_update_mask[0]=(((r).gport_stat_update_mask[0] & ~((uint32_t)0x7fff << 16)) | ((((uint32_t)f) & 0x7fff) << 16))

/*
 * These macros can be used to access GPORT_STAT_UPDATE_MASK.
 *
 */
#define BCM56218_A0_READ_GPORT_STAT_UPDATE_MASKr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GPORT_STAT_UPDATE_MASKr,(r._gport_stat_update_mask))
#define BCM56218_A0_WRITE_GPORT_STAT_UPDATE_MASKr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GPORT_STAT_UPDATE_MASKr,&(r._gport_stat_update_mask))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GPORT_STAT_UPDATE_MASKr BCM56218_A0_GPORT_STAT_UPDATE_MASKr
#define GPORT_STAT_UPDATE_MASKr_SIZE BCM56218_A0_GPORT_STAT_UPDATE_MASKr_SIZE
typedef BCM56218_A0_GPORT_STAT_UPDATE_MASKr_t GPORT_STAT_UPDATE_MASKr_t;
#define GPORT_STAT_UPDATE_MASKr_CLR BCM56218_A0_GPORT_STAT_UPDATE_MASKr_CLR
#define GPORT_STAT_UPDATE_MASKr_SET BCM56218_A0_GPORT_STAT_UPDATE_MASKr_SET
#define GPORT_STAT_UPDATE_MASKr_GET BCM56218_A0_GPORT_STAT_UPDATE_MASKr_GET
#define GPORT_STAT_UPDATE_MASKr_MASKf_GET BCM56218_A0_GPORT_STAT_UPDATE_MASKr_MASKf_GET
#define GPORT_STAT_UPDATE_MASKr_MASKf_SET BCM56218_A0_GPORT_STAT_UPDATE_MASKr_MASKf_SET
#define READ_GPORT_STAT_UPDATE_MASKr BCM56218_A0_READ_GPORT_STAT_UPDATE_MASKr
#define WRITE_GPORT_STAT_UPDATE_MASKr BCM56218_A0_WRITE_GPORT_STAT_UPDATE_MASKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GPORT_STAT_UPDATE_MASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GPORT_TPID
 * BLOCKS:   GPORT0
 * DESC:     GPORT VLAN Tag Protocol ID
 * SIZE:     32
 * FIELDS:
 *     TPID             Used in TriMAC to detect VLAN tagged packets.
 *
 ******************************************************************************/
#define BCM56218_A0_GPORT_TPIDr 0x00080028

#define BCM56218_A0_GPORT_TPIDr_SIZE 4

/*
 * This structure should be used to declare and program GPORT_TPID.
 *
 */
typedef union BCM56218_A0_GPORT_TPIDr_s {
	uint32_t v[1];
	uint32_t gport_tpid[1];
	uint32_t _gport_tpid;
} BCM56218_A0_GPORT_TPIDr_t;

#define BCM56218_A0_GPORT_TPIDr_CLR(r) (r).gport_tpid[0] = 0
#define BCM56218_A0_GPORT_TPIDr_SET(r,d) (r).gport_tpid[0] = d
#define BCM56218_A0_GPORT_TPIDr_GET(r) (r).gport_tpid[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_GPORT_TPIDr_TPIDf_GET(r) (((r).gport_tpid[0]) & 0xffff)
#define BCM56218_A0_GPORT_TPIDr_TPIDf_SET(r,f) (r).gport_tpid[0]=(((r).gport_tpid[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access GPORT_TPID.
 *
 */
#define BCM56218_A0_READ_GPORT_TPIDr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GPORT_TPIDr,(r._gport_tpid))
#define BCM56218_A0_WRITE_GPORT_TPIDr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56218_A0_BLKTYPE_GPORT),p,BCM56218_A0_GPORT_TPIDr,&(r._gport_tpid))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GPORT_TPIDr BCM56218_A0_GPORT_TPIDr
#define GPORT_TPIDr_SIZE BCM56218_A0_GPORT_TPIDr_SIZE
typedef BCM56218_A0_GPORT_TPIDr_t GPORT_TPIDr_t;
#define GPORT_TPIDr_CLR BCM56218_A0_GPORT_TPIDr_CLR
#define GPORT_TPIDr_SET BCM56218_A0_GPORT_TPIDr_SET
#define GPORT_TPIDr_GET BCM56218_A0_GPORT_TPIDr_GET
#define GPORT_TPIDr_TPIDf_GET BCM56218_A0_GPORT_TPIDr_TPIDf_GET
#define GPORT_TPIDr_TPIDf_SET BCM56218_A0_GPORT_TPIDr_TPIDf_SET
#define READ_GPORT_TPIDr BCM56218_A0_READ_GPORT_TPIDr
#define WRITE_GPORT_TPIDr BCM56218_A0_WRITE_GPORT_TPIDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GPORT_TPIDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GR1023
 * BLOCKS:   GPORT0
 * DESC:     Receive 512 to 1023 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_GR1023r 0x00000015

#define BCM56218_A0_GR1023r_SIZE 4

/*
 * This structure should be used to declare and program GR1023.
 *
 */
typedef union BCM56218_A0_GR1023r_s {
	uint32_t v[1];
	uint32_t gr1023[1];
	uint32_t _gr1023;
} BCM56218_A0_GR1023r_t;

#define BCM56218_A0_GR1023r_CLR(r) (r).gr1023[0] = 0
#define BCM56218_A0_GR1023r_SET(r,d) (r).gr1023[0] = d
#define BCM56218_A0_GR1023r_GET(r) (r).gr1023[0]


/*
 * These macros can be used to access GR1023.
 *
 */
#define BCM56218_A0_READ_GR1023r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GR1023r,(r._gr1023))
#define BCM56218_A0_WRITE_GR1023r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GR1023r,&(r._gr1023))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GR1023r BCM56218_A0_GR1023r
#define GR1023r_SIZE BCM56218_A0_GR1023r_SIZE
typedef BCM56218_A0_GR1023r_t GR1023r_t;
#define GR1023r_CLR BCM56218_A0_GR1023r_CLR
#define GR1023r_SET BCM56218_A0_GR1023r_SET
#define GR1023r_GET BCM56218_A0_GR1023r_GET
#define READ_GR1023r BCM56218_A0_READ_GR1023r
#define WRITE_GR1023r BCM56218_A0_WRITE_GR1023r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GR1023r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GR127
 * BLOCKS:   GPORT0
 * DESC:     Receive 65 to 127 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_GR127r 0x00000012

#define BCM56218_A0_GR127r_SIZE 4

/*
 * This structure should be used to declare and program GR127.
 *
 */
typedef union BCM56218_A0_GR127r_s {
	uint32_t v[1];
	uint32_t gr127[1];
	uint32_t _gr127;
} BCM56218_A0_GR127r_t;

#define BCM56218_A0_GR127r_CLR(r) (r).gr127[0] = 0
#define BCM56218_A0_GR127r_SET(r,d) (r).gr127[0] = d
#define BCM56218_A0_GR127r_GET(r) (r).gr127[0]


/*
 * These macros can be used to access GR127.
 *
 */
#define BCM56218_A0_READ_GR127r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GR127r,(r._gr127))
#define BCM56218_A0_WRITE_GR127r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GR127r,&(r._gr127))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GR127r BCM56218_A0_GR127r
#define GR127r_SIZE BCM56218_A0_GR127r_SIZE
typedef BCM56218_A0_GR127r_t GR127r_t;
#define GR127r_CLR BCM56218_A0_GR127r_CLR
#define GR127r_SET BCM56218_A0_GR127r_SET
#define GR127r_GET BCM56218_A0_GR127r_GET
#define READ_GR127r BCM56218_A0_READ_GR127r
#define WRITE_GR127r BCM56218_A0_WRITE_GR127r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GR127r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GR1518
 * BLOCKS:   GPORT0
 * DESC:     Receive 1024 to 1518 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_GR1518r 0x00000016

#define BCM56218_A0_GR1518r_SIZE 4

/*
 * This structure should be used to declare and program GR1518.
 *
 */
typedef union BCM56218_A0_GR1518r_s {
	uint32_t v[1];
	uint32_t gr1518[1];
	uint32_t _gr1518;
} BCM56218_A0_GR1518r_t;

#define BCM56218_A0_GR1518r_CLR(r) (r).gr1518[0] = 0
#define BCM56218_A0_GR1518r_SET(r,d) (r).gr1518[0] = d
#define BCM56218_A0_GR1518r_GET(r) (r).gr1518[0]


/*
 * These macros can be used to access GR1518.
 *
 */
#define BCM56218_A0_READ_GR1518r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GR1518r,(r._gr1518))
#define BCM56218_A0_WRITE_GR1518r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GR1518r,&(r._gr1518))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GR1518r BCM56218_A0_GR1518r
#define GR1518r_SIZE BCM56218_A0_GR1518r_SIZE
typedef BCM56218_A0_GR1518r_t GR1518r_t;
#define GR1518r_CLR BCM56218_A0_GR1518r_CLR
#define GR1518r_SET BCM56218_A0_GR1518r_SET
#define GR1518r_GET BCM56218_A0_GR1518r_GET
#define READ_GR1518r BCM56218_A0_READ_GR1518r
#define WRITE_GR1518r BCM56218_A0_WRITE_GR1518r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GR1518r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GR2047
 * BLOCKS:   GPORT0
 * DESC:     Receive 1519 to 2047 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_GR2047r 0x00000018

#define BCM56218_A0_GR2047r_SIZE 4

/*
 * This structure should be used to declare and program GR2047.
 *
 */
typedef union BCM56218_A0_GR2047r_s {
	uint32_t v[1];
	uint32_t gr2047[1];
	uint32_t _gr2047;
} BCM56218_A0_GR2047r_t;

#define BCM56218_A0_GR2047r_CLR(r) (r).gr2047[0] = 0
#define BCM56218_A0_GR2047r_SET(r,d) (r).gr2047[0] = d
#define BCM56218_A0_GR2047r_GET(r) (r).gr2047[0]


/*
 * These macros can be used to access GR2047.
 *
 */
#define BCM56218_A0_READ_GR2047r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GR2047r,(r._gr2047))
#define BCM56218_A0_WRITE_GR2047r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GR2047r,&(r._gr2047))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GR2047r BCM56218_A0_GR2047r
#define GR2047r_SIZE BCM56218_A0_GR2047r_SIZE
typedef BCM56218_A0_GR2047r_t GR2047r_t;
#define GR2047r_CLR BCM56218_A0_GR2047r_CLR
#define GR2047r_SET BCM56218_A0_GR2047r_SET
#define GR2047r_GET BCM56218_A0_GR2047r_GET
#define READ_GR2047r BCM56218_A0_READ_GR2047r
#define WRITE_GR2047r BCM56218_A0_WRITE_GR2047r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GR2047r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GR255
 * BLOCKS:   GPORT0
 * DESC:     Receive 128 to 255 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_GR255r 0x00000013

#define BCM56218_A0_GR255r_SIZE 4

/*
 * This structure should be used to declare and program GR255.
 *
 */
typedef union BCM56218_A0_GR255r_s {
	uint32_t v[1];
	uint32_t gr255[1];
	uint32_t _gr255;
} BCM56218_A0_GR255r_t;

#define BCM56218_A0_GR255r_CLR(r) (r).gr255[0] = 0
#define BCM56218_A0_GR255r_SET(r,d) (r).gr255[0] = d
#define BCM56218_A0_GR255r_GET(r) (r).gr255[0]


/*
 * These macros can be used to access GR255.
 *
 */
#define BCM56218_A0_READ_GR255r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GR255r,(r._gr255))
#define BCM56218_A0_WRITE_GR255r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GR255r,&(r._gr255))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GR255r BCM56218_A0_GR255r
#define GR255r_SIZE BCM56218_A0_GR255r_SIZE
typedef BCM56218_A0_GR255r_t GR255r_t;
#define GR255r_CLR BCM56218_A0_GR255r_CLR
#define GR255r_SET BCM56218_A0_GR255r_SET
#define GR255r_GET BCM56218_A0_GR255r_GET
#define READ_GR255r BCM56218_A0_READ_GR255r
#define WRITE_GR255r BCM56218_A0_WRITE_GR255r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GR255r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GR4095
 * BLOCKS:   GPORT0
 * DESC:     Receive 2048 to 4095 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_GR4095r 0x00000019

#define BCM56218_A0_GR4095r_SIZE 4

/*
 * This structure should be used to declare and program GR4095.
 *
 */
typedef union BCM56218_A0_GR4095r_s {
	uint32_t v[1];
	uint32_t gr4095[1];
	uint32_t _gr4095;
} BCM56218_A0_GR4095r_t;

#define BCM56218_A0_GR4095r_CLR(r) (r).gr4095[0] = 0
#define BCM56218_A0_GR4095r_SET(r,d) (r).gr4095[0] = d
#define BCM56218_A0_GR4095r_GET(r) (r).gr4095[0]


/*
 * These macros can be used to access GR4095.
 *
 */
#define BCM56218_A0_READ_GR4095r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GR4095r,(r._gr4095))
#define BCM56218_A0_WRITE_GR4095r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GR4095r,&(r._gr4095))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GR4095r BCM56218_A0_GR4095r
#define GR4095r_SIZE BCM56218_A0_GR4095r_SIZE
typedef BCM56218_A0_GR4095r_t GR4095r_t;
#define GR4095r_CLR BCM56218_A0_GR4095r_CLR
#define GR4095r_SET BCM56218_A0_GR4095r_SET
#define GR4095r_GET BCM56218_A0_GR4095r_GET
#define READ_GR4095r BCM56218_A0_READ_GR4095r
#define WRITE_GR4095r BCM56218_A0_WRITE_GR4095r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GR4095r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GR511
 * BLOCKS:   GPORT0
 * DESC:     Receive 256 to 511 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_GR511r 0x00000014

#define BCM56218_A0_GR511r_SIZE 4

/*
 * This structure should be used to declare and program GR511.
 *
 */
typedef union BCM56218_A0_GR511r_s {
	uint32_t v[1];
	uint32_t gr511[1];
	uint32_t _gr511;
} BCM56218_A0_GR511r_t;

#define BCM56218_A0_GR511r_CLR(r) (r).gr511[0] = 0
#define BCM56218_A0_GR511r_SET(r,d) (r).gr511[0] = d
#define BCM56218_A0_GR511r_GET(r) (r).gr511[0]


/*
 * These macros can be used to access GR511.
 *
 */
#define BCM56218_A0_READ_GR511r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GR511r,(r._gr511))
#define BCM56218_A0_WRITE_GR511r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GR511r,&(r._gr511))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GR511r BCM56218_A0_GR511r
#define GR511r_SIZE BCM56218_A0_GR511r_SIZE
typedef BCM56218_A0_GR511r_t GR511r_t;
#define GR511r_CLR BCM56218_A0_GR511r_CLR
#define GR511r_SET BCM56218_A0_GR511r_SET
#define GR511r_GET BCM56218_A0_GR511r_GET
#define READ_GR511r BCM56218_A0_READ_GR511r
#define WRITE_GR511r BCM56218_A0_WRITE_GR511r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GR511r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GR64
 * BLOCKS:   GPORT0
 * DESC:     Receive 64 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_GR64r 0x00000011

#define BCM56218_A0_GR64r_SIZE 4

/*
 * This structure should be used to declare and program GR64.
 *
 */
typedef union BCM56218_A0_GR64r_s {
	uint32_t v[1];
	uint32_t gr64[1];
	uint32_t _gr64;
} BCM56218_A0_GR64r_t;

#define BCM56218_A0_GR64r_CLR(r) (r).gr64[0] = 0
#define BCM56218_A0_GR64r_SET(r,d) (r).gr64[0] = d
#define BCM56218_A0_GR64r_GET(r) (r).gr64[0]


/*
 * These macros can be used to access GR64.
 *
 */
#define BCM56218_A0_READ_GR64r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GR64r,(r._gr64))
#define BCM56218_A0_WRITE_GR64r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GR64r,&(r._gr64))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GR64r BCM56218_A0_GR64r
#define GR64r_SIZE BCM56218_A0_GR64r_SIZE
typedef BCM56218_A0_GR64r_t GR64r_t;
#define GR64r_CLR BCM56218_A0_GR64r_CLR
#define GR64r_SET BCM56218_A0_GR64r_SET
#define GR64r_GET BCM56218_A0_GR64r_GET
#define READ_GR64r BCM56218_A0_READ_GR64r
#define WRITE_GR64r BCM56218_A0_WRITE_GR64r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GR64r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GR9216
 * BLOCKS:   GPORT0
 * DESC:     Receive 4096 to 9216 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_GR9216r 0x0000001a

#define BCM56218_A0_GR9216r_SIZE 4

/*
 * This structure should be used to declare and program GR9216.
 *
 */
typedef union BCM56218_A0_GR9216r_s {
	uint32_t v[1];
	uint32_t gr9216[1];
	uint32_t _gr9216;
} BCM56218_A0_GR9216r_t;

#define BCM56218_A0_GR9216r_CLR(r) (r).gr9216[0] = 0
#define BCM56218_A0_GR9216r_SET(r,d) (r).gr9216[0] = d
#define BCM56218_A0_GR9216r_GET(r) (r).gr9216[0]


/*
 * These macros can be used to access GR9216.
 *
 */
#define BCM56218_A0_READ_GR9216r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GR9216r,(r._gr9216))
#define BCM56218_A0_WRITE_GR9216r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GR9216r,&(r._gr9216))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GR9216r BCM56218_A0_GR9216r
#define GR9216r_SIZE BCM56218_A0_GR9216r_SIZE
typedef BCM56218_A0_GR9216r_t GR9216r_t;
#define GR9216r_CLR BCM56218_A0_GR9216r_CLR
#define GR9216r_SET BCM56218_A0_GR9216r_SET
#define GR9216r_GET BCM56218_A0_GR9216r_GET
#define READ_GR9216r BCM56218_A0_READ_GR9216r
#define WRITE_GR9216r BCM56218_A0_WRITE_GR9216r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GR9216r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GRALN
 * BLOCKS:   GPORT0
 * DESC:     Receive Alignment Error Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_GRALNr 0x00000004

#define BCM56218_A0_GRALNr_SIZE 4

/*
 * This structure should be used to declare and program GRALN.
 *
 */
typedef union BCM56218_A0_GRALNr_s {
	uint32_t v[1];
	uint32_t graln[1];
	uint32_t _graln;
} BCM56218_A0_GRALNr_t;

#define BCM56218_A0_GRALNr_CLR(r) (r).graln[0] = 0
#define BCM56218_A0_GRALNr_SET(r,d) (r).graln[0] = d
#define BCM56218_A0_GRALNr_GET(r) (r).graln[0]


/*
 * These macros can be used to access GRALN.
 *
 */
#define BCM56218_A0_READ_GRALNr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GRALNr,(r._graln))
#define BCM56218_A0_WRITE_GRALNr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GRALNr,&(r._graln))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRALNr BCM56218_A0_GRALNr
#define GRALNr_SIZE BCM56218_A0_GRALNr_SIZE
typedef BCM56218_A0_GRALNr_t GRALNr_t;
#define GRALNr_CLR BCM56218_A0_GRALNr_CLR
#define GRALNr_SET BCM56218_A0_GRALNr_SET
#define GRALNr_GET BCM56218_A0_GRALNr_GET
#define READ_GRALNr BCM56218_A0_READ_GRALNr
#define WRITE_GRALNr BCM56218_A0_WRITE_GRALNr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GRALNr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GRBCA
 * BLOCKS:   GPORT0
 * DESC:     Receive Broadcast Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_GRBCAr 0x00000010

#define BCM56218_A0_GRBCAr_SIZE 4

/*
 * This structure should be used to declare and program GRBCA.
 *
 */
typedef union BCM56218_A0_GRBCAr_s {
	uint32_t v[1];
	uint32_t grbca[1];
	uint32_t _grbca;
} BCM56218_A0_GRBCAr_t;

#define BCM56218_A0_GRBCAr_CLR(r) (r).grbca[0] = 0
#define BCM56218_A0_GRBCAr_SET(r,d) (r).grbca[0] = d
#define BCM56218_A0_GRBCAr_GET(r) (r).grbca[0]


/*
 * These macros can be used to access GRBCA.
 *
 */
#define BCM56218_A0_READ_GRBCAr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GRBCAr,(r._grbca))
#define BCM56218_A0_WRITE_GRBCAr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GRBCAr,&(r._grbca))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRBCAr BCM56218_A0_GRBCAr
#define GRBCAr_SIZE BCM56218_A0_GRBCAr_SIZE
typedef BCM56218_A0_GRBCAr_t GRBCAr_t;
#define GRBCAr_CLR BCM56218_A0_GRBCAr_CLR
#define GRBCAr_SET BCM56218_A0_GRBCAr_SET
#define GRBCAr_GET BCM56218_A0_GRBCAr_GET
#define READ_GRBCAr BCM56218_A0_READ_GRBCAr
#define WRITE_GRBCAr BCM56218_A0_WRITE_GRBCAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GRBCAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GRBYT
 * BLOCKS:   GPORT0
 * DESC:     Receive Byte Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_GRBYTr 0x0000001c

#define BCM56218_A0_GRBYTr_SIZE 4

/*
 * This structure should be used to declare and program GRBYT.
 *
 */
typedef union BCM56218_A0_GRBYTr_s {
	uint32_t v[1];
	uint32_t grbyt[1];
	uint32_t _grbyt;
} BCM56218_A0_GRBYTr_t;

#define BCM56218_A0_GRBYTr_CLR(r) (r).grbyt[0] = 0
#define BCM56218_A0_GRBYTr_SET(r,d) (r).grbyt[0] = d
#define BCM56218_A0_GRBYTr_GET(r) (r).grbyt[0]


/*
 * These macros can be used to access GRBYT.
 *
 */
#define BCM56218_A0_READ_GRBYTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GRBYTr,(r._grbyt))
#define BCM56218_A0_WRITE_GRBYTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GRBYTr,&(r._grbyt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRBYTr BCM56218_A0_GRBYTr
#define GRBYTr_SIZE BCM56218_A0_GRBYTr_SIZE
typedef BCM56218_A0_GRBYTr_t GRBYTr_t;
#define GRBYTr_CLR BCM56218_A0_GRBYTr_CLR
#define GRBYTr_SET BCM56218_A0_GRBYTr_SET
#define GRBYTr_GET BCM56218_A0_GRBYTr_GET
#define READ_GRBYTr BCM56218_A0_READ_GRBYTr
#define WRITE_GRBYTr BCM56218_A0_WRITE_GRBYTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GRBYTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GRCDE
 * BLOCKS:   GPORT0
 * DESC:     Receive Code Error Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_GRCDEr 0x00000006

#define BCM56218_A0_GRCDEr_SIZE 4

/*
 * This structure should be used to declare and program GRCDE.
 *
 */
typedef union BCM56218_A0_GRCDEr_s {
	uint32_t v[1];
	uint32_t grcde[1];
	uint32_t _grcde;
} BCM56218_A0_GRCDEr_t;

#define BCM56218_A0_GRCDEr_CLR(r) (r).grcde[0] = 0
#define BCM56218_A0_GRCDEr_SET(r,d) (r).grcde[0] = d
#define BCM56218_A0_GRCDEr_GET(r) (r).grcde[0]


/*
 * These macros can be used to access GRCDE.
 *
 */
#define BCM56218_A0_READ_GRCDEr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GRCDEr,(r._grcde))
#define BCM56218_A0_WRITE_GRCDEr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GRCDEr,&(r._grcde))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRCDEr BCM56218_A0_GRCDEr
#define GRCDEr_SIZE BCM56218_A0_GRCDEr_SIZE
typedef BCM56218_A0_GRCDEr_t GRCDEr_t;
#define GRCDEr_CLR BCM56218_A0_GRCDEr_CLR
#define GRCDEr_SET BCM56218_A0_GRCDEr_SET
#define GRCDEr_GET BCM56218_A0_GRCDEr_GET
#define READ_GRCDEr BCM56218_A0_READ_GRCDEr
#define WRITE_GRCDEr BCM56218_A0_WRITE_GRCDEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GRCDEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GRFCR
 * BLOCKS:   GPORT0
 * DESC:     Receive False Carrier Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_GRFCRr 0x00000007

#define BCM56218_A0_GRFCRr_SIZE 4

/*
 * This structure should be used to declare and program GRFCR.
 *
 */
typedef union BCM56218_A0_GRFCRr_s {
	uint32_t v[1];
	uint32_t grfcr[1];
	uint32_t _grfcr;
} BCM56218_A0_GRFCRr_t;

#define BCM56218_A0_GRFCRr_CLR(r) (r).grfcr[0] = 0
#define BCM56218_A0_GRFCRr_SET(r,d) (r).grfcr[0] = d
#define BCM56218_A0_GRFCRr_GET(r) (r).grfcr[0]


/*
 * These macros can be used to access GRFCR.
 *
 */
#define BCM56218_A0_READ_GRFCRr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GRFCRr,(r._grfcr))
#define BCM56218_A0_WRITE_GRFCRr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GRFCRr,&(r._grfcr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRFCRr BCM56218_A0_GRFCRr
#define GRFCRr_SIZE BCM56218_A0_GRFCRr_SIZE
typedef BCM56218_A0_GRFCRr_t GRFCRr_t;
#define GRFCRr_CLR BCM56218_A0_GRFCRr_CLR
#define GRFCRr_SET BCM56218_A0_GRFCRr_SET
#define GRFCRr_GET BCM56218_A0_GRFCRr_GET
#define READ_GRFCRr BCM56218_A0_READ_GRFCRr
#define WRITE_GRFCRr BCM56218_A0_WRITE_GRFCRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GRFCRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GRFCS
 * BLOCKS:   GPORT0
 * DESC:     Receive FCS Error Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_GRFCSr 0x00000000

#define BCM56218_A0_GRFCSr_SIZE 4

/*
 * This structure should be used to declare and program GRFCS.
 *
 */
typedef union BCM56218_A0_GRFCSr_s {
	uint32_t v[1];
	uint32_t grfcs[1];
	uint32_t _grfcs;
} BCM56218_A0_GRFCSr_t;

#define BCM56218_A0_GRFCSr_CLR(r) (r).grfcs[0] = 0
#define BCM56218_A0_GRFCSr_SET(r,d) (r).grfcs[0] = d
#define BCM56218_A0_GRFCSr_GET(r) (r).grfcs[0]


/*
 * These macros can be used to access GRFCS.
 *
 */
#define BCM56218_A0_READ_GRFCSr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GRFCSr,(r._grfcs))
#define BCM56218_A0_WRITE_GRFCSr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GRFCSr,&(r._grfcs))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRFCSr BCM56218_A0_GRFCSr
#define GRFCSr_SIZE BCM56218_A0_GRFCSr_SIZE
typedef BCM56218_A0_GRFCSr_t GRFCSr_t;
#define GRFCSr_CLR BCM56218_A0_GRFCSr_CLR
#define GRFCSr_SET BCM56218_A0_GRFCSr_SET
#define GRFCSr_GET BCM56218_A0_GRFCSr_GET
#define READ_GRFCSr BCM56218_A0_READ_GRFCSr
#define WRITE_GRFCSr BCM56218_A0_WRITE_GRFCSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GRFCSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GRFLR
 * BLOCKS:   GPORT0
 * DESC:     Receive Length Out of Range Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_GRFLRr 0x00000005

#define BCM56218_A0_GRFLRr_SIZE 4

/*
 * This structure should be used to declare and program GRFLR.
 *
 */
typedef union BCM56218_A0_GRFLRr_s {
	uint32_t v[1];
	uint32_t grflr[1];
	uint32_t _grflr;
} BCM56218_A0_GRFLRr_t;

#define BCM56218_A0_GRFLRr_CLR(r) (r).grflr[0] = 0
#define BCM56218_A0_GRFLRr_SET(r,d) (r).grflr[0] = d
#define BCM56218_A0_GRFLRr_GET(r) (r).grflr[0]


/*
 * These macros can be used to access GRFLR.
 *
 */
#define BCM56218_A0_READ_GRFLRr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GRFLRr,(r._grflr))
#define BCM56218_A0_WRITE_GRFLRr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GRFLRr,&(r._grflr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRFLRr BCM56218_A0_GRFLRr
#define GRFLRr_SIZE BCM56218_A0_GRFLRr_SIZE
typedef BCM56218_A0_GRFLRr_t GRFLRr_t;
#define GRFLRr_CLR BCM56218_A0_GRFLRr_CLR
#define GRFLRr_SET BCM56218_A0_GRFLRr_SET
#define GRFLRr_GET BCM56218_A0_GRFLRr_GET
#define READ_GRFLRr BCM56218_A0_READ_GRFLRr
#define WRITE_GRFLRr BCM56218_A0_WRITE_GRFLRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GRFLRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GRFRG
 * BLOCKS:   GPORT0
 * DESC:     Receive Fragment Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_GRFRGr 0x0000000d

#define BCM56218_A0_GRFRGr_SIZE 4

/*
 * This structure should be used to declare and program GRFRG.
 *
 */
typedef union BCM56218_A0_GRFRGr_s {
	uint32_t v[1];
	uint32_t grfrg[1];
	uint32_t _grfrg;
} BCM56218_A0_GRFRGr_t;

#define BCM56218_A0_GRFRGr_CLR(r) (r).grfrg[0] = 0
#define BCM56218_A0_GRFRGr_SET(r,d) (r).grfrg[0] = d
#define BCM56218_A0_GRFRGr_GET(r) (r).grfrg[0]


/*
 * These macros can be used to access GRFRG.
 *
 */
#define BCM56218_A0_READ_GRFRGr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GRFRGr,(r._grfrg))
#define BCM56218_A0_WRITE_GRFRGr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GRFRGr,&(r._grfrg))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRFRGr BCM56218_A0_GRFRGr
#define GRFRGr_SIZE BCM56218_A0_GRFRGr_SIZE
typedef BCM56218_A0_GRFRGr_t GRFRGr_t;
#define GRFRGr_CLR BCM56218_A0_GRFRGr_CLR
#define GRFRGr_SET BCM56218_A0_GRFRGr_SET
#define GRFRGr_GET BCM56218_A0_GRFRGr_GET
#define READ_GRFRGr BCM56218_A0_READ_GRFRGr
#define WRITE_GRFRGr BCM56218_A0_WRITE_GRFRGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GRFRGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GRJBR
 * BLOCKS:   GPORT0
 * DESC:     Receive Jabber Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_GRJBRr 0x00000009

#define BCM56218_A0_GRJBRr_SIZE 4

/*
 * This structure should be used to declare and program GRJBR.
 *
 */
typedef union BCM56218_A0_GRJBRr_s {
	uint32_t v[1];
	uint32_t grjbr[1];
	uint32_t _grjbr;
} BCM56218_A0_GRJBRr_t;

#define BCM56218_A0_GRJBRr_CLR(r) (r).grjbr[0] = 0
#define BCM56218_A0_GRJBRr_SET(r,d) (r).grjbr[0] = d
#define BCM56218_A0_GRJBRr_GET(r) (r).grjbr[0]


/*
 * These macros can be used to access GRJBR.
 *
 */
#define BCM56218_A0_READ_GRJBRr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GRJBRr,(r._grjbr))
#define BCM56218_A0_WRITE_GRJBRr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GRJBRr,&(r._grjbr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRJBRr BCM56218_A0_GRJBRr
#define GRJBRr_SIZE BCM56218_A0_GRJBRr_SIZE
typedef BCM56218_A0_GRJBRr_t GRJBRr_t;
#define GRJBRr_CLR BCM56218_A0_GRJBRr_CLR
#define GRJBRr_SET BCM56218_A0_GRJBRr_SET
#define GRJBRr_GET BCM56218_A0_GRJBRr_GET
#define READ_GRJBRr BCM56218_A0_READ_GRJBRr
#define WRITE_GRJBRr BCM56218_A0_WRITE_GRJBRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GRJBRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GRMCA
 * BLOCKS:   GPORT0
 * DESC:     Receive Multicast Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_GRMCAr 0x0000000f

#define BCM56218_A0_GRMCAr_SIZE 4

/*
 * This structure should be used to declare and program GRMCA.
 *
 */
typedef union BCM56218_A0_GRMCAr_s {
	uint32_t v[1];
	uint32_t grmca[1];
	uint32_t _grmca;
} BCM56218_A0_GRMCAr_t;

#define BCM56218_A0_GRMCAr_CLR(r) (r).grmca[0] = 0
#define BCM56218_A0_GRMCAr_SET(r,d) (r).grmca[0] = d
#define BCM56218_A0_GRMCAr_GET(r) (r).grmca[0]


/*
 * These macros can be used to access GRMCA.
 *
 */
#define BCM56218_A0_READ_GRMCAr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GRMCAr,(r._grmca))
#define BCM56218_A0_WRITE_GRMCAr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GRMCAr,&(r._grmca))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRMCAr BCM56218_A0_GRMCAr
#define GRMCAr_SIZE BCM56218_A0_GRMCAr_SIZE
typedef BCM56218_A0_GRMCAr_t GRMCAr_t;
#define GRMCAr_CLR BCM56218_A0_GRMCAr_CLR
#define GRMCAr_SET BCM56218_A0_GRMCAr_SET
#define GRMCAr_GET BCM56218_A0_GRMCAr_GET
#define READ_GRMCAr BCM56218_A0_READ_GRMCAr
#define WRITE_GRMCAr BCM56218_A0_WRITE_GRMCAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GRMCAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GRMGV
 * BLOCKS:   GPORT0
 * DESC:     Receive 1519 to 1522 Byte Good VLAN Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_GRMGVr 0x00000017

#define BCM56218_A0_GRMGVr_SIZE 4

/*
 * This structure should be used to declare and program GRMGV.
 *
 */
typedef union BCM56218_A0_GRMGVr_s {
	uint32_t v[1];
	uint32_t grmgv[1];
	uint32_t _grmgv;
} BCM56218_A0_GRMGVr_t;

#define BCM56218_A0_GRMGVr_CLR(r) (r).grmgv[0] = 0
#define BCM56218_A0_GRMGVr_SET(r,d) (r).grmgv[0] = d
#define BCM56218_A0_GRMGVr_GET(r) (r).grmgv[0]


/*
 * These macros can be used to access GRMGV.
 *
 */
#define BCM56218_A0_READ_GRMGVr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GRMGVr,(r._grmgv))
#define BCM56218_A0_WRITE_GRMGVr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GRMGVr,&(r._grmgv))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRMGVr BCM56218_A0_GRMGVr
#define GRMGVr_SIZE BCM56218_A0_GRMGVr_SIZE
typedef BCM56218_A0_GRMGVr_t GRMGVr_t;
#define GRMGVr_CLR BCM56218_A0_GRMGVr_CLR
#define GRMGVr_SET BCM56218_A0_GRMGVr_SET
#define GRMGVr_GET BCM56218_A0_GRMGVr_GET
#define READ_GRMGVr BCM56218_A0_READ_GRMGVr
#define WRITE_GRMGVr BCM56218_A0_WRITE_GRMGVr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GRMGVr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GRMTUE
 * BLOCKS:   GPORT0
 * DESC:     Receive MTU Check Error Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_GRMTUEr 0x0000000a

#define BCM56218_A0_GRMTUEr_SIZE 4

/*
 * This structure should be used to declare and program GRMTUE.
 *
 */
typedef union BCM56218_A0_GRMTUEr_s {
	uint32_t v[1];
	uint32_t grmtue[1];
	uint32_t _grmtue;
} BCM56218_A0_GRMTUEr_t;

#define BCM56218_A0_GRMTUEr_CLR(r) (r).grmtue[0] = 0
#define BCM56218_A0_GRMTUEr_SET(r,d) (r).grmtue[0] = d
#define BCM56218_A0_GRMTUEr_GET(r) (r).grmtue[0]


/*
 * These macros can be used to access GRMTUE.
 *
 */
#define BCM56218_A0_READ_GRMTUEr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GRMTUEr,(r._grmtue))
#define BCM56218_A0_WRITE_GRMTUEr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GRMTUEr,&(r._grmtue))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRMTUEr BCM56218_A0_GRMTUEr
#define GRMTUEr_SIZE BCM56218_A0_GRMTUEr_SIZE
typedef BCM56218_A0_GRMTUEr_t GRMTUEr_t;
#define GRMTUEr_CLR BCM56218_A0_GRMTUEr_CLR
#define GRMTUEr_SET BCM56218_A0_GRMTUEr_SET
#define GRMTUEr_GET BCM56218_A0_GRMTUEr_GET
#define READ_GRMTUEr BCM56218_A0_READ_GRMTUEr
#define WRITE_GRMTUEr BCM56218_A0_WRITE_GRMTUEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GRMTUEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GROVR
 * BLOCKS:   GPORT0
 * DESC:     Receive Oversized Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_GROVRr 0x00000008

#define BCM56218_A0_GROVRr_SIZE 4

/*
 * This structure should be used to declare and program GROVR.
 *
 */
typedef union BCM56218_A0_GROVRr_s {
	uint32_t v[1];
	uint32_t grovr[1];
	uint32_t _grovr;
} BCM56218_A0_GROVRr_t;

#define BCM56218_A0_GROVRr_CLR(r) (r).grovr[0] = 0
#define BCM56218_A0_GROVRr_SET(r,d) (r).grovr[0] = d
#define BCM56218_A0_GROVRr_GET(r) (r).grovr[0]


/*
 * These macros can be used to access GROVR.
 *
 */
#define BCM56218_A0_READ_GROVRr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GROVRr,(r._grovr))
#define BCM56218_A0_WRITE_GROVRr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GROVRr,&(r._grovr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GROVRr BCM56218_A0_GROVRr
#define GROVRr_SIZE BCM56218_A0_GROVRr_SIZE
typedef BCM56218_A0_GROVRr_t GROVRr_t;
#define GROVRr_CLR BCM56218_A0_GROVRr_CLR
#define GROVRr_SET BCM56218_A0_GROVRr_SET
#define GROVRr_GET BCM56218_A0_GROVRr_GET
#define READ_GROVRr BCM56218_A0_READ_GROVRr
#define WRITE_GROVRr BCM56218_A0_WRITE_GROVRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GROVRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GRPKT
 * BLOCKS:   GPORT0
 * DESC:     Receive frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_GRPKTr 0x0000001b

#define BCM56218_A0_GRPKTr_SIZE 4

/*
 * This structure should be used to declare and program GRPKT.
 *
 */
typedef union BCM56218_A0_GRPKTr_s {
	uint32_t v[1];
	uint32_t grpkt[1];
	uint32_t _grpkt;
} BCM56218_A0_GRPKTr_t;

#define BCM56218_A0_GRPKTr_CLR(r) (r).grpkt[0] = 0
#define BCM56218_A0_GRPKTr_SET(r,d) (r).grpkt[0] = d
#define BCM56218_A0_GRPKTr_GET(r) (r).grpkt[0]


/*
 * These macros can be used to access GRPKT.
 *
 */
#define BCM56218_A0_READ_GRPKTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GRPKTr,(r._grpkt))
#define BCM56218_A0_WRITE_GRPKTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GRPKTr,&(r._grpkt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRPKTr BCM56218_A0_GRPKTr
#define GRPKTr_SIZE BCM56218_A0_GRPKTr_SIZE
typedef BCM56218_A0_GRPKTr_t GRPKTr_t;
#define GRPKTr_CLR BCM56218_A0_GRPKTr_CLR
#define GRPKTr_SET BCM56218_A0_GRPKTr_SET
#define GRPKTr_GET BCM56218_A0_GRPKTr_GET
#define READ_GRPKTr BCM56218_A0_READ_GRPKTr
#define WRITE_GRPKTr BCM56218_A0_WRITE_GRPKTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GRPKTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GRPOK
 * BLOCKS:   GPORT0
 * DESC:     Received Packets OK Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_GRPOKr 0x0000001e

#define BCM56218_A0_GRPOKr_SIZE 4

/*
 * This structure should be used to declare and program GRPOK.
 *
 */
typedef union BCM56218_A0_GRPOKr_s {
	uint32_t v[1];
	uint32_t grpok[1];
	uint32_t _grpok;
} BCM56218_A0_GRPOKr_t;

#define BCM56218_A0_GRPOKr_CLR(r) (r).grpok[0] = 0
#define BCM56218_A0_GRPOKr_SET(r,d) (r).grpok[0] = d
#define BCM56218_A0_GRPOKr_GET(r) (r).grpok[0]


/*
 * These macros can be used to access GRPOK.
 *
 */
#define BCM56218_A0_READ_GRPOKr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GRPOKr,(r._grpok))
#define BCM56218_A0_WRITE_GRPOKr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GRPOKr,&(r._grpok))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRPOKr BCM56218_A0_GRPOKr
#define GRPOKr_SIZE BCM56218_A0_GRPOKr_SIZE
typedef BCM56218_A0_GRPOKr_t GRPOKr_t;
#define GRPOKr_CLR BCM56218_A0_GRPOKr_CLR
#define GRPOKr_SET BCM56218_A0_GRPOKr_SET
#define GRPOKr_GET BCM56218_A0_GRPOKr_GET
#define READ_GRPOKr BCM56218_A0_READ_GRPOKr
#define WRITE_GRPOKr BCM56218_A0_WRITE_GRPOKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GRPOKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GRUC
 * BLOCKS:   GPORT0
 * DESC:     Receive Unicast Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_GRUCr 0x0000001d

#define BCM56218_A0_GRUCr_SIZE 4

/*
 * This structure should be used to declare and program GRUC.
 *
 */
typedef union BCM56218_A0_GRUCr_s {
	uint32_t v[1];
	uint32_t gruc[1];
	uint32_t _gruc;
} BCM56218_A0_GRUCr_t;

#define BCM56218_A0_GRUCr_CLR(r) (r).gruc[0] = 0
#define BCM56218_A0_GRUCr_SET(r,d) (r).gruc[0] = d
#define BCM56218_A0_GRUCr_GET(r) (r).gruc[0]


/*
 * These macros can be used to access GRUC.
 *
 */
#define BCM56218_A0_READ_GRUCr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GRUCr,(r._gruc))
#define BCM56218_A0_WRITE_GRUCr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GRUCr,&(r._gruc))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRUCr BCM56218_A0_GRUCr
#define GRUCr_SIZE BCM56218_A0_GRUCr_SIZE
typedef BCM56218_A0_GRUCr_t GRUCr_t;
#define GRUCr_CLR BCM56218_A0_GRUCr_CLR
#define GRUCr_SET BCM56218_A0_GRUCr_SET
#define GRUCr_GET BCM56218_A0_GRUCr_GET
#define READ_GRUCr BCM56218_A0_READ_GRUCr
#define WRITE_GRUCr BCM56218_A0_WRITE_GRUCr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GRUCr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GRUND
 * BLOCKS:   GPORT0
 * DESC:     Receive Undersize Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_GRUNDr 0x0000000c

#define BCM56218_A0_GRUNDr_SIZE 4

/*
 * This structure should be used to declare and program GRUND.
 *
 */
typedef union BCM56218_A0_GRUNDr_s {
	uint32_t v[1];
	uint32_t grund[1];
	uint32_t _grund;
} BCM56218_A0_GRUNDr_t;

#define BCM56218_A0_GRUNDr_CLR(r) (r).grund[0] = 0
#define BCM56218_A0_GRUNDr_SET(r,d) (r).grund[0] = d
#define BCM56218_A0_GRUNDr_GET(r) (r).grund[0]


/*
 * These macros can be used to access GRUND.
 *
 */
#define BCM56218_A0_READ_GRUNDr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GRUNDr,(r._grund))
#define BCM56218_A0_WRITE_GRUNDr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GRUNDr,&(r._grund))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRUNDr BCM56218_A0_GRUNDr
#define GRUNDr_SIZE BCM56218_A0_GRUNDr_SIZE
typedef BCM56218_A0_GRUNDr_t GRUNDr_t;
#define GRUNDr_CLR BCM56218_A0_GRUNDr_CLR
#define GRUNDr_SET BCM56218_A0_GRUNDr_SET
#define GRUNDr_GET BCM56218_A0_GRUNDr_GET
#define READ_GRUNDr BCM56218_A0_READ_GRUNDr
#define WRITE_GRUNDr BCM56218_A0_WRITE_GRUNDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GRUNDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GRXCF
 * BLOCKS:   GPORT0
 * DESC:     Receive Control Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_GRXCFr 0x00000001

#define BCM56218_A0_GRXCFr_SIZE 4

/*
 * This structure should be used to declare and program GRXCF.
 *
 */
typedef union BCM56218_A0_GRXCFr_s {
	uint32_t v[1];
	uint32_t grxcf[1];
	uint32_t _grxcf;
} BCM56218_A0_GRXCFr_t;

#define BCM56218_A0_GRXCFr_CLR(r) (r).grxcf[0] = 0
#define BCM56218_A0_GRXCFr_SET(r,d) (r).grxcf[0] = d
#define BCM56218_A0_GRXCFr_GET(r) (r).grxcf[0]


/*
 * These macros can be used to access GRXCF.
 *
 */
#define BCM56218_A0_READ_GRXCFr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GRXCFr,(r._grxcf))
#define BCM56218_A0_WRITE_GRXCFr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GRXCFr,&(r._grxcf))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRXCFr BCM56218_A0_GRXCFr
#define GRXCFr_SIZE BCM56218_A0_GRXCFr_SIZE
typedef BCM56218_A0_GRXCFr_t GRXCFr_t;
#define GRXCFr_CLR BCM56218_A0_GRXCFr_CLR
#define GRXCFr_SET BCM56218_A0_GRXCFr_SET
#define GRXCFr_GET BCM56218_A0_GRXCFr_GET
#define READ_GRXCFr BCM56218_A0_READ_GRXCFr
#define WRITE_GRXCFr BCM56218_A0_WRITE_GRXCFr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GRXCFr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GRXPF
 * BLOCKS:   GPORT0
 * DESC:     Receive Pause Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_GRXPFr 0x00000002

#define BCM56218_A0_GRXPFr_SIZE 4

/*
 * This structure should be used to declare and program GRXPF.
 *
 */
typedef union BCM56218_A0_GRXPFr_s {
	uint32_t v[1];
	uint32_t grxpf[1];
	uint32_t _grxpf;
} BCM56218_A0_GRXPFr_t;

#define BCM56218_A0_GRXPFr_CLR(r) (r).grxpf[0] = 0
#define BCM56218_A0_GRXPFr_SET(r,d) (r).grxpf[0] = d
#define BCM56218_A0_GRXPFr_GET(r) (r).grxpf[0]


/*
 * These macros can be used to access GRXPF.
 *
 */
#define BCM56218_A0_READ_GRXPFr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GRXPFr,(r._grxpf))
#define BCM56218_A0_WRITE_GRXPFr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GRXPFr,&(r._grxpf))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRXPFr BCM56218_A0_GRXPFr
#define GRXPFr_SIZE BCM56218_A0_GRXPFr_SIZE
typedef BCM56218_A0_GRXPFr_t GRXPFr_t;
#define GRXPFr_CLR BCM56218_A0_GRXPFr_CLR
#define GRXPFr_SET BCM56218_A0_GRXPFr_SET
#define GRXPFr_GET BCM56218_A0_GRXPFr_GET
#define READ_GRXPFr BCM56218_A0_READ_GRXPFr
#define WRITE_GRXPFr BCM56218_A0_WRITE_GRXPFr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GRXPFr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GRXUO
 * BLOCKS:   GPORT0
 * DESC:     Receive Unsupported Opcode Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_GRXUOr 0x00000003

#define BCM56218_A0_GRXUOr_SIZE 4

/*
 * This structure should be used to declare and program GRXUO.
 *
 */
typedef union BCM56218_A0_GRXUOr_s {
	uint32_t v[1];
	uint32_t grxuo[1];
	uint32_t _grxuo;
} BCM56218_A0_GRXUOr_t;

#define BCM56218_A0_GRXUOr_CLR(r) (r).grxuo[0] = 0
#define BCM56218_A0_GRXUOr_SET(r,d) (r).grxuo[0] = d
#define BCM56218_A0_GRXUOr_GET(r) (r).grxuo[0]


/*
 * These macros can be used to access GRXUO.
 *
 */
#define BCM56218_A0_READ_GRXUOr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GRXUOr,(r._grxuo))
#define BCM56218_A0_WRITE_GRXUOr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GRXUOr,&(r._grxuo))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRXUOr BCM56218_A0_GRXUOr
#define GRXUOr_SIZE BCM56218_A0_GRXUOr_SIZE
typedef BCM56218_A0_GRXUOr_t GRXUOr_t;
#define GRXUOr_CLR BCM56218_A0_GRXUOr_CLR
#define GRXUOr_SET BCM56218_A0_GRXUOr_SET
#define GRXUOr_GET BCM56218_A0_GRXUOr_GET
#define READ_GRXUOr BCM56218_A0_READ_GRXUOr
#define WRITE_GRXUOr BCM56218_A0_WRITE_GRXUOr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GRXUOr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GSA0
 * BLOCKS:   GPORT0
 * DESC:     Station Address 31:0
 * SIZE:     32
 * FIELDS:
 *     STAD1            STAD bits 47:16
 *
 ******************************************************************************/
#define BCM56218_A0_GSA0r 0x00000104

#define BCM56218_A0_GSA0r_SIZE 4

/*
 * This structure should be used to declare and program GSA0.
 *
 */
typedef union BCM56218_A0_GSA0r_s {
	uint32_t v[1];
	uint32_t gsa0[1];
	uint32_t _gsa0;
} BCM56218_A0_GSA0r_t;

#define BCM56218_A0_GSA0r_CLR(r) (r).gsa0[0] = 0
#define BCM56218_A0_GSA0r_SET(r,d) (r).gsa0[0] = d
#define BCM56218_A0_GSA0r_GET(r) (r).gsa0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_GSA0r_STAD1f_GET(r) ((r).gsa0[0])
#define BCM56218_A0_GSA0r_STAD1f_SET(r,f) (r).gsa0[0]=((uint32_t)f)

/*
 * These macros can be used to access GSA0.
 *
 */
#define BCM56218_A0_READ_GSA0r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GSA0r,(r._gsa0))
#define BCM56218_A0_WRITE_GSA0r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GSA0r,&(r._gsa0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GSA0r BCM56218_A0_GSA0r
#define GSA0r_SIZE BCM56218_A0_GSA0r_SIZE
typedef BCM56218_A0_GSA0r_t GSA0r_t;
#define GSA0r_CLR BCM56218_A0_GSA0r_CLR
#define GSA0r_SET BCM56218_A0_GSA0r_SET
#define GSA0r_GET BCM56218_A0_GSA0r_GET
#define GSA0r_STAD1f_GET BCM56218_A0_GSA0r_STAD1f_GET
#define GSA0r_STAD1f_SET BCM56218_A0_GSA0r_STAD1f_SET
#define READ_GSA0r BCM56218_A0_READ_GSA0r
#define WRITE_GSA0r BCM56218_A0_WRITE_GSA0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GSA0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GSA1
 * BLOCKS:   GPORT0
 * DESC:     Station Address 47:32
 * SIZE:     32
 * FIELDS:
 *     STAD2            STAD bits 15:0
 *
 ******************************************************************************/
#define BCM56218_A0_GSA1r 0x00000105

#define BCM56218_A0_GSA1r_SIZE 4

/*
 * This structure should be used to declare and program GSA1.
 *
 */
typedef union BCM56218_A0_GSA1r_s {
	uint32_t v[1];
	uint32_t gsa1[1];
	uint32_t _gsa1;
} BCM56218_A0_GSA1r_t;

#define BCM56218_A0_GSA1r_CLR(r) (r).gsa1[0] = 0
#define BCM56218_A0_GSA1r_SET(r,d) (r).gsa1[0] = d
#define BCM56218_A0_GSA1r_GET(r) (r).gsa1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_GSA1r_STAD2f_GET(r) ((((r).gsa1[0]) >> 16) & 0xffff)
#define BCM56218_A0_GSA1r_STAD2f_SET(r,f) (r).gsa1[0]=(((r).gsa1[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access GSA1.
 *
 */
#define BCM56218_A0_READ_GSA1r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GSA1r,(r._gsa1))
#define BCM56218_A0_WRITE_GSA1r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GSA1r,&(r._gsa1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GSA1r BCM56218_A0_GSA1r
#define GSA1r_SIZE BCM56218_A0_GSA1r_SIZE
typedef BCM56218_A0_GSA1r_t GSA1r_t;
#define GSA1r_CLR BCM56218_A0_GSA1r_CLR
#define GSA1r_SET BCM56218_A0_GSA1r_SET
#define GSA1r_GET BCM56218_A0_GSA1r_GET
#define GSA1r_STAD2f_GET BCM56218_A0_GSA1r_STAD2f_GET
#define GSA1r_STAD2f_SET BCM56218_A0_GSA1r_STAD2f_SET
#define READ_GSA1r BCM56218_A0_READ_GSA1r
#define WRITE_GSA1r BCM56218_A0_WRITE_GSA1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GSA1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GT1023
 * BLOCKS:   GPORT0
 * DESC:     Transmit 512 to 1023 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_GT1023r 0x00000032

#define BCM56218_A0_GT1023r_SIZE 4

/*
 * This structure should be used to declare and program GT1023.
 *
 */
typedef union BCM56218_A0_GT1023r_s {
	uint32_t v[1];
	uint32_t gt1023[1];
	uint32_t _gt1023;
} BCM56218_A0_GT1023r_t;

#define BCM56218_A0_GT1023r_CLR(r) (r).gt1023[0] = 0
#define BCM56218_A0_GT1023r_SET(r,d) (r).gt1023[0] = d
#define BCM56218_A0_GT1023r_GET(r) (r).gt1023[0]


/*
 * These macros can be used to access GT1023.
 *
 */
#define BCM56218_A0_READ_GT1023r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GT1023r,(r._gt1023))
#define BCM56218_A0_WRITE_GT1023r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GT1023r,&(r._gt1023))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GT1023r BCM56218_A0_GT1023r
#define GT1023r_SIZE BCM56218_A0_GT1023r_SIZE
typedef BCM56218_A0_GT1023r_t GT1023r_t;
#define GT1023r_CLR BCM56218_A0_GT1023r_CLR
#define GT1023r_SET BCM56218_A0_GT1023r_SET
#define GT1023r_GET BCM56218_A0_GT1023r_GET
#define READ_GT1023r BCM56218_A0_READ_GT1023r
#define WRITE_GT1023r BCM56218_A0_WRITE_GT1023r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GT1023r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GT127
 * BLOCKS:   GPORT0
 * DESC:     Transmit 65 to 127 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_GT127r 0x0000002f

#define BCM56218_A0_GT127r_SIZE 4

/*
 * This structure should be used to declare and program GT127.
 *
 */
typedef union BCM56218_A0_GT127r_s {
	uint32_t v[1];
	uint32_t gt127[1];
	uint32_t _gt127;
} BCM56218_A0_GT127r_t;

#define BCM56218_A0_GT127r_CLR(r) (r).gt127[0] = 0
#define BCM56218_A0_GT127r_SET(r,d) (r).gt127[0] = d
#define BCM56218_A0_GT127r_GET(r) (r).gt127[0]


/*
 * These macros can be used to access GT127.
 *
 */
#define BCM56218_A0_READ_GT127r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GT127r,(r._gt127))
#define BCM56218_A0_WRITE_GT127r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GT127r,&(r._gt127))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GT127r BCM56218_A0_GT127r
#define GT127r_SIZE BCM56218_A0_GT127r_SIZE
typedef BCM56218_A0_GT127r_t GT127r_t;
#define GT127r_CLR BCM56218_A0_GT127r_CLR
#define GT127r_SET BCM56218_A0_GT127r_SET
#define GT127r_GET BCM56218_A0_GT127r_GET
#define READ_GT127r BCM56218_A0_READ_GT127r
#define WRITE_GT127r BCM56218_A0_WRITE_GT127r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GT127r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GT1518
 * BLOCKS:   GPORT0
 * DESC:     Transmit 1024 to 1518 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_GT1518r 0x00000033

#define BCM56218_A0_GT1518r_SIZE 4

/*
 * This structure should be used to declare and program GT1518.
 *
 */
typedef union BCM56218_A0_GT1518r_s {
	uint32_t v[1];
	uint32_t gt1518[1];
	uint32_t _gt1518;
} BCM56218_A0_GT1518r_t;

#define BCM56218_A0_GT1518r_CLR(r) (r).gt1518[0] = 0
#define BCM56218_A0_GT1518r_SET(r,d) (r).gt1518[0] = d
#define BCM56218_A0_GT1518r_GET(r) (r).gt1518[0]


/*
 * These macros can be used to access GT1518.
 *
 */
#define BCM56218_A0_READ_GT1518r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GT1518r,(r._gt1518))
#define BCM56218_A0_WRITE_GT1518r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GT1518r,&(r._gt1518))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GT1518r BCM56218_A0_GT1518r
#define GT1518r_SIZE BCM56218_A0_GT1518r_SIZE
typedef BCM56218_A0_GT1518r_t GT1518r_t;
#define GT1518r_CLR BCM56218_A0_GT1518r_CLR
#define GT1518r_SET BCM56218_A0_GT1518r_SET
#define GT1518r_GET BCM56218_A0_GT1518r_GET
#define READ_GT1518r BCM56218_A0_READ_GT1518r
#define WRITE_GT1518r BCM56218_A0_WRITE_GT1518r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GT1518r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GT2047
 * BLOCKS:   GPORT0
 * DESC:     Transmit 1519 to 2047 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_GT2047r 0x00000035

#define BCM56218_A0_GT2047r_SIZE 4

/*
 * This structure should be used to declare and program GT2047.
 *
 */
typedef union BCM56218_A0_GT2047r_s {
	uint32_t v[1];
	uint32_t gt2047[1];
	uint32_t _gt2047;
} BCM56218_A0_GT2047r_t;

#define BCM56218_A0_GT2047r_CLR(r) (r).gt2047[0] = 0
#define BCM56218_A0_GT2047r_SET(r,d) (r).gt2047[0] = d
#define BCM56218_A0_GT2047r_GET(r) (r).gt2047[0]


/*
 * These macros can be used to access GT2047.
 *
 */
#define BCM56218_A0_READ_GT2047r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GT2047r,(r._gt2047))
#define BCM56218_A0_WRITE_GT2047r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GT2047r,&(r._gt2047))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GT2047r BCM56218_A0_GT2047r
#define GT2047r_SIZE BCM56218_A0_GT2047r_SIZE
typedef BCM56218_A0_GT2047r_t GT2047r_t;
#define GT2047r_CLR BCM56218_A0_GT2047r_CLR
#define GT2047r_SET BCM56218_A0_GT2047r_SET
#define GT2047r_GET BCM56218_A0_GT2047r_GET
#define READ_GT2047r BCM56218_A0_READ_GT2047r
#define WRITE_GT2047r BCM56218_A0_WRITE_GT2047r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GT2047r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GT255
 * BLOCKS:   GPORT0
 * DESC:     Transmit 128 to 255 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_GT255r 0x00000030

#define BCM56218_A0_GT255r_SIZE 4

/*
 * This structure should be used to declare and program GT255.
 *
 */
typedef union BCM56218_A0_GT255r_s {
	uint32_t v[1];
	uint32_t gt255[1];
	uint32_t _gt255;
} BCM56218_A0_GT255r_t;

#define BCM56218_A0_GT255r_CLR(r) (r).gt255[0] = 0
#define BCM56218_A0_GT255r_SET(r,d) (r).gt255[0] = d
#define BCM56218_A0_GT255r_GET(r) (r).gt255[0]


/*
 * These macros can be used to access GT255.
 *
 */
#define BCM56218_A0_READ_GT255r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GT255r,(r._gt255))
#define BCM56218_A0_WRITE_GT255r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GT255r,&(r._gt255))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GT255r BCM56218_A0_GT255r
#define GT255r_SIZE BCM56218_A0_GT255r_SIZE
typedef BCM56218_A0_GT255r_t GT255r_t;
#define GT255r_CLR BCM56218_A0_GT255r_CLR
#define GT255r_SET BCM56218_A0_GT255r_SET
#define GT255r_GET BCM56218_A0_GT255r_GET
#define READ_GT255r BCM56218_A0_READ_GT255r
#define WRITE_GT255r BCM56218_A0_WRITE_GT255r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GT255r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GT4095
 * BLOCKS:   GPORT0
 * DESC:     Transmit 2048 to 4095 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_GT4095r 0x00000036

#define BCM56218_A0_GT4095r_SIZE 4

/*
 * This structure should be used to declare and program GT4095.
 *
 */
typedef union BCM56218_A0_GT4095r_s {
	uint32_t v[1];
	uint32_t gt4095[1];
	uint32_t _gt4095;
} BCM56218_A0_GT4095r_t;

#define BCM56218_A0_GT4095r_CLR(r) (r).gt4095[0] = 0
#define BCM56218_A0_GT4095r_SET(r,d) (r).gt4095[0] = d
#define BCM56218_A0_GT4095r_GET(r) (r).gt4095[0]


/*
 * These macros can be used to access GT4095.
 *
 */
#define BCM56218_A0_READ_GT4095r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GT4095r,(r._gt4095))
#define BCM56218_A0_WRITE_GT4095r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GT4095r,&(r._gt4095))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GT4095r BCM56218_A0_GT4095r
#define GT4095r_SIZE BCM56218_A0_GT4095r_SIZE
typedef BCM56218_A0_GT4095r_t GT4095r_t;
#define GT4095r_CLR BCM56218_A0_GT4095r_CLR
#define GT4095r_SET BCM56218_A0_GT4095r_SET
#define GT4095r_GET BCM56218_A0_GT4095r_GET
#define READ_GT4095r BCM56218_A0_READ_GT4095r
#define WRITE_GT4095r BCM56218_A0_WRITE_GT4095r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GT4095r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GT511
 * BLOCKS:   GPORT0
 * DESC:     Transmit 256 to 511 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_GT511r 0x00000031

#define BCM56218_A0_GT511r_SIZE 4

/*
 * This structure should be used to declare and program GT511.
 *
 */
typedef union BCM56218_A0_GT511r_s {
	uint32_t v[1];
	uint32_t gt511[1];
	uint32_t _gt511;
} BCM56218_A0_GT511r_t;

#define BCM56218_A0_GT511r_CLR(r) (r).gt511[0] = 0
#define BCM56218_A0_GT511r_SET(r,d) (r).gt511[0] = d
#define BCM56218_A0_GT511r_GET(r) (r).gt511[0]


/*
 * These macros can be used to access GT511.
 *
 */
#define BCM56218_A0_READ_GT511r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GT511r,(r._gt511))
#define BCM56218_A0_WRITE_GT511r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GT511r,&(r._gt511))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GT511r BCM56218_A0_GT511r
#define GT511r_SIZE BCM56218_A0_GT511r_SIZE
typedef BCM56218_A0_GT511r_t GT511r_t;
#define GT511r_CLR BCM56218_A0_GT511r_CLR
#define GT511r_SET BCM56218_A0_GT511r_SET
#define GT511r_GET BCM56218_A0_GT511r_GET
#define READ_GT511r BCM56218_A0_READ_GT511r
#define WRITE_GT511r BCM56218_A0_WRITE_GT511r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GT511r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GT64
 * BLOCKS:   GPORT0
 * DESC:     Transmit 64 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_GT64r 0x0000002e

#define BCM56218_A0_GT64r_SIZE 4

/*
 * This structure should be used to declare and program GT64.
 *
 */
typedef union BCM56218_A0_GT64r_s {
	uint32_t v[1];
	uint32_t gt64[1];
	uint32_t _gt64;
} BCM56218_A0_GT64r_t;

#define BCM56218_A0_GT64r_CLR(r) (r).gt64[0] = 0
#define BCM56218_A0_GT64r_SET(r,d) (r).gt64[0] = d
#define BCM56218_A0_GT64r_GET(r) (r).gt64[0]


/*
 * These macros can be used to access GT64.
 *
 */
#define BCM56218_A0_READ_GT64r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GT64r,(r._gt64))
#define BCM56218_A0_WRITE_GT64r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GT64r,&(r._gt64))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GT64r BCM56218_A0_GT64r
#define GT64r_SIZE BCM56218_A0_GT64r_SIZE
typedef BCM56218_A0_GT64r_t GT64r_t;
#define GT64r_CLR BCM56218_A0_GT64r_CLR
#define GT64r_SET BCM56218_A0_GT64r_SET
#define GT64r_GET BCM56218_A0_GT64r_GET
#define READ_GT64r BCM56218_A0_READ_GT64r
#define WRITE_GT64r BCM56218_A0_WRITE_GT64r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GT64r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GT9216
 * BLOCKS:   GPORT0
 * DESC:     Transmit 4096 to 9216 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_GT9216r 0x00000037

#define BCM56218_A0_GT9216r_SIZE 4

/*
 * This structure should be used to declare and program GT9216.
 *
 */
typedef union BCM56218_A0_GT9216r_s {
	uint32_t v[1];
	uint32_t gt9216[1];
	uint32_t _gt9216;
} BCM56218_A0_GT9216r_t;

#define BCM56218_A0_GT9216r_CLR(r) (r).gt9216[0] = 0
#define BCM56218_A0_GT9216r_SET(r,d) (r).gt9216[0] = d
#define BCM56218_A0_GT9216r_GET(r) (r).gt9216[0]


/*
 * These macros can be used to access GT9216.
 *
 */
#define BCM56218_A0_READ_GT9216r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GT9216r,(r._gt9216))
#define BCM56218_A0_WRITE_GT9216r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GT9216r,&(r._gt9216))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GT9216r BCM56218_A0_GT9216r
#define GT9216r_SIZE BCM56218_A0_GT9216r_SIZE
typedef BCM56218_A0_GT9216r_t GT9216r_t;
#define GT9216r_CLR BCM56218_A0_GT9216r_CLR
#define GT9216r_SET BCM56218_A0_GT9216r_SET
#define GT9216r_GET BCM56218_A0_GT9216r_GET
#define READ_GT9216r BCM56218_A0_READ_GT9216r
#define WRITE_GT9216r BCM56218_A0_WRITE_GT9216r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GT9216r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GTBCA
 * BLOCKS:   GPORT0
 * DESC:     Transmit Broadcast Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_GTBCAr 0x0000002d

#define BCM56218_A0_GTBCAr_SIZE 4

/*
 * This structure should be used to declare and program GTBCA.
 *
 */
typedef union BCM56218_A0_GTBCAr_s {
	uint32_t v[1];
	uint32_t gtbca[1];
	uint32_t _gtbca;
} BCM56218_A0_GTBCAr_t;

#define BCM56218_A0_GTBCAr_CLR(r) (r).gtbca[0] = 0
#define BCM56218_A0_GTBCAr_SET(r,d) (r).gtbca[0] = d
#define BCM56218_A0_GTBCAr_GET(r) (r).gtbca[0]


/*
 * These macros can be used to access GTBCA.
 *
 */
#define BCM56218_A0_READ_GTBCAr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GTBCAr,(r._gtbca))
#define BCM56218_A0_WRITE_GTBCAr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GTBCAr,&(r._gtbca))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTBCAr BCM56218_A0_GTBCAr
#define GTBCAr_SIZE BCM56218_A0_GTBCAr_SIZE
typedef BCM56218_A0_GTBCAr_t GTBCAr_t;
#define GTBCAr_CLR BCM56218_A0_GTBCAr_CLR
#define GTBCAr_SET BCM56218_A0_GTBCAr_SET
#define GTBCAr_GET BCM56218_A0_GTBCAr_GET
#define READ_GTBCAr BCM56218_A0_READ_GTBCAr
#define WRITE_GTBCAr BCM56218_A0_WRITE_GTBCAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GTBCAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GTBYT
 * BLOCKS:   GPORT0
 * DESC:     Transmit Byte Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_GTBYTr 0x00000039

#define BCM56218_A0_GTBYTr_SIZE 4

/*
 * This structure should be used to declare and program GTBYT.
 *
 */
typedef union BCM56218_A0_GTBYTr_s {
	uint32_t v[1];
	uint32_t gtbyt[1];
	uint32_t _gtbyt;
} BCM56218_A0_GTBYTr_t;

#define BCM56218_A0_GTBYTr_CLR(r) (r).gtbyt[0] = 0
#define BCM56218_A0_GTBYTr_SET(r,d) (r).gtbyt[0] = d
#define BCM56218_A0_GTBYTr_GET(r) (r).gtbyt[0]


/*
 * These macros can be used to access GTBYT.
 *
 */
#define BCM56218_A0_READ_GTBYTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GTBYTr,(r._gtbyt))
#define BCM56218_A0_WRITE_GTBYTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GTBYTr,&(r._gtbyt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTBYTr BCM56218_A0_GTBYTr
#define GTBYTr_SIZE BCM56218_A0_GTBYTr_SIZE
typedef BCM56218_A0_GTBYTr_t GTBYTr_t;
#define GTBYTr_CLR BCM56218_A0_GTBYTr_CLR
#define GTBYTr_SET BCM56218_A0_GTBYTr_SET
#define GTBYTr_GET BCM56218_A0_GTBYTr_GET
#define READ_GTBYTr BCM56218_A0_READ_GTBYTr
#define WRITE_GTBYTr BCM56218_A0_WRITE_GTBYTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GTBYTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GTDFR
 * BLOCKS:   GPORT0
 * DESC:     Transmit Single Deferral Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_GTDFRr 0x00000024

#define BCM56218_A0_GTDFRr_SIZE 4

/*
 * This structure should be used to declare and program GTDFR.
 *
 */
typedef union BCM56218_A0_GTDFRr_s {
	uint32_t v[1];
	uint32_t gtdfr[1];
	uint32_t _gtdfr;
} BCM56218_A0_GTDFRr_t;

#define BCM56218_A0_GTDFRr_CLR(r) (r).gtdfr[0] = 0
#define BCM56218_A0_GTDFRr_SET(r,d) (r).gtdfr[0] = d
#define BCM56218_A0_GTDFRr_GET(r) (r).gtdfr[0]


/*
 * These macros can be used to access GTDFR.
 *
 */
#define BCM56218_A0_READ_GTDFRr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GTDFRr,(r._gtdfr))
#define BCM56218_A0_WRITE_GTDFRr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GTDFRr,&(r._gtdfr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTDFRr BCM56218_A0_GTDFRr
#define GTDFRr_SIZE BCM56218_A0_GTDFRr_SIZE
typedef BCM56218_A0_GTDFRr_t GTDFRr_t;
#define GTDFRr_CLR BCM56218_A0_GTDFRr_CLR
#define GTDFRr_SET BCM56218_A0_GTDFRr_SET
#define GTDFRr_GET BCM56218_A0_GTDFRr_GET
#define READ_GTDFRr BCM56218_A0_READ_GTDFRr
#define WRITE_GTDFRr BCM56218_A0_WRITE_GTDFRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GTDFRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GTEDF
 * BLOCKS:   GPORT0
 * DESC:     Transmit Multiple Deferral Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_GTEDFr 0x00000025

#define BCM56218_A0_GTEDFr_SIZE 4

/*
 * This structure should be used to declare and program GTEDF.
 *
 */
typedef union BCM56218_A0_GTEDFr_s {
	uint32_t v[1];
	uint32_t gtedf[1];
	uint32_t _gtedf;
} BCM56218_A0_GTEDFr_t;

#define BCM56218_A0_GTEDFr_CLR(r) (r).gtedf[0] = 0
#define BCM56218_A0_GTEDFr_SET(r,d) (r).gtedf[0] = d
#define BCM56218_A0_GTEDFr_GET(r) (r).gtedf[0]


/*
 * These macros can be used to access GTEDF.
 *
 */
#define BCM56218_A0_READ_GTEDFr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GTEDFr,(r._gtedf))
#define BCM56218_A0_WRITE_GTEDFr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GTEDFr,&(r._gtedf))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTEDFr BCM56218_A0_GTEDFr
#define GTEDFr_SIZE BCM56218_A0_GTEDFr_SIZE
typedef BCM56218_A0_GTEDFr_t GTEDFr_t;
#define GTEDFr_CLR BCM56218_A0_GTEDFr_CLR
#define GTEDFr_SET BCM56218_A0_GTEDFr_SET
#define GTEDFr_GET BCM56218_A0_GTEDFr_GET
#define READ_GTEDFr BCM56218_A0_READ_GTEDFr
#define WRITE_GTEDFr BCM56218_A0_WRITE_GTEDFr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GTEDFr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GTFCS
 * BLOCKS:   GPORT0
 * DESC:     Transmit FCS Error Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_GTFCSr 0x00000021

#define BCM56218_A0_GTFCSr_SIZE 4

/*
 * This structure should be used to declare and program GTFCS.
 *
 */
typedef union BCM56218_A0_GTFCSr_s {
	uint32_t v[1];
	uint32_t gtfcs[1];
	uint32_t _gtfcs;
} BCM56218_A0_GTFCSr_t;

#define BCM56218_A0_GTFCSr_CLR(r) (r).gtfcs[0] = 0
#define BCM56218_A0_GTFCSr_SET(r,d) (r).gtfcs[0] = d
#define BCM56218_A0_GTFCSr_GET(r) (r).gtfcs[0]


/*
 * These macros can be used to access GTFCS.
 *
 */
#define BCM56218_A0_READ_GTFCSr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GTFCSr,(r._gtfcs))
#define BCM56218_A0_WRITE_GTFCSr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GTFCSr,&(r._gtfcs))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTFCSr BCM56218_A0_GTFCSr
#define GTFCSr_SIZE BCM56218_A0_GTFCSr_SIZE
typedef BCM56218_A0_GTFCSr_t GTFCSr_t;
#define GTFCSr_CLR BCM56218_A0_GTFCSr_CLR
#define GTFCSr_SET BCM56218_A0_GTFCSr_SET
#define GTFCSr_GET BCM56218_A0_GTFCSr_GET
#define READ_GTFCSr BCM56218_A0_READ_GTFCSr
#define WRITE_GTFCSr BCM56218_A0_WRITE_GTFCSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GTFCSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GTFRG
 * BLOCKS:   GPORT0
 * DESC:     Transmit Fragment Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_GTFRGr 0x0000002a

#define BCM56218_A0_GTFRGr_SIZE 4

/*
 * This structure should be used to declare and program GTFRG.
 *
 */
typedef union BCM56218_A0_GTFRGr_s {
	uint32_t v[1];
	uint32_t gtfrg[1];
	uint32_t _gtfrg;
} BCM56218_A0_GTFRGr_t;

#define BCM56218_A0_GTFRGr_CLR(r) (r).gtfrg[0] = 0
#define BCM56218_A0_GTFRGr_SET(r,d) (r).gtfrg[0] = d
#define BCM56218_A0_GTFRGr_GET(r) (r).gtfrg[0]


/*
 * These macros can be used to access GTFRG.
 *
 */
#define BCM56218_A0_READ_GTFRGr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GTFRGr,(r._gtfrg))
#define BCM56218_A0_WRITE_GTFRGr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GTFRGr,&(r._gtfrg))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTFRGr BCM56218_A0_GTFRGr
#define GTFRGr_SIZE BCM56218_A0_GTFRGr_SIZE
typedef BCM56218_A0_GTFRGr_t GTFRGr_t;
#define GTFRGr_CLR BCM56218_A0_GTFRGr_CLR
#define GTFRGr_SET BCM56218_A0_GTFRGr_SET
#define GTFRGr_GET BCM56218_A0_GTFRGr_GET
#define READ_GTFRGr BCM56218_A0_READ_GTFRGr
#define WRITE_GTFRGr BCM56218_A0_WRITE_GTFRGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GTFRGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GTJBR
 * BLOCKS:   GPORT0
 * DESC:     Transmit Jabber Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_GTJBRr 0x00000020

#define BCM56218_A0_GTJBRr_SIZE 4

/*
 * This structure should be used to declare and program GTJBR.
 *
 */
typedef union BCM56218_A0_GTJBRr_s {
	uint32_t v[1];
	uint32_t gtjbr[1];
	uint32_t _gtjbr;
} BCM56218_A0_GTJBRr_t;

#define BCM56218_A0_GTJBRr_CLR(r) (r).gtjbr[0] = 0
#define BCM56218_A0_GTJBRr_SET(r,d) (r).gtjbr[0] = d
#define BCM56218_A0_GTJBRr_GET(r) (r).gtjbr[0]


/*
 * These macros can be used to access GTJBR.
 *
 */
#define BCM56218_A0_READ_GTJBRr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GTJBRr,(r._gtjbr))
#define BCM56218_A0_WRITE_GTJBRr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GTJBRr,&(r._gtjbr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTJBRr BCM56218_A0_GTJBRr
#define GTJBRr_SIZE BCM56218_A0_GTJBRr_SIZE
typedef BCM56218_A0_GTJBRr_t GTJBRr_t;
#define GTJBRr_CLR BCM56218_A0_GTJBRr_CLR
#define GTJBRr_SET BCM56218_A0_GTJBRr_SET
#define GTJBRr_GET BCM56218_A0_GTJBRr_GET
#define READ_GTJBRr BCM56218_A0_READ_GTJBRr
#define WRITE_GTJBRr BCM56218_A0_WRITE_GTJBRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GTJBRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GTLCL
 * BLOCKS:   GPORT0
 * DESC:     Transmit Late Collision Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_GTLCLr 0x00000028

#define BCM56218_A0_GTLCLr_SIZE 4

/*
 * This structure should be used to declare and program GTLCL.
 *
 */
typedef union BCM56218_A0_GTLCLr_s {
	uint32_t v[1];
	uint32_t gtlcl[1];
	uint32_t _gtlcl;
} BCM56218_A0_GTLCLr_t;

#define BCM56218_A0_GTLCLr_CLR(r) (r).gtlcl[0] = 0
#define BCM56218_A0_GTLCLr_SET(r,d) (r).gtlcl[0] = d
#define BCM56218_A0_GTLCLr_GET(r) (r).gtlcl[0]


/*
 * These macros can be used to access GTLCL.
 *
 */
#define BCM56218_A0_READ_GTLCLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GTLCLr,(r._gtlcl))
#define BCM56218_A0_WRITE_GTLCLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GTLCLr,&(r._gtlcl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTLCLr BCM56218_A0_GTLCLr
#define GTLCLr_SIZE BCM56218_A0_GTLCLr_SIZE
typedef BCM56218_A0_GTLCLr_t GTLCLr_t;
#define GTLCLr_CLR BCM56218_A0_GTLCLr_CLR
#define GTLCLr_SET BCM56218_A0_GTLCLr_SET
#define GTLCLr_GET BCM56218_A0_GTLCLr_GET
#define READ_GTLCLr BCM56218_A0_READ_GTLCLr
#define WRITE_GTLCLr BCM56218_A0_WRITE_GTLCLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GTLCLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GTMCA
 * BLOCKS:   GPORT0
 * DESC:     Transmit Multicast Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_GTMCAr 0x0000002c

#define BCM56218_A0_GTMCAr_SIZE 4

/*
 * This structure should be used to declare and program GTMCA.
 *
 */
typedef union BCM56218_A0_GTMCAr_s {
	uint32_t v[1];
	uint32_t gtmca[1];
	uint32_t _gtmca;
} BCM56218_A0_GTMCAr_t;

#define BCM56218_A0_GTMCAr_CLR(r) (r).gtmca[0] = 0
#define BCM56218_A0_GTMCAr_SET(r,d) (r).gtmca[0] = d
#define BCM56218_A0_GTMCAr_GET(r) (r).gtmca[0]


/*
 * These macros can be used to access GTMCA.
 *
 */
#define BCM56218_A0_READ_GTMCAr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GTMCAr,(r._gtmca))
#define BCM56218_A0_WRITE_GTMCAr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GTMCAr,&(r._gtmca))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTMCAr BCM56218_A0_GTMCAr
#define GTMCAr_SIZE BCM56218_A0_GTMCAr_SIZE
typedef BCM56218_A0_GTMCAr_t GTMCAr_t;
#define GTMCAr_CLR BCM56218_A0_GTMCAr_CLR
#define GTMCAr_SET BCM56218_A0_GTMCAr_SET
#define GTMCAr_GET BCM56218_A0_GTMCAr_GET
#define READ_GTMCAr BCM56218_A0_READ_GTMCAr
#define WRITE_GTMCAr BCM56218_A0_WRITE_GTMCAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GTMCAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GTMCL
 * BLOCKS:   GPORT0
 * DESC:     Transmit Multiple Collision Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_GTMCLr 0x00000027

#define BCM56218_A0_GTMCLr_SIZE 4

/*
 * This structure should be used to declare and program GTMCL.
 *
 */
typedef union BCM56218_A0_GTMCLr_s {
	uint32_t v[1];
	uint32_t gtmcl[1];
	uint32_t _gtmcl;
} BCM56218_A0_GTMCLr_t;

#define BCM56218_A0_GTMCLr_CLR(r) (r).gtmcl[0] = 0
#define BCM56218_A0_GTMCLr_SET(r,d) (r).gtmcl[0] = d
#define BCM56218_A0_GTMCLr_GET(r) (r).gtmcl[0]


/*
 * These macros can be used to access GTMCL.
 *
 */
#define BCM56218_A0_READ_GTMCLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GTMCLr,(r._gtmcl))
#define BCM56218_A0_WRITE_GTMCLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GTMCLr,&(r._gtmcl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTMCLr BCM56218_A0_GTMCLr
#define GTMCLr_SIZE BCM56218_A0_GTMCLr_SIZE
typedef BCM56218_A0_GTMCLr_t GTMCLr_t;
#define GTMCLr_CLR BCM56218_A0_GTMCLr_CLR
#define GTMCLr_SET BCM56218_A0_GTMCLr_SET
#define GTMCLr_GET BCM56218_A0_GTMCLr_GET
#define READ_GTMCLr BCM56218_A0_READ_GTMCLr
#define WRITE_GTMCLr BCM56218_A0_WRITE_GTMCLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GTMCLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GTMGV
 * BLOCKS:   GPORT0
 * DESC:     Transmit 1519 to 1522 Byte Good VLAN Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_GTMGVr 0x00000034

#define BCM56218_A0_GTMGVr_SIZE 4

/*
 * This structure should be used to declare and program GTMGV.
 *
 */
typedef union BCM56218_A0_GTMGVr_s {
	uint32_t v[1];
	uint32_t gtmgv[1];
	uint32_t _gtmgv;
} BCM56218_A0_GTMGVr_t;

#define BCM56218_A0_GTMGVr_CLR(r) (r).gtmgv[0] = 0
#define BCM56218_A0_GTMGVr_SET(r,d) (r).gtmgv[0] = d
#define BCM56218_A0_GTMGVr_GET(r) (r).gtmgv[0]


/*
 * These macros can be used to access GTMGV.
 *
 */
#define BCM56218_A0_READ_GTMGVr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GTMGVr,(r._gtmgv))
#define BCM56218_A0_WRITE_GTMGVr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GTMGVr,&(r._gtmgv))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTMGVr BCM56218_A0_GTMGVr
#define GTMGVr_SIZE BCM56218_A0_GTMGVr_SIZE
typedef BCM56218_A0_GTMGVr_t GTMGVr_t;
#define GTMGVr_CLR BCM56218_A0_GTMGVr_CLR
#define GTMGVr_SET BCM56218_A0_GTMGVr_SET
#define GTMGVr_GET BCM56218_A0_GTMGVr_GET
#define READ_GTMGVr BCM56218_A0_READ_GTMGVr
#define WRITE_GTMGVr BCM56218_A0_WRITE_GTMGVr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GTMGVr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GTNCL
 * BLOCKS:   GPORT0
 * DESC:     Transmit Total Collision Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_GTNCLr 0x0000002b

#define BCM56218_A0_GTNCLr_SIZE 4

/*
 * This structure should be used to declare and program GTNCL.
 *
 */
typedef union BCM56218_A0_GTNCLr_s {
	uint32_t v[1];
	uint32_t gtncl[1];
	uint32_t _gtncl;
} BCM56218_A0_GTNCLr_t;

#define BCM56218_A0_GTNCLr_CLR(r) (r).gtncl[0] = 0
#define BCM56218_A0_GTNCLr_SET(r,d) (r).gtncl[0] = d
#define BCM56218_A0_GTNCLr_GET(r) (r).gtncl[0]


/*
 * These macros can be used to access GTNCL.
 *
 */
#define BCM56218_A0_READ_GTNCLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GTNCLr,(r._gtncl))
#define BCM56218_A0_WRITE_GTNCLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GTNCLr,&(r._gtncl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTNCLr BCM56218_A0_GTNCLr
#define GTNCLr_SIZE BCM56218_A0_GTNCLr_SIZE
typedef BCM56218_A0_GTNCLr_t GTNCLr_t;
#define GTNCLr_CLR BCM56218_A0_GTNCLr_CLR
#define GTNCLr_SET BCM56218_A0_GTNCLr_SET
#define GTNCLr_GET BCM56218_A0_GTNCLr_GET
#define READ_GTNCLr BCM56218_A0_READ_GTNCLr
#define WRITE_GTNCLr BCM56218_A0_WRITE_GTNCLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GTNCLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GTOVR
 * BLOCKS:   GPORT0
 * DESC:     Transmit Oversize Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_GTOVRr 0x00000023

#define BCM56218_A0_GTOVRr_SIZE 4

/*
 * This structure should be used to declare and program GTOVR.
 *
 */
typedef union BCM56218_A0_GTOVRr_s {
	uint32_t v[1];
	uint32_t gtovr[1];
	uint32_t _gtovr;
} BCM56218_A0_GTOVRr_t;

#define BCM56218_A0_GTOVRr_CLR(r) (r).gtovr[0] = 0
#define BCM56218_A0_GTOVRr_SET(r,d) (r).gtovr[0] = d
#define BCM56218_A0_GTOVRr_GET(r) (r).gtovr[0]


/*
 * These macros can be used to access GTOVR.
 *
 */
#define BCM56218_A0_READ_GTOVRr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GTOVRr,(r._gtovr))
#define BCM56218_A0_WRITE_GTOVRr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GTOVRr,&(r._gtovr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTOVRr BCM56218_A0_GTOVRr
#define GTOVRr_SIZE BCM56218_A0_GTOVRr_SIZE
typedef BCM56218_A0_GTOVRr_t GTOVRr_t;
#define GTOVRr_CLR BCM56218_A0_GTOVRr_CLR
#define GTOVRr_SET BCM56218_A0_GTOVRr_SET
#define GTOVRr_GET BCM56218_A0_GTOVRr_GET
#define READ_GTOVRr BCM56218_A0_READ_GTOVRr
#define WRITE_GTOVRr BCM56218_A0_WRITE_GTOVRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GTOVRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GTPKT
 * BLOCKS:   GPORT0
 * DESC:     Transmit frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_GTPKTr 0x00000038

#define BCM56218_A0_GTPKTr_SIZE 4

/*
 * This structure should be used to declare and program GTPKT.
 *
 */
typedef union BCM56218_A0_GTPKTr_s {
	uint32_t v[1];
	uint32_t gtpkt[1];
	uint32_t _gtpkt;
} BCM56218_A0_GTPKTr_t;

#define BCM56218_A0_GTPKTr_CLR(r) (r).gtpkt[0] = 0
#define BCM56218_A0_GTPKTr_SET(r,d) (r).gtpkt[0] = d
#define BCM56218_A0_GTPKTr_GET(r) (r).gtpkt[0]


/*
 * These macros can be used to access GTPKT.
 *
 */
#define BCM56218_A0_READ_GTPKTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GTPKTr,(r._gtpkt))
#define BCM56218_A0_WRITE_GTPKTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GTPKTr,&(r._gtpkt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTPKTr BCM56218_A0_GTPKTr
#define GTPKTr_SIZE BCM56218_A0_GTPKTr_SIZE
typedef BCM56218_A0_GTPKTr_t GTPKTr_t;
#define GTPKTr_CLR BCM56218_A0_GTPKTr_CLR
#define GTPKTr_SET BCM56218_A0_GTPKTr_SET
#define GTPKTr_GET BCM56218_A0_GTPKTr_GET
#define READ_GTPKTr BCM56218_A0_READ_GTPKTr
#define WRITE_GTPKTr BCM56218_A0_WRITE_GTPKTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GTPKTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GTPOK
 * BLOCKS:   GPORT0
 * DESC:     Transmitted Packets OK Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_GTPOKr 0x0000003b

#define BCM56218_A0_GTPOKr_SIZE 4

/*
 * This structure should be used to declare and program GTPOK.
 *
 */
typedef union BCM56218_A0_GTPOKr_s {
	uint32_t v[1];
	uint32_t gtpok[1];
	uint32_t _gtpok;
} BCM56218_A0_GTPOKr_t;

#define BCM56218_A0_GTPOKr_CLR(r) (r).gtpok[0] = 0
#define BCM56218_A0_GTPOKr_SET(r,d) (r).gtpok[0] = d
#define BCM56218_A0_GTPOKr_GET(r) (r).gtpok[0]


/*
 * These macros can be used to access GTPOK.
 *
 */
#define BCM56218_A0_READ_GTPOKr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GTPOKr,(r._gtpok))
#define BCM56218_A0_WRITE_GTPOKr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GTPOKr,&(r._gtpok))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTPOKr BCM56218_A0_GTPOKr
#define GTPOKr_SIZE BCM56218_A0_GTPOKr_SIZE
typedef BCM56218_A0_GTPOKr_t GTPOKr_t;
#define GTPOKr_CLR BCM56218_A0_GTPOKr_CLR
#define GTPOKr_SET BCM56218_A0_GTPOKr_SET
#define GTPOKr_GET BCM56218_A0_GTPOKr_GET
#define READ_GTPOKr BCM56218_A0_READ_GTPOKr
#define WRITE_GTPOKr BCM56218_A0_WRITE_GTPOKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GTPOKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GTSCL
 * BLOCKS:   GPORT0
 * DESC:     Transmit Single Collision Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_GTSCLr 0x00000026

#define BCM56218_A0_GTSCLr_SIZE 4

/*
 * This structure should be used to declare and program GTSCL.
 *
 */
typedef union BCM56218_A0_GTSCLr_s {
	uint32_t v[1];
	uint32_t gtscl[1];
	uint32_t _gtscl;
} BCM56218_A0_GTSCLr_t;

#define BCM56218_A0_GTSCLr_CLR(r) (r).gtscl[0] = 0
#define BCM56218_A0_GTSCLr_SET(r,d) (r).gtscl[0] = d
#define BCM56218_A0_GTSCLr_GET(r) (r).gtscl[0]


/*
 * These macros can be used to access GTSCL.
 *
 */
#define BCM56218_A0_READ_GTSCLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GTSCLr,(r._gtscl))
#define BCM56218_A0_WRITE_GTSCLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GTSCLr,&(r._gtscl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTSCLr BCM56218_A0_GTSCLr
#define GTSCLr_SIZE BCM56218_A0_GTSCLr_SIZE
typedef BCM56218_A0_GTSCLr_t GTSCLr_t;
#define GTSCLr_CLR BCM56218_A0_GTSCLr_CLR
#define GTSCLr_SET BCM56218_A0_GTSCLr_SET
#define GTSCLr_GET BCM56218_A0_GTSCLr_GET
#define READ_GTSCLr BCM56218_A0_READ_GTSCLr
#define WRITE_GTSCLr BCM56218_A0_WRITE_GTSCLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GTSCLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GTUC
 * BLOCKS:   GPORT0
 * DESC:     Transmit Unicast Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_GTUCr 0x0000003a

#define BCM56218_A0_GTUCr_SIZE 4

/*
 * This structure should be used to declare and program GTUC.
 *
 */
typedef union BCM56218_A0_GTUCr_s {
	uint32_t v[1];
	uint32_t gtuc[1];
	uint32_t _gtuc;
} BCM56218_A0_GTUCr_t;

#define BCM56218_A0_GTUCr_CLR(r) (r).gtuc[0] = 0
#define BCM56218_A0_GTUCr_SET(r,d) (r).gtuc[0] = d
#define BCM56218_A0_GTUCr_GET(r) (r).gtuc[0]


/*
 * These macros can be used to access GTUC.
 *
 */
#define BCM56218_A0_READ_GTUCr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GTUCr,(r._gtuc))
#define BCM56218_A0_WRITE_GTUCr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GTUCr,&(r._gtuc))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTUCr BCM56218_A0_GTUCr
#define GTUCr_SIZE BCM56218_A0_GTUCr_SIZE
typedef BCM56218_A0_GTUCr_t GTUCr_t;
#define GTUCr_CLR BCM56218_A0_GTUCr_CLR
#define GTUCr_SET BCM56218_A0_GTUCr_SET
#define GTUCr_GET BCM56218_A0_GTUCr_GET
#define READ_GTUCr BCM56218_A0_READ_GTUCr
#define WRITE_GTUCr BCM56218_A0_WRITE_GTUCr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GTUCr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GTXCF
 * BLOCKS:   GPORT0
 * DESC:     Transmit Control Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_GTXCFr 0x00000022

#define BCM56218_A0_GTXCFr_SIZE 4

/*
 * This structure should be used to declare and program GTXCF.
 *
 */
typedef union BCM56218_A0_GTXCFr_s {
	uint32_t v[1];
	uint32_t gtxcf[1];
	uint32_t _gtxcf;
} BCM56218_A0_GTXCFr_t;

#define BCM56218_A0_GTXCFr_CLR(r) (r).gtxcf[0] = 0
#define BCM56218_A0_GTXCFr_SET(r,d) (r).gtxcf[0] = d
#define BCM56218_A0_GTXCFr_GET(r) (r).gtxcf[0]


/*
 * These macros can be used to access GTXCF.
 *
 */
#define BCM56218_A0_READ_GTXCFr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GTXCFr,(r._gtxcf))
#define BCM56218_A0_WRITE_GTXCFr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GTXCFr,&(r._gtxcf))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTXCFr BCM56218_A0_GTXCFr
#define GTXCFr_SIZE BCM56218_A0_GTXCFr_SIZE
typedef BCM56218_A0_GTXCFr_t GTXCFr_t;
#define GTXCFr_CLR BCM56218_A0_GTXCFr_CLR
#define GTXCFr_SET BCM56218_A0_GTXCFr_SET
#define GTXCFr_GET BCM56218_A0_GTXCFr_GET
#define READ_GTXCFr BCM56218_A0_READ_GTXCFr
#define WRITE_GTXCFr BCM56218_A0_WRITE_GTXCFr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GTXCFr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GTXCL
 * BLOCKS:   GPORT0
 * DESC:     Transmit Excessive Collision Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_GTXCLr 0x00000029

#define BCM56218_A0_GTXCLr_SIZE 4

/*
 * This structure should be used to declare and program GTXCL.
 *
 */
typedef union BCM56218_A0_GTXCLr_s {
	uint32_t v[1];
	uint32_t gtxcl[1];
	uint32_t _gtxcl;
} BCM56218_A0_GTXCLr_t;

#define BCM56218_A0_GTXCLr_CLR(r) (r).gtxcl[0] = 0
#define BCM56218_A0_GTXCLr_SET(r,d) (r).gtxcl[0] = d
#define BCM56218_A0_GTXCLr_GET(r) (r).gtxcl[0]


/*
 * These macros can be used to access GTXCL.
 *
 */
#define BCM56218_A0_READ_GTXCLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GTXCLr,(r._gtxcl))
#define BCM56218_A0_WRITE_GTXCLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GTXCLr,&(r._gtxcl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTXCLr BCM56218_A0_GTXCLr
#define GTXCLr_SIZE BCM56218_A0_GTXCLr_SIZE
typedef BCM56218_A0_GTXCLr_t GTXCLr_t;
#define GTXCLr_CLR BCM56218_A0_GTXCLr_CLR
#define GTXCLr_SET BCM56218_A0_GTXCLr_SET
#define GTXCLr_GET BCM56218_A0_GTXCLr_GET
#define READ_GTXCLr BCM56218_A0_READ_GTXCLr
#define WRITE_GTXCLr BCM56218_A0_WRITE_GTXCLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GTXCLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  GTXPF
 * BLOCKS:   GPORT0
 * DESC:     Transmit Pause Control Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_GTXPFr 0x0000001f

#define BCM56218_A0_GTXPFr_SIZE 4

/*
 * This structure should be used to declare and program GTXPF.
 *
 */
typedef union BCM56218_A0_GTXPFr_s {
	uint32_t v[1];
	uint32_t gtxpf[1];
	uint32_t _gtxpf;
} BCM56218_A0_GTXPFr_t;

#define BCM56218_A0_GTXPFr_CLR(r) (r).gtxpf[0] = 0
#define BCM56218_A0_GTXPFr_SET(r,d) (r).gtxpf[0] = d
#define BCM56218_A0_GTXPFr_GET(r) (r).gtxpf[0]


/*
 * These macros can be used to access GTXPF.
 *
 */
#define BCM56218_A0_READ_GTXPFr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_GTXPFr,(r._gtxpf))
#define BCM56218_A0_WRITE_GTXPFr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_GTXPFr,&(r._gtxpf))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTXPFr BCM56218_A0_GTXPFr
#define GTXPFr_SIZE BCM56218_A0_GTXPFr_SIZE
typedef BCM56218_A0_GTXPFr_t GTXPFr_t;
#define GTXPFr_CLR BCM56218_A0_GTXPFr_CLR
#define GTXPFr_SET BCM56218_A0_GTXPFr_SET
#define GTXPFr_GET BCM56218_A0_GTXPFr_GET
#define READ_GTXPFr BCM56218_A0_READ_GTXPFr
#define WRITE_GTXPFr BCM56218_A0_WRITE_GTXPFr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_GTXPFr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  HASH_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     Hash Control Register
 * SIZE:     32
 * FIELDS:
 *     NON_UC_TRUNK_HASH_MOD_PORT_ENABLE Enables factoring modid/port into non-unicast trunk block mask hashing
 *     NON_UC_TRUNK_HASH_SRC_ENABLE Enables factoring source MAC or source IP into non-unicast trunk block mask hashing
 *     NON_UC_TRUNK_HASH_DST_ENABLE Enables factoring dest MAC or dest IP into non-unicast trunk block mask hashing
 *     UC_TRUNK_HASH_USE_SRC_PORT Use src port in unicast trunk hash
 *     RESERVED1        Reserved bits
 *     L2_AND_VLAN_MAC_HASH_SELECT Selects hashing algorithm used for L2 table lookups
 *     RESERVED0        Reserved bits
 *     ENABLE_DRACO1_5_HASH Enable using Draco 1.5 hashing for unicast trunking
 *     USE_TCP_UDP_PORTS Use TCP/UDP ports for ECMP/unicast trunk hashing
 *
 ******************************************************************************/
#define BCM56218_A0_HASH_CONTROLr 0x01780004

#define BCM56218_A0_HASH_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program HASH_CONTROL.
 *
 */
typedef union BCM56218_A0_HASH_CONTROLr_s {
	uint32_t v[1];
	uint32_t hash_control[1];
	uint32_t _hash_control;
} BCM56218_A0_HASH_CONTROLr_t;

#define BCM56218_A0_HASH_CONTROLr_CLR(r) (r).hash_control[0] = 0
#define BCM56218_A0_HASH_CONTROLr_SET(r,d) (r).hash_control[0] = d
#define BCM56218_A0_HASH_CONTROLr_GET(r) (r).hash_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_HASH_CONTROLr_NON_UC_TRUNK_HASH_MOD_PORT_ENABLEf_GET(r) (((r).hash_control[0]) & 0x1)
#define BCM56218_A0_HASH_CONTROLr_NON_UC_TRUNK_HASH_MOD_PORT_ENABLEf_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_HASH_CONTROLr_NON_UC_TRUNK_HASH_SRC_ENABLEf_GET(r) ((((r).hash_control[0]) >> 1) & 0x1)
#define BCM56218_A0_HASH_CONTROLr_NON_UC_TRUNK_HASH_SRC_ENABLEf_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_HASH_CONTROLr_NON_UC_TRUNK_HASH_DST_ENABLEf_GET(r) ((((r).hash_control[0]) >> 2) & 0x1)
#define BCM56218_A0_HASH_CONTROLr_NON_UC_TRUNK_HASH_DST_ENABLEf_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_HASH_CONTROLr_UC_TRUNK_HASH_USE_SRC_PORTf_GET(r) ((((r).hash_control[0]) >> 3) & 0x1)
#define BCM56218_A0_HASH_CONTROLr_UC_TRUNK_HASH_USE_SRC_PORTf_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56218_A0_HASH_CONTROLr_RESERVED1f_GET(r) ((((r).hash_control[0]) >> 4) & 0x7ff)
#define BCM56218_A0_HASH_CONTROLr_RESERVED1f_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32_t)0x7ff << 4)) | ((((uint32_t)f) & 0x7ff) << 4))
#define BCM56218_A0_HASH_CONTROLr_L2_AND_VLAN_MAC_HASH_SELECTf_GET(r) ((((r).hash_control[0]) >> 15) & 0x7)
#define BCM56218_A0_HASH_CONTROLr_L2_AND_VLAN_MAC_HASH_SELECTf_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM56218_A0_HASH_CONTROLr_RESERVED0f_GET(r) ((((r).hash_control[0]) >> 18) & 0x7)
#define BCM56218_A0_HASH_CONTROLr_RESERVED0f_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM56218_A0_HASH_CONTROLr_ENABLE_DRACO1_5_HASHf_GET(r) ((((r).hash_control[0]) >> 21) & 0x1)
#define BCM56218_A0_HASH_CONTROLr_ENABLE_DRACO1_5_HASHf_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM56218_A0_HASH_CONTROLr_USE_TCP_UDP_PORTSf_GET(r) ((((r).hash_control[0]) >> 22) & 0x1)
#define BCM56218_A0_HASH_CONTROLr_USE_TCP_UDP_PORTSf_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))

/*
 * These macros can be used to access HASH_CONTROL.
 *
 */
#define BCM56218_A0_READ_HASH_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_HASH_CONTROLr,(r._hash_control))
#define BCM56218_A0_WRITE_HASH_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_HASH_CONTROLr,&(r._hash_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HASH_CONTROLr BCM56218_A0_HASH_CONTROLr
#define HASH_CONTROLr_SIZE BCM56218_A0_HASH_CONTROLr_SIZE
typedef BCM56218_A0_HASH_CONTROLr_t HASH_CONTROLr_t;
#define HASH_CONTROLr_CLR BCM56218_A0_HASH_CONTROLr_CLR
#define HASH_CONTROLr_SET BCM56218_A0_HASH_CONTROLr_SET
#define HASH_CONTROLr_GET BCM56218_A0_HASH_CONTROLr_GET
#define HASH_CONTROLr_NON_UC_TRUNK_HASH_MOD_PORT_ENABLEf_GET BCM56218_A0_HASH_CONTROLr_NON_UC_TRUNK_HASH_MOD_PORT_ENABLEf_GET
#define HASH_CONTROLr_NON_UC_TRUNK_HASH_MOD_PORT_ENABLEf_SET BCM56218_A0_HASH_CONTROLr_NON_UC_TRUNK_HASH_MOD_PORT_ENABLEf_SET
#define HASH_CONTROLr_NON_UC_TRUNK_HASH_SRC_ENABLEf_GET BCM56218_A0_HASH_CONTROLr_NON_UC_TRUNK_HASH_SRC_ENABLEf_GET
#define HASH_CONTROLr_NON_UC_TRUNK_HASH_SRC_ENABLEf_SET BCM56218_A0_HASH_CONTROLr_NON_UC_TRUNK_HASH_SRC_ENABLEf_SET
#define HASH_CONTROLr_NON_UC_TRUNK_HASH_DST_ENABLEf_GET BCM56218_A0_HASH_CONTROLr_NON_UC_TRUNK_HASH_DST_ENABLEf_GET
#define HASH_CONTROLr_NON_UC_TRUNK_HASH_DST_ENABLEf_SET BCM56218_A0_HASH_CONTROLr_NON_UC_TRUNK_HASH_DST_ENABLEf_SET
#define HASH_CONTROLr_UC_TRUNK_HASH_USE_SRC_PORTf_GET BCM56218_A0_HASH_CONTROLr_UC_TRUNK_HASH_USE_SRC_PORTf_GET
#define HASH_CONTROLr_UC_TRUNK_HASH_USE_SRC_PORTf_SET BCM56218_A0_HASH_CONTROLr_UC_TRUNK_HASH_USE_SRC_PORTf_SET
#define HASH_CONTROLr_RESERVED1f_GET BCM56218_A0_HASH_CONTROLr_RESERVED1f_GET
#define HASH_CONTROLr_RESERVED1f_SET BCM56218_A0_HASH_CONTROLr_RESERVED1f_SET
#define HASH_CONTROLr_L2_AND_VLAN_MAC_HASH_SELECTf_GET BCM56218_A0_HASH_CONTROLr_L2_AND_VLAN_MAC_HASH_SELECTf_GET
#define HASH_CONTROLr_L2_AND_VLAN_MAC_HASH_SELECTf_SET BCM56218_A0_HASH_CONTROLr_L2_AND_VLAN_MAC_HASH_SELECTf_SET
#define HASH_CONTROLr_RESERVED0f_GET BCM56218_A0_HASH_CONTROLr_RESERVED0f_GET
#define HASH_CONTROLr_RESERVED0f_SET BCM56218_A0_HASH_CONTROLr_RESERVED0f_SET
#define HASH_CONTROLr_ENABLE_DRACO1_5_HASHf_GET BCM56218_A0_HASH_CONTROLr_ENABLE_DRACO1_5_HASHf_GET
#define HASH_CONTROLr_ENABLE_DRACO1_5_HASHf_SET BCM56218_A0_HASH_CONTROLr_ENABLE_DRACO1_5_HASHf_SET
#define HASH_CONTROLr_USE_TCP_UDP_PORTSf_GET BCM56218_A0_HASH_CONTROLr_USE_TCP_UDP_PORTSf_GET
#define HASH_CONTROLr_USE_TCP_UDP_PORTSf_SET BCM56218_A0_HASH_CONTROLr_USE_TCP_UDP_PORTSf_SET
#define READ_HASH_CONTROLr BCM56218_A0_READ_HASH_CONTROLr
#define WRITE_HASH_CONTROLr BCM56218_A0_WRITE_HASH_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_HASH_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  HOLCOSPKTSETLIMIT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     PKTSETLIMIT      HOL Packet high threshold for cos size of egress XQ COS n.The COS n HOL status will be generated when packet count is over (this setlimit - Skidmark to be configged SKIDMARKER field from MISCCONFIG register). Do not set HOLCOSPKTSETLIMIT lower than Skidmarck or it will be treatedas zero size of this COS n.Please note the sum of an egress port\'s all COS\' pktsetlimit can not over 2k. Modify this register during the traffic is an illeagal opreation, will cause unrecoverable damage on MMU.
 *     RESETLIMITSEL    HOL COSn Packet Reset Threshold Select opions for all cos of egress ports.When HOL COSn status is set, packet counts have to fall below Reset Threshold in order to clear HOL COSn status. 2'b00: 75% of HOL COS Packet Set Limit.2'b01: 50% of HOL COS Packet Set Limit.        2'b10: 25% of HOL COS Packet Set Limit.        2'b11: 100% of HOL COS Packet Set Limit.    Modify this register during the traffic is an illeagal opreation, will cause unrecoverable damage on MMU.
 *
 ******************************************************************************/
#define BCM56218_A0_HOLCOSPKTSETLIMITr 0x00600007

#define BCM56218_A0_HOLCOSPKTSETLIMITr_SIZE 4

/*
 * This structure should be used to declare and program HOLCOSPKTSETLIMIT.
 *
 */
typedef union BCM56218_A0_HOLCOSPKTSETLIMITr_s {
	uint32_t v[1];
	uint32_t holcospktsetlimit[1];
	uint32_t _holcospktsetlimit;
} BCM56218_A0_HOLCOSPKTSETLIMITr_t;

#define BCM56218_A0_HOLCOSPKTSETLIMITr_CLR(r) (r).holcospktsetlimit[0] = 0
#define BCM56218_A0_HOLCOSPKTSETLIMITr_SET(r,d) (r).holcospktsetlimit[0] = d
#define BCM56218_A0_HOLCOSPKTSETLIMITr_GET(r) (r).holcospktsetlimit[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_HOLCOSPKTSETLIMITr_PKTSETLIMITf_GET(r) (((r).holcospktsetlimit[0]) & 0x7ff)
#define BCM56218_A0_HOLCOSPKTSETLIMITr_PKTSETLIMITf_SET(r,f) (r).holcospktsetlimit[0]=(((r).holcospktsetlimit[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM56218_A0_HOLCOSPKTSETLIMITr_RESETLIMITSELf_GET(r) ((((r).holcospktsetlimit[0]) >> 11) & 0x3)
#define BCM56218_A0_HOLCOSPKTSETLIMITr_RESETLIMITSELf_SET(r,f) (r).holcospktsetlimit[0]=(((r).holcospktsetlimit[0] & ~((uint32_t)0x3 << 11)) | ((((uint32_t)f) & 0x3) << 11))

/*
 * These macros can be used to access HOLCOSPKTSETLIMIT.
 *
 */
#define BCM56218_A0_READ_HOLCOSPKTSETLIMITr(u,p,i,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_HOLCOSPKTSETLIMITr+(i),(r._holcospktsetlimit))
#define BCM56218_A0_WRITE_HOLCOSPKTSETLIMITr(u,p,i,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_HOLCOSPKTSETLIMITr+(i),&(r._holcospktsetlimit))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLCOSPKTSETLIMITr BCM56218_A0_HOLCOSPKTSETLIMITr
#define HOLCOSPKTSETLIMITr_SIZE BCM56218_A0_HOLCOSPKTSETLIMITr_SIZE
typedef BCM56218_A0_HOLCOSPKTSETLIMITr_t HOLCOSPKTSETLIMITr_t;
#define HOLCOSPKTSETLIMITr_CLR BCM56218_A0_HOLCOSPKTSETLIMITr_CLR
#define HOLCOSPKTSETLIMITr_SET BCM56218_A0_HOLCOSPKTSETLIMITr_SET
#define HOLCOSPKTSETLIMITr_GET BCM56218_A0_HOLCOSPKTSETLIMITr_GET
#define HOLCOSPKTSETLIMITr_PKTSETLIMITf_GET BCM56218_A0_HOLCOSPKTSETLIMITr_PKTSETLIMITf_GET
#define HOLCOSPKTSETLIMITr_PKTSETLIMITf_SET BCM56218_A0_HOLCOSPKTSETLIMITr_PKTSETLIMITf_SET
#define HOLCOSPKTSETLIMITr_RESETLIMITSELf_GET BCM56218_A0_HOLCOSPKTSETLIMITr_RESETLIMITSELf_GET
#define HOLCOSPKTSETLIMITr_RESETLIMITSELf_SET BCM56218_A0_HOLCOSPKTSETLIMITr_RESETLIMITSELf_SET
#define READ_HOLCOSPKTSETLIMITr BCM56218_A0_READ_HOLCOSPKTSETLIMITr
#define WRITE_HOLCOSPKTSETLIMITr BCM56218_A0_WRITE_HOLCOSPKTSETLIMITr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_HOLCOSPKTSETLIMITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  HOLCOSSTATUS
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     PORT_BITMAP      Current COS n HOL Cell status
 *
 ******************************************************************************/
#define BCM56218_A0_HOLCOSSTATUSr 0x0068000a

#define BCM56218_A0_HOLCOSSTATUSr_SIZE 4

/*
 * This structure should be used to declare and program HOLCOSSTATUS.
 *
 */
typedef union BCM56218_A0_HOLCOSSTATUSr_s {
	uint32_t v[1];
	uint32_t holcosstatus[1];
	uint32_t _holcosstatus;
} BCM56218_A0_HOLCOSSTATUSr_t;

#define BCM56218_A0_HOLCOSSTATUSr_CLR(r) (r).holcosstatus[0] = 0
#define BCM56218_A0_HOLCOSSTATUSr_SET(r,d) (r).holcosstatus[0] = d
#define BCM56218_A0_HOLCOSSTATUSr_GET(r) (r).holcosstatus[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_HOLCOSSTATUSr_PORT_BITMAPf_GET(r) ((r).holcosstatus[0])
#define BCM56218_A0_HOLCOSSTATUSr_PORT_BITMAPf_SET(r,f) (r).holcosstatus[0]=((uint32_t)f)

/*
 * These macros can be used to access HOLCOSSTATUS.
 *
 */
#define BCM56218_A0_READ_HOLCOSSTATUSr(u,i,r) cdk_xgs_reg32_read(u,BCM56218_A0_HOLCOSSTATUSr+(i),(r._holcosstatus))
#define BCM56218_A0_WRITE_HOLCOSSTATUSr(u,i,r) cdk_xgs_reg32_write(u,BCM56218_A0_HOLCOSSTATUSr+(i),&(r._holcosstatus))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLCOSSTATUSr BCM56218_A0_HOLCOSSTATUSr
#define HOLCOSSTATUSr_SIZE BCM56218_A0_HOLCOSSTATUSr_SIZE
typedef BCM56218_A0_HOLCOSSTATUSr_t HOLCOSSTATUSr_t;
#define HOLCOSSTATUSr_CLR BCM56218_A0_HOLCOSSTATUSr_CLR
#define HOLCOSSTATUSr_SET BCM56218_A0_HOLCOSSTATUSr_SET
#define HOLCOSSTATUSr_GET BCM56218_A0_HOLCOSSTATUSr_GET
#define HOLCOSSTATUSr_PORT_BITMAPf_GET BCM56218_A0_HOLCOSSTATUSr_PORT_BITMAPf_GET
#define HOLCOSSTATUSr_PORT_BITMAPf_SET BCM56218_A0_HOLCOSSTATUSr_PORT_BITMAPf_SET
#define READ_HOLCOSSTATUSr BCM56218_A0_READ_HOLCOSSTATUSr
#define WRITE_HOLCOSSTATUSr BCM56218_A0_WRITE_HOLCOSSTATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_HOLCOSSTATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  HOLCOSSTATUS_HI
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     PORT_BITMAP      Current COS n HOL Cell status for ports 53-32
 *
 ******************************************************************************/
#define BCM56218_A0_HOLCOSSTATUS_HIr 0x00680012

#define BCM56218_A0_HOLCOSSTATUS_HIr_SIZE 4

/*
 * This structure should be used to declare and program HOLCOSSTATUS_HI.
 *
 */
typedef union BCM56218_A0_HOLCOSSTATUS_HIr_s {
	uint32_t v[1];
	uint32_t holcosstatus_hi[1];
	uint32_t _holcosstatus_hi;
} BCM56218_A0_HOLCOSSTATUS_HIr_t;

#define BCM56218_A0_HOLCOSSTATUS_HIr_CLR(r) (r).holcosstatus_hi[0] = 0
#define BCM56218_A0_HOLCOSSTATUS_HIr_SET(r,d) (r).holcosstatus_hi[0] = d
#define BCM56218_A0_HOLCOSSTATUS_HIr_GET(r) (r).holcosstatus_hi[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_HOLCOSSTATUS_HIr_PORT_BITMAPf_GET(r) (((r).holcosstatus_hi[0]) & 0x3fffff)
#define BCM56218_A0_HOLCOSSTATUS_HIr_PORT_BITMAPf_SET(r,f) (r).holcosstatus_hi[0]=(((r).holcosstatus_hi[0] & ~((uint32_t)0x3fffff)) | (((uint32_t)f) & 0x3fffff))

/*
 * These macros can be used to access HOLCOSSTATUS_HI.
 *
 */
#define BCM56218_A0_READ_HOLCOSSTATUS_HIr(u,i,r) cdk_xgs_reg32_read(u,BCM56218_A0_HOLCOSSTATUS_HIr+(i),(r._holcosstatus_hi))
#define BCM56218_A0_WRITE_HOLCOSSTATUS_HIr(u,i,r) cdk_xgs_reg32_write(u,BCM56218_A0_HOLCOSSTATUS_HIr+(i),&(r._holcosstatus_hi))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLCOSSTATUS_HIr BCM56218_A0_HOLCOSSTATUS_HIr
#define HOLCOSSTATUS_HIr_SIZE BCM56218_A0_HOLCOSSTATUS_HIr_SIZE
typedef BCM56218_A0_HOLCOSSTATUS_HIr_t HOLCOSSTATUS_HIr_t;
#define HOLCOSSTATUS_HIr_CLR BCM56218_A0_HOLCOSSTATUS_HIr_CLR
#define HOLCOSSTATUS_HIr_SET BCM56218_A0_HOLCOSSTATUS_HIr_SET
#define HOLCOSSTATUS_HIr_GET BCM56218_A0_HOLCOSSTATUS_HIr_GET
#define HOLCOSSTATUS_HIr_PORT_BITMAPf_GET BCM56218_A0_HOLCOSSTATUS_HIr_PORT_BITMAPf_GET
#define HOLCOSSTATUS_HIr_PORT_BITMAPf_SET BCM56218_A0_HOLCOSSTATUS_HIr_PORT_BITMAPf_SET
#define READ_HOLCOSSTATUS_HIr BCM56218_A0_READ_HOLCOSSTATUS_HIr
#define WRITE_HOLCOSSTATUS_HIr BCM56218_A0_WRITE_HOLCOSSTATUS_HIr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_HOLCOSSTATUS_HIr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  HOLD
 * BLOCKS:   IPIPE
 * DESC:     Egress per port HOL Drop Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_HOLDr 0x0e700014

#define BCM56218_A0_HOLDr_SIZE 4

/*
 * This structure should be used to declare and program HOLD.
 *
 */
typedef union BCM56218_A0_HOLDr_s {
	uint32_t v[1];
	uint32_t hold[1];
	uint32_t _hold;
} BCM56218_A0_HOLDr_t;

#define BCM56218_A0_HOLDr_CLR(r) (r).hold[0] = 0
#define BCM56218_A0_HOLDr_SET(r,d) (r).hold[0] = d
#define BCM56218_A0_HOLDr_GET(r) (r).hold[0]


/*
 * These macros can be used to access HOLD.
 *
 */
#define BCM56218_A0_READ_HOLDr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_HOLDr,(r._hold))
#define BCM56218_A0_WRITE_HOLDr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_HOLDr,&(r._hold))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLDr BCM56218_A0_HOLDr
#define HOLDr_SIZE BCM56218_A0_HOLDr_SIZE
typedef BCM56218_A0_HOLDr_t HOLDr_t;
#define HOLDr_CLR BCM56218_A0_HOLDr_CLR
#define HOLDr_SET BCM56218_A0_HOLDr_SET
#define HOLDr_GET BCM56218_A0_HOLDr_GET
#define READ_HOLDr BCM56218_A0_READ_HOLDr
#define WRITE_HOLDr BCM56218_A0_WRITE_HOLDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_HOLDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  HOLD_COS0
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS0 Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            Incremented for each Packet drop due to Head Of Line blocking per egress port COS
 *
 ******************************************************************************/
#define BCM56218_A0_HOLD_COS0r 0x0e780015

#define BCM56218_A0_HOLD_COS0r_SIZE 4

/*
 * This structure should be used to declare and program HOLD_COS0.
 *
 */
typedef union BCM56218_A0_HOLD_COS0r_s {
	uint32_t v[1];
	uint32_t hold_cos0[1];
	uint32_t _hold_cos0;
} BCM56218_A0_HOLD_COS0r_t;

#define BCM56218_A0_HOLD_COS0r_CLR(r) (r).hold_cos0[0] = 0
#define BCM56218_A0_HOLD_COS0r_SET(r,d) (r).hold_cos0[0] = d
#define BCM56218_A0_HOLD_COS0r_GET(r) (r).hold_cos0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_HOLD_COS0r_COUNTf_GET(r) (((r).hold_cos0[0]) & 0x3ffffff)
#define BCM56218_A0_HOLD_COS0r_COUNTf_SET(r,f) (r).hold_cos0[0]=(((r).hold_cos0[0] & ~((uint32_t)0x3ffffff)) | (((uint32_t)f) & 0x3ffffff))

/*
 * These macros can be used to access HOLD_COS0.
 *
 */
#define BCM56218_A0_READ_HOLD_COS0r(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_HOLD_COS0r,(r._hold_cos0))
#define BCM56218_A0_WRITE_HOLD_COS0r(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_HOLD_COS0r,&(r._hold_cos0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLD_COS0r BCM56218_A0_HOLD_COS0r
#define HOLD_COS0r_SIZE BCM56218_A0_HOLD_COS0r_SIZE
typedef BCM56218_A0_HOLD_COS0r_t HOLD_COS0r_t;
#define HOLD_COS0r_CLR BCM56218_A0_HOLD_COS0r_CLR
#define HOLD_COS0r_SET BCM56218_A0_HOLD_COS0r_SET
#define HOLD_COS0r_GET BCM56218_A0_HOLD_COS0r_GET
#define HOLD_COS0r_COUNTf_GET BCM56218_A0_HOLD_COS0r_COUNTf_GET
#define HOLD_COS0r_COUNTf_SET BCM56218_A0_HOLD_COS0r_COUNTf_SET
#define READ_HOLD_COS0r BCM56218_A0_READ_HOLD_COS0r
#define WRITE_HOLD_COS0r BCM56218_A0_WRITE_HOLD_COS0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_HOLD_COS0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  HOLD_COS1
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS1 Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            Incremented for each Packet drop due to Head Of Line blocking per egress port COS
 *
 ******************************************************************************/
#define BCM56218_A0_HOLD_COS1r 0x0e780016

#define BCM56218_A0_HOLD_COS1r_SIZE 4

/*
 * This structure should be used to declare and program HOLD_COS1.
 *
 */
typedef union BCM56218_A0_HOLD_COS1r_s {
	uint32_t v[1];
	uint32_t hold_cos1[1];
	uint32_t _hold_cos1;
} BCM56218_A0_HOLD_COS1r_t;

#define BCM56218_A0_HOLD_COS1r_CLR(r) (r).hold_cos1[0] = 0
#define BCM56218_A0_HOLD_COS1r_SET(r,d) (r).hold_cos1[0] = d
#define BCM56218_A0_HOLD_COS1r_GET(r) (r).hold_cos1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_HOLD_COS1r_COUNTf_GET(r) (((r).hold_cos1[0]) & 0x3ffffff)
#define BCM56218_A0_HOLD_COS1r_COUNTf_SET(r,f) (r).hold_cos1[0]=(((r).hold_cos1[0] & ~((uint32_t)0x3ffffff)) | (((uint32_t)f) & 0x3ffffff))

/*
 * These macros can be used to access HOLD_COS1.
 *
 */
#define BCM56218_A0_READ_HOLD_COS1r(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_HOLD_COS1r,(r._hold_cos1))
#define BCM56218_A0_WRITE_HOLD_COS1r(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_HOLD_COS1r,&(r._hold_cos1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLD_COS1r BCM56218_A0_HOLD_COS1r
#define HOLD_COS1r_SIZE BCM56218_A0_HOLD_COS1r_SIZE
typedef BCM56218_A0_HOLD_COS1r_t HOLD_COS1r_t;
#define HOLD_COS1r_CLR BCM56218_A0_HOLD_COS1r_CLR
#define HOLD_COS1r_SET BCM56218_A0_HOLD_COS1r_SET
#define HOLD_COS1r_GET BCM56218_A0_HOLD_COS1r_GET
#define HOLD_COS1r_COUNTf_GET BCM56218_A0_HOLD_COS1r_COUNTf_GET
#define HOLD_COS1r_COUNTf_SET BCM56218_A0_HOLD_COS1r_COUNTf_SET
#define READ_HOLD_COS1r BCM56218_A0_READ_HOLD_COS1r
#define WRITE_HOLD_COS1r BCM56218_A0_WRITE_HOLD_COS1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_HOLD_COS1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  HOLD_COS2
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS2 Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            Incremented for each Packet drop due to Head Of Line blocking per egress port COS
 *
 ******************************************************************************/
#define BCM56218_A0_HOLD_COS2r 0x0e780017

#define BCM56218_A0_HOLD_COS2r_SIZE 4

/*
 * This structure should be used to declare and program HOLD_COS2.
 *
 */
typedef union BCM56218_A0_HOLD_COS2r_s {
	uint32_t v[1];
	uint32_t hold_cos2[1];
	uint32_t _hold_cos2;
} BCM56218_A0_HOLD_COS2r_t;

#define BCM56218_A0_HOLD_COS2r_CLR(r) (r).hold_cos2[0] = 0
#define BCM56218_A0_HOLD_COS2r_SET(r,d) (r).hold_cos2[0] = d
#define BCM56218_A0_HOLD_COS2r_GET(r) (r).hold_cos2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_HOLD_COS2r_COUNTf_GET(r) (((r).hold_cos2[0]) & 0x3ffffff)
#define BCM56218_A0_HOLD_COS2r_COUNTf_SET(r,f) (r).hold_cos2[0]=(((r).hold_cos2[0] & ~((uint32_t)0x3ffffff)) | (((uint32_t)f) & 0x3ffffff))

/*
 * These macros can be used to access HOLD_COS2.
 *
 */
#define BCM56218_A0_READ_HOLD_COS2r(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_HOLD_COS2r,(r._hold_cos2))
#define BCM56218_A0_WRITE_HOLD_COS2r(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_HOLD_COS2r,&(r._hold_cos2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLD_COS2r BCM56218_A0_HOLD_COS2r
#define HOLD_COS2r_SIZE BCM56218_A0_HOLD_COS2r_SIZE
typedef BCM56218_A0_HOLD_COS2r_t HOLD_COS2r_t;
#define HOLD_COS2r_CLR BCM56218_A0_HOLD_COS2r_CLR
#define HOLD_COS2r_SET BCM56218_A0_HOLD_COS2r_SET
#define HOLD_COS2r_GET BCM56218_A0_HOLD_COS2r_GET
#define HOLD_COS2r_COUNTf_GET BCM56218_A0_HOLD_COS2r_COUNTf_GET
#define HOLD_COS2r_COUNTf_SET BCM56218_A0_HOLD_COS2r_COUNTf_SET
#define READ_HOLD_COS2r BCM56218_A0_READ_HOLD_COS2r
#define WRITE_HOLD_COS2r BCM56218_A0_WRITE_HOLD_COS2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_HOLD_COS2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  HOLD_COS3
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS3 Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            Incremented for each Packet drop due to Head Of Line blocking per egress port COS
 *
 ******************************************************************************/
#define BCM56218_A0_HOLD_COS3r 0x0e780018

#define BCM56218_A0_HOLD_COS3r_SIZE 4

/*
 * This structure should be used to declare and program HOLD_COS3.
 *
 */
typedef union BCM56218_A0_HOLD_COS3r_s {
	uint32_t v[1];
	uint32_t hold_cos3[1];
	uint32_t _hold_cos3;
} BCM56218_A0_HOLD_COS3r_t;

#define BCM56218_A0_HOLD_COS3r_CLR(r) (r).hold_cos3[0] = 0
#define BCM56218_A0_HOLD_COS3r_SET(r,d) (r).hold_cos3[0] = d
#define BCM56218_A0_HOLD_COS3r_GET(r) (r).hold_cos3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_HOLD_COS3r_COUNTf_GET(r) (((r).hold_cos3[0]) & 0x3ffffff)
#define BCM56218_A0_HOLD_COS3r_COUNTf_SET(r,f) (r).hold_cos3[0]=(((r).hold_cos3[0] & ~((uint32_t)0x3ffffff)) | (((uint32_t)f) & 0x3ffffff))

/*
 * These macros can be used to access HOLD_COS3.
 *
 */
#define BCM56218_A0_READ_HOLD_COS3r(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_HOLD_COS3r,(r._hold_cos3))
#define BCM56218_A0_WRITE_HOLD_COS3r(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_HOLD_COS3r,&(r._hold_cos3))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLD_COS3r BCM56218_A0_HOLD_COS3r
#define HOLD_COS3r_SIZE BCM56218_A0_HOLD_COS3r_SIZE
typedef BCM56218_A0_HOLD_COS3r_t HOLD_COS3r_t;
#define HOLD_COS3r_CLR BCM56218_A0_HOLD_COS3r_CLR
#define HOLD_COS3r_SET BCM56218_A0_HOLD_COS3r_SET
#define HOLD_COS3r_GET BCM56218_A0_HOLD_COS3r_GET
#define HOLD_COS3r_COUNTf_GET BCM56218_A0_HOLD_COS3r_COUNTf_GET
#define HOLD_COS3r_COUNTf_SET BCM56218_A0_HOLD_COS3r_COUNTf_SET
#define READ_HOLD_COS3r BCM56218_A0_READ_HOLD_COS3r
#define WRITE_HOLD_COS3r BCM56218_A0_WRITE_HOLD_COS3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_HOLD_COS3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  HOLD_COS4
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS4 Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            Incremented for each Packet drop due to Head Of Line blocking per egress port COS
 *
 ******************************************************************************/
#define BCM56218_A0_HOLD_COS4r 0x0e780019

#define BCM56218_A0_HOLD_COS4r_SIZE 4

/*
 * This structure should be used to declare and program HOLD_COS4.
 *
 */
typedef union BCM56218_A0_HOLD_COS4r_s {
	uint32_t v[1];
	uint32_t hold_cos4[1];
	uint32_t _hold_cos4;
} BCM56218_A0_HOLD_COS4r_t;

#define BCM56218_A0_HOLD_COS4r_CLR(r) (r).hold_cos4[0] = 0
#define BCM56218_A0_HOLD_COS4r_SET(r,d) (r).hold_cos4[0] = d
#define BCM56218_A0_HOLD_COS4r_GET(r) (r).hold_cos4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_HOLD_COS4r_COUNTf_GET(r) (((r).hold_cos4[0]) & 0x3ffffff)
#define BCM56218_A0_HOLD_COS4r_COUNTf_SET(r,f) (r).hold_cos4[0]=(((r).hold_cos4[0] & ~((uint32_t)0x3ffffff)) | (((uint32_t)f) & 0x3ffffff))

/*
 * These macros can be used to access HOLD_COS4.
 *
 */
#define BCM56218_A0_READ_HOLD_COS4r(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_HOLD_COS4r,(r._hold_cos4))
#define BCM56218_A0_WRITE_HOLD_COS4r(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_HOLD_COS4r,&(r._hold_cos4))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLD_COS4r BCM56218_A0_HOLD_COS4r
#define HOLD_COS4r_SIZE BCM56218_A0_HOLD_COS4r_SIZE
typedef BCM56218_A0_HOLD_COS4r_t HOLD_COS4r_t;
#define HOLD_COS4r_CLR BCM56218_A0_HOLD_COS4r_CLR
#define HOLD_COS4r_SET BCM56218_A0_HOLD_COS4r_SET
#define HOLD_COS4r_GET BCM56218_A0_HOLD_COS4r_GET
#define HOLD_COS4r_COUNTf_GET BCM56218_A0_HOLD_COS4r_COUNTf_GET
#define HOLD_COS4r_COUNTf_SET BCM56218_A0_HOLD_COS4r_COUNTf_SET
#define READ_HOLD_COS4r BCM56218_A0_READ_HOLD_COS4r
#define WRITE_HOLD_COS4r BCM56218_A0_WRITE_HOLD_COS4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_HOLD_COS4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  HOLD_COS5
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS5 Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            Incremented for each Packet drop due to Head Of Line blocking per egress port COS
 *
 ******************************************************************************/
#define BCM56218_A0_HOLD_COS5r 0x0e78001a

#define BCM56218_A0_HOLD_COS5r_SIZE 4

/*
 * This structure should be used to declare and program HOLD_COS5.
 *
 */
typedef union BCM56218_A0_HOLD_COS5r_s {
	uint32_t v[1];
	uint32_t hold_cos5[1];
	uint32_t _hold_cos5;
} BCM56218_A0_HOLD_COS5r_t;

#define BCM56218_A0_HOLD_COS5r_CLR(r) (r).hold_cos5[0] = 0
#define BCM56218_A0_HOLD_COS5r_SET(r,d) (r).hold_cos5[0] = d
#define BCM56218_A0_HOLD_COS5r_GET(r) (r).hold_cos5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_HOLD_COS5r_COUNTf_GET(r) (((r).hold_cos5[0]) & 0x3ffffff)
#define BCM56218_A0_HOLD_COS5r_COUNTf_SET(r,f) (r).hold_cos5[0]=(((r).hold_cos5[0] & ~((uint32_t)0x3ffffff)) | (((uint32_t)f) & 0x3ffffff))

/*
 * These macros can be used to access HOLD_COS5.
 *
 */
#define BCM56218_A0_READ_HOLD_COS5r(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_HOLD_COS5r,(r._hold_cos5))
#define BCM56218_A0_WRITE_HOLD_COS5r(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_HOLD_COS5r,&(r._hold_cos5))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLD_COS5r BCM56218_A0_HOLD_COS5r
#define HOLD_COS5r_SIZE BCM56218_A0_HOLD_COS5r_SIZE
typedef BCM56218_A0_HOLD_COS5r_t HOLD_COS5r_t;
#define HOLD_COS5r_CLR BCM56218_A0_HOLD_COS5r_CLR
#define HOLD_COS5r_SET BCM56218_A0_HOLD_COS5r_SET
#define HOLD_COS5r_GET BCM56218_A0_HOLD_COS5r_GET
#define HOLD_COS5r_COUNTf_GET BCM56218_A0_HOLD_COS5r_COUNTf_GET
#define HOLD_COS5r_COUNTf_SET BCM56218_A0_HOLD_COS5r_COUNTf_SET
#define READ_HOLD_COS5r BCM56218_A0_READ_HOLD_COS5r
#define WRITE_HOLD_COS5r BCM56218_A0_WRITE_HOLD_COS5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_HOLD_COS5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  HOLD_COS6
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS6 Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            Incremented for each Packet drop due to Head Of Line blocking per egress port COS
 *
 ******************************************************************************/
#define BCM56218_A0_HOLD_COS6r 0x0e78001b

#define BCM56218_A0_HOLD_COS6r_SIZE 4

/*
 * This structure should be used to declare and program HOLD_COS6.
 *
 */
typedef union BCM56218_A0_HOLD_COS6r_s {
	uint32_t v[1];
	uint32_t hold_cos6[1];
	uint32_t _hold_cos6;
} BCM56218_A0_HOLD_COS6r_t;

#define BCM56218_A0_HOLD_COS6r_CLR(r) (r).hold_cos6[0] = 0
#define BCM56218_A0_HOLD_COS6r_SET(r,d) (r).hold_cos6[0] = d
#define BCM56218_A0_HOLD_COS6r_GET(r) (r).hold_cos6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_HOLD_COS6r_COUNTf_GET(r) (((r).hold_cos6[0]) & 0x3ffffff)
#define BCM56218_A0_HOLD_COS6r_COUNTf_SET(r,f) (r).hold_cos6[0]=(((r).hold_cos6[0] & ~((uint32_t)0x3ffffff)) | (((uint32_t)f) & 0x3ffffff))

/*
 * These macros can be used to access HOLD_COS6.
 *
 */
#define BCM56218_A0_READ_HOLD_COS6r(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_HOLD_COS6r,(r._hold_cos6))
#define BCM56218_A0_WRITE_HOLD_COS6r(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_HOLD_COS6r,&(r._hold_cos6))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLD_COS6r BCM56218_A0_HOLD_COS6r
#define HOLD_COS6r_SIZE BCM56218_A0_HOLD_COS6r_SIZE
typedef BCM56218_A0_HOLD_COS6r_t HOLD_COS6r_t;
#define HOLD_COS6r_CLR BCM56218_A0_HOLD_COS6r_CLR
#define HOLD_COS6r_SET BCM56218_A0_HOLD_COS6r_SET
#define HOLD_COS6r_GET BCM56218_A0_HOLD_COS6r_GET
#define HOLD_COS6r_COUNTf_GET BCM56218_A0_HOLD_COS6r_COUNTf_GET
#define HOLD_COS6r_COUNTf_SET BCM56218_A0_HOLD_COS6r_COUNTf_SET
#define READ_HOLD_COS6r BCM56218_A0_READ_HOLD_COS6r
#define WRITE_HOLD_COS6r BCM56218_A0_WRITE_HOLD_COS6r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_HOLD_COS6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  HOLD_COS7
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS7 Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            Incremented for each Packet drop due to Head Of Line blocking per egress port COS
 *
 ******************************************************************************/
#define BCM56218_A0_HOLD_COS7r 0x0e78001c

#define BCM56218_A0_HOLD_COS7r_SIZE 4

/*
 * This structure should be used to declare and program HOLD_COS7.
 *
 */
typedef union BCM56218_A0_HOLD_COS7r_s {
	uint32_t v[1];
	uint32_t hold_cos7[1];
	uint32_t _hold_cos7;
} BCM56218_A0_HOLD_COS7r_t;

#define BCM56218_A0_HOLD_COS7r_CLR(r) (r).hold_cos7[0] = 0
#define BCM56218_A0_HOLD_COS7r_SET(r,d) (r).hold_cos7[0] = d
#define BCM56218_A0_HOLD_COS7r_GET(r) (r).hold_cos7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_HOLD_COS7r_COUNTf_GET(r) (((r).hold_cos7[0]) & 0x3ffffff)
#define BCM56218_A0_HOLD_COS7r_COUNTf_SET(r,f) (r).hold_cos7[0]=(((r).hold_cos7[0] & ~((uint32_t)0x3ffffff)) | (((uint32_t)f) & 0x3ffffff))

/*
 * These macros can be used to access HOLD_COS7.
 *
 */
#define BCM56218_A0_READ_HOLD_COS7r(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_HOLD_COS7r,(r._hold_cos7))
#define BCM56218_A0_WRITE_HOLD_COS7r(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_HOLD_COS7r,&(r._hold_cos7))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLD_COS7r BCM56218_A0_HOLD_COS7r
#define HOLD_COS7r_SIZE BCM56218_A0_HOLD_COS7r_SIZE
typedef BCM56218_A0_HOLD_COS7r_t HOLD_COS7r_t;
#define HOLD_COS7r_CLR BCM56218_A0_HOLD_COS7r_CLR
#define HOLD_COS7r_SET BCM56218_A0_HOLD_COS7r_SET
#define HOLD_COS7r_GET BCM56218_A0_HOLD_COS7r_GET
#define HOLD_COS7r_COUNTf_GET BCM56218_A0_HOLD_COS7r_COUNTf_GET
#define HOLD_COS7r_COUNTf_SET BCM56218_A0_HOLD_COS7r_COUNTf_SET
#define READ_HOLD_COS7r BCM56218_A0_READ_HOLD_COS7r
#define WRITE_HOLD_COS7r BCM56218_A0_WRITE_HOLD_COS7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_HOLD_COS7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  HOLD_COS_PORT_SELECT
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS Counter Port Select Register
 * SIZE:     32
 * FIELDS:
 *     PORT_NUM         Port number
 *
 ******************************************************************************/
#define BCM56218_A0_HOLD_COS_PORT_SELECTr 0x0e780128

#define BCM56218_A0_HOLD_COS_PORT_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program HOLD_COS_PORT_SELECT.
 *
 */
typedef union BCM56218_A0_HOLD_COS_PORT_SELECTr_s {
	uint32_t v[1];
	uint32_t hold_cos_port_select[1];
	uint32_t _hold_cos_port_select;
} BCM56218_A0_HOLD_COS_PORT_SELECTr_t;

#define BCM56218_A0_HOLD_COS_PORT_SELECTr_CLR(r) (r).hold_cos_port_select[0] = 0
#define BCM56218_A0_HOLD_COS_PORT_SELECTr_SET(r,d) (r).hold_cos_port_select[0] = d
#define BCM56218_A0_HOLD_COS_PORT_SELECTr_GET(r) (r).hold_cos_port_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_HOLD_COS_PORT_SELECTr_PORT_NUMf_GET(r) (((r).hold_cos_port_select[0]) & 0x3f)
#define BCM56218_A0_HOLD_COS_PORT_SELECTr_PORT_NUMf_SET(r,f) (r).hold_cos_port_select[0]=(((r).hold_cos_port_select[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))

/*
 * These macros can be used to access HOLD_COS_PORT_SELECT.
 *
 */
#define BCM56218_A0_READ_HOLD_COS_PORT_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_HOLD_COS_PORT_SELECTr,(r._hold_cos_port_select))
#define BCM56218_A0_WRITE_HOLD_COS_PORT_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_HOLD_COS_PORT_SELECTr,&(r._hold_cos_port_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLD_COS_PORT_SELECTr BCM56218_A0_HOLD_COS_PORT_SELECTr
#define HOLD_COS_PORT_SELECTr_SIZE BCM56218_A0_HOLD_COS_PORT_SELECTr_SIZE
typedef BCM56218_A0_HOLD_COS_PORT_SELECTr_t HOLD_COS_PORT_SELECTr_t;
#define HOLD_COS_PORT_SELECTr_CLR BCM56218_A0_HOLD_COS_PORT_SELECTr_CLR
#define HOLD_COS_PORT_SELECTr_SET BCM56218_A0_HOLD_COS_PORT_SELECTr_SET
#define HOLD_COS_PORT_SELECTr_GET BCM56218_A0_HOLD_COS_PORT_SELECTr_GET
#define HOLD_COS_PORT_SELECTr_PORT_NUMf_GET BCM56218_A0_HOLD_COS_PORT_SELECTr_PORT_NUMf_GET
#define HOLD_COS_PORT_SELECTr_PORT_NUMf_SET BCM56218_A0_HOLD_COS_PORT_SELECTr_PORT_NUMf_SET
#define READ_HOLD_COS_PORT_SELECTr BCM56218_A0_READ_HOLD_COS_PORT_SELECTr
#define WRITE_HOLD_COS_PORT_SELECTr BCM56218_A0_WRITE_HOLD_COS_PORT_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_HOLD_COS_PORT_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  HOL_STAT_BMAP
 * BLOCKS:   IPIPE
 * DESC:     HOL Status Register  Lower Bitmap
 * SIZE:     32
 * FIELDS:
 *     PORT_BITMAP      HOL status port bitmap 
 *
 ******************************************************************************/
#define BCM56218_A0_HOL_STAT_BMAPr 0x0e780114

#define BCM56218_A0_HOL_STAT_BMAPr_SIZE 4

/*
 * This structure should be used to declare and program HOL_STAT_BMAP.
 *
 */
typedef union BCM56218_A0_HOL_STAT_BMAPr_s {
	uint32_t v[1];
	uint32_t hol_stat_bmap[1];
	uint32_t _hol_stat_bmap;
} BCM56218_A0_HOL_STAT_BMAPr_t;

#define BCM56218_A0_HOL_STAT_BMAPr_CLR(r) (r).hol_stat_bmap[0] = 0
#define BCM56218_A0_HOL_STAT_BMAPr_SET(r,d) (r).hol_stat_bmap[0] = d
#define BCM56218_A0_HOL_STAT_BMAPr_GET(r) (r).hol_stat_bmap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_HOL_STAT_BMAPr_PORT_BITMAPf_GET(r) ((r).hol_stat_bmap[0])
#define BCM56218_A0_HOL_STAT_BMAPr_PORT_BITMAPf_SET(r,f) (r).hol_stat_bmap[0]=((uint32_t)f)

/*
 * These macros can be used to access HOL_STAT_BMAP.
 *
 */
#define BCM56218_A0_READ_HOL_STAT_BMAPr(u,i,r) cdk_xgs_reg32_read(u,BCM56218_A0_HOL_STAT_BMAPr+(i),(r._hol_stat_bmap))
#define BCM56218_A0_WRITE_HOL_STAT_BMAPr(u,i,r) cdk_xgs_reg32_write(u,BCM56218_A0_HOL_STAT_BMAPr+(i),&(r._hol_stat_bmap))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOL_STAT_BMAPr BCM56218_A0_HOL_STAT_BMAPr
#define HOL_STAT_BMAPr_SIZE BCM56218_A0_HOL_STAT_BMAPr_SIZE
typedef BCM56218_A0_HOL_STAT_BMAPr_t HOL_STAT_BMAPr_t;
#define HOL_STAT_BMAPr_CLR BCM56218_A0_HOL_STAT_BMAPr_CLR
#define HOL_STAT_BMAPr_SET BCM56218_A0_HOL_STAT_BMAPr_SET
#define HOL_STAT_BMAPr_GET BCM56218_A0_HOL_STAT_BMAPr_GET
#define HOL_STAT_BMAPr_PORT_BITMAPf_GET BCM56218_A0_HOL_STAT_BMAPr_PORT_BITMAPf_GET
#define HOL_STAT_BMAPr_PORT_BITMAPf_SET BCM56218_A0_HOL_STAT_BMAPr_PORT_BITMAPf_SET
#define READ_HOL_STAT_BMAPr BCM56218_A0_READ_HOL_STAT_BMAPr
#define WRITE_HOL_STAT_BMAPr BCM56218_A0_WRITE_HOL_STAT_BMAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_HOL_STAT_BMAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  HOL_STAT_BMAP_HI
 * BLOCKS:   IPIPE
 * DESC:     HOL Status Register - Upper Bitmap
 * SIZE:     32
 * FIELDS:
 *     PORT_BITMAP      HOL status port bitmap 
 *
 ******************************************************************************/
#define BCM56218_A0_HOL_STAT_BMAP_HIr 0x0e78011c

#define BCM56218_A0_HOL_STAT_BMAP_HIr_SIZE 4

/*
 * This structure should be used to declare and program HOL_STAT_BMAP_HI.
 *
 */
typedef union BCM56218_A0_HOL_STAT_BMAP_HIr_s {
	uint32_t v[1];
	uint32_t hol_stat_bmap_hi[1];
	uint32_t _hol_stat_bmap_hi;
} BCM56218_A0_HOL_STAT_BMAP_HIr_t;

#define BCM56218_A0_HOL_STAT_BMAP_HIr_CLR(r) (r).hol_stat_bmap_hi[0] = 0
#define BCM56218_A0_HOL_STAT_BMAP_HIr_SET(r,d) (r).hol_stat_bmap_hi[0] = d
#define BCM56218_A0_HOL_STAT_BMAP_HIr_GET(r) (r).hol_stat_bmap_hi[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_HOL_STAT_BMAP_HIr_PORT_BITMAPf_GET(r) (((r).hol_stat_bmap_hi[0]) & 0x3fffff)
#define BCM56218_A0_HOL_STAT_BMAP_HIr_PORT_BITMAPf_SET(r,f) (r).hol_stat_bmap_hi[0]=(((r).hol_stat_bmap_hi[0] & ~((uint32_t)0x3fffff)) | (((uint32_t)f) & 0x3fffff))

/*
 * These macros can be used to access HOL_STAT_BMAP_HI.
 *
 */
#define BCM56218_A0_READ_HOL_STAT_BMAP_HIr(u,i,r) cdk_xgs_reg32_read(u,BCM56218_A0_HOL_STAT_BMAP_HIr+(i),(r._hol_stat_bmap_hi))
#define BCM56218_A0_WRITE_HOL_STAT_BMAP_HIr(u,i,r) cdk_xgs_reg32_write(u,BCM56218_A0_HOL_STAT_BMAP_HIr+(i),&(r._hol_stat_bmap_hi))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOL_STAT_BMAP_HIr BCM56218_A0_HOL_STAT_BMAP_HIr
#define HOL_STAT_BMAP_HIr_SIZE BCM56218_A0_HOL_STAT_BMAP_HIr_SIZE
typedef BCM56218_A0_HOL_STAT_BMAP_HIr_t HOL_STAT_BMAP_HIr_t;
#define HOL_STAT_BMAP_HIr_CLR BCM56218_A0_HOL_STAT_BMAP_HIr_CLR
#define HOL_STAT_BMAP_HIr_SET BCM56218_A0_HOL_STAT_BMAP_HIr_SET
#define HOL_STAT_BMAP_HIr_GET BCM56218_A0_HOL_STAT_BMAP_HIr_GET
#define HOL_STAT_BMAP_HIr_PORT_BITMAPf_GET BCM56218_A0_HOL_STAT_BMAP_HIr_PORT_BITMAPf_GET
#define HOL_STAT_BMAP_HIr_PORT_BITMAPf_SET BCM56218_A0_HOL_STAT_BMAP_HIr_PORT_BITMAPf_SET
#define READ_HOL_STAT_BMAP_HIr BCM56218_A0_READ_HOL_STAT_BMAP_HIr
#define WRITE_HOL_STAT_BMAP_HIr BCM56218_A0_WRITE_HOL_STAT_BMAP_HIr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_HOL_STAT_BMAP_HIr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  IBCAST_BLOCK_MASK
 * BLOCKS:   IPIPE_HI
 * DESC:     Broadcast Block Mask - Lower Bitmap
 * SIZE:     32
 * FIELDS:
 *     BLK_BITMAP       Bitmap of ports to be blocked
 *
 ******************************************************************************/
#define BCM56218_A0_IBCAST_BLOCK_MASKr 0x0e800104

#define BCM56218_A0_IBCAST_BLOCK_MASKr_SIZE 4

/*
 * This structure should be used to declare and program IBCAST_BLOCK_MASK.
 *
 */
typedef union BCM56218_A0_IBCAST_BLOCK_MASKr_s {
	uint32_t v[1];
	uint32_t ibcast_block_mask[1];
	uint32_t _ibcast_block_mask;
} BCM56218_A0_IBCAST_BLOCK_MASKr_t;

#define BCM56218_A0_IBCAST_BLOCK_MASKr_CLR(r) (r).ibcast_block_mask[0] = 0
#define BCM56218_A0_IBCAST_BLOCK_MASKr_SET(r,d) (r).ibcast_block_mask[0] = d
#define BCM56218_A0_IBCAST_BLOCK_MASKr_GET(r) (r).ibcast_block_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_IBCAST_BLOCK_MASKr_BLK_BITMAPf_GET(r) ((r).ibcast_block_mask[0])
#define BCM56218_A0_IBCAST_BLOCK_MASKr_BLK_BITMAPf_SET(r,f) (r).ibcast_block_mask[0]=((uint32_t)f)

/*
 * These macros can be used to access IBCAST_BLOCK_MASK.
 *
 */
#define BCM56218_A0_READ_IBCAST_BLOCK_MASKr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_IBCAST_BLOCK_MASKr,(r._ibcast_block_mask))
#define BCM56218_A0_WRITE_IBCAST_BLOCK_MASKr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_IBCAST_BLOCK_MASKr,&(r._ibcast_block_mask))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IBCAST_BLOCK_MASKr BCM56218_A0_IBCAST_BLOCK_MASKr
#define IBCAST_BLOCK_MASKr_SIZE BCM56218_A0_IBCAST_BLOCK_MASKr_SIZE
typedef BCM56218_A0_IBCAST_BLOCK_MASKr_t IBCAST_BLOCK_MASKr_t;
#define IBCAST_BLOCK_MASKr_CLR BCM56218_A0_IBCAST_BLOCK_MASKr_CLR
#define IBCAST_BLOCK_MASKr_SET BCM56218_A0_IBCAST_BLOCK_MASKr_SET
#define IBCAST_BLOCK_MASKr_GET BCM56218_A0_IBCAST_BLOCK_MASKr_GET
#define IBCAST_BLOCK_MASKr_BLK_BITMAPf_GET BCM56218_A0_IBCAST_BLOCK_MASKr_BLK_BITMAPf_GET
#define IBCAST_BLOCK_MASKr_BLK_BITMAPf_SET BCM56218_A0_IBCAST_BLOCK_MASKr_BLK_BITMAPf_SET
#define READ_IBCAST_BLOCK_MASKr BCM56218_A0_READ_IBCAST_BLOCK_MASKr
#define WRITE_IBCAST_BLOCK_MASKr BCM56218_A0_WRITE_IBCAST_BLOCK_MASKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_IBCAST_BLOCK_MASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  IBCAST_BLOCK_MASK_HI
 * BLOCKS:   IPIPE_HI
 * DESC:     Broadcast Block Mask - Upper Bitmap
 * SIZE:     32
 * FIELDS:
 *     BLK_BITMAP       Bitmap of ports to be blocked
 *
 ******************************************************************************/
#define BCM56218_A0_IBCAST_BLOCK_MASK_HIr 0x0e800105

#define BCM56218_A0_IBCAST_BLOCK_MASK_HIr_SIZE 4

/*
 * This structure should be used to declare and program IBCAST_BLOCK_MASK_HI.
 *
 */
typedef union BCM56218_A0_IBCAST_BLOCK_MASK_HIr_s {
	uint32_t v[1];
	uint32_t ibcast_block_mask_hi[1];
	uint32_t _ibcast_block_mask_hi;
} BCM56218_A0_IBCAST_BLOCK_MASK_HIr_t;

#define BCM56218_A0_IBCAST_BLOCK_MASK_HIr_CLR(r) (r).ibcast_block_mask_hi[0] = 0
#define BCM56218_A0_IBCAST_BLOCK_MASK_HIr_SET(r,d) (r).ibcast_block_mask_hi[0] = d
#define BCM56218_A0_IBCAST_BLOCK_MASK_HIr_GET(r) (r).ibcast_block_mask_hi[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_IBCAST_BLOCK_MASK_HIr_BLK_BITMAPf_GET(r) (((r).ibcast_block_mask_hi[0]) & 0x3fffff)
#define BCM56218_A0_IBCAST_BLOCK_MASK_HIr_BLK_BITMAPf_SET(r,f) (r).ibcast_block_mask_hi[0]=(((r).ibcast_block_mask_hi[0] & ~((uint32_t)0x3fffff)) | (((uint32_t)f) & 0x3fffff))

/*
 * These macros can be used to access IBCAST_BLOCK_MASK_HI.
 *
 */
#define BCM56218_A0_READ_IBCAST_BLOCK_MASK_HIr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_IBCAST_BLOCK_MASK_HIr,(r._ibcast_block_mask_hi))
#define BCM56218_A0_WRITE_IBCAST_BLOCK_MASK_HIr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_IBCAST_BLOCK_MASK_HIr,&(r._ibcast_block_mask_hi))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IBCAST_BLOCK_MASK_HIr BCM56218_A0_IBCAST_BLOCK_MASK_HIr
#define IBCAST_BLOCK_MASK_HIr_SIZE BCM56218_A0_IBCAST_BLOCK_MASK_HIr_SIZE
typedef BCM56218_A0_IBCAST_BLOCK_MASK_HIr_t IBCAST_BLOCK_MASK_HIr_t;
#define IBCAST_BLOCK_MASK_HIr_CLR BCM56218_A0_IBCAST_BLOCK_MASK_HIr_CLR
#define IBCAST_BLOCK_MASK_HIr_SET BCM56218_A0_IBCAST_BLOCK_MASK_HIr_SET
#define IBCAST_BLOCK_MASK_HIr_GET BCM56218_A0_IBCAST_BLOCK_MASK_HIr_GET
#define IBCAST_BLOCK_MASK_HIr_BLK_BITMAPf_GET BCM56218_A0_IBCAST_BLOCK_MASK_HIr_BLK_BITMAPf_GET
#define IBCAST_BLOCK_MASK_HIr_BLK_BITMAPf_SET BCM56218_A0_IBCAST_BLOCK_MASK_HIr_BLK_BITMAPf_SET
#define READ_IBCAST_BLOCK_MASK_HIr BCM56218_A0_READ_IBCAST_BLOCK_MASK_HIr
#define WRITE_IBCAST_BLOCK_MASK_HIr BCM56218_A0_WRITE_IBCAST_BLOCK_MASK_HIr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_IBCAST_BLOCK_MASK_HIr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  IBPBKPSTATUS
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     PORT_BITMAP      Current Back Pressure warning status
 *
 ******************************************************************************/
#define BCM56218_A0_IBPBKPSTATUSr 0x00680002

#define BCM56218_A0_IBPBKPSTATUSr_SIZE 4

/*
 * This structure should be used to declare and program IBPBKPSTATUS.
 *
 */
typedef union BCM56218_A0_IBPBKPSTATUSr_s {
	uint32_t v[1];
	uint32_t ibpbkpstatus[1];
	uint32_t _ibpbkpstatus;
} BCM56218_A0_IBPBKPSTATUSr_t;

#define BCM56218_A0_IBPBKPSTATUSr_CLR(r) (r).ibpbkpstatus[0] = 0
#define BCM56218_A0_IBPBKPSTATUSr_SET(r,d) (r).ibpbkpstatus[0] = d
#define BCM56218_A0_IBPBKPSTATUSr_GET(r) (r).ibpbkpstatus[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_IBPBKPSTATUSr_PORT_BITMAPf_GET(r) ((r).ibpbkpstatus[0])
#define BCM56218_A0_IBPBKPSTATUSr_PORT_BITMAPf_SET(r,f) (r).ibpbkpstatus[0]=((uint32_t)f)

/*
 * These macros can be used to access IBPBKPSTATUS.
 *
 */
#define BCM56218_A0_READ_IBPBKPSTATUSr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_IBPBKPSTATUSr,(r._ibpbkpstatus))
#define BCM56218_A0_WRITE_IBPBKPSTATUSr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_IBPBKPSTATUSr,&(r._ibpbkpstatus))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IBPBKPSTATUSr BCM56218_A0_IBPBKPSTATUSr
#define IBPBKPSTATUSr_SIZE BCM56218_A0_IBPBKPSTATUSr_SIZE
typedef BCM56218_A0_IBPBKPSTATUSr_t IBPBKPSTATUSr_t;
#define IBPBKPSTATUSr_CLR BCM56218_A0_IBPBKPSTATUSr_CLR
#define IBPBKPSTATUSr_SET BCM56218_A0_IBPBKPSTATUSr_SET
#define IBPBKPSTATUSr_GET BCM56218_A0_IBPBKPSTATUSr_GET
#define IBPBKPSTATUSr_PORT_BITMAPf_GET BCM56218_A0_IBPBKPSTATUSr_PORT_BITMAPf_GET
#define IBPBKPSTATUSr_PORT_BITMAPf_SET BCM56218_A0_IBPBKPSTATUSr_PORT_BITMAPf_SET
#define READ_IBPBKPSTATUSr BCM56218_A0_READ_IBPBKPSTATUSr
#define WRITE_IBPBKPSTATUSr BCM56218_A0_WRITE_IBPBKPSTATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_IBPBKPSTATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  IBPBKPSTATUS_HI
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     PORT_BITMAP      Current Back Pressure warning status for port 53-32
 *
 ******************************************************************************/
#define BCM56218_A0_IBPBKPSTATUS_HIr 0x00680003

#define BCM56218_A0_IBPBKPSTATUS_HIr_SIZE 4

/*
 * This structure should be used to declare and program IBPBKPSTATUS_HI.
 *
 */
typedef union BCM56218_A0_IBPBKPSTATUS_HIr_s {
	uint32_t v[1];
	uint32_t ibpbkpstatus_hi[1];
	uint32_t _ibpbkpstatus_hi;
} BCM56218_A0_IBPBKPSTATUS_HIr_t;

#define BCM56218_A0_IBPBKPSTATUS_HIr_CLR(r) (r).ibpbkpstatus_hi[0] = 0
#define BCM56218_A0_IBPBKPSTATUS_HIr_SET(r,d) (r).ibpbkpstatus_hi[0] = d
#define BCM56218_A0_IBPBKPSTATUS_HIr_GET(r) (r).ibpbkpstatus_hi[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_IBPBKPSTATUS_HIr_PORT_BITMAPf_GET(r) (((r).ibpbkpstatus_hi[0]) & 0x3fffff)
#define BCM56218_A0_IBPBKPSTATUS_HIr_PORT_BITMAPf_SET(r,f) (r).ibpbkpstatus_hi[0]=(((r).ibpbkpstatus_hi[0] & ~((uint32_t)0x3fffff)) | (((uint32_t)f) & 0x3fffff))

/*
 * These macros can be used to access IBPBKPSTATUS_HI.
 *
 */
#define BCM56218_A0_READ_IBPBKPSTATUS_HIr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_IBPBKPSTATUS_HIr,(r._ibpbkpstatus_hi))
#define BCM56218_A0_WRITE_IBPBKPSTATUS_HIr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_IBPBKPSTATUS_HIr,&(r._ibpbkpstatus_hi))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IBPBKPSTATUS_HIr BCM56218_A0_IBPBKPSTATUS_HIr
#define IBPBKPSTATUS_HIr_SIZE BCM56218_A0_IBPBKPSTATUS_HIr_SIZE
typedef BCM56218_A0_IBPBKPSTATUS_HIr_t IBPBKPSTATUS_HIr_t;
#define IBPBKPSTATUS_HIr_CLR BCM56218_A0_IBPBKPSTATUS_HIr_CLR
#define IBPBKPSTATUS_HIr_SET BCM56218_A0_IBPBKPSTATUS_HIr_SET
#define IBPBKPSTATUS_HIr_GET BCM56218_A0_IBPBKPSTATUS_HIr_GET
#define IBPBKPSTATUS_HIr_PORT_BITMAPf_GET BCM56218_A0_IBPBKPSTATUS_HIr_PORT_BITMAPf_GET
#define IBPBKPSTATUS_HIr_PORT_BITMAPf_SET BCM56218_A0_IBPBKPSTATUS_HIr_PORT_BITMAPf_SET
#define READ_IBPBKPSTATUS_HIr BCM56218_A0_READ_IBPBKPSTATUS_HIr
#define WRITE_IBPBKPSTATUS_HIr BCM56218_A0_WRITE_IBPBKPSTATUS_HIr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_IBPBKPSTATUS_HIr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  IBPCELLCOUNT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CELLCOUNT        Ingress cell count for all local ingress ports.Number of cells stored per ingress port in CBP Memory.
 *
 ******************************************************************************/
#define BCM56218_A0_IBPCELLCOUNTr 0x00600004

#define BCM56218_A0_IBPCELLCOUNTr_SIZE 4

/*
 * This structure should be used to declare and program IBPCELLCOUNT.
 *
 */
typedef union BCM56218_A0_IBPCELLCOUNTr_s {
	uint32_t v[1];
	uint32_t ibpcellcount[1];
	uint32_t _ibpcellcount;
} BCM56218_A0_IBPCELLCOUNTr_t;

#define BCM56218_A0_IBPCELLCOUNTr_CLR(r) (r).ibpcellcount[0] = 0
#define BCM56218_A0_IBPCELLCOUNTr_SET(r,d) (r).ibpcellcount[0] = d
#define BCM56218_A0_IBPCELLCOUNTr_GET(r) (r).ibpcellcount[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_IBPCELLCOUNTr_CELLCOUNTf_GET(r) (((r).ibpcellcount[0]) & 0x3fff)
#define BCM56218_A0_IBPCELLCOUNTr_CELLCOUNTf_SET(r,f) (r).ibpcellcount[0]=(((r).ibpcellcount[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access IBPCELLCOUNT.
 *
 */
#define BCM56218_A0_READ_IBPCELLCOUNTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_IBPCELLCOUNTr,(r._ibpcellcount))
#define BCM56218_A0_WRITE_IBPCELLCOUNTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_IBPCELLCOUNTr,&(r._ibpcellcount))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IBPCELLCOUNTr BCM56218_A0_IBPCELLCOUNTr
#define IBPCELLCOUNTr_SIZE BCM56218_A0_IBPCELLCOUNTr_SIZE
typedef BCM56218_A0_IBPCELLCOUNTr_t IBPCELLCOUNTr_t;
#define IBPCELLCOUNTr_CLR BCM56218_A0_IBPCELLCOUNTr_CLR
#define IBPCELLCOUNTr_SET BCM56218_A0_IBPCELLCOUNTr_SET
#define IBPCELLCOUNTr_GET BCM56218_A0_IBPCELLCOUNTr_GET
#define IBPCELLCOUNTr_CELLCOUNTf_GET BCM56218_A0_IBPCELLCOUNTr_CELLCOUNTf_GET
#define IBPCELLCOUNTr_CELLCOUNTf_SET BCM56218_A0_IBPCELLCOUNTr_CELLCOUNTf_SET
#define READ_IBPCELLCOUNTr BCM56218_A0_READ_IBPCELLCOUNTr
#define WRITE_IBPCELLCOUNTr BCM56218_A0_WRITE_IBPCELLCOUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_IBPCELLCOUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  IBPCELLSETLIMIT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CELLSETLIMIT     Back Pressure cell high threshold for all local ingress ports\' cell counts. Unit is the number of cells per port.Modify this register during the traffic is an illeagal opreation, will cause unrecoverable damage on MMU.
 *     RESETLIMITSEL    IBP Cell Reset Threshold for all local ingress ports.When Back pressure status is set, packet counts have to fall below Reset Threshold in order to clear BKP status. 2'b00: 75.0% of IBP Cell Set Limit.2'b01: 50.0% of IBP Cell Set Limit.    2'b10: 25.0% of IBP Cell Set Limit.    2'b11: 100% of IBP Cell Set Limit.    Modify this register during the traffic is an illeagal opreation, will cause unrecoverable damage on MMU.
 *
 ******************************************************************************/
#define BCM56218_A0_IBPCELLSETLIMITr 0x00600002

#define BCM56218_A0_IBPCELLSETLIMITr_SIZE 4

/*
 * This structure should be used to declare and program IBPCELLSETLIMIT.
 *
 */
typedef union BCM56218_A0_IBPCELLSETLIMITr_s {
	uint32_t v[1];
	uint32_t ibpcellsetlimit[1];
	uint32_t _ibpcellsetlimit;
} BCM56218_A0_IBPCELLSETLIMITr_t;

#define BCM56218_A0_IBPCELLSETLIMITr_CLR(r) (r).ibpcellsetlimit[0] = 0
#define BCM56218_A0_IBPCELLSETLIMITr_SET(r,d) (r).ibpcellsetlimit[0] = d
#define BCM56218_A0_IBPCELLSETLIMITr_GET(r) (r).ibpcellsetlimit[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_IBPCELLSETLIMITr_CELLSETLIMITf_GET(r) (((r).ibpcellsetlimit[0]) & 0x3fff)
#define BCM56218_A0_IBPCELLSETLIMITr_CELLSETLIMITf_SET(r,f) (r).ibpcellsetlimit[0]=(((r).ibpcellsetlimit[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM56218_A0_IBPCELLSETLIMITr_RESETLIMITSELf_GET(r) ((((r).ibpcellsetlimit[0]) >> 14) & 0x3)
#define BCM56218_A0_IBPCELLSETLIMITr_RESETLIMITSELf_SET(r,f) (r).ibpcellsetlimit[0]=(((r).ibpcellsetlimit[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))

/*
 * These macros can be used to access IBPCELLSETLIMIT.
 *
 */
#define BCM56218_A0_READ_IBPCELLSETLIMITr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_IBPCELLSETLIMITr,(r._ibpcellsetlimit))
#define BCM56218_A0_WRITE_IBPCELLSETLIMITr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_IBPCELLSETLIMITr,&(r._ibpcellsetlimit))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IBPCELLSETLIMITr BCM56218_A0_IBPCELLSETLIMITr
#define IBPCELLSETLIMITr_SIZE BCM56218_A0_IBPCELLSETLIMITr_SIZE
typedef BCM56218_A0_IBPCELLSETLIMITr_t IBPCELLSETLIMITr_t;
#define IBPCELLSETLIMITr_CLR BCM56218_A0_IBPCELLSETLIMITr_CLR
#define IBPCELLSETLIMITr_SET BCM56218_A0_IBPCELLSETLIMITr_SET
#define IBPCELLSETLIMITr_GET BCM56218_A0_IBPCELLSETLIMITr_GET
#define IBPCELLSETLIMITr_CELLSETLIMITf_GET BCM56218_A0_IBPCELLSETLIMITr_CELLSETLIMITf_GET
#define IBPCELLSETLIMITr_CELLSETLIMITf_SET BCM56218_A0_IBPCELLSETLIMITr_CELLSETLIMITf_SET
#define IBPCELLSETLIMITr_RESETLIMITSELf_GET BCM56218_A0_IBPCELLSETLIMITr_RESETLIMITSELf_GET
#define IBPCELLSETLIMITr_RESETLIMITSELf_SET BCM56218_A0_IBPCELLSETLIMITr_RESETLIMITSELf_SET
#define READ_IBPCELLSETLIMITr BCM56218_A0_READ_IBPCELLSETLIMITr
#define WRITE_IBPCELLSETLIMITr BCM56218_A0_WRITE_IBPCELLSETLIMITr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_IBPCELLSETLIMITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  IBPDISCARDSETLIMIT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     DISCARDSETLIMIT  Back Pressure Discard threshold for all local ingress ports cell counts.When an ingress port\'s cell count is above Discard Set Limit, all of incoming packet from this port are discarded. Discard Limit must be set above than IBPCELLSETLIMIT to prevent unexpected behavior. This limit represents an absolute value and is not related to IBPCELLSETLIMIT. Unit is the number of cells per port.
 *
 ******************************************************************************/
#define BCM56218_A0_IBPDISCARDSETLIMITr 0x00600003

#define BCM56218_A0_IBPDISCARDSETLIMITr_SIZE 4

/*
 * This structure should be used to declare and program IBPDISCARDSETLIMIT.
 *
 */
typedef union BCM56218_A0_IBPDISCARDSETLIMITr_s {
	uint32_t v[1];
	uint32_t ibpdiscardsetlimit[1];
	uint32_t _ibpdiscardsetlimit;
} BCM56218_A0_IBPDISCARDSETLIMITr_t;

#define BCM56218_A0_IBPDISCARDSETLIMITr_CLR(r) (r).ibpdiscardsetlimit[0] = 0
#define BCM56218_A0_IBPDISCARDSETLIMITr_SET(r,d) (r).ibpdiscardsetlimit[0] = d
#define BCM56218_A0_IBPDISCARDSETLIMITr_GET(r) (r).ibpdiscardsetlimit[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_IBPDISCARDSETLIMITr_DISCARDSETLIMITf_GET(r) (((r).ibpdiscardsetlimit[0]) & 0x3fff)
#define BCM56218_A0_IBPDISCARDSETLIMITr_DISCARDSETLIMITf_SET(r,f) (r).ibpdiscardsetlimit[0]=(((r).ibpdiscardsetlimit[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access IBPDISCARDSETLIMIT.
 *
 */
#define BCM56218_A0_READ_IBPDISCARDSETLIMITr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_IBPDISCARDSETLIMITr,(r._ibpdiscardsetlimit))
#define BCM56218_A0_WRITE_IBPDISCARDSETLIMITr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_IBPDISCARDSETLIMITr,&(r._ibpdiscardsetlimit))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IBPDISCARDSETLIMITr BCM56218_A0_IBPDISCARDSETLIMITr
#define IBPDISCARDSETLIMITr_SIZE BCM56218_A0_IBPDISCARDSETLIMITr_SIZE
typedef BCM56218_A0_IBPDISCARDSETLIMITr_t IBPDISCARDSETLIMITr_t;
#define IBPDISCARDSETLIMITr_CLR BCM56218_A0_IBPDISCARDSETLIMITr_CLR
#define IBPDISCARDSETLIMITr_SET BCM56218_A0_IBPDISCARDSETLIMITr_SET
#define IBPDISCARDSETLIMITr_GET BCM56218_A0_IBPDISCARDSETLIMITr_GET
#define IBPDISCARDSETLIMITr_DISCARDSETLIMITf_GET BCM56218_A0_IBPDISCARDSETLIMITr_DISCARDSETLIMITf_GET
#define IBPDISCARDSETLIMITr_DISCARDSETLIMITf_SET BCM56218_A0_IBPDISCARDSETLIMITr_DISCARDSETLIMITf_SET
#define READ_IBPDISCARDSETLIMITr BCM56218_A0_READ_IBPDISCARDSETLIMITr
#define WRITE_IBPDISCARDSETLIMITr BCM56218_A0_WRITE_IBPDISCARDSETLIMITr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_IBPDISCARDSETLIMITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  IBPDISCSTATUS
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     PORT_BITMAP      Current IBP discard status
 *
 ******************************************************************************/
#define BCM56218_A0_IBPDISCSTATUSr 0x00680006

#define BCM56218_A0_IBPDISCSTATUSr_SIZE 4

/*
 * This structure should be used to declare and program IBPDISCSTATUS.
 *
 */
typedef union BCM56218_A0_IBPDISCSTATUSr_s {
	uint32_t v[1];
	uint32_t ibpdiscstatus[1];
	uint32_t _ibpdiscstatus;
} BCM56218_A0_IBPDISCSTATUSr_t;

#define BCM56218_A0_IBPDISCSTATUSr_CLR(r) (r).ibpdiscstatus[0] = 0
#define BCM56218_A0_IBPDISCSTATUSr_SET(r,d) (r).ibpdiscstatus[0] = d
#define BCM56218_A0_IBPDISCSTATUSr_GET(r) (r).ibpdiscstatus[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_IBPDISCSTATUSr_PORT_BITMAPf_GET(r) ((r).ibpdiscstatus[0])
#define BCM56218_A0_IBPDISCSTATUSr_PORT_BITMAPf_SET(r,f) (r).ibpdiscstatus[0]=((uint32_t)f)

/*
 * These macros can be used to access IBPDISCSTATUS.
 *
 */
#define BCM56218_A0_READ_IBPDISCSTATUSr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_IBPDISCSTATUSr,(r._ibpdiscstatus))
#define BCM56218_A0_WRITE_IBPDISCSTATUSr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_IBPDISCSTATUSr,&(r._ibpdiscstatus))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IBPDISCSTATUSr BCM56218_A0_IBPDISCSTATUSr
#define IBPDISCSTATUSr_SIZE BCM56218_A0_IBPDISCSTATUSr_SIZE
typedef BCM56218_A0_IBPDISCSTATUSr_t IBPDISCSTATUSr_t;
#define IBPDISCSTATUSr_CLR BCM56218_A0_IBPDISCSTATUSr_CLR
#define IBPDISCSTATUSr_SET BCM56218_A0_IBPDISCSTATUSr_SET
#define IBPDISCSTATUSr_GET BCM56218_A0_IBPDISCSTATUSr_GET
#define IBPDISCSTATUSr_PORT_BITMAPf_GET BCM56218_A0_IBPDISCSTATUSr_PORT_BITMAPf_GET
#define IBPDISCSTATUSr_PORT_BITMAPf_SET BCM56218_A0_IBPDISCSTATUSr_PORT_BITMAPf_SET
#define READ_IBPDISCSTATUSr BCM56218_A0_READ_IBPDISCSTATUSr
#define WRITE_IBPDISCSTATUSr BCM56218_A0_WRITE_IBPDISCSTATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_IBPDISCSTATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  IBPDISCSTATUS_HI
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     PORT_BITMAP      Current IBP discard status for port 53-32
 *
 ******************************************************************************/
#define BCM56218_A0_IBPDISCSTATUS_HIr 0x00680007

#define BCM56218_A0_IBPDISCSTATUS_HIr_SIZE 4

/*
 * This structure should be used to declare and program IBPDISCSTATUS_HI.
 *
 */
typedef union BCM56218_A0_IBPDISCSTATUS_HIr_s {
	uint32_t v[1];
	uint32_t ibpdiscstatus_hi[1];
	uint32_t _ibpdiscstatus_hi;
} BCM56218_A0_IBPDISCSTATUS_HIr_t;

#define BCM56218_A0_IBPDISCSTATUS_HIr_CLR(r) (r).ibpdiscstatus_hi[0] = 0
#define BCM56218_A0_IBPDISCSTATUS_HIr_SET(r,d) (r).ibpdiscstatus_hi[0] = d
#define BCM56218_A0_IBPDISCSTATUS_HIr_GET(r) (r).ibpdiscstatus_hi[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_IBPDISCSTATUS_HIr_PORT_BITMAPf_GET(r) (((r).ibpdiscstatus_hi[0]) & 0x3fffff)
#define BCM56218_A0_IBPDISCSTATUS_HIr_PORT_BITMAPf_SET(r,f) (r).ibpdiscstatus_hi[0]=(((r).ibpdiscstatus_hi[0] & ~((uint32_t)0x3fffff)) | (((uint32_t)f) & 0x3fffff))

/*
 * These macros can be used to access IBPDISCSTATUS_HI.
 *
 */
#define BCM56218_A0_READ_IBPDISCSTATUS_HIr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_IBPDISCSTATUS_HIr,(r._ibpdiscstatus_hi))
#define BCM56218_A0_WRITE_IBPDISCSTATUS_HIr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_IBPDISCSTATUS_HIr,&(r._ibpdiscstatus_hi))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IBPDISCSTATUS_HIr BCM56218_A0_IBPDISCSTATUS_HIr
#define IBPDISCSTATUS_HIr_SIZE BCM56218_A0_IBPDISCSTATUS_HIr_SIZE
typedef BCM56218_A0_IBPDISCSTATUS_HIr_t IBPDISCSTATUS_HIr_t;
#define IBPDISCSTATUS_HIr_CLR BCM56218_A0_IBPDISCSTATUS_HIr_CLR
#define IBPDISCSTATUS_HIr_SET BCM56218_A0_IBPDISCSTATUS_HIr_SET
#define IBPDISCSTATUS_HIr_GET BCM56218_A0_IBPDISCSTATUS_HIr_GET
#define IBPDISCSTATUS_HIr_PORT_BITMAPf_GET BCM56218_A0_IBPDISCSTATUS_HIr_PORT_BITMAPf_GET
#define IBPDISCSTATUS_HIr_PORT_BITMAPf_SET BCM56218_A0_IBPDISCSTATUS_HIr_PORT_BITMAPf_SET
#define READ_IBPDISCSTATUS_HIr BCM56218_A0_READ_IBPDISCSTATUS_HIr
#define WRITE_IBPDISCSTATUS_HIr BCM56218_A0_WRITE_IBPDISCSTATUS_HIr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_IBPDISCSTATUS_HIr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  IBPPKTCOUNT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     PKTCOUNT         Ingress packet count for all local ingress ports.Number of packets stored per ingress port in XQ memories.
 *
 ******************************************************************************/
#define BCM56218_A0_IBPPKTCOUNTr 0x00600001

#define BCM56218_A0_IBPPKTCOUNTr_SIZE 4

/*
 * This structure should be used to declare and program IBPPKTCOUNT.
 *
 */
typedef union BCM56218_A0_IBPPKTCOUNTr_s {
	uint32_t v[1];
	uint32_t ibppktcount[1];
	uint32_t _ibppktcount;
} BCM56218_A0_IBPPKTCOUNTr_t;

#define BCM56218_A0_IBPPKTCOUNTr_CLR(r) (r).ibppktcount[0] = 0
#define BCM56218_A0_IBPPKTCOUNTr_SET(r,d) (r).ibppktcount[0] = d
#define BCM56218_A0_IBPPKTCOUNTr_GET(r) (r).ibppktcount[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_IBPPKTCOUNTr_PKTCOUNTf_GET(r) (((r).ibppktcount[0]) & 0x3fff)
#define BCM56218_A0_IBPPKTCOUNTr_PKTCOUNTf_SET(r,f) (r).ibppktcount[0]=(((r).ibppktcount[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access IBPPKTCOUNT.
 *
 */
#define BCM56218_A0_READ_IBPPKTCOUNTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_IBPPKTCOUNTr,(r._ibppktcount))
#define BCM56218_A0_WRITE_IBPPKTCOUNTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_IBPPKTCOUNTr,&(r._ibppktcount))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IBPPKTCOUNTr BCM56218_A0_IBPPKTCOUNTr
#define IBPPKTCOUNTr_SIZE BCM56218_A0_IBPPKTCOUNTr_SIZE
typedef BCM56218_A0_IBPPKTCOUNTr_t IBPPKTCOUNTr_t;
#define IBPPKTCOUNTr_CLR BCM56218_A0_IBPPKTCOUNTr_CLR
#define IBPPKTCOUNTr_SET BCM56218_A0_IBPPKTCOUNTr_SET
#define IBPPKTCOUNTr_GET BCM56218_A0_IBPPKTCOUNTr_GET
#define IBPPKTCOUNTr_PKTCOUNTf_GET BCM56218_A0_IBPPKTCOUNTr_PKTCOUNTf_GET
#define IBPPKTCOUNTr_PKTCOUNTf_SET BCM56218_A0_IBPPKTCOUNTr_PKTCOUNTf_SET
#define READ_IBPPKTCOUNTr BCM56218_A0_READ_IBPPKTCOUNTr
#define WRITE_IBPPKTCOUNTr BCM56218_A0_WRITE_IBPPKTCOUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_IBPPKTCOUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  IBPPKTSETLIMIT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     PKTSETLIMIT      Back Pressure packet high threshold for all local ingress ports packet counts. Unit is the number of packets per port.Modify this register during the traffic is an illeagal opreation, will cause unrecoverable damage on MMU.
 *     RESETLIMITSEL    IBP Packet Reset Threshold Select opions for all local ingress ports.When Back pressure status is set, packet counts have to fall below Reset Threshold in order to clear BKP status. 2'b00: 75.0% of IBP Packet Set Limit.2'b01: 50.0% of IBP Packet Set Limit.  2'b10: 25.0% of IBP Packet Set Limit.  2'b11: 100% of IBP Packet Set Limit.  Modify this register during the traffic is an illeagal opreation, will cause unrecoverable damage on MMU.
 *
 ******************************************************************************/
#define BCM56218_A0_IBPPKTSETLIMITr 0x00600000

#define BCM56218_A0_IBPPKTSETLIMITr_SIZE 4

/*
 * This structure should be used to declare and program IBPPKTSETLIMIT.
 *
 */
typedef union BCM56218_A0_IBPPKTSETLIMITr_s {
	uint32_t v[1];
	uint32_t ibppktsetlimit[1];
	uint32_t _ibppktsetlimit;
} BCM56218_A0_IBPPKTSETLIMITr_t;

#define BCM56218_A0_IBPPKTSETLIMITr_CLR(r) (r).ibppktsetlimit[0] = 0
#define BCM56218_A0_IBPPKTSETLIMITr_SET(r,d) (r).ibppktsetlimit[0] = d
#define BCM56218_A0_IBPPKTSETLIMITr_GET(r) (r).ibppktsetlimit[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_IBPPKTSETLIMITr_PKTSETLIMITf_GET(r) (((r).ibppktsetlimit[0]) & 0x3fff)
#define BCM56218_A0_IBPPKTSETLIMITr_PKTSETLIMITf_SET(r,f) (r).ibppktsetlimit[0]=(((r).ibppktsetlimit[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM56218_A0_IBPPKTSETLIMITr_RESETLIMITSELf_GET(r) ((((r).ibppktsetlimit[0]) >> 14) & 0x3)
#define BCM56218_A0_IBPPKTSETLIMITr_RESETLIMITSELf_SET(r,f) (r).ibppktsetlimit[0]=(((r).ibppktsetlimit[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))

/*
 * These macros can be used to access IBPPKTSETLIMIT.
 *
 */
#define BCM56218_A0_READ_IBPPKTSETLIMITr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_IBPPKTSETLIMITr,(r._ibppktsetlimit))
#define BCM56218_A0_WRITE_IBPPKTSETLIMITr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_IBPPKTSETLIMITr,&(r._ibppktsetlimit))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IBPPKTSETLIMITr BCM56218_A0_IBPPKTSETLIMITr
#define IBPPKTSETLIMITr_SIZE BCM56218_A0_IBPPKTSETLIMITr_SIZE
typedef BCM56218_A0_IBPPKTSETLIMITr_t IBPPKTSETLIMITr_t;
#define IBPPKTSETLIMITr_CLR BCM56218_A0_IBPPKTSETLIMITr_CLR
#define IBPPKTSETLIMITr_SET BCM56218_A0_IBPPKTSETLIMITr_SET
#define IBPPKTSETLIMITr_GET BCM56218_A0_IBPPKTSETLIMITr_GET
#define IBPPKTSETLIMITr_PKTSETLIMITf_GET BCM56218_A0_IBPPKTSETLIMITr_PKTSETLIMITf_GET
#define IBPPKTSETLIMITr_PKTSETLIMITf_SET BCM56218_A0_IBPPKTSETLIMITr_PKTSETLIMITf_SET
#define IBPPKTSETLIMITr_RESETLIMITSELf_GET BCM56218_A0_IBPPKTSETLIMITr_RESETLIMITSELf_GET
#define IBPPKTSETLIMITr_RESETLIMITSELf_SET BCM56218_A0_IBPPKTSETLIMITr_RESETLIMITSELf_SET
#define READ_IBPPKTSETLIMITr BCM56218_A0_READ_IBPPKTSETLIMITr
#define WRITE_IBPPKTSETLIMITr BCM56218_A0_WRITE_IBPPKTSETLIMITr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_IBPPKTSETLIMITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  ICONTROL_OPCODE_BITMAP
 * BLOCKS:   IPIPE_HI
 * DESC:     Higig control packet's switching bitmap register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           HiGig CONTROL opcode redirection
 *
 ******************************************************************************/
#define BCM56218_A0_ICONTROL_OPCODE_BITMAPr 0x0b800008

#define BCM56218_A0_ICONTROL_OPCODE_BITMAPr_SIZE 4

/*
 * This structure should be used to declare and program ICONTROL_OPCODE_BITMAP.
 *
 */
typedef union BCM56218_A0_ICONTROL_OPCODE_BITMAPr_s {
	uint32_t v[1];
	uint32_t icontrol_opcode_bitmap[1];
	uint32_t _icontrol_opcode_bitmap;
} BCM56218_A0_ICONTROL_OPCODE_BITMAPr_t;

#define BCM56218_A0_ICONTROL_OPCODE_BITMAPr_CLR(r) (r).icontrol_opcode_bitmap[0] = 0
#define BCM56218_A0_ICONTROL_OPCODE_BITMAPr_SET(r,d) (r).icontrol_opcode_bitmap[0] = d
#define BCM56218_A0_ICONTROL_OPCODE_BITMAPr_GET(r) (r).icontrol_opcode_bitmap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_ICONTROL_OPCODE_BITMAPr_BITMAPf_GET(r) (((r).icontrol_opcode_bitmap[0]) & 0x7)
#define BCM56218_A0_ICONTROL_OPCODE_BITMAPr_BITMAPf_SET(r,f) (r).icontrol_opcode_bitmap[0]=(((r).icontrol_opcode_bitmap[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))

/*
 * These macros can be used to access ICONTROL_OPCODE_BITMAP.
 *
 */
#define BCM56218_A0_READ_ICONTROL_OPCODE_BITMAPr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_ICONTROL_OPCODE_BITMAPr,(r._icontrol_opcode_bitmap))
#define BCM56218_A0_WRITE_ICONTROL_OPCODE_BITMAPr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_ICONTROL_OPCODE_BITMAPr,&(r._icontrol_opcode_bitmap))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ICONTROL_OPCODE_BITMAPr BCM56218_A0_ICONTROL_OPCODE_BITMAPr
#define ICONTROL_OPCODE_BITMAPr_SIZE BCM56218_A0_ICONTROL_OPCODE_BITMAPr_SIZE
typedef BCM56218_A0_ICONTROL_OPCODE_BITMAPr_t ICONTROL_OPCODE_BITMAPr_t;
#define ICONTROL_OPCODE_BITMAPr_CLR BCM56218_A0_ICONTROL_OPCODE_BITMAPr_CLR
#define ICONTROL_OPCODE_BITMAPr_SET BCM56218_A0_ICONTROL_OPCODE_BITMAPr_SET
#define ICONTROL_OPCODE_BITMAPr_GET BCM56218_A0_ICONTROL_OPCODE_BITMAPr_GET
#define ICONTROL_OPCODE_BITMAPr_BITMAPf_GET BCM56218_A0_ICONTROL_OPCODE_BITMAPr_BITMAPf_GET
#define ICONTROL_OPCODE_BITMAPr_BITMAPf_SET BCM56218_A0_ICONTROL_OPCODE_BITMAPr_BITMAPf_SET
#define READ_ICONTROL_OPCODE_BITMAPr BCM56218_A0_READ_ICONTROL_OPCODE_BITMAPr
#define WRITE_ICONTROL_OPCODE_BITMAPr BCM56218_A0_WRITE_ICONTROL_OPCODE_BITMAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_ICONTROL_OPCODE_BITMAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  ICOS_SEL
 * BLOCKS:   IPIPE_HI
 * DESC:     COS Queue Mapping Register based on internal priority
 * SIZE:     32
 * FIELDS:
 *     COS0             COS-0 Value
 *     COS1             COS-1 Value
 *     COS2             COS-2 Value
 *     COS3             COS-3 Value
 *     COS4             COS-4 Value
 *     COS5             COS-5 Value
 *     COS6             COS-6 Value
 *     COS7             COS-7 Value
 *
 ******************************************************************************/
#define BCM56218_A0_ICOS_SELr 0x0e80010f

#define BCM56218_A0_ICOS_SELr_SIZE 4

/*
 * This structure should be used to declare and program ICOS_SEL.
 *
 */
typedef union BCM56218_A0_ICOS_SELr_s {
	uint32_t v[1];
	uint32_t icos_sel[1];
	uint32_t _icos_sel;
} BCM56218_A0_ICOS_SELr_t;

#define BCM56218_A0_ICOS_SELr_CLR(r) (r).icos_sel[0] = 0
#define BCM56218_A0_ICOS_SELr_SET(r,d) (r).icos_sel[0] = d
#define BCM56218_A0_ICOS_SELr_GET(r) (r).icos_sel[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_ICOS_SELr_COS0f_GET(r) (((r).icos_sel[0]) & 0x7)
#define BCM56218_A0_ICOS_SELr_COS0f_SET(r,f) (r).icos_sel[0]=(((r).icos_sel[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM56218_A0_ICOS_SELr_COS1f_GET(r) ((((r).icos_sel[0]) >> 3) & 0x7)
#define BCM56218_A0_ICOS_SELr_COS1f_SET(r,f) (r).icos_sel[0]=(((r).icos_sel[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM56218_A0_ICOS_SELr_COS2f_GET(r) ((((r).icos_sel[0]) >> 6) & 0x7)
#define BCM56218_A0_ICOS_SELr_COS2f_SET(r,f) (r).icos_sel[0]=(((r).icos_sel[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM56218_A0_ICOS_SELr_COS3f_GET(r) ((((r).icos_sel[0]) >> 9) & 0x7)
#define BCM56218_A0_ICOS_SELr_COS3f_SET(r,f) (r).icos_sel[0]=(((r).icos_sel[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM56218_A0_ICOS_SELr_COS4f_GET(r) ((((r).icos_sel[0]) >> 12) & 0x7)
#define BCM56218_A0_ICOS_SELr_COS4f_SET(r,f) (r).icos_sel[0]=(((r).icos_sel[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM56218_A0_ICOS_SELr_COS5f_GET(r) ((((r).icos_sel[0]) >> 15) & 0x7)
#define BCM56218_A0_ICOS_SELr_COS5f_SET(r,f) (r).icos_sel[0]=(((r).icos_sel[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM56218_A0_ICOS_SELr_COS6f_GET(r) ((((r).icos_sel[0]) >> 18) & 0x7)
#define BCM56218_A0_ICOS_SELr_COS6f_SET(r,f) (r).icos_sel[0]=(((r).icos_sel[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM56218_A0_ICOS_SELr_COS7f_GET(r) ((((r).icos_sel[0]) >> 21) & 0x7)
#define BCM56218_A0_ICOS_SELr_COS7f_SET(r,f) (r).icos_sel[0]=(((r).icos_sel[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))

/*
 * These macros can be used to access ICOS_SEL.
 *
 */
#define BCM56218_A0_READ_ICOS_SELr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_ICOS_SELr,(r._icos_sel))
#define BCM56218_A0_WRITE_ICOS_SELr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_ICOS_SELr,&(r._icos_sel))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ICOS_SELr BCM56218_A0_ICOS_SELr
#define ICOS_SELr_SIZE BCM56218_A0_ICOS_SELr_SIZE
typedef BCM56218_A0_ICOS_SELr_t ICOS_SELr_t;
#define ICOS_SELr_CLR BCM56218_A0_ICOS_SELr_CLR
#define ICOS_SELr_SET BCM56218_A0_ICOS_SELr_SET
#define ICOS_SELr_GET BCM56218_A0_ICOS_SELr_GET
#define ICOS_SELr_COS0f_GET BCM56218_A0_ICOS_SELr_COS0f_GET
#define ICOS_SELr_COS0f_SET BCM56218_A0_ICOS_SELr_COS0f_SET
#define ICOS_SELr_COS1f_GET BCM56218_A0_ICOS_SELr_COS1f_GET
#define ICOS_SELr_COS1f_SET BCM56218_A0_ICOS_SELr_COS1f_SET
#define ICOS_SELr_COS2f_GET BCM56218_A0_ICOS_SELr_COS2f_GET
#define ICOS_SELr_COS2f_SET BCM56218_A0_ICOS_SELr_COS2f_SET
#define ICOS_SELr_COS3f_GET BCM56218_A0_ICOS_SELr_COS3f_GET
#define ICOS_SELr_COS3f_SET BCM56218_A0_ICOS_SELr_COS3f_SET
#define ICOS_SELr_COS4f_GET BCM56218_A0_ICOS_SELr_COS4f_GET
#define ICOS_SELr_COS4f_SET BCM56218_A0_ICOS_SELr_COS4f_SET
#define ICOS_SELr_COS5f_GET BCM56218_A0_ICOS_SELr_COS5f_GET
#define ICOS_SELr_COS5f_SET BCM56218_A0_ICOS_SELr_COS5f_SET
#define ICOS_SELr_COS6f_GET BCM56218_A0_ICOS_SELr_COS6f_GET
#define ICOS_SELr_COS6f_SET BCM56218_A0_ICOS_SELr_COS6f_SET
#define ICOS_SELr_COS7f_GET BCM56218_A0_ICOS_SELr_COS7f_GET
#define ICOS_SELr_COS7f_SET BCM56218_A0_ICOS_SELr_COS7f_SET
#define READ_ICOS_SELr BCM56218_A0_READ_ICOS_SELr
#define WRITE_ICOS_SELr BCM56218_A0_WRITE_ICOS_SELr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_ICOS_SELr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  ICOS_SEL_2
 * BLOCKS:   IPIPE_HI
 * DESC:     COS Queue Mapping Register based on internal priority.
 * SIZE:     32
 * FIELDS:
 *     COS8             COS value for priority-8 Value
 *     COS9             COS value for priority-9 Value
 *     COS10            COS value for priority-10 Value
 *     COS11            COS value for priority-11 Value
 *     COS12            COS value for priority-12 Value
 *     COS13            COS value for priority-13 Value
 *     COS14            COS value for priority-14 Value
 *     COS15            COS value for priority-15 Value
 *
 ******************************************************************************/
#define BCM56218_A0_ICOS_SEL_2r 0x0e80012f

#define BCM56218_A0_ICOS_SEL_2r_SIZE 4

/*
 * This structure should be used to declare and program ICOS_SEL_2.
 *
 */
typedef union BCM56218_A0_ICOS_SEL_2r_s {
	uint32_t v[1];
	uint32_t icos_sel_2[1];
	uint32_t _icos_sel_2;
} BCM56218_A0_ICOS_SEL_2r_t;

#define BCM56218_A0_ICOS_SEL_2r_CLR(r) (r).icos_sel_2[0] = 0
#define BCM56218_A0_ICOS_SEL_2r_SET(r,d) (r).icos_sel_2[0] = d
#define BCM56218_A0_ICOS_SEL_2r_GET(r) (r).icos_sel_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_ICOS_SEL_2r_COS8f_GET(r) (((r).icos_sel_2[0]) & 0x7)
#define BCM56218_A0_ICOS_SEL_2r_COS8f_SET(r,f) (r).icos_sel_2[0]=(((r).icos_sel_2[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM56218_A0_ICOS_SEL_2r_COS9f_GET(r) ((((r).icos_sel_2[0]) >> 3) & 0x7)
#define BCM56218_A0_ICOS_SEL_2r_COS9f_SET(r,f) (r).icos_sel_2[0]=(((r).icos_sel_2[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM56218_A0_ICOS_SEL_2r_COS10f_GET(r) ((((r).icos_sel_2[0]) >> 6) & 0x7)
#define BCM56218_A0_ICOS_SEL_2r_COS10f_SET(r,f) (r).icos_sel_2[0]=(((r).icos_sel_2[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM56218_A0_ICOS_SEL_2r_COS11f_GET(r) ((((r).icos_sel_2[0]) >> 9) & 0x7)
#define BCM56218_A0_ICOS_SEL_2r_COS11f_SET(r,f) (r).icos_sel_2[0]=(((r).icos_sel_2[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM56218_A0_ICOS_SEL_2r_COS12f_GET(r) ((((r).icos_sel_2[0]) >> 12) & 0x7)
#define BCM56218_A0_ICOS_SEL_2r_COS12f_SET(r,f) (r).icos_sel_2[0]=(((r).icos_sel_2[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM56218_A0_ICOS_SEL_2r_COS13f_GET(r) ((((r).icos_sel_2[0]) >> 15) & 0x7)
#define BCM56218_A0_ICOS_SEL_2r_COS13f_SET(r,f) (r).icos_sel_2[0]=(((r).icos_sel_2[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM56218_A0_ICOS_SEL_2r_COS14f_GET(r) ((((r).icos_sel_2[0]) >> 18) & 0x7)
#define BCM56218_A0_ICOS_SEL_2r_COS14f_SET(r,f) (r).icos_sel_2[0]=(((r).icos_sel_2[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM56218_A0_ICOS_SEL_2r_COS15f_GET(r) ((((r).icos_sel_2[0]) >> 21) & 0x7)
#define BCM56218_A0_ICOS_SEL_2r_COS15f_SET(r,f) (r).icos_sel_2[0]=(((r).icos_sel_2[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))

/*
 * These macros can be used to access ICOS_SEL_2.
 *
 */
#define BCM56218_A0_READ_ICOS_SEL_2r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_ICOS_SEL_2r,(r._icos_sel_2))
#define BCM56218_A0_WRITE_ICOS_SEL_2r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_ICOS_SEL_2r,&(r._icos_sel_2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ICOS_SEL_2r BCM56218_A0_ICOS_SEL_2r
#define ICOS_SEL_2r_SIZE BCM56218_A0_ICOS_SEL_2r_SIZE
typedef BCM56218_A0_ICOS_SEL_2r_t ICOS_SEL_2r_t;
#define ICOS_SEL_2r_CLR BCM56218_A0_ICOS_SEL_2r_CLR
#define ICOS_SEL_2r_SET BCM56218_A0_ICOS_SEL_2r_SET
#define ICOS_SEL_2r_GET BCM56218_A0_ICOS_SEL_2r_GET
#define ICOS_SEL_2r_COS8f_GET BCM56218_A0_ICOS_SEL_2r_COS8f_GET
#define ICOS_SEL_2r_COS8f_SET BCM56218_A0_ICOS_SEL_2r_COS8f_SET
#define ICOS_SEL_2r_COS9f_GET BCM56218_A0_ICOS_SEL_2r_COS9f_GET
#define ICOS_SEL_2r_COS9f_SET BCM56218_A0_ICOS_SEL_2r_COS9f_SET
#define ICOS_SEL_2r_COS10f_GET BCM56218_A0_ICOS_SEL_2r_COS10f_GET
#define ICOS_SEL_2r_COS10f_SET BCM56218_A0_ICOS_SEL_2r_COS10f_SET
#define ICOS_SEL_2r_COS11f_GET BCM56218_A0_ICOS_SEL_2r_COS11f_GET
#define ICOS_SEL_2r_COS11f_SET BCM56218_A0_ICOS_SEL_2r_COS11f_SET
#define ICOS_SEL_2r_COS12f_GET BCM56218_A0_ICOS_SEL_2r_COS12f_GET
#define ICOS_SEL_2r_COS12f_SET BCM56218_A0_ICOS_SEL_2r_COS12f_SET
#define ICOS_SEL_2r_COS13f_GET BCM56218_A0_ICOS_SEL_2r_COS13f_GET
#define ICOS_SEL_2r_COS13f_SET BCM56218_A0_ICOS_SEL_2r_COS13f_SET
#define ICOS_SEL_2r_COS14f_GET BCM56218_A0_ICOS_SEL_2r_COS14f_GET
#define ICOS_SEL_2r_COS14f_SET BCM56218_A0_ICOS_SEL_2r_COS14f_SET
#define ICOS_SEL_2r_COS15f_GET BCM56218_A0_ICOS_SEL_2r_COS15f_GET
#define ICOS_SEL_2r_COS15f_SET BCM56218_A0_ICOS_SEL_2r_COS15f_SET
#define READ_ICOS_SEL_2r BCM56218_A0_READ_ICOS_SEL_2r
#define WRITE_ICOS_SEL_2r BCM56218_A0_WRITE_ICOS_SEL_2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_ICOS_SEL_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  IEGR_PORT
 * BLOCKS:   EPIPE_HI
 * DESC:     Configuration Register for a Port. This is different for each GE, 10GE port.


 * SIZE:     32
 * FIELDS:
 *     PORT_TYPE        Specifies the type of the port. Bit[0] of PORT_TYPE field is HIGIG_BIT. If it is set, then the port is in Higig Mode.	0 = GE/10GE/CPU Port.	1 = HIGIG Port.Bit[1] of PORT_TYPE field is NNI_BIT. If it is set, then the port is NNI port, else UNI Port.	0 = UNI Port.	1 = NNI Port.
 *     HIGIG_PACKET     This port is a higig port.
 *     NNI_PORT         Port is NNI port if set to 1, otherwise UNI port.
 *     EN_EFILTER       RESERVED This feature is not supported for Raptor. This bit is don't care.
 *     PRESERVE_CPU_TAG Preserve the tag of the packet destines to CPU.
 *     CFI              If CFI-CNG mapping is enabled for the chip, i.e. EGR_CONFIG.CFI_AS_CNG bit is set, then thisfield corresponds to the values of CNG coming from MMU. e.g. If MMU.CNG = 0, then Packet.CFI = CFI[0]     If MMU.CNG = 1, then Packet.CFI = CFI[1] and so on.
 *     EM_SRCMOD_CHANGE Set to change the src_modid for the egress mirrored pkts going out of the higig port.
 *     MY_MODID         Module ID of this chip.
 *
 ******************************************************************************/
#define BCM56218_A0_IEGR_PORTr 0x01a00002

#define BCM56218_A0_IEGR_PORTr_SIZE 4

/*
 * This structure should be used to declare and program IEGR_PORT.
 *
 */
typedef union BCM56218_A0_IEGR_PORTr_s {
	uint32_t v[1];
	uint32_t iegr_port[1];
	uint32_t _iegr_port;
} BCM56218_A0_IEGR_PORTr_t;

#define BCM56218_A0_IEGR_PORTr_CLR(r) (r).iegr_port[0] = 0
#define BCM56218_A0_IEGR_PORTr_SET(r,d) (r).iegr_port[0] = d
#define BCM56218_A0_IEGR_PORTr_GET(r) (r).iegr_port[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_IEGR_PORTr_PORT_TYPEf_GET(r) (((r).iegr_port[0]) & 0x3)
#define BCM56218_A0_IEGR_PORTr_PORT_TYPEf_SET(r,f) (r).iegr_port[0]=(((r).iegr_port[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56218_A0_IEGR_PORTr_HIGIG_PACKETf_GET(r) (((r).iegr_port[0]) & 0x1)
#define BCM56218_A0_IEGR_PORTr_HIGIG_PACKETf_SET(r,f) (r).iegr_port[0]=(((r).iegr_port[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_IEGR_PORTr_NNI_PORTf_GET(r) ((((r).iegr_port[0]) >> 1) & 0x1)
#define BCM56218_A0_IEGR_PORTr_NNI_PORTf_SET(r,f) (r).iegr_port[0]=(((r).iegr_port[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_IEGR_PORTr_EN_EFILTERf_GET(r) ((((r).iegr_port[0]) >> 2) & 0x1)
#define BCM56218_A0_IEGR_PORTr_EN_EFILTERf_SET(r,f) (r).iegr_port[0]=(((r).iegr_port[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_IEGR_PORTr_PRESERVE_CPU_TAGf_GET(r) ((((r).iegr_port[0]) >> 3) & 0x1)
#define BCM56218_A0_IEGR_PORTr_PRESERVE_CPU_TAGf_SET(r,f) (r).iegr_port[0]=(((r).iegr_port[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56218_A0_IEGR_PORTr_CFIf_GET(r) ((((r).iegr_port[0]) >> 4) & 0xf)
#define BCM56218_A0_IEGR_PORTr_CFIf_SET(r,f) (r).iegr_port[0]=(((r).iegr_port[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56218_A0_IEGR_PORTr_EM_SRCMOD_CHANGEf_GET(r) ((((r).iegr_port[0]) >> 8) & 0x1)
#define BCM56218_A0_IEGR_PORTr_EM_SRCMOD_CHANGEf_SET(r,f) (r).iegr_port[0]=(((r).iegr_port[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56218_A0_IEGR_PORTr_MY_MODIDf_GET(r) ((((r).iegr_port[0]) >> 9) & 0xf)
#define BCM56218_A0_IEGR_PORTr_MY_MODIDf_SET(r,f) (r).iegr_port[0]=(((r).iegr_port[0] & ~((uint32_t)0xf << 9)) | ((((uint32_t)f) & 0xf) << 9))

/*
 * These macros can be used to access IEGR_PORT.
 *
 */
#define BCM56218_A0_READ_IEGR_PORTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_IEGR_PORTr,(r._iegr_port))
#define BCM56218_A0_WRITE_IEGR_PORTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_IEGR_PORTr,&(r._iegr_port))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IEGR_PORTr BCM56218_A0_IEGR_PORTr
#define IEGR_PORTr_SIZE BCM56218_A0_IEGR_PORTr_SIZE
typedef BCM56218_A0_IEGR_PORTr_t IEGR_PORTr_t;
#define IEGR_PORTr_CLR BCM56218_A0_IEGR_PORTr_CLR
#define IEGR_PORTr_SET BCM56218_A0_IEGR_PORTr_SET
#define IEGR_PORTr_GET BCM56218_A0_IEGR_PORTr_GET
#define IEGR_PORTr_PORT_TYPEf_GET BCM56218_A0_IEGR_PORTr_PORT_TYPEf_GET
#define IEGR_PORTr_PORT_TYPEf_SET BCM56218_A0_IEGR_PORTr_PORT_TYPEf_SET
#define IEGR_PORTr_HIGIG_PACKETf_GET BCM56218_A0_IEGR_PORTr_HIGIG_PACKETf_GET
#define IEGR_PORTr_HIGIG_PACKETf_SET BCM56218_A0_IEGR_PORTr_HIGIG_PACKETf_SET
#define IEGR_PORTr_NNI_PORTf_GET BCM56218_A0_IEGR_PORTr_NNI_PORTf_GET
#define IEGR_PORTr_NNI_PORTf_SET BCM56218_A0_IEGR_PORTr_NNI_PORTf_SET
#define IEGR_PORTr_EN_EFILTERf_GET BCM56218_A0_IEGR_PORTr_EN_EFILTERf_GET
#define IEGR_PORTr_EN_EFILTERf_SET BCM56218_A0_IEGR_PORTr_EN_EFILTERf_SET
#define IEGR_PORTr_PRESERVE_CPU_TAGf_GET BCM56218_A0_IEGR_PORTr_PRESERVE_CPU_TAGf_GET
#define IEGR_PORTr_PRESERVE_CPU_TAGf_SET BCM56218_A0_IEGR_PORTr_PRESERVE_CPU_TAGf_SET
#define IEGR_PORTr_CFIf_GET BCM56218_A0_IEGR_PORTr_CFIf_GET
#define IEGR_PORTr_CFIf_SET BCM56218_A0_IEGR_PORTr_CFIf_SET
#define IEGR_PORTr_EM_SRCMOD_CHANGEf_GET BCM56218_A0_IEGR_PORTr_EM_SRCMOD_CHANGEf_GET
#define IEGR_PORTr_EM_SRCMOD_CHANGEf_SET BCM56218_A0_IEGR_PORTr_EM_SRCMOD_CHANGEf_SET
#define IEGR_PORTr_MY_MODIDf_GET BCM56218_A0_IEGR_PORTr_MY_MODIDf_GET
#define IEGR_PORTr_MY_MODIDf_SET BCM56218_A0_IEGR_PORTr_MY_MODIDf_SET
#define READ_IEGR_PORTr BCM56218_A0_READ_IEGR_PORTr
#define WRITE_IEGR_PORTr BCM56218_A0_WRITE_IEGR_PORTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_IEGR_PORTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  IEGR_PORT_L3UC_MODS
 * BLOCKS:   EPIPE_HI
 * DESC:     Configuration Register for IPMC related modifications.


 * SIZE:     32
 * FIELDS:
 *     L3_UC_SA_DISABLE Disable the SA replacement for L3UC packets coming from a particular port. This register is indexed in EP based on the src_port_num.
 *     L3_UC_DA_DISABLE Disable the DA replacement for L3UC packets coming from a particular port. This register is indexed in EP based on the src_port_num.
 *     L3_UC_TTL_DISABLE Disable the TTL decrement for L3UC packets coming from a particular port. This register is indexed in EP based on the src_port_num.
 *     L3_UC_VLAN_DISABLE Disable the outer VID replacement for L3UC packets coming from a particular port. This register is indexed in EP based on the src_port_num.
 *
 ******************************************************************************/
#define BCM56218_A0_IEGR_PORT_L3UC_MODSr 0x01a00004

#define BCM56218_A0_IEGR_PORT_L3UC_MODSr_SIZE 4

/*
 * This structure should be used to declare and program IEGR_PORT_L3UC_MODS.
 *
 */
typedef union BCM56218_A0_IEGR_PORT_L3UC_MODSr_s {
	uint32_t v[1];
	uint32_t iegr_port_l3uc_mods[1];
	uint32_t _iegr_port_l3uc_mods;
} BCM56218_A0_IEGR_PORT_L3UC_MODSr_t;

#define BCM56218_A0_IEGR_PORT_L3UC_MODSr_CLR(r) (r).iegr_port_l3uc_mods[0] = 0
#define BCM56218_A0_IEGR_PORT_L3UC_MODSr_SET(r,d) (r).iegr_port_l3uc_mods[0] = d
#define BCM56218_A0_IEGR_PORT_L3UC_MODSr_GET(r) (r).iegr_port_l3uc_mods[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_IEGR_PORT_L3UC_MODSr_L3_UC_SA_DISABLEf_GET(r) (((r).iegr_port_l3uc_mods[0]) & 0x1)
#define BCM56218_A0_IEGR_PORT_L3UC_MODSr_L3_UC_SA_DISABLEf_SET(r,f) (r).iegr_port_l3uc_mods[0]=(((r).iegr_port_l3uc_mods[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_IEGR_PORT_L3UC_MODSr_L3_UC_DA_DISABLEf_GET(r) ((((r).iegr_port_l3uc_mods[0]) >> 1) & 0x1)
#define BCM56218_A0_IEGR_PORT_L3UC_MODSr_L3_UC_DA_DISABLEf_SET(r,f) (r).iegr_port_l3uc_mods[0]=(((r).iegr_port_l3uc_mods[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_IEGR_PORT_L3UC_MODSr_L3_UC_TTL_DISABLEf_GET(r) ((((r).iegr_port_l3uc_mods[0]) >> 2) & 0x1)
#define BCM56218_A0_IEGR_PORT_L3UC_MODSr_L3_UC_TTL_DISABLEf_SET(r,f) (r).iegr_port_l3uc_mods[0]=(((r).iegr_port_l3uc_mods[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_IEGR_PORT_L3UC_MODSr_L3_UC_VLAN_DISABLEf_GET(r) ((((r).iegr_port_l3uc_mods[0]) >> 3) & 0x1)
#define BCM56218_A0_IEGR_PORT_L3UC_MODSr_L3_UC_VLAN_DISABLEf_SET(r,f) (r).iegr_port_l3uc_mods[0]=(((r).iegr_port_l3uc_mods[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))

/*
 * These macros can be used to access IEGR_PORT_L3UC_MODS.
 *
 */
#define BCM56218_A0_READ_IEGR_PORT_L3UC_MODSr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_IEGR_PORT_L3UC_MODSr,(r._iegr_port_l3uc_mods))
#define BCM56218_A0_WRITE_IEGR_PORT_L3UC_MODSr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_IEGR_PORT_L3UC_MODSr,&(r._iegr_port_l3uc_mods))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IEGR_PORT_L3UC_MODSr BCM56218_A0_IEGR_PORT_L3UC_MODSr
#define IEGR_PORT_L3UC_MODSr_SIZE BCM56218_A0_IEGR_PORT_L3UC_MODSr_SIZE
typedef BCM56218_A0_IEGR_PORT_L3UC_MODSr_t IEGR_PORT_L3UC_MODSr_t;
#define IEGR_PORT_L3UC_MODSr_CLR BCM56218_A0_IEGR_PORT_L3UC_MODSr_CLR
#define IEGR_PORT_L3UC_MODSr_SET BCM56218_A0_IEGR_PORT_L3UC_MODSr_SET
#define IEGR_PORT_L3UC_MODSr_GET BCM56218_A0_IEGR_PORT_L3UC_MODSr_GET
#define IEGR_PORT_L3UC_MODSr_L3_UC_SA_DISABLEf_GET BCM56218_A0_IEGR_PORT_L3UC_MODSr_L3_UC_SA_DISABLEf_GET
#define IEGR_PORT_L3UC_MODSr_L3_UC_SA_DISABLEf_SET BCM56218_A0_IEGR_PORT_L3UC_MODSr_L3_UC_SA_DISABLEf_SET
#define IEGR_PORT_L3UC_MODSr_L3_UC_DA_DISABLEf_GET BCM56218_A0_IEGR_PORT_L3UC_MODSr_L3_UC_DA_DISABLEf_GET
#define IEGR_PORT_L3UC_MODSr_L3_UC_DA_DISABLEf_SET BCM56218_A0_IEGR_PORT_L3UC_MODSr_L3_UC_DA_DISABLEf_SET
#define IEGR_PORT_L3UC_MODSr_L3_UC_TTL_DISABLEf_GET BCM56218_A0_IEGR_PORT_L3UC_MODSr_L3_UC_TTL_DISABLEf_GET
#define IEGR_PORT_L3UC_MODSr_L3_UC_TTL_DISABLEf_SET BCM56218_A0_IEGR_PORT_L3UC_MODSr_L3_UC_TTL_DISABLEf_SET
#define IEGR_PORT_L3UC_MODSr_L3_UC_VLAN_DISABLEf_GET BCM56218_A0_IEGR_PORT_L3UC_MODSr_L3_UC_VLAN_DISABLEf_GET
#define IEGR_PORT_L3UC_MODSr_L3_UC_VLAN_DISABLEf_SET BCM56218_A0_IEGR_PORT_L3UC_MODSr_L3_UC_VLAN_DISABLEf_SET
#define READ_IEGR_PORT_L3UC_MODSr BCM56218_A0_READ_IEGR_PORT_L3UC_MODSr
#define WRITE_IEGR_PORT_L3UC_MODSr BCM56218_A0_WRITE_IEGR_PORT_L3UC_MODSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_IEGR_PORT_L3UC_MODSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  IEMIRROR_CONTROL
 * BLOCKS:   IPIPE_HI
 * DESC:     Egress mirror bitmap register - Lower Bitmap
 * SIZE:     32
 * FIELDS:
 *     BITMAP           Egress mirror bitmap
 *
 ******************************************************************************/
#define BCM56218_A0_IEMIRROR_CONTROLr 0x0e800109

#define BCM56218_A0_IEMIRROR_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program IEMIRROR_CONTROL.
 *
 */
typedef union BCM56218_A0_IEMIRROR_CONTROLr_s {
	uint32_t v[1];
	uint32_t iemirror_control[1];
	uint32_t _iemirror_control;
} BCM56218_A0_IEMIRROR_CONTROLr_t;

#define BCM56218_A0_IEMIRROR_CONTROLr_CLR(r) (r).iemirror_control[0] = 0
#define BCM56218_A0_IEMIRROR_CONTROLr_SET(r,d) (r).iemirror_control[0] = d
#define BCM56218_A0_IEMIRROR_CONTROLr_GET(r) (r).iemirror_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_IEMIRROR_CONTROLr_BITMAPf_GET(r) ((r).iemirror_control[0])
#define BCM56218_A0_IEMIRROR_CONTROLr_BITMAPf_SET(r,f) (r).iemirror_control[0]=((uint32_t)f)

/*
 * These macros can be used to access IEMIRROR_CONTROL.
 *
 */
#define BCM56218_A0_READ_IEMIRROR_CONTROLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_IEMIRROR_CONTROLr,(r._iemirror_control))
#define BCM56218_A0_WRITE_IEMIRROR_CONTROLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_IEMIRROR_CONTROLr,&(r._iemirror_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IEMIRROR_CONTROLr BCM56218_A0_IEMIRROR_CONTROLr
#define IEMIRROR_CONTROLr_SIZE BCM56218_A0_IEMIRROR_CONTROLr_SIZE
typedef BCM56218_A0_IEMIRROR_CONTROLr_t IEMIRROR_CONTROLr_t;
#define IEMIRROR_CONTROLr_CLR BCM56218_A0_IEMIRROR_CONTROLr_CLR
#define IEMIRROR_CONTROLr_SET BCM56218_A0_IEMIRROR_CONTROLr_SET
#define IEMIRROR_CONTROLr_GET BCM56218_A0_IEMIRROR_CONTROLr_GET
#define IEMIRROR_CONTROLr_BITMAPf_GET BCM56218_A0_IEMIRROR_CONTROLr_BITMAPf_GET
#define IEMIRROR_CONTROLr_BITMAPf_SET BCM56218_A0_IEMIRROR_CONTROLr_BITMAPf_SET
#define READ_IEMIRROR_CONTROLr BCM56218_A0_READ_IEMIRROR_CONTROLr
#define WRITE_IEMIRROR_CONTROLr BCM56218_A0_WRITE_IEMIRROR_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_IEMIRROR_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  IEMIRROR_CONTROL_HI
 * BLOCKS:   IPIPE_HI
 * DESC:     Egress mirror bitmap register - Upper Bitmap
 * SIZE:     32
 * FIELDS:
 *     BITMAP           Egress mirror bitmap
 *
 ******************************************************************************/
#define BCM56218_A0_IEMIRROR_CONTROL_HIr 0x0e80010a

#define BCM56218_A0_IEMIRROR_CONTROL_HIr_SIZE 4

/*
 * This structure should be used to declare and program IEMIRROR_CONTROL_HI.
 *
 */
typedef union BCM56218_A0_IEMIRROR_CONTROL_HIr_s {
	uint32_t v[1];
	uint32_t iemirror_control_hi[1];
	uint32_t _iemirror_control_hi;
} BCM56218_A0_IEMIRROR_CONTROL_HIr_t;

#define BCM56218_A0_IEMIRROR_CONTROL_HIr_CLR(r) (r).iemirror_control_hi[0] = 0
#define BCM56218_A0_IEMIRROR_CONTROL_HIr_SET(r,d) (r).iemirror_control_hi[0] = d
#define BCM56218_A0_IEMIRROR_CONTROL_HIr_GET(r) (r).iemirror_control_hi[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_IEMIRROR_CONTROL_HIr_BITMAPf_GET(r) (((r).iemirror_control_hi[0]) & 0x3fffff)
#define BCM56218_A0_IEMIRROR_CONTROL_HIr_BITMAPf_SET(r,f) (r).iemirror_control_hi[0]=(((r).iemirror_control_hi[0] & ~((uint32_t)0x3fffff)) | (((uint32_t)f) & 0x3fffff))

/*
 * These macros can be used to access IEMIRROR_CONTROL_HI.
 *
 */
#define BCM56218_A0_READ_IEMIRROR_CONTROL_HIr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_IEMIRROR_CONTROL_HIr,(r._iemirror_control_hi))
#define BCM56218_A0_WRITE_IEMIRROR_CONTROL_HIr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_IEMIRROR_CONTROL_HIr,&(r._iemirror_control_hi))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IEMIRROR_CONTROL_HIr BCM56218_A0_IEMIRROR_CONTROL_HIr
#define IEMIRROR_CONTROL_HIr_SIZE BCM56218_A0_IEMIRROR_CONTROL_HIr_SIZE
typedef BCM56218_A0_IEMIRROR_CONTROL_HIr_t IEMIRROR_CONTROL_HIr_t;
#define IEMIRROR_CONTROL_HIr_CLR BCM56218_A0_IEMIRROR_CONTROL_HIr_CLR
#define IEMIRROR_CONTROL_HIr_SET BCM56218_A0_IEMIRROR_CONTROL_HIr_SET
#define IEMIRROR_CONTROL_HIr_GET BCM56218_A0_IEMIRROR_CONTROL_HIr_GET
#define IEMIRROR_CONTROL_HIr_BITMAPf_GET BCM56218_A0_IEMIRROR_CONTROL_HIr_BITMAPf_GET
#define IEMIRROR_CONTROL_HIr_BITMAPf_SET BCM56218_A0_IEMIRROR_CONTROL_HIr_BITMAPf_SET
#define READ_IEMIRROR_CONTROL_HIr BCM56218_A0_READ_IEMIRROR_CONTROL_HIr
#define WRITE_IEMIRROR_CONTROL_HIr BCM56218_A0_WRITE_IEMIRROR_CONTROL_HIr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_IEMIRROR_CONTROL_HIr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  IGMP_MLD_PKT_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     Higig control packet's switching bitmap register
 * SIZE:     32
 * FIELDS:
 *     IPV6_MC_ROUTER_ADV_PKT_TO_CPU Copy Multicast Router Advertisement/Solicitation/Termination packets (ICMP types 151, 152, 153) to CPU if set to 1.
 *     IPV6_MC_ROUTER_ADV_PKT_FWD_ACTION Forwarding of Multicast Router Advertisement/Solicitation/Termination  packets (ICMP types 151, 152, 153) 00 - Forward based on MAC-DA, 01 - Drop the packet, 10 - Flood the packet to the VLAN members, 11 - Reserved.
 *     IPV4_MC_ROUTER_ADV_PKT_TO_CPU Copy Multicast Router Advertisement/Solicitation/Termination packets (ICMP types 151, 152, 153) to CPU if set to 1
 *     IPV4_MC_ROUTER_ADV_PKT_FWD_ACTION Forwarding of Multicast Router Advertisement/Solicitation/Termination  packets (ICMP types 151, 152, 153): 00 - Forward based on MAC-DA, 01 - Drop the packet., 10 - Flood the packet to the VLAN members, 11 - Reserved.
 *     IPV6_RESVD_MC_PKT_TO_CPU Copy IPv6 reserved multicast packets (DIP = ff0X:0:0:0:0:0:0:0) to CPU if set to 1
 *     IPV6_RESVD_MC_PKT_FWD_ACTION Forwarding of IPv6 reserved multicast packets (DIP = ff0X:0:0:0:0:0:0:0) as shown below:,00 - Forward based on MAC-DA, 01 - Drop the packet, 10 - Flood the packet to the VLAN members,11 - Reserved.
 *     IPV4_RESVD_MC_PKT_TO_CPU Copy IPv4 reserved multicast packets (DIP = 224.0.0.X) to CPU if set to 1.
 *     IPV4_RESVD_MC_PKT_FWD_ACTION Forwarding of IPv4 reserved multicast packets (DIP = 224.0.0.X) as shown below:00 - Forward based on MAC-DA, 01 - Drop the packet.,10 - Flood the packet to the VLAN members,11 - Reserved.
 *     MLD_QUERY_TO_CPU Copy MLD Queries to the CPU if set to 1.
 *     MLD_QUERY_FWD_ACTION Forwarding of MLD Query messages as shown below:00 - Forward based on MAC-DA,01 - Drop the packet.,10 - Flood the packet to the VLAN members,11 - Reserved.
 *     MLD_REP_DONE_TO_CPU Copy MLD Report (v1, v2,)/Done (v1) msgs to the CPU if set to 1.
 *     MLD_REP_DONE_FWD_ACTION Forwarding of MLD Report(v1,v2,)/Done(v1) messages as shown below: 00 - Forward based on MAC-DA,01 - Drop the packet.,10 - Flood the packet to the VLAN members,11 - Reserved.
 *     IGMP_UNKNOWN_MSG_TO_CPU Copy the unknown IGMP msg to CPU if set to 1.
 *     IGMP_UNKNOWN_MSG_FWD_ACTION Forwarding of unknown IGMP messages  (messages that are not recognized as Query/Report/Leave messages) as shown below:00 - Forward based on MAC-DA,01 - Drop the packet.,10 - Flood the packet to the VLAN members,11 - Reserved.
 *     IGMP_QUERY_TO_CPU Copy IGMP Query to the CPU if set to 1
 *     IGMP_QUERY_FWD_ACTION Forwarding of IGMP Query messages as shown below: ,00 - Forward based on MAC-DA,01 - Drop the packet.,10 - Flood the packet to the VLAN members,11 - Reserved.
 *     IGMP_REP_LEAVE_TO_CPU Copy IGMP Report (v1, v2, v3)/Leave (v2) msgs to the CPU if set to 1.
 *     IGMP_REP_LEAVE_FWD_ACTION Forwarding of IGMP Report(v1,v2,v3)/Leave(v2) messages as shown below: ,00 - Forward based on MAC-DA,01 - Drop the packet.,10 - Flood the packet to the VLAN members,11 - Reserved.
 *     PFM_RULE_APPLY   If this bit is set,, the current PFM rule in place is applied if not set it disables PFM rule check- when IGMP/MLD/ReservedMC/MC Router Adv packets are flooded to VLAN 
 *
 ******************************************************************************/
#define BCM56218_A0_IGMP_MLD_PKT_CONTROLr 0x0b700009

#define BCM56218_A0_IGMP_MLD_PKT_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program IGMP_MLD_PKT_CONTROL.
 *
 */
typedef union BCM56218_A0_IGMP_MLD_PKT_CONTROLr_s {
	uint32_t v[1];
	uint32_t igmp_mld_pkt_control[1];
	uint32_t _igmp_mld_pkt_control;
} BCM56218_A0_IGMP_MLD_PKT_CONTROLr_t;

#define BCM56218_A0_IGMP_MLD_PKT_CONTROLr_CLR(r) (r).igmp_mld_pkt_control[0] = 0
#define BCM56218_A0_IGMP_MLD_PKT_CONTROLr_SET(r,d) (r).igmp_mld_pkt_control[0] = d
#define BCM56218_A0_IGMP_MLD_PKT_CONTROLr_GET(r) (r).igmp_mld_pkt_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_IGMP_MLD_PKT_CONTROLr_IPV6_MC_ROUTER_ADV_PKT_TO_CPUf_GET(r) (((r).igmp_mld_pkt_control[0]) & 0x1)
#define BCM56218_A0_IGMP_MLD_PKT_CONTROLr_IPV6_MC_ROUTER_ADV_PKT_TO_CPUf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_IGMP_MLD_PKT_CONTROLr_IPV6_MC_ROUTER_ADV_PKT_FWD_ACTIONf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 1) & 0x3)
#define BCM56218_A0_IGMP_MLD_PKT_CONTROLr_IPV6_MC_ROUTER_ADV_PKT_FWD_ACTIONf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32_t)0x3 << 1)) | ((((uint32_t)f) & 0x3) << 1))
#define BCM56218_A0_IGMP_MLD_PKT_CONTROLr_IPV4_MC_ROUTER_ADV_PKT_TO_CPUf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 3) & 0x1)
#define BCM56218_A0_IGMP_MLD_PKT_CONTROLr_IPV4_MC_ROUTER_ADV_PKT_TO_CPUf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56218_A0_IGMP_MLD_PKT_CONTROLr_IPV4_MC_ROUTER_ADV_PKT_FWD_ACTIONf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 4) & 0x3)
#define BCM56218_A0_IGMP_MLD_PKT_CONTROLr_IPV4_MC_ROUTER_ADV_PKT_FWD_ACTIONf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM56218_A0_IGMP_MLD_PKT_CONTROLr_IPV6_RESVD_MC_PKT_TO_CPUf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 6) & 0x1)
#define BCM56218_A0_IGMP_MLD_PKT_CONTROLr_IPV6_RESVD_MC_PKT_TO_CPUf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56218_A0_IGMP_MLD_PKT_CONTROLr_IPV6_RESVD_MC_PKT_FWD_ACTIONf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 7) & 0x3)
#define BCM56218_A0_IGMP_MLD_PKT_CONTROLr_IPV6_RESVD_MC_PKT_FWD_ACTIONf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32_t)0x3 << 7)) | ((((uint32_t)f) & 0x3) << 7))
#define BCM56218_A0_IGMP_MLD_PKT_CONTROLr_IPV4_RESVD_MC_PKT_TO_CPUf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 9) & 0x1)
#define BCM56218_A0_IGMP_MLD_PKT_CONTROLr_IPV4_RESVD_MC_PKT_TO_CPUf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56218_A0_IGMP_MLD_PKT_CONTROLr_IPV4_RESVD_MC_PKT_FWD_ACTIONf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 10) & 0x3)
#define BCM56218_A0_IGMP_MLD_PKT_CONTROLr_IPV4_RESVD_MC_PKT_FWD_ACTIONf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCM56218_A0_IGMP_MLD_PKT_CONTROLr_MLD_QUERY_TO_CPUf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 12) & 0x1)
#define BCM56218_A0_IGMP_MLD_PKT_CONTROLr_MLD_QUERY_TO_CPUf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM56218_A0_IGMP_MLD_PKT_CONTROLr_MLD_QUERY_FWD_ACTIONf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 13) & 0x3)
#define BCM56218_A0_IGMP_MLD_PKT_CONTROLr_MLD_QUERY_FWD_ACTIONf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13))
#define BCM56218_A0_IGMP_MLD_PKT_CONTROLr_MLD_REP_DONE_TO_CPUf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 15) & 0x1)
#define BCM56218_A0_IGMP_MLD_PKT_CONTROLr_MLD_REP_DONE_TO_CPUf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56218_A0_IGMP_MLD_PKT_CONTROLr_MLD_REP_DONE_FWD_ACTIONf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 16) & 0x3)
#define BCM56218_A0_IGMP_MLD_PKT_CONTROLr_MLD_REP_DONE_FWD_ACTIONf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM56218_A0_IGMP_MLD_PKT_CONTROLr_IGMP_UNKNOWN_MSG_TO_CPUf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 18) & 0x1)
#define BCM56218_A0_IGMP_MLD_PKT_CONTROLr_IGMP_UNKNOWN_MSG_TO_CPUf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_IGMP_MLD_PKT_CONTROLr_IGMP_UNKNOWN_MSG_FWD_ACTIONf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 19) & 0x3)
#define BCM56218_A0_IGMP_MLD_PKT_CONTROLr_IGMP_UNKNOWN_MSG_FWD_ACTIONf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32_t)0x3 << 19)) | ((((uint32_t)f) & 0x3) << 19))
#define BCM56218_A0_IGMP_MLD_PKT_CONTROLr_IGMP_QUERY_TO_CPUf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 21) & 0x1)
#define BCM56218_A0_IGMP_MLD_PKT_CONTROLr_IGMP_QUERY_TO_CPUf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM56218_A0_IGMP_MLD_PKT_CONTROLr_IGMP_QUERY_FWD_ACTIONf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 22) & 0x3)
#define BCM56218_A0_IGMP_MLD_PKT_CONTROLr_IGMP_QUERY_FWD_ACTIONf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32_t)0x3 << 22)) | ((((uint32_t)f) & 0x3) << 22))
#define BCM56218_A0_IGMP_MLD_PKT_CONTROLr_IGMP_REP_LEAVE_TO_CPUf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 24) & 0x1)
#define BCM56218_A0_IGMP_MLD_PKT_CONTROLr_IGMP_REP_LEAVE_TO_CPUf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM56218_A0_IGMP_MLD_PKT_CONTROLr_IGMP_REP_LEAVE_FWD_ACTIONf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 25) & 0x3)
#define BCM56218_A0_IGMP_MLD_PKT_CONTROLr_IGMP_REP_LEAVE_FWD_ACTIONf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32_t)0x3 << 25)) | ((((uint32_t)f) & 0x3) << 25))
#define BCM56218_A0_IGMP_MLD_PKT_CONTROLr_PFM_RULE_APPLYf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 27) & 0x1)
#define BCM56218_A0_IGMP_MLD_PKT_CONTROLr_PFM_RULE_APPLYf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))

/*
 * These macros can be used to access IGMP_MLD_PKT_CONTROL.
 *
 */
#define BCM56218_A0_READ_IGMP_MLD_PKT_CONTROLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_IGMP_MLD_PKT_CONTROLr,(r._igmp_mld_pkt_control))
#define BCM56218_A0_WRITE_IGMP_MLD_PKT_CONTROLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_IGMP_MLD_PKT_CONTROLr,&(r._igmp_mld_pkt_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IGMP_MLD_PKT_CONTROLr BCM56218_A0_IGMP_MLD_PKT_CONTROLr
#define IGMP_MLD_PKT_CONTROLr_SIZE BCM56218_A0_IGMP_MLD_PKT_CONTROLr_SIZE
typedef BCM56218_A0_IGMP_MLD_PKT_CONTROLr_t IGMP_MLD_PKT_CONTROLr_t;
#define IGMP_MLD_PKT_CONTROLr_CLR BCM56218_A0_IGMP_MLD_PKT_CONTROLr_CLR
#define IGMP_MLD_PKT_CONTROLr_SET BCM56218_A0_IGMP_MLD_PKT_CONTROLr_SET
#define IGMP_MLD_PKT_CONTROLr_GET BCM56218_A0_IGMP_MLD_PKT_CONTROLr_GET
#define IGMP_MLD_PKT_CONTROLr_IPV6_MC_ROUTER_ADV_PKT_TO_CPUf_GET BCM56218_A0_IGMP_MLD_PKT_CONTROLr_IPV6_MC_ROUTER_ADV_PKT_TO_CPUf_GET
#define IGMP_MLD_PKT_CONTROLr_IPV6_MC_ROUTER_ADV_PKT_TO_CPUf_SET BCM56218_A0_IGMP_MLD_PKT_CONTROLr_IPV6_MC_ROUTER_ADV_PKT_TO_CPUf_SET
#define IGMP_MLD_PKT_CONTROLr_IPV6_MC_ROUTER_ADV_PKT_FWD_ACTIONf_GET BCM56218_A0_IGMP_MLD_PKT_CONTROLr_IPV6_MC_ROUTER_ADV_PKT_FWD_ACTIONf_GET
#define IGMP_MLD_PKT_CONTROLr_IPV6_MC_ROUTER_ADV_PKT_FWD_ACTIONf_SET BCM56218_A0_IGMP_MLD_PKT_CONTROLr_IPV6_MC_ROUTER_ADV_PKT_FWD_ACTIONf_SET
#define IGMP_MLD_PKT_CONTROLr_IPV4_MC_ROUTER_ADV_PKT_TO_CPUf_GET BCM56218_A0_IGMP_MLD_PKT_CONTROLr_IPV4_MC_ROUTER_ADV_PKT_TO_CPUf_GET
#define IGMP_MLD_PKT_CONTROLr_IPV4_MC_ROUTER_ADV_PKT_TO_CPUf_SET BCM56218_A0_IGMP_MLD_PKT_CONTROLr_IPV4_MC_ROUTER_ADV_PKT_TO_CPUf_SET
#define IGMP_MLD_PKT_CONTROLr_IPV4_MC_ROUTER_ADV_PKT_FWD_ACTIONf_GET BCM56218_A0_IGMP_MLD_PKT_CONTROLr_IPV4_MC_ROUTER_ADV_PKT_FWD_ACTIONf_GET
#define IGMP_MLD_PKT_CONTROLr_IPV4_MC_ROUTER_ADV_PKT_FWD_ACTIONf_SET BCM56218_A0_IGMP_MLD_PKT_CONTROLr_IPV4_MC_ROUTER_ADV_PKT_FWD_ACTIONf_SET
#define IGMP_MLD_PKT_CONTROLr_IPV6_RESVD_MC_PKT_TO_CPUf_GET BCM56218_A0_IGMP_MLD_PKT_CONTROLr_IPV6_RESVD_MC_PKT_TO_CPUf_GET
#define IGMP_MLD_PKT_CONTROLr_IPV6_RESVD_MC_PKT_TO_CPUf_SET BCM56218_A0_IGMP_MLD_PKT_CONTROLr_IPV6_RESVD_MC_PKT_TO_CPUf_SET
#define IGMP_MLD_PKT_CONTROLr_IPV6_RESVD_MC_PKT_FWD_ACTIONf_GET BCM56218_A0_IGMP_MLD_PKT_CONTROLr_IPV6_RESVD_MC_PKT_FWD_ACTIONf_GET
#define IGMP_MLD_PKT_CONTROLr_IPV6_RESVD_MC_PKT_FWD_ACTIONf_SET BCM56218_A0_IGMP_MLD_PKT_CONTROLr_IPV6_RESVD_MC_PKT_FWD_ACTIONf_SET
#define IGMP_MLD_PKT_CONTROLr_IPV4_RESVD_MC_PKT_TO_CPUf_GET BCM56218_A0_IGMP_MLD_PKT_CONTROLr_IPV4_RESVD_MC_PKT_TO_CPUf_GET
#define IGMP_MLD_PKT_CONTROLr_IPV4_RESVD_MC_PKT_TO_CPUf_SET BCM56218_A0_IGMP_MLD_PKT_CONTROLr_IPV4_RESVD_MC_PKT_TO_CPUf_SET
#define IGMP_MLD_PKT_CONTROLr_IPV4_RESVD_MC_PKT_FWD_ACTIONf_GET BCM56218_A0_IGMP_MLD_PKT_CONTROLr_IPV4_RESVD_MC_PKT_FWD_ACTIONf_GET
#define IGMP_MLD_PKT_CONTROLr_IPV4_RESVD_MC_PKT_FWD_ACTIONf_SET BCM56218_A0_IGMP_MLD_PKT_CONTROLr_IPV4_RESVD_MC_PKT_FWD_ACTIONf_SET
#define IGMP_MLD_PKT_CONTROLr_MLD_QUERY_TO_CPUf_GET BCM56218_A0_IGMP_MLD_PKT_CONTROLr_MLD_QUERY_TO_CPUf_GET
#define IGMP_MLD_PKT_CONTROLr_MLD_QUERY_TO_CPUf_SET BCM56218_A0_IGMP_MLD_PKT_CONTROLr_MLD_QUERY_TO_CPUf_SET
#define IGMP_MLD_PKT_CONTROLr_MLD_QUERY_FWD_ACTIONf_GET BCM56218_A0_IGMP_MLD_PKT_CONTROLr_MLD_QUERY_FWD_ACTIONf_GET
#define IGMP_MLD_PKT_CONTROLr_MLD_QUERY_FWD_ACTIONf_SET BCM56218_A0_IGMP_MLD_PKT_CONTROLr_MLD_QUERY_FWD_ACTIONf_SET
#define IGMP_MLD_PKT_CONTROLr_MLD_REP_DONE_TO_CPUf_GET BCM56218_A0_IGMP_MLD_PKT_CONTROLr_MLD_REP_DONE_TO_CPUf_GET
#define IGMP_MLD_PKT_CONTROLr_MLD_REP_DONE_TO_CPUf_SET BCM56218_A0_IGMP_MLD_PKT_CONTROLr_MLD_REP_DONE_TO_CPUf_SET
#define IGMP_MLD_PKT_CONTROLr_MLD_REP_DONE_FWD_ACTIONf_GET BCM56218_A0_IGMP_MLD_PKT_CONTROLr_MLD_REP_DONE_FWD_ACTIONf_GET
#define IGMP_MLD_PKT_CONTROLr_MLD_REP_DONE_FWD_ACTIONf_SET BCM56218_A0_IGMP_MLD_PKT_CONTROLr_MLD_REP_DONE_FWD_ACTIONf_SET
#define IGMP_MLD_PKT_CONTROLr_IGMP_UNKNOWN_MSG_TO_CPUf_GET BCM56218_A0_IGMP_MLD_PKT_CONTROLr_IGMP_UNKNOWN_MSG_TO_CPUf_GET
#define IGMP_MLD_PKT_CONTROLr_IGMP_UNKNOWN_MSG_TO_CPUf_SET BCM56218_A0_IGMP_MLD_PKT_CONTROLr_IGMP_UNKNOWN_MSG_TO_CPUf_SET
#define IGMP_MLD_PKT_CONTROLr_IGMP_UNKNOWN_MSG_FWD_ACTIONf_GET BCM56218_A0_IGMP_MLD_PKT_CONTROLr_IGMP_UNKNOWN_MSG_FWD_ACTIONf_GET
#define IGMP_MLD_PKT_CONTROLr_IGMP_UNKNOWN_MSG_FWD_ACTIONf_SET BCM56218_A0_IGMP_MLD_PKT_CONTROLr_IGMP_UNKNOWN_MSG_FWD_ACTIONf_SET
#define IGMP_MLD_PKT_CONTROLr_IGMP_QUERY_TO_CPUf_GET BCM56218_A0_IGMP_MLD_PKT_CONTROLr_IGMP_QUERY_TO_CPUf_GET
#define IGMP_MLD_PKT_CONTROLr_IGMP_QUERY_TO_CPUf_SET BCM56218_A0_IGMP_MLD_PKT_CONTROLr_IGMP_QUERY_TO_CPUf_SET
#define IGMP_MLD_PKT_CONTROLr_IGMP_QUERY_FWD_ACTIONf_GET BCM56218_A0_IGMP_MLD_PKT_CONTROLr_IGMP_QUERY_FWD_ACTIONf_GET
#define IGMP_MLD_PKT_CONTROLr_IGMP_QUERY_FWD_ACTIONf_SET BCM56218_A0_IGMP_MLD_PKT_CONTROLr_IGMP_QUERY_FWD_ACTIONf_SET
#define IGMP_MLD_PKT_CONTROLr_IGMP_REP_LEAVE_TO_CPUf_GET BCM56218_A0_IGMP_MLD_PKT_CONTROLr_IGMP_REP_LEAVE_TO_CPUf_GET
#define IGMP_MLD_PKT_CONTROLr_IGMP_REP_LEAVE_TO_CPUf_SET BCM56218_A0_IGMP_MLD_PKT_CONTROLr_IGMP_REP_LEAVE_TO_CPUf_SET
#define IGMP_MLD_PKT_CONTROLr_IGMP_REP_LEAVE_FWD_ACTIONf_GET BCM56218_A0_IGMP_MLD_PKT_CONTROLr_IGMP_REP_LEAVE_FWD_ACTIONf_GET
#define IGMP_MLD_PKT_CONTROLr_IGMP_REP_LEAVE_FWD_ACTIONf_SET BCM56218_A0_IGMP_MLD_PKT_CONTROLr_IGMP_REP_LEAVE_FWD_ACTIONf_SET
#define IGMP_MLD_PKT_CONTROLr_PFM_RULE_APPLYf_GET BCM56218_A0_IGMP_MLD_PKT_CONTROLr_PFM_RULE_APPLYf_GET
#define IGMP_MLD_PKT_CONTROLr_PFM_RULE_APPLYf_SET BCM56218_A0_IGMP_MLD_PKT_CONTROLr_PFM_RULE_APPLYf_SET
#define READ_IGMP_MLD_PKT_CONTROLr BCM56218_A0_READ_IGMP_MLD_PKT_CONTROLr
#define WRITE_IGMP_MLD_PKT_CONTROLr BCM56218_A0_WRITE_IGMP_MLD_PKT_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_IGMP_MLD_PKT_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  IHIGIG_CONTROL
 * BLOCKS:   IPIPE_HI
 * DESC:     Enable to pick the Port bitmap, in case a pkt with unknown opcode is received. 
 * SIZE:     32
 * FIELDS:
 *     UNKNOWN_OPCODE_ENABLE enable.
 *
 ******************************************************************************/
#define BCM56218_A0_IHIGIG_CONTROLr 0x0180000b

#define BCM56218_A0_IHIGIG_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program IHIGIG_CONTROL.
 *
 */
typedef union BCM56218_A0_IHIGIG_CONTROLr_s {
	uint32_t v[1];
	uint32_t ihigig_control[1];
	uint32_t _ihigig_control;
} BCM56218_A0_IHIGIG_CONTROLr_t;

#define BCM56218_A0_IHIGIG_CONTROLr_CLR(r) (r).ihigig_control[0] = 0
#define BCM56218_A0_IHIGIG_CONTROLr_SET(r,d) (r).ihigig_control[0] = d
#define BCM56218_A0_IHIGIG_CONTROLr_GET(r) (r).ihigig_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_IHIGIG_CONTROLr_UNKNOWN_OPCODE_ENABLEf_GET(r) (((r).ihigig_control[0]) & 0x1)
#define BCM56218_A0_IHIGIG_CONTROLr_UNKNOWN_OPCODE_ENABLEf_SET(r,f) (r).ihigig_control[0]=(((r).ihigig_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access IHIGIG_CONTROL.
 *
 */
#define BCM56218_A0_READ_IHIGIG_CONTROLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_IHIGIG_CONTROLr,(r._ihigig_control))
#define BCM56218_A0_WRITE_IHIGIG_CONTROLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_IHIGIG_CONTROLr,&(r._ihigig_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IHIGIG_CONTROLr BCM56218_A0_IHIGIG_CONTROLr
#define IHIGIG_CONTROLr_SIZE BCM56218_A0_IHIGIG_CONTROLr_SIZE
typedef BCM56218_A0_IHIGIG_CONTROLr_t IHIGIG_CONTROLr_t;
#define IHIGIG_CONTROLr_CLR BCM56218_A0_IHIGIG_CONTROLr_CLR
#define IHIGIG_CONTROLr_SET BCM56218_A0_IHIGIG_CONTROLr_SET
#define IHIGIG_CONTROLr_GET BCM56218_A0_IHIGIG_CONTROLr_GET
#define IHIGIG_CONTROLr_UNKNOWN_OPCODE_ENABLEf_GET BCM56218_A0_IHIGIG_CONTROLr_UNKNOWN_OPCODE_ENABLEf_GET
#define IHIGIG_CONTROLr_UNKNOWN_OPCODE_ENABLEf_SET BCM56218_A0_IHIGIG_CONTROLr_UNKNOWN_OPCODE_ENABLEf_SET
#define READ_IHIGIG_CONTROLr BCM56218_A0_READ_IHIGIG_CONTROLr
#define WRITE_IHIGIG_CONTROLr BCM56218_A0_WRITE_IHIGIG_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_IHIGIG_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  IMIRROR_CONTROL
 * BLOCKS:   IPIPE_HI
 * DESC:     Mirror control register
 * SIZE:     32
 * FIELDS:
 *     M_ENABLE         Enable mirroring
 *     IM_MTP_INDEX     Ingress MTP index
 *     EM_MTP_INDEX     Egress MTP index
 *     NON_UC_EM_MTP_INDEX Non-unicast egress MTP index
 *     SRC_MODID_BLOCK_MIRROR_ONLY_PKT Apply the source modid block masks, programmed in SRC_MODID_BLOCK table, for MTP of HiGig pkts with MH.M=1, MH.MO=1, MH.MD=0 ports
 *     SRC_MODID_BLOCK_MIRROR_COPY Apply the source modid block masks, programmed in SRC_MODID_BLOCK table, for MTP of HiGig pkts with MH.M=1, MH.MO=0, MH.MD=0 ports
 *
 ******************************************************************************/
#define BCM56218_A0_IMIRROR_CONTROLr 0x0e800108

#define BCM56218_A0_IMIRROR_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program IMIRROR_CONTROL.
 *
 */
typedef union BCM56218_A0_IMIRROR_CONTROLr_s {
	uint32_t v[1];
	uint32_t imirror_control[1];
	uint32_t _imirror_control;
} BCM56218_A0_IMIRROR_CONTROLr_t;

#define BCM56218_A0_IMIRROR_CONTROLr_CLR(r) (r).imirror_control[0] = 0
#define BCM56218_A0_IMIRROR_CONTROLr_SET(r,d) (r).imirror_control[0] = d
#define BCM56218_A0_IMIRROR_CONTROLr_GET(r) (r).imirror_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_IMIRROR_CONTROLr_M_ENABLEf_GET(r) (((r).imirror_control[0]) & 0x1)
#define BCM56218_A0_IMIRROR_CONTROLr_M_ENABLEf_SET(r,f) (r).imirror_control[0]=(((r).imirror_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_IMIRROR_CONTROLr_IM_MTP_INDEXf_GET(r) ((((r).imirror_control[0]) >> 1) & 0x3)
#define BCM56218_A0_IMIRROR_CONTROLr_IM_MTP_INDEXf_SET(r,f) (r).imirror_control[0]=(((r).imirror_control[0] & ~((uint32_t)0x3 << 1)) | ((((uint32_t)f) & 0x3) << 1))
#define BCM56218_A0_IMIRROR_CONTROLr_EM_MTP_INDEXf_GET(r) ((((r).imirror_control[0]) >> 3) & 0x3)
#define BCM56218_A0_IMIRROR_CONTROLr_EM_MTP_INDEXf_SET(r,f) (r).imirror_control[0]=(((r).imirror_control[0] & ~((uint32_t)0x3 << 3)) | ((((uint32_t)f) & 0x3) << 3))
#define BCM56218_A0_IMIRROR_CONTROLr_NON_UC_EM_MTP_INDEXf_GET(r) ((((r).imirror_control[0]) >> 5) & 0x3)
#define BCM56218_A0_IMIRROR_CONTROLr_NON_UC_EM_MTP_INDEXf_SET(r,f) (r).imirror_control[0]=(((r).imirror_control[0] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5))
#define BCM56218_A0_IMIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_ONLY_PKTf_GET(r) ((((r).imirror_control[0]) >> 7) & 0x1)
#define BCM56218_A0_IMIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_ONLY_PKTf_SET(r,f) (r).imirror_control[0]=(((r).imirror_control[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56218_A0_IMIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_COPYf_GET(r) ((((r).imirror_control[0]) >> 8) & 0x1)
#define BCM56218_A0_IMIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_COPYf_SET(r,f) (r).imirror_control[0]=(((r).imirror_control[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))

/*
 * These macros can be used to access IMIRROR_CONTROL.
 *
 */
#define BCM56218_A0_READ_IMIRROR_CONTROLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_IMIRROR_CONTROLr,(r._imirror_control))
#define BCM56218_A0_WRITE_IMIRROR_CONTROLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_IMIRROR_CONTROLr,&(r._imirror_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IMIRROR_CONTROLr BCM56218_A0_IMIRROR_CONTROLr
#define IMIRROR_CONTROLr_SIZE BCM56218_A0_IMIRROR_CONTROLr_SIZE
typedef BCM56218_A0_IMIRROR_CONTROLr_t IMIRROR_CONTROLr_t;
#define IMIRROR_CONTROLr_CLR BCM56218_A0_IMIRROR_CONTROLr_CLR
#define IMIRROR_CONTROLr_SET BCM56218_A0_IMIRROR_CONTROLr_SET
#define IMIRROR_CONTROLr_GET BCM56218_A0_IMIRROR_CONTROLr_GET
#define IMIRROR_CONTROLr_M_ENABLEf_GET BCM56218_A0_IMIRROR_CONTROLr_M_ENABLEf_GET
#define IMIRROR_CONTROLr_M_ENABLEf_SET BCM56218_A0_IMIRROR_CONTROLr_M_ENABLEf_SET
#define IMIRROR_CONTROLr_IM_MTP_INDEXf_GET BCM56218_A0_IMIRROR_CONTROLr_IM_MTP_INDEXf_GET
#define IMIRROR_CONTROLr_IM_MTP_INDEXf_SET BCM56218_A0_IMIRROR_CONTROLr_IM_MTP_INDEXf_SET
#define IMIRROR_CONTROLr_EM_MTP_INDEXf_GET BCM56218_A0_IMIRROR_CONTROLr_EM_MTP_INDEXf_GET
#define IMIRROR_CONTROLr_EM_MTP_INDEXf_SET BCM56218_A0_IMIRROR_CONTROLr_EM_MTP_INDEXf_SET
#define IMIRROR_CONTROLr_NON_UC_EM_MTP_INDEXf_GET BCM56218_A0_IMIRROR_CONTROLr_NON_UC_EM_MTP_INDEXf_GET
#define IMIRROR_CONTROLr_NON_UC_EM_MTP_INDEXf_SET BCM56218_A0_IMIRROR_CONTROLr_NON_UC_EM_MTP_INDEXf_SET
#define IMIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_ONLY_PKTf_GET BCM56218_A0_IMIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_ONLY_PKTf_GET
#define IMIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_ONLY_PKTf_SET BCM56218_A0_IMIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_ONLY_PKTf_SET
#define IMIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_COPYf_GET BCM56218_A0_IMIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_COPYf_GET
#define IMIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_COPYf_SET BCM56218_A0_IMIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_COPYf_SET
#define READ_IMIRROR_CONTROLr BCM56218_A0_READ_IMIRROR_CONTROLr
#define WRITE_IMIRROR_CONTROLr BCM56218_A0_WRITE_IMIRROR_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_IMIRROR_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  IMRP4
 * BLOCKS:   IPIPE
 * DESC:     Receive IPv4 L3 routed multicast packets
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_IMRP4r 0x0e700003

#define BCM56218_A0_IMRP4r_SIZE 4

/*
 * This structure should be used to declare and program IMRP4.
 *
 */
typedef union BCM56218_A0_IMRP4r_s {
	uint32_t v[1];
	uint32_t imrp4[1];
	uint32_t _imrp4;
} BCM56218_A0_IMRP4r_t;

#define BCM56218_A0_IMRP4r_CLR(r) (r).imrp4[0] = 0
#define BCM56218_A0_IMRP4r_SET(r,d) (r).imrp4[0] = d
#define BCM56218_A0_IMRP4r_GET(r) (r).imrp4[0]


/*
 * These macros can be used to access IMRP4.
 *
 */
#define BCM56218_A0_READ_IMRP4r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_IMRP4r,(r._imrp4))
#define BCM56218_A0_WRITE_IMRP4r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_IMRP4r,&(r._imrp4))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IMRP4r BCM56218_A0_IMRP4r
#define IMRP4r_SIZE BCM56218_A0_IMRP4r_SIZE
typedef BCM56218_A0_IMRP4r_t IMRP4r_t;
#define IMRP4r_CLR BCM56218_A0_IMRP4r_CLR
#define IMRP4r_SET BCM56218_A0_IMRP4r_SET
#define IMRP4r_GET BCM56218_A0_IMRP4r_GET
#define READ_IMRP4r BCM56218_A0_READ_IMRP4r
#define WRITE_IMRP4r BCM56218_A0_WRITE_IMRP4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_IMRP4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  IMRP6
 * BLOCKS:   IPIPE
 * DESC:     Receive IPv6 L3 routed multicast packets
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_IMRP6r 0x0e700007

#define BCM56218_A0_IMRP6r_SIZE 4

/*
 * This structure should be used to declare and program IMRP6.
 *
 */
typedef union BCM56218_A0_IMRP6r_s {
	uint32_t v[1];
	uint32_t imrp6[1];
	uint32_t _imrp6;
} BCM56218_A0_IMRP6r_t;

#define BCM56218_A0_IMRP6r_CLR(r) (r).imrp6[0] = 0
#define BCM56218_A0_IMRP6r_SET(r,d) (r).imrp6[0] = d
#define BCM56218_A0_IMRP6r_GET(r) (r).imrp6[0]


/*
 * These macros can be used to access IMRP6.
 *
 */
#define BCM56218_A0_READ_IMRP6r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_IMRP6r,(r._imrp6))
#define BCM56218_A0_WRITE_IMRP6r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_IMRP6r,&(r._imrp6))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IMRP6r BCM56218_A0_IMRP6r
#define IMRP6r_SIZE BCM56218_A0_IMRP6r_SIZE
typedef BCM56218_A0_IMRP6r_t IMRP6r_t;
#define IMRP6r_CLR BCM56218_A0_IMRP6r_CLR
#define IMRP6r_SET BCM56218_A0_IMRP6r_SET
#define IMRP6r_GET BCM56218_A0_IMRP6r_GET
#define READ_IMRP6r BCM56218_A0_READ_IMRP6r
#define WRITE_IMRP6r BCM56218_A0_WRITE_IMRP6r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_IMRP6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  IM_MTP_INDEX
 * BLOCKS:   IPIPE
 * DESC:     Ingress Mirror to Port Table
 * SIZE:     11
 * FIELDS:
 *     PORT_TGID        Mirror to port port/TGID
 *     MODULE_ID        Mirror to port module ID
 *
 ******************************************************************************/
#define BCM56218_A0_IM_MTP_INDEXm 0x0e7a0000

#define BCM56218_A0_IM_MTP_INDEXm_MIN 0
#define BCM56218_A0_IM_MTP_INDEXm_MAX 3
#define BCM56218_A0_IM_MTP_INDEXm_CMAX(u) 3
#define BCM56218_A0_IM_MTP_INDEXm_SIZE 2

/*
 * This structure should be used to declare and program IM_MTP_INDEX.
 *
 */
typedef union BCM56218_A0_IM_MTP_INDEXm_s {
	uint32_t v[1];
	uint32_t im_mtp_index[1];
	uint32_t _im_mtp_index;
} BCM56218_A0_IM_MTP_INDEXm_t;

#define BCM56218_A0_IM_MTP_INDEXm_CLR(r) (r).im_mtp_index[0] = 0
#define BCM56218_A0_IM_MTP_INDEXm_SET(r,d) (r).im_mtp_index[0] = d
#define BCM56218_A0_IM_MTP_INDEXm_GET(r) (r).im_mtp_index[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_IM_MTP_INDEXm_PORT_TGIDf_GET(r) (((r).im_mtp_index[0]) & 0x7f)
#define BCM56218_A0_IM_MTP_INDEXm_PORT_TGIDf_SET(r,f) (r).im_mtp_index[0]=(((r).im_mtp_index[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f))
#define BCM56218_A0_IM_MTP_INDEXm_MODULE_IDf_GET(r) ((((r).im_mtp_index[0]) >> 7) & 0xf)
#define BCM56218_A0_IM_MTP_INDEXm_MODULE_IDf_SET(r,f) (r).im_mtp_index[0]=(((r).im_mtp_index[0] & ~((uint32_t)0xf << 7)) | ((((uint32_t)f) & 0xf) << 7))

/*
 * These macros can be used to access IM_MTP_INDEX.
 *
 */
#define BCM56218_A0_READ_IM_MTP_INDEXm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_IM_MTP_INDEXm,i,(m._im_mtp_index),1)
#define BCM56218_A0_WRITE_IM_MTP_INDEXm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_IM_MTP_INDEXm,i,&(m._im_mtp_index),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IM_MTP_INDEXm BCM56218_A0_IM_MTP_INDEXm
#define IM_MTP_INDEXm_MIN BCM56218_A0_IM_MTP_INDEXm_MIN
#define IM_MTP_INDEXm_MAX BCM56218_A0_IM_MTP_INDEXm_MAX
#define IM_MTP_INDEXm_CMAX(u) BCM56218_A0_IM_MTP_INDEXm_CMAX(u)
#define IM_MTP_INDEXm_SIZE BCM56218_A0_IM_MTP_INDEXm_SIZE
typedef BCM56218_A0_IM_MTP_INDEXm_t IM_MTP_INDEXm_t;
#define IM_MTP_INDEXm_CLR BCM56218_A0_IM_MTP_INDEXm_CLR
#define IM_MTP_INDEXm_SET BCM56218_A0_IM_MTP_INDEXm_SET
#define IM_MTP_INDEXm_GET BCM56218_A0_IM_MTP_INDEXm_GET
#define IM_MTP_INDEXm_PORT_TGIDf_GET BCM56218_A0_IM_MTP_INDEXm_PORT_TGIDf_GET
#define IM_MTP_INDEXm_PORT_TGIDf_SET BCM56218_A0_IM_MTP_INDEXm_PORT_TGIDf_SET
#define IM_MTP_INDEXm_MODULE_IDf_GET BCM56218_A0_IM_MTP_INDEXm_MODULE_IDf_GET
#define IM_MTP_INDEXm_MODULE_IDf_SET BCM56218_A0_IM_MTP_INDEXm_MODULE_IDf_SET
#define READ_IM_MTP_INDEXm BCM56218_A0_READ_IM_MTP_INDEXm
#define WRITE_IM_MTP_INDEXm BCM56218_A0_WRITE_IM_MTP_INDEXm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_IM_MTP_INDEXm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  ING_CONFIG
 * BLOCKS:   IPIPE
 * DESC:     Switch configuration register
 * SIZE:     32
 * FIELDS:
 *     DT_MODE          Enables double tagging mode
 *     TRUNKS128        Indicates if 128 trunk groups are supported
 *     L2DH_EN          If set, L2 table will update its HIT bit on dest lookup
 *     L2DST_HIT_ENABLE If set, L2 table will update its HIT bit on dest lookup
 *     L3SH_EN          If set, L3 table will update its HIT bit on src lookup. Only apply to Unicast packets.
 *     L3SRC_HIT_ENABLE If set, L3 table will update its HIT bit on src lookup. Only apply to Unicast packets.
 *     RESERVED1        Reserevd bit
 *     CFI_AS_CNG       For tagged packets, use VLAN's CFI field to map to an internal CNG value (for double tagging)
 *     SNAP_OTHER_DECODE_ENABLE Decode SNAP packets with non-zero OUI for protocol-based VLAN
 *     STNMOVE_ON_L2SRC_DISC Perform station movement on L2 source discard packets
 *     FB_A0_COMPATIBLE FB-A0 compatible mode. Used for disabling source modid checks for mirror pkts on HiGig when in FB style of mirroring.
 *     STACK_MODE       Stacking Mode.
 *     RESERVED0        Reserved bits
 *     CVLAN_CFI_AS_CNG Treat CFI bit in customer vlan tag as CNG
 *     APPLY_EGR_MASK_ON_L2 Apply Egress mask for L2 switched packets
 *     APPLY_EGR_MASK_ON_L3 Apply Egress mask for L3 switched packets
 *     IGNORE_HG_HDR_DONOT_LEARN If set, HiGig hdrs DONOT_LEARN bit will be ignored and will be treated as reserved bit.
 *     DISABLE_COPY_TO_CPU_FOR_CPU_PORT If set, This disables copy to cpu(exceptions) if the packet is from CMIC
 *     IGMP_PKTS_UNICAST_IGNORE Unicast pkts with IGMP Payload(i.e., IP Protoocol = 2) will not be treated as IGMP Pkts
 *     MLD_PKTS_UNICAST_IGNORE Unicast pkts with MLD Payload will not be treated as MLD Pkts
 *     MLD_CHECKS_ENABLE If this bit is set, stricter checks for MLD packets are enabled, that is the packet is checked for TTL=1 and SIP is LINK_LOCAL
 *     IPV6_RESERVED_MC_ADDR_MLD_ENABLE If this bit is set a MLD packet which has a IPV6 reserved multicast address is treated as a MLD packet (not as a IPV6 reserved MC  packet)
 *     IPV4_RESERVED_MC_ADDR_IGMP_ENABLE If this bit is set a IGMP packet which has a IPV4 reserved multicast address is treated as a IGMP packet(not as a IPV4 reserved MC packet)
 *
 ******************************************************************************/
#define BCM56218_A0_ING_CONFIGr 0x01780000

#define BCM56218_A0_ING_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program ING_CONFIG.
 *
 */
typedef union BCM56218_A0_ING_CONFIGr_s {
	uint32_t v[1];
	uint32_t ing_config[1];
	uint32_t _ing_config;
} BCM56218_A0_ING_CONFIGr_t;

#define BCM56218_A0_ING_CONFIGr_CLR(r) (r).ing_config[0] = 0
#define BCM56218_A0_ING_CONFIGr_SET(r,d) (r).ing_config[0] = d
#define BCM56218_A0_ING_CONFIGr_GET(r) (r).ing_config[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_ING_CONFIGr_DT_MODEf_GET(r) (((r).ing_config[0]) & 0x1)
#define BCM56218_A0_ING_CONFIGr_DT_MODEf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_ING_CONFIGr_TRUNKS128f_GET(r) ((((r).ing_config[0]) >> 1) & 0x1)
#define BCM56218_A0_ING_CONFIGr_TRUNKS128f_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_ING_CONFIGr_L2DH_ENf_GET(r) ((((r).ing_config[0]) >> 2) & 0x1)
#define BCM56218_A0_ING_CONFIGr_L2DH_ENf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_ING_CONFIGr_L2DST_HIT_ENABLEf_GET(r) ((((r).ing_config[0]) >> 2) & 0x1)
#define BCM56218_A0_ING_CONFIGr_L2DST_HIT_ENABLEf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_ING_CONFIGr_L3SH_ENf_GET(r) ((((r).ing_config[0]) >> 3) & 0x1)
#define BCM56218_A0_ING_CONFIGr_L3SH_ENf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56218_A0_ING_CONFIGr_L3SRC_HIT_ENABLEf_GET(r) ((((r).ing_config[0]) >> 3) & 0x1)
#define BCM56218_A0_ING_CONFIGr_L3SRC_HIT_ENABLEf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56218_A0_ING_CONFIGr_RESERVED1f_GET(r) ((((r).ing_config[0]) >> 4) & 0x1)
#define BCM56218_A0_ING_CONFIGr_RESERVED1f_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56218_A0_ING_CONFIGr_CFI_AS_CNGf_GET(r) ((((r).ing_config[0]) >> 5) & 0x1)
#define BCM56218_A0_ING_CONFIGr_CFI_AS_CNGf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56218_A0_ING_CONFIGr_SNAP_OTHER_DECODE_ENABLEf_GET(r) ((((r).ing_config[0]) >> 6) & 0x1)
#define BCM56218_A0_ING_CONFIGr_SNAP_OTHER_DECODE_ENABLEf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56218_A0_ING_CONFIGr_STNMOVE_ON_L2SRC_DISCf_GET(r) ((((r).ing_config[0]) >> 7) & 0x1)
#define BCM56218_A0_ING_CONFIGr_STNMOVE_ON_L2SRC_DISCf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56218_A0_ING_CONFIGr_FB_A0_COMPATIBLEf_GET(r) ((((r).ing_config[0]) >> 8) & 0x1)
#define BCM56218_A0_ING_CONFIGr_FB_A0_COMPATIBLEf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56218_A0_ING_CONFIGr_STACK_MODEf_GET(r) ((((r).ing_config[0]) >> 9) & 0x3)
#define BCM56218_A0_ING_CONFIGr_STACK_MODEf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9))
#define BCM56218_A0_ING_CONFIGr_RESERVED0f_GET(r) ((((r).ing_config[0]) >> 11) & 0x3)
#define BCM56218_A0_ING_CONFIGr_RESERVED0f_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x3 << 11)) | ((((uint32_t)f) & 0x3) << 11))
#define BCM56218_A0_ING_CONFIGr_CVLAN_CFI_AS_CNGf_GET(r) ((((r).ing_config[0]) >> 13) & 0x1)
#define BCM56218_A0_ING_CONFIGr_CVLAN_CFI_AS_CNGf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56218_A0_ING_CONFIGr_APPLY_EGR_MASK_ON_L2f_GET(r) ((((r).ing_config[0]) >> 14) & 0x1)
#define BCM56218_A0_ING_CONFIGr_APPLY_EGR_MASK_ON_L2f_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM56218_A0_ING_CONFIGr_APPLY_EGR_MASK_ON_L3f_GET(r) ((((r).ing_config[0]) >> 15) & 0x1)
#define BCM56218_A0_ING_CONFIGr_APPLY_EGR_MASK_ON_L3f_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56218_A0_ING_CONFIGr_IGNORE_HG_HDR_DONOT_LEARNf_GET(r) ((((r).ing_config[0]) >> 16) & 0x1)
#define BCM56218_A0_ING_CONFIGr_IGNORE_HG_HDR_DONOT_LEARNf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56218_A0_ING_CONFIGr_DISABLE_COPY_TO_CPU_FOR_CPU_PORTf_GET(r) ((((r).ing_config[0]) >> 17) & 0x1)
#define BCM56218_A0_ING_CONFIGr_DISABLE_COPY_TO_CPU_FOR_CPU_PORTf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_ING_CONFIGr_IGMP_PKTS_UNICAST_IGNOREf_GET(r) ((((r).ing_config[0]) >> 18) & 0x1)
#define BCM56218_A0_ING_CONFIGr_IGMP_PKTS_UNICAST_IGNOREf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_ING_CONFIGr_MLD_PKTS_UNICAST_IGNOREf_GET(r) ((((r).ing_config[0]) >> 19) & 0x1)
#define BCM56218_A0_ING_CONFIGr_MLD_PKTS_UNICAST_IGNOREf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56218_A0_ING_CONFIGr_MLD_CHECKS_ENABLEf_GET(r) ((((r).ing_config[0]) >> 20) & 0x1)
#define BCM56218_A0_ING_CONFIGr_MLD_CHECKS_ENABLEf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM56218_A0_ING_CONFIGr_IPV6_RESERVED_MC_ADDR_MLD_ENABLEf_GET(r) ((((r).ing_config[0]) >> 21) & 0x1)
#define BCM56218_A0_ING_CONFIGr_IPV6_RESERVED_MC_ADDR_MLD_ENABLEf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM56218_A0_ING_CONFIGr_IPV4_RESERVED_MC_ADDR_IGMP_ENABLEf_GET(r) ((((r).ing_config[0]) >> 22) & 0x1)
#define BCM56218_A0_ING_CONFIGr_IPV4_RESERVED_MC_ADDR_IGMP_ENABLEf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))

/*
 * These macros can be used to access ING_CONFIG.
 *
 */
#define BCM56218_A0_READ_ING_CONFIGr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_ING_CONFIGr,(r._ing_config))
#define BCM56218_A0_WRITE_ING_CONFIGr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_ING_CONFIGr,&(r._ing_config))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ING_CONFIGr BCM56218_A0_ING_CONFIGr
#define ING_CONFIGr_SIZE BCM56218_A0_ING_CONFIGr_SIZE
typedef BCM56218_A0_ING_CONFIGr_t ING_CONFIGr_t;
#define ING_CONFIGr_CLR BCM56218_A0_ING_CONFIGr_CLR
#define ING_CONFIGr_SET BCM56218_A0_ING_CONFIGr_SET
#define ING_CONFIGr_GET BCM56218_A0_ING_CONFIGr_GET
#define ING_CONFIGr_DT_MODEf_GET BCM56218_A0_ING_CONFIGr_DT_MODEf_GET
#define ING_CONFIGr_DT_MODEf_SET BCM56218_A0_ING_CONFIGr_DT_MODEf_SET
#define ING_CONFIGr_TRUNKS128f_GET BCM56218_A0_ING_CONFIGr_TRUNKS128f_GET
#define ING_CONFIGr_TRUNKS128f_SET BCM56218_A0_ING_CONFIGr_TRUNKS128f_SET
#define ING_CONFIGr_L2DH_ENf_GET BCM56218_A0_ING_CONFIGr_L2DH_ENf_GET
#define ING_CONFIGr_L2DH_ENf_SET BCM56218_A0_ING_CONFIGr_L2DH_ENf_SET
#define ING_CONFIGr_L2DST_HIT_ENABLEf_GET BCM56218_A0_ING_CONFIGr_L2DST_HIT_ENABLEf_GET
#define ING_CONFIGr_L2DST_HIT_ENABLEf_SET BCM56218_A0_ING_CONFIGr_L2DST_HIT_ENABLEf_SET
#define ING_CONFIGr_L3SH_ENf_GET BCM56218_A0_ING_CONFIGr_L3SH_ENf_GET
#define ING_CONFIGr_L3SH_ENf_SET BCM56218_A0_ING_CONFIGr_L3SH_ENf_SET
#define ING_CONFIGr_L3SRC_HIT_ENABLEf_GET BCM56218_A0_ING_CONFIGr_L3SRC_HIT_ENABLEf_GET
#define ING_CONFIGr_L3SRC_HIT_ENABLEf_SET BCM56218_A0_ING_CONFIGr_L3SRC_HIT_ENABLEf_SET
#define ING_CONFIGr_RESERVED1f_GET BCM56218_A0_ING_CONFIGr_RESERVED1f_GET
#define ING_CONFIGr_RESERVED1f_SET BCM56218_A0_ING_CONFIGr_RESERVED1f_SET
#define ING_CONFIGr_CFI_AS_CNGf_GET BCM56218_A0_ING_CONFIGr_CFI_AS_CNGf_GET
#define ING_CONFIGr_CFI_AS_CNGf_SET BCM56218_A0_ING_CONFIGr_CFI_AS_CNGf_SET
#define ING_CONFIGr_SNAP_OTHER_DECODE_ENABLEf_GET BCM56218_A0_ING_CONFIGr_SNAP_OTHER_DECODE_ENABLEf_GET
#define ING_CONFIGr_SNAP_OTHER_DECODE_ENABLEf_SET BCM56218_A0_ING_CONFIGr_SNAP_OTHER_DECODE_ENABLEf_SET
#define ING_CONFIGr_STNMOVE_ON_L2SRC_DISCf_GET BCM56218_A0_ING_CONFIGr_STNMOVE_ON_L2SRC_DISCf_GET
#define ING_CONFIGr_STNMOVE_ON_L2SRC_DISCf_SET BCM56218_A0_ING_CONFIGr_STNMOVE_ON_L2SRC_DISCf_SET
#define ING_CONFIGr_FB_A0_COMPATIBLEf_GET BCM56218_A0_ING_CONFIGr_FB_A0_COMPATIBLEf_GET
#define ING_CONFIGr_FB_A0_COMPATIBLEf_SET BCM56218_A0_ING_CONFIGr_FB_A0_COMPATIBLEf_SET
#define ING_CONFIGr_STACK_MODEf_GET BCM56218_A0_ING_CONFIGr_STACK_MODEf_GET
#define ING_CONFIGr_STACK_MODEf_SET BCM56218_A0_ING_CONFIGr_STACK_MODEf_SET
#define ING_CONFIGr_RESERVED0f_GET BCM56218_A0_ING_CONFIGr_RESERVED0f_GET
#define ING_CONFIGr_RESERVED0f_SET BCM56218_A0_ING_CONFIGr_RESERVED0f_SET
#define ING_CONFIGr_CVLAN_CFI_AS_CNGf_GET BCM56218_A0_ING_CONFIGr_CVLAN_CFI_AS_CNGf_GET
#define ING_CONFIGr_CVLAN_CFI_AS_CNGf_SET BCM56218_A0_ING_CONFIGr_CVLAN_CFI_AS_CNGf_SET
#define ING_CONFIGr_APPLY_EGR_MASK_ON_L2f_GET BCM56218_A0_ING_CONFIGr_APPLY_EGR_MASK_ON_L2f_GET
#define ING_CONFIGr_APPLY_EGR_MASK_ON_L2f_SET BCM56218_A0_ING_CONFIGr_APPLY_EGR_MASK_ON_L2f_SET
#define ING_CONFIGr_APPLY_EGR_MASK_ON_L3f_GET BCM56218_A0_ING_CONFIGr_APPLY_EGR_MASK_ON_L3f_GET
#define ING_CONFIGr_APPLY_EGR_MASK_ON_L3f_SET BCM56218_A0_ING_CONFIGr_APPLY_EGR_MASK_ON_L3f_SET
#define ING_CONFIGr_IGNORE_HG_HDR_DONOT_LEARNf_GET BCM56218_A0_ING_CONFIGr_IGNORE_HG_HDR_DONOT_LEARNf_GET
#define ING_CONFIGr_IGNORE_HG_HDR_DONOT_LEARNf_SET BCM56218_A0_ING_CONFIGr_IGNORE_HG_HDR_DONOT_LEARNf_SET
#define ING_CONFIGr_DISABLE_COPY_TO_CPU_FOR_CPU_PORTf_GET BCM56218_A0_ING_CONFIGr_DISABLE_COPY_TO_CPU_FOR_CPU_PORTf_GET
#define ING_CONFIGr_DISABLE_COPY_TO_CPU_FOR_CPU_PORTf_SET BCM56218_A0_ING_CONFIGr_DISABLE_COPY_TO_CPU_FOR_CPU_PORTf_SET
#define ING_CONFIGr_IGMP_PKTS_UNICAST_IGNOREf_GET BCM56218_A0_ING_CONFIGr_IGMP_PKTS_UNICAST_IGNOREf_GET
#define ING_CONFIGr_IGMP_PKTS_UNICAST_IGNOREf_SET BCM56218_A0_ING_CONFIGr_IGMP_PKTS_UNICAST_IGNOREf_SET
#define ING_CONFIGr_MLD_PKTS_UNICAST_IGNOREf_GET BCM56218_A0_ING_CONFIGr_MLD_PKTS_UNICAST_IGNOREf_GET
#define ING_CONFIGr_MLD_PKTS_UNICAST_IGNOREf_SET BCM56218_A0_ING_CONFIGr_MLD_PKTS_UNICAST_IGNOREf_SET
#define ING_CONFIGr_MLD_CHECKS_ENABLEf_GET BCM56218_A0_ING_CONFIGr_MLD_CHECKS_ENABLEf_GET
#define ING_CONFIGr_MLD_CHECKS_ENABLEf_SET BCM56218_A0_ING_CONFIGr_MLD_CHECKS_ENABLEf_SET
#define ING_CONFIGr_IPV6_RESERVED_MC_ADDR_MLD_ENABLEf_GET BCM56218_A0_ING_CONFIGr_IPV6_RESERVED_MC_ADDR_MLD_ENABLEf_GET
#define ING_CONFIGr_IPV6_RESERVED_MC_ADDR_MLD_ENABLEf_SET BCM56218_A0_ING_CONFIGr_IPV6_RESERVED_MC_ADDR_MLD_ENABLEf_SET
#define ING_CONFIGr_IPV4_RESERVED_MC_ADDR_IGMP_ENABLEf_GET BCM56218_A0_ING_CONFIGr_IPV4_RESERVED_MC_ADDR_IGMP_ENABLEf_GET
#define ING_CONFIGr_IPV4_RESERVED_MC_ADDR_IGMP_ENABLEf_SET BCM56218_A0_ING_CONFIGr_IPV4_RESERVED_MC_ADDR_IGMP_ENABLEf_SET
#define READ_ING_CONFIGr BCM56218_A0_READ_ING_CONFIGr
#define WRITE_ING_CONFIGr BCM56218_A0_WRITE_ING_CONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_ING_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  ING_EVENT_DEBUG
 * BLOCKS:   IPIPE
 * DESC:     Ingress Events Debug Register
 * SIZE:     32
 * FIELDS:
 *     VXLT_MISS        Bit 0 - Packets dropped due to VLAN translation miss
 *     BPDU             Bit 1 - BPDU packet drop
 *     PROTOCOL_PKT     Bit 2 - Protocol packet drop
 *     CML              Bit 3 - Packets dropped due to CML
 *     SRC_ROUTE        Bit 4 - Packets dropped due to source route
 *     L2SRC_DISCARD    Bit 5 - Packets dropped due to L2 source discard
 *     L2SRC_STATIC_MOVE Bit 6 - Packets dropped due to L2 source static movement
 *     L2DST_DISCARD    Bit 7 - Packets dropped due to L2 destination discard
 *     CFI_OR_L3DISABLE Bit 8 - Packets dropped due to CFI or L3 disable
 *     HIGIG_MH_TYPE1   Bit 9 - Packets dropped due to HiGig module header type 1
 *     DISC_STAGE       Bit 10 - Packets dropped in discard stage
 *     INVALID_VLAN     Bit 11 - Packets dropped due to invalid VLAN
 *     PDISC            Bit 12 - Receive policy discard counter - DST_DISCARD, SRC_DISCARD, RATE_CONTROL, etc.
 *     RFILDR           Bit 13 - Packets dropped by FP
 *     RIMDR            Bit 14 - Multicast (L2+L3) packets that are dropped
 *     RDROP            Bit 15 - Port bitmap zero drop condition
 *     IMBP             Bit 16 - Bridged multicast packets
 *     RTUN             Bit 17 - Number of tunnel packets received
 *     VLANDR           Bit 18 - Receive VLAN drop cases
 *     DSL3HE           Bit 19 - DOS L3 header error packets
 *     DSL4HE           Bit 20 - DOS L4 header error packets
 *     DSICMP           Bit 21 - DOS ICMP error packets
 *     DSFRAG           Bit 22 - DOS fragment error packets
 *     MTUERR           Reserved - Reserved Bit 23 - Packets trapped to CPU due to egress L3 MTU violation
 *     RESERVED_3       Bit 24 - Reserved
 *     RTUNE            Bit 25 - Receive tunnel error packets
 *     MACLMT           Bit 26 - MAC rate limited packet
 *     HGHDRE           Bit 27 - Higig Header error packets
 *     MCIDXE           Bit 28 - Multicast Index error packets
 *     MAC_RATE_LIMIT   Bit 29 - Packet dropped due to MAC RATE LIMITING
 *     RESERVED_4       Bit 30 - Reserved
 *     RESERVED_5       Bit 31 - Reserved
 *
 ******************************************************************************/
#define BCM56218_A0_ING_EVENT_DEBUGr 0x0e780131

#define BCM56218_A0_ING_EVENT_DEBUGr_SIZE 4

/*
 * This structure should be used to declare and program ING_EVENT_DEBUG.
 *
 */
typedef union BCM56218_A0_ING_EVENT_DEBUGr_s {
	uint32_t v[1];
	uint32_t ing_event_debug[1];
	uint32_t _ing_event_debug;
} BCM56218_A0_ING_EVENT_DEBUGr_t;

#define BCM56218_A0_ING_EVENT_DEBUGr_CLR(r) (r).ing_event_debug[0] = 0
#define BCM56218_A0_ING_EVENT_DEBUGr_SET(r,d) (r).ing_event_debug[0] = d
#define BCM56218_A0_ING_EVENT_DEBUGr_GET(r) (r).ing_event_debug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_ING_EVENT_DEBUGr_VXLT_MISSf_GET(r) (((r).ing_event_debug[0]) & 0x1)
#define BCM56218_A0_ING_EVENT_DEBUGr_VXLT_MISSf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_ING_EVENT_DEBUGr_BPDUf_GET(r) ((((r).ing_event_debug[0]) >> 1) & 0x1)
#define BCM56218_A0_ING_EVENT_DEBUGr_BPDUf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_ING_EVENT_DEBUGr_PROTOCOL_PKTf_GET(r) ((((r).ing_event_debug[0]) >> 2) & 0x1)
#define BCM56218_A0_ING_EVENT_DEBUGr_PROTOCOL_PKTf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_ING_EVENT_DEBUGr_CMLf_GET(r) ((((r).ing_event_debug[0]) >> 3) & 0x1)
#define BCM56218_A0_ING_EVENT_DEBUGr_CMLf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56218_A0_ING_EVENT_DEBUGr_SRC_ROUTEf_GET(r) ((((r).ing_event_debug[0]) >> 4) & 0x1)
#define BCM56218_A0_ING_EVENT_DEBUGr_SRC_ROUTEf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56218_A0_ING_EVENT_DEBUGr_L2SRC_DISCARDf_GET(r) ((((r).ing_event_debug[0]) >> 5) & 0x1)
#define BCM56218_A0_ING_EVENT_DEBUGr_L2SRC_DISCARDf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56218_A0_ING_EVENT_DEBUGr_L2SRC_STATIC_MOVEf_GET(r) ((((r).ing_event_debug[0]) >> 6) & 0x1)
#define BCM56218_A0_ING_EVENT_DEBUGr_L2SRC_STATIC_MOVEf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56218_A0_ING_EVENT_DEBUGr_L2DST_DISCARDf_GET(r) ((((r).ing_event_debug[0]) >> 7) & 0x1)
#define BCM56218_A0_ING_EVENT_DEBUGr_L2DST_DISCARDf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56218_A0_ING_EVENT_DEBUGr_CFI_OR_L3DISABLEf_GET(r) ((((r).ing_event_debug[0]) >> 8) & 0x1)
#define BCM56218_A0_ING_EVENT_DEBUGr_CFI_OR_L3DISABLEf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56218_A0_ING_EVENT_DEBUGr_HIGIG_MH_TYPE1f_GET(r) ((((r).ing_event_debug[0]) >> 9) & 0x1)
#define BCM56218_A0_ING_EVENT_DEBUGr_HIGIG_MH_TYPE1f_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56218_A0_ING_EVENT_DEBUGr_DISC_STAGEf_GET(r) ((((r).ing_event_debug[0]) >> 10) & 0x1)
#define BCM56218_A0_ING_EVENT_DEBUGr_DISC_STAGEf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56218_A0_ING_EVENT_DEBUGr_INVALID_VLANf_GET(r) ((((r).ing_event_debug[0]) >> 11) & 0x1)
#define BCM56218_A0_ING_EVENT_DEBUGr_INVALID_VLANf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56218_A0_ING_EVENT_DEBUGr_PDISCf_GET(r) ((((r).ing_event_debug[0]) >> 12) & 0x1)
#define BCM56218_A0_ING_EVENT_DEBUGr_PDISCf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM56218_A0_ING_EVENT_DEBUGr_RFILDRf_GET(r) ((((r).ing_event_debug[0]) >> 13) & 0x1)
#define BCM56218_A0_ING_EVENT_DEBUGr_RFILDRf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56218_A0_ING_EVENT_DEBUGr_RIMDRf_GET(r) ((((r).ing_event_debug[0]) >> 14) & 0x1)
#define BCM56218_A0_ING_EVENT_DEBUGr_RIMDRf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM56218_A0_ING_EVENT_DEBUGr_RDROPf_GET(r) ((((r).ing_event_debug[0]) >> 15) & 0x1)
#define BCM56218_A0_ING_EVENT_DEBUGr_RDROPf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56218_A0_ING_EVENT_DEBUGr_IMBPf_GET(r) ((((r).ing_event_debug[0]) >> 16) & 0x1)
#define BCM56218_A0_ING_EVENT_DEBUGr_IMBPf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56218_A0_ING_EVENT_DEBUGr_RTUNf_GET(r) ((((r).ing_event_debug[0]) >> 17) & 0x1)
#define BCM56218_A0_ING_EVENT_DEBUGr_RTUNf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_ING_EVENT_DEBUGr_VLANDRf_GET(r) ((((r).ing_event_debug[0]) >> 18) & 0x1)
#define BCM56218_A0_ING_EVENT_DEBUGr_VLANDRf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_ING_EVENT_DEBUGr_DSL3HEf_GET(r) ((((r).ing_event_debug[0]) >> 19) & 0x1)
#define BCM56218_A0_ING_EVENT_DEBUGr_DSL3HEf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56218_A0_ING_EVENT_DEBUGr_DSL4HEf_GET(r) ((((r).ing_event_debug[0]) >> 20) & 0x1)
#define BCM56218_A0_ING_EVENT_DEBUGr_DSL4HEf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM56218_A0_ING_EVENT_DEBUGr_DSICMPf_GET(r) ((((r).ing_event_debug[0]) >> 21) & 0x1)
#define BCM56218_A0_ING_EVENT_DEBUGr_DSICMPf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM56218_A0_ING_EVENT_DEBUGr_DSFRAGf_GET(r) ((((r).ing_event_debug[0]) >> 22) & 0x1)
#define BCM56218_A0_ING_EVENT_DEBUGr_DSFRAGf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM56218_A0_ING_EVENT_DEBUGr_MTUERRf_GET(r) ((((r).ing_event_debug[0]) >> 23) & 0x1)
#define BCM56218_A0_ING_EVENT_DEBUGr_MTUERRf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM56218_A0_ING_EVENT_DEBUGr_RESERVED_3f_GET(r) ((((r).ing_event_debug[0]) >> 24) & 0x1)
#define BCM56218_A0_ING_EVENT_DEBUGr_RESERVED_3f_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM56218_A0_ING_EVENT_DEBUGr_RTUNEf_GET(r) ((((r).ing_event_debug[0]) >> 25) & 0x1)
#define BCM56218_A0_ING_EVENT_DEBUGr_RTUNEf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM56218_A0_ING_EVENT_DEBUGr_MACLMTf_GET(r) ((((r).ing_event_debug[0]) >> 26) & 0x1)
#define BCM56218_A0_ING_EVENT_DEBUGr_MACLMTf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM56218_A0_ING_EVENT_DEBUGr_HGHDREf_GET(r) ((((r).ing_event_debug[0]) >> 27) & 0x1)
#define BCM56218_A0_ING_EVENT_DEBUGr_HGHDREf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM56218_A0_ING_EVENT_DEBUGr_MCIDXEf_GET(r) ((((r).ing_event_debug[0]) >> 28) & 0x1)
#define BCM56218_A0_ING_EVENT_DEBUGr_MCIDXEf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM56218_A0_ING_EVENT_DEBUGr_MAC_RATE_LIMITf_GET(r) ((((r).ing_event_debug[0]) >> 29) & 0x1)
#define BCM56218_A0_ING_EVENT_DEBUGr_MAC_RATE_LIMITf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM56218_A0_ING_EVENT_DEBUGr_RESERVED_4f_GET(r) ((((r).ing_event_debug[0]) >> 30) & 0x1)
#define BCM56218_A0_ING_EVENT_DEBUGr_RESERVED_4f_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM56218_A0_ING_EVENT_DEBUGr_RESERVED_5f_GET(r) ((((r).ing_event_debug[0]) >> 31) & 0x1)
#define BCM56218_A0_ING_EVENT_DEBUGr_RESERVED_5f_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access ING_EVENT_DEBUG.
 *
 */
#define BCM56218_A0_READ_ING_EVENT_DEBUGr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_ING_EVENT_DEBUGr,(r._ing_event_debug))
#define BCM56218_A0_WRITE_ING_EVENT_DEBUGr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_ING_EVENT_DEBUGr,&(r._ing_event_debug))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ING_EVENT_DEBUGr BCM56218_A0_ING_EVENT_DEBUGr
#define ING_EVENT_DEBUGr_SIZE BCM56218_A0_ING_EVENT_DEBUGr_SIZE
typedef BCM56218_A0_ING_EVENT_DEBUGr_t ING_EVENT_DEBUGr_t;
#define ING_EVENT_DEBUGr_CLR BCM56218_A0_ING_EVENT_DEBUGr_CLR
#define ING_EVENT_DEBUGr_SET BCM56218_A0_ING_EVENT_DEBUGr_SET
#define ING_EVENT_DEBUGr_GET BCM56218_A0_ING_EVENT_DEBUGr_GET
#define ING_EVENT_DEBUGr_VXLT_MISSf_GET BCM56218_A0_ING_EVENT_DEBUGr_VXLT_MISSf_GET
#define ING_EVENT_DEBUGr_VXLT_MISSf_SET BCM56218_A0_ING_EVENT_DEBUGr_VXLT_MISSf_SET
#define ING_EVENT_DEBUGr_BPDUf_GET BCM56218_A0_ING_EVENT_DEBUGr_BPDUf_GET
#define ING_EVENT_DEBUGr_BPDUf_SET BCM56218_A0_ING_EVENT_DEBUGr_BPDUf_SET
#define ING_EVENT_DEBUGr_PROTOCOL_PKTf_GET BCM56218_A0_ING_EVENT_DEBUGr_PROTOCOL_PKTf_GET
#define ING_EVENT_DEBUGr_PROTOCOL_PKTf_SET BCM56218_A0_ING_EVENT_DEBUGr_PROTOCOL_PKTf_SET
#define ING_EVENT_DEBUGr_CMLf_GET BCM56218_A0_ING_EVENT_DEBUGr_CMLf_GET
#define ING_EVENT_DEBUGr_CMLf_SET BCM56218_A0_ING_EVENT_DEBUGr_CMLf_SET
#define ING_EVENT_DEBUGr_SRC_ROUTEf_GET BCM56218_A0_ING_EVENT_DEBUGr_SRC_ROUTEf_GET
#define ING_EVENT_DEBUGr_SRC_ROUTEf_SET BCM56218_A0_ING_EVENT_DEBUGr_SRC_ROUTEf_SET
#define ING_EVENT_DEBUGr_L2SRC_DISCARDf_GET BCM56218_A0_ING_EVENT_DEBUGr_L2SRC_DISCARDf_GET
#define ING_EVENT_DEBUGr_L2SRC_DISCARDf_SET BCM56218_A0_ING_EVENT_DEBUGr_L2SRC_DISCARDf_SET
#define ING_EVENT_DEBUGr_L2SRC_STATIC_MOVEf_GET BCM56218_A0_ING_EVENT_DEBUGr_L2SRC_STATIC_MOVEf_GET
#define ING_EVENT_DEBUGr_L2SRC_STATIC_MOVEf_SET BCM56218_A0_ING_EVENT_DEBUGr_L2SRC_STATIC_MOVEf_SET
#define ING_EVENT_DEBUGr_L2DST_DISCARDf_GET BCM56218_A0_ING_EVENT_DEBUGr_L2DST_DISCARDf_GET
#define ING_EVENT_DEBUGr_L2DST_DISCARDf_SET BCM56218_A0_ING_EVENT_DEBUGr_L2DST_DISCARDf_SET
#define ING_EVENT_DEBUGr_CFI_OR_L3DISABLEf_GET BCM56218_A0_ING_EVENT_DEBUGr_CFI_OR_L3DISABLEf_GET
#define ING_EVENT_DEBUGr_CFI_OR_L3DISABLEf_SET BCM56218_A0_ING_EVENT_DEBUGr_CFI_OR_L3DISABLEf_SET
#define ING_EVENT_DEBUGr_HIGIG_MH_TYPE1f_GET BCM56218_A0_ING_EVENT_DEBUGr_HIGIG_MH_TYPE1f_GET
#define ING_EVENT_DEBUGr_HIGIG_MH_TYPE1f_SET BCM56218_A0_ING_EVENT_DEBUGr_HIGIG_MH_TYPE1f_SET
#define ING_EVENT_DEBUGr_DISC_STAGEf_GET BCM56218_A0_ING_EVENT_DEBUGr_DISC_STAGEf_GET
#define ING_EVENT_DEBUGr_DISC_STAGEf_SET BCM56218_A0_ING_EVENT_DEBUGr_DISC_STAGEf_SET
#define ING_EVENT_DEBUGr_INVALID_VLANf_GET BCM56218_A0_ING_EVENT_DEBUGr_INVALID_VLANf_GET
#define ING_EVENT_DEBUGr_INVALID_VLANf_SET BCM56218_A0_ING_EVENT_DEBUGr_INVALID_VLANf_SET
#define ING_EVENT_DEBUGr_PDISCf_GET BCM56218_A0_ING_EVENT_DEBUGr_PDISCf_GET
#define ING_EVENT_DEBUGr_PDISCf_SET BCM56218_A0_ING_EVENT_DEBUGr_PDISCf_SET
#define ING_EVENT_DEBUGr_RFILDRf_GET BCM56218_A0_ING_EVENT_DEBUGr_RFILDRf_GET
#define ING_EVENT_DEBUGr_RFILDRf_SET BCM56218_A0_ING_EVENT_DEBUGr_RFILDRf_SET
#define ING_EVENT_DEBUGr_RIMDRf_GET BCM56218_A0_ING_EVENT_DEBUGr_RIMDRf_GET
#define ING_EVENT_DEBUGr_RIMDRf_SET BCM56218_A0_ING_EVENT_DEBUGr_RIMDRf_SET
#define ING_EVENT_DEBUGr_RDROPf_GET BCM56218_A0_ING_EVENT_DEBUGr_RDROPf_GET
#define ING_EVENT_DEBUGr_RDROPf_SET BCM56218_A0_ING_EVENT_DEBUGr_RDROPf_SET
#define ING_EVENT_DEBUGr_IMBPf_GET BCM56218_A0_ING_EVENT_DEBUGr_IMBPf_GET
#define ING_EVENT_DEBUGr_IMBPf_SET BCM56218_A0_ING_EVENT_DEBUGr_IMBPf_SET
#define ING_EVENT_DEBUGr_RTUNf_GET BCM56218_A0_ING_EVENT_DEBUGr_RTUNf_GET
#define ING_EVENT_DEBUGr_RTUNf_SET BCM56218_A0_ING_EVENT_DEBUGr_RTUNf_SET
#define ING_EVENT_DEBUGr_VLANDRf_GET BCM56218_A0_ING_EVENT_DEBUGr_VLANDRf_GET
#define ING_EVENT_DEBUGr_VLANDRf_SET BCM56218_A0_ING_EVENT_DEBUGr_VLANDRf_SET
#define ING_EVENT_DEBUGr_DSL3HEf_GET BCM56218_A0_ING_EVENT_DEBUGr_DSL3HEf_GET
#define ING_EVENT_DEBUGr_DSL3HEf_SET BCM56218_A0_ING_EVENT_DEBUGr_DSL3HEf_SET
#define ING_EVENT_DEBUGr_DSL4HEf_GET BCM56218_A0_ING_EVENT_DEBUGr_DSL4HEf_GET
#define ING_EVENT_DEBUGr_DSL4HEf_SET BCM56218_A0_ING_EVENT_DEBUGr_DSL4HEf_SET
#define ING_EVENT_DEBUGr_DSICMPf_GET BCM56218_A0_ING_EVENT_DEBUGr_DSICMPf_GET
#define ING_EVENT_DEBUGr_DSICMPf_SET BCM56218_A0_ING_EVENT_DEBUGr_DSICMPf_SET
#define ING_EVENT_DEBUGr_DSFRAGf_GET BCM56218_A0_ING_EVENT_DEBUGr_DSFRAGf_GET
#define ING_EVENT_DEBUGr_DSFRAGf_SET BCM56218_A0_ING_EVENT_DEBUGr_DSFRAGf_SET
#define ING_EVENT_DEBUGr_MTUERRf_GET BCM56218_A0_ING_EVENT_DEBUGr_MTUERRf_GET
#define ING_EVENT_DEBUGr_MTUERRf_SET BCM56218_A0_ING_EVENT_DEBUGr_MTUERRf_SET
#define ING_EVENT_DEBUGr_RESERVED_3f_GET BCM56218_A0_ING_EVENT_DEBUGr_RESERVED_3f_GET
#define ING_EVENT_DEBUGr_RESERVED_3f_SET BCM56218_A0_ING_EVENT_DEBUGr_RESERVED_3f_SET
#define ING_EVENT_DEBUGr_RTUNEf_GET BCM56218_A0_ING_EVENT_DEBUGr_RTUNEf_GET
#define ING_EVENT_DEBUGr_RTUNEf_SET BCM56218_A0_ING_EVENT_DEBUGr_RTUNEf_SET
#define ING_EVENT_DEBUGr_MACLMTf_GET BCM56218_A0_ING_EVENT_DEBUGr_MACLMTf_GET
#define ING_EVENT_DEBUGr_MACLMTf_SET BCM56218_A0_ING_EVENT_DEBUGr_MACLMTf_SET
#define ING_EVENT_DEBUGr_HGHDREf_GET BCM56218_A0_ING_EVENT_DEBUGr_HGHDREf_GET
#define ING_EVENT_DEBUGr_HGHDREf_SET BCM56218_A0_ING_EVENT_DEBUGr_HGHDREf_SET
#define ING_EVENT_DEBUGr_MCIDXEf_GET BCM56218_A0_ING_EVENT_DEBUGr_MCIDXEf_GET
#define ING_EVENT_DEBUGr_MCIDXEf_SET BCM56218_A0_ING_EVENT_DEBUGr_MCIDXEf_SET
#define ING_EVENT_DEBUGr_MAC_RATE_LIMITf_GET BCM56218_A0_ING_EVENT_DEBUGr_MAC_RATE_LIMITf_GET
#define ING_EVENT_DEBUGr_MAC_RATE_LIMITf_SET BCM56218_A0_ING_EVENT_DEBUGr_MAC_RATE_LIMITf_SET
#define ING_EVENT_DEBUGr_RESERVED_4f_GET BCM56218_A0_ING_EVENT_DEBUGr_RESERVED_4f_GET
#define ING_EVENT_DEBUGr_RESERVED_4f_SET BCM56218_A0_ING_EVENT_DEBUGr_RESERVED_4f_SET
#define ING_EVENT_DEBUGr_RESERVED_5f_GET BCM56218_A0_ING_EVENT_DEBUGr_RESERVED_5f_GET
#define ING_EVENT_DEBUGr_RESERVED_5f_SET BCM56218_A0_ING_EVENT_DEBUGr_RESERVED_5f_SET
#define READ_ING_EVENT_DEBUGr BCM56218_A0_READ_ING_EVENT_DEBUGr
#define WRITE_ING_EVENT_DEBUGr BCM56218_A0_WRITE_ING_EVENT_DEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_ING_EVENT_DEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  ING_HW_RESET_CONTROL_1
 * BLOCKS:   IPIPE
 * DESC:     Ingress Pipeline memory hardware initialization register #1
 * SIZE:     32
 * FIELDS:
 *     STAGE_NUMBER     IP stage for the memory table
 *     OFFSET           20-bit starting offset of table for memory
 *
 ******************************************************************************/
#define BCM56218_A0_ING_HW_RESET_CONTROL_1r 0x00780001

#define BCM56218_A0_ING_HW_RESET_CONTROL_1r_SIZE 4

/*
 * This structure should be used to declare and program ING_HW_RESET_CONTROL_1.
 *
 */
typedef union BCM56218_A0_ING_HW_RESET_CONTROL_1r_s {
	uint32_t v[1];
	uint32_t ing_hw_reset_control_1[1];
	uint32_t _ing_hw_reset_control_1;
} BCM56218_A0_ING_HW_RESET_CONTROL_1r_t;

#define BCM56218_A0_ING_HW_RESET_CONTROL_1r_CLR(r) (r).ing_hw_reset_control_1[0] = 0
#define BCM56218_A0_ING_HW_RESET_CONTROL_1r_SET(r,d) (r).ing_hw_reset_control_1[0] = d
#define BCM56218_A0_ING_HW_RESET_CONTROL_1r_GET(r) (r).ing_hw_reset_control_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_ING_HW_RESET_CONTROL_1r_STAGE_NUMBERf_GET(r) (((r).ing_hw_reset_control_1[0]) & 0x3f)
#define BCM56218_A0_ING_HW_RESET_CONTROL_1r_STAGE_NUMBERf_SET(r,f) (r).ing_hw_reset_control_1[0]=(((r).ing_hw_reset_control_1[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM56218_A0_ING_HW_RESET_CONTROL_1r_OFFSETf_GET(r) ((((r).ing_hw_reset_control_1[0]) >> 6) & 0xfffff)
#define BCM56218_A0_ING_HW_RESET_CONTROL_1r_OFFSETf_SET(r,f) (r).ing_hw_reset_control_1[0]=(((r).ing_hw_reset_control_1[0] & ~((uint32_t)0xfffff << 6)) | ((((uint32_t)f) & 0xfffff) << 6))

/*
 * These macros can be used to access ING_HW_RESET_CONTROL_1.
 *
 */
#define BCM56218_A0_READ_ING_HW_RESET_CONTROL_1r(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_ING_HW_RESET_CONTROL_1r,(r._ing_hw_reset_control_1))
#define BCM56218_A0_WRITE_ING_HW_RESET_CONTROL_1r(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_ING_HW_RESET_CONTROL_1r,&(r._ing_hw_reset_control_1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ING_HW_RESET_CONTROL_1r BCM56218_A0_ING_HW_RESET_CONTROL_1r
#define ING_HW_RESET_CONTROL_1r_SIZE BCM56218_A0_ING_HW_RESET_CONTROL_1r_SIZE
typedef BCM56218_A0_ING_HW_RESET_CONTROL_1r_t ING_HW_RESET_CONTROL_1r_t;
#define ING_HW_RESET_CONTROL_1r_CLR BCM56218_A0_ING_HW_RESET_CONTROL_1r_CLR
#define ING_HW_RESET_CONTROL_1r_SET BCM56218_A0_ING_HW_RESET_CONTROL_1r_SET
#define ING_HW_RESET_CONTROL_1r_GET BCM56218_A0_ING_HW_RESET_CONTROL_1r_GET
#define ING_HW_RESET_CONTROL_1r_STAGE_NUMBERf_GET BCM56218_A0_ING_HW_RESET_CONTROL_1r_STAGE_NUMBERf_GET
#define ING_HW_RESET_CONTROL_1r_STAGE_NUMBERf_SET BCM56218_A0_ING_HW_RESET_CONTROL_1r_STAGE_NUMBERf_SET
#define ING_HW_RESET_CONTROL_1r_OFFSETf_GET BCM56218_A0_ING_HW_RESET_CONTROL_1r_OFFSETf_GET
#define ING_HW_RESET_CONTROL_1r_OFFSETf_SET BCM56218_A0_ING_HW_RESET_CONTROL_1r_OFFSETf_SET
#define READ_ING_HW_RESET_CONTROL_1r BCM56218_A0_READ_ING_HW_RESET_CONTROL_1r
#define WRITE_ING_HW_RESET_CONTROL_1r BCM56218_A0_WRITE_ING_HW_RESET_CONTROL_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_ING_HW_RESET_CONTROL_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  ING_HW_RESET_CONTROL_2
 * BLOCKS:   IPIPE
 * DESC:     Ingress Pipeline memory hardware initialization register #2
 * SIZE:     32
 * FIELDS:
 *     COUNT            Number of entries of memory to initialize
 *     RESET_ALL        Indicates all memories in all stages should be initialized (independent of stage or table number)
 *     VALID            Set by software to trigger memory initialization
 *     DONE             Set by arbiter to indicate memory table writes have completed
 *
 ******************************************************************************/
#define BCM56218_A0_ING_HW_RESET_CONTROL_2r 0x00780002

#define BCM56218_A0_ING_HW_RESET_CONTROL_2r_SIZE 4

/*
 * This structure should be used to declare and program ING_HW_RESET_CONTROL_2.
 *
 */
typedef union BCM56218_A0_ING_HW_RESET_CONTROL_2r_s {
	uint32_t v[1];
	uint32_t ing_hw_reset_control_2[1];
	uint32_t _ing_hw_reset_control_2;
} BCM56218_A0_ING_HW_RESET_CONTROL_2r_t;

#define BCM56218_A0_ING_HW_RESET_CONTROL_2r_CLR(r) (r).ing_hw_reset_control_2[0] = 0
#define BCM56218_A0_ING_HW_RESET_CONTROL_2r_SET(r,d) (r).ing_hw_reset_control_2[0] = d
#define BCM56218_A0_ING_HW_RESET_CONTROL_2r_GET(r) (r).ing_hw_reset_control_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_ING_HW_RESET_CONTROL_2r_COUNTf_GET(r) (((r).ing_hw_reset_control_2[0]) & 0xffff)
#define BCM56218_A0_ING_HW_RESET_CONTROL_2r_COUNTf_SET(r,f) (r).ing_hw_reset_control_2[0]=(((r).ing_hw_reset_control_2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56218_A0_ING_HW_RESET_CONTROL_2r_RESET_ALLf_GET(r) ((((r).ing_hw_reset_control_2[0]) >> 16) & 0x1)
#define BCM56218_A0_ING_HW_RESET_CONTROL_2r_RESET_ALLf_SET(r,f) (r).ing_hw_reset_control_2[0]=(((r).ing_hw_reset_control_2[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56218_A0_ING_HW_RESET_CONTROL_2r_VALIDf_GET(r) ((((r).ing_hw_reset_control_2[0]) >> 17) & 0x1)
#define BCM56218_A0_ING_HW_RESET_CONTROL_2r_VALIDf_SET(r,f) (r).ing_hw_reset_control_2[0]=(((r).ing_hw_reset_control_2[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_ING_HW_RESET_CONTROL_2r_DONEf_GET(r) ((((r).ing_hw_reset_control_2[0]) >> 18) & 0x1)
#define BCM56218_A0_ING_HW_RESET_CONTROL_2r_DONEf_SET(r,f) (r).ing_hw_reset_control_2[0]=(((r).ing_hw_reset_control_2[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))

/*
 * These macros can be used to access ING_HW_RESET_CONTROL_2.
 *
 */
#define BCM56218_A0_READ_ING_HW_RESET_CONTROL_2r(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_ING_HW_RESET_CONTROL_2r,(r._ing_hw_reset_control_2))
#define BCM56218_A0_WRITE_ING_HW_RESET_CONTROL_2r(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_ING_HW_RESET_CONTROL_2r,&(r._ing_hw_reset_control_2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ING_HW_RESET_CONTROL_2r BCM56218_A0_ING_HW_RESET_CONTROL_2r
#define ING_HW_RESET_CONTROL_2r_SIZE BCM56218_A0_ING_HW_RESET_CONTROL_2r_SIZE
typedef BCM56218_A0_ING_HW_RESET_CONTROL_2r_t ING_HW_RESET_CONTROL_2r_t;
#define ING_HW_RESET_CONTROL_2r_CLR BCM56218_A0_ING_HW_RESET_CONTROL_2r_CLR
#define ING_HW_RESET_CONTROL_2r_SET BCM56218_A0_ING_HW_RESET_CONTROL_2r_SET
#define ING_HW_RESET_CONTROL_2r_GET BCM56218_A0_ING_HW_RESET_CONTROL_2r_GET
#define ING_HW_RESET_CONTROL_2r_COUNTf_GET BCM56218_A0_ING_HW_RESET_CONTROL_2r_COUNTf_GET
#define ING_HW_RESET_CONTROL_2r_COUNTf_SET BCM56218_A0_ING_HW_RESET_CONTROL_2r_COUNTf_SET
#define ING_HW_RESET_CONTROL_2r_RESET_ALLf_GET BCM56218_A0_ING_HW_RESET_CONTROL_2r_RESET_ALLf_GET
#define ING_HW_RESET_CONTROL_2r_RESET_ALLf_SET BCM56218_A0_ING_HW_RESET_CONTROL_2r_RESET_ALLf_SET
#define ING_HW_RESET_CONTROL_2r_VALIDf_GET BCM56218_A0_ING_HW_RESET_CONTROL_2r_VALIDf_GET
#define ING_HW_RESET_CONTROL_2r_VALIDf_SET BCM56218_A0_ING_HW_RESET_CONTROL_2r_VALIDf_SET
#define ING_HW_RESET_CONTROL_2r_DONEf_GET BCM56218_A0_ING_HW_RESET_CONTROL_2r_DONEf_GET
#define ING_HW_RESET_CONTROL_2r_DONEf_SET BCM56218_A0_ING_HW_RESET_CONTROL_2r_DONEf_SET
#define READ_ING_HW_RESET_CONTROL_2r BCM56218_A0_READ_ING_HW_RESET_CONTROL_2r
#define WRITE_ING_HW_RESET_CONTROL_2r BCM56218_A0_WRITE_ING_HW_RESET_CONTROL_2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_ING_HW_RESET_CONTROL_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  ING_L3_NEXT_HOP
 * BLOCKS:   IPIPE
 * DESC:     Reduced version of L3_NEXT_HOP table.  Used to provide just mod and port/TGID
 * SIZE:     24
 * FIELDS:
 *     L3UC_TUNNEL_TYPE Tunnel Type - 0 means no encap will be done. 1 means pkt will be l3 encapsulated.
 *     PORT_TGID        Port/TGID of next hop
 *     MODULE_ID        Module ID of next hop
 *     VLAN_ID          VLAN ID of next hop
 *
 ******************************************************************************/
#define BCM56218_A0_ING_L3_NEXT_HOPm 0x0d710000

#define BCM56218_A0_ING_L3_NEXT_HOPm_MIN 0
#define BCM56218_A0_ING_L3_NEXT_HOPm_MAX 255
#define BCM56218_A0_ING_L3_NEXT_HOPm_CMAX(u) 255
#define BCM56218_A0_ING_L3_NEXT_HOPm_SIZE 3

/*
 * This structure should be used to declare and program ING_L3_NEXT_HOP.
 *
 */
typedef union BCM56218_A0_ING_L3_NEXT_HOPm_s {
	uint32_t v[1];
	uint32_t ing_l3_next_hop[1];
	uint32_t _ing_l3_next_hop;
} BCM56218_A0_ING_L3_NEXT_HOPm_t;

#define BCM56218_A0_ING_L3_NEXT_HOPm_CLR(r) (r).ing_l3_next_hop[0] = 0
#define BCM56218_A0_ING_L3_NEXT_HOPm_SET(r,d) (r).ing_l3_next_hop[0] = d
#define BCM56218_A0_ING_L3_NEXT_HOPm_GET(r) (r).ing_l3_next_hop[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_ING_L3_NEXT_HOPm_L3UC_TUNNEL_TYPEf_GET(r) (((r).ing_l3_next_hop[0]) & 0x1)
#define BCM56218_A0_ING_L3_NEXT_HOPm_L3UC_TUNNEL_TYPEf_SET(r,f) (r).ing_l3_next_hop[0]=(((r).ing_l3_next_hop[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_ING_L3_NEXT_HOPm_PORT_TGIDf_GET(r) ((((r).ing_l3_next_hop[0]) >> 1) & 0x7f)
#define BCM56218_A0_ING_L3_NEXT_HOPm_PORT_TGIDf_SET(r,f) (r).ing_l3_next_hop[0]=(((r).ing_l3_next_hop[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))
#define BCM56218_A0_ING_L3_NEXT_HOPm_MODULE_IDf_GET(r) ((((r).ing_l3_next_hop[0]) >> 8) & 0xf)
#define BCM56218_A0_ING_L3_NEXT_HOPm_MODULE_IDf_SET(r,f) (r).ing_l3_next_hop[0]=(((r).ing_l3_next_hop[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM56218_A0_ING_L3_NEXT_HOPm_VLAN_IDf_GET(r) ((((r).ing_l3_next_hop[0]) >> 12) & 0xfff)
#define BCM56218_A0_ING_L3_NEXT_HOPm_VLAN_IDf_SET(r,f) (r).ing_l3_next_hop[0]=(((r).ing_l3_next_hop[0] & ~((uint32_t)0xfff << 12)) | ((((uint32_t)f) & 0xfff) << 12))

/*
 * These macros can be used to access ING_L3_NEXT_HOP.
 *
 */
#define BCM56218_A0_READ_ING_L3_NEXT_HOPm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_ING_L3_NEXT_HOPm,i,(m._ing_l3_next_hop),1)
#define BCM56218_A0_WRITE_ING_L3_NEXT_HOPm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_ING_L3_NEXT_HOPm,i,&(m._ing_l3_next_hop),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ING_L3_NEXT_HOPm BCM56218_A0_ING_L3_NEXT_HOPm
#define ING_L3_NEXT_HOPm_MIN BCM56218_A0_ING_L3_NEXT_HOPm_MIN
#define ING_L3_NEXT_HOPm_MAX BCM56218_A0_ING_L3_NEXT_HOPm_MAX
#define ING_L3_NEXT_HOPm_CMAX(u) BCM56218_A0_ING_L3_NEXT_HOPm_CMAX(u)
#define ING_L3_NEXT_HOPm_SIZE BCM56218_A0_ING_L3_NEXT_HOPm_SIZE
typedef BCM56218_A0_ING_L3_NEXT_HOPm_t ING_L3_NEXT_HOPm_t;
#define ING_L3_NEXT_HOPm_CLR BCM56218_A0_ING_L3_NEXT_HOPm_CLR
#define ING_L3_NEXT_HOPm_SET BCM56218_A0_ING_L3_NEXT_HOPm_SET
#define ING_L3_NEXT_HOPm_GET BCM56218_A0_ING_L3_NEXT_HOPm_GET
#define ING_L3_NEXT_HOPm_L3UC_TUNNEL_TYPEf_GET BCM56218_A0_ING_L3_NEXT_HOPm_L3UC_TUNNEL_TYPEf_GET
#define ING_L3_NEXT_HOPm_L3UC_TUNNEL_TYPEf_SET BCM56218_A0_ING_L3_NEXT_HOPm_L3UC_TUNNEL_TYPEf_SET
#define ING_L3_NEXT_HOPm_PORT_TGIDf_GET BCM56218_A0_ING_L3_NEXT_HOPm_PORT_TGIDf_GET
#define ING_L3_NEXT_HOPm_PORT_TGIDf_SET BCM56218_A0_ING_L3_NEXT_HOPm_PORT_TGIDf_SET
#define ING_L3_NEXT_HOPm_MODULE_IDf_GET BCM56218_A0_ING_L3_NEXT_HOPm_MODULE_IDf_GET
#define ING_L3_NEXT_HOPm_MODULE_IDf_SET BCM56218_A0_ING_L3_NEXT_HOPm_MODULE_IDf_SET
#define ING_L3_NEXT_HOPm_VLAN_IDf_GET BCM56218_A0_ING_L3_NEXT_HOPm_VLAN_IDf_GET
#define ING_L3_NEXT_HOPm_VLAN_IDf_SET BCM56218_A0_ING_L3_NEXT_HOPm_VLAN_IDf_SET
#define READ_ING_L3_NEXT_HOPm BCM56218_A0_READ_ING_L3_NEXT_HOPm
#define WRITE_ING_L3_NEXT_HOPm BCM56218_A0_WRITE_ING_L3_NEXT_HOPm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_ING_L3_NEXT_HOPm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  ING_MISC_CONFIG
 * BLOCKS:   IPIPE
 * DESC:     Configuration bits that are needed in Isw2
 * SIZE:     32
 * FIELDS:
 *     APPLY_EGR_MASK_ON_UC_ONLY If set, apply egress mask on unicast packets only.
 *     APPLY_SRCMOD_BLOCK_ON_UC_ONLY If set, apply source modid block on unicast packets only.
 *     DO_NOT_APPLY_SRCMOD_BLOCK_ON_SC If set, do not apply source modid block on system control packets.
 *
 ******************************************************************************/
#define BCM56218_A0_ING_MISC_CONFIGr 0x0e78012d

#define BCM56218_A0_ING_MISC_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program ING_MISC_CONFIG.
 *
 */
typedef union BCM56218_A0_ING_MISC_CONFIGr_s {
	uint32_t v[1];
	uint32_t ing_misc_config[1];
	uint32_t _ing_misc_config;
} BCM56218_A0_ING_MISC_CONFIGr_t;

#define BCM56218_A0_ING_MISC_CONFIGr_CLR(r) (r).ing_misc_config[0] = 0
#define BCM56218_A0_ING_MISC_CONFIGr_SET(r,d) (r).ing_misc_config[0] = d
#define BCM56218_A0_ING_MISC_CONFIGr_GET(r) (r).ing_misc_config[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_ING_MISC_CONFIGr_APPLY_EGR_MASK_ON_UC_ONLYf_GET(r) (((r).ing_misc_config[0]) & 0x1)
#define BCM56218_A0_ING_MISC_CONFIGr_APPLY_EGR_MASK_ON_UC_ONLYf_SET(r,f) (r).ing_misc_config[0]=(((r).ing_misc_config[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_ING_MISC_CONFIGr_APPLY_SRCMOD_BLOCK_ON_UC_ONLYf_GET(r) ((((r).ing_misc_config[0]) >> 1) & 0x1)
#define BCM56218_A0_ING_MISC_CONFIGr_APPLY_SRCMOD_BLOCK_ON_UC_ONLYf_SET(r,f) (r).ing_misc_config[0]=(((r).ing_misc_config[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_ING_MISC_CONFIGr_DO_NOT_APPLY_SRCMOD_BLOCK_ON_SCf_GET(r) ((((r).ing_misc_config[0]) >> 2) & 0x1)
#define BCM56218_A0_ING_MISC_CONFIGr_DO_NOT_APPLY_SRCMOD_BLOCK_ON_SCf_SET(r,f) (r).ing_misc_config[0]=(((r).ing_misc_config[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))

/*
 * These macros can be used to access ING_MISC_CONFIG.
 *
 */
#define BCM56218_A0_READ_ING_MISC_CONFIGr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_ING_MISC_CONFIGr,(r._ing_misc_config))
#define BCM56218_A0_WRITE_ING_MISC_CONFIGr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_ING_MISC_CONFIGr,&(r._ing_misc_config))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ING_MISC_CONFIGr BCM56218_A0_ING_MISC_CONFIGr
#define ING_MISC_CONFIGr_SIZE BCM56218_A0_ING_MISC_CONFIGr_SIZE
typedef BCM56218_A0_ING_MISC_CONFIGr_t ING_MISC_CONFIGr_t;
#define ING_MISC_CONFIGr_CLR BCM56218_A0_ING_MISC_CONFIGr_CLR
#define ING_MISC_CONFIGr_SET BCM56218_A0_ING_MISC_CONFIGr_SET
#define ING_MISC_CONFIGr_GET BCM56218_A0_ING_MISC_CONFIGr_GET
#define ING_MISC_CONFIGr_APPLY_EGR_MASK_ON_UC_ONLYf_GET BCM56218_A0_ING_MISC_CONFIGr_APPLY_EGR_MASK_ON_UC_ONLYf_GET
#define ING_MISC_CONFIGr_APPLY_EGR_MASK_ON_UC_ONLYf_SET BCM56218_A0_ING_MISC_CONFIGr_APPLY_EGR_MASK_ON_UC_ONLYf_SET
#define ING_MISC_CONFIGr_APPLY_SRCMOD_BLOCK_ON_UC_ONLYf_GET BCM56218_A0_ING_MISC_CONFIGr_APPLY_SRCMOD_BLOCK_ON_UC_ONLYf_GET
#define ING_MISC_CONFIGr_APPLY_SRCMOD_BLOCK_ON_UC_ONLYf_SET BCM56218_A0_ING_MISC_CONFIGr_APPLY_SRCMOD_BLOCK_ON_UC_ONLYf_SET
#define ING_MISC_CONFIGr_DO_NOT_APPLY_SRCMOD_BLOCK_ON_SCf_GET BCM56218_A0_ING_MISC_CONFIGr_DO_NOT_APPLY_SRCMOD_BLOCK_ON_SCf_GET
#define ING_MISC_CONFIGr_DO_NOT_APPLY_SRCMOD_BLOCK_ON_SCf_SET BCM56218_A0_ING_MISC_CONFIGr_DO_NOT_APPLY_SRCMOD_BLOCK_ON_SCf_SET
#define READ_ING_MISC_CONFIGr BCM56218_A0_READ_ING_MISC_CONFIGr
#define WRITE_ING_MISC_CONFIGr BCM56218_A0_WRITE_ING_MISC_CONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_ING_MISC_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  ING_MISC_CONFIG2
 * BLOCKS:   IPIPE
 * DESC:     Miscellaneous configuration bits
 * SIZE:     32
 * FIELDS:
 *     MACSA_ALL_ZERO_DROP If this bit is set, packets which have a MAC SA as all zeroes will be dropped
 *
 ******************************************************************************/
#define BCM56218_A0_ING_MISC_CONFIG2r 0x0b78000c

#define BCM56218_A0_ING_MISC_CONFIG2r_SIZE 4

/*
 * This structure should be used to declare and program ING_MISC_CONFIG2.
 *
 */
typedef union BCM56218_A0_ING_MISC_CONFIG2r_s {
	uint32_t v[1];
	uint32_t ing_misc_config2[1];
	uint32_t _ing_misc_config2;
} BCM56218_A0_ING_MISC_CONFIG2r_t;

#define BCM56218_A0_ING_MISC_CONFIG2r_CLR(r) (r).ing_misc_config2[0] = 0
#define BCM56218_A0_ING_MISC_CONFIG2r_SET(r,d) (r).ing_misc_config2[0] = d
#define BCM56218_A0_ING_MISC_CONFIG2r_GET(r) (r).ing_misc_config2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_ING_MISC_CONFIG2r_MACSA_ALL_ZERO_DROPf_GET(r) (((r).ing_misc_config2[0]) & 0x1)
#define BCM56218_A0_ING_MISC_CONFIG2r_MACSA_ALL_ZERO_DROPf_SET(r,f) (r).ing_misc_config2[0]=(((r).ing_misc_config2[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access ING_MISC_CONFIG2.
 *
 */
#define BCM56218_A0_READ_ING_MISC_CONFIG2r(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_ING_MISC_CONFIG2r,(r._ing_misc_config2))
#define BCM56218_A0_WRITE_ING_MISC_CONFIG2r(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_ING_MISC_CONFIG2r,&(r._ing_misc_config2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ING_MISC_CONFIG2r BCM56218_A0_ING_MISC_CONFIG2r
#define ING_MISC_CONFIG2r_SIZE BCM56218_A0_ING_MISC_CONFIG2r_SIZE
typedef BCM56218_A0_ING_MISC_CONFIG2r_t ING_MISC_CONFIG2r_t;
#define ING_MISC_CONFIG2r_CLR BCM56218_A0_ING_MISC_CONFIG2r_CLR
#define ING_MISC_CONFIG2r_SET BCM56218_A0_ING_MISC_CONFIG2r_SET
#define ING_MISC_CONFIG2r_GET BCM56218_A0_ING_MISC_CONFIG2r_GET
#define ING_MISC_CONFIG2r_MACSA_ALL_ZERO_DROPf_GET BCM56218_A0_ING_MISC_CONFIG2r_MACSA_ALL_ZERO_DROPf_GET
#define ING_MISC_CONFIG2r_MACSA_ALL_ZERO_DROPf_SET BCM56218_A0_ING_MISC_CONFIG2r_MACSA_ALL_ZERO_DROPf_SET
#define READ_ING_MISC_CONFIG2r BCM56218_A0_READ_ING_MISC_CONFIG2r
#define WRITE_ING_MISC_CONFIG2r BCM56218_A0_WRITE_ING_MISC_CONFIG2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_ING_MISC_CONFIG2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  ING_Q_BEGIN
 * BLOCKS:   IPIPE
 * DESC:     Register starts the IQ Bus which is provided for later ECO reasons, if any.
 * SIZE:     32
 * FIELDS:
 *     QBUS             Debug BUS introduced for later ECO provisions.
 *
 ******************************************************************************/
#define BCM56218_A0_ING_Q_BEGINr 0x00780006

#define BCM56218_A0_ING_Q_BEGINr_SIZE 4

/*
 * This structure should be used to declare and program ING_Q_BEGIN.
 *
 */
typedef union BCM56218_A0_ING_Q_BEGINr_s {
	uint32_t v[1];
	uint32_t ing_q_begin[1];
	uint32_t _ing_q_begin;
} BCM56218_A0_ING_Q_BEGINr_t;

#define BCM56218_A0_ING_Q_BEGINr_CLR(r) (r).ing_q_begin[0] = 0
#define BCM56218_A0_ING_Q_BEGINr_SET(r,d) (r).ing_q_begin[0] = d
#define BCM56218_A0_ING_Q_BEGINr_GET(r) (r).ing_q_begin[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_ING_Q_BEGINr_QBUSf_GET(r) ((r).ing_q_begin[0])
#define BCM56218_A0_ING_Q_BEGINr_QBUSf_SET(r,f) (r).ing_q_begin[0]=((uint32_t)f)

/*
 * These macros can be used to access ING_Q_BEGIN.
 *
 */
#define BCM56218_A0_READ_ING_Q_BEGINr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_ING_Q_BEGINr,(r._ing_q_begin))
#define BCM56218_A0_WRITE_ING_Q_BEGINr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_ING_Q_BEGINr,&(r._ing_q_begin))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ING_Q_BEGINr BCM56218_A0_ING_Q_BEGINr
#define ING_Q_BEGINr_SIZE BCM56218_A0_ING_Q_BEGINr_SIZE
typedef BCM56218_A0_ING_Q_BEGINr_t ING_Q_BEGINr_t;
#define ING_Q_BEGINr_CLR BCM56218_A0_ING_Q_BEGINr_CLR
#define ING_Q_BEGINr_SET BCM56218_A0_ING_Q_BEGINr_SET
#define ING_Q_BEGINr_GET BCM56218_A0_ING_Q_BEGINr_GET
#define ING_Q_BEGINr_QBUSf_GET BCM56218_A0_ING_Q_BEGINr_QBUSf_GET
#define ING_Q_BEGINr_QBUSf_SET BCM56218_A0_ING_Q_BEGINr_QBUSf_SET
#define READ_ING_Q_BEGINr BCM56218_A0_READ_ING_Q_BEGINr
#define WRITE_ING_Q_BEGINr BCM56218_A0_WRITE_ING_Q_BEGINr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_ING_Q_BEGINr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  IPORT_TABLE
 * BLOCKS:   IPIPE_HI
 * DESC:     Port Table
 * SIZE:     66
 * FIELDS:
 *     FILTER_ENABLE    Enable Filtering
 *     RESERVED0        RESERVED bit 
 *     RESERVED1        RESERVED bit
 *     TRUST_DSCP_V4    Ingress port is trusted port, trust incoming IPv4 DSCP
 *     TRUST_DSCP_V6    Ingress port is trusted port, trust incoming IPv6 DSCP
 *     EN_IFILTER       Enable ingress filtering
 *     MIRROR           Mirror enable
 *     CML              CPU managed learning
 *     PORT_PRI         Port default priority
 *     RESERVED2        RESERVED bit
 *     RESERVED3        RESERVED bit 
 *     RESERVED4        RESERVED bit 
 *     V6L3_ENABLE      IPv6 L3 enable
 *     V4L3_ENABLE      IPv4 L3 enable
 *     DROP_BPDU        when set, ingress drops BPDUs
 *     PORT_DIS_TAG     Drop all tagged packets
 *     PORT_DIS_UNTAG   Drop all untagged packets
 *     PASS_CONTROL_FRAMES Pass pause frames through without dropping
 *     SUBNET_BASED_VID_ENABLE Enable subnet-based VLANs
 *     MAC_BASED_VID_ENABLE Enable MAC-based VLANs
 *     PORT_VID         Port VLAN
 *     HIGIG_PACKET     Port is HiGig port
 *     NNI_PORT         Port is NNI port if set to 1, otherwise UNI port
 *     MAP_TAG_PKT_PRIORITY Map the incoming packet priority
 *     MY_MODID         Stacking module ID for this module
 *     OUTER_TPID       Outer (switching) VLAN
 *     VLAN_PRECEDENCE  Determine the priorities for selecting VLAN (MAC-based, subnet-based VLANs)
 *     PORT_BRIDGE      Allows L2 bridging to the incoming port
 *     MODPORT_TABLE_SEL To Select results from multiple modport tables
 *     IGNORE_MODID_LKUPS To ignore the look up results from the module id based tables. This is used for passthru pkts with modid greater than 16.
 *     REMOVE_HG_HDR_SRC_PORT If set to 1, do not forward the pkt to the non-trunk (i.e., not LAG) source port in module header when the MH.SRC_MODID is same as ING_CONFIG.MY_MODID. NOTE: If module header's source port is a trunk (LAG) port, the pkts are not forwarded to its LAG members irrespective of this control bit
 *     ALLOW_SRC_MOD    When set, packets whose source modid is equal to my_modid are not dropped
 *
 ******************************************************************************/
#define BCM56218_A0_IPORT_TABLEm 0x01800000

#define BCM56218_A0_IPORT_TABLEm_MIN 0
#define BCM56218_A0_IPORT_TABLEm_MAX 2
#define BCM56218_A0_IPORT_TABLEm_CMAX(u) 2
#define BCM56218_A0_IPORT_TABLEm_SIZE 9

/*
 * This structure should be used to declare and program IPORT_TABLE.
 *
 */
typedef union BCM56218_A0_IPORT_TABLEm_s {
	uint32_t v[3];
	uint32_t iport_table[3];
	uint32_t _iport_table;
} BCM56218_A0_IPORT_TABLEm_t;

#define BCM56218_A0_IPORT_TABLEm_CLR(r) CDK_MEMSET(&((r)._iport_table), 0, sizeof(BCM56218_A0_IPORT_TABLEm_t))
#define BCM56218_A0_IPORT_TABLEm_SET(r,i,d) (r).iport_table[i] = d
#define BCM56218_A0_IPORT_TABLEm_GET(r,i) (r).iport_table[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_IPORT_TABLEm_FILTER_ENABLEf_GET(r) (((r).iport_table[0]) & 0x1)
#define BCM56218_A0_IPORT_TABLEm_FILTER_ENABLEf_SET(r,f) (r).iport_table[0]=(((r).iport_table[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_IPORT_TABLEm_RESERVED0f_GET(r) ((((r).iport_table[0]) >> 1) & 0x1)
#define BCM56218_A0_IPORT_TABLEm_RESERVED0f_SET(r,f) (r).iport_table[0]=(((r).iport_table[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_IPORT_TABLEm_RESERVED1f_GET(r) ((((r).iport_table[0]) >> 2) & 0x1)
#define BCM56218_A0_IPORT_TABLEm_RESERVED1f_SET(r,f) (r).iport_table[0]=(((r).iport_table[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_IPORT_TABLEm_TRUST_DSCP_V4f_GET(r) ((((r).iport_table[0]) >> 3) & 0x1)
#define BCM56218_A0_IPORT_TABLEm_TRUST_DSCP_V4f_SET(r,f) (r).iport_table[0]=(((r).iport_table[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56218_A0_IPORT_TABLEm_TRUST_DSCP_V6f_GET(r) ((((r).iport_table[0]) >> 4) & 0x1)
#define BCM56218_A0_IPORT_TABLEm_TRUST_DSCP_V6f_SET(r,f) (r).iport_table[0]=(((r).iport_table[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56218_A0_IPORT_TABLEm_EN_IFILTERf_GET(r) ((((r).iport_table[0]) >> 5) & 0x1)
#define BCM56218_A0_IPORT_TABLEm_EN_IFILTERf_SET(r,f) (r).iport_table[0]=(((r).iport_table[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56218_A0_IPORT_TABLEm_MIRRORf_GET(r) ((((r).iport_table[0]) >> 6) & 0x1)
#define BCM56218_A0_IPORT_TABLEm_MIRRORf_SET(r,f) (r).iport_table[0]=(((r).iport_table[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56218_A0_IPORT_TABLEm_CMLf_GET(r) ((((r).iport_table[0]) >> 7) & 0x7)
#define BCM56218_A0_IPORT_TABLEm_CMLf_SET(r,f) (r).iport_table[0]=(((r).iport_table[0] & ~((uint32_t)0x7 << 7)) | ((((uint32_t)f) & 0x7) << 7))
#define BCM56218_A0_IPORT_TABLEm_PORT_PRIf_GET(r) ((((r).iport_table[0]) >> 10) & 0x7)
#define BCM56218_A0_IPORT_TABLEm_PORT_PRIf_SET(r,f) (r).iport_table[0]=(((r).iport_table[0] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10))
#define BCM56218_A0_IPORT_TABLEm_RESERVED2f_GET(r) ((((r).iport_table[0]) >> 13) & 0x1)
#define BCM56218_A0_IPORT_TABLEm_RESERVED2f_SET(r,f) (r).iport_table[0]=(((r).iport_table[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56218_A0_IPORT_TABLEm_RESERVED3f_GET(r) ((((r).iport_table[0]) >> 14) & 0x1)
#define BCM56218_A0_IPORT_TABLEm_RESERVED3f_SET(r,f) (r).iport_table[0]=(((r).iport_table[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM56218_A0_IPORT_TABLEm_RESERVED4f_GET(r) ((((r).iport_table[0]) >> 15) & 0x1)
#define BCM56218_A0_IPORT_TABLEm_RESERVED4f_SET(r,f) (r).iport_table[0]=(((r).iport_table[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56218_A0_IPORT_TABLEm_V6L3_ENABLEf_GET(r) ((((r).iport_table[0]) >> 16) & 0x1)
#define BCM56218_A0_IPORT_TABLEm_V6L3_ENABLEf_SET(r,f) (r).iport_table[0]=(((r).iport_table[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56218_A0_IPORT_TABLEm_V4L3_ENABLEf_GET(r) ((((r).iport_table[0]) >> 17) & 0x1)
#define BCM56218_A0_IPORT_TABLEm_V4L3_ENABLEf_SET(r,f) (r).iport_table[0]=(((r).iport_table[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_IPORT_TABLEm_DROP_BPDUf_GET(r) ((((r).iport_table[0]) >> 18) & 0x1)
#define BCM56218_A0_IPORT_TABLEm_DROP_BPDUf_SET(r,f) (r).iport_table[0]=(((r).iport_table[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_IPORT_TABLEm_PORT_DIS_TAGf_GET(r) ((((r).iport_table[0]) >> 19) & 0x1)
#define BCM56218_A0_IPORT_TABLEm_PORT_DIS_TAGf_SET(r,f) (r).iport_table[0]=(((r).iport_table[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56218_A0_IPORT_TABLEm_PORT_DIS_UNTAGf_GET(r) ((((r).iport_table[0]) >> 20) & 0x1)
#define BCM56218_A0_IPORT_TABLEm_PORT_DIS_UNTAGf_SET(r,f) (r).iport_table[0]=(((r).iport_table[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM56218_A0_IPORT_TABLEm_PASS_CONTROL_FRAMESf_GET(r) ((((r).iport_table[0]) >> 21) & 0x1)
#define BCM56218_A0_IPORT_TABLEm_PASS_CONTROL_FRAMESf_SET(r,f) (r).iport_table[0]=(((r).iport_table[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM56218_A0_IPORT_TABLEm_SUBNET_BASED_VID_ENABLEf_GET(r) ((((r).iport_table[0]) >> 22) & 0x1)
#define BCM56218_A0_IPORT_TABLEm_SUBNET_BASED_VID_ENABLEf_SET(r,f) (r).iport_table[0]=(((r).iport_table[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM56218_A0_IPORT_TABLEm_MAC_BASED_VID_ENABLEf_GET(r) ((((r).iport_table[0]) >> 23) & 0x1)
#define BCM56218_A0_IPORT_TABLEm_MAC_BASED_VID_ENABLEf_SET(r,f) (r).iport_table[0]=(((r).iport_table[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM56218_A0_IPORT_TABLEm_PORT_VIDf_GET(r) cdk_field32_get((r).iport_table,24,35)
#define BCM56218_A0_IPORT_TABLEm_PORT_VIDf_SET(r,f) cdk_field32_set((r).iport_table,24,35,f)
#define BCM56218_A0_IPORT_TABLEm_HIGIG_PACKETf_GET(r) ((((r).iport_table[1]) >> 4) & 0x1)
#define BCM56218_A0_IPORT_TABLEm_HIGIG_PACKETf_SET(r,f) (r).iport_table[1]=(((r).iport_table[1] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56218_A0_IPORT_TABLEm_NNI_PORTf_GET(r) ((((r).iport_table[1]) >> 5) & 0x1)
#define BCM56218_A0_IPORT_TABLEm_NNI_PORTf_SET(r,f) (r).iport_table[1]=(((r).iport_table[1] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56218_A0_IPORT_TABLEm_MAP_TAG_PKT_PRIORITYf_GET(r) ((((r).iport_table[1]) >> 6) & 0x1)
#define BCM56218_A0_IPORT_TABLEm_MAP_TAG_PKT_PRIORITYf_SET(r,f) (r).iport_table[1]=(((r).iport_table[1] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56218_A0_IPORT_TABLEm_MY_MODIDf_GET(r) ((((r).iport_table[1]) >> 7) & 0xf)
#define BCM56218_A0_IPORT_TABLEm_MY_MODIDf_SET(r,f) (r).iport_table[1]=(((r).iport_table[1] & ~((uint32_t)0xf << 7)) | ((((uint32_t)f) & 0xf) << 7))
#define BCM56218_A0_IPORT_TABLEm_OUTER_TPIDf_GET(r) ((((r).iport_table[1]) >> 11) & 0xffff)
#define BCM56218_A0_IPORT_TABLEm_OUTER_TPIDf_SET(r,f) (r).iport_table[1]=(((r).iport_table[1] & ~((uint32_t)0xffff << 11)) | ((((uint32_t)f) & 0xffff) << 11))
#define BCM56218_A0_IPORT_TABLEm_VLAN_PRECEDENCEf_GET(r) ((((r).iport_table[1]) >> 27) & 0x1)
#define BCM56218_A0_IPORT_TABLEm_VLAN_PRECEDENCEf_SET(r,f) (r).iport_table[1]=(((r).iport_table[1] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM56218_A0_IPORT_TABLEm_PORT_BRIDGEf_GET(r) ((((r).iport_table[1]) >> 28) & 0x1)
#define BCM56218_A0_IPORT_TABLEm_PORT_BRIDGEf_SET(r,f) (r).iport_table[1]=(((r).iport_table[1] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM56218_A0_IPORT_TABLEm_MODPORT_TABLE_SELf_GET(r) ((((r).iport_table[1]) >> 29) & 0x3)
#define BCM56218_A0_IPORT_TABLEm_MODPORT_TABLE_SELf_SET(r,f) (r).iport_table[1]=(((r).iport_table[1] & ~((uint32_t)0x3 << 29)) | ((((uint32_t)f) & 0x3) << 29))
#define BCM56218_A0_IPORT_TABLEm_IGNORE_MODID_LKUPSf_GET(r) ((((r).iport_table[1]) >> 31) & 0x1)
#define BCM56218_A0_IPORT_TABLEm_IGNORE_MODID_LKUPSf_SET(r,f) (r).iport_table[1]=(((r).iport_table[1] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM56218_A0_IPORT_TABLEm_REMOVE_HG_HDR_SRC_PORTf_GET(r) (((r).iport_table[2]) & 0x1)
#define BCM56218_A0_IPORT_TABLEm_REMOVE_HG_HDR_SRC_PORTf_SET(r,f) (r).iport_table[2]=(((r).iport_table[2] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_IPORT_TABLEm_ALLOW_SRC_MODf_GET(r) ((((r).iport_table[2]) >> 1) & 0x1)
#define BCM56218_A0_IPORT_TABLEm_ALLOW_SRC_MODf_SET(r,f) (r).iport_table[2]=(((r).iport_table[2] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access IPORT_TABLE.
 *
 */
#define BCM56218_A0_READ_IPORT_TABLEm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_IPORT_TABLEm,i,(m._iport_table),3)
#define BCM56218_A0_WRITE_IPORT_TABLEm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_IPORT_TABLEm,i,&(m._iport_table),3)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IPORT_TABLEm BCM56218_A0_IPORT_TABLEm
#define IPORT_TABLEm_MIN BCM56218_A0_IPORT_TABLEm_MIN
#define IPORT_TABLEm_MAX BCM56218_A0_IPORT_TABLEm_MAX
#define IPORT_TABLEm_CMAX(u) BCM56218_A0_IPORT_TABLEm_CMAX(u)
#define IPORT_TABLEm_SIZE BCM56218_A0_IPORT_TABLEm_SIZE
typedef BCM56218_A0_IPORT_TABLEm_t IPORT_TABLEm_t;
#define IPORT_TABLEm_CLR BCM56218_A0_IPORT_TABLEm_CLR
#define IPORT_TABLEm_SET BCM56218_A0_IPORT_TABLEm_SET
#define IPORT_TABLEm_GET BCM56218_A0_IPORT_TABLEm_GET
#define IPORT_TABLEm_FILTER_ENABLEf_GET BCM56218_A0_IPORT_TABLEm_FILTER_ENABLEf_GET
#define IPORT_TABLEm_FILTER_ENABLEf_SET BCM56218_A0_IPORT_TABLEm_FILTER_ENABLEf_SET
#define IPORT_TABLEm_RESERVED0f_GET BCM56218_A0_IPORT_TABLEm_RESERVED0f_GET
#define IPORT_TABLEm_RESERVED0f_SET BCM56218_A0_IPORT_TABLEm_RESERVED0f_SET
#define IPORT_TABLEm_RESERVED1f_GET BCM56218_A0_IPORT_TABLEm_RESERVED1f_GET
#define IPORT_TABLEm_RESERVED1f_SET BCM56218_A0_IPORT_TABLEm_RESERVED1f_SET
#define IPORT_TABLEm_TRUST_DSCP_V4f_GET BCM56218_A0_IPORT_TABLEm_TRUST_DSCP_V4f_GET
#define IPORT_TABLEm_TRUST_DSCP_V4f_SET BCM56218_A0_IPORT_TABLEm_TRUST_DSCP_V4f_SET
#define IPORT_TABLEm_TRUST_DSCP_V6f_GET BCM56218_A0_IPORT_TABLEm_TRUST_DSCP_V6f_GET
#define IPORT_TABLEm_TRUST_DSCP_V6f_SET BCM56218_A0_IPORT_TABLEm_TRUST_DSCP_V6f_SET
#define IPORT_TABLEm_EN_IFILTERf_GET BCM56218_A0_IPORT_TABLEm_EN_IFILTERf_GET
#define IPORT_TABLEm_EN_IFILTERf_SET BCM56218_A0_IPORT_TABLEm_EN_IFILTERf_SET
#define IPORT_TABLEm_MIRRORf_GET BCM56218_A0_IPORT_TABLEm_MIRRORf_GET
#define IPORT_TABLEm_MIRRORf_SET BCM56218_A0_IPORT_TABLEm_MIRRORf_SET
#define IPORT_TABLEm_CMLf_GET BCM56218_A0_IPORT_TABLEm_CMLf_GET
#define IPORT_TABLEm_CMLf_SET BCM56218_A0_IPORT_TABLEm_CMLf_SET
#define IPORT_TABLEm_PORT_PRIf_GET BCM56218_A0_IPORT_TABLEm_PORT_PRIf_GET
#define IPORT_TABLEm_PORT_PRIf_SET BCM56218_A0_IPORT_TABLEm_PORT_PRIf_SET
#define IPORT_TABLEm_RESERVED2f_GET BCM56218_A0_IPORT_TABLEm_RESERVED2f_GET
#define IPORT_TABLEm_RESERVED2f_SET BCM56218_A0_IPORT_TABLEm_RESERVED2f_SET
#define IPORT_TABLEm_RESERVED3f_GET BCM56218_A0_IPORT_TABLEm_RESERVED3f_GET
#define IPORT_TABLEm_RESERVED3f_SET BCM56218_A0_IPORT_TABLEm_RESERVED3f_SET
#define IPORT_TABLEm_RESERVED4f_GET BCM56218_A0_IPORT_TABLEm_RESERVED4f_GET
#define IPORT_TABLEm_RESERVED4f_SET BCM56218_A0_IPORT_TABLEm_RESERVED4f_SET
#define IPORT_TABLEm_V6L3_ENABLEf_GET BCM56218_A0_IPORT_TABLEm_V6L3_ENABLEf_GET
#define IPORT_TABLEm_V6L3_ENABLEf_SET BCM56218_A0_IPORT_TABLEm_V6L3_ENABLEf_SET
#define IPORT_TABLEm_V4L3_ENABLEf_GET BCM56218_A0_IPORT_TABLEm_V4L3_ENABLEf_GET
#define IPORT_TABLEm_V4L3_ENABLEf_SET BCM56218_A0_IPORT_TABLEm_V4L3_ENABLEf_SET
#define IPORT_TABLEm_DROP_BPDUf_GET BCM56218_A0_IPORT_TABLEm_DROP_BPDUf_GET
#define IPORT_TABLEm_DROP_BPDUf_SET BCM56218_A0_IPORT_TABLEm_DROP_BPDUf_SET
#define IPORT_TABLEm_PORT_DIS_TAGf_GET BCM56218_A0_IPORT_TABLEm_PORT_DIS_TAGf_GET
#define IPORT_TABLEm_PORT_DIS_TAGf_SET BCM56218_A0_IPORT_TABLEm_PORT_DIS_TAGf_SET
#define IPORT_TABLEm_PORT_DIS_UNTAGf_GET BCM56218_A0_IPORT_TABLEm_PORT_DIS_UNTAGf_GET
#define IPORT_TABLEm_PORT_DIS_UNTAGf_SET BCM56218_A0_IPORT_TABLEm_PORT_DIS_UNTAGf_SET
#define IPORT_TABLEm_PASS_CONTROL_FRAMESf_GET BCM56218_A0_IPORT_TABLEm_PASS_CONTROL_FRAMESf_GET
#define IPORT_TABLEm_PASS_CONTROL_FRAMESf_SET BCM56218_A0_IPORT_TABLEm_PASS_CONTROL_FRAMESf_SET
#define IPORT_TABLEm_SUBNET_BASED_VID_ENABLEf_GET BCM56218_A0_IPORT_TABLEm_SUBNET_BASED_VID_ENABLEf_GET
#define IPORT_TABLEm_SUBNET_BASED_VID_ENABLEf_SET BCM56218_A0_IPORT_TABLEm_SUBNET_BASED_VID_ENABLEf_SET
#define IPORT_TABLEm_MAC_BASED_VID_ENABLEf_GET BCM56218_A0_IPORT_TABLEm_MAC_BASED_VID_ENABLEf_GET
#define IPORT_TABLEm_MAC_BASED_VID_ENABLEf_SET BCM56218_A0_IPORT_TABLEm_MAC_BASED_VID_ENABLEf_SET
#define IPORT_TABLEm_PORT_VIDf_GET BCM56218_A0_IPORT_TABLEm_PORT_VIDf_GET
#define IPORT_TABLEm_PORT_VIDf_SET BCM56218_A0_IPORT_TABLEm_PORT_VIDf_SET
#define IPORT_TABLEm_HIGIG_PACKETf_GET BCM56218_A0_IPORT_TABLEm_HIGIG_PACKETf_GET
#define IPORT_TABLEm_HIGIG_PACKETf_SET BCM56218_A0_IPORT_TABLEm_HIGIG_PACKETf_SET
#define IPORT_TABLEm_NNI_PORTf_GET BCM56218_A0_IPORT_TABLEm_NNI_PORTf_GET
#define IPORT_TABLEm_NNI_PORTf_SET BCM56218_A0_IPORT_TABLEm_NNI_PORTf_SET
#define IPORT_TABLEm_MAP_TAG_PKT_PRIORITYf_GET BCM56218_A0_IPORT_TABLEm_MAP_TAG_PKT_PRIORITYf_GET
#define IPORT_TABLEm_MAP_TAG_PKT_PRIORITYf_SET BCM56218_A0_IPORT_TABLEm_MAP_TAG_PKT_PRIORITYf_SET
#define IPORT_TABLEm_MY_MODIDf_GET BCM56218_A0_IPORT_TABLEm_MY_MODIDf_GET
#define IPORT_TABLEm_MY_MODIDf_SET BCM56218_A0_IPORT_TABLEm_MY_MODIDf_SET
#define IPORT_TABLEm_OUTER_TPIDf_GET BCM56218_A0_IPORT_TABLEm_OUTER_TPIDf_GET
#define IPORT_TABLEm_OUTER_TPIDf_SET BCM56218_A0_IPORT_TABLEm_OUTER_TPIDf_SET
#define IPORT_TABLEm_VLAN_PRECEDENCEf_GET BCM56218_A0_IPORT_TABLEm_VLAN_PRECEDENCEf_GET
#define IPORT_TABLEm_VLAN_PRECEDENCEf_SET BCM56218_A0_IPORT_TABLEm_VLAN_PRECEDENCEf_SET
#define IPORT_TABLEm_PORT_BRIDGEf_GET BCM56218_A0_IPORT_TABLEm_PORT_BRIDGEf_GET
#define IPORT_TABLEm_PORT_BRIDGEf_SET BCM56218_A0_IPORT_TABLEm_PORT_BRIDGEf_SET
#define IPORT_TABLEm_MODPORT_TABLE_SELf_GET BCM56218_A0_IPORT_TABLEm_MODPORT_TABLE_SELf_GET
#define IPORT_TABLEm_MODPORT_TABLE_SELf_SET BCM56218_A0_IPORT_TABLEm_MODPORT_TABLE_SELf_SET
#define IPORT_TABLEm_IGNORE_MODID_LKUPSf_GET BCM56218_A0_IPORT_TABLEm_IGNORE_MODID_LKUPSf_GET
#define IPORT_TABLEm_IGNORE_MODID_LKUPSf_SET BCM56218_A0_IPORT_TABLEm_IGNORE_MODID_LKUPSf_SET
#define IPORT_TABLEm_REMOVE_HG_HDR_SRC_PORTf_GET BCM56218_A0_IPORT_TABLEm_REMOVE_HG_HDR_SRC_PORTf_GET
#define IPORT_TABLEm_REMOVE_HG_HDR_SRC_PORTf_SET BCM56218_A0_IPORT_TABLEm_REMOVE_HG_HDR_SRC_PORTf_SET
#define IPORT_TABLEm_ALLOW_SRC_MODf_GET BCM56218_A0_IPORT_TABLEm_ALLOW_SRC_MODf_GET
#define IPORT_TABLEm_ALLOW_SRC_MODf_SET BCM56218_A0_IPORT_TABLEm_ALLOW_SRC_MODf_SET
#define READ_IPORT_TABLEm BCM56218_A0_READ_IPORT_TABLEm
#define WRITE_IPORT_TABLEm BCM56218_A0_WRITE_IPORT_TABLEm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_IPORT_TABLEm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  IUNKNOWN_MCAST_BLOCK_MASK
 * BLOCKS:   IPIPE_HI
 * DESC:     Unknown Multicast Block Mask - Lower Bitmap
 * SIZE:     32
 * FIELDS:
 *     BLK_BITMAP       Bitmap of ports to be blocked
 *
 ******************************************************************************/
#define BCM56218_A0_IUNKNOWN_MCAST_BLOCK_MASKr 0x0e800102

#define BCM56218_A0_IUNKNOWN_MCAST_BLOCK_MASKr_SIZE 4

/*
 * This structure should be used to declare and program IUNKNOWN_MCAST_BLOCK_MASK.
 *
 */
typedef union BCM56218_A0_IUNKNOWN_MCAST_BLOCK_MASKr_s {
	uint32_t v[1];
	uint32_t iunknown_mcast_block_mask[1];
	uint32_t _iunknown_mcast_block_mask;
} BCM56218_A0_IUNKNOWN_MCAST_BLOCK_MASKr_t;

#define BCM56218_A0_IUNKNOWN_MCAST_BLOCK_MASKr_CLR(r) (r).iunknown_mcast_block_mask[0] = 0
#define BCM56218_A0_IUNKNOWN_MCAST_BLOCK_MASKr_SET(r,d) (r).iunknown_mcast_block_mask[0] = d
#define BCM56218_A0_IUNKNOWN_MCAST_BLOCK_MASKr_GET(r) (r).iunknown_mcast_block_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_IUNKNOWN_MCAST_BLOCK_MASKr_BLK_BITMAPf_GET(r) ((r).iunknown_mcast_block_mask[0])
#define BCM56218_A0_IUNKNOWN_MCAST_BLOCK_MASKr_BLK_BITMAPf_SET(r,f) (r).iunknown_mcast_block_mask[0]=((uint32_t)f)

/*
 * These macros can be used to access IUNKNOWN_MCAST_BLOCK_MASK.
 *
 */
#define BCM56218_A0_READ_IUNKNOWN_MCAST_BLOCK_MASKr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_IUNKNOWN_MCAST_BLOCK_MASKr,(r._iunknown_mcast_block_mask))
#define BCM56218_A0_WRITE_IUNKNOWN_MCAST_BLOCK_MASKr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_IUNKNOWN_MCAST_BLOCK_MASKr,&(r._iunknown_mcast_block_mask))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IUNKNOWN_MCAST_BLOCK_MASKr BCM56218_A0_IUNKNOWN_MCAST_BLOCK_MASKr
#define IUNKNOWN_MCAST_BLOCK_MASKr_SIZE BCM56218_A0_IUNKNOWN_MCAST_BLOCK_MASKr_SIZE
typedef BCM56218_A0_IUNKNOWN_MCAST_BLOCK_MASKr_t IUNKNOWN_MCAST_BLOCK_MASKr_t;
#define IUNKNOWN_MCAST_BLOCK_MASKr_CLR BCM56218_A0_IUNKNOWN_MCAST_BLOCK_MASKr_CLR
#define IUNKNOWN_MCAST_BLOCK_MASKr_SET BCM56218_A0_IUNKNOWN_MCAST_BLOCK_MASKr_SET
#define IUNKNOWN_MCAST_BLOCK_MASKr_GET BCM56218_A0_IUNKNOWN_MCAST_BLOCK_MASKr_GET
#define IUNKNOWN_MCAST_BLOCK_MASKr_BLK_BITMAPf_GET BCM56218_A0_IUNKNOWN_MCAST_BLOCK_MASKr_BLK_BITMAPf_GET
#define IUNKNOWN_MCAST_BLOCK_MASKr_BLK_BITMAPf_SET BCM56218_A0_IUNKNOWN_MCAST_BLOCK_MASKr_BLK_BITMAPf_SET
#define READ_IUNKNOWN_MCAST_BLOCK_MASKr BCM56218_A0_READ_IUNKNOWN_MCAST_BLOCK_MASKr
#define WRITE_IUNKNOWN_MCAST_BLOCK_MASKr BCM56218_A0_WRITE_IUNKNOWN_MCAST_BLOCK_MASKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_IUNKNOWN_MCAST_BLOCK_MASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  IUNKNOWN_MCAST_BLOCK_MASK_HI
 * BLOCKS:   IPIPE_HI
 * DESC:     Unknown Multicast Block Mask - Upper Bitmap
 * SIZE:     32
 * FIELDS:
 *     BLK_BITMAP       Bitmap of ports to be blocked
 *
 ******************************************************************************/
#define BCM56218_A0_IUNKNOWN_MCAST_BLOCK_MASK_HIr 0x0e800103

#define BCM56218_A0_IUNKNOWN_MCAST_BLOCK_MASK_HIr_SIZE 4

/*
 * This structure should be used to declare and program IUNKNOWN_MCAST_BLOCK_MASK_HI.
 *
 */
typedef union BCM56218_A0_IUNKNOWN_MCAST_BLOCK_MASK_HIr_s {
	uint32_t v[1];
	uint32_t iunknown_mcast_block_mask_hi[1];
	uint32_t _iunknown_mcast_block_mask_hi;
} BCM56218_A0_IUNKNOWN_MCAST_BLOCK_MASK_HIr_t;

#define BCM56218_A0_IUNKNOWN_MCAST_BLOCK_MASK_HIr_CLR(r) (r).iunknown_mcast_block_mask_hi[0] = 0
#define BCM56218_A0_IUNKNOWN_MCAST_BLOCK_MASK_HIr_SET(r,d) (r).iunknown_mcast_block_mask_hi[0] = d
#define BCM56218_A0_IUNKNOWN_MCAST_BLOCK_MASK_HIr_GET(r) (r).iunknown_mcast_block_mask_hi[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_IUNKNOWN_MCAST_BLOCK_MASK_HIr_BLK_BITMAPf_GET(r) (((r).iunknown_mcast_block_mask_hi[0]) & 0x3fffff)
#define BCM56218_A0_IUNKNOWN_MCAST_BLOCK_MASK_HIr_BLK_BITMAPf_SET(r,f) (r).iunknown_mcast_block_mask_hi[0]=(((r).iunknown_mcast_block_mask_hi[0] & ~((uint32_t)0x3fffff)) | (((uint32_t)f) & 0x3fffff))

/*
 * These macros can be used to access IUNKNOWN_MCAST_BLOCK_MASK_HI.
 *
 */
#define BCM56218_A0_READ_IUNKNOWN_MCAST_BLOCK_MASK_HIr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_IUNKNOWN_MCAST_BLOCK_MASK_HIr,(r._iunknown_mcast_block_mask_hi))
#define BCM56218_A0_WRITE_IUNKNOWN_MCAST_BLOCK_MASK_HIr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_IUNKNOWN_MCAST_BLOCK_MASK_HIr,&(r._iunknown_mcast_block_mask_hi))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IUNKNOWN_MCAST_BLOCK_MASK_HIr BCM56218_A0_IUNKNOWN_MCAST_BLOCK_MASK_HIr
#define IUNKNOWN_MCAST_BLOCK_MASK_HIr_SIZE BCM56218_A0_IUNKNOWN_MCAST_BLOCK_MASK_HIr_SIZE
typedef BCM56218_A0_IUNKNOWN_MCAST_BLOCK_MASK_HIr_t IUNKNOWN_MCAST_BLOCK_MASK_HIr_t;
#define IUNKNOWN_MCAST_BLOCK_MASK_HIr_CLR BCM56218_A0_IUNKNOWN_MCAST_BLOCK_MASK_HIr_CLR
#define IUNKNOWN_MCAST_BLOCK_MASK_HIr_SET BCM56218_A0_IUNKNOWN_MCAST_BLOCK_MASK_HIr_SET
#define IUNKNOWN_MCAST_BLOCK_MASK_HIr_GET BCM56218_A0_IUNKNOWN_MCAST_BLOCK_MASK_HIr_GET
#define IUNKNOWN_MCAST_BLOCK_MASK_HIr_BLK_BITMAPf_GET BCM56218_A0_IUNKNOWN_MCAST_BLOCK_MASK_HIr_BLK_BITMAPf_GET
#define IUNKNOWN_MCAST_BLOCK_MASK_HIr_BLK_BITMAPf_SET BCM56218_A0_IUNKNOWN_MCAST_BLOCK_MASK_HIr_BLK_BITMAPf_SET
#define READ_IUNKNOWN_MCAST_BLOCK_MASK_HIr BCM56218_A0_READ_IUNKNOWN_MCAST_BLOCK_MASK_HIr
#define WRITE_IUNKNOWN_MCAST_BLOCK_MASK_HIr BCM56218_A0_WRITE_IUNKNOWN_MCAST_BLOCK_MASK_HIr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_IUNKNOWN_MCAST_BLOCK_MASK_HIr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  IUNKNOWN_OPCODE
 * BLOCKS:   IPIPE_HI
 * DESC:     To pick the Port bitmap, in case a pkt with unknown opcode is received. 
 * SIZE:     32
 * FIELDS:
 *     UNKNOWN_OPCODE_BITMAP Lower Bitmap.
 *
 ******************************************************************************/
#define BCM56218_A0_IUNKNOWN_OPCODEr 0x01800009

#define BCM56218_A0_IUNKNOWN_OPCODEr_SIZE 4

/*
 * This structure should be used to declare and program IUNKNOWN_OPCODE.
 *
 */
typedef union BCM56218_A0_IUNKNOWN_OPCODEr_s {
	uint32_t v[1];
	uint32_t iunknown_opcode[1];
	uint32_t _iunknown_opcode;
} BCM56218_A0_IUNKNOWN_OPCODEr_t;

#define BCM56218_A0_IUNKNOWN_OPCODEr_CLR(r) (r).iunknown_opcode[0] = 0
#define BCM56218_A0_IUNKNOWN_OPCODEr_SET(r,d) (r).iunknown_opcode[0] = d
#define BCM56218_A0_IUNKNOWN_OPCODEr_GET(r) (r).iunknown_opcode[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_IUNKNOWN_OPCODEr_UNKNOWN_OPCODE_BITMAPf_GET(r) ((r).iunknown_opcode[0])
#define BCM56218_A0_IUNKNOWN_OPCODEr_UNKNOWN_OPCODE_BITMAPf_SET(r,f) (r).iunknown_opcode[0]=((uint32_t)f)

/*
 * These macros can be used to access IUNKNOWN_OPCODE.
 *
 */
#define BCM56218_A0_READ_IUNKNOWN_OPCODEr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_IUNKNOWN_OPCODEr,(r._iunknown_opcode))
#define BCM56218_A0_WRITE_IUNKNOWN_OPCODEr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_IUNKNOWN_OPCODEr,&(r._iunknown_opcode))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IUNKNOWN_OPCODEr BCM56218_A0_IUNKNOWN_OPCODEr
#define IUNKNOWN_OPCODEr_SIZE BCM56218_A0_IUNKNOWN_OPCODEr_SIZE
typedef BCM56218_A0_IUNKNOWN_OPCODEr_t IUNKNOWN_OPCODEr_t;
#define IUNKNOWN_OPCODEr_CLR BCM56218_A0_IUNKNOWN_OPCODEr_CLR
#define IUNKNOWN_OPCODEr_SET BCM56218_A0_IUNKNOWN_OPCODEr_SET
#define IUNKNOWN_OPCODEr_GET BCM56218_A0_IUNKNOWN_OPCODEr_GET
#define IUNKNOWN_OPCODEr_UNKNOWN_OPCODE_BITMAPf_GET BCM56218_A0_IUNKNOWN_OPCODEr_UNKNOWN_OPCODE_BITMAPf_GET
#define IUNKNOWN_OPCODEr_UNKNOWN_OPCODE_BITMAPf_SET BCM56218_A0_IUNKNOWN_OPCODEr_UNKNOWN_OPCODE_BITMAPf_SET
#define READ_IUNKNOWN_OPCODEr BCM56218_A0_READ_IUNKNOWN_OPCODEr
#define WRITE_IUNKNOWN_OPCODEr BCM56218_A0_WRITE_IUNKNOWN_OPCODEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_IUNKNOWN_OPCODEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  IUNKNOWN_OPCODE_HI
 * BLOCKS:   IPIPE_HI
 * DESC:     Upper Bitmap. To pick the Port bitmap, in case a pkt with unknown opcode is received. 
 * SIZE:     32
 * FIELDS:
 *     UNKNOWN_OPCODE_BITMAP Upper Bitmap.
 *
 ******************************************************************************/
#define BCM56218_A0_IUNKNOWN_OPCODE_HIr 0x0180000a

#define BCM56218_A0_IUNKNOWN_OPCODE_HIr_SIZE 4

/*
 * This structure should be used to declare and program IUNKNOWN_OPCODE_HI.
 *
 */
typedef union BCM56218_A0_IUNKNOWN_OPCODE_HIr_s {
	uint32_t v[1];
	uint32_t iunknown_opcode_hi[1];
	uint32_t _iunknown_opcode_hi;
} BCM56218_A0_IUNKNOWN_OPCODE_HIr_t;

#define BCM56218_A0_IUNKNOWN_OPCODE_HIr_CLR(r) (r).iunknown_opcode_hi[0] = 0
#define BCM56218_A0_IUNKNOWN_OPCODE_HIr_SET(r,d) (r).iunknown_opcode_hi[0] = d
#define BCM56218_A0_IUNKNOWN_OPCODE_HIr_GET(r) (r).iunknown_opcode_hi[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_IUNKNOWN_OPCODE_HIr_UNKNOWN_OPCODE_BITMAPf_GET(r) (((r).iunknown_opcode_hi[0]) & 0x3fffff)
#define BCM56218_A0_IUNKNOWN_OPCODE_HIr_UNKNOWN_OPCODE_BITMAPf_SET(r,f) (r).iunknown_opcode_hi[0]=(((r).iunknown_opcode_hi[0] & ~((uint32_t)0x3fffff)) | (((uint32_t)f) & 0x3fffff))

/*
 * These macros can be used to access IUNKNOWN_OPCODE_HI.
 *
 */
#define BCM56218_A0_READ_IUNKNOWN_OPCODE_HIr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_IUNKNOWN_OPCODE_HIr,(r._iunknown_opcode_hi))
#define BCM56218_A0_WRITE_IUNKNOWN_OPCODE_HIr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_IUNKNOWN_OPCODE_HIr,&(r._iunknown_opcode_hi))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IUNKNOWN_OPCODE_HIr BCM56218_A0_IUNKNOWN_OPCODE_HIr
#define IUNKNOWN_OPCODE_HIr_SIZE BCM56218_A0_IUNKNOWN_OPCODE_HIr_SIZE
typedef BCM56218_A0_IUNKNOWN_OPCODE_HIr_t IUNKNOWN_OPCODE_HIr_t;
#define IUNKNOWN_OPCODE_HIr_CLR BCM56218_A0_IUNKNOWN_OPCODE_HIr_CLR
#define IUNKNOWN_OPCODE_HIr_SET BCM56218_A0_IUNKNOWN_OPCODE_HIr_SET
#define IUNKNOWN_OPCODE_HIr_GET BCM56218_A0_IUNKNOWN_OPCODE_HIr_GET
#define IUNKNOWN_OPCODE_HIr_UNKNOWN_OPCODE_BITMAPf_GET BCM56218_A0_IUNKNOWN_OPCODE_HIr_UNKNOWN_OPCODE_BITMAPf_GET
#define IUNKNOWN_OPCODE_HIr_UNKNOWN_OPCODE_BITMAPf_SET BCM56218_A0_IUNKNOWN_OPCODE_HIr_UNKNOWN_OPCODE_BITMAPf_SET
#define READ_IUNKNOWN_OPCODE_HIr BCM56218_A0_READ_IUNKNOWN_OPCODE_HIr
#define WRITE_IUNKNOWN_OPCODE_HIr BCM56218_A0_WRITE_IUNKNOWN_OPCODE_HIr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_IUNKNOWN_OPCODE_HIr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  IUNKNOWN_UCAST_BLOCK_MASK
 * BLOCKS:   IPIPE_HI
 * DESC:     Unknown Unicast Block Mask - Lower Bitmap
 * SIZE:     32
 * FIELDS:
 *     BLK_BITMAP       Bitmap of ports to be blocked
 *
 ******************************************************************************/
#define BCM56218_A0_IUNKNOWN_UCAST_BLOCK_MASKr 0x0e800100

#define BCM56218_A0_IUNKNOWN_UCAST_BLOCK_MASKr_SIZE 4

/*
 * This structure should be used to declare and program IUNKNOWN_UCAST_BLOCK_MASK.
 *
 */
typedef union BCM56218_A0_IUNKNOWN_UCAST_BLOCK_MASKr_s {
	uint32_t v[1];
	uint32_t iunknown_ucast_block_mask[1];
	uint32_t _iunknown_ucast_block_mask;
} BCM56218_A0_IUNKNOWN_UCAST_BLOCK_MASKr_t;

#define BCM56218_A0_IUNKNOWN_UCAST_BLOCK_MASKr_CLR(r) (r).iunknown_ucast_block_mask[0] = 0
#define BCM56218_A0_IUNKNOWN_UCAST_BLOCK_MASKr_SET(r,d) (r).iunknown_ucast_block_mask[0] = d
#define BCM56218_A0_IUNKNOWN_UCAST_BLOCK_MASKr_GET(r) (r).iunknown_ucast_block_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_IUNKNOWN_UCAST_BLOCK_MASKr_BLK_BITMAPf_GET(r) ((r).iunknown_ucast_block_mask[0])
#define BCM56218_A0_IUNKNOWN_UCAST_BLOCK_MASKr_BLK_BITMAPf_SET(r,f) (r).iunknown_ucast_block_mask[0]=((uint32_t)f)

/*
 * These macros can be used to access IUNKNOWN_UCAST_BLOCK_MASK.
 *
 */
#define BCM56218_A0_READ_IUNKNOWN_UCAST_BLOCK_MASKr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_IUNKNOWN_UCAST_BLOCK_MASKr,(r._iunknown_ucast_block_mask))
#define BCM56218_A0_WRITE_IUNKNOWN_UCAST_BLOCK_MASKr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_IUNKNOWN_UCAST_BLOCK_MASKr,&(r._iunknown_ucast_block_mask))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IUNKNOWN_UCAST_BLOCK_MASKr BCM56218_A0_IUNKNOWN_UCAST_BLOCK_MASKr
#define IUNKNOWN_UCAST_BLOCK_MASKr_SIZE BCM56218_A0_IUNKNOWN_UCAST_BLOCK_MASKr_SIZE
typedef BCM56218_A0_IUNKNOWN_UCAST_BLOCK_MASKr_t IUNKNOWN_UCAST_BLOCK_MASKr_t;
#define IUNKNOWN_UCAST_BLOCK_MASKr_CLR BCM56218_A0_IUNKNOWN_UCAST_BLOCK_MASKr_CLR
#define IUNKNOWN_UCAST_BLOCK_MASKr_SET BCM56218_A0_IUNKNOWN_UCAST_BLOCK_MASKr_SET
#define IUNKNOWN_UCAST_BLOCK_MASKr_GET BCM56218_A0_IUNKNOWN_UCAST_BLOCK_MASKr_GET
#define IUNKNOWN_UCAST_BLOCK_MASKr_BLK_BITMAPf_GET BCM56218_A0_IUNKNOWN_UCAST_BLOCK_MASKr_BLK_BITMAPf_GET
#define IUNKNOWN_UCAST_BLOCK_MASKr_BLK_BITMAPf_SET BCM56218_A0_IUNKNOWN_UCAST_BLOCK_MASKr_BLK_BITMAPf_SET
#define READ_IUNKNOWN_UCAST_BLOCK_MASKr BCM56218_A0_READ_IUNKNOWN_UCAST_BLOCK_MASKr
#define WRITE_IUNKNOWN_UCAST_BLOCK_MASKr BCM56218_A0_WRITE_IUNKNOWN_UCAST_BLOCK_MASKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_IUNKNOWN_UCAST_BLOCK_MASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  IUNKNOWN_UCAST_BLOCK_MASK_HI
 * BLOCKS:   IPIPE_HI
 * DESC:     Unknown Unicast Block Mask - Upper Bitmap
 * SIZE:     32
 * FIELDS:
 *     BLK_BITMAP       Bitmap of ports to be blocked
 *
 ******************************************************************************/
#define BCM56218_A0_IUNKNOWN_UCAST_BLOCK_MASK_HIr 0x0e800101

#define BCM56218_A0_IUNKNOWN_UCAST_BLOCK_MASK_HIr_SIZE 4

/*
 * This structure should be used to declare and program IUNKNOWN_UCAST_BLOCK_MASK_HI.
 *
 */
typedef union BCM56218_A0_IUNKNOWN_UCAST_BLOCK_MASK_HIr_s {
	uint32_t v[1];
	uint32_t iunknown_ucast_block_mask_hi[1];
	uint32_t _iunknown_ucast_block_mask_hi;
} BCM56218_A0_IUNKNOWN_UCAST_BLOCK_MASK_HIr_t;

#define BCM56218_A0_IUNKNOWN_UCAST_BLOCK_MASK_HIr_CLR(r) (r).iunknown_ucast_block_mask_hi[0] = 0
#define BCM56218_A0_IUNKNOWN_UCAST_BLOCK_MASK_HIr_SET(r,d) (r).iunknown_ucast_block_mask_hi[0] = d
#define BCM56218_A0_IUNKNOWN_UCAST_BLOCK_MASK_HIr_GET(r) (r).iunknown_ucast_block_mask_hi[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_IUNKNOWN_UCAST_BLOCK_MASK_HIr_BLK_BITMAPf_GET(r) (((r).iunknown_ucast_block_mask_hi[0]) & 0x3fffff)
#define BCM56218_A0_IUNKNOWN_UCAST_BLOCK_MASK_HIr_BLK_BITMAPf_SET(r,f) (r).iunknown_ucast_block_mask_hi[0]=(((r).iunknown_ucast_block_mask_hi[0] & ~((uint32_t)0x3fffff)) | (((uint32_t)f) & 0x3fffff))

/*
 * These macros can be used to access IUNKNOWN_UCAST_BLOCK_MASK_HI.
 *
 */
#define BCM56218_A0_READ_IUNKNOWN_UCAST_BLOCK_MASK_HIr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_IUNKNOWN_UCAST_BLOCK_MASK_HIr,(r._iunknown_ucast_block_mask_hi))
#define BCM56218_A0_WRITE_IUNKNOWN_UCAST_BLOCK_MASK_HIr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_IUNKNOWN_UCAST_BLOCK_MASK_HIr,&(r._iunknown_ucast_block_mask_hi))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IUNKNOWN_UCAST_BLOCK_MASK_HIr BCM56218_A0_IUNKNOWN_UCAST_BLOCK_MASK_HIr
#define IUNKNOWN_UCAST_BLOCK_MASK_HIr_SIZE BCM56218_A0_IUNKNOWN_UCAST_BLOCK_MASK_HIr_SIZE
typedef BCM56218_A0_IUNKNOWN_UCAST_BLOCK_MASK_HIr_t IUNKNOWN_UCAST_BLOCK_MASK_HIr_t;
#define IUNKNOWN_UCAST_BLOCK_MASK_HIr_CLR BCM56218_A0_IUNKNOWN_UCAST_BLOCK_MASK_HIr_CLR
#define IUNKNOWN_UCAST_BLOCK_MASK_HIr_SET BCM56218_A0_IUNKNOWN_UCAST_BLOCK_MASK_HIr_SET
#define IUNKNOWN_UCAST_BLOCK_MASK_HIr_GET BCM56218_A0_IUNKNOWN_UCAST_BLOCK_MASK_HIr_GET
#define IUNKNOWN_UCAST_BLOCK_MASK_HIr_BLK_BITMAPf_GET BCM56218_A0_IUNKNOWN_UCAST_BLOCK_MASK_HIr_BLK_BITMAPf_GET
#define IUNKNOWN_UCAST_BLOCK_MASK_HIr_BLK_BITMAPf_SET BCM56218_A0_IUNKNOWN_UCAST_BLOCK_MASK_HIr_BLK_BITMAPf_SET
#define READ_IUNKNOWN_UCAST_BLOCK_MASK_HIr BCM56218_A0_READ_IUNKNOWN_UCAST_BLOCK_MASK_HIr
#define WRITE_IUNKNOWN_UCAST_BLOCK_MASK_HIr BCM56218_A0_WRITE_IUNKNOWN_UCAST_BLOCK_MASK_HIr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_IUNKNOWN_UCAST_BLOCK_MASK_HIr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  L2MC
 * BLOCKS:   IPIPE
 * DESC:     L2 Multicast table
 * SIZE:     55
 * FIELDS:
 *     PORT_BITMAP      Multicast port membership
 *     PORT_BITMAP_LO   Multicast port membership
 *     PORT_BITMAP_HI   Multicast port membership
 *     VALID            Indicates that the entry is valid
 *
 ******************************************************************************/
#define BCM56218_A0_L2MCm 0x07700000

#define BCM56218_A0_L2MCm_MIN 0
#define BCM56218_A0_L2MCm_MAX 255
#define BCM56218_A0_L2MCm_CMAX(u) 255
#define BCM56218_A0_L2MCm_SIZE 7

/*
 * This structure should be used to declare and program L2MC.
 *
 */
typedef union BCM56218_A0_L2MCm_s {
	uint32_t v[2];
	uint32_t l2mc[2];
	uint32_t _l2mc;
} BCM56218_A0_L2MCm_t;

#define BCM56218_A0_L2MCm_CLR(r) CDK_MEMSET(&((r)._l2mc), 0, sizeof(BCM56218_A0_L2MCm_t))
#define BCM56218_A0_L2MCm_SET(r,i,d) (r).l2mc[i] = d
#define BCM56218_A0_L2MCm_GET(r,i) (r).l2mc[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_L2MCm_PORT_BITMAPf_GET(r,a) cdk_field_get((r).l2mc,0,53,a)
#define BCM56218_A0_L2MCm_PORT_BITMAPf_SET(r,a) cdk_field_set((r).l2mc,0,53,a)
#define BCM56218_A0_L2MCm_PORT_BITMAP_LOf_GET(r) ((r).l2mc[0])
#define BCM56218_A0_L2MCm_PORT_BITMAP_LOf_SET(r,f) (r).l2mc[0]=((uint32_t)f)
#define BCM56218_A0_L2MCm_PORT_BITMAP_HIf_GET(r) (((r).l2mc[1]) & 0x3fffff)
#define BCM56218_A0_L2MCm_PORT_BITMAP_HIf_SET(r,f) (r).l2mc[1]=(((r).l2mc[1] & ~((uint32_t)0x3fffff)) | (((uint32_t)f) & 0x3fffff))
#define BCM56218_A0_L2MCm_VALIDf_GET(r) ((((r).l2mc[1]) >> 22) & 0x1)
#define BCM56218_A0_L2MCm_VALIDf_SET(r,f) (r).l2mc[1]=(((r).l2mc[1] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))

/*
 * These macros can be used to access L2MC.
 *
 */
#define BCM56218_A0_READ_L2MCm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_L2MCm,i,(m._l2mc),2)
#define BCM56218_A0_WRITE_L2MCm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_L2MCm,i,&(m._l2mc),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2MCm BCM56218_A0_L2MCm
#define L2MCm_MIN BCM56218_A0_L2MCm_MIN
#define L2MCm_MAX BCM56218_A0_L2MCm_MAX
#define L2MCm_CMAX(u) BCM56218_A0_L2MCm_CMAX(u)
#define L2MCm_SIZE BCM56218_A0_L2MCm_SIZE
typedef BCM56218_A0_L2MCm_t L2MCm_t;
#define L2MCm_CLR BCM56218_A0_L2MCm_CLR
#define L2MCm_SET BCM56218_A0_L2MCm_SET
#define L2MCm_GET BCM56218_A0_L2MCm_GET
#define L2MCm_PORT_BITMAPf_GET BCM56218_A0_L2MCm_PORT_BITMAPf_GET
#define L2MCm_PORT_BITMAPf_SET BCM56218_A0_L2MCm_PORT_BITMAPf_SET
#define L2MCm_PORT_BITMAP_LOf_GET BCM56218_A0_L2MCm_PORT_BITMAP_LOf_GET
#define L2MCm_PORT_BITMAP_LOf_SET BCM56218_A0_L2MCm_PORT_BITMAP_LOf_SET
#define L2MCm_PORT_BITMAP_HIf_GET BCM56218_A0_L2MCm_PORT_BITMAP_HIf_GET
#define L2MCm_PORT_BITMAP_HIf_SET BCM56218_A0_L2MCm_PORT_BITMAP_HIf_SET
#define L2MCm_VALIDf_GET BCM56218_A0_L2MCm_VALIDf_GET
#define L2MCm_VALIDf_SET BCM56218_A0_L2MCm_VALIDf_SET
#define READ_L2MCm BCM56218_A0_READ_L2MCm
#define WRITE_L2MCm BCM56218_A0_WRITE_L2MCm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_L2MCm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  L2X
 * BLOCKS:   IPIPE
 * DESC:     Combined HW managed L2 entry table.  Includes L2_ENTRY, L2_HITDA, and L2_HITSA
 * SIZE:     93
 * FIELDS:
 *     MAC_ADDR         MAC address
 *     VLAN_ID          VLAN ID
 *     PRI              Priority
 *     CPU              CPU bit
 *     DST_DISCARD      Dst Discard
 *     SRC_DISCARD      Src Discard
 *     SCP              SCP bit
 *     L2MC_PTR         Overlay of L2MC pointer (8 bits)
 *     PORT_TGID        Port or TGID
 *     TGID_PORT        Port or TGID - old Draco name
 *     TGID             TGID - old Draco name
 *     T                Trunk bit overlay(MSB of port_tgid)
 *     MODULE_ID        Module ID
 *     REMOTE_TRUNK     Remote Trunk bit indicates HiGig pkt with remote modid(MSB of module_id)
 *     L3               Indicates an L3 entry
 *     MAC_BLOCK_INDEX  MAC Block Index
 *     STATIC_BIT       Indicates entry is SW programmed and static
 *     RPE              RPE bit
 *     MIRROR           Mirror bit
 *     VALID            Indicates that the entry is valid
 *     SW_BIT           No hw functionality, excusilvely used by sw.
 *     EVEN_PARITY      Odd parity for the L2_ENTRY RAM fields (i.e. excludes HIT bits)
 *     HITDA            Dst hit update bit
 *     HITSA            Src hit update bit
 *
 ******************************************************************************/
#define BCM56218_A0_L2Xm 0x06700000

#define BCM56218_A0_L2Xm_MIN 0
#define BCM56218_A0_L2Xm_MAX 8191
#define BCM56218_A0_L2Xm_CMAX(u) 8191
#define BCM56218_A0_L2Xm_SIZE 12

/*
 * This structure should be used to declare and program L2X.
 *
 */
typedef union BCM56218_A0_L2Xm_s {
	uint32_t v[3];
	uint32_t l2x[3];
	uint32_t _l2x;
} BCM56218_A0_L2Xm_t;

#define BCM56218_A0_L2Xm_CLR(r) CDK_MEMSET(&((r)._l2x), 0, sizeof(BCM56218_A0_L2Xm_t))
#define BCM56218_A0_L2Xm_SET(r,i,d) (r).l2x[i] = d
#define BCM56218_A0_L2Xm_GET(r,i) (r).l2x[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_L2Xm_MAC_ADDRf_GET(r,a) cdk_field_get((r).l2x,0,47,a)
#define BCM56218_A0_L2Xm_MAC_ADDRf_SET(r,a) cdk_field_set((r).l2x,0,47,a)
#define BCM56218_A0_L2Xm_VLAN_IDf_GET(r) ((((r).l2x[1]) >> 16) & 0xfff)
#define BCM56218_A0_L2Xm_VLAN_IDf_SET(r,f) (r).l2x[1]=(((r).l2x[1] & ~((uint32_t)0xfff << 16)) | ((((uint32_t)f) & 0xfff) << 16))
#define BCM56218_A0_L2Xm_PRIf_GET(r) ((((r).l2x[1]) >> 28) & 0x7)
#define BCM56218_A0_L2Xm_PRIf_SET(r,f) (r).l2x[1]=(((r).l2x[1] & ~((uint32_t)0x7 << 28)) | ((((uint32_t)f) & 0x7) << 28))
#define BCM56218_A0_L2Xm_CPUf_GET(r) ((((r).l2x[1]) >> 31) & 0x1)
#define BCM56218_A0_L2Xm_CPUf_SET(r,f) (r).l2x[1]=(((r).l2x[1] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM56218_A0_L2Xm_DST_DISCARDf_GET(r) (((r).l2x[2]) & 0x1)
#define BCM56218_A0_L2Xm_DST_DISCARDf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_L2Xm_SRC_DISCARDf_GET(r) ((((r).l2x[2]) >> 1) & 0x1)
#define BCM56218_A0_L2Xm_SRC_DISCARDf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_L2Xm_SCPf_GET(r) ((((r).l2x[2]) >> 2) & 0x1)
#define BCM56218_A0_L2Xm_SCPf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_L2Xm_L2MC_PTRf_GET(r) ((((r).l2x[2]) >> 3) & 0xff)
#define BCM56218_A0_L2Xm_L2MC_PTRf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0xff << 3)) | ((((uint32_t)f) & 0xff) << 3))
#define BCM56218_A0_L2Xm_PORT_TGIDf_GET(r) ((((r).l2x[2]) >> 3) & 0x7f)
#define BCM56218_A0_L2Xm_PORT_TGIDf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x7f << 3)) | ((((uint32_t)f) & 0x7f) << 3))
#define BCM56218_A0_L2Xm_TGID_PORTf_GET(r) ((((r).l2x[2]) >> 3) & 0x7f)
#define BCM56218_A0_L2Xm_TGID_PORTf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x7f << 3)) | ((((uint32_t)f) & 0x7f) << 3))
#define BCM56218_A0_L2Xm_TGIDf_GET(r) ((((r).l2x[2]) >> 3) & 0x3f)
#define BCM56218_A0_L2Xm_TGIDf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x3f << 3)) | ((((uint32_t)f) & 0x3f) << 3))
#define BCM56218_A0_L2Xm_Tf_GET(r) ((((r).l2x[2]) >> 9) & 0x1)
#define BCM56218_A0_L2Xm_Tf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56218_A0_L2Xm_MODULE_IDf_GET(r) ((((r).l2x[2]) >> 10) & 0xf)
#define BCM56218_A0_L2Xm_MODULE_IDf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0xf << 10)) | ((((uint32_t)f) & 0xf) << 10))
#define BCM56218_A0_L2Xm_REMOTE_TRUNKf_GET(r) ((((r).l2x[2]) >> 13) & 0x1)
#define BCM56218_A0_L2Xm_REMOTE_TRUNKf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56218_A0_L2Xm_L3f_GET(r) ((((r).l2x[2]) >> 14) & 0x1)
#define BCM56218_A0_L2Xm_L3f_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM56218_A0_L2Xm_MAC_BLOCK_INDEXf_GET(r) ((((r).l2x[2]) >> 15) & 0x1f)
#define BCM56218_A0_L2Xm_MAC_BLOCK_INDEXf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x1f << 15)) | ((((uint32_t)f) & 0x1f) << 15))
#define BCM56218_A0_L2Xm_STATIC_BITf_GET(r) ((((r).l2x[2]) >> 21) & 0x1)
#define BCM56218_A0_L2Xm_STATIC_BITf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM56218_A0_L2Xm_RPEf_GET(r) ((((r).l2x[2]) >> 22) & 0x1)
#define BCM56218_A0_L2Xm_RPEf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM56218_A0_L2Xm_MIRRORf_GET(r) ((((r).l2x[2]) >> 23) & 0x1)
#define BCM56218_A0_L2Xm_MIRRORf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM56218_A0_L2Xm_VALIDf_GET(r) ((((r).l2x[2]) >> 24) & 0x1)
#define BCM56218_A0_L2Xm_VALIDf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM56218_A0_L2Xm_SW_BITf_GET(r) ((((r).l2x[2]) >> 25) & 0x1)
#define BCM56218_A0_L2Xm_SW_BITf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM56218_A0_L2Xm_EVEN_PARITYf_GET(r) ((((r).l2x[2]) >> 26) & 0x1)
#define BCM56218_A0_L2Xm_EVEN_PARITYf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM56218_A0_L2Xm_HITDAf_GET(r) ((((r).l2x[2]) >> 27) & 0x1)
#define BCM56218_A0_L2Xm_HITDAf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM56218_A0_L2Xm_HITSAf_GET(r) ((((r).l2x[2]) >> 28) & 0x1)
#define BCM56218_A0_L2Xm_HITSAf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))

/*
 * These macros can be used to access L2X.
 *
 */
#define BCM56218_A0_READ_L2Xm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_L2Xm,i,(m._l2x),3)
#define BCM56218_A0_WRITE_L2Xm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_L2Xm,i,&(m._l2x),3)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2Xm BCM56218_A0_L2Xm
#define L2Xm_MIN BCM56218_A0_L2Xm_MIN
#define L2Xm_MAX BCM56218_A0_L2Xm_MAX
#define L2Xm_CMAX(u) BCM56218_A0_L2Xm_CMAX(u)
#define L2Xm_SIZE BCM56218_A0_L2Xm_SIZE
typedef BCM56218_A0_L2Xm_t L2Xm_t;
#define L2Xm_CLR BCM56218_A0_L2Xm_CLR
#define L2Xm_SET BCM56218_A0_L2Xm_SET
#define L2Xm_GET BCM56218_A0_L2Xm_GET
#define L2Xm_MAC_ADDRf_GET BCM56218_A0_L2Xm_MAC_ADDRf_GET
#define L2Xm_MAC_ADDRf_SET BCM56218_A0_L2Xm_MAC_ADDRf_SET
#define L2Xm_VLAN_IDf_GET BCM56218_A0_L2Xm_VLAN_IDf_GET
#define L2Xm_VLAN_IDf_SET BCM56218_A0_L2Xm_VLAN_IDf_SET
#define L2Xm_PRIf_GET BCM56218_A0_L2Xm_PRIf_GET
#define L2Xm_PRIf_SET BCM56218_A0_L2Xm_PRIf_SET
#define L2Xm_CPUf_GET BCM56218_A0_L2Xm_CPUf_GET
#define L2Xm_CPUf_SET BCM56218_A0_L2Xm_CPUf_SET
#define L2Xm_DST_DISCARDf_GET BCM56218_A0_L2Xm_DST_DISCARDf_GET
#define L2Xm_DST_DISCARDf_SET BCM56218_A0_L2Xm_DST_DISCARDf_SET
#define L2Xm_SRC_DISCARDf_GET BCM56218_A0_L2Xm_SRC_DISCARDf_GET
#define L2Xm_SRC_DISCARDf_SET BCM56218_A0_L2Xm_SRC_DISCARDf_SET
#define L2Xm_SCPf_GET BCM56218_A0_L2Xm_SCPf_GET
#define L2Xm_SCPf_SET BCM56218_A0_L2Xm_SCPf_SET
#define L2Xm_L2MC_PTRf_GET BCM56218_A0_L2Xm_L2MC_PTRf_GET
#define L2Xm_L2MC_PTRf_SET BCM56218_A0_L2Xm_L2MC_PTRf_SET
#define L2Xm_PORT_TGIDf_GET BCM56218_A0_L2Xm_PORT_TGIDf_GET
#define L2Xm_PORT_TGIDf_SET BCM56218_A0_L2Xm_PORT_TGIDf_SET
#define L2Xm_TGID_PORTf_GET BCM56218_A0_L2Xm_TGID_PORTf_GET
#define L2Xm_TGID_PORTf_SET BCM56218_A0_L2Xm_TGID_PORTf_SET
#define L2Xm_TGIDf_GET BCM56218_A0_L2Xm_TGIDf_GET
#define L2Xm_TGIDf_SET BCM56218_A0_L2Xm_TGIDf_SET
#define L2Xm_Tf_GET BCM56218_A0_L2Xm_Tf_GET
#define L2Xm_Tf_SET BCM56218_A0_L2Xm_Tf_SET
#define L2Xm_MODULE_IDf_GET BCM56218_A0_L2Xm_MODULE_IDf_GET
#define L2Xm_MODULE_IDf_SET BCM56218_A0_L2Xm_MODULE_IDf_SET
#define L2Xm_REMOTE_TRUNKf_GET BCM56218_A0_L2Xm_REMOTE_TRUNKf_GET
#define L2Xm_REMOTE_TRUNKf_SET BCM56218_A0_L2Xm_REMOTE_TRUNKf_SET
#define L2Xm_L3f_GET BCM56218_A0_L2Xm_L3f_GET
#define L2Xm_L3f_SET BCM56218_A0_L2Xm_L3f_SET
#define L2Xm_MAC_BLOCK_INDEXf_GET BCM56218_A0_L2Xm_MAC_BLOCK_INDEXf_GET
#define L2Xm_MAC_BLOCK_INDEXf_SET BCM56218_A0_L2Xm_MAC_BLOCK_INDEXf_SET
#define L2Xm_STATIC_BITf_GET BCM56218_A0_L2Xm_STATIC_BITf_GET
#define L2Xm_STATIC_BITf_SET BCM56218_A0_L2Xm_STATIC_BITf_SET
#define L2Xm_RPEf_GET BCM56218_A0_L2Xm_RPEf_GET
#define L2Xm_RPEf_SET BCM56218_A0_L2Xm_RPEf_SET
#define L2Xm_MIRRORf_GET BCM56218_A0_L2Xm_MIRRORf_GET
#define L2Xm_MIRRORf_SET BCM56218_A0_L2Xm_MIRRORf_SET
#define L2Xm_VALIDf_GET BCM56218_A0_L2Xm_VALIDf_GET
#define L2Xm_VALIDf_SET BCM56218_A0_L2Xm_VALIDf_SET
#define L2Xm_SW_BITf_GET BCM56218_A0_L2Xm_SW_BITf_GET
#define L2Xm_SW_BITf_SET BCM56218_A0_L2Xm_SW_BITf_SET
#define L2Xm_EVEN_PARITYf_GET BCM56218_A0_L2Xm_EVEN_PARITYf_GET
#define L2Xm_EVEN_PARITYf_SET BCM56218_A0_L2Xm_EVEN_PARITYf_SET
#define L2Xm_HITDAf_GET BCM56218_A0_L2Xm_HITDAf_GET
#define L2Xm_HITDAf_SET BCM56218_A0_L2Xm_HITDAf_SET
#define L2Xm_HITSAf_GET BCM56218_A0_L2Xm_HITSAf_GET
#define L2Xm_HITSAf_SET BCM56218_A0_L2Xm_HITSAf_SET
#define READ_L2Xm BCM56218_A0_READ_L2Xm
#define WRITE_L2Xm BCM56218_A0_WRITE_L2Xm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_L2Xm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  L2_AGE_DEBUG
 * BLOCKS:   IPIPE
 * DESC:     Age Debug Register
 * SIZE:     32
 * FIELDS:
 *     AGE_COUNT        Indicates last entry to be aged (for all timer-based and per-port aging)
 *     START            initiate software-based timer aging (should not be started while timer-based aging is enabled)
 *     COMPLETE         signal software-based timer aging is complete
 *
 ******************************************************************************/
#define BCM56218_A0_L2_AGE_DEBUGr 0x00780005

#define BCM56218_A0_L2_AGE_DEBUGr_SIZE 4

/*
 * This structure should be used to declare and program L2_AGE_DEBUG.
 *
 */
typedef union BCM56218_A0_L2_AGE_DEBUGr_s {
	uint32_t v[1];
	uint32_t l2_age_debug[1];
	uint32_t _l2_age_debug;
} BCM56218_A0_L2_AGE_DEBUGr_t;

#define BCM56218_A0_L2_AGE_DEBUGr_CLR(r) (r).l2_age_debug[0] = 0
#define BCM56218_A0_L2_AGE_DEBUGr_SET(r,d) (r).l2_age_debug[0] = d
#define BCM56218_A0_L2_AGE_DEBUGr_GET(r) (r).l2_age_debug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_L2_AGE_DEBUGr_AGE_COUNTf_GET(r) (((r).l2_age_debug[0]) & 0x3fff)
#define BCM56218_A0_L2_AGE_DEBUGr_AGE_COUNTf_SET(r,f) (r).l2_age_debug[0]=(((r).l2_age_debug[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM56218_A0_L2_AGE_DEBUGr_STARTf_GET(r) ((((r).l2_age_debug[0]) >> 14) & 0x1)
#define BCM56218_A0_L2_AGE_DEBUGr_STARTf_SET(r,f) (r).l2_age_debug[0]=(((r).l2_age_debug[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM56218_A0_L2_AGE_DEBUGr_COMPLETEf_GET(r) ((((r).l2_age_debug[0]) >> 15) & 0x1)
#define BCM56218_A0_L2_AGE_DEBUGr_COMPLETEf_SET(r,f) (r).l2_age_debug[0]=(((r).l2_age_debug[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access L2_AGE_DEBUG.
 *
 */
#define BCM56218_A0_READ_L2_AGE_DEBUGr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_L2_AGE_DEBUGr,(r._l2_age_debug))
#define BCM56218_A0_WRITE_L2_AGE_DEBUGr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_L2_AGE_DEBUGr,&(r._l2_age_debug))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_AGE_DEBUGr BCM56218_A0_L2_AGE_DEBUGr
#define L2_AGE_DEBUGr_SIZE BCM56218_A0_L2_AGE_DEBUGr_SIZE
typedef BCM56218_A0_L2_AGE_DEBUGr_t L2_AGE_DEBUGr_t;
#define L2_AGE_DEBUGr_CLR BCM56218_A0_L2_AGE_DEBUGr_CLR
#define L2_AGE_DEBUGr_SET BCM56218_A0_L2_AGE_DEBUGr_SET
#define L2_AGE_DEBUGr_GET BCM56218_A0_L2_AGE_DEBUGr_GET
#define L2_AGE_DEBUGr_AGE_COUNTf_GET BCM56218_A0_L2_AGE_DEBUGr_AGE_COUNTf_GET
#define L2_AGE_DEBUGr_AGE_COUNTf_SET BCM56218_A0_L2_AGE_DEBUGr_AGE_COUNTf_SET
#define L2_AGE_DEBUGr_STARTf_GET BCM56218_A0_L2_AGE_DEBUGr_STARTf_GET
#define L2_AGE_DEBUGr_STARTf_SET BCM56218_A0_L2_AGE_DEBUGr_STARTf_SET
#define L2_AGE_DEBUGr_COMPLETEf_GET BCM56218_A0_L2_AGE_DEBUGr_COMPLETEf_GET
#define L2_AGE_DEBUGr_COMPLETEf_SET BCM56218_A0_L2_AGE_DEBUGr_COMPLETEf_SET
#define READ_L2_AGE_DEBUGr BCM56218_A0_READ_L2_AGE_DEBUGr
#define WRITE_L2_AGE_DEBUGr BCM56218_A0_WRITE_L2_AGE_DEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_L2_AGE_DEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  L2_AGE_TIMER
 * BLOCKS:   IPIPE
 * DESC:     Age Timer Register
 * SIZE:     32
 * FIELDS:
 *     AGE_VAL          Age Limit
 *     AGE_ENA          Age Enable
 *
 ******************************************************************************/
#define BCM56218_A0_L2_AGE_TIMERr 0x00780003

#define BCM56218_A0_L2_AGE_TIMERr_SIZE 4

/*
 * This structure should be used to declare and program L2_AGE_TIMER.
 *
 */
typedef union BCM56218_A0_L2_AGE_TIMERr_s {
	uint32_t v[1];
	uint32_t l2_age_timer[1];
	uint32_t _l2_age_timer;
} BCM56218_A0_L2_AGE_TIMERr_t;

#define BCM56218_A0_L2_AGE_TIMERr_CLR(r) (r).l2_age_timer[0] = 0
#define BCM56218_A0_L2_AGE_TIMERr_SET(r,d) (r).l2_age_timer[0] = d
#define BCM56218_A0_L2_AGE_TIMERr_GET(r) (r).l2_age_timer[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_L2_AGE_TIMERr_AGE_VALf_GET(r) (((r).l2_age_timer[0]) & 0xfffff)
#define BCM56218_A0_L2_AGE_TIMERr_AGE_VALf_SET(r,f) (r).l2_age_timer[0]=(((r).l2_age_timer[0] & ~((uint32_t)0xfffff)) | (((uint32_t)f) & 0xfffff))
#define BCM56218_A0_L2_AGE_TIMERr_AGE_ENAf_GET(r) ((((r).l2_age_timer[0]) >> 20) & 0x1)
#define BCM56218_A0_L2_AGE_TIMERr_AGE_ENAf_SET(r,f) (r).l2_age_timer[0]=(((r).l2_age_timer[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))

/*
 * These macros can be used to access L2_AGE_TIMER.
 *
 */
#define BCM56218_A0_READ_L2_AGE_TIMERr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_L2_AGE_TIMERr,(r._l2_age_timer))
#define BCM56218_A0_WRITE_L2_AGE_TIMERr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_L2_AGE_TIMERr,&(r._l2_age_timer))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_AGE_TIMERr BCM56218_A0_L2_AGE_TIMERr
#define L2_AGE_TIMERr_SIZE BCM56218_A0_L2_AGE_TIMERr_SIZE
typedef BCM56218_A0_L2_AGE_TIMERr_t L2_AGE_TIMERr_t;
#define L2_AGE_TIMERr_CLR BCM56218_A0_L2_AGE_TIMERr_CLR
#define L2_AGE_TIMERr_SET BCM56218_A0_L2_AGE_TIMERr_SET
#define L2_AGE_TIMERr_GET BCM56218_A0_L2_AGE_TIMERr_GET
#define L2_AGE_TIMERr_AGE_VALf_GET BCM56218_A0_L2_AGE_TIMERr_AGE_VALf_GET
#define L2_AGE_TIMERr_AGE_VALf_SET BCM56218_A0_L2_AGE_TIMERr_AGE_VALf_SET
#define L2_AGE_TIMERr_AGE_ENAf_GET BCM56218_A0_L2_AGE_TIMERr_AGE_ENAf_GET
#define L2_AGE_TIMERr_AGE_ENAf_SET BCM56218_A0_L2_AGE_TIMERr_AGE_ENAf_SET
#define READ_L2_AGE_TIMERr BCM56218_A0_READ_L2_AGE_TIMERr
#define WRITE_L2_AGE_TIMERr BCM56218_A0_WRITE_L2_AGE_TIMERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_L2_AGE_TIMERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  L2_ENTRY_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     L2_ENTRY_CONTROL
 * SIZE:     32
 * FIELDS:
 *     RAM0_CT0         CT debug bit 0 for RAM0
 *     RAM0_CT1         CT debug bit 1 for RAM0
 *     RAM0_CT2         CT debug bit 2 for RAM0
 *     RAM1_CT0         CT debug bit 0 for RAM1
 *     RAM1_CT1         CT debug bit 1 for RAM1
 *     RAM1_CT2         CT debug bit 2 for RAM1
 *     RAM2_CT0         CT debug bit 0 for RAM2
 *     RAM2_CT1         CT debug bit 1 for RAM2
 *     RAM2_CT2         CT debug bit 2 for RAM2
 *     RAM3_CT0         CT debug bit 0 for RAM3
 *     RAM3_CT1         CT debug bit 1 for RAM3
 *     RAM3_CT2         CT debug bit 2 for RAM3
 *     RAM0_SAM         SAM debug bits for RAM0
 *     RAM1_SAM         SAM debug bits for RAM1
 *     RAM2_SAM         SAM debug bits for RAM2
 *     RAM3_SAM         SAM debug bits for RAM3
 *
 ******************************************************************************/
#define BCM56218_A0_L2_ENTRY_CONTROLr 0x06780009

#define BCM56218_A0_L2_ENTRY_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program L2_ENTRY_CONTROL.
 *
 */
typedef union BCM56218_A0_L2_ENTRY_CONTROLr_s {
	uint32_t v[1];
	uint32_t l2_entry_control[1];
	uint32_t _l2_entry_control;
} BCM56218_A0_L2_ENTRY_CONTROLr_t;

#define BCM56218_A0_L2_ENTRY_CONTROLr_CLR(r) (r).l2_entry_control[0] = 0
#define BCM56218_A0_L2_ENTRY_CONTROLr_SET(r,d) (r).l2_entry_control[0] = d
#define BCM56218_A0_L2_ENTRY_CONTROLr_GET(r) (r).l2_entry_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_L2_ENTRY_CONTROLr_RAM0_CT0f_GET(r) (((r).l2_entry_control[0]) & 0x1)
#define BCM56218_A0_L2_ENTRY_CONTROLr_RAM0_CT0f_SET(r,f) (r).l2_entry_control[0]=(((r).l2_entry_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_L2_ENTRY_CONTROLr_RAM0_CT1f_GET(r) ((((r).l2_entry_control[0]) >> 1) & 0x1)
#define BCM56218_A0_L2_ENTRY_CONTROLr_RAM0_CT1f_SET(r,f) (r).l2_entry_control[0]=(((r).l2_entry_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_L2_ENTRY_CONTROLr_RAM0_CT2f_GET(r) ((((r).l2_entry_control[0]) >> 2) & 0x1)
#define BCM56218_A0_L2_ENTRY_CONTROLr_RAM0_CT2f_SET(r,f) (r).l2_entry_control[0]=(((r).l2_entry_control[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_L2_ENTRY_CONTROLr_RAM1_CT0f_GET(r) ((((r).l2_entry_control[0]) >> 3) & 0x1)
#define BCM56218_A0_L2_ENTRY_CONTROLr_RAM1_CT0f_SET(r,f) (r).l2_entry_control[0]=(((r).l2_entry_control[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56218_A0_L2_ENTRY_CONTROLr_RAM1_CT1f_GET(r) ((((r).l2_entry_control[0]) >> 4) & 0x1)
#define BCM56218_A0_L2_ENTRY_CONTROLr_RAM1_CT1f_SET(r,f) (r).l2_entry_control[0]=(((r).l2_entry_control[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56218_A0_L2_ENTRY_CONTROLr_RAM1_CT2f_GET(r) ((((r).l2_entry_control[0]) >> 5) & 0x1)
#define BCM56218_A0_L2_ENTRY_CONTROLr_RAM1_CT2f_SET(r,f) (r).l2_entry_control[0]=(((r).l2_entry_control[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56218_A0_L2_ENTRY_CONTROLr_RAM2_CT0f_GET(r) ((((r).l2_entry_control[0]) >> 6) & 0x1)
#define BCM56218_A0_L2_ENTRY_CONTROLr_RAM2_CT0f_SET(r,f) (r).l2_entry_control[0]=(((r).l2_entry_control[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56218_A0_L2_ENTRY_CONTROLr_RAM2_CT1f_GET(r) ((((r).l2_entry_control[0]) >> 7) & 0x1)
#define BCM56218_A0_L2_ENTRY_CONTROLr_RAM2_CT1f_SET(r,f) (r).l2_entry_control[0]=(((r).l2_entry_control[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56218_A0_L2_ENTRY_CONTROLr_RAM2_CT2f_GET(r) ((((r).l2_entry_control[0]) >> 8) & 0x1)
#define BCM56218_A0_L2_ENTRY_CONTROLr_RAM2_CT2f_SET(r,f) (r).l2_entry_control[0]=(((r).l2_entry_control[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56218_A0_L2_ENTRY_CONTROLr_RAM3_CT0f_GET(r) ((((r).l2_entry_control[0]) >> 9) & 0x1)
#define BCM56218_A0_L2_ENTRY_CONTROLr_RAM3_CT0f_SET(r,f) (r).l2_entry_control[0]=(((r).l2_entry_control[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56218_A0_L2_ENTRY_CONTROLr_RAM3_CT1f_GET(r) ((((r).l2_entry_control[0]) >> 10) & 0x1)
#define BCM56218_A0_L2_ENTRY_CONTROLr_RAM3_CT1f_SET(r,f) (r).l2_entry_control[0]=(((r).l2_entry_control[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56218_A0_L2_ENTRY_CONTROLr_RAM3_CT2f_GET(r) ((((r).l2_entry_control[0]) >> 11) & 0x1)
#define BCM56218_A0_L2_ENTRY_CONTROLr_RAM3_CT2f_SET(r,f) (r).l2_entry_control[0]=(((r).l2_entry_control[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56218_A0_L2_ENTRY_CONTROLr_RAM0_SAMf_GET(r) ((((r).l2_entry_control[0]) >> 12) & 0x3)
#define BCM56218_A0_L2_ENTRY_CONTROLr_RAM0_SAMf_SET(r,f) (r).l2_entry_control[0]=(((r).l2_entry_control[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM56218_A0_L2_ENTRY_CONTROLr_RAM1_SAMf_GET(r) ((((r).l2_entry_control[0]) >> 14) & 0x3)
#define BCM56218_A0_L2_ENTRY_CONTROLr_RAM1_SAMf_SET(r,f) (r).l2_entry_control[0]=(((r).l2_entry_control[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCM56218_A0_L2_ENTRY_CONTROLr_RAM2_SAMf_GET(r) ((((r).l2_entry_control[0]) >> 16) & 0x3)
#define BCM56218_A0_L2_ENTRY_CONTROLr_RAM2_SAMf_SET(r,f) (r).l2_entry_control[0]=(((r).l2_entry_control[0] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM56218_A0_L2_ENTRY_CONTROLr_RAM3_SAMf_GET(r) ((((r).l2_entry_control[0]) >> 18) & 0x3)
#define BCM56218_A0_L2_ENTRY_CONTROLr_RAM3_SAMf_SET(r,f) (r).l2_entry_control[0]=(((r).l2_entry_control[0] & ~((uint32_t)0x3 << 18)) | ((((uint32_t)f) & 0x3) << 18))

/*
 * These macros can be used to access L2_ENTRY_CONTROL.
 *
 */
#define BCM56218_A0_READ_L2_ENTRY_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_L2_ENTRY_CONTROLr,(r._l2_entry_control))
#define BCM56218_A0_WRITE_L2_ENTRY_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_L2_ENTRY_CONTROLr,&(r._l2_entry_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_ENTRY_CONTROLr BCM56218_A0_L2_ENTRY_CONTROLr
#define L2_ENTRY_CONTROLr_SIZE BCM56218_A0_L2_ENTRY_CONTROLr_SIZE
typedef BCM56218_A0_L2_ENTRY_CONTROLr_t L2_ENTRY_CONTROLr_t;
#define L2_ENTRY_CONTROLr_CLR BCM56218_A0_L2_ENTRY_CONTROLr_CLR
#define L2_ENTRY_CONTROLr_SET BCM56218_A0_L2_ENTRY_CONTROLr_SET
#define L2_ENTRY_CONTROLr_GET BCM56218_A0_L2_ENTRY_CONTROLr_GET
#define L2_ENTRY_CONTROLr_RAM0_CT0f_GET BCM56218_A0_L2_ENTRY_CONTROLr_RAM0_CT0f_GET
#define L2_ENTRY_CONTROLr_RAM0_CT0f_SET BCM56218_A0_L2_ENTRY_CONTROLr_RAM0_CT0f_SET
#define L2_ENTRY_CONTROLr_RAM0_CT1f_GET BCM56218_A0_L2_ENTRY_CONTROLr_RAM0_CT1f_GET
#define L2_ENTRY_CONTROLr_RAM0_CT1f_SET BCM56218_A0_L2_ENTRY_CONTROLr_RAM0_CT1f_SET
#define L2_ENTRY_CONTROLr_RAM0_CT2f_GET BCM56218_A0_L2_ENTRY_CONTROLr_RAM0_CT2f_GET
#define L2_ENTRY_CONTROLr_RAM0_CT2f_SET BCM56218_A0_L2_ENTRY_CONTROLr_RAM0_CT2f_SET
#define L2_ENTRY_CONTROLr_RAM1_CT0f_GET BCM56218_A0_L2_ENTRY_CONTROLr_RAM1_CT0f_GET
#define L2_ENTRY_CONTROLr_RAM1_CT0f_SET BCM56218_A0_L2_ENTRY_CONTROLr_RAM1_CT0f_SET
#define L2_ENTRY_CONTROLr_RAM1_CT1f_GET BCM56218_A0_L2_ENTRY_CONTROLr_RAM1_CT1f_GET
#define L2_ENTRY_CONTROLr_RAM1_CT1f_SET BCM56218_A0_L2_ENTRY_CONTROLr_RAM1_CT1f_SET
#define L2_ENTRY_CONTROLr_RAM1_CT2f_GET BCM56218_A0_L2_ENTRY_CONTROLr_RAM1_CT2f_GET
#define L2_ENTRY_CONTROLr_RAM1_CT2f_SET BCM56218_A0_L2_ENTRY_CONTROLr_RAM1_CT2f_SET
#define L2_ENTRY_CONTROLr_RAM2_CT0f_GET BCM56218_A0_L2_ENTRY_CONTROLr_RAM2_CT0f_GET
#define L2_ENTRY_CONTROLr_RAM2_CT0f_SET BCM56218_A0_L2_ENTRY_CONTROLr_RAM2_CT0f_SET
#define L2_ENTRY_CONTROLr_RAM2_CT1f_GET BCM56218_A0_L2_ENTRY_CONTROLr_RAM2_CT1f_GET
#define L2_ENTRY_CONTROLr_RAM2_CT1f_SET BCM56218_A0_L2_ENTRY_CONTROLr_RAM2_CT1f_SET
#define L2_ENTRY_CONTROLr_RAM2_CT2f_GET BCM56218_A0_L2_ENTRY_CONTROLr_RAM2_CT2f_GET
#define L2_ENTRY_CONTROLr_RAM2_CT2f_SET BCM56218_A0_L2_ENTRY_CONTROLr_RAM2_CT2f_SET
#define L2_ENTRY_CONTROLr_RAM3_CT0f_GET BCM56218_A0_L2_ENTRY_CONTROLr_RAM3_CT0f_GET
#define L2_ENTRY_CONTROLr_RAM3_CT0f_SET BCM56218_A0_L2_ENTRY_CONTROLr_RAM3_CT0f_SET
#define L2_ENTRY_CONTROLr_RAM3_CT1f_GET BCM56218_A0_L2_ENTRY_CONTROLr_RAM3_CT1f_GET
#define L2_ENTRY_CONTROLr_RAM3_CT1f_SET BCM56218_A0_L2_ENTRY_CONTROLr_RAM3_CT1f_SET
#define L2_ENTRY_CONTROLr_RAM3_CT2f_GET BCM56218_A0_L2_ENTRY_CONTROLr_RAM3_CT2f_GET
#define L2_ENTRY_CONTROLr_RAM3_CT2f_SET BCM56218_A0_L2_ENTRY_CONTROLr_RAM3_CT2f_SET
#define L2_ENTRY_CONTROLr_RAM0_SAMf_GET BCM56218_A0_L2_ENTRY_CONTROLr_RAM0_SAMf_GET
#define L2_ENTRY_CONTROLr_RAM0_SAMf_SET BCM56218_A0_L2_ENTRY_CONTROLr_RAM0_SAMf_SET
#define L2_ENTRY_CONTROLr_RAM1_SAMf_GET BCM56218_A0_L2_ENTRY_CONTROLr_RAM1_SAMf_GET
#define L2_ENTRY_CONTROLr_RAM1_SAMf_SET BCM56218_A0_L2_ENTRY_CONTROLr_RAM1_SAMf_SET
#define L2_ENTRY_CONTROLr_RAM2_SAMf_GET BCM56218_A0_L2_ENTRY_CONTROLr_RAM2_SAMf_GET
#define L2_ENTRY_CONTROLr_RAM2_SAMf_SET BCM56218_A0_L2_ENTRY_CONTROLr_RAM2_SAMf_SET
#define L2_ENTRY_CONTROLr_RAM3_SAMf_GET BCM56218_A0_L2_ENTRY_CONTROLr_RAM3_SAMf_GET
#define L2_ENTRY_CONTROLr_RAM3_SAMf_SET BCM56218_A0_L2_ENTRY_CONTROLr_RAM3_SAMf_SET
#define READ_L2_ENTRY_CONTROLr BCM56218_A0_READ_L2_ENTRY_CONTROLr
#define WRITE_L2_ENTRY_CONTROLr BCM56218_A0_WRITE_L2_ENTRY_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_L2_ENTRY_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  L2_ENTRY_ONLY
 * BLOCKS:   IPIPE
 * DESC:     HW managed L2_ENTRY table only.  Does not include L2_HITSA or L2_HITDA
 * SIZE:     91
 * FIELDS:
 *     MAC_ADDR         MAC address
 *     VLAN_ID          VLAN ID
 *     PRI              Priority
 *     CPU              CPU bit
 *     DST_DISCARD      Dst Discard
 *     SRC_DISCARD      Src Discard
 *     SCP              SCP bit
 *     L2MC_PTR         Overlay of L2MC pointer (8 bits)
 *     PORT_TGID        Port or TGID
 *     TGID_PORT        Port or TGID - old Draco name
 *     TGID             TGID - old Draco name
 *     T                Trunk bit overlay(MSB of port_tgid)
 *     MODULE_ID        Module ID
 *     REMOTE_TRUNK     Remote Trunk bit indicates HiGig pkt with remote modid(MSB of module_id)
 *     L3               Indicates an L3 entry
 *     MAC_BLOCK_INDEX  MAC Block Index
 *     STATIC_BIT       Indicates entry is SW programmed and static
 *     RPE              RPE bit
 *     MIRROR           Mirror bit
 *     VALID            Indicates that the entry is valid
 *     SW_BIT           No hw functionality, excusilvely used by sw.
 *     EVEN_PARITY      Odd parity for the L2_ENTRY RAM fields (i.e. excludes HIT bits)
 *
 ******************************************************************************/
#define BCM56218_A0_L2_ENTRY_ONLYm 0x06710000

#define BCM56218_A0_L2_ENTRY_ONLYm_MIN 0
#define BCM56218_A0_L2_ENTRY_ONLYm_MAX 8191
#define BCM56218_A0_L2_ENTRY_ONLYm_CMAX(u) 8191
#define BCM56218_A0_L2_ENTRY_ONLYm_SIZE 12

/*
 * This structure should be used to declare and program L2_ENTRY_ONLY.
 *
 */
typedef union BCM56218_A0_L2_ENTRY_ONLYm_s {
	uint32_t v[3];
	uint32_t l2_entry_only[3];
	uint32_t _l2_entry_only;
} BCM56218_A0_L2_ENTRY_ONLYm_t;

#define BCM56218_A0_L2_ENTRY_ONLYm_CLR(r) CDK_MEMSET(&((r)._l2_entry_only), 0, sizeof(BCM56218_A0_L2_ENTRY_ONLYm_t))
#define BCM56218_A0_L2_ENTRY_ONLYm_SET(r,i,d) (r).l2_entry_only[i] = d
#define BCM56218_A0_L2_ENTRY_ONLYm_GET(r,i) (r).l2_entry_only[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_L2_ENTRY_ONLYm_MAC_ADDRf_GET(r,a) cdk_field_get((r).l2_entry_only,0,47,a)
#define BCM56218_A0_L2_ENTRY_ONLYm_MAC_ADDRf_SET(r,a) cdk_field_set((r).l2_entry_only,0,47,a)
#define BCM56218_A0_L2_ENTRY_ONLYm_VLAN_IDf_GET(r) ((((r).l2_entry_only[1]) >> 16) & 0xfff)
#define BCM56218_A0_L2_ENTRY_ONLYm_VLAN_IDf_SET(r,f) (r).l2_entry_only[1]=(((r).l2_entry_only[1] & ~((uint32_t)0xfff << 16)) | ((((uint32_t)f) & 0xfff) << 16))
#define BCM56218_A0_L2_ENTRY_ONLYm_PRIf_GET(r) ((((r).l2_entry_only[1]) >> 28) & 0x7)
#define BCM56218_A0_L2_ENTRY_ONLYm_PRIf_SET(r,f) (r).l2_entry_only[1]=(((r).l2_entry_only[1] & ~((uint32_t)0x7 << 28)) | ((((uint32_t)f) & 0x7) << 28))
#define BCM56218_A0_L2_ENTRY_ONLYm_CPUf_GET(r) ((((r).l2_entry_only[1]) >> 31) & 0x1)
#define BCM56218_A0_L2_ENTRY_ONLYm_CPUf_SET(r,f) (r).l2_entry_only[1]=(((r).l2_entry_only[1] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM56218_A0_L2_ENTRY_ONLYm_DST_DISCARDf_GET(r) (((r).l2_entry_only[2]) & 0x1)
#define BCM56218_A0_L2_ENTRY_ONLYm_DST_DISCARDf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_L2_ENTRY_ONLYm_SRC_DISCARDf_GET(r) ((((r).l2_entry_only[2]) >> 1) & 0x1)
#define BCM56218_A0_L2_ENTRY_ONLYm_SRC_DISCARDf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_L2_ENTRY_ONLYm_SCPf_GET(r) ((((r).l2_entry_only[2]) >> 2) & 0x1)
#define BCM56218_A0_L2_ENTRY_ONLYm_SCPf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_L2_ENTRY_ONLYm_L2MC_PTRf_GET(r) ((((r).l2_entry_only[2]) >> 3) & 0xff)
#define BCM56218_A0_L2_ENTRY_ONLYm_L2MC_PTRf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0xff << 3)) | ((((uint32_t)f) & 0xff) << 3))
#define BCM56218_A0_L2_ENTRY_ONLYm_PORT_TGIDf_GET(r) ((((r).l2_entry_only[2]) >> 3) & 0x7f)
#define BCM56218_A0_L2_ENTRY_ONLYm_PORT_TGIDf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x7f << 3)) | ((((uint32_t)f) & 0x7f) << 3))
#define BCM56218_A0_L2_ENTRY_ONLYm_TGID_PORTf_GET(r) ((((r).l2_entry_only[2]) >> 3) & 0x7f)
#define BCM56218_A0_L2_ENTRY_ONLYm_TGID_PORTf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x7f << 3)) | ((((uint32_t)f) & 0x7f) << 3))
#define BCM56218_A0_L2_ENTRY_ONLYm_TGIDf_GET(r) ((((r).l2_entry_only[2]) >> 3) & 0x3f)
#define BCM56218_A0_L2_ENTRY_ONLYm_TGIDf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x3f << 3)) | ((((uint32_t)f) & 0x3f) << 3))
#define BCM56218_A0_L2_ENTRY_ONLYm_Tf_GET(r) ((((r).l2_entry_only[2]) >> 9) & 0x1)
#define BCM56218_A0_L2_ENTRY_ONLYm_Tf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56218_A0_L2_ENTRY_ONLYm_MODULE_IDf_GET(r) ((((r).l2_entry_only[2]) >> 10) & 0xf)
#define BCM56218_A0_L2_ENTRY_ONLYm_MODULE_IDf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0xf << 10)) | ((((uint32_t)f) & 0xf) << 10))
#define BCM56218_A0_L2_ENTRY_ONLYm_REMOTE_TRUNKf_GET(r) ((((r).l2_entry_only[2]) >> 13) & 0x1)
#define BCM56218_A0_L2_ENTRY_ONLYm_REMOTE_TRUNKf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56218_A0_L2_ENTRY_ONLYm_L3f_GET(r) ((((r).l2_entry_only[2]) >> 14) & 0x1)
#define BCM56218_A0_L2_ENTRY_ONLYm_L3f_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM56218_A0_L2_ENTRY_ONLYm_MAC_BLOCK_INDEXf_GET(r) ((((r).l2_entry_only[2]) >> 15) & 0x1f)
#define BCM56218_A0_L2_ENTRY_ONLYm_MAC_BLOCK_INDEXf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x1f << 15)) | ((((uint32_t)f) & 0x1f) << 15))
#define BCM56218_A0_L2_ENTRY_ONLYm_STATIC_BITf_GET(r) ((((r).l2_entry_only[2]) >> 21) & 0x1)
#define BCM56218_A0_L2_ENTRY_ONLYm_STATIC_BITf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM56218_A0_L2_ENTRY_ONLYm_RPEf_GET(r) ((((r).l2_entry_only[2]) >> 22) & 0x1)
#define BCM56218_A0_L2_ENTRY_ONLYm_RPEf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM56218_A0_L2_ENTRY_ONLYm_MIRRORf_GET(r) ((((r).l2_entry_only[2]) >> 23) & 0x1)
#define BCM56218_A0_L2_ENTRY_ONLYm_MIRRORf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM56218_A0_L2_ENTRY_ONLYm_VALIDf_GET(r) ((((r).l2_entry_only[2]) >> 24) & 0x1)
#define BCM56218_A0_L2_ENTRY_ONLYm_VALIDf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM56218_A0_L2_ENTRY_ONLYm_SW_BITf_GET(r) ((((r).l2_entry_only[2]) >> 25) & 0x1)
#define BCM56218_A0_L2_ENTRY_ONLYm_SW_BITf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM56218_A0_L2_ENTRY_ONLYm_EVEN_PARITYf_GET(r) ((((r).l2_entry_only[2]) >> 26) & 0x1)
#define BCM56218_A0_L2_ENTRY_ONLYm_EVEN_PARITYf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))

/*
 * These macros can be used to access L2_ENTRY_ONLY.
 *
 */
#define BCM56218_A0_READ_L2_ENTRY_ONLYm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_L2_ENTRY_ONLYm,i,(m._l2_entry_only),3)
#define BCM56218_A0_WRITE_L2_ENTRY_ONLYm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_L2_ENTRY_ONLYm,i,&(m._l2_entry_only),3)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_ENTRY_ONLYm BCM56218_A0_L2_ENTRY_ONLYm
#define L2_ENTRY_ONLYm_MIN BCM56218_A0_L2_ENTRY_ONLYm_MIN
#define L2_ENTRY_ONLYm_MAX BCM56218_A0_L2_ENTRY_ONLYm_MAX
#define L2_ENTRY_ONLYm_CMAX(u) BCM56218_A0_L2_ENTRY_ONLYm_CMAX(u)
#define L2_ENTRY_ONLYm_SIZE BCM56218_A0_L2_ENTRY_ONLYm_SIZE
typedef BCM56218_A0_L2_ENTRY_ONLYm_t L2_ENTRY_ONLYm_t;
#define L2_ENTRY_ONLYm_CLR BCM56218_A0_L2_ENTRY_ONLYm_CLR
#define L2_ENTRY_ONLYm_SET BCM56218_A0_L2_ENTRY_ONLYm_SET
#define L2_ENTRY_ONLYm_GET BCM56218_A0_L2_ENTRY_ONLYm_GET
#define L2_ENTRY_ONLYm_MAC_ADDRf_GET BCM56218_A0_L2_ENTRY_ONLYm_MAC_ADDRf_GET
#define L2_ENTRY_ONLYm_MAC_ADDRf_SET BCM56218_A0_L2_ENTRY_ONLYm_MAC_ADDRf_SET
#define L2_ENTRY_ONLYm_VLAN_IDf_GET BCM56218_A0_L2_ENTRY_ONLYm_VLAN_IDf_GET
#define L2_ENTRY_ONLYm_VLAN_IDf_SET BCM56218_A0_L2_ENTRY_ONLYm_VLAN_IDf_SET
#define L2_ENTRY_ONLYm_PRIf_GET BCM56218_A0_L2_ENTRY_ONLYm_PRIf_GET
#define L2_ENTRY_ONLYm_PRIf_SET BCM56218_A0_L2_ENTRY_ONLYm_PRIf_SET
#define L2_ENTRY_ONLYm_CPUf_GET BCM56218_A0_L2_ENTRY_ONLYm_CPUf_GET
#define L2_ENTRY_ONLYm_CPUf_SET BCM56218_A0_L2_ENTRY_ONLYm_CPUf_SET
#define L2_ENTRY_ONLYm_DST_DISCARDf_GET BCM56218_A0_L2_ENTRY_ONLYm_DST_DISCARDf_GET
#define L2_ENTRY_ONLYm_DST_DISCARDf_SET BCM56218_A0_L2_ENTRY_ONLYm_DST_DISCARDf_SET
#define L2_ENTRY_ONLYm_SRC_DISCARDf_GET BCM56218_A0_L2_ENTRY_ONLYm_SRC_DISCARDf_GET
#define L2_ENTRY_ONLYm_SRC_DISCARDf_SET BCM56218_A0_L2_ENTRY_ONLYm_SRC_DISCARDf_SET
#define L2_ENTRY_ONLYm_SCPf_GET BCM56218_A0_L2_ENTRY_ONLYm_SCPf_GET
#define L2_ENTRY_ONLYm_SCPf_SET BCM56218_A0_L2_ENTRY_ONLYm_SCPf_SET
#define L2_ENTRY_ONLYm_L2MC_PTRf_GET BCM56218_A0_L2_ENTRY_ONLYm_L2MC_PTRf_GET
#define L2_ENTRY_ONLYm_L2MC_PTRf_SET BCM56218_A0_L2_ENTRY_ONLYm_L2MC_PTRf_SET
#define L2_ENTRY_ONLYm_PORT_TGIDf_GET BCM56218_A0_L2_ENTRY_ONLYm_PORT_TGIDf_GET
#define L2_ENTRY_ONLYm_PORT_TGIDf_SET BCM56218_A0_L2_ENTRY_ONLYm_PORT_TGIDf_SET
#define L2_ENTRY_ONLYm_TGID_PORTf_GET BCM56218_A0_L2_ENTRY_ONLYm_TGID_PORTf_GET
#define L2_ENTRY_ONLYm_TGID_PORTf_SET BCM56218_A0_L2_ENTRY_ONLYm_TGID_PORTf_SET
#define L2_ENTRY_ONLYm_TGIDf_GET BCM56218_A0_L2_ENTRY_ONLYm_TGIDf_GET
#define L2_ENTRY_ONLYm_TGIDf_SET BCM56218_A0_L2_ENTRY_ONLYm_TGIDf_SET
#define L2_ENTRY_ONLYm_Tf_GET BCM56218_A0_L2_ENTRY_ONLYm_Tf_GET
#define L2_ENTRY_ONLYm_Tf_SET BCM56218_A0_L2_ENTRY_ONLYm_Tf_SET
#define L2_ENTRY_ONLYm_MODULE_IDf_GET BCM56218_A0_L2_ENTRY_ONLYm_MODULE_IDf_GET
#define L2_ENTRY_ONLYm_MODULE_IDf_SET BCM56218_A0_L2_ENTRY_ONLYm_MODULE_IDf_SET
#define L2_ENTRY_ONLYm_REMOTE_TRUNKf_GET BCM56218_A0_L2_ENTRY_ONLYm_REMOTE_TRUNKf_GET
#define L2_ENTRY_ONLYm_REMOTE_TRUNKf_SET BCM56218_A0_L2_ENTRY_ONLYm_REMOTE_TRUNKf_SET
#define L2_ENTRY_ONLYm_L3f_GET BCM56218_A0_L2_ENTRY_ONLYm_L3f_GET
#define L2_ENTRY_ONLYm_L3f_SET BCM56218_A0_L2_ENTRY_ONLYm_L3f_SET
#define L2_ENTRY_ONLYm_MAC_BLOCK_INDEXf_GET BCM56218_A0_L2_ENTRY_ONLYm_MAC_BLOCK_INDEXf_GET
#define L2_ENTRY_ONLYm_MAC_BLOCK_INDEXf_SET BCM56218_A0_L2_ENTRY_ONLYm_MAC_BLOCK_INDEXf_SET
#define L2_ENTRY_ONLYm_STATIC_BITf_GET BCM56218_A0_L2_ENTRY_ONLYm_STATIC_BITf_GET
#define L2_ENTRY_ONLYm_STATIC_BITf_SET BCM56218_A0_L2_ENTRY_ONLYm_STATIC_BITf_SET
#define L2_ENTRY_ONLYm_RPEf_GET BCM56218_A0_L2_ENTRY_ONLYm_RPEf_GET
#define L2_ENTRY_ONLYm_RPEf_SET BCM56218_A0_L2_ENTRY_ONLYm_RPEf_SET
#define L2_ENTRY_ONLYm_MIRRORf_GET BCM56218_A0_L2_ENTRY_ONLYm_MIRRORf_GET
#define L2_ENTRY_ONLYm_MIRRORf_SET BCM56218_A0_L2_ENTRY_ONLYm_MIRRORf_SET
#define L2_ENTRY_ONLYm_VALIDf_GET BCM56218_A0_L2_ENTRY_ONLYm_VALIDf_GET
#define L2_ENTRY_ONLYm_VALIDf_SET BCM56218_A0_L2_ENTRY_ONLYm_VALIDf_SET
#define L2_ENTRY_ONLYm_SW_BITf_GET BCM56218_A0_L2_ENTRY_ONLYm_SW_BITf_GET
#define L2_ENTRY_ONLYm_SW_BITf_SET BCM56218_A0_L2_ENTRY_ONLYm_SW_BITf_SET
#define L2_ENTRY_ONLYm_EVEN_PARITYf_GET BCM56218_A0_L2_ENTRY_ONLYm_EVEN_PARITYf_GET
#define L2_ENTRY_ONLYm_EVEN_PARITYf_SET BCM56218_A0_L2_ENTRY_ONLYm_EVEN_PARITYf_SET
#define READ_L2_ENTRY_ONLYm BCM56218_A0_READ_L2_ENTRY_ONLYm
#define WRITE_L2_ENTRY_ONLYm BCM56218_A0_WRITE_L2_ENTRY_ONLYm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_L2_ENTRY_ONLYm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  L2_ENTRY_PARITY_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     L2_ENTRY_PARITY_CONTROL
 * SIZE:     32
 * FIELDS:
 *     PARITY_IRQ_EN    This bit is AND'd with the PARITY_ERR bit of the PARITY_STATUS register to generate the parity irq.  The PARITY_ERR and BUCKET_IDX/ENTRY_BM are sticky while this bit is set.  Clearing this bit clears the PARITY_ERR bit.
 *     PARITY_EN        This bit enables parity checking for the L2_ENTRY table.
 *
 ******************************************************************************/
#define BCM56218_A0_L2_ENTRY_PARITY_CONTROLr 0x0678000c

#define BCM56218_A0_L2_ENTRY_PARITY_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program L2_ENTRY_PARITY_CONTROL.
 *
 */
typedef union BCM56218_A0_L2_ENTRY_PARITY_CONTROLr_s {
	uint32_t v[1];
	uint32_t l2_entry_parity_control[1];
	uint32_t _l2_entry_parity_control;
} BCM56218_A0_L2_ENTRY_PARITY_CONTROLr_t;

#define BCM56218_A0_L2_ENTRY_PARITY_CONTROLr_CLR(r) (r).l2_entry_parity_control[0] = 0
#define BCM56218_A0_L2_ENTRY_PARITY_CONTROLr_SET(r,d) (r).l2_entry_parity_control[0] = d
#define BCM56218_A0_L2_ENTRY_PARITY_CONTROLr_GET(r) (r).l2_entry_parity_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_L2_ENTRY_PARITY_CONTROLr_PARITY_IRQ_ENf_GET(r) (((r).l2_entry_parity_control[0]) & 0x1)
#define BCM56218_A0_L2_ENTRY_PARITY_CONTROLr_PARITY_IRQ_ENf_SET(r,f) (r).l2_entry_parity_control[0]=(((r).l2_entry_parity_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_L2_ENTRY_PARITY_CONTROLr_PARITY_ENf_GET(r) ((((r).l2_entry_parity_control[0]) >> 1) & 0x1)
#define BCM56218_A0_L2_ENTRY_PARITY_CONTROLr_PARITY_ENf_SET(r,f) (r).l2_entry_parity_control[0]=(((r).l2_entry_parity_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access L2_ENTRY_PARITY_CONTROL.
 *
 */
#define BCM56218_A0_READ_L2_ENTRY_PARITY_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_L2_ENTRY_PARITY_CONTROLr,(r._l2_entry_parity_control))
#define BCM56218_A0_WRITE_L2_ENTRY_PARITY_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_L2_ENTRY_PARITY_CONTROLr,&(r._l2_entry_parity_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_ENTRY_PARITY_CONTROLr BCM56218_A0_L2_ENTRY_PARITY_CONTROLr
#define L2_ENTRY_PARITY_CONTROLr_SIZE BCM56218_A0_L2_ENTRY_PARITY_CONTROLr_SIZE
typedef BCM56218_A0_L2_ENTRY_PARITY_CONTROLr_t L2_ENTRY_PARITY_CONTROLr_t;
#define L2_ENTRY_PARITY_CONTROLr_CLR BCM56218_A0_L2_ENTRY_PARITY_CONTROLr_CLR
#define L2_ENTRY_PARITY_CONTROLr_SET BCM56218_A0_L2_ENTRY_PARITY_CONTROLr_SET
#define L2_ENTRY_PARITY_CONTROLr_GET BCM56218_A0_L2_ENTRY_PARITY_CONTROLr_GET
#define L2_ENTRY_PARITY_CONTROLr_PARITY_IRQ_ENf_GET BCM56218_A0_L2_ENTRY_PARITY_CONTROLr_PARITY_IRQ_ENf_GET
#define L2_ENTRY_PARITY_CONTROLr_PARITY_IRQ_ENf_SET BCM56218_A0_L2_ENTRY_PARITY_CONTROLr_PARITY_IRQ_ENf_SET
#define L2_ENTRY_PARITY_CONTROLr_PARITY_ENf_GET BCM56218_A0_L2_ENTRY_PARITY_CONTROLr_PARITY_ENf_GET
#define L2_ENTRY_PARITY_CONTROLr_PARITY_ENf_SET BCM56218_A0_L2_ENTRY_PARITY_CONTROLr_PARITY_ENf_SET
#define READ_L2_ENTRY_PARITY_CONTROLr BCM56218_A0_READ_L2_ENTRY_PARITY_CONTROLr
#define WRITE_L2_ENTRY_PARITY_CONTROLr BCM56218_A0_WRITE_L2_ENTRY_PARITY_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_L2_ENTRY_PARITY_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  L2_ENTRY_PARITY_STATUS
 * BLOCKS:   IPIPE
 * DESC:     L2_ENTRY_PARITY_STATUS
 * SIZE:     32
 * FIELDS:
 *     PARITY_ERR       This bit when set indicates that a parity error has been detected.
 *     ENTRY_BM         This bitmap indicates the entries that had parity errors.  Bits 7..0 correspond to entries 7..0.
 *     BUCKET_IDX       This field indicates the index to the bucket in which the parity error was detected.
 *
 ******************************************************************************/
#define BCM56218_A0_L2_ENTRY_PARITY_STATUSr 0x0678000d

#define BCM56218_A0_L2_ENTRY_PARITY_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program L2_ENTRY_PARITY_STATUS.
 *
 */
typedef union BCM56218_A0_L2_ENTRY_PARITY_STATUSr_s {
	uint32_t v[1];
	uint32_t l2_entry_parity_status[1];
	uint32_t _l2_entry_parity_status;
} BCM56218_A0_L2_ENTRY_PARITY_STATUSr_t;

#define BCM56218_A0_L2_ENTRY_PARITY_STATUSr_CLR(r) (r).l2_entry_parity_status[0] = 0
#define BCM56218_A0_L2_ENTRY_PARITY_STATUSr_SET(r,d) (r).l2_entry_parity_status[0] = d
#define BCM56218_A0_L2_ENTRY_PARITY_STATUSr_GET(r) (r).l2_entry_parity_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_L2_ENTRY_PARITY_STATUSr_PARITY_ERRf_GET(r) (((r).l2_entry_parity_status[0]) & 0x1)
#define BCM56218_A0_L2_ENTRY_PARITY_STATUSr_PARITY_ERRf_SET(r,f) (r).l2_entry_parity_status[0]=(((r).l2_entry_parity_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_L2_ENTRY_PARITY_STATUSr_ENTRY_BMf_GET(r) ((((r).l2_entry_parity_status[0]) >> 1) & 0xff)
#define BCM56218_A0_L2_ENTRY_PARITY_STATUSr_ENTRY_BMf_SET(r,f) (r).l2_entry_parity_status[0]=(((r).l2_entry_parity_status[0] & ~((uint32_t)0xff << 1)) | ((((uint32_t)f) & 0xff) << 1))
#define BCM56218_A0_L2_ENTRY_PARITY_STATUSr_BUCKET_IDXf_GET(r) ((((r).l2_entry_parity_status[0]) >> 9) & 0x3ff)
#define BCM56218_A0_L2_ENTRY_PARITY_STATUSr_BUCKET_IDXf_SET(r,f) (r).l2_entry_parity_status[0]=(((r).l2_entry_parity_status[0] & ~((uint32_t)0x3ff << 9)) | ((((uint32_t)f) & 0x3ff) << 9))

/*
 * These macros can be used to access L2_ENTRY_PARITY_STATUS.
 *
 */
#define BCM56218_A0_READ_L2_ENTRY_PARITY_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_L2_ENTRY_PARITY_STATUSr,(r._l2_entry_parity_status))
#define BCM56218_A0_WRITE_L2_ENTRY_PARITY_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_L2_ENTRY_PARITY_STATUSr,&(r._l2_entry_parity_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_ENTRY_PARITY_STATUSr BCM56218_A0_L2_ENTRY_PARITY_STATUSr
#define L2_ENTRY_PARITY_STATUSr_SIZE BCM56218_A0_L2_ENTRY_PARITY_STATUSr_SIZE
typedef BCM56218_A0_L2_ENTRY_PARITY_STATUSr_t L2_ENTRY_PARITY_STATUSr_t;
#define L2_ENTRY_PARITY_STATUSr_CLR BCM56218_A0_L2_ENTRY_PARITY_STATUSr_CLR
#define L2_ENTRY_PARITY_STATUSr_SET BCM56218_A0_L2_ENTRY_PARITY_STATUSr_SET
#define L2_ENTRY_PARITY_STATUSr_GET BCM56218_A0_L2_ENTRY_PARITY_STATUSr_GET
#define L2_ENTRY_PARITY_STATUSr_PARITY_ERRf_GET BCM56218_A0_L2_ENTRY_PARITY_STATUSr_PARITY_ERRf_GET
#define L2_ENTRY_PARITY_STATUSr_PARITY_ERRf_SET BCM56218_A0_L2_ENTRY_PARITY_STATUSr_PARITY_ERRf_SET
#define L2_ENTRY_PARITY_STATUSr_ENTRY_BMf_GET BCM56218_A0_L2_ENTRY_PARITY_STATUSr_ENTRY_BMf_GET
#define L2_ENTRY_PARITY_STATUSr_ENTRY_BMf_SET BCM56218_A0_L2_ENTRY_PARITY_STATUSr_ENTRY_BMf_SET
#define L2_ENTRY_PARITY_STATUSr_BUCKET_IDXf_GET BCM56218_A0_L2_ENTRY_PARITY_STATUSr_BUCKET_IDXf_GET
#define L2_ENTRY_PARITY_STATUSr_BUCKET_IDXf_SET BCM56218_A0_L2_ENTRY_PARITY_STATUSr_BUCKET_IDXf_SET
#define READ_L2_ENTRY_PARITY_STATUSr BCM56218_A0_READ_L2_ENTRY_PARITY_STATUSr
#define WRITE_L2_ENTRY_PARITY_STATUSr BCM56218_A0_WRITE_L2_ENTRY_PARITY_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_L2_ENTRY_PARITY_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  L2_HITDA_ONLY
 * BLOCKS:   IPIPE
 * DESC:     HW managed L2_HITDA_ONLY table.  Just the DA hit bits.
 * SIZE:     8
 * FIELDS:
 *     HITDA_0          Hit bit set on Destination MAC addrs hits
 *     HITDA_1          Hit bit set on Destination MAC addrs hits
 *     HITDA_2          Hit bit set on Destination MAC addrs hits
 *     HITDA_3          Hit bit set on Destination MAC addrs hits
 *     HITDA_4          Hit bit set on Destination MAC addrs hits
 *     HITDA_5          Hit bit set on Destination MAC addrs hits
 *     HITDA_6          Hit bit set on Destination MAC addrs hits
 *     HITDA_7          Hit bit set on Destination MAC addrs hits
 *
 ******************************************************************************/
#define BCM56218_A0_L2_HITDA_ONLYm 0x06720000

#define BCM56218_A0_L2_HITDA_ONLYm_MIN 0
#define BCM56218_A0_L2_HITDA_ONLYm_MAX 1023
#define BCM56218_A0_L2_HITDA_ONLYm_CMAX(u) 1023
#define BCM56218_A0_L2_HITDA_ONLYm_SIZE 1

/*
 * This structure should be used to declare and program L2_HITDA_ONLY.
 *
 */
typedef union BCM56218_A0_L2_HITDA_ONLYm_s {
	uint32_t v[1];
	uint32_t l2_hitda_only[1];
	uint32_t _l2_hitda_only;
} BCM56218_A0_L2_HITDA_ONLYm_t;

#define BCM56218_A0_L2_HITDA_ONLYm_CLR(r) (r).l2_hitda_only[0] = 0
#define BCM56218_A0_L2_HITDA_ONLYm_SET(r,d) (r).l2_hitda_only[0] = d
#define BCM56218_A0_L2_HITDA_ONLYm_GET(r) (r).l2_hitda_only[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_L2_HITDA_ONLYm_HITDA_0f_GET(r) (((r).l2_hitda_only[0]) & 0x1)
#define BCM56218_A0_L2_HITDA_ONLYm_HITDA_0f_SET(r,f) (r).l2_hitda_only[0]=(((r).l2_hitda_only[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_L2_HITDA_ONLYm_HITDA_1f_GET(r) ((((r).l2_hitda_only[0]) >> 1) & 0x1)
#define BCM56218_A0_L2_HITDA_ONLYm_HITDA_1f_SET(r,f) (r).l2_hitda_only[0]=(((r).l2_hitda_only[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_L2_HITDA_ONLYm_HITDA_2f_GET(r) ((((r).l2_hitda_only[0]) >> 2) & 0x1)
#define BCM56218_A0_L2_HITDA_ONLYm_HITDA_2f_SET(r,f) (r).l2_hitda_only[0]=(((r).l2_hitda_only[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_L2_HITDA_ONLYm_HITDA_3f_GET(r) ((((r).l2_hitda_only[0]) >> 3) & 0x1)
#define BCM56218_A0_L2_HITDA_ONLYm_HITDA_3f_SET(r,f) (r).l2_hitda_only[0]=(((r).l2_hitda_only[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56218_A0_L2_HITDA_ONLYm_HITDA_4f_GET(r) ((((r).l2_hitda_only[0]) >> 4) & 0x1)
#define BCM56218_A0_L2_HITDA_ONLYm_HITDA_4f_SET(r,f) (r).l2_hitda_only[0]=(((r).l2_hitda_only[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56218_A0_L2_HITDA_ONLYm_HITDA_5f_GET(r) ((((r).l2_hitda_only[0]) >> 5) & 0x1)
#define BCM56218_A0_L2_HITDA_ONLYm_HITDA_5f_SET(r,f) (r).l2_hitda_only[0]=(((r).l2_hitda_only[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56218_A0_L2_HITDA_ONLYm_HITDA_6f_GET(r) ((((r).l2_hitda_only[0]) >> 6) & 0x1)
#define BCM56218_A0_L2_HITDA_ONLYm_HITDA_6f_SET(r,f) (r).l2_hitda_only[0]=(((r).l2_hitda_only[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56218_A0_L2_HITDA_ONLYm_HITDA_7f_GET(r) ((((r).l2_hitda_only[0]) >> 7) & 0x1)
#define BCM56218_A0_L2_HITDA_ONLYm_HITDA_7f_SET(r,f) (r).l2_hitda_only[0]=(((r).l2_hitda_only[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access L2_HITDA_ONLY.
 *
 */
#define BCM56218_A0_READ_L2_HITDA_ONLYm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_L2_HITDA_ONLYm,i,(m._l2_hitda_only),1)
#define BCM56218_A0_WRITE_L2_HITDA_ONLYm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_L2_HITDA_ONLYm,i,&(m._l2_hitda_only),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_HITDA_ONLYm BCM56218_A0_L2_HITDA_ONLYm
#define L2_HITDA_ONLYm_MIN BCM56218_A0_L2_HITDA_ONLYm_MIN
#define L2_HITDA_ONLYm_MAX BCM56218_A0_L2_HITDA_ONLYm_MAX
#define L2_HITDA_ONLYm_CMAX(u) BCM56218_A0_L2_HITDA_ONLYm_CMAX(u)
#define L2_HITDA_ONLYm_SIZE BCM56218_A0_L2_HITDA_ONLYm_SIZE
typedef BCM56218_A0_L2_HITDA_ONLYm_t L2_HITDA_ONLYm_t;
#define L2_HITDA_ONLYm_CLR BCM56218_A0_L2_HITDA_ONLYm_CLR
#define L2_HITDA_ONLYm_SET BCM56218_A0_L2_HITDA_ONLYm_SET
#define L2_HITDA_ONLYm_GET BCM56218_A0_L2_HITDA_ONLYm_GET
#define L2_HITDA_ONLYm_HITDA_0f_GET BCM56218_A0_L2_HITDA_ONLYm_HITDA_0f_GET
#define L2_HITDA_ONLYm_HITDA_0f_SET BCM56218_A0_L2_HITDA_ONLYm_HITDA_0f_SET
#define L2_HITDA_ONLYm_HITDA_1f_GET BCM56218_A0_L2_HITDA_ONLYm_HITDA_1f_GET
#define L2_HITDA_ONLYm_HITDA_1f_SET BCM56218_A0_L2_HITDA_ONLYm_HITDA_1f_SET
#define L2_HITDA_ONLYm_HITDA_2f_GET BCM56218_A0_L2_HITDA_ONLYm_HITDA_2f_GET
#define L2_HITDA_ONLYm_HITDA_2f_SET BCM56218_A0_L2_HITDA_ONLYm_HITDA_2f_SET
#define L2_HITDA_ONLYm_HITDA_3f_GET BCM56218_A0_L2_HITDA_ONLYm_HITDA_3f_GET
#define L2_HITDA_ONLYm_HITDA_3f_SET BCM56218_A0_L2_HITDA_ONLYm_HITDA_3f_SET
#define L2_HITDA_ONLYm_HITDA_4f_GET BCM56218_A0_L2_HITDA_ONLYm_HITDA_4f_GET
#define L2_HITDA_ONLYm_HITDA_4f_SET BCM56218_A0_L2_HITDA_ONLYm_HITDA_4f_SET
#define L2_HITDA_ONLYm_HITDA_5f_GET BCM56218_A0_L2_HITDA_ONLYm_HITDA_5f_GET
#define L2_HITDA_ONLYm_HITDA_5f_SET BCM56218_A0_L2_HITDA_ONLYm_HITDA_5f_SET
#define L2_HITDA_ONLYm_HITDA_6f_GET BCM56218_A0_L2_HITDA_ONLYm_HITDA_6f_GET
#define L2_HITDA_ONLYm_HITDA_6f_SET BCM56218_A0_L2_HITDA_ONLYm_HITDA_6f_SET
#define L2_HITDA_ONLYm_HITDA_7f_GET BCM56218_A0_L2_HITDA_ONLYm_HITDA_7f_GET
#define L2_HITDA_ONLYm_HITDA_7f_SET BCM56218_A0_L2_HITDA_ONLYm_HITDA_7f_SET
#define READ_L2_HITDA_ONLYm BCM56218_A0_READ_L2_HITDA_ONLYm
#define WRITE_L2_HITDA_ONLYm BCM56218_A0_WRITE_L2_HITDA_ONLYm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_L2_HITDA_ONLYm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  L2_HITSA_ONLY
 * BLOCKS:   IPIPE
 * DESC:     HW managed L2_HITSA_ONLY table.  Just the SA hit bits.
 * SIZE:     8
 * FIELDS:
 *     HITSA_0          Hit bit set on Source MAC addrs hits
 *     HITSA_1          Hit bit set on Source MAC addrs hits
 *     HITSA_2          Hit bit set on Source MAC addrs hits
 *     HITSA_3          Hit bit set on Source MAC addrs hits
 *     HITSA_4          Hit bit set on Source MAC addrs hits
 *     HITSA_5          Hit bit set on Source MAC addrs hits
 *     HITSA_6          Hit bit set on Source MAC addrs hits
 *     HITSA_7          Hit bit set on Source MAC addrs hits
 *
 ******************************************************************************/
#define BCM56218_A0_L2_HITSA_ONLYm 0x06730000

#define BCM56218_A0_L2_HITSA_ONLYm_MIN 0
#define BCM56218_A0_L2_HITSA_ONLYm_MAX 1023
#define BCM56218_A0_L2_HITSA_ONLYm_CMAX(u) 1023
#define BCM56218_A0_L2_HITSA_ONLYm_SIZE 1

/*
 * This structure should be used to declare and program L2_HITSA_ONLY.
 *
 */
typedef union BCM56218_A0_L2_HITSA_ONLYm_s {
	uint32_t v[1];
	uint32_t l2_hitsa_only[1];
	uint32_t _l2_hitsa_only;
} BCM56218_A0_L2_HITSA_ONLYm_t;

#define BCM56218_A0_L2_HITSA_ONLYm_CLR(r) (r).l2_hitsa_only[0] = 0
#define BCM56218_A0_L2_HITSA_ONLYm_SET(r,d) (r).l2_hitsa_only[0] = d
#define BCM56218_A0_L2_HITSA_ONLYm_GET(r) (r).l2_hitsa_only[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_L2_HITSA_ONLYm_HITSA_0f_GET(r) (((r).l2_hitsa_only[0]) & 0x1)
#define BCM56218_A0_L2_HITSA_ONLYm_HITSA_0f_SET(r,f) (r).l2_hitsa_only[0]=(((r).l2_hitsa_only[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_L2_HITSA_ONLYm_HITSA_1f_GET(r) ((((r).l2_hitsa_only[0]) >> 1) & 0x1)
#define BCM56218_A0_L2_HITSA_ONLYm_HITSA_1f_SET(r,f) (r).l2_hitsa_only[0]=(((r).l2_hitsa_only[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_L2_HITSA_ONLYm_HITSA_2f_GET(r) ((((r).l2_hitsa_only[0]) >> 2) & 0x1)
#define BCM56218_A0_L2_HITSA_ONLYm_HITSA_2f_SET(r,f) (r).l2_hitsa_only[0]=(((r).l2_hitsa_only[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_L2_HITSA_ONLYm_HITSA_3f_GET(r) ((((r).l2_hitsa_only[0]) >> 3) & 0x1)
#define BCM56218_A0_L2_HITSA_ONLYm_HITSA_3f_SET(r,f) (r).l2_hitsa_only[0]=(((r).l2_hitsa_only[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56218_A0_L2_HITSA_ONLYm_HITSA_4f_GET(r) ((((r).l2_hitsa_only[0]) >> 4) & 0x1)
#define BCM56218_A0_L2_HITSA_ONLYm_HITSA_4f_SET(r,f) (r).l2_hitsa_only[0]=(((r).l2_hitsa_only[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56218_A0_L2_HITSA_ONLYm_HITSA_5f_GET(r) ((((r).l2_hitsa_only[0]) >> 5) & 0x1)
#define BCM56218_A0_L2_HITSA_ONLYm_HITSA_5f_SET(r,f) (r).l2_hitsa_only[0]=(((r).l2_hitsa_only[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56218_A0_L2_HITSA_ONLYm_HITSA_6f_GET(r) ((((r).l2_hitsa_only[0]) >> 6) & 0x1)
#define BCM56218_A0_L2_HITSA_ONLYm_HITSA_6f_SET(r,f) (r).l2_hitsa_only[0]=(((r).l2_hitsa_only[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56218_A0_L2_HITSA_ONLYm_HITSA_7f_GET(r) ((((r).l2_hitsa_only[0]) >> 7) & 0x1)
#define BCM56218_A0_L2_HITSA_ONLYm_HITSA_7f_SET(r,f) (r).l2_hitsa_only[0]=(((r).l2_hitsa_only[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access L2_HITSA_ONLY.
 *
 */
#define BCM56218_A0_READ_L2_HITSA_ONLYm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_L2_HITSA_ONLYm,i,(m._l2_hitsa_only),1)
#define BCM56218_A0_WRITE_L2_HITSA_ONLYm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_L2_HITSA_ONLYm,i,&(m._l2_hitsa_only),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_HITSA_ONLYm BCM56218_A0_L2_HITSA_ONLYm
#define L2_HITSA_ONLYm_MIN BCM56218_A0_L2_HITSA_ONLYm_MIN
#define L2_HITSA_ONLYm_MAX BCM56218_A0_L2_HITSA_ONLYm_MAX
#define L2_HITSA_ONLYm_CMAX(u) BCM56218_A0_L2_HITSA_ONLYm_CMAX(u)
#define L2_HITSA_ONLYm_SIZE BCM56218_A0_L2_HITSA_ONLYm_SIZE
typedef BCM56218_A0_L2_HITSA_ONLYm_t L2_HITSA_ONLYm_t;
#define L2_HITSA_ONLYm_CLR BCM56218_A0_L2_HITSA_ONLYm_CLR
#define L2_HITSA_ONLYm_SET BCM56218_A0_L2_HITSA_ONLYm_SET
#define L2_HITSA_ONLYm_GET BCM56218_A0_L2_HITSA_ONLYm_GET
#define L2_HITSA_ONLYm_HITSA_0f_GET BCM56218_A0_L2_HITSA_ONLYm_HITSA_0f_GET
#define L2_HITSA_ONLYm_HITSA_0f_SET BCM56218_A0_L2_HITSA_ONLYm_HITSA_0f_SET
#define L2_HITSA_ONLYm_HITSA_1f_GET BCM56218_A0_L2_HITSA_ONLYm_HITSA_1f_GET
#define L2_HITSA_ONLYm_HITSA_1f_SET BCM56218_A0_L2_HITSA_ONLYm_HITSA_1f_SET
#define L2_HITSA_ONLYm_HITSA_2f_GET BCM56218_A0_L2_HITSA_ONLYm_HITSA_2f_GET
#define L2_HITSA_ONLYm_HITSA_2f_SET BCM56218_A0_L2_HITSA_ONLYm_HITSA_2f_SET
#define L2_HITSA_ONLYm_HITSA_3f_GET BCM56218_A0_L2_HITSA_ONLYm_HITSA_3f_GET
#define L2_HITSA_ONLYm_HITSA_3f_SET BCM56218_A0_L2_HITSA_ONLYm_HITSA_3f_SET
#define L2_HITSA_ONLYm_HITSA_4f_GET BCM56218_A0_L2_HITSA_ONLYm_HITSA_4f_GET
#define L2_HITSA_ONLYm_HITSA_4f_SET BCM56218_A0_L2_HITSA_ONLYm_HITSA_4f_SET
#define L2_HITSA_ONLYm_HITSA_5f_GET BCM56218_A0_L2_HITSA_ONLYm_HITSA_5f_GET
#define L2_HITSA_ONLYm_HITSA_5f_SET BCM56218_A0_L2_HITSA_ONLYm_HITSA_5f_SET
#define L2_HITSA_ONLYm_HITSA_6f_GET BCM56218_A0_L2_HITSA_ONLYm_HITSA_6f_GET
#define L2_HITSA_ONLYm_HITSA_6f_SET BCM56218_A0_L2_HITSA_ONLYm_HITSA_6f_SET
#define L2_HITSA_ONLYm_HITSA_7f_GET BCM56218_A0_L2_HITSA_ONLYm_HITSA_7f_GET
#define L2_HITSA_ONLYm_HITSA_7f_SET BCM56218_A0_L2_HITSA_ONLYm_HITSA_7f_SET
#define READ_L2_HITSA_ONLYm BCM56218_A0_READ_L2_HITSA_ONLYm
#define WRITE_L2_HITSA_ONLYm BCM56218_A0_WRITE_L2_HITSA_ONLYm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_L2_HITSA_ONLYm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  L2_HIT_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     L2_HIT_CONTROL
 * SIZE:     32
 * FIELDS:
 *     HITDA_CCM        CCM debug bit for L2_HITDA RAM
 *     HITSA_CCM        CCM debug bit for L2_HITSA RAM
 *     HITDA_RM         RM debug bit for L2_HITDA RAM
 *     HITSA_RM         RM debug bit for L2_HITSA RAM
 *
 ******************************************************************************/
#define BCM56218_A0_L2_HIT_CONTROLr 0x0678000b

#define BCM56218_A0_L2_HIT_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program L2_HIT_CONTROL.
 *
 */
typedef union BCM56218_A0_L2_HIT_CONTROLr_s {
	uint32_t v[1];
	uint32_t l2_hit_control[1];
	uint32_t _l2_hit_control;
} BCM56218_A0_L2_HIT_CONTROLr_t;

#define BCM56218_A0_L2_HIT_CONTROLr_CLR(r) (r).l2_hit_control[0] = 0
#define BCM56218_A0_L2_HIT_CONTROLr_SET(r,d) (r).l2_hit_control[0] = d
#define BCM56218_A0_L2_HIT_CONTROLr_GET(r) (r).l2_hit_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_L2_HIT_CONTROLr_HITDA_CCMf_GET(r) (((r).l2_hit_control[0]) & 0x1)
#define BCM56218_A0_L2_HIT_CONTROLr_HITDA_CCMf_SET(r,f) (r).l2_hit_control[0]=(((r).l2_hit_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_L2_HIT_CONTROLr_HITSA_CCMf_GET(r) (((r).l2_hit_control[0]) & 0x1)
#define BCM56218_A0_L2_HIT_CONTROLr_HITSA_CCMf_SET(r,f) (r).l2_hit_control[0]=(((r).l2_hit_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_L2_HIT_CONTROLr_HITDA_RMf_GET(r) ((((r).l2_hit_control[0]) >> 1) & 0x1)
#define BCM56218_A0_L2_HIT_CONTROLr_HITDA_RMf_SET(r,f) (r).l2_hit_control[0]=(((r).l2_hit_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_L2_HIT_CONTROLr_HITSA_RMf_GET(r) ((((r).l2_hit_control[0]) >> 1) & 0x1)
#define BCM56218_A0_L2_HIT_CONTROLr_HITSA_RMf_SET(r,f) (r).l2_hit_control[0]=(((r).l2_hit_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access L2_HIT_CONTROL.
 *
 */
#define BCM56218_A0_READ_L2_HIT_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_L2_HIT_CONTROLr,(r._l2_hit_control))
#define BCM56218_A0_WRITE_L2_HIT_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_L2_HIT_CONTROLr,&(r._l2_hit_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_HIT_CONTROLr BCM56218_A0_L2_HIT_CONTROLr
#define L2_HIT_CONTROLr_SIZE BCM56218_A0_L2_HIT_CONTROLr_SIZE
typedef BCM56218_A0_L2_HIT_CONTROLr_t L2_HIT_CONTROLr_t;
#define L2_HIT_CONTROLr_CLR BCM56218_A0_L2_HIT_CONTROLr_CLR
#define L2_HIT_CONTROLr_SET BCM56218_A0_L2_HIT_CONTROLr_SET
#define L2_HIT_CONTROLr_GET BCM56218_A0_L2_HIT_CONTROLr_GET
#define L2_HIT_CONTROLr_HITDA_CCMf_GET BCM56218_A0_L2_HIT_CONTROLr_HITDA_CCMf_GET
#define L2_HIT_CONTROLr_HITDA_CCMf_SET BCM56218_A0_L2_HIT_CONTROLr_HITDA_CCMf_SET
#define L2_HIT_CONTROLr_HITSA_CCMf_GET BCM56218_A0_L2_HIT_CONTROLr_HITSA_CCMf_GET
#define L2_HIT_CONTROLr_HITSA_CCMf_SET BCM56218_A0_L2_HIT_CONTROLr_HITSA_CCMf_SET
#define L2_HIT_CONTROLr_HITDA_RMf_GET BCM56218_A0_L2_HIT_CONTROLr_HITDA_RMf_GET
#define L2_HIT_CONTROLr_HITDA_RMf_SET BCM56218_A0_L2_HIT_CONTROLr_HITDA_RMf_SET
#define L2_HIT_CONTROLr_HITSA_RMf_GET BCM56218_A0_L2_HIT_CONTROLr_HITSA_RMf_GET
#define L2_HIT_CONTROLr_HITSA_RMf_SET BCM56218_A0_L2_HIT_CONTROLr_HITSA_RMf_SET
#define READ_L2_HIT_CONTROLr BCM56218_A0_READ_L2_HIT_CONTROLr
#define WRITE_L2_HIT_CONTROLr BCM56218_A0_WRITE_L2_HIT_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_L2_HIT_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  L2_MOD_FIFO
 * BLOCKS:   IPIPE
 * DESC:     FIFO for operations that MODify the L2_ENTRY table.
 * SIZE:     107
 * FIELDS:
 *     OPER             Operation type:  11->DELETE, 10->PPA_REPLACE, 00->WRITE, 01->reserved
 *     ENTRY_IDX        Index to the entry of the L2_ENTRY table modified.  Valid only for WRITE operations.
 *     BUCKET_IDX       Index to the bucket of the L2_ENTRY table affected.
 *     RESERVED0        RESERVED bit 
 *     WR_DATA          Overlay for WRITE operations.  All the L2_ENTRY fields specified in the L2_ENTRY_ONLY view
 *     WR_DATA_OR_REPL_DEL_BM Overlay for WRITE operation:  All the L2_ENTRY fields specified in the L2_ENTRY_ONLY view; used for L2_INSERT, LEARN, and MEMWR.  ...or...  Bitmap or bucket entries affected for DELETE and PPA_REPLACE operations; only 8 bits are valid for this overlay.
 *     DELETE_OR_REPL_BM Overlay for DELETE or PPA REPLACE operations.  Bitmap for bucket entries affected.
 *
 ******************************************************************************/
#define BCM56218_A0_L2_MOD_FIFOm 0x06770000

#define BCM56218_A0_L2_MOD_FIFOm_MIN 0
#define BCM56218_A0_L2_MOD_FIFOm_MAX 15
#define BCM56218_A0_L2_MOD_FIFOm_CMAX(u) 15
#define BCM56218_A0_L2_MOD_FIFOm_SIZE 14

/*
 * This structure should be used to declare and program L2_MOD_FIFO.
 *
 */
typedef union BCM56218_A0_L2_MOD_FIFOm_s {
	uint32_t v[4];
	uint32_t l2_mod_fifo[4];
	uint32_t _l2_mod_fifo;
} BCM56218_A0_L2_MOD_FIFOm_t;

#define BCM56218_A0_L2_MOD_FIFOm_CLR(r) CDK_MEMSET(&((r)._l2_mod_fifo), 0, sizeof(BCM56218_A0_L2_MOD_FIFOm_t))
#define BCM56218_A0_L2_MOD_FIFOm_SET(r,i,d) (r).l2_mod_fifo[i] = d
#define BCM56218_A0_L2_MOD_FIFOm_GET(r,i) (r).l2_mod_fifo[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_L2_MOD_FIFOm_OPERf_GET(r) (((r).l2_mod_fifo[0]) & 0x3)
#define BCM56218_A0_L2_MOD_FIFOm_OPERf_SET(r,f) (r).l2_mod_fifo[0]=(((r).l2_mod_fifo[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56218_A0_L2_MOD_FIFOm_ENTRY_IDXf_GET(r) ((((r).l2_mod_fifo[0]) >> 2) & 0x7)
#define BCM56218_A0_L2_MOD_FIFOm_ENTRY_IDXf_SET(r,f) (r).l2_mod_fifo[0]=(((r).l2_mod_fifo[0] & ~((uint32_t)0x7 << 2)) | ((((uint32_t)f) & 0x7) << 2))
#define BCM56218_A0_L2_MOD_FIFOm_BUCKET_IDXf_GET(r) ((((r).l2_mod_fifo[0]) >> 5) & 0x3ff)
#define BCM56218_A0_L2_MOD_FIFOm_BUCKET_IDXf_SET(r,f) (r).l2_mod_fifo[0]=(((r).l2_mod_fifo[0] & ~((uint32_t)0x3ff << 5)) | ((((uint32_t)f) & 0x3ff) << 5))
#define BCM56218_A0_L2_MOD_FIFOm_RESERVED0f_GET(r) ((((r).l2_mod_fifo[0]) >> 15) & 0x1)
#define BCM56218_A0_L2_MOD_FIFOm_RESERVED0f_SET(r,f) (r).l2_mod_fifo[0]=(((r).l2_mod_fifo[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56218_A0_L2_MOD_FIFOm_WR_DATAf_GET(r,a) cdk_field_get((r).l2_mod_fifo,16,106,a)
#define BCM56218_A0_L2_MOD_FIFOm_WR_DATAf_SET(r,a) cdk_field_set((r).l2_mod_fifo,16,106,a)
#define BCM56218_A0_L2_MOD_FIFOm_WR_DATA_OR_REPL_DEL_BMf_GET(r,a) cdk_field_get((r).l2_mod_fifo,16,106,a)
#define BCM56218_A0_L2_MOD_FIFOm_WR_DATA_OR_REPL_DEL_BMf_SET(r,a) cdk_field_set((r).l2_mod_fifo,16,106,a)
#define BCM56218_A0_L2_MOD_FIFOm_DELETE_OR_REPL_BMf_GET(r) ((((r).l2_mod_fifo[0]) >> 16) & 0xff)
#define BCM56218_A0_L2_MOD_FIFOm_DELETE_OR_REPL_BMf_SET(r,f) (r).l2_mod_fifo[0]=(((r).l2_mod_fifo[0] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))

/*
 * These macros can be used to access L2_MOD_FIFO.
 *
 */
#define BCM56218_A0_READ_L2_MOD_FIFOm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_L2_MOD_FIFOm,i,(m._l2_mod_fifo),4)
#define BCM56218_A0_WRITE_L2_MOD_FIFOm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_L2_MOD_FIFOm,i,&(m._l2_mod_fifo),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_MOD_FIFOm BCM56218_A0_L2_MOD_FIFOm
#define L2_MOD_FIFOm_MIN BCM56218_A0_L2_MOD_FIFOm_MIN
#define L2_MOD_FIFOm_MAX BCM56218_A0_L2_MOD_FIFOm_MAX
#define L2_MOD_FIFOm_CMAX(u) BCM56218_A0_L2_MOD_FIFOm_CMAX(u)
#define L2_MOD_FIFOm_SIZE BCM56218_A0_L2_MOD_FIFOm_SIZE
typedef BCM56218_A0_L2_MOD_FIFOm_t L2_MOD_FIFOm_t;
#define L2_MOD_FIFOm_CLR BCM56218_A0_L2_MOD_FIFOm_CLR
#define L2_MOD_FIFOm_SET BCM56218_A0_L2_MOD_FIFOm_SET
#define L2_MOD_FIFOm_GET BCM56218_A0_L2_MOD_FIFOm_GET
#define L2_MOD_FIFOm_OPERf_GET BCM56218_A0_L2_MOD_FIFOm_OPERf_GET
#define L2_MOD_FIFOm_OPERf_SET BCM56218_A0_L2_MOD_FIFOm_OPERf_SET
#define L2_MOD_FIFOm_ENTRY_IDXf_GET BCM56218_A0_L2_MOD_FIFOm_ENTRY_IDXf_GET
#define L2_MOD_FIFOm_ENTRY_IDXf_SET BCM56218_A0_L2_MOD_FIFOm_ENTRY_IDXf_SET
#define L2_MOD_FIFOm_BUCKET_IDXf_GET BCM56218_A0_L2_MOD_FIFOm_BUCKET_IDXf_GET
#define L2_MOD_FIFOm_BUCKET_IDXf_SET BCM56218_A0_L2_MOD_FIFOm_BUCKET_IDXf_SET
#define L2_MOD_FIFOm_RESERVED0f_GET BCM56218_A0_L2_MOD_FIFOm_RESERVED0f_GET
#define L2_MOD_FIFOm_RESERVED0f_SET BCM56218_A0_L2_MOD_FIFOm_RESERVED0f_SET
#define L2_MOD_FIFOm_WR_DATAf_GET BCM56218_A0_L2_MOD_FIFOm_WR_DATAf_GET
#define L2_MOD_FIFOm_WR_DATAf_SET BCM56218_A0_L2_MOD_FIFOm_WR_DATAf_SET
#define L2_MOD_FIFOm_WR_DATA_OR_REPL_DEL_BMf_GET BCM56218_A0_L2_MOD_FIFOm_WR_DATA_OR_REPL_DEL_BMf_GET
#define L2_MOD_FIFOm_WR_DATA_OR_REPL_DEL_BMf_SET BCM56218_A0_L2_MOD_FIFOm_WR_DATA_OR_REPL_DEL_BMf_SET
#define L2_MOD_FIFOm_DELETE_OR_REPL_BMf_GET BCM56218_A0_L2_MOD_FIFOm_DELETE_OR_REPL_BMf_GET
#define L2_MOD_FIFOm_DELETE_OR_REPL_BMf_SET BCM56218_A0_L2_MOD_FIFOm_DELETE_OR_REPL_BMf_SET
#define READ_L2_MOD_FIFOm BCM56218_A0_READ_L2_MOD_FIFOm
#define WRITE_L2_MOD_FIFOm BCM56218_A0_WRITE_L2_MOD_FIFOm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_L2_MOD_FIFOm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  L2_MOD_FIFO_CNT
 * BLOCKS:   IPIPE
 * DESC:     L2_MOD_FIFO_CNT
 * SIZE:     32
 * FIELDS:
 *     NUM_OF_ENTRIES   A count of the number of entries in the L2_MOD_FIFO.  This is actually the hardware write pointer, so it points to the last entry in the buffer.
 *
 ******************************************************************************/
#define BCM56218_A0_L2_MOD_FIFO_CNTr 0x0678000a

#define BCM56218_A0_L2_MOD_FIFO_CNTr_SIZE 4

/*
 * This structure should be used to declare and program L2_MOD_FIFO_CNT.
 *
 */
typedef union BCM56218_A0_L2_MOD_FIFO_CNTr_s {
	uint32_t v[1];
	uint32_t l2_mod_fifo_cnt[1];
	uint32_t _l2_mod_fifo_cnt;
} BCM56218_A0_L2_MOD_FIFO_CNTr_t;

#define BCM56218_A0_L2_MOD_FIFO_CNTr_CLR(r) (r).l2_mod_fifo_cnt[0] = 0
#define BCM56218_A0_L2_MOD_FIFO_CNTr_SET(r,d) (r).l2_mod_fifo_cnt[0] = d
#define BCM56218_A0_L2_MOD_FIFO_CNTr_GET(r) (r).l2_mod_fifo_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_L2_MOD_FIFO_CNTr_NUM_OF_ENTRIESf_GET(r) (((r).l2_mod_fifo_cnt[0]) & 0x1f)
#define BCM56218_A0_L2_MOD_FIFO_CNTr_NUM_OF_ENTRIESf_SET(r,f) (r).l2_mod_fifo_cnt[0]=(((r).l2_mod_fifo_cnt[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))

/*
 * These macros can be used to access L2_MOD_FIFO_CNT.
 *
 */
#define BCM56218_A0_READ_L2_MOD_FIFO_CNTr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_L2_MOD_FIFO_CNTr,(r._l2_mod_fifo_cnt))
#define BCM56218_A0_WRITE_L2_MOD_FIFO_CNTr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_L2_MOD_FIFO_CNTr,&(r._l2_mod_fifo_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_MOD_FIFO_CNTr BCM56218_A0_L2_MOD_FIFO_CNTr
#define L2_MOD_FIFO_CNTr_SIZE BCM56218_A0_L2_MOD_FIFO_CNTr_SIZE
typedef BCM56218_A0_L2_MOD_FIFO_CNTr_t L2_MOD_FIFO_CNTr_t;
#define L2_MOD_FIFO_CNTr_CLR BCM56218_A0_L2_MOD_FIFO_CNTr_CLR
#define L2_MOD_FIFO_CNTr_SET BCM56218_A0_L2_MOD_FIFO_CNTr_SET
#define L2_MOD_FIFO_CNTr_GET BCM56218_A0_L2_MOD_FIFO_CNTr_GET
#define L2_MOD_FIFO_CNTr_NUM_OF_ENTRIESf_GET BCM56218_A0_L2_MOD_FIFO_CNTr_NUM_OF_ENTRIESf_GET
#define L2_MOD_FIFO_CNTr_NUM_OF_ENTRIESf_SET BCM56218_A0_L2_MOD_FIFO_CNTr_NUM_OF_ENTRIESf_SET
#define READ_L2_MOD_FIFO_CNTr BCM56218_A0_READ_L2_MOD_FIFO_CNTr
#define WRITE_L2_MOD_FIFO_CNTr BCM56218_A0_WRITE_L2_MOD_FIFO_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_L2_MOD_FIFO_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  L2_USER_ENTRY
 * BLOCKS:   IPIPE
 * DESC:     Combined L2_ENTRY TCAM/Data RAM for guaranteed L2 entries and BPDUs.
 * SIZE:     141
 * FIELDS:
 *     VALID            Indicates that the entry is valid
 *     MAC_ADDR         MAC address
 *     VLAN_ID          VLAN ID
 *     MASK             Mask for the {VLAN_ID, MAC_ADDR}
 *     PRI              Priority
 *     CPU              CPU bit
 *     L3               Indicates an L3 entry
 *     RPE              RPE bit
 *     MIRROR           Mirror bit
 *     DST_DISCARD      Dst Discard
 *     PORT_TGID        Port or TGID
 *     MODULE_ID        Module ID
 *     BPDU             Indicates entry is a BPDU
 *
 ******************************************************************************/
#define BCM56218_A0_L2_USER_ENTRYm 0x06740000

#define BCM56218_A0_L2_USER_ENTRYm_MIN 0
#define BCM56218_A0_L2_USER_ENTRYm_MAX 127
#define BCM56218_A0_L2_USER_ENTRYm_CMAX(u) 127
#define BCM56218_A0_L2_USER_ENTRYm_SIZE 18

/*
 * This structure should be used to declare and program L2_USER_ENTRY.
 *
 */
typedef union BCM56218_A0_L2_USER_ENTRYm_s {
	uint32_t v[5];
	uint32_t l2_user_entry[5];
	uint32_t _l2_user_entry;
} BCM56218_A0_L2_USER_ENTRYm_t;

#define BCM56218_A0_L2_USER_ENTRYm_CLR(r) CDK_MEMSET(&((r)._l2_user_entry), 0, sizeof(BCM56218_A0_L2_USER_ENTRYm_t))
#define BCM56218_A0_L2_USER_ENTRYm_SET(r,i,d) (r).l2_user_entry[i] = d
#define BCM56218_A0_L2_USER_ENTRYm_GET(r,i) (r).l2_user_entry[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_L2_USER_ENTRYm_VALIDf_GET(r) (((r).l2_user_entry[0]) & 0x1)
#define BCM56218_A0_L2_USER_ENTRYm_VALIDf_SET(r,f) (r).l2_user_entry[0]=(((r).l2_user_entry[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_L2_USER_ENTRYm_MAC_ADDRf_GET(r,a) cdk_field_get((r).l2_user_entry,1,48,a)
#define BCM56218_A0_L2_USER_ENTRYm_MAC_ADDRf_SET(r,a) cdk_field_set((r).l2_user_entry,1,48,a)
#define BCM56218_A0_L2_USER_ENTRYm_VLAN_IDf_GET(r) ((((r).l2_user_entry[1]) >> 17) & 0xfff)
#define BCM56218_A0_L2_USER_ENTRYm_VLAN_IDf_SET(r,f) (r).l2_user_entry[1]=(((r).l2_user_entry[1] & ~((uint32_t)0xfff << 17)) | ((((uint32_t)f) & 0xfff) << 17))
#define BCM56218_A0_L2_USER_ENTRYm_MASKf_GET(r,a) cdk_field_get((r).l2_user_entry,61,120,a)
#define BCM56218_A0_L2_USER_ENTRYm_MASKf_SET(r,a) cdk_field_set((r).l2_user_entry,61,120,a)
#define BCM56218_A0_L2_USER_ENTRYm_PRIf_GET(r) ((((r).l2_user_entry[3]) >> 25) & 0x7)
#define BCM56218_A0_L2_USER_ENTRYm_PRIf_SET(r,f) (r).l2_user_entry[3]=(((r).l2_user_entry[3] & ~((uint32_t)0x7 << 25)) | ((((uint32_t)f) & 0x7) << 25))
#define BCM56218_A0_L2_USER_ENTRYm_CPUf_GET(r) ((((r).l2_user_entry[3]) >> 28) & 0x1)
#define BCM56218_A0_L2_USER_ENTRYm_CPUf_SET(r,f) (r).l2_user_entry[3]=(((r).l2_user_entry[3] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM56218_A0_L2_USER_ENTRYm_L3f_GET(r) ((((r).l2_user_entry[3]) >> 29) & 0x1)
#define BCM56218_A0_L2_USER_ENTRYm_L3f_SET(r,f) (r).l2_user_entry[3]=(((r).l2_user_entry[3] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM56218_A0_L2_USER_ENTRYm_RPEf_GET(r) ((((r).l2_user_entry[3]) >> 30) & 0x1)
#define BCM56218_A0_L2_USER_ENTRYm_RPEf_SET(r,f) (r).l2_user_entry[3]=(((r).l2_user_entry[3] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM56218_A0_L2_USER_ENTRYm_MIRRORf_GET(r) ((((r).l2_user_entry[3]) >> 31) & 0x1)
#define BCM56218_A0_L2_USER_ENTRYm_MIRRORf_SET(r,f) (r).l2_user_entry[3]=(((r).l2_user_entry[3] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM56218_A0_L2_USER_ENTRYm_DST_DISCARDf_GET(r) (((r).l2_user_entry[4]) & 0x1)
#define BCM56218_A0_L2_USER_ENTRYm_DST_DISCARDf_SET(r,f) (r).l2_user_entry[4]=(((r).l2_user_entry[4] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_L2_USER_ENTRYm_PORT_TGIDf_GET(r) ((((r).l2_user_entry[4]) >> 1) & 0x7f)
#define BCM56218_A0_L2_USER_ENTRYm_PORT_TGIDf_SET(r,f) (r).l2_user_entry[4]=(((r).l2_user_entry[4] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))
#define BCM56218_A0_L2_USER_ENTRYm_MODULE_IDf_GET(r) ((((r).l2_user_entry[4]) >> 8) & 0xf)
#define BCM56218_A0_L2_USER_ENTRYm_MODULE_IDf_SET(r,f) (r).l2_user_entry[4]=(((r).l2_user_entry[4] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM56218_A0_L2_USER_ENTRYm_BPDUf_GET(r) ((((r).l2_user_entry[4]) >> 12) & 0x1)
#define BCM56218_A0_L2_USER_ENTRYm_BPDUf_SET(r,f) (r).l2_user_entry[4]=(((r).l2_user_entry[4] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))

/*
 * These macros can be used to access L2_USER_ENTRY.
 *
 */
#define BCM56218_A0_READ_L2_USER_ENTRYm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_L2_USER_ENTRYm,i,(m._l2_user_entry),5)
#define BCM56218_A0_WRITE_L2_USER_ENTRYm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_L2_USER_ENTRYm,i,&(m._l2_user_entry),5)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_USER_ENTRYm BCM56218_A0_L2_USER_ENTRYm
#define L2_USER_ENTRYm_MIN BCM56218_A0_L2_USER_ENTRYm_MIN
#define L2_USER_ENTRYm_MAX BCM56218_A0_L2_USER_ENTRYm_MAX
#define L2_USER_ENTRYm_CMAX(u) BCM56218_A0_L2_USER_ENTRYm_CMAX(u)
#define L2_USER_ENTRYm_SIZE BCM56218_A0_L2_USER_ENTRYm_SIZE
typedef BCM56218_A0_L2_USER_ENTRYm_t L2_USER_ENTRYm_t;
#define L2_USER_ENTRYm_CLR BCM56218_A0_L2_USER_ENTRYm_CLR
#define L2_USER_ENTRYm_SET BCM56218_A0_L2_USER_ENTRYm_SET
#define L2_USER_ENTRYm_GET BCM56218_A0_L2_USER_ENTRYm_GET
#define L2_USER_ENTRYm_VALIDf_GET BCM56218_A0_L2_USER_ENTRYm_VALIDf_GET
#define L2_USER_ENTRYm_VALIDf_SET BCM56218_A0_L2_USER_ENTRYm_VALIDf_SET
#define L2_USER_ENTRYm_MAC_ADDRf_GET BCM56218_A0_L2_USER_ENTRYm_MAC_ADDRf_GET
#define L2_USER_ENTRYm_MAC_ADDRf_SET BCM56218_A0_L2_USER_ENTRYm_MAC_ADDRf_SET
#define L2_USER_ENTRYm_VLAN_IDf_GET BCM56218_A0_L2_USER_ENTRYm_VLAN_IDf_GET
#define L2_USER_ENTRYm_VLAN_IDf_SET BCM56218_A0_L2_USER_ENTRYm_VLAN_IDf_SET
#define L2_USER_ENTRYm_MASKf_GET BCM56218_A0_L2_USER_ENTRYm_MASKf_GET
#define L2_USER_ENTRYm_MASKf_SET BCM56218_A0_L2_USER_ENTRYm_MASKf_SET
#define L2_USER_ENTRYm_PRIf_GET BCM56218_A0_L2_USER_ENTRYm_PRIf_GET
#define L2_USER_ENTRYm_PRIf_SET BCM56218_A0_L2_USER_ENTRYm_PRIf_SET
#define L2_USER_ENTRYm_CPUf_GET BCM56218_A0_L2_USER_ENTRYm_CPUf_GET
#define L2_USER_ENTRYm_CPUf_SET BCM56218_A0_L2_USER_ENTRYm_CPUf_SET
#define L2_USER_ENTRYm_L3f_GET BCM56218_A0_L2_USER_ENTRYm_L3f_GET
#define L2_USER_ENTRYm_L3f_SET BCM56218_A0_L2_USER_ENTRYm_L3f_SET
#define L2_USER_ENTRYm_RPEf_GET BCM56218_A0_L2_USER_ENTRYm_RPEf_GET
#define L2_USER_ENTRYm_RPEf_SET BCM56218_A0_L2_USER_ENTRYm_RPEf_SET
#define L2_USER_ENTRYm_MIRRORf_GET BCM56218_A0_L2_USER_ENTRYm_MIRRORf_GET
#define L2_USER_ENTRYm_MIRRORf_SET BCM56218_A0_L2_USER_ENTRYm_MIRRORf_SET
#define L2_USER_ENTRYm_DST_DISCARDf_GET BCM56218_A0_L2_USER_ENTRYm_DST_DISCARDf_GET
#define L2_USER_ENTRYm_DST_DISCARDf_SET BCM56218_A0_L2_USER_ENTRYm_DST_DISCARDf_SET
#define L2_USER_ENTRYm_PORT_TGIDf_GET BCM56218_A0_L2_USER_ENTRYm_PORT_TGIDf_GET
#define L2_USER_ENTRYm_PORT_TGIDf_SET BCM56218_A0_L2_USER_ENTRYm_PORT_TGIDf_SET
#define L2_USER_ENTRYm_MODULE_IDf_GET BCM56218_A0_L2_USER_ENTRYm_MODULE_IDf_GET
#define L2_USER_ENTRYm_MODULE_IDf_SET BCM56218_A0_L2_USER_ENTRYm_MODULE_IDf_SET
#define L2_USER_ENTRYm_BPDUf_GET BCM56218_A0_L2_USER_ENTRYm_BPDUf_GET
#define L2_USER_ENTRYm_BPDUf_SET BCM56218_A0_L2_USER_ENTRYm_BPDUf_SET
#define READ_L2_USER_ENTRYm BCM56218_A0_READ_L2_USER_ENTRYm
#define WRITE_L2_USER_ENTRYm BCM56218_A0_WRITE_L2_USER_ENTRYm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_L2_USER_ENTRYm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  L2_USER_ENTRY_CAM_BIST_S10_STATUS
 * BLOCKS:   IPIPE
 * DESC:     L2_USER_ENTRY_CAM_BIST_S10_STATUS
 * SIZE:     32
 * FIELDS:
 *     S10_STATUS       S10_STATUS
 *
 ******************************************************************************/
#define BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S10_STATUSr 0x06780008

#define BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S10_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program L2_USER_ENTRY_CAM_BIST_S10_STATUS.
 *
 */
typedef union BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S10_STATUSr_s {
	uint32_t v[1];
	uint32_t l2_user_entry_cam_bist_s10_status[1];
	uint32_t _l2_user_entry_cam_bist_s10_status;
} BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S10_STATUSr_t;

#define BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S10_STATUSr_CLR(r) (r).l2_user_entry_cam_bist_s10_status[0] = 0
#define BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S10_STATUSr_SET(r,d) (r).l2_user_entry_cam_bist_s10_status[0] = d
#define BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S10_STATUSr_GET(r) (r).l2_user_entry_cam_bist_s10_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S10_STATUSr_S10_STATUSf_GET(r) (((r).l2_user_entry_cam_bist_s10_status[0]) & 0xff)
#define BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S10_STATUSr_S10_STATUSf_SET(r,f) (r).l2_user_entry_cam_bist_s10_status[0]=(((r).l2_user_entry_cam_bist_s10_status[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access L2_USER_ENTRY_CAM_BIST_S10_STATUS.
 *
 */
#define BCM56218_A0_READ_L2_USER_ENTRY_CAM_BIST_S10_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S10_STATUSr,(r._l2_user_entry_cam_bist_s10_status))
#define BCM56218_A0_WRITE_L2_USER_ENTRY_CAM_BIST_S10_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S10_STATUSr,&(r._l2_user_entry_cam_bist_s10_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_USER_ENTRY_CAM_BIST_S10_STATUSr BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S10_STATUSr
#define L2_USER_ENTRY_CAM_BIST_S10_STATUSr_SIZE BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S10_STATUSr_SIZE
typedef BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S10_STATUSr_t L2_USER_ENTRY_CAM_BIST_S10_STATUSr_t;
#define L2_USER_ENTRY_CAM_BIST_S10_STATUSr_CLR BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S10_STATUSr_CLR
#define L2_USER_ENTRY_CAM_BIST_S10_STATUSr_SET BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S10_STATUSr_SET
#define L2_USER_ENTRY_CAM_BIST_S10_STATUSr_GET BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S10_STATUSr_GET
#define L2_USER_ENTRY_CAM_BIST_S10_STATUSr_S10_STATUSf_GET BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S10_STATUSr_S10_STATUSf_GET
#define L2_USER_ENTRY_CAM_BIST_S10_STATUSr_S10_STATUSf_SET BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S10_STATUSr_S10_STATUSf_SET
#define READ_L2_USER_ENTRY_CAM_BIST_S10_STATUSr BCM56218_A0_READ_L2_USER_ENTRY_CAM_BIST_S10_STATUSr
#define WRITE_L2_USER_ENTRY_CAM_BIST_S10_STATUSr BCM56218_A0_WRITE_L2_USER_ENTRY_CAM_BIST_S10_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S10_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  L2_USER_ENTRY_CAM_BIST_S2_STATUS
 * BLOCKS:   IPIPE
 * DESC:     L2_USER_ENTRY_CAM_BIST_S2_STATUS
 * SIZE:     32
 * FIELDS:
 *     S2_STATUS        L2_USER_ENTRY_CAM_BIST_BIST_S2_STATUS
 *
 ******************************************************************************/
#define BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr 0x06780003

#define BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program L2_USER_ENTRY_CAM_BIST_S2_STATUS.
 *
 */
typedef union BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr_s {
	uint32_t v[1];
	uint32_t l2_user_entry_cam_bist_s2_status[1];
	uint32_t _l2_user_entry_cam_bist_s2_status;
} BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr_t;

#define BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr_CLR(r) (r).l2_user_entry_cam_bist_s2_status[0] = 0
#define BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr_SET(r,d) (r).l2_user_entry_cam_bist_s2_status[0] = d
#define BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr_GET(r) (r).l2_user_entry_cam_bist_s2_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr_S2_STATUSf_GET(r) (((r).l2_user_entry_cam_bist_s2_status[0]) & 0x7fff)
#define BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr_S2_STATUSf_SET(r,f) (r).l2_user_entry_cam_bist_s2_status[0]=(((r).l2_user_entry_cam_bist_s2_status[0] & ~((uint32_t)0x7fff)) | (((uint32_t)f) & 0x7fff))

/*
 * These macros can be used to access L2_USER_ENTRY_CAM_BIST_S2_STATUS.
 *
 */
#define BCM56218_A0_READ_L2_USER_ENTRY_CAM_BIST_S2_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr,(r._l2_user_entry_cam_bist_s2_status))
#define BCM56218_A0_WRITE_L2_USER_ENTRY_CAM_BIST_S2_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr,&(r._l2_user_entry_cam_bist_s2_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_USER_ENTRY_CAM_BIST_S2_STATUSr BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr
#define L2_USER_ENTRY_CAM_BIST_S2_STATUSr_SIZE BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr_SIZE
typedef BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr_t L2_USER_ENTRY_CAM_BIST_S2_STATUSr_t;
#define L2_USER_ENTRY_CAM_BIST_S2_STATUSr_CLR BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr_CLR
#define L2_USER_ENTRY_CAM_BIST_S2_STATUSr_SET BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr_SET
#define L2_USER_ENTRY_CAM_BIST_S2_STATUSr_GET BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr_GET
#define L2_USER_ENTRY_CAM_BIST_S2_STATUSr_S2_STATUSf_GET BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr_S2_STATUSf_GET
#define L2_USER_ENTRY_CAM_BIST_S2_STATUSr_S2_STATUSf_SET BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr_S2_STATUSf_SET
#define READ_L2_USER_ENTRY_CAM_BIST_S2_STATUSr BCM56218_A0_READ_L2_USER_ENTRY_CAM_BIST_S2_STATUSr
#define WRITE_L2_USER_ENTRY_CAM_BIST_S2_STATUSr BCM56218_A0_WRITE_L2_USER_ENTRY_CAM_BIST_S2_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  L2_USER_ENTRY_CAM_BIST_S3_STATUS
 * BLOCKS:   IPIPE
 * DESC:     L2_USER_ENTRY_CAM_BIST_S3_STATUS
 * SIZE:     32
 * FIELDS:
 *     S3_STATUS        S3_STATUS
 *
 ******************************************************************************/
#define BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr 0x06780004

#define BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program L2_USER_ENTRY_CAM_BIST_S3_STATUS.
 *
 */
typedef union BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr_s {
	uint32_t v[1];
	uint32_t l2_user_entry_cam_bist_s3_status[1];
	uint32_t _l2_user_entry_cam_bist_s3_status;
} BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr_t;

#define BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr_CLR(r) (r).l2_user_entry_cam_bist_s3_status[0] = 0
#define BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr_SET(r,d) (r).l2_user_entry_cam_bist_s3_status[0] = d
#define BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr_GET(r) (r).l2_user_entry_cam_bist_s3_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr_S3_STATUSf_GET(r) (((r).l2_user_entry_cam_bist_s3_status[0]) & 0xffff)
#define BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr_S3_STATUSf_SET(r,f) (r).l2_user_entry_cam_bist_s3_status[0]=(((r).l2_user_entry_cam_bist_s3_status[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access L2_USER_ENTRY_CAM_BIST_S3_STATUS.
 *
 */
#define BCM56218_A0_READ_L2_USER_ENTRY_CAM_BIST_S3_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr,(r._l2_user_entry_cam_bist_s3_status))
#define BCM56218_A0_WRITE_L2_USER_ENTRY_CAM_BIST_S3_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr,&(r._l2_user_entry_cam_bist_s3_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_USER_ENTRY_CAM_BIST_S3_STATUSr BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr
#define L2_USER_ENTRY_CAM_BIST_S3_STATUSr_SIZE BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr_SIZE
typedef BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr_t L2_USER_ENTRY_CAM_BIST_S3_STATUSr_t;
#define L2_USER_ENTRY_CAM_BIST_S3_STATUSr_CLR BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr_CLR
#define L2_USER_ENTRY_CAM_BIST_S3_STATUSr_SET BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr_SET
#define L2_USER_ENTRY_CAM_BIST_S3_STATUSr_GET BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr_GET
#define L2_USER_ENTRY_CAM_BIST_S3_STATUSr_S3_STATUSf_GET BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr_S3_STATUSf_GET
#define L2_USER_ENTRY_CAM_BIST_S3_STATUSr_S3_STATUSf_SET BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr_S3_STATUSf_SET
#define READ_L2_USER_ENTRY_CAM_BIST_S3_STATUSr BCM56218_A0_READ_L2_USER_ENTRY_CAM_BIST_S3_STATUSr
#define WRITE_L2_USER_ENTRY_CAM_BIST_S3_STATUSr BCM56218_A0_WRITE_L2_USER_ENTRY_CAM_BIST_S3_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  L2_USER_ENTRY_CAM_BIST_S5_STATUS
 * BLOCKS:   IPIPE
 * DESC:     L2_USER_ENTRY_CAM_BIST_S5_STATUS
 * SIZE:     32
 * FIELDS:
 *     S5_STATUS        S5_STATUS
 *
 ******************************************************************************/
#define BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr 0x06780005

#define BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program L2_USER_ENTRY_CAM_BIST_S5_STATUS.
 *
 */
typedef union BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr_s {
	uint32_t v[1];
	uint32_t l2_user_entry_cam_bist_s5_status[1];
	uint32_t _l2_user_entry_cam_bist_s5_status;
} BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr_t;

#define BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr_CLR(r) (r).l2_user_entry_cam_bist_s5_status[0] = 0
#define BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr_SET(r,d) (r).l2_user_entry_cam_bist_s5_status[0] = d
#define BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr_GET(r) (r).l2_user_entry_cam_bist_s5_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr_S5_STATUSf_GET(r) (((r).l2_user_entry_cam_bist_s5_status[0]) & 0x7fff)
#define BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr_S5_STATUSf_SET(r,f) (r).l2_user_entry_cam_bist_s5_status[0]=(((r).l2_user_entry_cam_bist_s5_status[0] & ~((uint32_t)0x7fff)) | (((uint32_t)f) & 0x7fff))

/*
 * These macros can be used to access L2_USER_ENTRY_CAM_BIST_S5_STATUS.
 *
 */
#define BCM56218_A0_READ_L2_USER_ENTRY_CAM_BIST_S5_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr,(r._l2_user_entry_cam_bist_s5_status))
#define BCM56218_A0_WRITE_L2_USER_ENTRY_CAM_BIST_S5_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr,&(r._l2_user_entry_cam_bist_s5_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_USER_ENTRY_CAM_BIST_S5_STATUSr BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr
#define L2_USER_ENTRY_CAM_BIST_S5_STATUSr_SIZE BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr_SIZE
typedef BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr_t L2_USER_ENTRY_CAM_BIST_S5_STATUSr_t;
#define L2_USER_ENTRY_CAM_BIST_S5_STATUSr_CLR BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr_CLR
#define L2_USER_ENTRY_CAM_BIST_S5_STATUSr_SET BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr_SET
#define L2_USER_ENTRY_CAM_BIST_S5_STATUSr_GET BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr_GET
#define L2_USER_ENTRY_CAM_BIST_S5_STATUSr_S5_STATUSf_GET BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr_S5_STATUSf_GET
#define L2_USER_ENTRY_CAM_BIST_S5_STATUSr_S5_STATUSf_SET BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr_S5_STATUSf_SET
#define READ_L2_USER_ENTRY_CAM_BIST_S5_STATUSr BCM56218_A0_READ_L2_USER_ENTRY_CAM_BIST_S5_STATUSr
#define WRITE_L2_USER_ENTRY_CAM_BIST_S5_STATUSr BCM56218_A0_WRITE_L2_USER_ENTRY_CAM_BIST_S5_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  L2_USER_ENTRY_CAM_BIST_S6_STATUS
 * BLOCKS:   IPIPE
 * DESC:     L2_USER_ENTRY_CAM_BIST_S6_STATUS
 * SIZE:     32
 * FIELDS:
 *     S6_STATUS        S6_STATUS
 *
 ******************************************************************************/
#define BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr 0x06780006

#define BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program L2_USER_ENTRY_CAM_BIST_S6_STATUS.
 *
 */
typedef union BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr_s {
	uint32_t v[1];
	uint32_t l2_user_entry_cam_bist_s6_status[1];
	uint32_t _l2_user_entry_cam_bist_s6_status;
} BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr_t;

#define BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr_CLR(r) (r).l2_user_entry_cam_bist_s6_status[0] = 0
#define BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr_SET(r,d) (r).l2_user_entry_cam_bist_s6_status[0] = d
#define BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr_GET(r) (r).l2_user_entry_cam_bist_s6_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr_S6_STATUSf_GET(r) (((r).l2_user_entry_cam_bist_s6_status[0]) & 0xffff)
#define BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr_S6_STATUSf_SET(r,f) (r).l2_user_entry_cam_bist_s6_status[0]=(((r).l2_user_entry_cam_bist_s6_status[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access L2_USER_ENTRY_CAM_BIST_S6_STATUS.
 *
 */
#define BCM56218_A0_READ_L2_USER_ENTRY_CAM_BIST_S6_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr,(r._l2_user_entry_cam_bist_s6_status))
#define BCM56218_A0_WRITE_L2_USER_ENTRY_CAM_BIST_S6_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr,&(r._l2_user_entry_cam_bist_s6_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_USER_ENTRY_CAM_BIST_S6_STATUSr BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr
#define L2_USER_ENTRY_CAM_BIST_S6_STATUSr_SIZE BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr_SIZE
typedef BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr_t L2_USER_ENTRY_CAM_BIST_S6_STATUSr_t;
#define L2_USER_ENTRY_CAM_BIST_S6_STATUSr_CLR BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr_CLR
#define L2_USER_ENTRY_CAM_BIST_S6_STATUSr_SET BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr_SET
#define L2_USER_ENTRY_CAM_BIST_S6_STATUSr_GET BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr_GET
#define L2_USER_ENTRY_CAM_BIST_S6_STATUSr_S6_STATUSf_GET BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr_S6_STATUSf_GET
#define L2_USER_ENTRY_CAM_BIST_S6_STATUSr_S6_STATUSf_SET BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr_S6_STATUSf_SET
#define READ_L2_USER_ENTRY_CAM_BIST_S6_STATUSr BCM56218_A0_READ_L2_USER_ENTRY_CAM_BIST_S6_STATUSr
#define WRITE_L2_USER_ENTRY_CAM_BIST_S6_STATUSr BCM56218_A0_WRITE_L2_USER_ENTRY_CAM_BIST_S6_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  L2_USER_ENTRY_CAM_BIST_S8_STATUS
 * BLOCKS:   IPIPE
 * DESC:     L2_USER_ENTRY_CAM_BIST_S8_STATUS
 * SIZE:     32
 * FIELDS:
 *     S8_STATUS        S8_STATUS
 *
 ******************************************************************************/
#define BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr 0x06780007

#define BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program L2_USER_ENTRY_CAM_BIST_S8_STATUS.
 *
 */
typedef union BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr_s {
	uint32_t v[1];
	uint32_t l2_user_entry_cam_bist_s8_status[1];
	uint32_t _l2_user_entry_cam_bist_s8_status;
} BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr_t;

#define BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr_CLR(r) (r).l2_user_entry_cam_bist_s8_status[0] = 0
#define BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr_SET(r,d) (r).l2_user_entry_cam_bist_s8_status[0] = d
#define BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr_GET(r) (r).l2_user_entry_cam_bist_s8_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr_S8_STATUSf_GET(r) (((r).l2_user_entry_cam_bist_s8_status[0]) & 0xffff)
#define BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr_S8_STATUSf_SET(r,f) (r).l2_user_entry_cam_bist_s8_status[0]=(((r).l2_user_entry_cam_bist_s8_status[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access L2_USER_ENTRY_CAM_BIST_S8_STATUS.
 *
 */
#define BCM56218_A0_READ_L2_USER_ENTRY_CAM_BIST_S8_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr,(r._l2_user_entry_cam_bist_s8_status))
#define BCM56218_A0_WRITE_L2_USER_ENTRY_CAM_BIST_S8_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr,&(r._l2_user_entry_cam_bist_s8_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_USER_ENTRY_CAM_BIST_S8_STATUSr BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr
#define L2_USER_ENTRY_CAM_BIST_S8_STATUSr_SIZE BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr_SIZE
typedef BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr_t L2_USER_ENTRY_CAM_BIST_S8_STATUSr_t;
#define L2_USER_ENTRY_CAM_BIST_S8_STATUSr_CLR BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr_CLR
#define L2_USER_ENTRY_CAM_BIST_S8_STATUSr_SET BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr_SET
#define L2_USER_ENTRY_CAM_BIST_S8_STATUSr_GET BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr_GET
#define L2_USER_ENTRY_CAM_BIST_S8_STATUSr_S8_STATUSf_GET BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr_S8_STATUSf_GET
#define L2_USER_ENTRY_CAM_BIST_S8_STATUSr_S8_STATUSf_SET BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr_S8_STATUSf_SET
#define READ_L2_USER_ENTRY_CAM_BIST_S8_STATUSr BCM56218_A0_READ_L2_USER_ENTRY_CAM_BIST_S8_STATUSr
#define WRITE_L2_USER_ENTRY_CAM_BIST_S8_STATUSr BCM56218_A0_WRITE_L2_USER_ENTRY_CAM_BIST_S8_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  L2_USER_ENTRY_CAM_BIST_STATUS
 * BLOCKS:   IPIPE
 * DESC:     L2_USER_ENTRY_CAM_BIST_STATUS
 * SIZE:     32
 * FIELDS:
 *     BIST_GO          BIST pass/fail flag (1->pass)
 *     BIST_DONE        Inicates if the BIST has completed
 *
 ******************************************************************************/
#define BCM56218_A0_L2_USER_ENTRY_CAM_BIST_STATUSr 0x06780002

#define BCM56218_A0_L2_USER_ENTRY_CAM_BIST_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program L2_USER_ENTRY_CAM_BIST_STATUS.
 *
 */
typedef union BCM56218_A0_L2_USER_ENTRY_CAM_BIST_STATUSr_s {
	uint32_t v[1];
	uint32_t l2_user_entry_cam_bist_status[1];
	uint32_t _l2_user_entry_cam_bist_status;
} BCM56218_A0_L2_USER_ENTRY_CAM_BIST_STATUSr_t;

#define BCM56218_A0_L2_USER_ENTRY_CAM_BIST_STATUSr_CLR(r) (r).l2_user_entry_cam_bist_status[0] = 0
#define BCM56218_A0_L2_USER_ENTRY_CAM_BIST_STATUSr_SET(r,d) (r).l2_user_entry_cam_bist_status[0] = d
#define BCM56218_A0_L2_USER_ENTRY_CAM_BIST_STATUSr_GET(r) (r).l2_user_entry_cam_bist_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_L2_USER_ENTRY_CAM_BIST_STATUSr_BIST_GOf_GET(r) (((r).l2_user_entry_cam_bist_status[0]) & 0x1)
#define BCM56218_A0_L2_USER_ENTRY_CAM_BIST_STATUSr_BIST_GOf_SET(r,f) (r).l2_user_entry_cam_bist_status[0]=(((r).l2_user_entry_cam_bist_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_L2_USER_ENTRY_CAM_BIST_STATUSr_BIST_DONEf_GET(r) ((((r).l2_user_entry_cam_bist_status[0]) >> 1) & 0x1)
#define BCM56218_A0_L2_USER_ENTRY_CAM_BIST_STATUSr_BIST_DONEf_SET(r,f) (r).l2_user_entry_cam_bist_status[0]=(((r).l2_user_entry_cam_bist_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access L2_USER_ENTRY_CAM_BIST_STATUS.
 *
 */
#define BCM56218_A0_READ_L2_USER_ENTRY_CAM_BIST_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_L2_USER_ENTRY_CAM_BIST_STATUSr,(r._l2_user_entry_cam_bist_status))
#define BCM56218_A0_WRITE_L2_USER_ENTRY_CAM_BIST_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_L2_USER_ENTRY_CAM_BIST_STATUSr,&(r._l2_user_entry_cam_bist_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_USER_ENTRY_CAM_BIST_STATUSr BCM56218_A0_L2_USER_ENTRY_CAM_BIST_STATUSr
#define L2_USER_ENTRY_CAM_BIST_STATUSr_SIZE BCM56218_A0_L2_USER_ENTRY_CAM_BIST_STATUSr_SIZE
typedef BCM56218_A0_L2_USER_ENTRY_CAM_BIST_STATUSr_t L2_USER_ENTRY_CAM_BIST_STATUSr_t;
#define L2_USER_ENTRY_CAM_BIST_STATUSr_CLR BCM56218_A0_L2_USER_ENTRY_CAM_BIST_STATUSr_CLR
#define L2_USER_ENTRY_CAM_BIST_STATUSr_SET BCM56218_A0_L2_USER_ENTRY_CAM_BIST_STATUSr_SET
#define L2_USER_ENTRY_CAM_BIST_STATUSr_GET BCM56218_A0_L2_USER_ENTRY_CAM_BIST_STATUSr_GET
#define L2_USER_ENTRY_CAM_BIST_STATUSr_BIST_GOf_GET BCM56218_A0_L2_USER_ENTRY_CAM_BIST_STATUSr_BIST_GOf_GET
#define L2_USER_ENTRY_CAM_BIST_STATUSr_BIST_GOf_SET BCM56218_A0_L2_USER_ENTRY_CAM_BIST_STATUSr_BIST_GOf_SET
#define L2_USER_ENTRY_CAM_BIST_STATUSr_BIST_DONEf_GET BCM56218_A0_L2_USER_ENTRY_CAM_BIST_STATUSr_BIST_DONEf_GET
#define L2_USER_ENTRY_CAM_BIST_STATUSr_BIST_DONEf_SET BCM56218_A0_L2_USER_ENTRY_CAM_BIST_STATUSr_BIST_DONEf_SET
#define READ_L2_USER_ENTRY_CAM_BIST_STATUSr BCM56218_A0_READ_L2_USER_ENTRY_CAM_BIST_STATUSr
#define WRITE_L2_USER_ENTRY_CAM_BIST_STATUSr BCM56218_A0_WRITE_L2_USER_ENTRY_CAM_BIST_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_L2_USER_ENTRY_CAM_BIST_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  L2_USER_ENTRY_CAM_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     L2_USER_ENTRY_CAM_CONTROL
 * SIZE:     32
 * FIELDS:
 *     BIST_EN          BIST enable for the CAM
 *     SAM              SAM debug bits
 *
 ******************************************************************************/
#define BCM56218_A0_L2_USER_ENTRY_CAM_CONTROLr 0x06780001

#define BCM56218_A0_L2_USER_ENTRY_CAM_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program L2_USER_ENTRY_CAM_CONTROL.
 *
 */
typedef union BCM56218_A0_L2_USER_ENTRY_CAM_CONTROLr_s {
	uint32_t v[1];
	uint32_t l2_user_entry_cam_control[1];
	uint32_t _l2_user_entry_cam_control;
} BCM56218_A0_L2_USER_ENTRY_CAM_CONTROLr_t;

#define BCM56218_A0_L2_USER_ENTRY_CAM_CONTROLr_CLR(r) (r).l2_user_entry_cam_control[0] = 0
#define BCM56218_A0_L2_USER_ENTRY_CAM_CONTROLr_SET(r,d) (r).l2_user_entry_cam_control[0] = d
#define BCM56218_A0_L2_USER_ENTRY_CAM_CONTROLr_GET(r) (r).l2_user_entry_cam_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_L2_USER_ENTRY_CAM_CONTROLr_BIST_ENf_GET(r) (((r).l2_user_entry_cam_control[0]) & 0x1)
#define BCM56218_A0_L2_USER_ENTRY_CAM_CONTROLr_BIST_ENf_SET(r,f) (r).l2_user_entry_cam_control[0]=(((r).l2_user_entry_cam_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_L2_USER_ENTRY_CAM_CONTROLr_SAMf_GET(r) ((((r).l2_user_entry_cam_control[0]) >> 1) & 0x7)
#define BCM56218_A0_L2_USER_ENTRY_CAM_CONTROLr_SAMf_SET(r,f) (r).l2_user_entry_cam_control[0]=(((r).l2_user_entry_cam_control[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))

/*
 * These macros can be used to access L2_USER_ENTRY_CAM_CONTROL.
 *
 */
#define BCM56218_A0_READ_L2_USER_ENTRY_CAM_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_L2_USER_ENTRY_CAM_CONTROLr,(r._l2_user_entry_cam_control))
#define BCM56218_A0_WRITE_L2_USER_ENTRY_CAM_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_L2_USER_ENTRY_CAM_CONTROLr,&(r._l2_user_entry_cam_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_USER_ENTRY_CAM_CONTROLr BCM56218_A0_L2_USER_ENTRY_CAM_CONTROLr
#define L2_USER_ENTRY_CAM_CONTROLr_SIZE BCM56218_A0_L2_USER_ENTRY_CAM_CONTROLr_SIZE
typedef BCM56218_A0_L2_USER_ENTRY_CAM_CONTROLr_t L2_USER_ENTRY_CAM_CONTROLr_t;
#define L2_USER_ENTRY_CAM_CONTROLr_CLR BCM56218_A0_L2_USER_ENTRY_CAM_CONTROLr_CLR
#define L2_USER_ENTRY_CAM_CONTROLr_SET BCM56218_A0_L2_USER_ENTRY_CAM_CONTROLr_SET
#define L2_USER_ENTRY_CAM_CONTROLr_GET BCM56218_A0_L2_USER_ENTRY_CAM_CONTROLr_GET
#define L2_USER_ENTRY_CAM_CONTROLr_BIST_ENf_GET BCM56218_A0_L2_USER_ENTRY_CAM_CONTROLr_BIST_ENf_GET
#define L2_USER_ENTRY_CAM_CONTROLr_BIST_ENf_SET BCM56218_A0_L2_USER_ENTRY_CAM_CONTROLr_BIST_ENf_SET
#define L2_USER_ENTRY_CAM_CONTROLr_SAMf_GET BCM56218_A0_L2_USER_ENTRY_CAM_CONTROLr_SAMf_GET
#define L2_USER_ENTRY_CAM_CONTROLr_SAMf_SET BCM56218_A0_L2_USER_ENTRY_CAM_CONTROLr_SAMf_SET
#define READ_L2_USER_ENTRY_CAM_CONTROLr BCM56218_A0_READ_L2_USER_ENTRY_CAM_CONTROLr
#define WRITE_L2_USER_ENTRY_CAM_CONTROLr BCM56218_A0_WRITE_L2_USER_ENTRY_CAM_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_L2_USER_ENTRY_CAM_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  L2_USER_ENTRY_DATA_ONLY
 * BLOCKS:   IPIPE
 * DESC:     Data SRAM for L2_USER_ENTRY TCAM.
 * SIZE:     20
 * FIELDS:
 *     PRI              Priority
 *     CPU              CPU bit
 *     L3               Indicates an L3 entry
 *     RPE              RPE bit
 *     MIRROR           Mirror bit
 *     DST_DISCARD      Dst Discard
 *     PORT_TGID        Port or TGID
 *     MODULE_ID        Module ID
 *     BPDU             Indicates entry is a BPDU
 *
 ******************************************************************************/
#define BCM56218_A0_L2_USER_ENTRY_DATA_ONLYm 0x06760000

#define BCM56218_A0_L2_USER_ENTRY_DATA_ONLYm_MIN 0
#define BCM56218_A0_L2_USER_ENTRY_DATA_ONLYm_MAX 127
#define BCM56218_A0_L2_USER_ENTRY_DATA_ONLYm_CMAX(u) 127
#define BCM56218_A0_L2_USER_ENTRY_DATA_ONLYm_SIZE 3

/*
 * This structure should be used to declare and program L2_USER_ENTRY_DATA_ONLY.
 *
 */
typedef union BCM56218_A0_L2_USER_ENTRY_DATA_ONLYm_s {
	uint32_t v[1];
	uint32_t l2_user_entry_data_only[1];
	uint32_t _l2_user_entry_data_only;
} BCM56218_A0_L2_USER_ENTRY_DATA_ONLYm_t;

#define BCM56218_A0_L2_USER_ENTRY_DATA_ONLYm_CLR(r) (r).l2_user_entry_data_only[0] = 0
#define BCM56218_A0_L2_USER_ENTRY_DATA_ONLYm_SET(r,d) (r).l2_user_entry_data_only[0] = d
#define BCM56218_A0_L2_USER_ENTRY_DATA_ONLYm_GET(r) (r).l2_user_entry_data_only[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_L2_USER_ENTRY_DATA_ONLYm_PRIf_GET(r) (((r).l2_user_entry_data_only[0]) & 0x7)
#define BCM56218_A0_L2_USER_ENTRY_DATA_ONLYm_PRIf_SET(r,f) (r).l2_user_entry_data_only[0]=(((r).l2_user_entry_data_only[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM56218_A0_L2_USER_ENTRY_DATA_ONLYm_CPUf_GET(r) ((((r).l2_user_entry_data_only[0]) >> 3) & 0x1)
#define BCM56218_A0_L2_USER_ENTRY_DATA_ONLYm_CPUf_SET(r,f) (r).l2_user_entry_data_only[0]=(((r).l2_user_entry_data_only[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56218_A0_L2_USER_ENTRY_DATA_ONLYm_L3f_GET(r) ((((r).l2_user_entry_data_only[0]) >> 4) & 0x1)
#define BCM56218_A0_L2_USER_ENTRY_DATA_ONLYm_L3f_SET(r,f) (r).l2_user_entry_data_only[0]=(((r).l2_user_entry_data_only[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56218_A0_L2_USER_ENTRY_DATA_ONLYm_RPEf_GET(r) ((((r).l2_user_entry_data_only[0]) >> 5) & 0x1)
#define BCM56218_A0_L2_USER_ENTRY_DATA_ONLYm_RPEf_SET(r,f) (r).l2_user_entry_data_only[0]=(((r).l2_user_entry_data_only[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56218_A0_L2_USER_ENTRY_DATA_ONLYm_MIRRORf_GET(r) ((((r).l2_user_entry_data_only[0]) >> 6) & 0x1)
#define BCM56218_A0_L2_USER_ENTRY_DATA_ONLYm_MIRRORf_SET(r,f) (r).l2_user_entry_data_only[0]=(((r).l2_user_entry_data_only[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56218_A0_L2_USER_ENTRY_DATA_ONLYm_DST_DISCARDf_GET(r) ((((r).l2_user_entry_data_only[0]) >> 7) & 0x1)
#define BCM56218_A0_L2_USER_ENTRY_DATA_ONLYm_DST_DISCARDf_SET(r,f) (r).l2_user_entry_data_only[0]=(((r).l2_user_entry_data_only[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56218_A0_L2_USER_ENTRY_DATA_ONLYm_PORT_TGIDf_GET(r) ((((r).l2_user_entry_data_only[0]) >> 8) & 0x7f)
#define BCM56218_A0_L2_USER_ENTRY_DATA_ONLYm_PORT_TGIDf_SET(r,f) (r).l2_user_entry_data_only[0]=(((r).l2_user_entry_data_only[0] & ~((uint32_t)0x7f << 8)) | ((((uint32_t)f) & 0x7f) << 8))
#define BCM56218_A0_L2_USER_ENTRY_DATA_ONLYm_MODULE_IDf_GET(r) ((((r).l2_user_entry_data_only[0]) >> 15) & 0xf)
#define BCM56218_A0_L2_USER_ENTRY_DATA_ONLYm_MODULE_IDf_SET(r,f) (r).l2_user_entry_data_only[0]=(((r).l2_user_entry_data_only[0] & ~((uint32_t)0xf << 15)) | ((((uint32_t)f) & 0xf) << 15))
#define BCM56218_A0_L2_USER_ENTRY_DATA_ONLYm_BPDUf_GET(r) ((((r).l2_user_entry_data_only[0]) >> 19) & 0x1)
#define BCM56218_A0_L2_USER_ENTRY_DATA_ONLYm_BPDUf_SET(r,f) (r).l2_user_entry_data_only[0]=(((r).l2_user_entry_data_only[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access L2_USER_ENTRY_DATA_ONLY.
 *
 */
#define BCM56218_A0_READ_L2_USER_ENTRY_DATA_ONLYm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_L2_USER_ENTRY_DATA_ONLYm,i,(m._l2_user_entry_data_only),1)
#define BCM56218_A0_WRITE_L2_USER_ENTRY_DATA_ONLYm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_L2_USER_ENTRY_DATA_ONLYm,i,&(m._l2_user_entry_data_only),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_USER_ENTRY_DATA_ONLYm BCM56218_A0_L2_USER_ENTRY_DATA_ONLYm
#define L2_USER_ENTRY_DATA_ONLYm_MIN BCM56218_A0_L2_USER_ENTRY_DATA_ONLYm_MIN
#define L2_USER_ENTRY_DATA_ONLYm_MAX BCM56218_A0_L2_USER_ENTRY_DATA_ONLYm_MAX
#define L2_USER_ENTRY_DATA_ONLYm_CMAX(u) BCM56218_A0_L2_USER_ENTRY_DATA_ONLYm_CMAX(u)
#define L2_USER_ENTRY_DATA_ONLYm_SIZE BCM56218_A0_L2_USER_ENTRY_DATA_ONLYm_SIZE
typedef BCM56218_A0_L2_USER_ENTRY_DATA_ONLYm_t L2_USER_ENTRY_DATA_ONLYm_t;
#define L2_USER_ENTRY_DATA_ONLYm_CLR BCM56218_A0_L2_USER_ENTRY_DATA_ONLYm_CLR
#define L2_USER_ENTRY_DATA_ONLYm_SET BCM56218_A0_L2_USER_ENTRY_DATA_ONLYm_SET
#define L2_USER_ENTRY_DATA_ONLYm_GET BCM56218_A0_L2_USER_ENTRY_DATA_ONLYm_GET
#define L2_USER_ENTRY_DATA_ONLYm_PRIf_GET BCM56218_A0_L2_USER_ENTRY_DATA_ONLYm_PRIf_GET
#define L2_USER_ENTRY_DATA_ONLYm_PRIf_SET BCM56218_A0_L2_USER_ENTRY_DATA_ONLYm_PRIf_SET
#define L2_USER_ENTRY_DATA_ONLYm_CPUf_GET BCM56218_A0_L2_USER_ENTRY_DATA_ONLYm_CPUf_GET
#define L2_USER_ENTRY_DATA_ONLYm_CPUf_SET BCM56218_A0_L2_USER_ENTRY_DATA_ONLYm_CPUf_SET
#define L2_USER_ENTRY_DATA_ONLYm_L3f_GET BCM56218_A0_L2_USER_ENTRY_DATA_ONLYm_L3f_GET
#define L2_USER_ENTRY_DATA_ONLYm_L3f_SET BCM56218_A0_L2_USER_ENTRY_DATA_ONLYm_L3f_SET
#define L2_USER_ENTRY_DATA_ONLYm_RPEf_GET BCM56218_A0_L2_USER_ENTRY_DATA_ONLYm_RPEf_GET
#define L2_USER_ENTRY_DATA_ONLYm_RPEf_SET BCM56218_A0_L2_USER_ENTRY_DATA_ONLYm_RPEf_SET
#define L2_USER_ENTRY_DATA_ONLYm_MIRRORf_GET BCM56218_A0_L2_USER_ENTRY_DATA_ONLYm_MIRRORf_GET
#define L2_USER_ENTRY_DATA_ONLYm_MIRRORf_SET BCM56218_A0_L2_USER_ENTRY_DATA_ONLYm_MIRRORf_SET
#define L2_USER_ENTRY_DATA_ONLYm_DST_DISCARDf_GET BCM56218_A0_L2_USER_ENTRY_DATA_ONLYm_DST_DISCARDf_GET
#define L2_USER_ENTRY_DATA_ONLYm_DST_DISCARDf_SET BCM56218_A0_L2_USER_ENTRY_DATA_ONLYm_DST_DISCARDf_SET
#define L2_USER_ENTRY_DATA_ONLYm_PORT_TGIDf_GET BCM56218_A0_L2_USER_ENTRY_DATA_ONLYm_PORT_TGIDf_GET
#define L2_USER_ENTRY_DATA_ONLYm_PORT_TGIDf_SET BCM56218_A0_L2_USER_ENTRY_DATA_ONLYm_PORT_TGIDf_SET
#define L2_USER_ENTRY_DATA_ONLYm_MODULE_IDf_GET BCM56218_A0_L2_USER_ENTRY_DATA_ONLYm_MODULE_IDf_GET
#define L2_USER_ENTRY_DATA_ONLYm_MODULE_IDf_SET BCM56218_A0_L2_USER_ENTRY_DATA_ONLYm_MODULE_IDf_SET
#define L2_USER_ENTRY_DATA_ONLYm_BPDUf_GET BCM56218_A0_L2_USER_ENTRY_DATA_ONLYm_BPDUf_GET
#define L2_USER_ENTRY_DATA_ONLYm_BPDUf_SET BCM56218_A0_L2_USER_ENTRY_DATA_ONLYm_BPDUf_SET
#define READ_L2_USER_ENTRY_DATA_ONLYm BCM56218_A0_READ_L2_USER_ENTRY_DATA_ONLYm
#define WRITE_L2_USER_ENTRY_DATA_ONLYm BCM56218_A0_WRITE_L2_USER_ENTRY_DATA_ONLYm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_L2_USER_ENTRY_DATA_ONLYm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  L2_USER_ENTRY_ONLY
 * BLOCKS:   IPIPE
 * DESC:     TCAM for guaranteed L2 entries and BPDUs.
 * SIZE:     121
 * FIELDS:
 *     VALID            Indicates that the entry is valid
 *     MAC_ADDR         MAC address
 *     VLAN_ID          VLAN ID
 *     MASK             Mask for the {VLAN_ID, MAC_ADDR}
 *
 ******************************************************************************/
#define BCM56218_A0_L2_USER_ENTRY_ONLYm 0x06750000

#define BCM56218_A0_L2_USER_ENTRY_ONLYm_MIN 0
#define BCM56218_A0_L2_USER_ENTRY_ONLYm_MAX 127
#define BCM56218_A0_L2_USER_ENTRY_ONLYm_CMAX(u) 127
#define BCM56218_A0_L2_USER_ENTRY_ONLYm_SIZE 16

/*
 * This structure should be used to declare and program L2_USER_ENTRY_ONLY.
 *
 */
typedef union BCM56218_A0_L2_USER_ENTRY_ONLYm_s {
	uint32_t v[4];
	uint32_t l2_user_entry_only[4];
	uint32_t _l2_user_entry_only;
} BCM56218_A0_L2_USER_ENTRY_ONLYm_t;

#define BCM56218_A0_L2_USER_ENTRY_ONLYm_CLR(r) CDK_MEMSET(&((r)._l2_user_entry_only), 0, sizeof(BCM56218_A0_L2_USER_ENTRY_ONLYm_t))
#define BCM56218_A0_L2_USER_ENTRY_ONLYm_SET(r,i,d) (r).l2_user_entry_only[i] = d
#define BCM56218_A0_L2_USER_ENTRY_ONLYm_GET(r,i) (r).l2_user_entry_only[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_L2_USER_ENTRY_ONLYm_VALIDf_GET(r) (((r).l2_user_entry_only[0]) & 0x1)
#define BCM56218_A0_L2_USER_ENTRY_ONLYm_VALIDf_SET(r,f) (r).l2_user_entry_only[0]=(((r).l2_user_entry_only[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_L2_USER_ENTRY_ONLYm_MAC_ADDRf_GET(r,a) cdk_field_get((r).l2_user_entry_only,1,48,a)
#define BCM56218_A0_L2_USER_ENTRY_ONLYm_MAC_ADDRf_SET(r,a) cdk_field_set((r).l2_user_entry_only,1,48,a)
#define BCM56218_A0_L2_USER_ENTRY_ONLYm_VLAN_IDf_GET(r) ((((r).l2_user_entry_only[1]) >> 17) & 0xfff)
#define BCM56218_A0_L2_USER_ENTRY_ONLYm_VLAN_IDf_SET(r,f) (r).l2_user_entry_only[1]=(((r).l2_user_entry_only[1] & ~((uint32_t)0xfff << 17)) | ((((uint32_t)f) & 0xfff) << 17))
#define BCM56218_A0_L2_USER_ENTRY_ONLYm_MASKf_GET(r,a) cdk_field_get((r).l2_user_entry_only,61,120,a)
#define BCM56218_A0_L2_USER_ENTRY_ONLYm_MASKf_SET(r,a) cdk_field_set((r).l2_user_entry_only,61,120,a)

/*
 * These macros can be used to access L2_USER_ENTRY_ONLY.
 *
 */
#define BCM56218_A0_READ_L2_USER_ENTRY_ONLYm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_L2_USER_ENTRY_ONLYm,i,(m._l2_user_entry_only),4)
#define BCM56218_A0_WRITE_L2_USER_ENTRY_ONLYm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_L2_USER_ENTRY_ONLYm,i,&(m._l2_user_entry_only),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_USER_ENTRY_ONLYm BCM56218_A0_L2_USER_ENTRY_ONLYm
#define L2_USER_ENTRY_ONLYm_MIN BCM56218_A0_L2_USER_ENTRY_ONLYm_MIN
#define L2_USER_ENTRY_ONLYm_MAX BCM56218_A0_L2_USER_ENTRY_ONLYm_MAX
#define L2_USER_ENTRY_ONLYm_CMAX(u) BCM56218_A0_L2_USER_ENTRY_ONLYm_CMAX(u)
#define L2_USER_ENTRY_ONLYm_SIZE BCM56218_A0_L2_USER_ENTRY_ONLYm_SIZE
typedef BCM56218_A0_L2_USER_ENTRY_ONLYm_t L2_USER_ENTRY_ONLYm_t;
#define L2_USER_ENTRY_ONLYm_CLR BCM56218_A0_L2_USER_ENTRY_ONLYm_CLR
#define L2_USER_ENTRY_ONLYm_SET BCM56218_A0_L2_USER_ENTRY_ONLYm_SET
#define L2_USER_ENTRY_ONLYm_GET BCM56218_A0_L2_USER_ENTRY_ONLYm_GET
#define L2_USER_ENTRY_ONLYm_VALIDf_GET BCM56218_A0_L2_USER_ENTRY_ONLYm_VALIDf_GET
#define L2_USER_ENTRY_ONLYm_VALIDf_SET BCM56218_A0_L2_USER_ENTRY_ONLYm_VALIDf_SET
#define L2_USER_ENTRY_ONLYm_MAC_ADDRf_GET BCM56218_A0_L2_USER_ENTRY_ONLYm_MAC_ADDRf_GET
#define L2_USER_ENTRY_ONLYm_MAC_ADDRf_SET BCM56218_A0_L2_USER_ENTRY_ONLYm_MAC_ADDRf_SET
#define L2_USER_ENTRY_ONLYm_VLAN_IDf_GET BCM56218_A0_L2_USER_ENTRY_ONLYm_VLAN_IDf_GET
#define L2_USER_ENTRY_ONLYm_VLAN_IDf_SET BCM56218_A0_L2_USER_ENTRY_ONLYm_VLAN_IDf_SET
#define L2_USER_ENTRY_ONLYm_MASKf_GET BCM56218_A0_L2_USER_ENTRY_ONLYm_MASKf_GET
#define L2_USER_ENTRY_ONLYm_MASKf_SET BCM56218_A0_L2_USER_ENTRY_ONLYm_MASKf_SET
#define READ_L2_USER_ENTRY_ONLYm BCM56218_A0_READ_L2_USER_ENTRY_ONLYm
#define WRITE_L2_USER_ENTRY_ONLYm BCM56218_A0_WRITE_L2_USER_ENTRY_ONLYm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_L2_USER_ENTRY_ONLYm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  L3_TUNNEL
 * BLOCKS:   IPIPE
 * DESC:     L3 Tunnel Table TCAM
 * SIZE:     190
 * FIELDS:
 *     SIP              Source IP Address for tunnel table lookup
 *     DIP              Destination IP Address for tunnel table lookup
 *     SIP_MASK         Source IP Address Mask
 *     DIP_MASK         Destination IP Address Mask
 *     VALID            Valid bit for each TCAM entry
 *     SUB_TUNNEL_TYPE  Indicates L3 tunnel type.  For automatic tunnels it indicates either ISATAP or 6-to-4.  For configured tunnels, it indicates if IPv4 in IPv4 (if sub_tunnel_type[0]==1) and/or IPv6 in IPv4 tunnels (if sub_tunnel_type[1]==1) are allowed.
 *     TUNNEL_TYPE      Indicates whether the tunnel is an auto or configured tunnel
 *     USE_OUTER_HDR_DSCP Use IPv4 outer header's DSCP field
 *     USE_OUTER_HDR_TTL Use IPv4 outer header's TTL field
 *     DONOT_CHANGE_INNER_HDR_DSCP Do not change inner header's DSCP field
 *     ALLOWED_PORT_BITMAP Port bitmap for this tunnel
 *     ALLOWED_PORT_BITMAP_LO Lower 32 Port bitmap for this tunnel
 *     ALLOWED_PORT_BITMAP_HI Upper Port bitmap for this tunnel
 *     USE_TUNNEL_DSCP  Trust dscp per tunnel
 *
 ******************************************************************************/
#define BCM56218_A0_L3_TUNNELm 0x02700000

#define BCM56218_A0_L3_TUNNELm_MIN 0
#define BCM56218_A0_L3_TUNNELm_MAX 7
#define BCM56218_A0_L3_TUNNELm_CMAX(u) 7
#define BCM56218_A0_L3_TUNNELm_SIZE 24

/*
 * This structure should be used to declare and program L3_TUNNEL.
 *
 */
typedef union BCM56218_A0_L3_TUNNELm_s {
	uint32_t v[6];
	uint32_t l3_tunnel[6];
	uint32_t _l3_tunnel;
} BCM56218_A0_L3_TUNNELm_t;

#define BCM56218_A0_L3_TUNNELm_CLR(r) CDK_MEMSET(&((r)._l3_tunnel), 0, sizeof(BCM56218_A0_L3_TUNNELm_t))
#define BCM56218_A0_L3_TUNNELm_SET(r,i,d) (r).l3_tunnel[i] = d
#define BCM56218_A0_L3_TUNNELm_GET(r,i) (r).l3_tunnel[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_L3_TUNNELm_SIPf_GET(r) ((r).l3_tunnel[0])
#define BCM56218_A0_L3_TUNNELm_SIPf_SET(r,f) (r).l3_tunnel[0]=((uint32_t)f)
#define BCM56218_A0_L3_TUNNELm_DIPf_GET(r) ((r).l3_tunnel[1])
#define BCM56218_A0_L3_TUNNELm_DIPf_SET(r,f) (r).l3_tunnel[1]=((uint32_t)f)
#define BCM56218_A0_L3_TUNNELm_SIP_MASKf_GET(r) ((r).l3_tunnel[2])
#define BCM56218_A0_L3_TUNNELm_SIP_MASKf_SET(r,f) (r).l3_tunnel[2]=((uint32_t)f)
#define BCM56218_A0_L3_TUNNELm_DIP_MASKf_GET(r) ((r).l3_tunnel[3])
#define BCM56218_A0_L3_TUNNELm_DIP_MASKf_SET(r,f) (r).l3_tunnel[3]=((uint32_t)f)
#define BCM56218_A0_L3_TUNNELm_VALIDf_GET(r) (((r).l3_tunnel[4]) & 0x1)
#define BCM56218_A0_L3_TUNNELm_VALIDf_SET(r,f) (r).l3_tunnel[4]=(((r).l3_tunnel[4] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_L3_TUNNELm_SUB_TUNNEL_TYPEf_GET(r) ((((r).l3_tunnel[4]) >> 1) & 0x3)
#define BCM56218_A0_L3_TUNNELm_SUB_TUNNEL_TYPEf_SET(r,f) (r).l3_tunnel[4]=(((r).l3_tunnel[4] & ~((uint32_t)0x3 << 1)) | ((((uint32_t)f) & 0x3) << 1))
#define BCM56218_A0_L3_TUNNELm_TUNNEL_TYPEf_GET(r) ((((r).l3_tunnel[4]) >> 3) & 0x1)
#define BCM56218_A0_L3_TUNNELm_TUNNEL_TYPEf_SET(r,f) (r).l3_tunnel[4]=(((r).l3_tunnel[4] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56218_A0_L3_TUNNELm_USE_OUTER_HDR_DSCPf_GET(r) ((((r).l3_tunnel[4]) >> 4) & 0x1)
#define BCM56218_A0_L3_TUNNELm_USE_OUTER_HDR_DSCPf_SET(r,f) (r).l3_tunnel[4]=(((r).l3_tunnel[4] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56218_A0_L3_TUNNELm_USE_OUTER_HDR_TTLf_GET(r) ((((r).l3_tunnel[4]) >> 5) & 0x1)
#define BCM56218_A0_L3_TUNNELm_USE_OUTER_HDR_TTLf_SET(r,f) (r).l3_tunnel[4]=(((r).l3_tunnel[4] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56218_A0_L3_TUNNELm_DONOT_CHANGE_INNER_HDR_DSCPf_GET(r) ((((r).l3_tunnel[4]) >> 6) & 0x1)
#define BCM56218_A0_L3_TUNNELm_DONOT_CHANGE_INNER_HDR_DSCPf_SET(r,f) (r).l3_tunnel[4]=(((r).l3_tunnel[4] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56218_A0_L3_TUNNELm_ALLOWED_PORT_BITMAPf_GET(r,a) cdk_field_get((r).l3_tunnel,135,188,a)
#define BCM56218_A0_L3_TUNNELm_ALLOWED_PORT_BITMAPf_SET(r,a) cdk_field_set((r).l3_tunnel,135,188,a)
#define BCM56218_A0_L3_TUNNELm_ALLOWED_PORT_BITMAP_LOf_GET(r) cdk_field32_get((r).l3_tunnel,135,166)
#define BCM56218_A0_L3_TUNNELm_ALLOWED_PORT_BITMAP_LOf_SET(r,f) cdk_field32_set((r).l3_tunnel,135,166,f)
#define BCM56218_A0_L3_TUNNELm_ALLOWED_PORT_BITMAP_HIf_GET(r) ((((r).l3_tunnel[5]) >> 7) & 0x3fffff)
#define BCM56218_A0_L3_TUNNELm_ALLOWED_PORT_BITMAP_HIf_SET(r,f) (r).l3_tunnel[5]=(((r).l3_tunnel[5] & ~((uint32_t)0x3fffff << 7)) | ((((uint32_t)f) & 0x3fffff) << 7))
#define BCM56218_A0_L3_TUNNELm_USE_TUNNEL_DSCPf_GET(r) ((((r).l3_tunnel[5]) >> 29) & 0x1)
#define BCM56218_A0_L3_TUNNELm_USE_TUNNEL_DSCPf_SET(r,f) (r).l3_tunnel[5]=(((r).l3_tunnel[5] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))

/*
 * These macros can be used to access L3_TUNNEL.
 *
 */
#define BCM56218_A0_READ_L3_TUNNELm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_L3_TUNNELm,i,(m._l3_tunnel),6)
#define BCM56218_A0_WRITE_L3_TUNNELm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_L3_TUNNELm,i,&(m._l3_tunnel),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_TUNNELm BCM56218_A0_L3_TUNNELm
#define L3_TUNNELm_MIN BCM56218_A0_L3_TUNNELm_MIN
#define L3_TUNNELm_MAX BCM56218_A0_L3_TUNNELm_MAX
#define L3_TUNNELm_CMAX(u) BCM56218_A0_L3_TUNNELm_CMAX(u)
#define L3_TUNNELm_SIZE BCM56218_A0_L3_TUNNELm_SIZE
typedef BCM56218_A0_L3_TUNNELm_t L3_TUNNELm_t;
#define L3_TUNNELm_CLR BCM56218_A0_L3_TUNNELm_CLR
#define L3_TUNNELm_SET BCM56218_A0_L3_TUNNELm_SET
#define L3_TUNNELm_GET BCM56218_A0_L3_TUNNELm_GET
#define L3_TUNNELm_SIPf_GET BCM56218_A0_L3_TUNNELm_SIPf_GET
#define L3_TUNNELm_SIPf_SET BCM56218_A0_L3_TUNNELm_SIPf_SET
#define L3_TUNNELm_DIPf_GET BCM56218_A0_L3_TUNNELm_DIPf_GET
#define L3_TUNNELm_DIPf_SET BCM56218_A0_L3_TUNNELm_DIPf_SET
#define L3_TUNNELm_SIP_MASKf_GET BCM56218_A0_L3_TUNNELm_SIP_MASKf_GET
#define L3_TUNNELm_SIP_MASKf_SET BCM56218_A0_L3_TUNNELm_SIP_MASKf_SET
#define L3_TUNNELm_DIP_MASKf_GET BCM56218_A0_L3_TUNNELm_DIP_MASKf_GET
#define L3_TUNNELm_DIP_MASKf_SET BCM56218_A0_L3_TUNNELm_DIP_MASKf_SET
#define L3_TUNNELm_VALIDf_GET BCM56218_A0_L3_TUNNELm_VALIDf_GET
#define L3_TUNNELm_VALIDf_SET BCM56218_A0_L3_TUNNELm_VALIDf_SET
#define L3_TUNNELm_SUB_TUNNEL_TYPEf_GET BCM56218_A0_L3_TUNNELm_SUB_TUNNEL_TYPEf_GET
#define L3_TUNNELm_SUB_TUNNEL_TYPEf_SET BCM56218_A0_L3_TUNNELm_SUB_TUNNEL_TYPEf_SET
#define L3_TUNNELm_TUNNEL_TYPEf_GET BCM56218_A0_L3_TUNNELm_TUNNEL_TYPEf_GET
#define L3_TUNNELm_TUNNEL_TYPEf_SET BCM56218_A0_L3_TUNNELm_TUNNEL_TYPEf_SET
#define L3_TUNNELm_USE_OUTER_HDR_DSCPf_GET BCM56218_A0_L3_TUNNELm_USE_OUTER_HDR_DSCPf_GET
#define L3_TUNNELm_USE_OUTER_HDR_DSCPf_SET BCM56218_A0_L3_TUNNELm_USE_OUTER_HDR_DSCPf_SET
#define L3_TUNNELm_USE_OUTER_HDR_TTLf_GET BCM56218_A0_L3_TUNNELm_USE_OUTER_HDR_TTLf_GET
#define L3_TUNNELm_USE_OUTER_HDR_TTLf_SET BCM56218_A0_L3_TUNNELm_USE_OUTER_HDR_TTLf_SET
#define L3_TUNNELm_DONOT_CHANGE_INNER_HDR_DSCPf_GET BCM56218_A0_L3_TUNNELm_DONOT_CHANGE_INNER_HDR_DSCPf_GET
#define L3_TUNNELm_DONOT_CHANGE_INNER_HDR_DSCPf_SET BCM56218_A0_L3_TUNNELm_DONOT_CHANGE_INNER_HDR_DSCPf_SET
#define L3_TUNNELm_ALLOWED_PORT_BITMAPf_GET BCM56218_A0_L3_TUNNELm_ALLOWED_PORT_BITMAPf_GET
#define L3_TUNNELm_ALLOWED_PORT_BITMAPf_SET BCM56218_A0_L3_TUNNELm_ALLOWED_PORT_BITMAPf_SET
#define L3_TUNNELm_ALLOWED_PORT_BITMAP_LOf_GET BCM56218_A0_L3_TUNNELm_ALLOWED_PORT_BITMAP_LOf_GET
#define L3_TUNNELm_ALLOWED_PORT_BITMAP_LOf_SET BCM56218_A0_L3_TUNNELm_ALLOWED_PORT_BITMAP_LOf_SET
#define L3_TUNNELm_ALLOWED_PORT_BITMAP_HIf_GET BCM56218_A0_L3_TUNNELm_ALLOWED_PORT_BITMAP_HIf_GET
#define L3_TUNNELm_ALLOWED_PORT_BITMAP_HIf_SET BCM56218_A0_L3_TUNNELm_ALLOWED_PORT_BITMAP_HIf_SET
#define L3_TUNNELm_USE_TUNNEL_DSCPf_GET BCM56218_A0_L3_TUNNELm_USE_TUNNEL_DSCPf_GET
#define L3_TUNNELm_USE_TUNNEL_DSCPf_SET BCM56218_A0_L3_TUNNELm_USE_TUNNEL_DSCPf_SET
#define READ_L3_TUNNELm BCM56218_A0_READ_L3_TUNNELm
#define WRITE_L3_TUNNELm BCM56218_A0_WRITE_L3_TUNNELm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_L3_TUNNELm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  LWMCOSCELLSETLIMIT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CELLSETLIMIT     In Dynamic Memory mode:This register represents the guaranteed number of CBP cells scheduled for COS n on this egress port. When LCCOUNTcrosses this limit it goes in to dynamiccell area which is shared by other COS and other ports.Dynamic Memory Mode register need to be set for this limit to be in effect.When not in Dynamic Memory Mode, This is the HOL Cell high waterthreshold for egress port packet of COS n, i.e Number of cells per egress port of COS 0.Modify this register during the traffic is an illeagal opreation, will cause unrecoverable damage on MMU.
 *     CELLRESETLIMIT   In Dynamic Memory mode:This register is not used.When not in Dynamic Memory Mode, This register is used for resume cell \cell admission when current HOL Cell Count is lower that this reset limit.Modify this register during the traffic is an illeagal opreation, will cause unrecoverable damage on MMU.
 *
 ******************************************************************************/
#define BCM56218_A0_LWMCOSCELLSETLIMITr 0x00600027

#define BCM56218_A0_LWMCOSCELLSETLIMITr_SIZE 4

/*
 * This structure should be used to declare and program LWMCOSCELLSETLIMIT.
 *
 */
typedef union BCM56218_A0_LWMCOSCELLSETLIMITr_s {
	uint32_t v[1];
	uint32_t lwmcoscellsetlimit[1];
	uint32_t _lwmcoscellsetlimit;
} BCM56218_A0_LWMCOSCELLSETLIMITr_t;

#define BCM56218_A0_LWMCOSCELLSETLIMITr_CLR(r) (r).lwmcoscellsetlimit[0] = 0
#define BCM56218_A0_LWMCOSCELLSETLIMITr_SET(r,d) (r).lwmcoscellsetlimit[0] = d
#define BCM56218_A0_LWMCOSCELLSETLIMITr_GET(r) (r).lwmcoscellsetlimit[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_LWMCOSCELLSETLIMITr_CELLSETLIMITf_GET(r) (((r).lwmcoscellsetlimit[0]) & 0xfff)
#define BCM56218_A0_LWMCOSCELLSETLIMITr_CELLSETLIMITf_SET(r,f) (r).lwmcoscellsetlimit[0]=(((r).lwmcoscellsetlimit[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM56218_A0_LWMCOSCELLSETLIMITr_CELLRESETLIMITf_GET(r) ((((r).lwmcoscellsetlimit[0]) >> 12) & 0xfff)
#define BCM56218_A0_LWMCOSCELLSETLIMITr_CELLRESETLIMITf_SET(r,f) (r).lwmcoscellsetlimit[0]=(((r).lwmcoscellsetlimit[0] & ~((uint32_t)0xfff << 12)) | ((((uint32_t)f) & 0xfff) << 12))

/*
 * These macros can be used to access LWMCOSCELLSETLIMIT.
 *
 */
#define BCM56218_A0_READ_LWMCOSCELLSETLIMITr(u,p,i,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_LWMCOSCELLSETLIMITr+(i),(r._lwmcoscellsetlimit))
#define BCM56218_A0_WRITE_LWMCOSCELLSETLIMITr(u,p,i,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_LWMCOSCELLSETLIMITr+(i),&(r._lwmcoscellsetlimit))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LWMCOSCELLSETLIMITr BCM56218_A0_LWMCOSCELLSETLIMITr
#define LWMCOSCELLSETLIMITr_SIZE BCM56218_A0_LWMCOSCELLSETLIMITr_SIZE
typedef BCM56218_A0_LWMCOSCELLSETLIMITr_t LWMCOSCELLSETLIMITr_t;
#define LWMCOSCELLSETLIMITr_CLR BCM56218_A0_LWMCOSCELLSETLIMITr_CLR
#define LWMCOSCELLSETLIMITr_SET BCM56218_A0_LWMCOSCELLSETLIMITr_SET
#define LWMCOSCELLSETLIMITr_GET BCM56218_A0_LWMCOSCELLSETLIMITr_GET
#define LWMCOSCELLSETLIMITr_CELLSETLIMITf_GET BCM56218_A0_LWMCOSCELLSETLIMITr_CELLSETLIMITf_GET
#define LWMCOSCELLSETLIMITr_CELLSETLIMITf_SET BCM56218_A0_LWMCOSCELLSETLIMITr_CELLSETLIMITf_SET
#define LWMCOSCELLSETLIMITr_CELLRESETLIMITf_GET BCM56218_A0_LWMCOSCELLSETLIMITr_CELLRESETLIMITf_GET
#define LWMCOSCELLSETLIMITr_CELLRESETLIMITf_SET BCM56218_A0_LWMCOSCELLSETLIMITr_CELLRESETLIMITf_SET
#define READ_LWMCOSCELLSETLIMITr BCM56218_A0_READ_LWMCOSCELLSETLIMITr
#define WRITE_LWMCOSCELLSETLIMITr BCM56218_A0_WRITE_LWMCOSCELLSETLIMITr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_LWMCOSCELLSETLIMITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MAC_BLOCK
 * BLOCKS:   IPIPE
 * DESC:     Source Trunk Bitmap Table
 * SIZE:     54
 * FIELDS:
 *     MAC_BLOCK_MASK   MAC block mask
 *     MAC_BLOCK_MASK_LO MAC block mask
 *     MAC_BLOCK_MASK_HI MAC block mask
 *
 ******************************************************************************/
#define BCM56218_A0_MAC_BLOCKm 0x0e740000

#define BCM56218_A0_MAC_BLOCKm_MIN 0
#define BCM56218_A0_MAC_BLOCKm_MAX 31
#define BCM56218_A0_MAC_BLOCKm_CMAX(u) 31
#define BCM56218_A0_MAC_BLOCKm_SIZE 7

/*
 * This structure should be used to declare and program MAC_BLOCK.
 *
 */
typedef union BCM56218_A0_MAC_BLOCKm_s {
	uint32_t v[2];
	uint32_t mac_block[2];
	uint32_t _mac_block;
} BCM56218_A0_MAC_BLOCKm_t;

#define BCM56218_A0_MAC_BLOCKm_CLR(r) CDK_MEMSET(&((r)._mac_block), 0, sizeof(BCM56218_A0_MAC_BLOCKm_t))
#define BCM56218_A0_MAC_BLOCKm_SET(r,i,d) (r).mac_block[i] = d
#define BCM56218_A0_MAC_BLOCKm_GET(r,i) (r).mac_block[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MAC_BLOCKm_MAC_BLOCK_MASKf_GET(r,a) cdk_field_get((r).mac_block,0,53,a)
#define BCM56218_A0_MAC_BLOCKm_MAC_BLOCK_MASKf_SET(r,a) cdk_field_set((r).mac_block,0,53,a)
#define BCM56218_A0_MAC_BLOCKm_MAC_BLOCK_MASK_LOf_GET(r) ((r).mac_block[0])
#define BCM56218_A0_MAC_BLOCKm_MAC_BLOCK_MASK_LOf_SET(r,f) (r).mac_block[0]=((uint32_t)f)
#define BCM56218_A0_MAC_BLOCKm_MAC_BLOCK_MASK_HIf_GET(r) (((r).mac_block[1]) & 0x3fffff)
#define BCM56218_A0_MAC_BLOCKm_MAC_BLOCK_MASK_HIf_SET(r,f) (r).mac_block[1]=(((r).mac_block[1] & ~((uint32_t)0x3fffff)) | (((uint32_t)f) & 0x3fffff))

/*
 * These macros can be used to access MAC_BLOCK.
 *
 */
#define BCM56218_A0_READ_MAC_BLOCKm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MAC_BLOCKm,i,(m._mac_block),2)
#define BCM56218_A0_WRITE_MAC_BLOCKm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MAC_BLOCKm,i,&(m._mac_block),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAC_BLOCKm BCM56218_A0_MAC_BLOCKm
#define MAC_BLOCKm_MIN BCM56218_A0_MAC_BLOCKm_MIN
#define MAC_BLOCKm_MAX BCM56218_A0_MAC_BLOCKm_MAX
#define MAC_BLOCKm_CMAX(u) BCM56218_A0_MAC_BLOCKm_CMAX(u)
#define MAC_BLOCKm_SIZE BCM56218_A0_MAC_BLOCKm_SIZE
typedef BCM56218_A0_MAC_BLOCKm_t MAC_BLOCKm_t;
#define MAC_BLOCKm_CLR BCM56218_A0_MAC_BLOCKm_CLR
#define MAC_BLOCKm_SET BCM56218_A0_MAC_BLOCKm_SET
#define MAC_BLOCKm_GET BCM56218_A0_MAC_BLOCKm_GET
#define MAC_BLOCKm_MAC_BLOCK_MASKf_GET BCM56218_A0_MAC_BLOCKm_MAC_BLOCK_MASKf_GET
#define MAC_BLOCKm_MAC_BLOCK_MASKf_SET BCM56218_A0_MAC_BLOCKm_MAC_BLOCK_MASKf_SET
#define MAC_BLOCKm_MAC_BLOCK_MASK_LOf_GET BCM56218_A0_MAC_BLOCKm_MAC_BLOCK_MASK_LOf_GET
#define MAC_BLOCKm_MAC_BLOCK_MASK_LOf_SET BCM56218_A0_MAC_BLOCKm_MAC_BLOCK_MASK_LOf_SET
#define MAC_BLOCKm_MAC_BLOCK_MASK_HIf_GET BCM56218_A0_MAC_BLOCKm_MAC_BLOCK_MASK_HIf_GET
#define MAC_BLOCKm_MAC_BLOCK_MASK_HIf_SET BCM56218_A0_MAC_BLOCKm_MAC_BLOCK_MASK_HIf_SET
#define READ_MAC_BLOCKm BCM56218_A0_READ_MAC_BLOCKm
#define WRITE_MAC_BLOCKm BCM56218_A0_WRITE_MAC_BLOCKm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MAC_BLOCKm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  MAC_LIMIT_CONFIG
 * BLOCKS:   IPIPE
 * DESC:     MODID config so that the aging/table update logic can use it to determine local vs remote entries
 * SIZE:     32
 * FIELDS:
 *     MY_MODID         the aging/table update logic can use it to determine local vs remote entries.
 *
 ******************************************************************************/
#define BCM56218_A0_MAC_LIMIT_CONFIGr 0x06780010

#define BCM56218_A0_MAC_LIMIT_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program MAC_LIMIT_CONFIG.
 *
 */
typedef union BCM56218_A0_MAC_LIMIT_CONFIGr_s {
	uint32_t v[1];
	uint32_t mac_limit_config[1];
	uint32_t _mac_limit_config;
} BCM56218_A0_MAC_LIMIT_CONFIGr_t;

#define BCM56218_A0_MAC_LIMIT_CONFIGr_CLR(r) (r).mac_limit_config[0] = 0
#define BCM56218_A0_MAC_LIMIT_CONFIGr_SET(r,d) (r).mac_limit_config[0] = d
#define BCM56218_A0_MAC_LIMIT_CONFIGr_GET(r) (r).mac_limit_config[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MAC_LIMIT_CONFIGr_MY_MODIDf_GET(r) (((r).mac_limit_config[0]) & 0xf)
#define BCM56218_A0_MAC_LIMIT_CONFIGr_MY_MODIDf_SET(r,f) (r).mac_limit_config[0]=(((r).mac_limit_config[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access MAC_LIMIT_CONFIG.
 *
 */
#define BCM56218_A0_READ_MAC_LIMIT_CONFIGr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_MAC_LIMIT_CONFIGr,(r._mac_limit_config))
#define BCM56218_A0_WRITE_MAC_LIMIT_CONFIGr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_MAC_LIMIT_CONFIGr,&(r._mac_limit_config))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAC_LIMIT_CONFIGr BCM56218_A0_MAC_LIMIT_CONFIGr
#define MAC_LIMIT_CONFIGr_SIZE BCM56218_A0_MAC_LIMIT_CONFIGr_SIZE
typedef BCM56218_A0_MAC_LIMIT_CONFIGr_t MAC_LIMIT_CONFIGr_t;
#define MAC_LIMIT_CONFIGr_CLR BCM56218_A0_MAC_LIMIT_CONFIGr_CLR
#define MAC_LIMIT_CONFIGr_SET BCM56218_A0_MAC_LIMIT_CONFIGr_SET
#define MAC_LIMIT_CONFIGr_GET BCM56218_A0_MAC_LIMIT_CONFIGr_GET
#define MAC_LIMIT_CONFIGr_MY_MODIDf_GET BCM56218_A0_MAC_LIMIT_CONFIGr_MY_MODIDf_GET
#define MAC_LIMIT_CONFIGr_MY_MODIDf_SET BCM56218_A0_MAC_LIMIT_CONFIGr_MY_MODIDf_SET
#define READ_MAC_LIMIT_CONFIGr BCM56218_A0_READ_MAC_LIMIT_CONFIGr
#define WRITE_MAC_LIMIT_CONFIGr BCM56218_A0_WRITE_MAC_LIMIT_CONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MAC_LIMIT_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  MAC_LIMIT_ENABLE
 * BLOCKS:   IPIPE
 * DESC:     Indicates if Mac Limit feature is enabled or not.
 * SIZE:     32
 * FIELDS:
 *     ENABLE           This bit must be set when enabling the MAC_LIMIT feature. Alongwith this, Limits have to be programmed correctly to enable the feature completely.
 *
 ******************************************************************************/
#define BCM56218_A0_MAC_LIMIT_ENABLEr 0x0178000c

#define BCM56218_A0_MAC_LIMIT_ENABLEr_SIZE 4

/*
 * This structure should be used to declare and program MAC_LIMIT_ENABLE.
 *
 */
typedef union BCM56218_A0_MAC_LIMIT_ENABLEr_s {
	uint32_t v[1];
	uint32_t mac_limit_enable[1];
	uint32_t _mac_limit_enable;
} BCM56218_A0_MAC_LIMIT_ENABLEr_t;

#define BCM56218_A0_MAC_LIMIT_ENABLEr_CLR(r) (r).mac_limit_enable[0] = 0
#define BCM56218_A0_MAC_LIMIT_ENABLEr_SET(r,d) (r).mac_limit_enable[0] = d
#define BCM56218_A0_MAC_LIMIT_ENABLEr_GET(r) (r).mac_limit_enable[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MAC_LIMIT_ENABLEr_ENABLEf_GET(r) (((r).mac_limit_enable[0]) & 0x1)
#define BCM56218_A0_MAC_LIMIT_ENABLEr_ENABLEf_SET(r,f) (r).mac_limit_enable[0]=(((r).mac_limit_enable[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access MAC_LIMIT_ENABLE.
 *
 */
#define BCM56218_A0_READ_MAC_LIMIT_ENABLEr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_MAC_LIMIT_ENABLEr,(r._mac_limit_enable))
#define BCM56218_A0_WRITE_MAC_LIMIT_ENABLEr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_MAC_LIMIT_ENABLEr,&(r._mac_limit_enable))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAC_LIMIT_ENABLEr BCM56218_A0_MAC_LIMIT_ENABLEr
#define MAC_LIMIT_ENABLEr_SIZE BCM56218_A0_MAC_LIMIT_ENABLEr_SIZE
typedef BCM56218_A0_MAC_LIMIT_ENABLEr_t MAC_LIMIT_ENABLEr_t;
#define MAC_LIMIT_ENABLEr_CLR BCM56218_A0_MAC_LIMIT_ENABLEr_CLR
#define MAC_LIMIT_ENABLEr_SET BCM56218_A0_MAC_LIMIT_ENABLEr_SET
#define MAC_LIMIT_ENABLEr_GET BCM56218_A0_MAC_LIMIT_ENABLEr_GET
#define MAC_LIMIT_ENABLEr_ENABLEf_GET BCM56218_A0_MAC_LIMIT_ENABLEr_ENABLEf_GET
#define MAC_LIMIT_ENABLEr_ENABLEf_SET BCM56218_A0_MAC_LIMIT_ENABLEr_ENABLEf_SET
#define READ_MAC_LIMIT_ENABLEr BCM56218_A0_READ_MAC_LIMIT_ENABLEr
#define WRITE_MAC_LIMIT_ENABLEr BCM56218_A0_WRITE_MAC_LIMIT_ENABLEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MAC_LIMIT_ENABLEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MAC_LIMIT_PORT_MAP_TABLE
 * BLOCKS:   IPIPE
 * DESC:     TABLE for mapping a INGRESS PORT to a index into MAC_LIMIT_COUNT_TABLE.
 * SIZE:     6
 * FIELDS:
 *     INDEX            index into MAC_LIMIT_COUNT_TABLE (used for mapping a INGRESS_PORT to a index into MAC_LIMIT_COUNT_TABLE) 
 *
 ******************************************************************************/
#define BCM56218_A0_MAC_LIMIT_PORT_MAP_TABLEm 0x06790000

#define BCM56218_A0_MAC_LIMIT_PORT_MAP_TABLEm_MIN 0
#define BCM56218_A0_MAC_LIMIT_PORT_MAP_TABLEm_MAX 53
#define BCM56218_A0_MAC_LIMIT_PORT_MAP_TABLEm_CMAX(u) 53
#define BCM56218_A0_MAC_LIMIT_PORT_MAP_TABLEm_SIZE 1

/*
 * This structure should be used to declare and program MAC_LIMIT_PORT_MAP_TABLE.
 *
 */
typedef union BCM56218_A0_MAC_LIMIT_PORT_MAP_TABLEm_s {
	uint32_t v[1];
	uint32_t mac_limit_port_map_table[1];
	uint32_t _mac_limit_port_map_table;
} BCM56218_A0_MAC_LIMIT_PORT_MAP_TABLEm_t;

#define BCM56218_A0_MAC_LIMIT_PORT_MAP_TABLEm_CLR(r) (r).mac_limit_port_map_table[0] = 0
#define BCM56218_A0_MAC_LIMIT_PORT_MAP_TABLEm_SET(r,d) (r).mac_limit_port_map_table[0] = d
#define BCM56218_A0_MAC_LIMIT_PORT_MAP_TABLEm_GET(r) (r).mac_limit_port_map_table[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MAC_LIMIT_PORT_MAP_TABLEm_INDEXf_GET(r) (((r).mac_limit_port_map_table[0]) & 0x3f)
#define BCM56218_A0_MAC_LIMIT_PORT_MAP_TABLEm_INDEXf_SET(r,f) (r).mac_limit_port_map_table[0]=(((r).mac_limit_port_map_table[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))

/*
 * These macros can be used to access MAC_LIMIT_PORT_MAP_TABLE.
 *
 */
#define BCM56218_A0_READ_MAC_LIMIT_PORT_MAP_TABLEm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MAC_LIMIT_PORT_MAP_TABLEm,i,(m._mac_limit_port_map_table),1)
#define BCM56218_A0_WRITE_MAC_LIMIT_PORT_MAP_TABLEm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MAC_LIMIT_PORT_MAP_TABLEm,i,&(m._mac_limit_port_map_table),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAC_LIMIT_PORT_MAP_TABLEm BCM56218_A0_MAC_LIMIT_PORT_MAP_TABLEm
#define MAC_LIMIT_PORT_MAP_TABLEm_MIN BCM56218_A0_MAC_LIMIT_PORT_MAP_TABLEm_MIN
#define MAC_LIMIT_PORT_MAP_TABLEm_MAX BCM56218_A0_MAC_LIMIT_PORT_MAP_TABLEm_MAX
#define MAC_LIMIT_PORT_MAP_TABLEm_CMAX(u) BCM56218_A0_MAC_LIMIT_PORT_MAP_TABLEm_CMAX(u)
#define MAC_LIMIT_PORT_MAP_TABLEm_SIZE BCM56218_A0_MAC_LIMIT_PORT_MAP_TABLEm_SIZE
typedef BCM56218_A0_MAC_LIMIT_PORT_MAP_TABLEm_t MAC_LIMIT_PORT_MAP_TABLEm_t;
#define MAC_LIMIT_PORT_MAP_TABLEm_CLR BCM56218_A0_MAC_LIMIT_PORT_MAP_TABLEm_CLR
#define MAC_LIMIT_PORT_MAP_TABLEm_SET BCM56218_A0_MAC_LIMIT_PORT_MAP_TABLEm_SET
#define MAC_LIMIT_PORT_MAP_TABLEm_GET BCM56218_A0_MAC_LIMIT_PORT_MAP_TABLEm_GET
#define MAC_LIMIT_PORT_MAP_TABLEm_INDEXf_GET BCM56218_A0_MAC_LIMIT_PORT_MAP_TABLEm_INDEXf_GET
#define MAC_LIMIT_PORT_MAP_TABLEm_INDEXf_SET BCM56218_A0_MAC_LIMIT_PORT_MAP_TABLEm_INDEXf_SET
#define READ_MAC_LIMIT_PORT_MAP_TABLEm BCM56218_A0_READ_MAC_LIMIT_PORT_MAP_TABLEm
#define WRITE_MAC_LIMIT_PORT_MAP_TABLEm BCM56218_A0_WRITE_MAC_LIMIT_PORT_MAP_TABLEm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MAC_LIMIT_PORT_MAP_TABLEm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MAC_LIMIT_TRUNK_MAP_TABLE
 * BLOCKS:   IPIPE
 * DESC:     TABLE for mapping a TRUNK group to a index into MAC_LIMIT_COUNT_TABLE.
 * SIZE:     6
 * FIELDS:
 *     INDEX            index into MAC_LIMIT_COUNT_TABLE (used for mapping a TRUNK GROUP to a index into MAC_LIMIT_COUNT_TABLE) 
 *
 ******************************************************************************/
#define BCM56218_A0_MAC_LIMIT_TRUNK_MAP_TABLEm 0x06780000

#define BCM56218_A0_MAC_LIMIT_TRUNK_MAP_TABLEm_MIN 0
#define BCM56218_A0_MAC_LIMIT_TRUNK_MAP_TABLEm_MAX 31
#define BCM56218_A0_MAC_LIMIT_TRUNK_MAP_TABLEm_CMAX(u) 31
#define BCM56218_A0_MAC_LIMIT_TRUNK_MAP_TABLEm_SIZE 1

/*
 * This structure should be used to declare and program MAC_LIMIT_TRUNK_MAP_TABLE.
 *
 */
typedef union BCM56218_A0_MAC_LIMIT_TRUNK_MAP_TABLEm_s {
	uint32_t v[1];
	uint32_t mac_limit_trunk_map_table[1];
	uint32_t _mac_limit_trunk_map_table;
} BCM56218_A0_MAC_LIMIT_TRUNK_MAP_TABLEm_t;

#define BCM56218_A0_MAC_LIMIT_TRUNK_MAP_TABLEm_CLR(r) (r).mac_limit_trunk_map_table[0] = 0
#define BCM56218_A0_MAC_LIMIT_TRUNK_MAP_TABLEm_SET(r,d) (r).mac_limit_trunk_map_table[0] = d
#define BCM56218_A0_MAC_LIMIT_TRUNK_MAP_TABLEm_GET(r) (r).mac_limit_trunk_map_table[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MAC_LIMIT_TRUNK_MAP_TABLEm_INDEXf_GET(r) (((r).mac_limit_trunk_map_table[0]) & 0x3f)
#define BCM56218_A0_MAC_LIMIT_TRUNK_MAP_TABLEm_INDEXf_SET(r,f) (r).mac_limit_trunk_map_table[0]=(((r).mac_limit_trunk_map_table[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))

/*
 * These macros can be used to access MAC_LIMIT_TRUNK_MAP_TABLE.
 *
 */
#define BCM56218_A0_READ_MAC_LIMIT_TRUNK_MAP_TABLEm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MAC_LIMIT_TRUNK_MAP_TABLEm,i,(m._mac_limit_trunk_map_table),1)
#define BCM56218_A0_WRITE_MAC_LIMIT_TRUNK_MAP_TABLEm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MAC_LIMIT_TRUNK_MAP_TABLEm,i,&(m._mac_limit_trunk_map_table),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAC_LIMIT_TRUNK_MAP_TABLEm BCM56218_A0_MAC_LIMIT_TRUNK_MAP_TABLEm
#define MAC_LIMIT_TRUNK_MAP_TABLEm_MIN BCM56218_A0_MAC_LIMIT_TRUNK_MAP_TABLEm_MIN
#define MAC_LIMIT_TRUNK_MAP_TABLEm_MAX BCM56218_A0_MAC_LIMIT_TRUNK_MAP_TABLEm_MAX
#define MAC_LIMIT_TRUNK_MAP_TABLEm_CMAX(u) BCM56218_A0_MAC_LIMIT_TRUNK_MAP_TABLEm_CMAX(u)
#define MAC_LIMIT_TRUNK_MAP_TABLEm_SIZE BCM56218_A0_MAC_LIMIT_TRUNK_MAP_TABLEm_SIZE
typedef BCM56218_A0_MAC_LIMIT_TRUNK_MAP_TABLEm_t MAC_LIMIT_TRUNK_MAP_TABLEm_t;
#define MAC_LIMIT_TRUNK_MAP_TABLEm_CLR BCM56218_A0_MAC_LIMIT_TRUNK_MAP_TABLEm_CLR
#define MAC_LIMIT_TRUNK_MAP_TABLEm_SET BCM56218_A0_MAC_LIMIT_TRUNK_MAP_TABLEm_SET
#define MAC_LIMIT_TRUNK_MAP_TABLEm_GET BCM56218_A0_MAC_LIMIT_TRUNK_MAP_TABLEm_GET
#define MAC_LIMIT_TRUNK_MAP_TABLEm_INDEXf_GET BCM56218_A0_MAC_LIMIT_TRUNK_MAP_TABLEm_INDEXf_GET
#define MAC_LIMIT_TRUNK_MAP_TABLEm_INDEXf_SET BCM56218_A0_MAC_LIMIT_TRUNK_MAP_TABLEm_INDEXf_SET
#define READ_MAC_LIMIT_TRUNK_MAP_TABLEm BCM56218_A0_READ_MAC_LIMIT_TRUNK_MAP_TABLEm
#define WRITE_MAC_LIMIT_TRUNK_MAP_TABLEm BCM56218_A0_WRITE_MAC_LIMIT_TRUNK_MAP_TABLEm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MAC_LIMIT_TRUNK_MAP_TABLEm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  MAC_TX_STATUS
 * BLOCKS:   GPORT0
 * DESC:      TriMAC tx status register
 * SIZE:     32
 * FIELDS:
 *     TXFIFO_ERR       When set, indicates TriMAC tx fifo underrun occur.
 *
 ******************************************************************************/
#define BCM56218_A0_MAC_TX_STATUSr 0x00000303

#define BCM56218_A0_MAC_TX_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program MAC_TX_STATUS.
 *
 */
typedef union BCM56218_A0_MAC_TX_STATUSr_s {
	uint32_t v[1];
	uint32_t mac_tx_status[1];
	uint32_t _mac_tx_status;
} BCM56218_A0_MAC_TX_STATUSr_t;

#define BCM56218_A0_MAC_TX_STATUSr_CLR(r) (r).mac_tx_status[0] = 0
#define BCM56218_A0_MAC_TX_STATUSr_SET(r,d) (r).mac_tx_status[0] = d
#define BCM56218_A0_MAC_TX_STATUSr_GET(r) (r).mac_tx_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MAC_TX_STATUSr_TXFIFO_ERRf_GET(r) (((r).mac_tx_status[0]) & 0x1)
#define BCM56218_A0_MAC_TX_STATUSr_TXFIFO_ERRf_SET(r,f) (r).mac_tx_status[0]=(((r).mac_tx_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access MAC_TX_STATUS.
 *
 */
#define BCM56218_A0_READ_MAC_TX_STATUSr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_MAC_TX_STATUSr,(r._mac_tx_status))
#define BCM56218_A0_WRITE_MAC_TX_STATUSr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_MAC_TX_STATUSr,&(r._mac_tx_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAC_TX_STATUSr BCM56218_A0_MAC_TX_STATUSr
#define MAC_TX_STATUSr_SIZE BCM56218_A0_MAC_TX_STATUSr_SIZE
typedef BCM56218_A0_MAC_TX_STATUSr_t MAC_TX_STATUSr_t;
#define MAC_TX_STATUSr_CLR BCM56218_A0_MAC_TX_STATUSr_CLR
#define MAC_TX_STATUSr_SET BCM56218_A0_MAC_TX_STATUSr_SET
#define MAC_TX_STATUSr_GET BCM56218_A0_MAC_TX_STATUSr_GET
#define MAC_TX_STATUSr_TXFIFO_ERRf_GET BCM56218_A0_MAC_TX_STATUSr_TXFIFO_ERRf_GET
#define MAC_TX_STATUSr_TXFIFO_ERRf_SET BCM56218_A0_MAC_TX_STATUSr_TXFIFO_ERRf_SET
#define READ_MAC_TX_STATUSr BCM56218_A0_READ_MAC_TX_STATUSr
#define WRITE_MAC_TX_STATUSr BCM56218_A0_WRITE_MAC_TX_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MAC_TX_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  MAXFR
 * BLOCKS:   GPORT0
 * DESC:     Max Frame Length
 * SIZE:     32
 * FIELDS:
 *     MAXFR            Max Frame Length is now 1518 Decimal
 *
 ******************************************************************************/
#define BCM56218_A0_MAXFRr 0x00000108

#define BCM56218_A0_MAXFRr_SIZE 4

/*
 * This structure should be used to declare and program MAXFR.
 *
 */
typedef union BCM56218_A0_MAXFRr_s {
	uint32_t v[1];
	uint32_t maxfr[1];
	uint32_t _maxfr;
} BCM56218_A0_MAXFRr_t;

#define BCM56218_A0_MAXFRr_CLR(r) (r).maxfr[0] = 0
#define BCM56218_A0_MAXFRr_SET(r,d) (r).maxfr[0] = d
#define BCM56218_A0_MAXFRr_GET(r) (r).maxfr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MAXFRr_MAXFRf_GET(r) (((r).maxfr[0]) & 0xffff)
#define BCM56218_A0_MAXFRr_MAXFRf_SET(r,f) (r).maxfr[0]=(((r).maxfr[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access MAXFR.
 *
 */
#define BCM56218_A0_READ_MAXFRr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_MAXFRr,(r._maxfr))
#define BCM56218_A0_WRITE_MAXFRr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_MAXFRr,&(r._maxfr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAXFRr BCM56218_A0_MAXFRr
#define MAXFRr_SIZE BCM56218_A0_MAXFRr_SIZE
typedef BCM56218_A0_MAXFRr_t MAXFRr_t;
#define MAXFRr_CLR BCM56218_A0_MAXFRr_CLR
#define MAXFRr_SET BCM56218_A0_MAXFRr_SET
#define MAXFRr_GET BCM56218_A0_MAXFRr_GET
#define MAXFRr_MAXFRf_GET BCM56218_A0_MAXFRr_MAXFRf_GET
#define MAXFRr_MAXFRf_SET BCM56218_A0_MAXFRr_MAXFRf_SET
#define READ_MAXFRr BCM56218_A0_READ_MAXFRr
#define WRITE_MAXFRr BCM56218_A0_WRITE_MAXFRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MAXFRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  MCAST_STORM_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     Ethernet Multicast Rate Control Registers
 * SIZE:     32
 * FIELDS:
 *     THRESHOLD        Rate Limit, count as number of packets
 *     ENABLE           Multicast rate control enable
 *
 ******************************************************************************/
#define BCM56218_A0_MCAST_STORM_CONTROLr 0x0b700002

#define BCM56218_A0_MCAST_STORM_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program MCAST_STORM_CONTROL.
 *
 */
typedef union BCM56218_A0_MCAST_STORM_CONTROLr_s {
	uint32_t v[1];
	uint32_t mcast_storm_control[1];
	uint32_t _mcast_storm_control;
} BCM56218_A0_MCAST_STORM_CONTROLr_t;

#define BCM56218_A0_MCAST_STORM_CONTROLr_CLR(r) (r).mcast_storm_control[0] = 0
#define BCM56218_A0_MCAST_STORM_CONTROLr_SET(r,d) (r).mcast_storm_control[0] = d
#define BCM56218_A0_MCAST_STORM_CONTROLr_GET(r) (r).mcast_storm_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MCAST_STORM_CONTROLr_THRESHOLDf_GET(r) (((r).mcast_storm_control[0]) & 0x1ffffff)
#define BCM56218_A0_MCAST_STORM_CONTROLr_THRESHOLDf_SET(r,f) (r).mcast_storm_control[0]=(((r).mcast_storm_control[0] & ~((uint32_t)0x1ffffff)) | (((uint32_t)f) & 0x1ffffff))
#define BCM56218_A0_MCAST_STORM_CONTROLr_ENABLEf_GET(r) ((((r).mcast_storm_control[0]) >> 25) & 0x1)
#define BCM56218_A0_MCAST_STORM_CONTROLr_ENABLEf_SET(r,f) (r).mcast_storm_control[0]=(((r).mcast_storm_control[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))

/*
 * These macros can be used to access MCAST_STORM_CONTROL.
 *
 */
#define BCM56218_A0_READ_MCAST_STORM_CONTROLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_MCAST_STORM_CONTROLr,(r._mcast_storm_control))
#define BCM56218_A0_WRITE_MCAST_STORM_CONTROLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_MCAST_STORM_CONTROLr,&(r._mcast_storm_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MCAST_STORM_CONTROLr BCM56218_A0_MCAST_STORM_CONTROLr
#define MCAST_STORM_CONTROLr_SIZE BCM56218_A0_MCAST_STORM_CONTROLr_SIZE
typedef BCM56218_A0_MCAST_STORM_CONTROLr_t MCAST_STORM_CONTROLr_t;
#define MCAST_STORM_CONTROLr_CLR BCM56218_A0_MCAST_STORM_CONTROLr_CLR
#define MCAST_STORM_CONTROLr_SET BCM56218_A0_MCAST_STORM_CONTROLr_SET
#define MCAST_STORM_CONTROLr_GET BCM56218_A0_MCAST_STORM_CONTROLr_GET
#define MCAST_STORM_CONTROLr_THRESHOLDf_GET BCM56218_A0_MCAST_STORM_CONTROLr_THRESHOLDf_GET
#define MCAST_STORM_CONTROLr_THRESHOLDf_SET BCM56218_A0_MCAST_STORM_CONTROLr_THRESHOLDf_SET
#define MCAST_STORM_CONTROLr_ENABLEf_GET BCM56218_A0_MCAST_STORM_CONTROLr_ENABLEf_GET
#define MCAST_STORM_CONTROLr_ENABLEf_SET BCM56218_A0_MCAST_STORM_CONTROLr_ENABLEf_SET
#define READ_MCAST_STORM_CONTROLr BCM56218_A0_READ_MCAST_STORM_CONTROLr
#define WRITE_MCAST_STORM_CONTROLr BCM56218_A0_WRITE_MCAST_STORM_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MCAST_STORM_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  MC_CONTROL_1
 * BLOCKS:   IPIPE
 * DESC:     Used to locate the bc index on mgid = {dst_mod,dst_port} combination from HG2. 
 * SIZE:     32
 * FIELDS:
 *     HIGIG2_BC_SIZE   Size of the index.
 *     HIGIG2_BC_BASE_OFFSET offset to locate the index.
 *
 ******************************************************************************/
#define BCM56218_A0_MC_CONTROL_1r 0x01780005

#define BCM56218_A0_MC_CONTROL_1r_SIZE 4

/*
 * This structure should be used to declare and program MC_CONTROL_1.
 *
 */
typedef union BCM56218_A0_MC_CONTROL_1r_s {
	uint32_t v[1];
	uint32_t mc_control_1[1];
	uint32_t _mc_control_1;
} BCM56218_A0_MC_CONTROL_1r_t;

#define BCM56218_A0_MC_CONTROL_1r_CLR(r) (r).mc_control_1[0] = 0
#define BCM56218_A0_MC_CONTROL_1r_SET(r,d) (r).mc_control_1[0] = d
#define BCM56218_A0_MC_CONTROL_1r_GET(r) (r).mc_control_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MC_CONTROL_1r_HIGIG2_BC_SIZEf_GET(r) (((r).mc_control_1[0]) & 0xffff)
#define BCM56218_A0_MC_CONTROL_1r_HIGIG2_BC_SIZEf_SET(r,f) (r).mc_control_1[0]=(((r).mc_control_1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56218_A0_MC_CONTROL_1r_HIGIG2_BC_BASE_OFFSETf_GET(r) ((((r).mc_control_1[0]) >> 16) & 0xffff)
#define BCM56218_A0_MC_CONTROL_1r_HIGIG2_BC_BASE_OFFSETf_SET(r,f) (r).mc_control_1[0]=(((r).mc_control_1[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access MC_CONTROL_1.
 *
 */
#define BCM56218_A0_READ_MC_CONTROL_1r(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_MC_CONTROL_1r,(r._mc_control_1))
#define BCM56218_A0_WRITE_MC_CONTROL_1r(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_MC_CONTROL_1r,&(r._mc_control_1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MC_CONTROL_1r BCM56218_A0_MC_CONTROL_1r
#define MC_CONTROL_1r_SIZE BCM56218_A0_MC_CONTROL_1r_SIZE
typedef BCM56218_A0_MC_CONTROL_1r_t MC_CONTROL_1r_t;
#define MC_CONTROL_1r_CLR BCM56218_A0_MC_CONTROL_1r_CLR
#define MC_CONTROL_1r_SET BCM56218_A0_MC_CONTROL_1r_SET
#define MC_CONTROL_1r_GET BCM56218_A0_MC_CONTROL_1r_GET
#define MC_CONTROL_1r_HIGIG2_BC_SIZEf_GET BCM56218_A0_MC_CONTROL_1r_HIGIG2_BC_SIZEf_GET
#define MC_CONTROL_1r_HIGIG2_BC_SIZEf_SET BCM56218_A0_MC_CONTROL_1r_HIGIG2_BC_SIZEf_SET
#define MC_CONTROL_1r_HIGIG2_BC_BASE_OFFSETf_GET BCM56218_A0_MC_CONTROL_1r_HIGIG2_BC_BASE_OFFSETf_GET
#define MC_CONTROL_1r_HIGIG2_BC_BASE_OFFSETf_SET BCM56218_A0_MC_CONTROL_1r_HIGIG2_BC_BASE_OFFSETf_SET
#define READ_MC_CONTROL_1r BCM56218_A0_READ_MC_CONTROL_1r
#define WRITE_MC_CONTROL_1r BCM56218_A0_WRITE_MC_CONTROL_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MC_CONTROL_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  MC_CONTROL_2
 * BLOCKS:   IPIPE
 * DESC:     Used to locate the mc index on mgid={dst_mod,dst_port} combination from HG2. 
 * SIZE:     32
 * FIELDS:
 *     HIGIG2_MC_SIZE   Size of the index.
 *     HIGIG2_MC_BASE_OFFSET offset to locate the index.
 *
 ******************************************************************************/
#define BCM56218_A0_MC_CONTROL_2r 0x01780006

#define BCM56218_A0_MC_CONTROL_2r_SIZE 4

/*
 * This structure should be used to declare and program MC_CONTROL_2.
 *
 */
typedef union BCM56218_A0_MC_CONTROL_2r_s {
	uint32_t v[1];
	uint32_t mc_control_2[1];
	uint32_t _mc_control_2;
} BCM56218_A0_MC_CONTROL_2r_t;

#define BCM56218_A0_MC_CONTROL_2r_CLR(r) (r).mc_control_2[0] = 0
#define BCM56218_A0_MC_CONTROL_2r_SET(r,d) (r).mc_control_2[0] = d
#define BCM56218_A0_MC_CONTROL_2r_GET(r) (r).mc_control_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MC_CONTROL_2r_HIGIG2_MC_SIZEf_GET(r) (((r).mc_control_2[0]) & 0xffff)
#define BCM56218_A0_MC_CONTROL_2r_HIGIG2_MC_SIZEf_SET(r,f) (r).mc_control_2[0]=(((r).mc_control_2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56218_A0_MC_CONTROL_2r_HIGIG2_MC_BASE_OFFSETf_GET(r) ((((r).mc_control_2[0]) >> 16) & 0xffff)
#define BCM56218_A0_MC_CONTROL_2r_HIGIG2_MC_BASE_OFFSETf_SET(r,f) (r).mc_control_2[0]=(((r).mc_control_2[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access MC_CONTROL_2.
 *
 */
#define BCM56218_A0_READ_MC_CONTROL_2r(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_MC_CONTROL_2r,(r._mc_control_2))
#define BCM56218_A0_WRITE_MC_CONTROL_2r(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_MC_CONTROL_2r,&(r._mc_control_2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MC_CONTROL_2r BCM56218_A0_MC_CONTROL_2r
#define MC_CONTROL_2r_SIZE BCM56218_A0_MC_CONTROL_2r_SIZE
typedef BCM56218_A0_MC_CONTROL_2r_t MC_CONTROL_2r_t;
#define MC_CONTROL_2r_CLR BCM56218_A0_MC_CONTROL_2r_CLR
#define MC_CONTROL_2r_SET BCM56218_A0_MC_CONTROL_2r_SET
#define MC_CONTROL_2r_GET BCM56218_A0_MC_CONTROL_2r_GET
#define MC_CONTROL_2r_HIGIG2_MC_SIZEf_GET BCM56218_A0_MC_CONTROL_2r_HIGIG2_MC_SIZEf_GET
#define MC_CONTROL_2r_HIGIG2_MC_SIZEf_SET BCM56218_A0_MC_CONTROL_2r_HIGIG2_MC_SIZEf_SET
#define MC_CONTROL_2r_HIGIG2_MC_BASE_OFFSETf_GET BCM56218_A0_MC_CONTROL_2r_HIGIG2_MC_BASE_OFFSETf_GET
#define MC_CONTROL_2r_HIGIG2_MC_BASE_OFFSETf_SET BCM56218_A0_MC_CONTROL_2r_HIGIG2_MC_BASE_OFFSETf_SET
#define READ_MC_CONTROL_2r BCM56218_A0_READ_MC_CONTROL_2r
#define WRITE_MC_CONTROL_2r BCM56218_A0_WRITE_MC_CONTROL_2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MC_CONTROL_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  MC_CONTROL_3
 * BLOCKS:   IPIPE
 * DESC:     Control bits to manipulate a overflowing MC index 
 * SIZE:     32
 * FIELDS:
 *     L2MC_MASK_LEN    Mask Length for L2MC groups.
 *     ALLOW_L2MC_INDEX_WRAP_AROUND If this bit is set and the L2MC group index is bigger than HIGIG2_L2MC_SIZE, apply the mask based on HIGIG2_L2MC_MASK_LEN.
 *
 ******************************************************************************/
#define BCM56218_A0_MC_CONTROL_3r 0x01780007

#define BCM56218_A0_MC_CONTROL_3r_SIZE 4

/*
 * This structure should be used to declare and program MC_CONTROL_3.
 *
 */
typedef union BCM56218_A0_MC_CONTROL_3r_s {
	uint32_t v[1];
	uint32_t mc_control_3[1];
	uint32_t _mc_control_3;
} BCM56218_A0_MC_CONTROL_3r_t;

#define BCM56218_A0_MC_CONTROL_3r_CLR(r) (r).mc_control_3[0] = 0
#define BCM56218_A0_MC_CONTROL_3r_SET(r,d) (r).mc_control_3[0] = d
#define BCM56218_A0_MC_CONTROL_3r_GET(r) (r).mc_control_3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MC_CONTROL_3r_L2MC_MASK_LENf_GET(r) (((r).mc_control_3[0]) & 0x1f)
#define BCM56218_A0_MC_CONTROL_3r_L2MC_MASK_LENf_SET(r,f) (r).mc_control_3[0]=(((r).mc_control_3[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56218_A0_MC_CONTROL_3r_ALLOW_L2MC_INDEX_WRAP_AROUNDf_GET(r) ((((r).mc_control_3[0]) >> 5) & 0x1)
#define BCM56218_A0_MC_CONTROL_3r_ALLOW_L2MC_INDEX_WRAP_AROUNDf_SET(r,f) (r).mc_control_3[0]=(((r).mc_control_3[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))

/*
 * These macros can be used to access MC_CONTROL_3.
 *
 */
#define BCM56218_A0_READ_MC_CONTROL_3r(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_MC_CONTROL_3r,(r._mc_control_3))
#define BCM56218_A0_WRITE_MC_CONTROL_3r(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_MC_CONTROL_3r,&(r._mc_control_3))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MC_CONTROL_3r BCM56218_A0_MC_CONTROL_3r
#define MC_CONTROL_3r_SIZE BCM56218_A0_MC_CONTROL_3r_SIZE
typedef BCM56218_A0_MC_CONTROL_3r_t MC_CONTROL_3r_t;
#define MC_CONTROL_3r_CLR BCM56218_A0_MC_CONTROL_3r_CLR
#define MC_CONTROL_3r_SET BCM56218_A0_MC_CONTROL_3r_SET
#define MC_CONTROL_3r_GET BCM56218_A0_MC_CONTROL_3r_GET
#define MC_CONTROL_3r_L2MC_MASK_LENf_GET BCM56218_A0_MC_CONTROL_3r_L2MC_MASK_LENf_GET
#define MC_CONTROL_3r_L2MC_MASK_LENf_SET BCM56218_A0_MC_CONTROL_3r_L2MC_MASK_LENf_SET
#define MC_CONTROL_3r_ALLOW_L2MC_INDEX_WRAP_AROUNDf_GET BCM56218_A0_MC_CONTROL_3r_ALLOW_L2MC_INDEX_WRAP_AROUNDf_GET
#define MC_CONTROL_3r_ALLOW_L2MC_INDEX_WRAP_AROUNDf_SET BCM56218_A0_MC_CONTROL_3r_ALLOW_L2MC_INDEX_WRAP_AROUNDf_SET
#define READ_MC_CONTROL_3r BCM56218_A0_READ_MC_CONTROL_3r
#define WRITE_MC_CONTROL_3r BCM56218_A0_WRITE_MC_CONTROL_3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MC_CONTROL_3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  MEMFAILINTMASK
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CFAPFAILINTMASK  MMU Memfail Interrupt enable bit to enable MMU MemFail Interrupt for CFAP memory stack underrun or overrun condition.1: Enable MMU MemFail Interrupt. 0: Disable MMU MemFail Interrupt. Default.
 *     SOFTRESETINTMASK MMU Memfail Interrupt enable bit to enable MMU MemFail Interrupt for receiving a first cell follow by a first cell without end cell condition.1: Enable MMU MemFail Interrupt. 0: Disable MMU MemFail Interrupt. Default. 
 *     CELLNOTIPINTMASK MMU Memfail Interrupt enable bit to enable MMU MemFail Interrupt fordetecting sending out garbage cells not in packet process. ie. Cell after End-Cell without a start bit. or Two Start cell without anEnd Cell in between.1: Enable MMU MemFail Interrupt. 0: Disable MMU MemFail Interrupt. Default. 
 *     CRCERRORINTMASK  MMU Memfail Interrupt Mask bit to enable MMU MemFail Interrupt fordetecting a failure of CBP cell data memory crc error condition.1: Enable MMU MemFail Interrupt. 0: Disable MMU MemFail Interrupt. Default. 
 *     CBPPKTHDRPARITYERRORINTMASK MMU Memfail Interrupt Mask bit to enable MMU MemFail Interrupt fordetecting a failure of CBP packet header memory parity error condition.1: Enable MMU MemFail Interrupt. 0: Disable MMU MemFail Interrupt. Default. 
 *     CBPCELLHDRPARITYERRORINTMASK MMU Memfail Interrupt Mask bit to enable MMU MemFail Interrupt whendetecting a failure of CBP cell header memory parity error condition.1: Enable MMU MemFail Interrupt. 0: Disable MMU MemFail Interrupt. Default. 
 *     XQPARITYERRORINTMASK MMU Memfail Interrupt Mask to enable MMU send out MemFail Interrupt whendetecting a failure of XQ memory parity error condition.1: Enable MMU MemFail Interrupt. 0: Disable MMU MemFail Interrupt. Default. 
 *     CFAPPARITYERRORINTMASK MMU CFAP Memory parity fail status for detecting cfap memory parity error. 1: Enable MMU MemFail Interrupt. 0: Disable MMU MemFail Interrupt. Default. 
 *     CCPPARITYERRORINTMASK MMU CCP Memory parity fail interrupt Mask for detecting ccp memory parity error.1: Enable MMU MemFail Interrupt. 0: Disable MMU MemFail Interrupt. Default. 
 *
 ******************************************************************************/
#define BCM56218_A0_MEMFAILINTMASKr 0x00680035

#define BCM56218_A0_MEMFAILINTMASKr_SIZE 4

/*
 * This structure should be used to declare and program MEMFAILINTMASK.
 *
 */
typedef union BCM56218_A0_MEMFAILINTMASKr_s {
	uint32_t v[1];
	uint32_t memfailintmask[1];
	uint32_t _memfailintmask;
} BCM56218_A0_MEMFAILINTMASKr_t;

#define BCM56218_A0_MEMFAILINTMASKr_CLR(r) (r).memfailintmask[0] = 0
#define BCM56218_A0_MEMFAILINTMASKr_SET(r,d) (r).memfailintmask[0] = d
#define BCM56218_A0_MEMFAILINTMASKr_GET(r) (r).memfailintmask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MEMFAILINTMASKr_CFAPFAILINTMASKf_GET(r) (((r).memfailintmask[0]) & 0x1)
#define BCM56218_A0_MEMFAILINTMASKr_CFAPFAILINTMASKf_SET(r,f) (r).memfailintmask[0]=(((r).memfailintmask[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_MEMFAILINTMASKr_SOFTRESETINTMASKf_GET(r) ((((r).memfailintmask[0]) >> 1) & 0x1)
#define BCM56218_A0_MEMFAILINTMASKr_SOFTRESETINTMASKf_SET(r,f) (r).memfailintmask[0]=(((r).memfailintmask[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_MEMFAILINTMASKr_CELLNOTIPINTMASKf_GET(r) ((((r).memfailintmask[0]) >> 2) & 0x1)
#define BCM56218_A0_MEMFAILINTMASKr_CELLNOTIPINTMASKf_SET(r,f) (r).memfailintmask[0]=(((r).memfailintmask[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_MEMFAILINTMASKr_CRCERRORINTMASKf_GET(r) ((((r).memfailintmask[0]) >> 3) & 0x1)
#define BCM56218_A0_MEMFAILINTMASKr_CRCERRORINTMASKf_SET(r,f) (r).memfailintmask[0]=(((r).memfailintmask[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56218_A0_MEMFAILINTMASKr_CBPPKTHDRPARITYERRORINTMASKf_GET(r) ((((r).memfailintmask[0]) >> 4) & 0x1)
#define BCM56218_A0_MEMFAILINTMASKr_CBPPKTHDRPARITYERRORINTMASKf_SET(r,f) (r).memfailintmask[0]=(((r).memfailintmask[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56218_A0_MEMFAILINTMASKr_CBPCELLHDRPARITYERRORINTMASKf_GET(r) ((((r).memfailintmask[0]) >> 5) & 0x1)
#define BCM56218_A0_MEMFAILINTMASKr_CBPCELLHDRPARITYERRORINTMASKf_SET(r,f) (r).memfailintmask[0]=(((r).memfailintmask[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56218_A0_MEMFAILINTMASKr_XQPARITYERRORINTMASKf_GET(r) ((((r).memfailintmask[0]) >> 6) & 0x1)
#define BCM56218_A0_MEMFAILINTMASKr_XQPARITYERRORINTMASKf_SET(r,f) (r).memfailintmask[0]=(((r).memfailintmask[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56218_A0_MEMFAILINTMASKr_CFAPPARITYERRORINTMASKf_GET(r) ((((r).memfailintmask[0]) >> 7) & 0x1)
#define BCM56218_A0_MEMFAILINTMASKr_CFAPPARITYERRORINTMASKf_SET(r,f) (r).memfailintmask[0]=(((r).memfailintmask[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56218_A0_MEMFAILINTMASKr_CCPPARITYERRORINTMASKf_GET(r) ((((r).memfailintmask[0]) >> 8) & 0x1)
#define BCM56218_A0_MEMFAILINTMASKr_CCPPARITYERRORINTMASKf_SET(r,f) (r).memfailintmask[0]=(((r).memfailintmask[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))

/*
 * These macros can be used to access MEMFAILINTMASK.
 *
 */
#define BCM56218_A0_READ_MEMFAILINTMASKr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_MEMFAILINTMASKr,(r._memfailintmask))
#define BCM56218_A0_WRITE_MEMFAILINTMASKr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_MEMFAILINTMASKr,&(r._memfailintmask))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEMFAILINTMASKr BCM56218_A0_MEMFAILINTMASKr
#define MEMFAILINTMASKr_SIZE BCM56218_A0_MEMFAILINTMASKr_SIZE
typedef BCM56218_A0_MEMFAILINTMASKr_t MEMFAILINTMASKr_t;
#define MEMFAILINTMASKr_CLR BCM56218_A0_MEMFAILINTMASKr_CLR
#define MEMFAILINTMASKr_SET BCM56218_A0_MEMFAILINTMASKr_SET
#define MEMFAILINTMASKr_GET BCM56218_A0_MEMFAILINTMASKr_GET
#define MEMFAILINTMASKr_CFAPFAILINTMASKf_GET BCM56218_A0_MEMFAILINTMASKr_CFAPFAILINTMASKf_GET
#define MEMFAILINTMASKr_CFAPFAILINTMASKf_SET BCM56218_A0_MEMFAILINTMASKr_CFAPFAILINTMASKf_SET
#define MEMFAILINTMASKr_SOFTRESETINTMASKf_GET BCM56218_A0_MEMFAILINTMASKr_SOFTRESETINTMASKf_GET
#define MEMFAILINTMASKr_SOFTRESETINTMASKf_SET BCM56218_A0_MEMFAILINTMASKr_SOFTRESETINTMASKf_SET
#define MEMFAILINTMASKr_CELLNOTIPINTMASKf_GET BCM56218_A0_MEMFAILINTMASKr_CELLNOTIPINTMASKf_GET
#define MEMFAILINTMASKr_CELLNOTIPINTMASKf_SET BCM56218_A0_MEMFAILINTMASKr_CELLNOTIPINTMASKf_SET
#define MEMFAILINTMASKr_CRCERRORINTMASKf_GET BCM56218_A0_MEMFAILINTMASKr_CRCERRORINTMASKf_GET
#define MEMFAILINTMASKr_CRCERRORINTMASKf_SET BCM56218_A0_MEMFAILINTMASKr_CRCERRORINTMASKf_SET
#define MEMFAILINTMASKr_CBPPKTHDRPARITYERRORINTMASKf_GET BCM56218_A0_MEMFAILINTMASKr_CBPPKTHDRPARITYERRORINTMASKf_GET
#define MEMFAILINTMASKr_CBPPKTHDRPARITYERRORINTMASKf_SET BCM56218_A0_MEMFAILINTMASKr_CBPPKTHDRPARITYERRORINTMASKf_SET
#define MEMFAILINTMASKr_CBPCELLHDRPARITYERRORINTMASKf_GET BCM56218_A0_MEMFAILINTMASKr_CBPCELLHDRPARITYERRORINTMASKf_GET
#define MEMFAILINTMASKr_CBPCELLHDRPARITYERRORINTMASKf_SET BCM56218_A0_MEMFAILINTMASKr_CBPCELLHDRPARITYERRORINTMASKf_SET
#define MEMFAILINTMASKr_XQPARITYERRORINTMASKf_GET BCM56218_A0_MEMFAILINTMASKr_XQPARITYERRORINTMASKf_GET
#define MEMFAILINTMASKr_XQPARITYERRORINTMASKf_SET BCM56218_A0_MEMFAILINTMASKr_XQPARITYERRORINTMASKf_SET
#define MEMFAILINTMASKr_CFAPPARITYERRORINTMASKf_GET BCM56218_A0_MEMFAILINTMASKr_CFAPPARITYERRORINTMASKf_GET
#define MEMFAILINTMASKr_CFAPPARITYERRORINTMASKf_SET BCM56218_A0_MEMFAILINTMASKr_CFAPPARITYERRORINTMASKf_SET
#define MEMFAILINTMASKr_CCPPARITYERRORINTMASKf_GET BCM56218_A0_MEMFAILINTMASKr_CCPPARITYERRORINTMASKf_GET
#define MEMFAILINTMASKr_CCPPARITYERRORINTMASKf_SET BCM56218_A0_MEMFAILINTMASKr_CCPPARITYERRORINTMASKf_SET
#define READ_MEMFAILINTMASKr BCM56218_A0_READ_MEMFAILINTMASKr
#define WRITE_MEMFAILINTMASKr BCM56218_A0_WRITE_MEMFAILINTMASKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MEMFAILINTMASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  MEMFAILINTSTATUS
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CFAPFAILERROR    MMU CFAP Fail Status for CFAP memory stack underrun or overrun condition. 
 *     SOFTRESETERROR   MMU detect software reset error status for receiving a first cell follow by a first cell without end cell condition.
 *     CELLNOTIPERROR   MMU Sending Cell Not In Progress error status for MMU sending out garbage cells not in packet. ie. Cell after End-Cell without a start bit.
 *     CELLCRCERROR     MMU CBP cell data crc fail status for detecting data emory crc error. 
 *     CBPPKTHDRPARITYERROR MMU CBP Packet Header Memory parity fail status for detecting packet header memory parity error. 
 *     CBPCELLHDRPARITYERROR MMU CBP Cell Header Memory parity fail status for detecting cell header memory parity error. CBP Cell Header Memory parity bit [32] covered from bit 0 bit 15. Cell CRC checksum field, bit 16 to bit 31, is not covered by paritycheck. 
 *     XQPARITYERROR    MMU XQ Memory parity fail status for detecting xq memory parity error. 
 *     CFAPPARITYERROR  MMU CFAP Memory parity fail status for detecting cfap memory parity error. 
 *     CCPPARITYERROR   MMU CCP Memory parity fail status for detecting ccp memory parity error. 
 *     MEMFAILINTCOUNT  Mem Fail Message Counter to count mem fail events. 
 *
 ******************************************************************************/
#define BCM56218_A0_MEMFAILINTSTATUSr 0x00680036

#define BCM56218_A0_MEMFAILINTSTATUSr_SIZE 4

/*
 * This structure should be used to declare and program MEMFAILINTSTATUS.
 *
 */
typedef union BCM56218_A0_MEMFAILINTSTATUSr_s {
	uint32_t v[1];
	uint32_t memfailintstatus[1];
	uint32_t _memfailintstatus;
} BCM56218_A0_MEMFAILINTSTATUSr_t;

#define BCM56218_A0_MEMFAILINTSTATUSr_CLR(r) (r).memfailintstatus[0] = 0
#define BCM56218_A0_MEMFAILINTSTATUSr_SET(r,d) (r).memfailintstatus[0] = d
#define BCM56218_A0_MEMFAILINTSTATUSr_GET(r) (r).memfailintstatus[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MEMFAILINTSTATUSr_CFAPFAILERRORf_GET(r) (((r).memfailintstatus[0]) & 0x1)
#define BCM56218_A0_MEMFAILINTSTATUSr_CFAPFAILERRORf_SET(r,f) (r).memfailintstatus[0]=(((r).memfailintstatus[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_MEMFAILINTSTATUSr_SOFTRESETERRORf_GET(r) ((((r).memfailintstatus[0]) >> 1) & 0x1)
#define BCM56218_A0_MEMFAILINTSTATUSr_SOFTRESETERRORf_SET(r,f) (r).memfailintstatus[0]=(((r).memfailintstatus[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_MEMFAILINTSTATUSr_CELLNOTIPERRORf_GET(r) ((((r).memfailintstatus[0]) >> 2) & 0x1)
#define BCM56218_A0_MEMFAILINTSTATUSr_CELLNOTIPERRORf_SET(r,f) (r).memfailintstatus[0]=(((r).memfailintstatus[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_MEMFAILINTSTATUSr_CELLCRCERRORf_GET(r) ((((r).memfailintstatus[0]) >> 3) & 0x1)
#define BCM56218_A0_MEMFAILINTSTATUSr_CELLCRCERRORf_SET(r,f) (r).memfailintstatus[0]=(((r).memfailintstatus[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56218_A0_MEMFAILINTSTATUSr_CBPPKTHDRPARITYERRORf_GET(r) ((((r).memfailintstatus[0]) >> 4) & 0x1)
#define BCM56218_A0_MEMFAILINTSTATUSr_CBPPKTHDRPARITYERRORf_SET(r,f) (r).memfailintstatus[0]=(((r).memfailintstatus[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56218_A0_MEMFAILINTSTATUSr_CBPCELLHDRPARITYERRORf_GET(r) ((((r).memfailintstatus[0]) >> 5) & 0x1)
#define BCM56218_A0_MEMFAILINTSTATUSr_CBPCELLHDRPARITYERRORf_SET(r,f) (r).memfailintstatus[0]=(((r).memfailintstatus[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56218_A0_MEMFAILINTSTATUSr_XQPARITYERRORf_GET(r) ((((r).memfailintstatus[0]) >> 6) & 0x1)
#define BCM56218_A0_MEMFAILINTSTATUSr_XQPARITYERRORf_SET(r,f) (r).memfailintstatus[0]=(((r).memfailintstatus[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56218_A0_MEMFAILINTSTATUSr_CFAPPARITYERRORf_GET(r) ((((r).memfailintstatus[0]) >> 7) & 0x1)
#define BCM56218_A0_MEMFAILINTSTATUSr_CFAPPARITYERRORf_SET(r,f) (r).memfailintstatus[0]=(((r).memfailintstatus[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56218_A0_MEMFAILINTSTATUSr_CCPPARITYERRORf_GET(r) ((((r).memfailintstatus[0]) >> 8) & 0x1)
#define BCM56218_A0_MEMFAILINTSTATUSr_CCPPARITYERRORf_SET(r,f) (r).memfailintstatus[0]=(((r).memfailintstatus[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56218_A0_MEMFAILINTSTATUSr_MEMFAILINTCOUNTf_GET(r) ((((r).memfailintstatus[0]) >> 9) & 0xffff)
#define BCM56218_A0_MEMFAILINTSTATUSr_MEMFAILINTCOUNTf_SET(r,f) (r).memfailintstatus[0]=(((r).memfailintstatus[0] & ~((uint32_t)0xffff << 9)) | ((((uint32_t)f) & 0xffff) << 9))

/*
 * These macros can be used to access MEMFAILINTSTATUS.
 *
 */
#define BCM56218_A0_READ_MEMFAILINTSTATUSr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_MEMFAILINTSTATUSr,(r._memfailintstatus))
#define BCM56218_A0_WRITE_MEMFAILINTSTATUSr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_MEMFAILINTSTATUSr,&(r._memfailintstatus))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEMFAILINTSTATUSr BCM56218_A0_MEMFAILINTSTATUSr
#define MEMFAILINTSTATUSr_SIZE BCM56218_A0_MEMFAILINTSTATUSr_SIZE
typedef BCM56218_A0_MEMFAILINTSTATUSr_t MEMFAILINTSTATUSr_t;
#define MEMFAILINTSTATUSr_CLR BCM56218_A0_MEMFAILINTSTATUSr_CLR
#define MEMFAILINTSTATUSr_SET BCM56218_A0_MEMFAILINTSTATUSr_SET
#define MEMFAILINTSTATUSr_GET BCM56218_A0_MEMFAILINTSTATUSr_GET
#define MEMFAILINTSTATUSr_CFAPFAILERRORf_GET BCM56218_A0_MEMFAILINTSTATUSr_CFAPFAILERRORf_GET
#define MEMFAILINTSTATUSr_CFAPFAILERRORf_SET BCM56218_A0_MEMFAILINTSTATUSr_CFAPFAILERRORf_SET
#define MEMFAILINTSTATUSr_SOFTRESETERRORf_GET BCM56218_A0_MEMFAILINTSTATUSr_SOFTRESETERRORf_GET
#define MEMFAILINTSTATUSr_SOFTRESETERRORf_SET BCM56218_A0_MEMFAILINTSTATUSr_SOFTRESETERRORf_SET
#define MEMFAILINTSTATUSr_CELLNOTIPERRORf_GET BCM56218_A0_MEMFAILINTSTATUSr_CELLNOTIPERRORf_GET
#define MEMFAILINTSTATUSr_CELLNOTIPERRORf_SET BCM56218_A0_MEMFAILINTSTATUSr_CELLNOTIPERRORf_SET
#define MEMFAILINTSTATUSr_CELLCRCERRORf_GET BCM56218_A0_MEMFAILINTSTATUSr_CELLCRCERRORf_GET
#define MEMFAILINTSTATUSr_CELLCRCERRORf_SET BCM56218_A0_MEMFAILINTSTATUSr_CELLCRCERRORf_SET
#define MEMFAILINTSTATUSr_CBPPKTHDRPARITYERRORf_GET BCM56218_A0_MEMFAILINTSTATUSr_CBPPKTHDRPARITYERRORf_GET
#define MEMFAILINTSTATUSr_CBPPKTHDRPARITYERRORf_SET BCM56218_A0_MEMFAILINTSTATUSr_CBPPKTHDRPARITYERRORf_SET
#define MEMFAILINTSTATUSr_CBPCELLHDRPARITYERRORf_GET BCM56218_A0_MEMFAILINTSTATUSr_CBPCELLHDRPARITYERRORf_GET
#define MEMFAILINTSTATUSr_CBPCELLHDRPARITYERRORf_SET BCM56218_A0_MEMFAILINTSTATUSr_CBPCELLHDRPARITYERRORf_SET
#define MEMFAILINTSTATUSr_XQPARITYERRORf_GET BCM56218_A0_MEMFAILINTSTATUSr_XQPARITYERRORf_GET
#define MEMFAILINTSTATUSr_XQPARITYERRORf_SET BCM56218_A0_MEMFAILINTSTATUSr_XQPARITYERRORf_SET
#define MEMFAILINTSTATUSr_CFAPPARITYERRORf_GET BCM56218_A0_MEMFAILINTSTATUSr_CFAPPARITYERRORf_GET
#define MEMFAILINTSTATUSr_CFAPPARITYERRORf_SET BCM56218_A0_MEMFAILINTSTATUSr_CFAPPARITYERRORf_SET
#define MEMFAILINTSTATUSr_CCPPARITYERRORf_GET BCM56218_A0_MEMFAILINTSTATUSr_CCPPARITYERRORf_GET
#define MEMFAILINTSTATUSr_CCPPARITYERRORf_SET BCM56218_A0_MEMFAILINTSTATUSr_CCPPARITYERRORf_SET
#define MEMFAILINTSTATUSr_MEMFAILINTCOUNTf_GET BCM56218_A0_MEMFAILINTSTATUSr_MEMFAILINTCOUNTf_GET
#define MEMFAILINTSTATUSr_MEMFAILINTCOUNTf_SET BCM56218_A0_MEMFAILINTSTATUSr_MEMFAILINTCOUNTf_SET
#define READ_MEMFAILINTSTATUSr BCM56218_A0_READ_MEMFAILINTSTATUSr
#define WRITE_MEMFAILINTSTATUSr BCM56218_A0_WRITE_MEMFAILINTSTATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MEMFAILINTSTATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  MIRROR_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     Mirror control register
 * SIZE:     32
 * FIELDS:
 *     M_ENABLE         Enable mirroring
 *     IM_MTP_INDEX     Ingress MTP index
 *     EM_MTP_INDEX     Egress MTP index
 *     NON_UC_EM_MTP_INDEX Non-unicast egress MTP index
 *     SRC_MODID_BLOCK_MIRROR_ONLY_PKT Apply the source modid block masks, programmed in SRC_MODID_BLOCK table, for MTP of HiGig pkts with MH.M=1, MH.MO=1, MH.MD=0 ports
 *     SRC_MODID_BLOCK_MIRROR_COPY Apply the source modid block masks, programmed in SRC_MODID_BLOCK table, for MTP of HiGig pkts with MH.M=1, MH.MO=0, MH.MD=0 ports
 *
 ******************************************************************************/
#define BCM56218_A0_MIRROR_CONTROLr 0x0e700108

#define BCM56218_A0_MIRROR_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program MIRROR_CONTROL.
 *
 */
typedef union BCM56218_A0_MIRROR_CONTROLr_s {
	uint32_t v[1];
	uint32_t mirror_control[1];
	uint32_t _mirror_control;
} BCM56218_A0_MIRROR_CONTROLr_t;

#define BCM56218_A0_MIRROR_CONTROLr_CLR(r) (r).mirror_control[0] = 0
#define BCM56218_A0_MIRROR_CONTROLr_SET(r,d) (r).mirror_control[0] = d
#define BCM56218_A0_MIRROR_CONTROLr_GET(r) (r).mirror_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MIRROR_CONTROLr_M_ENABLEf_GET(r) (((r).mirror_control[0]) & 0x1)
#define BCM56218_A0_MIRROR_CONTROLr_M_ENABLEf_SET(r,f) (r).mirror_control[0]=(((r).mirror_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_MIRROR_CONTROLr_IM_MTP_INDEXf_GET(r) ((((r).mirror_control[0]) >> 1) & 0x3)
#define BCM56218_A0_MIRROR_CONTROLr_IM_MTP_INDEXf_SET(r,f) (r).mirror_control[0]=(((r).mirror_control[0] & ~((uint32_t)0x3 << 1)) | ((((uint32_t)f) & 0x3) << 1))
#define BCM56218_A0_MIRROR_CONTROLr_EM_MTP_INDEXf_GET(r) ((((r).mirror_control[0]) >> 3) & 0x3)
#define BCM56218_A0_MIRROR_CONTROLr_EM_MTP_INDEXf_SET(r,f) (r).mirror_control[0]=(((r).mirror_control[0] & ~((uint32_t)0x3 << 3)) | ((((uint32_t)f) & 0x3) << 3))
#define BCM56218_A0_MIRROR_CONTROLr_NON_UC_EM_MTP_INDEXf_GET(r) ((((r).mirror_control[0]) >> 5) & 0x3)
#define BCM56218_A0_MIRROR_CONTROLr_NON_UC_EM_MTP_INDEXf_SET(r,f) (r).mirror_control[0]=(((r).mirror_control[0] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5))
#define BCM56218_A0_MIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_ONLY_PKTf_GET(r) ((((r).mirror_control[0]) >> 7) & 0x1)
#define BCM56218_A0_MIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_ONLY_PKTf_SET(r,f) (r).mirror_control[0]=(((r).mirror_control[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56218_A0_MIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_COPYf_GET(r) ((((r).mirror_control[0]) >> 8) & 0x1)
#define BCM56218_A0_MIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_COPYf_SET(r,f) (r).mirror_control[0]=(((r).mirror_control[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))

/*
 * These macros can be used to access MIRROR_CONTROL.
 *
 */
#define BCM56218_A0_READ_MIRROR_CONTROLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_MIRROR_CONTROLr,(r._mirror_control))
#define BCM56218_A0_WRITE_MIRROR_CONTROLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_MIRROR_CONTROLr,&(r._mirror_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIRROR_CONTROLr BCM56218_A0_MIRROR_CONTROLr
#define MIRROR_CONTROLr_SIZE BCM56218_A0_MIRROR_CONTROLr_SIZE
typedef BCM56218_A0_MIRROR_CONTROLr_t MIRROR_CONTROLr_t;
#define MIRROR_CONTROLr_CLR BCM56218_A0_MIRROR_CONTROLr_CLR
#define MIRROR_CONTROLr_SET BCM56218_A0_MIRROR_CONTROLr_SET
#define MIRROR_CONTROLr_GET BCM56218_A0_MIRROR_CONTROLr_GET
#define MIRROR_CONTROLr_M_ENABLEf_GET BCM56218_A0_MIRROR_CONTROLr_M_ENABLEf_GET
#define MIRROR_CONTROLr_M_ENABLEf_SET BCM56218_A0_MIRROR_CONTROLr_M_ENABLEf_SET
#define MIRROR_CONTROLr_IM_MTP_INDEXf_GET BCM56218_A0_MIRROR_CONTROLr_IM_MTP_INDEXf_GET
#define MIRROR_CONTROLr_IM_MTP_INDEXf_SET BCM56218_A0_MIRROR_CONTROLr_IM_MTP_INDEXf_SET
#define MIRROR_CONTROLr_EM_MTP_INDEXf_GET BCM56218_A0_MIRROR_CONTROLr_EM_MTP_INDEXf_GET
#define MIRROR_CONTROLr_EM_MTP_INDEXf_SET BCM56218_A0_MIRROR_CONTROLr_EM_MTP_INDEXf_SET
#define MIRROR_CONTROLr_NON_UC_EM_MTP_INDEXf_GET BCM56218_A0_MIRROR_CONTROLr_NON_UC_EM_MTP_INDEXf_GET
#define MIRROR_CONTROLr_NON_UC_EM_MTP_INDEXf_SET BCM56218_A0_MIRROR_CONTROLr_NON_UC_EM_MTP_INDEXf_SET
#define MIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_ONLY_PKTf_GET BCM56218_A0_MIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_ONLY_PKTf_GET
#define MIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_ONLY_PKTf_SET BCM56218_A0_MIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_ONLY_PKTf_SET
#define MIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_COPYf_GET BCM56218_A0_MIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_COPYf_GET
#define MIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_COPYf_SET BCM56218_A0_MIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_COPYf_SET
#define READ_MIRROR_CONTROLr BCM56218_A0_READ_MIRROR_CONTROLr
#define WRITE_MIRROR_CONTROLr BCM56218_A0_WRITE_MIRROR_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MIRROR_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  MISCCONFIG
 * BLOCKS:   MMU
 * DESC:     Controls various functions in the MMU
 * SIZE:     32
 * FIELDS:
 *     DYNAMIC_MEMORY_EN Dynamic Memory Mode EnableHOL cell limit behavior (dynamic sharing of CBP):1: Dynamic Memory mode is enabled,0: Dynamic Memory mode is disabled.
 *     CLRDROPCTR       Clear All Drop Packet CountersWhen set to 1, MMU will clear all port counter of the followings:DROPPEDPKTCOUNT, CNG0DROPCOUNT, CNG1DROPCOUNT  & CELLCRCERRCOUNT.Read to this bit will always return 0.
 *     CELLCRCCHECKEN   MMU cell data CRC checking enable to detect MMU internal memory failure during operation. Failure Cell Pointer can be retrieved from CELLCRCERRPOINTER regsiter. Failure pointer count can be retrieved from CELLCRCERRCOUNT register.This crc checking function can detect bith Cell CRC error and CBP Header Parity error.1: Enable sending sbus Memfail message based Cell CRC error and CBP Header Parity error. on CRC error and infroming egree about this error. Currenttransmitting packet will be corrupted. 0: Disable sending sbus Memfail message based on CRC error and not infroming egree       about this error. Default.
 *     SKIDMARKER       SkidMarker for each HOL Packet Counter, reaserved value for for the packetsalready in the transsion to beaccepted by mmu XQ.The values of SkidMarker are:2\'b00: 4 packets,2\'b01: 5 packets, 2\'b10: 6 packets,2\'b11: 7 packets.
 *     HOLMAXTIMER      HOL Maximum Timer for sending periodic HOL COSx and IBP discard status to IngressPipeline. The values of HOL Maximum Timer counts in the unit of micron second.If se to 0 there will be no periodic status send to Ingress Pipeline only sendon the time when status are changed.Default value is disable.
 *     SLAM_MEM         Write 1 into this register will interrupt CFAP & CCP power-on initialization.After write 1 into this register, users are able to slam cfap and ccp memorieswith desired value. When memoryslamming is done, users need to wirte 1 intoCFAPINIT bit in CFAPCONFIG register to complete CFAP & CCP initialzation.This regsiter should not be programmed while the tarffic is on. It may generateunexpected result.
 *     METERING_CLK_EN  METERING_CLK_EN will enable metering 7.8125us refresh tick to flow into egress portmetering, min/max bucket and ingress back pressure metering function.0: disable refresh tick,1: enable refresh tick.
 *     PARITY_CHECK_EN  PARITY_CHECK_EN enable MMU checking the parity of Memory read out data.0: disable memory parity check,1: enable memory parity check.
 *     HOL_CELL_SOP_DROP_EN Only do hol cell drop on sop cell to help TCP performance
 *
 ******************************************************************************/
#define BCM56218_A0_MISCCONFIGr 0x0068001f

#define BCM56218_A0_MISCCONFIGr_SIZE 4

/*
 * This structure should be used to declare and program MISCCONFIG.
 *
 */
typedef union BCM56218_A0_MISCCONFIGr_s {
	uint32_t v[1];
	uint32_t miscconfig[1];
	uint32_t _miscconfig;
} BCM56218_A0_MISCCONFIGr_t;

#define BCM56218_A0_MISCCONFIGr_CLR(r) (r).miscconfig[0] = 0
#define BCM56218_A0_MISCCONFIGr_SET(r,d) (r).miscconfig[0] = d
#define BCM56218_A0_MISCCONFIGr_GET(r) (r).miscconfig[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MISCCONFIGr_DYNAMIC_MEMORY_ENf_GET(r) (((r).miscconfig[0]) & 0x1)
#define BCM56218_A0_MISCCONFIGr_DYNAMIC_MEMORY_ENf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_MISCCONFIGr_CLRDROPCTRf_GET(r) ((((r).miscconfig[0]) >> 1) & 0x1)
#define BCM56218_A0_MISCCONFIGr_CLRDROPCTRf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_MISCCONFIGr_CELLCRCCHECKENf_GET(r) ((((r).miscconfig[0]) >> 2) & 0x1)
#define BCM56218_A0_MISCCONFIGr_CELLCRCCHECKENf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_MISCCONFIGr_SKIDMARKERf_GET(r) ((((r).miscconfig[0]) >> 3) & 0x3)
#define BCM56218_A0_MISCCONFIGr_SKIDMARKERf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32_t)0x3 << 3)) | ((((uint32_t)f) & 0x3) << 3))
#define BCM56218_A0_MISCCONFIGr_HOLMAXTIMERf_GET(r) ((((r).miscconfig[0]) >> 5) & 0x7)
#define BCM56218_A0_MISCCONFIGr_HOLMAXTIMERf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))
#define BCM56218_A0_MISCCONFIGr_SLAM_MEMf_GET(r) ((((r).miscconfig[0]) >> 8) & 0x1)
#define BCM56218_A0_MISCCONFIGr_SLAM_MEMf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56218_A0_MISCCONFIGr_METERING_CLK_ENf_GET(r) ((((r).miscconfig[0]) >> 9) & 0x1)
#define BCM56218_A0_MISCCONFIGr_METERING_CLK_ENf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56218_A0_MISCCONFIGr_PARITY_CHECK_ENf_GET(r) ((((r).miscconfig[0]) >> 10) & 0x1)
#define BCM56218_A0_MISCCONFIGr_PARITY_CHECK_ENf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56218_A0_MISCCONFIGr_HOL_CELL_SOP_DROP_ENf_GET(r) ((((r).miscconfig[0]) >> 11) & 0x1)
#define BCM56218_A0_MISCCONFIGr_HOL_CELL_SOP_DROP_ENf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))

/*
 * These macros can be used to access MISCCONFIG.
 *
 */
#define BCM56218_A0_READ_MISCCONFIGr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_MISCCONFIGr,(r._miscconfig))
#define BCM56218_A0_WRITE_MISCCONFIGr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_MISCCONFIGr,&(r._miscconfig))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MISCCONFIGr BCM56218_A0_MISCCONFIGr
#define MISCCONFIGr_SIZE BCM56218_A0_MISCCONFIGr_SIZE
typedef BCM56218_A0_MISCCONFIGr_t MISCCONFIGr_t;
#define MISCCONFIGr_CLR BCM56218_A0_MISCCONFIGr_CLR
#define MISCCONFIGr_SET BCM56218_A0_MISCCONFIGr_SET
#define MISCCONFIGr_GET BCM56218_A0_MISCCONFIGr_GET
#define MISCCONFIGr_DYNAMIC_MEMORY_ENf_GET BCM56218_A0_MISCCONFIGr_DYNAMIC_MEMORY_ENf_GET
#define MISCCONFIGr_DYNAMIC_MEMORY_ENf_SET BCM56218_A0_MISCCONFIGr_DYNAMIC_MEMORY_ENf_SET
#define MISCCONFIGr_CLRDROPCTRf_GET BCM56218_A0_MISCCONFIGr_CLRDROPCTRf_GET
#define MISCCONFIGr_CLRDROPCTRf_SET BCM56218_A0_MISCCONFIGr_CLRDROPCTRf_SET
#define MISCCONFIGr_CELLCRCCHECKENf_GET BCM56218_A0_MISCCONFIGr_CELLCRCCHECKENf_GET
#define MISCCONFIGr_CELLCRCCHECKENf_SET BCM56218_A0_MISCCONFIGr_CELLCRCCHECKENf_SET
#define MISCCONFIGr_SKIDMARKERf_GET BCM56218_A0_MISCCONFIGr_SKIDMARKERf_GET
#define MISCCONFIGr_SKIDMARKERf_SET BCM56218_A0_MISCCONFIGr_SKIDMARKERf_SET
#define MISCCONFIGr_HOLMAXTIMERf_GET BCM56218_A0_MISCCONFIGr_HOLMAXTIMERf_GET
#define MISCCONFIGr_HOLMAXTIMERf_SET BCM56218_A0_MISCCONFIGr_HOLMAXTIMERf_SET
#define MISCCONFIGr_SLAM_MEMf_GET BCM56218_A0_MISCCONFIGr_SLAM_MEMf_GET
#define MISCCONFIGr_SLAM_MEMf_SET BCM56218_A0_MISCCONFIGr_SLAM_MEMf_SET
#define MISCCONFIGr_METERING_CLK_ENf_GET BCM56218_A0_MISCCONFIGr_METERING_CLK_ENf_GET
#define MISCCONFIGr_METERING_CLK_ENf_SET BCM56218_A0_MISCCONFIGr_METERING_CLK_ENf_SET
#define MISCCONFIGr_PARITY_CHECK_ENf_GET BCM56218_A0_MISCCONFIGr_PARITY_CHECK_ENf_GET
#define MISCCONFIGr_PARITY_CHECK_ENf_SET BCM56218_A0_MISCCONFIGr_PARITY_CHECK_ENf_SET
#define MISCCONFIGr_HOL_CELL_SOP_DROP_ENf_GET BCM56218_A0_MISCCONFIGr_HOL_CELL_SOP_DROP_ENf_GET
#define MISCCONFIGr_HOL_CELL_SOP_DROP_ENf_SET BCM56218_A0_MISCCONFIGr_HOL_CELL_SOP_DROP_ENf_SET
#define READ_MISCCONFIGr BCM56218_A0_READ_MISCCONFIGr
#define WRITE_MISCCONFIGr BCM56218_A0_WRITE_MISCCONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MISCCONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  MMUPORTENABLE
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     MMUPORTENABLE    MMU port enable is to control which mmu egress port can accept packet
 *
 ******************************************************************************/
#define BCM56218_A0_MMUPORTENABLEr 0x00680023

#define BCM56218_A0_MMUPORTENABLEr_SIZE 4

/*
 * This structure should be used to declare and program MMUPORTENABLE.
 *
 */
typedef union BCM56218_A0_MMUPORTENABLEr_s {
	uint32_t v[1];
	uint32_t mmuportenable[1];
	uint32_t _mmuportenable;
} BCM56218_A0_MMUPORTENABLEr_t;

#define BCM56218_A0_MMUPORTENABLEr_CLR(r) (r).mmuportenable[0] = 0
#define BCM56218_A0_MMUPORTENABLEr_SET(r,d) (r).mmuportenable[0] = d
#define BCM56218_A0_MMUPORTENABLEr_GET(r) (r).mmuportenable[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMUPORTENABLEr_MMUPORTENABLEf_GET(r) ((r).mmuportenable[0])
#define BCM56218_A0_MMUPORTENABLEr_MMUPORTENABLEf_SET(r,f) (r).mmuportenable[0]=((uint32_t)f)

/*
 * These macros can be used to access MMUPORTENABLE.
 *
 */
#define BCM56218_A0_READ_MMUPORTENABLEr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_MMUPORTENABLEr,(r._mmuportenable))
#define BCM56218_A0_WRITE_MMUPORTENABLEr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_MMUPORTENABLEr,&(r._mmuportenable))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMUPORTENABLEr BCM56218_A0_MMUPORTENABLEr
#define MMUPORTENABLEr_SIZE BCM56218_A0_MMUPORTENABLEr_SIZE
typedef BCM56218_A0_MMUPORTENABLEr_t MMUPORTENABLEr_t;
#define MMUPORTENABLEr_CLR BCM56218_A0_MMUPORTENABLEr_CLR
#define MMUPORTENABLEr_SET BCM56218_A0_MMUPORTENABLEr_SET
#define MMUPORTENABLEr_GET BCM56218_A0_MMUPORTENABLEr_GET
#define MMUPORTENABLEr_MMUPORTENABLEf_GET BCM56218_A0_MMUPORTENABLEr_MMUPORTENABLEf_GET
#define MMUPORTENABLEr_MMUPORTENABLEf_SET BCM56218_A0_MMUPORTENABLEr_MMUPORTENABLEf_SET
#define READ_MMUPORTENABLEr BCM56218_A0_READ_MMUPORTENABLEr
#define WRITE_MMUPORTENABLEr BCM56218_A0_WRITE_MMUPORTENABLEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMUPORTENABLEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  MMUPORTENABLE_HI
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     MMUPORTENABLE    MMU port enable is to control which mmu egress port can accept packet
 *
 ******************************************************************************/
#define BCM56218_A0_MMUPORTENABLE_HIr 0x00680024

#define BCM56218_A0_MMUPORTENABLE_HIr_SIZE 4

/*
 * This structure should be used to declare and program MMUPORTENABLE_HI.
 *
 */
typedef union BCM56218_A0_MMUPORTENABLE_HIr_s {
	uint32_t v[1];
	uint32_t mmuportenable_hi[1];
	uint32_t _mmuportenable_hi;
} BCM56218_A0_MMUPORTENABLE_HIr_t;

#define BCM56218_A0_MMUPORTENABLE_HIr_CLR(r) (r).mmuportenable_hi[0] = 0
#define BCM56218_A0_MMUPORTENABLE_HIr_SET(r,d) (r).mmuportenable_hi[0] = d
#define BCM56218_A0_MMUPORTENABLE_HIr_GET(r) (r).mmuportenable_hi[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMUPORTENABLE_HIr_MMUPORTENABLEf_GET(r) (((r).mmuportenable_hi[0]) & 0x3fffff)
#define BCM56218_A0_MMUPORTENABLE_HIr_MMUPORTENABLEf_SET(r,f) (r).mmuportenable_hi[0]=(((r).mmuportenable_hi[0] & ~((uint32_t)0x3fffff)) | (((uint32_t)f) & 0x3fffff))

/*
 * These macros can be used to access MMUPORTENABLE_HI.
 *
 */
#define BCM56218_A0_READ_MMUPORTENABLE_HIr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_MMUPORTENABLE_HIr,(r._mmuportenable_hi))
#define BCM56218_A0_WRITE_MMUPORTENABLE_HIr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_MMUPORTENABLE_HIr,&(r._mmuportenable_hi))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMUPORTENABLE_HIr BCM56218_A0_MMUPORTENABLE_HIr
#define MMUPORTENABLE_HIr_SIZE BCM56218_A0_MMUPORTENABLE_HIr_SIZE
typedef BCM56218_A0_MMUPORTENABLE_HIr_t MMUPORTENABLE_HIr_t;
#define MMUPORTENABLE_HIr_CLR BCM56218_A0_MMUPORTENABLE_HIr_CLR
#define MMUPORTENABLE_HIr_SET BCM56218_A0_MMUPORTENABLE_HIr_SET
#define MMUPORTENABLE_HIr_GET BCM56218_A0_MMUPORTENABLE_HIr_GET
#define MMUPORTENABLE_HIr_MMUPORTENABLEf_GET BCM56218_A0_MMUPORTENABLE_HIr_MMUPORTENABLEf_GET
#define MMUPORTENABLE_HIr_MMUPORTENABLEf_SET BCM56218_A0_MMUPORTENABLE_HIr_MMUPORTENABLEf_SET
#define READ_MMUPORTENABLE_HIr BCM56218_A0_READ_MMUPORTENABLE_HIr
#define WRITE_MMUPORTENABLE_HIr BCM56218_A0_WRITE_MMUPORTENABLE_HIr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMUPORTENABLE_HIr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  MMUPORTTXENABLE
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     MMUPORTTXENABLE  MMU port tx enable is to control which mmu egress port (between 31-0) can start transmit packet
 *
 ******************************************************************************/
#define BCM56218_A0_MMUPORTTXENABLEr 0x0068004f

#define BCM56218_A0_MMUPORTTXENABLEr_SIZE 4

/*
 * This structure should be used to declare and program MMUPORTTXENABLE.
 *
 */
typedef union BCM56218_A0_MMUPORTTXENABLEr_s {
	uint32_t v[1];
	uint32_t mmuporttxenable[1];
	uint32_t _mmuporttxenable;
} BCM56218_A0_MMUPORTTXENABLEr_t;

#define BCM56218_A0_MMUPORTTXENABLEr_CLR(r) (r).mmuporttxenable[0] = 0
#define BCM56218_A0_MMUPORTTXENABLEr_SET(r,d) (r).mmuporttxenable[0] = d
#define BCM56218_A0_MMUPORTTXENABLEr_GET(r) (r).mmuporttxenable[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMUPORTTXENABLEr_MMUPORTTXENABLEf_GET(r) ((r).mmuporttxenable[0])
#define BCM56218_A0_MMUPORTTXENABLEr_MMUPORTTXENABLEf_SET(r,f) (r).mmuporttxenable[0]=((uint32_t)f)

/*
 * These macros can be used to access MMUPORTTXENABLE.
 *
 */
#define BCM56218_A0_READ_MMUPORTTXENABLEr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_MMUPORTTXENABLEr,(r._mmuporttxenable))
#define BCM56218_A0_WRITE_MMUPORTTXENABLEr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_MMUPORTTXENABLEr,&(r._mmuporttxenable))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMUPORTTXENABLEr BCM56218_A0_MMUPORTTXENABLEr
#define MMUPORTTXENABLEr_SIZE BCM56218_A0_MMUPORTTXENABLEr_SIZE
typedef BCM56218_A0_MMUPORTTXENABLEr_t MMUPORTTXENABLEr_t;
#define MMUPORTTXENABLEr_CLR BCM56218_A0_MMUPORTTXENABLEr_CLR
#define MMUPORTTXENABLEr_SET BCM56218_A0_MMUPORTTXENABLEr_SET
#define MMUPORTTXENABLEr_GET BCM56218_A0_MMUPORTTXENABLEr_GET
#define MMUPORTTXENABLEr_MMUPORTTXENABLEf_GET BCM56218_A0_MMUPORTTXENABLEr_MMUPORTTXENABLEf_GET
#define MMUPORTTXENABLEr_MMUPORTTXENABLEf_SET BCM56218_A0_MMUPORTTXENABLEr_MMUPORTTXENABLEf_SET
#define READ_MMUPORTTXENABLEr BCM56218_A0_READ_MMUPORTTXENABLEr
#define WRITE_MMUPORTTXENABLEr BCM56218_A0_WRITE_MMUPORTTXENABLEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMUPORTTXENABLEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  MMUPORTTXENABLE_HI
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     MMUPORTTXENABLE  MMU port tx enable is to control which mmu egress port (between 53-32) can start transmit packet
 *
 ******************************************************************************/
#define BCM56218_A0_MMUPORTTXENABLE_HIr 0x00680050

#define BCM56218_A0_MMUPORTTXENABLE_HIr_SIZE 4

/*
 * This structure should be used to declare and program MMUPORTTXENABLE_HI.
 *
 */
typedef union BCM56218_A0_MMUPORTTXENABLE_HIr_s {
	uint32_t v[1];
	uint32_t mmuporttxenable_hi[1];
	uint32_t _mmuporttxenable_hi;
} BCM56218_A0_MMUPORTTXENABLE_HIr_t;

#define BCM56218_A0_MMUPORTTXENABLE_HIr_CLR(r) (r).mmuporttxenable_hi[0] = 0
#define BCM56218_A0_MMUPORTTXENABLE_HIr_SET(r,d) (r).mmuporttxenable_hi[0] = d
#define BCM56218_A0_MMUPORTTXENABLE_HIr_GET(r) (r).mmuporttxenable_hi[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMUPORTTXENABLE_HIr_MMUPORTTXENABLEf_GET(r) (((r).mmuporttxenable_hi[0]) & 0x3fffff)
#define BCM56218_A0_MMUPORTTXENABLE_HIr_MMUPORTTXENABLEf_SET(r,f) (r).mmuporttxenable_hi[0]=(((r).mmuporttxenable_hi[0] & ~((uint32_t)0x3fffff)) | (((uint32_t)f) & 0x3fffff))

/*
 * These macros can be used to access MMUPORTTXENABLE_HI.
 *
 */
#define BCM56218_A0_READ_MMUPORTTXENABLE_HIr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_MMUPORTTXENABLE_HIr,(r._mmuporttxenable_hi))
#define BCM56218_A0_WRITE_MMUPORTTXENABLE_HIr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_MMUPORTTXENABLE_HIr,&(r._mmuporttxenable_hi))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMUPORTTXENABLE_HIr BCM56218_A0_MMUPORTTXENABLE_HIr
#define MMUPORTTXENABLE_HIr_SIZE BCM56218_A0_MMUPORTTXENABLE_HIr_SIZE
typedef BCM56218_A0_MMUPORTTXENABLE_HIr_t MMUPORTTXENABLE_HIr_t;
#define MMUPORTTXENABLE_HIr_CLR BCM56218_A0_MMUPORTTXENABLE_HIr_CLR
#define MMUPORTTXENABLE_HIr_SET BCM56218_A0_MMUPORTTXENABLE_HIr_SET
#define MMUPORTTXENABLE_HIr_GET BCM56218_A0_MMUPORTTXENABLE_HIr_GET
#define MMUPORTTXENABLE_HIr_MMUPORTTXENABLEf_GET BCM56218_A0_MMUPORTTXENABLE_HIr_MMUPORTTXENABLEf_GET
#define MMUPORTTXENABLE_HIr_MMUPORTTXENABLEf_SET BCM56218_A0_MMUPORTTXENABLE_HIr_MMUPORTTXENABLEf_SET
#define READ_MMUPORTTXENABLE_HIr BCM56218_A0_READ_MMUPORTTXENABLE_HIr
#define WRITE_MMUPORTTXENABLE_HIr BCM56218_A0_WRITE_MMUPORTTXENABLE_HIr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMUPORTTXENABLE_HIr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_AGING_CTR
 * BLOCKS:   MMU
 * DESC:     Aging Counter RAM
 * SIZE:     24
 * FIELDS:
 *     AGING_CTR        AGING_CTR
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_AGING_CTRm 0x0a658000

#define BCM56218_A0_MMU_AGING_CTRm_MIN 0
#define BCM56218_A0_MMU_AGING_CTRm_MAX 511
#define BCM56218_A0_MMU_AGING_CTRm_CMAX(u) 511
#define BCM56218_A0_MMU_AGING_CTRm_SIZE 3

/*
 * This structure should be used to declare and program MMU_AGING_CTR.
 *
 */
typedef union BCM56218_A0_MMU_AGING_CTRm_s {
	uint32_t v[1];
	uint32_t mmu_aging_ctr[1];
	uint32_t _mmu_aging_ctr;
} BCM56218_A0_MMU_AGING_CTRm_t;

#define BCM56218_A0_MMU_AGING_CTRm_CLR(r) (r).mmu_aging_ctr[0] = 0
#define BCM56218_A0_MMU_AGING_CTRm_SET(r,d) (r).mmu_aging_ctr[0] = d
#define BCM56218_A0_MMU_AGING_CTRm_GET(r) (r).mmu_aging_ctr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_AGING_CTRm_AGING_CTRf_GET(r) (((r).mmu_aging_ctr[0]) & 0xffffff)
#define BCM56218_A0_MMU_AGING_CTRm_AGING_CTRf_SET(r,f) (r).mmu_aging_ctr[0]=(((r).mmu_aging_ctr[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))

/*
 * These macros can be used to access MMU_AGING_CTR.
 *
 */
#define BCM56218_A0_READ_MMU_AGING_CTRm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_AGING_CTRm,i,(m._mmu_aging_ctr),1)
#define BCM56218_A0_WRITE_MMU_AGING_CTRm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_AGING_CTRm,i,&(m._mmu_aging_ctr),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_AGING_CTRm BCM56218_A0_MMU_AGING_CTRm
#define MMU_AGING_CTRm_MIN BCM56218_A0_MMU_AGING_CTRm_MIN
#define MMU_AGING_CTRm_MAX BCM56218_A0_MMU_AGING_CTRm_MAX
#define MMU_AGING_CTRm_CMAX(u) BCM56218_A0_MMU_AGING_CTRm_CMAX(u)
#define MMU_AGING_CTRm_SIZE BCM56218_A0_MMU_AGING_CTRm_SIZE
typedef BCM56218_A0_MMU_AGING_CTRm_t MMU_AGING_CTRm_t;
#define MMU_AGING_CTRm_CLR BCM56218_A0_MMU_AGING_CTRm_CLR
#define MMU_AGING_CTRm_SET BCM56218_A0_MMU_AGING_CTRm_SET
#define MMU_AGING_CTRm_GET BCM56218_A0_MMU_AGING_CTRm_GET
#define MMU_AGING_CTRm_AGING_CTRf_GET BCM56218_A0_MMU_AGING_CTRm_AGING_CTRf_GET
#define MMU_AGING_CTRm_AGING_CTRf_SET BCM56218_A0_MMU_AGING_CTRm_AGING_CTRf_SET
#define READ_MMU_AGING_CTRm BCM56218_A0_READ_MMU_AGING_CTRm
#define WRITE_MMU_AGING_CTRm BCM56218_A0_WRITE_MMU_AGING_CTRm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_AGING_CTRm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_AGING_EXP
 * BLOCKS:   MMU
 * DESC:     Aging Expiration Status RAM
 * SIZE:     8
 * FIELDS:
 *     AGING_EXP        AGING_EXP
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_AGING_EXPm 0x0a65c000

#define BCM56218_A0_MMU_AGING_EXPm_MIN 0
#define BCM56218_A0_MMU_AGING_EXPm_MAX 511
#define BCM56218_A0_MMU_AGING_EXPm_CMAX(u) 511
#define BCM56218_A0_MMU_AGING_EXPm_SIZE 1

/*
 * This structure should be used to declare and program MMU_AGING_EXP.
 *
 */
typedef union BCM56218_A0_MMU_AGING_EXPm_s {
	uint32_t v[1];
	uint32_t mmu_aging_exp[1];
	uint32_t _mmu_aging_exp;
} BCM56218_A0_MMU_AGING_EXPm_t;

#define BCM56218_A0_MMU_AGING_EXPm_CLR(r) (r).mmu_aging_exp[0] = 0
#define BCM56218_A0_MMU_AGING_EXPm_SET(r,d) (r).mmu_aging_exp[0] = d
#define BCM56218_A0_MMU_AGING_EXPm_GET(r) (r).mmu_aging_exp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_AGING_EXPm_AGING_EXPf_GET(r) (((r).mmu_aging_exp[0]) & 0xff)
#define BCM56218_A0_MMU_AGING_EXPm_AGING_EXPf_SET(r,f) (r).mmu_aging_exp[0]=(((r).mmu_aging_exp[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access MMU_AGING_EXP.
 *
 */
#define BCM56218_A0_READ_MMU_AGING_EXPm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_AGING_EXPm,i,(m._mmu_aging_exp),1)
#define BCM56218_A0_WRITE_MMU_AGING_EXPm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_AGING_EXPm,i,&(m._mmu_aging_exp),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_AGING_EXPm BCM56218_A0_MMU_AGING_EXPm
#define MMU_AGING_EXPm_MIN BCM56218_A0_MMU_AGING_EXPm_MIN
#define MMU_AGING_EXPm_MAX BCM56218_A0_MMU_AGING_EXPm_MAX
#define MMU_AGING_EXPm_CMAX(u) BCM56218_A0_MMU_AGING_EXPm_CMAX(u)
#define MMU_AGING_EXPm_SIZE BCM56218_A0_MMU_AGING_EXPm_SIZE
typedef BCM56218_A0_MMU_AGING_EXPm_t MMU_AGING_EXPm_t;
#define MMU_AGING_EXPm_CLR BCM56218_A0_MMU_AGING_EXPm_CLR
#define MMU_AGING_EXPm_SET BCM56218_A0_MMU_AGING_EXPm_SET
#define MMU_AGING_EXPm_GET BCM56218_A0_MMU_AGING_EXPm_GET
#define MMU_AGING_EXPm_AGING_EXPf_GET BCM56218_A0_MMU_AGING_EXPm_AGING_EXPf_GET
#define MMU_AGING_EXPm_AGING_EXPf_SET BCM56218_A0_MMU_AGING_EXPm_AGING_EXPf_SET
#define READ_MMU_AGING_EXPm BCM56218_A0_READ_MMU_AGING_EXPm
#define WRITE_MMU_AGING_EXPm BCM56218_A0_WRITE_MMU_AGING_EXPm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_AGING_EXPm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_CBPCellHeader
 * BLOCKS:   MMU
 * DESC:     CBP Header RAM
 * SIZE:     36
 * FIELDS:
 *     PURGE_CELL       How Many copies of this cell are there
 *     END_CELL         End cell flag of a packet
 *     NEXT_CELL_PTR    Next Cell Pointer is valid when END_CELL is 0
 *     CELL_LENGTH      Last Cell Length is valid when END_CELL is 1
 *     CELL_CRC_SUM     Cell CRC Checksum value
 *     CNG              CNG bit
 *     PBI_RESERVED_BIT_2 RESERVED_BIT_2
 *     PARITY           Cell header Parity
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_CBPCELLHEADERm 0x0a648000

#define BCM56218_A0_MMU_CBPCELLHEADERm_MIN 0
#define BCM56218_A0_MMU_CBPCELLHEADERm_MAX 4095
#define BCM56218_A0_MMU_CBPCELLHEADERm_CMAX(u) 4095
#define BCM56218_A0_MMU_CBPCELLHEADERm_SIZE 5

/*
 * This structure should be used to declare and program MMU_CBPCellHeader.
 *
 */
typedef union BCM56218_A0_MMU_CBPCELLHEADERm_s {
	uint32_t v[2];
	uint32_t mmu_cbpcellheader[2];
	uint32_t _mmu_cbpcellheader;
} BCM56218_A0_MMU_CBPCELLHEADERm_t;

#define BCM56218_A0_MMU_CBPCELLHEADERm_CLR(r) CDK_MEMSET(&((r)._mmu_cbpcellheader), 0, sizeof(BCM56218_A0_MMU_CBPCELLHEADERm_t))
#define BCM56218_A0_MMU_CBPCELLHEADERm_SET(r,i,d) (r).mmu_cbpcellheader[i] = d
#define BCM56218_A0_MMU_CBPCELLHEADERm_GET(r,i) (r).mmu_cbpcellheader[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_CBPCELLHEADERm_PURGE_CELLf_GET(r) (((r).mmu_cbpcellheader[0]) & 0x1)
#define BCM56218_A0_MMU_CBPCELLHEADERm_PURGE_CELLf_SET(r,f) (r).mmu_cbpcellheader[0]=(((r).mmu_cbpcellheader[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_MMU_CBPCELLHEADERm_END_CELLf_GET(r) ((((r).mmu_cbpcellheader[0]) >> 1) & 0x1)
#define BCM56218_A0_MMU_CBPCELLHEADERm_END_CELLf_SET(r,f) (r).mmu_cbpcellheader[0]=(((r).mmu_cbpcellheader[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_MMU_CBPCELLHEADERm_NEXT_CELL_PTRf_GET(r) ((((r).mmu_cbpcellheader[0]) >> 2) & 0x3fff)
#define BCM56218_A0_MMU_CBPCELLHEADERm_NEXT_CELL_PTRf_SET(r,f) (r).mmu_cbpcellheader[0]=(((r).mmu_cbpcellheader[0] & ~((uint32_t)0x3fff << 2)) | ((((uint32_t)f) & 0x3fff) << 2))
#define BCM56218_A0_MMU_CBPCELLHEADERm_CELL_LENGTHf_GET(r) ((((r).mmu_cbpcellheader[0]) >> 2) & 0xff)
#define BCM56218_A0_MMU_CBPCELLHEADERm_CELL_LENGTHf_SET(r,f) (r).mmu_cbpcellheader[0]=(((r).mmu_cbpcellheader[0] & ~((uint32_t)0xff << 2)) | ((((uint32_t)f) & 0xff) << 2))
#define BCM56218_A0_MMU_CBPCELLHEADERm_CELL_CRC_SUMf_GET(r) ((((r).mmu_cbpcellheader[0]) >> 16) & 0xffff)
#define BCM56218_A0_MMU_CBPCELLHEADERm_CELL_CRC_SUMf_SET(r,f) (r).mmu_cbpcellheader[0]=(((r).mmu_cbpcellheader[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))
#define BCM56218_A0_MMU_CBPCELLHEADERm_CNGf_GET(r) (((r).mmu_cbpcellheader[1]) & 0x3)
#define BCM56218_A0_MMU_CBPCELLHEADERm_CNGf_SET(r,f) (r).mmu_cbpcellheader[1]=(((r).mmu_cbpcellheader[1] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56218_A0_MMU_CBPCELLHEADERm_PBI_RESERVED_BIT_2f_GET(r) ((((r).mmu_cbpcellheader[1]) >> 2) & 0x1)
#define BCM56218_A0_MMU_CBPCELLHEADERm_PBI_RESERVED_BIT_2f_SET(r,f) (r).mmu_cbpcellheader[1]=(((r).mmu_cbpcellheader[1] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_MMU_CBPCELLHEADERm_PARITYf_GET(r) ((((r).mmu_cbpcellheader[1]) >> 3) & 0x1)
#define BCM56218_A0_MMU_CBPCELLHEADERm_PARITYf_SET(r,f) (r).mmu_cbpcellheader[1]=(((r).mmu_cbpcellheader[1] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))

/*
 * These macros can be used to access MMU_CBPCellHeader.
 *
 */
#define BCM56218_A0_READ_MMU_CBPCELLHEADERm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_CBPCELLHEADERm,i,(m._mmu_cbpcellheader),2)
#define BCM56218_A0_WRITE_MMU_CBPCELLHEADERm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_CBPCELLHEADERm,i,&(m._mmu_cbpcellheader),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CBPCELLHEADERm BCM56218_A0_MMU_CBPCELLHEADERm
#define MMU_CBPCELLHEADERm_MIN BCM56218_A0_MMU_CBPCELLHEADERm_MIN
#define MMU_CBPCELLHEADERm_MAX BCM56218_A0_MMU_CBPCELLHEADERm_MAX
#define MMU_CBPCELLHEADERm_CMAX(u) BCM56218_A0_MMU_CBPCELLHEADERm_CMAX(u)
#define MMU_CBPCELLHEADERm_SIZE BCM56218_A0_MMU_CBPCELLHEADERm_SIZE
typedef BCM56218_A0_MMU_CBPCELLHEADERm_t MMU_CBPCELLHEADERm_t;
#define MMU_CBPCELLHEADERm_CLR BCM56218_A0_MMU_CBPCELLHEADERm_CLR
#define MMU_CBPCELLHEADERm_SET BCM56218_A0_MMU_CBPCELLHEADERm_SET
#define MMU_CBPCELLHEADERm_GET BCM56218_A0_MMU_CBPCELLHEADERm_GET
#define MMU_CBPCELLHEADERm_PURGE_CELLf_GET BCM56218_A0_MMU_CBPCELLHEADERm_PURGE_CELLf_GET
#define MMU_CBPCELLHEADERm_PURGE_CELLf_SET BCM56218_A0_MMU_CBPCELLHEADERm_PURGE_CELLf_SET
#define MMU_CBPCELLHEADERm_END_CELLf_GET BCM56218_A0_MMU_CBPCELLHEADERm_END_CELLf_GET
#define MMU_CBPCELLHEADERm_END_CELLf_SET BCM56218_A0_MMU_CBPCELLHEADERm_END_CELLf_SET
#define MMU_CBPCELLHEADERm_NEXT_CELL_PTRf_GET BCM56218_A0_MMU_CBPCELLHEADERm_NEXT_CELL_PTRf_GET
#define MMU_CBPCELLHEADERm_NEXT_CELL_PTRf_SET BCM56218_A0_MMU_CBPCELLHEADERm_NEXT_CELL_PTRf_SET
#define MMU_CBPCELLHEADERm_CELL_LENGTHf_GET BCM56218_A0_MMU_CBPCELLHEADERm_CELL_LENGTHf_GET
#define MMU_CBPCELLHEADERm_CELL_LENGTHf_SET BCM56218_A0_MMU_CBPCELLHEADERm_CELL_LENGTHf_SET
#define MMU_CBPCELLHEADERm_CELL_CRC_SUMf_GET BCM56218_A0_MMU_CBPCELLHEADERm_CELL_CRC_SUMf_GET
#define MMU_CBPCELLHEADERm_CELL_CRC_SUMf_SET BCM56218_A0_MMU_CBPCELLHEADERm_CELL_CRC_SUMf_SET
#define MMU_CBPCELLHEADERm_CNGf_GET BCM56218_A0_MMU_CBPCELLHEADERm_CNGf_GET
#define MMU_CBPCELLHEADERm_CNGf_SET BCM56218_A0_MMU_CBPCELLHEADERm_CNGf_SET
#define MMU_CBPCELLHEADERm_PBI_RESERVED_BIT_2f_GET BCM56218_A0_MMU_CBPCELLHEADERm_PBI_RESERVED_BIT_2f_GET
#define MMU_CBPCELLHEADERm_PBI_RESERVED_BIT_2f_SET BCM56218_A0_MMU_CBPCELLHEADERm_PBI_RESERVED_BIT_2f_SET
#define MMU_CBPCELLHEADERm_PARITYf_GET BCM56218_A0_MMU_CBPCELLHEADERm_PARITYf_GET
#define MMU_CBPCELLHEADERm_PARITYf_SET BCM56218_A0_MMU_CBPCELLHEADERm_PARITYf_SET
#define READ_MMU_CBPCELLHEADERm BCM56218_A0_READ_MMU_CBPCELLHEADERm
#define WRITE_MMU_CBPCELLHEADERm BCM56218_A0_WRITE_MMU_CBPCELLHEADERm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_CBPCELLHEADERm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_CBPData0
 * BLOCKS:   MMU
 * DESC:     CBP Data RAM 0
 * SIZE:     128
 * FIELDS:
 *     CBPDATA          CBPData [127:0]
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_CBPDATA0m 0x0a600000

#define BCM56218_A0_MMU_CBPDATA0m_MIN 0
#define BCM56218_A0_MMU_CBPDATA0m_MAX 4095
#define BCM56218_A0_MMU_CBPDATA0m_CMAX(u) 4095
#define BCM56218_A0_MMU_CBPDATA0m_SIZE 16

/*
 * This structure should be used to declare and program MMU_CBPData0.
 *
 */
typedef union BCM56218_A0_MMU_CBPDATA0m_s {
	uint32_t v[4];
	uint32_t mmu_cbpdata0[4];
	uint32_t _mmu_cbpdata0;
} BCM56218_A0_MMU_CBPDATA0m_t;

#define BCM56218_A0_MMU_CBPDATA0m_CLR(r) CDK_MEMSET(&((r)._mmu_cbpdata0), 0, sizeof(BCM56218_A0_MMU_CBPDATA0m_t))
#define BCM56218_A0_MMU_CBPDATA0m_SET(r,i,d) (r).mmu_cbpdata0[i] = d
#define BCM56218_A0_MMU_CBPDATA0m_GET(r,i) (r).mmu_cbpdata0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_CBPDATA0m_CBPDATAf_GET(r,a) cdk_field_get((r).mmu_cbpdata0,0,127,a)
#define BCM56218_A0_MMU_CBPDATA0m_CBPDATAf_SET(r,a) cdk_field_set((r).mmu_cbpdata0,0,127,a)

/*
 * These macros can be used to access MMU_CBPData0.
 *
 */
#define BCM56218_A0_READ_MMU_CBPDATA0m(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_CBPDATA0m,i,(m._mmu_cbpdata0),4)
#define BCM56218_A0_WRITE_MMU_CBPDATA0m(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_CBPDATA0m,i,&(m._mmu_cbpdata0),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CBPDATA0m BCM56218_A0_MMU_CBPDATA0m
#define MMU_CBPDATA0m_MIN BCM56218_A0_MMU_CBPDATA0m_MIN
#define MMU_CBPDATA0m_MAX BCM56218_A0_MMU_CBPDATA0m_MAX
#define MMU_CBPDATA0m_CMAX(u) BCM56218_A0_MMU_CBPDATA0m_CMAX(u)
#define MMU_CBPDATA0m_SIZE BCM56218_A0_MMU_CBPDATA0m_SIZE
typedef BCM56218_A0_MMU_CBPDATA0m_t MMU_CBPDATA0m_t;
#define MMU_CBPDATA0m_CLR BCM56218_A0_MMU_CBPDATA0m_CLR
#define MMU_CBPDATA0m_SET BCM56218_A0_MMU_CBPDATA0m_SET
#define MMU_CBPDATA0m_GET BCM56218_A0_MMU_CBPDATA0m_GET
#define MMU_CBPDATA0m_CBPDATAf_GET BCM56218_A0_MMU_CBPDATA0m_CBPDATAf_GET
#define MMU_CBPDATA0m_CBPDATAf_SET BCM56218_A0_MMU_CBPDATA0m_CBPDATAf_SET
#define READ_MMU_CBPDATA0m BCM56218_A0_READ_MMU_CBPDATA0m
#define WRITE_MMU_CBPDATA0m BCM56218_A0_WRITE_MMU_CBPDATA0m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_CBPDATA0m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_CBPData1
 * BLOCKS:   MMU
 * DESC:     CBP Data RAM 1
 * SIZE:     128
 * FIELDS:
 *     CBPDATA          CBPData [255:128]
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_CBPDATA1m 0x0a604000

#define BCM56218_A0_MMU_CBPDATA1m_MIN 0
#define BCM56218_A0_MMU_CBPDATA1m_MAX 4095
#define BCM56218_A0_MMU_CBPDATA1m_CMAX(u) 4095
#define BCM56218_A0_MMU_CBPDATA1m_SIZE 16

/*
 * This structure should be used to declare and program MMU_CBPData1.
 *
 */
typedef union BCM56218_A0_MMU_CBPDATA1m_s {
	uint32_t v[4];
	uint32_t mmu_cbpdata1[4];
	uint32_t _mmu_cbpdata1;
} BCM56218_A0_MMU_CBPDATA1m_t;

#define BCM56218_A0_MMU_CBPDATA1m_CLR(r) CDK_MEMSET(&((r)._mmu_cbpdata1), 0, sizeof(BCM56218_A0_MMU_CBPDATA1m_t))
#define BCM56218_A0_MMU_CBPDATA1m_SET(r,i,d) (r).mmu_cbpdata1[i] = d
#define BCM56218_A0_MMU_CBPDATA1m_GET(r,i) (r).mmu_cbpdata1[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_CBPDATA1m_CBPDATAf_GET(r,a) cdk_field_get((r).mmu_cbpdata1,0,127,a)
#define BCM56218_A0_MMU_CBPDATA1m_CBPDATAf_SET(r,a) cdk_field_set((r).mmu_cbpdata1,0,127,a)

/*
 * These macros can be used to access MMU_CBPData1.
 *
 */
#define BCM56218_A0_READ_MMU_CBPDATA1m(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_CBPDATA1m,i,(m._mmu_cbpdata1),4)
#define BCM56218_A0_WRITE_MMU_CBPDATA1m(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_CBPDATA1m,i,&(m._mmu_cbpdata1),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CBPDATA1m BCM56218_A0_MMU_CBPDATA1m
#define MMU_CBPDATA1m_MIN BCM56218_A0_MMU_CBPDATA1m_MIN
#define MMU_CBPDATA1m_MAX BCM56218_A0_MMU_CBPDATA1m_MAX
#define MMU_CBPDATA1m_CMAX(u) BCM56218_A0_MMU_CBPDATA1m_CMAX(u)
#define MMU_CBPDATA1m_SIZE BCM56218_A0_MMU_CBPDATA1m_SIZE
typedef BCM56218_A0_MMU_CBPDATA1m_t MMU_CBPDATA1m_t;
#define MMU_CBPDATA1m_CLR BCM56218_A0_MMU_CBPDATA1m_CLR
#define MMU_CBPDATA1m_SET BCM56218_A0_MMU_CBPDATA1m_SET
#define MMU_CBPDATA1m_GET BCM56218_A0_MMU_CBPDATA1m_GET
#define MMU_CBPDATA1m_CBPDATAf_GET BCM56218_A0_MMU_CBPDATA1m_CBPDATAf_GET
#define MMU_CBPDATA1m_CBPDATAf_SET BCM56218_A0_MMU_CBPDATA1m_CBPDATAf_SET
#define READ_MMU_CBPDATA1m BCM56218_A0_READ_MMU_CBPDATA1m
#define WRITE_MMU_CBPDATA1m BCM56218_A0_WRITE_MMU_CBPDATA1m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_CBPDATA1m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_CBPData2
 * BLOCKS:   MMU
 * DESC:     CBP Data RAM 2
 * SIZE:     128
 * FIELDS:
 *     CBPDATA          CBPData [383:256]
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_CBPDATA2m 0x0a608000

#define BCM56218_A0_MMU_CBPDATA2m_MIN 0
#define BCM56218_A0_MMU_CBPDATA2m_MAX 4095
#define BCM56218_A0_MMU_CBPDATA2m_CMAX(u) 4095
#define BCM56218_A0_MMU_CBPDATA2m_SIZE 16

/*
 * This structure should be used to declare and program MMU_CBPData2.
 *
 */
typedef union BCM56218_A0_MMU_CBPDATA2m_s {
	uint32_t v[4];
	uint32_t mmu_cbpdata2[4];
	uint32_t _mmu_cbpdata2;
} BCM56218_A0_MMU_CBPDATA2m_t;

#define BCM56218_A0_MMU_CBPDATA2m_CLR(r) CDK_MEMSET(&((r)._mmu_cbpdata2), 0, sizeof(BCM56218_A0_MMU_CBPDATA2m_t))
#define BCM56218_A0_MMU_CBPDATA2m_SET(r,i,d) (r).mmu_cbpdata2[i] = d
#define BCM56218_A0_MMU_CBPDATA2m_GET(r,i) (r).mmu_cbpdata2[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_CBPDATA2m_CBPDATAf_GET(r,a) cdk_field_get((r).mmu_cbpdata2,0,127,a)
#define BCM56218_A0_MMU_CBPDATA2m_CBPDATAf_SET(r,a) cdk_field_set((r).mmu_cbpdata2,0,127,a)

/*
 * These macros can be used to access MMU_CBPData2.
 *
 */
#define BCM56218_A0_READ_MMU_CBPDATA2m(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_CBPDATA2m,i,(m._mmu_cbpdata2),4)
#define BCM56218_A0_WRITE_MMU_CBPDATA2m(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_CBPDATA2m,i,&(m._mmu_cbpdata2),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CBPDATA2m BCM56218_A0_MMU_CBPDATA2m
#define MMU_CBPDATA2m_MIN BCM56218_A0_MMU_CBPDATA2m_MIN
#define MMU_CBPDATA2m_MAX BCM56218_A0_MMU_CBPDATA2m_MAX
#define MMU_CBPDATA2m_CMAX(u) BCM56218_A0_MMU_CBPDATA2m_CMAX(u)
#define MMU_CBPDATA2m_SIZE BCM56218_A0_MMU_CBPDATA2m_SIZE
typedef BCM56218_A0_MMU_CBPDATA2m_t MMU_CBPDATA2m_t;
#define MMU_CBPDATA2m_CLR BCM56218_A0_MMU_CBPDATA2m_CLR
#define MMU_CBPDATA2m_SET BCM56218_A0_MMU_CBPDATA2m_SET
#define MMU_CBPDATA2m_GET BCM56218_A0_MMU_CBPDATA2m_GET
#define MMU_CBPDATA2m_CBPDATAf_GET BCM56218_A0_MMU_CBPDATA2m_CBPDATAf_GET
#define MMU_CBPDATA2m_CBPDATAf_SET BCM56218_A0_MMU_CBPDATA2m_CBPDATAf_SET
#define READ_MMU_CBPDATA2m BCM56218_A0_READ_MMU_CBPDATA2m
#define WRITE_MMU_CBPDATA2m BCM56218_A0_WRITE_MMU_CBPDATA2m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_CBPDATA2m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_CBPData3
 * BLOCKS:   MMU
 * DESC:     CBP Data RAM 3
 * SIZE:     128
 * FIELDS:
 *     CBPDATA          CBPData [511:384]
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_CBPDATA3m 0x0a60c000

#define BCM56218_A0_MMU_CBPDATA3m_MIN 0
#define BCM56218_A0_MMU_CBPDATA3m_MAX 4095
#define BCM56218_A0_MMU_CBPDATA3m_CMAX(u) 4095
#define BCM56218_A0_MMU_CBPDATA3m_SIZE 16

/*
 * This structure should be used to declare and program MMU_CBPData3.
 *
 */
typedef union BCM56218_A0_MMU_CBPDATA3m_s {
	uint32_t v[4];
	uint32_t mmu_cbpdata3[4];
	uint32_t _mmu_cbpdata3;
} BCM56218_A0_MMU_CBPDATA3m_t;

#define BCM56218_A0_MMU_CBPDATA3m_CLR(r) CDK_MEMSET(&((r)._mmu_cbpdata3), 0, sizeof(BCM56218_A0_MMU_CBPDATA3m_t))
#define BCM56218_A0_MMU_CBPDATA3m_SET(r,i,d) (r).mmu_cbpdata3[i] = d
#define BCM56218_A0_MMU_CBPDATA3m_GET(r,i) (r).mmu_cbpdata3[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_CBPDATA3m_CBPDATAf_GET(r,a) cdk_field_get((r).mmu_cbpdata3,0,127,a)
#define BCM56218_A0_MMU_CBPDATA3m_CBPDATAf_SET(r,a) cdk_field_set((r).mmu_cbpdata3,0,127,a)

/*
 * These macros can be used to access MMU_CBPData3.
 *
 */
#define BCM56218_A0_READ_MMU_CBPDATA3m(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_CBPDATA3m,i,(m._mmu_cbpdata3),4)
#define BCM56218_A0_WRITE_MMU_CBPDATA3m(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_CBPDATA3m,i,&(m._mmu_cbpdata3),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CBPDATA3m BCM56218_A0_MMU_CBPDATA3m
#define MMU_CBPDATA3m_MIN BCM56218_A0_MMU_CBPDATA3m_MIN
#define MMU_CBPDATA3m_MAX BCM56218_A0_MMU_CBPDATA3m_MAX
#define MMU_CBPDATA3m_CMAX(u) BCM56218_A0_MMU_CBPDATA3m_CMAX(u)
#define MMU_CBPDATA3m_SIZE BCM56218_A0_MMU_CBPDATA3m_SIZE
typedef BCM56218_A0_MMU_CBPDATA3m_t MMU_CBPDATA3m_t;
#define MMU_CBPDATA3m_CLR BCM56218_A0_MMU_CBPDATA3m_CLR
#define MMU_CBPDATA3m_SET BCM56218_A0_MMU_CBPDATA3m_SET
#define MMU_CBPDATA3m_GET BCM56218_A0_MMU_CBPDATA3m_GET
#define MMU_CBPDATA3m_CBPDATAf_GET BCM56218_A0_MMU_CBPDATA3m_CBPDATAf_GET
#define MMU_CBPDATA3m_CBPDATAf_SET BCM56218_A0_MMU_CBPDATA3m_CBPDATAf_SET
#define READ_MMU_CBPDATA3m BCM56218_A0_READ_MMU_CBPDATA3m
#define WRITE_MMU_CBPDATA3m BCM56218_A0_WRITE_MMU_CBPDATA3m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_CBPDATA3m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_CBPData4
 * BLOCKS:   MMU
 * DESC:     CBP Data RAM 4
 * SIZE:     128
 * FIELDS:
 *     CBPDATA          CBPData [539:512]
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_CBPDATA4m 0x0a610000

#define BCM56218_A0_MMU_CBPDATA4m_MIN 0
#define BCM56218_A0_MMU_CBPDATA4m_MAX 4095
#define BCM56218_A0_MMU_CBPDATA4m_CMAX(u) 4095
#define BCM56218_A0_MMU_CBPDATA4m_SIZE 16

/*
 * This structure should be used to declare and program MMU_CBPData4.
 *
 */
typedef union BCM56218_A0_MMU_CBPDATA4m_s {
	uint32_t v[4];
	uint32_t mmu_cbpdata4[4];
	uint32_t _mmu_cbpdata4;
} BCM56218_A0_MMU_CBPDATA4m_t;

#define BCM56218_A0_MMU_CBPDATA4m_CLR(r) CDK_MEMSET(&((r)._mmu_cbpdata4), 0, sizeof(BCM56218_A0_MMU_CBPDATA4m_t))
#define BCM56218_A0_MMU_CBPDATA4m_SET(r,i,d) (r).mmu_cbpdata4[i] = d
#define BCM56218_A0_MMU_CBPDATA4m_GET(r,i) (r).mmu_cbpdata4[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_CBPDATA4m_CBPDATAf_GET(r,a) cdk_field_get((r).mmu_cbpdata4,0,127,a)
#define BCM56218_A0_MMU_CBPDATA4m_CBPDATAf_SET(r,a) cdk_field_set((r).mmu_cbpdata4,0,127,a)

/*
 * These macros can be used to access MMU_CBPData4.
 *
 */
#define BCM56218_A0_READ_MMU_CBPDATA4m(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_CBPDATA4m,i,(m._mmu_cbpdata4),4)
#define BCM56218_A0_WRITE_MMU_CBPDATA4m(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_CBPDATA4m,i,&(m._mmu_cbpdata4),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CBPDATA4m BCM56218_A0_MMU_CBPDATA4m
#define MMU_CBPDATA4m_MIN BCM56218_A0_MMU_CBPDATA4m_MIN
#define MMU_CBPDATA4m_MAX BCM56218_A0_MMU_CBPDATA4m_MAX
#define MMU_CBPDATA4m_CMAX(u) BCM56218_A0_MMU_CBPDATA4m_CMAX(u)
#define MMU_CBPDATA4m_SIZE BCM56218_A0_MMU_CBPDATA4m_SIZE
typedef BCM56218_A0_MMU_CBPDATA4m_t MMU_CBPDATA4m_t;
#define MMU_CBPDATA4m_CLR BCM56218_A0_MMU_CBPDATA4m_CLR
#define MMU_CBPDATA4m_SET BCM56218_A0_MMU_CBPDATA4m_SET
#define MMU_CBPDATA4m_GET BCM56218_A0_MMU_CBPDATA4m_GET
#define MMU_CBPDATA4m_CBPDATAf_GET BCM56218_A0_MMU_CBPDATA4m_CBPDATAf_GET
#define MMU_CBPDATA4m_CBPDATAf_SET BCM56218_A0_MMU_CBPDATA4m_CBPDATAf_SET
#define READ_MMU_CBPDATA4m BCM56218_A0_READ_MMU_CBPDATA4m
#define WRITE_MMU_CBPDATA4m BCM56218_A0_WRITE_MMU_CBPDATA4m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_CBPDATA4m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_CBPData5
 * BLOCKS:   MMU
 * DESC:     CBP Data RAM 5
 * SIZE:     128
 * FIELDS:
 *     CBPDATA          CBPData [767:540]
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_CBPDATA5m 0x0a614000

#define BCM56218_A0_MMU_CBPDATA5m_MIN 0
#define BCM56218_A0_MMU_CBPDATA5m_MAX 4095
#define BCM56218_A0_MMU_CBPDATA5m_CMAX(u) 4095
#define BCM56218_A0_MMU_CBPDATA5m_SIZE 16

/*
 * This structure should be used to declare and program MMU_CBPData5.
 *
 */
typedef union BCM56218_A0_MMU_CBPDATA5m_s {
	uint32_t v[4];
	uint32_t mmu_cbpdata5[4];
	uint32_t _mmu_cbpdata5;
} BCM56218_A0_MMU_CBPDATA5m_t;

#define BCM56218_A0_MMU_CBPDATA5m_CLR(r) CDK_MEMSET(&((r)._mmu_cbpdata5), 0, sizeof(BCM56218_A0_MMU_CBPDATA5m_t))
#define BCM56218_A0_MMU_CBPDATA5m_SET(r,i,d) (r).mmu_cbpdata5[i] = d
#define BCM56218_A0_MMU_CBPDATA5m_GET(r,i) (r).mmu_cbpdata5[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_CBPDATA5m_CBPDATAf_GET(r,a) cdk_field_get((r).mmu_cbpdata5,0,127,a)
#define BCM56218_A0_MMU_CBPDATA5m_CBPDATAf_SET(r,a) cdk_field_set((r).mmu_cbpdata5,0,127,a)

/*
 * These macros can be used to access MMU_CBPData5.
 *
 */
#define BCM56218_A0_READ_MMU_CBPDATA5m(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_CBPDATA5m,i,(m._mmu_cbpdata5),4)
#define BCM56218_A0_WRITE_MMU_CBPDATA5m(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_CBPDATA5m,i,&(m._mmu_cbpdata5),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CBPDATA5m BCM56218_A0_MMU_CBPDATA5m
#define MMU_CBPDATA5m_MIN BCM56218_A0_MMU_CBPDATA5m_MIN
#define MMU_CBPDATA5m_MAX BCM56218_A0_MMU_CBPDATA5m_MAX
#define MMU_CBPDATA5m_CMAX(u) BCM56218_A0_MMU_CBPDATA5m_CMAX(u)
#define MMU_CBPDATA5m_SIZE BCM56218_A0_MMU_CBPDATA5m_SIZE
typedef BCM56218_A0_MMU_CBPDATA5m_t MMU_CBPDATA5m_t;
#define MMU_CBPDATA5m_CLR BCM56218_A0_MMU_CBPDATA5m_CLR
#define MMU_CBPDATA5m_SET BCM56218_A0_MMU_CBPDATA5m_SET
#define MMU_CBPDATA5m_GET BCM56218_A0_MMU_CBPDATA5m_GET
#define MMU_CBPDATA5m_CBPDATAf_GET BCM56218_A0_MMU_CBPDATA5m_CBPDATAf_GET
#define MMU_CBPDATA5m_CBPDATAf_SET BCM56218_A0_MMU_CBPDATA5m_CBPDATAf_SET
#define READ_MMU_CBPDATA5m BCM56218_A0_READ_MMU_CBPDATA5m
#define WRITE_MMU_CBPDATA5m BCM56218_A0_WRITE_MMU_CBPDATA5m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_CBPDATA5m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_CBPData6
 * BLOCKS:   MMU
 * DESC:     CBP Data RAM 6
 * SIZE:     128
 * FIELDS:
 *     CBPDATA          CBPData [895:768]
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_CBPDATA6m 0x0a618000

#define BCM56218_A0_MMU_CBPDATA6m_MIN 0
#define BCM56218_A0_MMU_CBPDATA6m_MAX 4095
#define BCM56218_A0_MMU_CBPDATA6m_CMAX(u) 4095
#define BCM56218_A0_MMU_CBPDATA6m_SIZE 16

/*
 * This structure should be used to declare and program MMU_CBPData6.
 *
 */
typedef union BCM56218_A0_MMU_CBPDATA6m_s {
	uint32_t v[4];
	uint32_t mmu_cbpdata6[4];
	uint32_t _mmu_cbpdata6;
} BCM56218_A0_MMU_CBPDATA6m_t;

#define BCM56218_A0_MMU_CBPDATA6m_CLR(r) CDK_MEMSET(&((r)._mmu_cbpdata6), 0, sizeof(BCM56218_A0_MMU_CBPDATA6m_t))
#define BCM56218_A0_MMU_CBPDATA6m_SET(r,i,d) (r).mmu_cbpdata6[i] = d
#define BCM56218_A0_MMU_CBPDATA6m_GET(r,i) (r).mmu_cbpdata6[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_CBPDATA6m_CBPDATAf_GET(r,a) cdk_field_get((r).mmu_cbpdata6,0,127,a)
#define BCM56218_A0_MMU_CBPDATA6m_CBPDATAf_SET(r,a) cdk_field_set((r).mmu_cbpdata6,0,127,a)

/*
 * These macros can be used to access MMU_CBPData6.
 *
 */
#define BCM56218_A0_READ_MMU_CBPDATA6m(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_CBPDATA6m,i,(m._mmu_cbpdata6),4)
#define BCM56218_A0_WRITE_MMU_CBPDATA6m(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_CBPDATA6m,i,&(m._mmu_cbpdata6),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CBPDATA6m BCM56218_A0_MMU_CBPDATA6m
#define MMU_CBPDATA6m_MIN BCM56218_A0_MMU_CBPDATA6m_MIN
#define MMU_CBPDATA6m_MAX BCM56218_A0_MMU_CBPDATA6m_MAX
#define MMU_CBPDATA6m_CMAX(u) BCM56218_A0_MMU_CBPDATA6m_CMAX(u)
#define MMU_CBPDATA6m_SIZE BCM56218_A0_MMU_CBPDATA6m_SIZE
typedef BCM56218_A0_MMU_CBPDATA6m_t MMU_CBPDATA6m_t;
#define MMU_CBPDATA6m_CLR BCM56218_A0_MMU_CBPDATA6m_CLR
#define MMU_CBPDATA6m_SET BCM56218_A0_MMU_CBPDATA6m_SET
#define MMU_CBPDATA6m_GET BCM56218_A0_MMU_CBPDATA6m_GET
#define MMU_CBPDATA6m_CBPDATAf_GET BCM56218_A0_MMU_CBPDATA6m_CBPDATAf_GET
#define MMU_CBPDATA6m_CBPDATAf_SET BCM56218_A0_MMU_CBPDATA6m_CBPDATAf_SET
#define READ_MMU_CBPDATA6m BCM56218_A0_READ_MMU_CBPDATA6m
#define WRITE_MMU_CBPDATA6m BCM56218_A0_WRITE_MMU_CBPDATA6m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_CBPDATA6m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_CBPData7
 * BLOCKS:   MMU
 * DESC:     CBP Data RAM 7
 * SIZE:     128
 * FIELDS:
 *     CBPDATA          CBPData [1025:896]
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_CBPDATA7m 0x0a61c000

#define BCM56218_A0_MMU_CBPDATA7m_MIN 0
#define BCM56218_A0_MMU_CBPDATA7m_MAX 4095
#define BCM56218_A0_MMU_CBPDATA7m_CMAX(u) 4095
#define BCM56218_A0_MMU_CBPDATA7m_SIZE 16

/*
 * This structure should be used to declare and program MMU_CBPData7.
 *
 */
typedef union BCM56218_A0_MMU_CBPDATA7m_s {
	uint32_t v[4];
	uint32_t mmu_cbpdata7[4];
	uint32_t _mmu_cbpdata7;
} BCM56218_A0_MMU_CBPDATA7m_t;

#define BCM56218_A0_MMU_CBPDATA7m_CLR(r) CDK_MEMSET(&((r)._mmu_cbpdata7), 0, sizeof(BCM56218_A0_MMU_CBPDATA7m_t))
#define BCM56218_A0_MMU_CBPDATA7m_SET(r,i,d) (r).mmu_cbpdata7[i] = d
#define BCM56218_A0_MMU_CBPDATA7m_GET(r,i) (r).mmu_cbpdata7[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_CBPDATA7m_CBPDATAf_GET(r,a) cdk_field_get((r).mmu_cbpdata7,0,127,a)
#define BCM56218_A0_MMU_CBPDATA7m_CBPDATAf_SET(r,a) cdk_field_set((r).mmu_cbpdata7,0,127,a)

/*
 * These macros can be used to access MMU_CBPData7.
 *
 */
#define BCM56218_A0_READ_MMU_CBPDATA7m(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_CBPDATA7m,i,(m._mmu_cbpdata7),4)
#define BCM56218_A0_WRITE_MMU_CBPDATA7m(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_CBPDATA7m,i,&(m._mmu_cbpdata7),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CBPDATA7m BCM56218_A0_MMU_CBPDATA7m
#define MMU_CBPDATA7m_MIN BCM56218_A0_MMU_CBPDATA7m_MIN
#define MMU_CBPDATA7m_MAX BCM56218_A0_MMU_CBPDATA7m_MAX
#define MMU_CBPDATA7m_CMAX(u) BCM56218_A0_MMU_CBPDATA7m_CMAX(u)
#define MMU_CBPDATA7m_SIZE BCM56218_A0_MMU_CBPDATA7m_SIZE
typedef BCM56218_A0_MMU_CBPDATA7m_t MMU_CBPDATA7m_t;
#define MMU_CBPDATA7m_CLR BCM56218_A0_MMU_CBPDATA7m_CLR
#define MMU_CBPDATA7m_SET BCM56218_A0_MMU_CBPDATA7m_SET
#define MMU_CBPDATA7m_GET BCM56218_A0_MMU_CBPDATA7m_GET
#define MMU_CBPDATA7m_CBPDATAf_GET BCM56218_A0_MMU_CBPDATA7m_CBPDATAf_GET
#define MMU_CBPDATA7m_CBPDATAf_SET BCM56218_A0_MMU_CBPDATA7m_CBPDATAf_SET
#define READ_MMU_CBPDATA7m BCM56218_A0_READ_MMU_CBPDATA7m
#define WRITE_MMU_CBPDATA7m BCM56218_A0_WRITE_MMU_CBPDATA7m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_CBPDATA7m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_CBPPktHeader0
 * BLOCKS:   MMU
 * DESC:     CBP Packet Header RAM 0
 * SIZE:     39
 * FIELDS:
 *     MH_PRIORITY      mh priority
 *     SRC_HIGIG        src higig
 *     PBI_RESERVED_BIT_0 pbi reserved bit 0
 *     SRC_PORT_NUM     Source Port Number
 *     HG2_FRC_RESERVED mh reserved
 *     NHOP_INDEX       Next HOP Index
 *     DSCP             New DSCP
 *     RESERVED         Reserved bits for future use
 *     PARITY_0         L3 Unicast Packet Flag
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_CBPPKTHEADER0m 0x0a640000

#define BCM56218_A0_MMU_CBPPKTHEADER0m_MIN 0
#define BCM56218_A0_MMU_CBPPKTHEADER0m_MAX 4095
#define BCM56218_A0_MMU_CBPPKTHEADER0m_CMAX(u) 4095
#define BCM56218_A0_MMU_CBPPKTHEADER0m_SIZE 5

/*
 * This structure should be used to declare and program MMU_CBPPktHeader0.
 *
 */
typedef union BCM56218_A0_MMU_CBPPKTHEADER0m_s {
	uint32_t v[2];
	uint32_t mmu_cbppktheader0[2];
	uint32_t _mmu_cbppktheader0;
} BCM56218_A0_MMU_CBPPKTHEADER0m_t;

#define BCM56218_A0_MMU_CBPPKTHEADER0m_CLR(r) CDK_MEMSET(&((r)._mmu_cbppktheader0), 0, sizeof(BCM56218_A0_MMU_CBPPKTHEADER0m_t))
#define BCM56218_A0_MMU_CBPPKTHEADER0m_SET(r,i,d) (r).mmu_cbppktheader0[i] = d
#define BCM56218_A0_MMU_CBPPKTHEADER0m_GET(r,i) (r).mmu_cbppktheader0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_CBPPKTHEADER0m_MH_PRIORITYf_GET(r) (((r).mmu_cbppktheader0[0]) & 0xf)
#define BCM56218_A0_MMU_CBPPKTHEADER0m_MH_PRIORITYf_SET(r,f) (r).mmu_cbppktheader0[0]=(((r).mmu_cbppktheader0[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56218_A0_MMU_CBPPKTHEADER0m_SRC_HIGIGf_GET(r) ((((r).mmu_cbppktheader0[0]) >> 4) & 0x1)
#define BCM56218_A0_MMU_CBPPKTHEADER0m_SRC_HIGIGf_SET(r,f) (r).mmu_cbppktheader0[0]=(((r).mmu_cbppktheader0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56218_A0_MMU_CBPPKTHEADER0m_PBI_RESERVED_BIT_0f_GET(r) ((((r).mmu_cbppktheader0[0]) >> 5) & 0x1)
#define BCM56218_A0_MMU_CBPPKTHEADER0m_PBI_RESERVED_BIT_0f_SET(r,f) (r).mmu_cbppktheader0[0]=(((r).mmu_cbppktheader0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56218_A0_MMU_CBPPKTHEADER0m_SRC_PORT_NUMf_GET(r) ((((r).mmu_cbppktheader0[0]) >> 6) & 0x3f)
#define BCM56218_A0_MMU_CBPPKTHEADER0m_SRC_PORT_NUMf_SET(r,f) (r).mmu_cbppktheader0[0]=(((r).mmu_cbppktheader0[0] & ~((uint32_t)0x3f << 6)) | ((((uint32_t)f) & 0x3f) << 6))
#define BCM56218_A0_MMU_CBPPKTHEADER0m_HG2_FRC_RESERVEDf_GET(r) ((((r).mmu_cbppktheader0[0]) >> 12) & 0x3f)
#define BCM56218_A0_MMU_CBPPKTHEADER0m_HG2_FRC_RESERVEDf_SET(r,f) (r).mmu_cbppktheader0[0]=(((r).mmu_cbppktheader0[0] & ~((uint32_t)0x3f << 12)) | ((((uint32_t)f) & 0x3f) << 12))
#define BCM56218_A0_MMU_CBPPKTHEADER0m_NHOP_INDEXf_GET(r) ((((r).mmu_cbppktheader0[0]) >> 18) & 0x1fff)
#define BCM56218_A0_MMU_CBPPKTHEADER0m_NHOP_INDEXf_SET(r,f) (r).mmu_cbppktheader0[0]=(((r).mmu_cbppktheader0[0] & ~((uint32_t)0x1fff << 18)) | ((((uint32_t)f) & 0x1fff) << 18))
#define BCM56218_A0_MMU_CBPPKTHEADER0m_DSCPf_GET(r) cdk_field32_get((r).mmu_cbppktheader0,31,36)
#define BCM56218_A0_MMU_CBPPKTHEADER0m_DSCPf_SET(r,f) cdk_field32_set((r).mmu_cbppktheader0,31,36,f)
#define BCM56218_A0_MMU_CBPPKTHEADER0m_RESERVEDf_GET(r) ((((r).mmu_cbppktheader0[1]) >> 5) & 0x1)
#define BCM56218_A0_MMU_CBPPKTHEADER0m_RESERVEDf_SET(r,f) (r).mmu_cbppktheader0[1]=(((r).mmu_cbppktheader0[1] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56218_A0_MMU_CBPPKTHEADER0m_PARITY_0f_GET(r) ((((r).mmu_cbppktheader0[1]) >> 6) & 0x1)
#define BCM56218_A0_MMU_CBPPKTHEADER0m_PARITY_0f_SET(r,f) (r).mmu_cbppktheader0[1]=(((r).mmu_cbppktheader0[1] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))

/*
 * These macros can be used to access MMU_CBPPktHeader0.
 *
 */
#define BCM56218_A0_READ_MMU_CBPPKTHEADER0m(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_CBPPKTHEADER0m,i,(m._mmu_cbppktheader0),2)
#define BCM56218_A0_WRITE_MMU_CBPPKTHEADER0m(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_CBPPKTHEADER0m,i,&(m._mmu_cbppktheader0),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CBPPKTHEADER0m BCM56218_A0_MMU_CBPPKTHEADER0m
#define MMU_CBPPKTHEADER0m_MIN BCM56218_A0_MMU_CBPPKTHEADER0m_MIN
#define MMU_CBPPKTHEADER0m_MAX BCM56218_A0_MMU_CBPPKTHEADER0m_MAX
#define MMU_CBPPKTHEADER0m_CMAX(u) BCM56218_A0_MMU_CBPPKTHEADER0m_CMAX(u)
#define MMU_CBPPKTHEADER0m_SIZE BCM56218_A0_MMU_CBPPKTHEADER0m_SIZE
typedef BCM56218_A0_MMU_CBPPKTHEADER0m_t MMU_CBPPKTHEADER0m_t;
#define MMU_CBPPKTHEADER0m_CLR BCM56218_A0_MMU_CBPPKTHEADER0m_CLR
#define MMU_CBPPKTHEADER0m_SET BCM56218_A0_MMU_CBPPKTHEADER0m_SET
#define MMU_CBPPKTHEADER0m_GET BCM56218_A0_MMU_CBPPKTHEADER0m_GET
#define MMU_CBPPKTHEADER0m_MH_PRIORITYf_GET BCM56218_A0_MMU_CBPPKTHEADER0m_MH_PRIORITYf_GET
#define MMU_CBPPKTHEADER0m_MH_PRIORITYf_SET BCM56218_A0_MMU_CBPPKTHEADER0m_MH_PRIORITYf_SET
#define MMU_CBPPKTHEADER0m_SRC_HIGIGf_GET BCM56218_A0_MMU_CBPPKTHEADER0m_SRC_HIGIGf_GET
#define MMU_CBPPKTHEADER0m_SRC_HIGIGf_SET BCM56218_A0_MMU_CBPPKTHEADER0m_SRC_HIGIGf_SET
#define MMU_CBPPKTHEADER0m_PBI_RESERVED_BIT_0f_GET BCM56218_A0_MMU_CBPPKTHEADER0m_PBI_RESERVED_BIT_0f_GET
#define MMU_CBPPKTHEADER0m_PBI_RESERVED_BIT_0f_SET BCM56218_A0_MMU_CBPPKTHEADER0m_PBI_RESERVED_BIT_0f_SET
#define MMU_CBPPKTHEADER0m_SRC_PORT_NUMf_GET BCM56218_A0_MMU_CBPPKTHEADER0m_SRC_PORT_NUMf_GET
#define MMU_CBPPKTHEADER0m_SRC_PORT_NUMf_SET BCM56218_A0_MMU_CBPPKTHEADER0m_SRC_PORT_NUMf_SET
#define MMU_CBPPKTHEADER0m_HG2_FRC_RESERVEDf_GET BCM56218_A0_MMU_CBPPKTHEADER0m_HG2_FRC_RESERVEDf_GET
#define MMU_CBPPKTHEADER0m_HG2_FRC_RESERVEDf_SET BCM56218_A0_MMU_CBPPKTHEADER0m_HG2_FRC_RESERVEDf_SET
#define MMU_CBPPKTHEADER0m_NHOP_INDEXf_GET BCM56218_A0_MMU_CBPPKTHEADER0m_NHOP_INDEXf_GET
#define MMU_CBPPKTHEADER0m_NHOP_INDEXf_SET BCM56218_A0_MMU_CBPPKTHEADER0m_NHOP_INDEXf_SET
#define MMU_CBPPKTHEADER0m_DSCPf_GET BCM56218_A0_MMU_CBPPKTHEADER0m_DSCPf_GET
#define MMU_CBPPKTHEADER0m_DSCPf_SET BCM56218_A0_MMU_CBPPKTHEADER0m_DSCPf_SET
#define MMU_CBPPKTHEADER0m_RESERVEDf_GET BCM56218_A0_MMU_CBPPKTHEADER0m_RESERVEDf_GET
#define MMU_CBPPKTHEADER0m_RESERVEDf_SET BCM56218_A0_MMU_CBPPKTHEADER0m_RESERVEDf_SET
#define MMU_CBPPKTHEADER0m_PARITY_0f_GET BCM56218_A0_MMU_CBPPKTHEADER0m_PARITY_0f_GET
#define MMU_CBPPKTHEADER0m_PARITY_0f_SET BCM56218_A0_MMU_CBPPKTHEADER0m_PARITY_0f_SET
#define READ_MMU_CBPPKTHEADER0m BCM56218_A0_READ_MMU_CBPPKTHEADER0m
#define WRITE_MMU_CBPPKTHEADER0m BCM56218_A0_WRITE_MMU_CBPPKTHEADER0m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_CBPPKTHEADER0m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_CBPPktHeader1
 * BLOCKS:   MMU
 * DESC:     CBP Packet Header RAM 1
 * SIZE:     39
 * FIELDS:
 *     PKT_PRI          Insert Priority
 *     PKT_VID          Insert Vlan ID
 *     ADD_VID          VLAN ID Added
 *     PKT_CFI          Insert Vlan ID
 *     INGRESS_TAGGED   Ingress Packet Tagged
 *     PBI_RESERVED_BIT_1 PBI reserved bit 1
 *     SOBMH            sobmh
 *     PBI_RESERVED_BIT_3 PBI reserved bit 3
 *     DO_NOT_CHANGE_TTL PBI reserved bit 1
 *     ECN              PBI reserved bit 1
 *     DECAP_IPTUNNEL   Decap IP Tunneling Packet
 *     BPDU             BPDU bit
 *     L3UC             Parity for CBP Packet Header
 *     COPY_COUNT       How Many copies of this cell are there
 *     USE_OUTER_HDR_TTL outer hdr ttl
 *     RESERVED         reserved
 *     PARITY_1         Parity for CBP Packet Header
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_CBPPKTHEADER1m 0x0a644000

#define BCM56218_A0_MMU_CBPPKTHEADER1m_MIN 0
#define BCM56218_A0_MMU_CBPPKTHEADER1m_MAX 4095
#define BCM56218_A0_MMU_CBPPKTHEADER1m_CMAX(u) 4095
#define BCM56218_A0_MMU_CBPPKTHEADER1m_SIZE 5

/*
 * This structure should be used to declare and program MMU_CBPPktHeader1.
 *
 */
typedef union BCM56218_A0_MMU_CBPPKTHEADER1m_s {
	uint32_t v[2];
	uint32_t mmu_cbppktheader1[2];
	uint32_t _mmu_cbppktheader1;
} BCM56218_A0_MMU_CBPPKTHEADER1m_t;

#define BCM56218_A0_MMU_CBPPKTHEADER1m_CLR(r) CDK_MEMSET(&((r)._mmu_cbppktheader1), 0, sizeof(BCM56218_A0_MMU_CBPPKTHEADER1m_t))
#define BCM56218_A0_MMU_CBPPKTHEADER1m_SET(r,i,d) (r).mmu_cbppktheader1[i] = d
#define BCM56218_A0_MMU_CBPPKTHEADER1m_GET(r,i) (r).mmu_cbppktheader1[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_CBPPKTHEADER1m_PKT_PRIf_GET(r) (((r).mmu_cbppktheader1[0]) & 0x7)
#define BCM56218_A0_MMU_CBPPKTHEADER1m_PKT_PRIf_SET(r,f) (r).mmu_cbppktheader1[0]=(((r).mmu_cbppktheader1[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM56218_A0_MMU_CBPPKTHEADER1m_PKT_VIDf_GET(r) ((((r).mmu_cbppktheader1[0]) >> 3) & 0xfff)
#define BCM56218_A0_MMU_CBPPKTHEADER1m_PKT_VIDf_SET(r,f) (r).mmu_cbppktheader1[0]=(((r).mmu_cbppktheader1[0] & ~((uint32_t)0xfff << 3)) | ((((uint32_t)f) & 0xfff) << 3))
#define BCM56218_A0_MMU_CBPPKTHEADER1m_ADD_VIDf_GET(r) ((((r).mmu_cbppktheader1[0]) >> 15) & 0x1)
#define BCM56218_A0_MMU_CBPPKTHEADER1m_ADD_VIDf_SET(r,f) (r).mmu_cbppktheader1[0]=(((r).mmu_cbppktheader1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56218_A0_MMU_CBPPKTHEADER1m_PKT_CFIf_GET(r) ((((r).mmu_cbppktheader1[0]) >> 16) & 0x1)
#define BCM56218_A0_MMU_CBPPKTHEADER1m_PKT_CFIf_SET(r,f) (r).mmu_cbppktheader1[0]=(((r).mmu_cbppktheader1[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56218_A0_MMU_CBPPKTHEADER1m_INGRESS_TAGGEDf_GET(r) ((((r).mmu_cbppktheader1[0]) >> 17) & 0x1)
#define BCM56218_A0_MMU_CBPPKTHEADER1m_INGRESS_TAGGEDf_SET(r,f) (r).mmu_cbppktheader1[0]=(((r).mmu_cbppktheader1[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_MMU_CBPPKTHEADER1m_PBI_RESERVED_BIT_1f_GET(r) ((((r).mmu_cbppktheader1[0]) >> 18) & 0x1)
#define BCM56218_A0_MMU_CBPPKTHEADER1m_PBI_RESERVED_BIT_1f_SET(r,f) (r).mmu_cbppktheader1[0]=(((r).mmu_cbppktheader1[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_MMU_CBPPKTHEADER1m_SOBMHf_GET(r) ((((r).mmu_cbppktheader1[0]) >> 19) & 0x1)
#define BCM56218_A0_MMU_CBPPKTHEADER1m_SOBMHf_SET(r,f) (r).mmu_cbppktheader1[0]=(((r).mmu_cbppktheader1[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56218_A0_MMU_CBPPKTHEADER1m_PBI_RESERVED_BIT_3f_GET(r) ((((r).mmu_cbppktheader1[0]) >> 20) & 0x1)
#define BCM56218_A0_MMU_CBPPKTHEADER1m_PBI_RESERVED_BIT_3f_SET(r,f) (r).mmu_cbppktheader1[0]=(((r).mmu_cbppktheader1[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM56218_A0_MMU_CBPPKTHEADER1m_DO_NOT_CHANGE_TTLf_GET(r) ((((r).mmu_cbppktheader1[0]) >> 21) & 0x1)
#define BCM56218_A0_MMU_CBPPKTHEADER1m_DO_NOT_CHANGE_TTLf_SET(r,f) (r).mmu_cbppktheader1[0]=(((r).mmu_cbppktheader1[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM56218_A0_MMU_CBPPKTHEADER1m_ECNf_GET(r) ((((r).mmu_cbppktheader1[0]) >> 22) & 0x3)
#define BCM56218_A0_MMU_CBPPKTHEADER1m_ECNf_SET(r,f) (r).mmu_cbppktheader1[0]=(((r).mmu_cbppktheader1[0] & ~((uint32_t)0x3 << 22)) | ((((uint32_t)f) & 0x3) << 22))
#define BCM56218_A0_MMU_CBPPKTHEADER1m_DECAP_IPTUNNELf_GET(r) ((((r).mmu_cbppktheader1[0]) >> 24) & 0x1)
#define BCM56218_A0_MMU_CBPPKTHEADER1m_DECAP_IPTUNNELf_SET(r,f) (r).mmu_cbppktheader1[0]=(((r).mmu_cbppktheader1[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM56218_A0_MMU_CBPPKTHEADER1m_BPDUf_GET(r) ((((r).mmu_cbppktheader1[0]) >> 25) & 0x1)
#define BCM56218_A0_MMU_CBPPKTHEADER1m_BPDUf_SET(r,f) (r).mmu_cbppktheader1[0]=(((r).mmu_cbppktheader1[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM56218_A0_MMU_CBPPKTHEADER1m_L3UCf_GET(r) ((((r).mmu_cbppktheader1[0]) >> 26) & 0x1)
#define BCM56218_A0_MMU_CBPPKTHEADER1m_L3UCf_SET(r,f) (r).mmu_cbppktheader1[0]=(((r).mmu_cbppktheader1[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM56218_A0_MMU_CBPPKTHEADER1m_COPY_COUNTf_GET(r) cdk_field32_get((r).mmu_cbppktheader1,27,32)
#define BCM56218_A0_MMU_CBPPKTHEADER1m_COPY_COUNTf_SET(r,f) cdk_field32_set((r).mmu_cbppktheader1,27,32,f)
#define BCM56218_A0_MMU_CBPPKTHEADER1m_USE_OUTER_HDR_TTLf_GET(r) ((((r).mmu_cbppktheader1[1]) >> 1) & 0x1)
#define BCM56218_A0_MMU_CBPPKTHEADER1m_USE_OUTER_HDR_TTLf_SET(r,f) (r).mmu_cbppktheader1[1]=(((r).mmu_cbppktheader1[1] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_MMU_CBPPKTHEADER1m_RESERVEDf_GET(r) ((((r).mmu_cbppktheader1[1]) >> 2) & 0xf)
#define BCM56218_A0_MMU_CBPPKTHEADER1m_RESERVEDf_SET(r,f) (r).mmu_cbppktheader1[1]=(((r).mmu_cbppktheader1[1] & ~((uint32_t)0xf << 2)) | ((((uint32_t)f) & 0xf) << 2))
#define BCM56218_A0_MMU_CBPPKTHEADER1m_PARITY_1f_GET(r) ((((r).mmu_cbppktheader1[1]) >> 6) & 0x1)
#define BCM56218_A0_MMU_CBPPKTHEADER1m_PARITY_1f_SET(r,f) (r).mmu_cbppktheader1[1]=(((r).mmu_cbppktheader1[1] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))

/*
 * These macros can be used to access MMU_CBPPktHeader1.
 *
 */
#define BCM56218_A0_READ_MMU_CBPPKTHEADER1m(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_CBPPKTHEADER1m,i,(m._mmu_cbppktheader1),2)
#define BCM56218_A0_WRITE_MMU_CBPPKTHEADER1m(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_CBPPKTHEADER1m,i,&(m._mmu_cbppktheader1),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CBPPKTHEADER1m BCM56218_A0_MMU_CBPPKTHEADER1m
#define MMU_CBPPKTHEADER1m_MIN BCM56218_A0_MMU_CBPPKTHEADER1m_MIN
#define MMU_CBPPKTHEADER1m_MAX BCM56218_A0_MMU_CBPPKTHEADER1m_MAX
#define MMU_CBPPKTHEADER1m_CMAX(u) BCM56218_A0_MMU_CBPPKTHEADER1m_CMAX(u)
#define MMU_CBPPKTHEADER1m_SIZE BCM56218_A0_MMU_CBPPKTHEADER1m_SIZE
typedef BCM56218_A0_MMU_CBPPKTHEADER1m_t MMU_CBPPKTHEADER1m_t;
#define MMU_CBPPKTHEADER1m_CLR BCM56218_A0_MMU_CBPPKTHEADER1m_CLR
#define MMU_CBPPKTHEADER1m_SET BCM56218_A0_MMU_CBPPKTHEADER1m_SET
#define MMU_CBPPKTHEADER1m_GET BCM56218_A0_MMU_CBPPKTHEADER1m_GET
#define MMU_CBPPKTHEADER1m_PKT_PRIf_GET BCM56218_A0_MMU_CBPPKTHEADER1m_PKT_PRIf_GET
#define MMU_CBPPKTHEADER1m_PKT_PRIf_SET BCM56218_A0_MMU_CBPPKTHEADER1m_PKT_PRIf_SET
#define MMU_CBPPKTHEADER1m_PKT_VIDf_GET BCM56218_A0_MMU_CBPPKTHEADER1m_PKT_VIDf_GET
#define MMU_CBPPKTHEADER1m_PKT_VIDf_SET BCM56218_A0_MMU_CBPPKTHEADER1m_PKT_VIDf_SET
#define MMU_CBPPKTHEADER1m_ADD_VIDf_GET BCM56218_A0_MMU_CBPPKTHEADER1m_ADD_VIDf_GET
#define MMU_CBPPKTHEADER1m_ADD_VIDf_SET BCM56218_A0_MMU_CBPPKTHEADER1m_ADD_VIDf_SET
#define MMU_CBPPKTHEADER1m_PKT_CFIf_GET BCM56218_A0_MMU_CBPPKTHEADER1m_PKT_CFIf_GET
#define MMU_CBPPKTHEADER1m_PKT_CFIf_SET BCM56218_A0_MMU_CBPPKTHEADER1m_PKT_CFIf_SET
#define MMU_CBPPKTHEADER1m_INGRESS_TAGGEDf_GET BCM56218_A0_MMU_CBPPKTHEADER1m_INGRESS_TAGGEDf_GET
#define MMU_CBPPKTHEADER1m_INGRESS_TAGGEDf_SET BCM56218_A0_MMU_CBPPKTHEADER1m_INGRESS_TAGGEDf_SET
#define MMU_CBPPKTHEADER1m_PBI_RESERVED_BIT_1f_GET BCM56218_A0_MMU_CBPPKTHEADER1m_PBI_RESERVED_BIT_1f_GET
#define MMU_CBPPKTHEADER1m_PBI_RESERVED_BIT_1f_SET BCM56218_A0_MMU_CBPPKTHEADER1m_PBI_RESERVED_BIT_1f_SET
#define MMU_CBPPKTHEADER1m_SOBMHf_GET BCM56218_A0_MMU_CBPPKTHEADER1m_SOBMHf_GET
#define MMU_CBPPKTHEADER1m_SOBMHf_SET BCM56218_A0_MMU_CBPPKTHEADER1m_SOBMHf_SET
#define MMU_CBPPKTHEADER1m_PBI_RESERVED_BIT_3f_GET BCM56218_A0_MMU_CBPPKTHEADER1m_PBI_RESERVED_BIT_3f_GET
#define MMU_CBPPKTHEADER1m_PBI_RESERVED_BIT_3f_SET BCM56218_A0_MMU_CBPPKTHEADER1m_PBI_RESERVED_BIT_3f_SET
#define MMU_CBPPKTHEADER1m_DO_NOT_CHANGE_TTLf_GET BCM56218_A0_MMU_CBPPKTHEADER1m_DO_NOT_CHANGE_TTLf_GET
#define MMU_CBPPKTHEADER1m_DO_NOT_CHANGE_TTLf_SET BCM56218_A0_MMU_CBPPKTHEADER1m_DO_NOT_CHANGE_TTLf_SET
#define MMU_CBPPKTHEADER1m_ECNf_GET BCM56218_A0_MMU_CBPPKTHEADER1m_ECNf_GET
#define MMU_CBPPKTHEADER1m_ECNf_SET BCM56218_A0_MMU_CBPPKTHEADER1m_ECNf_SET
#define MMU_CBPPKTHEADER1m_DECAP_IPTUNNELf_GET BCM56218_A0_MMU_CBPPKTHEADER1m_DECAP_IPTUNNELf_GET
#define MMU_CBPPKTHEADER1m_DECAP_IPTUNNELf_SET BCM56218_A0_MMU_CBPPKTHEADER1m_DECAP_IPTUNNELf_SET
#define MMU_CBPPKTHEADER1m_BPDUf_GET BCM56218_A0_MMU_CBPPKTHEADER1m_BPDUf_GET
#define MMU_CBPPKTHEADER1m_BPDUf_SET BCM56218_A0_MMU_CBPPKTHEADER1m_BPDUf_SET
#define MMU_CBPPKTHEADER1m_L3UCf_GET BCM56218_A0_MMU_CBPPKTHEADER1m_L3UCf_GET
#define MMU_CBPPKTHEADER1m_L3UCf_SET BCM56218_A0_MMU_CBPPKTHEADER1m_L3UCf_SET
#define MMU_CBPPKTHEADER1m_COPY_COUNTf_GET BCM56218_A0_MMU_CBPPKTHEADER1m_COPY_COUNTf_GET
#define MMU_CBPPKTHEADER1m_COPY_COUNTf_SET BCM56218_A0_MMU_CBPPKTHEADER1m_COPY_COUNTf_SET
#define MMU_CBPPKTHEADER1m_USE_OUTER_HDR_TTLf_GET BCM56218_A0_MMU_CBPPKTHEADER1m_USE_OUTER_HDR_TTLf_GET
#define MMU_CBPPKTHEADER1m_USE_OUTER_HDR_TTLf_SET BCM56218_A0_MMU_CBPPKTHEADER1m_USE_OUTER_HDR_TTLf_SET
#define MMU_CBPPKTHEADER1m_RESERVEDf_GET BCM56218_A0_MMU_CBPPKTHEADER1m_RESERVEDf_GET
#define MMU_CBPPKTHEADER1m_RESERVEDf_SET BCM56218_A0_MMU_CBPPKTHEADER1m_RESERVEDf_SET
#define MMU_CBPPKTHEADER1m_PARITY_1f_GET BCM56218_A0_MMU_CBPPKTHEADER1m_PARITY_1f_GET
#define MMU_CBPPKTHEADER1m_PARITY_1f_SET BCM56218_A0_MMU_CBPPKTHEADER1m_PARITY_1f_SET
#define READ_MMU_CBPPKTHEADER1m BCM56218_A0_READ_MMU_CBPPKTHEADER1m
#define WRITE_MMU_CBPPKTHEADER1m BCM56218_A0_WRITE_MMU_CBPPKTHEADER1m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_CBPPKTHEADER1m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_CCP
 * BLOCKS:   MMU
 * DESC:     Copy Count Pool RAM
 * SIZE:     7
 * FIELDS:
 *     CCP              Packet's copy count
 *     PARITY           Packet's copy count parity
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_CCPm 0x0a654000

#define BCM56218_A0_MMU_CCPm_MIN 0
#define BCM56218_A0_MMU_CCPm_MAX 4095
#define BCM56218_A0_MMU_CCPm_CMAX(u) 4095
#define BCM56218_A0_MMU_CCPm_SIZE 1

/*
 * This structure should be used to declare and program MMU_CCP.
 *
 */
typedef union BCM56218_A0_MMU_CCPm_s {
	uint32_t v[1];
	uint32_t mmu_ccp[1];
	uint32_t _mmu_ccp;
} BCM56218_A0_MMU_CCPm_t;

#define BCM56218_A0_MMU_CCPm_CLR(r) (r).mmu_ccp[0] = 0
#define BCM56218_A0_MMU_CCPm_SET(r,d) (r).mmu_ccp[0] = d
#define BCM56218_A0_MMU_CCPm_GET(r) (r).mmu_ccp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_CCPm_CCPf_GET(r) (((r).mmu_ccp[0]) & 0x3f)
#define BCM56218_A0_MMU_CCPm_CCPf_SET(r,f) (r).mmu_ccp[0]=(((r).mmu_ccp[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM56218_A0_MMU_CCPm_PARITYf_GET(r) ((((r).mmu_ccp[0]) >> 6) & 0x1)
#define BCM56218_A0_MMU_CCPm_PARITYf_SET(r,f) (r).mmu_ccp[0]=(((r).mmu_ccp[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))

/*
 * These macros can be used to access MMU_CCP.
 *
 */
#define BCM56218_A0_READ_MMU_CCPm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_CCPm,i,(m._mmu_ccp),1)
#define BCM56218_A0_WRITE_MMU_CCPm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_CCPm,i,&(m._mmu_ccp),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CCPm BCM56218_A0_MMU_CCPm
#define MMU_CCPm_MIN BCM56218_A0_MMU_CCPm_MIN
#define MMU_CCPm_MAX BCM56218_A0_MMU_CCPm_MAX
#define MMU_CCPm_CMAX(u) BCM56218_A0_MMU_CCPm_CMAX(u)
#define MMU_CCPm_SIZE BCM56218_A0_MMU_CCPm_SIZE
typedef BCM56218_A0_MMU_CCPm_t MMU_CCPm_t;
#define MMU_CCPm_CLR BCM56218_A0_MMU_CCPm_CLR
#define MMU_CCPm_SET BCM56218_A0_MMU_CCPm_SET
#define MMU_CCPm_GET BCM56218_A0_MMU_CCPm_GET
#define MMU_CCPm_CCPf_GET BCM56218_A0_MMU_CCPm_CCPf_GET
#define MMU_CCPm_CCPf_SET BCM56218_A0_MMU_CCPm_CCPf_SET
#define MMU_CCPm_PARITYf_GET BCM56218_A0_MMU_CCPm_PARITYf_GET
#define MMU_CCPm_PARITYf_SET BCM56218_A0_MMU_CCPm_PARITYf_SET
#define READ_MMU_CCPm BCM56218_A0_READ_MMU_CCPm
#define WRITE_MMU_CCPm BCM56218_A0_WRITE_MMU_CCPm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_CCPm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_CFAP
 * BLOCKS:   MMU
 * DESC:     CBP Free Address Pool RAM
 * SIZE:     15
 * FIELDS:
 *     FREE_PTR         CBP Free Address
 *     PARITY           CBP Free Address Parity
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_CFAPm 0x0a650000

#define BCM56218_A0_MMU_CFAPm_MIN 0
#define BCM56218_A0_MMU_CFAPm_MAX 4095
#define BCM56218_A0_MMU_CFAPm_CMAX(u) 4095
#define BCM56218_A0_MMU_CFAPm_SIZE 2

/*
 * This structure should be used to declare and program MMU_CFAP.
 *
 */
typedef union BCM56218_A0_MMU_CFAPm_s {
	uint32_t v[1];
	uint32_t mmu_cfap[1];
	uint32_t _mmu_cfap;
} BCM56218_A0_MMU_CFAPm_t;

#define BCM56218_A0_MMU_CFAPm_CLR(r) (r).mmu_cfap[0] = 0
#define BCM56218_A0_MMU_CFAPm_SET(r,d) (r).mmu_cfap[0] = d
#define BCM56218_A0_MMU_CFAPm_GET(r) (r).mmu_cfap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_CFAPm_FREE_PTRf_GET(r) (((r).mmu_cfap[0]) & 0x3fff)
#define BCM56218_A0_MMU_CFAPm_FREE_PTRf_SET(r,f) (r).mmu_cfap[0]=(((r).mmu_cfap[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM56218_A0_MMU_CFAPm_PARITYf_GET(r) ((((r).mmu_cfap[0]) >> 14) & 0x1)
#define BCM56218_A0_MMU_CFAPm_PARITYf_SET(r,f) (r).mmu_cfap[0]=(((r).mmu_cfap[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))

/*
 * These macros can be used to access MMU_CFAP.
 *
 */
#define BCM56218_A0_READ_MMU_CFAPm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_CFAPm,i,(m._mmu_cfap),1)
#define BCM56218_A0_WRITE_MMU_CFAPm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_CFAPm,i,&(m._mmu_cfap),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CFAPm BCM56218_A0_MMU_CFAPm
#define MMU_CFAPm_MIN BCM56218_A0_MMU_CFAPm_MIN
#define MMU_CFAPm_MAX BCM56218_A0_MMU_CFAPm_MAX
#define MMU_CFAPm_CMAX(u) BCM56218_A0_MMU_CFAPm_CMAX(u)
#define MMU_CFAPm_SIZE BCM56218_A0_MMU_CFAPm_SIZE
typedef BCM56218_A0_MMU_CFAPm_t MMU_CFAPm_t;
#define MMU_CFAPm_CLR BCM56218_A0_MMU_CFAPm_CLR
#define MMU_CFAPm_SET BCM56218_A0_MMU_CFAPm_SET
#define MMU_CFAPm_GET BCM56218_A0_MMU_CFAPm_GET
#define MMU_CFAPm_FREE_PTRf_GET BCM56218_A0_MMU_CFAPm_FREE_PTRf_GET
#define MMU_CFAPm_FREE_PTRf_SET BCM56218_A0_MMU_CFAPm_FREE_PTRf_SET
#define MMU_CFAPm_PARITYf_GET BCM56218_A0_MMU_CFAPm_PARITYf_GET
#define MMU_CFAPm_PARITYf_SET BCM56218_A0_MMU_CFAPm_PARITYf_SET
#define READ_MMU_CFAPm BCM56218_A0_READ_MMU_CFAPm
#define WRITE_MMU_CFAPm BCM56218_A0_WRITE_MMU_CFAPm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_CFAPm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_XQ0
 * BLOCKS:   MMU
 * DESC:     XQ0
 * SIZE:     163
 * FIELDS:
 *     PARITY_0         Parity bit
 *     PARITY0_DATA     parity0 data
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     RESERVED_0       reserved for future use
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *     MTP_INDEX        Mirror-to-Port Index
 *     RESERVED_1       reserved for future use
 *     MH_OPCODE_OVERLAY Module Header OPCode
 *     CLASSIFICATION_TAG Calssification TAG
 *     HEADER_TYPE      Module Header Type
 *     MATCHED_RULE     Matched Rule Number to help out the CPU
 *     CPU_OPCODE       CPU OPCode to help out the CPU
 *     COS              Packet COS
 *     PARITY_1         Parity bit 0
 *     MODULE_HEADER    extra Module Header information.
 *     PARITY1_DATA     parity1 data
 *     CLASSIFICATION_TAG_HI Packet COS
 *     SRC_MODID        Packet COS
 *     DESTINATION      destination
 *     SRC_PORT_TGID    Packet COS
 *     MCST             Packet COS
 *     VC_LABEL         Packet COS
 *     LBID             Packet COS
 *     L3_MTU_FAILED    Packet COS
 *     HDR_EXT_OVERLAY  hdr ext overlay
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_XQ0m 0x0b600000

#define BCM56218_A0_MMU_XQ0m_MIN 0
#define BCM56218_A0_MMU_XQ0m_MAX 767
#define BCM56218_A0_MMU_XQ0m_CMAX(u) 767
#define BCM56218_A0_MMU_XQ0m_SIZE 21

/*
 * This structure should be used to declare and program MMU_XQ0.
 *
 */
typedef union BCM56218_A0_MMU_XQ0m_s {
	uint32_t v[6];
	uint32_t mmu_xq0[6];
	uint32_t _mmu_xq0;
} BCM56218_A0_MMU_XQ0m_t;

#define BCM56218_A0_MMU_XQ0m_CLR(r) CDK_MEMSET(&((r)._mmu_xq0), 0, sizeof(BCM56218_A0_MMU_XQ0m_t))
#define BCM56218_A0_MMU_XQ0m_SET(r,i,d) (r).mmu_xq0[i] = d
#define BCM56218_A0_MMU_XQ0m_GET(r,i) (r).mmu_xq0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_XQ0m_PARITY_0f_GET(r) (((r).mmu_xq0[0]) & 0x1)
#define BCM56218_A0_MMU_XQ0m_PARITY_0f_SET(r,f) (r).mmu_xq0[0]=(((r).mmu_xq0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_MMU_XQ0m_PARITY0_DATAf_GET(r,a) cdk_field_get((r).mmu_xq0,1,90,a)
#define BCM56218_A0_MMU_XQ0m_PARITY0_DATAf_SET(r,a) cdk_field_set((r).mmu_xq0,1,90,a)
#define BCM56218_A0_MMU_XQ0m_L2f_GET(r) ((((r).mmu_xq0[0]) >> 1) & 0x1)
#define BCM56218_A0_MMU_XQ0m_L2f_SET(r,f) (r).mmu_xq0[0]=(((r).mmu_xq0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_MMU_XQ0m_PURGEf_GET(r) ((((r).mmu_xq0[0]) >> 2) & 0x1)
#define BCM56218_A0_MMU_XQ0m_PURGEf_SET(r,f) (r).mmu_xq0[0]=(((r).mmu_xq0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_MMU_XQ0m_PKT_PTRf_GET(r) ((((r).mmu_xq0[0]) >> 3) & 0x3fff)
#define BCM56218_A0_MMU_XQ0m_PKT_PTRf_SET(r,f) (r).mmu_xq0[0]=(((r).mmu_xq0[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56218_A0_MMU_XQ0m_RESERVED_0f_GET(r) ((((r).mmu_xq0[0]) >> 17) & 0x1)
#define BCM56218_A0_MMU_XQ0m_RESERVED_0f_SET(r,f) (r).mmu_xq0[0]=(((r).mmu_xq0[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_MMU_XQ0m_IMIRRORf_GET(r) ((((r).mmu_xq0[0]) >> 18) & 0x1)
#define BCM56218_A0_MMU_XQ0m_IMIRRORf_SET(r,f) (r).mmu_xq0[0]=(((r).mmu_xq0[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_MMU_XQ0m_EMIRRORf_GET(r) ((((r).mmu_xq0[0]) >> 19) & 0x1)
#define BCM56218_A0_MMU_XQ0m_EMIRRORf_SET(r,f) (r).mmu_xq0[0]=(((r).mmu_xq0[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56218_A0_MMU_XQ0m_MTP_INDEXf_GET(r) ((((r).mmu_xq0[0]) >> 20) & 0x7f)
#define BCM56218_A0_MMU_XQ0m_MTP_INDEXf_SET(r,f) (r).mmu_xq0[0]=(((r).mmu_xq0[0] & ~((uint32_t)0x7f << 20)) | ((((uint32_t)f) & 0x7f) << 20))
#define BCM56218_A0_MMU_XQ0m_RESERVED_1f_GET(r) ((((r).mmu_xq0[0]) >> 27) & 0x3)
#define BCM56218_A0_MMU_XQ0m_RESERVED_1f_SET(r,f) (r).mmu_xq0[0]=(((r).mmu_xq0[0] & ~((uint32_t)0x3 << 27)) | ((((uint32_t)f) & 0x3) << 27))
#define BCM56218_A0_MMU_XQ0m_MH_OPCODE_OVERLAYf_GET(r) cdk_field32_get((r).mmu_xq0,29,36)
#define BCM56218_A0_MMU_XQ0m_MH_OPCODE_OVERLAYf_SET(r,f) cdk_field32_set((r).mmu_xq0,29,36,f)
#define BCM56218_A0_MMU_XQ0m_CLASSIFICATION_TAGf_GET(r) ((((r).mmu_xq0[1]) >> 5) & 0x7ff)
#define BCM56218_A0_MMU_XQ0m_CLASSIFICATION_TAGf_SET(r,f) (r).mmu_xq0[1]=(((r).mmu_xq0[1] & ~((uint32_t)0x7ff << 5)) | ((((uint32_t)f) & 0x7ff) << 5))
#define BCM56218_A0_MMU_XQ0m_HEADER_TYPEf_GET(r) ((((r).mmu_xq0[1]) >> 16) & 0x7)
#define BCM56218_A0_MMU_XQ0m_HEADER_TYPEf_SET(r,f) (r).mmu_xq0[1]=(((r).mmu_xq0[1] & ~((uint32_t)0x7 << 16)) | ((((uint32_t)f) & 0x7) << 16))
#define BCM56218_A0_MMU_XQ0m_MATCHED_RULEf_GET(r) ((((r).mmu_xq0[1]) >> 19) & 0x7ff)
#define BCM56218_A0_MMU_XQ0m_MATCHED_RULEf_SET(r,f) (r).mmu_xq0[1]=(((r).mmu_xq0[1] & ~((uint32_t)0x7ff << 19)) | ((((uint32_t)f) & 0x7ff) << 19))
#define BCM56218_A0_MMU_XQ0m_CPU_OPCODEf_GET(r) cdk_field32_get((r).mmu_xq0,62,87)
#define BCM56218_A0_MMU_XQ0m_CPU_OPCODEf_SET(r,f) cdk_field32_set((r).mmu_xq0,62,87,f)
#define BCM56218_A0_MMU_XQ0m_COSf_GET(r) ((((r).mmu_xq0[2]) >> 24) & 0x7)
#define BCM56218_A0_MMU_XQ0m_COSf_SET(r,f) (r).mmu_xq0[2]=(((r).mmu_xq0[2] & ~((uint32_t)0x7 << 24)) | ((((uint32_t)f) & 0x7) << 24))
#define BCM56218_A0_MMU_XQ0m_PARITY_1f_GET(r) ((((r).mmu_xq0[2]) >> 27) & 0x1)
#define BCM56218_A0_MMU_XQ0m_PARITY_1f_SET(r,f) (r).mmu_xq0[2]=(((r).mmu_xq0[2] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM56218_A0_MMU_XQ0m_MODULE_HEADERf_GET(r,a) cdk_field_get((r).mmu_xq0,92,162,a)
#define BCM56218_A0_MMU_XQ0m_MODULE_HEADERf_SET(r,a) cdk_field_set((r).mmu_xq0,92,162,a)
#define BCM56218_A0_MMU_XQ0m_PARITY1_DATAf_GET(r,a) cdk_field_get((r).mmu_xq0,92,162,a)
#define BCM56218_A0_MMU_XQ0m_PARITY1_DATAf_SET(r,a) cdk_field_set((r).mmu_xq0,92,162,a)
#define BCM56218_A0_MMU_XQ0m_CLASSIFICATION_TAG_HIf_GET(r) cdk_field32_get((r).mmu_xq0,92,96)
#define BCM56218_A0_MMU_XQ0m_CLASSIFICATION_TAG_HIf_SET(r,f) cdk_field32_set((r).mmu_xq0,92,96,f)
#define BCM56218_A0_MMU_XQ0m_SRC_MODIDf_GET(r) ((((r).mmu_xq0[3]) >> 1) & 0xff)
#define BCM56218_A0_MMU_XQ0m_SRC_MODIDf_SET(r,f) (r).mmu_xq0[3]=(((r).mmu_xq0[3] & ~((uint32_t)0xff << 1)) | ((((uint32_t)f) & 0xff) << 1))
#define BCM56218_A0_MMU_XQ0m_DESTINATIONf_GET(r) ((((r).mmu_xq0[3]) >> 9) & 0xffff)
#define BCM56218_A0_MMU_XQ0m_DESTINATIONf_SET(r,f) (r).mmu_xq0[3]=(((r).mmu_xq0[3] & ~((uint32_t)0xffff << 9)) | ((((uint32_t)f) & 0xffff) << 9))
#define BCM56218_A0_MMU_XQ0m_SRC_PORT_TGIDf_GET(r) cdk_field32_get((r).mmu_xq0,111,128)
#define BCM56218_A0_MMU_XQ0m_SRC_PORT_TGIDf_SET(r,f) cdk_field32_set((r).mmu_xq0,111,128,f)
#define BCM56218_A0_MMU_XQ0m_MCSTf_GET(r) ((((r).mmu_xq0[4]) >> 1) & 0x1)
#define BCM56218_A0_MMU_XQ0m_MCSTf_SET(r,f) (r).mmu_xq0[4]=(((r).mmu_xq0[4] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_MMU_XQ0m_VC_LABELf_GET(r) ((((r).mmu_xq0[4]) >> 2) & 0xffff)
#define BCM56218_A0_MMU_XQ0m_VC_LABELf_SET(r,f) (r).mmu_xq0[4]=(((r).mmu_xq0[4] & ~((uint32_t)0xffff << 2)) | ((((uint32_t)f) & 0xffff) << 2))
#define BCM56218_A0_MMU_XQ0m_LBIDf_GET(r) ((((r).mmu_xq0[4]) >> 18) & 0xff)
#define BCM56218_A0_MMU_XQ0m_LBIDf_SET(r,f) (r).mmu_xq0[4]=(((r).mmu_xq0[4] & ~((uint32_t)0xff << 18)) | ((((uint32_t)f) & 0xff) << 18))
#define BCM56218_A0_MMU_XQ0m_L3_MTU_FAILEDf_GET(r) ((((r).mmu_xq0[4]) >> 26) & 0x1)
#define BCM56218_A0_MMU_XQ0m_L3_MTU_FAILEDf_SET(r,f) (r).mmu_xq0[4]=(((r).mmu_xq0[4] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM56218_A0_MMU_XQ0m_HDR_EXT_OVERLAYf_GET(r) cdk_field32_get((r).mmu_xq0,155,162)
#define BCM56218_A0_MMU_XQ0m_HDR_EXT_OVERLAYf_SET(r,f) cdk_field32_set((r).mmu_xq0,155,162,f)

/*
 * These macros can be used to access MMU_XQ0.
 *
 */
#define BCM56218_A0_READ_MMU_XQ0m(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_XQ0m,i,(m._mmu_xq0),6)
#define BCM56218_A0_WRITE_MMU_XQ0m(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_XQ0m,i,&(m._mmu_xq0),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ0m BCM56218_A0_MMU_XQ0m
#define MMU_XQ0m_MIN BCM56218_A0_MMU_XQ0m_MIN
#define MMU_XQ0m_MAX BCM56218_A0_MMU_XQ0m_MAX
#define MMU_XQ0m_CMAX(u) BCM56218_A0_MMU_XQ0m_CMAX(u)
#define MMU_XQ0m_SIZE BCM56218_A0_MMU_XQ0m_SIZE
typedef BCM56218_A0_MMU_XQ0m_t MMU_XQ0m_t;
#define MMU_XQ0m_CLR BCM56218_A0_MMU_XQ0m_CLR
#define MMU_XQ0m_SET BCM56218_A0_MMU_XQ0m_SET
#define MMU_XQ0m_GET BCM56218_A0_MMU_XQ0m_GET
#define MMU_XQ0m_PARITY_0f_GET BCM56218_A0_MMU_XQ0m_PARITY_0f_GET
#define MMU_XQ0m_PARITY_0f_SET BCM56218_A0_MMU_XQ0m_PARITY_0f_SET
#define MMU_XQ0m_PARITY0_DATAf_GET BCM56218_A0_MMU_XQ0m_PARITY0_DATAf_GET
#define MMU_XQ0m_PARITY0_DATAf_SET BCM56218_A0_MMU_XQ0m_PARITY0_DATAf_SET
#define MMU_XQ0m_L2f_GET BCM56218_A0_MMU_XQ0m_L2f_GET
#define MMU_XQ0m_L2f_SET BCM56218_A0_MMU_XQ0m_L2f_SET
#define MMU_XQ0m_PURGEf_GET BCM56218_A0_MMU_XQ0m_PURGEf_GET
#define MMU_XQ0m_PURGEf_SET BCM56218_A0_MMU_XQ0m_PURGEf_SET
#define MMU_XQ0m_PKT_PTRf_GET BCM56218_A0_MMU_XQ0m_PKT_PTRf_GET
#define MMU_XQ0m_PKT_PTRf_SET BCM56218_A0_MMU_XQ0m_PKT_PTRf_SET
#define MMU_XQ0m_RESERVED_0f_GET BCM56218_A0_MMU_XQ0m_RESERVED_0f_GET
#define MMU_XQ0m_RESERVED_0f_SET BCM56218_A0_MMU_XQ0m_RESERVED_0f_SET
#define MMU_XQ0m_IMIRRORf_GET BCM56218_A0_MMU_XQ0m_IMIRRORf_GET
#define MMU_XQ0m_IMIRRORf_SET BCM56218_A0_MMU_XQ0m_IMIRRORf_SET
#define MMU_XQ0m_EMIRRORf_GET BCM56218_A0_MMU_XQ0m_EMIRRORf_GET
#define MMU_XQ0m_EMIRRORf_SET BCM56218_A0_MMU_XQ0m_EMIRRORf_SET
#define MMU_XQ0m_MTP_INDEXf_GET BCM56218_A0_MMU_XQ0m_MTP_INDEXf_GET
#define MMU_XQ0m_MTP_INDEXf_SET BCM56218_A0_MMU_XQ0m_MTP_INDEXf_SET
#define MMU_XQ0m_RESERVED_1f_GET BCM56218_A0_MMU_XQ0m_RESERVED_1f_GET
#define MMU_XQ0m_RESERVED_1f_SET BCM56218_A0_MMU_XQ0m_RESERVED_1f_SET
#define MMU_XQ0m_MH_OPCODE_OVERLAYf_GET BCM56218_A0_MMU_XQ0m_MH_OPCODE_OVERLAYf_GET
#define MMU_XQ0m_MH_OPCODE_OVERLAYf_SET BCM56218_A0_MMU_XQ0m_MH_OPCODE_OVERLAYf_SET
#define MMU_XQ0m_CLASSIFICATION_TAGf_GET BCM56218_A0_MMU_XQ0m_CLASSIFICATION_TAGf_GET
#define MMU_XQ0m_CLASSIFICATION_TAGf_SET BCM56218_A0_MMU_XQ0m_CLASSIFICATION_TAGf_SET
#define MMU_XQ0m_HEADER_TYPEf_GET BCM56218_A0_MMU_XQ0m_HEADER_TYPEf_GET
#define MMU_XQ0m_HEADER_TYPEf_SET BCM56218_A0_MMU_XQ0m_HEADER_TYPEf_SET
#define MMU_XQ0m_MATCHED_RULEf_GET BCM56218_A0_MMU_XQ0m_MATCHED_RULEf_GET
#define MMU_XQ0m_MATCHED_RULEf_SET BCM56218_A0_MMU_XQ0m_MATCHED_RULEf_SET
#define MMU_XQ0m_CPU_OPCODEf_GET BCM56218_A0_MMU_XQ0m_CPU_OPCODEf_GET
#define MMU_XQ0m_CPU_OPCODEf_SET BCM56218_A0_MMU_XQ0m_CPU_OPCODEf_SET
#define MMU_XQ0m_COSf_GET BCM56218_A0_MMU_XQ0m_COSf_GET
#define MMU_XQ0m_COSf_SET BCM56218_A0_MMU_XQ0m_COSf_SET
#define MMU_XQ0m_PARITY_1f_GET BCM56218_A0_MMU_XQ0m_PARITY_1f_GET
#define MMU_XQ0m_PARITY_1f_SET BCM56218_A0_MMU_XQ0m_PARITY_1f_SET
#define MMU_XQ0m_MODULE_HEADERf_GET BCM56218_A0_MMU_XQ0m_MODULE_HEADERf_GET
#define MMU_XQ0m_MODULE_HEADERf_SET BCM56218_A0_MMU_XQ0m_MODULE_HEADERf_SET
#define MMU_XQ0m_PARITY1_DATAf_GET BCM56218_A0_MMU_XQ0m_PARITY1_DATAf_GET
#define MMU_XQ0m_PARITY1_DATAf_SET BCM56218_A0_MMU_XQ0m_PARITY1_DATAf_SET
#define MMU_XQ0m_CLASSIFICATION_TAG_HIf_GET BCM56218_A0_MMU_XQ0m_CLASSIFICATION_TAG_HIf_GET
#define MMU_XQ0m_CLASSIFICATION_TAG_HIf_SET BCM56218_A0_MMU_XQ0m_CLASSIFICATION_TAG_HIf_SET
#define MMU_XQ0m_SRC_MODIDf_GET BCM56218_A0_MMU_XQ0m_SRC_MODIDf_GET
#define MMU_XQ0m_SRC_MODIDf_SET BCM56218_A0_MMU_XQ0m_SRC_MODIDf_SET
#define MMU_XQ0m_DESTINATIONf_GET BCM56218_A0_MMU_XQ0m_DESTINATIONf_GET
#define MMU_XQ0m_DESTINATIONf_SET BCM56218_A0_MMU_XQ0m_DESTINATIONf_SET
#define MMU_XQ0m_SRC_PORT_TGIDf_GET BCM56218_A0_MMU_XQ0m_SRC_PORT_TGIDf_GET
#define MMU_XQ0m_SRC_PORT_TGIDf_SET BCM56218_A0_MMU_XQ0m_SRC_PORT_TGIDf_SET
#define MMU_XQ0m_MCSTf_GET BCM56218_A0_MMU_XQ0m_MCSTf_GET
#define MMU_XQ0m_MCSTf_SET BCM56218_A0_MMU_XQ0m_MCSTf_SET
#define MMU_XQ0m_VC_LABELf_GET BCM56218_A0_MMU_XQ0m_VC_LABELf_GET
#define MMU_XQ0m_VC_LABELf_SET BCM56218_A0_MMU_XQ0m_VC_LABELf_SET
#define MMU_XQ0m_LBIDf_GET BCM56218_A0_MMU_XQ0m_LBIDf_GET
#define MMU_XQ0m_LBIDf_SET BCM56218_A0_MMU_XQ0m_LBIDf_SET
#define MMU_XQ0m_L3_MTU_FAILEDf_GET BCM56218_A0_MMU_XQ0m_L3_MTU_FAILEDf_GET
#define MMU_XQ0m_L3_MTU_FAILEDf_SET BCM56218_A0_MMU_XQ0m_L3_MTU_FAILEDf_SET
#define MMU_XQ0m_HDR_EXT_OVERLAYf_GET BCM56218_A0_MMU_XQ0m_HDR_EXT_OVERLAYf_GET
#define MMU_XQ0m_HDR_EXT_OVERLAYf_SET BCM56218_A0_MMU_XQ0m_HDR_EXT_OVERLAYf_SET
#define READ_MMU_XQ0m BCM56218_A0_READ_MMU_XQ0m
#define WRITE_MMU_XQ0m BCM56218_A0_WRITE_MMU_XQ0m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_XQ0m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_XQ1
 * BLOCKS:   MMU
 * DESC:     XQ1
 * SIZE:     123
 * FIELDS:
 *     PARITY_0         Parity bit 0
 *     PARITY0_DATA     parity0 data
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     RESERVED_0       reserved for future use
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *     MTP_INDEX        Mirror-to-Port Index
 *     RESERVED_1       reserved for future use
 *     MH_OPCODE_OVERLAY Module Header OPCode
 *     CLASSIFICATION_TAG Calssification TAG
 *     HEADER_TYPE      Module Header Type
 *     PARITY_1         Parity bit 1
 *     MODULE_HEADER    extra Module Header information.
 *     PARITY1_DATA     parity1 data
 *     CLASSIFICATION_TAG_HI Packet COS
 *     SRC_MODID        Packet COS
 *     DESTINATION      Packet COS
 *     SRC_PORT_TGID    Packet COS
 *     MCST             Packet COS
 *     VC_LABEL         Packet COS
 *     LBID             Packet COS
 *     RESERVED_2       reserved for future use
 *     HDR_EXT_OVERLAY  hdr ext overlay
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_XQ1m 0x0b604000

#define BCM56218_A0_MMU_XQ1m_MIN 0
#define BCM56218_A0_MMU_XQ1m_MAX 767
#define BCM56218_A0_MMU_XQ1m_CMAX(u) 767
#define BCM56218_A0_MMU_XQ1m_SIZE 16

/*
 * This structure should be used to declare and program MMU_XQ1.
 *
 */
typedef union BCM56218_A0_MMU_XQ1m_s {
	uint32_t v[4];
	uint32_t mmu_xq1[4];
	uint32_t _mmu_xq1;
} BCM56218_A0_MMU_XQ1m_t;

#define BCM56218_A0_MMU_XQ1m_CLR(r) CDK_MEMSET(&((r)._mmu_xq1), 0, sizeof(BCM56218_A0_MMU_XQ1m_t))
#define BCM56218_A0_MMU_XQ1m_SET(r,i,d) (r).mmu_xq1[i] = d
#define BCM56218_A0_MMU_XQ1m_GET(r,i) (r).mmu_xq1[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_XQ1m_PARITY_0f_GET(r) (((r).mmu_xq1[0]) & 0x1)
#define BCM56218_A0_MMU_XQ1m_PARITY_0f_SET(r,f) (r).mmu_xq1[0]=(((r).mmu_xq1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_MMU_XQ1m_PARITY0_DATAf_GET(r,a) cdk_field_get((r).mmu_xq1,1,50,a)
#define BCM56218_A0_MMU_XQ1m_PARITY0_DATAf_SET(r,a) cdk_field_set((r).mmu_xq1,1,50,a)
#define BCM56218_A0_MMU_XQ1m_L2f_GET(r) ((((r).mmu_xq1[0]) >> 1) & 0x1)
#define BCM56218_A0_MMU_XQ1m_L2f_SET(r,f) (r).mmu_xq1[0]=(((r).mmu_xq1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_MMU_XQ1m_PURGEf_GET(r) ((((r).mmu_xq1[0]) >> 2) & 0x1)
#define BCM56218_A0_MMU_XQ1m_PURGEf_SET(r,f) (r).mmu_xq1[0]=(((r).mmu_xq1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_MMU_XQ1m_PKT_PTRf_GET(r) ((((r).mmu_xq1[0]) >> 3) & 0x3fff)
#define BCM56218_A0_MMU_XQ1m_PKT_PTRf_SET(r,f) (r).mmu_xq1[0]=(((r).mmu_xq1[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56218_A0_MMU_XQ1m_RESERVED_0f_GET(r) ((((r).mmu_xq1[0]) >> 17) & 0x1)
#define BCM56218_A0_MMU_XQ1m_RESERVED_0f_SET(r,f) (r).mmu_xq1[0]=(((r).mmu_xq1[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_MMU_XQ1m_IMIRRORf_GET(r) ((((r).mmu_xq1[0]) >> 18) & 0x1)
#define BCM56218_A0_MMU_XQ1m_IMIRRORf_SET(r,f) (r).mmu_xq1[0]=(((r).mmu_xq1[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_MMU_XQ1m_EMIRRORf_GET(r) ((((r).mmu_xq1[0]) >> 19) & 0x1)
#define BCM56218_A0_MMU_XQ1m_EMIRRORf_SET(r,f) (r).mmu_xq1[0]=(((r).mmu_xq1[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56218_A0_MMU_XQ1m_MTP_INDEXf_GET(r) ((((r).mmu_xq1[0]) >> 20) & 0x7f)
#define BCM56218_A0_MMU_XQ1m_MTP_INDEXf_SET(r,f) (r).mmu_xq1[0]=(((r).mmu_xq1[0] & ~((uint32_t)0x7f << 20)) | ((((uint32_t)f) & 0x7f) << 20))
#define BCM56218_A0_MMU_XQ1m_RESERVED_1f_GET(r) ((((r).mmu_xq1[0]) >> 27) & 0x3)
#define BCM56218_A0_MMU_XQ1m_RESERVED_1f_SET(r,f) (r).mmu_xq1[0]=(((r).mmu_xq1[0] & ~((uint32_t)0x3 << 27)) | ((((uint32_t)f) & 0x3) << 27))
#define BCM56218_A0_MMU_XQ1m_MH_OPCODE_OVERLAYf_GET(r) cdk_field32_get((r).mmu_xq1,29,36)
#define BCM56218_A0_MMU_XQ1m_MH_OPCODE_OVERLAYf_SET(r,f) cdk_field32_set((r).mmu_xq1,29,36,f)
#define BCM56218_A0_MMU_XQ1m_CLASSIFICATION_TAGf_GET(r) ((((r).mmu_xq1[1]) >> 5) & 0x7ff)
#define BCM56218_A0_MMU_XQ1m_CLASSIFICATION_TAGf_SET(r,f) (r).mmu_xq1[1]=(((r).mmu_xq1[1] & ~((uint32_t)0x7ff << 5)) | ((((uint32_t)f) & 0x7ff) << 5))
#define BCM56218_A0_MMU_XQ1m_HEADER_TYPEf_GET(r) ((((r).mmu_xq1[1]) >> 16) & 0x7)
#define BCM56218_A0_MMU_XQ1m_HEADER_TYPEf_SET(r,f) (r).mmu_xq1[1]=(((r).mmu_xq1[1] & ~((uint32_t)0x7 << 16)) | ((((uint32_t)f) & 0x7) << 16))
#define BCM56218_A0_MMU_XQ1m_PARITY_1f_GET(r) ((((r).mmu_xq1[1]) >> 19) & 0x1)
#define BCM56218_A0_MMU_XQ1m_PARITY_1f_SET(r,f) (r).mmu_xq1[1]=(((r).mmu_xq1[1] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56218_A0_MMU_XQ1m_MODULE_HEADERf_GET(r,a) cdk_field_get((r).mmu_xq1,52,122,a)
#define BCM56218_A0_MMU_XQ1m_MODULE_HEADERf_SET(r,a) cdk_field_set((r).mmu_xq1,52,122,a)
#define BCM56218_A0_MMU_XQ1m_PARITY1_DATAf_GET(r,a) cdk_field_get((r).mmu_xq1,52,122,a)
#define BCM56218_A0_MMU_XQ1m_PARITY1_DATAf_SET(r,a) cdk_field_set((r).mmu_xq1,52,122,a)
#define BCM56218_A0_MMU_XQ1m_CLASSIFICATION_TAG_HIf_GET(r) ((((r).mmu_xq1[1]) >> 20) & 0x1f)
#define BCM56218_A0_MMU_XQ1m_CLASSIFICATION_TAG_HIf_SET(r,f) (r).mmu_xq1[1]=(((r).mmu_xq1[1] & ~((uint32_t)0x1f << 20)) | ((((uint32_t)f) & 0x1f) << 20))
#define BCM56218_A0_MMU_XQ1m_SRC_MODIDf_GET(r) cdk_field32_get((r).mmu_xq1,57,64)
#define BCM56218_A0_MMU_XQ1m_SRC_MODIDf_SET(r,f) cdk_field32_set((r).mmu_xq1,57,64,f)
#define BCM56218_A0_MMU_XQ1m_DESTINATIONf_GET(r) ((((r).mmu_xq1[2]) >> 1) & 0xffff)
#define BCM56218_A0_MMU_XQ1m_DESTINATIONf_SET(r,f) (r).mmu_xq1[2]=(((r).mmu_xq1[2] & ~((uint32_t)0xffff << 1)) | ((((uint32_t)f) & 0xffff) << 1))
#define BCM56218_A0_MMU_XQ1m_SRC_PORT_TGIDf_GET(r) ((((r).mmu_xq1[2]) >> 17) & 0xff)
#define BCM56218_A0_MMU_XQ1m_SRC_PORT_TGIDf_SET(r,f) (r).mmu_xq1[2]=(((r).mmu_xq1[2] & ~((uint32_t)0xff << 17)) | ((((uint32_t)f) & 0xff) << 17))
#define BCM56218_A0_MMU_XQ1m_MCSTf_GET(r) ((((r).mmu_xq1[2]) >> 25) & 0x1)
#define BCM56218_A0_MMU_XQ1m_MCSTf_SET(r,f) (r).mmu_xq1[2]=(((r).mmu_xq1[2] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM56218_A0_MMU_XQ1m_VC_LABELf_GET(r) cdk_field32_get((r).mmu_xq1,90,105)
#define BCM56218_A0_MMU_XQ1m_VC_LABELf_SET(r,f) cdk_field32_set((r).mmu_xq1,90,105,f)
#define BCM56218_A0_MMU_XQ1m_LBIDf_GET(r) ((((r).mmu_xq1[3]) >> 10) & 0xff)
#define BCM56218_A0_MMU_XQ1m_LBIDf_SET(r,f) (r).mmu_xq1[3]=(((r).mmu_xq1[3] & ~((uint32_t)0xff << 10)) | ((((uint32_t)f) & 0xff) << 10))
#define BCM56218_A0_MMU_XQ1m_RESERVED_2f_GET(r) ((((r).mmu_xq1[3]) >> 18) & 0x1)
#define BCM56218_A0_MMU_XQ1m_RESERVED_2f_SET(r,f) (r).mmu_xq1[3]=(((r).mmu_xq1[3] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_MMU_XQ1m_HDR_EXT_OVERLAYf_GET(r) ((((r).mmu_xq1[3]) >> 19) & 0xff)
#define BCM56218_A0_MMU_XQ1m_HDR_EXT_OVERLAYf_SET(r,f) (r).mmu_xq1[3]=(((r).mmu_xq1[3] & ~((uint32_t)0xff << 19)) | ((((uint32_t)f) & 0xff) << 19))

/*
 * These macros can be used to access MMU_XQ1.
 *
 */
#define BCM56218_A0_READ_MMU_XQ1m(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_XQ1m,i,(m._mmu_xq1),4)
#define BCM56218_A0_WRITE_MMU_XQ1m(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_XQ1m,i,&(m._mmu_xq1),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ1m BCM56218_A0_MMU_XQ1m
#define MMU_XQ1m_MIN BCM56218_A0_MMU_XQ1m_MIN
#define MMU_XQ1m_MAX BCM56218_A0_MMU_XQ1m_MAX
#define MMU_XQ1m_CMAX(u) BCM56218_A0_MMU_XQ1m_CMAX(u)
#define MMU_XQ1m_SIZE BCM56218_A0_MMU_XQ1m_SIZE
typedef BCM56218_A0_MMU_XQ1m_t MMU_XQ1m_t;
#define MMU_XQ1m_CLR BCM56218_A0_MMU_XQ1m_CLR
#define MMU_XQ1m_SET BCM56218_A0_MMU_XQ1m_SET
#define MMU_XQ1m_GET BCM56218_A0_MMU_XQ1m_GET
#define MMU_XQ1m_PARITY_0f_GET BCM56218_A0_MMU_XQ1m_PARITY_0f_GET
#define MMU_XQ1m_PARITY_0f_SET BCM56218_A0_MMU_XQ1m_PARITY_0f_SET
#define MMU_XQ1m_PARITY0_DATAf_GET BCM56218_A0_MMU_XQ1m_PARITY0_DATAf_GET
#define MMU_XQ1m_PARITY0_DATAf_SET BCM56218_A0_MMU_XQ1m_PARITY0_DATAf_SET
#define MMU_XQ1m_L2f_GET BCM56218_A0_MMU_XQ1m_L2f_GET
#define MMU_XQ1m_L2f_SET BCM56218_A0_MMU_XQ1m_L2f_SET
#define MMU_XQ1m_PURGEf_GET BCM56218_A0_MMU_XQ1m_PURGEf_GET
#define MMU_XQ1m_PURGEf_SET BCM56218_A0_MMU_XQ1m_PURGEf_SET
#define MMU_XQ1m_PKT_PTRf_GET BCM56218_A0_MMU_XQ1m_PKT_PTRf_GET
#define MMU_XQ1m_PKT_PTRf_SET BCM56218_A0_MMU_XQ1m_PKT_PTRf_SET
#define MMU_XQ1m_RESERVED_0f_GET BCM56218_A0_MMU_XQ1m_RESERVED_0f_GET
#define MMU_XQ1m_RESERVED_0f_SET BCM56218_A0_MMU_XQ1m_RESERVED_0f_SET
#define MMU_XQ1m_IMIRRORf_GET BCM56218_A0_MMU_XQ1m_IMIRRORf_GET
#define MMU_XQ1m_IMIRRORf_SET BCM56218_A0_MMU_XQ1m_IMIRRORf_SET
#define MMU_XQ1m_EMIRRORf_GET BCM56218_A0_MMU_XQ1m_EMIRRORf_GET
#define MMU_XQ1m_EMIRRORf_SET BCM56218_A0_MMU_XQ1m_EMIRRORf_SET
#define MMU_XQ1m_MTP_INDEXf_GET BCM56218_A0_MMU_XQ1m_MTP_INDEXf_GET
#define MMU_XQ1m_MTP_INDEXf_SET BCM56218_A0_MMU_XQ1m_MTP_INDEXf_SET
#define MMU_XQ1m_RESERVED_1f_GET BCM56218_A0_MMU_XQ1m_RESERVED_1f_GET
#define MMU_XQ1m_RESERVED_1f_SET BCM56218_A0_MMU_XQ1m_RESERVED_1f_SET
#define MMU_XQ1m_MH_OPCODE_OVERLAYf_GET BCM56218_A0_MMU_XQ1m_MH_OPCODE_OVERLAYf_GET
#define MMU_XQ1m_MH_OPCODE_OVERLAYf_SET BCM56218_A0_MMU_XQ1m_MH_OPCODE_OVERLAYf_SET
#define MMU_XQ1m_CLASSIFICATION_TAGf_GET BCM56218_A0_MMU_XQ1m_CLASSIFICATION_TAGf_GET
#define MMU_XQ1m_CLASSIFICATION_TAGf_SET BCM56218_A0_MMU_XQ1m_CLASSIFICATION_TAGf_SET
#define MMU_XQ1m_HEADER_TYPEf_GET BCM56218_A0_MMU_XQ1m_HEADER_TYPEf_GET
#define MMU_XQ1m_HEADER_TYPEf_SET BCM56218_A0_MMU_XQ1m_HEADER_TYPEf_SET
#define MMU_XQ1m_PARITY_1f_GET BCM56218_A0_MMU_XQ1m_PARITY_1f_GET
#define MMU_XQ1m_PARITY_1f_SET BCM56218_A0_MMU_XQ1m_PARITY_1f_SET
#define MMU_XQ1m_MODULE_HEADERf_GET BCM56218_A0_MMU_XQ1m_MODULE_HEADERf_GET
#define MMU_XQ1m_MODULE_HEADERf_SET BCM56218_A0_MMU_XQ1m_MODULE_HEADERf_SET
#define MMU_XQ1m_PARITY1_DATAf_GET BCM56218_A0_MMU_XQ1m_PARITY1_DATAf_GET
#define MMU_XQ1m_PARITY1_DATAf_SET BCM56218_A0_MMU_XQ1m_PARITY1_DATAf_SET
#define MMU_XQ1m_CLASSIFICATION_TAG_HIf_GET BCM56218_A0_MMU_XQ1m_CLASSIFICATION_TAG_HIf_GET
#define MMU_XQ1m_CLASSIFICATION_TAG_HIf_SET BCM56218_A0_MMU_XQ1m_CLASSIFICATION_TAG_HIf_SET
#define MMU_XQ1m_SRC_MODIDf_GET BCM56218_A0_MMU_XQ1m_SRC_MODIDf_GET
#define MMU_XQ1m_SRC_MODIDf_SET BCM56218_A0_MMU_XQ1m_SRC_MODIDf_SET
#define MMU_XQ1m_DESTINATIONf_GET BCM56218_A0_MMU_XQ1m_DESTINATIONf_GET
#define MMU_XQ1m_DESTINATIONf_SET BCM56218_A0_MMU_XQ1m_DESTINATIONf_SET
#define MMU_XQ1m_SRC_PORT_TGIDf_GET BCM56218_A0_MMU_XQ1m_SRC_PORT_TGIDf_GET
#define MMU_XQ1m_SRC_PORT_TGIDf_SET BCM56218_A0_MMU_XQ1m_SRC_PORT_TGIDf_SET
#define MMU_XQ1m_MCSTf_GET BCM56218_A0_MMU_XQ1m_MCSTf_GET
#define MMU_XQ1m_MCSTf_SET BCM56218_A0_MMU_XQ1m_MCSTf_SET
#define MMU_XQ1m_VC_LABELf_GET BCM56218_A0_MMU_XQ1m_VC_LABELf_GET
#define MMU_XQ1m_VC_LABELf_SET BCM56218_A0_MMU_XQ1m_VC_LABELf_SET
#define MMU_XQ1m_LBIDf_GET BCM56218_A0_MMU_XQ1m_LBIDf_GET
#define MMU_XQ1m_LBIDf_SET BCM56218_A0_MMU_XQ1m_LBIDf_SET
#define MMU_XQ1m_RESERVED_2f_GET BCM56218_A0_MMU_XQ1m_RESERVED_2f_GET
#define MMU_XQ1m_RESERVED_2f_SET BCM56218_A0_MMU_XQ1m_RESERVED_2f_SET
#define MMU_XQ1m_HDR_EXT_OVERLAYf_GET BCM56218_A0_MMU_XQ1m_HDR_EXT_OVERLAYf_GET
#define MMU_XQ1m_HDR_EXT_OVERLAYf_SET BCM56218_A0_MMU_XQ1m_HDR_EXT_OVERLAYf_SET
#define READ_MMU_XQ1m BCM56218_A0_READ_MMU_XQ1m
#define WRITE_MMU_XQ1m BCM56218_A0_WRITE_MMU_XQ1m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_XQ1m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_XQ10
 * BLOCKS:   MMU
 * DESC:     XQ10
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     RESERVED_0       reserved for future use
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_XQ10m 0x0b628000

#define BCM56218_A0_MMU_XQ10m_MIN 0
#define BCM56218_A0_MMU_XQ10m_MAX 511
#define BCM56218_A0_MMU_XQ10m_CMAX(u) 511
#define BCM56218_A0_MMU_XQ10m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ10.
 *
 */
typedef union BCM56218_A0_MMU_XQ10m_s {
	uint32_t v[1];
	uint32_t mmu_xq10[1];
	uint32_t _mmu_xq10;
} BCM56218_A0_MMU_XQ10m_t;

#define BCM56218_A0_MMU_XQ10m_CLR(r) (r).mmu_xq10[0] = 0
#define BCM56218_A0_MMU_XQ10m_SET(r,d) (r).mmu_xq10[0] = d
#define BCM56218_A0_MMU_XQ10m_GET(r) (r).mmu_xq10[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_XQ10m_PARITY_0f_GET(r) (((r).mmu_xq10[0]) & 0x1)
#define BCM56218_A0_MMU_XQ10m_PARITY_0f_SET(r,f) (r).mmu_xq10[0]=(((r).mmu_xq10[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_MMU_XQ10m_L2f_GET(r) ((((r).mmu_xq10[0]) >> 1) & 0x1)
#define BCM56218_A0_MMU_XQ10m_L2f_SET(r,f) (r).mmu_xq10[0]=(((r).mmu_xq10[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_MMU_XQ10m_PURGEf_GET(r) ((((r).mmu_xq10[0]) >> 2) & 0x1)
#define BCM56218_A0_MMU_XQ10m_PURGEf_SET(r,f) (r).mmu_xq10[0]=(((r).mmu_xq10[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_MMU_XQ10m_PKT_PTRf_GET(r) ((((r).mmu_xq10[0]) >> 3) & 0x3fff)
#define BCM56218_A0_MMU_XQ10m_PKT_PTRf_SET(r,f) (r).mmu_xq10[0]=(((r).mmu_xq10[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56218_A0_MMU_XQ10m_RESERVED_0f_GET(r) ((((r).mmu_xq10[0]) >> 17) & 0x1)
#define BCM56218_A0_MMU_XQ10m_RESERVED_0f_SET(r,f) (r).mmu_xq10[0]=(((r).mmu_xq10[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_MMU_XQ10m_IMIRRORf_GET(r) ((((r).mmu_xq10[0]) >> 18) & 0x1)
#define BCM56218_A0_MMU_XQ10m_IMIRRORf_SET(r,f) (r).mmu_xq10[0]=(((r).mmu_xq10[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_MMU_XQ10m_EMIRRORf_GET(r) ((((r).mmu_xq10[0]) >> 19) & 0x1)
#define BCM56218_A0_MMU_XQ10m_EMIRRORf_SET(r,f) (r).mmu_xq10[0]=(((r).mmu_xq10[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ10.
 *
 */
#define BCM56218_A0_READ_MMU_XQ10m(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_XQ10m,i,(m._mmu_xq10),1)
#define BCM56218_A0_WRITE_MMU_XQ10m(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_XQ10m,i,&(m._mmu_xq10),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ10m BCM56218_A0_MMU_XQ10m
#define MMU_XQ10m_MIN BCM56218_A0_MMU_XQ10m_MIN
#define MMU_XQ10m_MAX BCM56218_A0_MMU_XQ10m_MAX
#define MMU_XQ10m_CMAX(u) BCM56218_A0_MMU_XQ10m_CMAX(u)
#define MMU_XQ10m_SIZE BCM56218_A0_MMU_XQ10m_SIZE
typedef BCM56218_A0_MMU_XQ10m_t MMU_XQ10m_t;
#define MMU_XQ10m_CLR BCM56218_A0_MMU_XQ10m_CLR
#define MMU_XQ10m_SET BCM56218_A0_MMU_XQ10m_SET
#define MMU_XQ10m_GET BCM56218_A0_MMU_XQ10m_GET
#define MMU_XQ10m_PARITY_0f_GET BCM56218_A0_MMU_XQ10m_PARITY_0f_GET
#define MMU_XQ10m_PARITY_0f_SET BCM56218_A0_MMU_XQ10m_PARITY_0f_SET
#define MMU_XQ10m_L2f_GET BCM56218_A0_MMU_XQ10m_L2f_GET
#define MMU_XQ10m_L2f_SET BCM56218_A0_MMU_XQ10m_L2f_SET
#define MMU_XQ10m_PURGEf_GET BCM56218_A0_MMU_XQ10m_PURGEf_GET
#define MMU_XQ10m_PURGEf_SET BCM56218_A0_MMU_XQ10m_PURGEf_SET
#define MMU_XQ10m_PKT_PTRf_GET BCM56218_A0_MMU_XQ10m_PKT_PTRf_GET
#define MMU_XQ10m_PKT_PTRf_SET BCM56218_A0_MMU_XQ10m_PKT_PTRf_SET
#define MMU_XQ10m_RESERVED_0f_GET BCM56218_A0_MMU_XQ10m_RESERVED_0f_GET
#define MMU_XQ10m_RESERVED_0f_SET BCM56218_A0_MMU_XQ10m_RESERVED_0f_SET
#define MMU_XQ10m_IMIRRORf_GET BCM56218_A0_MMU_XQ10m_IMIRRORf_GET
#define MMU_XQ10m_IMIRRORf_SET BCM56218_A0_MMU_XQ10m_IMIRRORf_SET
#define MMU_XQ10m_EMIRRORf_GET BCM56218_A0_MMU_XQ10m_EMIRRORf_GET
#define MMU_XQ10m_EMIRRORf_SET BCM56218_A0_MMU_XQ10m_EMIRRORf_SET
#define READ_MMU_XQ10m BCM56218_A0_READ_MMU_XQ10m
#define WRITE_MMU_XQ10m BCM56218_A0_WRITE_MMU_XQ10m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_XQ10m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_XQ11
 * BLOCKS:   MMU
 * DESC:     XQ11
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     RESERVED_0       reserved for future use
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_XQ11m 0x0b62c000

#define BCM56218_A0_MMU_XQ11m_MIN 0
#define BCM56218_A0_MMU_XQ11m_MAX 511
#define BCM56218_A0_MMU_XQ11m_CMAX(u) 511
#define BCM56218_A0_MMU_XQ11m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ11.
 *
 */
typedef union BCM56218_A0_MMU_XQ11m_s {
	uint32_t v[1];
	uint32_t mmu_xq11[1];
	uint32_t _mmu_xq11;
} BCM56218_A0_MMU_XQ11m_t;

#define BCM56218_A0_MMU_XQ11m_CLR(r) (r).mmu_xq11[0] = 0
#define BCM56218_A0_MMU_XQ11m_SET(r,d) (r).mmu_xq11[0] = d
#define BCM56218_A0_MMU_XQ11m_GET(r) (r).mmu_xq11[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_XQ11m_PARITY_0f_GET(r) (((r).mmu_xq11[0]) & 0x1)
#define BCM56218_A0_MMU_XQ11m_PARITY_0f_SET(r,f) (r).mmu_xq11[0]=(((r).mmu_xq11[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_MMU_XQ11m_L2f_GET(r) ((((r).mmu_xq11[0]) >> 1) & 0x1)
#define BCM56218_A0_MMU_XQ11m_L2f_SET(r,f) (r).mmu_xq11[0]=(((r).mmu_xq11[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_MMU_XQ11m_PURGEf_GET(r) ((((r).mmu_xq11[0]) >> 2) & 0x1)
#define BCM56218_A0_MMU_XQ11m_PURGEf_SET(r,f) (r).mmu_xq11[0]=(((r).mmu_xq11[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_MMU_XQ11m_PKT_PTRf_GET(r) ((((r).mmu_xq11[0]) >> 3) & 0x3fff)
#define BCM56218_A0_MMU_XQ11m_PKT_PTRf_SET(r,f) (r).mmu_xq11[0]=(((r).mmu_xq11[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56218_A0_MMU_XQ11m_RESERVED_0f_GET(r) ((((r).mmu_xq11[0]) >> 17) & 0x1)
#define BCM56218_A0_MMU_XQ11m_RESERVED_0f_SET(r,f) (r).mmu_xq11[0]=(((r).mmu_xq11[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_MMU_XQ11m_IMIRRORf_GET(r) ((((r).mmu_xq11[0]) >> 18) & 0x1)
#define BCM56218_A0_MMU_XQ11m_IMIRRORf_SET(r,f) (r).mmu_xq11[0]=(((r).mmu_xq11[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_MMU_XQ11m_EMIRRORf_GET(r) ((((r).mmu_xq11[0]) >> 19) & 0x1)
#define BCM56218_A0_MMU_XQ11m_EMIRRORf_SET(r,f) (r).mmu_xq11[0]=(((r).mmu_xq11[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ11.
 *
 */
#define BCM56218_A0_READ_MMU_XQ11m(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_XQ11m,i,(m._mmu_xq11),1)
#define BCM56218_A0_WRITE_MMU_XQ11m(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_XQ11m,i,&(m._mmu_xq11),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ11m BCM56218_A0_MMU_XQ11m
#define MMU_XQ11m_MIN BCM56218_A0_MMU_XQ11m_MIN
#define MMU_XQ11m_MAX BCM56218_A0_MMU_XQ11m_MAX
#define MMU_XQ11m_CMAX(u) BCM56218_A0_MMU_XQ11m_CMAX(u)
#define MMU_XQ11m_SIZE BCM56218_A0_MMU_XQ11m_SIZE
typedef BCM56218_A0_MMU_XQ11m_t MMU_XQ11m_t;
#define MMU_XQ11m_CLR BCM56218_A0_MMU_XQ11m_CLR
#define MMU_XQ11m_SET BCM56218_A0_MMU_XQ11m_SET
#define MMU_XQ11m_GET BCM56218_A0_MMU_XQ11m_GET
#define MMU_XQ11m_PARITY_0f_GET BCM56218_A0_MMU_XQ11m_PARITY_0f_GET
#define MMU_XQ11m_PARITY_0f_SET BCM56218_A0_MMU_XQ11m_PARITY_0f_SET
#define MMU_XQ11m_L2f_GET BCM56218_A0_MMU_XQ11m_L2f_GET
#define MMU_XQ11m_L2f_SET BCM56218_A0_MMU_XQ11m_L2f_SET
#define MMU_XQ11m_PURGEf_GET BCM56218_A0_MMU_XQ11m_PURGEf_GET
#define MMU_XQ11m_PURGEf_SET BCM56218_A0_MMU_XQ11m_PURGEf_SET
#define MMU_XQ11m_PKT_PTRf_GET BCM56218_A0_MMU_XQ11m_PKT_PTRf_GET
#define MMU_XQ11m_PKT_PTRf_SET BCM56218_A0_MMU_XQ11m_PKT_PTRf_SET
#define MMU_XQ11m_RESERVED_0f_GET BCM56218_A0_MMU_XQ11m_RESERVED_0f_GET
#define MMU_XQ11m_RESERVED_0f_SET BCM56218_A0_MMU_XQ11m_RESERVED_0f_SET
#define MMU_XQ11m_IMIRRORf_GET BCM56218_A0_MMU_XQ11m_IMIRRORf_GET
#define MMU_XQ11m_IMIRRORf_SET BCM56218_A0_MMU_XQ11m_IMIRRORf_SET
#define MMU_XQ11m_EMIRRORf_GET BCM56218_A0_MMU_XQ11m_EMIRRORf_GET
#define MMU_XQ11m_EMIRRORf_SET BCM56218_A0_MMU_XQ11m_EMIRRORf_SET
#define READ_MMU_XQ11m BCM56218_A0_READ_MMU_XQ11m
#define WRITE_MMU_XQ11m BCM56218_A0_WRITE_MMU_XQ11m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_XQ11m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_XQ12
 * BLOCKS:   MMU
 * DESC:     XQ12
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     RESERVED_0       reserved for future use
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_XQ12m 0x0b630000

#define BCM56218_A0_MMU_XQ12m_MIN 0
#define BCM56218_A0_MMU_XQ12m_MAX 511
#define BCM56218_A0_MMU_XQ12m_CMAX(u) 511
#define BCM56218_A0_MMU_XQ12m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ12.
 *
 */
typedef union BCM56218_A0_MMU_XQ12m_s {
	uint32_t v[1];
	uint32_t mmu_xq12[1];
	uint32_t _mmu_xq12;
} BCM56218_A0_MMU_XQ12m_t;

#define BCM56218_A0_MMU_XQ12m_CLR(r) (r).mmu_xq12[0] = 0
#define BCM56218_A0_MMU_XQ12m_SET(r,d) (r).mmu_xq12[0] = d
#define BCM56218_A0_MMU_XQ12m_GET(r) (r).mmu_xq12[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_XQ12m_PARITY_0f_GET(r) (((r).mmu_xq12[0]) & 0x1)
#define BCM56218_A0_MMU_XQ12m_PARITY_0f_SET(r,f) (r).mmu_xq12[0]=(((r).mmu_xq12[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_MMU_XQ12m_L2f_GET(r) ((((r).mmu_xq12[0]) >> 1) & 0x1)
#define BCM56218_A0_MMU_XQ12m_L2f_SET(r,f) (r).mmu_xq12[0]=(((r).mmu_xq12[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_MMU_XQ12m_PURGEf_GET(r) ((((r).mmu_xq12[0]) >> 2) & 0x1)
#define BCM56218_A0_MMU_XQ12m_PURGEf_SET(r,f) (r).mmu_xq12[0]=(((r).mmu_xq12[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_MMU_XQ12m_PKT_PTRf_GET(r) ((((r).mmu_xq12[0]) >> 3) & 0x3fff)
#define BCM56218_A0_MMU_XQ12m_PKT_PTRf_SET(r,f) (r).mmu_xq12[0]=(((r).mmu_xq12[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56218_A0_MMU_XQ12m_RESERVED_0f_GET(r) ((((r).mmu_xq12[0]) >> 17) & 0x1)
#define BCM56218_A0_MMU_XQ12m_RESERVED_0f_SET(r,f) (r).mmu_xq12[0]=(((r).mmu_xq12[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_MMU_XQ12m_IMIRRORf_GET(r) ((((r).mmu_xq12[0]) >> 18) & 0x1)
#define BCM56218_A0_MMU_XQ12m_IMIRRORf_SET(r,f) (r).mmu_xq12[0]=(((r).mmu_xq12[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_MMU_XQ12m_EMIRRORf_GET(r) ((((r).mmu_xq12[0]) >> 19) & 0x1)
#define BCM56218_A0_MMU_XQ12m_EMIRRORf_SET(r,f) (r).mmu_xq12[0]=(((r).mmu_xq12[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ12.
 *
 */
#define BCM56218_A0_READ_MMU_XQ12m(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_XQ12m,i,(m._mmu_xq12),1)
#define BCM56218_A0_WRITE_MMU_XQ12m(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_XQ12m,i,&(m._mmu_xq12),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ12m BCM56218_A0_MMU_XQ12m
#define MMU_XQ12m_MIN BCM56218_A0_MMU_XQ12m_MIN
#define MMU_XQ12m_MAX BCM56218_A0_MMU_XQ12m_MAX
#define MMU_XQ12m_CMAX(u) BCM56218_A0_MMU_XQ12m_CMAX(u)
#define MMU_XQ12m_SIZE BCM56218_A0_MMU_XQ12m_SIZE
typedef BCM56218_A0_MMU_XQ12m_t MMU_XQ12m_t;
#define MMU_XQ12m_CLR BCM56218_A0_MMU_XQ12m_CLR
#define MMU_XQ12m_SET BCM56218_A0_MMU_XQ12m_SET
#define MMU_XQ12m_GET BCM56218_A0_MMU_XQ12m_GET
#define MMU_XQ12m_PARITY_0f_GET BCM56218_A0_MMU_XQ12m_PARITY_0f_GET
#define MMU_XQ12m_PARITY_0f_SET BCM56218_A0_MMU_XQ12m_PARITY_0f_SET
#define MMU_XQ12m_L2f_GET BCM56218_A0_MMU_XQ12m_L2f_GET
#define MMU_XQ12m_L2f_SET BCM56218_A0_MMU_XQ12m_L2f_SET
#define MMU_XQ12m_PURGEf_GET BCM56218_A0_MMU_XQ12m_PURGEf_GET
#define MMU_XQ12m_PURGEf_SET BCM56218_A0_MMU_XQ12m_PURGEf_SET
#define MMU_XQ12m_PKT_PTRf_GET BCM56218_A0_MMU_XQ12m_PKT_PTRf_GET
#define MMU_XQ12m_PKT_PTRf_SET BCM56218_A0_MMU_XQ12m_PKT_PTRf_SET
#define MMU_XQ12m_RESERVED_0f_GET BCM56218_A0_MMU_XQ12m_RESERVED_0f_GET
#define MMU_XQ12m_RESERVED_0f_SET BCM56218_A0_MMU_XQ12m_RESERVED_0f_SET
#define MMU_XQ12m_IMIRRORf_GET BCM56218_A0_MMU_XQ12m_IMIRRORf_GET
#define MMU_XQ12m_IMIRRORf_SET BCM56218_A0_MMU_XQ12m_IMIRRORf_SET
#define MMU_XQ12m_EMIRRORf_GET BCM56218_A0_MMU_XQ12m_EMIRRORf_GET
#define MMU_XQ12m_EMIRRORf_SET BCM56218_A0_MMU_XQ12m_EMIRRORf_SET
#define READ_MMU_XQ12m BCM56218_A0_READ_MMU_XQ12m
#define WRITE_MMU_XQ12m BCM56218_A0_WRITE_MMU_XQ12m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_XQ12m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_XQ13
 * BLOCKS:   MMU
 * DESC:     XQ13
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     RESERVED_0       reserved for future use
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_XQ13m 0x0b634000

#define BCM56218_A0_MMU_XQ13m_MIN 0
#define BCM56218_A0_MMU_XQ13m_MAX 511
#define BCM56218_A0_MMU_XQ13m_CMAX(u) 511
#define BCM56218_A0_MMU_XQ13m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ13.
 *
 */
typedef union BCM56218_A0_MMU_XQ13m_s {
	uint32_t v[1];
	uint32_t mmu_xq13[1];
	uint32_t _mmu_xq13;
} BCM56218_A0_MMU_XQ13m_t;

#define BCM56218_A0_MMU_XQ13m_CLR(r) (r).mmu_xq13[0] = 0
#define BCM56218_A0_MMU_XQ13m_SET(r,d) (r).mmu_xq13[0] = d
#define BCM56218_A0_MMU_XQ13m_GET(r) (r).mmu_xq13[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_XQ13m_PARITY_0f_GET(r) (((r).mmu_xq13[0]) & 0x1)
#define BCM56218_A0_MMU_XQ13m_PARITY_0f_SET(r,f) (r).mmu_xq13[0]=(((r).mmu_xq13[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_MMU_XQ13m_L2f_GET(r) ((((r).mmu_xq13[0]) >> 1) & 0x1)
#define BCM56218_A0_MMU_XQ13m_L2f_SET(r,f) (r).mmu_xq13[0]=(((r).mmu_xq13[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_MMU_XQ13m_PURGEf_GET(r) ((((r).mmu_xq13[0]) >> 2) & 0x1)
#define BCM56218_A0_MMU_XQ13m_PURGEf_SET(r,f) (r).mmu_xq13[0]=(((r).mmu_xq13[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_MMU_XQ13m_PKT_PTRf_GET(r) ((((r).mmu_xq13[0]) >> 3) & 0x3fff)
#define BCM56218_A0_MMU_XQ13m_PKT_PTRf_SET(r,f) (r).mmu_xq13[0]=(((r).mmu_xq13[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56218_A0_MMU_XQ13m_RESERVED_0f_GET(r) ((((r).mmu_xq13[0]) >> 17) & 0x1)
#define BCM56218_A0_MMU_XQ13m_RESERVED_0f_SET(r,f) (r).mmu_xq13[0]=(((r).mmu_xq13[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_MMU_XQ13m_IMIRRORf_GET(r) ((((r).mmu_xq13[0]) >> 18) & 0x1)
#define BCM56218_A0_MMU_XQ13m_IMIRRORf_SET(r,f) (r).mmu_xq13[0]=(((r).mmu_xq13[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_MMU_XQ13m_EMIRRORf_GET(r) ((((r).mmu_xq13[0]) >> 19) & 0x1)
#define BCM56218_A0_MMU_XQ13m_EMIRRORf_SET(r,f) (r).mmu_xq13[0]=(((r).mmu_xq13[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ13.
 *
 */
#define BCM56218_A0_READ_MMU_XQ13m(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_XQ13m,i,(m._mmu_xq13),1)
#define BCM56218_A0_WRITE_MMU_XQ13m(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_XQ13m,i,&(m._mmu_xq13),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ13m BCM56218_A0_MMU_XQ13m
#define MMU_XQ13m_MIN BCM56218_A0_MMU_XQ13m_MIN
#define MMU_XQ13m_MAX BCM56218_A0_MMU_XQ13m_MAX
#define MMU_XQ13m_CMAX(u) BCM56218_A0_MMU_XQ13m_CMAX(u)
#define MMU_XQ13m_SIZE BCM56218_A0_MMU_XQ13m_SIZE
typedef BCM56218_A0_MMU_XQ13m_t MMU_XQ13m_t;
#define MMU_XQ13m_CLR BCM56218_A0_MMU_XQ13m_CLR
#define MMU_XQ13m_SET BCM56218_A0_MMU_XQ13m_SET
#define MMU_XQ13m_GET BCM56218_A0_MMU_XQ13m_GET
#define MMU_XQ13m_PARITY_0f_GET BCM56218_A0_MMU_XQ13m_PARITY_0f_GET
#define MMU_XQ13m_PARITY_0f_SET BCM56218_A0_MMU_XQ13m_PARITY_0f_SET
#define MMU_XQ13m_L2f_GET BCM56218_A0_MMU_XQ13m_L2f_GET
#define MMU_XQ13m_L2f_SET BCM56218_A0_MMU_XQ13m_L2f_SET
#define MMU_XQ13m_PURGEf_GET BCM56218_A0_MMU_XQ13m_PURGEf_GET
#define MMU_XQ13m_PURGEf_SET BCM56218_A0_MMU_XQ13m_PURGEf_SET
#define MMU_XQ13m_PKT_PTRf_GET BCM56218_A0_MMU_XQ13m_PKT_PTRf_GET
#define MMU_XQ13m_PKT_PTRf_SET BCM56218_A0_MMU_XQ13m_PKT_PTRf_SET
#define MMU_XQ13m_RESERVED_0f_GET BCM56218_A0_MMU_XQ13m_RESERVED_0f_GET
#define MMU_XQ13m_RESERVED_0f_SET BCM56218_A0_MMU_XQ13m_RESERVED_0f_SET
#define MMU_XQ13m_IMIRRORf_GET BCM56218_A0_MMU_XQ13m_IMIRRORf_GET
#define MMU_XQ13m_IMIRRORf_SET BCM56218_A0_MMU_XQ13m_IMIRRORf_SET
#define MMU_XQ13m_EMIRRORf_GET BCM56218_A0_MMU_XQ13m_EMIRRORf_GET
#define MMU_XQ13m_EMIRRORf_SET BCM56218_A0_MMU_XQ13m_EMIRRORf_SET
#define READ_MMU_XQ13m BCM56218_A0_READ_MMU_XQ13m
#define WRITE_MMU_XQ13m BCM56218_A0_WRITE_MMU_XQ13m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_XQ13m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_XQ14
 * BLOCKS:   MMU
 * DESC:     XQ14
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     RESERVED_0       reserved for future use
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_XQ14m 0x0b638000

#define BCM56218_A0_MMU_XQ14m_MIN 0
#define BCM56218_A0_MMU_XQ14m_MAX 511
#define BCM56218_A0_MMU_XQ14m_CMAX(u) 511
#define BCM56218_A0_MMU_XQ14m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ14.
 *
 */
typedef union BCM56218_A0_MMU_XQ14m_s {
	uint32_t v[1];
	uint32_t mmu_xq14[1];
	uint32_t _mmu_xq14;
} BCM56218_A0_MMU_XQ14m_t;

#define BCM56218_A0_MMU_XQ14m_CLR(r) (r).mmu_xq14[0] = 0
#define BCM56218_A0_MMU_XQ14m_SET(r,d) (r).mmu_xq14[0] = d
#define BCM56218_A0_MMU_XQ14m_GET(r) (r).mmu_xq14[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_XQ14m_PARITY_0f_GET(r) (((r).mmu_xq14[0]) & 0x1)
#define BCM56218_A0_MMU_XQ14m_PARITY_0f_SET(r,f) (r).mmu_xq14[0]=(((r).mmu_xq14[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_MMU_XQ14m_L2f_GET(r) ((((r).mmu_xq14[0]) >> 1) & 0x1)
#define BCM56218_A0_MMU_XQ14m_L2f_SET(r,f) (r).mmu_xq14[0]=(((r).mmu_xq14[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_MMU_XQ14m_PURGEf_GET(r) ((((r).mmu_xq14[0]) >> 2) & 0x1)
#define BCM56218_A0_MMU_XQ14m_PURGEf_SET(r,f) (r).mmu_xq14[0]=(((r).mmu_xq14[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_MMU_XQ14m_PKT_PTRf_GET(r) ((((r).mmu_xq14[0]) >> 3) & 0x3fff)
#define BCM56218_A0_MMU_XQ14m_PKT_PTRf_SET(r,f) (r).mmu_xq14[0]=(((r).mmu_xq14[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56218_A0_MMU_XQ14m_RESERVED_0f_GET(r) ((((r).mmu_xq14[0]) >> 17) & 0x1)
#define BCM56218_A0_MMU_XQ14m_RESERVED_0f_SET(r,f) (r).mmu_xq14[0]=(((r).mmu_xq14[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_MMU_XQ14m_IMIRRORf_GET(r) ((((r).mmu_xq14[0]) >> 18) & 0x1)
#define BCM56218_A0_MMU_XQ14m_IMIRRORf_SET(r,f) (r).mmu_xq14[0]=(((r).mmu_xq14[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_MMU_XQ14m_EMIRRORf_GET(r) ((((r).mmu_xq14[0]) >> 19) & 0x1)
#define BCM56218_A0_MMU_XQ14m_EMIRRORf_SET(r,f) (r).mmu_xq14[0]=(((r).mmu_xq14[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ14.
 *
 */
#define BCM56218_A0_READ_MMU_XQ14m(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_XQ14m,i,(m._mmu_xq14),1)
#define BCM56218_A0_WRITE_MMU_XQ14m(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_XQ14m,i,&(m._mmu_xq14),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ14m BCM56218_A0_MMU_XQ14m
#define MMU_XQ14m_MIN BCM56218_A0_MMU_XQ14m_MIN
#define MMU_XQ14m_MAX BCM56218_A0_MMU_XQ14m_MAX
#define MMU_XQ14m_CMAX(u) BCM56218_A0_MMU_XQ14m_CMAX(u)
#define MMU_XQ14m_SIZE BCM56218_A0_MMU_XQ14m_SIZE
typedef BCM56218_A0_MMU_XQ14m_t MMU_XQ14m_t;
#define MMU_XQ14m_CLR BCM56218_A0_MMU_XQ14m_CLR
#define MMU_XQ14m_SET BCM56218_A0_MMU_XQ14m_SET
#define MMU_XQ14m_GET BCM56218_A0_MMU_XQ14m_GET
#define MMU_XQ14m_PARITY_0f_GET BCM56218_A0_MMU_XQ14m_PARITY_0f_GET
#define MMU_XQ14m_PARITY_0f_SET BCM56218_A0_MMU_XQ14m_PARITY_0f_SET
#define MMU_XQ14m_L2f_GET BCM56218_A0_MMU_XQ14m_L2f_GET
#define MMU_XQ14m_L2f_SET BCM56218_A0_MMU_XQ14m_L2f_SET
#define MMU_XQ14m_PURGEf_GET BCM56218_A0_MMU_XQ14m_PURGEf_GET
#define MMU_XQ14m_PURGEf_SET BCM56218_A0_MMU_XQ14m_PURGEf_SET
#define MMU_XQ14m_PKT_PTRf_GET BCM56218_A0_MMU_XQ14m_PKT_PTRf_GET
#define MMU_XQ14m_PKT_PTRf_SET BCM56218_A0_MMU_XQ14m_PKT_PTRf_SET
#define MMU_XQ14m_RESERVED_0f_GET BCM56218_A0_MMU_XQ14m_RESERVED_0f_GET
#define MMU_XQ14m_RESERVED_0f_SET BCM56218_A0_MMU_XQ14m_RESERVED_0f_SET
#define MMU_XQ14m_IMIRRORf_GET BCM56218_A0_MMU_XQ14m_IMIRRORf_GET
#define MMU_XQ14m_IMIRRORf_SET BCM56218_A0_MMU_XQ14m_IMIRRORf_SET
#define MMU_XQ14m_EMIRRORf_GET BCM56218_A0_MMU_XQ14m_EMIRRORf_GET
#define MMU_XQ14m_EMIRRORf_SET BCM56218_A0_MMU_XQ14m_EMIRRORf_SET
#define READ_MMU_XQ14m BCM56218_A0_READ_MMU_XQ14m
#define WRITE_MMU_XQ14m BCM56218_A0_WRITE_MMU_XQ14m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_XQ14m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_XQ15
 * BLOCKS:   MMU
 * DESC:     XQ15
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     RESERVED_0       reserved for future use
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_XQ15m 0x0b63c000

#define BCM56218_A0_MMU_XQ15m_MIN 0
#define BCM56218_A0_MMU_XQ15m_MAX 511
#define BCM56218_A0_MMU_XQ15m_CMAX(u) 511
#define BCM56218_A0_MMU_XQ15m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ15.
 *
 */
typedef union BCM56218_A0_MMU_XQ15m_s {
	uint32_t v[1];
	uint32_t mmu_xq15[1];
	uint32_t _mmu_xq15;
} BCM56218_A0_MMU_XQ15m_t;

#define BCM56218_A0_MMU_XQ15m_CLR(r) (r).mmu_xq15[0] = 0
#define BCM56218_A0_MMU_XQ15m_SET(r,d) (r).mmu_xq15[0] = d
#define BCM56218_A0_MMU_XQ15m_GET(r) (r).mmu_xq15[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_XQ15m_PARITY_0f_GET(r) (((r).mmu_xq15[0]) & 0x1)
#define BCM56218_A0_MMU_XQ15m_PARITY_0f_SET(r,f) (r).mmu_xq15[0]=(((r).mmu_xq15[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_MMU_XQ15m_L2f_GET(r) ((((r).mmu_xq15[0]) >> 1) & 0x1)
#define BCM56218_A0_MMU_XQ15m_L2f_SET(r,f) (r).mmu_xq15[0]=(((r).mmu_xq15[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_MMU_XQ15m_PURGEf_GET(r) ((((r).mmu_xq15[0]) >> 2) & 0x1)
#define BCM56218_A0_MMU_XQ15m_PURGEf_SET(r,f) (r).mmu_xq15[0]=(((r).mmu_xq15[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_MMU_XQ15m_PKT_PTRf_GET(r) ((((r).mmu_xq15[0]) >> 3) & 0x3fff)
#define BCM56218_A0_MMU_XQ15m_PKT_PTRf_SET(r,f) (r).mmu_xq15[0]=(((r).mmu_xq15[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56218_A0_MMU_XQ15m_RESERVED_0f_GET(r) ((((r).mmu_xq15[0]) >> 17) & 0x1)
#define BCM56218_A0_MMU_XQ15m_RESERVED_0f_SET(r,f) (r).mmu_xq15[0]=(((r).mmu_xq15[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_MMU_XQ15m_IMIRRORf_GET(r) ((((r).mmu_xq15[0]) >> 18) & 0x1)
#define BCM56218_A0_MMU_XQ15m_IMIRRORf_SET(r,f) (r).mmu_xq15[0]=(((r).mmu_xq15[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_MMU_XQ15m_EMIRRORf_GET(r) ((((r).mmu_xq15[0]) >> 19) & 0x1)
#define BCM56218_A0_MMU_XQ15m_EMIRRORf_SET(r,f) (r).mmu_xq15[0]=(((r).mmu_xq15[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ15.
 *
 */
#define BCM56218_A0_READ_MMU_XQ15m(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_XQ15m,i,(m._mmu_xq15),1)
#define BCM56218_A0_WRITE_MMU_XQ15m(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_XQ15m,i,&(m._mmu_xq15),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ15m BCM56218_A0_MMU_XQ15m
#define MMU_XQ15m_MIN BCM56218_A0_MMU_XQ15m_MIN
#define MMU_XQ15m_MAX BCM56218_A0_MMU_XQ15m_MAX
#define MMU_XQ15m_CMAX(u) BCM56218_A0_MMU_XQ15m_CMAX(u)
#define MMU_XQ15m_SIZE BCM56218_A0_MMU_XQ15m_SIZE
typedef BCM56218_A0_MMU_XQ15m_t MMU_XQ15m_t;
#define MMU_XQ15m_CLR BCM56218_A0_MMU_XQ15m_CLR
#define MMU_XQ15m_SET BCM56218_A0_MMU_XQ15m_SET
#define MMU_XQ15m_GET BCM56218_A0_MMU_XQ15m_GET
#define MMU_XQ15m_PARITY_0f_GET BCM56218_A0_MMU_XQ15m_PARITY_0f_GET
#define MMU_XQ15m_PARITY_0f_SET BCM56218_A0_MMU_XQ15m_PARITY_0f_SET
#define MMU_XQ15m_L2f_GET BCM56218_A0_MMU_XQ15m_L2f_GET
#define MMU_XQ15m_L2f_SET BCM56218_A0_MMU_XQ15m_L2f_SET
#define MMU_XQ15m_PURGEf_GET BCM56218_A0_MMU_XQ15m_PURGEf_GET
#define MMU_XQ15m_PURGEf_SET BCM56218_A0_MMU_XQ15m_PURGEf_SET
#define MMU_XQ15m_PKT_PTRf_GET BCM56218_A0_MMU_XQ15m_PKT_PTRf_GET
#define MMU_XQ15m_PKT_PTRf_SET BCM56218_A0_MMU_XQ15m_PKT_PTRf_SET
#define MMU_XQ15m_RESERVED_0f_GET BCM56218_A0_MMU_XQ15m_RESERVED_0f_GET
#define MMU_XQ15m_RESERVED_0f_SET BCM56218_A0_MMU_XQ15m_RESERVED_0f_SET
#define MMU_XQ15m_IMIRRORf_GET BCM56218_A0_MMU_XQ15m_IMIRRORf_GET
#define MMU_XQ15m_IMIRRORf_SET BCM56218_A0_MMU_XQ15m_IMIRRORf_SET
#define MMU_XQ15m_EMIRRORf_GET BCM56218_A0_MMU_XQ15m_EMIRRORf_GET
#define MMU_XQ15m_EMIRRORf_SET BCM56218_A0_MMU_XQ15m_EMIRRORf_SET
#define READ_MMU_XQ15m BCM56218_A0_READ_MMU_XQ15m
#define WRITE_MMU_XQ15m BCM56218_A0_WRITE_MMU_XQ15m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_XQ15m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_XQ16
 * BLOCKS:   MMU
 * DESC:     XQ16
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     RESERVED_0       reserved for future use
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_XQ16m 0x0b640000

#define BCM56218_A0_MMU_XQ16m_MIN 0
#define BCM56218_A0_MMU_XQ16m_MAX 511
#define BCM56218_A0_MMU_XQ16m_CMAX(u) 511
#define BCM56218_A0_MMU_XQ16m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ16.
 *
 */
typedef union BCM56218_A0_MMU_XQ16m_s {
	uint32_t v[1];
	uint32_t mmu_xq16[1];
	uint32_t _mmu_xq16;
} BCM56218_A0_MMU_XQ16m_t;

#define BCM56218_A0_MMU_XQ16m_CLR(r) (r).mmu_xq16[0] = 0
#define BCM56218_A0_MMU_XQ16m_SET(r,d) (r).mmu_xq16[0] = d
#define BCM56218_A0_MMU_XQ16m_GET(r) (r).mmu_xq16[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_XQ16m_PARITY_0f_GET(r) (((r).mmu_xq16[0]) & 0x1)
#define BCM56218_A0_MMU_XQ16m_PARITY_0f_SET(r,f) (r).mmu_xq16[0]=(((r).mmu_xq16[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_MMU_XQ16m_L2f_GET(r) ((((r).mmu_xq16[0]) >> 1) & 0x1)
#define BCM56218_A0_MMU_XQ16m_L2f_SET(r,f) (r).mmu_xq16[0]=(((r).mmu_xq16[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_MMU_XQ16m_PURGEf_GET(r) ((((r).mmu_xq16[0]) >> 2) & 0x1)
#define BCM56218_A0_MMU_XQ16m_PURGEf_SET(r,f) (r).mmu_xq16[0]=(((r).mmu_xq16[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_MMU_XQ16m_PKT_PTRf_GET(r) ((((r).mmu_xq16[0]) >> 3) & 0x3fff)
#define BCM56218_A0_MMU_XQ16m_PKT_PTRf_SET(r,f) (r).mmu_xq16[0]=(((r).mmu_xq16[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56218_A0_MMU_XQ16m_RESERVED_0f_GET(r) ((((r).mmu_xq16[0]) >> 17) & 0x1)
#define BCM56218_A0_MMU_XQ16m_RESERVED_0f_SET(r,f) (r).mmu_xq16[0]=(((r).mmu_xq16[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_MMU_XQ16m_IMIRRORf_GET(r) ((((r).mmu_xq16[0]) >> 18) & 0x1)
#define BCM56218_A0_MMU_XQ16m_IMIRRORf_SET(r,f) (r).mmu_xq16[0]=(((r).mmu_xq16[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_MMU_XQ16m_EMIRRORf_GET(r) ((((r).mmu_xq16[0]) >> 19) & 0x1)
#define BCM56218_A0_MMU_XQ16m_EMIRRORf_SET(r,f) (r).mmu_xq16[0]=(((r).mmu_xq16[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ16.
 *
 */
#define BCM56218_A0_READ_MMU_XQ16m(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_XQ16m,i,(m._mmu_xq16),1)
#define BCM56218_A0_WRITE_MMU_XQ16m(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_XQ16m,i,&(m._mmu_xq16),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ16m BCM56218_A0_MMU_XQ16m
#define MMU_XQ16m_MIN BCM56218_A0_MMU_XQ16m_MIN
#define MMU_XQ16m_MAX BCM56218_A0_MMU_XQ16m_MAX
#define MMU_XQ16m_CMAX(u) BCM56218_A0_MMU_XQ16m_CMAX(u)
#define MMU_XQ16m_SIZE BCM56218_A0_MMU_XQ16m_SIZE
typedef BCM56218_A0_MMU_XQ16m_t MMU_XQ16m_t;
#define MMU_XQ16m_CLR BCM56218_A0_MMU_XQ16m_CLR
#define MMU_XQ16m_SET BCM56218_A0_MMU_XQ16m_SET
#define MMU_XQ16m_GET BCM56218_A0_MMU_XQ16m_GET
#define MMU_XQ16m_PARITY_0f_GET BCM56218_A0_MMU_XQ16m_PARITY_0f_GET
#define MMU_XQ16m_PARITY_0f_SET BCM56218_A0_MMU_XQ16m_PARITY_0f_SET
#define MMU_XQ16m_L2f_GET BCM56218_A0_MMU_XQ16m_L2f_GET
#define MMU_XQ16m_L2f_SET BCM56218_A0_MMU_XQ16m_L2f_SET
#define MMU_XQ16m_PURGEf_GET BCM56218_A0_MMU_XQ16m_PURGEf_GET
#define MMU_XQ16m_PURGEf_SET BCM56218_A0_MMU_XQ16m_PURGEf_SET
#define MMU_XQ16m_PKT_PTRf_GET BCM56218_A0_MMU_XQ16m_PKT_PTRf_GET
#define MMU_XQ16m_PKT_PTRf_SET BCM56218_A0_MMU_XQ16m_PKT_PTRf_SET
#define MMU_XQ16m_RESERVED_0f_GET BCM56218_A0_MMU_XQ16m_RESERVED_0f_GET
#define MMU_XQ16m_RESERVED_0f_SET BCM56218_A0_MMU_XQ16m_RESERVED_0f_SET
#define MMU_XQ16m_IMIRRORf_GET BCM56218_A0_MMU_XQ16m_IMIRRORf_GET
#define MMU_XQ16m_IMIRRORf_SET BCM56218_A0_MMU_XQ16m_IMIRRORf_SET
#define MMU_XQ16m_EMIRRORf_GET BCM56218_A0_MMU_XQ16m_EMIRRORf_GET
#define MMU_XQ16m_EMIRRORf_SET BCM56218_A0_MMU_XQ16m_EMIRRORf_SET
#define READ_MMU_XQ16m BCM56218_A0_READ_MMU_XQ16m
#define WRITE_MMU_XQ16m BCM56218_A0_WRITE_MMU_XQ16m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_XQ16m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_XQ17
 * BLOCKS:   MMU
 * DESC:     XQ17
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     RESERVED_0       reserved for future use
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_XQ17m 0x0b644000

#define BCM56218_A0_MMU_XQ17m_MIN 0
#define BCM56218_A0_MMU_XQ17m_MAX 511
#define BCM56218_A0_MMU_XQ17m_CMAX(u) 511
#define BCM56218_A0_MMU_XQ17m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ17.
 *
 */
typedef union BCM56218_A0_MMU_XQ17m_s {
	uint32_t v[1];
	uint32_t mmu_xq17[1];
	uint32_t _mmu_xq17;
} BCM56218_A0_MMU_XQ17m_t;

#define BCM56218_A0_MMU_XQ17m_CLR(r) (r).mmu_xq17[0] = 0
#define BCM56218_A0_MMU_XQ17m_SET(r,d) (r).mmu_xq17[0] = d
#define BCM56218_A0_MMU_XQ17m_GET(r) (r).mmu_xq17[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_XQ17m_PARITY_0f_GET(r) (((r).mmu_xq17[0]) & 0x1)
#define BCM56218_A0_MMU_XQ17m_PARITY_0f_SET(r,f) (r).mmu_xq17[0]=(((r).mmu_xq17[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_MMU_XQ17m_L2f_GET(r) ((((r).mmu_xq17[0]) >> 1) & 0x1)
#define BCM56218_A0_MMU_XQ17m_L2f_SET(r,f) (r).mmu_xq17[0]=(((r).mmu_xq17[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_MMU_XQ17m_PURGEf_GET(r) ((((r).mmu_xq17[0]) >> 2) & 0x1)
#define BCM56218_A0_MMU_XQ17m_PURGEf_SET(r,f) (r).mmu_xq17[0]=(((r).mmu_xq17[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_MMU_XQ17m_PKT_PTRf_GET(r) ((((r).mmu_xq17[0]) >> 3) & 0x3fff)
#define BCM56218_A0_MMU_XQ17m_PKT_PTRf_SET(r,f) (r).mmu_xq17[0]=(((r).mmu_xq17[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56218_A0_MMU_XQ17m_RESERVED_0f_GET(r) ((((r).mmu_xq17[0]) >> 17) & 0x1)
#define BCM56218_A0_MMU_XQ17m_RESERVED_0f_SET(r,f) (r).mmu_xq17[0]=(((r).mmu_xq17[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_MMU_XQ17m_IMIRRORf_GET(r) ((((r).mmu_xq17[0]) >> 18) & 0x1)
#define BCM56218_A0_MMU_XQ17m_IMIRRORf_SET(r,f) (r).mmu_xq17[0]=(((r).mmu_xq17[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_MMU_XQ17m_EMIRRORf_GET(r) ((((r).mmu_xq17[0]) >> 19) & 0x1)
#define BCM56218_A0_MMU_XQ17m_EMIRRORf_SET(r,f) (r).mmu_xq17[0]=(((r).mmu_xq17[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ17.
 *
 */
#define BCM56218_A0_READ_MMU_XQ17m(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_XQ17m,i,(m._mmu_xq17),1)
#define BCM56218_A0_WRITE_MMU_XQ17m(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_XQ17m,i,&(m._mmu_xq17),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ17m BCM56218_A0_MMU_XQ17m
#define MMU_XQ17m_MIN BCM56218_A0_MMU_XQ17m_MIN
#define MMU_XQ17m_MAX BCM56218_A0_MMU_XQ17m_MAX
#define MMU_XQ17m_CMAX(u) BCM56218_A0_MMU_XQ17m_CMAX(u)
#define MMU_XQ17m_SIZE BCM56218_A0_MMU_XQ17m_SIZE
typedef BCM56218_A0_MMU_XQ17m_t MMU_XQ17m_t;
#define MMU_XQ17m_CLR BCM56218_A0_MMU_XQ17m_CLR
#define MMU_XQ17m_SET BCM56218_A0_MMU_XQ17m_SET
#define MMU_XQ17m_GET BCM56218_A0_MMU_XQ17m_GET
#define MMU_XQ17m_PARITY_0f_GET BCM56218_A0_MMU_XQ17m_PARITY_0f_GET
#define MMU_XQ17m_PARITY_0f_SET BCM56218_A0_MMU_XQ17m_PARITY_0f_SET
#define MMU_XQ17m_L2f_GET BCM56218_A0_MMU_XQ17m_L2f_GET
#define MMU_XQ17m_L2f_SET BCM56218_A0_MMU_XQ17m_L2f_SET
#define MMU_XQ17m_PURGEf_GET BCM56218_A0_MMU_XQ17m_PURGEf_GET
#define MMU_XQ17m_PURGEf_SET BCM56218_A0_MMU_XQ17m_PURGEf_SET
#define MMU_XQ17m_PKT_PTRf_GET BCM56218_A0_MMU_XQ17m_PKT_PTRf_GET
#define MMU_XQ17m_PKT_PTRf_SET BCM56218_A0_MMU_XQ17m_PKT_PTRf_SET
#define MMU_XQ17m_RESERVED_0f_GET BCM56218_A0_MMU_XQ17m_RESERVED_0f_GET
#define MMU_XQ17m_RESERVED_0f_SET BCM56218_A0_MMU_XQ17m_RESERVED_0f_SET
#define MMU_XQ17m_IMIRRORf_GET BCM56218_A0_MMU_XQ17m_IMIRRORf_GET
#define MMU_XQ17m_IMIRRORf_SET BCM56218_A0_MMU_XQ17m_IMIRRORf_SET
#define MMU_XQ17m_EMIRRORf_GET BCM56218_A0_MMU_XQ17m_EMIRRORf_GET
#define MMU_XQ17m_EMIRRORf_SET BCM56218_A0_MMU_XQ17m_EMIRRORf_SET
#define READ_MMU_XQ17m BCM56218_A0_READ_MMU_XQ17m
#define WRITE_MMU_XQ17m BCM56218_A0_WRITE_MMU_XQ17m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_XQ17m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_XQ18
 * BLOCKS:   MMU
 * DESC:     XQ18
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     RESERVED_0       reserved for future use
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_XQ18m 0x0b648000

#define BCM56218_A0_MMU_XQ18m_MIN 0
#define BCM56218_A0_MMU_XQ18m_MAX 511
#define BCM56218_A0_MMU_XQ18m_CMAX(u) 511
#define BCM56218_A0_MMU_XQ18m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ18.
 *
 */
typedef union BCM56218_A0_MMU_XQ18m_s {
	uint32_t v[1];
	uint32_t mmu_xq18[1];
	uint32_t _mmu_xq18;
} BCM56218_A0_MMU_XQ18m_t;

#define BCM56218_A0_MMU_XQ18m_CLR(r) (r).mmu_xq18[0] = 0
#define BCM56218_A0_MMU_XQ18m_SET(r,d) (r).mmu_xq18[0] = d
#define BCM56218_A0_MMU_XQ18m_GET(r) (r).mmu_xq18[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_XQ18m_PARITY_0f_GET(r) (((r).mmu_xq18[0]) & 0x1)
#define BCM56218_A0_MMU_XQ18m_PARITY_0f_SET(r,f) (r).mmu_xq18[0]=(((r).mmu_xq18[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_MMU_XQ18m_L2f_GET(r) ((((r).mmu_xq18[0]) >> 1) & 0x1)
#define BCM56218_A0_MMU_XQ18m_L2f_SET(r,f) (r).mmu_xq18[0]=(((r).mmu_xq18[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_MMU_XQ18m_PURGEf_GET(r) ((((r).mmu_xq18[0]) >> 2) & 0x1)
#define BCM56218_A0_MMU_XQ18m_PURGEf_SET(r,f) (r).mmu_xq18[0]=(((r).mmu_xq18[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_MMU_XQ18m_PKT_PTRf_GET(r) ((((r).mmu_xq18[0]) >> 3) & 0x3fff)
#define BCM56218_A0_MMU_XQ18m_PKT_PTRf_SET(r,f) (r).mmu_xq18[0]=(((r).mmu_xq18[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56218_A0_MMU_XQ18m_RESERVED_0f_GET(r) ((((r).mmu_xq18[0]) >> 17) & 0x1)
#define BCM56218_A0_MMU_XQ18m_RESERVED_0f_SET(r,f) (r).mmu_xq18[0]=(((r).mmu_xq18[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_MMU_XQ18m_IMIRRORf_GET(r) ((((r).mmu_xq18[0]) >> 18) & 0x1)
#define BCM56218_A0_MMU_XQ18m_IMIRRORf_SET(r,f) (r).mmu_xq18[0]=(((r).mmu_xq18[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_MMU_XQ18m_EMIRRORf_GET(r) ((((r).mmu_xq18[0]) >> 19) & 0x1)
#define BCM56218_A0_MMU_XQ18m_EMIRRORf_SET(r,f) (r).mmu_xq18[0]=(((r).mmu_xq18[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ18.
 *
 */
#define BCM56218_A0_READ_MMU_XQ18m(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_XQ18m,i,(m._mmu_xq18),1)
#define BCM56218_A0_WRITE_MMU_XQ18m(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_XQ18m,i,&(m._mmu_xq18),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ18m BCM56218_A0_MMU_XQ18m
#define MMU_XQ18m_MIN BCM56218_A0_MMU_XQ18m_MIN
#define MMU_XQ18m_MAX BCM56218_A0_MMU_XQ18m_MAX
#define MMU_XQ18m_CMAX(u) BCM56218_A0_MMU_XQ18m_CMAX(u)
#define MMU_XQ18m_SIZE BCM56218_A0_MMU_XQ18m_SIZE
typedef BCM56218_A0_MMU_XQ18m_t MMU_XQ18m_t;
#define MMU_XQ18m_CLR BCM56218_A0_MMU_XQ18m_CLR
#define MMU_XQ18m_SET BCM56218_A0_MMU_XQ18m_SET
#define MMU_XQ18m_GET BCM56218_A0_MMU_XQ18m_GET
#define MMU_XQ18m_PARITY_0f_GET BCM56218_A0_MMU_XQ18m_PARITY_0f_GET
#define MMU_XQ18m_PARITY_0f_SET BCM56218_A0_MMU_XQ18m_PARITY_0f_SET
#define MMU_XQ18m_L2f_GET BCM56218_A0_MMU_XQ18m_L2f_GET
#define MMU_XQ18m_L2f_SET BCM56218_A0_MMU_XQ18m_L2f_SET
#define MMU_XQ18m_PURGEf_GET BCM56218_A0_MMU_XQ18m_PURGEf_GET
#define MMU_XQ18m_PURGEf_SET BCM56218_A0_MMU_XQ18m_PURGEf_SET
#define MMU_XQ18m_PKT_PTRf_GET BCM56218_A0_MMU_XQ18m_PKT_PTRf_GET
#define MMU_XQ18m_PKT_PTRf_SET BCM56218_A0_MMU_XQ18m_PKT_PTRf_SET
#define MMU_XQ18m_RESERVED_0f_GET BCM56218_A0_MMU_XQ18m_RESERVED_0f_GET
#define MMU_XQ18m_RESERVED_0f_SET BCM56218_A0_MMU_XQ18m_RESERVED_0f_SET
#define MMU_XQ18m_IMIRRORf_GET BCM56218_A0_MMU_XQ18m_IMIRRORf_GET
#define MMU_XQ18m_IMIRRORf_SET BCM56218_A0_MMU_XQ18m_IMIRRORf_SET
#define MMU_XQ18m_EMIRRORf_GET BCM56218_A0_MMU_XQ18m_EMIRRORf_GET
#define MMU_XQ18m_EMIRRORf_SET BCM56218_A0_MMU_XQ18m_EMIRRORf_SET
#define READ_MMU_XQ18m BCM56218_A0_READ_MMU_XQ18m
#define WRITE_MMU_XQ18m BCM56218_A0_WRITE_MMU_XQ18m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_XQ18m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_XQ19
 * BLOCKS:   MMU
 * DESC:     XQ19
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     RESERVED_0       reserved for future use
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_XQ19m 0x0b64c000

#define BCM56218_A0_MMU_XQ19m_MIN 0
#define BCM56218_A0_MMU_XQ19m_MAX 511
#define BCM56218_A0_MMU_XQ19m_CMAX(u) 511
#define BCM56218_A0_MMU_XQ19m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ19.
 *
 */
typedef union BCM56218_A0_MMU_XQ19m_s {
	uint32_t v[1];
	uint32_t mmu_xq19[1];
	uint32_t _mmu_xq19;
} BCM56218_A0_MMU_XQ19m_t;

#define BCM56218_A0_MMU_XQ19m_CLR(r) (r).mmu_xq19[0] = 0
#define BCM56218_A0_MMU_XQ19m_SET(r,d) (r).mmu_xq19[0] = d
#define BCM56218_A0_MMU_XQ19m_GET(r) (r).mmu_xq19[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_XQ19m_PARITY_0f_GET(r) (((r).mmu_xq19[0]) & 0x1)
#define BCM56218_A0_MMU_XQ19m_PARITY_0f_SET(r,f) (r).mmu_xq19[0]=(((r).mmu_xq19[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_MMU_XQ19m_L2f_GET(r) ((((r).mmu_xq19[0]) >> 1) & 0x1)
#define BCM56218_A0_MMU_XQ19m_L2f_SET(r,f) (r).mmu_xq19[0]=(((r).mmu_xq19[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_MMU_XQ19m_PURGEf_GET(r) ((((r).mmu_xq19[0]) >> 2) & 0x1)
#define BCM56218_A0_MMU_XQ19m_PURGEf_SET(r,f) (r).mmu_xq19[0]=(((r).mmu_xq19[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_MMU_XQ19m_PKT_PTRf_GET(r) ((((r).mmu_xq19[0]) >> 3) & 0x3fff)
#define BCM56218_A0_MMU_XQ19m_PKT_PTRf_SET(r,f) (r).mmu_xq19[0]=(((r).mmu_xq19[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56218_A0_MMU_XQ19m_RESERVED_0f_GET(r) ((((r).mmu_xq19[0]) >> 17) & 0x1)
#define BCM56218_A0_MMU_XQ19m_RESERVED_0f_SET(r,f) (r).mmu_xq19[0]=(((r).mmu_xq19[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_MMU_XQ19m_IMIRRORf_GET(r) ((((r).mmu_xq19[0]) >> 18) & 0x1)
#define BCM56218_A0_MMU_XQ19m_IMIRRORf_SET(r,f) (r).mmu_xq19[0]=(((r).mmu_xq19[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_MMU_XQ19m_EMIRRORf_GET(r) ((((r).mmu_xq19[0]) >> 19) & 0x1)
#define BCM56218_A0_MMU_XQ19m_EMIRRORf_SET(r,f) (r).mmu_xq19[0]=(((r).mmu_xq19[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ19.
 *
 */
#define BCM56218_A0_READ_MMU_XQ19m(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_XQ19m,i,(m._mmu_xq19),1)
#define BCM56218_A0_WRITE_MMU_XQ19m(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_XQ19m,i,&(m._mmu_xq19),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ19m BCM56218_A0_MMU_XQ19m
#define MMU_XQ19m_MIN BCM56218_A0_MMU_XQ19m_MIN
#define MMU_XQ19m_MAX BCM56218_A0_MMU_XQ19m_MAX
#define MMU_XQ19m_CMAX(u) BCM56218_A0_MMU_XQ19m_CMAX(u)
#define MMU_XQ19m_SIZE BCM56218_A0_MMU_XQ19m_SIZE
typedef BCM56218_A0_MMU_XQ19m_t MMU_XQ19m_t;
#define MMU_XQ19m_CLR BCM56218_A0_MMU_XQ19m_CLR
#define MMU_XQ19m_SET BCM56218_A0_MMU_XQ19m_SET
#define MMU_XQ19m_GET BCM56218_A0_MMU_XQ19m_GET
#define MMU_XQ19m_PARITY_0f_GET BCM56218_A0_MMU_XQ19m_PARITY_0f_GET
#define MMU_XQ19m_PARITY_0f_SET BCM56218_A0_MMU_XQ19m_PARITY_0f_SET
#define MMU_XQ19m_L2f_GET BCM56218_A0_MMU_XQ19m_L2f_GET
#define MMU_XQ19m_L2f_SET BCM56218_A0_MMU_XQ19m_L2f_SET
#define MMU_XQ19m_PURGEf_GET BCM56218_A0_MMU_XQ19m_PURGEf_GET
#define MMU_XQ19m_PURGEf_SET BCM56218_A0_MMU_XQ19m_PURGEf_SET
#define MMU_XQ19m_PKT_PTRf_GET BCM56218_A0_MMU_XQ19m_PKT_PTRf_GET
#define MMU_XQ19m_PKT_PTRf_SET BCM56218_A0_MMU_XQ19m_PKT_PTRf_SET
#define MMU_XQ19m_RESERVED_0f_GET BCM56218_A0_MMU_XQ19m_RESERVED_0f_GET
#define MMU_XQ19m_RESERVED_0f_SET BCM56218_A0_MMU_XQ19m_RESERVED_0f_SET
#define MMU_XQ19m_IMIRRORf_GET BCM56218_A0_MMU_XQ19m_IMIRRORf_GET
#define MMU_XQ19m_IMIRRORf_SET BCM56218_A0_MMU_XQ19m_IMIRRORf_SET
#define MMU_XQ19m_EMIRRORf_GET BCM56218_A0_MMU_XQ19m_EMIRRORf_GET
#define MMU_XQ19m_EMIRRORf_SET BCM56218_A0_MMU_XQ19m_EMIRRORf_SET
#define READ_MMU_XQ19m BCM56218_A0_READ_MMU_XQ19m
#define WRITE_MMU_XQ19m BCM56218_A0_WRITE_MMU_XQ19m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_XQ19m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_XQ2
 * BLOCKS:   MMU
 * DESC:     XQ2
 * SIZE:     123
 * FIELDS:
 *     PARITY_0         Parity bit 0
 *     PARITY0_DATA     parity0 data
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     RESERVED_0       reserved for future use
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *     MTP_INDEX        Mirror-to-Port Index
 *     RESERVED_1       reserved for future use
 *     MH_OPCODE_OVERLAY Module Header OPCode
 *     CLASSIFICATION_TAG Calssification TAG
 *     HEADER_TYPE      Module Header Type
 *     PARITY_1         Parity bit 1
 *     MODULE_HEADER    extra Module Header information.
 *     PARITY1_DATA     parity1 data
 *     CLASSIFICATION_TAG_HI Packet COS
 *     SRC_MODID        Packet COS
 *     DESTINATION      Packet COS
 *     SRC_PORT_TGID    Packet COS
 *     MCST             Packet COS
 *     VC_LABEL         Packet COS
 *     LBID             Packet COS
 *     RESERVED_2       reserved for future use
 *     HDR_EXT_OVERLAY  hdr ext overlay
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_XQ2m 0x0b608000

#define BCM56218_A0_MMU_XQ2m_MIN 0
#define BCM56218_A0_MMU_XQ2m_MAX 767
#define BCM56218_A0_MMU_XQ2m_CMAX(u) 767
#define BCM56218_A0_MMU_XQ2m_SIZE 16

/*
 * This structure should be used to declare and program MMU_XQ2.
 *
 */
typedef union BCM56218_A0_MMU_XQ2m_s {
	uint32_t v[4];
	uint32_t mmu_xq2[4];
	uint32_t _mmu_xq2;
} BCM56218_A0_MMU_XQ2m_t;

#define BCM56218_A0_MMU_XQ2m_CLR(r) CDK_MEMSET(&((r)._mmu_xq2), 0, sizeof(BCM56218_A0_MMU_XQ2m_t))
#define BCM56218_A0_MMU_XQ2m_SET(r,i,d) (r).mmu_xq2[i] = d
#define BCM56218_A0_MMU_XQ2m_GET(r,i) (r).mmu_xq2[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_XQ2m_PARITY_0f_GET(r) (((r).mmu_xq2[0]) & 0x1)
#define BCM56218_A0_MMU_XQ2m_PARITY_0f_SET(r,f) (r).mmu_xq2[0]=(((r).mmu_xq2[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_MMU_XQ2m_PARITY0_DATAf_GET(r,a) cdk_field_get((r).mmu_xq2,1,50,a)
#define BCM56218_A0_MMU_XQ2m_PARITY0_DATAf_SET(r,a) cdk_field_set((r).mmu_xq2,1,50,a)
#define BCM56218_A0_MMU_XQ2m_L2f_GET(r) ((((r).mmu_xq2[0]) >> 1) & 0x1)
#define BCM56218_A0_MMU_XQ2m_L2f_SET(r,f) (r).mmu_xq2[0]=(((r).mmu_xq2[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_MMU_XQ2m_PURGEf_GET(r) ((((r).mmu_xq2[0]) >> 2) & 0x1)
#define BCM56218_A0_MMU_XQ2m_PURGEf_SET(r,f) (r).mmu_xq2[0]=(((r).mmu_xq2[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_MMU_XQ2m_PKT_PTRf_GET(r) ((((r).mmu_xq2[0]) >> 3) & 0x3fff)
#define BCM56218_A0_MMU_XQ2m_PKT_PTRf_SET(r,f) (r).mmu_xq2[0]=(((r).mmu_xq2[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56218_A0_MMU_XQ2m_RESERVED_0f_GET(r) ((((r).mmu_xq2[0]) >> 17) & 0x1)
#define BCM56218_A0_MMU_XQ2m_RESERVED_0f_SET(r,f) (r).mmu_xq2[0]=(((r).mmu_xq2[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_MMU_XQ2m_IMIRRORf_GET(r) ((((r).mmu_xq2[0]) >> 18) & 0x1)
#define BCM56218_A0_MMU_XQ2m_IMIRRORf_SET(r,f) (r).mmu_xq2[0]=(((r).mmu_xq2[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_MMU_XQ2m_EMIRRORf_GET(r) ((((r).mmu_xq2[0]) >> 19) & 0x1)
#define BCM56218_A0_MMU_XQ2m_EMIRRORf_SET(r,f) (r).mmu_xq2[0]=(((r).mmu_xq2[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56218_A0_MMU_XQ2m_MTP_INDEXf_GET(r) ((((r).mmu_xq2[0]) >> 20) & 0x7f)
#define BCM56218_A0_MMU_XQ2m_MTP_INDEXf_SET(r,f) (r).mmu_xq2[0]=(((r).mmu_xq2[0] & ~((uint32_t)0x7f << 20)) | ((((uint32_t)f) & 0x7f) << 20))
#define BCM56218_A0_MMU_XQ2m_RESERVED_1f_GET(r) ((((r).mmu_xq2[0]) >> 27) & 0x3)
#define BCM56218_A0_MMU_XQ2m_RESERVED_1f_SET(r,f) (r).mmu_xq2[0]=(((r).mmu_xq2[0] & ~((uint32_t)0x3 << 27)) | ((((uint32_t)f) & 0x3) << 27))
#define BCM56218_A0_MMU_XQ2m_MH_OPCODE_OVERLAYf_GET(r) cdk_field32_get((r).mmu_xq2,29,36)
#define BCM56218_A0_MMU_XQ2m_MH_OPCODE_OVERLAYf_SET(r,f) cdk_field32_set((r).mmu_xq2,29,36,f)
#define BCM56218_A0_MMU_XQ2m_CLASSIFICATION_TAGf_GET(r) ((((r).mmu_xq2[1]) >> 5) & 0x7ff)
#define BCM56218_A0_MMU_XQ2m_CLASSIFICATION_TAGf_SET(r,f) (r).mmu_xq2[1]=(((r).mmu_xq2[1] & ~((uint32_t)0x7ff << 5)) | ((((uint32_t)f) & 0x7ff) << 5))
#define BCM56218_A0_MMU_XQ2m_HEADER_TYPEf_GET(r) ((((r).mmu_xq2[1]) >> 16) & 0x7)
#define BCM56218_A0_MMU_XQ2m_HEADER_TYPEf_SET(r,f) (r).mmu_xq2[1]=(((r).mmu_xq2[1] & ~((uint32_t)0x7 << 16)) | ((((uint32_t)f) & 0x7) << 16))
#define BCM56218_A0_MMU_XQ2m_PARITY_1f_GET(r) ((((r).mmu_xq2[1]) >> 19) & 0x1)
#define BCM56218_A0_MMU_XQ2m_PARITY_1f_SET(r,f) (r).mmu_xq2[1]=(((r).mmu_xq2[1] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56218_A0_MMU_XQ2m_MODULE_HEADERf_GET(r,a) cdk_field_get((r).mmu_xq2,52,122,a)
#define BCM56218_A0_MMU_XQ2m_MODULE_HEADERf_SET(r,a) cdk_field_set((r).mmu_xq2,52,122,a)
#define BCM56218_A0_MMU_XQ2m_PARITY1_DATAf_GET(r,a) cdk_field_get((r).mmu_xq2,52,122,a)
#define BCM56218_A0_MMU_XQ2m_PARITY1_DATAf_SET(r,a) cdk_field_set((r).mmu_xq2,52,122,a)
#define BCM56218_A0_MMU_XQ2m_CLASSIFICATION_TAG_HIf_GET(r) ((((r).mmu_xq2[1]) >> 20) & 0x1f)
#define BCM56218_A0_MMU_XQ2m_CLASSIFICATION_TAG_HIf_SET(r,f) (r).mmu_xq2[1]=(((r).mmu_xq2[1] & ~((uint32_t)0x1f << 20)) | ((((uint32_t)f) & 0x1f) << 20))
#define BCM56218_A0_MMU_XQ2m_SRC_MODIDf_GET(r) cdk_field32_get((r).mmu_xq2,57,64)
#define BCM56218_A0_MMU_XQ2m_SRC_MODIDf_SET(r,f) cdk_field32_set((r).mmu_xq2,57,64,f)
#define BCM56218_A0_MMU_XQ2m_DESTINATIONf_GET(r) ((((r).mmu_xq2[2]) >> 1) & 0xffff)
#define BCM56218_A0_MMU_XQ2m_DESTINATIONf_SET(r,f) (r).mmu_xq2[2]=(((r).mmu_xq2[2] & ~((uint32_t)0xffff << 1)) | ((((uint32_t)f) & 0xffff) << 1))
#define BCM56218_A0_MMU_XQ2m_SRC_PORT_TGIDf_GET(r) ((((r).mmu_xq2[2]) >> 17) & 0xff)
#define BCM56218_A0_MMU_XQ2m_SRC_PORT_TGIDf_SET(r,f) (r).mmu_xq2[2]=(((r).mmu_xq2[2] & ~((uint32_t)0xff << 17)) | ((((uint32_t)f) & 0xff) << 17))
#define BCM56218_A0_MMU_XQ2m_MCSTf_GET(r) ((((r).mmu_xq2[2]) >> 25) & 0x1)
#define BCM56218_A0_MMU_XQ2m_MCSTf_SET(r,f) (r).mmu_xq2[2]=(((r).mmu_xq2[2] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM56218_A0_MMU_XQ2m_VC_LABELf_GET(r) cdk_field32_get((r).mmu_xq2,90,105)
#define BCM56218_A0_MMU_XQ2m_VC_LABELf_SET(r,f) cdk_field32_set((r).mmu_xq2,90,105,f)
#define BCM56218_A0_MMU_XQ2m_LBIDf_GET(r) ((((r).mmu_xq2[3]) >> 10) & 0xff)
#define BCM56218_A0_MMU_XQ2m_LBIDf_SET(r,f) (r).mmu_xq2[3]=(((r).mmu_xq2[3] & ~((uint32_t)0xff << 10)) | ((((uint32_t)f) & 0xff) << 10))
#define BCM56218_A0_MMU_XQ2m_RESERVED_2f_GET(r) ((((r).mmu_xq2[3]) >> 18) & 0x1)
#define BCM56218_A0_MMU_XQ2m_RESERVED_2f_SET(r,f) (r).mmu_xq2[3]=(((r).mmu_xq2[3] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_MMU_XQ2m_HDR_EXT_OVERLAYf_GET(r) ((((r).mmu_xq2[3]) >> 19) & 0xff)
#define BCM56218_A0_MMU_XQ2m_HDR_EXT_OVERLAYf_SET(r,f) (r).mmu_xq2[3]=(((r).mmu_xq2[3] & ~((uint32_t)0xff << 19)) | ((((uint32_t)f) & 0xff) << 19))

/*
 * These macros can be used to access MMU_XQ2.
 *
 */
#define BCM56218_A0_READ_MMU_XQ2m(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_XQ2m,i,(m._mmu_xq2),4)
#define BCM56218_A0_WRITE_MMU_XQ2m(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_XQ2m,i,&(m._mmu_xq2),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ2m BCM56218_A0_MMU_XQ2m
#define MMU_XQ2m_MIN BCM56218_A0_MMU_XQ2m_MIN
#define MMU_XQ2m_MAX BCM56218_A0_MMU_XQ2m_MAX
#define MMU_XQ2m_CMAX(u) BCM56218_A0_MMU_XQ2m_CMAX(u)
#define MMU_XQ2m_SIZE BCM56218_A0_MMU_XQ2m_SIZE
typedef BCM56218_A0_MMU_XQ2m_t MMU_XQ2m_t;
#define MMU_XQ2m_CLR BCM56218_A0_MMU_XQ2m_CLR
#define MMU_XQ2m_SET BCM56218_A0_MMU_XQ2m_SET
#define MMU_XQ2m_GET BCM56218_A0_MMU_XQ2m_GET
#define MMU_XQ2m_PARITY_0f_GET BCM56218_A0_MMU_XQ2m_PARITY_0f_GET
#define MMU_XQ2m_PARITY_0f_SET BCM56218_A0_MMU_XQ2m_PARITY_0f_SET
#define MMU_XQ2m_PARITY0_DATAf_GET BCM56218_A0_MMU_XQ2m_PARITY0_DATAf_GET
#define MMU_XQ2m_PARITY0_DATAf_SET BCM56218_A0_MMU_XQ2m_PARITY0_DATAf_SET
#define MMU_XQ2m_L2f_GET BCM56218_A0_MMU_XQ2m_L2f_GET
#define MMU_XQ2m_L2f_SET BCM56218_A0_MMU_XQ2m_L2f_SET
#define MMU_XQ2m_PURGEf_GET BCM56218_A0_MMU_XQ2m_PURGEf_GET
#define MMU_XQ2m_PURGEf_SET BCM56218_A0_MMU_XQ2m_PURGEf_SET
#define MMU_XQ2m_PKT_PTRf_GET BCM56218_A0_MMU_XQ2m_PKT_PTRf_GET
#define MMU_XQ2m_PKT_PTRf_SET BCM56218_A0_MMU_XQ2m_PKT_PTRf_SET
#define MMU_XQ2m_RESERVED_0f_GET BCM56218_A0_MMU_XQ2m_RESERVED_0f_GET
#define MMU_XQ2m_RESERVED_0f_SET BCM56218_A0_MMU_XQ2m_RESERVED_0f_SET
#define MMU_XQ2m_IMIRRORf_GET BCM56218_A0_MMU_XQ2m_IMIRRORf_GET
#define MMU_XQ2m_IMIRRORf_SET BCM56218_A0_MMU_XQ2m_IMIRRORf_SET
#define MMU_XQ2m_EMIRRORf_GET BCM56218_A0_MMU_XQ2m_EMIRRORf_GET
#define MMU_XQ2m_EMIRRORf_SET BCM56218_A0_MMU_XQ2m_EMIRRORf_SET
#define MMU_XQ2m_MTP_INDEXf_GET BCM56218_A0_MMU_XQ2m_MTP_INDEXf_GET
#define MMU_XQ2m_MTP_INDEXf_SET BCM56218_A0_MMU_XQ2m_MTP_INDEXf_SET
#define MMU_XQ2m_RESERVED_1f_GET BCM56218_A0_MMU_XQ2m_RESERVED_1f_GET
#define MMU_XQ2m_RESERVED_1f_SET BCM56218_A0_MMU_XQ2m_RESERVED_1f_SET
#define MMU_XQ2m_MH_OPCODE_OVERLAYf_GET BCM56218_A0_MMU_XQ2m_MH_OPCODE_OVERLAYf_GET
#define MMU_XQ2m_MH_OPCODE_OVERLAYf_SET BCM56218_A0_MMU_XQ2m_MH_OPCODE_OVERLAYf_SET
#define MMU_XQ2m_CLASSIFICATION_TAGf_GET BCM56218_A0_MMU_XQ2m_CLASSIFICATION_TAGf_GET
#define MMU_XQ2m_CLASSIFICATION_TAGf_SET BCM56218_A0_MMU_XQ2m_CLASSIFICATION_TAGf_SET
#define MMU_XQ2m_HEADER_TYPEf_GET BCM56218_A0_MMU_XQ2m_HEADER_TYPEf_GET
#define MMU_XQ2m_HEADER_TYPEf_SET BCM56218_A0_MMU_XQ2m_HEADER_TYPEf_SET
#define MMU_XQ2m_PARITY_1f_GET BCM56218_A0_MMU_XQ2m_PARITY_1f_GET
#define MMU_XQ2m_PARITY_1f_SET BCM56218_A0_MMU_XQ2m_PARITY_1f_SET
#define MMU_XQ2m_MODULE_HEADERf_GET BCM56218_A0_MMU_XQ2m_MODULE_HEADERf_GET
#define MMU_XQ2m_MODULE_HEADERf_SET BCM56218_A0_MMU_XQ2m_MODULE_HEADERf_SET
#define MMU_XQ2m_PARITY1_DATAf_GET BCM56218_A0_MMU_XQ2m_PARITY1_DATAf_GET
#define MMU_XQ2m_PARITY1_DATAf_SET BCM56218_A0_MMU_XQ2m_PARITY1_DATAf_SET
#define MMU_XQ2m_CLASSIFICATION_TAG_HIf_GET BCM56218_A0_MMU_XQ2m_CLASSIFICATION_TAG_HIf_GET
#define MMU_XQ2m_CLASSIFICATION_TAG_HIf_SET BCM56218_A0_MMU_XQ2m_CLASSIFICATION_TAG_HIf_SET
#define MMU_XQ2m_SRC_MODIDf_GET BCM56218_A0_MMU_XQ2m_SRC_MODIDf_GET
#define MMU_XQ2m_SRC_MODIDf_SET BCM56218_A0_MMU_XQ2m_SRC_MODIDf_SET
#define MMU_XQ2m_DESTINATIONf_GET BCM56218_A0_MMU_XQ2m_DESTINATIONf_GET
#define MMU_XQ2m_DESTINATIONf_SET BCM56218_A0_MMU_XQ2m_DESTINATIONf_SET
#define MMU_XQ2m_SRC_PORT_TGIDf_GET BCM56218_A0_MMU_XQ2m_SRC_PORT_TGIDf_GET
#define MMU_XQ2m_SRC_PORT_TGIDf_SET BCM56218_A0_MMU_XQ2m_SRC_PORT_TGIDf_SET
#define MMU_XQ2m_MCSTf_GET BCM56218_A0_MMU_XQ2m_MCSTf_GET
#define MMU_XQ2m_MCSTf_SET BCM56218_A0_MMU_XQ2m_MCSTf_SET
#define MMU_XQ2m_VC_LABELf_GET BCM56218_A0_MMU_XQ2m_VC_LABELf_GET
#define MMU_XQ2m_VC_LABELf_SET BCM56218_A0_MMU_XQ2m_VC_LABELf_SET
#define MMU_XQ2m_LBIDf_GET BCM56218_A0_MMU_XQ2m_LBIDf_GET
#define MMU_XQ2m_LBIDf_SET BCM56218_A0_MMU_XQ2m_LBIDf_SET
#define MMU_XQ2m_RESERVED_2f_GET BCM56218_A0_MMU_XQ2m_RESERVED_2f_GET
#define MMU_XQ2m_RESERVED_2f_SET BCM56218_A0_MMU_XQ2m_RESERVED_2f_SET
#define MMU_XQ2m_HDR_EXT_OVERLAYf_GET BCM56218_A0_MMU_XQ2m_HDR_EXT_OVERLAYf_GET
#define MMU_XQ2m_HDR_EXT_OVERLAYf_SET BCM56218_A0_MMU_XQ2m_HDR_EXT_OVERLAYf_SET
#define READ_MMU_XQ2m BCM56218_A0_READ_MMU_XQ2m
#define WRITE_MMU_XQ2m BCM56218_A0_WRITE_MMU_XQ2m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_XQ2m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_XQ20
 * BLOCKS:   MMU
 * DESC:     XQ20
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     RESERVED_0       reserved for future use
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_XQ20m 0x0b650000

#define BCM56218_A0_MMU_XQ20m_MIN 0
#define BCM56218_A0_MMU_XQ20m_MAX 511
#define BCM56218_A0_MMU_XQ20m_CMAX(u) 511
#define BCM56218_A0_MMU_XQ20m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ20.
 *
 */
typedef union BCM56218_A0_MMU_XQ20m_s {
	uint32_t v[1];
	uint32_t mmu_xq20[1];
	uint32_t _mmu_xq20;
} BCM56218_A0_MMU_XQ20m_t;

#define BCM56218_A0_MMU_XQ20m_CLR(r) (r).mmu_xq20[0] = 0
#define BCM56218_A0_MMU_XQ20m_SET(r,d) (r).mmu_xq20[0] = d
#define BCM56218_A0_MMU_XQ20m_GET(r) (r).mmu_xq20[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_XQ20m_PARITY_0f_GET(r) (((r).mmu_xq20[0]) & 0x1)
#define BCM56218_A0_MMU_XQ20m_PARITY_0f_SET(r,f) (r).mmu_xq20[0]=(((r).mmu_xq20[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_MMU_XQ20m_L2f_GET(r) ((((r).mmu_xq20[0]) >> 1) & 0x1)
#define BCM56218_A0_MMU_XQ20m_L2f_SET(r,f) (r).mmu_xq20[0]=(((r).mmu_xq20[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_MMU_XQ20m_PURGEf_GET(r) ((((r).mmu_xq20[0]) >> 2) & 0x1)
#define BCM56218_A0_MMU_XQ20m_PURGEf_SET(r,f) (r).mmu_xq20[0]=(((r).mmu_xq20[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_MMU_XQ20m_PKT_PTRf_GET(r) ((((r).mmu_xq20[0]) >> 3) & 0x3fff)
#define BCM56218_A0_MMU_XQ20m_PKT_PTRf_SET(r,f) (r).mmu_xq20[0]=(((r).mmu_xq20[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56218_A0_MMU_XQ20m_RESERVED_0f_GET(r) ((((r).mmu_xq20[0]) >> 17) & 0x1)
#define BCM56218_A0_MMU_XQ20m_RESERVED_0f_SET(r,f) (r).mmu_xq20[0]=(((r).mmu_xq20[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_MMU_XQ20m_IMIRRORf_GET(r) ((((r).mmu_xq20[0]) >> 18) & 0x1)
#define BCM56218_A0_MMU_XQ20m_IMIRRORf_SET(r,f) (r).mmu_xq20[0]=(((r).mmu_xq20[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_MMU_XQ20m_EMIRRORf_GET(r) ((((r).mmu_xq20[0]) >> 19) & 0x1)
#define BCM56218_A0_MMU_XQ20m_EMIRRORf_SET(r,f) (r).mmu_xq20[0]=(((r).mmu_xq20[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ20.
 *
 */
#define BCM56218_A0_READ_MMU_XQ20m(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_XQ20m,i,(m._mmu_xq20),1)
#define BCM56218_A0_WRITE_MMU_XQ20m(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_XQ20m,i,&(m._mmu_xq20),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ20m BCM56218_A0_MMU_XQ20m
#define MMU_XQ20m_MIN BCM56218_A0_MMU_XQ20m_MIN
#define MMU_XQ20m_MAX BCM56218_A0_MMU_XQ20m_MAX
#define MMU_XQ20m_CMAX(u) BCM56218_A0_MMU_XQ20m_CMAX(u)
#define MMU_XQ20m_SIZE BCM56218_A0_MMU_XQ20m_SIZE
typedef BCM56218_A0_MMU_XQ20m_t MMU_XQ20m_t;
#define MMU_XQ20m_CLR BCM56218_A0_MMU_XQ20m_CLR
#define MMU_XQ20m_SET BCM56218_A0_MMU_XQ20m_SET
#define MMU_XQ20m_GET BCM56218_A0_MMU_XQ20m_GET
#define MMU_XQ20m_PARITY_0f_GET BCM56218_A0_MMU_XQ20m_PARITY_0f_GET
#define MMU_XQ20m_PARITY_0f_SET BCM56218_A0_MMU_XQ20m_PARITY_0f_SET
#define MMU_XQ20m_L2f_GET BCM56218_A0_MMU_XQ20m_L2f_GET
#define MMU_XQ20m_L2f_SET BCM56218_A0_MMU_XQ20m_L2f_SET
#define MMU_XQ20m_PURGEf_GET BCM56218_A0_MMU_XQ20m_PURGEf_GET
#define MMU_XQ20m_PURGEf_SET BCM56218_A0_MMU_XQ20m_PURGEf_SET
#define MMU_XQ20m_PKT_PTRf_GET BCM56218_A0_MMU_XQ20m_PKT_PTRf_GET
#define MMU_XQ20m_PKT_PTRf_SET BCM56218_A0_MMU_XQ20m_PKT_PTRf_SET
#define MMU_XQ20m_RESERVED_0f_GET BCM56218_A0_MMU_XQ20m_RESERVED_0f_GET
#define MMU_XQ20m_RESERVED_0f_SET BCM56218_A0_MMU_XQ20m_RESERVED_0f_SET
#define MMU_XQ20m_IMIRRORf_GET BCM56218_A0_MMU_XQ20m_IMIRRORf_GET
#define MMU_XQ20m_IMIRRORf_SET BCM56218_A0_MMU_XQ20m_IMIRRORf_SET
#define MMU_XQ20m_EMIRRORf_GET BCM56218_A0_MMU_XQ20m_EMIRRORf_GET
#define MMU_XQ20m_EMIRRORf_SET BCM56218_A0_MMU_XQ20m_EMIRRORf_SET
#define READ_MMU_XQ20m BCM56218_A0_READ_MMU_XQ20m
#define WRITE_MMU_XQ20m BCM56218_A0_WRITE_MMU_XQ20m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_XQ20m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_XQ21
 * BLOCKS:   MMU
 * DESC:     XQ21
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     RESERVED_0       reserved for future use
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_XQ21m 0x0b654000

#define BCM56218_A0_MMU_XQ21m_MIN 0
#define BCM56218_A0_MMU_XQ21m_MAX 511
#define BCM56218_A0_MMU_XQ21m_CMAX(u) 511
#define BCM56218_A0_MMU_XQ21m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ21.
 *
 */
typedef union BCM56218_A0_MMU_XQ21m_s {
	uint32_t v[1];
	uint32_t mmu_xq21[1];
	uint32_t _mmu_xq21;
} BCM56218_A0_MMU_XQ21m_t;

#define BCM56218_A0_MMU_XQ21m_CLR(r) (r).mmu_xq21[0] = 0
#define BCM56218_A0_MMU_XQ21m_SET(r,d) (r).mmu_xq21[0] = d
#define BCM56218_A0_MMU_XQ21m_GET(r) (r).mmu_xq21[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_XQ21m_PARITY_0f_GET(r) (((r).mmu_xq21[0]) & 0x1)
#define BCM56218_A0_MMU_XQ21m_PARITY_0f_SET(r,f) (r).mmu_xq21[0]=(((r).mmu_xq21[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_MMU_XQ21m_L2f_GET(r) ((((r).mmu_xq21[0]) >> 1) & 0x1)
#define BCM56218_A0_MMU_XQ21m_L2f_SET(r,f) (r).mmu_xq21[0]=(((r).mmu_xq21[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_MMU_XQ21m_PURGEf_GET(r) ((((r).mmu_xq21[0]) >> 2) & 0x1)
#define BCM56218_A0_MMU_XQ21m_PURGEf_SET(r,f) (r).mmu_xq21[0]=(((r).mmu_xq21[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_MMU_XQ21m_PKT_PTRf_GET(r) ((((r).mmu_xq21[0]) >> 3) & 0x3fff)
#define BCM56218_A0_MMU_XQ21m_PKT_PTRf_SET(r,f) (r).mmu_xq21[0]=(((r).mmu_xq21[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56218_A0_MMU_XQ21m_RESERVED_0f_GET(r) ((((r).mmu_xq21[0]) >> 17) & 0x1)
#define BCM56218_A0_MMU_XQ21m_RESERVED_0f_SET(r,f) (r).mmu_xq21[0]=(((r).mmu_xq21[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_MMU_XQ21m_IMIRRORf_GET(r) ((((r).mmu_xq21[0]) >> 18) & 0x1)
#define BCM56218_A0_MMU_XQ21m_IMIRRORf_SET(r,f) (r).mmu_xq21[0]=(((r).mmu_xq21[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_MMU_XQ21m_EMIRRORf_GET(r) ((((r).mmu_xq21[0]) >> 19) & 0x1)
#define BCM56218_A0_MMU_XQ21m_EMIRRORf_SET(r,f) (r).mmu_xq21[0]=(((r).mmu_xq21[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ21.
 *
 */
#define BCM56218_A0_READ_MMU_XQ21m(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_XQ21m,i,(m._mmu_xq21),1)
#define BCM56218_A0_WRITE_MMU_XQ21m(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_XQ21m,i,&(m._mmu_xq21),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ21m BCM56218_A0_MMU_XQ21m
#define MMU_XQ21m_MIN BCM56218_A0_MMU_XQ21m_MIN
#define MMU_XQ21m_MAX BCM56218_A0_MMU_XQ21m_MAX
#define MMU_XQ21m_CMAX(u) BCM56218_A0_MMU_XQ21m_CMAX(u)
#define MMU_XQ21m_SIZE BCM56218_A0_MMU_XQ21m_SIZE
typedef BCM56218_A0_MMU_XQ21m_t MMU_XQ21m_t;
#define MMU_XQ21m_CLR BCM56218_A0_MMU_XQ21m_CLR
#define MMU_XQ21m_SET BCM56218_A0_MMU_XQ21m_SET
#define MMU_XQ21m_GET BCM56218_A0_MMU_XQ21m_GET
#define MMU_XQ21m_PARITY_0f_GET BCM56218_A0_MMU_XQ21m_PARITY_0f_GET
#define MMU_XQ21m_PARITY_0f_SET BCM56218_A0_MMU_XQ21m_PARITY_0f_SET
#define MMU_XQ21m_L2f_GET BCM56218_A0_MMU_XQ21m_L2f_GET
#define MMU_XQ21m_L2f_SET BCM56218_A0_MMU_XQ21m_L2f_SET
#define MMU_XQ21m_PURGEf_GET BCM56218_A0_MMU_XQ21m_PURGEf_GET
#define MMU_XQ21m_PURGEf_SET BCM56218_A0_MMU_XQ21m_PURGEf_SET
#define MMU_XQ21m_PKT_PTRf_GET BCM56218_A0_MMU_XQ21m_PKT_PTRf_GET
#define MMU_XQ21m_PKT_PTRf_SET BCM56218_A0_MMU_XQ21m_PKT_PTRf_SET
#define MMU_XQ21m_RESERVED_0f_GET BCM56218_A0_MMU_XQ21m_RESERVED_0f_GET
#define MMU_XQ21m_RESERVED_0f_SET BCM56218_A0_MMU_XQ21m_RESERVED_0f_SET
#define MMU_XQ21m_IMIRRORf_GET BCM56218_A0_MMU_XQ21m_IMIRRORf_GET
#define MMU_XQ21m_IMIRRORf_SET BCM56218_A0_MMU_XQ21m_IMIRRORf_SET
#define MMU_XQ21m_EMIRRORf_GET BCM56218_A0_MMU_XQ21m_EMIRRORf_GET
#define MMU_XQ21m_EMIRRORf_SET BCM56218_A0_MMU_XQ21m_EMIRRORf_SET
#define READ_MMU_XQ21m BCM56218_A0_READ_MMU_XQ21m
#define WRITE_MMU_XQ21m BCM56218_A0_WRITE_MMU_XQ21m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_XQ21m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_XQ22
 * BLOCKS:   MMU
 * DESC:     XQ22
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     RESERVED_0       reserved for future use
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_XQ22m 0x0b658000

#define BCM56218_A0_MMU_XQ22m_MIN 0
#define BCM56218_A0_MMU_XQ22m_MAX 511
#define BCM56218_A0_MMU_XQ22m_CMAX(u) 511
#define BCM56218_A0_MMU_XQ22m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ22.
 *
 */
typedef union BCM56218_A0_MMU_XQ22m_s {
	uint32_t v[1];
	uint32_t mmu_xq22[1];
	uint32_t _mmu_xq22;
} BCM56218_A0_MMU_XQ22m_t;

#define BCM56218_A0_MMU_XQ22m_CLR(r) (r).mmu_xq22[0] = 0
#define BCM56218_A0_MMU_XQ22m_SET(r,d) (r).mmu_xq22[0] = d
#define BCM56218_A0_MMU_XQ22m_GET(r) (r).mmu_xq22[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_XQ22m_PARITY_0f_GET(r) (((r).mmu_xq22[0]) & 0x1)
#define BCM56218_A0_MMU_XQ22m_PARITY_0f_SET(r,f) (r).mmu_xq22[0]=(((r).mmu_xq22[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_MMU_XQ22m_L2f_GET(r) ((((r).mmu_xq22[0]) >> 1) & 0x1)
#define BCM56218_A0_MMU_XQ22m_L2f_SET(r,f) (r).mmu_xq22[0]=(((r).mmu_xq22[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_MMU_XQ22m_PURGEf_GET(r) ((((r).mmu_xq22[0]) >> 2) & 0x1)
#define BCM56218_A0_MMU_XQ22m_PURGEf_SET(r,f) (r).mmu_xq22[0]=(((r).mmu_xq22[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_MMU_XQ22m_PKT_PTRf_GET(r) ((((r).mmu_xq22[0]) >> 3) & 0x3fff)
#define BCM56218_A0_MMU_XQ22m_PKT_PTRf_SET(r,f) (r).mmu_xq22[0]=(((r).mmu_xq22[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56218_A0_MMU_XQ22m_RESERVED_0f_GET(r) ((((r).mmu_xq22[0]) >> 17) & 0x1)
#define BCM56218_A0_MMU_XQ22m_RESERVED_0f_SET(r,f) (r).mmu_xq22[0]=(((r).mmu_xq22[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_MMU_XQ22m_IMIRRORf_GET(r) ((((r).mmu_xq22[0]) >> 18) & 0x1)
#define BCM56218_A0_MMU_XQ22m_IMIRRORf_SET(r,f) (r).mmu_xq22[0]=(((r).mmu_xq22[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_MMU_XQ22m_EMIRRORf_GET(r) ((((r).mmu_xq22[0]) >> 19) & 0x1)
#define BCM56218_A0_MMU_XQ22m_EMIRRORf_SET(r,f) (r).mmu_xq22[0]=(((r).mmu_xq22[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ22.
 *
 */
#define BCM56218_A0_READ_MMU_XQ22m(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_XQ22m,i,(m._mmu_xq22),1)
#define BCM56218_A0_WRITE_MMU_XQ22m(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_XQ22m,i,&(m._mmu_xq22),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ22m BCM56218_A0_MMU_XQ22m
#define MMU_XQ22m_MIN BCM56218_A0_MMU_XQ22m_MIN
#define MMU_XQ22m_MAX BCM56218_A0_MMU_XQ22m_MAX
#define MMU_XQ22m_CMAX(u) BCM56218_A0_MMU_XQ22m_CMAX(u)
#define MMU_XQ22m_SIZE BCM56218_A0_MMU_XQ22m_SIZE
typedef BCM56218_A0_MMU_XQ22m_t MMU_XQ22m_t;
#define MMU_XQ22m_CLR BCM56218_A0_MMU_XQ22m_CLR
#define MMU_XQ22m_SET BCM56218_A0_MMU_XQ22m_SET
#define MMU_XQ22m_GET BCM56218_A0_MMU_XQ22m_GET
#define MMU_XQ22m_PARITY_0f_GET BCM56218_A0_MMU_XQ22m_PARITY_0f_GET
#define MMU_XQ22m_PARITY_0f_SET BCM56218_A0_MMU_XQ22m_PARITY_0f_SET
#define MMU_XQ22m_L2f_GET BCM56218_A0_MMU_XQ22m_L2f_GET
#define MMU_XQ22m_L2f_SET BCM56218_A0_MMU_XQ22m_L2f_SET
#define MMU_XQ22m_PURGEf_GET BCM56218_A0_MMU_XQ22m_PURGEf_GET
#define MMU_XQ22m_PURGEf_SET BCM56218_A0_MMU_XQ22m_PURGEf_SET
#define MMU_XQ22m_PKT_PTRf_GET BCM56218_A0_MMU_XQ22m_PKT_PTRf_GET
#define MMU_XQ22m_PKT_PTRf_SET BCM56218_A0_MMU_XQ22m_PKT_PTRf_SET
#define MMU_XQ22m_RESERVED_0f_GET BCM56218_A0_MMU_XQ22m_RESERVED_0f_GET
#define MMU_XQ22m_RESERVED_0f_SET BCM56218_A0_MMU_XQ22m_RESERVED_0f_SET
#define MMU_XQ22m_IMIRRORf_GET BCM56218_A0_MMU_XQ22m_IMIRRORf_GET
#define MMU_XQ22m_IMIRRORf_SET BCM56218_A0_MMU_XQ22m_IMIRRORf_SET
#define MMU_XQ22m_EMIRRORf_GET BCM56218_A0_MMU_XQ22m_EMIRRORf_GET
#define MMU_XQ22m_EMIRRORf_SET BCM56218_A0_MMU_XQ22m_EMIRRORf_SET
#define READ_MMU_XQ22m BCM56218_A0_READ_MMU_XQ22m
#define WRITE_MMU_XQ22m BCM56218_A0_WRITE_MMU_XQ22m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_XQ22m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_XQ23
 * BLOCKS:   MMU
 * DESC:     XQ23
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     RESERVED_0       reserved for future use
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_XQ23m 0x0b65c000

#define BCM56218_A0_MMU_XQ23m_MIN 0
#define BCM56218_A0_MMU_XQ23m_MAX 511
#define BCM56218_A0_MMU_XQ23m_CMAX(u) 511
#define BCM56218_A0_MMU_XQ23m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ23.
 *
 */
typedef union BCM56218_A0_MMU_XQ23m_s {
	uint32_t v[1];
	uint32_t mmu_xq23[1];
	uint32_t _mmu_xq23;
} BCM56218_A0_MMU_XQ23m_t;

#define BCM56218_A0_MMU_XQ23m_CLR(r) (r).mmu_xq23[0] = 0
#define BCM56218_A0_MMU_XQ23m_SET(r,d) (r).mmu_xq23[0] = d
#define BCM56218_A0_MMU_XQ23m_GET(r) (r).mmu_xq23[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_XQ23m_PARITY_0f_GET(r) (((r).mmu_xq23[0]) & 0x1)
#define BCM56218_A0_MMU_XQ23m_PARITY_0f_SET(r,f) (r).mmu_xq23[0]=(((r).mmu_xq23[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_MMU_XQ23m_L2f_GET(r) ((((r).mmu_xq23[0]) >> 1) & 0x1)
#define BCM56218_A0_MMU_XQ23m_L2f_SET(r,f) (r).mmu_xq23[0]=(((r).mmu_xq23[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_MMU_XQ23m_PURGEf_GET(r) ((((r).mmu_xq23[0]) >> 2) & 0x1)
#define BCM56218_A0_MMU_XQ23m_PURGEf_SET(r,f) (r).mmu_xq23[0]=(((r).mmu_xq23[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_MMU_XQ23m_PKT_PTRf_GET(r) ((((r).mmu_xq23[0]) >> 3) & 0x3fff)
#define BCM56218_A0_MMU_XQ23m_PKT_PTRf_SET(r,f) (r).mmu_xq23[0]=(((r).mmu_xq23[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56218_A0_MMU_XQ23m_RESERVED_0f_GET(r) ((((r).mmu_xq23[0]) >> 17) & 0x1)
#define BCM56218_A0_MMU_XQ23m_RESERVED_0f_SET(r,f) (r).mmu_xq23[0]=(((r).mmu_xq23[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_MMU_XQ23m_IMIRRORf_GET(r) ((((r).mmu_xq23[0]) >> 18) & 0x1)
#define BCM56218_A0_MMU_XQ23m_IMIRRORf_SET(r,f) (r).mmu_xq23[0]=(((r).mmu_xq23[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_MMU_XQ23m_EMIRRORf_GET(r) ((((r).mmu_xq23[0]) >> 19) & 0x1)
#define BCM56218_A0_MMU_XQ23m_EMIRRORf_SET(r,f) (r).mmu_xq23[0]=(((r).mmu_xq23[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ23.
 *
 */
#define BCM56218_A0_READ_MMU_XQ23m(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_XQ23m,i,(m._mmu_xq23),1)
#define BCM56218_A0_WRITE_MMU_XQ23m(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_XQ23m,i,&(m._mmu_xq23),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ23m BCM56218_A0_MMU_XQ23m
#define MMU_XQ23m_MIN BCM56218_A0_MMU_XQ23m_MIN
#define MMU_XQ23m_MAX BCM56218_A0_MMU_XQ23m_MAX
#define MMU_XQ23m_CMAX(u) BCM56218_A0_MMU_XQ23m_CMAX(u)
#define MMU_XQ23m_SIZE BCM56218_A0_MMU_XQ23m_SIZE
typedef BCM56218_A0_MMU_XQ23m_t MMU_XQ23m_t;
#define MMU_XQ23m_CLR BCM56218_A0_MMU_XQ23m_CLR
#define MMU_XQ23m_SET BCM56218_A0_MMU_XQ23m_SET
#define MMU_XQ23m_GET BCM56218_A0_MMU_XQ23m_GET
#define MMU_XQ23m_PARITY_0f_GET BCM56218_A0_MMU_XQ23m_PARITY_0f_GET
#define MMU_XQ23m_PARITY_0f_SET BCM56218_A0_MMU_XQ23m_PARITY_0f_SET
#define MMU_XQ23m_L2f_GET BCM56218_A0_MMU_XQ23m_L2f_GET
#define MMU_XQ23m_L2f_SET BCM56218_A0_MMU_XQ23m_L2f_SET
#define MMU_XQ23m_PURGEf_GET BCM56218_A0_MMU_XQ23m_PURGEf_GET
#define MMU_XQ23m_PURGEf_SET BCM56218_A0_MMU_XQ23m_PURGEf_SET
#define MMU_XQ23m_PKT_PTRf_GET BCM56218_A0_MMU_XQ23m_PKT_PTRf_GET
#define MMU_XQ23m_PKT_PTRf_SET BCM56218_A0_MMU_XQ23m_PKT_PTRf_SET
#define MMU_XQ23m_RESERVED_0f_GET BCM56218_A0_MMU_XQ23m_RESERVED_0f_GET
#define MMU_XQ23m_RESERVED_0f_SET BCM56218_A0_MMU_XQ23m_RESERVED_0f_SET
#define MMU_XQ23m_IMIRRORf_GET BCM56218_A0_MMU_XQ23m_IMIRRORf_GET
#define MMU_XQ23m_IMIRRORf_SET BCM56218_A0_MMU_XQ23m_IMIRRORf_SET
#define MMU_XQ23m_EMIRRORf_GET BCM56218_A0_MMU_XQ23m_EMIRRORf_GET
#define MMU_XQ23m_EMIRRORf_SET BCM56218_A0_MMU_XQ23m_EMIRRORf_SET
#define READ_MMU_XQ23m BCM56218_A0_READ_MMU_XQ23m
#define WRITE_MMU_XQ23m BCM56218_A0_WRITE_MMU_XQ23m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_XQ23m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_XQ24
 * BLOCKS:   MMU
 * DESC:     XQ24
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     RESERVED_0       reserved for future use
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_XQ24m 0x0b660000

#define BCM56218_A0_MMU_XQ24m_MIN 0
#define BCM56218_A0_MMU_XQ24m_MAX 511
#define BCM56218_A0_MMU_XQ24m_CMAX(u) 511
#define BCM56218_A0_MMU_XQ24m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ24.
 *
 */
typedef union BCM56218_A0_MMU_XQ24m_s {
	uint32_t v[1];
	uint32_t mmu_xq24[1];
	uint32_t _mmu_xq24;
} BCM56218_A0_MMU_XQ24m_t;

#define BCM56218_A0_MMU_XQ24m_CLR(r) (r).mmu_xq24[0] = 0
#define BCM56218_A0_MMU_XQ24m_SET(r,d) (r).mmu_xq24[0] = d
#define BCM56218_A0_MMU_XQ24m_GET(r) (r).mmu_xq24[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_XQ24m_PARITY_0f_GET(r) (((r).mmu_xq24[0]) & 0x1)
#define BCM56218_A0_MMU_XQ24m_PARITY_0f_SET(r,f) (r).mmu_xq24[0]=(((r).mmu_xq24[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_MMU_XQ24m_L2f_GET(r) ((((r).mmu_xq24[0]) >> 1) & 0x1)
#define BCM56218_A0_MMU_XQ24m_L2f_SET(r,f) (r).mmu_xq24[0]=(((r).mmu_xq24[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_MMU_XQ24m_PURGEf_GET(r) ((((r).mmu_xq24[0]) >> 2) & 0x1)
#define BCM56218_A0_MMU_XQ24m_PURGEf_SET(r,f) (r).mmu_xq24[0]=(((r).mmu_xq24[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_MMU_XQ24m_PKT_PTRf_GET(r) ((((r).mmu_xq24[0]) >> 3) & 0x3fff)
#define BCM56218_A0_MMU_XQ24m_PKT_PTRf_SET(r,f) (r).mmu_xq24[0]=(((r).mmu_xq24[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56218_A0_MMU_XQ24m_RESERVED_0f_GET(r) ((((r).mmu_xq24[0]) >> 17) & 0x1)
#define BCM56218_A0_MMU_XQ24m_RESERVED_0f_SET(r,f) (r).mmu_xq24[0]=(((r).mmu_xq24[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_MMU_XQ24m_IMIRRORf_GET(r) ((((r).mmu_xq24[0]) >> 18) & 0x1)
#define BCM56218_A0_MMU_XQ24m_IMIRRORf_SET(r,f) (r).mmu_xq24[0]=(((r).mmu_xq24[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_MMU_XQ24m_EMIRRORf_GET(r) ((((r).mmu_xq24[0]) >> 19) & 0x1)
#define BCM56218_A0_MMU_XQ24m_EMIRRORf_SET(r,f) (r).mmu_xq24[0]=(((r).mmu_xq24[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ24.
 *
 */
#define BCM56218_A0_READ_MMU_XQ24m(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_XQ24m,i,(m._mmu_xq24),1)
#define BCM56218_A0_WRITE_MMU_XQ24m(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_XQ24m,i,&(m._mmu_xq24),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ24m BCM56218_A0_MMU_XQ24m
#define MMU_XQ24m_MIN BCM56218_A0_MMU_XQ24m_MIN
#define MMU_XQ24m_MAX BCM56218_A0_MMU_XQ24m_MAX
#define MMU_XQ24m_CMAX(u) BCM56218_A0_MMU_XQ24m_CMAX(u)
#define MMU_XQ24m_SIZE BCM56218_A0_MMU_XQ24m_SIZE
typedef BCM56218_A0_MMU_XQ24m_t MMU_XQ24m_t;
#define MMU_XQ24m_CLR BCM56218_A0_MMU_XQ24m_CLR
#define MMU_XQ24m_SET BCM56218_A0_MMU_XQ24m_SET
#define MMU_XQ24m_GET BCM56218_A0_MMU_XQ24m_GET
#define MMU_XQ24m_PARITY_0f_GET BCM56218_A0_MMU_XQ24m_PARITY_0f_GET
#define MMU_XQ24m_PARITY_0f_SET BCM56218_A0_MMU_XQ24m_PARITY_0f_SET
#define MMU_XQ24m_L2f_GET BCM56218_A0_MMU_XQ24m_L2f_GET
#define MMU_XQ24m_L2f_SET BCM56218_A0_MMU_XQ24m_L2f_SET
#define MMU_XQ24m_PURGEf_GET BCM56218_A0_MMU_XQ24m_PURGEf_GET
#define MMU_XQ24m_PURGEf_SET BCM56218_A0_MMU_XQ24m_PURGEf_SET
#define MMU_XQ24m_PKT_PTRf_GET BCM56218_A0_MMU_XQ24m_PKT_PTRf_GET
#define MMU_XQ24m_PKT_PTRf_SET BCM56218_A0_MMU_XQ24m_PKT_PTRf_SET
#define MMU_XQ24m_RESERVED_0f_GET BCM56218_A0_MMU_XQ24m_RESERVED_0f_GET
#define MMU_XQ24m_RESERVED_0f_SET BCM56218_A0_MMU_XQ24m_RESERVED_0f_SET
#define MMU_XQ24m_IMIRRORf_GET BCM56218_A0_MMU_XQ24m_IMIRRORf_GET
#define MMU_XQ24m_IMIRRORf_SET BCM56218_A0_MMU_XQ24m_IMIRRORf_SET
#define MMU_XQ24m_EMIRRORf_GET BCM56218_A0_MMU_XQ24m_EMIRRORf_GET
#define MMU_XQ24m_EMIRRORf_SET BCM56218_A0_MMU_XQ24m_EMIRRORf_SET
#define READ_MMU_XQ24m BCM56218_A0_READ_MMU_XQ24m
#define WRITE_MMU_XQ24m BCM56218_A0_WRITE_MMU_XQ24m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_XQ24m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_XQ25
 * BLOCKS:   MMU
 * DESC:     XQ25
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     RESERVED_0       reserved for future use
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_XQ25m 0x0b664000

#define BCM56218_A0_MMU_XQ25m_MIN 0
#define BCM56218_A0_MMU_XQ25m_MAX 511
#define BCM56218_A0_MMU_XQ25m_CMAX(u) 511
#define BCM56218_A0_MMU_XQ25m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ25.
 *
 */
typedef union BCM56218_A0_MMU_XQ25m_s {
	uint32_t v[1];
	uint32_t mmu_xq25[1];
	uint32_t _mmu_xq25;
} BCM56218_A0_MMU_XQ25m_t;

#define BCM56218_A0_MMU_XQ25m_CLR(r) (r).mmu_xq25[0] = 0
#define BCM56218_A0_MMU_XQ25m_SET(r,d) (r).mmu_xq25[0] = d
#define BCM56218_A0_MMU_XQ25m_GET(r) (r).mmu_xq25[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_XQ25m_PARITY_0f_GET(r) (((r).mmu_xq25[0]) & 0x1)
#define BCM56218_A0_MMU_XQ25m_PARITY_0f_SET(r,f) (r).mmu_xq25[0]=(((r).mmu_xq25[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_MMU_XQ25m_L2f_GET(r) ((((r).mmu_xq25[0]) >> 1) & 0x1)
#define BCM56218_A0_MMU_XQ25m_L2f_SET(r,f) (r).mmu_xq25[0]=(((r).mmu_xq25[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_MMU_XQ25m_PURGEf_GET(r) ((((r).mmu_xq25[0]) >> 2) & 0x1)
#define BCM56218_A0_MMU_XQ25m_PURGEf_SET(r,f) (r).mmu_xq25[0]=(((r).mmu_xq25[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_MMU_XQ25m_PKT_PTRf_GET(r) ((((r).mmu_xq25[0]) >> 3) & 0x3fff)
#define BCM56218_A0_MMU_XQ25m_PKT_PTRf_SET(r,f) (r).mmu_xq25[0]=(((r).mmu_xq25[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56218_A0_MMU_XQ25m_RESERVED_0f_GET(r) ((((r).mmu_xq25[0]) >> 17) & 0x1)
#define BCM56218_A0_MMU_XQ25m_RESERVED_0f_SET(r,f) (r).mmu_xq25[0]=(((r).mmu_xq25[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_MMU_XQ25m_IMIRRORf_GET(r) ((((r).mmu_xq25[0]) >> 18) & 0x1)
#define BCM56218_A0_MMU_XQ25m_IMIRRORf_SET(r,f) (r).mmu_xq25[0]=(((r).mmu_xq25[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_MMU_XQ25m_EMIRRORf_GET(r) ((((r).mmu_xq25[0]) >> 19) & 0x1)
#define BCM56218_A0_MMU_XQ25m_EMIRRORf_SET(r,f) (r).mmu_xq25[0]=(((r).mmu_xq25[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ25.
 *
 */
#define BCM56218_A0_READ_MMU_XQ25m(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_XQ25m,i,(m._mmu_xq25),1)
#define BCM56218_A0_WRITE_MMU_XQ25m(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_XQ25m,i,&(m._mmu_xq25),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ25m BCM56218_A0_MMU_XQ25m
#define MMU_XQ25m_MIN BCM56218_A0_MMU_XQ25m_MIN
#define MMU_XQ25m_MAX BCM56218_A0_MMU_XQ25m_MAX
#define MMU_XQ25m_CMAX(u) BCM56218_A0_MMU_XQ25m_CMAX(u)
#define MMU_XQ25m_SIZE BCM56218_A0_MMU_XQ25m_SIZE
typedef BCM56218_A0_MMU_XQ25m_t MMU_XQ25m_t;
#define MMU_XQ25m_CLR BCM56218_A0_MMU_XQ25m_CLR
#define MMU_XQ25m_SET BCM56218_A0_MMU_XQ25m_SET
#define MMU_XQ25m_GET BCM56218_A0_MMU_XQ25m_GET
#define MMU_XQ25m_PARITY_0f_GET BCM56218_A0_MMU_XQ25m_PARITY_0f_GET
#define MMU_XQ25m_PARITY_0f_SET BCM56218_A0_MMU_XQ25m_PARITY_0f_SET
#define MMU_XQ25m_L2f_GET BCM56218_A0_MMU_XQ25m_L2f_GET
#define MMU_XQ25m_L2f_SET BCM56218_A0_MMU_XQ25m_L2f_SET
#define MMU_XQ25m_PURGEf_GET BCM56218_A0_MMU_XQ25m_PURGEf_GET
#define MMU_XQ25m_PURGEf_SET BCM56218_A0_MMU_XQ25m_PURGEf_SET
#define MMU_XQ25m_PKT_PTRf_GET BCM56218_A0_MMU_XQ25m_PKT_PTRf_GET
#define MMU_XQ25m_PKT_PTRf_SET BCM56218_A0_MMU_XQ25m_PKT_PTRf_SET
#define MMU_XQ25m_RESERVED_0f_GET BCM56218_A0_MMU_XQ25m_RESERVED_0f_GET
#define MMU_XQ25m_RESERVED_0f_SET BCM56218_A0_MMU_XQ25m_RESERVED_0f_SET
#define MMU_XQ25m_IMIRRORf_GET BCM56218_A0_MMU_XQ25m_IMIRRORf_GET
#define MMU_XQ25m_IMIRRORf_SET BCM56218_A0_MMU_XQ25m_IMIRRORf_SET
#define MMU_XQ25m_EMIRRORf_GET BCM56218_A0_MMU_XQ25m_EMIRRORf_GET
#define MMU_XQ25m_EMIRRORf_SET BCM56218_A0_MMU_XQ25m_EMIRRORf_SET
#define READ_MMU_XQ25m BCM56218_A0_READ_MMU_XQ25m
#define WRITE_MMU_XQ25m BCM56218_A0_WRITE_MMU_XQ25m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_XQ25m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_XQ26
 * BLOCKS:   MMU
 * DESC:     XQ26
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     RESERVED_0       reserved for future use
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_XQ26m 0x0b668000

#define BCM56218_A0_MMU_XQ26m_MIN 0
#define BCM56218_A0_MMU_XQ26m_MAX 511
#define BCM56218_A0_MMU_XQ26m_CMAX(u) 511
#define BCM56218_A0_MMU_XQ26m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ26.
 *
 */
typedef union BCM56218_A0_MMU_XQ26m_s {
	uint32_t v[1];
	uint32_t mmu_xq26[1];
	uint32_t _mmu_xq26;
} BCM56218_A0_MMU_XQ26m_t;

#define BCM56218_A0_MMU_XQ26m_CLR(r) (r).mmu_xq26[0] = 0
#define BCM56218_A0_MMU_XQ26m_SET(r,d) (r).mmu_xq26[0] = d
#define BCM56218_A0_MMU_XQ26m_GET(r) (r).mmu_xq26[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_XQ26m_PARITY_0f_GET(r) (((r).mmu_xq26[0]) & 0x1)
#define BCM56218_A0_MMU_XQ26m_PARITY_0f_SET(r,f) (r).mmu_xq26[0]=(((r).mmu_xq26[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_MMU_XQ26m_L2f_GET(r) ((((r).mmu_xq26[0]) >> 1) & 0x1)
#define BCM56218_A0_MMU_XQ26m_L2f_SET(r,f) (r).mmu_xq26[0]=(((r).mmu_xq26[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_MMU_XQ26m_PURGEf_GET(r) ((((r).mmu_xq26[0]) >> 2) & 0x1)
#define BCM56218_A0_MMU_XQ26m_PURGEf_SET(r,f) (r).mmu_xq26[0]=(((r).mmu_xq26[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_MMU_XQ26m_PKT_PTRf_GET(r) ((((r).mmu_xq26[0]) >> 3) & 0x3fff)
#define BCM56218_A0_MMU_XQ26m_PKT_PTRf_SET(r,f) (r).mmu_xq26[0]=(((r).mmu_xq26[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56218_A0_MMU_XQ26m_RESERVED_0f_GET(r) ((((r).mmu_xq26[0]) >> 17) & 0x1)
#define BCM56218_A0_MMU_XQ26m_RESERVED_0f_SET(r,f) (r).mmu_xq26[0]=(((r).mmu_xq26[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_MMU_XQ26m_IMIRRORf_GET(r) ((((r).mmu_xq26[0]) >> 18) & 0x1)
#define BCM56218_A0_MMU_XQ26m_IMIRRORf_SET(r,f) (r).mmu_xq26[0]=(((r).mmu_xq26[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_MMU_XQ26m_EMIRRORf_GET(r) ((((r).mmu_xq26[0]) >> 19) & 0x1)
#define BCM56218_A0_MMU_XQ26m_EMIRRORf_SET(r,f) (r).mmu_xq26[0]=(((r).mmu_xq26[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ26.
 *
 */
#define BCM56218_A0_READ_MMU_XQ26m(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_XQ26m,i,(m._mmu_xq26),1)
#define BCM56218_A0_WRITE_MMU_XQ26m(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_XQ26m,i,&(m._mmu_xq26),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ26m BCM56218_A0_MMU_XQ26m
#define MMU_XQ26m_MIN BCM56218_A0_MMU_XQ26m_MIN
#define MMU_XQ26m_MAX BCM56218_A0_MMU_XQ26m_MAX
#define MMU_XQ26m_CMAX(u) BCM56218_A0_MMU_XQ26m_CMAX(u)
#define MMU_XQ26m_SIZE BCM56218_A0_MMU_XQ26m_SIZE
typedef BCM56218_A0_MMU_XQ26m_t MMU_XQ26m_t;
#define MMU_XQ26m_CLR BCM56218_A0_MMU_XQ26m_CLR
#define MMU_XQ26m_SET BCM56218_A0_MMU_XQ26m_SET
#define MMU_XQ26m_GET BCM56218_A0_MMU_XQ26m_GET
#define MMU_XQ26m_PARITY_0f_GET BCM56218_A0_MMU_XQ26m_PARITY_0f_GET
#define MMU_XQ26m_PARITY_0f_SET BCM56218_A0_MMU_XQ26m_PARITY_0f_SET
#define MMU_XQ26m_L2f_GET BCM56218_A0_MMU_XQ26m_L2f_GET
#define MMU_XQ26m_L2f_SET BCM56218_A0_MMU_XQ26m_L2f_SET
#define MMU_XQ26m_PURGEf_GET BCM56218_A0_MMU_XQ26m_PURGEf_GET
#define MMU_XQ26m_PURGEf_SET BCM56218_A0_MMU_XQ26m_PURGEf_SET
#define MMU_XQ26m_PKT_PTRf_GET BCM56218_A0_MMU_XQ26m_PKT_PTRf_GET
#define MMU_XQ26m_PKT_PTRf_SET BCM56218_A0_MMU_XQ26m_PKT_PTRf_SET
#define MMU_XQ26m_RESERVED_0f_GET BCM56218_A0_MMU_XQ26m_RESERVED_0f_GET
#define MMU_XQ26m_RESERVED_0f_SET BCM56218_A0_MMU_XQ26m_RESERVED_0f_SET
#define MMU_XQ26m_IMIRRORf_GET BCM56218_A0_MMU_XQ26m_IMIRRORf_GET
#define MMU_XQ26m_IMIRRORf_SET BCM56218_A0_MMU_XQ26m_IMIRRORf_SET
#define MMU_XQ26m_EMIRRORf_GET BCM56218_A0_MMU_XQ26m_EMIRRORf_GET
#define MMU_XQ26m_EMIRRORf_SET BCM56218_A0_MMU_XQ26m_EMIRRORf_SET
#define READ_MMU_XQ26m BCM56218_A0_READ_MMU_XQ26m
#define WRITE_MMU_XQ26m BCM56218_A0_WRITE_MMU_XQ26m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_XQ26m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_XQ27
 * BLOCKS:   MMU
 * DESC:     XQ27
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     RESERVED_0       reserved for future use
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_XQ27m 0x0b66c000

#define BCM56218_A0_MMU_XQ27m_MIN 0
#define BCM56218_A0_MMU_XQ27m_MAX 511
#define BCM56218_A0_MMU_XQ27m_CMAX(u) 511
#define BCM56218_A0_MMU_XQ27m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ27.
 *
 */
typedef union BCM56218_A0_MMU_XQ27m_s {
	uint32_t v[1];
	uint32_t mmu_xq27[1];
	uint32_t _mmu_xq27;
} BCM56218_A0_MMU_XQ27m_t;

#define BCM56218_A0_MMU_XQ27m_CLR(r) (r).mmu_xq27[0] = 0
#define BCM56218_A0_MMU_XQ27m_SET(r,d) (r).mmu_xq27[0] = d
#define BCM56218_A0_MMU_XQ27m_GET(r) (r).mmu_xq27[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_XQ27m_PARITY_0f_GET(r) (((r).mmu_xq27[0]) & 0x1)
#define BCM56218_A0_MMU_XQ27m_PARITY_0f_SET(r,f) (r).mmu_xq27[0]=(((r).mmu_xq27[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_MMU_XQ27m_L2f_GET(r) ((((r).mmu_xq27[0]) >> 1) & 0x1)
#define BCM56218_A0_MMU_XQ27m_L2f_SET(r,f) (r).mmu_xq27[0]=(((r).mmu_xq27[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_MMU_XQ27m_PURGEf_GET(r) ((((r).mmu_xq27[0]) >> 2) & 0x1)
#define BCM56218_A0_MMU_XQ27m_PURGEf_SET(r,f) (r).mmu_xq27[0]=(((r).mmu_xq27[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_MMU_XQ27m_PKT_PTRf_GET(r) ((((r).mmu_xq27[0]) >> 3) & 0x3fff)
#define BCM56218_A0_MMU_XQ27m_PKT_PTRf_SET(r,f) (r).mmu_xq27[0]=(((r).mmu_xq27[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56218_A0_MMU_XQ27m_RESERVED_0f_GET(r) ((((r).mmu_xq27[0]) >> 17) & 0x1)
#define BCM56218_A0_MMU_XQ27m_RESERVED_0f_SET(r,f) (r).mmu_xq27[0]=(((r).mmu_xq27[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_MMU_XQ27m_IMIRRORf_GET(r) ((((r).mmu_xq27[0]) >> 18) & 0x1)
#define BCM56218_A0_MMU_XQ27m_IMIRRORf_SET(r,f) (r).mmu_xq27[0]=(((r).mmu_xq27[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_MMU_XQ27m_EMIRRORf_GET(r) ((((r).mmu_xq27[0]) >> 19) & 0x1)
#define BCM56218_A0_MMU_XQ27m_EMIRRORf_SET(r,f) (r).mmu_xq27[0]=(((r).mmu_xq27[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ27.
 *
 */
#define BCM56218_A0_READ_MMU_XQ27m(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_XQ27m,i,(m._mmu_xq27),1)
#define BCM56218_A0_WRITE_MMU_XQ27m(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_XQ27m,i,&(m._mmu_xq27),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ27m BCM56218_A0_MMU_XQ27m
#define MMU_XQ27m_MIN BCM56218_A0_MMU_XQ27m_MIN
#define MMU_XQ27m_MAX BCM56218_A0_MMU_XQ27m_MAX
#define MMU_XQ27m_CMAX(u) BCM56218_A0_MMU_XQ27m_CMAX(u)
#define MMU_XQ27m_SIZE BCM56218_A0_MMU_XQ27m_SIZE
typedef BCM56218_A0_MMU_XQ27m_t MMU_XQ27m_t;
#define MMU_XQ27m_CLR BCM56218_A0_MMU_XQ27m_CLR
#define MMU_XQ27m_SET BCM56218_A0_MMU_XQ27m_SET
#define MMU_XQ27m_GET BCM56218_A0_MMU_XQ27m_GET
#define MMU_XQ27m_PARITY_0f_GET BCM56218_A0_MMU_XQ27m_PARITY_0f_GET
#define MMU_XQ27m_PARITY_0f_SET BCM56218_A0_MMU_XQ27m_PARITY_0f_SET
#define MMU_XQ27m_L2f_GET BCM56218_A0_MMU_XQ27m_L2f_GET
#define MMU_XQ27m_L2f_SET BCM56218_A0_MMU_XQ27m_L2f_SET
#define MMU_XQ27m_PURGEf_GET BCM56218_A0_MMU_XQ27m_PURGEf_GET
#define MMU_XQ27m_PURGEf_SET BCM56218_A0_MMU_XQ27m_PURGEf_SET
#define MMU_XQ27m_PKT_PTRf_GET BCM56218_A0_MMU_XQ27m_PKT_PTRf_GET
#define MMU_XQ27m_PKT_PTRf_SET BCM56218_A0_MMU_XQ27m_PKT_PTRf_SET
#define MMU_XQ27m_RESERVED_0f_GET BCM56218_A0_MMU_XQ27m_RESERVED_0f_GET
#define MMU_XQ27m_RESERVED_0f_SET BCM56218_A0_MMU_XQ27m_RESERVED_0f_SET
#define MMU_XQ27m_IMIRRORf_GET BCM56218_A0_MMU_XQ27m_IMIRRORf_GET
#define MMU_XQ27m_IMIRRORf_SET BCM56218_A0_MMU_XQ27m_IMIRRORf_SET
#define MMU_XQ27m_EMIRRORf_GET BCM56218_A0_MMU_XQ27m_EMIRRORf_GET
#define MMU_XQ27m_EMIRRORf_SET BCM56218_A0_MMU_XQ27m_EMIRRORf_SET
#define READ_MMU_XQ27m BCM56218_A0_READ_MMU_XQ27m
#define WRITE_MMU_XQ27m BCM56218_A0_WRITE_MMU_XQ27m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_XQ27m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_XQ28
 * BLOCKS:   MMU
 * DESC:     XQ28
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     RESERVED_0       reserved for future use
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_XQ28m 0x0b670000

#define BCM56218_A0_MMU_XQ28m_MIN 0
#define BCM56218_A0_MMU_XQ28m_MAX 511
#define BCM56218_A0_MMU_XQ28m_CMAX(u) 511
#define BCM56218_A0_MMU_XQ28m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ28.
 *
 */
typedef union BCM56218_A0_MMU_XQ28m_s {
	uint32_t v[1];
	uint32_t mmu_xq28[1];
	uint32_t _mmu_xq28;
} BCM56218_A0_MMU_XQ28m_t;

#define BCM56218_A0_MMU_XQ28m_CLR(r) (r).mmu_xq28[0] = 0
#define BCM56218_A0_MMU_XQ28m_SET(r,d) (r).mmu_xq28[0] = d
#define BCM56218_A0_MMU_XQ28m_GET(r) (r).mmu_xq28[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_XQ28m_PARITY_0f_GET(r) (((r).mmu_xq28[0]) & 0x1)
#define BCM56218_A0_MMU_XQ28m_PARITY_0f_SET(r,f) (r).mmu_xq28[0]=(((r).mmu_xq28[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_MMU_XQ28m_L2f_GET(r) ((((r).mmu_xq28[0]) >> 1) & 0x1)
#define BCM56218_A0_MMU_XQ28m_L2f_SET(r,f) (r).mmu_xq28[0]=(((r).mmu_xq28[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_MMU_XQ28m_PURGEf_GET(r) ((((r).mmu_xq28[0]) >> 2) & 0x1)
#define BCM56218_A0_MMU_XQ28m_PURGEf_SET(r,f) (r).mmu_xq28[0]=(((r).mmu_xq28[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_MMU_XQ28m_PKT_PTRf_GET(r) ((((r).mmu_xq28[0]) >> 3) & 0x3fff)
#define BCM56218_A0_MMU_XQ28m_PKT_PTRf_SET(r,f) (r).mmu_xq28[0]=(((r).mmu_xq28[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56218_A0_MMU_XQ28m_RESERVED_0f_GET(r) ((((r).mmu_xq28[0]) >> 17) & 0x1)
#define BCM56218_A0_MMU_XQ28m_RESERVED_0f_SET(r,f) (r).mmu_xq28[0]=(((r).mmu_xq28[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_MMU_XQ28m_IMIRRORf_GET(r) ((((r).mmu_xq28[0]) >> 18) & 0x1)
#define BCM56218_A0_MMU_XQ28m_IMIRRORf_SET(r,f) (r).mmu_xq28[0]=(((r).mmu_xq28[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_MMU_XQ28m_EMIRRORf_GET(r) ((((r).mmu_xq28[0]) >> 19) & 0x1)
#define BCM56218_A0_MMU_XQ28m_EMIRRORf_SET(r,f) (r).mmu_xq28[0]=(((r).mmu_xq28[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ28.
 *
 */
#define BCM56218_A0_READ_MMU_XQ28m(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_XQ28m,i,(m._mmu_xq28),1)
#define BCM56218_A0_WRITE_MMU_XQ28m(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_XQ28m,i,&(m._mmu_xq28),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ28m BCM56218_A0_MMU_XQ28m
#define MMU_XQ28m_MIN BCM56218_A0_MMU_XQ28m_MIN
#define MMU_XQ28m_MAX BCM56218_A0_MMU_XQ28m_MAX
#define MMU_XQ28m_CMAX(u) BCM56218_A0_MMU_XQ28m_CMAX(u)
#define MMU_XQ28m_SIZE BCM56218_A0_MMU_XQ28m_SIZE
typedef BCM56218_A0_MMU_XQ28m_t MMU_XQ28m_t;
#define MMU_XQ28m_CLR BCM56218_A0_MMU_XQ28m_CLR
#define MMU_XQ28m_SET BCM56218_A0_MMU_XQ28m_SET
#define MMU_XQ28m_GET BCM56218_A0_MMU_XQ28m_GET
#define MMU_XQ28m_PARITY_0f_GET BCM56218_A0_MMU_XQ28m_PARITY_0f_GET
#define MMU_XQ28m_PARITY_0f_SET BCM56218_A0_MMU_XQ28m_PARITY_0f_SET
#define MMU_XQ28m_L2f_GET BCM56218_A0_MMU_XQ28m_L2f_GET
#define MMU_XQ28m_L2f_SET BCM56218_A0_MMU_XQ28m_L2f_SET
#define MMU_XQ28m_PURGEf_GET BCM56218_A0_MMU_XQ28m_PURGEf_GET
#define MMU_XQ28m_PURGEf_SET BCM56218_A0_MMU_XQ28m_PURGEf_SET
#define MMU_XQ28m_PKT_PTRf_GET BCM56218_A0_MMU_XQ28m_PKT_PTRf_GET
#define MMU_XQ28m_PKT_PTRf_SET BCM56218_A0_MMU_XQ28m_PKT_PTRf_SET
#define MMU_XQ28m_RESERVED_0f_GET BCM56218_A0_MMU_XQ28m_RESERVED_0f_GET
#define MMU_XQ28m_RESERVED_0f_SET BCM56218_A0_MMU_XQ28m_RESERVED_0f_SET
#define MMU_XQ28m_IMIRRORf_GET BCM56218_A0_MMU_XQ28m_IMIRRORf_GET
#define MMU_XQ28m_IMIRRORf_SET BCM56218_A0_MMU_XQ28m_IMIRRORf_SET
#define MMU_XQ28m_EMIRRORf_GET BCM56218_A0_MMU_XQ28m_EMIRRORf_GET
#define MMU_XQ28m_EMIRRORf_SET BCM56218_A0_MMU_XQ28m_EMIRRORf_SET
#define READ_MMU_XQ28m BCM56218_A0_READ_MMU_XQ28m
#define WRITE_MMU_XQ28m BCM56218_A0_WRITE_MMU_XQ28m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_XQ28m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_XQ29
 * BLOCKS:   MMU
 * DESC:     XQ29
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     RESERVED_0       reserved for future use
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_XQ29m 0x0b674000

#define BCM56218_A0_MMU_XQ29m_MIN 0
#define BCM56218_A0_MMU_XQ29m_MAX 511
#define BCM56218_A0_MMU_XQ29m_CMAX(u) 511
#define BCM56218_A0_MMU_XQ29m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ29.
 *
 */
typedef union BCM56218_A0_MMU_XQ29m_s {
	uint32_t v[1];
	uint32_t mmu_xq29[1];
	uint32_t _mmu_xq29;
} BCM56218_A0_MMU_XQ29m_t;

#define BCM56218_A0_MMU_XQ29m_CLR(r) (r).mmu_xq29[0] = 0
#define BCM56218_A0_MMU_XQ29m_SET(r,d) (r).mmu_xq29[0] = d
#define BCM56218_A0_MMU_XQ29m_GET(r) (r).mmu_xq29[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_XQ29m_PARITY_0f_GET(r) (((r).mmu_xq29[0]) & 0x1)
#define BCM56218_A0_MMU_XQ29m_PARITY_0f_SET(r,f) (r).mmu_xq29[0]=(((r).mmu_xq29[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_MMU_XQ29m_L2f_GET(r) ((((r).mmu_xq29[0]) >> 1) & 0x1)
#define BCM56218_A0_MMU_XQ29m_L2f_SET(r,f) (r).mmu_xq29[0]=(((r).mmu_xq29[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_MMU_XQ29m_PURGEf_GET(r) ((((r).mmu_xq29[0]) >> 2) & 0x1)
#define BCM56218_A0_MMU_XQ29m_PURGEf_SET(r,f) (r).mmu_xq29[0]=(((r).mmu_xq29[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_MMU_XQ29m_PKT_PTRf_GET(r) ((((r).mmu_xq29[0]) >> 3) & 0x3fff)
#define BCM56218_A0_MMU_XQ29m_PKT_PTRf_SET(r,f) (r).mmu_xq29[0]=(((r).mmu_xq29[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56218_A0_MMU_XQ29m_RESERVED_0f_GET(r) ((((r).mmu_xq29[0]) >> 17) & 0x1)
#define BCM56218_A0_MMU_XQ29m_RESERVED_0f_SET(r,f) (r).mmu_xq29[0]=(((r).mmu_xq29[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_MMU_XQ29m_IMIRRORf_GET(r) ((((r).mmu_xq29[0]) >> 18) & 0x1)
#define BCM56218_A0_MMU_XQ29m_IMIRRORf_SET(r,f) (r).mmu_xq29[0]=(((r).mmu_xq29[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_MMU_XQ29m_EMIRRORf_GET(r) ((((r).mmu_xq29[0]) >> 19) & 0x1)
#define BCM56218_A0_MMU_XQ29m_EMIRRORf_SET(r,f) (r).mmu_xq29[0]=(((r).mmu_xq29[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ29.
 *
 */
#define BCM56218_A0_READ_MMU_XQ29m(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_XQ29m,i,(m._mmu_xq29),1)
#define BCM56218_A0_WRITE_MMU_XQ29m(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_XQ29m,i,&(m._mmu_xq29),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ29m BCM56218_A0_MMU_XQ29m
#define MMU_XQ29m_MIN BCM56218_A0_MMU_XQ29m_MIN
#define MMU_XQ29m_MAX BCM56218_A0_MMU_XQ29m_MAX
#define MMU_XQ29m_CMAX(u) BCM56218_A0_MMU_XQ29m_CMAX(u)
#define MMU_XQ29m_SIZE BCM56218_A0_MMU_XQ29m_SIZE
typedef BCM56218_A0_MMU_XQ29m_t MMU_XQ29m_t;
#define MMU_XQ29m_CLR BCM56218_A0_MMU_XQ29m_CLR
#define MMU_XQ29m_SET BCM56218_A0_MMU_XQ29m_SET
#define MMU_XQ29m_GET BCM56218_A0_MMU_XQ29m_GET
#define MMU_XQ29m_PARITY_0f_GET BCM56218_A0_MMU_XQ29m_PARITY_0f_GET
#define MMU_XQ29m_PARITY_0f_SET BCM56218_A0_MMU_XQ29m_PARITY_0f_SET
#define MMU_XQ29m_L2f_GET BCM56218_A0_MMU_XQ29m_L2f_GET
#define MMU_XQ29m_L2f_SET BCM56218_A0_MMU_XQ29m_L2f_SET
#define MMU_XQ29m_PURGEf_GET BCM56218_A0_MMU_XQ29m_PURGEf_GET
#define MMU_XQ29m_PURGEf_SET BCM56218_A0_MMU_XQ29m_PURGEf_SET
#define MMU_XQ29m_PKT_PTRf_GET BCM56218_A0_MMU_XQ29m_PKT_PTRf_GET
#define MMU_XQ29m_PKT_PTRf_SET BCM56218_A0_MMU_XQ29m_PKT_PTRf_SET
#define MMU_XQ29m_RESERVED_0f_GET BCM56218_A0_MMU_XQ29m_RESERVED_0f_GET
#define MMU_XQ29m_RESERVED_0f_SET BCM56218_A0_MMU_XQ29m_RESERVED_0f_SET
#define MMU_XQ29m_IMIRRORf_GET BCM56218_A0_MMU_XQ29m_IMIRRORf_GET
#define MMU_XQ29m_IMIRRORf_SET BCM56218_A0_MMU_XQ29m_IMIRRORf_SET
#define MMU_XQ29m_EMIRRORf_GET BCM56218_A0_MMU_XQ29m_EMIRRORf_GET
#define MMU_XQ29m_EMIRRORf_SET BCM56218_A0_MMU_XQ29m_EMIRRORf_SET
#define READ_MMU_XQ29m BCM56218_A0_READ_MMU_XQ29m
#define WRITE_MMU_XQ29m BCM56218_A0_WRITE_MMU_XQ29m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_XQ29m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_XQ3
 * BLOCKS:   MMU
 * DESC:     XQ3
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     RESERVED_0       reserved for future use
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_XQ3m 0x0b60c000

#define BCM56218_A0_MMU_XQ3m_MIN 0
#define BCM56218_A0_MMU_XQ3m_MAX 767
#define BCM56218_A0_MMU_XQ3m_CMAX(u) 767
#define BCM56218_A0_MMU_XQ3m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ3.
 *
 */
typedef union BCM56218_A0_MMU_XQ3m_s {
	uint32_t v[1];
	uint32_t mmu_xq3[1];
	uint32_t _mmu_xq3;
} BCM56218_A0_MMU_XQ3m_t;

#define BCM56218_A0_MMU_XQ3m_CLR(r) (r).mmu_xq3[0] = 0
#define BCM56218_A0_MMU_XQ3m_SET(r,d) (r).mmu_xq3[0] = d
#define BCM56218_A0_MMU_XQ3m_GET(r) (r).mmu_xq3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_XQ3m_PARITY_0f_GET(r) (((r).mmu_xq3[0]) & 0x1)
#define BCM56218_A0_MMU_XQ3m_PARITY_0f_SET(r,f) (r).mmu_xq3[0]=(((r).mmu_xq3[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_MMU_XQ3m_L2f_GET(r) ((((r).mmu_xq3[0]) >> 1) & 0x1)
#define BCM56218_A0_MMU_XQ3m_L2f_SET(r,f) (r).mmu_xq3[0]=(((r).mmu_xq3[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_MMU_XQ3m_PURGEf_GET(r) ((((r).mmu_xq3[0]) >> 2) & 0x1)
#define BCM56218_A0_MMU_XQ3m_PURGEf_SET(r,f) (r).mmu_xq3[0]=(((r).mmu_xq3[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_MMU_XQ3m_PKT_PTRf_GET(r) ((((r).mmu_xq3[0]) >> 3) & 0x3fff)
#define BCM56218_A0_MMU_XQ3m_PKT_PTRf_SET(r,f) (r).mmu_xq3[0]=(((r).mmu_xq3[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56218_A0_MMU_XQ3m_RESERVED_0f_GET(r) ((((r).mmu_xq3[0]) >> 17) & 0x1)
#define BCM56218_A0_MMU_XQ3m_RESERVED_0f_SET(r,f) (r).mmu_xq3[0]=(((r).mmu_xq3[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_MMU_XQ3m_IMIRRORf_GET(r) ((((r).mmu_xq3[0]) >> 18) & 0x1)
#define BCM56218_A0_MMU_XQ3m_IMIRRORf_SET(r,f) (r).mmu_xq3[0]=(((r).mmu_xq3[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_MMU_XQ3m_EMIRRORf_GET(r) ((((r).mmu_xq3[0]) >> 19) & 0x1)
#define BCM56218_A0_MMU_XQ3m_EMIRRORf_SET(r,f) (r).mmu_xq3[0]=(((r).mmu_xq3[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ3.
 *
 */
#define BCM56218_A0_READ_MMU_XQ3m(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_XQ3m,i,(m._mmu_xq3),1)
#define BCM56218_A0_WRITE_MMU_XQ3m(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_XQ3m,i,&(m._mmu_xq3),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ3m BCM56218_A0_MMU_XQ3m
#define MMU_XQ3m_MIN BCM56218_A0_MMU_XQ3m_MIN
#define MMU_XQ3m_MAX BCM56218_A0_MMU_XQ3m_MAX
#define MMU_XQ3m_CMAX(u) BCM56218_A0_MMU_XQ3m_CMAX(u)
#define MMU_XQ3m_SIZE BCM56218_A0_MMU_XQ3m_SIZE
typedef BCM56218_A0_MMU_XQ3m_t MMU_XQ3m_t;
#define MMU_XQ3m_CLR BCM56218_A0_MMU_XQ3m_CLR
#define MMU_XQ3m_SET BCM56218_A0_MMU_XQ3m_SET
#define MMU_XQ3m_GET BCM56218_A0_MMU_XQ3m_GET
#define MMU_XQ3m_PARITY_0f_GET BCM56218_A0_MMU_XQ3m_PARITY_0f_GET
#define MMU_XQ3m_PARITY_0f_SET BCM56218_A0_MMU_XQ3m_PARITY_0f_SET
#define MMU_XQ3m_L2f_GET BCM56218_A0_MMU_XQ3m_L2f_GET
#define MMU_XQ3m_L2f_SET BCM56218_A0_MMU_XQ3m_L2f_SET
#define MMU_XQ3m_PURGEf_GET BCM56218_A0_MMU_XQ3m_PURGEf_GET
#define MMU_XQ3m_PURGEf_SET BCM56218_A0_MMU_XQ3m_PURGEf_SET
#define MMU_XQ3m_PKT_PTRf_GET BCM56218_A0_MMU_XQ3m_PKT_PTRf_GET
#define MMU_XQ3m_PKT_PTRf_SET BCM56218_A0_MMU_XQ3m_PKT_PTRf_SET
#define MMU_XQ3m_RESERVED_0f_GET BCM56218_A0_MMU_XQ3m_RESERVED_0f_GET
#define MMU_XQ3m_RESERVED_0f_SET BCM56218_A0_MMU_XQ3m_RESERVED_0f_SET
#define MMU_XQ3m_IMIRRORf_GET BCM56218_A0_MMU_XQ3m_IMIRRORf_GET
#define MMU_XQ3m_IMIRRORf_SET BCM56218_A0_MMU_XQ3m_IMIRRORf_SET
#define MMU_XQ3m_EMIRRORf_GET BCM56218_A0_MMU_XQ3m_EMIRRORf_GET
#define MMU_XQ3m_EMIRRORf_SET BCM56218_A0_MMU_XQ3m_EMIRRORf_SET
#define READ_MMU_XQ3m BCM56218_A0_READ_MMU_XQ3m
#define WRITE_MMU_XQ3m BCM56218_A0_WRITE_MMU_XQ3m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_XQ3m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_XQ30
 * BLOCKS:   MMU
 * DESC:     XQ30
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     RESERVED_0       reserved for future use
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_XQ30m 0x0b678000

#define BCM56218_A0_MMU_XQ30m_MIN 0
#define BCM56218_A0_MMU_XQ30m_MAX 511
#define BCM56218_A0_MMU_XQ30m_CMAX(u) 511
#define BCM56218_A0_MMU_XQ30m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ30.
 *
 */
typedef union BCM56218_A0_MMU_XQ30m_s {
	uint32_t v[1];
	uint32_t mmu_xq30[1];
	uint32_t _mmu_xq30;
} BCM56218_A0_MMU_XQ30m_t;

#define BCM56218_A0_MMU_XQ30m_CLR(r) (r).mmu_xq30[0] = 0
#define BCM56218_A0_MMU_XQ30m_SET(r,d) (r).mmu_xq30[0] = d
#define BCM56218_A0_MMU_XQ30m_GET(r) (r).mmu_xq30[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_XQ30m_PARITY_0f_GET(r) (((r).mmu_xq30[0]) & 0x1)
#define BCM56218_A0_MMU_XQ30m_PARITY_0f_SET(r,f) (r).mmu_xq30[0]=(((r).mmu_xq30[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_MMU_XQ30m_L2f_GET(r) ((((r).mmu_xq30[0]) >> 1) & 0x1)
#define BCM56218_A0_MMU_XQ30m_L2f_SET(r,f) (r).mmu_xq30[0]=(((r).mmu_xq30[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_MMU_XQ30m_PURGEf_GET(r) ((((r).mmu_xq30[0]) >> 2) & 0x1)
#define BCM56218_A0_MMU_XQ30m_PURGEf_SET(r,f) (r).mmu_xq30[0]=(((r).mmu_xq30[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_MMU_XQ30m_PKT_PTRf_GET(r) ((((r).mmu_xq30[0]) >> 3) & 0x3fff)
#define BCM56218_A0_MMU_XQ30m_PKT_PTRf_SET(r,f) (r).mmu_xq30[0]=(((r).mmu_xq30[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56218_A0_MMU_XQ30m_RESERVED_0f_GET(r) ((((r).mmu_xq30[0]) >> 17) & 0x1)
#define BCM56218_A0_MMU_XQ30m_RESERVED_0f_SET(r,f) (r).mmu_xq30[0]=(((r).mmu_xq30[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_MMU_XQ30m_IMIRRORf_GET(r) ((((r).mmu_xq30[0]) >> 18) & 0x1)
#define BCM56218_A0_MMU_XQ30m_IMIRRORf_SET(r,f) (r).mmu_xq30[0]=(((r).mmu_xq30[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_MMU_XQ30m_EMIRRORf_GET(r) ((((r).mmu_xq30[0]) >> 19) & 0x1)
#define BCM56218_A0_MMU_XQ30m_EMIRRORf_SET(r,f) (r).mmu_xq30[0]=(((r).mmu_xq30[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ30.
 *
 */
#define BCM56218_A0_READ_MMU_XQ30m(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_XQ30m,i,(m._mmu_xq30),1)
#define BCM56218_A0_WRITE_MMU_XQ30m(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_XQ30m,i,&(m._mmu_xq30),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ30m BCM56218_A0_MMU_XQ30m
#define MMU_XQ30m_MIN BCM56218_A0_MMU_XQ30m_MIN
#define MMU_XQ30m_MAX BCM56218_A0_MMU_XQ30m_MAX
#define MMU_XQ30m_CMAX(u) BCM56218_A0_MMU_XQ30m_CMAX(u)
#define MMU_XQ30m_SIZE BCM56218_A0_MMU_XQ30m_SIZE
typedef BCM56218_A0_MMU_XQ30m_t MMU_XQ30m_t;
#define MMU_XQ30m_CLR BCM56218_A0_MMU_XQ30m_CLR
#define MMU_XQ30m_SET BCM56218_A0_MMU_XQ30m_SET
#define MMU_XQ30m_GET BCM56218_A0_MMU_XQ30m_GET
#define MMU_XQ30m_PARITY_0f_GET BCM56218_A0_MMU_XQ30m_PARITY_0f_GET
#define MMU_XQ30m_PARITY_0f_SET BCM56218_A0_MMU_XQ30m_PARITY_0f_SET
#define MMU_XQ30m_L2f_GET BCM56218_A0_MMU_XQ30m_L2f_GET
#define MMU_XQ30m_L2f_SET BCM56218_A0_MMU_XQ30m_L2f_SET
#define MMU_XQ30m_PURGEf_GET BCM56218_A0_MMU_XQ30m_PURGEf_GET
#define MMU_XQ30m_PURGEf_SET BCM56218_A0_MMU_XQ30m_PURGEf_SET
#define MMU_XQ30m_PKT_PTRf_GET BCM56218_A0_MMU_XQ30m_PKT_PTRf_GET
#define MMU_XQ30m_PKT_PTRf_SET BCM56218_A0_MMU_XQ30m_PKT_PTRf_SET
#define MMU_XQ30m_RESERVED_0f_GET BCM56218_A0_MMU_XQ30m_RESERVED_0f_GET
#define MMU_XQ30m_RESERVED_0f_SET BCM56218_A0_MMU_XQ30m_RESERVED_0f_SET
#define MMU_XQ30m_IMIRRORf_GET BCM56218_A0_MMU_XQ30m_IMIRRORf_GET
#define MMU_XQ30m_IMIRRORf_SET BCM56218_A0_MMU_XQ30m_IMIRRORf_SET
#define MMU_XQ30m_EMIRRORf_GET BCM56218_A0_MMU_XQ30m_EMIRRORf_GET
#define MMU_XQ30m_EMIRRORf_SET BCM56218_A0_MMU_XQ30m_EMIRRORf_SET
#define READ_MMU_XQ30m BCM56218_A0_READ_MMU_XQ30m
#define WRITE_MMU_XQ30m BCM56218_A0_WRITE_MMU_XQ30m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_XQ30m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_XQ31
 * BLOCKS:   MMU
 * DESC:     XQ31
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     RESERVED_0       reserved for future use
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_XQ31m 0x0b67c000

#define BCM56218_A0_MMU_XQ31m_MIN 0
#define BCM56218_A0_MMU_XQ31m_MAX 511
#define BCM56218_A0_MMU_XQ31m_CMAX(u) 511
#define BCM56218_A0_MMU_XQ31m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ31.
 *
 */
typedef union BCM56218_A0_MMU_XQ31m_s {
	uint32_t v[1];
	uint32_t mmu_xq31[1];
	uint32_t _mmu_xq31;
} BCM56218_A0_MMU_XQ31m_t;

#define BCM56218_A0_MMU_XQ31m_CLR(r) (r).mmu_xq31[0] = 0
#define BCM56218_A0_MMU_XQ31m_SET(r,d) (r).mmu_xq31[0] = d
#define BCM56218_A0_MMU_XQ31m_GET(r) (r).mmu_xq31[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_XQ31m_PARITY_0f_GET(r) (((r).mmu_xq31[0]) & 0x1)
#define BCM56218_A0_MMU_XQ31m_PARITY_0f_SET(r,f) (r).mmu_xq31[0]=(((r).mmu_xq31[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_MMU_XQ31m_L2f_GET(r) ((((r).mmu_xq31[0]) >> 1) & 0x1)
#define BCM56218_A0_MMU_XQ31m_L2f_SET(r,f) (r).mmu_xq31[0]=(((r).mmu_xq31[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_MMU_XQ31m_PURGEf_GET(r) ((((r).mmu_xq31[0]) >> 2) & 0x1)
#define BCM56218_A0_MMU_XQ31m_PURGEf_SET(r,f) (r).mmu_xq31[0]=(((r).mmu_xq31[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_MMU_XQ31m_PKT_PTRf_GET(r) ((((r).mmu_xq31[0]) >> 3) & 0x3fff)
#define BCM56218_A0_MMU_XQ31m_PKT_PTRf_SET(r,f) (r).mmu_xq31[0]=(((r).mmu_xq31[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56218_A0_MMU_XQ31m_RESERVED_0f_GET(r) ((((r).mmu_xq31[0]) >> 17) & 0x1)
#define BCM56218_A0_MMU_XQ31m_RESERVED_0f_SET(r,f) (r).mmu_xq31[0]=(((r).mmu_xq31[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_MMU_XQ31m_IMIRRORf_GET(r) ((((r).mmu_xq31[0]) >> 18) & 0x1)
#define BCM56218_A0_MMU_XQ31m_IMIRRORf_SET(r,f) (r).mmu_xq31[0]=(((r).mmu_xq31[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_MMU_XQ31m_EMIRRORf_GET(r) ((((r).mmu_xq31[0]) >> 19) & 0x1)
#define BCM56218_A0_MMU_XQ31m_EMIRRORf_SET(r,f) (r).mmu_xq31[0]=(((r).mmu_xq31[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ31.
 *
 */
#define BCM56218_A0_READ_MMU_XQ31m(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_XQ31m,i,(m._mmu_xq31),1)
#define BCM56218_A0_WRITE_MMU_XQ31m(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_XQ31m,i,&(m._mmu_xq31),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ31m BCM56218_A0_MMU_XQ31m
#define MMU_XQ31m_MIN BCM56218_A0_MMU_XQ31m_MIN
#define MMU_XQ31m_MAX BCM56218_A0_MMU_XQ31m_MAX
#define MMU_XQ31m_CMAX(u) BCM56218_A0_MMU_XQ31m_CMAX(u)
#define MMU_XQ31m_SIZE BCM56218_A0_MMU_XQ31m_SIZE
typedef BCM56218_A0_MMU_XQ31m_t MMU_XQ31m_t;
#define MMU_XQ31m_CLR BCM56218_A0_MMU_XQ31m_CLR
#define MMU_XQ31m_SET BCM56218_A0_MMU_XQ31m_SET
#define MMU_XQ31m_GET BCM56218_A0_MMU_XQ31m_GET
#define MMU_XQ31m_PARITY_0f_GET BCM56218_A0_MMU_XQ31m_PARITY_0f_GET
#define MMU_XQ31m_PARITY_0f_SET BCM56218_A0_MMU_XQ31m_PARITY_0f_SET
#define MMU_XQ31m_L2f_GET BCM56218_A0_MMU_XQ31m_L2f_GET
#define MMU_XQ31m_L2f_SET BCM56218_A0_MMU_XQ31m_L2f_SET
#define MMU_XQ31m_PURGEf_GET BCM56218_A0_MMU_XQ31m_PURGEf_GET
#define MMU_XQ31m_PURGEf_SET BCM56218_A0_MMU_XQ31m_PURGEf_SET
#define MMU_XQ31m_PKT_PTRf_GET BCM56218_A0_MMU_XQ31m_PKT_PTRf_GET
#define MMU_XQ31m_PKT_PTRf_SET BCM56218_A0_MMU_XQ31m_PKT_PTRf_SET
#define MMU_XQ31m_RESERVED_0f_GET BCM56218_A0_MMU_XQ31m_RESERVED_0f_GET
#define MMU_XQ31m_RESERVED_0f_SET BCM56218_A0_MMU_XQ31m_RESERVED_0f_SET
#define MMU_XQ31m_IMIRRORf_GET BCM56218_A0_MMU_XQ31m_IMIRRORf_GET
#define MMU_XQ31m_IMIRRORf_SET BCM56218_A0_MMU_XQ31m_IMIRRORf_SET
#define MMU_XQ31m_EMIRRORf_GET BCM56218_A0_MMU_XQ31m_EMIRRORf_GET
#define MMU_XQ31m_EMIRRORf_SET BCM56218_A0_MMU_XQ31m_EMIRRORf_SET
#define READ_MMU_XQ31m BCM56218_A0_READ_MMU_XQ31m
#define WRITE_MMU_XQ31m BCM56218_A0_WRITE_MMU_XQ31m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_XQ31m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_XQ32
 * BLOCKS:   MMU
 * DESC:     XQ32
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     RESERVED_0       reserved for future use
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_XQ32m 0x0b680000

#define BCM56218_A0_MMU_XQ32m_MIN 0
#define BCM56218_A0_MMU_XQ32m_MAX 511
#define BCM56218_A0_MMU_XQ32m_CMAX(u) 511
#define BCM56218_A0_MMU_XQ32m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ32.
 *
 */
typedef union BCM56218_A0_MMU_XQ32m_s {
	uint32_t v[1];
	uint32_t mmu_xq32[1];
	uint32_t _mmu_xq32;
} BCM56218_A0_MMU_XQ32m_t;

#define BCM56218_A0_MMU_XQ32m_CLR(r) (r).mmu_xq32[0] = 0
#define BCM56218_A0_MMU_XQ32m_SET(r,d) (r).mmu_xq32[0] = d
#define BCM56218_A0_MMU_XQ32m_GET(r) (r).mmu_xq32[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_XQ32m_PARITY_0f_GET(r) (((r).mmu_xq32[0]) & 0x1)
#define BCM56218_A0_MMU_XQ32m_PARITY_0f_SET(r,f) (r).mmu_xq32[0]=(((r).mmu_xq32[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_MMU_XQ32m_L2f_GET(r) ((((r).mmu_xq32[0]) >> 1) & 0x1)
#define BCM56218_A0_MMU_XQ32m_L2f_SET(r,f) (r).mmu_xq32[0]=(((r).mmu_xq32[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_MMU_XQ32m_PURGEf_GET(r) ((((r).mmu_xq32[0]) >> 2) & 0x1)
#define BCM56218_A0_MMU_XQ32m_PURGEf_SET(r,f) (r).mmu_xq32[0]=(((r).mmu_xq32[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_MMU_XQ32m_PKT_PTRf_GET(r) ((((r).mmu_xq32[0]) >> 3) & 0x3fff)
#define BCM56218_A0_MMU_XQ32m_PKT_PTRf_SET(r,f) (r).mmu_xq32[0]=(((r).mmu_xq32[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56218_A0_MMU_XQ32m_RESERVED_0f_GET(r) ((((r).mmu_xq32[0]) >> 17) & 0x1)
#define BCM56218_A0_MMU_XQ32m_RESERVED_0f_SET(r,f) (r).mmu_xq32[0]=(((r).mmu_xq32[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_MMU_XQ32m_IMIRRORf_GET(r) ((((r).mmu_xq32[0]) >> 18) & 0x1)
#define BCM56218_A0_MMU_XQ32m_IMIRRORf_SET(r,f) (r).mmu_xq32[0]=(((r).mmu_xq32[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_MMU_XQ32m_EMIRRORf_GET(r) ((((r).mmu_xq32[0]) >> 19) & 0x1)
#define BCM56218_A0_MMU_XQ32m_EMIRRORf_SET(r,f) (r).mmu_xq32[0]=(((r).mmu_xq32[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ32.
 *
 */
#define BCM56218_A0_READ_MMU_XQ32m(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_XQ32m,i,(m._mmu_xq32),1)
#define BCM56218_A0_WRITE_MMU_XQ32m(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_XQ32m,i,&(m._mmu_xq32),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ32m BCM56218_A0_MMU_XQ32m
#define MMU_XQ32m_MIN BCM56218_A0_MMU_XQ32m_MIN
#define MMU_XQ32m_MAX BCM56218_A0_MMU_XQ32m_MAX
#define MMU_XQ32m_CMAX(u) BCM56218_A0_MMU_XQ32m_CMAX(u)
#define MMU_XQ32m_SIZE BCM56218_A0_MMU_XQ32m_SIZE
typedef BCM56218_A0_MMU_XQ32m_t MMU_XQ32m_t;
#define MMU_XQ32m_CLR BCM56218_A0_MMU_XQ32m_CLR
#define MMU_XQ32m_SET BCM56218_A0_MMU_XQ32m_SET
#define MMU_XQ32m_GET BCM56218_A0_MMU_XQ32m_GET
#define MMU_XQ32m_PARITY_0f_GET BCM56218_A0_MMU_XQ32m_PARITY_0f_GET
#define MMU_XQ32m_PARITY_0f_SET BCM56218_A0_MMU_XQ32m_PARITY_0f_SET
#define MMU_XQ32m_L2f_GET BCM56218_A0_MMU_XQ32m_L2f_GET
#define MMU_XQ32m_L2f_SET BCM56218_A0_MMU_XQ32m_L2f_SET
#define MMU_XQ32m_PURGEf_GET BCM56218_A0_MMU_XQ32m_PURGEf_GET
#define MMU_XQ32m_PURGEf_SET BCM56218_A0_MMU_XQ32m_PURGEf_SET
#define MMU_XQ32m_PKT_PTRf_GET BCM56218_A0_MMU_XQ32m_PKT_PTRf_GET
#define MMU_XQ32m_PKT_PTRf_SET BCM56218_A0_MMU_XQ32m_PKT_PTRf_SET
#define MMU_XQ32m_RESERVED_0f_GET BCM56218_A0_MMU_XQ32m_RESERVED_0f_GET
#define MMU_XQ32m_RESERVED_0f_SET BCM56218_A0_MMU_XQ32m_RESERVED_0f_SET
#define MMU_XQ32m_IMIRRORf_GET BCM56218_A0_MMU_XQ32m_IMIRRORf_GET
#define MMU_XQ32m_IMIRRORf_SET BCM56218_A0_MMU_XQ32m_IMIRRORf_SET
#define MMU_XQ32m_EMIRRORf_GET BCM56218_A0_MMU_XQ32m_EMIRRORf_GET
#define MMU_XQ32m_EMIRRORf_SET BCM56218_A0_MMU_XQ32m_EMIRRORf_SET
#define READ_MMU_XQ32m BCM56218_A0_READ_MMU_XQ32m
#define WRITE_MMU_XQ32m BCM56218_A0_WRITE_MMU_XQ32m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_XQ32m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_XQ33
 * BLOCKS:   MMU
 * DESC:     XQ33
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     RESERVED_0       reserved for future use
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_XQ33m 0x0b684000

#define BCM56218_A0_MMU_XQ33m_MIN 0
#define BCM56218_A0_MMU_XQ33m_MAX 511
#define BCM56218_A0_MMU_XQ33m_CMAX(u) 511
#define BCM56218_A0_MMU_XQ33m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ33.
 *
 */
typedef union BCM56218_A0_MMU_XQ33m_s {
	uint32_t v[1];
	uint32_t mmu_xq33[1];
	uint32_t _mmu_xq33;
} BCM56218_A0_MMU_XQ33m_t;

#define BCM56218_A0_MMU_XQ33m_CLR(r) (r).mmu_xq33[0] = 0
#define BCM56218_A0_MMU_XQ33m_SET(r,d) (r).mmu_xq33[0] = d
#define BCM56218_A0_MMU_XQ33m_GET(r) (r).mmu_xq33[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_XQ33m_PARITY_0f_GET(r) (((r).mmu_xq33[0]) & 0x1)
#define BCM56218_A0_MMU_XQ33m_PARITY_0f_SET(r,f) (r).mmu_xq33[0]=(((r).mmu_xq33[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_MMU_XQ33m_L2f_GET(r) ((((r).mmu_xq33[0]) >> 1) & 0x1)
#define BCM56218_A0_MMU_XQ33m_L2f_SET(r,f) (r).mmu_xq33[0]=(((r).mmu_xq33[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_MMU_XQ33m_PURGEf_GET(r) ((((r).mmu_xq33[0]) >> 2) & 0x1)
#define BCM56218_A0_MMU_XQ33m_PURGEf_SET(r,f) (r).mmu_xq33[0]=(((r).mmu_xq33[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_MMU_XQ33m_PKT_PTRf_GET(r) ((((r).mmu_xq33[0]) >> 3) & 0x3fff)
#define BCM56218_A0_MMU_XQ33m_PKT_PTRf_SET(r,f) (r).mmu_xq33[0]=(((r).mmu_xq33[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56218_A0_MMU_XQ33m_RESERVED_0f_GET(r) ((((r).mmu_xq33[0]) >> 17) & 0x1)
#define BCM56218_A0_MMU_XQ33m_RESERVED_0f_SET(r,f) (r).mmu_xq33[0]=(((r).mmu_xq33[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_MMU_XQ33m_IMIRRORf_GET(r) ((((r).mmu_xq33[0]) >> 18) & 0x1)
#define BCM56218_A0_MMU_XQ33m_IMIRRORf_SET(r,f) (r).mmu_xq33[0]=(((r).mmu_xq33[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_MMU_XQ33m_EMIRRORf_GET(r) ((((r).mmu_xq33[0]) >> 19) & 0x1)
#define BCM56218_A0_MMU_XQ33m_EMIRRORf_SET(r,f) (r).mmu_xq33[0]=(((r).mmu_xq33[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ33.
 *
 */
#define BCM56218_A0_READ_MMU_XQ33m(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_XQ33m,i,(m._mmu_xq33),1)
#define BCM56218_A0_WRITE_MMU_XQ33m(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_XQ33m,i,&(m._mmu_xq33),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ33m BCM56218_A0_MMU_XQ33m
#define MMU_XQ33m_MIN BCM56218_A0_MMU_XQ33m_MIN
#define MMU_XQ33m_MAX BCM56218_A0_MMU_XQ33m_MAX
#define MMU_XQ33m_CMAX(u) BCM56218_A0_MMU_XQ33m_CMAX(u)
#define MMU_XQ33m_SIZE BCM56218_A0_MMU_XQ33m_SIZE
typedef BCM56218_A0_MMU_XQ33m_t MMU_XQ33m_t;
#define MMU_XQ33m_CLR BCM56218_A0_MMU_XQ33m_CLR
#define MMU_XQ33m_SET BCM56218_A0_MMU_XQ33m_SET
#define MMU_XQ33m_GET BCM56218_A0_MMU_XQ33m_GET
#define MMU_XQ33m_PARITY_0f_GET BCM56218_A0_MMU_XQ33m_PARITY_0f_GET
#define MMU_XQ33m_PARITY_0f_SET BCM56218_A0_MMU_XQ33m_PARITY_0f_SET
#define MMU_XQ33m_L2f_GET BCM56218_A0_MMU_XQ33m_L2f_GET
#define MMU_XQ33m_L2f_SET BCM56218_A0_MMU_XQ33m_L2f_SET
#define MMU_XQ33m_PURGEf_GET BCM56218_A0_MMU_XQ33m_PURGEf_GET
#define MMU_XQ33m_PURGEf_SET BCM56218_A0_MMU_XQ33m_PURGEf_SET
#define MMU_XQ33m_PKT_PTRf_GET BCM56218_A0_MMU_XQ33m_PKT_PTRf_GET
#define MMU_XQ33m_PKT_PTRf_SET BCM56218_A0_MMU_XQ33m_PKT_PTRf_SET
#define MMU_XQ33m_RESERVED_0f_GET BCM56218_A0_MMU_XQ33m_RESERVED_0f_GET
#define MMU_XQ33m_RESERVED_0f_SET BCM56218_A0_MMU_XQ33m_RESERVED_0f_SET
#define MMU_XQ33m_IMIRRORf_GET BCM56218_A0_MMU_XQ33m_IMIRRORf_GET
#define MMU_XQ33m_IMIRRORf_SET BCM56218_A0_MMU_XQ33m_IMIRRORf_SET
#define MMU_XQ33m_EMIRRORf_GET BCM56218_A0_MMU_XQ33m_EMIRRORf_GET
#define MMU_XQ33m_EMIRRORf_SET BCM56218_A0_MMU_XQ33m_EMIRRORf_SET
#define READ_MMU_XQ33m BCM56218_A0_READ_MMU_XQ33m
#define WRITE_MMU_XQ33m BCM56218_A0_WRITE_MMU_XQ33m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_XQ33m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_XQ34
 * BLOCKS:   MMU
 * DESC:     XQ34
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     RESERVED_0       reserved for future use
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_XQ34m 0x0b688000

#define BCM56218_A0_MMU_XQ34m_MIN 0
#define BCM56218_A0_MMU_XQ34m_MAX 511
#define BCM56218_A0_MMU_XQ34m_CMAX(u) 511
#define BCM56218_A0_MMU_XQ34m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ34.
 *
 */
typedef union BCM56218_A0_MMU_XQ34m_s {
	uint32_t v[1];
	uint32_t mmu_xq34[1];
	uint32_t _mmu_xq34;
} BCM56218_A0_MMU_XQ34m_t;

#define BCM56218_A0_MMU_XQ34m_CLR(r) (r).mmu_xq34[0] = 0
#define BCM56218_A0_MMU_XQ34m_SET(r,d) (r).mmu_xq34[0] = d
#define BCM56218_A0_MMU_XQ34m_GET(r) (r).mmu_xq34[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_XQ34m_PARITY_0f_GET(r) (((r).mmu_xq34[0]) & 0x1)
#define BCM56218_A0_MMU_XQ34m_PARITY_0f_SET(r,f) (r).mmu_xq34[0]=(((r).mmu_xq34[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_MMU_XQ34m_L2f_GET(r) ((((r).mmu_xq34[0]) >> 1) & 0x1)
#define BCM56218_A0_MMU_XQ34m_L2f_SET(r,f) (r).mmu_xq34[0]=(((r).mmu_xq34[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_MMU_XQ34m_PURGEf_GET(r) ((((r).mmu_xq34[0]) >> 2) & 0x1)
#define BCM56218_A0_MMU_XQ34m_PURGEf_SET(r,f) (r).mmu_xq34[0]=(((r).mmu_xq34[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_MMU_XQ34m_PKT_PTRf_GET(r) ((((r).mmu_xq34[0]) >> 3) & 0x3fff)
#define BCM56218_A0_MMU_XQ34m_PKT_PTRf_SET(r,f) (r).mmu_xq34[0]=(((r).mmu_xq34[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56218_A0_MMU_XQ34m_RESERVED_0f_GET(r) ((((r).mmu_xq34[0]) >> 17) & 0x1)
#define BCM56218_A0_MMU_XQ34m_RESERVED_0f_SET(r,f) (r).mmu_xq34[0]=(((r).mmu_xq34[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_MMU_XQ34m_IMIRRORf_GET(r) ((((r).mmu_xq34[0]) >> 18) & 0x1)
#define BCM56218_A0_MMU_XQ34m_IMIRRORf_SET(r,f) (r).mmu_xq34[0]=(((r).mmu_xq34[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_MMU_XQ34m_EMIRRORf_GET(r) ((((r).mmu_xq34[0]) >> 19) & 0x1)
#define BCM56218_A0_MMU_XQ34m_EMIRRORf_SET(r,f) (r).mmu_xq34[0]=(((r).mmu_xq34[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ34.
 *
 */
#define BCM56218_A0_READ_MMU_XQ34m(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_XQ34m,i,(m._mmu_xq34),1)
#define BCM56218_A0_WRITE_MMU_XQ34m(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_XQ34m,i,&(m._mmu_xq34),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ34m BCM56218_A0_MMU_XQ34m
#define MMU_XQ34m_MIN BCM56218_A0_MMU_XQ34m_MIN
#define MMU_XQ34m_MAX BCM56218_A0_MMU_XQ34m_MAX
#define MMU_XQ34m_CMAX(u) BCM56218_A0_MMU_XQ34m_CMAX(u)
#define MMU_XQ34m_SIZE BCM56218_A0_MMU_XQ34m_SIZE
typedef BCM56218_A0_MMU_XQ34m_t MMU_XQ34m_t;
#define MMU_XQ34m_CLR BCM56218_A0_MMU_XQ34m_CLR
#define MMU_XQ34m_SET BCM56218_A0_MMU_XQ34m_SET
#define MMU_XQ34m_GET BCM56218_A0_MMU_XQ34m_GET
#define MMU_XQ34m_PARITY_0f_GET BCM56218_A0_MMU_XQ34m_PARITY_0f_GET
#define MMU_XQ34m_PARITY_0f_SET BCM56218_A0_MMU_XQ34m_PARITY_0f_SET
#define MMU_XQ34m_L2f_GET BCM56218_A0_MMU_XQ34m_L2f_GET
#define MMU_XQ34m_L2f_SET BCM56218_A0_MMU_XQ34m_L2f_SET
#define MMU_XQ34m_PURGEf_GET BCM56218_A0_MMU_XQ34m_PURGEf_GET
#define MMU_XQ34m_PURGEf_SET BCM56218_A0_MMU_XQ34m_PURGEf_SET
#define MMU_XQ34m_PKT_PTRf_GET BCM56218_A0_MMU_XQ34m_PKT_PTRf_GET
#define MMU_XQ34m_PKT_PTRf_SET BCM56218_A0_MMU_XQ34m_PKT_PTRf_SET
#define MMU_XQ34m_RESERVED_0f_GET BCM56218_A0_MMU_XQ34m_RESERVED_0f_GET
#define MMU_XQ34m_RESERVED_0f_SET BCM56218_A0_MMU_XQ34m_RESERVED_0f_SET
#define MMU_XQ34m_IMIRRORf_GET BCM56218_A0_MMU_XQ34m_IMIRRORf_GET
#define MMU_XQ34m_IMIRRORf_SET BCM56218_A0_MMU_XQ34m_IMIRRORf_SET
#define MMU_XQ34m_EMIRRORf_GET BCM56218_A0_MMU_XQ34m_EMIRRORf_GET
#define MMU_XQ34m_EMIRRORf_SET BCM56218_A0_MMU_XQ34m_EMIRRORf_SET
#define READ_MMU_XQ34m BCM56218_A0_READ_MMU_XQ34m
#define WRITE_MMU_XQ34m BCM56218_A0_WRITE_MMU_XQ34m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_XQ34m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_XQ35
 * BLOCKS:   MMU
 * DESC:     XQ35
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     RESERVED_0       reserved for future use
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_XQ35m 0x0b68c000

#define BCM56218_A0_MMU_XQ35m_MIN 0
#define BCM56218_A0_MMU_XQ35m_MAX 511
#define BCM56218_A0_MMU_XQ35m_CMAX(u) 511
#define BCM56218_A0_MMU_XQ35m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ35.
 *
 */
typedef union BCM56218_A0_MMU_XQ35m_s {
	uint32_t v[1];
	uint32_t mmu_xq35[1];
	uint32_t _mmu_xq35;
} BCM56218_A0_MMU_XQ35m_t;

#define BCM56218_A0_MMU_XQ35m_CLR(r) (r).mmu_xq35[0] = 0
#define BCM56218_A0_MMU_XQ35m_SET(r,d) (r).mmu_xq35[0] = d
#define BCM56218_A0_MMU_XQ35m_GET(r) (r).mmu_xq35[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_XQ35m_PARITY_0f_GET(r) (((r).mmu_xq35[0]) & 0x1)
#define BCM56218_A0_MMU_XQ35m_PARITY_0f_SET(r,f) (r).mmu_xq35[0]=(((r).mmu_xq35[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_MMU_XQ35m_L2f_GET(r) ((((r).mmu_xq35[0]) >> 1) & 0x1)
#define BCM56218_A0_MMU_XQ35m_L2f_SET(r,f) (r).mmu_xq35[0]=(((r).mmu_xq35[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_MMU_XQ35m_PURGEf_GET(r) ((((r).mmu_xq35[0]) >> 2) & 0x1)
#define BCM56218_A0_MMU_XQ35m_PURGEf_SET(r,f) (r).mmu_xq35[0]=(((r).mmu_xq35[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_MMU_XQ35m_PKT_PTRf_GET(r) ((((r).mmu_xq35[0]) >> 3) & 0x3fff)
#define BCM56218_A0_MMU_XQ35m_PKT_PTRf_SET(r,f) (r).mmu_xq35[0]=(((r).mmu_xq35[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56218_A0_MMU_XQ35m_RESERVED_0f_GET(r) ((((r).mmu_xq35[0]) >> 17) & 0x1)
#define BCM56218_A0_MMU_XQ35m_RESERVED_0f_SET(r,f) (r).mmu_xq35[0]=(((r).mmu_xq35[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_MMU_XQ35m_IMIRRORf_GET(r) ((((r).mmu_xq35[0]) >> 18) & 0x1)
#define BCM56218_A0_MMU_XQ35m_IMIRRORf_SET(r,f) (r).mmu_xq35[0]=(((r).mmu_xq35[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_MMU_XQ35m_EMIRRORf_GET(r) ((((r).mmu_xq35[0]) >> 19) & 0x1)
#define BCM56218_A0_MMU_XQ35m_EMIRRORf_SET(r,f) (r).mmu_xq35[0]=(((r).mmu_xq35[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ35.
 *
 */
#define BCM56218_A0_READ_MMU_XQ35m(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_XQ35m,i,(m._mmu_xq35),1)
#define BCM56218_A0_WRITE_MMU_XQ35m(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_XQ35m,i,&(m._mmu_xq35),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ35m BCM56218_A0_MMU_XQ35m
#define MMU_XQ35m_MIN BCM56218_A0_MMU_XQ35m_MIN
#define MMU_XQ35m_MAX BCM56218_A0_MMU_XQ35m_MAX
#define MMU_XQ35m_CMAX(u) BCM56218_A0_MMU_XQ35m_CMAX(u)
#define MMU_XQ35m_SIZE BCM56218_A0_MMU_XQ35m_SIZE
typedef BCM56218_A0_MMU_XQ35m_t MMU_XQ35m_t;
#define MMU_XQ35m_CLR BCM56218_A0_MMU_XQ35m_CLR
#define MMU_XQ35m_SET BCM56218_A0_MMU_XQ35m_SET
#define MMU_XQ35m_GET BCM56218_A0_MMU_XQ35m_GET
#define MMU_XQ35m_PARITY_0f_GET BCM56218_A0_MMU_XQ35m_PARITY_0f_GET
#define MMU_XQ35m_PARITY_0f_SET BCM56218_A0_MMU_XQ35m_PARITY_0f_SET
#define MMU_XQ35m_L2f_GET BCM56218_A0_MMU_XQ35m_L2f_GET
#define MMU_XQ35m_L2f_SET BCM56218_A0_MMU_XQ35m_L2f_SET
#define MMU_XQ35m_PURGEf_GET BCM56218_A0_MMU_XQ35m_PURGEf_GET
#define MMU_XQ35m_PURGEf_SET BCM56218_A0_MMU_XQ35m_PURGEf_SET
#define MMU_XQ35m_PKT_PTRf_GET BCM56218_A0_MMU_XQ35m_PKT_PTRf_GET
#define MMU_XQ35m_PKT_PTRf_SET BCM56218_A0_MMU_XQ35m_PKT_PTRf_SET
#define MMU_XQ35m_RESERVED_0f_GET BCM56218_A0_MMU_XQ35m_RESERVED_0f_GET
#define MMU_XQ35m_RESERVED_0f_SET BCM56218_A0_MMU_XQ35m_RESERVED_0f_SET
#define MMU_XQ35m_IMIRRORf_GET BCM56218_A0_MMU_XQ35m_IMIRRORf_GET
#define MMU_XQ35m_IMIRRORf_SET BCM56218_A0_MMU_XQ35m_IMIRRORf_SET
#define MMU_XQ35m_EMIRRORf_GET BCM56218_A0_MMU_XQ35m_EMIRRORf_GET
#define MMU_XQ35m_EMIRRORf_SET BCM56218_A0_MMU_XQ35m_EMIRRORf_SET
#define READ_MMU_XQ35m BCM56218_A0_READ_MMU_XQ35m
#define WRITE_MMU_XQ35m BCM56218_A0_WRITE_MMU_XQ35m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_XQ35m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_XQ36
 * BLOCKS:   MMU
 * DESC:     XQ36
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     RESERVED_0       reserved for future use
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_XQ36m 0x0b690000

#define BCM56218_A0_MMU_XQ36m_MIN 0
#define BCM56218_A0_MMU_XQ36m_MAX 511
#define BCM56218_A0_MMU_XQ36m_CMAX(u) 511
#define BCM56218_A0_MMU_XQ36m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ36.
 *
 */
typedef union BCM56218_A0_MMU_XQ36m_s {
	uint32_t v[1];
	uint32_t mmu_xq36[1];
	uint32_t _mmu_xq36;
} BCM56218_A0_MMU_XQ36m_t;

#define BCM56218_A0_MMU_XQ36m_CLR(r) (r).mmu_xq36[0] = 0
#define BCM56218_A0_MMU_XQ36m_SET(r,d) (r).mmu_xq36[0] = d
#define BCM56218_A0_MMU_XQ36m_GET(r) (r).mmu_xq36[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_XQ36m_PARITY_0f_GET(r) (((r).mmu_xq36[0]) & 0x1)
#define BCM56218_A0_MMU_XQ36m_PARITY_0f_SET(r,f) (r).mmu_xq36[0]=(((r).mmu_xq36[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_MMU_XQ36m_L2f_GET(r) ((((r).mmu_xq36[0]) >> 1) & 0x1)
#define BCM56218_A0_MMU_XQ36m_L2f_SET(r,f) (r).mmu_xq36[0]=(((r).mmu_xq36[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_MMU_XQ36m_PURGEf_GET(r) ((((r).mmu_xq36[0]) >> 2) & 0x1)
#define BCM56218_A0_MMU_XQ36m_PURGEf_SET(r,f) (r).mmu_xq36[0]=(((r).mmu_xq36[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_MMU_XQ36m_PKT_PTRf_GET(r) ((((r).mmu_xq36[0]) >> 3) & 0x3fff)
#define BCM56218_A0_MMU_XQ36m_PKT_PTRf_SET(r,f) (r).mmu_xq36[0]=(((r).mmu_xq36[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56218_A0_MMU_XQ36m_RESERVED_0f_GET(r) ((((r).mmu_xq36[0]) >> 17) & 0x1)
#define BCM56218_A0_MMU_XQ36m_RESERVED_0f_SET(r,f) (r).mmu_xq36[0]=(((r).mmu_xq36[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_MMU_XQ36m_IMIRRORf_GET(r) ((((r).mmu_xq36[0]) >> 18) & 0x1)
#define BCM56218_A0_MMU_XQ36m_IMIRRORf_SET(r,f) (r).mmu_xq36[0]=(((r).mmu_xq36[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_MMU_XQ36m_EMIRRORf_GET(r) ((((r).mmu_xq36[0]) >> 19) & 0x1)
#define BCM56218_A0_MMU_XQ36m_EMIRRORf_SET(r,f) (r).mmu_xq36[0]=(((r).mmu_xq36[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ36.
 *
 */
#define BCM56218_A0_READ_MMU_XQ36m(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_XQ36m,i,(m._mmu_xq36),1)
#define BCM56218_A0_WRITE_MMU_XQ36m(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_XQ36m,i,&(m._mmu_xq36),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ36m BCM56218_A0_MMU_XQ36m
#define MMU_XQ36m_MIN BCM56218_A0_MMU_XQ36m_MIN
#define MMU_XQ36m_MAX BCM56218_A0_MMU_XQ36m_MAX
#define MMU_XQ36m_CMAX(u) BCM56218_A0_MMU_XQ36m_CMAX(u)
#define MMU_XQ36m_SIZE BCM56218_A0_MMU_XQ36m_SIZE
typedef BCM56218_A0_MMU_XQ36m_t MMU_XQ36m_t;
#define MMU_XQ36m_CLR BCM56218_A0_MMU_XQ36m_CLR
#define MMU_XQ36m_SET BCM56218_A0_MMU_XQ36m_SET
#define MMU_XQ36m_GET BCM56218_A0_MMU_XQ36m_GET
#define MMU_XQ36m_PARITY_0f_GET BCM56218_A0_MMU_XQ36m_PARITY_0f_GET
#define MMU_XQ36m_PARITY_0f_SET BCM56218_A0_MMU_XQ36m_PARITY_0f_SET
#define MMU_XQ36m_L2f_GET BCM56218_A0_MMU_XQ36m_L2f_GET
#define MMU_XQ36m_L2f_SET BCM56218_A0_MMU_XQ36m_L2f_SET
#define MMU_XQ36m_PURGEf_GET BCM56218_A0_MMU_XQ36m_PURGEf_GET
#define MMU_XQ36m_PURGEf_SET BCM56218_A0_MMU_XQ36m_PURGEf_SET
#define MMU_XQ36m_PKT_PTRf_GET BCM56218_A0_MMU_XQ36m_PKT_PTRf_GET
#define MMU_XQ36m_PKT_PTRf_SET BCM56218_A0_MMU_XQ36m_PKT_PTRf_SET
#define MMU_XQ36m_RESERVED_0f_GET BCM56218_A0_MMU_XQ36m_RESERVED_0f_GET
#define MMU_XQ36m_RESERVED_0f_SET BCM56218_A0_MMU_XQ36m_RESERVED_0f_SET
#define MMU_XQ36m_IMIRRORf_GET BCM56218_A0_MMU_XQ36m_IMIRRORf_GET
#define MMU_XQ36m_IMIRRORf_SET BCM56218_A0_MMU_XQ36m_IMIRRORf_SET
#define MMU_XQ36m_EMIRRORf_GET BCM56218_A0_MMU_XQ36m_EMIRRORf_GET
#define MMU_XQ36m_EMIRRORf_SET BCM56218_A0_MMU_XQ36m_EMIRRORf_SET
#define READ_MMU_XQ36m BCM56218_A0_READ_MMU_XQ36m
#define WRITE_MMU_XQ36m BCM56218_A0_WRITE_MMU_XQ36m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_XQ36m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_XQ37
 * BLOCKS:   MMU
 * DESC:     XQ37
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     RESERVED_0       reserved for future use
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_XQ37m 0x0b694000

#define BCM56218_A0_MMU_XQ37m_MIN 0
#define BCM56218_A0_MMU_XQ37m_MAX 511
#define BCM56218_A0_MMU_XQ37m_CMAX(u) 511
#define BCM56218_A0_MMU_XQ37m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ37.
 *
 */
typedef union BCM56218_A0_MMU_XQ37m_s {
	uint32_t v[1];
	uint32_t mmu_xq37[1];
	uint32_t _mmu_xq37;
} BCM56218_A0_MMU_XQ37m_t;

#define BCM56218_A0_MMU_XQ37m_CLR(r) (r).mmu_xq37[0] = 0
#define BCM56218_A0_MMU_XQ37m_SET(r,d) (r).mmu_xq37[0] = d
#define BCM56218_A0_MMU_XQ37m_GET(r) (r).mmu_xq37[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_XQ37m_PARITY_0f_GET(r) (((r).mmu_xq37[0]) & 0x1)
#define BCM56218_A0_MMU_XQ37m_PARITY_0f_SET(r,f) (r).mmu_xq37[0]=(((r).mmu_xq37[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_MMU_XQ37m_L2f_GET(r) ((((r).mmu_xq37[0]) >> 1) & 0x1)
#define BCM56218_A0_MMU_XQ37m_L2f_SET(r,f) (r).mmu_xq37[0]=(((r).mmu_xq37[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_MMU_XQ37m_PURGEf_GET(r) ((((r).mmu_xq37[0]) >> 2) & 0x1)
#define BCM56218_A0_MMU_XQ37m_PURGEf_SET(r,f) (r).mmu_xq37[0]=(((r).mmu_xq37[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_MMU_XQ37m_PKT_PTRf_GET(r) ((((r).mmu_xq37[0]) >> 3) & 0x3fff)
#define BCM56218_A0_MMU_XQ37m_PKT_PTRf_SET(r,f) (r).mmu_xq37[0]=(((r).mmu_xq37[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56218_A0_MMU_XQ37m_RESERVED_0f_GET(r) ((((r).mmu_xq37[0]) >> 17) & 0x1)
#define BCM56218_A0_MMU_XQ37m_RESERVED_0f_SET(r,f) (r).mmu_xq37[0]=(((r).mmu_xq37[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_MMU_XQ37m_IMIRRORf_GET(r) ((((r).mmu_xq37[0]) >> 18) & 0x1)
#define BCM56218_A0_MMU_XQ37m_IMIRRORf_SET(r,f) (r).mmu_xq37[0]=(((r).mmu_xq37[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_MMU_XQ37m_EMIRRORf_GET(r) ((((r).mmu_xq37[0]) >> 19) & 0x1)
#define BCM56218_A0_MMU_XQ37m_EMIRRORf_SET(r,f) (r).mmu_xq37[0]=(((r).mmu_xq37[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ37.
 *
 */
#define BCM56218_A0_READ_MMU_XQ37m(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_XQ37m,i,(m._mmu_xq37),1)
#define BCM56218_A0_WRITE_MMU_XQ37m(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_XQ37m,i,&(m._mmu_xq37),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ37m BCM56218_A0_MMU_XQ37m
#define MMU_XQ37m_MIN BCM56218_A0_MMU_XQ37m_MIN
#define MMU_XQ37m_MAX BCM56218_A0_MMU_XQ37m_MAX
#define MMU_XQ37m_CMAX(u) BCM56218_A0_MMU_XQ37m_CMAX(u)
#define MMU_XQ37m_SIZE BCM56218_A0_MMU_XQ37m_SIZE
typedef BCM56218_A0_MMU_XQ37m_t MMU_XQ37m_t;
#define MMU_XQ37m_CLR BCM56218_A0_MMU_XQ37m_CLR
#define MMU_XQ37m_SET BCM56218_A0_MMU_XQ37m_SET
#define MMU_XQ37m_GET BCM56218_A0_MMU_XQ37m_GET
#define MMU_XQ37m_PARITY_0f_GET BCM56218_A0_MMU_XQ37m_PARITY_0f_GET
#define MMU_XQ37m_PARITY_0f_SET BCM56218_A0_MMU_XQ37m_PARITY_0f_SET
#define MMU_XQ37m_L2f_GET BCM56218_A0_MMU_XQ37m_L2f_GET
#define MMU_XQ37m_L2f_SET BCM56218_A0_MMU_XQ37m_L2f_SET
#define MMU_XQ37m_PURGEf_GET BCM56218_A0_MMU_XQ37m_PURGEf_GET
#define MMU_XQ37m_PURGEf_SET BCM56218_A0_MMU_XQ37m_PURGEf_SET
#define MMU_XQ37m_PKT_PTRf_GET BCM56218_A0_MMU_XQ37m_PKT_PTRf_GET
#define MMU_XQ37m_PKT_PTRf_SET BCM56218_A0_MMU_XQ37m_PKT_PTRf_SET
#define MMU_XQ37m_RESERVED_0f_GET BCM56218_A0_MMU_XQ37m_RESERVED_0f_GET
#define MMU_XQ37m_RESERVED_0f_SET BCM56218_A0_MMU_XQ37m_RESERVED_0f_SET
#define MMU_XQ37m_IMIRRORf_GET BCM56218_A0_MMU_XQ37m_IMIRRORf_GET
#define MMU_XQ37m_IMIRRORf_SET BCM56218_A0_MMU_XQ37m_IMIRRORf_SET
#define MMU_XQ37m_EMIRRORf_GET BCM56218_A0_MMU_XQ37m_EMIRRORf_GET
#define MMU_XQ37m_EMIRRORf_SET BCM56218_A0_MMU_XQ37m_EMIRRORf_SET
#define READ_MMU_XQ37m BCM56218_A0_READ_MMU_XQ37m
#define WRITE_MMU_XQ37m BCM56218_A0_WRITE_MMU_XQ37m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_XQ37m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_XQ38
 * BLOCKS:   MMU
 * DESC:     XQ38
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     RESERVED_0       reserved for future use
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_XQ38m 0x0b698000

#define BCM56218_A0_MMU_XQ38m_MIN 0
#define BCM56218_A0_MMU_XQ38m_MAX 511
#define BCM56218_A0_MMU_XQ38m_CMAX(u) 511
#define BCM56218_A0_MMU_XQ38m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ38.
 *
 */
typedef union BCM56218_A0_MMU_XQ38m_s {
	uint32_t v[1];
	uint32_t mmu_xq38[1];
	uint32_t _mmu_xq38;
} BCM56218_A0_MMU_XQ38m_t;

#define BCM56218_A0_MMU_XQ38m_CLR(r) (r).mmu_xq38[0] = 0
#define BCM56218_A0_MMU_XQ38m_SET(r,d) (r).mmu_xq38[0] = d
#define BCM56218_A0_MMU_XQ38m_GET(r) (r).mmu_xq38[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_XQ38m_PARITY_0f_GET(r) (((r).mmu_xq38[0]) & 0x1)
#define BCM56218_A0_MMU_XQ38m_PARITY_0f_SET(r,f) (r).mmu_xq38[0]=(((r).mmu_xq38[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_MMU_XQ38m_L2f_GET(r) ((((r).mmu_xq38[0]) >> 1) & 0x1)
#define BCM56218_A0_MMU_XQ38m_L2f_SET(r,f) (r).mmu_xq38[0]=(((r).mmu_xq38[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_MMU_XQ38m_PURGEf_GET(r) ((((r).mmu_xq38[0]) >> 2) & 0x1)
#define BCM56218_A0_MMU_XQ38m_PURGEf_SET(r,f) (r).mmu_xq38[0]=(((r).mmu_xq38[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_MMU_XQ38m_PKT_PTRf_GET(r) ((((r).mmu_xq38[0]) >> 3) & 0x3fff)
#define BCM56218_A0_MMU_XQ38m_PKT_PTRf_SET(r,f) (r).mmu_xq38[0]=(((r).mmu_xq38[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56218_A0_MMU_XQ38m_RESERVED_0f_GET(r) ((((r).mmu_xq38[0]) >> 17) & 0x1)
#define BCM56218_A0_MMU_XQ38m_RESERVED_0f_SET(r,f) (r).mmu_xq38[0]=(((r).mmu_xq38[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_MMU_XQ38m_IMIRRORf_GET(r) ((((r).mmu_xq38[0]) >> 18) & 0x1)
#define BCM56218_A0_MMU_XQ38m_IMIRRORf_SET(r,f) (r).mmu_xq38[0]=(((r).mmu_xq38[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_MMU_XQ38m_EMIRRORf_GET(r) ((((r).mmu_xq38[0]) >> 19) & 0x1)
#define BCM56218_A0_MMU_XQ38m_EMIRRORf_SET(r,f) (r).mmu_xq38[0]=(((r).mmu_xq38[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ38.
 *
 */
#define BCM56218_A0_READ_MMU_XQ38m(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_XQ38m,i,(m._mmu_xq38),1)
#define BCM56218_A0_WRITE_MMU_XQ38m(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_XQ38m,i,&(m._mmu_xq38),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ38m BCM56218_A0_MMU_XQ38m
#define MMU_XQ38m_MIN BCM56218_A0_MMU_XQ38m_MIN
#define MMU_XQ38m_MAX BCM56218_A0_MMU_XQ38m_MAX
#define MMU_XQ38m_CMAX(u) BCM56218_A0_MMU_XQ38m_CMAX(u)
#define MMU_XQ38m_SIZE BCM56218_A0_MMU_XQ38m_SIZE
typedef BCM56218_A0_MMU_XQ38m_t MMU_XQ38m_t;
#define MMU_XQ38m_CLR BCM56218_A0_MMU_XQ38m_CLR
#define MMU_XQ38m_SET BCM56218_A0_MMU_XQ38m_SET
#define MMU_XQ38m_GET BCM56218_A0_MMU_XQ38m_GET
#define MMU_XQ38m_PARITY_0f_GET BCM56218_A0_MMU_XQ38m_PARITY_0f_GET
#define MMU_XQ38m_PARITY_0f_SET BCM56218_A0_MMU_XQ38m_PARITY_0f_SET
#define MMU_XQ38m_L2f_GET BCM56218_A0_MMU_XQ38m_L2f_GET
#define MMU_XQ38m_L2f_SET BCM56218_A0_MMU_XQ38m_L2f_SET
#define MMU_XQ38m_PURGEf_GET BCM56218_A0_MMU_XQ38m_PURGEf_GET
#define MMU_XQ38m_PURGEf_SET BCM56218_A0_MMU_XQ38m_PURGEf_SET
#define MMU_XQ38m_PKT_PTRf_GET BCM56218_A0_MMU_XQ38m_PKT_PTRf_GET
#define MMU_XQ38m_PKT_PTRf_SET BCM56218_A0_MMU_XQ38m_PKT_PTRf_SET
#define MMU_XQ38m_RESERVED_0f_GET BCM56218_A0_MMU_XQ38m_RESERVED_0f_GET
#define MMU_XQ38m_RESERVED_0f_SET BCM56218_A0_MMU_XQ38m_RESERVED_0f_SET
#define MMU_XQ38m_IMIRRORf_GET BCM56218_A0_MMU_XQ38m_IMIRRORf_GET
#define MMU_XQ38m_IMIRRORf_SET BCM56218_A0_MMU_XQ38m_IMIRRORf_SET
#define MMU_XQ38m_EMIRRORf_GET BCM56218_A0_MMU_XQ38m_EMIRRORf_GET
#define MMU_XQ38m_EMIRRORf_SET BCM56218_A0_MMU_XQ38m_EMIRRORf_SET
#define READ_MMU_XQ38m BCM56218_A0_READ_MMU_XQ38m
#define WRITE_MMU_XQ38m BCM56218_A0_WRITE_MMU_XQ38m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_XQ38m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_XQ39
 * BLOCKS:   MMU
 * DESC:     XQ39
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     RESERVED_0       reserved for future use
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_XQ39m 0x0b69c000

#define BCM56218_A0_MMU_XQ39m_MIN 0
#define BCM56218_A0_MMU_XQ39m_MAX 511
#define BCM56218_A0_MMU_XQ39m_CMAX(u) 511
#define BCM56218_A0_MMU_XQ39m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ39.
 *
 */
typedef union BCM56218_A0_MMU_XQ39m_s {
	uint32_t v[1];
	uint32_t mmu_xq39[1];
	uint32_t _mmu_xq39;
} BCM56218_A0_MMU_XQ39m_t;

#define BCM56218_A0_MMU_XQ39m_CLR(r) (r).mmu_xq39[0] = 0
#define BCM56218_A0_MMU_XQ39m_SET(r,d) (r).mmu_xq39[0] = d
#define BCM56218_A0_MMU_XQ39m_GET(r) (r).mmu_xq39[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_XQ39m_PARITY_0f_GET(r) (((r).mmu_xq39[0]) & 0x1)
#define BCM56218_A0_MMU_XQ39m_PARITY_0f_SET(r,f) (r).mmu_xq39[0]=(((r).mmu_xq39[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_MMU_XQ39m_L2f_GET(r) ((((r).mmu_xq39[0]) >> 1) & 0x1)
#define BCM56218_A0_MMU_XQ39m_L2f_SET(r,f) (r).mmu_xq39[0]=(((r).mmu_xq39[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_MMU_XQ39m_PURGEf_GET(r) ((((r).mmu_xq39[0]) >> 2) & 0x1)
#define BCM56218_A0_MMU_XQ39m_PURGEf_SET(r,f) (r).mmu_xq39[0]=(((r).mmu_xq39[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_MMU_XQ39m_PKT_PTRf_GET(r) ((((r).mmu_xq39[0]) >> 3) & 0x3fff)
#define BCM56218_A0_MMU_XQ39m_PKT_PTRf_SET(r,f) (r).mmu_xq39[0]=(((r).mmu_xq39[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56218_A0_MMU_XQ39m_RESERVED_0f_GET(r) ((((r).mmu_xq39[0]) >> 17) & 0x1)
#define BCM56218_A0_MMU_XQ39m_RESERVED_0f_SET(r,f) (r).mmu_xq39[0]=(((r).mmu_xq39[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_MMU_XQ39m_IMIRRORf_GET(r) ((((r).mmu_xq39[0]) >> 18) & 0x1)
#define BCM56218_A0_MMU_XQ39m_IMIRRORf_SET(r,f) (r).mmu_xq39[0]=(((r).mmu_xq39[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_MMU_XQ39m_EMIRRORf_GET(r) ((((r).mmu_xq39[0]) >> 19) & 0x1)
#define BCM56218_A0_MMU_XQ39m_EMIRRORf_SET(r,f) (r).mmu_xq39[0]=(((r).mmu_xq39[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ39.
 *
 */
#define BCM56218_A0_READ_MMU_XQ39m(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_XQ39m,i,(m._mmu_xq39),1)
#define BCM56218_A0_WRITE_MMU_XQ39m(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_XQ39m,i,&(m._mmu_xq39),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ39m BCM56218_A0_MMU_XQ39m
#define MMU_XQ39m_MIN BCM56218_A0_MMU_XQ39m_MIN
#define MMU_XQ39m_MAX BCM56218_A0_MMU_XQ39m_MAX
#define MMU_XQ39m_CMAX(u) BCM56218_A0_MMU_XQ39m_CMAX(u)
#define MMU_XQ39m_SIZE BCM56218_A0_MMU_XQ39m_SIZE
typedef BCM56218_A0_MMU_XQ39m_t MMU_XQ39m_t;
#define MMU_XQ39m_CLR BCM56218_A0_MMU_XQ39m_CLR
#define MMU_XQ39m_SET BCM56218_A0_MMU_XQ39m_SET
#define MMU_XQ39m_GET BCM56218_A0_MMU_XQ39m_GET
#define MMU_XQ39m_PARITY_0f_GET BCM56218_A0_MMU_XQ39m_PARITY_0f_GET
#define MMU_XQ39m_PARITY_0f_SET BCM56218_A0_MMU_XQ39m_PARITY_0f_SET
#define MMU_XQ39m_L2f_GET BCM56218_A0_MMU_XQ39m_L2f_GET
#define MMU_XQ39m_L2f_SET BCM56218_A0_MMU_XQ39m_L2f_SET
#define MMU_XQ39m_PURGEf_GET BCM56218_A0_MMU_XQ39m_PURGEf_GET
#define MMU_XQ39m_PURGEf_SET BCM56218_A0_MMU_XQ39m_PURGEf_SET
#define MMU_XQ39m_PKT_PTRf_GET BCM56218_A0_MMU_XQ39m_PKT_PTRf_GET
#define MMU_XQ39m_PKT_PTRf_SET BCM56218_A0_MMU_XQ39m_PKT_PTRf_SET
#define MMU_XQ39m_RESERVED_0f_GET BCM56218_A0_MMU_XQ39m_RESERVED_0f_GET
#define MMU_XQ39m_RESERVED_0f_SET BCM56218_A0_MMU_XQ39m_RESERVED_0f_SET
#define MMU_XQ39m_IMIRRORf_GET BCM56218_A0_MMU_XQ39m_IMIRRORf_GET
#define MMU_XQ39m_IMIRRORf_SET BCM56218_A0_MMU_XQ39m_IMIRRORf_SET
#define MMU_XQ39m_EMIRRORf_GET BCM56218_A0_MMU_XQ39m_EMIRRORf_GET
#define MMU_XQ39m_EMIRRORf_SET BCM56218_A0_MMU_XQ39m_EMIRRORf_SET
#define READ_MMU_XQ39m BCM56218_A0_READ_MMU_XQ39m
#define WRITE_MMU_XQ39m BCM56218_A0_WRITE_MMU_XQ39m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_XQ39m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_XQ4
 * BLOCKS:   MMU
 * DESC:     XQ4
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     RESERVED_0       reserved for future use
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_XQ4m 0x0b610000

#define BCM56218_A0_MMU_XQ4m_MIN 0
#define BCM56218_A0_MMU_XQ4m_MAX 767
#define BCM56218_A0_MMU_XQ4m_CMAX(u) 767
#define BCM56218_A0_MMU_XQ4m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ4.
 *
 */
typedef union BCM56218_A0_MMU_XQ4m_s {
	uint32_t v[1];
	uint32_t mmu_xq4[1];
	uint32_t _mmu_xq4;
} BCM56218_A0_MMU_XQ4m_t;

#define BCM56218_A0_MMU_XQ4m_CLR(r) (r).mmu_xq4[0] = 0
#define BCM56218_A0_MMU_XQ4m_SET(r,d) (r).mmu_xq4[0] = d
#define BCM56218_A0_MMU_XQ4m_GET(r) (r).mmu_xq4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_XQ4m_PARITY_0f_GET(r) (((r).mmu_xq4[0]) & 0x1)
#define BCM56218_A0_MMU_XQ4m_PARITY_0f_SET(r,f) (r).mmu_xq4[0]=(((r).mmu_xq4[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_MMU_XQ4m_L2f_GET(r) ((((r).mmu_xq4[0]) >> 1) & 0x1)
#define BCM56218_A0_MMU_XQ4m_L2f_SET(r,f) (r).mmu_xq4[0]=(((r).mmu_xq4[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_MMU_XQ4m_PURGEf_GET(r) ((((r).mmu_xq4[0]) >> 2) & 0x1)
#define BCM56218_A0_MMU_XQ4m_PURGEf_SET(r,f) (r).mmu_xq4[0]=(((r).mmu_xq4[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_MMU_XQ4m_PKT_PTRf_GET(r) ((((r).mmu_xq4[0]) >> 3) & 0x3fff)
#define BCM56218_A0_MMU_XQ4m_PKT_PTRf_SET(r,f) (r).mmu_xq4[0]=(((r).mmu_xq4[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56218_A0_MMU_XQ4m_RESERVED_0f_GET(r) ((((r).mmu_xq4[0]) >> 17) & 0x1)
#define BCM56218_A0_MMU_XQ4m_RESERVED_0f_SET(r,f) (r).mmu_xq4[0]=(((r).mmu_xq4[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_MMU_XQ4m_IMIRRORf_GET(r) ((((r).mmu_xq4[0]) >> 18) & 0x1)
#define BCM56218_A0_MMU_XQ4m_IMIRRORf_SET(r,f) (r).mmu_xq4[0]=(((r).mmu_xq4[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_MMU_XQ4m_EMIRRORf_GET(r) ((((r).mmu_xq4[0]) >> 19) & 0x1)
#define BCM56218_A0_MMU_XQ4m_EMIRRORf_SET(r,f) (r).mmu_xq4[0]=(((r).mmu_xq4[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ4.
 *
 */
#define BCM56218_A0_READ_MMU_XQ4m(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_XQ4m,i,(m._mmu_xq4),1)
#define BCM56218_A0_WRITE_MMU_XQ4m(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_XQ4m,i,&(m._mmu_xq4),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ4m BCM56218_A0_MMU_XQ4m
#define MMU_XQ4m_MIN BCM56218_A0_MMU_XQ4m_MIN
#define MMU_XQ4m_MAX BCM56218_A0_MMU_XQ4m_MAX
#define MMU_XQ4m_CMAX(u) BCM56218_A0_MMU_XQ4m_CMAX(u)
#define MMU_XQ4m_SIZE BCM56218_A0_MMU_XQ4m_SIZE
typedef BCM56218_A0_MMU_XQ4m_t MMU_XQ4m_t;
#define MMU_XQ4m_CLR BCM56218_A0_MMU_XQ4m_CLR
#define MMU_XQ4m_SET BCM56218_A0_MMU_XQ4m_SET
#define MMU_XQ4m_GET BCM56218_A0_MMU_XQ4m_GET
#define MMU_XQ4m_PARITY_0f_GET BCM56218_A0_MMU_XQ4m_PARITY_0f_GET
#define MMU_XQ4m_PARITY_0f_SET BCM56218_A0_MMU_XQ4m_PARITY_0f_SET
#define MMU_XQ4m_L2f_GET BCM56218_A0_MMU_XQ4m_L2f_GET
#define MMU_XQ4m_L2f_SET BCM56218_A0_MMU_XQ4m_L2f_SET
#define MMU_XQ4m_PURGEf_GET BCM56218_A0_MMU_XQ4m_PURGEf_GET
#define MMU_XQ4m_PURGEf_SET BCM56218_A0_MMU_XQ4m_PURGEf_SET
#define MMU_XQ4m_PKT_PTRf_GET BCM56218_A0_MMU_XQ4m_PKT_PTRf_GET
#define MMU_XQ4m_PKT_PTRf_SET BCM56218_A0_MMU_XQ4m_PKT_PTRf_SET
#define MMU_XQ4m_RESERVED_0f_GET BCM56218_A0_MMU_XQ4m_RESERVED_0f_GET
#define MMU_XQ4m_RESERVED_0f_SET BCM56218_A0_MMU_XQ4m_RESERVED_0f_SET
#define MMU_XQ4m_IMIRRORf_GET BCM56218_A0_MMU_XQ4m_IMIRRORf_GET
#define MMU_XQ4m_IMIRRORf_SET BCM56218_A0_MMU_XQ4m_IMIRRORf_SET
#define MMU_XQ4m_EMIRRORf_GET BCM56218_A0_MMU_XQ4m_EMIRRORf_GET
#define MMU_XQ4m_EMIRRORf_SET BCM56218_A0_MMU_XQ4m_EMIRRORf_SET
#define READ_MMU_XQ4m BCM56218_A0_READ_MMU_XQ4m
#define WRITE_MMU_XQ4m BCM56218_A0_WRITE_MMU_XQ4m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_XQ4m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_XQ40
 * BLOCKS:   MMU
 * DESC:     XQ40
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     RESERVED_0       reserved for future use
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_XQ40m 0x0b6a0000

#define BCM56218_A0_MMU_XQ40m_MIN 0
#define BCM56218_A0_MMU_XQ40m_MAX 511
#define BCM56218_A0_MMU_XQ40m_CMAX(u) 511
#define BCM56218_A0_MMU_XQ40m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ40.
 *
 */
typedef union BCM56218_A0_MMU_XQ40m_s {
	uint32_t v[1];
	uint32_t mmu_xq40[1];
	uint32_t _mmu_xq40;
} BCM56218_A0_MMU_XQ40m_t;

#define BCM56218_A0_MMU_XQ40m_CLR(r) (r).mmu_xq40[0] = 0
#define BCM56218_A0_MMU_XQ40m_SET(r,d) (r).mmu_xq40[0] = d
#define BCM56218_A0_MMU_XQ40m_GET(r) (r).mmu_xq40[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_XQ40m_PARITY_0f_GET(r) (((r).mmu_xq40[0]) & 0x1)
#define BCM56218_A0_MMU_XQ40m_PARITY_0f_SET(r,f) (r).mmu_xq40[0]=(((r).mmu_xq40[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_MMU_XQ40m_L2f_GET(r) ((((r).mmu_xq40[0]) >> 1) & 0x1)
#define BCM56218_A0_MMU_XQ40m_L2f_SET(r,f) (r).mmu_xq40[0]=(((r).mmu_xq40[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_MMU_XQ40m_PURGEf_GET(r) ((((r).mmu_xq40[0]) >> 2) & 0x1)
#define BCM56218_A0_MMU_XQ40m_PURGEf_SET(r,f) (r).mmu_xq40[0]=(((r).mmu_xq40[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_MMU_XQ40m_PKT_PTRf_GET(r) ((((r).mmu_xq40[0]) >> 3) & 0x3fff)
#define BCM56218_A0_MMU_XQ40m_PKT_PTRf_SET(r,f) (r).mmu_xq40[0]=(((r).mmu_xq40[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56218_A0_MMU_XQ40m_RESERVED_0f_GET(r) ((((r).mmu_xq40[0]) >> 17) & 0x1)
#define BCM56218_A0_MMU_XQ40m_RESERVED_0f_SET(r,f) (r).mmu_xq40[0]=(((r).mmu_xq40[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_MMU_XQ40m_IMIRRORf_GET(r) ((((r).mmu_xq40[0]) >> 18) & 0x1)
#define BCM56218_A0_MMU_XQ40m_IMIRRORf_SET(r,f) (r).mmu_xq40[0]=(((r).mmu_xq40[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_MMU_XQ40m_EMIRRORf_GET(r) ((((r).mmu_xq40[0]) >> 19) & 0x1)
#define BCM56218_A0_MMU_XQ40m_EMIRRORf_SET(r,f) (r).mmu_xq40[0]=(((r).mmu_xq40[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ40.
 *
 */
#define BCM56218_A0_READ_MMU_XQ40m(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_XQ40m,i,(m._mmu_xq40),1)
#define BCM56218_A0_WRITE_MMU_XQ40m(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_XQ40m,i,&(m._mmu_xq40),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ40m BCM56218_A0_MMU_XQ40m
#define MMU_XQ40m_MIN BCM56218_A0_MMU_XQ40m_MIN
#define MMU_XQ40m_MAX BCM56218_A0_MMU_XQ40m_MAX
#define MMU_XQ40m_CMAX(u) BCM56218_A0_MMU_XQ40m_CMAX(u)
#define MMU_XQ40m_SIZE BCM56218_A0_MMU_XQ40m_SIZE
typedef BCM56218_A0_MMU_XQ40m_t MMU_XQ40m_t;
#define MMU_XQ40m_CLR BCM56218_A0_MMU_XQ40m_CLR
#define MMU_XQ40m_SET BCM56218_A0_MMU_XQ40m_SET
#define MMU_XQ40m_GET BCM56218_A0_MMU_XQ40m_GET
#define MMU_XQ40m_PARITY_0f_GET BCM56218_A0_MMU_XQ40m_PARITY_0f_GET
#define MMU_XQ40m_PARITY_0f_SET BCM56218_A0_MMU_XQ40m_PARITY_0f_SET
#define MMU_XQ40m_L2f_GET BCM56218_A0_MMU_XQ40m_L2f_GET
#define MMU_XQ40m_L2f_SET BCM56218_A0_MMU_XQ40m_L2f_SET
#define MMU_XQ40m_PURGEf_GET BCM56218_A0_MMU_XQ40m_PURGEf_GET
#define MMU_XQ40m_PURGEf_SET BCM56218_A0_MMU_XQ40m_PURGEf_SET
#define MMU_XQ40m_PKT_PTRf_GET BCM56218_A0_MMU_XQ40m_PKT_PTRf_GET
#define MMU_XQ40m_PKT_PTRf_SET BCM56218_A0_MMU_XQ40m_PKT_PTRf_SET
#define MMU_XQ40m_RESERVED_0f_GET BCM56218_A0_MMU_XQ40m_RESERVED_0f_GET
#define MMU_XQ40m_RESERVED_0f_SET BCM56218_A0_MMU_XQ40m_RESERVED_0f_SET
#define MMU_XQ40m_IMIRRORf_GET BCM56218_A0_MMU_XQ40m_IMIRRORf_GET
#define MMU_XQ40m_IMIRRORf_SET BCM56218_A0_MMU_XQ40m_IMIRRORf_SET
#define MMU_XQ40m_EMIRRORf_GET BCM56218_A0_MMU_XQ40m_EMIRRORf_GET
#define MMU_XQ40m_EMIRRORf_SET BCM56218_A0_MMU_XQ40m_EMIRRORf_SET
#define READ_MMU_XQ40m BCM56218_A0_READ_MMU_XQ40m
#define WRITE_MMU_XQ40m BCM56218_A0_WRITE_MMU_XQ40m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_XQ40m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_XQ41
 * BLOCKS:   MMU
 * DESC:     XQ41
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     RESERVED_0       reserved for future use
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_XQ41m 0x0b6a4000

#define BCM56218_A0_MMU_XQ41m_MIN 0
#define BCM56218_A0_MMU_XQ41m_MAX 511
#define BCM56218_A0_MMU_XQ41m_CMAX(u) 511
#define BCM56218_A0_MMU_XQ41m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ41.
 *
 */
typedef union BCM56218_A0_MMU_XQ41m_s {
	uint32_t v[1];
	uint32_t mmu_xq41[1];
	uint32_t _mmu_xq41;
} BCM56218_A0_MMU_XQ41m_t;

#define BCM56218_A0_MMU_XQ41m_CLR(r) (r).mmu_xq41[0] = 0
#define BCM56218_A0_MMU_XQ41m_SET(r,d) (r).mmu_xq41[0] = d
#define BCM56218_A0_MMU_XQ41m_GET(r) (r).mmu_xq41[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_XQ41m_PARITY_0f_GET(r) (((r).mmu_xq41[0]) & 0x1)
#define BCM56218_A0_MMU_XQ41m_PARITY_0f_SET(r,f) (r).mmu_xq41[0]=(((r).mmu_xq41[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_MMU_XQ41m_L2f_GET(r) ((((r).mmu_xq41[0]) >> 1) & 0x1)
#define BCM56218_A0_MMU_XQ41m_L2f_SET(r,f) (r).mmu_xq41[0]=(((r).mmu_xq41[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_MMU_XQ41m_PURGEf_GET(r) ((((r).mmu_xq41[0]) >> 2) & 0x1)
#define BCM56218_A0_MMU_XQ41m_PURGEf_SET(r,f) (r).mmu_xq41[0]=(((r).mmu_xq41[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_MMU_XQ41m_PKT_PTRf_GET(r) ((((r).mmu_xq41[0]) >> 3) & 0x3fff)
#define BCM56218_A0_MMU_XQ41m_PKT_PTRf_SET(r,f) (r).mmu_xq41[0]=(((r).mmu_xq41[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56218_A0_MMU_XQ41m_RESERVED_0f_GET(r) ((((r).mmu_xq41[0]) >> 17) & 0x1)
#define BCM56218_A0_MMU_XQ41m_RESERVED_0f_SET(r,f) (r).mmu_xq41[0]=(((r).mmu_xq41[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_MMU_XQ41m_IMIRRORf_GET(r) ((((r).mmu_xq41[0]) >> 18) & 0x1)
#define BCM56218_A0_MMU_XQ41m_IMIRRORf_SET(r,f) (r).mmu_xq41[0]=(((r).mmu_xq41[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_MMU_XQ41m_EMIRRORf_GET(r) ((((r).mmu_xq41[0]) >> 19) & 0x1)
#define BCM56218_A0_MMU_XQ41m_EMIRRORf_SET(r,f) (r).mmu_xq41[0]=(((r).mmu_xq41[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ41.
 *
 */
#define BCM56218_A0_READ_MMU_XQ41m(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_XQ41m,i,(m._mmu_xq41),1)
#define BCM56218_A0_WRITE_MMU_XQ41m(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_XQ41m,i,&(m._mmu_xq41),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ41m BCM56218_A0_MMU_XQ41m
#define MMU_XQ41m_MIN BCM56218_A0_MMU_XQ41m_MIN
#define MMU_XQ41m_MAX BCM56218_A0_MMU_XQ41m_MAX
#define MMU_XQ41m_CMAX(u) BCM56218_A0_MMU_XQ41m_CMAX(u)
#define MMU_XQ41m_SIZE BCM56218_A0_MMU_XQ41m_SIZE
typedef BCM56218_A0_MMU_XQ41m_t MMU_XQ41m_t;
#define MMU_XQ41m_CLR BCM56218_A0_MMU_XQ41m_CLR
#define MMU_XQ41m_SET BCM56218_A0_MMU_XQ41m_SET
#define MMU_XQ41m_GET BCM56218_A0_MMU_XQ41m_GET
#define MMU_XQ41m_PARITY_0f_GET BCM56218_A0_MMU_XQ41m_PARITY_0f_GET
#define MMU_XQ41m_PARITY_0f_SET BCM56218_A0_MMU_XQ41m_PARITY_0f_SET
#define MMU_XQ41m_L2f_GET BCM56218_A0_MMU_XQ41m_L2f_GET
#define MMU_XQ41m_L2f_SET BCM56218_A0_MMU_XQ41m_L2f_SET
#define MMU_XQ41m_PURGEf_GET BCM56218_A0_MMU_XQ41m_PURGEf_GET
#define MMU_XQ41m_PURGEf_SET BCM56218_A0_MMU_XQ41m_PURGEf_SET
#define MMU_XQ41m_PKT_PTRf_GET BCM56218_A0_MMU_XQ41m_PKT_PTRf_GET
#define MMU_XQ41m_PKT_PTRf_SET BCM56218_A0_MMU_XQ41m_PKT_PTRf_SET
#define MMU_XQ41m_RESERVED_0f_GET BCM56218_A0_MMU_XQ41m_RESERVED_0f_GET
#define MMU_XQ41m_RESERVED_0f_SET BCM56218_A0_MMU_XQ41m_RESERVED_0f_SET
#define MMU_XQ41m_IMIRRORf_GET BCM56218_A0_MMU_XQ41m_IMIRRORf_GET
#define MMU_XQ41m_IMIRRORf_SET BCM56218_A0_MMU_XQ41m_IMIRRORf_SET
#define MMU_XQ41m_EMIRRORf_GET BCM56218_A0_MMU_XQ41m_EMIRRORf_GET
#define MMU_XQ41m_EMIRRORf_SET BCM56218_A0_MMU_XQ41m_EMIRRORf_SET
#define READ_MMU_XQ41m BCM56218_A0_READ_MMU_XQ41m
#define WRITE_MMU_XQ41m BCM56218_A0_WRITE_MMU_XQ41m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_XQ41m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_XQ42
 * BLOCKS:   MMU
 * DESC:     XQ42
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     RESERVED_0       reserved for future use
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_XQ42m 0x0b6a8000

#define BCM56218_A0_MMU_XQ42m_MIN 0
#define BCM56218_A0_MMU_XQ42m_MAX 511
#define BCM56218_A0_MMU_XQ42m_CMAX(u) 511
#define BCM56218_A0_MMU_XQ42m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ42.
 *
 */
typedef union BCM56218_A0_MMU_XQ42m_s {
	uint32_t v[1];
	uint32_t mmu_xq42[1];
	uint32_t _mmu_xq42;
} BCM56218_A0_MMU_XQ42m_t;

#define BCM56218_A0_MMU_XQ42m_CLR(r) (r).mmu_xq42[0] = 0
#define BCM56218_A0_MMU_XQ42m_SET(r,d) (r).mmu_xq42[0] = d
#define BCM56218_A0_MMU_XQ42m_GET(r) (r).mmu_xq42[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_XQ42m_PARITY_0f_GET(r) (((r).mmu_xq42[0]) & 0x1)
#define BCM56218_A0_MMU_XQ42m_PARITY_0f_SET(r,f) (r).mmu_xq42[0]=(((r).mmu_xq42[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_MMU_XQ42m_L2f_GET(r) ((((r).mmu_xq42[0]) >> 1) & 0x1)
#define BCM56218_A0_MMU_XQ42m_L2f_SET(r,f) (r).mmu_xq42[0]=(((r).mmu_xq42[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_MMU_XQ42m_PURGEf_GET(r) ((((r).mmu_xq42[0]) >> 2) & 0x1)
#define BCM56218_A0_MMU_XQ42m_PURGEf_SET(r,f) (r).mmu_xq42[0]=(((r).mmu_xq42[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_MMU_XQ42m_PKT_PTRf_GET(r) ((((r).mmu_xq42[0]) >> 3) & 0x3fff)
#define BCM56218_A0_MMU_XQ42m_PKT_PTRf_SET(r,f) (r).mmu_xq42[0]=(((r).mmu_xq42[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56218_A0_MMU_XQ42m_RESERVED_0f_GET(r) ((((r).mmu_xq42[0]) >> 17) & 0x1)
#define BCM56218_A0_MMU_XQ42m_RESERVED_0f_SET(r,f) (r).mmu_xq42[0]=(((r).mmu_xq42[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_MMU_XQ42m_IMIRRORf_GET(r) ((((r).mmu_xq42[0]) >> 18) & 0x1)
#define BCM56218_A0_MMU_XQ42m_IMIRRORf_SET(r,f) (r).mmu_xq42[0]=(((r).mmu_xq42[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_MMU_XQ42m_EMIRRORf_GET(r) ((((r).mmu_xq42[0]) >> 19) & 0x1)
#define BCM56218_A0_MMU_XQ42m_EMIRRORf_SET(r,f) (r).mmu_xq42[0]=(((r).mmu_xq42[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ42.
 *
 */
#define BCM56218_A0_READ_MMU_XQ42m(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_XQ42m,i,(m._mmu_xq42),1)
#define BCM56218_A0_WRITE_MMU_XQ42m(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_XQ42m,i,&(m._mmu_xq42),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ42m BCM56218_A0_MMU_XQ42m
#define MMU_XQ42m_MIN BCM56218_A0_MMU_XQ42m_MIN
#define MMU_XQ42m_MAX BCM56218_A0_MMU_XQ42m_MAX
#define MMU_XQ42m_CMAX(u) BCM56218_A0_MMU_XQ42m_CMAX(u)
#define MMU_XQ42m_SIZE BCM56218_A0_MMU_XQ42m_SIZE
typedef BCM56218_A0_MMU_XQ42m_t MMU_XQ42m_t;
#define MMU_XQ42m_CLR BCM56218_A0_MMU_XQ42m_CLR
#define MMU_XQ42m_SET BCM56218_A0_MMU_XQ42m_SET
#define MMU_XQ42m_GET BCM56218_A0_MMU_XQ42m_GET
#define MMU_XQ42m_PARITY_0f_GET BCM56218_A0_MMU_XQ42m_PARITY_0f_GET
#define MMU_XQ42m_PARITY_0f_SET BCM56218_A0_MMU_XQ42m_PARITY_0f_SET
#define MMU_XQ42m_L2f_GET BCM56218_A0_MMU_XQ42m_L2f_GET
#define MMU_XQ42m_L2f_SET BCM56218_A0_MMU_XQ42m_L2f_SET
#define MMU_XQ42m_PURGEf_GET BCM56218_A0_MMU_XQ42m_PURGEf_GET
#define MMU_XQ42m_PURGEf_SET BCM56218_A0_MMU_XQ42m_PURGEf_SET
#define MMU_XQ42m_PKT_PTRf_GET BCM56218_A0_MMU_XQ42m_PKT_PTRf_GET
#define MMU_XQ42m_PKT_PTRf_SET BCM56218_A0_MMU_XQ42m_PKT_PTRf_SET
#define MMU_XQ42m_RESERVED_0f_GET BCM56218_A0_MMU_XQ42m_RESERVED_0f_GET
#define MMU_XQ42m_RESERVED_0f_SET BCM56218_A0_MMU_XQ42m_RESERVED_0f_SET
#define MMU_XQ42m_IMIRRORf_GET BCM56218_A0_MMU_XQ42m_IMIRRORf_GET
#define MMU_XQ42m_IMIRRORf_SET BCM56218_A0_MMU_XQ42m_IMIRRORf_SET
#define MMU_XQ42m_EMIRRORf_GET BCM56218_A0_MMU_XQ42m_EMIRRORf_GET
#define MMU_XQ42m_EMIRRORf_SET BCM56218_A0_MMU_XQ42m_EMIRRORf_SET
#define READ_MMU_XQ42m BCM56218_A0_READ_MMU_XQ42m
#define WRITE_MMU_XQ42m BCM56218_A0_WRITE_MMU_XQ42m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_XQ42m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_XQ43
 * BLOCKS:   MMU
 * DESC:     XQ43
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     RESERVED_0       reserved for future use
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_XQ43m 0x0b6ac000

#define BCM56218_A0_MMU_XQ43m_MIN 0
#define BCM56218_A0_MMU_XQ43m_MAX 511
#define BCM56218_A0_MMU_XQ43m_CMAX(u) 511
#define BCM56218_A0_MMU_XQ43m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ43.
 *
 */
typedef union BCM56218_A0_MMU_XQ43m_s {
	uint32_t v[1];
	uint32_t mmu_xq43[1];
	uint32_t _mmu_xq43;
} BCM56218_A0_MMU_XQ43m_t;

#define BCM56218_A0_MMU_XQ43m_CLR(r) (r).mmu_xq43[0] = 0
#define BCM56218_A0_MMU_XQ43m_SET(r,d) (r).mmu_xq43[0] = d
#define BCM56218_A0_MMU_XQ43m_GET(r) (r).mmu_xq43[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_XQ43m_PARITY_0f_GET(r) (((r).mmu_xq43[0]) & 0x1)
#define BCM56218_A0_MMU_XQ43m_PARITY_0f_SET(r,f) (r).mmu_xq43[0]=(((r).mmu_xq43[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_MMU_XQ43m_L2f_GET(r) ((((r).mmu_xq43[0]) >> 1) & 0x1)
#define BCM56218_A0_MMU_XQ43m_L2f_SET(r,f) (r).mmu_xq43[0]=(((r).mmu_xq43[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_MMU_XQ43m_PURGEf_GET(r) ((((r).mmu_xq43[0]) >> 2) & 0x1)
#define BCM56218_A0_MMU_XQ43m_PURGEf_SET(r,f) (r).mmu_xq43[0]=(((r).mmu_xq43[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_MMU_XQ43m_PKT_PTRf_GET(r) ((((r).mmu_xq43[0]) >> 3) & 0x3fff)
#define BCM56218_A0_MMU_XQ43m_PKT_PTRf_SET(r,f) (r).mmu_xq43[0]=(((r).mmu_xq43[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56218_A0_MMU_XQ43m_RESERVED_0f_GET(r) ((((r).mmu_xq43[0]) >> 17) & 0x1)
#define BCM56218_A0_MMU_XQ43m_RESERVED_0f_SET(r,f) (r).mmu_xq43[0]=(((r).mmu_xq43[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_MMU_XQ43m_IMIRRORf_GET(r) ((((r).mmu_xq43[0]) >> 18) & 0x1)
#define BCM56218_A0_MMU_XQ43m_IMIRRORf_SET(r,f) (r).mmu_xq43[0]=(((r).mmu_xq43[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_MMU_XQ43m_EMIRRORf_GET(r) ((((r).mmu_xq43[0]) >> 19) & 0x1)
#define BCM56218_A0_MMU_XQ43m_EMIRRORf_SET(r,f) (r).mmu_xq43[0]=(((r).mmu_xq43[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ43.
 *
 */
#define BCM56218_A0_READ_MMU_XQ43m(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_XQ43m,i,(m._mmu_xq43),1)
#define BCM56218_A0_WRITE_MMU_XQ43m(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_XQ43m,i,&(m._mmu_xq43),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ43m BCM56218_A0_MMU_XQ43m
#define MMU_XQ43m_MIN BCM56218_A0_MMU_XQ43m_MIN
#define MMU_XQ43m_MAX BCM56218_A0_MMU_XQ43m_MAX
#define MMU_XQ43m_CMAX(u) BCM56218_A0_MMU_XQ43m_CMAX(u)
#define MMU_XQ43m_SIZE BCM56218_A0_MMU_XQ43m_SIZE
typedef BCM56218_A0_MMU_XQ43m_t MMU_XQ43m_t;
#define MMU_XQ43m_CLR BCM56218_A0_MMU_XQ43m_CLR
#define MMU_XQ43m_SET BCM56218_A0_MMU_XQ43m_SET
#define MMU_XQ43m_GET BCM56218_A0_MMU_XQ43m_GET
#define MMU_XQ43m_PARITY_0f_GET BCM56218_A0_MMU_XQ43m_PARITY_0f_GET
#define MMU_XQ43m_PARITY_0f_SET BCM56218_A0_MMU_XQ43m_PARITY_0f_SET
#define MMU_XQ43m_L2f_GET BCM56218_A0_MMU_XQ43m_L2f_GET
#define MMU_XQ43m_L2f_SET BCM56218_A0_MMU_XQ43m_L2f_SET
#define MMU_XQ43m_PURGEf_GET BCM56218_A0_MMU_XQ43m_PURGEf_GET
#define MMU_XQ43m_PURGEf_SET BCM56218_A0_MMU_XQ43m_PURGEf_SET
#define MMU_XQ43m_PKT_PTRf_GET BCM56218_A0_MMU_XQ43m_PKT_PTRf_GET
#define MMU_XQ43m_PKT_PTRf_SET BCM56218_A0_MMU_XQ43m_PKT_PTRf_SET
#define MMU_XQ43m_RESERVED_0f_GET BCM56218_A0_MMU_XQ43m_RESERVED_0f_GET
#define MMU_XQ43m_RESERVED_0f_SET BCM56218_A0_MMU_XQ43m_RESERVED_0f_SET
#define MMU_XQ43m_IMIRRORf_GET BCM56218_A0_MMU_XQ43m_IMIRRORf_GET
#define MMU_XQ43m_IMIRRORf_SET BCM56218_A0_MMU_XQ43m_IMIRRORf_SET
#define MMU_XQ43m_EMIRRORf_GET BCM56218_A0_MMU_XQ43m_EMIRRORf_GET
#define MMU_XQ43m_EMIRRORf_SET BCM56218_A0_MMU_XQ43m_EMIRRORf_SET
#define READ_MMU_XQ43m BCM56218_A0_READ_MMU_XQ43m
#define WRITE_MMU_XQ43m BCM56218_A0_WRITE_MMU_XQ43m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_XQ43m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_XQ44
 * BLOCKS:   MMU
 * DESC:     XQ44
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     RESERVED_0       reserved for future use
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_XQ44m 0x0b6b0000

#define BCM56218_A0_MMU_XQ44m_MIN 0
#define BCM56218_A0_MMU_XQ44m_MAX 511
#define BCM56218_A0_MMU_XQ44m_CMAX(u) 511
#define BCM56218_A0_MMU_XQ44m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ44.
 *
 */
typedef union BCM56218_A0_MMU_XQ44m_s {
	uint32_t v[1];
	uint32_t mmu_xq44[1];
	uint32_t _mmu_xq44;
} BCM56218_A0_MMU_XQ44m_t;

#define BCM56218_A0_MMU_XQ44m_CLR(r) (r).mmu_xq44[0] = 0
#define BCM56218_A0_MMU_XQ44m_SET(r,d) (r).mmu_xq44[0] = d
#define BCM56218_A0_MMU_XQ44m_GET(r) (r).mmu_xq44[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_XQ44m_PARITY_0f_GET(r) (((r).mmu_xq44[0]) & 0x1)
#define BCM56218_A0_MMU_XQ44m_PARITY_0f_SET(r,f) (r).mmu_xq44[0]=(((r).mmu_xq44[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_MMU_XQ44m_L2f_GET(r) ((((r).mmu_xq44[0]) >> 1) & 0x1)
#define BCM56218_A0_MMU_XQ44m_L2f_SET(r,f) (r).mmu_xq44[0]=(((r).mmu_xq44[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_MMU_XQ44m_PURGEf_GET(r) ((((r).mmu_xq44[0]) >> 2) & 0x1)
#define BCM56218_A0_MMU_XQ44m_PURGEf_SET(r,f) (r).mmu_xq44[0]=(((r).mmu_xq44[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_MMU_XQ44m_PKT_PTRf_GET(r) ((((r).mmu_xq44[0]) >> 3) & 0x3fff)
#define BCM56218_A0_MMU_XQ44m_PKT_PTRf_SET(r,f) (r).mmu_xq44[0]=(((r).mmu_xq44[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56218_A0_MMU_XQ44m_RESERVED_0f_GET(r) ((((r).mmu_xq44[0]) >> 17) & 0x1)
#define BCM56218_A0_MMU_XQ44m_RESERVED_0f_SET(r,f) (r).mmu_xq44[0]=(((r).mmu_xq44[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_MMU_XQ44m_IMIRRORf_GET(r) ((((r).mmu_xq44[0]) >> 18) & 0x1)
#define BCM56218_A0_MMU_XQ44m_IMIRRORf_SET(r,f) (r).mmu_xq44[0]=(((r).mmu_xq44[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_MMU_XQ44m_EMIRRORf_GET(r) ((((r).mmu_xq44[0]) >> 19) & 0x1)
#define BCM56218_A0_MMU_XQ44m_EMIRRORf_SET(r,f) (r).mmu_xq44[0]=(((r).mmu_xq44[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ44.
 *
 */
#define BCM56218_A0_READ_MMU_XQ44m(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_XQ44m,i,(m._mmu_xq44),1)
#define BCM56218_A0_WRITE_MMU_XQ44m(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_XQ44m,i,&(m._mmu_xq44),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ44m BCM56218_A0_MMU_XQ44m
#define MMU_XQ44m_MIN BCM56218_A0_MMU_XQ44m_MIN
#define MMU_XQ44m_MAX BCM56218_A0_MMU_XQ44m_MAX
#define MMU_XQ44m_CMAX(u) BCM56218_A0_MMU_XQ44m_CMAX(u)
#define MMU_XQ44m_SIZE BCM56218_A0_MMU_XQ44m_SIZE
typedef BCM56218_A0_MMU_XQ44m_t MMU_XQ44m_t;
#define MMU_XQ44m_CLR BCM56218_A0_MMU_XQ44m_CLR
#define MMU_XQ44m_SET BCM56218_A0_MMU_XQ44m_SET
#define MMU_XQ44m_GET BCM56218_A0_MMU_XQ44m_GET
#define MMU_XQ44m_PARITY_0f_GET BCM56218_A0_MMU_XQ44m_PARITY_0f_GET
#define MMU_XQ44m_PARITY_0f_SET BCM56218_A0_MMU_XQ44m_PARITY_0f_SET
#define MMU_XQ44m_L2f_GET BCM56218_A0_MMU_XQ44m_L2f_GET
#define MMU_XQ44m_L2f_SET BCM56218_A0_MMU_XQ44m_L2f_SET
#define MMU_XQ44m_PURGEf_GET BCM56218_A0_MMU_XQ44m_PURGEf_GET
#define MMU_XQ44m_PURGEf_SET BCM56218_A0_MMU_XQ44m_PURGEf_SET
#define MMU_XQ44m_PKT_PTRf_GET BCM56218_A0_MMU_XQ44m_PKT_PTRf_GET
#define MMU_XQ44m_PKT_PTRf_SET BCM56218_A0_MMU_XQ44m_PKT_PTRf_SET
#define MMU_XQ44m_RESERVED_0f_GET BCM56218_A0_MMU_XQ44m_RESERVED_0f_GET
#define MMU_XQ44m_RESERVED_0f_SET BCM56218_A0_MMU_XQ44m_RESERVED_0f_SET
#define MMU_XQ44m_IMIRRORf_GET BCM56218_A0_MMU_XQ44m_IMIRRORf_GET
#define MMU_XQ44m_IMIRRORf_SET BCM56218_A0_MMU_XQ44m_IMIRRORf_SET
#define MMU_XQ44m_EMIRRORf_GET BCM56218_A0_MMU_XQ44m_EMIRRORf_GET
#define MMU_XQ44m_EMIRRORf_SET BCM56218_A0_MMU_XQ44m_EMIRRORf_SET
#define READ_MMU_XQ44m BCM56218_A0_READ_MMU_XQ44m
#define WRITE_MMU_XQ44m BCM56218_A0_WRITE_MMU_XQ44m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_XQ44m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_XQ45
 * BLOCKS:   MMU
 * DESC:     XQ45
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     RESERVED_0       reserved for future use
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_XQ45m 0x0b6b4000

#define BCM56218_A0_MMU_XQ45m_MIN 0
#define BCM56218_A0_MMU_XQ45m_MAX 511
#define BCM56218_A0_MMU_XQ45m_CMAX(u) 511
#define BCM56218_A0_MMU_XQ45m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ45.
 *
 */
typedef union BCM56218_A0_MMU_XQ45m_s {
	uint32_t v[1];
	uint32_t mmu_xq45[1];
	uint32_t _mmu_xq45;
} BCM56218_A0_MMU_XQ45m_t;

#define BCM56218_A0_MMU_XQ45m_CLR(r) (r).mmu_xq45[0] = 0
#define BCM56218_A0_MMU_XQ45m_SET(r,d) (r).mmu_xq45[0] = d
#define BCM56218_A0_MMU_XQ45m_GET(r) (r).mmu_xq45[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_XQ45m_PARITY_0f_GET(r) (((r).mmu_xq45[0]) & 0x1)
#define BCM56218_A0_MMU_XQ45m_PARITY_0f_SET(r,f) (r).mmu_xq45[0]=(((r).mmu_xq45[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_MMU_XQ45m_L2f_GET(r) ((((r).mmu_xq45[0]) >> 1) & 0x1)
#define BCM56218_A0_MMU_XQ45m_L2f_SET(r,f) (r).mmu_xq45[0]=(((r).mmu_xq45[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_MMU_XQ45m_PURGEf_GET(r) ((((r).mmu_xq45[0]) >> 2) & 0x1)
#define BCM56218_A0_MMU_XQ45m_PURGEf_SET(r,f) (r).mmu_xq45[0]=(((r).mmu_xq45[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_MMU_XQ45m_PKT_PTRf_GET(r) ((((r).mmu_xq45[0]) >> 3) & 0x3fff)
#define BCM56218_A0_MMU_XQ45m_PKT_PTRf_SET(r,f) (r).mmu_xq45[0]=(((r).mmu_xq45[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56218_A0_MMU_XQ45m_RESERVED_0f_GET(r) ((((r).mmu_xq45[0]) >> 17) & 0x1)
#define BCM56218_A0_MMU_XQ45m_RESERVED_0f_SET(r,f) (r).mmu_xq45[0]=(((r).mmu_xq45[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_MMU_XQ45m_IMIRRORf_GET(r) ((((r).mmu_xq45[0]) >> 18) & 0x1)
#define BCM56218_A0_MMU_XQ45m_IMIRRORf_SET(r,f) (r).mmu_xq45[0]=(((r).mmu_xq45[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_MMU_XQ45m_EMIRRORf_GET(r) ((((r).mmu_xq45[0]) >> 19) & 0x1)
#define BCM56218_A0_MMU_XQ45m_EMIRRORf_SET(r,f) (r).mmu_xq45[0]=(((r).mmu_xq45[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ45.
 *
 */
#define BCM56218_A0_READ_MMU_XQ45m(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_XQ45m,i,(m._mmu_xq45),1)
#define BCM56218_A0_WRITE_MMU_XQ45m(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_XQ45m,i,&(m._mmu_xq45),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ45m BCM56218_A0_MMU_XQ45m
#define MMU_XQ45m_MIN BCM56218_A0_MMU_XQ45m_MIN
#define MMU_XQ45m_MAX BCM56218_A0_MMU_XQ45m_MAX
#define MMU_XQ45m_CMAX(u) BCM56218_A0_MMU_XQ45m_CMAX(u)
#define MMU_XQ45m_SIZE BCM56218_A0_MMU_XQ45m_SIZE
typedef BCM56218_A0_MMU_XQ45m_t MMU_XQ45m_t;
#define MMU_XQ45m_CLR BCM56218_A0_MMU_XQ45m_CLR
#define MMU_XQ45m_SET BCM56218_A0_MMU_XQ45m_SET
#define MMU_XQ45m_GET BCM56218_A0_MMU_XQ45m_GET
#define MMU_XQ45m_PARITY_0f_GET BCM56218_A0_MMU_XQ45m_PARITY_0f_GET
#define MMU_XQ45m_PARITY_0f_SET BCM56218_A0_MMU_XQ45m_PARITY_0f_SET
#define MMU_XQ45m_L2f_GET BCM56218_A0_MMU_XQ45m_L2f_GET
#define MMU_XQ45m_L2f_SET BCM56218_A0_MMU_XQ45m_L2f_SET
#define MMU_XQ45m_PURGEf_GET BCM56218_A0_MMU_XQ45m_PURGEf_GET
#define MMU_XQ45m_PURGEf_SET BCM56218_A0_MMU_XQ45m_PURGEf_SET
#define MMU_XQ45m_PKT_PTRf_GET BCM56218_A0_MMU_XQ45m_PKT_PTRf_GET
#define MMU_XQ45m_PKT_PTRf_SET BCM56218_A0_MMU_XQ45m_PKT_PTRf_SET
#define MMU_XQ45m_RESERVED_0f_GET BCM56218_A0_MMU_XQ45m_RESERVED_0f_GET
#define MMU_XQ45m_RESERVED_0f_SET BCM56218_A0_MMU_XQ45m_RESERVED_0f_SET
#define MMU_XQ45m_IMIRRORf_GET BCM56218_A0_MMU_XQ45m_IMIRRORf_GET
#define MMU_XQ45m_IMIRRORf_SET BCM56218_A0_MMU_XQ45m_IMIRRORf_SET
#define MMU_XQ45m_EMIRRORf_GET BCM56218_A0_MMU_XQ45m_EMIRRORf_GET
#define MMU_XQ45m_EMIRRORf_SET BCM56218_A0_MMU_XQ45m_EMIRRORf_SET
#define READ_MMU_XQ45m BCM56218_A0_READ_MMU_XQ45m
#define WRITE_MMU_XQ45m BCM56218_A0_WRITE_MMU_XQ45m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_XQ45m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_XQ46
 * BLOCKS:   MMU
 * DESC:     XQ46
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     RESERVED_0       reserved for future use
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_XQ46m 0x0b6b8000

#define BCM56218_A0_MMU_XQ46m_MIN 0
#define BCM56218_A0_MMU_XQ46m_MAX 511
#define BCM56218_A0_MMU_XQ46m_CMAX(u) 511
#define BCM56218_A0_MMU_XQ46m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ46.
 *
 */
typedef union BCM56218_A0_MMU_XQ46m_s {
	uint32_t v[1];
	uint32_t mmu_xq46[1];
	uint32_t _mmu_xq46;
} BCM56218_A0_MMU_XQ46m_t;

#define BCM56218_A0_MMU_XQ46m_CLR(r) (r).mmu_xq46[0] = 0
#define BCM56218_A0_MMU_XQ46m_SET(r,d) (r).mmu_xq46[0] = d
#define BCM56218_A0_MMU_XQ46m_GET(r) (r).mmu_xq46[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_XQ46m_PARITY_0f_GET(r) (((r).mmu_xq46[0]) & 0x1)
#define BCM56218_A0_MMU_XQ46m_PARITY_0f_SET(r,f) (r).mmu_xq46[0]=(((r).mmu_xq46[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_MMU_XQ46m_L2f_GET(r) ((((r).mmu_xq46[0]) >> 1) & 0x1)
#define BCM56218_A0_MMU_XQ46m_L2f_SET(r,f) (r).mmu_xq46[0]=(((r).mmu_xq46[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_MMU_XQ46m_PURGEf_GET(r) ((((r).mmu_xq46[0]) >> 2) & 0x1)
#define BCM56218_A0_MMU_XQ46m_PURGEf_SET(r,f) (r).mmu_xq46[0]=(((r).mmu_xq46[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_MMU_XQ46m_PKT_PTRf_GET(r) ((((r).mmu_xq46[0]) >> 3) & 0x3fff)
#define BCM56218_A0_MMU_XQ46m_PKT_PTRf_SET(r,f) (r).mmu_xq46[0]=(((r).mmu_xq46[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56218_A0_MMU_XQ46m_RESERVED_0f_GET(r) ((((r).mmu_xq46[0]) >> 17) & 0x1)
#define BCM56218_A0_MMU_XQ46m_RESERVED_0f_SET(r,f) (r).mmu_xq46[0]=(((r).mmu_xq46[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_MMU_XQ46m_IMIRRORf_GET(r) ((((r).mmu_xq46[0]) >> 18) & 0x1)
#define BCM56218_A0_MMU_XQ46m_IMIRRORf_SET(r,f) (r).mmu_xq46[0]=(((r).mmu_xq46[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_MMU_XQ46m_EMIRRORf_GET(r) ((((r).mmu_xq46[0]) >> 19) & 0x1)
#define BCM56218_A0_MMU_XQ46m_EMIRRORf_SET(r,f) (r).mmu_xq46[0]=(((r).mmu_xq46[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ46.
 *
 */
#define BCM56218_A0_READ_MMU_XQ46m(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_XQ46m,i,(m._mmu_xq46),1)
#define BCM56218_A0_WRITE_MMU_XQ46m(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_XQ46m,i,&(m._mmu_xq46),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ46m BCM56218_A0_MMU_XQ46m
#define MMU_XQ46m_MIN BCM56218_A0_MMU_XQ46m_MIN
#define MMU_XQ46m_MAX BCM56218_A0_MMU_XQ46m_MAX
#define MMU_XQ46m_CMAX(u) BCM56218_A0_MMU_XQ46m_CMAX(u)
#define MMU_XQ46m_SIZE BCM56218_A0_MMU_XQ46m_SIZE
typedef BCM56218_A0_MMU_XQ46m_t MMU_XQ46m_t;
#define MMU_XQ46m_CLR BCM56218_A0_MMU_XQ46m_CLR
#define MMU_XQ46m_SET BCM56218_A0_MMU_XQ46m_SET
#define MMU_XQ46m_GET BCM56218_A0_MMU_XQ46m_GET
#define MMU_XQ46m_PARITY_0f_GET BCM56218_A0_MMU_XQ46m_PARITY_0f_GET
#define MMU_XQ46m_PARITY_0f_SET BCM56218_A0_MMU_XQ46m_PARITY_0f_SET
#define MMU_XQ46m_L2f_GET BCM56218_A0_MMU_XQ46m_L2f_GET
#define MMU_XQ46m_L2f_SET BCM56218_A0_MMU_XQ46m_L2f_SET
#define MMU_XQ46m_PURGEf_GET BCM56218_A0_MMU_XQ46m_PURGEf_GET
#define MMU_XQ46m_PURGEf_SET BCM56218_A0_MMU_XQ46m_PURGEf_SET
#define MMU_XQ46m_PKT_PTRf_GET BCM56218_A0_MMU_XQ46m_PKT_PTRf_GET
#define MMU_XQ46m_PKT_PTRf_SET BCM56218_A0_MMU_XQ46m_PKT_PTRf_SET
#define MMU_XQ46m_RESERVED_0f_GET BCM56218_A0_MMU_XQ46m_RESERVED_0f_GET
#define MMU_XQ46m_RESERVED_0f_SET BCM56218_A0_MMU_XQ46m_RESERVED_0f_SET
#define MMU_XQ46m_IMIRRORf_GET BCM56218_A0_MMU_XQ46m_IMIRRORf_GET
#define MMU_XQ46m_IMIRRORf_SET BCM56218_A0_MMU_XQ46m_IMIRRORf_SET
#define MMU_XQ46m_EMIRRORf_GET BCM56218_A0_MMU_XQ46m_EMIRRORf_GET
#define MMU_XQ46m_EMIRRORf_SET BCM56218_A0_MMU_XQ46m_EMIRRORf_SET
#define READ_MMU_XQ46m BCM56218_A0_READ_MMU_XQ46m
#define WRITE_MMU_XQ46m BCM56218_A0_WRITE_MMU_XQ46m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_XQ46m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_XQ47
 * BLOCKS:   MMU
 * DESC:     XQ47
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     RESERVED_0       reserved for future use
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_XQ47m 0x0b6bc000

#define BCM56218_A0_MMU_XQ47m_MIN 0
#define BCM56218_A0_MMU_XQ47m_MAX 511
#define BCM56218_A0_MMU_XQ47m_CMAX(u) 511
#define BCM56218_A0_MMU_XQ47m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ47.
 *
 */
typedef union BCM56218_A0_MMU_XQ47m_s {
	uint32_t v[1];
	uint32_t mmu_xq47[1];
	uint32_t _mmu_xq47;
} BCM56218_A0_MMU_XQ47m_t;

#define BCM56218_A0_MMU_XQ47m_CLR(r) (r).mmu_xq47[0] = 0
#define BCM56218_A0_MMU_XQ47m_SET(r,d) (r).mmu_xq47[0] = d
#define BCM56218_A0_MMU_XQ47m_GET(r) (r).mmu_xq47[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_XQ47m_PARITY_0f_GET(r) (((r).mmu_xq47[0]) & 0x1)
#define BCM56218_A0_MMU_XQ47m_PARITY_0f_SET(r,f) (r).mmu_xq47[0]=(((r).mmu_xq47[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_MMU_XQ47m_L2f_GET(r) ((((r).mmu_xq47[0]) >> 1) & 0x1)
#define BCM56218_A0_MMU_XQ47m_L2f_SET(r,f) (r).mmu_xq47[0]=(((r).mmu_xq47[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_MMU_XQ47m_PURGEf_GET(r) ((((r).mmu_xq47[0]) >> 2) & 0x1)
#define BCM56218_A0_MMU_XQ47m_PURGEf_SET(r,f) (r).mmu_xq47[0]=(((r).mmu_xq47[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_MMU_XQ47m_PKT_PTRf_GET(r) ((((r).mmu_xq47[0]) >> 3) & 0x3fff)
#define BCM56218_A0_MMU_XQ47m_PKT_PTRf_SET(r,f) (r).mmu_xq47[0]=(((r).mmu_xq47[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56218_A0_MMU_XQ47m_RESERVED_0f_GET(r) ((((r).mmu_xq47[0]) >> 17) & 0x1)
#define BCM56218_A0_MMU_XQ47m_RESERVED_0f_SET(r,f) (r).mmu_xq47[0]=(((r).mmu_xq47[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_MMU_XQ47m_IMIRRORf_GET(r) ((((r).mmu_xq47[0]) >> 18) & 0x1)
#define BCM56218_A0_MMU_XQ47m_IMIRRORf_SET(r,f) (r).mmu_xq47[0]=(((r).mmu_xq47[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_MMU_XQ47m_EMIRRORf_GET(r) ((((r).mmu_xq47[0]) >> 19) & 0x1)
#define BCM56218_A0_MMU_XQ47m_EMIRRORf_SET(r,f) (r).mmu_xq47[0]=(((r).mmu_xq47[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ47.
 *
 */
#define BCM56218_A0_READ_MMU_XQ47m(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_XQ47m,i,(m._mmu_xq47),1)
#define BCM56218_A0_WRITE_MMU_XQ47m(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_XQ47m,i,&(m._mmu_xq47),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ47m BCM56218_A0_MMU_XQ47m
#define MMU_XQ47m_MIN BCM56218_A0_MMU_XQ47m_MIN
#define MMU_XQ47m_MAX BCM56218_A0_MMU_XQ47m_MAX
#define MMU_XQ47m_CMAX(u) BCM56218_A0_MMU_XQ47m_CMAX(u)
#define MMU_XQ47m_SIZE BCM56218_A0_MMU_XQ47m_SIZE
typedef BCM56218_A0_MMU_XQ47m_t MMU_XQ47m_t;
#define MMU_XQ47m_CLR BCM56218_A0_MMU_XQ47m_CLR
#define MMU_XQ47m_SET BCM56218_A0_MMU_XQ47m_SET
#define MMU_XQ47m_GET BCM56218_A0_MMU_XQ47m_GET
#define MMU_XQ47m_PARITY_0f_GET BCM56218_A0_MMU_XQ47m_PARITY_0f_GET
#define MMU_XQ47m_PARITY_0f_SET BCM56218_A0_MMU_XQ47m_PARITY_0f_SET
#define MMU_XQ47m_L2f_GET BCM56218_A0_MMU_XQ47m_L2f_GET
#define MMU_XQ47m_L2f_SET BCM56218_A0_MMU_XQ47m_L2f_SET
#define MMU_XQ47m_PURGEf_GET BCM56218_A0_MMU_XQ47m_PURGEf_GET
#define MMU_XQ47m_PURGEf_SET BCM56218_A0_MMU_XQ47m_PURGEf_SET
#define MMU_XQ47m_PKT_PTRf_GET BCM56218_A0_MMU_XQ47m_PKT_PTRf_GET
#define MMU_XQ47m_PKT_PTRf_SET BCM56218_A0_MMU_XQ47m_PKT_PTRf_SET
#define MMU_XQ47m_RESERVED_0f_GET BCM56218_A0_MMU_XQ47m_RESERVED_0f_GET
#define MMU_XQ47m_RESERVED_0f_SET BCM56218_A0_MMU_XQ47m_RESERVED_0f_SET
#define MMU_XQ47m_IMIRRORf_GET BCM56218_A0_MMU_XQ47m_IMIRRORf_GET
#define MMU_XQ47m_IMIRRORf_SET BCM56218_A0_MMU_XQ47m_IMIRRORf_SET
#define MMU_XQ47m_EMIRRORf_GET BCM56218_A0_MMU_XQ47m_EMIRRORf_GET
#define MMU_XQ47m_EMIRRORf_SET BCM56218_A0_MMU_XQ47m_EMIRRORf_SET
#define READ_MMU_XQ47m BCM56218_A0_READ_MMU_XQ47m
#define WRITE_MMU_XQ47m BCM56218_A0_WRITE_MMU_XQ47m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_XQ47m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_XQ48
 * BLOCKS:   MMU
 * DESC:     XQ48
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     RESERVED_0       reserved for future use
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_XQ48m 0x0b6c0000

#define BCM56218_A0_MMU_XQ48m_MIN 0
#define BCM56218_A0_MMU_XQ48m_MAX 511
#define BCM56218_A0_MMU_XQ48m_CMAX(u) 511
#define BCM56218_A0_MMU_XQ48m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ48.
 *
 */
typedef union BCM56218_A0_MMU_XQ48m_s {
	uint32_t v[1];
	uint32_t mmu_xq48[1];
	uint32_t _mmu_xq48;
} BCM56218_A0_MMU_XQ48m_t;

#define BCM56218_A0_MMU_XQ48m_CLR(r) (r).mmu_xq48[0] = 0
#define BCM56218_A0_MMU_XQ48m_SET(r,d) (r).mmu_xq48[0] = d
#define BCM56218_A0_MMU_XQ48m_GET(r) (r).mmu_xq48[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_XQ48m_PARITY_0f_GET(r) (((r).mmu_xq48[0]) & 0x1)
#define BCM56218_A0_MMU_XQ48m_PARITY_0f_SET(r,f) (r).mmu_xq48[0]=(((r).mmu_xq48[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_MMU_XQ48m_L2f_GET(r) ((((r).mmu_xq48[0]) >> 1) & 0x1)
#define BCM56218_A0_MMU_XQ48m_L2f_SET(r,f) (r).mmu_xq48[0]=(((r).mmu_xq48[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_MMU_XQ48m_PURGEf_GET(r) ((((r).mmu_xq48[0]) >> 2) & 0x1)
#define BCM56218_A0_MMU_XQ48m_PURGEf_SET(r,f) (r).mmu_xq48[0]=(((r).mmu_xq48[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_MMU_XQ48m_PKT_PTRf_GET(r) ((((r).mmu_xq48[0]) >> 3) & 0x3fff)
#define BCM56218_A0_MMU_XQ48m_PKT_PTRf_SET(r,f) (r).mmu_xq48[0]=(((r).mmu_xq48[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56218_A0_MMU_XQ48m_RESERVED_0f_GET(r) ((((r).mmu_xq48[0]) >> 17) & 0x1)
#define BCM56218_A0_MMU_XQ48m_RESERVED_0f_SET(r,f) (r).mmu_xq48[0]=(((r).mmu_xq48[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_MMU_XQ48m_IMIRRORf_GET(r) ((((r).mmu_xq48[0]) >> 18) & 0x1)
#define BCM56218_A0_MMU_XQ48m_IMIRRORf_SET(r,f) (r).mmu_xq48[0]=(((r).mmu_xq48[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_MMU_XQ48m_EMIRRORf_GET(r) ((((r).mmu_xq48[0]) >> 19) & 0x1)
#define BCM56218_A0_MMU_XQ48m_EMIRRORf_SET(r,f) (r).mmu_xq48[0]=(((r).mmu_xq48[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ48.
 *
 */
#define BCM56218_A0_READ_MMU_XQ48m(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_XQ48m,i,(m._mmu_xq48),1)
#define BCM56218_A0_WRITE_MMU_XQ48m(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_XQ48m,i,&(m._mmu_xq48),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ48m BCM56218_A0_MMU_XQ48m
#define MMU_XQ48m_MIN BCM56218_A0_MMU_XQ48m_MIN
#define MMU_XQ48m_MAX BCM56218_A0_MMU_XQ48m_MAX
#define MMU_XQ48m_CMAX(u) BCM56218_A0_MMU_XQ48m_CMAX(u)
#define MMU_XQ48m_SIZE BCM56218_A0_MMU_XQ48m_SIZE
typedef BCM56218_A0_MMU_XQ48m_t MMU_XQ48m_t;
#define MMU_XQ48m_CLR BCM56218_A0_MMU_XQ48m_CLR
#define MMU_XQ48m_SET BCM56218_A0_MMU_XQ48m_SET
#define MMU_XQ48m_GET BCM56218_A0_MMU_XQ48m_GET
#define MMU_XQ48m_PARITY_0f_GET BCM56218_A0_MMU_XQ48m_PARITY_0f_GET
#define MMU_XQ48m_PARITY_0f_SET BCM56218_A0_MMU_XQ48m_PARITY_0f_SET
#define MMU_XQ48m_L2f_GET BCM56218_A0_MMU_XQ48m_L2f_GET
#define MMU_XQ48m_L2f_SET BCM56218_A0_MMU_XQ48m_L2f_SET
#define MMU_XQ48m_PURGEf_GET BCM56218_A0_MMU_XQ48m_PURGEf_GET
#define MMU_XQ48m_PURGEf_SET BCM56218_A0_MMU_XQ48m_PURGEf_SET
#define MMU_XQ48m_PKT_PTRf_GET BCM56218_A0_MMU_XQ48m_PKT_PTRf_GET
#define MMU_XQ48m_PKT_PTRf_SET BCM56218_A0_MMU_XQ48m_PKT_PTRf_SET
#define MMU_XQ48m_RESERVED_0f_GET BCM56218_A0_MMU_XQ48m_RESERVED_0f_GET
#define MMU_XQ48m_RESERVED_0f_SET BCM56218_A0_MMU_XQ48m_RESERVED_0f_SET
#define MMU_XQ48m_IMIRRORf_GET BCM56218_A0_MMU_XQ48m_IMIRRORf_GET
#define MMU_XQ48m_IMIRRORf_SET BCM56218_A0_MMU_XQ48m_IMIRRORf_SET
#define MMU_XQ48m_EMIRRORf_GET BCM56218_A0_MMU_XQ48m_EMIRRORf_GET
#define MMU_XQ48m_EMIRRORf_SET BCM56218_A0_MMU_XQ48m_EMIRRORf_SET
#define READ_MMU_XQ48m BCM56218_A0_READ_MMU_XQ48m
#define WRITE_MMU_XQ48m BCM56218_A0_WRITE_MMU_XQ48m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_XQ48m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_XQ49
 * BLOCKS:   MMU
 * DESC:     XQ49
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     RESERVED_0       reserved for future use
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_XQ49m 0x0b6c4000

#define BCM56218_A0_MMU_XQ49m_MIN 0
#define BCM56218_A0_MMU_XQ49m_MAX 511
#define BCM56218_A0_MMU_XQ49m_CMAX(u) 511
#define BCM56218_A0_MMU_XQ49m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ49.
 *
 */
typedef union BCM56218_A0_MMU_XQ49m_s {
	uint32_t v[1];
	uint32_t mmu_xq49[1];
	uint32_t _mmu_xq49;
} BCM56218_A0_MMU_XQ49m_t;

#define BCM56218_A0_MMU_XQ49m_CLR(r) (r).mmu_xq49[0] = 0
#define BCM56218_A0_MMU_XQ49m_SET(r,d) (r).mmu_xq49[0] = d
#define BCM56218_A0_MMU_XQ49m_GET(r) (r).mmu_xq49[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_XQ49m_PARITY_0f_GET(r) (((r).mmu_xq49[0]) & 0x1)
#define BCM56218_A0_MMU_XQ49m_PARITY_0f_SET(r,f) (r).mmu_xq49[0]=(((r).mmu_xq49[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_MMU_XQ49m_L2f_GET(r) ((((r).mmu_xq49[0]) >> 1) & 0x1)
#define BCM56218_A0_MMU_XQ49m_L2f_SET(r,f) (r).mmu_xq49[0]=(((r).mmu_xq49[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_MMU_XQ49m_PURGEf_GET(r) ((((r).mmu_xq49[0]) >> 2) & 0x1)
#define BCM56218_A0_MMU_XQ49m_PURGEf_SET(r,f) (r).mmu_xq49[0]=(((r).mmu_xq49[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_MMU_XQ49m_PKT_PTRf_GET(r) ((((r).mmu_xq49[0]) >> 3) & 0x3fff)
#define BCM56218_A0_MMU_XQ49m_PKT_PTRf_SET(r,f) (r).mmu_xq49[0]=(((r).mmu_xq49[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56218_A0_MMU_XQ49m_RESERVED_0f_GET(r) ((((r).mmu_xq49[0]) >> 17) & 0x1)
#define BCM56218_A0_MMU_XQ49m_RESERVED_0f_SET(r,f) (r).mmu_xq49[0]=(((r).mmu_xq49[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_MMU_XQ49m_IMIRRORf_GET(r) ((((r).mmu_xq49[0]) >> 18) & 0x1)
#define BCM56218_A0_MMU_XQ49m_IMIRRORf_SET(r,f) (r).mmu_xq49[0]=(((r).mmu_xq49[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_MMU_XQ49m_EMIRRORf_GET(r) ((((r).mmu_xq49[0]) >> 19) & 0x1)
#define BCM56218_A0_MMU_XQ49m_EMIRRORf_SET(r,f) (r).mmu_xq49[0]=(((r).mmu_xq49[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ49.
 *
 */
#define BCM56218_A0_READ_MMU_XQ49m(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_XQ49m,i,(m._mmu_xq49),1)
#define BCM56218_A0_WRITE_MMU_XQ49m(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_XQ49m,i,&(m._mmu_xq49),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ49m BCM56218_A0_MMU_XQ49m
#define MMU_XQ49m_MIN BCM56218_A0_MMU_XQ49m_MIN
#define MMU_XQ49m_MAX BCM56218_A0_MMU_XQ49m_MAX
#define MMU_XQ49m_CMAX(u) BCM56218_A0_MMU_XQ49m_CMAX(u)
#define MMU_XQ49m_SIZE BCM56218_A0_MMU_XQ49m_SIZE
typedef BCM56218_A0_MMU_XQ49m_t MMU_XQ49m_t;
#define MMU_XQ49m_CLR BCM56218_A0_MMU_XQ49m_CLR
#define MMU_XQ49m_SET BCM56218_A0_MMU_XQ49m_SET
#define MMU_XQ49m_GET BCM56218_A0_MMU_XQ49m_GET
#define MMU_XQ49m_PARITY_0f_GET BCM56218_A0_MMU_XQ49m_PARITY_0f_GET
#define MMU_XQ49m_PARITY_0f_SET BCM56218_A0_MMU_XQ49m_PARITY_0f_SET
#define MMU_XQ49m_L2f_GET BCM56218_A0_MMU_XQ49m_L2f_GET
#define MMU_XQ49m_L2f_SET BCM56218_A0_MMU_XQ49m_L2f_SET
#define MMU_XQ49m_PURGEf_GET BCM56218_A0_MMU_XQ49m_PURGEf_GET
#define MMU_XQ49m_PURGEf_SET BCM56218_A0_MMU_XQ49m_PURGEf_SET
#define MMU_XQ49m_PKT_PTRf_GET BCM56218_A0_MMU_XQ49m_PKT_PTRf_GET
#define MMU_XQ49m_PKT_PTRf_SET BCM56218_A0_MMU_XQ49m_PKT_PTRf_SET
#define MMU_XQ49m_RESERVED_0f_GET BCM56218_A0_MMU_XQ49m_RESERVED_0f_GET
#define MMU_XQ49m_RESERVED_0f_SET BCM56218_A0_MMU_XQ49m_RESERVED_0f_SET
#define MMU_XQ49m_IMIRRORf_GET BCM56218_A0_MMU_XQ49m_IMIRRORf_GET
#define MMU_XQ49m_IMIRRORf_SET BCM56218_A0_MMU_XQ49m_IMIRRORf_SET
#define MMU_XQ49m_EMIRRORf_GET BCM56218_A0_MMU_XQ49m_EMIRRORf_GET
#define MMU_XQ49m_EMIRRORf_SET BCM56218_A0_MMU_XQ49m_EMIRRORf_SET
#define READ_MMU_XQ49m BCM56218_A0_READ_MMU_XQ49m
#define WRITE_MMU_XQ49m BCM56218_A0_WRITE_MMU_XQ49m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_XQ49m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_XQ5
 * BLOCKS:   MMU
 * DESC:     XQ5
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     RESERVED_0       reserved for future use
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_XQ5m 0x0b614000

#define BCM56218_A0_MMU_XQ5m_MIN 0
#define BCM56218_A0_MMU_XQ5m_MAX 767
#define BCM56218_A0_MMU_XQ5m_CMAX(u) 767
#define BCM56218_A0_MMU_XQ5m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ5.
 *
 */
typedef union BCM56218_A0_MMU_XQ5m_s {
	uint32_t v[1];
	uint32_t mmu_xq5[1];
	uint32_t _mmu_xq5;
} BCM56218_A0_MMU_XQ5m_t;

#define BCM56218_A0_MMU_XQ5m_CLR(r) (r).mmu_xq5[0] = 0
#define BCM56218_A0_MMU_XQ5m_SET(r,d) (r).mmu_xq5[0] = d
#define BCM56218_A0_MMU_XQ5m_GET(r) (r).mmu_xq5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_XQ5m_PARITY_0f_GET(r) (((r).mmu_xq5[0]) & 0x1)
#define BCM56218_A0_MMU_XQ5m_PARITY_0f_SET(r,f) (r).mmu_xq5[0]=(((r).mmu_xq5[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_MMU_XQ5m_L2f_GET(r) ((((r).mmu_xq5[0]) >> 1) & 0x1)
#define BCM56218_A0_MMU_XQ5m_L2f_SET(r,f) (r).mmu_xq5[0]=(((r).mmu_xq5[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_MMU_XQ5m_PURGEf_GET(r) ((((r).mmu_xq5[0]) >> 2) & 0x1)
#define BCM56218_A0_MMU_XQ5m_PURGEf_SET(r,f) (r).mmu_xq5[0]=(((r).mmu_xq5[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_MMU_XQ5m_PKT_PTRf_GET(r) ((((r).mmu_xq5[0]) >> 3) & 0x3fff)
#define BCM56218_A0_MMU_XQ5m_PKT_PTRf_SET(r,f) (r).mmu_xq5[0]=(((r).mmu_xq5[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56218_A0_MMU_XQ5m_RESERVED_0f_GET(r) ((((r).mmu_xq5[0]) >> 17) & 0x1)
#define BCM56218_A0_MMU_XQ5m_RESERVED_0f_SET(r,f) (r).mmu_xq5[0]=(((r).mmu_xq5[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_MMU_XQ5m_IMIRRORf_GET(r) ((((r).mmu_xq5[0]) >> 18) & 0x1)
#define BCM56218_A0_MMU_XQ5m_IMIRRORf_SET(r,f) (r).mmu_xq5[0]=(((r).mmu_xq5[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_MMU_XQ5m_EMIRRORf_GET(r) ((((r).mmu_xq5[0]) >> 19) & 0x1)
#define BCM56218_A0_MMU_XQ5m_EMIRRORf_SET(r,f) (r).mmu_xq5[0]=(((r).mmu_xq5[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ5.
 *
 */
#define BCM56218_A0_READ_MMU_XQ5m(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_XQ5m,i,(m._mmu_xq5),1)
#define BCM56218_A0_WRITE_MMU_XQ5m(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_XQ5m,i,&(m._mmu_xq5),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ5m BCM56218_A0_MMU_XQ5m
#define MMU_XQ5m_MIN BCM56218_A0_MMU_XQ5m_MIN
#define MMU_XQ5m_MAX BCM56218_A0_MMU_XQ5m_MAX
#define MMU_XQ5m_CMAX(u) BCM56218_A0_MMU_XQ5m_CMAX(u)
#define MMU_XQ5m_SIZE BCM56218_A0_MMU_XQ5m_SIZE
typedef BCM56218_A0_MMU_XQ5m_t MMU_XQ5m_t;
#define MMU_XQ5m_CLR BCM56218_A0_MMU_XQ5m_CLR
#define MMU_XQ5m_SET BCM56218_A0_MMU_XQ5m_SET
#define MMU_XQ5m_GET BCM56218_A0_MMU_XQ5m_GET
#define MMU_XQ5m_PARITY_0f_GET BCM56218_A0_MMU_XQ5m_PARITY_0f_GET
#define MMU_XQ5m_PARITY_0f_SET BCM56218_A0_MMU_XQ5m_PARITY_0f_SET
#define MMU_XQ5m_L2f_GET BCM56218_A0_MMU_XQ5m_L2f_GET
#define MMU_XQ5m_L2f_SET BCM56218_A0_MMU_XQ5m_L2f_SET
#define MMU_XQ5m_PURGEf_GET BCM56218_A0_MMU_XQ5m_PURGEf_GET
#define MMU_XQ5m_PURGEf_SET BCM56218_A0_MMU_XQ5m_PURGEf_SET
#define MMU_XQ5m_PKT_PTRf_GET BCM56218_A0_MMU_XQ5m_PKT_PTRf_GET
#define MMU_XQ5m_PKT_PTRf_SET BCM56218_A0_MMU_XQ5m_PKT_PTRf_SET
#define MMU_XQ5m_RESERVED_0f_GET BCM56218_A0_MMU_XQ5m_RESERVED_0f_GET
#define MMU_XQ5m_RESERVED_0f_SET BCM56218_A0_MMU_XQ5m_RESERVED_0f_SET
#define MMU_XQ5m_IMIRRORf_GET BCM56218_A0_MMU_XQ5m_IMIRRORf_GET
#define MMU_XQ5m_IMIRRORf_SET BCM56218_A0_MMU_XQ5m_IMIRRORf_SET
#define MMU_XQ5m_EMIRRORf_GET BCM56218_A0_MMU_XQ5m_EMIRRORf_GET
#define MMU_XQ5m_EMIRRORf_SET BCM56218_A0_MMU_XQ5m_EMIRRORf_SET
#define READ_MMU_XQ5m BCM56218_A0_READ_MMU_XQ5m
#define WRITE_MMU_XQ5m BCM56218_A0_WRITE_MMU_XQ5m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_XQ5m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_XQ50
 * BLOCKS:   MMU
 * DESC:     XQ50
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     RESERVED_0       reserved for future use
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_XQ50m 0x0b6c8000

#define BCM56218_A0_MMU_XQ50m_MIN 0
#define BCM56218_A0_MMU_XQ50m_MAX 511
#define BCM56218_A0_MMU_XQ50m_CMAX(u) 511
#define BCM56218_A0_MMU_XQ50m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ50.
 *
 */
typedef union BCM56218_A0_MMU_XQ50m_s {
	uint32_t v[1];
	uint32_t mmu_xq50[1];
	uint32_t _mmu_xq50;
} BCM56218_A0_MMU_XQ50m_t;

#define BCM56218_A0_MMU_XQ50m_CLR(r) (r).mmu_xq50[0] = 0
#define BCM56218_A0_MMU_XQ50m_SET(r,d) (r).mmu_xq50[0] = d
#define BCM56218_A0_MMU_XQ50m_GET(r) (r).mmu_xq50[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_XQ50m_PARITY_0f_GET(r) (((r).mmu_xq50[0]) & 0x1)
#define BCM56218_A0_MMU_XQ50m_PARITY_0f_SET(r,f) (r).mmu_xq50[0]=(((r).mmu_xq50[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_MMU_XQ50m_L2f_GET(r) ((((r).mmu_xq50[0]) >> 1) & 0x1)
#define BCM56218_A0_MMU_XQ50m_L2f_SET(r,f) (r).mmu_xq50[0]=(((r).mmu_xq50[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_MMU_XQ50m_PURGEf_GET(r) ((((r).mmu_xq50[0]) >> 2) & 0x1)
#define BCM56218_A0_MMU_XQ50m_PURGEf_SET(r,f) (r).mmu_xq50[0]=(((r).mmu_xq50[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_MMU_XQ50m_PKT_PTRf_GET(r) ((((r).mmu_xq50[0]) >> 3) & 0x3fff)
#define BCM56218_A0_MMU_XQ50m_PKT_PTRf_SET(r,f) (r).mmu_xq50[0]=(((r).mmu_xq50[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56218_A0_MMU_XQ50m_RESERVED_0f_GET(r) ((((r).mmu_xq50[0]) >> 17) & 0x1)
#define BCM56218_A0_MMU_XQ50m_RESERVED_0f_SET(r,f) (r).mmu_xq50[0]=(((r).mmu_xq50[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_MMU_XQ50m_IMIRRORf_GET(r) ((((r).mmu_xq50[0]) >> 18) & 0x1)
#define BCM56218_A0_MMU_XQ50m_IMIRRORf_SET(r,f) (r).mmu_xq50[0]=(((r).mmu_xq50[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_MMU_XQ50m_EMIRRORf_GET(r) ((((r).mmu_xq50[0]) >> 19) & 0x1)
#define BCM56218_A0_MMU_XQ50m_EMIRRORf_SET(r,f) (r).mmu_xq50[0]=(((r).mmu_xq50[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ50.
 *
 */
#define BCM56218_A0_READ_MMU_XQ50m(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_XQ50m,i,(m._mmu_xq50),1)
#define BCM56218_A0_WRITE_MMU_XQ50m(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_XQ50m,i,&(m._mmu_xq50),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ50m BCM56218_A0_MMU_XQ50m
#define MMU_XQ50m_MIN BCM56218_A0_MMU_XQ50m_MIN
#define MMU_XQ50m_MAX BCM56218_A0_MMU_XQ50m_MAX
#define MMU_XQ50m_CMAX(u) BCM56218_A0_MMU_XQ50m_CMAX(u)
#define MMU_XQ50m_SIZE BCM56218_A0_MMU_XQ50m_SIZE
typedef BCM56218_A0_MMU_XQ50m_t MMU_XQ50m_t;
#define MMU_XQ50m_CLR BCM56218_A0_MMU_XQ50m_CLR
#define MMU_XQ50m_SET BCM56218_A0_MMU_XQ50m_SET
#define MMU_XQ50m_GET BCM56218_A0_MMU_XQ50m_GET
#define MMU_XQ50m_PARITY_0f_GET BCM56218_A0_MMU_XQ50m_PARITY_0f_GET
#define MMU_XQ50m_PARITY_0f_SET BCM56218_A0_MMU_XQ50m_PARITY_0f_SET
#define MMU_XQ50m_L2f_GET BCM56218_A0_MMU_XQ50m_L2f_GET
#define MMU_XQ50m_L2f_SET BCM56218_A0_MMU_XQ50m_L2f_SET
#define MMU_XQ50m_PURGEf_GET BCM56218_A0_MMU_XQ50m_PURGEf_GET
#define MMU_XQ50m_PURGEf_SET BCM56218_A0_MMU_XQ50m_PURGEf_SET
#define MMU_XQ50m_PKT_PTRf_GET BCM56218_A0_MMU_XQ50m_PKT_PTRf_GET
#define MMU_XQ50m_PKT_PTRf_SET BCM56218_A0_MMU_XQ50m_PKT_PTRf_SET
#define MMU_XQ50m_RESERVED_0f_GET BCM56218_A0_MMU_XQ50m_RESERVED_0f_GET
#define MMU_XQ50m_RESERVED_0f_SET BCM56218_A0_MMU_XQ50m_RESERVED_0f_SET
#define MMU_XQ50m_IMIRRORf_GET BCM56218_A0_MMU_XQ50m_IMIRRORf_GET
#define MMU_XQ50m_IMIRRORf_SET BCM56218_A0_MMU_XQ50m_IMIRRORf_SET
#define MMU_XQ50m_EMIRRORf_GET BCM56218_A0_MMU_XQ50m_EMIRRORf_GET
#define MMU_XQ50m_EMIRRORf_SET BCM56218_A0_MMU_XQ50m_EMIRRORf_SET
#define READ_MMU_XQ50m BCM56218_A0_READ_MMU_XQ50m
#define WRITE_MMU_XQ50m BCM56218_A0_WRITE_MMU_XQ50m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_XQ50m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_XQ51
 * BLOCKS:   MMU
 * DESC:     XQ51
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     RESERVED_0       reserved for future use
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_XQ51m 0x0b6cc000

#define BCM56218_A0_MMU_XQ51m_MIN 0
#define BCM56218_A0_MMU_XQ51m_MAX 511
#define BCM56218_A0_MMU_XQ51m_CMAX(u) 511
#define BCM56218_A0_MMU_XQ51m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ51.
 *
 */
typedef union BCM56218_A0_MMU_XQ51m_s {
	uint32_t v[1];
	uint32_t mmu_xq51[1];
	uint32_t _mmu_xq51;
} BCM56218_A0_MMU_XQ51m_t;

#define BCM56218_A0_MMU_XQ51m_CLR(r) (r).mmu_xq51[0] = 0
#define BCM56218_A0_MMU_XQ51m_SET(r,d) (r).mmu_xq51[0] = d
#define BCM56218_A0_MMU_XQ51m_GET(r) (r).mmu_xq51[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_XQ51m_PARITY_0f_GET(r) (((r).mmu_xq51[0]) & 0x1)
#define BCM56218_A0_MMU_XQ51m_PARITY_0f_SET(r,f) (r).mmu_xq51[0]=(((r).mmu_xq51[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_MMU_XQ51m_L2f_GET(r) ((((r).mmu_xq51[0]) >> 1) & 0x1)
#define BCM56218_A0_MMU_XQ51m_L2f_SET(r,f) (r).mmu_xq51[0]=(((r).mmu_xq51[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_MMU_XQ51m_PURGEf_GET(r) ((((r).mmu_xq51[0]) >> 2) & 0x1)
#define BCM56218_A0_MMU_XQ51m_PURGEf_SET(r,f) (r).mmu_xq51[0]=(((r).mmu_xq51[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_MMU_XQ51m_PKT_PTRf_GET(r) ((((r).mmu_xq51[0]) >> 3) & 0x3fff)
#define BCM56218_A0_MMU_XQ51m_PKT_PTRf_SET(r,f) (r).mmu_xq51[0]=(((r).mmu_xq51[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56218_A0_MMU_XQ51m_RESERVED_0f_GET(r) ((((r).mmu_xq51[0]) >> 17) & 0x1)
#define BCM56218_A0_MMU_XQ51m_RESERVED_0f_SET(r,f) (r).mmu_xq51[0]=(((r).mmu_xq51[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_MMU_XQ51m_IMIRRORf_GET(r) ((((r).mmu_xq51[0]) >> 18) & 0x1)
#define BCM56218_A0_MMU_XQ51m_IMIRRORf_SET(r,f) (r).mmu_xq51[0]=(((r).mmu_xq51[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_MMU_XQ51m_EMIRRORf_GET(r) ((((r).mmu_xq51[0]) >> 19) & 0x1)
#define BCM56218_A0_MMU_XQ51m_EMIRRORf_SET(r,f) (r).mmu_xq51[0]=(((r).mmu_xq51[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ51.
 *
 */
#define BCM56218_A0_READ_MMU_XQ51m(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_XQ51m,i,(m._mmu_xq51),1)
#define BCM56218_A0_WRITE_MMU_XQ51m(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_XQ51m,i,&(m._mmu_xq51),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ51m BCM56218_A0_MMU_XQ51m
#define MMU_XQ51m_MIN BCM56218_A0_MMU_XQ51m_MIN
#define MMU_XQ51m_MAX BCM56218_A0_MMU_XQ51m_MAX
#define MMU_XQ51m_CMAX(u) BCM56218_A0_MMU_XQ51m_CMAX(u)
#define MMU_XQ51m_SIZE BCM56218_A0_MMU_XQ51m_SIZE
typedef BCM56218_A0_MMU_XQ51m_t MMU_XQ51m_t;
#define MMU_XQ51m_CLR BCM56218_A0_MMU_XQ51m_CLR
#define MMU_XQ51m_SET BCM56218_A0_MMU_XQ51m_SET
#define MMU_XQ51m_GET BCM56218_A0_MMU_XQ51m_GET
#define MMU_XQ51m_PARITY_0f_GET BCM56218_A0_MMU_XQ51m_PARITY_0f_GET
#define MMU_XQ51m_PARITY_0f_SET BCM56218_A0_MMU_XQ51m_PARITY_0f_SET
#define MMU_XQ51m_L2f_GET BCM56218_A0_MMU_XQ51m_L2f_GET
#define MMU_XQ51m_L2f_SET BCM56218_A0_MMU_XQ51m_L2f_SET
#define MMU_XQ51m_PURGEf_GET BCM56218_A0_MMU_XQ51m_PURGEf_GET
#define MMU_XQ51m_PURGEf_SET BCM56218_A0_MMU_XQ51m_PURGEf_SET
#define MMU_XQ51m_PKT_PTRf_GET BCM56218_A0_MMU_XQ51m_PKT_PTRf_GET
#define MMU_XQ51m_PKT_PTRf_SET BCM56218_A0_MMU_XQ51m_PKT_PTRf_SET
#define MMU_XQ51m_RESERVED_0f_GET BCM56218_A0_MMU_XQ51m_RESERVED_0f_GET
#define MMU_XQ51m_RESERVED_0f_SET BCM56218_A0_MMU_XQ51m_RESERVED_0f_SET
#define MMU_XQ51m_IMIRRORf_GET BCM56218_A0_MMU_XQ51m_IMIRRORf_GET
#define MMU_XQ51m_IMIRRORf_SET BCM56218_A0_MMU_XQ51m_IMIRRORf_SET
#define MMU_XQ51m_EMIRRORf_GET BCM56218_A0_MMU_XQ51m_EMIRRORf_GET
#define MMU_XQ51m_EMIRRORf_SET BCM56218_A0_MMU_XQ51m_EMIRRORf_SET
#define READ_MMU_XQ51m BCM56218_A0_READ_MMU_XQ51m
#define WRITE_MMU_XQ51m BCM56218_A0_WRITE_MMU_XQ51m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_XQ51m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_XQ52
 * BLOCKS:   MMU
 * DESC:     XQ52
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     RESERVED_0       reserved for future use
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_XQ52m 0x0b6d0000

#define BCM56218_A0_MMU_XQ52m_MIN 0
#define BCM56218_A0_MMU_XQ52m_MAX 511
#define BCM56218_A0_MMU_XQ52m_CMAX(u) 511
#define BCM56218_A0_MMU_XQ52m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ52.
 *
 */
typedef union BCM56218_A0_MMU_XQ52m_s {
	uint32_t v[1];
	uint32_t mmu_xq52[1];
	uint32_t _mmu_xq52;
} BCM56218_A0_MMU_XQ52m_t;

#define BCM56218_A0_MMU_XQ52m_CLR(r) (r).mmu_xq52[0] = 0
#define BCM56218_A0_MMU_XQ52m_SET(r,d) (r).mmu_xq52[0] = d
#define BCM56218_A0_MMU_XQ52m_GET(r) (r).mmu_xq52[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_XQ52m_PARITY_0f_GET(r) (((r).mmu_xq52[0]) & 0x1)
#define BCM56218_A0_MMU_XQ52m_PARITY_0f_SET(r,f) (r).mmu_xq52[0]=(((r).mmu_xq52[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_MMU_XQ52m_L2f_GET(r) ((((r).mmu_xq52[0]) >> 1) & 0x1)
#define BCM56218_A0_MMU_XQ52m_L2f_SET(r,f) (r).mmu_xq52[0]=(((r).mmu_xq52[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_MMU_XQ52m_PURGEf_GET(r) ((((r).mmu_xq52[0]) >> 2) & 0x1)
#define BCM56218_A0_MMU_XQ52m_PURGEf_SET(r,f) (r).mmu_xq52[0]=(((r).mmu_xq52[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_MMU_XQ52m_PKT_PTRf_GET(r) ((((r).mmu_xq52[0]) >> 3) & 0x3fff)
#define BCM56218_A0_MMU_XQ52m_PKT_PTRf_SET(r,f) (r).mmu_xq52[0]=(((r).mmu_xq52[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56218_A0_MMU_XQ52m_RESERVED_0f_GET(r) ((((r).mmu_xq52[0]) >> 17) & 0x1)
#define BCM56218_A0_MMU_XQ52m_RESERVED_0f_SET(r,f) (r).mmu_xq52[0]=(((r).mmu_xq52[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_MMU_XQ52m_IMIRRORf_GET(r) ((((r).mmu_xq52[0]) >> 18) & 0x1)
#define BCM56218_A0_MMU_XQ52m_IMIRRORf_SET(r,f) (r).mmu_xq52[0]=(((r).mmu_xq52[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_MMU_XQ52m_EMIRRORf_GET(r) ((((r).mmu_xq52[0]) >> 19) & 0x1)
#define BCM56218_A0_MMU_XQ52m_EMIRRORf_SET(r,f) (r).mmu_xq52[0]=(((r).mmu_xq52[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ52.
 *
 */
#define BCM56218_A0_READ_MMU_XQ52m(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_XQ52m,i,(m._mmu_xq52),1)
#define BCM56218_A0_WRITE_MMU_XQ52m(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_XQ52m,i,&(m._mmu_xq52),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ52m BCM56218_A0_MMU_XQ52m
#define MMU_XQ52m_MIN BCM56218_A0_MMU_XQ52m_MIN
#define MMU_XQ52m_MAX BCM56218_A0_MMU_XQ52m_MAX
#define MMU_XQ52m_CMAX(u) BCM56218_A0_MMU_XQ52m_CMAX(u)
#define MMU_XQ52m_SIZE BCM56218_A0_MMU_XQ52m_SIZE
typedef BCM56218_A0_MMU_XQ52m_t MMU_XQ52m_t;
#define MMU_XQ52m_CLR BCM56218_A0_MMU_XQ52m_CLR
#define MMU_XQ52m_SET BCM56218_A0_MMU_XQ52m_SET
#define MMU_XQ52m_GET BCM56218_A0_MMU_XQ52m_GET
#define MMU_XQ52m_PARITY_0f_GET BCM56218_A0_MMU_XQ52m_PARITY_0f_GET
#define MMU_XQ52m_PARITY_0f_SET BCM56218_A0_MMU_XQ52m_PARITY_0f_SET
#define MMU_XQ52m_L2f_GET BCM56218_A0_MMU_XQ52m_L2f_GET
#define MMU_XQ52m_L2f_SET BCM56218_A0_MMU_XQ52m_L2f_SET
#define MMU_XQ52m_PURGEf_GET BCM56218_A0_MMU_XQ52m_PURGEf_GET
#define MMU_XQ52m_PURGEf_SET BCM56218_A0_MMU_XQ52m_PURGEf_SET
#define MMU_XQ52m_PKT_PTRf_GET BCM56218_A0_MMU_XQ52m_PKT_PTRf_GET
#define MMU_XQ52m_PKT_PTRf_SET BCM56218_A0_MMU_XQ52m_PKT_PTRf_SET
#define MMU_XQ52m_RESERVED_0f_GET BCM56218_A0_MMU_XQ52m_RESERVED_0f_GET
#define MMU_XQ52m_RESERVED_0f_SET BCM56218_A0_MMU_XQ52m_RESERVED_0f_SET
#define MMU_XQ52m_IMIRRORf_GET BCM56218_A0_MMU_XQ52m_IMIRRORf_GET
#define MMU_XQ52m_IMIRRORf_SET BCM56218_A0_MMU_XQ52m_IMIRRORf_SET
#define MMU_XQ52m_EMIRRORf_GET BCM56218_A0_MMU_XQ52m_EMIRRORf_GET
#define MMU_XQ52m_EMIRRORf_SET BCM56218_A0_MMU_XQ52m_EMIRRORf_SET
#define READ_MMU_XQ52m BCM56218_A0_READ_MMU_XQ52m
#define WRITE_MMU_XQ52m BCM56218_A0_WRITE_MMU_XQ52m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_XQ52m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_XQ53
 * BLOCKS:   MMU
 * DESC:     XQ53
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     RESERVED_0       reserved for future use
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_XQ53m 0x0b6d4000

#define BCM56218_A0_MMU_XQ53m_MIN 0
#define BCM56218_A0_MMU_XQ53m_MAX 511
#define BCM56218_A0_MMU_XQ53m_CMAX(u) 511
#define BCM56218_A0_MMU_XQ53m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ53.
 *
 */
typedef union BCM56218_A0_MMU_XQ53m_s {
	uint32_t v[1];
	uint32_t mmu_xq53[1];
	uint32_t _mmu_xq53;
} BCM56218_A0_MMU_XQ53m_t;

#define BCM56218_A0_MMU_XQ53m_CLR(r) (r).mmu_xq53[0] = 0
#define BCM56218_A0_MMU_XQ53m_SET(r,d) (r).mmu_xq53[0] = d
#define BCM56218_A0_MMU_XQ53m_GET(r) (r).mmu_xq53[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_XQ53m_PARITY_0f_GET(r) (((r).mmu_xq53[0]) & 0x1)
#define BCM56218_A0_MMU_XQ53m_PARITY_0f_SET(r,f) (r).mmu_xq53[0]=(((r).mmu_xq53[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_MMU_XQ53m_L2f_GET(r) ((((r).mmu_xq53[0]) >> 1) & 0x1)
#define BCM56218_A0_MMU_XQ53m_L2f_SET(r,f) (r).mmu_xq53[0]=(((r).mmu_xq53[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_MMU_XQ53m_PURGEf_GET(r) ((((r).mmu_xq53[0]) >> 2) & 0x1)
#define BCM56218_A0_MMU_XQ53m_PURGEf_SET(r,f) (r).mmu_xq53[0]=(((r).mmu_xq53[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_MMU_XQ53m_PKT_PTRf_GET(r) ((((r).mmu_xq53[0]) >> 3) & 0x3fff)
#define BCM56218_A0_MMU_XQ53m_PKT_PTRf_SET(r,f) (r).mmu_xq53[0]=(((r).mmu_xq53[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56218_A0_MMU_XQ53m_RESERVED_0f_GET(r) ((((r).mmu_xq53[0]) >> 17) & 0x1)
#define BCM56218_A0_MMU_XQ53m_RESERVED_0f_SET(r,f) (r).mmu_xq53[0]=(((r).mmu_xq53[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_MMU_XQ53m_IMIRRORf_GET(r) ((((r).mmu_xq53[0]) >> 18) & 0x1)
#define BCM56218_A0_MMU_XQ53m_IMIRRORf_SET(r,f) (r).mmu_xq53[0]=(((r).mmu_xq53[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_MMU_XQ53m_EMIRRORf_GET(r) ((((r).mmu_xq53[0]) >> 19) & 0x1)
#define BCM56218_A0_MMU_XQ53m_EMIRRORf_SET(r,f) (r).mmu_xq53[0]=(((r).mmu_xq53[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ53.
 *
 */
#define BCM56218_A0_READ_MMU_XQ53m(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_XQ53m,i,(m._mmu_xq53),1)
#define BCM56218_A0_WRITE_MMU_XQ53m(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_XQ53m,i,&(m._mmu_xq53),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ53m BCM56218_A0_MMU_XQ53m
#define MMU_XQ53m_MIN BCM56218_A0_MMU_XQ53m_MIN
#define MMU_XQ53m_MAX BCM56218_A0_MMU_XQ53m_MAX
#define MMU_XQ53m_CMAX(u) BCM56218_A0_MMU_XQ53m_CMAX(u)
#define MMU_XQ53m_SIZE BCM56218_A0_MMU_XQ53m_SIZE
typedef BCM56218_A0_MMU_XQ53m_t MMU_XQ53m_t;
#define MMU_XQ53m_CLR BCM56218_A0_MMU_XQ53m_CLR
#define MMU_XQ53m_SET BCM56218_A0_MMU_XQ53m_SET
#define MMU_XQ53m_GET BCM56218_A0_MMU_XQ53m_GET
#define MMU_XQ53m_PARITY_0f_GET BCM56218_A0_MMU_XQ53m_PARITY_0f_GET
#define MMU_XQ53m_PARITY_0f_SET BCM56218_A0_MMU_XQ53m_PARITY_0f_SET
#define MMU_XQ53m_L2f_GET BCM56218_A0_MMU_XQ53m_L2f_GET
#define MMU_XQ53m_L2f_SET BCM56218_A0_MMU_XQ53m_L2f_SET
#define MMU_XQ53m_PURGEf_GET BCM56218_A0_MMU_XQ53m_PURGEf_GET
#define MMU_XQ53m_PURGEf_SET BCM56218_A0_MMU_XQ53m_PURGEf_SET
#define MMU_XQ53m_PKT_PTRf_GET BCM56218_A0_MMU_XQ53m_PKT_PTRf_GET
#define MMU_XQ53m_PKT_PTRf_SET BCM56218_A0_MMU_XQ53m_PKT_PTRf_SET
#define MMU_XQ53m_RESERVED_0f_GET BCM56218_A0_MMU_XQ53m_RESERVED_0f_GET
#define MMU_XQ53m_RESERVED_0f_SET BCM56218_A0_MMU_XQ53m_RESERVED_0f_SET
#define MMU_XQ53m_IMIRRORf_GET BCM56218_A0_MMU_XQ53m_IMIRRORf_GET
#define MMU_XQ53m_IMIRRORf_SET BCM56218_A0_MMU_XQ53m_IMIRRORf_SET
#define MMU_XQ53m_EMIRRORf_GET BCM56218_A0_MMU_XQ53m_EMIRRORf_GET
#define MMU_XQ53m_EMIRRORf_SET BCM56218_A0_MMU_XQ53m_EMIRRORf_SET
#define READ_MMU_XQ53m BCM56218_A0_READ_MMU_XQ53m
#define WRITE_MMU_XQ53m BCM56218_A0_WRITE_MMU_XQ53m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_XQ53m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_XQ6
 * BLOCKS:   MMU
 * DESC:     XQ6
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     RESERVED_0       reserved for future use
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_XQ6m 0x0b618000

#define BCM56218_A0_MMU_XQ6m_MIN 0
#define BCM56218_A0_MMU_XQ6m_MAX 511
#define BCM56218_A0_MMU_XQ6m_CMAX(u) 511
#define BCM56218_A0_MMU_XQ6m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ6.
 *
 */
typedef union BCM56218_A0_MMU_XQ6m_s {
	uint32_t v[1];
	uint32_t mmu_xq6[1];
	uint32_t _mmu_xq6;
} BCM56218_A0_MMU_XQ6m_t;

#define BCM56218_A0_MMU_XQ6m_CLR(r) (r).mmu_xq6[0] = 0
#define BCM56218_A0_MMU_XQ6m_SET(r,d) (r).mmu_xq6[0] = d
#define BCM56218_A0_MMU_XQ6m_GET(r) (r).mmu_xq6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_XQ6m_PARITY_0f_GET(r) (((r).mmu_xq6[0]) & 0x1)
#define BCM56218_A0_MMU_XQ6m_PARITY_0f_SET(r,f) (r).mmu_xq6[0]=(((r).mmu_xq6[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_MMU_XQ6m_L2f_GET(r) ((((r).mmu_xq6[0]) >> 1) & 0x1)
#define BCM56218_A0_MMU_XQ6m_L2f_SET(r,f) (r).mmu_xq6[0]=(((r).mmu_xq6[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_MMU_XQ6m_PURGEf_GET(r) ((((r).mmu_xq6[0]) >> 2) & 0x1)
#define BCM56218_A0_MMU_XQ6m_PURGEf_SET(r,f) (r).mmu_xq6[0]=(((r).mmu_xq6[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_MMU_XQ6m_PKT_PTRf_GET(r) ((((r).mmu_xq6[0]) >> 3) & 0x3fff)
#define BCM56218_A0_MMU_XQ6m_PKT_PTRf_SET(r,f) (r).mmu_xq6[0]=(((r).mmu_xq6[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56218_A0_MMU_XQ6m_RESERVED_0f_GET(r) ((((r).mmu_xq6[0]) >> 17) & 0x1)
#define BCM56218_A0_MMU_XQ6m_RESERVED_0f_SET(r,f) (r).mmu_xq6[0]=(((r).mmu_xq6[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_MMU_XQ6m_IMIRRORf_GET(r) ((((r).mmu_xq6[0]) >> 18) & 0x1)
#define BCM56218_A0_MMU_XQ6m_IMIRRORf_SET(r,f) (r).mmu_xq6[0]=(((r).mmu_xq6[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_MMU_XQ6m_EMIRRORf_GET(r) ((((r).mmu_xq6[0]) >> 19) & 0x1)
#define BCM56218_A0_MMU_XQ6m_EMIRRORf_SET(r,f) (r).mmu_xq6[0]=(((r).mmu_xq6[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ6.
 *
 */
#define BCM56218_A0_READ_MMU_XQ6m(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_XQ6m,i,(m._mmu_xq6),1)
#define BCM56218_A0_WRITE_MMU_XQ6m(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_XQ6m,i,&(m._mmu_xq6),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ6m BCM56218_A0_MMU_XQ6m
#define MMU_XQ6m_MIN BCM56218_A0_MMU_XQ6m_MIN
#define MMU_XQ6m_MAX BCM56218_A0_MMU_XQ6m_MAX
#define MMU_XQ6m_CMAX(u) BCM56218_A0_MMU_XQ6m_CMAX(u)
#define MMU_XQ6m_SIZE BCM56218_A0_MMU_XQ6m_SIZE
typedef BCM56218_A0_MMU_XQ6m_t MMU_XQ6m_t;
#define MMU_XQ6m_CLR BCM56218_A0_MMU_XQ6m_CLR
#define MMU_XQ6m_SET BCM56218_A0_MMU_XQ6m_SET
#define MMU_XQ6m_GET BCM56218_A0_MMU_XQ6m_GET
#define MMU_XQ6m_PARITY_0f_GET BCM56218_A0_MMU_XQ6m_PARITY_0f_GET
#define MMU_XQ6m_PARITY_0f_SET BCM56218_A0_MMU_XQ6m_PARITY_0f_SET
#define MMU_XQ6m_L2f_GET BCM56218_A0_MMU_XQ6m_L2f_GET
#define MMU_XQ6m_L2f_SET BCM56218_A0_MMU_XQ6m_L2f_SET
#define MMU_XQ6m_PURGEf_GET BCM56218_A0_MMU_XQ6m_PURGEf_GET
#define MMU_XQ6m_PURGEf_SET BCM56218_A0_MMU_XQ6m_PURGEf_SET
#define MMU_XQ6m_PKT_PTRf_GET BCM56218_A0_MMU_XQ6m_PKT_PTRf_GET
#define MMU_XQ6m_PKT_PTRf_SET BCM56218_A0_MMU_XQ6m_PKT_PTRf_SET
#define MMU_XQ6m_RESERVED_0f_GET BCM56218_A0_MMU_XQ6m_RESERVED_0f_GET
#define MMU_XQ6m_RESERVED_0f_SET BCM56218_A0_MMU_XQ6m_RESERVED_0f_SET
#define MMU_XQ6m_IMIRRORf_GET BCM56218_A0_MMU_XQ6m_IMIRRORf_GET
#define MMU_XQ6m_IMIRRORf_SET BCM56218_A0_MMU_XQ6m_IMIRRORf_SET
#define MMU_XQ6m_EMIRRORf_GET BCM56218_A0_MMU_XQ6m_EMIRRORf_GET
#define MMU_XQ6m_EMIRRORf_SET BCM56218_A0_MMU_XQ6m_EMIRRORf_SET
#define READ_MMU_XQ6m BCM56218_A0_READ_MMU_XQ6m
#define WRITE_MMU_XQ6m BCM56218_A0_WRITE_MMU_XQ6m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_XQ6m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_XQ7
 * BLOCKS:   MMU
 * DESC:     XQ7
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     RESERVED_0       reserved for future use
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_XQ7m 0x0b61c000

#define BCM56218_A0_MMU_XQ7m_MIN 0
#define BCM56218_A0_MMU_XQ7m_MAX 511
#define BCM56218_A0_MMU_XQ7m_CMAX(u) 511
#define BCM56218_A0_MMU_XQ7m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ7.
 *
 */
typedef union BCM56218_A0_MMU_XQ7m_s {
	uint32_t v[1];
	uint32_t mmu_xq7[1];
	uint32_t _mmu_xq7;
} BCM56218_A0_MMU_XQ7m_t;

#define BCM56218_A0_MMU_XQ7m_CLR(r) (r).mmu_xq7[0] = 0
#define BCM56218_A0_MMU_XQ7m_SET(r,d) (r).mmu_xq7[0] = d
#define BCM56218_A0_MMU_XQ7m_GET(r) (r).mmu_xq7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_XQ7m_PARITY_0f_GET(r) (((r).mmu_xq7[0]) & 0x1)
#define BCM56218_A0_MMU_XQ7m_PARITY_0f_SET(r,f) (r).mmu_xq7[0]=(((r).mmu_xq7[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_MMU_XQ7m_L2f_GET(r) ((((r).mmu_xq7[0]) >> 1) & 0x1)
#define BCM56218_A0_MMU_XQ7m_L2f_SET(r,f) (r).mmu_xq7[0]=(((r).mmu_xq7[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_MMU_XQ7m_PURGEf_GET(r) ((((r).mmu_xq7[0]) >> 2) & 0x1)
#define BCM56218_A0_MMU_XQ7m_PURGEf_SET(r,f) (r).mmu_xq7[0]=(((r).mmu_xq7[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_MMU_XQ7m_PKT_PTRf_GET(r) ((((r).mmu_xq7[0]) >> 3) & 0x3fff)
#define BCM56218_A0_MMU_XQ7m_PKT_PTRf_SET(r,f) (r).mmu_xq7[0]=(((r).mmu_xq7[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56218_A0_MMU_XQ7m_RESERVED_0f_GET(r) ((((r).mmu_xq7[0]) >> 17) & 0x1)
#define BCM56218_A0_MMU_XQ7m_RESERVED_0f_SET(r,f) (r).mmu_xq7[0]=(((r).mmu_xq7[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_MMU_XQ7m_IMIRRORf_GET(r) ((((r).mmu_xq7[0]) >> 18) & 0x1)
#define BCM56218_A0_MMU_XQ7m_IMIRRORf_SET(r,f) (r).mmu_xq7[0]=(((r).mmu_xq7[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_MMU_XQ7m_EMIRRORf_GET(r) ((((r).mmu_xq7[0]) >> 19) & 0x1)
#define BCM56218_A0_MMU_XQ7m_EMIRRORf_SET(r,f) (r).mmu_xq7[0]=(((r).mmu_xq7[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ7.
 *
 */
#define BCM56218_A0_READ_MMU_XQ7m(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_XQ7m,i,(m._mmu_xq7),1)
#define BCM56218_A0_WRITE_MMU_XQ7m(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_XQ7m,i,&(m._mmu_xq7),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ7m BCM56218_A0_MMU_XQ7m
#define MMU_XQ7m_MIN BCM56218_A0_MMU_XQ7m_MIN
#define MMU_XQ7m_MAX BCM56218_A0_MMU_XQ7m_MAX
#define MMU_XQ7m_CMAX(u) BCM56218_A0_MMU_XQ7m_CMAX(u)
#define MMU_XQ7m_SIZE BCM56218_A0_MMU_XQ7m_SIZE
typedef BCM56218_A0_MMU_XQ7m_t MMU_XQ7m_t;
#define MMU_XQ7m_CLR BCM56218_A0_MMU_XQ7m_CLR
#define MMU_XQ7m_SET BCM56218_A0_MMU_XQ7m_SET
#define MMU_XQ7m_GET BCM56218_A0_MMU_XQ7m_GET
#define MMU_XQ7m_PARITY_0f_GET BCM56218_A0_MMU_XQ7m_PARITY_0f_GET
#define MMU_XQ7m_PARITY_0f_SET BCM56218_A0_MMU_XQ7m_PARITY_0f_SET
#define MMU_XQ7m_L2f_GET BCM56218_A0_MMU_XQ7m_L2f_GET
#define MMU_XQ7m_L2f_SET BCM56218_A0_MMU_XQ7m_L2f_SET
#define MMU_XQ7m_PURGEf_GET BCM56218_A0_MMU_XQ7m_PURGEf_GET
#define MMU_XQ7m_PURGEf_SET BCM56218_A0_MMU_XQ7m_PURGEf_SET
#define MMU_XQ7m_PKT_PTRf_GET BCM56218_A0_MMU_XQ7m_PKT_PTRf_GET
#define MMU_XQ7m_PKT_PTRf_SET BCM56218_A0_MMU_XQ7m_PKT_PTRf_SET
#define MMU_XQ7m_RESERVED_0f_GET BCM56218_A0_MMU_XQ7m_RESERVED_0f_GET
#define MMU_XQ7m_RESERVED_0f_SET BCM56218_A0_MMU_XQ7m_RESERVED_0f_SET
#define MMU_XQ7m_IMIRRORf_GET BCM56218_A0_MMU_XQ7m_IMIRRORf_GET
#define MMU_XQ7m_IMIRRORf_SET BCM56218_A0_MMU_XQ7m_IMIRRORf_SET
#define MMU_XQ7m_EMIRRORf_GET BCM56218_A0_MMU_XQ7m_EMIRRORf_GET
#define MMU_XQ7m_EMIRRORf_SET BCM56218_A0_MMU_XQ7m_EMIRRORf_SET
#define READ_MMU_XQ7m BCM56218_A0_READ_MMU_XQ7m
#define WRITE_MMU_XQ7m BCM56218_A0_WRITE_MMU_XQ7m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_XQ7m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_XQ8
 * BLOCKS:   MMU
 * DESC:     XQ8
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     RESERVED_0       reserved for future use
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_XQ8m 0x0b620000

#define BCM56218_A0_MMU_XQ8m_MIN 0
#define BCM56218_A0_MMU_XQ8m_MAX 511
#define BCM56218_A0_MMU_XQ8m_CMAX(u) 511
#define BCM56218_A0_MMU_XQ8m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ8.
 *
 */
typedef union BCM56218_A0_MMU_XQ8m_s {
	uint32_t v[1];
	uint32_t mmu_xq8[1];
	uint32_t _mmu_xq8;
} BCM56218_A0_MMU_XQ8m_t;

#define BCM56218_A0_MMU_XQ8m_CLR(r) (r).mmu_xq8[0] = 0
#define BCM56218_A0_MMU_XQ8m_SET(r,d) (r).mmu_xq8[0] = d
#define BCM56218_A0_MMU_XQ8m_GET(r) (r).mmu_xq8[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_XQ8m_PARITY_0f_GET(r) (((r).mmu_xq8[0]) & 0x1)
#define BCM56218_A0_MMU_XQ8m_PARITY_0f_SET(r,f) (r).mmu_xq8[0]=(((r).mmu_xq8[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_MMU_XQ8m_L2f_GET(r) ((((r).mmu_xq8[0]) >> 1) & 0x1)
#define BCM56218_A0_MMU_XQ8m_L2f_SET(r,f) (r).mmu_xq8[0]=(((r).mmu_xq8[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_MMU_XQ8m_PURGEf_GET(r) ((((r).mmu_xq8[0]) >> 2) & 0x1)
#define BCM56218_A0_MMU_XQ8m_PURGEf_SET(r,f) (r).mmu_xq8[0]=(((r).mmu_xq8[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_MMU_XQ8m_PKT_PTRf_GET(r) ((((r).mmu_xq8[0]) >> 3) & 0x3fff)
#define BCM56218_A0_MMU_XQ8m_PKT_PTRf_SET(r,f) (r).mmu_xq8[0]=(((r).mmu_xq8[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56218_A0_MMU_XQ8m_RESERVED_0f_GET(r) ((((r).mmu_xq8[0]) >> 17) & 0x1)
#define BCM56218_A0_MMU_XQ8m_RESERVED_0f_SET(r,f) (r).mmu_xq8[0]=(((r).mmu_xq8[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_MMU_XQ8m_IMIRRORf_GET(r) ((((r).mmu_xq8[0]) >> 18) & 0x1)
#define BCM56218_A0_MMU_XQ8m_IMIRRORf_SET(r,f) (r).mmu_xq8[0]=(((r).mmu_xq8[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_MMU_XQ8m_EMIRRORf_GET(r) ((((r).mmu_xq8[0]) >> 19) & 0x1)
#define BCM56218_A0_MMU_XQ8m_EMIRRORf_SET(r,f) (r).mmu_xq8[0]=(((r).mmu_xq8[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ8.
 *
 */
#define BCM56218_A0_READ_MMU_XQ8m(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_XQ8m,i,(m._mmu_xq8),1)
#define BCM56218_A0_WRITE_MMU_XQ8m(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_XQ8m,i,&(m._mmu_xq8),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ8m BCM56218_A0_MMU_XQ8m
#define MMU_XQ8m_MIN BCM56218_A0_MMU_XQ8m_MIN
#define MMU_XQ8m_MAX BCM56218_A0_MMU_XQ8m_MAX
#define MMU_XQ8m_CMAX(u) BCM56218_A0_MMU_XQ8m_CMAX(u)
#define MMU_XQ8m_SIZE BCM56218_A0_MMU_XQ8m_SIZE
typedef BCM56218_A0_MMU_XQ8m_t MMU_XQ8m_t;
#define MMU_XQ8m_CLR BCM56218_A0_MMU_XQ8m_CLR
#define MMU_XQ8m_SET BCM56218_A0_MMU_XQ8m_SET
#define MMU_XQ8m_GET BCM56218_A0_MMU_XQ8m_GET
#define MMU_XQ8m_PARITY_0f_GET BCM56218_A0_MMU_XQ8m_PARITY_0f_GET
#define MMU_XQ8m_PARITY_0f_SET BCM56218_A0_MMU_XQ8m_PARITY_0f_SET
#define MMU_XQ8m_L2f_GET BCM56218_A0_MMU_XQ8m_L2f_GET
#define MMU_XQ8m_L2f_SET BCM56218_A0_MMU_XQ8m_L2f_SET
#define MMU_XQ8m_PURGEf_GET BCM56218_A0_MMU_XQ8m_PURGEf_GET
#define MMU_XQ8m_PURGEf_SET BCM56218_A0_MMU_XQ8m_PURGEf_SET
#define MMU_XQ8m_PKT_PTRf_GET BCM56218_A0_MMU_XQ8m_PKT_PTRf_GET
#define MMU_XQ8m_PKT_PTRf_SET BCM56218_A0_MMU_XQ8m_PKT_PTRf_SET
#define MMU_XQ8m_RESERVED_0f_GET BCM56218_A0_MMU_XQ8m_RESERVED_0f_GET
#define MMU_XQ8m_RESERVED_0f_SET BCM56218_A0_MMU_XQ8m_RESERVED_0f_SET
#define MMU_XQ8m_IMIRRORf_GET BCM56218_A0_MMU_XQ8m_IMIRRORf_GET
#define MMU_XQ8m_IMIRRORf_SET BCM56218_A0_MMU_XQ8m_IMIRRORf_SET
#define MMU_XQ8m_EMIRRORf_GET BCM56218_A0_MMU_XQ8m_EMIRRORf_GET
#define MMU_XQ8m_EMIRRORf_SET BCM56218_A0_MMU_XQ8m_EMIRRORf_SET
#define READ_MMU_XQ8m BCM56218_A0_READ_MMU_XQ8m
#define WRITE_MMU_XQ8m BCM56218_A0_WRITE_MMU_XQ8m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_XQ8m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MMU_XQ9
 * BLOCKS:   MMU
 * DESC:     XQ9
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     RESERVED_0       reserved for future use
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56218_A0_MMU_XQ9m 0x0b624000

#define BCM56218_A0_MMU_XQ9m_MIN 0
#define BCM56218_A0_MMU_XQ9m_MAX 511
#define BCM56218_A0_MMU_XQ9m_CMAX(u) 511
#define BCM56218_A0_MMU_XQ9m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ9.
 *
 */
typedef union BCM56218_A0_MMU_XQ9m_s {
	uint32_t v[1];
	uint32_t mmu_xq9[1];
	uint32_t _mmu_xq9;
} BCM56218_A0_MMU_XQ9m_t;

#define BCM56218_A0_MMU_XQ9m_CLR(r) (r).mmu_xq9[0] = 0
#define BCM56218_A0_MMU_XQ9m_SET(r,d) (r).mmu_xq9[0] = d
#define BCM56218_A0_MMU_XQ9m_GET(r) (r).mmu_xq9[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MMU_XQ9m_PARITY_0f_GET(r) (((r).mmu_xq9[0]) & 0x1)
#define BCM56218_A0_MMU_XQ9m_PARITY_0f_SET(r,f) (r).mmu_xq9[0]=(((r).mmu_xq9[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_MMU_XQ9m_L2f_GET(r) ((((r).mmu_xq9[0]) >> 1) & 0x1)
#define BCM56218_A0_MMU_XQ9m_L2f_SET(r,f) (r).mmu_xq9[0]=(((r).mmu_xq9[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_MMU_XQ9m_PURGEf_GET(r) ((((r).mmu_xq9[0]) >> 2) & 0x1)
#define BCM56218_A0_MMU_XQ9m_PURGEf_SET(r,f) (r).mmu_xq9[0]=(((r).mmu_xq9[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_MMU_XQ9m_PKT_PTRf_GET(r) ((((r).mmu_xq9[0]) >> 3) & 0x3fff)
#define BCM56218_A0_MMU_XQ9m_PKT_PTRf_SET(r,f) (r).mmu_xq9[0]=(((r).mmu_xq9[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56218_A0_MMU_XQ9m_RESERVED_0f_GET(r) ((((r).mmu_xq9[0]) >> 17) & 0x1)
#define BCM56218_A0_MMU_XQ9m_RESERVED_0f_SET(r,f) (r).mmu_xq9[0]=(((r).mmu_xq9[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_MMU_XQ9m_IMIRRORf_GET(r) ((((r).mmu_xq9[0]) >> 18) & 0x1)
#define BCM56218_A0_MMU_XQ9m_IMIRRORf_SET(r,f) (r).mmu_xq9[0]=(((r).mmu_xq9[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_MMU_XQ9m_EMIRRORf_GET(r) ((((r).mmu_xq9[0]) >> 19) & 0x1)
#define BCM56218_A0_MMU_XQ9m_EMIRRORf_SET(r,f) (r).mmu_xq9[0]=(((r).mmu_xq9[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ9.
 *
 */
#define BCM56218_A0_READ_MMU_XQ9m(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MMU_XQ9m,i,(m._mmu_xq9),1)
#define BCM56218_A0_WRITE_MMU_XQ9m(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MMU_XQ9m,i,&(m._mmu_xq9),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ9m BCM56218_A0_MMU_XQ9m
#define MMU_XQ9m_MIN BCM56218_A0_MMU_XQ9m_MIN
#define MMU_XQ9m_MAX BCM56218_A0_MMU_XQ9m_MAX
#define MMU_XQ9m_CMAX(u) BCM56218_A0_MMU_XQ9m_CMAX(u)
#define MMU_XQ9m_SIZE BCM56218_A0_MMU_XQ9m_SIZE
typedef BCM56218_A0_MMU_XQ9m_t MMU_XQ9m_t;
#define MMU_XQ9m_CLR BCM56218_A0_MMU_XQ9m_CLR
#define MMU_XQ9m_SET BCM56218_A0_MMU_XQ9m_SET
#define MMU_XQ9m_GET BCM56218_A0_MMU_XQ9m_GET
#define MMU_XQ9m_PARITY_0f_GET BCM56218_A0_MMU_XQ9m_PARITY_0f_GET
#define MMU_XQ9m_PARITY_0f_SET BCM56218_A0_MMU_XQ9m_PARITY_0f_SET
#define MMU_XQ9m_L2f_GET BCM56218_A0_MMU_XQ9m_L2f_GET
#define MMU_XQ9m_L2f_SET BCM56218_A0_MMU_XQ9m_L2f_SET
#define MMU_XQ9m_PURGEf_GET BCM56218_A0_MMU_XQ9m_PURGEf_GET
#define MMU_XQ9m_PURGEf_SET BCM56218_A0_MMU_XQ9m_PURGEf_SET
#define MMU_XQ9m_PKT_PTRf_GET BCM56218_A0_MMU_XQ9m_PKT_PTRf_GET
#define MMU_XQ9m_PKT_PTRf_SET BCM56218_A0_MMU_XQ9m_PKT_PTRf_SET
#define MMU_XQ9m_RESERVED_0f_GET BCM56218_A0_MMU_XQ9m_RESERVED_0f_GET
#define MMU_XQ9m_RESERVED_0f_SET BCM56218_A0_MMU_XQ9m_RESERVED_0f_SET
#define MMU_XQ9m_IMIRRORf_GET BCM56218_A0_MMU_XQ9m_IMIRRORf_GET
#define MMU_XQ9m_IMIRRORf_SET BCM56218_A0_MMU_XQ9m_IMIRRORf_SET
#define MMU_XQ9m_EMIRRORf_GET BCM56218_A0_MMU_XQ9m_EMIRRORf_GET
#define MMU_XQ9m_EMIRRORf_SET BCM56218_A0_MMU_XQ9m_EMIRRORf_SET
#define READ_MMU_XQ9m BCM56218_A0_READ_MMU_XQ9m
#define WRITE_MMU_XQ9m BCM56218_A0_WRITE_MMU_XQ9m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MMU_XQ9m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MODPORT_MAP
 * BLOCKS:   IPIPE
 * DESC:     Module Port Mapping Table. Writing to this view updates all 3 copies of the MODPORT_TABLE, i.e. MODPORT_MAP_SW, MODPORT_MAP_IM, MODPORT_MAP_EM. Reading this table results in data from MODPORT_MAP_SW only. Each tables index is constructed by {block_num(2bits), modid(4bits)}. Block_num indicates which of the 4 tables are needed to be looked at within MODPORT_MAP table., 
 * SIZE:     2
 * FIELDS:
 *     HIGIG_PORT_BITMAP HiGig destination port bitmap
 *
 ******************************************************************************/
#define BCM56218_A0_MODPORT_MAPm 0x0e750000

#define BCM56218_A0_MODPORT_MAPm_MIN 0
#define BCM56218_A0_MODPORT_MAPm_MAX 63
#define BCM56218_A0_MODPORT_MAPm_CMAX(u) 63
#define BCM56218_A0_MODPORT_MAPm_SIZE 1

/*
 * This structure should be used to declare and program MODPORT_MAP.
 *
 */
typedef union BCM56218_A0_MODPORT_MAPm_s {
	uint32_t v[1];
	uint32_t modport_map[1];
	uint32_t _modport_map;
} BCM56218_A0_MODPORT_MAPm_t;

#define BCM56218_A0_MODPORT_MAPm_CLR(r) (r).modport_map[0] = 0
#define BCM56218_A0_MODPORT_MAPm_SET(r,d) (r).modport_map[0] = d
#define BCM56218_A0_MODPORT_MAPm_GET(r) (r).modport_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MODPORT_MAPm_HIGIG_PORT_BITMAPf_GET(r) (((r).modport_map[0]) & 0x3)
#define BCM56218_A0_MODPORT_MAPm_HIGIG_PORT_BITMAPf_SET(r,f) (r).modport_map[0]=(((r).modport_map[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))

/*
 * These macros can be used to access MODPORT_MAP.
 *
 */
#define BCM56218_A0_READ_MODPORT_MAPm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MODPORT_MAPm,i,(m._modport_map),1)
#define BCM56218_A0_WRITE_MODPORT_MAPm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MODPORT_MAPm,i,&(m._modport_map),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MODPORT_MAPm BCM56218_A0_MODPORT_MAPm
#define MODPORT_MAPm_MIN BCM56218_A0_MODPORT_MAPm_MIN
#define MODPORT_MAPm_MAX BCM56218_A0_MODPORT_MAPm_MAX
#define MODPORT_MAPm_CMAX(u) BCM56218_A0_MODPORT_MAPm_CMAX(u)
#define MODPORT_MAPm_SIZE BCM56218_A0_MODPORT_MAPm_SIZE
typedef BCM56218_A0_MODPORT_MAPm_t MODPORT_MAPm_t;
#define MODPORT_MAPm_CLR BCM56218_A0_MODPORT_MAPm_CLR
#define MODPORT_MAPm_SET BCM56218_A0_MODPORT_MAPm_SET
#define MODPORT_MAPm_GET BCM56218_A0_MODPORT_MAPm_GET
#define MODPORT_MAPm_HIGIG_PORT_BITMAPf_GET BCM56218_A0_MODPORT_MAPm_HIGIG_PORT_BITMAPf_GET
#define MODPORT_MAPm_HIGIG_PORT_BITMAPf_SET BCM56218_A0_MODPORT_MAPm_HIGIG_PORT_BITMAPf_SET
#define READ_MODPORT_MAPm BCM56218_A0_READ_MODPORT_MAPm
#define WRITE_MODPORT_MAPm BCM56218_A0_WRITE_MODPORT_MAPm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MODPORT_MAPm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MODPORT_MAP_EM
 * BLOCKS:   IPIPE
 * DESC:     Third physical copy of Module Port Mapping Table - used for mapping the egress mirrored copy of a packet. User may individually read, write this table witout affecting the contents of other tables.
 * SIZE:     2
 * FIELDS:
 *     HIGIG_PORT_BITMAP HiGig destination port bitmap
 *
 ******************************************************************************/
#define BCM56218_A0_MODPORT_MAP_EMm 0x0e780000

#define BCM56218_A0_MODPORT_MAP_EMm_MIN 0
#define BCM56218_A0_MODPORT_MAP_EMm_MAX 63
#define BCM56218_A0_MODPORT_MAP_EMm_CMAX(u) 63
#define BCM56218_A0_MODPORT_MAP_EMm_SIZE 1

/*
 * This structure should be used to declare and program MODPORT_MAP_EM.
 *
 */
typedef union BCM56218_A0_MODPORT_MAP_EMm_s {
	uint32_t v[1];
	uint32_t modport_map_em[1];
	uint32_t _modport_map_em;
} BCM56218_A0_MODPORT_MAP_EMm_t;

#define BCM56218_A0_MODPORT_MAP_EMm_CLR(r) (r).modport_map_em[0] = 0
#define BCM56218_A0_MODPORT_MAP_EMm_SET(r,d) (r).modport_map_em[0] = d
#define BCM56218_A0_MODPORT_MAP_EMm_GET(r) (r).modport_map_em[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MODPORT_MAP_EMm_HIGIG_PORT_BITMAPf_GET(r) (((r).modport_map_em[0]) & 0x3)
#define BCM56218_A0_MODPORT_MAP_EMm_HIGIG_PORT_BITMAPf_SET(r,f) (r).modport_map_em[0]=(((r).modport_map_em[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))

/*
 * These macros can be used to access MODPORT_MAP_EM.
 *
 */
#define BCM56218_A0_READ_MODPORT_MAP_EMm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MODPORT_MAP_EMm,i,(m._modport_map_em),1)
#define BCM56218_A0_WRITE_MODPORT_MAP_EMm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MODPORT_MAP_EMm,i,&(m._modport_map_em),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MODPORT_MAP_EMm BCM56218_A0_MODPORT_MAP_EMm
#define MODPORT_MAP_EMm_MIN BCM56218_A0_MODPORT_MAP_EMm_MIN
#define MODPORT_MAP_EMm_MAX BCM56218_A0_MODPORT_MAP_EMm_MAX
#define MODPORT_MAP_EMm_CMAX(u) BCM56218_A0_MODPORT_MAP_EMm_CMAX(u)
#define MODPORT_MAP_EMm_SIZE BCM56218_A0_MODPORT_MAP_EMm_SIZE
typedef BCM56218_A0_MODPORT_MAP_EMm_t MODPORT_MAP_EMm_t;
#define MODPORT_MAP_EMm_CLR BCM56218_A0_MODPORT_MAP_EMm_CLR
#define MODPORT_MAP_EMm_SET BCM56218_A0_MODPORT_MAP_EMm_SET
#define MODPORT_MAP_EMm_GET BCM56218_A0_MODPORT_MAP_EMm_GET
#define MODPORT_MAP_EMm_HIGIG_PORT_BITMAPf_GET BCM56218_A0_MODPORT_MAP_EMm_HIGIG_PORT_BITMAPf_GET
#define MODPORT_MAP_EMm_HIGIG_PORT_BITMAPf_SET BCM56218_A0_MODPORT_MAP_EMm_HIGIG_PORT_BITMAPf_SET
#define READ_MODPORT_MAP_EMm BCM56218_A0_READ_MODPORT_MAP_EMm
#define WRITE_MODPORT_MAP_EMm BCM56218_A0_WRITE_MODPORT_MAP_EMm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MODPORT_MAP_EMm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MODPORT_MAP_IM
 * BLOCKS:   IPIPE
 * DESC:     Second physical copy of Module Port Mapping Table - used for mapping the ingress mirrored copy of a packet. User may individually read, write this table witout affecting the contents of other tables.
 * SIZE:     2
 * FIELDS:
 *     HIGIG_PORT_BITMAP HiGig destination port bitmap
 *
 ******************************************************************************/
#define BCM56218_A0_MODPORT_MAP_IMm 0x0e770000

#define BCM56218_A0_MODPORT_MAP_IMm_MIN 0
#define BCM56218_A0_MODPORT_MAP_IMm_MAX 63
#define BCM56218_A0_MODPORT_MAP_IMm_CMAX(u) 63
#define BCM56218_A0_MODPORT_MAP_IMm_SIZE 1

/*
 * This structure should be used to declare and program MODPORT_MAP_IM.
 *
 */
typedef union BCM56218_A0_MODPORT_MAP_IMm_s {
	uint32_t v[1];
	uint32_t modport_map_im[1];
	uint32_t _modport_map_im;
} BCM56218_A0_MODPORT_MAP_IMm_t;

#define BCM56218_A0_MODPORT_MAP_IMm_CLR(r) (r).modport_map_im[0] = 0
#define BCM56218_A0_MODPORT_MAP_IMm_SET(r,d) (r).modport_map_im[0] = d
#define BCM56218_A0_MODPORT_MAP_IMm_GET(r) (r).modport_map_im[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MODPORT_MAP_IMm_HIGIG_PORT_BITMAPf_GET(r) (((r).modport_map_im[0]) & 0x3)
#define BCM56218_A0_MODPORT_MAP_IMm_HIGIG_PORT_BITMAPf_SET(r,f) (r).modport_map_im[0]=(((r).modport_map_im[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))

/*
 * These macros can be used to access MODPORT_MAP_IM.
 *
 */
#define BCM56218_A0_READ_MODPORT_MAP_IMm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MODPORT_MAP_IMm,i,(m._modport_map_im),1)
#define BCM56218_A0_WRITE_MODPORT_MAP_IMm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MODPORT_MAP_IMm,i,&(m._modport_map_im),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MODPORT_MAP_IMm BCM56218_A0_MODPORT_MAP_IMm
#define MODPORT_MAP_IMm_MIN BCM56218_A0_MODPORT_MAP_IMm_MIN
#define MODPORT_MAP_IMm_MAX BCM56218_A0_MODPORT_MAP_IMm_MAX
#define MODPORT_MAP_IMm_CMAX(u) BCM56218_A0_MODPORT_MAP_IMm_CMAX(u)
#define MODPORT_MAP_IMm_SIZE BCM56218_A0_MODPORT_MAP_IMm_SIZE
typedef BCM56218_A0_MODPORT_MAP_IMm_t MODPORT_MAP_IMm_t;
#define MODPORT_MAP_IMm_CLR BCM56218_A0_MODPORT_MAP_IMm_CLR
#define MODPORT_MAP_IMm_SET BCM56218_A0_MODPORT_MAP_IMm_SET
#define MODPORT_MAP_IMm_GET BCM56218_A0_MODPORT_MAP_IMm_GET
#define MODPORT_MAP_IMm_HIGIG_PORT_BITMAPf_GET BCM56218_A0_MODPORT_MAP_IMm_HIGIG_PORT_BITMAPf_GET
#define MODPORT_MAP_IMm_HIGIG_PORT_BITMAPf_SET BCM56218_A0_MODPORT_MAP_IMm_HIGIG_PORT_BITMAPf_SET
#define READ_MODPORT_MAP_IMm BCM56218_A0_READ_MODPORT_MAP_IMm
#define WRITE_MODPORT_MAP_IMm BCM56218_A0_WRITE_MODPORT_MAP_IMm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MODPORT_MAP_IMm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  MODPORT_MAP_SW
 * BLOCKS:   IPIPE
 * DESC:     First physical copy of Module Port Mapping Table - used for mapping the switched copy of a packet. User may individually read, write this table witout affecting the contents of other tables(MODPORT_MAP_IM, MODPORT_MAP_EM).
 * SIZE:     2
 * FIELDS:
 *     HIGIG_PORT_BITMAP HiGig destination port bitmap
 *
 ******************************************************************************/
#define BCM56218_A0_MODPORT_MAP_SWm 0x0e760000

#define BCM56218_A0_MODPORT_MAP_SWm_MIN 0
#define BCM56218_A0_MODPORT_MAP_SWm_MAX 63
#define BCM56218_A0_MODPORT_MAP_SWm_CMAX(u) 63
#define BCM56218_A0_MODPORT_MAP_SWm_SIZE 1

/*
 * This structure should be used to declare and program MODPORT_MAP_SW.
 *
 */
typedef union BCM56218_A0_MODPORT_MAP_SWm_s {
	uint32_t v[1];
	uint32_t modport_map_sw[1];
	uint32_t _modport_map_sw;
} BCM56218_A0_MODPORT_MAP_SWm_t;

#define BCM56218_A0_MODPORT_MAP_SWm_CLR(r) (r).modport_map_sw[0] = 0
#define BCM56218_A0_MODPORT_MAP_SWm_SET(r,d) (r).modport_map_sw[0] = d
#define BCM56218_A0_MODPORT_MAP_SWm_GET(r) (r).modport_map_sw[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_MODPORT_MAP_SWm_HIGIG_PORT_BITMAPf_GET(r) (((r).modport_map_sw[0]) & 0x3)
#define BCM56218_A0_MODPORT_MAP_SWm_HIGIG_PORT_BITMAPf_SET(r,f) (r).modport_map_sw[0]=(((r).modport_map_sw[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))

/*
 * These macros can be used to access MODPORT_MAP_SW.
 *
 */
#define BCM56218_A0_READ_MODPORT_MAP_SWm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_MODPORT_MAP_SWm,i,(m._modport_map_sw),1)
#define BCM56218_A0_WRITE_MODPORT_MAP_SWm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_MODPORT_MAP_SWm,i,&(m._modport_map_sw),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MODPORT_MAP_SWm BCM56218_A0_MODPORT_MAP_SWm
#define MODPORT_MAP_SWm_MIN BCM56218_A0_MODPORT_MAP_SWm_MIN
#define MODPORT_MAP_SWm_MAX BCM56218_A0_MODPORT_MAP_SWm_MAX
#define MODPORT_MAP_SWm_CMAX(u) BCM56218_A0_MODPORT_MAP_SWm_CMAX(u)
#define MODPORT_MAP_SWm_SIZE BCM56218_A0_MODPORT_MAP_SWm_SIZE
typedef BCM56218_A0_MODPORT_MAP_SWm_t MODPORT_MAP_SWm_t;
#define MODPORT_MAP_SWm_CLR BCM56218_A0_MODPORT_MAP_SWm_CLR
#define MODPORT_MAP_SWm_SET BCM56218_A0_MODPORT_MAP_SWm_SET
#define MODPORT_MAP_SWm_GET BCM56218_A0_MODPORT_MAP_SWm_GET
#define MODPORT_MAP_SWm_HIGIG_PORT_BITMAPf_GET BCM56218_A0_MODPORT_MAP_SWm_HIGIG_PORT_BITMAPf_GET
#define MODPORT_MAP_SWm_HIGIG_PORT_BITMAPf_SET BCM56218_A0_MODPORT_MAP_SWm_HIGIG_PORT_BITMAPf_SET
#define READ_MODPORT_MAP_SWm BCM56218_A0_READ_MODPORT_MAP_SWm
#define WRITE_MODPORT_MAP_SWm BCM56218_A0_WRITE_MODPORT_MAP_SWm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_MODPORT_MAP_SWm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  NONUCAST_TRUNK_BLOCK_MASK
 * BLOCKS:   IPIPE
 * DESC:     Multicast and Broadcast Trunk Block Mask Table
 * SIZE:     54
 * FIELDS:
 *     BLOCK_MASK       Multicast/broadcast trunk block mask
 *     BLOCK_MASK_LO    Multicast/broadcast trunk block mask
 *     BLOCK_MASK_HI    Multicast/broadcast trunk block mask
 *
 ******************************************************************************/
#define BCM56218_A0_NONUCAST_TRUNK_BLOCK_MASKm 0x0e790000

#define BCM56218_A0_NONUCAST_TRUNK_BLOCK_MASKm_MIN 0
#define BCM56218_A0_NONUCAST_TRUNK_BLOCK_MASKm_MAX 15
#define BCM56218_A0_NONUCAST_TRUNK_BLOCK_MASKm_CMAX(u) 15
#define BCM56218_A0_NONUCAST_TRUNK_BLOCK_MASKm_SIZE 7

/*
 * This structure should be used to declare and program NONUCAST_TRUNK_BLOCK_MASK.
 *
 */
typedef union BCM56218_A0_NONUCAST_TRUNK_BLOCK_MASKm_s {
	uint32_t v[2];
	uint32_t nonucast_trunk_block_mask[2];
	uint32_t _nonucast_trunk_block_mask;
} BCM56218_A0_NONUCAST_TRUNK_BLOCK_MASKm_t;

#define BCM56218_A0_NONUCAST_TRUNK_BLOCK_MASKm_CLR(r) CDK_MEMSET(&((r)._nonucast_trunk_block_mask), 0, sizeof(BCM56218_A0_NONUCAST_TRUNK_BLOCK_MASKm_t))
#define BCM56218_A0_NONUCAST_TRUNK_BLOCK_MASKm_SET(r,i,d) (r).nonucast_trunk_block_mask[i] = d
#define BCM56218_A0_NONUCAST_TRUNK_BLOCK_MASKm_GET(r,i) (r).nonucast_trunk_block_mask[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_NONUCAST_TRUNK_BLOCK_MASKm_BLOCK_MASKf_GET(r,a) cdk_field_get((r).nonucast_trunk_block_mask,0,53,a)
#define BCM56218_A0_NONUCAST_TRUNK_BLOCK_MASKm_BLOCK_MASKf_SET(r,a) cdk_field_set((r).nonucast_trunk_block_mask,0,53,a)
#define BCM56218_A0_NONUCAST_TRUNK_BLOCK_MASKm_BLOCK_MASK_LOf_GET(r) ((r).nonucast_trunk_block_mask[0])
#define BCM56218_A0_NONUCAST_TRUNK_BLOCK_MASKm_BLOCK_MASK_LOf_SET(r,f) (r).nonucast_trunk_block_mask[0]=((uint32_t)f)
#define BCM56218_A0_NONUCAST_TRUNK_BLOCK_MASKm_BLOCK_MASK_HIf_GET(r) (((r).nonucast_trunk_block_mask[1]) & 0x3fffff)
#define BCM56218_A0_NONUCAST_TRUNK_BLOCK_MASKm_BLOCK_MASK_HIf_SET(r,f) (r).nonucast_trunk_block_mask[1]=(((r).nonucast_trunk_block_mask[1] & ~((uint32_t)0x3fffff)) | (((uint32_t)f) & 0x3fffff))

/*
 * These macros can be used to access NONUCAST_TRUNK_BLOCK_MASK.
 *
 */
#define BCM56218_A0_READ_NONUCAST_TRUNK_BLOCK_MASKm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_NONUCAST_TRUNK_BLOCK_MASKm,i,(m._nonucast_trunk_block_mask),2)
#define BCM56218_A0_WRITE_NONUCAST_TRUNK_BLOCK_MASKm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_NONUCAST_TRUNK_BLOCK_MASKm,i,&(m._nonucast_trunk_block_mask),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define NONUCAST_TRUNK_BLOCK_MASKm BCM56218_A0_NONUCAST_TRUNK_BLOCK_MASKm
#define NONUCAST_TRUNK_BLOCK_MASKm_MIN BCM56218_A0_NONUCAST_TRUNK_BLOCK_MASKm_MIN
#define NONUCAST_TRUNK_BLOCK_MASKm_MAX BCM56218_A0_NONUCAST_TRUNK_BLOCK_MASKm_MAX
#define NONUCAST_TRUNK_BLOCK_MASKm_CMAX(u) BCM56218_A0_NONUCAST_TRUNK_BLOCK_MASKm_CMAX(u)
#define NONUCAST_TRUNK_BLOCK_MASKm_SIZE BCM56218_A0_NONUCAST_TRUNK_BLOCK_MASKm_SIZE
typedef BCM56218_A0_NONUCAST_TRUNK_BLOCK_MASKm_t NONUCAST_TRUNK_BLOCK_MASKm_t;
#define NONUCAST_TRUNK_BLOCK_MASKm_CLR BCM56218_A0_NONUCAST_TRUNK_BLOCK_MASKm_CLR
#define NONUCAST_TRUNK_BLOCK_MASKm_SET BCM56218_A0_NONUCAST_TRUNK_BLOCK_MASKm_SET
#define NONUCAST_TRUNK_BLOCK_MASKm_GET BCM56218_A0_NONUCAST_TRUNK_BLOCK_MASKm_GET
#define NONUCAST_TRUNK_BLOCK_MASKm_BLOCK_MASKf_GET BCM56218_A0_NONUCAST_TRUNK_BLOCK_MASKm_BLOCK_MASKf_GET
#define NONUCAST_TRUNK_BLOCK_MASKm_BLOCK_MASKf_SET BCM56218_A0_NONUCAST_TRUNK_BLOCK_MASKm_BLOCK_MASKf_SET
#define NONUCAST_TRUNK_BLOCK_MASKm_BLOCK_MASK_LOf_GET BCM56218_A0_NONUCAST_TRUNK_BLOCK_MASKm_BLOCK_MASK_LOf_GET
#define NONUCAST_TRUNK_BLOCK_MASKm_BLOCK_MASK_LOf_SET BCM56218_A0_NONUCAST_TRUNK_BLOCK_MASKm_BLOCK_MASK_LOf_SET
#define NONUCAST_TRUNK_BLOCK_MASKm_BLOCK_MASK_HIf_GET BCM56218_A0_NONUCAST_TRUNK_BLOCK_MASKm_BLOCK_MASK_HIf_GET
#define NONUCAST_TRUNK_BLOCK_MASKm_BLOCK_MASK_HIf_SET BCM56218_A0_NONUCAST_TRUNK_BLOCK_MASKm_BLOCK_MASK_HIf_SET
#define READ_NONUCAST_TRUNK_BLOCK_MASKm BCM56218_A0_READ_NONUCAST_TRUNK_BLOCK_MASKm
#define WRITE_NONUCAST_TRUNK_BLOCK_MASKm BCM56218_A0_WRITE_NONUCAST_TRUNK_BLOCK_MASKm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_NONUCAST_TRUNK_BLOCK_MASKm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  PAUSE_CONTROL
 * BLOCKS:   GPORT0
 * DESC:     PAUSE frame timer control register
 * SIZE:     32
 * FIELDS:
 *     VALUE            Each bit in this register represents 512 bit times independent of the port speed. Values of 0 and 1 are illegal.
 *     ENABLE           Enable Extra Pause Frames.
 *
 ******************************************************************************/
#define BCM56218_A0_PAUSE_CONTROLr 0x00000302

#define BCM56218_A0_PAUSE_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program PAUSE_CONTROL.
 *
 */
typedef union BCM56218_A0_PAUSE_CONTROLr_s {
	uint32_t v[1];
	uint32_t pause_control[1];
	uint32_t _pause_control;
} BCM56218_A0_PAUSE_CONTROLr_t;

#define BCM56218_A0_PAUSE_CONTROLr_CLR(r) (r).pause_control[0] = 0
#define BCM56218_A0_PAUSE_CONTROLr_SET(r,d) (r).pause_control[0] = d
#define BCM56218_A0_PAUSE_CONTROLr_GET(r) (r).pause_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_PAUSE_CONTROLr_VALUEf_GET(r) (((r).pause_control[0]) & 0x1ffff)
#define BCM56218_A0_PAUSE_CONTROLr_VALUEf_SET(r,f) (r).pause_control[0]=(((r).pause_control[0] & ~((uint32_t)0x1ffff)) | (((uint32_t)f) & 0x1ffff))
#define BCM56218_A0_PAUSE_CONTROLr_ENABLEf_GET(r) ((((r).pause_control[0]) >> 17) & 0x1)
#define BCM56218_A0_PAUSE_CONTROLr_ENABLEf_SET(r,f) (r).pause_control[0]=(((r).pause_control[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))

/*
 * These macros can be used to access PAUSE_CONTROL.
 *
 */
#define BCM56218_A0_READ_PAUSE_CONTROLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_PAUSE_CONTROLr,(r._pause_control))
#define BCM56218_A0_WRITE_PAUSE_CONTROLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_PAUSE_CONTROLr,&(r._pause_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PAUSE_CONTROLr BCM56218_A0_PAUSE_CONTROLr
#define PAUSE_CONTROLr_SIZE BCM56218_A0_PAUSE_CONTROLr_SIZE
typedef BCM56218_A0_PAUSE_CONTROLr_t PAUSE_CONTROLr_t;
#define PAUSE_CONTROLr_CLR BCM56218_A0_PAUSE_CONTROLr_CLR
#define PAUSE_CONTROLr_SET BCM56218_A0_PAUSE_CONTROLr_SET
#define PAUSE_CONTROLr_GET BCM56218_A0_PAUSE_CONTROLr_GET
#define PAUSE_CONTROLr_VALUEf_GET BCM56218_A0_PAUSE_CONTROLr_VALUEf_GET
#define PAUSE_CONTROLr_VALUEf_SET BCM56218_A0_PAUSE_CONTROLr_VALUEf_SET
#define PAUSE_CONTROLr_ENABLEf_GET BCM56218_A0_PAUSE_CONTROLr_ENABLEf_GET
#define PAUSE_CONTROLr_ENABLEf_SET BCM56218_A0_PAUSE_CONTROLr_ENABLEf_SET
#define READ_PAUSE_CONTROLr BCM56218_A0_READ_PAUSE_CONTROLr
#define WRITE_PAUSE_CONTROLr BCM56218_A0_WRITE_PAUSE_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_PAUSE_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  PER_PORT_AGE_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     Per Port Aging Control Register
 * SIZE:     32
 * FIELDS:
 *     TGID_PORT        trunk group or port number
 *     MODULE_ID        module id
 *     VLAN_ID          vlan id
 *     PPA_MODE         indicates selection criteria, deletion versus replacement
 *     EXCL_STATIC      exclude static entries from deletion and replacement
 *     START            initiate per port aging
 *     COMPLETE         signal per port aging is complete
 *
 ******************************************************************************/
#define BCM56218_A0_PER_PORT_AGE_CONTROLr 0x00780004

#define BCM56218_A0_PER_PORT_AGE_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program PER_PORT_AGE_CONTROL.
 *
 */
typedef union BCM56218_A0_PER_PORT_AGE_CONTROLr_s {
	uint32_t v[1];
	uint32_t per_port_age_control[1];
	uint32_t _per_port_age_control;
} BCM56218_A0_PER_PORT_AGE_CONTROLr_t;

#define BCM56218_A0_PER_PORT_AGE_CONTROLr_CLR(r) (r).per_port_age_control[0] = 0
#define BCM56218_A0_PER_PORT_AGE_CONTROLr_SET(r,d) (r).per_port_age_control[0] = d
#define BCM56218_A0_PER_PORT_AGE_CONTROLr_GET(r) (r).per_port_age_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_PER_PORT_AGE_CONTROLr_TGID_PORTf_GET(r) (((r).per_port_age_control[0]) & 0x7f)
#define BCM56218_A0_PER_PORT_AGE_CONTROLr_TGID_PORTf_SET(r,f) (r).per_port_age_control[0]=(((r).per_port_age_control[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f))
#define BCM56218_A0_PER_PORT_AGE_CONTROLr_MODULE_IDf_GET(r) ((((r).per_port_age_control[0]) >> 7) & 0xf)
#define BCM56218_A0_PER_PORT_AGE_CONTROLr_MODULE_IDf_SET(r,f) (r).per_port_age_control[0]=(((r).per_port_age_control[0] & ~((uint32_t)0xf << 7)) | ((((uint32_t)f) & 0xf) << 7))
#define BCM56218_A0_PER_PORT_AGE_CONTROLr_VLAN_IDf_GET(r) ((((r).per_port_age_control[0]) >> 11) & 0xfff)
#define BCM56218_A0_PER_PORT_AGE_CONTROLr_VLAN_IDf_SET(r,f) (r).per_port_age_control[0]=(((r).per_port_age_control[0] & ~((uint32_t)0xfff << 11)) | ((((uint32_t)f) & 0xfff) << 11))
#define BCM56218_A0_PER_PORT_AGE_CONTROLr_PPA_MODEf_GET(r) ((((r).per_port_age_control[0]) >> 23) & 0x7)
#define BCM56218_A0_PER_PORT_AGE_CONTROLr_PPA_MODEf_SET(r,f) (r).per_port_age_control[0]=(((r).per_port_age_control[0] & ~((uint32_t)0x7 << 23)) | ((((uint32_t)f) & 0x7) << 23))
#define BCM56218_A0_PER_PORT_AGE_CONTROLr_EXCL_STATICf_GET(r) ((((r).per_port_age_control[0]) >> 26) & 0x1)
#define BCM56218_A0_PER_PORT_AGE_CONTROLr_EXCL_STATICf_SET(r,f) (r).per_port_age_control[0]=(((r).per_port_age_control[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM56218_A0_PER_PORT_AGE_CONTROLr_STARTf_GET(r) ((((r).per_port_age_control[0]) >> 27) & 0x1)
#define BCM56218_A0_PER_PORT_AGE_CONTROLr_STARTf_SET(r,f) (r).per_port_age_control[0]=(((r).per_port_age_control[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM56218_A0_PER_PORT_AGE_CONTROLr_COMPLETEf_GET(r) ((((r).per_port_age_control[0]) >> 28) & 0x1)
#define BCM56218_A0_PER_PORT_AGE_CONTROLr_COMPLETEf_SET(r,f) (r).per_port_age_control[0]=(((r).per_port_age_control[0] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))

/*
 * These macros can be used to access PER_PORT_AGE_CONTROL.
 *
 */
#define BCM56218_A0_READ_PER_PORT_AGE_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_PER_PORT_AGE_CONTROLr,(r._per_port_age_control))
#define BCM56218_A0_WRITE_PER_PORT_AGE_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_PER_PORT_AGE_CONTROLr,&(r._per_port_age_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PER_PORT_AGE_CONTROLr BCM56218_A0_PER_PORT_AGE_CONTROLr
#define PER_PORT_AGE_CONTROLr_SIZE BCM56218_A0_PER_PORT_AGE_CONTROLr_SIZE
typedef BCM56218_A0_PER_PORT_AGE_CONTROLr_t PER_PORT_AGE_CONTROLr_t;
#define PER_PORT_AGE_CONTROLr_CLR BCM56218_A0_PER_PORT_AGE_CONTROLr_CLR
#define PER_PORT_AGE_CONTROLr_SET BCM56218_A0_PER_PORT_AGE_CONTROLr_SET
#define PER_PORT_AGE_CONTROLr_GET BCM56218_A0_PER_PORT_AGE_CONTROLr_GET
#define PER_PORT_AGE_CONTROLr_TGID_PORTf_GET BCM56218_A0_PER_PORT_AGE_CONTROLr_TGID_PORTf_GET
#define PER_PORT_AGE_CONTROLr_TGID_PORTf_SET BCM56218_A0_PER_PORT_AGE_CONTROLr_TGID_PORTf_SET
#define PER_PORT_AGE_CONTROLr_MODULE_IDf_GET BCM56218_A0_PER_PORT_AGE_CONTROLr_MODULE_IDf_GET
#define PER_PORT_AGE_CONTROLr_MODULE_IDf_SET BCM56218_A0_PER_PORT_AGE_CONTROLr_MODULE_IDf_SET
#define PER_PORT_AGE_CONTROLr_VLAN_IDf_GET BCM56218_A0_PER_PORT_AGE_CONTROLr_VLAN_IDf_GET
#define PER_PORT_AGE_CONTROLr_VLAN_IDf_SET BCM56218_A0_PER_PORT_AGE_CONTROLr_VLAN_IDf_SET
#define PER_PORT_AGE_CONTROLr_PPA_MODEf_GET BCM56218_A0_PER_PORT_AGE_CONTROLr_PPA_MODEf_GET
#define PER_PORT_AGE_CONTROLr_PPA_MODEf_SET BCM56218_A0_PER_PORT_AGE_CONTROLr_PPA_MODEf_SET
#define PER_PORT_AGE_CONTROLr_EXCL_STATICf_GET BCM56218_A0_PER_PORT_AGE_CONTROLr_EXCL_STATICf_GET
#define PER_PORT_AGE_CONTROLr_EXCL_STATICf_SET BCM56218_A0_PER_PORT_AGE_CONTROLr_EXCL_STATICf_SET
#define PER_PORT_AGE_CONTROLr_STARTf_GET BCM56218_A0_PER_PORT_AGE_CONTROLr_STARTf_GET
#define PER_PORT_AGE_CONTROLr_STARTf_SET BCM56218_A0_PER_PORT_AGE_CONTROLr_STARTf_SET
#define PER_PORT_AGE_CONTROLr_COMPLETEf_GET BCM56218_A0_PER_PORT_AGE_CONTROLr_COMPLETEf_GET
#define PER_PORT_AGE_CONTROLr_COMPLETEf_SET BCM56218_A0_PER_PORT_AGE_CONTROLr_COMPLETEf_SET
#define READ_PER_PORT_AGE_CONTROLr BCM56218_A0_READ_PER_PORT_AGE_CONTROLr
#define WRITE_PER_PORT_AGE_CONTROLr BCM56218_A0_WRITE_PER_PORT_AGE_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_PER_PORT_AGE_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  PER_PORT_REPL_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     Per-Port-Aging Replacement Register
 * SIZE:     32
 * FIELDS:
 *     PORT_TGID        Port_TGID value to be used in replacment.
 *     MODULE_ID        Module_Id value to be used in replacement.
 *
 ******************************************************************************/
#define BCM56218_A0_PER_PORT_REPL_CONTROLr 0x06780000

#define BCM56218_A0_PER_PORT_REPL_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program PER_PORT_REPL_CONTROL.
 *
 */
typedef union BCM56218_A0_PER_PORT_REPL_CONTROLr_s {
	uint32_t v[1];
	uint32_t per_port_repl_control[1];
	uint32_t _per_port_repl_control;
} BCM56218_A0_PER_PORT_REPL_CONTROLr_t;

#define BCM56218_A0_PER_PORT_REPL_CONTROLr_CLR(r) (r).per_port_repl_control[0] = 0
#define BCM56218_A0_PER_PORT_REPL_CONTROLr_SET(r,d) (r).per_port_repl_control[0] = d
#define BCM56218_A0_PER_PORT_REPL_CONTROLr_GET(r) (r).per_port_repl_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_PER_PORT_REPL_CONTROLr_PORT_TGIDf_GET(r) (((r).per_port_repl_control[0]) & 0x7f)
#define BCM56218_A0_PER_PORT_REPL_CONTROLr_PORT_TGIDf_SET(r,f) (r).per_port_repl_control[0]=(((r).per_port_repl_control[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f))
#define BCM56218_A0_PER_PORT_REPL_CONTROLr_MODULE_IDf_GET(r) ((((r).per_port_repl_control[0]) >> 7) & 0xf)
#define BCM56218_A0_PER_PORT_REPL_CONTROLr_MODULE_IDf_SET(r,f) (r).per_port_repl_control[0]=(((r).per_port_repl_control[0] & ~((uint32_t)0xf << 7)) | ((((uint32_t)f) & 0xf) << 7))

/*
 * These macros can be used to access PER_PORT_REPL_CONTROL.
 *
 */
#define BCM56218_A0_READ_PER_PORT_REPL_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_PER_PORT_REPL_CONTROLr,(r._per_port_repl_control))
#define BCM56218_A0_WRITE_PER_PORT_REPL_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_PER_PORT_REPL_CONTROLr,&(r._per_port_repl_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PER_PORT_REPL_CONTROLr BCM56218_A0_PER_PORT_REPL_CONTROLr
#define PER_PORT_REPL_CONTROLr_SIZE BCM56218_A0_PER_PORT_REPL_CONTROLr_SIZE
typedef BCM56218_A0_PER_PORT_REPL_CONTROLr_t PER_PORT_REPL_CONTROLr_t;
#define PER_PORT_REPL_CONTROLr_CLR BCM56218_A0_PER_PORT_REPL_CONTROLr_CLR
#define PER_PORT_REPL_CONTROLr_SET BCM56218_A0_PER_PORT_REPL_CONTROLr_SET
#define PER_PORT_REPL_CONTROLr_GET BCM56218_A0_PER_PORT_REPL_CONTROLr_GET
#define PER_PORT_REPL_CONTROLr_PORT_TGIDf_GET BCM56218_A0_PER_PORT_REPL_CONTROLr_PORT_TGIDf_GET
#define PER_PORT_REPL_CONTROLr_PORT_TGIDf_SET BCM56218_A0_PER_PORT_REPL_CONTROLr_PORT_TGIDf_SET
#define PER_PORT_REPL_CONTROLr_MODULE_IDf_GET BCM56218_A0_PER_PORT_REPL_CONTROLr_MODULE_IDf_GET
#define PER_PORT_REPL_CONTROLr_MODULE_IDf_SET BCM56218_A0_PER_PORT_REPL_CONTROLr_MODULE_IDf_SET
#define READ_PER_PORT_REPL_CONTROLr BCM56218_A0_READ_PER_PORT_REPL_CONTROLr
#define WRITE_PER_PORT_REPL_CONTROLr BCM56218_A0_WRITE_PER_PORT_REPL_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_PER_PORT_REPL_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  PKTAGINGLIMIT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     AGINGLIMITCOS0   Package aging timer limit for cos 0.Valid number from 0 to 5 to select durations stay in switch. Do not set value to 6 or 7 this may cause packet early aging. 
 *     AGINGLIMITCOS1   Package aging timer limit for cos 1.Valid number from 0 to 5 to select durations stay in switch. Do not set value to 6 or 7 this may cause packet early aging. 
 *     AGINGLIMITCOS2   Package aging timer limit for cos 2.Valid number from 0 to 5 to select durations stay in switch. Do not set value to 6 or 7 this may cause packet early aging. 
 *     AGINGLIMITCOS3   Package aging timer limit for cos 3.Valid number from 0 to 5 to select durations stay in switch. Do not set value to 6 or 7 this may cause packet early aging. 
 *     AGINGLIMITCOS4   Package aging timer limit for cos 4.Valid number from 0 to 5 to select durations stay in switch. Do not set value to 6 or 7 this may cause packet early aging. 
 *     AGINGLIMITCOS5   Package aging timer limit for cos 5.Valid number from 0 to 5 to select durations stay in switch. Do not set value to 6 or 7 this may cause packet early aging. 
 *     AGINGLIMITCOS6   Package aging timer limit for cos 6.Valid number from 0 to 5 to select durations stay in switch. Do not set value to 6 or 7 this may cause packet early aging. 
 *     AGINGLIMITCOS7   Package aging timer limit for cos 7.Valid number from 0 to 5 to select durations stay in switch. Do not set value to 6 or 7 this may cause packet early aging. 
 *
 ******************************************************************************/
#define BCM56218_A0_PKTAGINGLIMITr 0x0068001e

#define BCM56218_A0_PKTAGINGLIMITr_SIZE 4

/*
 * This structure should be used to declare and program PKTAGINGLIMIT.
 *
 */
typedef union BCM56218_A0_PKTAGINGLIMITr_s {
	uint32_t v[1];
	uint32_t pktaginglimit[1];
	uint32_t _pktaginglimit;
} BCM56218_A0_PKTAGINGLIMITr_t;

#define BCM56218_A0_PKTAGINGLIMITr_CLR(r) (r).pktaginglimit[0] = 0
#define BCM56218_A0_PKTAGINGLIMITr_SET(r,d) (r).pktaginglimit[0] = d
#define BCM56218_A0_PKTAGINGLIMITr_GET(r) (r).pktaginglimit[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_PKTAGINGLIMITr_AGINGLIMITCOS0f_GET(r) (((r).pktaginglimit[0]) & 0x7)
#define BCM56218_A0_PKTAGINGLIMITr_AGINGLIMITCOS0f_SET(r,f) (r).pktaginglimit[0]=(((r).pktaginglimit[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM56218_A0_PKTAGINGLIMITr_AGINGLIMITCOS1f_GET(r) ((((r).pktaginglimit[0]) >> 3) & 0x7)
#define BCM56218_A0_PKTAGINGLIMITr_AGINGLIMITCOS1f_SET(r,f) (r).pktaginglimit[0]=(((r).pktaginglimit[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM56218_A0_PKTAGINGLIMITr_AGINGLIMITCOS2f_GET(r) ((((r).pktaginglimit[0]) >> 6) & 0x7)
#define BCM56218_A0_PKTAGINGLIMITr_AGINGLIMITCOS2f_SET(r,f) (r).pktaginglimit[0]=(((r).pktaginglimit[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM56218_A0_PKTAGINGLIMITr_AGINGLIMITCOS3f_GET(r) ((((r).pktaginglimit[0]) >> 9) & 0x7)
#define BCM56218_A0_PKTAGINGLIMITr_AGINGLIMITCOS3f_SET(r,f) (r).pktaginglimit[0]=(((r).pktaginglimit[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM56218_A0_PKTAGINGLIMITr_AGINGLIMITCOS4f_GET(r) ((((r).pktaginglimit[0]) >> 12) & 0x7)
#define BCM56218_A0_PKTAGINGLIMITr_AGINGLIMITCOS4f_SET(r,f) (r).pktaginglimit[0]=(((r).pktaginglimit[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM56218_A0_PKTAGINGLIMITr_AGINGLIMITCOS5f_GET(r) ((((r).pktaginglimit[0]) >> 15) & 0x7)
#define BCM56218_A0_PKTAGINGLIMITr_AGINGLIMITCOS5f_SET(r,f) (r).pktaginglimit[0]=(((r).pktaginglimit[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM56218_A0_PKTAGINGLIMITr_AGINGLIMITCOS6f_GET(r) ((((r).pktaginglimit[0]) >> 18) & 0x7)
#define BCM56218_A0_PKTAGINGLIMITr_AGINGLIMITCOS6f_SET(r,f) (r).pktaginglimit[0]=(((r).pktaginglimit[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM56218_A0_PKTAGINGLIMITr_AGINGLIMITCOS7f_GET(r) ((((r).pktaginglimit[0]) >> 21) & 0x7)
#define BCM56218_A0_PKTAGINGLIMITr_AGINGLIMITCOS7f_SET(r,f) (r).pktaginglimit[0]=(((r).pktaginglimit[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))

/*
 * These macros can be used to access PKTAGINGLIMIT.
 *
 */
#define BCM56218_A0_READ_PKTAGINGLIMITr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_PKTAGINGLIMITr,(r._pktaginglimit))
#define BCM56218_A0_WRITE_PKTAGINGLIMITr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_PKTAGINGLIMITr,&(r._pktaginglimit))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTAGINGLIMITr BCM56218_A0_PKTAGINGLIMITr
#define PKTAGINGLIMITr_SIZE BCM56218_A0_PKTAGINGLIMITr_SIZE
typedef BCM56218_A0_PKTAGINGLIMITr_t PKTAGINGLIMITr_t;
#define PKTAGINGLIMITr_CLR BCM56218_A0_PKTAGINGLIMITr_CLR
#define PKTAGINGLIMITr_SET BCM56218_A0_PKTAGINGLIMITr_SET
#define PKTAGINGLIMITr_GET BCM56218_A0_PKTAGINGLIMITr_GET
#define PKTAGINGLIMITr_AGINGLIMITCOS0f_GET BCM56218_A0_PKTAGINGLIMITr_AGINGLIMITCOS0f_GET
#define PKTAGINGLIMITr_AGINGLIMITCOS0f_SET BCM56218_A0_PKTAGINGLIMITr_AGINGLIMITCOS0f_SET
#define PKTAGINGLIMITr_AGINGLIMITCOS1f_GET BCM56218_A0_PKTAGINGLIMITr_AGINGLIMITCOS1f_GET
#define PKTAGINGLIMITr_AGINGLIMITCOS1f_SET BCM56218_A0_PKTAGINGLIMITr_AGINGLIMITCOS1f_SET
#define PKTAGINGLIMITr_AGINGLIMITCOS2f_GET BCM56218_A0_PKTAGINGLIMITr_AGINGLIMITCOS2f_GET
#define PKTAGINGLIMITr_AGINGLIMITCOS2f_SET BCM56218_A0_PKTAGINGLIMITr_AGINGLIMITCOS2f_SET
#define PKTAGINGLIMITr_AGINGLIMITCOS3f_GET BCM56218_A0_PKTAGINGLIMITr_AGINGLIMITCOS3f_GET
#define PKTAGINGLIMITr_AGINGLIMITCOS3f_SET BCM56218_A0_PKTAGINGLIMITr_AGINGLIMITCOS3f_SET
#define PKTAGINGLIMITr_AGINGLIMITCOS4f_GET BCM56218_A0_PKTAGINGLIMITr_AGINGLIMITCOS4f_GET
#define PKTAGINGLIMITr_AGINGLIMITCOS4f_SET BCM56218_A0_PKTAGINGLIMITr_AGINGLIMITCOS4f_SET
#define PKTAGINGLIMITr_AGINGLIMITCOS5f_GET BCM56218_A0_PKTAGINGLIMITr_AGINGLIMITCOS5f_GET
#define PKTAGINGLIMITr_AGINGLIMITCOS5f_SET BCM56218_A0_PKTAGINGLIMITr_AGINGLIMITCOS5f_SET
#define PKTAGINGLIMITr_AGINGLIMITCOS6f_GET BCM56218_A0_PKTAGINGLIMITr_AGINGLIMITCOS6f_GET
#define PKTAGINGLIMITr_AGINGLIMITCOS6f_SET BCM56218_A0_PKTAGINGLIMITr_AGINGLIMITCOS6f_SET
#define PKTAGINGLIMITr_AGINGLIMITCOS7f_GET BCM56218_A0_PKTAGINGLIMITr_AGINGLIMITCOS7f_GET
#define PKTAGINGLIMITr_AGINGLIMITCOS7f_SET BCM56218_A0_PKTAGINGLIMITr_AGINGLIMITCOS7f_SET
#define READ_PKTAGINGLIMITr BCM56218_A0_READ_PKTAGINGLIMITr
#define WRITE_PKTAGINGLIMITr BCM56218_A0_WRITE_PKTAGINGLIMITr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_PKTAGINGLIMITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  PKTAGINGTIMER
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     DURATIONSELECT   13 bits aging interval duration select registers. Duration select determines the interval at which the age timergets incremented. After DURATIONSELECT number of clock timer ticks (pulses) the age timer will be incremented by 1.Packet aging function is disabled when set this register to 0.Packet aging function is disabled by default after power-on reset.
 *     AGINGTICKSEL     Select Aging tick clock source.0: 125us clock pulse.1: 500ms clock pulse
 *
 ******************************************************************************/
#define BCM56218_A0_PKTAGINGTIMERr 0x0068001d

#define BCM56218_A0_PKTAGINGTIMERr_SIZE 4

/*
 * This structure should be used to declare and program PKTAGINGTIMER.
 *
 */
typedef union BCM56218_A0_PKTAGINGTIMERr_s {
	uint32_t v[1];
	uint32_t pktagingtimer[1];
	uint32_t _pktagingtimer;
} BCM56218_A0_PKTAGINGTIMERr_t;

#define BCM56218_A0_PKTAGINGTIMERr_CLR(r) (r).pktagingtimer[0] = 0
#define BCM56218_A0_PKTAGINGTIMERr_SET(r,d) (r).pktagingtimer[0] = d
#define BCM56218_A0_PKTAGINGTIMERr_GET(r) (r).pktagingtimer[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_PKTAGINGTIMERr_DURATIONSELECTf_GET(r) (((r).pktagingtimer[0]) & 0x1fff)
#define BCM56218_A0_PKTAGINGTIMERr_DURATIONSELECTf_SET(r,f) (r).pktagingtimer[0]=(((r).pktagingtimer[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))
#define BCM56218_A0_PKTAGINGTIMERr_AGINGTICKSELf_GET(r) ((((r).pktagingtimer[0]) >> 13) & 0x1)
#define BCM56218_A0_PKTAGINGTIMERr_AGINGTICKSELf_SET(r,f) (r).pktagingtimer[0]=(((r).pktagingtimer[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))

/*
 * These macros can be used to access PKTAGINGTIMER.
 *
 */
#define BCM56218_A0_READ_PKTAGINGTIMERr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_PKTAGINGTIMERr,(r._pktagingtimer))
#define BCM56218_A0_WRITE_PKTAGINGTIMERr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_PKTAGINGTIMERr,&(r._pktagingtimer))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTAGINGTIMERr BCM56218_A0_PKTAGINGTIMERr
#define PKTAGINGTIMERr_SIZE BCM56218_A0_PKTAGINGTIMERr_SIZE
typedef BCM56218_A0_PKTAGINGTIMERr_t PKTAGINGTIMERr_t;
#define PKTAGINGTIMERr_CLR BCM56218_A0_PKTAGINGTIMERr_CLR
#define PKTAGINGTIMERr_SET BCM56218_A0_PKTAGINGTIMERr_SET
#define PKTAGINGTIMERr_GET BCM56218_A0_PKTAGINGTIMERr_GET
#define PKTAGINGTIMERr_DURATIONSELECTf_GET BCM56218_A0_PKTAGINGTIMERr_DURATIONSELECTf_GET
#define PKTAGINGTIMERr_DURATIONSELECTf_SET BCM56218_A0_PKTAGINGTIMERr_DURATIONSELECTf_SET
#define PKTAGINGTIMERr_AGINGTICKSELf_GET BCM56218_A0_PKTAGINGTIMERr_AGINGTICKSELf_GET
#define PKTAGINGTIMERr_AGINGTICKSELf_SET BCM56218_A0_PKTAGINGTIMERr_AGINGTICKSELf_SET
#define READ_PKTAGINGTIMERr BCM56218_A0_READ_PKTAGINGTIMERr
#define WRITE_PKTAGINGTIMERr BCM56218_A0_WRITE_PKTAGINGTIMERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_PKTAGINGTIMERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  PORT_BRIDGE_BMAP
 * BLOCKS:   IPIPE
 * DESC:     Bitmap of ports with port_bridge enabled
 * SIZE:     32
 * FIELDS:
 *     BITMAP           Bitmap of all XGE ports with port_bridge enabled. DO NOT include HiGig ports
 *
 ******************************************************************************/
#define BCM56218_A0_PORT_BRIDGE_BMAPr 0x0e78012b

#define BCM56218_A0_PORT_BRIDGE_BMAPr_SIZE 4

/*
 * This structure should be used to declare and program PORT_BRIDGE_BMAP.
 *
 */
typedef union BCM56218_A0_PORT_BRIDGE_BMAPr_s {
	uint32_t v[1];
	uint32_t port_bridge_bmap[1];
	uint32_t _port_bridge_bmap;
} BCM56218_A0_PORT_BRIDGE_BMAPr_t;

#define BCM56218_A0_PORT_BRIDGE_BMAPr_CLR(r) (r).port_bridge_bmap[0] = 0
#define BCM56218_A0_PORT_BRIDGE_BMAPr_SET(r,d) (r).port_bridge_bmap[0] = d
#define BCM56218_A0_PORT_BRIDGE_BMAPr_GET(r) (r).port_bridge_bmap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_PORT_BRIDGE_BMAPr_BITMAPf_GET(r) ((r).port_bridge_bmap[0])
#define BCM56218_A0_PORT_BRIDGE_BMAPr_BITMAPf_SET(r,f) (r).port_bridge_bmap[0]=((uint32_t)f)

/*
 * These macros can be used to access PORT_BRIDGE_BMAP.
 *
 */
#define BCM56218_A0_READ_PORT_BRIDGE_BMAPr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_PORT_BRIDGE_BMAPr,(r._port_bridge_bmap))
#define BCM56218_A0_WRITE_PORT_BRIDGE_BMAPr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_PORT_BRIDGE_BMAPr,&(r._port_bridge_bmap))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_BRIDGE_BMAPr BCM56218_A0_PORT_BRIDGE_BMAPr
#define PORT_BRIDGE_BMAPr_SIZE BCM56218_A0_PORT_BRIDGE_BMAPr_SIZE
typedef BCM56218_A0_PORT_BRIDGE_BMAPr_t PORT_BRIDGE_BMAPr_t;
#define PORT_BRIDGE_BMAPr_CLR BCM56218_A0_PORT_BRIDGE_BMAPr_CLR
#define PORT_BRIDGE_BMAPr_SET BCM56218_A0_PORT_BRIDGE_BMAPr_SET
#define PORT_BRIDGE_BMAPr_GET BCM56218_A0_PORT_BRIDGE_BMAPr_GET
#define PORT_BRIDGE_BMAPr_BITMAPf_GET BCM56218_A0_PORT_BRIDGE_BMAPr_BITMAPf_GET
#define PORT_BRIDGE_BMAPr_BITMAPf_SET BCM56218_A0_PORT_BRIDGE_BMAPr_BITMAPf_SET
#define READ_PORT_BRIDGE_BMAPr BCM56218_A0_READ_PORT_BRIDGE_BMAPr
#define WRITE_PORT_BRIDGE_BMAPr BCM56218_A0_WRITE_PORT_BRIDGE_BMAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_PORT_BRIDGE_BMAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  PORT_BRIDGE_BMAP_HI
 * BLOCKS:   IPIPE
 * DESC:     UPPER Bitmap of ports with port_bridge enabled
 * SIZE:     32
 * FIELDS:
 *     BITMAP           Bitmap of all XGE ports with port_bridge enabled. DO NOT include HiGig ports
 *
 ******************************************************************************/
#define BCM56218_A0_PORT_BRIDGE_BMAP_HIr 0x0e78012c

#define BCM56218_A0_PORT_BRIDGE_BMAP_HIr_SIZE 4

/*
 * This structure should be used to declare and program PORT_BRIDGE_BMAP_HI.
 *
 */
typedef union BCM56218_A0_PORT_BRIDGE_BMAP_HIr_s {
	uint32_t v[1];
	uint32_t port_bridge_bmap_hi[1];
	uint32_t _port_bridge_bmap_hi;
} BCM56218_A0_PORT_BRIDGE_BMAP_HIr_t;

#define BCM56218_A0_PORT_BRIDGE_BMAP_HIr_CLR(r) (r).port_bridge_bmap_hi[0] = 0
#define BCM56218_A0_PORT_BRIDGE_BMAP_HIr_SET(r,d) (r).port_bridge_bmap_hi[0] = d
#define BCM56218_A0_PORT_BRIDGE_BMAP_HIr_GET(r) (r).port_bridge_bmap_hi[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_PORT_BRIDGE_BMAP_HIr_BITMAPf_GET(r) (((r).port_bridge_bmap_hi[0]) & 0x3fffff)
#define BCM56218_A0_PORT_BRIDGE_BMAP_HIr_BITMAPf_SET(r,f) (r).port_bridge_bmap_hi[0]=(((r).port_bridge_bmap_hi[0] & ~((uint32_t)0x3fffff)) | (((uint32_t)f) & 0x3fffff))

/*
 * These macros can be used to access PORT_BRIDGE_BMAP_HI.
 *
 */
#define BCM56218_A0_READ_PORT_BRIDGE_BMAP_HIr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_PORT_BRIDGE_BMAP_HIr,(r._port_bridge_bmap_hi))
#define BCM56218_A0_WRITE_PORT_BRIDGE_BMAP_HIr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_PORT_BRIDGE_BMAP_HIr,&(r._port_bridge_bmap_hi))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_BRIDGE_BMAP_HIr BCM56218_A0_PORT_BRIDGE_BMAP_HIr
#define PORT_BRIDGE_BMAP_HIr_SIZE BCM56218_A0_PORT_BRIDGE_BMAP_HIr_SIZE
typedef BCM56218_A0_PORT_BRIDGE_BMAP_HIr_t PORT_BRIDGE_BMAP_HIr_t;
#define PORT_BRIDGE_BMAP_HIr_CLR BCM56218_A0_PORT_BRIDGE_BMAP_HIr_CLR
#define PORT_BRIDGE_BMAP_HIr_SET BCM56218_A0_PORT_BRIDGE_BMAP_HIr_SET
#define PORT_BRIDGE_BMAP_HIr_GET BCM56218_A0_PORT_BRIDGE_BMAP_HIr_GET
#define PORT_BRIDGE_BMAP_HIr_BITMAPf_GET BCM56218_A0_PORT_BRIDGE_BMAP_HIr_BITMAPf_GET
#define PORT_BRIDGE_BMAP_HIr_BITMAPf_SET BCM56218_A0_PORT_BRIDGE_BMAP_HIr_BITMAPf_SET
#define READ_PORT_BRIDGE_BMAP_HIr BCM56218_A0_READ_PORT_BRIDGE_BMAP_HIr
#define WRITE_PORT_BRIDGE_BMAP_HIr BCM56218_A0_WRITE_PORT_BRIDGE_BMAP_HIr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_PORT_BRIDGE_BMAP_HIr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  PORT_OR_TRUNK_MAC_ACTION
 * BLOCKS:   IPIPE
 * DESC:     indexed with the indicies from MAC_LIMIT_TRUNK_MAP_TABLE or MAC_LIMIT_PORT_MAP_TABLE
 * SIZE:     2
 * FIELDS:
 *     OVER_LIMIT_TOCPU the copy to CPU action control bit used when the PORT_TRUNK_MAC_COUNT exceeds the PORT_TRUNK_MAC_LIMIT
 *     OVER_LIMIT_DROP  the drop action control bit used when the PORT_TRUNK_MAC_COUNT exceeds the PORT_TRUNK_MAC_LIMIT
 *
 ******************************************************************************/
#define BCM56218_A0_PORT_OR_TRUNK_MAC_ACTIONm 0x0b720000

#define BCM56218_A0_PORT_OR_TRUNK_MAC_ACTIONm_MIN 0
#define BCM56218_A0_PORT_OR_TRUNK_MAC_ACTIONm_MAX 53
#define BCM56218_A0_PORT_OR_TRUNK_MAC_ACTIONm_CMAX(u) 53
#define BCM56218_A0_PORT_OR_TRUNK_MAC_ACTIONm_SIZE 1

/*
 * This structure should be used to declare and program PORT_OR_TRUNK_MAC_ACTION.
 *
 */
typedef union BCM56218_A0_PORT_OR_TRUNK_MAC_ACTIONm_s {
	uint32_t v[1];
	uint32_t port_or_trunk_mac_action[1];
	uint32_t _port_or_trunk_mac_action;
} BCM56218_A0_PORT_OR_TRUNK_MAC_ACTIONm_t;

#define BCM56218_A0_PORT_OR_TRUNK_MAC_ACTIONm_CLR(r) (r).port_or_trunk_mac_action[0] = 0
#define BCM56218_A0_PORT_OR_TRUNK_MAC_ACTIONm_SET(r,d) (r).port_or_trunk_mac_action[0] = d
#define BCM56218_A0_PORT_OR_TRUNK_MAC_ACTIONm_GET(r) (r).port_or_trunk_mac_action[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_PORT_OR_TRUNK_MAC_ACTIONm_OVER_LIMIT_TOCPUf_GET(r) (((r).port_or_trunk_mac_action[0]) & 0x1)
#define BCM56218_A0_PORT_OR_TRUNK_MAC_ACTIONm_OVER_LIMIT_TOCPUf_SET(r,f) (r).port_or_trunk_mac_action[0]=(((r).port_or_trunk_mac_action[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_PORT_OR_TRUNK_MAC_ACTIONm_OVER_LIMIT_DROPf_GET(r) ((((r).port_or_trunk_mac_action[0]) >> 1) & 0x1)
#define BCM56218_A0_PORT_OR_TRUNK_MAC_ACTIONm_OVER_LIMIT_DROPf_SET(r,f) (r).port_or_trunk_mac_action[0]=(((r).port_or_trunk_mac_action[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access PORT_OR_TRUNK_MAC_ACTION.
 *
 */
#define BCM56218_A0_READ_PORT_OR_TRUNK_MAC_ACTIONm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_PORT_OR_TRUNK_MAC_ACTIONm,i,(m._port_or_trunk_mac_action),1)
#define BCM56218_A0_WRITE_PORT_OR_TRUNK_MAC_ACTIONm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_PORT_OR_TRUNK_MAC_ACTIONm,i,&(m._port_or_trunk_mac_action),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_OR_TRUNK_MAC_ACTIONm BCM56218_A0_PORT_OR_TRUNK_MAC_ACTIONm
#define PORT_OR_TRUNK_MAC_ACTIONm_MIN BCM56218_A0_PORT_OR_TRUNK_MAC_ACTIONm_MIN
#define PORT_OR_TRUNK_MAC_ACTIONm_MAX BCM56218_A0_PORT_OR_TRUNK_MAC_ACTIONm_MAX
#define PORT_OR_TRUNK_MAC_ACTIONm_CMAX(u) BCM56218_A0_PORT_OR_TRUNK_MAC_ACTIONm_CMAX(u)
#define PORT_OR_TRUNK_MAC_ACTIONm_SIZE BCM56218_A0_PORT_OR_TRUNK_MAC_ACTIONm_SIZE
typedef BCM56218_A0_PORT_OR_TRUNK_MAC_ACTIONm_t PORT_OR_TRUNK_MAC_ACTIONm_t;
#define PORT_OR_TRUNK_MAC_ACTIONm_CLR BCM56218_A0_PORT_OR_TRUNK_MAC_ACTIONm_CLR
#define PORT_OR_TRUNK_MAC_ACTIONm_SET BCM56218_A0_PORT_OR_TRUNK_MAC_ACTIONm_SET
#define PORT_OR_TRUNK_MAC_ACTIONm_GET BCM56218_A0_PORT_OR_TRUNK_MAC_ACTIONm_GET
#define PORT_OR_TRUNK_MAC_ACTIONm_OVER_LIMIT_TOCPUf_GET BCM56218_A0_PORT_OR_TRUNK_MAC_ACTIONm_OVER_LIMIT_TOCPUf_GET
#define PORT_OR_TRUNK_MAC_ACTIONm_OVER_LIMIT_TOCPUf_SET BCM56218_A0_PORT_OR_TRUNK_MAC_ACTIONm_OVER_LIMIT_TOCPUf_SET
#define PORT_OR_TRUNK_MAC_ACTIONm_OVER_LIMIT_DROPf_GET BCM56218_A0_PORT_OR_TRUNK_MAC_ACTIONm_OVER_LIMIT_DROPf_GET
#define PORT_OR_TRUNK_MAC_ACTIONm_OVER_LIMIT_DROPf_SET BCM56218_A0_PORT_OR_TRUNK_MAC_ACTIONm_OVER_LIMIT_DROPf_SET
#define READ_PORT_OR_TRUNK_MAC_ACTIONm BCM56218_A0_READ_PORT_OR_TRUNK_MAC_ACTIONm
#define WRITE_PORT_OR_TRUNK_MAC_ACTIONm BCM56218_A0_WRITE_PORT_OR_TRUNK_MAC_ACTIONm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_PORT_OR_TRUNK_MAC_ACTIONm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  PORT_OR_TRUNK_MAC_COUNT
 * BLOCKS:   IPIPE
 * DESC:     TABLE for per port /LAG MAC counts .
 * SIZE:     13
 * FIELDS:
 *     PORT_TRUNK_MAC_COUNT Table which has the per port/LAG MAC COUNTs that are updated by the H/W. Instead of having seperate counts/limits on per port and per LAG (TRUNK GROUP) basis, Raptor implements one set of 54 counts/limits. Each ingress port and TRUNK Group can be mapped to one of the 54 counts/limits using TRUNK/PORT mapping tables
 *
 ******************************************************************************/
#define BCM56218_A0_PORT_OR_TRUNK_MAC_COUNTm 0x067a0000

#define BCM56218_A0_PORT_OR_TRUNK_MAC_COUNTm_MIN 0
#define BCM56218_A0_PORT_OR_TRUNK_MAC_COUNTm_MAX 53
#define BCM56218_A0_PORT_OR_TRUNK_MAC_COUNTm_CMAX(u) 53
#define BCM56218_A0_PORT_OR_TRUNK_MAC_COUNTm_SIZE 2

/*
 * This structure should be used to declare and program PORT_OR_TRUNK_MAC_COUNT.
 *
 */
typedef union BCM56218_A0_PORT_OR_TRUNK_MAC_COUNTm_s {
	uint32_t v[1];
	uint32_t port_or_trunk_mac_count[1];
	uint32_t _port_or_trunk_mac_count;
} BCM56218_A0_PORT_OR_TRUNK_MAC_COUNTm_t;

#define BCM56218_A0_PORT_OR_TRUNK_MAC_COUNTm_CLR(r) (r).port_or_trunk_mac_count[0] = 0
#define BCM56218_A0_PORT_OR_TRUNK_MAC_COUNTm_SET(r,d) (r).port_or_trunk_mac_count[0] = d
#define BCM56218_A0_PORT_OR_TRUNK_MAC_COUNTm_GET(r) (r).port_or_trunk_mac_count[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_PORT_OR_TRUNK_MAC_COUNTm_PORT_TRUNK_MAC_COUNTf_GET(r) (((r).port_or_trunk_mac_count[0]) & 0x1fff)
#define BCM56218_A0_PORT_OR_TRUNK_MAC_COUNTm_PORT_TRUNK_MAC_COUNTf_SET(r,f) (r).port_or_trunk_mac_count[0]=(((r).port_or_trunk_mac_count[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))

/*
 * These macros can be used to access PORT_OR_TRUNK_MAC_COUNT.
 *
 */
#define BCM56218_A0_READ_PORT_OR_TRUNK_MAC_COUNTm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_PORT_OR_TRUNK_MAC_COUNTm,i,(m._port_or_trunk_mac_count),1)
#define BCM56218_A0_WRITE_PORT_OR_TRUNK_MAC_COUNTm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_PORT_OR_TRUNK_MAC_COUNTm,i,&(m._port_or_trunk_mac_count),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_OR_TRUNK_MAC_COUNTm BCM56218_A0_PORT_OR_TRUNK_MAC_COUNTm
#define PORT_OR_TRUNK_MAC_COUNTm_MIN BCM56218_A0_PORT_OR_TRUNK_MAC_COUNTm_MIN
#define PORT_OR_TRUNK_MAC_COUNTm_MAX BCM56218_A0_PORT_OR_TRUNK_MAC_COUNTm_MAX
#define PORT_OR_TRUNK_MAC_COUNTm_CMAX(u) BCM56218_A0_PORT_OR_TRUNK_MAC_COUNTm_CMAX(u)
#define PORT_OR_TRUNK_MAC_COUNTm_SIZE BCM56218_A0_PORT_OR_TRUNK_MAC_COUNTm_SIZE
typedef BCM56218_A0_PORT_OR_TRUNK_MAC_COUNTm_t PORT_OR_TRUNK_MAC_COUNTm_t;
#define PORT_OR_TRUNK_MAC_COUNTm_CLR BCM56218_A0_PORT_OR_TRUNK_MAC_COUNTm_CLR
#define PORT_OR_TRUNK_MAC_COUNTm_SET BCM56218_A0_PORT_OR_TRUNK_MAC_COUNTm_SET
#define PORT_OR_TRUNK_MAC_COUNTm_GET BCM56218_A0_PORT_OR_TRUNK_MAC_COUNTm_GET
#define PORT_OR_TRUNK_MAC_COUNTm_PORT_TRUNK_MAC_COUNTf_GET BCM56218_A0_PORT_OR_TRUNK_MAC_COUNTm_PORT_TRUNK_MAC_COUNTf_GET
#define PORT_OR_TRUNK_MAC_COUNTm_PORT_TRUNK_MAC_COUNTf_SET BCM56218_A0_PORT_OR_TRUNK_MAC_COUNTm_PORT_TRUNK_MAC_COUNTf_SET
#define READ_PORT_OR_TRUNK_MAC_COUNTm BCM56218_A0_READ_PORT_OR_TRUNK_MAC_COUNTm
#define WRITE_PORT_OR_TRUNK_MAC_COUNTm BCM56218_A0_WRITE_PORT_OR_TRUNK_MAC_COUNTm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_PORT_OR_TRUNK_MAC_COUNTm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  PORT_OR_TRUNK_MAC_LIMIT
 * BLOCKS:   IPIPE
 * DESC:     the system MAC count limit value
 * SIZE:     14
 * FIELDS:
 *     PORT_TRUNK_MAC_LIMIT The system MAC count limit value that needs to be programmed by the user
 *
 ******************************************************************************/
#define BCM56218_A0_PORT_OR_TRUNK_MAC_LIMITm 0x067b0000

#define BCM56218_A0_PORT_OR_TRUNK_MAC_LIMITm_MIN 0
#define BCM56218_A0_PORT_OR_TRUNK_MAC_LIMITm_MAX 53
#define BCM56218_A0_PORT_OR_TRUNK_MAC_LIMITm_CMAX(u) 53
#define BCM56218_A0_PORT_OR_TRUNK_MAC_LIMITm_SIZE 2

/*
 * This structure should be used to declare and program PORT_OR_TRUNK_MAC_LIMIT.
 *
 */
typedef union BCM56218_A0_PORT_OR_TRUNK_MAC_LIMITm_s {
	uint32_t v[1];
	uint32_t port_or_trunk_mac_limit[1];
	uint32_t _port_or_trunk_mac_limit;
} BCM56218_A0_PORT_OR_TRUNK_MAC_LIMITm_t;

#define BCM56218_A0_PORT_OR_TRUNK_MAC_LIMITm_CLR(r) (r).port_or_trunk_mac_limit[0] = 0
#define BCM56218_A0_PORT_OR_TRUNK_MAC_LIMITm_SET(r,d) (r).port_or_trunk_mac_limit[0] = d
#define BCM56218_A0_PORT_OR_TRUNK_MAC_LIMITm_GET(r) (r).port_or_trunk_mac_limit[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_PORT_OR_TRUNK_MAC_LIMITm_PORT_TRUNK_MAC_LIMITf_GET(r) (((r).port_or_trunk_mac_limit[0]) & 0x3fff)
#define BCM56218_A0_PORT_OR_TRUNK_MAC_LIMITm_PORT_TRUNK_MAC_LIMITf_SET(r,f) (r).port_or_trunk_mac_limit[0]=(((r).port_or_trunk_mac_limit[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access PORT_OR_TRUNK_MAC_LIMIT.
 *
 */
#define BCM56218_A0_READ_PORT_OR_TRUNK_MAC_LIMITm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_PORT_OR_TRUNK_MAC_LIMITm,i,(m._port_or_trunk_mac_limit),1)
#define BCM56218_A0_WRITE_PORT_OR_TRUNK_MAC_LIMITm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_PORT_OR_TRUNK_MAC_LIMITm,i,&(m._port_or_trunk_mac_limit),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_OR_TRUNK_MAC_LIMITm BCM56218_A0_PORT_OR_TRUNK_MAC_LIMITm
#define PORT_OR_TRUNK_MAC_LIMITm_MIN BCM56218_A0_PORT_OR_TRUNK_MAC_LIMITm_MIN
#define PORT_OR_TRUNK_MAC_LIMITm_MAX BCM56218_A0_PORT_OR_TRUNK_MAC_LIMITm_MAX
#define PORT_OR_TRUNK_MAC_LIMITm_CMAX(u) BCM56218_A0_PORT_OR_TRUNK_MAC_LIMITm_CMAX(u)
#define PORT_OR_TRUNK_MAC_LIMITm_SIZE BCM56218_A0_PORT_OR_TRUNK_MAC_LIMITm_SIZE
typedef BCM56218_A0_PORT_OR_TRUNK_MAC_LIMITm_t PORT_OR_TRUNK_MAC_LIMITm_t;
#define PORT_OR_TRUNK_MAC_LIMITm_CLR BCM56218_A0_PORT_OR_TRUNK_MAC_LIMITm_CLR
#define PORT_OR_TRUNK_MAC_LIMITm_SET BCM56218_A0_PORT_OR_TRUNK_MAC_LIMITm_SET
#define PORT_OR_TRUNK_MAC_LIMITm_GET BCM56218_A0_PORT_OR_TRUNK_MAC_LIMITm_GET
#define PORT_OR_TRUNK_MAC_LIMITm_PORT_TRUNK_MAC_LIMITf_GET BCM56218_A0_PORT_OR_TRUNK_MAC_LIMITm_PORT_TRUNK_MAC_LIMITf_GET
#define PORT_OR_TRUNK_MAC_LIMITm_PORT_TRUNK_MAC_LIMITf_SET BCM56218_A0_PORT_OR_TRUNK_MAC_LIMITm_PORT_TRUNK_MAC_LIMITf_SET
#define READ_PORT_OR_TRUNK_MAC_LIMITm BCM56218_A0_READ_PORT_OR_TRUNK_MAC_LIMITm
#define WRITE_PORT_OR_TRUNK_MAC_LIMITm BCM56218_A0_WRITE_PORT_OR_TRUNK_MAC_LIMITm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_PORT_OR_TRUNK_MAC_LIMITm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  PORT_TAB
 * BLOCKS:   IPIPE
 * DESC:     Port Table
 * SIZE:     66
 * FIELDS:
 *     FILTER_ENABLE    Enable Filtering
 *     RESERVED0        RESERVED bit 
 *     RESERVED1        RESERVED bit
 *     TRUST_DSCP_V4    Ingress port is trusted port, trust incoming IPv4 DSCP
 *     TRUST_DSCP_V6    Ingress port is trusted port, trust incoming IPv6 DSCP
 *     EN_IFILTER       Enable ingress filtering
 *     MIRROR           Mirror enable
 *     CML              CPU managed learning
 *     PORT_PRI         Port default priority
 *     RESERVED2        RESERVED bit
 *     RESERVED3        RESERVED bit 
 *     RESERVED4        RESERVED bit 
 *     V6L3_ENABLE      IPv6 L3 enable
 *     V4L3_ENABLE      IPv4 L3 enable
 *     DROP_BPDU        when set, ingress drops BPDUs
 *     PORT_DIS_TAG     Drop all tagged packets
 *     PORT_DIS_UNTAG   Drop all untagged packets
 *     PASS_CONTROL_FRAMES Pass pause frames through without dropping
 *     SUBNET_BASED_VID_ENABLE Enable subnet-based VLANs
 *     MAC_BASED_VID_ENABLE Enable MAC-based VLANs
 *     PORT_VID         Port VLAN
 *     HIGIG_PACKET     Port is HiGig port
 *     NNI_PORT         Port is NNI port if set to 1, otherwise UNI port
 *     MAP_TAG_PKT_PRIORITY Map the incoming packet priority
 *     MY_MODID         Stacking module ID for this module
 *     OUTER_TPID       Outer (switching) VLAN
 *     VLAN_PRECEDENCE  Determine the priorities for selecting VLAN (MAC-based, subnet-based VLANs)
 *     PORT_BRIDGE      Allows L2 bridging to the incoming port
 *     MODPORT_TABLE_SEL To Select results from multiple modport tables
 *     IGNORE_MODID_LKUPS To ignore the look up results from the module id based tables. This is used for passthru pkts with modid greater than 16.
 *     REMOVE_HG_HDR_SRC_PORT If set to 1, do not forward the pkt to the non-trunk (i.e., not LAG) source port in module header when the MH.SRC_MODID is same as ING_CONFIG.MY_MODID. NOTE: If module header's source port is a trunk (LAG) port, the pkts are not forwarded to its LAG members irrespective of this control bit
 *     ALLOW_SRC_MOD    When set, packets whose source modid is equal to my_modid are not dropped
 *
 ******************************************************************************/
#define BCM56218_A0_PORT_TABm 0x01700000

#define BCM56218_A0_PORT_TABm_MIN 0
#define BCM56218_A0_PORT_TABm_MAX 53
#define BCM56218_A0_PORT_TABm_CMAX(u) 53
#define BCM56218_A0_PORT_TABm_SIZE 9

/*
 * This structure should be used to declare and program PORT_TAB.
 *
 */
typedef union BCM56218_A0_PORT_TABm_s {
	uint32_t v[3];
	uint32_t port_tab[3];
	uint32_t _port_tab;
} BCM56218_A0_PORT_TABm_t;

#define BCM56218_A0_PORT_TABm_CLR(r) CDK_MEMSET(&((r)._port_tab), 0, sizeof(BCM56218_A0_PORT_TABm_t))
#define BCM56218_A0_PORT_TABm_SET(r,i,d) (r).port_tab[i] = d
#define BCM56218_A0_PORT_TABm_GET(r,i) (r).port_tab[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_PORT_TABm_FILTER_ENABLEf_GET(r) (((r).port_tab[0]) & 0x1)
#define BCM56218_A0_PORT_TABm_FILTER_ENABLEf_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_PORT_TABm_RESERVED0f_GET(r) ((((r).port_tab[0]) >> 1) & 0x1)
#define BCM56218_A0_PORT_TABm_RESERVED0f_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_PORT_TABm_RESERVED1f_GET(r) ((((r).port_tab[0]) >> 2) & 0x1)
#define BCM56218_A0_PORT_TABm_RESERVED1f_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_PORT_TABm_TRUST_DSCP_V4f_GET(r) ((((r).port_tab[0]) >> 3) & 0x1)
#define BCM56218_A0_PORT_TABm_TRUST_DSCP_V4f_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56218_A0_PORT_TABm_TRUST_DSCP_V6f_GET(r) ((((r).port_tab[0]) >> 4) & 0x1)
#define BCM56218_A0_PORT_TABm_TRUST_DSCP_V6f_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56218_A0_PORT_TABm_EN_IFILTERf_GET(r) ((((r).port_tab[0]) >> 5) & 0x1)
#define BCM56218_A0_PORT_TABm_EN_IFILTERf_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56218_A0_PORT_TABm_MIRRORf_GET(r) ((((r).port_tab[0]) >> 6) & 0x1)
#define BCM56218_A0_PORT_TABm_MIRRORf_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56218_A0_PORT_TABm_CMLf_GET(r) ((((r).port_tab[0]) >> 7) & 0x7)
#define BCM56218_A0_PORT_TABm_CMLf_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x7 << 7)) | ((((uint32_t)f) & 0x7) << 7))
#define BCM56218_A0_PORT_TABm_PORT_PRIf_GET(r) ((((r).port_tab[0]) >> 10) & 0x7)
#define BCM56218_A0_PORT_TABm_PORT_PRIf_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10))
#define BCM56218_A0_PORT_TABm_RESERVED2f_GET(r) ((((r).port_tab[0]) >> 13) & 0x1)
#define BCM56218_A0_PORT_TABm_RESERVED2f_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56218_A0_PORT_TABm_RESERVED3f_GET(r) ((((r).port_tab[0]) >> 14) & 0x1)
#define BCM56218_A0_PORT_TABm_RESERVED3f_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM56218_A0_PORT_TABm_RESERVED4f_GET(r) ((((r).port_tab[0]) >> 15) & 0x1)
#define BCM56218_A0_PORT_TABm_RESERVED4f_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56218_A0_PORT_TABm_V6L3_ENABLEf_GET(r) ((((r).port_tab[0]) >> 16) & 0x1)
#define BCM56218_A0_PORT_TABm_V6L3_ENABLEf_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56218_A0_PORT_TABm_V4L3_ENABLEf_GET(r) ((((r).port_tab[0]) >> 17) & 0x1)
#define BCM56218_A0_PORT_TABm_V4L3_ENABLEf_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_PORT_TABm_DROP_BPDUf_GET(r) ((((r).port_tab[0]) >> 18) & 0x1)
#define BCM56218_A0_PORT_TABm_DROP_BPDUf_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_PORT_TABm_PORT_DIS_TAGf_GET(r) ((((r).port_tab[0]) >> 19) & 0x1)
#define BCM56218_A0_PORT_TABm_PORT_DIS_TAGf_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56218_A0_PORT_TABm_PORT_DIS_UNTAGf_GET(r) ((((r).port_tab[0]) >> 20) & 0x1)
#define BCM56218_A0_PORT_TABm_PORT_DIS_UNTAGf_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM56218_A0_PORT_TABm_PASS_CONTROL_FRAMESf_GET(r) ((((r).port_tab[0]) >> 21) & 0x1)
#define BCM56218_A0_PORT_TABm_PASS_CONTROL_FRAMESf_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM56218_A0_PORT_TABm_SUBNET_BASED_VID_ENABLEf_GET(r) ((((r).port_tab[0]) >> 22) & 0x1)
#define BCM56218_A0_PORT_TABm_SUBNET_BASED_VID_ENABLEf_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM56218_A0_PORT_TABm_MAC_BASED_VID_ENABLEf_GET(r) ((((r).port_tab[0]) >> 23) & 0x1)
#define BCM56218_A0_PORT_TABm_MAC_BASED_VID_ENABLEf_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM56218_A0_PORT_TABm_PORT_VIDf_GET(r) cdk_field32_get((r).port_tab,24,35)
#define BCM56218_A0_PORT_TABm_PORT_VIDf_SET(r,f) cdk_field32_set((r).port_tab,24,35,f)
#define BCM56218_A0_PORT_TABm_HIGIG_PACKETf_GET(r) ((((r).port_tab[1]) >> 4) & 0x1)
#define BCM56218_A0_PORT_TABm_HIGIG_PACKETf_SET(r,f) (r).port_tab[1]=(((r).port_tab[1] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56218_A0_PORT_TABm_NNI_PORTf_GET(r) ((((r).port_tab[1]) >> 5) & 0x1)
#define BCM56218_A0_PORT_TABm_NNI_PORTf_SET(r,f) (r).port_tab[1]=(((r).port_tab[1] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56218_A0_PORT_TABm_MAP_TAG_PKT_PRIORITYf_GET(r) ((((r).port_tab[1]) >> 6) & 0x1)
#define BCM56218_A0_PORT_TABm_MAP_TAG_PKT_PRIORITYf_SET(r,f) (r).port_tab[1]=(((r).port_tab[1] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56218_A0_PORT_TABm_MY_MODIDf_GET(r) ((((r).port_tab[1]) >> 7) & 0xf)
#define BCM56218_A0_PORT_TABm_MY_MODIDf_SET(r,f) (r).port_tab[1]=(((r).port_tab[1] & ~((uint32_t)0xf << 7)) | ((((uint32_t)f) & 0xf) << 7))
#define BCM56218_A0_PORT_TABm_OUTER_TPIDf_GET(r) ((((r).port_tab[1]) >> 11) & 0xffff)
#define BCM56218_A0_PORT_TABm_OUTER_TPIDf_SET(r,f) (r).port_tab[1]=(((r).port_tab[1] & ~((uint32_t)0xffff << 11)) | ((((uint32_t)f) & 0xffff) << 11))
#define BCM56218_A0_PORT_TABm_VLAN_PRECEDENCEf_GET(r) ((((r).port_tab[1]) >> 27) & 0x1)
#define BCM56218_A0_PORT_TABm_VLAN_PRECEDENCEf_SET(r,f) (r).port_tab[1]=(((r).port_tab[1] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM56218_A0_PORT_TABm_PORT_BRIDGEf_GET(r) ((((r).port_tab[1]) >> 28) & 0x1)
#define BCM56218_A0_PORT_TABm_PORT_BRIDGEf_SET(r,f) (r).port_tab[1]=(((r).port_tab[1] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM56218_A0_PORT_TABm_MODPORT_TABLE_SELf_GET(r) ((((r).port_tab[1]) >> 29) & 0x3)
#define BCM56218_A0_PORT_TABm_MODPORT_TABLE_SELf_SET(r,f) (r).port_tab[1]=(((r).port_tab[1] & ~((uint32_t)0x3 << 29)) | ((((uint32_t)f) & 0x3) << 29))
#define BCM56218_A0_PORT_TABm_IGNORE_MODID_LKUPSf_GET(r) ((((r).port_tab[1]) >> 31) & 0x1)
#define BCM56218_A0_PORT_TABm_IGNORE_MODID_LKUPSf_SET(r,f) (r).port_tab[1]=(((r).port_tab[1] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM56218_A0_PORT_TABm_REMOVE_HG_HDR_SRC_PORTf_GET(r) (((r).port_tab[2]) & 0x1)
#define BCM56218_A0_PORT_TABm_REMOVE_HG_HDR_SRC_PORTf_SET(r,f) (r).port_tab[2]=(((r).port_tab[2] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_PORT_TABm_ALLOW_SRC_MODf_GET(r) ((((r).port_tab[2]) >> 1) & 0x1)
#define BCM56218_A0_PORT_TABm_ALLOW_SRC_MODf_SET(r,f) (r).port_tab[2]=(((r).port_tab[2] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access PORT_TAB.
 *
 */
#define BCM56218_A0_READ_PORT_TABm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_PORT_TABm,i,(m._port_tab),3)
#define BCM56218_A0_WRITE_PORT_TABm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_PORT_TABm,i,&(m._port_tab),3)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_TABm BCM56218_A0_PORT_TABm
#define PORT_TABm_MIN BCM56218_A0_PORT_TABm_MIN
#define PORT_TABm_MAX BCM56218_A0_PORT_TABm_MAX
#define PORT_TABm_CMAX(u) BCM56218_A0_PORT_TABm_CMAX(u)
#define PORT_TABm_SIZE BCM56218_A0_PORT_TABm_SIZE
typedef BCM56218_A0_PORT_TABm_t PORT_TABm_t;
#define PORT_TABm_CLR BCM56218_A0_PORT_TABm_CLR
#define PORT_TABm_SET BCM56218_A0_PORT_TABm_SET
#define PORT_TABm_GET BCM56218_A0_PORT_TABm_GET
#define PORT_TABm_FILTER_ENABLEf_GET BCM56218_A0_PORT_TABm_FILTER_ENABLEf_GET
#define PORT_TABm_FILTER_ENABLEf_SET BCM56218_A0_PORT_TABm_FILTER_ENABLEf_SET
#define PORT_TABm_RESERVED0f_GET BCM56218_A0_PORT_TABm_RESERVED0f_GET
#define PORT_TABm_RESERVED0f_SET BCM56218_A0_PORT_TABm_RESERVED0f_SET
#define PORT_TABm_RESERVED1f_GET BCM56218_A0_PORT_TABm_RESERVED1f_GET
#define PORT_TABm_RESERVED1f_SET BCM56218_A0_PORT_TABm_RESERVED1f_SET
#define PORT_TABm_TRUST_DSCP_V4f_GET BCM56218_A0_PORT_TABm_TRUST_DSCP_V4f_GET
#define PORT_TABm_TRUST_DSCP_V4f_SET BCM56218_A0_PORT_TABm_TRUST_DSCP_V4f_SET
#define PORT_TABm_TRUST_DSCP_V6f_GET BCM56218_A0_PORT_TABm_TRUST_DSCP_V6f_GET
#define PORT_TABm_TRUST_DSCP_V6f_SET BCM56218_A0_PORT_TABm_TRUST_DSCP_V6f_SET
#define PORT_TABm_EN_IFILTERf_GET BCM56218_A0_PORT_TABm_EN_IFILTERf_GET
#define PORT_TABm_EN_IFILTERf_SET BCM56218_A0_PORT_TABm_EN_IFILTERf_SET
#define PORT_TABm_MIRRORf_GET BCM56218_A0_PORT_TABm_MIRRORf_GET
#define PORT_TABm_MIRRORf_SET BCM56218_A0_PORT_TABm_MIRRORf_SET
#define PORT_TABm_CMLf_GET BCM56218_A0_PORT_TABm_CMLf_GET
#define PORT_TABm_CMLf_SET BCM56218_A0_PORT_TABm_CMLf_SET
#define PORT_TABm_PORT_PRIf_GET BCM56218_A0_PORT_TABm_PORT_PRIf_GET
#define PORT_TABm_PORT_PRIf_SET BCM56218_A0_PORT_TABm_PORT_PRIf_SET
#define PORT_TABm_RESERVED2f_GET BCM56218_A0_PORT_TABm_RESERVED2f_GET
#define PORT_TABm_RESERVED2f_SET BCM56218_A0_PORT_TABm_RESERVED2f_SET
#define PORT_TABm_RESERVED3f_GET BCM56218_A0_PORT_TABm_RESERVED3f_GET
#define PORT_TABm_RESERVED3f_SET BCM56218_A0_PORT_TABm_RESERVED3f_SET
#define PORT_TABm_RESERVED4f_GET BCM56218_A0_PORT_TABm_RESERVED4f_GET
#define PORT_TABm_RESERVED4f_SET BCM56218_A0_PORT_TABm_RESERVED4f_SET
#define PORT_TABm_V6L3_ENABLEf_GET BCM56218_A0_PORT_TABm_V6L3_ENABLEf_GET
#define PORT_TABm_V6L3_ENABLEf_SET BCM56218_A0_PORT_TABm_V6L3_ENABLEf_SET
#define PORT_TABm_V4L3_ENABLEf_GET BCM56218_A0_PORT_TABm_V4L3_ENABLEf_GET
#define PORT_TABm_V4L3_ENABLEf_SET BCM56218_A0_PORT_TABm_V4L3_ENABLEf_SET
#define PORT_TABm_DROP_BPDUf_GET BCM56218_A0_PORT_TABm_DROP_BPDUf_GET
#define PORT_TABm_DROP_BPDUf_SET BCM56218_A0_PORT_TABm_DROP_BPDUf_SET
#define PORT_TABm_PORT_DIS_TAGf_GET BCM56218_A0_PORT_TABm_PORT_DIS_TAGf_GET
#define PORT_TABm_PORT_DIS_TAGf_SET BCM56218_A0_PORT_TABm_PORT_DIS_TAGf_SET
#define PORT_TABm_PORT_DIS_UNTAGf_GET BCM56218_A0_PORT_TABm_PORT_DIS_UNTAGf_GET
#define PORT_TABm_PORT_DIS_UNTAGf_SET BCM56218_A0_PORT_TABm_PORT_DIS_UNTAGf_SET
#define PORT_TABm_PASS_CONTROL_FRAMESf_GET BCM56218_A0_PORT_TABm_PASS_CONTROL_FRAMESf_GET
#define PORT_TABm_PASS_CONTROL_FRAMESf_SET BCM56218_A0_PORT_TABm_PASS_CONTROL_FRAMESf_SET
#define PORT_TABm_SUBNET_BASED_VID_ENABLEf_GET BCM56218_A0_PORT_TABm_SUBNET_BASED_VID_ENABLEf_GET
#define PORT_TABm_SUBNET_BASED_VID_ENABLEf_SET BCM56218_A0_PORT_TABm_SUBNET_BASED_VID_ENABLEf_SET
#define PORT_TABm_MAC_BASED_VID_ENABLEf_GET BCM56218_A0_PORT_TABm_MAC_BASED_VID_ENABLEf_GET
#define PORT_TABm_MAC_BASED_VID_ENABLEf_SET BCM56218_A0_PORT_TABm_MAC_BASED_VID_ENABLEf_SET
#define PORT_TABm_PORT_VIDf_GET BCM56218_A0_PORT_TABm_PORT_VIDf_GET
#define PORT_TABm_PORT_VIDf_SET BCM56218_A0_PORT_TABm_PORT_VIDf_SET
#define PORT_TABm_HIGIG_PACKETf_GET BCM56218_A0_PORT_TABm_HIGIG_PACKETf_GET
#define PORT_TABm_HIGIG_PACKETf_SET BCM56218_A0_PORT_TABm_HIGIG_PACKETf_SET
#define PORT_TABm_NNI_PORTf_GET BCM56218_A0_PORT_TABm_NNI_PORTf_GET
#define PORT_TABm_NNI_PORTf_SET BCM56218_A0_PORT_TABm_NNI_PORTf_SET
#define PORT_TABm_MAP_TAG_PKT_PRIORITYf_GET BCM56218_A0_PORT_TABm_MAP_TAG_PKT_PRIORITYf_GET
#define PORT_TABm_MAP_TAG_PKT_PRIORITYf_SET BCM56218_A0_PORT_TABm_MAP_TAG_PKT_PRIORITYf_SET
#define PORT_TABm_MY_MODIDf_GET BCM56218_A0_PORT_TABm_MY_MODIDf_GET
#define PORT_TABm_MY_MODIDf_SET BCM56218_A0_PORT_TABm_MY_MODIDf_SET
#define PORT_TABm_OUTER_TPIDf_GET BCM56218_A0_PORT_TABm_OUTER_TPIDf_GET
#define PORT_TABm_OUTER_TPIDf_SET BCM56218_A0_PORT_TABm_OUTER_TPIDf_SET
#define PORT_TABm_VLAN_PRECEDENCEf_GET BCM56218_A0_PORT_TABm_VLAN_PRECEDENCEf_GET
#define PORT_TABm_VLAN_PRECEDENCEf_SET BCM56218_A0_PORT_TABm_VLAN_PRECEDENCEf_SET
#define PORT_TABm_PORT_BRIDGEf_GET BCM56218_A0_PORT_TABm_PORT_BRIDGEf_GET
#define PORT_TABm_PORT_BRIDGEf_SET BCM56218_A0_PORT_TABm_PORT_BRIDGEf_SET
#define PORT_TABm_MODPORT_TABLE_SELf_GET BCM56218_A0_PORT_TABm_MODPORT_TABLE_SELf_GET
#define PORT_TABm_MODPORT_TABLE_SELf_SET BCM56218_A0_PORT_TABm_MODPORT_TABLE_SELf_SET
#define PORT_TABm_IGNORE_MODID_LKUPSf_GET BCM56218_A0_PORT_TABm_IGNORE_MODID_LKUPSf_GET
#define PORT_TABm_IGNORE_MODID_LKUPSf_SET BCM56218_A0_PORT_TABm_IGNORE_MODID_LKUPSf_SET
#define PORT_TABm_REMOVE_HG_HDR_SRC_PORTf_GET BCM56218_A0_PORT_TABm_REMOVE_HG_HDR_SRC_PORTf_GET
#define PORT_TABm_REMOVE_HG_HDR_SRC_PORTf_SET BCM56218_A0_PORT_TABm_REMOVE_HG_HDR_SRC_PORTf_SET
#define PORT_TABm_ALLOW_SRC_MODf_GET BCM56218_A0_PORT_TABm_ALLOW_SRC_MODf_GET
#define PORT_TABm_ALLOW_SRC_MODf_SET BCM56218_A0_PORT_TABm_ALLOW_SRC_MODf_SET
#define READ_PORT_TABm BCM56218_A0_READ_PORT_TABm
#define WRITE_PORT_TABm BCM56218_A0_WRITE_PORT_TABm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_PORT_TABm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  PPPEMPTYSTATUS
 * BLOCKS:   MMU
 * DESC:     Displays the PPP Empty status
 * SIZE:     32
 * FIELDS:
 *     PORT_BITMAP      PPP for port is empty
 *
 ******************************************************************************/
#define BCM56218_A0_PPPEMPTYSTATUSr 0x00680000

#define BCM56218_A0_PPPEMPTYSTATUSr_SIZE 4

/*
 * This structure should be used to declare and program PPPEMPTYSTATUS.
 *
 */
typedef union BCM56218_A0_PPPEMPTYSTATUSr_s {
	uint32_t v[1];
	uint32_t pppemptystatus[1];
	uint32_t _pppemptystatus;
} BCM56218_A0_PPPEMPTYSTATUSr_t;

#define BCM56218_A0_PPPEMPTYSTATUSr_CLR(r) (r).pppemptystatus[0] = 0
#define BCM56218_A0_PPPEMPTYSTATUSr_SET(r,d) (r).pppemptystatus[0] = d
#define BCM56218_A0_PPPEMPTYSTATUSr_GET(r) (r).pppemptystatus[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_PPPEMPTYSTATUSr_PORT_BITMAPf_GET(r) ((r).pppemptystatus[0])
#define BCM56218_A0_PPPEMPTYSTATUSr_PORT_BITMAPf_SET(r,f) (r).pppemptystatus[0]=((uint32_t)f)

/*
 * These macros can be used to access PPPEMPTYSTATUS.
 *
 */
#define BCM56218_A0_READ_PPPEMPTYSTATUSr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_PPPEMPTYSTATUSr,(r._pppemptystatus))
#define BCM56218_A0_WRITE_PPPEMPTYSTATUSr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_PPPEMPTYSTATUSr,&(r._pppemptystatus))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PPPEMPTYSTATUSr BCM56218_A0_PPPEMPTYSTATUSr
#define PPPEMPTYSTATUSr_SIZE BCM56218_A0_PPPEMPTYSTATUSr_SIZE
typedef BCM56218_A0_PPPEMPTYSTATUSr_t PPPEMPTYSTATUSr_t;
#define PPPEMPTYSTATUSr_CLR BCM56218_A0_PPPEMPTYSTATUSr_CLR
#define PPPEMPTYSTATUSr_SET BCM56218_A0_PPPEMPTYSTATUSr_SET
#define PPPEMPTYSTATUSr_GET BCM56218_A0_PPPEMPTYSTATUSr_GET
#define PPPEMPTYSTATUSr_PORT_BITMAPf_GET BCM56218_A0_PPPEMPTYSTATUSr_PORT_BITMAPf_GET
#define PPPEMPTYSTATUSr_PORT_BITMAPf_SET BCM56218_A0_PPPEMPTYSTATUSr_PORT_BITMAPf_SET
#define READ_PPPEMPTYSTATUSr BCM56218_A0_READ_PPPEMPTYSTATUSr
#define WRITE_PPPEMPTYSTATUSr BCM56218_A0_WRITE_PPPEMPTYSTATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_PPPEMPTYSTATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  PPPEMPTYSTATUS_HI
 * BLOCKS:   MMU
 * DESC:     Displays the PPP Empty status for ports 53-32
 * SIZE:     32
 * FIELDS:
 *     PORT_BITMAP      PPP for port is empty for ports 53-32
 *
 ******************************************************************************/
#define BCM56218_A0_PPPEMPTYSTATUS_HIr 0x00680001

#define BCM56218_A0_PPPEMPTYSTATUS_HIr_SIZE 4

/*
 * This structure should be used to declare and program PPPEMPTYSTATUS_HI.
 *
 */
typedef union BCM56218_A0_PPPEMPTYSTATUS_HIr_s {
	uint32_t v[1];
	uint32_t pppemptystatus_hi[1];
	uint32_t _pppemptystatus_hi;
} BCM56218_A0_PPPEMPTYSTATUS_HIr_t;

#define BCM56218_A0_PPPEMPTYSTATUS_HIr_CLR(r) (r).pppemptystatus_hi[0] = 0
#define BCM56218_A0_PPPEMPTYSTATUS_HIr_SET(r,d) (r).pppemptystatus_hi[0] = d
#define BCM56218_A0_PPPEMPTYSTATUS_HIr_GET(r) (r).pppemptystatus_hi[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_PPPEMPTYSTATUS_HIr_PORT_BITMAPf_GET(r) (((r).pppemptystatus_hi[0]) & 0x3fffff)
#define BCM56218_A0_PPPEMPTYSTATUS_HIr_PORT_BITMAPf_SET(r,f) (r).pppemptystatus_hi[0]=(((r).pppemptystatus_hi[0] & ~((uint32_t)0x3fffff)) | (((uint32_t)f) & 0x3fffff))

/*
 * These macros can be used to access PPPEMPTYSTATUS_HI.
 *
 */
#define BCM56218_A0_READ_PPPEMPTYSTATUS_HIr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_PPPEMPTYSTATUS_HIr,(r._pppemptystatus_hi))
#define BCM56218_A0_WRITE_PPPEMPTYSTATUS_HIr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_PPPEMPTYSTATUS_HIr,&(r._pppemptystatus_hi))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PPPEMPTYSTATUS_HIr BCM56218_A0_PPPEMPTYSTATUS_HIr
#define PPPEMPTYSTATUS_HIr_SIZE BCM56218_A0_PPPEMPTYSTATUS_HIr_SIZE
typedef BCM56218_A0_PPPEMPTYSTATUS_HIr_t PPPEMPTYSTATUS_HIr_t;
#define PPPEMPTYSTATUS_HIr_CLR BCM56218_A0_PPPEMPTYSTATUS_HIr_CLR
#define PPPEMPTYSTATUS_HIr_SET BCM56218_A0_PPPEMPTYSTATUS_HIr_SET
#define PPPEMPTYSTATUS_HIr_GET BCM56218_A0_PPPEMPTYSTATUS_HIr_GET
#define PPPEMPTYSTATUS_HIr_PORT_BITMAPf_GET BCM56218_A0_PPPEMPTYSTATUS_HIr_PORT_BITMAPf_GET
#define PPPEMPTYSTATUS_HIr_PORT_BITMAPf_SET BCM56218_A0_PPPEMPTYSTATUS_HIr_PORT_BITMAPf_SET
#define READ_PPPEMPTYSTATUS_HIr BCM56218_A0_READ_PPPEMPTYSTATUS_HIr
#define WRITE_PPPEMPTYSTATUS_HIr BCM56218_A0_WRITE_PPPEMPTYSTATUS_HIr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_PPPEMPTYSTATUS_HIr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  PRIORITY_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     Register that controls the generation of various priorities
 * SIZE:     32
 * FIELDS:
 *     SC_CPU_PRI_MODE  Specifies how the CPU priority of HiGig+ and HiGig2 system control packets will be generated.
 *     ALWAYS_APPLY_CPU_PRI_SEL If set, the internal priority of both the unicast and non-unicast packets will go through CPU_PRI_SEL mapping. If not set, the internal priority of only the non-unicast packets will go through CPU_PRI_SEL mapping.
 *
 ******************************************************************************/
#define BCM56218_A0_PRIORITY_CONTROLr 0x0e780133

#define BCM56218_A0_PRIORITY_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program PRIORITY_CONTROL.
 *
 */
typedef union BCM56218_A0_PRIORITY_CONTROLr_s {
	uint32_t v[1];
	uint32_t priority_control[1];
	uint32_t _priority_control;
} BCM56218_A0_PRIORITY_CONTROLr_t;

#define BCM56218_A0_PRIORITY_CONTROLr_CLR(r) (r).priority_control[0] = 0
#define BCM56218_A0_PRIORITY_CONTROLr_SET(r,d) (r).priority_control[0] = d
#define BCM56218_A0_PRIORITY_CONTROLr_GET(r) (r).priority_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_PRIORITY_CONTROLr_SC_CPU_PRI_MODEf_GET(r) (((r).priority_control[0]) & 0x1)
#define BCM56218_A0_PRIORITY_CONTROLr_SC_CPU_PRI_MODEf_SET(r,f) (r).priority_control[0]=(((r).priority_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_PRIORITY_CONTROLr_ALWAYS_APPLY_CPU_PRI_SELf_GET(r) ((((r).priority_control[0]) >> 1) & 0x1)
#define BCM56218_A0_PRIORITY_CONTROLr_ALWAYS_APPLY_CPU_PRI_SELf_SET(r,f) (r).priority_control[0]=(((r).priority_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access PRIORITY_CONTROL.
 *
 */
#define BCM56218_A0_READ_PRIORITY_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_PRIORITY_CONTROLr,(r._priority_control))
#define BCM56218_A0_WRITE_PRIORITY_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_PRIORITY_CONTROLr,&(r._priority_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PRIORITY_CONTROLr BCM56218_A0_PRIORITY_CONTROLr
#define PRIORITY_CONTROLr_SIZE BCM56218_A0_PRIORITY_CONTROLr_SIZE
typedef BCM56218_A0_PRIORITY_CONTROLr_t PRIORITY_CONTROLr_t;
#define PRIORITY_CONTROLr_CLR BCM56218_A0_PRIORITY_CONTROLr_CLR
#define PRIORITY_CONTROLr_SET BCM56218_A0_PRIORITY_CONTROLr_SET
#define PRIORITY_CONTROLr_GET BCM56218_A0_PRIORITY_CONTROLr_GET
#define PRIORITY_CONTROLr_SC_CPU_PRI_MODEf_GET BCM56218_A0_PRIORITY_CONTROLr_SC_CPU_PRI_MODEf_GET
#define PRIORITY_CONTROLr_SC_CPU_PRI_MODEf_SET BCM56218_A0_PRIORITY_CONTROLr_SC_CPU_PRI_MODEf_SET
#define PRIORITY_CONTROLr_ALWAYS_APPLY_CPU_PRI_SELf_GET BCM56218_A0_PRIORITY_CONTROLr_ALWAYS_APPLY_CPU_PRI_SELf_GET
#define PRIORITY_CONTROLr_ALWAYS_APPLY_CPU_PRI_SELf_SET BCM56218_A0_PRIORITY_CONTROLr_ALWAYS_APPLY_CPU_PRI_SELf_SET
#define READ_PRIORITY_CONTROLr BCM56218_A0_READ_PRIORITY_CONTROLr
#define WRITE_PRIORITY_CONTROLr BCM56218_A0_WRITE_PRIORITY_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_PRIORITY_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  PROTOCOL_PKT_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     Protocol Packet Control Register
 * SIZE:     32
 * FIELDS:
 *     DHCP_PKT_TO_CPU  Send DHCP Packets to the CPU
 *     DHCP_PKT_DROP    Drop DHCP Packets
 *     ND_PKT_TO_CPU    Send ND Packets to the CPU
 *     ND_PKT_DROP      Drop ND Packets
 *     ARP_REQUEST_TO_CPU Send ARP Request Packets to the CPU
 *     ARP_REQUEST_DROP Drop ARP Request Packets
 *     ARP_REPLY_TO_CPU Send ARP Reply Packets to the CPU
 *     ARP_REPLY_DROP   Drop ARP Reply Packets
 *
 ******************************************************************************/
#define BCM56218_A0_PROTOCOL_PKT_CONTROLr 0x0b700006

#define BCM56218_A0_PROTOCOL_PKT_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program PROTOCOL_PKT_CONTROL.
 *
 */
typedef union BCM56218_A0_PROTOCOL_PKT_CONTROLr_s {
	uint32_t v[1];
	uint32_t protocol_pkt_control[1];
	uint32_t _protocol_pkt_control;
} BCM56218_A0_PROTOCOL_PKT_CONTROLr_t;

#define BCM56218_A0_PROTOCOL_PKT_CONTROLr_CLR(r) (r).protocol_pkt_control[0] = 0
#define BCM56218_A0_PROTOCOL_PKT_CONTROLr_SET(r,d) (r).protocol_pkt_control[0] = d
#define BCM56218_A0_PROTOCOL_PKT_CONTROLr_GET(r) (r).protocol_pkt_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_PROTOCOL_PKT_CONTROLr_DHCP_PKT_TO_CPUf_GET(r) (((r).protocol_pkt_control[0]) & 0x1)
#define BCM56218_A0_PROTOCOL_PKT_CONTROLr_DHCP_PKT_TO_CPUf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_PROTOCOL_PKT_CONTROLr_DHCP_PKT_DROPf_GET(r) ((((r).protocol_pkt_control[0]) >> 1) & 0x1)
#define BCM56218_A0_PROTOCOL_PKT_CONTROLr_DHCP_PKT_DROPf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_PROTOCOL_PKT_CONTROLr_ND_PKT_TO_CPUf_GET(r) ((((r).protocol_pkt_control[0]) >> 2) & 0x1)
#define BCM56218_A0_PROTOCOL_PKT_CONTROLr_ND_PKT_TO_CPUf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_PROTOCOL_PKT_CONTROLr_ND_PKT_DROPf_GET(r) ((((r).protocol_pkt_control[0]) >> 3) & 0x1)
#define BCM56218_A0_PROTOCOL_PKT_CONTROLr_ND_PKT_DROPf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56218_A0_PROTOCOL_PKT_CONTROLr_ARP_REQUEST_TO_CPUf_GET(r) ((((r).protocol_pkt_control[0]) >> 4) & 0x1)
#define BCM56218_A0_PROTOCOL_PKT_CONTROLr_ARP_REQUEST_TO_CPUf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56218_A0_PROTOCOL_PKT_CONTROLr_ARP_REQUEST_DROPf_GET(r) ((((r).protocol_pkt_control[0]) >> 5) & 0x1)
#define BCM56218_A0_PROTOCOL_PKT_CONTROLr_ARP_REQUEST_DROPf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56218_A0_PROTOCOL_PKT_CONTROLr_ARP_REPLY_TO_CPUf_GET(r) ((((r).protocol_pkt_control[0]) >> 6) & 0x1)
#define BCM56218_A0_PROTOCOL_PKT_CONTROLr_ARP_REPLY_TO_CPUf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56218_A0_PROTOCOL_PKT_CONTROLr_ARP_REPLY_DROPf_GET(r) ((((r).protocol_pkt_control[0]) >> 7) & 0x1)
#define BCM56218_A0_PROTOCOL_PKT_CONTROLr_ARP_REPLY_DROPf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access PROTOCOL_PKT_CONTROL.
 *
 */
#define BCM56218_A0_READ_PROTOCOL_PKT_CONTROLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_PROTOCOL_PKT_CONTROLr,(r._protocol_pkt_control))
#define BCM56218_A0_WRITE_PROTOCOL_PKT_CONTROLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_PROTOCOL_PKT_CONTROLr,&(r._protocol_pkt_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PROTOCOL_PKT_CONTROLr BCM56218_A0_PROTOCOL_PKT_CONTROLr
#define PROTOCOL_PKT_CONTROLr_SIZE BCM56218_A0_PROTOCOL_PKT_CONTROLr_SIZE
typedef BCM56218_A0_PROTOCOL_PKT_CONTROLr_t PROTOCOL_PKT_CONTROLr_t;
#define PROTOCOL_PKT_CONTROLr_CLR BCM56218_A0_PROTOCOL_PKT_CONTROLr_CLR
#define PROTOCOL_PKT_CONTROLr_SET BCM56218_A0_PROTOCOL_PKT_CONTROLr_SET
#define PROTOCOL_PKT_CONTROLr_GET BCM56218_A0_PROTOCOL_PKT_CONTROLr_GET
#define PROTOCOL_PKT_CONTROLr_DHCP_PKT_TO_CPUf_GET BCM56218_A0_PROTOCOL_PKT_CONTROLr_DHCP_PKT_TO_CPUf_GET
#define PROTOCOL_PKT_CONTROLr_DHCP_PKT_TO_CPUf_SET BCM56218_A0_PROTOCOL_PKT_CONTROLr_DHCP_PKT_TO_CPUf_SET
#define PROTOCOL_PKT_CONTROLr_DHCP_PKT_DROPf_GET BCM56218_A0_PROTOCOL_PKT_CONTROLr_DHCP_PKT_DROPf_GET
#define PROTOCOL_PKT_CONTROLr_DHCP_PKT_DROPf_SET BCM56218_A0_PROTOCOL_PKT_CONTROLr_DHCP_PKT_DROPf_SET
#define PROTOCOL_PKT_CONTROLr_ND_PKT_TO_CPUf_GET BCM56218_A0_PROTOCOL_PKT_CONTROLr_ND_PKT_TO_CPUf_GET
#define PROTOCOL_PKT_CONTROLr_ND_PKT_TO_CPUf_SET BCM56218_A0_PROTOCOL_PKT_CONTROLr_ND_PKT_TO_CPUf_SET
#define PROTOCOL_PKT_CONTROLr_ND_PKT_DROPf_GET BCM56218_A0_PROTOCOL_PKT_CONTROLr_ND_PKT_DROPf_GET
#define PROTOCOL_PKT_CONTROLr_ND_PKT_DROPf_SET BCM56218_A0_PROTOCOL_PKT_CONTROLr_ND_PKT_DROPf_SET
#define PROTOCOL_PKT_CONTROLr_ARP_REQUEST_TO_CPUf_GET BCM56218_A0_PROTOCOL_PKT_CONTROLr_ARP_REQUEST_TO_CPUf_GET
#define PROTOCOL_PKT_CONTROLr_ARP_REQUEST_TO_CPUf_SET BCM56218_A0_PROTOCOL_PKT_CONTROLr_ARP_REQUEST_TO_CPUf_SET
#define PROTOCOL_PKT_CONTROLr_ARP_REQUEST_DROPf_GET BCM56218_A0_PROTOCOL_PKT_CONTROLr_ARP_REQUEST_DROPf_GET
#define PROTOCOL_PKT_CONTROLr_ARP_REQUEST_DROPf_SET BCM56218_A0_PROTOCOL_PKT_CONTROLr_ARP_REQUEST_DROPf_SET
#define PROTOCOL_PKT_CONTROLr_ARP_REPLY_TO_CPUf_GET BCM56218_A0_PROTOCOL_PKT_CONTROLr_ARP_REPLY_TO_CPUf_GET
#define PROTOCOL_PKT_CONTROLr_ARP_REPLY_TO_CPUf_SET BCM56218_A0_PROTOCOL_PKT_CONTROLr_ARP_REPLY_TO_CPUf_SET
#define PROTOCOL_PKT_CONTROLr_ARP_REPLY_DROPf_GET BCM56218_A0_PROTOCOL_PKT_CONTROLr_ARP_REPLY_DROPf_GET
#define PROTOCOL_PKT_CONTROLr_ARP_REPLY_DROPf_SET BCM56218_A0_PROTOCOL_PKT_CONTROLr_ARP_REPLY_DROPf_SET
#define READ_PROTOCOL_PKT_CONTROLr BCM56218_A0_READ_PROTOCOL_PKT_CONTROLr
#define WRITE_PROTOCOL_PKT_CONTROLr BCM56218_A0_WRITE_PROTOCOL_PKT_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_PROTOCOL_PKT_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  RDBGC0
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #0
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_RDBGC0r 0x0e70000b

#define BCM56218_A0_RDBGC0r_SIZE 4

/*
 * This structure should be used to declare and program RDBGC0.
 *
 */
typedef union BCM56218_A0_RDBGC0r_s {
	uint32_t v[1];
	uint32_t rdbgc0[1];
	uint32_t _rdbgc0;
} BCM56218_A0_RDBGC0r_t;

#define BCM56218_A0_RDBGC0r_CLR(r) (r).rdbgc0[0] = 0
#define BCM56218_A0_RDBGC0r_SET(r,d) (r).rdbgc0[0] = d
#define BCM56218_A0_RDBGC0r_GET(r) (r).rdbgc0[0]


/*
 * These macros can be used to access RDBGC0.
 *
 */
#define BCM56218_A0_READ_RDBGC0r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_RDBGC0r,(r._rdbgc0))
#define BCM56218_A0_WRITE_RDBGC0r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_RDBGC0r,&(r._rdbgc0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC0r BCM56218_A0_RDBGC0r
#define RDBGC0r_SIZE BCM56218_A0_RDBGC0r_SIZE
typedef BCM56218_A0_RDBGC0r_t RDBGC0r_t;
#define RDBGC0r_CLR BCM56218_A0_RDBGC0r_CLR
#define RDBGC0r_SET BCM56218_A0_RDBGC0r_SET
#define RDBGC0r_GET BCM56218_A0_RDBGC0r_GET
#define READ_RDBGC0r BCM56218_A0_READ_RDBGC0r
#define WRITE_RDBGC0r BCM56218_A0_WRITE_RDBGC0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_RDBGC0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  RDBGC0_SELECT
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #0 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The RDBGC0_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM56218_A0_RDBGC0_SELECTr 0x0e780020

#define BCM56218_A0_RDBGC0_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program RDBGC0_SELECT.
 *
 */
typedef union BCM56218_A0_RDBGC0_SELECTr_s {
	uint32_t v[1];
	uint32_t rdbgc0_select[1];
	uint32_t _rdbgc0_select;
} BCM56218_A0_RDBGC0_SELECTr_t;

#define BCM56218_A0_RDBGC0_SELECTr_CLR(r) (r).rdbgc0_select[0] = 0
#define BCM56218_A0_RDBGC0_SELECTr_SET(r,d) (r).rdbgc0_select[0] = d
#define BCM56218_A0_RDBGC0_SELECTr_GET(r) (r).rdbgc0_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_RDBGC0_SELECTr_BITMAPf_GET(r) (((r).rdbgc0_select[0]) & 0x3fffffff)
#define BCM56218_A0_RDBGC0_SELECTr_BITMAPf_SET(r,f) (r).rdbgc0_select[0]=(((r).rdbgc0_select[0] & ~((uint32_t)0x3fffffff)) | (((uint32_t)f) & 0x3fffffff))

/*
 * These macros can be used to access RDBGC0_SELECT.
 *
 */
#define BCM56218_A0_READ_RDBGC0_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_RDBGC0_SELECTr,(r._rdbgc0_select))
#define BCM56218_A0_WRITE_RDBGC0_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_RDBGC0_SELECTr,&(r._rdbgc0_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC0_SELECTr BCM56218_A0_RDBGC0_SELECTr
#define RDBGC0_SELECTr_SIZE BCM56218_A0_RDBGC0_SELECTr_SIZE
typedef BCM56218_A0_RDBGC0_SELECTr_t RDBGC0_SELECTr_t;
#define RDBGC0_SELECTr_CLR BCM56218_A0_RDBGC0_SELECTr_CLR
#define RDBGC0_SELECTr_SET BCM56218_A0_RDBGC0_SELECTr_SET
#define RDBGC0_SELECTr_GET BCM56218_A0_RDBGC0_SELECTr_GET
#define RDBGC0_SELECTr_BITMAPf_GET BCM56218_A0_RDBGC0_SELECTr_BITMAPf_GET
#define RDBGC0_SELECTr_BITMAPf_SET BCM56218_A0_RDBGC0_SELECTr_BITMAPf_SET
#define READ_RDBGC0_SELECTr BCM56218_A0_READ_RDBGC0_SELECTr
#define WRITE_RDBGC0_SELECTr BCM56218_A0_WRITE_RDBGC0_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_RDBGC0_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  RDBGC1
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #1
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_RDBGC1r 0x0e70000c

#define BCM56218_A0_RDBGC1r_SIZE 4

/*
 * This structure should be used to declare and program RDBGC1.
 *
 */
typedef union BCM56218_A0_RDBGC1r_s {
	uint32_t v[1];
	uint32_t rdbgc1[1];
	uint32_t _rdbgc1;
} BCM56218_A0_RDBGC1r_t;

#define BCM56218_A0_RDBGC1r_CLR(r) (r).rdbgc1[0] = 0
#define BCM56218_A0_RDBGC1r_SET(r,d) (r).rdbgc1[0] = d
#define BCM56218_A0_RDBGC1r_GET(r) (r).rdbgc1[0]


/*
 * These macros can be used to access RDBGC1.
 *
 */
#define BCM56218_A0_READ_RDBGC1r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_RDBGC1r,(r._rdbgc1))
#define BCM56218_A0_WRITE_RDBGC1r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_RDBGC1r,&(r._rdbgc1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC1r BCM56218_A0_RDBGC1r
#define RDBGC1r_SIZE BCM56218_A0_RDBGC1r_SIZE
typedef BCM56218_A0_RDBGC1r_t RDBGC1r_t;
#define RDBGC1r_CLR BCM56218_A0_RDBGC1r_CLR
#define RDBGC1r_SET BCM56218_A0_RDBGC1r_SET
#define RDBGC1r_GET BCM56218_A0_RDBGC1r_GET
#define READ_RDBGC1r BCM56218_A0_READ_RDBGC1r
#define WRITE_RDBGC1r BCM56218_A0_WRITE_RDBGC1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_RDBGC1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  RDBGC1_SELECT
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #1 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The RDBGC1_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM56218_A0_RDBGC1_SELECTr 0x0e780021

#define BCM56218_A0_RDBGC1_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program RDBGC1_SELECT.
 *
 */
typedef union BCM56218_A0_RDBGC1_SELECTr_s {
	uint32_t v[1];
	uint32_t rdbgc1_select[1];
	uint32_t _rdbgc1_select;
} BCM56218_A0_RDBGC1_SELECTr_t;

#define BCM56218_A0_RDBGC1_SELECTr_CLR(r) (r).rdbgc1_select[0] = 0
#define BCM56218_A0_RDBGC1_SELECTr_SET(r,d) (r).rdbgc1_select[0] = d
#define BCM56218_A0_RDBGC1_SELECTr_GET(r) (r).rdbgc1_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_RDBGC1_SELECTr_BITMAPf_GET(r) (((r).rdbgc1_select[0]) & 0x3fffffff)
#define BCM56218_A0_RDBGC1_SELECTr_BITMAPf_SET(r,f) (r).rdbgc1_select[0]=(((r).rdbgc1_select[0] & ~((uint32_t)0x3fffffff)) | (((uint32_t)f) & 0x3fffffff))

/*
 * These macros can be used to access RDBGC1_SELECT.
 *
 */
#define BCM56218_A0_READ_RDBGC1_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_RDBGC1_SELECTr,(r._rdbgc1_select))
#define BCM56218_A0_WRITE_RDBGC1_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_RDBGC1_SELECTr,&(r._rdbgc1_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC1_SELECTr BCM56218_A0_RDBGC1_SELECTr
#define RDBGC1_SELECTr_SIZE BCM56218_A0_RDBGC1_SELECTr_SIZE
typedef BCM56218_A0_RDBGC1_SELECTr_t RDBGC1_SELECTr_t;
#define RDBGC1_SELECTr_CLR BCM56218_A0_RDBGC1_SELECTr_CLR
#define RDBGC1_SELECTr_SET BCM56218_A0_RDBGC1_SELECTr_SET
#define RDBGC1_SELECTr_GET BCM56218_A0_RDBGC1_SELECTr_GET
#define RDBGC1_SELECTr_BITMAPf_GET BCM56218_A0_RDBGC1_SELECTr_BITMAPf_GET
#define RDBGC1_SELECTr_BITMAPf_SET BCM56218_A0_RDBGC1_SELECTr_BITMAPf_SET
#define READ_RDBGC1_SELECTr BCM56218_A0_READ_RDBGC1_SELECTr
#define WRITE_RDBGC1_SELECTr BCM56218_A0_WRITE_RDBGC1_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_RDBGC1_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  RDBGC2
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #2
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_RDBGC2r 0x0e70000d

#define BCM56218_A0_RDBGC2r_SIZE 4

/*
 * This structure should be used to declare and program RDBGC2.
 *
 */
typedef union BCM56218_A0_RDBGC2r_s {
	uint32_t v[1];
	uint32_t rdbgc2[1];
	uint32_t _rdbgc2;
} BCM56218_A0_RDBGC2r_t;

#define BCM56218_A0_RDBGC2r_CLR(r) (r).rdbgc2[0] = 0
#define BCM56218_A0_RDBGC2r_SET(r,d) (r).rdbgc2[0] = d
#define BCM56218_A0_RDBGC2r_GET(r) (r).rdbgc2[0]


/*
 * These macros can be used to access RDBGC2.
 *
 */
#define BCM56218_A0_READ_RDBGC2r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_RDBGC2r,(r._rdbgc2))
#define BCM56218_A0_WRITE_RDBGC2r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_RDBGC2r,&(r._rdbgc2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC2r BCM56218_A0_RDBGC2r
#define RDBGC2r_SIZE BCM56218_A0_RDBGC2r_SIZE
typedef BCM56218_A0_RDBGC2r_t RDBGC2r_t;
#define RDBGC2r_CLR BCM56218_A0_RDBGC2r_CLR
#define RDBGC2r_SET BCM56218_A0_RDBGC2r_SET
#define RDBGC2r_GET BCM56218_A0_RDBGC2r_GET
#define READ_RDBGC2r BCM56218_A0_READ_RDBGC2r
#define WRITE_RDBGC2r BCM56218_A0_WRITE_RDBGC2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_RDBGC2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  RDBGC2_SELECT
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #2 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The RDBGC2_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM56218_A0_RDBGC2_SELECTr 0x0e780022

#define BCM56218_A0_RDBGC2_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program RDBGC2_SELECT.
 *
 */
typedef union BCM56218_A0_RDBGC2_SELECTr_s {
	uint32_t v[1];
	uint32_t rdbgc2_select[1];
	uint32_t _rdbgc2_select;
} BCM56218_A0_RDBGC2_SELECTr_t;

#define BCM56218_A0_RDBGC2_SELECTr_CLR(r) (r).rdbgc2_select[0] = 0
#define BCM56218_A0_RDBGC2_SELECTr_SET(r,d) (r).rdbgc2_select[0] = d
#define BCM56218_A0_RDBGC2_SELECTr_GET(r) (r).rdbgc2_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_RDBGC2_SELECTr_BITMAPf_GET(r) (((r).rdbgc2_select[0]) & 0x3fffffff)
#define BCM56218_A0_RDBGC2_SELECTr_BITMAPf_SET(r,f) (r).rdbgc2_select[0]=(((r).rdbgc2_select[0] & ~((uint32_t)0x3fffffff)) | (((uint32_t)f) & 0x3fffffff))

/*
 * These macros can be used to access RDBGC2_SELECT.
 *
 */
#define BCM56218_A0_READ_RDBGC2_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_RDBGC2_SELECTr,(r._rdbgc2_select))
#define BCM56218_A0_WRITE_RDBGC2_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_RDBGC2_SELECTr,&(r._rdbgc2_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC2_SELECTr BCM56218_A0_RDBGC2_SELECTr
#define RDBGC2_SELECTr_SIZE BCM56218_A0_RDBGC2_SELECTr_SIZE
typedef BCM56218_A0_RDBGC2_SELECTr_t RDBGC2_SELECTr_t;
#define RDBGC2_SELECTr_CLR BCM56218_A0_RDBGC2_SELECTr_CLR
#define RDBGC2_SELECTr_SET BCM56218_A0_RDBGC2_SELECTr_SET
#define RDBGC2_SELECTr_GET BCM56218_A0_RDBGC2_SELECTr_GET
#define RDBGC2_SELECTr_BITMAPf_GET BCM56218_A0_RDBGC2_SELECTr_BITMAPf_GET
#define RDBGC2_SELECTr_BITMAPf_SET BCM56218_A0_RDBGC2_SELECTr_BITMAPf_SET
#define READ_RDBGC2_SELECTr BCM56218_A0_READ_RDBGC2_SELECTr
#define WRITE_RDBGC2_SELECTr BCM56218_A0_WRITE_RDBGC2_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_RDBGC2_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  RDBGC3
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #3
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_RDBGC3r 0x0e70000e

#define BCM56218_A0_RDBGC3r_SIZE 4

/*
 * This structure should be used to declare and program RDBGC3.
 *
 */
typedef union BCM56218_A0_RDBGC3r_s {
	uint32_t v[1];
	uint32_t rdbgc3[1];
	uint32_t _rdbgc3;
} BCM56218_A0_RDBGC3r_t;

#define BCM56218_A0_RDBGC3r_CLR(r) (r).rdbgc3[0] = 0
#define BCM56218_A0_RDBGC3r_SET(r,d) (r).rdbgc3[0] = d
#define BCM56218_A0_RDBGC3r_GET(r) (r).rdbgc3[0]


/*
 * These macros can be used to access RDBGC3.
 *
 */
#define BCM56218_A0_READ_RDBGC3r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_RDBGC3r,(r._rdbgc3))
#define BCM56218_A0_WRITE_RDBGC3r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_RDBGC3r,&(r._rdbgc3))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC3r BCM56218_A0_RDBGC3r
#define RDBGC3r_SIZE BCM56218_A0_RDBGC3r_SIZE
typedef BCM56218_A0_RDBGC3r_t RDBGC3r_t;
#define RDBGC3r_CLR BCM56218_A0_RDBGC3r_CLR
#define RDBGC3r_SET BCM56218_A0_RDBGC3r_SET
#define RDBGC3r_GET BCM56218_A0_RDBGC3r_GET
#define READ_RDBGC3r BCM56218_A0_READ_RDBGC3r
#define WRITE_RDBGC3r BCM56218_A0_WRITE_RDBGC3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_RDBGC3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  RDBGC3_SELECT
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #3 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The RDBGC3_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM56218_A0_RDBGC3_SELECTr 0x0e780023

#define BCM56218_A0_RDBGC3_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program RDBGC3_SELECT.
 *
 */
typedef union BCM56218_A0_RDBGC3_SELECTr_s {
	uint32_t v[1];
	uint32_t rdbgc3_select[1];
	uint32_t _rdbgc3_select;
} BCM56218_A0_RDBGC3_SELECTr_t;

#define BCM56218_A0_RDBGC3_SELECTr_CLR(r) (r).rdbgc3_select[0] = 0
#define BCM56218_A0_RDBGC3_SELECTr_SET(r,d) (r).rdbgc3_select[0] = d
#define BCM56218_A0_RDBGC3_SELECTr_GET(r) (r).rdbgc3_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_RDBGC3_SELECTr_BITMAPf_GET(r) (((r).rdbgc3_select[0]) & 0x3fffffff)
#define BCM56218_A0_RDBGC3_SELECTr_BITMAPf_SET(r,f) (r).rdbgc3_select[0]=(((r).rdbgc3_select[0] & ~((uint32_t)0x3fffffff)) | (((uint32_t)f) & 0x3fffffff))

/*
 * These macros can be used to access RDBGC3_SELECT.
 *
 */
#define BCM56218_A0_READ_RDBGC3_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_RDBGC3_SELECTr,(r._rdbgc3_select))
#define BCM56218_A0_WRITE_RDBGC3_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_RDBGC3_SELECTr,&(r._rdbgc3_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC3_SELECTr BCM56218_A0_RDBGC3_SELECTr
#define RDBGC3_SELECTr_SIZE BCM56218_A0_RDBGC3_SELECTr_SIZE
typedef BCM56218_A0_RDBGC3_SELECTr_t RDBGC3_SELECTr_t;
#define RDBGC3_SELECTr_CLR BCM56218_A0_RDBGC3_SELECTr_CLR
#define RDBGC3_SELECTr_SET BCM56218_A0_RDBGC3_SELECTr_SET
#define RDBGC3_SELECTr_GET BCM56218_A0_RDBGC3_SELECTr_GET
#define RDBGC3_SELECTr_BITMAPf_GET BCM56218_A0_RDBGC3_SELECTr_BITMAPf_GET
#define RDBGC3_SELECTr_BITMAPf_SET BCM56218_A0_RDBGC3_SELECTr_BITMAPf_SET
#define READ_RDBGC3_SELECTr BCM56218_A0_READ_RDBGC3_SELECTr
#define WRITE_RDBGC3_SELECTr BCM56218_A0_WRITE_RDBGC3_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_RDBGC3_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  RDBGC4
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #4
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_RDBGC4r 0x0e70000f

#define BCM56218_A0_RDBGC4r_SIZE 4

/*
 * This structure should be used to declare and program RDBGC4.
 *
 */
typedef union BCM56218_A0_RDBGC4r_s {
	uint32_t v[1];
	uint32_t rdbgc4[1];
	uint32_t _rdbgc4;
} BCM56218_A0_RDBGC4r_t;

#define BCM56218_A0_RDBGC4r_CLR(r) (r).rdbgc4[0] = 0
#define BCM56218_A0_RDBGC4r_SET(r,d) (r).rdbgc4[0] = d
#define BCM56218_A0_RDBGC4r_GET(r) (r).rdbgc4[0]


/*
 * These macros can be used to access RDBGC4.
 *
 */
#define BCM56218_A0_READ_RDBGC4r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_RDBGC4r,(r._rdbgc4))
#define BCM56218_A0_WRITE_RDBGC4r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_RDBGC4r,&(r._rdbgc4))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC4r BCM56218_A0_RDBGC4r
#define RDBGC4r_SIZE BCM56218_A0_RDBGC4r_SIZE
typedef BCM56218_A0_RDBGC4r_t RDBGC4r_t;
#define RDBGC4r_CLR BCM56218_A0_RDBGC4r_CLR
#define RDBGC4r_SET BCM56218_A0_RDBGC4r_SET
#define RDBGC4r_GET BCM56218_A0_RDBGC4r_GET
#define READ_RDBGC4r BCM56218_A0_READ_RDBGC4r
#define WRITE_RDBGC4r BCM56218_A0_WRITE_RDBGC4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_RDBGC4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  RDBGC4_SELECT
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #4 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The RDBGC4_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM56218_A0_RDBGC4_SELECTr 0x0e780024

#define BCM56218_A0_RDBGC4_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program RDBGC4_SELECT.
 *
 */
typedef union BCM56218_A0_RDBGC4_SELECTr_s {
	uint32_t v[1];
	uint32_t rdbgc4_select[1];
	uint32_t _rdbgc4_select;
} BCM56218_A0_RDBGC4_SELECTr_t;

#define BCM56218_A0_RDBGC4_SELECTr_CLR(r) (r).rdbgc4_select[0] = 0
#define BCM56218_A0_RDBGC4_SELECTr_SET(r,d) (r).rdbgc4_select[0] = d
#define BCM56218_A0_RDBGC4_SELECTr_GET(r) (r).rdbgc4_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_RDBGC4_SELECTr_BITMAPf_GET(r) (((r).rdbgc4_select[0]) & 0x3fffffff)
#define BCM56218_A0_RDBGC4_SELECTr_BITMAPf_SET(r,f) (r).rdbgc4_select[0]=(((r).rdbgc4_select[0] & ~((uint32_t)0x3fffffff)) | (((uint32_t)f) & 0x3fffffff))

/*
 * These macros can be used to access RDBGC4_SELECT.
 *
 */
#define BCM56218_A0_READ_RDBGC4_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_RDBGC4_SELECTr,(r._rdbgc4_select))
#define BCM56218_A0_WRITE_RDBGC4_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_RDBGC4_SELECTr,&(r._rdbgc4_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC4_SELECTr BCM56218_A0_RDBGC4_SELECTr
#define RDBGC4_SELECTr_SIZE BCM56218_A0_RDBGC4_SELECTr_SIZE
typedef BCM56218_A0_RDBGC4_SELECTr_t RDBGC4_SELECTr_t;
#define RDBGC4_SELECTr_CLR BCM56218_A0_RDBGC4_SELECTr_CLR
#define RDBGC4_SELECTr_SET BCM56218_A0_RDBGC4_SELECTr_SET
#define RDBGC4_SELECTr_GET BCM56218_A0_RDBGC4_SELECTr_GET
#define RDBGC4_SELECTr_BITMAPf_GET BCM56218_A0_RDBGC4_SELECTr_BITMAPf_GET
#define RDBGC4_SELECTr_BITMAPf_SET BCM56218_A0_RDBGC4_SELECTr_BITMAPf_SET
#define READ_RDBGC4_SELECTr BCM56218_A0_READ_RDBGC4_SELECTr
#define WRITE_RDBGC4_SELECTr BCM56218_A0_WRITE_RDBGC4_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_RDBGC4_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  RDBGC5
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #5
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_RDBGC5r 0x0e700010

#define BCM56218_A0_RDBGC5r_SIZE 4

/*
 * This structure should be used to declare and program RDBGC5.
 *
 */
typedef union BCM56218_A0_RDBGC5r_s {
	uint32_t v[1];
	uint32_t rdbgc5[1];
	uint32_t _rdbgc5;
} BCM56218_A0_RDBGC5r_t;

#define BCM56218_A0_RDBGC5r_CLR(r) (r).rdbgc5[0] = 0
#define BCM56218_A0_RDBGC5r_SET(r,d) (r).rdbgc5[0] = d
#define BCM56218_A0_RDBGC5r_GET(r) (r).rdbgc5[0]


/*
 * These macros can be used to access RDBGC5.
 *
 */
#define BCM56218_A0_READ_RDBGC5r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_RDBGC5r,(r._rdbgc5))
#define BCM56218_A0_WRITE_RDBGC5r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_RDBGC5r,&(r._rdbgc5))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC5r BCM56218_A0_RDBGC5r
#define RDBGC5r_SIZE BCM56218_A0_RDBGC5r_SIZE
typedef BCM56218_A0_RDBGC5r_t RDBGC5r_t;
#define RDBGC5r_CLR BCM56218_A0_RDBGC5r_CLR
#define RDBGC5r_SET BCM56218_A0_RDBGC5r_SET
#define RDBGC5r_GET BCM56218_A0_RDBGC5r_GET
#define READ_RDBGC5r BCM56218_A0_READ_RDBGC5r
#define WRITE_RDBGC5r BCM56218_A0_WRITE_RDBGC5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_RDBGC5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  RDBGC5_SELECT
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #5 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The RDBGC5_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM56218_A0_RDBGC5_SELECTr 0x0e780025

#define BCM56218_A0_RDBGC5_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program RDBGC5_SELECT.
 *
 */
typedef union BCM56218_A0_RDBGC5_SELECTr_s {
	uint32_t v[1];
	uint32_t rdbgc5_select[1];
	uint32_t _rdbgc5_select;
} BCM56218_A0_RDBGC5_SELECTr_t;

#define BCM56218_A0_RDBGC5_SELECTr_CLR(r) (r).rdbgc5_select[0] = 0
#define BCM56218_A0_RDBGC5_SELECTr_SET(r,d) (r).rdbgc5_select[0] = d
#define BCM56218_A0_RDBGC5_SELECTr_GET(r) (r).rdbgc5_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_RDBGC5_SELECTr_BITMAPf_GET(r) (((r).rdbgc5_select[0]) & 0x3fffffff)
#define BCM56218_A0_RDBGC5_SELECTr_BITMAPf_SET(r,f) (r).rdbgc5_select[0]=(((r).rdbgc5_select[0] & ~((uint32_t)0x3fffffff)) | (((uint32_t)f) & 0x3fffffff))

/*
 * These macros can be used to access RDBGC5_SELECT.
 *
 */
#define BCM56218_A0_READ_RDBGC5_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_RDBGC5_SELECTr,(r._rdbgc5_select))
#define BCM56218_A0_WRITE_RDBGC5_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_RDBGC5_SELECTr,&(r._rdbgc5_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC5_SELECTr BCM56218_A0_RDBGC5_SELECTr
#define RDBGC5_SELECTr_SIZE BCM56218_A0_RDBGC5_SELECTr_SIZE
typedef BCM56218_A0_RDBGC5_SELECTr_t RDBGC5_SELECTr_t;
#define RDBGC5_SELECTr_CLR BCM56218_A0_RDBGC5_SELECTr_CLR
#define RDBGC5_SELECTr_SET BCM56218_A0_RDBGC5_SELECTr_SET
#define RDBGC5_SELECTr_GET BCM56218_A0_RDBGC5_SELECTr_GET
#define RDBGC5_SELECTr_BITMAPf_GET BCM56218_A0_RDBGC5_SELECTr_BITMAPf_GET
#define RDBGC5_SELECTr_BITMAPf_SET BCM56218_A0_RDBGC5_SELECTr_BITMAPf_SET
#define READ_RDBGC5_SELECTr BCM56218_A0_READ_RDBGC5_SELECTr
#define WRITE_RDBGC5_SELECTr BCM56218_A0_WRITE_RDBGC5_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_RDBGC5_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  RDBGC6
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #6
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_RDBGC6r 0x0e700011

#define BCM56218_A0_RDBGC6r_SIZE 4

/*
 * This structure should be used to declare and program RDBGC6.
 *
 */
typedef union BCM56218_A0_RDBGC6r_s {
	uint32_t v[1];
	uint32_t rdbgc6[1];
	uint32_t _rdbgc6;
} BCM56218_A0_RDBGC6r_t;

#define BCM56218_A0_RDBGC6r_CLR(r) (r).rdbgc6[0] = 0
#define BCM56218_A0_RDBGC6r_SET(r,d) (r).rdbgc6[0] = d
#define BCM56218_A0_RDBGC6r_GET(r) (r).rdbgc6[0]


/*
 * These macros can be used to access RDBGC6.
 *
 */
#define BCM56218_A0_READ_RDBGC6r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_RDBGC6r,(r._rdbgc6))
#define BCM56218_A0_WRITE_RDBGC6r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_RDBGC6r,&(r._rdbgc6))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC6r BCM56218_A0_RDBGC6r
#define RDBGC6r_SIZE BCM56218_A0_RDBGC6r_SIZE
typedef BCM56218_A0_RDBGC6r_t RDBGC6r_t;
#define RDBGC6r_CLR BCM56218_A0_RDBGC6r_CLR
#define RDBGC6r_SET BCM56218_A0_RDBGC6r_SET
#define RDBGC6r_GET BCM56218_A0_RDBGC6r_GET
#define READ_RDBGC6r BCM56218_A0_READ_RDBGC6r
#define WRITE_RDBGC6r BCM56218_A0_WRITE_RDBGC6r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_RDBGC6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  RDBGC6_SELECT
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #6 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The RDBGC6_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM56218_A0_RDBGC6_SELECTr 0x0e780026

#define BCM56218_A0_RDBGC6_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program RDBGC6_SELECT.
 *
 */
typedef union BCM56218_A0_RDBGC6_SELECTr_s {
	uint32_t v[1];
	uint32_t rdbgc6_select[1];
	uint32_t _rdbgc6_select;
} BCM56218_A0_RDBGC6_SELECTr_t;

#define BCM56218_A0_RDBGC6_SELECTr_CLR(r) (r).rdbgc6_select[0] = 0
#define BCM56218_A0_RDBGC6_SELECTr_SET(r,d) (r).rdbgc6_select[0] = d
#define BCM56218_A0_RDBGC6_SELECTr_GET(r) (r).rdbgc6_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_RDBGC6_SELECTr_BITMAPf_GET(r) (((r).rdbgc6_select[0]) & 0x3fffffff)
#define BCM56218_A0_RDBGC6_SELECTr_BITMAPf_SET(r,f) (r).rdbgc6_select[0]=(((r).rdbgc6_select[0] & ~((uint32_t)0x3fffffff)) | (((uint32_t)f) & 0x3fffffff))

/*
 * These macros can be used to access RDBGC6_SELECT.
 *
 */
#define BCM56218_A0_READ_RDBGC6_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_RDBGC6_SELECTr,(r._rdbgc6_select))
#define BCM56218_A0_WRITE_RDBGC6_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_RDBGC6_SELECTr,&(r._rdbgc6_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC6_SELECTr BCM56218_A0_RDBGC6_SELECTr
#define RDBGC6_SELECTr_SIZE BCM56218_A0_RDBGC6_SELECTr_SIZE
typedef BCM56218_A0_RDBGC6_SELECTr_t RDBGC6_SELECTr_t;
#define RDBGC6_SELECTr_CLR BCM56218_A0_RDBGC6_SELECTr_CLR
#define RDBGC6_SELECTr_SET BCM56218_A0_RDBGC6_SELECTr_SET
#define RDBGC6_SELECTr_GET BCM56218_A0_RDBGC6_SELECTr_GET
#define RDBGC6_SELECTr_BITMAPf_GET BCM56218_A0_RDBGC6_SELECTr_BITMAPf_GET
#define RDBGC6_SELECTr_BITMAPf_SET BCM56218_A0_RDBGC6_SELECTr_BITMAPf_SET
#define READ_RDBGC6_SELECTr BCM56218_A0_READ_RDBGC6_SELECTr
#define WRITE_RDBGC6_SELECTr BCM56218_A0_WRITE_RDBGC6_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_RDBGC6_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  RDBGC7
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #7
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_RDBGC7r 0x0e700012

#define BCM56218_A0_RDBGC7r_SIZE 4

/*
 * This structure should be used to declare and program RDBGC7.
 *
 */
typedef union BCM56218_A0_RDBGC7r_s {
	uint32_t v[1];
	uint32_t rdbgc7[1];
	uint32_t _rdbgc7;
} BCM56218_A0_RDBGC7r_t;

#define BCM56218_A0_RDBGC7r_CLR(r) (r).rdbgc7[0] = 0
#define BCM56218_A0_RDBGC7r_SET(r,d) (r).rdbgc7[0] = d
#define BCM56218_A0_RDBGC7r_GET(r) (r).rdbgc7[0]


/*
 * These macros can be used to access RDBGC7.
 *
 */
#define BCM56218_A0_READ_RDBGC7r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_RDBGC7r,(r._rdbgc7))
#define BCM56218_A0_WRITE_RDBGC7r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_RDBGC7r,&(r._rdbgc7))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC7r BCM56218_A0_RDBGC7r
#define RDBGC7r_SIZE BCM56218_A0_RDBGC7r_SIZE
typedef BCM56218_A0_RDBGC7r_t RDBGC7r_t;
#define RDBGC7r_CLR BCM56218_A0_RDBGC7r_CLR
#define RDBGC7r_SET BCM56218_A0_RDBGC7r_SET
#define RDBGC7r_GET BCM56218_A0_RDBGC7r_GET
#define READ_RDBGC7r BCM56218_A0_READ_RDBGC7r
#define WRITE_RDBGC7r BCM56218_A0_WRITE_RDBGC7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_RDBGC7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  RDBGC7_SELECT
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #7 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The RDBGC7_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM56218_A0_RDBGC7_SELECTr 0x0e780027

#define BCM56218_A0_RDBGC7_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program RDBGC7_SELECT.
 *
 */
typedef union BCM56218_A0_RDBGC7_SELECTr_s {
	uint32_t v[1];
	uint32_t rdbgc7_select[1];
	uint32_t _rdbgc7_select;
} BCM56218_A0_RDBGC7_SELECTr_t;

#define BCM56218_A0_RDBGC7_SELECTr_CLR(r) (r).rdbgc7_select[0] = 0
#define BCM56218_A0_RDBGC7_SELECTr_SET(r,d) (r).rdbgc7_select[0] = d
#define BCM56218_A0_RDBGC7_SELECTr_GET(r) (r).rdbgc7_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_RDBGC7_SELECTr_BITMAPf_GET(r) (((r).rdbgc7_select[0]) & 0x3fffffff)
#define BCM56218_A0_RDBGC7_SELECTr_BITMAPf_SET(r,f) (r).rdbgc7_select[0]=(((r).rdbgc7_select[0] & ~((uint32_t)0x3fffffff)) | (((uint32_t)f) & 0x3fffffff))

/*
 * These macros can be used to access RDBGC7_SELECT.
 *
 */
#define BCM56218_A0_READ_RDBGC7_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_RDBGC7_SELECTr,(r._rdbgc7_select))
#define BCM56218_A0_WRITE_RDBGC7_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_RDBGC7_SELECTr,&(r._rdbgc7_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC7_SELECTr BCM56218_A0_RDBGC7_SELECTr
#define RDBGC7_SELECTr_SIZE BCM56218_A0_RDBGC7_SELECTr_SIZE
typedef BCM56218_A0_RDBGC7_SELECTr_t RDBGC7_SELECTr_t;
#define RDBGC7_SELECTr_CLR BCM56218_A0_RDBGC7_SELECTr_CLR
#define RDBGC7_SELECTr_SET BCM56218_A0_RDBGC7_SELECTr_SET
#define RDBGC7_SELECTr_GET BCM56218_A0_RDBGC7_SELECTr_GET
#define RDBGC7_SELECTr_BITMAPf_GET BCM56218_A0_RDBGC7_SELECTr_BITMAPf_GET
#define RDBGC7_SELECTr_BITMAPf_SET BCM56218_A0_RDBGC7_SELECTr_BITMAPf_SET
#define READ_RDBGC7_SELECTr BCM56218_A0_READ_RDBGC7_SELECTr
#define WRITE_RDBGC7_SELECTr BCM56218_A0_WRITE_RDBGC7_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_RDBGC7_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  RDBGC8
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #8
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_RDBGC8r 0x0e700013

#define BCM56218_A0_RDBGC8r_SIZE 4

/*
 * This structure should be used to declare and program RDBGC8.
 *
 */
typedef union BCM56218_A0_RDBGC8r_s {
	uint32_t v[1];
	uint32_t rdbgc8[1];
	uint32_t _rdbgc8;
} BCM56218_A0_RDBGC8r_t;

#define BCM56218_A0_RDBGC8r_CLR(r) (r).rdbgc8[0] = 0
#define BCM56218_A0_RDBGC8r_SET(r,d) (r).rdbgc8[0] = d
#define BCM56218_A0_RDBGC8r_GET(r) (r).rdbgc8[0]


/*
 * These macros can be used to access RDBGC8.
 *
 */
#define BCM56218_A0_READ_RDBGC8r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_RDBGC8r,(r._rdbgc8))
#define BCM56218_A0_WRITE_RDBGC8r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_RDBGC8r,&(r._rdbgc8))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC8r BCM56218_A0_RDBGC8r
#define RDBGC8r_SIZE BCM56218_A0_RDBGC8r_SIZE
typedef BCM56218_A0_RDBGC8r_t RDBGC8r_t;
#define RDBGC8r_CLR BCM56218_A0_RDBGC8r_CLR
#define RDBGC8r_SET BCM56218_A0_RDBGC8r_SET
#define RDBGC8r_GET BCM56218_A0_RDBGC8r_GET
#define READ_RDBGC8r BCM56218_A0_READ_RDBGC8r
#define WRITE_RDBGC8r BCM56218_A0_WRITE_RDBGC8r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_RDBGC8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  RDBGC8_SELECT
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #8 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The RDBGC8_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM56218_A0_RDBGC8_SELECTr 0x0e780028

#define BCM56218_A0_RDBGC8_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program RDBGC8_SELECT.
 *
 */
typedef union BCM56218_A0_RDBGC8_SELECTr_s {
	uint32_t v[1];
	uint32_t rdbgc8_select[1];
	uint32_t _rdbgc8_select;
} BCM56218_A0_RDBGC8_SELECTr_t;

#define BCM56218_A0_RDBGC8_SELECTr_CLR(r) (r).rdbgc8_select[0] = 0
#define BCM56218_A0_RDBGC8_SELECTr_SET(r,d) (r).rdbgc8_select[0] = d
#define BCM56218_A0_RDBGC8_SELECTr_GET(r) (r).rdbgc8_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_RDBGC8_SELECTr_BITMAPf_GET(r) (((r).rdbgc8_select[0]) & 0x3fffffff)
#define BCM56218_A0_RDBGC8_SELECTr_BITMAPf_SET(r,f) (r).rdbgc8_select[0]=(((r).rdbgc8_select[0] & ~((uint32_t)0x3fffffff)) | (((uint32_t)f) & 0x3fffffff))

/*
 * These macros can be used to access RDBGC8_SELECT.
 *
 */
#define BCM56218_A0_READ_RDBGC8_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_RDBGC8_SELECTr,(r._rdbgc8_select))
#define BCM56218_A0_WRITE_RDBGC8_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_RDBGC8_SELECTr,&(r._rdbgc8_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC8_SELECTr BCM56218_A0_RDBGC8_SELECTr
#define RDBGC8_SELECTr_SIZE BCM56218_A0_RDBGC8_SELECTr_SIZE
typedef BCM56218_A0_RDBGC8_SELECTr_t RDBGC8_SELECTr_t;
#define RDBGC8_SELECTr_CLR BCM56218_A0_RDBGC8_SELECTr_CLR
#define RDBGC8_SELECTr_SET BCM56218_A0_RDBGC8_SELECTr_SET
#define RDBGC8_SELECTr_GET BCM56218_A0_RDBGC8_SELECTr_GET
#define RDBGC8_SELECTr_BITMAPf_GET BCM56218_A0_RDBGC8_SELECTr_BITMAPf_GET
#define RDBGC8_SELECTr_BITMAPf_SET BCM56218_A0_RDBGC8_SELECTr_BITMAPf_SET
#define READ_RDBGC8_SELECTr BCM56218_A0_READ_RDBGC8_SELECTr
#define WRITE_RDBGC8_SELECTr BCM56218_A0_WRITE_RDBGC8_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_RDBGC8_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  RDISC
 * BLOCKS:   IPIPE
 * DESC:     Receive Discard Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_RDISCr 0x0e700008

#define BCM56218_A0_RDISCr_SIZE 4

/*
 * This structure should be used to declare and program RDISC.
 *
 */
typedef union BCM56218_A0_RDISCr_s {
	uint32_t v[1];
	uint32_t rdisc[1];
	uint32_t _rdisc;
} BCM56218_A0_RDISCr_t;

#define BCM56218_A0_RDISCr_CLR(r) (r).rdisc[0] = 0
#define BCM56218_A0_RDISCr_SET(r,d) (r).rdisc[0] = d
#define BCM56218_A0_RDISCr_GET(r) (r).rdisc[0]


/*
 * These macros can be used to access RDISC.
 *
 */
#define BCM56218_A0_READ_RDISCr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_RDISCr,(r._rdisc))
#define BCM56218_A0_WRITE_RDISCr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_RDISCr,&(r._rdisc))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDISCr BCM56218_A0_RDISCr
#define RDISCr_SIZE BCM56218_A0_RDISCr_SIZE
typedef BCM56218_A0_RDISCr_t RDISCr_t;
#define RDISCr_CLR BCM56218_A0_RDISCr_CLR
#define RDISCr_SET BCM56218_A0_RDISCr_SET
#define RDISCr_GET BCM56218_A0_RDISCr_GET
#define READ_RDISCr BCM56218_A0_READ_RDISCr
#define WRITE_RDISCr BCM56218_A0_WRITE_RDISCr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_RDISCr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  REVCD
 * BLOCKS:   GPORT0
 * DESC:     Revision Info
 * SIZE:     32
 * FIELDS:
 *     REV              Revision Number
 *     MONTH            Revision Month
 *     YEAR             Revision Year
 *
 ******************************************************************************/
#define BCM56218_A0_REVCDr 0x0000010b

#define BCM56218_A0_REVCDr_SIZE 4

/*
 * This structure should be used to declare and program REVCD.
 *
 */
typedef union BCM56218_A0_REVCDr_s {
	uint32_t v[1];
	uint32_t revcd[1];
	uint32_t _revcd;
} BCM56218_A0_REVCDr_t;

#define BCM56218_A0_REVCDr_CLR(r) (r).revcd[0] = 0
#define BCM56218_A0_REVCDr_SET(r,d) (r).revcd[0] = d
#define BCM56218_A0_REVCDr_GET(r) (r).revcd[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_REVCDr_REVf_GET(r) (((r).revcd[0]) & 0xf)
#define BCM56218_A0_REVCDr_REVf_SET(r,f) (r).revcd[0]=(((r).revcd[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56218_A0_REVCDr_MONTHf_GET(r) ((((r).revcd[0]) >> 4) & 0xf)
#define BCM56218_A0_REVCDr_MONTHf_SET(r,f) (r).revcd[0]=(((r).revcd[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56218_A0_REVCDr_YEARf_GET(r) ((((r).revcd[0]) >> 8) & 0xff)
#define BCM56218_A0_REVCDr_YEARf_SET(r,f) (r).revcd[0]=(((r).revcd[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access REVCD.
 *
 */
#define BCM56218_A0_READ_REVCDr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_REVCDr,(r._revcd))
#define BCM56218_A0_WRITE_REVCDr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_REVCDr,&(r._revcd))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define REVCDr BCM56218_A0_REVCDr
#define REVCDr_SIZE BCM56218_A0_REVCDr_SIZE
typedef BCM56218_A0_REVCDr_t REVCDr_t;
#define REVCDr_CLR BCM56218_A0_REVCDr_CLR
#define REVCDr_SET BCM56218_A0_REVCDr_SET
#define REVCDr_GET BCM56218_A0_REVCDr_GET
#define REVCDr_REVf_GET BCM56218_A0_REVCDr_REVf_GET
#define REVCDr_REVf_SET BCM56218_A0_REVCDr_REVf_SET
#define REVCDr_MONTHf_GET BCM56218_A0_REVCDr_MONTHf_GET
#define REVCDr_MONTHf_SET BCM56218_A0_REVCDr_MONTHf_SET
#define REVCDr_YEARf_GET BCM56218_A0_REVCDr_YEARf_GET
#define REVCDr_YEARf_SET BCM56218_A0_REVCDr_YEARf_SET
#define READ_REVCDr BCM56218_A0_READ_REVCDr
#define WRITE_REVCDr BCM56218_A0_WRITE_REVCDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_REVCDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  RIPC4
 * BLOCKS:   IPIPE
 * DESC:     Receive IPv4 L3 Unicast Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_RIPC4r 0x0e700001

#define BCM56218_A0_RIPC4r_SIZE 4

/*
 * This structure should be used to declare and program RIPC4.
 *
 */
typedef union BCM56218_A0_RIPC4r_s {
	uint32_t v[1];
	uint32_t ripc4[1];
	uint32_t _ripc4;
} BCM56218_A0_RIPC4r_t;

#define BCM56218_A0_RIPC4r_CLR(r) (r).ripc4[0] = 0
#define BCM56218_A0_RIPC4r_SET(r,d) (r).ripc4[0] = d
#define BCM56218_A0_RIPC4r_GET(r) (r).ripc4[0]


/*
 * These macros can be used to access RIPC4.
 *
 */
#define BCM56218_A0_READ_RIPC4r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_RIPC4r,(r._ripc4))
#define BCM56218_A0_WRITE_RIPC4r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_RIPC4r,&(r._ripc4))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RIPC4r BCM56218_A0_RIPC4r
#define RIPC4r_SIZE BCM56218_A0_RIPC4r_SIZE
typedef BCM56218_A0_RIPC4r_t RIPC4r_t;
#define RIPC4r_CLR BCM56218_A0_RIPC4r_CLR
#define RIPC4r_SET BCM56218_A0_RIPC4r_SET
#define RIPC4r_GET BCM56218_A0_RIPC4r_GET
#define READ_RIPC4r BCM56218_A0_READ_RIPC4r
#define WRITE_RIPC4r BCM56218_A0_WRITE_RIPC4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_RIPC4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  RIPC6
 * BLOCKS:   IPIPE
 * DESC:     Receive IPv6 L3 Unicast Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_RIPC6r 0x0e700005

#define BCM56218_A0_RIPC6r_SIZE 4

/*
 * This structure should be used to declare and program RIPC6.
 *
 */
typedef union BCM56218_A0_RIPC6r_s {
	uint32_t v[1];
	uint32_t ripc6[1];
	uint32_t _ripc6;
} BCM56218_A0_RIPC6r_t;

#define BCM56218_A0_RIPC6r_CLR(r) (r).ripc6[0] = 0
#define BCM56218_A0_RIPC6r_SET(r,d) (r).ripc6[0] = d
#define BCM56218_A0_RIPC6r_GET(r) (r).ripc6[0]


/*
 * These macros can be used to access RIPC6.
 *
 */
#define BCM56218_A0_READ_RIPC6r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_RIPC6r,(r._ripc6))
#define BCM56218_A0_WRITE_RIPC6r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_RIPC6r,&(r._ripc6))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RIPC6r BCM56218_A0_RIPC6r
#define RIPC6r_SIZE BCM56218_A0_RIPC6r_SIZE
typedef BCM56218_A0_RIPC6r_t RIPC6r_t;
#define RIPC6r_CLR BCM56218_A0_RIPC6r_CLR
#define RIPC6r_SET BCM56218_A0_RIPC6r_SET
#define RIPC6r_GET BCM56218_A0_RIPC6r_GET
#define READ_RIPC6r BCM56218_A0_READ_RIPC6r
#define WRITE_RIPC6r BCM56218_A0_WRITE_RIPC6r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_RIPC6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  RIPD4
 * BLOCKS:   IPIPE
 * DESC:     Receive IPv4 L3 Discard Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_RIPD4r 0x0e700000

#define BCM56218_A0_RIPD4r_SIZE 4

/*
 * This structure should be used to declare and program RIPD4.
 *
 */
typedef union BCM56218_A0_RIPD4r_s {
	uint32_t v[1];
	uint32_t ripd4[1];
	uint32_t _ripd4;
} BCM56218_A0_RIPD4r_t;

#define BCM56218_A0_RIPD4r_CLR(r) (r).ripd4[0] = 0
#define BCM56218_A0_RIPD4r_SET(r,d) (r).ripd4[0] = d
#define BCM56218_A0_RIPD4r_GET(r) (r).ripd4[0]


/*
 * These macros can be used to access RIPD4.
 *
 */
#define BCM56218_A0_READ_RIPD4r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_RIPD4r,(r._ripd4))
#define BCM56218_A0_WRITE_RIPD4r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_RIPD4r,&(r._ripd4))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RIPD4r BCM56218_A0_RIPD4r
#define RIPD4r_SIZE BCM56218_A0_RIPD4r_SIZE
typedef BCM56218_A0_RIPD4r_t RIPD4r_t;
#define RIPD4r_CLR BCM56218_A0_RIPD4r_CLR
#define RIPD4r_SET BCM56218_A0_RIPD4r_SET
#define RIPD4r_GET BCM56218_A0_RIPD4r_GET
#define READ_RIPD4r BCM56218_A0_READ_RIPD4r
#define WRITE_RIPD4r BCM56218_A0_WRITE_RIPD4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_RIPD4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  RIPD6
 * BLOCKS:   IPIPE
 * DESC:     Receive IPv6 L3 Discard Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_RIPD6r 0x0e700004

#define BCM56218_A0_RIPD6r_SIZE 4

/*
 * This structure should be used to declare and program RIPD6.
 *
 */
typedef union BCM56218_A0_RIPD6r_s {
	uint32_t v[1];
	uint32_t ripd6[1];
	uint32_t _ripd6;
} BCM56218_A0_RIPD6r_t;

#define BCM56218_A0_RIPD6r_CLR(r) (r).ripd6[0] = 0
#define BCM56218_A0_RIPD6r_SET(r,d) (r).ripd6[0] = d
#define BCM56218_A0_RIPD6r_GET(r) (r).ripd6[0]


/*
 * These macros can be used to access RIPD6.
 *
 */
#define BCM56218_A0_READ_RIPD6r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_RIPD6r,(r._ripd6))
#define BCM56218_A0_WRITE_RIPD6r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_RIPD6r,&(r._ripd6))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RIPD6r BCM56218_A0_RIPD6r
#define RIPD6r_SIZE BCM56218_A0_RIPD6r_SIZE
typedef BCM56218_A0_RIPD6r_t RIPD6r_t;
#define RIPD6r_CLR BCM56218_A0_RIPD6r_CLR
#define RIPD6r_SET BCM56218_A0_RIPD6r_SET
#define RIPD6r_GET BCM56218_A0_RIPD6r_GET
#define READ_RIPD6r BCM56218_A0_READ_RIPD6r
#define WRITE_RIPD6r BCM56218_A0_WRITE_RIPD6r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_RIPD6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  RIPHE4
 * BLOCKS:   IPIPE
 * DESC:     Receive IPv4 L3 IP Header Error Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_RIPHE4r 0x0e700002

#define BCM56218_A0_RIPHE4r_SIZE 4

/*
 * This structure should be used to declare and program RIPHE4.
 *
 */
typedef union BCM56218_A0_RIPHE4r_s {
	uint32_t v[1];
	uint32_t riphe4[1];
	uint32_t _riphe4;
} BCM56218_A0_RIPHE4r_t;

#define BCM56218_A0_RIPHE4r_CLR(r) (r).riphe4[0] = 0
#define BCM56218_A0_RIPHE4r_SET(r,d) (r).riphe4[0] = d
#define BCM56218_A0_RIPHE4r_GET(r) (r).riphe4[0]


/*
 * These macros can be used to access RIPHE4.
 *
 */
#define BCM56218_A0_READ_RIPHE4r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_RIPHE4r,(r._riphe4))
#define BCM56218_A0_WRITE_RIPHE4r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_RIPHE4r,&(r._riphe4))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RIPHE4r BCM56218_A0_RIPHE4r
#define RIPHE4r_SIZE BCM56218_A0_RIPHE4r_SIZE
typedef BCM56218_A0_RIPHE4r_t RIPHE4r_t;
#define RIPHE4r_CLR BCM56218_A0_RIPHE4r_CLR
#define RIPHE4r_SET BCM56218_A0_RIPHE4r_SET
#define RIPHE4r_GET BCM56218_A0_RIPHE4r_GET
#define READ_RIPHE4r BCM56218_A0_READ_RIPHE4r
#define WRITE_RIPHE4r BCM56218_A0_WRITE_RIPHE4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_RIPHE4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  RIPHE6
 * BLOCKS:   IPIPE
 * DESC:     Receive IPv6 L3 IP Header Error Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_RIPHE6r 0x0e700006

#define BCM56218_A0_RIPHE6r_SIZE 4

/*
 * This structure should be used to declare and program RIPHE6.
 *
 */
typedef union BCM56218_A0_RIPHE6r_s {
	uint32_t v[1];
	uint32_t riphe6[1];
	uint32_t _riphe6;
} BCM56218_A0_RIPHE6r_t;

#define BCM56218_A0_RIPHE6r_CLR(r) (r).riphe6[0] = 0
#define BCM56218_A0_RIPHE6r_SET(r,d) (r).riphe6[0] = d
#define BCM56218_A0_RIPHE6r_GET(r) (r).riphe6[0]


/*
 * These macros can be used to access RIPHE6.
 *
 */
#define BCM56218_A0_READ_RIPHE6r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_RIPHE6r,(r._riphe6))
#define BCM56218_A0_WRITE_RIPHE6r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_RIPHE6r,&(r._riphe6))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RIPHE6r BCM56218_A0_RIPHE6r
#define RIPHE6r_SIZE BCM56218_A0_RIPHE6r_SIZE
typedef BCM56218_A0_RIPHE6r_t RIPHE6r_t;
#define RIPHE6r_CLR BCM56218_A0_RIPHE6r_CLR
#define RIPHE6r_SET BCM56218_A0_RIPHE6r_SET
#define RIPHE6r_GET BCM56218_A0_RIPHE6r_GET
#define READ_RIPHE6r BCM56218_A0_READ_RIPHE6r
#define WRITE_RIPHE6r BCM56218_A0_WRITE_RIPHE6r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_RIPHE6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  RPORTD
 * BLOCKS:   IPIPE
 * DESC:     PortInDiscard Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_RPORTDr 0x0e70000a

#define BCM56218_A0_RPORTDr_SIZE 4

/*
 * This structure should be used to declare and program RPORTD.
 *
 */
typedef union BCM56218_A0_RPORTDr_s {
	uint32_t v[1];
	uint32_t rportd[1];
	uint32_t _rportd;
} BCM56218_A0_RPORTDr_t;

#define BCM56218_A0_RPORTDr_CLR(r) (r).rportd[0] = 0
#define BCM56218_A0_RPORTDr_SET(r,d) (r).rportd[0] = d
#define BCM56218_A0_RPORTDr_GET(r) (r).rportd[0]


/*
 * These macros can be used to access RPORTD.
 *
 */
#define BCM56218_A0_READ_RPORTDr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_RPORTDr,(r._rportd))
#define BCM56218_A0_WRITE_RPORTDr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_RPORTDr,&(r._rportd))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RPORTDr BCM56218_A0_RPORTDr
#define RPORTDr_SIZE BCM56218_A0_RPORTDr_SIZE
typedef BCM56218_A0_RPORTDr_t RPORTDr_t;
#define RPORTDr_CLR BCM56218_A0_RPORTDr_CLR
#define RPORTDr_SET BCM56218_A0_RPORTDr_SET
#define RPORTDr_GET BCM56218_A0_RPORTDr_GET
#define READ_RPORTDr BCM56218_A0_READ_RPORTDr
#define WRITE_RPORTDr BCM56218_A0_WRITE_RPORTDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_RPORTDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  RRBYT
 * BLOCKS:   GPORT0
 * DESC:     Receive Runt Byte Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_RRBYTr 0x0000000e

#define BCM56218_A0_RRBYTr_SIZE 4

/*
 * This structure should be used to declare and program RRBYT.
 *
 */
typedef union BCM56218_A0_RRBYTr_s {
	uint32_t v[1];
	uint32_t rrbyt[1];
	uint32_t _rrbyt;
} BCM56218_A0_RRBYTr_t;

#define BCM56218_A0_RRBYTr_CLR(r) (r).rrbyt[0] = 0
#define BCM56218_A0_RRBYTr_SET(r,d) (r).rrbyt[0] = d
#define BCM56218_A0_RRBYTr_GET(r) (r).rrbyt[0]


/*
 * These macros can be used to access RRBYT.
 *
 */
#define BCM56218_A0_READ_RRBYTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_RRBYTr,(r._rrbyt))
#define BCM56218_A0_WRITE_RRBYTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_RRBYTr,&(r._rrbyt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RRBYTr BCM56218_A0_RRBYTr
#define RRBYTr_SIZE BCM56218_A0_RRBYTr_SIZE
typedef BCM56218_A0_RRBYTr_t RRBYTr_t;
#define RRBYTr_CLR BCM56218_A0_RRBYTr_CLR
#define RRBYTr_SET BCM56218_A0_RRBYTr_SET
#define RRBYTr_GET BCM56218_A0_RRBYTr_GET
#define READ_RRBYTr BCM56218_A0_READ_RRBYTr
#define WRITE_RRBYTr BCM56218_A0_WRITE_RRBYTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_RRBYTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  RRPKT
 * BLOCKS:   GPORT0
 * DESC:     Receive RUNT Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_RRPKTr 0x0000000b

#define BCM56218_A0_RRPKTr_SIZE 4

/*
 * This structure should be used to declare and program RRPKT.
 *
 */
typedef union BCM56218_A0_RRPKTr_s {
	uint32_t v[1];
	uint32_t rrpkt[1];
	uint32_t _rrpkt;
} BCM56218_A0_RRPKTr_t;

#define BCM56218_A0_RRPKTr_CLR(r) (r).rrpkt[0] = 0
#define BCM56218_A0_RRPKTr_SET(r,d) (r).rrpkt[0] = d
#define BCM56218_A0_RRPKTr_GET(r) (r).rrpkt[0]


/*
 * These macros can be used to access RRPKT.
 *
 */
#define BCM56218_A0_READ_RRPKTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_RRPKTr,(r._rrpkt))
#define BCM56218_A0_WRITE_RRPKTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_RRPKTr,&(r._rrpkt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RRPKTr BCM56218_A0_RRPKTr
#define RRPKTr_SIZE BCM56218_A0_RRPKTr_SIZE
typedef BCM56218_A0_RRPKTr_t RRPKTr_t;
#define RRPKTr_CLR BCM56218_A0_RRPKTr_CLR
#define RRPKTr_SET BCM56218_A0_RRPKTr_SET
#define RRPKTr_GET BCM56218_A0_RRPKTr_GET
#define READ_RRPKTr BCM56218_A0_READ_RRPKTr
#define WRITE_RRPKTr BCM56218_A0_WRITE_RRPKTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_RRPKTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  RSV_READ
 * BLOCKS:   GPORT0
 * DESC:     MAC RSV (Receive Status Vector) debug register
 * SIZE:     32
 * FIELDS:
 *     ENABLE           Debug register, this provides a copy of the most recent RSV from the MAC to the core.
 *
 ******************************************************************************/
#define BCM56218_A0_RSV_READr 0x00000304

#define BCM56218_A0_RSV_READr_SIZE 4

/*
 * This structure should be used to declare and program RSV_READ.
 *
 */
typedef union BCM56218_A0_RSV_READr_s {
	uint32_t v[1];
	uint32_t rsv_read[1];
	uint32_t _rsv_read;
} BCM56218_A0_RSV_READr_t;

#define BCM56218_A0_RSV_READr_CLR(r) (r).rsv_read[0] = 0
#define BCM56218_A0_RSV_READr_SET(r,d) (r).rsv_read[0] = d
#define BCM56218_A0_RSV_READr_GET(r) (r).rsv_read[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_RSV_READr_ENABLEf_GET(r) (((r).rsv_read[0]) & 0x7fffffff)
#define BCM56218_A0_RSV_READr_ENABLEf_SET(r,f) (r).rsv_read[0]=(((r).rsv_read[0] & ~((uint32_t)0x7fffffff)) | (((uint32_t)f) & 0x7fffffff))

/*
 * These macros can be used to access RSV_READ.
 *
 */
#define BCM56218_A0_READ_RSV_READr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_RSV_READr,(r._rsv_read))
#define BCM56218_A0_WRITE_RSV_READr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_RSV_READr,&(r._rsv_read))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RSV_READr BCM56218_A0_RSV_READr
#define RSV_READr_SIZE BCM56218_A0_RSV_READr_SIZE
typedef BCM56218_A0_RSV_READr_t RSV_READr_t;
#define RSV_READr_CLR BCM56218_A0_RSV_READr_CLR
#define RSV_READr_SET BCM56218_A0_RSV_READr_SET
#define RSV_READr_GET BCM56218_A0_RSV_READr_GET
#define RSV_READr_ENABLEf_GET BCM56218_A0_RSV_READr_ENABLEf_GET
#define RSV_READr_ENABLEf_SET BCM56218_A0_RSV_READr_ENABLEf_SET
#define READ_RSV_READr BCM56218_A0_READ_RSV_READr
#define WRITE_RSV_READr BCM56218_A0_WRITE_RSV_READr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_RSV_READr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  RUC
 * BLOCKS:   IPIPE
 * DESC:     Receive Unicast Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_RUCr 0x0e700009

#define BCM56218_A0_RUCr_SIZE 4

/*
 * This structure should be used to declare and program RUC.
 *
 */
typedef union BCM56218_A0_RUCr_s {
	uint32_t v[1];
	uint32_t ruc[1];
	uint32_t _ruc;
} BCM56218_A0_RUCr_t;

#define BCM56218_A0_RUCr_CLR(r) (r).ruc[0] = 0
#define BCM56218_A0_RUCr_SET(r,d) (r).ruc[0] = d
#define BCM56218_A0_RUCr_GET(r) (r).ruc[0]


/*
 * These macros can be used to access RUC.
 *
 */
#define BCM56218_A0_READ_RUCr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_RUCr,(r._ruc))
#define BCM56218_A0_WRITE_RUCr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_RUCr,&(r._ruc))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RUCr BCM56218_A0_RUCr
#define RUCr_SIZE BCM56218_A0_RUCr_SIZE
typedef BCM56218_A0_RUCr_t RUCr_t;
#define RUCr_CLR BCM56218_A0_RUCr_CLR
#define RUCr_SET BCM56218_A0_RUCr_SET
#define RUCr_GET BCM56218_A0_RUCr_GET
#define READ_RUCr BCM56218_A0_READ_RUCr
#define WRITE_RUCr BCM56218_A0_WRITE_RUCr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_RUCr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * SWFORMAT:  RX_DCB
 * BLOCKS:  
 * DESC:     Packet DMA descriptor.
 * SIZE:     352
 * FIELDS:
 *     BYTES_TRANSFERRED Number of bytes transferred
 *     END_BIT          Descriptor is for last (or only) packet fragment.
 *     START_BIT        Descriptor is for first (or only) packet fragment.
 *     ERROR            Internal RX error encountered.
 *     DONE             Descriptor done.
 *     DECAP_IPTUNNEL   IP tunnel encapsulation was stripped from packet.
 *     PKT_WAS_UNTAGGED Packet ingressed untagged on an Ethernet (non-HiGig) port.
 *     OUTER_VID        Outer VLAN ID of the packet.
 *     OUTER_CFI        Outer CFI assigned to the packet.
 *     OUTER_PRI        Outer priority assigned to the packet.
 *     DSCP             New DCSP value computed by the switch chip.
 *     SRC_PORT         Source port number.
 *     NHOP_INDEX       Next Hop index.
 *     MATCHED_RULE     Matched Field Processor rule.
 *     REASON           CPU opcode, reason the packet was copied to the CPU. Bit 25 - MAC limit counters have exceededBit 24 - Parity error in L2/L3 tablesBit 23 - HiGig Header error  Bit 22 - L3 MTU check fail to CPU  Bit 21 - Parity error on IP tables  Bit 20 - L3 slow path CPU processed packets  Bit 19 - ICMP redirect copy to CPU  Bit 18 - L2 MTU check fail to CPU  Bit 17 - Tunnel error trap to CPU  Bit 16 - Martian address trap to CPU  Bit 15 - DOS attack trap to CPU  Bit 14 - Protocol packet  Bit 13 - L3 header  - IP options, TTL=0, !IPv4 etc."  Bit 12 - FP action - copy to CPU  Bit 11 - IPMC miss - {SIP, DIP} miss or DIP miss"  Bit 10 - Multicast miss   Bit 9  - Station movement - L3  Bit 8  - L3 DIP miss  Bit 7  - L3 SIP miss  Bit 6  - sFlow - Dst  Bit 5  - sFlow - Src  Bit 4  - L2_table - copy to CPU  Bit 3  - Station movement - L2  Bit 2  - Destination lookup failure   Bit 1  - Source lookup failure  Bit 0  - Learning enabled in port table and SA is learnt; Unknown VLAN ID; VLAN ID = 0xfff  
 *     RESERVED_0       Unused.
 *     REGEN_CRC        Packet was modified and CRC is no longer valid.
 *     SWITCH           Switched packet (as opposed to mirrored packet.)
 *     SRC_HG           Source is HiGig.
 *     PURGE_CELL       Packet is marked for purging.
 *     PKT_AGED         Packet is aged.
 *     MTP_INDEX        Mirror-to-Port index.
 *     L3UC             Packet is a L3 unicast packet.
 *     IMIRROR          Ingress mirror packet.
 *     EMIRROR          Egress mirror packet.
 *     COS              Queue number used internally for non-CPU ports.
 *     CPU_COS          Queue number used internally for the CPU port.
 *     CHANGE_DSCP      DSCP value was changed.
 *     CELL_ERROR       Packet cell had CRC or parity error.
 *     BPDU             BPDU packet
 *     ADD_VID          VLAN ID was added.
 *     DO_NOT_CHANGE_TTL TTL was not changed by Field Processor (L3 unicast packets.)
 *     MODULE_HEADER    Valid only if the SRC_HG bit is set to 1 in this descriptor.
 *     BYTE_COUNT       Byte count for the transfer.
 *     CHAIN            Indicates that next sequential descriptor is valid.
 *     SG               Scatter/Gather - packet continues (TX) or may continue (RX) in the next DMA descriptor.
 *     RELOAD           Load next descriptor from address in ADDR field.
 *     ADDR             Physical memory address for the transfer.
 *
 ******************************************************************************/
#define BCM56218_A0_RX_DCB 0x00000000

#define BCM56218_A0_RX_DCB_SIZE 44

/*
 * This structure should be used to declare and program RX_DCB.
 *
 */
typedef union BCM56218_A0_RX_DCB_s {
	uint32_t v[11];
	uint32_t rx_dcb[11];
	uint32_t _rx_dcb;
} BCM56218_A0_RX_DCB_t;

#define BCM56218_A0_RX_DCB_CLR(r) CDK_MEMSET(&((r)._rx_dcb), 0, sizeof(BCM56218_A0_RX_DCB_t))
#define BCM56218_A0_RX_DCB_SET(r,i,d) (r).rx_dcb[i] = d
#define BCM56218_A0_RX_DCB_GET(r,i) (r).rx_dcb[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_RX_DCB_BYTES_TRANSFERREDf_GET(r) (((r).rx_dcb[10]) & 0xffff)
#define BCM56218_A0_RX_DCB_BYTES_TRANSFERREDf_SET(r,f) (r).rx_dcb[10]=(((r).rx_dcb[10] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56218_A0_RX_DCB_END_BITf_GET(r) ((((r).rx_dcb[10]) >> 16) & 0x1)
#define BCM56218_A0_RX_DCB_END_BITf_SET(r,f) (r).rx_dcb[10]=(((r).rx_dcb[10] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56218_A0_RX_DCB_START_BITf_GET(r) ((((r).rx_dcb[10]) >> 17) & 0x1)
#define BCM56218_A0_RX_DCB_START_BITf_SET(r,f) (r).rx_dcb[10]=(((r).rx_dcb[10] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_RX_DCB_ERRORf_GET(r) ((((r).rx_dcb[10]) >> 18) & 0x1)
#define BCM56218_A0_RX_DCB_ERRORf_SET(r,f) (r).rx_dcb[10]=(((r).rx_dcb[10] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_RX_DCB_DONEf_GET(r) ((((r).rx_dcb[10]) >> 31) & 0x1)
#define BCM56218_A0_RX_DCB_DONEf_SET(r,f) (r).rx_dcb[10]=(((r).rx_dcb[10] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM56218_A0_RX_DCB_DECAP_IPTUNNELf_GET(r) ((((r).rx_dcb[9]) >> 14) & 0x1)
#define BCM56218_A0_RX_DCB_DECAP_IPTUNNELf_SET(r,f) (r).rx_dcb[9]=(((r).rx_dcb[9] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM56218_A0_RX_DCB_PKT_WAS_UNTAGGEDf_GET(r) ((((r).rx_dcb[9]) >> 15) & 0x1)
#define BCM56218_A0_RX_DCB_PKT_WAS_UNTAGGEDf_SET(r,f) (r).rx_dcb[9]=(((r).rx_dcb[9] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56218_A0_RX_DCB_OUTER_VIDf_GET(r) ((((r).rx_dcb[9]) >> 16) & 0xfff)
#define BCM56218_A0_RX_DCB_OUTER_VIDf_SET(r,f) (r).rx_dcb[9]=(((r).rx_dcb[9] & ~((uint32_t)0xfff << 16)) | ((((uint32_t)f) & 0xfff) << 16))
#define BCM56218_A0_RX_DCB_OUTER_CFIf_GET(r) ((((r).rx_dcb[9]) >> 28) & 0x1)
#define BCM56218_A0_RX_DCB_OUTER_CFIf_SET(r,f) (r).rx_dcb[9]=(((r).rx_dcb[9] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM56218_A0_RX_DCB_OUTER_PRIf_GET(r) ((((r).rx_dcb[9]) >> 29) & 0x7)
#define BCM56218_A0_RX_DCB_OUTER_PRIf_SET(r,f) (r).rx_dcb[9]=(((r).rx_dcb[9] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))
#define BCM56218_A0_RX_DCB_DSCPf_GET(r) (((r).rx_dcb[8]) & 0xff)
#define BCM56218_A0_RX_DCB_DSCPf_SET(r,f) (r).rx_dcb[8]=(((r).rx_dcb[8] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56218_A0_RX_DCB_SRC_PORTf_GET(r) ((((r).rx_dcb[8]) >> 8) & 0x3f)
#define BCM56218_A0_RX_DCB_SRC_PORTf_SET(r,f) (r).rx_dcb[8]=(((r).rx_dcb[8] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define BCM56218_A0_RX_DCB_NHOP_INDEXf_GET(r) ((((r).rx_dcb[8]) >> 14) & 0xff)
#define BCM56218_A0_RX_DCB_NHOP_INDEXf_SET(r,f) (r).rx_dcb[8]=(((r).rx_dcb[8] & ~((uint32_t)0xff << 14)) | ((((uint32_t)f) & 0xff) << 14))
#define BCM56218_A0_RX_DCB_MATCHED_RULEf_GET(r) ((((r).rx_dcb[8]) >> 22) & 0x3ff)
#define BCM56218_A0_RX_DCB_MATCHED_RULEf_SET(r,f) (r).rx_dcb[8]=(((r).rx_dcb[8] & ~((uint32_t)0x3ff << 22)) | ((((uint32_t)f) & 0x3ff) << 22))
#define BCM56218_A0_RX_DCB_REASONf_GET(r) (((r).rx_dcb[7]) & 0x3ffffff)
#define BCM56218_A0_RX_DCB_REASONf_SET(r,f) (r).rx_dcb[7]=(((r).rx_dcb[7] & ~((uint32_t)0x3ffffff)) | (((uint32_t)f) & 0x3ffffff))
#define BCM56218_A0_RX_DCB_RESERVED_0f_GET(r) cdk_field32_be_get((r).rx_dcb,11,122,)
#define BCM56218_A0_RX_DCB_RESERVED_0f_SET(r,f) cdk_field32_be_set((r).rx_dcb,11,122,133,f)
#define BCM56218_A0_RX_DCB_REGEN_CRCf_GET(r) ((((r).rx_dcb[6]) >> 6) & 0x1)
#define BCM56218_A0_RX_DCB_REGEN_CRCf_SET(r,f) (r).rx_dcb[6]=(((r).rx_dcb[6] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56218_A0_RX_DCB_SWITCHf_GET(r) ((((r).rx_dcb[6]) >> 7) & 0x1)
#define BCM56218_A0_RX_DCB_SWITCHf_SET(r,f) (r).rx_dcb[6]=(((r).rx_dcb[6] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56218_A0_RX_DCB_SRC_HGf_GET(r) ((((r).rx_dcb[6]) >> 8) & 0x1)
#define BCM56218_A0_RX_DCB_SRC_HGf_SET(r,f) (r).rx_dcb[6]=(((r).rx_dcb[6] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56218_A0_RX_DCB_PURGE_CELLf_GET(r) ((((r).rx_dcb[6]) >> 9) & 0x1)
#define BCM56218_A0_RX_DCB_PURGE_CELLf_SET(r,f) (r).rx_dcb[6]=(((r).rx_dcb[6] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56218_A0_RX_DCB_PKT_AGEDf_GET(r) ((((r).rx_dcb[6]) >> 10) & 0x1)
#define BCM56218_A0_RX_DCB_PKT_AGEDf_SET(r,f) (r).rx_dcb[6]=(((r).rx_dcb[6] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56218_A0_RX_DCB_MTP_INDEXf_GET(r) ((((r).rx_dcb[6]) >> 11) & 0x7f)
#define BCM56218_A0_RX_DCB_MTP_INDEXf_SET(r,f) (r).rx_dcb[6]=(((r).rx_dcb[6] & ~((uint32_t)0x7f << 11)) | ((((uint32_t)f) & 0x7f) << 11))
#define BCM56218_A0_RX_DCB_L3UCf_GET(r) ((((r).rx_dcb[6]) >> 18) & 0x1)
#define BCM56218_A0_RX_DCB_L3UCf_SET(r,f) (r).rx_dcb[6]=(((r).rx_dcb[6] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_RX_DCB_IMIRRORf_GET(r) ((((r).rx_dcb[6]) >> 19) & 0x1)
#define BCM56218_A0_RX_DCB_IMIRRORf_SET(r,f) (r).rx_dcb[6]=(((r).rx_dcb[6] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56218_A0_RX_DCB_EMIRRORf_GET(r) ((((r).rx_dcb[6]) >> 20) & 0x1)
#define BCM56218_A0_RX_DCB_EMIRRORf_SET(r,f) (r).rx_dcb[6]=(((r).rx_dcb[6] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM56218_A0_RX_DCB_COSf_GET(r) ((((r).rx_dcb[6]) >> 21) & 0x7)
#define BCM56218_A0_RX_DCB_COSf_SET(r,f) (r).rx_dcb[6]=(((r).rx_dcb[6] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM56218_A0_RX_DCB_CPU_COSf_GET(r) ((((r).rx_dcb[6]) >> 24) & 0x7)
#define BCM56218_A0_RX_DCB_CPU_COSf_SET(r,f) (r).rx_dcb[6]=(((r).rx_dcb[6] & ~((uint32_t)0x7 << 24)) | ((((uint32_t)f) & 0x7) << 24))
#define BCM56218_A0_RX_DCB_CHANGE_DSCPf_GET(r) ((((r).rx_dcb[6]) >> 27) & 0x1)
#define BCM56218_A0_RX_DCB_CHANGE_DSCPf_SET(r,f) (r).rx_dcb[6]=(((r).rx_dcb[6] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM56218_A0_RX_DCB_CELL_ERRORf_GET(r) ((((r).rx_dcb[6]) >> 28) & 0x1)
#define BCM56218_A0_RX_DCB_CELL_ERRORf_SET(r,f) (r).rx_dcb[6]=(((r).rx_dcb[6] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM56218_A0_RX_DCB_BPDUf_GET(r) ((((r).rx_dcb[6]) >> 29) & 0x1)
#define BCM56218_A0_RX_DCB_BPDUf_SET(r,f) (r).rx_dcb[6]=(((r).rx_dcb[6] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM56218_A0_RX_DCB_ADD_VIDf_GET(r) ((((r).rx_dcb[6]) >> 30) & 0x1)
#define BCM56218_A0_RX_DCB_ADD_VIDf_SET(r,f) (r).rx_dcb[6]=(((r).rx_dcb[6] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM56218_A0_RX_DCB_DO_NOT_CHANGE_TTLf_GET(r) ((((r).rx_dcb[6]) >> 31) & 0x1)
#define BCM56218_A0_RX_DCB_DO_NOT_CHANGE_TTLf_SET(r,f) (r).rx_dcb[6]=(((r).rx_dcb[6] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM56218_A0_RX_DCB_MODULE_HEADERf_GET(r,a) cdk_field_be_get((r).rx_dcb,11,160,287,a)
#define BCM56218_A0_RX_DCB_MODULE_HEADERf_SET(r,a) cdk_field_be_set((r).rx_dcb,11,160,287,a)
#define BCM56218_A0_RX_DCB_MODULE_HEADERf_PTR(r) ((void*)&(r).rx_dcb[2])
#define BCM56218_A0_RX_DCB_BYTE_COUNTf_GET(r) (((r).rx_dcb[1]) & 0xffff)
#define BCM56218_A0_RX_DCB_BYTE_COUNTf_SET(r,f) (r).rx_dcb[1]=(((r).rx_dcb[1] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56218_A0_RX_DCB_CHAINf_GET(r) ((((r).rx_dcb[1]) >> 16) & 0x1)
#define BCM56218_A0_RX_DCB_CHAINf_SET(r,f) (r).rx_dcb[1]=(((r).rx_dcb[1] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56218_A0_RX_DCB_SGf_GET(r) ((((r).rx_dcb[1]) >> 17) & 0x1)
#define BCM56218_A0_RX_DCB_SGf_SET(r,f) (r).rx_dcb[1]=(((r).rx_dcb[1] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_RX_DCB_RELOADf_GET(r) ((((r).rx_dcb[1]) >> 18) & 0x1)
#define BCM56218_A0_RX_DCB_RELOADf_SET(r,f) (r).rx_dcb[1]=(((r).rx_dcb[1] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_RX_DCB_ADDRf_GET(r) ((r).rx_dcb[0])
#define BCM56218_A0_RX_DCB_ADDRf_SET(r,f) (r).rx_dcb[0]=((uint32_t)f)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RX_DCB BCM56218_A0_RX_DCB
#define RX_DCB_SIZE BCM56218_A0_RX_DCB_SIZE
typedef BCM56218_A0_RX_DCB_t RX_DCB_t;
#define RX_DCB_CLR BCM56218_A0_RX_DCB_CLR
#define RX_DCB_SET BCM56218_A0_RX_DCB_SET
#define RX_DCB_GET BCM56218_A0_RX_DCB_GET
#define RX_DCB_BYTES_TRANSFERREDf_GET BCM56218_A0_RX_DCB_BYTES_TRANSFERREDf_GET
#define RX_DCB_BYTES_TRANSFERREDf_SET BCM56218_A0_RX_DCB_BYTES_TRANSFERREDf_SET
#define RX_DCB_END_BITf_GET BCM56218_A0_RX_DCB_END_BITf_GET
#define RX_DCB_END_BITf_SET BCM56218_A0_RX_DCB_END_BITf_SET
#define RX_DCB_START_BITf_GET BCM56218_A0_RX_DCB_START_BITf_GET
#define RX_DCB_START_BITf_SET BCM56218_A0_RX_DCB_START_BITf_SET
#define RX_DCB_ERRORf_GET BCM56218_A0_RX_DCB_ERRORf_GET
#define RX_DCB_ERRORf_SET BCM56218_A0_RX_DCB_ERRORf_SET
#define RX_DCB_DONEf_GET BCM56218_A0_RX_DCB_DONEf_GET
#define RX_DCB_DONEf_SET BCM56218_A0_RX_DCB_DONEf_SET
#define RX_DCB_DECAP_IPTUNNELf_GET BCM56218_A0_RX_DCB_DECAP_IPTUNNELf_GET
#define RX_DCB_DECAP_IPTUNNELf_SET BCM56218_A0_RX_DCB_DECAP_IPTUNNELf_SET
#define RX_DCB_PKT_WAS_UNTAGGEDf_GET BCM56218_A0_RX_DCB_PKT_WAS_UNTAGGEDf_GET
#define RX_DCB_PKT_WAS_UNTAGGEDf_SET BCM56218_A0_RX_DCB_PKT_WAS_UNTAGGEDf_SET
#define RX_DCB_OUTER_VIDf_GET BCM56218_A0_RX_DCB_OUTER_VIDf_GET
#define RX_DCB_OUTER_VIDf_SET BCM56218_A0_RX_DCB_OUTER_VIDf_SET
#define RX_DCB_OUTER_CFIf_GET BCM56218_A0_RX_DCB_OUTER_CFIf_GET
#define RX_DCB_OUTER_CFIf_SET BCM56218_A0_RX_DCB_OUTER_CFIf_SET
#define RX_DCB_OUTER_PRIf_GET BCM56218_A0_RX_DCB_OUTER_PRIf_GET
#define RX_DCB_OUTER_PRIf_SET BCM56218_A0_RX_DCB_OUTER_PRIf_SET
#define RX_DCB_DSCPf_GET BCM56218_A0_RX_DCB_DSCPf_GET
#define RX_DCB_DSCPf_SET BCM56218_A0_RX_DCB_DSCPf_SET
#define RX_DCB_SRC_PORTf_GET BCM56218_A0_RX_DCB_SRC_PORTf_GET
#define RX_DCB_SRC_PORTf_SET BCM56218_A0_RX_DCB_SRC_PORTf_SET
#define RX_DCB_NHOP_INDEXf_GET BCM56218_A0_RX_DCB_NHOP_INDEXf_GET
#define RX_DCB_NHOP_INDEXf_SET BCM56218_A0_RX_DCB_NHOP_INDEXf_SET
#define RX_DCB_MATCHED_RULEf_GET BCM56218_A0_RX_DCB_MATCHED_RULEf_GET
#define RX_DCB_MATCHED_RULEf_SET BCM56218_A0_RX_DCB_MATCHED_RULEf_SET
#define RX_DCB_REASONf_GET BCM56218_A0_RX_DCB_REASONf_GET
#define RX_DCB_REASONf_SET BCM56218_A0_RX_DCB_REASONf_SET
#define RX_DCB_RESERVED_0f_GET BCM56218_A0_RX_DCB_RESERVED_0f_GET
#define RX_DCB_RESERVED_0f_SET BCM56218_A0_RX_DCB_RESERVED_0f_SET
#define RX_DCB_REGEN_CRCf_GET BCM56218_A0_RX_DCB_REGEN_CRCf_GET
#define RX_DCB_REGEN_CRCf_SET BCM56218_A0_RX_DCB_REGEN_CRCf_SET
#define RX_DCB_SWITCHf_GET BCM56218_A0_RX_DCB_SWITCHf_GET
#define RX_DCB_SWITCHf_SET BCM56218_A0_RX_DCB_SWITCHf_SET
#define RX_DCB_SRC_HGf_GET BCM56218_A0_RX_DCB_SRC_HGf_GET
#define RX_DCB_SRC_HGf_SET BCM56218_A0_RX_DCB_SRC_HGf_SET
#define RX_DCB_PURGE_CELLf_GET BCM56218_A0_RX_DCB_PURGE_CELLf_GET
#define RX_DCB_PURGE_CELLf_SET BCM56218_A0_RX_DCB_PURGE_CELLf_SET
#define RX_DCB_PKT_AGEDf_GET BCM56218_A0_RX_DCB_PKT_AGEDf_GET
#define RX_DCB_PKT_AGEDf_SET BCM56218_A0_RX_DCB_PKT_AGEDf_SET
#define RX_DCB_MTP_INDEXf_GET BCM56218_A0_RX_DCB_MTP_INDEXf_GET
#define RX_DCB_MTP_INDEXf_SET BCM56218_A0_RX_DCB_MTP_INDEXf_SET
#define RX_DCB_L3UCf_GET BCM56218_A0_RX_DCB_L3UCf_GET
#define RX_DCB_L3UCf_SET BCM56218_A0_RX_DCB_L3UCf_SET
#define RX_DCB_IMIRRORf_GET BCM56218_A0_RX_DCB_IMIRRORf_GET
#define RX_DCB_IMIRRORf_SET BCM56218_A0_RX_DCB_IMIRRORf_SET
#define RX_DCB_EMIRRORf_GET BCM56218_A0_RX_DCB_EMIRRORf_GET
#define RX_DCB_EMIRRORf_SET BCM56218_A0_RX_DCB_EMIRRORf_SET
#define RX_DCB_COSf_GET BCM56218_A0_RX_DCB_COSf_GET
#define RX_DCB_COSf_SET BCM56218_A0_RX_DCB_COSf_SET
#define RX_DCB_CPU_COSf_GET BCM56218_A0_RX_DCB_CPU_COSf_GET
#define RX_DCB_CPU_COSf_SET BCM56218_A0_RX_DCB_CPU_COSf_SET
#define RX_DCB_CHANGE_DSCPf_GET BCM56218_A0_RX_DCB_CHANGE_DSCPf_GET
#define RX_DCB_CHANGE_DSCPf_SET BCM56218_A0_RX_DCB_CHANGE_DSCPf_SET
#define RX_DCB_CELL_ERRORf_GET BCM56218_A0_RX_DCB_CELL_ERRORf_GET
#define RX_DCB_CELL_ERRORf_SET BCM56218_A0_RX_DCB_CELL_ERRORf_SET
#define RX_DCB_BPDUf_GET BCM56218_A0_RX_DCB_BPDUf_GET
#define RX_DCB_BPDUf_SET BCM56218_A0_RX_DCB_BPDUf_SET
#define RX_DCB_ADD_VIDf_GET BCM56218_A0_RX_DCB_ADD_VIDf_GET
#define RX_DCB_ADD_VIDf_SET BCM56218_A0_RX_DCB_ADD_VIDf_SET
#define RX_DCB_DO_NOT_CHANGE_TTLf_GET BCM56218_A0_RX_DCB_DO_NOT_CHANGE_TTLf_GET
#define RX_DCB_DO_NOT_CHANGE_TTLf_SET BCM56218_A0_RX_DCB_DO_NOT_CHANGE_TTLf_SET
#define RX_DCB_MODULE_HEADERf_GET BCM56218_A0_RX_DCB_MODULE_HEADERf_GET
#define RX_DCB_MODULE_HEADERf_SET BCM56218_A0_RX_DCB_MODULE_HEADERf_SET
#define RX_DCB_MODULE_HEADERf_PTR BCM56218_A0_RX_DCB_MODULE_HEADERf_PTR
#define RX_DCB_BYTE_COUNTf_GET BCM56218_A0_RX_DCB_BYTE_COUNTf_GET
#define RX_DCB_BYTE_COUNTf_SET BCM56218_A0_RX_DCB_BYTE_COUNTf_SET
#define RX_DCB_CHAINf_GET BCM56218_A0_RX_DCB_CHAINf_GET
#define RX_DCB_CHAINf_SET BCM56218_A0_RX_DCB_CHAINf_SET
#define RX_DCB_SGf_GET BCM56218_A0_RX_DCB_SGf_GET
#define RX_DCB_SGf_SET BCM56218_A0_RX_DCB_SGf_SET
#define RX_DCB_RELOADf_GET BCM56218_A0_RX_DCB_RELOADf_GET
#define RX_DCB_RELOADf_SET BCM56218_A0_RX_DCB_RELOADf_SET
#define RX_DCB_ADDRf_GET BCM56218_A0_RX_DCB_ADDRf_GET
#define RX_DCB_ADDRf_SET BCM56218_A0_RX_DCB_ADDRf_SET
#define READ_RX_DCB BCM56218_A0_READ_RX_DCB
#define WRITE_RX_DCB BCM56218_A0_WRITE_RX_DCB

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_RX_DCB'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  SC_BYTE_METER_CONFIG
 * BLOCKS:   IPIPE
 * DESC:     Ethernet Byte Based Metering Control Register
 * SIZE:     32
 * FIELDS:
 *     DLFBC_ENABLE     DLF byte based storm rate control enable
 *     MCAST_ENABLE     Multicast byte based storm rate control enable
 *     BCAST_ENABLE     Broadcast byte based storm rate control enable
 *
 ******************************************************************************/
#define BCM56218_A0_SC_BYTE_METER_CONFIGr 0x0b70000b

#define BCM56218_A0_SC_BYTE_METER_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program SC_BYTE_METER_CONFIG.
 *
 */
typedef union BCM56218_A0_SC_BYTE_METER_CONFIGr_s {
	uint32_t v[1];
	uint32_t sc_byte_meter_config[1];
	uint32_t _sc_byte_meter_config;
} BCM56218_A0_SC_BYTE_METER_CONFIGr_t;

#define BCM56218_A0_SC_BYTE_METER_CONFIGr_CLR(r) (r).sc_byte_meter_config[0] = 0
#define BCM56218_A0_SC_BYTE_METER_CONFIGr_SET(r,d) (r).sc_byte_meter_config[0] = d
#define BCM56218_A0_SC_BYTE_METER_CONFIGr_GET(r) (r).sc_byte_meter_config[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_SC_BYTE_METER_CONFIGr_DLFBC_ENABLEf_GET(r) (((r).sc_byte_meter_config[0]) & 0x1)
#define BCM56218_A0_SC_BYTE_METER_CONFIGr_DLFBC_ENABLEf_SET(r,f) (r).sc_byte_meter_config[0]=(((r).sc_byte_meter_config[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_SC_BYTE_METER_CONFIGr_MCAST_ENABLEf_GET(r) ((((r).sc_byte_meter_config[0]) >> 1) & 0x1)
#define BCM56218_A0_SC_BYTE_METER_CONFIGr_MCAST_ENABLEf_SET(r,f) (r).sc_byte_meter_config[0]=(((r).sc_byte_meter_config[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_SC_BYTE_METER_CONFIGr_BCAST_ENABLEf_GET(r) ((((r).sc_byte_meter_config[0]) >> 2) & 0x1)
#define BCM56218_A0_SC_BYTE_METER_CONFIGr_BCAST_ENABLEf_SET(r,f) (r).sc_byte_meter_config[0]=(((r).sc_byte_meter_config[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))

/*
 * These macros can be used to access SC_BYTE_METER_CONFIG.
 *
 */
#define BCM56218_A0_READ_SC_BYTE_METER_CONFIGr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_SC_BYTE_METER_CONFIGr,(r._sc_byte_meter_config))
#define BCM56218_A0_WRITE_SC_BYTE_METER_CONFIGr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_SC_BYTE_METER_CONFIGr,&(r._sc_byte_meter_config))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SC_BYTE_METER_CONFIGr BCM56218_A0_SC_BYTE_METER_CONFIGr
#define SC_BYTE_METER_CONFIGr_SIZE BCM56218_A0_SC_BYTE_METER_CONFIGr_SIZE
typedef BCM56218_A0_SC_BYTE_METER_CONFIGr_t SC_BYTE_METER_CONFIGr_t;
#define SC_BYTE_METER_CONFIGr_CLR BCM56218_A0_SC_BYTE_METER_CONFIGr_CLR
#define SC_BYTE_METER_CONFIGr_SET BCM56218_A0_SC_BYTE_METER_CONFIGr_SET
#define SC_BYTE_METER_CONFIGr_GET BCM56218_A0_SC_BYTE_METER_CONFIGr_GET
#define SC_BYTE_METER_CONFIGr_DLFBC_ENABLEf_GET BCM56218_A0_SC_BYTE_METER_CONFIGr_DLFBC_ENABLEf_GET
#define SC_BYTE_METER_CONFIGr_DLFBC_ENABLEf_SET BCM56218_A0_SC_BYTE_METER_CONFIGr_DLFBC_ENABLEf_SET
#define SC_BYTE_METER_CONFIGr_MCAST_ENABLEf_GET BCM56218_A0_SC_BYTE_METER_CONFIGr_MCAST_ENABLEf_GET
#define SC_BYTE_METER_CONFIGr_MCAST_ENABLEf_SET BCM56218_A0_SC_BYTE_METER_CONFIGr_MCAST_ENABLEf_SET
#define SC_BYTE_METER_CONFIGr_BCAST_ENABLEf_GET BCM56218_A0_SC_BYTE_METER_CONFIGr_BCAST_ENABLEf_GET
#define SC_BYTE_METER_CONFIGr_BCAST_ENABLEf_SET BCM56218_A0_SC_BYTE_METER_CONFIGr_BCAST_ENABLEf_SET
#define READ_SC_BYTE_METER_CONFIGr BCM56218_A0_READ_SC_BYTE_METER_CONFIGr
#define WRITE_SC_BYTE_METER_CONFIGr BCM56218_A0_WRITE_SC_BYTE_METER_CONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_SC_BYTE_METER_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  SFLOW_EGR_RAND_SEED
 * BLOCKS:   IPIPE
 * DESC:     sFlow Egress Random Number Generator Seed Register
 * SIZE:     32
 * FIELDS:
 *     SEED             Seed for sFlow Egress Random Number Generator
 *
 ******************************************************************************/
#define BCM56218_A0_SFLOW_EGR_RAND_SEEDr 0x0e780127

#define BCM56218_A0_SFLOW_EGR_RAND_SEEDr_SIZE 4

/*
 * This structure should be used to declare and program SFLOW_EGR_RAND_SEED.
 *
 */
typedef union BCM56218_A0_SFLOW_EGR_RAND_SEEDr_s {
	uint32_t v[1];
	uint32_t sflow_egr_rand_seed[1];
	uint32_t _sflow_egr_rand_seed;
} BCM56218_A0_SFLOW_EGR_RAND_SEEDr_t;

#define BCM56218_A0_SFLOW_EGR_RAND_SEEDr_CLR(r) (r).sflow_egr_rand_seed[0] = 0
#define BCM56218_A0_SFLOW_EGR_RAND_SEEDr_SET(r,d) (r).sflow_egr_rand_seed[0] = d
#define BCM56218_A0_SFLOW_EGR_RAND_SEEDr_GET(r) (r).sflow_egr_rand_seed[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_SFLOW_EGR_RAND_SEEDr_SEEDf_GET(r) (((r).sflow_egr_rand_seed[0]) & 0x1ffffff)
#define BCM56218_A0_SFLOW_EGR_RAND_SEEDr_SEEDf_SET(r,f) (r).sflow_egr_rand_seed[0]=(((r).sflow_egr_rand_seed[0] & ~((uint32_t)0x1ffffff)) | (((uint32_t)f) & 0x1ffffff))

/*
 * These macros can be used to access SFLOW_EGR_RAND_SEED.
 *
 */
#define BCM56218_A0_READ_SFLOW_EGR_RAND_SEEDr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_SFLOW_EGR_RAND_SEEDr,(r._sflow_egr_rand_seed))
#define BCM56218_A0_WRITE_SFLOW_EGR_RAND_SEEDr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_SFLOW_EGR_RAND_SEEDr,&(r._sflow_egr_rand_seed))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SFLOW_EGR_RAND_SEEDr BCM56218_A0_SFLOW_EGR_RAND_SEEDr
#define SFLOW_EGR_RAND_SEEDr_SIZE BCM56218_A0_SFLOW_EGR_RAND_SEEDr_SIZE
typedef BCM56218_A0_SFLOW_EGR_RAND_SEEDr_t SFLOW_EGR_RAND_SEEDr_t;
#define SFLOW_EGR_RAND_SEEDr_CLR BCM56218_A0_SFLOW_EGR_RAND_SEEDr_CLR
#define SFLOW_EGR_RAND_SEEDr_SET BCM56218_A0_SFLOW_EGR_RAND_SEEDr_SET
#define SFLOW_EGR_RAND_SEEDr_GET BCM56218_A0_SFLOW_EGR_RAND_SEEDr_GET
#define SFLOW_EGR_RAND_SEEDr_SEEDf_GET BCM56218_A0_SFLOW_EGR_RAND_SEEDr_SEEDf_GET
#define SFLOW_EGR_RAND_SEEDr_SEEDf_SET BCM56218_A0_SFLOW_EGR_RAND_SEEDr_SEEDf_SET
#define READ_SFLOW_EGR_RAND_SEEDr BCM56218_A0_READ_SFLOW_EGR_RAND_SEEDr
#define WRITE_SFLOW_EGR_RAND_SEEDr BCM56218_A0_WRITE_SFLOW_EGR_RAND_SEEDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_SFLOW_EGR_RAND_SEEDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  SFLOW_EGR_THRESHOLD
 * BLOCKS:   IPIPE
 * DESC:     sFlow Egress Threshold Register
 * SIZE:     32
 * FIELDS:
 *     THRESHOLD        sFlow Egress Threshold Value
 *     ENABLE           Enable sFlow Egress
 *
 ******************************************************************************/
#define BCM56218_A0_SFLOW_EGR_THRESHOLDr 0x0e70010c

#define BCM56218_A0_SFLOW_EGR_THRESHOLDr_SIZE 4

/*
 * This structure should be used to declare and program SFLOW_EGR_THRESHOLD.
 *
 */
typedef union BCM56218_A0_SFLOW_EGR_THRESHOLDr_s {
	uint32_t v[1];
	uint32_t sflow_egr_threshold[1];
	uint32_t _sflow_egr_threshold;
} BCM56218_A0_SFLOW_EGR_THRESHOLDr_t;

#define BCM56218_A0_SFLOW_EGR_THRESHOLDr_CLR(r) (r).sflow_egr_threshold[0] = 0
#define BCM56218_A0_SFLOW_EGR_THRESHOLDr_SET(r,d) (r).sflow_egr_threshold[0] = d
#define BCM56218_A0_SFLOW_EGR_THRESHOLDr_GET(r) (r).sflow_egr_threshold[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_SFLOW_EGR_THRESHOLDr_THRESHOLDf_GET(r) (((r).sflow_egr_threshold[0]) & 0xffff)
#define BCM56218_A0_SFLOW_EGR_THRESHOLDr_THRESHOLDf_SET(r,f) (r).sflow_egr_threshold[0]=(((r).sflow_egr_threshold[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56218_A0_SFLOW_EGR_THRESHOLDr_ENABLEf_GET(r) ((((r).sflow_egr_threshold[0]) >> 16) & 0x1)
#define BCM56218_A0_SFLOW_EGR_THRESHOLDr_ENABLEf_SET(r,f) (r).sflow_egr_threshold[0]=(((r).sflow_egr_threshold[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))

/*
 * These macros can be used to access SFLOW_EGR_THRESHOLD.
 *
 */
#define BCM56218_A0_READ_SFLOW_EGR_THRESHOLDr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_SFLOW_EGR_THRESHOLDr,(r._sflow_egr_threshold))
#define BCM56218_A0_WRITE_SFLOW_EGR_THRESHOLDr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_SFLOW_EGR_THRESHOLDr,&(r._sflow_egr_threshold))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SFLOW_EGR_THRESHOLDr BCM56218_A0_SFLOW_EGR_THRESHOLDr
#define SFLOW_EGR_THRESHOLDr_SIZE BCM56218_A0_SFLOW_EGR_THRESHOLDr_SIZE
typedef BCM56218_A0_SFLOW_EGR_THRESHOLDr_t SFLOW_EGR_THRESHOLDr_t;
#define SFLOW_EGR_THRESHOLDr_CLR BCM56218_A0_SFLOW_EGR_THRESHOLDr_CLR
#define SFLOW_EGR_THRESHOLDr_SET BCM56218_A0_SFLOW_EGR_THRESHOLDr_SET
#define SFLOW_EGR_THRESHOLDr_GET BCM56218_A0_SFLOW_EGR_THRESHOLDr_GET
#define SFLOW_EGR_THRESHOLDr_THRESHOLDf_GET BCM56218_A0_SFLOW_EGR_THRESHOLDr_THRESHOLDf_GET
#define SFLOW_EGR_THRESHOLDr_THRESHOLDf_SET BCM56218_A0_SFLOW_EGR_THRESHOLDr_THRESHOLDf_SET
#define SFLOW_EGR_THRESHOLDr_ENABLEf_GET BCM56218_A0_SFLOW_EGR_THRESHOLDr_ENABLEf_GET
#define SFLOW_EGR_THRESHOLDr_ENABLEf_SET BCM56218_A0_SFLOW_EGR_THRESHOLDr_ENABLEf_SET
#define READ_SFLOW_EGR_THRESHOLDr BCM56218_A0_READ_SFLOW_EGR_THRESHOLDr
#define WRITE_SFLOW_EGR_THRESHOLDr BCM56218_A0_WRITE_SFLOW_EGR_THRESHOLDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_SFLOW_EGR_THRESHOLDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  SFLOW_ING_RAND_SEED
 * BLOCKS:   IPIPE
 * DESC:     sFlow Ingress Random Number Generator Seed Register
 * SIZE:     32
 * FIELDS:
 *     SEED             Seed for sFlow Ingress Random Number Generator
 *
 ******************************************************************************/
#define BCM56218_A0_SFLOW_ING_RAND_SEEDr 0x0e780126

#define BCM56218_A0_SFLOW_ING_RAND_SEEDr_SIZE 4

/*
 * This structure should be used to declare and program SFLOW_ING_RAND_SEED.
 *
 */
typedef union BCM56218_A0_SFLOW_ING_RAND_SEEDr_s {
	uint32_t v[1];
	uint32_t sflow_ing_rand_seed[1];
	uint32_t _sflow_ing_rand_seed;
} BCM56218_A0_SFLOW_ING_RAND_SEEDr_t;

#define BCM56218_A0_SFLOW_ING_RAND_SEEDr_CLR(r) (r).sflow_ing_rand_seed[0] = 0
#define BCM56218_A0_SFLOW_ING_RAND_SEEDr_SET(r,d) (r).sflow_ing_rand_seed[0] = d
#define BCM56218_A0_SFLOW_ING_RAND_SEEDr_GET(r) (r).sflow_ing_rand_seed[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_SFLOW_ING_RAND_SEEDr_SEEDf_GET(r) (((r).sflow_ing_rand_seed[0]) & 0x1ffffff)
#define BCM56218_A0_SFLOW_ING_RAND_SEEDr_SEEDf_SET(r,f) (r).sflow_ing_rand_seed[0]=(((r).sflow_ing_rand_seed[0] & ~((uint32_t)0x1ffffff)) | (((uint32_t)f) & 0x1ffffff))

/*
 * These macros can be used to access SFLOW_ING_RAND_SEED.
 *
 */
#define BCM56218_A0_READ_SFLOW_ING_RAND_SEEDr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_SFLOW_ING_RAND_SEEDr,(r._sflow_ing_rand_seed))
#define BCM56218_A0_WRITE_SFLOW_ING_RAND_SEEDr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_SFLOW_ING_RAND_SEEDr,&(r._sflow_ing_rand_seed))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SFLOW_ING_RAND_SEEDr BCM56218_A0_SFLOW_ING_RAND_SEEDr
#define SFLOW_ING_RAND_SEEDr_SIZE BCM56218_A0_SFLOW_ING_RAND_SEEDr_SIZE
typedef BCM56218_A0_SFLOW_ING_RAND_SEEDr_t SFLOW_ING_RAND_SEEDr_t;
#define SFLOW_ING_RAND_SEEDr_CLR BCM56218_A0_SFLOW_ING_RAND_SEEDr_CLR
#define SFLOW_ING_RAND_SEEDr_SET BCM56218_A0_SFLOW_ING_RAND_SEEDr_SET
#define SFLOW_ING_RAND_SEEDr_GET BCM56218_A0_SFLOW_ING_RAND_SEEDr_GET
#define SFLOW_ING_RAND_SEEDr_SEEDf_GET BCM56218_A0_SFLOW_ING_RAND_SEEDr_SEEDf_GET
#define SFLOW_ING_RAND_SEEDr_SEEDf_SET BCM56218_A0_SFLOW_ING_RAND_SEEDr_SEEDf_SET
#define READ_SFLOW_ING_RAND_SEEDr BCM56218_A0_READ_SFLOW_ING_RAND_SEEDr
#define WRITE_SFLOW_ING_RAND_SEEDr BCM56218_A0_WRITE_SFLOW_ING_RAND_SEEDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_SFLOW_ING_RAND_SEEDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  SFLOW_ING_THRESHOLD
 * BLOCKS:   IPIPE
 * DESC:     sFlow Ingress Threshold Register
 * SIZE:     32
 * FIELDS:
 *     THRESHOLD        sFlow Ingress Threshold Value
 *     ENABLE           Enable sFlow Ingress
 *
 ******************************************************************************/
#define BCM56218_A0_SFLOW_ING_THRESHOLDr 0x0e70010b

#define BCM56218_A0_SFLOW_ING_THRESHOLDr_SIZE 4

/*
 * This structure should be used to declare and program SFLOW_ING_THRESHOLD.
 *
 */
typedef union BCM56218_A0_SFLOW_ING_THRESHOLDr_s {
	uint32_t v[1];
	uint32_t sflow_ing_threshold[1];
	uint32_t _sflow_ing_threshold;
} BCM56218_A0_SFLOW_ING_THRESHOLDr_t;

#define BCM56218_A0_SFLOW_ING_THRESHOLDr_CLR(r) (r).sflow_ing_threshold[0] = 0
#define BCM56218_A0_SFLOW_ING_THRESHOLDr_SET(r,d) (r).sflow_ing_threshold[0] = d
#define BCM56218_A0_SFLOW_ING_THRESHOLDr_GET(r) (r).sflow_ing_threshold[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_SFLOW_ING_THRESHOLDr_THRESHOLDf_GET(r) (((r).sflow_ing_threshold[0]) & 0xffff)
#define BCM56218_A0_SFLOW_ING_THRESHOLDr_THRESHOLDf_SET(r,f) (r).sflow_ing_threshold[0]=(((r).sflow_ing_threshold[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56218_A0_SFLOW_ING_THRESHOLDr_ENABLEf_GET(r) ((((r).sflow_ing_threshold[0]) >> 16) & 0x1)
#define BCM56218_A0_SFLOW_ING_THRESHOLDr_ENABLEf_SET(r,f) (r).sflow_ing_threshold[0]=(((r).sflow_ing_threshold[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))

/*
 * These macros can be used to access SFLOW_ING_THRESHOLD.
 *
 */
#define BCM56218_A0_READ_SFLOW_ING_THRESHOLDr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_SFLOW_ING_THRESHOLDr,(r._sflow_ing_threshold))
#define BCM56218_A0_WRITE_SFLOW_ING_THRESHOLDr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_SFLOW_ING_THRESHOLDr,&(r._sflow_ing_threshold))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SFLOW_ING_THRESHOLDr BCM56218_A0_SFLOW_ING_THRESHOLDr
#define SFLOW_ING_THRESHOLDr_SIZE BCM56218_A0_SFLOW_ING_THRESHOLDr_SIZE
typedef BCM56218_A0_SFLOW_ING_THRESHOLDr_t SFLOW_ING_THRESHOLDr_t;
#define SFLOW_ING_THRESHOLDr_CLR BCM56218_A0_SFLOW_ING_THRESHOLDr_CLR
#define SFLOW_ING_THRESHOLDr_SET BCM56218_A0_SFLOW_ING_THRESHOLDr_SET
#define SFLOW_ING_THRESHOLDr_GET BCM56218_A0_SFLOW_ING_THRESHOLDr_GET
#define SFLOW_ING_THRESHOLDr_THRESHOLDf_GET BCM56218_A0_SFLOW_ING_THRESHOLDr_THRESHOLDf_GET
#define SFLOW_ING_THRESHOLDr_THRESHOLDf_SET BCM56218_A0_SFLOW_ING_THRESHOLDr_THRESHOLDf_SET
#define SFLOW_ING_THRESHOLDr_ENABLEf_GET BCM56218_A0_SFLOW_ING_THRESHOLDr_ENABLEf_GET
#define SFLOW_ING_THRESHOLDr_ENABLEf_SET BCM56218_A0_SFLOW_ING_THRESHOLDr_ENABLEf_SET
#define READ_SFLOW_ING_THRESHOLDr BCM56218_A0_READ_SFLOW_ING_THRESHOLDr
#define WRITE_SFLOW_ING_THRESHOLDr BCM56218_A0_WRITE_SFLOW_ING_THRESHOLDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_SFLOW_ING_THRESHOLDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  SOFTRESETPBM
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     SOFTRESETPBM     Ingress Port Bitmap indicats which Ingress Port is generating software reset error. 
 *
 ******************************************************************************/
#define BCM56218_A0_SOFTRESETPBMr 0x0068003a

#define BCM56218_A0_SOFTRESETPBMr_SIZE 4

/*
 * This structure should be used to declare and program SOFTRESETPBM.
 *
 */
typedef union BCM56218_A0_SOFTRESETPBMr_s {
	uint32_t v[1];
	uint32_t softresetpbm[1];
	uint32_t _softresetpbm;
} BCM56218_A0_SOFTRESETPBMr_t;

#define BCM56218_A0_SOFTRESETPBMr_CLR(r) (r).softresetpbm[0] = 0
#define BCM56218_A0_SOFTRESETPBMr_SET(r,d) (r).softresetpbm[0] = d
#define BCM56218_A0_SOFTRESETPBMr_GET(r) (r).softresetpbm[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_SOFTRESETPBMr_SOFTRESETPBMf_GET(r) ((r).softresetpbm[0])
#define BCM56218_A0_SOFTRESETPBMr_SOFTRESETPBMf_SET(r,f) (r).softresetpbm[0]=((uint32_t)f)

/*
 * These macros can be used to access SOFTRESETPBM.
 *
 */
#define BCM56218_A0_READ_SOFTRESETPBMr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_SOFTRESETPBMr,(r._softresetpbm))
#define BCM56218_A0_WRITE_SOFTRESETPBMr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_SOFTRESETPBMr,&(r._softresetpbm))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SOFTRESETPBMr BCM56218_A0_SOFTRESETPBMr
#define SOFTRESETPBMr_SIZE BCM56218_A0_SOFTRESETPBMr_SIZE
typedef BCM56218_A0_SOFTRESETPBMr_t SOFTRESETPBMr_t;
#define SOFTRESETPBMr_CLR BCM56218_A0_SOFTRESETPBMr_CLR
#define SOFTRESETPBMr_SET BCM56218_A0_SOFTRESETPBMr_SET
#define SOFTRESETPBMr_GET BCM56218_A0_SOFTRESETPBMr_GET
#define SOFTRESETPBMr_SOFTRESETPBMf_GET BCM56218_A0_SOFTRESETPBMr_SOFTRESETPBMf_GET
#define SOFTRESETPBMr_SOFTRESETPBMf_SET BCM56218_A0_SOFTRESETPBMr_SOFTRESETPBMf_SET
#define READ_SOFTRESETPBMr BCM56218_A0_READ_SOFTRESETPBMr
#define WRITE_SOFTRESETPBMr BCM56218_A0_WRITE_SOFTRESETPBMr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_SOFTRESETPBMr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  SOFTRESETPBM_HI
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     SOFTRESETPBM     Ingress Port Bitmap indicats which Ingress Port is generating software reset error. 
 *
 ******************************************************************************/
#define BCM56218_A0_SOFTRESETPBM_HIr 0x0068003b

#define BCM56218_A0_SOFTRESETPBM_HIr_SIZE 4

/*
 * This structure should be used to declare and program SOFTRESETPBM_HI.
 *
 */
typedef union BCM56218_A0_SOFTRESETPBM_HIr_s {
	uint32_t v[1];
	uint32_t softresetpbm_hi[1];
	uint32_t _softresetpbm_hi;
} BCM56218_A0_SOFTRESETPBM_HIr_t;

#define BCM56218_A0_SOFTRESETPBM_HIr_CLR(r) (r).softresetpbm_hi[0] = 0
#define BCM56218_A0_SOFTRESETPBM_HIr_SET(r,d) (r).softresetpbm_hi[0] = d
#define BCM56218_A0_SOFTRESETPBM_HIr_GET(r) (r).softresetpbm_hi[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_SOFTRESETPBM_HIr_SOFTRESETPBMf_GET(r) (((r).softresetpbm_hi[0]) & 0x3fffff)
#define BCM56218_A0_SOFTRESETPBM_HIr_SOFTRESETPBMf_SET(r,f) (r).softresetpbm_hi[0]=(((r).softresetpbm_hi[0] & ~((uint32_t)0x3fffff)) | (((uint32_t)f) & 0x3fffff))

/*
 * These macros can be used to access SOFTRESETPBM_HI.
 *
 */
#define BCM56218_A0_READ_SOFTRESETPBM_HIr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_SOFTRESETPBM_HIr,(r._softresetpbm_hi))
#define BCM56218_A0_WRITE_SOFTRESETPBM_HIr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_SOFTRESETPBM_HIr,&(r._softresetpbm_hi))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SOFTRESETPBM_HIr BCM56218_A0_SOFTRESETPBM_HIr
#define SOFTRESETPBM_HIr_SIZE BCM56218_A0_SOFTRESETPBM_HIr_SIZE
typedef BCM56218_A0_SOFTRESETPBM_HIr_t SOFTRESETPBM_HIr_t;
#define SOFTRESETPBM_HIr_CLR BCM56218_A0_SOFTRESETPBM_HIr_CLR
#define SOFTRESETPBM_HIr_SET BCM56218_A0_SOFTRESETPBM_HIr_SET
#define SOFTRESETPBM_HIr_GET BCM56218_A0_SOFTRESETPBM_HIr_GET
#define SOFTRESETPBM_HIr_SOFTRESETPBMf_GET BCM56218_A0_SOFTRESETPBM_HIr_SOFTRESETPBMf_GET
#define SOFTRESETPBM_HIr_SOFTRESETPBMf_SET BCM56218_A0_SOFTRESETPBM_HIr_SOFTRESETPBMf_SET
#define READ_SOFTRESETPBM_HIr BCM56218_A0_READ_SOFTRESETPBM_HIr
#define WRITE_SOFTRESETPBM_HIr BCM56218_A0_WRITE_SOFTRESETPBM_HIr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_SOFTRESETPBM_HIr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * SWFORMAT:  SOFTWARE_BLOCKMAP
 * BLOCKS:  
 * DESC:     Software Blockmap
 * SIZE:     8
 * FIELDS:
 *     BSAFE            Software Block Flag for BSAFE
 *     CMIC             Software Block Flag for CMIC
 *     EPIPE            Software Block Flag for EPIPE
 *     EPIPE_HI         Software Block Flag for EPIPE_HI
 *     GPORT            Software Block Flag for GPORT
 *     IPIPE            Software Block Flag for IPIPE
 *     IPIPE_HI         Software Block Flag for IPIPE_HI
 *     MMU              Software Block Flag for MMU
 *
 ******************************************************************************/
#define BCM56218_A0_SOFTWARE_BLOCKMAP 0x00000000

#define BCM56218_A0_SOFTWARE_BLOCKMAP_SIZE 1

/*
 * This structure should be used to declare and program SOFTWARE_BLOCKMAP.
 *
 */
typedef union BCM56218_A0_SOFTWARE_BLOCKMAP_s {
	uint32_t v[1];
	uint32_t software_blockmap[1];
	uint32_t _software_blockmap;
} BCM56218_A0_SOFTWARE_BLOCKMAP_t;

#define BCM56218_A0_SOFTWARE_BLOCKMAP_CLR(r) (r).software_blockmap[0] = 0
#define BCM56218_A0_SOFTWARE_BLOCKMAP_SET(r,d) (r).software_blockmap[0] = d
#define BCM56218_A0_SOFTWARE_BLOCKMAP_GET(r) (r).software_blockmap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_SOFTWARE_BLOCKMAP_BSAFEf_GET(r) (((r).software_blockmap[0]) & 0x1)
#define BCM56218_A0_SOFTWARE_BLOCKMAP_BSAFEf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_SOFTWARE_BLOCKMAP_CMICf_GET(r) ((((r).software_blockmap[0]) >> 1) & 0x1)
#define BCM56218_A0_SOFTWARE_BLOCKMAP_CMICf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_SOFTWARE_BLOCKMAP_EPIPEf_GET(r) ((((r).software_blockmap[0]) >> 2) & 0x1)
#define BCM56218_A0_SOFTWARE_BLOCKMAP_EPIPEf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_SOFTWARE_BLOCKMAP_EPIPE_HIf_GET(r) ((((r).software_blockmap[0]) >> 3) & 0x1)
#define BCM56218_A0_SOFTWARE_BLOCKMAP_EPIPE_HIf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56218_A0_SOFTWARE_BLOCKMAP_GPORTf_GET(r) ((((r).software_blockmap[0]) >> 4) & 0x1)
#define BCM56218_A0_SOFTWARE_BLOCKMAP_GPORTf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56218_A0_SOFTWARE_BLOCKMAP_IPIPEf_GET(r) ((((r).software_blockmap[0]) >> 5) & 0x1)
#define BCM56218_A0_SOFTWARE_BLOCKMAP_IPIPEf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56218_A0_SOFTWARE_BLOCKMAP_IPIPE_HIf_GET(r) ((((r).software_blockmap[0]) >> 6) & 0x1)
#define BCM56218_A0_SOFTWARE_BLOCKMAP_IPIPE_HIf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56218_A0_SOFTWARE_BLOCKMAP_MMUf_GET(r) ((((r).software_blockmap[0]) >> 7) & 0x1)
#define BCM56218_A0_SOFTWARE_BLOCKMAP_MMUf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SOFTWARE_BLOCKMAP BCM56218_A0_SOFTWARE_BLOCKMAP
#define SOFTWARE_BLOCKMAP_SIZE BCM56218_A0_SOFTWARE_BLOCKMAP_SIZE
typedef BCM56218_A0_SOFTWARE_BLOCKMAP_t SOFTWARE_BLOCKMAP_t;
#define SOFTWARE_BLOCKMAP_CLR BCM56218_A0_SOFTWARE_BLOCKMAP_CLR
#define SOFTWARE_BLOCKMAP_SET BCM56218_A0_SOFTWARE_BLOCKMAP_SET
#define SOFTWARE_BLOCKMAP_GET BCM56218_A0_SOFTWARE_BLOCKMAP_GET
#define SOFTWARE_BLOCKMAP_BSAFEf_GET BCM56218_A0_SOFTWARE_BLOCKMAP_BSAFEf_GET
#define SOFTWARE_BLOCKMAP_BSAFEf_SET BCM56218_A0_SOFTWARE_BLOCKMAP_BSAFEf_SET
#define SOFTWARE_BLOCKMAP_CMICf_GET BCM56218_A0_SOFTWARE_BLOCKMAP_CMICf_GET
#define SOFTWARE_BLOCKMAP_CMICf_SET BCM56218_A0_SOFTWARE_BLOCKMAP_CMICf_SET
#define SOFTWARE_BLOCKMAP_EPIPEf_GET BCM56218_A0_SOFTWARE_BLOCKMAP_EPIPEf_GET
#define SOFTWARE_BLOCKMAP_EPIPEf_SET BCM56218_A0_SOFTWARE_BLOCKMAP_EPIPEf_SET
#define SOFTWARE_BLOCKMAP_EPIPE_HIf_GET BCM56218_A0_SOFTWARE_BLOCKMAP_EPIPE_HIf_GET
#define SOFTWARE_BLOCKMAP_EPIPE_HIf_SET BCM56218_A0_SOFTWARE_BLOCKMAP_EPIPE_HIf_SET
#define SOFTWARE_BLOCKMAP_GPORTf_GET BCM56218_A0_SOFTWARE_BLOCKMAP_GPORTf_GET
#define SOFTWARE_BLOCKMAP_GPORTf_SET BCM56218_A0_SOFTWARE_BLOCKMAP_GPORTf_SET
#define SOFTWARE_BLOCKMAP_IPIPEf_GET BCM56218_A0_SOFTWARE_BLOCKMAP_IPIPEf_GET
#define SOFTWARE_BLOCKMAP_IPIPEf_SET BCM56218_A0_SOFTWARE_BLOCKMAP_IPIPEf_SET
#define SOFTWARE_BLOCKMAP_IPIPE_HIf_GET BCM56218_A0_SOFTWARE_BLOCKMAP_IPIPE_HIf_GET
#define SOFTWARE_BLOCKMAP_IPIPE_HIf_SET BCM56218_A0_SOFTWARE_BLOCKMAP_IPIPE_HIf_SET
#define SOFTWARE_BLOCKMAP_MMUf_GET BCM56218_A0_SOFTWARE_BLOCKMAP_MMUf_GET
#define SOFTWARE_BLOCKMAP_MMUf_SET BCM56218_A0_SOFTWARE_BLOCKMAP_MMUf_SET
#define READ_SOFTWARE_BLOCKMAP BCM56218_A0_READ_SOFTWARE_BLOCKMAP
#define WRITE_SOFTWARE_BLOCKMAP BCM56218_A0_WRITE_SOFTWARE_BLOCKMAP

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_SOFTWARE_BLOCKMAP'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  SOURCE_TRUNK_MAP_TABLE
 * BLOCKS:   IPIPE
 * DESC:     Source Trunk Map Table
 * SIZE:     7
 * FIELDS:
 *     PORT_TYPE        Indicates source port type
 *     TGID             Source port TGID (32 tgid support only)
 *
 ******************************************************************************/
#define BCM56218_A0_SOURCE_TRUNK_MAP_TABLEm 0x02710000

#define BCM56218_A0_SOURCE_TRUNK_MAP_TABLEm_MIN 0
#define BCM56218_A0_SOURCE_TRUNK_MAP_TABLEm_MAX 1023
#define BCM56218_A0_SOURCE_TRUNK_MAP_TABLEm_CMAX(u) 1023
#define BCM56218_A0_SOURCE_TRUNK_MAP_TABLEm_SIZE 1

/*
 * This structure should be used to declare and program SOURCE_TRUNK_MAP_TABLE.
 *
 */
typedef union BCM56218_A0_SOURCE_TRUNK_MAP_TABLEm_s {
	uint32_t v[1];
	uint32_t source_trunk_map_table[1];
	uint32_t _source_trunk_map_table;
} BCM56218_A0_SOURCE_TRUNK_MAP_TABLEm_t;

#define BCM56218_A0_SOURCE_TRUNK_MAP_TABLEm_CLR(r) (r).source_trunk_map_table[0] = 0
#define BCM56218_A0_SOURCE_TRUNK_MAP_TABLEm_SET(r,d) (r).source_trunk_map_table[0] = d
#define BCM56218_A0_SOURCE_TRUNK_MAP_TABLEm_GET(r) (r).source_trunk_map_table[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_SOURCE_TRUNK_MAP_TABLEm_PORT_TYPEf_GET(r) (((r).source_trunk_map_table[0]) & 0x3)
#define BCM56218_A0_SOURCE_TRUNK_MAP_TABLEm_PORT_TYPEf_SET(r,f) (r).source_trunk_map_table[0]=(((r).source_trunk_map_table[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56218_A0_SOURCE_TRUNK_MAP_TABLEm_TGIDf_GET(r) ((((r).source_trunk_map_table[0]) >> 2) & 0x1f)
#define BCM56218_A0_SOURCE_TRUNK_MAP_TABLEm_TGIDf_SET(r,f) (r).source_trunk_map_table[0]=(((r).source_trunk_map_table[0] & ~((uint32_t)0x1f << 2)) | ((((uint32_t)f) & 0x1f) << 2))

/*
 * These macros can be used to access SOURCE_TRUNK_MAP_TABLE.
 *
 */
#define BCM56218_A0_READ_SOURCE_TRUNK_MAP_TABLEm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_SOURCE_TRUNK_MAP_TABLEm,i,(m._source_trunk_map_table),1)
#define BCM56218_A0_WRITE_SOURCE_TRUNK_MAP_TABLEm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_SOURCE_TRUNK_MAP_TABLEm,i,&(m._source_trunk_map_table),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SOURCE_TRUNK_MAP_TABLEm BCM56218_A0_SOURCE_TRUNK_MAP_TABLEm
#define SOURCE_TRUNK_MAP_TABLEm_MIN BCM56218_A0_SOURCE_TRUNK_MAP_TABLEm_MIN
#define SOURCE_TRUNK_MAP_TABLEm_MAX BCM56218_A0_SOURCE_TRUNK_MAP_TABLEm_MAX
#define SOURCE_TRUNK_MAP_TABLEm_CMAX(u) BCM56218_A0_SOURCE_TRUNK_MAP_TABLEm_CMAX(u)
#define SOURCE_TRUNK_MAP_TABLEm_SIZE BCM56218_A0_SOURCE_TRUNK_MAP_TABLEm_SIZE
typedef BCM56218_A0_SOURCE_TRUNK_MAP_TABLEm_t SOURCE_TRUNK_MAP_TABLEm_t;
#define SOURCE_TRUNK_MAP_TABLEm_CLR BCM56218_A0_SOURCE_TRUNK_MAP_TABLEm_CLR
#define SOURCE_TRUNK_MAP_TABLEm_SET BCM56218_A0_SOURCE_TRUNK_MAP_TABLEm_SET
#define SOURCE_TRUNK_MAP_TABLEm_GET BCM56218_A0_SOURCE_TRUNK_MAP_TABLEm_GET
#define SOURCE_TRUNK_MAP_TABLEm_PORT_TYPEf_GET BCM56218_A0_SOURCE_TRUNK_MAP_TABLEm_PORT_TYPEf_GET
#define SOURCE_TRUNK_MAP_TABLEm_PORT_TYPEf_SET BCM56218_A0_SOURCE_TRUNK_MAP_TABLEm_PORT_TYPEf_SET
#define SOURCE_TRUNK_MAP_TABLEm_TGIDf_GET BCM56218_A0_SOURCE_TRUNK_MAP_TABLEm_TGIDf_GET
#define SOURCE_TRUNK_MAP_TABLEm_TGIDf_SET BCM56218_A0_SOURCE_TRUNK_MAP_TABLEm_TGIDf_SET
#define READ_SOURCE_TRUNK_MAP_TABLEm BCM56218_A0_READ_SOURCE_TRUNK_MAP_TABLEm
#define WRITE_SOURCE_TRUNK_MAP_TABLEm BCM56218_A0_WRITE_SOURCE_TRUNK_MAP_TABLEm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_SOURCE_TRUNK_MAP_TABLEm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  SRC_MODID_BLOCK
 * BLOCKS:   IPIPE
 * DESC:     Source Modid based blocking mask table. Index is constructed {port_num(2bits),modid(4bits)}. Port_num can be 0, 1 or 2.
 * SIZE:     7
 * FIELDS:
 *     PORT_0_5_BLOCK_MASK overlay PBM for ports 0-5
 *     CPU_PORT_BLOCK_MASK Block Mask for CPU port
 *     HIGIG_XGE_PORT_BLOCK_MASK Block MASK for HiGig ports
 *     GMII_PORT_BLOCK_MASK Block GMII port
 *     UPLINK_PORT_BLOCK_MASK Block all 1 GE Uplink ports
 *     GE_PORT_BLOCK_MASK Block all 1 GE ports
 *
 ******************************************************************************/
#define BCM56218_A0_SRC_MODID_BLOCKm 0x0e7c0000

#define BCM56218_A0_SRC_MODID_BLOCKm_MIN 0
#define BCM56218_A0_SRC_MODID_BLOCKm_MAX 47
#define BCM56218_A0_SRC_MODID_BLOCKm_CMAX(u) 47
#define BCM56218_A0_SRC_MODID_BLOCKm_SIZE 1

/*
 * This structure should be used to declare and program SRC_MODID_BLOCK.
 *
 */
typedef union BCM56218_A0_SRC_MODID_BLOCKm_s {
	uint32_t v[1];
	uint32_t src_modid_block[1];
	uint32_t _src_modid_block;
} BCM56218_A0_SRC_MODID_BLOCKm_t;

#define BCM56218_A0_SRC_MODID_BLOCKm_CLR(r) (r).src_modid_block[0] = 0
#define BCM56218_A0_SRC_MODID_BLOCKm_SET(r,d) (r).src_modid_block[0] = d
#define BCM56218_A0_SRC_MODID_BLOCKm_GET(r) (r).src_modid_block[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_SRC_MODID_BLOCKm_PORT_0_5_BLOCK_MASKf_GET(r) (((r).src_modid_block[0]) & 0x3f)
#define BCM56218_A0_SRC_MODID_BLOCKm_PORT_0_5_BLOCK_MASKf_SET(r,f) (r).src_modid_block[0]=(((r).src_modid_block[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM56218_A0_SRC_MODID_BLOCKm_CPU_PORT_BLOCK_MASKf_GET(r) (((r).src_modid_block[0]) & 0x1)
#define BCM56218_A0_SRC_MODID_BLOCKm_CPU_PORT_BLOCK_MASKf_SET(r,f) (r).src_modid_block[0]=(((r).src_modid_block[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_SRC_MODID_BLOCKm_HIGIG_XGE_PORT_BLOCK_MASKf_GET(r) ((((r).src_modid_block[0]) >> 1) & 0x3)
#define BCM56218_A0_SRC_MODID_BLOCKm_HIGIG_XGE_PORT_BLOCK_MASKf_SET(r,f) (r).src_modid_block[0]=(((r).src_modid_block[0] & ~((uint32_t)0x3 << 1)) | ((((uint32_t)f) & 0x3) << 1))
#define BCM56218_A0_SRC_MODID_BLOCKm_GMII_PORT_BLOCK_MASKf_GET(r) ((((r).src_modid_block[0]) >> 3) & 0x1)
#define BCM56218_A0_SRC_MODID_BLOCKm_GMII_PORT_BLOCK_MASKf_SET(r,f) (r).src_modid_block[0]=(((r).src_modid_block[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56218_A0_SRC_MODID_BLOCKm_UPLINK_PORT_BLOCK_MASKf_GET(r) ((((r).src_modid_block[0]) >> 4) & 0x3)
#define BCM56218_A0_SRC_MODID_BLOCKm_UPLINK_PORT_BLOCK_MASKf_SET(r,f) (r).src_modid_block[0]=(((r).src_modid_block[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM56218_A0_SRC_MODID_BLOCKm_GE_PORT_BLOCK_MASKf_GET(r) ((((r).src_modid_block[0]) >> 6) & 0x1)
#define BCM56218_A0_SRC_MODID_BLOCKm_GE_PORT_BLOCK_MASKf_SET(r,f) (r).src_modid_block[0]=(((r).src_modid_block[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))

/*
 * These macros can be used to access SRC_MODID_BLOCK.
 *
 */
#define BCM56218_A0_READ_SRC_MODID_BLOCKm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_SRC_MODID_BLOCKm,i,(m._src_modid_block),1)
#define BCM56218_A0_WRITE_SRC_MODID_BLOCKm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_SRC_MODID_BLOCKm,i,&(m._src_modid_block),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SRC_MODID_BLOCKm BCM56218_A0_SRC_MODID_BLOCKm
#define SRC_MODID_BLOCKm_MIN BCM56218_A0_SRC_MODID_BLOCKm_MIN
#define SRC_MODID_BLOCKm_MAX BCM56218_A0_SRC_MODID_BLOCKm_MAX
#define SRC_MODID_BLOCKm_CMAX(u) BCM56218_A0_SRC_MODID_BLOCKm_CMAX(u)
#define SRC_MODID_BLOCKm_SIZE BCM56218_A0_SRC_MODID_BLOCKm_SIZE
typedef BCM56218_A0_SRC_MODID_BLOCKm_t SRC_MODID_BLOCKm_t;
#define SRC_MODID_BLOCKm_CLR BCM56218_A0_SRC_MODID_BLOCKm_CLR
#define SRC_MODID_BLOCKm_SET BCM56218_A0_SRC_MODID_BLOCKm_SET
#define SRC_MODID_BLOCKm_GET BCM56218_A0_SRC_MODID_BLOCKm_GET
#define SRC_MODID_BLOCKm_PORT_0_5_BLOCK_MASKf_GET BCM56218_A0_SRC_MODID_BLOCKm_PORT_0_5_BLOCK_MASKf_GET
#define SRC_MODID_BLOCKm_PORT_0_5_BLOCK_MASKf_SET BCM56218_A0_SRC_MODID_BLOCKm_PORT_0_5_BLOCK_MASKf_SET
#define SRC_MODID_BLOCKm_CPU_PORT_BLOCK_MASKf_GET BCM56218_A0_SRC_MODID_BLOCKm_CPU_PORT_BLOCK_MASKf_GET
#define SRC_MODID_BLOCKm_CPU_PORT_BLOCK_MASKf_SET BCM56218_A0_SRC_MODID_BLOCKm_CPU_PORT_BLOCK_MASKf_SET
#define SRC_MODID_BLOCKm_HIGIG_XGE_PORT_BLOCK_MASKf_GET BCM56218_A0_SRC_MODID_BLOCKm_HIGIG_XGE_PORT_BLOCK_MASKf_GET
#define SRC_MODID_BLOCKm_HIGIG_XGE_PORT_BLOCK_MASKf_SET BCM56218_A0_SRC_MODID_BLOCKm_HIGIG_XGE_PORT_BLOCK_MASKf_SET
#define SRC_MODID_BLOCKm_GMII_PORT_BLOCK_MASKf_GET BCM56218_A0_SRC_MODID_BLOCKm_GMII_PORT_BLOCK_MASKf_GET
#define SRC_MODID_BLOCKm_GMII_PORT_BLOCK_MASKf_SET BCM56218_A0_SRC_MODID_BLOCKm_GMII_PORT_BLOCK_MASKf_SET
#define SRC_MODID_BLOCKm_UPLINK_PORT_BLOCK_MASKf_GET BCM56218_A0_SRC_MODID_BLOCKm_UPLINK_PORT_BLOCK_MASKf_GET
#define SRC_MODID_BLOCKm_UPLINK_PORT_BLOCK_MASKf_SET BCM56218_A0_SRC_MODID_BLOCKm_UPLINK_PORT_BLOCK_MASKf_SET
#define SRC_MODID_BLOCKm_GE_PORT_BLOCK_MASKf_GET BCM56218_A0_SRC_MODID_BLOCKm_GE_PORT_BLOCK_MASKf_GET
#define SRC_MODID_BLOCKm_GE_PORT_BLOCK_MASKf_SET BCM56218_A0_SRC_MODID_BLOCKm_GE_PORT_BLOCK_MASKf_SET
#define READ_SRC_MODID_BLOCKm BCM56218_A0_READ_SRC_MODID_BLOCKm
#define WRITE_SRC_MODID_BLOCKm BCM56218_A0_WRITE_SRC_MODID_BLOCKm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_SRC_MODID_BLOCKm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  STG_TAB
 * BLOCKS:   IPIPE
 * DESC:     Spanning Tree Group state table
 * SIZE:     108
 * FIELDS:
 *     SP_TREE_PORT0    Spanning Tree State for port 0
 *     SP_TREE_PORT1    Spanning Tree State for port 1
 *     SP_TREE_PORT2    Spanning Tree State for port 2
 *     SP_TREE_PORT3    Spanning Tree State for port 3
 *     SP_TREE_PORT4    Spanning Tree State for port 4
 *     SP_TREE_PORT5    Spanning Tree State for port 5
 *     SP_TREE_PORT6    Spanning Tree State for port 6
 *     SP_TREE_PORT7    Spanning Tree State for port 7
 *     SP_TREE_PORT8    Spanning Tree State for port 8
 *     SP_TREE_PORT9    Spanning Tree State for port 9
 *     SP_TREE_PORT10   Spanning Tree State for port 10
 *     SP_TREE_PORT11   Spanning Tree State for port 11
 *     SP_TREE_PORT12   Spanning Tree State for port 12
 *     SP_TREE_PORT13   Spanning Tree State for port 13
 *     SP_TREE_PORT14   Spanning Tree State for port 14
 *     SP_TREE_PORT15   Spanning Tree State for port 15
 *     SP_TREE_PORT16   Spanning Tree State for port 16
 *     SP_TREE_PORT17   Spanning Tree State for port 17
 *     SP_TREE_PORT18   Spanning Tree State for port 18
 *     SP_TREE_PORT19   Spanning Tree State for port 19
 *     SP_TREE_PORT20   Spanning Tree State for port 20
 *     SP_TREE_PORT21   Spanning Tree State for port 21
 *     SP_TREE_PORT22   Spanning Tree State for port 22
 *     SP_TREE_PORT23   Spanning Tree State for port 23
 *     SP_TREE_PORT24   Spanning Tree State for port 24
 *     SP_TREE_PORT25   Spanning Tree State for port 25
 *     SP_TREE_PORT26   Spanning Tree State for port 26
 *     SP_TREE_PORT27   Spanning Tree State for port 27
 *     SP_TREE_PORT28   Spanning Tree State for port 28
 *     SP_TREE_PORT29   Spanning Tree State for port 29
 *     SP_TREE_PORT30   Spanning Tree State for port 30
 *     SP_TREE_PORT31   Spanning Tree State for port 31
 *     SP_TREE_PORT32   Spanning Tree State for port 32
 *     SP_TREE_PORT33   Spanning Tree State for port 33
 *     SP_TREE_PORT34   Spanning Tree State for port 34
 *     SP_TREE_PORT35   Spanning Tree State for port 35
 *     SP_TREE_PORT36   Spanning Tree State for port 36
 *     SP_TREE_PORT37   Spanning Tree State for port 37
 *     SP_TREE_PORT38   Spanning Tree State for port 38
 *     SP_TREE_PORT39   Spanning Tree State for port 39
 *     SP_TREE_PORT40   Spanning Tree State for port 40
 *     SP_TREE_PORT41   Spanning Tree State for port 41
 *     SP_TREE_PORT42   Spanning Tree State for port 42
 *     SP_TREE_PORT43   Spanning Tree State for port 43
 *     SP_TREE_PORT44   Spanning Tree State for port 44
 *     SP_TREE_PORT45   Spanning Tree State for port 45
 *     SP_TREE_PORT46   Spanning Tree State for port 46
 *     SP_TREE_PORT47   Spanning Tree State for port 47
 *     SP_TREE_PORT48   Spanning Tree State for port 48
 *     SP_TREE_PORT49   Spanning Tree State for port 49
 *     SP_TREE_PORT50   Spanning Tree State for port 50
 *     SP_TREE_PORT51   Spanning Tree State for port 51
 *     SP_TREE_PORT52   Spanning Tree State for port 52
 *     SP_TREE_PORT53   Spanning Tree State for port 53
 *
 ******************************************************************************/
#define BCM56218_A0_STG_TABm 0x05710000

#define BCM56218_A0_STG_TABm_MIN 0
#define BCM56218_A0_STG_TABm_MAX 127
#define BCM56218_A0_STG_TABm_CMAX(u) 127
#define BCM56218_A0_STG_TABm_SIZE 14

/*
 * This structure should be used to declare and program STG_TAB.
 *
 */
typedef union BCM56218_A0_STG_TABm_s {
	uint32_t v[4];
	uint32_t stg_tab[4];
	uint32_t _stg_tab;
} BCM56218_A0_STG_TABm_t;

#define BCM56218_A0_STG_TABm_CLR(r) CDK_MEMSET(&((r)._stg_tab), 0, sizeof(BCM56218_A0_STG_TABm_t))
#define BCM56218_A0_STG_TABm_SET(r,i,d) (r).stg_tab[i] = d
#define BCM56218_A0_STG_TABm_GET(r,i) (r).stg_tab[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_STG_TABm_SP_TREE_PORT0f_GET(r) (((r).stg_tab[0]) & 0x3)
#define BCM56218_A0_STG_TABm_SP_TREE_PORT0f_SET(r,f) (r).stg_tab[0]=(((r).stg_tab[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56218_A0_STG_TABm_SP_TREE_PORT1f_GET(r) ((((r).stg_tab[0]) >> 2) & 0x3)
#define BCM56218_A0_STG_TABm_SP_TREE_PORT1f_SET(r,f) (r).stg_tab[0]=(((r).stg_tab[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM56218_A0_STG_TABm_SP_TREE_PORT2f_GET(r) ((((r).stg_tab[0]) >> 4) & 0x3)
#define BCM56218_A0_STG_TABm_SP_TREE_PORT2f_SET(r,f) (r).stg_tab[0]=(((r).stg_tab[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM56218_A0_STG_TABm_SP_TREE_PORT3f_GET(r) ((((r).stg_tab[0]) >> 6) & 0x3)
#define BCM56218_A0_STG_TABm_SP_TREE_PORT3f_SET(r,f) (r).stg_tab[0]=(((r).stg_tab[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM56218_A0_STG_TABm_SP_TREE_PORT4f_GET(r) ((((r).stg_tab[0]) >> 8) & 0x3)
#define BCM56218_A0_STG_TABm_SP_TREE_PORT4f_SET(r,f) (r).stg_tab[0]=(((r).stg_tab[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM56218_A0_STG_TABm_SP_TREE_PORT5f_GET(r) ((((r).stg_tab[0]) >> 10) & 0x3)
#define BCM56218_A0_STG_TABm_SP_TREE_PORT5f_SET(r,f) (r).stg_tab[0]=(((r).stg_tab[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCM56218_A0_STG_TABm_SP_TREE_PORT6f_GET(r) ((((r).stg_tab[0]) >> 12) & 0x3)
#define BCM56218_A0_STG_TABm_SP_TREE_PORT6f_SET(r,f) (r).stg_tab[0]=(((r).stg_tab[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM56218_A0_STG_TABm_SP_TREE_PORT7f_GET(r) ((((r).stg_tab[0]) >> 14) & 0x3)
#define BCM56218_A0_STG_TABm_SP_TREE_PORT7f_SET(r,f) (r).stg_tab[0]=(((r).stg_tab[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCM56218_A0_STG_TABm_SP_TREE_PORT8f_GET(r) ((((r).stg_tab[0]) >> 16) & 0x3)
#define BCM56218_A0_STG_TABm_SP_TREE_PORT8f_SET(r,f) (r).stg_tab[0]=(((r).stg_tab[0] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM56218_A0_STG_TABm_SP_TREE_PORT9f_GET(r) ((((r).stg_tab[0]) >> 18) & 0x3)
#define BCM56218_A0_STG_TABm_SP_TREE_PORT9f_SET(r,f) (r).stg_tab[0]=(((r).stg_tab[0] & ~((uint32_t)0x3 << 18)) | ((((uint32_t)f) & 0x3) << 18))
#define BCM56218_A0_STG_TABm_SP_TREE_PORT10f_GET(r) ((((r).stg_tab[0]) >> 20) & 0x3)
#define BCM56218_A0_STG_TABm_SP_TREE_PORT10f_SET(r,f) (r).stg_tab[0]=(((r).stg_tab[0] & ~((uint32_t)0x3 << 20)) | ((((uint32_t)f) & 0x3) << 20))
#define BCM56218_A0_STG_TABm_SP_TREE_PORT11f_GET(r) ((((r).stg_tab[0]) >> 22) & 0x3)
#define BCM56218_A0_STG_TABm_SP_TREE_PORT11f_SET(r,f) (r).stg_tab[0]=(((r).stg_tab[0] & ~((uint32_t)0x3 << 22)) | ((((uint32_t)f) & 0x3) << 22))
#define BCM56218_A0_STG_TABm_SP_TREE_PORT12f_GET(r) ((((r).stg_tab[0]) >> 24) & 0x3)
#define BCM56218_A0_STG_TABm_SP_TREE_PORT12f_SET(r,f) (r).stg_tab[0]=(((r).stg_tab[0] & ~((uint32_t)0x3 << 24)) | ((((uint32_t)f) & 0x3) << 24))
#define BCM56218_A0_STG_TABm_SP_TREE_PORT13f_GET(r) ((((r).stg_tab[0]) >> 26) & 0x3)
#define BCM56218_A0_STG_TABm_SP_TREE_PORT13f_SET(r,f) (r).stg_tab[0]=(((r).stg_tab[0] & ~((uint32_t)0x3 << 26)) | ((((uint32_t)f) & 0x3) << 26))
#define BCM56218_A0_STG_TABm_SP_TREE_PORT14f_GET(r) ((((r).stg_tab[0]) >> 28) & 0x3)
#define BCM56218_A0_STG_TABm_SP_TREE_PORT14f_SET(r,f) (r).stg_tab[0]=(((r).stg_tab[0] & ~((uint32_t)0x3 << 28)) | ((((uint32_t)f) & 0x3) << 28))
#define BCM56218_A0_STG_TABm_SP_TREE_PORT15f_GET(r) ((((r).stg_tab[0]) >> 30) & 0x3)
#define BCM56218_A0_STG_TABm_SP_TREE_PORT15f_SET(r,f) (r).stg_tab[0]=(((r).stg_tab[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))
#define BCM56218_A0_STG_TABm_SP_TREE_PORT16f_GET(r) (((r).stg_tab[1]) & 0x3)
#define BCM56218_A0_STG_TABm_SP_TREE_PORT16f_SET(r,f) (r).stg_tab[1]=(((r).stg_tab[1] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56218_A0_STG_TABm_SP_TREE_PORT17f_GET(r) ((((r).stg_tab[1]) >> 2) & 0x3)
#define BCM56218_A0_STG_TABm_SP_TREE_PORT17f_SET(r,f) (r).stg_tab[1]=(((r).stg_tab[1] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM56218_A0_STG_TABm_SP_TREE_PORT18f_GET(r) ((((r).stg_tab[1]) >> 4) & 0x3)
#define BCM56218_A0_STG_TABm_SP_TREE_PORT18f_SET(r,f) (r).stg_tab[1]=(((r).stg_tab[1] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM56218_A0_STG_TABm_SP_TREE_PORT19f_GET(r) ((((r).stg_tab[1]) >> 6) & 0x3)
#define BCM56218_A0_STG_TABm_SP_TREE_PORT19f_SET(r,f) (r).stg_tab[1]=(((r).stg_tab[1] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM56218_A0_STG_TABm_SP_TREE_PORT20f_GET(r) ((((r).stg_tab[1]) >> 8) & 0x3)
#define BCM56218_A0_STG_TABm_SP_TREE_PORT20f_SET(r,f) (r).stg_tab[1]=(((r).stg_tab[1] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM56218_A0_STG_TABm_SP_TREE_PORT21f_GET(r) ((((r).stg_tab[1]) >> 10) & 0x3)
#define BCM56218_A0_STG_TABm_SP_TREE_PORT21f_SET(r,f) (r).stg_tab[1]=(((r).stg_tab[1] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCM56218_A0_STG_TABm_SP_TREE_PORT22f_GET(r) ((((r).stg_tab[1]) >> 12) & 0x3)
#define BCM56218_A0_STG_TABm_SP_TREE_PORT22f_SET(r,f) (r).stg_tab[1]=(((r).stg_tab[1] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM56218_A0_STG_TABm_SP_TREE_PORT23f_GET(r) ((((r).stg_tab[1]) >> 14) & 0x3)
#define BCM56218_A0_STG_TABm_SP_TREE_PORT23f_SET(r,f) (r).stg_tab[1]=(((r).stg_tab[1] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCM56218_A0_STG_TABm_SP_TREE_PORT24f_GET(r) ((((r).stg_tab[1]) >> 16) & 0x3)
#define BCM56218_A0_STG_TABm_SP_TREE_PORT24f_SET(r,f) (r).stg_tab[1]=(((r).stg_tab[1] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM56218_A0_STG_TABm_SP_TREE_PORT25f_GET(r) ((((r).stg_tab[1]) >> 18) & 0x3)
#define BCM56218_A0_STG_TABm_SP_TREE_PORT25f_SET(r,f) (r).stg_tab[1]=(((r).stg_tab[1] & ~((uint32_t)0x3 << 18)) | ((((uint32_t)f) & 0x3) << 18))
#define BCM56218_A0_STG_TABm_SP_TREE_PORT26f_GET(r) ((((r).stg_tab[1]) >> 20) & 0x3)
#define BCM56218_A0_STG_TABm_SP_TREE_PORT26f_SET(r,f) (r).stg_tab[1]=(((r).stg_tab[1] & ~((uint32_t)0x3 << 20)) | ((((uint32_t)f) & 0x3) << 20))
#define BCM56218_A0_STG_TABm_SP_TREE_PORT27f_GET(r) ((((r).stg_tab[1]) >> 22) & 0x3)
#define BCM56218_A0_STG_TABm_SP_TREE_PORT27f_SET(r,f) (r).stg_tab[1]=(((r).stg_tab[1] & ~((uint32_t)0x3 << 22)) | ((((uint32_t)f) & 0x3) << 22))
#define BCM56218_A0_STG_TABm_SP_TREE_PORT28f_GET(r) ((((r).stg_tab[1]) >> 24) & 0x3)
#define BCM56218_A0_STG_TABm_SP_TREE_PORT28f_SET(r,f) (r).stg_tab[1]=(((r).stg_tab[1] & ~((uint32_t)0x3 << 24)) | ((((uint32_t)f) & 0x3) << 24))
#define BCM56218_A0_STG_TABm_SP_TREE_PORT29f_GET(r) ((((r).stg_tab[1]) >> 26) & 0x3)
#define BCM56218_A0_STG_TABm_SP_TREE_PORT29f_SET(r,f) (r).stg_tab[1]=(((r).stg_tab[1] & ~((uint32_t)0x3 << 26)) | ((((uint32_t)f) & 0x3) << 26))
#define BCM56218_A0_STG_TABm_SP_TREE_PORT30f_GET(r) ((((r).stg_tab[1]) >> 28) & 0x3)
#define BCM56218_A0_STG_TABm_SP_TREE_PORT30f_SET(r,f) (r).stg_tab[1]=(((r).stg_tab[1] & ~((uint32_t)0x3 << 28)) | ((((uint32_t)f) & 0x3) << 28))
#define BCM56218_A0_STG_TABm_SP_TREE_PORT31f_GET(r) ((((r).stg_tab[1]) >> 30) & 0x3)
#define BCM56218_A0_STG_TABm_SP_TREE_PORT31f_SET(r,f) (r).stg_tab[1]=(((r).stg_tab[1] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))
#define BCM56218_A0_STG_TABm_SP_TREE_PORT32f_GET(r) (((r).stg_tab[2]) & 0x3)
#define BCM56218_A0_STG_TABm_SP_TREE_PORT32f_SET(r,f) (r).stg_tab[2]=(((r).stg_tab[2] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56218_A0_STG_TABm_SP_TREE_PORT33f_GET(r) ((((r).stg_tab[2]) >> 2) & 0x3)
#define BCM56218_A0_STG_TABm_SP_TREE_PORT33f_SET(r,f) (r).stg_tab[2]=(((r).stg_tab[2] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM56218_A0_STG_TABm_SP_TREE_PORT34f_GET(r) ((((r).stg_tab[2]) >> 4) & 0x3)
#define BCM56218_A0_STG_TABm_SP_TREE_PORT34f_SET(r,f) (r).stg_tab[2]=(((r).stg_tab[2] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM56218_A0_STG_TABm_SP_TREE_PORT35f_GET(r) ((((r).stg_tab[2]) >> 6) & 0x3)
#define BCM56218_A0_STG_TABm_SP_TREE_PORT35f_SET(r,f) (r).stg_tab[2]=(((r).stg_tab[2] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM56218_A0_STG_TABm_SP_TREE_PORT36f_GET(r) ((((r).stg_tab[2]) >> 8) & 0x3)
#define BCM56218_A0_STG_TABm_SP_TREE_PORT36f_SET(r,f) (r).stg_tab[2]=(((r).stg_tab[2] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM56218_A0_STG_TABm_SP_TREE_PORT37f_GET(r) ((((r).stg_tab[2]) >> 10) & 0x3)
#define BCM56218_A0_STG_TABm_SP_TREE_PORT37f_SET(r,f) (r).stg_tab[2]=(((r).stg_tab[2] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCM56218_A0_STG_TABm_SP_TREE_PORT38f_GET(r) ((((r).stg_tab[2]) >> 12) & 0x3)
#define BCM56218_A0_STG_TABm_SP_TREE_PORT38f_SET(r,f) (r).stg_tab[2]=(((r).stg_tab[2] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM56218_A0_STG_TABm_SP_TREE_PORT39f_GET(r) ((((r).stg_tab[2]) >> 14) & 0x3)
#define BCM56218_A0_STG_TABm_SP_TREE_PORT39f_SET(r,f) (r).stg_tab[2]=(((r).stg_tab[2] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCM56218_A0_STG_TABm_SP_TREE_PORT40f_GET(r) ((((r).stg_tab[2]) >> 16) & 0x3)
#define BCM56218_A0_STG_TABm_SP_TREE_PORT40f_SET(r,f) (r).stg_tab[2]=(((r).stg_tab[2] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM56218_A0_STG_TABm_SP_TREE_PORT41f_GET(r) ((((r).stg_tab[2]) >> 18) & 0x3)
#define BCM56218_A0_STG_TABm_SP_TREE_PORT41f_SET(r,f) (r).stg_tab[2]=(((r).stg_tab[2] & ~((uint32_t)0x3 << 18)) | ((((uint32_t)f) & 0x3) << 18))
#define BCM56218_A0_STG_TABm_SP_TREE_PORT42f_GET(r) ((((r).stg_tab[2]) >> 20) & 0x3)
#define BCM56218_A0_STG_TABm_SP_TREE_PORT42f_SET(r,f) (r).stg_tab[2]=(((r).stg_tab[2] & ~((uint32_t)0x3 << 20)) | ((((uint32_t)f) & 0x3) << 20))
#define BCM56218_A0_STG_TABm_SP_TREE_PORT43f_GET(r) ((((r).stg_tab[2]) >> 22) & 0x3)
#define BCM56218_A0_STG_TABm_SP_TREE_PORT43f_SET(r,f) (r).stg_tab[2]=(((r).stg_tab[2] & ~((uint32_t)0x3 << 22)) | ((((uint32_t)f) & 0x3) << 22))
#define BCM56218_A0_STG_TABm_SP_TREE_PORT44f_GET(r) ((((r).stg_tab[2]) >> 24) & 0x3)
#define BCM56218_A0_STG_TABm_SP_TREE_PORT44f_SET(r,f) (r).stg_tab[2]=(((r).stg_tab[2] & ~((uint32_t)0x3 << 24)) | ((((uint32_t)f) & 0x3) << 24))
#define BCM56218_A0_STG_TABm_SP_TREE_PORT45f_GET(r) ((((r).stg_tab[2]) >> 26) & 0x3)
#define BCM56218_A0_STG_TABm_SP_TREE_PORT45f_SET(r,f) (r).stg_tab[2]=(((r).stg_tab[2] & ~((uint32_t)0x3 << 26)) | ((((uint32_t)f) & 0x3) << 26))
#define BCM56218_A0_STG_TABm_SP_TREE_PORT46f_GET(r) ((((r).stg_tab[2]) >> 28) & 0x3)
#define BCM56218_A0_STG_TABm_SP_TREE_PORT46f_SET(r,f) (r).stg_tab[2]=(((r).stg_tab[2] & ~((uint32_t)0x3 << 28)) | ((((uint32_t)f) & 0x3) << 28))
#define BCM56218_A0_STG_TABm_SP_TREE_PORT47f_GET(r) ((((r).stg_tab[2]) >> 30) & 0x3)
#define BCM56218_A0_STG_TABm_SP_TREE_PORT47f_SET(r,f) (r).stg_tab[2]=(((r).stg_tab[2] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))
#define BCM56218_A0_STG_TABm_SP_TREE_PORT48f_GET(r) (((r).stg_tab[3]) & 0x3)
#define BCM56218_A0_STG_TABm_SP_TREE_PORT48f_SET(r,f) (r).stg_tab[3]=(((r).stg_tab[3] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56218_A0_STG_TABm_SP_TREE_PORT49f_GET(r) ((((r).stg_tab[3]) >> 2) & 0x3)
#define BCM56218_A0_STG_TABm_SP_TREE_PORT49f_SET(r,f) (r).stg_tab[3]=(((r).stg_tab[3] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM56218_A0_STG_TABm_SP_TREE_PORT50f_GET(r) ((((r).stg_tab[3]) >> 4) & 0x3)
#define BCM56218_A0_STG_TABm_SP_TREE_PORT50f_SET(r,f) (r).stg_tab[3]=(((r).stg_tab[3] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM56218_A0_STG_TABm_SP_TREE_PORT51f_GET(r) ((((r).stg_tab[3]) >> 6) & 0x3)
#define BCM56218_A0_STG_TABm_SP_TREE_PORT51f_SET(r,f) (r).stg_tab[3]=(((r).stg_tab[3] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM56218_A0_STG_TABm_SP_TREE_PORT52f_GET(r) ((((r).stg_tab[3]) >> 8) & 0x3)
#define BCM56218_A0_STG_TABm_SP_TREE_PORT52f_SET(r,f) (r).stg_tab[3]=(((r).stg_tab[3] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM56218_A0_STG_TABm_SP_TREE_PORT53f_GET(r) ((((r).stg_tab[3]) >> 10) & 0x3)
#define BCM56218_A0_STG_TABm_SP_TREE_PORT53f_SET(r,f) (r).stg_tab[3]=(((r).stg_tab[3] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))

/*
 * These macros can be used to access STG_TAB.
 *
 */
#define BCM56218_A0_READ_STG_TABm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_STG_TABm,i,(m._stg_tab),4)
#define BCM56218_A0_WRITE_STG_TABm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_STG_TABm,i,&(m._stg_tab),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define STG_TABm BCM56218_A0_STG_TABm
#define STG_TABm_MIN BCM56218_A0_STG_TABm_MIN
#define STG_TABm_MAX BCM56218_A0_STG_TABm_MAX
#define STG_TABm_CMAX(u) BCM56218_A0_STG_TABm_CMAX(u)
#define STG_TABm_SIZE BCM56218_A0_STG_TABm_SIZE
typedef BCM56218_A0_STG_TABm_t STG_TABm_t;
#define STG_TABm_CLR BCM56218_A0_STG_TABm_CLR
#define STG_TABm_SET BCM56218_A0_STG_TABm_SET
#define STG_TABm_GET BCM56218_A0_STG_TABm_GET
#define STG_TABm_SP_TREE_PORT0f_GET BCM56218_A0_STG_TABm_SP_TREE_PORT0f_GET
#define STG_TABm_SP_TREE_PORT0f_SET BCM56218_A0_STG_TABm_SP_TREE_PORT0f_SET
#define STG_TABm_SP_TREE_PORT1f_GET BCM56218_A0_STG_TABm_SP_TREE_PORT1f_GET
#define STG_TABm_SP_TREE_PORT1f_SET BCM56218_A0_STG_TABm_SP_TREE_PORT1f_SET
#define STG_TABm_SP_TREE_PORT2f_GET BCM56218_A0_STG_TABm_SP_TREE_PORT2f_GET
#define STG_TABm_SP_TREE_PORT2f_SET BCM56218_A0_STG_TABm_SP_TREE_PORT2f_SET
#define STG_TABm_SP_TREE_PORT3f_GET BCM56218_A0_STG_TABm_SP_TREE_PORT3f_GET
#define STG_TABm_SP_TREE_PORT3f_SET BCM56218_A0_STG_TABm_SP_TREE_PORT3f_SET
#define STG_TABm_SP_TREE_PORT4f_GET BCM56218_A0_STG_TABm_SP_TREE_PORT4f_GET
#define STG_TABm_SP_TREE_PORT4f_SET BCM56218_A0_STG_TABm_SP_TREE_PORT4f_SET
#define STG_TABm_SP_TREE_PORT5f_GET BCM56218_A0_STG_TABm_SP_TREE_PORT5f_GET
#define STG_TABm_SP_TREE_PORT5f_SET BCM56218_A0_STG_TABm_SP_TREE_PORT5f_SET
#define STG_TABm_SP_TREE_PORT6f_GET BCM56218_A0_STG_TABm_SP_TREE_PORT6f_GET
#define STG_TABm_SP_TREE_PORT6f_SET BCM56218_A0_STG_TABm_SP_TREE_PORT6f_SET
#define STG_TABm_SP_TREE_PORT7f_GET BCM56218_A0_STG_TABm_SP_TREE_PORT7f_GET
#define STG_TABm_SP_TREE_PORT7f_SET BCM56218_A0_STG_TABm_SP_TREE_PORT7f_SET
#define STG_TABm_SP_TREE_PORT8f_GET BCM56218_A0_STG_TABm_SP_TREE_PORT8f_GET
#define STG_TABm_SP_TREE_PORT8f_SET BCM56218_A0_STG_TABm_SP_TREE_PORT8f_SET
#define STG_TABm_SP_TREE_PORT9f_GET BCM56218_A0_STG_TABm_SP_TREE_PORT9f_GET
#define STG_TABm_SP_TREE_PORT9f_SET BCM56218_A0_STG_TABm_SP_TREE_PORT9f_SET
#define STG_TABm_SP_TREE_PORT10f_GET BCM56218_A0_STG_TABm_SP_TREE_PORT10f_GET
#define STG_TABm_SP_TREE_PORT10f_SET BCM56218_A0_STG_TABm_SP_TREE_PORT10f_SET
#define STG_TABm_SP_TREE_PORT11f_GET BCM56218_A0_STG_TABm_SP_TREE_PORT11f_GET
#define STG_TABm_SP_TREE_PORT11f_SET BCM56218_A0_STG_TABm_SP_TREE_PORT11f_SET
#define STG_TABm_SP_TREE_PORT12f_GET BCM56218_A0_STG_TABm_SP_TREE_PORT12f_GET
#define STG_TABm_SP_TREE_PORT12f_SET BCM56218_A0_STG_TABm_SP_TREE_PORT12f_SET
#define STG_TABm_SP_TREE_PORT13f_GET BCM56218_A0_STG_TABm_SP_TREE_PORT13f_GET
#define STG_TABm_SP_TREE_PORT13f_SET BCM56218_A0_STG_TABm_SP_TREE_PORT13f_SET
#define STG_TABm_SP_TREE_PORT14f_GET BCM56218_A0_STG_TABm_SP_TREE_PORT14f_GET
#define STG_TABm_SP_TREE_PORT14f_SET BCM56218_A0_STG_TABm_SP_TREE_PORT14f_SET
#define STG_TABm_SP_TREE_PORT15f_GET BCM56218_A0_STG_TABm_SP_TREE_PORT15f_GET
#define STG_TABm_SP_TREE_PORT15f_SET BCM56218_A0_STG_TABm_SP_TREE_PORT15f_SET
#define STG_TABm_SP_TREE_PORT16f_GET BCM56218_A0_STG_TABm_SP_TREE_PORT16f_GET
#define STG_TABm_SP_TREE_PORT16f_SET BCM56218_A0_STG_TABm_SP_TREE_PORT16f_SET
#define STG_TABm_SP_TREE_PORT17f_GET BCM56218_A0_STG_TABm_SP_TREE_PORT17f_GET
#define STG_TABm_SP_TREE_PORT17f_SET BCM56218_A0_STG_TABm_SP_TREE_PORT17f_SET
#define STG_TABm_SP_TREE_PORT18f_GET BCM56218_A0_STG_TABm_SP_TREE_PORT18f_GET
#define STG_TABm_SP_TREE_PORT18f_SET BCM56218_A0_STG_TABm_SP_TREE_PORT18f_SET
#define STG_TABm_SP_TREE_PORT19f_GET BCM56218_A0_STG_TABm_SP_TREE_PORT19f_GET
#define STG_TABm_SP_TREE_PORT19f_SET BCM56218_A0_STG_TABm_SP_TREE_PORT19f_SET
#define STG_TABm_SP_TREE_PORT20f_GET BCM56218_A0_STG_TABm_SP_TREE_PORT20f_GET
#define STG_TABm_SP_TREE_PORT20f_SET BCM56218_A0_STG_TABm_SP_TREE_PORT20f_SET
#define STG_TABm_SP_TREE_PORT21f_GET BCM56218_A0_STG_TABm_SP_TREE_PORT21f_GET
#define STG_TABm_SP_TREE_PORT21f_SET BCM56218_A0_STG_TABm_SP_TREE_PORT21f_SET
#define STG_TABm_SP_TREE_PORT22f_GET BCM56218_A0_STG_TABm_SP_TREE_PORT22f_GET
#define STG_TABm_SP_TREE_PORT22f_SET BCM56218_A0_STG_TABm_SP_TREE_PORT22f_SET
#define STG_TABm_SP_TREE_PORT23f_GET BCM56218_A0_STG_TABm_SP_TREE_PORT23f_GET
#define STG_TABm_SP_TREE_PORT23f_SET BCM56218_A0_STG_TABm_SP_TREE_PORT23f_SET
#define STG_TABm_SP_TREE_PORT24f_GET BCM56218_A0_STG_TABm_SP_TREE_PORT24f_GET
#define STG_TABm_SP_TREE_PORT24f_SET BCM56218_A0_STG_TABm_SP_TREE_PORT24f_SET
#define STG_TABm_SP_TREE_PORT25f_GET BCM56218_A0_STG_TABm_SP_TREE_PORT25f_GET
#define STG_TABm_SP_TREE_PORT25f_SET BCM56218_A0_STG_TABm_SP_TREE_PORT25f_SET
#define STG_TABm_SP_TREE_PORT26f_GET BCM56218_A0_STG_TABm_SP_TREE_PORT26f_GET
#define STG_TABm_SP_TREE_PORT26f_SET BCM56218_A0_STG_TABm_SP_TREE_PORT26f_SET
#define STG_TABm_SP_TREE_PORT27f_GET BCM56218_A0_STG_TABm_SP_TREE_PORT27f_GET
#define STG_TABm_SP_TREE_PORT27f_SET BCM56218_A0_STG_TABm_SP_TREE_PORT27f_SET
#define STG_TABm_SP_TREE_PORT28f_GET BCM56218_A0_STG_TABm_SP_TREE_PORT28f_GET
#define STG_TABm_SP_TREE_PORT28f_SET BCM56218_A0_STG_TABm_SP_TREE_PORT28f_SET
#define STG_TABm_SP_TREE_PORT29f_GET BCM56218_A0_STG_TABm_SP_TREE_PORT29f_GET
#define STG_TABm_SP_TREE_PORT29f_SET BCM56218_A0_STG_TABm_SP_TREE_PORT29f_SET
#define STG_TABm_SP_TREE_PORT30f_GET BCM56218_A0_STG_TABm_SP_TREE_PORT30f_GET
#define STG_TABm_SP_TREE_PORT30f_SET BCM56218_A0_STG_TABm_SP_TREE_PORT30f_SET
#define STG_TABm_SP_TREE_PORT31f_GET BCM56218_A0_STG_TABm_SP_TREE_PORT31f_GET
#define STG_TABm_SP_TREE_PORT31f_SET BCM56218_A0_STG_TABm_SP_TREE_PORT31f_SET
#define STG_TABm_SP_TREE_PORT32f_GET BCM56218_A0_STG_TABm_SP_TREE_PORT32f_GET
#define STG_TABm_SP_TREE_PORT32f_SET BCM56218_A0_STG_TABm_SP_TREE_PORT32f_SET
#define STG_TABm_SP_TREE_PORT33f_GET BCM56218_A0_STG_TABm_SP_TREE_PORT33f_GET
#define STG_TABm_SP_TREE_PORT33f_SET BCM56218_A0_STG_TABm_SP_TREE_PORT33f_SET
#define STG_TABm_SP_TREE_PORT34f_GET BCM56218_A0_STG_TABm_SP_TREE_PORT34f_GET
#define STG_TABm_SP_TREE_PORT34f_SET BCM56218_A0_STG_TABm_SP_TREE_PORT34f_SET
#define STG_TABm_SP_TREE_PORT35f_GET BCM56218_A0_STG_TABm_SP_TREE_PORT35f_GET
#define STG_TABm_SP_TREE_PORT35f_SET BCM56218_A0_STG_TABm_SP_TREE_PORT35f_SET
#define STG_TABm_SP_TREE_PORT36f_GET BCM56218_A0_STG_TABm_SP_TREE_PORT36f_GET
#define STG_TABm_SP_TREE_PORT36f_SET BCM56218_A0_STG_TABm_SP_TREE_PORT36f_SET
#define STG_TABm_SP_TREE_PORT37f_GET BCM56218_A0_STG_TABm_SP_TREE_PORT37f_GET
#define STG_TABm_SP_TREE_PORT37f_SET BCM56218_A0_STG_TABm_SP_TREE_PORT37f_SET
#define STG_TABm_SP_TREE_PORT38f_GET BCM56218_A0_STG_TABm_SP_TREE_PORT38f_GET
#define STG_TABm_SP_TREE_PORT38f_SET BCM56218_A0_STG_TABm_SP_TREE_PORT38f_SET
#define STG_TABm_SP_TREE_PORT39f_GET BCM56218_A0_STG_TABm_SP_TREE_PORT39f_GET
#define STG_TABm_SP_TREE_PORT39f_SET BCM56218_A0_STG_TABm_SP_TREE_PORT39f_SET
#define STG_TABm_SP_TREE_PORT40f_GET BCM56218_A0_STG_TABm_SP_TREE_PORT40f_GET
#define STG_TABm_SP_TREE_PORT40f_SET BCM56218_A0_STG_TABm_SP_TREE_PORT40f_SET
#define STG_TABm_SP_TREE_PORT41f_GET BCM56218_A0_STG_TABm_SP_TREE_PORT41f_GET
#define STG_TABm_SP_TREE_PORT41f_SET BCM56218_A0_STG_TABm_SP_TREE_PORT41f_SET
#define STG_TABm_SP_TREE_PORT42f_GET BCM56218_A0_STG_TABm_SP_TREE_PORT42f_GET
#define STG_TABm_SP_TREE_PORT42f_SET BCM56218_A0_STG_TABm_SP_TREE_PORT42f_SET
#define STG_TABm_SP_TREE_PORT43f_GET BCM56218_A0_STG_TABm_SP_TREE_PORT43f_GET
#define STG_TABm_SP_TREE_PORT43f_SET BCM56218_A0_STG_TABm_SP_TREE_PORT43f_SET
#define STG_TABm_SP_TREE_PORT44f_GET BCM56218_A0_STG_TABm_SP_TREE_PORT44f_GET
#define STG_TABm_SP_TREE_PORT44f_SET BCM56218_A0_STG_TABm_SP_TREE_PORT44f_SET
#define STG_TABm_SP_TREE_PORT45f_GET BCM56218_A0_STG_TABm_SP_TREE_PORT45f_GET
#define STG_TABm_SP_TREE_PORT45f_SET BCM56218_A0_STG_TABm_SP_TREE_PORT45f_SET
#define STG_TABm_SP_TREE_PORT46f_GET BCM56218_A0_STG_TABm_SP_TREE_PORT46f_GET
#define STG_TABm_SP_TREE_PORT46f_SET BCM56218_A0_STG_TABm_SP_TREE_PORT46f_SET
#define STG_TABm_SP_TREE_PORT47f_GET BCM56218_A0_STG_TABm_SP_TREE_PORT47f_GET
#define STG_TABm_SP_TREE_PORT47f_SET BCM56218_A0_STG_TABm_SP_TREE_PORT47f_SET
#define STG_TABm_SP_TREE_PORT48f_GET BCM56218_A0_STG_TABm_SP_TREE_PORT48f_GET
#define STG_TABm_SP_TREE_PORT48f_SET BCM56218_A0_STG_TABm_SP_TREE_PORT48f_SET
#define STG_TABm_SP_TREE_PORT49f_GET BCM56218_A0_STG_TABm_SP_TREE_PORT49f_GET
#define STG_TABm_SP_TREE_PORT49f_SET BCM56218_A0_STG_TABm_SP_TREE_PORT49f_SET
#define STG_TABm_SP_TREE_PORT50f_GET BCM56218_A0_STG_TABm_SP_TREE_PORT50f_GET
#define STG_TABm_SP_TREE_PORT50f_SET BCM56218_A0_STG_TABm_SP_TREE_PORT50f_SET
#define STG_TABm_SP_TREE_PORT51f_GET BCM56218_A0_STG_TABm_SP_TREE_PORT51f_GET
#define STG_TABm_SP_TREE_PORT51f_SET BCM56218_A0_STG_TABm_SP_TREE_PORT51f_SET
#define STG_TABm_SP_TREE_PORT52f_GET BCM56218_A0_STG_TABm_SP_TREE_PORT52f_GET
#define STG_TABm_SP_TREE_PORT52f_SET BCM56218_A0_STG_TABm_SP_TREE_PORT52f_SET
#define STG_TABm_SP_TREE_PORT53f_GET BCM56218_A0_STG_TABm_SP_TREE_PORT53f_GET
#define STG_TABm_SP_TREE_PORT53f_SET BCM56218_A0_STG_TABm_SP_TREE_PORT53f_SET
#define READ_STG_TABm BCM56218_A0_READ_STG_TABm
#define WRITE_STG_TABm BCM56218_A0_WRITE_STG_TABm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_STG_TABm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  SYS_MAC_ACTION
 * BLOCKS:   IPIPE
 * DESC:     Actions control when the MAC_COUNT exceeds the LIMIT
 * SIZE:     32
 * FIELDS:
 *     MAC_LIMIT_USE_SYS_ACTION  The action priority control bit that is used when both port/LAG & System MAC limits are exceeded.
 *     OVER_LIMIT_TOCPU The copy to CPU action control bit used when the count exceeds the SYS_MAC_LIMIT 
 *     OVER_LIMIT_DROP  The drop action control bit used when the SYS_MAC_COUNT exceeds the SYS_MAC_LIMIT
 *
 ******************************************************************************/
#define BCM56218_A0_SYS_MAC_ACTIONr 0x0b78000a

#define BCM56218_A0_SYS_MAC_ACTIONr_SIZE 4

/*
 * This structure should be used to declare and program SYS_MAC_ACTION.
 *
 */
typedef union BCM56218_A0_SYS_MAC_ACTIONr_s {
	uint32_t v[1];
	uint32_t sys_mac_action[1];
	uint32_t _sys_mac_action;
} BCM56218_A0_SYS_MAC_ACTIONr_t;

#define BCM56218_A0_SYS_MAC_ACTIONr_CLR(r) (r).sys_mac_action[0] = 0
#define BCM56218_A0_SYS_MAC_ACTIONr_SET(r,d) (r).sys_mac_action[0] = d
#define BCM56218_A0_SYS_MAC_ACTIONr_GET(r) (r).sys_mac_action[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_SYS_MAC_ACTIONr_MAC_LIMIT_USE_SYS_ACTIONf_GET(r) (((r).sys_mac_action[0]) & 0x1)
#define BCM56218_A0_SYS_MAC_ACTIONr_MAC_LIMIT_USE_SYS_ACTIONf_SET(r,f) (r).sys_mac_action[0]=(((r).sys_mac_action[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_SYS_MAC_ACTIONr_OVER_LIMIT_TOCPUf_GET(r) ((((r).sys_mac_action[0]) >> 1) & 0x1)
#define BCM56218_A0_SYS_MAC_ACTIONr_OVER_LIMIT_TOCPUf_SET(r,f) (r).sys_mac_action[0]=(((r).sys_mac_action[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_SYS_MAC_ACTIONr_OVER_LIMIT_DROPf_GET(r) ((((r).sys_mac_action[0]) >> 2) & 0x1)
#define BCM56218_A0_SYS_MAC_ACTIONr_OVER_LIMIT_DROPf_SET(r,f) (r).sys_mac_action[0]=(((r).sys_mac_action[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))

/*
 * These macros can be used to access SYS_MAC_ACTION.
 *
 */
#define BCM56218_A0_READ_SYS_MAC_ACTIONr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_SYS_MAC_ACTIONr,(r._sys_mac_action))
#define BCM56218_A0_WRITE_SYS_MAC_ACTIONr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_SYS_MAC_ACTIONr,&(r._sys_mac_action))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SYS_MAC_ACTIONr BCM56218_A0_SYS_MAC_ACTIONr
#define SYS_MAC_ACTIONr_SIZE BCM56218_A0_SYS_MAC_ACTIONr_SIZE
typedef BCM56218_A0_SYS_MAC_ACTIONr_t SYS_MAC_ACTIONr_t;
#define SYS_MAC_ACTIONr_CLR BCM56218_A0_SYS_MAC_ACTIONr_CLR
#define SYS_MAC_ACTIONr_SET BCM56218_A0_SYS_MAC_ACTIONr_SET
#define SYS_MAC_ACTIONr_GET BCM56218_A0_SYS_MAC_ACTIONr_GET
#define SYS_MAC_ACTIONr_MAC_LIMIT_USE_SYS_ACTIONf_GET BCM56218_A0_SYS_MAC_ACTIONr_MAC_LIMIT_USE_SYS_ACTIONf_GET
#define SYS_MAC_ACTIONr_MAC_LIMIT_USE_SYS_ACTIONf_SET BCM56218_A0_SYS_MAC_ACTIONr_MAC_LIMIT_USE_SYS_ACTIONf_SET
#define SYS_MAC_ACTIONr_OVER_LIMIT_TOCPUf_GET BCM56218_A0_SYS_MAC_ACTIONr_OVER_LIMIT_TOCPUf_GET
#define SYS_MAC_ACTIONr_OVER_LIMIT_TOCPUf_SET BCM56218_A0_SYS_MAC_ACTIONr_OVER_LIMIT_TOCPUf_SET
#define SYS_MAC_ACTIONr_OVER_LIMIT_DROPf_GET BCM56218_A0_SYS_MAC_ACTIONr_OVER_LIMIT_DROPf_GET
#define SYS_MAC_ACTIONr_OVER_LIMIT_DROPf_SET BCM56218_A0_SYS_MAC_ACTIONr_OVER_LIMIT_DROPf_SET
#define READ_SYS_MAC_ACTIONr BCM56218_A0_READ_SYS_MAC_ACTIONr
#define WRITE_SYS_MAC_ACTIONr BCM56218_A0_WRITE_SYS_MAC_ACTIONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_SYS_MAC_ACTIONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  SYS_MAC_COUNT
 * BLOCKS:   IPIPE
 * DESC:     sytem MAC counts update by the H/W
 * SIZE:     32
 * FIELDS:
 *     SYS_MAC_COUNT    This register has the sytem MAC counts update by the H/W. 
 *
 ******************************************************************************/
#define BCM56218_A0_SYS_MAC_COUNTr 0x0678000e

#define BCM56218_A0_SYS_MAC_COUNTr_SIZE 4

/*
 * This structure should be used to declare and program SYS_MAC_COUNT.
 *
 */
typedef union BCM56218_A0_SYS_MAC_COUNTr_s {
	uint32_t v[1];
	uint32_t sys_mac_count[1];
	uint32_t _sys_mac_count;
} BCM56218_A0_SYS_MAC_COUNTr_t;

#define BCM56218_A0_SYS_MAC_COUNTr_CLR(r) (r).sys_mac_count[0] = 0
#define BCM56218_A0_SYS_MAC_COUNTr_SET(r,d) (r).sys_mac_count[0] = d
#define BCM56218_A0_SYS_MAC_COUNTr_GET(r) (r).sys_mac_count[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_SYS_MAC_COUNTr_SYS_MAC_COUNTf_GET(r) (((r).sys_mac_count[0]) & 0x1fff)
#define BCM56218_A0_SYS_MAC_COUNTr_SYS_MAC_COUNTf_SET(r,f) (r).sys_mac_count[0]=(((r).sys_mac_count[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))

/*
 * These macros can be used to access SYS_MAC_COUNT.
 *
 */
#define BCM56218_A0_READ_SYS_MAC_COUNTr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_SYS_MAC_COUNTr,(r._sys_mac_count))
#define BCM56218_A0_WRITE_SYS_MAC_COUNTr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_SYS_MAC_COUNTr,&(r._sys_mac_count))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SYS_MAC_COUNTr BCM56218_A0_SYS_MAC_COUNTr
#define SYS_MAC_COUNTr_SIZE BCM56218_A0_SYS_MAC_COUNTr_SIZE
typedef BCM56218_A0_SYS_MAC_COUNTr_t SYS_MAC_COUNTr_t;
#define SYS_MAC_COUNTr_CLR BCM56218_A0_SYS_MAC_COUNTr_CLR
#define SYS_MAC_COUNTr_SET BCM56218_A0_SYS_MAC_COUNTr_SET
#define SYS_MAC_COUNTr_GET BCM56218_A0_SYS_MAC_COUNTr_GET
#define SYS_MAC_COUNTr_SYS_MAC_COUNTf_GET BCM56218_A0_SYS_MAC_COUNTr_SYS_MAC_COUNTf_GET
#define SYS_MAC_COUNTr_SYS_MAC_COUNTf_SET BCM56218_A0_SYS_MAC_COUNTr_SYS_MAC_COUNTf_SET
#define READ_SYS_MAC_COUNTr BCM56218_A0_READ_SYS_MAC_COUNTr
#define WRITE_SYS_MAC_COUNTr BCM56218_A0_WRITE_SYS_MAC_COUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_SYS_MAC_COUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  SYS_MAC_LIMIT
 * BLOCKS:   IPIPE
 * DESC:     sytem MAC counts limit 
 * SIZE:     32
 * FIELDS:
 *     SYS_MAC_LIMIT    the system MAC count limit value that needs to be programmed by the user.
 *
 ******************************************************************************/
#define BCM56218_A0_SYS_MAC_LIMITr 0x0678000f

#define BCM56218_A0_SYS_MAC_LIMITr_SIZE 4

/*
 * This structure should be used to declare and program SYS_MAC_LIMIT.
 *
 */
typedef union BCM56218_A0_SYS_MAC_LIMITr_s {
	uint32_t v[1];
	uint32_t sys_mac_limit[1];
	uint32_t _sys_mac_limit;
} BCM56218_A0_SYS_MAC_LIMITr_t;

#define BCM56218_A0_SYS_MAC_LIMITr_CLR(r) (r).sys_mac_limit[0] = 0
#define BCM56218_A0_SYS_MAC_LIMITr_SET(r,d) (r).sys_mac_limit[0] = d
#define BCM56218_A0_SYS_MAC_LIMITr_GET(r) (r).sys_mac_limit[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_SYS_MAC_LIMITr_SYS_MAC_LIMITf_GET(r) (((r).sys_mac_limit[0]) & 0x3fff)
#define BCM56218_A0_SYS_MAC_LIMITr_SYS_MAC_LIMITf_SET(r,f) (r).sys_mac_limit[0]=(((r).sys_mac_limit[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access SYS_MAC_LIMIT.
 *
 */
#define BCM56218_A0_READ_SYS_MAC_LIMITr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_SYS_MAC_LIMITr,(r._sys_mac_limit))
#define BCM56218_A0_WRITE_SYS_MAC_LIMITr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_SYS_MAC_LIMITr,&(r._sys_mac_limit))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SYS_MAC_LIMITr BCM56218_A0_SYS_MAC_LIMITr
#define SYS_MAC_LIMITr_SIZE BCM56218_A0_SYS_MAC_LIMITr_SIZE
typedef BCM56218_A0_SYS_MAC_LIMITr_t SYS_MAC_LIMITr_t;
#define SYS_MAC_LIMITr_CLR BCM56218_A0_SYS_MAC_LIMITr_CLR
#define SYS_MAC_LIMITr_SET BCM56218_A0_SYS_MAC_LIMITr_SET
#define SYS_MAC_LIMITr_GET BCM56218_A0_SYS_MAC_LIMITr_GET
#define SYS_MAC_LIMITr_SYS_MAC_LIMITf_GET BCM56218_A0_SYS_MAC_LIMITr_SYS_MAC_LIMITf_GET
#define SYS_MAC_LIMITr_SYS_MAC_LIMITf_SET BCM56218_A0_SYS_MAC_LIMITr_SYS_MAC_LIMITf_SET
#define READ_SYS_MAC_LIMITr BCM56218_A0_READ_SYS_MAC_LIMITr
#define WRITE_SYS_MAC_LIMITr BCM56218_A0_WRITE_SYS_MAC_LIMITr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_SYS_MAC_LIMITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  TDBGC0
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #0
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_TDBGC0r 0x0a900000

#define BCM56218_A0_TDBGC0r_SIZE 4

/*
 * This structure should be used to declare and program TDBGC0.
 *
 */
typedef union BCM56218_A0_TDBGC0r_s {
	uint32_t v[1];
	uint32_t tdbgc0[1];
	uint32_t _tdbgc0;
} BCM56218_A0_TDBGC0r_t;

#define BCM56218_A0_TDBGC0r_CLR(r) (r).tdbgc0[0] = 0
#define BCM56218_A0_TDBGC0r_SET(r,d) (r).tdbgc0[0] = d
#define BCM56218_A0_TDBGC0r_GET(r) (r).tdbgc0[0]


/*
 * These macros can be used to access TDBGC0.
 *
 */
#define BCM56218_A0_READ_TDBGC0r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_TDBGC0r,(r._tdbgc0))
#define BCM56218_A0_WRITE_TDBGC0r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_TDBGC0r,&(r._tdbgc0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC0r BCM56218_A0_TDBGC0r
#define TDBGC0r_SIZE BCM56218_A0_TDBGC0r_SIZE
typedef BCM56218_A0_TDBGC0r_t TDBGC0r_t;
#define TDBGC0r_CLR BCM56218_A0_TDBGC0r_CLR
#define TDBGC0r_SET BCM56218_A0_TDBGC0r_SET
#define TDBGC0r_GET BCM56218_A0_TDBGC0r_GET
#define READ_TDBGC0r BCM56218_A0_READ_TDBGC0r
#define WRITE_TDBGC0r BCM56218_A0_WRITE_TDBGC0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_TDBGC0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  TDBGC0_SELECT
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #0 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The TDBGC0_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM56218_A0_TDBGC0_SELECTr 0x0a980020

#define BCM56218_A0_TDBGC0_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program TDBGC0_SELECT.
 *
 */
typedef union BCM56218_A0_TDBGC0_SELECTr_s {
	uint32_t v[1];
	uint32_t tdbgc0_select[1];
	uint32_t _tdbgc0_select;
} BCM56218_A0_TDBGC0_SELECTr_t;

#define BCM56218_A0_TDBGC0_SELECTr_CLR(r) (r).tdbgc0_select[0] = 0
#define BCM56218_A0_TDBGC0_SELECTr_SET(r,d) (r).tdbgc0_select[0] = d
#define BCM56218_A0_TDBGC0_SELECTr_GET(r) (r).tdbgc0_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_TDBGC0_SELECTr_BITMAPf_GET(r) (((r).tdbgc0_select[0]) & 0x1fffff)
#define BCM56218_A0_TDBGC0_SELECTr_BITMAPf_SET(r,f) (r).tdbgc0_select[0]=(((r).tdbgc0_select[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access TDBGC0_SELECT.
 *
 */
#define BCM56218_A0_READ_TDBGC0_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_TDBGC0_SELECTr,(r._tdbgc0_select))
#define BCM56218_A0_WRITE_TDBGC0_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_TDBGC0_SELECTr,&(r._tdbgc0_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC0_SELECTr BCM56218_A0_TDBGC0_SELECTr
#define TDBGC0_SELECTr_SIZE BCM56218_A0_TDBGC0_SELECTr_SIZE
typedef BCM56218_A0_TDBGC0_SELECTr_t TDBGC0_SELECTr_t;
#define TDBGC0_SELECTr_CLR BCM56218_A0_TDBGC0_SELECTr_CLR
#define TDBGC0_SELECTr_SET BCM56218_A0_TDBGC0_SELECTr_SET
#define TDBGC0_SELECTr_GET BCM56218_A0_TDBGC0_SELECTr_GET
#define TDBGC0_SELECTr_BITMAPf_GET BCM56218_A0_TDBGC0_SELECTr_BITMAPf_GET
#define TDBGC0_SELECTr_BITMAPf_SET BCM56218_A0_TDBGC0_SELECTr_BITMAPf_SET
#define READ_TDBGC0_SELECTr BCM56218_A0_READ_TDBGC0_SELECTr
#define WRITE_TDBGC0_SELECTr BCM56218_A0_WRITE_TDBGC0_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_TDBGC0_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  TDBGC1
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #1
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_TDBGC1r 0x0a900001

#define BCM56218_A0_TDBGC1r_SIZE 4

/*
 * This structure should be used to declare and program TDBGC1.
 *
 */
typedef union BCM56218_A0_TDBGC1r_s {
	uint32_t v[1];
	uint32_t tdbgc1[1];
	uint32_t _tdbgc1;
} BCM56218_A0_TDBGC1r_t;

#define BCM56218_A0_TDBGC1r_CLR(r) (r).tdbgc1[0] = 0
#define BCM56218_A0_TDBGC1r_SET(r,d) (r).tdbgc1[0] = d
#define BCM56218_A0_TDBGC1r_GET(r) (r).tdbgc1[0]


/*
 * These macros can be used to access TDBGC1.
 *
 */
#define BCM56218_A0_READ_TDBGC1r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_TDBGC1r,(r._tdbgc1))
#define BCM56218_A0_WRITE_TDBGC1r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_TDBGC1r,&(r._tdbgc1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC1r BCM56218_A0_TDBGC1r
#define TDBGC1r_SIZE BCM56218_A0_TDBGC1r_SIZE
typedef BCM56218_A0_TDBGC1r_t TDBGC1r_t;
#define TDBGC1r_CLR BCM56218_A0_TDBGC1r_CLR
#define TDBGC1r_SET BCM56218_A0_TDBGC1r_SET
#define TDBGC1r_GET BCM56218_A0_TDBGC1r_GET
#define READ_TDBGC1r BCM56218_A0_READ_TDBGC1r
#define WRITE_TDBGC1r BCM56218_A0_WRITE_TDBGC1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_TDBGC1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  TDBGC10
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #10
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_TDBGC10r 0x0a90000a

#define BCM56218_A0_TDBGC10r_SIZE 4

/*
 * This structure should be used to declare and program TDBGC10.
 *
 */
typedef union BCM56218_A0_TDBGC10r_s {
	uint32_t v[1];
	uint32_t tdbgc10[1];
	uint32_t _tdbgc10;
} BCM56218_A0_TDBGC10r_t;

#define BCM56218_A0_TDBGC10r_CLR(r) (r).tdbgc10[0] = 0
#define BCM56218_A0_TDBGC10r_SET(r,d) (r).tdbgc10[0] = d
#define BCM56218_A0_TDBGC10r_GET(r) (r).tdbgc10[0]


/*
 * These macros can be used to access TDBGC10.
 *
 */
#define BCM56218_A0_READ_TDBGC10r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_TDBGC10r,(r._tdbgc10))
#define BCM56218_A0_WRITE_TDBGC10r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_TDBGC10r,&(r._tdbgc10))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC10r BCM56218_A0_TDBGC10r
#define TDBGC10r_SIZE BCM56218_A0_TDBGC10r_SIZE
typedef BCM56218_A0_TDBGC10r_t TDBGC10r_t;
#define TDBGC10r_CLR BCM56218_A0_TDBGC10r_CLR
#define TDBGC10r_SET BCM56218_A0_TDBGC10r_SET
#define TDBGC10r_GET BCM56218_A0_TDBGC10r_GET
#define READ_TDBGC10r BCM56218_A0_READ_TDBGC10r
#define WRITE_TDBGC10r BCM56218_A0_WRITE_TDBGC10r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_TDBGC10r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  TDBGC10_SELECT
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #10 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The TDBGC10_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM56218_A0_TDBGC10_SELECTr 0x0a98002a

#define BCM56218_A0_TDBGC10_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program TDBGC10_SELECT.
 *
 */
typedef union BCM56218_A0_TDBGC10_SELECTr_s {
	uint32_t v[1];
	uint32_t tdbgc10_select[1];
	uint32_t _tdbgc10_select;
} BCM56218_A0_TDBGC10_SELECTr_t;

#define BCM56218_A0_TDBGC10_SELECTr_CLR(r) (r).tdbgc10_select[0] = 0
#define BCM56218_A0_TDBGC10_SELECTr_SET(r,d) (r).tdbgc10_select[0] = d
#define BCM56218_A0_TDBGC10_SELECTr_GET(r) (r).tdbgc10_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_TDBGC10_SELECTr_BITMAPf_GET(r) (((r).tdbgc10_select[0]) & 0x1fffff)
#define BCM56218_A0_TDBGC10_SELECTr_BITMAPf_SET(r,f) (r).tdbgc10_select[0]=(((r).tdbgc10_select[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access TDBGC10_SELECT.
 *
 */
#define BCM56218_A0_READ_TDBGC10_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_TDBGC10_SELECTr,(r._tdbgc10_select))
#define BCM56218_A0_WRITE_TDBGC10_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_TDBGC10_SELECTr,&(r._tdbgc10_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC10_SELECTr BCM56218_A0_TDBGC10_SELECTr
#define TDBGC10_SELECTr_SIZE BCM56218_A0_TDBGC10_SELECTr_SIZE
typedef BCM56218_A0_TDBGC10_SELECTr_t TDBGC10_SELECTr_t;
#define TDBGC10_SELECTr_CLR BCM56218_A0_TDBGC10_SELECTr_CLR
#define TDBGC10_SELECTr_SET BCM56218_A0_TDBGC10_SELECTr_SET
#define TDBGC10_SELECTr_GET BCM56218_A0_TDBGC10_SELECTr_GET
#define TDBGC10_SELECTr_BITMAPf_GET BCM56218_A0_TDBGC10_SELECTr_BITMAPf_GET
#define TDBGC10_SELECTr_BITMAPf_SET BCM56218_A0_TDBGC10_SELECTr_BITMAPf_SET
#define READ_TDBGC10_SELECTr BCM56218_A0_READ_TDBGC10_SELECTr
#define WRITE_TDBGC10_SELECTr BCM56218_A0_WRITE_TDBGC10_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_TDBGC10_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  TDBGC11
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #11
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_TDBGC11r 0x0a90000b

#define BCM56218_A0_TDBGC11r_SIZE 4

/*
 * This structure should be used to declare and program TDBGC11.
 *
 */
typedef union BCM56218_A0_TDBGC11r_s {
	uint32_t v[1];
	uint32_t tdbgc11[1];
	uint32_t _tdbgc11;
} BCM56218_A0_TDBGC11r_t;

#define BCM56218_A0_TDBGC11r_CLR(r) (r).tdbgc11[0] = 0
#define BCM56218_A0_TDBGC11r_SET(r,d) (r).tdbgc11[0] = d
#define BCM56218_A0_TDBGC11r_GET(r) (r).tdbgc11[0]


/*
 * These macros can be used to access TDBGC11.
 *
 */
#define BCM56218_A0_READ_TDBGC11r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_TDBGC11r,(r._tdbgc11))
#define BCM56218_A0_WRITE_TDBGC11r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_TDBGC11r,&(r._tdbgc11))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC11r BCM56218_A0_TDBGC11r
#define TDBGC11r_SIZE BCM56218_A0_TDBGC11r_SIZE
typedef BCM56218_A0_TDBGC11r_t TDBGC11r_t;
#define TDBGC11r_CLR BCM56218_A0_TDBGC11r_CLR
#define TDBGC11r_SET BCM56218_A0_TDBGC11r_SET
#define TDBGC11r_GET BCM56218_A0_TDBGC11r_GET
#define READ_TDBGC11r BCM56218_A0_READ_TDBGC11r
#define WRITE_TDBGC11r BCM56218_A0_WRITE_TDBGC11r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_TDBGC11r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  TDBGC11_SELECT
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #11 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The TDBGC11_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM56218_A0_TDBGC11_SELECTr 0x0a98002b

#define BCM56218_A0_TDBGC11_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program TDBGC11_SELECT.
 *
 */
typedef union BCM56218_A0_TDBGC11_SELECTr_s {
	uint32_t v[1];
	uint32_t tdbgc11_select[1];
	uint32_t _tdbgc11_select;
} BCM56218_A0_TDBGC11_SELECTr_t;

#define BCM56218_A0_TDBGC11_SELECTr_CLR(r) (r).tdbgc11_select[0] = 0
#define BCM56218_A0_TDBGC11_SELECTr_SET(r,d) (r).tdbgc11_select[0] = d
#define BCM56218_A0_TDBGC11_SELECTr_GET(r) (r).tdbgc11_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_TDBGC11_SELECTr_BITMAPf_GET(r) (((r).tdbgc11_select[0]) & 0x1fffff)
#define BCM56218_A0_TDBGC11_SELECTr_BITMAPf_SET(r,f) (r).tdbgc11_select[0]=(((r).tdbgc11_select[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access TDBGC11_SELECT.
 *
 */
#define BCM56218_A0_READ_TDBGC11_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_TDBGC11_SELECTr,(r._tdbgc11_select))
#define BCM56218_A0_WRITE_TDBGC11_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_TDBGC11_SELECTr,&(r._tdbgc11_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC11_SELECTr BCM56218_A0_TDBGC11_SELECTr
#define TDBGC11_SELECTr_SIZE BCM56218_A0_TDBGC11_SELECTr_SIZE
typedef BCM56218_A0_TDBGC11_SELECTr_t TDBGC11_SELECTr_t;
#define TDBGC11_SELECTr_CLR BCM56218_A0_TDBGC11_SELECTr_CLR
#define TDBGC11_SELECTr_SET BCM56218_A0_TDBGC11_SELECTr_SET
#define TDBGC11_SELECTr_GET BCM56218_A0_TDBGC11_SELECTr_GET
#define TDBGC11_SELECTr_BITMAPf_GET BCM56218_A0_TDBGC11_SELECTr_BITMAPf_GET
#define TDBGC11_SELECTr_BITMAPf_SET BCM56218_A0_TDBGC11_SELECTr_BITMAPf_SET
#define READ_TDBGC11_SELECTr BCM56218_A0_READ_TDBGC11_SELECTr
#define WRITE_TDBGC11_SELECTr BCM56218_A0_WRITE_TDBGC11_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_TDBGC11_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  TDBGC1_SELECT
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #1 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The TDBGC1_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM56218_A0_TDBGC1_SELECTr 0x0a980021

#define BCM56218_A0_TDBGC1_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program TDBGC1_SELECT.
 *
 */
typedef union BCM56218_A0_TDBGC1_SELECTr_s {
	uint32_t v[1];
	uint32_t tdbgc1_select[1];
	uint32_t _tdbgc1_select;
} BCM56218_A0_TDBGC1_SELECTr_t;

#define BCM56218_A0_TDBGC1_SELECTr_CLR(r) (r).tdbgc1_select[0] = 0
#define BCM56218_A0_TDBGC1_SELECTr_SET(r,d) (r).tdbgc1_select[0] = d
#define BCM56218_A0_TDBGC1_SELECTr_GET(r) (r).tdbgc1_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_TDBGC1_SELECTr_BITMAPf_GET(r) (((r).tdbgc1_select[0]) & 0x1fffff)
#define BCM56218_A0_TDBGC1_SELECTr_BITMAPf_SET(r,f) (r).tdbgc1_select[0]=(((r).tdbgc1_select[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access TDBGC1_SELECT.
 *
 */
#define BCM56218_A0_READ_TDBGC1_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_TDBGC1_SELECTr,(r._tdbgc1_select))
#define BCM56218_A0_WRITE_TDBGC1_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_TDBGC1_SELECTr,&(r._tdbgc1_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC1_SELECTr BCM56218_A0_TDBGC1_SELECTr
#define TDBGC1_SELECTr_SIZE BCM56218_A0_TDBGC1_SELECTr_SIZE
typedef BCM56218_A0_TDBGC1_SELECTr_t TDBGC1_SELECTr_t;
#define TDBGC1_SELECTr_CLR BCM56218_A0_TDBGC1_SELECTr_CLR
#define TDBGC1_SELECTr_SET BCM56218_A0_TDBGC1_SELECTr_SET
#define TDBGC1_SELECTr_GET BCM56218_A0_TDBGC1_SELECTr_GET
#define TDBGC1_SELECTr_BITMAPf_GET BCM56218_A0_TDBGC1_SELECTr_BITMAPf_GET
#define TDBGC1_SELECTr_BITMAPf_SET BCM56218_A0_TDBGC1_SELECTr_BITMAPf_SET
#define READ_TDBGC1_SELECTr BCM56218_A0_READ_TDBGC1_SELECTr
#define WRITE_TDBGC1_SELECTr BCM56218_A0_WRITE_TDBGC1_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_TDBGC1_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  TDBGC2
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #2
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_TDBGC2r 0x0a900002

#define BCM56218_A0_TDBGC2r_SIZE 4

/*
 * This structure should be used to declare and program TDBGC2.
 *
 */
typedef union BCM56218_A0_TDBGC2r_s {
	uint32_t v[1];
	uint32_t tdbgc2[1];
	uint32_t _tdbgc2;
} BCM56218_A0_TDBGC2r_t;

#define BCM56218_A0_TDBGC2r_CLR(r) (r).tdbgc2[0] = 0
#define BCM56218_A0_TDBGC2r_SET(r,d) (r).tdbgc2[0] = d
#define BCM56218_A0_TDBGC2r_GET(r) (r).tdbgc2[0]


/*
 * These macros can be used to access TDBGC2.
 *
 */
#define BCM56218_A0_READ_TDBGC2r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_TDBGC2r,(r._tdbgc2))
#define BCM56218_A0_WRITE_TDBGC2r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_TDBGC2r,&(r._tdbgc2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC2r BCM56218_A0_TDBGC2r
#define TDBGC2r_SIZE BCM56218_A0_TDBGC2r_SIZE
typedef BCM56218_A0_TDBGC2r_t TDBGC2r_t;
#define TDBGC2r_CLR BCM56218_A0_TDBGC2r_CLR
#define TDBGC2r_SET BCM56218_A0_TDBGC2r_SET
#define TDBGC2r_GET BCM56218_A0_TDBGC2r_GET
#define READ_TDBGC2r BCM56218_A0_READ_TDBGC2r
#define WRITE_TDBGC2r BCM56218_A0_WRITE_TDBGC2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_TDBGC2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  TDBGC2_SELECT
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #2 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The TDBGC2_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM56218_A0_TDBGC2_SELECTr 0x0a980022

#define BCM56218_A0_TDBGC2_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program TDBGC2_SELECT.
 *
 */
typedef union BCM56218_A0_TDBGC2_SELECTr_s {
	uint32_t v[1];
	uint32_t tdbgc2_select[1];
	uint32_t _tdbgc2_select;
} BCM56218_A0_TDBGC2_SELECTr_t;

#define BCM56218_A0_TDBGC2_SELECTr_CLR(r) (r).tdbgc2_select[0] = 0
#define BCM56218_A0_TDBGC2_SELECTr_SET(r,d) (r).tdbgc2_select[0] = d
#define BCM56218_A0_TDBGC2_SELECTr_GET(r) (r).tdbgc2_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_TDBGC2_SELECTr_BITMAPf_GET(r) (((r).tdbgc2_select[0]) & 0x1fffff)
#define BCM56218_A0_TDBGC2_SELECTr_BITMAPf_SET(r,f) (r).tdbgc2_select[0]=(((r).tdbgc2_select[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access TDBGC2_SELECT.
 *
 */
#define BCM56218_A0_READ_TDBGC2_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_TDBGC2_SELECTr,(r._tdbgc2_select))
#define BCM56218_A0_WRITE_TDBGC2_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_TDBGC2_SELECTr,&(r._tdbgc2_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC2_SELECTr BCM56218_A0_TDBGC2_SELECTr
#define TDBGC2_SELECTr_SIZE BCM56218_A0_TDBGC2_SELECTr_SIZE
typedef BCM56218_A0_TDBGC2_SELECTr_t TDBGC2_SELECTr_t;
#define TDBGC2_SELECTr_CLR BCM56218_A0_TDBGC2_SELECTr_CLR
#define TDBGC2_SELECTr_SET BCM56218_A0_TDBGC2_SELECTr_SET
#define TDBGC2_SELECTr_GET BCM56218_A0_TDBGC2_SELECTr_GET
#define TDBGC2_SELECTr_BITMAPf_GET BCM56218_A0_TDBGC2_SELECTr_BITMAPf_GET
#define TDBGC2_SELECTr_BITMAPf_SET BCM56218_A0_TDBGC2_SELECTr_BITMAPf_SET
#define READ_TDBGC2_SELECTr BCM56218_A0_READ_TDBGC2_SELECTr
#define WRITE_TDBGC2_SELECTr BCM56218_A0_WRITE_TDBGC2_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_TDBGC2_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  TDBGC3
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #3
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_TDBGC3r 0x0a900003

#define BCM56218_A0_TDBGC3r_SIZE 4

/*
 * This structure should be used to declare and program TDBGC3.
 *
 */
typedef union BCM56218_A0_TDBGC3r_s {
	uint32_t v[1];
	uint32_t tdbgc3[1];
	uint32_t _tdbgc3;
} BCM56218_A0_TDBGC3r_t;

#define BCM56218_A0_TDBGC3r_CLR(r) (r).tdbgc3[0] = 0
#define BCM56218_A0_TDBGC3r_SET(r,d) (r).tdbgc3[0] = d
#define BCM56218_A0_TDBGC3r_GET(r) (r).tdbgc3[0]


/*
 * These macros can be used to access TDBGC3.
 *
 */
#define BCM56218_A0_READ_TDBGC3r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_TDBGC3r,(r._tdbgc3))
#define BCM56218_A0_WRITE_TDBGC3r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_TDBGC3r,&(r._tdbgc3))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC3r BCM56218_A0_TDBGC3r
#define TDBGC3r_SIZE BCM56218_A0_TDBGC3r_SIZE
typedef BCM56218_A0_TDBGC3r_t TDBGC3r_t;
#define TDBGC3r_CLR BCM56218_A0_TDBGC3r_CLR
#define TDBGC3r_SET BCM56218_A0_TDBGC3r_SET
#define TDBGC3r_GET BCM56218_A0_TDBGC3r_GET
#define READ_TDBGC3r BCM56218_A0_READ_TDBGC3r
#define WRITE_TDBGC3r BCM56218_A0_WRITE_TDBGC3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_TDBGC3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  TDBGC3_SELECT
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #3 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The TDBGC3_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM56218_A0_TDBGC3_SELECTr 0x0a980023

#define BCM56218_A0_TDBGC3_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program TDBGC3_SELECT.
 *
 */
typedef union BCM56218_A0_TDBGC3_SELECTr_s {
	uint32_t v[1];
	uint32_t tdbgc3_select[1];
	uint32_t _tdbgc3_select;
} BCM56218_A0_TDBGC3_SELECTr_t;

#define BCM56218_A0_TDBGC3_SELECTr_CLR(r) (r).tdbgc3_select[0] = 0
#define BCM56218_A0_TDBGC3_SELECTr_SET(r,d) (r).tdbgc3_select[0] = d
#define BCM56218_A0_TDBGC3_SELECTr_GET(r) (r).tdbgc3_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_TDBGC3_SELECTr_BITMAPf_GET(r) (((r).tdbgc3_select[0]) & 0x1fffff)
#define BCM56218_A0_TDBGC3_SELECTr_BITMAPf_SET(r,f) (r).tdbgc3_select[0]=(((r).tdbgc3_select[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access TDBGC3_SELECT.
 *
 */
#define BCM56218_A0_READ_TDBGC3_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_TDBGC3_SELECTr,(r._tdbgc3_select))
#define BCM56218_A0_WRITE_TDBGC3_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_TDBGC3_SELECTr,&(r._tdbgc3_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC3_SELECTr BCM56218_A0_TDBGC3_SELECTr
#define TDBGC3_SELECTr_SIZE BCM56218_A0_TDBGC3_SELECTr_SIZE
typedef BCM56218_A0_TDBGC3_SELECTr_t TDBGC3_SELECTr_t;
#define TDBGC3_SELECTr_CLR BCM56218_A0_TDBGC3_SELECTr_CLR
#define TDBGC3_SELECTr_SET BCM56218_A0_TDBGC3_SELECTr_SET
#define TDBGC3_SELECTr_GET BCM56218_A0_TDBGC3_SELECTr_GET
#define TDBGC3_SELECTr_BITMAPf_GET BCM56218_A0_TDBGC3_SELECTr_BITMAPf_GET
#define TDBGC3_SELECTr_BITMAPf_SET BCM56218_A0_TDBGC3_SELECTr_BITMAPf_SET
#define READ_TDBGC3_SELECTr BCM56218_A0_READ_TDBGC3_SELECTr
#define WRITE_TDBGC3_SELECTr BCM56218_A0_WRITE_TDBGC3_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_TDBGC3_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  TDBGC4
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #4
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_TDBGC4r 0x0a900004

#define BCM56218_A0_TDBGC4r_SIZE 4

/*
 * This structure should be used to declare and program TDBGC4.
 *
 */
typedef union BCM56218_A0_TDBGC4r_s {
	uint32_t v[1];
	uint32_t tdbgc4[1];
	uint32_t _tdbgc4;
} BCM56218_A0_TDBGC4r_t;

#define BCM56218_A0_TDBGC4r_CLR(r) (r).tdbgc4[0] = 0
#define BCM56218_A0_TDBGC4r_SET(r,d) (r).tdbgc4[0] = d
#define BCM56218_A0_TDBGC4r_GET(r) (r).tdbgc4[0]


/*
 * These macros can be used to access TDBGC4.
 *
 */
#define BCM56218_A0_READ_TDBGC4r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_TDBGC4r,(r._tdbgc4))
#define BCM56218_A0_WRITE_TDBGC4r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_TDBGC4r,&(r._tdbgc4))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC4r BCM56218_A0_TDBGC4r
#define TDBGC4r_SIZE BCM56218_A0_TDBGC4r_SIZE
typedef BCM56218_A0_TDBGC4r_t TDBGC4r_t;
#define TDBGC4r_CLR BCM56218_A0_TDBGC4r_CLR
#define TDBGC4r_SET BCM56218_A0_TDBGC4r_SET
#define TDBGC4r_GET BCM56218_A0_TDBGC4r_GET
#define READ_TDBGC4r BCM56218_A0_READ_TDBGC4r
#define WRITE_TDBGC4r BCM56218_A0_WRITE_TDBGC4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_TDBGC4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  TDBGC4_SELECT
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #4 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The TDBGC4_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM56218_A0_TDBGC4_SELECTr 0x0a980024

#define BCM56218_A0_TDBGC4_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program TDBGC4_SELECT.
 *
 */
typedef union BCM56218_A0_TDBGC4_SELECTr_s {
	uint32_t v[1];
	uint32_t tdbgc4_select[1];
	uint32_t _tdbgc4_select;
} BCM56218_A0_TDBGC4_SELECTr_t;

#define BCM56218_A0_TDBGC4_SELECTr_CLR(r) (r).tdbgc4_select[0] = 0
#define BCM56218_A0_TDBGC4_SELECTr_SET(r,d) (r).tdbgc4_select[0] = d
#define BCM56218_A0_TDBGC4_SELECTr_GET(r) (r).tdbgc4_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_TDBGC4_SELECTr_BITMAPf_GET(r) (((r).tdbgc4_select[0]) & 0x1fffff)
#define BCM56218_A0_TDBGC4_SELECTr_BITMAPf_SET(r,f) (r).tdbgc4_select[0]=(((r).tdbgc4_select[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access TDBGC4_SELECT.
 *
 */
#define BCM56218_A0_READ_TDBGC4_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_TDBGC4_SELECTr,(r._tdbgc4_select))
#define BCM56218_A0_WRITE_TDBGC4_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_TDBGC4_SELECTr,&(r._tdbgc4_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC4_SELECTr BCM56218_A0_TDBGC4_SELECTr
#define TDBGC4_SELECTr_SIZE BCM56218_A0_TDBGC4_SELECTr_SIZE
typedef BCM56218_A0_TDBGC4_SELECTr_t TDBGC4_SELECTr_t;
#define TDBGC4_SELECTr_CLR BCM56218_A0_TDBGC4_SELECTr_CLR
#define TDBGC4_SELECTr_SET BCM56218_A0_TDBGC4_SELECTr_SET
#define TDBGC4_SELECTr_GET BCM56218_A0_TDBGC4_SELECTr_GET
#define TDBGC4_SELECTr_BITMAPf_GET BCM56218_A0_TDBGC4_SELECTr_BITMAPf_GET
#define TDBGC4_SELECTr_BITMAPf_SET BCM56218_A0_TDBGC4_SELECTr_BITMAPf_SET
#define READ_TDBGC4_SELECTr BCM56218_A0_READ_TDBGC4_SELECTr
#define WRITE_TDBGC4_SELECTr BCM56218_A0_WRITE_TDBGC4_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_TDBGC4_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  TDBGC5
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #5
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_TDBGC5r 0x0a900005

#define BCM56218_A0_TDBGC5r_SIZE 4

/*
 * This structure should be used to declare and program TDBGC5.
 *
 */
typedef union BCM56218_A0_TDBGC5r_s {
	uint32_t v[1];
	uint32_t tdbgc5[1];
	uint32_t _tdbgc5;
} BCM56218_A0_TDBGC5r_t;

#define BCM56218_A0_TDBGC5r_CLR(r) (r).tdbgc5[0] = 0
#define BCM56218_A0_TDBGC5r_SET(r,d) (r).tdbgc5[0] = d
#define BCM56218_A0_TDBGC5r_GET(r) (r).tdbgc5[0]


/*
 * These macros can be used to access TDBGC5.
 *
 */
#define BCM56218_A0_READ_TDBGC5r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_TDBGC5r,(r._tdbgc5))
#define BCM56218_A0_WRITE_TDBGC5r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_TDBGC5r,&(r._tdbgc5))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC5r BCM56218_A0_TDBGC5r
#define TDBGC5r_SIZE BCM56218_A0_TDBGC5r_SIZE
typedef BCM56218_A0_TDBGC5r_t TDBGC5r_t;
#define TDBGC5r_CLR BCM56218_A0_TDBGC5r_CLR
#define TDBGC5r_SET BCM56218_A0_TDBGC5r_SET
#define TDBGC5r_GET BCM56218_A0_TDBGC5r_GET
#define READ_TDBGC5r BCM56218_A0_READ_TDBGC5r
#define WRITE_TDBGC5r BCM56218_A0_WRITE_TDBGC5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_TDBGC5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  TDBGC5_SELECT
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #5 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The TDBGC5_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM56218_A0_TDBGC5_SELECTr 0x0a980025

#define BCM56218_A0_TDBGC5_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program TDBGC5_SELECT.
 *
 */
typedef union BCM56218_A0_TDBGC5_SELECTr_s {
	uint32_t v[1];
	uint32_t tdbgc5_select[1];
	uint32_t _tdbgc5_select;
} BCM56218_A0_TDBGC5_SELECTr_t;

#define BCM56218_A0_TDBGC5_SELECTr_CLR(r) (r).tdbgc5_select[0] = 0
#define BCM56218_A0_TDBGC5_SELECTr_SET(r,d) (r).tdbgc5_select[0] = d
#define BCM56218_A0_TDBGC5_SELECTr_GET(r) (r).tdbgc5_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_TDBGC5_SELECTr_BITMAPf_GET(r) (((r).tdbgc5_select[0]) & 0x1fffff)
#define BCM56218_A0_TDBGC5_SELECTr_BITMAPf_SET(r,f) (r).tdbgc5_select[0]=(((r).tdbgc5_select[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access TDBGC5_SELECT.
 *
 */
#define BCM56218_A0_READ_TDBGC5_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_TDBGC5_SELECTr,(r._tdbgc5_select))
#define BCM56218_A0_WRITE_TDBGC5_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_TDBGC5_SELECTr,&(r._tdbgc5_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC5_SELECTr BCM56218_A0_TDBGC5_SELECTr
#define TDBGC5_SELECTr_SIZE BCM56218_A0_TDBGC5_SELECTr_SIZE
typedef BCM56218_A0_TDBGC5_SELECTr_t TDBGC5_SELECTr_t;
#define TDBGC5_SELECTr_CLR BCM56218_A0_TDBGC5_SELECTr_CLR
#define TDBGC5_SELECTr_SET BCM56218_A0_TDBGC5_SELECTr_SET
#define TDBGC5_SELECTr_GET BCM56218_A0_TDBGC5_SELECTr_GET
#define TDBGC5_SELECTr_BITMAPf_GET BCM56218_A0_TDBGC5_SELECTr_BITMAPf_GET
#define TDBGC5_SELECTr_BITMAPf_SET BCM56218_A0_TDBGC5_SELECTr_BITMAPf_SET
#define READ_TDBGC5_SELECTr BCM56218_A0_READ_TDBGC5_SELECTr
#define WRITE_TDBGC5_SELECTr BCM56218_A0_WRITE_TDBGC5_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_TDBGC5_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  TDBGC6
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #6
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_TDBGC6r 0x0a900006

#define BCM56218_A0_TDBGC6r_SIZE 4

/*
 * This structure should be used to declare and program TDBGC6.
 *
 */
typedef union BCM56218_A0_TDBGC6r_s {
	uint32_t v[1];
	uint32_t tdbgc6[1];
	uint32_t _tdbgc6;
} BCM56218_A0_TDBGC6r_t;

#define BCM56218_A0_TDBGC6r_CLR(r) (r).tdbgc6[0] = 0
#define BCM56218_A0_TDBGC6r_SET(r,d) (r).tdbgc6[0] = d
#define BCM56218_A0_TDBGC6r_GET(r) (r).tdbgc6[0]


/*
 * These macros can be used to access TDBGC6.
 *
 */
#define BCM56218_A0_READ_TDBGC6r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_TDBGC6r,(r._tdbgc6))
#define BCM56218_A0_WRITE_TDBGC6r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_TDBGC6r,&(r._tdbgc6))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC6r BCM56218_A0_TDBGC6r
#define TDBGC6r_SIZE BCM56218_A0_TDBGC6r_SIZE
typedef BCM56218_A0_TDBGC6r_t TDBGC6r_t;
#define TDBGC6r_CLR BCM56218_A0_TDBGC6r_CLR
#define TDBGC6r_SET BCM56218_A0_TDBGC6r_SET
#define TDBGC6r_GET BCM56218_A0_TDBGC6r_GET
#define READ_TDBGC6r BCM56218_A0_READ_TDBGC6r
#define WRITE_TDBGC6r BCM56218_A0_WRITE_TDBGC6r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_TDBGC6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  TDBGC6_SELECT
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #6 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The TDBGC6_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM56218_A0_TDBGC6_SELECTr 0x0a980026

#define BCM56218_A0_TDBGC6_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program TDBGC6_SELECT.
 *
 */
typedef union BCM56218_A0_TDBGC6_SELECTr_s {
	uint32_t v[1];
	uint32_t tdbgc6_select[1];
	uint32_t _tdbgc6_select;
} BCM56218_A0_TDBGC6_SELECTr_t;

#define BCM56218_A0_TDBGC6_SELECTr_CLR(r) (r).tdbgc6_select[0] = 0
#define BCM56218_A0_TDBGC6_SELECTr_SET(r,d) (r).tdbgc6_select[0] = d
#define BCM56218_A0_TDBGC6_SELECTr_GET(r) (r).tdbgc6_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_TDBGC6_SELECTr_BITMAPf_GET(r) (((r).tdbgc6_select[0]) & 0x1fffff)
#define BCM56218_A0_TDBGC6_SELECTr_BITMAPf_SET(r,f) (r).tdbgc6_select[0]=(((r).tdbgc6_select[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access TDBGC6_SELECT.
 *
 */
#define BCM56218_A0_READ_TDBGC6_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_TDBGC6_SELECTr,(r._tdbgc6_select))
#define BCM56218_A0_WRITE_TDBGC6_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_TDBGC6_SELECTr,&(r._tdbgc6_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC6_SELECTr BCM56218_A0_TDBGC6_SELECTr
#define TDBGC6_SELECTr_SIZE BCM56218_A0_TDBGC6_SELECTr_SIZE
typedef BCM56218_A0_TDBGC6_SELECTr_t TDBGC6_SELECTr_t;
#define TDBGC6_SELECTr_CLR BCM56218_A0_TDBGC6_SELECTr_CLR
#define TDBGC6_SELECTr_SET BCM56218_A0_TDBGC6_SELECTr_SET
#define TDBGC6_SELECTr_GET BCM56218_A0_TDBGC6_SELECTr_GET
#define TDBGC6_SELECTr_BITMAPf_GET BCM56218_A0_TDBGC6_SELECTr_BITMAPf_GET
#define TDBGC6_SELECTr_BITMAPf_SET BCM56218_A0_TDBGC6_SELECTr_BITMAPf_SET
#define READ_TDBGC6_SELECTr BCM56218_A0_READ_TDBGC6_SELECTr
#define WRITE_TDBGC6_SELECTr BCM56218_A0_WRITE_TDBGC6_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_TDBGC6_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  TDBGC7
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #7
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_TDBGC7r 0x0a900007

#define BCM56218_A0_TDBGC7r_SIZE 4

/*
 * This structure should be used to declare and program TDBGC7.
 *
 */
typedef union BCM56218_A0_TDBGC7r_s {
	uint32_t v[1];
	uint32_t tdbgc7[1];
	uint32_t _tdbgc7;
} BCM56218_A0_TDBGC7r_t;

#define BCM56218_A0_TDBGC7r_CLR(r) (r).tdbgc7[0] = 0
#define BCM56218_A0_TDBGC7r_SET(r,d) (r).tdbgc7[0] = d
#define BCM56218_A0_TDBGC7r_GET(r) (r).tdbgc7[0]


/*
 * These macros can be used to access TDBGC7.
 *
 */
#define BCM56218_A0_READ_TDBGC7r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_TDBGC7r,(r._tdbgc7))
#define BCM56218_A0_WRITE_TDBGC7r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_TDBGC7r,&(r._tdbgc7))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC7r BCM56218_A0_TDBGC7r
#define TDBGC7r_SIZE BCM56218_A0_TDBGC7r_SIZE
typedef BCM56218_A0_TDBGC7r_t TDBGC7r_t;
#define TDBGC7r_CLR BCM56218_A0_TDBGC7r_CLR
#define TDBGC7r_SET BCM56218_A0_TDBGC7r_SET
#define TDBGC7r_GET BCM56218_A0_TDBGC7r_GET
#define READ_TDBGC7r BCM56218_A0_READ_TDBGC7r
#define WRITE_TDBGC7r BCM56218_A0_WRITE_TDBGC7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_TDBGC7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  TDBGC7_SELECT
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #7 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The TDBGC7_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM56218_A0_TDBGC7_SELECTr 0x0a980027

#define BCM56218_A0_TDBGC7_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program TDBGC7_SELECT.
 *
 */
typedef union BCM56218_A0_TDBGC7_SELECTr_s {
	uint32_t v[1];
	uint32_t tdbgc7_select[1];
	uint32_t _tdbgc7_select;
} BCM56218_A0_TDBGC7_SELECTr_t;

#define BCM56218_A0_TDBGC7_SELECTr_CLR(r) (r).tdbgc7_select[0] = 0
#define BCM56218_A0_TDBGC7_SELECTr_SET(r,d) (r).tdbgc7_select[0] = d
#define BCM56218_A0_TDBGC7_SELECTr_GET(r) (r).tdbgc7_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_TDBGC7_SELECTr_BITMAPf_GET(r) (((r).tdbgc7_select[0]) & 0x1fffff)
#define BCM56218_A0_TDBGC7_SELECTr_BITMAPf_SET(r,f) (r).tdbgc7_select[0]=(((r).tdbgc7_select[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access TDBGC7_SELECT.
 *
 */
#define BCM56218_A0_READ_TDBGC7_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_TDBGC7_SELECTr,(r._tdbgc7_select))
#define BCM56218_A0_WRITE_TDBGC7_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_TDBGC7_SELECTr,&(r._tdbgc7_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC7_SELECTr BCM56218_A0_TDBGC7_SELECTr
#define TDBGC7_SELECTr_SIZE BCM56218_A0_TDBGC7_SELECTr_SIZE
typedef BCM56218_A0_TDBGC7_SELECTr_t TDBGC7_SELECTr_t;
#define TDBGC7_SELECTr_CLR BCM56218_A0_TDBGC7_SELECTr_CLR
#define TDBGC7_SELECTr_SET BCM56218_A0_TDBGC7_SELECTr_SET
#define TDBGC7_SELECTr_GET BCM56218_A0_TDBGC7_SELECTr_GET
#define TDBGC7_SELECTr_BITMAPf_GET BCM56218_A0_TDBGC7_SELECTr_BITMAPf_GET
#define TDBGC7_SELECTr_BITMAPf_SET BCM56218_A0_TDBGC7_SELECTr_BITMAPf_SET
#define READ_TDBGC7_SELECTr BCM56218_A0_READ_TDBGC7_SELECTr
#define WRITE_TDBGC7_SELECTr BCM56218_A0_WRITE_TDBGC7_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_TDBGC7_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  TDBGC8
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #8
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_TDBGC8r 0x0a900008

#define BCM56218_A0_TDBGC8r_SIZE 4

/*
 * This structure should be used to declare and program TDBGC8.
 *
 */
typedef union BCM56218_A0_TDBGC8r_s {
	uint32_t v[1];
	uint32_t tdbgc8[1];
	uint32_t _tdbgc8;
} BCM56218_A0_TDBGC8r_t;

#define BCM56218_A0_TDBGC8r_CLR(r) (r).tdbgc8[0] = 0
#define BCM56218_A0_TDBGC8r_SET(r,d) (r).tdbgc8[0] = d
#define BCM56218_A0_TDBGC8r_GET(r) (r).tdbgc8[0]


/*
 * These macros can be used to access TDBGC8.
 *
 */
#define BCM56218_A0_READ_TDBGC8r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_TDBGC8r,(r._tdbgc8))
#define BCM56218_A0_WRITE_TDBGC8r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_TDBGC8r,&(r._tdbgc8))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC8r BCM56218_A0_TDBGC8r
#define TDBGC8r_SIZE BCM56218_A0_TDBGC8r_SIZE
typedef BCM56218_A0_TDBGC8r_t TDBGC8r_t;
#define TDBGC8r_CLR BCM56218_A0_TDBGC8r_CLR
#define TDBGC8r_SET BCM56218_A0_TDBGC8r_SET
#define TDBGC8r_GET BCM56218_A0_TDBGC8r_GET
#define READ_TDBGC8r BCM56218_A0_READ_TDBGC8r
#define WRITE_TDBGC8r BCM56218_A0_WRITE_TDBGC8r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_TDBGC8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  TDBGC8_SELECT
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #8 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The TDBGC8_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM56218_A0_TDBGC8_SELECTr 0x0a980028

#define BCM56218_A0_TDBGC8_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program TDBGC8_SELECT.
 *
 */
typedef union BCM56218_A0_TDBGC8_SELECTr_s {
	uint32_t v[1];
	uint32_t tdbgc8_select[1];
	uint32_t _tdbgc8_select;
} BCM56218_A0_TDBGC8_SELECTr_t;

#define BCM56218_A0_TDBGC8_SELECTr_CLR(r) (r).tdbgc8_select[0] = 0
#define BCM56218_A0_TDBGC8_SELECTr_SET(r,d) (r).tdbgc8_select[0] = d
#define BCM56218_A0_TDBGC8_SELECTr_GET(r) (r).tdbgc8_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_TDBGC8_SELECTr_BITMAPf_GET(r) (((r).tdbgc8_select[0]) & 0x1fffff)
#define BCM56218_A0_TDBGC8_SELECTr_BITMAPf_SET(r,f) (r).tdbgc8_select[0]=(((r).tdbgc8_select[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access TDBGC8_SELECT.
 *
 */
#define BCM56218_A0_READ_TDBGC8_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_TDBGC8_SELECTr,(r._tdbgc8_select))
#define BCM56218_A0_WRITE_TDBGC8_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_TDBGC8_SELECTr,&(r._tdbgc8_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC8_SELECTr BCM56218_A0_TDBGC8_SELECTr
#define TDBGC8_SELECTr_SIZE BCM56218_A0_TDBGC8_SELECTr_SIZE
typedef BCM56218_A0_TDBGC8_SELECTr_t TDBGC8_SELECTr_t;
#define TDBGC8_SELECTr_CLR BCM56218_A0_TDBGC8_SELECTr_CLR
#define TDBGC8_SELECTr_SET BCM56218_A0_TDBGC8_SELECTr_SET
#define TDBGC8_SELECTr_GET BCM56218_A0_TDBGC8_SELECTr_GET
#define TDBGC8_SELECTr_BITMAPf_GET BCM56218_A0_TDBGC8_SELECTr_BITMAPf_GET
#define TDBGC8_SELECTr_BITMAPf_SET BCM56218_A0_TDBGC8_SELECTr_BITMAPf_SET
#define READ_TDBGC8_SELECTr BCM56218_A0_READ_TDBGC8_SELECTr
#define WRITE_TDBGC8_SELECTr BCM56218_A0_WRITE_TDBGC8_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_TDBGC8_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  TDBGC9
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #9
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_TDBGC9r 0x0a900009

#define BCM56218_A0_TDBGC9r_SIZE 4

/*
 * This structure should be used to declare and program TDBGC9.
 *
 */
typedef union BCM56218_A0_TDBGC9r_s {
	uint32_t v[1];
	uint32_t tdbgc9[1];
	uint32_t _tdbgc9;
} BCM56218_A0_TDBGC9r_t;

#define BCM56218_A0_TDBGC9r_CLR(r) (r).tdbgc9[0] = 0
#define BCM56218_A0_TDBGC9r_SET(r,d) (r).tdbgc9[0] = d
#define BCM56218_A0_TDBGC9r_GET(r) (r).tdbgc9[0]


/*
 * These macros can be used to access TDBGC9.
 *
 */
#define BCM56218_A0_READ_TDBGC9r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_TDBGC9r,(r._tdbgc9))
#define BCM56218_A0_WRITE_TDBGC9r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_TDBGC9r,&(r._tdbgc9))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC9r BCM56218_A0_TDBGC9r
#define TDBGC9r_SIZE BCM56218_A0_TDBGC9r_SIZE
typedef BCM56218_A0_TDBGC9r_t TDBGC9r_t;
#define TDBGC9r_CLR BCM56218_A0_TDBGC9r_CLR
#define TDBGC9r_SET BCM56218_A0_TDBGC9r_SET
#define TDBGC9r_GET BCM56218_A0_TDBGC9r_GET
#define READ_TDBGC9r BCM56218_A0_READ_TDBGC9r
#define WRITE_TDBGC9r BCM56218_A0_WRITE_TDBGC9r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_TDBGC9r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  TDBGC9_SELECT
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #9 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The TDBGC9_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM56218_A0_TDBGC9_SELECTr 0x0a980029

#define BCM56218_A0_TDBGC9_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program TDBGC9_SELECT.
 *
 */
typedef union BCM56218_A0_TDBGC9_SELECTr_s {
	uint32_t v[1];
	uint32_t tdbgc9_select[1];
	uint32_t _tdbgc9_select;
} BCM56218_A0_TDBGC9_SELECTr_t;

#define BCM56218_A0_TDBGC9_SELECTr_CLR(r) (r).tdbgc9_select[0] = 0
#define BCM56218_A0_TDBGC9_SELECTr_SET(r,d) (r).tdbgc9_select[0] = d
#define BCM56218_A0_TDBGC9_SELECTr_GET(r) (r).tdbgc9_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_TDBGC9_SELECTr_BITMAPf_GET(r) (((r).tdbgc9_select[0]) & 0x1fffff)
#define BCM56218_A0_TDBGC9_SELECTr_BITMAPf_SET(r,f) (r).tdbgc9_select[0]=(((r).tdbgc9_select[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access TDBGC9_SELECT.
 *
 */
#define BCM56218_A0_READ_TDBGC9_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_TDBGC9_SELECTr,(r._tdbgc9_select))
#define BCM56218_A0_WRITE_TDBGC9_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_TDBGC9_SELECTr,&(r._tdbgc9_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC9_SELECTr BCM56218_A0_TDBGC9_SELECTr
#define TDBGC9_SELECTr_SIZE BCM56218_A0_TDBGC9_SELECTr_SIZE
typedef BCM56218_A0_TDBGC9_SELECTr_t TDBGC9_SELECTr_t;
#define TDBGC9_SELECTr_CLR BCM56218_A0_TDBGC9_SELECTr_CLR
#define TDBGC9_SELECTr_SET BCM56218_A0_TDBGC9_SELECTr_SET
#define TDBGC9_SELECTr_GET BCM56218_A0_TDBGC9_SELECTr_GET
#define TDBGC9_SELECTr_BITMAPf_GET BCM56218_A0_TDBGC9_SELECTr_BITMAPf_GET
#define TDBGC9_SELECTr_BITMAPf_SET BCM56218_A0_TDBGC9_SELECTr_BITMAPf_SET
#define READ_TDBGC9_SELECTr BCM56218_A0_READ_TDBGC9_SELECTr
#define WRITE_TDBGC9_SELECTr BCM56218_A0_WRITE_TDBGC9_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_TDBGC9_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  TEST2
 * BLOCKS:   GPORT0
 * DESC:     Test control
 * SIZE:     32
 * FIELDS:
 *     SPQCT            Shortcut Pause Quanta Counter
 *     TPAUSE           Test Pause
 *
 ******************************************************************************/
#define BCM56218_A0_TEST2r 0x00000119

#define BCM56218_A0_TEST2r_SIZE 4

/*
 * This structure should be used to declare and program TEST2.
 *
 */
typedef union BCM56218_A0_TEST2r_s {
	uint32_t v[1];
	uint32_t test2[1];
	uint32_t _test2;
} BCM56218_A0_TEST2r_t;

#define BCM56218_A0_TEST2r_CLR(r) (r).test2[0] = 0
#define BCM56218_A0_TEST2r_SET(r,d) (r).test2[0] = d
#define BCM56218_A0_TEST2r_GET(r) (r).test2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_TEST2r_SPQCTf_GET(r) (((r).test2[0]) & 0x1)
#define BCM56218_A0_TEST2r_SPQCTf_SET(r,f) (r).test2[0]=(((r).test2[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_TEST2r_TPAUSEf_GET(r) ((((r).test2[0]) >> 1) & 0x1)
#define BCM56218_A0_TEST2r_TPAUSEf_SET(r,f) (r).test2[0]=(((r).test2[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access TEST2.
 *
 */
#define BCM56218_A0_READ_TEST2r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_TEST2r,(r._test2))
#define BCM56218_A0_WRITE_TEST2r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_TEST2r,&(r._test2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TEST2r BCM56218_A0_TEST2r
#define TEST2r_SIZE BCM56218_A0_TEST2r_SIZE
typedef BCM56218_A0_TEST2r_t TEST2r_t;
#define TEST2r_CLR BCM56218_A0_TEST2r_CLR
#define TEST2r_SET BCM56218_A0_TEST2r_SET
#define TEST2r_GET BCM56218_A0_TEST2r_GET
#define TEST2r_SPQCTf_GET BCM56218_A0_TEST2r_SPQCTf_GET
#define TEST2r_SPQCTf_SET BCM56218_A0_TEST2r_SPQCTf_SET
#define TEST2r_TPAUSEf_GET BCM56218_A0_TEST2r_TPAUSEf_GET
#define TEST2r_TPAUSEf_SET BCM56218_A0_TEST2r_TPAUSEf_SET
#define READ_TEST2r BCM56218_A0_READ_TEST2r
#define WRITE_TEST2r BCM56218_A0_WRITE_TEST2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_TEST2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  TOTALDYNCELLRESETLIMIT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     TOTALDYNCELLRESETLIMIT This regs is the reset limit. When total dynamic cell count is less than this reste limit. All COS hol dropping status will be reset.
 *
 ******************************************************************************/
#define BCM56218_A0_TOTALDYNCELLRESETLIMITr 0x00680051

#define BCM56218_A0_TOTALDYNCELLRESETLIMITr_SIZE 4

/*
 * This structure should be used to declare and program TOTALDYNCELLRESETLIMIT.
 *
 */
typedef union BCM56218_A0_TOTALDYNCELLRESETLIMITr_s {
	uint32_t v[1];
	uint32_t totaldyncellresetlimit[1];
	uint32_t _totaldyncellresetlimit;
} BCM56218_A0_TOTALDYNCELLRESETLIMITr_t;

#define BCM56218_A0_TOTALDYNCELLRESETLIMITr_CLR(r) (r).totaldyncellresetlimit[0] = 0
#define BCM56218_A0_TOTALDYNCELLRESETLIMITr_SET(r,d) (r).totaldyncellresetlimit[0] = d
#define BCM56218_A0_TOTALDYNCELLRESETLIMITr_GET(r) (r).totaldyncellresetlimit[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_TOTALDYNCELLRESETLIMITr_TOTALDYNCELLRESETLIMITf_GET(r) (((r).totaldyncellresetlimit[0]) & 0x3ffff)
#define BCM56218_A0_TOTALDYNCELLRESETLIMITr_TOTALDYNCELLRESETLIMITf_SET(r,f) (r).totaldyncellresetlimit[0]=(((r).totaldyncellresetlimit[0] & ~((uint32_t)0x3ffff)) | (((uint32_t)f) & 0x3ffff))

/*
 * These macros can be used to access TOTALDYNCELLRESETLIMIT.
 *
 */
#define BCM56218_A0_READ_TOTALDYNCELLRESETLIMITr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_TOTALDYNCELLRESETLIMITr,(r._totaldyncellresetlimit))
#define BCM56218_A0_WRITE_TOTALDYNCELLRESETLIMITr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_TOTALDYNCELLRESETLIMITr,&(r._totaldyncellresetlimit))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TOTALDYNCELLRESETLIMITr BCM56218_A0_TOTALDYNCELLRESETLIMITr
#define TOTALDYNCELLRESETLIMITr_SIZE BCM56218_A0_TOTALDYNCELLRESETLIMITr_SIZE
typedef BCM56218_A0_TOTALDYNCELLRESETLIMITr_t TOTALDYNCELLRESETLIMITr_t;
#define TOTALDYNCELLRESETLIMITr_CLR BCM56218_A0_TOTALDYNCELLRESETLIMITr_CLR
#define TOTALDYNCELLRESETLIMITr_SET BCM56218_A0_TOTALDYNCELLRESETLIMITr_SET
#define TOTALDYNCELLRESETLIMITr_GET BCM56218_A0_TOTALDYNCELLRESETLIMITr_GET
#define TOTALDYNCELLRESETLIMITr_TOTALDYNCELLRESETLIMITf_GET BCM56218_A0_TOTALDYNCELLRESETLIMITr_TOTALDYNCELLRESETLIMITf_GET
#define TOTALDYNCELLRESETLIMITr_TOTALDYNCELLRESETLIMITf_SET BCM56218_A0_TOTALDYNCELLRESETLIMITr_TOTALDYNCELLRESETLIMITf_SET
#define READ_TOTALDYNCELLRESETLIMITr BCM56218_A0_READ_TOTALDYNCELLRESETLIMITr
#define WRITE_TOTALDYNCELLRESETLIMITr BCM56218_A0_WRITE_TOTALDYNCELLRESETLIMITr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_TOTALDYNCELLRESETLIMITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  TOTALDYNCELLSETLIMIT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     TOTALDYNCELLSETLIMIT Total Dynamic Cell Count Limit for whole CBP memory. This represents thetotal dynamic cells that can be used by all {ports,cos}.Default value is 0xfa0.
 *
 ******************************************************************************/
#define BCM56218_A0_TOTALDYNCELLSETLIMITr 0x00680020

#define BCM56218_A0_TOTALDYNCELLSETLIMITr_SIZE 4

/*
 * This structure should be used to declare and program TOTALDYNCELLSETLIMIT.
 *
 */
typedef union BCM56218_A0_TOTALDYNCELLSETLIMITr_s {
	uint32_t v[1];
	uint32_t totaldyncellsetlimit[1];
	uint32_t _totaldyncellsetlimit;
} BCM56218_A0_TOTALDYNCELLSETLIMITr_t;

#define BCM56218_A0_TOTALDYNCELLSETLIMITr_CLR(r) (r).totaldyncellsetlimit[0] = 0
#define BCM56218_A0_TOTALDYNCELLSETLIMITr_SET(r,d) (r).totaldyncellsetlimit[0] = d
#define BCM56218_A0_TOTALDYNCELLSETLIMITr_GET(r) (r).totaldyncellsetlimit[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_TOTALDYNCELLSETLIMITr_TOTALDYNCELLSETLIMITf_GET(r) (((r).totaldyncellsetlimit[0]) & 0x3ffff)
#define BCM56218_A0_TOTALDYNCELLSETLIMITr_TOTALDYNCELLSETLIMITf_SET(r,f) (r).totaldyncellsetlimit[0]=(((r).totaldyncellsetlimit[0] & ~((uint32_t)0x3ffff)) | (((uint32_t)f) & 0x3ffff))

/*
 * These macros can be used to access TOTALDYNCELLSETLIMIT.
 *
 */
#define BCM56218_A0_READ_TOTALDYNCELLSETLIMITr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_TOTALDYNCELLSETLIMITr,(r._totaldyncellsetlimit))
#define BCM56218_A0_WRITE_TOTALDYNCELLSETLIMITr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_TOTALDYNCELLSETLIMITr,&(r._totaldyncellsetlimit))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TOTALDYNCELLSETLIMITr BCM56218_A0_TOTALDYNCELLSETLIMITr
#define TOTALDYNCELLSETLIMITr_SIZE BCM56218_A0_TOTALDYNCELLSETLIMITr_SIZE
typedef BCM56218_A0_TOTALDYNCELLSETLIMITr_t TOTALDYNCELLSETLIMITr_t;
#define TOTALDYNCELLSETLIMITr_CLR BCM56218_A0_TOTALDYNCELLSETLIMITr_CLR
#define TOTALDYNCELLSETLIMITr_SET BCM56218_A0_TOTALDYNCELLSETLIMITr_SET
#define TOTALDYNCELLSETLIMITr_GET BCM56218_A0_TOTALDYNCELLSETLIMITr_GET
#define TOTALDYNCELLSETLIMITr_TOTALDYNCELLSETLIMITf_GET BCM56218_A0_TOTALDYNCELLSETLIMITr_TOTALDYNCELLSETLIMITf_GET
#define TOTALDYNCELLSETLIMITr_TOTALDYNCELLSETLIMITf_SET BCM56218_A0_TOTALDYNCELLSETLIMITr_TOTALDYNCELLSETLIMITf_SET
#define READ_TOTALDYNCELLSETLIMITr BCM56218_A0_READ_TOTALDYNCELLSETLIMITr
#define WRITE_TOTALDYNCELLSETLIMITr BCM56218_A0_WRITE_TOTALDYNCELLSETLIMITr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_TOTALDYNCELLSETLIMITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  TOTALDYNCELLUSED
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     TOTALDYNCELLUSED Total Dynamic Cell Count for whole CBP memory.This represents thetotal dynamic cells that are be used by all {ports,cos}.
 *
 ******************************************************************************/
#define BCM56218_A0_TOTALDYNCELLUSEDr 0x00680021

#define BCM56218_A0_TOTALDYNCELLUSEDr_SIZE 4

/*
 * This structure should be used to declare and program TOTALDYNCELLUSED.
 *
 */
typedef union BCM56218_A0_TOTALDYNCELLUSEDr_s {
	uint32_t v[1];
	uint32_t totaldyncellused[1];
	uint32_t _totaldyncellused;
} BCM56218_A0_TOTALDYNCELLUSEDr_t;

#define BCM56218_A0_TOTALDYNCELLUSEDr_CLR(r) (r).totaldyncellused[0] = 0
#define BCM56218_A0_TOTALDYNCELLUSEDr_SET(r,d) (r).totaldyncellused[0] = d
#define BCM56218_A0_TOTALDYNCELLUSEDr_GET(r) (r).totaldyncellused[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_TOTALDYNCELLUSEDr_TOTALDYNCELLUSEDf_GET(r) (((r).totaldyncellused[0]) & 0x3ffff)
#define BCM56218_A0_TOTALDYNCELLUSEDr_TOTALDYNCELLUSEDf_SET(r,f) (r).totaldyncellused[0]=(((r).totaldyncellused[0] & ~((uint32_t)0x3ffff)) | (((uint32_t)f) & 0x3ffff))

/*
 * These macros can be used to access TOTALDYNCELLUSED.
 *
 */
#define BCM56218_A0_READ_TOTALDYNCELLUSEDr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_TOTALDYNCELLUSEDr,(r._totaldyncellused))
#define BCM56218_A0_WRITE_TOTALDYNCELLUSEDr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_TOTALDYNCELLUSEDr,&(r._totaldyncellused))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TOTALDYNCELLUSEDr BCM56218_A0_TOTALDYNCELLUSEDr
#define TOTALDYNCELLUSEDr_SIZE BCM56218_A0_TOTALDYNCELLUSEDr_SIZE
typedef BCM56218_A0_TOTALDYNCELLUSEDr_t TOTALDYNCELLUSEDr_t;
#define TOTALDYNCELLUSEDr_CLR BCM56218_A0_TOTALDYNCELLUSEDr_CLR
#define TOTALDYNCELLUSEDr_SET BCM56218_A0_TOTALDYNCELLUSEDr_SET
#define TOTALDYNCELLUSEDr_GET BCM56218_A0_TOTALDYNCELLUSEDr_GET
#define TOTALDYNCELLUSEDr_TOTALDYNCELLUSEDf_GET BCM56218_A0_TOTALDYNCELLUSEDr_TOTALDYNCELLUSEDf_GET
#define TOTALDYNCELLUSEDr_TOTALDYNCELLUSEDf_SET BCM56218_A0_TOTALDYNCELLUSEDr_TOTALDYNCELLUSEDf_SET
#define READ_TOTALDYNCELLUSEDr BCM56218_A0_READ_TOTALDYNCELLUSEDr
#define WRITE_TOTALDYNCELLUSEDr BCM56218_A0_WRITE_TOTALDYNCELLUSEDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_TOTALDYNCELLUSEDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  TPCE
 * BLOCKS:   EPIPE
 * DESC:     Egress Purge and Cell Error Drop Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56218_A0_TPCEr 0x0a90000c

#define BCM56218_A0_TPCEr_SIZE 4

/*
 * This structure should be used to declare and program TPCE.
 *
 */
typedef union BCM56218_A0_TPCEr_s {
	uint32_t v[1];
	uint32_t tpce[1];
	uint32_t _tpce;
} BCM56218_A0_TPCEr_t;

#define BCM56218_A0_TPCEr_CLR(r) (r).tpce[0] = 0
#define BCM56218_A0_TPCEr_SET(r,d) (r).tpce[0] = d
#define BCM56218_A0_TPCEr_GET(r) (r).tpce[0]


/*
 * These macros can be used to access TPCE.
 *
 */
#define BCM56218_A0_READ_TPCEr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_TPCEr,(r._tpce))
#define BCM56218_A0_WRITE_TPCEr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_TPCEr,&(r._tpce))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TPCEr BCM56218_A0_TPCEr
#define TPCEr_SIZE BCM56218_A0_TPCEr_SIZE
typedef BCM56218_A0_TPCEr_t TPCEr_t;
#define TPCEr_CLR BCM56218_A0_TPCEr_CLR
#define TPCEr_SET BCM56218_A0_TPCEr_SET
#define TPCEr_GET BCM56218_A0_TPCEr_GET
#define READ_TPCEr BCM56218_A0_READ_TPCEr
#define WRITE_TPCEr BCM56218_A0_WRITE_TPCEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_TPCEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  TRUNK_BITMAP
 * BLOCKS:   IPIPE
 * DESC:     Source Trunk Bitmap Table
 * SIZE:     54
 * FIELDS:
 *     TRUNK_BITMAP     Source Trunk Bitmap Table
 *     TRUNK_BITMAP_LO  Source Trunk Bitmap Table
 *     TRUNK_BITMAP_HI  Source Trunk Bitmap Table
 *
 ******************************************************************************/
#define BCM56218_A0_TRUNK_BITMAPm 0x0e730000

#define BCM56218_A0_TRUNK_BITMAPm_MIN 0
#define BCM56218_A0_TRUNK_BITMAPm_MAX 31
#define BCM56218_A0_TRUNK_BITMAPm_CMAX(u) 31
#define BCM56218_A0_TRUNK_BITMAPm_SIZE 7

/*
 * This structure should be used to declare and program TRUNK_BITMAP.
 *
 */
typedef union BCM56218_A0_TRUNK_BITMAPm_s {
	uint32_t v[2];
	uint32_t trunk_bitmap[2];
	uint32_t _trunk_bitmap;
} BCM56218_A0_TRUNK_BITMAPm_t;

#define BCM56218_A0_TRUNK_BITMAPm_CLR(r) CDK_MEMSET(&((r)._trunk_bitmap), 0, sizeof(BCM56218_A0_TRUNK_BITMAPm_t))
#define BCM56218_A0_TRUNK_BITMAPm_SET(r,i,d) (r).trunk_bitmap[i] = d
#define BCM56218_A0_TRUNK_BITMAPm_GET(r,i) (r).trunk_bitmap[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_TRUNK_BITMAPm_TRUNK_BITMAPf_GET(r,a) cdk_field_get((r).trunk_bitmap,0,53,a)
#define BCM56218_A0_TRUNK_BITMAPm_TRUNK_BITMAPf_SET(r,a) cdk_field_set((r).trunk_bitmap,0,53,a)
#define BCM56218_A0_TRUNK_BITMAPm_TRUNK_BITMAP_LOf_GET(r) ((r).trunk_bitmap[0])
#define BCM56218_A0_TRUNK_BITMAPm_TRUNK_BITMAP_LOf_SET(r,f) (r).trunk_bitmap[0]=((uint32_t)f)
#define BCM56218_A0_TRUNK_BITMAPm_TRUNK_BITMAP_HIf_GET(r) (((r).trunk_bitmap[1]) & 0x3fffff)
#define BCM56218_A0_TRUNK_BITMAPm_TRUNK_BITMAP_HIf_SET(r,f) (r).trunk_bitmap[1]=(((r).trunk_bitmap[1] & ~((uint32_t)0x3fffff)) | (((uint32_t)f) & 0x3fffff))

/*
 * These macros can be used to access TRUNK_BITMAP.
 *
 */
#define BCM56218_A0_READ_TRUNK_BITMAPm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_TRUNK_BITMAPm,i,(m._trunk_bitmap),2)
#define BCM56218_A0_WRITE_TRUNK_BITMAPm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_TRUNK_BITMAPm,i,&(m._trunk_bitmap),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TRUNK_BITMAPm BCM56218_A0_TRUNK_BITMAPm
#define TRUNK_BITMAPm_MIN BCM56218_A0_TRUNK_BITMAPm_MIN
#define TRUNK_BITMAPm_MAX BCM56218_A0_TRUNK_BITMAPm_MAX
#define TRUNK_BITMAPm_CMAX(u) BCM56218_A0_TRUNK_BITMAPm_CMAX(u)
#define TRUNK_BITMAPm_SIZE BCM56218_A0_TRUNK_BITMAPm_SIZE
typedef BCM56218_A0_TRUNK_BITMAPm_t TRUNK_BITMAPm_t;
#define TRUNK_BITMAPm_CLR BCM56218_A0_TRUNK_BITMAPm_CLR
#define TRUNK_BITMAPm_SET BCM56218_A0_TRUNK_BITMAPm_SET
#define TRUNK_BITMAPm_GET BCM56218_A0_TRUNK_BITMAPm_GET
#define TRUNK_BITMAPm_TRUNK_BITMAPf_GET BCM56218_A0_TRUNK_BITMAPm_TRUNK_BITMAPf_GET
#define TRUNK_BITMAPm_TRUNK_BITMAPf_SET BCM56218_A0_TRUNK_BITMAPm_TRUNK_BITMAPf_SET
#define TRUNK_BITMAPm_TRUNK_BITMAP_LOf_GET BCM56218_A0_TRUNK_BITMAPm_TRUNK_BITMAP_LOf_GET
#define TRUNK_BITMAPm_TRUNK_BITMAP_LOf_SET BCM56218_A0_TRUNK_BITMAPm_TRUNK_BITMAP_LOf_SET
#define TRUNK_BITMAPm_TRUNK_BITMAP_HIf_GET BCM56218_A0_TRUNK_BITMAPm_TRUNK_BITMAP_HIf_GET
#define TRUNK_BITMAPm_TRUNK_BITMAP_HIf_SET BCM56218_A0_TRUNK_BITMAPm_TRUNK_BITMAP_HIf_SET
#define READ_TRUNK_BITMAPm BCM56218_A0_READ_TRUNK_BITMAPm
#define WRITE_TRUNK_BITMAPm BCM56218_A0_WRITE_TRUNK_BITMAPm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_TRUNK_BITMAPm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  TRUNK_GROUP
 * BLOCKS:   IPIPE
 * DESC:     Egress Mask Table
 * SIZE:     83
 * FIELDS:
 *     PORT0            trunk port 0
 *     MODULE0          module id 0
 *     PORT1            trunk port 1
 *     MODULE1          module id 1
 *     PORT2            trunk port 2
 *     MODULE2          module id 2
 *     PORT3            trunk port 3
 *     MODULE3          module id 3
 *     PORT4            trunk port 4
 *     MODULE4          module id 4
 *     PORT5            trunk port 5
 *     MODULE5          module id 5
 *     PORT6            trunk port 6
 *     MODULE6          module id 6
 *     PORT7            trunk port 7
 *     MODULE7          module id 7
 *     RTAG             Supported RTAG values
 *
 ******************************************************************************/
#define BCM56218_A0_TRUNK_GROUPm 0x0e720000

#define BCM56218_A0_TRUNK_GROUPm_MIN 0
#define BCM56218_A0_TRUNK_GROUPm_MAX 31
#define BCM56218_A0_TRUNK_GROUPm_CMAX(u) 31
#define BCM56218_A0_TRUNK_GROUPm_SIZE 11

/*
 * This structure should be used to declare and program TRUNK_GROUP.
 *
 */
typedef union BCM56218_A0_TRUNK_GROUPm_s {
	uint32_t v[3];
	uint32_t trunk_group[3];
	uint32_t _trunk_group;
} BCM56218_A0_TRUNK_GROUPm_t;

#define BCM56218_A0_TRUNK_GROUPm_CLR(r) CDK_MEMSET(&((r)._trunk_group), 0, sizeof(BCM56218_A0_TRUNK_GROUPm_t))
#define BCM56218_A0_TRUNK_GROUPm_SET(r,i,d) (r).trunk_group[i] = d
#define BCM56218_A0_TRUNK_GROUPm_GET(r,i) (r).trunk_group[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_TRUNK_GROUPm_PORT0f_GET(r) (((r).trunk_group[0]) & 0x3f)
#define BCM56218_A0_TRUNK_GROUPm_PORT0f_SET(r,f) (r).trunk_group[0]=(((r).trunk_group[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM56218_A0_TRUNK_GROUPm_MODULE0f_GET(r) ((((r).trunk_group[0]) >> 6) & 0xf)
#define BCM56218_A0_TRUNK_GROUPm_MODULE0f_SET(r,f) (r).trunk_group[0]=(((r).trunk_group[0] & ~((uint32_t)0xf << 6)) | ((((uint32_t)f) & 0xf) << 6))
#define BCM56218_A0_TRUNK_GROUPm_PORT1f_GET(r) ((((r).trunk_group[0]) >> 10) & 0x3f)
#define BCM56218_A0_TRUNK_GROUPm_PORT1f_SET(r,f) (r).trunk_group[0]=(((r).trunk_group[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))
#define BCM56218_A0_TRUNK_GROUPm_MODULE1f_GET(r) ((((r).trunk_group[0]) >> 16) & 0xf)
#define BCM56218_A0_TRUNK_GROUPm_MODULE1f_SET(r,f) (r).trunk_group[0]=(((r).trunk_group[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM56218_A0_TRUNK_GROUPm_PORT2f_GET(r) ((((r).trunk_group[0]) >> 20) & 0x3f)
#define BCM56218_A0_TRUNK_GROUPm_PORT2f_SET(r,f) (r).trunk_group[0]=(((r).trunk_group[0] & ~((uint32_t)0x3f << 20)) | ((((uint32_t)f) & 0x3f) << 20))
#define BCM56218_A0_TRUNK_GROUPm_MODULE2f_GET(r) ((((r).trunk_group[0]) >> 26) & 0xf)
#define BCM56218_A0_TRUNK_GROUPm_MODULE2f_SET(r,f) (r).trunk_group[0]=(((r).trunk_group[0] & ~((uint32_t)0xf << 26)) | ((((uint32_t)f) & 0xf) << 26))
#define BCM56218_A0_TRUNK_GROUPm_PORT3f_GET(r) cdk_field32_get((r).trunk_group,30,35)
#define BCM56218_A0_TRUNK_GROUPm_PORT3f_SET(r,f) cdk_field32_set((r).trunk_group,30,35,f)
#define BCM56218_A0_TRUNK_GROUPm_MODULE3f_GET(r) ((((r).trunk_group[1]) >> 4) & 0xf)
#define BCM56218_A0_TRUNK_GROUPm_MODULE3f_SET(r,f) (r).trunk_group[1]=(((r).trunk_group[1] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56218_A0_TRUNK_GROUPm_PORT4f_GET(r) ((((r).trunk_group[1]) >> 8) & 0x3f)
#define BCM56218_A0_TRUNK_GROUPm_PORT4f_SET(r,f) (r).trunk_group[1]=(((r).trunk_group[1] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define BCM56218_A0_TRUNK_GROUPm_MODULE4f_GET(r) ((((r).trunk_group[1]) >> 14) & 0xf)
#define BCM56218_A0_TRUNK_GROUPm_MODULE4f_SET(r,f) (r).trunk_group[1]=(((r).trunk_group[1] & ~((uint32_t)0xf << 14)) | ((((uint32_t)f) & 0xf) << 14))
#define BCM56218_A0_TRUNK_GROUPm_PORT5f_GET(r) ((((r).trunk_group[1]) >> 18) & 0x3f)
#define BCM56218_A0_TRUNK_GROUPm_PORT5f_SET(r,f) (r).trunk_group[1]=(((r).trunk_group[1] & ~((uint32_t)0x3f << 18)) | ((((uint32_t)f) & 0x3f) << 18))
#define BCM56218_A0_TRUNK_GROUPm_MODULE5f_GET(r) ((((r).trunk_group[1]) >> 24) & 0xf)
#define BCM56218_A0_TRUNK_GROUPm_MODULE5f_SET(r,f) (r).trunk_group[1]=(((r).trunk_group[1] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM56218_A0_TRUNK_GROUPm_PORT6f_GET(r) cdk_field32_get((r).trunk_group,60,65)
#define BCM56218_A0_TRUNK_GROUPm_PORT6f_SET(r,f) cdk_field32_set((r).trunk_group,60,65,f)
#define BCM56218_A0_TRUNK_GROUPm_MODULE6f_GET(r) ((((r).trunk_group[2]) >> 2) & 0xf)
#define BCM56218_A0_TRUNK_GROUPm_MODULE6f_SET(r,f) (r).trunk_group[2]=(((r).trunk_group[2] & ~((uint32_t)0xf << 2)) | ((((uint32_t)f) & 0xf) << 2))
#define BCM56218_A0_TRUNK_GROUPm_PORT7f_GET(r) ((((r).trunk_group[2]) >> 6) & 0x3f)
#define BCM56218_A0_TRUNK_GROUPm_PORT7f_SET(r,f) (r).trunk_group[2]=(((r).trunk_group[2] & ~((uint32_t)0x3f << 6)) | ((((uint32_t)f) & 0x3f) << 6))
#define BCM56218_A0_TRUNK_GROUPm_MODULE7f_GET(r) ((((r).trunk_group[2]) >> 12) & 0xf)
#define BCM56218_A0_TRUNK_GROUPm_MODULE7f_SET(r,f) (r).trunk_group[2]=(((r).trunk_group[2] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM56218_A0_TRUNK_GROUPm_RTAGf_GET(r) ((((r).trunk_group[2]) >> 16) & 0x7)
#define BCM56218_A0_TRUNK_GROUPm_RTAGf_SET(r,f) (r).trunk_group[2]=(((r).trunk_group[2] & ~((uint32_t)0x7 << 16)) | ((((uint32_t)f) & 0x7) << 16))

/*
 * These macros can be used to access TRUNK_GROUP.
 *
 */
#define BCM56218_A0_READ_TRUNK_GROUPm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_TRUNK_GROUPm,i,(m._trunk_group),3)
#define BCM56218_A0_WRITE_TRUNK_GROUPm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_TRUNK_GROUPm,i,&(m._trunk_group),3)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TRUNK_GROUPm BCM56218_A0_TRUNK_GROUPm
#define TRUNK_GROUPm_MIN BCM56218_A0_TRUNK_GROUPm_MIN
#define TRUNK_GROUPm_MAX BCM56218_A0_TRUNK_GROUPm_MAX
#define TRUNK_GROUPm_CMAX(u) BCM56218_A0_TRUNK_GROUPm_CMAX(u)
#define TRUNK_GROUPm_SIZE BCM56218_A0_TRUNK_GROUPm_SIZE
typedef BCM56218_A0_TRUNK_GROUPm_t TRUNK_GROUPm_t;
#define TRUNK_GROUPm_CLR BCM56218_A0_TRUNK_GROUPm_CLR
#define TRUNK_GROUPm_SET BCM56218_A0_TRUNK_GROUPm_SET
#define TRUNK_GROUPm_GET BCM56218_A0_TRUNK_GROUPm_GET
#define TRUNK_GROUPm_PORT0f_GET BCM56218_A0_TRUNK_GROUPm_PORT0f_GET
#define TRUNK_GROUPm_PORT0f_SET BCM56218_A0_TRUNK_GROUPm_PORT0f_SET
#define TRUNK_GROUPm_MODULE0f_GET BCM56218_A0_TRUNK_GROUPm_MODULE0f_GET
#define TRUNK_GROUPm_MODULE0f_SET BCM56218_A0_TRUNK_GROUPm_MODULE0f_SET
#define TRUNK_GROUPm_PORT1f_GET BCM56218_A0_TRUNK_GROUPm_PORT1f_GET
#define TRUNK_GROUPm_PORT1f_SET BCM56218_A0_TRUNK_GROUPm_PORT1f_SET
#define TRUNK_GROUPm_MODULE1f_GET BCM56218_A0_TRUNK_GROUPm_MODULE1f_GET
#define TRUNK_GROUPm_MODULE1f_SET BCM56218_A0_TRUNK_GROUPm_MODULE1f_SET
#define TRUNK_GROUPm_PORT2f_GET BCM56218_A0_TRUNK_GROUPm_PORT2f_GET
#define TRUNK_GROUPm_PORT2f_SET BCM56218_A0_TRUNK_GROUPm_PORT2f_SET
#define TRUNK_GROUPm_MODULE2f_GET BCM56218_A0_TRUNK_GROUPm_MODULE2f_GET
#define TRUNK_GROUPm_MODULE2f_SET BCM56218_A0_TRUNK_GROUPm_MODULE2f_SET
#define TRUNK_GROUPm_PORT3f_GET BCM56218_A0_TRUNK_GROUPm_PORT3f_GET
#define TRUNK_GROUPm_PORT3f_SET BCM56218_A0_TRUNK_GROUPm_PORT3f_SET
#define TRUNK_GROUPm_MODULE3f_GET BCM56218_A0_TRUNK_GROUPm_MODULE3f_GET
#define TRUNK_GROUPm_MODULE3f_SET BCM56218_A0_TRUNK_GROUPm_MODULE3f_SET
#define TRUNK_GROUPm_PORT4f_GET BCM56218_A0_TRUNK_GROUPm_PORT4f_GET
#define TRUNK_GROUPm_PORT4f_SET BCM56218_A0_TRUNK_GROUPm_PORT4f_SET
#define TRUNK_GROUPm_MODULE4f_GET BCM56218_A0_TRUNK_GROUPm_MODULE4f_GET
#define TRUNK_GROUPm_MODULE4f_SET BCM56218_A0_TRUNK_GROUPm_MODULE4f_SET
#define TRUNK_GROUPm_PORT5f_GET BCM56218_A0_TRUNK_GROUPm_PORT5f_GET
#define TRUNK_GROUPm_PORT5f_SET BCM56218_A0_TRUNK_GROUPm_PORT5f_SET
#define TRUNK_GROUPm_MODULE5f_GET BCM56218_A0_TRUNK_GROUPm_MODULE5f_GET
#define TRUNK_GROUPm_MODULE5f_SET BCM56218_A0_TRUNK_GROUPm_MODULE5f_SET
#define TRUNK_GROUPm_PORT6f_GET BCM56218_A0_TRUNK_GROUPm_PORT6f_GET
#define TRUNK_GROUPm_PORT6f_SET BCM56218_A0_TRUNK_GROUPm_PORT6f_SET
#define TRUNK_GROUPm_MODULE6f_GET BCM56218_A0_TRUNK_GROUPm_MODULE6f_GET
#define TRUNK_GROUPm_MODULE6f_SET BCM56218_A0_TRUNK_GROUPm_MODULE6f_SET
#define TRUNK_GROUPm_PORT7f_GET BCM56218_A0_TRUNK_GROUPm_PORT7f_GET
#define TRUNK_GROUPm_PORT7f_SET BCM56218_A0_TRUNK_GROUPm_PORT7f_SET
#define TRUNK_GROUPm_MODULE7f_GET BCM56218_A0_TRUNK_GROUPm_MODULE7f_GET
#define TRUNK_GROUPm_MODULE7f_SET BCM56218_A0_TRUNK_GROUPm_MODULE7f_SET
#define TRUNK_GROUPm_RTAGf_GET BCM56218_A0_TRUNK_GROUPm_RTAGf_GET
#define TRUNK_GROUPm_RTAGf_SET BCM56218_A0_TRUNK_GROUPm_RTAGf_SET
#define READ_TRUNK_GROUPm BCM56218_A0_READ_TRUNK_GROUPm
#define WRITE_TRUNK_GROUPm BCM56218_A0_WRITE_TRUNK_GROUPm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_TRUNK_GROUPm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * SWFORMAT:  TX_DCB
 * BLOCKS:  
 * DESC:     Packet DMA descriptor.
 * SIZE:     352
 * FIELDS:
 *     BYTES_TRANSFERRED Number of bytes transferred.
 *     DONE             Descriptor done.
 *     MODULE_HEADER    Valid only if the HG bit is set to 1 in this descriptor.
 *     BYTE_COUNT       Byte count for the transfer.
 *     CHAIN            Indicates that next sequential descriptor is valid.
 *     SG               Scatter/Gather - packet continues in the next DMA descriptor.
 *     RELOAD           Load next descriptor from address in ADDR field.
 *     HG               Specifies whether the current packet is in HiGig format.0=Regular Ethernet format, 1=HiGig format
 *     STAT             Update statistics counters (TX packet).
 *     PAUSE            Set to indicate that TX packet is a pause frame.
 *     PURGE            Set to indicate that TX packet should be purged.
 *     ADDR             Physical memory address for the transfer.
 *
 ******************************************************************************/
#define BCM56218_A0_TX_DCB 0x00000000

#define BCM56218_A0_TX_DCB_SIZE 44

/*
 * This structure should be used to declare and program TX_DCB.
 *
 */
typedef union BCM56218_A0_TX_DCB_s {
	uint32_t v[11];
	uint32_t tx_dcb[11];
	uint32_t _tx_dcb;
} BCM56218_A0_TX_DCB_t;

#define BCM56218_A0_TX_DCB_CLR(r) CDK_MEMSET(&((r)._tx_dcb), 0, sizeof(BCM56218_A0_TX_DCB_t))
#define BCM56218_A0_TX_DCB_SET(r,i,d) (r).tx_dcb[i] = d
#define BCM56218_A0_TX_DCB_GET(r,i) (r).tx_dcb[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_TX_DCB_BYTES_TRANSFERREDf_GET(r) (((r).tx_dcb[10]) & 0xffff)
#define BCM56218_A0_TX_DCB_BYTES_TRANSFERREDf_SET(r,f) (r).tx_dcb[10]=(((r).tx_dcb[10] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56218_A0_TX_DCB_DONEf_GET(r) ((((r).tx_dcb[10]) >> 31) & 0x1)
#define BCM56218_A0_TX_DCB_DONEf_SET(r,f) (r).tx_dcb[10]=(((r).tx_dcb[10] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM56218_A0_TX_DCB_MODULE_HEADERf_GET(r,a) cdk_field_be_get((r).tx_dcb,11,160,287,a)
#define BCM56218_A0_TX_DCB_MODULE_HEADERf_SET(r,a) cdk_field_be_set((r).tx_dcb,11,160,287,a)
#define BCM56218_A0_TX_DCB_MODULE_HEADERf_PTR(r) ((void*)&(r).tx_dcb[2])
#define BCM56218_A0_TX_DCB_BYTE_COUNTf_GET(r) (((r).tx_dcb[1]) & 0xffff)
#define BCM56218_A0_TX_DCB_BYTE_COUNTf_SET(r,f) (r).tx_dcb[1]=(((r).tx_dcb[1] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56218_A0_TX_DCB_CHAINf_GET(r) ((((r).tx_dcb[1]) >> 16) & 0x1)
#define BCM56218_A0_TX_DCB_CHAINf_SET(r,f) (r).tx_dcb[1]=(((r).tx_dcb[1] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56218_A0_TX_DCB_SGf_GET(r) ((((r).tx_dcb[1]) >> 17) & 0x1)
#define BCM56218_A0_TX_DCB_SGf_SET(r,f) (r).tx_dcb[1]=(((r).tx_dcb[1] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_TX_DCB_RELOADf_GET(r) ((((r).tx_dcb[1]) >> 18) & 0x1)
#define BCM56218_A0_TX_DCB_RELOADf_SET(r,f) (r).tx_dcb[1]=(((r).tx_dcb[1] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_TX_DCB_HGf_GET(r) ((((r).tx_dcb[1]) >> 19) & 0x1)
#define BCM56218_A0_TX_DCB_HGf_SET(r,f) (r).tx_dcb[1]=(((r).tx_dcb[1] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56218_A0_TX_DCB_STATf_GET(r) ((((r).tx_dcb[1]) >> 20) & 0x1)
#define BCM56218_A0_TX_DCB_STATf_SET(r,f) (r).tx_dcb[1]=(((r).tx_dcb[1] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM56218_A0_TX_DCB_PAUSEf_GET(r) ((((r).tx_dcb[1]) >> 21) & 0x1)
#define BCM56218_A0_TX_DCB_PAUSEf_SET(r,f) (r).tx_dcb[1]=(((r).tx_dcb[1] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM56218_A0_TX_DCB_PURGEf_GET(r) ((((r).tx_dcb[1]) >> 22) & 0x1)
#define BCM56218_A0_TX_DCB_PURGEf_SET(r,f) (r).tx_dcb[1]=(((r).tx_dcb[1] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM56218_A0_TX_DCB_ADDRf_GET(r) ((r).tx_dcb[0])
#define BCM56218_A0_TX_DCB_ADDRf_SET(r,f) (r).tx_dcb[0]=((uint32_t)f)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TX_DCB BCM56218_A0_TX_DCB
#define TX_DCB_SIZE BCM56218_A0_TX_DCB_SIZE
typedef BCM56218_A0_TX_DCB_t TX_DCB_t;
#define TX_DCB_CLR BCM56218_A0_TX_DCB_CLR
#define TX_DCB_SET BCM56218_A0_TX_DCB_SET
#define TX_DCB_GET BCM56218_A0_TX_DCB_GET
#define TX_DCB_BYTES_TRANSFERREDf_GET BCM56218_A0_TX_DCB_BYTES_TRANSFERREDf_GET
#define TX_DCB_BYTES_TRANSFERREDf_SET BCM56218_A0_TX_DCB_BYTES_TRANSFERREDf_SET
#define TX_DCB_DONEf_GET BCM56218_A0_TX_DCB_DONEf_GET
#define TX_DCB_DONEf_SET BCM56218_A0_TX_DCB_DONEf_SET
#define TX_DCB_MODULE_HEADERf_GET BCM56218_A0_TX_DCB_MODULE_HEADERf_GET
#define TX_DCB_MODULE_HEADERf_SET BCM56218_A0_TX_DCB_MODULE_HEADERf_SET
#define TX_DCB_MODULE_HEADERf_PTR BCM56218_A0_TX_DCB_MODULE_HEADERf_PTR
#define TX_DCB_BYTE_COUNTf_GET BCM56218_A0_TX_DCB_BYTE_COUNTf_GET
#define TX_DCB_BYTE_COUNTf_SET BCM56218_A0_TX_DCB_BYTE_COUNTf_SET
#define TX_DCB_CHAINf_GET BCM56218_A0_TX_DCB_CHAINf_GET
#define TX_DCB_CHAINf_SET BCM56218_A0_TX_DCB_CHAINf_SET
#define TX_DCB_SGf_GET BCM56218_A0_TX_DCB_SGf_GET
#define TX_DCB_SGf_SET BCM56218_A0_TX_DCB_SGf_SET
#define TX_DCB_RELOADf_GET BCM56218_A0_TX_DCB_RELOADf_GET
#define TX_DCB_RELOADf_SET BCM56218_A0_TX_DCB_RELOADf_SET
#define TX_DCB_HGf_GET BCM56218_A0_TX_DCB_HGf_GET
#define TX_DCB_HGf_SET BCM56218_A0_TX_DCB_HGf_SET
#define TX_DCB_STATf_GET BCM56218_A0_TX_DCB_STATf_GET
#define TX_DCB_STATf_SET BCM56218_A0_TX_DCB_STATf_SET
#define TX_DCB_PAUSEf_GET BCM56218_A0_TX_DCB_PAUSEf_GET
#define TX_DCB_PAUSEf_SET BCM56218_A0_TX_DCB_PAUSEf_SET
#define TX_DCB_PURGEf_GET BCM56218_A0_TX_DCB_PURGEf_GET
#define TX_DCB_PURGEf_SET BCM56218_A0_TX_DCB_PURGEf_SET
#define TX_DCB_ADDRf_GET BCM56218_A0_TX_DCB_ADDRf_GET
#define TX_DCB_ADDRf_SET BCM56218_A0_TX_DCB_ADDRf_SET
#define READ_TX_DCB BCM56218_A0_READ_TX_DCB
#define WRITE_TX_DCB BCM56218_A0_WRITE_TX_DCB

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_TX_DCB'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  UDF_ETHERTYPE_MATCH
 * BLOCKS:   IPIPE
 * DESC:     UDF Ethertype Match Register (used to select unique UDF offsets for different EtherTypes
 * SIZE:     32
 * FIELDS:
 *     ETHERTYPE        Programmable ethertype to match for UDF ethertype match
 *     RESERVED0        Unused bit
 *     L2_PACKET_FORMAT L2 packet format to match for UDF ethertype match
 *     ENABLE           Enables UDF ethertype match
 *
 ******************************************************************************/
#define BCM56218_A0_UDF_ETHERTYPE_MATCHr 0x02780000

#define BCM56218_A0_UDF_ETHERTYPE_MATCHr_SIZE 4

/*
 * This structure should be used to declare and program UDF_ETHERTYPE_MATCH.
 *
 */
typedef union BCM56218_A0_UDF_ETHERTYPE_MATCHr_s {
	uint32_t v[1];
	uint32_t udf_ethertype_match[1];
	uint32_t _udf_ethertype_match;
} BCM56218_A0_UDF_ETHERTYPE_MATCHr_t;

#define BCM56218_A0_UDF_ETHERTYPE_MATCHr_CLR(r) (r).udf_ethertype_match[0] = 0
#define BCM56218_A0_UDF_ETHERTYPE_MATCHr_SET(r,d) (r).udf_ethertype_match[0] = d
#define BCM56218_A0_UDF_ETHERTYPE_MATCHr_GET(r) (r).udf_ethertype_match[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_UDF_ETHERTYPE_MATCHr_ETHERTYPEf_GET(r) (((r).udf_ethertype_match[0]) & 0xffff)
#define BCM56218_A0_UDF_ETHERTYPE_MATCHr_ETHERTYPEf_SET(r,f) (r).udf_ethertype_match[0]=(((r).udf_ethertype_match[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56218_A0_UDF_ETHERTYPE_MATCHr_RESERVED0f_GET(r) ((((r).udf_ethertype_match[0]) >> 16) & 0x1)
#define BCM56218_A0_UDF_ETHERTYPE_MATCHr_RESERVED0f_SET(r,f) (r).udf_ethertype_match[0]=(((r).udf_ethertype_match[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56218_A0_UDF_ETHERTYPE_MATCHr_L2_PACKET_FORMATf_GET(r) ((((r).udf_ethertype_match[0]) >> 17) & 0x3)
#define BCM56218_A0_UDF_ETHERTYPE_MATCHr_L2_PACKET_FORMATf_SET(r,f) (r).udf_ethertype_match[0]=(((r).udf_ethertype_match[0] & ~((uint32_t)0x3 << 17)) | ((((uint32_t)f) & 0x3) << 17))
#define BCM56218_A0_UDF_ETHERTYPE_MATCHr_ENABLEf_GET(r) ((((r).udf_ethertype_match[0]) >> 19) & 0x1)
#define BCM56218_A0_UDF_ETHERTYPE_MATCHr_ENABLEf_SET(r,f) (r).udf_ethertype_match[0]=(((r).udf_ethertype_match[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access UDF_ETHERTYPE_MATCH.
 *
 */
#define BCM56218_A0_READ_UDF_ETHERTYPE_MATCHr(u,i,r) cdk_xgs_reg32_read(u,BCM56218_A0_UDF_ETHERTYPE_MATCHr+(i),(r._udf_ethertype_match))
#define BCM56218_A0_WRITE_UDF_ETHERTYPE_MATCHr(u,i,r) cdk_xgs_reg32_write(u,BCM56218_A0_UDF_ETHERTYPE_MATCHr+(i),&(r._udf_ethertype_match))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define UDF_ETHERTYPE_MATCHr BCM56218_A0_UDF_ETHERTYPE_MATCHr
#define UDF_ETHERTYPE_MATCHr_SIZE BCM56218_A0_UDF_ETHERTYPE_MATCHr_SIZE
typedef BCM56218_A0_UDF_ETHERTYPE_MATCHr_t UDF_ETHERTYPE_MATCHr_t;
#define UDF_ETHERTYPE_MATCHr_CLR BCM56218_A0_UDF_ETHERTYPE_MATCHr_CLR
#define UDF_ETHERTYPE_MATCHr_SET BCM56218_A0_UDF_ETHERTYPE_MATCHr_SET
#define UDF_ETHERTYPE_MATCHr_GET BCM56218_A0_UDF_ETHERTYPE_MATCHr_GET
#define UDF_ETHERTYPE_MATCHr_ETHERTYPEf_GET BCM56218_A0_UDF_ETHERTYPE_MATCHr_ETHERTYPEf_GET
#define UDF_ETHERTYPE_MATCHr_ETHERTYPEf_SET BCM56218_A0_UDF_ETHERTYPE_MATCHr_ETHERTYPEf_SET
#define UDF_ETHERTYPE_MATCHr_RESERVED0f_GET BCM56218_A0_UDF_ETHERTYPE_MATCHr_RESERVED0f_GET
#define UDF_ETHERTYPE_MATCHr_RESERVED0f_SET BCM56218_A0_UDF_ETHERTYPE_MATCHr_RESERVED0f_SET
#define UDF_ETHERTYPE_MATCHr_L2_PACKET_FORMATf_GET BCM56218_A0_UDF_ETHERTYPE_MATCHr_L2_PACKET_FORMATf_GET
#define UDF_ETHERTYPE_MATCHr_L2_PACKET_FORMATf_SET BCM56218_A0_UDF_ETHERTYPE_MATCHr_L2_PACKET_FORMATf_SET
#define UDF_ETHERTYPE_MATCHr_ENABLEf_GET BCM56218_A0_UDF_ETHERTYPE_MATCHr_ENABLEf_GET
#define UDF_ETHERTYPE_MATCHr_ENABLEf_SET BCM56218_A0_UDF_ETHERTYPE_MATCHr_ENABLEf_SET
#define READ_UDF_ETHERTYPE_MATCHr BCM56218_A0_READ_UDF_ETHERTYPE_MATCHr
#define WRITE_UDF_ETHERTYPE_MATCHr BCM56218_A0_WRITE_UDF_ETHERTYPE_MATCHr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_UDF_ETHERTYPE_MATCHr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  UDF_IPPROTO_MATCH
 * BLOCKS:   IPIPE
 * DESC:     UDF IP Protocol Matching Register (select unique UDF offsets for different IP protocols)
 * SIZE:     32
 * FIELDS:
 *     PROTOCOL         IP protocol to match
 *     IPV6ENABLE       Enable this UDF matching mechanism for IPv6
 *     IPV4ENABLE       Enable this UDF matching mechanism for IPv4
 *
 ******************************************************************************/
#define BCM56218_A0_UDF_IPPROTO_MATCHr 0x02780008

#define BCM56218_A0_UDF_IPPROTO_MATCHr_SIZE 4

/*
 * This structure should be used to declare and program UDF_IPPROTO_MATCH.
 *
 */
typedef union BCM56218_A0_UDF_IPPROTO_MATCHr_s {
	uint32_t v[1];
	uint32_t udf_ipproto_match[1];
	uint32_t _udf_ipproto_match;
} BCM56218_A0_UDF_IPPROTO_MATCHr_t;

#define BCM56218_A0_UDF_IPPROTO_MATCHr_CLR(r) (r).udf_ipproto_match[0] = 0
#define BCM56218_A0_UDF_IPPROTO_MATCHr_SET(r,d) (r).udf_ipproto_match[0] = d
#define BCM56218_A0_UDF_IPPROTO_MATCHr_GET(r) (r).udf_ipproto_match[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_UDF_IPPROTO_MATCHr_PROTOCOLf_GET(r) (((r).udf_ipproto_match[0]) & 0xff)
#define BCM56218_A0_UDF_IPPROTO_MATCHr_PROTOCOLf_SET(r,f) (r).udf_ipproto_match[0]=(((r).udf_ipproto_match[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56218_A0_UDF_IPPROTO_MATCHr_IPV6ENABLEf_GET(r) ((((r).udf_ipproto_match[0]) >> 8) & 0x1)
#define BCM56218_A0_UDF_IPPROTO_MATCHr_IPV6ENABLEf_SET(r,f) (r).udf_ipproto_match[0]=(((r).udf_ipproto_match[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56218_A0_UDF_IPPROTO_MATCHr_IPV4ENABLEf_GET(r) ((((r).udf_ipproto_match[0]) >> 9) & 0x1)
#define BCM56218_A0_UDF_IPPROTO_MATCHr_IPV4ENABLEf_SET(r,f) (r).udf_ipproto_match[0]=(((r).udf_ipproto_match[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))

/*
 * These macros can be used to access UDF_IPPROTO_MATCH.
 *
 */
#define BCM56218_A0_READ_UDF_IPPROTO_MATCHr(u,i,r) cdk_xgs_reg32_read(u,BCM56218_A0_UDF_IPPROTO_MATCHr+(i),(r._udf_ipproto_match))
#define BCM56218_A0_WRITE_UDF_IPPROTO_MATCHr(u,i,r) cdk_xgs_reg32_write(u,BCM56218_A0_UDF_IPPROTO_MATCHr+(i),&(r._udf_ipproto_match))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define UDF_IPPROTO_MATCHr BCM56218_A0_UDF_IPPROTO_MATCHr
#define UDF_IPPROTO_MATCHr_SIZE BCM56218_A0_UDF_IPPROTO_MATCHr_SIZE
typedef BCM56218_A0_UDF_IPPROTO_MATCHr_t UDF_IPPROTO_MATCHr_t;
#define UDF_IPPROTO_MATCHr_CLR BCM56218_A0_UDF_IPPROTO_MATCHr_CLR
#define UDF_IPPROTO_MATCHr_SET BCM56218_A0_UDF_IPPROTO_MATCHr_SET
#define UDF_IPPROTO_MATCHr_GET BCM56218_A0_UDF_IPPROTO_MATCHr_GET
#define UDF_IPPROTO_MATCHr_PROTOCOLf_GET BCM56218_A0_UDF_IPPROTO_MATCHr_PROTOCOLf_GET
#define UDF_IPPROTO_MATCHr_PROTOCOLf_SET BCM56218_A0_UDF_IPPROTO_MATCHr_PROTOCOLf_SET
#define UDF_IPPROTO_MATCHr_IPV6ENABLEf_GET BCM56218_A0_UDF_IPPROTO_MATCHr_IPV6ENABLEf_GET
#define UDF_IPPROTO_MATCHr_IPV6ENABLEf_SET BCM56218_A0_UDF_IPPROTO_MATCHr_IPV6ENABLEf_SET
#define UDF_IPPROTO_MATCHr_IPV4ENABLEf_GET BCM56218_A0_UDF_IPPROTO_MATCHr_IPV4ENABLEf_GET
#define UDF_IPPROTO_MATCHr_IPV4ENABLEf_SET BCM56218_A0_UDF_IPPROTO_MATCHr_IPV4ENABLEf_SET
#define READ_UDF_IPPROTO_MATCHr BCM56218_A0_READ_UDF_IPPROTO_MATCHr
#define WRITE_UDF_IPPROTO_MATCHr BCM56218_A0_WRITE_UDF_IPPROTO_MATCHr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_UDF_IPPROTO_MATCHr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  UNKNOWN_MCAST_BLOCK_MASK
 * BLOCKS:   IPIPE
 * DESC:     Unknown Multicast Block Mask - Lower Bitmap
 * SIZE:     32
 * FIELDS:
 *     BLK_BITMAP       Bitmap of ports to be blocked
 *
 ******************************************************************************/
#define BCM56218_A0_UNKNOWN_MCAST_BLOCK_MASKr 0x0e700102

#define BCM56218_A0_UNKNOWN_MCAST_BLOCK_MASKr_SIZE 4

/*
 * This structure should be used to declare and program UNKNOWN_MCAST_BLOCK_MASK.
 *
 */
typedef union BCM56218_A0_UNKNOWN_MCAST_BLOCK_MASKr_s {
	uint32_t v[1];
	uint32_t unknown_mcast_block_mask[1];
	uint32_t _unknown_mcast_block_mask;
} BCM56218_A0_UNKNOWN_MCAST_BLOCK_MASKr_t;

#define BCM56218_A0_UNKNOWN_MCAST_BLOCK_MASKr_CLR(r) (r).unknown_mcast_block_mask[0] = 0
#define BCM56218_A0_UNKNOWN_MCAST_BLOCK_MASKr_SET(r,d) (r).unknown_mcast_block_mask[0] = d
#define BCM56218_A0_UNKNOWN_MCAST_BLOCK_MASKr_GET(r) (r).unknown_mcast_block_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_UNKNOWN_MCAST_BLOCK_MASKr_BLK_BITMAPf_GET(r) ((r).unknown_mcast_block_mask[0])
#define BCM56218_A0_UNKNOWN_MCAST_BLOCK_MASKr_BLK_BITMAPf_SET(r,f) (r).unknown_mcast_block_mask[0]=((uint32_t)f)

/*
 * These macros can be used to access UNKNOWN_MCAST_BLOCK_MASK.
 *
 */
#define BCM56218_A0_READ_UNKNOWN_MCAST_BLOCK_MASKr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_UNKNOWN_MCAST_BLOCK_MASKr,(r._unknown_mcast_block_mask))
#define BCM56218_A0_WRITE_UNKNOWN_MCAST_BLOCK_MASKr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_UNKNOWN_MCAST_BLOCK_MASKr,&(r._unknown_mcast_block_mask))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define UNKNOWN_MCAST_BLOCK_MASKr BCM56218_A0_UNKNOWN_MCAST_BLOCK_MASKr
#define UNKNOWN_MCAST_BLOCK_MASKr_SIZE BCM56218_A0_UNKNOWN_MCAST_BLOCK_MASKr_SIZE
typedef BCM56218_A0_UNKNOWN_MCAST_BLOCK_MASKr_t UNKNOWN_MCAST_BLOCK_MASKr_t;
#define UNKNOWN_MCAST_BLOCK_MASKr_CLR BCM56218_A0_UNKNOWN_MCAST_BLOCK_MASKr_CLR
#define UNKNOWN_MCAST_BLOCK_MASKr_SET BCM56218_A0_UNKNOWN_MCAST_BLOCK_MASKr_SET
#define UNKNOWN_MCAST_BLOCK_MASKr_GET BCM56218_A0_UNKNOWN_MCAST_BLOCK_MASKr_GET
#define UNKNOWN_MCAST_BLOCK_MASKr_BLK_BITMAPf_GET BCM56218_A0_UNKNOWN_MCAST_BLOCK_MASKr_BLK_BITMAPf_GET
#define UNKNOWN_MCAST_BLOCK_MASKr_BLK_BITMAPf_SET BCM56218_A0_UNKNOWN_MCAST_BLOCK_MASKr_BLK_BITMAPf_SET
#define READ_UNKNOWN_MCAST_BLOCK_MASKr BCM56218_A0_READ_UNKNOWN_MCAST_BLOCK_MASKr
#define WRITE_UNKNOWN_MCAST_BLOCK_MASKr BCM56218_A0_WRITE_UNKNOWN_MCAST_BLOCK_MASKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_UNKNOWN_MCAST_BLOCK_MASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  UNKNOWN_MCAST_BLOCK_MASK_HI
 * BLOCKS:   IPIPE
 * DESC:     Unknown Multicast Block Mask - Upper Bitmap
 * SIZE:     32
 * FIELDS:
 *     BLK_BITMAP       Bitmap of ports to be blocked
 *
 ******************************************************************************/
#define BCM56218_A0_UNKNOWN_MCAST_BLOCK_MASK_HIr 0x0e700103

#define BCM56218_A0_UNKNOWN_MCAST_BLOCK_MASK_HIr_SIZE 4

/*
 * This structure should be used to declare and program UNKNOWN_MCAST_BLOCK_MASK_HI.
 *
 */
typedef union BCM56218_A0_UNKNOWN_MCAST_BLOCK_MASK_HIr_s {
	uint32_t v[1];
	uint32_t unknown_mcast_block_mask_hi[1];
	uint32_t _unknown_mcast_block_mask_hi;
} BCM56218_A0_UNKNOWN_MCAST_BLOCK_MASK_HIr_t;

#define BCM56218_A0_UNKNOWN_MCAST_BLOCK_MASK_HIr_CLR(r) (r).unknown_mcast_block_mask_hi[0] = 0
#define BCM56218_A0_UNKNOWN_MCAST_BLOCK_MASK_HIr_SET(r,d) (r).unknown_mcast_block_mask_hi[0] = d
#define BCM56218_A0_UNKNOWN_MCAST_BLOCK_MASK_HIr_GET(r) (r).unknown_mcast_block_mask_hi[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_UNKNOWN_MCAST_BLOCK_MASK_HIr_BLK_BITMAPf_GET(r) (((r).unknown_mcast_block_mask_hi[0]) & 0x3fffff)
#define BCM56218_A0_UNKNOWN_MCAST_BLOCK_MASK_HIr_BLK_BITMAPf_SET(r,f) (r).unknown_mcast_block_mask_hi[0]=(((r).unknown_mcast_block_mask_hi[0] & ~((uint32_t)0x3fffff)) | (((uint32_t)f) & 0x3fffff))

/*
 * These macros can be used to access UNKNOWN_MCAST_BLOCK_MASK_HI.
 *
 */
#define BCM56218_A0_READ_UNKNOWN_MCAST_BLOCK_MASK_HIr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_UNKNOWN_MCAST_BLOCK_MASK_HIr,(r._unknown_mcast_block_mask_hi))
#define BCM56218_A0_WRITE_UNKNOWN_MCAST_BLOCK_MASK_HIr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_UNKNOWN_MCAST_BLOCK_MASK_HIr,&(r._unknown_mcast_block_mask_hi))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define UNKNOWN_MCAST_BLOCK_MASK_HIr BCM56218_A0_UNKNOWN_MCAST_BLOCK_MASK_HIr
#define UNKNOWN_MCAST_BLOCK_MASK_HIr_SIZE BCM56218_A0_UNKNOWN_MCAST_BLOCK_MASK_HIr_SIZE
typedef BCM56218_A0_UNKNOWN_MCAST_BLOCK_MASK_HIr_t UNKNOWN_MCAST_BLOCK_MASK_HIr_t;
#define UNKNOWN_MCAST_BLOCK_MASK_HIr_CLR BCM56218_A0_UNKNOWN_MCAST_BLOCK_MASK_HIr_CLR
#define UNKNOWN_MCAST_BLOCK_MASK_HIr_SET BCM56218_A0_UNKNOWN_MCAST_BLOCK_MASK_HIr_SET
#define UNKNOWN_MCAST_BLOCK_MASK_HIr_GET BCM56218_A0_UNKNOWN_MCAST_BLOCK_MASK_HIr_GET
#define UNKNOWN_MCAST_BLOCK_MASK_HIr_BLK_BITMAPf_GET BCM56218_A0_UNKNOWN_MCAST_BLOCK_MASK_HIr_BLK_BITMAPf_GET
#define UNKNOWN_MCAST_BLOCK_MASK_HIr_BLK_BITMAPf_SET BCM56218_A0_UNKNOWN_MCAST_BLOCK_MASK_HIr_BLK_BITMAPf_SET
#define READ_UNKNOWN_MCAST_BLOCK_MASK_HIr BCM56218_A0_READ_UNKNOWN_MCAST_BLOCK_MASK_HIr
#define WRITE_UNKNOWN_MCAST_BLOCK_MASK_HIr BCM56218_A0_WRITE_UNKNOWN_MCAST_BLOCK_MASK_HIr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_UNKNOWN_MCAST_BLOCK_MASK_HIr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  UNKNOWN_UCAST_BLOCK_MASK
 * BLOCKS:   IPIPE
 * DESC:     Unknown Unicast Block Mask - Lower Bitmap
 * SIZE:     32
 * FIELDS:
 *     BLK_BITMAP       Bitmap of ports to be blocked
 *
 ******************************************************************************/
#define BCM56218_A0_UNKNOWN_UCAST_BLOCK_MASKr 0x0e700100

#define BCM56218_A0_UNKNOWN_UCAST_BLOCK_MASKr_SIZE 4

/*
 * This structure should be used to declare and program UNKNOWN_UCAST_BLOCK_MASK.
 *
 */
typedef union BCM56218_A0_UNKNOWN_UCAST_BLOCK_MASKr_s {
	uint32_t v[1];
	uint32_t unknown_ucast_block_mask[1];
	uint32_t _unknown_ucast_block_mask;
} BCM56218_A0_UNKNOWN_UCAST_BLOCK_MASKr_t;

#define BCM56218_A0_UNKNOWN_UCAST_BLOCK_MASKr_CLR(r) (r).unknown_ucast_block_mask[0] = 0
#define BCM56218_A0_UNKNOWN_UCAST_BLOCK_MASKr_SET(r,d) (r).unknown_ucast_block_mask[0] = d
#define BCM56218_A0_UNKNOWN_UCAST_BLOCK_MASKr_GET(r) (r).unknown_ucast_block_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_UNKNOWN_UCAST_BLOCK_MASKr_BLK_BITMAPf_GET(r) ((r).unknown_ucast_block_mask[0])
#define BCM56218_A0_UNKNOWN_UCAST_BLOCK_MASKr_BLK_BITMAPf_SET(r,f) (r).unknown_ucast_block_mask[0]=((uint32_t)f)

/*
 * These macros can be used to access UNKNOWN_UCAST_BLOCK_MASK.
 *
 */
#define BCM56218_A0_READ_UNKNOWN_UCAST_BLOCK_MASKr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_UNKNOWN_UCAST_BLOCK_MASKr,(r._unknown_ucast_block_mask))
#define BCM56218_A0_WRITE_UNKNOWN_UCAST_BLOCK_MASKr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_UNKNOWN_UCAST_BLOCK_MASKr,&(r._unknown_ucast_block_mask))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define UNKNOWN_UCAST_BLOCK_MASKr BCM56218_A0_UNKNOWN_UCAST_BLOCK_MASKr
#define UNKNOWN_UCAST_BLOCK_MASKr_SIZE BCM56218_A0_UNKNOWN_UCAST_BLOCK_MASKr_SIZE
typedef BCM56218_A0_UNKNOWN_UCAST_BLOCK_MASKr_t UNKNOWN_UCAST_BLOCK_MASKr_t;
#define UNKNOWN_UCAST_BLOCK_MASKr_CLR BCM56218_A0_UNKNOWN_UCAST_BLOCK_MASKr_CLR
#define UNKNOWN_UCAST_BLOCK_MASKr_SET BCM56218_A0_UNKNOWN_UCAST_BLOCK_MASKr_SET
#define UNKNOWN_UCAST_BLOCK_MASKr_GET BCM56218_A0_UNKNOWN_UCAST_BLOCK_MASKr_GET
#define UNKNOWN_UCAST_BLOCK_MASKr_BLK_BITMAPf_GET BCM56218_A0_UNKNOWN_UCAST_BLOCK_MASKr_BLK_BITMAPf_GET
#define UNKNOWN_UCAST_BLOCK_MASKr_BLK_BITMAPf_SET BCM56218_A0_UNKNOWN_UCAST_BLOCK_MASKr_BLK_BITMAPf_SET
#define READ_UNKNOWN_UCAST_BLOCK_MASKr BCM56218_A0_READ_UNKNOWN_UCAST_BLOCK_MASKr
#define WRITE_UNKNOWN_UCAST_BLOCK_MASKr BCM56218_A0_WRITE_UNKNOWN_UCAST_BLOCK_MASKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_UNKNOWN_UCAST_BLOCK_MASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  UNKNOWN_UCAST_BLOCK_MASK_HI
 * BLOCKS:   IPIPE
 * DESC:     Unknown Unicast Block Mask - Upper Bitmap
 * SIZE:     32
 * FIELDS:
 *     BLK_BITMAP       Bitmap of ports to be blocked
 *
 ******************************************************************************/
#define BCM56218_A0_UNKNOWN_UCAST_BLOCK_MASK_HIr 0x0e700101

#define BCM56218_A0_UNKNOWN_UCAST_BLOCK_MASK_HIr_SIZE 4

/*
 * This structure should be used to declare and program UNKNOWN_UCAST_BLOCK_MASK_HI.
 *
 */
typedef union BCM56218_A0_UNKNOWN_UCAST_BLOCK_MASK_HIr_s {
	uint32_t v[1];
	uint32_t unknown_ucast_block_mask_hi[1];
	uint32_t _unknown_ucast_block_mask_hi;
} BCM56218_A0_UNKNOWN_UCAST_BLOCK_MASK_HIr_t;

#define BCM56218_A0_UNKNOWN_UCAST_BLOCK_MASK_HIr_CLR(r) (r).unknown_ucast_block_mask_hi[0] = 0
#define BCM56218_A0_UNKNOWN_UCAST_BLOCK_MASK_HIr_SET(r,d) (r).unknown_ucast_block_mask_hi[0] = d
#define BCM56218_A0_UNKNOWN_UCAST_BLOCK_MASK_HIr_GET(r) (r).unknown_ucast_block_mask_hi[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_UNKNOWN_UCAST_BLOCK_MASK_HIr_BLK_BITMAPf_GET(r) (((r).unknown_ucast_block_mask_hi[0]) & 0x3fffff)
#define BCM56218_A0_UNKNOWN_UCAST_BLOCK_MASK_HIr_BLK_BITMAPf_SET(r,f) (r).unknown_ucast_block_mask_hi[0]=(((r).unknown_ucast_block_mask_hi[0] & ~((uint32_t)0x3fffff)) | (((uint32_t)f) & 0x3fffff))

/*
 * These macros can be used to access UNKNOWN_UCAST_BLOCK_MASK_HI.
 *
 */
#define BCM56218_A0_READ_UNKNOWN_UCAST_BLOCK_MASK_HIr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_UNKNOWN_UCAST_BLOCK_MASK_HIr,(r._unknown_ucast_block_mask_hi))
#define BCM56218_A0_WRITE_UNKNOWN_UCAST_BLOCK_MASK_HIr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_UNKNOWN_UCAST_BLOCK_MASK_HIr,&(r._unknown_ucast_block_mask_hi))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define UNKNOWN_UCAST_BLOCK_MASK_HIr BCM56218_A0_UNKNOWN_UCAST_BLOCK_MASK_HIr
#define UNKNOWN_UCAST_BLOCK_MASK_HIr_SIZE BCM56218_A0_UNKNOWN_UCAST_BLOCK_MASK_HIr_SIZE
typedef BCM56218_A0_UNKNOWN_UCAST_BLOCK_MASK_HIr_t UNKNOWN_UCAST_BLOCK_MASK_HIr_t;
#define UNKNOWN_UCAST_BLOCK_MASK_HIr_CLR BCM56218_A0_UNKNOWN_UCAST_BLOCK_MASK_HIr_CLR
#define UNKNOWN_UCAST_BLOCK_MASK_HIr_SET BCM56218_A0_UNKNOWN_UCAST_BLOCK_MASK_HIr_SET
#define UNKNOWN_UCAST_BLOCK_MASK_HIr_GET BCM56218_A0_UNKNOWN_UCAST_BLOCK_MASK_HIr_GET
#define UNKNOWN_UCAST_BLOCK_MASK_HIr_BLK_BITMAPf_GET BCM56218_A0_UNKNOWN_UCAST_BLOCK_MASK_HIr_BLK_BITMAPf_GET
#define UNKNOWN_UCAST_BLOCK_MASK_HIr_BLK_BITMAPf_SET BCM56218_A0_UNKNOWN_UCAST_BLOCK_MASK_HIr_BLK_BITMAPf_SET
#define READ_UNKNOWN_UCAST_BLOCK_MASK_HIr BCM56218_A0_READ_UNKNOWN_UCAST_BLOCK_MASK_HIr
#define WRITE_UNKNOWN_UCAST_BLOCK_MASK_HIr BCM56218_A0_WRITE_UNKNOWN_UCAST_BLOCK_MASK_HIr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_UNKNOWN_UCAST_BLOCK_MASK_HIr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  VLAN_CTRL
 * BLOCKS:   IPIPE
 * DESC:     VLAN Control Register #1
 * SIZE:     32
 * FIELDS:
 *     LEARN_VID        LEARN_VID for ARL learning
 *     USE_LEARN_VID    USE LEARN_VID field from this register for ARL learning
 *     INNER_TPID       TPID for inner VLAN, used for double tagging modes only
 *
 ******************************************************************************/
#define BCM56218_A0_VLAN_CTRLr 0x01780003

#define BCM56218_A0_VLAN_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program VLAN_CTRL.
 *
 */
typedef union BCM56218_A0_VLAN_CTRLr_s {
	uint32_t v[1];
	uint32_t vlan_ctrl[1];
	uint32_t _vlan_ctrl;
} BCM56218_A0_VLAN_CTRLr_t;

#define BCM56218_A0_VLAN_CTRLr_CLR(r) (r).vlan_ctrl[0] = 0
#define BCM56218_A0_VLAN_CTRLr_SET(r,d) (r).vlan_ctrl[0] = d
#define BCM56218_A0_VLAN_CTRLr_GET(r) (r).vlan_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_VLAN_CTRLr_LEARN_VIDf_GET(r) (((r).vlan_ctrl[0]) & 0xfff)
#define BCM56218_A0_VLAN_CTRLr_LEARN_VIDf_SET(r,f) (r).vlan_ctrl[0]=(((r).vlan_ctrl[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM56218_A0_VLAN_CTRLr_USE_LEARN_VIDf_GET(r) ((((r).vlan_ctrl[0]) >> 12) & 0x1)
#define BCM56218_A0_VLAN_CTRLr_USE_LEARN_VIDf_SET(r,f) (r).vlan_ctrl[0]=(((r).vlan_ctrl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM56218_A0_VLAN_CTRLr_INNER_TPIDf_GET(r) ((((r).vlan_ctrl[0]) >> 13) & 0xffff)
#define BCM56218_A0_VLAN_CTRLr_INNER_TPIDf_SET(r,f) (r).vlan_ctrl[0]=(((r).vlan_ctrl[0] & ~((uint32_t)0xffff << 13)) | ((((uint32_t)f) & 0xffff) << 13))

/*
 * These macros can be used to access VLAN_CTRL.
 *
 */
#define BCM56218_A0_READ_VLAN_CTRLr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_VLAN_CTRLr,(r._vlan_ctrl))
#define BCM56218_A0_WRITE_VLAN_CTRLr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_VLAN_CTRLr,&(r._vlan_ctrl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_CTRLr BCM56218_A0_VLAN_CTRLr
#define VLAN_CTRLr_SIZE BCM56218_A0_VLAN_CTRLr_SIZE
typedef BCM56218_A0_VLAN_CTRLr_t VLAN_CTRLr_t;
#define VLAN_CTRLr_CLR BCM56218_A0_VLAN_CTRLr_CLR
#define VLAN_CTRLr_SET BCM56218_A0_VLAN_CTRLr_SET
#define VLAN_CTRLr_GET BCM56218_A0_VLAN_CTRLr_GET
#define VLAN_CTRLr_LEARN_VIDf_GET BCM56218_A0_VLAN_CTRLr_LEARN_VIDf_GET
#define VLAN_CTRLr_LEARN_VIDf_SET BCM56218_A0_VLAN_CTRLr_LEARN_VIDf_SET
#define VLAN_CTRLr_USE_LEARN_VIDf_GET BCM56218_A0_VLAN_CTRLr_USE_LEARN_VIDf_GET
#define VLAN_CTRLr_USE_LEARN_VIDf_SET BCM56218_A0_VLAN_CTRLr_USE_LEARN_VIDf_SET
#define VLAN_CTRLr_INNER_TPIDf_GET BCM56218_A0_VLAN_CTRLr_INNER_TPIDf_GET
#define VLAN_CTRLr_INNER_TPIDf_SET BCM56218_A0_VLAN_CTRLr_INNER_TPIDf_SET
#define READ_VLAN_CTRLr BCM56218_A0_READ_VLAN_CTRLr
#define WRITE_VLAN_CTRLr BCM56218_A0_WRITE_VLAN_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_VLAN_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  VLAN_MAC
 * BLOCKS:   IPIPE
 * DESC:     Holds key & data for MAC-based VLAN substitution
 * SIZE:     64
 * FIELDS:
 *     MAC_ADDR         MAC address key
 *     VLAN_ID          VLAN ID
 *     PRI              Priority
 *     VALID            VLAN ID
 *
 ******************************************************************************/
#define BCM56218_A0_VLAN_MACm 0x04750000

#define BCM56218_A0_VLAN_MACm_MIN 0
#define BCM56218_A0_VLAN_MACm_MAX 511
#define BCM56218_A0_VLAN_MACm_CMAX(u) 511
#define BCM56218_A0_VLAN_MACm_SIZE 8

/*
 * This structure should be used to declare and program VLAN_MAC.
 *
 */
typedef union BCM56218_A0_VLAN_MACm_s {
	uint32_t v[2];
	uint32_t vlan_mac[2];
	uint32_t _vlan_mac;
} BCM56218_A0_VLAN_MACm_t;

#define BCM56218_A0_VLAN_MACm_CLR(r) CDK_MEMSET(&((r)._vlan_mac), 0, sizeof(BCM56218_A0_VLAN_MACm_t))
#define BCM56218_A0_VLAN_MACm_SET(r,i,d) (r).vlan_mac[i] = d
#define BCM56218_A0_VLAN_MACm_GET(r,i) (r).vlan_mac[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_VLAN_MACm_MAC_ADDRf_GET(r,a) cdk_field_get((r).vlan_mac,0,47,a)
#define BCM56218_A0_VLAN_MACm_MAC_ADDRf_SET(r,a) cdk_field_set((r).vlan_mac,0,47,a)
#define BCM56218_A0_VLAN_MACm_VLAN_IDf_GET(r) ((((r).vlan_mac[1]) >> 16) & 0xfff)
#define BCM56218_A0_VLAN_MACm_VLAN_IDf_SET(r,f) (r).vlan_mac[1]=(((r).vlan_mac[1] & ~((uint32_t)0xfff << 16)) | ((((uint32_t)f) & 0xfff) << 16))
#define BCM56218_A0_VLAN_MACm_PRIf_GET(r) ((((r).vlan_mac[1]) >> 28) & 0x7)
#define BCM56218_A0_VLAN_MACm_PRIf_SET(r,f) (r).vlan_mac[1]=(((r).vlan_mac[1] & ~((uint32_t)0x7 << 28)) | ((((uint32_t)f) & 0x7) << 28))
#define BCM56218_A0_VLAN_MACm_VALIDf_GET(r) ((((r).vlan_mac[1]) >> 31) & 0x1)
#define BCM56218_A0_VLAN_MACm_VALIDf_SET(r,f) (r).vlan_mac[1]=(((r).vlan_mac[1] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access VLAN_MAC.
 *
 */
#define BCM56218_A0_READ_VLAN_MACm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_VLAN_MACm,i,(m._vlan_mac),2)
#define BCM56218_A0_WRITE_VLAN_MACm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_VLAN_MACm,i,&(m._vlan_mac),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_MACm BCM56218_A0_VLAN_MACm
#define VLAN_MACm_MIN BCM56218_A0_VLAN_MACm_MIN
#define VLAN_MACm_MAX BCM56218_A0_VLAN_MACm_MAX
#define VLAN_MACm_CMAX(u) BCM56218_A0_VLAN_MACm_CMAX(u)
#define VLAN_MACm_SIZE BCM56218_A0_VLAN_MACm_SIZE
typedef BCM56218_A0_VLAN_MACm_t VLAN_MACm_t;
#define VLAN_MACm_CLR BCM56218_A0_VLAN_MACm_CLR
#define VLAN_MACm_SET BCM56218_A0_VLAN_MACm_SET
#define VLAN_MACm_GET BCM56218_A0_VLAN_MACm_GET
#define VLAN_MACm_MAC_ADDRf_GET BCM56218_A0_VLAN_MACm_MAC_ADDRf_GET
#define VLAN_MACm_MAC_ADDRf_SET BCM56218_A0_VLAN_MACm_MAC_ADDRf_SET
#define VLAN_MACm_VLAN_IDf_GET BCM56218_A0_VLAN_MACm_VLAN_IDf_GET
#define VLAN_MACm_VLAN_IDf_SET BCM56218_A0_VLAN_MACm_VLAN_IDf_SET
#define VLAN_MACm_PRIf_GET BCM56218_A0_VLAN_MACm_PRIf_GET
#define VLAN_MACm_PRIf_SET BCM56218_A0_VLAN_MACm_PRIf_SET
#define VLAN_MACm_VALIDf_GET BCM56218_A0_VLAN_MACm_VALIDf_GET
#define VLAN_MACm_VALIDf_SET BCM56218_A0_VLAN_MACm_VALIDf_SET
#define READ_VLAN_MACm BCM56218_A0_READ_VLAN_MACm
#define WRITE_VLAN_MACm BCM56218_A0_WRITE_VLAN_MACm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_VLAN_MACm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  VLAN_PROTOCOL
 * BLOCKS:   IPIPE
 * DESC:     Holds data for Protocol-based VLAN substitution.  Just the VLAN_PROTOCOL RAM.
 * SIZE:     21
 * FIELDS:
 *     ETHERTYPE        Ethertype field
 *     LLC              LLC type pkt
 *     SNAP             SNAP type pkt
 *     ETHERII          Ethernet 2 type pkt
 *     MATCHLOWER       Match lower
 *     MATCHUPPER       Match upper
 *
 ******************************************************************************/
#define BCM56218_A0_VLAN_PROTOCOLm 0x04700000

#define BCM56218_A0_VLAN_PROTOCOLm_MIN 0
#define BCM56218_A0_VLAN_PROTOCOLm_MAX 15
#define BCM56218_A0_VLAN_PROTOCOLm_CMAX(u) 15
#define BCM56218_A0_VLAN_PROTOCOLm_SIZE 3

/*
 * This structure should be used to declare and program VLAN_PROTOCOL.
 *
 */
typedef union BCM56218_A0_VLAN_PROTOCOLm_s {
	uint32_t v[1];
	uint32_t vlan_protocol[1];
	uint32_t _vlan_protocol;
} BCM56218_A0_VLAN_PROTOCOLm_t;

#define BCM56218_A0_VLAN_PROTOCOLm_CLR(r) (r).vlan_protocol[0] = 0
#define BCM56218_A0_VLAN_PROTOCOLm_SET(r,d) (r).vlan_protocol[0] = d
#define BCM56218_A0_VLAN_PROTOCOLm_GET(r) (r).vlan_protocol[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_VLAN_PROTOCOLm_ETHERTYPEf_GET(r) (((r).vlan_protocol[0]) & 0xffff)
#define BCM56218_A0_VLAN_PROTOCOLm_ETHERTYPEf_SET(r,f) (r).vlan_protocol[0]=(((r).vlan_protocol[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56218_A0_VLAN_PROTOCOLm_LLCf_GET(r) ((((r).vlan_protocol[0]) >> 16) & 0x1)
#define BCM56218_A0_VLAN_PROTOCOLm_LLCf_SET(r,f) (r).vlan_protocol[0]=(((r).vlan_protocol[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56218_A0_VLAN_PROTOCOLm_SNAPf_GET(r) ((((r).vlan_protocol[0]) >> 17) & 0x1)
#define BCM56218_A0_VLAN_PROTOCOLm_SNAPf_SET(r,f) (r).vlan_protocol[0]=(((r).vlan_protocol[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56218_A0_VLAN_PROTOCOLm_ETHERIIf_GET(r) ((((r).vlan_protocol[0]) >> 18) & 0x1)
#define BCM56218_A0_VLAN_PROTOCOLm_ETHERIIf_SET(r,f) (r).vlan_protocol[0]=(((r).vlan_protocol[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56218_A0_VLAN_PROTOCOLm_MATCHLOWERf_GET(r) ((((r).vlan_protocol[0]) >> 19) & 0x1)
#define BCM56218_A0_VLAN_PROTOCOLm_MATCHLOWERf_SET(r,f) (r).vlan_protocol[0]=(((r).vlan_protocol[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56218_A0_VLAN_PROTOCOLm_MATCHUPPERf_GET(r) ((((r).vlan_protocol[0]) >> 20) & 0x1)
#define BCM56218_A0_VLAN_PROTOCOLm_MATCHUPPERf_SET(r,f) (r).vlan_protocol[0]=(((r).vlan_protocol[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))

/*
 * These macros can be used to access VLAN_PROTOCOL.
 *
 */
#define BCM56218_A0_READ_VLAN_PROTOCOLm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_VLAN_PROTOCOLm,i,(m._vlan_protocol),1)
#define BCM56218_A0_WRITE_VLAN_PROTOCOLm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_VLAN_PROTOCOLm,i,&(m._vlan_protocol),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_PROTOCOLm BCM56218_A0_VLAN_PROTOCOLm
#define VLAN_PROTOCOLm_MIN BCM56218_A0_VLAN_PROTOCOLm_MIN
#define VLAN_PROTOCOLm_MAX BCM56218_A0_VLAN_PROTOCOLm_MAX
#define VLAN_PROTOCOLm_CMAX(u) BCM56218_A0_VLAN_PROTOCOLm_CMAX(u)
#define VLAN_PROTOCOLm_SIZE BCM56218_A0_VLAN_PROTOCOLm_SIZE
typedef BCM56218_A0_VLAN_PROTOCOLm_t VLAN_PROTOCOLm_t;
#define VLAN_PROTOCOLm_CLR BCM56218_A0_VLAN_PROTOCOLm_CLR
#define VLAN_PROTOCOLm_SET BCM56218_A0_VLAN_PROTOCOLm_SET
#define VLAN_PROTOCOLm_GET BCM56218_A0_VLAN_PROTOCOLm_GET
#define VLAN_PROTOCOLm_ETHERTYPEf_GET BCM56218_A0_VLAN_PROTOCOLm_ETHERTYPEf_GET
#define VLAN_PROTOCOLm_ETHERTYPEf_SET BCM56218_A0_VLAN_PROTOCOLm_ETHERTYPEf_SET
#define VLAN_PROTOCOLm_LLCf_GET BCM56218_A0_VLAN_PROTOCOLm_LLCf_GET
#define VLAN_PROTOCOLm_LLCf_SET BCM56218_A0_VLAN_PROTOCOLm_LLCf_SET
#define VLAN_PROTOCOLm_SNAPf_GET BCM56218_A0_VLAN_PROTOCOLm_SNAPf_GET
#define VLAN_PROTOCOLm_SNAPf_SET BCM56218_A0_VLAN_PROTOCOLm_SNAPf_SET
#define VLAN_PROTOCOLm_ETHERIIf_GET BCM56218_A0_VLAN_PROTOCOLm_ETHERIIf_GET
#define VLAN_PROTOCOLm_ETHERIIf_SET BCM56218_A0_VLAN_PROTOCOLm_ETHERIIf_SET
#define VLAN_PROTOCOLm_MATCHLOWERf_GET BCM56218_A0_VLAN_PROTOCOLm_MATCHLOWERf_GET
#define VLAN_PROTOCOLm_MATCHLOWERf_SET BCM56218_A0_VLAN_PROTOCOLm_MATCHLOWERf_SET
#define VLAN_PROTOCOLm_MATCHUPPERf_GET BCM56218_A0_VLAN_PROTOCOLm_MATCHUPPERf_GET
#define VLAN_PROTOCOLm_MATCHUPPERf_SET BCM56218_A0_VLAN_PROTOCOLm_MATCHUPPERf_SET
#define READ_VLAN_PROTOCOLm BCM56218_A0_READ_VLAN_PROTOCOLm
#define WRITE_VLAN_PROTOCOLm BCM56218_A0_WRITE_VLAN_PROTOCOLm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_VLAN_PROTOCOLm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  VLAN_PROTOCOL_DATA
 * BLOCKS:   IPIPE
 * DESC:     Holds data for Protocol-based VLAN substitution
 * SIZE:     15
 * FIELDS:
 *     PRI              Priority field
 *     VLAN_ID          VLAN ID
 *
 ******************************************************************************/
#define BCM56218_A0_VLAN_PROTOCOL_DATAm 0x04710000

#define BCM56218_A0_VLAN_PROTOCOL_DATAm_MIN 0
#define BCM56218_A0_VLAN_PROTOCOL_DATAm_MAX 863
#define BCM56218_A0_VLAN_PROTOCOL_DATAm_CMAX(u) 863
#define BCM56218_A0_VLAN_PROTOCOL_DATAm_SIZE 2

/*
 * This structure should be used to declare and program VLAN_PROTOCOL_DATA.
 *
 */
typedef union BCM56218_A0_VLAN_PROTOCOL_DATAm_s {
	uint32_t v[1];
	uint32_t vlan_protocol_data[1];
	uint32_t _vlan_protocol_data;
} BCM56218_A0_VLAN_PROTOCOL_DATAm_t;

#define BCM56218_A0_VLAN_PROTOCOL_DATAm_CLR(r) (r).vlan_protocol_data[0] = 0
#define BCM56218_A0_VLAN_PROTOCOL_DATAm_SET(r,d) (r).vlan_protocol_data[0] = d
#define BCM56218_A0_VLAN_PROTOCOL_DATAm_GET(r) (r).vlan_protocol_data[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_VLAN_PROTOCOL_DATAm_PRIf_GET(r) (((r).vlan_protocol_data[0]) & 0x7)
#define BCM56218_A0_VLAN_PROTOCOL_DATAm_PRIf_SET(r,f) (r).vlan_protocol_data[0]=(((r).vlan_protocol_data[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM56218_A0_VLAN_PROTOCOL_DATAm_VLAN_IDf_GET(r) ((((r).vlan_protocol_data[0]) >> 3) & 0xfff)
#define BCM56218_A0_VLAN_PROTOCOL_DATAm_VLAN_IDf_SET(r,f) (r).vlan_protocol_data[0]=(((r).vlan_protocol_data[0] & ~((uint32_t)0xfff << 3)) | ((((uint32_t)f) & 0xfff) << 3))

/*
 * These macros can be used to access VLAN_PROTOCOL_DATA.
 *
 */
#define BCM56218_A0_READ_VLAN_PROTOCOL_DATAm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_VLAN_PROTOCOL_DATAm,i,(m._vlan_protocol_data),1)
#define BCM56218_A0_WRITE_VLAN_PROTOCOL_DATAm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_VLAN_PROTOCOL_DATAm,i,&(m._vlan_protocol_data),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_PROTOCOL_DATAm BCM56218_A0_VLAN_PROTOCOL_DATAm
#define VLAN_PROTOCOL_DATAm_MIN BCM56218_A0_VLAN_PROTOCOL_DATAm_MIN
#define VLAN_PROTOCOL_DATAm_MAX BCM56218_A0_VLAN_PROTOCOL_DATAm_MAX
#define VLAN_PROTOCOL_DATAm_CMAX(u) BCM56218_A0_VLAN_PROTOCOL_DATAm_CMAX(u)
#define VLAN_PROTOCOL_DATAm_SIZE BCM56218_A0_VLAN_PROTOCOL_DATAm_SIZE
typedef BCM56218_A0_VLAN_PROTOCOL_DATAm_t VLAN_PROTOCOL_DATAm_t;
#define VLAN_PROTOCOL_DATAm_CLR BCM56218_A0_VLAN_PROTOCOL_DATAm_CLR
#define VLAN_PROTOCOL_DATAm_SET BCM56218_A0_VLAN_PROTOCOL_DATAm_SET
#define VLAN_PROTOCOL_DATAm_GET BCM56218_A0_VLAN_PROTOCOL_DATAm_GET
#define VLAN_PROTOCOL_DATAm_PRIf_GET BCM56218_A0_VLAN_PROTOCOL_DATAm_PRIf_GET
#define VLAN_PROTOCOL_DATAm_PRIf_SET BCM56218_A0_VLAN_PROTOCOL_DATAm_PRIf_SET
#define VLAN_PROTOCOL_DATAm_VLAN_IDf_GET BCM56218_A0_VLAN_PROTOCOL_DATAm_VLAN_IDf_GET
#define VLAN_PROTOCOL_DATAm_VLAN_IDf_SET BCM56218_A0_VLAN_PROTOCOL_DATAm_VLAN_IDf_SET
#define READ_VLAN_PROTOCOL_DATAm BCM56218_A0_READ_VLAN_PROTOCOL_DATAm
#define WRITE_VLAN_PROTOCOL_DATAm BCM56218_A0_WRITE_VLAN_PROTOCOL_DATAm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_VLAN_PROTOCOL_DATAm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  VLAN_SUBNET
 * BLOCKS:   IPIPE
 * DESC:     TCAM for IP subnet based VLAN substitution
 * SIZE:     144
 * FIELDS:
 *     VALID            IP Subnet mask
 *     IP_ADDR          IP Address key
 *     MASK             IP Subnet mask
 *     PRI              Priority field
 *     VLAN_ID          VLAN ID
 *
 ******************************************************************************/
#define BCM56218_A0_VLAN_SUBNETm 0x04720000

#define BCM56218_A0_VLAN_SUBNETm_MIN 0
#define BCM56218_A0_VLAN_SUBNETm_MAX 255
#define BCM56218_A0_VLAN_SUBNETm_CMAX(u) 255
#define BCM56218_A0_VLAN_SUBNETm_SIZE 18

/*
 * This structure should be used to declare and program VLAN_SUBNET.
 *
 */
typedef union BCM56218_A0_VLAN_SUBNETm_s {
	uint32_t v[5];
	uint32_t vlan_subnet[5];
	uint32_t _vlan_subnet;
} BCM56218_A0_VLAN_SUBNETm_t;

#define BCM56218_A0_VLAN_SUBNETm_CLR(r) CDK_MEMSET(&((r)._vlan_subnet), 0, sizeof(BCM56218_A0_VLAN_SUBNETm_t))
#define BCM56218_A0_VLAN_SUBNETm_SET(r,i,d) (r).vlan_subnet[i] = d
#define BCM56218_A0_VLAN_SUBNETm_GET(r,i) (r).vlan_subnet[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_VLAN_SUBNETm_VALIDf_GET(r) (((r).vlan_subnet[0]) & 0x1)
#define BCM56218_A0_VLAN_SUBNETm_VALIDf_SET(r,f) (r).vlan_subnet[0]=(((r).vlan_subnet[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_VLAN_SUBNETm_IP_ADDRf_GET(r,a) cdk_field_get((r).vlan_subnet,1,64,a)
#define BCM56218_A0_VLAN_SUBNETm_IP_ADDRf_SET(r,a) cdk_field_set((r).vlan_subnet,1,64,a)
#define BCM56218_A0_VLAN_SUBNETm_MASKf_GET(r,a) cdk_field_get((r).vlan_subnet,65,128,a)
#define BCM56218_A0_VLAN_SUBNETm_MASKf_SET(r,a) cdk_field_set((r).vlan_subnet,65,128,a)
#define BCM56218_A0_VLAN_SUBNETm_PRIf_GET(r) ((((r).vlan_subnet[4]) >> 1) & 0x7)
#define BCM56218_A0_VLAN_SUBNETm_PRIf_SET(r,f) (r).vlan_subnet[4]=(((r).vlan_subnet[4] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define BCM56218_A0_VLAN_SUBNETm_VLAN_IDf_GET(r) ((((r).vlan_subnet[4]) >> 4) & 0xfff)
#define BCM56218_A0_VLAN_SUBNETm_VLAN_IDf_SET(r,f) (r).vlan_subnet[4]=(((r).vlan_subnet[4] & ~((uint32_t)0xfff << 4)) | ((((uint32_t)f) & 0xfff) << 4))

/*
 * These macros can be used to access VLAN_SUBNET.
 *
 */
#define BCM56218_A0_READ_VLAN_SUBNETm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_VLAN_SUBNETm,i,(m._vlan_subnet),5)
#define BCM56218_A0_WRITE_VLAN_SUBNETm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_VLAN_SUBNETm,i,&(m._vlan_subnet),5)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_SUBNETm BCM56218_A0_VLAN_SUBNETm
#define VLAN_SUBNETm_MIN BCM56218_A0_VLAN_SUBNETm_MIN
#define VLAN_SUBNETm_MAX BCM56218_A0_VLAN_SUBNETm_MAX
#define VLAN_SUBNETm_CMAX(u) BCM56218_A0_VLAN_SUBNETm_CMAX(u)
#define VLAN_SUBNETm_SIZE BCM56218_A0_VLAN_SUBNETm_SIZE
typedef BCM56218_A0_VLAN_SUBNETm_t VLAN_SUBNETm_t;
#define VLAN_SUBNETm_CLR BCM56218_A0_VLAN_SUBNETm_CLR
#define VLAN_SUBNETm_SET BCM56218_A0_VLAN_SUBNETm_SET
#define VLAN_SUBNETm_GET BCM56218_A0_VLAN_SUBNETm_GET
#define VLAN_SUBNETm_VALIDf_GET BCM56218_A0_VLAN_SUBNETm_VALIDf_GET
#define VLAN_SUBNETm_VALIDf_SET BCM56218_A0_VLAN_SUBNETm_VALIDf_SET
#define VLAN_SUBNETm_IP_ADDRf_GET BCM56218_A0_VLAN_SUBNETm_IP_ADDRf_GET
#define VLAN_SUBNETm_IP_ADDRf_SET BCM56218_A0_VLAN_SUBNETm_IP_ADDRf_SET
#define VLAN_SUBNETm_MASKf_GET BCM56218_A0_VLAN_SUBNETm_MASKf_GET
#define VLAN_SUBNETm_MASKf_SET BCM56218_A0_VLAN_SUBNETm_MASKf_SET
#define VLAN_SUBNETm_PRIf_GET BCM56218_A0_VLAN_SUBNETm_PRIf_GET
#define VLAN_SUBNETm_PRIf_SET BCM56218_A0_VLAN_SUBNETm_PRIf_SET
#define VLAN_SUBNETm_VLAN_IDf_GET BCM56218_A0_VLAN_SUBNETm_VLAN_IDf_GET
#define VLAN_SUBNETm_VLAN_IDf_SET BCM56218_A0_VLAN_SUBNETm_VLAN_IDf_SET
#define READ_VLAN_SUBNETm BCM56218_A0_READ_VLAN_SUBNETm
#define WRITE_VLAN_SUBNETm BCM56218_A0_WRITE_VLAN_SUBNETm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_VLAN_SUBNETm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  VLAN_SUBNET_CAM_BIST_S10_STATUS
 * BLOCKS:   IPIPE
 * DESC:     VLAN_SUBNET_CAM_BIST_S10_STATUS
 * SIZE:     32
 * FIELDS:
 *     S10_STATUS       S10_STATUS
 *
 ******************************************************************************/
#define BCM56218_A0_VLAN_SUBNET_CAM_BIST_S10_STATUSr 0x04780007

#define BCM56218_A0_VLAN_SUBNET_CAM_BIST_S10_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program VLAN_SUBNET_CAM_BIST_S10_STATUS.
 *
 */
typedef union BCM56218_A0_VLAN_SUBNET_CAM_BIST_S10_STATUSr_s {
	uint32_t v[1];
	uint32_t vlan_subnet_cam_bist_s10_status[1];
	uint32_t _vlan_subnet_cam_bist_s10_status;
} BCM56218_A0_VLAN_SUBNET_CAM_BIST_S10_STATUSr_t;

#define BCM56218_A0_VLAN_SUBNET_CAM_BIST_S10_STATUSr_CLR(r) (r).vlan_subnet_cam_bist_s10_status[0] = 0
#define BCM56218_A0_VLAN_SUBNET_CAM_BIST_S10_STATUSr_SET(r,d) (r).vlan_subnet_cam_bist_s10_status[0] = d
#define BCM56218_A0_VLAN_SUBNET_CAM_BIST_S10_STATUSr_GET(r) (r).vlan_subnet_cam_bist_s10_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_VLAN_SUBNET_CAM_BIST_S10_STATUSr_S10_STATUSf_GET(r) (((r).vlan_subnet_cam_bist_s10_status[0]) & 0xff)
#define BCM56218_A0_VLAN_SUBNET_CAM_BIST_S10_STATUSr_S10_STATUSf_SET(r,f) (r).vlan_subnet_cam_bist_s10_status[0]=(((r).vlan_subnet_cam_bist_s10_status[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access VLAN_SUBNET_CAM_BIST_S10_STATUS.
 *
 */
#define BCM56218_A0_READ_VLAN_SUBNET_CAM_BIST_S10_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_VLAN_SUBNET_CAM_BIST_S10_STATUSr,(r._vlan_subnet_cam_bist_s10_status))
#define BCM56218_A0_WRITE_VLAN_SUBNET_CAM_BIST_S10_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_VLAN_SUBNET_CAM_BIST_S10_STATUSr,&(r._vlan_subnet_cam_bist_s10_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_SUBNET_CAM_BIST_S10_STATUSr BCM56218_A0_VLAN_SUBNET_CAM_BIST_S10_STATUSr
#define VLAN_SUBNET_CAM_BIST_S10_STATUSr_SIZE BCM56218_A0_VLAN_SUBNET_CAM_BIST_S10_STATUSr_SIZE
typedef BCM56218_A0_VLAN_SUBNET_CAM_BIST_S10_STATUSr_t VLAN_SUBNET_CAM_BIST_S10_STATUSr_t;
#define VLAN_SUBNET_CAM_BIST_S10_STATUSr_CLR BCM56218_A0_VLAN_SUBNET_CAM_BIST_S10_STATUSr_CLR
#define VLAN_SUBNET_CAM_BIST_S10_STATUSr_SET BCM56218_A0_VLAN_SUBNET_CAM_BIST_S10_STATUSr_SET
#define VLAN_SUBNET_CAM_BIST_S10_STATUSr_GET BCM56218_A0_VLAN_SUBNET_CAM_BIST_S10_STATUSr_GET
#define VLAN_SUBNET_CAM_BIST_S10_STATUSr_S10_STATUSf_GET BCM56218_A0_VLAN_SUBNET_CAM_BIST_S10_STATUSr_S10_STATUSf_GET
#define VLAN_SUBNET_CAM_BIST_S10_STATUSr_S10_STATUSf_SET BCM56218_A0_VLAN_SUBNET_CAM_BIST_S10_STATUSr_S10_STATUSf_SET
#define READ_VLAN_SUBNET_CAM_BIST_S10_STATUSr BCM56218_A0_READ_VLAN_SUBNET_CAM_BIST_S10_STATUSr
#define WRITE_VLAN_SUBNET_CAM_BIST_S10_STATUSr BCM56218_A0_WRITE_VLAN_SUBNET_CAM_BIST_S10_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_VLAN_SUBNET_CAM_BIST_S10_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  VLAN_SUBNET_CAM_BIST_S2_STATUS
 * BLOCKS:   IPIPE
 * DESC:     VLAN_SUBNET_CAM_BIST_S2_STATUS
 * SIZE:     32
 * FIELDS:
 *     S2_STATUS        VLAN_SUBNET_CAM_BIST_BIST_S2_STATUS
 *
 ******************************************************************************/
#define BCM56218_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr 0x04780002

#define BCM56218_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program VLAN_SUBNET_CAM_BIST_S2_STATUS.
 *
 */
typedef union BCM56218_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr_s {
	uint32_t v[1];
	uint32_t vlan_subnet_cam_bist_s2_status[1];
	uint32_t _vlan_subnet_cam_bist_s2_status;
} BCM56218_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr_t;

#define BCM56218_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr_CLR(r) (r).vlan_subnet_cam_bist_s2_status[0] = 0
#define BCM56218_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr_SET(r,d) (r).vlan_subnet_cam_bist_s2_status[0] = d
#define BCM56218_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr_GET(r) (r).vlan_subnet_cam_bist_s2_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr_S2_STATUSf_GET(r) (((r).vlan_subnet_cam_bist_s2_status[0]) & 0x7fff)
#define BCM56218_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr_S2_STATUSf_SET(r,f) (r).vlan_subnet_cam_bist_s2_status[0]=(((r).vlan_subnet_cam_bist_s2_status[0] & ~((uint32_t)0x7fff)) | (((uint32_t)f) & 0x7fff))

/*
 * These macros can be used to access VLAN_SUBNET_CAM_BIST_S2_STATUS.
 *
 */
#define BCM56218_A0_READ_VLAN_SUBNET_CAM_BIST_S2_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr,(r._vlan_subnet_cam_bist_s2_status))
#define BCM56218_A0_WRITE_VLAN_SUBNET_CAM_BIST_S2_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr,&(r._vlan_subnet_cam_bist_s2_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_SUBNET_CAM_BIST_S2_STATUSr BCM56218_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr
#define VLAN_SUBNET_CAM_BIST_S2_STATUSr_SIZE BCM56218_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr_SIZE
typedef BCM56218_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr_t VLAN_SUBNET_CAM_BIST_S2_STATUSr_t;
#define VLAN_SUBNET_CAM_BIST_S2_STATUSr_CLR BCM56218_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr_CLR
#define VLAN_SUBNET_CAM_BIST_S2_STATUSr_SET BCM56218_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr_SET
#define VLAN_SUBNET_CAM_BIST_S2_STATUSr_GET BCM56218_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr_GET
#define VLAN_SUBNET_CAM_BIST_S2_STATUSr_S2_STATUSf_GET BCM56218_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr_S2_STATUSf_GET
#define VLAN_SUBNET_CAM_BIST_S2_STATUSr_S2_STATUSf_SET BCM56218_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr_S2_STATUSf_SET
#define READ_VLAN_SUBNET_CAM_BIST_S2_STATUSr BCM56218_A0_READ_VLAN_SUBNET_CAM_BIST_S2_STATUSr
#define WRITE_VLAN_SUBNET_CAM_BIST_S2_STATUSr BCM56218_A0_WRITE_VLAN_SUBNET_CAM_BIST_S2_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  VLAN_SUBNET_CAM_BIST_S3_STATUS
 * BLOCKS:   IPIPE
 * DESC:     VLAN_SUBNET_CAM_BIST_S3_STATUS
 * SIZE:     32
 * FIELDS:
 *     S3_STATUS        S3_STATUS
 *
 ******************************************************************************/
#define BCM56218_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr 0x04780003

#define BCM56218_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program VLAN_SUBNET_CAM_BIST_S3_STATUS.
 *
 */
typedef union BCM56218_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr_s {
	uint32_t v[1];
	uint32_t vlan_subnet_cam_bist_s3_status[1];
	uint32_t _vlan_subnet_cam_bist_s3_status;
} BCM56218_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr_t;

#define BCM56218_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr_CLR(r) (r).vlan_subnet_cam_bist_s3_status[0] = 0
#define BCM56218_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr_SET(r,d) (r).vlan_subnet_cam_bist_s3_status[0] = d
#define BCM56218_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr_GET(r) (r).vlan_subnet_cam_bist_s3_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr_S3_STATUSf_GET(r) (((r).vlan_subnet_cam_bist_s3_status[0]) & 0xffff)
#define BCM56218_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr_S3_STATUSf_SET(r,f) (r).vlan_subnet_cam_bist_s3_status[0]=(((r).vlan_subnet_cam_bist_s3_status[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access VLAN_SUBNET_CAM_BIST_S3_STATUS.
 *
 */
#define BCM56218_A0_READ_VLAN_SUBNET_CAM_BIST_S3_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr,(r._vlan_subnet_cam_bist_s3_status))
#define BCM56218_A0_WRITE_VLAN_SUBNET_CAM_BIST_S3_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr,&(r._vlan_subnet_cam_bist_s3_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_SUBNET_CAM_BIST_S3_STATUSr BCM56218_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr
#define VLAN_SUBNET_CAM_BIST_S3_STATUSr_SIZE BCM56218_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr_SIZE
typedef BCM56218_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr_t VLAN_SUBNET_CAM_BIST_S3_STATUSr_t;
#define VLAN_SUBNET_CAM_BIST_S3_STATUSr_CLR BCM56218_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr_CLR
#define VLAN_SUBNET_CAM_BIST_S3_STATUSr_SET BCM56218_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr_SET
#define VLAN_SUBNET_CAM_BIST_S3_STATUSr_GET BCM56218_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr_GET
#define VLAN_SUBNET_CAM_BIST_S3_STATUSr_S3_STATUSf_GET BCM56218_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr_S3_STATUSf_GET
#define VLAN_SUBNET_CAM_BIST_S3_STATUSr_S3_STATUSf_SET BCM56218_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr_S3_STATUSf_SET
#define READ_VLAN_SUBNET_CAM_BIST_S3_STATUSr BCM56218_A0_READ_VLAN_SUBNET_CAM_BIST_S3_STATUSr
#define WRITE_VLAN_SUBNET_CAM_BIST_S3_STATUSr BCM56218_A0_WRITE_VLAN_SUBNET_CAM_BIST_S3_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  VLAN_SUBNET_CAM_BIST_S5_STATUS
 * BLOCKS:   IPIPE
 * DESC:     VLAN_SUBNET_CAM_BIST_S5_STATUS
 * SIZE:     32
 * FIELDS:
 *     S5_STATUS        S5_STATUS
 *
 ******************************************************************************/
#define BCM56218_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr 0x04780004

#define BCM56218_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program VLAN_SUBNET_CAM_BIST_S5_STATUS.
 *
 */
typedef union BCM56218_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr_s {
	uint32_t v[1];
	uint32_t vlan_subnet_cam_bist_s5_status[1];
	uint32_t _vlan_subnet_cam_bist_s5_status;
} BCM56218_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr_t;

#define BCM56218_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr_CLR(r) (r).vlan_subnet_cam_bist_s5_status[0] = 0
#define BCM56218_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr_SET(r,d) (r).vlan_subnet_cam_bist_s5_status[0] = d
#define BCM56218_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr_GET(r) (r).vlan_subnet_cam_bist_s5_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr_S5_STATUSf_GET(r) (((r).vlan_subnet_cam_bist_s5_status[0]) & 0x7fff)
#define BCM56218_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr_S5_STATUSf_SET(r,f) (r).vlan_subnet_cam_bist_s5_status[0]=(((r).vlan_subnet_cam_bist_s5_status[0] & ~((uint32_t)0x7fff)) | (((uint32_t)f) & 0x7fff))

/*
 * These macros can be used to access VLAN_SUBNET_CAM_BIST_S5_STATUS.
 *
 */
#define BCM56218_A0_READ_VLAN_SUBNET_CAM_BIST_S5_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr,(r._vlan_subnet_cam_bist_s5_status))
#define BCM56218_A0_WRITE_VLAN_SUBNET_CAM_BIST_S5_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr,&(r._vlan_subnet_cam_bist_s5_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_SUBNET_CAM_BIST_S5_STATUSr BCM56218_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr
#define VLAN_SUBNET_CAM_BIST_S5_STATUSr_SIZE BCM56218_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr_SIZE
typedef BCM56218_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr_t VLAN_SUBNET_CAM_BIST_S5_STATUSr_t;
#define VLAN_SUBNET_CAM_BIST_S5_STATUSr_CLR BCM56218_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr_CLR
#define VLAN_SUBNET_CAM_BIST_S5_STATUSr_SET BCM56218_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr_SET
#define VLAN_SUBNET_CAM_BIST_S5_STATUSr_GET BCM56218_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr_GET
#define VLAN_SUBNET_CAM_BIST_S5_STATUSr_S5_STATUSf_GET BCM56218_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr_S5_STATUSf_GET
#define VLAN_SUBNET_CAM_BIST_S5_STATUSr_S5_STATUSf_SET BCM56218_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr_S5_STATUSf_SET
#define READ_VLAN_SUBNET_CAM_BIST_S5_STATUSr BCM56218_A0_READ_VLAN_SUBNET_CAM_BIST_S5_STATUSr
#define WRITE_VLAN_SUBNET_CAM_BIST_S5_STATUSr BCM56218_A0_WRITE_VLAN_SUBNET_CAM_BIST_S5_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  VLAN_SUBNET_CAM_BIST_S6_STATUS
 * BLOCKS:   IPIPE
 * DESC:     VLAN_SUBNET_CAM_BIST_S6_STATUS
 * SIZE:     32
 * FIELDS:
 *     S6_STATUS        S6_STATUS
 *
 ******************************************************************************/
#define BCM56218_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr 0x04780005

#define BCM56218_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program VLAN_SUBNET_CAM_BIST_S6_STATUS.
 *
 */
typedef union BCM56218_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr_s {
	uint32_t v[1];
	uint32_t vlan_subnet_cam_bist_s6_status[1];
	uint32_t _vlan_subnet_cam_bist_s6_status;
} BCM56218_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr_t;

#define BCM56218_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr_CLR(r) (r).vlan_subnet_cam_bist_s6_status[0] = 0
#define BCM56218_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr_SET(r,d) (r).vlan_subnet_cam_bist_s6_status[0] = d
#define BCM56218_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr_GET(r) (r).vlan_subnet_cam_bist_s6_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr_S6_STATUSf_GET(r) (((r).vlan_subnet_cam_bist_s6_status[0]) & 0xffff)
#define BCM56218_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr_S6_STATUSf_SET(r,f) (r).vlan_subnet_cam_bist_s6_status[0]=(((r).vlan_subnet_cam_bist_s6_status[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access VLAN_SUBNET_CAM_BIST_S6_STATUS.
 *
 */
#define BCM56218_A0_READ_VLAN_SUBNET_CAM_BIST_S6_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr,(r._vlan_subnet_cam_bist_s6_status))
#define BCM56218_A0_WRITE_VLAN_SUBNET_CAM_BIST_S6_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr,&(r._vlan_subnet_cam_bist_s6_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_SUBNET_CAM_BIST_S6_STATUSr BCM56218_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr
#define VLAN_SUBNET_CAM_BIST_S6_STATUSr_SIZE BCM56218_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr_SIZE
typedef BCM56218_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr_t VLAN_SUBNET_CAM_BIST_S6_STATUSr_t;
#define VLAN_SUBNET_CAM_BIST_S6_STATUSr_CLR BCM56218_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr_CLR
#define VLAN_SUBNET_CAM_BIST_S6_STATUSr_SET BCM56218_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr_SET
#define VLAN_SUBNET_CAM_BIST_S6_STATUSr_GET BCM56218_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr_GET
#define VLAN_SUBNET_CAM_BIST_S6_STATUSr_S6_STATUSf_GET BCM56218_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr_S6_STATUSf_GET
#define VLAN_SUBNET_CAM_BIST_S6_STATUSr_S6_STATUSf_SET BCM56218_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr_S6_STATUSf_SET
#define READ_VLAN_SUBNET_CAM_BIST_S6_STATUSr BCM56218_A0_READ_VLAN_SUBNET_CAM_BIST_S6_STATUSr
#define WRITE_VLAN_SUBNET_CAM_BIST_S6_STATUSr BCM56218_A0_WRITE_VLAN_SUBNET_CAM_BIST_S6_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  VLAN_SUBNET_CAM_BIST_S8_STATUS
 * BLOCKS:   IPIPE
 * DESC:     VLAN_SUBNET_CAM_BIST_S8_STATUS
 * SIZE:     32
 * FIELDS:
 *     S8_STATUS        S8_STATUS
 *
 ******************************************************************************/
#define BCM56218_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr 0x04780006

#define BCM56218_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program VLAN_SUBNET_CAM_BIST_S8_STATUS.
 *
 */
typedef union BCM56218_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr_s {
	uint32_t v[1];
	uint32_t vlan_subnet_cam_bist_s8_status[1];
	uint32_t _vlan_subnet_cam_bist_s8_status;
} BCM56218_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr_t;

#define BCM56218_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr_CLR(r) (r).vlan_subnet_cam_bist_s8_status[0] = 0
#define BCM56218_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr_SET(r,d) (r).vlan_subnet_cam_bist_s8_status[0] = d
#define BCM56218_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr_GET(r) (r).vlan_subnet_cam_bist_s8_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr_S8_STATUSf_GET(r) (((r).vlan_subnet_cam_bist_s8_status[0]) & 0xffff)
#define BCM56218_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr_S8_STATUSf_SET(r,f) (r).vlan_subnet_cam_bist_s8_status[0]=(((r).vlan_subnet_cam_bist_s8_status[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access VLAN_SUBNET_CAM_BIST_S8_STATUS.
 *
 */
#define BCM56218_A0_READ_VLAN_SUBNET_CAM_BIST_S8_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr,(r._vlan_subnet_cam_bist_s8_status))
#define BCM56218_A0_WRITE_VLAN_SUBNET_CAM_BIST_S8_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr,&(r._vlan_subnet_cam_bist_s8_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_SUBNET_CAM_BIST_S8_STATUSr BCM56218_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr
#define VLAN_SUBNET_CAM_BIST_S8_STATUSr_SIZE BCM56218_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr_SIZE
typedef BCM56218_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr_t VLAN_SUBNET_CAM_BIST_S8_STATUSr_t;
#define VLAN_SUBNET_CAM_BIST_S8_STATUSr_CLR BCM56218_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr_CLR
#define VLAN_SUBNET_CAM_BIST_S8_STATUSr_SET BCM56218_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr_SET
#define VLAN_SUBNET_CAM_BIST_S8_STATUSr_GET BCM56218_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr_GET
#define VLAN_SUBNET_CAM_BIST_S8_STATUSr_S8_STATUSf_GET BCM56218_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr_S8_STATUSf_GET
#define VLAN_SUBNET_CAM_BIST_S8_STATUSr_S8_STATUSf_SET BCM56218_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr_S8_STATUSf_SET
#define READ_VLAN_SUBNET_CAM_BIST_S8_STATUSr BCM56218_A0_READ_VLAN_SUBNET_CAM_BIST_S8_STATUSr
#define WRITE_VLAN_SUBNET_CAM_BIST_S8_STATUSr BCM56218_A0_WRITE_VLAN_SUBNET_CAM_BIST_S8_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  VLAN_SUBNET_CAM_BIST_STATUS
 * BLOCKS:   IPIPE
 * DESC:     VLAN_SUBNET_CAM_BIST_STATUS
 * SIZE:     32
 * FIELDS:
 *     BIST_GO          BIST pass/fail flag (1->pass)
 *     BIST_DONE        Inicates if the BIST has completed
 *
 ******************************************************************************/
#define BCM56218_A0_VLAN_SUBNET_CAM_BIST_STATUSr 0x04780001

#define BCM56218_A0_VLAN_SUBNET_CAM_BIST_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program VLAN_SUBNET_CAM_BIST_STATUS.
 *
 */
typedef union BCM56218_A0_VLAN_SUBNET_CAM_BIST_STATUSr_s {
	uint32_t v[1];
	uint32_t vlan_subnet_cam_bist_status[1];
	uint32_t _vlan_subnet_cam_bist_status;
} BCM56218_A0_VLAN_SUBNET_CAM_BIST_STATUSr_t;

#define BCM56218_A0_VLAN_SUBNET_CAM_BIST_STATUSr_CLR(r) (r).vlan_subnet_cam_bist_status[0] = 0
#define BCM56218_A0_VLAN_SUBNET_CAM_BIST_STATUSr_SET(r,d) (r).vlan_subnet_cam_bist_status[0] = d
#define BCM56218_A0_VLAN_SUBNET_CAM_BIST_STATUSr_GET(r) (r).vlan_subnet_cam_bist_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_VLAN_SUBNET_CAM_BIST_STATUSr_BIST_GOf_GET(r) (((r).vlan_subnet_cam_bist_status[0]) & 0x1)
#define BCM56218_A0_VLAN_SUBNET_CAM_BIST_STATUSr_BIST_GOf_SET(r,f) (r).vlan_subnet_cam_bist_status[0]=(((r).vlan_subnet_cam_bist_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_VLAN_SUBNET_CAM_BIST_STATUSr_BIST_DONEf_GET(r) ((((r).vlan_subnet_cam_bist_status[0]) >> 1) & 0x1)
#define BCM56218_A0_VLAN_SUBNET_CAM_BIST_STATUSr_BIST_DONEf_SET(r,f) (r).vlan_subnet_cam_bist_status[0]=(((r).vlan_subnet_cam_bist_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access VLAN_SUBNET_CAM_BIST_STATUS.
 *
 */
#define BCM56218_A0_READ_VLAN_SUBNET_CAM_BIST_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_VLAN_SUBNET_CAM_BIST_STATUSr,(r._vlan_subnet_cam_bist_status))
#define BCM56218_A0_WRITE_VLAN_SUBNET_CAM_BIST_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_VLAN_SUBNET_CAM_BIST_STATUSr,&(r._vlan_subnet_cam_bist_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_SUBNET_CAM_BIST_STATUSr BCM56218_A0_VLAN_SUBNET_CAM_BIST_STATUSr
#define VLAN_SUBNET_CAM_BIST_STATUSr_SIZE BCM56218_A0_VLAN_SUBNET_CAM_BIST_STATUSr_SIZE
typedef BCM56218_A0_VLAN_SUBNET_CAM_BIST_STATUSr_t VLAN_SUBNET_CAM_BIST_STATUSr_t;
#define VLAN_SUBNET_CAM_BIST_STATUSr_CLR BCM56218_A0_VLAN_SUBNET_CAM_BIST_STATUSr_CLR
#define VLAN_SUBNET_CAM_BIST_STATUSr_SET BCM56218_A0_VLAN_SUBNET_CAM_BIST_STATUSr_SET
#define VLAN_SUBNET_CAM_BIST_STATUSr_GET BCM56218_A0_VLAN_SUBNET_CAM_BIST_STATUSr_GET
#define VLAN_SUBNET_CAM_BIST_STATUSr_BIST_GOf_GET BCM56218_A0_VLAN_SUBNET_CAM_BIST_STATUSr_BIST_GOf_GET
#define VLAN_SUBNET_CAM_BIST_STATUSr_BIST_GOf_SET BCM56218_A0_VLAN_SUBNET_CAM_BIST_STATUSr_BIST_GOf_SET
#define VLAN_SUBNET_CAM_BIST_STATUSr_BIST_DONEf_GET BCM56218_A0_VLAN_SUBNET_CAM_BIST_STATUSr_BIST_DONEf_GET
#define VLAN_SUBNET_CAM_BIST_STATUSr_BIST_DONEf_SET BCM56218_A0_VLAN_SUBNET_CAM_BIST_STATUSr_BIST_DONEf_SET
#define READ_VLAN_SUBNET_CAM_BIST_STATUSr BCM56218_A0_READ_VLAN_SUBNET_CAM_BIST_STATUSr
#define WRITE_VLAN_SUBNET_CAM_BIST_STATUSr BCM56218_A0_WRITE_VLAN_SUBNET_CAM_BIST_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_VLAN_SUBNET_CAM_BIST_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  VLAN_SUBNET_CAM_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     VLAN_SUBNET_CAM_CONTROL
 * SIZE:     32
 * FIELDS:
 *     BIST_EN0         BIST enable for CAM0
 *     BIST_EN1         BIST enable for CAM1
 *     SAM              SAM debug bits
 *
 ******************************************************************************/
#define BCM56218_A0_VLAN_SUBNET_CAM_CONTROLr 0x04780000

#define BCM56218_A0_VLAN_SUBNET_CAM_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program VLAN_SUBNET_CAM_CONTROL.
 *
 */
typedef union BCM56218_A0_VLAN_SUBNET_CAM_CONTROLr_s {
	uint32_t v[1];
	uint32_t vlan_subnet_cam_control[1];
	uint32_t _vlan_subnet_cam_control;
} BCM56218_A0_VLAN_SUBNET_CAM_CONTROLr_t;

#define BCM56218_A0_VLAN_SUBNET_CAM_CONTROLr_CLR(r) (r).vlan_subnet_cam_control[0] = 0
#define BCM56218_A0_VLAN_SUBNET_CAM_CONTROLr_SET(r,d) (r).vlan_subnet_cam_control[0] = d
#define BCM56218_A0_VLAN_SUBNET_CAM_CONTROLr_GET(r) (r).vlan_subnet_cam_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_VLAN_SUBNET_CAM_CONTROLr_BIST_EN0f_GET(r) (((r).vlan_subnet_cam_control[0]) & 0x1)
#define BCM56218_A0_VLAN_SUBNET_CAM_CONTROLr_BIST_EN0f_SET(r,f) (r).vlan_subnet_cam_control[0]=(((r).vlan_subnet_cam_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_VLAN_SUBNET_CAM_CONTROLr_BIST_EN1f_GET(r) ((((r).vlan_subnet_cam_control[0]) >> 1) & 0x1)
#define BCM56218_A0_VLAN_SUBNET_CAM_CONTROLr_BIST_EN1f_SET(r,f) (r).vlan_subnet_cam_control[0]=(((r).vlan_subnet_cam_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_VLAN_SUBNET_CAM_CONTROLr_SAMf_GET(r) ((((r).vlan_subnet_cam_control[0]) >> 2) & 0x7)
#define BCM56218_A0_VLAN_SUBNET_CAM_CONTROLr_SAMf_SET(r,f) (r).vlan_subnet_cam_control[0]=(((r).vlan_subnet_cam_control[0] & ~((uint32_t)0x7 << 2)) | ((((uint32_t)f) & 0x7) << 2))

/*
 * These macros can be used to access VLAN_SUBNET_CAM_CONTROL.
 *
 */
#define BCM56218_A0_READ_VLAN_SUBNET_CAM_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_VLAN_SUBNET_CAM_CONTROLr,(r._vlan_subnet_cam_control))
#define BCM56218_A0_WRITE_VLAN_SUBNET_CAM_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_VLAN_SUBNET_CAM_CONTROLr,&(r._vlan_subnet_cam_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_SUBNET_CAM_CONTROLr BCM56218_A0_VLAN_SUBNET_CAM_CONTROLr
#define VLAN_SUBNET_CAM_CONTROLr_SIZE BCM56218_A0_VLAN_SUBNET_CAM_CONTROLr_SIZE
typedef BCM56218_A0_VLAN_SUBNET_CAM_CONTROLr_t VLAN_SUBNET_CAM_CONTROLr_t;
#define VLAN_SUBNET_CAM_CONTROLr_CLR BCM56218_A0_VLAN_SUBNET_CAM_CONTROLr_CLR
#define VLAN_SUBNET_CAM_CONTROLr_SET BCM56218_A0_VLAN_SUBNET_CAM_CONTROLr_SET
#define VLAN_SUBNET_CAM_CONTROLr_GET BCM56218_A0_VLAN_SUBNET_CAM_CONTROLr_GET
#define VLAN_SUBNET_CAM_CONTROLr_BIST_EN0f_GET BCM56218_A0_VLAN_SUBNET_CAM_CONTROLr_BIST_EN0f_GET
#define VLAN_SUBNET_CAM_CONTROLr_BIST_EN0f_SET BCM56218_A0_VLAN_SUBNET_CAM_CONTROLr_BIST_EN0f_SET
#define VLAN_SUBNET_CAM_CONTROLr_BIST_EN1f_GET BCM56218_A0_VLAN_SUBNET_CAM_CONTROLr_BIST_EN1f_GET
#define VLAN_SUBNET_CAM_CONTROLr_BIST_EN1f_SET BCM56218_A0_VLAN_SUBNET_CAM_CONTROLr_BIST_EN1f_SET
#define VLAN_SUBNET_CAM_CONTROLr_SAMf_GET BCM56218_A0_VLAN_SUBNET_CAM_CONTROLr_SAMf_GET
#define VLAN_SUBNET_CAM_CONTROLr_SAMf_SET BCM56218_A0_VLAN_SUBNET_CAM_CONTROLr_SAMf_SET
#define READ_VLAN_SUBNET_CAM_CONTROLr BCM56218_A0_READ_VLAN_SUBNET_CAM_CONTROLr
#define WRITE_VLAN_SUBNET_CAM_CONTROLr BCM56218_A0_WRITE_VLAN_SUBNET_CAM_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_VLAN_SUBNET_CAM_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  VLAN_SUBNET_DATA_ONLY
 * BLOCKS:   IPIPE
 * DESC:     Holds data for IP Subnet-based VLAN substitution
 * SIZE:     15
 * FIELDS:
 *     PRI              Priority field
 *     VLAN_ID          VLAN ID
 *
 ******************************************************************************/
#define BCM56218_A0_VLAN_SUBNET_DATA_ONLYm 0x04740000

#define BCM56218_A0_VLAN_SUBNET_DATA_ONLYm_MIN 0
#define BCM56218_A0_VLAN_SUBNET_DATA_ONLYm_MAX 255
#define BCM56218_A0_VLAN_SUBNET_DATA_ONLYm_CMAX(u) 255
#define BCM56218_A0_VLAN_SUBNET_DATA_ONLYm_SIZE 2

/*
 * This structure should be used to declare and program VLAN_SUBNET_DATA_ONLY.
 *
 */
typedef union BCM56218_A0_VLAN_SUBNET_DATA_ONLYm_s {
	uint32_t v[1];
	uint32_t vlan_subnet_data_only[1];
	uint32_t _vlan_subnet_data_only;
} BCM56218_A0_VLAN_SUBNET_DATA_ONLYm_t;

#define BCM56218_A0_VLAN_SUBNET_DATA_ONLYm_CLR(r) (r).vlan_subnet_data_only[0] = 0
#define BCM56218_A0_VLAN_SUBNET_DATA_ONLYm_SET(r,d) (r).vlan_subnet_data_only[0] = d
#define BCM56218_A0_VLAN_SUBNET_DATA_ONLYm_GET(r) (r).vlan_subnet_data_only[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_VLAN_SUBNET_DATA_ONLYm_PRIf_GET(r) (((r).vlan_subnet_data_only[0]) & 0x7)
#define BCM56218_A0_VLAN_SUBNET_DATA_ONLYm_PRIf_SET(r,f) (r).vlan_subnet_data_only[0]=(((r).vlan_subnet_data_only[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM56218_A0_VLAN_SUBNET_DATA_ONLYm_VLAN_IDf_GET(r) ((((r).vlan_subnet_data_only[0]) >> 3) & 0xfff)
#define BCM56218_A0_VLAN_SUBNET_DATA_ONLYm_VLAN_IDf_SET(r,f) (r).vlan_subnet_data_only[0]=(((r).vlan_subnet_data_only[0] & ~((uint32_t)0xfff << 3)) | ((((uint32_t)f) & 0xfff) << 3))

/*
 * These macros can be used to access VLAN_SUBNET_DATA_ONLY.
 *
 */
#define BCM56218_A0_READ_VLAN_SUBNET_DATA_ONLYm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_VLAN_SUBNET_DATA_ONLYm,i,(m._vlan_subnet_data_only),1)
#define BCM56218_A0_WRITE_VLAN_SUBNET_DATA_ONLYm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_VLAN_SUBNET_DATA_ONLYm,i,&(m._vlan_subnet_data_only),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_SUBNET_DATA_ONLYm BCM56218_A0_VLAN_SUBNET_DATA_ONLYm
#define VLAN_SUBNET_DATA_ONLYm_MIN BCM56218_A0_VLAN_SUBNET_DATA_ONLYm_MIN
#define VLAN_SUBNET_DATA_ONLYm_MAX BCM56218_A0_VLAN_SUBNET_DATA_ONLYm_MAX
#define VLAN_SUBNET_DATA_ONLYm_CMAX(u) BCM56218_A0_VLAN_SUBNET_DATA_ONLYm_CMAX(u)
#define VLAN_SUBNET_DATA_ONLYm_SIZE BCM56218_A0_VLAN_SUBNET_DATA_ONLYm_SIZE
typedef BCM56218_A0_VLAN_SUBNET_DATA_ONLYm_t VLAN_SUBNET_DATA_ONLYm_t;
#define VLAN_SUBNET_DATA_ONLYm_CLR BCM56218_A0_VLAN_SUBNET_DATA_ONLYm_CLR
#define VLAN_SUBNET_DATA_ONLYm_SET BCM56218_A0_VLAN_SUBNET_DATA_ONLYm_SET
#define VLAN_SUBNET_DATA_ONLYm_GET BCM56218_A0_VLAN_SUBNET_DATA_ONLYm_GET
#define VLAN_SUBNET_DATA_ONLYm_PRIf_GET BCM56218_A0_VLAN_SUBNET_DATA_ONLYm_PRIf_GET
#define VLAN_SUBNET_DATA_ONLYm_PRIf_SET BCM56218_A0_VLAN_SUBNET_DATA_ONLYm_PRIf_SET
#define VLAN_SUBNET_DATA_ONLYm_VLAN_IDf_GET BCM56218_A0_VLAN_SUBNET_DATA_ONLYm_VLAN_IDf_GET
#define VLAN_SUBNET_DATA_ONLYm_VLAN_IDf_SET BCM56218_A0_VLAN_SUBNET_DATA_ONLYm_VLAN_IDf_SET
#define READ_VLAN_SUBNET_DATA_ONLYm BCM56218_A0_READ_VLAN_SUBNET_DATA_ONLYm
#define WRITE_VLAN_SUBNET_DATA_ONLYm BCM56218_A0_WRITE_VLAN_SUBNET_DATA_ONLYm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_VLAN_SUBNET_DATA_ONLYm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  VLAN_SUBNET_ONLY
 * BLOCKS:   IPIPE
 * DESC:     TCAM for IP subnet based VLAN substitution
 * SIZE:     129
 * FIELDS:
 *     VALID            IP Subnet mask
 *     IP_ADDR          IP Address key
 *     MASK             IP Subnet mask
 *
 ******************************************************************************/
#define BCM56218_A0_VLAN_SUBNET_ONLYm 0x04730000

#define BCM56218_A0_VLAN_SUBNET_ONLYm_MIN 0
#define BCM56218_A0_VLAN_SUBNET_ONLYm_MAX 255
#define BCM56218_A0_VLAN_SUBNET_ONLYm_CMAX(u) 255
#define BCM56218_A0_VLAN_SUBNET_ONLYm_SIZE 17

/*
 * This structure should be used to declare and program VLAN_SUBNET_ONLY.
 *
 */
typedef union BCM56218_A0_VLAN_SUBNET_ONLYm_s {
	uint32_t v[5];
	uint32_t vlan_subnet_only[5];
	uint32_t _vlan_subnet_only;
} BCM56218_A0_VLAN_SUBNET_ONLYm_t;

#define BCM56218_A0_VLAN_SUBNET_ONLYm_CLR(r) CDK_MEMSET(&((r)._vlan_subnet_only), 0, sizeof(BCM56218_A0_VLAN_SUBNET_ONLYm_t))
#define BCM56218_A0_VLAN_SUBNET_ONLYm_SET(r,i,d) (r).vlan_subnet_only[i] = d
#define BCM56218_A0_VLAN_SUBNET_ONLYm_GET(r,i) (r).vlan_subnet_only[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_VLAN_SUBNET_ONLYm_VALIDf_GET(r) (((r).vlan_subnet_only[0]) & 0x1)
#define BCM56218_A0_VLAN_SUBNET_ONLYm_VALIDf_SET(r,f) (r).vlan_subnet_only[0]=(((r).vlan_subnet_only[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_VLAN_SUBNET_ONLYm_IP_ADDRf_GET(r,a) cdk_field_get((r).vlan_subnet_only,1,64,a)
#define BCM56218_A0_VLAN_SUBNET_ONLYm_IP_ADDRf_SET(r,a) cdk_field_set((r).vlan_subnet_only,1,64,a)
#define BCM56218_A0_VLAN_SUBNET_ONLYm_MASKf_GET(r,a) cdk_field_get((r).vlan_subnet_only,65,128,a)
#define BCM56218_A0_VLAN_SUBNET_ONLYm_MASKf_SET(r,a) cdk_field_set((r).vlan_subnet_only,65,128,a)

/*
 * These macros can be used to access VLAN_SUBNET_ONLY.
 *
 */
#define BCM56218_A0_READ_VLAN_SUBNET_ONLYm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_VLAN_SUBNET_ONLYm,i,(m._vlan_subnet_only),5)
#define BCM56218_A0_WRITE_VLAN_SUBNET_ONLYm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_VLAN_SUBNET_ONLYm,i,&(m._vlan_subnet_only),5)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_SUBNET_ONLYm BCM56218_A0_VLAN_SUBNET_ONLYm
#define VLAN_SUBNET_ONLYm_MIN BCM56218_A0_VLAN_SUBNET_ONLYm_MIN
#define VLAN_SUBNET_ONLYm_MAX BCM56218_A0_VLAN_SUBNET_ONLYm_MAX
#define VLAN_SUBNET_ONLYm_CMAX(u) BCM56218_A0_VLAN_SUBNET_ONLYm_CMAX(u)
#define VLAN_SUBNET_ONLYm_SIZE BCM56218_A0_VLAN_SUBNET_ONLYm_SIZE
typedef BCM56218_A0_VLAN_SUBNET_ONLYm_t VLAN_SUBNET_ONLYm_t;
#define VLAN_SUBNET_ONLYm_CLR BCM56218_A0_VLAN_SUBNET_ONLYm_CLR
#define VLAN_SUBNET_ONLYm_SET BCM56218_A0_VLAN_SUBNET_ONLYm_SET
#define VLAN_SUBNET_ONLYm_GET BCM56218_A0_VLAN_SUBNET_ONLYm_GET
#define VLAN_SUBNET_ONLYm_VALIDf_GET BCM56218_A0_VLAN_SUBNET_ONLYm_VALIDf_GET
#define VLAN_SUBNET_ONLYm_VALIDf_SET BCM56218_A0_VLAN_SUBNET_ONLYm_VALIDf_SET
#define VLAN_SUBNET_ONLYm_IP_ADDRf_GET BCM56218_A0_VLAN_SUBNET_ONLYm_IP_ADDRf_GET
#define VLAN_SUBNET_ONLYm_IP_ADDRf_SET BCM56218_A0_VLAN_SUBNET_ONLYm_IP_ADDRf_SET
#define VLAN_SUBNET_ONLYm_MASKf_GET BCM56218_A0_VLAN_SUBNET_ONLYm_MASKf_GET
#define VLAN_SUBNET_ONLYm_MASKf_SET BCM56218_A0_VLAN_SUBNET_ONLYm_MASKf_SET
#define READ_VLAN_SUBNET_ONLYm BCM56218_A0_READ_VLAN_SUBNET_ONLYm
#define WRITE_VLAN_SUBNET_ONLYm BCM56218_A0_WRITE_VLAN_SUBNET_ONLYm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_VLAN_SUBNET_ONLYm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * MEMORY:  VLAN_TAB
 * BLOCKS:   IPIPE
 * DESC:     Contains cntrls assoc with the 4K VLANs.
 * SIZE:     64
 * FIELDS:
 *     PORT_BITMAP      VLAN port membership bitmap
 *     PORT_BITMAP_LO   VLAN port membership bitmap
 *     PORT_BITMAP_HI   VLAN port membership bitmap
 *     VALID            Valid VLAN ID
 *     STG              Spanning Tree Group ID
 *     PFM              Port Filtering Mode
 *
 ******************************************************************************/
#define BCM56218_A0_VLAN_TABm 0x05700000

#define BCM56218_A0_VLAN_TABm_MIN 0
#define BCM56218_A0_VLAN_TABm_MAX 4095
#define BCM56218_A0_VLAN_TABm_CMAX(u) 4095
#define BCM56218_A0_VLAN_TABm_SIZE 8

/*
 * This structure should be used to declare and program VLAN_TAB.
 *
 */
typedef union BCM56218_A0_VLAN_TABm_s {
	uint32_t v[2];
	uint32_t vlan_tab[2];
	uint32_t _vlan_tab;
} BCM56218_A0_VLAN_TABm_t;

#define BCM56218_A0_VLAN_TABm_CLR(r) CDK_MEMSET(&((r)._vlan_tab), 0, sizeof(BCM56218_A0_VLAN_TABm_t))
#define BCM56218_A0_VLAN_TABm_SET(r,i,d) (r).vlan_tab[i] = d
#define BCM56218_A0_VLAN_TABm_GET(r,i) (r).vlan_tab[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_VLAN_TABm_PORT_BITMAPf_GET(r,a) cdk_field_get((r).vlan_tab,0,53,a)
#define BCM56218_A0_VLAN_TABm_PORT_BITMAPf_SET(r,a) cdk_field_set((r).vlan_tab,0,53,a)
#define BCM56218_A0_VLAN_TABm_PORT_BITMAP_LOf_GET(r) ((r).vlan_tab[0])
#define BCM56218_A0_VLAN_TABm_PORT_BITMAP_LOf_SET(r,f) (r).vlan_tab[0]=((uint32_t)f)
#define BCM56218_A0_VLAN_TABm_PORT_BITMAP_HIf_GET(r) (((r).vlan_tab[1]) & 0x3fffff)
#define BCM56218_A0_VLAN_TABm_PORT_BITMAP_HIf_SET(r,f) (r).vlan_tab[1]=(((r).vlan_tab[1] & ~((uint32_t)0x3fffff)) | (((uint32_t)f) & 0x3fffff))
#define BCM56218_A0_VLAN_TABm_VALIDf_GET(r) ((((r).vlan_tab[1]) >> 22) & 0x1)
#define BCM56218_A0_VLAN_TABm_VALIDf_SET(r,f) (r).vlan_tab[1]=(((r).vlan_tab[1] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM56218_A0_VLAN_TABm_STGf_GET(r) ((((r).vlan_tab[1]) >> 23) & 0x7f)
#define BCM56218_A0_VLAN_TABm_STGf_SET(r,f) (r).vlan_tab[1]=(((r).vlan_tab[1] & ~((uint32_t)0x7f << 23)) | ((((uint32_t)f) & 0x7f) << 23))
#define BCM56218_A0_VLAN_TABm_PFMf_GET(r) ((((r).vlan_tab[1]) >> 30) & 0x3)
#define BCM56218_A0_VLAN_TABm_PFMf_SET(r,f) (r).vlan_tab[1]=(((r).vlan_tab[1] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))

/*
 * These macros can be used to access VLAN_TAB.
 *
 */
#define BCM56218_A0_READ_VLAN_TABm(u,i,m) cdk_xgs_mem_read(u,BCM56218_A0_VLAN_TABm,i,(m._vlan_tab),2)
#define BCM56218_A0_WRITE_VLAN_TABm(u,i,m) cdk_xgs_mem_write(u,BCM56218_A0_VLAN_TABm,i,&(m._vlan_tab),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_TABm BCM56218_A0_VLAN_TABm
#define VLAN_TABm_MIN BCM56218_A0_VLAN_TABm_MIN
#define VLAN_TABm_MAX BCM56218_A0_VLAN_TABm_MAX
#define VLAN_TABm_CMAX(u) BCM56218_A0_VLAN_TABm_CMAX(u)
#define VLAN_TABm_SIZE BCM56218_A0_VLAN_TABm_SIZE
typedef BCM56218_A0_VLAN_TABm_t VLAN_TABm_t;
#define VLAN_TABm_CLR BCM56218_A0_VLAN_TABm_CLR
#define VLAN_TABm_SET BCM56218_A0_VLAN_TABm_SET
#define VLAN_TABm_GET BCM56218_A0_VLAN_TABm_GET
#define VLAN_TABm_PORT_BITMAPf_GET BCM56218_A0_VLAN_TABm_PORT_BITMAPf_GET
#define VLAN_TABm_PORT_BITMAPf_SET BCM56218_A0_VLAN_TABm_PORT_BITMAPf_SET
#define VLAN_TABm_PORT_BITMAP_LOf_GET BCM56218_A0_VLAN_TABm_PORT_BITMAP_LOf_GET
#define VLAN_TABm_PORT_BITMAP_LOf_SET BCM56218_A0_VLAN_TABm_PORT_BITMAP_LOf_SET
#define VLAN_TABm_PORT_BITMAP_HIf_GET BCM56218_A0_VLAN_TABm_PORT_BITMAP_HIf_GET
#define VLAN_TABm_PORT_BITMAP_HIf_SET BCM56218_A0_VLAN_TABm_PORT_BITMAP_HIf_SET
#define VLAN_TABm_VALIDf_GET BCM56218_A0_VLAN_TABm_VALIDf_GET
#define VLAN_TABm_VALIDf_SET BCM56218_A0_VLAN_TABm_VALIDf_SET
#define VLAN_TABm_STGf_GET BCM56218_A0_VLAN_TABm_STGf_GET
#define VLAN_TABm_STGf_SET BCM56218_A0_VLAN_TABm_STGf_SET
#define VLAN_TABm_PFMf_GET BCM56218_A0_VLAN_TABm_PFMf_GET
#define VLAN_TABm_PFMf_SET BCM56218_A0_VLAN_TABm_PFMf_SET
#define READ_VLAN_TABm BCM56218_A0_READ_VLAN_TABm
#define WRITE_VLAN_TABm BCM56218_A0_WRITE_VLAN_TABm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_VLAN_TABm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  WRRWEIGHT_COS
 * BLOCKS:   MMU
 * DESC:      WRR Weight for each COS
 * SIZE:     32
 * FIELDS:
 *     WEIGHT           When Weighted Round Robin is selected, this register cos Weightdefines how many packets can  be trasmitted in one run.If value is zero, this COS will be a pure priority scheduling.When Deficit Round Robin Queueing selects, this register is COS weight,Define how many bytes can  be trasmitted in one run. If value is zero, this COS will be a pure priority scheduling.COS7Weight= 0:   pure prioirty,COS7Weight= value between 1-127: this will be the multiplication factor with the chosen quanta    
 *
 ******************************************************************************/
#define BCM56218_A0_WRRWEIGHT_COSr 0x00600043

#define BCM56218_A0_WRRWEIGHT_COSr_SIZE 4

/*
 * This structure should be used to declare and program WRRWEIGHT_COS.
 *
 */
typedef union BCM56218_A0_WRRWEIGHT_COSr_s {
	uint32_t v[1];
	uint32_t wrrweight_cos[1];
	uint32_t _wrrweight_cos;
} BCM56218_A0_WRRWEIGHT_COSr_t;

#define BCM56218_A0_WRRWEIGHT_COSr_CLR(r) (r).wrrweight_cos[0] = 0
#define BCM56218_A0_WRRWEIGHT_COSr_SET(r,d) (r).wrrweight_cos[0] = d
#define BCM56218_A0_WRRWEIGHT_COSr_GET(r) (r).wrrweight_cos[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_WRRWEIGHT_COSr_WEIGHTf_GET(r) (((r).wrrweight_cos[0]) & 0x7f)
#define BCM56218_A0_WRRWEIGHT_COSr_WEIGHTf_SET(r,f) (r).wrrweight_cos[0]=(((r).wrrweight_cos[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f))

/*
 * These macros can be used to access WRRWEIGHT_COS.
 *
 */
#define BCM56218_A0_READ_WRRWEIGHT_COSr(u,p,i,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_WRRWEIGHT_COSr+(i),(r._wrrweight_cos))
#define BCM56218_A0_WRITE_WRRWEIGHT_COSr(u,p,i,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_WRRWEIGHT_COSr+(i),&(r._wrrweight_cos))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define WRRWEIGHT_COSr BCM56218_A0_WRRWEIGHT_COSr
#define WRRWEIGHT_COSr_SIZE BCM56218_A0_WRRWEIGHT_COSr_SIZE
typedef BCM56218_A0_WRRWEIGHT_COSr_t WRRWEIGHT_COSr_t;
#define WRRWEIGHT_COSr_CLR BCM56218_A0_WRRWEIGHT_COSr_CLR
#define WRRWEIGHT_COSr_SET BCM56218_A0_WRRWEIGHT_COSr_SET
#define WRRWEIGHT_COSr_GET BCM56218_A0_WRRWEIGHT_COSr_GET
#define WRRWEIGHT_COSr_WEIGHTf_GET BCM56218_A0_WRRWEIGHT_COSr_WEIGHTf_GET
#define WRRWEIGHT_COSr_WEIGHTf_SET BCM56218_A0_WRRWEIGHT_COSr_WEIGHTf_SET
#define READ_WRRWEIGHT_COSr BCM56218_A0_READ_WRRWEIGHT_COSr
#define WRITE_WRRWEIGHT_COSr BCM56218_A0_WRITE_WRRWEIGHT_COSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_WRRWEIGHT_COSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  XQCOSARBSEL
 * BLOCKS:   MMU
 * DESC:     Scheduler Control Selection
 * SIZE:     32
 * FIELDS:
 *     COSARB           Scheduler Control OptionscosArb[1:0]=0: Strict priority among valid COSs. (default value.)cosArb[1:0]=1: Round Robin Queueing among valid COSs.cosArb[1:0]=2: Weightd Round Robin Queueing, WRR, scheduling according to WRR Weight.cosArb[1:0]=3: Deficit Round Robin Queueing, DRR, scheduling according to WRR Weight.
 *     MTU_QUANTA_SELECT In WDRR mode, each weight is multiplied by MTU quanta which is defined by MTU_Quanta_Select:cosArb[3:2]=0: MTU Quanta is 2048 bytes. cosArb[3:2]=1: MTU Quanta is 4096 bytes.cosArb[3:2]=2: MTU Quanta is 8192 bytes.cosArb[3:2]=3: MTU Quanta is 16384 bytes(default value)
 *
 ******************************************************************************/
#define BCM56218_A0_XQCOSARBSELr 0x00600042

#define BCM56218_A0_XQCOSARBSELr_SIZE 4

/*
 * This structure should be used to declare and program XQCOSARBSEL.
 *
 */
typedef union BCM56218_A0_XQCOSARBSELr_s {
	uint32_t v[1];
	uint32_t xqcosarbsel[1];
	uint32_t _xqcosarbsel;
} BCM56218_A0_XQCOSARBSELr_t;

#define BCM56218_A0_XQCOSARBSELr_CLR(r) (r).xqcosarbsel[0] = 0
#define BCM56218_A0_XQCOSARBSELr_SET(r,d) (r).xqcosarbsel[0] = d
#define BCM56218_A0_XQCOSARBSELr_GET(r) (r).xqcosarbsel[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_XQCOSARBSELr_COSARBf_GET(r) (((r).xqcosarbsel[0]) & 0x3)
#define BCM56218_A0_XQCOSARBSELr_COSARBf_SET(r,f) (r).xqcosarbsel[0]=(((r).xqcosarbsel[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56218_A0_XQCOSARBSELr_MTU_QUANTA_SELECTf_GET(r) ((((r).xqcosarbsel[0]) >> 2) & 0x3)
#define BCM56218_A0_XQCOSARBSELr_MTU_QUANTA_SELECTf_SET(r,f) (r).xqcosarbsel[0]=(((r).xqcosarbsel[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))

/*
 * These macros can be used to access XQCOSARBSEL.
 *
 */
#define BCM56218_A0_READ_XQCOSARBSELr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_XQCOSARBSELr,(r._xqcosarbsel))
#define BCM56218_A0_WRITE_XQCOSARBSELr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_XQCOSARBSELr,&(r._xqcosarbsel))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XQCOSARBSELr BCM56218_A0_XQCOSARBSELr
#define XQCOSARBSELr_SIZE BCM56218_A0_XQCOSARBSELr_SIZE
typedef BCM56218_A0_XQCOSARBSELr_t XQCOSARBSELr_t;
#define XQCOSARBSELr_CLR BCM56218_A0_XQCOSARBSELr_CLR
#define XQCOSARBSELr_SET BCM56218_A0_XQCOSARBSELr_SET
#define XQCOSARBSELr_GET BCM56218_A0_XQCOSARBSELr_GET
#define XQCOSARBSELr_COSARBf_GET BCM56218_A0_XQCOSARBSELr_COSARBf_GET
#define XQCOSARBSELr_COSARBf_SET BCM56218_A0_XQCOSARBSELr_COSARBf_SET
#define XQCOSARBSELr_MTU_QUANTA_SELECTf_GET BCM56218_A0_XQCOSARBSELr_MTU_QUANTA_SELECTf_GET
#define XQCOSARBSELr_MTU_QUANTA_SELECTf_SET BCM56218_A0_XQCOSARBSELr_MTU_QUANTA_SELECTf_SET
#define READ_XQCOSARBSELr BCM56218_A0_READ_XQCOSARBSELr
#define WRITE_XQCOSARBSELr BCM56218_A0_WRITE_XQCOSARBSELr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_XQCOSARBSELr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  XQEMPTY
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     COS0             COS0 has no entries for this port
 *     COS1             COS1 has no entries for this port
 *     COS2             COS2 has no entries for this port
 *     COS3             COS3 has no entries for this port
 *     COS4             COS4 has no entries for this port
 *     COS5             COS5 has no entries for this port
 *     COS6             COS6 has no entries for this port
 *     COS7             COS7 has no entries for this port
 *
 ******************************************************************************/
#define BCM56218_A0_XQEMPTYr 0x00600039

#define BCM56218_A0_XQEMPTYr_SIZE 4

/*
 * This structure should be used to declare and program XQEMPTY.
 *
 */
typedef union BCM56218_A0_XQEMPTYr_s {
	uint32_t v[1];
	uint32_t xqempty[1];
	uint32_t _xqempty;
} BCM56218_A0_XQEMPTYr_t;

#define BCM56218_A0_XQEMPTYr_CLR(r) (r).xqempty[0] = 0
#define BCM56218_A0_XQEMPTYr_SET(r,d) (r).xqempty[0] = d
#define BCM56218_A0_XQEMPTYr_GET(r) (r).xqempty[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_XQEMPTYr_COS0f_GET(r) (((r).xqempty[0]) & 0x1)
#define BCM56218_A0_XQEMPTYr_COS0f_SET(r,f) (r).xqempty[0]=(((r).xqempty[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_XQEMPTYr_COS1f_GET(r) ((((r).xqempty[0]) >> 1) & 0x1)
#define BCM56218_A0_XQEMPTYr_COS1f_SET(r,f) (r).xqempty[0]=(((r).xqempty[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_XQEMPTYr_COS2f_GET(r) ((((r).xqempty[0]) >> 2) & 0x1)
#define BCM56218_A0_XQEMPTYr_COS2f_SET(r,f) (r).xqempty[0]=(((r).xqempty[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_XQEMPTYr_COS3f_GET(r) ((((r).xqempty[0]) >> 3) & 0x1)
#define BCM56218_A0_XQEMPTYr_COS3f_SET(r,f) (r).xqempty[0]=(((r).xqempty[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56218_A0_XQEMPTYr_COS4f_GET(r) ((((r).xqempty[0]) >> 4) & 0x1)
#define BCM56218_A0_XQEMPTYr_COS4f_SET(r,f) (r).xqempty[0]=(((r).xqempty[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56218_A0_XQEMPTYr_COS5f_GET(r) ((((r).xqempty[0]) >> 5) & 0x1)
#define BCM56218_A0_XQEMPTYr_COS5f_SET(r,f) (r).xqempty[0]=(((r).xqempty[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56218_A0_XQEMPTYr_COS6f_GET(r) ((((r).xqempty[0]) >> 6) & 0x1)
#define BCM56218_A0_XQEMPTYr_COS6f_SET(r,f) (r).xqempty[0]=(((r).xqempty[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56218_A0_XQEMPTYr_COS7f_GET(r) ((((r).xqempty[0]) >> 7) & 0x1)
#define BCM56218_A0_XQEMPTYr_COS7f_SET(r,f) (r).xqempty[0]=(((r).xqempty[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access XQEMPTY.
 *
 */
#define BCM56218_A0_READ_XQEMPTYr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_XQEMPTYr,(r._xqempty))
#define BCM56218_A0_WRITE_XQEMPTYr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_XQEMPTYr,&(r._xqempty))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XQEMPTYr BCM56218_A0_XQEMPTYr
#define XQEMPTYr_SIZE BCM56218_A0_XQEMPTYr_SIZE
typedef BCM56218_A0_XQEMPTYr_t XQEMPTYr_t;
#define XQEMPTYr_CLR BCM56218_A0_XQEMPTYr_CLR
#define XQEMPTYr_SET BCM56218_A0_XQEMPTYr_SET
#define XQEMPTYr_GET BCM56218_A0_XQEMPTYr_GET
#define XQEMPTYr_COS0f_GET BCM56218_A0_XQEMPTYr_COS0f_GET
#define XQEMPTYr_COS0f_SET BCM56218_A0_XQEMPTYr_COS0f_SET
#define XQEMPTYr_COS1f_GET BCM56218_A0_XQEMPTYr_COS1f_GET
#define XQEMPTYr_COS1f_SET BCM56218_A0_XQEMPTYr_COS1f_SET
#define XQEMPTYr_COS2f_GET BCM56218_A0_XQEMPTYr_COS2f_GET
#define XQEMPTYr_COS2f_SET BCM56218_A0_XQEMPTYr_COS2f_SET
#define XQEMPTYr_COS3f_GET BCM56218_A0_XQEMPTYr_COS3f_GET
#define XQEMPTYr_COS3f_SET BCM56218_A0_XQEMPTYr_COS3f_SET
#define XQEMPTYr_COS4f_GET BCM56218_A0_XQEMPTYr_COS4f_GET
#define XQEMPTYr_COS4f_SET BCM56218_A0_XQEMPTYr_COS4f_SET
#define XQEMPTYr_COS5f_GET BCM56218_A0_XQEMPTYr_COS5f_GET
#define XQEMPTYr_COS5f_SET BCM56218_A0_XQEMPTYr_COS5f_SET
#define XQEMPTYr_COS6f_GET BCM56218_A0_XQEMPTYr_COS6f_GET
#define XQEMPTYr_COS6f_SET BCM56218_A0_XQEMPTYr_COS6f_SET
#define XQEMPTYr_COS7f_GET BCM56218_A0_XQEMPTYr_COS7f_GET
#define XQEMPTYr_COS7f_SET BCM56218_A0_XQEMPTYr_COS7f_SET
#define READ_XQEMPTYr BCM56218_A0_READ_XQEMPTYr
#define WRITE_XQEMPTYr BCM56218_A0_WRITE_XQEMPTYr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_XQEMPTYr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  XQMEMDEBUG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CCM              ccm registers.
 *     RM               rm registers.
 *     CT0              ct0 registers.
 *     CT1              ct1 registers.
 *     CT2              ct2 registers.
 *     SAM              sam registers.
 *
 ******************************************************************************/
#define BCM56218_A0_XQMEMDEBUGr 0x00600051

#define BCM56218_A0_XQMEMDEBUGr_SIZE 4

/*
 * This structure should be used to declare and program XQMEMDEBUG.
 *
 */
typedef union BCM56218_A0_XQMEMDEBUGr_s {
	uint32_t v[1];
	uint32_t xqmemdebug[1];
	uint32_t _xqmemdebug;
} BCM56218_A0_XQMEMDEBUGr_t;

#define BCM56218_A0_XQMEMDEBUGr_CLR(r) (r).xqmemdebug[0] = 0
#define BCM56218_A0_XQMEMDEBUGr_SET(r,d) (r).xqmemdebug[0] = d
#define BCM56218_A0_XQMEMDEBUGr_GET(r) (r).xqmemdebug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_XQMEMDEBUGr_CCMf_GET(r) (((r).xqmemdebug[0]) & 0x1)
#define BCM56218_A0_XQMEMDEBUGr_CCMf_SET(r,f) (r).xqmemdebug[0]=(((r).xqmemdebug[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56218_A0_XQMEMDEBUGr_RMf_GET(r) ((((r).xqmemdebug[0]) >> 1) & 0x1)
#define BCM56218_A0_XQMEMDEBUGr_RMf_SET(r,f) (r).xqmemdebug[0]=(((r).xqmemdebug[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56218_A0_XQMEMDEBUGr_CT0f_GET(r) ((((r).xqmemdebug[0]) >> 2) & 0x1)
#define BCM56218_A0_XQMEMDEBUGr_CT0f_SET(r,f) (r).xqmemdebug[0]=(((r).xqmemdebug[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56218_A0_XQMEMDEBUGr_CT1f_GET(r) ((((r).xqmemdebug[0]) >> 3) & 0x1)
#define BCM56218_A0_XQMEMDEBUGr_CT1f_SET(r,f) (r).xqmemdebug[0]=(((r).xqmemdebug[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56218_A0_XQMEMDEBUGr_CT2f_GET(r) ((((r).xqmemdebug[0]) >> 4) & 0x1)
#define BCM56218_A0_XQMEMDEBUGr_CT2f_SET(r,f) (r).xqmemdebug[0]=(((r).xqmemdebug[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56218_A0_XQMEMDEBUGr_SAMf_GET(r) ((((r).xqmemdebug[0]) >> 5) & 0x3)
#define BCM56218_A0_XQMEMDEBUGr_SAMf_SET(r,f) (r).xqmemdebug[0]=(((r).xqmemdebug[0] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5))

/*
 * These macros can be used to access XQMEMDEBUG.
 *
 */
#define BCM56218_A0_READ_XQMEMDEBUGr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_XQMEMDEBUGr,(r._xqmemdebug))
#define BCM56218_A0_WRITE_XQMEMDEBUGr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_XQMEMDEBUGr,&(r._xqmemdebug))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XQMEMDEBUGr BCM56218_A0_XQMEMDEBUGr
#define XQMEMDEBUGr_SIZE BCM56218_A0_XQMEMDEBUGr_SIZE
typedef BCM56218_A0_XQMEMDEBUGr_t XQMEMDEBUGr_t;
#define XQMEMDEBUGr_CLR BCM56218_A0_XQMEMDEBUGr_CLR
#define XQMEMDEBUGr_SET BCM56218_A0_XQMEMDEBUGr_SET
#define XQMEMDEBUGr_GET BCM56218_A0_XQMEMDEBUGr_GET
#define XQMEMDEBUGr_CCMf_GET BCM56218_A0_XQMEMDEBUGr_CCMf_GET
#define XQMEMDEBUGr_CCMf_SET BCM56218_A0_XQMEMDEBUGr_CCMf_SET
#define XQMEMDEBUGr_RMf_GET BCM56218_A0_XQMEMDEBUGr_RMf_GET
#define XQMEMDEBUGr_RMf_SET BCM56218_A0_XQMEMDEBUGr_RMf_SET
#define XQMEMDEBUGr_CT0f_GET BCM56218_A0_XQMEMDEBUGr_CT0f_GET
#define XQMEMDEBUGr_CT0f_SET BCM56218_A0_XQMEMDEBUGr_CT0f_SET
#define XQMEMDEBUGr_CT1f_GET BCM56218_A0_XQMEMDEBUGr_CT1f_GET
#define XQMEMDEBUGr_CT1f_SET BCM56218_A0_XQMEMDEBUGr_CT1f_SET
#define XQMEMDEBUGr_CT2f_GET BCM56218_A0_XQMEMDEBUGr_CT2f_GET
#define XQMEMDEBUGr_CT2f_SET BCM56218_A0_XQMEMDEBUGr_CT2f_SET
#define XQMEMDEBUGr_SAMf_GET BCM56218_A0_XQMEMDEBUGr_SAMf_GET
#define XQMEMDEBUGr_SAMf_SET BCM56218_A0_XQMEMDEBUGr_SAMf_SET
#define READ_XQMEMDEBUGr BCM56218_A0_READ_XQMEMDEBUGr
#define WRITE_XQMEMDEBUGr BCM56218_A0_WRITE_XQMEMDEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_XQMEMDEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  XQPARITYERRORPBM
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     XQPARITYERRORPBM Egress Port Bitmap indicats which egress port detects XQ parity error.
 *
 ******************************************************************************/
#define BCM56218_A0_XQPARITYERRORPBMr 0x0068003c

#define BCM56218_A0_XQPARITYERRORPBMr_SIZE 4

/*
 * This structure should be used to declare and program XQPARITYERRORPBM.
 *
 */
typedef union BCM56218_A0_XQPARITYERRORPBMr_s {
	uint32_t v[1];
	uint32_t xqparityerrorpbm[1];
	uint32_t _xqparityerrorpbm;
} BCM56218_A0_XQPARITYERRORPBMr_t;

#define BCM56218_A0_XQPARITYERRORPBMr_CLR(r) (r).xqparityerrorpbm[0] = 0
#define BCM56218_A0_XQPARITYERRORPBMr_SET(r,d) (r).xqparityerrorpbm[0] = d
#define BCM56218_A0_XQPARITYERRORPBMr_GET(r) (r).xqparityerrorpbm[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_XQPARITYERRORPBMr_XQPARITYERRORPBMf_GET(r) ((r).xqparityerrorpbm[0])
#define BCM56218_A0_XQPARITYERRORPBMr_XQPARITYERRORPBMf_SET(r,f) (r).xqparityerrorpbm[0]=((uint32_t)f)

/*
 * These macros can be used to access XQPARITYERRORPBM.
 *
 */
#define BCM56218_A0_READ_XQPARITYERRORPBMr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_XQPARITYERRORPBMr,(r._xqparityerrorpbm))
#define BCM56218_A0_WRITE_XQPARITYERRORPBMr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_XQPARITYERRORPBMr,&(r._xqparityerrorpbm))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XQPARITYERRORPBMr BCM56218_A0_XQPARITYERRORPBMr
#define XQPARITYERRORPBMr_SIZE BCM56218_A0_XQPARITYERRORPBMr_SIZE
typedef BCM56218_A0_XQPARITYERRORPBMr_t XQPARITYERRORPBMr_t;
#define XQPARITYERRORPBMr_CLR BCM56218_A0_XQPARITYERRORPBMr_CLR
#define XQPARITYERRORPBMr_SET BCM56218_A0_XQPARITYERRORPBMr_SET
#define XQPARITYERRORPBMr_GET BCM56218_A0_XQPARITYERRORPBMr_GET
#define XQPARITYERRORPBMr_XQPARITYERRORPBMf_GET BCM56218_A0_XQPARITYERRORPBMr_XQPARITYERRORPBMf_GET
#define XQPARITYERRORPBMr_XQPARITYERRORPBMf_SET BCM56218_A0_XQPARITYERRORPBMr_XQPARITYERRORPBMf_SET
#define READ_XQPARITYERRORPBMr BCM56218_A0_READ_XQPARITYERRORPBMr
#define WRITE_XQPARITYERRORPBMr BCM56218_A0_WRITE_XQPARITYERRORPBMr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_XQPARITYERRORPBMr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  XQPARITYERRORPBM_HI
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     XQPARITYERRORPBM_HI Egress Port Bitmap indicats which egress port detects XQ parity error.for port 53-32
 *
 ******************************************************************************/
#define BCM56218_A0_XQPARITYERRORPBM_HIr 0x0068003d

#define BCM56218_A0_XQPARITYERRORPBM_HIr_SIZE 4

/*
 * This structure should be used to declare and program XQPARITYERRORPBM_HI.
 *
 */
typedef union BCM56218_A0_XQPARITYERRORPBM_HIr_s {
	uint32_t v[1];
	uint32_t xqparityerrorpbm_hi[1];
	uint32_t _xqparityerrorpbm_hi;
} BCM56218_A0_XQPARITYERRORPBM_HIr_t;

#define BCM56218_A0_XQPARITYERRORPBM_HIr_CLR(r) (r).xqparityerrorpbm_hi[0] = 0
#define BCM56218_A0_XQPARITYERRORPBM_HIr_SET(r,d) (r).xqparityerrorpbm_hi[0] = d
#define BCM56218_A0_XQPARITYERRORPBM_HIr_GET(r) (r).xqparityerrorpbm_hi[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_XQPARITYERRORPBM_HIr_XQPARITYERRORPBM_HIf_GET(r) (((r).xqparityerrorpbm_hi[0]) & 0x3fffff)
#define BCM56218_A0_XQPARITYERRORPBM_HIr_XQPARITYERRORPBM_HIf_SET(r,f) (r).xqparityerrorpbm_hi[0]=(((r).xqparityerrorpbm_hi[0] & ~((uint32_t)0x3fffff)) | (((uint32_t)f) & 0x3fffff))

/*
 * These macros can be used to access XQPARITYERRORPBM_HI.
 *
 */
#define BCM56218_A0_READ_XQPARITYERRORPBM_HIr(u,r) cdk_xgs_reg32_read(u,BCM56218_A0_XQPARITYERRORPBM_HIr,(r._xqparityerrorpbm_hi))
#define BCM56218_A0_WRITE_XQPARITYERRORPBM_HIr(u,r) cdk_xgs_reg32_write(u,BCM56218_A0_XQPARITYERRORPBM_HIr,&(r._xqparityerrorpbm_hi))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XQPARITYERRORPBM_HIr BCM56218_A0_XQPARITYERRORPBM_HIr
#define XQPARITYERRORPBM_HIr_SIZE BCM56218_A0_XQPARITYERRORPBM_HIr_SIZE
typedef BCM56218_A0_XQPARITYERRORPBM_HIr_t XQPARITYERRORPBM_HIr_t;
#define XQPARITYERRORPBM_HIr_CLR BCM56218_A0_XQPARITYERRORPBM_HIr_CLR
#define XQPARITYERRORPBM_HIr_SET BCM56218_A0_XQPARITYERRORPBM_HIr_SET
#define XQPARITYERRORPBM_HIr_GET BCM56218_A0_XQPARITYERRORPBM_HIr_GET
#define XQPARITYERRORPBM_HIr_XQPARITYERRORPBM_HIf_GET BCM56218_A0_XQPARITYERRORPBM_HIr_XQPARITYERRORPBM_HIf_GET
#define XQPARITYERRORPBM_HIr_XQPARITYERRORPBM_HIf_SET BCM56218_A0_XQPARITYERRORPBM_HIr_XQPARITYERRORPBM_HIf_SET
#define READ_XQPARITYERRORPBM_HIr BCM56218_A0_READ_XQPARITYERRORPBM_HIr
#define WRITE_XQPARITYERRORPBM_HIr BCM56218_A0_WRITE_XQPARITYERRORPBM_HIr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_XQPARITYERRORPBM_HIr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  XQPARITYERRORPTR
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     XQPARITYERRORPTR Egress Port XQ's parity error packet pointer keeps the abandonedxq parity errored memory address.
 *     XQPARITYERRORPKTPTR Egress Port XQ's parity error packet pointer keeps the abandonedxq parity errored memory read data's packet pointer.
 *
 ******************************************************************************/
#define BCM56218_A0_XQPARITYERRORPTRr 0x00600050

#define BCM56218_A0_XQPARITYERRORPTRr_SIZE 4

/*
 * This structure should be used to declare and program XQPARITYERRORPTR.
 *
 */
typedef union BCM56218_A0_XQPARITYERRORPTRr_s {
	uint32_t v[1];
	uint32_t xqparityerrorptr[1];
	uint32_t _xqparityerrorptr;
} BCM56218_A0_XQPARITYERRORPTRr_t;

#define BCM56218_A0_XQPARITYERRORPTRr_CLR(r) (r).xqparityerrorptr[0] = 0
#define BCM56218_A0_XQPARITYERRORPTRr_SET(r,d) (r).xqparityerrorptr[0] = d
#define BCM56218_A0_XQPARITYERRORPTRr_GET(r) (r).xqparityerrorptr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_XQPARITYERRORPTRr_XQPARITYERRORPTRf_GET(r) (((r).xqparityerrorptr[0]) & 0x7ff)
#define BCM56218_A0_XQPARITYERRORPTRr_XQPARITYERRORPTRf_SET(r,f) (r).xqparityerrorptr[0]=(((r).xqparityerrorptr[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM56218_A0_XQPARITYERRORPTRr_XQPARITYERRORPKTPTRf_GET(r) ((((r).xqparityerrorptr[0]) >> 11) & 0x3fff)
#define BCM56218_A0_XQPARITYERRORPTRr_XQPARITYERRORPKTPTRf_SET(r,f) (r).xqparityerrorptr[0]=(((r).xqparityerrorptr[0] & ~((uint32_t)0x3fff << 11)) | ((((uint32_t)f) & 0x3fff) << 11))

/*
 * These macros can be used to access XQPARITYERRORPTR.
 *
 */
#define BCM56218_A0_READ_XQPARITYERRORPTRr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_XQPARITYERRORPTRr,(r._xqparityerrorptr))
#define BCM56218_A0_WRITE_XQPARITYERRORPTRr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_XQPARITYERRORPTRr,&(r._xqparityerrorptr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XQPARITYERRORPTRr BCM56218_A0_XQPARITYERRORPTRr
#define XQPARITYERRORPTRr_SIZE BCM56218_A0_XQPARITYERRORPTRr_SIZE
typedef BCM56218_A0_XQPARITYERRORPTRr_t XQPARITYERRORPTRr_t;
#define XQPARITYERRORPTRr_CLR BCM56218_A0_XQPARITYERRORPTRr_CLR
#define XQPARITYERRORPTRr_SET BCM56218_A0_XQPARITYERRORPTRr_SET
#define XQPARITYERRORPTRr_GET BCM56218_A0_XQPARITYERRORPTRr_GET
#define XQPARITYERRORPTRr_XQPARITYERRORPTRf_GET BCM56218_A0_XQPARITYERRORPTRr_XQPARITYERRORPTRf_GET
#define XQPARITYERRORPTRr_XQPARITYERRORPTRf_SET BCM56218_A0_XQPARITYERRORPTRr_XQPARITYERRORPTRf_SET
#define XQPARITYERRORPTRr_XQPARITYERRORPKTPTRf_GET BCM56218_A0_XQPARITYERRORPTRr_XQPARITYERRORPKTPTRf_GET
#define XQPARITYERRORPTRr_XQPARITYERRORPKTPTRf_SET BCM56218_A0_XQPARITYERRORPTRr_XQPARITYERRORPKTPTRf_SET
#define READ_XQPARITYERRORPTRr BCM56218_A0_READ_XQPARITYERRORPTRr
#define WRITE_XQPARITYERRORPTRr BCM56218_A0_WRITE_XQPARITYERRORPTRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_XQPARITYERRORPTRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56218_A0
 * REGISTER:  XQREADPOINTER
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     READPOINTER      Current read address of XQ memory.
 *     COS              Currnet COS of XQ read pointer.
 *
 ******************************************************************************/
#define BCM56218_A0_XQREADPOINTERr 0x00600040

#define BCM56218_A0_XQREADPOINTERr_SIZE 4

/*
 * This structure should be used to declare and program XQREADPOINTER.
 *
 */
typedef union BCM56218_A0_XQREADPOINTERr_s {
	uint32_t v[1];
	uint32_t xqreadpointer[1];
	uint32_t _xqreadpointer;
} BCM56218_A0_XQREADPOINTERr_t;

#define BCM56218_A0_XQREADPOINTERr_CLR(r) (r).xqreadpointer[0] = 0
#define BCM56218_A0_XQREADPOINTERr_SET(r,d) (r).xqreadpointer[0] = d
#define BCM56218_A0_XQREADPOINTERr_GET(r) (r).xqreadpointer[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56218_A0_XQREADPOINTERr_READPOINTERf_GET(r) (((r).xqreadpointer[0]) & 0x7ff)
#define BCM56218_A0_XQREADPOINTERr_READPOINTERf_SET(r,f) (r).xqreadpointer[0]=(((r).xqreadpointer[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM56218_A0_XQREADPOINTERr_COSf_GET(r) ((((r).xqreadpointer[0]) >> 11) & 0x7)
#define BCM56218_A0_XQREADPOINTERr_COSf_SET(r,f) (r).xqreadpointer[0]=(((r).xqreadpointer[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11))

/*
 * These macros can be used to access XQREADPOINTER.
 *
 */
#define BCM56218_A0_READ_XQREADPOINTERr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56218_A0_XQREADPOINTERr,(r._xqreadpointer))
#define BCM56218_A0_WRITE_XQREADPOINTERr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56218_A0_XQREADPOINTERr,&(r._xqreadpointer))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XQREADPOINTERr BCM56218_A0_XQREADPOINTERr
#define XQREADPOINTERr_SIZE BCM56218_A0_XQREADPOINTERr_SIZE
typedef BCM56218_A0_XQREADPOINTERr_t XQREADPOINTERr_t;
#define XQREADPOINTERr_CLR BCM56218_A0_XQREADPOINTERr_CLR
#define XQREADPOINTERr_SET BCM56218_A0_XQREADPOINTERr_SET
#define XQREADPOINTERr_GET BCM56218_A0_XQREADPOINTERr_GET
#define XQREADPOINTERr_READPOINTERf_GET BCM56218_A0_XQREADPOINTERr_READPOINTERf_GET
#define XQREADPOINTERr_READPOINTERf_SET BCM56218_A0_XQREADPOINTERr_READPOINTERf_SET
#define XQREADPOINTERr_COSf_GET BCM56218_A0_XQREADPOINTERr_COSf_GET
#define XQREADPOINTERr_COSf_SET BCM56218_A0_XQREADPOINTERr_COSf_SET
#define READ_XQREADPOINTERr BCM56218_A0_READ_XQREADPOINTERr
#define WRITE_XQREADPOINTERr BCM56218_A0_WRITE_XQREADPOINTERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56218_A0_XQREADPOINTERr'
 ******************************************************************************/




#endif /* CDK_CONFIG_CHIP_DEFS_USE_DSYMS */
#endif /* __BCM56218_A0_DEFS_H__ */
