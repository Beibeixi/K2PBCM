#ifndef __BCM56504_A0_DEFS_H__
#define __BCM56504_A0_DEFS_H__
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated from the registers file.
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Copyright 2013 Broadcom Corporation.
 * This program is the proprietary software of Broadcom Corporation
 * and/or its licensors, and may only be used, duplicated, modified
 * or distributed pursuant to the terms and conditions of a separate,
 * written license agreement executed between you and Broadcom
 * (an "Authorized License").  Except as set forth in an Authorized
 * License, Broadcom grants no license (express or implied), right
 * to use, or waiver of any kind with respect to the Software, and
 * Broadcom expressly reserves all rights in and to the Software
 * and all intellectual property rights therein.  IF YOU HAVE
 * NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
 * IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
 * ALL USE OF THE SOFTWARE.  
 *  
 * Except as expressly set forth in the Authorized License,
 *  
 * 1.     This program, including its structure, sequence and organization,
 * constitutes the valuable trade secrets of Broadcom, and you shall use
 * all reasonable efforts to protect the confidentiality thereof,
 * and to use this information only in connection with your use of
 * Broadcom integrated circuit products.
 *  
 * 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
 * PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
 * REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
 * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
 * DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
 * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
 * ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
 * CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
 * OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
 * 
 * 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
 * BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
 * INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
 * ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
 * TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
 * THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR USD 1.00,
 * WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
 * ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
 *
 * Definition file for the BCM56504_A0.
 * This file provides all basic definitions required to program the BCM56504_A0.
 *
 ******************************************************************************/

#include <cdk/cdk_string.h>
#include <cdk/cdk_field.h>
#include <cdk/arch/xgs_reg.h>
#include <cdk/arch/xgs_mem.h>

/*******************************************************************************
 *
 *                    CHIP DEFINITIONS BEGIN HERE
 *
 ******************************************************************************/



/* CMIC physical block/port */
#define BCM56504_A0_CMIC_BLOCK          15
#define BCM56504_A0_CMIC_PORT           28

/* Additional block types */
#define BCM56504_A0_BLKTYPE_BSAFE       0
#define BCM56504_A0_BLKTYPE_CMIC        1
#define BCM56504_A0_BLKTYPE_EPIPE       2
#define BCM56504_A0_BLKTYPE_EPIPE_HI    3
#define BCM56504_A0_BLKTYPE_GPORT       4
#define BCM56504_A0_BLKTYPE_IPIPE       5
#define BCM56504_A0_BLKTYPE_IPIPE_HI    6
#define BCM56504_A0_BLKTYPE_MMU         7
#define BCM56504_A0_BLKTYPE_XPORT       8

#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_BLOCK                      BCM56504_A0_CMIC_BLOCK
#define CMIC_PORT                       BCM56504_A0_CMIC_PORT

#define BLKTYPE_BSAFE                   BCM56504_A0_BLKTYPE_BSAFE
#define BLKTYPE_CMIC                    BCM56504_A0_BLKTYPE_CMIC
#define BLKTYPE_EPIPE                   BCM56504_A0_BLKTYPE_EPIPE
#define BLKTYPE_EPIPE_HI                BCM56504_A0_BLKTYPE_EPIPE_HI
#define BLKTYPE_GPORT                   BCM56504_A0_BLKTYPE_GPORT
#define BLKTYPE_IPIPE                   BCM56504_A0_BLKTYPE_IPIPE
#define BLKTYPE_IPIPE_HI                BCM56504_A0_BLKTYPE_IPIPE_HI
#define BLKTYPE_MMU                     BCM56504_A0_BLKTYPE_MMU
#define BLKTYPE_XPORT                   BCM56504_A0_BLKTYPE_XPORT

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */



#if CDK_CONFIG_CHIP_DEFS_USE_DSYMS == 1
/* Use DSYM all_defs.h instead of static chip definitions */
#include "all_defs.h"
#else

/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  AGINGCTRMEMDEBUG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CCM              ccm registers.
 *     RM               rm registers.
 *
 ******************************************************************************/
#define BCM56504_A0_AGINGCTRMEMDEBUGr 0x0068003c

#define BCM56504_A0_AGINGCTRMEMDEBUGr_SIZE 4

/*
 * This structure should be used to declare and program AGINGCTRMEMDEBUG.
 *
 */
typedef union BCM56504_A0_AGINGCTRMEMDEBUGr_s {
	uint32_t v[1];
	uint32_t agingctrmemdebug[1];
	uint32_t _agingctrmemdebug;
} BCM56504_A0_AGINGCTRMEMDEBUGr_t;

#define BCM56504_A0_AGINGCTRMEMDEBUGr_CLR(r) (r).agingctrmemdebug[0] = 0
#define BCM56504_A0_AGINGCTRMEMDEBUGr_SET(r,d) (r).agingctrmemdebug[0] = d
#define BCM56504_A0_AGINGCTRMEMDEBUGr_GET(r) (r).agingctrmemdebug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_AGINGCTRMEMDEBUGr_CCMf_GET(r) (((r).agingctrmemdebug[0]) & 0x1)
#define BCM56504_A0_AGINGCTRMEMDEBUGr_CCMf_SET(r,f) (r).agingctrmemdebug[0]=(((r).agingctrmemdebug[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_AGINGCTRMEMDEBUGr_RMf_GET(r) ((((r).agingctrmemdebug[0]) >> 1) & 0x1)
#define BCM56504_A0_AGINGCTRMEMDEBUGr_RMf_SET(r,f) (r).agingctrmemdebug[0]=(((r).agingctrmemdebug[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access AGINGCTRMEMDEBUG.
 *
 */
#define BCM56504_A0_READ_AGINGCTRMEMDEBUGr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_AGINGCTRMEMDEBUGr,(r._agingctrmemdebug))
#define BCM56504_A0_WRITE_AGINGCTRMEMDEBUGr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_AGINGCTRMEMDEBUGr,&(r._agingctrmemdebug))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define AGINGCTRMEMDEBUGr BCM56504_A0_AGINGCTRMEMDEBUGr
#define AGINGCTRMEMDEBUGr_SIZE BCM56504_A0_AGINGCTRMEMDEBUGr_SIZE
typedef BCM56504_A0_AGINGCTRMEMDEBUGr_t AGINGCTRMEMDEBUGr_t;
#define AGINGCTRMEMDEBUGr_CLR BCM56504_A0_AGINGCTRMEMDEBUGr_CLR
#define AGINGCTRMEMDEBUGr_SET BCM56504_A0_AGINGCTRMEMDEBUGr_SET
#define AGINGCTRMEMDEBUGr_GET BCM56504_A0_AGINGCTRMEMDEBUGr_GET
#define AGINGCTRMEMDEBUGr_CCMf_GET BCM56504_A0_AGINGCTRMEMDEBUGr_CCMf_GET
#define AGINGCTRMEMDEBUGr_CCMf_SET BCM56504_A0_AGINGCTRMEMDEBUGr_CCMf_SET
#define AGINGCTRMEMDEBUGr_RMf_GET BCM56504_A0_AGINGCTRMEMDEBUGr_RMf_GET
#define AGINGCTRMEMDEBUGr_RMf_SET BCM56504_A0_AGINGCTRMEMDEBUGr_RMf_SET
#define READ_AGINGCTRMEMDEBUGr BCM56504_A0_READ_AGINGCTRMEMDEBUGr
#define WRITE_AGINGCTRMEMDEBUGr BCM56504_A0_WRITE_AGINGCTRMEMDEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_AGINGCTRMEMDEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  AGINGEXPMEMDEBUG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CCM              ccm registers.
 *     RM               rm registers.
 *
 ******************************************************************************/
#define BCM56504_A0_AGINGEXPMEMDEBUGr 0x0068003d

#define BCM56504_A0_AGINGEXPMEMDEBUGr_SIZE 4

/*
 * This structure should be used to declare and program AGINGEXPMEMDEBUG.
 *
 */
typedef union BCM56504_A0_AGINGEXPMEMDEBUGr_s {
	uint32_t v[1];
	uint32_t agingexpmemdebug[1];
	uint32_t _agingexpmemdebug;
} BCM56504_A0_AGINGEXPMEMDEBUGr_t;

#define BCM56504_A0_AGINGEXPMEMDEBUGr_CLR(r) (r).agingexpmemdebug[0] = 0
#define BCM56504_A0_AGINGEXPMEMDEBUGr_SET(r,d) (r).agingexpmemdebug[0] = d
#define BCM56504_A0_AGINGEXPMEMDEBUGr_GET(r) (r).agingexpmemdebug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_AGINGEXPMEMDEBUGr_CCMf_GET(r) (((r).agingexpmemdebug[0]) & 0x1)
#define BCM56504_A0_AGINGEXPMEMDEBUGr_CCMf_SET(r,f) (r).agingexpmemdebug[0]=(((r).agingexpmemdebug[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_AGINGEXPMEMDEBUGr_RMf_GET(r) ((((r).agingexpmemdebug[0]) >> 1) & 0x1)
#define BCM56504_A0_AGINGEXPMEMDEBUGr_RMf_SET(r,f) (r).agingexpmemdebug[0]=(((r).agingexpmemdebug[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access AGINGEXPMEMDEBUG.
 *
 */
#define BCM56504_A0_READ_AGINGEXPMEMDEBUGr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_AGINGEXPMEMDEBUGr,(r._agingexpmemdebug))
#define BCM56504_A0_WRITE_AGINGEXPMEMDEBUGr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_AGINGEXPMEMDEBUGr,&(r._agingexpmemdebug))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define AGINGEXPMEMDEBUGr BCM56504_A0_AGINGEXPMEMDEBUGr
#define AGINGEXPMEMDEBUGr_SIZE BCM56504_A0_AGINGEXPMEMDEBUGr_SIZE
typedef BCM56504_A0_AGINGEXPMEMDEBUGr_t AGINGEXPMEMDEBUGr_t;
#define AGINGEXPMEMDEBUGr_CLR BCM56504_A0_AGINGEXPMEMDEBUGr_CLR
#define AGINGEXPMEMDEBUGr_SET BCM56504_A0_AGINGEXPMEMDEBUGr_SET
#define AGINGEXPMEMDEBUGr_GET BCM56504_A0_AGINGEXPMEMDEBUGr_GET
#define AGINGEXPMEMDEBUGr_CCMf_GET BCM56504_A0_AGINGEXPMEMDEBUGr_CCMf_GET
#define AGINGEXPMEMDEBUGr_CCMf_SET BCM56504_A0_AGINGEXPMEMDEBUGr_CCMf_SET
#define AGINGEXPMEMDEBUGr_RMf_GET BCM56504_A0_AGINGEXPMEMDEBUGr_RMf_GET
#define AGINGEXPMEMDEBUGr_RMf_SET BCM56504_A0_AGINGEXPMEMDEBUGr_RMf_SET
#define READ_AGINGEXPMEMDEBUGr BCM56504_A0_READ_AGINGEXPMEMDEBUGr
#define WRITE_AGINGEXPMEMDEBUGr BCM56504_A0_WRITE_AGINGEXPMEMDEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_AGINGEXPMEMDEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  ASFCONFIG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     ASF_EN           Alternative Store and forward mode enable.When enable this bit, mmu will dispatch a packet to egress xq when recive anumber of cells specfic at ASF_CELL_NUM. This will causing a early tranmissionof a packet with less latency. 
 *     ASF_CELL_NUM     Received cell number for enabling Alternative Store and forward mode.Number of cells for early tranmission. Suggest value for ASF_CELL_NUM is 7.User can program a value from 0 upto 15. However, for programing ASF_CELL_NUM to a value below 5, asf will hold until receiving 5 cells to start.
 *
 ******************************************************************************/
#define BCM56504_A0_ASFCONFIGr 0x00680017

#define BCM56504_A0_ASFCONFIGr_SIZE 4

/*
 * This structure should be used to declare and program ASFCONFIG.
 *
 */
typedef union BCM56504_A0_ASFCONFIGr_s {
	uint32_t v[1];
	uint32_t asfconfig[1];
	uint32_t _asfconfig;
} BCM56504_A0_ASFCONFIGr_t;

#define BCM56504_A0_ASFCONFIGr_CLR(r) (r).asfconfig[0] = 0
#define BCM56504_A0_ASFCONFIGr_SET(r,d) (r).asfconfig[0] = d
#define BCM56504_A0_ASFCONFIGr_GET(r) (r).asfconfig[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_ASFCONFIGr_ASF_ENf_GET(r) (((r).asfconfig[0]) & 0x1)
#define BCM56504_A0_ASFCONFIGr_ASF_ENf_SET(r,f) (r).asfconfig[0]=(((r).asfconfig[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_ASFCONFIGr_ASF_CELL_NUMf_GET(r) ((((r).asfconfig[0]) >> 1) & 0xf)
#define BCM56504_A0_ASFCONFIGr_ASF_CELL_NUMf_SET(r,f) (r).asfconfig[0]=(((r).asfconfig[0] & ~((uint32_t)0xf << 1)) | ((((uint32_t)f) & 0xf) << 1))

/*
 * These macros can be used to access ASFCONFIG.
 *
 */
#define BCM56504_A0_READ_ASFCONFIGr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_ASFCONFIGr,(r._asfconfig))
#define BCM56504_A0_WRITE_ASFCONFIGr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_ASFCONFIGr,&(r._asfconfig))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ASFCONFIGr BCM56504_A0_ASFCONFIGr
#define ASFCONFIGr_SIZE BCM56504_A0_ASFCONFIGr_SIZE
typedef BCM56504_A0_ASFCONFIGr_t ASFCONFIGr_t;
#define ASFCONFIGr_CLR BCM56504_A0_ASFCONFIGr_CLR
#define ASFCONFIGr_SET BCM56504_A0_ASFCONFIGr_SET
#define ASFCONFIGr_GET BCM56504_A0_ASFCONFIGr_GET
#define ASFCONFIGr_ASF_ENf_GET BCM56504_A0_ASFCONFIGr_ASF_ENf_GET
#define ASFCONFIGr_ASF_ENf_SET BCM56504_A0_ASFCONFIGr_ASF_ENf_SET
#define ASFCONFIGr_ASF_CELL_NUMf_GET BCM56504_A0_ASFCONFIGr_ASF_CELL_NUMf_GET
#define ASFCONFIGr_ASF_CELL_NUMf_SET BCM56504_A0_ASFCONFIGr_ASF_CELL_NUMf_SET
#define READ_ASFCONFIGr BCM56504_A0_READ_ASFCONFIGr
#define WRITE_ASFCONFIGr BCM56504_A0_WRITE_ASFCONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_ASFCONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  ASFPORTSPEED
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     PORTSPEED        Port Speed Registers for Alternative Stored and Forward mode.3\'b000:  Port is not participating in ASF mode on both ingressing/egressing.3\'b001:  10 Mbs Half Duplex.3\'b010:  10 Mbs Full Duplex.3\'b011: 100 Mbs Half Duplex.3\'b100: 100 Mbs Full Deplex.3\'b101:   1 Gbs Full Deplex.3\'b110:  10 Gbs Full Deplex.3\'b111:  12 Gbs Full Deplex.
 *
 ******************************************************************************/
#define BCM56504_A0_ASFPORTSPEEDr 0x0060004c

#define BCM56504_A0_ASFPORTSPEEDr_SIZE 4

/*
 * This structure should be used to declare and program ASFPORTSPEED.
 *
 */
typedef union BCM56504_A0_ASFPORTSPEEDr_s {
	uint32_t v[1];
	uint32_t asfportspeed[1];
	uint32_t _asfportspeed;
} BCM56504_A0_ASFPORTSPEEDr_t;

#define BCM56504_A0_ASFPORTSPEEDr_CLR(r) (r).asfportspeed[0] = 0
#define BCM56504_A0_ASFPORTSPEEDr_SET(r,d) (r).asfportspeed[0] = d
#define BCM56504_A0_ASFPORTSPEEDr_GET(r) (r).asfportspeed[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_ASFPORTSPEEDr_PORTSPEEDf_GET(r) (((r).asfportspeed[0]) & 0x7)
#define BCM56504_A0_ASFPORTSPEEDr_PORTSPEEDf_SET(r,f) (r).asfportspeed[0]=(((r).asfportspeed[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))

/*
 * These macros can be used to access ASFPORTSPEED.
 *
 */
#define BCM56504_A0_READ_ASFPORTSPEEDr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_ASFPORTSPEEDr,(r._asfportspeed))
#define BCM56504_A0_WRITE_ASFPORTSPEEDr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_ASFPORTSPEEDr,&(r._asfportspeed))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ASFPORTSPEEDr BCM56504_A0_ASFPORTSPEEDr
#define ASFPORTSPEEDr_SIZE BCM56504_A0_ASFPORTSPEEDr_SIZE
typedef BCM56504_A0_ASFPORTSPEEDr_t ASFPORTSPEEDr_t;
#define ASFPORTSPEEDr_CLR BCM56504_A0_ASFPORTSPEEDr_CLR
#define ASFPORTSPEEDr_SET BCM56504_A0_ASFPORTSPEEDr_SET
#define ASFPORTSPEEDr_GET BCM56504_A0_ASFPORTSPEEDr_GET
#define ASFPORTSPEEDr_PORTSPEEDf_GET BCM56504_A0_ASFPORTSPEEDr_PORTSPEEDf_GET
#define ASFPORTSPEEDr_PORTSPEEDf_SET BCM56504_A0_ASFPORTSPEEDr_PORTSPEEDf_SET
#define READ_ASFPORTSPEEDr BCM56504_A0_READ_ASFPORTSPEEDr
#define WRITE_ASFPORTSPEEDr BCM56504_A0_WRITE_ASFPORTSPEEDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_ASFPORTSPEEDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  AUX_ARB_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     IP auxilary arbiter control register
 * SIZE:     32
 * FIELDS:
 *     L2_MOD_FIFO_LOCK Set to 1 to lock the L2_MOD_FIFO, clearing empties the L2_MOD_FIFO
 *     L2_MOD_FIFO_ENABLE Enables tracking the L2_MOD_FIFO, this cause learns/ages to get blocked when full
 *     FP_REFRESH_ENABLE Enables sending FP refreshes down the pipeline
 *     CLK_GRAN         clock granularity for ages (speed up for simulation use only)
 *
 ******************************************************************************/
#define BCM56504_A0_AUX_ARB_CONTROLr 0x00780000

#define BCM56504_A0_AUX_ARB_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program AUX_ARB_CONTROL.
 *
 */
typedef union BCM56504_A0_AUX_ARB_CONTROLr_s {
	uint32_t v[1];
	uint32_t aux_arb_control[1];
	uint32_t _aux_arb_control;
} BCM56504_A0_AUX_ARB_CONTROLr_t;

#define BCM56504_A0_AUX_ARB_CONTROLr_CLR(r) (r).aux_arb_control[0] = 0
#define BCM56504_A0_AUX_ARB_CONTROLr_SET(r,d) (r).aux_arb_control[0] = d
#define BCM56504_A0_AUX_ARB_CONTROLr_GET(r) (r).aux_arb_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_AUX_ARB_CONTROLr_L2_MOD_FIFO_LOCKf_GET(r) (((r).aux_arb_control[0]) & 0x1)
#define BCM56504_A0_AUX_ARB_CONTROLr_L2_MOD_FIFO_LOCKf_SET(r,f) (r).aux_arb_control[0]=(((r).aux_arb_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_AUX_ARB_CONTROLr_L2_MOD_FIFO_ENABLEf_GET(r) ((((r).aux_arb_control[0]) >> 1) & 0x1)
#define BCM56504_A0_AUX_ARB_CONTROLr_L2_MOD_FIFO_ENABLEf_SET(r,f) (r).aux_arb_control[0]=(((r).aux_arb_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_AUX_ARB_CONTROLr_FP_REFRESH_ENABLEf_GET(r) ((((r).aux_arb_control[0]) >> 2) & 0x1)
#define BCM56504_A0_AUX_ARB_CONTROLr_FP_REFRESH_ENABLEf_SET(r,f) (r).aux_arb_control[0]=(((r).aux_arb_control[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_AUX_ARB_CONTROLr_CLK_GRANf_GET(r) ((((r).aux_arb_control[0]) >> 3) & 0x3)
#define BCM56504_A0_AUX_ARB_CONTROLr_CLK_GRANf_SET(r,f) (r).aux_arb_control[0]=(((r).aux_arb_control[0] & ~((uint32_t)0x3 << 3)) | ((((uint32_t)f) & 0x3) << 3))

/*
 * These macros can be used to access AUX_ARB_CONTROL.
 *
 */
#define BCM56504_A0_READ_AUX_ARB_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_AUX_ARB_CONTROLr,(r._aux_arb_control))
#define BCM56504_A0_WRITE_AUX_ARB_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_AUX_ARB_CONTROLr,&(r._aux_arb_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define AUX_ARB_CONTROLr BCM56504_A0_AUX_ARB_CONTROLr
#define AUX_ARB_CONTROLr_SIZE BCM56504_A0_AUX_ARB_CONTROLr_SIZE
typedef BCM56504_A0_AUX_ARB_CONTROLr_t AUX_ARB_CONTROLr_t;
#define AUX_ARB_CONTROLr_CLR BCM56504_A0_AUX_ARB_CONTROLr_CLR
#define AUX_ARB_CONTROLr_SET BCM56504_A0_AUX_ARB_CONTROLr_SET
#define AUX_ARB_CONTROLr_GET BCM56504_A0_AUX_ARB_CONTROLr_GET
#define AUX_ARB_CONTROLr_L2_MOD_FIFO_LOCKf_GET BCM56504_A0_AUX_ARB_CONTROLr_L2_MOD_FIFO_LOCKf_GET
#define AUX_ARB_CONTROLr_L2_MOD_FIFO_LOCKf_SET BCM56504_A0_AUX_ARB_CONTROLr_L2_MOD_FIFO_LOCKf_SET
#define AUX_ARB_CONTROLr_L2_MOD_FIFO_ENABLEf_GET BCM56504_A0_AUX_ARB_CONTROLr_L2_MOD_FIFO_ENABLEf_GET
#define AUX_ARB_CONTROLr_L2_MOD_FIFO_ENABLEf_SET BCM56504_A0_AUX_ARB_CONTROLr_L2_MOD_FIFO_ENABLEf_SET
#define AUX_ARB_CONTROLr_FP_REFRESH_ENABLEf_GET BCM56504_A0_AUX_ARB_CONTROLr_FP_REFRESH_ENABLEf_GET
#define AUX_ARB_CONTROLr_FP_REFRESH_ENABLEf_SET BCM56504_A0_AUX_ARB_CONTROLr_FP_REFRESH_ENABLEf_SET
#define AUX_ARB_CONTROLr_CLK_GRANf_GET BCM56504_A0_AUX_ARB_CONTROLr_CLK_GRANf_GET
#define AUX_ARB_CONTROLr_CLK_GRANf_SET BCM56504_A0_AUX_ARB_CONTROLr_CLK_GRANf_SET
#define READ_AUX_ARB_CONTROLr BCM56504_A0_READ_AUX_ARB_CONTROLr
#define WRITE_AUX_ARB_CONTROLr BCM56504_A0_WRITE_AUX_ARB_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_AUX_ARB_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  BCAST_BLOCK_MASK
 * BLOCKS:   IPIPE
 * DESC:     Broadcast Block Mask
 * SIZE:     32
 * FIELDS:
 *     BLK_BITMAP       Bitmap of ports to be blocked
 *
 ******************************************************************************/
#define BCM56504_A0_BCAST_BLOCK_MASKr 0x0e700102

#define BCM56504_A0_BCAST_BLOCK_MASKr_SIZE 4

/*
 * This structure should be used to declare and program BCAST_BLOCK_MASK.
 *
 */
typedef union BCM56504_A0_BCAST_BLOCK_MASKr_s {
	uint32_t v[1];
	uint32_t bcast_block_mask[1];
	uint32_t _bcast_block_mask;
} BCM56504_A0_BCAST_BLOCK_MASKr_t;

#define BCM56504_A0_BCAST_BLOCK_MASKr_CLR(r) (r).bcast_block_mask[0] = 0
#define BCM56504_A0_BCAST_BLOCK_MASKr_SET(r,d) (r).bcast_block_mask[0] = d
#define BCM56504_A0_BCAST_BLOCK_MASKr_GET(r) (r).bcast_block_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_BCAST_BLOCK_MASKr_BLK_BITMAPf_GET(r) (((r).bcast_block_mask[0]) & 0x1fffffff)
#define BCM56504_A0_BCAST_BLOCK_MASKr_BLK_BITMAPf_SET(r,f) (r).bcast_block_mask[0]=(((r).bcast_block_mask[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))

/*
 * These macros can be used to access BCAST_BLOCK_MASK.
 *
 */
#define BCM56504_A0_READ_BCAST_BLOCK_MASKr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_BCAST_BLOCK_MASKr,(r._bcast_block_mask))
#define BCM56504_A0_WRITE_BCAST_BLOCK_MASKr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_BCAST_BLOCK_MASKr,&(r._bcast_block_mask))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BCAST_BLOCK_MASKr BCM56504_A0_BCAST_BLOCK_MASKr
#define BCAST_BLOCK_MASKr_SIZE BCM56504_A0_BCAST_BLOCK_MASKr_SIZE
typedef BCM56504_A0_BCAST_BLOCK_MASKr_t BCAST_BLOCK_MASKr_t;
#define BCAST_BLOCK_MASKr_CLR BCM56504_A0_BCAST_BLOCK_MASKr_CLR
#define BCAST_BLOCK_MASKr_SET BCM56504_A0_BCAST_BLOCK_MASKr_SET
#define BCAST_BLOCK_MASKr_GET BCM56504_A0_BCAST_BLOCK_MASKr_GET
#define BCAST_BLOCK_MASKr_BLK_BITMAPf_GET BCM56504_A0_BCAST_BLOCK_MASKr_BLK_BITMAPf_GET
#define BCAST_BLOCK_MASKr_BLK_BITMAPf_SET BCM56504_A0_BCAST_BLOCK_MASKr_BLK_BITMAPf_SET
#define READ_BCAST_BLOCK_MASKr BCM56504_A0_READ_BCAST_BLOCK_MASKr
#define WRITE_BCAST_BLOCK_MASKr BCM56504_A0_WRITE_BCAST_BLOCK_MASKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_BCAST_BLOCK_MASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  BCAST_STORM_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     Ethernet Broadcast Rate Control Registers
 * SIZE:     32
 * FIELDS:
 *     THRESHOLD        Rate Limit, count as number of packets
 *     ENABLE           Broadcast rate control enable
 *
 ******************************************************************************/
#define BCM56504_A0_BCAST_STORM_CONTROLr 0x0b700001

#define BCM56504_A0_BCAST_STORM_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program BCAST_STORM_CONTROL.
 *
 */
typedef union BCM56504_A0_BCAST_STORM_CONTROLr_s {
	uint32_t v[1];
	uint32_t bcast_storm_control[1];
	uint32_t _bcast_storm_control;
} BCM56504_A0_BCAST_STORM_CONTROLr_t;

#define BCM56504_A0_BCAST_STORM_CONTROLr_CLR(r) (r).bcast_storm_control[0] = 0
#define BCM56504_A0_BCAST_STORM_CONTROLr_SET(r,d) (r).bcast_storm_control[0] = d
#define BCM56504_A0_BCAST_STORM_CONTROLr_GET(r) (r).bcast_storm_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_BCAST_STORM_CONTROLr_THRESHOLDf_GET(r) (((r).bcast_storm_control[0]) & 0x1ffffff)
#define BCM56504_A0_BCAST_STORM_CONTROLr_THRESHOLDf_SET(r,f) (r).bcast_storm_control[0]=(((r).bcast_storm_control[0] & ~((uint32_t)0x1ffffff)) | (((uint32_t)f) & 0x1ffffff))
#define BCM56504_A0_BCAST_STORM_CONTROLr_ENABLEf_GET(r) ((((r).bcast_storm_control[0]) >> 25) & 0x1)
#define BCM56504_A0_BCAST_STORM_CONTROLr_ENABLEf_SET(r,f) (r).bcast_storm_control[0]=(((r).bcast_storm_control[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))

/*
 * These macros can be used to access BCAST_STORM_CONTROL.
 *
 */
#define BCM56504_A0_READ_BCAST_STORM_CONTROLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_BCAST_STORM_CONTROLr,(r._bcast_storm_control))
#define BCM56504_A0_WRITE_BCAST_STORM_CONTROLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_BCAST_STORM_CONTROLr,&(r._bcast_storm_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BCAST_STORM_CONTROLr BCM56504_A0_BCAST_STORM_CONTROLr
#define BCAST_STORM_CONTROLr_SIZE BCM56504_A0_BCAST_STORM_CONTROLr_SIZE
typedef BCM56504_A0_BCAST_STORM_CONTROLr_t BCAST_STORM_CONTROLr_t;
#define BCAST_STORM_CONTROLr_CLR BCM56504_A0_BCAST_STORM_CONTROLr_CLR
#define BCAST_STORM_CONTROLr_SET BCM56504_A0_BCAST_STORM_CONTROLr_SET
#define BCAST_STORM_CONTROLr_GET BCM56504_A0_BCAST_STORM_CONTROLr_GET
#define BCAST_STORM_CONTROLr_THRESHOLDf_GET BCM56504_A0_BCAST_STORM_CONTROLr_THRESHOLDf_GET
#define BCAST_STORM_CONTROLr_THRESHOLDf_SET BCM56504_A0_BCAST_STORM_CONTROLr_THRESHOLDf_SET
#define BCAST_STORM_CONTROLr_ENABLEf_GET BCM56504_A0_BCAST_STORM_CONTROLr_ENABLEf_GET
#define BCAST_STORM_CONTROLr_ENABLEf_SET BCM56504_A0_BCAST_STORM_CONTROLr_ENABLEf_SET
#define READ_BCAST_STORM_CONTROLr BCM56504_A0_READ_BCAST_STORM_CONTROLr
#define WRITE_BCAST_STORM_CONTROLr BCM56504_A0_WRITE_BCAST_STORM_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_BCAST_STORM_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  BKPMETERINGBUCKET
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     BUCKET_COUNT     Pause Metering\'s Bucket Count for each ingress port
 *     IN_PROFILE_FLAG  IN_PROFILE_FLAG inidcates the current state of Back Pressure Metering bucket1: out of profile0: In profile
 *
 ******************************************************************************/
#define BCM56504_A0_BKPMETERINGBUCKETr 0x0060000b

#define BCM56504_A0_BKPMETERINGBUCKETr_SIZE 4

/*
 * This structure should be used to declare and program BKPMETERINGBUCKET.
 *
 */
typedef union BCM56504_A0_BKPMETERINGBUCKETr_s {
	uint32_t v[1];
	uint32_t bkpmeteringbucket[1];
	uint32_t _bkpmeteringbucket;
} BCM56504_A0_BKPMETERINGBUCKETr_t;

#define BCM56504_A0_BKPMETERINGBUCKETr_CLR(r) (r).bkpmeteringbucket[0] = 0
#define BCM56504_A0_BKPMETERINGBUCKETr_SET(r,d) (r).bkpmeteringbucket[0] = d
#define BCM56504_A0_BKPMETERINGBUCKETr_GET(r) (r).bkpmeteringbucket[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_BKPMETERINGBUCKETr_BUCKET_COUNTf_GET(r) (((r).bkpmeteringbucket[0]) & 0x1fffffff)
#define BCM56504_A0_BKPMETERINGBUCKETr_BUCKET_COUNTf_SET(r,f) (r).bkpmeteringbucket[0]=(((r).bkpmeteringbucket[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM56504_A0_BKPMETERINGBUCKETr_IN_PROFILE_FLAGf_GET(r) ((((r).bkpmeteringbucket[0]) >> 29) & 0x1)
#define BCM56504_A0_BKPMETERINGBUCKETr_IN_PROFILE_FLAGf_SET(r,f) (r).bkpmeteringbucket[0]=(((r).bkpmeteringbucket[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))

/*
 * These macros can be used to access BKPMETERINGBUCKET.
 *
 */
#define BCM56504_A0_READ_BKPMETERINGBUCKETr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_BKPMETERINGBUCKETr,(r._bkpmeteringbucket))
#define BCM56504_A0_WRITE_BKPMETERINGBUCKETr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_BKPMETERINGBUCKETr,&(r._bkpmeteringbucket))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BKPMETERINGBUCKETr BCM56504_A0_BKPMETERINGBUCKETr
#define BKPMETERINGBUCKETr_SIZE BCM56504_A0_BKPMETERINGBUCKETr_SIZE
typedef BCM56504_A0_BKPMETERINGBUCKETr_t BKPMETERINGBUCKETr_t;
#define BKPMETERINGBUCKETr_CLR BCM56504_A0_BKPMETERINGBUCKETr_CLR
#define BKPMETERINGBUCKETr_SET BCM56504_A0_BKPMETERINGBUCKETr_SET
#define BKPMETERINGBUCKETr_GET BCM56504_A0_BKPMETERINGBUCKETr_GET
#define BKPMETERINGBUCKETr_BUCKET_COUNTf_GET BCM56504_A0_BKPMETERINGBUCKETr_BUCKET_COUNTf_GET
#define BKPMETERINGBUCKETr_BUCKET_COUNTf_SET BCM56504_A0_BKPMETERINGBUCKETr_BUCKET_COUNTf_SET
#define BKPMETERINGBUCKETr_IN_PROFILE_FLAGf_GET BCM56504_A0_BKPMETERINGBUCKETr_IN_PROFILE_FLAGf_GET
#define BKPMETERINGBUCKETr_IN_PROFILE_FLAGf_SET BCM56504_A0_BKPMETERINGBUCKETr_IN_PROFILE_FLAGf_SET
#define READ_BKPMETERINGBUCKETr BCM56504_A0_READ_BKPMETERINGBUCKETr
#define WRITE_BKPMETERINGBUCKETr BCM56504_A0_WRITE_BKPMETERINGBUCKETr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_BKPMETERINGBUCKETr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  BKPMETERINGCONFIG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     PAUSE_THD        Pause Threshold for start pause on pause metering of an ingress port:When Bucket Count fells below Pause Threshold, it sends out Back PressureWarning Status Message. This threshold must not over the size of Bucket Count.0x0:  Disable0x1:  32k bits. (32*1024)0x2:  64k bits. (64*1024)0x3: 128k bits. (128*1024)0x4: 256k bits. (256*1024)0x5: 512k bits. (512*1024)0x6:   1M bits. (1024*1024)0x7:   2M bits. (2*1024*1024)0x8:   4M bits. (4*1024*1024)0x9:   8M bits. (8*1024*1024)0xa:  16M bits. (16*1024*1024)0xb:  32M bits. (32*1024*1024)0xc:  64M bits. (64*1024*1024)0xd: 128M bits. (128*1024*1024)0xe: 128M bits. (128*1024*1024) setting satuated at 0xd 0xf: 128M bits. (128*1024*1024) setting satuated at 0xd
 *     RESUME_THD       Resume Threshold for resume reception on pause metering of an ingress port:When Bucket Count remain above Resume Threshold, it sends out Back PressureWarning Status Clearing Message. This threshold must not over the size of Bucket Count. 2\'b00:  75% of PAUSE_THD.2\'b01:  50% of PAUSE_THD.2\'b10:  25% of PAUSE_THD.2\'b11:  12.5% of PAUSE_THD.
 *     DISCARD_THD      Resume Threshold for discarding packet on Back Pressure Metering bucket of an ingress port:When Bucket Count remain above discard Threshold, it sends out Back PressureWarning Status Clearing Message. This threshold select if the number over PAUSE_THD. 2\'b00:  75% of PAUSE_THD above PAUSE_THD.2\'b01:  50% of PAUSE_THD above PAUSE_THD.2\'b10:  25% of PAUSE_THD above PAUSE_THD.2\'b11:  12.5% of PAUSE_THD above PAUSE_THD.
 *     REFRESHCOUNT     Refresh count for Back Pressure Metering bucket. Each unit of REFRESHrepresents 64 kbps. To use back pressure metering feature, MISCCONFIG.METERING_CLK_EN need to be set enable.
 *     BKPDISCARD_EN    Back Pressure Metering Discard Message Enable:Enable Back Pressure Warning Message to discard packet formthis ingress port when Back Pressure Metering bucket count is above Discard Threshold.   
 *
 ******************************************************************************/
#define BCM56504_A0_BKPMETERINGCONFIGr 0x0060000a

#define BCM56504_A0_BKPMETERINGCONFIGr_SIZE 4

/*
 * This structure should be used to declare and program BKPMETERINGCONFIG.
 *
 */
typedef union BCM56504_A0_BKPMETERINGCONFIGr_s {
	uint32_t v[1];
	uint32_t bkpmeteringconfig[1];
	uint32_t _bkpmeteringconfig;
} BCM56504_A0_BKPMETERINGCONFIGr_t;

#define BCM56504_A0_BKPMETERINGCONFIGr_CLR(r) (r).bkpmeteringconfig[0] = 0
#define BCM56504_A0_BKPMETERINGCONFIGr_SET(r,d) (r).bkpmeteringconfig[0] = d
#define BCM56504_A0_BKPMETERINGCONFIGr_GET(r) (r).bkpmeteringconfig[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_BKPMETERINGCONFIGr_PAUSE_THDf_GET(r) (((r).bkpmeteringconfig[0]) & 0xf)
#define BCM56504_A0_BKPMETERINGCONFIGr_PAUSE_THDf_SET(r,f) (r).bkpmeteringconfig[0]=(((r).bkpmeteringconfig[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56504_A0_BKPMETERINGCONFIGr_RESUME_THDf_GET(r) ((((r).bkpmeteringconfig[0]) >> 4) & 0x3)
#define BCM56504_A0_BKPMETERINGCONFIGr_RESUME_THDf_SET(r,f) (r).bkpmeteringconfig[0]=(((r).bkpmeteringconfig[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM56504_A0_BKPMETERINGCONFIGr_DISCARD_THDf_GET(r) ((((r).bkpmeteringconfig[0]) >> 6) & 0x3)
#define BCM56504_A0_BKPMETERINGCONFIGr_DISCARD_THDf_SET(r,f) (r).bkpmeteringconfig[0]=(((r).bkpmeteringconfig[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM56504_A0_BKPMETERINGCONFIGr_REFRESHCOUNTf_GET(r) ((((r).bkpmeteringconfig[0]) >> 8) & 0x3ffff)
#define BCM56504_A0_BKPMETERINGCONFIGr_REFRESHCOUNTf_SET(r,f) (r).bkpmeteringconfig[0]=(((r).bkpmeteringconfig[0] & ~((uint32_t)0x3ffff << 8)) | ((((uint32_t)f) & 0x3ffff) << 8))
#define BCM56504_A0_BKPMETERINGCONFIGr_BKPDISCARD_ENf_GET(r) ((((r).bkpmeteringconfig[0]) >> 26) & 0x1)
#define BCM56504_A0_BKPMETERINGCONFIGr_BKPDISCARD_ENf_SET(r,f) (r).bkpmeteringconfig[0]=(((r).bkpmeteringconfig[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))

/*
 * These macros can be used to access BKPMETERINGCONFIG.
 *
 */
#define BCM56504_A0_READ_BKPMETERINGCONFIGr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_BKPMETERINGCONFIGr,(r._bkpmeteringconfig))
#define BCM56504_A0_WRITE_BKPMETERINGCONFIGr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_BKPMETERINGCONFIGr,&(r._bkpmeteringconfig))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BKPMETERINGCONFIGr BCM56504_A0_BKPMETERINGCONFIGr
#define BKPMETERINGCONFIGr_SIZE BCM56504_A0_BKPMETERINGCONFIGr_SIZE
typedef BCM56504_A0_BKPMETERINGCONFIGr_t BKPMETERINGCONFIGr_t;
#define BKPMETERINGCONFIGr_CLR BCM56504_A0_BKPMETERINGCONFIGr_CLR
#define BKPMETERINGCONFIGr_SET BCM56504_A0_BKPMETERINGCONFIGr_SET
#define BKPMETERINGCONFIGr_GET BCM56504_A0_BKPMETERINGCONFIGr_GET
#define BKPMETERINGCONFIGr_PAUSE_THDf_GET BCM56504_A0_BKPMETERINGCONFIGr_PAUSE_THDf_GET
#define BKPMETERINGCONFIGr_PAUSE_THDf_SET BCM56504_A0_BKPMETERINGCONFIGr_PAUSE_THDf_SET
#define BKPMETERINGCONFIGr_RESUME_THDf_GET BCM56504_A0_BKPMETERINGCONFIGr_RESUME_THDf_GET
#define BKPMETERINGCONFIGr_RESUME_THDf_SET BCM56504_A0_BKPMETERINGCONFIGr_RESUME_THDf_SET
#define BKPMETERINGCONFIGr_DISCARD_THDf_GET BCM56504_A0_BKPMETERINGCONFIGr_DISCARD_THDf_GET
#define BKPMETERINGCONFIGr_DISCARD_THDf_SET BCM56504_A0_BKPMETERINGCONFIGr_DISCARD_THDf_SET
#define BKPMETERINGCONFIGr_REFRESHCOUNTf_GET BCM56504_A0_BKPMETERINGCONFIGr_REFRESHCOUNTf_GET
#define BKPMETERINGCONFIGr_REFRESHCOUNTf_SET BCM56504_A0_BKPMETERINGCONFIGr_REFRESHCOUNTf_SET
#define BKPMETERINGCONFIGr_BKPDISCARD_ENf_GET BCM56504_A0_BKPMETERINGCONFIGr_BKPDISCARD_ENf_GET
#define BKPMETERINGCONFIGr_BKPDISCARD_ENf_SET BCM56504_A0_BKPMETERINGCONFIGr_BKPDISCARD_ENf_SET
#define READ_BKPMETERINGCONFIGr BCM56504_A0_READ_BKPMETERINGCONFIGr
#define WRITE_BKPMETERINGCONFIGr BCM56504_A0_WRITE_BKPMETERINGCONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_BKPMETERINGCONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  BKPMETERINGDISCSTATUS
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     PORT_BITMAP      Current Back Pressure Metering discard status
 *
 ******************************************************************************/
#define BCM56504_A0_BKPMETERINGDISCSTATUSr 0x00680006

#define BCM56504_A0_BKPMETERINGDISCSTATUSr_SIZE 4

/*
 * This structure should be used to declare and program BKPMETERINGDISCSTATUS.
 *
 */
typedef union BCM56504_A0_BKPMETERINGDISCSTATUSr_s {
	uint32_t v[1];
	uint32_t bkpmeteringdiscstatus[1];
	uint32_t _bkpmeteringdiscstatus;
} BCM56504_A0_BKPMETERINGDISCSTATUSr_t;

#define BCM56504_A0_BKPMETERINGDISCSTATUSr_CLR(r) (r).bkpmeteringdiscstatus[0] = 0
#define BCM56504_A0_BKPMETERINGDISCSTATUSr_SET(r,d) (r).bkpmeteringdiscstatus[0] = d
#define BCM56504_A0_BKPMETERINGDISCSTATUSr_GET(r) (r).bkpmeteringdiscstatus[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_BKPMETERINGDISCSTATUSr_PORT_BITMAPf_GET(r) (((r).bkpmeteringdiscstatus[0]) & 0x1fffffff)
#define BCM56504_A0_BKPMETERINGDISCSTATUSr_PORT_BITMAPf_SET(r,f) (r).bkpmeteringdiscstatus[0]=(((r).bkpmeteringdiscstatus[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))

/*
 * These macros can be used to access BKPMETERINGDISCSTATUS.
 *
 */
#define BCM56504_A0_READ_BKPMETERINGDISCSTATUSr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_BKPMETERINGDISCSTATUSr,(r._bkpmeteringdiscstatus))
#define BCM56504_A0_WRITE_BKPMETERINGDISCSTATUSr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_BKPMETERINGDISCSTATUSr,&(r._bkpmeteringdiscstatus))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BKPMETERINGDISCSTATUSr BCM56504_A0_BKPMETERINGDISCSTATUSr
#define BKPMETERINGDISCSTATUSr_SIZE BCM56504_A0_BKPMETERINGDISCSTATUSr_SIZE
typedef BCM56504_A0_BKPMETERINGDISCSTATUSr_t BKPMETERINGDISCSTATUSr_t;
#define BKPMETERINGDISCSTATUSr_CLR BCM56504_A0_BKPMETERINGDISCSTATUSr_CLR
#define BKPMETERINGDISCSTATUSr_SET BCM56504_A0_BKPMETERINGDISCSTATUSr_SET
#define BKPMETERINGDISCSTATUSr_GET BCM56504_A0_BKPMETERINGDISCSTATUSr_GET
#define BKPMETERINGDISCSTATUSr_PORT_BITMAPf_GET BCM56504_A0_BKPMETERINGDISCSTATUSr_PORT_BITMAPf_GET
#define BKPMETERINGDISCSTATUSr_PORT_BITMAPf_SET BCM56504_A0_BKPMETERINGDISCSTATUSr_PORT_BITMAPf_SET
#define READ_BKPMETERINGDISCSTATUSr BCM56504_A0_READ_BKPMETERINGDISCSTATUSr
#define WRITE_BKPMETERINGDISCSTATUSr BCM56504_A0_WRITE_BKPMETERINGDISCSTATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_BKPMETERINGDISCSTATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  BKPMETERINGSTATUS
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     PORT_BITMAP      Current Back Pressure Metering status
 *
 ******************************************************************************/
#define BCM56504_A0_BKPMETERINGSTATUSr 0x00680003

#define BCM56504_A0_BKPMETERINGSTATUSr_SIZE 4

/*
 * This structure should be used to declare and program BKPMETERINGSTATUS.
 *
 */
typedef union BCM56504_A0_BKPMETERINGSTATUSr_s {
	uint32_t v[1];
	uint32_t bkpmeteringstatus[1];
	uint32_t _bkpmeteringstatus;
} BCM56504_A0_BKPMETERINGSTATUSr_t;

#define BCM56504_A0_BKPMETERINGSTATUSr_CLR(r) (r).bkpmeteringstatus[0] = 0
#define BCM56504_A0_BKPMETERINGSTATUSr_SET(r,d) (r).bkpmeteringstatus[0] = d
#define BCM56504_A0_BKPMETERINGSTATUSr_GET(r) (r).bkpmeteringstatus[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_BKPMETERINGSTATUSr_PORT_BITMAPf_GET(r) (((r).bkpmeteringstatus[0]) & 0x1fffffff)
#define BCM56504_A0_BKPMETERINGSTATUSr_PORT_BITMAPf_SET(r,f) (r).bkpmeteringstatus[0]=(((r).bkpmeteringstatus[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))

/*
 * These macros can be used to access BKPMETERINGSTATUS.
 *
 */
#define BCM56504_A0_READ_BKPMETERINGSTATUSr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_BKPMETERINGSTATUSr,(r._bkpmeteringstatus))
#define BCM56504_A0_WRITE_BKPMETERINGSTATUSr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_BKPMETERINGSTATUSr,&(r._bkpmeteringstatus))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BKPMETERINGSTATUSr BCM56504_A0_BKPMETERINGSTATUSr
#define BKPMETERINGSTATUSr_SIZE BCM56504_A0_BKPMETERINGSTATUSr_SIZE
typedef BCM56504_A0_BKPMETERINGSTATUSr_t BKPMETERINGSTATUSr_t;
#define BKPMETERINGSTATUSr_CLR BCM56504_A0_BKPMETERINGSTATUSr_CLR
#define BKPMETERINGSTATUSr_SET BCM56504_A0_BKPMETERINGSTATUSr_SET
#define BKPMETERINGSTATUSr_GET BCM56504_A0_BKPMETERINGSTATUSr_GET
#define BKPMETERINGSTATUSr_PORT_BITMAPf_GET BCM56504_A0_BKPMETERINGSTATUSr_PORT_BITMAPf_GET
#define BKPMETERINGSTATUSr_PORT_BITMAPf_SET BCM56504_A0_BKPMETERINGSTATUSr_PORT_BITMAPf_SET
#define READ_BKPMETERINGSTATUSr BCM56504_A0_READ_BKPMETERINGSTATUSr
#define WRITE_BKPMETERINGSTATUSr BCM56504_A0_WRITE_BKPMETERINGSTATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_BKPMETERINGSTATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  BKP_DISC_BMAP
 * BLOCKS:   IPIPE
 * DESC:     Back Pressure Discard Register
 * SIZE:     32
 * FIELDS:
 *     PORT_BITMAP      Back Pressure Discard Bitmap 
 *
 ******************************************************************************/
#define BCM56504_A0_BKP_DISC_BMAPr 0x0e78010c

#define BCM56504_A0_BKP_DISC_BMAPr_SIZE 4

/*
 * This structure should be used to declare and program BKP_DISC_BMAP.
 *
 */
typedef union BCM56504_A0_BKP_DISC_BMAPr_s {
	uint32_t v[1];
	uint32_t bkp_disc_bmap[1];
	uint32_t _bkp_disc_bmap;
} BCM56504_A0_BKP_DISC_BMAPr_t;

#define BCM56504_A0_BKP_DISC_BMAPr_CLR(r) (r).bkp_disc_bmap[0] = 0
#define BCM56504_A0_BKP_DISC_BMAPr_SET(r,d) (r).bkp_disc_bmap[0] = d
#define BCM56504_A0_BKP_DISC_BMAPr_GET(r) (r).bkp_disc_bmap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_BKP_DISC_BMAPr_PORT_BITMAPf_GET(r) (((r).bkp_disc_bmap[0]) & 0x1fffffff)
#define BCM56504_A0_BKP_DISC_BMAPr_PORT_BITMAPf_SET(r,f) (r).bkp_disc_bmap[0]=(((r).bkp_disc_bmap[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))

/*
 * These macros can be used to access BKP_DISC_BMAP.
 *
 */
#define BCM56504_A0_READ_BKP_DISC_BMAPr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_BKP_DISC_BMAPr,(r._bkp_disc_bmap))
#define BCM56504_A0_WRITE_BKP_DISC_BMAPr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_BKP_DISC_BMAPr,&(r._bkp_disc_bmap))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BKP_DISC_BMAPr BCM56504_A0_BKP_DISC_BMAPr
#define BKP_DISC_BMAPr_SIZE BCM56504_A0_BKP_DISC_BMAPr_SIZE
typedef BCM56504_A0_BKP_DISC_BMAPr_t BKP_DISC_BMAPr_t;
#define BKP_DISC_BMAPr_CLR BCM56504_A0_BKP_DISC_BMAPr_CLR
#define BKP_DISC_BMAPr_SET BCM56504_A0_BKP_DISC_BMAPr_SET
#define BKP_DISC_BMAPr_GET BCM56504_A0_BKP_DISC_BMAPr_GET
#define BKP_DISC_BMAPr_PORT_BITMAPf_GET BCM56504_A0_BKP_DISC_BMAPr_PORT_BITMAPf_GET
#define BKP_DISC_BMAPr_PORT_BITMAPf_SET BCM56504_A0_BKP_DISC_BMAPr_PORT_BITMAPf_SET
#define READ_BKP_DISC_BMAPr BCM56504_A0_READ_BKP_DISC_BMAPr
#define WRITE_BKP_DISC_BMAPr BCM56504_A0_WRITE_BKP_DISC_BMAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_BKP_DISC_BMAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  BSAFE_CMD_DATA_IN
 * BLOCKS:   BSAFE
 * DESC:     Command Data Out Register
 * SIZE:     32
 * FIELDS:
 *     CMD_DIN          Input data for command processing to the uHSM.
 *
 ******************************************************************************/
#define BCM56504_A0_BSAFE_CMD_DATA_INm 0x00b10000

#define BCM56504_A0_BSAFE_CMD_DATA_INm_MIN 0
#define BCM56504_A0_BSAFE_CMD_DATA_INm_MAX 255
#define BCM56504_A0_BSAFE_CMD_DATA_INm_CMAX(u) 255
#define BCM56504_A0_BSAFE_CMD_DATA_INm_SIZE 4

/*
 * This structure should be used to declare and program BSAFE_CMD_DATA_IN.
 *
 */
typedef union BCM56504_A0_BSAFE_CMD_DATA_INm_s {
	uint32_t v[1];
	uint32_t bsafe_cmd_data_in[1];
	uint32_t _bsafe_cmd_data_in;
} BCM56504_A0_BSAFE_CMD_DATA_INm_t;

#define BCM56504_A0_BSAFE_CMD_DATA_INm_CLR(r) (r).bsafe_cmd_data_in[0] = 0
#define BCM56504_A0_BSAFE_CMD_DATA_INm_SET(r,d) (r).bsafe_cmd_data_in[0] = d
#define BCM56504_A0_BSAFE_CMD_DATA_INm_GET(r) (r).bsafe_cmd_data_in[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_BSAFE_CMD_DATA_INm_CMD_DINf_GET(r) ((r).bsafe_cmd_data_in[0])
#define BCM56504_A0_BSAFE_CMD_DATA_INm_CMD_DINf_SET(r,f) (r).bsafe_cmd_data_in[0]=((uint32_t)f)

/*
 * These macros can be used to access BSAFE_CMD_DATA_IN.
 *
 */
#define BCM56504_A0_READ_BSAFE_CMD_DATA_INm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_BSAFE_CMD_DATA_INm,i,(m._bsafe_cmd_data_in),1)
#define BCM56504_A0_WRITE_BSAFE_CMD_DATA_INm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_BSAFE_CMD_DATA_INm,i,&(m._bsafe_cmd_data_in),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BSAFE_CMD_DATA_INm BCM56504_A0_BSAFE_CMD_DATA_INm
#define BSAFE_CMD_DATA_INm_MIN BCM56504_A0_BSAFE_CMD_DATA_INm_MIN
#define BSAFE_CMD_DATA_INm_MAX BCM56504_A0_BSAFE_CMD_DATA_INm_MAX
#define BSAFE_CMD_DATA_INm_CMAX(u) BCM56504_A0_BSAFE_CMD_DATA_INm_CMAX(u)
#define BSAFE_CMD_DATA_INm_SIZE BCM56504_A0_BSAFE_CMD_DATA_INm_SIZE
typedef BCM56504_A0_BSAFE_CMD_DATA_INm_t BSAFE_CMD_DATA_INm_t;
#define BSAFE_CMD_DATA_INm_CLR BCM56504_A0_BSAFE_CMD_DATA_INm_CLR
#define BSAFE_CMD_DATA_INm_SET BCM56504_A0_BSAFE_CMD_DATA_INm_SET
#define BSAFE_CMD_DATA_INm_GET BCM56504_A0_BSAFE_CMD_DATA_INm_GET
#define BSAFE_CMD_DATA_INm_CMD_DINf_GET BCM56504_A0_BSAFE_CMD_DATA_INm_CMD_DINf_GET
#define BSAFE_CMD_DATA_INm_CMD_DINf_SET BCM56504_A0_BSAFE_CMD_DATA_INm_CMD_DINf_SET
#define READ_BSAFE_CMD_DATA_INm BCM56504_A0_READ_BSAFE_CMD_DATA_INm
#define WRITE_BSAFE_CMD_DATA_INm BCM56504_A0_WRITE_BSAFE_CMD_DATA_INm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_BSAFE_CMD_DATA_INm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  BSAFE_CMD_DATA_OUT
 * BLOCKS:   BSAFE
 * DESC:     Command Data Out Register
 * SIZE:     32
 * FIELDS:
 *     CMD_DOUT         Output data for command processing from the uHSM.
 *
 ******************************************************************************/
#define BCM56504_A0_BSAFE_CMD_DATA_OUTm 0x00b20000

#define BCM56504_A0_BSAFE_CMD_DATA_OUTm_MIN 0
#define BCM56504_A0_BSAFE_CMD_DATA_OUTm_MAX 255
#define BCM56504_A0_BSAFE_CMD_DATA_OUTm_CMAX(u) 255
#define BCM56504_A0_BSAFE_CMD_DATA_OUTm_SIZE 4

/*
 * This structure should be used to declare and program BSAFE_CMD_DATA_OUT.
 *
 */
typedef union BCM56504_A0_BSAFE_CMD_DATA_OUTm_s {
	uint32_t v[1];
	uint32_t bsafe_cmd_data_out[1];
	uint32_t _bsafe_cmd_data_out;
} BCM56504_A0_BSAFE_CMD_DATA_OUTm_t;

#define BCM56504_A0_BSAFE_CMD_DATA_OUTm_CLR(r) (r).bsafe_cmd_data_out[0] = 0
#define BCM56504_A0_BSAFE_CMD_DATA_OUTm_SET(r,d) (r).bsafe_cmd_data_out[0] = d
#define BCM56504_A0_BSAFE_CMD_DATA_OUTm_GET(r) (r).bsafe_cmd_data_out[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_BSAFE_CMD_DATA_OUTm_CMD_DOUTf_GET(r) ((r).bsafe_cmd_data_out[0])
#define BCM56504_A0_BSAFE_CMD_DATA_OUTm_CMD_DOUTf_SET(r,f) (r).bsafe_cmd_data_out[0]=((uint32_t)f)

/*
 * These macros can be used to access BSAFE_CMD_DATA_OUT.
 *
 */
#define BCM56504_A0_READ_BSAFE_CMD_DATA_OUTm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_BSAFE_CMD_DATA_OUTm,i,(m._bsafe_cmd_data_out),1)
#define BCM56504_A0_WRITE_BSAFE_CMD_DATA_OUTm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_BSAFE_CMD_DATA_OUTm,i,&(m._bsafe_cmd_data_out),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BSAFE_CMD_DATA_OUTm BCM56504_A0_BSAFE_CMD_DATA_OUTm
#define BSAFE_CMD_DATA_OUTm_MIN BCM56504_A0_BSAFE_CMD_DATA_OUTm_MIN
#define BSAFE_CMD_DATA_OUTm_MAX BCM56504_A0_BSAFE_CMD_DATA_OUTm_MAX
#define BSAFE_CMD_DATA_OUTm_CMAX(u) BCM56504_A0_BSAFE_CMD_DATA_OUTm_CMAX(u)
#define BSAFE_CMD_DATA_OUTm_SIZE BCM56504_A0_BSAFE_CMD_DATA_OUTm_SIZE
typedef BCM56504_A0_BSAFE_CMD_DATA_OUTm_t BSAFE_CMD_DATA_OUTm_t;
#define BSAFE_CMD_DATA_OUTm_CLR BCM56504_A0_BSAFE_CMD_DATA_OUTm_CLR
#define BSAFE_CMD_DATA_OUTm_SET BCM56504_A0_BSAFE_CMD_DATA_OUTm_SET
#define BSAFE_CMD_DATA_OUTm_GET BCM56504_A0_BSAFE_CMD_DATA_OUTm_GET
#define BSAFE_CMD_DATA_OUTm_CMD_DOUTf_GET BCM56504_A0_BSAFE_CMD_DATA_OUTm_CMD_DOUTf_GET
#define BSAFE_CMD_DATA_OUTm_CMD_DOUTf_SET BCM56504_A0_BSAFE_CMD_DATA_OUTm_CMD_DOUTf_SET
#define READ_BSAFE_CMD_DATA_OUTm BCM56504_A0_READ_BSAFE_CMD_DATA_OUTm
#define WRITE_BSAFE_CMD_DATA_OUTm BCM56504_A0_WRITE_BSAFE_CMD_DATA_OUTm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_BSAFE_CMD_DATA_OUTm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  BSAFE_GLB_CMD_CTRL
 * BLOCKS:   BSAFE
 * DESC:     This register is used to control the command interface for the uHSM. The 
values in this register are used to control the GLB_CMD_DATA_IN and 
GLB_CMD_DATA_OUT data input registers.

 * SIZE:     32
 * FIELDS:
 *     CMD_IRDY         COMMAND INPUT READY: Indicates that the GLB_CMD_DATA_IN register is ready to accept data from the local interface.
 *     CMD_ISYNC        COMMAND INPUT SYNC: This bit is set high to indicate the start of a command packet to the uHSM. It is lowered to zero on the last word of the command packet.
 *     CMD_ORDY         COMMAND OUTPUT READY: Indicates that the GLB_CMD_DATA_OUT register contains valid data.
 *     CMD_OSYNC        COMMAND OUTPUT SYNC: This bit is set high by to indicate the start of a command packet response from the uHSM. It is lowered on the last word of the command packet to indicate the end of the response.
 *     RESERVED_4       Reserved.
 *     SOFT_RST         Initiates a soft reset of the uHSM block. The state of the entire block is cleared to the power on reset values.  The soft reset can be initiated by the local host via the external interface OR the master controller.
 *     GPI              General Purpose Input: The input value of the GPIO[2:0] pins.
 *     RESERVED_3       Reserved.
 *     GPO              General Purpose Output: The output value that the GPIO[2:0] are set to by the master controller.
 *     RESERVED_2       Reserved.
 *     GPEN             General Purpose Enable: Controls the enable signal on the bi-directional GPIO[2:0] pins.
 *     RESERVED_1       Reserved.
 *     REVID            The uHSM revision identification based on the RTL netlist/ROM version. This revision identifier can potentially be the same for multiple chips as it identifies the version of the uHSM only.  The uHSM master controller sets these bits from a value stored in ROM.
 *
 ******************************************************************************/
#define BCM56504_A0_BSAFE_GLB_CMD_CTRLr 0x00b80214

#define BCM56504_A0_BSAFE_GLB_CMD_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program BSAFE_GLB_CMD_CTRL.
 *
 */
typedef union BCM56504_A0_BSAFE_GLB_CMD_CTRLr_s {
	uint32_t v[1];
	uint32_t bsafe_glb_cmd_ctrl[1];
	uint32_t _bsafe_glb_cmd_ctrl;
} BCM56504_A0_BSAFE_GLB_CMD_CTRLr_t;

#define BCM56504_A0_BSAFE_GLB_CMD_CTRLr_CLR(r) (r).bsafe_glb_cmd_ctrl[0] = 0
#define BCM56504_A0_BSAFE_GLB_CMD_CTRLr_SET(r,d) (r).bsafe_glb_cmd_ctrl[0] = d
#define BCM56504_A0_BSAFE_GLB_CMD_CTRLr_GET(r) (r).bsafe_glb_cmd_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_BSAFE_GLB_CMD_CTRLr_CMD_IRDYf_GET(r) (((r).bsafe_glb_cmd_ctrl[0]) & 0x1)
#define BCM56504_A0_BSAFE_GLB_CMD_CTRLr_CMD_IRDYf_SET(r,f) (r).bsafe_glb_cmd_ctrl[0]=(((r).bsafe_glb_cmd_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_BSAFE_GLB_CMD_CTRLr_CMD_ISYNCf_GET(r) ((((r).bsafe_glb_cmd_ctrl[0]) >> 1) & 0x1)
#define BCM56504_A0_BSAFE_GLB_CMD_CTRLr_CMD_ISYNCf_SET(r,f) (r).bsafe_glb_cmd_ctrl[0]=(((r).bsafe_glb_cmd_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_BSAFE_GLB_CMD_CTRLr_CMD_ORDYf_GET(r) ((((r).bsafe_glb_cmd_ctrl[0]) >> 2) & 0x1)
#define BCM56504_A0_BSAFE_GLB_CMD_CTRLr_CMD_ORDYf_SET(r,f) (r).bsafe_glb_cmd_ctrl[0]=(((r).bsafe_glb_cmd_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_BSAFE_GLB_CMD_CTRLr_CMD_OSYNCf_GET(r) ((((r).bsafe_glb_cmd_ctrl[0]) >> 3) & 0x1)
#define BCM56504_A0_BSAFE_GLB_CMD_CTRLr_CMD_OSYNCf_SET(r,f) (r).bsafe_glb_cmd_ctrl[0]=(((r).bsafe_glb_cmd_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_BSAFE_GLB_CMD_CTRLr_RESERVED_4f_GET(r) ((((r).bsafe_glb_cmd_ctrl[0]) >> 4) & 0x7)
#define BCM56504_A0_BSAFE_GLB_CMD_CTRLr_RESERVED_4f_SET(r,f) (r).bsafe_glb_cmd_ctrl[0]=(((r).bsafe_glb_cmd_ctrl[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4))
#define BCM56504_A0_BSAFE_GLB_CMD_CTRLr_SOFT_RSTf_GET(r) ((((r).bsafe_glb_cmd_ctrl[0]) >> 7) & 0x1)
#define BCM56504_A0_BSAFE_GLB_CMD_CTRLr_SOFT_RSTf_SET(r,f) (r).bsafe_glb_cmd_ctrl[0]=(((r).bsafe_glb_cmd_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56504_A0_BSAFE_GLB_CMD_CTRLr_GPIf_GET(r) ((((r).bsafe_glb_cmd_ctrl[0]) >> 8) & 0x7)
#define BCM56504_A0_BSAFE_GLB_CMD_CTRLr_GPIf_SET(r,f) (r).bsafe_glb_cmd_ctrl[0]=(((r).bsafe_glb_cmd_ctrl[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8))
#define BCM56504_A0_BSAFE_GLB_CMD_CTRLr_RESERVED_3f_GET(r) ((((r).bsafe_glb_cmd_ctrl[0]) >> 11) & 0x1)
#define BCM56504_A0_BSAFE_GLB_CMD_CTRLr_RESERVED_3f_SET(r,f) (r).bsafe_glb_cmd_ctrl[0]=(((r).bsafe_glb_cmd_ctrl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56504_A0_BSAFE_GLB_CMD_CTRLr_GPOf_GET(r) ((((r).bsafe_glb_cmd_ctrl[0]) >> 12) & 0x7)
#define BCM56504_A0_BSAFE_GLB_CMD_CTRLr_GPOf_SET(r,f) (r).bsafe_glb_cmd_ctrl[0]=(((r).bsafe_glb_cmd_ctrl[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM56504_A0_BSAFE_GLB_CMD_CTRLr_RESERVED_2f_GET(r) ((((r).bsafe_glb_cmd_ctrl[0]) >> 15) & 0x1)
#define BCM56504_A0_BSAFE_GLB_CMD_CTRLr_RESERVED_2f_SET(r,f) (r).bsafe_glb_cmd_ctrl[0]=(((r).bsafe_glb_cmd_ctrl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56504_A0_BSAFE_GLB_CMD_CTRLr_GPENf_GET(r) ((((r).bsafe_glb_cmd_ctrl[0]) >> 16) & 0x7)
#define BCM56504_A0_BSAFE_GLB_CMD_CTRLr_GPENf_SET(r,f) (r).bsafe_glb_cmd_ctrl[0]=(((r).bsafe_glb_cmd_ctrl[0] & ~((uint32_t)0x7 << 16)) | ((((uint32_t)f) & 0x7) << 16))
#define BCM56504_A0_BSAFE_GLB_CMD_CTRLr_RESERVED_1f_GET(r) ((((r).bsafe_glb_cmd_ctrl[0]) >> 19) & 0x1f)
#define BCM56504_A0_BSAFE_GLB_CMD_CTRLr_RESERVED_1f_SET(r,f) (r).bsafe_glb_cmd_ctrl[0]=(((r).bsafe_glb_cmd_ctrl[0] & ~((uint32_t)0x1f << 19)) | ((((uint32_t)f) & 0x1f) << 19))
#define BCM56504_A0_BSAFE_GLB_CMD_CTRLr_REVIDf_GET(r) ((((r).bsafe_glb_cmd_ctrl[0]) >> 24) & 0xff)
#define BCM56504_A0_BSAFE_GLB_CMD_CTRLr_REVIDf_SET(r,f) (r).bsafe_glb_cmd_ctrl[0]=(((r).bsafe_glb_cmd_ctrl[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access BSAFE_GLB_CMD_CTRL.
 *
 */
#define BCM56504_A0_READ_BSAFE_GLB_CMD_CTRLr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_BSAFE_GLB_CMD_CTRLr,(r._bsafe_glb_cmd_ctrl))
#define BCM56504_A0_WRITE_BSAFE_GLB_CMD_CTRLr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_BSAFE_GLB_CMD_CTRLr,&(r._bsafe_glb_cmd_ctrl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BSAFE_GLB_CMD_CTRLr BCM56504_A0_BSAFE_GLB_CMD_CTRLr
#define BSAFE_GLB_CMD_CTRLr_SIZE BCM56504_A0_BSAFE_GLB_CMD_CTRLr_SIZE
typedef BCM56504_A0_BSAFE_GLB_CMD_CTRLr_t BSAFE_GLB_CMD_CTRLr_t;
#define BSAFE_GLB_CMD_CTRLr_CLR BCM56504_A0_BSAFE_GLB_CMD_CTRLr_CLR
#define BSAFE_GLB_CMD_CTRLr_SET BCM56504_A0_BSAFE_GLB_CMD_CTRLr_SET
#define BSAFE_GLB_CMD_CTRLr_GET BCM56504_A0_BSAFE_GLB_CMD_CTRLr_GET
#define BSAFE_GLB_CMD_CTRLr_CMD_IRDYf_GET BCM56504_A0_BSAFE_GLB_CMD_CTRLr_CMD_IRDYf_GET
#define BSAFE_GLB_CMD_CTRLr_CMD_IRDYf_SET BCM56504_A0_BSAFE_GLB_CMD_CTRLr_CMD_IRDYf_SET
#define BSAFE_GLB_CMD_CTRLr_CMD_ISYNCf_GET BCM56504_A0_BSAFE_GLB_CMD_CTRLr_CMD_ISYNCf_GET
#define BSAFE_GLB_CMD_CTRLr_CMD_ISYNCf_SET BCM56504_A0_BSAFE_GLB_CMD_CTRLr_CMD_ISYNCf_SET
#define BSAFE_GLB_CMD_CTRLr_CMD_ORDYf_GET BCM56504_A0_BSAFE_GLB_CMD_CTRLr_CMD_ORDYf_GET
#define BSAFE_GLB_CMD_CTRLr_CMD_ORDYf_SET BCM56504_A0_BSAFE_GLB_CMD_CTRLr_CMD_ORDYf_SET
#define BSAFE_GLB_CMD_CTRLr_CMD_OSYNCf_GET BCM56504_A0_BSAFE_GLB_CMD_CTRLr_CMD_OSYNCf_GET
#define BSAFE_GLB_CMD_CTRLr_CMD_OSYNCf_SET BCM56504_A0_BSAFE_GLB_CMD_CTRLr_CMD_OSYNCf_SET
#define BSAFE_GLB_CMD_CTRLr_RESERVED_4f_GET BCM56504_A0_BSAFE_GLB_CMD_CTRLr_RESERVED_4f_GET
#define BSAFE_GLB_CMD_CTRLr_RESERVED_4f_SET BCM56504_A0_BSAFE_GLB_CMD_CTRLr_RESERVED_4f_SET
#define BSAFE_GLB_CMD_CTRLr_SOFT_RSTf_GET BCM56504_A0_BSAFE_GLB_CMD_CTRLr_SOFT_RSTf_GET
#define BSAFE_GLB_CMD_CTRLr_SOFT_RSTf_SET BCM56504_A0_BSAFE_GLB_CMD_CTRLr_SOFT_RSTf_SET
#define BSAFE_GLB_CMD_CTRLr_GPIf_GET BCM56504_A0_BSAFE_GLB_CMD_CTRLr_GPIf_GET
#define BSAFE_GLB_CMD_CTRLr_GPIf_SET BCM56504_A0_BSAFE_GLB_CMD_CTRLr_GPIf_SET
#define BSAFE_GLB_CMD_CTRLr_RESERVED_3f_GET BCM56504_A0_BSAFE_GLB_CMD_CTRLr_RESERVED_3f_GET
#define BSAFE_GLB_CMD_CTRLr_RESERVED_3f_SET BCM56504_A0_BSAFE_GLB_CMD_CTRLr_RESERVED_3f_SET
#define BSAFE_GLB_CMD_CTRLr_GPOf_GET BCM56504_A0_BSAFE_GLB_CMD_CTRLr_GPOf_GET
#define BSAFE_GLB_CMD_CTRLr_GPOf_SET BCM56504_A0_BSAFE_GLB_CMD_CTRLr_GPOf_SET
#define BSAFE_GLB_CMD_CTRLr_RESERVED_2f_GET BCM56504_A0_BSAFE_GLB_CMD_CTRLr_RESERVED_2f_GET
#define BSAFE_GLB_CMD_CTRLr_RESERVED_2f_SET BCM56504_A0_BSAFE_GLB_CMD_CTRLr_RESERVED_2f_SET
#define BSAFE_GLB_CMD_CTRLr_GPENf_GET BCM56504_A0_BSAFE_GLB_CMD_CTRLr_GPENf_GET
#define BSAFE_GLB_CMD_CTRLr_GPENf_SET BCM56504_A0_BSAFE_GLB_CMD_CTRLr_GPENf_SET
#define BSAFE_GLB_CMD_CTRLr_RESERVED_1f_GET BCM56504_A0_BSAFE_GLB_CMD_CTRLr_RESERVED_1f_GET
#define BSAFE_GLB_CMD_CTRLr_RESERVED_1f_SET BCM56504_A0_BSAFE_GLB_CMD_CTRLr_RESERVED_1f_SET
#define BSAFE_GLB_CMD_CTRLr_REVIDf_GET BCM56504_A0_BSAFE_GLB_CMD_CTRLr_REVIDf_GET
#define BSAFE_GLB_CMD_CTRLr_REVIDf_SET BCM56504_A0_BSAFE_GLB_CMD_CTRLr_REVIDf_SET
#define READ_BSAFE_GLB_CMD_CTRLr BCM56504_A0_READ_BSAFE_GLB_CMD_CTRLr
#define WRITE_BSAFE_GLB_CMD_CTRLr BCM56504_A0_WRITE_BSAFE_GLB_CMD_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_BSAFE_GLB_CMD_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  BSAFE_GLB_CMD_DATA_IN
 * BLOCKS:   BSAFE
 * DESC:     Command Data In Register.

 * SIZE:     32
 * FIELDS:
 *     CMD_DIN          Input data for command processing to the uHSM.
 *
 ******************************************************************************/
#define BCM56504_A0_BSAFE_GLB_CMD_DATA_INr 0x00b80218

#define BCM56504_A0_BSAFE_GLB_CMD_DATA_INr_SIZE 4

/*
 * This structure should be used to declare and program BSAFE_GLB_CMD_DATA_IN.
 *
 */
typedef union BCM56504_A0_BSAFE_GLB_CMD_DATA_INr_s {
	uint32_t v[1];
	uint32_t bsafe_glb_cmd_data_in[1];
	uint32_t _bsafe_glb_cmd_data_in;
} BCM56504_A0_BSAFE_GLB_CMD_DATA_INr_t;

#define BCM56504_A0_BSAFE_GLB_CMD_DATA_INr_CLR(r) (r).bsafe_glb_cmd_data_in[0] = 0
#define BCM56504_A0_BSAFE_GLB_CMD_DATA_INr_SET(r,d) (r).bsafe_glb_cmd_data_in[0] = d
#define BCM56504_A0_BSAFE_GLB_CMD_DATA_INr_GET(r) (r).bsafe_glb_cmd_data_in[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_BSAFE_GLB_CMD_DATA_INr_CMD_DINf_GET(r) ((r).bsafe_glb_cmd_data_in[0])
#define BCM56504_A0_BSAFE_GLB_CMD_DATA_INr_CMD_DINf_SET(r,f) (r).bsafe_glb_cmd_data_in[0]=((uint32_t)f)

/*
 * These macros can be used to access BSAFE_GLB_CMD_DATA_IN.
 *
 */
#define BCM56504_A0_READ_BSAFE_GLB_CMD_DATA_INr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_BSAFE_GLB_CMD_DATA_INr,(r._bsafe_glb_cmd_data_in))
#define BCM56504_A0_WRITE_BSAFE_GLB_CMD_DATA_INr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_BSAFE_GLB_CMD_DATA_INr,&(r._bsafe_glb_cmd_data_in))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BSAFE_GLB_CMD_DATA_INr BCM56504_A0_BSAFE_GLB_CMD_DATA_INr
#define BSAFE_GLB_CMD_DATA_INr_SIZE BCM56504_A0_BSAFE_GLB_CMD_DATA_INr_SIZE
typedef BCM56504_A0_BSAFE_GLB_CMD_DATA_INr_t BSAFE_GLB_CMD_DATA_INr_t;
#define BSAFE_GLB_CMD_DATA_INr_CLR BCM56504_A0_BSAFE_GLB_CMD_DATA_INr_CLR
#define BSAFE_GLB_CMD_DATA_INr_SET BCM56504_A0_BSAFE_GLB_CMD_DATA_INr_SET
#define BSAFE_GLB_CMD_DATA_INr_GET BCM56504_A0_BSAFE_GLB_CMD_DATA_INr_GET
#define BSAFE_GLB_CMD_DATA_INr_CMD_DINf_GET BCM56504_A0_BSAFE_GLB_CMD_DATA_INr_CMD_DINf_GET
#define BSAFE_GLB_CMD_DATA_INr_CMD_DINf_SET BCM56504_A0_BSAFE_GLB_CMD_DATA_INr_CMD_DINf_SET
#define READ_BSAFE_GLB_CMD_DATA_INr BCM56504_A0_READ_BSAFE_GLB_CMD_DATA_INr
#define WRITE_BSAFE_GLB_CMD_DATA_INr BCM56504_A0_WRITE_BSAFE_GLB_CMD_DATA_INr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_BSAFE_GLB_CMD_DATA_INr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  BSAFE_GLB_CMD_DATA_OUT
 * BLOCKS:   BSAFE
 * DESC:     Command Data Out Register.

 * SIZE:     32
 * FIELDS:
 *     CMD_DIN          Output data for command processing from the uHSM.
 *
 ******************************************************************************/
#define BCM56504_A0_BSAFE_GLB_CMD_DATA_OUTr 0x00b8021c

#define BCM56504_A0_BSAFE_GLB_CMD_DATA_OUTr_SIZE 4

/*
 * This structure should be used to declare and program BSAFE_GLB_CMD_DATA_OUT.
 *
 */
typedef union BCM56504_A0_BSAFE_GLB_CMD_DATA_OUTr_s {
	uint32_t v[1];
	uint32_t bsafe_glb_cmd_data_out[1];
	uint32_t _bsafe_glb_cmd_data_out;
} BCM56504_A0_BSAFE_GLB_CMD_DATA_OUTr_t;

#define BCM56504_A0_BSAFE_GLB_CMD_DATA_OUTr_CLR(r) (r).bsafe_glb_cmd_data_out[0] = 0
#define BCM56504_A0_BSAFE_GLB_CMD_DATA_OUTr_SET(r,d) (r).bsafe_glb_cmd_data_out[0] = d
#define BCM56504_A0_BSAFE_GLB_CMD_DATA_OUTr_GET(r) (r).bsafe_glb_cmd_data_out[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_BSAFE_GLB_CMD_DATA_OUTr_CMD_DINf_GET(r) ((r).bsafe_glb_cmd_data_out[0])
#define BCM56504_A0_BSAFE_GLB_CMD_DATA_OUTr_CMD_DINf_SET(r,f) (r).bsafe_glb_cmd_data_out[0]=((uint32_t)f)

/*
 * These macros can be used to access BSAFE_GLB_CMD_DATA_OUT.
 *
 */
#define BCM56504_A0_READ_BSAFE_GLB_CMD_DATA_OUTr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_BSAFE_GLB_CMD_DATA_OUTr,(r._bsafe_glb_cmd_data_out))
#define BCM56504_A0_WRITE_BSAFE_GLB_CMD_DATA_OUTr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_BSAFE_GLB_CMD_DATA_OUTr,&(r._bsafe_glb_cmd_data_out))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BSAFE_GLB_CMD_DATA_OUTr BCM56504_A0_BSAFE_GLB_CMD_DATA_OUTr
#define BSAFE_GLB_CMD_DATA_OUTr_SIZE BCM56504_A0_BSAFE_GLB_CMD_DATA_OUTr_SIZE
typedef BCM56504_A0_BSAFE_GLB_CMD_DATA_OUTr_t BSAFE_GLB_CMD_DATA_OUTr_t;
#define BSAFE_GLB_CMD_DATA_OUTr_CLR BCM56504_A0_BSAFE_GLB_CMD_DATA_OUTr_CLR
#define BSAFE_GLB_CMD_DATA_OUTr_SET BCM56504_A0_BSAFE_GLB_CMD_DATA_OUTr_SET
#define BSAFE_GLB_CMD_DATA_OUTr_GET BCM56504_A0_BSAFE_GLB_CMD_DATA_OUTr_GET
#define BSAFE_GLB_CMD_DATA_OUTr_CMD_DINf_GET BCM56504_A0_BSAFE_GLB_CMD_DATA_OUTr_CMD_DINf_GET
#define BSAFE_GLB_CMD_DATA_OUTr_CMD_DINf_SET BCM56504_A0_BSAFE_GLB_CMD_DATA_OUTr_CMD_DINf_SET
#define READ_BSAFE_GLB_CMD_DATA_OUTr BCM56504_A0_READ_BSAFE_GLB_CMD_DATA_OUTr
#define WRITE_BSAFE_GLB_CMD_DATA_OUTr BCM56504_A0_WRITE_BSAFE_GLB_CMD_DATA_OUTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_BSAFE_GLB_CMD_DATA_OUTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  BSAFE_GLB_DEV_STATUS
 * BLOCKS:   BSAFE
 * DESC:     The status register is accessible by the local host at any time to indicate 
the current status of the uHSM. The local host must use the GLB_STATUS.BUSY 
bits to determine when it can access the data buffer via external interface.

 * SIZE:     32
 * FIELDS:
 *     BUSY             These bits lock out access to the command registers.  It indicates that the uHSM block is busy processing a command.  On reset, these bits will indicate busy until the master controller is ready to accept commands (INIT_DONE=1).
 *     INIT_KEY         Indicates directly from the security bits of the OTP array that the device keyis initialized.
 *     INIT_DONE        Indicates that initialization has competed.
 *     KS_ACTIVE        Key session setup have been completed and the session is active.
 *     RESERVED_2       Reserved.
 *     PROD_CFG_VLD     This flag is set when the prod_config register is initializedwith the value stored in NVM. Setting this flag informsthe external world that the content of theprod_config register is good to be sampled.
 *     RESERVED_1       Reserved.
 *
 ******************************************************************************/
#define BCM56504_A0_BSAFE_GLB_DEV_STATUSr 0x00b80210

#define BCM56504_A0_BSAFE_GLB_DEV_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program BSAFE_GLB_DEV_STATUS.
 *
 */
typedef union BCM56504_A0_BSAFE_GLB_DEV_STATUSr_s {
	uint32_t v[1];
	uint32_t bsafe_glb_dev_status[1];
	uint32_t _bsafe_glb_dev_status;
} BCM56504_A0_BSAFE_GLB_DEV_STATUSr_t;

#define BCM56504_A0_BSAFE_GLB_DEV_STATUSr_CLR(r) (r).bsafe_glb_dev_status[0] = 0
#define BCM56504_A0_BSAFE_GLB_DEV_STATUSr_SET(r,d) (r).bsafe_glb_dev_status[0] = d
#define BCM56504_A0_BSAFE_GLB_DEV_STATUSr_GET(r) (r).bsafe_glb_dev_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_BSAFE_GLB_DEV_STATUSr_BUSYf_GET(r) (((r).bsafe_glb_dev_status[0]) & 0x3)
#define BCM56504_A0_BSAFE_GLB_DEV_STATUSr_BUSYf_SET(r,f) (r).bsafe_glb_dev_status[0]=(((r).bsafe_glb_dev_status[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56504_A0_BSAFE_GLB_DEV_STATUSr_INIT_KEYf_GET(r) ((((r).bsafe_glb_dev_status[0]) >> 2) & 0x3)
#define BCM56504_A0_BSAFE_GLB_DEV_STATUSr_INIT_KEYf_SET(r,f) (r).bsafe_glb_dev_status[0]=(((r).bsafe_glb_dev_status[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM56504_A0_BSAFE_GLB_DEV_STATUSr_INIT_DONEf_GET(r) ((((r).bsafe_glb_dev_status[0]) >> 4) & 0x1)
#define BCM56504_A0_BSAFE_GLB_DEV_STATUSr_INIT_DONEf_SET(r,f) (r).bsafe_glb_dev_status[0]=(((r).bsafe_glb_dev_status[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56504_A0_BSAFE_GLB_DEV_STATUSr_KS_ACTIVEf_GET(r) ((((r).bsafe_glb_dev_status[0]) >> 5) & 0x1)
#define BCM56504_A0_BSAFE_GLB_DEV_STATUSr_KS_ACTIVEf_SET(r,f) (r).bsafe_glb_dev_status[0]=(((r).bsafe_glb_dev_status[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56504_A0_BSAFE_GLB_DEV_STATUSr_RESERVED_2f_GET(r) ((((r).bsafe_glb_dev_status[0]) >> 6) & 0x1)
#define BCM56504_A0_BSAFE_GLB_DEV_STATUSr_RESERVED_2f_SET(r,f) (r).bsafe_glb_dev_status[0]=(((r).bsafe_glb_dev_status[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56504_A0_BSAFE_GLB_DEV_STATUSr_PROD_CFG_VLDf_GET(r) ((((r).bsafe_glb_dev_status[0]) >> 7) & 0x1)
#define BCM56504_A0_BSAFE_GLB_DEV_STATUSr_PROD_CFG_VLDf_SET(r,f) (r).bsafe_glb_dev_status[0]=(((r).bsafe_glb_dev_status[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56504_A0_BSAFE_GLB_DEV_STATUSr_RESERVED_1f_GET(r) ((((r).bsafe_glb_dev_status[0]) >> 8) & 0xffffff)
#define BCM56504_A0_BSAFE_GLB_DEV_STATUSr_RESERVED_1f_SET(r,f) (r).bsafe_glb_dev_status[0]=(((r).bsafe_glb_dev_status[0] & ~((uint32_t)0xffffff << 8)) | ((((uint32_t)f) & 0xffffff) << 8))

/*
 * These macros can be used to access BSAFE_GLB_DEV_STATUS.
 *
 */
#define BCM56504_A0_READ_BSAFE_GLB_DEV_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_BSAFE_GLB_DEV_STATUSr,(r._bsafe_glb_dev_status))
#define BCM56504_A0_WRITE_BSAFE_GLB_DEV_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_BSAFE_GLB_DEV_STATUSr,&(r._bsafe_glb_dev_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BSAFE_GLB_DEV_STATUSr BCM56504_A0_BSAFE_GLB_DEV_STATUSr
#define BSAFE_GLB_DEV_STATUSr_SIZE BCM56504_A0_BSAFE_GLB_DEV_STATUSr_SIZE
typedef BCM56504_A0_BSAFE_GLB_DEV_STATUSr_t BSAFE_GLB_DEV_STATUSr_t;
#define BSAFE_GLB_DEV_STATUSr_CLR BCM56504_A0_BSAFE_GLB_DEV_STATUSr_CLR
#define BSAFE_GLB_DEV_STATUSr_SET BCM56504_A0_BSAFE_GLB_DEV_STATUSr_SET
#define BSAFE_GLB_DEV_STATUSr_GET BCM56504_A0_BSAFE_GLB_DEV_STATUSr_GET
#define BSAFE_GLB_DEV_STATUSr_BUSYf_GET BCM56504_A0_BSAFE_GLB_DEV_STATUSr_BUSYf_GET
#define BSAFE_GLB_DEV_STATUSr_BUSYf_SET BCM56504_A0_BSAFE_GLB_DEV_STATUSr_BUSYf_SET
#define BSAFE_GLB_DEV_STATUSr_INIT_KEYf_GET BCM56504_A0_BSAFE_GLB_DEV_STATUSr_INIT_KEYf_GET
#define BSAFE_GLB_DEV_STATUSr_INIT_KEYf_SET BCM56504_A0_BSAFE_GLB_DEV_STATUSr_INIT_KEYf_SET
#define BSAFE_GLB_DEV_STATUSr_INIT_DONEf_GET BCM56504_A0_BSAFE_GLB_DEV_STATUSr_INIT_DONEf_GET
#define BSAFE_GLB_DEV_STATUSr_INIT_DONEf_SET BCM56504_A0_BSAFE_GLB_DEV_STATUSr_INIT_DONEf_SET
#define BSAFE_GLB_DEV_STATUSr_KS_ACTIVEf_GET BCM56504_A0_BSAFE_GLB_DEV_STATUSr_KS_ACTIVEf_GET
#define BSAFE_GLB_DEV_STATUSr_KS_ACTIVEf_SET BCM56504_A0_BSAFE_GLB_DEV_STATUSr_KS_ACTIVEf_SET
#define BSAFE_GLB_DEV_STATUSr_RESERVED_2f_GET BCM56504_A0_BSAFE_GLB_DEV_STATUSr_RESERVED_2f_GET
#define BSAFE_GLB_DEV_STATUSr_RESERVED_2f_SET BCM56504_A0_BSAFE_GLB_DEV_STATUSr_RESERVED_2f_SET
#define BSAFE_GLB_DEV_STATUSr_PROD_CFG_VLDf_GET BCM56504_A0_BSAFE_GLB_DEV_STATUSr_PROD_CFG_VLDf_GET
#define BSAFE_GLB_DEV_STATUSr_PROD_CFG_VLDf_SET BCM56504_A0_BSAFE_GLB_DEV_STATUSr_PROD_CFG_VLDf_SET
#define BSAFE_GLB_DEV_STATUSr_RESERVED_1f_GET BCM56504_A0_BSAFE_GLB_DEV_STATUSr_RESERVED_1f_GET
#define BSAFE_GLB_DEV_STATUSr_RESERVED_1f_SET BCM56504_A0_BSAFE_GLB_DEV_STATUSr_RESERVED_1f_SET
#define READ_BSAFE_GLB_DEV_STATUSr BCM56504_A0_READ_BSAFE_GLB_DEV_STATUSr
#define WRITE_BSAFE_GLB_DEV_STATUSr BCM56504_A0_WRITE_BSAFE_GLB_DEV_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_BSAFE_GLB_DEV_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  BSAFE_GLB_INT_CTRL
 * BLOCKS:   BSAFE
 * DESC:     Command Data Out Register.

 * SIZE:     32
 * FIELDS:
 *     SRC_CDONE        COMMAND DONE: Indicates that the uHSM has completed a command.
 *     SRC_CERR         COMMAND ERROR: Indicates that the uHSM has completed a command that returns a non-zero returnCode.
 *     SRC_RDY          READY: Indicates that the uHSM is ready to accept a command.
 *     RESERVED_3       Reserved.
 *     SRC_SAL          SECURITY ASSURANCE LOGIC: Indicates that the SAL has triggered an interrupt. The SAL status register should be read for more information.
 *     RESERVED_2       Reserved.
 *     INT_SRC_EN       INTERRUPT SOURCE ENABLE: The interrupt mask register. Each bit corresponds to an individual interrupt source defined in SRC_xxxx[3:0]
 *     RESERVED_1       Reserved.
 *
 ******************************************************************************/
#define BCM56504_A0_BSAFE_GLB_INT_CTRLr 0x00b80220

#define BCM56504_A0_BSAFE_GLB_INT_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program BSAFE_GLB_INT_CTRL.
 *
 */
typedef union BCM56504_A0_BSAFE_GLB_INT_CTRLr_s {
	uint32_t v[1];
	uint32_t bsafe_glb_int_ctrl[1];
	uint32_t _bsafe_glb_int_ctrl;
} BCM56504_A0_BSAFE_GLB_INT_CTRLr_t;

#define BCM56504_A0_BSAFE_GLB_INT_CTRLr_CLR(r) (r).bsafe_glb_int_ctrl[0] = 0
#define BCM56504_A0_BSAFE_GLB_INT_CTRLr_SET(r,d) (r).bsafe_glb_int_ctrl[0] = d
#define BCM56504_A0_BSAFE_GLB_INT_CTRLr_GET(r) (r).bsafe_glb_int_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_BSAFE_GLB_INT_CTRLr_SRC_CDONEf_GET(r) (((r).bsafe_glb_int_ctrl[0]) & 0x1)
#define BCM56504_A0_BSAFE_GLB_INT_CTRLr_SRC_CDONEf_SET(r,f) (r).bsafe_glb_int_ctrl[0]=(((r).bsafe_glb_int_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_BSAFE_GLB_INT_CTRLr_SRC_CERRf_GET(r) ((((r).bsafe_glb_int_ctrl[0]) >> 1) & 0x1)
#define BCM56504_A0_BSAFE_GLB_INT_CTRLr_SRC_CERRf_SET(r,f) (r).bsafe_glb_int_ctrl[0]=(((r).bsafe_glb_int_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_BSAFE_GLB_INT_CTRLr_SRC_RDYf_GET(r) ((((r).bsafe_glb_int_ctrl[0]) >> 2) & 0x1)
#define BCM56504_A0_BSAFE_GLB_INT_CTRLr_SRC_RDYf_SET(r,f) (r).bsafe_glb_int_ctrl[0]=(((r).bsafe_glb_int_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_BSAFE_GLB_INT_CTRLr_RESERVED_3f_GET(r) ((((r).bsafe_glb_int_ctrl[0]) >> 3) & 0x1)
#define BCM56504_A0_BSAFE_GLB_INT_CTRLr_RESERVED_3f_SET(r,f) (r).bsafe_glb_int_ctrl[0]=(((r).bsafe_glb_int_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_BSAFE_GLB_INT_CTRLr_SRC_SALf_GET(r) ((((r).bsafe_glb_int_ctrl[0]) >> 4) & 0x1)
#define BCM56504_A0_BSAFE_GLB_INT_CTRLr_SRC_SALf_SET(r,f) (r).bsafe_glb_int_ctrl[0]=(((r).bsafe_glb_int_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56504_A0_BSAFE_GLB_INT_CTRLr_RESERVED_2f_GET(r) ((((r).bsafe_glb_int_ctrl[0]) >> 5) & 0x7)
#define BCM56504_A0_BSAFE_GLB_INT_CTRLr_RESERVED_2f_SET(r,f) (r).bsafe_glb_int_ctrl[0]=(((r).bsafe_glb_int_ctrl[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))
#define BCM56504_A0_BSAFE_GLB_INT_CTRLr_INT_SRC_ENf_GET(r) ((((r).bsafe_glb_int_ctrl[0]) >> 8) & 0x1f)
#define BCM56504_A0_BSAFE_GLB_INT_CTRLr_INT_SRC_ENf_SET(r,f) (r).bsafe_glb_int_ctrl[0]=(((r).bsafe_glb_int_ctrl[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56504_A0_BSAFE_GLB_INT_CTRLr_RESERVED_1f_GET(r) ((((r).bsafe_glb_int_ctrl[0]) >> 13) & 0x7ffff)
#define BCM56504_A0_BSAFE_GLB_INT_CTRLr_RESERVED_1f_SET(r,f) (r).bsafe_glb_int_ctrl[0]=(((r).bsafe_glb_int_ctrl[0] & ~((uint32_t)0x7ffff << 13)) | ((((uint32_t)f) & 0x7ffff) << 13))

/*
 * These macros can be used to access BSAFE_GLB_INT_CTRL.
 *
 */
#define BCM56504_A0_READ_BSAFE_GLB_INT_CTRLr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_BSAFE_GLB_INT_CTRLr,(r._bsafe_glb_int_ctrl))
#define BCM56504_A0_WRITE_BSAFE_GLB_INT_CTRLr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_BSAFE_GLB_INT_CTRLr,&(r._bsafe_glb_int_ctrl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BSAFE_GLB_INT_CTRLr BCM56504_A0_BSAFE_GLB_INT_CTRLr
#define BSAFE_GLB_INT_CTRLr_SIZE BCM56504_A0_BSAFE_GLB_INT_CTRLr_SIZE
typedef BCM56504_A0_BSAFE_GLB_INT_CTRLr_t BSAFE_GLB_INT_CTRLr_t;
#define BSAFE_GLB_INT_CTRLr_CLR BCM56504_A0_BSAFE_GLB_INT_CTRLr_CLR
#define BSAFE_GLB_INT_CTRLr_SET BCM56504_A0_BSAFE_GLB_INT_CTRLr_SET
#define BSAFE_GLB_INT_CTRLr_GET BCM56504_A0_BSAFE_GLB_INT_CTRLr_GET
#define BSAFE_GLB_INT_CTRLr_SRC_CDONEf_GET BCM56504_A0_BSAFE_GLB_INT_CTRLr_SRC_CDONEf_GET
#define BSAFE_GLB_INT_CTRLr_SRC_CDONEf_SET BCM56504_A0_BSAFE_GLB_INT_CTRLr_SRC_CDONEf_SET
#define BSAFE_GLB_INT_CTRLr_SRC_CERRf_GET BCM56504_A0_BSAFE_GLB_INT_CTRLr_SRC_CERRf_GET
#define BSAFE_GLB_INT_CTRLr_SRC_CERRf_SET BCM56504_A0_BSAFE_GLB_INT_CTRLr_SRC_CERRf_SET
#define BSAFE_GLB_INT_CTRLr_SRC_RDYf_GET BCM56504_A0_BSAFE_GLB_INT_CTRLr_SRC_RDYf_GET
#define BSAFE_GLB_INT_CTRLr_SRC_RDYf_SET BCM56504_A0_BSAFE_GLB_INT_CTRLr_SRC_RDYf_SET
#define BSAFE_GLB_INT_CTRLr_RESERVED_3f_GET BCM56504_A0_BSAFE_GLB_INT_CTRLr_RESERVED_3f_GET
#define BSAFE_GLB_INT_CTRLr_RESERVED_3f_SET BCM56504_A0_BSAFE_GLB_INT_CTRLr_RESERVED_3f_SET
#define BSAFE_GLB_INT_CTRLr_SRC_SALf_GET BCM56504_A0_BSAFE_GLB_INT_CTRLr_SRC_SALf_GET
#define BSAFE_GLB_INT_CTRLr_SRC_SALf_SET BCM56504_A0_BSAFE_GLB_INT_CTRLr_SRC_SALf_SET
#define BSAFE_GLB_INT_CTRLr_RESERVED_2f_GET BCM56504_A0_BSAFE_GLB_INT_CTRLr_RESERVED_2f_GET
#define BSAFE_GLB_INT_CTRLr_RESERVED_2f_SET BCM56504_A0_BSAFE_GLB_INT_CTRLr_RESERVED_2f_SET
#define BSAFE_GLB_INT_CTRLr_INT_SRC_ENf_GET BCM56504_A0_BSAFE_GLB_INT_CTRLr_INT_SRC_ENf_GET
#define BSAFE_GLB_INT_CTRLr_INT_SRC_ENf_SET BCM56504_A0_BSAFE_GLB_INT_CTRLr_INT_SRC_ENf_SET
#define BSAFE_GLB_INT_CTRLr_RESERVED_1f_GET BCM56504_A0_BSAFE_GLB_INT_CTRLr_RESERVED_1f_GET
#define BSAFE_GLB_INT_CTRLr_RESERVED_1f_SET BCM56504_A0_BSAFE_GLB_INT_CTRLr_RESERVED_1f_SET
#define READ_BSAFE_GLB_INT_CTRLr BCM56504_A0_READ_BSAFE_GLB_INT_CTRLr
#define WRITE_BSAFE_GLB_INT_CTRLr BCM56504_A0_WRITE_BSAFE_GLB_INT_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_BSAFE_GLB_INT_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  BSAFE_GLB_PRESCALE
 * BLOCKS:   BSAFE
 * DESC:     The reference clock (refclk) input is pre-scaled to provide a nominal 1 second 
clock tick used to increment the GLB_TIMER register. The reference clock is 
divided by four in the reference clock domain, then synchronized to the core 
clock domain.  The core clock input must be equal to or greater than the 
reference clock input for all frequencies. The divide by four ensures that 
the reference clock is sampled properly. Therefore, the time tick is calculated
as follows: period = (refclk period * PRESCALE * 4)
When the refclk is 6.25MHz, the prescalar should have the value 0x17D784. When 
the refclk is 62.5MHz, the prescalar should have the value 0xEE6B28.
This register is write-once protected. It can only be written one time
by an sbus write access. Further write attempts are ignored by uHSM.

 * SIZE:     32
 * FIELDS:
 *     PRESCALE         Pre-scalar value for the system time tick. The defaultvalue assumes a 6.25MHz reference system clock input.The value of this register can only be initialized onceafter each hardware reset. Subsequent write operations tothis register through the register access interface will nothave any effect.
 *     RESERVED_1       Reserved.
 *
 ******************************************************************************/
#define BCM56504_A0_BSAFE_GLB_PRESCALEr 0x00b80204

#define BCM56504_A0_BSAFE_GLB_PRESCALEr_SIZE 4

/*
 * This structure should be used to declare and program BSAFE_GLB_PRESCALE.
 *
 */
typedef union BCM56504_A0_BSAFE_GLB_PRESCALEr_s {
	uint32_t v[1];
	uint32_t bsafe_glb_prescale[1];
	uint32_t _bsafe_glb_prescale;
} BCM56504_A0_BSAFE_GLB_PRESCALEr_t;

#define BCM56504_A0_BSAFE_GLB_PRESCALEr_CLR(r) (r).bsafe_glb_prescale[0] = 0
#define BCM56504_A0_BSAFE_GLB_PRESCALEr_SET(r,d) (r).bsafe_glb_prescale[0] = d
#define BCM56504_A0_BSAFE_GLB_PRESCALEr_GET(r) (r).bsafe_glb_prescale[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_BSAFE_GLB_PRESCALEr_PRESCALEf_GET(r) (((r).bsafe_glb_prescale[0]) & 0xffffff)
#define BCM56504_A0_BSAFE_GLB_PRESCALEr_PRESCALEf_SET(r,f) (r).bsafe_glb_prescale[0]=(((r).bsafe_glb_prescale[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))
#define BCM56504_A0_BSAFE_GLB_PRESCALEr_RESERVED_1f_GET(r) ((((r).bsafe_glb_prescale[0]) >> 24) & 0xff)
#define BCM56504_A0_BSAFE_GLB_PRESCALEr_RESERVED_1f_SET(r,f) (r).bsafe_glb_prescale[0]=(((r).bsafe_glb_prescale[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access BSAFE_GLB_PRESCALE.
 *
 */
#define BCM56504_A0_READ_BSAFE_GLB_PRESCALEr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_BSAFE_GLB_PRESCALEr,(r._bsafe_glb_prescale))
#define BCM56504_A0_WRITE_BSAFE_GLB_PRESCALEr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_BSAFE_GLB_PRESCALEr,&(r._bsafe_glb_prescale))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BSAFE_GLB_PRESCALEr BCM56504_A0_BSAFE_GLB_PRESCALEr
#define BSAFE_GLB_PRESCALEr_SIZE BCM56504_A0_BSAFE_GLB_PRESCALEr_SIZE
typedef BCM56504_A0_BSAFE_GLB_PRESCALEr_t BSAFE_GLB_PRESCALEr_t;
#define BSAFE_GLB_PRESCALEr_CLR BCM56504_A0_BSAFE_GLB_PRESCALEr_CLR
#define BSAFE_GLB_PRESCALEr_SET BCM56504_A0_BSAFE_GLB_PRESCALEr_SET
#define BSAFE_GLB_PRESCALEr_GET BCM56504_A0_BSAFE_GLB_PRESCALEr_GET
#define BSAFE_GLB_PRESCALEr_PRESCALEf_GET BCM56504_A0_BSAFE_GLB_PRESCALEr_PRESCALEf_GET
#define BSAFE_GLB_PRESCALEr_PRESCALEf_SET BCM56504_A0_BSAFE_GLB_PRESCALEr_PRESCALEf_SET
#define BSAFE_GLB_PRESCALEr_RESERVED_1f_GET BCM56504_A0_BSAFE_GLB_PRESCALEr_RESERVED_1f_GET
#define BSAFE_GLB_PRESCALEr_RESERVED_1f_SET BCM56504_A0_BSAFE_GLB_PRESCALEr_RESERVED_1f_SET
#define READ_BSAFE_GLB_PRESCALEr BCM56504_A0_READ_BSAFE_GLB_PRESCALEr
#define WRITE_BSAFE_GLB_PRESCALEr BCM56504_A0_WRITE_BSAFE_GLB_PRESCALEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_BSAFE_GLB_PRESCALEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  BSAFE_GLB_PROD_CFG
 * BLOCKS:   BSAFE
 * DESC:     The device configuration register allows the system to be configured securely 
by the HSM. For example, a higher performance capability can be shipped 
disabled, then upgraded via a secure communication message in the field to 
increase perforamnce.  These bits would be used to disable the feature or 
performance capability in the system (or on chip).  Upon each power on reset 
or hardware reset of the uHSM, the embedded microcontroller will read the 
default initial value of this register from the NVM and set the register 
content. The register content can be subsequently updated via uHSM_LD_CFG 
command. The functionality of the uHSM is determined by the current value of 
the register.  The content of this register is brought out to the uHSM 
interface so that external system hardware can be configured.

 * SIZE:     32
 * FIELDS:
 *     PROD_CFG         The secure product configuration values. The usage is system dependent for eachbit.  The initial values of these bits are set via the "uHSM_INIT_DEVICEKEY (uhsm_config, prod_config, authorization)" command in the "configuration" input field. The values of these bits can be changed in-field by a manufacturer's authorized signature.
 *
 ******************************************************************************/
#define BCM56504_A0_BSAFE_GLB_PROD_CFGr 0x00b8020c

#define BCM56504_A0_BSAFE_GLB_PROD_CFGr_SIZE 4

/*
 * This structure should be used to declare and program BSAFE_GLB_PROD_CFG.
 *
 */
typedef union BCM56504_A0_BSAFE_GLB_PROD_CFGr_s {
	uint32_t v[1];
	uint32_t bsafe_glb_prod_cfg[1];
	uint32_t _bsafe_glb_prod_cfg;
} BCM56504_A0_BSAFE_GLB_PROD_CFGr_t;

#define BCM56504_A0_BSAFE_GLB_PROD_CFGr_CLR(r) (r).bsafe_glb_prod_cfg[0] = 0
#define BCM56504_A0_BSAFE_GLB_PROD_CFGr_SET(r,d) (r).bsafe_glb_prod_cfg[0] = d
#define BCM56504_A0_BSAFE_GLB_PROD_CFGr_GET(r) (r).bsafe_glb_prod_cfg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_BSAFE_GLB_PROD_CFGr_PROD_CFGf_GET(r) ((r).bsafe_glb_prod_cfg[0])
#define BCM56504_A0_BSAFE_GLB_PROD_CFGr_PROD_CFGf_SET(r,f) (r).bsafe_glb_prod_cfg[0]=((uint32_t)f)

/*
 * These macros can be used to access BSAFE_GLB_PROD_CFG.
 *
 */
#define BCM56504_A0_READ_BSAFE_GLB_PROD_CFGr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_BSAFE_GLB_PROD_CFGr,(r._bsafe_glb_prod_cfg))
#define BCM56504_A0_WRITE_BSAFE_GLB_PROD_CFGr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_BSAFE_GLB_PROD_CFGr,&(r._bsafe_glb_prod_cfg))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BSAFE_GLB_PROD_CFGr BCM56504_A0_BSAFE_GLB_PROD_CFGr
#define BSAFE_GLB_PROD_CFGr_SIZE BCM56504_A0_BSAFE_GLB_PROD_CFGr_SIZE
typedef BCM56504_A0_BSAFE_GLB_PROD_CFGr_t BSAFE_GLB_PROD_CFGr_t;
#define BSAFE_GLB_PROD_CFGr_CLR BCM56504_A0_BSAFE_GLB_PROD_CFGr_CLR
#define BSAFE_GLB_PROD_CFGr_SET BCM56504_A0_BSAFE_GLB_PROD_CFGr_SET
#define BSAFE_GLB_PROD_CFGr_GET BCM56504_A0_BSAFE_GLB_PROD_CFGr_GET
#define BSAFE_GLB_PROD_CFGr_PROD_CFGf_GET BCM56504_A0_BSAFE_GLB_PROD_CFGr_PROD_CFGf_GET
#define BSAFE_GLB_PROD_CFGr_PROD_CFGf_SET BCM56504_A0_BSAFE_GLB_PROD_CFGr_PROD_CFGf_SET
#define READ_BSAFE_GLB_PROD_CFGr BCM56504_A0_READ_BSAFE_GLB_PROD_CFGr
#define WRITE_BSAFE_GLB_PROD_CFGr BCM56504_A0_WRITE_BSAFE_GLB_PROD_CFGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_BSAFE_GLB_PROD_CFGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  BSAFE_GLB_TIMER
 * BLOCKS:   BSAFE
 * DESC:     System Time Register.
The timer register is used to determine when time based keys are expired
by the uHSM. The time tick is stored in this register and is set to zero 
at reset. The time tick increments in one second increments continuously 
from reset.
The value of this register can only be initialized once
after each hardware reset. Subsequent write operations to
this register through the register access interface will not
have any effect.

 * SIZE:     32
 * FIELDS:
 *     TIME_TICK        The relative time tick register. This register is disabled at reset. It remains at zero, until it is being programmed to a non-zero value.The value of this registers can only be initialized once after each hardware reset. Subsequent write operations to this register through the register access interface will not have any effect.This field is write-once protected. It can only be written one timeby an sbus write access. Further write attempts are ignored by uHSM.
 *
 ******************************************************************************/
#define BCM56504_A0_BSAFE_GLB_TIMERr 0x00b80200

#define BCM56504_A0_BSAFE_GLB_TIMERr_SIZE 4

/*
 * This structure should be used to declare and program BSAFE_GLB_TIMER.
 *
 */
typedef union BCM56504_A0_BSAFE_GLB_TIMERr_s {
	uint32_t v[1];
	uint32_t bsafe_glb_timer[1];
	uint32_t _bsafe_glb_timer;
} BCM56504_A0_BSAFE_GLB_TIMERr_t;

#define BCM56504_A0_BSAFE_GLB_TIMERr_CLR(r) (r).bsafe_glb_timer[0] = 0
#define BCM56504_A0_BSAFE_GLB_TIMERr_SET(r,d) (r).bsafe_glb_timer[0] = d
#define BCM56504_A0_BSAFE_GLB_TIMERr_GET(r) (r).bsafe_glb_timer[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_BSAFE_GLB_TIMERr_TIME_TICKf_GET(r) ((r).bsafe_glb_timer[0])
#define BCM56504_A0_BSAFE_GLB_TIMERr_TIME_TICKf_SET(r,f) (r).bsafe_glb_timer[0]=((uint32_t)f)

/*
 * These macros can be used to access BSAFE_GLB_TIMER.
 *
 */
#define BCM56504_A0_READ_BSAFE_GLB_TIMERr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_BSAFE_GLB_TIMERr,(r._bsafe_glb_timer))
#define BCM56504_A0_WRITE_BSAFE_GLB_TIMERr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_BSAFE_GLB_TIMERr,&(r._bsafe_glb_timer))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BSAFE_GLB_TIMERr BCM56504_A0_BSAFE_GLB_TIMERr
#define BSAFE_GLB_TIMERr_SIZE BCM56504_A0_BSAFE_GLB_TIMERr_SIZE
typedef BCM56504_A0_BSAFE_GLB_TIMERr_t BSAFE_GLB_TIMERr_t;
#define BSAFE_GLB_TIMERr_CLR BCM56504_A0_BSAFE_GLB_TIMERr_CLR
#define BSAFE_GLB_TIMERr_SET BCM56504_A0_BSAFE_GLB_TIMERr_SET
#define BSAFE_GLB_TIMERr_GET BCM56504_A0_BSAFE_GLB_TIMERr_GET
#define BSAFE_GLB_TIMERr_TIME_TICKf_GET BCM56504_A0_BSAFE_GLB_TIMERr_TIME_TICKf_GET
#define BSAFE_GLB_TIMERr_TIME_TICKf_SET BCM56504_A0_BSAFE_GLB_TIMERr_TIME_TICKf_SET
#define READ_BSAFE_GLB_TIMERr BCM56504_A0_READ_BSAFE_GLB_TIMERr
#define WRITE_BSAFE_GLB_TIMERr BCM56504_A0_WRITE_BSAFE_GLB_TIMERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_BSAFE_GLB_TIMERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  BSAFE_GLB_UHSM_CFG
 * BLOCKS:   BSAFE
 * DESC:     The uHSM configuration register allows the uHSM to be configured securely by 
the HSM. The most common use for this function is the in field upgrade 
capability for export controls.  Upon each power on reset or hardware reset 
of the uHSM, the embedded microcontroller will read the default initial value 
of this register from the NVM and set the register content. The register 
content can be subsequently updated via uHSM_LD_CFG command. The 
functionality of the uHSM is determined by the current value of the register.

 * SIZE:     32
 * FIELDS:
 *     UHSM_CFG         The secure uHSM configuration values. The pre-defined flags are specified in the uHSM_INIT_DEVICEKEY command.  The initial values of these bits are set via the "uHSM_INIT_DEVICEKEY (uhsm_config, prod_config, authorization)" command in the "configuration" input field. The values of these bits can be changed in-field by a manufacturer's authorized signature.
 *
 ******************************************************************************/
#define BCM56504_A0_BSAFE_GLB_UHSM_CFGr 0x00b80208

#define BCM56504_A0_BSAFE_GLB_UHSM_CFGr_SIZE 4

/*
 * This structure should be used to declare and program BSAFE_GLB_UHSM_CFG.
 *
 */
typedef union BCM56504_A0_BSAFE_GLB_UHSM_CFGr_s {
	uint32_t v[1];
	uint32_t bsafe_glb_uhsm_cfg[1];
	uint32_t _bsafe_glb_uhsm_cfg;
} BCM56504_A0_BSAFE_GLB_UHSM_CFGr_t;

#define BCM56504_A0_BSAFE_GLB_UHSM_CFGr_CLR(r) (r).bsafe_glb_uhsm_cfg[0] = 0
#define BCM56504_A0_BSAFE_GLB_UHSM_CFGr_SET(r,d) (r).bsafe_glb_uhsm_cfg[0] = d
#define BCM56504_A0_BSAFE_GLB_UHSM_CFGr_GET(r) (r).bsafe_glb_uhsm_cfg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_BSAFE_GLB_UHSM_CFGr_UHSM_CFGf_GET(r) ((r).bsafe_glb_uhsm_cfg[0])
#define BCM56504_A0_BSAFE_GLB_UHSM_CFGr_UHSM_CFGf_SET(r,f) (r).bsafe_glb_uhsm_cfg[0]=((uint32_t)f)

/*
 * These macros can be used to access BSAFE_GLB_UHSM_CFG.
 *
 */
#define BCM56504_A0_READ_BSAFE_GLB_UHSM_CFGr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_BSAFE_GLB_UHSM_CFGr,(r._bsafe_glb_uhsm_cfg))
#define BCM56504_A0_WRITE_BSAFE_GLB_UHSM_CFGr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_BSAFE_GLB_UHSM_CFGr,&(r._bsafe_glb_uhsm_cfg))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BSAFE_GLB_UHSM_CFGr BCM56504_A0_BSAFE_GLB_UHSM_CFGr
#define BSAFE_GLB_UHSM_CFGr_SIZE BCM56504_A0_BSAFE_GLB_UHSM_CFGr_SIZE
typedef BCM56504_A0_BSAFE_GLB_UHSM_CFGr_t BSAFE_GLB_UHSM_CFGr_t;
#define BSAFE_GLB_UHSM_CFGr_CLR BCM56504_A0_BSAFE_GLB_UHSM_CFGr_CLR
#define BSAFE_GLB_UHSM_CFGr_SET BCM56504_A0_BSAFE_GLB_UHSM_CFGr_SET
#define BSAFE_GLB_UHSM_CFGr_GET BCM56504_A0_BSAFE_GLB_UHSM_CFGr_GET
#define BSAFE_GLB_UHSM_CFGr_UHSM_CFGf_GET BCM56504_A0_BSAFE_GLB_UHSM_CFGr_UHSM_CFGf_GET
#define BSAFE_GLB_UHSM_CFGr_UHSM_CFGf_SET BCM56504_A0_BSAFE_GLB_UHSM_CFGr_UHSM_CFGf_SET
#define READ_BSAFE_GLB_UHSM_CFGr BCM56504_A0_READ_BSAFE_GLB_UHSM_CFGr
#define WRITE_BSAFE_GLB_UHSM_CFGr BCM56504_A0_WRITE_BSAFE_GLB_UHSM_CFGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_BSAFE_GLB_UHSM_CFGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CBPCELLCRCERRPTR
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     ERRORPOINTER     CBP Cell Data Memory cell CRC error pointer tells first failured memory entry.
 *
 ******************************************************************************/
#define BCM56504_A0_CBPCELLCRCERRPTRr 0x00680032

#define BCM56504_A0_CBPCELLCRCERRPTRr_SIZE 4

/*
 * This structure should be used to declare and program CBPCELLCRCERRPTR.
 *
 */
typedef union BCM56504_A0_CBPCELLCRCERRPTRr_s {
	uint32_t v[1];
	uint32_t cbpcellcrcerrptr[1];
	uint32_t _cbpcellcrcerrptr;
} BCM56504_A0_CBPCELLCRCERRPTRr_t;

#define BCM56504_A0_CBPCELLCRCERRPTRr_CLR(r) (r).cbpcellcrcerrptr[0] = 0
#define BCM56504_A0_CBPCELLCRCERRPTRr_SET(r,d) (r).cbpcellcrcerrptr[0] = d
#define BCM56504_A0_CBPCELLCRCERRPTRr_GET(r) (r).cbpcellcrcerrptr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CBPCELLCRCERRPTRr_ERRORPOINTERf_GET(r) (((r).cbpcellcrcerrptr[0]) & 0x3fff)
#define BCM56504_A0_CBPCELLCRCERRPTRr_ERRORPOINTERf_SET(r,f) (r).cbpcellcrcerrptr[0]=(((r).cbpcellcrcerrptr[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access CBPCELLCRCERRPTR.
 *
 */
#define BCM56504_A0_READ_CBPCELLCRCERRPTRr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_CBPCELLCRCERRPTRr,(r._cbpcellcrcerrptr))
#define BCM56504_A0_WRITE_CBPCELLCRCERRPTRr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_CBPCELLCRCERRPTRr,&(r._cbpcellcrcerrptr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CBPCELLCRCERRPTRr BCM56504_A0_CBPCELLCRCERRPTRr
#define CBPCELLCRCERRPTRr_SIZE BCM56504_A0_CBPCELLCRCERRPTRr_SIZE
typedef BCM56504_A0_CBPCELLCRCERRPTRr_t CBPCELLCRCERRPTRr_t;
#define CBPCELLCRCERRPTRr_CLR BCM56504_A0_CBPCELLCRCERRPTRr_CLR
#define CBPCELLCRCERRPTRr_SET BCM56504_A0_CBPCELLCRCERRPTRr_SET
#define CBPCELLCRCERRPTRr_GET BCM56504_A0_CBPCELLCRCERRPTRr_GET
#define CBPCELLCRCERRPTRr_ERRORPOINTERf_GET BCM56504_A0_CBPCELLCRCERRPTRr_ERRORPOINTERf_GET
#define CBPCELLCRCERRPTRr_ERRORPOINTERf_SET BCM56504_A0_CBPCELLCRCERRPTRr_ERRORPOINTERf_SET
#define READ_CBPCELLCRCERRPTRr BCM56504_A0_READ_CBPCELLCRCERRPTRr
#define WRITE_CBPCELLCRCERRPTRr BCM56504_A0_WRITE_CBPCELLCRCERRPTRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CBPCELLCRCERRPTRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CBPCELLHDRMEMDEBUG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     SAM              sam registers.
 *     CT0              ct0 registers.
 *     CT3              ct1 registers.
 *     CT2              ct2 registers.
 *
 ******************************************************************************/
#define BCM56504_A0_CBPCELLHDRMEMDEBUGr 0x00680052

#define BCM56504_A0_CBPCELLHDRMEMDEBUGr_SIZE 4

/*
 * This structure should be used to declare and program CBPCELLHDRMEMDEBUG.
 *
 */
typedef union BCM56504_A0_CBPCELLHDRMEMDEBUGr_s {
	uint32_t v[1];
	uint32_t cbpcellhdrmemdebug[1];
	uint32_t _cbpcellhdrmemdebug;
} BCM56504_A0_CBPCELLHDRMEMDEBUGr_t;

#define BCM56504_A0_CBPCELLHDRMEMDEBUGr_CLR(r) (r).cbpcellhdrmemdebug[0] = 0
#define BCM56504_A0_CBPCELLHDRMEMDEBUGr_SET(r,d) (r).cbpcellhdrmemdebug[0] = d
#define BCM56504_A0_CBPCELLHDRMEMDEBUGr_GET(r) (r).cbpcellhdrmemdebug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CBPCELLHDRMEMDEBUGr_SAMf_GET(r) (((r).cbpcellhdrmemdebug[0]) & 0x3)
#define BCM56504_A0_CBPCELLHDRMEMDEBUGr_SAMf_SET(r,f) (r).cbpcellhdrmemdebug[0]=(((r).cbpcellhdrmemdebug[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56504_A0_CBPCELLHDRMEMDEBUGr_CT0f_GET(r) ((((r).cbpcellhdrmemdebug[0]) >> 2) & 0x1)
#define BCM56504_A0_CBPCELLHDRMEMDEBUGr_CT0f_SET(r,f) (r).cbpcellhdrmemdebug[0]=(((r).cbpcellhdrmemdebug[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_CBPCELLHDRMEMDEBUGr_CT3f_GET(r) ((((r).cbpcellhdrmemdebug[0]) >> 3) & 0x1)
#define BCM56504_A0_CBPCELLHDRMEMDEBUGr_CT3f_SET(r,f) (r).cbpcellhdrmemdebug[0]=(((r).cbpcellhdrmemdebug[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_CBPCELLHDRMEMDEBUGr_CT2f_GET(r) ((((r).cbpcellhdrmemdebug[0]) >> 4) & 0x1)
#define BCM56504_A0_CBPCELLHDRMEMDEBUGr_CT2f_SET(r,f) (r).cbpcellhdrmemdebug[0]=(((r).cbpcellhdrmemdebug[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))

/*
 * These macros can be used to access CBPCELLHDRMEMDEBUG.
 *
 */
#define BCM56504_A0_READ_CBPCELLHDRMEMDEBUGr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_CBPCELLHDRMEMDEBUGr,(r._cbpcellhdrmemdebug))
#define BCM56504_A0_WRITE_CBPCELLHDRMEMDEBUGr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_CBPCELLHDRMEMDEBUGr,&(r._cbpcellhdrmemdebug))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CBPCELLHDRMEMDEBUGr BCM56504_A0_CBPCELLHDRMEMDEBUGr
#define CBPCELLHDRMEMDEBUGr_SIZE BCM56504_A0_CBPCELLHDRMEMDEBUGr_SIZE
typedef BCM56504_A0_CBPCELLHDRMEMDEBUGr_t CBPCELLHDRMEMDEBUGr_t;
#define CBPCELLHDRMEMDEBUGr_CLR BCM56504_A0_CBPCELLHDRMEMDEBUGr_CLR
#define CBPCELLHDRMEMDEBUGr_SET BCM56504_A0_CBPCELLHDRMEMDEBUGr_SET
#define CBPCELLHDRMEMDEBUGr_GET BCM56504_A0_CBPCELLHDRMEMDEBUGr_GET
#define CBPCELLHDRMEMDEBUGr_SAMf_GET BCM56504_A0_CBPCELLHDRMEMDEBUGr_SAMf_GET
#define CBPCELLHDRMEMDEBUGr_SAMf_SET BCM56504_A0_CBPCELLHDRMEMDEBUGr_SAMf_SET
#define CBPCELLHDRMEMDEBUGr_CT0f_GET BCM56504_A0_CBPCELLHDRMEMDEBUGr_CT0f_GET
#define CBPCELLHDRMEMDEBUGr_CT0f_SET BCM56504_A0_CBPCELLHDRMEMDEBUGr_CT0f_SET
#define CBPCELLHDRMEMDEBUGr_CT3f_GET BCM56504_A0_CBPCELLHDRMEMDEBUGr_CT3f_GET
#define CBPCELLHDRMEMDEBUGr_CT3f_SET BCM56504_A0_CBPCELLHDRMEMDEBUGr_CT3f_SET
#define CBPCELLHDRMEMDEBUGr_CT2f_GET BCM56504_A0_CBPCELLHDRMEMDEBUGr_CT2f_GET
#define CBPCELLHDRMEMDEBUGr_CT2f_SET BCM56504_A0_CBPCELLHDRMEMDEBUGr_CT2f_SET
#define READ_CBPCELLHDRMEMDEBUGr BCM56504_A0_READ_CBPCELLHDRMEMDEBUGr
#define WRITE_CBPCELLHDRMEMDEBUGr BCM56504_A0_WRITE_CBPCELLHDRMEMDEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CBPCELLHDRMEMDEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CBPCELLHDRPARITYERRPTR
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     ERRORPOINTER     CBP Cell Header Memory parity error pointer is the errored cell header pointer.
 *     ERROREDNEXTCELLPOINTER CBP Cell Header Memory parity error next cell pointer is the abandoned next cellpointer.
 *
 ******************************************************************************/
#define BCM56504_A0_CBPCELLHDRPARITYERRPTRr 0x00680033

#define BCM56504_A0_CBPCELLHDRPARITYERRPTRr_SIZE 4

/*
 * This structure should be used to declare and program CBPCELLHDRPARITYERRPTR.
 *
 */
typedef union BCM56504_A0_CBPCELLHDRPARITYERRPTRr_s {
	uint32_t v[1];
	uint32_t cbpcellhdrparityerrptr[1];
	uint32_t _cbpcellhdrparityerrptr;
} BCM56504_A0_CBPCELLHDRPARITYERRPTRr_t;

#define BCM56504_A0_CBPCELLHDRPARITYERRPTRr_CLR(r) (r).cbpcellhdrparityerrptr[0] = 0
#define BCM56504_A0_CBPCELLHDRPARITYERRPTRr_SET(r,d) (r).cbpcellhdrparityerrptr[0] = d
#define BCM56504_A0_CBPCELLHDRPARITYERRPTRr_GET(r) (r).cbpcellhdrparityerrptr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CBPCELLHDRPARITYERRPTRr_ERRORPOINTERf_GET(r) (((r).cbpcellhdrparityerrptr[0]) & 0x3fff)
#define BCM56504_A0_CBPCELLHDRPARITYERRPTRr_ERRORPOINTERf_SET(r,f) (r).cbpcellhdrparityerrptr[0]=(((r).cbpcellhdrparityerrptr[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM56504_A0_CBPCELLHDRPARITYERRPTRr_ERROREDNEXTCELLPOINTERf_GET(r) ((((r).cbpcellhdrparityerrptr[0]) >> 14) & 0x3fff)
#define BCM56504_A0_CBPCELLHDRPARITYERRPTRr_ERROREDNEXTCELLPOINTERf_SET(r,f) (r).cbpcellhdrparityerrptr[0]=(((r).cbpcellhdrparityerrptr[0] & ~((uint32_t)0x3fff << 14)) | ((((uint32_t)f) & 0x3fff) << 14))

/*
 * These macros can be used to access CBPCELLHDRPARITYERRPTR.
 *
 */
#define BCM56504_A0_READ_CBPCELLHDRPARITYERRPTRr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_CBPCELLHDRPARITYERRPTRr,(r._cbpcellhdrparityerrptr))
#define BCM56504_A0_WRITE_CBPCELLHDRPARITYERRPTRr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_CBPCELLHDRPARITYERRPTRr,&(r._cbpcellhdrparityerrptr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CBPCELLHDRPARITYERRPTRr BCM56504_A0_CBPCELLHDRPARITYERRPTRr
#define CBPCELLHDRPARITYERRPTRr_SIZE BCM56504_A0_CBPCELLHDRPARITYERRPTRr_SIZE
typedef BCM56504_A0_CBPCELLHDRPARITYERRPTRr_t CBPCELLHDRPARITYERRPTRr_t;
#define CBPCELLHDRPARITYERRPTRr_CLR BCM56504_A0_CBPCELLHDRPARITYERRPTRr_CLR
#define CBPCELLHDRPARITYERRPTRr_SET BCM56504_A0_CBPCELLHDRPARITYERRPTRr_SET
#define CBPCELLHDRPARITYERRPTRr_GET BCM56504_A0_CBPCELLHDRPARITYERRPTRr_GET
#define CBPCELLHDRPARITYERRPTRr_ERRORPOINTERf_GET BCM56504_A0_CBPCELLHDRPARITYERRPTRr_ERRORPOINTERf_GET
#define CBPCELLHDRPARITYERRPTRr_ERRORPOINTERf_SET BCM56504_A0_CBPCELLHDRPARITYERRPTRr_ERRORPOINTERf_SET
#define CBPCELLHDRPARITYERRPTRr_ERROREDNEXTCELLPOINTERf_GET BCM56504_A0_CBPCELLHDRPARITYERRPTRr_ERROREDNEXTCELLPOINTERf_GET
#define CBPCELLHDRPARITYERRPTRr_ERROREDNEXTCELLPOINTERf_SET BCM56504_A0_CBPCELLHDRPARITYERRPTRr_ERROREDNEXTCELLPOINTERf_SET
#define READ_CBPCELLHDRPARITYERRPTRr BCM56504_A0_READ_CBPCELLHDRPARITYERRPTRr
#define WRITE_CBPCELLHDRPARITYERRPTRr BCM56504_A0_WRITE_CBPCELLHDRPARITYERRPTRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CBPCELLHDRPARITYERRPTRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CBPDATAMEM0DEBUG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     SAM              sam registers.
 *     CT0              ct0 registers.
 *     CT3              ct1 registers.
 *     CT2              ct2 registers.
 *
 ******************************************************************************/
#define BCM56504_A0_CBPDATAMEM0DEBUGr 0x00680040

#define BCM56504_A0_CBPDATAMEM0DEBUGr_SIZE 4

/*
 * This structure should be used to declare and program CBPDATAMEM0DEBUG.
 *
 */
typedef union BCM56504_A0_CBPDATAMEM0DEBUGr_s {
	uint32_t v[1];
	uint32_t cbpdatamem0debug[1];
	uint32_t _cbpdatamem0debug;
} BCM56504_A0_CBPDATAMEM0DEBUGr_t;

#define BCM56504_A0_CBPDATAMEM0DEBUGr_CLR(r) (r).cbpdatamem0debug[0] = 0
#define BCM56504_A0_CBPDATAMEM0DEBUGr_SET(r,d) (r).cbpdatamem0debug[0] = d
#define BCM56504_A0_CBPDATAMEM0DEBUGr_GET(r) (r).cbpdatamem0debug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CBPDATAMEM0DEBUGr_SAMf_GET(r) (((r).cbpdatamem0debug[0]) & 0x3)
#define BCM56504_A0_CBPDATAMEM0DEBUGr_SAMf_SET(r,f) (r).cbpdatamem0debug[0]=(((r).cbpdatamem0debug[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56504_A0_CBPDATAMEM0DEBUGr_CT0f_GET(r) ((((r).cbpdatamem0debug[0]) >> 2) & 0x1)
#define BCM56504_A0_CBPDATAMEM0DEBUGr_CT0f_SET(r,f) (r).cbpdatamem0debug[0]=(((r).cbpdatamem0debug[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_CBPDATAMEM0DEBUGr_CT3f_GET(r) ((((r).cbpdatamem0debug[0]) >> 3) & 0x1)
#define BCM56504_A0_CBPDATAMEM0DEBUGr_CT3f_SET(r,f) (r).cbpdatamem0debug[0]=(((r).cbpdatamem0debug[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_CBPDATAMEM0DEBUGr_CT2f_GET(r) ((((r).cbpdatamem0debug[0]) >> 4) & 0x1)
#define BCM56504_A0_CBPDATAMEM0DEBUGr_CT2f_SET(r,f) (r).cbpdatamem0debug[0]=(((r).cbpdatamem0debug[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))

/*
 * These macros can be used to access CBPDATAMEM0DEBUG.
 *
 */
#define BCM56504_A0_READ_CBPDATAMEM0DEBUGr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_CBPDATAMEM0DEBUGr,(r._cbpdatamem0debug))
#define BCM56504_A0_WRITE_CBPDATAMEM0DEBUGr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_CBPDATAMEM0DEBUGr,&(r._cbpdatamem0debug))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CBPDATAMEM0DEBUGr BCM56504_A0_CBPDATAMEM0DEBUGr
#define CBPDATAMEM0DEBUGr_SIZE BCM56504_A0_CBPDATAMEM0DEBUGr_SIZE
typedef BCM56504_A0_CBPDATAMEM0DEBUGr_t CBPDATAMEM0DEBUGr_t;
#define CBPDATAMEM0DEBUGr_CLR BCM56504_A0_CBPDATAMEM0DEBUGr_CLR
#define CBPDATAMEM0DEBUGr_SET BCM56504_A0_CBPDATAMEM0DEBUGr_SET
#define CBPDATAMEM0DEBUGr_GET BCM56504_A0_CBPDATAMEM0DEBUGr_GET
#define CBPDATAMEM0DEBUGr_SAMf_GET BCM56504_A0_CBPDATAMEM0DEBUGr_SAMf_GET
#define CBPDATAMEM0DEBUGr_SAMf_SET BCM56504_A0_CBPDATAMEM0DEBUGr_SAMf_SET
#define CBPDATAMEM0DEBUGr_CT0f_GET BCM56504_A0_CBPDATAMEM0DEBUGr_CT0f_GET
#define CBPDATAMEM0DEBUGr_CT0f_SET BCM56504_A0_CBPDATAMEM0DEBUGr_CT0f_SET
#define CBPDATAMEM0DEBUGr_CT3f_GET BCM56504_A0_CBPDATAMEM0DEBUGr_CT3f_GET
#define CBPDATAMEM0DEBUGr_CT3f_SET BCM56504_A0_CBPDATAMEM0DEBUGr_CT3f_SET
#define CBPDATAMEM0DEBUGr_CT2f_GET BCM56504_A0_CBPDATAMEM0DEBUGr_CT2f_GET
#define CBPDATAMEM0DEBUGr_CT2f_SET BCM56504_A0_CBPDATAMEM0DEBUGr_CT2f_SET
#define READ_CBPDATAMEM0DEBUGr BCM56504_A0_READ_CBPDATAMEM0DEBUGr
#define WRITE_CBPDATAMEM0DEBUGr BCM56504_A0_WRITE_CBPDATAMEM0DEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CBPDATAMEM0DEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CBPDATAMEM10DEBUG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     SAM              sam registers.
 *     CT0              ct0 registers.
 *     CT3              ct1 registers.
 *     CT2              ct2 registers.
 *
 ******************************************************************************/
#define BCM56504_A0_CBPDATAMEM10DEBUGr 0x0068004a

#define BCM56504_A0_CBPDATAMEM10DEBUGr_SIZE 4

/*
 * This structure should be used to declare and program CBPDATAMEM10DEBUG.
 *
 */
typedef union BCM56504_A0_CBPDATAMEM10DEBUGr_s {
	uint32_t v[1];
	uint32_t cbpdatamem10debug[1];
	uint32_t _cbpdatamem10debug;
} BCM56504_A0_CBPDATAMEM10DEBUGr_t;

#define BCM56504_A0_CBPDATAMEM10DEBUGr_CLR(r) (r).cbpdatamem10debug[0] = 0
#define BCM56504_A0_CBPDATAMEM10DEBUGr_SET(r,d) (r).cbpdatamem10debug[0] = d
#define BCM56504_A0_CBPDATAMEM10DEBUGr_GET(r) (r).cbpdatamem10debug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CBPDATAMEM10DEBUGr_SAMf_GET(r) (((r).cbpdatamem10debug[0]) & 0x3)
#define BCM56504_A0_CBPDATAMEM10DEBUGr_SAMf_SET(r,f) (r).cbpdatamem10debug[0]=(((r).cbpdatamem10debug[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56504_A0_CBPDATAMEM10DEBUGr_CT0f_GET(r) ((((r).cbpdatamem10debug[0]) >> 2) & 0x1)
#define BCM56504_A0_CBPDATAMEM10DEBUGr_CT0f_SET(r,f) (r).cbpdatamem10debug[0]=(((r).cbpdatamem10debug[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_CBPDATAMEM10DEBUGr_CT3f_GET(r) ((((r).cbpdatamem10debug[0]) >> 3) & 0x1)
#define BCM56504_A0_CBPDATAMEM10DEBUGr_CT3f_SET(r,f) (r).cbpdatamem10debug[0]=(((r).cbpdatamem10debug[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_CBPDATAMEM10DEBUGr_CT2f_GET(r) ((((r).cbpdatamem10debug[0]) >> 4) & 0x1)
#define BCM56504_A0_CBPDATAMEM10DEBUGr_CT2f_SET(r,f) (r).cbpdatamem10debug[0]=(((r).cbpdatamem10debug[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))

/*
 * These macros can be used to access CBPDATAMEM10DEBUG.
 *
 */
#define BCM56504_A0_READ_CBPDATAMEM10DEBUGr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_CBPDATAMEM10DEBUGr,(r._cbpdatamem10debug))
#define BCM56504_A0_WRITE_CBPDATAMEM10DEBUGr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_CBPDATAMEM10DEBUGr,&(r._cbpdatamem10debug))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CBPDATAMEM10DEBUGr BCM56504_A0_CBPDATAMEM10DEBUGr
#define CBPDATAMEM10DEBUGr_SIZE BCM56504_A0_CBPDATAMEM10DEBUGr_SIZE
typedef BCM56504_A0_CBPDATAMEM10DEBUGr_t CBPDATAMEM10DEBUGr_t;
#define CBPDATAMEM10DEBUGr_CLR BCM56504_A0_CBPDATAMEM10DEBUGr_CLR
#define CBPDATAMEM10DEBUGr_SET BCM56504_A0_CBPDATAMEM10DEBUGr_SET
#define CBPDATAMEM10DEBUGr_GET BCM56504_A0_CBPDATAMEM10DEBUGr_GET
#define CBPDATAMEM10DEBUGr_SAMf_GET BCM56504_A0_CBPDATAMEM10DEBUGr_SAMf_GET
#define CBPDATAMEM10DEBUGr_SAMf_SET BCM56504_A0_CBPDATAMEM10DEBUGr_SAMf_SET
#define CBPDATAMEM10DEBUGr_CT0f_GET BCM56504_A0_CBPDATAMEM10DEBUGr_CT0f_GET
#define CBPDATAMEM10DEBUGr_CT0f_SET BCM56504_A0_CBPDATAMEM10DEBUGr_CT0f_SET
#define CBPDATAMEM10DEBUGr_CT3f_GET BCM56504_A0_CBPDATAMEM10DEBUGr_CT3f_GET
#define CBPDATAMEM10DEBUGr_CT3f_SET BCM56504_A0_CBPDATAMEM10DEBUGr_CT3f_SET
#define CBPDATAMEM10DEBUGr_CT2f_GET BCM56504_A0_CBPDATAMEM10DEBUGr_CT2f_GET
#define CBPDATAMEM10DEBUGr_CT2f_SET BCM56504_A0_CBPDATAMEM10DEBUGr_CT2f_SET
#define READ_CBPDATAMEM10DEBUGr BCM56504_A0_READ_CBPDATAMEM10DEBUGr
#define WRITE_CBPDATAMEM10DEBUGr BCM56504_A0_WRITE_CBPDATAMEM10DEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CBPDATAMEM10DEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CBPDATAMEM11DEBUG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     SAM              sam registers.
 *     CT0              ct0 registers.
 *     CT3              ct1 registers.
 *     CT2              ct2 registers.
 *
 ******************************************************************************/
#define BCM56504_A0_CBPDATAMEM11DEBUGr 0x0068004b

#define BCM56504_A0_CBPDATAMEM11DEBUGr_SIZE 4

/*
 * This structure should be used to declare and program CBPDATAMEM11DEBUG.
 *
 */
typedef union BCM56504_A0_CBPDATAMEM11DEBUGr_s {
	uint32_t v[1];
	uint32_t cbpdatamem11debug[1];
	uint32_t _cbpdatamem11debug;
} BCM56504_A0_CBPDATAMEM11DEBUGr_t;

#define BCM56504_A0_CBPDATAMEM11DEBUGr_CLR(r) (r).cbpdatamem11debug[0] = 0
#define BCM56504_A0_CBPDATAMEM11DEBUGr_SET(r,d) (r).cbpdatamem11debug[0] = d
#define BCM56504_A0_CBPDATAMEM11DEBUGr_GET(r) (r).cbpdatamem11debug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CBPDATAMEM11DEBUGr_SAMf_GET(r) (((r).cbpdatamem11debug[0]) & 0x3)
#define BCM56504_A0_CBPDATAMEM11DEBUGr_SAMf_SET(r,f) (r).cbpdatamem11debug[0]=(((r).cbpdatamem11debug[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56504_A0_CBPDATAMEM11DEBUGr_CT0f_GET(r) ((((r).cbpdatamem11debug[0]) >> 2) & 0x1)
#define BCM56504_A0_CBPDATAMEM11DEBUGr_CT0f_SET(r,f) (r).cbpdatamem11debug[0]=(((r).cbpdatamem11debug[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_CBPDATAMEM11DEBUGr_CT3f_GET(r) ((((r).cbpdatamem11debug[0]) >> 3) & 0x1)
#define BCM56504_A0_CBPDATAMEM11DEBUGr_CT3f_SET(r,f) (r).cbpdatamem11debug[0]=(((r).cbpdatamem11debug[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_CBPDATAMEM11DEBUGr_CT2f_GET(r) ((((r).cbpdatamem11debug[0]) >> 4) & 0x1)
#define BCM56504_A0_CBPDATAMEM11DEBUGr_CT2f_SET(r,f) (r).cbpdatamem11debug[0]=(((r).cbpdatamem11debug[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))

/*
 * These macros can be used to access CBPDATAMEM11DEBUG.
 *
 */
#define BCM56504_A0_READ_CBPDATAMEM11DEBUGr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_CBPDATAMEM11DEBUGr,(r._cbpdatamem11debug))
#define BCM56504_A0_WRITE_CBPDATAMEM11DEBUGr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_CBPDATAMEM11DEBUGr,&(r._cbpdatamem11debug))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CBPDATAMEM11DEBUGr BCM56504_A0_CBPDATAMEM11DEBUGr
#define CBPDATAMEM11DEBUGr_SIZE BCM56504_A0_CBPDATAMEM11DEBUGr_SIZE
typedef BCM56504_A0_CBPDATAMEM11DEBUGr_t CBPDATAMEM11DEBUGr_t;
#define CBPDATAMEM11DEBUGr_CLR BCM56504_A0_CBPDATAMEM11DEBUGr_CLR
#define CBPDATAMEM11DEBUGr_SET BCM56504_A0_CBPDATAMEM11DEBUGr_SET
#define CBPDATAMEM11DEBUGr_GET BCM56504_A0_CBPDATAMEM11DEBUGr_GET
#define CBPDATAMEM11DEBUGr_SAMf_GET BCM56504_A0_CBPDATAMEM11DEBUGr_SAMf_GET
#define CBPDATAMEM11DEBUGr_SAMf_SET BCM56504_A0_CBPDATAMEM11DEBUGr_SAMf_SET
#define CBPDATAMEM11DEBUGr_CT0f_GET BCM56504_A0_CBPDATAMEM11DEBUGr_CT0f_GET
#define CBPDATAMEM11DEBUGr_CT0f_SET BCM56504_A0_CBPDATAMEM11DEBUGr_CT0f_SET
#define CBPDATAMEM11DEBUGr_CT3f_GET BCM56504_A0_CBPDATAMEM11DEBUGr_CT3f_GET
#define CBPDATAMEM11DEBUGr_CT3f_SET BCM56504_A0_CBPDATAMEM11DEBUGr_CT3f_SET
#define CBPDATAMEM11DEBUGr_CT2f_GET BCM56504_A0_CBPDATAMEM11DEBUGr_CT2f_GET
#define CBPDATAMEM11DEBUGr_CT2f_SET BCM56504_A0_CBPDATAMEM11DEBUGr_CT2f_SET
#define READ_CBPDATAMEM11DEBUGr BCM56504_A0_READ_CBPDATAMEM11DEBUGr
#define WRITE_CBPDATAMEM11DEBUGr BCM56504_A0_WRITE_CBPDATAMEM11DEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CBPDATAMEM11DEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CBPDATAMEM12DEBUG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     SAM              sam registers.
 *     CT0              ct0 registers.
 *     CT3              ct1 registers.
 *     CT2              ct2 registers.
 *
 ******************************************************************************/
#define BCM56504_A0_CBPDATAMEM12DEBUGr 0x0068004c

#define BCM56504_A0_CBPDATAMEM12DEBUGr_SIZE 4

/*
 * This structure should be used to declare and program CBPDATAMEM12DEBUG.
 *
 */
typedef union BCM56504_A0_CBPDATAMEM12DEBUGr_s {
	uint32_t v[1];
	uint32_t cbpdatamem12debug[1];
	uint32_t _cbpdatamem12debug;
} BCM56504_A0_CBPDATAMEM12DEBUGr_t;

#define BCM56504_A0_CBPDATAMEM12DEBUGr_CLR(r) (r).cbpdatamem12debug[0] = 0
#define BCM56504_A0_CBPDATAMEM12DEBUGr_SET(r,d) (r).cbpdatamem12debug[0] = d
#define BCM56504_A0_CBPDATAMEM12DEBUGr_GET(r) (r).cbpdatamem12debug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CBPDATAMEM12DEBUGr_SAMf_GET(r) (((r).cbpdatamem12debug[0]) & 0x3)
#define BCM56504_A0_CBPDATAMEM12DEBUGr_SAMf_SET(r,f) (r).cbpdatamem12debug[0]=(((r).cbpdatamem12debug[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56504_A0_CBPDATAMEM12DEBUGr_CT0f_GET(r) ((((r).cbpdatamem12debug[0]) >> 2) & 0x1)
#define BCM56504_A0_CBPDATAMEM12DEBUGr_CT0f_SET(r,f) (r).cbpdatamem12debug[0]=(((r).cbpdatamem12debug[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_CBPDATAMEM12DEBUGr_CT3f_GET(r) ((((r).cbpdatamem12debug[0]) >> 3) & 0x1)
#define BCM56504_A0_CBPDATAMEM12DEBUGr_CT3f_SET(r,f) (r).cbpdatamem12debug[0]=(((r).cbpdatamem12debug[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_CBPDATAMEM12DEBUGr_CT2f_GET(r) ((((r).cbpdatamem12debug[0]) >> 4) & 0x1)
#define BCM56504_A0_CBPDATAMEM12DEBUGr_CT2f_SET(r,f) (r).cbpdatamem12debug[0]=(((r).cbpdatamem12debug[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))

/*
 * These macros can be used to access CBPDATAMEM12DEBUG.
 *
 */
#define BCM56504_A0_READ_CBPDATAMEM12DEBUGr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_CBPDATAMEM12DEBUGr,(r._cbpdatamem12debug))
#define BCM56504_A0_WRITE_CBPDATAMEM12DEBUGr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_CBPDATAMEM12DEBUGr,&(r._cbpdatamem12debug))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CBPDATAMEM12DEBUGr BCM56504_A0_CBPDATAMEM12DEBUGr
#define CBPDATAMEM12DEBUGr_SIZE BCM56504_A0_CBPDATAMEM12DEBUGr_SIZE
typedef BCM56504_A0_CBPDATAMEM12DEBUGr_t CBPDATAMEM12DEBUGr_t;
#define CBPDATAMEM12DEBUGr_CLR BCM56504_A0_CBPDATAMEM12DEBUGr_CLR
#define CBPDATAMEM12DEBUGr_SET BCM56504_A0_CBPDATAMEM12DEBUGr_SET
#define CBPDATAMEM12DEBUGr_GET BCM56504_A0_CBPDATAMEM12DEBUGr_GET
#define CBPDATAMEM12DEBUGr_SAMf_GET BCM56504_A0_CBPDATAMEM12DEBUGr_SAMf_GET
#define CBPDATAMEM12DEBUGr_SAMf_SET BCM56504_A0_CBPDATAMEM12DEBUGr_SAMf_SET
#define CBPDATAMEM12DEBUGr_CT0f_GET BCM56504_A0_CBPDATAMEM12DEBUGr_CT0f_GET
#define CBPDATAMEM12DEBUGr_CT0f_SET BCM56504_A0_CBPDATAMEM12DEBUGr_CT0f_SET
#define CBPDATAMEM12DEBUGr_CT3f_GET BCM56504_A0_CBPDATAMEM12DEBUGr_CT3f_GET
#define CBPDATAMEM12DEBUGr_CT3f_SET BCM56504_A0_CBPDATAMEM12DEBUGr_CT3f_SET
#define CBPDATAMEM12DEBUGr_CT2f_GET BCM56504_A0_CBPDATAMEM12DEBUGr_CT2f_GET
#define CBPDATAMEM12DEBUGr_CT2f_SET BCM56504_A0_CBPDATAMEM12DEBUGr_CT2f_SET
#define READ_CBPDATAMEM12DEBUGr BCM56504_A0_READ_CBPDATAMEM12DEBUGr
#define WRITE_CBPDATAMEM12DEBUGr BCM56504_A0_WRITE_CBPDATAMEM12DEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CBPDATAMEM12DEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CBPDATAMEM13DEBUG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     SAM              sam registers.
 *     CT0              ct0 registers.
 *     CT3              ct1 registers.
 *     CT2              ct2 registers.
 *
 ******************************************************************************/
#define BCM56504_A0_CBPDATAMEM13DEBUGr 0x0068004d

#define BCM56504_A0_CBPDATAMEM13DEBUGr_SIZE 4

/*
 * This structure should be used to declare and program CBPDATAMEM13DEBUG.
 *
 */
typedef union BCM56504_A0_CBPDATAMEM13DEBUGr_s {
	uint32_t v[1];
	uint32_t cbpdatamem13debug[1];
	uint32_t _cbpdatamem13debug;
} BCM56504_A0_CBPDATAMEM13DEBUGr_t;

#define BCM56504_A0_CBPDATAMEM13DEBUGr_CLR(r) (r).cbpdatamem13debug[0] = 0
#define BCM56504_A0_CBPDATAMEM13DEBUGr_SET(r,d) (r).cbpdatamem13debug[0] = d
#define BCM56504_A0_CBPDATAMEM13DEBUGr_GET(r) (r).cbpdatamem13debug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CBPDATAMEM13DEBUGr_SAMf_GET(r) (((r).cbpdatamem13debug[0]) & 0x3)
#define BCM56504_A0_CBPDATAMEM13DEBUGr_SAMf_SET(r,f) (r).cbpdatamem13debug[0]=(((r).cbpdatamem13debug[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56504_A0_CBPDATAMEM13DEBUGr_CT0f_GET(r) ((((r).cbpdatamem13debug[0]) >> 2) & 0x1)
#define BCM56504_A0_CBPDATAMEM13DEBUGr_CT0f_SET(r,f) (r).cbpdatamem13debug[0]=(((r).cbpdatamem13debug[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_CBPDATAMEM13DEBUGr_CT3f_GET(r) ((((r).cbpdatamem13debug[0]) >> 3) & 0x1)
#define BCM56504_A0_CBPDATAMEM13DEBUGr_CT3f_SET(r,f) (r).cbpdatamem13debug[0]=(((r).cbpdatamem13debug[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_CBPDATAMEM13DEBUGr_CT2f_GET(r) ((((r).cbpdatamem13debug[0]) >> 4) & 0x1)
#define BCM56504_A0_CBPDATAMEM13DEBUGr_CT2f_SET(r,f) (r).cbpdatamem13debug[0]=(((r).cbpdatamem13debug[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))

/*
 * These macros can be used to access CBPDATAMEM13DEBUG.
 *
 */
#define BCM56504_A0_READ_CBPDATAMEM13DEBUGr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_CBPDATAMEM13DEBUGr,(r._cbpdatamem13debug))
#define BCM56504_A0_WRITE_CBPDATAMEM13DEBUGr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_CBPDATAMEM13DEBUGr,&(r._cbpdatamem13debug))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CBPDATAMEM13DEBUGr BCM56504_A0_CBPDATAMEM13DEBUGr
#define CBPDATAMEM13DEBUGr_SIZE BCM56504_A0_CBPDATAMEM13DEBUGr_SIZE
typedef BCM56504_A0_CBPDATAMEM13DEBUGr_t CBPDATAMEM13DEBUGr_t;
#define CBPDATAMEM13DEBUGr_CLR BCM56504_A0_CBPDATAMEM13DEBUGr_CLR
#define CBPDATAMEM13DEBUGr_SET BCM56504_A0_CBPDATAMEM13DEBUGr_SET
#define CBPDATAMEM13DEBUGr_GET BCM56504_A0_CBPDATAMEM13DEBUGr_GET
#define CBPDATAMEM13DEBUGr_SAMf_GET BCM56504_A0_CBPDATAMEM13DEBUGr_SAMf_GET
#define CBPDATAMEM13DEBUGr_SAMf_SET BCM56504_A0_CBPDATAMEM13DEBUGr_SAMf_SET
#define CBPDATAMEM13DEBUGr_CT0f_GET BCM56504_A0_CBPDATAMEM13DEBUGr_CT0f_GET
#define CBPDATAMEM13DEBUGr_CT0f_SET BCM56504_A0_CBPDATAMEM13DEBUGr_CT0f_SET
#define CBPDATAMEM13DEBUGr_CT3f_GET BCM56504_A0_CBPDATAMEM13DEBUGr_CT3f_GET
#define CBPDATAMEM13DEBUGr_CT3f_SET BCM56504_A0_CBPDATAMEM13DEBUGr_CT3f_SET
#define CBPDATAMEM13DEBUGr_CT2f_GET BCM56504_A0_CBPDATAMEM13DEBUGr_CT2f_GET
#define CBPDATAMEM13DEBUGr_CT2f_SET BCM56504_A0_CBPDATAMEM13DEBUGr_CT2f_SET
#define READ_CBPDATAMEM13DEBUGr BCM56504_A0_READ_CBPDATAMEM13DEBUGr
#define WRITE_CBPDATAMEM13DEBUGr BCM56504_A0_WRITE_CBPDATAMEM13DEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CBPDATAMEM13DEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CBPDATAMEM14DEBUG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     SAM              sam registers.
 *     CT0              ct0 registers.
 *     CT3              ct1 registers.
 *     CT2              ct2 registers.
 *
 ******************************************************************************/
#define BCM56504_A0_CBPDATAMEM14DEBUGr 0x0068004e

#define BCM56504_A0_CBPDATAMEM14DEBUGr_SIZE 4

/*
 * This structure should be used to declare and program CBPDATAMEM14DEBUG.
 *
 */
typedef union BCM56504_A0_CBPDATAMEM14DEBUGr_s {
	uint32_t v[1];
	uint32_t cbpdatamem14debug[1];
	uint32_t _cbpdatamem14debug;
} BCM56504_A0_CBPDATAMEM14DEBUGr_t;

#define BCM56504_A0_CBPDATAMEM14DEBUGr_CLR(r) (r).cbpdatamem14debug[0] = 0
#define BCM56504_A0_CBPDATAMEM14DEBUGr_SET(r,d) (r).cbpdatamem14debug[0] = d
#define BCM56504_A0_CBPDATAMEM14DEBUGr_GET(r) (r).cbpdatamem14debug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CBPDATAMEM14DEBUGr_SAMf_GET(r) (((r).cbpdatamem14debug[0]) & 0x3)
#define BCM56504_A0_CBPDATAMEM14DEBUGr_SAMf_SET(r,f) (r).cbpdatamem14debug[0]=(((r).cbpdatamem14debug[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56504_A0_CBPDATAMEM14DEBUGr_CT0f_GET(r) ((((r).cbpdatamem14debug[0]) >> 2) & 0x1)
#define BCM56504_A0_CBPDATAMEM14DEBUGr_CT0f_SET(r,f) (r).cbpdatamem14debug[0]=(((r).cbpdatamem14debug[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_CBPDATAMEM14DEBUGr_CT3f_GET(r) ((((r).cbpdatamem14debug[0]) >> 3) & 0x1)
#define BCM56504_A0_CBPDATAMEM14DEBUGr_CT3f_SET(r,f) (r).cbpdatamem14debug[0]=(((r).cbpdatamem14debug[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_CBPDATAMEM14DEBUGr_CT2f_GET(r) ((((r).cbpdatamem14debug[0]) >> 4) & 0x1)
#define BCM56504_A0_CBPDATAMEM14DEBUGr_CT2f_SET(r,f) (r).cbpdatamem14debug[0]=(((r).cbpdatamem14debug[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))

/*
 * These macros can be used to access CBPDATAMEM14DEBUG.
 *
 */
#define BCM56504_A0_READ_CBPDATAMEM14DEBUGr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_CBPDATAMEM14DEBUGr,(r._cbpdatamem14debug))
#define BCM56504_A0_WRITE_CBPDATAMEM14DEBUGr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_CBPDATAMEM14DEBUGr,&(r._cbpdatamem14debug))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CBPDATAMEM14DEBUGr BCM56504_A0_CBPDATAMEM14DEBUGr
#define CBPDATAMEM14DEBUGr_SIZE BCM56504_A0_CBPDATAMEM14DEBUGr_SIZE
typedef BCM56504_A0_CBPDATAMEM14DEBUGr_t CBPDATAMEM14DEBUGr_t;
#define CBPDATAMEM14DEBUGr_CLR BCM56504_A0_CBPDATAMEM14DEBUGr_CLR
#define CBPDATAMEM14DEBUGr_SET BCM56504_A0_CBPDATAMEM14DEBUGr_SET
#define CBPDATAMEM14DEBUGr_GET BCM56504_A0_CBPDATAMEM14DEBUGr_GET
#define CBPDATAMEM14DEBUGr_SAMf_GET BCM56504_A0_CBPDATAMEM14DEBUGr_SAMf_GET
#define CBPDATAMEM14DEBUGr_SAMf_SET BCM56504_A0_CBPDATAMEM14DEBUGr_SAMf_SET
#define CBPDATAMEM14DEBUGr_CT0f_GET BCM56504_A0_CBPDATAMEM14DEBUGr_CT0f_GET
#define CBPDATAMEM14DEBUGr_CT0f_SET BCM56504_A0_CBPDATAMEM14DEBUGr_CT0f_SET
#define CBPDATAMEM14DEBUGr_CT3f_GET BCM56504_A0_CBPDATAMEM14DEBUGr_CT3f_GET
#define CBPDATAMEM14DEBUGr_CT3f_SET BCM56504_A0_CBPDATAMEM14DEBUGr_CT3f_SET
#define CBPDATAMEM14DEBUGr_CT2f_GET BCM56504_A0_CBPDATAMEM14DEBUGr_CT2f_GET
#define CBPDATAMEM14DEBUGr_CT2f_SET BCM56504_A0_CBPDATAMEM14DEBUGr_CT2f_SET
#define READ_CBPDATAMEM14DEBUGr BCM56504_A0_READ_CBPDATAMEM14DEBUGr
#define WRITE_CBPDATAMEM14DEBUGr BCM56504_A0_WRITE_CBPDATAMEM14DEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CBPDATAMEM14DEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CBPDATAMEM15DEBUG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     SAM              sam registers.
 *     CT0              ct0 registers.
 *     CT3              ct1 registers.
 *     CT2              ct2 registers.
 *
 ******************************************************************************/
#define BCM56504_A0_CBPDATAMEM15DEBUGr 0x0068004f

#define BCM56504_A0_CBPDATAMEM15DEBUGr_SIZE 4

/*
 * This structure should be used to declare and program CBPDATAMEM15DEBUG.
 *
 */
typedef union BCM56504_A0_CBPDATAMEM15DEBUGr_s {
	uint32_t v[1];
	uint32_t cbpdatamem15debug[1];
	uint32_t _cbpdatamem15debug;
} BCM56504_A0_CBPDATAMEM15DEBUGr_t;

#define BCM56504_A0_CBPDATAMEM15DEBUGr_CLR(r) (r).cbpdatamem15debug[0] = 0
#define BCM56504_A0_CBPDATAMEM15DEBUGr_SET(r,d) (r).cbpdatamem15debug[0] = d
#define BCM56504_A0_CBPDATAMEM15DEBUGr_GET(r) (r).cbpdatamem15debug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CBPDATAMEM15DEBUGr_SAMf_GET(r) (((r).cbpdatamem15debug[0]) & 0x3)
#define BCM56504_A0_CBPDATAMEM15DEBUGr_SAMf_SET(r,f) (r).cbpdatamem15debug[0]=(((r).cbpdatamem15debug[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56504_A0_CBPDATAMEM15DEBUGr_CT0f_GET(r) ((((r).cbpdatamem15debug[0]) >> 2) & 0x1)
#define BCM56504_A0_CBPDATAMEM15DEBUGr_CT0f_SET(r,f) (r).cbpdatamem15debug[0]=(((r).cbpdatamem15debug[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_CBPDATAMEM15DEBUGr_CT3f_GET(r) ((((r).cbpdatamem15debug[0]) >> 3) & 0x1)
#define BCM56504_A0_CBPDATAMEM15DEBUGr_CT3f_SET(r,f) (r).cbpdatamem15debug[0]=(((r).cbpdatamem15debug[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_CBPDATAMEM15DEBUGr_CT2f_GET(r) ((((r).cbpdatamem15debug[0]) >> 4) & 0x1)
#define BCM56504_A0_CBPDATAMEM15DEBUGr_CT2f_SET(r,f) (r).cbpdatamem15debug[0]=(((r).cbpdatamem15debug[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))

/*
 * These macros can be used to access CBPDATAMEM15DEBUG.
 *
 */
#define BCM56504_A0_READ_CBPDATAMEM15DEBUGr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_CBPDATAMEM15DEBUGr,(r._cbpdatamem15debug))
#define BCM56504_A0_WRITE_CBPDATAMEM15DEBUGr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_CBPDATAMEM15DEBUGr,&(r._cbpdatamem15debug))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CBPDATAMEM15DEBUGr BCM56504_A0_CBPDATAMEM15DEBUGr
#define CBPDATAMEM15DEBUGr_SIZE BCM56504_A0_CBPDATAMEM15DEBUGr_SIZE
typedef BCM56504_A0_CBPDATAMEM15DEBUGr_t CBPDATAMEM15DEBUGr_t;
#define CBPDATAMEM15DEBUGr_CLR BCM56504_A0_CBPDATAMEM15DEBUGr_CLR
#define CBPDATAMEM15DEBUGr_SET BCM56504_A0_CBPDATAMEM15DEBUGr_SET
#define CBPDATAMEM15DEBUGr_GET BCM56504_A0_CBPDATAMEM15DEBUGr_GET
#define CBPDATAMEM15DEBUGr_SAMf_GET BCM56504_A0_CBPDATAMEM15DEBUGr_SAMf_GET
#define CBPDATAMEM15DEBUGr_SAMf_SET BCM56504_A0_CBPDATAMEM15DEBUGr_SAMf_SET
#define CBPDATAMEM15DEBUGr_CT0f_GET BCM56504_A0_CBPDATAMEM15DEBUGr_CT0f_GET
#define CBPDATAMEM15DEBUGr_CT0f_SET BCM56504_A0_CBPDATAMEM15DEBUGr_CT0f_SET
#define CBPDATAMEM15DEBUGr_CT3f_GET BCM56504_A0_CBPDATAMEM15DEBUGr_CT3f_GET
#define CBPDATAMEM15DEBUGr_CT3f_SET BCM56504_A0_CBPDATAMEM15DEBUGr_CT3f_SET
#define CBPDATAMEM15DEBUGr_CT2f_GET BCM56504_A0_CBPDATAMEM15DEBUGr_CT2f_GET
#define CBPDATAMEM15DEBUGr_CT2f_SET BCM56504_A0_CBPDATAMEM15DEBUGr_CT2f_SET
#define READ_CBPDATAMEM15DEBUGr BCM56504_A0_READ_CBPDATAMEM15DEBUGr
#define WRITE_CBPDATAMEM15DEBUGr BCM56504_A0_WRITE_CBPDATAMEM15DEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CBPDATAMEM15DEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CBPDATAMEM1DEBUG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     SAM              sam registers.
 *     CT0              ct0 registers.
 *     CT3              ct1 registers.
 *     CT2              ct2 registers.
 *
 ******************************************************************************/
#define BCM56504_A0_CBPDATAMEM1DEBUGr 0x00680041

#define BCM56504_A0_CBPDATAMEM1DEBUGr_SIZE 4

/*
 * This structure should be used to declare and program CBPDATAMEM1DEBUG.
 *
 */
typedef union BCM56504_A0_CBPDATAMEM1DEBUGr_s {
	uint32_t v[1];
	uint32_t cbpdatamem1debug[1];
	uint32_t _cbpdatamem1debug;
} BCM56504_A0_CBPDATAMEM1DEBUGr_t;

#define BCM56504_A0_CBPDATAMEM1DEBUGr_CLR(r) (r).cbpdatamem1debug[0] = 0
#define BCM56504_A0_CBPDATAMEM1DEBUGr_SET(r,d) (r).cbpdatamem1debug[0] = d
#define BCM56504_A0_CBPDATAMEM1DEBUGr_GET(r) (r).cbpdatamem1debug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CBPDATAMEM1DEBUGr_SAMf_GET(r) (((r).cbpdatamem1debug[0]) & 0x3)
#define BCM56504_A0_CBPDATAMEM1DEBUGr_SAMf_SET(r,f) (r).cbpdatamem1debug[0]=(((r).cbpdatamem1debug[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56504_A0_CBPDATAMEM1DEBUGr_CT0f_GET(r) ((((r).cbpdatamem1debug[0]) >> 2) & 0x1)
#define BCM56504_A0_CBPDATAMEM1DEBUGr_CT0f_SET(r,f) (r).cbpdatamem1debug[0]=(((r).cbpdatamem1debug[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_CBPDATAMEM1DEBUGr_CT3f_GET(r) ((((r).cbpdatamem1debug[0]) >> 3) & 0x1)
#define BCM56504_A0_CBPDATAMEM1DEBUGr_CT3f_SET(r,f) (r).cbpdatamem1debug[0]=(((r).cbpdatamem1debug[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_CBPDATAMEM1DEBUGr_CT2f_GET(r) ((((r).cbpdatamem1debug[0]) >> 4) & 0x1)
#define BCM56504_A0_CBPDATAMEM1DEBUGr_CT2f_SET(r,f) (r).cbpdatamem1debug[0]=(((r).cbpdatamem1debug[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))

/*
 * These macros can be used to access CBPDATAMEM1DEBUG.
 *
 */
#define BCM56504_A0_READ_CBPDATAMEM1DEBUGr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_CBPDATAMEM1DEBUGr,(r._cbpdatamem1debug))
#define BCM56504_A0_WRITE_CBPDATAMEM1DEBUGr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_CBPDATAMEM1DEBUGr,&(r._cbpdatamem1debug))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CBPDATAMEM1DEBUGr BCM56504_A0_CBPDATAMEM1DEBUGr
#define CBPDATAMEM1DEBUGr_SIZE BCM56504_A0_CBPDATAMEM1DEBUGr_SIZE
typedef BCM56504_A0_CBPDATAMEM1DEBUGr_t CBPDATAMEM1DEBUGr_t;
#define CBPDATAMEM1DEBUGr_CLR BCM56504_A0_CBPDATAMEM1DEBUGr_CLR
#define CBPDATAMEM1DEBUGr_SET BCM56504_A0_CBPDATAMEM1DEBUGr_SET
#define CBPDATAMEM1DEBUGr_GET BCM56504_A0_CBPDATAMEM1DEBUGr_GET
#define CBPDATAMEM1DEBUGr_SAMf_GET BCM56504_A0_CBPDATAMEM1DEBUGr_SAMf_GET
#define CBPDATAMEM1DEBUGr_SAMf_SET BCM56504_A0_CBPDATAMEM1DEBUGr_SAMf_SET
#define CBPDATAMEM1DEBUGr_CT0f_GET BCM56504_A0_CBPDATAMEM1DEBUGr_CT0f_GET
#define CBPDATAMEM1DEBUGr_CT0f_SET BCM56504_A0_CBPDATAMEM1DEBUGr_CT0f_SET
#define CBPDATAMEM1DEBUGr_CT3f_GET BCM56504_A0_CBPDATAMEM1DEBUGr_CT3f_GET
#define CBPDATAMEM1DEBUGr_CT3f_SET BCM56504_A0_CBPDATAMEM1DEBUGr_CT3f_SET
#define CBPDATAMEM1DEBUGr_CT2f_GET BCM56504_A0_CBPDATAMEM1DEBUGr_CT2f_GET
#define CBPDATAMEM1DEBUGr_CT2f_SET BCM56504_A0_CBPDATAMEM1DEBUGr_CT2f_SET
#define READ_CBPDATAMEM1DEBUGr BCM56504_A0_READ_CBPDATAMEM1DEBUGr
#define WRITE_CBPDATAMEM1DEBUGr BCM56504_A0_WRITE_CBPDATAMEM1DEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CBPDATAMEM1DEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CBPDATAMEM2DEBUG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     SAM              sam registers.
 *     CT0              ct0 registers.
 *     CT3              ct1 registers.
 *     CT2              ct2 registers.
 *
 ******************************************************************************/
#define BCM56504_A0_CBPDATAMEM2DEBUGr 0x00680042

#define BCM56504_A0_CBPDATAMEM2DEBUGr_SIZE 4

/*
 * This structure should be used to declare and program CBPDATAMEM2DEBUG.
 *
 */
typedef union BCM56504_A0_CBPDATAMEM2DEBUGr_s {
	uint32_t v[1];
	uint32_t cbpdatamem2debug[1];
	uint32_t _cbpdatamem2debug;
} BCM56504_A0_CBPDATAMEM2DEBUGr_t;

#define BCM56504_A0_CBPDATAMEM2DEBUGr_CLR(r) (r).cbpdatamem2debug[0] = 0
#define BCM56504_A0_CBPDATAMEM2DEBUGr_SET(r,d) (r).cbpdatamem2debug[0] = d
#define BCM56504_A0_CBPDATAMEM2DEBUGr_GET(r) (r).cbpdatamem2debug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CBPDATAMEM2DEBUGr_SAMf_GET(r) (((r).cbpdatamem2debug[0]) & 0x3)
#define BCM56504_A0_CBPDATAMEM2DEBUGr_SAMf_SET(r,f) (r).cbpdatamem2debug[0]=(((r).cbpdatamem2debug[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56504_A0_CBPDATAMEM2DEBUGr_CT0f_GET(r) ((((r).cbpdatamem2debug[0]) >> 2) & 0x1)
#define BCM56504_A0_CBPDATAMEM2DEBUGr_CT0f_SET(r,f) (r).cbpdatamem2debug[0]=(((r).cbpdatamem2debug[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_CBPDATAMEM2DEBUGr_CT3f_GET(r) ((((r).cbpdatamem2debug[0]) >> 3) & 0x1)
#define BCM56504_A0_CBPDATAMEM2DEBUGr_CT3f_SET(r,f) (r).cbpdatamem2debug[0]=(((r).cbpdatamem2debug[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_CBPDATAMEM2DEBUGr_CT2f_GET(r) ((((r).cbpdatamem2debug[0]) >> 4) & 0x1)
#define BCM56504_A0_CBPDATAMEM2DEBUGr_CT2f_SET(r,f) (r).cbpdatamem2debug[0]=(((r).cbpdatamem2debug[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))

/*
 * These macros can be used to access CBPDATAMEM2DEBUG.
 *
 */
#define BCM56504_A0_READ_CBPDATAMEM2DEBUGr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_CBPDATAMEM2DEBUGr,(r._cbpdatamem2debug))
#define BCM56504_A0_WRITE_CBPDATAMEM2DEBUGr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_CBPDATAMEM2DEBUGr,&(r._cbpdatamem2debug))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CBPDATAMEM2DEBUGr BCM56504_A0_CBPDATAMEM2DEBUGr
#define CBPDATAMEM2DEBUGr_SIZE BCM56504_A0_CBPDATAMEM2DEBUGr_SIZE
typedef BCM56504_A0_CBPDATAMEM2DEBUGr_t CBPDATAMEM2DEBUGr_t;
#define CBPDATAMEM2DEBUGr_CLR BCM56504_A0_CBPDATAMEM2DEBUGr_CLR
#define CBPDATAMEM2DEBUGr_SET BCM56504_A0_CBPDATAMEM2DEBUGr_SET
#define CBPDATAMEM2DEBUGr_GET BCM56504_A0_CBPDATAMEM2DEBUGr_GET
#define CBPDATAMEM2DEBUGr_SAMf_GET BCM56504_A0_CBPDATAMEM2DEBUGr_SAMf_GET
#define CBPDATAMEM2DEBUGr_SAMf_SET BCM56504_A0_CBPDATAMEM2DEBUGr_SAMf_SET
#define CBPDATAMEM2DEBUGr_CT0f_GET BCM56504_A0_CBPDATAMEM2DEBUGr_CT0f_GET
#define CBPDATAMEM2DEBUGr_CT0f_SET BCM56504_A0_CBPDATAMEM2DEBUGr_CT0f_SET
#define CBPDATAMEM2DEBUGr_CT3f_GET BCM56504_A0_CBPDATAMEM2DEBUGr_CT3f_GET
#define CBPDATAMEM2DEBUGr_CT3f_SET BCM56504_A0_CBPDATAMEM2DEBUGr_CT3f_SET
#define CBPDATAMEM2DEBUGr_CT2f_GET BCM56504_A0_CBPDATAMEM2DEBUGr_CT2f_GET
#define CBPDATAMEM2DEBUGr_CT2f_SET BCM56504_A0_CBPDATAMEM2DEBUGr_CT2f_SET
#define READ_CBPDATAMEM2DEBUGr BCM56504_A0_READ_CBPDATAMEM2DEBUGr
#define WRITE_CBPDATAMEM2DEBUGr BCM56504_A0_WRITE_CBPDATAMEM2DEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CBPDATAMEM2DEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CBPDATAMEM3DEBUG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     SAM              sam registers.
 *     CT0              ct0 registers.
 *     CT3              ct1 registers.
 *     CT2              ct2 registers.
 *
 ******************************************************************************/
#define BCM56504_A0_CBPDATAMEM3DEBUGr 0x00680043

#define BCM56504_A0_CBPDATAMEM3DEBUGr_SIZE 4

/*
 * This structure should be used to declare and program CBPDATAMEM3DEBUG.
 *
 */
typedef union BCM56504_A0_CBPDATAMEM3DEBUGr_s {
	uint32_t v[1];
	uint32_t cbpdatamem3debug[1];
	uint32_t _cbpdatamem3debug;
} BCM56504_A0_CBPDATAMEM3DEBUGr_t;

#define BCM56504_A0_CBPDATAMEM3DEBUGr_CLR(r) (r).cbpdatamem3debug[0] = 0
#define BCM56504_A0_CBPDATAMEM3DEBUGr_SET(r,d) (r).cbpdatamem3debug[0] = d
#define BCM56504_A0_CBPDATAMEM3DEBUGr_GET(r) (r).cbpdatamem3debug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CBPDATAMEM3DEBUGr_SAMf_GET(r) (((r).cbpdatamem3debug[0]) & 0x3)
#define BCM56504_A0_CBPDATAMEM3DEBUGr_SAMf_SET(r,f) (r).cbpdatamem3debug[0]=(((r).cbpdatamem3debug[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56504_A0_CBPDATAMEM3DEBUGr_CT0f_GET(r) ((((r).cbpdatamem3debug[0]) >> 2) & 0x1)
#define BCM56504_A0_CBPDATAMEM3DEBUGr_CT0f_SET(r,f) (r).cbpdatamem3debug[0]=(((r).cbpdatamem3debug[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_CBPDATAMEM3DEBUGr_CT3f_GET(r) ((((r).cbpdatamem3debug[0]) >> 3) & 0x1)
#define BCM56504_A0_CBPDATAMEM3DEBUGr_CT3f_SET(r,f) (r).cbpdatamem3debug[0]=(((r).cbpdatamem3debug[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_CBPDATAMEM3DEBUGr_CT2f_GET(r) ((((r).cbpdatamem3debug[0]) >> 4) & 0x1)
#define BCM56504_A0_CBPDATAMEM3DEBUGr_CT2f_SET(r,f) (r).cbpdatamem3debug[0]=(((r).cbpdatamem3debug[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))

/*
 * These macros can be used to access CBPDATAMEM3DEBUG.
 *
 */
#define BCM56504_A0_READ_CBPDATAMEM3DEBUGr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_CBPDATAMEM3DEBUGr,(r._cbpdatamem3debug))
#define BCM56504_A0_WRITE_CBPDATAMEM3DEBUGr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_CBPDATAMEM3DEBUGr,&(r._cbpdatamem3debug))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CBPDATAMEM3DEBUGr BCM56504_A0_CBPDATAMEM3DEBUGr
#define CBPDATAMEM3DEBUGr_SIZE BCM56504_A0_CBPDATAMEM3DEBUGr_SIZE
typedef BCM56504_A0_CBPDATAMEM3DEBUGr_t CBPDATAMEM3DEBUGr_t;
#define CBPDATAMEM3DEBUGr_CLR BCM56504_A0_CBPDATAMEM3DEBUGr_CLR
#define CBPDATAMEM3DEBUGr_SET BCM56504_A0_CBPDATAMEM3DEBUGr_SET
#define CBPDATAMEM3DEBUGr_GET BCM56504_A0_CBPDATAMEM3DEBUGr_GET
#define CBPDATAMEM3DEBUGr_SAMf_GET BCM56504_A0_CBPDATAMEM3DEBUGr_SAMf_GET
#define CBPDATAMEM3DEBUGr_SAMf_SET BCM56504_A0_CBPDATAMEM3DEBUGr_SAMf_SET
#define CBPDATAMEM3DEBUGr_CT0f_GET BCM56504_A0_CBPDATAMEM3DEBUGr_CT0f_GET
#define CBPDATAMEM3DEBUGr_CT0f_SET BCM56504_A0_CBPDATAMEM3DEBUGr_CT0f_SET
#define CBPDATAMEM3DEBUGr_CT3f_GET BCM56504_A0_CBPDATAMEM3DEBUGr_CT3f_GET
#define CBPDATAMEM3DEBUGr_CT3f_SET BCM56504_A0_CBPDATAMEM3DEBUGr_CT3f_SET
#define CBPDATAMEM3DEBUGr_CT2f_GET BCM56504_A0_CBPDATAMEM3DEBUGr_CT2f_GET
#define CBPDATAMEM3DEBUGr_CT2f_SET BCM56504_A0_CBPDATAMEM3DEBUGr_CT2f_SET
#define READ_CBPDATAMEM3DEBUGr BCM56504_A0_READ_CBPDATAMEM3DEBUGr
#define WRITE_CBPDATAMEM3DEBUGr BCM56504_A0_WRITE_CBPDATAMEM3DEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CBPDATAMEM3DEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CBPDATAMEM4DEBUG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     SAM              sam registers.
 *     CT0              ct0 registers.
 *     CT3              ct1 registers.
 *     CT2              ct2 registers.
 *
 ******************************************************************************/
#define BCM56504_A0_CBPDATAMEM4DEBUGr 0x00680044

#define BCM56504_A0_CBPDATAMEM4DEBUGr_SIZE 4

/*
 * This structure should be used to declare and program CBPDATAMEM4DEBUG.
 *
 */
typedef union BCM56504_A0_CBPDATAMEM4DEBUGr_s {
	uint32_t v[1];
	uint32_t cbpdatamem4debug[1];
	uint32_t _cbpdatamem4debug;
} BCM56504_A0_CBPDATAMEM4DEBUGr_t;

#define BCM56504_A0_CBPDATAMEM4DEBUGr_CLR(r) (r).cbpdatamem4debug[0] = 0
#define BCM56504_A0_CBPDATAMEM4DEBUGr_SET(r,d) (r).cbpdatamem4debug[0] = d
#define BCM56504_A0_CBPDATAMEM4DEBUGr_GET(r) (r).cbpdatamem4debug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CBPDATAMEM4DEBUGr_SAMf_GET(r) (((r).cbpdatamem4debug[0]) & 0x3)
#define BCM56504_A0_CBPDATAMEM4DEBUGr_SAMf_SET(r,f) (r).cbpdatamem4debug[0]=(((r).cbpdatamem4debug[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56504_A0_CBPDATAMEM4DEBUGr_CT0f_GET(r) ((((r).cbpdatamem4debug[0]) >> 2) & 0x1)
#define BCM56504_A0_CBPDATAMEM4DEBUGr_CT0f_SET(r,f) (r).cbpdatamem4debug[0]=(((r).cbpdatamem4debug[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_CBPDATAMEM4DEBUGr_CT3f_GET(r) ((((r).cbpdatamem4debug[0]) >> 3) & 0x1)
#define BCM56504_A0_CBPDATAMEM4DEBUGr_CT3f_SET(r,f) (r).cbpdatamem4debug[0]=(((r).cbpdatamem4debug[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_CBPDATAMEM4DEBUGr_CT2f_GET(r) ((((r).cbpdatamem4debug[0]) >> 4) & 0x1)
#define BCM56504_A0_CBPDATAMEM4DEBUGr_CT2f_SET(r,f) (r).cbpdatamem4debug[0]=(((r).cbpdatamem4debug[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))

/*
 * These macros can be used to access CBPDATAMEM4DEBUG.
 *
 */
#define BCM56504_A0_READ_CBPDATAMEM4DEBUGr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_CBPDATAMEM4DEBUGr,(r._cbpdatamem4debug))
#define BCM56504_A0_WRITE_CBPDATAMEM4DEBUGr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_CBPDATAMEM4DEBUGr,&(r._cbpdatamem4debug))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CBPDATAMEM4DEBUGr BCM56504_A0_CBPDATAMEM4DEBUGr
#define CBPDATAMEM4DEBUGr_SIZE BCM56504_A0_CBPDATAMEM4DEBUGr_SIZE
typedef BCM56504_A0_CBPDATAMEM4DEBUGr_t CBPDATAMEM4DEBUGr_t;
#define CBPDATAMEM4DEBUGr_CLR BCM56504_A0_CBPDATAMEM4DEBUGr_CLR
#define CBPDATAMEM4DEBUGr_SET BCM56504_A0_CBPDATAMEM4DEBUGr_SET
#define CBPDATAMEM4DEBUGr_GET BCM56504_A0_CBPDATAMEM4DEBUGr_GET
#define CBPDATAMEM4DEBUGr_SAMf_GET BCM56504_A0_CBPDATAMEM4DEBUGr_SAMf_GET
#define CBPDATAMEM4DEBUGr_SAMf_SET BCM56504_A0_CBPDATAMEM4DEBUGr_SAMf_SET
#define CBPDATAMEM4DEBUGr_CT0f_GET BCM56504_A0_CBPDATAMEM4DEBUGr_CT0f_GET
#define CBPDATAMEM4DEBUGr_CT0f_SET BCM56504_A0_CBPDATAMEM4DEBUGr_CT0f_SET
#define CBPDATAMEM4DEBUGr_CT3f_GET BCM56504_A0_CBPDATAMEM4DEBUGr_CT3f_GET
#define CBPDATAMEM4DEBUGr_CT3f_SET BCM56504_A0_CBPDATAMEM4DEBUGr_CT3f_SET
#define CBPDATAMEM4DEBUGr_CT2f_GET BCM56504_A0_CBPDATAMEM4DEBUGr_CT2f_GET
#define CBPDATAMEM4DEBUGr_CT2f_SET BCM56504_A0_CBPDATAMEM4DEBUGr_CT2f_SET
#define READ_CBPDATAMEM4DEBUGr BCM56504_A0_READ_CBPDATAMEM4DEBUGr
#define WRITE_CBPDATAMEM4DEBUGr BCM56504_A0_WRITE_CBPDATAMEM4DEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CBPDATAMEM4DEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CBPDATAMEM5DEBUG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     SAM              sam registers.
 *     CT0              ct0 registers.
 *     CT3              ct1 registers.
 *     CT2              ct2 registers.
 *
 ******************************************************************************/
#define BCM56504_A0_CBPDATAMEM5DEBUGr 0x00680045

#define BCM56504_A0_CBPDATAMEM5DEBUGr_SIZE 4

/*
 * This structure should be used to declare and program CBPDATAMEM5DEBUG.
 *
 */
typedef union BCM56504_A0_CBPDATAMEM5DEBUGr_s {
	uint32_t v[1];
	uint32_t cbpdatamem5debug[1];
	uint32_t _cbpdatamem5debug;
} BCM56504_A0_CBPDATAMEM5DEBUGr_t;

#define BCM56504_A0_CBPDATAMEM5DEBUGr_CLR(r) (r).cbpdatamem5debug[0] = 0
#define BCM56504_A0_CBPDATAMEM5DEBUGr_SET(r,d) (r).cbpdatamem5debug[0] = d
#define BCM56504_A0_CBPDATAMEM5DEBUGr_GET(r) (r).cbpdatamem5debug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CBPDATAMEM5DEBUGr_SAMf_GET(r) (((r).cbpdatamem5debug[0]) & 0x3)
#define BCM56504_A0_CBPDATAMEM5DEBUGr_SAMf_SET(r,f) (r).cbpdatamem5debug[0]=(((r).cbpdatamem5debug[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56504_A0_CBPDATAMEM5DEBUGr_CT0f_GET(r) ((((r).cbpdatamem5debug[0]) >> 2) & 0x1)
#define BCM56504_A0_CBPDATAMEM5DEBUGr_CT0f_SET(r,f) (r).cbpdatamem5debug[0]=(((r).cbpdatamem5debug[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_CBPDATAMEM5DEBUGr_CT3f_GET(r) ((((r).cbpdatamem5debug[0]) >> 3) & 0x1)
#define BCM56504_A0_CBPDATAMEM5DEBUGr_CT3f_SET(r,f) (r).cbpdatamem5debug[0]=(((r).cbpdatamem5debug[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_CBPDATAMEM5DEBUGr_CT2f_GET(r) ((((r).cbpdatamem5debug[0]) >> 4) & 0x1)
#define BCM56504_A0_CBPDATAMEM5DEBUGr_CT2f_SET(r,f) (r).cbpdatamem5debug[0]=(((r).cbpdatamem5debug[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))

/*
 * These macros can be used to access CBPDATAMEM5DEBUG.
 *
 */
#define BCM56504_A0_READ_CBPDATAMEM5DEBUGr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_CBPDATAMEM5DEBUGr,(r._cbpdatamem5debug))
#define BCM56504_A0_WRITE_CBPDATAMEM5DEBUGr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_CBPDATAMEM5DEBUGr,&(r._cbpdatamem5debug))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CBPDATAMEM5DEBUGr BCM56504_A0_CBPDATAMEM5DEBUGr
#define CBPDATAMEM5DEBUGr_SIZE BCM56504_A0_CBPDATAMEM5DEBUGr_SIZE
typedef BCM56504_A0_CBPDATAMEM5DEBUGr_t CBPDATAMEM5DEBUGr_t;
#define CBPDATAMEM5DEBUGr_CLR BCM56504_A0_CBPDATAMEM5DEBUGr_CLR
#define CBPDATAMEM5DEBUGr_SET BCM56504_A0_CBPDATAMEM5DEBUGr_SET
#define CBPDATAMEM5DEBUGr_GET BCM56504_A0_CBPDATAMEM5DEBUGr_GET
#define CBPDATAMEM5DEBUGr_SAMf_GET BCM56504_A0_CBPDATAMEM5DEBUGr_SAMf_GET
#define CBPDATAMEM5DEBUGr_SAMf_SET BCM56504_A0_CBPDATAMEM5DEBUGr_SAMf_SET
#define CBPDATAMEM5DEBUGr_CT0f_GET BCM56504_A0_CBPDATAMEM5DEBUGr_CT0f_GET
#define CBPDATAMEM5DEBUGr_CT0f_SET BCM56504_A0_CBPDATAMEM5DEBUGr_CT0f_SET
#define CBPDATAMEM5DEBUGr_CT3f_GET BCM56504_A0_CBPDATAMEM5DEBUGr_CT3f_GET
#define CBPDATAMEM5DEBUGr_CT3f_SET BCM56504_A0_CBPDATAMEM5DEBUGr_CT3f_SET
#define CBPDATAMEM5DEBUGr_CT2f_GET BCM56504_A0_CBPDATAMEM5DEBUGr_CT2f_GET
#define CBPDATAMEM5DEBUGr_CT2f_SET BCM56504_A0_CBPDATAMEM5DEBUGr_CT2f_SET
#define READ_CBPDATAMEM5DEBUGr BCM56504_A0_READ_CBPDATAMEM5DEBUGr
#define WRITE_CBPDATAMEM5DEBUGr BCM56504_A0_WRITE_CBPDATAMEM5DEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CBPDATAMEM5DEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CBPDATAMEM6DEBUG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     SAM              sam registers.
 *     CT0              ct0 registers.
 *     CT3              ct1 registers.
 *     CT2              ct2 registers.
 *
 ******************************************************************************/
#define BCM56504_A0_CBPDATAMEM6DEBUGr 0x00680046

#define BCM56504_A0_CBPDATAMEM6DEBUGr_SIZE 4

/*
 * This structure should be used to declare and program CBPDATAMEM6DEBUG.
 *
 */
typedef union BCM56504_A0_CBPDATAMEM6DEBUGr_s {
	uint32_t v[1];
	uint32_t cbpdatamem6debug[1];
	uint32_t _cbpdatamem6debug;
} BCM56504_A0_CBPDATAMEM6DEBUGr_t;

#define BCM56504_A0_CBPDATAMEM6DEBUGr_CLR(r) (r).cbpdatamem6debug[0] = 0
#define BCM56504_A0_CBPDATAMEM6DEBUGr_SET(r,d) (r).cbpdatamem6debug[0] = d
#define BCM56504_A0_CBPDATAMEM6DEBUGr_GET(r) (r).cbpdatamem6debug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CBPDATAMEM6DEBUGr_SAMf_GET(r) (((r).cbpdatamem6debug[0]) & 0x3)
#define BCM56504_A0_CBPDATAMEM6DEBUGr_SAMf_SET(r,f) (r).cbpdatamem6debug[0]=(((r).cbpdatamem6debug[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56504_A0_CBPDATAMEM6DEBUGr_CT0f_GET(r) ((((r).cbpdatamem6debug[0]) >> 2) & 0x1)
#define BCM56504_A0_CBPDATAMEM6DEBUGr_CT0f_SET(r,f) (r).cbpdatamem6debug[0]=(((r).cbpdatamem6debug[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_CBPDATAMEM6DEBUGr_CT3f_GET(r) ((((r).cbpdatamem6debug[0]) >> 3) & 0x1)
#define BCM56504_A0_CBPDATAMEM6DEBUGr_CT3f_SET(r,f) (r).cbpdatamem6debug[0]=(((r).cbpdatamem6debug[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_CBPDATAMEM6DEBUGr_CT2f_GET(r) ((((r).cbpdatamem6debug[0]) >> 4) & 0x1)
#define BCM56504_A0_CBPDATAMEM6DEBUGr_CT2f_SET(r,f) (r).cbpdatamem6debug[0]=(((r).cbpdatamem6debug[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))

/*
 * These macros can be used to access CBPDATAMEM6DEBUG.
 *
 */
#define BCM56504_A0_READ_CBPDATAMEM6DEBUGr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_CBPDATAMEM6DEBUGr,(r._cbpdatamem6debug))
#define BCM56504_A0_WRITE_CBPDATAMEM6DEBUGr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_CBPDATAMEM6DEBUGr,&(r._cbpdatamem6debug))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CBPDATAMEM6DEBUGr BCM56504_A0_CBPDATAMEM6DEBUGr
#define CBPDATAMEM6DEBUGr_SIZE BCM56504_A0_CBPDATAMEM6DEBUGr_SIZE
typedef BCM56504_A0_CBPDATAMEM6DEBUGr_t CBPDATAMEM6DEBUGr_t;
#define CBPDATAMEM6DEBUGr_CLR BCM56504_A0_CBPDATAMEM6DEBUGr_CLR
#define CBPDATAMEM6DEBUGr_SET BCM56504_A0_CBPDATAMEM6DEBUGr_SET
#define CBPDATAMEM6DEBUGr_GET BCM56504_A0_CBPDATAMEM6DEBUGr_GET
#define CBPDATAMEM6DEBUGr_SAMf_GET BCM56504_A0_CBPDATAMEM6DEBUGr_SAMf_GET
#define CBPDATAMEM6DEBUGr_SAMf_SET BCM56504_A0_CBPDATAMEM6DEBUGr_SAMf_SET
#define CBPDATAMEM6DEBUGr_CT0f_GET BCM56504_A0_CBPDATAMEM6DEBUGr_CT0f_GET
#define CBPDATAMEM6DEBUGr_CT0f_SET BCM56504_A0_CBPDATAMEM6DEBUGr_CT0f_SET
#define CBPDATAMEM6DEBUGr_CT3f_GET BCM56504_A0_CBPDATAMEM6DEBUGr_CT3f_GET
#define CBPDATAMEM6DEBUGr_CT3f_SET BCM56504_A0_CBPDATAMEM6DEBUGr_CT3f_SET
#define CBPDATAMEM6DEBUGr_CT2f_GET BCM56504_A0_CBPDATAMEM6DEBUGr_CT2f_GET
#define CBPDATAMEM6DEBUGr_CT2f_SET BCM56504_A0_CBPDATAMEM6DEBUGr_CT2f_SET
#define READ_CBPDATAMEM6DEBUGr BCM56504_A0_READ_CBPDATAMEM6DEBUGr
#define WRITE_CBPDATAMEM6DEBUGr BCM56504_A0_WRITE_CBPDATAMEM6DEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CBPDATAMEM6DEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CBPDATAMEM7DEBUG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     SAM              sam registers.
 *     CT0              ct0 registers.
 *     CT3              ct1 registers.
 *     CT2              ct2 registers.
 *
 ******************************************************************************/
#define BCM56504_A0_CBPDATAMEM7DEBUGr 0x00680047

#define BCM56504_A0_CBPDATAMEM7DEBUGr_SIZE 4

/*
 * This structure should be used to declare and program CBPDATAMEM7DEBUG.
 *
 */
typedef union BCM56504_A0_CBPDATAMEM7DEBUGr_s {
	uint32_t v[1];
	uint32_t cbpdatamem7debug[1];
	uint32_t _cbpdatamem7debug;
} BCM56504_A0_CBPDATAMEM7DEBUGr_t;

#define BCM56504_A0_CBPDATAMEM7DEBUGr_CLR(r) (r).cbpdatamem7debug[0] = 0
#define BCM56504_A0_CBPDATAMEM7DEBUGr_SET(r,d) (r).cbpdatamem7debug[0] = d
#define BCM56504_A0_CBPDATAMEM7DEBUGr_GET(r) (r).cbpdatamem7debug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CBPDATAMEM7DEBUGr_SAMf_GET(r) (((r).cbpdatamem7debug[0]) & 0x3)
#define BCM56504_A0_CBPDATAMEM7DEBUGr_SAMf_SET(r,f) (r).cbpdatamem7debug[0]=(((r).cbpdatamem7debug[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56504_A0_CBPDATAMEM7DEBUGr_CT0f_GET(r) ((((r).cbpdatamem7debug[0]) >> 2) & 0x1)
#define BCM56504_A0_CBPDATAMEM7DEBUGr_CT0f_SET(r,f) (r).cbpdatamem7debug[0]=(((r).cbpdatamem7debug[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_CBPDATAMEM7DEBUGr_CT3f_GET(r) ((((r).cbpdatamem7debug[0]) >> 3) & 0x1)
#define BCM56504_A0_CBPDATAMEM7DEBUGr_CT3f_SET(r,f) (r).cbpdatamem7debug[0]=(((r).cbpdatamem7debug[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_CBPDATAMEM7DEBUGr_CT2f_GET(r) ((((r).cbpdatamem7debug[0]) >> 4) & 0x1)
#define BCM56504_A0_CBPDATAMEM7DEBUGr_CT2f_SET(r,f) (r).cbpdatamem7debug[0]=(((r).cbpdatamem7debug[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))

/*
 * These macros can be used to access CBPDATAMEM7DEBUG.
 *
 */
#define BCM56504_A0_READ_CBPDATAMEM7DEBUGr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_CBPDATAMEM7DEBUGr,(r._cbpdatamem7debug))
#define BCM56504_A0_WRITE_CBPDATAMEM7DEBUGr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_CBPDATAMEM7DEBUGr,&(r._cbpdatamem7debug))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CBPDATAMEM7DEBUGr BCM56504_A0_CBPDATAMEM7DEBUGr
#define CBPDATAMEM7DEBUGr_SIZE BCM56504_A0_CBPDATAMEM7DEBUGr_SIZE
typedef BCM56504_A0_CBPDATAMEM7DEBUGr_t CBPDATAMEM7DEBUGr_t;
#define CBPDATAMEM7DEBUGr_CLR BCM56504_A0_CBPDATAMEM7DEBUGr_CLR
#define CBPDATAMEM7DEBUGr_SET BCM56504_A0_CBPDATAMEM7DEBUGr_SET
#define CBPDATAMEM7DEBUGr_GET BCM56504_A0_CBPDATAMEM7DEBUGr_GET
#define CBPDATAMEM7DEBUGr_SAMf_GET BCM56504_A0_CBPDATAMEM7DEBUGr_SAMf_GET
#define CBPDATAMEM7DEBUGr_SAMf_SET BCM56504_A0_CBPDATAMEM7DEBUGr_SAMf_SET
#define CBPDATAMEM7DEBUGr_CT0f_GET BCM56504_A0_CBPDATAMEM7DEBUGr_CT0f_GET
#define CBPDATAMEM7DEBUGr_CT0f_SET BCM56504_A0_CBPDATAMEM7DEBUGr_CT0f_SET
#define CBPDATAMEM7DEBUGr_CT3f_GET BCM56504_A0_CBPDATAMEM7DEBUGr_CT3f_GET
#define CBPDATAMEM7DEBUGr_CT3f_SET BCM56504_A0_CBPDATAMEM7DEBUGr_CT3f_SET
#define CBPDATAMEM7DEBUGr_CT2f_GET BCM56504_A0_CBPDATAMEM7DEBUGr_CT2f_GET
#define CBPDATAMEM7DEBUGr_CT2f_SET BCM56504_A0_CBPDATAMEM7DEBUGr_CT2f_SET
#define READ_CBPDATAMEM7DEBUGr BCM56504_A0_READ_CBPDATAMEM7DEBUGr
#define WRITE_CBPDATAMEM7DEBUGr BCM56504_A0_WRITE_CBPDATAMEM7DEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CBPDATAMEM7DEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CBPDATAMEM8DEBUG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     SAM              sam registers.
 *     CT0              ct0 registers.
 *     CT3              ct1 registers.
 *     CT2              ct2 registers.
 *
 ******************************************************************************/
#define BCM56504_A0_CBPDATAMEM8DEBUGr 0x00680048

#define BCM56504_A0_CBPDATAMEM8DEBUGr_SIZE 4

/*
 * This structure should be used to declare and program CBPDATAMEM8DEBUG.
 *
 */
typedef union BCM56504_A0_CBPDATAMEM8DEBUGr_s {
	uint32_t v[1];
	uint32_t cbpdatamem8debug[1];
	uint32_t _cbpdatamem8debug;
} BCM56504_A0_CBPDATAMEM8DEBUGr_t;

#define BCM56504_A0_CBPDATAMEM8DEBUGr_CLR(r) (r).cbpdatamem8debug[0] = 0
#define BCM56504_A0_CBPDATAMEM8DEBUGr_SET(r,d) (r).cbpdatamem8debug[0] = d
#define BCM56504_A0_CBPDATAMEM8DEBUGr_GET(r) (r).cbpdatamem8debug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CBPDATAMEM8DEBUGr_SAMf_GET(r) (((r).cbpdatamem8debug[0]) & 0x3)
#define BCM56504_A0_CBPDATAMEM8DEBUGr_SAMf_SET(r,f) (r).cbpdatamem8debug[0]=(((r).cbpdatamem8debug[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56504_A0_CBPDATAMEM8DEBUGr_CT0f_GET(r) ((((r).cbpdatamem8debug[0]) >> 2) & 0x1)
#define BCM56504_A0_CBPDATAMEM8DEBUGr_CT0f_SET(r,f) (r).cbpdatamem8debug[0]=(((r).cbpdatamem8debug[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_CBPDATAMEM8DEBUGr_CT3f_GET(r) ((((r).cbpdatamem8debug[0]) >> 3) & 0x1)
#define BCM56504_A0_CBPDATAMEM8DEBUGr_CT3f_SET(r,f) (r).cbpdatamem8debug[0]=(((r).cbpdatamem8debug[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_CBPDATAMEM8DEBUGr_CT2f_GET(r) ((((r).cbpdatamem8debug[0]) >> 4) & 0x1)
#define BCM56504_A0_CBPDATAMEM8DEBUGr_CT2f_SET(r,f) (r).cbpdatamem8debug[0]=(((r).cbpdatamem8debug[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))

/*
 * These macros can be used to access CBPDATAMEM8DEBUG.
 *
 */
#define BCM56504_A0_READ_CBPDATAMEM8DEBUGr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_CBPDATAMEM8DEBUGr,(r._cbpdatamem8debug))
#define BCM56504_A0_WRITE_CBPDATAMEM8DEBUGr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_CBPDATAMEM8DEBUGr,&(r._cbpdatamem8debug))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CBPDATAMEM8DEBUGr BCM56504_A0_CBPDATAMEM8DEBUGr
#define CBPDATAMEM8DEBUGr_SIZE BCM56504_A0_CBPDATAMEM8DEBUGr_SIZE
typedef BCM56504_A0_CBPDATAMEM8DEBUGr_t CBPDATAMEM8DEBUGr_t;
#define CBPDATAMEM8DEBUGr_CLR BCM56504_A0_CBPDATAMEM8DEBUGr_CLR
#define CBPDATAMEM8DEBUGr_SET BCM56504_A0_CBPDATAMEM8DEBUGr_SET
#define CBPDATAMEM8DEBUGr_GET BCM56504_A0_CBPDATAMEM8DEBUGr_GET
#define CBPDATAMEM8DEBUGr_SAMf_GET BCM56504_A0_CBPDATAMEM8DEBUGr_SAMf_GET
#define CBPDATAMEM8DEBUGr_SAMf_SET BCM56504_A0_CBPDATAMEM8DEBUGr_SAMf_SET
#define CBPDATAMEM8DEBUGr_CT0f_GET BCM56504_A0_CBPDATAMEM8DEBUGr_CT0f_GET
#define CBPDATAMEM8DEBUGr_CT0f_SET BCM56504_A0_CBPDATAMEM8DEBUGr_CT0f_SET
#define CBPDATAMEM8DEBUGr_CT3f_GET BCM56504_A0_CBPDATAMEM8DEBUGr_CT3f_GET
#define CBPDATAMEM8DEBUGr_CT3f_SET BCM56504_A0_CBPDATAMEM8DEBUGr_CT3f_SET
#define CBPDATAMEM8DEBUGr_CT2f_GET BCM56504_A0_CBPDATAMEM8DEBUGr_CT2f_GET
#define CBPDATAMEM8DEBUGr_CT2f_SET BCM56504_A0_CBPDATAMEM8DEBUGr_CT2f_SET
#define READ_CBPDATAMEM8DEBUGr BCM56504_A0_READ_CBPDATAMEM8DEBUGr
#define WRITE_CBPDATAMEM8DEBUGr BCM56504_A0_WRITE_CBPDATAMEM8DEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CBPDATAMEM8DEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CBPDATAMEM9DEBUG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     SAM              sam registers.
 *     CT0              ct0 registers.
 *     CT3              ct1 registers.
 *     CT2              ct2 registers.
 *
 ******************************************************************************/
#define BCM56504_A0_CBPDATAMEM9DEBUGr 0x00680049

#define BCM56504_A0_CBPDATAMEM9DEBUGr_SIZE 4

/*
 * This structure should be used to declare and program CBPDATAMEM9DEBUG.
 *
 */
typedef union BCM56504_A0_CBPDATAMEM9DEBUGr_s {
	uint32_t v[1];
	uint32_t cbpdatamem9debug[1];
	uint32_t _cbpdatamem9debug;
} BCM56504_A0_CBPDATAMEM9DEBUGr_t;

#define BCM56504_A0_CBPDATAMEM9DEBUGr_CLR(r) (r).cbpdatamem9debug[0] = 0
#define BCM56504_A0_CBPDATAMEM9DEBUGr_SET(r,d) (r).cbpdatamem9debug[0] = d
#define BCM56504_A0_CBPDATAMEM9DEBUGr_GET(r) (r).cbpdatamem9debug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CBPDATAMEM9DEBUGr_SAMf_GET(r) (((r).cbpdatamem9debug[0]) & 0x3)
#define BCM56504_A0_CBPDATAMEM9DEBUGr_SAMf_SET(r,f) (r).cbpdatamem9debug[0]=(((r).cbpdatamem9debug[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56504_A0_CBPDATAMEM9DEBUGr_CT0f_GET(r) ((((r).cbpdatamem9debug[0]) >> 2) & 0x1)
#define BCM56504_A0_CBPDATAMEM9DEBUGr_CT0f_SET(r,f) (r).cbpdatamem9debug[0]=(((r).cbpdatamem9debug[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_CBPDATAMEM9DEBUGr_CT3f_GET(r) ((((r).cbpdatamem9debug[0]) >> 3) & 0x1)
#define BCM56504_A0_CBPDATAMEM9DEBUGr_CT3f_SET(r,f) (r).cbpdatamem9debug[0]=(((r).cbpdatamem9debug[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_CBPDATAMEM9DEBUGr_CT2f_GET(r) ((((r).cbpdatamem9debug[0]) >> 4) & 0x1)
#define BCM56504_A0_CBPDATAMEM9DEBUGr_CT2f_SET(r,f) (r).cbpdatamem9debug[0]=(((r).cbpdatamem9debug[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))

/*
 * These macros can be used to access CBPDATAMEM9DEBUG.
 *
 */
#define BCM56504_A0_READ_CBPDATAMEM9DEBUGr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_CBPDATAMEM9DEBUGr,(r._cbpdatamem9debug))
#define BCM56504_A0_WRITE_CBPDATAMEM9DEBUGr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_CBPDATAMEM9DEBUGr,&(r._cbpdatamem9debug))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CBPDATAMEM9DEBUGr BCM56504_A0_CBPDATAMEM9DEBUGr
#define CBPDATAMEM9DEBUGr_SIZE BCM56504_A0_CBPDATAMEM9DEBUGr_SIZE
typedef BCM56504_A0_CBPDATAMEM9DEBUGr_t CBPDATAMEM9DEBUGr_t;
#define CBPDATAMEM9DEBUGr_CLR BCM56504_A0_CBPDATAMEM9DEBUGr_CLR
#define CBPDATAMEM9DEBUGr_SET BCM56504_A0_CBPDATAMEM9DEBUGr_SET
#define CBPDATAMEM9DEBUGr_GET BCM56504_A0_CBPDATAMEM9DEBUGr_GET
#define CBPDATAMEM9DEBUGr_SAMf_GET BCM56504_A0_CBPDATAMEM9DEBUGr_SAMf_GET
#define CBPDATAMEM9DEBUGr_SAMf_SET BCM56504_A0_CBPDATAMEM9DEBUGr_SAMf_SET
#define CBPDATAMEM9DEBUGr_CT0f_GET BCM56504_A0_CBPDATAMEM9DEBUGr_CT0f_GET
#define CBPDATAMEM9DEBUGr_CT0f_SET BCM56504_A0_CBPDATAMEM9DEBUGr_CT0f_SET
#define CBPDATAMEM9DEBUGr_CT3f_GET BCM56504_A0_CBPDATAMEM9DEBUGr_CT3f_GET
#define CBPDATAMEM9DEBUGr_CT3f_SET BCM56504_A0_CBPDATAMEM9DEBUGr_CT3f_SET
#define CBPDATAMEM9DEBUGr_CT2f_GET BCM56504_A0_CBPDATAMEM9DEBUGr_CT2f_GET
#define CBPDATAMEM9DEBUGr_CT2f_SET BCM56504_A0_CBPDATAMEM9DEBUGr_CT2f_SET
#define READ_CBPDATAMEM9DEBUGr BCM56504_A0_READ_CBPDATAMEM9DEBUGr
#define WRITE_CBPDATAMEM9DEBUGr BCM56504_A0_WRITE_CBPDATAMEM9DEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CBPDATAMEM9DEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CBPPKTHDRMEM0DEBUG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     SAM              sam registers.
 *     CT0              ct0 registers.
 *     CT3              ct1 registers.
 *     CT2              ct2 registers.
 *
 ******************************************************************************/
#define BCM56504_A0_CBPPKTHDRMEM0DEBUGr 0x00680050

#define BCM56504_A0_CBPPKTHDRMEM0DEBUGr_SIZE 4

/*
 * This structure should be used to declare and program CBPPKTHDRMEM0DEBUG.
 *
 */
typedef union BCM56504_A0_CBPPKTHDRMEM0DEBUGr_s {
	uint32_t v[1];
	uint32_t cbppkthdrmem0debug[1];
	uint32_t _cbppkthdrmem0debug;
} BCM56504_A0_CBPPKTHDRMEM0DEBUGr_t;

#define BCM56504_A0_CBPPKTHDRMEM0DEBUGr_CLR(r) (r).cbppkthdrmem0debug[0] = 0
#define BCM56504_A0_CBPPKTHDRMEM0DEBUGr_SET(r,d) (r).cbppkthdrmem0debug[0] = d
#define BCM56504_A0_CBPPKTHDRMEM0DEBUGr_GET(r) (r).cbppkthdrmem0debug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CBPPKTHDRMEM0DEBUGr_SAMf_GET(r) (((r).cbppkthdrmem0debug[0]) & 0x3)
#define BCM56504_A0_CBPPKTHDRMEM0DEBUGr_SAMf_SET(r,f) (r).cbppkthdrmem0debug[0]=(((r).cbppkthdrmem0debug[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56504_A0_CBPPKTHDRMEM0DEBUGr_CT0f_GET(r) ((((r).cbppkthdrmem0debug[0]) >> 2) & 0x1)
#define BCM56504_A0_CBPPKTHDRMEM0DEBUGr_CT0f_SET(r,f) (r).cbppkthdrmem0debug[0]=(((r).cbppkthdrmem0debug[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_CBPPKTHDRMEM0DEBUGr_CT3f_GET(r) ((((r).cbppkthdrmem0debug[0]) >> 3) & 0x1)
#define BCM56504_A0_CBPPKTHDRMEM0DEBUGr_CT3f_SET(r,f) (r).cbppkthdrmem0debug[0]=(((r).cbppkthdrmem0debug[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_CBPPKTHDRMEM0DEBUGr_CT2f_GET(r) ((((r).cbppkthdrmem0debug[0]) >> 4) & 0x1)
#define BCM56504_A0_CBPPKTHDRMEM0DEBUGr_CT2f_SET(r,f) (r).cbppkthdrmem0debug[0]=(((r).cbppkthdrmem0debug[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))

/*
 * These macros can be used to access CBPPKTHDRMEM0DEBUG.
 *
 */
#define BCM56504_A0_READ_CBPPKTHDRMEM0DEBUGr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_CBPPKTHDRMEM0DEBUGr,(r._cbppkthdrmem0debug))
#define BCM56504_A0_WRITE_CBPPKTHDRMEM0DEBUGr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_CBPPKTHDRMEM0DEBUGr,&(r._cbppkthdrmem0debug))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CBPPKTHDRMEM0DEBUGr BCM56504_A0_CBPPKTHDRMEM0DEBUGr
#define CBPPKTHDRMEM0DEBUGr_SIZE BCM56504_A0_CBPPKTHDRMEM0DEBUGr_SIZE
typedef BCM56504_A0_CBPPKTHDRMEM0DEBUGr_t CBPPKTHDRMEM0DEBUGr_t;
#define CBPPKTHDRMEM0DEBUGr_CLR BCM56504_A0_CBPPKTHDRMEM0DEBUGr_CLR
#define CBPPKTHDRMEM0DEBUGr_SET BCM56504_A0_CBPPKTHDRMEM0DEBUGr_SET
#define CBPPKTHDRMEM0DEBUGr_GET BCM56504_A0_CBPPKTHDRMEM0DEBUGr_GET
#define CBPPKTHDRMEM0DEBUGr_SAMf_GET BCM56504_A0_CBPPKTHDRMEM0DEBUGr_SAMf_GET
#define CBPPKTHDRMEM0DEBUGr_SAMf_SET BCM56504_A0_CBPPKTHDRMEM0DEBUGr_SAMf_SET
#define CBPPKTHDRMEM0DEBUGr_CT0f_GET BCM56504_A0_CBPPKTHDRMEM0DEBUGr_CT0f_GET
#define CBPPKTHDRMEM0DEBUGr_CT0f_SET BCM56504_A0_CBPPKTHDRMEM0DEBUGr_CT0f_SET
#define CBPPKTHDRMEM0DEBUGr_CT3f_GET BCM56504_A0_CBPPKTHDRMEM0DEBUGr_CT3f_GET
#define CBPPKTHDRMEM0DEBUGr_CT3f_SET BCM56504_A0_CBPPKTHDRMEM0DEBUGr_CT3f_SET
#define CBPPKTHDRMEM0DEBUGr_CT2f_GET BCM56504_A0_CBPPKTHDRMEM0DEBUGr_CT2f_GET
#define CBPPKTHDRMEM0DEBUGr_CT2f_SET BCM56504_A0_CBPPKTHDRMEM0DEBUGr_CT2f_SET
#define READ_CBPPKTHDRMEM0DEBUGr BCM56504_A0_READ_CBPPKTHDRMEM0DEBUGr
#define WRITE_CBPPKTHDRMEM0DEBUGr BCM56504_A0_WRITE_CBPPKTHDRMEM0DEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CBPPKTHDRMEM0DEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CBPPKTHDRMEM1DEBUG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     SAM              sam registers.
 *     CT0              ct0 registers.
 *     CT3              ct1 registers.
 *     CT2              ct2 registers.
 *
 ******************************************************************************/
#define BCM56504_A0_CBPPKTHDRMEM1DEBUGr 0x00680051

#define BCM56504_A0_CBPPKTHDRMEM1DEBUGr_SIZE 4

/*
 * This structure should be used to declare and program CBPPKTHDRMEM1DEBUG.
 *
 */
typedef union BCM56504_A0_CBPPKTHDRMEM1DEBUGr_s {
	uint32_t v[1];
	uint32_t cbppkthdrmem1debug[1];
	uint32_t _cbppkthdrmem1debug;
} BCM56504_A0_CBPPKTHDRMEM1DEBUGr_t;

#define BCM56504_A0_CBPPKTHDRMEM1DEBUGr_CLR(r) (r).cbppkthdrmem1debug[0] = 0
#define BCM56504_A0_CBPPKTHDRMEM1DEBUGr_SET(r,d) (r).cbppkthdrmem1debug[0] = d
#define BCM56504_A0_CBPPKTHDRMEM1DEBUGr_GET(r) (r).cbppkthdrmem1debug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CBPPKTHDRMEM1DEBUGr_SAMf_GET(r) (((r).cbppkthdrmem1debug[0]) & 0x3)
#define BCM56504_A0_CBPPKTHDRMEM1DEBUGr_SAMf_SET(r,f) (r).cbppkthdrmem1debug[0]=(((r).cbppkthdrmem1debug[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56504_A0_CBPPKTHDRMEM1DEBUGr_CT0f_GET(r) ((((r).cbppkthdrmem1debug[0]) >> 2) & 0x1)
#define BCM56504_A0_CBPPKTHDRMEM1DEBUGr_CT0f_SET(r,f) (r).cbppkthdrmem1debug[0]=(((r).cbppkthdrmem1debug[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_CBPPKTHDRMEM1DEBUGr_CT3f_GET(r) ((((r).cbppkthdrmem1debug[0]) >> 3) & 0x1)
#define BCM56504_A0_CBPPKTHDRMEM1DEBUGr_CT3f_SET(r,f) (r).cbppkthdrmem1debug[0]=(((r).cbppkthdrmem1debug[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_CBPPKTHDRMEM1DEBUGr_CT2f_GET(r) ((((r).cbppkthdrmem1debug[0]) >> 4) & 0x1)
#define BCM56504_A0_CBPPKTHDRMEM1DEBUGr_CT2f_SET(r,f) (r).cbppkthdrmem1debug[0]=(((r).cbppkthdrmem1debug[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))

/*
 * These macros can be used to access CBPPKTHDRMEM1DEBUG.
 *
 */
#define BCM56504_A0_READ_CBPPKTHDRMEM1DEBUGr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_CBPPKTHDRMEM1DEBUGr,(r._cbppkthdrmem1debug))
#define BCM56504_A0_WRITE_CBPPKTHDRMEM1DEBUGr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_CBPPKTHDRMEM1DEBUGr,&(r._cbppkthdrmem1debug))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CBPPKTHDRMEM1DEBUGr BCM56504_A0_CBPPKTHDRMEM1DEBUGr
#define CBPPKTHDRMEM1DEBUGr_SIZE BCM56504_A0_CBPPKTHDRMEM1DEBUGr_SIZE
typedef BCM56504_A0_CBPPKTHDRMEM1DEBUGr_t CBPPKTHDRMEM1DEBUGr_t;
#define CBPPKTHDRMEM1DEBUGr_CLR BCM56504_A0_CBPPKTHDRMEM1DEBUGr_CLR
#define CBPPKTHDRMEM1DEBUGr_SET BCM56504_A0_CBPPKTHDRMEM1DEBUGr_SET
#define CBPPKTHDRMEM1DEBUGr_GET BCM56504_A0_CBPPKTHDRMEM1DEBUGr_GET
#define CBPPKTHDRMEM1DEBUGr_SAMf_GET BCM56504_A0_CBPPKTHDRMEM1DEBUGr_SAMf_GET
#define CBPPKTHDRMEM1DEBUGr_SAMf_SET BCM56504_A0_CBPPKTHDRMEM1DEBUGr_SAMf_SET
#define CBPPKTHDRMEM1DEBUGr_CT0f_GET BCM56504_A0_CBPPKTHDRMEM1DEBUGr_CT0f_GET
#define CBPPKTHDRMEM1DEBUGr_CT0f_SET BCM56504_A0_CBPPKTHDRMEM1DEBUGr_CT0f_SET
#define CBPPKTHDRMEM1DEBUGr_CT3f_GET BCM56504_A0_CBPPKTHDRMEM1DEBUGr_CT3f_GET
#define CBPPKTHDRMEM1DEBUGr_CT3f_SET BCM56504_A0_CBPPKTHDRMEM1DEBUGr_CT3f_SET
#define CBPPKTHDRMEM1DEBUGr_CT2f_GET BCM56504_A0_CBPPKTHDRMEM1DEBUGr_CT2f_GET
#define CBPPKTHDRMEM1DEBUGr_CT2f_SET BCM56504_A0_CBPPKTHDRMEM1DEBUGr_CT2f_SET
#define READ_CBPPKTHDRMEM1DEBUGr BCM56504_A0_READ_CBPPKTHDRMEM1DEBUGr
#define WRITE_CBPPKTHDRMEM1DEBUGr BCM56504_A0_WRITE_CBPPKTHDRMEM1DEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CBPPKTHDRMEM1DEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CBPPKTHDRPARITYERRPTR
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     ERRORPOINTER     CBP Packet Header Memory parity error pointer is the errored cell header pointer.
 *
 ******************************************************************************/
#define BCM56504_A0_CBPPKTHDRPARITYERRPTRr 0x00680034

#define BCM56504_A0_CBPPKTHDRPARITYERRPTRr_SIZE 4

/*
 * This structure should be used to declare and program CBPPKTHDRPARITYERRPTR.
 *
 */
typedef union BCM56504_A0_CBPPKTHDRPARITYERRPTRr_s {
	uint32_t v[1];
	uint32_t cbppkthdrparityerrptr[1];
	uint32_t _cbppkthdrparityerrptr;
} BCM56504_A0_CBPPKTHDRPARITYERRPTRr_t;

#define BCM56504_A0_CBPPKTHDRPARITYERRPTRr_CLR(r) (r).cbppkthdrparityerrptr[0] = 0
#define BCM56504_A0_CBPPKTHDRPARITYERRPTRr_SET(r,d) (r).cbppkthdrparityerrptr[0] = d
#define BCM56504_A0_CBPPKTHDRPARITYERRPTRr_GET(r) (r).cbppkthdrparityerrptr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CBPPKTHDRPARITYERRPTRr_ERRORPOINTERf_GET(r) (((r).cbppkthdrparityerrptr[0]) & 0x3fff)
#define BCM56504_A0_CBPPKTHDRPARITYERRPTRr_ERRORPOINTERf_SET(r,f) (r).cbppkthdrparityerrptr[0]=(((r).cbppkthdrparityerrptr[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access CBPPKTHDRPARITYERRPTR.
 *
 */
#define BCM56504_A0_READ_CBPPKTHDRPARITYERRPTRr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_CBPPKTHDRPARITYERRPTRr,(r._cbppkthdrparityerrptr))
#define BCM56504_A0_WRITE_CBPPKTHDRPARITYERRPTRr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_CBPPKTHDRPARITYERRPTRr,&(r._cbppkthdrparityerrptr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CBPPKTHDRPARITYERRPTRr BCM56504_A0_CBPPKTHDRPARITYERRPTRr
#define CBPPKTHDRPARITYERRPTRr_SIZE BCM56504_A0_CBPPKTHDRPARITYERRPTRr_SIZE
typedef BCM56504_A0_CBPPKTHDRPARITYERRPTRr_t CBPPKTHDRPARITYERRPTRr_t;
#define CBPPKTHDRPARITYERRPTRr_CLR BCM56504_A0_CBPPKTHDRPARITYERRPTRr_CLR
#define CBPPKTHDRPARITYERRPTRr_SET BCM56504_A0_CBPPKTHDRPARITYERRPTRr_SET
#define CBPPKTHDRPARITYERRPTRr_GET BCM56504_A0_CBPPKTHDRPARITYERRPTRr_GET
#define CBPPKTHDRPARITYERRPTRr_ERRORPOINTERf_GET BCM56504_A0_CBPPKTHDRPARITYERRPTRr_ERRORPOINTERf_GET
#define CBPPKTHDRPARITYERRPTRr_ERRORPOINTERf_SET BCM56504_A0_CBPPKTHDRPARITYERRPTRr_ERRORPOINTERf_SET
#define READ_CBPPKTHDRPARITYERRPTRr BCM56504_A0_READ_CBPPKTHDRPARITYERRPTRr
#define WRITE_CBPPKTHDRPARITYERRPTRr BCM56504_A0_WRITE_CBPPKTHDRPARITYERRPTRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CBPPKTHDRPARITYERRPTRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CCPMEMDEBUG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CCM              ccm registers.
 *     RM               rm registers.
 *
 ******************************************************************************/
#define BCM56504_A0_CCPMEMDEBUGr 0x0068003a

#define BCM56504_A0_CCPMEMDEBUGr_SIZE 4

/*
 * This structure should be used to declare and program CCPMEMDEBUG.
 *
 */
typedef union BCM56504_A0_CCPMEMDEBUGr_s {
	uint32_t v[1];
	uint32_t ccpmemdebug[1];
	uint32_t _ccpmemdebug;
} BCM56504_A0_CCPMEMDEBUGr_t;

#define BCM56504_A0_CCPMEMDEBUGr_CLR(r) (r).ccpmemdebug[0] = 0
#define BCM56504_A0_CCPMEMDEBUGr_SET(r,d) (r).ccpmemdebug[0] = d
#define BCM56504_A0_CCPMEMDEBUGr_GET(r) (r).ccpmemdebug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CCPMEMDEBUGr_CCMf_GET(r) (((r).ccpmemdebug[0]) & 0x1)
#define BCM56504_A0_CCPMEMDEBUGr_CCMf_SET(r,f) (r).ccpmemdebug[0]=(((r).ccpmemdebug[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_CCPMEMDEBUGr_RMf_GET(r) ((((r).ccpmemdebug[0]) >> 1) & 0x1)
#define BCM56504_A0_CCPMEMDEBUGr_RMf_SET(r,f) (r).ccpmemdebug[0]=(((r).ccpmemdebug[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access CCPMEMDEBUG.
 *
 */
#define BCM56504_A0_READ_CCPMEMDEBUGr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_CCPMEMDEBUGr,(r._ccpmemdebug))
#define BCM56504_A0_WRITE_CCPMEMDEBUGr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_CCPMEMDEBUGr,&(r._ccpmemdebug))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CCPMEMDEBUGr BCM56504_A0_CCPMEMDEBUGr
#define CCPMEMDEBUGr_SIZE BCM56504_A0_CCPMEMDEBUGr_SIZE
typedef BCM56504_A0_CCPMEMDEBUGr_t CCPMEMDEBUGr_t;
#define CCPMEMDEBUGr_CLR BCM56504_A0_CCPMEMDEBUGr_CLR
#define CCPMEMDEBUGr_SET BCM56504_A0_CCPMEMDEBUGr_SET
#define CCPMEMDEBUGr_GET BCM56504_A0_CCPMEMDEBUGr_GET
#define CCPMEMDEBUGr_CCMf_GET BCM56504_A0_CCPMEMDEBUGr_CCMf_GET
#define CCPMEMDEBUGr_CCMf_SET BCM56504_A0_CCPMEMDEBUGr_CCMf_SET
#define CCPMEMDEBUGr_RMf_GET BCM56504_A0_CCPMEMDEBUGr_RMf_GET
#define CCPMEMDEBUGr_RMf_SET BCM56504_A0_CCPMEMDEBUGr_RMf_SET
#define READ_CCPMEMDEBUGr BCM56504_A0_READ_CCPMEMDEBUGr
#define WRITE_CCPMEMDEBUGr BCM56504_A0_WRITE_CCPMEMDEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CCPMEMDEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CCPPARITYERRORPTR
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CCPPARITYERRORPTR MMU CCP memory parity error pointer indicats.this register only keeps the most current ccp parity error pointer.
 *
 ******************************************************************************/
#define BCM56504_A0_CCPPARITYERRORPTRr 0x00680039

#define BCM56504_A0_CCPPARITYERRORPTRr_SIZE 4

/*
 * This structure should be used to declare and program CCPPARITYERRORPTR.
 *
 */
typedef union BCM56504_A0_CCPPARITYERRORPTRr_s {
	uint32_t v[1];
	uint32_t ccpparityerrorptr[1];
	uint32_t _ccpparityerrorptr;
} BCM56504_A0_CCPPARITYERRORPTRr_t;

#define BCM56504_A0_CCPPARITYERRORPTRr_CLR(r) (r).ccpparityerrorptr[0] = 0
#define BCM56504_A0_CCPPARITYERRORPTRr_SET(r,d) (r).ccpparityerrorptr[0] = d
#define BCM56504_A0_CCPPARITYERRORPTRr_GET(r) (r).ccpparityerrorptr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CCPPARITYERRORPTRr_CCPPARITYERRORPTRf_GET(r) (((r).ccpparityerrorptr[0]) & 0x3fff)
#define BCM56504_A0_CCPPARITYERRORPTRr_CCPPARITYERRORPTRf_SET(r,f) (r).ccpparityerrorptr[0]=(((r).ccpparityerrorptr[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access CCPPARITYERRORPTR.
 *
 */
#define BCM56504_A0_READ_CCPPARITYERRORPTRr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_CCPPARITYERRORPTRr,(r._ccpparityerrorptr))
#define BCM56504_A0_WRITE_CCPPARITYERRORPTRr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_CCPPARITYERRORPTRr,&(r._ccpparityerrorptr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CCPPARITYERRORPTRr BCM56504_A0_CCPPARITYERRORPTRr
#define CCPPARITYERRORPTRr_SIZE BCM56504_A0_CCPPARITYERRORPTRr_SIZE
typedef BCM56504_A0_CCPPARITYERRORPTRr_t CCPPARITYERRORPTRr_t;
#define CCPPARITYERRORPTRr_CLR BCM56504_A0_CCPPARITYERRORPTRr_CLR
#define CCPPARITYERRORPTRr_SET BCM56504_A0_CCPPARITYERRORPTRr_SET
#define CCPPARITYERRORPTRr_GET BCM56504_A0_CCPPARITYERRORPTRr_GET
#define CCPPARITYERRORPTRr_CCPPARITYERRORPTRf_GET BCM56504_A0_CCPPARITYERRORPTRr_CCPPARITYERRORPTRf_GET
#define CCPPARITYERRORPTRr_CCPPARITYERRORPTRf_SET BCM56504_A0_CCPPARITYERRORPTRr_CCPPARITYERRORPTRf_SET
#define READ_CCPPARITYERRORPTRr BCM56504_A0_READ_CCPPARITYERRORPTRr
#define WRITE_CCPPARITYERRORPTRr BCM56504_A0_WRITE_CCPPARITYERRORPTRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CCPPARITYERRORPTRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CFAPCONFIG
 * BLOCKS:   MMU
 * DESC:     Controls the CFAP behavior
 * SIZE:     32
 * FIELDS:
 *     CFAPPOOLSIZE     Maximum number of cell pointers of CBP memory.Do NOT set this above the RESET VALUE. It will cause unexpected behavior of MMU. 
 *     CFAPINIT         Re-Initialize CFAP Memory.When write 1 to Set this bit mmu will re-initialize CFAP pointer pre-fetchprocess after user had rearranged CFAP memory. 
 *
 ******************************************************************************/
#define BCM56504_A0_CFAPCONFIGr 0x00680010

#define BCM56504_A0_CFAPCONFIGr_SIZE 4

/*
 * This structure should be used to declare and program CFAPCONFIG.
 *
 */
typedef union BCM56504_A0_CFAPCONFIGr_s {
	uint32_t v[1];
	uint32_t cfapconfig[1];
	uint32_t _cfapconfig;
} BCM56504_A0_CFAPCONFIGr_t;

#define BCM56504_A0_CFAPCONFIGr_CLR(r) (r).cfapconfig[0] = 0
#define BCM56504_A0_CFAPCONFIGr_SET(r,d) (r).cfapconfig[0] = d
#define BCM56504_A0_CFAPCONFIGr_GET(r) (r).cfapconfig[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CFAPCONFIGr_CFAPPOOLSIZEf_GET(r) (((r).cfapconfig[0]) & 0x3fff)
#define BCM56504_A0_CFAPCONFIGr_CFAPPOOLSIZEf_SET(r,f) (r).cfapconfig[0]=(((r).cfapconfig[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM56504_A0_CFAPCONFIGr_CFAPINITf_GET(r) ((((r).cfapconfig[0]) >> 14) & 0x1)
#define BCM56504_A0_CFAPCONFIGr_CFAPINITf_SET(r,f) (r).cfapconfig[0]=(((r).cfapconfig[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))

/*
 * These macros can be used to access CFAPCONFIG.
 *
 */
#define BCM56504_A0_READ_CFAPCONFIGr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_CFAPCONFIGr,(r._cfapconfig))
#define BCM56504_A0_WRITE_CFAPCONFIGr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_CFAPCONFIGr,&(r._cfapconfig))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFAPCONFIGr BCM56504_A0_CFAPCONFIGr
#define CFAPCONFIGr_SIZE BCM56504_A0_CFAPCONFIGr_SIZE
typedef BCM56504_A0_CFAPCONFIGr_t CFAPCONFIGr_t;
#define CFAPCONFIGr_CLR BCM56504_A0_CFAPCONFIGr_CLR
#define CFAPCONFIGr_SET BCM56504_A0_CFAPCONFIGr_SET
#define CFAPCONFIGr_GET BCM56504_A0_CFAPCONFIGr_GET
#define CFAPCONFIGr_CFAPPOOLSIZEf_GET BCM56504_A0_CFAPCONFIGr_CFAPPOOLSIZEf_GET
#define CFAPCONFIGr_CFAPPOOLSIZEf_SET BCM56504_A0_CFAPCONFIGr_CFAPPOOLSIZEf_SET
#define CFAPCONFIGr_CFAPINITf_GET BCM56504_A0_CFAPCONFIGr_CFAPINITf_GET
#define CFAPCONFIGr_CFAPINITf_SET BCM56504_A0_CFAPCONFIGr_CFAPINITf_SET
#define READ_CFAPCONFIGr BCM56504_A0_READ_CFAPCONFIGr
#define WRITE_CFAPCONFIGr BCM56504_A0_WRITE_CFAPCONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CFAPCONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CFAPFULLTHRESHOLD
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CFAPFULLSETPOINT CFAP FULL Set Point define the threshold of entering CFAP FULL condition. CFAP is full when CFAP Read Pointer is above this limit.
 *     CFAPFULLRESETPOINT CFAP FULL Reset Point define the threshold of exiting CFAP FULL condition. CFAP is not full when CFAP Read Pointeris below this limit.
 *
 ******************************************************************************/
#define BCM56504_A0_CFAPFULLTHRESHOLDr 0x00680012

#define BCM56504_A0_CFAPFULLTHRESHOLDr_SIZE 4

/*
 * This structure should be used to declare and program CFAPFULLTHRESHOLD.
 *
 */
typedef union BCM56504_A0_CFAPFULLTHRESHOLDr_s {
	uint32_t v[1];
	uint32_t cfapfullthreshold[1];
	uint32_t _cfapfullthreshold;
} BCM56504_A0_CFAPFULLTHRESHOLDr_t;

#define BCM56504_A0_CFAPFULLTHRESHOLDr_CLR(r) (r).cfapfullthreshold[0] = 0
#define BCM56504_A0_CFAPFULLTHRESHOLDr_SET(r,d) (r).cfapfullthreshold[0] = d
#define BCM56504_A0_CFAPFULLTHRESHOLDr_GET(r) (r).cfapfullthreshold[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CFAPFULLTHRESHOLDr_CFAPFULLSETPOINTf_GET(r) (((r).cfapfullthreshold[0]) & 0x3fff)
#define BCM56504_A0_CFAPFULLTHRESHOLDr_CFAPFULLSETPOINTf_SET(r,f) (r).cfapfullthreshold[0]=(((r).cfapfullthreshold[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM56504_A0_CFAPFULLTHRESHOLDr_CFAPFULLRESETPOINTf_GET(r) ((((r).cfapfullthreshold[0]) >> 14) & 0x3fff)
#define BCM56504_A0_CFAPFULLTHRESHOLDr_CFAPFULLRESETPOINTf_SET(r,f) (r).cfapfullthreshold[0]=(((r).cfapfullthreshold[0] & ~((uint32_t)0x3fff << 14)) | ((((uint32_t)f) & 0x3fff) << 14))

/*
 * These macros can be used to access CFAPFULLTHRESHOLD.
 *
 */
#define BCM56504_A0_READ_CFAPFULLTHRESHOLDr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_CFAPFULLTHRESHOLDr,(r._cfapfullthreshold))
#define BCM56504_A0_WRITE_CFAPFULLTHRESHOLDr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_CFAPFULLTHRESHOLDr,&(r._cfapfullthreshold))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFAPFULLTHRESHOLDr BCM56504_A0_CFAPFULLTHRESHOLDr
#define CFAPFULLTHRESHOLDr_SIZE BCM56504_A0_CFAPFULLTHRESHOLDr_SIZE
typedef BCM56504_A0_CFAPFULLTHRESHOLDr_t CFAPFULLTHRESHOLDr_t;
#define CFAPFULLTHRESHOLDr_CLR BCM56504_A0_CFAPFULLTHRESHOLDr_CLR
#define CFAPFULLTHRESHOLDr_SET BCM56504_A0_CFAPFULLTHRESHOLDr_SET
#define CFAPFULLTHRESHOLDr_GET BCM56504_A0_CFAPFULLTHRESHOLDr_GET
#define CFAPFULLTHRESHOLDr_CFAPFULLSETPOINTf_GET BCM56504_A0_CFAPFULLTHRESHOLDr_CFAPFULLSETPOINTf_GET
#define CFAPFULLTHRESHOLDr_CFAPFULLSETPOINTf_SET BCM56504_A0_CFAPFULLTHRESHOLDr_CFAPFULLSETPOINTf_SET
#define CFAPFULLTHRESHOLDr_CFAPFULLRESETPOINTf_GET BCM56504_A0_CFAPFULLTHRESHOLDr_CFAPFULLRESETPOINTf_GET
#define CFAPFULLTHRESHOLDr_CFAPFULLRESETPOINTf_SET BCM56504_A0_CFAPFULLTHRESHOLDr_CFAPFULLRESETPOINTf_SET
#define READ_CFAPFULLTHRESHOLDr BCM56504_A0_READ_CFAPFULLTHRESHOLDr
#define WRITE_CFAPFULLTHRESHOLDr BCM56504_A0_WRITE_CFAPFULLTHRESHOLDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CFAPFULLTHRESHOLDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CFAPMEMDEBUG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CCM              ccm registers.
 *     RM               rm registers.
 *
 ******************************************************************************/
#define BCM56504_A0_CFAPMEMDEBUGr 0x0068003b

#define BCM56504_A0_CFAPMEMDEBUGr_SIZE 4

/*
 * This structure should be used to declare and program CFAPMEMDEBUG.
 *
 */
typedef union BCM56504_A0_CFAPMEMDEBUGr_s {
	uint32_t v[1];
	uint32_t cfapmemdebug[1];
	uint32_t _cfapmemdebug;
} BCM56504_A0_CFAPMEMDEBUGr_t;

#define BCM56504_A0_CFAPMEMDEBUGr_CLR(r) (r).cfapmemdebug[0] = 0
#define BCM56504_A0_CFAPMEMDEBUGr_SET(r,d) (r).cfapmemdebug[0] = d
#define BCM56504_A0_CFAPMEMDEBUGr_GET(r) (r).cfapmemdebug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CFAPMEMDEBUGr_CCMf_GET(r) (((r).cfapmemdebug[0]) & 0x1)
#define BCM56504_A0_CFAPMEMDEBUGr_CCMf_SET(r,f) (r).cfapmemdebug[0]=(((r).cfapmemdebug[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_CFAPMEMDEBUGr_RMf_GET(r) ((((r).cfapmemdebug[0]) >> 1) & 0x1)
#define BCM56504_A0_CFAPMEMDEBUGr_RMf_SET(r,f) (r).cfapmemdebug[0]=(((r).cfapmemdebug[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access CFAPMEMDEBUG.
 *
 */
#define BCM56504_A0_READ_CFAPMEMDEBUGr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_CFAPMEMDEBUGr,(r._cfapmemdebug))
#define BCM56504_A0_WRITE_CFAPMEMDEBUGr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_CFAPMEMDEBUGr,&(r._cfapmemdebug))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFAPMEMDEBUGr BCM56504_A0_CFAPMEMDEBUGr
#define CFAPMEMDEBUGr_SIZE BCM56504_A0_CFAPMEMDEBUGr_SIZE
typedef BCM56504_A0_CFAPMEMDEBUGr_t CFAPMEMDEBUGr_t;
#define CFAPMEMDEBUGr_CLR BCM56504_A0_CFAPMEMDEBUGr_CLR
#define CFAPMEMDEBUGr_SET BCM56504_A0_CFAPMEMDEBUGr_SET
#define CFAPMEMDEBUGr_GET BCM56504_A0_CFAPMEMDEBUGr_GET
#define CFAPMEMDEBUGr_CCMf_GET BCM56504_A0_CFAPMEMDEBUGr_CCMf_GET
#define CFAPMEMDEBUGr_CCMf_SET BCM56504_A0_CFAPMEMDEBUGr_CCMf_SET
#define CFAPMEMDEBUGr_RMf_GET BCM56504_A0_CFAPMEMDEBUGr_RMf_GET
#define CFAPMEMDEBUGr_RMf_SET BCM56504_A0_CFAPMEMDEBUGr_RMf_SET
#define READ_CFAPMEMDEBUGr BCM56504_A0_READ_CFAPMEMDEBUGr
#define WRITE_CFAPMEMDEBUGr BCM56504_A0_WRITE_CFAPMEMDEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CFAPMEMDEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CFAPPARITYERRORPTR
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CFAPPARITYERRORPTR MMU CFAP memory parity error pointer indicats.this register only keeps the most current cfap parity error pointer.
 *
 ******************************************************************************/
#define BCM56504_A0_CFAPPARITYERRORPTRr 0x00680038

#define BCM56504_A0_CFAPPARITYERRORPTRr_SIZE 4

/*
 * This structure should be used to declare and program CFAPPARITYERRORPTR.
 *
 */
typedef union BCM56504_A0_CFAPPARITYERRORPTRr_s {
	uint32_t v[1];
	uint32_t cfapparityerrorptr[1];
	uint32_t _cfapparityerrorptr;
} BCM56504_A0_CFAPPARITYERRORPTRr_t;

#define BCM56504_A0_CFAPPARITYERRORPTRr_CLR(r) (r).cfapparityerrorptr[0] = 0
#define BCM56504_A0_CFAPPARITYERRORPTRr_SET(r,d) (r).cfapparityerrorptr[0] = d
#define BCM56504_A0_CFAPPARITYERRORPTRr_GET(r) (r).cfapparityerrorptr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CFAPPARITYERRORPTRr_CFAPPARITYERRORPTRf_GET(r) (((r).cfapparityerrorptr[0]) & 0x3fff)
#define BCM56504_A0_CFAPPARITYERRORPTRr_CFAPPARITYERRORPTRf_SET(r,f) (r).cfapparityerrorptr[0]=(((r).cfapparityerrorptr[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access CFAPPARITYERRORPTR.
 *
 */
#define BCM56504_A0_READ_CFAPPARITYERRORPTRr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_CFAPPARITYERRORPTRr,(r._cfapparityerrorptr))
#define BCM56504_A0_WRITE_CFAPPARITYERRORPTRr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_CFAPPARITYERRORPTRr,&(r._cfapparityerrorptr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFAPPARITYERRORPTRr BCM56504_A0_CFAPPARITYERRORPTRr
#define CFAPPARITYERRORPTRr_SIZE BCM56504_A0_CFAPPARITYERRORPTRr_SIZE
typedef BCM56504_A0_CFAPPARITYERRORPTRr_t CFAPPARITYERRORPTRr_t;
#define CFAPPARITYERRORPTRr_CLR BCM56504_A0_CFAPPARITYERRORPTRr_CLR
#define CFAPPARITYERRORPTRr_SET BCM56504_A0_CFAPPARITYERRORPTRr_SET
#define CFAPPARITYERRORPTRr_GET BCM56504_A0_CFAPPARITYERRORPTRr_GET
#define CFAPPARITYERRORPTRr_CFAPPARITYERRORPTRf_GET BCM56504_A0_CFAPPARITYERRORPTRr_CFAPPARITYERRORPTRf_GET
#define CFAPPARITYERRORPTRr_CFAPPARITYERRORPTRf_SET BCM56504_A0_CFAPPARITYERRORPTRr_CFAPPARITYERRORPTRf_SET
#define READ_CFAPPARITYERRORPTRr BCM56504_A0_READ_CFAPPARITYERRORPTRr
#define WRITE_CFAPPARITYERRORPTRr BCM56504_A0_WRITE_CFAPPARITYERRORPTRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CFAPPARITYERRORPTRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CFAPREADPOINTER
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CFAPREADPOINTER  The current number of cells that are outstanding in the CBP memory.
 *     CBPFULLSTATUS    Current CBP FULL Status
 *
 ******************************************************************************/
#define BCM56504_A0_CFAPREADPOINTERr 0x00680011

#define BCM56504_A0_CFAPREADPOINTERr_SIZE 4

/*
 * This structure should be used to declare and program CFAPREADPOINTER.
 *
 */
typedef union BCM56504_A0_CFAPREADPOINTERr_s {
	uint32_t v[1];
	uint32_t cfapreadpointer[1];
	uint32_t _cfapreadpointer;
} BCM56504_A0_CFAPREADPOINTERr_t;

#define BCM56504_A0_CFAPREADPOINTERr_CLR(r) (r).cfapreadpointer[0] = 0
#define BCM56504_A0_CFAPREADPOINTERr_SET(r,d) (r).cfapreadpointer[0] = d
#define BCM56504_A0_CFAPREADPOINTERr_GET(r) (r).cfapreadpointer[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CFAPREADPOINTERr_CFAPREADPOINTERf_GET(r) (((r).cfapreadpointer[0]) & 0x3fff)
#define BCM56504_A0_CFAPREADPOINTERr_CFAPREADPOINTERf_SET(r,f) (r).cfapreadpointer[0]=(((r).cfapreadpointer[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM56504_A0_CFAPREADPOINTERr_CBPFULLSTATUSf_GET(r) ((((r).cfapreadpointer[0]) >> 14) & 0x1)
#define BCM56504_A0_CFAPREADPOINTERr_CBPFULLSTATUSf_SET(r,f) (r).cfapreadpointer[0]=(((r).cfapreadpointer[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))

/*
 * These macros can be used to access CFAPREADPOINTER.
 *
 */
#define BCM56504_A0_READ_CFAPREADPOINTERr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_CFAPREADPOINTERr,(r._cfapreadpointer))
#define BCM56504_A0_WRITE_CFAPREADPOINTERr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_CFAPREADPOINTERr,&(r._cfapreadpointer))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFAPREADPOINTERr BCM56504_A0_CFAPREADPOINTERr
#define CFAPREADPOINTERr_SIZE BCM56504_A0_CFAPREADPOINTERr_SIZE
typedef BCM56504_A0_CFAPREADPOINTERr_t CFAPREADPOINTERr_t;
#define CFAPREADPOINTERr_CLR BCM56504_A0_CFAPREADPOINTERr_CLR
#define CFAPREADPOINTERr_SET BCM56504_A0_CFAPREADPOINTERr_SET
#define CFAPREADPOINTERr_GET BCM56504_A0_CFAPREADPOINTERr_GET
#define CFAPREADPOINTERr_CFAPREADPOINTERf_GET BCM56504_A0_CFAPREADPOINTERr_CFAPREADPOINTERf_GET
#define CFAPREADPOINTERr_CFAPREADPOINTERf_SET BCM56504_A0_CFAPREADPOINTERr_CFAPREADPOINTERf_SET
#define CFAPREADPOINTERr_CBPFULLSTATUSf_GET BCM56504_A0_CFAPREADPOINTERr_CBPFULLSTATUSf_GET
#define CFAPREADPOINTERr_CBPFULLSTATUSf_SET BCM56504_A0_CFAPREADPOINTERr_CBPFULLSTATUSf_SET
#define READ_CFAPREADPOINTERr BCM56504_A0_READ_CFAPREADPOINTERr
#define WRITE_CFAPREADPOINTERr BCM56504_A0_WRITE_CFAPREADPOINTERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CFAPREADPOINTERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMICMINTIMER
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CMICMINTIMER     CMIC Minimum Timer will insert a slot for packet tranmitted from mmu tocmic port. The values of CMIC Minimum Timer counts in the unit of micron second.If the value is set zero, then this forced cmic arbitration will be disable.Default value is disable.
 *
 ******************************************************************************/
#define BCM56504_A0_CMICMINTIMERr 0x0068001b

#define BCM56504_A0_CMICMINTIMERr_SIZE 4

/*
 * This structure should be used to declare and program CMICMINTIMER.
 *
 */
typedef union BCM56504_A0_CMICMINTIMERr_s {
	uint32_t v[1];
	uint32_t cmicmintimer[1];
	uint32_t _cmicmintimer;
} BCM56504_A0_CMICMINTIMERr_t;

#define BCM56504_A0_CMICMINTIMERr_CLR(r) (r).cmicmintimer[0] = 0
#define BCM56504_A0_CMICMINTIMERr_SET(r,d) (r).cmicmintimer[0] = d
#define BCM56504_A0_CMICMINTIMERr_GET(r) (r).cmicmintimer[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMICMINTIMERr_CMICMINTIMERf_GET(r) (((r).cmicmintimer[0]) & 0x7)
#define BCM56504_A0_CMICMINTIMERr_CMICMINTIMERf_SET(r,f) (r).cmicmintimer[0]=(((r).cmicmintimer[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))

/*
 * These macros can be used to access CMICMINTIMER.
 *
 */
#define BCM56504_A0_READ_CMICMINTIMERr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_CMICMINTIMERr,(r._cmicmintimer))
#define BCM56504_A0_WRITE_CMICMINTIMERr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_CMICMINTIMERr,&(r._cmicmintimer))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMICMINTIMERr BCM56504_A0_CMICMINTIMERr
#define CMICMINTIMERr_SIZE BCM56504_A0_CMICMINTIMERr_SIZE
typedef BCM56504_A0_CMICMINTIMERr_t CMICMINTIMERr_t;
#define CMICMINTIMERr_CLR BCM56504_A0_CMICMINTIMERr_CLR
#define CMICMINTIMERr_SET BCM56504_A0_CMICMINTIMERr_SET
#define CMICMINTIMERr_GET BCM56504_A0_CMICMINTIMERr_GET
#define CMICMINTIMERr_CMICMINTIMERf_GET BCM56504_A0_CMICMINTIMERr_CMICMINTIMERf_GET
#define CMICMINTIMERr_CMICMINTIMERf_SET BCM56504_A0_CMICMINTIMERr_CMICMINTIMERf_SET
#define READ_CMICMINTIMERr BCM56504_A0_READ_CMICMINTIMERr
#define WRITE_CMICMINTIMERr BCM56504_A0_WRITE_CMICMINTIMERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMICMINTIMERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMICTXCOSMASK
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CMICTXCOSMASK    COS Mask sends from CMIC to MMU in order to control which COS packets cpu wants to receive.
 *
 ******************************************************************************/
#define BCM56504_A0_CMICTXCOSMASKr 0x0068001c

#define BCM56504_A0_CMICTXCOSMASKr_SIZE 4

/*
 * This structure should be used to declare and program CMICTXCOSMASK.
 *
 */
typedef union BCM56504_A0_CMICTXCOSMASKr_s {
	uint32_t v[1];
	uint32_t cmictxcosmask[1];
	uint32_t _cmictxcosmask;
} BCM56504_A0_CMICTXCOSMASKr_t;

#define BCM56504_A0_CMICTXCOSMASKr_CLR(r) (r).cmictxcosmask[0] = 0
#define BCM56504_A0_CMICTXCOSMASKr_SET(r,d) (r).cmictxcosmask[0] = d
#define BCM56504_A0_CMICTXCOSMASKr_GET(r) (r).cmictxcosmask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMICTXCOSMASKr_CMICTXCOSMASKf_GET(r) (((r).cmictxcosmask[0]) & 0xff)
#define BCM56504_A0_CMICTXCOSMASKr_CMICTXCOSMASKf_SET(r,f) (r).cmictxcosmask[0]=(((r).cmictxcosmask[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access CMICTXCOSMASK.
 *
 */
#define BCM56504_A0_READ_CMICTXCOSMASKr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_CMICTXCOSMASKr,(r._cmictxcosmask))
#define BCM56504_A0_WRITE_CMICTXCOSMASKr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_CMICTXCOSMASKr,&(r._cmictxcosmask))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMICTXCOSMASKr BCM56504_A0_CMICTXCOSMASKr
#define CMICTXCOSMASKr_SIZE BCM56504_A0_CMICTXCOSMASKr_SIZE
typedef BCM56504_A0_CMICTXCOSMASKr_t CMICTXCOSMASKr_t;
#define CMICTXCOSMASKr_CLR BCM56504_A0_CMICTXCOSMASKr_CLR
#define CMICTXCOSMASKr_SET BCM56504_A0_CMICTXCOSMASKr_SET
#define CMICTXCOSMASKr_GET BCM56504_A0_CMICTXCOSMASKr_GET
#define CMICTXCOSMASKr_CMICTXCOSMASKf_GET BCM56504_A0_CMICTXCOSMASKr_CMICTXCOSMASKf_GET
#define CMICTXCOSMASKr_CMICTXCOSMASKf_SET BCM56504_A0_CMICTXCOSMASKr_CMICTXCOSMASKf_SET
#define READ_CMICTXCOSMASKr BCM56504_A0_READ_CMICTXCOSMASKr
#define WRITE_CMICTXCOSMASKr BCM56504_A0_WRITE_CMICTXCOSMASKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMICTXCOSMASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_CONFIG
 * BLOCKS:   CMIC
 * DESC:     Configuration Register
 * SIZE:     32
 * FIELDS:
 *     RD_BRST_EN       When set (1), CMIC supports PIO Read Bursts
 *     WR_BRST_EN       When set (1), CMIC supports PIO Write Bursts
 *     BE_CHECK_EN      When set (1), CMIC Does BE Check (32-bit) on PCI writes
 *     MSTR_Q_MAX_EN    When set (1), CMIC can queue up to 4 PCI master requests
 *     RESERVED_1       Reserved
 *     RESET_CPS        When set CMIC drives CPS-Channel reset
 *     ACT_LOW_INT      When set CMIC drives INTR pin as Active LOW (0) - Default is Active low
 *     SCHAN_ABORT      When set CMIC aborts any pending SCH operation
 *     UNTAG_ALL_RCV_EN When set CMIC removes the TAG field from all received Packets
 *     UNTAG_EN         When set CMIC can remove the TAG field
 *     LE_DMA_EN        When set CMIC the DMA data transfer will be done in Little Endian format
 *     I2C_EN           When set CMIC PCI access to I2C interface is Enabled
 *     RESERVED_2       Reserved
 *     IGNORE_ADR_ALIGN_EN When set, allow DMA (PCI->SOC) to be aligned to any address boundary.
 *     RESERVED_3       Reserved
 *     DMA_GARBAGE_COLLECT_EN When set CMIC collects packets with Purge bit set
 *     RESET_PCI_EN     If set, CPS reset will also  reset the internal CMIC PCI interface.
 *     TIME_STAMP_UPD_DIS Disable packet time stamp update operation.  DEBUG ONLY.
 *     SG_ENABLE        Enable scatter/gather operation.
 *     SG_RELOAD_ENABLE Enable scatter/gather reload operation.
 *     RLD_STS_UPD_DIS  When set, do not update status fields on reload operation.
 *     STOP_LS_ON_CHANGE When set, on link change detection, stop link scanning
 *     ABORT_STAT_DMA   Abort the current stat DMA operation.  Not for normal operation.
 *     RESERVED_4       Reserved
 *     COS_RX_EN        When set, packet DMA is based on received COS.  Multiple write channels can be active. 
 *     RESERVED_5       Reserved
 *     OVER_RIDE_EXT_MDIO_MSTR_CNTRL When set, external MDIO master access is disabled,and CMIC becomes the MDIO master, allowing hardware link scan. MUST BE 1 FOR NORMAL OPERATION. Set to 0x0 by default to allow ATE tests to access XAUI/SERDES cores.
 *     MIIM_ADDR_MAP_ENABLE When set, use the MDIO Address Map Table to get the Phy IDfrom the port number for both Wr/Rd and link scan.Else, use the Phy ID as-is.
 *     RESERVED_6       Reserved
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_CONFIGr 0x0000010c

#define BCM56504_A0_CMIC_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CONFIG.
 *
 */
typedef union BCM56504_A0_CMIC_CONFIGr_s {
	uint32_t v[1];
	uint32_t cmic_config[1];
	uint32_t _cmic_config;
} BCM56504_A0_CMIC_CONFIGr_t;

#define BCM56504_A0_CMIC_CONFIGr_CLR(r) (r).cmic_config[0] = 0
#define BCM56504_A0_CMIC_CONFIGr_SET(r,d) (r).cmic_config[0] = d
#define BCM56504_A0_CMIC_CONFIGr_GET(r) (r).cmic_config[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_CONFIGr_RD_BRST_ENf_GET(r) (((r).cmic_config[0]) & 0x1)
#define BCM56504_A0_CMIC_CONFIGr_RD_BRST_ENf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_CMIC_CONFIGr_WR_BRST_ENf_GET(r) ((((r).cmic_config[0]) >> 1) & 0x1)
#define BCM56504_A0_CMIC_CONFIGr_WR_BRST_ENf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_CMIC_CONFIGr_BE_CHECK_ENf_GET(r) ((((r).cmic_config[0]) >> 2) & 0x1)
#define BCM56504_A0_CMIC_CONFIGr_BE_CHECK_ENf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_CMIC_CONFIGr_MSTR_Q_MAX_ENf_GET(r) ((((r).cmic_config[0]) >> 3) & 0x1)
#define BCM56504_A0_CMIC_CONFIGr_MSTR_Q_MAX_ENf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_CMIC_CONFIGr_RESERVED_1f_GET(r) ((((r).cmic_config[0]) >> 4) & 0x1)
#define BCM56504_A0_CMIC_CONFIGr_RESERVED_1f_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56504_A0_CMIC_CONFIGr_RESET_CPSf_GET(r) ((((r).cmic_config[0]) >> 5) & 0x1)
#define BCM56504_A0_CMIC_CONFIGr_RESET_CPSf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56504_A0_CMIC_CONFIGr_ACT_LOW_INTf_GET(r) ((((r).cmic_config[0]) >> 6) & 0x1)
#define BCM56504_A0_CMIC_CONFIGr_ACT_LOW_INTf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56504_A0_CMIC_CONFIGr_SCHAN_ABORTf_GET(r) ((((r).cmic_config[0]) >> 7) & 0x1)
#define BCM56504_A0_CMIC_CONFIGr_SCHAN_ABORTf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56504_A0_CMIC_CONFIGr_UNTAG_ALL_RCV_ENf_GET(r) ((((r).cmic_config[0]) >> 8) & 0x1)
#define BCM56504_A0_CMIC_CONFIGr_UNTAG_ALL_RCV_ENf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56504_A0_CMIC_CONFIGr_UNTAG_ENf_GET(r) ((((r).cmic_config[0]) >> 9) & 0x1)
#define BCM56504_A0_CMIC_CONFIGr_UNTAG_ENf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56504_A0_CMIC_CONFIGr_LE_DMA_ENf_GET(r) ((((r).cmic_config[0]) >> 10) & 0x1)
#define BCM56504_A0_CMIC_CONFIGr_LE_DMA_ENf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56504_A0_CMIC_CONFIGr_I2C_ENf_GET(r) ((((r).cmic_config[0]) >> 11) & 0x1)
#define BCM56504_A0_CMIC_CONFIGr_I2C_ENf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56504_A0_CMIC_CONFIGr_RESERVED_2f_GET(r) ((((r).cmic_config[0]) >> 12) & 0x1)
#define BCM56504_A0_CMIC_CONFIGr_RESERVED_2f_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM56504_A0_CMIC_CONFIGr_IGNORE_ADR_ALIGN_ENf_GET(r) ((((r).cmic_config[0]) >> 13) & 0x1)
#define BCM56504_A0_CMIC_CONFIGr_IGNORE_ADR_ALIGN_ENf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56504_A0_CMIC_CONFIGr_RESERVED_3f_GET(r) ((((r).cmic_config[0]) >> 14) & 0x1)
#define BCM56504_A0_CMIC_CONFIGr_RESERVED_3f_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM56504_A0_CMIC_CONFIGr_DMA_GARBAGE_COLLECT_ENf_GET(r) ((((r).cmic_config[0]) >> 15) & 0x1)
#define BCM56504_A0_CMIC_CONFIGr_DMA_GARBAGE_COLLECT_ENf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56504_A0_CMIC_CONFIGr_RESET_PCI_ENf_GET(r) ((((r).cmic_config[0]) >> 16) & 0x1)
#define BCM56504_A0_CMIC_CONFIGr_RESET_PCI_ENf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56504_A0_CMIC_CONFIGr_TIME_STAMP_UPD_DISf_GET(r) ((((r).cmic_config[0]) >> 17) & 0x1)
#define BCM56504_A0_CMIC_CONFIGr_TIME_STAMP_UPD_DISf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56504_A0_CMIC_CONFIGr_SG_ENABLEf_GET(r) ((((r).cmic_config[0]) >> 18) & 0x1)
#define BCM56504_A0_CMIC_CONFIGr_SG_ENABLEf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56504_A0_CMIC_CONFIGr_SG_RELOAD_ENABLEf_GET(r) ((((r).cmic_config[0]) >> 19) & 0x1)
#define BCM56504_A0_CMIC_CONFIGr_SG_RELOAD_ENABLEf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56504_A0_CMIC_CONFIGr_RLD_STS_UPD_DISf_GET(r) ((((r).cmic_config[0]) >> 20) & 0x1)
#define BCM56504_A0_CMIC_CONFIGr_RLD_STS_UPD_DISf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM56504_A0_CMIC_CONFIGr_STOP_LS_ON_CHANGEf_GET(r) ((((r).cmic_config[0]) >> 21) & 0x1)
#define BCM56504_A0_CMIC_CONFIGr_STOP_LS_ON_CHANGEf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM56504_A0_CMIC_CONFIGr_ABORT_STAT_DMAf_GET(r) ((((r).cmic_config[0]) >> 22) & 0x1)
#define BCM56504_A0_CMIC_CONFIGr_ABORT_STAT_DMAf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM56504_A0_CMIC_CONFIGr_RESERVED_4f_GET(r) ((((r).cmic_config[0]) >> 23) & 0x1)
#define BCM56504_A0_CMIC_CONFIGr_RESERVED_4f_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM56504_A0_CMIC_CONFIGr_COS_RX_ENf_GET(r) ((((r).cmic_config[0]) >> 24) & 0x1)
#define BCM56504_A0_CMIC_CONFIGr_COS_RX_ENf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM56504_A0_CMIC_CONFIGr_RESERVED_5f_GET(r) ((((r).cmic_config[0]) >> 25) & 0x1)
#define BCM56504_A0_CMIC_CONFIGr_RESERVED_5f_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM56504_A0_CMIC_CONFIGr_OVER_RIDE_EXT_MDIO_MSTR_CNTRLf_GET(r) ((((r).cmic_config[0]) >> 26) & 0x1)
#define BCM56504_A0_CMIC_CONFIGr_OVER_RIDE_EXT_MDIO_MSTR_CNTRLf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM56504_A0_CMIC_CONFIGr_MIIM_ADDR_MAP_ENABLEf_GET(r) ((((r).cmic_config[0]) >> 27) & 0x1)
#define BCM56504_A0_CMIC_CONFIGr_MIIM_ADDR_MAP_ENABLEf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM56504_A0_CMIC_CONFIGr_RESERVED_6f_GET(r) ((((r).cmic_config[0]) >> 28) & 0xf)
#define BCM56504_A0_CMIC_CONFIGr_RESERVED_6f_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access CMIC_CONFIG.
 *
 */
#define BCM56504_A0_READ_CMIC_CONFIGr(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_CONFIGr,r._cmic_config)
#define BCM56504_A0_WRITE_CMIC_CONFIGr(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_CONFIGr,r._cmic_config)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_CONFIGr BCM56504_A0_CMIC_CONFIGr
#define CMIC_CONFIGr_SIZE BCM56504_A0_CMIC_CONFIGr_SIZE
typedef BCM56504_A0_CMIC_CONFIGr_t CMIC_CONFIGr_t;
#define CMIC_CONFIGr_CLR BCM56504_A0_CMIC_CONFIGr_CLR
#define CMIC_CONFIGr_SET BCM56504_A0_CMIC_CONFIGr_SET
#define CMIC_CONFIGr_GET BCM56504_A0_CMIC_CONFIGr_GET
#define CMIC_CONFIGr_RD_BRST_ENf_GET BCM56504_A0_CMIC_CONFIGr_RD_BRST_ENf_GET
#define CMIC_CONFIGr_RD_BRST_ENf_SET BCM56504_A0_CMIC_CONFIGr_RD_BRST_ENf_SET
#define CMIC_CONFIGr_WR_BRST_ENf_GET BCM56504_A0_CMIC_CONFIGr_WR_BRST_ENf_GET
#define CMIC_CONFIGr_WR_BRST_ENf_SET BCM56504_A0_CMIC_CONFIGr_WR_BRST_ENf_SET
#define CMIC_CONFIGr_BE_CHECK_ENf_GET BCM56504_A0_CMIC_CONFIGr_BE_CHECK_ENf_GET
#define CMIC_CONFIGr_BE_CHECK_ENf_SET BCM56504_A0_CMIC_CONFIGr_BE_CHECK_ENf_SET
#define CMIC_CONFIGr_MSTR_Q_MAX_ENf_GET BCM56504_A0_CMIC_CONFIGr_MSTR_Q_MAX_ENf_GET
#define CMIC_CONFIGr_MSTR_Q_MAX_ENf_SET BCM56504_A0_CMIC_CONFIGr_MSTR_Q_MAX_ENf_SET
#define CMIC_CONFIGr_RESERVED_1f_GET BCM56504_A0_CMIC_CONFIGr_RESERVED_1f_GET
#define CMIC_CONFIGr_RESERVED_1f_SET BCM56504_A0_CMIC_CONFIGr_RESERVED_1f_SET
#define CMIC_CONFIGr_RESET_CPSf_GET BCM56504_A0_CMIC_CONFIGr_RESET_CPSf_GET
#define CMIC_CONFIGr_RESET_CPSf_SET BCM56504_A0_CMIC_CONFIGr_RESET_CPSf_SET
#define CMIC_CONFIGr_ACT_LOW_INTf_GET BCM56504_A0_CMIC_CONFIGr_ACT_LOW_INTf_GET
#define CMIC_CONFIGr_ACT_LOW_INTf_SET BCM56504_A0_CMIC_CONFIGr_ACT_LOW_INTf_SET
#define CMIC_CONFIGr_SCHAN_ABORTf_GET BCM56504_A0_CMIC_CONFIGr_SCHAN_ABORTf_GET
#define CMIC_CONFIGr_SCHAN_ABORTf_SET BCM56504_A0_CMIC_CONFIGr_SCHAN_ABORTf_SET
#define CMIC_CONFIGr_UNTAG_ALL_RCV_ENf_GET BCM56504_A0_CMIC_CONFIGr_UNTAG_ALL_RCV_ENf_GET
#define CMIC_CONFIGr_UNTAG_ALL_RCV_ENf_SET BCM56504_A0_CMIC_CONFIGr_UNTAG_ALL_RCV_ENf_SET
#define CMIC_CONFIGr_UNTAG_ENf_GET BCM56504_A0_CMIC_CONFIGr_UNTAG_ENf_GET
#define CMIC_CONFIGr_UNTAG_ENf_SET BCM56504_A0_CMIC_CONFIGr_UNTAG_ENf_SET
#define CMIC_CONFIGr_LE_DMA_ENf_GET BCM56504_A0_CMIC_CONFIGr_LE_DMA_ENf_GET
#define CMIC_CONFIGr_LE_DMA_ENf_SET BCM56504_A0_CMIC_CONFIGr_LE_DMA_ENf_SET
#define CMIC_CONFIGr_I2C_ENf_GET BCM56504_A0_CMIC_CONFIGr_I2C_ENf_GET
#define CMIC_CONFIGr_I2C_ENf_SET BCM56504_A0_CMIC_CONFIGr_I2C_ENf_SET
#define CMIC_CONFIGr_RESERVED_2f_GET BCM56504_A0_CMIC_CONFIGr_RESERVED_2f_GET
#define CMIC_CONFIGr_RESERVED_2f_SET BCM56504_A0_CMIC_CONFIGr_RESERVED_2f_SET
#define CMIC_CONFIGr_IGNORE_ADR_ALIGN_ENf_GET BCM56504_A0_CMIC_CONFIGr_IGNORE_ADR_ALIGN_ENf_GET
#define CMIC_CONFIGr_IGNORE_ADR_ALIGN_ENf_SET BCM56504_A0_CMIC_CONFIGr_IGNORE_ADR_ALIGN_ENf_SET
#define CMIC_CONFIGr_RESERVED_3f_GET BCM56504_A0_CMIC_CONFIGr_RESERVED_3f_GET
#define CMIC_CONFIGr_RESERVED_3f_SET BCM56504_A0_CMIC_CONFIGr_RESERVED_3f_SET
#define CMIC_CONFIGr_DMA_GARBAGE_COLLECT_ENf_GET BCM56504_A0_CMIC_CONFIGr_DMA_GARBAGE_COLLECT_ENf_GET
#define CMIC_CONFIGr_DMA_GARBAGE_COLLECT_ENf_SET BCM56504_A0_CMIC_CONFIGr_DMA_GARBAGE_COLLECT_ENf_SET
#define CMIC_CONFIGr_RESET_PCI_ENf_GET BCM56504_A0_CMIC_CONFIGr_RESET_PCI_ENf_GET
#define CMIC_CONFIGr_RESET_PCI_ENf_SET BCM56504_A0_CMIC_CONFIGr_RESET_PCI_ENf_SET
#define CMIC_CONFIGr_TIME_STAMP_UPD_DISf_GET BCM56504_A0_CMIC_CONFIGr_TIME_STAMP_UPD_DISf_GET
#define CMIC_CONFIGr_TIME_STAMP_UPD_DISf_SET BCM56504_A0_CMIC_CONFIGr_TIME_STAMP_UPD_DISf_SET
#define CMIC_CONFIGr_SG_ENABLEf_GET BCM56504_A0_CMIC_CONFIGr_SG_ENABLEf_GET
#define CMIC_CONFIGr_SG_ENABLEf_SET BCM56504_A0_CMIC_CONFIGr_SG_ENABLEf_SET
#define CMIC_CONFIGr_SG_RELOAD_ENABLEf_GET BCM56504_A0_CMIC_CONFIGr_SG_RELOAD_ENABLEf_GET
#define CMIC_CONFIGr_SG_RELOAD_ENABLEf_SET BCM56504_A0_CMIC_CONFIGr_SG_RELOAD_ENABLEf_SET
#define CMIC_CONFIGr_RLD_STS_UPD_DISf_GET BCM56504_A0_CMIC_CONFIGr_RLD_STS_UPD_DISf_GET
#define CMIC_CONFIGr_RLD_STS_UPD_DISf_SET BCM56504_A0_CMIC_CONFIGr_RLD_STS_UPD_DISf_SET
#define CMIC_CONFIGr_STOP_LS_ON_CHANGEf_GET BCM56504_A0_CMIC_CONFIGr_STOP_LS_ON_CHANGEf_GET
#define CMIC_CONFIGr_STOP_LS_ON_CHANGEf_SET BCM56504_A0_CMIC_CONFIGr_STOP_LS_ON_CHANGEf_SET
#define CMIC_CONFIGr_ABORT_STAT_DMAf_GET BCM56504_A0_CMIC_CONFIGr_ABORT_STAT_DMAf_GET
#define CMIC_CONFIGr_ABORT_STAT_DMAf_SET BCM56504_A0_CMIC_CONFIGr_ABORT_STAT_DMAf_SET
#define CMIC_CONFIGr_RESERVED_4f_GET BCM56504_A0_CMIC_CONFIGr_RESERVED_4f_GET
#define CMIC_CONFIGr_RESERVED_4f_SET BCM56504_A0_CMIC_CONFIGr_RESERVED_4f_SET
#define CMIC_CONFIGr_COS_RX_ENf_GET BCM56504_A0_CMIC_CONFIGr_COS_RX_ENf_GET
#define CMIC_CONFIGr_COS_RX_ENf_SET BCM56504_A0_CMIC_CONFIGr_COS_RX_ENf_SET
#define CMIC_CONFIGr_RESERVED_5f_GET BCM56504_A0_CMIC_CONFIGr_RESERVED_5f_GET
#define CMIC_CONFIGr_RESERVED_5f_SET BCM56504_A0_CMIC_CONFIGr_RESERVED_5f_SET
#define CMIC_CONFIGr_OVER_RIDE_EXT_MDIO_MSTR_CNTRLf_GET BCM56504_A0_CMIC_CONFIGr_OVER_RIDE_EXT_MDIO_MSTR_CNTRLf_GET
#define CMIC_CONFIGr_OVER_RIDE_EXT_MDIO_MSTR_CNTRLf_SET BCM56504_A0_CMIC_CONFIGr_OVER_RIDE_EXT_MDIO_MSTR_CNTRLf_SET
#define CMIC_CONFIGr_MIIM_ADDR_MAP_ENABLEf_GET BCM56504_A0_CMIC_CONFIGr_MIIM_ADDR_MAP_ENABLEf_GET
#define CMIC_CONFIGr_MIIM_ADDR_MAP_ENABLEf_SET BCM56504_A0_CMIC_CONFIGr_MIIM_ADDR_MAP_ENABLEf_SET
#define CMIC_CONFIGr_RESERVED_6f_GET BCM56504_A0_CMIC_CONFIGr_RESERVED_6f_GET
#define CMIC_CONFIGr_RESERVED_6f_SET BCM56504_A0_CMIC_CONFIGr_RESERVED_6f_SET
#define READ_CMIC_CONFIGr BCM56504_A0_READ_CMIC_CONFIGr
#define WRITE_CMIC_CONFIGr BCM56504_A0_WRITE_CMIC_CONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_COS_CTRL_RX
 * BLOCKS:   CMIC
 * DESC:     When COS_RX_EN of CMIC_CONFIG is set, this register
indicates which cos are admitted by channel 

 * SIZE:     32
 * FIELDS:
 *     CH0_COS_BMP      Channel 0 COS bitmap
 *     CH1_COS_BMP      Channel 1 COS bitmap
 *     CH2_COS_BMP      Channel 2 COS bitmap
 *     CH3_COS_BMP      Channel 3 COS bitmap
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_COS_CTRL_RXr 0x00000180

#define BCM56504_A0_CMIC_COS_CTRL_RXr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_COS_CTRL_RX.
 *
 */
typedef union BCM56504_A0_CMIC_COS_CTRL_RXr_s {
	uint32_t v[1];
	uint32_t cmic_cos_ctrl_rx[1];
	uint32_t _cmic_cos_ctrl_rx;
} BCM56504_A0_CMIC_COS_CTRL_RXr_t;

#define BCM56504_A0_CMIC_COS_CTRL_RXr_CLR(r) (r).cmic_cos_ctrl_rx[0] = 0
#define BCM56504_A0_CMIC_COS_CTRL_RXr_SET(r,d) (r).cmic_cos_ctrl_rx[0] = d
#define BCM56504_A0_CMIC_COS_CTRL_RXr_GET(r) (r).cmic_cos_ctrl_rx[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_COS_CTRL_RXr_CH0_COS_BMPf_GET(r) (((r).cmic_cos_ctrl_rx[0]) & 0xff)
#define BCM56504_A0_CMIC_COS_CTRL_RXr_CH0_COS_BMPf_SET(r,f) (r).cmic_cos_ctrl_rx[0]=(((r).cmic_cos_ctrl_rx[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56504_A0_CMIC_COS_CTRL_RXr_CH1_COS_BMPf_GET(r) ((((r).cmic_cos_ctrl_rx[0]) >> 8) & 0xff)
#define BCM56504_A0_CMIC_COS_CTRL_RXr_CH1_COS_BMPf_SET(r,f) (r).cmic_cos_ctrl_rx[0]=(((r).cmic_cos_ctrl_rx[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCM56504_A0_CMIC_COS_CTRL_RXr_CH2_COS_BMPf_GET(r) ((((r).cmic_cos_ctrl_rx[0]) >> 16) & 0xff)
#define BCM56504_A0_CMIC_COS_CTRL_RXr_CH2_COS_BMPf_SET(r,f) (r).cmic_cos_ctrl_rx[0]=(((r).cmic_cos_ctrl_rx[0] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define BCM56504_A0_CMIC_COS_CTRL_RXr_CH3_COS_BMPf_GET(r) ((((r).cmic_cos_ctrl_rx[0]) >> 24) & 0xff)
#define BCM56504_A0_CMIC_COS_CTRL_RXr_CH3_COS_BMPf_SET(r,f) (r).cmic_cos_ctrl_rx[0]=(((r).cmic_cos_ctrl_rx[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access CMIC_COS_CTRL_RX.
 *
 */
#define BCM56504_A0_READ_CMIC_COS_CTRL_RXr(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_COS_CTRL_RXr,r._cmic_cos_ctrl_rx)
#define BCM56504_A0_WRITE_CMIC_COS_CTRL_RXr(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_COS_CTRL_RXr,r._cmic_cos_ctrl_rx)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_COS_CTRL_RXr BCM56504_A0_CMIC_COS_CTRL_RXr
#define CMIC_COS_CTRL_RXr_SIZE BCM56504_A0_CMIC_COS_CTRL_RXr_SIZE
typedef BCM56504_A0_CMIC_COS_CTRL_RXr_t CMIC_COS_CTRL_RXr_t;
#define CMIC_COS_CTRL_RXr_CLR BCM56504_A0_CMIC_COS_CTRL_RXr_CLR
#define CMIC_COS_CTRL_RXr_SET BCM56504_A0_CMIC_COS_CTRL_RXr_SET
#define CMIC_COS_CTRL_RXr_GET BCM56504_A0_CMIC_COS_CTRL_RXr_GET
#define CMIC_COS_CTRL_RXr_CH0_COS_BMPf_GET BCM56504_A0_CMIC_COS_CTRL_RXr_CH0_COS_BMPf_GET
#define CMIC_COS_CTRL_RXr_CH0_COS_BMPf_SET BCM56504_A0_CMIC_COS_CTRL_RXr_CH0_COS_BMPf_SET
#define CMIC_COS_CTRL_RXr_CH1_COS_BMPf_GET BCM56504_A0_CMIC_COS_CTRL_RXr_CH1_COS_BMPf_GET
#define CMIC_COS_CTRL_RXr_CH1_COS_BMPf_SET BCM56504_A0_CMIC_COS_CTRL_RXr_CH1_COS_BMPf_SET
#define CMIC_COS_CTRL_RXr_CH2_COS_BMPf_GET BCM56504_A0_CMIC_COS_CTRL_RXr_CH2_COS_BMPf_GET
#define CMIC_COS_CTRL_RXr_CH2_COS_BMPf_SET BCM56504_A0_CMIC_COS_CTRL_RXr_CH2_COS_BMPf_SET
#define CMIC_COS_CTRL_RXr_CH3_COS_BMPf_GET BCM56504_A0_CMIC_COS_CTRL_RXr_CH3_COS_BMPf_GET
#define CMIC_COS_CTRL_RXr_CH3_COS_BMPf_SET BCM56504_A0_CMIC_COS_CTRL_RXr_CH3_COS_BMPf_SET
#define READ_CMIC_COS_CTRL_RXr BCM56504_A0_READ_CMIC_COS_CTRL_RXr
#define WRITE_CMIC_COS_CTRL_RXr BCM56504_A0_WRITE_CMIC_COS_CTRL_RXr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_COS_CTRL_RXr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_DEV_REV_ID
 * BLOCKS:   CMIC
 * DESC:     Device/revision ID
 * SIZE:     32
 * FIELDS:
 *     DEV_ID           Device ID
 *     REV_ID           Revision ID
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_DEV_REV_IDr 0x00000178

#define BCM56504_A0_CMIC_DEV_REV_IDr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_DEV_REV_ID.
 *
 */
typedef union BCM56504_A0_CMIC_DEV_REV_IDr_s {
	uint32_t v[1];
	uint32_t cmic_dev_rev_id[1];
	uint32_t _cmic_dev_rev_id;
} BCM56504_A0_CMIC_DEV_REV_IDr_t;

#define BCM56504_A0_CMIC_DEV_REV_IDr_CLR(r) (r).cmic_dev_rev_id[0] = 0
#define BCM56504_A0_CMIC_DEV_REV_IDr_SET(r,d) (r).cmic_dev_rev_id[0] = d
#define BCM56504_A0_CMIC_DEV_REV_IDr_GET(r) (r).cmic_dev_rev_id[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_DEV_REV_IDr_DEV_IDf_GET(r) (((r).cmic_dev_rev_id[0]) & 0xffff)
#define BCM56504_A0_CMIC_DEV_REV_IDr_DEV_IDf_SET(r,f) (r).cmic_dev_rev_id[0]=(((r).cmic_dev_rev_id[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56504_A0_CMIC_DEV_REV_IDr_REV_IDf_GET(r) ((((r).cmic_dev_rev_id[0]) >> 16) & 0xff)
#define BCM56504_A0_CMIC_DEV_REV_IDr_REV_IDf_SET(r,f) (r).cmic_dev_rev_id[0]=(((r).cmic_dev_rev_id[0] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define BCM56504_A0_CMIC_DEV_REV_IDr_RESERVED_1f_GET(r) ((((r).cmic_dev_rev_id[0]) >> 24) & 0xff)
#define BCM56504_A0_CMIC_DEV_REV_IDr_RESERVED_1f_SET(r,f) (r).cmic_dev_rev_id[0]=(((r).cmic_dev_rev_id[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access CMIC_DEV_REV_ID.
 *
 */
#define BCM56504_A0_READ_CMIC_DEV_REV_IDr(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_DEV_REV_IDr,r._cmic_dev_rev_id)
#define BCM56504_A0_WRITE_CMIC_DEV_REV_IDr(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_DEV_REV_IDr,r._cmic_dev_rev_id)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_DEV_REV_IDr BCM56504_A0_CMIC_DEV_REV_IDr
#define CMIC_DEV_REV_IDr_SIZE BCM56504_A0_CMIC_DEV_REV_IDr_SIZE
typedef BCM56504_A0_CMIC_DEV_REV_IDr_t CMIC_DEV_REV_IDr_t;
#define CMIC_DEV_REV_IDr_CLR BCM56504_A0_CMIC_DEV_REV_IDr_CLR
#define CMIC_DEV_REV_IDr_SET BCM56504_A0_CMIC_DEV_REV_IDr_SET
#define CMIC_DEV_REV_IDr_GET BCM56504_A0_CMIC_DEV_REV_IDr_GET
#define CMIC_DEV_REV_IDr_DEV_IDf_GET BCM56504_A0_CMIC_DEV_REV_IDr_DEV_IDf_GET
#define CMIC_DEV_REV_IDr_DEV_IDf_SET BCM56504_A0_CMIC_DEV_REV_IDr_DEV_IDf_SET
#define CMIC_DEV_REV_IDr_REV_IDf_GET BCM56504_A0_CMIC_DEV_REV_IDr_REV_IDf_GET
#define CMIC_DEV_REV_IDr_REV_IDf_SET BCM56504_A0_CMIC_DEV_REV_IDr_REV_IDf_SET
#define CMIC_DEV_REV_IDr_RESERVED_1f_GET BCM56504_A0_CMIC_DEV_REV_IDr_RESERVED_1f_GET
#define CMIC_DEV_REV_IDr_RESERVED_1f_SET BCM56504_A0_CMIC_DEV_REV_IDr_RESERVED_1f_SET
#define READ_CMIC_DEV_REV_IDr BCM56504_A0_READ_CMIC_DEV_REV_IDr
#define WRITE_CMIC_DEV_REV_IDr BCM56504_A0_WRITE_CMIC_DEV_REV_IDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_DEV_REV_IDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_DMA_CTRL
 * BLOCKS:   CMIC
 * DESC:     DMA Control Register
 * SIZE:     32
 * FIELDS:
 *     CH0_DIRECTION    DMA channel 0 direction:1=Mem->SOC, 0=SOC->Mem
 *     RESERVED_1_CH0   Reserved
 *     CH0_ABORT_DMA    DMA channel 0 abort
 *     CH0_SEL_INTR_ON_DESC_OR_PKT DMA channel 0 interrupt select:1=after descriptor, 0=after packet
 *     RESERVED_2_CH0   Reserved
 *     RESERVED_3_CH0   Reserved
 *     CH0_DROP_RX_PKT_ON_CHAIN_END DMA channel 0 setting for handling packet received after hittingend of chain (and hence no descriptors are available)1=drop the packet, 0=block, waiting for descriptor to be available
 *     CH1_DIRECTION    DMA channel 1 direction:1=Mem->SOC, 0=SOC->Mem
 *     RESERVED_1_CH1   Reserved
 *     CH1_ABORT_DMA    DMA channel 1 abort
 *     CH1_SEL_INTR_ON_DESC_OR_PKT DMA channel 1 interrupt select:1=after descriptor, 0=after packet
 *     RESERVED_2_CH1   Reserved
 *     RESERVED_3_CH1   Reserved
 *     CH1_DROP_RX_PKT_ON_CHAIN_END DMA channel 1 setting for handling packet received after hittingend of chain (and hence no descriptors are available)1=drop the packet, 0=block, waiting for descriptor to be available
 *     CH2_DIRECTION    DMA channel 2 direction:1=Mem->SOC, 0=SOC->Mem
 *     RESERVED_1_CH2   Reserved
 *     CH2_ABORT_DMA    DMA channel 2 abort
 *     CH2_SEL_INTR_ON_DESC_OR_PKT DMA channel 2 interrupt select:1=after descriptor, 0=after packet
 *     RESERVED_2_CH2   Reserved
 *     RESERVED_3_CH2   Reserved
 *     CH2_DROP_RX_PKT_ON_CHAIN_END DMA channel 2 setting for handling packet received after hittingend of chain (and hence no descriptors are available)1=drop the packet, 0=block, waiting for descriptor to be available
 *     CH3_DIRECTION    DMA channel 3 direction:1=Mem->SOC, 0=SOC->Mem
 *     RESERVED_1_CH3   Reserved
 *     CH3_ABORT_DMA    DMA channel 3 abort
 *     CH3_SEL_INTR_ON_DESC_OR_PKT DMA channel 3 interrupt select:1=after descriptor, 0=after packet
 *     RESERVED_2_CH3   Reserved
 *     RESERVED_3_CH3   Reserved
 *     CH3_DROP_RX_PKT_ON_CHAIN_END DMA channel 3 setting for handling packet received after hittingend of chain (and hence no descriptors are available)1=drop the packet, 0=block, waiting for descriptor to be available
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_DMA_CTRLr 0x00000100

#define BCM56504_A0_CMIC_DMA_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_DMA_CTRL.
 *
 */
typedef union BCM56504_A0_CMIC_DMA_CTRLr_s {
	uint32_t v[1];
	uint32_t cmic_dma_ctrl[1];
	uint32_t _cmic_dma_ctrl;
} BCM56504_A0_CMIC_DMA_CTRLr_t;

#define BCM56504_A0_CMIC_DMA_CTRLr_CLR(r) (r).cmic_dma_ctrl[0] = 0
#define BCM56504_A0_CMIC_DMA_CTRLr_SET(r,d) (r).cmic_dma_ctrl[0] = d
#define BCM56504_A0_CMIC_DMA_CTRLr_GET(r) (r).cmic_dma_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_DMA_CTRLr_CH0_DIRECTIONf_GET(r) (((r).cmic_dma_ctrl[0]) & 0x1)
#define BCM56504_A0_CMIC_DMA_CTRLr_CH0_DIRECTIONf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_CMIC_DMA_CTRLr_RESERVED_1_CH0f_GET(r) ((((r).cmic_dma_ctrl[0]) >> 1) & 0x1)
#define BCM56504_A0_CMIC_DMA_CTRLr_RESERVED_1_CH0f_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_CMIC_DMA_CTRLr_CH0_ABORT_DMAf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 2) & 0x1)
#define BCM56504_A0_CMIC_DMA_CTRLr_CH0_ABORT_DMAf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_CMIC_DMA_CTRLr_CH0_SEL_INTR_ON_DESC_OR_PKTf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 3) & 0x1)
#define BCM56504_A0_CMIC_DMA_CTRLr_CH0_SEL_INTR_ON_DESC_OR_PKTf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_CMIC_DMA_CTRLr_RESERVED_2_CH0f_GET(r) ((((r).cmic_dma_ctrl[0]) >> 4) & 0x1)
#define BCM56504_A0_CMIC_DMA_CTRLr_RESERVED_2_CH0f_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56504_A0_CMIC_DMA_CTRLr_RESERVED_3_CH0f_GET(r) ((((r).cmic_dma_ctrl[0]) >> 5) & 0x3)
#define BCM56504_A0_CMIC_DMA_CTRLr_RESERVED_3_CH0f_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5))
#define BCM56504_A0_CMIC_DMA_CTRLr_CH0_DROP_RX_PKT_ON_CHAIN_ENDf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 7) & 0x1)
#define BCM56504_A0_CMIC_DMA_CTRLr_CH0_DROP_RX_PKT_ON_CHAIN_ENDf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56504_A0_CMIC_DMA_CTRLr_CH1_DIRECTIONf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 8) & 0x1)
#define BCM56504_A0_CMIC_DMA_CTRLr_CH1_DIRECTIONf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56504_A0_CMIC_DMA_CTRLr_RESERVED_1_CH1f_GET(r) ((((r).cmic_dma_ctrl[0]) >> 9) & 0x1)
#define BCM56504_A0_CMIC_DMA_CTRLr_RESERVED_1_CH1f_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56504_A0_CMIC_DMA_CTRLr_CH1_ABORT_DMAf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 10) & 0x1)
#define BCM56504_A0_CMIC_DMA_CTRLr_CH1_ABORT_DMAf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56504_A0_CMIC_DMA_CTRLr_CH1_SEL_INTR_ON_DESC_OR_PKTf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 11) & 0x1)
#define BCM56504_A0_CMIC_DMA_CTRLr_CH1_SEL_INTR_ON_DESC_OR_PKTf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56504_A0_CMIC_DMA_CTRLr_RESERVED_2_CH1f_GET(r) ((((r).cmic_dma_ctrl[0]) >> 12) & 0x1)
#define BCM56504_A0_CMIC_DMA_CTRLr_RESERVED_2_CH1f_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM56504_A0_CMIC_DMA_CTRLr_RESERVED_3_CH1f_GET(r) ((((r).cmic_dma_ctrl[0]) >> 13) & 0x3)
#define BCM56504_A0_CMIC_DMA_CTRLr_RESERVED_3_CH1f_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13))
#define BCM56504_A0_CMIC_DMA_CTRLr_CH1_DROP_RX_PKT_ON_CHAIN_ENDf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 15) & 0x1)
#define BCM56504_A0_CMIC_DMA_CTRLr_CH1_DROP_RX_PKT_ON_CHAIN_ENDf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56504_A0_CMIC_DMA_CTRLr_CH2_DIRECTIONf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 16) & 0x1)
#define BCM56504_A0_CMIC_DMA_CTRLr_CH2_DIRECTIONf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56504_A0_CMIC_DMA_CTRLr_RESERVED_1_CH2f_GET(r) ((((r).cmic_dma_ctrl[0]) >> 17) & 0x1)
#define BCM56504_A0_CMIC_DMA_CTRLr_RESERVED_1_CH2f_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56504_A0_CMIC_DMA_CTRLr_CH2_ABORT_DMAf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 18) & 0x1)
#define BCM56504_A0_CMIC_DMA_CTRLr_CH2_ABORT_DMAf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56504_A0_CMIC_DMA_CTRLr_CH2_SEL_INTR_ON_DESC_OR_PKTf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 19) & 0x1)
#define BCM56504_A0_CMIC_DMA_CTRLr_CH2_SEL_INTR_ON_DESC_OR_PKTf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56504_A0_CMIC_DMA_CTRLr_RESERVED_2_CH2f_GET(r) ((((r).cmic_dma_ctrl[0]) >> 20) & 0x1)
#define BCM56504_A0_CMIC_DMA_CTRLr_RESERVED_2_CH2f_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM56504_A0_CMIC_DMA_CTRLr_RESERVED_3_CH2f_GET(r) ((((r).cmic_dma_ctrl[0]) >> 21) & 0x3)
#define BCM56504_A0_CMIC_DMA_CTRLr_RESERVED_3_CH2f_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x3 << 21)) | ((((uint32_t)f) & 0x3) << 21))
#define BCM56504_A0_CMIC_DMA_CTRLr_CH2_DROP_RX_PKT_ON_CHAIN_ENDf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 23) & 0x1)
#define BCM56504_A0_CMIC_DMA_CTRLr_CH2_DROP_RX_PKT_ON_CHAIN_ENDf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM56504_A0_CMIC_DMA_CTRLr_CH3_DIRECTIONf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 24) & 0x1)
#define BCM56504_A0_CMIC_DMA_CTRLr_CH3_DIRECTIONf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM56504_A0_CMIC_DMA_CTRLr_RESERVED_1_CH3f_GET(r) ((((r).cmic_dma_ctrl[0]) >> 25) & 0x1)
#define BCM56504_A0_CMIC_DMA_CTRLr_RESERVED_1_CH3f_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM56504_A0_CMIC_DMA_CTRLr_CH3_ABORT_DMAf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 26) & 0x1)
#define BCM56504_A0_CMIC_DMA_CTRLr_CH3_ABORT_DMAf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM56504_A0_CMIC_DMA_CTRLr_CH3_SEL_INTR_ON_DESC_OR_PKTf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 27) & 0x1)
#define BCM56504_A0_CMIC_DMA_CTRLr_CH3_SEL_INTR_ON_DESC_OR_PKTf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM56504_A0_CMIC_DMA_CTRLr_RESERVED_2_CH3f_GET(r) ((((r).cmic_dma_ctrl[0]) >> 28) & 0x1)
#define BCM56504_A0_CMIC_DMA_CTRLr_RESERVED_2_CH3f_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM56504_A0_CMIC_DMA_CTRLr_RESERVED_3_CH3f_GET(r) ((((r).cmic_dma_ctrl[0]) >> 29) & 0x3)
#define BCM56504_A0_CMIC_DMA_CTRLr_RESERVED_3_CH3f_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x3 << 29)) | ((((uint32_t)f) & 0x3) << 29))
#define BCM56504_A0_CMIC_DMA_CTRLr_CH3_DROP_RX_PKT_ON_CHAIN_ENDf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 31) & 0x1)
#define BCM56504_A0_CMIC_DMA_CTRLr_CH3_DROP_RX_PKT_ON_CHAIN_ENDf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access CMIC_DMA_CTRL.
 *
 */
#define BCM56504_A0_READ_CMIC_DMA_CTRLr(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_DMA_CTRLr,r._cmic_dma_ctrl)
#define BCM56504_A0_WRITE_CMIC_DMA_CTRLr(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_DMA_CTRLr,r._cmic_dma_ctrl)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_DMA_CTRLr BCM56504_A0_CMIC_DMA_CTRLr
#define CMIC_DMA_CTRLr_SIZE BCM56504_A0_CMIC_DMA_CTRLr_SIZE
typedef BCM56504_A0_CMIC_DMA_CTRLr_t CMIC_DMA_CTRLr_t;
#define CMIC_DMA_CTRLr_CLR BCM56504_A0_CMIC_DMA_CTRLr_CLR
#define CMIC_DMA_CTRLr_SET BCM56504_A0_CMIC_DMA_CTRLr_SET
#define CMIC_DMA_CTRLr_GET BCM56504_A0_CMIC_DMA_CTRLr_GET
#define CMIC_DMA_CTRLr_CH0_DIRECTIONf_GET BCM56504_A0_CMIC_DMA_CTRLr_CH0_DIRECTIONf_GET
#define CMIC_DMA_CTRLr_CH0_DIRECTIONf_SET BCM56504_A0_CMIC_DMA_CTRLr_CH0_DIRECTIONf_SET
#define CMIC_DMA_CTRLr_RESERVED_1_CH0f_GET BCM56504_A0_CMIC_DMA_CTRLr_RESERVED_1_CH0f_GET
#define CMIC_DMA_CTRLr_RESERVED_1_CH0f_SET BCM56504_A0_CMIC_DMA_CTRLr_RESERVED_1_CH0f_SET
#define CMIC_DMA_CTRLr_CH0_ABORT_DMAf_GET BCM56504_A0_CMIC_DMA_CTRLr_CH0_ABORT_DMAf_GET
#define CMIC_DMA_CTRLr_CH0_ABORT_DMAf_SET BCM56504_A0_CMIC_DMA_CTRLr_CH0_ABORT_DMAf_SET
#define CMIC_DMA_CTRLr_CH0_SEL_INTR_ON_DESC_OR_PKTf_GET BCM56504_A0_CMIC_DMA_CTRLr_CH0_SEL_INTR_ON_DESC_OR_PKTf_GET
#define CMIC_DMA_CTRLr_CH0_SEL_INTR_ON_DESC_OR_PKTf_SET BCM56504_A0_CMIC_DMA_CTRLr_CH0_SEL_INTR_ON_DESC_OR_PKTf_SET
#define CMIC_DMA_CTRLr_RESERVED_2_CH0f_GET BCM56504_A0_CMIC_DMA_CTRLr_RESERVED_2_CH0f_GET
#define CMIC_DMA_CTRLr_RESERVED_2_CH0f_SET BCM56504_A0_CMIC_DMA_CTRLr_RESERVED_2_CH0f_SET
#define CMIC_DMA_CTRLr_RESERVED_3_CH0f_GET BCM56504_A0_CMIC_DMA_CTRLr_RESERVED_3_CH0f_GET
#define CMIC_DMA_CTRLr_RESERVED_3_CH0f_SET BCM56504_A0_CMIC_DMA_CTRLr_RESERVED_3_CH0f_SET
#define CMIC_DMA_CTRLr_CH0_DROP_RX_PKT_ON_CHAIN_ENDf_GET BCM56504_A0_CMIC_DMA_CTRLr_CH0_DROP_RX_PKT_ON_CHAIN_ENDf_GET
#define CMIC_DMA_CTRLr_CH0_DROP_RX_PKT_ON_CHAIN_ENDf_SET BCM56504_A0_CMIC_DMA_CTRLr_CH0_DROP_RX_PKT_ON_CHAIN_ENDf_SET
#define CMIC_DMA_CTRLr_CH1_DIRECTIONf_GET BCM56504_A0_CMIC_DMA_CTRLr_CH1_DIRECTIONf_GET
#define CMIC_DMA_CTRLr_CH1_DIRECTIONf_SET BCM56504_A0_CMIC_DMA_CTRLr_CH1_DIRECTIONf_SET
#define CMIC_DMA_CTRLr_RESERVED_1_CH1f_GET BCM56504_A0_CMIC_DMA_CTRLr_RESERVED_1_CH1f_GET
#define CMIC_DMA_CTRLr_RESERVED_1_CH1f_SET BCM56504_A0_CMIC_DMA_CTRLr_RESERVED_1_CH1f_SET
#define CMIC_DMA_CTRLr_CH1_ABORT_DMAf_GET BCM56504_A0_CMIC_DMA_CTRLr_CH1_ABORT_DMAf_GET
#define CMIC_DMA_CTRLr_CH1_ABORT_DMAf_SET BCM56504_A0_CMIC_DMA_CTRLr_CH1_ABORT_DMAf_SET
#define CMIC_DMA_CTRLr_CH1_SEL_INTR_ON_DESC_OR_PKTf_GET BCM56504_A0_CMIC_DMA_CTRLr_CH1_SEL_INTR_ON_DESC_OR_PKTf_GET
#define CMIC_DMA_CTRLr_CH1_SEL_INTR_ON_DESC_OR_PKTf_SET BCM56504_A0_CMIC_DMA_CTRLr_CH1_SEL_INTR_ON_DESC_OR_PKTf_SET
#define CMIC_DMA_CTRLr_RESERVED_2_CH1f_GET BCM56504_A0_CMIC_DMA_CTRLr_RESERVED_2_CH1f_GET
#define CMIC_DMA_CTRLr_RESERVED_2_CH1f_SET BCM56504_A0_CMIC_DMA_CTRLr_RESERVED_2_CH1f_SET
#define CMIC_DMA_CTRLr_RESERVED_3_CH1f_GET BCM56504_A0_CMIC_DMA_CTRLr_RESERVED_3_CH1f_GET
#define CMIC_DMA_CTRLr_RESERVED_3_CH1f_SET BCM56504_A0_CMIC_DMA_CTRLr_RESERVED_3_CH1f_SET
#define CMIC_DMA_CTRLr_CH1_DROP_RX_PKT_ON_CHAIN_ENDf_GET BCM56504_A0_CMIC_DMA_CTRLr_CH1_DROP_RX_PKT_ON_CHAIN_ENDf_GET
#define CMIC_DMA_CTRLr_CH1_DROP_RX_PKT_ON_CHAIN_ENDf_SET BCM56504_A0_CMIC_DMA_CTRLr_CH1_DROP_RX_PKT_ON_CHAIN_ENDf_SET
#define CMIC_DMA_CTRLr_CH2_DIRECTIONf_GET BCM56504_A0_CMIC_DMA_CTRLr_CH2_DIRECTIONf_GET
#define CMIC_DMA_CTRLr_CH2_DIRECTIONf_SET BCM56504_A0_CMIC_DMA_CTRLr_CH2_DIRECTIONf_SET
#define CMIC_DMA_CTRLr_RESERVED_1_CH2f_GET BCM56504_A0_CMIC_DMA_CTRLr_RESERVED_1_CH2f_GET
#define CMIC_DMA_CTRLr_RESERVED_1_CH2f_SET BCM56504_A0_CMIC_DMA_CTRLr_RESERVED_1_CH2f_SET
#define CMIC_DMA_CTRLr_CH2_ABORT_DMAf_GET BCM56504_A0_CMIC_DMA_CTRLr_CH2_ABORT_DMAf_GET
#define CMIC_DMA_CTRLr_CH2_ABORT_DMAf_SET BCM56504_A0_CMIC_DMA_CTRLr_CH2_ABORT_DMAf_SET
#define CMIC_DMA_CTRLr_CH2_SEL_INTR_ON_DESC_OR_PKTf_GET BCM56504_A0_CMIC_DMA_CTRLr_CH2_SEL_INTR_ON_DESC_OR_PKTf_GET
#define CMIC_DMA_CTRLr_CH2_SEL_INTR_ON_DESC_OR_PKTf_SET BCM56504_A0_CMIC_DMA_CTRLr_CH2_SEL_INTR_ON_DESC_OR_PKTf_SET
#define CMIC_DMA_CTRLr_RESERVED_2_CH2f_GET BCM56504_A0_CMIC_DMA_CTRLr_RESERVED_2_CH2f_GET
#define CMIC_DMA_CTRLr_RESERVED_2_CH2f_SET BCM56504_A0_CMIC_DMA_CTRLr_RESERVED_2_CH2f_SET
#define CMIC_DMA_CTRLr_RESERVED_3_CH2f_GET BCM56504_A0_CMIC_DMA_CTRLr_RESERVED_3_CH2f_GET
#define CMIC_DMA_CTRLr_RESERVED_3_CH2f_SET BCM56504_A0_CMIC_DMA_CTRLr_RESERVED_3_CH2f_SET
#define CMIC_DMA_CTRLr_CH2_DROP_RX_PKT_ON_CHAIN_ENDf_GET BCM56504_A0_CMIC_DMA_CTRLr_CH2_DROP_RX_PKT_ON_CHAIN_ENDf_GET
#define CMIC_DMA_CTRLr_CH2_DROP_RX_PKT_ON_CHAIN_ENDf_SET BCM56504_A0_CMIC_DMA_CTRLr_CH2_DROP_RX_PKT_ON_CHAIN_ENDf_SET
#define CMIC_DMA_CTRLr_CH3_DIRECTIONf_GET BCM56504_A0_CMIC_DMA_CTRLr_CH3_DIRECTIONf_GET
#define CMIC_DMA_CTRLr_CH3_DIRECTIONf_SET BCM56504_A0_CMIC_DMA_CTRLr_CH3_DIRECTIONf_SET
#define CMIC_DMA_CTRLr_RESERVED_1_CH3f_GET BCM56504_A0_CMIC_DMA_CTRLr_RESERVED_1_CH3f_GET
#define CMIC_DMA_CTRLr_RESERVED_1_CH3f_SET BCM56504_A0_CMIC_DMA_CTRLr_RESERVED_1_CH3f_SET
#define CMIC_DMA_CTRLr_CH3_ABORT_DMAf_GET BCM56504_A0_CMIC_DMA_CTRLr_CH3_ABORT_DMAf_GET
#define CMIC_DMA_CTRLr_CH3_ABORT_DMAf_SET BCM56504_A0_CMIC_DMA_CTRLr_CH3_ABORT_DMAf_SET
#define CMIC_DMA_CTRLr_CH3_SEL_INTR_ON_DESC_OR_PKTf_GET BCM56504_A0_CMIC_DMA_CTRLr_CH3_SEL_INTR_ON_DESC_OR_PKTf_GET
#define CMIC_DMA_CTRLr_CH3_SEL_INTR_ON_DESC_OR_PKTf_SET BCM56504_A0_CMIC_DMA_CTRLr_CH3_SEL_INTR_ON_DESC_OR_PKTf_SET
#define CMIC_DMA_CTRLr_RESERVED_2_CH3f_GET BCM56504_A0_CMIC_DMA_CTRLr_RESERVED_2_CH3f_GET
#define CMIC_DMA_CTRLr_RESERVED_2_CH3f_SET BCM56504_A0_CMIC_DMA_CTRLr_RESERVED_2_CH3f_SET
#define CMIC_DMA_CTRLr_RESERVED_3_CH3f_GET BCM56504_A0_CMIC_DMA_CTRLr_RESERVED_3_CH3f_GET
#define CMIC_DMA_CTRLr_RESERVED_3_CH3f_SET BCM56504_A0_CMIC_DMA_CTRLr_RESERVED_3_CH3f_SET
#define CMIC_DMA_CTRLr_CH3_DROP_RX_PKT_ON_CHAIN_ENDf_GET BCM56504_A0_CMIC_DMA_CTRLr_CH3_DROP_RX_PKT_ON_CHAIN_ENDf_GET
#define CMIC_DMA_CTRLr_CH3_DROP_RX_PKT_ON_CHAIN_ENDf_SET BCM56504_A0_CMIC_DMA_CTRLr_CH3_DROP_RX_PKT_ON_CHAIN_ENDf_SET
#define READ_CMIC_DMA_CTRLr BCM56504_A0_READ_CMIC_DMA_CTRLr
#define WRITE_CMIC_DMA_CTRLr BCM56504_A0_WRITE_CMIC_DMA_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_DMA_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_DMA_DESC0
 * BLOCKS:   CMIC
 * DESC:     DMA Channel 0 Descriptor Address
 * SIZE:     32
 * FIELDS:
 *     ADDR             DMA CH0 DESCRIPTOR ADDRESS REGISTER
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_DMA_DESC0r 0x00000110

#define BCM56504_A0_CMIC_DMA_DESC0r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_DMA_DESC0.
 *
 */
typedef union BCM56504_A0_CMIC_DMA_DESC0r_s {
	uint32_t v[1];
	uint32_t cmic_dma_desc0[1];
	uint32_t _cmic_dma_desc0;
} BCM56504_A0_CMIC_DMA_DESC0r_t;

#define BCM56504_A0_CMIC_DMA_DESC0r_CLR(r) (r).cmic_dma_desc0[0] = 0
#define BCM56504_A0_CMIC_DMA_DESC0r_SET(r,d) (r).cmic_dma_desc0[0] = d
#define BCM56504_A0_CMIC_DMA_DESC0r_GET(r) (r).cmic_dma_desc0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_DMA_DESC0r_ADDRf_GET(r) ((r).cmic_dma_desc0[0])
#define BCM56504_A0_CMIC_DMA_DESC0r_ADDRf_SET(r,f) (r).cmic_dma_desc0[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_DMA_DESC0.
 *
 */
#define BCM56504_A0_READ_CMIC_DMA_DESC0r(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_DMA_DESC0r,r._cmic_dma_desc0)
#define BCM56504_A0_WRITE_CMIC_DMA_DESC0r(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_DMA_DESC0r,r._cmic_dma_desc0)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_DMA_DESC0r BCM56504_A0_CMIC_DMA_DESC0r
#define CMIC_DMA_DESC0r_SIZE BCM56504_A0_CMIC_DMA_DESC0r_SIZE
typedef BCM56504_A0_CMIC_DMA_DESC0r_t CMIC_DMA_DESC0r_t;
#define CMIC_DMA_DESC0r_CLR BCM56504_A0_CMIC_DMA_DESC0r_CLR
#define CMIC_DMA_DESC0r_SET BCM56504_A0_CMIC_DMA_DESC0r_SET
#define CMIC_DMA_DESC0r_GET BCM56504_A0_CMIC_DMA_DESC0r_GET
#define CMIC_DMA_DESC0r_ADDRf_GET BCM56504_A0_CMIC_DMA_DESC0r_ADDRf_GET
#define CMIC_DMA_DESC0r_ADDRf_SET BCM56504_A0_CMIC_DMA_DESC0r_ADDRf_SET
#define READ_CMIC_DMA_DESC0r BCM56504_A0_READ_CMIC_DMA_DESC0r
#define WRITE_CMIC_DMA_DESC0r BCM56504_A0_WRITE_CMIC_DMA_DESC0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_DMA_DESC0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_DMA_DESC1
 * BLOCKS:   CMIC
 * DESC:     DMA Channel 1 Descriptor Address
 * SIZE:     32
 * FIELDS:
 *     ADDR             DMA CH1 DESCRIPTOR ADDRESS REGISTER
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_DMA_DESC1r 0x00000114

#define BCM56504_A0_CMIC_DMA_DESC1r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_DMA_DESC1.
 *
 */
typedef union BCM56504_A0_CMIC_DMA_DESC1r_s {
	uint32_t v[1];
	uint32_t cmic_dma_desc1[1];
	uint32_t _cmic_dma_desc1;
} BCM56504_A0_CMIC_DMA_DESC1r_t;

#define BCM56504_A0_CMIC_DMA_DESC1r_CLR(r) (r).cmic_dma_desc1[0] = 0
#define BCM56504_A0_CMIC_DMA_DESC1r_SET(r,d) (r).cmic_dma_desc1[0] = d
#define BCM56504_A0_CMIC_DMA_DESC1r_GET(r) (r).cmic_dma_desc1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_DMA_DESC1r_ADDRf_GET(r) ((r).cmic_dma_desc1[0])
#define BCM56504_A0_CMIC_DMA_DESC1r_ADDRf_SET(r,f) (r).cmic_dma_desc1[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_DMA_DESC1.
 *
 */
#define BCM56504_A0_READ_CMIC_DMA_DESC1r(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_DMA_DESC1r,r._cmic_dma_desc1)
#define BCM56504_A0_WRITE_CMIC_DMA_DESC1r(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_DMA_DESC1r,r._cmic_dma_desc1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_DMA_DESC1r BCM56504_A0_CMIC_DMA_DESC1r
#define CMIC_DMA_DESC1r_SIZE BCM56504_A0_CMIC_DMA_DESC1r_SIZE
typedef BCM56504_A0_CMIC_DMA_DESC1r_t CMIC_DMA_DESC1r_t;
#define CMIC_DMA_DESC1r_CLR BCM56504_A0_CMIC_DMA_DESC1r_CLR
#define CMIC_DMA_DESC1r_SET BCM56504_A0_CMIC_DMA_DESC1r_SET
#define CMIC_DMA_DESC1r_GET BCM56504_A0_CMIC_DMA_DESC1r_GET
#define CMIC_DMA_DESC1r_ADDRf_GET BCM56504_A0_CMIC_DMA_DESC1r_ADDRf_GET
#define CMIC_DMA_DESC1r_ADDRf_SET BCM56504_A0_CMIC_DMA_DESC1r_ADDRf_SET
#define READ_CMIC_DMA_DESC1r BCM56504_A0_READ_CMIC_DMA_DESC1r
#define WRITE_CMIC_DMA_DESC1r BCM56504_A0_WRITE_CMIC_DMA_DESC1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_DMA_DESC1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_DMA_DESC2
 * BLOCKS:   CMIC
 * DESC:     DMA Channel 2 Descriptor Address
 * SIZE:     32
 * FIELDS:
 *     ADDR             DMA CH2 DESCRIPTOR ADDRESS REGISTER
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_DMA_DESC2r 0x00000118

#define BCM56504_A0_CMIC_DMA_DESC2r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_DMA_DESC2.
 *
 */
typedef union BCM56504_A0_CMIC_DMA_DESC2r_s {
	uint32_t v[1];
	uint32_t cmic_dma_desc2[1];
	uint32_t _cmic_dma_desc2;
} BCM56504_A0_CMIC_DMA_DESC2r_t;

#define BCM56504_A0_CMIC_DMA_DESC2r_CLR(r) (r).cmic_dma_desc2[0] = 0
#define BCM56504_A0_CMIC_DMA_DESC2r_SET(r,d) (r).cmic_dma_desc2[0] = d
#define BCM56504_A0_CMIC_DMA_DESC2r_GET(r) (r).cmic_dma_desc2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_DMA_DESC2r_ADDRf_GET(r) ((r).cmic_dma_desc2[0])
#define BCM56504_A0_CMIC_DMA_DESC2r_ADDRf_SET(r,f) (r).cmic_dma_desc2[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_DMA_DESC2.
 *
 */
#define BCM56504_A0_READ_CMIC_DMA_DESC2r(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_DMA_DESC2r,r._cmic_dma_desc2)
#define BCM56504_A0_WRITE_CMIC_DMA_DESC2r(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_DMA_DESC2r,r._cmic_dma_desc2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_DMA_DESC2r BCM56504_A0_CMIC_DMA_DESC2r
#define CMIC_DMA_DESC2r_SIZE BCM56504_A0_CMIC_DMA_DESC2r_SIZE
typedef BCM56504_A0_CMIC_DMA_DESC2r_t CMIC_DMA_DESC2r_t;
#define CMIC_DMA_DESC2r_CLR BCM56504_A0_CMIC_DMA_DESC2r_CLR
#define CMIC_DMA_DESC2r_SET BCM56504_A0_CMIC_DMA_DESC2r_SET
#define CMIC_DMA_DESC2r_GET BCM56504_A0_CMIC_DMA_DESC2r_GET
#define CMIC_DMA_DESC2r_ADDRf_GET BCM56504_A0_CMIC_DMA_DESC2r_ADDRf_GET
#define CMIC_DMA_DESC2r_ADDRf_SET BCM56504_A0_CMIC_DMA_DESC2r_ADDRf_SET
#define READ_CMIC_DMA_DESC2r BCM56504_A0_READ_CMIC_DMA_DESC2r
#define WRITE_CMIC_DMA_DESC2r BCM56504_A0_WRITE_CMIC_DMA_DESC2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_DMA_DESC2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_DMA_DESC3
 * BLOCKS:   CMIC
 * DESC:     DMA Channel 3 Descriptor Address
 * SIZE:     32
 * FIELDS:
 *     ADDR             DMA CH3 DESCRIPTOR ADDRESS REGISTER
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_DMA_DESC3r 0x0000011c

#define BCM56504_A0_CMIC_DMA_DESC3r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_DMA_DESC3.
 *
 */
typedef union BCM56504_A0_CMIC_DMA_DESC3r_s {
	uint32_t v[1];
	uint32_t cmic_dma_desc3[1];
	uint32_t _cmic_dma_desc3;
} BCM56504_A0_CMIC_DMA_DESC3r_t;

#define BCM56504_A0_CMIC_DMA_DESC3r_CLR(r) (r).cmic_dma_desc3[0] = 0
#define BCM56504_A0_CMIC_DMA_DESC3r_SET(r,d) (r).cmic_dma_desc3[0] = d
#define BCM56504_A0_CMIC_DMA_DESC3r_GET(r) (r).cmic_dma_desc3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_DMA_DESC3r_ADDRf_GET(r) ((r).cmic_dma_desc3[0])
#define BCM56504_A0_CMIC_DMA_DESC3r_ADDRf_SET(r,f) (r).cmic_dma_desc3[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_DMA_DESC3.
 *
 */
#define BCM56504_A0_READ_CMIC_DMA_DESC3r(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_DMA_DESC3r,r._cmic_dma_desc3)
#define BCM56504_A0_WRITE_CMIC_DMA_DESC3r(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_DMA_DESC3r,r._cmic_dma_desc3)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_DMA_DESC3r BCM56504_A0_CMIC_DMA_DESC3r
#define CMIC_DMA_DESC3r_SIZE BCM56504_A0_CMIC_DMA_DESC3r_SIZE
typedef BCM56504_A0_CMIC_DMA_DESC3r_t CMIC_DMA_DESC3r_t;
#define CMIC_DMA_DESC3r_CLR BCM56504_A0_CMIC_DMA_DESC3r_CLR
#define CMIC_DMA_DESC3r_SET BCM56504_A0_CMIC_DMA_DESC3r_SET
#define CMIC_DMA_DESC3r_GET BCM56504_A0_CMIC_DMA_DESC3r_GET
#define CMIC_DMA_DESC3r_ADDRf_GET BCM56504_A0_CMIC_DMA_DESC3r_ADDRf_GET
#define CMIC_DMA_DESC3r_ADDRf_SET BCM56504_A0_CMIC_DMA_DESC3r_ADDRf_SET
#define READ_CMIC_DMA_DESC3r BCM56504_A0_READ_CMIC_DMA_DESC3r
#define WRITE_CMIC_DMA_DESC3r BCM56504_A0_WRITE_CMIC_DMA_DESC3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_DMA_DESC3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_DMA_STAT
 * BLOCKS:   CMIC
 * DESC:     DMA Status and Control Register
 * SIZE:     32
 * FIELDS:
 *     CH0_DMA_EN       Set by CPU to start a DMA on CH0 
 *     CH1_DMA_EN       Set by CPU to start a DMA on CH1 
 *     CH2_DMA_EN       Set by CPU to start a DMA on CH2 
 *     CH3_DMA_EN       Set by CPU to start a DMA on CH3 
 *     CH0_CHAIN_DONE   Set by CMIC indicating DMA Completion 
 *     CH1_CHAIN_DONE   Set by CMIC indicating DMA Completion 
 *     CH2_CHAIN_DONE   Set by CMIC indicating DMA Completion 
 *     CH3_CHAIN_DONE   Set by CMIC indicating DMA Completion 
 *     CH0_DESC_DONE    Set by CMIC indicating Current DMA DES Completion 
 *     CH1_DESC_DONE    Set by CMIC indicating Current DMA DES Completion 
 *     CH2_DESC_DONE    Set by CMIC indicating Current DMA DES Completion 
 *     CH3_DESC_DONE    Set by CMIC indicating Current DMA DES Completion 
 *     DMA_RESET        Set by CPU to reset DMA Controller
 *     STATS_DMA_OPN_COMPLETE Set by CPU to indicate Stats DMA operation complete
 *     STATS_DMA_ITER_DONE Set by CPU to indicate Stats DMA iteration done
 *     TX_DMA_ABORT_NEEDS_CLEANUP Set by CPU to indicate that the previous TX DMA was aborted inthe middle of a packet (i.e., not at packet boundary). The CPU needs to clean up by forcing an eop packet with purge bit set.
 *     STATS_DMA_ERROR  Set by CPU to indicate Stats DMA resulted in an error
 *     STATS_DMA_ACTIVE Set by CPU to indicate Stats DMA currently active
 *     CH0_DMA_ACTIVE   Set by CMIC to indicate DMA channel is Active
 *     CH1_DMA_ACTIVE   Set by CMIC to indicate DMA channel is Active
 *     CH2_DMA_ACTIVE   Set by CMIC to indicate DMA channel is Active
 *     CH3_DMA_ACTIVE   Set by CMIC to indicate DMA channel is Active
 *     PCI_PARITY_ERR   Set by CMIC to indicate DMA Resulting in PCI Parity Error
 *     PCI_FATAL_ERR    Set by CMIC to indicate DMA Resulting in PCI Fatal Error
 *     BIT_POS          Selects one of 32 bits positions to be Set/Reset
 *     BIT_VAL          Set to 1 to set a bit, 0 to reset a bit
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_DMA_STATr 0x00000104

#define BCM56504_A0_CMIC_DMA_STATr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_DMA_STAT.
 *
 */
typedef union BCM56504_A0_CMIC_DMA_STATr_s {
	uint32_t v[1];
	uint32_t cmic_dma_stat[1];
	uint32_t _cmic_dma_stat;
} BCM56504_A0_CMIC_DMA_STATr_t;

#define BCM56504_A0_CMIC_DMA_STATr_CLR(r) (r).cmic_dma_stat[0] = 0
#define BCM56504_A0_CMIC_DMA_STATr_SET(r,d) (r).cmic_dma_stat[0] = d
#define BCM56504_A0_CMIC_DMA_STATr_GET(r) (r).cmic_dma_stat[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_DMA_STATr_CH0_DMA_ENf_GET(r) (((r).cmic_dma_stat[0]) & 0x1)
#define BCM56504_A0_CMIC_DMA_STATr_CH0_DMA_ENf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_CMIC_DMA_STATr_CH1_DMA_ENf_GET(r) ((((r).cmic_dma_stat[0]) >> 1) & 0x1)
#define BCM56504_A0_CMIC_DMA_STATr_CH1_DMA_ENf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_CMIC_DMA_STATr_CH2_DMA_ENf_GET(r) ((((r).cmic_dma_stat[0]) >> 2) & 0x1)
#define BCM56504_A0_CMIC_DMA_STATr_CH2_DMA_ENf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_CMIC_DMA_STATr_CH3_DMA_ENf_GET(r) ((((r).cmic_dma_stat[0]) >> 3) & 0x1)
#define BCM56504_A0_CMIC_DMA_STATr_CH3_DMA_ENf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_CMIC_DMA_STATr_CH0_CHAIN_DONEf_GET(r) ((((r).cmic_dma_stat[0]) >> 4) & 0x1)
#define BCM56504_A0_CMIC_DMA_STATr_CH0_CHAIN_DONEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56504_A0_CMIC_DMA_STATr_CH1_CHAIN_DONEf_GET(r) ((((r).cmic_dma_stat[0]) >> 5) & 0x1)
#define BCM56504_A0_CMIC_DMA_STATr_CH1_CHAIN_DONEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56504_A0_CMIC_DMA_STATr_CH2_CHAIN_DONEf_GET(r) ((((r).cmic_dma_stat[0]) >> 6) & 0x1)
#define BCM56504_A0_CMIC_DMA_STATr_CH2_CHAIN_DONEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56504_A0_CMIC_DMA_STATr_CH3_CHAIN_DONEf_GET(r) ((((r).cmic_dma_stat[0]) >> 7) & 0x1)
#define BCM56504_A0_CMIC_DMA_STATr_CH3_CHAIN_DONEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56504_A0_CMIC_DMA_STATr_CH0_DESC_DONEf_GET(r) ((((r).cmic_dma_stat[0]) >> 8) & 0x1)
#define BCM56504_A0_CMIC_DMA_STATr_CH0_DESC_DONEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56504_A0_CMIC_DMA_STATr_CH1_DESC_DONEf_GET(r) ((((r).cmic_dma_stat[0]) >> 9) & 0x1)
#define BCM56504_A0_CMIC_DMA_STATr_CH1_DESC_DONEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56504_A0_CMIC_DMA_STATr_CH2_DESC_DONEf_GET(r) ((((r).cmic_dma_stat[0]) >> 10) & 0x1)
#define BCM56504_A0_CMIC_DMA_STATr_CH2_DESC_DONEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56504_A0_CMIC_DMA_STATr_CH3_DESC_DONEf_GET(r) ((((r).cmic_dma_stat[0]) >> 11) & 0x1)
#define BCM56504_A0_CMIC_DMA_STATr_CH3_DESC_DONEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56504_A0_CMIC_DMA_STATr_DMA_RESETf_GET(r) ((((r).cmic_dma_stat[0]) >> 12) & 0x1)
#define BCM56504_A0_CMIC_DMA_STATr_DMA_RESETf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM56504_A0_CMIC_DMA_STATr_STATS_DMA_OPN_COMPLETEf_GET(r) ((((r).cmic_dma_stat[0]) >> 13) & 0x1)
#define BCM56504_A0_CMIC_DMA_STATr_STATS_DMA_OPN_COMPLETEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56504_A0_CMIC_DMA_STATr_STATS_DMA_ITER_DONEf_GET(r) ((((r).cmic_dma_stat[0]) >> 14) & 0x1)
#define BCM56504_A0_CMIC_DMA_STATr_STATS_DMA_ITER_DONEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM56504_A0_CMIC_DMA_STATr_TX_DMA_ABORT_NEEDS_CLEANUPf_GET(r) ((((r).cmic_dma_stat[0]) >> 15) & 0x1)
#define BCM56504_A0_CMIC_DMA_STATr_TX_DMA_ABORT_NEEDS_CLEANUPf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56504_A0_CMIC_DMA_STATr_STATS_DMA_ERRORf_GET(r) ((((r).cmic_dma_stat[0]) >> 16) & 0x1)
#define BCM56504_A0_CMIC_DMA_STATr_STATS_DMA_ERRORf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56504_A0_CMIC_DMA_STATr_STATS_DMA_ACTIVEf_GET(r) ((((r).cmic_dma_stat[0]) >> 17) & 0x1)
#define BCM56504_A0_CMIC_DMA_STATr_STATS_DMA_ACTIVEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56504_A0_CMIC_DMA_STATr_CH0_DMA_ACTIVEf_GET(r) ((((r).cmic_dma_stat[0]) >> 18) & 0x1)
#define BCM56504_A0_CMIC_DMA_STATr_CH0_DMA_ACTIVEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56504_A0_CMIC_DMA_STATr_CH1_DMA_ACTIVEf_GET(r) ((((r).cmic_dma_stat[0]) >> 19) & 0x1)
#define BCM56504_A0_CMIC_DMA_STATr_CH1_DMA_ACTIVEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56504_A0_CMIC_DMA_STATr_CH2_DMA_ACTIVEf_GET(r) ((((r).cmic_dma_stat[0]) >> 20) & 0x1)
#define BCM56504_A0_CMIC_DMA_STATr_CH2_DMA_ACTIVEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM56504_A0_CMIC_DMA_STATr_CH3_DMA_ACTIVEf_GET(r) ((((r).cmic_dma_stat[0]) >> 21) & 0x1)
#define BCM56504_A0_CMIC_DMA_STATr_CH3_DMA_ACTIVEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM56504_A0_CMIC_DMA_STATr_PCI_PARITY_ERRf_GET(r) ((((r).cmic_dma_stat[0]) >> 22) & 0x1f)
#define BCM56504_A0_CMIC_DMA_STATr_PCI_PARITY_ERRf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1f << 22)) | ((((uint32_t)f) & 0x1f) << 22))
#define BCM56504_A0_CMIC_DMA_STATr_PCI_FATAL_ERRf_GET(r) ((((r).cmic_dma_stat[0]) >> 27) & 0x1f)
#define BCM56504_A0_CMIC_DMA_STATr_PCI_FATAL_ERRf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1f << 27)) | ((((uint32_t)f) & 0x1f) << 27))
#define BCM56504_A0_CMIC_DMA_STATr_BIT_POSf_GET(r) (((r).cmic_dma_stat[0]) & 0x1f)
#define BCM56504_A0_CMIC_DMA_STATr_BIT_POSf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56504_A0_CMIC_DMA_STATr_BIT_VALf_GET(r) ((((r).cmic_dma_stat[0]) >> 7) & 0x1)
#define BCM56504_A0_CMIC_DMA_STATr_BIT_VALf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access CMIC_DMA_STAT.
 *
 */
#define BCM56504_A0_READ_CMIC_DMA_STATr(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_DMA_STATr,r._cmic_dma_stat)
#define BCM56504_A0_WRITE_CMIC_DMA_STATr(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_DMA_STATr,r._cmic_dma_stat)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_DMA_STATr BCM56504_A0_CMIC_DMA_STATr
#define CMIC_DMA_STATr_SIZE BCM56504_A0_CMIC_DMA_STATr_SIZE
typedef BCM56504_A0_CMIC_DMA_STATr_t CMIC_DMA_STATr_t;
#define CMIC_DMA_STATr_CLR BCM56504_A0_CMIC_DMA_STATr_CLR
#define CMIC_DMA_STATr_SET BCM56504_A0_CMIC_DMA_STATr_SET
#define CMIC_DMA_STATr_GET BCM56504_A0_CMIC_DMA_STATr_GET
#define CMIC_DMA_STATr_CH0_DMA_ENf_GET BCM56504_A0_CMIC_DMA_STATr_CH0_DMA_ENf_GET
#define CMIC_DMA_STATr_CH0_DMA_ENf_SET BCM56504_A0_CMIC_DMA_STATr_CH0_DMA_ENf_SET
#define CMIC_DMA_STATr_CH1_DMA_ENf_GET BCM56504_A0_CMIC_DMA_STATr_CH1_DMA_ENf_GET
#define CMIC_DMA_STATr_CH1_DMA_ENf_SET BCM56504_A0_CMIC_DMA_STATr_CH1_DMA_ENf_SET
#define CMIC_DMA_STATr_CH2_DMA_ENf_GET BCM56504_A0_CMIC_DMA_STATr_CH2_DMA_ENf_GET
#define CMIC_DMA_STATr_CH2_DMA_ENf_SET BCM56504_A0_CMIC_DMA_STATr_CH2_DMA_ENf_SET
#define CMIC_DMA_STATr_CH3_DMA_ENf_GET BCM56504_A0_CMIC_DMA_STATr_CH3_DMA_ENf_GET
#define CMIC_DMA_STATr_CH3_DMA_ENf_SET BCM56504_A0_CMIC_DMA_STATr_CH3_DMA_ENf_SET
#define CMIC_DMA_STATr_CH0_CHAIN_DONEf_GET BCM56504_A0_CMIC_DMA_STATr_CH0_CHAIN_DONEf_GET
#define CMIC_DMA_STATr_CH0_CHAIN_DONEf_SET BCM56504_A0_CMIC_DMA_STATr_CH0_CHAIN_DONEf_SET
#define CMIC_DMA_STATr_CH1_CHAIN_DONEf_GET BCM56504_A0_CMIC_DMA_STATr_CH1_CHAIN_DONEf_GET
#define CMIC_DMA_STATr_CH1_CHAIN_DONEf_SET BCM56504_A0_CMIC_DMA_STATr_CH1_CHAIN_DONEf_SET
#define CMIC_DMA_STATr_CH2_CHAIN_DONEf_GET BCM56504_A0_CMIC_DMA_STATr_CH2_CHAIN_DONEf_GET
#define CMIC_DMA_STATr_CH2_CHAIN_DONEf_SET BCM56504_A0_CMIC_DMA_STATr_CH2_CHAIN_DONEf_SET
#define CMIC_DMA_STATr_CH3_CHAIN_DONEf_GET BCM56504_A0_CMIC_DMA_STATr_CH3_CHAIN_DONEf_GET
#define CMIC_DMA_STATr_CH3_CHAIN_DONEf_SET BCM56504_A0_CMIC_DMA_STATr_CH3_CHAIN_DONEf_SET
#define CMIC_DMA_STATr_CH0_DESC_DONEf_GET BCM56504_A0_CMIC_DMA_STATr_CH0_DESC_DONEf_GET
#define CMIC_DMA_STATr_CH0_DESC_DONEf_SET BCM56504_A0_CMIC_DMA_STATr_CH0_DESC_DONEf_SET
#define CMIC_DMA_STATr_CH1_DESC_DONEf_GET BCM56504_A0_CMIC_DMA_STATr_CH1_DESC_DONEf_GET
#define CMIC_DMA_STATr_CH1_DESC_DONEf_SET BCM56504_A0_CMIC_DMA_STATr_CH1_DESC_DONEf_SET
#define CMIC_DMA_STATr_CH2_DESC_DONEf_GET BCM56504_A0_CMIC_DMA_STATr_CH2_DESC_DONEf_GET
#define CMIC_DMA_STATr_CH2_DESC_DONEf_SET BCM56504_A0_CMIC_DMA_STATr_CH2_DESC_DONEf_SET
#define CMIC_DMA_STATr_CH3_DESC_DONEf_GET BCM56504_A0_CMIC_DMA_STATr_CH3_DESC_DONEf_GET
#define CMIC_DMA_STATr_CH3_DESC_DONEf_SET BCM56504_A0_CMIC_DMA_STATr_CH3_DESC_DONEf_SET
#define CMIC_DMA_STATr_DMA_RESETf_GET BCM56504_A0_CMIC_DMA_STATr_DMA_RESETf_GET
#define CMIC_DMA_STATr_DMA_RESETf_SET BCM56504_A0_CMIC_DMA_STATr_DMA_RESETf_SET
#define CMIC_DMA_STATr_STATS_DMA_OPN_COMPLETEf_GET BCM56504_A0_CMIC_DMA_STATr_STATS_DMA_OPN_COMPLETEf_GET
#define CMIC_DMA_STATr_STATS_DMA_OPN_COMPLETEf_SET BCM56504_A0_CMIC_DMA_STATr_STATS_DMA_OPN_COMPLETEf_SET
#define CMIC_DMA_STATr_STATS_DMA_ITER_DONEf_GET BCM56504_A0_CMIC_DMA_STATr_STATS_DMA_ITER_DONEf_GET
#define CMIC_DMA_STATr_STATS_DMA_ITER_DONEf_SET BCM56504_A0_CMIC_DMA_STATr_STATS_DMA_ITER_DONEf_SET
#define CMIC_DMA_STATr_TX_DMA_ABORT_NEEDS_CLEANUPf_GET BCM56504_A0_CMIC_DMA_STATr_TX_DMA_ABORT_NEEDS_CLEANUPf_GET
#define CMIC_DMA_STATr_TX_DMA_ABORT_NEEDS_CLEANUPf_SET BCM56504_A0_CMIC_DMA_STATr_TX_DMA_ABORT_NEEDS_CLEANUPf_SET
#define CMIC_DMA_STATr_STATS_DMA_ERRORf_GET BCM56504_A0_CMIC_DMA_STATr_STATS_DMA_ERRORf_GET
#define CMIC_DMA_STATr_STATS_DMA_ERRORf_SET BCM56504_A0_CMIC_DMA_STATr_STATS_DMA_ERRORf_SET
#define CMIC_DMA_STATr_STATS_DMA_ACTIVEf_GET BCM56504_A0_CMIC_DMA_STATr_STATS_DMA_ACTIVEf_GET
#define CMIC_DMA_STATr_STATS_DMA_ACTIVEf_SET BCM56504_A0_CMIC_DMA_STATr_STATS_DMA_ACTIVEf_SET
#define CMIC_DMA_STATr_CH0_DMA_ACTIVEf_GET BCM56504_A0_CMIC_DMA_STATr_CH0_DMA_ACTIVEf_GET
#define CMIC_DMA_STATr_CH0_DMA_ACTIVEf_SET BCM56504_A0_CMIC_DMA_STATr_CH0_DMA_ACTIVEf_SET
#define CMIC_DMA_STATr_CH1_DMA_ACTIVEf_GET BCM56504_A0_CMIC_DMA_STATr_CH1_DMA_ACTIVEf_GET
#define CMIC_DMA_STATr_CH1_DMA_ACTIVEf_SET BCM56504_A0_CMIC_DMA_STATr_CH1_DMA_ACTIVEf_SET
#define CMIC_DMA_STATr_CH2_DMA_ACTIVEf_GET BCM56504_A0_CMIC_DMA_STATr_CH2_DMA_ACTIVEf_GET
#define CMIC_DMA_STATr_CH2_DMA_ACTIVEf_SET BCM56504_A0_CMIC_DMA_STATr_CH2_DMA_ACTIVEf_SET
#define CMIC_DMA_STATr_CH3_DMA_ACTIVEf_GET BCM56504_A0_CMIC_DMA_STATr_CH3_DMA_ACTIVEf_GET
#define CMIC_DMA_STATr_CH3_DMA_ACTIVEf_SET BCM56504_A0_CMIC_DMA_STATr_CH3_DMA_ACTIVEf_SET
#define CMIC_DMA_STATr_PCI_PARITY_ERRf_GET BCM56504_A0_CMIC_DMA_STATr_PCI_PARITY_ERRf_GET
#define CMIC_DMA_STATr_PCI_PARITY_ERRf_SET BCM56504_A0_CMIC_DMA_STATr_PCI_PARITY_ERRf_SET
#define CMIC_DMA_STATr_PCI_FATAL_ERRf_GET BCM56504_A0_CMIC_DMA_STATr_PCI_FATAL_ERRf_GET
#define CMIC_DMA_STATr_PCI_FATAL_ERRf_SET BCM56504_A0_CMIC_DMA_STATr_PCI_FATAL_ERRf_SET
#define CMIC_DMA_STATr_BIT_POSf_GET BCM56504_A0_CMIC_DMA_STATr_BIT_POSf_GET
#define CMIC_DMA_STATr_BIT_POSf_SET BCM56504_A0_CMIC_DMA_STATr_BIT_POSf_SET
#define CMIC_DMA_STATr_BIT_VALf_GET BCM56504_A0_CMIC_DMA_STATr_BIT_VALf_GET
#define CMIC_DMA_STATr_BIT_VALf_SET BCM56504_A0_CMIC_DMA_STATr_BIT_VALf_SET
#define READ_CMIC_DMA_STATr BCM56504_A0_READ_CMIC_DMA_STATr
#define WRITE_CMIC_DMA_STATr BCM56504_A0_WRITE_CMIC_DMA_STATr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_DMA_STATr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_ENDIANESS_SEL
 * BLOCKS:   CMIC
 * DESC:     Endianness selection register (for various CMIC operations)

 * SIZE:     32
 * FIELDS:
 *     BYTELANE0        Each byte lane must carry the same data value,especially the MSB byte and the LSB byte.The various bits in the byte are interpretedas explained below:
 *     BYTELANE1        Byte Lane 1 (see BYTELANE0)Each byte lane must carry the same data value.
 *     BYTELANE2        Byte Lane 2 (see BYTELANE0)Each byte lane must carry the same data value.
 *     BYTELANE3        Byte Lane 3 (see BYTELANE0)Each byte lane must carry the same data value.
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_ENDIANESS_SELr 0x00000174

#define BCM56504_A0_CMIC_ENDIANESS_SELr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_ENDIANESS_SEL.
 *
 */
typedef union BCM56504_A0_CMIC_ENDIANESS_SELr_s {
	uint32_t v[1];
	uint32_t cmic_endianess_sel[1];
	uint32_t _cmic_endianess_sel;
} BCM56504_A0_CMIC_ENDIANESS_SELr_t;

#define BCM56504_A0_CMIC_ENDIANESS_SELr_CLR(r) (r).cmic_endianess_sel[0] = 0
#define BCM56504_A0_CMIC_ENDIANESS_SELr_SET(r,d) (r).cmic_endianess_sel[0] = d
#define BCM56504_A0_CMIC_ENDIANESS_SELr_GET(r) (r).cmic_endianess_sel[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_ENDIANESS_SELr_BYTELANE0f_GET(r) (((r).cmic_endianess_sel[0]) & 0xff)
#define BCM56504_A0_CMIC_ENDIANESS_SELr_BYTELANE0f_SET(r,f) (r).cmic_endianess_sel[0]=(((r).cmic_endianess_sel[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56504_A0_CMIC_ENDIANESS_SELr_BYTELANE1f_GET(r) ((((r).cmic_endianess_sel[0]) >> 8) & 0xff)
#define BCM56504_A0_CMIC_ENDIANESS_SELr_BYTELANE1f_SET(r,f) (r).cmic_endianess_sel[0]=(((r).cmic_endianess_sel[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCM56504_A0_CMIC_ENDIANESS_SELr_BYTELANE2f_GET(r) ((((r).cmic_endianess_sel[0]) >> 16) & 0xff)
#define BCM56504_A0_CMIC_ENDIANESS_SELr_BYTELANE2f_SET(r,f) (r).cmic_endianess_sel[0]=(((r).cmic_endianess_sel[0] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define BCM56504_A0_CMIC_ENDIANESS_SELr_BYTELANE3f_GET(r) ((((r).cmic_endianess_sel[0]) >> 24) & 0xff)
#define BCM56504_A0_CMIC_ENDIANESS_SELr_BYTELANE3f_SET(r,f) (r).cmic_endianess_sel[0]=(((r).cmic_endianess_sel[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access CMIC_ENDIANESS_SEL.
 *
 */
#define BCM56504_A0_READ_CMIC_ENDIANESS_SELr(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_ENDIANESS_SELr,r._cmic_endianess_sel)
#define BCM56504_A0_WRITE_CMIC_ENDIANESS_SELr(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_ENDIANESS_SELr,r._cmic_endianess_sel)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_ENDIANESS_SELr BCM56504_A0_CMIC_ENDIANESS_SELr
#define CMIC_ENDIANESS_SELr_SIZE BCM56504_A0_CMIC_ENDIANESS_SELr_SIZE
typedef BCM56504_A0_CMIC_ENDIANESS_SELr_t CMIC_ENDIANESS_SELr_t;
#define CMIC_ENDIANESS_SELr_CLR BCM56504_A0_CMIC_ENDIANESS_SELr_CLR
#define CMIC_ENDIANESS_SELr_SET BCM56504_A0_CMIC_ENDIANESS_SELr_SET
#define CMIC_ENDIANESS_SELr_GET BCM56504_A0_CMIC_ENDIANESS_SELr_GET
#define CMIC_ENDIANESS_SELr_BYTELANE0f_GET BCM56504_A0_CMIC_ENDIANESS_SELr_BYTELANE0f_GET
#define CMIC_ENDIANESS_SELr_BYTELANE0f_SET BCM56504_A0_CMIC_ENDIANESS_SELr_BYTELANE0f_SET
#define CMIC_ENDIANESS_SELr_BYTELANE1f_GET BCM56504_A0_CMIC_ENDIANESS_SELr_BYTELANE1f_GET
#define CMIC_ENDIANESS_SELr_BYTELANE1f_SET BCM56504_A0_CMIC_ENDIANESS_SELr_BYTELANE1f_SET
#define CMIC_ENDIANESS_SELr_BYTELANE2f_GET BCM56504_A0_CMIC_ENDIANESS_SELr_BYTELANE2f_GET
#define CMIC_ENDIANESS_SELr_BYTELANE2f_SET BCM56504_A0_CMIC_ENDIANESS_SELr_BYTELANE2f_SET
#define CMIC_ENDIANESS_SELr_BYTELANE3f_GET BCM56504_A0_CMIC_ENDIANESS_SELr_BYTELANE3f_GET
#define CMIC_ENDIANESS_SELr_BYTELANE3f_SET BCM56504_A0_CMIC_ENDIANESS_SELr_BYTELANE3f_SET
#define READ_CMIC_ENDIANESS_SELr BCM56504_A0_READ_CMIC_ENDIANESS_SELr
#define WRITE_CMIC_ENDIANESS_SELr BCM56504_A0_WRITE_CMIC_ENDIANESS_SELr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_ENDIANESS_SELr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_I2C_CTRL
 * BLOCKS:   CMIC
 * DESC:     I2C Status and Control Register
 * SIZE:     32
 * FIELDS:
 *     RESERVED_1       Reserved
 *     AAAK             When set (1), asserts an ACKNOWLEDGE clock pulse (SDA LOW) on the I2C bus 
 *     INT_FLAG         When set, indicates an interrupt has occurred due to one of the status conditions 
 *     MM_STP           When set, controls entering the Master mode and send a STOP condition on the bus, when it is free. This bit is automatically cleared after the STOP condition has been sent. 
 *     MM_STRT          When set, controls entering the Master mode and send a START condition on the bus, when it is free. This bit is automatically cleared after the START condition has been sent. 
 *     BUS_EN           When set, Enable I2C bus and respond to calls to the slave address and the General Call Address ability. 
 *     INT_EN           When set, enables generation of interrupts.
 *     RESERVED_2       Reserved
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_I2C_CTRLr 0x00000128

#define BCM56504_A0_CMIC_I2C_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_I2C_CTRL.
 *
 */
typedef union BCM56504_A0_CMIC_I2C_CTRLr_s {
	uint32_t v[1];
	uint32_t cmic_i2c_ctrl[1];
	uint32_t _cmic_i2c_ctrl;
} BCM56504_A0_CMIC_I2C_CTRLr_t;

#define BCM56504_A0_CMIC_I2C_CTRLr_CLR(r) (r).cmic_i2c_ctrl[0] = 0
#define BCM56504_A0_CMIC_I2C_CTRLr_SET(r,d) (r).cmic_i2c_ctrl[0] = d
#define BCM56504_A0_CMIC_I2C_CTRLr_GET(r) (r).cmic_i2c_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_I2C_CTRLr_RESERVED_1f_GET(r) (((r).cmic_i2c_ctrl[0]) & 0x3)
#define BCM56504_A0_CMIC_I2C_CTRLr_RESERVED_1f_SET(r,f) (r).cmic_i2c_ctrl[0]=(((r).cmic_i2c_ctrl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56504_A0_CMIC_I2C_CTRLr_AAAKf_GET(r) ((((r).cmic_i2c_ctrl[0]) >> 2) & 0x1)
#define BCM56504_A0_CMIC_I2C_CTRLr_AAAKf_SET(r,f) (r).cmic_i2c_ctrl[0]=(((r).cmic_i2c_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_CMIC_I2C_CTRLr_INT_FLAGf_GET(r) ((((r).cmic_i2c_ctrl[0]) >> 3) & 0x1)
#define BCM56504_A0_CMIC_I2C_CTRLr_INT_FLAGf_SET(r,f) (r).cmic_i2c_ctrl[0]=(((r).cmic_i2c_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_CMIC_I2C_CTRLr_MM_STPf_GET(r) ((((r).cmic_i2c_ctrl[0]) >> 4) & 0x1)
#define BCM56504_A0_CMIC_I2C_CTRLr_MM_STPf_SET(r,f) (r).cmic_i2c_ctrl[0]=(((r).cmic_i2c_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56504_A0_CMIC_I2C_CTRLr_MM_STRTf_GET(r) ((((r).cmic_i2c_ctrl[0]) >> 5) & 0x1)
#define BCM56504_A0_CMIC_I2C_CTRLr_MM_STRTf_SET(r,f) (r).cmic_i2c_ctrl[0]=(((r).cmic_i2c_ctrl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56504_A0_CMIC_I2C_CTRLr_BUS_ENf_GET(r) ((((r).cmic_i2c_ctrl[0]) >> 6) & 0x1)
#define BCM56504_A0_CMIC_I2C_CTRLr_BUS_ENf_SET(r,f) (r).cmic_i2c_ctrl[0]=(((r).cmic_i2c_ctrl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56504_A0_CMIC_I2C_CTRLr_INT_ENf_GET(r) ((((r).cmic_i2c_ctrl[0]) >> 7) & 0x1)
#define BCM56504_A0_CMIC_I2C_CTRLr_INT_ENf_SET(r,f) (r).cmic_i2c_ctrl[0]=(((r).cmic_i2c_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56504_A0_CMIC_I2C_CTRLr_RESERVED_2f_GET(r) ((((r).cmic_i2c_ctrl[0]) >> 8) & 0xffffff)
#define BCM56504_A0_CMIC_I2C_CTRLr_RESERVED_2f_SET(r,f) (r).cmic_i2c_ctrl[0]=(((r).cmic_i2c_ctrl[0] & ~((uint32_t)0xffffff << 8)) | ((((uint32_t)f) & 0xffffff) << 8))

/*
 * These macros can be used to access CMIC_I2C_CTRL.
 *
 */
#define BCM56504_A0_READ_CMIC_I2C_CTRLr(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_I2C_CTRLr,r._cmic_i2c_ctrl)
#define BCM56504_A0_WRITE_CMIC_I2C_CTRLr(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_I2C_CTRLr,r._cmic_i2c_ctrl)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_I2C_CTRLr BCM56504_A0_CMIC_I2C_CTRLr
#define CMIC_I2C_CTRLr_SIZE BCM56504_A0_CMIC_I2C_CTRLr_SIZE
typedef BCM56504_A0_CMIC_I2C_CTRLr_t CMIC_I2C_CTRLr_t;
#define CMIC_I2C_CTRLr_CLR BCM56504_A0_CMIC_I2C_CTRLr_CLR
#define CMIC_I2C_CTRLr_SET BCM56504_A0_CMIC_I2C_CTRLr_SET
#define CMIC_I2C_CTRLr_GET BCM56504_A0_CMIC_I2C_CTRLr_GET
#define CMIC_I2C_CTRLr_RESERVED_1f_GET BCM56504_A0_CMIC_I2C_CTRLr_RESERVED_1f_GET
#define CMIC_I2C_CTRLr_RESERVED_1f_SET BCM56504_A0_CMIC_I2C_CTRLr_RESERVED_1f_SET
#define CMIC_I2C_CTRLr_AAAKf_GET BCM56504_A0_CMIC_I2C_CTRLr_AAAKf_GET
#define CMIC_I2C_CTRLr_AAAKf_SET BCM56504_A0_CMIC_I2C_CTRLr_AAAKf_SET
#define CMIC_I2C_CTRLr_INT_FLAGf_GET BCM56504_A0_CMIC_I2C_CTRLr_INT_FLAGf_GET
#define CMIC_I2C_CTRLr_INT_FLAGf_SET BCM56504_A0_CMIC_I2C_CTRLr_INT_FLAGf_SET
#define CMIC_I2C_CTRLr_MM_STPf_GET BCM56504_A0_CMIC_I2C_CTRLr_MM_STPf_GET
#define CMIC_I2C_CTRLr_MM_STPf_SET BCM56504_A0_CMIC_I2C_CTRLr_MM_STPf_SET
#define CMIC_I2C_CTRLr_MM_STRTf_GET BCM56504_A0_CMIC_I2C_CTRLr_MM_STRTf_GET
#define CMIC_I2C_CTRLr_MM_STRTf_SET BCM56504_A0_CMIC_I2C_CTRLr_MM_STRTf_SET
#define CMIC_I2C_CTRLr_BUS_ENf_GET BCM56504_A0_CMIC_I2C_CTRLr_BUS_ENf_GET
#define CMIC_I2C_CTRLr_BUS_ENf_SET BCM56504_A0_CMIC_I2C_CTRLr_BUS_ENf_SET
#define CMIC_I2C_CTRLr_INT_ENf_GET BCM56504_A0_CMIC_I2C_CTRLr_INT_ENf_GET
#define CMIC_I2C_CTRLr_INT_ENf_SET BCM56504_A0_CMIC_I2C_CTRLr_INT_ENf_SET
#define CMIC_I2C_CTRLr_RESERVED_2f_GET BCM56504_A0_CMIC_I2C_CTRLr_RESERVED_2f_GET
#define CMIC_I2C_CTRLr_RESERVED_2f_SET BCM56504_A0_CMIC_I2C_CTRLr_RESERVED_2f_SET
#define READ_CMIC_I2C_CTRLr BCM56504_A0_READ_CMIC_I2C_CTRLr
#define WRITE_CMIC_I2C_CTRLr BCM56504_A0_WRITE_CMIC_I2C_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_I2C_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_I2C_DATA
 * BLOCKS:   CMIC
 * DESC:     I2C Data Register
 * SIZE:     32
 * FIELDS:
 *     DATA             Data that is read from or written to the I2C interface.
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_I2C_DATAr 0x00000124

#define BCM56504_A0_CMIC_I2C_DATAr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_I2C_DATA.
 *
 */
typedef union BCM56504_A0_CMIC_I2C_DATAr_s {
	uint32_t v[1];
	uint32_t cmic_i2c_data[1];
	uint32_t _cmic_i2c_data;
} BCM56504_A0_CMIC_I2C_DATAr_t;

#define BCM56504_A0_CMIC_I2C_DATAr_CLR(r) (r).cmic_i2c_data[0] = 0
#define BCM56504_A0_CMIC_I2C_DATAr_SET(r,d) (r).cmic_i2c_data[0] = d
#define BCM56504_A0_CMIC_I2C_DATAr_GET(r) (r).cmic_i2c_data[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_I2C_DATAr_DATAf_GET(r) (((r).cmic_i2c_data[0]) & 0xff)
#define BCM56504_A0_CMIC_I2C_DATAr_DATAf_SET(r,f) (r).cmic_i2c_data[0]=(((r).cmic_i2c_data[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56504_A0_CMIC_I2C_DATAr_RESERVED_1f_GET(r) ((((r).cmic_i2c_data[0]) >> 8) & 0xffffff)
#define BCM56504_A0_CMIC_I2C_DATAr_RESERVED_1f_SET(r,f) (r).cmic_i2c_data[0]=(((r).cmic_i2c_data[0] & ~((uint32_t)0xffffff << 8)) | ((((uint32_t)f) & 0xffffff) << 8))

/*
 * These macros can be used to access CMIC_I2C_DATA.
 *
 */
#define BCM56504_A0_READ_CMIC_I2C_DATAr(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_I2C_DATAr,r._cmic_i2c_data)
#define BCM56504_A0_WRITE_CMIC_I2C_DATAr(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_I2C_DATAr,r._cmic_i2c_data)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_I2C_DATAr BCM56504_A0_CMIC_I2C_DATAr
#define CMIC_I2C_DATAr_SIZE BCM56504_A0_CMIC_I2C_DATAr_SIZE
typedef BCM56504_A0_CMIC_I2C_DATAr_t CMIC_I2C_DATAr_t;
#define CMIC_I2C_DATAr_CLR BCM56504_A0_CMIC_I2C_DATAr_CLR
#define CMIC_I2C_DATAr_SET BCM56504_A0_CMIC_I2C_DATAr_SET
#define CMIC_I2C_DATAr_GET BCM56504_A0_CMIC_I2C_DATAr_GET
#define CMIC_I2C_DATAr_DATAf_GET BCM56504_A0_CMIC_I2C_DATAr_DATAf_GET
#define CMIC_I2C_DATAr_DATAf_SET BCM56504_A0_CMIC_I2C_DATAr_DATAf_SET
#define CMIC_I2C_DATAr_RESERVED_1f_GET BCM56504_A0_CMIC_I2C_DATAr_RESERVED_1f_GET
#define CMIC_I2C_DATAr_RESERVED_1f_SET BCM56504_A0_CMIC_I2C_DATAr_RESERVED_1f_SET
#define READ_CMIC_I2C_DATAr BCM56504_A0_READ_CMIC_I2C_DATAr
#define WRITE_CMIC_I2C_DATAr BCM56504_A0_WRITE_CMIC_I2C_DATAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_I2C_DATAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_I2C_RESET
 * BLOCKS:   CMIC
 * DESC:     I2C Soft Reset Register
 * SIZE:     32
 * FIELDS:
 *     RESET            A write operation to this register with any data will perform a soft reset to the I2C interface.  The bus is set to idle state and the MM_STOP, MM_STRT and INT_FLAG in the I2C Status and Control Register are set to 0. 
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_I2C_RESETr 0x0000013c

#define BCM56504_A0_CMIC_I2C_RESETr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_I2C_RESET.
 *
 */
typedef union BCM56504_A0_CMIC_I2C_RESETr_s {
	uint32_t v[1];
	uint32_t cmic_i2c_reset[1];
	uint32_t _cmic_i2c_reset;
} BCM56504_A0_CMIC_I2C_RESETr_t;

#define BCM56504_A0_CMIC_I2C_RESETr_CLR(r) (r).cmic_i2c_reset[0] = 0
#define BCM56504_A0_CMIC_I2C_RESETr_SET(r,d) (r).cmic_i2c_reset[0] = d
#define BCM56504_A0_CMIC_I2C_RESETr_GET(r) (r).cmic_i2c_reset[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_I2C_RESETr_RESETf_GET(r) (((r).cmic_i2c_reset[0]) & 0xff)
#define BCM56504_A0_CMIC_I2C_RESETr_RESETf_SET(r,f) (r).cmic_i2c_reset[0]=(((r).cmic_i2c_reset[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56504_A0_CMIC_I2C_RESETr_RESERVED_1f_GET(r) ((((r).cmic_i2c_reset[0]) >> 8) & 0xffffff)
#define BCM56504_A0_CMIC_I2C_RESETr_RESERVED_1f_SET(r,f) (r).cmic_i2c_reset[0]=(((r).cmic_i2c_reset[0] & ~((uint32_t)0xffffff << 8)) | ((((uint32_t)f) & 0xffffff) << 8))

/*
 * These macros can be used to access CMIC_I2C_RESET.
 *
 */
#define BCM56504_A0_READ_CMIC_I2C_RESETr(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_I2C_RESETr,r._cmic_i2c_reset)
#define BCM56504_A0_WRITE_CMIC_I2C_RESETr(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_I2C_RESETr,r._cmic_i2c_reset)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_I2C_RESETr BCM56504_A0_CMIC_I2C_RESETr
#define CMIC_I2C_RESETr_SIZE BCM56504_A0_CMIC_I2C_RESETr_SIZE
typedef BCM56504_A0_CMIC_I2C_RESETr_t CMIC_I2C_RESETr_t;
#define CMIC_I2C_RESETr_CLR BCM56504_A0_CMIC_I2C_RESETr_CLR
#define CMIC_I2C_RESETr_SET BCM56504_A0_CMIC_I2C_RESETr_SET
#define CMIC_I2C_RESETr_GET BCM56504_A0_CMIC_I2C_RESETr_GET
#define CMIC_I2C_RESETr_RESETf_GET BCM56504_A0_CMIC_I2C_RESETr_RESETf_GET
#define CMIC_I2C_RESETr_RESETf_SET BCM56504_A0_CMIC_I2C_RESETr_RESETf_SET
#define CMIC_I2C_RESETr_RESERVED_1f_GET BCM56504_A0_CMIC_I2C_RESETr_RESERVED_1f_GET
#define CMIC_I2C_RESETr_RESERVED_1f_SET BCM56504_A0_CMIC_I2C_RESETr_RESERVED_1f_SET
#define READ_CMIC_I2C_RESETr BCM56504_A0_READ_CMIC_I2C_RESETr
#define WRITE_CMIC_I2C_RESETr BCM56504_A0_WRITE_CMIC_I2C_RESETr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_I2C_RESETr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_I2C_SLAVE_ADDR
 * BLOCKS:   CMIC
 * DESC:     I2C Slave Address Register
 * SIZE:     32
 * FIELDS:
 *     GEN_CALL_EN      Controls recognition of the General Call Address of 00H.0 = Disable General Call Address recognition1 = Enable General Call Address recognition
 *     ADDR             I2C SLAVE Address 6:0
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_I2C_SLAVE_ADDRr 0x00000120

#define BCM56504_A0_CMIC_I2C_SLAVE_ADDRr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_I2C_SLAVE_ADDR.
 *
 */
typedef union BCM56504_A0_CMIC_I2C_SLAVE_ADDRr_s {
	uint32_t v[1];
	uint32_t cmic_i2c_slave_addr[1];
	uint32_t _cmic_i2c_slave_addr;
} BCM56504_A0_CMIC_I2C_SLAVE_ADDRr_t;

#define BCM56504_A0_CMIC_I2C_SLAVE_ADDRr_CLR(r) (r).cmic_i2c_slave_addr[0] = 0
#define BCM56504_A0_CMIC_I2C_SLAVE_ADDRr_SET(r,d) (r).cmic_i2c_slave_addr[0] = d
#define BCM56504_A0_CMIC_I2C_SLAVE_ADDRr_GET(r) (r).cmic_i2c_slave_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_I2C_SLAVE_ADDRr_GEN_CALL_ENf_GET(r) (((r).cmic_i2c_slave_addr[0]) & 0x1)
#define BCM56504_A0_CMIC_I2C_SLAVE_ADDRr_GEN_CALL_ENf_SET(r,f) (r).cmic_i2c_slave_addr[0]=(((r).cmic_i2c_slave_addr[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_CMIC_I2C_SLAVE_ADDRr_ADDRf_GET(r) ((((r).cmic_i2c_slave_addr[0]) >> 1) & 0x7f)
#define BCM56504_A0_CMIC_I2C_SLAVE_ADDRr_ADDRf_SET(r,f) (r).cmic_i2c_slave_addr[0]=(((r).cmic_i2c_slave_addr[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))
#define BCM56504_A0_CMIC_I2C_SLAVE_ADDRr_RESERVED_1f_GET(r) ((((r).cmic_i2c_slave_addr[0]) >> 8) & 0xffffff)
#define BCM56504_A0_CMIC_I2C_SLAVE_ADDRr_RESERVED_1f_SET(r,f) (r).cmic_i2c_slave_addr[0]=(((r).cmic_i2c_slave_addr[0] & ~((uint32_t)0xffffff << 8)) | ((((uint32_t)f) & 0xffffff) << 8))

/*
 * These macros can be used to access CMIC_I2C_SLAVE_ADDR.
 *
 */
#define BCM56504_A0_READ_CMIC_I2C_SLAVE_ADDRr(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_I2C_SLAVE_ADDRr,r._cmic_i2c_slave_addr)
#define BCM56504_A0_WRITE_CMIC_I2C_SLAVE_ADDRr(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_I2C_SLAVE_ADDRr,r._cmic_i2c_slave_addr)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_I2C_SLAVE_ADDRr BCM56504_A0_CMIC_I2C_SLAVE_ADDRr
#define CMIC_I2C_SLAVE_ADDRr_SIZE BCM56504_A0_CMIC_I2C_SLAVE_ADDRr_SIZE
typedef BCM56504_A0_CMIC_I2C_SLAVE_ADDRr_t CMIC_I2C_SLAVE_ADDRr_t;
#define CMIC_I2C_SLAVE_ADDRr_CLR BCM56504_A0_CMIC_I2C_SLAVE_ADDRr_CLR
#define CMIC_I2C_SLAVE_ADDRr_SET BCM56504_A0_CMIC_I2C_SLAVE_ADDRr_SET
#define CMIC_I2C_SLAVE_ADDRr_GET BCM56504_A0_CMIC_I2C_SLAVE_ADDRr_GET
#define CMIC_I2C_SLAVE_ADDRr_GEN_CALL_ENf_GET BCM56504_A0_CMIC_I2C_SLAVE_ADDRr_GEN_CALL_ENf_GET
#define CMIC_I2C_SLAVE_ADDRr_GEN_CALL_ENf_SET BCM56504_A0_CMIC_I2C_SLAVE_ADDRr_GEN_CALL_ENf_SET
#define CMIC_I2C_SLAVE_ADDRr_ADDRf_GET BCM56504_A0_CMIC_I2C_SLAVE_ADDRr_ADDRf_GET
#define CMIC_I2C_SLAVE_ADDRr_ADDRf_SET BCM56504_A0_CMIC_I2C_SLAVE_ADDRr_ADDRf_SET
#define CMIC_I2C_SLAVE_ADDRr_RESERVED_1f_GET BCM56504_A0_CMIC_I2C_SLAVE_ADDRr_RESERVED_1f_GET
#define CMIC_I2C_SLAVE_ADDRr_RESERVED_1f_SET BCM56504_A0_CMIC_I2C_SLAVE_ADDRr_RESERVED_1f_SET
#define READ_CMIC_I2C_SLAVE_ADDRr BCM56504_A0_READ_CMIC_I2C_SLAVE_ADDRr
#define WRITE_CMIC_I2C_SLAVE_ADDRr BCM56504_A0_WRITE_CMIC_I2C_SLAVE_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_I2C_SLAVE_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_I2C_SLAVE_XADDR
 * BLOCKS:   CMIC
 * DESC:     I2C Slave Extended Address Register
 * SIZE:     32
 * FIELDS:
 *     ADDR             Slave address 7-0 for the extended slave addressing mode.  When the address received starts with F7-F0H, the two LSBs are recognized as slave address 9-8 and the content of this register are used as address 7-0 to form the 10-bit address used in extended addressing mode. 
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_I2C_SLAVE_XADDRr 0x00000130

#define BCM56504_A0_CMIC_I2C_SLAVE_XADDRr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_I2C_SLAVE_XADDR.
 *
 */
typedef union BCM56504_A0_CMIC_I2C_SLAVE_XADDRr_s {
	uint32_t v[1];
	uint32_t cmic_i2c_slave_xaddr[1];
	uint32_t _cmic_i2c_slave_xaddr;
} BCM56504_A0_CMIC_I2C_SLAVE_XADDRr_t;

#define BCM56504_A0_CMIC_I2C_SLAVE_XADDRr_CLR(r) (r).cmic_i2c_slave_xaddr[0] = 0
#define BCM56504_A0_CMIC_I2C_SLAVE_XADDRr_SET(r,d) (r).cmic_i2c_slave_xaddr[0] = d
#define BCM56504_A0_CMIC_I2C_SLAVE_XADDRr_GET(r) (r).cmic_i2c_slave_xaddr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_I2C_SLAVE_XADDRr_ADDRf_GET(r) (((r).cmic_i2c_slave_xaddr[0]) & 0xff)
#define BCM56504_A0_CMIC_I2C_SLAVE_XADDRr_ADDRf_SET(r,f) (r).cmic_i2c_slave_xaddr[0]=(((r).cmic_i2c_slave_xaddr[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56504_A0_CMIC_I2C_SLAVE_XADDRr_RESERVED_1f_GET(r) ((((r).cmic_i2c_slave_xaddr[0]) >> 8) & 0xffffff)
#define BCM56504_A0_CMIC_I2C_SLAVE_XADDRr_RESERVED_1f_SET(r,f) (r).cmic_i2c_slave_xaddr[0]=(((r).cmic_i2c_slave_xaddr[0] & ~((uint32_t)0xffffff << 8)) | ((((uint32_t)f) & 0xffffff) << 8))

/*
 * These macros can be used to access CMIC_I2C_SLAVE_XADDR.
 *
 */
#define BCM56504_A0_READ_CMIC_I2C_SLAVE_XADDRr(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_I2C_SLAVE_XADDRr,r._cmic_i2c_slave_xaddr)
#define BCM56504_A0_WRITE_CMIC_I2C_SLAVE_XADDRr(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_I2C_SLAVE_XADDRr,r._cmic_i2c_slave_xaddr)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_I2C_SLAVE_XADDRr BCM56504_A0_CMIC_I2C_SLAVE_XADDRr
#define CMIC_I2C_SLAVE_XADDRr_SIZE BCM56504_A0_CMIC_I2C_SLAVE_XADDRr_SIZE
typedef BCM56504_A0_CMIC_I2C_SLAVE_XADDRr_t CMIC_I2C_SLAVE_XADDRr_t;
#define CMIC_I2C_SLAVE_XADDRr_CLR BCM56504_A0_CMIC_I2C_SLAVE_XADDRr_CLR
#define CMIC_I2C_SLAVE_XADDRr_SET BCM56504_A0_CMIC_I2C_SLAVE_XADDRr_SET
#define CMIC_I2C_SLAVE_XADDRr_GET BCM56504_A0_CMIC_I2C_SLAVE_XADDRr_GET
#define CMIC_I2C_SLAVE_XADDRr_ADDRf_GET BCM56504_A0_CMIC_I2C_SLAVE_XADDRr_ADDRf_GET
#define CMIC_I2C_SLAVE_XADDRr_ADDRf_SET BCM56504_A0_CMIC_I2C_SLAVE_XADDRr_ADDRf_SET
#define CMIC_I2C_SLAVE_XADDRr_RESERVED_1f_GET BCM56504_A0_CMIC_I2C_SLAVE_XADDRr_RESERVED_1f_GET
#define CMIC_I2C_SLAVE_XADDRr_RESERVED_1f_SET BCM56504_A0_CMIC_I2C_SLAVE_XADDRr_RESERVED_1f_SET
#define READ_CMIC_I2C_SLAVE_XADDRr BCM56504_A0_READ_CMIC_I2C_SLAVE_XADDRr
#define WRITE_CMIC_I2C_SLAVE_XADDRr BCM56504_A0_WRITE_CMIC_I2C_SLAVE_XADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_I2C_SLAVE_XADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_I2C_STAT
 * BLOCKS:   CMIC
 * DESC:     I2C Condition Status Register
 * SIZE:     32
 * FIELDS:
 *     RESERVED_1       Reserved
 *     COND             Five bit condition codes defined as follows: I2C Status Register
 *     RESERVED_2       Reserved
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_I2C_STATr 0x0000012c

#define BCM56504_A0_CMIC_I2C_STATr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_I2C_STAT.
 *
 */
typedef union BCM56504_A0_CMIC_I2C_STATr_s {
	uint32_t v[1];
	uint32_t cmic_i2c_stat[1];
	uint32_t _cmic_i2c_stat;
} BCM56504_A0_CMIC_I2C_STATr_t;

#define BCM56504_A0_CMIC_I2C_STATr_CLR(r) (r).cmic_i2c_stat[0] = 0
#define BCM56504_A0_CMIC_I2C_STATr_SET(r,d) (r).cmic_i2c_stat[0] = d
#define BCM56504_A0_CMIC_I2C_STATr_GET(r) (r).cmic_i2c_stat[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_I2C_STATr_RESERVED_1f_GET(r) (((r).cmic_i2c_stat[0]) & 0x7)
#define BCM56504_A0_CMIC_I2C_STATr_RESERVED_1f_SET(r,f) (r).cmic_i2c_stat[0]=(((r).cmic_i2c_stat[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM56504_A0_CMIC_I2C_STATr_CONDf_GET(r) ((((r).cmic_i2c_stat[0]) >> 3) & 0x1f)
#define BCM56504_A0_CMIC_I2C_STATr_CONDf_SET(r,f) (r).cmic_i2c_stat[0]=(((r).cmic_i2c_stat[0] & ~((uint32_t)0x1f << 3)) | ((((uint32_t)f) & 0x1f) << 3))
#define BCM56504_A0_CMIC_I2C_STATr_RESERVED_2f_GET(r) ((((r).cmic_i2c_stat[0]) >> 8) & 0xffffff)
#define BCM56504_A0_CMIC_I2C_STATr_RESERVED_2f_SET(r,f) (r).cmic_i2c_stat[0]=(((r).cmic_i2c_stat[0] & ~((uint32_t)0xffffff << 8)) | ((((uint32_t)f) & 0xffffff) << 8))

/*
 * These macros can be used to access CMIC_I2C_STAT.
 *
 */
#define BCM56504_A0_READ_CMIC_I2C_STATr(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_I2C_STATr,r._cmic_i2c_stat)
#define BCM56504_A0_WRITE_CMIC_I2C_STATr(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_I2C_STATr,r._cmic_i2c_stat)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_I2C_STATr BCM56504_A0_CMIC_I2C_STATr
#define CMIC_I2C_STATr_SIZE BCM56504_A0_CMIC_I2C_STATr_SIZE
typedef BCM56504_A0_CMIC_I2C_STATr_t CMIC_I2C_STATr_t;
#define CMIC_I2C_STATr_CLR BCM56504_A0_CMIC_I2C_STATr_CLR
#define CMIC_I2C_STATr_SET BCM56504_A0_CMIC_I2C_STATr_SET
#define CMIC_I2C_STATr_GET BCM56504_A0_CMIC_I2C_STATr_GET
#define CMIC_I2C_STATr_RESERVED_1f_GET BCM56504_A0_CMIC_I2C_STATr_RESERVED_1f_GET
#define CMIC_I2C_STATr_RESERVED_1f_SET BCM56504_A0_CMIC_I2C_STATr_RESERVED_1f_SET
#define CMIC_I2C_STATr_CONDf_GET BCM56504_A0_CMIC_I2C_STATr_CONDf_GET
#define CMIC_I2C_STATr_CONDf_SET BCM56504_A0_CMIC_I2C_STATr_CONDf_SET
#define CMIC_I2C_STATr_RESERVED_2f_GET BCM56504_A0_CMIC_I2C_STATr_RESERVED_2f_GET
#define CMIC_I2C_STATr_RESERVED_2f_SET BCM56504_A0_CMIC_I2C_STATr_RESERVED_2f_SET
#define READ_CMIC_I2C_STATr BCM56504_A0_READ_CMIC_I2C_STATr
#define WRITE_CMIC_I2C_STATr BCM56504_A0_WRITE_CMIC_I2C_STATr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_I2C_STATr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_IRQ_MASK
 * BLOCKS:   CMIC
 * DESC:     Interrupt Mask Register
 * SIZE:     32
 * FIELDS:
 *     SCH_MSG_DONE     SCH Message Operation Complete Mask
 *     RESERVED_1       Reserved
 *     LINK_STAT_MOD    Link Status Change Mask
 *     L2_MOD_FIFO_NOT_EMPTY L2 MOD Fifo is full
 *     RESERVED_2       Reserved
 *     CH0_DESC_DONE    DMA CH0 Next Descriptor Execution Complete Mask
 *     CH0_CHAIN_DONE   DMA CH0 End Of Chain Mask
 *     CH1_DESC_DONE    DMA CH1 Next Descriptor Execution Complete Mask
 *     CH1_CHAIN_DONE   DMA CH1 ENd Of Chain Mask
 *     CH2_DESC_DONE    DMA CH2 Next Descriptor Execution Complete Mask
 *     CH2_CHAIN_DONE   DMA CH2 End Of Chain Mask
 *     CH3_DESC_DONE    DMA CH3 Next Descriptor Execution Complete Mask
 *     CH3_CHAIN_DONE   DMA CH3 End Of Chain Mask
 *     PCI_PARITY_ERR   PCI Bus Parity Error Mask
 *     PCI_FATAL_ERR    PCI Bus Fatal Error Mask
 *     SCHAN_ERR        SCH Bus Error Mask
 *     I2C_INTR         I2C Mask
 *     MIIM_OP_DONE     MIIM Operation Complete Mask
 *     STAT_DMA_DONE    Stats DMA Iteration Complete Mask
 *     RESERVED_3       Reserved
 *     BSE_CMDMEM_DONE  BSE CMDMEM DONE
 *     CSE_CMDMEM_DONE  CSE CMDMEM DONE
 *     HSE_CMDMEM_DONE  HSE CMDMEM DONE
 *     MEM_FAIL         MMU Memory Failed
 *     TABLE_DMA_COMPLETE Table DMA operation complete Mask
 *     SLAM_DMA_COMPLETE Slam DMA operation complete Mask
 *     BSAFE_OP_DONE    Broadsafe operation complete
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_IRQ_MASKr 0x00000148

#define BCM56504_A0_CMIC_IRQ_MASKr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_IRQ_MASK.
 *
 */
typedef union BCM56504_A0_CMIC_IRQ_MASKr_s {
	uint32_t v[1];
	uint32_t cmic_irq_mask[1];
	uint32_t _cmic_irq_mask;
} BCM56504_A0_CMIC_IRQ_MASKr_t;

#define BCM56504_A0_CMIC_IRQ_MASKr_CLR(r) (r).cmic_irq_mask[0] = 0
#define BCM56504_A0_CMIC_IRQ_MASKr_SET(r,d) (r).cmic_irq_mask[0] = d
#define BCM56504_A0_CMIC_IRQ_MASKr_GET(r) (r).cmic_irq_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_IRQ_MASKr_SCH_MSG_DONEf_GET(r) (((r).cmic_irq_mask[0]) & 0x1)
#define BCM56504_A0_CMIC_IRQ_MASKr_SCH_MSG_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_CMIC_IRQ_MASKr_RESERVED_1f_GET(r) ((((r).cmic_irq_mask[0]) >> 1) & 0x7)
#define BCM56504_A0_CMIC_IRQ_MASKr_RESERVED_1f_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define BCM56504_A0_CMIC_IRQ_MASKr_LINK_STAT_MODf_GET(r) ((((r).cmic_irq_mask[0]) >> 4) & 0x1)
#define BCM56504_A0_CMIC_IRQ_MASKr_LINK_STAT_MODf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56504_A0_CMIC_IRQ_MASKr_L2_MOD_FIFO_NOT_EMPTYf_GET(r) ((((r).cmic_irq_mask[0]) >> 5) & 0x1)
#define BCM56504_A0_CMIC_IRQ_MASKr_L2_MOD_FIFO_NOT_EMPTYf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56504_A0_CMIC_IRQ_MASKr_RESERVED_2f_GET(r) ((((r).cmic_irq_mask[0]) >> 6) & 0x1)
#define BCM56504_A0_CMIC_IRQ_MASKr_RESERVED_2f_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56504_A0_CMIC_IRQ_MASKr_CH0_DESC_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 7) & 0x1)
#define BCM56504_A0_CMIC_IRQ_MASKr_CH0_DESC_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56504_A0_CMIC_IRQ_MASKr_CH0_CHAIN_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 8) & 0x1)
#define BCM56504_A0_CMIC_IRQ_MASKr_CH0_CHAIN_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56504_A0_CMIC_IRQ_MASKr_CH1_DESC_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 9) & 0x1)
#define BCM56504_A0_CMIC_IRQ_MASKr_CH1_DESC_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56504_A0_CMIC_IRQ_MASKr_CH1_CHAIN_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 10) & 0x1)
#define BCM56504_A0_CMIC_IRQ_MASKr_CH1_CHAIN_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56504_A0_CMIC_IRQ_MASKr_CH2_DESC_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 11) & 0x1)
#define BCM56504_A0_CMIC_IRQ_MASKr_CH2_DESC_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56504_A0_CMIC_IRQ_MASKr_CH2_CHAIN_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 12) & 0x1)
#define BCM56504_A0_CMIC_IRQ_MASKr_CH2_CHAIN_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM56504_A0_CMIC_IRQ_MASKr_CH3_DESC_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 13) & 0x1)
#define BCM56504_A0_CMIC_IRQ_MASKr_CH3_DESC_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56504_A0_CMIC_IRQ_MASKr_CH3_CHAIN_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 14) & 0x1)
#define BCM56504_A0_CMIC_IRQ_MASKr_CH3_CHAIN_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM56504_A0_CMIC_IRQ_MASKr_PCI_PARITY_ERRf_GET(r) ((((r).cmic_irq_mask[0]) >> 15) & 0x1)
#define BCM56504_A0_CMIC_IRQ_MASKr_PCI_PARITY_ERRf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56504_A0_CMIC_IRQ_MASKr_PCI_FATAL_ERRf_GET(r) ((((r).cmic_irq_mask[0]) >> 16) & 0x1)
#define BCM56504_A0_CMIC_IRQ_MASKr_PCI_FATAL_ERRf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56504_A0_CMIC_IRQ_MASKr_SCHAN_ERRf_GET(r) ((((r).cmic_irq_mask[0]) >> 17) & 0x1)
#define BCM56504_A0_CMIC_IRQ_MASKr_SCHAN_ERRf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56504_A0_CMIC_IRQ_MASKr_I2C_INTRf_GET(r) ((((r).cmic_irq_mask[0]) >> 18) & 0x1)
#define BCM56504_A0_CMIC_IRQ_MASKr_I2C_INTRf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56504_A0_CMIC_IRQ_MASKr_MIIM_OP_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 19) & 0x1)
#define BCM56504_A0_CMIC_IRQ_MASKr_MIIM_OP_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56504_A0_CMIC_IRQ_MASKr_STAT_DMA_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 20) & 0x1)
#define BCM56504_A0_CMIC_IRQ_MASKr_STAT_DMA_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM56504_A0_CMIC_IRQ_MASKr_RESERVED_3f_GET(r) ((((r).cmic_irq_mask[0]) >> 21) & 0xf)
#define BCM56504_A0_CMIC_IRQ_MASKr_RESERVED_3f_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0xf << 21)) | ((((uint32_t)f) & 0xf) << 21))
#define BCM56504_A0_CMIC_IRQ_MASKr_BSE_CMDMEM_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 25) & 0x1)
#define BCM56504_A0_CMIC_IRQ_MASKr_BSE_CMDMEM_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM56504_A0_CMIC_IRQ_MASKr_CSE_CMDMEM_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 26) & 0x1)
#define BCM56504_A0_CMIC_IRQ_MASKr_CSE_CMDMEM_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM56504_A0_CMIC_IRQ_MASKr_HSE_CMDMEM_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 27) & 0x1)
#define BCM56504_A0_CMIC_IRQ_MASKr_HSE_CMDMEM_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM56504_A0_CMIC_IRQ_MASKr_MEM_FAILf_GET(r) ((((r).cmic_irq_mask[0]) >> 28) & 0x1)
#define BCM56504_A0_CMIC_IRQ_MASKr_MEM_FAILf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM56504_A0_CMIC_IRQ_MASKr_TABLE_DMA_COMPLETEf_GET(r) ((((r).cmic_irq_mask[0]) >> 29) & 0x1)
#define BCM56504_A0_CMIC_IRQ_MASKr_TABLE_DMA_COMPLETEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM56504_A0_CMIC_IRQ_MASKr_SLAM_DMA_COMPLETEf_GET(r) ((((r).cmic_irq_mask[0]) >> 30) & 0x1)
#define BCM56504_A0_CMIC_IRQ_MASKr_SLAM_DMA_COMPLETEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM56504_A0_CMIC_IRQ_MASKr_BSAFE_OP_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 31) & 0x1)
#define BCM56504_A0_CMIC_IRQ_MASKr_BSAFE_OP_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access CMIC_IRQ_MASK.
 *
 */
#define BCM56504_A0_READ_CMIC_IRQ_MASKr(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_IRQ_MASKr,r._cmic_irq_mask)
#define BCM56504_A0_WRITE_CMIC_IRQ_MASKr(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_IRQ_MASKr,r._cmic_irq_mask)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_IRQ_MASKr BCM56504_A0_CMIC_IRQ_MASKr
#define CMIC_IRQ_MASKr_SIZE BCM56504_A0_CMIC_IRQ_MASKr_SIZE
typedef BCM56504_A0_CMIC_IRQ_MASKr_t CMIC_IRQ_MASKr_t;
#define CMIC_IRQ_MASKr_CLR BCM56504_A0_CMIC_IRQ_MASKr_CLR
#define CMIC_IRQ_MASKr_SET BCM56504_A0_CMIC_IRQ_MASKr_SET
#define CMIC_IRQ_MASKr_GET BCM56504_A0_CMIC_IRQ_MASKr_GET
#define CMIC_IRQ_MASKr_SCH_MSG_DONEf_GET BCM56504_A0_CMIC_IRQ_MASKr_SCH_MSG_DONEf_GET
#define CMIC_IRQ_MASKr_SCH_MSG_DONEf_SET BCM56504_A0_CMIC_IRQ_MASKr_SCH_MSG_DONEf_SET
#define CMIC_IRQ_MASKr_RESERVED_1f_GET BCM56504_A0_CMIC_IRQ_MASKr_RESERVED_1f_GET
#define CMIC_IRQ_MASKr_RESERVED_1f_SET BCM56504_A0_CMIC_IRQ_MASKr_RESERVED_1f_SET
#define CMIC_IRQ_MASKr_LINK_STAT_MODf_GET BCM56504_A0_CMIC_IRQ_MASKr_LINK_STAT_MODf_GET
#define CMIC_IRQ_MASKr_LINK_STAT_MODf_SET BCM56504_A0_CMIC_IRQ_MASKr_LINK_STAT_MODf_SET
#define CMIC_IRQ_MASKr_L2_MOD_FIFO_NOT_EMPTYf_GET BCM56504_A0_CMIC_IRQ_MASKr_L2_MOD_FIFO_NOT_EMPTYf_GET
#define CMIC_IRQ_MASKr_L2_MOD_FIFO_NOT_EMPTYf_SET BCM56504_A0_CMIC_IRQ_MASKr_L2_MOD_FIFO_NOT_EMPTYf_SET
#define CMIC_IRQ_MASKr_RESERVED_2f_GET BCM56504_A0_CMIC_IRQ_MASKr_RESERVED_2f_GET
#define CMIC_IRQ_MASKr_RESERVED_2f_SET BCM56504_A0_CMIC_IRQ_MASKr_RESERVED_2f_SET
#define CMIC_IRQ_MASKr_CH0_DESC_DONEf_GET BCM56504_A0_CMIC_IRQ_MASKr_CH0_DESC_DONEf_GET
#define CMIC_IRQ_MASKr_CH0_DESC_DONEf_SET BCM56504_A0_CMIC_IRQ_MASKr_CH0_DESC_DONEf_SET
#define CMIC_IRQ_MASKr_CH0_CHAIN_DONEf_GET BCM56504_A0_CMIC_IRQ_MASKr_CH0_CHAIN_DONEf_GET
#define CMIC_IRQ_MASKr_CH0_CHAIN_DONEf_SET BCM56504_A0_CMIC_IRQ_MASKr_CH0_CHAIN_DONEf_SET
#define CMIC_IRQ_MASKr_CH1_DESC_DONEf_GET BCM56504_A0_CMIC_IRQ_MASKr_CH1_DESC_DONEf_GET
#define CMIC_IRQ_MASKr_CH1_DESC_DONEf_SET BCM56504_A0_CMIC_IRQ_MASKr_CH1_DESC_DONEf_SET
#define CMIC_IRQ_MASKr_CH1_CHAIN_DONEf_GET BCM56504_A0_CMIC_IRQ_MASKr_CH1_CHAIN_DONEf_GET
#define CMIC_IRQ_MASKr_CH1_CHAIN_DONEf_SET BCM56504_A0_CMIC_IRQ_MASKr_CH1_CHAIN_DONEf_SET
#define CMIC_IRQ_MASKr_CH2_DESC_DONEf_GET BCM56504_A0_CMIC_IRQ_MASKr_CH2_DESC_DONEf_GET
#define CMIC_IRQ_MASKr_CH2_DESC_DONEf_SET BCM56504_A0_CMIC_IRQ_MASKr_CH2_DESC_DONEf_SET
#define CMIC_IRQ_MASKr_CH2_CHAIN_DONEf_GET BCM56504_A0_CMIC_IRQ_MASKr_CH2_CHAIN_DONEf_GET
#define CMIC_IRQ_MASKr_CH2_CHAIN_DONEf_SET BCM56504_A0_CMIC_IRQ_MASKr_CH2_CHAIN_DONEf_SET
#define CMIC_IRQ_MASKr_CH3_DESC_DONEf_GET BCM56504_A0_CMIC_IRQ_MASKr_CH3_DESC_DONEf_GET
#define CMIC_IRQ_MASKr_CH3_DESC_DONEf_SET BCM56504_A0_CMIC_IRQ_MASKr_CH3_DESC_DONEf_SET
#define CMIC_IRQ_MASKr_CH3_CHAIN_DONEf_GET BCM56504_A0_CMIC_IRQ_MASKr_CH3_CHAIN_DONEf_GET
#define CMIC_IRQ_MASKr_CH3_CHAIN_DONEf_SET BCM56504_A0_CMIC_IRQ_MASKr_CH3_CHAIN_DONEf_SET
#define CMIC_IRQ_MASKr_PCI_PARITY_ERRf_GET BCM56504_A0_CMIC_IRQ_MASKr_PCI_PARITY_ERRf_GET
#define CMIC_IRQ_MASKr_PCI_PARITY_ERRf_SET BCM56504_A0_CMIC_IRQ_MASKr_PCI_PARITY_ERRf_SET
#define CMIC_IRQ_MASKr_PCI_FATAL_ERRf_GET BCM56504_A0_CMIC_IRQ_MASKr_PCI_FATAL_ERRf_GET
#define CMIC_IRQ_MASKr_PCI_FATAL_ERRf_SET BCM56504_A0_CMIC_IRQ_MASKr_PCI_FATAL_ERRf_SET
#define CMIC_IRQ_MASKr_SCHAN_ERRf_GET BCM56504_A0_CMIC_IRQ_MASKr_SCHAN_ERRf_GET
#define CMIC_IRQ_MASKr_SCHAN_ERRf_SET BCM56504_A0_CMIC_IRQ_MASKr_SCHAN_ERRf_SET
#define CMIC_IRQ_MASKr_I2C_INTRf_GET BCM56504_A0_CMIC_IRQ_MASKr_I2C_INTRf_GET
#define CMIC_IRQ_MASKr_I2C_INTRf_SET BCM56504_A0_CMIC_IRQ_MASKr_I2C_INTRf_SET
#define CMIC_IRQ_MASKr_MIIM_OP_DONEf_GET BCM56504_A0_CMIC_IRQ_MASKr_MIIM_OP_DONEf_GET
#define CMIC_IRQ_MASKr_MIIM_OP_DONEf_SET BCM56504_A0_CMIC_IRQ_MASKr_MIIM_OP_DONEf_SET
#define CMIC_IRQ_MASKr_STAT_DMA_DONEf_GET BCM56504_A0_CMIC_IRQ_MASKr_STAT_DMA_DONEf_GET
#define CMIC_IRQ_MASKr_STAT_DMA_DONEf_SET BCM56504_A0_CMIC_IRQ_MASKr_STAT_DMA_DONEf_SET
#define CMIC_IRQ_MASKr_RESERVED_3f_GET BCM56504_A0_CMIC_IRQ_MASKr_RESERVED_3f_GET
#define CMIC_IRQ_MASKr_RESERVED_3f_SET BCM56504_A0_CMIC_IRQ_MASKr_RESERVED_3f_SET
#define CMIC_IRQ_MASKr_BSE_CMDMEM_DONEf_GET BCM56504_A0_CMIC_IRQ_MASKr_BSE_CMDMEM_DONEf_GET
#define CMIC_IRQ_MASKr_BSE_CMDMEM_DONEf_SET BCM56504_A0_CMIC_IRQ_MASKr_BSE_CMDMEM_DONEf_SET
#define CMIC_IRQ_MASKr_CSE_CMDMEM_DONEf_GET BCM56504_A0_CMIC_IRQ_MASKr_CSE_CMDMEM_DONEf_GET
#define CMIC_IRQ_MASKr_CSE_CMDMEM_DONEf_SET BCM56504_A0_CMIC_IRQ_MASKr_CSE_CMDMEM_DONEf_SET
#define CMIC_IRQ_MASKr_HSE_CMDMEM_DONEf_GET BCM56504_A0_CMIC_IRQ_MASKr_HSE_CMDMEM_DONEf_GET
#define CMIC_IRQ_MASKr_HSE_CMDMEM_DONEf_SET BCM56504_A0_CMIC_IRQ_MASKr_HSE_CMDMEM_DONEf_SET
#define CMIC_IRQ_MASKr_MEM_FAILf_GET BCM56504_A0_CMIC_IRQ_MASKr_MEM_FAILf_GET
#define CMIC_IRQ_MASKr_MEM_FAILf_SET BCM56504_A0_CMIC_IRQ_MASKr_MEM_FAILf_SET
#define CMIC_IRQ_MASKr_TABLE_DMA_COMPLETEf_GET BCM56504_A0_CMIC_IRQ_MASKr_TABLE_DMA_COMPLETEf_GET
#define CMIC_IRQ_MASKr_TABLE_DMA_COMPLETEf_SET BCM56504_A0_CMIC_IRQ_MASKr_TABLE_DMA_COMPLETEf_SET
#define CMIC_IRQ_MASKr_SLAM_DMA_COMPLETEf_GET BCM56504_A0_CMIC_IRQ_MASKr_SLAM_DMA_COMPLETEf_GET
#define CMIC_IRQ_MASKr_SLAM_DMA_COMPLETEf_SET BCM56504_A0_CMIC_IRQ_MASKr_SLAM_DMA_COMPLETEf_SET
#define CMIC_IRQ_MASKr_BSAFE_OP_DONEf_GET BCM56504_A0_CMIC_IRQ_MASKr_BSAFE_OP_DONEf_GET
#define CMIC_IRQ_MASKr_BSAFE_OP_DONEf_SET BCM56504_A0_CMIC_IRQ_MASKr_BSAFE_OP_DONEf_SET
#define READ_CMIC_IRQ_MASKr BCM56504_A0_READ_CMIC_IRQ_MASKr
#define WRITE_CMIC_IRQ_MASKr BCM56504_A0_WRITE_CMIC_IRQ_MASKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_IRQ_MASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_IRQ_STAT
 * BLOCKS:   CMIC
 * DESC:     Interrupt Status Register
 * SIZE:     32
 * FIELDS:
 *     SCH_MSG_DONE     SCH Message Operation Complete Interrupt
 *     RESERVED_1       Reserved
 *     LINK_STAT_MOD    Link Status Change Interrupt
 *     L2_MOD_FIFO_NOT_EMPTY L2 MOD Fifo is full
 *     RESERVED_2       Reserved
 *     CH0_DESC_DONE    DMA CH0 Next Descriptor Execution Complete Interrupt
 *     CH0_CHAIN_DONE   DMA CH0 End Of Chain Interrupt
 *     CH1_DESC_DONE    DMA CH1 Next Descriptor Execution Complete Interrupt
 *     CH1_CHAIN_DONE   DMA CH1 End Of Chain Interrupt
 *     CH2_DESC_DONE    DMA CH2 Next Descriptor Execution Complete Interrupt
 *     CH2_CHAIN_DONE   DMA CH2 End Of Chain Interrupt
 *     CH3_DESC_DONE    DMA CH3 Next Descriptor Execution Complete Interrupt
 *     CH3_CHAIN_DONE   DMA CH3 End Of Chain Interrupt
 *     PCI_PARITY_ERR   PCI Bus Parity Error Interrupt
 *     PCI_FATAL_ERR    PCI Bus Fatal Error Interrupt
 *     SCHAN_ERR        SCH Bus Error Interrupt
 *     I2C_INTR         I2C Interrupt
 *     MIIM_OP_DONE     MIIM Operation Complete Interrupt
 *     STAT_DMA_DONE    Stats DMA Iteration Complete Interrupt
 *     RESERVED_3       Reserved
 *     BSE_CMDMEM_DONE  BSE CMDMEM DONE
 *     CSE_CMDMEM_DONE  CSE CMDMEM DONE
 *     HSE_CMDMEM_DONE  HSE CMDMEM DONE
 *     MEM_FAIL         MMU Memory Failed
 *     TABLE_DMA_COMPLETE Table DMA operation complete
 *     SLAM_DMA_COMPLETE Slam DMA operation complete
 *     BSAFE_OP_DONE    Broadsafe operation complete
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_IRQ_STATr 0x00000144

#define BCM56504_A0_CMIC_IRQ_STATr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_IRQ_STAT.
 *
 */
typedef union BCM56504_A0_CMIC_IRQ_STATr_s {
	uint32_t v[1];
	uint32_t cmic_irq_stat[1];
	uint32_t _cmic_irq_stat;
} BCM56504_A0_CMIC_IRQ_STATr_t;

#define BCM56504_A0_CMIC_IRQ_STATr_CLR(r) (r).cmic_irq_stat[0] = 0
#define BCM56504_A0_CMIC_IRQ_STATr_SET(r,d) (r).cmic_irq_stat[0] = d
#define BCM56504_A0_CMIC_IRQ_STATr_GET(r) (r).cmic_irq_stat[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_IRQ_STATr_SCH_MSG_DONEf_GET(r) (((r).cmic_irq_stat[0]) & 0x1)
#define BCM56504_A0_CMIC_IRQ_STATr_SCH_MSG_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_CMIC_IRQ_STATr_RESERVED_1f_GET(r) ((((r).cmic_irq_stat[0]) >> 1) & 0x7)
#define BCM56504_A0_CMIC_IRQ_STATr_RESERVED_1f_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define BCM56504_A0_CMIC_IRQ_STATr_LINK_STAT_MODf_GET(r) ((((r).cmic_irq_stat[0]) >> 4) & 0x1)
#define BCM56504_A0_CMIC_IRQ_STATr_LINK_STAT_MODf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56504_A0_CMIC_IRQ_STATr_L2_MOD_FIFO_NOT_EMPTYf_GET(r) ((((r).cmic_irq_stat[0]) >> 5) & 0x1)
#define BCM56504_A0_CMIC_IRQ_STATr_L2_MOD_FIFO_NOT_EMPTYf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56504_A0_CMIC_IRQ_STATr_RESERVED_2f_GET(r) ((((r).cmic_irq_stat[0]) >> 6) & 0x1)
#define BCM56504_A0_CMIC_IRQ_STATr_RESERVED_2f_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56504_A0_CMIC_IRQ_STATr_CH0_DESC_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 7) & 0x1)
#define BCM56504_A0_CMIC_IRQ_STATr_CH0_DESC_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56504_A0_CMIC_IRQ_STATr_CH0_CHAIN_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 8) & 0x1)
#define BCM56504_A0_CMIC_IRQ_STATr_CH0_CHAIN_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56504_A0_CMIC_IRQ_STATr_CH1_DESC_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 9) & 0x1)
#define BCM56504_A0_CMIC_IRQ_STATr_CH1_DESC_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56504_A0_CMIC_IRQ_STATr_CH1_CHAIN_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 10) & 0x1)
#define BCM56504_A0_CMIC_IRQ_STATr_CH1_CHAIN_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56504_A0_CMIC_IRQ_STATr_CH2_DESC_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 11) & 0x1)
#define BCM56504_A0_CMIC_IRQ_STATr_CH2_DESC_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56504_A0_CMIC_IRQ_STATr_CH2_CHAIN_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 12) & 0x1)
#define BCM56504_A0_CMIC_IRQ_STATr_CH2_CHAIN_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM56504_A0_CMIC_IRQ_STATr_CH3_DESC_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 13) & 0x1)
#define BCM56504_A0_CMIC_IRQ_STATr_CH3_DESC_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56504_A0_CMIC_IRQ_STATr_CH3_CHAIN_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 14) & 0x1)
#define BCM56504_A0_CMIC_IRQ_STATr_CH3_CHAIN_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM56504_A0_CMIC_IRQ_STATr_PCI_PARITY_ERRf_GET(r) ((((r).cmic_irq_stat[0]) >> 15) & 0x1)
#define BCM56504_A0_CMIC_IRQ_STATr_PCI_PARITY_ERRf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56504_A0_CMIC_IRQ_STATr_PCI_FATAL_ERRf_GET(r) ((((r).cmic_irq_stat[0]) >> 16) & 0x1)
#define BCM56504_A0_CMIC_IRQ_STATr_PCI_FATAL_ERRf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56504_A0_CMIC_IRQ_STATr_SCHAN_ERRf_GET(r) ((((r).cmic_irq_stat[0]) >> 17) & 0x1)
#define BCM56504_A0_CMIC_IRQ_STATr_SCHAN_ERRf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56504_A0_CMIC_IRQ_STATr_I2C_INTRf_GET(r) ((((r).cmic_irq_stat[0]) >> 18) & 0x1)
#define BCM56504_A0_CMIC_IRQ_STATr_I2C_INTRf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56504_A0_CMIC_IRQ_STATr_MIIM_OP_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 19) & 0x1)
#define BCM56504_A0_CMIC_IRQ_STATr_MIIM_OP_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56504_A0_CMIC_IRQ_STATr_STAT_DMA_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 20) & 0x1)
#define BCM56504_A0_CMIC_IRQ_STATr_STAT_DMA_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM56504_A0_CMIC_IRQ_STATr_RESERVED_3f_GET(r) ((((r).cmic_irq_stat[0]) >> 21) & 0xf)
#define BCM56504_A0_CMIC_IRQ_STATr_RESERVED_3f_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0xf << 21)) | ((((uint32_t)f) & 0xf) << 21))
#define BCM56504_A0_CMIC_IRQ_STATr_BSE_CMDMEM_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 25) & 0x1)
#define BCM56504_A0_CMIC_IRQ_STATr_BSE_CMDMEM_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM56504_A0_CMIC_IRQ_STATr_CSE_CMDMEM_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 26) & 0x1)
#define BCM56504_A0_CMIC_IRQ_STATr_CSE_CMDMEM_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM56504_A0_CMIC_IRQ_STATr_HSE_CMDMEM_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 27) & 0x1)
#define BCM56504_A0_CMIC_IRQ_STATr_HSE_CMDMEM_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM56504_A0_CMIC_IRQ_STATr_MEM_FAILf_GET(r) ((((r).cmic_irq_stat[0]) >> 28) & 0x1)
#define BCM56504_A0_CMIC_IRQ_STATr_MEM_FAILf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM56504_A0_CMIC_IRQ_STATr_TABLE_DMA_COMPLETEf_GET(r) ((((r).cmic_irq_stat[0]) >> 29) & 0x1)
#define BCM56504_A0_CMIC_IRQ_STATr_TABLE_DMA_COMPLETEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM56504_A0_CMIC_IRQ_STATr_SLAM_DMA_COMPLETEf_GET(r) ((((r).cmic_irq_stat[0]) >> 30) & 0x1)
#define BCM56504_A0_CMIC_IRQ_STATr_SLAM_DMA_COMPLETEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM56504_A0_CMIC_IRQ_STATr_BSAFE_OP_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 31) & 0x1)
#define BCM56504_A0_CMIC_IRQ_STATr_BSAFE_OP_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access CMIC_IRQ_STAT.
 *
 */
#define BCM56504_A0_READ_CMIC_IRQ_STATr(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_IRQ_STATr,r._cmic_irq_stat)
#define BCM56504_A0_WRITE_CMIC_IRQ_STATr(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_IRQ_STATr,r._cmic_irq_stat)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_IRQ_STATr BCM56504_A0_CMIC_IRQ_STATr
#define CMIC_IRQ_STATr_SIZE BCM56504_A0_CMIC_IRQ_STATr_SIZE
typedef BCM56504_A0_CMIC_IRQ_STATr_t CMIC_IRQ_STATr_t;
#define CMIC_IRQ_STATr_CLR BCM56504_A0_CMIC_IRQ_STATr_CLR
#define CMIC_IRQ_STATr_SET BCM56504_A0_CMIC_IRQ_STATr_SET
#define CMIC_IRQ_STATr_GET BCM56504_A0_CMIC_IRQ_STATr_GET
#define CMIC_IRQ_STATr_SCH_MSG_DONEf_GET BCM56504_A0_CMIC_IRQ_STATr_SCH_MSG_DONEf_GET
#define CMIC_IRQ_STATr_SCH_MSG_DONEf_SET BCM56504_A0_CMIC_IRQ_STATr_SCH_MSG_DONEf_SET
#define CMIC_IRQ_STATr_RESERVED_1f_GET BCM56504_A0_CMIC_IRQ_STATr_RESERVED_1f_GET
#define CMIC_IRQ_STATr_RESERVED_1f_SET BCM56504_A0_CMIC_IRQ_STATr_RESERVED_1f_SET
#define CMIC_IRQ_STATr_LINK_STAT_MODf_GET BCM56504_A0_CMIC_IRQ_STATr_LINK_STAT_MODf_GET
#define CMIC_IRQ_STATr_LINK_STAT_MODf_SET BCM56504_A0_CMIC_IRQ_STATr_LINK_STAT_MODf_SET
#define CMIC_IRQ_STATr_L2_MOD_FIFO_NOT_EMPTYf_GET BCM56504_A0_CMIC_IRQ_STATr_L2_MOD_FIFO_NOT_EMPTYf_GET
#define CMIC_IRQ_STATr_L2_MOD_FIFO_NOT_EMPTYf_SET BCM56504_A0_CMIC_IRQ_STATr_L2_MOD_FIFO_NOT_EMPTYf_SET
#define CMIC_IRQ_STATr_RESERVED_2f_GET BCM56504_A0_CMIC_IRQ_STATr_RESERVED_2f_GET
#define CMIC_IRQ_STATr_RESERVED_2f_SET BCM56504_A0_CMIC_IRQ_STATr_RESERVED_2f_SET
#define CMIC_IRQ_STATr_CH0_DESC_DONEf_GET BCM56504_A0_CMIC_IRQ_STATr_CH0_DESC_DONEf_GET
#define CMIC_IRQ_STATr_CH0_DESC_DONEf_SET BCM56504_A0_CMIC_IRQ_STATr_CH0_DESC_DONEf_SET
#define CMIC_IRQ_STATr_CH0_CHAIN_DONEf_GET BCM56504_A0_CMIC_IRQ_STATr_CH0_CHAIN_DONEf_GET
#define CMIC_IRQ_STATr_CH0_CHAIN_DONEf_SET BCM56504_A0_CMIC_IRQ_STATr_CH0_CHAIN_DONEf_SET
#define CMIC_IRQ_STATr_CH1_DESC_DONEf_GET BCM56504_A0_CMIC_IRQ_STATr_CH1_DESC_DONEf_GET
#define CMIC_IRQ_STATr_CH1_DESC_DONEf_SET BCM56504_A0_CMIC_IRQ_STATr_CH1_DESC_DONEf_SET
#define CMIC_IRQ_STATr_CH1_CHAIN_DONEf_GET BCM56504_A0_CMIC_IRQ_STATr_CH1_CHAIN_DONEf_GET
#define CMIC_IRQ_STATr_CH1_CHAIN_DONEf_SET BCM56504_A0_CMIC_IRQ_STATr_CH1_CHAIN_DONEf_SET
#define CMIC_IRQ_STATr_CH2_DESC_DONEf_GET BCM56504_A0_CMIC_IRQ_STATr_CH2_DESC_DONEf_GET
#define CMIC_IRQ_STATr_CH2_DESC_DONEf_SET BCM56504_A0_CMIC_IRQ_STATr_CH2_DESC_DONEf_SET
#define CMIC_IRQ_STATr_CH2_CHAIN_DONEf_GET BCM56504_A0_CMIC_IRQ_STATr_CH2_CHAIN_DONEf_GET
#define CMIC_IRQ_STATr_CH2_CHAIN_DONEf_SET BCM56504_A0_CMIC_IRQ_STATr_CH2_CHAIN_DONEf_SET
#define CMIC_IRQ_STATr_CH3_DESC_DONEf_GET BCM56504_A0_CMIC_IRQ_STATr_CH3_DESC_DONEf_GET
#define CMIC_IRQ_STATr_CH3_DESC_DONEf_SET BCM56504_A0_CMIC_IRQ_STATr_CH3_DESC_DONEf_SET
#define CMIC_IRQ_STATr_CH3_CHAIN_DONEf_GET BCM56504_A0_CMIC_IRQ_STATr_CH3_CHAIN_DONEf_GET
#define CMIC_IRQ_STATr_CH3_CHAIN_DONEf_SET BCM56504_A0_CMIC_IRQ_STATr_CH3_CHAIN_DONEf_SET
#define CMIC_IRQ_STATr_PCI_PARITY_ERRf_GET BCM56504_A0_CMIC_IRQ_STATr_PCI_PARITY_ERRf_GET
#define CMIC_IRQ_STATr_PCI_PARITY_ERRf_SET BCM56504_A0_CMIC_IRQ_STATr_PCI_PARITY_ERRf_SET
#define CMIC_IRQ_STATr_PCI_FATAL_ERRf_GET BCM56504_A0_CMIC_IRQ_STATr_PCI_FATAL_ERRf_GET
#define CMIC_IRQ_STATr_PCI_FATAL_ERRf_SET BCM56504_A0_CMIC_IRQ_STATr_PCI_FATAL_ERRf_SET
#define CMIC_IRQ_STATr_SCHAN_ERRf_GET BCM56504_A0_CMIC_IRQ_STATr_SCHAN_ERRf_GET
#define CMIC_IRQ_STATr_SCHAN_ERRf_SET BCM56504_A0_CMIC_IRQ_STATr_SCHAN_ERRf_SET
#define CMIC_IRQ_STATr_I2C_INTRf_GET BCM56504_A0_CMIC_IRQ_STATr_I2C_INTRf_GET
#define CMIC_IRQ_STATr_I2C_INTRf_SET BCM56504_A0_CMIC_IRQ_STATr_I2C_INTRf_SET
#define CMIC_IRQ_STATr_MIIM_OP_DONEf_GET BCM56504_A0_CMIC_IRQ_STATr_MIIM_OP_DONEf_GET
#define CMIC_IRQ_STATr_MIIM_OP_DONEf_SET BCM56504_A0_CMIC_IRQ_STATr_MIIM_OP_DONEf_SET
#define CMIC_IRQ_STATr_STAT_DMA_DONEf_GET BCM56504_A0_CMIC_IRQ_STATr_STAT_DMA_DONEf_GET
#define CMIC_IRQ_STATr_STAT_DMA_DONEf_SET BCM56504_A0_CMIC_IRQ_STATr_STAT_DMA_DONEf_SET
#define CMIC_IRQ_STATr_RESERVED_3f_GET BCM56504_A0_CMIC_IRQ_STATr_RESERVED_3f_GET
#define CMIC_IRQ_STATr_RESERVED_3f_SET BCM56504_A0_CMIC_IRQ_STATr_RESERVED_3f_SET
#define CMIC_IRQ_STATr_BSE_CMDMEM_DONEf_GET BCM56504_A0_CMIC_IRQ_STATr_BSE_CMDMEM_DONEf_GET
#define CMIC_IRQ_STATr_BSE_CMDMEM_DONEf_SET BCM56504_A0_CMIC_IRQ_STATr_BSE_CMDMEM_DONEf_SET
#define CMIC_IRQ_STATr_CSE_CMDMEM_DONEf_GET BCM56504_A0_CMIC_IRQ_STATr_CSE_CMDMEM_DONEf_GET
#define CMIC_IRQ_STATr_CSE_CMDMEM_DONEf_SET BCM56504_A0_CMIC_IRQ_STATr_CSE_CMDMEM_DONEf_SET
#define CMIC_IRQ_STATr_HSE_CMDMEM_DONEf_GET BCM56504_A0_CMIC_IRQ_STATr_HSE_CMDMEM_DONEf_GET
#define CMIC_IRQ_STATr_HSE_CMDMEM_DONEf_SET BCM56504_A0_CMIC_IRQ_STATr_HSE_CMDMEM_DONEf_SET
#define CMIC_IRQ_STATr_MEM_FAILf_GET BCM56504_A0_CMIC_IRQ_STATr_MEM_FAILf_GET
#define CMIC_IRQ_STATr_MEM_FAILf_SET BCM56504_A0_CMIC_IRQ_STATr_MEM_FAILf_SET
#define CMIC_IRQ_STATr_TABLE_DMA_COMPLETEf_GET BCM56504_A0_CMIC_IRQ_STATr_TABLE_DMA_COMPLETEf_GET
#define CMIC_IRQ_STATr_TABLE_DMA_COMPLETEf_SET BCM56504_A0_CMIC_IRQ_STATr_TABLE_DMA_COMPLETEf_SET
#define CMIC_IRQ_STATr_SLAM_DMA_COMPLETEf_GET BCM56504_A0_CMIC_IRQ_STATr_SLAM_DMA_COMPLETEf_GET
#define CMIC_IRQ_STATr_SLAM_DMA_COMPLETEf_SET BCM56504_A0_CMIC_IRQ_STATr_SLAM_DMA_COMPLETEf_SET
#define CMIC_IRQ_STATr_BSAFE_OP_DONEf_GET BCM56504_A0_CMIC_IRQ_STATr_BSAFE_OP_DONEf_GET
#define CMIC_IRQ_STATr_BSAFE_OP_DONEf_SET BCM56504_A0_CMIC_IRQ_STATr_BSAFE_OP_DONEf_SET
#define READ_CMIC_IRQ_STATr BCM56504_A0_READ_CMIC_IRQ_STATr
#define WRITE_CMIC_IRQ_STATr BCM56504_A0_WRITE_CMIC_IRQ_STATr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_IRQ_STATr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_LEDUP_CTRL
 * BLOCKS:   CMIC
 * DESC:     LEDUP Control
 * SIZE:     32
 * FIELDS:
 *     LEDUP_EN         LEDUP Enable
 *     LEDUP_SKIP_SCAN_OUT If set, skip Data Scan-out step
 *     LEDUP_SKIP_PROCESSOR If set, skip LED Processor run
 *     LEDUP_SKIP_SCAN_IN If set, skip MAC Data Scan-in step
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_LEDUP_CTRLr 0x00001000

#define BCM56504_A0_CMIC_LEDUP_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_LEDUP_CTRL.
 *
 */
typedef union BCM56504_A0_CMIC_LEDUP_CTRLr_s {
	uint32_t v[1];
	uint32_t cmic_ledup_ctrl[1];
	uint32_t _cmic_ledup_ctrl;
} BCM56504_A0_CMIC_LEDUP_CTRLr_t;

#define BCM56504_A0_CMIC_LEDUP_CTRLr_CLR(r) (r).cmic_ledup_ctrl[0] = 0
#define BCM56504_A0_CMIC_LEDUP_CTRLr_SET(r,d) (r).cmic_ledup_ctrl[0] = d
#define BCM56504_A0_CMIC_LEDUP_CTRLr_GET(r) (r).cmic_ledup_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_LEDUP_CTRLr_LEDUP_ENf_GET(r) (((r).cmic_ledup_ctrl[0]) & 0x1)
#define BCM56504_A0_CMIC_LEDUP_CTRLr_LEDUP_ENf_SET(r,f) (r).cmic_ledup_ctrl[0]=(((r).cmic_ledup_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_CMIC_LEDUP_CTRLr_LEDUP_SKIP_SCAN_OUTf_GET(r) ((((r).cmic_ledup_ctrl[0]) >> 1) & 0x1)
#define BCM56504_A0_CMIC_LEDUP_CTRLr_LEDUP_SKIP_SCAN_OUTf_SET(r,f) (r).cmic_ledup_ctrl[0]=(((r).cmic_ledup_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_CMIC_LEDUP_CTRLr_LEDUP_SKIP_PROCESSORf_GET(r) ((((r).cmic_ledup_ctrl[0]) >> 2) & 0x1)
#define BCM56504_A0_CMIC_LEDUP_CTRLr_LEDUP_SKIP_PROCESSORf_SET(r,f) (r).cmic_ledup_ctrl[0]=(((r).cmic_ledup_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_CMIC_LEDUP_CTRLr_LEDUP_SKIP_SCAN_INf_GET(r) ((((r).cmic_ledup_ctrl[0]) >> 3) & 0x1)
#define BCM56504_A0_CMIC_LEDUP_CTRLr_LEDUP_SKIP_SCAN_INf_SET(r,f) (r).cmic_ledup_ctrl[0]=(((r).cmic_ledup_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))

/*
 * These macros can be used to access CMIC_LEDUP_CTRL.
 *
 */
#define BCM56504_A0_READ_CMIC_LEDUP_CTRLr(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_LEDUP_CTRLr,r._cmic_ledup_ctrl)
#define BCM56504_A0_WRITE_CMIC_LEDUP_CTRLr(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_LEDUP_CTRLr,r._cmic_ledup_ctrl)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_LEDUP_CTRLr BCM56504_A0_CMIC_LEDUP_CTRLr
#define CMIC_LEDUP_CTRLr_SIZE BCM56504_A0_CMIC_LEDUP_CTRLr_SIZE
typedef BCM56504_A0_CMIC_LEDUP_CTRLr_t CMIC_LEDUP_CTRLr_t;
#define CMIC_LEDUP_CTRLr_CLR BCM56504_A0_CMIC_LEDUP_CTRLr_CLR
#define CMIC_LEDUP_CTRLr_SET BCM56504_A0_CMIC_LEDUP_CTRLr_SET
#define CMIC_LEDUP_CTRLr_GET BCM56504_A0_CMIC_LEDUP_CTRLr_GET
#define CMIC_LEDUP_CTRLr_LEDUP_ENf_GET BCM56504_A0_CMIC_LEDUP_CTRLr_LEDUP_ENf_GET
#define CMIC_LEDUP_CTRLr_LEDUP_ENf_SET BCM56504_A0_CMIC_LEDUP_CTRLr_LEDUP_ENf_SET
#define CMIC_LEDUP_CTRLr_LEDUP_SKIP_SCAN_OUTf_GET BCM56504_A0_CMIC_LEDUP_CTRLr_LEDUP_SKIP_SCAN_OUTf_GET
#define CMIC_LEDUP_CTRLr_LEDUP_SKIP_SCAN_OUTf_SET BCM56504_A0_CMIC_LEDUP_CTRLr_LEDUP_SKIP_SCAN_OUTf_SET
#define CMIC_LEDUP_CTRLr_LEDUP_SKIP_PROCESSORf_GET BCM56504_A0_CMIC_LEDUP_CTRLr_LEDUP_SKIP_PROCESSORf_GET
#define CMIC_LEDUP_CTRLr_LEDUP_SKIP_PROCESSORf_SET BCM56504_A0_CMIC_LEDUP_CTRLr_LEDUP_SKIP_PROCESSORf_SET
#define CMIC_LEDUP_CTRLr_LEDUP_SKIP_SCAN_INf_GET BCM56504_A0_CMIC_LEDUP_CTRLr_LEDUP_SKIP_SCAN_INf_GET
#define CMIC_LEDUP_CTRLr_LEDUP_SKIP_SCAN_INf_SET BCM56504_A0_CMIC_LEDUP_CTRLr_LEDUP_SKIP_SCAN_INf_SET
#define READ_CMIC_LEDUP_CTRLr BCM56504_A0_READ_CMIC_LEDUP_CTRLr
#define WRITE_CMIC_LEDUP_CTRLr BCM56504_A0_WRITE_CMIC_LEDUP_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_LEDUP_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_LEDUP_DATA_RAM
 * BLOCKS:   CMIC
 * DESC:     LEDUP Data RAM
 * SIZE:     32
 * FIELDS:
 *     DATA             LEDUP DATA RAM data (Rd/Wr) word
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_LEDUP_DATA_RAMr 0x00001c00

#define BCM56504_A0_CMIC_LEDUP_DATA_RAMr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_LEDUP_DATA_RAM.
 *
 */
typedef union BCM56504_A0_CMIC_LEDUP_DATA_RAMr_s {
	uint32_t v[1];
	uint32_t cmic_ledup_data_ram[1];
	uint32_t _cmic_ledup_data_ram;
} BCM56504_A0_CMIC_LEDUP_DATA_RAMr_t;

#define BCM56504_A0_CMIC_LEDUP_DATA_RAMr_CLR(r) (r).cmic_ledup_data_ram[0] = 0
#define BCM56504_A0_CMIC_LEDUP_DATA_RAMr_SET(r,d) (r).cmic_ledup_data_ram[0] = d
#define BCM56504_A0_CMIC_LEDUP_DATA_RAMr_GET(r) (r).cmic_ledup_data_ram[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_LEDUP_DATA_RAMr_DATAf_GET(r) (((r).cmic_ledup_data_ram[0]) & 0xff)
#define BCM56504_A0_CMIC_LEDUP_DATA_RAMr_DATAf_SET(r,f) (r).cmic_ledup_data_ram[0]=(((r).cmic_ledup_data_ram[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access CMIC_LEDUP_DATA_RAM.
 *
 */
#define BCM56504_A0_READ_CMIC_LEDUP_DATA_RAMr(u,i,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_LEDUP_DATA_RAMr+(4*(i)),r._cmic_ledup_data_ram)
#define BCM56504_A0_WRITE_CMIC_LEDUP_DATA_RAMr(u,i,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_LEDUP_DATA_RAMr+(4*(i)),r._cmic_ledup_data_ram)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_LEDUP_DATA_RAMr BCM56504_A0_CMIC_LEDUP_DATA_RAMr
#define CMIC_LEDUP_DATA_RAMr_SIZE BCM56504_A0_CMIC_LEDUP_DATA_RAMr_SIZE
typedef BCM56504_A0_CMIC_LEDUP_DATA_RAMr_t CMIC_LEDUP_DATA_RAMr_t;
#define CMIC_LEDUP_DATA_RAMr_CLR BCM56504_A0_CMIC_LEDUP_DATA_RAMr_CLR
#define CMIC_LEDUP_DATA_RAMr_SET BCM56504_A0_CMIC_LEDUP_DATA_RAMr_SET
#define CMIC_LEDUP_DATA_RAMr_GET BCM56504_A0_CMIC_LEDUP_DATA_RAMr_GET
#define CMIC_LEDUP_DATA_RAMr_DATAf_GET BCM56504_A0_CMIC_LEDUP_DATA_RAMr_DATAf_GET
#define CMIC_LEDUP_DATA_RAMr_DATAf_SET BCM56504_A0_CMIC_LEDUP_DATA_RAMr_DATAf_SET
#define READ_CMIC_LEDUP_DATA_RAMr BCM56504_A0_READ_CMIC_LEDUP_DATA_RAMr
#define WRITE_CMIC_LEDUP_DATA_RAMr BCM56504_A0_WRITE_CMIC_LEDUP_DATA_RAMr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_LEDUP_DATA_RAMr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_LEDUP_PROGRAM_RAM
 * BLOCKS:   CMIC
 * DESC:     LEDUP Program RAM
 * SIZE:     32
 * FIELDS:
 *     DATA             LEDUP PROGRAM RAM data (Rd/Wr) word
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_LEDUP_PROGRAM_RAMr 0x00001800

#define BCM56504_A0_CMIC_LEDUP_PROGRAM_RAMr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_LEDUP_PROGRAM_RAM.
 *
 */
typedef union BCM56504_A0_CMIC_LEDUP_PROGRAM_RAMr_s {
	uint32_t v[1];
	uint32_t cmic_ledup_program_ram[1];
	uint32_t _cmic_ledup_program_ram;
} BCM56504_A0_CMIC_LEDUP_PROGRAM_RAMr_t;

#define BCM56504_A0_CMIC_LEDUP_PROGRAM_RAMr_CLR(r) (r).cmic_ledup_program_ram[0] = 0
#define BCM56504_A0_CMIC_LEDUP_PROGRAM_RAMr_SET(r,d) (r).cmic_ledup_program_ram[0] = d
#define BCM56504_A0_CMIC_LEDUP_PROGRAM_RAMr_GET(r) (r).cmic_ledup_program_ram[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_LEDUP_PROGRAM_RAMr_DATAf_GET(r) (((r).cmic_ledup_program_ram[0]) & 0xff)
#define BCM56504_A0_CMIC_LEDUP_PROGRAM_RAMr_DATAf_SET(r,f) (r).cmic_ledup_program_ram[0]=(((r).cmic_ledup_program_ram[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access CMIC_LEDUP_PROGRAM_RAM.
 *
 */
#define BCM56504_A0_READ_CMIC_LEDUP_PROGRAM_RAMr(u,i,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_LEDUP_PROGRAM_RAMr+(4*(i)),r._cmic_ledup_program_ram)
#define BCM56504_A0_WRITE_CMIC_LEDUP_PROGRAM_RAMr(u,i,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_LEDUP_PROGRAM_RAMr+(4*(i)),r._cmic_ledup_program_ram)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_LEDUP_PROGRAM_RAMr BCM56504_A0_CMIC_LEDUP_PROGRAM_RAMr
#define CMIC_LEDUP_PROGRAM_RAMr_SIZE BCM56504_A0_CMIC_LEDUP_PROGRAM_RAMr_SIZE
typedef BCM56504_A0_CMIC_LEDUP_PROGRAM_RAMr_t CMIC_LEDUP_PROGRAM_RAMr_t;
#define CMIC_LEDUP_PROGRAM_RAMr_CLR BCM56504_A0_CMIC_LEDUP_PROGRAM_RAMr_CLR
#define CMIC_LEDUP_PROGRAM_RAMr_SET BCM56504_A0_CMIC_LEDUP_PROGRAM_RAMr_SET
#define CMIC_LEDUP_PROGRAM_RAMr_GET BCM56504_A0_CMIC_LEDUP_PROGRAM_RAMr_GET
#define CMIC_LEDUP_PROGRAM_RAMr_DATAf_GET BCM56504_A0_CMIC_LEDUP_PROGRAM_RAMr_DATAf_GET
#define CMIC_LEDUP_PROGRAM_RAMr_DATAf_SET BCM56504_A0_CMIC_LEDUP_PROGRAM_RAMr_DATAf_SET
#define READ_CMIC_LEDUP_PROGRAM_RAMr BCM56504_A0_READ_CMIC_LEDUP_PROGRAM_RAMr
#define WRITE_CMIC_LEDUP_PROGRAM_RAMr BCM56504_A0_WRITE_CMIC_LEDUP_PROGRAM_RAMr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_LEDUP_PROGRAM_RAMr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_LEDUP_STATUS
 * BLOCKS:   CMIC
 * DESC:     LEDUP Status
 * SIZE:     32
 * FIELDS:
 *     PROGRAM_COUNTER  LEDUP Program Counter
 *     LEDUP_RUNNING    LEDUP Running
 *     LEDUP_INITIALISING LEDUP Initialising
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_LEDUP_STATUSr 0x00001004

#define BCM56504_A0_CMIC_LEDUP_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_LEDUP_STATUS.
 *
 */
typedef union BCM56504_A0_CMIC_LEDUP_STATUSr_s {
	uint32_t v[1];
	uint32_t cmic_ledup_status[1];
	uint32_t _cmic_ledup_status;
} BCM56504_A0_CMIC_LEDUP_STATUSr_t;

#define BCM56504_A0_CMIC_LEDUP_STATUSr_CLR(r) (r).cmic_ledup_status[0] = 0
#define BCM56504_A0_CMIC_LEDUP_STATUSr_SET(r,d) (r).cmic_ledup_status[0] = d
#define BCM56504_A0_CMIC_LEDUP_STATUSr_GET(r) (r).cmic_ledup_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_LEDUP_STATUSr_PROGRAM_COUNTERf_GET(r) (((r).cmic_ledup_status[0]) & 0xff)
#define BCM56504_A0_CMIC_LEDUP_STATUSr_PROGRAM_COUNTERf_SET(r,f) (r).cmic_ledup_status[0]=(((r).cmic_ledup_status[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56504_A0_CMIC_LEDUP_STATUSr_LEDUP_RUNNINGf_GET(r) ((((r).cmic_ledup_status[0]) >> 8) & 0x1)
#define BCM56504_A0_CMIC_LEDUP_STATUSr_LEDUP_RUNNINGf_SET(r,f) (r).cmic_ledup_status[0]=(((r).cmic_ledup_status[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56504_A0_CMIC_LEDUP_STATUSr_LEDUP_INITIALISINGf_GET(r) ((((r).cmic_ledup_status[0]) >> 9) & 0x1)
#define BCM56504_A0_CMIC_LEDUP_STATUSr_LEDUP_INITIALISINGf_SET(r,f) (r).cmic_ledup_status[0]=(((r).cmic_ledup_status[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))

/*
 * These macros can be used to access CMIC_LEDUP_STATUS.
 *
 */
#define BCM56504_A0_READ_CMIC_LEDUP_STATUSr(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_LEDUP_STATUSr,r._cmic_ledup_status)
#define BCM56504_A0_WRITE_CMIC_LEDUP_STATUSr(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_LEDUP_STATUSr,r._cmic_ledup_status)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_LEDUP_STATUSr BCM56504_A0_CMIC_LEDUP_STATUSr
#define CMIC_LEDUP_STATUSr_SIZE BCM56504_A0_CMIC_LEDUP_STATUSr_SIZE
typedef BCM56504_A0_CMIC_LEDUP_STATUSr_t CMIC_LEDUP_STATUSr_t;
#define CMIC_LEDUP_STATUSr_CLR BCM56504_A0_CMIC_LEDUP_STATUSr_CLR
#define CMIC_LEDUP_STATUSr_SET BCM56504_A0_CMIC_LEDUP_STATUSr_SET
#define CMIC_LEDUP_STATUSr_GET BCM56504_A0_CMIC_LEDUP_STATUSr_GET
#define CMIC_LEDUP_STATUSr_PROGRAM_COUNTERf_GET BCM56504_A0_CMIC_LEDUP_STATUSr_PROGRAM_COUNTERf_GET
#define CMIC_LEDUP_STATUSr_PROGRAM_COUNTERf_SET BCM56504_A0_CMIC_LEDUP_STATUSr_PROGRAM_COUNTERf_SET
#define CMIC_LEDUP_STATUSr_LEDUP_RUNNINGf_GET BCM56504_A0_CMIC_LEDUP_STATUSr_LEDUP_RUNNINGf_GET
#define CMIC_LEDUP_STATUSr_LEDUP_RUNNINGf_SET BCM56504_A0_CMIC_LEDUP_STATUSr_LEDUP_RUNNINGf_SET
#define CMIC_LEDUP_STATUSr_LEDUP_INITIALISINGf_GET BCM56504_A0_CMIC_LEDUP_STATUSr_LEDUP_INITIALISINGf_GET
#define CMIC_LEDUP_STATUSr_LEDUP_INITIALISINGf_SET BCM56504_A0_CMIC_LEDUP_STATUSr_LEDUP_INITIALISINGf_SET
#define READ_CMIC_LEDUP_STATUSr BCM56504_A0_READ_CMIC_LEDUP_STATUSr
#define WRITE_CMIC_LEDUP_STATUSr BCM56504_A0_WRITE_CMIC_LEDUP_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_LEDUP_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_LINK_STAT
 * BLOCKS:   CMIC
 * DESC:     Link Status Register
 * SIZE:     32
 * FIELDS:
 *     PORT_BITMAP      Link Up / Down Register
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_LINK_STATr 0x00000140

#define BCM56504_A0_CMIC_LINK_STATr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_LINK_STAT.
 *
 */
typedef union BCM56504_A0_CMIC_LINK_STATr_s {
	uint32_t v[1];
	uint32_t cmic_link_stat[1];
	uint32_t _cmic_link_stat;
} BCM56504_A0_CMIC_LINK_STATr_t;

#define BCM56504_A0_CMIC_LINK_STATr_CLR(r) (r).cmic_link_stat[0] = 0
#define BCM56504_A0_CMIC_LINK_STATr_SET(r,d) (r).cmic_link_stat[0] = d
#define BCM56504_A0_CMIC_LINK_STATr_GET(r) (r).cmic_link_stat[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_LINK_STATr_PORT_BITMAPf_GET(r) ((r).cmic_link_stat[0])
#define BCM56504_A0_CMIC_LINK_STATr_PORT_BITMAPf_SET(r,f) (r).cmic_link_stat[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_LINK_STAT.
 *
 */
#define BCM56504_A0_READ_CMIC_LINK_STATr(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_LINK_STATr,r._cmic_link_stat)
#define BCM56504_A0_WRITE_CMIC_LINK_STATr(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_LINK_STATr,r._cmic_link_stat)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_LINK_STATr BCM56504_A0_CMIC_LINK_STATr
#define CMIC_LINK_STATr_SIZE BCM56504_A0_CMIC_LINK_STATr_SIZE
typedef BCM56504_A0_CMIC_LINK_STATr_t CMIC_LINK_STATr_t;
#define CMIC_LINK_STATr_CLR BCM56504_A0_CMIC_LINK_STATr_CLR
#define CMIC_LINK_STATr_SET BCM56504_A0_CMIC_LINK_STATr_SET
#define CMIC_LINK_STATr_GET BCM56504_A0_CMIC_LINK_STATr_GET
#define CMIC_LINK_STATr_PORT_BITMAPf_GET BCM56504_A0_CMIC_LINK_STATr_PORT_BITMAPf_GET
#define CMIC_LINK_STATr_PORT_BITMAPf_SET BCM56504_A0_CMIC_LINK_STATr_PORT_BITMAPf_SET
#define READ_CMIC_LINK_STATr BCM56504_A0_READ_CMIC_LINK_STATr
#define WRITE_CMIC_LINK_STATr BCM56504_A0_WRITE_CMIC_LINK_STATr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_LINK_STATr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_MIIM_ADDRESS
 * BLOCKS:   CMIC
 * DESC:     Supplies the register address of MIIM reads and writes.
For clause 22 devices, bits [4:0] supply the REGAD.
For clause 45 devices, bits [20:16] supply the DTYPE,
                   and bits [15: 0] supply the reg address

 * SIZE:     32
 * FIELDS:
 *     CLAUSE_22_REGADR Register address for associated read or write
 *     RESERVED_1       Reserved
 *     CLAUSE_45_REGADR Register address for associated read or write
 *     CLAUSE_45_DTYPE  Block-within-PHY address for associated read or write
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_MIIM_ADDRESSr 0x000004a0

#define BCM56504_A0_CMIC_MIIM_ADDRESSr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_ADDRESS.
 *
 */
typedef union BCM56504_A0_CMIC_MIIM_ADDRESSr_s {
	uint32_t v[1];
	uint32_t cmic_miim_address[1];
	uint32_t _cmic_miim_address;
} BCM56504_A0_CMIC_MIIM_ADDRESSr_t;

#define BCM56504_A0_CMIC_MIIM_ADDRESSr_CLR(r) (r).cmic_miim_address[0] = 0
#define BCM56504_A0_CMIC_MIIM_ADDRESSr_SET(r,d) (r).cmic_miim_address[0] = d
#define BCM56504_A0_CMIC_MIIM_ADDRESSr_GET(r) (r).cmic_miim_address[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_MIIM_ADDRESSr_CLAUSE_22_REGADRf_GET(r) (((r).cmic_miim_address[0]) & 0x1f)
#define BCM56504_A0_CMIC_MIIM_ADDRESSr_CLAUSE_22_REGADRf_SET(r,f) (r).cmic_miim_address[0]=(((r).cmic_miim_address[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56504_A0_CMIC_MIIM_ADDRESSr_RESERVED_1f_GET(r) ((((r).cmic_miim_address[0]) >> 21) & 0x7ff)
#define BCM56504_A0_CMIC_MIIM_ADDRESSr_RESERVED_1f_SET(r,f) (r).cmic_miim_address[0]=(((r).cmic_miim_address[0] & ~((uint32_t)0x7ff << 21)) | ((((uint32_t)f) & 0x7ff) << 21))
#define BCM56504_A0_CMIC_MIIM_ADDRESSr_CLAUSE_45_REGADRf_GET(r) (((r).cmic_miim_address[0]) & 0xffff)
#define BCM56504_A0_CMIC_MIIM_ADDRESSr_CLAUSE_45_REGADRf_SET(r,f) (r).cmic_miim_address[0]=(((r).cmic_miim_address[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56504_A0_CMIC_MIIM_ADDRESSr_CLAUSE_45_DTYPEf_GET(r) ((((r).cmic_miim_address[0]) >> 16) & 0x1f)
#define BCM56504_A0_CMIC_MIIM_ADDRESSr_CLAUSE_45_DTYPEf_SET(r,f) (r).cmic_miim_address[0]=(((r).cmic_miim_address[0] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))

/*
 * These macros can be used to access CMIC_MIIM_ADDRESS.
 *
 */
#define BCM56504_A0_READ_CMIC_MIIM_ADDRESSr(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_MIIM_ADDRESSr,r._cmic_miim_address)
#define BCM56504_A0_WRITE_CMIC_MIIM_ADDRESSr(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_MIIM_ADDRESSr,r._cmic_miim_address)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_ADDRESSr BCM56504_A0_CMIC_MIIM_ADDRESSr
#define CMIC_MIIM_ADDRESSr_SIZE BCM56504_A0_CMIC_MIIM_ADDRESSr_SIZE
typedef BCM56504_A0_CMIC_MIIM_ADDRESSr_t CMIC_MIIM_ADDRESSr_t;
#define CMIC_MIIM_ADDRESSr_CLR BCM56504_A0_CMIC_MIIM_ADDRESSr_CLR
#define CMIC_MIIM_ADDRESSr_SET BCM56504_A0_CMIC_MIIM_ADDRESSr_SET
#define CMIC_MIIM_ADDRESSr_GET BCM56504_A0_CMIC_MIIM_ADDRESSr_GET
#define CMIC_MIIM_ADDRESSr_CLAUSE_22_REGADRf_GET BCM56504_A0_CMIC_MIIM_ADDRESSr_CLAUSE_22_REGADRf_GET
#define CMIC_MIIM_ADDRESSr_CLAUSE_22_REGADRf_SET BCM56504_A0_CMIC_MIIM_ADDRESSr_CLAUSE_22_REGADRf_SET
#define CMIC_MIIM_ADDRESSr_RESERVED_1f_GET BCM56504_A0_CMIC_MIIM_ADDRESSr_RESERVED_1f_GET
#define CMIC_MIIM_ADDRESSr_RESERVED_1f_SET BCM56504_A0_CMIC_MIIM_ADDRESSr_RESERVED_1f_SET
#define CMIC_MIIM_ADDRESSr_CLAUSE_45_REGADRf_GET BCM56504_A0_CMIC_MIIM_ADDRESSr_CLAUSE_45_REGADRf_GET
#define CMIC_MIIM_ADDRESSr_CLAUSE_45_REGADRf_SET BCM56504_A0_CMIC_MIIM_ADDRESSr_CLAUSE_45_REGADRf_SET
#define CMIC_MIIM_ADDRESSr_CLAUSE_45_DTYPEf_GET BCM56504_A0_CMIC_MIIM_ADDRESSr_CLAUSE_45_DTYPEf_GET
#define CMIC_MIIM_ADDRESSr_CLAUSE_45_DTYPEf_SET BCM56504_A0_CMIC_MIIM_ADDRESSr_CLAUSE_45_DTYPEf_SET
#define READ_CMIC_MIIM_ADDRESSr BCM56504_A0_READ_CMIC_MIIM_ADDRESSr
#define WRITE_CMIC_MIIM_ADDRESSr BCM56504_A0_WRITE_CMIC_MIIM_ADDRESSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_MIIM_ADDRESSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8
 * BLOCKS:   CMIC
 * DESC:     MIIM Phy Address map, Port 11:8
 * SIZE:     32
 * FIELDS:
 *     PHY_ID_8         Phy ID of external phy for Port 8
 *     RESERVED_0       Reserved
 *     PHY_ID_9         Phy ID of external phy for Port 9
 *     RESERVED_1       Reserved
 *     PHY_ID_10        Phy ID of external phy for Port 10
 *     RESERVED_2       Reserved
 *     PHY_ID_11        Phy ID of external phy for Port 11
 *     RESERVED_3       Reserved
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r 0x000004c8

#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8.
 *
 */
typedef union BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_s {
	uint32_t v[1];
	uint32_t cmic_miim_ext_phy_addr_map_11_8[1];
	uint32_t _cmic_miim_ext_phy_addr_map_11_8;
} BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_t;

#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_CLR(r) (r).cmic_miim_ext_phy_addr_map_11_8[0] = 0
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_SET(r,d) (r).cmic_miim_ext_phy_addr_map_11_8[0] = d
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_GET(r) (r).cmic_miim_ext_phy_addr_map_11_8[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_8f_GET(r) (((r).cmic_miim_ext_phy_addr_map_11_8[0]) & 0x1f)
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_8f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_11_8[0]=(((r).cmic_miim_ext_phy_addr_map_11_8[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_RESERVED_0f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_11_8[0]) >> 5) & 0x7)
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_RESERVED_0f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_11_8[0]=(((r).cmic_miim_ext_phy_addr_map_11_8[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_9f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_11_8[0]) >> 8) & 0x1f)
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_9f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_11_8[0]=(((r).cmic_miim_ext_phy_addr_map_11_8[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_RESERVED_1f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_11_8[0]) >> 13) & 0x7)
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_RESERVED_1f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_11_8[0]=(((r).cmic_miim_ext_phy_addr_map_11_8[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_10f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_11_8[0]) >> 16) & 0x1f)
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_10f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_11_8[0]=(((r).cmic_miim_ext_phy_addr_map_11_8[0] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_RESERVED_2f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_11_8[0]) >> 21) & 0x7)
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_RESERVED_2f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_11_8[0]=(((r).cmic_miim_ext_phy_addr_map_11_8[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_11f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_11_8[0]) >> 24) & 0x1f)
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_11f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_11_8[0]=(((r).cmic_miim_ext_phy_addr_map_11_8[0] & ~((uint32_t)0x1f << 24)) | ((((uint32_t)f) & 0x1f) << 24))
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_RESERVED_3f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_11_8[0]) >> 29) & 0x7)
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_RESERVED_3f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_11_8[0]=(((r).cmic_miim_ext_phy_addr_map_11_8[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8.
 *
 */
#define BCM56504_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r,r._cmic_miim_ext_phy_addr_map_11_8)
#define BCM56504_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r,r._cmic_miim_ext_phy_addr_map_11_8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_SIZE BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_SIZE
typedef BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_t CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_t;
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_CLR BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_CLR
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_8f_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_8f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_8f_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_8f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_RESERVED_0f_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_RESERVED_0f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_RESERVED_0f_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_RESERVED_0f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_9f_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_9f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_9f_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_9f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_RESERVED_1f_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_RESERVED_1f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_RESERVED_1f_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_RESERVED_1f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_10f_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_10f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_10f_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_10f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_RESERVED_2f_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_RESERVED_2f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_RESERVED_2f_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_RESERVED_2f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_11f_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_11f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_11f_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_11f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_RESERVED_3f_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_RESERVED_3f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_RESERVED_3f_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_RESERVED_3f_SET
#define READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r BCM56504_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r
#define WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r BCM56504_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12
 * BLOCKS:   CMIC
 * DESC:     MIIM Phy Address map, Port 15:12
 * SIZE:     32
 * FIELDS:
 *     PHY_ID_12        Phy ID of external phy for Port 12
 *     RESERVED_0       Reserved
 *     PHY_ID_13        Phy ID of external phy for Port 13
 *     RESERVED_1       Reserved
 *     PHY_ID_14        Phy ID of external phy for Port 14
 *     RESERVED_2       Reserved
 *     PHY_ID_15        Phy ID of external phy for Port 15
 *     RESERVED_3       Reserved
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r 0x000004cc

#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12.
 *
 */
typedef union BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_s {
	uint32_t v[1];
	uint32_t cmic_miim_ext_phy_addr_map_15_12[1];
	uint32_t _cmic_miim_ext_phy_addr_map_15_12;
} BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_t;

#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_CLR(r) (r).cmic_miim_ext_phy_addr_map_15_12[0] = 0
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_SET(r,d) (r).cmic_miim_ext_phy_addr_map_15_12[0] = d
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_GET(r) (r).cmic_miim_ext_phy_addr_map_15_12[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_12f_GET(r) (((r).cmic_miim_ext_phy_addr_map_15_12[0]) & 0x1f)
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_12f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_15_12[0]=(((r).cmic_miim_ext_phy_addr_map_15_12[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_RESERVED_0f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_15_12[0]) >> 5) & 0x7)
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_RESERVED_0f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_15_12[0]=(((r).cmic_miim_ext_phy_addr_map_15_12[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_13f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_15_12[0]) >> 8) & 0x1f)
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_13f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_15_12[0]=(((r).cmic_miim_ext_phy_addr_map_15_12[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_RESERVED_1f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_15_12[0]) >> 13) & 0x7)
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_RESERVED_1f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_15_12[0]=(((r).cmic_miim_ext_phy_addr_map_15_12[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_14f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_15_12[0]) >> 16) & 0x1f)
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_14f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_15_12[0]=(((r).cmic_miim_ext_phy_addr_map_15_12[0] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_RESERVED_2f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_15_12[0]) >> 21) & 0x7)
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_RESERVED_2f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_15_12[0]=(((r).cmic_miim_ext_phy_addr_map_15_12[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_15f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_15_12[0]) >> 24) & 0x1f)
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_15f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_15_12[0]=(((r).cmic_miim_ext_phy_addr_map_15_12[0] & ~((uint32_t)0x1f << 24)) | ((((uint32_t)f) & 0x1f) << 24))
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_RESERVED_3f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_15_12[0]) >> 29) & 0x7)
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_RESERVED_3f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_15_12[0]=(((r).cmic_miim_ext_phy_addr_map_15_12[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12.
 *
 */
#define BCM56504_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r,r._cmic_miim_ext_phy_addr_map_15_12)
#define BCM56504_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r,r._cmic_miim_ext_phy_addr_map_15_12)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_SIZE BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_SIZE
typedef BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_t CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_t;
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_CLR BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_CLR
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_12f_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_12f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_12f_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_12f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_RESERVED_0f_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_RESERVED_0f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_RESERVED_0f_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_RESERVED_0f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_13f_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_13f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_13f_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_13f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_RESERVED_1f_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_RESERVED_1f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_RESERVED_1f_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_RESERVED_1f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_14f_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_14f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_14f_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_14f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_RESERVED_2f_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_RESERVED_2f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_RESERVED_2f_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_RESERVED_2f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_15f_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_15f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_15f_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_15f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_RESERVED_3f_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_RESERVED_3f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_RESERVED_3f_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_RESERVED_3f_SET
#define READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r BCM56504_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r
#define WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r BCM56504_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16
 * BLOCKS:   CMIC
 * DESC:     MIIM Phy Address map, Port 19:16
 * SIZE:     32
 * FIELDS:
 *     PHY_ID_16        Phy ID of external phy for Port 16
 *     RESERVED_0       Reserved
 *     PHY_ID_17        Phy ID of external phy for Port 17
 *     RESERVED_1       Reserved
 *     PHY_ID_18        Phy ID of external phy for Port 18
 *     RESERVED_2       Reserved
 *     PHY_ID_19        Phy ID of external phy for Port 19
 *     RESERVED_3       Reserved
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r 0x000004d0

#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16.
 *
 */
typedef union BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_s {
	uint32_t v[1];
	uint32_t cmic_miim_ext_phy_addr_map_19_16[1];
	uint32_t _cmic_miim_ext_phy_addr_map_19_16;
} BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_t;

#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_CLR(r) (r).cmic_miim_ext_phy_addr_map_19_16[0] = 0
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_SET(r,d) (r).cmic_miim_ext_phy_addr_map_19_16[0] = d
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_GET(r) (r).cmic_miim_ext_phy_addr_map_19_16[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_16f_GET(r) (((r).cmic_miim_ext_phy_addr_map_19_16[0]) & 0x1f)
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_16f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_19_16[0]=(((r).cmic_miim_ext_phy_addr_map_19_16[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_RESERVED_0f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_19_16[0]) >> 5) & 0x7)
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_RESERVED_0f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_19_16[0]=(((r).cmic_miim_ext_phy_addr_map_19_16[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_17f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_19_16[0]) >> 8) & 0x1f)
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_17f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_19_16[0]=(((r).cmic_miim_ext_phy_addr_map_19_16[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_RESERVED_1f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_19_16[0]) >> 13) & 0x7)
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_RESERVED_1f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_19_16[0]=(((r).cmic_miim_ext_phy_addr_map_19_16[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_18f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_19_16[0]) >> 16) & 0x1f)
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_18f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_19_16[0]=(((r).cmic_miim_ext_phy_addr_map_19_16[0] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_RESERVED_2f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_19_16[0]) >> 21) & 0x7)
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_RESERVED_2f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_19_16[0]=(((r).cmic_miim_ext_phy_addr_map_19_16[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_19f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_19_16[0]) >> 24) & 0x1f)
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_19f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_19_16[0]=(((r).cmic_miim_ext_phy_addr_map_19_16[0] & ~((uint32_t)0x1f << 24)) | ((((uint32_t)f) & 0x1f) << 24))
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_RESERVED_3f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_19_16[0]) >> 29) & 0x7)
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_RESERVED_3f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_19_16[0]=(((r).cmic_miim_ext_phy_addr_map_19_16[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16.
 *
 */
#define BCM56504_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r,r._cmic_miim_ext_phy_addr_map_19_16)
#define BCM56504_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r,r._cmic_miim_ext_phy_addr_map_19_16)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_SIZE BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_SIZE
typedef BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_t CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_t;
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_CLR BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_CLR
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_16f_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_16f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_16f_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_16f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_RESERVED_0f_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_RESERVED_0f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_RESERVED_0f_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_RESERVED_0f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_17f_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_17f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_17f_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_17f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_RESERVED_1f_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_RESERVED_1f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_RESERVED_1f_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_RESERVED_1f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_18f_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_18f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_18f_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_18f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_RESERVED_2f_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_RESERVED_2f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_RESERVED_2f_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_RESERVED_2f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_19f_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_19f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_19f_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_19f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_RESERVED_3f_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_RESERVED_3f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_RESERVED_3f_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_RESERVED_3f_SET
#define READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r BCM56504_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r
#define WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r BCM56504_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20
 * BLOCKS:   CMIC
 * DESC:     MIIM Phy Address map, Port 23:20
 * SIZE:     32
 * FIELDS:
 *     PHY_ID_20        Phy ID of external phy for Port 20
 *     RESERVED_0       Reserved
 *     PHY_ID_21        Phy ID of external phy for Port 21
 *     RESERVED_1       Reserved
 *     PHY_ID_22        Phy ID of external phy for Port 22
 *     RESERVED_2       Reserved
 *     PHY_ID_23        Phy ID of external phy for Port 23
 *     RESERVED_3       Reserved
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r 0x000004d4

#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20.
 *
 */
typedef union BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_s {
	uint32_t v[1];
	uint32_t cmic_miim_ext_phy_addr_map_23_20[1];
	uint32_t _cmic_miim_ext_phy_addr_map_23_20;
} BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_t;

#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_CLR(r) (r).cmic_miim_ext_phy_addr_map_23_20[0] = 0
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_SET(r,d) (r).cmic_miim_ext_phy_addr_map_23_20[0] = d
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_GET(r) (r).cmic_miim_ext_phy_addr_map_23_20[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_20f_GET(r) (((r).cmic_miim_ext_phy_addr_map_23_20[0]) & 0x1f)
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_20f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_23_20[0]=(((r).cmic_miim_ext_phy_addr_map_23_20[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_RESERVED_0f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_23_20[0]) >> 5) & 0x7)
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_RESERVED_0f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_23_20[0]=(((r).cmic_miim_ext_phy_addr_map_23_20[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_21f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_23_20[0]) >> 8) & 0x1f)
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_21f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_23_20[0]=(((r).cmic_miim_ext_phy_addr_map_23_20[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_RESERVED_1f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_23_20[0]) >> 13) & 0x7)
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_RESERVED_1f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_23_20[0]=(((r).cmic_miim_ext_phy_addr_map_23_20[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_22f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_23_20[0]) >> 16) & 0x1f)
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_22f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_23_20[0]=(((r).cmic_miim_ext_phy_addr_map_23_20[0] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_RESERVED_2f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_23_20[0]) >> 21) & 0x7)
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_RESERVED_2f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_23_20[0]=(((r).cmic_miim_ext_phy_addr_map_23_20[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_23f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_23_20[0]) >> 24) & 0x1f)
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_23f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_23_20[0]=(((r).cmic_miim_ext_phy_addr_map_23_20[0] & ~((uint32_t)0x1f << 24)) | ((((uint32_t)f) & 0x1f) << 24))
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_RESERVED_3f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_23_20[0]) >> 29) & 0x7)
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_RESERVED_3f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_23_20[0]=(((r).cmic_miim_ext_phy_addr_map_23_20[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20.
 *
 */
#define BCM56504_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r,r._cmic_miim_ext_phy_addr_map_23_20)
#define BCM56504_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r,r._cmic_miim_ext_phy_addr_map_23_20)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_SIZE BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_SIZE
typedef BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_t CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_t;
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_CLR BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_CLR
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_20f_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_20f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_20f_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_20f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_RESERVED_0f_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_RESERVED_0f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_RESERVED_0f_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_RESERVED_0f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_21f_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_21f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_21f_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_21f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_RESERVED_1f_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_RESERVED_1f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_RESERVED_1f_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_RESERVED_1f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_22f_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_22f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_22f_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_22f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_RESERVED_2f_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_RESERVED_2f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_RESERVED_2f_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_RESERVED_2f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_23f_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_23f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_23f_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_23f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_RESERVED_3f_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_RESERVED_3f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_RESERVED_3f_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_RESERVED_3f_SET
#define READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r BCM56504_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r
#define WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r BCM56504_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24
 * BLOCKS:   CMIC
 * DESC:     MIIM Phy Address map, Port 27:24
 * SIZE:     32
 * FIELDS:
 *     PHY_ID_24        Phy ID of external phy for Port 24
 *     RESERVED_0       Reserved
 *     PHY_ID_25        Phy ID of external phy for Port 25
 *     RESERVED_1       Reserved
 *     PHY_ID_26        Phy ID of external phy for Port 26
 *     RESERVED_2       Reserved
 *     PHY_ID_27        Phy ID of external phy for Port 27
 *     RESERVED_3       Reserved
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r 0x000004d8

#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24.
 *
 */
typedef union BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_s {
	uint32_t v[1];
	uint32_t cmic_miim_ext_phy_addr_map_27_24[1];
	uint32_t _cmic_miim_ext_phy_addr_map_27_24;
} BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_t;

#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_CLR(r) (r).cmic_miim_ext_phy_addr_map_27_24[0] = 0
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_SET(r,d) (r).cmic_miim_ext_phy_addr_map_27_24[0] = d
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_GET(r) (r).cmic_miim_ext_phy_addr_map_27_24[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_24f_GET(r) (((r).cmic_miim_ext_phy_addr_map_27_24[0]) & 0x1f)
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_24f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_27_24[0]=(((r).cmic_miim_ext_phy_addr_map_27_24[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_RESERVED_0f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_27_24[0]) >> 5) & 0x7)
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_RESERVED_0f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_27_24[0]=(((r).cmic_miim_ext_phy_addr_map_27_24[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_25f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_27_24[0]) >> 8) & 0x1f)
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_25f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_27_24[0]=(((r).cmic_miim_ext_phy_addr_map_27_24[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_RESERVED_1f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_27_24[0]) >> 13) & 0x7)
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_RESERVED_1f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_27_24[0]=(((r).cmic_miim_ext_phy_addr_map_27_24[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_26f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_27_24[0]) >> 16) & 0x1f)
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_26f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_27_24[0]=(((r).cmic_miim_ext_phy_addr_map_27_24[0] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_RESERVED_2f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_27_24[0]) >> 21) & 0x7)
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_RESERVED_2f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_27_24[0]=(((r).cmic_miim_ext_phy_addr_map_27_24[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_27f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_27_24[0]) >> 24) & 0x1f)
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_27f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_27_24[0]=(((r).cmic_miim_ext_phy_addr_map_27_24[0] & ~((uint32_t)0x1f << 24)) | ((((uint32_t)f) & 0x1f) << 24))
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_RESERVED_3f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_27_24[0]) >> 29) & 0x7)
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_RESERVED_3f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_27_24[0]=(((r).cmic_miim_ext_phy_addr_map_27_24[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24.
 *
 */
#define BCM56504_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r,r._cmic_miim_ext_phy_addr_map_27_24)
#define BCM56504_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r,r._cmic_miim_ext_phy_addr_map_27_24)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_SIZE BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_SIZE
typedef BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_t CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_t;
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_CLR BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_CLR
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_24f_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_24f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_24f_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_24f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_RESERVED_0f_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_RESERVED_0f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_RESERVED_0f_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_RESERVED_0f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_25f_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_25f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_25f_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_25f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_RESERVED_1f_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_RESERVED_1f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_RESERVED_1f_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_RESERVED_1f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_26f_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_26f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_26f_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_26f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_RESERVED_2f_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_RESERVED_2f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_RESERVED_2f_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_RESERVED_2f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_27f_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_27f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_27f_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_27f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_RESERVED_3f_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_RESERVED_3f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_RESERVED_3f_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_RESERVED_3f_SET
#define READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r BCM56504_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r
#define WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r BCM56504_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28
 * BLOCKS:   CMIC
 * DESC:     MIIM Phy Address map, Port 31:28
 * SIZE:     32
 * FIELDS:
 *     PHY_ID_28        Phy ID of external phy for Port 28
 *     RESERVED_0       Reserved
 *     PHY_ID_29        Phy ID of external phy for Port 29
 *     RESERVED_1       Reserved
 *     PHY_ID_30        Phy ID of external phy for Port 30
 *     RESERVED_3       Reserved
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r 0x000004dc

#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28.
 *
 */
typedef union BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_s {
	uint32_t v[1];
	uint32_t cmic_miim_ext_phy_addr_map_31_28[1];
	uint32_t _cmic_miim_ext_phy_addr_map_31_28;
} BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_t;

#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_CLR(r) (r).cmic_miim_ext_phy_addr_map_31_28[0] = 0
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_SET(r,d) (r).cmic_miim_ext_phy_addr_map_31_28[0] = d
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_GET(r) (r).cmic_miim_ext_phy_addr_map_31_28[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_28f_GET(r) (((r).cmic_miim_ext_phy_addr_map_31_28[0]) & 0x1f)
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_28f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_31_28[0]=(((r).cmic_miim_ext_phy_addr_map_31_28[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_RESERVED_0f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_31_28[0]) >> 5) & 0x7)
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_RESERVED_0f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_31_28[0]=(((r).cmic_miim_ext_phy_addr_map_31_28[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_29f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_31_28[0]) >> 8) & 0x1f)
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_29f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_31_28[0]=(((r).cmic_miim_ext_phy_addr_map_31_28[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_RESERVED_1f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_31_28[0]) >> 13) & 0x7)
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_RESERVED_1f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_31_28[0]=(((r).cmic_miim_ext_phy_addr_map_31_28[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_30f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_31_28[0]) >> 16) & 0x1f)
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_30f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_31_28[0]=(((r).cmic_miim_ext_phy_addr_map_31_28[0] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_RESERVED_3f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_31_28[0]) >> 21) & 0x7ff)
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_RESERVED_3f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_31_28[0]=(((r).cmic_miim_ext_phy_addr_map_31_28[0] & ~((uint32_t)0x7ff << 21)) | ((((uint32_t)f) & 0x7ff) << 21))

/*
 * These macros can be used to access CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28.
 *
 */
#define BCM56504_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r,r._cmic_miim_ext_phy_addr_map_31_28)
#define BCM56504_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r,r._cmic_miim_ext_phy_addr_map_31_28)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_SIZE BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_SIZE
typedef BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_t CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_t;
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_CLR BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_CLR
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_28f_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_28f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_28f_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_28f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_RESERVED_0f_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_RESERVED_0f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_RESERVED_0f_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_RESERVED_0f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_29f_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_29f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_29f_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_29f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_RESERVED_1f_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_RESERVED_1f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_RESERVED_1f_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_RESERVED_1f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_30f_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_30f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_30f_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_30f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_RESERVED_3f_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_RESERVED_3f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_RESERVED_3f_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_RESERVED_3f_SET
#define READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r BCM56504_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r
#define WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r BCM56504_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0
 * BLOCKS:   CMIC
 * DESC:     MIIM Phy Address map, Port 3:0
 * SIZE:     32
 * FIELDS:
 *     PHY_ID_0         Phy ID of external phy for Port 0
 *     RESERVED_0       Reserved
 *     PHY_ID_1         Phy ID of external phy for Port 1
 *     RESERVED_1       Reserved
 *     PHY_ID_2         Phy ID of external phy for Port 2
 *     RESERVED_2       Reserved
 *     PHY_ID_3         Phy ID of external phy for Port 3
 *     RESERVED_3       Reserved
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r 0x000004c0

#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0.
 *
 */
typedef union BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_s {
	uint32_t v[1];
	uint32_t cmic_miim_ext_phy_addr_map_3_0[1];
	uint32_t _cmic_miim_ext_phy_addr_map_3_0;
} BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_t;

#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_CLR(r) (r).cmic_miim_ext_phy_addr_map_3_0[0] = 0
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_SET(r,d) (r).cmic_miim_ext_phy_addr_map_3_0[0] = d
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_GET(r) (r).cmic_miim_ext_phy_addr_map_3_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_0f_GET(r) (((r).cmic_miim_ext_phy_addr_map_3_0[0]) & 0x1f)
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_0f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_3_0[0]=(((r).cmic_miim_ext_phy_addr_map_3_0[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_RESERVED_0f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_3_0[0]) >> 5) & 0x7)
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_RESERVED_0f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_3_0[0]=(((r).cmic_miim_ext_phy_addr_map_3_0[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_1f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_3_0[0]) >> 8) & 0x1f)
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_1f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_3_0[0]=(((r).cmic_miim_ext_phy_addr_map_3_0[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_RESERVED_1f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_3_0[0]) >> 13) & 0x7)
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_RESERVED_1f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_3_0[0]=(((r).cmic_miim_ext_phy_addr_map_3_0[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_2f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_3_0[0]) >> 16) & 0x1f)
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_2f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_3_0[0]=(((r).cmic_miim_ext_phy_addr_map_3_0[0] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_RESERVED_2f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_3_0[0]) >> 21) & 0x7)
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_RESERVED_2f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_3_0[0]=(((r).cmic_miim_ext_phy_addr_map_3_0[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_3f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_3_0[0]) >> 24) & 0x1f)
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_3f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_3_0[0]=(((r).cmic_miim_ext_phy_addr_map_3_0[0] & ~((uint32_t)0x1f << 24)) | ((((uint32_t)f) & 0x1f) << 24))
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_RESERVED_3f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_3_0[0]) >> 29) & 0x7)
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_RESERVED_3f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_3_0[0]=(((r).cmic_miim_ext_phy_addr_map_3_0[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0.
 *
 */
#define BCM56504_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r,r._cmic_miim_ext_phy_addr_map_3_0)
#define BCM56504_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r,r._cmic_miim_ext_phy_addr_map_3_0)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_SIZE BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_SIZE
typedef BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_t CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_t;
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_CLR BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_CLR
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_0f_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_0f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_0f_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_0f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_RESERVED_0f_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_RESERVED_0f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_RESERVED_0f_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_RESERVED_0f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_1f_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_1f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_1f_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_1f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_RESERVED_1f_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_RESERVED_1f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_RESERVED_1f_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_RESERVED_1f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_2f_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_2f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_2f_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_2f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_RESERVED_2f_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_RESERVED_2f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_RESERVED_2f_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_RESERVED_2f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_3f_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_3f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_3f_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_3f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_RESERVED_3f_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_RESERVED_3f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_RESERVED_3f_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_RESERVED_3f_SET
#define READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r BCM56504_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r
#define WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r BCM56504_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4
 * BLOCKS:   CMIC
 * DESC:     MIIM Phy Address map, Port 7:4
 * SIZE:     32
 * FIELDS:
 *     PHY_ID_4         Phy ID of external phy for Port 4
 *     RESERVED_0       Reserved
 *     PHY_ID_5         Phy ID of external phy for Port 5
 *     RESERVED_1       Reserved
 *     PHY_ID_6         Phy ID of external phy for Port 6
 *     RESERVED_2       Reserved
 *     PHY_ID_7         Phy ID of external phy for Port 7
 *     RESERVED_3       Reserved
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r 0x000004c4

#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4.
 *
 */
typedef union BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_s {
	uint32_t v[1];
	uint32_t cmic_miim_ext_phy_addr_map_7_4[1];
	uint32_t _cmic_miim_ext_phy_addr_map_7_4;
} BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_t;

#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_CLR(r) (r).cmic_miim_ext_phy_addr_map_7_4[0] = 0
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_SET(r,d) (r).cmic_miim_ext_phy_addr_map_7_4[0] = d
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_GET(r) (r).cmic_miim_ext_phy_addr_map_7_4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_4f_GET(r) (((r).cmic_miim_ext_phy_addr_map_7_4[0]) & 0x1f)
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_4f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_7_4[0]=(((r).cmic_miim_ext_phy_addr_map_7_4[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_RESERVED_0f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_7_4[0]) >> 5) & 0x7)
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_RESERVED_0f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_7_4[0]=(((r).cmic_miim_ext_phy_addr_map_7_4[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_5f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_7_4[0]) >> 8) & 0x1f)
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_5f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_7_4[0]=(((r).cmic_miim_ext_phy_addr_map_7_4[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_RESERVED_1f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_7_4[0]) >> 13) & 0x7)
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_RESERVED_1f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_7_4[0]=(((r).cmic_miim_ext_phy_addr_map_7_4[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_6f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_7_4[0]) >> 16) & 0x1f)
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_6f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_7_4[0]=(((r).cmic_miim_ext_phy_addr_map_7_4[0] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_RESERVED_2f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_7_4[0]) >> 21) & 0x7)
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_RESERVED_2f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_7_4[0]=(((r).cmic_miim_ext_phy_addr_map_7_4[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_7f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_7_4[0]) >> 24) & 0x1f)
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_7f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_7_4[0]=(((r).cmic_miim_ext_phy_addr_map_7_4[0] & ~((uint32_t)0x1f << 24)) | ((((uint32_t)f) & 0x1f) << 24))
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_RESERVED_3f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_7_4[0]) >> 29) & 0x7)
#define BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_RESERVED_3f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_7_4[0]=(((r).cmic_miim_ext_phy_addr_map_7_4[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4.
 *
 */
#define BCM56504_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r,r._cmic_miim_ext_phy_addr_map_7_4)
#define BCM56504_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r,r._cmic_miim_ext_phy_addr_map_7_4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_SIZE BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_SIZE
typedef BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_t CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_t;
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_CLR BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_CLR
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_4f_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_4f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_4f_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_4f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_RESERVED_0f_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_RESERVED_0f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_RESERVED_0f_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_RESERVED_0f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_5f_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_5f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_5f_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_5f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_RESERVED_1f_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_RESERVED_1f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_RESERVED_1f_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_RESERVED_1f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_6f_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_6f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_6f_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_6f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_RESERVED_2f_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_RESERVED_2f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_RESERVED_2f_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_RESERVED_2f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_7f_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_7f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_7f_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_7f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_RESERVED_3f_GET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_RESERVED_3f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_RESERVED_3f_SET BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_RESERVED_3f_SET
#define READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r BCM56504_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r
#define WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r BCM56504_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_MIIM_INT_SEL_MAP
 * BLOCKS:   CMIC
 * DESC:     Port bitmap specifying whether scan should be done
from internal or external phy.
0=external phy, 1=internal phy
Note: The bitmap is index by port number.

 * SIZE:     32
 * FIELDS:
 *     PORT_BITMAP      0 bits imply get link status by scanning external phy1 bits imply get link status directly from internal phy
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_MIIM_INT_SEL_MAPr 0x000004ac

#define BCM56504_A0_CMIC_MIIM_INT_SEL_MAPr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_INT_SEL_MAP.
 *
 */
typedef union BCM56504_A0_CMIC_MIIM_INT_SEL_MAPr_s {
	uint32_t v[1];
	uint32_t cmic_miim_int_sel_map[1];
	uint32_t _cmic_miim_int_sel_map;
} BCM56504_A0_CMIC_MIIM_INT_SEL_MAPr_t;

#define BCM56504_A0_CMIC_MIIM_INT_SEL_MAPr_CLR(r) (r).cmic_miim_int_sel_map[0] = 0
#define BCM56504_A0_CMIC_MIIM_INT_SEL_MAPr_SET(r,d) (r).cmic_miim_int_sel_map[0] = d
#define BCM56504_A0_CMIC_MIIM_INT_SEL_MAPr_GET(r) (r).cmic_miim_int_sel_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_MIIM_INT_SEL_MAPr_PORT_BITMAPf_GET(r) ((r).cmic_miim_int_sel_map[0])
#define BCM56504_A0_CMIC_MIIM_INT_SEL_MAPr_PORT_BITMAPf_SET(r,f) (r).cmic_miim_int_sel_map[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_MIIM_INT_SEL_MAP.
 *
 */
#define BCM56504_A0_READ_CMIC_MIIM_INT_SEL_MAPr(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_MIIM_INT_SEL_MAPr,r._cmic_miim_int_sel_map)
#define BCM56504_A0_WRITE_CMIC_MIIM_INT_SEL_MAPr(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_MIIM_INT_SEL_MAPr,r._cmic_miim_int_sel_map)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_INT_SEL_MAPr BCM56504_A0_CMIC_MIIM_INT_SEL_MAPr
#define CMIC_MIIM_INT_SEL_MAPr_SIZE BCM56504_A0_CMIC_MIIM_INT_SEL_MAPr_SIZE
typedef BCM56504_A0_CMIC_MIIM_INT_SEL_MAPr_t CMIC_MIIM_INT_SEL_MAPr_t;
#define CMIC_MIIM_INT_SEL_MAPr_CLR BCM56504_A0_CMIC_MIIM_INT_SEL_MAPr_CLR
#define CMIC_MIIM_INT_SEL_MAPr_SET BCM56504_A0_CMIC_MIIM_INT_SEL_MAPr_SET
#define CMIC_MIIM_INT_SEL_MAPr_GET BCM56504_A0_CMIC_MIIM_INT_SEL_MAPr_GET
#define CMIC_MIIM_INT_SEL_MAPr_PORT_BITMAPf_GET BCM56504_A0_CMIC_MIIM_INT_SEL_MAPr_PORT_BITMAPf_GET
#define CMIC_MIIM_INT_SEL_MAPr_PORT_BITMAPf_SET BCM56504_A0_CMIC_MIIM_INT_SEL_MAPr_PORT_BITMAPf_SET
#define READ_CMIC_MIIM_INT_SEL_MAPr BCM56504_A0_READ_CMIC_MIIM_INT_SEL_MAPr
#define WRITE_CMIC_MIIM_INT_SEL_MAPr BCM56504_A0_WRITE_CMIC_MIIM_INT_SEL_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_MIIM_INT_SEL_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_MIIM_PARAM
 * BLOCKS:   CMIC
 * DESC:     MIIM Parameter Register
 * SIZE:     32
 * FIELDS:
 *     PHY_DATA         PHY register data
 *     PHY_ID           Port number (Phy ID is looked up from port number)
 *     C45_SEL          When set, send MIIM transaction using Clause 45.Otherwise, send as Clause 22 transaction.
 *     HG_SEL           When set, send MIIM transaction on Higig MDIO bus.Otherwise, send on Gig MDIO bus.
 *     INTERNAL_SEL     When set, send MIIM transaction on Internal MDIO bus.Otherwise, send on External MDIO bus.
 *     RESERVED_2       Reserved
 *     MIIM_CYCLE       This field is used to select which type of MIIM cycle to run.Normally, it should just be set to 000.    000: Automatically runs the proper read or write cycle based         on the ports' protocol preference, and whether a read         or write cycle was requested.  If the port is clause 45         enabled, then the read or write will be preceeded by         an address cycle.    001: requests a clause 22 write cycle;         use MIIM_WR_REG_EN control    010: requests a clause 22 read cycle;         use MIIM_RD_REG_EN control    100: requests a clause 45 address cycle;         use MIIM_WR_REG_EN control    101: requests a clause 45 write cycle;         use MIIM_WR_REG_EN control    110: requests a clause 45 read cycle w/addr increment;         use MIIM_RD_REG_EN control    111: requests a clause 45 read cycle;         use MIIM_RD_REG_EN control
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_MIIM_PARAMr 0x00000158

#define BCM56504_A0_CMIC_MIIM_PARAMr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_PARAM.
 *
 */
typedef union BCM56504_A0_CMIC_MIIM_PARAMr_s {
	uint32_t v[1];
	uint32_t cmic_miim_param[1];
	uint32_t _cmic_miim_param;
} BCM56504_A0_CMIC_MIIM_PARAMr_t;

#define BCM56504_A0_CMIC_MIIM_PARAMr_CLR(r) (r).cmic_miim_param[0] = 0
#define BCM56504_A0_CMIC_MIIM_PARAMr_SET(r,d) (r).cmic_miim_param[0] = d
#define BCM56504_A0_CMIC_MIIM_PARAMr_GET(r) (r).cmic_miim_param[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_MIIM_PARAMr_PHY_DATAf_GET(r) (((r).cmic_miim_param[0]) & 0xffff)
#define BCM56504_A0_CMIC_MIIM_PARAMr_PHY_DATAf_SET(r,f) (r).cmic_miim_param[0]=(((r).cmic_miim_param[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56504_A0_CMIC_MIIM_PARAMr_PHY_IDf_GET(r) ((((r).cmic_miim_param[0]) >> 16) & 0x1f)
#define BCM56504_A0_CMIC_MIIM_PARAMr_PHY_IDf_SET(r,f) (r).cmic_miim_param[0]=(((r).cmic_miim_param[0] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define BCM56504_A0_CMIC_MIIM_PARAMr_C45_SELf_GET(r) ((((r).cmic_miim_param[0]) >> 21) & 0x1)
#define BCM56504_A0_CMIC_MIIM_PARAMr_C45_SELf_SET(r,f) (r).cmic_miim_param[0]=(((r).cmic_miim_param[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM56504_A0_CMIC_MIIM_PARAMr_HG_SELf_GET(r) ((((r).cmic_miim_param[0]) >> 22) & 0x1)
#define BCM56504_A0_CMIC_MIIM_PARAMr_HG_SELf_SET(r,f) (r).cmic_miim_param[0]=(((r).cmic_miim_param[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM56504_A0_CMIC_MIIM_PARAMr_INTERNAL_SELf_GET(r) ((((r).cmic_miim_param[0]) >> 23) & 0x1)
#define BCM56504_A0_CMIC_MIIM_PARAMr_INTERNAL_SELf_SET(r,f) (r).cmic_miim_param[0]=(((r).cmic_miim_param[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM56504_A0_CMIC_MIIM_PARAMr_RESERVED_2f_GET(r) ((((r).cmic_miim_param[0]) >> 24) & 0x1f)
#define BCM56504_A0_CMIC_MIIM_PARAMr_RESERVED_2f_SET(r,f) (r).cmic_miim_param[0]=(((r).cmic_miim_param[0] & ~((uint32_t)0x1f << 24)) | ((((uint32_t)f) & 0x1f) << 24))
#define BCM56504_A0_CMIC_MIIM_PARAMr_MIIM_CYCLEf_GET(r) ((((r).cmic_miim_param[0]) >> 29) & 0x7)
#define BCM56504_A0_CMIC_MIIM_PARAMr_MIIM_CYCLEf_SET(r,f) (r).cmic_miim_param[0]=(((r).cmic_miim_param[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access CMIC_MIIM_PARAM.
 *
 */
#define BCM56504_A0_READ_CMIC_MIIM_PARAMr(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_MIIM_PARAMr,r._cmic_miim_param)
#define BCM56504_A0_WRITE_CMIC_MIIM_PARAMr(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_MIIM_PARAMr,r._cmic_miim_param)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_PARAMr BCM56504_A0_CMIC_MIIM_PARAMr
#define CMIC_MIIM_PARAMr_SIZE BCM56504_A0_CMIC_MIIM_PARAMr_SIZE
typedef BCM56504_A0_CMIC_MIIM_PARAMr_t CMIC_MIIM_PARAMr_t;
#define CMIC_MIIM_PARAMr_CLR BCM56504_A0_CMIC_MIIM_PARAMr_CLR
#define CMIC_MIIM_PARAMr_SET BCM56504_A0_CMIC_MIIM_PARAMr_SET
#define CMIC_MIIM_PARAMr_GET BCM56504_A0_CMIC_MIIM_PARAMr_GET
#define CMIC_MIIM_PARAMr_PHY_DATAf_GET BCM56504_A0_CMIC_MIIM_PARAMr_PHY_DATAf_GET
#define CMIC_MIIM_PARAMr_PHY_DATAf_SET BCM56504_A0_CMIC_MIIM_PARAMr_PHY_DATAf_SET
#define CMIC_MIIM_PARAMr_PHY_IDf_GET BCM56504_A0_CMIC_MIIM_PARAMr_PHY_IDf_GET
#define CMIC_MIIM_PARAMr_PHY_IDf_SET BCM56504_A0_CMIC_MIIM_PARAMr_PHY_IDf_SET
#define CMIC_MIIM_PARAMr_C45_SELf_GET BCM56504_A0_CMIC_MIIM_PARAMr_C45_SELf_GET
#define CMIC_MIIM_PARAMr_C45_SELf_SET BCM56504_A0_CMIC_MIIM_PARAMr_C45_SELf_SET
#define CMIC_MIIM_PARAMr_HG_SELf_GET BCM56504_A0_CMIC_MIIM_PARAMr_HG_SELf_GET
#define CMIC_MIIM_PARAMr_HG_SELf_SET BCM56504_A0_CMIC_MIIM_PARAMr_HG_SELf_SET
#define CMIC_MIIM_PARAMr_INTERNAL_SELf_GET BCM56504_A0_CMIC_MIIM_PARAMr_INTERNAL_SELf_GET
#define CMIC_MIIM_PARAMr_INTERNAL_SELf_SET BCM56504_A0_CMIC_MIIM_PARAMr_INTERNAL_SELf_SET
#define CMIC_MIIM_PARAMr_RESERVED_2f_GET BCM56504_A0_CMIC_MIIM_PARAMr_RESERVED_2f_GET
#define CMIC_MIIM_PARAMr_RESERVED_2f_SET BCM56504_A0_CMIC_MIIM_PARAMr_RESERVED_2f_SET
#define CMIC_MIIM_PARAMr_MIIM_CYCLEf_GET BCM56504_A0_CMIC_MIIM_PARAMr_MIIM_CYCLEf_GET
#define CMIC_MIIM_PARAMr_MIIM_CYCLEf_SET BCM56504_A0_CMIC_MIIM_PARAMr_MIIM_CYCLEf_SET
#define READ_CMIC_MIIM_PARAMr BCM56504_A0_READ_CMIC_MIIM_PARAMr
#define WRITE_CMIC_MIIM_PARAMr BCM56504_A0_WRITE_CMIC_MIIM_PARAMr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_MIIM_PARAMr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_MIIM_PORT_TYPE_MAP
 * BLOCKS:   CMIC
 * DESC:     Port type bitmap: 0=Gig port, 1=Higig port
Note: The bitmap is index by port number.

 * SIZE:     32
 * FIELDS:
 *     BITMAP           0 bits are   Gig ports, so access   Gig MIIM interface1 bits are HG/XE ports, so access Higig MIIM interface
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_MIIM_PORT_TYPE_MAPr 0x000004a8

#define BCM56504_A0_CMIC_MIIM_PORT_TYPE_MAPr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_PORT_TYPE_MAP.
 *
 */
typedef union BCM56504_A0_CMIC_MIIM_PORT_TYPE_MAPr_s {
	uint32_t v[1];
	uint32_t cmic_miim_port_type_map[1];
	uint32_t _cmic_miim_port_type_map;
} BCM56504_A0_CMIC_MIIM_PORT_TYPE_MAPr_t;

#define BCM56504_A0_CMIC_MIIM_PORT_TYPE_MAPr_CLR(r) (r).cmic_miim_port_type_map[0] = 0
#define BCM56504_A0_CMIC_MIIM_PORT_TYPE_MAPr_SET(r,d) (r).cmic_miim_port_type_map[0] = d
#define BCM56504_A0_CMIC_MIIM_PORT_TYPE_MAPr_GET(r) (r).cmic_miim_port_type_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_MIIM_PORT_TYPE_MAPr_BITMAPf_GET(r) ((r).cmic_miim_port_type_map[0])
#define BCM56504_A0_CMIC_MIIM_PORT_TYPE_MAPr_BITMAPf_SET(r,f) (r).cmic_miim_port_type_map[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_MIIM_PORT_TYPE_MAP.
 *
 */
#define BCM56504_A0_READ_CMIC_MIIM_PORT_TYPE_MAPr(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_MIIM_PORT_TYPE_MAPr,r._cmic_miim_port_type_map)
#define BCM56504_A0_WRITE_CMIC_MIIM_PORT_TYPE_MAPr(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_MIIM_PORT_TYPE_MAPr,r._cmic_miim_port_type_map)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_PORT_TYPE_MAPr BCM56504_A0_CMIC_MIIM_PORT_TYPE_MAPr
#define CMIC_MIIM_PORT_TYPE_MAPr_SIZE BCM56504_A0_CMIC_MIIM_PORT_TYPE_MAPr_SIZE
typedef BCM56504_A0_CMIC_MIIM_PORT_TYPE_MAPr_t CMIC_MIIM_PORT_TYPE_MAPr_t;
#define CMIC_MIIM_PORT_TYPE_MAPr_CLR BCM56504_A0_CMIC_MIIM_PORT_TYPE_MAPr_CLR
#define CMIC_MIIM_PORT_TYPE_MAPr_SET BCM56504_A0_CMIC_MIIM_PORT_TYPE_MAPr_SET
#define CMIC_MIIM_PORT_TYPE_MAPr_GET BCM56504_A0_CMIC_MIIM_PORT_TYPE_MAPr_GET
#define CMIC_MIIM_PORT_TYPE_MAPr_BITMAPf_GET BCM56504_A0_CMIC_MIIM_PORT_TYPE_MAPr_BITMAPf_GET
#define CMIC_MIIM_PORT_TYPE_MAPr_BITMAPf_SET BCM56504_A0_CMIC_MIIM_PORT_TYPE_MAPr_BITMAPf_SET
#define READ_CMIC_MIIM_PORT_TYPE_MAPr BCM56504_A0_READ_CMIC_MIIM_PORT_TYPE_MAPr
#define WRITE_CMIC_MIIM_PORT_TYPE_MAPr BCM56504_A0_WRITE_CMIC_MIIM_PORT_TYPE_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_MIIM_PORT_TYPE_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_MIIM_PROTOCOL_MAP
 * BLOCKS:   CMIC
 * DESC:     Port bitmap of MIIM protocol: 0=clause 22, 1=clause 45
Note: The bitmap is index by port number.

 * SIZE:     32
 * FIELDS:
 *     BITMAP           0 bits are ports that use clause 22;1 bits are ports that use clause 45.Note: This register is shared by external and internal phy's, so it should be programmed appropriately beforelaunching MIIM wr/rd or link scan commands.
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_MIIM_PROTOCOL_MAPr 0x000004a4

#define BCM56504_A0_CMIC_MIIM_PROTOCOL_MAPr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_PROTOCOL_MAP.
 *
 */
typedef union BCM56504_A0_CMIC_MIIM_PROTOCOL_MAPr_s {
	uint32_t v[1];
	uint32_t cmic_miim_protocol_map[1];
	uint32_t _cmic_miim_protocol_map;
} BCM56504_A0_CMIC_MIIM_PROTOCOL_MAPr_t;

#define BCM56504_A0_CMIC_MIIM_PROTOCOL_MAPr_CLR(r) (r).cmic_miim_protocol_map[0] = 0
#define BCM56504_A0_CMIC_MIIM_PROTOCOL_MAPr_SET(r,d) (r).cmic_miim_protocol_map[0] = d
#define BCM56504_A0_CMIC_MIIM_PROTOCOL_MAPr_GET(r) (r).cmic_miim_protocol_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_MIIM_PROTOCOL_MAPr_BITMAPf_GET(r) ((r).cmic_miim_protocol_map[0])
#define BCM56504_A0_CMIC_MIIM_PROTOCOL_MAPr_BITMAPf_SET(r,f) (r).cmic_miim_protocol_map[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_MIIM_PROTOCOL_MAP.
 *
 */
#define BCM56504_A0_READ_CMIC_MIIM_PROTOCOL_MAPr(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_MIIM_PROTOCOL_MAPr,r._cmic_miim_protocol_map)
#define BCM56504_A0_WRITE_CMIC_MIIM_PROTOCOL_MAPr(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_MIIM_PROTOCOL_MAPr,r._cmic_miim_protocol_map)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_PROTOCOL_MAPr BCM56504_A0_CMIC_MIIM_PROTOCOL_MAPr
#define CMIC_MIIM_PROTOCOL_MAPr_SIZE BCM56504_A0_CMIC_MIIM_PROTOCOL_MAPr_SIZE
typedef BCM56504_A0_CMIC_MIIM_PROTOCOL_MAPr_t CMIC_MIIM_PROTOCOL_MAPr_t;
#define CMIC_MIIM_PROTOCOL_MAPr_CLR BCM56504_A0_CMIC_MIIM_PROTOCOL_MAPr_CLR
#define CMIC_MIIM_PROTOCOL_MAPr_SET BCM56504_A0_CMIC_MIIM_PROTOCOL_MAPr_SET
#define CMIC_MIIM_PROTOCOL_MAPr_GET BCM56504_A0_CMIC_MIIM_PROTOCOL_MAPr_GET
#define CMIC_MIIM_PROTOCOL_MAPr_BITMAPf_GET BCM56504_A0_CMIC_MIIM_PROTOCOL_MAPr_BITMAPf_GET
#define CMIC_MIIM_PROTOCOL_MAPr_BITMAPf_SET BCM56504_A0_CMIC_MIIM_PROTOCOL_MAPr_BITMAPf_SET
#define READ_CMIC_MIIM_PROTOCOL_MAPr BCM56504_A0_READ_CMIC_MIIM_PROTOCOL_MAPr
#define WRITE_CMIC_MIIM_PROTOCOL_MAPr BCM56504_A0_WRITE_CMIC_MIIM_PROTOCOL_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_MIIM_PROTOCOL_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_MIIM_READ_DATA
 * BLOCKS:   CMIC
 * DESC:     MIIM Read Data Register
 * SIZE:     32
 * FIELDS:
 *     DATA             MIIM Read Data Register
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_MIIM_READ_DATAr 0x0000015c

#define BCM56504_A0_CMIC_MIIM_READ_DATAr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_READ_DATA.
 *
 */
typedef union BCM56504_A0_CMIC_MIIM_READ_DATAr_s {
	uint32_t v[1];
	uint32_t cmic_miim_read_data[1];
	uint32_t _cmic_miim_read_data;
} BCM56504_A0_CMIC_MIIM_READ_DATAr_t;

#define BCM56504_A0_CMIC_MIIM_READ_DATAr_CLR(r) (r).cmic_miim_read_data[0] = 0
#define BCM56504_A0_CMIC_MIIM_READ_DATAr_SET(r,d) (r).cmic_miim_read_data[0] = d
#define BCM56504_A0_CMIC_MIIM_READ_DATAr_GET(r) (r).cmic_miim_read_data[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_MIIM_READ_DATAr_DATAf_GET(r) (((r).cmic_miim_read_data[0]) & 0xffff)
#define BCM56504_A0_CMIC_MIIM_READ_DATAr_DATAf_SET(r,f) (r).cmic_miim_read_data[0]=(((r).cmic_miim_read_data[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access CMIC_MIIM_READ_DATA.
 *
 */
#define BCM56504_A0_READ_CMIC_MIIM_READ_DATAr(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_MIIM_READ_DATAr,r._cmic_miim_read_data)
#define BCM56504_A0_WRITE_CMIC_MIIM_READ_DATAr(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_MIIM_READ_DATAr,r._cmic_miim_read_data)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_READ_DATAr BCM56504_A0_CMIC_MIIM_READ_DATAr
#define CMIC_MIIM_READ_DATAr_SIZE BCM56504_A0_CMIC_MIIM_READ_DATAr_SIZE
typedef BCM56504_A0_CMIC_MIIM_READ_DATAr_t CMIC_MIIM_READ_DATAr_t;
#define CMIC_MIIM_READ_DATAr_CLR BCM56504_A0_CMIC_MIIM_READ_DATAr_CLR
#define CMIC_MIIM_READ_DATAr_SET BCM56504_A0_CMIC_MIIM_READ_DATAr_SET
#define CMIC_MIIM_READ_DATAr_GET BCM56504_A0_CMIC_MIIM_READ_DATAr_GET
#define CMIC_MIIM_READ_DATAr_DATAf_GET BCM56504_A0_CMIC_MIIM_READ_DATAr_DATAf_GET
#define CMIC_MIIM_READ_DATAr_DATAf_SET BCM56504_A0_CMIC_MIIM_READ_DATAr_DATAf_SET
#define READ_CMIC_MIIM_READ_DATAr BCM56504_A0_READ_CMIC_MIIM_READ_DATAr
#define WRITE_CMIC_MIIM_READ_DATAr BCM56504_A0_WRITE_CMIC_MIIM_READ_DATAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_MIIM_READ_DATAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_RATE_ADJUST
 * BLOCKS:   CMIC
 * DESC:     Various parts of the chip involved in rate control 
require a constant, known frequency. This reference 
frequency is based off of the chip 's core clock.
However, the core clock can be different in different
designs, thus the need for this register.

The core clock frequency is multiplied by the rational
quantity (DIVIDEND/DIVISOR), and the further divided
down by 2 to produce the actual MDIO operation freqeuncy.

To avoid skew, it is recommended that the DIVIDEND value
usually be set to 1.

The default values are for 133MHz operation:
DIVIDEND=1, DIVISOR=6, 
MDIO operation freq = 133MHz/(6*2) =~ 11MHz

For 157MHz core clock chips, set:
DIVIDEND=1, DIVISOR=7, 
MDIO operation freq = 133MHz/(7*2) =~ 11MHz


 * SIZE:     32
 * FIELDS:
 *     DIVISOR          Denominator of clock scale factor.
 *     DIVIDEND         Numerator of clock scale factor.
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_RATE_ADJUSTr 0x000001b0

#define BCM56504_A0_CMIC_RATE_ADJUSTr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_RATE_ADJUST.
 *
 */
typedef union BCM56504_A0_CMIC_RATE_ADJUSTr_s {
	uint32_t v[1];
	uint32_t cmic_rate_adjust[1];
	uint32_t _cmic_rate_adjust;
} BCM56504_A0_CMIC_RATE_ADJUSTr_t;

#define BCM56504_A0_CMIC_RATE_ADJUSTr_CLR(r) (r).cmic_rate_adjust[0] = 0
#define BCM56504_A0_CMIC_RATE_ADJUSTr_SET(r,d) (r).cmic_rate_adjust[0] = d
#define BCM56504_A0_CMIC_RATE_ADJUSTr_GET(r) (r).cmic_rate_adjust[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_RATE_ADJUSTr_DIVISORf_GET(r) (((r).cmic_rate_adjust[0]) & 0xffff)
#define BCM56504_A0_CMIC_RATE_ADJUSTr_DIVISORf_SET(r,f) (r).cmic_rate_adjust[0]=(((r).cmic_rate_adjust[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56504_A0_CMIC_RATE_ADJUSTr_DIVIDENDf_GET(r) ((((r).cmic_rate_adjust[0]) >> 16) & 0xffff)
#define BCM56504_A0_CMIC_RATE_ADJUSTr_DIVIDENDf_SET(r,f) (r).cmic_rate_adjust[0]=(((r).cmic_rate_adjust[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access CMIC_RATE_ADJUST.
 *
 */
#define BCM56504_A0_READ_CMIC_RATE_ADJUSTr(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_RATE_ADJUSTr,r._cmic_rate_adjust)
#define BCM56504_A0_WRITE_CMIC_RATE_ADJUSTr(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_RATE_ADJUSTr,r._cmic_rate_adjust)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_RATE_ADJUSTr BCM56504_A0_CMIC_RATE_ADJUSTr
#define CMIC_RATE_ADJUSTr_SIZE BCM56504_A0_CMIC_RATE_ADJUSTr_SIZE
typedef BCM56504_A0_CMIC_RATE_ADJUSTr_t CMIC_RATE_ADJUSTr_t;
#define CMIC_RATE_ADJUSTr_CLR BCM56504_A0_CMIC_RATE_ADJUSTr_CLR
#define CMIC_RATE_ADJUSTr_SET BCM56504_A0_CMIC_RATE_ADJUSTr_SET
#define CMIC_RATE_ADJUSTr_GET BCM56504_A0_CMIC_RATE_ADJUSTr_GET
#define CMIC_RATE_ADJUSTr_DIVISORf_GET BCM56504_A0_CMIC_RATE_ADJUSTr_DIVISORf_GET
#define CMIC_RATE_ADJUSTr_DIVISORf_SET BCM56504_A0_CMIC_RATE_ADJUSTr_DIVISORf_SET
#define CMIC_RATE_ADJUSTr_DIVIDENDf_GET BCM56504_A0_CMIC_RATE_ADJUSTr_DIVIDENDf_GET
#define CMIC_RATE_ADJUSTr_DIVIDENDf_SET BCM56504_A0_CMIC_RATE_ADJUSTr_DIVIDENDf_SET
#define READ_CMIC_RATE_ADJUSTr BCM56504_A0_READ_CMIC_RATE_ADJUSTr
#define WRITE_CMIC_RATE_ADJUSTr BCM56504_A0_WRITE_CMIC_RATE_ADJUSTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_RATE_ADJUSTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_SBUS_RING_MAP
 * BLOCKS:   CMIC
 * DESC:     Map of S-bus agents on all 3 S-bus rings in the chip
 * SIZE:     32
 * FIELDS:
 *     RING_NUM_SBUS_ID_0 S-bus ring number for agent with S-bus ID  0
 *     RING_NUM_SBUS_ID_1 S-bus ring number for agent with S-bus ID  1
 *     RING_NUM_SBUS_ID_2 S-bus ring number for agent with S-bus ID  2
 *     RING_NUM_SBUS_ID_3 S-bus ring number for agent with S-bus ID  3
 *     RING_NUM_SBUS_ID_4 S-bus ring number for agent with S-bus ID  4
 *     RING_NUM_SBUS_ID_5 S-bus ring number for agent with S-bus ID  5
 *     RING_NUM_SBUS_ID_6 S-bus ring number for agent with S-bus ID  6
 *     RING_NUM_SBUS_ID_7 S-bus ring number for agent with S-bus ID  7
 *     RING_NUM_SBUS_ID_8 S-bus ring number for agent with S-bus ID  8
 *     RING_NUM_SBUS_ID_9 S-bus ring number for agent with S-bus ID  9
 *     RING_NUM_SBUS_ID_10 S-bus ring number for agent with S-bus ID 10
 *     RING_NUM_SBUS_ID_11 S-bus ring number for agent with S-bus ID 11
 *     RING_NUM_SBUS_ID_12 S-bus ring number for agent with S-bus ID 12
 *     RING_NUM_SBUS_ID_13 S-bus ring number for agent with S-bus ID 13
 *     RING_NUM_SBUS_ID_14 S-bus ring number for agent with S-bus ID 14
 *     RING_NUM_SBUS_ID_15 S-bus ring number for agent with S-bus ID 15
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_SBUS_RING_MAPr 0x00000400

#define BCM56504_A0_CMIC_SBUS_RING_MAPr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SBUS_RING_MAP.
 *
 */
typedef union BCM56504_A0_CMIC_SBUS_RING_MAPr_s {
	uint32_t v[1];
	uint32_t cmic_sbus_ring_map[1];
	uint32_t _cmic_sbus_ring_map;
} BCM56504_A0_CMIC_SBUS_RING_MAPr_t;

#define BCM56504_A0_CMIC_SBUS_RING_MAPr_CLR(r) (r).cmic_sbus_ring_map[0] = 0
#define BCM56504_A0_CMIC_SBUS_RING_MAPr_SET(r,d) (r).cmic_sbus_ring_map[0] = d
#define BCM56504_A0_CMIC_SBUS_RING_MAPr_GET(r) (r).cmic_sbus_ring_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_0f_GET(r) (((r).cmic_sbus_ring_map[0]) & 0x3)
#define BCM56504_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_0f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56504_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_1f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 2) & 0x3)
#define BCM56504_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_1f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM56504_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_2f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 4) & 0x3)
#define BCM56504_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_2f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM56504_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_3f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 6) & 0x3)
#define BCM56504_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_3f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM56504_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_4f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 8) & 0x3)
#define BCM56504_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_4f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM56504_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_5f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 10) & 0x3)
#define BCM56504_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_5f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCM56504_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_6f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 12) & 0x3)
#define BCM56504_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_6f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM56504_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_7f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 14) & 0x3)
#define BCM56504_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_7f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCM56504_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_8f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 16) & 0x3)
#define BCM56504_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_8f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM56504_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_9f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 18) & 0x3)
#define BCM56504_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_9f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32_t)0x3 << 18)) | ((((uint32_t)f) & 0x3) << 18))
#define BCM56504_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_10f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 20) & 0x3)
#define BCM56504_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_10f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32_t)0x3 << 20)) | ((((uint32_t)f) & 0x3) << 20))
#define BCM56504_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_11f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 22) & 0x3)
#define BCM56504_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_11f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32_t)0x3 << 22)) | ((((uint32_t)f) & 0x3) << 22))
#define BCM56504_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_12f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 24) & 0x3)
#define BCM56504_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_12f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32_t)0x3 << 24)) | ((((uint32_t)f) & 0x3) << 24))
#define BCM56504_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_13f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 26) & 0x3)
#define BCM56504_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_13f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32_t)0x3 << 26)) | ((((uint32_t)f) & 0x3) << 26))
#define BCM56504_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_14f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 28) & 0x3)
#define BCM56504_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_14f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32_t)0x3 << 28)) | ((((uint32_t)f) & 0x3) << 28))
#define BCM56504_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_15f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 30) & 0x3)
#define BCM56504_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_15f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))

/*
 * These macros can be used to access CMIC_SBUS_RING_MAP.
 *
 */
#define BCM56504_A0_READ_CMIC_SBUS_RING_MAPr(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_SBUS_RING_MAPr,r._cmic_sbus_ring_map)
#define BCM56504_A0_WRITE_CMIC_SBUS_RING_MAPr(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_SBUS_RING_MAPr,r._cmic_sbus_ring_map)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_SBUS_RING_MAPr BCM56504_A0_CMIC_SBUS_RING_MAPr
#define CMIC_SBUS_RING_MAPr_SIZE BCM56504_A0_CMIC_SBUS_RING_MAPr_SIZE
typedef BCM56504_A0_CMIC_SBUS_RING_MAPr_t CMIC_SBUS_RING_MAPr_t;
#define CMIC_SBUS_RING_MAPr_CLR BCM56504_A0_CMIC_SBUS_RING_MAPr_CLR
#define CMIC_SBUS_RING_MAPr_SET BCM56504_A0_CMIC_SBUS_RING_MAPr_SET
#define CMIC_SBUS_RING_MAPr_GET BCM56504_A0_CMIC_SBUS_RING_MAPr_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_0f_GET BCM56504_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_0f_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_0f_SET BCM56504_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_0f_SET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_1f_GET BCM56504_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_1f_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_1f_SET BCM56504_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_1f_SET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_2f_GET BCM56504_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_2f_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_2f_SET BCM56504_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_2f_SET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_3f_GET BCM56504_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_3f_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_3f_SET BCM56504_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_3f_SET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_4f_GET BCM56504_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_4f_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_4f_SET BCM56504_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_4f_SET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_5f_GET BCM56504_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_5f_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_5f_SET BCM56504_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_5f_SET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_6f_GET BCM56504_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_6f_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_6f_SET BCM56504_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_6f_SET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_7f_GET BCM56504_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_7f_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_7f_SET BCM56504_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_7f_SET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_8f_GET BCM56504_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_8f_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_8f_SET BCM56504_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_8f_SET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_9f_GET BCM56504_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_9f_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_9f_SET BCM56504_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_9f_SET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_10f_GET BCM56504_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_10f_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_10f_SET BCM56504_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_10f_SET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_11f_GET BCM56504_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_11f_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_11f_SET BCM56504_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_11f_SET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_12f_GET BCM56504_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_12f_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_12f_SET BCM56504_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_12f_SET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_13f_GET BCM56504_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_13f_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_13f_SET BCM56504_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_13f_SET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_14f_GET BCM56504_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_14f_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_14f_SET BCM56504_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_14f_SET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_15f_GET BCM56504_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_15f_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_15f_SET BCM56504_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_15f_SET
#define READ_CMIC_SBUS_RING_MAPr BCM56504_A0_READ_CMIC_SBUS_RING_MAPr
#define WRITE_CMIC_SBUS_RING_MAPr BCM56504_A0_WRITE_CMIC_SBUS_RING_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_SBUS_RING_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_SBUS_TIMEOUT
 * BLOCKS:   CMIC
 * DESC:     Secret register that allows software to program the
S-bus operation completion time limit (in terms of 
number of core clocks).
If this limit is exceeded, the CMIC will set the SW PIO
"DONE" bit and the "ERROR" bit to indicate the timeout.

 * SIZE:     32
 * FIELDS:
 *     TIMEOUT_VAL      Timeout value in core clocks
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_SBUS_TIMEOUTr 0x00000408

#define BCM56504_A0_CMIC_SBUS_TIMEOUTr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SBUS_TIMEOUT.
 *
 */
typedef union BCM56504_A0_CMIC_SBUS_TIMEOUTr_s {
	uint32_t v[1];
	uint32_t cmic_sbus_timeout[1];
	uint32_t _cmic_sbus_timeout;
} BCM56504_A0_CMIC_SBUS_TIMEOUTr_t;

#define BCM56504_A0_CMIC_SBUS_TIMEOUTr_CLR(r) (r).cmic_sbus_timeout[0] = 0
#define BCM56504_A0_CMIC_SBUS_TIMEOUTr_SET(r,d) (r).cmic_sbus_timeout[0] = d
#define BCM56504_A0_CMIC_SBUS_TIMEOUTr_GET(r) (r).cmic_sbus_timeout[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_SBUS_TIMEOUTr_TIMEOUT_VALf_GET(r) ((r).cmic_sbus_timeout[0])
#define BCM56504_A0_CMIC_SBUS_TIMEOUTr_TIMEOUT_VALf_SET(r,f) (r).cmic_sbus_timeout[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_SBUS_TIMEOUT.
 *
 */
#define BCM56504_A0_READ_CMIC_SBUS_TIMEOUTr(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_SBUS_TIMEOUTr,r._cmic_sbus_timeout)
#define BCM56504_A0_WRITE_CMIC_SBUS_TIMEOUTr(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_SBUS_TIMEOUTr,r._cmic_sbus_timeout)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_SBUS_TIMEOUTr BCM56504_A0_CMIC_SBUS_TIMEOUTr
#define CMIC_SBUS_TIMEOUTr_SIZE BCM56504_A0_CMIC_SBUS_TIMEOUTr_SIZE
typedef BCM56504_A0_CMIC_SBUS_TIMEOUTr_t CMIC_SBUS_TIMEOUTr_t;
#define CMIC_SBUS_TIMEOUTr_CLR BCM56504_A0_CMIC_SBUS_TIMEOUTr_CLR
#define CMIC_SBUS_TIMEOUTr_SET BCM56504_A0_CMIC_SBUS_TIMEOUTr_SET
#define CMIC_SBUS_TIMEOUTr_GET BCM56504_A0_CMIC_SBUS_TIMEOUTr_GET
#define CMIC_SBUS_TIMEOUTr_TIMEOUT_VALf_GET BCM56504_A0_CMIC_SBUS_TIMEOUTr_TIMEOUT_VALf_GET
#define CMIC_SBUS_TIMEOUTr_TIMEOUT_VALf_SET BCM56504_A0_CMIC_SBUS_TIMEOUTr_TIMEOUT_VALf_SET
#define READ_CMIC_SBUS_TIMEOUTr BCM56504_A0_READ_CMIC_SBUS_TIMEOUTr
#define WRITE_CMIC_SBUS_TIMEOUTr BCM56504_A0_WRITE_CMIC_SBUS_TIMEOUTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_SBUS_TIMEOUTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_SCAN_PORTS
 * BLOCKS:   CMIC
 * DESC:     Scan Ports Register
 * SIZE:     32
 * FIELDS:
 *     PORT_BITMAP      SCAN ports Register
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_SCAN_PORTSr 0x00000160

#define BCM56504_A0_CMIC_SCAN_PORTSr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SCAN_PORTS.
 *
 */
typedef union BCM56504_A0_CMIC_SCAN_PORTSr_s {
	uint32_t v[1];
	uint32_t cmic_scan_ports[1];
	uint32_t _cmic_scan_ports;
} BCM56504_A0_CMIC_SCAN_PORTSr_t;

#define BCM56504_A0_CMIC_SCAN_PORTSr_CLR(r) (r).cmic_scan_ports[0] = 0
#define BCM56504_A0_CMIC_SCAN_PORTSr_SET(r,d) (r).cmic_scan_ports[0] = d
#define BCM56504_A0_CMIC_SCAN_PORTSr_GET(r) (r).cmic_scan_ports[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_SCAN_PORTSr_PORT_BITMAPf_GET(r) ((r).cmic_scan_ports[0])
#define BCM56504_A0_CMIC_SCAN_PORTSr_PORT_BITMAPf_SET(r,f) (r).cmic_scan_ports[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_SCAN_PORTS.
 *
 */
#define BCM56504_A0_READ_CMIC_SCAN_PORTSr(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_SCAN_PORTSr,r._cmic_scan_ports)
#define BCM56504_A0_WRITE_CMIC_SCAN_PORTSr(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_SCAN_PORTSr,r._cmic_scan_ports)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_SCAN_PORTSr BCM56504_A0_CMIC_SCAN_PORTSr
#define CMIC_SCAN_PORTSr_SIZE BCM56504_A0_CMIC_SCAN_PORTSr_SIZE
typedef BCM56504_A0_CMIC_SCAN_PORTSr_t CMIC_SCAN_PORTSr_t;
#define CMIC_SCAN_PORTSr_CLR BCM56504_A0_CMIC_SCAN_PORTSr_CLR
#define CMIC_SCAN_PORTSr_SET BCM56504_A0_CMIC_SCAN_PORTSr_SET
#define CMIC_SCAN_PORTSr_GET BCM56504_A0_CMIC_SCAN_PORTSr_GET
#define CMIC_SCAN_PORTSr_PORT_BITMAPf_GET BCM56504_A0_CMIC_SCAN_PORTSr_PORT_BITMAPf_GET
#define CMIC_SCAN_PORTSr_PORT_BITMAPf_SET BCM56504_A0_CMIC_SCAN_PORTSr_PORT_BITMAPf_SET
#define READ_CMIC_SCAN_PORTSr BCM56504_A0_READ_CMIC_SCAN_PORTSr
#define WRITE_CMIC_SCAN_PORTSr BCM56504_A0_WRITE_CMIC_SCAN_PORTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_SCAN_PORTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_SCHAN_CTRL
 * BLOCKS:   CMIC
 * DESC:     Status and Control Register
 * SIZE:     32
 * FIELDS:
 *     MSG_START        Set by CPU to start an SCH operation
 *     MSG_DONE         Set by CMIC to indicate an SCH operation completion
 *     RESERVED_1       Reserved
 *     LINK_STATUS_CHANGE Set by CMIC to indicate Link status changed
 *     PCI_FATAL_ERR    Set by CMIC to indicate a Fatal Error during PCI master Operation
 *     PCI_PARITY_ERR   Set by CMIC to indicate a Parity Error during PCI master Operation
 *     RESERVED_3       Reserved
 *     MIIM_SCAN_BUSY   Set by CMIC indicating that MIIM scan cycle is in progress
 *     RESERVED_4       Reserved
 *     MIIM_RD_START    Set by CPU to start a Read operation on MIIM Interface
 *     MIIM_WR_START    Set by CPU to start a Write operation on MIIM Interface
 *     MIIM_OP_DONE     Set by CMIC to indicate Completion of MIIM Rd/Wr Operation
 *     MIIM_LINK_SCAN_EN Set by CPU to start automatic Link Status scanning
 *     RESERVED_5       Reserved
 *     NACK             Set by CMIC to indicate last S-bus operation resulted in a NACK(i.e., command was legal, but could not be serviced due tohardware resource limitations)Clearing the SCH_PIO_OPN_COMPLETE bit or starting a new SCH operation will automatically clear this bit
 *     TIMEOUT          Set by CMIC to indicate last S-bus operation resulted in a TIMEOUT.(i.e., no ACK was received by CMIC within the TIMEOUT intervalspecified in CMIC_SBUS_TIMEOUT)Clearing the SCH_PIO_OPN_COMPLETE bit or starting a new SCH operation will automatically clear this bit
 *     BIT_POS          Selects one of 32 bits positions to be Set/Reset
 *     BIT_VAL          Set to 1 to set a bit, 0 to reset a bit
 *     RESERVED_6       Reserved
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_SCHAN_CTRLr 0x00000050

#define BCM56504_A0_CMIC_SCHAN_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SCHAN_CTRL.
 *
 */
typedef union BCM56504_A0_CMIC_SCHAN_CTRLr_s {
	uint32_t v[1];
	uint32_t cmic_schan_ctrl[1];
	uint32_t _cmic_schan_ctrl;
} BCM56504_A0_CMIC_SCHAN_CTRLr_t;

#define BCM56504_A0_CMIC_SCHAN_CTRLr_CLR(r) (r).cmic_schan_ctrl[0] = 0
#define BCM56504_A0_CMIC_SCHAN_CTRLr_SET(r,d) (r).cmic_schan_ctrl[0] = d
#define BCM56504_A0_CMIC_SCHAN_CTRLr_GET(r) (r).cmic_schan_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_SCHAN_CTRLr_MSG_STARTf_GET(r) (((r).cmic_schan_ctrl[0]) & 0x1)
#define BCM56504_A0_CMIC_SCHAN_CTRLr_MSG_STARTf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_CMIC_SCHAN_CTRLr_MSG_DONEf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 1) & 0x1)
#define BCM56504_A0_CMIC_SCHAN_CTRLr_MSG_DONEf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_CMIC_SCHAN_CTRLr_RESERVED_1f_GET(r) ((((r).cmic_schan_ctrl[0]) >> 2) & 0x3f)
#define BCM56504_A0_CMIC_SCHAN_CTRLr_RESERVED_1f_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x3f << 2)) | ((((uint32_t)f) & 0x3f) << 2))
#define BCM56504_A0_CMIC_SCHAN_CTRLr_LINK_STATUS_CHANGEf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 8) & 0x1)
#define BCM56504_A0_CMIC_SCHAN_CTRLr_LINK_STATUS_CHANGEf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56504_A0_CMIC_SCHAN_CTRLr_PCI_FATAL_ERRf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 9) & 0x1)
#define BCM56504_A0_CMIC_SCHAN_CTRLr_PCI_FATAL_ERRf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56504_A0_CMIC_SCHAN_CTRLr_PCI_PARITY_ERRf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 10) & 0x1)
#define BCM56504_A0_CMIC_SCHAN_CTRLr_PCI_PARITY_ERRf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56504_A0_CMIC_SCHAN_CTRLr_RESERVED_3f_GET(r) ((((r).cmic_schan_ctrl[0]) >> 11) & 0x7)
#define BCM56504_A0_CMIC_SCHAN_CTRLr_RESERVED_3f_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11))
#define BCM56504_A0_CMIC_SCHAN_CTRLr_MIIM_SCAN_BUSYf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 14) & 0x1)
#define BCM56504_A0_CMIC_SCHAN_CTRLr_MIIM_SCAN_BUSYf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM56504_A0_CMIC_SCHAN_CTRLr_RESERVED_4f_GET(r) ((((r).cmic_schan_ctrl[0]) >> 15) & 0x1)
#define BCM56504_A0_CMIC_SCHAN_CTRLr_RESERVED_4f_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56504_A0_CMIC_SCHAN_CTRLr_MIIM_RD_STARTf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 16) & 0x1)
#define BCM56504_A0_CMIC_SCHAN_CTRLr_MIIM_RD_STARTf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56504_A0_CMIC_SCHAN_CTRLr_MIIM_WR_STARTf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 17) & 0x1)
#define BCM56504_A0_CMIC_SCHAN_CTRLr_MIIM_WR_STARTf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56504_A0_CMIC_SCHAN_CTRLr_MIIM_OP_DONEf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 18) & 0x1)
#define BCM56504_A0_CMIC_SCHAN_CTRLr_MIIM_OP_DONEf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56504_A0_CMIC_SCHAN_CTRLr_MIIM_LINK_SCAN_ENf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 19) & 0x1)
#define BCM56504_A0_CMIC_SCHAN_CTRLr_MIIM_LINK_SCAN_ENf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56504_A0_CMIC_SCHAN_CTRLr_RESERVED_5f_GET(r) ((((r).cmic_schan_ctrl[0]) >> 20) & 0x1)
#define BCM56504_A0_CMIC_SCHAN_CTRLr_RESERVED_5f_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM56504_A0_CMIC_SCHAN_CTRLr_NACKf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 21) & 0x1)
#define BCM56504_A0_CMIC_SCHAN_CTRLr_NACKf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM56504_A0_CMIC_SCHAN_CTRLr_TIMEOUTf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 22) & 0x1)
#define BCM56504_A0_CMIC_SCHAN_CTRLr_TIMEOUTf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM56504_A0_CMIC_SCHAN_CTRLr_BIT_POSf_GET(r) (((r).cmic_schan_ctrl[0]) & 0x1f)
#define BCM56504_A0_CMIC_SCHAN_CTRLr_BIT_POSf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56504_A0_CMIC_SCHAN_CTRLr_BIT_VALf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 7) & 0x1)
#define BCM56504_A0_CMIC_SCHAN_CTRLr_BIT_VALf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56504_A0_CMIC_SCHAN_CTRLr_RESERVED_6f_GET(r) ((((r).cmic_schan_ctrl[0]) >> 22) & 0x3ff)
#define BCM56504_A0_CMIC_SCHAN_CTRLr_RESERVED_6f_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x3ff << 22)) | ((((uint32_t)f) & 0x3ff) << 22))

/*
 * These macros can be used to access CMIC_SCHAN_CTRL.
 *
 */
#define BCM56504_A0_READ_CMIC_SCHAN_CTRLr(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_SCHAN_CTRLr,r._cmic_schan_ctrl)
#define BCM56504_A0_WRITE_CMIC_SCHAN_CTRLr(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_SCHAN_CTRLr,r._cmic_schan_ctrl)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_SCHAN_CTRLr BCM56504_A0_CMIC_SCHAN_CTRLr
#define CMIC_SCHAN_CTRLr_SIZE BCM56504_A0_CMIC_SCHAN_CTRLr_SIZE
typedef BCM56504_A0_CMIC_SCHAN_CTRLr_t CMIC_SCHAN_CTRLr_t;
#define CMIC_SCHAN_CTRLr_CLR BCM56504_A0_CMIC_SCHAN_CTRLr_CLR
#define CMIC_SCHAN_CTRLr_SET BCM56504_A0_CMIC_SCHAN_CTRLr_SET
#define CMIC_SCHAN_CTRLr_GET BCM56504_A0_CMIC_SCHAN_CTRLr_GET
#define CMIC_SCHAN_CTRLr_MSG_STARTf_GET BCM56504_A0_CMIC_SCHAN_CTRLr_MSG_STARTf_GET
#define CMIC_SCHAN_CTRLr_MSG_STARTf_SET BCM56504_A0_CMIC_SCHAN_CTRLr_MSG_STARTf_SET
#define CMIC_SCHAN_CTRLr_MSG_DONEf_GET BCM56504_A0_CMIC_SCHAN_CTRLr_MSG_DONEf_GET
#define CMIC_SCHAN_CTRLr_MSG_DONEf_SET BCM56504_A0_CMIC_SCHAN_CTRLr_MSG_DONEf_SET
#define CMIC_SCHAN_CTRLr_RESERVED_1f_GET BCM56504_A0_CMIC_SCHAN_CTRLr_RESERVED_1f_GET
#define CMIC_SCHAN_CTRLr_RESERVED_1f_SET BCM56504_A0_CMIC_SCHAN_CTRLr_RESERVED_1f_SET
#define CMIC_SCHAN_CTRLr_LINK_STATUS_CHANGEf_GET BCM56504_A0_CMIC_SCHAN_CTRLr_LINK_STATUS_CHANGEf_GET
#define CMIC_SCHAN_CTRLr_LINK_STATUS_CHANGEf_SET BCM56504_A0_CMIC_SCHAN_CTRLr_LINK_STATUS_CHANGEf_SET
#define CMIC_SCHAN_CTRLr_PCI_FATAL_ERRf_GET BCM56504_A0_CMIC_SCHAN_CTRLr_PCI_FATAL_ERRf_GET
#define CMIC_SCHAN_CTRLr_PCI_FATAL_ERRf_SET BCM56504_A0_CMIC_SCHAN_CTRLr_PCI_FATAL_ERRf_SET
#define CMIC_SCHAN_CTRLr_PCI_PARITY_ERRf_GET BCM56504_A0_CMIC_SCHAN_CTRLr_PCI_PARITY_ERRf_GET
#define CMIC_SCHAN_CTRLr_PCI_PARITY_ERRf_SET BCM56504_A0_CMIC_SCHAN_CTRLr_PCI_PARITY_ERRf_SET
#define CMIC_SCHAN_CTRLr_RESERVED_3f_GET BCM56504_A0_CMIC_SCHAN_CTRLr_RESERVED_3f_GET
#define CMIC_SCHAN_CTRLr_RESERVED_3f_SET BCM56504_A0_CMIC_SCHAN_CTRLr_RESERVED_3f_SET
#define CMIC_SCHAN_CTRLr_MIIM_SCAN_BUSYf_GET BCM56504_A0_CMIC_SCHAN_CTRLr_MIIM_SCAN_BUSYf_GET
#define CMIC_SCHAN_CTRLr_MIIM_SCAN_BUSYf_SET BCM56504_A0_CMIC_SCHAN_CTRLr_MIIM_SCAN_BUSYf_SET
#define CMIC_SCHAN_CTRLr_RESERVED_4f_GET BCM56504_A0_CMIC_SCHAN_CTRLr_RESERVED_4f_GET
#define CMIC_SCHAN_CTRLr_RESERVED_4f_SET BCM56504_A0_CMIC_SCHAN_CTRLr_RESERVED_4f_SET
#define CMIC_SCHAN_CTRLr_MIIM_RD_STARTf_GET BCM56504_A0_CMIC_SCHAN_CTRLr_MIIM_RD_STARTf_GET
#define CMIC_SCHAN_CTRLr_MIIM_RD_STARTf_SET BCM56504_A0_CMIC_SCHAN_CTRLr_MIIM_RD_STARTf_SET
#define CMIC_SCHAN_CTRLr_MIIM_WR_STARTf_GET BCM56504_A0_CMIC_SCHAN_CTRLr_MIIM_WR_STARTf_GET
#define CMIC_SCHAN_CTRLr_MIIM_WR_STARTf_SET BCM56504_A0_CMIC_SCHAN_CTRLr_MIIM_WR_STARTf_SET
#define CMIC_SCHAN_CTRLr_MIIM_OP_DONEf_GET BCM56504_A0_CMIC_SCHAN_CTRLr_MIIM_OP_DONEf_GET
#define CMIC_SCHAN_CTRLr_MIIM_OP_DONEf_SET BCM56504_A0_CMIC_SCHAN_CTRLr_MIIM_OP_DONEf_SET
#define CMIC_SCHAN_CTRLr_MIIM_LINK_SCAN_ENf_GET BCM56504_A0_CMIC_SCHAN_CTRLr_MIIM_LINK_SCAN_ENf_GET
#define CMIC_SCHAN_CTRLr_MIIM_LINK_SCAN_ENf_SET BCM56504_A0_CMIC_SCHAN_CTRLr_MIIM_LINK_SCAN_ENf_SET
#define CMIC_SCHAN_CTRLr_RESERVED_5f_GET BCM56504_A0_CMIC_SCHAN_CTRLr_RESERVED_5f_GET
#define CMIC_SCHAN_CTRLr_RESERVED_5f_SET BCM56504_A0_CMIC_SCHAN_CTRLr_RESERVED_5f_SET
#define CMIC_SCHAN_CTRLr_NACKf_GET BCM56504_A0_CMIC_SCHAN_CTRLr_NACKf_GET
#define CMIC_SCHAN_CTRLr_NACKf_SET BCM56504_A0_CMIC_SCHAN_CTRLr_NACKf_SET
#define CMIC_SCHAN_CTRLr_TIMEOUTf_GET BCM56504_A0_CMIC_SCHAN_CTRLr_TIMEOUTf_GET
#define CMIC_SCHAN_CTRLr_TIMEOUTf_SET BCM56504_A0_CMIC_SCHAN_CTRLr_TIMEOUTf_SET
#define CMIC_SCHAN_CTRLr_BIT_POSf_GET BCM56504_A0_CMIC_SCHAN_CTRLr_BIT_POSf_GET
#define CMIC_SCHAN_CTRLr_BIT_POSf_SET BCM56504_A0_CMIC_SCHAN_CTRLr_BIT_POSf_SET
#define CMIC_SCHAN_CTRLr_BIT_VALf_GET BCM56504_A0_CMIC_SCHAN_CTRLr_BIT_VALf_GET
#define CMIC_SCHAN_CTRLr_BIT_VALf_SET BCM56504_A0_CMIC_SCHAN_CTRLr_BIT_VALf_SET
#define CMIC_SCHAN_CTRLr_RESERVED_6f_GET BCM56504_A0_CMIC_SCHAN_CTRLr_RESERVED_6f_GET
#define CMIC_SCHAN_CTRLr_RESERVED_6f_SET BCM56504_A0_CMIC_SCHAN_CTRLr_RESERVED_6f_SET
#define READ_CMIC_SCHAN_CTRLr BCM56504_A0_READ_CMIC_SCHAN_CTRLr
#define WRITE_CMIC_SCHAN_CTRLr BCM56504_A0_WRITE_CMIC_SCHAN_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_SCHAN_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_SCHAN_ERR
 * BLOCKS:   CMIC
 * DESC:     Error Status Register
 * SIZE:     32
 * FIELDS:
 *     NACK             When set, indicates the last S-bus command resulted in an NACK(i.e., could not be fulfilled due to hardware resource limitations).
 *     RESERVED_1       Reserved
 *     ERR_CODE         Error code in the SCH Error message
 *     ERRBIT           When set, indicates the last S-bus command resulted in an error(i.e., the command was illegal, or accessed an invalid address)
 *     DATA_LEN         Data length in the SCH Error ACK message
 *     SRC_PORT         Source port in the SCH Error ACK message(not guaranteed to be set by all blocks)
 *     DST_PORT         Dest port in the SCH Error ACK message
 *     OP_CODE          Opcode in the SCH Error ACK message
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_SCHAN_ERRr 0x0000005c

#define BCM56504_A0_CMIC_SCHAN_ERRr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SCHAN_ERR.
 *
 */
typedef union BCM56504_A0_CMIC_SCHAN_ERRr_s {
	uint32_t v[1];
	uint32_t cmic_schan_err[1];
	uint32_t _cmic_schan_err;
} BCM56504_A0_CMIC_SCHAN_ERRr_t;

#define BCM56504_A0_CMIC_SCHAN_ERRr_CLR(r) (r).cmic_schan_err[0] = 0
#define BCM56504_A0_CMIC_SCHAN_ERRr_SET(r,d) (r).cmic_schan_err[0] = d
#define BCM56504_A0_CMIC_SCHAN_ERRr_GET(r) (r).cmic_schan_err[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_SCHAN_ERRr_NACKf_GET(r) (((r).cmic_schan_err[0]) & 0x1)
#define BCM56504_A0_CMIC_SCHAN_ERRr_NACKf_SET(r,f) (r).cmic_schan_err[0]=(((r).cmic_schan_err[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_CMIC_SCHAN_ERRr_RESERVED_1f_GET(r) ((((r).cmic_schan_err[0]) >> 1) & 0x7)
#define BCM56504_A0_CMIC_SCHAN_ERRr_RESERVED_1f_SET(r,f) (r).cmic_schan_err[0]=(((r).cmic_schan_err[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define BCM56504_A0_CMIC_SCHAN_ERRr_ERR_CODEf_GET(r) ((((r).cmic_schan_err[0]) >> 4) & 0x3)
#define BCM56504_A0_CMIC_SCHAN_ERRr_ERR_CODEf_SET(r,f) (r).cmic_schan_err[0]=(((r).cmic_schan_err[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM56504_A0_CMIC_SCHAN_ERRr_ERRBITf_GET(r) ((((r).cmic_schan_err[0]) >> 6) & 0x1)
#define BCM56504_A0_CMIC_SCHAN_ERRr_ERRBITf_SET(r,f) (r).cmic_schan_err[0]=(((r).cmic_schan_err[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56504_A0_CMIC_SCHAN_ERRr_DATA_LENf_GET(r) ((((r).cmic_schan_err[0]) >> 7) & 0x7f)
#define BCM56504_A0_CMIC_SCHAN_ERRr_DATA_LENf_SET(r,f) (r).cmic_schan_err[0]=(((r).cmic_schan_err[0] & ~((uint32_t)0x7f << 7)) | ((((uint32_t)f) & 0x7f) << 7))
#define BCM56504_A0_CMIC_SCHAN_ERRr_SRC_PORTf_GET(r) ((((r).cmic_schan_err[0]) >> 14) & 0x3f)
#define BCM56504_A0_CMIC_SCHAN_ERRr_SRC_PORTf_SET(r,f) (r).cmic_schan_err[0]=(((r).cmic_schan_err[0] & ~((uint32_t)0x3f << 14)) | ((((uint32_t)f) & 0x3f) << 14))
#define BCM56504_A0_CMIC_SCHAN_ERRr_DST_PORTf_GET(r) ((((r).cmic_schan_err[0]) >> 20) & 0x3f)
#define BCM56504_A0_CMIC_SCHAN_ERRr_DST_PORTf_SET(r,f) (r).cmic_schan_err[0]=(((r).cmic_schan_err[0] & ~((uint32_t)0x3f << 20)) | ((((uint32_t)f) & 0x3f) << 20))
#define BCM56504_A0_CMIC_SCHAN_ERRr_OP_CODEf_GET(r) ((((r).cmic_schan_err[0]) >> 26) & 0x3f)
#define BCM56504_A0_CMIC_SCHAN_ERRr_OP_CODEf_SET(r,f) (r).cmic_schan_err[0]=(((r).cmic_schan_err[0] & ~((uint32_t)0x3f << 26)) | ((((uint32_t)f) & 0x3f) << 26))

/*
 * These macros can be used to access CMIC_SCHAN_ERR.
 *
 */
#define BCM56504_A0_READ_CMIC_SCHAN_ERRr(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_SCHAN_ERRr,r._cmic_schan_err)
#define BCM56504_A0_WRITE_CMIC_SCHAN_ERRr(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_SCHAN_ERRr,r._cmic_schan_err)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_SCHAN_ERRr BCM56504_A0_CMIC_SCHAN_ERRr
#define CMIC_SCHAN_ERRr_SIZE BCM56504_A0_CMIC_SCHAN_ERRr_SIZE
typedef BCM56504_A0_CMIC_SCHAN_ERRr_t CMIC_SCHAN_ERRr_t;
#define CMIC_SCHAN_ERRr_CLR BCM56504_A0_CMIC_SCHAN_ERRr_CLR
#define CMIC_SCHAN_ERRr_SET BCM56504_A0_CMIC_SCHAN_ERRr_SET
#define CMIC_SCHAN_ERRr_GET BCM56504_A0_CMIC_SCHAN_ERRr_GET
#define CMIC_SCHAN_ERRr_NACKf_GET BCM56504_A0_CMIC_SCHAN_ERRr_NACKf_GET
#define CMIC_SCHAN_ERRr_NACKf_SET BCM56504_A0_CMIC_SCHAN_ERRr_NACKf_SET
#define CMIC_SCHAN_ERRr_RESERVED_1f_GET BCM56504_A0_CMIC_SCHAN_ERRr_RESERVED_1f_GET
#define CMIC_SCHAN_ERRr_RESERVED_1f_SET BCM56504_A0_CMIC_SCHAN_ERRr_RESERVED_1f_SET
#define CMIC_SCHAN_ERRr_ERR_CODEf_GET BCM56504_A0_CMIC_SCHAN_ERRr_ERR_CODEf_GET
#define CMIC_SCHAN_ERRr_ERR_CODEf_SET BCM56504_A0_CMIC_SCHAN_ERRr_ERR_CODEf_SET
#define CMIC_SCHAN_ERRr_ERRBITf_GET BCM56504_A0_CMIC_SCHAN_ERRr_ERRBITf_GET
#define CMIC_SCHAN_ERRr_ERRBITf_SET BCM56504_A0_CMIC_SCHAN_ERRr_ERRBITf_SET
#define CMIC_SCHAN_ERRr_DATA_LENf_GET BCM56504_A0_CMIC_SCHAN_ERRr_DATA_LENf_GET
#define CMIC_SCHAN_ERRr_DATA_LENf_SET BCM56504_A0_CMIC_SCHAN_ERRr_DATA_LENf_SET
#define CMIC_SCHAN_ERRr_SRC_PORTf_GET BCM56504_A0_CMIC_SCHAN_ERRr_SRC_PORTf_GET
#define CMIC_SCHAN_ERRr_SRC_PORTf_SET BCM56504_A0_CMIC_SCHAN_ERRr_SRC_PORTf_SET
#define CMIC_SCHAN_ERRr_DST_PORTf_GET BCM56504_A0_CMIC_SCHAN_ERRr_DST_PORTf_GET
#define CMIC_SCHAN_ERRr_DST_PORTf_SET BCM56504_A0_CMIC_SCHAN_ERRr_DST_PORTf_SET
#define CMIC_SCHAN_ERRr_OP_CODEf_GET BCM56504_A0_CMIC_SCHAN_ERRr_OP_CODEf_GET
#define CMIC_SCHAN_ERRr_OP_CODEf_SET BCM56504_A0_CMIC_SCHAN_ERRr_OP_CODEf_SET
#define READ_CMIC_SCHAN_ERRr BCM56504_A0_READ_CMIC_SCHAN_ERRr
#define WRITE_CMIC_SCHAN_ERRr BCM56504_A0_WRITE_CMIC_SCHAN_ERRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_SCHAN_ERRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_SCHAN_MESSAGE
 * BLOCKS:   CMIC
 * DESC:     S-bus PIO Message Register Set
 * SIZE:     32
 * FIELDS:
 *     DATA             S-channel data (Rd/Wr) word
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_SCHAN_MESSAGEr 0x00000000

#define BCM56504_A0_CMIC_SCHAN_MESSAGEr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SCHAN_MESSAGE.
 *
 */
typedef union BCM56504_A0_CMIC_SCHAN_MESSAGEr_s {
	uint32_t v[1];
	uint32_t cmic_schan_message[1];
	uint32_t _cmic_schan_message;
} BCM56504_A0_CMIC_SCHAN_MESSAGEr_t;

#define BCM56504_A0_CMIC_SCHAN_MESSAGEr_CLR(r) (r).cmic_schan_message[0] = 0
#define BCM56504_A0_CMIC_SCHAN_MESSAGEr_SET(r,d) (r).cmic_schan_message[0] = d
#define BCM56504_A0_CMIC_SCHAN_MESSAGEr_GET(r) (r).cmic_schan_message[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_SCHAN_MESSAGEr_DATAf_GET(r) ((r).cmic_schan_message[0])
#define BCM56504_A0_CMIC_SCHAN_MESSAGEr_DATAf_SET(r,f) (r).cmic_schan_message[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_SCHAN_MESSAGE.
 *
 */
#define BCM56504_A0_READ_CMIC_SCHAN_MESSAGEr(u,i,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_SCHAN_MESSAGEr+(4*(i)),r._cmic_schan_message)
#define BCM56504_A0_WRITE_CMIC_SCHAN_MESSAGEr(u,i,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_SCHAN_MESSAGEr+(4*(i)),r._cmic_schan_message)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_SCHAN_MESSAGEr BCM56504_A0_CMIC_SCHAN_MESSAGEr
#define CMIC_SCHAN_MESSAGEr_SIZE BCM56504_A0_CMIC_SCHAN_MESSAGEr_SIZE
typedef BCM56504_A0_CMIC_SCHAN_MESSAGEr_t CMIC_SCHAN_MESSAGEr_t;
#define CMIC_SCHAN_MESSAGEr_CLR BCM56504_A0_CMIC_SCHAN_MESSAGEr_CLR
#define CMIC_SCHAN_MESSAGEr_SET BCM56504_A0_CMIC_SCHAN_MESSAGEr_SET
#define CMIC_SCHAN_MESSAGEr_GET BCM56504_A0_CMIC_SCHAN_MESSAGEr_GET
#define CMIC_SCHAN_MESSAGEr_DATAf_GET BCM56504_A0_CMIC_SCHAN_MESSAGEr_DATAf_GET
#define CMIC_SCHAN_MESSAGEr_DATAf_SET BCM56504_A0_CMIC_SCHAN_MESSAGEr_DATAf_SET
#define READ_CMIC_SCHAN_MESSAGEr BCM56504_A0_READ_CMIC_SCHAN_MESSAGEr
#define WRITE_CMIC_SCHAN_MESSAGEr BCM56504_A0_WRITE_CMIC_SCHAN_MESSAGEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_SCHAN_MESSAGEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_SCHAN_MESSAGE_EXT
 * BLOCKS:   CMIC
 * DESC:     S-bus PIO Message Register Set (extended)
 * SIZE:     32
 * FIELDS:
 *     DATA             S-channel data (Rd/Wr) word
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_SCHAN_MESSAGE_EXTr 0x00000800

#define BCM56504_A0_CMIC_SCHAN_MESSAGE_EXTr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SCHAN_MESSAGE_EXT.
 *
 */
typedef union BCM56504_A0_CMIC_SCHAN_MESSAGE_EXTr_s {
	uint32_t v[1];
	uint32_t cmic_schan_message_ext[1];
	uint32_t _cmic_schan_message_ext;
} BCM56504_A0_CMIC_SCHAN_MESSAGE_EXTr_t;

#define BCM56504_A0_CMIC_SCHAN_MESSAGE_EXTr_CLR(r) (r).cmic_schan_message_ext[0] = 0
#define BCM56504_A0_CMIC_SCHAN_MESSAGE_EXTr_SET(r,d) (r).cmic_schan_message_ext[0] = d
#define BCM56504_A0_CMIC_SCHAN_MESSAGE_EXTr_GET(r) (r).cmic_schan_message_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_SCHAN_MESSAGE_EXTr_DATAf_GET(r) ((r).cmic_schan_message_ext[0])
#define BCM56504_A0_CMIC_SCHAN_MESSAGE_EXTr_DATAf_SET(r,f) (r).cmic_schan_message_ext[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_SCHAN_MESSAGE_EXT.
 *
 */
#define BCM56504_A0_READ_CMIC_SCHAN_MESSAGE_EXTr(u,i,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_SCHAN_MESSAGE_EXTr+(4*(i)),r._cmic_schan_message_ext)
#define BCM56504_A0_WRITE_CMIC_SCHAN_MESSAGE_EXTr(u,i,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_SCHAN_MESSAGE_EXTr+(4*(i)),r._cmic_schan_message_ext)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_SCHAN_MESSAGE_EXTr BCM56504_A0_CMIC_SCHAN_MESSAGE_EXTr
#define CMIC_SCHAN_MESSAGE_EXTr_SIZE BCM56504_A0_CMIC_SCHAN_MESSAGE_EXTr_SIZE
typedef BCM56504_A0_CMIC_SCHAN_MESSAGE_EXTr_t CMIC_SCHAN_MESSAGE_EXTr_t;
#define CMIC_SCHAN_MESSAGE_EXTr_CLR BCM56504_A0_CMIC_SCHAN_MESSAGE_EXTr_CLR
#define CMIC_SCHAN_MESSAGE_EXTr_SET BCM56504_A0_CMIC_SCHAN_MESSAGE_EXTr_SET
#define CMIC_SCHAN_MESSAGE_EXTr_GET BCM56504_A0_CMIC_SCHAN_MESSAGE_EXTr_GET
#define CMIC_SCHAN_MESSAGE_EXTr_DATAf_GET BCM56504_A0_CMIC_SCHAN_MESSAGE_EXTr_DATAf_GET
#define CMIC_SCHAN_MESSAGE_EXTr_DATAf_SET BCM56504_A0_CMIC_SCHAN_MESSAGE_EXTr_DATAf_SET
#define READ_CMIC_SCHAN_MESSAGE_EXTr BCM56504_A0_READ_CMIC_SCHAN_MESSAGE_EXTr
#define WRITE_CMIC_SCHAN_MESSAGE_EXTr BCM56504_A0_WRITE_CMIC_SCHAN_MESSAGE_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_SCHAN_MESSAGE_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_SLAM_DMA_CFG
 * BLOCKS:   CMIC
 * DESC:     Slam DMA Config Register
 * SIZE:     32
 * FIELDS:
 *     EN               Set by CPU to Enable Slam DMA Transfer
 *     ABORT            Set by CPU to Abort Slam DMA Transfer
 *     DONE             Set by CMIC to indicate Slam DMA Transfer CompletionCan be cleared (but not set) by CPU.
 *     ERROR            Set by CMIC to indicate Slam DMA Transfer wasaborted due to an error (most probably due to a NACK).Can be cleared (but not set) by CPU.
 *     RESERVED_1       Reserved
 *     BEATS            Written by CPU indicating number of data beats.For Slam DMA purposes, each table entry is 32-bit aligned.The widest S-bus table wr/rd supported is 640 bits.So, the valid values for this field are 1-20 (beats).
 *     ORDER            Set by CPU to specify Slam DMA order:'0' =>  forward (used for DELETE operations)'1' => backward (used for INSERT operations)
 *     REV_MODULO_COUNT Set by CPU to specify 'Entry count for the first iteration ofa Reverse Slam DMA operation'. The formula for this value is:( CMIC_SLAM_DMA_ENTRY_COUNT[23:0] % ( 64 / BEATS[4:0] ) )
 *     RESERVED_2       Reserved
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_SLAM_DMA_CFGr 0x0000044c

#define BCM56504_A0_CMIC_SLAM_DMA_CFGr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SLAM_DMA_CFG.
 *
 */
typedef union BCM56504_A0_CMIC_SLAM_DMA_CFGr_s {
	uint32_t v[1];
	uint32_t cmic_slam_dma_cfg[1];
	uint32_t _cmic_slam_dma_cfg;
} BCM56504_A0_CMIC_SLAM_DMA_CFGr_t;

#define BCM56504_A0_CMIC_SLAM_DMA_CFGr_CLR(r) (r).cmic_slam_dma_cfg[0] = 0
#define BCM56504_A0_CMIC_SLAM_DMA_CFGr_SET(r,d) (r).cmic_slam_dma_cfg[0] = d
#define BCM56504_A0_CMIC_SLAM_DMA_CFGr_GET(r) (r).cmic_slam_dma_cfg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_SLAM_DMA_CFGr_ENf_GET(r) (((r).cmic_slam_dma_cfg[0]) & 0x1)
#define BCM56504_A0_CMIC_SLAM_DMA_CFGr_ENf_SET(r,f) (r).cmic_slam_dma_cfg[0]=(((r).cmic_slam_dma_cfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_CMIC_SLAM_DMA_CFGr_ABORTf_GET(r) ((((r).cmic_slam_dma_cfg[0]) >> 1) & 0x1)
#define BCM56504_A0_CMIC_SLAM_DMA_CFGr_ABORTf_SET(r,f) (r).cmic_slam_dma_cfg[0]=(((r).cmic_slam_dma_cfg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_CMIC_SLAM_DMA_CFGr_DONEf_GET(r) ((((r).cmic_slam_dma_cfg[0]) >> 2) & 0x1)
#define BCM56504_A0_CMIC_SLAM_DMA_CFGr_DONEf_SET(r,f) (r).cmic_slam_dma_cfg[0]=(((r).cmic_slam_dma_cfg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_CMIC_SLAM_DMA_CFGr_ERRORf_GET(r) ((((r).cmic_slam_dma_cfg[0]) >> 3) & 0x1)
#define BCM56504_A0_CMIC_SLAM_DMA_CFGr_ERRORf_SET(r,f) (r).cmic_slam_dma_cfg[0]=(((r).cmic_slam_dma_cfg[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_CMIC_SLAM_DMA_CFGr_RESERVED_1f_GET(r) ((((r).cmic_slam_dma_cfg[0]) >> 4) & 0xfff)
#define BCM56504_A0_CMIC_SLAM_DMA_CFGr_RESERVED_1f_SET(r,f) (r).cmic_slam_dma_cfg[0]=(((r).cmic_slam_dma_cfg[0] & ~((uint32_t)0xfff << 4)) | ((((uint32_t)f) & 0xfff) << 4))
#define BCM56504_A0_CMIC_SLAM_DMA_CFGr_BEATSf_GET(r) ((((r).cmic_slam_dma_cfg[0]) >> 16) & 0x1f)
#define BCM56504_A0_CMIC_SLAM_DMA_CFGr_BEATSf_SET(r,f) (r).cmic_slam_dma_cfg[0]=(((r).cmic_slam_dma_cfg[0] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define BCM56504_A0_CMIC_SLAM_DMA_CFGr_ORDERf_GET(r) ((((r).cmic_slam_dma_cfg[0]) >> 21) & 0x1)
#define BCM56504_A0_CMIC_SLAM_DMA_CFGr_ORDERf_SET(r,f) (r).cmic_slam_dma_cfg[0]=(((r).cmic_slam_dma_cfg[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM56504_A0_CMIC_SLAM_DMA_CFGr_REV_MODULO_COUNTf_GET(r) ((((r).cmic_slam_dma_cfg[0]) >> 22) & 0x3f)
#define BCM56504_A0_CMIC_SLAM_DMA_CFGr_REV_MODULO_COUNTf_SET(r,f) (r).cmic_slam_dma_cfg[0]=(((r).cmic_slam_dma_cfg[0] & ~((uint32_t)0x3f << 22)) | ((((uint32_t)f) & 0x3f) << 22))
#define BCM56504_A0_CMIC_SLAM_DMA_CFGr_RESERVED_2f_GET(r) ((((r).cmic_slam_dma_cfg[0]) >> 28) & 0xf)
#define BCM56504_A0_CMIC_SLAM_DMA_CFGr_RESERVED_2f_SET(r,f) (r).cmic_slam_dma_cfg[0]=(((r).cmic_slam_dma_cfg[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access CMIC_SLAM_DMA_CFG.
 *
 */
#define BCM56504_A0_READ_CMIC_SLAM_DMA_CFGr(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_SLAM_DMA_CFGr,r._cmic_slam_dma_cfg)
#define BCM56504_A0_WRITE_CMIC_SLAM_DMA_CFGr(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_SLAM_DMA_CFGr,r._cmic_slam_dma_cfg)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_SLAM_DMA_CFGr BCM56504_A0_CMIC_SLAM_DMA_CFGr
#define CMIC_SLAM_DMA_CFGr_SIZE BCM56504_A0_CMIC_SLAM_DMA_CFGr_SIZE
typedef BCM56504_A0_CMIC_SLAM_DMA_CFGr_t CMIC_SLAM_DMA_CFGr_t;
#define CMIC_SLAM_DMA_CFGr_CLR BCM56504_A0_CMIC_SLAM_DMA_CFGr_CLR
#define CMIC_SLAM_DMA_CFGr_SET BCM56504_A0_CMIC_SLAM_DMA_CFGr_SET
#define CMIC_SLAM_DMA_CFGr_GET BCM56504_A0_CMIC_SLAM_DMA_CFGr_GET
#define CMIC_SLAM_DMA_CFGr_ENf_GET BCM56504_A0_CMIC_SLAM_DMA_CFGr_ENf_GET
#define CMIC_SLAM_DMA_CFGr_ENf_SET BCM56504_A0_CMIC_SLAM_DMA_CFGr_ENf_SET
#define CMIC_SLAM_DMA_CFGr_ABORTf_GET BCM56504_A0_CMIC_SLAM_DMA_CFGr_ABORTf_GET
#define CMIC_SLAM_DMA_CFGr_ABORTf_SET BCM56504_A0_CMIC_SLAM_DMA_CFGr_ABORTf_SET
#define CMIC_SLAM_DMA_CFGr_DONEf_GET BCM56504_A0_CMIC_SLAM_DMA_CFGr_DONEf_GET
#define CMIC_SLAM_DMA_CFGr_DONEf_SET BCM56504_A0_CMIC_SLAM_DMA_CFGr_DONEf_SET
#define CMIC_SLAM_DMA_CFGr_ERRORf_GET BCM56504_A0_CMIC_SLAM_DMA_CFGr_ERRORf_GET
#define CMIC_SLAM_DMA_CFGr_ERRORf_SET BCM56504_A0_CMIC_SLAM_DMA_CFGr_ERRORf_SET
#define CMIC_SLAM_DMA_CFGr_RESERVED_1f_GET BCM56504_A0_CMIC_SLAM_DMA_CFGr_RESERVED_1f_GET
#define CMIC_SLAM_DMA_CFGr_RESERVED_1f_SET BCM56504_A0_CMIC_SLAM_DMA_CFGr_RESERVED_1f_SET
#define CMIC_SLAM_DMA_CFGr_BEATSf_GET BCM56504_A0_CMIC_SLAM_DMA_CFGr_BEATSf_GET
#define CMIC_SLAM_DMA_CFGr_BEATSf_SET BCM56504_A0_CMIC_SLAM_DMA_CFGr_BEATSf_SET
#define CMIC_SLAM_DMA_CFGr_ORDERf_GET BCM56504_A0_CMIC_SLAM_DMA_CFGr_ORDERf_GET
#define CMIC_SLAM_DMA_CFGr_ORDERf_SET BCM56504_A0_CMIC_SLAM_DMA_CFGr_ORDERf_SET
#define CMIC_SLAM_DMA_CFGr_REV_MODULO_COUNTf_GET BCM56504_A0_CMIC_SLAM_DMA_CFGr_REV_MODULO_COUNTf_GET
#define CMIC_SLAM_DMA_CFGr_REV_MODULO_COUNTf_SET BCM56504_A0_CMIC_SLAM_DMA_CFGr_REV_MODULO_COUNTf_SET
#define CMIC_SLAM_DMA_CFGr_RESERVED_2f_GET BCM56504_A0_CMIC_SLAM_DMA_CFGr_RESERVED_2f_GET
#define CMIC_SLAM_DMA_CFGr_RESERVED_2f_SET BCM56504_A0_CMIC_SLAM_DMA_CFGr_RESERVED_2f_SET
#define READ_CMIC_SLAM_DMA_CFGr BCM56504_A0_READ_CMIC_SLAM_DMA_CFGr
#define WRITE_CMIC_SLAM_DMA_CFGr BCM56504_A0_WRITE_CMIC_SLAM_DMA_CFGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_SLAM_DMA_CFGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDR
 * BLOCKS:   CMIC
 * DESC:     Slam DMA Current Entry S-bus Address Register
 * SIZE:     32
 * FIELDS:
 *     ADDR             Written by CMIC indicating S-bus address of the Table Entrycurrently being processed
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr 0x00000454

#define BCM56504_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDR.
 *
 */
typedef union BCM56504_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_s {
	uint32_t v[1];
	uint32_t cmic_slam_dma_cur_entry_sbus_addr[1];
	uint32_t _cmic_slam_dma_cur_entry_sbus_addr;
} BCM56504_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_t;

#define BCM56504_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_CLR(r) (r).cmic_slam_dma_cur_entry_sbus_addr[0] = 0
#define BCM56504_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_SET(r,d) (r).cmic_slam_dma_cur_entry_sbus_addr[0] = d
#define BCM56504_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_GET(r) (r).cmic_slam_dma_cur_entry_sbus_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_ADDRf_GET(r) ((r).cmic_slam_dma_cur_entry_sbus_addr[0])
#define BCM56504_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_ADDRf_SET(r,f) (r).cmic_slam_dma_cur_entry_sbus_addr[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDR.
 *
 */
#define BCM56504_A0_READ_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr,r._cmic_slam_dma_cur_entry_sbus_addr)
#define BCM56504_A0_WRITE_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr,r._cmic_slam_dma_cur_entry_sbus_addr)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr BCM56504_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr
#define CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_SIZE BCM56504_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_SIZE
typedef BCM56504_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_t CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_t;
#define CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_CLR BCM56504_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_CLR
#define CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_SET BCM56504_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_SET
#define CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_GET BCM56504_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_GET
#define CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_ADDRf_GET BCM56504_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_ADDRf_GET
#define CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_ADDRf_SET BCM56504_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_ADDRf_SET
#define READ_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr BCM56504_A0_READ_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr
#define WRITE_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr BCM56504_A0_WRITE_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_SLAM_DMA_ENTRY_COUNT
 * BLOCKS:   CMIC
 * DESC:     Slam DMA Entry Count Register
 * SIZE:     32
 * FIELDS:
 *     COUNT            Written by CPU indicating number of Slam entries for Slam DMA.
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_SLAM_DMA_ENTRY_COUNTr 0x00000448

#define BCM56504_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SLAM_DMA_ENTRY_COUNT.
 *
 */
typedef union BCM56504_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_s {
	uint32_t v[1];
	uint32_t cmic_slam_dma_entry_count[1];
	uint32_t _cmic_slam_dma_entry_count;
} BCM56504_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_t;

#define BCM56504_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_CLR(r) (r).cmic_slam_dma_entry_count[0] = 0
#define BCM56504_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_SET(r,d) (r).cmic_slam_dma_entry_count[0] = d
#define BCM56504_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_GET(r) (r).cmic_slam_dma_entry_count[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_COUNTf_GET(r) (((r).cmic_slam_dma_entry_count[0]) & 0xffffff)
#define BCM56504_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_COUNTf_SET(r,f) (r).cmic_slam_dma_entry_count[0]=(((r).cmic_slam_dma_entry_count[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))
#define BCM56504_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_RESERVED_1f_GET(r) ((((r).cmic_slam_dma_entry_count[0]) >> 24) & 0xff)
#define BCM56504_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_RESERVED_1f_SET(r,f) (r).cmic_slam_dma_entry_count[0]=(((r).cmic_slam_dma_entry_count[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access CMIC_SLAM_DMA_ENTRY_COUNT.
 *
 */
#define BCM56504_A0_READ_CMIC_SLAM_DMA_ENTRY_COUNTr(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_SLAM_DMA_ENTRY_COUNTr,r._cmic_slam_dma_entry_count)
#define BCM56504_A0_WRITE_CMIC_SLAM_DMA_ENTRY_COUNTr(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_SLAM_DMA_ENTRY_COUNTr,r._cmic_slam_dma_entry_count)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_SLAM_DMA_ENTRY_COUNTr BCM56504_A0_CMIC_SLAM_DMA_ENTRY_COUNTr
#define CMIC_SLAM_DMA_ENTRY_COUNTr_SIZE BCM56504_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_SIZE
typedef BCM56504_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_t CMIC_SLAM_DMA_ENTRY_COUNTr_t;
#define CMIC_SLAM_DMA_ENTRY_COUNTr_CLR BCM56504_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_CLR
#define CMIC_SLAM_DMA_ENTRY_COUNTr_SET BCM56504_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_SET
#define CMIC_SLAM_DMA_ENTRY_COUNTr_GET BCM56504_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_GET
#define CMIC_SLAM_DMA_ENTRY_COUNTr_COUNTf_GET BCM56504_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_COUNTf_GET
#define CMIC_SLAM_DMA_ENTRY_COUNTr_COUNTf_SET BCM56504_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_COUNTf_SET
#define CMIC_SLAM_DMA_ENTRY_COUNTr_RESERVED_1f_GET BCM56504_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_RESERVED_1f_GET
#define CMIC_SLAM_DMA_ENTRY_COUNTr_RESERVED_1f_SET BCM56504_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_RESERVED_1f_SET
#define READ_CMIC_SLAM_DMA_ENTRY_COUNTr BCM56504_A0_READ_CMIC_SLAM_DMA_ENTRY_COUNTr
#define WRITE_CMIC_SLAM_DMA_ENTRY_COUNTr BCM56504_A0_WRITE_CMIC_SLAM_DMA_ENTRY_COUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_SLAM_DMA_ENTRY_COUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_SLAM_DMA_PCIMEM_START_ADDR
 * BLOCKS:   CMIC
 * DESC:     Slam DMA PCI Memory Start Address Register

 * SIZE:     32
 * FIELDS:
 *     ADDR             Written by CPU indicating Slam DMA Physical (PCI) Memory Start Address
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr 0x00000440

#define BCM56504_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SLAM_DMA_PCIMEM_START_ADDR.
 *
 */
typedef union BCM56504_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr_s {
	uint32_t v[1];
	uint32_t cmic_slam_dma_pcimem_start_addr[1];
	uint32_t _cmic_slam_dma_pcimem_start_addr;
} BCM56504_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr_t;

#define BCM56504_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr_CLR(r) (r).cmic_slam_dma_pcimem_start_addr[0] = 0
#define BCM56504_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr_SET(r,d) (r).cmic_slam_dma_pcimem_start_addr[0] = d
#define BCM56504_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr_GET(r) (r).cmic_slam_dma_pcimem_start_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr_ADDRf_GET(r) ((r).cmic_slam_dma_pcimem_start_addr[0])
#define BCM56504_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr_ADDRf_SET(r,f) (r).cmic_slam_dma_pcimem_start_addr[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_SLAM_DMA_PCIMEM_START_ADDR.
 *
 */
#define BCM56504_A0_READ_CMIC_SLAM_DMA_PCIMEM_START_ADDRr(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr,r._cmic_slam_dma_pcimem_start_addr)
#define BCM56504_A0_WRITE_CMIC_SLAM_DMA_PCIMEM_START_ADDRr(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr,r._cmic_slam_dma_pcimem_start_addr)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_SLAM_DMA_PCIMEM_START_ADDRr BCM56504_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr
#define CMIC_SLAM_DMA_PCIMEM_START_ADDRr_SIZE BCM56504_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr_SIZE
typedef BCM56504_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr_t CMIC_SLAM_DMA_PCIMEM_START_ADDRr_t;
#define CMIC_SLAM_DMA_PCIMEM_START_ADDRr_CLR BCM56504_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr_CLR
#define CMIC_SLAM_DMA_PCIMEM_START_ADDRr_SET BCM56504_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr_SET
#define CMIC_SLAM_DMA_PCIMEM_START_ADDRr_GET BCM56504_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr_GET
#define CMIC_SLAM_DMA_PCIMEM_START_ADDRr_ADDRf_GET BCM56504_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr_ADDRf_GET
#define CMIC_SLAM_DMA_PCIMEM_START_ADDRr_ADDRf_SET BCM56504_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr_ADDRf_SET
#define READ_CMIC_SLAM_DMA_PCIMEM_START_ADDRr BCM56504_A0_READ_CMIC_SLAM_DMA_PCIMEM_START_ADDRr
#define WRITE_CMIC_SLAM_DMA_PCIMEM_START_ADDRr BCM56504_A0_WRITE_CMIC_SLAM_DMA_PCIMEM_START_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_SLAM_DMA_SBUS_START_ADDR
 * BLOCKS:   CMIC
 * DESC:     Slam DMA S-bus Start Address Register

 * SIZE:     32
 * FIELDS:
 *     ADDR             Written by CPU indicating Slam DMA Logical (S-bus) Memory Start Address. This address has the followingfields: table (6b), block (4b) and region+index (20b)
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr 0x00000444

#define BCM56504_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SLAM_DMA_SBUS_START_ADDR.
 *
 */
typedef union BCM56504_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr_s {
	uint32_t v[1];
	uint32_t cmic_slam_dma_sbus_start_addr[1];
	uint32_t _cmic_slam_dma_sbus_start_addr;
} BCM56504_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr_t;

#define BCM56504_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr_CLR(r) (r).cmic_slam_dma_sbus_start_addr[0] = 0
#define BCM56504_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr_SET(r,d) (r).cmic_slam_dma_sbus_start_addr[0] = d
#define BCM56504_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr_GET(r) (r).cmic_slam_dma_sbus_start_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr_ADDRf_GET(r) ((r).cmic_slam_dma_sbus_start_addr[0])
#define BCM56504_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr_ADDRf_SET(r,f) (r).cmic_slam_dma_sbus_start_addr[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_SLAM_DMA_SBUS_START_ADDR.
 *
 */
#define BCM56504_A0_READ_CMIC_SLAM_DMA_SBUS_START_ADDRr(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr,r._cmic_slam_dma_sbus_start_addr)
#define BCM56504_A0_WRITE_CMIC_SLAM_DMA_SBUS_START_ADDRr(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr,r._cmic_slam_dma_sbus_start_addr)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_SLAM_DMA_SBUS_START_ADDRr BCM56504_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr
#define CMIC_SLAM_DMA_SBUS_START_ADDRr_SIZE BCM56504_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr_SIZE
typedef BCM56504_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr_t CMIC_SLAM_DMA_SBUS_START_ADDRr_t;
#define CMIC_SLAM_DMA_SBUS_START_ADDRr_CLR BCM56504_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr_CLR
#define CMIC_SLAM_DMA_SBUS_START_ADDRr_SET BCM56504_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr_SET
#define CMIC_SLAM_DMA_SBUS_START_ADDRr_GET BCM56504_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr_GET
#define CMIC_SLAM_DMA_SBUS_START_ADDRr_ADDRf_GET BCM56504_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr_ADDRf_GET
#define CMIC_SLAM_DMA_SBUS_START_ADDRr_ADDRf_SET BCM56504_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr_ADDRf_SET
#define READ_CMIC_SLAM_DMA_SBUS_START_ADDRr BCM56504_A0_READ_CMIC_SLAM_DMA_SBUS_START_ADDRr
#define WRITE_CMIC_SLAM_DMA_SBUS_START_ADDRr BCM56504_A0_WRITE_CMIC_SLAM_DMA_SBUS_START_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_SOFT_RESET_REG
 * BLOCKS:   CMIC
 * DESC:     CMIC Soft Reset register
 * SIZE:     32
 * FIELDS:
 *     CMIC_GP_RST_L    Gport Reset (active low)
 *     CMIC_GX4_RST_L   GX4 Reset (active low)
 *     RESERVED_0       Reserved
 *     CMIC_XP_RST_L    Xport Reset (active low)
 *     CMIC_XGXS_RST_L  XGXS Reset (active low)
 *     CMIC_MMU_RST_L   MMU Reset (active low)
 *     CMIC_IP_RST_L    IP Reset (active low)
 *     RESERVED_1       Reserved
 *     CMIC_EP_RST_L    EP Reset (active low)
 *     RESERVED_2       Reserved
 *     CMIC_BSAFE_RST_L BSafe Reset (active low)
 *     CMIC_BSAFE_CLKGEN_RST_L BSafe Clkgen Reset (active low)
 *     RESERVED_3       Reserved
 *     CMIC_XG_PLL_RST_L XG PLL Reset (active low)
 *     RESERVED_4       Reserved
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_SOFT_RESET_REGr 0x00000580

#define BCM56504_A0_CMIC_SOFT_RESET_REGr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SOFT_RESET_REG.
 *
 */
typedef union BCM56504_A0_CMIC_SOFT_RESET_REGr_s {
	uint32_t v[1];
	uint32_t cmic_soft_reset_reg[1];
	uint32_t _cmic_soft_reset_reg;
} BCM56504_A0_CMIC_SOFT_RESET_REGr_t;

#define BCM56504_A0_CMIC_SOFT_RESET_REGr_CLR(r) (r).cmic_soft_reset_reg[0] = 0
#define BCM56504_A0_CMIC_SOFT_RESET_REGr_SET(r,d) (r).cmic_soft_reset_reg[0] = d
#define BCM56504_A0_CMIC_SOFT_RESET_REGr_GET(r) (r).cmic_soft_reset_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_SOFT_RESET_REGr_CMIC_GP_RST_Lf_GET(r) (((r).cmic_soft_reset_reg[0]) & 0x1)
#define BCM56504_A0_CMIC_SOFT_RESET_REGr_CMIC_GP_RST_Lf_SET(r,f) (r).cmic_soft_reset_reg[0]=(((r).cmic_soft_reset_reg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_CMIC_SOFT_RESET_REGr_CMIC_GX4_RST_Lf_GET(r) ((((r).cmic_soft_reset_reg[0]) >> 1) & 0x1)
#define BCM56504_A0_CMIC_SOFT_RESET_REGr_CMIC_GX4_RST_Lf_SET(r,f) (r).cmic_soft_reset_reg[0]=(((r).cmic_soft_reset_reg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_CMIC_SOFT_RESET_REGr_RESERVED_0f_GET(r) ((((r).cmic_soft_reset_reg[0]) >> 2) & 0x3)
#define BCM56504_A0_CMIC_SOFT_RESET_REGr_RESERVED_0f_SET(r,f) (r).cmic_soft_reset_reg[0]=(((r).cmic_soft_reset_reg[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM56504_A0_CMIC_SOFT_RESET_REGr_CMIC_XP_RST_Lf_GET(r) ((((r).cmic_soft_reset_reg[0]) >> 4) & 0x1)
#define BCM56504_A0_CMIC_SOFT_RESET_REGr_CMIC_XP_RST_Lf_SET(r,f) (r).cmic_soft_reset_reg[0]=(((r).cmic_soft_reset_reg[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56504_A0_CMIC_SOFT_RESET_REGr_CMIC_XGXS_RST_Lf_GET(r) ((((r).cmic_soft_reset_reg[0]) >> 5) & 0x1)
#define BCM56504_A0_CMIC_SOFT_RESET_REGr_CMIC_XGXS_RST_Lf_SET(r,f) (r).cmic_soft_reset_reg[0]=(((r).cmic_soft_reset_reg[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56504_A0_CMIC_SOFT_RESET_REGr_CMIC_MMU_RST_Lf_GET(r) ((((r).cmic_soft_reset_reg[0]) >> 6) & 0x1)
#define BCM56504_A0_CMIC_SOFT_RESET_REGr_CMIC_MMU_RST_Lf_SET(r,f) (r).cmic_soft_reset_reg[0]=(((r).cmic_soft_reset_reg[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56504_A0_CMIC_SOFT_RESET_REGr_CMIC_IP_RST_Lf_GET(r) ((((r).cmic_soft_reset_reg[0]) >> 7) & 0x1)
#define BCM56504_A0_CMIC_SOFT_RESET_REGr_CMIC_IP_RST_Lf_SET(r,f) (r).cmic_soft_reset_reg[0]=(((r).cmic_soft_reset_reg[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56504_A0_CMIC_SOFT_RESET_REGr_RESERVED_1f_GET(r) ((((r).cmic_soft_reset_reg[0]) >> 8) & 0x1)
#define BCM56504_A0_CMIC_SOFT_RESET_REGr_RESERVED_1f_SET(r,f) (r).cmic_soft_reset_reg[0]=(((r).cmic_soft_reset_reg[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56504_A0_CMIC_SOFT_RESET_REGr_CMIC_EP_RST_Lf_GET(r) ((((r).cmic_soft_reset_reg[0]) >> 9) & 0x1)
#define BCM56504_A0_CMIC_SOFT_RESET_REGr_CMIC_EP_RST_Lf_SET(r,f) (r).cmic_soft_reset_reg[0]=(((r).cmic_soft_reset_reg[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56504_A0_CMIC_SOFT_RESET_REGr_RESERVED_2f_GET(r) ((((r).cmic_soft_reset_reg[0]) >> 10) & 0x1)
#define BCM56504_A0_CMIC_SOFT_RESET_REGr_RESERVED_2f_SET(r,f) (r).cmic_soft_reset_reg[0]=(((r).cmic_soft_reset_reg[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56504_A0_CMIC_SOFT_RESET_REGr_CMIC_BSAFE_RST_Lf_GET(r) ((((r).cmic_soft_reset_reg[0]) >> 11) & 0x1)
#define BCM56504_A0_CMIC_SOFT_RESET_REGr_CMIC_BSAFE_RST_Lf_SET(r,f) (r).cmic_soft_reset_reg[0]=(((r).cmic_soft_reset_reg[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56504_A0_CMIC_SOFT_RESET_REGr_CMIC_BSAFE_CLKGEN_RST_Lf_GET(r) ((((r).cmic_soft_reset_reg[0]) >> 12) & 0x1)
#define BCM56504_A0_CMIC_SOFT_RESET_REGr_CMIC_BSAFE_CLKGEN_RST_Lf_SET(r,f) (r).cmic_soft_reset_reg[0]=(((r).cmic_soft_reset_reg[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM56504_A0_CMIC_SOFT_RESET_REGr_RESERVED_3f_GET(r) ((((r).cmic_soft_reset_reg[0]) >> 13) & 0xf)
#define BCM56504_A0_CMIC_SOFT_RESET_REGr_RESERVED_3f_SET(r,f) (r).cmic_soft_reset_reg[0]=(((r).cmic_soft_reset_reg[0] & ~((uint32_t)0xf << 13)) | ((((uint32_t)f) & 0xf) << 13))
#define BCM56504_A0_CMIC_SOFT_RESET_REGr_CMIC_XG_PLL_RST_Lf_GET(r) ((((r).cmic_soft_reset_reg[0]) >> 17) & 0x1)
#define BCM56504_A0_CMIC_SOFT_RESET_REGr_CMIC_XG_PLL_RST_Lf_SET(r,f) (r).cmic_soft_reset_reg[0]=(((r).cmic_soft_reset_reg[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56504_A0_CMIC_SOFT_RESET_REGr_RESERVED_4f_GET(r) ((((r).cmic_soft_reset_reg[0]) >> 18) & 0x3fff)
#define BCM56504_A0_CMIC_SOFT_RESET_REGr_RESERVED_4f_SET(r,f) (r).cmic_soft_reset_reg[0]=(((r).cmic_soft_reset_reg[0] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access CMIC_SOFT_RESET_REG.
 *
 */
#define BCM56504_A0_READ_CMIC_SOFT_RESET_REGr(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_SOFT_RESET_REGr,r._cmic_soft_reset_reg)
#define BCM56504_A0_WRITE_CMIC_SOFT_RESET_REGr(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_SOFT_RESET_REGr,r._cmic_soft_reset_reg)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_SOFT_RESET_REGr BCM56504_A0_CMIC_SOFT_RESET_REGr
#define CMIC_SOFT_RESET_REGr_SIZE BCM56504_A0_CMIC_SOFT_RESET_REGr_SIZE
typedef BCM56504_A0_CMIC_SOFT_RESET_REGr_t CMIC_SOFT_RESET_REGr_t;
#define CMIC_SOFT_RESET_REGr_CLR BCM56504_A0_CMIC_SOFT_RESET_REGr_CLR
#define CMIC_SOFT_RESET_REGr_SET BCM56504_A0_CMIC_SOFT_RESET_REGr_SET
#define CMIC_SOFT_RESET_REGr_GET BCM56504_A0_CMIC_SOFT_RESET_REGr_GET
#define CMIC_SOFT_RESET_REGr_CMIC_GP_RST_Lf_GET BCM56504_A0_CMIC_SOFT_RESET_REGr_CMIC_GP_RST_Lf_GET
#define CMIC_SOFT_RESET_REGr_CMIC_GP_RST_Lf_SET BCM56504_A0_CMIC_SOFT_RESET_REGr_CMIC_GP_RST_Lf_SET
#define CMIC_SOFT_RESET_REGr_CMIC_GX4_RST_Lf_GET BCM56504_A0_CMIC_SOFT_RESET_REGr_CMIC_GX4_RST_Lf_GET
#define CMIC_SOFT_RESET_REGr_CMIC_GX4_RST_Lf_SET BCM56504_A0_CMIC_SOFT_RESET_REGr_CMIC_GX4_RST_Lf_SET
#define CMIC_SOFT_RESET_REGr_RESERVED_0f_GET BCM56504_A0_CMIC_SOFT_RESET_REGr_RESERVED_0f_GET
#define CMIC_SOFT_RESET_REGr_RESERVED_0f_SET BCM56504_A0_CMIC_SOFT_RESET_REGr_RESERVED_0f_SET
#define CMIC_SOFT_RESET_REGr_CMIC_XP_RST_Lf_GET BCM56504_A0_CMIC_SOFT_RESET_REGr_CMIC_XP_RST_Lf_GET
#define CMIC_SOFT_RESET_REGr_CMIC_XP_RST_Lf_SET BCM56504_A0_CMIC_SOFT_RESET_REGr_CMIC_XP_RST_Lf_SET
#define CMIC_SOFT_RESET_REGr_CMIC_XGXS_RST_Lf_GET BCM56504_A0_CMIC_SOFT_RESET_REGr_CMIC_XGXS_RST_Lf_GET
#define CMIC_SOFT_RESET_REGr_CMIC_XGXS_RST_Lf_SET BCM56504_A0_CMIC_SOFT_RESET_REGr_CMIC_XGXS_RST_Lf_SET
#define CMIC_SOFT_RESET_REGr_CMIC_MMU_RST_Lf_GET BCM56504_A0_CMIC_SOFT_RESET_REGr_CMIC_MMU_RST_Lf_GET
#define CMIC_SOFT_RESET_REGr_CMIC_MMU_RST_Lf_SET BCM56504_A0_CMIC_SOFT_RESET_REGr_CMIC_MMU_RST_Lf_SET
#define CMIC_SOFT_RESET_REGr_CMIC_IP_RST_Lf_GET BCM56504_A0_CMIC_SOFT_RESET_REGr_CMIC_IP_RST_Lf_GET
#define CMIC_SOFT_RESET_REGr_CMIC_IP_RST_Lf_SET BCM56504_A0_CMIC_SOFT_RESET_REGr_CMIC_IP_RST_Lf_SET
#define CMIC_SOFT_RESET_REGr_RESERVED_1f_GET BCM56504_A0_CMIC_SOFT_RESET_REGr_RESERVED_1f_GET
#define CMIC_SOFT_RESET_REGr_RESERVED_1f_SET BCM56504_A0_CMIC_SOFT_RESET_REGr_RESERVED_1f_SET
#define CMIC_SOFT_RESET_REGr_CMIC_EP_RST_Lf_GET BCM56504_A0_CMIC_SOFT_RESET_REGr_CMIC_EP_RST_Lf_GET
#define CMIC_SOFT_RESET_REGr_CMIC_EP_RST_Lf_SET BCM56504_A0_CMIC_SOFT_RESET_REGr_CMIC_EP_RST_Lf_SET
#define CMIC_SOFT_RESET_REGr_RESERVED_2f_GET BCM56504_A0_CMIC_SOFT_RESET_REGr_RESERVED_2f_GET
#define CMIC_SOFT_RESET_REGr_RESERVED_2f_SET BCM56504_A0_CMIC_SOFT_RESET_REGr_RESERVED_2f_SET
#define CMIC_SOFT_RESET_REGr_CMIC_BSAFE_RST_Lf_GET BCM56504_A0_CMIC_SOFT_RESET_REGr_CMIC_BSAFE_RST_Lf_GET
#define CMIC_SOFT_RESET_REGr_CMIC_BSAFE_RST_Lf_SET BCM56504_A0_CMIC_SOFT_RESET_REGr_CMIC_BSAFE_RST_Lf_SET
#define CMIC_SOFT_RESET_REGr_CMIC_BSAFE_CLKGEN_RST_Lf_GET BCM56504_A0_CMIC_SOFT_RESET_REGr_CMIC_BSAFE_CLKGEN_RST_Lf_GET
#define CMIC_SOFT_RESET_REGr_CMIC_BSAFE_CLKGEN_RST_Lf_SET BCM56504_A0_CMIC_SOFT_RESET_REGr_CMIC_BSAFE_CLKGEN_RST_Lf_SET
#define CMIC_SOFT_RESET_REGr_RESERVED_3f_GET BCM56504_A0_CMIC_SOFT_RESET_REGr_RESERVED_3f_GET
#define CMIC_SOFT_RESET_REGr_RESERVED_3f_SET BCM56504_A0_CMIC_SOFT_RESET_REGr_RESERVED_3f_SET
#define CMIC_SOFT_RESET_REGr_CMIC_XG_PLL_RST_Lf_GET BCM56504_A0_CMIC_SOFT_RESET_REGr_CMIC_XG_PLL_RST_Lf_GET
#define CMIC_SOFT_RESET_REGr_CMIC_XG_PLL_RST_Lf_SET BCM56504_A0_CMIC_SOFT_RESET_REGr_CMIC_XG_PLL_RST_Lf_SET
#define CMIC_SOFT_RESET_REGr_RESERVED_4f_GET BCM56504_A0_CMIC_SOFT_RESET_REGr_RESERVED_4f_GET
#define CMIC_SOFT_RESET_REGr_RESERVED_4f_SET BCM56504_A0_CMIC_SOFT_RESET_REGr_RESERVED_4f_SET
#define READ_CMIC_SOFT_RESET_REGr BCM56504_A0_READ_CMIC_SOFT_RESET_REGr
#define WRITE_CMIC_SOFT_RESET_REGr BCM56504_A0_WRITE_CMIC_SOFT_RESET_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_SOFT_RESET_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_STAT_DMA_ADDR
 * BLOCKS:   CMIC
 * DESC:     Stats memory start address

 * SIZE:     32
 * FIELDS:
 *     ADDR             Start memory address where the stats counters willbe written to
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_STAT_DMA_ADDRr 0x00000164

#define BCM56504_A0_CMIC_STAT_DMA_ADDRr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_ADDR.
 *
 */
typedef union BCM56504_A0_CMIC_STAT_DMA_ADDRr_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_addr[1];
	uint32_t _cmic_stat_dma_addr;
} BCM56504_A0_CMIC_STAT_DMA_ADDRr_t;

#define BCM56504_A0_CMIC_STAT_DMA_ADDRr_CLR(r) (r).cmic_stat_dma_addr[0] = 0
#define BCM56504_A0_CMIC_STAT_DMA_ADDRr_SET(r,d) (r).cmic_stat_dma_addr[0] = d
#define BCM56504_A0_CMIC_STAT_DMA_ADDRr_GET(r) (r).cmic_stat_dma_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_STAT_DMA_ADDRr_ADDRf_GET(r) ((r).cmic_stat_dma_addr[0])
#define BCM56504_A0_CMIC_STAT_DMA_ADDRr_ADDRf_SET(r,f) (r).cmic_stat_dma_addr[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_STAT_DMA_ADDR.
 *
 */
#define BCM56504_A0_READ_CMIC_STAT_DMA_ADDRr(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_STAT_DMA_ADDRr,r._cmic_stat_dma_addr)
#define BCM56504_A0_WRITE_CMIC_STAT_DMA_ADDRr(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_STAT_DMA_ADDRr,r._cmic_stat_dma_addr)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_ADDRr BCM56504_A0_CMIC_STAT_DMA_ADDRr
#define CMIC_STAT_DMA_ADDRr_SIZE BCM56504_A0_CMIC_STAT_DMA_ADDRr_SIZE
typedef BCM56504_A0_CMIC_STAT_DMA_ADDRr_t CMIC_STAT_DMA_ADDRr_t;
#define CMIC_STAT_DMA_ADDRr_CLR BCM56504_A0_CMIC_STAT_DMA_ADDRr_CLR
#define CMIC_STAT_DMA_ADDRr_SET BCM56504_A0_CMIC_STAT_DMA_ADDRr_SET
#define CMIC_STAT_DMA_ADDRr_GET BCM56504_A0_CMIC_STAT_DMA_ADDRr_GET
#define CMIC_STAT_DMA_ADDRr_ADDRf_GET BCM56504_A0_CMIC_STAT_DMA_ADDRr_ADDRf_GET
#define CMIC_STAT_DMA_ADDRr_ADDRf_SET BCM56504_A0_CMIC_STAT_DMA_ADDRr_ADDRf_SET
#define READ_CMIC_STAT_DMA_ADDRr BCM56504_A0_READ_CMIC_STAT_DMA_ADDRr
#define WRITE_CMIC_STAT_DMA_ADDRr BCM56504_A0_WRITE_CMIC_STAT_DMA_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_STAT_DMA_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_STAT_DMA_BLKNUM_MAP_15_8
 * BLOCKS:   CMIC
 * DESC:     Stats DMA port <-> block-number map, ports 15 to 8

 * SIZE:     32
 * FIELDS:
 *     SBUS_BLKNUM_8    S-bus block number for port  8
 *     SBUS_BLKNUM_9    S-bus block number for port  9
 *     SBUS_BLKNUM_10   S-bus block number for port 10
 *     SBUS_BLKNUM_11   S-bus block number for port 11
 *     SBUS_BLKNUM_12   S-bus block number for port 12
 *     SBUS_BLKNUM_13   S-bus block number for port 13
 *     SBUS_BLKNUM_14   S-bus block number for port 14
 *     SBUS_BLKNUM_15   S-bus block number for port 15
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r 0x00000484

#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_BLKNUM_MAP_15_8.
 *
 */
typedef union BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_blknum_map_15_8[1];
	uint32_t _cmic_stat_dma_blknum_map_15_8;
} BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_t;

#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_CLR(r) (r).cmic_stat_dma_blknum_map_15_8[0] = 0
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SET(r,d) (r).cmic_stat_dma_blknum_map_15_8[0] = d
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_GET(r) (r).cmic_stat_dma_blknum_map_15_8[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_8f_GET(r) (((r).cmic_stat_dma_blknum_map_15_8[0]) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_8f_SET(r,f) (r).cmic_stat_dma_blknum_map_15_8[0]=(((r).cmic_stat_dma_blknum_map_15_8[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_9f_GET(r) ((((r).cmic_stat_dma_blknum_map_15_8[0]) >> 4) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_9f_SET(r,f) (r).cmic_stat_dma_blknum_map_15_8[0]=(((r).cmic_stat_dma_blknum_map_15_8[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_10f_GET(r) ((((r).cmic_stat_dma_blknum_map_15_8[0]) >> 8) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_10f_SET(r,f) (r).cmic_stat_dma_blknum_map_15_8[0]=(((r).cmic_stat_dma_blknum_map_15_8[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_11f_GET(r) ((((r).cmic_stat_dma_blknum_map_15_8[0]) >> 12) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_11f_SET(r,f) (r).cmic_stat_dma_blknum_map_15_8[0]=(((r).cmic_stat_dma_blknum_map_15_8[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_12f_GET(r) ((((r).cmic_stat_dma_blknum_map_15_8[0]) >> 16) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_12f_SET(r,f) (r).cmic_stat_dma_blknum_map_15_8[0]=(((r).cmic_stat_dma_blknum_map_15_8[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_13f_GET(r) ((((r).cmic_stat_dma_blknum_map_15_8[0]) >> 20) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_13f_SET(r,f) (r).cmic_stat_dma_blknum_map_15_8[0]=(((r).cmic_stat_dma_blknum_map_15_8[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_14f_GET(r) ((((r).cmic_stat_dma_blknum_map_15_8[0]) >> 24) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_14f_SET(r,f) (r).cmic_stat_dma_blknum_map_15_8[0]=(((r).cmic_stat_dma_blknum_map_15_8[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_15f_GET(r) ((((r).cmic_stat_dma_blknum_map_15_8[0]) >> 28) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_15f_SET(r,f) (r).cmic_stat_dma_blknum_map_15_8[0]=(((r).cmic_stat_dma_blknum_map_15_8[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access CMIC_STAT_DMA_BLKNUM_MAP_15_8.
 *
 */
#define BCM56504_A0_READ_CMIC_STAT_DMA_BLKNUM_MAP_15_8r(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r,r._cmic_stat_dma_blknum_map_15_8)
#define BCM56504_A0_WRITE_CMIC_STAT_DMA_BLKNUM_MAP_15_8r(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r,r._cmic_stat_dma_blknum_map_15_8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SIZE BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SIZE
typedef BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_t CMIC_STAT_DMA_BLKNUM_MAP_15_8r_t;
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_CLR BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_CLR
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_GET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_8f_GET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_8f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_8f_SET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_8f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_9f_GET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_9f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_9f_SET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_9f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_10f_GET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_10f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_10f_SET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_10f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_11f_GET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_11f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_11f_SET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_11f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_12f_GET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_12f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_12f_SET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_12f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_13f_GET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_13f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_13f_SET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_13f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_14f_GET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_14f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_14f_SET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_14f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_15f_GET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_15f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_15f_SET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_15f_SET
#define READ_CMIC_STAT_DMA_BLKNUM_MAP_15_8r BCM56504_A0_READ_CMIC_STAT_DMA_BLKNUM_MAP_15_8r
#define WRITE_CMIC_STAT_DMA_BLKNUM_MAP_15_8r BCM56504_A0_WRITE_CMIC_STAT_DMA_BLKNUM_MAP_15_8r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_STAT_DMA_BLKNUM_MAP_23_16
 * BLOCKS:   CMIC
 * DESC:     Stats DMA port <-> block-number map, ports 23 to 16

 * SIZE:     32
 * FIELDS:
 *     SBUS_BLKNUM_16   S-bus block number for port 16
 *     SBUS_BLKNUM_17   S-bus block number for port 17
 *     SBUS_BLKNUM_18   S-bus block number for port 18
 *     SBUS_BLKNUM_19   S-bus block number for port 19
 *     SBUS_BLKNUM_20   S-bus block number for port 20
 *     SBUS_BLKNUM_21   S-bus block number for port 21
 *     SBUS_BLKNUM_22   S-bus block number for port 22
 *     SBUS_BLKNUM_23   S-bus block number for port 23
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r 0x00000488

#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_BLKNUM_MAP_23_16.
 *
 */
typedef union BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_blknum_map_23_16[1];
	uint32_t _cmic_stat_dma_blknum_map_23_16;
} BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_t;

#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_CLR(r) (r).cmic_stat_dma_blknum_map_23_16[0] = 0
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SET(r,d) (r).cmic_stat_dma_blknum_map_23_16[0] = d
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_GET(r) (r).cmic_stat_dma_blknum_map_23_16[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_16f_GET(r) (((r).cmic_stat_dma_blknum_map_23_16[0]) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_16f_SET(r,f) (r).cmic_stat_dma_blknum_map_23_16[0]=(((r).cmic_stat_dma_blknum_map_23_16[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_17f_GET(r) ((((r).cmic_stat_dma_blknum_map_23_16[0]) >> 4) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_17f_SET(r,f) (r).cmic_stat_dma_blknum_map_23_16[0]=(((r).cmic_stat_dma_blknum_map_23_16[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_18f_GET(r) ((((r).cmic_stat_dma_blknum_map_23_16[0]) >> 8) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_18f_SET(r,f) (r).cmic_stat_dma_blknum_map_23_16[0]=(((r).cmic_stat_dma_blknum_map_23_16[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_19f_GET(r) ((((r).cmic_stat_dma_blknum_map_23_16[0]) >> 12) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_19f_SET(r,f) (r).cmic_stat_dma_blknum_map_23_16[0]=(((r).cmic_stat_dma_blknum_map_23_16[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_20f_GET(r) ((((r).cmic_stat_dma_blknum_map_23_16[0]) >> 16) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_20f_SET(r,f) (r).cmic_stat_dma_blknum_map_23_16[0]=(((r).cmic_stat_dma_blknum_map_23_16[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_21f_GET(r) ((((r).cmic_stat_dma_blknum_map_23_16[0]) >> 20) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_21f_SET(r,f) (r).cmic_stat_dma_blknum_map_23_16[0]=(((r).cmic_stat_dma_blknum_map_23_16[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_22f_GET(r) ((((r).cmic_stat_dma_blknum_map_23_16[0]) >> 24) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_22f_SET(r,f) (r).cmic_stat_dma_blknum_map_23_16[0]=(((r).cmic_stat_dma_blknum_map_23_16[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_23f_GET(r) ((((r).cmic_stat_dma_blknum_map_23_16[0]) >> 28) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_23f_SET(r,f) (r).cmic_stat_dma_blknum_map_23_16[0]=(((r).cmic_stat_dma_blknum_map_23_16[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access CMIC_STAT_DMA_BLKNUM_MAP_23_16.
 *
 */
#define BCM56504_A0_READ_CMIC_STAT_DMA_BLKNUM_MAP_23_16r(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r,r._cmic_stat_dma_blknum_map_23_16)
#define BCM56504_A0_WRITE_CMIC_STAT_DMA_BLKNUM_MAP_23_16r(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r,r._cmic_stat_dma_blknum_map_23_16)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SIZE BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SIZE
typedef BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_t CMIC_STAT_DMA_BLKNUM_MAP_23_16r_t;
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_CLR BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_CLR
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_GET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_16f_GET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_16f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_16f_SET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_16f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_17f_GET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_17f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_17f_SET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_17f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_18f_GET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_18f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_18f_SET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_18f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_19f_GET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_19f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_19f_SET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_19f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_20f_GET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_20f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_20f_SET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_20f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_21f_GET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_21f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_21f_SET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_21f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_22f_GET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_22f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_22f_SET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_22f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_23f_GET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_23f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_23f_SET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_23f_SET
#define READ_CMIC_STAT_DMA_BLKNUM_MAP_23_16r BCM56504_A0_READ_CMIC_STAT_DMA_BLKNUM_MAP_23_16r
#define WRITE_CMIC_STAT_DMA_BLKNUM_MAP_23_16r BCM56504_A0_WRITE_CMIC_STAT_DMA_BLKNUM_MAP_23_16r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_STAT_DMA_BLKNUM_MAP_31_24
 * BLOCKS:   CMIC
 * DESC:     Stats DMA port <-> block-number map, ports 31 to 24

 * SIZE:     32
 * FIELDS:
 *     SBUS_BLKNUM_24   S-bus block number for port 24
 *     SBUS_BLKNUM_25   S-bus block number for port 25
 *     SBUS_BLKNUM_26   S-bus block number for port 26
 *     SBUS_BLKNUM_27   S-bus block number for port 27
 *     SBUS_BLKNUM_28   S-bus block number for port 28
 *     SBUS_BLKNUM_29   S-bus block number for port 29
 *     SBUS_BLKNUM_30   S-bus block number for port 30
 *     SBUS_BLKNUM_31   S-bus block number for port 31
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r 0x0000048c

#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_BLKNUM_MAP_31_24.
 *
 */
typedef union BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_blknum_map_31_24[1];
	uint32_t _cmic_stat_dma_blknum_map_31_24;
} BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_t;

#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_CLR(r) (r).cmic_stat_dma_blknum_map_31_24[0] = 0
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SET(r,d) (r).cmic_stat_dma_blknum_map_31_24[0] = d
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_GET(r) (r).cmic_stat_dma_blknum_map_31_24[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_24f_GET(r) (((r).cmic_stat_dma_blknum_map_31_24[0]) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_24f_SET(r,f) (r).cmic_stat_dma_blknum_map_31_24[0]=(((r).cmic_stat_dma_blknum_map_31_24[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_25f_GET(r) ((((r).cmic_stat_dma_blknum_map_31_24[0]) >> 4) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_25f_SET(r,f) (r).cmic_stat_dma_blknum_map_31_24[0]=(((r).cmic_stat_dma_blknum_map_31_24[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_26f_GET(r) ((((r).cmic_stat_dma_blknum_map_31_24[0]) >> 8) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_26f_SET(r,f) (r).cmic_stat_dma_blknum_map_31_24[0]=(((r).cmic_stat_dma_blknum_map_31_24[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_27f_GET(r) ((((r).cmic_stat_dma_blknum_map_31_24[0]) >> 12) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_27f_SET(r,f) (r).cmic_stat_dma_blknum_map_31_24[0]=(((r).cmic_stat_dma_blknum_map_31_24[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_28f_GET(r) ((((r).cmic_stat_dma_blknum_map_31_24[0]) >> 16) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_28f_SET(r,f) (r).cmic_stat_dma_blknum_map_31_24[0]=(((r).cmic_stat_dma_blknum_map_31_24[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_29f_GET(r) ((((r).cmic_stat_dma_blknum_map_31_24[0]) >> 20) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_29f_SET(r,f) (r).cmic_stat_dma_blknum_map_31_24[0]=(((r).cmic_stat_dma_blknum_map_31_24[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_30f_GET(r) ((((r).cmic_stat_dma_blknum_map_31_24[0]) >> 24) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_30f_SET(r,f) (r).cmic_stat_dma_blknum_map_31_24[0]=(((r).cmic_stat_dma_blknum_map_31_24[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_31f_GET(r) ((((r).cmic_stat_dma_blknum_map_31_24[0]) >> 28) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_31f_SET(r,f) (r).cmic_stat_dma_blknum_map_31_24[0]=(((r).cmic_stat_dma_blknum_map_31_24[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access CMIC_STAT_DMA_BLKNUM_MAP_31_24.
 *
 */
#define BCM56504_A0_READ_CMIC_STAT_DMA_BLKNUM_MAP_31_24r(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r,r._cmic_stat_dma_blknum_map_31_24)
#define BCM56504_A0_WRITE_CMIC_STAT_DMA_BLKNUM_MAP_31_24r(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r,r._cmic_stat_dma_blknum_map_31_24)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SIZE BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SIZE
typedef BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_t CMIC_STAT_DMA_BLKNUM_MAP_31_24r_t;
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_CLR BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_CLR
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_GET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_24f_GET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_24f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_24f_SET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_24f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_25f_GET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_25f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_25f_SET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_25f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_26f_GET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_26f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_26f_SET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_26f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_27f_GET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_27f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_27f_SET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_27f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_28f_GET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_28f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_28f_SET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_28f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_29f_GET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_29f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_29f_SET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_29f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_30f_GET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_30f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_30f_SET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_30f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_31f_GET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_31f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_31f_SET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_31f_SET
#define READ_CMIC_STAT_DMA_BLKNUM_MAP_31_24r BCM56504_A0_READ_CMIC_STAT_DMA_BLKNUM_MAP_31_24r
#define WRITE_CMIC_STAT_DMA_BLKNUM_MAP_31_24r BCM56504_A0_WRITE_CMIC_STAT_DMA_BLKNUM_MAP_31_24r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_STAT_DMA_BLKNUM_MAP_7_0
 * BLOCKS:   CMIC
 * DESC:     Stats DMA port <-> block-number map, ports 7 to 0

 * SIZE:     32
 * FIELDS:
 *     SBUS_BLKNUM_0    S-bus block number for port 0
 *     SBUS_BLKNUM_1    S-bus block number for port 1
 *     SBUS_BLKNUM_2    S-bus block number for port 2
 *     SBUS_BLKNUM_3    S-bus block number for port 3
 *     SBUS_BLKNUM_4    S-bus block number for port 4
 *     SBUS_BLKNUM_5    S-bus block number for port 5
 *     SBUS_BLKNUM_6    S-bus block number for port 6
 *     SBUS_BLKNUM_7    S-bus block number for port 7
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r 0x00000480

#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_BLKNUM_MAP_7_0.
 *
 */
typedef union BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_blknum_map_7_0[1];
	uint32_t _cmic_stat_dma_blknum_map_7_0;
} BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_t;

#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_CLR(r) (r).cmic_stat_dma_blknum_map_7_0[0] = 0
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SET(r,d) (r).cmic_stat_dma_blknum_map_7_0[0] = d
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_GET(r) (r).cmic_stat_dma_blknum_map_7_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_0f_GET(r) (((r).cmic_stat_dma_blknum_map_7_0[0]) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_0f_SET(r,f) (r).cmic_stat_dma_blknum_map_7_0[0]=(((r).cmic_stat_dma_blknum_map_7_0[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_1f_GET(r) ((((r).cmic_stat_dma_blknum_map_7_0[0]) >> 4) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_1f_SET(r,f) (r).cmic_stat_dma_blknum_map_7_0[0]=(((r).cmic_stat_dma_blknum_map_7_0[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_2f_GET(r) ((((r).cmic_stat_dma_blknum_map_7_0[0]) >> 8) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_2f_SET(r,f) (r).cmic_stat_dma_blknum_map_7_0[0]=(((r).cmic_stat_dma_blknum_map_7_0[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_3f_GET(r) ((((r).cmic_stat_dma_blknum_map_7_0[0]) >> 12) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_3f_SET(r,f) (r).cmic_stat_dma_blknum_map_7_0[0]=(((r).cmic_stat_dma_blknum_map_7_0[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_4f_GET(r) ((((r).cmic_stat_dma_blknum_map_7_0[0]) >> 16) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_4f_SET(r,f) (r).cmic_stat_dma_blknum_map_7_0[0]=(((r).cmic_stat_dma_blknum_map_7_0[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_5f_GET(r) ((((r).cmic_stat_dma_blknum_map_7_0[0]) >> 20) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_5f_SET(r,f) (r).cmic_stat_dma_blknum_map_7_0[0]=(((r).cmic_stat_dma_blknum_map_7_0[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_6f_GET(r) ((((r).cmic_stat_dma_blknum_map_7_0[0]) >> 24) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_6f_SET(r,f) (r).cmic_stat_dma_blknum_map_7_0[0]=(((r).cmic_stat_dma_blknum_map_7_0[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_7f_GET(r) ((((r).cmic_stat_dma_blknum_map_7_0[0]) >> 28) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_7f_SET(r,f) (r).cmic_stat_dma_blknum_map_7_0[0]=(((r).cmic_stat_dma_blknum_map_7_0[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access CMIC_STAT_DMA_BLKNUM_MAP_7_0.
 *
 */
#define BCM56504_A0_READ_CMIC_STAT_DMA_BLKNUM_MAP_7_0r(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r,r._cmic_stat_dma_blknum_map_7_0)
#define BCM56504_A0_WRITE_CMIC_STAT_DMA_BLKNUM_MAP_7_0r(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r,r._cmic_stat_dma_blknum_map_7_0)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SIZE BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SIZE
typedef BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_t CMIC_STAT_DMA_BLKNUM_MAP_7_0r_t;
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_CLR BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_CLR
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_GET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_0f_GET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_0f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_0f_SET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_0f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_1f_GET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_1f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_1f_SET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_1f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_2f_GET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_2f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_2f_SET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_2f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_3f_GET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_3f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_3f_SET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_3f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_4f_GET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_4f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_4f_SET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_4f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_5f_GET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_5f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_5f_SET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_5f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_6f_GET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_6f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_6f_SET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_6f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_7f_GET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_7f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_7f_SET BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_7f_SET
#define READ_CMIC_STAT_DMA_BLKNUM_MAP_7_0r BCM56504_A0_READ_CMIC_STAT_DMA_BLKNUM_MAP_7_0r
#define WRITE_CMIC_STAT_DMA_BLKNUM_MAP_7_0r BCM56504_A0_WRITE_CMIC_STAT_DMA_BLKNUM_MAP_7_0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_STAT_DMA_CURRENT
 * BLOCKS:   CMIC
 * DESC:     Current Stat Counter Value Register
 * SIZE:     32
 * FIELDS:
 *     DATA             Address of Stat counter currently being processed bythe Stats DMA engine
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_STAT_DMA_CURRENTr 0x00000170

#define BCM56504_A0_CMIC_STAT_DMA_CURRENTr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_CURRENT.
 *
 */
typedef union BCM56504_A0_CMIC_STAT_DMA_CURRENTr_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_current[1];
	uint32_t _cmic_stat_dma_current;
} BCM56504_A0_CMIC_STAT_DMA_CURRENTr_t;

#define BCM56504_A0_CMIC_STAT_DMA_CURRENTr_CLR(r) (r).cmic_stat_dma_current[0] = 0
#define BCM56504_A0_CMIC_STAT_DMA_CURRENTr_SET(r,d) (r).cmic_stat_dma_current[0] = d
#define BCM56504_A0_CMIC_STAT_DMA_CURRENTr_GET(r) (r).cmic_stat_dma_current[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_STAT_DMA_CURRENTr_DATAf_GET(r) ((r).cmic_stat_dma_current[0])
#define BCM56504_A0_CMIC_STAT_DMA_CURRENTr_DATAf_SET(r,f) (r).cmic_stat_dma_current[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_STAT_DMA_CURRENT.
 *
 */
#define BCM56504_A0_READ_CMIC_STAT_DMA_CURRENTr(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_STAT_DMA_CURRENTr,r._cmic_stat_dma_current)
#define BCM56504_A0_WRITE_CMIC_STAT_DMA_CURRENTr(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_STAT_DMA_CURRENTr,r._cmic_stat_dma_current)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_CURRENTr BCM56504_A0_CMIC_STAT_DMA_CURRENTr
#define CMIC_STAT_DMA_CURRENTr_SIZE BCM56504_A0_CMIC_STAT_DMA_CURRENTr_SIZE
typedef BCM56504_A0_CMIC_STAT_DMA_CURRENTr_t CMIC_STAT_DMA_CURRENTr_t;
#define CMIC_STAT_DMA_CURRENTr_CLR BCM56504_A0_CMIC_STAT_DMA_CURRENTr_CLR
#define CMIC_STAT_DMA_CURRENTr_SET BCM56504_A0_CMIC_STAT_DMA_CURRENTr_SET
#define CMIC_STAT_DMA_CURRENTr_GET BCM56504_A0_CMIC_STAT_DMA_CURRENTr_GET
#define CMIC_STAT_DMA_CURRENTr_DATAf_GET BCM56504_A0_CMIC_STAT_DMA_CURRENTr_DATAf_GET
#define CMIC_STAT_DMA_CURRENTr_DATAf_SET BCM56504_A0_CMIC_STAT_DMA_CURRENTr_DATAf_SET
#define READ_CMIC_STAT_DMA_CURRENTr BCM56504_A0_READ_CMIC_STAT_DMA_CURRENTr
#define WRITE_CMIC_STAT_DMA_CURRENTr BCM56504_A0_WRITE_CMIC_STAT_DMA_CURRENTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_STAT_DMA_CURRENTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_STAT_DMA_EGR_STATS_CFG
 * BLOCKS:   CMIC
 * DESC:     Stats DMA Egress stats config register
 * SIZE:     32
 * FIELDS:
 *     EGR_ETH_BLK_NUM  S-bus block number of Egress for stats counters
 *     RESERVED_1       Reserved
 *     EGR_STAT_COUNTERS_NUM Number of Egress Stats counters per port
 *     RESERVED_2       Reserved
 *     EGR_STATS_PIPELINE_STAGE_NUM Egress pipeline stats counter stage number (if any), 
 *     RESERVED_3       Reserved
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_STAT_DMA_EGR_STATS_CFGr 0x00000464

#define BCM56504_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_EGR_STATS_CFG.
 *
 */
typedef union BCM56504_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_egr_stats_cfg[1];
	uint32_t _cmic_stat_dma_egr_stats_cfg;
} BCM56504_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_t;

#define BCM56504_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_CLR(r) (r).cmic_stat_dma_egr_stats_cfg[0] = 0
#define BCM56504_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_SET(r,d) (r).cmic_stat_dma_egr_stats_cfg[0] = d
#define BCM56504_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_GET(r) (r).cmic_stat_dma_egr_stats_cfg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_ETH_BLK_NUMf_GET(r) (((r).cmic_stat_dma_egr_stats_cfg[0]) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_ETH_BLK_NUMf_SET(r,f) (r).cmic_stat_dma_egr_stats_cfg[0]=(((r).cmic_stat_dma_egr_stats_cfg[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56504_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_1f_GET(r) ((((r).cmic_stat_dma_egr_stats_cfg[0]) >> 4) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_1f_SET(r,f) (r).cmic_stat_dma_egr_stats_cfg[0]=(((r).cmic_stat_dma_egr_stats_cfg[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56504_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_STAT_COUNTERS_NUMf_GET(r) ((((r).cmic_stat_dma_egr_stats_cfg[0]) >> 8) & 0x3f)
#define BCM56504_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_STAT_COUNTERS_NUMf_SET(r,f) (r).cmic_stat_dma_egr_stats_cfg[0]=(((r).cmic_stat_dma_egr_stats_cfg[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define BCM56504_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_2f_GET(r) ((((r).cmic_stat_dma_egr_stats_cfg[0]) >> 14) & 0x3)
#define BCM56504_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_2f_SET(r,f) (r).cmic_stat_dma_egr_stats_cfg[0]=(((r).cmic_stat_dma_egr_stats_cfg[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCM56504_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_STATS_PIPELINE_STAGE_NUMf_GET(r) ((((r).cmic_stat_dma_egr_stats_cfg[0]) >> 16) & 0x3f)
#define BCM56504_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_STATS_PIPELINE_STAGE_NUMf_SET(r,f) (r).cmic_stat_dma_egr_stats_cfg[0]=(((r).cmic_stat_dma_egr_stats_cfg[0] & ~((uint32_t)0x3f << 16)) | ((((uint32_t)f) & 0x3f) << 16))
#define BCM56504_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_3f_GET(r) ((((r).cmic_stat_dma_egr_stats_cfg[0]) >> 22) & 0x3ff)
#define BCM56504_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_3f_SET(r,f) (r).cmic_stat_dma_egr_stats_cfg[0]=(((r).cmic_stat_dma_egr_stats_cfg[0] & ~((uint32_t)0x3ff << 22)) | ((((uint32_t)f) & 0x3ff) << 22))

/*
 * These macros can be used to access CMIC_STAT_DMA_EGR_STATS_CFG.
 *
 */
#define BCM56504_A0_READ_CMIC_STAT_DMA_EGR_STATS_CFGr(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_STAT_DMA_EGR_STATS_CFGr,r._cmic_stat_dma_egr_stats_cfg)
#define BCM56504_A0_WRITE_CMIC_STAT_DMA_EGR_STATS_CFGr(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_STAT_DMA_EGR_STATS_CFGr,r._cmic_stat_dma_egr_stats_cfg)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_EGR_STATS_CFGr BCM56504_A0_CMIC_STAT_DMA_EGR_STATS_CFGr
#define CMIC_STAT_DMA_EGR_STATS_CFGr_SIZE BCM56504_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_SIZE
typedef BCM56504_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_t CMIC_STAT_DMA_EGR_STATS_CFGr_t;
#define CMIC_STAT_DMA_EGR_STATS_CFGr_CLR BCM56504_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_CLR
#define CMIC_STAT_DMA_EGR_STATS_CFGr_SET BCM56504_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_SET
#define CMIC_STAT_DMA_EGR_STATS_CFGr_GET BCM56504_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_GET
#define CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_ETH_BLK_NUMf_GET BCM56504_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_ETH_BLK_NUMf_GET
#define CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_ETH_BLK_NUMf_SET BCM56504_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_ETH_BLK_NUMf_SET
#define CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_1f_GET BCM56504_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_1f_GET
#define CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_1f_SET BCM56504_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_1f_SET
#define CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_STAT_COUNTERS_NUMf_GET BCM56504_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_STAT_COUNTERS_NUMf_GET
#define CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_STAT_COUNTERS_NUMf_SET BCM56504_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_STAT_COUNTERS_NUMf_SET
#define CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_2f_GET BCM56504_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_2f_GET
#define CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_2f_SET BCM56504_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_2f_SET
#define CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_STATS_PIPELINE_STAGE_NUMf_GET BCM56504_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_STATS_PIPELINE_STAGE_NUMf_GET
#define CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_STATS_PIPELINE_STAGE_NUMf_SET BCM56504_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_STATS_PIPELINE_STAGE_NUMf_SET
#define CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_3f_GET BCM56504_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_3f_GET
#define CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_3f_SET BCM56504_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_3f_SET
#define READ_CMIC_STAT_DMA_EGR_STATS_CFGr BCM56504_A0_READ_CMIC_STAT_DMA_EGR_STATS_CFGr
#define WRITE_CMIC_STAT_DMA_EGR_STATS_CFGr BCM56504_A0_WRITE_CMIC_STAT_DMA_EGR_STATS_CFGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_STAT_DMA_EGR_STATS_CFGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_STAT_DMA_ING_STATS_CFG
 * BLOCKS:   CMIC
 * DESC:     Stats DMA Ingress stats config register
 * SIZE:     32
 * FIELDS:
 *     ING_ETH_BLK_NUM  S-bus block number of Ingress for stats counters
 *     RESERVED_1       Reserved
 *     ING_STAT_COUNTERS_NUM Number of Ingress Stats counters per port
 *     RESERVED_2       Reserved
 *     ING_STATS_PIPELINE_STAGE_NUM Ingress pipeline stats counter stage number (if any), 
 *     RESERVED_3       Reserved
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_STAT_DMA_ING_STATS_CFGr 0x00000460

#define BCM56504_A0_CMIC_STAT_DMA_ING_STATS_CFGr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_ING_STATS_CFG.
 *
 */
typedef union BCM56504_A0_CMIC_STAT_DMA_ING_STATS_CFGr_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_ing_stats_cfg[1];
	uint32_t _cmic_stat_dma_ing_stats_cfg;
} BCM56504_A0_CMIC_STAT_DMA_ING_STATS_CFGr_t;

#define BCM56504_A0_CMIC_STAT_DMA_ING_STATS_CFGr_CLR(r) (r).cmic_stat_dma_ing_stats_cfg[0] = 0
#define BCM56504_A0_CMIC_STAT_DMA_ING_STATS_CFGr_SET(r,d) (r).cmic_stat_dma_ing_stats_cfg[0] = d
#define BCM56504_A0_CMIC_STAT_DMA_ING_STATS_CFGr_GET(r) (r).cmic_stat_dma_ing_stats_cfg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_STAT_DMA_ING_STATS_CFGr_ING_ETH_BLK_NUMf_GET(r) (((r).cmic_stat_dma_ing_stats_cfg[0]) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_ING_STATS_CFGr_ING_ETH_BLK_NUMf_SET(r,f) (r).cmic_stat_dma_ing_stats_cfg[0]=(((r).cmic_stat_dma_ing_stats_cfg[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56504_A0_CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_1f_GET(r) ((((r).cmic_stat_dma_ing_stats_cfg[0]) >> 4) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_1f_SET(r,f) (r).cmic_stat_dma_ing_stats_cfg[0]=(((r).cmic_stat_dma_ing_stats_cfg[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56504_A0_CMIC_STAT_DMA_ING_STATS_CFGr_ING_STAT_COUNTERS_NUMf_GET(r) ((((r).cmic_stat_dma_ing_stats_cfg[0]) >> 8) & 0x3f)
#define BCM56504_A0_CMIC_STAT_DMA_ING_STATS_CFGr_ING_STAT_COUNTERS_NUMf_SET(r,f) (r).cmic_stat_dma_ing_stats_cfg[0]=(((r).cmic_stat_dma_ing_stats_cfg[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define BCM56504_A0_CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_2f_GET(r) ((((r).cmic_stat_dma_ing_stats_cfg[0]) >> 14) & 0x3)
#define BCM56504_A0_CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_2f_SET(r,f) (r).cmic_stat_dma_ing_stats_cfg[0]=(((r).cmic_stat_dma_ing_stats_cfg[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCM56504_A0_CMIC_STAT_DMA_ING_STATS_CFGr_ING_STATS_PIPELINE_STAGE_NUMf_GET(r) ((((r).cmic_stat_dma_ing_stats_cfg[0]) >> 16) & 0x3f)
#define BCM56504_A0_CMIC_STAT_DMA_ING_STATS_CFGr_ING_STATS_PIPELINE_STAGE_NUMf_SET(r,f) (r).cmic_stat_dma_ing_stats_cfg[0]=(((r).cmic_stat_dma_ing_stats_cfg[0] & ~((uint32_t)0x3f << 16)) | ((((uint32_t)f) & 0x3f) << 16))
#define BCM56504_A0_CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_3f_GET(r) ((((r).cmic_stat_dma_ing_stats_cfg[0]) >> 22) & 0x3ff)
#define BCM56504_A0_CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_3f_SET(r,f) (r).cmic_stat_dma_ing_stats_cfg[0]=(((r).cmic_stat_dma_ing_stats_cfg[0] & ~((uint32_t)0x3ff << 22)) | ((((uint32_t)f) & 0x3ff) << 22))

/*
 * These macros can be used to access CMIC_STAT_DMA_ING_STATS_CFG.
 *
 */
#define BCM56504_A0_READ_CMIC_STAT_DMA_ING_STATS_CFGr(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_STAT_DMA_ING_STATS_CFGr,r._cmic_stat_dma_ing_stats_cfg)
#define BCM56504_A0_WRITE_CMIC_STAT_DMA_ING_STATS_CFGr(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_STAT_DMA_ING_STATS_CFGr,r._cmic_stat_dma_ing_stats_cfg)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_ING_STATS_CFGr BCM56504_A0_CMIC_STAT_DMA_ING_STATS_CFGr
#define CMIC_STAT_DMA_ING_STATS_CFGr_SIZE BCM56504_A0_CMIC_STAT_DMA_ING_STATS_CFGr_SIZE
typedef BCM56504_A0_CMIC_STAT_DMA_ING_STATS_CFGr_t CMIC_STAT_DMA_ING_STATS_CFGr_t;
#define CMIC_STAT_DMA_ING_STATS_CFGr_CLR BCM56504_A0_CMIC_STAT_DMA_ING_STATS_CFGr_CLR
#define CMIC_STAT_DMA_ING_STATS_CFGr_SET BCM56504_A0_CMIC_STAT_DMA_ING_STATS_CFGr_SET
#define CMIC_STAT_DMA_ING_STATS_CFGr_GET BCM56504_A0_CMIC_STAT_DMA_ING_STATS_CFGr_GET
#define CMIC_STAT_DMA_ING_STATS_CFGr_ING_ETH_BLK_NUMf_GET BCM56504_A0_CMIC_STAT_DMA_ING_STATS_CFGr_ING_ETH_BLK_NUMf_GET
#define CMIC_STAT_DMA_ING_STATS_CFGr_ING_ETH_BLK_NUMf_SET BCM56504_A0_CMIC_STAT_DMA_ING_STATS_CFGr_ING_ETH_BLK_NUMf_SET
#define CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_1f_GET BCM56504_A0_CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_1f_GET
#define CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_1f_SET BCM56504_A0_CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_1f_SET
#define CMIC_STAT_DMA_ING_STATS_CFGr_ING_STAT_COUNTERS_NUMf_GET BCM56504_A0_CMIC_STAT_DMA_ING_STATS_CFGr_ING_STAT_COUNTERS_NUMf_GET
#define CMIC_STAT_DMA_ING_STATS_CFGr_ING_STAT_COUNTERS_NUMf_SET BCM56504_A0_CMIC_STAT_DMA_ING_STATS_CFGr_ING_STAT_COUNTERS_NUMf_SET
#define CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_2f_GET BCM56504_A0_CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_2f_GET
#define CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_2f_SET BCM56504_A0_CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_2f_SET
#define CMIC_STAT_DMA_ING_STATS_CFGr_ING_STATS_PIPELINE_STAGE_NUMf_GET BCM56504_A0_CMIC_STAT_DMA_ING_STATS_CFGr_ING_STATS_PIPELINE_STAGE_NUMf_GET
#define CMIC_STAT_DMA_ING_STATS_CFGr_ING_STATS_PIPELINE_STAGE_NUMf_SET BCM56504_A0_CMIC_STAT_DMA_ING_STATS_CFGr_ING_STATS_PIPELINE_STAGE_NUMf_SET
#define CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_3f_GET BCM56504_A0_CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_3f_GET
#define CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_3f_SET BCM56504_A0_CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_3f_SET
#define READ_CMIC_STAT_DMA_ING_STATS_CFGr BCM56504_A0_READ_CMIC_STAT_DMA_ING_STATS_CFGr
#define WRITE_CMIC_STAT_DMA_ING_STATS_CFGr BCM56504_A0_WRITE_CMIC_STAT_DMA_ING_STATS_CFGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_STAT_DMA_ING_STATS_CFGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_STAT_DMA_MAC_STATS_CFG
 * BLOCKS:   CMIC
 * DESC:     Stats DMA MAC stats config register
 * SIZE:     32
 * FIELDS:
 *     MAC_G_STAT_COUNTERS_NUM Number of MAC GPORT Stats counters per port
 *     RESERVED_1       Reserved
 *     MAC_X_STAT_COUNTERS_NUM Number of MAC XPORT Stats counters per port
 *     RESERVED_2       Reserved
 *     MAC_STATS_PIPELINE_STAGE_NUM MAC stats counter stage number (if any), 
 *     RESERVED_3       Reserved
 *     CPU_STATS_PORT_NUM CPU Port number (for Stats DMA purposes), 
 *     RESERVED_4       Reserved
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_STAT_DMA_MAC_STATS_CFGr 0x00000468

#define BCM56504_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_MAC_STATS_CFG.
 *
 */
typedef union BCM56504_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_mac_stats_cfg[1];
	uint32_t _cmic_stat_dma_mac_stats_cfg;
} BCM56504_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_t;

#define BCM56504_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_CLR(r) (r).cmic_stat_dma_mac_stats_cfg[0] = 0
#define BCM56504_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_SET(r,d) (r).cmic_stat_dma_mac_stats_cfg[0] = d
#define BCM56504_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_GET(r) (r).cmic_stat_dma_mac_stats_cfg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_G_STAT_COUNTERS_NUMf_GET(r) (((r).cmic_stat_dma_mac_stats_cfg[0]) & 0x3f)
#define BCM56504_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_G_STAT_COUNTERS_NUMf_SET(r,f) (r).cmic_stat_dma_mac_stats_cfg[0]=(((r).cmic_stat_dma_mac_stats_cfg[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM56504_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_RESERVED_1f_GET(r) ((((r).cmic_stat_dma_mac_stats_cfg[0]) >> 6) & 0x3)
#define BCM56504_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_RESERVED_1f_SET(r,f) (r).cmic_stat_dma_mac_stats_cfg[0]=(((r).cmic_stat_dma_mac_stats_cfg[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM56504_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_X_STAT_COUNTERS_NUMf_GET(r) ((((r).cmic_stat_dma_mac_stats_cfg[0]) >> 8) & 0x7f)
#define BCM56504_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_X_STAT_COUNTERS_NUMf_SET(r,f) (r).cmic_stat_dma_mac_stats_cfg[0]=(((r).cmic_stat_dma_mac_stats_cfg[0] & ~((uint32_t)0x7f << 8)) | ((((uint32_t)f) & 0x7f) << 8))
#define BCM56504_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_RESERVED_2f_GET(r) ((((r).cmic_stat_dma_mac_stats_cfg[0]) >> 15) & 0x1)
#define BCM56504_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_RESERVED_2f_SET(r,f) (r).cmic_stat_dma_mac_stats_cfg[0]=(((r).cmic_stat_dma_mac_stats_cfg[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56504_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_STATS_PIPELINE_STAGE_NUMf_GET(r) ((((r).cmic_stat_dma_mac_stats_cfg[0]) >> 16) & 0x3f)
#define BCM56504_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_STATS_PIPELINE_STAGE_NUMf_SET(r,f) (r).cmic_stat_dma_mac_stats_cfg[0]=(((r).cmic_stat_dma_mac_stats_cfg[0] & ~((uint32_t)0x3f << 16)) | ((((uint32_t)f) & 0x3f) << 16))
#define BCM56504_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_RESERVED_3f_GET(r) ((((r).cmic_stat_dma_mac_stats_cfg[0]) >> 22) & 0x3)
#define BCM56504_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_RESERVED_3f_SET(r,f) (r).cmic_stat_dma_mac_stats_cfg[0]=(((r).cmic_stat_dma_mac_stats_cfg[0] & ~((uint32_t)0x3 << 22)) | ((((uint32_t)f) & 0x3) << 22))
#define BCM56504_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_CPU_STATS_PORT_NUMf_GET(r) ((((r).cmic_stat_dma_mac_stats_cfg[0]) >> 24) & 0x1f)
#define BCM56504_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_CPU_STATS_PORT_NUMf_SET(r,f) (r).cmic_stat_dma_mac_stats_cfg[0]=(((r).cmic_stat_dma_mac_stats_cfg[0] & ~((uint32_t)0x1f << 24)) | ((((uint32_t)f) & 0x1f) << 24))
#define BCM56504_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_RESERVED_4f_GET(r) ((((r).cmic_stat_dma_mac_stats_cfg[0]) >> 29) & 0x7)
#define BCM56504_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_RESERVED_4f_SET(r,f) (r).cmic_stat_dma_mac_stats_cfg[0]=(((r).cmic_stat_dma_mac_stats_cfg[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access CMIC_STAT_DMA_MAC_STATS_CFG.
 *
 */
#define BCM56504_A0_READ_CMIC_STAT_DMA_MAC_STATS_CFGr(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_STAT_DMA_MAC_STATS_CFGr,r._cmic_stat_dma_mac_stats_cfg)
#define BCM56504_A0_WRITE_CMIC_STAT_DMA_MAC_STATS_CFGr(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_STAT_DMA_MAC_STATS_CFGr,r._cmic_stat_dma_mac_stats_cfg)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_MAC_STATS_CFGr BCM56504_A0_CMIC_STAT_DMA_MAC_STATS_CFGr
#define CMIC_STAT_DMA_MAC_STATS_CFGr_SIZE BCM56504_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_SIZE
typedef BCM56504_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_t CMIC_STAT_DMA_MAC_STATS_CFGr_t;
#define CMIC_STAT_DMA_MAC_STATS_CFGr_CLR BCM56504_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_CLR
#define CMIC_STAT_DMA_MAC_STATS_CFGr_SET BCM56504_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_SET
#define CMIC_STAT_DMA_MAC_STATS_CFGr_GET BCM56504_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_GET
#define CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_G_STAT_COUNTERS_NUMf_GET BCM56504_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_G_STAT_COUNTERS_NUMf_GET
#define CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_G_STAT_COUNTERS_NUMf_SET BCM56504_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_G_STAT_COUNTERS_NUMf_SET
#define CMIC_STAT_DMA_MAC_STATS_CFGr_RESERVED_1f_GET BCM56504_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_RESERVED_1f_GET
#define CMIC_STAT_DMA_MAC_STATS_CFGr_RESERVED_1f_SET BCM56504_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_RESERVED_1f_SET
#define CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_X_STAT_COUNTERS_NUMf_GET BCM56504_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_X_STAT_COUNTERS_NUMf_GET
#define CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_X_STAT_COUNTERS_NUMf_SET BCM56504_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_X_STAT_COUNTERS_NUMf_SET
#define CMIC_STAT_DMA_MAC_STATS_CFGr_RESERVED_2f_GET BCM56504_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_RESERVED_2f_GET
#define CMIC_STAT_DMA_MAC_STATS_CFGr_RESERVED_2f_SET BCM56504_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_RESERVED_2f_SET
#define CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_STATS_PIPELINE_STAGE_NUMf_GET BCM56504_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_STATS_PIPELINE_STAGE_NUMf_GET
#define CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_STATS_PIPELINE_STAGE_NUMf_SET BCM56504_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_STATS_PIPELINE_STAGE_NUMf_SET
#define CMIC_STAT_DMA_MAC_STATS_CFGr_RESERVED_3f_GET BCM56504_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_RESERVED_3f_GET
#define CMIC_STAT_DMA_MAC_STATS_CFGr_RESERVED_3f_SET BCM56504_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_RESERVED_3f_SET
#define CMIC_STAT_DMA_MAC_STATS_CFGr_CPU_STATS_PORT_NUMf_GET BCM56504_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_CPU_STATS_PORT_NUMf_GET
#define CMIC_STAT_DMA_MAC_STATS_CFGr_CPU_STATS_PORT_NUMf_SET BCM56504_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_CPU_STATS_PORT_NUMf_SET
#define CMIC_STAT_DMA_MAC_STATS_CFGr_RESERVED_4f_GET BCM56504_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_RESERVED_4f_GET
#define CMIC_STAT_DMA_MAC_STATS_CFGr_RESERVED_4f_SET BCM56504_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_RESERVED_4f_SET
#define READ_CMIC_STAT_DMA_MAC_STATS_CFGr BCM56504_A0_READ_CMIC_STAT_DMA_MAC_STATS_CFGr
#define WRITE_CMIC_STAT_DMA_MAC_STATS_CFGr BCM56504_A0_WRITE_CMIC_STAT_DMA_MAC_STATS_CFGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_STAT_DMA_MAC_STATS_CFGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_STAT_DMA_PORTNUM_MAP_15_8
 * BLOCKS:   CMIC
 * DESC:     Stats DMA port <-> port-number map, ports 15 to 8

 * SIZE:     32
 * FIELDS:
 *     SBUS_PORTNUM_8   S-bus port number for port  8
 *     SBUS_PORTNUM_9   S-bus port number for port  9
 *     SBUS_PORTNUM_10  S-bus port number for port 10
 *     SBUS_PORTNUM_11  S-bus port number for port 11
 *     SBUS_PORTNUM_12  S-bus port number for port 12
 *     SBUS_PORTNUM_13  S-bus port number for port 13
 *     SBUS_PORTNUM_14  S-bus port number for port 14
 *     SBUS_PORTNUM_15  S-bus port number for port 15
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_8r 0x00000494

#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_8r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_PORTNUM_MAP_15_8.
 *
 */
typedef union BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_8r_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_portnum_map_15_8[1];
	uint32_t _cmic_stat_dma_portnum_map_15_8;
} BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_8r_t;

#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_8r_CLR(r) (r).cmic_stat_dma_portnum_map_15_8[0] = 0
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_8r_SET(r,d) (r).cmic_stat_dma_portnum_map_15_8[0] = d
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_8r_GET(r) (r).cmic_stat_dma_portnum_map_15_8[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_8r_SBUS_PORTNUM_8f_GET(r) (((r).cmic_stat_dma_portnum_map_15_8[0]) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_8r_SBUS_PORTNUM_8f_SET(r,f) (r).cmic_stat_dma_portnum_map_15_8[0]=(((r).cmic_stat_dma_portnum_map_15_8[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_8r_SBUS_PORTNUM_9f_GET(r) ((((r).cmic_stat_dma_portnum_map_15_8[0]) >> 4) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_8r_SBUS_PORTNUM_9f_SET(r,f) (r).cmic_stat_dma_portnum_map_15_8[0]=(((r).cmic_stat_dma_portnum_map_15_8[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_8r_SBUS_PORTNUM_10f_GET(r) ((((r).cmic_stat_dma_portnum_map_15_8[0]) >> 8) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_8r_SBUS_PORTNUM_10f_SET(r,f) (r).cmic_stat_dma_portnum_map_15_8[0]=(((r).cmic_stat_dma_portnum_map_15_8[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_8r_SBUS_PORTNUM_11f_GET(r) ((((r).cmic_stat_dma_portnum_map_15_8[0]) >> 12) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_8r_SBUS_PORTNUM_11f_SET(r,f) (r).cmic_stat_dma_portnum_map_15_8[0]=(((r).cmic_stat_dma_portnum_map_15_8[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_8r_SBUS_PORTNUM_12f_GET(r) ((((r).cmic_stat_dma_portnum_map_15_8[0]) >> 16) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_8r_SBUS_PORTNUM_12f_SET(r,f) (r).cmic_stat_dma_portnum_map_15_8[0]=(((r).cmic_stat_dma_portnum_map_15_8[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_8r_SBUS_PORTNUM_13f_GET(r) ((((r).cmic_stat_dma_portnum_map_15_8[0]) >> 20) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_8r_SBUS_PORTNUM_13f_SET(r,f) (r).cmic_stat_dma_portnum_map_15_8[0]=(((r).cmic_stat_dma_portnum_map_15_8[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_8r_SBUS_PORTNUM_14f_GET(r) ((((r).cmic_stat_dma_portnum_map_15_8[0]) >> 24) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_8r_SBUS_PORTNUM_14f_SET(r,f) (r).cmic_stat_dma_portnum_map_15_8[0]=(((r).cmic_stat_dma_portnum_map_15_8[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_8r_SBUS_PORTNUM_15f_GET(r) ((((r).cmic_stat_dma_portnum_map_15_8[0]) >> 28) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_8r_SBUS_PORTNUM_15f_SET(r,f) (r).cmic_stat_dma_portnum_map_15_8[0]=(((r).cmic_stat_dma_portnum_map_15_8[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access CMIC_STAT_DMA_PORTNUM_MAP_15_8.
 *
 */
#define BCM56504_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_15_8r(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_8r,r._cmic_stat_dma_portnum_map_15_8)
#define BCM56504_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_15_8r(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_8r,r._cmic_stat_dma_portnum_map_15_8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_PORTNUM_MAP_15_8r BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_8r
#define CMIC_STAT_DMA_PORTNUM_MAP_15_8r_SIZE BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_8r_SIZE
typedef BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_8r_t CMIC_STAT_DMA_PORTNUM_MAP_15_8r_t;
#define CMIC_STAT_DMA_PORTNUM_MAP_15_8r_CLR BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_8r_CLR
#define CMIC_STAT_DMA_PORTNUM_MAP_15_8r_SET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_8r_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_15_8r_GET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_8r_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_15_8r_SBUS_PORTNUM_8f_GET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_8r_SBUS_PORTNUM_8f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_15_8r_SBUS_PORTNUM_8f_SET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_8r_SBUS_PORTNUM_8f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_15_8r_SBUS_PORTNUM_9f_GET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_8r_SBUS_PORTNUM_9f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_15_8r_SBUS_PORTNUM_9f_SET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_8r_SBUS_PORTNUM_9f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_15_8r_SBUS_PORTNUM_10f_GET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_8r_SBUS_PORTNUM_10f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_15_8r_SBUS_PORTNUM_10f_SET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_8r_SBUS_PORTNUM_10f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_15_8r_SBUS_PORTNUM_11f_GET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_8r_SBUS_PORTNUM_11f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_15_8r_SBUS_PORTNUM_11f_SET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_8r_SBUS_PORTNUM_11f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_15_8r_SBUS_PORTNUM_12f_GET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_8r_SBUS_PORTNUM_12f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_15_8r_SBUS_PORTNUM_12f_SET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_8r_SBUS_PORTNUM_12f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_15_8r_SBUS_PORTNUM_13f_GET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_8r_SBUS_PORTNUM_13f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_15_8r_SBUS_PORTNUM_13f_SET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_8r_SBUS_PORTNUM_13f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_15_8r_SBUS_PORTNUM_14f_GET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_8r_SBUS_PORTNUM_14f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_15_8r_SBUS_PORTNUM_14f_SET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_8r_SBUS_PORTNUM_14f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_15_8r_SBUS_PORTNUM_15f_GET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_8r_SBUS_PORTNUM_15f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_15_8r_SBUS_PORTNUM_15f_SET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_8r_SBUS_PORTNUM_15f_SET
#define READ_CMIC_STAT_DMA_PORTNUM_MAP_15_8r BCM56504_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_15_8r
#define WRITE_CMIC_STAT_DMA_PORTNUM_MAP_15_8r BCM56504_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_15_8r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_STAT_DMA_PORTNUM_MAP_23_16
 * BLOCKS:   CMIC
 * DESC:     Stats DMA port <-> port-number map, ports 23 to 16

 * SIZE:     32
 * FIELDS:
 *     SBUS_PORTNUM_16  S-bus port number for port 16
 *     SBUS_PORTNUM_17  S-bus port number for port 17
 *     SBUS_PORTNUM_18  S-bus port number for port 18
 *     SBUS_PORTNUM_19  S-bus port number for port 19
 *     SBUS_PORTNUM_20  S-bus port number for port 20
 *     SBUS_PORTNUM_21  S-bus port number for port 21
 *     SBUS_PORTNUM_22  S-bus port number for port 22
 *     SBUS_PORTNUM_23  S-bus port number for port 23
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_16r 0x00000498

#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_16r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_PORTNUM_MAP_23_16.
 *
 */
typedef union BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_16r_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_portnum_map_23_16[1];
	uint32_t _cmic_stat_dma_portnum_map_23_16;
} BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_16r_t;

#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_16r_CLR(r) (r).cmic_stat_dma_portnum_map_23_16[0] = 0
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_16r_SET(r,d) (r).cmic_stat_dma_portnum_map_23_16[0] = d
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_16r_GET(r) (r).cmic_stat_dma_portnum_map_23_16[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_16r_SBUS_PORTNUM_16f_GET(r) (((r).cmic_stat_dma_portnum_map_23_16[0]) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_16r_SBUS_PORTNUM_16f_SET(r,f) (r).cmic_stat_dma_portnum_map_23_16[0]=(((r).cmic_stat_dma_portnum_map_23_16[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_16r_SBUS_PORTNUM_17f_GET(r) ((((r).cmic_stat_dma_portnum_map_23_16[0]) >> 4) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_16r_SBUS_PORTNUM_17f_SET(r,f) (r).cmic_stat_dma_portnum_map_23_16[0]=(((r).cmic_stat_dma_portnum_map_23_16[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_16r_SBUS_PORTNUM_18f_GET(r) ((((r).cmic_stat_dma_portnum_map_23_16[0]) >> 8) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_16r_SBUS_PORTNUM_18f_SET(r,f) (r).cmic_stat_dma_portnum_map_23_16[0]=(((r).cmic_stat_dma_portnum_map_23_16[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_16r_SBUS_PORTNUM_19f_GET(r) ((((r).cmic_stat_dma_portnum_map_23_16[0]) >> 12) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_16r_SBUS_PORTNUM_19f_SET(r,f) (r).cmic_stat_dma_portnum_map_23_16[0]=(((r).cmic_stat_dma_portnum_map_23_16[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_16r_SBUS_PORTNUM_20f_GET(r) ((((r).cmic_stat_dma_portnum_map_23_16[0]) >> 16) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_16r_SBUS_PORTNUM_20f_SET(r,f) (r).cmic_stat_dma_portnum_map_23_16[0]=(((r).cmic_stat_dma_portnum_map_23_16[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_16r_SBUS_PORTNUM_21f_GET(r) ((((r).cmic_stat_dma_portnum_map_23_16[0]) >> 20) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_16r_SBUS_PORTNUM_21f_SET(r,f) (r).cmic_stat_dma_portnum_map_23_16[0]=(((r).cmic_stat_dma_portnum_map_23_16[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_16r_SBUS_PORTNUM_22f_GET(r) ((((r).cmic_stat_dma_portnum_map_23_16[0]) >> 24) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_16r_SBUS_PORTNUM_22f_SET(r,f) (r).cmic_stat_dma_portnum_map_23_16[0]=(((r).cmic_stat_dma_portnum_map_23_16[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_16r_SBUS_PORTNUM_23f_GET(r) ((((r).cmic_stat_dma_portnum_map_23_16[0]) >> 28) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_16r_SBUS_PORTNUM_23f_SET(r,f) (r).cmic_stat_dma_portnum_map_23_16[0]=(((r).cmic_stat_dma_portnum_map_23_16[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access CMIC_STAT_DMA_PORTNUM_MAP_23_16.
 *
 */
#define BCM56504_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_23_16r(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_16r,r._cmic_stat_dma_portnum_map_23_16)
#define BCM56504_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_23_16r(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_16r,r._cmic_stat_dma_portnum_map_23_16)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_PORTNUM_MAP_23_16r BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_16r
#define CMIC_STAT_DMA_PORTNUM_MAP_23_16r_SIZE BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_16r_SIZE
typedef BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_16r_t CMIC_STAT_DMA_PORTNUM_MAP_23_16r_t;
#define CMIC_STAT_DMA_PORTNUM_MAP_23_16r_CLR BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_16r_CLR
#define CMIC_STAT_DMA_PORTNUM_MAP_23_16r_SET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_16r_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_23_16r_GET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_16r_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_23_16r_SBUS_PORTNUM_16f_GET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_16r_SBUS_PORTNUM_16f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_23_16r_SBUS_PORTNUM_16f_SET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_16r_SBUS_PORTNUM_16f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_23_16r_SBUS_PORTNUM_17f_GET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_16r_SBUS_PORTNUM_17f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_23_16r_SBUS_PORTNUM_17f_SET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_16r_SBUS_PORTNUM_17f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_23_16r_SBUS_PORTNUM_18f_GET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_16r_SBUS_PORTNUM_18f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_23_16r_SBUS_PORTNUM_18f_SET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_16r_SBUS_PORTNUM_18f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_23_16r_SBUS_PORTNUM_19f_GET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_16r_SBUS_PORTNUM_19f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_23_16r_SBUS_PORTNUM_19f_SET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_16r_SBUS_PORTNUM_19f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_23_16r_SBUS_PORTNUM_20f_GET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_16r_SBUS_PORTNUM_20f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_23_16r_SBUS_PORTNUM_20f_SET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_16r_SBUS_PORTNUM_20f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_23_16r_SBUS_PORTNUM_21f_GET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_16r_SBUS_PORTNUM_21f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_23_16r_SBUS_PORTNUM_21f_SET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_16r_SBUS_PORTNUM_21f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_23_16r_SBUS_PORTNUM_22f_GET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_16r_SBUS_PORTNUM_22f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_23_16r_SBUS_PORTNUM_22f_SET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_16r_SBUS_PORTNUM_22f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_23_16r_SBUS_PORTNUM_23f_GET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_16r_SBUS_PORTNUM_23f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_23_16r_SBUS_PORTNUM_23f_SET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_16r_SBUS_PORTNUM_23f_SET
#define READ_CMIC_STAT_DMA_PORTNUM_MAP_23_16r BCM56504_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_23_16r
#define WRITE_CMIC_STAT_DMA_PORTNUM_MAP_23_16r BCM56504_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_23_16r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_16r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_STAT_DMA_PORTNUM_MAP_31_24
 * BLOCKS:   CMIC
 * DESC:     Stats DMA port <-> port-number map, ports 31 to 24

 * SIZE:     32
 * FIELDS:
 *     SBUS_PORTNUM_24  S-bus port number for port 24
 *     SBUS_PORTNUM_25  S-bus port number for port 25
 *     SBUS_PORTNUM_26  S-bus port number for port 26
 *     SBUS_PORTNUM_27  S-bus port number for port 27
 *     SBUS_PORTNUM_28  S-bus port number for port 28
 *     SBUS_PORTNUM_29  S-bus port number for port 29
 *     SBUS_PORTNUM_30  S-bus port number for port 30
 *     SBUS_PORTNUM_31  S-bus port number for port 31
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_24r 0x0000049c

#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_24r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_PORTNUM_MAP_31_24.
 *
 */
typedef union BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_24r_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_portnum_map_31_24[1];
	uint32_t _cmic_stat_dma_portnum_map_31_24;
} BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_24r_t;

#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_24r_CLR(r) (r).cmic_stat_dma_portnum_map_31_24[0] = 0
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_24r_SET(r,d) (r).cmic_stat_dma_portnum_map_31_24[0] = d
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_24r_GET(r) (r).cmic_stat_dma_portnum_map_31_24[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_24r_SBUS_PORTNUM_24f_GET(r) (((r).cmic_stat_dma_portnum_map_31_24[0]) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_24r_SBUS_PORTNUM_24f_SET(r,f) (r).cmic_stat_dma_portnum_map_31_24[0]=(((r).cmic_stat_dma_portnum_map_31_24[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_24r_SBUS_PORTNUM_25f_GET(r) ((((r).cmic_stat_dma_portnum_map_31_24[0]) >> 4) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_24r_SBUS_PORTNUM_25f_SET(r,f) (r).cmic_stat_dma_portnum_map_31_24[0]=(((r).cmic_stat_dma_portnum_map_31_24[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_24r_SBUS_PORTNUM_26f_GET(r) ((((r).cmic_stat_dma_portnum_map_31_24[0]) >> 8) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_24r_SBUS_PORTNUM_26f_SET(r,f) (r).cmic_stat_dma_portnum_map_31_24[0]=(((r).cmic_stat_dma_portnum_map_31_24[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_24r_SBUS_PORTNUM_27f_GET(r) ((((r).cmic_stat_dma_portnum_map_31_24[0]) >> 12) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_24r_SBUS_PORTNUM_27f_SET(r,f) (r).cmic_stat_dma_portnum_map_31_24[0]=(((r).cmic_stat_dma_portnum_map_31_24[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_24r_SBUS_PORTNUM_28f_GET(r) ((((r).cmic_stat_dma_portnum_map_31_24[0]) >> 16) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_24r_SBUS_PORTNUM_28f_SET(r,f) (r).cmic_stat_dma_portnum_map_31_24[0]=(((r).cmic_stat_dma_portnum_map_31_24[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_24r_SBUS_PORTNUM_29f_GET(r) ((((r).cmic_stat_dma_portnum_map_31_24[0]) >> 20) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_24r_SBUS_PORTNUM_29f_SET(r,f) (r).cmic_stat_dma_portnum_map_31_24[0]=(((r).cmic_stat_dma_portnum_map_31_24[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_24r_SBUS_PORTNUM_30f_GET(r) ((((r).cmic_stat_dma_portnum_map_31_24[0]) >> 24) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_24r_SBUS_PORTNUM_30f_SET(r,f) (r).cmic_stat_dma_portnum_map_31_24[0]=(((r).cmic_stat_dma_portnum_map_31_24[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_24r_SBUS_PORTNUM_31f_GET(r) ((((r).cmic_stat_dma_portnum_map_31_24[0]) >> 28) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_24r_SBUS_PORTNUM_31f_SET(r,f) (r).cmic_stat_dma_portnum_map_31_24[0]=(((r).cmic_stat_dma_portnum_map_31_24[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access CMIC_STAT_DMA_PORTNUM_MAP_31_24.
 *
 */
#define BCM56504_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_31_24r(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_24r,r._cmic_stat_dma_portnum_map_31_24)
#define BCM56504_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_31_24r(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_24r,r._cmic_stat_dma_portnum_map_31_24)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_PORTNUM_MAP_31_24r BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_24r
#define CMIC_STAT_DMA_PORTNUM_MAP_31_24r_SIZE BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_24r_SIZE
typedef BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_24r_t CMIC_STAT_DMA_PORTNUM_MAP_31_24r_t;
#define CMIC_STAT_DMA_PORTNUM_MAP_31_24r_CLR BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_24r_CLR
#define CMIC_STAT_DMA_PORTNUM_MAP_31_24r_SET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_24r_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_31_24r_GET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_24r_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_31_24r_SBUS_PORTNUM_24f_GET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_24r_SBUS_PORTNUM_24f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_31_24r_SBUS_PORTNUM_24f_SET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_24r_SBUS_PORTNUM_24f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_31_24r_SBUS_PORTNUM_25f_GET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_24r_SBUS_PORTNUM_25f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_31_24r_SBUS_PORTNUM_25f_SET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_24r_SBUS_PORTNUM_25f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_31_24r_SBUS_PORTNUM_26f_GET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_24r_SBUS_PORTNUM_26f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_31_24r_SBUS_PORTNUM_26f_SET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_24r_SBUS_PORTNUM_26f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_31_24r_SBUS_PORTNUM_27f_GET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_24r_SBUS_PORTNUM_27f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_31_24r_SBUS_PORTNUM_27f_SET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_24r_SBUS_PORTNUM_27f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_31_24r_SBUS_PORTNUM_28f_GET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_24r_SBUS_PORTNUM_28f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_31_24r_SBUS_PORTNUM_28f_SET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_24r_SBUS_PORTNUM_28f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_31_24r_SBUS_PORTNUM_29f_GET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_24r_SBUS_PORTNUM_29f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_31_24r_SBUS_PORTNUM_29f_SET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_24r_SBUS_PORTNUM_29f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_31_24r_SBUS_PORTNUM_30f_GET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_24r_SBUS_PORTNUM_30f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_31_24r_SBUS_PORTNUM_30f_SET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_24r_SBUS_PORTNUM_30f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_31_24r_SBUS_PORTNUM_31f_GET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_24r_SBUS_PORTNUM_31f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_31_24r_SBUS_PORTNUM_31f_SET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_24r_SBUS_PORTNUM_31f_SET
#define READ_CMIC_STAT_DMA_PORTNUM_MAP_31_24r BCM56504_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_31_24r
#define WRITE_CMIC_STAT_DMA_PORTNUM_MAP_31_24r BCM56504_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_31_24r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_24r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_STAT_DMA_PORTNUM_MAP_7_0
 * BLOCKS:   CMIC
 * DESC:     Stats DMA port <-> port-number map, ports 7 to 0

 * SIZE:     32
 * FIELDS:
 *     SBUS_PORTNUM_0   S-bus port number for port 0
 *     SBUS_PORTNUM_1   S-bus port number for port 1
 *     SBUS_PORTNUM_2   S-bus port number for port 2
 *     SBUS_PORTNUM_3   S-bus port number for port 3
 *     SBUS_PORTNUM_4   S-bus port number for port 4
 *     SBUS_PORTNUM_5   S-bus port number for port 5
 *     SBUS_PORTNUM_6   S-bus port number for port 6
 *     SBUS_PORTNUM_7   S-bus port number for port 7
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_0r 0x00000490

#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_0r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_PORTNUM_MAP_7_0.
 *
 */
typedef union BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_0r_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_portnum_map_7_0[1];
	uint32_t _cmic_stat_dma_portnum_map_7_0;
} BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_0r_t;

#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_0r_CLR(r) (r).cmic_stat_dma_portnum_map_7_0[0] = 0
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_0r_SET(r,d) (r).cmic_stat_dma_portnum_map_7_0[0] = d
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_0r_GET(r) (r).cmic_stat_dma_portnum_map_7_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_0r_SBUS_PORTNUM_0f_GET(r) (((r).cmic_stat_dma_portnum_map_7_0[0]) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_0r_SBUS_PORTNUM_0f_SET(r,f) (r).cmic_stat_dma_portnum_map_7_0[0]=(((r).cmic_stat_dma_portnum_map_7_0[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_0r_SBUS_PORTNUM_1f_GET(r) ((((r).cmic_stat_dma_portnum_map_7_0[0]) >> 4) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_0r_SBUS_PORTNUM_1f_SET(r,f) (r).cmic_stat_dma_portnum_map_7_0[0]=(((r).cmic_stat_dma_portnum_map_7_0[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_0r_SBUS_PORTNUM_2f_GET(r) ((((r).cmic_stat_dma_portnum_map_7_0[0]) >> 8) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_0r_SBUS_PORTNUM_2f_SET(r,f) (r).cmic_stat_dma_portnum_map_7_0[0]=(((r).cmic_stat_dma_portnum_map_7_0[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_0r_SBUS_PORTNUM_3f_GET(r) ((((r).cmic_stat_dma_portnum_map_7_0[0]) >> 12) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_0r_SBUS_PORTNUM_3f_SET(r,f) (r).cmic_stat_dma_portnum_map_7_0[0]=(((r).cmic_stat_dma_portnum_map_7_0[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_0r_SBUS_PORTNUM_4f_GET(r) ((((r).cmic_stat_dma_portnum_map_7_0[0]) >> 16) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_0r_SBUS_PORTNUM_4f_SET(r,f) (r).cmic_stat_dma_portnum_map_7_0[0]=(((r).cmic_stat_dma_portnum_map_7_0[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_0r_SBUS_PORTNUM_5f_GET(r) ((((r).cmic_stat_dma_portnum_map_7_0[0]) >> 20) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_0r_SBUS_PORTNUM_5f_SET(r,f) (r).cmic_stat_dma_portnum_map_7_0[0]=(((r).cmic_stat_dma_portnum_map_7_0[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_0r_SBUS_PORTNUM_6f_GET(r) ((((r).cmic_stat_dma_portnum_map_7_0[0]) >> 24) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_0r_SBUS_PORTNUM_6f_SET(r,f) (r).cmic_stat_dma_portnum_map_7_0[0]=(((r).cmic_stat_dma_portnum_map_7_0[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_0r_SBUS_PORTNUM_7f_GET(r) ((((r).cmic_stat_dma_portnum_map_7_0[0]) >> 28) & 0xf)
#define BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_0r_SBUS_PORTNUM_7f_SET(r,f) (r).cmic_stat_dma_portnum_map_7_0[0]=(((r).cmic_stat_dma_portnum_map_7_0[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access CMIC_STAT_DMA_PORTNUM_MAP_7_0.
 *
 */
#define BCM56504_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_7_0r(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_0r,r._cmic_stat_dma_portnum_map_7_0)
#define BCM56504_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_7_0r(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_0r,r._cmic_stat_dma_portnum_map_7_0)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_PORTNUM_MAP_7_0r BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_0r
#define CMIC_STAT_DMA_PORTNUM_MAP_7_0r_SIZE BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_0r_SIZE
typedef BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_0r_t CMIC_STAT_DMA_PORTNUM_MAP_7_0r_t;
#define CMIC_STAT_DMA_PORTNUM_MAP_7_0r_CLR BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_0r_CLR
#define CMIC_STAT_DMA_PORTNUM_MAP_7_0r_SET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_0r_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_7_0r_GET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_0r_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_7_0r_SBUS_PORTNUM_0f_GET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_0r_SBUS_PORTNUM_0f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_7_0r_SBUS_PORTNUM_0f_SET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_0r_SBUS_PORTNUM_0f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_7_0r_SBUS_PORTNUM_1f_GET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_0r_SBUS_PORTNUM_1f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_7_0r_SBUS_PORTNUM_1f_SET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_0r_SBUS_PORTNUM_1f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_7_0r_SBUS_PORTNUM_2f_GET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_0r_SBUS_PORTNUM_2f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_7_0r_SBUS_PORTNUM_2f_SET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_0r_SBUS_PORTNUM_2f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_7_0r_SBUS_PORTNUM_3f_GET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_0r_SBUS_PORTNUM_3f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_7_0r_SBUS_PORTNUM_3f_SET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_0r_SBUS_PORTNUM_3f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_7_0r_SBUS_PORTNUM_4f_GET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_0r_SBUS_PORTNUM_4f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_7_0r_SBUS_PORTNUM_4f_SET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_0r_SBUS_PORTNUM_4f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_7_0r_SBUS_PORTNUM_5f_GET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_0r_SBUS_PORTNUM_5f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_7_0r_SBUS_PORTNUM_5f_SET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_0r_SBUS_PORTNUM_5f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_7_0r_SBUS_PORTNUM_6f_GET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_0r_SBUS_PORTNUM_6f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_7_0r_SBUS_PORTNUM_6f_SET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_0r_SBUS_PORTNUM_6f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_7_0r_SBUS_PORTNUM_7f_GET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_0r_SBUS_PORTNUM_7f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_7_0r_SBUS_PORTNUM_7f_SET BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_0r_SBUS_PORTNUM_7f_SET
#define READ_CMIC_STAT_DMA_PORTNUM_MAP_7_0r BCM56504_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_7_0r
#define WRITE_CMIC_STAT_DMA_PORTNUM_MAP_7_0r BCM56504_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_7_0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_STAT_DMA_PORTS
 * BLOCKS:   CMIC
 * DESC:     Stat Counter Port Bit Map Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           Stat Counter Port Bit Map
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_STAT_DMA_PORTSr 0x0000016c

#define BCM56504_A0_CMIC_STAT_DMA_PORTSr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_PORTS.
 *
 */
typedef union BCM56504_A0_CMIC_STAT_DMA_PORTSr_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_ports[1];
	uint32_t _cmic_stat_dma_ports;
} BCM56504_A0_CMIC_STAT_DMA_PORTSr_t;

#define BCM56504_A0_CMIC_STAT_DMA_PORTSr_CLR(r) (r).cmic_stat_dma_ports[0] = 0
#define BCM56504_A0_CMIC_STAT_DMA_PORTSr_SET(r,d) (r).cmic_stat_dma_ports[0] = d
#define BCM56504_A0_CMIC_STAT_DMA_PORTSr_GET(r) (r).cmic_stat_dma_ports[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_STAT_DMA_PORTSr_BITMAPf_GET(r) ((r).cmic_stat_dma_ports[0])
#define BCM56504_A0_CMIC_STAT_DMA_PORTSr_BITMAPf_SET(r,f) (r).cmic_stat_dma_ports[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_STAT_DMA_PORTS.
 *
 */
#define BCM56504_A0_READ_CMIC_STAT_DMA_PORTSr(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_STAT_DMA_PORTSr,r._cmic_stat_dma_ports)
#define BCM56504_A0_WRITE_CMIC_STAT_DMA_PORTSr(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_STAT_DMA_PORTSr,r._cmic_stat_dma_ports)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_PORTSr BCM56504_A0_CMIC_STAT_DMA_PORTSr
#define CMIC_STAT_DMA_PORTSr_SIZE BCM56504_A0_CMIC_STAT_DMA_PORTSr_SIZE
typedef BCM56504_A0_CMIC_STAT_DMA_PORTSr_t CMIC_STAT_DMA_PORTSr_t;
#define CMIC_STAT_DMA_PORTSr_CLR BCM56504_A0_CMIC_STAT_DMA_PORTSr_CLR
#define CMIC_STAT_DMA_PORTSr_SET BCM56504_A0_CMIC_STAT_DMA_PORTSr_SET
#define CMIC_STAT_DMA_PORTSr_GET BCM56504_A0_CMIC_STAT_DMA_PORTSr_GET
#define CMIC_STAT_DMA_PORTSr_BITMAPf_GET BCM56504_A0_CMIC_STAT_DMA_PORTSr_BITMAPf_GET
#define CMIC_STAT_DMA_PORTSr_BITMAPf_SET BCM56504_A0_CMIC_STAT_DMA_PORTSr_BITMAPf_SET
#define READ_CMIC_STAT_DMA_PORTSr BCM56504_A0_READ_CMIC_STAT_DMA_PORTSr
#define WRITE_CMIC_STAT_DMA_PORTSr BCM56504_A0_WRITE_CMIC_STAT_DMA_PORTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_STAT_DMA_PORTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_STAT_DMA_PORT_TYPE_MAP
 * BLOCKS:   CMIC
 * DESC:     Port type bitmap for Stat DMA: 0=Gig port, 1=Higig port
Note: The bitmap is index by port number.

 * SIZE:     32
 * FIELDS:
 *     BITMAP           0 bits are   Gig ports, so get MAC_G_STAT_COUNTERS_NUM counters1 bits are Higig ports, so get MAC_X_STAT_COUNTERS_NUM counters
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr 0x0000046c

#define BCM56504_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_PORT_TYPE_MAP.
 *
 */
typedef union BCM56504_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_port_type_map[1];
	uint32_t _cmic_stat_dma_port_type_map;
} BCM56504_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr_t;

#define BCM56504_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr_CLR(r) (r).cmic_stat_dma_port_type_map[0] = 0
#define BCM56504_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr_SET(r,d) (r).cmic_stat_dma_port_type_map[0] = d
#define BCM56504_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr_GET(r) (r).cmic_stat_dma_port_type_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr_BITMAPf_GET(r) ((r).cmic_stat_dma_port_type_map[0])
#define BCM56504_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr_BITMAPf_SET(r,f) (r).cmic_stat_dma_port_type_map[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_STAT_DMA_PORT_TYPE_MAP.
 *
 */
#define BCM56504_A0_READ_CMIC_STAT_DMA_PORT_TYPE_MAPr(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr,r._cmic_stat_dma_port_type_map)
#define BCM56504_A0_WRITE_CMIC_STAT_DMA_PORT_TYPE_MAPr(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr,r._cmic_stat_dma_port_type_map)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_PORT_TYPE_MAPr BCM56504_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr
#define CMIC_STAT_DMA_PORT_TYPE_MAPr_SIZE BCM56504_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr_SIZE
typedef BCM56504_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr_t CMIC_STAT_DMA_PORT_TYPE_MAPr_t;
#define CMIC_STAT_DMA_PORT_TYPE_MAPr_CLR BCM56504_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr_CLR
#define CMIC_STAT_DMA_PORT_TYPE_MAPr_SET BCM56504_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr_SET
#define CMIC_STAT_DMA_PORT_TYPE_MAPr_GET BCM56504_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr_GET
#define CMIC_STAT_DMA_PORT_TYPE_MAPr_BITMAPf_GET BCM56504_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr_BITMAPf_GET
#define CMIC_STAT_DMA_PORT_TYPE_MAPr_BITMAPf_SET BCM56504_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr_BITMAPf_SET
#define READ_CMIC_STAT_DMA_PORT_TYPE_MAPr BCM56504_A0_READ_CMIC_STAT_DMA_PORT_TYPE_MAPr
#define WRITE_CMIC_STAT_DMA_PORT_TYPE_MAPr BCM56504_A0_WRITE_CMIC_STAT_DMA_PORT_TYPE_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_STAT_DMA_SETUP
 * BLOCKS:   CMIC
 * DESC:     Stat Counter DMA Access Setup Register
 * SIZE:     32
 * FIELDS:
 *     RESERVED_1       Reserved
 *     TIME_VAL         Timer Value
 *     E_T              Enable Timer
 *     EN               Enable DMA
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_STAT_DMA_SETUPr 0x00000168

#define BCM56504_A0_CMIC_STAT_DMA_SETUPr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_SETUP.
 *
 */
typedef union BCM56504_A0_CMIC_STAT_DMA_SETUPr_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_setup[1];
	uint32_t _cmic_stat_dma_setup;
} BCM56504_A0_CMIC_STAT_DMA_SETUPr_t;

#define BCM56504_A0_CMIC_STAT_DMA_SETUPr_CLR(r) (r).cmic_stat_dma_setup[0] = 0
#define BCM56504_A0_CMIC_STAT_DMA_SETUPr_SET(r,d) (r).cmic_stat_dma_setup[0] = d
#define BCM56504_A0_CMIC_STAT_DMA_SETUPr_GET(r) (r).cmic_stat_dma_setup[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_STAT_DMA_SETUPr_RESERVED_1f_GET(r) (((r).cmic_stat_dma_setup[0]) & 0xffff)
#define BCM56504_A0_CMIC_STAT_DMA_SETUPr_RESERVED_1f_SET(r,f) (r).cmic_stat_dma_setup[0]=(((r).cmic_stat_dma_setup[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56504_A0_CMIC_STAT_DMA_SETUPr_TIME_VALf_GET(r) ((((r).cmic_stat_dma_setup[0]) >> 16) & 0x3fff)
#define BCM56504_A0_CMIC_STAT_DMA_SETUPr_TIME_VALf_SET(r,f) (r).cmic_stat_dma_setup[0]=(((r).cmic_stat_dma_setup[0] & ~((uint32_t)0x3fff << 16)) | ((((uint32_t)f) & 0x3fff) << 16))
#define BCM56504_A0_CMIC_STAT_DMA_SETUPr_E_Tf_GET(r) ((((r).cmic_stat_dma_setup[0]) >> 30) & 0x1)
#define BCM56504_A0_CMIC_STAT_DMA_SETUPr_E_Tf_SET(r,f) (r).cmic_stat_dma_setup[0]=(((r).cmic_stat_dma_setup[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM56504_A0_CMIC_STAT_DMA_SETUPr_ENf_GET(r) ((((r).cmic_stat_dma_setup[0]) >> 31) & 0x1)
#define BCM56504_A0_CMIC_STAT_DMA_SETUPr_ENf_SET(r,f) (r).cmic_stat_dma_setup[0]=(((r).cmic_stat_dma_setup[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access CMIC_STAT_DMA_SETUP.
 *
 */
#define BCM56504_A0_READ_CMIC_STAT_DMA_SETUPr(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_STAT_DMA_SETUPr,r._cmic_stat_dma_setup)
#define BCM56504_A0_WRITE_CMIC_STAT_DMA_SETUPr(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_STAT_DMA_SETUPr,r._cmic_stat_dma_setup)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_SETUPr BCM56504_A0_CMIC_STAT_DMA_SETUPr
#define CMIC_STAT_DMA_SETUPr_SIZE BCM56504_A0_CMIC_STAT_DMA_SETUPr_SIZE
typedef BCM56504_A0_CMIC_STAT_DMA_SETUPr_t CMIC_STAT_DMA_SETUPr_t;
#define CMIC_STAT_DMA_SETUPr_CLR BCM56504_A0_CMIC_STAT_DMA_SETUPr_CLR
#define CMIC_STAT_DMA_SETUPr_SET BCM56504_A0_CMIC_STAT_DMA_SETUPr_SET
#define CMIC_STAT_DMA_SETUPr_GET BCM56504_A0_CMIC_STAT_DMA_SETUPr_GET
#define CMIC_STAT_DMA_SETUPr_RESERVED_1f_GET BCM56504_A0_CMIC_STAT_DMA_SETUPr_RESERVED_1f_GET
#define CMIC_STAT_DMA_SETUPr_RESERVED_1f_SET BCM56504_A0_CMIC_STAT_DMA_SETUPr_RESERVED_1f_SET
#define CMIC_STAT_DMA_SETUPr_TIME_VALf_GET BCM56504_A0_CMIC_STAT_DMA_SETUPr_TIME_VALf_GET
#define CMIC_STAT_DMA_SETUPr_TIME_VALf_SET BCM56504_A0_CMIC_STAT_DMA_SETUPr_TIME_VALf_SET
#define CMIC_STAT_DMA_SETUPr_E_Tf_GET BCM56504_A0_CMIC_STAT_DMA_SETUPr_E_Tf_GET
#define CMIC_STAT_DMA_SETUPr_E_Tf_SET BCM56504_A0_CMIC_STAT_DMA_SETUPr_E_Tf_SET
#define CMIC_STAT_DMA_SETUPr_ENf_GET BCM56504_A0_CMIC_STAT_DMA_SETUPr_ENf_GET
#define CMIC_STAT_DMA_SETUPr_ENf_SET BCM56504_A0_CMIC_STAT_DMA_SETUPr_ENf_SET
#define READ_CMIC_STAT_DMA_SETUPr BCM56504_A0_READ_CMIC_STAT_DMA_SETUPr
#define WRITE_CMIC_STAT_DMA_SETUPr BCM56504_A0_WRITE_CMIC_STAT_DMA_SETUPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_STAT_DMA_SETUPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_SW_PIO_ACK_DATA_BEAT_COUNT
 * BLOCKS:   CMIC
 * DESC:     Debug register that provides the number of data
beats in the last SW PIO S-bus ACK

 * SIZE:     32
 * FIELDS:
 *     BEAT_COUNT       Beat count
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr 0x00000404

#define BCM56504_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SW_PIO_ACK_DATA_BEAT_COUNT.
 *
 */
typedef union BCM56504_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_s {
	uint32_t v[1];
	uint32_t cmic_sw_pio_ack_data_beat_count[1];
	uint32_t _cmic_sw_pio_ack_data_beat_count;
} BCM56504_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_t;

#define BCM56504_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_CLR(r) (r).cmic_sw_pio_ack_data_beat_count[0] = 0
#define BCM56504_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_SET(r,d) (r).cmic_sw_pio_ack_data_beat_count[0] = d
#define BCM56504_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_GET(r) (r).cmic_sw_pio_ack_data_beat_count[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_BEAT_COUNTf_GET(r) (((r).cmic_sw_pio_ack_data_beat_count[0]) & 0x1f)
#define BCM56504_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_BEAT_COUNTf_SET(r,f) (r).cmic_sw_pio_ack_data_beat_count[0]=(((r).cmic_sw_pio_ack_data_beat_count[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56504_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_RESERVED_0f_GET(r) ((((r).cmic_sw_pio_ack_data_beat_count[0]) >> 5) & 0x7ffffff)
#define BCM56504_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_RESERVED_0f_SET(r,f) (r).cmic_sw_pio_ack_data_beat_count[0]=(((r).cmic_sw_pio_ack_data_beat_count[0] & ~((uint32_t)0x7ffffff << 5)) | ((((uint32_t)f) & 0x7ffffff) << 5))

/*
 * These macros can be used to access CMIC_SW_PIO_ACK_DATA_BEAT_COUNT.
 *
 */
#define BCM56504_A0_READ_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr,r._cmic_sw_pio_ack_data_beat_count)
#define BCM56504_A0_WRITE_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr,r._cmic_sw_pio_ack_data_beat_count)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr BCM56504_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr
#define CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_SIZE BCM56504_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_SIZE
typedef BCM56504_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_t CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_t;
#define CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_CLR BCM56504_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_CLR
#define CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_SET BCM56504_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_SET
#define CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_GET BCM56504_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_GET
#define CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_BEAT_COUNTf_GET BCM56504_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_BEAT_COUNTf_GET
#define CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_BEAT_COUNTf_SET BCM56504_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_BEAT_COUNTf_SET
#define CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_RESERVED_0f_GET BCM56504_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_RESERVED_0f_GET
#define CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_RESERVED_0f_SET BCM56504_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_RESERVED_0f_SET
#define READ_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr BCM56504_A0_READ_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr
#define WRITE_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr BCM56504_A0_WRITE_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_TABLE_DMA_CFG
 * BLOCKS:   CMIC
 * DESC:     Table DMA Config Register
 * SIZE:     32
 * FIELDS:
 *     EN               Set by CPU to Enable Table DMA Transfer
 *     ABORT            Set by CPU to Abort Table DMA Transfer
 *     DONE             Set by CMIC to indicate Table DMA Transfer Completion.Can be cleared (but not set) by CPU.
 *     ERROR            Set by CMIC to indicate Table DMA Transfer wasaborted due to an error (most probably due to a NACK).Can be cleared (but not set) by CPU.
 *     RESERVED_1       Reserved
 *     BEATS            Written by CPU indicating number of data beats.For Table DMA purposes, each table entry is 32-bit aligned.The widest S-bus table wr/rd supported is 640 bits.So, the valid values for this field are 1-20 (beats).
 *     RESERVED_2       Reserved
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_TABLE_DMA_CFGr 0x0000042c

#define BCM56504_A0_CMIC_TABLE_DMA_CFGr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_TABLE_DMA_CFG.
 *
 */
typedef union BCM56504_A0_CMIC_TABLE_DMA_CFGr_s {
	uint32_t v[1];
	uint32_t cmic_table_dma_cfg[1];
	uint32_t _cmic_table_dma_cfg;
} BCM56504_A0_CMIC_TABLE_DMA_CFGr_t;

#define BCM56504_A0_CMIC_TABLE_DMA_CFGr_CLR(r) (r).cmic_table_dma_cfg[0] = 0
#define BCM56504_A0_CMIC_TABLE_DMA_CFGr_SET(r,d) (r).cmic_table_dma_cfg[0] = d
#define BCM56504_A0_CMIC_TABLE_DMA_CFGr_GET(r) (r).cmic_table_dma_cfg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_TABLE_DMA_CFGr_ENf_GET(r) (((r).cmic_table_dma_cfg[0]) & 0x1)
#define BCM56504_A0_CMIC_TABLE_DMA_CFGr_ENf_SET(r,f) (r).cmic_table_dma_cfg[0]=(((r).cmic_table_dma_cfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_CMIC_TABLE_DMA_CFGr_ABORTf_GET(r) ((((r).cmic_table_dma_cfg[0]) >> 1) & 0x1)
#define BCM56504_A0_CMIC_TABLE_DMA_CFGr_ABORTf_SET(r,f) (r).cmic_table_dma_cfg[0]=(((r).cmic_table_dma_cfg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_CMIC_TABLE_DMA_CFGr_DONEf_GET(r) ((((r).cmic_table_dma_cfg[0]) >> 2) & 0x1)
#define BCM56504_A0_CMIC_TABLE_DMA_CFGr_DONEf_SET(r,f) (r).cmic_table_dma_cfg[0]=(((r).cmic_table_dma_cfg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_CMIC_TABLE_DMA_CFGr_ERRORf_GET(r) ((((r).cmic_table_dma_cfg[0]) >> 3) & 0x1)
#define BCM56504_A0_CMIC_TABLE_DMA_CFGr_ERRORf_SET(r,f) (r).cmic_table_dma_cfg[0]=(((r).cmic_table_dma_cfg[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_CMIC_TABLE_DMA_CFGr_RESERVED_1f_GET(r) ((((r).cmic_table_dma_cfg[0]) >> 4) & 0xfff)
#define BCM56504_A0_CMIC_TABLE_DMA_CFGr_RESERVED_1f_SET(r,f) (r).cmic_table_dma_cfg[0]=(((r).cmic_table_dma_cfg[0] & ~((uint32_t)0xfff << 4)) | ((((uint32_t)f) & 0xfff) << 4))
#define BCM56504_A0_CMIC_TABLE_DMA_CFGr_BEATSf_GET(r) ((((r).cmic_table_dma_cfg[0]) >> 16) & 0x1f)
#define BCM56504_A0_CMIC_TABLE_DMA_CFGr_BEATSf_SET(r,f) (r).cmic_table_dma_cfg[0]=(((r).cmic_table_dma_cfg[0] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define BCM56504_A0_CMIC_TABLE_DMA_CFGr_RESERVED_2f_GET(r) ((((r).cmic_table_dma_cfg[0]) >> 21) & 0x7ff)
#define BCM56504_A0_CMIC_TABLE_DMA_CFGr_RESERVED_2f_SET(r,f) (r).cmic_table_dma_cfg[0]=(((r).cmic_table_dma_cfg[0] & ~((uint32_t)0x7ff << 21)) | ((((uint32_t)f) & 0x7ff) << 21))

/*
 * These macros can be used to access CMIC_TABLE_DMA_CFG.
 *
 */
#define BCM56504_A0_READ_CMIC_TABLE_DMA_CFGr(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_TABLE_DMA_CFGr,r._cmic_table_dma_cfg)
#define BCM56504_A0_WRITE_CMIC_TABLE_DMA_CFGr(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_TABLE_DMA_CFGr,r._cmic_table_dma_cfg)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_TABLE_DMA_CFGr BCM56504_A0_CMIC_TABLE_DMA_CFGr
#define CMIC_TABLE_DMA_CFGr_SIZE BCM56504_A0_CMIC_TABLE_DMA_CFGr_SIZE
typedef BCM56504_A0_CMIC_TABLE_DMA_CFGr_t CMIC_TABLE_DMA_CFGr_t;
#define CMIC_TABLE_DMA_CFGr_CLR BCM56504_A0_CMIC_TABLE_DMA_CFGr_CLR
#define CMIC_TABLE_DMA_CFGr_SET BCM56504_A0_CMIC_TABLE_DMA_CFGr_SET
#define CMIC_TABLE_DMA_CFGr_GET BCM56504_A0_CMIC_TABLE_DMA_CFGr_GET
#define CMIC_TABLE_DMA_CFGr_ENf_GET BCM56504_A0_CMIC_TABLE_DMA_CFGr_ENf_GET
#define CMIC_TABLE_DMA_CFGr_ENf_SET BCM56504_A0_CMIC_TABLE_DMA_CFGr_ENf_SET
#define CMIC_TABLE_DMA_CFGr_ABORTf_GET BCM56504_A0_CMIC_TABLE_DMA_CFGr_ABORTf_GET
#define CMIC_TABLE_DMA_CFGr_ABORTf_SET BCM56504_A0_CMIC_TABLE_DMA_CFGr_ABORTf_SET
#define CMIC_TABLE_DMA_CFGr_DONEf_GET BCM56504_A0_CMIC_TABLE_DMA_CFGr_DONEf_GET
#define CMIC_TABLE_DMA_CFGr_DONEf_SET BCM56504_A0_CMIC_TABLE_DMA_CFGr_DONEf_SET
#define CMIC_TABLE_DMA_CFGr_ERRORf_GET BCM56504_A0_CMIC_TABLE_DMA_CFGr_ERRORf_GET
#define CMIC_TABLE_DMA_CFGr_ERRORf_SET BCM56504_A0_CMIC_TABLE_DMA_CFGr_ERRORf_SET
#define CMIC_TABLE_DMA_CFGr_RESERVED_1f_GET BCM56504_A0_CMIC_TABLE_DMA_CFGr_RESERVED_1f_GET
#define CMIC_TABLE_DMA_CFGr_RESERVED_1f_SET BCM56504_A0_CMIC_TABLE_DMA_CFGr_RESERVED_1f_SET
#define CMIC_TABLE_DMA_CFGr_BEATSf_GET BCM56504_A0_CMIC_TABLE_DMA_CFGr_BEATSf_GET
#define CMIC_TABLE_DMA_CFGr_BEATSf_SET BCM56504_A0_CMIC_TABLE_DMA_CFGr_BEATSf_SET
#define CMIC_TABLE_DMA_CFGr_RESERVED_2f_GET BCM56504_A0_CMIC_TABLE_DMA_CFGr_RESERVED_2f_GET
#define CMIC_TABLE_DMA_CFGr_RESERVED_2f_SET BCM56504_A0_CMIC_TABLE_DMA_CFGr_RESERVED_2f_SET
#define READ_CMIC_TABLE_DMA_CFGr BCM56504_A0_READ_CMIC_TABLE_DMA_CFGr
#define WRITE_CMIC_TABLE_DMA_CFGr BCM56504_A0_WRITE_CMIC_TABLE_DMA_CFGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_TABLE_DMA_CFGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDR
 * BLOCKS:   CMIC
 * DESC:     Table DMA Current Entry S-bus Address Register
 * SIZE:     32
 * FIELDS:
 *     ADDR             Written by CMIC indicating S-bus address of the Table Entrycurrently being processed
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr 0x00000434

#define BCM56504_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDR.
 *
 */
typedef union BCM56504_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_s {
	uint32_t v[1];
	uint32_t cmic_table_dma_cur_entry_sbus_addr[1];
	uint32_t _cmic_table_dma_cur_entry_sbus_addr;
} BCM56504_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_t;

#define BCM56504_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_CLR(r) (r).cmic_table_dma_cur_entry_sbus_addr[0] = 0
#define BCM56504_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_SET(r,d) (r).cmic_table_dma_cur_entry_sbus_addr[0] = d
#define BCM56504_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_GET(r) (r).cmic_table_dma_cur_entry_sbus_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_ADDRf_GET(r) ((r).cmic_table_dma_cur_entry_sbus_addr[0])
#define BCM56504_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_ADDRf_SET(r,f) (r).cmic_table_dma_cur_entry_sbus_addr[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDR.
 *
 */
#define BCM56504_A0_READ_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr,r._cmic_table_dma_cur_entry_sbus_addr)
#define BCM56504_A0_WRITE_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr,r._cmic_table_dma_cur_entry_sbus_addr)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr BCM56504_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr
#define CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_SIZE BCM56504_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_SIZE
typedef BCM56504_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_t CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_t;
#define CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_CLR BCM56504_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_CLR
#define CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_SET BCM56504_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_SET
#define CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_GET BCM56504_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_GET
#define CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_ADDRf_GET BCM56504_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_ADDRf_GET
#define CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_ADDRf_SET BCM56504_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_ADDRf_SET
#define READ_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr BCM56504_A0_READ_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr
#define WRITE_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr BCM56504_A0_WRITE_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_TABLE_DMA_ENTRY_COUNT
 * BLOCKS:   CMIC
 * DESC:     Table DMA Entry Count Register
 * SIZE:     32
 * FIELDS:
 *     COUNT            Written by CPU indicating number of Table entries for Table DMA.
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_TABLE_DMA_ENTRY_COUNTr 0x00000428

#define BCM56504_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_TABLE_DMA_ENTRY_COUNT.
 *
 */
typedef union BCM56504_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_s {
	uint32_t v[1];
	uint32_t cmic_table_dma_entry_count[1];
	uint32_t _cmic_table_dma_entry_count;
} BCM56504_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_t;

#define BCM56504_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_CLR(r) (r).cmic_table_dma_entry_count[0] = 0
#define BCM56504_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_SET(r,d) (r).cmic_table_dma_entry_count[0] = d
#define BCM56504_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_GET(r) (r).cmic_table_dma_entry_count[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_COUNTf_GET(r) (((r).cmic_table_dma_entry_count[0]) & 0xffffff)
#define BCM56504_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_COUNTf_SET(r,f) (r).cmic_table_dma_entry_count[0]=(((r).cmic_table_dma_entry_count[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))
#define BCM56504_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_RESERVED_1f_GET(r) ((((r).cmic_table_dma_entry_count[0]) >> 24) & 0xff)
#define BCM56504_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_RESERVED_1f_SET(r,f) (r).cmic_table_dma_entry_count[0]=(((r).cmic_table_dma_entry_count[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access CMIC_TABLE_DMA_ENTRY_COUNT.
 *
 */
#define BCM56504_A0_READ_CMIC_TABLE_DMA_ENTRY_COUNTr(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_TABLE_DMA_ENTRY_COUNTr,r._cmic_table_dma_entry_count)
#define BCM56504_A0_WRITE_CMIC_TABLE_DMA_ENTRY_COUNTr(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_TABLE_DMA_ENTRY_COUNTr,r._cmic_table_dma_entry_count)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_TABLE_DMA_ENTRY_COUNTr BCM56504_A0_CMIC_TABLE_DMA_ENTRY_COUNTr
#define CMIC_TABLE_DMA_ENTRY_COUNTr_SIZE BCM56504_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_SIZE
typedef BCM56504_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_t CMIC_TABLE_DMA_ENTRY_COUNTr_t;
#define CMIC_TABLE_DMA_ENTRY_COUNTr_CLR BCM56504_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_CLR
#define CMIC_TABLE_DMA_ENTRY_COUNTr_SET BCM56504_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_SET
#define CMIC_TABLE_DMA_ENTRY_COUNTr_GET BCM56504_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_GET
#define CMIC_TABLE_DMA_ENTRY_COUNTr_COUNTf_GET BCM56504_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_COUNTf_GET
#define CMIC_TABLE_DMA_ENTRY_COUNTr_COUNTf_SET BCM56504_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_COUNTf_SET
#define CMIC_TABLE_DMA_ENTRY_COUNTr_RESERVED_1f_GET BCM56504_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_RESERVED_1f_GET
#define CMIC_TABLE_DMA_ENTRY_COUNTr_RESERVED_1f_SET BCM56504_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_RESERVED_1f_SET
#define READ_CMIC_TABLE_DMA_ENTRY_COUNTr BCM56504_A0_READ_CMIC_TABLE_DMA_ENTRY_COUNTr
#define WRITE_CMIC_TABLE_DMA_ENTRY_COUNTr BCM56504_A0_WRITE_CMIC_TABLE_DMA_ENTRY_COUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_TABLE_DMA_ENTRY_COUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_TABLE_DMA_PCIMEM_START_ADDR
 * BLOCKS:   CMIC
 * DESC:     Table DMA PCI Memory Start Address Register

 * SIZE:     32
 * FIELDS:
 *     ADDR             Written by CPU indicating Table DMA Physical (PCI) Memory Start Address
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr 0x00000420

#define BCM56504_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_TABLE_DMA_PCIMEM_START_ADDR.
 *
 */
typedef union BCM56504_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr_s {
	uint32_t v[1];
	uint32_t cmic_table_dma_pcimem_start_addr[1];
	uint32_t _cmic_table_dma_pcimem_start_addr;
} BCM56504_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr_t;

#define BCM56504_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr_CLR(r) (r).cmic_table_dma_pcimem_start_addr[0] = 0
#define BCM56504_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr_SET(r,d) (r).cmic_table_dma_pcimem_start_addr[0] = d
#define BCM56504_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr_GET(r) (r).cmic_table_dma_pcimem_start_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr_ADDRf_GET(r) ((r).cmic_table_dma_pcimem_start_addr[0])
#define BCM56504_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr_ADDRf_SET(r,f) (r).cmic_table_dma_pcimem_start_addr[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_TABLE_DMA_PCIMEM_START_ADDR.
 *
 */
#define BCM56504_A0_READ_CMIC_TABLE_DMA_PCIMEM_START_ADDRr(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr,r._cmic_table_dma_pcimem_start_addr)
#define BCM56504_A0_WRITE_CMIC_TABLE_DMA_PCIMEM_START_ADDRr(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr,r._cmic_table_dma_pcimem_start_addr)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_TABLE_DMA_PCIMEM_START_ADDRr BCM56504_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr
#define CMIC_TABLE_DMA_PCIMEM_START_ADDRr_SIZE BCM56504_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr_SIZE
typedef BCM56504_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr_t CMIC_TABLE_DMA_PCIMEM_START_ADDRr_t;
#define CMIC_TABLE_DMA_PCIMEM_START_ADDRr_CLR BCM56504_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr_CLR
#define CMIC_TABLE_DMA_PCIMEM_START_ADDRr_SET BCM56504_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr_SET
#define CMIC_TABLE_DMA_PCIMEM_START_ADDRr_GET BCM56504_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr_GET
#define CMIC_TABLE_DMA_PCIMEM_START_ADDRr_ADDRf_GET BCM56504_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr_ADDRf_GET
#define CMIC_TABLE_DMA_PCIMEM_START_ADDRr_ADDRf_SET BCM56504_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr_ADDRf_SET
#define READ_CMIC_TABLE_DMA_PCIMEM_START_ADDRr BCM56504_A0_READ_CMIC_TABLE_DMA_PCIMEM_START_ADDRr
#define WRITE_CMIC_TABLE_DMA_PCIMEM_START_ADDRr BCM56504_A0_WRITE_CMIC_TABLE_DMA_PCIMEM_START_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_TABLE_DMA_SBUS_START_ADDR
 * BLOCKS:   CMIC
 * DESC:     Table DMA S-bus Start Address Register

 * SIZE:     32
 * FIELDS:
 *     ADDR             Written by CPU indicating Table DMA Logical (S-bus) Memory Start Address. This address has the followingfields: table (6b), block (4b) and region+index (20b)
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr 0x00000424

#define BCM56504_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_TABLE_DMA_SBUS_START_ADDR.
 *
 */
typedef union BCM56504_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr_s {
	uint32_t v[1];
	uint32_t cmic_table_dma_sbus_start_addr[1];
	uint32_t _cmic_table_dma_sbus_start_addr;
} BCM56504_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr_t;

#define BCM56504_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr_CLR(r) (r).cmic_table_dma_sbus_start_addr[0] = 0
#define BCM56504_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr_SET(r,d) (r).cmic_table_dma_sbus_start_addr[0] = d
#define BCM56504_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr_GET(r) (r).cmic_table_dma_sbus_start_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr_ADDRf_GET(r) ((r).cmic_table_dma_sbus_start_addr[0])
#define BCM56504_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr_ADDRf_SET(r,f) (r).cmic_table_dma_sbus_start_addr[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_TABLE_DMA_SBUS_START_ADDR.
 *
 */
#define BCM56504_A0_READ_CMIC_TABLE_DMA_SBUS_START_ADDRr(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr,r._cmic_table_dma_sbus_start_addr)
#define BCM56504_A0_WRITE_CMIC_TABLE_DMA_SBUS_START_ADDRr(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr,r._cmic_table_dma_sbus_start_addr)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_TABLE_DMA_SBUS_START_ADDRr BCM56504_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr
#define CMIC_TABLE_DMA_SBUS_START_ADDRr_SIZE BCM56504_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr_SIZE
typedef BCM56504_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr_t CMIC_TABLE_DMA_SBUS_START_ADDRr_t;
#define CMIC_TABLE_DMA_SBUS_START_ADDRr_CLR BCM56504_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr_CLR
#define CMIC_TABLE_DMA_SBUS_START_ADDRr_SET BCM56504_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr_SET
#define CMIC_TABLE_DMA_SBUS_START_ADDRr_GET BCM56504_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr_GET
#define CMIC_TABLE_DMA_SBUS_START_ADDRr_ADDRf_GET BCM56504_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr_ADDRf_GET
#define CMIC_TABLE_DMA_SBUS_START_ADDRr_ADDRf_SET BCM56504_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr_ADDRf_SET
#define READ_CMIC_TABLE_DMA_SBUS_START_ADDRr BCM56504_A0_READ_CMIC_TABLE_DMA_SBUS_START_ADDRr
#define WRITE_CMIC_TABLE_DMA_SBUS_START_ADDRr BCM56504_A0_WRITE_CMIC_TABLE_DMA_SBUS_START_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_TAP_CONTROL
 * BLOCKS:   CMIC
 * DESC:     Must follow TAP protocol to initiate BIST and read BIST results

 * SIZE:     32
 * FIELDS:
 *     TDI              Tap control data in
 *     TMS              Test mode select
 *     TCK              TAP clock
 *     TRST             TAP reset
 *     TDO              TAP data out
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_TAP_CONTROLr 0x00000194

#define BCM56504_A0_CMIC_TAP_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_TAP_CONTROL.
 *
 */
typedef union BCM56504_A0_CMIC_TAP_CONTROLr_s {
	uint32_t v[1];
	uint32_t cmic_tap_control[1];
	uint32_t _cmic_tap_control;
} BCM56504_A0_CMIC_TAP_CONTROLr_t;

#define BCM56504_A0_CMIC_TAP_CONTROLr_CLR(r) (r).cmic_tap_control[0] = 0
#define BCM56504_A0_CMIC_TAP_CONTROLr_SET(r,d) (r).cmic_tap_control[0] = d
#define BCM56504_A0_CMIC_TAP_CONTROLr_GET(r) (r).cmic_tap_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_TAP_CONTROLr_TDIf_GET(r) (((r).cmic_tap_control[0]) & 0x1)
#define BCM56504_A0_CMIC_TAP_CONTROLr_TDIf_SET(r,f) (r).cmic_tap_control[0]=(((r).cmic_tap_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_CMIC_TAP_CONTROLr_TMSf_GET(r) ((((r).cmic_tap_control[0]) >> 1) & 0x1)
#define BCM56504_A0_CMIC_TAP_CONTROLr_TMSf_SET(r,f) (r).cmic_tap_control[0]=(((r).cmic_tap_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_CMIC_TAP_CONTROLr_TCKf_GET(r) ((((r).cmic_tap_control[0]) >> 2) & 0x1)
#define BCM56504_A0_CMIC_TAP_CONTROLr_TCKf_SET(r,f) (r).cmic_tap_control[0]=(((r).cmic_tap_control[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_CMIC_TAP_CONTROLr_TRSTf_GET(r) ((((r).cmic_tap_control[0]) >> 3) & 0x1)
#define BCM56504_A0_CMIC_TAP_CONTROLr_TRSTf_SET(r,f) (r).cmic_tap_control[0]=(((r).cmic_tap_control[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_CMIC_TAP_CONTROLr_TDOf_GET(r) ((((r).cmic_tap_control[0]) >> 4) & 0x1)
#define BCM56504_A0_CMIC_TAP_CONTROLr_TDOf_SET(r,f) (r).cmic_tap_control[0]=(((r).cmic_tap_control[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56504_A0_CMIC_TAP_CONTROLr_RESERVED_1f_GET(r) ((((r).cmic_tap_control[0]) >> 5) & 0x7ffffff)
#define BCM56504_A0_CMIC_TAP_CONTROLr_RESERVED_1f_SET(r,f) (r).cmic_tap_control[0]=(((r).cmic_tap_control[0] & ~((uint32_t)0x7ffffff << 5)) | ((((uint32_t)f) & 0x7ffffff) << 5))

/*
 * These macros can be used to access CMIC_TAP_CONTROL.
 *
 */
#define BCM56504_A0_READ_CMIC_TAP_CONTROLr(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_TAP_CONTROLr,r._cmic_tap_control)
#define BCM56504_A0_WRITE_CMIC_TAP_CONTROLr(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_TAP_CONTROLr,r._cmic_tap_control)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_TAP_CONTROLr BCM56504_A0_CMIC_TAP_CONTROLr
#define CMIC_TAP_CONTROLr_SIZE BCM56504_A0_CMIC_TAP_CONTROLr_SIZE
typedef BCM56504_A0_CMIC_TAP_CONTROLr_t CMIC_TAP_CONTROLr_t;
#define CMIC_TAP_CONTROLr_CLR BCM56504_A0_CMIC_TAP_CONTROLr_CLR
#define CMIC_TAP_CONTROLr_SET BCM56504_A0_CMIC_TAP_CONTROLr_SET
#define CMIC_TAP_CONTROLr_GET BCM56504_A0_CMIC_TAP_CONTROLr_GET
#define CMIC_TAP_CONTROLr_TDIf_GET BCM56504_A0_CMIC_TAP_CONTROLr_TDIf_GET
#define CMIC_TAP_CONTROLr_TDIf_SET BCM56504_A0_CMIC_TAP_CONTROLr_TDIf_SET
#define CMIC_TAP_CONTROLr_TMSf_GET BCM56504_A0_CMIC_TAP_CONTROLr_TMSf_GET
#define CMIC_TAP_CONTROLr_TMSf_SET BCM56504_A0_CMIC_TAP_CONTROLr_TMSf_SET
#define CMIC_TAP_CONTROLr_TCKf_GET BCM56504_A0_CMIC_TAP_CONTROLr_TCKf_GET
#define CMIC_TAP_CONTROLr_TCKf_SET BCM56504_A0_CMIC_TAP_CONTROLr_TCKf_SET
#define CMIC_TAP_CONTROLr_TRSTf_GET BCM56504_A0_CMIC_TAP_CONTROLr_TRSTf_GET
#define CMIC_TAP_CONTROLr_TRSTf_SET BCM56504_A0_CMIC_TAP_CONTROLr_TRSTf_SET
#define CMIC_TAP_CONTROLr_TDOf_GET BCM56504_A0_CMIC_TAP_CONTROLr_TDOf_GET
#define CMIC_TAP_CONTROLr_TDOf_SET BCM56504_A0_CMIC_TAP_CONTROLr_TDOf_SET
#define CMIC_TAP_CONTROLr_RESERVED_1f_GET BCM56504_A0_CMIC_TAP_CONTROLr_RESERVED_1f_GET
#define CMIC_TAP_CONTROLr_RESERVED_1f_SET BCM56504_A0_CMIC_TAP_CONTROLr_RESERVED_1f_SET
#define READ_CMIC_TAP_CONTROLr BCM56504_A0_READ_CMIC_TAP_CONTROLr
#define WRITE_CMIC_TAP_CONTROLr BCM56504_A0_WRITE_CMIC_TAP_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_TAP_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_XGXS_MDIO_CONFIG
 * BLOCKS:   CMIC
 * DESC:     CMIC XGXS MDIO Config 0 register
 * SIZE:     32
 * FIELDS:
 *     IEEE_DEVICES_IN_PKG IEEE devices in XGXS package
 *     MD_DEVAD         MDIO Device address
 *     MD_ST            Internal phy clause 45 select bitWhen 0, use clause 22 MIIM (historic)  addressing.When 1, use clause 45 MIIM (new style) addressing.
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIGr 0x00000500

#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_XGXS_MDIO_CONFIG.
 *
 */
typedef union BCM56504_A0_CMIC_XGXS_MDIO_CONFIGr_s {
	uint32_t v[1];
	uint32_t cmic_xgxs_mdio_config[1];
	uint32_t _cmic_xgxs_mdio_config;
} BCM56504_A0_CMIC_XGXS_MDIO_CONFIGr_t;

#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIGr_CLR(r) (r).cmic_xgxs_mdio_config[0] = 0
#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIGr_SET(r,d) (r).cmic_xgxs_mdio_config[0] = d
#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIGr_GET(r) (r).cmic_xgxs_mdio_config[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIGr_IEEE_DEVICES_IN_PKGf_GET(r) (((r).cmic_xgxs_mdio_config[0]) & 0xff)
#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIGr_IEEE_DEVICES_IN_PKGf_SET(r,f) (r).cmic_xgxs_mdio_config[0]=(((r).cmic_xgxs_mdio_config[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIGr_MD_DEVADf_GET(r) ((((r).cmic_xgxs_mdio_config[0]) >> 8) & 0x1f)
#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIGr_MD_DEVADf_SET(r,f) (r).cmic_xgxs_mdio_config[0]=(((r).cmic_xgxs_mdio_config[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIGr_MD_STf_GET(r) ((((r).cmic_xgxs_mdio_config[0]) >> 13) & 0x1)
#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIGr_MD_STf_SET(r,f) (r).cmic_xgxs_mdio_config[0]=(((r).cmic_xgxs_mdio_config[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIGr_RESERVED_0f_GET(r) ((((r).cmic_xgxs_mdio_config[0]) >> 14) & 0x3ffff)
#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIGr_RESERVED_0f_SET(r,f) (r).cmic_xgxs_mdio_config[0]=(((r).cmic_xgxs_mdio_config[0] & ~((uint32_t)0x3ffff << 14)) | ((((uint32_t)f) & 0x3ffff) << 14))

/*
 * These macros can be used to access CMIC_XGXS_MDIO_CONFIG.
 *
 */
#define BCM56504_A0_READ_CMIC_XGXS_MDIO_CONFIGr(u,i,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_XGXS_MDIO_CONFIGr+(4*(i)),r._cmic_xgxs_mdio_config)
#define BCM56504_A0_WRITE_CMIC_XGXS_MDIO_CONFIGr(u,i,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_XGXS_MDIO_CONFIGr+(4*(i)),r._cmic_xgxs_mdio_config)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_XGXS_MDIO_CONFIGr BCM56504_A0_CMIC_XGXS_MDIO_CONFIGr
#define CMIC_XGXS_MDIO_CONFIGr_SIZE BCM56504_A0_CMIC_XGXS_MDIO_CONFIGr_SIZE
typedef BCM56504_A0_CMIC_XGXS_MDIO_CONFIGr_t CMIC_XGXS_MDIO_CONFIGr_t;
#define CMIC_XGXS_MDIO_CONFIGr_CLR BCM56504_A0_CMIC_XGXS_MDIO_CONFIGr_CLR
#define CMIC_XGXS_MDIO_CONFIGr_SET BCM56504_A0_CMIC_XGXS_MDIO_CONFIGr_SET
#define CMIC_XGXS_MDIO_CONFIGr_GET BCM56504_A0_CMIC_XGXS_MDIO_CONFIGr_GET
#define CMIC_XGXS_MDIO_CONFIGr_IEEE_DEVICES_IN_PKGf_GET BCM56504_A0_CMIC_XGXS_MDIO_CONFIGr_IEEE_DEVICES_IN_PKGf_GET
#define CMIC_XGXS_MDIO_CONFIGr_IEEE_DEVICES_IN_PKGf_SET BCM56504_A0_CMIC_XGXS_MDIO_CONFIGr_IEEE_DEVICES_IN_PKGf_SET
#define CMIC_XGXS_MDIO_CONFIGr_MD_DEVADf_GET BCM56504_A0_CMIC_XGXS_MDIO_CONFIGr_MD_DEVADf_GET
#define CMIC_XGXS_MDIO_CONFIGr_MD_DEVADf_SET BCM56504_A0_CMIC_XGXS_MDIO_CONFIGr_MD_DEVADf_SET
#define CMIC_XGXS_MDIO_CONFIGr_MD_STf_GET BCM56504_A0_CMIC_XGXS_MDIO_CONFIGr_MD_STf_GET
#define CMIC_XGXS_MDIO_CONFIGr_MD_STf_SET BCM56504_A0_CMIC_XGXS_MDIO_CONFIGr_MD_STf_SET
#define CMIC_XGXS_MDIO_CONFIGr_RESERVED_0f_GET BCM56504_A0_CMIC_XGXS_MDIO_CONFIGr_RESERVED_0f_GET
#define CMIC_XGXS_MDIO_CONFIGr_RESERVED_0f_SET BCM56504_A0_CMIC_XGXS_MDIO_CONFIGr_RESERVED_0f_SET
#define READ_CMIC_XGXS_MDIO_CONFIGr BCM56504_A0_READ_CMIC_XGXS_MDIO_CONFIGr
#define WRITE_CMIC_XGXS_MDIO_CONFIGr BCM56504_A0_WRITE_CMIC_XGXS_MDIO_CONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_XGXS_MDIO_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_XGXS_MDIO_CONFIG_0
 * BLOCKS:   CMIC
 * DESC:     CMIC XGXS MDIO Config 0 register
 * SIZE:     32
 * FIELDS:
 *     IEEE_DEVICES_IN_PKG IEEE devices in XGXS package
 *     MD_DEVAD         MDIO Device address
 *     MD_ST            Internal phy clause 45 select bitWhen 0, use clause 22 MIIM (historic)  addressing.When 1, use clause 45 MIIM (new style) addressing.
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_0r 0x00000500

#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_0r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_XGXS_MDIO_CONFIG_0.
 *
 */
typedef union BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_0r_s {
	uint32_t v[1];
	uint32_t cmic_xgxs_mdio_config_0[1];
	uint32_t _cmic_xgxs_mdio_config_0;
} BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_0r_t;

#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_0r_CLR(r) (r).cmic_xgxs_mdio_config_0[0] = 0
#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_0r_SET(r,d) (r).cmic_xgxs_mdio_config_0[0] = d
#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_0r_GET(r) (r).cmic_xgxs_mdio_config_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_0r_IEEE_DEVICES_IN_PKGf_GET(r) (((r).cmic_xgxs_mdio_config_0[0]) & 0xff)
#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_0r_IEEE_DEVICES_IN_PKGf_SET(r,f) (r).cmic_xgxs_mdio_config_0[0]=(((r).cmic_xgxs_mdio_config_0[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_0r_MD_DEVADf_GET(r) ((((r).cmic_xgxs_mdio_config_0[0]) >> 8) & 0x1f)
#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_0r_MD_DEVADf_SET(r,f) (r).cmic_xgxs_mdio_config_0[0]=(((r).cmic_xgxs_mdio_config_0[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_0r_MD_STf_GET(r) ((((r).cmic_xgxs_mdio_config_0[0]) >> 13) & 0x1)
#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_0r_MD_STf_SET(r,f) (r).cmic_xgxs_mdio_config_0[0]=(((r).cmic_xgxs_mdio_config_0[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_0r_RESERVED_0f_GET(r) ((((r).cmic_xgxs_mdio_config_0[0]) >> 14) & 0x3ffff)
#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_0r_RESERVED_0f_SET(r,f) (r).cmic_xgxs_mdio_config_0[0]=(((r).cmic_xgxs_mdio_config_0[0] & ~((uint32_t)0x3ffff << 14)) | ((((uint32_t)f) & 0x3ffff) << 14))

/*
 * These macros can be used to access CMIC_XGXS_MDIO_CONFIG_0.
 *
 */
#define BCM56504_A0_READ_CMIC_XGXS_MDIO_CONFIG_0r(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_0r,r._cmic_xgxs_mdio_config_0)
#define BCM56504_A0_WRITE_CMIC_XGXS_MDIO_CONFIG_0r(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_0r,r._cmic_xgxs_mdio_config_0)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_XGXS_MDIO_CONFIG_0r BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_0r
#define CMIC_XGXS_MDIO_CONFIG_0r_SIZE BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_0r_SIZE
typedef BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_0r_t CMIC_XGXS_MDIO_CONFIG_0r_t;
#define CMIC_XGXS_MDIO_CONFIG_0r_CLR BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_0r_CLR
#define CMIC_XGXS_MDIO_CONFIG_0r_SET BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_0r_SET
#define CMIC_XGXS_MDIO_CONFIG_0r_GET BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_0r_GET
#define CMIC_XGXS_MDIO_CONFIG_0r_IEEE_DEVICES_IN_PKGf_GET BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_0r_IEEE_DEVICES_IN_PKGf_GET
#define CMIC_XGXS_MDIO_CONFIG_0r_IEEE_DEVICES_IN_PKGf_SET BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_0r_IEEE_DEVICES_IN_PKGf_SET
#define CMIC_XGXS_MDIO_CONFIG_0r_MD_DEVADf_GET BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_0r_MD_DEVADf_GET
#define CMIC_XGXS_MDIO_CONFIG_0r_MD_DEVADf_SET BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_0r_MD_DEVADf_SET
#define CMIC_XGXS_MDIO_CONFIG_0r_MD_STf_GET BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_0r_MD_STf_GET
#define CMIC_XGXS_MDIO_CONFIG_0r_MD_STf_SET BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_0r_MD_STf_SET
#define CMIC_XGXS_MDIO_CONFIG_0r_RESERVED_0f_GET BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_0r_RESERVED_0f_GET
#define CMIC_XGXS_MDIO_CONFIG_0r_RESERVED_0f_SET BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_0r_RESERVED_0f_SET
#define READ_CMIC_XGXS_MDIO_CONFIG_0r BCM56504_A0_READ_CMIC_XGXS_MDIO_CONFIG_0r
#define WRITE_CMIC_XGXS_MDIO_CONFIG_0r BCM56504_A0_WRITE_CMIC_XGXS_MDIO_CONFIG_0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_XGXS_MDIO_CONFIG_1
 * BLOCKS:   CMIC
 * DESC:     CMIC XGXS MDIO Config 1 register
 * SIZE:     32
 * FIELDS:
 *     IEEE_DEVICES_IN_PKG IEEE devices in XGXS package
 *     MD_DEVAD         MDIO Device address
 *     MD_ST            Internal phy clause 45 select bitWhen 0, use clause 22 MIIM (historic)  addressing.When 1, use clause 45 MIIM (new style) addressing.
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_1r 0x00000504

#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_1r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_XGXS_MDIO_CONFIG_1.
 *
 */
typedef union BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_1r_s {
	uint32_t v[1];
	uint32_t cmic_xgxs_mdio_config_1[1];
	uint32_t _cmic_xgxs_mdio_config_1;
} BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_1r_t;

#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_1r_CLR(r) (r).cmic_xgxs_mdio_config_1[0] = 0
#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_1r_SET(r,d) (r).cmic_xgxs_mdio_config_1[0] = d
#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_1r_GET(r) (r).cmic_xgxs_mdio_config_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_1r_IEEE_DEVICES_IN_PKGf_GET(r) (((r).cmic_xgxs_mdio_config_1[0]) & 0xff)
#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_1r_IEEE_DEVICES_IN_PKGf_SET(r,f) (r).cmic_xgxs_mdio_config_1[0]=(((r).cmic_xgxs_mdio_config_1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_1r_MD_DEVADf_GET(r) ((((r).cmic_xgxs_mdio_config_1[0]) >> 8) & 0x1f)
#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_1r_MD_DEVADf_SET(r,f) (r).cmic_xgxs_mdio_config_1[0]=(((r).cmic_xgxs_mdio_config_1[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_1r_MD_STf_GET(r) ((((r).cmic_xgxs_mdio_config_1[0]) >> 13) & 0x1)
#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_1r_MD_STf_SET(r,f) (r).cmic_xgxs_mdio_config_1[0]=(((r).cmic_xgxs_mdio_config_1[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_1r_RESERVED_0f_GET(r) ((((r).cmic_xgxs_mdio_config_1[0]) >> 14) & 0x3ffff)
#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_1r_RESERVED_0f_SET(r,f) (r).cmic_xgxs_mdio_config_1[0]=(((r).cmic_xgxs_mdio_config_1[0] & ~((uint32_t)0x3ffff << 14)) | ((((uint32_t)f) & 0x3ffff) << 14))

/*
 * These macros can be used to access CMIC_XGXS_MDIO_CONFIG_1.
 *
 */
#define BCM56504_A0_READ_CMIC_XGXS_MDIO_CONFIG_1r(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_1r,r._cmic_xgxs_mdio_config_1)
#define BCM56504_A0_WRITE_CMIC_XGXS_MDIO_CONFIG_1r(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_1r,r._cmic_xgxs_mdio_config_1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_XGXS_MDIO_CONFIG_1r BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_1r
#define CMIC_XGXS_MDIO_CONFIG_1r_SIZE BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_1r_SIZE
typedef BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_1r_t CMIC_XGXS_MDIO_CONFIG_1r_t;
#define CMIC_XGXS_MDIO_CONFIG_1r_CLR BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_1r_CLR
#define CMIC_XGXS_MDIO_CONFIG_1r_SET BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_1r_SET
#define CMIC_XGXS_MDIO_CONFIG_1r_GET BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_1r_GET
#define CMIC_XGXS_MDIO_CONFIG_1r_IEEE_DEVICES_IN_PKGf_GET BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_1r_IEEE_DEVICES_IN_PKGf_GET
#define CMIC_XGXS_MDIO_CONFIG_1r_IEEE_DEVICES_IN_PKGf_SET BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_1r_IEEE_DEVICES_IN_PKGf_SET
#define CMIC_XGXS_MDIO_CONFIG_1r_MD_DEVADf_GET BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_1r_MD_DEVADf_GET
#define CMIC_XGXS_MDIO_CONFIG_1r_MD_DEVADf_SET BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_1r_MD_DEVADf_SET
#define CMIC_XGXS_MDIO_CONFIG_1r_MD_STf_GET BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_1r_MD_STf_GET
#define CMIC_XGXS_MDIO_CONFIG_1r_MD_STf_SET BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_1r_MD_STf_SET
#define CMIC_XGXS_MDIO_CONFIG_1r_RESERVED_0f_GET BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_1r_RESERVED_0f_GET
#define CMIC_XGXS_MDIO_CONFIG_1r_RESERVED_0f_SET BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_1r_RESERVED_0f_SET
#define READ_CMIC_XGXS_MDIO_CONFIG_1r BCM56504_A0_READ_CMIC_XGXS_MDIO_CONFIG_1r
#define WRITE_CMIC_XGXS_MDIO_CONFIG_1r BCM56504_A0_WRITE_CMIC_XGXS_MDIO_CONFIG_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_XGXS_MDIO_CONFIG_2
 * BLOCKS:   CMIC
 * DESC:     CMIC XGXS MDIO Config 2 register
 * SIZE:     32
 * FIELDS:
 *     IEEE_DEVICES_IN_PKG IEEE devices in XGXS package
 *     MD_DEVAD         MDIO Device address
 *     MD_ST            Internal phy clause 45 select bitWhen 0, use clause 22 MIIM (historic)  addressing.When 1, use clause 45 MIIM (new style) addressing.
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_2r 0x00000508

#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_2r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_XGXS_MDIO_CONFIG_2.
 *
 */
typedef union BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_2r_s {
	uint32_t v[1];
	uint32_t cmic_xgxs_mdio_config_2[1];
	uint32_t _cmic_xgxs_mdio_config_2;
} BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_2r_t;

#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_2r_CLR(r) (r).cmic_xgxs_mdio_config_2[0] = 0
#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_2r_SET(r,d) (r).cmic_xgxs_mdio_config_2[0] = d
#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_2r_GET(r) (r).cmic_xgxs_mdio_config_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_2r_IEEE_DEVICES_IN_PKGf_GET(r) (((r).cmic_xgxs_mdio_config_2[0]) & 0xff)
#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_2r_IEEE_DEVICES_IN_PKGf_SET(r,f) (r).cmic_xgxs_mdio_config_2[0]=(((r).cmic_xgxs_mdio_config_2[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_2r_MD_DEVADf_GET(r) ((((r).cmic_xgxs_mdio_config_2[0]) >> 8) & 0x1f)
#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_2r_MD_DEVADf_SET(r,f) (r).cmic_xgxs_mdio_config_2[0]=(((r).cmic_xgxs_mdio_config_2[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_2r_MD_STf_GET(r) ((((r).cmic_xgxs_mdio_config_2[0]) >> 13) & 0x1)
#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_2r_MD_STf_SET(r,f) (r).cmic_xgxs_mdio_config_2[0]=(((r).cmic_xgxs_mdio_config_2[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_2r_RESERVED_0f_GET(r) ((((r).cmic_xgxs_mdio_config_2[0]) >> 14) & 0x3ffff)
#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_2r_RESERVED_0f_SET(r,f) (r).cmic_xgxs_mdio_config_2[0]=(((r).cmic_xgxs_mdio_config_2[0] & ~((uint32_t)0x3ffff << 14)) | ((((uint32_t)f) & 0x3ffff) << 14))

/*
 * These macros can be used to access CMIC_XGXS_MDIO_CONFIG_2.
 *
 */
#define BCM56504_A0_READ_CMIC_XGXS_MDIO_CONFIG_2r(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_2r,r._cmic_xgxs_mdio_config_2)
#define BCM56504_A0_WRITE_CMIC_XGXS_MDIO_CONFIG_2r(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_2r,r._cmic_xgxs_mdio_config_2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_XGXS_MDIO_CONFIG_2r BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_2r
#define CMIC_XGXS_MDIO_CONFIG_2r_SIZE BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_2r_SIZE
typedef BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_2r_t CMIC_XGXS_MDIO_CONFIG_2r_t;
#define CMIC_XGXS_MDIO_CONFIG_2r_CLR BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_2r_CLR
#define CMIC_XGXS_MDIO_CONFIG_2r_SET BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_2r_SET
#define CMIC_XGXS_MDIO_CONFIG_2r_GET BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_2r_GET
#define CMIC_XGXS_MDIO_CONFIG_2r_IEEE_DEVICES_IN_PKGf_GET BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_2r_IEEE_DEVICES_IN_PKGf_GET
#define CMIC_XGXS_MDIO_CONFIG_2r_IEEE_DEVICES_IN_PKGf_SET BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_2r_IEEE_DEVICES_IN_PKGf_SET
#define CMIC_XGXS_MDIO_CONFIG_2r_MD_DEVADf_GET BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_2r_MD_DEVADf_GET
#define CMIC_XGXS_MDIO_CONFIG_2r_MD_DEVADf_SET BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_2r_MD_DEVADf_SET
#define CMIC_XGXS_MDIO_CONFIG_2r_MD_STf_GET BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_2r_MD_STf_GET
#define CMIC_XGXS_MDIO_CONFIG_2r_MD_STf_SET BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_2r_MD_STf_SET
#define CMIC_XGXS_MDIO_CONFIG_2r_RESERVED_0f_GET BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_2r_RESERVED_0f_GET
#define CMIC_XGXS_MDIO_CONFIG_2r_RESERVED_0f_SET BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_2r_RESERVED_0f_SET
#define READ_CMIC_XGXS_MDIO_CONFIG_2r BCM56504_A0_READ_CMIC_XGXS_MDIO_CONFIG_2r
#define WRITE_CMIC_XGXS_MDIO_CONFIG_2r BCM56504_A0_WRITE_CMIC_XGXS_MDIO_CONFIG_2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_XGXS_MDIO_CONFIG_3
 * BLOCKS:   CMIC
 * DESC:     CMIC XGXS MDIO Config 3 register
 * SIZE:     32
 * FIELDS:
 *     IEEE_DEVICES_IN_PKG IEEE devices in XGXS package
 *     MD_DEVAD         MDIO Device address
 *     MD_ST            Internal phy clause 45 select bitWhen 0, use clause 22 MIIM (historic)  addressing.When 1, use clause 45 MIIM (new style) addressing.
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_3r 0x0000050c

#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_3r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_XGXS_MDIO_CONFIG_3.
 *
 */
typedef union BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_3r_s {
	uint32_t v[1];
	uint32_t cmic_xgxs_mdio_config_3[1];
	uint32_t _cmic_xgxs_mdio_config_3;
} BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_3r_t;

#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_3r_CLR(r) (r).cmic_xgxs_mdio_config_3[0] = 0
#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_3r_SET(r,d) (r).cmic_xgxs_mdio_config_3[0] = d
#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_3r_GET(r) (r).cmic_xgxs_mdio_config_3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_3r_IEEE_DEVICES_IN_PKGf_GET(r) (((r).cmic_xgxs_mdio_config_3[0]) & 0xff)
#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_3r_IEEE_DEVICES_IN_PKGf_SET(r,f) (r).cmic_xgxs_mdio_config_3[0]=(((r).cmic_xgxs_mdio_config_3[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_3r_MD_DEVADf_GET(r) ((((r).cmic_xgxs_mdio_config_3[0]) >> 8) & 0x1f)
#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_3r_MD_DEVADf_SET(r,f) (r).cmic_xgxs_mdio_config_3[0]=(((r).cmic_xgxs_mdio_config_3[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_3r_MD_STf_GET(r) ((((r).cmic_xgxs_mdio_config_3[0]) >> 13) & 0x1)
#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_3r_MD_STf_SET(r,f) (r).cmic_xgxs_mdio_config_3[0]=(((r).cmic_xgxs_mdio_config_3[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_3r_RESERVED_0f_GET(r) ((((r).cmic_xgxs_mdio_config_3[0]) >> 14) & 0x3ffff)
#define BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_3r_RESERVED_0f_SET(r,f) (r).cmic_xgxs_mdio_config_3[0]=(((r).cmic_xgxs_mdio_config_3[0] & ~((uint32_t)0x3ffff << 14)) | ((((uint32_t)f) & 0x3ffff) << 14))

/*
 * These macros can be used to access CMIC_XGXS_MDIO_CONFIG_3.
 *
 */
#define BCM56504_A0_READ_CMIC_XGXS_MDIO_CONFIG_3r(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_3r,r._cmic_xgxs_mdio_config_3)
#define BCM56504_A0_WRITE_CMIC_XGXS_MDIO_CONFIG_3r(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_3r,r._cmic_xgxs_mdio_config_3)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_XGXS_MDIO_CONFIG_3r BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_3r
#define CMIC_XGXS_MDIO_CONFIG_3r_SIZE BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_3r_SIZE
typedef BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_3r_t CMIC_XGXS_MDIO_CONFIG_3r_t;
#define CMIC_XGXS_MDIO_CONFIG_3r_CLR BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_3r_CLR
#define CMIC_XGXS_MDIO_CONFIG_3r_SET BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_3r_SET
#define CMIC_XGXS_MDIO_CONFIG_3r_GET BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_3r_GET
#define CMIC_XGXS_MDIO_CONFIG_3r_IEEE_DEVICES_IN_PKGf_GET BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_3r_IEEE_DEVICES_IN_PKGf_GET
#define CMIC_XGXS_MDIO_CONFIG_3r_IEEE_DEVICES_IN_PKGf_SET BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_3r_IEEE_DEVICES_IN_PKGf_SET
#define CMIC_XGXS_MDIO_CONFIG_3r_MD_DEVADf_GET BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_3r_MD_DEVADf_GET
#define CMIC_XGXS_MDIO_CONFIG_3r_MD_DEVADf_SET BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_3r_MD_DEVADf_SET
#define CMIC_XGXS_MDIO_CONFIG_3r_MD_STf_GET BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_3r_MD_STf_GET
#define CMIC_XGXS_MDIO_CONFIG_3r_MD_STf_SET BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_3r_MD_STf_SET
#define CMIC_XGXS_MDIO_CONFIG_3r_RESERVED_0f_GET BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_3r_RESERVED_0f_GET
#define CMIC_XGXS_MDIO_CONFIG_3r_RESERVED_0f_SET BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_3r_RESERVED_0f_SET
#define READ_CMIC_XGXS_MDIO_CONFIG_3r BCM56504_A0_READ_CMIC_XGXS_MDIO_CONFIG_3r
#define WRITE_CMIC_XGXS_MDIO_CONFIG_3r BCM56504_A0_WRITE_CMIC_XGXS_MDIO_CONFIG_3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_XGXS_MDIO_CONFIG_3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_XGXS_PLL_CONTROL_1
 * BLOCKS:   CMIC
 * DESC:     CMIC XGXS PLL Control register 1
 * SIZE:     32
 * FIELDS:
 *     PLL_CONTROL_9_0  XAUI PLLCONTROL register bits [9:0]
 *     PLL_CONTROL_10   XAUI PLLCONTROL register bits 10 - select between 10g and 12g for XAUI port 3
 *     PLL_CONTROL_11   XAUI PLLCONTROL register bits 11 - select between 10g and 12g for XAUI port 2
 *     PLL_CONTROL_12   XAUI PLLCONTROL register bits 12 - select between 10g and 12g for XAUI port 1
 *     PLL_CONTROL_13   XAUI PLLCONTROL register bits 13 - select between 10g and 12g for XAUI port 0
 *     PLL_CONTROL_31_14 XAUI PLLCONTROL register bits [31:14]
 *     RESET            Reset for VCO sequencer.0=de-asserted. 1=asserted, starts VCO sequencer
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_XGXS_PLL_CONTROL_1r 0x00000584

#define BCM56504_A0_CMIC_XGXS_PLL_CONTROL_1r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_XGXS_PLL_CONTROL_1.
 *
 */
typedef union BCM56504_A0_CMIC_XGXS_PLL_CONTROL_1r_s {
	uint32_t v[1];
	uint32_t cmic_xgxs_pll_control_1[1];
	uint32_t _cmic_xgxs_pll_control_1;
} BCM56504_A0_CMIC_XGXS_PLL_CONTROL_1r_t;

#define BCM56504_A0_CMIC_XGXS_PLL_CONTROL_1r_CLR(r) (r).cmic_xgxs_pll_control_1[0] = 0
#define BCM56504_A0_CMIC_XGXS_PLL_CONTROL_1r_SET(r,d) (r).cmic_xgxs_pll_control_1[0] = d
#define BCM56504_A0_CMIC_XGXS_PLL_CONTROL_1r_GET(r) (r).cmic_xgxs_pll_control_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_9_0f_GET(r) (((r).cmic_xgxs_pll_control_1[0]) & 0x3ff)
#define BCM56504_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_9_0f_SET(r,f) (r).cmic_xgxs_pll_control_1[0]=(((r).cmic_xgxs_pll_control_1[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM56504_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_10f_GET(r) ((((r).cmic_xgxs_pll_control_1[0]) >> 10) & 0x1)
#define BCM56504_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_10f_SET(r,f) (r).cmic_xgxs_pll_control_1[0]=(((r).cmic_xgxs_pll_control_1[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56504_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_11f_GET(r) ((((r).cmic_xgxs_pll_control_1[0]) >> 11) & 0x1)
#define BCM56504_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_11f_SET(r,f) (r).cmic_xgxs_pll_control_1[0]=(((r).cmic_xgxs_pll_control_1[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56504_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_12f_GET(r) ((((r).cmic_xgxs_pll_control_1[0]) >> 12) & 0x1)
#define BCM56504_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_12f_SET(r,f) (r).cmic_xgxs_pll_control_1[0]=(((r).cmic_xgxs_pll_control_1[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM56504_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_13f_GET(r) ((((r).cmic_xgxs_pll_control_1[0]) >> 13) & 0x1)
#define BCM56504_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_13f_SET(r,f) (r).cmic_xgxs_pll_control_1[0]=(((r).cmic_xgxs_pll_control_1[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56504_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_31_14f_GET(r) ((((r).cmic_xgxs_pll_control_1[0]) >> 14) & 0x3ffff)
#define BCM56504_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_31_14f_SET(r,f) (r).cmic_xgxs_pll_control_1[0]=(((r).cmic_xgxs_pll_control_1[0] & ~((uint32_t)0x3ffff << 14)) | ((((uint32_t)f) & 0x3ffff) << 14))
#define BCM56504_A0_CMIC_XGXS_PLL_CONTROL_1r_RESETf_GET(r) ((((r).cmic_xgxs_pll_control_1[0]) >> 20) & 0x1)
#define BCM56504_A0_CMIC_XGXS_PLL_CONTROL_1r_RESETf_SET(r,f) (r).cmic_xgxs_pll_control_1[0]=(((r).cmic_xgxs_pll_control_1[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))

/*
 * These macros can be used to access CMIC_XGXS_PLL_CONTROL_1.
 *
 */
#define BCM56504_A0_READ_CMIC_XGXS_PLL_CONTROL_1r(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_XGXS_PLL_CONTROL_1r,r._cmic_xgxs_pll_control_1)
#define BCM56504_A0_WRITE_CMIC_XGXS_PLL_CONTROL_1r(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_XGXS_PLL_CONTROL_1r,r._cmic_xgxs_pll_control_1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_XGXS_PLL_CONTROL_1r BCM56504_A0_CMIC_XGXS_PLL_CONTROL_1r
#define CMIC_XGXS_PLL_CONTROL_1r_SIZE BCM56504_A0_CMIC_XGXS_PLL_CONTROL_1r_SIZE
typedef BCM56504_A0_CMIC_XGXS_PLL_CONTROL_1r_t CMIC_XGXS_PLL_CONTROL_1r_t;
#define CMIC_XGXS_PLL_CONTROL_1r_CLR BCM56504_A0_CMIC_XGXS_PLL_CONTROL_1r_CLR
#define CMIC_XGXS_PLL_CONTROL_1r_SET BCM56504_A0_CMIC_XGXS_PLL_CONTROL_1r_SET
#define CMIC_XGXS_PLL_CONTROL_1r_GET BCM56504_A0_CMIC_XGXS_PLL_CONTROL_1r_GET
#define CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_9_0f_GET BCM56504_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_9_0f_GET
#define CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_9_0f_SET BCM56504_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_9_0f_SET
#define CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_10f_GET BCM56504_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_10f_GET
#define CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_10f_SET BCM56504_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_10f_SET
#define CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_11f_GET BCM56504_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_11f_GET
#define CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_11f_SET BCM56504_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_11f_SET
#define CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_12f_GET BCM56504_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_12f_GET
#define CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_12f_SET BCM56504_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_12f_SET
#define CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_13f_GET BCM56504_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_13f_GET
#define CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_13f_SET BCM56504_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_13f_SET
#define CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_31_14f_GET BCM56504_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_31_14f_GET
#define CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_31_14f_SET BCM56504_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_31_14f_SET
#define CMIC_XGXS_PLL_CONTROL_1r_RESETf_GET BCM56504_A0_CMIC_XGXS_PLL_CONTROL_1r_RESETf_GET
#define CMIC_XGXS_PLL_CONTROL_1r_RESETf_SET BCM56504_A0_CMIC_XGXS_PLL_CONTROL_1r_RESETf_SET
#define READ_CMIC_XGXS_PLL_CONTROL_1r BCM56504_A0_READ_CMIC_XGXS_PLL_CONTROL_1r
#define WRITE_CMIC_XGXS_PLL_CONTROL_1r BCM56504_A0_WRITE_CMIC_XGXS_PLL_CONTROL_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_XGXS_PLL_CONTROL_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CMIC_XGXS_PLL_CONTROL_2
 * BLOCKS:   CMIC
 * DESC:     CMIC XGXS PLL Control register 2
 * SIZE:     32
 * FIELDS:
 *     PLL_CONTROL_43_32 XAUI PLLCONTROL register bits [43:32]
 *     XGPLL_CONTROL_PWRDN_INDEX XG PLL Control power down index
 *     PLL_STATUS       XAUI PLL Status bits [17:0]
 *     CMIC_XG_PLL_LOCK XG PLL Reset
 *     PLL_SM_FREQ_PASS Frequency lock
 *
 ******************************************************************************/
#define BCM56504_A0_CMIC_XGXS_PLL_CONTROL_2r 0x00000588

#define BCM56504_A0_CMIC_XGXS_PLL_CONTROL_2r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_XGXS_PLL_CONTROL_2.
 *
 */
typedef union BCM56504_A0_CMIC_XGXS_PLL_CONTROL_2r_s {
	uint32_t v[1];
	uint32_t cmic_xgxs_pll_control_2[1];
	uint32_t _cmic_xgxs_pll_control_2;
} BCM56504_A0_CMIC_XGXS_PLL_CONTROL_2r_t;

#define BCM56504_A0_CMIC_XGXS_PLL_CONTROL_2r_CLR(r) (r).cmic_xgxs_pll_control_2[0] = 0
#define BCM56504_A0_CMIC_XGXS_PLL_CONTROL_2r_SET(r,d) (r).cmic_xgxs_pll_control_2[0] = d
#define BCM56504_A0_CMIC_XGXS_PLL_CONTROL_2r_GET(r) (r).cmic_xgxs_pll_control_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CMIC_XGXS_PLL_CONTROL_2r_PLL_CONTROL_43_32f_GET(r) (((r).cmic_xgxs_pll_control_2[0]) & 0xfff)
#define BCM56504_A0_CMIC_XGXS_PLL_CONTROL_2r_PLL_CONTROL_43_32f_SET(r,f) (r).cmic_xgxs_pll_control_2[0]=(((r).cmic_xgxs_pll_control_2[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM56504_A0_CMIC_XGXS_PLL_CONTROL_2r_XGPLL_CONTROL_PWRDN_INDEXf_GET(r) ((((r).cmic_xgxs_pll_control_2[0]) >> 12) & 0x1)
#define BCM56504_A0_CMIC_XGXS_PLL_CONTROL_2r_XGPLL_CONTROL_PWRDN_INDEXf_SET(r,f) (r).cmic_xgxs_pll_control_2[0]=(((r).cmic_xgxs_pll_control_2[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM56504_A0_CMIC_XGXS_PLL_CONTROL_2r_PLL_STATUSf_GET(r) ((((r).cmic_xgxs_pll_control_2[0]) >> 13) & 0x3ffff)
#define BCM56504_A0_CMIC_XGXS_PLL_CONTROL_2r_PLL_STATUSf_SET(r,f) (r).cmic_xgxs_pll_control_2[0]=(((r).cmic_xgxs_pll_control_2[0] & ~((uint32_t)0x3ffff << 13)) | ((((uint32_t)f) & 0x3ffff) << 13))
#define BCM56504_A0_CMIC_XGXS_PLL_CONTROL_2r_CMIC_XG_PLL_LOCKf_GET(r) ((((r).cmic_xgxs_pll_control_2[0]) >> 31) & 0x1)
#define BCM56504_A0_CMIC_XGXS_PLL_CONTROL_2r_CMIC_XG_PLL_LOCKf_SET(r,f) (r).cmic_xgxs_pll_control_2[0]=(((r).cmic_xgxs_pll_control_2[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM56504_A0_CMIC_XGXS_PLL_CONTROL_2r_PLL_SM_FREQ_PASSf_GET(r) ((((r).cmic_xgxs_pll_control_2[0]) >> 14) & 0x1)
#define BCM56504_A0_CMIC_XGXS_PLL_CONTROL_2r_PLL_SM_FREQ_PASSf_SET(r,f) (r).cmic_xgxs_pll_control_2[0]=(((r).cmic_xgxs_pll_control_2[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))

/*
 * These macros can be used to access CMIC_XGXS_PLL_CONTROL_2.
 *
 */
#define BCM56504_A0_READ_CMIC_XGXS_PLL_CONTROL_2r(u,r) CDK_DEV_READ32(u,BCM56504_A0_CMIC_XGXS_PLL_CONTROL_2r,r._cmic_xgxs_pll_control_2)
#define BCM56504_A0_WRITE_CMIC_XGXS_PLL_CONTROL_2r(u,r) CDK_DEV_WRITE32(u,BCM56504_A0_CMIC_XGXS_PLL_CONTROL_2r,r._cmic_xgxs_pll_control_2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_XGXS_PLL_CONTROL_2r BCM56504_A0_CMIC_XGXS_PLL_CONTROL_2r
#define CMIC_XGXS_PLL_CONTROL_2r_SIZE BCM56504_A0_CMIC_XGXS_PLL_CONTROL_2r_SIZE
typedef BCM56504_A0_CMIC_XGXS_PLL_CONTROL_2r_t CMIC_XGXS_PLL_CONTROL_2r_t;
#define CMIC_XGXS_PLL_CONTROL_2r_CLR BCM56504_A0_CMIC_XGXS_PLL_CONTROL_2r_CLR
#define CMIC_XGXS_PLL_CONTROL_2r_SET BCM56504_A0_CMIC_XGXS_PLL_CONTROL_2r_SET
#define CMIC_XGXS_PLL_CONTROL_2r_GET BCM56504_A0_CMIC_XGXS_PLL_CONTROL_2r_GET
#define CMIC_XGXS_PLL_CONTROL_2r_PLL_CONTROL_43_32f_GET BCM56504_A0_CMIC_XGXS_PLL_CONTROL_2r_PLL_CONTROL_43_32f_GET
#define CMIC_XGXS_PLL_CONTROL_2r_PLL_CONTROL_43_32f_SET BCM56504_A0_CMIC_XGXS_PLL_CONTROL_2r_PLL_CONTROL_43_32f_SET
#define CMIC_XGXS_PLL_CONTROL_2r_XGPLL_CONTROL_PWRDN_INDEXf_GET BCM56504_A0_CMIC_XGXS_PLL_CONTROL_2r_XGPLL_CONTROL_PWRDN_INDEXf_GET
#define CMIC_XGXS_PLL_CONTROL_2r_XGPLL_CONTROL_PWRDN_INDEXf_SET BCM56504_A0_CMIC_XGXS_PLL_CONTROL_2r_XGPLL_CONTROL_PWRDN_INDEXf_SET
#define CMIC_XGXS_PLL_CONTROL_2r_PLL_STATUSf_GET BCM56504_A0_CMIC_XGXS_PLL_CONTROL_2r_PLL_STATUSf_GET
#define CMIC_XGXS_PLL_CONTROL_2r_PLL_STATUSf_SET BCM56504_A0_CMIC_XGXS_PLL_CONTROL_2r_PLL_STATUSf_SET
#define CMIC_XGXS_PLL_CONTROL_2r_CMIC_XG_PLL_LOCKf_GET BCM56504_A0_CMIC_XGXS_PLL_CONTROL_2r_CMIC_XG_PLL_LOCKf_GET
#define CMIC_XGXS_PLL_CONTROL_2r_CMIC_XG_PLL_LOCKf_SET BCM56504_A0_CMIC_XGXS_PLL_CONTROL_2r_CMIC_XG_PLL_LOCKf_SET
#define CMIC_XGXS_PLL_CONTROL_2r_PLL_SM_FREQ_PASSf_GET BCM56504_A0_CMIC_XGXS_PLL_CONTROL_2r_PLL_SM_FREQ_PASSf_GET
#define CMIC_XGXS_PLL_CONTROL_2r_PLL_SM_FREQ_PASSf_SET BCM56504_A0_CMIC_XGXS_PLL_CONTROL_2r_PLL_SM_FREQ_PASSf_SET
#define READ_CMIC_XGXS_PLL_CONTROL_2r BCM56504_A0_READ_CMIC_XGXS_PLL_CONTROL_2r
#define WRITE_CMIC_XGXS_PLL_CONTROL_2r BCM56504_A0_WRITE_CMIC_XGXS_PLL_CONTROL_2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CMIC_XGXS_PLL_CONTROL_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CNGCOSPKTLIMIT0
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CNGPKTSETLIMIT0  CNG0 Set Limit for COS n for an egress port.When packet count is above this limit, incoming packet carried congestion color red (CNG[1:0]==2'b01) will be dropped. This limit is needed to be set lower than HOLCOSPKTSETLIMIT of the same port to ensure dropping CNG0 packet mechanism will take effect early than HOL. Number of packet allowed for CNG0 packet per egress port of COS 0.
 *
 ******************************************************************************/
#define BCM56504_A0_CNGCOSPKTLIMIT0r 0x00600018

#define BCM56504_A0_CNGCOSPKTLIMIT0r_SIZE 4

/*
 * This structure should be used to declare and program CNGCOSPKTLIMIT0.
 *
 */
typedef union BCM56504_A0_CNGCOSPKTLIMIT0r_s {
	uint32_t v[1];
	uint32_t cngcospktlimit0[1];
	uint32_t _cngcospktlimit0;
} BCM56504_A0_CNGCOSPKTLIMIT0r_t;

#define BCM56504_A0_CNGCOSPKTLIMIT0r_CLR(r) (r).cngcospktlimit0[0] = 0
#define BCM56504_A0_CNGCOSPKTLIMIT0r_SET(r,d) (r).cngcospktlimit0[0] = d
#define BCM56504_A0_CNGCOSPKTLIMIT0r_GET(r) (r).cngcospktlimit0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CNGCOSPKTLIMIT0r_CNGPKTSETLIMIT0f_GET(r) (((r).cngcospktlimit0[0]) & 0x7ff)
#define BCM56504_A0_CNGCOSPKTLIMIT0r_CNGPKTSETLIMIT0f_SET(r,f) (r).cngcospktlimit0[0]=(((r).cngcospktlimit0[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))

/*
 * These macros can be used to access CNGCOSPKTLIMIT0.
 *
 */
#define BCM56504_A0_READ_CNGCOSPKTLIMIT0r(u,p,i,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_CNGCOSPKTLIMIT0r+(i),(r._cngcospktlimit0))
#define BCM56504_A0_WRITE_CNGCOSPKTLIMIT0r(u,p,i,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_CNGCOSPKTLIMIT0r+(i),&(r._cngcospktlimit0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CNGCOSPKTLIMIT0r BCM56504_A0_CNGCOSPKTLIMIT0r
#define CNGCOSPKTLIMIT0r_SIZE BCM56504_A0_CNGCOSPKTLIMIT0r_SIZE
typedef BCM56504_A0_CNGCOSPKTLIMIT0r_t CNGCOSPKTLIMIT0r_t;
#define CNGCOSPKTLIMIT0r_CLR BCM56504_A0_CNGCOSPKTLIMIT0r_CLR
#define CNGCOSPKTLIMIT0r_SET BCM56504_A0_CNGCOSPKTLIMIT0r_SET
#define CNGCOSPKTLIMIT0r_GET BCM56504_A0_CNGCOSPKTLIMIT0r_GET
#define CNGCOSPKTLIMIT0r_CNGPKTSETLIMIT0f_GET BCM56504_A0_CNGCOSPKTLIMIT0r_CNGPKTSETLIMIT0f_GET
#define CNGCOSPKTLIMIT0r_CNGPKTSETLIMIT0f_SET BCM56504_A0_CNGCOSPKTLIMIT0r_CNGPKTSETLIMIT0f_SET
#define READ_CNGCOSPKTLIMIT0r BCM56504_A0_READ_CNGCOSPKTLIMIT0r
#define WRITE_CNGCOSPKTLIMIT0r BCM56504_A0_WRITE_CNGCOSPKTLIMIT0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CNGCOSPKTLIMIT0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CNGCOSPKTLIMIT1
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CNGPKTSETLIMIT1  CNG1 Set Limit for COS n for an egress port.When packet count is above this limit, incoming packet carried congestion color yellow (CNG[1:0]==2'b11) will be dropped. This limit is needed to be set lower than HOLCOSPKTSETLIMIT of the same port to ensure dropping CNG1 packet mechanism will take effect early than HOL. Number of packet allowed for CNG1 packet per egress port of COS 0.
 *
 ******************************************************************************/
#define BCM56504_A0_CNGCOSPKTLIMIT1r 0x00600020

#define BCM56504_A0_CNGCOSPKTLIMIT1r_SIZE 4

/*
 * This structure should be used to declare and program CNGCOSPKTLIMIT1.
 *
 */
typedef union BCM56504_A0_CNGCOSPKTLIMIT1r_s {
	uint32_t v[1];
	uint32_t cngcospktlimit1[1];
	uint32_t _cngcospktlimit1;
} BCM56504_A0_CNGCOSPKTLIMIT1r_t;

#define BCM56504_A0_CNGCOSPKTLIMIT1r_CLR(r) (r).cngcospktlimit1[0] = 0
#define BCM56504_A0_CNGCOSPKTLIMIT1r_SET(r,d) (r).cngcospktlimit1[0] = d
#define BCM56504_A0_CNGCOSPKTLIMIT1r_GET(r) (r).cngcospktlimit1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CNGCOSPKTLIMIT1r_CNGPKTSETLIMIT1f_GET(r) (((r).cngcospktlimit1[0]) & 0x7ff)
#define BCM56504_A0_CNGCOSPKTLIMIT1r_CNGPKTSETLIMIT1f_SET(r,f) (r).cngcospktlimit1[0]=(((r).cngcospktlimit1[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))

/*
 * These macros can be used to access CNGCOSPKTLIMIT1.
 *
 */
#define BCM56504_A0_READ_CNGCOSPKTLIMIT1r(u,p,i,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_CNGCOSPKTLIMIT1r+(i),(r._cngcospktlimit1))
#define BCM56504_A0_WRITE_CNGCOSPKTLIMIT1r(u,p,i,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_CNGCOSPKTLIMIT1r+(i),&(r._cngcospktlimit1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CNGCOSPKTLIMIT1r BCM56504_A0_CNGCOSPKTLIMIT1r
#define CNGCOSPKTLIMIT1r_SIZE BCM56504_A0_CNGCOSPKTLIMIT1r_SIZE
typedef BCM56504_A0_CNGCOSPKTLIMIT1r_t CNGCOSPKTLIMIT1r_t;
#define CNGCOSPKTLIMIT1r_CLR BCM56504_A0_CNGCOSPKTLIMIT1r_CLR
#define CNGCOSPKTLIMIT1r_SET BCM56504_A0_CNGCOSPKTLIMIT1r_SET
#define CNGCOSPKTLIMIT1r_GET BCM56504_A0_CNGCOSPKTLIMIT1r_GET
#define CNGCOSPKTLIMIT1r_CNGPKTSETLIMIT1f_GET BCM56504_A0_CNGCOSPKTLIMIT1r_CNGPKTSETLIMIT1f_GET
#define CNGCOSPKTLIMIT1r_CNGPKTSETLIMIT1f_SET BCM56504_A0_CNGCOSPKTLIMIT1r_CNGPKTSETLIMIT1f_SET
#define READ_CNGCOSPKTLIMIT1r BCM56504_A0_READ_CNGCOSPKTLIMIT1r
#define WRITE_CNGCOSPKTLIMIT1r BCM56504_A0_WRITE_CNGCOSPKTLIMIT1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CNGCOSPKTLIMIT1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CNGDROPCOUNT0
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     DROPPKTCOUNT     Dropped Packet Count accounts for congestion color red dropped packets for eachegress port after its HOLPktCount over CNG0 Packet Set limit. This is per port based counter collecting all packets for this port on different COS. Number of packets per egress port.
 *
 ******************************************************************************/
#define BCM56504_A0_CNGDROPCOUNT0r 0x00600048

#define BCM56504_A0_CNGDROPCOUNT0r_SIZE 4

/*
 * This structure should be used to declare and program CNGDROPCOUNT0.
 *
 */
typedef union BCM56504_A0_CNGDROPCOUNT0r_s {
	uint32_t v[1];
	uint32_t cngdropcount0[1];
	uint32_t _cngdropcount0;
} BCM56504_A0_CNGDROPCOUNT0r_t;

#define BCM56504_A0_CNGDROPCOUNT0r_CLR(r) (r).cngdropcount0[0] = 0
#define BCM56504_A0_CNGDROPCOUNT0r_SET(r,d) (r).cngdropcount0[0] = d
#define BCM56504_A0_CNGDROPCOUNT0r_GET(r) (r).cngdropcount0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CNGDROPCOUNT0r_DROPPKTCOUNTf_GET(r) ((r).cngdropcount0[0])
#define BCM56504_A0_CNGDROPCOUNT0r_DROPPKTCOUNTf_SET(r,f) (r).cngdropcount0[0]=((uint32_t)f)

/*
 * These macros can be used to access CNGDROPCOUNT0.
 *
 */
#define BCM56504_A0_READ_CNGDROPCOUNT0r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_CNGDROPCOUNT0r,(r._cngdropcount0))
#define BCM56504_A0_WRITE_CNGDROPCOUNT0r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_CNGDROPCOUNT0r,&(r._cngdropcount0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CNGDROPCOUNT0r BCM56504_A0_CNGDROPCOUNT0r
#define CNGDROPCOUNT0r_SIZE BCM56504_A0_CNGDROPCOUNT0r_SIZE
typedef BCM56504_A0_CNGDROPCOUNT0r_t CNGDROPCOUNT0r_t;
#define CNGDROPCOUNT0r_CLR BCM56504_A0_CNGDROPCOUNT0r_CLR
#define CNGDROPCOUNT0r_SET BCM56504_A0_CNGDROPCOUNT0r_SET
#define CNGDROPCOUNT0r_GET BCM56504_A0_CNGDROPCOUNT0r_GET
#define CNGDROPCOUNT0r_DROPPKTCOUNTf_GET BCM56504_A0_CNGDROPCOUNT0r_DROPPKTCOUNTf_GET
#define CNGDROPCOUNT0r_DROPPKTCOUNTf_SET BCM56504_A0_CNGDROPCOUNT0r_DROPPKTCOUNTf_SET
#define READ_CNGDROPCOUNT0r BCM56504_A0_READ_CNGDROPCOUNT0r
#define WRITE_CNGDROPCOUNT0r BCM56504_A0_WRITE_CNGDROPCOUNT0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CNGDROPCOUNT0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CNGDROPCOUNT1
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     DROPPKTCOUNT     Dropped Packet Count accounts for congestion color yellow dropped packets for eachegress port after its HOLPktCount over CNG1 Packet Set limit. This is per port based counter collecting all packets for this port on different COS. Number of packets per egress port.
 *
 ******************************************************************************/
#define BCM56504_A0_CNGDROPCOUNT1r 0x00600049

#define BCM56504_A0_CNGDROPCOUNT1r_SIZE 4

/*
 * This structure should be used to declare and program CNGDROPCOUNT1.
 *
 */
typedef union BCM56504_A0_CNGDROPCOUNT1r_s {
	uint32_t v[1];
	uint32_t cngdropcount1[1];
	uint32_t _cngdropcount1;
} BCM56504_A0_CNGDROPCOUNT1r_t;

#define BCM56504_A0_CNGDROPCOUNT1r_CLR(r) (r).cngdropcount1[0] = 0
#define BCM56504_A0_CNGDROPCOUNT1r_SET(r,d) (r).cngdropcount1[0] = d
#define BCM56504_A0_CNGDROPCOUNT1r_GET(r) (r).cngdropcount1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CNGDROPCOUNT1r_DROPPKTCOUNTf_GET(r) ((r).cngdropcount1[0])
#define BCM56504_A0_CNGDROPCOUNT1r_DROPPKTCOUNTf_SET(r,f) (r).cngdropcount1[0]=((uint32_t)f)

/*
 * These macros can be used to access CNGDROPCOUNT1.
 *
 */
#define BCM56504_A0_READ_CNGDROPCOUNT1r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_CNGDROPCOUNT1r,(r._cngdropcount1))
#define BCM56504_A0_WRITE_CNGDROPCOUNT1r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_CNGDROPCOUNT1r,&(r._cngdropcount1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CNGDROPCOUNT1r BCM56504_A0_CNGDROPCOUNT1r
#define CNGDROPCOUNT1r_SIZE BCM56504_A0_CNGDROPCOUNT1r_SIZE
typedef BCM56504_A0_CNGDROPCOUNT1r_t CNGDROPCOUNT1r_t;
#define CNGDROPCOUNT1r_CLR BCM56504_A0_CNGDROPCOUNT1r_CLR
#define CNGDROPCOUNT1r_SET BCM56504_A0_CNGDROPCOUNT1r_SET
#define CNGDROPCOUNT1r_GET BCM56504_A0_CNGDROPCOUNT1r_GET
#define CNGDROPCOUNT1r_DROPPKTCOUNTf_GET BCM56504_A0_CNGDROPCOUNT1r_DROPPKTCOUNTf_GET
#define CNGDROPCOUNT1r_DROPPKTCOUNTf_SET BCM56504_A0_CNGDROPCOUNT1r_DROPPKTCOUNTf_SET
#define READ_CNGDROPCOUNT1r BCM56504_A0_READ_CNGDROPCOUNT1r
#define WRITE_CNGDROPCOUNT1r BCM56504_A0_WRITE_CNGDROPCOUNT1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CNGDROPCOUNT1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CNG_MAP
 * BLOCKS:   IPIPE
 * DESC:     CNG Mapping Register
 * SIZE:     32
 * FIELDS:
 *     PRIORITY0_CNG    Maps the priority(0) to a default CNG (congestion value for untrusted ports)
 *     PRIORITY1_CNG    Maps the priority(1) to a default CNG (congestion value for untrusted ports)
 *     PRIORITY2_CNG    Maps the priority(2) to a default CNG (congestion value for untrusted ports)
 *     PRIORITY3_CNG    Maps the priority(3) to a default CNG (congestion value for untrusted ports)
 *     PRIORITY4_CNG    Maps the priority(4) to a default CNG (congestion value for untrusted ports)
 *     PRIORITY5_CNG    Maps the priority(5) to a default CNG (congestion value for untrusted ports)
 *     PRIORITY6_CNG    Maps the priority(6) to a default CNG (congestion value for untrusted ports)
 *     PRIORITY7_CNG    Maps the priority(7) to a default CNG (congestion value for untrusted ports)
 *     CFI0_CNG         Maps the incoming CFI(0) to a default CNG (if CFI_AS_CNG is set in ING_CONFIG)
 *     CFI1_CNG         Maps the incoming CFI(1) to a default CNG (if CFI_AS_CNG is set in ING_CONFIG)
 *
 ******************************************************************************/
#define BCM56504_A0_CNG_MAPr 0x0b700000

#define BCM56504_A0_CNG_MAPr_SIZE 4

/*
 * This structure should be used to declare and program CNG_MAP.
 *
 */
typedef union BCM56504_A0_CNG_MAPr_s {
	uint32_t v[1];
	uint32_t cng_map[1];
	uint32_t _cng_map;
} BCM56504_A0_CNG_MAPr_t;

#define BCM56504_A0_CNG_MAPr_CLR(r) (r).cng_map[0] = 0
#define BCM56504_A0_CNG_MAPr_SET(r,d) (r).cng_map[0] = d
#define BCM56504_A0_CNG_MAPr_GET(r) (r).cng_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CNG_MAPr_PRIORITY0_CNGf_GET(r) (((r).cng_map[0]) & 0x3)
#define BCM56504_A0_CNG_MAPr_PRIORITY0_CNGf_SET(r,f) (r).cng_map[0]=(((r).cng_map[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56504_A0_CNG_MAPr_PRIORITY1_CNGf_GET(r) ((((r).cng_map[0]) >> 2) & 0x3)
#define BCM56504_A0_CNG_MAPr_PRIORITY1_CNGf_SET(r,f) (r).cng_map[0]=(((r).cng_map[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM56504_A0_CNG_MAPr_PRIORITY2_CNGf_GET(r) ((((r).cng_map[0]) >> 4) & 0x3)
#define BCM56504_A0_CNG_MAPr_PRIORITY2_CNGf_SET(r,f) (r).cng_map[0]=(((r).cng_map[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM56504_A0_CNG_MAPr_PRIORITY3_CNGf_GET(r) ((((r).cng_map[0]) >> 6) & 0x3)
#define BCM56504_A0_CNG_MAPr_PRIORITY3_CNGf_SET(r,f) (r).cng_map[0]=(((r).cng_map[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM56504_A0_CNG_MAPr_PRIORITY4_CNGf_GET(r) ((((r).cng_map[0]) >> 8) & 0x3)
#define BCM56504_A0_CNG_MAPr_PRIORITY4_CNGf_SET(r,f) (r).cng_map[0]=(((r).cng_map[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM56504_A0_CNG_MAPr_PRIORITY5_CNGf_GET(r) ((((r).cng_map[0]) >> 10) & 0x3)
#define BCM56504_A0_CNG_MAPr_PRIORITY5_CNGf_SET(r,f) (r).cng_map[0]=(((r).cng_map[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCM56504_A0_CNG_MAPr_PRIORITY6_CNGf_GET(r) ((((r).cng_map[0]) >> 12) & 0x3)
#define BCM56504_A0_CNG_MAPr_PRIORITY6_CNGf_SET(r,f) (r).cng_map[0]=(((r).cng_map[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM56504_A0_CNG_MAPr_PRIORITY7_CNGf_GET(r) ((((r).cng_map[0]) >> 14) & 0x3)
#define BCM56504_A0_CNG_MAPr_PRIORITY7_CNGf_SET(r,f) (r).cng_map[0]=(((r).cng_map[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCM56504_A0_CNG_MAPr_CFI0_CNGf_GET(r) ((((r).cng_map[0]) >> 16) & 0x3)
#define BCM56504_A0_CNG_MAPr_CFI0_CNGf_SET(r,f) (r).cng_map[0]=(((r).cng_map[0] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM56504_A0_CNG_MAPr_CFI1_CNGf_GET(r) ((((r).cng_map[0]) >> 18) & 0x3)
#define BCM56504_A0_CNG_MAPr_CFI1_CNGf_SET(r,f) (r).cng_map[0]=(((r).cng_map[0] & ~((uint32_t)0x3 << 18)) | ((((uint32_t)f) & 0x3) << 18))

/*
 * These macros can be used to access CNG_MAP.
 *
 */
#define BCM56504_A0_READ_CNG_MAPr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_CNG_MAPr,(r._cng_map))
#define BCM56504_A0_WRITE_CNG_MAPr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_CNG_MAPr,&(r._cng_map))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CNG_MAPr BCM56504_A0_CNG_MAPr
#define CNG_MAPr_SIZE BCM56504_A0_CNG_MAPr_SIZE
typedef BCM56504_A0_CNG_MAPr_t CNG_MAPr_t;
#define CNG_MAPr_CLR BCM56504_A0_CNG_MAPr_CLR
#define CNG_MAPr_SET BCM56504_A0_CNG_MAPr_SET
#define CNG_MAPr_GET BCM56504_A0_CNG_MAPr_GET
#define CNG_MAPr_PRIORITY0_CNGf_GET BCM56504_A0_CNG_MAPr_PRIORITY0_CNGf_GET
#define CNG_MAPr_PRIORITY0_CNGf_SET BCM56504_A0_CNG_MAPr_PRIORITY0_CNGf_SET
#define CNG_MAPr_PRIORITY1_CNGf_GET BCM56504_A0_CNG_MAPr_PRIORITY1_CNGf_GET
#define CNG_MAPr_PRIORITY1_CNGf_SET BCM56504_A0_CNG_MAPr_PRIORITY1_CNGf_SET
#define CNG_MAPr_PRIORITY2_CNGf_GET BCM56504_A0_CNG_MAPr_PRIORITY2_CNGf_GET
#define CNG_MAPr_PRIORITY2_CNGf_SET BCM56504_A0_CNG_MAPr_PRIORITY2_CNGf_SET
#define CNG_MAPr_PRIORITY3_CNGf_GET BCM56504_A0_CNG_MAPr_PRIORITY3_CNGf_GET
#define CNG_MAPr_PRIORITY3_CNGf_SET BCM56504_A0_CNG_MAPr_PRIORITY3_CNGf_SET
#define CNG_MAPr_PRIORITY4_CNGf_GET BCM56504_A0_CNG_MAPr_PRIORITY4_CNGf_GET
#define CNG_MAPr_PRIORITY4_CNGf_SET BCM56504_A0_CNG_MAPr_PRIORITY4_CNGf_SET
#define CNG_MAPr_PRIORITY5_CNGf_GET BCM56504_A0_CNG_MAPr_PRIORITY5_CNGf_GET
#define CNG_MAPr_PRIORITY5_CNGf_SET BCM56504_A0_CNG_MAPr_PRIORITY5_CNGf_SET
#define CNG_MAPr_PRIORITY6_CNGf_GET BCM56504_A0_CNG_MAPr_PRIORITY6_CNGf_GET
#define CNG_MAPr_PRIORITY6_CNGf_SET BCM56504_A0_CNG_MAPr_PRIORITY6_CNGf_SET
#define CNG_MAPr_PRIORITY7_CNGf_GET BCM56504_A0_CNG_MAPr_PRIORITY7_CNGf_GET
#define CNG_MAPr_PRIORITY7_CNGf_SET BCM56504_A0_CNG_MAPr_PRIORITY7_CNGf_SET
#define CNG_MAPr_CFI0_CNGf_GET BCM56504_A0_CNG_MAPr_CFI0_CNGf_GET
#define CNG_MAPr_CFI0_CNGf_SET BCM56504_A0_CNG_MAPr_CFI0_CNGf_SET
#define CNG_MAPr_CFI1_CNGf_GET BCM56504_A0_CNG_MAPr_CFI1_CNGf_GET
#define CNG_MAPr_CFI1_CNGf_SET BCM56504_A0_CNG_MAPr_CFI1_CNGf_SET
#define READ_CNG_MAPr BCM56504_A0_READ_CNG_MAPr
#define WRITE_CNG_MAPr BCM56504_A0_WRITE_CNG_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CNG_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  COSLCCOUNT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     LCCOUNT          Cell Count for egress port packet of COS n: Number of cells per egress port of COS n.
 *
 ******************************************************************************/
#define BCM56504_A0_COSLCCOUNTr 0x00600038

#define BCM56504_A0_COSLCCOUNTr_SIZE 4

/*
 * This structure should be used to declare and program COSLCCOUNT.
 *
 */
typedef union BCM56504_A0_COSLCCOUNTr_s {
	uint32_t v[1];
	uint32_t coslccount[1];
	uint32_t _coslccount;
} BCM56504_A0_COSLCCOUNTr_t;

#define BCM56504_A0_COSLCCOUNTr_CLR(r) (r).coslccount[0] = 0
#define BCM56504_A0_COSLCCOUNTr_SET(r,d) (r).coslccount[0] = d
#define BCM56504_A0_COSLCCOUNTr_GET(r) (r).coslccount[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_COSLCCOUNTr_LCCOUNTf_GET(r) (((r).coslccount[0]) & 0x3fff)
#define BCM56504_A0_COSLCCOUNTr_LCCOUNTf_SET(r,f) (r).coslccount[0]=(((r).coslccount[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access COSLCCOUNT.
 *
 */
#define BCM56504_A0_READ_COSLCCOUNTr(u,p,i,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_COSLCCOUNTr+(i),(r._coslccount))
#define BCM56504_A0_WRITE_COSLCCOUNTr(u,p,i,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_COSLCCOUNTr+(i),&(r._coslccount))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define COSLCCOUNTr BCM56504_A0_COSLCCOUNTr
#define COSLCCOUNTr_SIZE BCM56504_A0_COSLCCOUNTr_SIZE
typedef BCM56504_A0_COSLCCOUNTr_t COSLCCOUNTr_t;
#define COSLCCOUNTr_CLR BCM56504_A0_COSLCCOUNTr_CLR
#define COSLCCOUNTr_SET BCM56504_A0_COSLCCOUNTr_SET
#define COSLCCOUNTr_GET BCM56504_A0_COSLCCOUNTr_GET
#define COSLCCOUNTr_LCCOUNTf_GET BCM56504_A0_COSLCCOUNTr_LCCOUNTf_GET
#define COSLCCOUNTr_LCCOUNTf_SET BCM56504_A0_COSLCCOUNTr_LCCOUNTf_SET
#define READ_COSLCCOUNTr BCM56504_A0_READ_COSLCCOUNTr
#define WRITE_COSLCCOUNTr BCM56504_A0_WRITE_COSLCCOUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_COSLCCOUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  COSPKTCOUNT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     PKTCOUNT         Packet Count for egress port packet for COS n: This is current nuumber of entries in XQ of COS n for this egress port.Number of packets per egress port for COS n.
 *
 ******************************************************************************/
#define BCM56504_A0_COSPKTCOUNTr 0x00600028

#define BCM56504_A0_COSPKTCOUNTr_SIZE 4

/*
 * This structure should be used to declare and program COSPKTCOUNT.
 *
 */
typedef union BCM56504_A0_COSPKTCOUNTr_s {
	uint32_t v[1];
	uint32_t cospktcount[1];
	uint32_t _cospktcount;
} BCM56504_A0_COSPKTCOUNTr_t;

#define BCM56504_A0_COSPKTCOUNTr_CLR(r) (r).cospktcount[0] = 0
#define BCM56504_A0_COSPKTCOUNTr_SET(r,d) (r).cospktcount[0] = d
#define BCM56504_A0_COSPKTCOUNTr_GET(r) (r).cospktcount[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_COSPKTCOUNTr_PKTCOUNTf_GET(r) (((r).cospktcount[0]) & 0x7ff)
#define BCM56504_A0_COSPKTCOUNTr_PKTCOUNTf_SET(r,f) (r).cospktcount[0]=(((r).cospktcount[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))

/*
 * These macros can be used to access COSPKTCOUNT.
 *
 */
#define BCM56504_A0_READ_COSPKTCOUNTr(u,p,i,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_COSPKTCOUNTr+(i),(r._cospktcount))
#define BCM56504_A0_WRITE_COSPKTCOUNTr(u,p,i,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_COSPKTCOUNTr+(i),&(r._cospktcount))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define COSPKTCOUNTr BCM56504_A0_COSPKTCOUNTr
#define COSPKTCOUNTr_SIZE BCM56504_A0_COSPKTCOUNTr_SIZE
typedef BCM56504_A0_COSPKTCOUNTr_t COSPKTCOUNTr_t;
#define COSPKTCOUNTr_CLR BCM56504_A0_COSPKTCOUNTr_CLR
#define COSPKTCOUNTr_SET BCM56504_A0_COSPKTCOUNTr_SET
#define COSPKTCOUNTr_GET BCM56504_A0_COSPKTCOUNTr_GET
#define COSPKTCOUNTr_PKTCOUNTf_GET BCM56504_A0_COSPKTCOUNTr_PKTCOUNTf_GET
#define COSPKTCOUNTr_PKTCOUNTf_SET BCM56504_A0_COSPKTCOUNTr_PKTCOUNTf_SET
#define READ_COSPKTCOUNTr BCM56504_A0_READ_COSPKTCOUNTr
#define WRITE_COSPKTCOUNTr BCM56504_A0_WRITE_COSPKTCOUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_COSPKTCOUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  COS_SEL
 * BLOCKS:   IPIPE
 * DESC:     COS Queue Mapping Register
 * SIZE:     32
 * FIELDS:
 *     COS0             COS-0 Value
 *     COS1             COS-1 Value
 *     COS2             COS-2 Value
 *     COS3             COS-3 Value
 *     COS4             COS-4 Value
 *     COS5             COS-5 Value
 *     COS6             COS-6 Value
 *     COS7             COS-7 Value
 *
 ******************************************************************************/
#define BCM56504_A0_COS_SELr 0x0e70010a

#define BCM56504_A0_COS_SELr_SIZE 4

/*
 * This structure should be used to declare and program COS_SEL.
 *
 */
typedef union BCM56504_A0_COS_SELr_s {
	uint32_t v[1];
	uint32_t cos_sel[1];
	uint32_t _cos_sel;
} BCM56504_A0_COS_SELr_t;

#define BCM56504_A0_COS_SELr_CLR(r) (r).cos_sel[0] = 0
#define BCM56504_A0_COS_SELr_SET(r,d) (r).cos_sel[0] = d
#define BCM56504_A0_COS_SELr_GET(r) (r).cos_sel[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_COS_SELr_COS0f_GET(r) (((r).cos_sel[0]) & 0x7)
#define BCM56504_A0_COS_SELr_COS0f_SET(r,f) (r).cos_sel[0]=(((r).cos_sel[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM56504_A0_COS_SELr_COS1f_GET(r) ((((r).cos_sel[0]) >> 3) & 0x7)
#define BCM56504_A0_COS_SELr_COS1f_SET(r,f) (r).cos_sel[0]=(((r).cos_sel[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM56504_A0_COS_SELr_COS2f_GET(r) ((((r).cos_sel[0]) >> 6) & 0x7)
#define BCM56504_A0_COS_SELr_COS2f_SET(r,f) (r).cos_sel[0]=(((r).cos_sel[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM56504_A0_COS_SELr_COS3f_GET(r) ((((r).cos_sel[0]) >> 9) & 0x7)
#define BCM56504_A0_COS_SELr_COS3f_SET(r,f) (r).cos_sel[0]=(((r).cos_sel[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM56504_A0_COS_SELr_COS4f_GET(r) ((((r).cos_sel[0]) >> 12) & 0x7)
#define BCM56504_A0_COS_SELr_COS4f_SET(r,f) (r).cos_sel[0]=(((r).cos_sel[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM56504_A0_COS_SELr_COS5f_GET(r) ((((r).cos_sel[0]) >> 15) & 0x7)
#define BCM56504_A0_COS_SELr_COS5f_SET(r,f) (r).cos_sel[0]=(((r).cos_sel[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM56504_A0_COS_SELr_COS6f_GET(r) ((((r).cos_sel[0]) >> 18) & 0x7)
#define BCM56504_A0_COS_SELr_COS6f_SET(r,f) (r).cos_sel[0]=(((r).cos_sel[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM56504_A0_COS_SELr_COS7f_GET(r) ((((r).cos_sel[0]) >> 21) & 0x7)
#define BCM56504_A0_COS_SELr_COS7f_SET(r,f) (r).cos_sel[0]=(((r).cos_sel[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))

/*
 * These macros can be used to access COS_SEL.
 *
 */
#define BCM56504_A0_READ_COS_SELr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_COS_SELr,(r._cos_sel))
#define BCM56504_A0_WRITE_COS_SELr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_COS_SELr,&(r._cos_sel))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define COS_SELr BCM56504_A0_COS_SELr
#define COS_SELr_SIZE BCM56504_A0_COS_SELr_SIZE
typedef BCM56504_A0_COS_SELr_t COS_SELr_t;
#define COS_SELr_CLR BCM56504_A0_COS_SELr_CLR
#define COS_SELr_SET BCM56504_A0_COS_SELr_SET
#define COS_SELr_GET BCM56504_A0_COS_SELr_GET
#define COS_SELr_COS0f_GET BCM56504_A0_COS_SELr_COS0f_GET
#define COS_SELr_COS0f_SET BCM56504_A0_COS_SELr_COS0f_SET
#define COS_SELr_COS1f_GET BCM56504_A0_COS_SELr_COS1f_GET
#define COS_SELr_COS1f_SET BCM56504_A0_COS_SELr_COS1f_SET
#define COS_SELr_COS2f_GET BCM56504_A0_COS_SELr_COS2f_GET
#define COS_SELr_COS2f_SET BCM56504_A0_COS_SELr_COS2f_SET
#define COS_SELr_COS3f_GET BCM56504_A0_COS_SELr_COS3f_GET
#define COS_SELr_COS3f_SET BCM56504_A0_COS_SELr_COS3f_SET
#define COS_SELr_COS4f_GET BCM56504_A0_COS_SELr_COS4f_GET
#define COS_SELr_COS4f_SET BCM56504_A0_COS_SELr_COS4f_SET
#define COS_SELr_COS5f_GET BCM56504_A0_COS_SELr_COS5f_GET
#define COS_SELr_COS5f_SET BCM56504_A0_COS_SELr_COS5f_SET
#define COS_SELr_COS6f_GET BCM56504_A0_COS_SELr_COS6f_GET
#define COS_SELr_COS6f_SET BCM56504_A0_COS_SELr_COS6f_SET
#define COS_SELr_COS7f_GET BCM56504_A0_COS_SELr_COS7f_GET
#define COS_SELr_COS7f_SET BCM56504_A0_COS_SELr_COS7f_SET
#define READ_COS_SELr BCM56504_A0_READ_COS_SELr
#define WRITE_COS_SELr BCM56504_A0_WRITE_COS_SELr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_COS_SELr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CPU_CONTROL_1
 * BLOCKS:   IPIPE
 * DESC:     Control Register for Packets sent to the CPU
 * SIZE:     32
 * FIELDS:
 *     STATICMOVE_TOCPU Static move send to CPU enable
 *     NONSTATICMOVE_TOCPU Non-static move send to CPU enable
 *     UIPMC_TOCPU      Unknown IPMC (IPMC miss) send to CPU enable
 *     UMC_TOCPU        Unknown multicast (L2MC miss) send to CPU enable
 *     UUCAST_TOCPU     Unknown unicast send to CPU enable
 *     V4L3ERR_TOCPU    IPv4 L3 error send to CPU enable
 *     IPMCERR_TOCPU    IPMC error send to CPU enable
 *     UVLAN_TOCPU      Unknown VLAN send to CPU enable
 *     UNRESOLVEDL3SRC_TOCPU Unresolved source for L3 send to CPU enable
 *     V6L3DSTMISS_TOCPU IPv6 L3 unicast destination miss send to CPU enable
 *     V4L3DSTMISS_TOCPU IPv4 L3 unicast destination miss send to CPU enable
 *     IPMCPORTMISS_TOCPU IPMC port mismatch send to CPU enable
 *     SRCROUTE_TOCPU   If SA[40] set, send to CPU enable
 *     V6L3ERR_TOCPU    IPv6 L3 error send to CPU enable
 *     MARTIAN_ADDR_TOCPU Martian address send to CPU enable
 *     TUNNEL_ERR_TOCPU Tunnel error send to CPU enable
 *     DOSATTACK_TOCPU  DOS attack send to CPU enable
 *     L3UC_TTL_ERR_TOCPU L3 unicast TTL error send to CPU enable
 *     IPMC_TTL_ERR_TOCPU L3 multicast TTL error send to CPU enable
 *     ICMP_REDIRECT_TOCPU ICMP redirect send to CPU enable
 *     L3_SLOWPATH_TOCPU L3 slow path to CPU enable
 *
 ******************************************************************************/
#define BCM56504_A0_CPU_CONTROL_1r 0x0b780004

#define BCM56504_A0_CPU_CONTROL_1r_SIZE 4

/*
 * This structure should be used to declare and program CPU_CONTROL_1.
 *
 */
typedef union BCM56504_A0_CPU_CONTROL_1r_s {
	uint32_t v[1];
	uint32_t cpu_control_1[1];
	uint32_t _cpu_control_1;
} BCM56504_A0_CPU_CONTROL_1r_t;

#define BCM56504_A0_CPU_CONTROL_1r_CLR(r) (r).cpu_control_1[0] = 0
#define BCM56504_A0_CPU_CONTROL_1r_SET(r,d) (r).cpu_control_1[0] = d
#define BCM56504_A0_CPU_CONTROL_1r_GET(r) (r).cpu_control_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CPU_CONTROL_1r_STATICMOVE_TOCPUf_GET(r) (((r).cpu_control_1[0]) & 0x1)
#define BCM56504_A0_CPU_CONTROL_1r_STATICMOVE_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_CPU_CONTROL_1r_NONSTATICMOVE_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 1) & 0x1)
#define BCM56504_A0_CPU_CONTROL_1r_NONSTATICMOVE_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_CPU_CONTROL_1r_UIPMC_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 2) & 0x1)
#define BCM56504_A0_CPU_CONTROL_1r_UIPMC_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_CPU_CONTROL_1r_UMC_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 3) & 0x1)
#define BCM56504_A0_CPU_CONTROL_1r_UMC_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_CPU_CONTROL_1r_UUCAST_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 4) & 0x1)
#define BCM56504_A0_CPU_CONTROL_1r_UUCAST_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56504_A0_CPU_CONTROL_1r_V4L3ERR_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 5) & 0x1)
#define BCM56504_A0_CPU_CONTROL_1r_V4L3ERR_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56504_A0_CPU_CONTROL_1r_IPMCERR_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 6) & 0x1)
#define BCM56504_A0_CPU_CONTROL_1r_IPMCERR_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56504_A0_CPU_CONTROL_1r_UVLAN_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 7) & 0x1)
#define BCM56504_A0_CPU_CONTROL_1r_UVLAN_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56504_A0_CPU_CONTROL_1r_UNRESOLVEDL3SRC_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 8) & 0x1)
#define BCM56504_A0_CPU_CONTROL_1r_UNRESOLVEDL3SRC_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56504_A0_CPU_CONTROL_1r_V6L3DSTMISS_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 9) & 0x1)
#define BCM56504_A0_CPU_CONTROL_1r_V6L3DSTMISS_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56504_A0_CPU_CONTROL_1r_V4L3DSTMISS_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 10) & 0x1)
#define BCM56504_A0_CPU_CONTROL_1r_V4L3DSTMISS_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56504_A0_CPU_CONTROL_1r_IPMCPORTMISS_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 11) & 0x1)
#define BCM56504_A0_CPU_CONTROL_1r_IPMCPORTMISS_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56504_A0_CPU_CONTROL_1r_SRCROUTE_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 12) & 0x1)
#define BCM56504_A0_CPU_CONTROL_1r_SRCROUTE_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM56504_A0_CPU_CONTROL_1r_V6L3ERR_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 13) & 0x1)
#define BCM56504_A0_CPU_CONTROL_1r_V6L3ERR_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56504_A0_CPU_CONTROL_1r_MARTIAN_ADDR_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 14) & 0x1)
#define BCM56504_A0_CPU_CONTROL_1r_MARTIAN_ADDR_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM56504_A0_CPU_CONTROL_1r_TUNNEL_ERR_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 15) & 0x1)
#define BCM56504_A0_CPU_CONTROL_1r_TUNNEL_ERR_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56504_A0_CPU_CONTROL_1r_DOSATTACK_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 16) & 0x1)
#define BCM56504_A0_CPU_CONTROL_1r_DOSATTACK_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56504_A0_CPU_CONTROL_1r_L3UC_TTL_ERR_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 17) & 0x1)
#define BCM56504_A0_CPU_CONTROL_1r_L3UC_TTL_ERR_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56504_A0_CPU_CONTROL_1r_IPMC_TTL_ERR_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 18) & 0x1)
#define BCM56504_A0_CPU_CONTROL_1r_IPMC_TTL_ERR_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56504_A0_CPU_CONTROL_1r_ICMP_REDIRECT_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 19) & 0x1)
#define BCM56504_A0_CPU_CONTROL_1r_ICMP_REDIRECT_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56504_A0_CPU_CONTROL_1r_L3_SLOWPATH_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 20) & 0x1)
#define BCM56504_A0_CPU_CONTROL_1r_L3_SLOWPATH_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))

/*
 * These macros can be used to access CPU_CONTROL_1.
 *
 */
#define BCM56504_A0_READ_CPU_CONTROL_1r(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_CPU_CONTROL_1r,(r._cpu_control_1))
#define BCM56504_A0_WRITE_CPU_CONTROL_1r(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_CPU_CONTROL_1r,&(r._cpu_control_1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CPU_CONTROL_1r BCM56504_A0_CPU_CONTROL_1r
#define CPU_CONTROL_1r_SIZE BCM56504_A0_CPU_CONTROL_1r_SIZE
typedef BCM56504_A0_CPU_CONTROL_1r_t CPU_CONTROL_1r_t;
#define CPU_CONTROL_1r_CLR BCM56504_A0_CPU_CONTROL_1r_CLR
#define CPU_CONTROL_1r_SET BCM56504_A0_CPU_CONTROL_1r_SET
#define CPU_CONTROL_1r_GET BCM56504_A0_CPU_CONTROL_1r_GET
#define CPU_CONTROL_1r_STATICMOVE_TOCPUf_GET BCM56504_A0_CPU_CONTROL_1r_STATICMOVE_TOCPUf_GET
#define CPU_CONTROL_1r_STATICMOVE_TOCPUf_SET BCM56504_A0_CPU_CONTROL_1r_STATICMOVE_TOCPUf_SET
#define CPU_CONTROL_1r_NONSTATICMOVE_TOCPUf_GET BCM56504_A0_CPU_CONTROL_1r_NONSTATICMOVE_TOCPUf_GET
#define CPU_CONTROL_1r_NONSTATICMOVE_TOCPUf_SET BCM56504_A0_CPU_CONTROL_1r_NONSTATICMOVE_TOCPUf_SET
#define CPU_CONTROL_1r_UIPMC_TOCPUf_GET BCM56504_A0_CPU_CONTROL_1r_UIPMC_TOCPUf_GET
#define CPU_CONTROL_1r_UIPMC_TOCPUf_SET BCM56504_A0_CPU_CONTROL_1r_UIPMC_TOCPUf_SET
#define CPU_CONTROL_1r_UMC_TOCPUf_GET BCM56504_A0_CPU_CONTROL_1r_UMC_TOCPUf_GET
#define CPU_CONTROL_1r_UMC_TOCPUf_SET BCM56504_A0_CPU_CONTROL_1r_UMC_TOCPUf_SET
#define CPU_CONTROL_1r_UUCAST_TOCPUf_GET BCM56504_A0_CPU_CONTROL_1r_UUCAST_TOCPUf_GET
#define CPU_CONTROL_1r_UUCAST_TOCPUf_SET BCM56504_A0_CPU_CONTROL_1r_UUCAST_TOCPUf_SET
#define CPU_CONTROL_1r_V4L3ERR_TOCPUf_GET BCM56504_A0_CPU_CONTROL_1r_V4L3ERR_TOCPUf_GET
#define CPU_CONTROL_1r_V4L3ERR_TOCPUf_SET BCM56504_A0_CPU_CONTROL_1r_V4L3ERR_TOCPUf_SET
#define CPU_CONTROL_1r_IPMCERR_TOCPUf_GET BCM56504_A0_CPU_CONTROL_1r_IPMCERR_TOCPUf_GET
#define CPU_CONTROL_1r_IPMCERR_TOCPUf_SET BCM56504_A0_CPU_CONTROL_1r_IPMCERR_TOCPUf_SET
#define CPU_CONTROL_1r_UVLAN_TOCPUf_GET BCM56504_A0_CPU_CONTROL_1r_UVLAN_TOCPUf_GET
#define CPU_CONTROL_1r_UVLAN_TOCPUf_SET BCM56504_A0_CPU_CONTROL_1r_UVLAN_TOCPUf_SET
#define CPU_CONTROL_1r_UNRESOLVEDL3SRC_TOCPUf_GET BCM56504_A0_CPU_CONTROL_1r_UNRESOLVEDL3SRC_TOCPUf_GET
#define CPU_CONTROL_1r_UNRESOLVEDL3SRC_TOCPUf_SET BCM56504_A0_CPU_CONTROL_1r_UNRESOLVEDL3SRC_TOCPUf_SET
#define CPU_CONTROL_1r_V6L3DSTMISS_TOCPUf_GET BCM56504_A0_CPU_CONTROL_1r_V6L3DSTMISS_TOCPUf_GET
#define CPU_CONTROL_1r_V6L3DSTMISS_TOCPUf_SET BCM56504_A0_CPU_CONTROL_1r_V6L3DSTMISS_TOCPUf_SET
#define CPU_CONTROL_1r_V4L3DSTMISS_TOCPUf_GET BCM56504_A0_CPU_CONTROL_1r_V4L3DSTMISS_TOCPUf_GET
#define CPU_CONTROL_1r_V4L3DSTMISS_TOCPUf_SET BCM56504_A0_CPU_CONTROL_1r_V4L3DSTMISS_TOCPUf_SET
#define CPU_CONTROL_1r_IPMCPORTMISS_TOCPUf_GET BCM56504_A0_CPU_CONTROL_1r_IPMCPORTMISS_TOCPUf_GET
#define CPU_CONTROL_1r_IPMCPORTMISS_TOCPUf_SET BCM56504_A0_CPU_CONTROL_1r_IPMCPORTMISS_TOCPUf_SET
#define CPU_CONTROL_1r_SRCROUTE_TOCPUf_GET BCM56504_A0_CPU_CONTROL_1r_SRCROUTE_TOCPUf_GET
#define CPU_CONTROL_1r_SRCROUTE_TOCPUf_SET BCM56504_A0_CPU_CONTROL_1r_SRCROUTE_TOCPUf_SET
#define CPU_CONTROL_1r_V6L3ERR_TOCPUf_GET BCM56504_A0_CPU_CONTROL_1r_V6L3ERR_TOCPUf_GET
#define CPU_CONTROL_1r_V6L3ERR_TOCPUf_SET BCM56504_A0_CPU_CONTROL_1r_V6L3ERR_TOCPUf_SET
#define CPU_CONTROL_1r_MARTIAN_ADDR_TOCPUf_GET BCM56504_A0_CPU_CONTROL_1r_MARTIAN_ADDR_TOCPUf_GET
#define CPU_CONTROL_1r_MARTIAN_ADDR_TOCPUf_SET BCM56504_A0_CPU_CONTROL_1r_MARTIAN_ADDR_TOCPUf_SET
#define CPU_CONTROL_1r_TUNNEL_ERR_TOCPUf_GET BCM56504_A0_CPU_CONTROL_1r_TUNNEL_ERR_TOCPUf_GET
#define CPU_CONTROL_1r_TUNNEL_ERR_TOCPUf_SET BCM56504_A0_CPU_CONTROL_1r_TUNNEL_ERR_TOCPUf_SET
#define CPU_CONTROL_1r_DOSATTACK_TOCPUf_GET BCM56504_A0_CPU_CONTROL_1r_DOSATTACK_TOCPUf_GET
#define CPU_CONTROL_1r_DOSATTACK_TOCPUf_SET BCM56504_A0_CPU_CONTROL_1r_DOSATTACK_TOCPUf_SET
#define CPU_CONTROL_1r_L3UC_TTL_ERR_TOCPUf_GET BCM56504_A0_CPU_CONTROL_1r_L3UC_TTL_ERR_TOCPUf_GET
#define CPU_CONTROL_1r_L3UC_TTL_ERR_TOCPUf_SET BCM56504_A0_CPU_CONTROL_1r_L3UC_TTL_ERR_TOCPUf_SET
#define CPU_CONTROL_1r_IPMC_TTL_ERR_TOCPUf_GET BCM56504_A0_CPU_CONTROL_1r_IPMC_TTL_ERR_TOCPUf_GET
#define CPU_CONTROL_1r_IPMC_TTL_ERR_TOCPUf_SET BCM56504_A0_CPU_CONTROL_1r_IPMC_TTL_ERR_TOCPUf_SET
#define CPU_CONTROL_1r_ICMP_REDIRECT_TOCPUf_GET BCM56504_A0_CPU_CONTROL_1r_ICMP_REDIRECT_TOCPUf_GET
#define CPU_CONTROL_1r_ICMP_REDIRECT_TOCPUf_SET BCM56504_A0_CPU_CONTROL_1r_ICMP_REDIRECT_TOCPUf_SET
#define CPU_CONTROL_1r_L3_SLOWPATH_TOCPUf_GET BCM56504_A0_CPU_CONTROL_1r_L3_SLOWPATH_TOCPUf_GET
#define CPU_CONTROL_1r_L3_SLOWPATH_TOCPUf_SET BCM56504_A0_CPU_CONTROL_1r_L3_SLOWPATH_TOCPUf_SET
#define READ_CPU_CONTROL_1r BCM56504_A0_READ_CPU_CONTROL_1r
#define WRITE_CPU_CONTROL_1r BCM56504_A0_WRITE_CPU_CONTROL_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CPU_CONTROL_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CPU_CONTROL_2
 * BLOCKS:   IPIPE
 * DESC:     Control Register for Packets sent to the CPU
 * SIZE:     32
 * FIELDS:
 *     CPU_PROTOCOL_PRIORITY CPU Protocol Priority
 *     CPU_LKUPFAIL_PRIORITY CPU Lookup Fail Priority
 *     CPU_SFLOW_PRIORITY CPU SFLOW Priority
 *     CPU_DEFAULT_PRIORITY CPU Default Priority
 *     CPU_MTUFAIL_PRIORITY CPU MTU fail Priority
 *     CPU_FPCOPY_PRIORITY CPU FP copy to cpu Priority
 *     CPU_ICMP_REDIRECT_PRIORITY CPU ICMP Redirect Priority
 *     CPU_MIRROR_PRIORITY CPU Mirror Priority
 *
 ******************************************************************************/
#define BCM56504_A0_CPU_CONTROL_2r 0x0e780115

#define BCM56504_A0_CPU_CONTROL_2r_SIZE 4

/*
 * This structure should be used to declare and program CPU_CONTROL_2.
 *
 */
typedef union BCM56504_A0_CPU_CONTROL_2r_s {
	uint32_t v[1];
	uint32_t cpu_control_2[1];
	uint32_t _cpu_control_2;
} BCM56504_A0_CPU_CONTROL_2r_t;

#define BCM56504_A0_CPU_CONTROL_2r_CLR(r) (r).cpu_control_2[0] = 0
#define BCM56504_A0_CPU_CONTROL_2r_SET(r,d) (r).cpu_control_2[0] = d
#define BCM56504_A0_CPU_CONTROL_2r_GET(r) (r).cpu_control_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CPU_CONTROL_2r_CPU_PROTOCOL_PRIORITYf_GET(r) (((r).cpu_control_2[0]) & 0x7)
#define BCM56504_A0_CPU_CONTROL_2r_CPU_PROTOCOL_PRIORITYf_SET(r,f) (r).cpu_control_2[0]=(((r).cpu_control_2[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM56504_A0_CPU_CONTROL_2r_CPU_LKUPFAIL_PRIORITYf_GET(r) ((((r).cpu_control_2[0]) >> 3) & 0x7)
#define BCM56504_A0_CPU_CONTROL_2r_CPU_LKUPFAIL_PRIORITYf_SET(r,f) (r).cpu_control_2[0]=(((r).cpu_control_2[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM56504_A0_CPU_CONTROL_2r_CPU_SFLOW_PRIORITYf_GET(r) ((((r).cpu_control_2[0]) >> 6) & 0x7)
#define BCM56504_A0_CPU_CONTROL_2r_CPU_SFLOW_PRIORITYf_SET(r,f) (r).cpu_control_2[0]=(((r).cpu_control_2[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM56504_A0_CPU_CONTROL_2r_CPU_DEFAULT_PRIORITYf_GET(r) ((((r).cpu_control_2[0]) >> 9) & 0x7)
#define BCM56504_A0_CPU_CONTROL_2r_CPU_DEFAULT_PRIORITYf_SET(r,f) (r).cpu_control_2[0]=(((r).cpu_control_2[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM56504_A0_CPU_CONTROL_2r_CPU_MTUFAIL_PRIORITYf_GET(r) ((((r).cpu_control_2[0]) >> 12) & 0x7)
#define BCM56504_A0_CPU_CONTROL_2r_CPU_MTUFAIL_PRIORITYf_SET(r,f) (r).cpu_control_2[0]=(((r).cpu_control_2[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM56504_A0_CPU_CONTROL_2r_CPU_FPCOPY_PRIORITYf_GET(r) ((((r).cpu_control_2[0]) >> 15) & 0x7)
#define BCM56504_A0_CPU_CONTROL_2r_CPU_FPCOPY_PRIORITYf_SET(r,f) (r).cpu_control_2[0]=(((r).cpu_control_2[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM56504_A0_CPU_CONTROL_2r_CPU_ICMP_REDIRECT_PRIORITYf_GET(r) ((((r).cpu_control_2[0]) >> 18) & 0x7)
#define BCM56504_A0_CPU_CONTROL_2r_CPU_ICMP_REDIRECT_PRIORITYf_SET(r,f) (r).cpu_control_2[0]=(((r).cpu_control_2[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM56504_A0_CPU_CONTROL_2r_CPU_MIRROR_PRIORITYf_GET(r) ((((r).cpu_control_2[0]) >> 21) & 0x7)
#define BCM56504_A0_CPU_CONTROL_2r_CPU_MIRROR_PRIORITYf_SET(r,f) (r).cpu_control_2[0]=(((r).cpu_control_2[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))

/*
 * These macros can be used to access CPU_CONTROL_2.
 *
 */
#define BCM56504_A0_READ_CPU_CONTROL_2r(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_CPU_CONTROL_2r,(r._cpu_control_2))
#define BCM56504_A0_WRITE_CPU_CONTROL_2r(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_CPU_CONTROL_2r,&(r._cpu_control_2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CPU_CONTROL_2r BCM56504_A0_CPU_CONTROL_2r
#define CPU_CONTROL_2r_SIZE BCM56504_A0_CPU_CONTROL_2r_SIZE
typedef BCM56504_A0_CPU_CONTROL_2r_t CPU_CONTROL_2r_t;
#define CPU_CONTROL_2r_CLR BCM56504_A0_CPU_CONTROL_2r_CLR
#define CPU_CONTROL_2r_SET BCM56504_A0_CPU_CONTROL_2r_SET
#define CPU_CONTROL_2r_GET BCM56504_A0_CPU_CONTROL_2r_GET
#define CPU_CONTROL_2r_CPU_PROTOCOL_PRIORITYf_GET BCM56504_A0_CPU_CONTROL_2r_CPU_PROTOCOL_PRIORITYf_GET
#define CPU_CONTROL_2r_CPU_PROTOCOL_PRIORITYf_SET BCM56504_A0_CPU_CONTROL_2r_CPU_PROTOCOL_PRIORITYf_SET
#define CPU_CONTROL_2r_CPU_LKUPFAIL_PRIORITYf_GET BCM56504_A0_CPU_CONTROL_2r_CPU_LKUPFAIL_PRIORITYf_GET
#define CPU_CONTROL_2r_CPU_LKUPFAIL_PRIORITYf_SET BCM56504_A0_CPU_CONTROL_2r_CPU_LKUPFAIL_PRIORITYf_SET
#define CPU_CONTROL_2r_CPU_SFLOW_PRIORITYf_GET BCM56504_A0_CPU_CONTROL_2r_CPU_SFLOW_PRIORITYf_GET
#define CPU_CONTROL_2r_CPU_SFLOW_PRIORITYf_SET BCM56504_A0_CPU_CONTROL_2r_CPU_SFLOW_PRIORITYf_SET
#define CPU_CONTROL_2r_CPU_DEFAULT_PRIORITYf_GET BCM56504_A0_CPU_CONTROL_2r_CPU_DEFAULT_PRIORITYf_GET
#define CPU_CONTROL_2r_CPU_DEFAULT_PRIORITYf_SET BCM56504_A0_CPU_CONTROL_2r_CPU_DEFAULT_PRIORITYf_SET
#define CPU_CONTROL_2r_CPU_MTUFAIL_PRIORITYf_GET BCM56504_A0_CPU_CONTROL_2r_CPU_MTUFAIL_PRIORITYf_GET
#define CPU_CONTROL_2r_CPU_MTUFAIL_PRIORITYf_SET BCM56504_A0_CPU_CONTROL_2r_CPU_MTUFAIL_PRIORITYf_SET
#define CPU_CONTROL_2r_CPU_FPCOPY_PRIORITYf_GET BCM56504_A0_CPU_CONTROL_2r_CPU_FPCOPY_PRIORITYf_GET
#define CPU_CONTROL_2r_CPU_FPCOPY_PRIORITYf_SET BCM56504_A0_CPU_CONTROL_2r_CPU_FPCOPY_PRIORITYf_SET
#define CPU_CONTROL_2r_CPU_ICMP_REDIRECT_PRIORITYf_GET BCM56504_A0_CPU_CONTROL_2r_CPU_ICMP_REDIRECT_PRIORITYf_GET
#define CPU_CONTROL_2r_CPU_ICMP_REDIRECT_PRIORITYf_SET BCM56504_A0_CPU_CONTROL_2r_CPU_ICMP_REDIRECT_PRIORITYf_SET
#define CPU_CONTROL_2r_CPU_MIRROR_PRIORITYf_GET BCM56504_A0_CPU_CONTROL_2r_CPU_MIRROR_PRIORITYf_GET
#define CPU_CONTROL_2r_CPU_MIRROR_PRIORITYf_SET BCM56504_A0_CPU_CONTROL_2r_CPU_MIRROR_PRIORITYf_SET
#define READ_CPU_CONTROL_2r BCM56504_A0_READ_CPU_CONTROL_2r
#define WRITE_CPU_CONTROL_2r BCM56504_A0_WRITE_CPU_CONTROL_2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CPU_CONTROL_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CPU_COS_SEL
 * BLOCKS:   IPIPE
 * DESC:     CPU COS Select Register
 * SIZE:     32
 * FIELDS:
 *     COS0             COS 0 value
 *     COS1             COS 1 value
 *     COS2             COS 2 value
 *     COS3             COS 3 value
 *     COS4             COS 4 value
 *     COS5             COS 5 value
 *     COS6             COS 6 value
 *     COS7             COS 7 value
 *
 ******************************************************************************/
#define BCM56504_A0_CPU_COS_SELr 0x0e780120

#define BCM56504_A0_CPU_COS_SELr_SIZE 4

/*
 * This structure should be used to declare and program CPU_COS_SEL.
 *
 */
typedef union BCM56504_A0_CPU_COS_SELr_s {
	uint32_t v[1];
	uint32_t cpu_cos_sel[1];
	uint32_t _cpu_cos_sel;
} BCM56504_A0_CPU_COS_SELr_t;

#define BCM56504_A0_CPU_COS_SELr_CLR(r) (r).cpu_cos_sel[0] = 0
#define BCM56504_A0_CPU_COS_SELr_SET(r,d) (r).cpu_cos_sel[0] = d
#define BCM56504_A0_CPU_COS_SELr_GET(r) (r).cpu_cos_sel[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CPU_COS_SELr_COS0f_GET(r) (((r).cpu_cos_sel[0]) & 0x7)
#define BCM56504_A0_CPU_COS_SELr_COS0f_SET(r,f) (r).cpu_cos_sel[0]=(((r).cpu_cos_sel[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM56504_A0_CPU_COS_SELr_COS1f_GET(r) ((((r).cpu_cos_sel[0]) >> 3) & 0x7)
#define BCM56504_A0_CPU_COS_SELr_COS1f_SET(r,f) (r).cpu_cos_sel[0]=(((r).cpu_cos_sel[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM56504_A0_CPU_COS_SELr_COS2f_GET(r) ((((r).cpu_cos_sel[0]) >> 6) & 0x7)
#define BCM56504_A0_CPU_COS_SELr_COS2f_SET(r,f) (r).cpu_cos_sel[0]=(((r).cpu_cos_sel[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM56504_A0_CPU_COS_SELr_COS3f_GET(r) ((((r).cpu_cos_sel[0]) >> 9) & 0x7)
#define BCM56504_A0_CPU_COS_SELr_COS3f_SET(r,f) (r).cpu_cos_sel[0]=(((r).cpu_cos_sel[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM56504_A0_CPU_COS_SELr_COS4f_GET(r) ((((r).cpu_cos_sel[0]) >> 12) & 0x7)
#define BCM56504_A0_CPU_COS_SELr_COS4f_SET(r,f) (r).cpu_cos_sel[0]=(((r).cpu_cos_sel[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM56504_A0_CPU_COS_SELr_COS5f_GET(r) ((((r).cpu_cos_sel[0]) >> 15) & 0x7)
#define BCM56504_A0_CPU_COS_SELr_COS5f_SET(r,f) (r).cpu_cos_sel[0]=(((r).cpu_cos_sel[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM56504_A0_CPU_COS_SELr_COS6f_GET(r) ((((r).cpu_cos_sel[0]) >> 18) & 0x7)
#define BCM56504_A0_CPU_COS_SELr_COS6f_SET(r,f) (r).cpu_cos_sel[0]=(((r).cpu_cos_sel[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM56504_A0_CPU_COS_SELr_COS7f_GET(r) ((((r).cpu_cos_sel[0]) >> 21) & 0x7)
#define BCM56504_A0_CPU_COS_SELr_COS7f_SET(r,f) (r).cpu_cos_sel[0]=(((r).cpu_cos_sel[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))

/*
 * These macros can be used to access CPU_COS_SEL.
 *
 */
#define BCM56504_A0_READ_CPU_COS_SELr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_CPU_COS_SELr,(r._cpu_cos_sel))
#define BCM56504_A0_WRITE_CPU_COS_SELr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_CPU_COS_SELr,&(r._cpu_cos_sel))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CPU_COS_SELr BCM56504_A0_CPU_COS_SELr
#define CPU_COS_SELr_SIZE BCM56504_A0_CPU_COS_SELr_SIZE
typedef BCM56504_A0_CPU_COS_SELr_t CPU_COS_SELr_t;
#define CPU_COS_SELr_CLR BCM56504_A0_CPU_COS_SELr_CLR
#define CPU_COS_SELr_SET BCM56504_A0_CPU_COS_SELr_SET
#define CPU_COS_SELr_GET BCM56504_A0_CPU_COS_SELr_GET
#define CPU_COS_SELr_COS0f_GET BCM56504_A0_CPU_COS_SELr_COS0f_GET
#define CPU_COS_SELr_COS0f_SET BCM56504_A0_CPU_COS_SELr_COS0f_SET
#define CPU_COS_SELr_COS1f_GET BCM56504_A0_CPU_COS_SELr_COS1f_GET
#define CPU_COS_SELr_COS1f_SET BCM56504_A0_CPU_COS_SELr_COS1f_SET
#define CPU_COS_SELr_COS2f_GET BCM56504_A0_CPU_COS_SELr_COS2f_GET
#define CPU_COS_SELr_COS2f_SET BCM56504_A0_CPU_COS_SELr_COS2f_SET
#define CPU_COS_SELr_COS3f_GET BCM56504_A0_CPU_COS_SELr_COS3f_GET
#define CPU_COS_SELr_COS3f_SET BCM56504_A0_CPU_COS_SELr_COS3f_SET
#define CPU_COS_SELr_COS4f_GET BCM56504_A0_CPU_COS_SELr_COS4f_GET
#define CPU_COS_SELr_COS4f_SET BCM56504_A0_CPU_COS_SELr_COS4f_SET
#define CPU_COS_SELr_COS5f_GET BCM56504_A0_CPU_COS_SELr_COS5f_GET
#define CPU_COS_SELr_COS5f_SET BCM56504_A0_CPU_COS_SELr_COS5f_SET
#define CPU_COS_SELr_COS6f_GET BCM56504_A0_CPU_COS_SELr_COS6f_GET
#define CPU_COS_SELr_COS6f_SET BCM56504_A0_CPU_COS_SELr_COS6f_SET
#define CPU_COS_SELr_COS7f_GET BCM56504_A0_CPU_COS_SELr_COS7f_GET
#define CPU_COS_SELr_COS7f_SET BCM56504_A0_CPU_COS_SELr_COS7f_SET
#define READ_CPU_COS_SELr BCM56504_A0_READ_CPU_COS_SELr
#define WRITE_CPU_COS_SELr BCM56504_A0_WRITE_CPU_COS_SELr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CPU_COS_SELr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  CPU_PRIORITY_SEL
 * BLOCKS:   IPIPE
 * DESC:     CPU Priority Select Register
 * SIZE:     32
 * FIELDS:
 *     PRI0             Priority 0 value
 *     PRI1             Priority 1 value
 *     PRI2             Priority 2 value
 *     PRI3             Priority 3 value
 *     PRI4             Priority 4 value
 *     PRI5             Priority 5 value
 *     PRI6             Priority 6 value
 *     PRI7             Priority 7 value
 *
 ******************************************************************************/
#define BCM56504_A0_CPU_PRIORITY_SELr 0x0e780119

#define BCM56504_A0_CPU_PRIORITY_SELr_SIZE 4

/*
 * This structure should be used to declare and program CPU_PRIORITY_SEL.
 *
 */
typedef union BCM56504_A0_CPU_PRIORITY_SELr_s {
	uint32_t v[1];
	uint32_t cpu_priority_sel[1];
	uint32_t _cpu_priority_sel;
} BCM56504_A0_CPU_PRIORITY_SELr_t;

#define BCM56504_A0_CPU_PRIORITY_SELr_CLR(r) (r).cpu_priority_sel[0] = 0
#define BCM56504_A0_CPU_PRIORITY_SELr_SET(r,d) (r).cpu_priority_sel[0] = d
#define BCM56504_A0_CPU_PRIORITY_SELr_GET(r) (r).cpu_priority_sel[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_CPU_PRIORITY_SELr_PRI0f_GET(r) (((r).cpu_priority_sel[0]) & 0x7)
#define BCM56504_A0_CPU_PRIORITY_SELr_PRI0f_SET(r,f) (r).cpu_priority_sel[0]=(((r).cpu_priority_sel[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM56504_A0_CPU_PRIORITY_SELr_PRI1f_GET(r) ((((r).cpu_priority_sel[0]) >> 3) & 0x7)
#define BCM56504_A0_CPU_PRIORITY_SELr_PRI1f_SET(r,f) (r).cpu_priority_sel[0]=(((r).cpu_priority_sel[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM56504_A0_CPU_PRIORITY_SELr_PRI2f_GET(r) ((((r).cpu_priority_sel[0]) >> 6) & 0x7)
#define BCM56504_A0_CPU_PRIORITY_SELr_PRI2f_SET(r,f) (r).cpu_priority_sel[0]=(((r).cpu_priority_sel[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM56504_A0_CPU_PRIORITY_SELr_PRI3f_GET(r) ((((r).cpu_priority_sel[0]) >> 9) & 0x7)
#define BCM56504_A0_CPU_PRIORITY_SELr_PRI3f_SET(r,f) (r).cpu_priority_sel[0]=(((r).cpu_priority_sel[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM56504_A0_CPU_PRIORITY_SELr_PRI4f_GET(r) ((((r).cpu_priority_sel[0]) >> 12) & 0x7)
#define BCM56504_A0_CPU_PRIORITY_SELr_PRI4f_SET(r,f) (r).cpu_priority_sel[0]=(((r).cpu_priority_sel[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM56504_A0_CPU_PRIORITY_SELr_PRI5f_GET(r) ((((r).cpu_priority_sel[0]) >> 15) & 0x7)
#define BCM56504_A0_CPU_PRIORITY_SELr_PRI5f_SET(r,f) (r).cpu_priority_sel[0]=(((r).cpu_priority_sel[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM56504_A0_CPU_PRIORITY_SELr_PRI6f_GET(r) ((((r).cpu_priority_sel[0]) >> 18) & 0x7)
#define BCM56504_A0_CPU_PRIORITY_SELr_PRI6f_SET(r,f) (r).cpu_priority_sel[0]=(((r).cpu_priority_sel[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM56504_A0_CPU_PRIORITY_SELr_PRI7f_GET(r) ((((r).cpu_priority_sel[0]) >> 21) & 0x7)
#define BCM56504_A0_CPU_PRIORITY_SELr_PRI7f_SET(r,f) (r).cpu_priority_sel[0]=(((r).cpu_priority_sel[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))

/*
 * These macros can be used to access CPU_PRIORITY_SEL.
 *
 */
#define BCM56504_A0_READ_CPU_PRIORITY_SELr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_CPU_PRIORITY_SELr,(r._cpu_priority_sel))
#define BCM56504_A0_WRITE_CPU_PRIORITY_SELr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_CPU_PRIORITY_SELr,&(r._cpu_priority_sel))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CPU_PRIORITY_SELr BCM56504_A0_CPU_PRIORITY_SELr
#define CPU_PRIORITY_SELr_SIZE BCM56504_A0_CPU_PRIORITY_SELr_SIZE
typedef BCM56504_A0_CPU_PRIORITY_SELr_t CPU_PRIORITY_SELr_t;
#define CPU_PRIORITY_SELr_CLR BCM56504_A0_CPU_PRIORITY_SELr_CLR
#define CPU_PRIORITY_SELr_SET BCM56504_A0_CPU_PRIORITY_SELr_SET
#define CPU_PRIORITY_SELr_GET BCM56504_A0_CPU_PRIORITY_SELr_GET
#define CPU_PRIORITY_SELr_PRI0f_GET BCM56504_A0_CPU_PRIORITY_SELr_PRI0f_GET
#define CPU_PRIORITY_SELr_PRI0f_SET BCM56504_A0_CPU_PRIORITY_SELr_PRI0f_SET
#define CPU_PRIORITY_SELr_PRI1f_GET BCM56504_A0_CPU_PRIORITY_SELr_PRI1f_GET
#define CPU_PRIORITY_SELr_PRI1f_SET BCM56504_A0_CPU_PRIORITY_SELr_PRI1f_SET
#define CPU_PRIORITY_SELr_PRI2f_GET BCM56504_A0_CPU_PRIORITY_SELr_PRI2f_GET
#define CPU_PRIORITY_SELr_PRI2f_SET BCM56504_A0_CPU_PRIORITY_SELr_PRI2f_SET
#define CPU_PRIORITY_SELr_PRI3f_GET BCM56504_A0_CPU_PRIORITY_SELr_PRI3f_GET
#define CPU_PRIORITY_SELr_PRI3f_SET BCM56504_A0_CPU_PRIORITY_SELr_PRI3f_SET
#define CPU_PRIORITY_SELr_PRI4f_GET BCM56504_A0_CPU_PRIORITY_SELr_PRI4f_GET
#define CPU_PRIORITY_SELr_PRI4f_SET BCM56504_A0_CPU_PRIORITY_SELr_PRI4f_SET
#define CPU_PRIORITY_SELr_PRI5f_GET BCM56504_A0_CPU_PRIORITY_SELr_PRI5f_GET
#define CPU_PRIORITY_SELr_PRI5f_SET BCM56504_A0_CPU_PRIORITY_SELr_PRI5f_SET
#define CPU_PRIORITY_SELr_PRI6f_GET BCM56504_A0_CPU_PRIORITY_SELr_PRI6f_GET
#define CPU_PRIORITY_SELr_PRI6f_SET BCM56504_A0_CPU_PRIORITY_SELr_PRI6f_SET
#define CPU_PRIORITY_SELr_PRI7f_GET BCM56504_A0_CPU_PRIORITY_SELr_PRI7f_GET
#define CPU_PRIORITY_SELr_PRI7f_SET BCM56504_A0_CPU_PRIORITY_SELr_PRI7f_SET
#define READ_CPU_PRIORITY_SELr BCM56504_A0_READ_CPU_PRIORITY_SELr
#define WRITE_CPU_PRIORITY_SELr BCM56504_A0_WRITE_CPU_PRIORITY_SELr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_CPU_PRIORITY_SELr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  DLFBC_STORM_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     Ethernet DLF Rate Control Registers
 * SIZE:     32
 * FIELDS:
 *     THRESHOLD        Rate Limit, count as number of packets
 *     ENABLE           DLF rate control enable
 *
 ******************************************************************************/
#define BCM56504_A0_DLFBC_STORM_CONTROLr 0x0b700003

#define BCM56504_A0_DLFBC_STORM_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program DLFBC_STORM_CONTROL.
 *
 */
typedef union BCM56504_A0_DLFBC_STORM_CONTROLr_s {
	uint32_t v[1];
	uint32_t dlfbc_storm_control[1];
	uint32_t _dlfbc_storm_control;
} BCM56504_A0_DLFBC_STORM_CONTROLr_t;

#define BCM56504_A0_DLFBC_STORM_CONTROLr_CLR(r) (r).dlfbc_storm_control[0] = 0
#define BCM56504_A0_DLFBC_STORM_CONTROLr_SET(r,d) (r).dlfbc_storm_control[0] = d
#define BCM56504_A0_DLFBC_STORM_CONTROLr_GET(r) (r).dlfbc_storm_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_DLFBC_STORM_CONTROLr_THRESHOLDf_GET(r) (((r).dlfbc_storm_control[0]) & 0x1ffffff)
#define BCM56504_A0_DLFBC_STORM_CONTROLr_THRESHOLDf_SET(r,f) (r).dlfbc_storm_control[0]=(((r).dlfbc_storm_control[0] & ~((uint32_t)0x1ffffff)) | (((uint32_t)f) & 0x1ffffff))
#define BCM56504_A0_DLFBC_STORM_CONTROLr_ENABLEf_GET(r) ((((r).dlfbc_storm_control[0]) >> 25) & 0x1)
#define BCM56504_A0_DLFBC_STORM_CONTROLr_ENABLEf_SET(r,f) (r).dlfbc_storm_control[0]=(((r).dlfbc_storm_control[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))

/*
 * These macros can be used to access DLFBC_STORM_CONTROL.
 *
 */
#define BCM56504_A0_READ_DLFBC_STORM_CONTROLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_DLFBC_STORM_CONTROLr,(r._dlfbc_storm_control))
#define BCM56504_A0_WRITE_DLFBC_STORM_CONTROLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_DLFBC_STORM_CONTROLr,&(r._dlfbc_storm_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DLFBC_STORM_CONTROLr BCM56504_A0_DLFBC_STORM_CONTROLr
#define DLFBC_STORM_CONTROLr_SIZE BCM56504_A0_DLFBC_STORM_CONTROLr_SIZE
typedef BCM56504_A0_DLFBC_STORM_CONTROLr_t DLFBC_STORM_CONTROLr_t;
#define DLFBC_STORM_CONTROLr_CLR BCM56504_A0_DLFBC_STORM_CONTROLr_CLR
#define DLFBC_STORM_CONTROLr_SET BCM56504_A0_DLFBC_STORM_CONTROLr_SET
#define DLFBC_STORM_CONTROLr_GET BCM56504_A0_DLFBC_STORM_CONTROLr_GET
#define DLFBC_STORM_CONTROLr_THRESHOLDf_GET BCM56504_A0_DLFBC_STORM_CONTROLr_THRESHOLDf_GET
#define DLFBC_STORM_CONTROLr_THRESHOLDf_SET BCM56504_A0_DLFBC_STORM_CONTROLr_THRESHOLDf_SET
#define DLFBC_STORM_CONTROLr_ENABLEf_GET BCM56504_A0_DLFBC_STORM_CONTROLr_ENABLEf_GET
#define DLFBC_STORM_CONTROLr_ENABLEf_SET BCM56504_A0_DLFBC_STORM_CONTROLr_ENABLEf_SET
#define READ_DLFBC_STORM_CONTROLr BCM56504_A0_READ_DLFBC_STORM_CONTROLr
#define WRITE_DLFBC_STORM_CONTROLr BCM56504_A0_WRITE_DLFBC_STORM_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_DLFBC_STORM_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  DOS_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     DOS (Denial of Service) Attack Control Register
 * SIZE:     32
 * FIELDS:
 *     ICMP_CHECK_ENABLE Enable ICMP DOS attack checks
 *     TCP_FRAG_CHECK_ENABLE Enable checking TCP DOS fragment attack
 *     L4_PORT_CHECK_ENABLE Enable checking TCP/UDP DOS attack for dropping packet if TCP/UDP source port == destination port
 *     TCP_FLAGS_CHECK_ENABLE Enable checking TCP DOS attacks on invalid flags
 *     IPV4_FIRST_FRAG_CHECK_ENABLE Enable checking DOS attacks on IP first fragments
 *     BIG_ICMP_PKT_SIZE Maximum length ICMP packet allowed before dropping (maximum 1023 bytes)
 *     MIN_TCPHDR_SIZE  Minimum TCP header length allowed (minimum 0 bytes, maximum 255 bytes)
 *     DROP_IF_SIP_EQUALS_DIP Drop IPv4/IPv6 packets if the SIP == DIP
 *
 ******************************************************************************/
#define BCM56504_A0_DOS_CONTROLr 0x01780001

#define BCM56504_A0_DOS_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program DOS_CONTROL.
 *
 */
typedef union BCM56504_A0_DOS_CONTROLr_s {
	uint32_t v[1];
	uint32_t dos_control[1];
	uint32_t _dos_control;
} BCM56504_A0_DOS_CONTROLr_t;

#define BCM56504_A0_DOS_CONTROLr_CLR(r) (r).dos_control[0] = 0
#define BCM56504_A0_DOS_CONTROLr_SET(r,d) (r).dos_control[0] = d
#define BCM56504_A0_DOS_CONTROLr_GET(r) (r).dos_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_DOS_CONTROLr_ICMP_CHECK_ENABLEf_GET(r) (((r).dos_control[0]) & 0x1)
#define BCM56504_A0_DOS_CONTROLr_ICMP_CHECK_ENABLEf_SET(r,f) (r).dos_control[0]=(((r).dos_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_DOS_CONTROLr_TCP_FRAG_CHECK_ENABLEf_GET(r) ((((r).dos_control[0]) >> 1) & 0x1)
#define BCM56504_A0_DOS_CONTROLr_TCP_FRAG_CHECK_ENABLEf_SET(r,f) (r).dos_control[0]=(((r).dos_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_DOS_CONTROLr_L4_PORT_CHECK_ENABLEf_GET(r) ((((r).dos_control[0]) >> 2) & 0x1)
#define BCM56504_A0_DOS_CONTROLr_L4_PORT_CHECK_ENABLEf_SET(r,f) (r).dos_control[0]=(((r).dos_control[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_DOS_CONTROLr_TCP_FLAGS_CHECK_ENABLEf_GET(r) ((((r).dos_control[0]) >> 3) & 0x1)
#define BCM56504_A0_DOS_CONTROLr_TCP_FLAGS_CHECK_ENABLEf_SET(r,f) (r).dos_control[0]=(((r).dos_control[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_DOS_CONTROLr_IPV4_FIRST_FRAG_CHECK_ENABLEf_GET(r) ((((r).dos_control[0]) >> 4) & 0x1)
#define BCM56504_A0_DOS_CONTROLr_IPV4_FIRST_FRAG_CHECK_ENABLEf_SET(r,f) (r).dos_control[0]=(((r).dos_control[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56504_A0_DOS_CONTROLr_BIG_ICMP_PKT_SIZEf_GET(r) ((((r).dos_control[0]) >> 5) & 0x3ff)
#define BCM56504_A0_DOS_CONTROLr_BIG_ICMP_PKT_SIZEf_SET(r,f) (r).dos_control[0]=(((r).dos_control[0] & ~((uint32_t)0x3ff << 5)) | ((((uint32_t)f) & 0x3ff) << 5))
#define BCM56504_A0_DOS_CONTROLr_MIN_TCPHDR_SIZEf_GET(r) ((((r).dos_control[0]) >> 15) & 0xff)
#define BCM56504_A0_DOS_CONTROLr_MIN_TCPHDR_SIZEf_SET(r,f) (r).dos_control[0]=(((r).dos_control[0] & ~((uint32_t)0xff << 15)) | ((((uint32_t)f) & 0xff) << 15))
#define BCM56504_A0_DOS_CONTROLr_DROP_IF_SIP_EQUALS_DIPf_GET(r) ((((r).dos_control[0]) >> 23) & 0x1)
#define BCM56504_A0_DOS_CONTROLr_DROP_IF_SIP_EQUALS_DIPf_SET(r,f) (r).dos_control[0]=(((r).dos_control[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))

/*
 * These macros can be used to access DOS_CONTROL.
 *
 */
#define BCM56504_A0_READ_DOS_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_DOS_CONTROLr,(r._dos_control))
#define BCM56504_A0_WRITE_DOS_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_DOS_CONTROLr,&(r._dos_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DOS_CONTROLr BCM56504_A0_DOS_CONTROLr
#define DOS_CONTROLr_SIZE BCM56504_A0_DOS_CONTROLr_SIZE
typedef BCM56504_A0_DOS_CONTROLr_t DOS_CONTROLr_t;
#define DOS_CONTROLr_CLR BCM56504_A0_DOS_CONTROLr_CLR
#define DOS_CONTROLr_SET BCM56504_A0_DOS_CONTROLr_SET
#define DOS_CONTROLr_GET BCM56504_A0_DOS_CONTROLr_GET
#define DOS_CONTROLr_ICMP_CHECK_ENABLEf_GET BCM56504_A0_DOS_CONTROLr_ICMP_CHECK_ENABLEf_GET
#define DOS_CONTROLr_ICMP_CHECK_ENABLEf_SET BCM56504_A0_DOS_CONTROLr_ICMP_CHECK_ENABLEf_SET
#define DOS_CONTROLr_TCP_FRAG_CHECK_ENABLEf_GET BCM56504_A0_DOS_CONTROLr_TCP_FRAG_CHECK_ENABLEf_GET
#define DOS_CONTROLr_TCP_FRAG_CHECK_ENABLEf_SET BCM56504_A0_DOS_CONTROLr_TCP_FRAG_CHECK_ENABLEf_SET
#define DOS_CONTROLr_L4_PORT_CHECK_ENABLEf_GET BCM56504_A0_DOS_CONTROLr_L4_PORT_CHECK_ENABLEf_GET
#define DOS_CONTROLr_L4_PORT_CHECK_ENABLEf_SET BCM56504_A0_DOS_CONTROLr_L4_PORT_CHECK_ENABLEf_SET
#define DOS_CONTROLr_TCP_FLAGS_CHECK_ENABLEf_GET BCM56504_A0_DOS_CONTROLr_TCP_FLAGS_CHECK_ENABLEf_GET
#define DOS_CONTROLr_TCP_FLAGS_CHECK_ENABLEf_SET BCM56504_A0_DOS_CONTROLr_TCP_FLAGS_CHECK_ENABLEf_SET
#define DOS_CONTROLr_IPV4_FIRST_FRAG_CHECK_ENABLEf_GET BCM56504_A0_DOS_CONTROLr_IPV4_FIRST_FRAG_CHECK_ENABLEf_GET
#define DOS_CONTROLr_IPV4_FIRST_FRAG_CHECK_ENABLEf_SET BCM56504_A0_DOS_CONTROLr_IPV4_FIRST_FRAG_CHECK_ENABLEf_SET
#define DOS_CONTROLr_BIG_ICMP_PKT_SIZEf_GET BCM56504_A0_DOS_CONTROLr_BIG_ICMP_PKT_SIZEf_GET
#define DOS_CONTROLr_BIG_ICMP_PKT_SIZEf_SET BCM56504_A0_DOS_CONTROLr_BIG_ICMP_PKT_SIZEf_SET
#define DOS_CONTROLr_MIN_TCPHDR_SIZEf_GET BCM56504_A0_DOS_CONTROLr_MIN_TCPHDR_SIZEf_GET
#define DOS_CONTROLr_MIN_TCPHDR_SIZEf_SET BCM56504_A0_DOS_CONTROLr_MIN_TCPHDR_SIZEf_SET
#define DOS_CONTROLr_DROP_IF_SIP_EQUALS_DIPf_GET BCM56504_A0_DOS_CONTROLr_DROP_IF_SIP_EQUALS_DIPf_GET
#define DOS_CONTROLr_DROP_IF_SIP_EQUALS_DIPf_SET BCM56504_A0_DOS_CONTROLr_DROP_IF_SIP_EQUALS_DIPf_SET
#define READ_DOS_CONTROLr BCM56504_A0_READ_DOS_CONTROLr
#define WRITE_DOS_CONTROLr BCM56504_A0_WRITE_DOS_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_DOS_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  DSCP_TABLE
 * BLOCKS:   IPIPE
 * DESC:     Diff Serv Code Point Table
 * SIZE:     11
 * FIELDS:
 *     DSCP             New Diff Serv Code Point
 *     PRI              Priority
 *     CNG              Congestion bits
 *
 ******************************************************************************/
#define BCM56504_A0_DSCP_TABLEm 0x08700000

#define BCM56504_A0_DSCP_TABLEm_MIN 0
#define BCM56504_A0_DSCP_TABLEm_MAX 63
#define BCM56504_A0_DSCP_TABLEm_CMAX(u) 63
#define BCM56504_A0_DSCP_TABLEm_SIZE 2

/*
 * This structure should be used to declare and program DSCP_TABLE.
 *
 */
typedef union BCM56504_A0_DSCP_TABLEm_s {
	uint32_t v[1];
	uint32_t dscp_table[1];
	uint32_t _dscp_table;
} BCM56504_A0_DSCP_TABLEm_t;

#define BCM56504_A0_DSCP_TABLEm_CLR(r) (r).dscp_table[0] = 0
#define BCM56504_A0_DSCP_TABLEm_SET(r,d) (r).dscp_table[0] = d
#define BCM56504_A0_DSCP_TABLEm_GET(r) (r).dscp_table[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_DSCP_TABLEm_DSCPf_GET(r) (((r).dscp_table[0]) & 0x3f)
#define BCM56504_A0_DSCP_TABLEm_DSCPf_SET(r,f) (r).dscp_table[0]=(((r).dscp_table[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM56504_A0_DSCP_TABLEm_PRIf_GET(r) ((((r).dscp_table[0]) >> 6) & 0x7)
#define BCM56504_A0_DSCP_TABLEm_PRIf_SET(r,f) (r).dscp_table[0]=(((r).dscp_table[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM56504_A0_DSCP_TABLEm_CNGf_GET(r) ((((r).dscp_table[0]) >> 9) & 0x3)
#define BCM56504_A0_DSCP_TABLEm_CNGf_SET(r,f) (r).dscp_table[0]=(((r).dscp_table[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9))

/*
 * These macros can be used to access DSCP_TABLE.
 *
 */
#define BCM56504_A0_READ_DSCP_TABLEm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_DSCP_TABLEm,i,(m._dscp_table),1)
#define BCM56504_A0_WRITE_DSCP_TABLEm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_DSCP_TABLEm,i,&(m._dscp_table),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DSCP_TABLEm BCM56504_A0_DSCP_TABLEm
#define DSCP_TABLEm_MIN BCM56504_A0_DSCP_TABLEm_MIN
#define DSCP_TABLEm_MAX BCM56504_A0_DSCP_TABLEm_MAX
#define DSCP_TABLEm_CMAX(u) BCM56504_A0_DSCP_TABLEm_CMAX(u)
#define DSCP_TABLEm_SIZE BCM56504_A0_DSCP_TABLEm_SIZE
typedef BCM56504_A0_DSCP_TABLEm_t DSCP_TABLEm_t;
#define DSCP_TABLEm_CLR BCM56504_A0_DSCP_TABLEm_CLR
#define DSCP_TABLEm_SET BCM56504_A0_DSCP_TABLEm_SET
#define DSCP_TABLEm_GET BCM56504_A0_DSCP_TABLEm_GET
#define DSCP_TABLEm_DSCPf_GET BCM56504_A0_DSCP_TABLEm_DSCPf_GET
#define DSCP_TABLEm_DSCPf_SET BCM56504_A0_DSCP_TABLEm_DSCPf_SET
#define DSCP_TABLEm_PRIf_GET BCM56504_A0_DSCP_TABLEm_PRIf_GET
#define DSCP_TABLEm_PRIf_SET BCM56504_A0_DSCP_TABLEm_PRIf_SET
#define DSCP_TABLEm_CNGf_GET BCM56504_A0_DSCP_TABLEm_CNGf_GET
#define DSCP_TABLEm_CNGf_SET BCM56504_A0_DSCP_TABLEm_CNGf_SET
#define READ_DSCP_TABLEm BCM56504_A0_READ_DSCP_TABLEm
#define WRITE_DSCP_TABLEm BCM56504_A0_WRITE_DSCP_TABLEm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_DSCP_TABLEm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  DYNCELLCOUNT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     DYNAMICCELLCOUNT Dynamic Cell Count for each egress port: 
 *
 ******************************************************************************/
#define BCM56504_A0_DYNCELLCOUNTr 0x00600041

#define BCM56504_A0_DYNCELLCOUNTr_SIZE 4

/*
 * This structure should be used to declare and program DYNCELLCOUNT.
 *
 */
typedef union BCM56504_A0_DYNCELLCOUNTr_s {
	uint32_t v[1];
	uint32_t dyncellcount[1];
	uint32_t _dyncellcount;
} BCM56504_A0_DYNCELLCOUNTr_t;

#define BCM56504_A0_DYNCELLCOUNTr_CLR(r) (r).dyncellcount[0] = 0
#define BCM56504_A0_DYNCELLCOUNTr_SET(r,d) (r).dyncellcount[0] = d
#define BCM56504_A0_DYNCELLCOUNTr_GET(r) (r).dyncellcount[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_DYNCELLCOUNTr_DYNAMICCELLCOUNTf_GET(r) (((r).dyncellcount[0]) & 0x3fff)
#define BCM56504_A0_DYNCELLCOUNTr_DYNAMICCELLCOUNTf_SET(r,f) (r).dyncellcount[0]=(((r).dyncellcount[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access DYNCELLCOUNT.
 *
 */
#define BCM56504_A0_READ_DYNCELLCOUNTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_DYNCELLCOUNTr,(r._dyncellcount))
#define BCM56504_A0_WRITE_DYNCELLCOUNTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_DYNCELLCOUNTr,&(r._dyncellcount))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DYNCELLCOUNTr BCM56504_A0_DYNCELLCOUNTr
#define DYNCELLCOUNTr_SIZE BCM56504_A0_DYNCELLCOUNTr_SIZE
typedef BCM56504_A0_DYNCELLCOUNTr_t DYNCELLCOUNTr_t;
#define DYNCELLCOUNTr_CLR BCM56504_A0_DYNCELLCOUNTr_CLR
#define DYNCELLCOUNTr_SET BCM56504_A0_DYNCELLCOUNTr_SET
#define DYNCELLCOUNTr_GET BCM56504_A0_DYNCELLCOUNTr_GET
#define DYNCELLCOUNTr_DYNAMICCELLCOUNTf_GET BCM56504_A0_DYNCELLCOUNTr_DYNAMICCELLCOUNTf_GET
#define DYNCELLCOUNTr_DYNAMICCELLCOUNTf_SET BCM56504_A0_DYNCELLCOUNTr_DYNAMICCELLCOUNTf_SET
#define READ_DYNCELLCOUNTr BCM56504_A0_READ_DYNCELLCOUNTr
#define WRITE_DYNCELLCOUNTr BCM56504_A0_WRITE_DYNCELLCOUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_DYNCELLCOUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  DYNCELLLIMIT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     DYNCELLLIMIT     In Dynamic Memory mode:This regs represent the total dynamic cells that can be used by a port for all COSs. This CBP cells (LCCOUNT>LWM) that are used above the LWM limit are compared against this limit. Effectivelythis limit represents the HOL cell limit for a port. This limit is usedonly if Draco_1.5_mode is enabled.This limit is not used in Draco 1.0 mode.
 *     DYNCELLRESETLIMITSEL In Dynamic Memory mode:This regs is the reset limit on the percentage of the each cos LWM. Each cos hol status will be reset when CBP cells is under the percentage of LWM. (LCCOUNT<%(LWM)). Selection are3'b1xx: 100.0% of LWM. (default setting)3'b000:  75.0% of LWM.3'b001:  50.0% of LWM.3'b010:  25.0% of LWM.3'b011:  12.5% of LWM.This reset limit valids as if Dynamic Memory mode is selected.This reset limit is not valid in Draco 1.0 mode.
 *
 ******************************************************************************/
#define BCM56504_A0_DYNCELLLIMITr 0x00600040

#define BCM56504_A0_DYNCELLLIMITr_SIZE 4

/*
 * This structure should be used to declare and program DYNCELLLIMIT.
 *
 */
typedef union BCM56504_A0_DYNCELLLIMITr_s {
	uint32_t v[1];
	uint32_t dyncelllimit[1];
	uint32_t _dyncelllimit;
} BCM56504_A0_DYNCELLLIMITr_t;

#define BCM56504_A0_DYNCELLLIMITr_CLR(r) (r).dyncelllimit[0] = 0
#define BCM56504_A0_DYNCELLLIMITr_SET(r,d) (r).dyncelllimit[0] = d
#define BCM56504_A0_DYNCELLLIMITr_GET(r) (r).dyncelllimit[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_DYNCELLLIMITr_DYNCELLLIMITf_GET(r) (((r).dyncelllimit[0]) & 0x3fff)
#define BCM56504_A0_DYNCELLLIMITr_DYNCELLLIMITf_SET(r,f) (r).dyncelllimit[0]=(((r).dyncelllimit[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM56504_A0_DYNCELLLIMITr_DYNCELLRESETLIMITSELf_GET(r) ((((r).dyncelllimit[0]) >> 14) & 0x7)
#define BCM56504_A0_DYNCELLLIMITr_DYNCELLRESETLIMITSELf_SET(r,f) (r).dyncelllimit[0]=(((r).dyncelllimit[0] & ~((uint32_t)0x7 << 14)) | ((((uint32_t)f) & 0x7) << 14))

/*
 * These macros can be used to access DYNCELLLIMIT.
 *
 */
#define BCM56504_A0_READ_DYNCELLLIMITr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_DYNCELLLIMITr,(r._dyncelllimit))
#define BCM56504_A0_WRITE_DYNCELLLIMITr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_DYNCELLLIMITr,&(r._dyncelllimit))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DYNCELLLIMITr BCM56504_A0_DYNCELLLIMITr
#define DYNCELLLIMITr_SIZE BCM56504_A0_DYNCELLLIMITr_SIZE
typedef BCM56504_A0_DYNCELLLIMITr_t DYNCELLLIMITr_t;
#define DYNCELLLIMITr_CLR BCM56504_A0_DYNCELLLIMITr_CLR
#define DYNCELLLIMITr_SET BCM56504_A0_DYNCELLLIMITr_SET
#define DYNCELLLIMITr_GET BCM56504_A0_DYNCELLLIMITr_GET
#define DYNCELLLIMITr_DYNCELLLIMITf_GET BCM56504_A0_DYNCELLLIMITr_DYNCELLLIMITf_GET
#define DYNCELLLIMITr_DYNCELLLIMITf_SET BCM56504_A0_DYNCELLLIMITr_DYNCELLLIMITf_SET
#define DYNCELLLIMITr_DYNCELLRESETLIMITSELf_GET BCM56504_A0_DYNCELLLIMITr_DYNCELLRESETLIMITSELf_GET
#define DYNCELLLIMITr_DYNCELLRESETLIMITSELf_SET BCM56504_A0_DYNCELLLIMITr_DYNCELLRESETLIMITSELf_SET
#define READ_DYNCELLLIMITr BCM56504_A0_READ_DYNCELLLIMITr
#define WRITE_DYNCELLLIMITr BCM56504_A0_WRITE_DYNCELLLIMITr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_DYNCELLLIMITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  E2ECONFIG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     E2E_IBP_EN       E2E IBP Mode Enable Register. 1: To Enable E2E IBP Mode. 0: To Disable E2E IBP Mode. Default.
 *     XPORT24_SEND_E2E_IBP 1: XPORT24 will can send e2e ibp message frame. 0: XPORT24 will can not send e2e ibp message frame. 
 *     XPORT25_SEND_E2E_IBP 1: XPORT25 will can send e2e ibp message frame. 0: XPORT25 will can not send e2e ibp message frame. 
 *     XPORT26_SEND_E2E_IBP 1: XPORT26 will can send e2e ibp message frame. 0: XPORT26 will can not send e2e ibp message frame. 
 *     XPORT27_SEND_E2E_IBP 1: XPORT27 will can send e2e ibp message frame. 0: XPORT27 will can not send e2e ibp message frame. 
 *     E2E_HOL_EN       E2E HOL Mode Enable Register. 1: To Enable E2E HOL Mode. 0: To Disable E2E HOL Mode. Default.
 *     XPORT24_SEND_E2E_HOL 1: XPORT24 will can send e2e hol message frame. 0: XPORT24 will can not send e2e hol message frame. 
 *     XPORT25_SEND_E2E_HOL 1: XPORT25 will can send e2e hol message frame. 0: XPORT25 will can not send e2e hol message frame. 
 *     XPORT26_SEND_E2E_HOL 1: XPORT26 will can send e2e hol message frame. 0: XPORT26 will can not send e2e hol message frame. 
 *     XPORT27_SEND_E2E_HOL 1: XPORT27 will can send e2e hol message frame. 0: XPORT27 will can not send e2e hol message frame. 
 *     E2E_MINTIMER_SEL E2E_MINTIMER_SEL is the timing coontraint to control how frequently a secondE2E ibp/hol packet can be sent out. It starts counting after an E2E ibp/hol packet is sent and expired at selected time. There is no packet sending deforetimer expired.  0: Min Timer Disable 1:  16 us 2:  32 us 3:  64 us 4: 128 us 5: 256 us 6: 512 us 7:   1 ms 8:   2 ms 9:   4 ms10:   8 ms11:  16 ms12:  32 ms13:  64 ms14: 128 ms15: 256 ms
 *     E2E_MAXTIMER_SEL E2E_MAXTIMER_SEL is the timing coontraints to control how at least a secondE2E ibp/hol packet need to be sent out evene there is no status change. It starts counting after an E2E ibp/hol packet is sent and expired at selectedtime. Whwne timer expired, it will send out one ibp/hol packet to sync outremote module status.   0: Max Timer Disable 1:  16 us 2:  32 us 3:  64 us 4: 128 us 5: 256 us 6: 512 us 7:   1 ms 8:   2 ms 9:   4 ms10:   8 ms11:  16 ms12:  32 ms13:  64 ms14: 128 ms15: 256 ms
 *     REMOTE_SRCMODID  Remote srouce module id for E2E IBP Cell/Packet Count of remote module. all 29 ports in this module will be accounted for E2E IBP purposes. 
 *     SEND_RX_E2E_BKP_EN SEND_RXBKP_EN received e2e BKP status to gport/xport enable0: Send rx bkp status disable,1: Send rx bkp status enable.
 *
 ******************************************************************************/
#define BCM56504_A0_E2ECONFIGr 0x00680016

#define BCM56504_A0_E2ECONFIGr_SIZE 4

/*
 * This structure should be used to declare and program E2ECONFIG.
 *
 */
typedef union BCM56504_A0_E2ECONFIGr_s {
	uint32_t v[1];
	uint32_t e2econfig[1];
	uint32_t _e2econfig;
} BCM56504_A0_E2ECONFIGr_t;

#define BCM56504_A0_E2ECONFIGr_CLR(r) (r).e2econfig[0] = 0
#define BCM56504_A0_E2ECONFIGr_SET(r,d) (r).e2econfig[0] = d
#define BCM56504_A0_E2ECONFIGr_GET(r) (r).e2econfig[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_E2ECONFIGr_E2E_IBP_ENf_GET(r) (((r).e2econfig[0]) & 0x1)
#define BCM56504_A0_E2ECONFIGr_E2E_IBP_ENf_SET(r,f) (r).e2econfig[0]=(((r).e2econfig[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_E2ECONFIGr_XPORT24_SEND_E2E_IBPf_GET(r) ((((r).e2econfig[0]) >> 1) & 0x1)
#define BCM56504_A0_E2ECONFIGr_XPORT24_SEND_E2E_IBPf_SET(r,f) (r).e2econfig[0]=(((r).e2econfig[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_E2ECONFIGr_XPORT25_SEND_E2E_IBPf_GET(r) ((((r).e2econfig[0]) >> 2) & 0x1)
#define BCM56504_A0_E2ECONFIGr_XPORT25_SEND_E2E_IBPf_SET(r,f) (r).e2econfig[0]=(((r).e2econfig[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_E2ECONFIGr_XPORT26_SEND_E2E_IBPf_GET(r) ((((r).e2econfig[0]) >> 3) & 0x1)
#define BCM56504_A0_E2ECONFIGr_XPORT26_SEND_E2E_IBPf_SET(r,f) (r).e2econfig[0]=(((r).e2econfig[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_E2ECONFIGr_XPORT27_SEND_E2E_IBPf_GET(r) ((((r).e2econfig[0]) >> 4) & 0x1)
#define BCM56504_A0_E2ECONFIGr_XPORT27_SEND_E2E_IBPf_SET(r,f) (r).e2econfig[0]=(((r).e2econfig[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56504_A0_E2ECONFIGr_E2E_HOL_ENf_GET(r) ((((r).e2econfig[0]) >> 5) & 0x1)
#define BCM56504_A0_E2ECONFIGr_E2E_HOL_ENf_SET(r,f) (r).e2econfig[0]=(((r).e2econfig[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56504_A0_E2ECONFIGr_XPORT24_SEND_E2E_HOLf_GET(r) ((((r).e2econfig[0]) >> 6) & 0x1)
#define BCM56504_A0_E2ECONFIGr_XPORT24_SEND_E2E_HOLf_SET(r,f) (r).e2econfig[0]=(((r).e2econfig[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56504_A0_E2ECONFIGr_XPORT25_SEND_E2E_HOLf_GET(r) ((((r).e2econfig[0]) >> 7) & 0x1)
#define BCM56504_A0_E2ECONFIGr_XPORT25_SEND_E2E_HOLf_SET(r,f) (r).e2econfig[0]=(((r).e2econfig[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56504_A0_E2ECONFIGr_XPORT26_SEND_E2E_HOLf_GET(r) ((((r).e2econfig[0]) >> 8) & 0x1)
#define BCM56504_A0_E2ECONFIGr_XPORT26_SEND_E2E_HOLf_SET(r,f) (r).e2econfig[0]=(((r).e2econfig[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56504_A0_E2ECONFIGr_XPORT27_SEND_E2E_HOLf_GET(r) ((((r).e2econfig[0]) >> 9) & 0x1)
#define BCM56504_A0_E2ECONFIGr_XPORT27_SEND_E2E_HOLf_SET(r,f) (r).e2econfig[0]=(((r).e2econfig[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56504_A0_E2ECONFIGr_E2E_MINTIMER_SELf_GET(r) ((((r).e2econfig[0]) >> 10) & 0xf)
#define BCM56504_A0_E2ECONFIGr_E2E_MINTIMER_SELf_SET(r,f) (r).e2econfig[0]=(((r).e2econfig[0] & ~((uint32_t)0xf << 10)) | ((((uint32_t)f) & 0xf) << 10))
#define BCM56504_A0_E2ECONFIGr_E2E_MAXTIMER_SELf_GET(r) ((((r).e2econfig[0]) >> 14) & 0xf)
#define BCM56504_A0_E2ECONFIGr_E2E_MAXTIMER_SELf_SET(r,f) (r).e2econfig[0]=(((r).e2econfig[0] & ~((uint32_t)0xf << 14)) | ((((uint32_t)f) & 0xf) << 14))
#define BCM56504_A0_E2ECONFIGr_REMOTE_SRCMODIDf_GET(r) ((((r).e2econfig[0]) >> 18) & 0x3f)
#define BCM56504_A0_E2ECONFIGr_REMOTE_SRCMODIDf_SET(r,f) (r).e2econfig[0]=(((r).e2econfig[0] & ~((uint32_t)0x3f << 18)) | ((((uint32_t)f) & 0x3f) << 18))
#define BCM56504_A0_E2ECONFIGr_SEND_RX_E2E_BKP_ENf_GET(r) ((((r).e2econfig[0]) >> 24) & 0x1)
#define BCM56504_A0_E2ECONFIGr_SEND_RX_E2E_BKP_ENf_SET(r,f) (r).e2econfig[0]=(((r).e2econfig[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))

/*
 * These macros can be used to access E2ECONFIG.
 *
 */
#define BCM56504_A0_READ_E2ECONFIGr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_E2ECONFIGr,(r._e2econfig))
#define BCM56504_A0_WRITE_E2ECONFIGr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_E2ECONFIGr,&(r._e2econfig))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define E2ECONFIGr BCM56504_A0_E2ECONFIGr
#define E2ECONFIGr_SIZE BCM56504_A0_E2ECONFIGr_SIZE
typedef BCM56504_A0_E2ECONFIGr_t E2ECONFIGr_t;
#define E2ECONFIGr_CLR BCM56504_A0_E2ECONFIGr_CLR
#define E2ECONFIGr_SET BCM56504_A0_E2ECONFIGr_SET
#define E2ECONFIGr_GET BCM56504_A0_E2ECONFIGr_GET
#define E2ECONFIGr_E2E_IBP_ENf_GET BCM56504_A0_E2ECONFIGr_E2E_IBP_ENf_GET
#define E2ECONFIGr_E2E_IBP_ENf_SET BCM56504_A0_E2ECONFIGr_E2E_IBP_ENf_SET
#define E2ECONFIGr_XPORT24_SEND_E2E_IBPf_GET BCM56504_A0_E2ECONFIGr_XPORT24_SEND_E2E_IBPf_GET
#define E2ECONFIGr_XPORT24_SEND_E2E_IBPf_SET BCM56504_A0_E2ECONFIGr_XPORT24_SEND_E2E_IBPf_SET
#define E2ECONFIGr_XPORT25_SEND_E2E_IBPf_GET BCM56504_A0_E2ECONFIGr_XPORT25_SEND_E2E_IBPf_GET
#define E2ECONFIGr_XPORT25_SEND_E2E_IBPf_SET BCM56504_A0_E2ECONFIGr_XPORT25_SEND_E2E_IBPf_SET
#define E2ECONFIGr_XPORT26_SEND_E2E_IBPf_GET BCM56504_A0_E2ECONFIGr_XPORT26_SEND_E2E_IBPf_GET
#define E2ECONFIGr_XPORT26_SEND_E2E_IBPf_SET BCM56504_A0_E2ECONFIGr_XPORT26_SEND_E2E_IBPf_SET
#define E2ECONFIGr_XPORT27_SEND_E2E_IBPf_GET BCM56504_A0_E2ECONFIGr_XPORT27_SEND_E2E_IBPf_GET
#define E2ECONFIGr_XPORT27_SEND_E2E_IBPf_SET BCM56504_A0_E2ECONFIGr_XPORT27_SEND_E2E_IBPf_SET
#define E2ECONFIGr_E2E_HOL_ENf_GET BCM56504_A0_E2ECONFIGr_E2E_HOL_ENf_GET
#define E2ECONFIGr_E2E_HOL_ENf_SET BCM56504_A0_E2ECONFIGr_E2E_HOL_ENf_SET
#define E2ECONFIGr_XPORT24_SEND_E2E_HOLf_GET BCM56504_A0_E2ECONFIGr_XPORT24_SEND_E2E_HOLf_GET
#define E2ECONFIGr_XPORT24_SEND_E2E_HOLf_SET BCM56504_A0_E2ECONFIGr_XPORT24_SEND_E2E_HOLf_SET
#define E2ECONFIGr_XPORT25_SEND_E2E_HOLf_GET BCM56504_A0_E2ECONFIGr_XPORT25_SEND_E2E_HOLf_GET
#define E2ECONFIGr_XPORT25_SEND_E2E_HOLf_SET BCM56504_A0_E2ECONFIGr_XPORT25_SEND_E2E_HOLf_SET
#define E2ECONFIGr_XPORT26_SEND_E2E_HOLf_GET BCM56504_A0_E2ECONFIGr_XPORT26_SEND_E2E_HOLf_GET
#define E2ECONFIGr_XPORT26_SEND_E2E_HOLf_SET BCM56504_A0_E2ECONFIGr_XPORT26_SEND_E2E_HOLf_SET
#define E2ECONFIGr_XPORT27_SEND_E2E_HOLf_GET BCM56504_A0_E2ECONFIGr_XPORT27_SEND_E2E_HOLf_GET
#define E2ECONFIGr_XPORT27_SEND_E2E_HOLf_SET BCM56504_A0_E2ECONFIGr_XPORT27_SEND_E2E_HOLf_SET
#define E2ECONFIGr_E2E_MINTIMER_SELf_GET BCM56504_A0_E2ECONFIGr_E2E_MINTIMER_SELf_GET
#define E2ECONFIGr_E2E_MINTIMER_SELf_SET BCM56504_A0_E2ECONFIGr_E2E_MINTIMER_SELf_SET
#define E2ECONFIGr_E2E_MAXTIMER_SELf_GET BCM56504_A0_E2ECONFIGr_E2E_MAXTIMER_SELf_GET
#define E2ECONFIGr_E2E_MAXTIMER_SELf_SET BCM56504_A0_E2ECONFIGr_E2E_MAXTIMER_SELf_SET
#define E2ECONFIGr_REMOTE_SRCMODIDf_GET BCM56504_A0_E2ECONFIGr_REMOTE_SRCMODIDf_GET
#define E2ECONFIGr_REMOTE_SRCMODIDf_SET BCM56504_A0_E2ECONFIGr_REMOTE_SRCMODIDf_SET
#define E2ECONFIGr_SEND_RX_E2E_BKP_ENf_GET BCM56504_A0_E2ECONFIGr_SEND_RX_E2E_BKP_ENf_GET
#define E2ECONFIGr_SEND_RX_E2E_BKP_ENf_SET BCM56504_A0_E2ECONFIGr_SEND_RX_E2E_BKP_ENf_SET
#define READ_E2ECONFIGr BCM56504_A0_READ_E2ECONFIGr
#define WRITE_E2ECONFIGr BCM56504_A0_WRITE_E2ECONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_E2ECONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  E2EIBPBKPSTATUS
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     PORT_BITMAP      Current E2E port Back Pressure warning status which is the summary of E2EIBPFC status from 3 remote module. To review status from individual source module, please read from registers E2EIBPFCBITMAP1, E2EIBPFCBITMAP2 or E2EIBPFCBITMAP3. 
 *
 ******************************************************************************/
#define BCM56504_A0_E2EIBPBKPSTATUSr 0x00680002

#define BCM56504_A0_E2EIBPBKPSTATUSr_SIZE 4

/*
 * This structure should be used to declare and program E2EIBPBKPSTATUS.
 *
 */
typedef union BCM56504_A0_E2EIBPBKPSTATUSr_s {
	uint32_t v[1];
	uint32_t e2eibpbkpstatus[1];
	uint32_t _e2eibpbkpstatus;
} BCM56504_A0_E2EIBPBKPSTATUSr_t;

#define BCM56504_A0_E2EIBPBKPSTATUSr_CLR(r) (r).e2eibpbkpstatus[0] = 0
#define BCM56504_A0_E2EIBPBKPSTATUSr_SET(r,d) (r).e2eibpbkpstatus[0] = d
#define BCM56504_A0_E2EIBPBKPSTATUSr_GET(r) (r).e2eibpbkpstatus[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_E2EIBPBKPSTATUSr_PORT_BITMAPf_GET(r) (((r).e2eibpbkpstatus[0]) & 0x1fffffff)
#define BCM56504_A0_E2EIBPBKPSTATUSr_PORT_BITMAPf_SET(r,f) (r).e2eibpbkpstatus[0]=(((r).e2eibpbkpstatus[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))

/*
 * These macros can be used to access E2EIBPBKPSTATUS.
 *
 */
#define BCM56504_A0_READ_E2EIBPBKPSTATUSr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_E2EIBPBKPSTATUSr,(r._e2eibpbkpstatus))
#define BCM56504_A0_WRITE_E2EIBPBKPSTATUSr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_E2EIBPBKPSTATUSr,&(r._e2eibpbkpstatus))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define E2EIBPBKPSTATUSr BCM56504_A0_E2EIBPBKPSTATUSr
#define E2EIBPBKPSTATUSr_SIZE BCM56504_A0_E2EIBPBKPSTATUSr_SIZE
typedef BCM56504_A0_E2EIBPBKPSTATUSr_t E2EIBPBKPSTATUSr_t;
#define E2EIBPBKPSTATUSr_CLR BCM56504_A0_E2EIBPBKPSTATUSr_CLR
#define E2EIBPBKPSTATUSr_SET BCM56504_A0_E2EIBPBKPSTATUSr_SET
#define E2EIBPBKPSTATUSr_GET BCM56504_A0_E2EIBPBKPSTATUSr_GET
#define E2EIBPBKPSTATUSr_PORT_BITMAPf_GET BCM56504_A0_E2EIBPBKPSTATUSr_PORT_BITMAPf_GET
#define E2EIBPBKPSTATUSr_PORT_BITMAPf_SET BCM56504_A0_E2EIBPBKPSTATUSr_PORT_BITMAPf_SET
#define READ_E2EIBPBKPSTATUSr BCM56504_A0_READ_E2EIBPBKPSTATUSr
#define WRITE_E2EIBPBKPSTATUSr BCM56504_A0_WRITE_E2EIBPBKPSTATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_E2EIBPBKPSTATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  E2EIBPCELLCOUNT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CELLCOUNT        Ingress cell count for all remote ports in remote module.Number of cells stored per ingress port.
 *
 ******************************************************************************/
#define BCM56504_A0_E2EIBPCELLCOUNTr 0x00600009

#define BCM56504_A0_E2EIBPCELLCOUNTr_SIZE 4

/*
 * This structure should be used to declare and program E2EIBPCELLCOUNT.
 *
 */
typedef union BCM56504_A0_E2EIBPCELLCOUNTr_s {
	uint32_t v[1];
	uint32_t e2eibpcellcount[1];
	uint32_t _e2eibpcellcount;
} BCM56504_A0_E2EIBPCELLCOUNTr_t;

#define BCM56504_A0_E2EIBPCELLCOUNTr_CLR(r) (r).e2eibpcellcount[0] = 0
#define BCM56504_A0_E2EIBPCELLCOUNTr_SET(r,d) (r).e2eibpcellcount[0] = d
#define BCM56504_A0_E2EIBPCELLCOUNTr_GET(r) (r).e2eibpcellcount[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_E2EIBPCELLCOUNTr_CELLCOUNTf_GET(r) (((r).e2eibpcellcount[0]) & 0x3fff)
#define BCM56504_A0_E2EIBPCELLCOUNTr_CELLCOUNTf_SET(r,f) (r).e2eibpcellcount[0]=(((r).e2eibpcellcount[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access E2EIBPCELLCOUNT.
 *
 */
#define BCM56504_A0_READ_E2EIBPCELLCOUNTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_E2EIBPCELLCOUNTr,(r._e2eibpcellcount))
#define BCM56504_A0_WRITE_E2EIBPCELLCOUNTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_E2EIBPCELLCOUNTr,&(r._e2eibpcellcount))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define E2EIBPCELLCOUNTr BCM56504_A0_E2EIBPCELLCOUNTr
#define E2EIBPCELLCOUNTr_SIZE BCM56504_A0_E2EIBPCELLCOUNTr_SIZE
typedef BCM56504_A0_E2EIBPCELLCOUNTr_t E2EIBPCELLCOUNTr_t;
#define E2EIBPCELLCOUNTr_CLR BCM56504_A0_E2EIBPCELLCOUNTr_CLR
#define E2EIBPCELLCOUNTr_SET BCM56504_A0_E2EIBPCELLCOUNTr_SET
#define E2EIBPCELLCOUNTr_GET BCM56504_A0_E2EIBPCELLCOUNTr_GET
#define E2EIBPCELLCOUNTr_CELLCOUNTf_GET BCM56504_A0_E2EIBPCELLCOUNTr_CELLCOUNTf_GET
#define E2EIBPCELLCOUNTr_CELLCOUNTf_SET BCM56504_A0_E2EIBPCELLCOUNTr_CELLCOUNTf_SET
#define READ_E2EIBPCELLCOUNTr BCM56504_A0_READ_E2EIBPCELLCOUNTr
#define WRITE_E2EIBPCELLCOUNTr BCM56504_A0_WRITE_E2EIBPCELLCOUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_E2EIBPCELLCOUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  E2EIBPCELLSETLIMIT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CELLSETLIMIT     Back Pressure cell high threshold for all remote ports in remote module. Unit is the number of cells per port.
 *     RESETLIMITSEL    E2E IBP Flow Control Cell Reset Threshold for all remote ingress ports.When Back pressure status is set, packet counts have to fall below Reset Threshold in order to clear BKP status. 2'b00: 75.0% of E2E IBP Cell Set Limit.2'b01: 50.0% of E2E IBP Cell Set Limit.    2'b10: 25.0% of E2E IBP Cell Set Limit.    2'b11: 12.5% of E2E IBP Cell Set Limit.    
 *
 ******************************************************************************/
#define BCM56504_A0_E2EIBPCELLSETLIMITr 0x00600007

#define BCM56504_A0_E2EIBPCELLSETLIMITr_SIZE 4

/*
 * This structure should be used to declare and program E2EIBPCELLSETLIMIT.
 *
 */
typedef union BCM56504_A0_E2EIBPCELLSETLIMITr_s {
	uint32_t v[1];
	uint32_t e2eibpcellsetlimit[1];
	uint32_t _e2eibpcellsetlimit;
} BCM56504_A0_E2EIBPCELLSETLIMITr_t;

#define BCM56504_A0_E2EIBPCELLSETLIMITr_CLR(r) (r).e2eibpcellsetlimit[0] = 0
#define BCM56504_A0_E2EIBPCELLSETLIMITr_SET(r,d) (r).e2eibpcellsetlimit[0] = d
#define BCM56504_A0_E2EIBPCELLSETLIMITr_GET(r) (r).e2eibpcellsetlimit[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_E2EIBPCELLSETLIMITr_CELLSETLIMITf_GET(r) (((r).e2eibpcellsetlimit[0]) & 0x3fff)
#define BCM56504_A0_E2EIBPCELLSETLIMITr_CELLSETLIMITf_SET(r,f) (r).e2eibpcellsetlimit[0]=(((r).e2eibpcellsetlimit[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM56504_A0_E2EIBPCELLSETLIMITr_RESETLIMITSELf_GET(r) ((((r).e2eibpcellsetlimit[0]) >> 14) & 0x3)
#define BCM56504_A0_E2EIBPCELLSETLIMITr_RESETLIMITSELf_SET(r,f) (r).e2eibpcellsetlimit[0]=(((r).e2eibpcellsetlimit[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))

/*
 * These macros can be used to access E2EIBPCELLSETLIMIT.
 *
 */
#define BCM56504_A0_READ_E2EIBPCELLSETLIMITr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_E2EIBPCELLSETLIMITr,(r._e2eibpcellsetlimit))
#define BCM56504_A0_WRITE_E2EIBPCELLSETLIMITr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_E2EIBPCELLSETLIMITr,&(r._e2eibpcellsetlimit))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define E2EIBPCELLSETLIMITr BCM56504_A0_E2EIBPCELLSETLIMITr
#define E2EIBPCELLSETLIMITr_SIZE BCM56504_A0_E2EIBPCELLSETLIMITr_SIZE
typedef BCM56504_A0_E2EIBPCELLSETLIMITr_t E2EIBPCELLSETLIMITr_t;
#define E2EIBPCELLSETLIMITr_CLR BCM56504_A0_E2EIBPCELLSETLIMITr_CLR
#define E2EIBPCELLSETLIMITr_SET BCM56504_A0_E2EIBPCELLSETLIMITr_SET
#define E2EIBPCELLSETLIMITr_GET BCM56504_A0_E2EIBPCELLSETLIMITr_GET
#define E2EIBPCELLSETLIMITr_CELLSETLIMITf_GET BCM56504_A0_E2EIBPCELLSETLIMITr_CELLSETLIMITf_GET
#define E2EIBPCELLSETLIMITr_CELLSETLIMITf_SET BCM56504_A0_E2EIBPCELLSETLIMITr_CELLSETLIMITf_SET
#define E2EIBPCELLSETLIMITr_RESETLIMITSELf_GET BCM56504_A0_E2EIBPCELLSETLIMITr_RESETLIMITSELf_GET
#define E2EIBPCELLSETLIMITr_RESETLIMITSELf_SET BCM56504_A0_E2EIBPCELLSETLIMITr_RESETLIMITSELf_SET
#define READ_E2EIBPCELLSETLIMITr BCM56504_A0_READ_E2EIBPCELLSETLIMITr
#define WRITE_E2EIBPCELLSETLIMITr BCM56504_A0_WRITE_E2EIBPCELLSETLIMITr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_E2EIBPCELLSETLIMITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  E2EIBPDISCARDSETLIMIT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     DISCARDSETLIMIT  E2E IBP Flow Control Discard Threshold for all local ingress ports cell counts.When an ingress port\'s cell count is above Discard Set Limit, all of incoming packet from this port are discarded. Discard Limit must be set above than IBPCELLSETLIMIT to prevent unexpected behavior. This limit represents an absolute value and is not related to E2EIBPCELLSETLIMIT. Unit is the number of cells per port.
 *
 ******************************************************************************/
#define BCM56504_A0_E2EIBPDISCARDSETLIMITr 0x00600008

#define BCM56504_A0_E2EIBPDISCARDSETLIMITr_SIZE 4

/*
 * This structure should be used to declare and program E2EIBPDISCARDSETLIMIT.
 *
 */
typedef union BCM56504_A0_E2EIBPDISCARDSETLIMITr_s {
	uint32_t v[1];
	uint32_t e2eibpdiscardsetlimit[1];
	uint32_t _e2eibpdiscardsetlimit;
} BCM56504_A0_E2EIBPDISCARDSETLIMITr_t;

#define BCM56504_A0_E2EIBPDISCARDSETLIMITr_CLR(r) (r).e2eibpdiscardsetlimit[0] = 0
#define BCM56504_A0_E2EIBPDISCARDSETLIMITr_SET(r,d) (r).e2eibpdiscardsetlimit[0] = d
#define BCM56504_A0_E2EIBPDISCARDSETLIMITr_GET(r) (r).e2eibpdiscardsetlimit[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_E2EIBPDISCARDSETLIMITr_DISCARDSETLIMITf_GET(r) (((r).e2eibpdiscardsetlimit[0]) & 0x3fff)
#define BCM56504_A0_E2EIBPDISCARDSETLIMITr_DISCARDSETLIMITf_SET(r,f) (r).e2eibpdiscardsetlimit[0]=(((r).e2eibpdiscardsetlimit[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access E2EIBPDISCARDSETLIMIT.
 *
 */
#define BCM56504_A0_READ_E2EIBPDISCARDSETLIMITr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_E2EIBPDISCARDSETLIMITr,(r._e2eibpdiscardsetlimit))
#define BCM56504_A0_WRITE_E2EIBPDISCARDSETLIMITr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_E2EIBPDISCARDSETLIMITr,&(r._e2eibpdiscardsetlimit))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define E2EIBPDISCARDSETLIMITr BCM56504_A0_E2EIBPDISCARDSETLIMITr
#define E2EIBPDISCARDSETLIMITr_SIZE BCM56504_A0_E2EIBPDISCARDSETLIMITr_SIZE
typedef BCM56504_A0_E2EIBPDISCARDSETLIMITr_t E2EIBPDISCARDSETLIMITr_t;
#define E2EIBPDISCARDSETLIMITr_CLR BCM56504_A0_E2EIBPDISCARDSETLIMITr_CLR
#define E2EIBPDISCARDSETLIMITr_SET BCM56504_A0_E2EIBPDISCARDSETLIMITr_SET
#define E2EIBPDISCARDSETLIMITr_GET BCM56504_A0_E2EIBPDISCARDSETLIMITr_GET
#define E2EIBPDISCARDSETLIMITr_DISCARDSETLIMITf_GET BCM56504_A0_E2EIBPDISCARDSETLIMITr_DISCARDSETLIMITf_GET
#define E2EIBPDISCARDSETLIMITr_DISCARDSETLIMITf_SET BCM56504_A0_E2EIBPDISCARDSETLIMITr_DISCARDSETLIMITf_SET
#define READ_E2EIBPDISCARDSETLIMITr BCM56504_A0_READ_E2EIBPDISCARDSETLIMITr
#define WRITE_E2EIBPDISCARDSETLIMITr BCM56504_A0_WRITE_E2EIBPDISCARDSETLIMITr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_E2EIBPDISCARDSETLIMITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  E2EIBPDISCSTATUS
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     PORT_BITMAP      Current E2E IBP discard status
 *
 ******************************************************************************/
#define BCM56504_A0_E2EIBPDISCSTATUSr 0x00680005

#define BCM56504_A0_E2EIBPDISCSTATUSr_SIZE 4

/*
 * This structure should be used to declare and program E2EIBPDISCSTATUS.
 *
 */
typedef union BCM56504_A0_E2EIBPDISCSTATUSr_s {
	uint32_t v[1];
	uint32_t e2eibpdiscstatus[1];
	uint32_t _e2eibpdiscstatus;
} BCM56504_A0_E2EIBPDISCSTATUSr_t;

#define BCM56504_A0_E2EIBPDISCSTATUSr_CLR(r) (r).e2eibpdiscstatus[0] = 0
#define BCM56504_A0_E2EIBPDISCSTATUSr_SET(r,d) (r).e2eibpdiscstatus[0] = d
#define BCM56504_A0_E2EIBPDISCSTATUSr_GET(r) (r).e2eibpdiscstatus[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_E2EIBPDISCSTATUSr_PORT_BITMAPf_GET(r) (((r).e2eibpdiscstatus[0]) & 0x1fffffff)
#define BCM56504_A0_E2EIBPDISCSTATUSr_PORT_BITMAPf_SET(r,f) (r).e2eibpdiscstatus[0]=(((r).e2eibpdiscstatus[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))

/*
 * These macros can be used to access E2EIBPDISCSTATUS.
 *
 */
#define BCM56504_A0_READ_E2EIBPDISCSTATUSr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_E2EIBPDISCSTATUSr,(r._e2eibpdiscstatus))
#define BCM56504_A0_WRITE_E2EIBPDISCSTATUSr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_E2EIBPDISCSTATUSr,&(r._e2eibpdiscstatus))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define E2EIBPDISCSTATUSr BCM56504_A0_E2EIBPDISCSTATUSr
#define E2EIBPDISCSTATUSr_SIZE BCM56504_A0_E2EIBPDISCSTATUSr_SIZE
typedef BCM56504_A0_E2EIBPDISCSTATUSr_t E2EIBPDISCSTATUSr_t;
#define E2EIBPDISCSTATUSr_CLR BCM56504_A0_E2EIBPDISCSTATUSr_CLR
#define E2EIBPDISCSTATUSr_SET BCM56504_A0_E2EIBPDISCSTATUSr_SET
#define E2EIBPDISCSTATUSr_GET BCM56504_A0_E2EIBPDISCSTATUSr_GET
#define E2EIBPDISCSTATUSr_PORT_BITMAPf_GET BCM56504_A0_E2EIBPDISCSTATUSr_PORT_BITMAPf_GET
#define E2EIBPDISCSTATUSr_PORT_BITMAPf_SET BCM56504_A0_E2EIBPDISCSTATUSr_PORT_BITMAPf_SET
#define READ_E2EIBPDISCSTATUSr BCM56504_A0_READ_E2EIBPDISCSTATUSr
#define WRITE_E2EIBPDISCSTATUSr BCM56504_A0_WRITE_E2EIBPDISCSTATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_E2EIBPDISCSTATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  E2EIBPPKTCOUNT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     PKTCOUNT         Ingress packet count for all remote ports in remote module.Number of packets stored per ingress port.
 *
 ******************************************************************************/
#define BCM56504_A0_E2EIBPPKTCOUNTr 0x00600006

#define BCM56504_A0_E2EIBPPKTCOUNTr_SIZE 4

/*
 * This structure should be used to declare and program E2EIBPPKTCOUNT.
 *
 */
typedef union BCM56504_A0_E2EIBPPKTCOUNTr_s {
	uint32_t v[1];
	uint32_t e2eibppktcount[1];
	uint32_t _e2eibppktcount;
} BCM56504_A0_E2EIBPPKTCOUNTr_t;

#define BCM56504_A0_E2EIBPPKTCOUNTr_CLR(r) (r).e2eibppktcount[0] = 0
#define BCM56504_A0_E2EIBPPKTCOUNTr_SET(r,d) (r).e2eibppktcount[0] = d
#define BCM56504_A0_E2EIBPPKTCOUNTr_GET(r) (r).e2eibppktcount[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_E2EIBPPKTCOUNTr_PKTCOUNTf_GET(r) (((r).e2eibppktcount[0]) & 0x3fff)
#define BCM56504_A0_E2EIBPPKTCOUNTr_PKTCOUNTf_SET(r,f) (r).e2eibppktcount[0]=(((r).e2eibppktcount[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access E2EIBPPKTCOUNT.
 *
 */
#define BCM56504_A0_READ_E2EIBPPKTCOUNTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_E2EIBPPKTCOUNTr,(r._e2eibppktcount))
#define BCM56504_A0_WRITE_E2EIBPPKTCOUNTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_E2EIBPPKTCOUNTr,&(r._e2eibppktcount))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define E2EIBPPKTCOUNTr BCM56504_A0_E2EIBPPKTCOUNTr
#define E2EIBPPKTCOUNTr_SIZE BCM56504_A0_E2EIBPPKTCOUNTr_SIZE
typedef BCM56504_A0_E2EIBPPKTCOUNTr_t E2EIBPPKTCOUNTr_t;
#define E2EIBPPKTCOUNTr_CLR BCM56504_A0_E2EIBPPKTCOUNTr_CLR
#define E2EIBPPKTCOUNTr_SET BCM56504_A0_E2EIBPPKTCOUNTr_SET
#define E2EIBPPKTCOUNTr_GET BCM56504_A0_E2EIBPPKTCOUNTr_GET
#define E2EIBPPKTCOUNTr_PKTCOUNTf_GET BCM56504_A0_E2EIBPPKTCOUNTr_PKTCOUNTf_GET
#define E2EIBPPKTCOUNTr_PKTCOUNTf_SET BCM56504_A0_E2EIBPPKTCOUNTr_PKTCOUNTf_SET
#define READ_E2EIBPPKTCOUNTr BCM56504_A0_READ_E2EIBPPKTCOUNTr
#define WRITE_E2EIBPPKTCOUNTr BCM56504_A0_WRITE_E2EIBPPKTCOUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_E2EIBPPKTCOUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  E2EIBPPKTSETLIMIT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     PKTSETLIMIT      Back Pressure packet high threshold for all remote ports in remote module. Unit is the number of packets per port.
 *     RESETLIMITSEL    E2E IBP Flow Control Packet Reset Threshold for all remote ingress ports.When Back pressure status is set, packet counts have to fall below Reset Threshold in order to clear BKP status. 2'b00: 75.0% of E2E IBP packet Set Limit.2'b01: 50.0% of E2E IBP packet Set Limit.    2'b10: 25.0% of E2E IBP packet Set Limit.    2'b11: 12.5% of E2E IBP packet Set Limit.    
 *
 ******************************************************************************/
#define BCM56504_A0_E2EIBPPKTSETLIMITr 0x00600005

#define BCM56504_A0_E2EIBPPKTSETLIMITr_SIZE 4

/*
 * This structure should be used to declare and program E2EIBPPKTSETLIMIT.
 *
 */
typedef union BCM56504_A0_E2EIBPPKTSETLIMITr_s {
	uint32_t v[1];
	uint32_t e2eibppktsetlimit[1];
	uint32_t _e2eibppktsetlimit;
} BCM56504_A0_E2EIBPPKTSETLIMITr_t;

#define BCM56504_A0_E2EIBPPKTSETLIMITr_CLR(r) (r).e2eibppktsetlimit[0] = 0
#define BCM56504_A0_E2EIBPPKTSETLIMITr_SET(r,d) (r).e2eibppktsetlimit[0] = d
#define BCM56504_A0_E2EIBPPKTSETLIMITr_GET(r) (r).e2eibppktsetlimit[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_E2EIBPPKTSETLIMITr_PKTSETLIMITf_GET(r) (((r).e2eibppktsetlimit[0]) & 0x3fff)
#define BCM56504_A0_E2EIBPPKTSETLIMITr_PKTSETLIMITf_SET(r,f) (r).e2eibppktsetlimit[0]=(((r).e2eibppktsetlimit[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM56504_A0_E2EIBPPKTSETLIMITr_RESETLIMITSELf_GET(r) ((((r).e2eibppktsetlimit[0]) >> 14) & 0x3)
#define BCM56504_A0_E2EIBPPKTSETLIMITr_RESETLIMITSELf_SET(r,f) (r).e2eibppktsetlimit[0]=(((r).e2eibppktsetlimit[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))

/*
 * These macros can be used to access E2EIBPPKTSETLIMIT.
 *
 */
#define BCM56504_A0_READ_E2EIBPPKTSETLIMITr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_E2EIBPPKTSETLIMITr,(r._e2eibppktsetlimit))
#define BCM56504_A0_WRITE_E2EIBPPKTSETLIMITr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_E2EIBPPKTSETLIMITr,&(r._e2eibppktsetlimit))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define E2EIBPPKTSETLIMITr BCM56504_A0_E2EIBPPKTSETLIMITr
#define E2EIBPPKTSETLIMITr_SIZE BCM56504_A0_E2EIBPPKTSETLIMITr_SIZE
typedef BCM56504_A0_E2EIBPPKTSETLIMITr_t E2EIBPPKTSETLIMITr_t;
#define E2EIBPPKTSETLIMITr_CLR BCM56504_A0_E2EIBPPKTSETLIMITr_CLR
#define E2EIBPPKTSETLIMITr_SET BCM56504_A0_E2EIBPPKTSETLIMITr_SET
#define E2EIBPPKTSETLIMITr_GET BCM56504_A0_E2EIBPPKTSETLIMITr_GET
#define E2EIBPPKTSETLIMITr_PKTSETLIMITf_GET BCM56504_A0_E2EIBPPKTSETLIMITr_PKTSETLIMITf_GET
#define E2EIBPPKTSETLIMITr_PKTSETLIMITf_SET BCM56504_A0_E2EIBPPKTSETLIMITr_PKTSETLIMITf_SET
#define E2EIBPPKTSETLIMITr_RESETLIMITSELf_GET BCM56504_A0_E2EIBPPKTSETLIMITr_RESETLIMITSELf_GET
#define E2EIBPPKTSETLIMITr_RESETLIMITSELf_SET BCM56504_A0_E2EIBPPKTSETLIMITr_RESETLIMITSELf_SET
#define READ_E2EIBPPKTSETLIMITr BCM56504_A0_READ_E2EIBPPKTSETLIMITr
#define WRITE_E2EIBPPKTSETLIMITr BCM56504_A0_WRITE_E2EIBPPKTSETLIMITr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_E2EIBPPKTSETLIMITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  E2E_HOL_RX_DA_LS
 * BLOCKS:   IPIPE_HI
 * DESC:     End-to-End HOL LSB DA Register
 * SIZE:     32
 * FIELDS:
 *     DA               Least significant 16-bits of the DA for receive E2E HOL messages
 *
 ******************************************************************************/
#define BCM56504_A0_E2E_HOL_RX_DA_LSr 0x02880001

#define BCM56504_A0_E2E_HOL_RX_DA_LSr_SIZE 4

/*
 * This structure should be used to declare and program E2E_HOL_RX_DA_LS.
 *
 */
typedef union BCM56504_A0_E2E_HOL_RX_DA_LSr_s {
	uint32_t v[1];
	uint32_t e2e_hol_rx_da_ls[1];
	uint32_t _e2e_hol_rx_da_ls;
} BCM56504_A0_E2E_HOL_RX_DA_LSr_t;

#define BCM56504_A0_E2E_HOL_RX_DA_LSr_CLR(r) (r).e2e_hol_rx_da_ls[0] = 0
#define BCM56504_A0_E2E_HOL_RX_DA_LSr_SET(r,d) (r).e2e_hol_rx_da_ls[0] = d
#define BCM56504_A0_E2E_HOL_RX_DA_LSr_GET(r) (r).e2e_hol_rx_da_ls[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_E2E_HOL_RX_DA_LSr_DAf_GET(r) ((r).e2e_hol_rx_da_ls[0])
#define BCM56504_A0_E2E_HOL_RX_DA_LSr_DAf_SET(r,f) (r).e2e_hol_rx_da_ls[0]=((uint32_t)f)

/*
 * These macros can be used to access E2E_HOL_RX_DA_LS.
 *
 */
#define BCM56504_A0_READ_E2E_HOL_RX_DA_LSr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_E2E_HOL_RX_DA_LSr,(r._e2e_hol_rx_da_ls))
#define BCM56504_A0_WRITE_E2E_HOL_RX_DA_LSr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_E2E_HOL_RX_DA_LSr,&(r._e2e_hol_rx_da_ls))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define E2E_HOL_RX_DA_LSr BCM56504_A0_E2E_HOL_RX_DA_LSr
#define E2E_HOL_RX_DA_LSr_SIZE BCM56504_A0_E2E_HOL_RX_DA_LSr_SIZE
typedef BCM56504_A0_E2E_HOL_RX_DA_LSr_t E2E_HOL_RX_DA_LSr_t;
#define E2E_HOL_RX_DA_LSr_CLR BCM56504_A0_E2E_HOL_RX_DA_LSr_CLR
#define E2E_HOL_RX_DA_LSr_SET BCM56504_A0_E2E_HOL_RX_DA_LSr_SET
#define E2E_HOL_RX_DA_LSr_GET BCM56504_A0_E2E_HOL_RX_DA_LSr_GET
#define E2E_HOL_RX_DA_LSr_DAf_GET BCM56504_A0_E2E_HOL_RX_DA_LSr_DAf_GET
#define E2E_HOL_RX_DA_LSr_DAf_SET BCM56504_A0_E2E_HOL_RX_DA_LSr_DAf_SET
#define READ_E2E_HOL_RX_DA_LSr BCM56504_A0_READ_E2E_HOL_RX_DA_LSr
#define WRITE_E2E_HOL_RX_DA_LSr BCM56504_A0_WRITE_E2E_HOL_RX_DA_LSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_E2E_HOL_RX_DA_LSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  E2E_HOL_RX_DA_MS
 * BLOCKS:   IPIPE_HI
 * DESC:     End-to-End HOL MSB DA Register
 * SIZE:     32
 * FIELDS:
 *     DA               Most significant 16-bits of the DA for receive E2E HOL messages
 *
 ******************************************************************************/
#define BCM56504_A0_E2E_HOL_RX_DA_MSr 0x02880000

#define BCM56504_A0_E2E_HOL_RX_DA_MSr_SIZE 4

/*
 * This structure should be used to declare and program E2E_HOL_RX_DA_MS.
 *
 */
typedef union BCM56504_A0_E2E_HOL_RX_DA_MSr_s {
	uint32_t v[1];
	uint32_t e2e_hol_rx_da_ms[1];
	uint32_t _e2e_hol_rx_da_ms;
} BCM56504_A0_E2E_HOL_RX_DA_MSr_t;

#define BCM56504_A0_E2E_HOL_RX_DA_MSr_CLR(r) (r).e2e_hol_rx_da_ms[0] = 0
#define BCM56504_A0_E2E_HOL_RX_DA_MSr_SET(r,d) (r).e2e_hol_rx_da_ms[0] = d
#define BCM56504_A0_E2E_HOL_RX_DA_MSr_GET(r) (r).e2e_hol_rx_da_ms[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_E2E_HOL_RX_DA_MSr_DAf_GET(r) (((r).e2e_hol_rx_da_ms[0]) & 0xffff)
#define BCM56504_A0_E2E_HOL_RX_DA_MSr_DAf_SET(r,f) (r).e2e_hol_rx_da_ms[0]=(((r).e2e_hol_rx_da_ms[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access E2E_HOL_RX_DA_MS.
 *
 */
#define BCM56504_A0_READ_E2E_HOL_RX_DA_MSr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_E2E_HOL_RX_DA_MSr,(r._e2e_hol_rx_da_ms))
#define BCM56504_A0_WRITE_E2E_HOL_RX_DA_MSr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_E2E_HOL_RX_DA_MSr,&(r._e2e_hol_rx_da_ms))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define E2E_HOL_RX_DA_MSr BCM56504_A0_E2E_HOL_RX_DA_MSr
#define E2E_HOL_RX_DA_MSr_SIZE BCM56504_A0_E2E_HOL_RX_DA_MSr_SIZE
typedef BCM56504_A0_E2E_HOL_RX_DA_MSr_t E2E_HOL_RX_DA_MSr_t;
#define E2E_HOL_RX_DA_MSr_CLR BCM56504_A0_E2E_HOL_RX_DA_MSr_CLR
#define E2E_HOL_RX_DA_MSr_SET BCM56504_A0_E2E_HOL_RX_DA_MSr_SET
#define E2E_HOL_RX_DA_MSr_GET BCM56504_A0_E2E_HOL_RX_DA_MSr_GET
#define E2E_HOL_RX_DA_MSr_DAf_GET BCM56504_A0_E2E_HOL_RX_DA_MSr_DAf_GET
#define E2E_HOL_RX_DA_MSr_DAf_SET BCM56504_A0_E2E_HOL_RX_DA_MSr_DAf_SET
#define READ_E2E_HOL_RX_DA_MSr BCM56504_A0_READ_E2E_HOL_RX_DA_MSr
#define WRITE_E2E_HOL_RX_DA_MSr BCM56504_A0_WRITE_E2E_HOL_RX_DA_MSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_E2E_HOL_RX_DA_MSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  E2E_HOL_RX_LENGTH_TYPE
 * BLOCKS:   IPIPE_HI
 * DESC:     End-to-End HOL Length/Type Register
 * SIZE:     32
 * FIELDS:
 *     LENGTH_TYPE      Length/Type Field for receive E2E HOL messages
 *
 ******************************************************************************/
#define BCM56504_A0_E2E_HOL_RX_LENGTH_TYPEr 0x02880002

#define BCM56504_A0_E2E_HOL_RX_LENGTH_TYPEr_SIZE 4

/*
 * This structure should be used to declare and program E2E_HOL_RX_LENGTH_TYPE.
 *
 */
typedef union BCM56504_A0_E2E_HOL_RX_LENGTH_TYPEr_s {
	uint32_t v[1];
	uint32_t e2e_hol_rx_length_type[1];
	uint32_t _e2e_hol_rx_length_type;
} BCM56504_A0_E2E_HOL_RX_LENGTH_TYPEr_t;

#define BCM56504_A0_E2E_HOL_RX_LENGTH_TYPEr_CLR(r) (r).e2e_hol_rx_length_type[0] = 0
#define BCM56504_A0_E2E_HOL_RX_LENGTH_TYPEr_SET(r,d) (r).e2e_hol_rx_length_type[0] = d
#define BCM56504_A0_E2E_HOL_RX_LENGTH_TYPEr_GET(r) (r).e2e_hol_rx_length_type[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_E2E_HOL_RX_LENGTH_TYPEr_LENGTH_TYPEf_GET(r) (((r).e2e_hol_rx_length_type[0]) & 0xffff)
#define BCM56504_A0_E2E_HOL_RX_LENGTH_TYPEr_LENGTH_TYPEf_SET(r,f) (r).e2e_hol_rx_length_type[0]=(((r).e2e_hol_rx_length_type[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access E2E_HOL_RX_LENGTH_TYPE.
 *
 */
#define BCM56504_A0_READ_E2E_HOL_RX_LENGTH_TYPEr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_E2E_HOL_RX_LENGTH_TYPEr,(r._e2e_hol_rx_length_type))
#define BCM56504_A0_WRITE_E2E_HOL_RX_LENGTH_TYPEr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_E2E_HOL_RX_LENGTH_TYPEr,&(r._e2e_hol_rx_length_type))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define E2E_HOL_RX_LENGTH_TYPEr BCM56504_A0_E2E_HOL_RX_LENGTH_TYPEr
#define E2E_HOL_RX_LENGTH_TYPEr_SIZE BCM56504_A0_E2E_HOL_RX_LENGTH_TYPEr_SIZE
typedef BCM56504_A0_E2E_HOL_RX_LENGTH_TYPEr_t E2E_HOL_RX_LENGTH_TYPEr_t;
#define E2E_HOL_RX_LENGTH_TYPEr_CLR BCM56504_A0_E2E_HOL_RX_LENGTH_TYPEr_CLR
#define E2E_HOL_RX_LENGTH_TYPEr_SET BCM56504_A0_E2E_HOL_RX_LENGTH_TYPEr_SET
#define E2E_HOL_RX_LENGTH_TYPEr_GET BCM56504_A0_E2E_HOL_RX_LENGTH_TYPEr_GET
#define E2E_HOL_RX_LENGTH_TYPEr_LENGTH_TYPEf_GET BCM56504_A0_E2E_HOL_RX_LENGTH_TYPEr_LENGTH_TYPEf_GET
#define E2E_HOL_RX_LENGTH_TYPEr_LENGTH_TYPEf_SET BCM56504_A0_E2E_HOL_RX_LENGTH_TYPEr_LENGTH_TYPEf_SET
#define READ_E2E_HOL_RX_LENGTH_TYPEr BCM56504_A0_READ_E2E_HOL_RX_LENGTH_TYPEr
#define WRITE_E2E_HOL_RX_LENGTH_TYPEr BCM56504_A0_WRITE_E2E_HOL_RX_LENGTH_TYPEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_E2E_HOL_RX_LENGTH_TYPEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  E2E_HOL_RX_OPCODE
 * BLOCKS:   IPIPE_HI
 * DESC:     End-to-End HOL Opcode Register
 * SIZE:     32
 * FIELDS:
 *     OPCODE           Opcode Field for receive E2E HOL messages
 *
 ******************************************************************************/
#define BCM56504_A0_E2E_HOL_RX_OPCODEr 0x02880003

#define BCM56504_A0_E2E_HOL_RX_OPCODEr_SIZE 4

/*
 * This structure should be used to declare and program E2E_HOL_RX_OPCODE.
 *
 */
typedef union BCM56504_A0_E2E_HOL_RX_OPCODEr_s {
	uint32_t v[1];
	uint32_t e2e_hol_rx_opcode[1];
	uint32_t _e2e_hol_rx_opcode;
} BCM56504_A0_E2E_HOL_RX_OPCODEr_t;

#define BCM56504_A0_E2E_HOL_RX_OPCODEr_CLR(r) (r).e2e_hol_rx_opcode[0] = 0
#define BCM56504_A0_E2E_HOL_RX_OPCODEr_SET(r,d) (r).e2e_hol_rx_opcode[0] = d
#define BCM56504_A0_E2E_HOL_RX_OPCODEr_GET(r) (r).e2e_hol_rx_opcode[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_E2E_HOL_RX_OPCODEr_OPCODEf_GET(r) (((r).e2e_hol_rx_opcode[0]) & 0xffff)
#define BCM56504_A0_E2E_HOL_RX_OPCODEr_OPCODEf_SET(r,f) (r).e2e_hol_rx_opcode[0]=(((r).e2e_hol_rx_opcode[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access E2E_HOL_RX_OPCODE.
 *
 */
#define BCM56504_A0_READ_E2E_HOL_RX_OPCODEr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_E2E_HOL_RX_OPCODEr,(r._e2e_hol_rx_opcode))
#define BCM56504_A0_WRITE_E2E_HOL_RX_OPCODEr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_E2E_HOL_RX_OPCODEr,&(r._e2e_hol_rx_opcode))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define E2E_HOL_RX_OPCODEr BCM56504_A0_E2E_HOL_RX_OPCODEr
#define E2E_HOL_RX_OPCODEr_SIZE BCM56504_A0_E2E_HOL_RX_OPCODEr_SIZE
typedef BCM56504_A0_E2E_HOL_RX_OPCODEr_t E2E_HOL_RX_OPCODEr_t;
#define E2E_HOL_RX_OPCODEr_CLR BCM56504_A0_E2E_HOL_RX_OPCODEr_CLR
#define E2E_HOL_RX_OPCODEr_SET BCM56504_A0_E2E_HOL_RX_OPCODEr_SET
#define E2E_HOL_RX_OPCODEr_GET BCM56504_A0_E2E_HOL_RX_OPCODEr_GET
#define E2E_HOL_RX_OPCODEr_OPCODEf_GET BCM56504_A0_E2E_HOL_RX_OPCODEr_OPCODEf_GET
#define E2E_HOL_RX_OPCODEr_OPCODEf_SET BCM56504_A0_E2E_HOL_RX_OPCODEr_OPCODEf_SET
#define READ_E2E_HOL_RX_OPCODEr BCM56504_A0_READ_E2E_HOL_RX_OPCODEr
#define WRITE_E2E_HOL_RX_OPCODEr BCM56504_A0_WRITE_E2E_HOL_RX_OPCODEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_E2E_HOL_RX_OPCODEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  E2E_HOL_STATUS
 * BLOCKS:   IPIPE
 * DESC:     Remote Module End-to-End HOL Status Table
 * SIZE:     256
 * FIELDS:
 *     COS0_HOL_BITMAP  COS0 Port Bitmap
 *     COS1_HOL_BITMAP  COS1 Port Bitmap
 *     COS2_HOL_BITMAP  COS2 Port Bitmap
 *     COS3_HOL_BITMAP  COS3 Port Bitmap
 *     COS4_HOL_BITMAP  COS4 Port Bitmap
 *     COS5_HOL_BITMAP  COS5 Port Bitmap
 *     COS6_HOL_BITMAP  COS6 Port Bitmap
 *     COS7_HOL_BITMAP  COS7 Port Bitmap
 *
 ******************************************************************************/
#define BCM56504_A0_E2E_HOL_STATUSm 0x0e770000

#define BCM56504_A0_E2E_HOL_STATUSm_MIN 0
#define BCM56504_A0_E2E_HOL_STATUSm_MAX 63
#define BCM56504_A0_E2E_HOL_STATUSm_CMAX(u) 63
#define BCM56504_A0_E2E_HOL_STATUSm_SIZE 32

/*
 * This structure should be used to declare and program E2E_HOL_STATUS.
 *
 */
typedef union BCM56504_A0_E2E_HOL_STATUSm_s {
	uint32_t v[8];
	uint32_t e2e_hol_status[8];
	uint32_t _e2e_hol_status;
} BCM56504_A0_E2E_HOL_STATUSm_t;

#define BCM56504_A0_E2E_HOL_STATUSm_CLR(r) CDK_MEMSET(&((r)._e2e_hol_status), 0, sizeof(BCM56504_A0_E2E_HOL_STATUSm_t))
#define BCM56504_A0_E2E_HOL_STATUSm_SET(r,i,d) (r).e2e_hol_status[i] = d
#define BCM56504_A0_E2E_HOL_STATUSm_GET(r,i) (r).e2e_hol_status[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_E2E_HOL_STATUSm_COS0_HOL_BITMAPf_GET(r) ((r).e2e_hol_status[0])
#define BCM56504_A0_E2E_HOL_STATUSm_COS0_HOL_BITMAPf_SET(r,f) (r).e2e_hol_status[0]=((uint32_t)f)
#define BCM56504_A0_E2E_HOL_STATUSm_COS1_HOL_BITMAPf_GET(r) ((r).e2e_hol_status[1])
#define BCM56504_A0_E2E_HOL_STATUSm_COS1_HOL_BITMAPf_SET(r,f) (r).e2e_hol_status[1]=((uint32_t)f)
#define BCM56504_A0_E2E_HOL_STATUSm_COS2_HOL_BITMAPf_GET(r) ((r).e2e_hol_status[2])
#define BCM56504_A0_E2E_HOL_STATUSm_COS2_HOL_BITMAPf_SET(r,f) (r).e2e_hol_status[2]=((uint32_t)f)
#define BCM56504_A0_E2E_HOL_STATUSm_COS3_HOL_BITMAPf_GET(r) ((r).e2e_hol_status[3])
#define BCM56504_A0_E2E_HOL_STATUSm_COS3_HOL_BITMAPf_SET(r,f) (r).e2e_hol_status[3]=((uint32_t)f)
#define BCM56504_A0_E2E_HOL_STATUSm_COS4_HOL_BITMAPf_GET(r) ((r).e2e_hol_status[4])
#define BCM56504_A0_E2E_HOL_STATUSm_COS4_HOL_BITMAPf_SET(r,f) (r).e2e_hol_status[4]=((uint32_t)f)
#define BCM56504_A0_E2E_HOL_STATUSm_COS5_HOL_BITMAPf_GET(r) ((r).e2e_hol_status[5])
#define BCM56504_A0_E2E_HOL_STATUSm_COS5_HOL_BITMAPf_SET(r,f) (r).e2e_hol_status[5]=((uint32_t)f)
#define BCM56504_A0_E2E_HOL_STATUSm_COS6_HOL_BITMAPf_GET(r) ((r).e2e_hol_status[6])
#define BCM56504_A0_E2E_HOL_STATUSm_COS6_HOL_BITMAPf_SET(r,f) (r).e2e_hol_status[6]=((uint32_t)f)
#define BCM56504_A0_E2E_HOL_STATUSm_COS7_HOL_BITMAPf_GET(r) ((r).e2e_hol_status[7])
#define BCM56504_A0_E2E_HOL_STATUSm_COS7_HOL_BITMAPf_SET(r,f) (r).e2e_hol_status[7]=((uint32_t)f)

/*
 * These macros can be used to access E2E_HOL_STATUS.
 *
 */
#define BCM56504_A0_READ_E2E_HOL_STATUSm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_E2E_HOL_STATUSm,i,(m._e2e_hol_status),8)
#define BCM56504_A0_WRITE_E2E_HOL_STATUSm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_E2E_HOL_STATUSm,i,&(m._e2e_hol_status),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define E2E_HOL_STATUSm BCM56504_A0_E2E_HOL_STATUSm
#define E2E_HOL_STATUSm_MIN BCM56504_A0_E2E_HOL_STATUSm_MIN
#define E2E_HOL_STATUSm_MAX BCM56504_A0_E2E_HOL_STATUSm_MAX
#define E2E_HOL_STATUSm_CMAX(u) BCM56504_A0_E2E_HOL_STATUSm_CMAX(u)
#define E2E_HOL_STATUSm_SIZE BCM56504_A0_E2E_HOL_STATUSm_SIZE
typedef BCM56504_A0_E2E_HOL_STATUSm_t E2E_HOL_STATUSm_t;
#define E2E_HOL_STATUSm_CLR BCM56504_A0_E2E_HOL_STATUSm_CLR
#define E2E_HOL_STATUSm_SET BCM56504_A0_E2E_HOL_STATUSm_SET
#define E2E_HOL_STATUSm_GET BCM56504_A0_E2E_HOL_STATUSm_GET
#define E2E_HOL_STATUSm_COS0_HOL_BITMAPf_GET BCM56504_A0_E2E_HOL_STATUSm_COS0_HOL_BITMAPf_GET
#define E2E_HOL_STATUSm_COS0_HOL_BITMAPf_SET BCM56504_A0_E2E_HOL_STATUSm_COS0_HOL_BITMAPf_SET
#define E2E_HOL_STATUSm_COS1_HOL_BITMAPf_GET BCM56504_A0_E2E_HOL_STATUSm_COS1_HOL_BITMAPf_GET
#define E2E_HOL_STATUSm_COS1_HOL_BITMAPf_SET BCM56504_A0_E2E_HOL_STATUSm_COS1_HOL_BITMAPf_SET
#define E2E_HOL_STATUSm_COS2_HOL_BITMAPf_GET BCM56504_A0_E2E_HOL_STATUSm_COS2_HOL_BITMAPf_GET
#define E2E_HOL_STATUSm_COS2_HOL_BITMAPf_SET BCM56504_A0_E2E_HOL_STATUSm_COS2_HOL_BITMAPf_SET
#define E2E_HOL_STATUSm_COS3_HOL_BITMAPf_GET BCM56504_A0_E2E_HOL_STATUSm_COS3_HOL_BITMAPf_GET
#define E2E_HOL_STATUSm_COS3_HOL_BITMAPf_SET BCM56504_A0_E2E_HOL_STATUSm_COS3_HOL_BITMAPf_SET
#define E2E_HOL_STATUSm_COS4_HOL_BITMAPf_GET BCM56504_A0_E2E_HOL_STATUSm_COS4_HOL_BITMAPf_GET
#define E2E_HOL_STATUSm_COS4_HOL_BITMAPf_SET BCM56504_A0_E2E_HOL_STATUSm_COS4_HOL_BITMAPf_SET
#define E2E_HOL_STATUSm_COS5_HOL_BITMAPf_GET BCM56504_A0_E2E_HOL_STATUSm_COS5_HOL_BITMAPf_GET
#define E2E_HOL_STATUSm_COS5_HOL_BITMAPf_SET BCM56504_A0_E2E_HOL_STATUSm_COS5_HOL_BITMAPf_SET
#define E2E_HOL_STATUSm_COS6_HOL_BITMAPf_GET BCM56504_A0_E2E_HOL_STATUSm_COS6_HOL_BITMAPf_GET
#define E2E_HOL_STATUSm_COS6_HOL_BITMAPf_SET BCM56504_A0_E2E_HOL_STATUSm_COS6_HOL_BITMAPf_SET
#define E2E_HOL_STATUSm_COS7_HOL_BITMAPf_GET BCM56504_A0_E2E_HOL_STATUSm_COS7_HOL_BITMAPf_GET
#define E2E_HOL_STATUSm_COS7_HOL_BITMAPf_SET BCM56504_A0_E2E_HOL_STATUSm_COS7_HOL_BITMAPf_SET
#define READ_E2E_HOL_STATUSm BCM56504_A0_READ_E2E_HOL_STATUSm
#define WRITE_E2E_HOL_STATUSm BCM56504_A0_WRITE_E2E_HOL_STATUSm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_E2E_HOL_STATUSm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  E2E_IBP_RX_DA_LS
 * BLOCKS:   IPIPE_HI
 * DESC:     End-to-End IBP LSB DA Register
 * SIZE:     32
 * FIELDS:
 *     DA               Least significant 16-bits of the DA for receive E2E IBP messages
 *
 ******************************************************************************/
#define BCM56504_A0_E2E_IBP_RX_DA_LSr 0x02880005

#define BCM56504_A0_E2E_IBP_RX_DA_LSr_SIZE 4

/*
 * This structure should be used to declare and program E2E_IBP_RX_DA_LS.
 *
 */
typedef union BCM56504_A0_E2E_IBP_RX_DA_LSr_s {
	uint32_t v[1];
	uint32_t e2e_ibp_rx_da_ls[1];
	uint32_t _e2e_ibp_rx_da_ls;
} BCM56504_A0_E2E_IBP_RX_DA_LSr_t;

#define BCM56504_A0_E2E_IBP_RX_DA_LSr_CLR(r) (r).e2e_ibp_rx_da_ls[0] = 0
#define BCM56504_A0_E2E_IBP_RX_DA_LSr_SET(r,d) (r).e2e_ibp_rx_da_ls[0] = d
#define BCM56504_A0_E2E_IBP_RX_DA_LSr_GET(r) (r).e2e_ibp_rx_da_ls[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_E2E_IBP_RX_DA_LSr_DAf_GET(r) ((r).e2e_ibp_rx_da_ls[0])
#define BCM56504_A0_E2E_IBP_RX_DA_LSr_DAf_SET(r,f) (r).e2e_ibp_rx_da_ls[0]=((uint32_t)f)

/*
 * These macros can be used to access E2E_IBP_RX_DA_LS.
 *
 */
#define BCM56504_A0_READ_E2E_IBP_RX_DA_LSr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_E2E_IBP_RX_DA_LSr,(r._e2e_ibp_rx_da_ls))
#define BCM56504_A0_WRITE_E2E_IBP_RX_DA_LSr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_E2E_IBP_RX_DA_LSr,&(r._e2e_ibp_rx_da_ls))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define E2E_IBP_RX_DA_LSr BCM56504_A0_E2E_IBP_RX_DA_LSr
#define E2E_IBP_RX_DA_LSr_SIZE BCM56504_A0_E2E_IBP_RX_DA_LSr_SIZE
typedef BCM56504_A0_E2E_IBP_RX_DA_LSr_t E2E_IBP_RX_DA_LSr_t;
#define E2E_IBP_RX_DA_LSr_CLR BCM56504_A0_E2E_IBP_RX_DA_LSr_CLR
#define E2E_IBP_RX_DA_LSr_SET BCM56504_A0_E2E_IBP_RX_DA_LSr_SET
#define E2E_IBP_RX_DA_LSr_GET BCM56504_A0_E2E_IBP_RX_DA_LSr_GET
#define E2E_IBP_RX_DA_LSr_DAf_GET BCM56504_A0_E2E_IBP_RX_DA_LSr_DAf_GET
#define E2E_IBP_RX_DA_LSr_DAf_SET BCM56504_A0_E2E_IBP_RX_DA_LSr_DAf_SET
#define READ_E2E_IBP_RX_DA_LSr BCM56504_A0_READ_E2E_IBP_RX_DA_LSr
#define WRITE_E2E_IBP_RX_DA_LSr BCM56504_A0_WRITE_E2E_IBP_RX_DA_LSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_E2E_IBP_RX_DA_LSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  E2E_IBP_RX_DA_MS
 * BLOCKS:   IPIPE_HI
 * DESC:     End-to-End IBP MSB DA Register
 * SIZE:     32
 * FIELDS:
 *     DA               Most significant 16-bits of the DA for receive E2E IBP messages
 *
 ******************************************************************************/
#define BCM56504_A0_E2E_IBP_RX_DA_MSr 0x02880004

#define BCM56504_A0_E2E_IBP_RX_DA_MSr_SIZE 4

/*
 * This structure should be used to declare and program E2E_IBP_RX_DA_MS.
 *
 */
typedef union BCM56504_A0_E2E_IBP_RX_DA_MSr_s {
	uint32_t v[1];
	uint32_t e2e_ibp_rx_da_ms[1];
	uint32_t _e2e_ibp_rx_da_ms;
} BCM56504_A0_E2E_IBP_RX_DA_MSr_t;

#define BCM56504_A0_E2E_IBP_RX_DA_MSr_CLR(r) (r).e2e_ibp_rx_da_ms[0] = 0
#define BCM56504_A0_E2E_IBP_RX_DA_MSr_SET(r,d) (r).e2e_ibp_rx_da_ms[0] = d
#define BCM56504_A0_E2E_IBP_RX_DA_MSr_GET(r) (r).e2e_ibp_rx_da_ms[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_E2E_IBP_RX_DA_MSr_DAf_GET(r) (((r).e2e_ibp_rx_da_ms[0]) & 0xffff)
#define BCM56504_A0_E2E_IBP_RX_DA_MSr_DAf_SET(r,f) (r).e2e_ibp_rx_da_ms[0]=(((r).e2e_ibp_rx_da_ms[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access E2E_IBP_RX_DA_MS.
 *
 */
#define BCM56504_A0_READ_E2E_IBP_RX_DA_MSr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_E2E_IBP_RX_DA_MSr,(r._e2e_ibp_rx_da_ms))
#define BCM56504_A0_WRITE_E2E_IBP_RX_DA_MSr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_E2E_IBP_RX_DA_MSr,&(r._e2e_ibp_rx_da_ms))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define E2E_IBP_RX_DA_MSr BCM56504_A0_E2E_IBP_RX_DA_MSr
#define E2E_IBP_RX_DA_MSr_SIZE BCM56504_A0_E2E_IBP_RX_DA_MSr_SIZE
typedef BCM56504_A0_E2E_IBP_RX_DA_MSr_t E2E_IBP_RX_DA_MSr_t;
#define E2E_IBP_RX_DA_MSr_CLR BCM56504_A0_E2E_IBP_RX_DA_MSr_CLR
#define E2E_IBP_RX_DA_MSr_SET BCM56504_A0_E2E_IBP_RX_DA_MSr_SET
#define E2E_IBP_RX_DA_MSr_GET BCM56504_A0_E2E_IBP_RX_DA_MSr_GET
#define E2E_IBP_RX_DA_MSr_DAf_GET BCM56504_A0_E2E_IBP_RX_DA_MSr_DAf_GET
#define E2E_IBP_RX_DA_MSr_DAf_SET BCM56504_A0_E2E_IBP_RX_DA_MSr_DAf_SET
#define READ_E2E_IBP_RX_DA_MSr BCM56504_A0_READ_E2E_IBP_RX_DA_MSr
#define WRITE_E2E_IBP_RX_DA_MSr BCM56504_A0_WRITE_E2E_IBP_RX_DA_MSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_E2E_IBP_RX_DA_MSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  E2E_IBP_RX_LENGTH_TYPE
 * BLOCKS:   IPIPE_HI
 * DESC:     End-to-End IBP Length/Type Register
 * SIZE:     32
 * FIELDS:
 *     LENGTH_TYPE      Length/Type Field for receive E2E IBP messages
 *
 ******************************************************************************/
#define BCM56504_A0_E2E_IBP_RX_LENGTH_TYPEr 0x02880006

#define BCM56504_A0_E2E_IBP_RX_LENGTH_TYPEr_SIZE 4

/*
 * This structure should be used to declare and program E2E_IBP_RX_LENGTH_TYPE.
 *
 */
typedef union BCM56504_A0_E2E_IBP_RX_LENGTH_TYPEr_s {
	uint32_t v[1];
	uint32_t e2e_ibp_rx_length_type[1];
	uint32_t _e2e_ibp_rx_length_type;
} BCM56504_A0_E2E_IBP_RX_LENGTH_TYPEr_t;

#define BCM56504_A0_E2E_IBP_RX_LENGTH_TYPEr_CLR(r) (r).e2e_ibp_rx_length_type[0] = 0
#define BCM56504_A0_E2E_IBP_RX_LENGTH_TYPEr_SET(r,d) (r).e2e_ibp_rx_length_type[0] = d
#define BCM56504_A0_E2E_IBP_RX_LENGTH_TYPEr_GET(r) (r).e2e_ibp_rx_length_type[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_E2E_IBP_RX_LENGTH_TYPEr_LENGTH_TYPEf_GET(r) (((r).e2e_ibp_rx_length_type[0]) & 0xffff)
#define BCM56504_A0_E2E_IBP_RX_LENGTH_TYPEr_LENGTH_TYPEf_SET(r,f) (r).e2e_ibp_rx_length_type[0]=(((r).e2e_ibp_rx_length_type[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access E2E_IBP_RX_LENGTH_TYPE.
 *
 */
#define BCM56504_A0_READ_E2E_IBP_RX_LENGTH_TYPEr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_E2E_IBP_RX_LENGTH_TYPEr,(r._e2e_ibp_rx_length_type))
#define BCM56504_A0_WRITE_E2E_IBP_RX_LENGTH_TYPEr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_E2E_IBP_RX_LENGTH_TYPEr,&(r._e2e_ibp_rx_length_type))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define E2E_IBP_RX_LENGTH_TYPEr BCM56504_A0_E2E_IBP_RX_LENGTH_TYPEr
#define E2E_IBP_RX_LENGTH_TYPEr_SIZE BCM56504_A0_E2E_IBP_RX_LENGTH_TYPEr_SIZE
typedef BCM56504_A0_E2E_IBP_RX_LENGTH_TYPEr_t E2E_IBP_RX_LENGTH_TYPEr_t;
#define E2E_IBP_RX_LENGTH_TYPEr_CLR BCM56504_A0_E2E_IBP_RX_LENGTH_TYPEr_CLR
#define E2E_IBP_RX_LENGTH_TYPEr_SET BCM56504_A0_E2E_IBP_RX_LENGTH_TYPEr_SET
#define E2E_IBP_RX_LENGTH_TYPEr_GET BCM56504_A0_E2E_IBP_RX_LENGTH_TYPEr_GET
#define E2E_IBP_RX_LENGTH_TYPEr_LENGTH_TYPEf_GET BCM56504_A0_E2E_IBP_RX_LENGTH_TYPEr_LENGTH_TYPEf_GET
#define E2E_IBP_RX_LENGTH_TYPEr_LENGTH_TYPEf_SET BCM56504_A0_E2E_IBP_RX_LENGTH_TYPEr_LENGTH_TYPEf_SET
#define READ_E2E_IBP_RX_LENGTH_TYPEr BCM56504_A0_READ_E2E_IBP_RX_LENGTH_TYPEr
#define WRITE_E2E_IBP_RX_LENGTH_TYPEr BCM56504_A0_WRITE_E2E_IBP_RX_LENGTH_TYPEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_E2E_IBP_RX_LENGTH_TYPEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  E2E_IBP_RX_OPCODE
 * BLOCKS:   IPIPE_HI
 * DESC:     End-to-End IBP Opcode Register
 * SIZE:     32
 * FIELDS:
 *     OPCODE           Opcode Field for receive E2E IBP messages
 *
 ******************************************************************************/
#define BCM56504_A0_E2E_IBP_RX_OPCODEr 0x02880007

#define BCM56504_A0_E2E_IBP_RX_OPCODEr_SIZE 4

/*
 * This structure should be used to declare and program E2E_IBP_RX_OPCODE.
 *
 */
typedef union BCM56504_A0_E2E_IBP_RX_OPCODEr_s {
	uint32_t v[1];
	uint32_t e2e_ibp_rx_opcode[1];
	uint32_t _e2e_ibp_rx_opcode;
} BCM56504_A0_E2E_IBP_RX_OPCODEr_t;

#define BCM56504_A0_E2E_IBP_RX_OPCODEr_CLR(r) (r).e2e_ibp_rx_opcode[0] = 0
#define BCM56504_A0_E2E_IBP_RX_OPCODEr_SET(r,d) (r).e2e_ibp_rx_opcode[0] = d
#define BCM56504_A0_E2E_IBP_RX_OPCODEr_GET(r) (r).e2e_ibp_rx_opcode[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_E2E_IBP_RX_OPCODEr_OPCODEf_GET(r) (((r).e2e_ibp_rx_opcode[0]) & 0xffff)
#define BCM56504_A0_E2E_IBP_RX_OPCODEr_OPCODEf_SET(r,f) (r).e2e_ibp_rx_opcode[0]=(((r).e2e_ibp_rx_opcode[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access E2E_IBP_RX_OPCODE.
 *
 */
#define BCM56504_A0_READ_E2E_IBP_RX_OPCODEr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_E2E_IBP_RX_OPCODEr,(r._e2e_ibp_rx_opcode))
#define BCM56504_A0_WRITE_E2E_IBP_RX_OPCODEr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_E2E_IBP_RX_OPCODEr,&(r._e2e_ibp_rx_opcode))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define E2E_IBP_RX_OPCODEr BCM56504_A0_E2E_IBP_RX_OPCODEr
#define E2E_IBP_RX_OPCODEr_SIZE BCM56504_A0_E2E_IBP_RX_OPCODEr_SIZE
typedef BCM56504_A0_E2E_IBP_RX_OPCODEr_t E2E_IBP_RX_OPCODEr_t;
#define E2E_IBP_RX_OPCODEr_CLR BCM56504_A0_E2E_IBP_RX_OPCODEr_CLR
#define E2E_IBP_RX_OPCODEr_SET BCM56504_A0_E2E_IBP_RX_OPCODEr_SET
#define E2E_IBP_RX_OPCODEr_GET BCM56504_A0_E2E_IBP_RX_OPCODEr_GET
#define E2E_IBP_RX_OPCODEr_OPCODEf_GET BCM56504_A0_E2E_IBP_RX_OPCODEr_OPCODEf_GET
#define E2E_IBP_RX_OPCODEr_OPCODEf_SET BCM56504_A0_E2E_IBP_RX_OPCODEr_OPCODEf_SET
#define READ_E2E_IBP_RX_OPCODEr BCM56504_A0_READ_E2E_IBP_RX_OPCODEr
#define WRITE_E2E_IBP_RX_OPCODEr BCM56504_A0_WRITE_E2E_IBP_RX_OPCODEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_E2E_IBP_RX_OPCODEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  EGRDROPPKTCOUNT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     DROPPEDPKTCOUNT  This is per egress port based counter and it counts the number of whole packets dropped by MMU and will not pass to egress port. MMU counts packets only if the portbitmap of the received packet is non-zero and not purgedThe reasons for mmu to drop packet:1. CBP memory Full,2. IBP Cell count over IBPDISCARDSETLIMIT,3. HOL Cell count over HOLCOSxCELLSETLIMIT,4. HOL Packet count over HOLCOSxPKTSETLIMIT,5. HOL Packet count over CNGCOSxPKTSETLIMIT0 and Packet with CNG[1:0]=2'b01,6. HOL Packet count over CNGCOSxPKTSETLIMIT1 and Packet with CNG[1:0]=2'b11,7. Single cell packet (64~128 bytes) purged by Ingress Pipeline.For packet just dropped when the some cells of the packet are already beenadmitted by mmu, this packet will not get counted by MMU EGRDROPPKTCOUNT. 
 *
 ******************************************************************************/
#define BCM56504_A0_EGRDROPPKTCOUNTr 0x00600047

#define BCM56504_A0_EGRDROPPKTCOUNTr_SIZE 4

/*
 * This structure should be used to declare and program EGRDROPPKTCOUNT.
 *
 */
typedef union BCM56504_A0_EGRDROPPKTCOUNTr_s {
	uint32_t v[1];
	uint32_t egrdroppktcount[1];
	uint32_t _egrdroppktcount;
} BCM56504_A0_EGRDROPPKTCOUNTr_t;

#define BCM56504_A0_EGRDROPPKTCOUNTr_CLR(r) (r).egrdroppktcount[0] = 0
#define BCM56504_A0_EGRDROPPKTCOUNTr_SET(r,d) (r).egrdroppktcount[0] = d
#define BCM56504_A0_EGRDROPPKTCOUNTr_GET(r) (r).egrdroppktcount[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_EGRDROPPKTCOUNTr_DROPPEDPKTCOUNTf_GET(r) ((r).egrdroppktcount[0])
#define BCM56504_A0_EGRDROPPKTCOUNTr_DROPPEDPKTCOUNTf_SET(r,f) (r).egrdroppktcount[0]=((uint32_t)f)

/*
 * These macros can be used to access EGRDROPPKTCOUNT.
 *
 */
#define BCM56504_A0_READ_EGRDROPPKTCOUNTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_EGRDROPPKTCOUNTr,(r._egrdroppktcount))
#define BCM56504_A0_WRITE_EGRDROPPKTCOUNTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_EGRDROPPKTCOUNTr,&(r._egrdroppktcount))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGRDROPPKTCOUNTr BCM56504_A0_EGRDROPPKTCOUNTr
#define EGRDROPPKTCOUNTr_SIZE BCM56504_A0_EGRDROPPKTCOUNTr_SIZE
typedef BCM56504_A0_EGRDROPPKTCOUNTr_t EGRDROPPKTCOUNTr_t;
#define EGRDROPPKTCOUNTr_CLR BCM56504_A0_EGRDROPPKTCOUNTr_CLR
#define EGRDROPPKTCOUNTr_SET BCM56504_A0_EGRDROPPKTCOUNTr_SET
#define EGRDROPPKTCOUNTr_GET BCM56504_A0_EGRDROPPKTCOUNTr_GET
#define EGRDROPPKTCOUNTr_DROPPEDPKTCOUNTf_GET BCM56504_A0_EGRDROPPKTCOUNTr_DROPPEDPKTCOUNTf_GET
#define EGRDROPPKTCOUNTr_DROPPEDPKTCOUNTf_SET BCM56504_A0_EGRDROPPKTCOUNTr_DROPPEDPKTCOUNTf_SET
#define READ_EGRDROPPKTCOUNTr BCM56504_A0_READ_EGRDROPPKTCOUNTr
#define WRITE_EGRDROPPKTCOUNTr BCM56504_A0_WRITE_EGRDROPPKTCOUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_EGRDROPPKTCOUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  EGRESSCELLREQUESTCOUNT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     REQUESTCOUNT     Egress Cell request Counter.Counter needs to reset when reseting Egress port.
 *
 ******************************************************************************/
#define BCM56504_A0_EGRESSCELLREQUESTCOUNTr 0x00600044

#define BCM56504_A0_EGRESSCELLREQUESTCOUNTr_SIZE 4

/*
 * This structure should be used to declare and program EGRESSCELLREQUESTCOUNT.
 *
 */
typedef union BCM56504_A0_EGRESSCELLREQUESTCOUNTr_s {
	uint32_t v[1];
	uint32_t egresscellrequestcount[1];
	uint32_t _egresscellrequestcount;
} BCM56504_A0_EGRESSCELLREQUESTCOUNTr_t;

#define BCM56504_A0_EGRESSCELLREQUESTCOUNTr_CLR(r) (r).egresscellrequestcount[0] = 0
#define BCM56504_A0_EGRESSCELLREQUESTCOUNTr_SET(r,d) (r).egresscellrequestcount[0] = d
#define BCM56504_A0_EGRESSCELLREQUESTCOUNTr_GET(r) (r).egresscellrequestcount[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_EGRESSCELLREQUESTCOUNTr_REQUESTCOUNTf_GET(r) (((r).egresscellrequestcount[0]) & 0xf)
#define BCM56504_A0_EGRESSCELLREQUESTCOUNTr_REQUESTCOUNTf_SET(r,f) (r).egresscellrequestcount[0]=(((r).egresscellrequestcount[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access EGRESSCELLREQUESTCOUNT.
 *
 */
#define BCM56504_A0_READ_EGRESSCELLREQUESTCOUNTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_EGRESSCELLREQUESTCOUNTr,(r._egresscellrequestcount))
#define BCM56504_A0_WRITE_EGRESSCELLREQUESTCOUNTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_EGRESSCELLREQUESTCOUNTr,&(r._egresscellrequestcount))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGRESSCELLREQUESTCOUNTr BCM56504_A0_EGRESSCELLREQUESTCOUNTr
#define EGRESSCELLREQUESTCOUNTr_SIZE BCM56504_A0_EGRESSCELLREQUESTCOUNTr_SIZE
typedef BCM56504_A0_EGRESSCELLREQUESTCOUNTr_t EGRESSCELLREQUESTCOUNTr_t;
#define EGRESSCELLREQUESTCOUNTr_CLR BCM56504_A0_EGRESSCELLREQUESTCOUNTr_CLR
#define EGRESSCELLREQUESTCOUNTr_SET BCM56504_A0_EGRESSCELLREQUESTCOUNTr_SET
#define EGRESSCELLREQUESTCOUNTr_GET BCM56504_A0_EGRESSCELLREQUESTCOUNTr_GET
#define EGRESSCELLREQUESTCOUNTr_REQUESTCOUNTf_GET BCM56504_A0_EGRESSCELLREQUESTCOUNTr_REQUESTCOUNTf_GET
#define EGRESSCELLREQUESTCOUNTr_REQUESTCOUNTf_SET BCM56504_A0_EGRESSCELLREQUESTCOUNTr_REQUESTCOUNTf_SET
#define READ_EGRESSCELLREQUESTCOUNTr BCM56504_A0_READ_EGRESSCELLREQUESTCOUNTr
#define WRITE_EGRESSCELLREQUESTCOUNTr BCM56504_A0_WRITE_EGRESSCELLREQUESTCOUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_EGRESSCELLREQUESTCOUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  EGRMETERINGBUCKET
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     BUCKET           Maximum rate bucket. Each unit represents 64k bits.
 *     IN_PROFILE_FLAG  IN_PROFILE_FLAG inidcates the current state of metering bucket1: out of profile0: In profileDefault value is in profile.
 *
 ******************************************************************************/
#define BCM56504_A0_EGRMETERINGBUCKETr 0x00600071

#define BCM56504_A0_EGRMETERINGBUCKETr_SIZE 4

/*
 * This structure should be used to declare and program EGRMETERINGBUCKET.
 *
 */
typedef union BCM56504_A0_EGRMETERINGBUCKETr_s {
	uint32_t v[1];
	uint32_t egrmeteringbucket[1];
	uint32_t _egrmeteringbucket;
} BCM56504_A0_EGRMETERINGBUCKETr_t;

#define BCM56504_A0_EGRMETERINGBUCKETr_CLR(r) (r).egrmeteringbucket[0] = 0
#define BCM56504_A0_EGRMETERINGBUCKETr_SET(r,d) (r).egrmeteringbucket[0] = d
#define BCM56504_A0_EGRMETERINGBUCKETr_GET(r) (r).egrmeteringbucket[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_EGRMETERINGBUCKETr_BUCKETf_GET(r) (((r).egrmeteringbucket[0]) & 0x1fffffff)
#define BCM56504_A0_EGRMETERINGBUCKETr_BUCKETf_SET(r,f) (r).egrmeteringbucket[0]=(((r).egrmeteringbucket[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM56504_A0_EGRMETERINGBUCKETr_IN_PROFILE_FLAGf_GET(r) ((((r).egrmeteringbucket[0]) >> 29) & 0x1)
#define BCM56504_A0_EGRMETERINGBUCKETr_IN_PROFILE_FLAGf_SET(r,f) (r).egrmeteringbucket[0]=(((r).egrmeteringbucket[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))

/*
 * These macros can be used to access EGRMETERINGBUCKET.
 *
 */
#define BCM56504_A0_READ_EGRMETERINGBUCKETr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_EGRMETERINGBUCKETr,(r._egrmeteringbucket))
#define BCM56504_A0_WRITE_EGRMETERINGBUCKETr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_EGRMETERINGBUCKETr,&(r._egrmeteringbucket))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGRMETERINGBUCKETr BCM56504_A0_EGRMETERINGBUCKETr
#define EGRMETERINGBUCKETr_SIZE BCM56504_A0_EGRMETERINGBUCKETr_SIZE
typedef BCM56504_A0_EGRMETERINGBUCKETr_t EGRMETERINGBUCKETr_t;
#define EGRMETERINGBUCKETr_CLR BCM56504_A0_EGRMETERINGBUCKETr_CLR
#define EGRMETERINGBUCKETr_SET BCM56504_A0_EGRMETERINGBUCKETr_SET
#define EGRMETERINGBUCKETr_GET BCM56504_A0_EGRMETERINGBUCKETr_GET
#define EGRMETERINGBUCKETr_BUCKETf_GET BCM56504_A0_EGRMETERINGBUCKETr_BUCKETf_GET
#define EGRMETERINGBUCKETr_BUCKETf_SET BCM56504_A0_EGRMETERINGBUCKETr_BUCKETf_SET
#define EGRMETERINGBUCKETr_IN_PROFILE_FLAGf_GET BCM56504_A0_EGRMETERINGBUCKETr_IN_PROFILE_FLAGf_GET
#define EGRMETERINGBUCKETr_IN_PROFILE_FLAGf_SET BCM56504_A0_EGRMETERINGBUCKETr_IN_PROFILE_FLAGf_SET
#define READ_EGRMETERINGBUCKETr BCM56504_A0_READ_EGRMETERINGBUCKETr
#define WRITE_EGRMETERINGBUCKETr BCM56504_A0_WRITE_EGRMETERINGBUCKETr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_EGRMETERINGBUCKETr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  EGRMETERINGCONFIG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     THD_SEL          Threshold for metering bucket.0x0:  Disable0x1:  32k bits. (32*1024)0x2:  64k bits. (64*1024)0x3: 128k bits. (128*1024)0x4: 256k bits. (256*1024)0x5: 512k bits. (512*1024)0x6:   1M bits. (1024*1024)0x7:   2M bits. (2*1024*1024)0x8:   4M bits. (4*1024*1024)0x9:   8M bits. (8*1024*1024)0xa:  16M bits. (16*1024*1024)0xb:  32M bits. (32*1024*1024)0xc:  64M bits. (64*1024*1024)0xd: 128M bits. (128*1024*1024)0xe: 128M bits. (128*1024*1024) setting satuated at 0xd 0xf: 128M bits. (128*1024*1024) setting satuated at 0xd
 *     REFRESH          Refresh count for metering bucket. Each unit of REFRESH represents 64 kbps. To use egress metering feature, MISCCONFIG.METERING_CLK_EN need to be set enable.
 *
 ******************************************************************************/
#define BCM56504_A0_EGRMETERINGCONFIGr 0x00600070

#define BCM56504_A0_EGRMETERINGCONFIGr_SIZE 4

/*
 * This structure should be used to declare and program EGRMETERINGCONFIG.
 *
 */
typedef union BCM56504_A0_EGRMETERINGCONFIGr_s {
	uint32_t v[1];
	uint32_t egrmeteringconfig[1];
	uint32_t _egrmeteringconfig;
} BCM56504_A0_EGRMETERINGCONFIGr_t;

#define BCM56504_A0_EGRMETERINGCONFIGr_CLR(r) (r).egrmeteringconfig[0] = 0
#define BCM56504_A0_EGRMETERINGCONFIGr_SET(r,d) (r).egrmeteringconfig[0] = d
#define BCM56504_A0_EGRMETERINGCONFIGr_GET(r) (r).egrmeteringconfig[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_EGRMETERINGCONFIGr_THD_SELf_GET(r) (((r).egrmeteringconfig[0]) & 0xf)
#define BCM56504_A0_EGRMETERINGCONFIGr_THD_SELf_SET(r,f) (r).egrmeteringconfig[0]=(((r).egrmeteringconfig[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56504_A0_EGRMETERINGCONFIGr_REFRESHf_GET(r) ((((r).egrmeteringconfig[0]) >> 4) & 0x3ffff)
#define BCM56504_A0_EGRMETERINGCONFIGr_REFRESHf_SET(r,f) (r).egrmeteringconfig[0]=(((r).egrmeteringconfig[0] & ~((uint32_t)0x3ffff << 4)) | ((((uint32_t)f) & 0x3ffff) << 4))

/*
 * These macros can be used to access EGRMETERINGCONFIG.
 *
 */
#define BCM56504_A0_READ_EGRMETERINGCONFIGr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_EGRMETERINGCONFIGr,(r._egrmeteringconfig))
#define BCM56504_A0_WRITE_EGRMETERINGCONFIGr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_EGRMETERINGCONFIGr,&(r._egrmeteringconfig))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGRMETERINGCONFIGr BCM56504_A0_EGRMETERINGCONFIGr
#define EGRMETERINGCONFIGr_SIZE BCM56504_A0_EGRMETERINGCONFIGr_SIZE
typedef BCM56504_A0_EGRMETERINGCONFIGr_t EGRMETERINGCONFIGr_t;
#define EGRMETERINGCONFIGr_CLR BCM56504_A0_EGRMETERINGCONFIGr_CLR
#define EGRMETERINGCONFIGr_SET BCM56504_A0_EGRMETERINGCONFIGr_SET
#define EGRMETERINGCONFIGr_GET BCM56504_A0_EGRMETERINGCONFIGr_GET
#define EGRMETERINGCONFIGr_THD_SELf_GET BCM56504_A0_EGRMETERINGCONFIGr_THD_SELf_GET
#define EGRMETERINGCONFIGr_THD_SELf_SET BCM56504_A0_EGRMETERINGCONFIGr_THD_SELf_SET
#define EGRMETERINGCONFIGr_REFRESHf_GET BCM56504_A0_EGRMETERINGCONFIGr_REFRESHf_GET
#define EGRMETERINGCONFIGr_REFRESHf_SET BCM56504_A0_EGRMETERINGCONFIGr_REFRESHf_SET
#define READ_EGRMETERINGCONFIGr BCM56504_A0_READ_EGRMETERINGCONFIGr
#define WRITE_EGRMETERINGCONFIGr BCM56504_A0_WRITE_EGRMETERINGCONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_EGRMETERINGCONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  EGRTXPKTCTR0
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     TXPKTCOUNT       Transmit Packet Counter: When TXPKTCOUNT_SEL in EGRTXPKTCTR0 is selected, this packet tranmit counter will count all the packets to be tranmitted topre-configured egress port with pre-configurated cos on EGRTXPKTCTRCONFIG0.  
 *
 ******************************************************************************/
#define BCM56504_A0_EGRTXPKTCTR0r 0x00680028

#define BCM56504_A0_EGRTXPKTCTR0r_SIZE 4

/*
 * This structure should be used to declare and program EGRTXPKTCTR0.
 *
 */
typedef union BCM56504_A0_EGRTXPKTCTR0r_s {
	uint32_t v[1];
	uint32_t egrtxpktctr0[1];
	uint32_t _egrtxpktctr0;
} BCM56504_A0_EGRTXPKTCTR0r_t;

#define BCM56504_A0_EGRTXPKTCTR0r_CLR(r) (r).egrtxpktctr0[0] = 0
#define BCM56504_A0_EGRTXPKTCTR0r_SET(r,d) (r).egrtxpktctr0[0] = d
#define BCM56504_A0_EGRTXPKTCTR0r_GET(r) (r).egrtxpktctr0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_EGRTXPKTCTR0r_TXPKTCOUNTf_GET(r) ((r).egrtxpktctr0[0])
#define BCM56504_A0_EGRTXPKTCTR0r_TXPKTCOUNTf_SET(r,f) (r).egrtxpktctr0[0]=((uint32_t)f)

/*
 * These macros can be used to access EGRTXPKTCTR0.
 *
 */
#define BCM56504_A0_READ_EGRTXPKTCTR0r(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_EGRTXPKTCTR0r,(r._egrtxpktctr0))
#define BCM56504_A0_WRITE_EGRTXPKTCTR0r(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_EGRTXPKTCTR0r,&(r._egrtxpktctr0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGRTXPKTCTR0r BCM56504_A0_EGRTXPKTCTR0r
#define EGRTXPKTCTR0r_SIZE BCM56504_A0_EGRTXPKTCTR0r_SIZE
typedef BCM56504_A0_EGRTXPKTCTR0r_t EGRTXPKTCTR0r_t;
#define EGRTXPKTCTR0r_CLR BCM56504_A0_EGRTXPKTCTR0r_CLR
#define EGRTXPKTCTR0r_SET BCM56504_A0_EGRTXPKTCTR0r_SET
#define EGRTXPKTCTR0r_GET BCM56504_A0_EGRTXPKTCTR0r_GET
#define EGRTXPKTCTR0r_TXPKTCOUNTf_GET BCM56504_A0_EGRTXPKTCTR0r_TXPKTCOUNTf_GET
#define EGRTXPKTCTR0r_TXPKTCOUNTf_SET BCM56504_A0_EGRTXPKTCTR0r_TXPKTCOUNTf_SET
#define READ_EGRTXPKTCTR0r BCM56504_A0_READ_EGRTXPKTCTR0r
#define WRITE_EGRTXPKTCTR0r BCM56504_A0_WRITE_EGRTXPKTCTR0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_EGRTXPKTCTR0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  EGRTXPKTCTR1
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     TXPKTCOUNT       Transmit Packet Counter: When TXPKTCOUNT_SEL in EGRTXPKTCTR1 is selected, this packet tranmit counter will count all the packets to be tranmitted topre-configured egress port with pre-configurated cos on EGRTXPKTCTRCONFIG1.  
 *
 ******************************************************************************/
#define BCM56504_A0_EGRTXPKTCTR1r 0x00680029

#define BCM56504_A0_EGRTXPKTCTR1r_SIZE 4

/*
 * This structure should be used to declare and program EGRTXPKTCTR1.
 *
 */
typedef union BCM56504_A0_EGRTXPKTCTR1r_s {
	uint32_t v[1];
	uint32_t egrtxpktctr1[1];
	uint32_t _egrtxpktctr1;
} BCM56504_A0_EGRTXPKTCTR1r_t;

#define BCM56504_A0_EGRTXPKTCTR1r_CLR(r) (r).egrtxpktctr1[0] = 0
#define BCM56504_A0_EGRTXPKTCTR1r_SET(r,d) (r).egrtxpktctr1[0] = d
#define BCM56504_A0_EGRTXPKTCTR1r_GET(r) (r).egrtxpktctr1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_EGRTXPKTCTR1r_TXPKTCOUNTf_GET(r) ((r).egrtxpktctr1[0])
#define BCM56504_A0_EGRTXPKTCTR1r_TXPKTCOUNTf_SET(r,f) (r).egrtxpktctr1[0]=((uint32_t)f)

/*
 * These macros can be used to access EGRTXPKTCTR1.
 *
 */
#define BCM56504_A0_READ_EGRTXPKTCTR1r(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_EGRTXPKTCTR1r,(r._egrtxpktctr1))
#define BCM56504_A0_WRITE_EGRTXPKTCTR1r(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_EGRTXPKTCTR1r,&(r._egrtxpktctr1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGRTXPKTCTR1r BCM56504_A0_EGRTXPKTCTR1r
#define EGRTXPKTCTR1r_SIZE BCM56504_A0_EGRTXPKTCTR1r_SIZE
typedef BCM56504_A0_EGRTXPKTCTR1r_t EGRTXPKTCTR1r_t;
#define EGRTXPKTCTR1r_CLR BCM56504_A0_EGRTXPKTCTR1r_CLR
#define EGRTXPKTCTR1r_SET BCM56504_A0_EGRTXPKTCTR1r_SET
#define EGRTXPKTCTR1r_GET BCM56504_A0_EGRTXPKTCTR1r_GET
#define EGRTXPKTCTR1r_TXPKTCOUNTf_GET BCM56504_A0_EGRTXPKTCTR1r_TXPKTCOUNTf_GET
#define EGRTXPKTCTR1r_TXPKTCOUNTf_SET BCM56504_A0_EGRTXPKTCTR1r_TXPKTCOUNTf_SET
#define READ_EGRTXPKTCTR1r BCM56504_A0_READ_EGRTXPKTCTR1r
#define WRITE_EGRTXPKTCTR1r BCM56504_A0_WRITE_EGRTXPKTCTR1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_EGRTXPKTCTR1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  EGRTXPKTCTR2
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     TXPKTCOUNT       Transmit Packet Counter: When TXPKTCOUNT_SEL in EGRTXPKTCTR2 is selected, this packet tranmit counter will count all the packets to be tranmitted topre-configured egress port with pre-configurated cos on EGRTXPKTCTRCONFIG2.  
 *
 ******************************************************************************/
#define BCM56504_A0_EGRTXPKTCTR2r 0x0068002a

#define BCM56504_A0_EGRTXPKTCTR2r_SIZE 4

/*
 * This structure should be used to declare and program EGRTXPKTCTR2.
 *
 */
typedef union BCM56504_A0_EGRTXPKTCTR2r_s {
	uint32_t v[1];
	uint32_t egrtxpktctr2[1];
	uint32_t _egrtxpktctr2;
} BCM56504_A0_EGRTXPKTCTR2r_t;

#define BCM56504_A0_EGRTXPKTCTR2r_CLR(r) (r).egrtxpktctr2[0] = 0
#define BCM56504_A0_EGRTXPKTCTR2r_SET(r,d) (r).egrtxpktctr2[0] = d
#define BCM56504_A0_EGRTXPKTCTR2r_GET(r) (r).egrtxpktctr2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_EGRTXPKTCTR2r_TXPKTCOUNTf_GET(r) ((r).egrtxpktctr2[0])
#define BCM56504_A0_EGRTXPKTCTR2r_TXPKTCOUNTf_SET(r,f) (r).egrtxpktctr2[0]=((uint32_t)f)

/*
 * These macros can be used to access EGRTXPKTCTR2.
 *
 */
#define BCM56504_A0_READ_EGRTXPKTCTR2r(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_EGRTXPKTCTR2r,(r._egrtxpktctr2))
#define BCM56504_A0_WRITE_EGRTXPKTCTR2r(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_EGRTXPKTCTR2r,&(r._egrtxpktctr2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGRTXPKTCTR2r BCM56504_A0_EGRTXPKTCTR2r
#define EGRTXPKTCTR2r_SIZE BCM56504_A0_EGRTXPKTCTR2r_SIZE
typedef BCM56504_A0_EGRTXPKTCTR2r_t EGRTXPKTCTR2r_t;
#define EGRTXPKTCTR2r_CLR BCM56504_A0_EGRTXPKTCTR2r_CLR
#define EGRTXPKTCTR2r_SET BCM56504_A0_EGRTXPKTCTR2r_SET
#define EGRTXPKTCTR2r_GET BCM56504_A0_EGRTXPKTCTR2r_GET
#define EGRTXPKTCTR2r_TXPKTCOUNTf_GET BCM56504_A0_EGRTXPKTCTR2r_TXPKTCOUNTf_GET
#define EGRTXPKTCTR2r_TXPKTCOUNTf_SET BCM56504_A0_EGRTXPKTCTR2r_TXPKTCOUNTf_SET
#define READ_EGRTXPKTCTR2r BCM56504_A0_READ_EGRTXPKTCTR2r
#define WRITE_EGRTXPKTCTR2r BCM56504_A0_WRITE_EGRTXPKTCTR2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_EGRTXPKTCTR2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  EGRTXPKTCTR3
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     TXPKTCOUNT       Transmit Packet Counter: When TXPKTCOUNT_SEL in EGRTXPKTCTR3 is selected, this packet tranmit counter will count all the packets to be tranmitted topre-configured egress port with pre-configurated cos on EGRTXPKTCTRCONFIG3.  
 *
 ******************************************************************************/
#define BCM56504_A0_EGRTXPKTCTR3r 0x0068002b

#define BCM56504_A0_EGRTXPKTCTR3r_SIZE 4

/*
 * This structure should be used to declare and program EGRTXPKTCTR3.
 *
 */
typedef union BCM56504_A0_EGRTXPKTCTR3r_s {
	uint32_t v[1];
	uint32_t egrtxpktctr3[1];
	uint32_t _egrtxpktctr3;
} BCM56504_A0_EGRTXPKTCTR3r_t;

#define BCM56504_A0_EGRTXPKTCTR3r_CLR(r) (r).egrtxpktctr3[0] = 0
#define BCM56504_A0_EGRTXPKTCTR3r_SET(r,d) (r).egrtxpktctr3[0] = d
#define BCM56504_A0_EGRTXPKTCTR3r_GET(r) (r).egrtxpktctr3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_EGRTXPKTCTR3r_TXPKTCOUNTf_GET(r) ((r).egrtxpktctr3[0])
#define BCM56504_A0_EGRTXPKTCTR3r_TXPKTCOUNTf_SET(r,f) (r).egrtxpktctr3[0]=((uint32_t)f)

/*
 * These macros can be used to access EGRTXPKTCTR3.
 *
 */
#define BCM56504_A0_READ_EGRTXPKTCTR3r(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_EGRTXPKTCTR3r,(r._egrtxpktctr3))
#define BCM56504_A0_WRITE_EGRTXPKTCTR3r(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_EGRTXPKTCTR3r,&(r._egrtxpktctr3))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGRTXPKTCTR3r BCM56504_A0_EGRTXPKTCTR3r
#define EGRTXPKTCTR3r_SIZE BCM56504_A0_EGRTXPKTCTR3r_SIZE
typedef BCM56504_A0_EGRTXPKTCTR3r_t EGRTXPKTCTR3r_t;
#define EGRTXPKTCTR3r_CLR BCM56504_A0_EGRTXPKTCTR3r_CLR
#define EGRTXPKTCTR3r_SET BCM56504_A0_EGRTXPKTCTR3r_SET
#define EGRTXPKTCTR3r_GET BCM56504_A0_EGRTXPKTCTR3r_GET
#define EGRTXPKTCTR3r_TXPKTCOUNTf_GET BCM56504_A0_EGRTXPKTCTR3r_TXPKTCOUNTf_GET
#define EGRTXPKTCTR3r_TXPKTCOUNTf_SET BCM56504_A0_EGRTXPKTCTR3r_TXPKTCOUNTf_SET
#define READ_EGRTXPKTCTR3r BCM56504_A0_READ_EGRTXPKTCTR3r
#define WRITE_EGRTXPKTCTR3r BCM56504_A0_WRITE_EGRTXPKTCTR3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_EGRTXPKTCTR3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  EGRTXPKTCTR4
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     TXPKTCOUNT       Transmit Packet Counter: When TXPKTCOUNT_SEL in EGRTXPKTCTR4 is selected, this packet tranmit counter will count all the packets to be tranmitted topre-configured egress port with pre-configurated cos on EGRTXPKTCTRCONFIG4.  
 *
 ******************************************************************************/
#define BCM56504_A0_EGRTXPKTCTR4r 0x0068002c

#define BCM56504_A0_EGRTXPKTCTR4r_SIZE 4

/*
 * This structure should be used to declare and program EGRTXPKTCTR4.
 *
 */
typedef union BCM56504_A0_EGRTXPKTCTR4r_s {
	uint32_t v[1];
	uint32_t egrtxpktctr4[1];
	uint32_t _egrtxpktctr4;
} BCM56504_A0_EGRTXPKTCTR4r_t;

#define BCM56504_A0_EGRTXPKTCTR4r_CLR(r) (r).egrtxpktctr4[0] = 0
#define BCM56504_A0_EGRTXPKTCTR4r_SET(r,d) (r).egrtxpktctr4[0] = d
#define BCM56504_A0_EGRTXPKTCTR4r_GET(r) (r).egrtxpktctr4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_EGRTXPKTCTR4r_TXPKTCOUNTf_GET(r) ((r).egrtxpktctr4[0])
#define BCM56504_A0_EGRTXPKTCTR4r_TXPKTCOUNTf_SET(r,f) (r).egrtxpktctr4[0]=((uint32_t)f)

/*
 * These macros can be used to access EGRTXPKTCTR4.
 *
 */
#define BCM56504_A0_READ_EGRTXPKTCTR4r(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_EGRTXPKTCTR4r,(r._egrtxpktctr4))
#define BCM56504_A0_WRITE_EGRTXPKTCTR4r(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_EGRTXPKTCTR4r,&(r._egrtxpktctr4))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGRTXPKTCTR4r BCM56504_A0_EGRTXPKTCTR4r
#define EGRTXPKTCTR4r_SIZE BCM56504_A0_EGRTXPKTCTR4r_SIZE
typedef BCM56504_A0_EGRTXPKTCTR4r_t EGRTXPKTCTR4r_t;
#define EGRTXPKTCTR4r_CLR BCM56504_A0_EGRTXPKTCTR4r_CLR
#define EGRTXPKTCTR4r_SET BCM56504_A0_EGRTXPKTCTR4r_SET
#define EGRTXPKTCTR4r_GET BCM56504_A0_EGRTXPKTCTR4r_GET
#define EGRTXPKTCTR4r_TXPKTCOUNTf_GET BCM56504_A0_EGRTXPKTCTR4r_TXPKTCOUNTf_GET
#define EGRTXPKTCTR4r_TXPKTCOUNTf_SET BCM56504_A0_EGRTXPKTCTR4r_TXPKTCOUNTf_SET
#define READ_EGRTXPKTCTR4r BCM56504_A0_READ_EGRTXPKTCTR4r
#define WRITE_EGRTXPKTCTR4r BCM56504_A0_WRITE_EGRTXPKTCTR4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_EGRTXPKTCTR4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  EGRTXPKTCTR5
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     TXPKTCOUNT       Transmit Packet Counter: When TXPKTCOUNT_SEL in EGRTXPKTCTR5 is selected, this packet tranmit counter will count all the packets to be tranmitted topre-configured egress port with pre-configurated cos on EGRTXPKTCTRCONFIG5.  
 *
 ******************************************************************************/
#define BCM56504_A0_EGRTXPKTCTR5r 0x0068002d

#define BCM56504_A0_EGRTXPKTCTR5r_SIZE 4

/*
 * This structure should be used to declare and program EGRTXPKTCTR5.
 *
 */
typedef union BCM56504_A0_EGRTXPKTCTR5r_s {
	uint32_t v[1];
	uint32_t egrtxpktctr5[1];
	uint32_t _egrtxpktctr5;
} BCM56504_A0_EGRTXPKTCTR5r_t;

#define BCM56504_A0_EGRTXPKTCTR5r_CLR(r) (r).egrtxpktctr5[0] = 0
#define BCM56504_A0_EGRTXPKTCTR5r_SET(r,d) (r).egrtxpktctr5[0] = d
#define BCM56504_A0_EGRTXPKTCTR5r_GET(r) (r).egrtxpktctr5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_EGRTXPKTCTR5r_TXPKTCOUNTf_GET(r) ((r).egrtxpktctr5[0])
#define BCM56504_A0_EGRTXPKTCTR5r_TXPKTCOUNTf_SET(r,f) (r).egrtxpktctr5[0]=((uint32_t)f)

/*
 * These macros can be used to access EGRTXPKTCTR5.
 *
 */
#define BCM56504_A0_READ_EGRTXPKTCTR5r(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_EGRTXPKTCTR5r,(r._egrtxpktctr5))
#define BCM56504_A0_WRITE_EGRTXPKTCTR5r(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_EGRTXPKTCTR5r,&(r._egrtxpktctr5))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGRTXPKTCTR5r BCM56504_A0_EGRTXPKTCTR5r
#define EGRTXPKTCTR5r_SIZE BCM56504_A0_EGRTXPKTCTR5r_SIZE
typedef BCM56504_A0_EGRTXPKTCTR5r_t EGRTXPKTCTR5r_t;
#define EGRTXPKTCTR5r_CLR BCM56504_A0_EGRTXPKTCTR5r_CLR
#define EGRTXPKTCTR5r_SET BCM56504_A0_EGRTXPKTCTR5r_SET
#define EGRTXPKTCTR5r_GET BCM56504_A0_EGRTXPKTCTR5r_GET
#define EGRTXPKTCTR5r_TXPKTCOUNTf_GET BCM56504_A0_EGRTXPKTCTR5r_TXPKTCOUNTf_GET
#define EGRTXPKTCTR5r_TXPKTCOUNTf_SET BCM56504_A0_EGRTXPKTCTR5r_TXPKTCOUNTf_SET
#define READ_EGRTXPKTCTR5r BCM56504_A0_READ_EGRTXPKTCTR5r
#define WRITE_EGRTXPKTCTR5r BCM56504_A0_WRITE_EGRTXPKTCTR5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_EGRTXPKTCTR5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  EGRTXPKTCTR6
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     TXPKTCOUNT       Transmit Packet Counter: When TXPKTCOUNT_SEL in EGRTXPKTCTR6 is selected, this packet tranmit counter will count all the packets to be tranmitted topre-configured egress port with pre-configurated cos on EGRTXPKTCTRCONFIG6.  
 *
 ******************************************************************************/
#define BCM56504_A0_EGRTXPKTCTR6r 0x0068002e

#define BCM56504_A0_EGRTXPKTCTR6r_SIZE 4

/*
 * This structure should be used to declare and program EGRTXPKTCTR6.
 *
 */
typedef union BCM56504_A0_EGRTXPKTCTR6r_s {
	uint32_t v[1];
	uint32_t egrtxpktctr6[1];
	uint32_t _egrtxpktctr6;
} BCM56504_A0_EGRTXPKTCTR6r_t;

#define BCM56504_A0_EGRTXPKTCTR6r_CLR(r) (r).egrtxpktctr6[0] = 0
#define BCM56504_A0_EGRTXPKTCTR6r_SET(r,d) (r).egrtxpktctr6[0] = d
#define BCM56504_A0_EGRTXPKTCTR6r_GET(r) (r).egrtxpktctr6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_EGRTXPKTCTR6r_TXPKTCOUNTf_GET(r) ((r).egrtxpktctr6[0])
#define BCM56504_A0_EGRTXPKTCTR6r_TXPKTCOUNTf_SET(r,f) (r).egrtxpktctr6[0]=((uint32_t)f)

/*
 * These macros can be used to access EGRTXPKTCTR6.
 *
 */
#define BCM56504_A0_READ_EGRTXPKTCTR6r(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_EGRTXPKTCTR6r,(r._egrtxpktctr6))
#define BCM56504_A0_WRITE_EGRTXPKTCTR6r(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_EGRTXPKTCTR6r,&(r._egrtxpktctr6))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGRTXPKTCTR6r BCM56504_A0_EGRTXPKTCTR6r
#define EGRTXPKTCTR6r_SIZE BCM56504_A0_EGRTXPKTCTR6r_SIZE
typedef BCM56504_A0_EGRTXPKTCTR6r_t EGRTXPKTCTR6r_t;
#define EGRTXPKTCTR6r_CLR BCM56504_A0_EGRTXPKTCTR6r_CLR
#define EGRTXPKTCTR6r_SET BCM56504_A0_EGRTXPKTCTR6r_SET
#define EGRTXPKTCTR6r_GET BCM56504_A0_EGRTXPKTCTR6r_GET
#define EGRTXPKTCTR6r_TXPKTCOUNTf_GET BCM56504_A0_EGRTXPKTCTR6r_TXPKTCOUNTf_GET
#define EGRTXPKTCTR6r_TXPKTCOUNTf_SET BCM56504_A0_EGRTXPKTCTR6r_TXPKTCOUNTf_SET
#define READ_EGRTXPKTCTR6r BCM56504_A0_READ_EGRTXPKTCTR6r
#define WRITE_EGRTXPKTCTR6r BCM56504_A0_WRITE_EGRTXPKTCTR6r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_EGRTXPKTCTR6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  EGRTXPKTCTR7
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     TXPKTCOUNT       Transmit Packet Counter: When TXPKTCOUNT_SEL in EGRTXPKTCTR7 is selected, this packet tranmit counter will count all the packets to be tranmitted topre-configured egress port with pre-configurated cos on EGRTXPKTCTRCONFIG7.  
 *
 ******************************************************************************/
#define BCM56504_A0_EGRTXPKTCTR7r 0x0068002f

#define BCM56504_A0_EGRTXPKTCTR7r_SIZE 4

/*
 * This structure should be used to declare and program EGRTXPKTCTR7.
 *
 */
typedef union BCM56504_A0_EGRTXPKTCTR7r_s {
	uint32_t v[1];
	uint32_t egrtxpktctr7[1];
	uint32_t _egrtxpktctr7;
} BCM56504_A0_EGRTXPKTCTR7r_t;

#define BCM56504_A0_EGRTXPKTCTR7r_CLR(r) (r).egrtxpktctr7[0] = 0
#define BCM56504_A0_EGRTXPKTCTR7r_SET(r,d) (r).egrtxpktctr7[0] = d
#define BCM56504_A0_EGRTXPKTCTR7r_GET(r) (r).egrtxpktctr7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_EGRTXPKTCTR7r_TXPKTCOUNTf_GET(r) ((r).egrtxpktctr7[0])
#define BCM56504_A0_EGRTXPKTCTR7r_TXPKTCOUNTf_SET(r,f) (r).egrtxpktctr7[0]=((uint32_t)f)

/*
 * These macros can be used to access EGRTXPKTCTR7.
 *
 */
#define BCM56504_A0_READ_EGRTXPKTCTR7r(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_EGRTXPKTCTR7r,(r._egrtxpktctr7))
#define BCM56504_A0_WRITE_EGRTXPKTCTR7r(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_EGRTXPKTCTR7r,&(r._egrtxpktctr7))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGRTXPKTCTR7r BCM56504_A0_EGRTXPKTCTR7r
#define EGRTXPKTCTR7r_SIZE BCM56504_A0_EGRTXPKTCTR7r_SIZE
typedef BCM56504_A0_EGRTXPKTCTR7r_t EGRTXPKTCTR7r_t;
#define EGRTXPKTCTR7r_CLR BCM56504_A0_EGRTXPKTCTR7r_CLR
#define EGRTXPKTCTR7r_SET BCM56504_A0_EGRTXPKTCTR7r_SET
#define EGRTXPKTCTR7r_GET BCM56504_A0_EGRTXPKTCTR7r_GET
#define EGRTXPKTCTR7r_TXPKTCOUNTf_GET BCM56504_A0_EGRTXPKTCTR7r_TXPKTCOUNTf_GET
#define EGRTXPKTCTR7r_TXPKTCOUNTf_SET BCM56504_A0_EGRTXPKTCTR7r_TXPKTCOUNTf_SET
#define READ_EGRTXPKTCTR7r BCM56504_A0_READ_EGRTXPKTCTR7r
#define WRITE_EGRTXPKTCTR7r BCM56504_A0_WRITE_EGRTXPKTCTR7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_EGRTXPKTCTR7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  EGRTXPKTCTRCONFIG0
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     TXEPORTNUM       Egress port number: When TXPKTCOUNT_EN is selected, this packet tranmitcounter EGRTXPKTCTR0 will count all the packets to be tranmitted to this egress port.  
 *     TXIPORTNUM       Ingress port number: When TXPKTCOUNT_IPORTEN is selected, this packet tranmitcounter EGRTXPKTCTR0 will count all the packets received from this ingress port.  
 *     TXCOSNUM         Egress cos number: When TXPKTCOUNT_EN is aseerted, this packet tranmitcounter EGRTXPKTCTR0 will count all the packets to be tranmitted to pre-configured cos.  
 *     TXPKTCOUNT_SEL   Transmit Packet Counter Select: Select the way EGRTXPKTCTR0 count the packet:2'b00: Disable, not counting.2'b01: Count packets transmit to egress port with cos defined in        TXEPORTNUM and TXCOSNUM2'b10: Count packets receive from ingress port with cos defined in       TXIPORTNUM and TXCOSNUM2'b11: Count packets receive from ingress port and transmit to egress port       with cos defined in TXIPORTNUM, TXEPORTNUM and TXCOSNUM.
 *
 ******************************************************************************/
#define BCM56504_A0_EGRTXPKTCTRCONFIG0r 0x00680020

#define BCM56504_A0_EGRTXPKTCTRCONFIG0r_SIZE 4

/*
 * This structure should be used to declare and program EGRTXPKTCTRCONFIG0.
 *
 */
typedef union BCM56504_A0_EGRTXPKTCTRCONFIG0r_s {
	uint32_t v[1];
	uint32_t egrtxpktctrconfig0[1];
	uint32_t _egrtxpktctrconfig0;
} BCM56504_A0_EGRTXPKTCTRCONFIG0r_t;

#define BCM56504_A0_EGRTXPKTCTRCONFIG0r_CLR(r) (r).egrtxpktctrconfig0[0] = 0
#define BCM56504_A0_EGRTXPKTCTRCONFIG0r_SET(r,d) (r).egrtxpktctrconfig0[0] = d
#define BCM56504_A0_EGRTXPKTCTRCONFIG0r_GET(r) (r).egrtxpktctrconfig0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_EGRTXPKTCTRCONFIG0r_TXEPORTNUMf_GET(r) (((r).egrtxpktctrconfig0[0]) & 0x1f)
#define BCM56504_A0_EGRTXPKTCTRCONFIG0r_TXEPORTNUMf_SET(r,f) (r).egrtxpktctrconfig0[0]=(((r).egrtxpktctrconfig0[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56504_A0_EGRTXPKTCTRCONFIG0r_TXIPORTNUMf_GET(r) ((((r).egrtxpktctrconfig0[0]) >> 5) & 0x1f)
#define BCM56504_A0_EGRTXPKTCTRCONFIG0r_TXIPORTNUMf_SET(r,f) (r).egrtxpktctrconfig0[0]=(((r).egrtxpktctrconfig0[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5))
#define BCM56504_A0_EGRTXPKTCTRCONFIG0r_TXCOSNUMf_GET(r) ((((r).egrtxpktctrconfig0[0]) >> 10) & 0x7)
#define BCM56504_A0_EGRTXPKTCTRCONFIG0r_TXCOSNUMf_SET(r,f) (r).egrtxpktctrconfig0[0]=(((r).egrtxpktctrconfig0[0] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10))
#define BCM56504_A0_EGRTXPKTCTRCONFIG0r_TXPKTCOUNT_SELf_GET(r) ((((r).egrtxpktctrconfig0[0]) >> 13) & 0x3)
#define BCM56504_A0_EGRTXPKTCTRCONFIG0r_TXPKTCOUNT_SELf_SET(r,f) (r).egrtxpktctrconfig0[0]=(((r).egrtxpktctrconfig0[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13))

/*
 * These macros can be used to access EGRTXPKTCTRCONFIG0.
 *
 */
#define BCM56504_A0_READ_EGRTXPKTCTRCONFIG0r(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_EGRTXPKTCTRCONFIG0r,(r._egrtxpktctrconfig0))
#define BCM56504_A0_WRITE_EGRTXPKTCTRCONFIG0r(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_EGRTXPKTCTRCONFIG0r,&(r._egrtxpktctrconfig0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGRTXPKTCTRCONFIG0r BCM56504_A0_EGRTXPKTCTRCONFIG0r
#define EGRTXPKTCTRCONFIG0r_SIZE BCM56504_A0_EGRTXPKTCTRCONFIG0r_SIZE
typedef BCM56504_A0_EGRTXPKTCTRCONFIG0r_t EGRTXPKTCTRCONFIG0r_t;
#define EGRTXPKTCTRCONFIG0r_CLR BCM56504_A0_EGRTXPKTCTRCONFIG0r_CLR
#define EGRTXPKTCTRCONFIG0r_SET BCM56504_A0_EGRTXPKTCTRCONFIG0r_SET
#define EGRTXPKTCTRCONFIG0r_GET BCM56504_A0_EGRTXPKTCTRCONFIG0r_GET
#define EGRTXPKTCTRCONFIG0r_TXEPORTNUMf_GET BCM56504_A0_EGRTXPKTCTRCONFIG0r_TXEPORTNUMf_GET
#define EGRTXPKTCTRCONFIG0r_TXEPORTNUMf_SET BCM56504_A0_EGRTXPKTCTRCONFIG0r_TXEPORTNUMf_SET
#define EGRTXPKTCTRCONFIG0r_TXIPORTNUMf_GET BCM56504_A0_EGRTXPKTCTRCONFIG0r_TXIPORTNUMf_GET
#define EGRTXPKTCTRCONFIG0r_TXIPORTNUMf_SET BCM56504_A0_EGRTXPKTCTRCONFIG0r_TXIPORTNUMf_SET
#define EGRTXPKTCTRCONFIG0r_TXCOSNUMf_GET BCM56504_A0_EGRTXPKTCTRCONFIG0r_TXCOSNUMf_GET
#define EGRTXPKTCTRCONFIG0r_TXCOSNUMf_SET BCM56504_A0_EGRTXPKTCTRCONFIG0r_TXCOSNUMf_SET
#define EGRTXPKTCTRCONFIG0r_TXPKTCOUNT_SELf_GET BCM56504_A0_EGRTXPKTCTRCONFIG0r_TXPKTCOUNT_SELf_GET
#define EGRTXPKTCTRCONFIG0r_TXPKTCOUNT_SELf_SET BCM56504_A0_EGRTXPKTCTRCONFIG0r_TXPKTCOUNT_SELf_SET
#define READ_EGRTXPKTCTRCONFIG0r BCM56504_A0_READ_EGRTXPKTCTRCONFIG0r
#define WRITE_EGRTXPKTCTRCONFIG0r BCM56504_A0_WRITE_EGRTXPKTCTRCONFIG0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_EGRTXPKTCTRCONFIG0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  EGRTXPKTCTRCONFIG1
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     TXEPORTNUM       Egress port number: When TXPKTCOUNT_EN is selected, this packet tranmitcounter EGRTXPKTCTR1 will count all the packets to be tranmitted to this egress port.  
 *     TXIPORTNUM       Ingress port number: When TXPKTCOUNT_IPORTEN is selected, this packet tranmitcounter EGRTXPKTCTR1 will count all the packets received from this ingress port.  
 *     TXCOSNUM         Egress cos number: When TXPKTCOUNT_EN is aseerted, this packet tranmitcounter EGRTXPKTCTR1 will count all the packets to be tranmitted to pre-configured cos.  
 *     TXPKTCOUNT_SEL   Transmit Packet Counter Select: Select the way EGRTXPKTCTR1 count the packet:2'b00: Disable, not counting.2'b01: Count packets transmit to egress port with cos defined in        TXEPORTNUM and TXCOSNUM2'b10: Count packets receive from ingress port with cos defined in       TXIPORTNUM and TXCOSNUM2'b11: Count packets receive from ingress port and transmit to egress port       with cos defined in TXIPORTNUM, TXEPORTNUM and TXCOSNUM.
 *
 ******************************************************************************/
#define BCM56504_A0_EGRTXPKTCTRCONFIG1r 0x00680021

#define BCM56504_A0_EGRTXPKTCTRCONFIG1r_SIZE 4

/*
 * This structure should be used to declare and program EGRTXPKTCTRCONFIG1.
 *
 */
typedef union BCM56504_A0_EGRTXPKTCTRCONFIG1r_s {
	uint32_t v[1];
	uint32_t egrtxpktctrconfig1[1];
	uint32_t _egrtxpktctrconfig1;
} BCM56504_A0_EGRTXPKTCTRCONFIG1r_t;

#define BCM56504_A0_EGRTXPKTCTRCONFIG1r_CLR(r) (r).egrtxpktctrconfig1[0] = 0
#define BCM56504_A0_EGRTXPKTCTRCONFIG1r_SET(r,d) (r).egrtxpktctrconfig1[0] = d
#define BCM56504_A0_EGRTXPKTCTRCONFIG1r_GET(r) (r).egrtxpktctrconfig1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_EGRTXPKTCTRCONFIG1r_TXEPORTNUMf_GET(r) (((r).egrtxpktctrconfig1[0]) & 0x1f)
#define BCM56504_A0_EGRTXPKTCTRCONFIG1r_TXEPORTNUMf_SET(r,f) (r).egrtxpktctrconfig1[0]=(((r).egrtxpktctrconfig1[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56504_A0_EGRTXPKTCTRCONFIG1r_TXIPORTNUMf_GET(r) ((((r).egrtxpktctrconfig1[0]) >> 5) & 0x1f)
#define BCM56504_A0_EGRTXPKTCTRCONFIG1r_TXIPORTNUMf_SET(r,f) (r).egrtxpktctrconfig1[0]=(((r).egrtxpktctrconfig1[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5))
#define BCM56504_A0_EGRTXPKTCTRCONFIG1r_TXCOSNUMf_GET(r) ((((r).egrtxpktctrconfig1[0]) >> 10) & 0x7)
#define BCM56504_A0_EGRTXPKTCTRCONFIG1r_TXCOSNUMf_SET(r,f) (r).egrtxpktctrconfig1[0]=(((r).egrtxpktctrconfig1[0] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10))
#define BCM56504_A0_EGRTXPKTCTRCONFIG1r_TXPKTCOUNT_SELf_GET(r) ((((r).egrtxpktctrconfig1[0]) >> 13) & 0x3)
#define BCM56504_A0_EGRTXPKTCTRCONFIG1r_TXPKTCOUNT_SELf_SET(r,f) (r).egrtxpktctrconfig1[0]=(((r).egrtxpktctrconfig1[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13))

/*
 * These macros can be used to access EGRTXPKTCTRCONFIG1.
 *
 */
#define BCM56504_A0_READ_EGRTXPKTCTRCONFIG1r(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_EGRTXPKTCTRCONFIG1r,(r._egrtxpktctrconfig1))
#define BCM56504_A0_WRITE_EGRTXPKTCTRCONFIG1r(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_EGRTXPKTCTRCONFIG1r,&(r._egrtxpktctrconfig1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGRTXPKTCTRCONFIG1r BCM56504_A0_EGRTXPKTCTRCONFIG1r
#define EGRTXPKTCTRCONFIG1r_SIZE BCM56504_A0_EGRTXPKTCTRCONFIG1r_SIZE
typedef BCM56504_A0_EGRTXPKTCTRCONFIG1r_t EGRTXPKTCTRCONFIG1r_t;
#define EGRTXPKTCTRCONFIG1r_CLR BCM56504_A0_EGRTXPKTCTRCONFIG1r_CLR
#define EGRTXPKTCTRCONFIG1r_SET BCM56504_A0_EGRTXPKTCTRCONFIG1r_SET
#define EGRTXPKTCTRCONFIG1r_GET BCM56504_A0_EGRTXPKTCTRCONFIG1r_GET
#define EGRTXPKTCTRCONFIG1r_TXEPORTNUMf_GET BCM56504_A0_EGRTXPKTCTRCONFIG1r_TXEPORTNUMf_GET
#define EGRTXPKTCTRCONFIG1r_TXEPORTNUMf_SET BCM56504_A0_EGRTXPKTCTRCONFIG1r_TXEPORTNUMf_SET
#define EGRTXPKTCTRCONFIG1r_TXIPORTNUMf_GET BCM56504_A0_EGRTXPKTCTRCONFIG1r_TXIPORTNUMf_GET
#define EGRTXPKTCTRCONFIG1r_TXIPORTNUMf_SET BCM56504_A0_EGRTXPKTCTRCONFIG1r_TXIPORTNUMf_SET
#define EGRTXPKTCTRCONFIG1r_TXCOSNUMf_GET BCM56504_A0_EGRTXPKTCTRCONFIG1r_TXCOSNUMf_GET
#define EGRTXPKTCTRCONFIG1r_TXCOSNUMf_SET BCM56504_A0_EGRTXPKTCTRCONFIG1r_TXCOSNUMf_SET
#define EGRTXPKTCTRCONFIG1r_TXPKTCOUNT_SELf_GET BCM56504_A0_EGRTXPKTCTRCONFIG1r_TXPKTCOUNT_SELf_GET
#define EGRTXPKTCTRCONFIG1r_TXPKTCOUNT_SELf_SET BCM56504_A0_EGRTXPKTCTRCONFIG1r_TXPKTCOUNT_SELf_SET
#define READ_EGRTXPKTCTRCONFIG1r BCM56504_A0_READ_EGRTXPKTCTRCONFIG1r
#define WRITE_EGRTXPKTCTRCONFIG1r BCM56504_A0_WRITE_EGRTXPKTCTRCONFIG1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_EGRTXPKTCTRCONFIG1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  EGRTXPKTCTRCONFIG2
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     TXEPORTNUM       Egress port number: When TXPKTCOUNT_EN is selected, this packet tranmitcounter EGRTXPKTCTR2 will count all the packets to be tranmitted to this egress port.  
 *     TXIPORTNUM       Ingress port number: When TXPKTCOUNT_IPORTEN is selected, this packet tranmitcounter EGRTXPKTCTR2 will count all the packets received from this ingress port.  
 *     TXCOSNUM         Egress cos number: When TXPKTCOUNT_EN is aseerted, this packet tranmitcounter EGRTXPKTCTR2 will count all the packets to be tranmitted to pre-configured cos.  
 *     TXPKTCOUNT_SEL   Transmit Packet Counter Select: Select the way EGRTXPKTCTR2 count the packet:2'b00: Disable, not counting.2'b01: Count packets transmit to egress port with cos defined in        TXEPORTNUM and TXCOSNUM2'b10: Count packets receive from ingress port with cos defined in       TXIPORTNUM and TXCOSNUM2'b11: Count packets receive from ingress port and transmit to egress port       with cos defined in TXIPORTNUM, TXEPORTNUM and TXCOSNUM.
 *
 ******************************************************************************/
#define BCM56504_A0_EGRTXPKTCTRCONFIG2r 0x00680022

#define BCM56504_A0_EGRTXPKTCTRCONFIG2r_SIZE 4

/*
 * This structure should be used to declare and program EGRTXPKTCTRCONFIG2.
 *
 */
typedef union BCM56504_A0_EGRTXPKTCTRCONFIG2r_s {
	uint32_t v[1];
	uint32_t egrtxpktctrconfig2[1];
	uint32_t _egrtxpktctrconfig2;
} BCM56504_A0_EGRTXPKTCTRCONFIG2r_t;

#define BCM56504_A0_EGRTXPKTCTRCONFIG2r_CLR(r) (r).egrtxpktctrconfig2[0] = 0
#define BCM56504_A0_EGRTXPKTCTRCONFIG2r_SET(r,d) (r).egrtxpktctrconfig2[0] = d
#define BCM56504_A0_EGRTXPKTCTRCONFIG2r_GET(r) (r).egrtxpktctrconfig2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_EGRTXPKTCTRCONFIG2r_TXEPORTNUMf_GET(r) (((r).egrtxpktctrconfig2[0]) & 0x1f)
#define BCM56504_A0_EGRTXPKTCTRCONFIG2r_TXEPORTNUMf_SET(r,f) (r).egrtxpktctrconfig2[0]=(((r).egrtxpktctrconfig2[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56504_A0_EGRTXPKTCTRCONFIG2r_TXIPORTNUMf_GET(r) ((((r).egrtxpktctrconfig2[0]) >> 5) & 0x1f)
#define BCM56504_A0_EGRTXPKTCTRCONFIG2r_TXIPORTNUMf_SET(r,f) (r).egrtxpktctrconfig2[0]=(((r).egrtxpktctrconfig2[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5))
#define BCM56504_A0_EGRTXPKTCTRCONFIG2r_TXCOSNUMf_GET(r) ((((r).egrtxpktctrconfig2[0]) >> 10) & 0x7)
#define BCM56504_A0_EGRTXPKTCTRCONFIG2r_TXCOSNUMf_SET(r,f) (r).egrtxpktctrconfig2[0]=(((r).egrtxpktctrconfig2[0] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10))
#define BCM56504_A0_EGRTXPKTCTRCONFIG2r_TXPKTCOUNT_SELf_GET(r) ((((r).egrtxpktctrconfig2[0]) >> 13) & 0x3)
#define BCM56504_A0_EGRTXPKTCTRCONFIG2r_TXPKTCOUNT_SELf_SET(r,f) (r).egrtxpktctrconfig2[0]=(((r).egrtxpktctrconfig2[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13))

/*
 * These macros can be used to access EGRTXPKTCTRCONFIG2.
 *
 */
#define BCM56504_A0_READ_EGRTXPKTCTRCONFIG2r(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_EGRTXPKTCTRCONFIG2r,(r._egrtxpktctrconfig2))
#define BCM56504_A0_WRITE_EGRTXPKTCTRCONFIG2r(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_EGRTXPKTCTRCONFIG2r,&(r._egrtxpktctrconfig2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGRTXPKTCTRCONFIG2r BCM56504_A0_EGRTXPKTCTRCONFIG2r
#define EGRTXPKTCTRCONFIG2r_SIZE BCM56504_A0_EGRTXPKTCTRCONFIG2r_SIZE
typedef BCM56504_A0_EGRTXPKTCTRCONFIG2r_t EGRTXPKTCTRCONFIG2r_t;
#define EGRTXPKTCTRCONFIG2r_CLR BCM56504_A0_EGRTXPKTCTRCONFIG2r_CLR
#define EGRTXPKTCTRCONFIG2r_SET BCM56504_A0_EGRTXPKTCTRCONFIG2r_SET
#define EGRTXPKTCTRCONFIG2r_GET BCM56504_A0_EGRTXPKTCTRCONFIG2r_GET
#define EGRTXPKTCTRCONFIG2r_TXEPORTNUMf_GET BCM56504_A0_EGRTXPKTCTRCONFIG2r_TXEPORTNUMf_GET
#define EGRTXPKTCTRCONFIG2r_TXEPORTNUMf_SET BCM56504_A0_EGRTXPKTCTRCONFIG2r_TXEPORTNUMf_SET
#define EGRTXPKTCTRCONFIG2r_TXIPORTNUMf_GET BCM56504_A0_EGRTXPKTCTRCONFIG2r_TXIPORTNUMf_GET
#define EGRTXPKTCTRCONFIG2r_TXIPORTNUMf_SET BCM56504_A0_EGRTXPKTCTRCONFIG2r_TXIPORTNUMf_SET
#define EGRTXPKTCTRCONFIG2r_TXCOSNUMf_GET BCM56504_A0_EGRTXPKTCTRCONFIG2r_TXCOSNUMf_GET
#define EGRTXPKTCTRCONFIG2r_TXCOSNUMf_SET BCM56504_A0_EGRTXPKTCTRCONFIG2r_TXCOSNUMf_SET
#define EGRTXPKTCTRCONFIG2r_TXPKTCOUNT_SELf_GET BCM56504_A0_EGRTXPKTCTRCONFIG2r_TXPKTCOUNT_SELf_GET
#define EGRTXPKTCTRCONFIG2r_TXPKTCOUNT_SELf_SET BCM56504_A0_EGRTXPKTCTRCONFIG2r_TXPKTCOUNT_SELf_SET
#define READ_EGRTXPKTCTRCONFIG2r BCM56504_A0_READ_EGRTXPKTCTRCONFIG2r
#define WRITE_EGRTXPKTCTRCONFIG2r BCM56504_A0_WRITE_EGRTXPKTCTRCONFIG2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_EGRTXPKTCTRCONFIG2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  EGRTXPKTCTRCONFIG3
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     TXEPORTNUM       Egress port number: When TXPKTCOUNT_EN is selected, this packet tranmitcounter EGRTXPKTCTR3 will count all the packets to be tranmitted to this egress port.  
 *     TXIPORTNUM       Ingress port number: When TXPKTCOUNT_IPORTEN is selected, this packet tranmitcounter EGRTXPKTCTR3 will count all the packets received from this ingress port.  
 *     TXCOSNUM         Egress cos number: When TXPKTCOUNT_EN is aseerted, this packet tranmitcounter EGRTXPKTCTR3 will count all the packets to be tranmitted to pre-configured cos.  
 *     TXPKTCOUNT_SEL   Transmit Packet Counter Select: Select the way EGRTXPKTCTR3 count the packet:2'b00: Disable, not counting.2'b01: Count packets transmit to egress port with cos defined in        TXEPORTNUM and TXCOSNUM2'b10: Count packets receive from ingress port with cos defined in       TXIPORTNUM and TXCOSNUM2'b11: Count packets receive from ingress port and transmit to egress port       with cos defined in TXIPORTNUM, TXEPORTNUM and TXCOSNUM.
 *
 ******************************************************************************/
#define BCM56504_A0_EGRTXPKTCTRCONFIG3r 0x00680023

#define BCM56504_A0_EGRTXPKTCTRCONFIG3r_SIZE 4

/*
 * This structure should be used to declare and program EGRTXPKTCTRCONFIG3.
 *
 */
typedef union BCM56504_A0_EGRTXPKTCTRCONFIG3r_s {
	uint32_t v[1];
	uint32_t egrtxpktctrconfig3[1];
	uint32_t _egrtxpktctrconfig3;
} BCM56504_A0_EGRTXPKTCTRCONFIG3r_t;

#define BCM56504_A0_EGRTXPKTCTRCONFIG3r_CLR(r) (r).egrtxpktctrconfig3[0] = 0
#define BCM56504_A0_EGRTXPKTCTRCONFIG3r_SET(r,d) (r).egrtxpktctrconfig3[0] = d
#define BCM56504_A0_EGRTXPKTCTRCONFIG3r_GET(r) (r).egrtxpktctrconfig3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_EGRTXPKTCTRCONFIG3r_TXEPORTNUMf_GET(r) (((r).egrtxpktctrconfig3[0]) & 0x1f)
#define BCM56504_A0_EGRTXPKTCTRCONFIG3r_TXEPORTNUMf_SET(r,f) (r).egrtxpktctrconfig3[0]=(((r).egrtxpktctrconfig3[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56504_A0_EGRTXPKTCTRCONFIG3r_TXIPORTNUMf_GET(r) ((((r).egrtxpktctrconfig3[0]) >> 5) & 0x1f)
#define BCM56504_A0_EGRTXPKTCTRCONFIG3r_TXIPORTNUMf_SET(r,f) (r).egrtxpktctrconfig3[0]=(((r).egrtxpktctrconfig3[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5))
#define BCM56504_A0_EGRTXPKTCTRCONFIG3r_TXCOSNUMf_GET(r) ((((r).egrtxpktctrconfig3[0]) >> 10) & 0x7)
#define BCM56504_A0_EGRTXPKTCTRCONFIG3r_TXCOSNUMf_SET(r,f) (r).egrtxpktctrconfig3[0]=(((r).egrtxpktctrconfig3[0] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10))
#define BCM56504_A0_EGRTXPKTCTRCONFIG3r_TXPKTCOUNT_SELf_GET(r) ((((r).egrtxpktctrconfig3[0]) >> 13) & 0x3)
#define BCM56504_A0_EGRTXPKTCTRCONFIG3r_TXPKTCOUNT_SELf_SET(r,f) (r).egrtxpktctrconfig3[0]=(((r).egrtxpktctrconfig3[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13))

/*
 * These macros can be used to access EGRTXPKTCTRCONFIG3.
 *
 */
#define BCM56504_A0_READ_EGRTXPKTCTRCONFIG3r(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_EGRTXPKTCTRCONFIG3r,(r._egrtxpktctrconfig3))
#define BCM56504_A0_WRITE_EGRTXPKTCTRCONFIG3r(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_EGRTXPKTCTRCONFIG3r,&(r._egrtxpktctrconfig3))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGRTXPKTCTRCONFIG3r BCM56504_A0_EGRTXPKTCTRCONFIG3r
#define EGRTXPKTCTRCONFIG3r_SIZE BCM56504_A0_EGRTXPKTCTRCONFIG3r_SIZE
typedef BCM56504_A0_EGRTXPKTCTRCONFIG3r_t EGRTXPKTCTRCONFIG3r_t;
#define EGRTXPKTCTRCONFIG3r_CLR BCM56504_A0_EGRTXPKTCTRCONFIG3r_CLR
#define EGRTXPKTCTRCONFIG3r_SET BCM56504_A0_EGRTXPKTCTRCONFIG3r_SET
#define EGRTXPKTCTRCONFIG3r_GET BCM56504_A0_EGRTXPKTCTRCONFIG3r_GET
#define EGRTXPKTCTRCONFIG3r_TXEPORTNUMf_GET BCM56504_A0_EGRTXPKTCTRCONFIG3r_TXEPORTNUMf_GET
#define EGRTXPKTCTRCONFIG3r_TXEPORTNUMf_SET BCM56504_A0_EGRTXPKTCTRCONFIG3r_TXEPORTNUMf_SET
#define EGRTXPKTCTRCONFIG3r_TXIPORTNUMf_GET BCM56504_A0_EGRTXPKTCTRCONFIG3r_TXIPORTNUMf_GET
#define EGRTXPKTCTRCONFIG3r_TXIPORTNUMf_SET BCM56504_A0_EGRTXPKTCTRCONFIG3r_TXIPORTNUMf_SET
#define EGRTXPKTCTRCONFIG3r_TXCOSNUMf_GET BCM56504_A0_EGRTXPKTCTRCONFIG3r_TXCOSNUMf_GET
#define EGRTXPKTCTRCONFIG3r_TXCOSNUMf_SET BCM56504_A0_EGRTXPKTCTRCONFIG3r_TXCOSNUMf_SET
#define EGRTXPKTCTRCONFIG3r_TXPKTCOUNT_SELf_GET BCM56504_A0_EGRTXPKTCTRCONFIG3r_TXPKTCOUNT_SELf_GET
#define EGRTXPKTCTRCONFIG3r_TXPKTCOUNT_SELf_SET BCM56504_A0_EGRTXPKTCTRCONFIG3r_TXPKTCOUNT_SELf_SET
#define READ_EGRTXPKTCTRCONFIG3r BCM56504_A0_READ_EGRTXPKTCTRCONFIG3r
#define WRITE_EGRTXPKTCTRCONFIG3r BCM56504_A0_WRITE_EGRTXPKTCTRCONFIG3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_EGRTXPKTCTRCONFIG3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  EGRTXPKTCTRCONFIG4
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     TXEPORTNUM       Egress port number: When TXPKTCOUNT_EN is selected, this packet tranmitcounter EGRTXPKTCTR4 will count all the packets to be tranmitted to this egress port.  
 *     TXIPORTNUM       Ingress port number: When TXPKTCOUNT_IPORTEN is selected, this packet tranmitcounter EGRTXPKTCTR4 will count all the packets received from this ingress port.  
 *     TXCOSNUM         Egress cos number: When TXPKTCOUNT_EN is aseerted, this packet tranmitcounter EGRTXPKTCTR4 will count all the packets to be tranmitted to pre-configured cos.  
 *     TXPKTCOUNT_SEL   Transmit Packet Counter Select: Select the way EGRTXPKTCTR4 count the packet:2'b00: Disable, not counting.2'b01: Count packets transmit to egress port with cos defined in        TXEPORTNUM and TXCOSNUM2'b10: Count packets receive from ingress port with cos defined in       TXIPORTNUM and TXCOSNUM2'b11: Count packets receive from ingress port and transmit to egress port       with cos defined in TXIPORTNUM, TXEPORTNUM and TXCOSNUM.
 *
 ******************************************************************************/
#define BCM56504_A0_EGRTXPKTCTRCONFIG4r 0x00680024

#define BCM56504_A0_EGRTXPKTCTRCONFIG4r_SIZE 4

/*
 * This structure should be used to declare and program EGRTXPKTCTRCONFIG4.
 *
 */
typedef union BCM56504_A0_EGRTXPKTCTRCONFIG4r_s {
	uint32_t v[1];
	uint32_t egrtxpktctrconfig4[1];
	uint32_t _egrtxpktctrconfig4;
} BCM56504_A0_EGRTXPKTCTRCONFIG4r_t;

#define BCM56504_A0_EGRTXPKTCTRCONFIG4r_CLR(r) (r).egrtxpktctrconfig4[0] = 0
#define BCM56504_A0_EGRTXPKTCTRCONFIG4r_SET(r,d) (r).egrtxpktctrconfig4[0] = d
#define BCM56504_A0_EGRTXPKTCTRCONFIG4r_GET(r) (r).egrtxpktctrconfig4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_EGRTXPKTCTRCONFIG4r_TXEPORTNUMf_GET(r) (((r).egrtxpktctrconfig4[0]) & 0x1f)
#define BCM56504_A0_EGRTXPKTCTRCONFIG4r_TXEPORTNUMf_SET(r,f) (r).egrtxpktctrconfig4[0]=(((r).egrtxpktctrconfig4[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56504_A0_EGRTXPKTCTRCONFIG4r_TXIPORTNUMf_GET(r) ((((r).egrtxpktctrconfig4[0]) >> 5) & 0x1f)
#define BCM56504_A0_EGRTXPKTCTRCONFIG4r_TXIPORTNUMf_SET(r,f) (r).egrtxpktctrconfig4[0]=(((r).egrtxpktctrconfig4[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5))
#define BCM56504_A0_EGRTXPKTCTRCONFIG4r_TXCOSNUMf_GET(r) ((((r).egrtxpktctrconfig4[0]) >> 10) & 0x7)
#define BCM56504_A0_EGRTXPKTCTRCONFIG4r_TXCOSNUMf_SET(r,f) (r).egrtxpktctrconfig4[0]=(((r).egrtxpktctrconfig4[0] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10))
#define BCM56504_A0_EGRTXPKTCTRCONFIG4r_TXPKTCOUNT_SELf_GET(r) ((((r).egrtxpktctrconfig4[0]) >> 13) & 0x3)
#define BCM56504_A0_EGRTXPKTCTRCONFIG4r_TXPKTCOUNT_SELf_SET(r,f) (r).egrtxpktctrconfig4[0]=(((r).egrtxpktctrconfig4[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13))

/*
 * These macros can be used to access EGRTXPKTCTRCONFIG4.
 *
 */
#define BCM56504_A0_READ_EGRTXPKTCTRCONFIG4r(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_EGRTXPKTCTRCONFIG4r,(r._egrtxpktctrconfig4))
#define BCM56504_A0_WRITE_EGRTXPKTCTRCONFIG4r(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_EGRTXPKTCTRCONFIG4r,&(r._egrtxpktctrconfig4))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGRTXPKTCTRCONFIG4r BCM56504_A0_EGRTXPKTCTRCONFIG4r
#define EGRTXPKTCTRCONFIG4r_SIZE BCM56504_A0_EGRTXPKTCTRCONFIG4r_SIZE
typedef BCM56504_A0_EGRTXPKTCTRCONFIG4r_t EGRTXPKTCTRCONFIG4r_t;
#define EGRTXPKTCTRCONFIG4r_CLR BCM56504_A0_EGRTXPKTCTRCONFIG4r_CLR
#define EGRTXPKTCTRCONFIG4r_SET BCM56504_A0_EGRTXPKTCTRCONFIG4r_SET
#define EGRTXPKTCTRCONFIG4r_GET BCM56504_A0_EGRTXPKTCTRCONFIG4r_GET
#define EGRTXPKTCTRCONFIG4r_TXEPORTNUMf_GET BCM56504_A0_EGRTXPKTCTRCONFIG4r_TXEPORTNUMf_GET
#define EGRTXPKTCTRCONFIG4r_TXEPORTNUMf_SET BCM56504_A0_EGRTXPKTCTRCONFIG4r_TXEPORTNUMf_SET
#define EGRTXPKTCTRCONFIG4r_TXIPORTNUMf_GET BCM56504_A0_EGRTXPKTCTRCONFIG4r_TXIPORTNUMf_GET
#define EGRTXPKTCTRCONFIG4r_TXIPORTNUMf_SET BCM56504_A0_EGRTXPKTCTRCONFIG4r_TXIPORTNUMf_SET
#define EGRTXPKTCTRCONFIG4r_TXCOSNUMf_GET BCM56504_A0_EGRTXPKTCTRCONFIG4r_TXCOSNUMf_GET
#define EGRTXPKTCTRCONFIG4r_TXCOSNUMf_SET BCM56504_A0_EGRTXPKTCTRCONFIG4r_TXCOSNUMf_SET
#define EGRTXPKTCTRCONFIG4r_TXPKTCOUNT_SELf_GET BCM56504_A0_EGRTXPKTCTRCONFIG4r_TXPKTCOUNT_SELf_GET
#define EGRTXPKTCTRCONFIG4r_TXPKTCOUNT_SELf_SET BCM56504_A0_EGRTXPKTCTRCONFIG4r_TXPKTCOUNT_SELf_SET
#define READ_EGRTXPKTCTRCONFIG4r BCM56504_A0_READ_EGRTXPKTCTRCONFIG4r
#define WRITE_EGRTXPKTCTRCONFIG4r BCM56504_A0_WRITE_EGRTXPKTCTRCONFIG4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_EGRTXPKTCTRCONFIG4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  EGRTXPKTCTRCONFIG5
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     TXEPORTNUM       Egress port number: When TXPKTCOUNT_EN is selected, this packet tranmitcounter EGRTXPKTCTR5 will count all the packets to be tranmitted to this egress port.  
 *     TXIPORTNUM       Ingress port number: When TXPKTCOUNT_IPORTEN is selected, this packet tranmitcounter EGRTXPKTCTR5 will count all the packets received from this ingress port.  
 *     TXCOSNUM         Egress cos number: When TXPKTCOUNT_EN is aseerted, this packet tranmitcounter EGRTXPKTCTR5 will count all the packets to be tranmitted to pre-configured cos.  
 *     TXPKTCOUNT_SEL   Transmit Packet Counter Select: Select the way EGRTXPKTCTR5 count the packet:2'b00: Disable, not counting.2'b01: Count packets transmit to egress port with cos defined in        TXEPORTNUM and TXCOSNUM2'b10: Count packets receive from ingress port with cos defined in       TXIPORTNUM and TXCOSNUM2'b11: Count packets receive from ingress port and transmit to egress port       with cos defined in TXIPORTNUM, TXEPORTNUM and TXCOSNUM.
 *
 ******************************************************************************/
#define BCM56504_A0_EGRTXPKTCTRCONFIG5r 0x00680025

#define BCM56504_A0_EGRTXPKTCTRCONFIG5r_SIZE 4

/*
 * This structure should be used to declare and program EGRTXPKTCTRCONFIG5.
 *
 */
typedef union BCM56504_A0_EGRTXPKTCTRCONFIG5r_s {
	uint32_t v[1];
	uint32_t egrtxpktctrconfig5[1];
	uint32_t _egrtxpktctrconfig5;
} BCM56504_A0_EGRTXPKTCTRCONFIG5r_t;

#define BCM56504_A0_EGRTXPKTCTRCONFIG5r_CLR(r) (r).egrtxpktctrconfig5[0] = 0
#define BCM56504_A0_EGRTXPKTCTRCONFIG5r_SET(r,d) (r).egrtxpktctrconfig5[0] = d
#define BCM56504_A0_EGRTXPKTCTRCONFIG5r_GET(r) (r).egrtxpktctrconfig5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_EGRTXPKTCTRCONFIG5r_TXEPORTNUMf_GET(r) (((r).egrtxpktctrconfig5[0]) & 0x1f)
#define BCM56504_A0_EGRTXPKTCTRCONFIG5r_TXEPORTNUMf_SET(r,f) (r).egrtxpktctrconfig5[0]=(((r).egrtxpktctrconfig5[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56504_A0_EGRTXPKTCTRCONFIG5r_TXIPORTNUMf_GET(r) ((((r).egrtxpktctrconfig5[0]) >> 5) & 0x1f)
#define BCM56504_A0_EGRTXPKTCTRCONFIG5r_TXIPORTNUMf_SET(r,f) (r).egrtxpktctrconfig5[0]=(((r).egrtxpktctrconfig5[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5))
#define BCM56504_A0_EGRTXPKTCTRCONFIG5r_TXCOSNUMf_GET(r) ((((r).egrtxpktctrconfig5[0]) >> 10) & 0x7)
#define BCM56504_A0_EGRTXPKTCTRCONFIG5r_TXCOSNUMf_SET(r,f) (r).egrtxpktctrconfig5[0]=(((r).egrtxpktctrconfig5[0] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10))
#define BCM56504_A0_EGRTXPKTCTRCONFIG5r_TXPKTCOUNT_SELf_GET(r) ((((r).egrtxpktctrconfig5[0]) >> 13) & 0x3)
#define BCM56504_A0_EGRTXPKTCTRCONFIG5r_TXPKTCOUNT_SELf_SET(r,f) (r).egrtxpktctrconfig5[0]=(((r).egrtxpktctrconfig5[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13))

/*
 * These macros can be used to access EGRTXPKTCTRCONFIG5.
 *
 */
#define BCM56504_A0_READ_EGRTXPKTCTRCONFIG5r(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_EGRTXPKTCTRCONFIG5r,(r._egrtxpktctrconfig5))
#define BCM56504_A0_WRITE_EGRTXPKTCTRCONFIG5r(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_EGRTXPKTCTRCONFIG5r,&(r._egrtxpktctrconfig5))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGRTXPKTCTRCONFIG5r BCM56504_A0_EGRTXPKTCTRCONFIG5r
#define EGRTXPKTCTRCONFIG5r_SIZE BCM56504_A0_EGRTXPKTCTRCONFIG5r_SIZE
typedef BCM56504_A0_EGRTXPKTCTRCONFIG5r_t EGRTXPKTCTRCONFIG5r_t;
#define EGRTXPKTCTRCONFIG5r_CLR BCM56504_A0_EGRTXPKTCTRCONFIG5r_CLR
#define EGRTXPKTCTRCONFIG5r_SET BCM56504_A0_EGRTXPKTCTRCONFIG5r_SET
#define EGRTXPKTCTRCONFIG5r_GET BCM56504_A0_EGRTXPKTCTRCONFIG5r_GET
#define EGRTXPKTCTRCONFIG5r_TXEPORTNUMf_GET BCM56504_A0_EGRTXPKTCTRCONFIG5r_TXEPORTNUMf_GET
#define EGRTXPKTCTRCONFIG5r_TXEPORTNUMf_SET BCM56504_A0_EGRTXPKTCTRCONFIG5r_TXEPORTNUMf_SET
#define EGRTXPKTCTRCONFIG5r_TXIPORTNUMf_GET BCM56504_A0_EGRTXPKTCTRCONFIG5r_TXIPORTNUMf_GET
#define EGRTXPKTCTRCONFIG5r_TXIPORTNUMf_SET BCM56504_A0_EGRTXPKTCTRCONFIG5r_TXIPORTNUMf_SET
#define EGRTXPKTCTRCONFIG5r_TXCOSNUMf_GET BCM56504_A0_EGRTXPKTCTRCONFIG5r_TXCOSNUMf_GET
#define EGRTXPKTCTRCONFIG5r_TXCOSNUMf_SET BCM56504_A0_EGRTXPKTCTRCONFIG5r_TXCOSNUMf_SET
#define EGRTXPKTCTRCONFIG5r_TXPKTCOUNT_SELf_GET BCM56504_A0_EGRTXPKTCTRCONFIG5r_TXPKTCOUNT_SELf_GET
#define EGRTXPKTCTRCONFIG5r_TXPKTCOUNT_SELf_SET BCM56504_A0_EGRTXPKTCTRCONFIG5r_TXPKTCOUNT_SELf_SET
#define READ_EGRTXPKTCTRCONFIG5r BCM56504_A0_READ_EGRTXPKTCTRCONFIG5r
#define WRITE_EGRTXPKTCTRCONFIG5r BCM56504_A0_WRITE_EGRTXPKTCTRCONFIG5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_EGRTXPKTCTRCONFIG5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  EGRTXPKTCTRCONFIG6
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     TXEPORTNUM       Egress port number: When TXPKTCOUNT_EN is selected, this packet tranmitcounter EGRTXPKTCTR6 will count all the packets to be tranmitted to this egress port.  
 *     TXIPORTNUM       Ingress port number: When TXPKTCOUNT_IPORTEN is selected, this packet tranmitcounter EGRTXPKTCTR6 will count all the packets received from this ingress port.  
 *     TXCOSNUM         Egress cos number: When TXPKTCOUNT_EN is aseerted, this packet tranmitcounter EGRTXPKTCTR6 will count all the packets to be tranmitted to pre-configured cos.  
 *     TXPKTCOUNT_SEL   Transmit Packet Counter Select: Select the way EGRTXPKTCTR6 count the packet:2'b00: Disable, not counting.2'b01: Count packets transmit to egress port with cos defined in        TXEPORTNUM and TXCOSNUM2'b10: Count packets receive from ingress port with cos defined in       TXIPORTNUM and TXCOSNUM2'b11: Count packets receive from ingress port and transmit to egress port       with cos defined in TXIPORTNUM, TXEPORTNUM and TXCOSNUM.
 *
 ******************************************************************************/
#define BCM56504_A0_EGRTXPKTCTRCONFIG6r 0x00680026

#define BCM56504_A0_EGRTXPKTCTRCONFIG6r_SIZE 4

/*
 * This structure should be used to declare and program EGRTXPKTCTRCONFIG6.
 *
 */
typedef union BCM56504_A0_EGRTXPKTCTRCONFIG6r_s {
	uint32_t v[1];
	uint32_t egrtxpktctrconfig6[1];
	uint32_t _egrtxpktctrconfig6;
} BCM56504_A0_EGRTXPKTCTRCONFIG6r_t;

#define BCM56504_A0_EGRTXPKTCTRCONFIG6r_CLR(r) (r).egrtxpktctrconfig6[0] = 0
#define BCM56504_A0_EGRTXPKTCTRCONFIG6r_SET(r,d) (r).egrtxpktctrconfig6[0] = d
#define BCM56504_A0_EGRTXPKTCTRCONFIG6r_GET(r) (r).egrtxpktctrconfig6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_EGRTXPKTCTRCONFIG6r_TXEPORTNUMf_GET(r) (((r).egrtxpktctrconfig6[0]) & 0x1f)
#define BCM56504_A0_EGRTXPKTCTRCONFIG6r_TXEPORTNUMf_SET(r,f) (r).egrtxpktctrconfig6[0]=(((r).egrtxpktctrconfig6[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56504_A0_EGRTXPKTCTRCONFIG6r_TXIPORTNUMf_GET(r) ((((r).egrtxpktctrconfig6[0]) >> 5) & 0x1f)
#define BCM56504_A0_EGRTXPKTCTRCONFIG6r_TXIPORTNUMf_SET(r,f) (r).egrtxpktctrconfig6[0]=(((r).egrtxpktctrconfig6[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5))
#define BCM56504_A0_EGRTXPKTCTRCONFIG6r_TXCOSNUMf_GET(r) ((((r).egrtxpktctrconfig6[0]) >> 10) & 0x7)
#define BCM56504_A0_EGRTXPKTCTRCONFIG6r_TXCOSNUMf_SET(r,f) (r).egrtxpktctrconfig6[0]=(((r).egrtxpktctrconfig6[0] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10))
#define BCM56504_A0_EGRTXPKTCTRCONFIG6r_TXPKTCOUNT_SELf_GET(r) ((((r).egrtxpktctrconfig6[0]) >> 13) & 0x3)
#define BCM56504_A0_EGRTXPKTCTRCONFIG6r_TXPKTCOUNT_SELf_SET(r,f) (r).egrtxpktctrconfig6[0]=(((r).egrtxpktctrconfig6[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13))

/*
 * These macros can be used to access EGRTXPKTCTRCONFIG6.
 *
 */
#define BCM56504_A0_READ_EGRTXPKTCTRCONFIG6r(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_EGRTXPKTCTRCONFIG6r,(r._egrtxpktctrconfig6))
#define BCM56504_A0_WRITE_EGRTXPKTCTRCONFIG6r(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_EGRTXPKTCTRCONFIG6r,&(r._egrtxpktctrconfig6))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGRTXPKTCTRCONFIG6r BCM56504_A0_EGRTXPKTCTRCONFIG6r
#define EGRTXPKTCTRCONFIG6r_SIZE BCM56504_A0_EGRTXPKTCTRCONFIG6r_SIZE
typedef BCM56504_A0_EGRTXPKTCTRCONFIG6r_t EGRTXPKTCTRCONFIG6r_t;
#define EGRTXPKTCTRCONFIG6r_CLR BCM56504_A0_EGRTXPKTCTRCONFIG6r_CLR
#define EGRTXPKTCTRCONFIG6r_SET BCM56504_A0_EGRTXPKTCTRCONFIG6r_SET
#define EGRTXPKTCTRCONFIG6r_GET BCM56504_A0_EGRTXPKTCTRCONFIG6r_GET
#define EGRTXPKTCTRCONFIG6r_TXEPORTNUMf_GET BCM56504_A0_EGRTXPKTCTRCONFIG6r_TXEPORTNUMf_GET
#define EGRTXPKTCTRCONFIG6r_TXEPORTNUMf_SET BCM56504_A0_EGRTXPKTCTRCONFIG6r_TXEPORTNUMf_SET
#define EGRTXPKTCTRCONFIG6r_TXIPORTNUMf_GET BCM56504_A0_EGRTXPKTCTRCONFIG6r_TXIPORTNUMf_GET
#define EGRTXPKTCTRCONFIG6r_TXIPORTNUMf_SET BCM56504_A0_EGRTXPKTCTRCONFIG6r_TXIPORTNUMf_SET
#define EGRTXPKTCTRCONFIG6r_TXCOSNUMf_GET BCM56504_A0_EGRTXPKTCTRCONFIG6r_TXCOSNUMf_GET
#define EGRTXPKTCTRCONFIG6r_TXCOSNUMf_SET BCM56504_A0_EGRTXPKTCTRCONFIG6r_TXCOSNUMf_SET
#define EGRTXPKTCTRCONFIG6r_TXPKTCOUNT_SELf_GET BCM56504_A0_EGRTXPKTCTRCONFIG6r_TXPKTCOUNT_SELf_GET
#define EGRTXPKTCTRCONFIG6r_TXPKTCOUNT_SELf_SET BCM56504_A0_EGRTXPKTCTRCONFIG6r_TXPKTCOUNT_SELf_SET
#define READ_EGRTXPKTCTRCONFIG6r BCM56504_A0_READ_EGRTXPKTCTRCONFIG6r
#define WRITE_EGRTXPKTCTRCONFIG6r BCM56504_A0_WRITE_EGRTXPKTCTRCONFIG6r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_EGRTXPKTCTRCONFIG6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  EGRTXPKTCTRCONFIG7
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     TXEPORTNUM       Egress port number: When TXPKTCOUNT_EN is selected, this packet tranmitcounter EGRTXPKTCTR7 will count all the packets to be tranmitted to this egress port.  
 *     TXIPORTNUM       Ingress port number: When TXPKTCOUNT_IPORTEN is selected, this packet tranmitcounter EGRTXPKTCTR7 will count all the packets received from this ingress port.  
 *     TXCOSNUM         Egress cos number: When TXPKTCOUNT_EN is aseerted, this packet tranmitcounter EGRTXPKTCTR7 will count all the packets to be tranmitted to pre-configured cos.  
 *     TXPKTCOUNT_SEL   Transmit Packet Counter Select: Select the way EGRTXPKTCTR7 count the packet:2'b00: Disable, not counting.2'b01: Count packets transmit to egress port with cos defined in        TXEPORTNUM and TXCOSNUM2'b10: Count packets receive from ingress port with cos defined in       TXIPORTNUM and TXCOSNUM2'b11: Count packets receive from ingress port and transmit to egress port       with cos defined in TXIPORTNUM, TXEPORTNUM and TXCOSNUM.
 *
 ******************************************************************************/
#define BCM56504_A0_EGRTXPKTCTRCONFIG7r 0x00680027

#define BCM56504_A0_EGRTXPKTCTRCONFIG7r_SIZE 4

/*
 * This structure should be used to declare and program EGRTXPKTCTRCONFIG7.
 *
 */
typedef union BCM56504_A0_EGRTXPKTCTRCONFIG7r_s {
	uint32_t v[1];
	uint32_t egrtxpktctrconfig7[1];
	uint32_t _egrtxpktctrconfig7;
} BCM56504_A0_EGRTXPKTCTRCONFIG7r_t;

#define BCM56504_A0_EGRTXPKTCTRCONFIG7r_CLR(r) (r).egrtxpktctrconfig7[0] = 0
#define BCM56504_A0_EGRTXPKTCTRCONFIG7r_SET(r,d) (r).egrtxpktctrconfig7[0] = d
#define BCM56504_A0_EGRTXPKTCTRCONFIG7r_GET(r) (r).egrtxpktctrconfig7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_EGRTXPKTCTRCONFIG7r_TXEPORTNUMf_GET(r) (((r).egrtxpktctrconfig7[0]) & 0x1f)
#define BCM56504_A0_EGRTXPKTCTRCONFIG7r_TXEPORTNUMf_SET(r,f) (r).egrtxpktctrconfig7[0]=(((r).egrtxpktctrconfig7[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56504_A0_EGRTXPKTCTRCONFIG7r_TXIPORTNUMf_GET(r) ((((r).egrtxpktctrconfig7[0]) >> 5) & 0x1f)
#define BCM56504_A0_EGRTXPKTCTRCONFIG7r_TXIPORTNUMf_SET(r,f) (r).egrtxpktctrconfig7[0]=(((r).egrtxpktctrconfig7[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5))
#define BCM56504_A0_EGRTXPKTCTRCONFIG7r_TXCOSNUMf_GET(r) ((((r).egrtxpktctrconfig7[0]) >> 10) & 0x7)
#define BCM56504_A0_EGRTXPKTCTRCONFIG7r_TXCOSNUMf_SET(r,f) (r).egrtxpktctrconfig7[0]=(((r).egrtxpktctrconfig7[0] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10))
#define BCM56504_A0_EGRTXPKTCTRCONFIG7r_TXPKTCOUNT_SELf_GET(r) ((((r).egrtxpktctrconfig7[0]) >> 13) & 0x3)
#define BCM56504_A0_EGRTXPKTCTRCONFIG7r_TXPKTCOUNT_SELf_SET(r,f) (r).egrtxpktctrconfig7[0]=(((r).egrtxpktctrconfig7[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13))

/*
 * These macros can be used to access EGRTXPKTCTRCONFIG7.
 *
 */
#define BCM56504_A0_READ_EGRTXPKTCTRCONFIG7r(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_EGRTXPKTCTRCONFIG7r,(r._egrtxpktctrconfig7))
#define BCM56504_A0_WRITE_EGRTXPKTCTRCONFIG7r(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_EGRTXPKTCTRCONFIG7r,&(r._egrtxpktctrconfig7))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGRTXPKTCTRCONFIG7r BCM56504_A0_EGRTXPKTCTRCONFIG7r
#define EGRTXPKTCTRCONFIG7r_SIZE BCM56504_A0_EGRTXPKTCTRCONFIG7r_SIZE
typedef BCM56504_A0_EGRTXPKTCTRCONFIG7r_t EGRTXPKTCTRCONFIG7r_t;
#define EGRTXPKTCTRCONFIG7r_CLR BCM56504_A0_EGRTXPKTCTRCONFIG7r_CLR
#define EGRTXPKTCTRCONFIG7r_SET BCM56504_A0_EGRTXPKTCTRCONFIG7r_SET
#define EGRTXPKTCTRCONFIG7r_GET BCM56504_A0_EGRTXPKTCTRCONFIG7r_GET
#define EGRTXPKTCTRCONFIG7r_TXEPORTNUMf_GET BCM56504_A0_EGRTXPKTCTRCONFIG7r_TXEPORTNUMf_GET
#define EGRTXPKTCTRCONFIG7r_TXEPORTNUMf_SET BCM56504_A0_EGRTXPKTCTRCONFIG7r_TXEPORTNUMf_SET
#define EGRTXPKTCTRCONFIG7r_TXIPORTNUMf_GET BCM56504_A0_EGRTXPKTCTRCONFIG7r_TXIPORTNUMf_GET
#define EGRTXPKTCTRCONFIG7r_TXIPORTNUMf_SET BCM56504_A0_EGRTXPKTCTRCONFIG7r_TXIPORTNUMf_SET
#define EGRTXPKTCTRCONFIG7r_TXCOSNUMf_GET BCM56504_A0_EGRTXPKTCTRCONFIG7r_TXCOSNUMf_GET
#define EGRTXPKTCTRCONFIG7r_TXCOSNUMf_SET BCM56504_A0_EGRTXPKTCTRCONFIG7r_TXCOSNUMf_SET
#define EGRTXPKTCTRCONFIG7r_TXPKTCOUNT_SELf_GET BCM56504_A0_EGRTXPKTCTRCONFIG7r_TXPKTCOUNT_SELf_GET
#define EGRTXPKTCTRCONFIG7r_TXPKTCOUNT_SELf_SET BCM56504_A0_EGRTXPKTCTRCONFIG7r_TXPKTCOUNT_SELf_SET
#define READ_EGRTXPKTCTRCONFIG7r BCM56504_A0_READ_EGRTXPKTCTRCONFIG7r
#define WRITE_EGRTXPKTCTRCONFIG7r BCM56504_A0_WRITE_EGRTXPKTCTRCONFIG7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_EGRTXPKTCTRCONFIG7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  EGR_CONFIG
 * BLOCKS:   EPIPE
 * DESC:     Configuration Register for the entire chip. 


 * SIZE:     32
 * FIELDS:
 *     DT_MODE          Double Tagging Mode is enabled or not.
 *     DRACO1_5_MIRROR  If set then Draco 1.5 style mirroring is enabled. Else Firebolt style of mirroring is enabled.
 *     CFI_AS_CNG       CFI-CNG mapping enabled. If this bit is set, Packet Modification stages will map the incoming CNG bits to CFI bits in the packet vlan tag. This bit is per chip.
 *     USE_LEARN_VID    Use the learn_vid for vid membership and stg state check.
 *     LEARN_VID        Vid to be used for vid membership and stg state check when USE_LEARN_VID is set.
 *     INNER_TPID       TPID to identify inner vlan tag of the packet when switch is operating in DT mode, i.e. DT_MODE bit is set.
 *
 ******************************************************************************/
#define BCM56504_A0_EGR_CONFIGr 0x01980000

#define BCM56504_A0_EGR_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program EGR_CONFIG.
 *
 */
typedef union BCM56504_A0_EGR_CONFIGr_s {
	uint32_t v[1];
	uint32_t egr_config[1];
	uint32_t _egr_config;
} BCM56504_A0_EGR_CONFIGr_t;

#define BCM56504_A0_EGR_CONFIGr_CLR(r) (r).egr_config[0] = 0
#define BCM56504_A0_EGR_CONFIGr_SET(r,d) (r).egr_config[0] = d
#define BCM56504_A0_EGR_CONFIGr_GET(r) (r).egr_config[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_EGR_CONFIGr_DT_MODEf_GET(r) (((r).egr_config[0]) & 0x1)
#define BCM56504_A0_EGR_CONFIGr_DT_MODEf_SET(r,f) (r).egr_config[0]=(((r).egr_config[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_EGR_CONFIGr_DRACO1_5_MIRRORf_GET(r) ((((r).egr_config[0]) >> 1) & 0x1)
#define BCM56504_A0_EGR_CONFIGr_DRACO1_5_MIRRORf_SET(r,f) (r).egr_config[0]=(((r).egr_config[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_EGR_CONFIGr_CFI_AS_CNGf_GET(r) ((((r).egr_config[0]) >> 2) & 0x1)
#define BCM56504_A0_EGR_CONFIGr_CFI_AS_CNGf_SET(r,f) (r).egr_config[0]=(((r).egr_config[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_EGR_CONFIGr_USE_LEARN_VIDf_GET(r) ((((r).egr_config[0]) >> 3) & 0x1)
#define BCM56504_A0_EGR_CONFIGr_USE_LEARN_VIDf_SET(r,f) (r).egr_config[0]=(((r).egr_config[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_EGR_CONFIGr_LEARN_VIDf_GET(r) ((((r).egr_config[0]) >> 4) & 0xfff)
#define BCM56504_A0_EGR_CONFIGr_LEARN_VIDf_SET(r,f) (r).egr_config[0]=(((r).egr_config[0] & ~((uint32_t)0xfff << 4)) | ((((uint32_t)f) & 0xfff) << 4))
#define BCM56504_A0_EGR_CONFIGr_INNER_TPIDf_GET(r) ((((r).egr_config[0]) >> 16) & 0xffff)
#define BCM56504_A0_EGR_CONFIGr_INNER_TPIDf_SET(r,f) (r).egr_config[0]=(((r).egr_config[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access EGR_CONFIG.
 *
 */
#define BCM56504_A0_READ_EGR_CONFIGr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_EGR_CONFIGr,(r._egr_config))
#define BCM56504_A0_WRITE_EGR_CONFIGr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_EGR_CONFIGr,&(r._egr_config))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_CONFIGr BCM56504_A0_EGR_CONFIGr
#define EGR_CONFIGr_SIZE BCM56504_A0_EGR_CONFIGr_SIZE
typedef BCM56504_A0_EGR_CONFIGr_t EGR_CONFIGr_t;
#define EGR_CONFIGr_CLR BCM56504_A0_EGR_CONFIGr_CLR
#define EGR_CONFIGr_SET BCM56504_A0_EGR_CONFIGr_SET
#define EGR_CONFIGr_GET BCM56504_A0_EGR_CONFIGr_GET
#define EGR_CONFIGr_DT_MODEf_GET BCM56504_A0_EGR_CONFIGr_DT_MODEf_GET
#define EGR_CONFIGr_DT_MODEf_SET BCM56504_A0_EGR_CONFIGr_DT_MODEf_SET
#define EGR_CONFIGr_DRACO1_5_MIRRORf_GET BCM56504_A0_EGR_CONFIGr_DRACO1_5_MIRRORf_GET
#define EGR_CONFIGr_DRACO1_5_MIRRORf_SET BCM56504_A0_EGR_CONFIGr_DRACO1_5_MIRRORf_SET
#define EGR_CONFIGr_CFI_AS_CNGf_GET BCM56504_A0_EGR_CONFIGr_CFI_AS_CNGf_GET
#define EGR_CONFIGr_CFI_AS_CNGf_SET BCM56504_A0_EGR_CONFIGr_CFI_AS_CNGf_SET
#define EGR_CONFIGr_USE_LEARN_VIDf_GET BCM56504_A0_EGR_CONFIGr_USE_LEARN_VIDf_GET
#define EGR_CONFIGr_USE_LEARN_VIDf_SET BCM56504_A0_EGR_CONFIGr_USE_LEARN_VIDf_SET
#define EGR_CONFIGr_LEARN_VIDf_GET BCM56504_A0_EGR_CONFIGr_LEARN_VIDf_GET
#define EGR_CONFIGr_LEARN_VIDf_SET BCM56504_A0_EGR_CONFIGr_LEARN_VIDf_SET
#define EGR_CONFIGr_INNER_TPIDf_GET BCM56504_A0_EGR_CONFIGr_INNER_TPIDf_GET
#define EGR_CONFIGr_INNER_TPIDf_SET BCM56504_A0_EGR_CONFIGr_INNER_TPIDf_SET
#define READ_EGR_CONFIGr BCM56504_A0_READ_EGR_CONFIGr
#define WRITE_EGR_CONFIGr BCM56504_A0_WRITE_EGR_CONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_EGR_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  EGR_CONFIG_1
 * BLOCKS:   EPIPE
 * DESC:     Configuration Register Extension for the entire chip. 


 * SIZE:     32
 * FIELDS:
 *     RING_MODE        User should set it when FBs are cascaded in a ring fashion
 *     IPMC_ROUTE_SAME_VLAN When special processing is needed for IPMC replicated pkt which has same vlan as incoming packet's vlan.
 *
 ******************************************************************************/
#define BCM56504_A0_EGR_CONFIG_1r 0x01980001

#define BCM56504_A0_EGR_CONFIG_1r_SIZE 4

/*
 * This structure should be used to declare and program EGR_CONFIG_1.
 *
 */
typedef union BCM56504_A0_EGR_CONFIG_1r_s {
	uint32_t v[1];
	uint32_t egr_config_1[1];
	uint32_t _egr_config_1;
} BCM56504_A0_EGR_CONFIG_1r_t;

#define BCM56504_A0_EGR_CONFIG_1r_CLR(r) (r).egr_config_1[0] = 0
#define BCM56504_A0_EGR_CONFIG_1r_SET(r,d) (r).egr_config_1[0] = d
#define BCM56504_A0_EGR_CONFIG_1r_GET(r) (r).egr_config_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_EGR_CONFIG_1r_RING_MODEf_GET(r) (((r).egr_config_1[0]) & 0x1)
#define BCM56504_A0_EGR_CONFIG_1r_RING_MODEf_SET(r,f) (r).egr_config_1[0]=(((r).egr_config_1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_EGR_CONFIG_1r_IPMC_ROUTE_SAME_VLANf_GET(r) ((((r).egr_config_1[0]) >> 1) & 0x1)
#define BCM56504_A0_EGR_CONFIG_1r_IPMC_ROUTE_SAME_VLANf_SET(r,f) (r).egr_config_1[0]=(((r).egr_config_1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access EGR_CONFIG_1.
 *
 */
#define BCM56504_A0_READ_EGR_CONFIG_1r(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_EGR_CONFIG_1r,(r._egr_config_1))
#define BCM56504_A0_WRITE_EGR_CONFIG_1r(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_EGR_CONFIG_1r,&(r._egr_config_1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_CONFIG_1r BCM56504_A0_EGR_CONFIG_1r
#define EGR_CONFIG_1r_SIZE BCM56504_A0_EGR_CONFIG_1r_SIZE
typedef BCM56504_A0_EGR_CONFIG_1r_t EGR_CONFIG_1r_t;
#define EGR_CONFIG_1r_CLR BCM56504_A0_EGR_CONFIG_1r_CLR
#define EGR_CONFIG_1r_SET BCM56504_A0_EGR_CONFIG_1r_SET
#define EGR_CONFIG_1r_GET BCM56504_A0_EGR_CONFIG_1r_GET
#define EGR_CONFIG_1r_RING_MODEf_GET BCM56504_A0_EGR_CONFIG_1r_RING_MODEf_GET
#define EGR_CONFIG_1r_RING_MODEf_SET BCM56504_A0_EGR_CONFIG_1r_RING_MODEf_SET
#define EGR_CONFIG_1r_IPMC_ROUTE_SAME_VLANf_GET BCM56504_A0_EGR_CONFIG_1r_IPMC_ROUTE_SAME_VLANf_GET
#define EGR_CONFIG_1r_IPMC_ROUTE_SAME_VLANf_SET BCM56504_A0_EGR_CONFIG_1r_IPMC_ROUTE_SAME_VLANf_SET
#define READ_EGR_CONFIG_1r BCM56504_A0_READ_EGR_CONFIG_1r
#define WRITE_EGR_CONFIG_1r BCM56504_A0_WRITE_EGR_CONFIG_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_EGR_CONFIG_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  EGR_DBG
 * BLOCKS:   EPIPE
 * DESC:     Configuration Register for a Port. This is same for GE, 10GE, Higig Ports.


 * SIZE:     32
 * FIELDS:
 *     RESURRECT        Enable the resurrect feature for purge, aged and cell_error packets.If this bit is set, the packets marked as Purge, Aged, Cell_error are not dropped in the chip.
 *     DISABLE_CRC_REGEN Disable CRC regeneration for GE ports only. In case of Higig or 10GE, theCRC regeration is config based in the mac.
 *     ALWAYS_CRC_REGEN Always regenrate the CRC for GE ports only. In case of Higig or 10GE, theCRC regeration is config based in the mac.
 *
 ******************************************************************************/
#define BCM56504_A0_EGR_DBGr 0x06900000

#define BCM56504_A0_EGR_DBGr_SIZE 4

/*
 * This structure should be used to declare and program EGR_DBG.
 *
 */
typedef union BCM56504_A0_EGR_DBGr_s {
	uint32_t v[1];
	uint32_t egr_dbg[1];
	uint32_t _egr_dbg;
} BCM56504_A0_EGR_DBGr_t;

#define BCM56504_A0_EGR_DBGr_CLR(r) (r).egr_dbg[0] = 0
#define BCM56504_A0_EGR_DBGr_SET(r,d) (r).egr_dbg[0] = d
#define BCM56504_A0_EGR_DBGr_GET(r) (r).egr_dbg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_EGR_DBGr_RESURRECTf_GET(r) (((r).egr_dbg[0]) & 0x1)
#define BCM56504_A0_EGR_DBGr_RESURRECTf_SET(r,f) (r).egr_dbg[0]=(((r).egr_dbg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_EGR_DBGr_DISABLE_CRC_REGENf_GET(r) ((((r).egr_dbg[0]) >> 1) & 0x1)
#define BCM56504_A0_EGR_DBGr_DISABLE_CRC_REGENf_SET(r,f) (r).egr_dbg[0]=(((r).egr_dbg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_EGR_DBGr_ALWAYS_CRC_REGENf_GET(r) ((((r).egr_dbg[0]) >> 2) & 0x1)
#define BCM56504_A0_EGR_DBGr_ALWAYS_CRC_REGENf_SET(r,f) (r).egr_dbg[0]=(((r).egr_dbg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))

/*
 * These macros can be used to access EGR_DBG.
 *
 */
#define BCM56504_A0_READ_EGR_DBGr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_EGR_DBGr,(r._egr_dbg))
#define BCM56504_A0_WRITE_EGR_DBGr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_EGR_DBGr,&(r._egr_dbg))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_DBGr BCM56504_A0_EGR_DBGr
#define EGR_DBGr_SIZE BCM56504_A0_EGR_DBGr_SIZE
typedef BCM56504_A0_EGR_DBGr_t EGR_DBGr_t;
#define EGR_DBGr_CLR BCM56504_A0_EGR_DBGr_CLR
#define EGR_DBGr_SET BCM56504_A0_EGR_DBGr_SET
#define EGR_DBGr_GET BCM56504_A0_EGR_DBGr_GET
#define EGR_DBGr_RESURRECTf_GET BCM56504_A0_EGR_DBGr_RESURRECTf_GET
#define EGR_DBGr_RESURRECTf_SET BCM56504_A0_EGR_DBGr_RESURRECTf_SET
#define EGR_DBGr_DISABLE_CRC_REGENf_GET BCM56504_A0_EGR_DBGr_DISABLE_CRC_REGENf_GET
#define EGR_DBGr_DISABLE_CRC_REGENf_SET BCM56504_A0_EGR_DBGr_DISABLE_CRC_REGENf_SET
#define EGR_DBGr_ALWAYS_CRC_REGENf_GET BCM56504_A0_EGR_DBGr_ALWAYS_CRC_REGENf_GET
#define EGR_DBGr_ALWAYS_CRC_REGENf_SET BCM56504_A0_EGR_DBGr_ALWAYS_CRC_REGENf_SET
#define READ_EGR_DBGr BCM56504_A0_READ_EGR_DBGr
#define WRITE_EGR_DBGr BCM56504_A0_WRITE_EGR_DBGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_EGR_DBGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  EGR_DSCP_TABLE
 * BLOCKS:   EPIPE
 * DESC:     Egress DSCP Table to select the new dscp for outer tunnel header packets.
 * SIZE:     6
 * FIELDS:
 *     DSCP             New DSCP to be used for the outer tunnel header based on the incoming mmu priority and the DSCP_SEL field from the EGR_IP_TUNNEL table.
 *
 ******************************************************************************/
#define BCM56504_A0_EGR_DSCP_TABLEm 0x05970000

#define BCM56504_A0_EGR_DSCP_TABLEm_MIN 0
#define BCM56504_A0_EGR_DSCP_TABLEm_MAX 31
#define BCM56504_A0_EGR_DSCP_TABLEm_CMAX(u) 31
#define BCM56504_A0_EGR_DSCP_TABLEm_SIZE 1

/*
 * This structure should be used to declare and program EGR_DSCP_TABLE.
 *
 */
typedef union BCM56504_A0_EGR_DSCP_TABLEm_s {
	uint32_t v[1];
	uint32_t egr_dscp_table[1];
	uint32_t _egr_dscp_table;
} BCM56504_A0_EGR_DSCP_TABLEm_t;

#define BCM56504_A0_EGR_DSCP_TABLEm_CLR(r) (r).egr_dscp_table[0] = 0
#define BCM56504_A0_EGR_DSCP_TABLEm_SET(r,d) (r).egr_dscp_table[0] = d
#define BCM56504_A0_EGR_DSCP_TABLEm_GET(r) (r).egr_dscp_table[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_EGR_DSCP_TABLEm_DSCPf_GET(r) (((r).egr_dscp_table[0]) & 0x3f)
#define BCM56504_A0_EGR_DSCP_TABLEm_DSCPf_SET(r,f) (r).egr_dscp_table[0]=(((r).egr_dscp_table[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))

/*
 * These macros can be used to access EGR_DSCP_TABLE.
 *
 */
#define BCM56504_A0_READ_EGR_DSCP_TABLEm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_EGR_DSCP_TABLEm,i,(m._egr_dscp_table),1)
#define BCM56504_A0_WRITE_EGR_DSCP_TABLEm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_EGR_DSCP_TABLEm,i,&(m._egr_dscp_table),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_DSCP_TABLEm BCM56504_A0_EGR_DSCP_TABLEm
#define EGR_DSCP_TABLEm_MIN BCM56504_A0_EGR_DSCP_TABLEm_MIN
#define EGR_DSCP_TABLEm_MAX BCM56504_A0_EGR_DSCP_TABLEm_MAX
#define EGR_DSCP_TABLEm_CMAX(u) BCM56504_A0_EGR_DSCP_TABLEm_CMAX(u)
#define EGR_DSCP_TABLEm_SIZE BCM56504_A0_EGR_DSCP_TABLEm_SIZE
typedef BCM56504_A0_EGR_DSCP_TABLEm_t EGR_DSCP_TABLEm_t;
#define EGR_DSCP_TABLEm_CLR BCM56504_A0_EGR_DSCP_TABLEm_CLR
#define EGR_DSCP_TABLEm_SET BCM56504_A0_EGR_DSCP_TABLEm_SET
#define EGR_DSCP_TABLEm_GET BCM56504_A0_EGR_DSCP_TABLEm_GET
#define EGR_DSCP_TABLEm_DSCPf_GET BCM56504_A0_EGR_DSCP_TABLEm_DSCPf_GET
#define EGR_DSCP_TABLEm_DSCPf_SET BCM56504_A0_EGR_DSCP_TABLEm_DSCPf_SET
#define READ_EGR_DSCP_TABLEm BCM56504_A0_READ_EGR_DSCP_TABLEm
#define WRITE_EGR_DSCP_TABLEm BCM56504_A0_WRITE_EGR_DSCP_TABLEm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_EGR_DSCP_TABLEm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  EGR_EM_MTP_INDEX
 * BLOCKS:   EPIPE
 * DESC:     Mirror to Port Table. 
Index is constructed using pbe.mtp_index[6:0] field.
We use {pbe.mtp_index[5:4],pbe.mtp_index[2:0]} as index into this table.

 * SIZE:     11
 * FIELDS:
 *     MTP_DST_MODID    DST_MODID field to be used in the module header in case of mirroring.
 *     MTP_DST_PORT     DST_PORT field to be used in module header in case of mirroring.
 *
 ******************************************************************************/
#define BCM56504_A0_EGR_EM_MTP_INDEXm 0x05960000

#define BCM56504_A0_EGR_EM_MTP_INDEXm_MIN 0
#define BCM56504_A0_EGR_EM_MTP_INDEXm_MAX 31
#define BCM56504_A0_EGR_EM_MTP_INDEXm_CMAX(u) 31
#define BCM56504_A0_EGR_EM_MTP_INDEXm_SIZE 2

/*
 * This structure should be used to declare and program EGR_EM_MTP_INDEX.
 *
 */
typedef union BCM56504_A0_EGR_EM_MTP_INDEXm_s {
	uint32_t v[1];
	uint32_t egr_em_mtp_index[1];
	uint32_t _egr_em_mtp_index;
} BCM56504_A0_EGR_EM_MTP_INDEXm_t;

#define BCM56504_A0_EGR_EM_MTP_INDEXm_CLR(r) (r).egr_em_mtp_index[0] = 0
#define BCM56504_A0_EGR_EM_MTP_INDEXm_SET(r,d) (r).egr_em_mtp_index[0] = d
#define BCM56504_A0_EGR_EM_MTP_INDEXm_GET(r) (r).egr_em_mtp_index[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_EGR_EM_MTP_INDEXm_MTP_DST_MODIDf_GET(r) (((r).egr_em_mtp_index[0]) & 0x3f)
#define BCM56504_A0_EGR_EM_MTP_INDEXm_MTP_DST_MODIDf_SET(r,f) (r).egr_em_mtp_index[0]=(((r).egr_em_mtp_index[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM56504_A0_EGR_EM_MTP_INDEXm_MTP_DST_PORTf_GET(r) ((((r).egr_em_mtp_index[0]) >> 6) & 0x1f)
#define BCM56504_A0_EGR_EM_MTP_INDEXm_MTP_DST_PORTf_SET(r,f) (r).egr_em_mtp_index[0]=(((r).egr_em_mtp_index[0] & ~((uint32_t)0x1f << 6)) | ((((uint32_t)f) & 0x1f) << 6))

/*
 * These macros can be used to access EGR_EM_MTP_INDEX.
 *
 */
#define BCM56504_A0_READ_EGR_EM_MTP_INDEXm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_EGR_EM_MTP_INDEXm,i,(m._egr_em_mtp_index),1)
#define BCM56504_A0_WRITE_EGR_EM_MTP_INDEXm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_EGR_EM_MTP_INDEXm,i,&(m._egr_em_mtp_index),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_EM_MTP_INDEXm BCM56504_A0_EGR_EM_MTP_INDEXm
#define EGR_EM_MTP_INDEXm_MIN BCM56504_A0_EGR_EM_MTP_INDEXm_MIN
#define EGR_EM_MTP_INDEXm_MAX BCM56504_A0_EGR_EM_MTP_INDEXm_MAX
#define EGR_EM_MTP_INDEXm_CMAX(u) BCM56504_A0_EGR_EM_MTP_INDEXm_CMAX(u)
#define EGR_EM_MTP_INDEXm_SIZE BCM56504_A0_EGR_EM_MTP_INDEXm_SIZE
typedef BCM56504_A0_EGR_EM_MTP_INDEXm_t EGR_EM_MTP_INDEXm_t;
#define EGR_EM_MTP_INDEXm_CLR BCM56504_A0_EGR_EM_MTP_INDEXm_CLR
#define EGR_EM_MTP_INDEXm_SET BCM56504_A0_EGR_EM_MTP_INDEXm_SET
#define EGR_EM_MTP_INDEXm_GET BCM56504_A0_EGR_EM_MTP_INDEXm_GET
#define EGR_EM_MTP_INDEXm_MTP_DST_MODIDf_GET BCM56504_A0_EGR_EM_MTP_INDEXm_MTP_DST_MODIDf_GET
#define EGR_EM_MTP_INDEXm_MTP_DST_MODIDf_SET BCM56504_A0_EGR_EM_MTP_INDEXm_MTP_DST_MODIDf_SET
#define EGR_EM_MTP_INDEXm_MTP_DST_PORTf_GET BCM56504_A0_EGR_EM_MTP_INDEXm_MTP_DST_PORTf_GET
#define EGR_EM_MTP_INDEXm_MTP_DST_PORTf_SET BCM56504_A0_EGR_EM_MTP_INDEXm_MTP_DST_PORTf_SET
#define READ_EGR_EM_MTP_INDEXm BCM56504_A0_READ_EGR_EM_MTP_INDEXm
#define WRITE_EGR_EM_MTP_INDEXm BCM56504_A0_WRITE_EGR_EM_MTP_INDEXm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_EGR_EM_MTP_INDEXm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  EGR_ENABLE
 * BLOCKS:   EPIPE
 * DESC:     Enables the Egress Port for transmission.

 * SIZE:     32
 * FIELDS:
 *     PRT_ENABLE       Port is enabled. If this bit is set, the requests to MMU will be made from this port to the MMU.
 *
 ******************************************************************************/
#define BCM56504_A0_EGR_ENABLEr 0x0a900100

#define BCM56504_A0_EGR_ENABLEr_SIZE 4

/*
 * This structure should be used to declare and program EGR_ENABLE.
 *
 */
typedef union BCM56504_A0_EGR_ENABLEr_s {
	uint32_t v[1];
	uint32_t egr_enable[1];
	uint32_t _egr_enable;
} BCM56504_A0_EGR_ENABLEr_t;

#define BCM56504_A0_EGR_ENABLEr_CLR(r) (r).egr_enable[0] = 0
#define BCM56504_A0_EGR_ENABLEr_SET(r,d) (r).egr_enable[0] = d
#define BCM56504_A0_EGR_ENABLEr_GET(r) (r).egr_enable[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_EGR_ENABLEr_PRT_ENABLEf_GET(r) (((r).egr_enable[0]) & 0x1)
#define BCM56504_A0_EGR_ENABLEr_PRT_ENABLEf_SET(r,f) (r).egr_enable[0]=(((r).egr_enable[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access EGR_ENABLE.
 *
 */
#define BCM56504_A0_READ_EGR_ENABLEr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_EGR_ENABLEr,(r._egr_enable))
#define BCM56504_A0_WRITE_EGR_ENABLEr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_EGR_ENABLEr,&(r._egr_enable))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_ENABLEr BCM56504_A0_EGR_ENABLEr
#define EGR_ENABLEr_SIZE BCM56504_A0_EGR_ENABLEr_SIZE
typedef BCM56504_A0_EGR_ENABLEr_t EGR_ENABLEr_t;
#define EGR_ENABLEr_CLR BCM56504_A0_EGR_ENABLEr_CLR
#define EGR_ENABLEr_SET BCM56504_A0_EGR_ENABLEr_SET
#define EGR_ENABLEr_GET BCM56504_A0_EGR_ENABLEr_GET
#define EGR_ENABLEr_PRT_ENABLEf_GET BCM56504_A0_EGR_ENABLEr_PRT_ENABLEf_GET
#define EGR_ENABLEr_PRT_ENABLEf_SET BCM56504_A0_EGR_ENABLEr_PRT_ENABLEf_SET
#define READ_EGR_ENABLEr BCM56504_A0_READ_EGR_ENABLEr
#define WRITE_EGR_ENABLEr BCM56504_A0_WRITE_EGR_ENABLEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_EGR_ENABLEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  EGR_HW_RESET_CONTROL_0
 * BLOCKS:   EPIPE
 * DESC:     This register is for controlling the HW Table Initialization Feature of the Egress Pipeline.
This register should be programmed before programming EGR_HW_RESET_CONTROL_1 register.

 * SIZE:     32
 * FIELDS:
 *     STAGE_NUMBER     Stage Number where table to be reset is located. This is NOT used when EGR_HW_RESET_CONTROL_1.RESET_ALL bit is set.
 *     START_ADDRESS    20 bit starting address for the memory. HW starts incrementing from this address until EGR_HW_RESET_CONTROL_1.COUNT is completed.  START_ADDRESS is relevant even when EGR_HW_RESET_CONTROL_1.RESET_ALL bit is set.
 *
 ******************************************************************************/
#define BCM56504_A0_EGR_HW_RESET_CONTROL_0r 0x00980000

#define BCM56504_A0_EGR_HW_RESET_CONTROL_0r_SIZE 4

/*
 * This structure should be used to declare and program EGR_HW_RESET_CONTROL_0.
 *
 */
typedef union BCM56504_A0_EGR_HW_RESET_CONTROL_0r_s {
	uint32_t v[1];
	uint32_t egr_hw_reset_control_0[1];
	uint32_t _egr_hw_reset_control_0;
} BCM56504_A0_EGR_HW_RESET_CONTROL_0r_t;

#define BCM56504_A0_EGR_HW_RESET_CONTROL_0r_CLR(r) (r).egr_hw_reset_control_0[0] = 0
#define BCM56504_A0_EGR_HW_RESET_CONTROL_0r_SET(r,d) (r).egr_hw_reset_control_0[0] = d
#define BCM56504_A0_EGR_HW_RESET_CONTROL_0r_GET(r) (r).egr_hw_reset_control_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_EGR_HW_RESET_CONTROL_0r_STAGE_NUMBERf_GET(r) (((r).egr_hw_reset_control_0[0]) & 0x3f)
#define BCM56504_A0_EGR_HW_RESET_CONTROL_0r_STAGE_NUMBERf_SET(r,f) (r).egr_hw_reset_control_0[0]=(((r).egr_hw_reset_control_0[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM56504_A0_EGR_HW_RESET_CONTROL_0r_START_ADDRESSf_GET(r) ((((r).egr_hw_reset_control_0[0]) >> 6) & 0xfffff)
#define BCM56504_A0_EGR_HW_RESET_CONTROL_0r_START_ADDRESSf_SET(r,f) (r).egr_hw_reset_control_0[0]=(((r).egr_hw_reset_control_0[0] & ~((uint32_t)0xfffff << 6)) | ((((uint32_t)f) & 0xfffff) << 6))

/*
 * These macros can be used to access EGR_HW_RESET_CONTROL_0.
 *
 */
#define BCM56504_A0_READ_EGR_HW_RESET_CONTROL_0r(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_EGR_HW_RESET_CONTROL_0r,(r._egr_hw_reset_control_0))
#define BCM56504_A0_WRITE_EGR_HW_RESET_CONTROL_0r(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_EGR_HW_RESET_CONTROL_0r,&(r._egr_hw_reset_control_0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_HW_RESET_CONTROL_0r BCM56504_A0_EGR_HW_RESET_CONTROL_0r
#define EGR_HW_RESET_CONTROL_0r_SIZE BCM56504_A0_EGR_HW_RESET_CONTROL_0r_SIZE
typedef BCM56504_A0_EGR_HW_RESET_CONTROL_0r_t EGR_HW_RESET_CONTROL_0r_t;
#define EGR_HW_RESET_CONTROL_0r_CLR BCM56504_A0_EGR_HW_RESET_CONTROL_0r_CLR
#define EGR_HW_RESET_CONTROL_0r_SET BCM56504_A0_EGR_HW_RESET_CONTROL_0r_SET
#define EGR_HW_RESET_CONTROL_0r_GET BCM56504_A0_EGR_HW_RESET_CONTROL_0r_GET
#define EGR_HW_RESET_CONTROL_0r_STAGE_NUMBERf_GET BCM56504_A0_EGR_HW_RESET_CONTROL_0r_STAGE_NUMBERf_GET
#define EGR_HW_RESET_CONTROL_0r_STAGE_NUMBERf_SET BCM56504_A0_EGR_HW_RESET_CONTROL_0r_STAGE_NUMBERf_SET
#define EGR_HW_RESET_CONTROL_0r_START_ADDRESSf_GET BCM56504_A0_EGR_HW_RESET_CONTROL_0r_START_ADDRESSf_GET
#define EGR_HW_RESET_CONTROL_0r_START_ADDRESSf_SET BCM56504_A0_EGR_HW_RESET_CONTROL_0r_START_ADDRESSf_SET
#define READ_EGR_HW_RESET_CONTROL_0r BCM56504_A0_READ_EGR_HW_RESET_CONTROL_0r
#define WRITE_EGR_HW_RESET_CONTROL_0r BCM56504_A0_WRITE_EGR_HW_RESET_CONTROL_0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_EGR_HW_RESET_CONTROL_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  EGR_HW_RESET_CONTROL_1
 * BLOCKS:   EPIPE
 * DESC:     This register is for controlling the HW Table Initialization Feature of the Egress Pipeline.

 * SIZE:     32
 * FIELDS:
 *     COUNT            Count of entries which need to be resetted starting from EGR_HW_RESET_CONTROL_0.START_ADDRESS.
 *     RESET_ALL        If set, then ALL Tables in the Egress Pipeline will be resetted for COUNT entries. STAGE_NUMBER is ignored when this bit is set. 
 *     VALID            The HW table initialization will start after Logic sees this bit as set.
 *     DONE             After HW has issued memory reset commands equal to COUNT times, it will set DONE bit,SW can poll this bit from time to time and whenever it is set, SW should reset DONE and VALIDbits to 0. This will end the HW Reset Sequence of memories in the HW.
 *
 ******************************************************************************/
#define BCM56504_A0_EGR_HW_RESET_CONTROL_1r 0x00980001

#define BCM56504_A0_EGR_HW_RESET_CONTROL_1r_SIZE 4

/*
 * This structure should be used to declare and program EGR_HW_RESET_CONTROL_1.
 *
 */
typedef union BCM56504_A0_EGR_HW_RESET_CONTROL_1r_s {
	uint32_t v[1];
	uint32_t egr_hw_reset_control_1[1];
	uint32_t _egr_hw_reset_control_1;
} BCM56504_A0_EGR_HW_RESET_CONTROL_1r_t;

#define BCM56504_A0_EGR_HW_RESET_CONTROL_1r_CLR(r) (r).egr_hw_reset_control_1[0] = 0
#define BCM56504_A0_EGR_HW_RESET_CONTROL_1r_SET(r,d) (r).egr_hw_reset_control_1[0] = d
#define BCM56504_A0_EGR_HW_RESET_CONTROL_1r_GET(r) (r).egr_hw_reset_control_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_EGR_HW_RESET_CONTROL_1r_COUNTf_GET(r) (((r).egr_hw_reset_control_1[0]) & 0xffff)
#define BCM56504_A0_EGR_HW_RESET_CONTROL_1r_COUNTf_SET(r,f) (r).egr_hw_reset_control_1[0]=(((r).egr_hw_reset_control_1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56504_A0_EGR_HW_RESET_CONTROL_1r_RESET_ALLf_GET(r) ((((r).egr_hw_reset_control_1[0]) >> 16) & 0x1)
#define BCM56504_A0_EGR_HW_RESET_CONTROL_1r_RESET_ALLf_SET(r,f) (r).egr_hw_reset_control_1[0]=(((r).egr_hw_reset_control_1[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56504_A0_EGR_HW_RESET_CONTROL_1r_VALIDf_GET(r) ((((r).egr_hw_reset_control_1[0]) >> 17) & 0x1)
#define BCM56504_A0_EGR_HW_RESET_CONTROL_1r_VALIDf_SET(r,f) (r).egr_hw_reset_control_1[0]=(((r).egr_hw_reset_control_1[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56504_A0_EGR_HW_RESET_CONTROL_1r_DONEf_GET(r) ((((r).egr_hw_reset_control_1[0]) >> 18) & 0x1)
#define BCM56504_A0_EGR_HW_RESET_CONTROL_1r_DONEf_SET(r,f) (r).egr_hw_reset_control_1[0]=(((r).egr_hw_reset_control_1[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))

/*
 * These macros can be used to access EGR_HW_RESET_CONTROL_1.
 *
 */
#define BCM56504_A0_READ_EGR_HW_RESET_CONTROL_1r(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_EGR_HW_RESET_CONTROL_1r,(r._egr_hw_reset_control_1))
#define BCM56504_A0_WRITE_EGR_HW_RESET_CONTROL_1r(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_EGR_HW_RESET_CONTROL_1r,&(r._egr_hw_reset_control_1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_HW_RESET_CONTROL_1r BCM56504_A0_EGR_HW_RESET_CONTROL_1r
#define EGR_HW_RESET_CONTROL_1r_SIZE BCM56504_A0_EGR_HW_RESET_CONTROL_1r_SIZE
typedef BCM56504_A0_EGR_HW_RESET_CONTROL_1r_t EGR_HW_RESET_CONTROL_1r_t;
#define EGR_HW_RESET_CONTROL_1r_CLR BCM56504_A0_EGR_HW_RESET_CONTROL_1r_CLR
#define EGR_HW_RESET_CONTROL_1r_SET BCM56504_A0_EGR_HW_RESET_CONTROL_1r_SET
#define EGR_HW_RESET_CONTROL_1r_GET BCM56504_A0_EGR_HW_RESET_CONTROL_1r_GET
#define EGR_HW_RESET_CONTROL_1r_COUNTf_GET BCM56504_A0_EGR_HW_RESET_CONTROL_1r_COUNTf_GET
#define EGR_HW_RESET_CONTROL_1r_COUNTf_SET BCM56504_A0_EGR_HW_RESET_CONTROL_1r_COUNTf_SET
#define EGR_HW_RESET_CONTROL_1r_RESET_ALLf_GET BCM56504_A0_EGR_HW_RESET_CONTROL_1r_RESET_ALLf_GET
#define EGR_HW_RESET_CONTROL_1r_RESET_ALLf_SET BCM56504_A0_EGR_HW_RESET_CONTROL_1r_RESET_ALLf_SET
#define EGR_HW_RESET_CONTROL_1r_VALIDf_GET BCM56504_A0_EGR_HW_RESET_CONTROL_1r_VALIDf_GET
#define EGR_HW_RESET_CONTROL_1r_VALIDf_SET BCM56504_A0_EGR_HW_RESET_CONTROL_1r_VALIDf_SET
#define EGR_HW_RESET_CONTROL_1r_DONEf_GET BCM56504_A0_EGR_HW_RESET_CONTROL_1r_DONEf_GET
#define EGR_HW_RESET_CONTROL_1r_DONEf_SET BCM56504_A0_EGR_HW_RESET_CONTROL_1r_DONEf_SET
#define READ_EGR_HW_RESET_CONTROL_1r BCM56504_A0_READ_EGR_HW_RESET_CONTROL_1r
#define WRITE_EGR_HW_RESET_CONTROL_1r BCM56504_A0_WRITE_EGR_HW_RESET_CONTROL_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_EGR_HW_RESET_CONTROL_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  EGR_IM_MTP_INDEX
 * BLOCKS:   EPIPE
 * DESC:     Mirror to Port Table to be used for IM tagged packets. 
Index is constructed using pbe.mtp_index[6:0] field.
We use {pbe.mtp_index[4:3],pbe.mtp_index[2:0]} as index into this table.

 * SIZE:     11
 * FIELDS:
 *     MTP_DST_MODID    DST_MODID field to be used in the module header in case of mirroring.
 *     MTP_DST_PORT     DST_PORT field to be used in module header in case of mirroring.
 *
 ******************************************************************************/
#define BCM56504_A0_EGR_IM_MTP_INDEXm 0x05950000

#define BCM56504_A0_EGR_IM_MTP_INDEXm_MIN 0
#define BCM56504_A0_EGR_IM_MTP_INDEXm_MAX 31
#define BCM56504_A0_EGR_IM_MTP_INDEXm_CMAX(u) 31
#define BCM56504_A0_EGR_IM_MTP_INDEXm_SIZE 2

/*
 * This structure should be used to declare and program EGR_IM_MTP_INDEX.
 *
 */
typedef union BCM56504_A0_EGR_IM_MTP_INDEXm_s {
	uint32_t v[1];
	uint32_t egr_im_mtp_index[1];
	uint32_t _egr_im_mtp_index;
} BCM56504_A0_EGR_IM_MTP_INDEXm_t;

#define BCM56504_A0_EGR_IM_MTP_INDEXm_CLR(r) (r).egr_im_mtp_index[0] = 0
#define BCM56504_A0_EGR_IM_MTP_INDEXm_SET(r,d) (r).egr_im_mtp_index[0] = d
#define BCM56504_A0_EGR_IM_MTP_INDEXm_GET(r) (r).egr_im_mtp_index[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_EGR_IM_MTP_INDEXm_MTP_DST_MODIDf_GET(r) (((r).egr_im_mtp_index[0]) & 0x3f)
#define BCM56504_A0_EGR_IM_MTP_INDEXm_MTP_DST_MODIDf_SET(r,f) (r).egr_im_mtp_index[0]=(((r).egr_im_mtp_index[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM56504_A0_EGR_IM_MTP_INDEXm_MTP_DST_PORTf_GET(r) ((((r).egr_im_mtp_index[0]) >> 6) & 0x1f)
#define BCM56504_A0_EGR_IM_MTP_INDEXm_MTP_DST_PORTf_SET(r,f) (r).egr_im_mtp_index[0]=(((r).egr_im_mtp_index[0] & ~((uint32_t)0x1f << 6)) | ((((uint32_t)f) & 0x1f) << 6))

/*
 * These macros can be used to access EGR_IM_MTP_INDEX.
 *
 */
#define BCM56504_A0_READ_EGR_IM_MTP_INDEXm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_EGR_IM_MTP_INDEXm,i,(m._egr_im_mtp_index),1)
#define BCM56504_A0_WRITE_EGR_IM_MTP_INDEXm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_EGR_IM_MTP_INDEXm,i,&(m._egr_im_mtp_index),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_IM_MTP_INDEXm BCM56504_A0_EGR_IM_MTP_INDEXm
#define EGR_IM_MTP_INDEXm_MIN BCM56504_A0_EGR_IM_MTP_INDEXm_MIN
#define EGR_IM_MTP_INDEXm_MAX BCM56504_A0_EGR_IM_MTP_INDEXm_MAX
#define EGR_IM_MTP_INDEXm_CMAX(u) BCM56504_A0_EGR_IM_MTP_INDEXm_CMAX(u)
#define EGR_IM_MTP_INDEXm_SIZE BCM56504_A0_EGR_IM_MTP_INDEXm_SIZE
typedef BCM56504_A0_EGR_IM_MTP_INDEXm_t EGR_IM_MTP_INDEXm_t;
#define EGR_IM_MTP_INDEXm_CLR BCM56504_A0_EGR_IM_MTP_INDEXm_CLR
#define EGR_IM_MTP_INDEXm_SET BCM56504_A0_EGR_IM_MTP_INDEXm_SET
#define EGR_IM_MTP_INDEXm_GET BCM56504_A0_EGR_IM_MTP_INDEXm_GET
#define EGR_IM_MTP_INDEXm_MTP_DST_MODIDf_GET BCM56504_A0_EGR_IM_MTP_INDEXm_MTP_DST_MODIDf_GET
#define EGR_IM_MTP_INDEXm_MTP_DST_MODIDf_SET BCM56504_A0_EGR_IM_MTP_INDEXm_MTP_DST_MODIDf_SET
#define EGR_IM_MTP_INDEXm_MTP_DST_PORTf_GET BCM56504_A0_EGR_IM_MTP_INDEXm_MTP_DST_PORTf_GET
#define EGR_IM_MTP_INDEXm_MTP_DST_PORTf_SET BCM56504_A0_EGR_IM_MTP_INDEXm_MTP_DST_PORTf_SET
#define READ_EGR_IM_MTP_INDEXm BCM56504_A0_READ_EGR_IM_MTP_INDEXm
#define WRITE_EGR_IM_MTP_INDEXm BCM56504_A0_WRITE_EGR_IM_MTP_INDEXm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_EGR_IM_MTP_INDEXm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  EGR_IPMC_CFG2
 * BLOCKS:   EPIPE
 * DESC:     Configuration Register for IPMC related modifications.


 * SIZE:     32
 * FIELDS:
 *     DISABLE_TTL_DECREMENT Disable the TTL decrement in case of IPMC L3 routed packet.
 *     DISABLE_SA_REPLACE Disable the SA Replacement in case of IPMC L3 routed packet. 
 *     UNTAG            Untag the pkt in case of IPMC L3 routing. 
 *     VID              VID to be used for IPMC L3 packet untagging. For an IPMC L3 Routed packet, If UNTAG bit is set and the packet vid matches the VID field, the vlan tag is removed from the packet.For this function packet vid is selected on following basis.	For L3 packets 		- Vid from the interface table.
 *
 ******************************************************************************/
#define BCM56504_A0_EGR_IPMC_CFG2r 0x06900001

#define BCM56504_A0_EGR_IPMC_CFG2r_SIZE 4

/*
 * This structure should be used to declare and program EGR_IPMC_CFG2.
 *
 */
typedef union BCM56504_A0_EGR_IPMC_CFG2r_s {
	uint32_t v[1];
	uint32_t egr_ipmc_cfg2[1];
	uint32_t _egr_ipmc_cfg2;
} BCM56504_A0_EGR_IPMC_CFG2r_t;

#define BCM56504_A0_EGR_IPMC_CFG2r_CLR(r) (r).egr_ipmc_cfg2[0] = 0
#define BCM56504_A0_EGR_IPMC_CFG2r_SET(r,d) (r).egr_ipmc_cfg2[0] = d
#define BCM56504_A0_EGR_IPMC_CFG2r_GET(r) (r).egr_ipmc_cfg2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_EGR_IPMC_CFG2r_DISABLE_TTL_DECREMENTf_GET(r) (((r).egr_ipmc_cfg2[0]) & 0x1)
#define BCM56504_A0_EGR_IPMC_CFG2r_DISABLE_TTL_DECREMENTf_SET(r,f) (r).egr_ipmc_cfg2[0]=(((r).egr_ipmc_cfg2[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_EGR_IPMC_CFG2r_DISABLE_SA_REPLACEf_GET(r) ((((r).egr_ipmc_cfg2[0]) >> 1) & 0x1)
#define BCM56504_A0_EGR_IPMC_CFG2r_DISABLE_SA_REPLACEf_SET(r,f) (r).egr_ipmc_cfg2[0]=(((r).egr_ipmc_cfg2[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_EGR_IPMC_CFG2r_UNTAGf_GET(r) ((((r).egr_ipmc_cfg2[0]) >> 2) & 0x1)
#define BCM56504_A0_EGR_IPMC_CFG2r_UNTAGf_SET(r,f) (r).egr_ipmc_cfg2[0]=(((r).egr_ipmc_cfg2[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_EGR_IPMC_CFG2r_VIDf_GET(r) ((((r).egr_ipmc_cfg2[0]) >> 3) & 0xfff)
#define BCM56504_A0_EGR_IPMC_CFG2r_VIDf_SET(r,f) (r).egr_ipmc_cfg2[0]=(((r).egr_ipmc_cfg2[0] & ~((uint32_t)0xfff << 3)) | ((((uint32_t)f) & 0xfff) << 3))

/*
 * These macros can be used to access EGR_IPMC_CFG2.
 *
 */
#define BCM56504_A0_READ_EGR_IPMC_CFG2r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_EGR_IPMC_CFG2r,(r._egr_ipmc_cfg2))
#define BCM56504_A0_WRITE_EGR_IPMC_CFG2r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_EGR_IPMC_CFG2r,&(r._egr_ipmc_cfg2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_IPMC_CFG2r BCM56504_A0_EGR_IPMC_CFG2r
#define EGR_IPMC_CFG2r_SIZE BCM56504_A0_EGR_IPMC_CFG2r_SIZE
typedef BCM56504_A0_EGR_IPMC_CFG2r_t EGR_IPMC_CFG2r_t;
#define EGR_IPMC_CFG2r_CLR BCM56504_A0_EGR_IPMC_CFG2r_CLR
#define EGR_IPMC_CFG2r_SET BCM56504_A0_EGR_IPMC_CFG2r_SET
#define EGR_IPMC_CFG2r_GET BCM56504_A0_EGR_IPMC_CFG2r_GET
#define EGR_IPMC_CFG2r_DISABLE_TTL_DECREMENTf_GET BCM56504_A0_EGR_IPMC_CFG2r_DISABLE_TTL_DECREMENTf_GET
#define EGR_IPMC_CFG2r_DISABLE_TTL_DECREMENTf_SET BCM56504_A0_EGR_IPMC_CFG2r_DISABLE_TTL_DECREMENTf_SET
#define EGR_IPMC_CFG2r_DISABLE_SA_REPLACEf_GET BCM56504_A0_EGR_IPMC_CFG2r_DISABLE_SA_REPLACEf_GET
#define EGR_IPMC_CFG2r_DISABLE_SA_REPLACEf_SET BCM56504_A0_EGR_IPMC_CFG2r_DISABLE_SA_REPLACEf_SET
#define EGR_IPMC_CFG2r_UNTAGf_GET BCM56504_A0_EGR_IPMC_CFG2r_UNTAGf_GET
#define EGR_IPMC_CFG2r_UNTAGf_SET BCM56504_A0_EGR_IPMC_CFG2r_UNTAGf_SET
#define EGR_IPMC_CFG2r_VIDf_GET BCM56504_A0_EGR_IPMC_CFG2r_VIDf_GET
#define EGR_IPMC_CFG2r_VIDf_SET BCM56504_A0_EGR_IPMC_CFG2r_VIDf_SET
#define READ_EGR_IPMC_CFG2r BCM56504_A0_READ_EGR_IPMC_CFG2r
#define WRITE_EGR_IPMC_CFG2r BCM56504_A0_WRITE_EGR_IPMC_CFG2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_EGR_IPMC_CFG2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  EGR_IP_TUNNEL
 * BLOCKS:   EPIPE
 * DESC:     Egress IP Tunnel Table. Used to Make new Tunnel Header.
 * SIZE:     131
 * FIELDS:
 *     DEST_ADDR        MAC DA to be used to change the pkt mac da in case of IP Tunneling.
 *     TTL              TTL to be used in the IP Tunnel Header.
 *     SIP              Source IP Address to be used in the IP Tunnel Header.
 *     DIP              Destination IP Address to be used in the IP Tunnel Header.
 *     TUNNEL_TYPE      Specifies which Tunnel Protocol is Supported by this entry.
 *     DSCP             Specifies what should be the new DSCP to be put int he tunnel header.
 *     DSCP_SEL         Specifies which dscp to choose to put in the outer tunnel header.               DSCP_SEL                Defines selection of DSCP               00 - Pick up from Tunnel Table               01 - Pick up from Packet (PICK_FROM_PACKET)               10 - Pick up from DSCP table (PICK_FROM_DSCP_TABLE)               11 - Reserved
 *
 ******************************************************************************/
#define BCM56504_A0_EGR_IP_TUNNELm 0x05940000

#define BCM56504_A0_EGR_IP_TUNNELm_MIN 0
#define BCM56504_A0_EGR_IP_TUNNELm_MAX 127
#define BCM56504_A0_EGR_IP_TUNNELm_CMAX(u) 127
#define BCM56504_A0_EGR_IP_TUNNELm_SIZE 17

/*
 * This structure should be used to declare and program EGR_IP_TUNNEL.
 *
 */
typedef union BCM56504_A0_EGR_IP_TUNNELm_s {
	uint32_t v[5];
	uint32_t egr_ip_tunnel[5];
	uint32_t _egr_ip_tunnel;
} BCM56504_A0_EGR_IP_TUNNELm_t;

#define BCM56504_A0_EGR_IP_TUNNELm_CLR(r) CDK_MEMSET(&((r)._egr_ip_tunnel), 0, sizeof(BCM56504_A0_EGR_IP_TUNNELm_t))
#define BCM56504_A0_EGR_IP_TUNNELm_SET(r,i,d) (r).egr_ip_tunnel[i] = d
#define BCM56504_A0_EGR_IP_TUNNELm_GET(r,i) (r).egr_ip_tunnel[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_EGR_IP_TUNNELm_DEST_ADDRf_GET(r,a) cdk_field_get((r).egr_ip_tunnel,0,47,a)
#define BCM56504_A0_EGR_IP_TUNNELm_DEST_ADDRf_SET(r,a) cdk_field_set((r).egr_ip_tunnel,0,47,a)
#define BCM56504_A0_EGR_IP_TUNNELm_TTLf_GET(r) ((((r).egr_ip_tunnel[1]) >> 16) & 0xff)
#define BCM56504_A0_EGR_IP_TUNNELm_TTLf_SET(r,f) (r).egr_ip_tunnel[1]=(((r).egr_ip_tunnel[1] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define BCM56504_A0_EGR_IP_TUNNELm_SIPf_GET(r) cdk_field32_get((r).egr_ip_tunnel,56,87)
#define BCM56504_A0_EGR_IP_TUNNELm_SIPf_SET(r,f) cdk_field32_set((r).egr_ip_tunnel,56,87,f)
#define BCM56504_A0_EGR_IP_TUNNELm_DIPf_GET(r) cdk_field32_get((r).egr_ip_tunnel,88,119)
#define BCM56504_A0_EGR_IP_TUNNELm_DIPf_SET(r,f) cdk_field32_set((r).egr_ip_tunnel,88,119,f)
#define BCM56504_A0_EGR_IP_TUNNELm_TUNNEL_TYPEf_GET(r) ((((r).egr_ip_tunnel[3]) >> 24) & 0x7)
#define BCM56504_A0_EGR_IP_TUNNELm_TUNNEL_TYPEf_SET(r,f) (r).egr_ip_tunnel[3]=(((r).egr_ip_tunnel[3] & ~((uint32_t)0x7 << 24)) | ((((uint32_t)f) & 0x7) << 24))
#define BCM56504_A0_EGR_IP_TUNNELm_DSCPf_GET(r) cdk_field32_get((r).egr_ip_tunnel,123,128)
#define BCM56504_A0_EGR_IP_TUNNELm_DSCPf_SET(r,f) cdk_field32_set((r).egr_ip_tunnel,123,128,f)
#define BCM56504_A0_EGR_IP_TUNNELm_DSCP_SELf_GET(r) ((((r).egr_ip_tunnel[4]) >> 1) & 0x3)
#define BCM56504_A0_EGR_IP_TUNNELm_DSCP_SELf_SET(r,f) (r).egr_ip_tunnel[4]=(((r).egr_ip_tunnel[4] & ~((uint32_t)0x3 << 1)) | ((((uint32_t)f) & 0x3) << 1))

/*
 * These macros can be used to access EGR_IP_TUNNEL.
 *
 */
#define BCM56504_A0_READ_EGR_IP_TUNNELm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_EGR_IP_TUNNELm,i,(m._egr_ip_tunnel),5)
#define BCM56504_A0_WRITE_EGR_IP_TUNNELm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_EGR_IP_TUNNELm,i,&(m._egr_ip_tunnel),5)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_IP_TUNNELm BCM56504_A0_EGR_IP_TUNNELm
#define EGR_IP_TUNNELm_MIN BCM56504_A0_EGR_IP_TUNNELm_MIN
#define EGR_IP_TUNNELm_MAX BCM56504_A0_EGR_IP_TUNNELm_MAX
#define EGR_IP_TUNNELm_CMAX(u) BCM56504_A0_EGR_IP_TUNNELm_CMAX(u)
#define EGR_IP_TUNNELm_SIZE BCM56504_A0_EGR_IP_TUNNELm_SIZE
typedef BCM56504_A0_EGR_IP_TUNNELm_t EGR_IP_TUNNELm_t;
#define EGR_IP_TUNNELm_CLR BCM56504_A0_EGR_IP_TUNNELm_CLR
#define EGR_IP_TUNNELm_SET BCM56504_A0_EGR_IP_TUNNELm_SET
#define EGR_IP_TUNNELm_GET BCM56504_A0_EGR_IP_TUNNELm_GET
#define EGR_IP_TUNNELm_DEST_ADDRf_GET BCM56504_A0_EGR_IP_TUNNELm_DEST_ADDRf_GET
#define EGR_IP_TUNNELm_DEST_ADDRf_SET BCM56504_A0_EGR_IP_TUNNELm_DEST_ADDRf_SET
#define EGR_IP_TUNNELm_TTLf_GET BCM56504_A0_EGR_IP_TUNNELm_TTLf_GET
#define EGR_IP_TUNNELm_TTLf_SET BCM56504_A0_EGR_IP_TUNNELm_TTLf_SET
#define EGR_IP_TUNNELm_SIPf_GET BCM56504_A0_EGR_IP_TUNNELm_SIPf_GET
#define EGR_IP_TUNNELm_SIPf_SET BCM56504_A0_EGR_IP_TUNNELm_SIPf_SET
#define EGR_IP_TUNNELm_DIPf_GET BCM56504_A0_EGR_IP_TUNNELm_DIPf_GET
#define EGR_IP_TUNNELm_DIPf_SET BCM56504_A0_EGR_IP_TUNNELm_DIPf_SET
#define EGR_IP_TUNNELm_TUNNEL_TYPEf_GET BCM56504_A0_EGR_IP_TUNNELm_TUNNEL_TYPEf_GET
#define EGR_IP_TUNNELm_TUNNEL_TYPEf_SET BCM56504_A0_EGR_IP_TUNNELm_TUNNEL_TYPEf_SET
#define EGR_IP_TUNNELm_DSCPf_GET BCM56504_A0_EGR_IP_TUNNELm_DSCPf_GET
#define EGR_IP_TUNNELm_DSCPf_SET BCM56504_A0_EGR_IP_TUNNELm_DSCPf_SET
#define EGR_IP_TUNNELm_DSCP_SELf_GET BCM56504_A0_EGR_IP_TUNNELm_DSCP_SELf_GET
#define EGR_IP_TUNNELm_DSCP_SELf_SET BCM56504_A0_EGR_IP_TUNNELm_DSCP_SELf_SET
#define READ_EGR_IP_TUNNELm BCM56504_A0_READ_EGR_IP_TUNNELm
#define WRITE_EGR_IP_TUNNELm BCM56504_A0_WRITE_EGR_IP_TUNNELm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_EGR_IP_TUNNELm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  EGR_L3_INTF
 * BLOCKS:   EPIPE
 * DESC:     L3 Interface Table
 * SIZE:     76
 * FIELDS:
 *     TUNNEL_INDEX     Tunnel Index to be used to search EGR_IP_TUNNEL table.
 *     L2_SWITCH        Indicates if the packet needs to be only L2 Switched and only L2 modifications needs to be done.
 *     VID              VID to be used for L3 replacement
 *     TTL_THRESHOLD    TTL Threshold to be used for L3 TTL checks.
 *     MAC_ADDRESS      MAC Address to be used for SA Replacement in the L3 modifications.
 *
 ******************************************************************************/
#define BCM56504_A0_EGR_L3_INTFm 0x03920000

#define BCM56504_A0_EGR_L3_INTFm_MIN 0
#define BCM56504_A0_EGR_L3_INTFm_MAX 4095
#define BCM56504_A0_EGR_L3_INTFm_CMAX(u) 4095
#define BCM56504_A0_EGR_L3_INTFm_SIZE 10

/*
 * This structure should be used to declare and program EGR_L3_INTF.
 *
 */
typedef union BCM56504_A0_EGR_L3_INTFm_s {
	uint32_t v[3];
	uint32_t egr_l3_intf[3];
	uint32_t _egr_l3_intf;
} BCM56504_A0_EGR_L3_INTFm_t;

#define BCM56504_A0_EGR_L3_INTFm_CLR(r) CDK_MEMSET(&((r)._egr_l3_intf), 0, sizeof(BCM56504_A0_EGR_L3_INTFm_t))
#define BCM56504_A0_EGR_L3_INTFm_SET(r,i,d) (r).egr_l3_intf[i] = d
#define BCM56504_A0_EGR_L3_INTFm_GET(r,i) (r).egr_l3_intf[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_EGR_L3_INTFm_TUNNEL_INDEXf_GET(r) (((r).egr_l3_intf[0]) & 0x7f)
#define BCM56504_A0_EGR_L3_INTFm_TUNNEL_INDEXf_SET(r,f) (r).egr_l3_intf[0]=(((r).egr_l3_intf[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f))
#define BCM56504_A0_EGR_L3_INTFm_L2_SWITCHf_GET(r) ((((r).egr_l3_intf[0]) >> 7) & 0x1)
#define BCM56504_A0_EGR_L3_INTFm_L2_SWITCHf_SET(r,f) (r).egr_l3_intf[0]=(((r).egr_l3_intf[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56504_A0_EGR_L3_INTFm_VIDf_GET(r) ((((r).egr_l3_intf[0]) >> 8) & 0xfff)
#define BCM56504_A0_EGR_L3_INTFm_VIDf_SET(r,f) (r).egr_l3_intf[0]=(((r).egr_l3_intf[0] & ~((uint32_t)0xfff << 8)) | ((((uint32_t)f) & 0xfff) << 8))
#define BCM56504_A0_EGR_L3_INTFm_TTL_THRESHOLDf_GET(r) ((((r).egr_l3_intf[0]) >> 20) & 0xff)
#define BCM56504_A0_EGR_L3_INTFm_TTL_THRESHOLDf_SET(r,f) (r).egr_l3_intf[0]=(((r).egr_l3_intf[0] & ~((uint32_t)0xff << 20)) | ((((uint32_t)f) & 0xff) << 20))
#define BCM56504_A0_EGR_L3_INTFm_MAC_ADDRESSf_GET(r,a) cdk_field_get((r).egr_l3_intf,28,75,a)
#define BCM56504_A0_EGR_L3_INTFm_MAC_ADDRESSf_SET(r,a) cdk_field_set((r).egr_l3_intf,28,75,a)

/*
 * These macros can be used to access EGR_L3_INTF.
 *
 */
#define BCM56504_A0_READ_EGR_L3_INTFm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_EGR_L3_INTFm,i,(m._egr_l3_intf),3)
#define BCM56504_A0_WRITE_EGR_L3_INTFm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_EGR_L3_INTFm,i,&(m._egr_l3_intf),3)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_L3_INTFm BCM56504_A0_EGR_L3_INTFm
#define EGR_L3_INTFm_MIN BCM56504_A0_EGR_L3_INTFm_MIN
#define EGR_L3_INTFm_MAX BCM56504_A0_EGR_L3_INTFm_MAX
#define EGR_L3_INTFm_CMAX(u) BCM56504_A0_EGR_L3_INTFm_CMAX(u)
#define EGR_L3_INTFm_SIZE BCM56504_A0_EGR_L3_INTFm_SIZE
typedef BCM56504_A0_EGR_L3_INTFm_t EGR_L3_INTFm_t;
#define EGR_L3_INTFm_CLR BCM56504_A0_EGR_L3_INTFm_CLR
#define EGR_L3_INTFm_SET BCM56504_A0_EGR_L3_INTFm_SET
#define EGR_L3_INTFm_GET BCM56504_A0_EGR_L3_INTFm_GET
#define EGR_L3_INTFm_TUNNEL_INDEXf_GET BCM56504_A0_EGR_L3_INTFm_TUNNEL_INDEXf_GET
#define EGR_L3_INTFm_TUNNEL_INDEXf_SET BCM56504_A0_EGR_L3_INTFm_TUNNEL_INDEXf_SET
#define EGR_L3_INTFm_L2_SWITCHf_GET BCM56504_A0_EGR_L3_INTFm_L2_SWITCHf_GET
#define EGR_L3_INTFm_L2_SWITCHf_SET BCM56504_A0_EGR_L3_INTFm_L2_SWITCHf_SET
#define EGR_L3_INTFm_VIDf_GET BCM56504_A0_EGR_L3_INTFm_VIDf_GET
#define EGR_L3_INTFm_VIDf_SET BCM56504_A0_EGR_L3_INTFm_VIDf_SET
#define EGR_L3_INTFm_TTL_THRESHOLDf_GET BCM56504_A0_EGR_L3_INTFm_TTL_THRESHOLDf_GET
#define EGR_L3_INTFm_TTL_THRESHOLDf_SET BCM56504_A0_EGR_L3_INTFm_TTL_THRESHOLDf_SET
#define EGR_L3_INTFm_MAC_ADDRESSf_GET BCM56504_A0_EGR_L3_INTFm_MAC_ADDRESSf_GET
#define EGR_L3_INTFm_MAC_ADDRESSf_SET BCM56504_A0_EGR_L3_INTFm_MAC_ADDRESSf_SET
#define READ_EGR_L3_INTFm BCM56504_A0_READ_EGR_L3_INTFm
#define WRITE_EGR_L3_INTFm BCM56504_A0_WRITE_EGR_L3_INTFm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_EGR_L3_INTFm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  EGR_L3_NEXT_HOP
 * BLOCKS:   EPIPE
 * DESC:     Next Hop Table
 * SIZE:     60
 * FIELDS:
 *     INTF_NUM         Interface Number to be used as index for L3_INTF table or VID for FP pkt change cases.
 *     MAC_ADDRESS      Mac Addres to be used for DA replacement by L3UC or FP modified packets.
 *
 ******************************************************************************/
#define BCM56504_A0_EGR_L3_NEXT_HOPm 0x03910000

#define BCM56504_A0_EGR_L3_NEXT_HOPm_MIN 0
#define BCM56504_A0_EGR_L3_NEXT_HOPm_MAX 8191
#define BCM56504_A0_EGR_L3_NEXT_HOPm_CMAX(u) 8191
#define BCM56504_A0_EGR_L3_NEXT_HOPm_SIZE 8

/*
 * This structure should be used to declare and program EGR_L3_NEXT_HOP.
 *
 */
typedef union BCM56504_A0_EGR_L3_NEXT_HOPm_s {
	uint32_t v[2];
	uint32_t egr_l3_next_hop[2];
	uint32_t _egr_l3_next_hop;
} BCM56504_A0_EGR_L3_NEXT_HOPm_t;

#define BCM56504_A0_EGR_L3_NEXT_HOPm_CLR(r) CDK_MEMSET(&((r)._egr_l3_next_hop), 0, sizeof(BCM56504_A0_EGR_L3_NEXT_HOPm_t))
#define BCM56504_A0_EGR_L3_NEXT_HOPm_SET(r,i,d) (r).egr_l3_next_hop[i] = d
#define BCM56504_A0_EGR_L3_NEXT_HOPm_GET(r,i) (r).egr_l3_next_hop[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_EGR_L3_NEXT_HOPm_INTF_NUMf_GET(r) (((r).egr_l3_next_hop[0]) & 0xfff)
#define BCM56504_A0_EGR_L3_NEXT_HOPm_INTF_NUMf_SET(r,f) (r).egr_l3_next_hop[0]=(((r).egr_l3_next_hop[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM56504_A0_EGR_L3_NEXT_HOPm_MAC_ADDRESSf_GET(r,a) cdk_field_get((r).egr_l3_next_hop,12,59,a)
#define BCM56504_A0_EGR_L3_NEXT_HOPm_MAC_ADDRESSf_SET(r,a) cdk_field_set((r).egr_l3_next_hop,12,59,a)

/*
 * These macros can be used to access EGR_L3_NEXT_HOP.
 *
 */
#define BCM56504_A0_READ_EGR_L3_NEXT_HOPm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_EGR_L3_NEXT_HOPm,i,(m._egr_l3_next_hop),2)
#define BCM56504_A0_WRITE_EGR_L3_NEXT_HOPm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_EGR_L3_NEXT_HOPm,i,&(m._egr_l3_next_hop),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_L3_NEXT_HOPm BCM56504_A0_EGR_L3_NEXT_HOPm
#define EGR_L3_NEXT_HOPm_MIN BCM56504_A0_EGR_L3_NEXT_HOPm_MIN
#define EGR_L3_NEXT_HOPm_MAX BCM56504_A0_EGR_L3_NEXT_HOPm_MAX
#define EGR_L3_NEXT_HOPm_CMAX(u) BCM56504_A0_EGR_L3_NEXT_HOPm_CMAX(u)
#define EGR_L3_NEXT_HOPm_SIZE BCM56504_A0_EGR_L3_NEXT_HOPm_SIZE
typedef BCM56504_A0_EGR_L3_NEXT_HOPm_t EGR_L3_NEXT_HOPm_t;
#define EGR_L3_NEXT_HOPm_CLR BCM56504_A0_EGR_L3_NEXT_HOPm_CLR
#define EGR_L3_NEXT_HOPm_SET BCM56504_A0_EGR_L3_NEXT_HOPm_SET
#define EGR_L3_NEXT_HOPm_GET BCM56504_A0_EGR_L3_NEXT_HOPm_GET
#define EGR_L3_NEXT_HOPm_INTF_NUMf_GET BCM56504_A0_EGR_L3_NEXT_HOPm_INTF_NUMf_GET
#define EGR_L3_NEXT_HOPm_INTF_NUMf_SET BCM56504_A0_EGR_L3_NEXT_HOPm_INTF_NUMf_SET
#define EGR_L3_NEXT_HOPm_MAC_ADDRESSf_GET BCM56504_A0_EGR_L3_NEXT_HOPm_MAC_ADDRESSf_GET
#define EGR_L3_NEXT_HOPm_MAC_ADDRESSf_SET BCM56504_A0_EGR_L3_NEXT_HOPm_MAC_ADDRESSf_SET
#define READ_EGR_L3_NEXT_HOPm BCM56504_A0_READ_EGR_L3_NEXT_HOPm
#define WRITE_EGR_L3_NEXT_HOPm BCM56504_A0_WRITE_EGR_L3_NEXT_HOPm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_EGR_L3_NEXT_HOPm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  EGR_MASK
 * BLOCKS:   IPIPE
 * DESC:     Egress Mask Table
 * SIZE:     29
 * FIELDS:
 *     EGRESS_MASK      Egress mask block mask for source port
 *
 ******************************************************************************/
#define BCM56504_A0_EGR_MASKm 0x0e700000

#define BCM56504_A0_EGR_MASKm_MIN 0
#define BCM56504_A0_EGR_MASKm_MAX 2047
#define BCM56504_A0_EGR_MASKm_CMAX(u) 2047
#define BCM56504_A0_EGR_MASKm_SIZE 4

/*
 * This structure should be used to declare and program EGR_MASK.
 *
 */
typedef union BCM56504_A0_EGR_MASKm_s {
	uint32_t v[1];
	uint32_t egr_mask[1];
	uint32_t _egr_mask;
} BCM56504_A0_EGR_MASKm_t;

#define BCM56504_A0_EGR_MASKm_CLR(r) (r).egr_mask[0] = 0
#define BCM56504_A0_EGR_MASKm_SET(r,d) (r).egr_mask[0] = d
#define BCM56504_A0_EGR_MASKm_GET(r) (r).egr_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_EGR_MASKm_EGRESS_MASKf_GET(r) (((r).egr_mask[0]) & 0x1fffffff)
#define BCM56504_A0_EGR_MASKm_EGRESS_MASKf_SET(r,f) (r).egr_mask[0]=(((r).egr_mask[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))

/*
 * These macros can be used to access EGR_MASK.
 *
 */
#define BCM56504_A0_READ_EGR_MASKm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_EGR_MASKm,i,(m._egr_mask),1)
#define BCM56504_A0_WRITE_EGR_MASKm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_EGR_MASKm,i,&(m._egr_mask),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_MASKm BCM56504_A0_EGR_MASKm
#define EGR_MASKm_MIN BCM56504_A0_EGR_MASKm_MIN
#define EGR_MASKm_MAX BCM56504_A0_EGR_MASKm_MAX
#define EGR_MASKm_CMAX(u) BCM56504_A0_EGR_MASKm_CMAX(u)
#define EGR_MASKm_SIZE BCM56504_A0_EGR_MASKm_SIZE
typedef BCM56504_A0_EGR_MASKm_t EGR_MASKm_t;
#define EGR_MASKm_CLR BCM56504_A0_EGR_MASKm_CLR
#define EGR_MASKm_SET BCM56504_A0_EGR_MASKm_SET
#define EGR_MASKm_GET BCM56504_A0_EGR_MASKm_GET
#define EGR_MASKm_EGRESS_MASKf_GET BCM56504_A0_EGR_MASKm_EGRESS_MASKf_GET
#define EGR_MASKm_EGRESS_MASKf_SET BCM56504_A0_EGR_MASKm_EGRESS_MASKf_SET
#define READ_EGR_MASKm BCM56504_A0_READ_EGR_MASKm
#define WRITE_EGR_MASKm BCM56504_A0_WRITE_EGR_MASKm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_EGR_MASKm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  EGR_MMU_REQUESTS
 * BLOCKS:   EPIPE
 * DESC:     This register contains the cell requests asserted by TP for individual ports to MMU.
Meaning of cell request is 1024 bits data. All it shows is the number of times cell_request signal
was asserted by TP to MMU for each port. 

 * SIZE:     32
 * FIELDS:
 *     OUTSTANDING_PORT_REQUESTS Number of cell requests.
 *
 ******************************************************************************/
#define BCM56504_A0_EGR_MMU_REQUESTSr 0x0a900102

#define BCM56504_A0_EGR_MMU_REQUESTSr_SIZE 4

/*
 * This structure should be used to declare and program EGR_MMU_REQUESTS.
 *
 */
typedef union BCM56504_A0_EGR_MMU_REQUESTSr_s {
	uint32_t v[1];
	uint32_t egr_mmu_requests[1];
	uint32_t _egr_mmu_requests;
} BCM56504_A0_EGR_MMU_REQUESTSr_t;

#define BCM56504_A0_EGR_MMU_REQUESTSr_CLR(r) (r).egr_mmu_requests[0] = 0
#define BCM56504_A0_EGR_MMU_REQUESTSr_SET(r,d) (r).egr_mmu_requests[0] = d
#define BCM56504_A0_EGR_MMU_REQUESTSr_GET(r) (r).egr_mmu_requests[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_EGR_MMU_REQUESTSr_OUTSTANDING_PORT_REQUESTSf_GET(r) (((r).egr_mmu_requests[0]) & 0xf)
#define BCM56504_A0_EGR_MMU_REQUESTSr_OUTSTANDING_PORT_REQUESTSf_SET(r,f) (r).egr_mmu_requests[0]=(((r).egr_mmu_requests[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access EGR_MMU_REQUESTS.
 *
 */
#define BCM56504_A0_READ_EGR_MMU_REQUESTSr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_EGR_MMU_REQUESTSr,(r._egr_mmu_requests))
#define BCM56504_A0_WRITE_EGR_MMU_REQUESTSr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_EGR_MMU_REQUESTSr,&(r._egr_mmu_requests))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_MMU_REQUESTSr BCM56504_A0_EGR_MMU_REQUESTSr
#define EGR_MMU_REQUESTSr_SIZE BCM56504_A0_EGR_MMU_REQUESTSr_SIZE
typedef BCM56504_A0_EGR_MMU_REQUESTSr_t EGR_MMU_REQUESTSr_t;
#define EGR_MMU_REQUESTSr_CLR BCM56504_A0_EGR_MMU_REQUESTSr_CLR
#define EGR_MMU_REQUESTSr_SET BCM56504_A0_EGR_MMU_REQUESTSr_SET
#define EGR_MMU_REQUESTSr_GET BCM56504_A0_EGR_MMU_REQUESTSr_GET
#define EGR_MMU_REQUESTSr_OUTSTANDING_PORT_REQUESTSf_GET BCM56504_A0_EGR_MMU_REQUESTSr_OUTSTANDING_PORT_REQUESTSf_GET
#define EGR_MMU_REQUESTSr_OUTSTANDING_PORT_REQUESTSf_SET BCM56504_A0_EGR_MMU_REQUESTSr_OUTSTANDING_PORT_REQUESTSf_SET
#define READ_EGR_MMU_REQUESTSr BCM56504_A0_READ_EGR_MMU_REQUESTSr
#define WRITE_EGR_MMU_REQUESTSr BCM56504_A0_WRITE_EGR_MMU_REQUESTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_EGR_MMU_REQUESTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  EGR_MTU_SIZE
 * BLOCKS:   IPIPE
 * DESC:     Egress MTU Size Register
 * SIZE:     32
 * FIELDS:
 *     MTU_SIZE         Egress ports MTU limit
 *
 ******************************************************************************/
#define BCM56504_A0_EGR_MTU_SIZEr 0x0e700114

#define BCM56504_A0_EGR_MTU_SIZEr_SIZE 4

/*
 * This structure should be used to declare and program EGR_MTU_SIZE.
 *
 */
typedef union BCM56504_A0_EGR_MTU_SIZEr_s {
	uint32_t v[1];
	uint32_t egr_mtu_size[1];
	uint32_t _egr_mtu_size;
} BCM56504_A0_EGR_MTU_SIZEr_t;

#define BCM56504_A0_EGR_MTU_SIZEr_CLR(r) (r).egr_mtu_size[0] = 0
#define BCM56504_A0_EGR_MTU_SIZEr_SET(r,d) (r).egr_mtu_size[0] = d
#define BCM56504_A0_EGR_MTU_SIZEr_GET(r) (r).egr_mtu_size[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_EGR_MTU_SIZEr_MTU_SIZEf_GET(r) (((r).egr_mtu_size[0]) & 0x3fff)
#define BCM56504_A0_EGR_MTU_SIZEr_MTU_SIZEf_SET(r,f) (r).egr_mtu_size[0]=(((r).egr_mtu_size[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access EGR_MTU_SIZE.
 *
 */
#define BCM56504_A0_READ_EGR_MTU_SIZEr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_EGR_MTU_SIZEr,(r._egr_mtu_size))
#define BCM56504_A0_WRITE_EGR_MTU_SIZEr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_EGR_MTU_SIZEr,&(r._egr_mtu_size))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_MTU_SIZEr BCM56504_A0_EGR_MTU_SIZEr
#define EGR_MTU_SIZEr_SIZE BCM56504_A0_EGR_MTU_SIZEr_SIZE
typedef BCM56504_A0_EGR_MTU_SIZEr_t EGR_MTU_SIZEr_t;
#define EGR_MTU_SIZEr_CLR BCM56504_A0_EGR_MTU_SIZEr_CLR
#define EGR_MTU_SIZEr_SET BCM56504_A0_EGR_MTU_SIZEr_SET
#define EGR_MTU_SIZEr_GET BCM56504_A0_EGR_MTU_SIZEr_GET
#define EGR_MTU_SIZEr_MTU_SIZEf_GET BCM56504_A0_EGR_MTU_SIZEr_MTU_SIZEf_GET
#define EGR_MTU_SIZEr_MTU_SIZEf_SET BCM56504_A0_EGR_MTU_SIZEr_MTU_SIZEf_SET
#define READ_EGR_MTU_SIZEr BCM56504_A0_READ_EGR_MTU_SIZEr
#define WRITE_EGR_MTU_SIZEr BCM56504_A0_WRITE_EGR_MTU_SIZEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_EGR_MTU_SIZEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  EGR_PORT
 * BLOCKS:   EPIPE
 * DESC:     Configuration Register for a Port. This is different for each GE, 10GE port.


 * SIZE:     32
 * FIELDS:
 *     PORT_TYPE        Specifies the type of the port. Bit[0] of PORT_TYPE field is HIGIG_BIT. If it is set, then the port is in Higig Mode.	0 = GE/10GE/CPU Port.	1 = HIGIG Port.Bit[1] of PORT_TYPE field is NNI_BIT. If it is set, then the port is NNI port, else UNI Port.	0 = UNI Port.	1 = NNI Port.
 *     EN_EFILTER       If this bit is set, the VLAN Membership check is done for the outgoing port.
 *     PRESERVE_CPU_TAG Preserve the tag of the packet destines to CPU.
 *     CFI              If CFI-CNG mapping is enabled for the chip, i.e. EGR_CONFIG.CFI_AS_CNG bit is set, then thisfield corresponds to the values of CNG coming from MMU. e.g. If MMU.CNG = 0, then Packet.CFI = CFI[0]     If MMU.CNG = 1, then Packet.CFI = CFI[1] and so on.
 *     HIGIG_PACKET     This port is a higig port.
 *     NNI_PORT         Port is NNI port if set to 1, otherwise UNI port.
 *
 ******************************************************************************/
#define BCM56504_A0_EGR_PORTr 0x01900002

#define BCM56504_A0_EGR_PORTr_SIZE 4

/*
 * This structure should be used to declare and program EGR_PORT.
 *
 */
typedef union BCM56504_A0_EGR_PORTr_s {
	uint32_t v[1];
	uint32_t egr_port[1];
	uint32_t _egr_port;
} BCM56504_A0_EGR_PORTr_t;

#define BCM56504_A0_EGR_PORTr_CLR(r) (r).egr_port[0] = 0
#define BCM56504_A0_EGR_PORTr_SET(r,d) (r).egr_port[0] = d
#define BCM56504_A0_EGR_PORTr_GET(r) (r).egr_port[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_EGR_PORTr_PORT_TYPEf_GET(r) (((r).egr_port[0]) & 0x3)
#define BCM56504_A0_EGR_PORTr_PORT_TYPEf_SET(r,f) (r).egr_port[0]=(((r).egr_port[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56504_A0_EGR_PORTr_EN_EFILTERf_GET(r) ((((r).egr_port[0]) >> 2) & 0x1)
#define BCM56504_A0_EGR_PORTr_EN_EFILTERf_SET(r,f) (r).egr_port[0]=(((r).egr_port[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_EGR_PORTr_PRESERVE_CPU_TAGf_GET(r) ((((r).egr_port[0]) >> 3) & 0x1)
#define BCM56504_A0_EGR_PORTr_PRESERVE_CPU_TAGf_SET(r,f) (r).egr_port[0]=(((r).egr_port[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_EGR_PORTr_CFIf_GET(r) ((((r).egr_port[0]) >> 4) & 0xf)
#define BCM56504_A0_EGR_PORTr_CFIf_SET(r,f) (r).egr_port[0]=(((r).egr_port[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56504_A0_EGR_PORTr_HIGIG_PACKETf_GET(r) (((r).egr_port[0]) & 0x1)
#define BCM56504_A0_EGR_PORTr_HIGIG_PACKETf_SET(r,f) (r).egr_port[0]=(((r).egr_port[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_EGR_PORTr_NNI_PORTf_GET(r) ((((r).egr_port[0]) >> 1) & 0x1)
#define BCM56504_A0_EGR_PORTr_NNI_PORTf_SET(r,f) (r).egr_port[0]=(((r).egr_port[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access EGR_PORT.
 *
 */
#define BCM56504_A0_READ_EGR_PORTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_EGR_PORTr,(r._egr_port))
#define BCM56504_A0_WRITE_EGR_PORTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_EGR_PORTr,&(r._egr_port))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_PORTr BCM56504_A0_EGR_PORTr
#define EGR_PORTr_SIZE BCM56504_A0_EGR_PORTr_SIZE
typedef BCM56504_A0_EGR_PORTr_t EGR_PORTr_t;
#define EGR_PORTr_CLR BCM56504_A0_EGR_PORTr_CLR
#define EGR_PORTr_SET BCM56504_A0_EGR_PORTr_SET
#define EGR_PORTr_GET BCM56504_A0_EGR_PORTr_GET
#define EGR_PORTr_PORT_TYPEf_GET BCM56504_A0_EGR_PORTr_PORT_TYPEf_GET
#define EGR_PORTr_PORT_TYPEf_SET BCM56504_A0_EGR_PORTr_PORT_TYPEf_SET
#define EGR_PORTr_EN_EFILTERf_GET BCM56504_A0_EGR_PORTr_EN_EFILTERf_GET
#define EGR_PORTr_EN_EFILTERf_SET BCM56504_A0_EGR_PORTr_EN_EFILTERf_SET
#define EGR_PORTr_PRESERVE_CPU_TAGf_GET BCM56504_A0_EGR_PORTr_PRESERVE_CPU_TAGf_GET
#define EGR_PORTr_PRESERVE_CPU_TAGf_SET BCM56504_A0_EGR_PORTr_PRESERVE_CPU_TAGf_SET
#define EGR_PORTr_CFIf_GET BCM56504_A0_EGR_PORTr_CFIf_GET
#define EGR_PORTr_CFIf_SET BCM56504_A0_EGR_PORTr_CFIf_SET
#define EGR_PORTr_HIGIG_PACKETf_GET BCM56504_A0_EGR_PORTr_HIGIG_PACKETf_GET
#define EGR_PORTr_HIGIG_PACKETf_SET BCM56504_A0_EGR_PORTr_HIGIG_PACKETf_SET
#define EGR_PORTr_NNI_PORTf_GET BCM56504_A0_EGR_PORTr_NNI_PORTf_GET
#define EGR_PORTr_NNI_PORTf_SET BCM56504_A0_EGR_PORTr_NNI_PORTf_SET
#define READ_EGR_PORTr BCM56504_A0_READ_EGR_PORTr
#define WRITE_EGR_PORTr BCM56504_A0_WRITE_EGR_PORTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_EGR_PORTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  EGR_PORT_L3UC_MODS
 * BLOCKS:   EPIPE
 * DESC:     Configuration Register for IPMC related modifications.


 * SIZE:     32
 * FIELDS:
 *     L3_UC_SA_DISABLE Disable the SA replacement for L3UC packets coming from a particular port. This register is indexed in EP based on the src_port_num.
 *     L3_UC_DA_DISABLE Disable the DA replacement for L3UC packets coming from a particular port. This register is indexed in EP based on the src_port_num.
 *     L3_UC_TTL_DISABLE Disable the TTL decrement for L3UC packets coming from a particular port. This register is indexed in EP based on the src_port_num.
 *     L3_UC_VLAN_DISABLE Disable the outer VID replacement for L3UC packets coming from a particular port. This register is indexed in EP based on the src_port_num.
 *
 ******************************************************************************/
#define BCM56504_A0_EGR_PORT_L3UC_MODSr 0x06900002

#define BCM56504_A0_EGR_PORT_L3UC_MODSr_SIZE 4

/*
 * This structure should be used to declare and program EGR_PORT_L3UC_MODS.
 *
 */
typedef union BCM56504_A0_EGR_PORT_L3UC_MODSr_s {
	uint32_t v[1];
	uint32_t egr_port_l3uc_mods[1];
	uint32_t _egr_port_l3uc_mods;
} BCM56504_A0_EGR_PORT_L3UC_MODSr_t;

#define BCM56504_A0_EGR_PORT_L3UC_MODSr_CLR(r) (r).egr_port_l3uc_mods[0] = 0
#define BCM56504_A0_EGR_PORT_L3UC_MODSr_SET(r,d) (r).egr_port_l3uc_mods[0] = d
#define BCM56504_A0_EGR_PORT_L3UC_MODSr_GET(r) (r).egr_port_l3uc_mods[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_EGR_PORT_L3UC_MODSr_L3_UC_SA_DISABLEf_GET(r) (((r).egr_port_l3uc_mods[0]) & 0x1)
#define BCM56504_A0_EGR_PORT_L3UC_MODSr_L3_UC_SA_DISABLEf_SET(r,f) (r).egr_port_l3uc_mods[0]=(((r).egr_port_l3uc_mods[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_EGR_PORT_L3UC_MODSr_L3_UC_DA_DISABLEf_GET(r) ((((r).egr_port_l3uc_mods[0]) >> 1) & 0x1)
#define BCM56504_A0_EGR_PORT_L3UC_MODSr_L3_UC_DA_DISABLEf_SET(r,f) (r).egr_port_l3uc_mods[0]=(((r).egr_port_l3uc_mods[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_EGR_PORT_L3UC_MODSr_L3_UC_TTL_DISABLEf_GET(r) ((((r).egr_port_l3uc_mods[0]) >> 2) & 0x1)
#define BCM56504_A0_EGR_PORT_L3UC_MODSr_L3_UC_TTL_DISABLEf_SET(r,f) (r).egr_port_l3uc_mods[0]=(((r).egr_port_l3uc_mods[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_EGR_PORT_L3UC_MODSr_L3_UC_VLAN_DISABLEf_GET(r) ((((r).egr_port_l3uc_mods[0]) >> 3) & 0x1)
#define BCM56504_A0_EGR_PORT_L3UC_MODSr_L3_UC_VLAN_DISABLEf_SET(r,f) (r).egr_port_l3uc_mods[0]=(((r).egr_port_l3uc_mods[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))

/*
 * These macros can be used to access EGR_PORT_L3UC_MODS.
 *
 */
#define BCM56504_A0_READ_EGR_PORT_L3UC_MODSr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_EGR_PORT_L3UC_MODSr,(r._egr_port_l3uc_mods))
#define BCM56504_A0_WRITE_EGR_PORT_L3UC_MODSr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_EGR_PORT_L3UC_MODSr,&(r._egr_port_l3uc_mods))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_PORT_L3UC_MODSr BCM56504_A0_EGR_PORT_L3UC_MODSr
#define EGR_PORT_L3UC_MODSr_SIZE BCM56504_A0_EGR_PORT_L3UC_MODSr_SIZE
typedef BCM56504_A0_EGR_PORT_L3UC_MODSr_t EGR_PORT_L3UC_MODSr_t;
#define EGR_PORT_L3UC_MODSr_CLR BCM56504_A0_EGR_PORT_L3UC_MODSr_CLR
#define EGR_PORT_L3UC_MODSr_SET BCM56504_A0_EGR_PORT_L3UC_MODSr_SET
#define EGR_PORT_L3UC_MODSr_GET BCM56504_A0_EGR_PORT_L3UC_MODSr_GET
#define EGR_PORT_L3UC_MODSr_L3_UC_SA_DISABLEf_GET BCM56504_A0_EGR_PORT_L3UC_MODSr_L3_UC_SA_DISABLEf_GET
#define EGR_PORT_L3UC_MODSr_L3_UC_SA_DISABLEf_SET BCM56504_A0_EGR_PORT_L3UC_MODSr_L3_UC_SA_DISABLEf_SET
#define EGR_PORT_L3UC_MODSr_L3_UC_DA_DISABLEf_GET BCM56504_A0_EGR_PORT_L3UC_MODSr_L3_UC_DA_DISABLEf_GET
#define EGR_PORT_L3UC_MODSr_L3_UC_DA_DISABLEf_SET BCM56504_A0_EGR_PORT_L3UC_MODSr_L3_UC_DA_DISABLEf_SET
#define EGR_PORT_L3UC_MODSr_L3_UC_TTL_DISABLEf_GET BCM56504_A0_EGR_PORT_L3UC_MODSr_L3_UC_TTL_DISABLEf_GET
#define EGR_PORT_L3UC_MODSr_L3_UC_TTL_DISABLEf_SET BCM56504_A0_EGR_PORT_L3UC_MODSr_L3_UC_TTL_DISABLEf_SET
#define EGR_PORT_L3UC_MODSr_L3_UC_VLAN_DISABLEf_GET BCM56504_A0_EGR_PORT_L3UC_MODSr_L3_UC_VLAN_DISABLEf_GET
#define EGR_PORT_L3UC_MODSr_L3_UC_VLAN_DISABLEf_SET BCM56504_A0_EGR_PORT_L3UC_MODSr_L3_UC_VLAN_DISABLEf_SET
#define READ_EGR_PORT_L3UC_MODSr BCM56504_A0_READ_EGR_PORT_L3UC_MODSr
#define WRITE_EGR_PORT_L3UC_MODSr BCM56504_A0_WRITE_EGR_PORT_L3UC_MODSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_EGR_PORT_L3UC_MODSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  EGR_PORT_REQUESTS
 * BLOCKS:   EPIPE
 * DESC:     This register contains the cell requests asserted by individual ports from GPORT, XPORT, CMIC
blocks. Meaning of cell request is different for different ports, but this register has no
understanding of those meanings. All it shows is the number of times cell_request signal
was asserted by each port to TP. 

 * SIZE:     32
 * FIELDS:
 *     OUTSTANDING_PORT_REQUESTS Number of cell requests.
 *
 ******************************************************************************/
#define BCM56504_A0_EGR_PORT_REQUESTSr 0x0a900101

#define BCM56504_A0_EGR_PORT_REQUESTSr_SIZE 4

/*
 * This structure should be used to declare and program EGR_PORT_REQUESTS.
 *
 */
typedef union BCM56504_A0_EGR_PORT_REQUESTSr_s {
	uint32_t v[1];
	uint32_t egr_port_requests[1];
	uint32_t _egr_port_requests;
} BCM56504_A0_EGR_PORT_REQUESTSr_t;

#define BCM56504_A0_EGR_PORT_REQUESTSr_CLR(r) (r).egr_port_requests[0] = 0
#define BCM56504_A0_EGR_PORT_REQUESTSr_SET(r,d) (r).egr_port_requests[0] = d
#define BCM56504_A0_EGR_PORT_REQUESTSr_GET(r) (r).egr_port_requests[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_EGR_PORT_REQUESTSr_OUTSTANDING_PORT_REQUESTSf_GET(r) (((r).egr_port_requests[0]) & 0xf)
#define BCM56504_A0_EGR_PORT_REQUESTSr_OUTSTANDING_PORT_REQUESTSf_SET(r,f) (r).egr_port_requests[0]=(((r).egr_port_requests[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access EGR_PORT_REQUESTS.
 *
 */
#define BCM56504_A0_READ_EGR_PORT_REQUESTSr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_EGR_PORT_REQUESTSr,(r._egr_port_requests))
#define BCM56504_A0_WRITE_EGR_PORT_REQUESTSr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_EGR_PORT_REQUESTSr,&(r._egr_port_requests))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_PORT_REQUESTSr BCM56504_A0_EGR_PORT_REQUESTSr
#define EGR_PORT_REQUESTSr_SIZE BCM56504_A0_EGR_PORT_REQUESTSr_SIZE
typedef BCM56504_A0_EGR_PORT_REQUESTSr_t EGR_PORT_REQUESTSr_t;
#define EGR_PORT_REQUESTSr_CLR BCM56504_A0_EGR_PORT_REQUESTSr_CLR
#define EGR_PORT_REQUESTSr_SET BCM56504_A0_EGR_PORT_REQUESTSr_SET
#define EGR_PORT_REQUESTSr_GET BCM56504_A0_EGR_PORT_REQUESTSr_GET
#define EGR_PORT_REQUESTSr_OUTSTANDING_PORT_REQUESTSf_GET BCM56504_A0_EGR_PORT_REQUESTSr_OUTSTANDING_PORT_REQUESTSf_GET
#define EGR_PORT_REQUESTSr_OUTSTANDING_PORT_REQUESTSf_SET BCM56504_A0_EGR_PORT_REQUESTSr_OUTSTANDING_PORT_REQUESTSf_SET
#define READ_EGR_PORT_REQUESTSr BCM56504_A0_READ_EGR_PORT_REQUESTSr
#define WRITE_EGR_PORT_REQUESTSr BCM56504_A0_WRITE_EGR_PORT_REQUESTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_EGR_PORT_REQUESTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  EGR_Q_BEGIN
 * BLOCKS:   EPIPE
 * DESC:     Register starts an EQ Bus which is provided for later ECO reasons, if any.

 * SIZE:     32
 * FIELDS:
 *     QBUS             Debug BUS introduced for later ECO provisions.
 *
 ******************************************************************************/
#define BCM56504_A0_EGR_Q_BEGINr 0x00980002

#define BCM56504_A0_EGR_Q_BEGINr_SIZE 4

/*
 * This structure should be used to declare and program EGR_Q_BEGIN.
 *
 */
typedef union BCM56504_A0_EGR_Q_BEGINr_s {
	uint32_t v[1];
	uint32_t egr_q_begin[1];
	uint32_t _egr_q_begin;
} BCM56504_A0_EGR_Q_BEGINr_t;

#define BCM56504_A0_EGR_Q_BEGINr_CLR(r) (r).egr_q_begin[0] = 0
#define BCM56504_A0_EGR_Q_BEGINr_SET(r,d) (r).egr_q_begin[0] = d
#define BCM56504_A0_EGR_Q_BEGINr_GET(r) (r).egr_q_begin[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_EGR_Q_BEGINr_QBUSf_GET(r) ((r).egr_q_begin[0])
#define BCM56504_A0_EGR_Q_BEGINr_QBUSf_SET(r,f) (r).egr_q_begin[0]=((uint32_t)f)

/*
 * These macros can be used to access EGR_Q_BEGIN.
 *
 */
#define BCM56504_A0_READ_EGR_Q_BEGINr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_EGR_Q_BEGINr,(r._egr_q_begin))
#define BCM56504_A0_WRITE_EGR_Q_BEGINr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_EGR_Q_BEGINr,&(r._egr_q_begin))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_Q_BEGINr BCM56504_A0_EGR_Q_BEGINr
#define EGR_Q_BEGINr_SIZE BCM56504_A0_EGR_Q_BEGINr_SIZE
typedef BCM56504_A0_EGR_Q_BEGINr_t EGR_Q_BEGINr_t;
#define EGR_Q_BEGINr_CLR BCM56504_A0_EGR_Q_BEGINr_CLR
#define EGR_Q_BEGINr_SET BCM56504_A0_EGR_Q_BEGINr_SET
#define EGR_Q_BEGINr_GET BCM56504_A0_EGR_Q_BEGINr_GET
#define EGR_Q_BEGINr_QBUSf_GET BCM56504_A0_EGR_Q_BEGINr_QBUSf_GET
#define EGR_Q_BEGINr_QBUSf_SET BCM56504_A0_EGR_Q_BEGINr_QBUSf_SET
#define READ_EGR_Q_BEGINr BCM56504_A0_READ_EGR_Q_BEGINr
#define WRITE_EGR_Q_BEGINr BCM56504_A0_WRITE_EGR_Q_BEGINr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_EGR_Q_BEGINr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  EGR_Q_END
 * BLOCKS:   EPIPE
 * DESC:     Register starts an EQ Bus which is provided for later ECO reasons, if any.

 * SIZE:     32
 * FIELDS:
 *     QBUS             Debug BUS introduced for later ECO provisions.
 *
 ******************************************************************************/
#define BCM56504_A0_EGR_Q_ENDr 0x0a980103

#define BCM56504_A0_EGR_Q_ENDr_SIZE 4

/*
 * This structure should be used to declare and program EGR_Q_END.
 *
 */
typedef union BCM56504_A0_EGR_Q_ENDr_s {
	uint32_t v[1];
	uint32_t egr_q_end[1];
	uint32_t _egr_q_end;
} BCM56504_A0_EGR_Q_ENDr_t;

#define BCM56504_A0_EGR_Q_ENDr_CLR(r) (r).egr_q_end[0] = 0
#define BCM56504_A0_EGR_Q_ENDr_SET(r,d) (r).egr_q_end[0] = d
#define BCM56504_A0_EGR_Q_ENDr_GET(r) (r).egr_q_end[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_EGR_Q_ENDr_QBUSf_GET(r) ((r).egr_q_end[0])
#define BCM56504_A0_EGR_Q_ENDr_QBUSf_SET(r,f) (r).egr_q_end[0]=((uint32_t)f)

/*
 * These macros can be used to access EGR_Q_END.
 *
 */
#define BCM56504_A0_READ_EGR_Q_ENDr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_EGR_Q_ENDr,(r._egr_q_end))
#define BCM56504_A0_WRITE_EGR_Q_ENDr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_EGR_Q_ENDr,&(r._egr_q_end))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_Q_ENDr BCM56504_A0_EGR_Q_ENDr
#define EGR_Q_ENDr_SIZE BCM56504_A0_EGR_Q_ENDr_SIZE
typedef BCM56504_A0_EGR_Q_ENDr_t EGR_Q_ENDr_t;
#define EGR_Q_ENDr_CLR BCM56504_A0_EGR_Q_ENDr_CLR
#define EGR_Q_ENDr_SET BCM56504_A0_EGR_Q_ENDr_SET
#define EGR_Q_ENDr_GET BCM56504_A0_EGR_Q_ENDr_GET
#define EGR_Q_ENDr_QBUSf_GET BCM56504_A0_EGR_Q_ENDr_QBUSf_GET
#define EGR_Q_ENDr_QBUSf_SET BCM56504_A0_EGR_Q_ENDr_QBUSf_SET
#define READ_EGR_Q_ENDr BCM56504_A0_READ_EGR_Q_ENDr
#define WRITE_EGR_Q_ENDr BCM56504_A0_WRITE_EGR_Q_ENDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_EGR_Q_ENDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  EGR_RSPAN_VLAN_TAG
 * BLOCKS:   EPIPE
 * DESC:     For RSPAN feature, the vlan tag is picked up from here.


 * SIZE:     32
 * FIELDS:
 *     TAG              This field contains the entire 4 bytes (32 bits wide) tag to be added to the packet for RSPAN.The way it should be programmed is, 	TAG[31:16] = TPID,Tpid to be used when rspan tag will be added in the packet modifier. 	TAG[15:13] = Priority to be used when rspan tag will be added in the packet modifier. 	TAG[12]    = CFI to be used when rspan tag will be added in the packet modifier. 	TAG[11:0]  = VID to be used when rspan tag will be added in the packet modifier. If TAG is all zero then it means we do not add the rspan tag.
 *
 ******************************************************************************/
#define BCM56504_A0_EGR_RSPAN_VLAN_TAGr 0x09900000

#define BCM56504_A0_EGR_RSPAN_VLAN_TAGr_SIZE 4

/*
 * This structure should be used to declare and program EGR_RSPAN_VLAN_TAG.
 *
 */
typedef union BCM56504_A0_EGR_RSPAN_VLAN_TAGr_s {
	uint32_t v[1];
	uint32_t egr_rspan_vlan_tag[1];
	uint32_t _egr_rspan_vlan_tag;
} BCM56504_A0_EGR_RSPAN_VLAN_TAGr_t;

#define BCM56504_A0_EGR_RSPAN_VLAN_TAGr_CLR(r) (r).egr_rspan_vlan_tag[0] = 0
#define BCM56504_A0_EGR_RSPAN_VLAN_TAGr_SET(r,d) (r).egr_rspan_vlan_tag[0] = d
#define BCM56504_A0_EGR_RSPAN_VLAN_TAGr_GET(r) (r).egr_rspan_vlan_tag[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_EGR_RSPAN_VLAN_TAGr_TAGf_GET(r) ((r).egr_rspan_vlan_tag[0])
#define BCM56504_A0_EGR_RSPAN_VLAN_TAGr_TAGf_SET(r,f) (r).egr_rspan_vlan_tag[0]=((uint32_t)f)

/*
 * These macros can be used to access EGR_RSPAN_VLAN_TAG.
 *
 */
#define BCM56504_A0_READ_EGR_RSPAN_VLAN_TAGr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_EGR_RSPAN_VLAN_TAGr,(r._egr_rspan_vlan_tag))
#define BCM56504_A0_WRITE_EGR_RSPAN_VLAN_TAGr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_EGR_RSPAN_VLAN_TAGr,&(r._egr_rspan_vlan_tag))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_RSPAN_VLAN_TAGr BCM56504_A0_EGR_RSPAN_VLAN_TAGr
#define EGR_RSPAN_VLAN_TAGr_SIZE BCM56504_A0_EGR_RSPAN_VLAN_TAGr_SIZE
typedef BCM56504_A0_EGR_RSPAN_VLAN_TAGr_t EGR_RSPAN_VLAN_TAGr_t;
#define EGR_RSPAN_VLAN_TAGr_CLR BCM56504_A0_EGR_RSPAN_VLAN_TAGr_CLR
#define EGR_RSPAN_VLAN_TAGr_SET BCM56504_A0_EGR_RSPAN_VLAN_TAGr_SET
#define EGR_RSPAN_VLAN_TAGr_GET BCM56504_A0_EGR_RSPAN_VLAN_TAGr_GET
#define EGR_RSPAN_VLAN_TAGr_TAGf_GET BCM56504_A0_EGR_RSPAN_VLAN_TAGr_TAGf_GET
#define EGR_RSPAN_VLAN_TAGr_TAGf_SET BCM56504_A0_EGR_RSPAN_VLAN_TAGr_TAGf_SET
#define READ_EGR_RSPAN_VLAN_TAGr BCM56504_A0_READ_EGR_RSPAN_VLAN_TAGr
#define WRITE_EGR_RSPAN_VLAN_TAGr BCM56504_A0_WRITE_EGR_RSPAN_VLAN_TAGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_EGR_RSPAN_VLAN_TAGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  EGR_TUNNEL_CONTROL
 * BLOCKS:   EPIPE
 * DESC:     Global ID value for Tunnel Pkts. This value is passed in the pkt whenever tunnel
is encapsulated in a packet in Transmit Pipeline.


 * SIZE:     32
 * FIELDS:
 *     IPV4_ID          Global id to be inserted in the packet. This is the running ID, i.e. whenever a pkt is transmitted, the value is incremented here.
 *     START_IPV4_ID    Global ID written by CPU. This is written by logic when CPU writes to the IPV4_ID field. After that START_IPV4_ID field remains constant, which is useful for debugging to see what was the starting id for this chip, as IPV4_ID keeps on changing with each encapped packet.
 *
 ******************************************************************************/
#define BCM56504_A0_EGR_TUNNEL_CONTROLr 0x07980000

#define BCM56504_A0_EGR_TUNNEL_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program EGR_TUNNEL_CONTROL.
 *
 */
typedef union BCM56504_A0_EGR_TUNNEL_CONTROLr_s {
	uint32_t v[1];
	uint32_t egr_tunnel_control[1];
	uint32_t _egr_tunnel_control;
} BCM56504_A0_EGR_TUNNEL_CONTROLr_t;

#define BCM56504_A0_EGR_TUNNEL_CONTROLr_CLR(r) (r).egr_tunnel_control[0] = 0
#define BCM56504_A0_EGR_TUNNEL_CONTROLr_SET(r,d) (r).egr_tunnel_control[0] = d
#define BCM56504_A0_EGR_TUNNEL_CONTROLr_GET(r) (r).egr_tunnel_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_EGR_TUNNEL_CONTROLr_IPV4_IDf_GET(r) (((r).egr_tunnel_control[0]) & 0xffff)
#define BCM56504_A0_EGR_TUNNEL_CONTROLr_IPV4_IDf_SET(r,f) (r).egr_tunnel_control[0]=(((r).egr_tunnel_control[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56504_A0_EGR_TUNNEL_CONTROLr_START_IPV4_IDf_GET(r) ((((r).egr_tunnel_control[0]) >> 16) & 0xffff)
#define BCM56504_A0_EGR_TUNNEL_CONTROLr_START_IPV4_IDf_SET(r,f) (r).egr_tunnel_control[0]=(((r).egr_tunnel_control[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access EGR_TUNNEL_CONTROL.
 *
 */
#define BCM56504_A0_READ_EGR_TUNNEL_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_EGR_TUNNEL_CONTROLr,(r._egr_tunnel_control))
#define BCM56504_A0_WRITE_EGR_TUNNEL_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_EGR_TUNNEL_CONTROLr,&(r._egr_tunnel_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_TUNNEL_CONTROLr BCM56504_A0_EGR_TUNNEL_CONTROLr
#define EGR_TUNNEL_CONTROLr_SIZE BCM56504_A0_EGR_TUNNEL_CONTROLr_SIZE
typedef BCM56504_A0_EGR_TUNNEL_CONTROLr_t EGR_TUNNEL_CONTROLr_t;
#define EGR_TUNNEL_CONTROLr_CLR BCM56504_A0_EGR_TUNNEL_CONTROLr_CLR
#define EGR_TUNNEL_CONTROLr_SET BCM56504_A0_EGR_TUNNEL_CONTROLr_SET
#define EGR_TUNNEL_CONTROLr_GET BCM56504_A0_EGR_TUNNEL_CONTROLr_GET
#define EGR_TUNNEL_CONTROLr_IPV4_IDf_GET BCM56504_A0_EGR_TUNNEL_CONTROLr_IPV4_IDf_GET
#define EGR_TUNNEL_CONTROLr_IPV4_IDf_SET BCM56504_A0_EGR_TUNNEL_CONTROLr_IPV4_IDf_SET
#define EGR_TUNNEL_CONTROLr_START_IPV4_IDf_GET BCM56504_A0_EGR_TUNNEL_CONTROLr_START_IPV4_IDf_GET
#define EGR_TUNNEL_CONTROLr_START_IPV4_IDf_SET BCM56504_A0_EGR_TUNNEL_CONTROLr_START_IPV4_IDf_SET
#define READ_EGR_TUNNEL_CONTROLr BCM56504_A0_READ_EGR_TUNNEL_CONTROLr
#define WRITE_EGR_TUNNEL_CONTROLr BCM56504_A0_WRITE_EGR_TUNNEL_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_EGR_TUNNEL_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  EGR_TUNNEL_ID_MASK
 * BLOCKS:   EPIPE
 * DESC:     Global ID mask value for Tunnel Pkts. 


 * SIZE:     32
 * FIELDS:
 *     IPV4_ID_MASK     Global id mask to be used before inserting the tag in the packet.
 *
 ******************************************************************************/
#define BCM56504_A0_EGR_TUNNEL_ID_MASKr 0x07980001

#define BCM56504_A0_EGR_TUNNEL_ID_MASKr_SIZE 4

/*
 * This structure should be used to declare and program EGR_TUNNEL_ID_MASK.
 *
 */
typedef union BCM56504_A0_EGR_TUNNEL_ID_MASKr_s {
	uint32_t v[1];
	uint32_t egr_tunnel_id_mask[1];
	uint32_t _egr_tunnel_id_mask;
} BCM56504_A0_EGR_TUNNEL_ID_MASKr_t;

#define BCM56504_A0_EGR_TUNNEL_ID_MASKr_CLR(r) (r).egr_tunnel_id_mask[0] = 0
#define BCM56504_A0_EGR_TUNNEL_ID_MASKr_SET(r,d) (r).egr_tunnel_id_mask[0] = d
#define BCM56504_A0_EGR_TUNNEL_ID_MASKr_GET(r) (r).egr_tunnel_id_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_EGR_TUNNEL_ID_MASKr_IPV4_ID_MASKf_GET(r) (((r).egr_tunnel_id_mask[0]) & 0xffff)
#define BCM56504_A0_EGR_TUNNEL_ID_MASKr_IPV4_ID_MASKf_SET(r,f) (r).egr_tunnel_id_mask[0]=(((r).egr_tunnel_id_mask[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access EGR_TUNNEL_ID_MASK.
 *
 */
#define BCM56504_A0_READ_EGR_TUNNEL_ID_MASKr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_EGR_TUNNEL_ID_MASKr,(r._egr_tunnel_id_mask))
#define BCM56504_A0_WRITE_EGR_TUNNEL_ID_MASKr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_EGR_TUNNEL_ID_MASKr,&(r._egr_tunnel_id_mask))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_TUNNEL_ID_MASKr BCM56504_A0_EGR_TUNNEL_ID_MASKr
#define EGR_TUNNEL_ID_MASKr_SIZE BCM56504_A0_EGR_TUNNEL_ID_MASKr_SIZE
typedef BCM56504_A0_EGR_TUNNEL_ID_MASKr_t EGR_TUNNEL_ID_MASKr_t;
#define EGR_TUNNEL_ID_MASKr_CLR BCM56504_A0_EGR_TUNNEL_ID_MASKr_CLR
#define EGR_TUNNEL_ID_MASKr_SET BCM56504_A0_EGR_TUNNEL_ID_MASKr_SET
#define EGR_TUNNEL_ID_MASKr_GET BCM56504_A0_EGR_TUNNEL_ID_MASKr_GET
#define EGR_TUNNEL_ID_MASKr_IPV4_ID_MASKf_GET BCM56504_A0_EGR_TUNNEL_ID_MASKr_IPV4_ID_MASKf_GET
#define EGR_TUNNEL_ID_MASKr_IPV4_ID_MASKf_SET BCM56504_A0_EGR_TUNNEL_ID_MASKr_IPV4_ID_MASKf_SET
#define READ_EGR_TUNNEL_ID_MASKr BCM56504_A0_READ_EGR_TUNNEL_ID_MASKr
#define WRITE_EGR_TUNNEL_ID_MASKr BCM56504_A0_WRITE_EGR_TUNNEL_ID_MASKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_EGR_TUNNEL_ID_MASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  EGR_TUNNEL_PIMDR1_CFG0
 * BLOCKS:   EPIPE
 * DESC:     For PIMSM-DR1 type of tunnel pkts, MS 4 bytes are specified here, so that they
can be inserted in the packet.

 * SIZE:     32
 * FIELDS:
 *     MS_PIMSM_HDR     Specifies the MS 32 bits of the PIMSM-DR1 Header, which needs to be inserted in the packet, if tunnel table search results in pkt encap.
 *
 ******************************************************************************/
#define BCM56504_A0_EGR_TUNNEL_PIMDR1_CFG0r 0x08980000

#define BCM56504_A0_EGR_TUNNEL_PIMDR1_CFG0r_SIZE 4

/*
 * This structure should be used to declare and program EGR_TUNNEL_PIMDR1_CFG0.
 *
 */
typedef union BCM56504_A0_EGR_TUNNEL_PIMDR1_CFG0r_s {
	uint32_t v[1];
	uint32_t egr_tunnel_pimdr1_cfg0[1];
	uint32_t _egr_tunnel_pimdr1_cfg0;
} BCM56504_A0_EGR_TUNNEL_PIMDR1_CFG0r_t;

#define BCM56504_A0_EGR_TUNNEL_PIMDR1_CFG0r_CLR(r) (r).egr_tunnel_pimdr1_cfg0[0] = 0
#define BCM56504_A0_EGR_TUNNEL_PIMDR1_CFG0r_SET(r,d) (r).egr_tunnel_pimdr1_cfg0[0] = d
#define BCM56504_A0_EGR_TUNNEL_PIMDR1_CFG0r_GET(r) (r).egr_tunnel_pimdr1_cfg0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_EGR_TUNNEL_PIMDR1_CFG0r_MS_PIMSM_HDRf_GET(r) ((r).egr_tunnel_pimdr1_cfg0[0])
#define BCM56504_A0_EGR_TUNNEL_PIMDR1_CFG0r_MS_PIMSM_HDRf_SET(r,f) (r).egr_tunnel_pimdr1_cfg0[0]=((uint32_t)f)

/*
 * These macros can be used to access EGR_TUNNEL_PIMDR1_CFG0.
 *
 */
#define BCM56504_A0_READ_EGR_TUNNEL_PIMDR1_CFG0r(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_EGR_TUNNEL_PIMDR1_CFG0r,(r._egr_tunnel_pimdr1_cfg0))
#define BCM56504_A0_WRITE_EGR_TUNNEL_PIMDR1_CFG0r(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_EGR_TUNNEL_PIMDR1_CFG0r,&(r._egr_tunnel_pimdr1_cfg0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_TUNNEL_PIMDR1_CFG0r BCM56504_A0_EGR_TUNNEL_PIMDR1_CFG0r
#define EGR_TUNNEL_PIMDR1_CFG0r_SIZE BCM56504_A0_EGR_TUNNEL_PIMDR1_CFG0r_SIZE
typedef BCM56504_A0_EGR_TUNNEL_PIMDR1_CFG0r_t EGR_TUNNEL_PIMDR1_CFG0r_t;
#define EGR_TUNNEL_PIMDR1_CFG0r_CLR BCM56504_A0_EGR_TUNNEL_PIMDR1_CFG0r_CLR
#define EGR_TUNNEL_PIMDR1_CFG0r_SET BCM56504_A0_EGR_TUNNEL_PIMDR1_CFG0r_SET
#define EGR_TUNNEL_PIMDR1_CFG0r_GET BCM56504_A0_EGR_TUNNEL_PIMDR1_CFG0r_GET
#define EGR_TUNNEL_PIMDR1_CFG0r_MS_PIMSM_HDRf_GET BCM56504_A0_EGR_TUNNEL_PIMDR1_CFG0r_MS_PIMSM_HDRf_GET
#define EGR_TUNNEL_PIMDR1_CFG0r_MS_PIMSM_HDRf_SET BCM56504_A0_EGR_TUNNEL_PIMDR1_CFG0r_MS_PIMSM_HDRf_SET
#define READ_EGR_TUNNEL_PIMDR1_CFG0r BCM56504_A0_READ_EGR_TUNNEL_PIMDR1_CFG0r
#define WRITE_EGR_TUNNEL_PIMDR1_CFG0r BCM56504_A0_WRITE_EGR_TUNNEL_PIMDR1_CFG0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_EGR_TUNNEL_PIMDR1_CFG0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  EGR_TUNNEL_PIMDR1_CFG1
 * BLOCKS:   EPIPE
 * DESC:     For PIMSM-DR1 type of tunnel pkts, LS 4 bytes are specified here, so that they
can be inserted in the packet.

 * SIZE:     32
 * FIELDS:
 *     LS_PIMSM_HDR     Specifies the LS 32 bits of the PIMSM-DR1 Header, which needs to be inserted in the packet, if tunnel table search results in pkt encap.
 *
 ******************************************************************************/
#define BCM56504_A0_EGR_TUNNEL_PIMDR1_CFG1r 0x08980001

#define BCM56504_A0_EGR_TUNNEL_PIMDR1_CFG1r_SIZE 4

/*
 * This structure should be used to declare and program EGR_TUNNEL_PIMDR1_CFG1.
 *
 */
typedef union BCM56504_A0_EGR_TUNNEL_PIMDR1_CFG1r_s {
	uint32_t v[1];
	uint32_t egr_tunnel_pimdr1_cfg1[1];
	uint32_t _egr_tunnel_pimdr1_cfg1;
} BCM56504_A0_EGR_TUNNEL_PIMDR1_CFG1r_t;

#define BCM56504_A0_EGR_TUNNEL_PIMDR1_CFG1r_CLR(r) (r).egr_tunnel_pimdr1_cfg1[0] = 0
#define BCM56504_A0_EGR_TUNNEL_PIMDR1_CFG1r_SET(r,d) (r).egr_tunnel_pimdr1_cfg1[0] = d
#define BCM56504_A0_EGR_TUNNEL_PIMDR1_CFG1r_GET(r) (r).egr_tunnel_pimdr1_cfg1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_EGR_TUNNEL_PIMDR1_CFG1r_LS_PIMSM_HDRf_GET(r) ((r).egr_tunnel_pimdr1_cfg1[0])
#define BCM56504_A0_EGR_TUNNEL_PIMDR1_CFG1r_LS_PIMSM_HDRf_SET(r,f) (r).egr_tunnel_pimdr1_cfg1[0]=((uint32_t)f)

/*
 * These macros can be used to access EGR_TUNNEL_PIMDR1_CFG1.
 *
 */
#define BCM56504_A0_READ_EGR_TUNNEL_PIMDR1_CFG1r(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_EGR_TUNNEL_PIMDR1_CFG1r,(r._egr_tunnel_pimdr1_cfg1))
#define BCM56504_A0_WRITE_EGR_TUNNEL_PIMDR1_CFG1r(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_EGR_TUNNEL_PIMDR1_CFG1r,&(r._egr_tunnel_pimdr1_cfg1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_TUNNEL_PIMDR1_CFG1r BCM56504_A0_EGR_TUNNEL_PIMDR1_CFG1r
#define EGR_TUNNEL_PIMDR1_CFG1r_SIZE BCM56504_A0_EGR_TUNNEL_PIMDR1_CFG1r_SIZE
typedef BCM56504_A0_EGR_TUNNEL_PIMDR1_CFG1r_t EGR_TUNNEL_PIMDR1_CFG1r_t;
#define EGR_TUNNEL_PIMDR1_CFG1r_CLR BCM56504_A0_EGR_TUNNEL_PIMDR1_CFG1r_CLR
#define EGR_TUNNEL_PIMDR1_CFG1r_SET BCM56504_A0_EGR_TUNNEL_PIMDR1_CFG1r_SET
#define EGR_TUNNEL_PIMDR1_CFG1r_GET BCM56504_A0_EGR_TUNNEL_PIMDR1_CFG1r_GET
#define EGR_TUNNEL_PIMDR1_CFG1r_LS_PIMSM_HDRf_GET BCM56504_A0_EGR_TUNNEL_PIMDR1_CFG1r_LS_PIMSM_HDRf_GET
#define EGR_TUNNEL_PIMDR1_CFG1r_LS_PIMSM_HDRf_SET BCM56504_A0_EGR_TUNNEL_PIMDR1_CFG1r_LS_PIMSM_HDRf_SET
#define READ_EGR_TUNNEL_PIMDR1_CFG1r BCM56504_A0_READ_EGR_TUNNEL_PIMDR1_CFG1r
#define WRITE_EGR_TUNNEL_PIMDR1_CFG1r BCM56504_A0_WRITE_EGR_TUNNEL_PIMDR1_CFG1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_EGR_TUNNEL_PIMDR1_CFG1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  EGR_TUNNEL_PIMDR2_CFG0
 * BLOCKS:   EPIPE
 * DESC:     For PIMSM-DR2 type of tunnel pkts, MS 4 bytes are specified here, so that they
can be inserted in the packet.

 * SIZE:     32
 * FIELDS:
 *     MS_PIMSM_HDR     Specifies the MS 32 bits PIMSM-DR2 Header, which needs to be inserted in the packet, if tunnel table search results in pkt encap.
 *
 ******************************************************************************/
#define BCM56504_A0_EGR_TUNNEL_PIMDR2_CFG0r 0x08980002

#define BCM56504_A0_EGR_TUNNEL_PIMDR2_CFG0r_SIZE 4

/*
 * This structure should be used to declare and program EGR_TUNNEL_PIMDR2_CFG0.
 *
 */
typedef union BCM56504_A0_EGR_TUNNEL_PIMDR2_CFG0r_s {
	uint32_t v[1];
	uint32_t egr_tunnel_pimdr2_cfg0[1];
	uint32_t _egr_tunnel_pimdr2_cfg0;
} BCM56504_A0_EGR_TUNNEL_PIMDR2_CFG0r_t;

#define BCM56504_A0_EGR_TUNNEL_PIMDR2_CFG0r_CLR(r) (r).egr_tunnel_pimdr2_cfg0[0] = 0
#define BCM56504_A0_EGR_TUNNEL_PIMDR2_CFG0r_SET(r,d) (r).egr_tunnel_pimdr2_cfg0[0] = d
#define BCM56504_A0_EGR_TUNNEL_PIMDR2_CFG0r_GET(r) (r).egr_tunnel_pimdr2_cfg0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_EGR_TUNNEL_PIMDR2_CFG0r_MS_PIMSM_HDRf_GET(r) ((r).egr_tunnel_pimdr2_cfg0[0])
#define BCM56504_A0_EGR_TUNNEL_PIMDR2_CFG0r_MS_PIMSM_HDRf_SET(r,f) (r).egr_tunnel_pimdr2_cfg0[0]=((uint32_t)f)

/*
 * These macros can be used to access EGR_TUNNEL_PIMDR2_CFG0.
 *
 */
#define BCM56504_A0_READ_EGR_TUNNEL_PIMDR2_CFG0r(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_EGR_TUNNEL_PIMDR2_CFG0r,(r._egr_tunnel_pimdr2_cfg0))
#define BCM56504_A0_WRITE_EGR_TUNNEL_PIMDR2_CFG0r(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_EGR_TUNNEL_PIMDR2_CFG0r,&(r._egr_tunnel_pimdr2_cfg0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_TUNNEL_PIMDR2_CFG0r BCM56504_A0_EGR_TUNNEL_PIMDR2_CFG0r
#define EGR_TUNNEL_PIMDR2_CFG0r_SIZE BCM56504_A0_EGR_TUNNEL_PIMDR2_CFG0r_SIZE
typedef BCM56504_A0_EGR_TUNNEL_PIMDR2_CFG0r_t EGR_TUNNEL_PIMDR2_CFG0r_t;
#define EGR_TUNNEL_PIMDR2_CFG0r_CLR BCM56504_A0_EGR_TUNNEL_PIMDR2_CFG0r_CLR
#define EGR_TUNNEL_PIMDR2_CFG0r_SET BCM56504_A0_EGR_TUNNEL_PIMDR2_CFG0r_SET
#define EGR_TUNNEL_PIMDR2_CFG0r_GET BCM56504_A0_EGR_TUNNEL_PIMDR2_CFG0r_GET
#define EGR_TUNNEL_PIMDR2_CFG0r_MS_PIMSM_HDRf_GET BCM56504_A0_EGR_TUNNEL_PIMDR2_CFG0r_MS_PIMSM_HDRf_GET
#define EGR_TUNNEL_PIMDR2_CFG0r_MS_PIMSM_HDRf_SET BCM56504_A0_EGR_TUNNEL_PIMDR2_CFG0r_MS_PIMSM_HDRf_SET
#define READ_EGR_TUNNEL_PIMDR2_CFG0r BCM56504_A0_READ_EGR_TUNNEL_PIMDR2_CFG0r
#define WRITE_EGR_TUNNEL_PIMDR2_CFG0r BCM56504_A0_WRITE_EGR_TUNNEL_PIMDR2_CFG0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_EGR_TUNNEL_PIMDR2_CFG0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  EGR_TUNNEL_PIMDR2_CFG1
 * BLOCKS:   EPIPE
 * DESC:     For PIMSM-DR2 type of tunnel pkts, LS 4 bytes are specified here, so that they
can be inserted in the packet.

 * SIZE:     32
 * FIELDS:
 *     LS_PIMSM_HDR     Specifies the LS 32 bits PIMSM-DR2 Header, which needs to be inserted in the packet, if tunnel table search results in pkt encap.
 *
 ******************************************************************************/
#define BCM56504_A0_EGR_TUNNEL_PIMDR2_CFG1r 0x08980003

#define BCM56504_A0_EGR_TUNNEL_PIMDR2_CFG1r_SIZE 4

/*
 * This structure should be used to declare and program EGR_TUNNEL_PIMDR2_CFG1.
 *
 */
typedef union BCM56504_A0_EGR_TUNNEL_PIMDR2_CFG1r_s {
	uint32_t v[1];
	uint32_t egr_tunnel_pimdr2_cfg1[1];
	uint32_t _egr_tunnel_pimdr2_cfg1;
} BCM56504_A0_EGR_TUNNEL_PIMDR2_CFG1r_t;

#define BCM56504_A0_EGR_TUNNEL_PIMDR2_CFG1r_CLR(r) (r).egr_tunnel_pimdr2_cfg1[0] = 0
#define BCM56504_A0_EGR_TUNNEL_PIMDR2_CFG1r_SET(r,d) (r).egr_tunnel_pimdr2_cfg1[0] = d
#define BCM56504_A0_EGR_TUNNEL_PIMDR2_CFG1r_GET(r) (r).egr_tunnel_pimdr2_cfg1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_EGR_TUNNEL_PIMDR2_CFG1r_LS_PIMSM_HDRf_GET(r) ((r).egr_tunnel_pimdr2_cfg1[0])
#define BCM56504_A0_EGR_TUNNEL_PIMDR2_CFG1r_LS_PIMSM_HDRf_SET(r,f) (r).egr_tunnel_pimdr2_cfg1[0]=((uint32_t)f)

/*
 * These macros can be used to access EGR_TUNNEL_PIMDR2_CFG1.
 *
 */
#define BCM56504_A0_READ_EGR_TUNNEL_PIMDR2_CFG1r(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_EGR_TUNNEL_PIMDR2_CFG1r,(r._egr_tunnel_pimdr2_cfg1))
#define BCM56504_A0_WRITE_EGR_TUNNEL_PIMDR2_CFG1r(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_EGR_TUNNEL_PIMDR2_CFG1r,&(r._egr_tunnel_pimdr2_cfg1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_TUNNEL_PIMDR2_CFG1r BCM56504_A0_EGR_TUNNEL_PIMDR2_CFG1r
#define EGR_TUNNEL_PIMDR2_CFG1r_SIZE BCM56504_A0_EGR_TUNNEL_PIMDR2_CFG1r_SIZE
typedef BCM56504_A0_EGR_TUNNEL_PIMDR2_CFG1r_t EGR_TUNNEL_PIMDR2_CFG1r_t;
#define EGR_TUNNEL_PIMDR2_CFG1r_CLR BCM56504_A0_EGR_TUNNEL_PIMDR2_CFG1r_CLR
#define EGR_TUNNEL_PIMDR2_CFG1r_SET BCM56504_A0_EGR_TUNNEL_PIMDR2_CFG1r_SET
#define EGR_TUNNEL_PIMDR2_CFG1r_GET BCM56504_A0_EGR_TUNNEL_PIMDR2_CFG1r_GET
#define EGR_TUNNEL_PIMDR2_CFG1r_LS_PIMSM_HDRf_GET BCM56504_A0_EGR_TUNNEL_PIMDR2_CFG1r_LS_PIMSM_HDRf_GET
#define EGR_TUNNEL_PIMDR2_CFG1r_LS_PIMSM_HDRf_SET BCM56504_A0_EGR_TUNNEL_PIMDR2_CFG1r_LS_PIMSM_HDRf_SET
#define READ_EGR_TUNNEL_PIMDR2_CFG1r BCM56504_A0_READ_EGR_TUNNEL_PIMDR2_CFG1r
#define WRITE_EGR_TUNNEL_PIMDR2_CFG1r BCM56504_A0_WRITE_EGR_TUNNEL_PIMDR2_CFG1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_EGR_TUNNEL_PIMDR2_CFG1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  EGR_VLAN
 * BLOCKS:   EPIPE
 * DESC:     Vlan Membership Table for Egress
 * SIZE:     68
 * FIELDS:
 *     UT_BITMAP        Alias for UT_PORT_BITMAP
 *     PORT_BITMAP      Indiactes which port is member of this VLAN.  A bit for CPU is needed.
 *     STG              Spanning Tree Group Number. To be used for indexing VLAN_STG table.
 *     PFM              Port Filtering Mode . 
 *     VALID            Indicates if the entry is valid.
 *
 ******************************************************************************/
#define BCM56504_A0_EGR_VLANm 0x04910000

#define BCM56504_A0_EGR_VLANm_MIN 0
#define BCM56504_A0_EGR_VLANm_MAX 4095
#define BCM56504_A0_EGR_VLANm_CMAX(u) 4095
#define BCM56504_A0_EGR_VLANm_SIZE 9

/*
 * This structure should be used to declare and program EGR_VLAN.
 *
 */
typedef union BCM56504_A0_EGR_VLANm_s {
	uint32_t v[3];
	uint32_t egr_vlan[3];
	uint32_t _egr_vlan;
} BCM56504_A0_EGR_VLANm_t;

#define BCM56504_A0_EGR_VLANm_CLR(r) CDK_MEMSET(&((r)._egr_vlan), 0, sizeof(BCM56504_A0_EGR_VLANm_t))
#define BCM56504_A0_EGR_VLANm_SET(r,i,d) (r).egr_vlan[i] = d
#define BCM56504_A0_EGR_VLANm_GET(r,i) (r).egr_vlan[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_EGR_VLANm_UT_BITMAPf_GET(r) (((r).egr_vlan[0]) & 0xfffffff)
#define BCM56504_A0_EGR_VLANm_UT_BITMAPf_SET(r,f) (r).egr_vlan[0]=(((r).egr_vlan[0] & ~((uint32_t)0xfffffff)) | (((uint32_t)f) & 0xfffffff))
#define BCM56504_A0_EGR_VLANm_PORT_BITMAPf_GET(r) cdk_field32_get((r).egr_vlan,28,56)
#define BCM56504_A0_EGR_VLANm_PORT_BITMAPf_SET(r,f) cdk_field32_set((r).egr_vlan,28,56,f)
#define BCM56504_A0_EGR_VLANm_STGf_GET(r) cdk_field32_get((r).egr_vlan,57,64)
#define BCM56504_A0_EGR_VLANm_STGf_SET(r,f) cdk_field32_set((r).egr_vlan,57,64,f)
#define BCM56504_A0_EGR_VLANm_PFMf_GET(r) ((((r).egr_vlan[2]) >> 1) & 0x3)
#define BCM56504_A0_EGR_VLANm_PFMf_SET(r,f) (r).egr_vlan[2]=(((r).egr_vlan[2] & ~((uint32_t)0x3 << 1)) | ((((uint32_t)f) & 0x3) << 1))
#define BCM56504_A0_EGR_VLANm_VALIDf_GET(r) ((((r).egr_vlan[2]) >> 3) & 0x1)
#define BCM56504_A0_EGR_VLANm_VALIDf_SET(r,f) (r).egr_vlan[2]=(((r).egr_vlan[2] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))

/*
 * These macros can be used to access EGR_VLAN.
 *
 */
#define BCM56504_A0_READ_EGR_VLANm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_EGR_VLANm,i,(m._egr_vlan),3)
#define BCM56504_A0_WRITE_EGR_VLANm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_EGR_VLANm,i,&(m._egr_vlan),3)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_VLANm BCM56504_A0_EGR_VLANm
#define EGR_VLANm_MIN BCM56504_A0_EGR_VLANm_MIN
#define EGR_VLANm_MAX BCM56504_A0_EGR_VLANm_MAX
#define EGR_VLANm_CMAX(u) BCM56504_A0_EGR_VLANm_CMAX(u)
#define EGR_VLANm_SIZE BCM56504_A0_EGR_VLANm_SIZE
typedef BCM56504_A0_EGR_VLANm_t EGR_VLANm_t;
#define EGR_VLANm_CLR BCM56504_A0_EGR_VLANm_CLR
#define EGR_VLANm_SET BCM56504_A0_EGR_VLANm_SET
#define EGR_VLANm_GET BCM56504_A0_EGR_VLANm_GET
#define EGR_VLANm_UT_BITMAPf_GET BCM56504_A0_EGR_VLANm_UT_BITMAPf_GET
#define EGR_VLANm_UT_BITMAPf_SET BCM56504_A0_EGR_VLANm_UT_BITMAPf_SET
#define EGR_VLANm_PORT_BITMAPf_GET BCM56504_A0_EGR_VLANm_PORT_BITMAPf_GET
#define EGR_VLANm_PORT_BITMAPf_SET BCM56504_A0_EGR_VLANm_PORT_BITMAPf_SET
#define EGR_VLANm_STGf_GET BCM56504_A0_EGR_VLANm_STGf_GET
#define EGR_VLANm_STGf_SET BCM56504_A0_EGR_VLANm_STGf_SET
#define EGR_VLANm_PFMf_GET BCM56504_A0_EGR_VLANm_PFMf_GET
#define EGR_VLANm_PFMf_SET BCM56504_A0_EGR_VLANm_PFMf_SET
#define EGR_VLANm_VALIDf_GET BCM56504_A0_EGR_VLANm_VALIDf_GET
#define EGR_VLANm_VALIDf_SET BCM56504_A0_EGR_VLANm_VALIDf_SET
#define READ_EGR_VLANm BCM56504_A0_READ_EGR_VLANm
#define WRITE_EGR_VLANm BCM56504_A0_WRITE_EGR_VLANm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_EGR_VLANm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  EGR_VLAN_CONTROL_1
 * BLOCKS:   EPIPE
 * DESC:     Controls Vlan Translate and VLAN membership related functions.

 * SIZE:     32
 * FIELDS:
 *     VT_ENABLE        VLAN Translate is enabled on this port. If this bit is set, then the vid, pri obtained from the VXLTCAM Lookup is used.
 *     VT_MISS_DROP     If this bit is set, and a lookup in the vxlt cam table results in a miss, then pkt is dropped.This bit is meaningful only when VT_ENABLE is set.
 *     OUTER_TPID       TPID to identify the outer tag. Also this tpid is used when packet modification stages add a vlan tag in the packet. 
 *
 ******************************************************************************/
#define BCM56504_A0_EGR_VLAN_CONTROL_1r 0x01900003

#define BCM56504_A0_EGR_VLAN_CONTROL_1r_SIZE 4

/*
 * This structure should be used to declare and program EGR_VLAN_CONTROL_1.
 *
 */
typedef union BCM56504_A0_EGR_VLAN_CONTROL_1r_s {
	uint32_t v[1];
	uint32_t egr_vlan_control_1[1];
	uint32_t _egr_vlan_control_1;
} BCM56504_A0_EGR_VLAN_CONTROL_1r_t;

#define BCM56504_A0_EGR_VLAN_CONTROL_1r_CLR(r) (r).egr_vlan_control_1[0] = 0
#define BCM56504_A0_EGR_VLAN_CONTROL_1r_SET(r,d) (r).egr_vlan_control_1[0] = d
#define BCM56504_A0_EGR_VLAN_CONTROL_1r_GET(r) (r).egr_vlan_control_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_EGR_VLAN_CONTROL_1r_VT_ENABLEf_GET(r) (((r).egr_vlan_control_1[0]) & 0x1)
#define BCM56504_A0_EGR_VLAN_CONTROL_1r_VT_ENABLEf_SET(r,f) (r).egr_vlan_control_1[0]=(((r).egr_vlan_control_1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_EGR_VLAN_CONTROL_1r_VT_MISS_DROPf_GET(r) ((((r).egr_vlan_control_1[0]) >> 1) & 0x1)
#define BCM56504_A0_EGR_VLAN_CONTROL_1r_VT_MISS_DROPf_SET(r,f) (r).egr_vlan_control_1[0]=(((r).egr_vlan_control_1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_EGR_VLAN_CONTROL_1r_OUTER_TPIDf_GET(r) ((((r).egr_vlan_control_1[0]) >> 2) & 0xffff)
#define BCM56504_A0_EGR_VLAN_CONTROL_1r_OUTER_TPIDf_SET(r,f) (r).egr_vlan_control_1[0]=(((r).egr_vlan_control_1[0] & ~((uint32_t)0xffff << 2)) | ((((uint32_t)f) & 0xffff) << 2))

/*
 * These macros can be used to access EGR_VLAN_CONTROL_1.
 *
 */
#define BCM56504_A0_READ_EGR_VLAN_CONTROL_1r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_EGR_VLAN_CONTROL_1r,(r._egr_vlan_control_1))
#define BCM56504_A0_WRITE_EGR_VLAN_CONTROL_1r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_EGR_VLAN_CONTROL_1r,&(r._egr_vlan_control_1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_VLAN_CONTROL_1r BCM56504_A0_EGR_VLAN_CONTROL_1r
#define EGR_VLAN_CONTROL_1r_SIZE BCM56504_A0_EGR_VLAN_CONTROL_1r_SIZE
typedef BCM56504_A0_EGR_VLAN_CONTROL_1r_t EGR_VLAN_CONTROL_1r_t;
#define EGR_VLAN_CONTROL_1r_CLR BCM56504_A0_EGR_VLAN_CONTROL_1r_CLR
#define EGR_VLAN_CONTROL_1r_SET BCM56504_A0_EGR_VLAN_CONTROL_1r_SET
#define EGR_VLAN_CONTROL_1r_GET BCM56504_A0_EGR_VLAN_CONTROL_1r_GET
#define EGR_VLAN_CONTROL_1r_VT_ENABLEf_GET BCM56504_A0_EGR_VLAN_CONTROL_1r_VT_ENABLEf_GET
#define EGR_VLAN_CONTROL_1r_VT_ENABLEf_SET BCM56504_A0_EGR_VLAN_CONTROL_1r_VT_ENABLEf_SET
#define EGR_VLAN_CONTROL_1r_VT_MISS_DROPf_GET BCM56504_A0_EGR_VLAN_CONTROL_1r_VT_MISS_DROPf_GET
#define EGR_VLAN_CONTROL_1r_VT_MISS_DROPf_SET BCM56504_A0_EGR_VLAN_CONTROL_1r_VT_MISS_DROPf_SET
#define EGR_VLAN_CONTROL_1r_OUTER_TPIDf_GET BCM56504_A0_EGR_VLAN_CONTROL_1r_OUTER_TPIDf_GET
#define EGR_VLAN_CONTROL_1r_OUTER_TPIDf_SET BCM56504_A0_EGR_VLAN_CONTROL_1r_OUTER_TPIDf_SET
#define READ_EGR_VLAN_CONTROL_1r BCM56504_A0_READ_EGR_VLAN_CONTROL_1r
#define WRITE_EGR_VLAN_CONTROL_1r BCM56504_A0_WRITE_EGR_VLAN_CONTROL_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_EGR_VLAN_CONTROL_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  EGR_VLAN_STG
 * BLOCKS:   EPIPE
 * DESC:     Egress Spanning Tree Stage Table
 * SIZE:     56
 * FIELDS:
 *     SP_TREE_PORT0    Spanning Tree State for Port 0.
 *     SP_TREE_PORT1    Spanning Tree State for Port 1.
 *     SP_TREE_PORT2    Spanning Tree State for Port 2.
 *     SP_TREE_PORT3    Spanning Tree State for Port 3.
 *     SP_TREE_PORT4    Spanning Tree State for Port 4.
 *     SP_TREE_PORT5    Spanning Tree State for Port 5.
 *     SP_TREE_PORT6    Spanning Tree State for Port 6.
 *     SP_TREE_PORT7    Spanning Tree State for Port 7.
 *     SP_TREE_PORT8    Spanning Tree State for Port 8.
 *     SP_TREE_PORT9    Spanning Tree State for Port 9.
 *     SP_TREE_PORT10   Spanning Tree State for Port 10.
 *     SP_TREE_PORT11   Spanning Tree State for Port 11.
 *     SP_TREE_PORT12   Spanning Tree State for Port 12.
 *     SP_TREE_PORT13   Spanning Tree State for Port 13.
 *     SP_TREE_PORT14   Spanning Tree State for Port 14.
 *     SP_TREE_PORT15   Spanning Tree State for Port 15.
 *     SP_TREE_PORT16   Spanning Tree State for Port 16.
 *     SP_TREE_PORT17   Spanning Tree State for Port 17.
 *     SP_TREE_PORT18   Spanning Tree State for Port 18.
 *     SP_TREE_PORT19   Spanning Tree State for Port 19.
 *     SP_TREE_PORT20   Spanning Tree State for Port 20.
 *     SP_TREE_PORT21   Spanning Tree State for Port 21.
 *     SP_TREE_PORT22   Spanning Tree State for Port 22.
 *     SP_TREE_PORT23   Spanning Tree State for Port 23.
 *     SP_TREE_PORT24   Spanning Tree State for Port 24.
 *     SP_TREE_PORT25   Spanning Tree State for Port 25.
 *     SP_TREE_PORT26   Spanning Tree State for Port 26.
 *     SP_TREE_PORT27   Spanning Tree State for Port 27.
 *
 ******************************************************************************/
#define BCM56504_A0_EGR_VLAN_STGm 0x04920000

#define BCM56504_A0_EGR_VLAN_STGm_MIN 0
#define BCM56504_A0_EGR_VLAN_STGm_MAX 255
#define BCM56504_A0_EGR_VLAN_STGm_CMAX(u) 255
#define BCM56504_A0_EGR_VLAN_STGm_SIZE 7

/*
 * This structure should be used to declare and program EGR_VLAN_STG.
 *
 */
typedef union BCM56504_A0_EGR_VLAN_STGm_s {
	uint32_t v[2];
	uint32_t egr_vlan_stg[2];
	uint32_t _egr_vlan_stg;
} BCM56504_A0_EGR_VLAN_STGm_t;

#define BCM56504_A0_EGR_VLAN_STGm_CLR(r) CDK_MEMSET(&((r)._egr_vlan_stg), 0, sizeof(BCM56504_A0_EGR_VLAN_STGm_t))
#define BCM56504_A0_EGR_VLAN_STGm_SET(r,i,d) (r).egr_vlan_stg[i] = d
#define BCM56504_A0_EGR_VLAN_STGm_GET(r,i) (r).egr_vlan_stg[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT0f_GET(r) (((r).egr_vlan_stg[0]) & 0x3)
#define BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT0f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT1f_GET(r) ((((r).egr_vlan_stg[0]) >> 2) & 0x3)
#define BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT1f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT2f_GET(r) ((((r).egr_vlan_stg[0]) >> 4) & 0x3)
#define BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT2f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT3f_GET(r) ((((r).egr_vlan_stg[0]) >> 6) & 0x3)
#define BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT3f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT4f_GET(r) ((((r).egr_vlan_stg[0]) >> 8) & 0x3)
#define BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT4f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT5f_GET(r) ((((r).egr_vlan_stg[0]) >> 10) & 0x3)
#define BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT5f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT6f_GET(r) ((((r).egr_vlan_stg[0]) >> 12) & 0x3)
#define BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT6f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT7f_GET(r) ((((r).egr_vlan_stg[0]) >> 14) & 0x3)
#define BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT7f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT8f_GET(r) ((((r).egr_vlan_stg[0]) >> 16) & 0x3)
#define BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT8f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT9f_GET(r) ((((r).egr_vlan_stg[0]) >> 18) & 0x3)
#define BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT9f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32_t)0x3 << 18)) | ((((uint32_t)f) & 0x3) << 18))
#define BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT10f_GET(r) ((((r).egr_vlan_stg[0]) >> 20) & 0x3)
#define BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT10f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32_t)0x3 << 20)) | ((((uint32_t)f) & 0x3) << 20))
#define BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT11f_GET(r) ((((r).egr_vlan_stg[0]) >> 22) & 0x3)
#define BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT11f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32_t)0x3 << 22)) | ((((uint32_t)f) & 0x3) << 22))
#define BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT12f_GET(r) ((((r).egr_vlan_stg[0]) >> 24) & 0x3)
#define BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT12f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32_t)0x3 << 24)) | ((((uint32_t)f) & 0x3) << 24))
#define BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT13f_GET(r) ((((r).egr_vlan_stg[0]) >> 26) & 0x3)
#define BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT13f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32_t)0x3 << 26)) | ((((uint32_t)f) & 0x3) << 26))
#define BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT14f_GET(r) ((((r).egr_vlan_stg[0]) >> 28) & 0x3)
#define BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT14f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32_t)0x3 << 28)) | ((((uint32_t)f) & 0x3) << 28))
#define BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT15f_GET(r) ((((r).egr_vlan_stg[0]) >> 30) & 0x3)
#define BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT15f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))
#define BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT16f_GET(r) (((r).egr_vlan_stg[1]) & 0x3)
#define BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT16f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT17f_GET(r) ((((r).egr_vlan_stg[1]) >> 2) & 0x3)
#define BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT17f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT18f_GET(r) ((((r).egr_vlan_stg[1]) >> 4) & 0x3)
#define BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT18f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT19f_GET(r) ((((r).egr_vlan_stg[1]) >> 6) & 0x3)
#define BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT19f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT20f_GET(r) ((((r).egr_vlan_stg[1]) >> 8) & 0x3)
#define BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT20f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT21f_GET(r) ((((r).egr_vlan_stg[1]) >> 10) & 0x3)
#define BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT21f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT22f_GET(r) ((((r).egr_vlan_stg[1]) >> 12) & 0x3)
#define BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT22f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT23f_GET(r) ((((r).egr_vlan_stg[1]) >> 14) & 0x3)
#define BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT23f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT24f_GET(r) ((((r).egr_vlan_stg[1]) >> 16) & 0x3)
#define BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT24f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT25f_GET(r) ((((r).egr_vlan_stg[1]) >> 18) & 0x3)
#define BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT25f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32_t)0x3 << 18)) | ((((uint32_t)f) & 0x3) << 18))
#define BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT26f_GET(r) ((((r).egr_vlan_stg[1]) >> 20) & 0x3)
#define BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT26f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32_t)0x3 << 20)) | ((((uint32_t)f) & 0x3) << 20))
#define BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT27f_GET(r) ((((r).egr_vlan_stg[1]) >> 22) & 0x3)
#define BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT27f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32_t)0x3 << 22)) | ((((uint32_t)f) & 0x3) << 22))

/*
 * These macros can be used to access EGR_VLAN_STG.
 *
 */
#define BCM56504_A0_READ_EGR_VLAN_STGm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_EGR_VLAN_STGm,i,(m._egr_vlan_stg),2)
#define BCM56504_A0_WRITE_EGR_VLAN_STGm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_EGR_VLAN_STGm,i,&(m._egr_vlan_stg),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_VLAN_STGm BCM56504_A0_EGR_VLAN_STGm
#define EGR_VLAN_STGm_MIN BCM56504_A0_EGR_VLAN_STGm_MIN
#define EGR_VLAN_STGm_MAX BCM56504_A0_EGR_VLAN_STGm_MAX
#define EGR_VLAN_STGm_CMAX(u) BCM56504_A0_EGR_VLAN_STGm_CMAX(u)
#define EGR_VLAN_STGm_SIZE BCM56504_A0_EGR_VLAN_STGm_SIZE
typedef BCM56504_A0_EGR_VLAN_STGm_t EGR_VLAN_STGm_t;
#define EGR_VLAN_STGm_CLR BCM56504_A0_EGR_VLAN_STGm_CLR
#define EGR_VLAN_STGm_SET BCM56504_A0_EGR_VLAN_STGm_SET
#define EGR_VLAN_STGm_GET BCM56504_A0_EGR_VLAN_STGm_GET
#define EGR_VLAN_STGm_SP_TREE_PORT0f_GET BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT0f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT0f_SET BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT0f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT1f_GET BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT1f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT1f_SET BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT1f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT2f_GET BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT2f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT2f_SET BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT2f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT3f_GET BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT3f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT3f_SET BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT3f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT4f_GET BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT4f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT4f_SET BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT4f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT5f_GET BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT5f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT5f_SET BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT5f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT6f_GET BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT6f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT6f_SET BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT6f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT7f_GET BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT7f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT7f_SET BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT7f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT8f_GET BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT8f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT8f_SET BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT8f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT9f_GET BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT9f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT9f_SET BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT9f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT10f_GET BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT10f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT10f_SET BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT10f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT11f_GET BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT11f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT11f_SET BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT11f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT12f_GET BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT12f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT12f_SET BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT12f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT13f_GET BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT13f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT13f_SET BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT13f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT14f_GET BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT14f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT14f_SET BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT14f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT15f_GET BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT15f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT15f_SET BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT15f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT16f_GET BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT16f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT16f_SET BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT16f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT17f_GET BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT17f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT17f_SET BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT17f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT18f_GET BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT18f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT18f_SET BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT18f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT19f_GET BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT19f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT19f_SET BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT19f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT20f_GET BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT20f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT20f_SET BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT20f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT21f_GET BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT21f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT21f_SET BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT21f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT22f_GET BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT22f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT22f_SET BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT22f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT23f_GET BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT23f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT23f_SET BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT23f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT24f_GET BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT24f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT24f_SET BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT24f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT25f_GET BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT25f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT25f_SET BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT25f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT26f_GET BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT26f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT26f_SET BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT26f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT27f_GET BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT27f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT27f_SET BCM56504_A0_EGR_VLAN_STGm_SP_TREE_PORT27f_SET
#define READ_EGR_VLAN_STGm BCM56504_A0_READ_EGR_VLAN_STGm
#define WRITE_EGR_VLAN_STGm BCM56504_A0_WRITE_EGR_VLAN_STGm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_EGR_VLAN_STGm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  EGR_VLAN_XLATE
 * BLOCKS:   EPIPE
 * DESC:     Egress Vlan Translate CAM-RAM Combined View.
 * SIZE:     34
 * FIELDS:
 *     VALID            Valid Bit for the Entry. It has to be 0th bit in the CAM.
 *     VID              VID to be compared wrt the input Key.
 *     EGRESS_PORT      Destination port to be compared wrt the input key.
 *     NEW_VLAN_ID      VID to be used to translate the original packet or so far constructed VID at L3 stage.
 *     PRI              Priority to be used to translate the original priority.
 *     RPE              Used to determine if the vlan_xlate_data PRI needs to be replaced.
 *
 ******************************************************************************/
#define BCM56504_A0_EGR_VLAN_XLATEm 0x05910000

#define BCM56504_A0_EGR_VLAN_XLATEm_MIN 0
#define BCM56504_A0_EGR_VLAN_XLATEm_MAX 767
#define BCM56504_A0_EGR_VLAN_XLATEm_CMAX(u) 767
#define BCM56504_A0_EGR_VLAN_XLATEm_SIZE 5

/*
 * This structure should be used to declare and program EGR_VLAN_XLATE.
 *
 */
typedef union BCM56504_A0_EGR_VLAN_XLATEm_s {
	uint32_t v[2];
	uint32_t egr_vlan_xlate[2];
	uint32_t _egr_vlan_xlate;
} BCM56504_A0_EGR_VLAN_XLATEm_t;

#define BCM56504_A0_EGR_VLAN_XLATEm_CLR(r) CDK_MEMSET(&((r)._egr_vlan_xlate), 0, sizeof(BCM56504_A0_EGR_VLAN_XLATEm_t))
#define BCM56504_A0_EGR_VLAN_XLATEm_SET(r,i,d) (r).egr_vlan_xlate[i] = d
#define BCM56504_A0_EGR_VLAN_XLATEm_GET(r,i) (r).egr_vlan_xlate[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_EGR_VLAN_XLATEm_VALIDf_GET(r) (((r).egr_vlan_xlate[0]) & 0x1)
#define BCM56504_A0_EGR_VLAN_XLATEm_VALIDf_SET(r,f) (r).egr_vlan_xlate[0]=(((r).egr_vlan_xlate[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_EGR_VLAN_XLATEm_VIDf_GET(r) ((((r).egr_vlan_xlate[0]) >> 1) & 0xfff)
#define BCM56504_A0_EGR_VLAN_XLATEm_VIDf_SET(r,f) (r).egr_vlan_xlate[0]=(((r).egr_vlan_xlate[0] & ~((uint32_t)0xfff << 1)) | ((((uint32_t)f) & 0xfff) << 1))
#define BCM56504_A0_EGR_VLAN_XLATEm_EGRESS_PORTf_GET(r) ((((r).egr_vlan_xlate[0]) >> 13) & 0x1f)
#define BCM56504_A0_EGR_VLAN_XLATEm_EGRESS_PORTf_SET(r,f) (r).egr_vlan_xlate[0]=(((r).egr_vlan_xlate[0] & ~((uint32_t)0x1f << 13)) | ((((uint32_t)f) & 0x1f) << 13))
#define BCM56504_A0_EGR_VLAN_XLATEm_NEW_VLAN_IDf_GET(r) ((((r).egr_vlan_xlate[0]) >> 18) & 0xfff)
#define BCM56504_A0_EGR_VLAN_XLATEm_NEW_VLAN_IDf_SET(r,f) (r).egr_vlan_xlate[0]=(((r).egr_vlan_xlate[0] & ~((uint32_t)0xfff << 18)) | ((((uint32_t)f) & 0xfff) << 18))
#define BCM56504_A0_EGR_VLAN_XLATEm_PRIf_GET(r) cdk_field32_get((r).egr_vlan_xlate,30,32)
#define BCM56504_A0_EGR_VLAN_XLATEm_PRIf_SET(r,f) cdk_field32_set((r).egr_vlan_xlate,30,32,f)
#define BCM56504_A0_EGR_VLAN_XLATEm_RPEf_GET(r) ((((r).egr_vlan_xlate[1]) >> 1) & 0x1)
#define BCM56504_A0_EGR_VLAN_XLATEm_RPEf_SET(r,f) (r).egr_vlan_xlate[1]=(((r).egr_vlan_xlate[1] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access EGR_VLAN_XLATE.
 *
 */
#define BCM56504_A0_READ_EGR_VLAN_XLATEm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_EGR_VLAN_XLATEm,i,(m._egr_vlan_xlate),2)
#define BCM56504_A0_WRITE_EGR_VLAN_XLATEm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_EGR_VLAN_XLATEm,i,&(m._egr_vlan_xlate),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_VLAN_XLATEm BCM56504_A0_EGR_VLAN_XLATEm
#define EGR_VLAN_XLATEm_MIN BCM56504_A0_EGR_VLAN_XLATEm_MIN
#define EGR_VLAN_XLATEm_MAX BCM56504_A0_EGR_VLAN_XLATEm_MAX
#define EGR_VLAN_XLATEm_CMAX(u) BCM56504_A0_EGR_VLAN_XLATEm_CMAX(u)
#define EGR_VLAN_XLATEm_SIZE BCM56504_A0_EGR_VLAN_XLATEm_SIZE
typedef BCM56504_A0_EGR_VLAN_XLATEm_t EGR_VLAN_XLATEm_t;
#define EGR_VLAN_XLATEm_CLR BCM56504_A0_EGR_VLAN_XLATEm_CLR
#define EGR_VLAN_XLATEm_SET BCM56504_A0_EGR_VLAN_XLATEm_SET
#define EGR_VLAN_XLATEm_GET BCM56504_A0_EGR_VLAN_XLATEm_GET
#define EGR_VLAN_XLATEm_VALIDf_GET BCM56504_A0_EGR_VLAN_XLATEm_VALIDf_GET
#define EGR_VLAN_XLATEm_VALIDf_SET BCM56504_A0_EGR_VLAN_XLATEm_VALIDf_SET
#define EGR_VLAN_XLATEm_VIDf_GET BCM56504_A0_EGR_VLAN_XLATEm_VIDf_GET
#define EGR_VLAN_XLATEm_VIDf_SET BCM56504_A0_EGR_VLAN_XLATEm_VIDf_SET
#define EGR_VLAN_XLATEm_EGRESS_PORTf_GET BCM56504_A0_EGR_VLAN_XLATEm_EGRESS_PORTf_GET
#define EGR_VLAN_XLATEm_EGRESS_PORTf_SET BCM56504_A0_EGR_VLAN_XLATEm_EGRESS_PORTf_SET
#define EGR_VLAN_XLATEm_NEW_VLAN_IDf_GET BCM56504_A0_EGR_VLAN_XLATEm_NEW_VLAN_IDf_GET
#define EGR_VLAN_XLATEm_NEW_VLAN_IDf_SET BCM56504_A0_EGR_VLAN_XLATEm_NEW_VLAN_IDf_SET
#define EGR_VLAN_XLATEm_PRIf_GET BCM56504_A0_EGR_VLAN_XLATEm_PRIf_GET
#define EGR_VLAN_XLATEm_PRIf_SET BCM56504_A0_EGR_VLAN_XLATEm_PRIf_SET
#define EGR_VLAN_XLATEm_RPEf_GET BCM56504_A0_EGR_VLAN_XLATEm_RPEf_GET
#define EGR_VLAN_XLATEm_RPEf_SET BCM56504_A0_EGR_VLAN_XLATEm_RPEf_SET
#define READ_EGR_VLAN_XLATEm BCM56504_A0_READ_EGR_VLAN_XLATEm
#define WRITE_EGR_VLAN_XLATEm BCM56504_A0_WRITE_EGR_VLAN_XLATEm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_EGR_VLAN_XLATEm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  EGR_VLAN_XLATE_DATA_ONLY
 * BLOCKS:   EPIPE
 * DESC:     Egress Vlan Translate Data Table only
 * SIZE:     16
 * FIELDS:
 *     NEW_VID          VID to be used to translate the original packet or so far constructed VID at L3 stage.
 *     PRI              Priority to be used to translate the original priority.
 *     RPE              Used to determine if the vlan_xlate_data PRI needs to be replaced.
 *
 ******************************************************************************/
#define BCM56504_A0_EGR_VLAN_XLATE_DATA_ONLYm 0x05930000

#define BCM56504_A0_EGR_VLAN_XLATE_DATA_ONLYm_MIN 0
#define BCM56504_A0_EGR_VLAN_XLATE_DATA_ONLYm_MAX 767
#define BCM56504_A0_EGR_VLAN_XLATE_DATA_ONLYm_CMAX(u) 767
#define BCM56504_A0_EGR_VLAN_XLATE_DATA_ONLYm_SIZE 2

/*
 * This structure should be used to declare and program EGR_VLAN_XLATE_DATA_ONLY.
 *
 */
typedef union BCM56504_A0_EGR_VLAN_XLATE_DATA_ONLYm_s {
	uint32_t v[1];
	uint32_t egr_vlan_xlate_data_only[1];
	uint32_t _egr_vlan_xlate_data_only;
} BCM56504_A0_EGR_VLAN_XLATE_DATA_ONLYm_t;

#define BCM56504_A0_EGR_VLAN_XLATE_DATA_ONLYm_CLR(r) (r).egr_vlan_xlate_data_only[0] = 0
#define BCM56504_A0_EGR_VLAN_XLATE_DATA_ONLYm_SET(r,d) (r).egr_vlan_xlate_data_only[0] = d
#define BCM56504_A0_EGR_VLAN_XLATE_DATA_ONLYm_GET(r) (r).egr_vlan_xlate_data_only[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_EGR_VLAN_XLATE_DATA_ONLYm_NEW_VIDf_GET(r) (((r).egr_vlan_xlate_data_only[0]) & 0xfff)
#define BCM56504_A0_EGR_VLAN_XLATE_DATA_ONLYm_NEW_VIDf_SET(r,f) (r).egr_vlan_xlate_data_only[0]=(((r).egr_vlan_xlate_data_only[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM56504_A0_EGR_VLAN_XLATE_DATA_ONLYm_PRIf_GET(r) ((((r).egr_vlan_xlate_data_only[0]) >> 12) & 0x7)
#define BCM56504_A0_EGR_VLAN_XLATE_DATA_ONLYm_PRIf_SET(r,f) (r).egr_vlan_xlate_data_only[0]=(((r).egr_vlan_xlate_data_only[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM56504_A0_EGR_VLAN_XLATE_DATA_ONLYm_RPEf_GET(r) ((((r).egr_vlan_xlate_data_only[0]) >> 15) & 0x1)
#define BCM56504_A0_EGR_VLAN_XLATE_DATA_ONLYm_RPEf_SET(r,f) (r).egr_vlan_xlate_data_only[0]=(((r).egr_vlan_xlate_data_only[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access EGR_VLAN_XLATE_DATA_ONLY.
 *
 */
#define BCM56504_A0_READ_EGR_VLAN_XLATE_DATA_ONLYm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_EGR_VLAN_XLATE_DATA_ONLYm,i,(m._egr_vlan_xlate_data_only),1)
#define BCM56504_A0_WRITE_EGR_VLAN_XLATE_DATA_ONLYm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_EGR_VLAN_XLATE_DATA_ONLYm,i,&(m._egr_vlan_xlate_data_only),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_VLAN_XLATE_DATA_ONLYm BCM56504_A0_EGR_VLAN_XLATE_DATA_ONLYm
#define EGR_VLAN_XLATE_DATA_ONLYm_MIN BCM56504_A0_EGR_VLAN_XLATE_DATA_ONLYm_MIN
#define EGR_VLAN_XLATE_DATA_ONLYm_MAX BCM56504_A0_EGR_VLAN_XLATE_DATA_ONLYm_MAX
#define EGR_VLAN_XLATE_DATA_ONLYm_CMAX(u) BCM56504_A0_EGR_VLAN_XLATE_DATA_ONLYm_CMAX(u)
#define EGR_VLAN_XLATE_DATA_ONLYm_SIZE BCM56504_A0_EGR_VLAN_XLATE_DATA_ONLYm_SIZE
typedef BCM56504_A0_EGR_VLAN_XLATE_DATA_ONLYm_t EGR_VLAN_XLATE_DATA_ONLYm_t;
#define EGR_VLAN_XLATE_DATA_ONLYm_CLR BCM56504_A0_EGR_VLAN_XLATE_DATA_ONLYm_CLR
#define EGR_VLAN_XLATE_DATA_ONLYm_SET BCM56504_A0_EGR_VLAN_XLATE_DATA_ONLYm_SET
#define EGR_VLAN_XLATE_DATA_ONLYm_GET BCM56504_A0_EGR_VLAN_XLATE_DATA_ONLYm_GET
#define EGR_VLAN_XLATE_DATA_ONLYm_NEW_VIDf_GET BCM56504_A0_EGR_VLAN_XLATE_DATA_ONLYm_NEW_VIDf_GET
#define EGR_VLAN_XLATE_DATA_ONLYm_NEW_VIDf_SET BCM56504_A0_EGR_VLAN_XLATE_DATA_ONLYm_NEW_VIDf_SET
#define EGR_VLAN_XLATE_DATA_ONLYm_PRIf_GET BCM56504_A0_EGR_VLAN_XLATE_DATA_ONLYm_PRIf_GET
#define EGR_VLAN_XLATE_DATA_ONLYm_PRIf_SET BCM56504_A0_EGR_VLAN_XLATE_DATA_ONLYm_PRIf_SET
#define EGR_VLAN_XLATE_DATA_ONLYm_RPEf_GET BCM56504_A0_EGR_VLAN_XLATE_DATA_ONLYm_RPEf_GET
#define EGR_VLAN_XLATE_DATA_ONLYm_RPEf_SET BCM56504_A0_EGR_VLAN_XLATE_DATA_ONLYm_RPEf_SET
#define READ_EGR_VLAN_XLATE_DATA_ONLYm BCM56504_A0_READ_EGR_VLAN_XLATE_DATA_ONLYm
#define WRITE_EGR_VLAN_XLATE_DATA_ONLYm BCM56504_A0_WRITE_EGR_VLAN_XLATE_DATA_ONLYm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_EGR_VLAN_XLATE_DATA_ONLYm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  EGR_VLAN_XLATE_ONLY
 * BLOCKS:   EPIPE
 * DESC:     Egress Vlan Translate CAM only.
 * SIZE:     18
 * FIELDS:
 *     VALID            Valid Bit for the Entry. It has to be 0th bit in the CAM.
 *     VID              VID to be compared wrt the input Key.
 *     EGRESS_PORT      Destination port to be compared wrt the input key.
 *
 ******************************************************************************/
#define BCM56504_A0_EGR_VLAN_XLATE_ONLYm 0x05920000

#define BCM56504_A0_EGR_VLAN_XLATE_ONLYm_MIN 0
#define BCM56504_A0_EGR_VLAN_XLATE_ONLYm_MAX 767
#define BCM56504_A0_EGR_VLAN_XLATE_ONLYm_CMAX(u) 767
#define BCM56504_A0_EGR_VLAN_XLATE_ONLYm_SIZE 3

/*
 * This structure should be used to declare and program EGR_VLAN_XLATE_ONLY.
 *
 */
typedef union BCM56504_A0_EGR_VLAN_XLATE_ONLYm_s {
	uint32_t v[1];
	uint32_t egr_vlan_xlate_only[1];
	uint32_t _egr_vlan_xlate_only;
} BCM56504_A0_EGR_VLAN_XLATE_ONLYm_t;

#define BCM56504_A0_EGR_VLAN_XLATE_ONLYm_CLR(r) (r).egr_vlan_xlate_only[0] = 0
#define BCM56504_A0_EGR_VLAN_XLATE_ONLYm_SET(r,d) (r).egr_vlan_xlate_only[0] = d
#define BCM56504_A0_EGR_VLAN_XLATE_ONLYm_GET(r) (r).egr_vlan_xlate_only[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_EGR_VLAN_XLATE_ONLYm_VALIDf_GET(r) (((r).egr_vlan_xlate_only[0]) & 0x1)
#define BCM56504_A0_EGR_VLAN_XLATE_ONLYm_VALIDf_SET(r,f) (r).egr_vlan_xlate_only[0]=(((r).egr_vlan_xlate_only[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_EGR_VLAN_XLATE_ONLYm_VIDf_GET(r) ((((r).egr_vlan_xlate_only[0]) >> 1) & 0xfff)
#define BCM56504_A0_EGR_VLAN_XLATE_ONLYm_VIDf_SET(r,f) (r).egr_vlan_xlate_only[0]=(((r).egr_vlan_xlate_only[0] & ~((uint32_t)0xfff << 1)) | ((((uint32_t)f) & 0xfff) << 1))
#define BCM56504_A0_EGR_VLAN_XLATE_ONLYm_EGRESS_PORTf_GET(r) ((((r).egr_vlan_xlate_only[0]) >> 13) & 0x1f)
#define BCM56504_A0_EGR_VLAN_XLATE_ONLYm_EGRESS_PORTf_SET(r,f) (r).egr_vlan_xlate_only[0]=(((r).egr_vlan_xlate_only[0] & ~((uint32_t)0x1f << 13)) | ((((uint32_t)f) & 0x1f) << 13))

/*
 * These macros can be used to access EGR_VLAN_XLATE_ONLY.
 *
 */
#define BCM56504_A0_READ_EGR_VLAN_XLATE_ONLYm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_EGR_VLAN_XLATE_ONLYm,i,(m._egr_vlan_xlate_only),1)
#define BCM56504_A0_WRITE_EGR_VLAN_XLATE_ONLYm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_EGR_VLAN_XLATE_ONLYm,i,&(m._egr_vlan_xlate_only),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_VLAN_XLATE_ONLYm BCM56504_A0_EGR_VLAN_XLATE_ONLYm
#define EGR_VLAN_XLATE_ONLYm_MIN BCM56504_A0_EGR_VLAN_XLATE_ONLYm_MIN
#define EGR_VLAN_XLATE_ONLYm_MAX BCM56504_A0_EGR_VLAN_XLATE_ONLYm_MAX
#define EGR_VLAN_XLATE_ONLYm_CMAX(u) BCM56504_A0_EGR_VLAN_XLATE_ONLYm_CMAX(u)
#define EGR_VLAN_XLATE_ONLYm_SIZE BCM56504_A0_EGR_VLAN_XLATE_ONLYm_SIZE
typedef BCM56504_A0_EGR_VLAN_XLATE_ONLYm_t EGR_VLAN_XLATE_ONLYm_t;
#define EGR_VLAN_XLATE_ONLYm_CLR BCM56504_A0_EGR_VLAN_XLATE_ONLYm_CLR
#define EGR_VLAN_XLATE_ONLYm_SET BCM56504_A0_EGR_VLAN_XLATE_ONLYm_SET
#define EGR_VLAN_XLATE_ONLYm_GET BCM56504_A0_EGR_VLAN_XLATE_ONLYm_GET
#define EGR_VLAN_XLATE_ONLYm_VALIDf_GET BCM56504_A0_EGR_VLAN_XLATE_ONLYm_VALIDf_GET
#define EGR_VLAN_XLATE_ONLYm_VALIDf_SET BCM56504_A0_EGR_VLAN_XLATE_ONLYm_VALIDf_SET
#define EGR_VLAN_XLATE_ONLYm_VIDf_GET BCM56504_A0_EGR_VLAN_XLATE_ONLYm_VIDf_GET
#define EGR_VLAN_XLATE_ONLYm_VIDf_SET BCM56504_A0_EGR_VLAN_XLATE_ONLYm_VIDf_SET
#define EGR_VLAN_XLATE_ONLYm_EGRESS_PORTf_GET BCM56504_A0_EGR_VLAN_XLATE_ONLYm_EGRESS_PORTf_GET
#define EGR_VLAN_XLATE_ONLYm_EGRESS_PORTf_SET BCM56504_A0_EGR_VLAN_XLATE_ONLYm_EGRESS_PORTf_SET
#define READ_EGR_VLAN_XLATE_ONLYm BCM56504_A0_READ_EGR_VLAN_XLATE_ONLYm
#define WRITE_EGR_VLAN_XLATE_ONLYm BCM56504_A0_WRITE_EGR_VLAN_XLATE_ONLYm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_EGR_VLAN_XLATE_ONLYm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  EGR_VXLT_CAM_BIST_S2_STATUS
 * BLOCKS:   EPIPE
 * DESC:     EGR_VXLT_CAM_BIST_S2_STATUS
 * SIZE:     32
 * FIELDS:
 *     MATCH_STATUS     Match status
 *     BIT_POS          Sliding Bit position when match happened
 *     AINDEX           Aindex when match happened
 *
 ******************************************************************************/
#define BCM56504_A0_EGR_VXLT_CAM_BIST_S2_STATUSr 0x05980002

#define BCM56504_A0_EGR_VXLT_CAM_BIST_S2_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program EGR_VXLT_CAM_BIST_S2_STATUS.
 *
 */
typedef union BCM56504_A0_EGR_VXLT_CAM_BIST_S2_STATUSr_s {
	uint32_t v[1];
	uint32_t egr_vxlt_cam_bist_s2_status[1];
	uint32_t _egr_vxlt_cam_bist_s2_status;
} BCM56504_A0_EGR_VXLT_CAM_BIST_S2_STATUSr_t;

#define BCM56504_A0_EGR_VXLT_CAM_BIST_S2_STATUSr_CLR(r) (r).egr_vxlt_cam_bist_s2_status[0] = 0
#define BCM56504_A0_EGR_VXLT_CAM_BIST_S2_STATUSr_SET(r,d) (r).egr_vxlt_cam_bist_s2_status[0] = d
#define BCM56504_A0_EGR_VXLT_CAM_BIST_S2_STATUSr_GET(r) (r).egr_vxlt_cam_bist_s2_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_EGR_VXLT_CAM_BIST_S2_STATUSr_MATCH_STATUSf_GET(r) (((r).egr_vxlt_cam_bist_s2_status[0]) & 0x1)
#define BCM56504_A0_EGR_VXLT_CAM_BIST_S2_STATUSr_MATCH_STATUSf_SET(r,f) (r).egr_vxlt_cam_bist_s2_status[0]=(((r).egr_vxlt_cam_bist_s2_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_EGR_VXLT_CAM_BIST_S2_STATUSr_BIT_POSf_GET(r) ((((r).egr_vxlt_cam_bist_s2_status[0]) >> 1) & 0x1f)
#define BCM56504_A0_EGR_VXLT_CAM_BIST_S2_STATUSr_BIT_POSf_SET(r,f) (r).egr_vxlt_cam_bist_s2_status[0]=(((r).egr_vxlt_cam_bist_s2_status[0] & ~((uint32_t)0x1f << 1)) | ((((uint32_t)f) & 0x1f) << 1))
#define BCM56504_A0_EGR_VXLT_CAM_BIST_S2_STATUSr_AINDEXf_GET(r) ((((r).egr_vxlt_cam_bist_s2_status[0]) >> 6) & 0x3ff)
#define BCM56504_A0_EGR_VXLT_CAM_BIST_S2_STATUSr_AINDEXf_SET(r,f) (r).egr_vxlt_cam_bist_s2_status[0]=(((r).egr_vxlt_cam_bist_s2_status[0] & ~((uint32_t)0x3ff << 6)) | ((((uint32_t)f) & 0x3ff) << 6))

/*
 * These macros can be used to access EGR_VXLT_CAM_BIST_S2_STATUS.
 *
 */
#define BCM56504_A0_READ_EGR_VXLT_CAM_BIST_S2_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_EGR_VXLT_CAM_BIST_S2_STATUSr,(r._egr_vxlt_cam_bist_s2_status))
#define BCM56504_A0_WRITE_EGR_VXLT_CAM_BIST_S2_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_EGR_VXLT_CAM_BIST_S2_STATUSr,&(r._egr_vxlt_cam_bist_s2_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_VXLT_CAM_BIST_S2_STATUSr BCM56504_A0_EGR_VXLT_CAM_BIST_S2_STATUSr
#define EGR_VXLT_CAM_BIST_S2_STATUSr_SIZE BCM56504_A0_EGR_VXLT_CAM_BIST_S2_STATUSr_SIZE
typedef BCM56504_A0_EGR_VXLT_CAM_BIST_S2_STATUSr_t EGR_VXLT_CAM_BIST_S2_STATUSr_t;
#define EGR_VXLT_CAM_BIST_S2_STATUSr_CLR BCM56504_A0_EGR_VXLT_CAM_BIST_S2_STATUSr_CLR
#define EGR_VXLT_CAM_BIST_S2_STATUSr_SET BCM56504_A0_EGR_VXLT_CAM_BIST_S2_STATUSr_SET
#define EGR_VXLT_CAM_BIST_S2_STATUSr_GET BCM56504_A0_EGR_VXLT_CAM_BIST_S2_STATUSr_GET
#define EGR_VXLT_CAM_BIST_S2_STATUSr_MATCH_STATUSf_GET BCM56504_A0_EGR_VXLT_CAM_BIST_S2_STATUSr_MATCH_STATUSf_GET
#define EGR_VXLT_CAM_BIST_S2_STATUSr_MATCH_STATUSf_SET BCM56504_A0_EGR_VXLT_CAM_BIST_S2_STATUSr_MATCH_STATUSf_SET
#define EGR_VXLT_CAM_BIST_S2_STATUSr_BIT_POSf_GET BCM56504_A0_EGR_VXLT_CAM_BIST_S2_STATUSr_BIT_POSf_GET
#define EGR_VXLT_CAM_BIST_S2_STATUSr_BIT_POSf_SET BCM56504_A0_EGR_VXLT_CAM_BIST_S2_STATUSr_BIT_POSf_SET
#define EGR_VXLT_CAM_BIST_S2_STATUSr_AINDEXf_GET BCM56504_A0_EGR_VXLT_CAM_BIST_S2_STATUSr_AINDEXf_GET
#define EGR_VXLT_CAM_BIST_S2_STATUSr_AINDEXf_SET BCM56504_A0_EGR_VXLT_CAM_BIST_S2_STATUSr_AINDEXf_SET
#define READ_EGR_VXLT_CAM_BIST_S2_STATUSr BCM56504_A0_READ_EGR_VXLT_CAM_BIST_S2_STATUSr
#define WRITE_EGR_VXLT_CAM_BIST_S2_STATUSr BCM56504_A0_WRITE_EGR_VXLT_CAM_BIST_S2_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_EGR_VXLT_CAM_BIST_S2_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  EGR_VXLT_CAM_BIST_S3_STATUS
 * BLOCKS:   EPIPE
 * DESC:     EGR_VXLT_CAM_BIST_S3_STATUS
 * SIZE:     32
 * FIELDS:
 *     MATCH_STATUS     Match status
 *     AINDEX_STATUS    AIndex status
 *     ACTUAL_AINDEX    Actual AIndex when CAM reported a match
 *     EXPECTED_AINDEX  Expected AIndex
 *
 ******************************************************************************/
#define BCM56504_A0_EGR_VXLT_CAM_BIST_S3_STATUSr 0x05980003

#define BCM56504_A0_EGR_VXLT_CAM_BIST_S3_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program EGR_VXLT_CAM_BIST_S3_STATUS.
 *
 */
typedef union BCM56504_A0_EGR_VXLT_CAM_BIST_S3_STATUSr_s {
	uint32_t v[1];
	uint32_t egr_vxlt_cam_bist_s3_status[1];
	uint32_t _egr_vxlt_cam_bist_s3_status;
} BCM56504_A0_EGR_VXLT_CAM_BIST_S3_STATUSr_t;

#define BCM56504_A0_EGR_VXLT_CAM_BIST_S3_STATUSr_CLR(r) (r).egr_vxlt_cam_bist_s3_status[0] = 0
#define BCM56504_A0_EGR_VXLT_CAM_BIST_S3_STATUSr_SET(r,d) (r).egr_vxlt_cam_bist_s3_status[0] = d
#define BCM56504_A0_EGR_VXLT_CAM_BIST_S3_STATUSr_GET(r) (r).egr_vxlt_cam_bist_s3_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_EGR_VXLT_CAM_BIST_S3_STATUSr_MATCH_STATUSf_GET(r) (((r).egr_vxlt_cam_bist_s3_status[0]) & 0x1)
#define BCM56504_A0_EGR_VXLT_CAM_BIST_S3_STATUSr_MATCH_STATUSf_SET(r,f) (r).egr_vxlt_cam_bist_s3_status[0]=(((r).egr_vxlt_cam_bist_s3_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_EGR_VXLT_CAM_BIST_S3_STATUSr_AINDEX_STATUSf_GET(r) ((((r).egr_vxlt_cam_bist_s3_status[0]) >> 1) & 0x1)
#define BCM56504_A0_EGR_VXLT_CAM_BIST_S3_STATUSr_AINDEX_STATUSf_SET(r,f) (r).egr_vxlt_cam_bist_s3_status[0]=(((r).egr_vxlt_cam_bist_s3_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_EGR_VXLT_CAM_BIST_S3_STATUSr_ACTUAL_AINDEXf_GET(r) ((((r).egr_vxlt_cam_bist_s3_status[0]) >> 2) & 0x3ff)
#define BCM56504_A0_EGR_VXLT_CAM_BIST_S3_STATUSr_ACTUAL_AINDEXf_SET(r,f) (r).egr_vxlt_cam_bist_s3_status[0]=(((r).egr_vxlt_cam_bist_s3_status[0] & ~((uint32_t)0x3ff << 2)) | ((((uint32_t)f) & 0x3ff) << 2))
#define BCM56504_A0_EGR_VXLT_CAM_BIST_S3_STATUSr_EXPECTED_AINDEXf_GET(r) ((((r).egr_vxlt_cam_bist_s3_status[0]) >> 12) & 0x3ff)
#define BCM56504_A0_EGR_VXLT_CAM_BIST_S3_STATUSr_EXPECTED_AINDEXf_SET(r,f) (r).egr_vxlt_cam_bist_s3_status[0]=(((r).egr_vxlt_cam_bist_s3_status[0] & ~((uint32_t)0x3ff << 12)) | ((((uint32_t)f) & 0x3ff) << 12))

/*
 * These macros can be used to access EGR_VXLT_CAM_BIST_S3_STATUS.
 *
 */
#define BCM56504_A0_READ_EGR_VXLT_CAM_BIST_S3_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_EGR_VXLT_CAM_BIST_S3_STATUSr,(r._egr_vxlt_cam_bist_s3_status))
#define BCM56504_A0_WRITE_EGR_VXLT_CAM_BIST_S3_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_EGR_VXLT_CAM_BIST_S3_STATUSr,&(r._egr_vxlt_cam_bist_s3_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_VXLT_CAM_BIST_S3_STATUSr BCM56504_A0_EGR_VXLT_CAM_BIST_S3_STATUSr
#define EGR_VXLT_CAM_BIST_S3_STATUSr_SIZE BCM56504_A0_EGR_VXLT_CAM_BIST_S3_STATUSr_SIZE
typedef BCM56504_A0_EGR_VXLT_CAM_BIST_S3_STATUSr_t EGR_VXLT_CAM_BIST_S3_STATUSr_t;
#define EGR_VXLT_CAM_BIST_S3_STATUSr_CLR BCM56504_A0_EGR_VXLT_CAM_BIST_S3_STATUSr_CLR
#define EGR_VXLT_CAM_BIST_S3_STATUSr_SET BCM56504_A0_EGR_VXLT_CAM_BIST_S3_STATUSr_SET
#define EGR_VXLT_CAM_BIST_S3_STATUSr_GET BCM56504_A0_EGR_VXLT_CAM_BIST_S3_STATUSr_GET
#define EGR_VXLT_CAM_BIST_S3_STATUSr_MATCH_STATUSf_GET BCM56504_A0_EGR_VXLT_CAM_BIST_S3_STATUSr_MATCH_STATUSf_GET
#define EGR_VXLT_CAM_BIST_S3_STATUSr_MATCH_STATUSf_SET BCM56504_A0_EGR_VXLT_CAM_BIST_S3_STATUSr_MATCH_STATUSf_SET
#define EGR_VXLT_CAM_BIST_S3_STATUSr_AINDEX_STATUSf_GET BCM56504_A0_EGR_VXLT_CAM_BIST_S3_STATUSr_AINDEX_STATUSf_GET
#define EGR_VXLT_CAM_BIST_S3_STATUSr_AINDEX_STATUSf_SET BCM56504_A0_EGR_VXLT_CAM_BIST_S3_STATUSr_AINDEX_STATUSf_SET
#define EGR_VXLT_CAM_BIST_S3_STATUSr_ACTUAL_AINDEXf_GET BCM56504_A0_EGR_VXLT_CAM_BIST_S3_STATUSr_ACTUAL_AINDEXf_GET
#define EGR_VXLT_CAM_BIST_S3_STATUSr_ACTUAL_AINDEXf_SET BCM56504_A0_EGR_VXLT_CAM_BIST_S3_STATUSr_ACTUAL_AINDEXf_SET
#define EGR_VXLT_CAM_BIST_S3_STATUSr_EXPECTED_AINDEXf_GET BCM56504_A0_EGR_VXLT_CAM_BIST_S3_STATUSr_EXPECTED_AINDEXf_GET
#define EGR_VXLT_CAM_BIST_S3_STATUSr_EXPECTED_AINDEXf_SET BCM56504_A0_EGR_VXLT_CAM_BIST_S3_STATUSr_EXPECTED_AINDEXf_SET
#define READ_EGR_VXLT_CAM_BIST_S3_STATUSr BCM56504_A0_READ_EGR_VXLT_CAM_BIST_S3_STATUSr
#define WRITE_EGR_VXLT_CAM_BIST_S3_STATUSr BCM56504_A0_WRITE_EGR_VXLT_CAM_BIST_S3_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_EGR_VXLT_CAM_BIST_S3_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  EGR_VXLT_CAM_BIST_S5_STATUS
 * BLOCKS:   EPIPE
 * DESC:     EGR_VXLT_CAM_BIST_S5_STATUS
 * SIZE:     32
 * FIELDS:
 *     MATCH_STATUS     Match status
 *     BIT_POS          Sliding Bit position when match happened
 *     AINDEX           Aindex when match happened
 *
 ******************************************************************************/
#define BCM56504_A0_EGR_VXLT_CAM_BIST_S5_STATUSr 0x05980004

#define BCM56504_A0_EGR_VXLT_CAM_BIST_S5_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program EGR_VXLT_CAM_BIST_S5_STATUS.
 *
 */
typedef union BCM56504_A0_EGR_VXLT_CAM_BIST_S5_STATUSr_s {
	uint32_t v[1];
	uint32_t egr_vxlt_cam_bist_s5_status[1];
	uint32_t _egr_vxlt_cam_bist_s5_status;
} BCM56504_A0_EGR_VXLT_CAM_BIST_S5_STATUSr_t;

#define BCM56504_A0_EGR_VXLT_CAM_BIST_S5_STATUSr_CLR(r) (r).egr_vxlt_cam_bist_s5_status[0] = 0
#define BCM56504_A0_EGR_VXLT_CAM_BIST_S5_STATUSr_SET(r,d) (r).egr_vxlt_cam_bist_s5_status[0] = d
#define BCM56504_A0_EGR_VXLT_CAM_BIST_S5_STATUSr_GET(r) (r).egr_vxlt_cam_bist_s5_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_EGR_VXLT_CAM_BIST_S5_STATUSr_MATCH_STATUSf_GET(r) (((r).egr_vxlt_cam_bist_s5_status[0]) & 0x1)
#define BCM56504_A0_EGR_VXLT_CAM_BIST_S5_STATUSr_MATCH_STATUSf_SET(r,f) (r).egr_vxlt_cam_bist_s5_status[0]=(((r).egr_vxlt_cam_bist_s5_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_EGR_VXLT_CAM_BIST_S5_STATUSr_BIT_POSf_GET(r) ((((r).egr_vxlt_cam_bist_s5_status[0]) >> 1) & 0x1f)
#define BCM56504_A0_EGR_VXLT_CAM_BIST_S5_STATUSr_BIT_POSf_SET(r,f) (r).egr_vxlt_cam_bist_s5_status[0]=(((r).egr_vxlt_cam_bist_s5_status[0] & ~((uint32_t)0x1f << 1)) | ((((uint32_t)f) & 0x1f) << 1))
#define BCM56504_A0_EGR_VXLT_CAM_BIST_S5_STATUSr_AINDEXf_GET(r) ((((r).egr_vxlt_cam_bist_s5_status[0]) >> 6) & 0x3ff)
#define BCM56504_A0_EGR_VXLT_CAM_BIST_S5_STATUSr_AINDEXf_SET(r,f) (r).egr_vxlt_cam_bist_s5_status[0]=(((r).egr_vxlt_cam_bist_s5_status[0] & ~((uint32_t)0x3ff << 6)) | ((((uint32_t)f) & 0x3ff) << 6))

/*
 * These macros can be used to access EGR_VXLT_CAM_BIST_S5_STATUS.
 *
 */
#define BCM56504_A0_READ_EGR_VXLT_CAM_BIST_S5_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_EGR_VXLT_CAM_BIST_S5_STATUSr,(r._egr_vxlt_cam_bist_s5_status))
#define BCM56504_A0_WRITE_EGR_VXLT_CAM_BIST_S5_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_EGR_VXLT_CAM_BIST_S5_STATUSr,&(r._egr_vxlt_cam_bist_s5_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_VXLT_CAM_BIST_S5_STATUSr BCM56504_A0_EGR_VXLT_CAM_BIST_S5_STATUSr
#define EGR_VXLT_CAM_BIST_S5_STATUSr_SIZE BCM56504_A0_EGR_VXLT_CAM_BIST_S5_STATUSr_SIZE
typedef BCM56504_A0_EGR_VXLT_CAM_BIST_S5_STATUSr_t EGR_VXLT_CAM_BIST_S5_STATUSr_t;
#define EGR_VXLT_CAM_BIST_S5_STATUSr_CLR BCM56504_A0_EGR_VXLT_CAM_BIST_S5_STATUSr_CLR
#define EGR_VXLT_CAM_BIST_S5_STATUSr_SET BCM56504_A0_EGR_VXLT_CAM_BIST_S5_STATUSr_SET
#define EGR_VXLT_CAM_BIST_S5_STATUSr_GET BCM56504_A0_EGR_VXLT_CAM_BIST_S5_STATUSr_GET
#define EGR_VXLT_CAM_BIST_S5_STATUSr_MATCH_STATUSf_GET BCM56504_A0_EGR_VXLT_CAM_BIST_S5_STATUSr_MATCH_STATUSf_GET
#define EGR_VXLT_CAM_BIST_S5_STATUSr_MATCH_STATUSf_SET BCM56504_A0_EGR_VXLT_CAM_BIST_S5_STATUSr_MATCH_STATUSf_SET
#define EGR_VXLT_CAM_BIST_S5_STATUSr_BIT_POSf_GET BCM56504_A0_EGR_VXLT_CAM_BIST_S5_STATUSr_BIT_POSf_GET
#define EGR_VXLT_CAM_BIST_S5_STATUSr_BIT_POSf_SET BCM56504_A0_EGR_VXLT_CAM_BIST_S5_STATUSr_BIT_POSf_SET
#define EGR_VXLT_CAM_BIST_S5_STATUSr_AINDEXf_GET BCM56504_A0_EGR_VXLT_CAM_BIST_S5_STATUSr_AINDEXf_GET
#define EGR_VXLT_CAM_BIST_S5_STATUSr_AINDEXf_SET BCM56504_A0_EGR_VXLT_CAM_BIST_S5_STATUSr_AINDEXf_SET
#define READ_EGR_VXLT_CAM_BIST_S5_STATUSr BCM56504_A0_READ_EGR_VXLT_CAM_BIST_S5_STATUSr
#define WRITE_EGR_VXLT_CAM_BIST_S5_STATUSr BCM56504_A0_WRITE_EGR_VXLT_CAM_BIST_S5_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_EGR_VXLT_CAM_BIST_S5_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  EGR_VXLT_CAM_BIST_S6_STATUS
 * BLOCKS:   EPIPE
 * DESC:     EGR_VXLT_CAM_BIST_S6_STATUS
 * SIZE:     32
 * FIELDS:
 *     MATCH_STATUS     Match status
 *     AINDEX_STATUS    AIndex status
 *     ACTUAL_AINDEX    Actual AIndex when CAM reported a match
 *     EXPECTED_AINDEX  Expected AIndex
 *
 ******************************************************************************/
#define BCM56504_A0_EGR_VXLT_CAM_BIST_S6_STATUSr 0x05980005

#define BCM56504_A0_EGR_VXLT_CAM_BIST_S6_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program EGR_VXLT_CAM_BIST_S6_STATUS.
 *
 */
typedef union BCM56504_A0_EGR_VXLT_CAM_BIST_S6_STATUSr_s {
	uint32_t v[1];
	uint32_t egr_vxlt_cam_bist_s6_status[1];
	uint32_t _egr_vxlt_cam_bist_s6_status;
} BCM56504_A0_EGR_VXLT_CAM_BIST_S6_STATUSr_t;

#define BCM56504_A0_EGR_VXLT_CAM_BIST_S6_STATUSr_CLR(r) (r).egr_vxlt_cam_bist_s6_status[0] = 0
#define BCM56504_A0_EGR_VXLT_CAM_BIST_S6_STATUSr_SET(r,d) (r).egr_vxlt_cam_bist_s6_status[0] = d
#define BCM56504_A0_EGR_VXLT_CAM_BIST_S6_STATUSr_GET(r) (r).egr_vxlt_cam_bist_s6_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_EGR_VXLT_CAM_BIST_S6_STATUSr_MATCH_STATUSf_GET(r) (((r).egr_vxlt_cam_bist_s6_status[0]) & 0x1)
#define BCM56504_A0_EGR_VXLT_CAM_BIST_S6_STATUSr_MATCH_STATUSf_SET(r,f) (r).egr_vxlt_cam_bist_s6_status[0]=(((r).egr_vxlt_cam_bist_s6_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_EGR_VXLT_CAM_BIST_S6_STATUSr_AINDEX_STATUSf_GET(r) ((((r).egr_vxlt_cam_bist_s6_status[0]) >> 1) & 0x1)
#define BCM56504_A0_EGR_VXLT_CAM_BIST_S6_STATUSr_AINDEX_STATUSf_SET(r,f) (r).egr_vxlt_cam_bist_s6_status[0]=(((r).egr_vxlt_cam_bist_s6_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_EGR_VXLT_CAM_BIST_S6_STATUSr_ACTUAL_AINDEXf_GET(r) ((((r).egr_vxlt_cam_bist_s6_status[0]) >> 2) & 0x3ff)
#define BCM56504_A0_EGR_VXLT_CAM_BIST_S6_STATUSr_ACTUAL_AINDEXf_SET(r,f) (r).egr_vxlt_cam_bist_s6_status[0]=(((r).egr_vxlt_cam_bist_s6_status[0] & ~((uint32_t)0x3ff << 2)) | ((((uint32_t)f) & 0x3ff) << 2))
#define BCM56504_A0_EGR_VXLT_CAM_BIST_S6_STATUSr_EXPECTED_AINDEXf_GET(r) ((((r).egr_vxlt_cam_bist_s6_status[0]) >> 12) & 0x3ff)
#define BCM56504_A0_EGR_VXLT_CAM_BIST_S6_STATUSr_EXPECTED_AINDEXf_SET(r,f) (r).egr_vxlt_cam_bist_s6_status[0]=(((r).egr_vxlt_cam_bist_s6_status[0] & ~((uint32_t)0x3ff << 12)) | ((((uint32_t)f) & 0x3ff) << 12))

/*
 * These macros can be used to access EGR_VXLT_CAM_BIST_S6_STATUS.
 *
 */
#define BCM56504_A0_READ_EGR_VXLT_CAM_BIST_S6_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_EGR_VXLT_CAM_BIST_S6_STATUSr,(r._egr_vxlt_cam_bist_s6_status))
#define BCM56504_A0_WRITE_EGR_VXLT_CAM_BIST_S6_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_EGR_VXLT_CAM_BIST_S6_STATUSr,&(r._egr_vxlt_cam_bist_s6_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_VXLT_CAM_BIST_S6_STATUSr BCM56504_A0_EGR_VXLT_CAM_BIST_S6_STATUSr
#define EGR_VXLT_CAM_BIST_S6_STATUSr_SIZE BCM56504_A0_EGR_VXLT_CAM_BIST_S6_STATUSr_SIZE
typedef BCM56504_A0_EGR_VXLT_CAM_BIST_S6_STATUSr_t EGR_VXLT_CAM_BIST_S6_STATUSr_t;
#define EGR_VXLT_CAM_BIST_S6_STATUSr_CLR BCM56504_A0_EGR_VXLT_CAM_BIST_S6_STATUSr_CLR
#define EGR_VXLT_CAM_BIST_S6_STATUSr_SET BCM56504_A0_EGR_VXLT_CAM_BIST_S6_STATUSr_SET
#define EGR_VXLT_CAM_BIST_S6_STATUSr_GET BCM56504_A0_EGR_VXLT_CAM_BIST_S6_STATUSr_GET
#define EGR_VXLT_CAM_BIST_S6_STATUSr_MATCH_STATUSf_GET BCM56504_A0_EGR_VXLT_CAM_BIST_S6_STATUSr_MATCH_STATUSf_GET
#define EGR_VXLT_CAM_BIST_S6_STATUSr_MATCH_STATUSf_SET BCM56504_A0_EGR_VXLT_CAM_BIST_S6_STATUSr_MATCH_STATUSf_SET
#define EGR_VXLT_CAM_BIST_S6_STATUSr_AINDEX_STATUSf_GET BCM56504_A0_EGR_VXLT_CAM_BIST_S6_STATUSr_AINDEX_STATUSf_GET
#define EGR_VXLT_CAM_BIST_S6_STATUSr_AINDEX_STATUSf_SET BCM56504_A0_EGR_VXLT_CAM_BIST_S6_STATUSr_AINDEX_STATUSf_SET
#define EGR_VXLT_CAM_BIST_S6_STATUSr_ACTUAL_AINDEXf_GET BCM56504_A0_EGR_VXLT_CAM_BIST_S6_STATUSr_ACTUAL_AINDEXf_GET
#define EGR_VXLT_CAM_BIST_S6_STATUSr_ACTUAL_AINDEXf_SET BCM56504_A0_EGR_VXLT_CAM_BIST_S6_STATUSr_ACTUAL_AINDEXf_SET
#define EGR_VXLT_CAM_BIST_S6_STATUSr_EXPECTED_AINDEXf_GET BCM56504_A0_EGR_VXLT_CAM_BIST_S6_STATUSr_EXPECTED_AINDEXf_GET
#define EGR_VXLT_CAM_BIST_S6_STATUSr_EXPECTED_AINDEXf_SET BCM56504_A0_EGR_VXLT_CAM_BIST_S6_STATUSr_EXPECTED_AINDEXf_SET
#define READ_EGR_VXLT_CAM_BIST_S6_STATUSr BCM56504_A0_READ_EGR_VXLT_CAM_BIST_S6_STATUSr
#define WRITE_EGR_VXLT_CAM_BIST_S6_STATUSr BCM56504_A0_WRITE_EGR_VXLT_CAM_BIST_S6_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_EGR_VXLT_CAM_BIST_S6_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  EGR_VXLT_CAM_BIST_S8_STATUS
 * BLOCKS:   EPIPE
 * DESC:     EGR_VXLT_CAM_BIST_S8_STATUS
 * SIZE:     32
 * FIELDS:
 *     MATCH_STATUS     Match status
 *     AINDEX           Aindex when match happened
 *
 ******************************************************************************/
#define BCM56504_A0_EGR_VXLT_CAM_BIST_S8_STATUSr 0x05980006

#define BCM56504_A0_EGR_VXLT_CAM_BIST_S8_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program EGR_VXLT_CAM_BIST_S8_STATUS.
 *
 */
typedef union BCM56504_A0_EGR_VXLT_CAM_BIST_S8_STATUSr_s {
	uint32_t v[1];
	uint32_t egr_vxlt_cam_bist_s8_status[1];
	uint32_t _egr_vxlt_cam_bist_s8_status;
} BCM56504_A0_EGR_VXLT_CAM_BIST_S8_STATUSr_t;

#define BCM56504_A0_EGR_VXLT_CAM_BIST_S8_STATUSr_CLR(r) (r).egr_vxlt_cam_bist_s8_status[0] = 0
#define BCM56504_A0_EGR_VXLT_CAM_BIST_S8_STATUSr_SET(r,d) (r).egr_vxlt_cam_bist_s8_status[0] = d
#define BCM56504_A0_EGR_VXLT_CAM_BIST_S8_STATUSr_GET(r) (r).egr_vxlt_cam_bist_s8_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_EGR_VXLT_CAM_BIST_S8_STATUSr_MATCH_STATUSf_GET(r) (((r).egr_vxlt_cam_bist_s8_status[0]) & 0x1)
#define BCM56504_A0_EGR_VXLT_CAM_BIST_S8_STATUSr_MATCH_STATUSf_SET(r,f) (r).egr_vxlt_cam_bist_s8_status[0]=(((r).egr_vxlt_cam_bist_s8_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_EGR_VXLT_CAM_BIST_S8_STATUSr_AINDEXf_GET(r) ((((r).egr_vxlt_cam_bist_s8_status[0]) >> 1) & 0x3ff)
#define BCM56504_A0_EGR_VXLT_CAM_BIST_S8_STATUSr_AINDEXf_SET(r,f) (r).egr_vxlt_cam_bist_s8_status[0]=(((r).egr_vxlt_cam_bist_s8_status[0] & ~((uint32_t)0x3ff << 1)) | ((((uint32_t)f) & 0x3ff) << 1))

/*
 * These macros can be used to access EGR_VXLT_CAM_BIST_S8_STATUS.
 *
 */
#define BCM56504_A0_READ_EGR_VXLT_CAM_BIST_S8_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_EGR_VXLT_CAM_BIST_S8_STATUSr,(r._egr_vxlt_cam_bist_s8_status))
#define BCM56504_A0_WRITE_EGR_VXLT_CAM_BIST_S8_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_EGR_VXLT_CAM_BIST_S8_STATUSr,&(r._egr_vxlt_cam_bist_s8_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_VXLT_CAM_BIST_S8_STATUSr BCM56504_A0_EGR_VXLT_CAM_BIST_S8_STATUSr
#define EGR_VXLT_CAM_BIST_S8_STATUSr_SIZE BCM56504_A0_EGR_VXLT_CAM_BIST_S8_STATUSr_SIZE
typedef BCM56504_A0_EGR_VXLT_CAM_BIST_S8_STATUSr_t EGR_VXLT_CAM_BIST_S8_STATUSr_t;
#define EGR_VXLT_CAM_BIST_S8_STATUSr_CLR BCM56504_A0_EGR_VXLT_CAM_BIST_S8_STATUSr_CLR
#define EGR_VXLT_CAM_BIST_S8_STATUSr_SET BCM56504_A0_EGR_VXLT_CAM_BIST_S8_STATUSr_SET
#define EGR_VXLT_CAM_BIST_S8_STATUSr_GET BCM56504_A0_EGR_VXLT_CAM_BIST_S8_STATUSr_GET
#define EGR_VXLT_CAM_BIST_S8_STATUSr_MATCH_STATUSf_GET BCM56504_A0_EGR_VXLT_CAM_BIST_S8_STATUSr_MATCH_STATUSf_GET
#define EGR_VXLT_CAM_BIST_S8_STATUSr_MATCH_STATUSf_SET BCM56504_A0_EGR_VXLT_CAM_BIST_S8_STATUSr_MATCH_STATUSf_SET
#define EGR_VXLT_CAM_BIST_S8_STATUSr_AINDEXf_GET BCM56504_A0_EGR_VXLT_CAM_BIST_S8_STATUSr_AINDEXf_GET
#define EGR_VXLT_CAM_BIST_S8_STATUSr_AINDEXf_SET BCM56504_A0_EGR_VXLT_CAM_BIST_S8_STATUSr_AINDEXf_SET
#define READ_EGR_VXLT_CAM_BIST_S8_STATUSr BCM56504_A0_READ_EGR_VXLT_CAM_BIST_S8_STATUSr
#define WRITE_EGR_VXLT_CAM_BIST_S8_STATUSr BCM56504_A0_WRITE_EGR_VXLT_CAM_BIST_S8_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_EGR_VXLT_CAM_BIST_S8_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  EGR_VXLT_CAM_BIST_STATUS
 * BLOCKS:   EPIPE
 * DESC:     EGR_VXLT_CAM_BIST_STATUS
 * SIZE:     32
 * FIELDS:
 *     BIST_GO          BIST pass/fail flag
 *     BIST_DONE        BIST completion status
 *
 ******************************************************************************/
#define BCM56504_A0_EGR_VXLT_CAM_BIST_STATUSr 0x05980001

#define BCM56504_A0_EGR_VXLT_CAM_BIST_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program EGR_VXLT_CAM_BIST_STATUS.
 *
 */
typedef union BCM56504_A0_EGR_VXLT_CAM_BIST_STATUSr_s {
	uint32_t v[1];
	uint32_t egr_vxlt_cam_bist_status[1];
	uint32_t _egr_vxlt_cam_bist_status;
} BCM56504_A0_EGR_VXLT_CAM_BIST_STATUSr_t;

#define BCM56504_A0_EGR_VXLT_CAM_BIST_STATUSr_CLR(r) (r).egr_vxlt_cam_bist_status[0] = 0
#define BCM56504_A0_EGR_VXLT_CAM_BIST_STATUSr_SET(r,d) (r).egr_vxlt_cam_bist_status[0] = d
#define BCM56504_A0_EGR_VXLT_CAM_BIST_STATUSr_GET(r) (r).egr_vxlt_cam_bist_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_EGR_VXLT_CAM_BIST_STATUSr_BIST_GOf_GET(r) (((r).egr_vxlt_cam_bist_status[0]) & 0x1)
#define BCM56504_A0_EGR_VXLT_CAM_BIST_STATUSr_BIST_GOf_SET(r,f) (r).egr_vxlt_cam_bist_status[0]=(((r).egr_vxlt_cam_bist_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_EGR_VXLT_CAM_BIST_STATUSr_BIST_DONEf_GET(r) ((((r).egr_vxlt_cam_bist_status[0]) >> 1) & 0x1)
#define BCM56504_A0_EGR_VXLT_CAM_BIST_STATUSr_BIST_DONEf_SET(r,f) (r).egr_vxlt_cam_bist_status[0]=(((r).egr_vxlt_cam_bist_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access EGR_VXLT_CAM_BIST_STATUS.
 *
 */
#define BCM56504_A0_READ_EGR_VXLT_CAM_BIST_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_EGR_VXLT_CAM_BIST_STATUSr,(r._egr_vxlt_cam_bist_status))
#define BCM56504_A0_WRITE_EGR_VXLT_CAM_BIST_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_EGR_VXLT_CAM_BIST_STATUSr,&(r._egr_vxlt_cam_bist_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_VXLT_CAM_BIST_STATUSr BCM56504_A0_EGR_VXLT_CAM_BIST_STATUSr
#define EGR_VXLT_CAM_BIST_STATUSr_SIZE BCM56504_A0_EGR_VXLT_CAM_BIST_STATUSr_SIZE
typedef BCM56504_A0_EGR_VXLT_CAM_BIST_STATUSr_t EGR_VXLT_CAM_BIST_STATUSr_t;
#define EGR_VXLT_CAM_BIST_STATUSr_CLR BCM56504_A0_EGR_VXLT_CAM_BIST_STATUSr_CLR
#define EGR_VXLT_CAM_BIST_STATUSr_SET BCM56504_A0_EGR_VXLT_CAM_BIST_STATUSr_SET
#define EGR_VXLT_CAM_BIST_STATUSr_GET BCM56504_A0_EGR_VXLT_CAM_BIST_STATUSr_GET
#define EGR_VXLT_CAM_BIST_STATUSr_BIST_GOf_GET BCM56504_A0_EGR_VXLT_CAM_BIST_STATUSr_BIST_GOf_GET
#define EGR_VXLT_CAM_BIST_STATUSr_BIST_GOf_SET BCM56504_A0_EGR_VXLT_CAM_BIST_STATUSr_BIST_GOf_SET
#define EGR_VXLT_CAM_BIST_STATUSr_BIST_DONEf_GET BCM56504_A0_EGR_VXLT_CAM_BIST_STATUSr_BIST_DONEf_GET
#define EGR_VXLT_CAM_BIST_STATUSr_BIST_DONEf_SET BCM56504_A0_EGR_VXLT_CAM_BIST_STATUSr_BIST_DONEf_SET
#define READ_EGR_VXLT_CAM_BIST_STATUSr BCM56504_A0_READ_EGR_VXLT_CAM_BIST_STATUSr
#define WRITE_EGR_VXLT_CAM_BIST_STATUSr BCM56504_A0_WRITE_EGR_VXLT_CAM_BIST_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_EGR_VXLT_CAM_BIST_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  EGR_VXLT_CAM_CONTROL
 * BLOCKS:   EPIPE
 * DESC:     EGR_VXLT_CAM_CONTROL
 * SIZE:     32
 * FIELDS:
 *     BIST_EN          BIST_EN enable
 *     SAM              Tied to the SAM bits of the CAM.
 *
 ******************************************************************************/
#define BCM56504_A0_EGR_VXLT_CAM_CONTROLr 0x05980000

#define BCM56504_A0_EGR_VXLT_CAM_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program EGR_VXLT_CAM_CONTROL.
 *
 */
typedef union BCM56504_A0_EGR_VXLT_CAM_CONTROLr_s {
	uint32_t v[1];
	uint32_t egr_vxlt_cam_control[1];
	uint32_t _egr_vxlt_cam_control;
} BCM56504_A0_EGR_VXLT_CAM_CONTROLr_t;

#define BCM56504_A0_EGR_VXLT_CAM_CONTROLr_CLR(r) (r).egr_vxlt_cam_control[0] = 0
#define BCM56504_A0_EGR_VXLT_CAM_CONTROLr_SET(r,d) (r).egr_vxlt_cam_control[0] = d
#define BCM56504_A0_EGR_VXLT_CAM_CONTROLr_GET(r) (r).egr_vxlt_cam_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_EGR_VXLT_CAM_CONTROLr_BIST_ENf_GET(r) (((r).egr_vxlt_cam_control[0]) & 0x1)
#define BCM56504_A0_EGR_VXLT_CAM_CONTROLr_BIST_ENf_SET(r,f) (r).egr_vxlt_cam_control[0]=(((r).egr_vxlt_cam_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_EGR_VXLT_CAM_CONTROLr_SAMf_GET(r) ((((r).egr_vxlt_cam_control[0]) >> 1) & 0x7)
#define BCM56504_A0_EGR_VXLT_CAM_CONTROLr_SAMf_SET(r,f) (r).egr_vxlt_cam_control[0]=(((r).egr_vxlt_cam_control[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))

/*
 * These macros can be used to access EGR_VXLT_CAM_CONTROL.
 *
 */
#define BCM56504_A0_READ_EGR_VXLT_CAM_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_EGR_VXLT_CAM_CONTROLr,(r._egr_vxlt_cam_control))
#define BCM56504_A0_WRITE_EGR_VXLT_CAM_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_EGR_VXLT_CAM_CONTROLr,&(r._egr_vxlt_cam_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_VXLT_CAM_CONTROLr BCM56504_A0_EGR_VXLT_CAM_CONTROLr
#define EGR_VXLT_CAM_CONTROLr_SIZE BCM56504_A0_EGR_VXLT_CAM_CONTROLr_SIZE
typedef BCM56504_A0_EGR_VXLT_CAM_CONTROLr_t EGR_VXLT_CAM_CONTROLr_t;
#define EGR_VXLT_CAM_CONTROLr_CLR BCM56504_A0_EGR_VXLT_CAM_CONTROLr_CLR
#define EGR_VXLT_CAM_CONTROLr_SET BCM56504_A0_EGR_VXLT_CAM_CONTROLr_SET
#define EGR_VXLT_CAM_CONTROLr_GET BCM56504_A0_EGR_VXLT_CAM_CONTROLr_GET
#define EGR_VXLT_CAM_CONTROLr_BIST_ENf_GET BCM56504_A0_EGR_VXLT_CAM_CONTROLr_BIST_ENf_GET
#define EGR_VXLT_CAM_CONTROLr_BIST_ENf_SET BCM56504_A0_EGR_VXLT_CAM_CONTROLr_BIST_ENf_SET
#define EGR_VXLT_CAM_CONTROLr_SAMf_GET BCM56504_A0_EGR_VXLT_CAM_CONTROLr_SAMf_GET
#define EGR_VXLT_CAM_CONTROLr_SAMf_SET BCM56504_A0_EGR_VXLT_CAM_CONTROLr_SAMf_SET
#define READ_EGR_VXLT_CAM_CONTROLr BCM56504_A0_READ_EGR_VXLT_CAM_CONTROLr
#define WRITE_EGR_VXLT_CAM_CONTROLr BCM56504_A0_WRITE_EGR_VXLT_CAM_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_EGR_VXLT_CAM_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  EMIRROR_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     Egress mirror bitmap register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           Egress mirror bitmap
 *
 ******************************************************************************/
#define BCM56504_A0_EMIRROR_CONTROLr 0x0e700105

#define BCM56504_A0_EMIRROR_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program EMIRROR_CONTROL.
 *
 */
typedef union BCM56504_A0_EMIRROR_CONTROLr_s {
	uint32_t v[1];
	uint32_t emirror_control[1];
	uint32_t _emirror_control;
} BCM56504_A0_EMIRROR_CONTROLr_t;

#define BCM56504_A0_EMIRROR_CONTROLr_CLR(r) (r).emirror_control[0] = 0
#define BCM56504_A0_EMIRROR_CONTROLr_SET(r,d) (r).emirror_control[0] = d
#define BCM56504_A0_EMIRROR_CONTROLr_GET(r) (r).emirror_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_EMIRROR_CONTROLr_BITMAPf_GET(r) (((r).emirror_control[0]) & 0x1fffffff)
#define BCM56504_A0_EMIRROR_CONTROLr_BITMAPf_SET(r,f) (r).emirror_control[0]=(((r).emirror_control[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))

/*
 * These macros can be used to access EMIRROR_CONTROL.
 *
 */
#define BCM56504_A0_READ_EMIRROR_CONTROLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_EMIRROR_CONTROLr,(r._emirror_control))
#define BCM56504_A0_WRITE_EMIRROR_CONTROLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_EMIRROR_CONTROLr,&(r._emirror_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EMIRROR_CONTROLr BCM56504_A0_EMIRROR_CONTROLr
#define EMIRROR_CONTROLr_SIZE BCM56504_A0_EMIRROR_CONTROLr_SIZE
typedef BCM56504_A0_EMIRROR_CONTROLr_t EMIRROR_CONTROLr_t;
#define EMIRROR_CONTROLr_CLR BCM56504_A0_EMIRROR_CONTROLr_CLR
#define EMIRROR_CONTROLr_SET BCM56504_A0_EMIRROR_CONTROLr_SET
#define EMIRROR_CONTROLr_GET BCM56504_A0_EMIRROR_CONTROLr_GET
#define EMIRROR_CONTROLr_BITMAPf_GET BCM56504_A0_EMIRROR_CONTROLr_BITMAPf_GET
#define EMIRROR_CONTROLr_BITMAPf_SET BCM56504_A0_EMIRROR_CONTROLr_BITMAPf_SET
#define READ_EMIRROR_CONTROLr BCM56504_A0_READ_EMIRROR_CONTROLr
#define WRITE_EMIRROR_CONTROLr BCM56504_A0_WRITE_EMIRROR_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_EMIRROR_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  EM_MTP_INDEX
 * BLOCKS:   IPIPE
 * DESC:     Egress Mirror to Port Table
 * SIZE:     12
 * FIELDS:
 *     PORT_TGID        Mirror to port port/TGID
 *     MODULE_ID        Mirror to port module ID
 *
 ******************************************************************************/
#define BCM56504_A0_EM_MTP_INDEXm 0x0e790000

#define BCM56504_A0_EM_MTP_INDEXm_MIN 0
#define BCM56504_A0_EM_MTP_INDEXm_MAX 3
#define BCM56504_A0_EM_MTP_INDEXm_CMAX(u) 3
#define BCM56504_A0_EM_MTP_INDEXm_SIZE 2

/*
 * This structure should be used to declare and program EM_MTP_INDEX.
 *
 */
typedef union BCM56504_A0_EM_MTP_INDEXm_s {
	uint32_t v[1];
	uint32_t em_mtp_index[1];
	uint32_t _em_mtp_index;
} BCM56504_A0_EM_MTP_INDEXm_t;

#define BCM56504_A0_EM_MTP_INDEXm_CLR(r) (r).em_mtp_index[0] = 0
#define BCM56504_A0_EM_MTP_INDEXm_SET(r,d) (r).em_mtp_index[0] = d
#define BCM56504_A0_EM_MTP_INDEXm_GET(r) (r).em_mtp_index[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_EM_MTP_INDEXm_PORT_TGIDf_GET(r) (((r).em_mtp_index[0]) & 0x3f)
#define BCM56504_A0_EM_MTP_INDEXm_PORT_TGIDf_SET(r,f) (r).em_mtp_index[0]=(((r).em_mtp_index[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM56504_A0_EM_MTP_INDEXm_MODULE_IDf_GET(r) ((((r).em_mtp_index[0]) >> 6) & 0x3f)
#define BCM56504_A0_EM_MTP_INDEXm_MODULE_IDf_SET(r,f) (r).em_mtp_index[0]=(((r).em_mtp_index[0] & ~((uint32_t)0x3f << 6)) | ((((uint32_t)f) & 0x3f) << 6))

/*
 * These macros can be used to access EM_MTP_INDEX.
 *
 */
#define BCM56504_A0_READ_EM_MTP_INDEXm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_EM_MTP_INDEXm,i,(m._em_mtp_index),1)
#define BCM56504_A0_WRITE_EM_MTP_INDEXm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_EM_MTP_INDEXm,i,&(m._em_mtp_index),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EM_MTP_INDEXm BCM56504_A0_EM_MTP_INDEXm
#define EM_MTP_INDEXm_MIN BCM56504_A0_EM_MTP_INDEXm_MIN
#define EM_MTP_INDEXm_MAX BCM56504_A0_EM_MTP_INDEXm_MAX
#define EM_MTP_INDEXm_CMAX(u) BCM56504_A0_EM_MTP_INDEXm_CMAX(u)
#define EM_MTP_INDEXm_SIZE BCM56504_A0_EM_MTP_INDEXm_SIZE
typedef BCM56504_A0_EM_MTP_INDEXm_t EM_MTP_INDEXm_t;
#define EM_MTP_INDEXm_CLR BCM56504_A0_EM_MTP_INDEXm_CLR
#define EM_MTP_INDEXm_SET BCM56504_A0_EM_MTP_INDEXm_SET
#define EM_MTP_INDEXm_GET BCM56504_A0_EM_MTP_INDEXm_GET
#define EM_MTP_INDEXm_PORT_TGIDf_GET BCM56504_A0_EM_MTP_INDEXm_PORT_TGIDf_GET
#define EM_MTP_INDEXm_PORT_TGIDf_SET BCM56504_A0_EM_MTP_INDEXm_PORT_TGIDf_SET
#define EM_MTP_INDEXm_MODULE_IDf_GET BCM56504_A0_EM_MTP_INDEXm_MODULE_IDf_GET
#define EM_MTP_INDEXm_MODULE_IDf_SET BCM56504_A0_EM_MTP_INDEXm_MODULE_IDf_SET
#define READ_EM_MTP_INDEXm BCM56504_A0_READ_EM_MTP_INDEXm
#define WRITE_EM_MTP_INDEXm BCM56504_A0_WRITE_EM_MTP_INDEXm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_EM_MTP_INDEXm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  EPC_LINK_BMAP
 * BLOCKS:   IPIPE
 * DESC:     Link status register
 * SIZE:     32
 * FIELDS:
 *     PORT_BITMAP      Link status bitmap 
 *
 ******************************************************************************/
#define BCM56504_A0_EPC_LINK_BMAPr 0x0e78010b

#define BCM56504_A0_EPC_LINK_BMAPr_SIZE 4

/*
 * This structure should be used to declare and program EPC_LINK_BMAP.
 *
 */
typedef union BCM56504_A0_EPC_LINK_BMAPr_s {
	uint32_t v[1];
	uint32_t epc_link_bmap[1];
	uint32_t _epc_link_bmap;
} BCM56504_A0_EPC_LINK_BMAPr_t;

#define BCM56504_A0_EPC_LINK_BMAPr_CLR(r) (r).epc_link_bmap[0] = 0
#define BCM56504_A0_EPC_LINK_BMAPr_SET(r,d) (r).epc_link_bmap[0] = d
#define BCM56504_A0_EPC_LINK_BMAPr_GET(r) (r).epc_link_bmap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_EPC_LINK_BMAPr_PORT_BITMAPf_GET(r) (((r).epc_link_bmap[0]) & 0x1fffffff)
#define BCM56504_A0_EPC_LINK_BMAPr_PORT_BITMAPf_SET(r,f) (r).epc_link_bmap[0]=(((r).epc_link_bmap[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))

/*
 * These macros can be used to access EPC_LINK_BMAP.
 *
 */
#define BCM56504_A0_READ_EPC_LINK_BMAPr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_EPC_LINK_BMAPr,(r._epc_link_bmap))
#define BCM56504_A0_WRITE_EPC_LINK_BMAPr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_EPC_LINK_BMAPr,&(r._epc_link_bmap))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EPC_LINK_BMAPr BCM56504_A0_EPC_LINK_BMAPr
#define EPC_LINK_BMAPr_SIZE BCM56504_A0_EPC_LINK_BMAPr_SIZE
typedef BCM56504_A0_EPC_LINK_BMAPr_t EPC_LINK_BMAPr_t;
#define EPC_LINK_BMAPr_CLR BCM56504_A0_EPC_LINK_BMAPr_CLR
#define EPC_LINK_BMAPr_SET BCM56504_A0_EPC_LINK_BMAPr_SET
#define EPC_LINK_BMAPr_GET BCM56504_A0_EPC_LINK_BMAPr_GET
#define EPC_LINK_BMAPr_PORT_BITMAPf_GET BCM56504_A0_EPC_LINK_BMAPr_PORT_BITMAPf_GET
#define EPC_LINK_BMAPr_PORT_BITMAPf_SET BCM56504_A0_EPC_LINK_BMAPr_PORT_BITMAPf_SET
#define READ_EPC_LINK_BMAPr BCM56504_A0_READ_EPC_LINK_BMAPr
#define WRITE_EPC_LINK_BMAPr BCM56504_A0_WRITE_EPC_LINK_BMAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_EPC_LINK_BMAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  ESA0
 * BLOCKS:   GPORT0
 * DESC:     Station Adress[15:0]
 * SIZE:     32
 * FIELDS:
 *     STAD0            Station Address [15:0]
 *
 ******************************************************************************/
#define BCM56504_A0_ESA0r 0x00f00210

#define BCM56504_A0_ESA0r_SIZE 4

/*
 * This structure should be used to declare and program ESA0.
 *
 */
typedef union BCM56504_A0_ESA0r_s {
	uint32_t v[1];
	uint32_t esa0[1];
	uint32_t _esa0;
} BCM56504_A0_ESA0r_t;

#define BCM56504_A0_ESA0r_CLR(r) (r).esa0[0] = 0
#define BCM56504_A0_ESA0r_SET(r,d) (r).esa0[0] = d
#define BCM56504_A0_ESA0r_GET(r) (r).esa0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_ESA0r_STAD0f_GET(r) (((r).esa0[0]) & 0xffff)
#define BCM56504_A0_ESA0r_STAD0f_SET(r,f) (r).esa0[0]=(((r).esa0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access ESA0.
 *
 */
#define BCM56504_A0_READ_ESA0r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_ESA0r,(r._esa0))
#define BCM56504_A0_WRITE_ESA0r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_ESA0r,&(r._esa0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ESA0r BCM56504_A0_ESA0r
#define ESA0r_SIZE BCM56504_A0_ESA0r_SIZE
typedef BCM56504_A0_ESA0r_t ESA0r_t;
#define ESA0r_CLR BCM56504_A0_ESA0r_CLR
#define ESA0r_SET BCM56504_A0_ESA0r_SET
#define ESA0r_GET BCM56504_A0_ESA0r_GET
#define ESA0r_STAD0f_GET BCM56504_A0_ESA0r_STAD0f_GET
#define ESA0r_STAD0f_SET BCM56504_A0_ESA0r_STAD0f_SET
#define READ_ESA0r BCM56504_A0_READ_ESA0r
#define WRITE_ESA0r BCM56504_A0_WRITE_ESA0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_ESA0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  ESA1
 * BLOCKS:   GPORT0
 * DESC:     Station Adress[31:16]
 * SIZE:     32
 * FIELDS:
 *     STAD0            Station Address [31:16]
 *
 ******************************************************************************/
#define BCM56504_A0_ESA1r 0x00f00211

#define BCM56504_A0_ESA1r_SIZE 4

/*
 * This structure should be used to declare and program ESA1.
 *
 */
typedef union BCM56504_A0_ESA1r_s {
	uint32_t v[1];
	uint32_t esa1[1];
	uint32_t _esa1;
} BCM56504_A0_ESA1r_t;

#define BCM56504_A0_ESA1r_CLR(r) (r).esa1[0] = 0
#define BCM56504_A0_ESA1r_SET(r,d) (r).esa1[0] = d
#define BCM56504_A0_ESA1r_GET(r) (r).esa1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_ESA1r_STAD0f_GET(r) (((r).esa1[0]) & 0xffff)
#define BCM56504_A0_ESA1r_STAD0f_SET(r,f) (r).esa1[0]=(((r).esa1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access ESA1.
 *
 */
#define BCM56504_A0_READ_ESA1r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_ESA1r,(r._esa1))
#define BCM56504_A0_WRITE_ESA1r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_ESA1r,&(r._esa1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ESA1r BCM56504_A0_ESA1r
#define ESA1r_SIZE BCM56504_A0_ESA1r_SIZE
typedef BCM56504_A0_ESA1r_t ESA1r_t;
#define ESA1r_CLR BCM56504_A0_ESA1r_CLR
#define ESA1r_SET BCM56504_A0_ESA1r_SET
#define ESA1r_GET BCM56504_A0_ESA1r_GET
#define ESA1r_STAD0f_GET BCM56504_A0_ESA1r_STAD0f_GET
#define ESA1r_STAD0f_SET BCM56504_A0_ESA1r_STAD0f_SET
#define READ_ESA1r BCM56504_A0_READ_ESA1r
#define WRITE_ESA1r BCM56504_A0_WRITE_ESA1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_ESA1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  ESA2
 * BLOCKS:   GPORT0
 * DESC:     Station Adress[47:32]
 * SIZE:     32
 * FIELDS:
 *     STAD0            Station Address [47:32]
 *
 ******************************************************************************/
#define BCM56504_A0_ESA2r 0x00f00212

#define BCM56504_A0_ESA2r_SIZE 4

/*
 * This structure should be used to declare and program ESA2.
 *
 */
typedef union BCM56504_A0_ESA2r_s {
	uint32_t v[1];
	uint32_t esa2[1];
	uint32_t _esa2;
} BCM56504_A0_ESA2r_t;

#define BCM56504_A0_ESA2r_CLR(r) (r).esa2[0] = 0
#define BCM56504_A0_ESA2r_SET(r,d) (r).esa2[0] = d
#define BCM56504_A0_ESA2r_GET(r) (r).esa2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_ESA2r_STAD0f_GET(r) (((r).esa2[0]) & 0xffff)
#define BCM56504_A0_ESA2r_STAD0f_SET(r,f) (r).esa2[0]=(((r).esa2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access ESA2.
 *
 */
#define BCM56504_A0_READ_ESA2r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_ESA2r,(r._esa2))
#define BCM56504_A0_WRITE_ESA2r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_ESA2r,&(r._esa2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ESA2r BCM56504_A0_ESA2r
#define ESA2r_SIZE BCM56504_A0_ESA2r_SIZE
typedef BCM56504_A0_ESA2r_t ESA2r_t;
#define ESA2r_CLR BCM56504_A0_ESA2r_CLR
#define ESA2r_SET BCM56504_A0_ESA2r_SET
#define ESA2r_GET BCM56504_A0_ESA2r_GET
#define ESA2r_STAD0f_GET BCM56504_A0_ESA2r_STAD0f_GET
#define ESA2r_STAD0f_SET BCM56504_A0_ESA2r_STAD0f_SET
#define READ_ESA2r BCM56504_A0_READ_ESA2r
#define WRITE_ESA2r BCM56504_A0_WRITE_ESA2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_ESA2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  FE_CLRT
 * BLOCKS:   GPORT0
 * DESC:     Fast Ethernet Collision Window/Retry Register.
 * SIZE:     32
 * FIELDS:
 *     RETRY            Number of retransmit attempts before aborting due to excessive collisions 
 *     COL_WIN          Slot time or collision window during which collisions occur
 *
 ******************************************************************************/
#define BCM56504_A0_FE_CLRTr 0x00f00204

#define BCM56504_A0_FE_CLRTr_SIZE 4

/*
 * This structure should be used to declare and program FE_CLRT.
 *
 */
typedef union BCM56504_A0_FE_CLRTr_s {
	uint32_t v[1];
	uint32_t fe_clrt[1];
	uint32_t _fe_clrt;
} BCM56504_A0_FE_CLRTr_t;

#define BCM56504_A0_FE_CLRTr_CLR(r) (r).fe_clrt[0] = 0
#define BCM56504_A0_FE_CLRTr_SET(r,d) (r).fe_clrt[0] = d
#define BCM56504_A0_FE_CLRTr_GET(r) (r).fe_clrt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_FE_CLRTr_RETRYf_GET(r) (((r).fe_clrt[0]) & 0xf)
#define BCM56504_A0_FE_CLRTr_RETRYf_SET(r,f) (r).fe_clrt[0]=(((r).fe_clrt[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56504_A0_FE_CLRTr_COL_WINf_GET(r) ((((r).fe_clrt[0]) >> 8) & 0x3f)
#define BCM56504_A0_FE_CLRTr_COL_WINf_SET(r,f) (r).fe_clrt[0]=(((r).fe_clrt[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))

/*
 * These macros can be used to access FE_CLRT.
 *
 */
#define BCM56504_A0_READ_FE_CLRTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_FE_CLRTr,(r._fe_clrt))
#define BCM56504_A0_WRITE_FE_CLRTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_FE_CLRTr,&(r._fe_clrt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FE_CLRTr BCM56504_A0_FE_CLRTr
#define FE_CLRTr_SIZE BCM56504_A0_FE_CLRTr_SIZE
typedef BCM56504_A0_FE_CLRTr_t FE_CLRTr_t;
#define FE_CLRTr_CLR BCM56504_A0_FE_CLRTr_CLR
#define FE_CLRTr_SET BCM56504_A0_FE_CLRTr_SET
#define FE_CLRTr_GET BCM56504_A0_FE_CLRTr_GET
#define FE_CLRTr_RETRYf_GET BCM56504_A0_FE_CLRTr_RETRYf_GET
#define FE_CLRTr_RETRYf_SET BCM56504_A0_FE_CLRTr_RETRYf_SET
#define FE_CLRTr_COL_WINf_GET BCM56504_A0_FE_CLRTr_COL_WINf_GET
#define FE_CLRTr_COL_WINf_SET BCM56504_A0_FE_CLRTr_COL_WINf_SET
#define READ_FE_CLRTr BCM56504_A0_READ_FE_CLRTr
#define WRITE_FE_CLRTr BCM56504_A0_WRITE_FE_CLRTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_FE_CLRTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  FE_EXCESSIVE_DEFER_LIMIT
 * BLOCKS:   GPORT0
 * DESC:     Fast Ethernet Excessive Deferral Limit Register
 * SIZE:     32
 * FIELDS:
 *     LIMIT            Excessive Deferral Limit Value (programmed to (4*MAX_FRAME-1)If FE_SUPP.BIT_MODE is set to 1'b1, then this register should be programmed to 16*(MAX_FRAME)-1
 *
 ******************************************************************************/
#define BCM56504_A0_FE_EXCESSIVE_DEFER_LIMITr 0x00f0020f

#define BCM56504_A0_FE_EXCESSIVE_DEFER_LIMITr_SIZE 4

/*
 * This structure should be used to declare and program FE_EXCESSIVE_DEFER_LIMIT.
 *
 */
typedef union BCM56504_A0_FE_EXCESSIVE_DEFER_LIMITr_s {
	uint32_t v[1];
	uint32_t fe_excessive_defer_limit[1];
	uint32_t _fe_excessive_defer_limit;
} BCM56504_A0_FE_EXCESSIVE_DEFER_LIMITr_t;

#define BCM56504_A0_FE_EXCESSIVE_DEFER_LIMITr_CLR(r) (r).fe_excessive_defer_limit[0] = 0
#define BCM56504_A0_FE_EXCESSIVE_DEFER_LIMITr_SET(r,d) (r).fe_excessive_defer_limit[0] = d
#define BCM56504_A0_FE_EXCESSIVE_DEFER_LIMITr_GET(r) (r).fe_excessive_defer_limit[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_FE_EXCESSIVE_DEFER_LIMITr_LIMITf_GET(r) (((r).fe_excessive_defer_limit[0]) & 0xffff)
#define BCM56504_A0_FE_EXCESSIVE_DEFER_LIMITr_LIMITf_SET(r,f) (r).fe_excessive_defer_limit[0]=(((r).fe_excessive_defer_limit[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access FE_EXCESSIVE_DEFER_LIMIT.
 *
 */
#define BCM56504_A0_READ_FE_EXCESSIVE_DEFER_LIMITr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_FE_EXCESSIVE_DEFER_LIMITr,(r._fe_excessive_defer_limit))
#define BCM56504_A0_WRITE_FE_EXCESSIVE_DEFER_LIMITr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_FE_EXCESSIVE_DEFER_LIMITr,&(r._fe_excessive_defer_limit))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FE_EXCESSIVE_DEFER_LIMITr BCM56504_A0_FE_EXCESSIVE_DEFER_LIMITr
#define FE_EXCESSIVE_DEFER_LIMITr_SIZE BCM56504_A0_FE_EXCESSIVE_DEFER_LIMITr_SIZE
typedef BCM56504_A0_FE_EXCESSIVE_DEFER_LIMITr_t FE_EXCESSIVE_DEFER_LIMITr_t;
#define FE_EXCESSIVE_DEFER_LIMITr_CLR BCM56504_A0_FE_EXCESSIVE_DEFER_LIMITr_CLR
#define FE_EXCESSIVE_DEFER_LIMITr_SET BCM56504_A0_FE_EXCESSIVE_DEFER_LIMITr_SET
#define FE_EXCESSIVE_DEFER_LIMITr_GET BCM56504_A0_FE_EXCESSIVE_DEFER_LIMITr_GET
#define FE_EXCESSIVE_DEFER_LIMITr_LIMITf_GET BCM56504_A0_FE_EXCESSIVE_DEFER_LIMITr_LIMITf_GET
#define FE_EXCESSIVE_DEFER_LIMITr_LIMITf_SET BCM56504_A0_FE_EXCESSIVE_DEFER_LIMITr_LIMITf_SET
#define READ_FE_EXCESSIVE_DEFER_LIMITr BCM56504_A0_READ_FE_EXCESSIVE_DEFER_LIMITr
#define WRITE_FE_EXCESSIVE_DEFER_LIMITr BCM56504_A0_WRITE_FE_EXCESSIVE_DEFER_LIMITr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_FE_EXCESSIVE_DEFER_LIMITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  FE_IPGR
 * BLOCKS:   GPORT0
 * DESC:     Fast Ethernet IPGR Register for non back to back transmit.
 * SIZE:     32
 * FIELDS:
 *     IPGR2            IPG Part 2 for non-back to back transmit
 *     IPGR1            IPG Part 1 for non-back to back transmit
 *
 ******************************************************************************/
#define BCM56504_A0_FE_IPGRr 0x00f00203

#define BCM56504_A0_FE_IPGRr_SIZE 4

/*
 * This structure should be used to declare and program FE_IPGR.
 *
 */
typedef union BCM56504_A0_FE_IPGRr_s {
	uint32_t v[1];
	uint32_t fe_ipgr[1];
	uint32_t _fe_ipgr;
} BCM56504_A0_FE_IPGRr_t;

#define BCM56504_A0_FE_IPGRr_CLR(r) (r).fe_ipgr[0] = 0
#define BCM56504_A0_FE_IPGRr_SET(r,d) (r).fe_ipgr[0] = d
#define BCM56504_A0_FE_IPGRr_GET(r) (r).fe_ipgr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_FE_IPGRr_IPGR2f_GET(r) (((r).fe_ipgr[0]) & 0x7f)
#define BCM56504_A0_FE_IPGRr_IPGR2f_SET(r,f) (r).fe_ipgr[0]=(((r).fe_ipgr[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f))
#define BCM56504_A0_FE_IPGRr_IPGR1f_GET(r) ((((r).fe_ipgr[0]) >> 8) & 0x7f)
#define BCM56504_A0_FE_IPGRr_IPGR1f_SET(r,f) (r).fe_ipgr[0]=(((r).fe_ipgr[0] & ~((uint32_t)0x7f << 8)) | ((((uint32_t)f) & 0x7f) << 8))

/*
 * These macros can be used to access FE_IPGR.
 *
 */
#define BCM56504_A0_READ_FE_IPGRr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_FE_IPGRr,(r._fe_ipgr))
#define BCM56504_A0_WRITE_FE_IPGRr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_FE_IPGRr,&(r._fe_ipgr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FE_IPGRr BCM56504_A0_FE_IPGRr
#define FE_IPGRr_SIZE BCM56504_A0_FE_IPGRr_SIZE
typedef BCM56504_A0_FE_IPGRr_t FE_IPGRr_t;
#define FE_IPGRr_CLR BCM56504_A0_FE_IPGRr_CLR
#define FE_IPGRr_SET BCM56504_A0_FE_IPGRr_SET
#define FE_IPGRr_GET BCM56504_A0_FE_IPGRr_GET
#define FE_IPGRr_IPGR2f_GET BCM56504_A0_FE_IPGRr_IPGR2f_GET
#define FE_IPGRr_IPGR2f_SET BCM56504_A0_FE_IPGRr_IPGR2f_SET
#define FE_IPGRr_IPGR1f_GET BCM56504_A0_FE_IPGRr_IPGR1f_GET
#define FE_IPGRr_IPGR1f_SET BCM56504_A0_FE_IPGRr_IPGR1f_SET
#define READ_FE_IPGRr BCM56504_A0_READ_FE_IPGRr
#define WRITE_FE_IPGRr BCM56504_A0_WRITE_FE_IPGRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_FE_IPGRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  FE_IPGT
 * BLOCKS:   GPORT0
 * DESC:     Fast Ethernet IPGT Register for back to back transmit.
 * SIZE:     32
 * FIELDS:
 *     IPGT             IPG between back to back transmit packets in units of bytes
 *
 ******************************************************************************/
#define BCM56504_A0_FE_IPGTr 0x00f00202

#define BCM56504_A0_FE_IPGTr_SIZE 4

/*
 * This structure should be used to declare and program FE_IPGT.
 *
 */
typedef union BCM56504_A0_FE_IPGTr_s {
	uint32_t v[1];
	uint32_t fe_ipgt[1];
	uint32_t _fe_ipgt;
} BCM56504_A0_FE_IPGTr_t;

#define BCM56504_A0_FE_IPGTr_CLR(r) (r).fe_ipgt[0] = 0
#define BCM56504_A0_FE_IPGTr_SET(r,d) (r).fe_ipgt[0] = d
#define BCM56504_A0_FE_IPGTr_GET(r) (r).fe_ipgt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_FE_IPGTr_IPGTf_GET(r) (((r).fe_ipgt[0]) & 0x7f)
#define BCM56504_A0_FE_IPGTr_IPGTf_SET(r,f) (r).fe_ipgt[0]=(((r).fe_ipgt[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f))

/*
 * These macros can be used to access FE_IPGT.
 *
 */
#define BCM56504_A0_READ_FE_IPGTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_FE_IPGTr,(r._fe_ipgt))
#define BCM56504_A0_WRITE_FE_IPGTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_FE_IPGTr,&(r._fe_ipgt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FE_IPGTr BCM56504_A0_FE_IPGTr
#define FE_IPGTr_SIZE BCM56504_A0_FE_IPGTr_SIZE
typedef BCM56504_A0_FE_IPGTr_t FE_IPGTr_t;
#define FE_IPGTr_CLR BCM56504_A0_FE_IPGTr_CLR
#define FE_IPGTr_SET BCM56504_A0_FE_IPGTr_SET
#define FE_IPGTr_GET BCM56504_A0_FE_IPGTr_GET
#define FE_IPGTr_IPGTf_GET BCM56504_A0_FE_IPGTr_IPGTf_GET
#define FE_IPGTr_IPGTf_SET BCM56504_A0_FE_IPGTr_IPGTf_SET
#define READ_FE_IPGTr BCM56504_A0_READ_FE_IPGTr
#define WRITE_FE_IPGTr BCM56504_A0_WRITE_FE_IPGTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_FE_IPGTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  FE_MAC1
 * BLOCKS:   GPORT0
 * DESC:     Fast Ethernet MAC Configuration 1 Register.
 * SIZE:     32
 * FIELDS:
 *     RX_EN            RX Enable
 *     PASSALL          Pass All Rx Frames
 *     RX_PAU           RX Flow control
 *     TX_PAU           TX Flow control
 *     LBACK            Loopback
 *     HRTFN            reset for transmit blocks
 *     HRRFN            reset for receive blocks
 *     R_EXTEND_RANDOM_NUMBER_GENERATOR If 0, randon number generator in FE mac is unchanged.  If 1, random number generator in mac is extended to 23 bits with a new polynomial
 *     R_RNG_GATE       Disable (0) or enable (1) inclusion of state bits into random number generator in FE mac.
 *     RST_SIM          Reset Simulation
 *     SRST             Soft reset (Not used, control from GMACC0)
 *
 ******************************************************************************/
#define BCM56504_A0_FE_MAC1r 0x00f00200

#define BCM56504_A0_FE_MAC1r_SIZE 4

/*
 * This structure should be used to declare and program FE_MAC1.
 *
 */
typedef union BCM56504_A0_FE_MAC1r_s {
	uint32_t v[1];
	uint32_t fe_mac1[1];
	uint32_t _fe_mac1;
} BCM56504_A0_FE_MAC1r_t;

#define BCM56504_A0_FE_MAC1r_CLR(r) (r).fe_mac1[0] = 0
#define BCM56504_A0_FE_MAC1r_SET(r,d) (r).fe_mac1[0] = d
#define BCM56504_A0_FE_MAC1r_GET(r) (r).fe_mac1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_FE_MAC1r_RX_ENf_GET(r) (((r).fe_mac1[0]) & 0x1)
#define BCM56504_A0_FE_MAC1r_RX_ENf_SET(r,f) (r).fe_mac1[0]=(((r).fe_mac1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_FE_MAC1r_PASSALLf_GET(r) ((((r).fe_mac1[0]) >> 1) & 0x1)
#define BCM56504_A0_FE_MAC1r_PASSALLf_SET(r,f) (r).fe_mac1[0]=(((r).fe_mac1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_FE_MAC1r_RX_PAUf_GET(r) ((((r).fe_mac1[0]) >> 2) & 0x1)
#define BCM56504_A0_FE_MAC1r_RX_PAUf_SET(r,f) (r).fe_mac1[0]=(((r).fe_mac1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_FE_MAC1r_TX_PAUf_GET(r) ((((r).fe_mac1[0]) >> 3) & 0x1)
#define BCM56504_A0_FE_MAC1r_TX_PAUf_SET(r,f) (r).fe_mac1[0]=(((r).fe_mac1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_FE_MAC1r_LBACKf_GET(r) ((((r).fe_mac1[0]) >> 4) & 0x1)
#define BCM56504_A0_FE_MAC1r_LBACKf_SET(r,f) (r).fe_mac1[0]=(((r).fe_mac1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56504_A0_FE_MAC1r_HRTFNf_GET(r) ((((r).fe_mac1[0]) >> 8) & 0x1)
#define BCM56504_A0_FE_MAC1r_HRTFNf_SET(r,f) (r).fe_mac1[0]=(((r).fe_mac1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56504_A0_FE_MAC1r_HRRFNf_GET(r) ((((r).fe_mac1[0]) >> 10) & 0x1)
#define BCM56504_A0_FE_MAC1r_HRRFNf_SET(r,f) (r).fe_mac1[0]=(((r).fe_mac1[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56504_A0_FE_MAC1r_R_EXTEND_RANDOM_NUMBER_GENERATORf_GET(r) ((((r).fe_mac1[0]) >> 12) & 0x1)
#define BCM56504_A0_FE_MAC1r_R_EXTEND_RANDOM_NUMBER_GENERATORf_SET(r,f) (r).fe_mac1[0]=(((r).fe_mac1[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM56504_A0_FE_MAC1r_R_RNG_GATEf_GET(r) ((((r).fe_mac1[0]) >> 13) & 0x1)
#define BCM56504_A0_FE_MAC1r_R_RNG_GATEf_SET(r,f) (r).fe_mac1[0]=(((r).fe_mac1[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56504_A0_FE_MAC1r_RST_SIMf_GET(r) ((((r).fe_mac1[0]) >> 14) & 0x1)
#define BCM56504_A0_FE_MAC1r_RST_SIMf_SET(r,f) (r).fe_mac1[0]=(((r).fe_mac1[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM56504_A0_FE_MAC1r_SRSTf_GET(r) ((((r).fe_mac1[0]) >> 15) & 0x1)
#define BCM56504_A0_FE_MAC1r_SRSTf_SET(r,f) (r).fe_mac1[0]=(((r).fe_mac1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access FE_MAC1.
 *
 */
#define BCM56504_A0_READ_FE_MAC1r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_FE_MAC1r,(r._fe_mac1))
#define BCM56504_A0_WRITE_FE_MAC1r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_FE_MAC1r,&(r._fe_mac1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FE_MAC1r BCM56504_A0_FE_MAC1r
#define FE_MAC1r_SIZE BCM56504_A0_FE_MAC1r_SIZE
typedef BCM56504_A0_FE_MAC1r_t FE_MAC1r_t;
#define FE_MAC1r_CLR BCM56504_A0_FE_MAC1r_CLR
#define FE_MAC1r_SET BCM56504_A0_FE_MAC1r_SET
#define FE_MAC1r_GET BCM56504_A0_FE_MAC1r_GET
#define FE_MAC1r_RX_ENf_GET BCM56504_A0_FE_MAC1r_RX_ENf_GET
#define FE_MAC1r_RX_ENf_SET BCM56504_A0_FE_MAC1r_RX_ENf_SET
#define FE_MAC1r_PASSALLf_GET BCM56504_A0_FE_MAC1r_PASSALLf_GET
#define FE_MAC1r_PASSALLf_SET BCM56504_A0_FE_MAC1r_PASSALLf_SET
#define FE_MAC1r_RX_PAUf_GET BCM56504_A0_FE_MAC1r_RX_PAUf_GET
#define FE_MAC1r_RX_PAUf_SET BCM56504_A0_FE_MAC1r_RX_PAUf_SET
#define FE_MAC1r_TX_PAUf_GET BCM56504_A0_FE_MAC1r_TX_PAUf_GET
#define FE_MAC1r_TX_PAUf_SET BCM56504_A0_FE_MAC1r_TX_PAUf_SET
#define FE_MAC1r_LBACKf_GET BCM56504_A0_FE_MAC1r_LBACKf_GET
#define FE_MAC1r_LBACKf_SET BCM56504_A0_FE_MAC1r_LBACKf_SET
#define FE_MAC1r_HRTFNf_GET BCM56504_A0_FE_MAC1r_HRTFNf_GET
#define FE_MAC1r_HRTFNf_SET BCM56504_A0_FE_MAC1r_HRTFNf_SET
#define FE_MAC1r_HRRFNf_GET BCM56504_A0_FE_MAC1r_HRRFNf_GET
#define FE_MAC1r_HRRFNf_SET BCM56504_A0_FE_MAC1r_HRRFNf_SET
#define FE_MAC1r_R_EXTEND_RANDOM_NUMBER_GENERATORf_GET BCM56504_A0_FE_MAC1r_R_EXTEND_RANDOM_NUMBER_GENERATORf_GET
#define FE_MAC1r_R_EXTEND_RANDOM_NUMBER_GENERATORf_SET BCM56504_A0_FE_MAC1r_R_EXTEND_RANDOM_NUMBER_GENERATORf_SET
#define FE_MAC1r_R_RNG_GATEf_GET BCM56504_A0_FE_MAC1r_R_RNG_GATEf_GET
#define FE_MAC1r_R_RNG_GATEf_SET BCM56504_A0_FE_MAC1r_R_RNG_GATEf_SET
#define FE_MAC1r_RST_SIMf_GET BCM56504_A0_FE_MAC1r_RST_SIMf_GET
#define FE_MAC1r_RST_SIMf_SET BCM56504_A0_FE_MAC1r_RST_SIMf_SET
#define FE_MAC1r_SRSTf_GET BCM56504_A0_FE_MAC1r_SRSTf_GET
#define FE_MAC1r_SRSTf_SET BCM56504_A0_FE_MAC1r_SRSTf_SET
#define READ_FE_MAC1r BCM56504_A0_READ_FE_MAC1r
#define WRITE_FE_MAC1r BCM56504_A0_WRITE_FE_MAC1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_FE_MAC1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  FE_MAC2
 * BLOCKS:   GPORT0
 * DESC:     Fast Ethernet MAC Configuration 2 Register.
 * SIZE:     32
 * FIELDS:
 *     FULL_DUP         Full Duplex Operation 0 = Enable Half Duplex 1 = Enable Full Duplex operation
 *     LG_CHK           Frame Length Checking 0 = Do not perform Frame Length checking 1 = Perform Frame Length checking if length/type field indicates one and report mismatches on xmit/recv statistics vector 
 *     HUGE_FR          Huge Frame Enable 0 = Huge frames are neither transmitted nor received 1 = Huge frames of any length are both transmitted and received
 *     DEL_CRC          Delayed CRC - determines the number of bytes of proprietary header information on the front of IEEE802.3 frames 0 = No proprietary header 1 = 4 bytes of proprietary header (ignored by CRC function)
 *     CRC_EN           Append CRC to frames 0 = Do not append CRC. Frame presented to MAC contains a CRC 1 = Append CRC to every frame, irrespective of padding requirement
 *     PAD_EN           Pad and add CRC to all short frames using bit setting of VLAN_PAD and AUTO_PAD 
 *     VLAN_PAD         Pad all short frames to 64 bytes and append a valid CRC
 *     AUTO_PAD         Automatic Detection of tagged and un-tagged frames and padding is performed accordingly 
 *     PURE_PAD         Pure Preamble Enforcement 0 = No preamble checking is performed 1 = Verify preamble contains 0x55 and is error free. Otherwise, discard the packet 
 *     LONG_PRE         Long Preamble Enforcement 0 = Receive packets with any length preamble per standard 1 = Receive packets with preamble fields less than 12 bytes in length 
 *     NO_BOFF          Backoff after collision. 0 = Use Binary exponential backoff algorithm 1 = Retransmit immediately
 *     BP_NO_BOFF       Back Pressure Backoff after collision. 0 = Use Binary exponential backoff algorithm 1 = Retransmit immediately
 *     EXC_DEF          Deferral to carrier. 0 = Abort when excessive deferral limit is reached and provide feedback to the host system 1 = Defer to carrier indefinitely as per standard
 *
 ******************************************************************************/
#define BCM56504_A0_FE_MAC2r 0x00f00201

#define BCM56504_A0_FE_MAC2r_SIZE 4

/*
 * This structure should be used to declare and program FE_MAC2.
 *
 */
typedef union BCM56504_A0_FE_MAC2r_s {
	uint32_t v[1];
	uint32_t fe_mac2[1];
	uint32_t _fe_mac2;
} BCM56504_A0_FE_MAC2r_t;

#define BCM56504_A0_FE_MAC2r_CLR(r) (r).fe_mac2[0] = 0
#define BCM56504_A0_FE_MAC2r_SET(r,d) (r).fe_mac2[0] = d
#define BCM56504_A0_FE_MAC2r_GET(r) (r).fe_mac2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_FE_MAC2r_FULL_DUPf_GET(r) (((r).fe_mac2[0]) & 0x1)
#define BCM56504_A0_FE_MAC2r_FULL_DUPf_SET(r,f) (r).fe_mac2[0]=(((r).fe_mac2[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_FE_MAC2r_LG_CHKf_GET(r) ((((r).fe_mac2[0]) >> 1) & 0x1)
#define BCM56504_A0_FE_MAC2r_LG_CHKf_SET(r,f) (r).fe_mac2[0]=(((r).fe_mac2[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_FE_MAC2r_HUGE_FRf_GET(r) ((((r).fe_mac2[0]) >> 2) & 0x1)
#define BCM56504_A0_FE_MAC2r_HUGE_FRf_SET(r,f) (r).fe_mac2[0]=(((r).fe_mac2[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_FE_MAC2r_DEL_CRCf_GET(r) ((((r).fe_mac2[0]) >> 3) & 0x1)
#define BCM56504_A0_FE_MAC2r_DEL_CRCf_SET(r,f) (r).fe_mac2[0]=(((r).fe_mac2[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_FE_MAC2r_CRC_ENf_GET(r) ((((r).fe_mac2[0]) >> 4) & 0x1)
#define BCM56504_A0_FE_MAC2r_CRC_ENf_SET(r,f) (r).fe_mac2[0]=(((r).fe_mac2[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56504_A0_FE_MAC2r_PAD_ENf_GET(r) ((((r).fe_mac2[0]) >> 5) & 0x1)
#define BCM56504_A0_FE_MAC2r_PAD_ENf_SET(r,f) (r).fe_mac2[0]=(((r).fe_mac2[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56504_A0_FE_MAC2r_VLAN_PADf_GET(r) ((((r).fe_mac2[0]) >> 6) & 0x1)
#define BCM56504_A0_FE_MAC2r_VLAN_PADf_SET(r,f) (r).fe_mac2[0]=(((r).fe_mac2[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56504_A0_FE_MAC2r_AUTO_PADf_GET(r) ((((r).fe_mac2[0]) >> 7) & 0x1)
#define BCM56504_A0_FE_MAC2r_AUTO_PADf_SET(r,f) (r).fe_mac2[0]=(((r).fe_mac2[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56504_A0_FE_MAC2r_PURE_PADf_GET(r) ((((r).fe_mac2[0]) >> 8) & 0x1)
#define BCM56504_A0_FE_MAC2r_PURE_PADf_SET(r,f) (r).fe_mac2[0]=(((r).fe_mac2[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56504_A0_FE_MAC2r_LONG_PREf_GET(r) ((((r).fe_mac2[0]) >> 9) & 0x1)
#define BCM56504_A0_FE_MAC2r_LONG_PREf_SET(r,f) (r).fe_mac2[0]=(((r).fe_mac2[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56504_A0_FE_MAC2r_NO_BOFFf_GET(r) ((((r).fe_mac2[0]) >> 12) & 0x1)
#define BCM56504_A0_FE_MAC2r_NO_BOFFf_SET(r,f) (r).fe_mac2[0]=(((r).fe_mac2[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM56504_A0_FE_MAC2r_BP_NO_BOFFf_GET(r) ((((r).fe_mac2[0]) >> 13) & 0x1)
#define BCM56504_A0_FE_MAC2r_BP_NO_BOFFf_SET(r,f) (r).fe_mac2[0]=(((r).fe_mac2[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56504_A0_FE_MAC2r_EXC_DEFf_GET(r) ((((r).fe_mac2[0]) >> 14) & 0x1)
#define BCM56504_A0_FE_MAC2r_EXC_DEFf_SET(r,f) (r).fe_mac2[0]=(((r).fe_mac2[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))

/*
 * These macros can be used to access FE_MAC2.
 *
 */
#define BCM56504_A0_READ_FE_MAC2r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_FE_MAC2r,(r._fe_mac2))
#define BCM56504_A0_WRITE_FE_MAC2r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_FE_MAC2r,&(r._fe_mac2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FE_MAC2r BCM56504_A0_FE_MAC2r
#define FE_MAC2r_SIZE BCM56504_A0_FE_MAC2r_SIZE
typedef BCM56504_A0_FE_MAC2r_t FE_MAC2r_t;
#define FE_MAC2r_CLR BCM56504_A0_FE_MAC2r_CLR
#define FE_MAC2r_SET BCM56504_A0_FE_MAC2r_SET
#define FE_MAC2r_GET BCM56504_A0_FE_MAC2r_GET
#define FE_MAC2r_FULL_DUPf_GET BCM56504_A0_FE_MAC2r_FULL_DUPf_GET
#define FE_MAC2r_FULL_DUPf_SET BCM56504_A0_FE_MAC2r_FULL_DUPf_SET
#define FE_MAC2r_LG_CHKf_GET BCM56504_A0_FE_MAC2r_LG_CHKf_GET
#define FE_MAC2r_LG_CHKf_SET BCM56504_A0_FE_MAC2r_LG_CHKf_SET
#define FE_MAC2r_HUGE_FRf_GET BCM56504_A0_FE_MAC2r_HUGE_FRf_GET
#define FE_MAC2r_HUGE_FRf_SET BCM56504_A0_FE_MAC2r_HUGE_FRf_SET
#define FE_MAC2r_DEL_CRCf_GET BCM56504_A0_FE_MAC2r_DEL_CRCf_GET
#define FE_MAC2r_DEL_CRCf_SET BCM56504_A0_FE_MAC2r_DEL_CRCf_SET
#define FE_MAC2r_CRC_ENf_GET BCM56504_A0_FE_MAC2r_CRC_ENf_GET
#define FE_MAC2r_CRC_ENf_SET BCM56504_A0_FE_MAC2r_CRC_ENf_SET
#define FE_MAC2r_PAD_ENf_GET BCM56504_A0_FE_MAC2r_PAD_ENf_GET
#define FE_MAC2r_PAD_ENf_SET BCM56504_A0_FE_MAC2r_PAD_ENf_SET
#define FE_MAC2r_VLAN_PADf_GET BCM56504_A0_FE_MAC2r_VLAN_PADf_GET
#define FE_MAC2r_VLAN_PADf_SET BCM56504_A0_FE_MAC2r_VLAN_PADf_SET
#define FE_MAC2r_AUTO_PADf_GET BCM56504_A0_FE_MAC2r_AUTO_PADf_GET
#define FE_MAC2r_AUTO_PADf_SET BCM56504_A0_FE_MAC2r_AUTO_PADf_SET
#define FE_MAC2r_PURE_PADf_GET BCM56504_A0_FE_MAC2r_PURE_PADf_GET
#define FE_MAC2r_PURE_PADf_SET BCM56504_A0_FE_MAC2r_PURE_PADf_SET
#define FE_MAC2r_LONG_PREf_GET BCM56504_A0_FE_MAC2r_LONG_PREf_GET
#define FE_MAC2r_LONG_PREf_SET BCM56504_A0_FE_MAC2r_LONG_PREf_SET
#define FE_MAC2r_NO_BOFFf_GET BCM56504_A0_FE_MAC2r_NO_BOFFf_GET
#define FE_MAC2r_NO_BOFFf_SET BCM56504_A0_FE_MAC2r_NO_BOFFf_SET
#define FE_MAC2r_BP_NO_BOFFf_GET BCM56504_A0_FE_MAC2r_BP_NO_BOFFf_GET
#define FE_MAC2r_BP_NO_BOFFf_SET BCM56504_A0_FE_MAC2r_BP_NO_BOFFf_SET
#define FE_MAC2r_EXC_DEFf_GET BCM56504_A0_FE_MAC2r_EXC_DEFf_GET
#define FE_MAC2r_EXC_DEFf_SET BCM56504_A0_FE_MAC2r_EXC_DEFf_SET
#define READ_FE_MAC2r BCM56504_A0_READ_FE_MAC2r
#define WRITE_FE_MAC2r BCM56504_A0_WRITE_FE_MAC2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_FE_MAC2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  FE_MAXF
 * BLOCKS:   GPORT0
 * DESC:     Fast Ethernet Maximum Frame Length Register.
 * SIZE:     32
 * FIELDS:
 *     MAXFR            Maximum frame length in bytes that will be received is now 1518 Decimal
 *
 ******************************************************************************/
#define BCM56504_A0_FE_MAXFr 0x00f00205

#define BCM56504_A0_FE_MAXFr_SIZE 4

/*
 * This structure should be used to declare and program FE_MAXF.
 *
 */
typedef union BCM56504_A0_FE_MAXFr_s {
	uint32_t v[1];
	uint32_t fe_maxf[1];
	uint32_t _fe_maxf;
} BCM56504_A0_FE_MAXFr_t;

#define BCM56504_A0_FE_MAXFr_CLR(r) (r).fe_maxf[0] = 0
#define BCM56504_A0_FE_MAXFr_SET(r,d) (r).fe_maxf[0] = d
#define BCM56504_A0_FE_MAXFr_GET(r) (r).fe_maxf[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_FE_MAXFr_MAXFRf_GET(r) (((r).fe_maxf[0]) & 0xffff)
#define BCM56504_A0_FE_MAXFr_MAXFRf_SET(r,f) (r).fe_maxf[0]=(((r).fe_maxf[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access FE_MAXF.
 *
 */
#define BCM56504_A0_READ_FE_MAXFr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_FE_MAXFr,(r._fe_maxf))
#define BCM56504_A0_WRITE_FE_MAXFr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_FE_MAXFr,&(r._fe_maxf))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FE_MAXFr BCM56504_A0_FE_MAXFr
#define FE_MAXFr_SIZE BCM56504_A0_FE_MAXFr_SIZE
typedef BCM56504_A0_FE_MAXFr_t FE_MAXFr_t;
#define FE_MAXFr_CLR BCM56504_A0_FE_MAXFr_CLR
#define FE_MAXFr_SET BCM56504_A0_FE_MAXFr_SET
#define FE_MAXFr_GET BCM56504_A0_FE_MAXFr_GET
#define FE_MAXFr_MAXFRf_GET BCM56504_A0_FE_MAXFr_MAXFRf_GET
#define FE_MAXFr_MAXFRf_SET BCM56504_A0_FE_MAXFr_MAXFRf_SET
#define READ_FE_MAXFr BCM56504_A0_READ_FE_MAXFr
#define WRITE_FE_MAXFr BCM56504_A0_WRITE_FE_MAXFr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_FE_MAXFr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  FE_SUPP
 * BLOCKS:   GPORT0
 * DESC:     Fast Ethernet Support Register.
 * SIZE:     32
 * FIELDS:
 *     BIT_MODE         ENDEC Mode where clock is the bit clock 0 = Disable ENDEC mode 1 = Enable ENDEC mode
 *     SPEED            Operating speed of the RMII 0 = 10Mb/sec mode 1 = 100Mb/sec mode
 *     PHYMOD           This bit controls whether the MAC is in MAC-to-MAC (0), or MAC-to-PHY (1) mode
 *
 ******************************************************************************/
#define BCM56504_A0_FE_SUPPr 0x00f00206

#define BCM56504_A0_FE_SUPPr_SIZE 4

/*
 * This structure should be used to declare and program FE_SUPP.
 *
 */
typedef union BCM56504_A0_FE_SUPPr_s {
	uint32_t v[1];
	uint32_t fe_supp[1];
	uint32_t _fe_supp;
} BCM56504_A0_FE_SUPPr_t;

#define BCM56504_A0_FE_SUPPr_CLR(r) (r).fe_supp[0] = 0
#define BCM56504_A0_FE_SUPPr_SET(r,d) (r).fe_supp[0] = d
#define BCM56504_A0_FE_SUPPr_GET(r) (r).fe_supp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_FE_SUPPr_BIT_MODEf_GET(r) (((r).fe_supp[0]) & 0x1)
#define BCM56504_A0_FE_SUPPr_BIT_MODEf_SET(r,f) (r).fe_supp[0]=(((r).fe_supp[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_FE_SUPPr_SPEEDf_GET(r) ((((r).fe_supp[0]) >> 8) & 0x1)
#define BCM56504_A0_FE_SUPPr_SPEEDf_SET(r,f) (r).fe_supp[0]=(((r).fe_supp[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56504_A0_FE_SUPPr_PHYMODf_GET(r) ((((r).fe_supp[0]) >> 12) & 0x1)
#define BCM56504_A0_FE_SUPPr_PHYMODf_SET(r,f) (r).fe_supp[0]=(((r).fe_supp[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))

/*
 * These macros can be used to access FE_SUPP.
 *
 */
#define BCM56504_A0_READ_FE_SUPPr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_FE_SUPPr,(r._fe_supp))
#define BCM56504_A0_WRITE_FE_SUPPr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_FE_SUPPr,&(r._fe_supp))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FE_SUPPr BCM56504_A0_FE_SUPPr
#define FE_SUPPr_SIZE BCM56504_A0_FE_SUPPr_SIZE
typedef BCM56504_A0_FE_SUPPr_t FE_SUPPr_t;
#define FE_SUPPr_CLR BCM56504_A0_FE_SUPPr_CLR
#define FE_SUPPr_SET BCM56504_A0_FE_SUPPr_SET
#define FE_SUPPr_GET BCM56504_A0_FE_SUPPr_GET
#define FE_SUPPr_BIT_MODEf_GET BCM56504_A0_FE_SUPPr_BIT_MODEf_GET
#define FE_SUPPr_BIT_MODEf_SET BCM56504_A0_FE_SUPPr_BIT_MODEf_SET
#define FE_SUPPr_SPEEDf_GET BCM56504_A0_FE_SUPPr_SPEEDf_GET
#define FE_SUPPr_SPEEDf_SET BCM56504_A0_FE_SUPPr_SPEEDf_SET
#define FE_SUPPr_PHYMODf_GET BCM56504_A0_FE_SUPPr_PHYMODf_GET
#define FE_SUPPr_PHYMODf_SET BCM56504_A0_FE_SUPPr_PHYMODf_SET
#define READ_FE_SUPPr BCM56504_A0_READ_FE_SUPPr
#define WRITE_FE_SUPPr BCM56504_A0_WRITE_FE_SUPPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_FE_SUPPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  FE_TEST
 * BLOCKS:   GPORT0
 * DESC:     Fast Ethernet Test Register.
 * SIZE:     32
 * FIELDS:
 *     SHORT_QNTA       Shortcut Pause Quanta 0 = Do not configure ENDEC mode (clock is nibble clock) 1 = Configure ENDEC mode (clock is bit clock)
 *     TEST_PAUSE       Test Pause 0 = Do not reset RMII logic 1 = Reset RMII logic
 *     TEST_BACK        Test Back Pressure 0 = Do not assert backpressure 1 = Assert backpressure, causing preamble to be transmitted
 *
 ******************************************************************************/
#define BCM56504_A0_FE_TESTr 0x00f00207

#define BCM56504_A0_FE_TESTr_SIZE 4

/*
 * This structure should be used to declare and program FE_TEST.
 *
 */
typedef union BCM56504_A0_FE_TESTr_s {
	uint32_t v[1];
	uint32_t fe_test[1];
	uint32_t _fe_test;
} BCM56504_A0_FE_TESTr_t;

#define BCM56504_A0_FE_TESTr_CLR(r) (r).fe_test[0] = 0
#define BCM56504_A0_FE_TESTr_SET(r,d) (r).fe_test[0] = d
#define BCM56504_A0_FE_TESTr_GET(r) (r).fe_test[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_FE_TESTr_SHORT_QNTAf_GET(r) (((r).fe_test[0]) & 0x1)
#define BCM56504_A0_FE_TESTr_SHORT_QNTAf_SET(r,f) (r).fe_test[0]=(((r).fe_test[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_FE_TESTr_TEST_PAUSEf_GET(r) ((((r).fe_test[0]) >> 1) & 0x1)
#define BCM56504_A0_FE_TESTr_TEST_PAUSEf_SET(r,f) (r).fe_test[0]=(((r).fe_test[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_FE_TESTr_TEST_BACKf_GET(r) ((((r).fe_test[0]) >> 2) & 0x1)
#define BCM56504_A0_FE_TESTr_TEST_BACKf_SET(r,f) (r).fe_test[0]=(((r).fe_test[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))

/*
 * These macros can be used to access FE_TEST.
 *
 */
#define BCM56504_A0_READ_FE_TESTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_FE_TESTr,(r._fe_test))
#define BCM56504_A0_WRITE_FE_TESTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_FE_TESTr,&(r._fe_test))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FE_TESTr BCM56504_A0_FE_TESTr
#define FE_TESTr_SIZE BCM56504_A0_FE_TESTr_SIZE
typedef BCM56504_A0_FE_TESTr_t FE_TESTr_t;
#define FE_TESTr_CLR BCM56504_A0_FE_TESTr_CLR
#define FE_TESTr_SET BCM56504_A0_FE_TESTr_SET
#define FE_TESTr_GET BCM56504_A0_FE_TESTr_GET
#define FE_TESTr_SHORT_QNTAf_GET BCM56504_A0_FE_TESTr_SHORT_QNTAf_GET
#define FE_TESTr_SHORT_QNTAf_SET BCM56504_A0_FE_TESTr_SHORT_QNTAf_SET
#define FE_TESTr_TEST_PAUSEf_GET BCM56504_A0_FE_TESTr_TEST_PAUSEf_GET
#define FE_TESTr_TEST_PAUSEf_SET BCM56504_A0_FE_TESTr_TEST_PAUSEf_SET
#define FE_TESTr_TEST_BACKf_GET BCM56504_A0_FE_TESTr_TEST_BACKf_GET
#define FE_TESTr_TEST_BACKf_SET BCM56504_A0_FE_TESTr_TEST_BACKf_SET
#define READ_FE_TESTr BCM56504_A0_READ_FE_TESTr
#define WRITE_FE_TESTr BCM56504_A0_WRITE_FE_TESTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_FE_TESTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  FP_CAM_BIST_ENABLE
 * BLOCKS:   IPIPE
 * DESC:     FP_CAM_BIST_ENABLE
 * SIZE:     32
 * FIELDS:
 *     FP_CAM_BIST_ENABLE_SLICE_0 FP_CAM_BIST_ENABLE FOR FP SLICE 0
 *     FP_CAM_BIST_ENABLE_SLICE_1 FP_CAM_BIST_ENABLE FOR FP SLICE 1
 *     FP_CAM_BIST_ENABLE_SLICE_2 FP_CAM_BIST_ENABLE FOR FP SLICE 2
 *     FP_CAM_BIST_ENABLE_SLICE_3 FP_CAM_BIST_ENABLE FOR FP SLICE 3
 *     FP_CAM_BIST_ENABLE_SLICE_4 FP_CAM_BIST_ENABLE FOR FP SLICE 4
 *     FP_CAM_BIST_ENABLE_SLICE_5 FP_CAM_BIST_ENABLE FOR FP SLICE 5
 *     FP_CAM_BIST_ENABLE_SLICE_6 FP_CAM_BIST_ENABLE FOR FP SLICE 6
 *     FP_CAM_BIST_ENABLE_SLICE_7 FP_CAM_BIST_ENABLE FOR FP SLICE 7
 *     FP_CAM_BIST_ENABLE_SLICE_8 FP_CAM_BIST_ENABLE FOR FP SLICE 8
 *     FP_CAM_BIST_ENABLE_SLICE_9 FP_CAM_BIST_ENABLE FOR FP SLICE 9
 *     FP_CAM_BIST_ENABLE_SLICE_10 FP_CAM_BIST_ENABLE FOR FP SLICE 10
 *     FP_CAM_BIST_ENABLE_SLICE_11 FP_CAM_BIST_ENABLE FOR FP SLICE 11
 *     FP_CAM_BIST_ENABLE_SLICE_12 FP_CAM_BIST_ENABLE FOR FP SLICE 12
 *     FP_CAM_BIST_ENABLE_SLICE_13 FP_CAM_BIST_ENABLE FOR FP SLICE 13
 *     FP_CAM_BIST_ENABLE_SLICE_14 FP_CAM_BIST_ENABLE FOR FP SLICE 14
 *     FP_CAM_BIST_ENABLE_SLICE_15 FP_CAM_BIST_ENABLE FOR FP SLICE 15
 *
 ******************************************************************************/
#define BCM56504_A0_FP_CAM_BIST_ENABLEr 0x0c780008

#define BCM56504_A0_FP_CAM_BIST_ENABLEr_SIZE 4

/*
 * This structure should be used to declare and program FP_CAM_BIST_ENABLE.
 *
 */
typedef union BCM56504_A0_FP_CAM_BIST_ENABLEr_s {
	uint32_t v[1];
	uint32_t fp_cam_bist_enable[1];
	uint32_t _fp_cam_bist_enable;
} BCM56504_A0_FP_CAM_BIST_ENABLEr_t;

#define BCM56504_A0_FP_CAM_BIST_ENABLEr_CLR(r) (r).fp_cam_bist_enable[0] = 0
#define BCM56504_A0_FP_CAM_BIST_ENABLEr_SET(r,d) (r).fp_cam_bist_enable[0] = d
#define BCM56504_A0_FP_CAM_BIST_ENABLEr_GET(r) (r).fp_cam_bist_enable[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_0f_GET(r) (((r).fp_cam_bist_enable[0]) & 0x1)
#define BCM56504_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_0f_SET(r,f) (r).fp_cam_bist_enable[0]=(((r).fp_cam_bist_enable[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_1f_GET(r) ((((r).fp_cam_bist_enable[0]) >> 1) & 0x1)
#define BCM56504_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_1f_SET(r,f) (r).fp_cam_bist_enable[0]=(((r).fp_cam_bist_enable[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_2f_GET(r) ((((r).fp_cam_bist_enable[0]) >> 2) & 0x1)
#define BCM56504_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_2f_SET(r,f) (r).fp_cam_bist_enable[0]=(((r).fp_cam_bist_enable[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_3f_GET(r) ((((r).fp_cam_bist_enable[0]) >> 3) & 0x1)
#define BCM56504_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_3f_SET(r,f) (r).fp_cam_bist_enable[0]=(((r).fp_cam_bist_enable[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_4f_GET(r) ((((r).fp_cam_bist_enable[0]) >> 4) & 0x1)
#define BCM56504_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_4f_SET(r,f) (r).fp_cam_bist_enable[0]=(((r).fp_cam_bist_enable[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56504_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_5f_GET(r) ((((r).fp_cam_bist_enable[0]) >> 5) & 0x1)
#define BCM56504_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_5f_SET(r,f) (r).fp_cam_bist_enable[0]=(((r).fp_cam_bist_enable[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56504_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_6f_GET(r) ((((r).fp_cam_bist_enable[0]) >> 6) & 0x1)
#define BCM56504_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_6f_SET(r,f) (r).fp_cam_bist_enable[0]=(((r).fp_cam_bist_enable[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56504_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_7f_GET(r) ((((r).fp_cam_bist_enable[0]) >> 7) & 0x1)
#define BCM56504_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_7f_SET(r,f) (r).fp_cam_bist_enable[0]=(((r).fp_cam_bist_enable[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56504_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_8f_GET(r) ((((r).fp_cam_bist_enable[0]) >> 8) & 0x1)
#define BCM56504_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_8f_SET(r,f) (r).fp_cam_bist_enable[0]=(((r).fp_cam_bist_enable[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56504_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_9f_GET(r) ((((r).fp_cam_bist_enable[0]) >> 9) & 0x1)
#define BCM56504_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_9f_SET(r,f) (r).fp_cam_bist_enable[0]=(((r).fp_cam_bist_enable[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56504_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_10f_GET(r) ((((r).fp_cam_bist_enable[0]) >> 10) & 0x1)
#define BCM56504_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_10f_SET(r,f) (r).fp_cam_bist_enable[0]=(((r).fp_cam_bist_enable[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56504_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_11f_GET(r) ((((r).fp_cam_bist_enable[0]) >> 11) & 0x1)
#define BCM56504_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_11f_SET(r,f) (r).fp_cam_bist_enable[0]=(((r).fp_cam_bist_enable[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56504_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_12f_GET(r) ((((r).fp_cam_bist_enable[0]) >> 12) & 0x1)
#define BCM56504_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_12f_SET(r,f) (r).fp_cam_bist_enable[0]=(((r).fp_cam_bist_enable[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM56504_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_13f_GET(r) ((((r).fp_cam_bist_enable[0]) >> 13) & 0x1)
#define BCM56504_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_13f_SET(r,f) (r).fp_cam_bist_enable[0]=(((r).fp_cam_bist_enable[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56504_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_14f_GET(r) ((((r).fp_cam_bist_enable[0]) >> 14) & 0x1)
#define BCM56504_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_14f_SET(r,f) (r).fp_cam_bist_enable[0]=(((r).fp_cam_bist_enable[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM56504_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_15f_GET(r) ((((r).fp_cam_bist_enable[0]) >> 15) & 0x1)
#define BCM56504_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_15f_SET(r,f) (r).fp_cam_bist_enable[0]=(((r).fp_cam_bist_enable[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access FP_CAM_BIST_ENABLE.
 *
 */
#define BCM56504_A0_READ_FP_CAM_BIST_ENABLEr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_FP_CAM_BIST_ENABLEr,(r._fp_cam_bist_enable))
#define BCM56504_A0_WRITE_FP_CAM_BIST_ENABLEr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_FP_CAM_BIST_ENABLEr,&(r._fp_cam_bist_enable))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_CAM_BIST_ENABLEr BCM56504_A0_FP_CAM_BIST_ENABLEr
#define FP_CAM_BIST_ENABLEr_SIZE BCM56504_A0_FP_CAM_BIST_ENABLEr_SIZE
typedef BCM56504_A0_FP_CAM_BIST_ENABLEr_t FP_CAM_BIST_ENABLEr_t;
#define FP_CAM_BIST_ENABLEr_CLR BCM56504_A0_FP_CAM_BIST_ENABLEr_CLR
#define FP_CAM_BIST_ENABLEr_SET BCM56504_A0_FP_CAM_BIST_ENABLEr_SET
#define FP_CAM_BIST_ENABLEr_GET BCM56504_A0_FP_CAM_BIST_ENABLEr_GET
#define FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_0f_GET BCM56504_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_0f_GET
#define FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_0f_SET BCM56504_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_0f_SET
#define FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_1f_GET BCM56504_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_1f_GET
#define FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_1f_SET BCM56504_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_1f_SET
#define FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_2f_GET BCM56504_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_2f_GET
#define FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_2f_SET BCM56504_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_2f_SET
#define FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_3f_GET BCM56504_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_3f_GET
#define FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_3f_SET BCM56504_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_3f_SET
#define FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_4f_GET BCM56504_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_4f_GET
#define FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_4f_SET BCM56504_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_4f_SET
#define FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_5f_GET BCM56504_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_5f_GET
#define FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_5f_SET BCM56504_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_5f_SET
#define FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_6f_GET BCM56504_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_6f_GET
#define FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_6f_SET BCM56504_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_6f_SET
#define FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_7f_GET BCM56504_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_7f_GET
#define FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_7f_SET BCM56504_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_7f_SET
#define FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_8f_GET BCM56504_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_8f_GET
#define FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_8f_SET BCM56504_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_8f_SET
#define FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_9f_GET BCM56504_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_9f_GET
#define FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_9f_SET BCM56504_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_9f_SET
#define FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_10f_GET BCM56504_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_10f_GET
#define FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_10f_SET BCM56504_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_10f_SET
#define FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_11f_GET BCM56504_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_11f_GET
#define FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_11f_SET BCM56504_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_11f_SET
#define FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_12f_GET BCM56504_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_12f_GET
#define FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_12f_SET BCM56504_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_12f_SET
#define FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_13f_GET BCM56504_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_13f_GET
#define FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_13f_SET BCM56504_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_13f_SET
#define FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_14f_GET BCM56504_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_14f_GET
#define FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_14f_SET BCM56504_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_14f_SET
#define FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_15f_GET BCM56504_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_15f_GET
#define FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_15f_SET BCM56504_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_15f_SET
#define READ_FP_CAM_BIST_ENABLEr BCM56504_A0_READ_FP_CAM_BIST_ENABLEr
#define WRITE_FP_CAM_BIST_ENABLEr BCM56504_A0_WRITE_FP_CAM_BIST_ENABLEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_FP_CAM_BIST_ENABLEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  FP_CAM_BIST_S10_STATUS
 * BLOCKS:   IPIPE
 * DESC:     FP_CAM_BIST_S10_STATUS
 * SIZE:     32
 * FIELDS:
 *     MATCH_STATUS     Match status
 *     AINDEX           Aindex when match happened
 *
 ******************************************************************************/
#define BCM56504_A0_FP_CAM_BIST_S10_STATUSr 0x0c780005

#define BCM56504_A0_FP_CAM_BIST_S10_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program FP_CAM_BIST_S10_STATUS.
 *
 */
typedef union BCM56504_A0_FP_CAM_BIST_S10_STATUSr_s {
	uint32_t v[1];
	uint32_t fp_cam_bist_s10_status[1];
	uint32_t _fp_cam_bist_s10_status;
} BCM56504_A0_FP_CAM_BIST_S10_STATUSr_t;

#define BCM56504_A0_FP_CAM_BIST_S10_STATUSr_CLR(r) (r).fp_cam_bist_s10_status[0] = 0
#define BCM56504_A0_FP_CAM_BIST_S10_STATUSr_SET(r,d) (r).fp_cam_bist_s10_status[0] = d
#define BCM56504_A0_FP_CAM_BIST_S10_STATUSr_GET(r) (r).fp_cam_bist_s10_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_FP_CAM_BIST_S10_STATUSr_MATCH_STATUSf_GET(r) (((r).fp_cam_bist_s10_status[0]) & 0x1)
#define BCM56504_A0_FP_CAM_BIST_S10_STATUSr_MATCH_STATUSf_SET(r,f) (r).fp_cam_bist_s10_status[0]=(((r).fp_cam_bist_s10_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_FP_CAM_BIST_S10_STATUSr_AINDEXf_GET(r) ((((r).fp_cam_bist_s10_status[0]) >> 1) & 0x7f)
#define BCM56504_A0_FP_CAM_BIST_S10_STATUSr_AINDEXf_SET(r,f) (r).fp_cam_bist_s10_status[0]=(((r).fp_cam_bist_s10_status[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))

/*
 * These macros can be used to access FP_CAM_BIST_S10_STATUS.
 *
 */
#define BCM56504_A0_READ_FP_CAM_BIST_S10_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_FP_CAM_BIST_S10_STATUSr,(r._fp_cam_bist_s10_status))
#define BCM56504_A0_WRITE_FP_CAM_BIST_S10_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_FP_CAM_BIST_S10_STATUSr,&(r._fp_cam_bist_s10_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_CAM_BIST_S10_STATUSr BCM56504_A0_FP_CAM_BIST_S10_STATUSr
#define FP_CAM_BIST_S10_STATUSr_SIZE BCM56504_A0_FP_CAM_BIST_S10_STATUSr_SIZE
typedef BCM56504_A0_FP_CAM_BIST_S10_STATUSr_t FP_CAM_BIST_S10_STATUSr_t;
#define FP_CAM_BIST_S10_STATUSr_CLR BCM56504_A0_FP_CAM_BIST_S10_STATUSr_CLR
#define FP_CAM_BIST_S10_STATUSr_SET BCM56504_A0_FP_CAM_BIST_S10_STATUSr_SET
#define FP_CAM_BIST_S10_STATUSr_GET BCM56504_A0_FP_CAM_BIST_S10_STATUSr_GET
#define FP_CAM_BIST_S10_STATUSr_MATCH_STATUSf_GET BCM56504_A0_FP_CAM_BIST_S10_STATUSr_MATCH_STATUSf_GET
#define FP_CAM_BIST_S10_STATUSr_MATCH_STATUSf_SET BCM56504_A0_FP_CAM_BIST_S10_STATUSr_MATCH_STATUSf_SET
#define FP_CAM_BIST_S10_STATUSr_AINDEXf_GET BCM56504_A0_FP_CAM_BIST_S10_STATUSr_AINDEXf_GET
#define FP_CAM_BIST_S10_STATUSr_AINDEXf_SET BCM56504_A0_FP_CAM_BIST_S10_STATUSr_AINDEXf_SET
#define READ_FP_CAM_BIST_S10_STATUSr BCM56504_A0_READ_FP_CAM_BIST_S10_STATUSr
#define WRITE_FP_CAM_BIST_S10_STATUSr BCM56504_A0_WRITE_FP_CAM_BIST_S10_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_FP_CAM_BIST_S10_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  FP_CAM_BIST_S12_STATUS
 * BLOCKS:   IPIPE
 * DESC:     FP_CAM_BIST_S12_STATUS
 * SIZE:     32
 * FIELDS:
 *     MATCH_STATUS     Match status
 *     AINDEX_STATUS    AIndex status
 *     ACTUAL_AINDEX    Actual AIndex when CAM reported a match
 *     EXPECTED_AINDEX  Expected AIndex
 *
 ******************************************************************************/
#define BCM56504_A0_FP_CAM_BIST_S12_STATUSr 0x0c780006

#define BCM56504_A0_FP_CAM_BIST_S12_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program FP_CAM_BIST_S12_STATUS.
 *
 */
typedef union BCM56504_A0_FP_CAM_BIST_S12_STATUSr_s {
	uint32_t v[1];
	uint32_t fp_cam_bist_s12_status[1];
	uint32_t _fp_cam_bist_s12_status;
} BCM56504_A0_FP_CAM_BIST_S12_STATUSr_t;

#define BCM56504_A0_FP_CAM_BIST_S12_STATUSr_CLR(r) (r).fp_cam_bist_s12_status[0] = 0
#define BCM56504_A0_FP_CAM_BIST_S12_STATUSr_SET(r,d) (r).fp_cam_bist_s12_status[0] = d
#define BCM56504_A0_FP_CAM_BIST_S12_STATUSr_GET(r) (r).fp_cam_bist_s12_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_FP_CAM_BIST_S12_STATUSr_MATCH_STATUSf_GET(r) (((r).fp_cam_bist_s12_status[0]) & 0x1)
#define BCM56504_A0_FP_CAM_BIST_S12_STATUSr_MATCH_STATUSf_SET(r,f) (r).fp_cam_bist_s12_status[0]=(((r).fp_cam_bist_s12_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_FP_CAM_BIST_S12_STATUSr_AINDEX_STATUSf_GET(r) ((((r).fp_cam_bist_s12_status[0]) >> 1) & 0x1)
#define BCM56504_A0_FP_CAM_BIST_S12_STATUSr_AINDEX_STATUSf_SET(r,f) (r).fp_cam_bist_s12_status[0]=(((r).fp_cam_bist_s12_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_FP_CAM_BIST_S12_STATUSr_ACTUAL_AINDEXf_GET(r) ((((r).fp_cam_bist_s12_status[0]) >> 2) & 0x7f)
#define BCM56504_A0_FP_CAM_BIST_S12_STATUSr_ACTUAL_AINDEXf_SET(r,f) (r).fp_cam_bist_s12_status[0]=(((r).fp_cam_bist_s12_status[0] & ~((uint32_t)0x7f << 2)) | ((((uint32_t)f) & 0x7f) << 2))
#define BCM56504_A0_FP_CAM_BIST_S12_STATUSr_EXPECTED_AINDEXf_GET(r) ((((r).fp_cam_bist_s12_status[0]) >> 9) & 0x7f)
#define BCM56504_A0_FP_CAM_BIST_S12_STATUSr_EXPECTED_AINDEXf_SET(r,f) (r).fp_cam_bist_s12_status[0]=(((r).fp_cam_bist_s12_status[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access FP_CAM_BIST_S12_STATUS.
 *
 */
#define BCM56504_A0_READ_FP_CAM_BIST_S12_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_FP_CAM_BIST_S12_STATUSr,(r._fp_cam_bist_s12_status))
#define BCM56504_A0_WRITE_FP_CAM_BIST_S12_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_FP_CAM_BIST_S12_STATUSr,&(r._fp_cam_bist_s12_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_CAM_BIST_S12_STATUSr BCM56504_A0_FP_CAM_BIST_S12_STATUSr
#define FP_CAM_BIST_S12_STATUSr_SIZE BCM56504_A0_FP_CAM_BIST_S12_STATUSr_SIZE
typedef BCM56504_A0_FP_CAM_BIST_S12_STATUSr_t FP_CAM_BIST_S12_STATUSr_t;
#define FP_CAM_BIST_S12_STATUSr_CLR BCM56504_A0_FP_CAM_BIST_S12_STATUSr_CLR
#define FP_CAM_BIST_S12_STATUSr_SET BCM56504_A0_FP_CAM_BIST_S12_STATUSr_SET
#define FP_CAM_BIST_S12_STATUSr_GET BCM56504_A0_FP_CAM_BIST_S12_STATUSr_GET
#define FP_CAM_BIST_S12_STATUSr_MATCH_STATUSf_GET BCM56504_A0_FP_CAM_BIST_S12_STATUSr_MATCH_STATUSf_GET
#define FP_CAM_BIST_S12_STATUSr_MATCH_STATUSf_SET BCM56504_A0_FP_CAM_BIST_S12_STATUSr_MATCH_STATUSf_SET
#define FP_CAM_BIST_S12_STATUSr_AINDEX_STATUSf_GET BCM56504_A0_FP_CAM_BIST_S12_STATUSr_AINDEX_STATUSf_GET
#define FP_CAM_BIST_S12_STATUSr_AINDEX_STATUSf_SET BCM56504_A0_FP_CAM_BIST_S12_STATUSr_AINDEX_STATUSf_SET
#define FP_CAM_BIST_S12_STATUSr_ACTUAL_AINDEXf_GET BCM56504_A0_FP_CAM_BIST_S12_STATUSr_ACTUAL_AINDEXf_GET
#define FP_CAM_BIST_S12_STATUSr_ACTUAL_AINDEXf_SET BCM56504_A0_FP_CAM_BIST_S12_STATUSr_ACTUAL_AINDEXf_SET
#define FP_CAM_BIST_S12_STATUSr_EXPECTED_AINDEXf_GET BCM56504_A0_FP_CAM_BIST_S12_STATUSr_EXPECTED_AINDEXf_GET
#define FP_CAM_BIST_S12_STATUSr_EXPECTED_AINDEXf_SET BCM56504_A0_FP_CAM_BIST_S12_STATUSr_EXPECTED_AINDEXf_SET
#define READ_FP_CAM_BIST_S12_STATUSr BCM56504_A0_READ_FP_CAM_BIST_S12_STATUSr
#define WRITE_FP_CAM_BIST_S12_STATUSr BCM56504_A0_WRITE_FP_CAM_BIST_S12_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_FP_CAM_BIST_S12_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  FP_CAM_BIST_S2_STATUS
 * BLOCKS:   IPIPE
 * DESC:     FP_CAM_BIST_S2_STATUS
 * SIZE:     32
 * FIELDS:
 *     MATCH_STATUS     Match status
 *     BIT_POS          Sliding Bit position when match happened
 *     AINDEX           Aindex when match happened
 *
 ******************************************************************************/
#define BCM56504_A0_FP_CAM_BIST_S2_STATUSr 0x0c780000

#define BCM56504_A0_FP_CAM_BIST_S2_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program FP_CAM_BIST_S2_STATUS.
 *
 */
typedef union BCM56504_A0_FP_CAM_BIST_S2_STATUSr_s {
	uint32_t v[1];
	uint32_t fp_cam_bist_s2_status[1];
	uint32_t _fp_cam_bist_s2_status;
} BCM56504_A0_FP_CAM_BIST_S2_STATUSr_t;

#define BCM56504_A0_FP_CAM_BIST_S2_STATUSr_CLR(r) (r).fp_cam_bist_s2_status[0] = 0
#define BCM56504_A0_FP_CAM_BIST_S2_STATUSr_SET(r,d) (r).fp_cam_bist_s2_status[0] = d
#define BCM56504_A0_FP_CAM_BIST_S2_STATUSr_GET(r) (r).fp_cam_bist_s2_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_FP_CAM_BIST_S2_STATUSr_MATCH_STATUSf_GET(r) (((r).fp_cam_bist_s2_status[0]) & 0x1)
#define BCM56504_A0_FP_CAM_BIST_S2_STATUSr_MATCH_STATUSf_SET(r,f) (r).fp_cam_bist_s2_status[0]=(((r).fp_cam_bist_s2_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_FP_CAM_BIST_S2_STATUSr_BIT_POSf_GET(r) ((((r).fp_cam_bist_s2_status[0]) >> 1) & 0xff)
#define BCM56504_A0_FP_CAM_BIST_S2_STATUSr_BIT_POSf_SET(r,f) (r).fp_cam_bist_s2_status[0]=(((r).fp_cam_bist_s2_status[0] & ~((uint32_t)0xff << 1)) | ((((uint32_t)f) & 0xff) << 1))
#define BCM56504_A0_FP_CAM_BIST_S2_STATUSr_AINDEXf_GET(r) ((((r).fp_cam_bist_s2_status[0]) >> 9) & 0x7f)
#define BCM56504_A0_FP_CAM_BIST_S2_STATUSr_AINDEXf_SET(r,f) (r).fp_cam_bist_s2_status[0]=(((r).fp_cam_bist_s2_status[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access FP_CAM_BIST_S2_STATUS.
 *
 */
#define BCM56504_A0_READ_FP_CAM_BIST_S2_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_FP_CAM_BIST_S2_STATUSr,(r._fp_cam_bist_s2_status))
#define BCM56504_A0_WRITE_FP_CAM_BIST_S2_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_FP_CAM_BIST_S2_STATUSr,&(r._fp_cam_bist_s2_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_CAM_BIST_S2_STATUSr BCM56504_A0_FP_CAM_BIST_S2_STATUSr
#define FP_CAM_BIST_S2_STATUSr_SIZE BCM56504_A0_FP_CAM_BIST_S2_STATUSr_SIZE
typedef BCM56504_A0_FP_CAM_BIST_S2_STATUSr_t FP_CAM_BIST_S2_STATUSr_t;
#define FP_CAM_BIST_S2_STATUSr_CLR BCM56504_A0_FP_CAM_BIST_S2_STATUSr_CLR
#define FP_CAM_BIST_S2_STATUSr_SET BCM56504_A0_FP_CAM_BIST_S2_STATUSr_SET
#define FP_CAM_BIST_S2_STATUSr_GET BCM56504_A0_FP_CAM_BIST_S2_STATUSr_GET
#define FP_CAM_BIST_S2_STATUSr_MATCH_STATUSf_GET BCM56504_A0_FP_CAM_BIST_S2_STATUSr_MATCH_STATUSf_GET
#define FP_CAM_BIST_S2_STATUSr_MATCH_STATUSf_SET BCM56504_A0_FP_CAM_BIST_S2_STATUSr_MATCH_STATUSf_SET
#define FP_CAM_BIST_S2_STATUSr_BIT_POSf_GET BCM56504_A0_FP_CAM_BIST_S2_STATUSr_BIT_POSf_GET
#define FP_CAM_BIST_S2_STATUSr_BIT_POSf_SET BCM56504_A0_FP_CAM_BIST_S2_STATUSr_BIT_POSf_SET
#define FP_CAM_BIST_S2_STATUSr_AINDEXf_GET BCM56504_A0_FP_CAM_BIST_S2_STATUSr_AINDEXf_GET
#define FP_CAM_BIST_S2_STATUSr_AINDEXf_SET BCM56504_A0_FP_CAM_BIST_S2_STATUSr_AINDEXf_SET
#define READ_FP_CAM_BIST_S2_STATUSr BCM56504_A0_READ_FP_CAM_BIST_S2_STATUSr
#define WRITE_FP_CAM_BIST_S2_STATUSr BCM56504_A0_WRITE_FP_CAM_BIST_S2_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_FP_CAM_BIST_S2_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  FP_CAM_BIST_S3_STATUS
 * BLOCKS:   IPIPE
 * DESC:     FP_CAM_BIST_S3_STATUS
 * SIZE:     32
 * FIELDS:
 *     MATCH_STATUS     Match status
 *     AINDEX_STATUS    AIndex status
 *     ACTUAL_AINDEX    Actual AIndex when CAM reported a match
 *     EXPECTED_AINDEX  Expected AIndex
 *
 ******************************************************************************/
#define BCM56504_A0_FP_CAM_BIST_S3_STATUSr 0x0c780001

#define BCM56504_A0_FP_CAM_BIST_S3_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program FP_CAM_BIST_S3_STATUS.
 *
 */
typedef union BCM56504_A0_FP_CAM_BIST_S3_STATUSr_s {
	uint32_t v[1];
	uint32_t fp_cam_bist_s3_status[1];
	uint32_t _fp_cam_bist_s3_status;
} BCM56504_A0_FP_CAM_BIST_S3_STATUSr_t;

#define BCM56504_A0_FP_CAM_BIST_S3_STATUSr_CLR(r) (r).fp_cam_bist_s3_status[0] = 0
#define BCM56504_A0_FP_CAM_BIST_S3_STATUSr_SET(r,d) (r).fp_cam_bist_s3_status[0] = d
#define BCM56504_A0_FP_CAM_BIST_S3_STATUSr_GET(r) (r).fp_cam_bist_s3_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_FP_CAM_BIST_S3_STATUSr_MATCH_STATUSf_GET(r) (((r).fp_cam_bist_s3_status[0]) & 0x1)
#define BCM56504_A0_FP_CAM_BIST_S3_STATUSr_MATCH_STATUSf_SET(r,f) (r).fp_cam_bist_s3_status[0]=(((r).fp_cam_bist_s3_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_FP_CAM_BIST_S3_STATUSr_AINDEX_STATUSf_GET(r) ((((r).fp_cam_bist_s3_status[0]) >> 1) & 0x1)
#define BCM56504_A0_FP_CAM_BIST_S3_STATUSr_AINDEX_STATUSf_SET(r,f) (r).fp_cam_bist_s3_status[0]=(((r).fp_cam_bist_s3_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_FP_CAM_BIST_S3_STATUSr_ACTUAL_AINDEXf_GET(r) ((((r).fp_cam_bist_s3_status[0]) >> 2) & 0x7f)
#define BCM56504_A0_FP_CAM_BIST_S3_STATUSr_ACTUAL_AINDEXf_SET(r,f) (r).fp_cam_bist_s3_status[0]=(((r).fp_cam_bist_s3_status[0] & ~((uint32_t)0x7f << 2)) | ((((uint32_t)f) & 0x7f) << 2))
#define BCM56504_A0_FP_CAM_BIST_S3_STATUSr_EXPECTED_AINDEXf_GET(r) ((((r).fp_cam_bist_s3_status[0]) >> 9) & 0x7f)
#define BCM56504_A0_FP_CAM_BIST_S3_STATUSr_EXPECTED_AINDEXf_SET(r,f) (r).fp_cam_bist_s3_status[0]=(((r).fp_cam_bist_s3_status[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access FP_CAM_BIST_S3_STATUS.
 *
 */
#define BCM56504_A0_READ_FP_CAM_BIST_S3_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_FP_CAM_BIST_S3_STATUSr,(r._fp_cam_bist_s3_status))
#define BCM56504_A0_WRITE_FP_CAM_BIST_S3_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_FP_CAM_BIST_S3_STATUSr,&(r._fp_cam_bist_s3_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_CAM_BIST_S3_STATUSr BCM56504_A0_FP_CAM_BIST_S3_STATUSr
#define FP_CAM_BIST_S3_STATUSr_SIZE BCM56504_A0_FP_CAM_BIST_S3_STATUSr_SIZE
typedef BCM56504_A0_FP_CAM_BIST_S3_STATUSr_t FP_CAM_BIST_S3_STATUSr_t;
#define FP_CAM_BIST_S3_STATUSr_CLR BCM56504_A0_FP_CAM_BIST_S3_STATUSr_CLR
#define FP_CAM_BIST_S3_STATUSr_SET BCM56504_A0_FP_CAM_BIST_S3_STATUSr_SET
#define FP_CAM_BIST_S3_STATUSr_GET BCM56504_A0_FP_CAM_BIST_S3_STATUSr_GET
#define FP_CAM_BIST_S3_STATUSr_MATCH_STATUSf_GET BCM56504_A0_FP_CAM_BIST_S3_STATUSr_MATCH_STATUSf_GET
#define FP_CAM_BIST_S3_STATUSr_MATCH_STATUSf_SET BCM56504_A0_FP_CAM_BIST_S3_STATUSr_MATCH_STATUSf_SET
#define FP_CAM_BIST_S3_STATUSr_AINDEX_STATUSf_GET BCM56504_A0_FP_CAM_BIST_S3_STATUSr_AINDEX_STATUSf_GET
#define FP_CAM_BIST_S3_STATUSr_AINDEX_STATUSf_SET BCM56504_A0_FP_CAM_BIST_S3_STATUSr_AINDEX_STATUSf_SET
#define FP_CAM_BIST_S3_STATUSr_ACTUAL_AINDEXf_GET BCM56504_A0_FP_CAM_BIST_S3_STATUSr_ACTUAL_AINDEXf_GET
#define FP_CAM_BIST_S3_STATUSr_ACTUAL_AINDEXf_SET BCM56504_A0_FP_CAM_BIST_S3_STATUSr_ACTUAL_AINDEXf_SET
#define FP_CAM_BIST_S3_STATUSr_EXPECTED_AINDEXf_GET BCM56504_A0_FP_CAM_BIST_S3_STATUSr_EXPECTED_AINDEXf_GET
#define FP_CAM_BIST_S3_STATUSr_EXPECTED_AINDEXf_SET BCM56504_A0_FP_CAM_BIST_S3_STATUSr_EXPECTED_AINDEXf_SET
#define READ_FP_CAM_BIST_S3_STATUSr BCM56504_A0_READ_FP_CAM_BIST_S3_STATUSr
#define WRITE_FP_CAM_BIST_S3_STATUSr BCM56504_A0_WRITE_FP_CAM_BIST_S3_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_FP_CAM_BIST_S3_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  FP_CAM_BIST_S5_STATUS
 * BLOCKS:   IPIPE
 * DESC:     FP_CAM_BIST_S5_STATUS
 * SIZE:     32
 * FIELDS:
 *     MATCH_STATUS     Match status
 *     BIT_POS          Sliding Bit position when match happened
 *     AINDEX           Aindex when match happened
 *
 ******************************************************************************/
#define BCM56504_A0_FP_CAM_BIST_S5_STATUSr 0x0c780002

#define BCM56504_A0_FP_CAM_BIST_S5_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program FP_CAM_BIST_S5_STATUS.
 *
 */
typedef union BCM56504_A0_FP_CAM_BIST_S5_STATUSr_s {
	uint32_t v[1];
	uint32_t fp_cam_bist_s5_status[1];
	uint32_t _fp_cam_bist_s5_status;
} BCM56504_A0_FP_CAM_BIST_S5_STATUSr_t;

#define BCM56504_A0_FP_CAM_BIST_S5_STATUSr_CLR(r) (r).fp_cam_bist_s5_status[0] = 0
#define BCM56504_A0_FP_CAM_BIST_S5_STATUSr_SET(r,d) (r).fp_cam_bist_s5_status[0] = d
#define BCM56504_A0_FP_CAM_BIST_S5_STATUSr_GET(r) (r).fp_cam_bist_s5_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_FP_CAM_BIST_S5_STATUSr_MATCH_STATUSf_GET(r) (((r).fp_cam_bist_s5_status[0]) & 0x1)
#define BCM56504_A0_FP_CAM_BIST_S5_STATUSr_MATCH_STATUSf_SET(r,f) (r).fp_cam_bist_s5_status[0]=(((r).fp_cam_bist_s5_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_FP_CAM_BIST_S5_STATUSr_BIT_POSf_GET(r) ((((r).fp_cam_bist_s5_status[0]) >> 1) & 0xff)
#define BCM56504_A0_FP_CAM_BIST_S5_STATUSr_BIT_POSf_SET(r,f) (r).fp_cam_bist_s5_status[0]=(((r).fp_cam_bist_s5_status[0] & ~((uint32_t)0xff << 1)) | ((((uint32_t)f) & 0xff) << 1))
#define BCM56504_A0_FP_CAM_BIST_S5_STATUSr_AINDEXf_GET(r) ((((r).fp_cam_bist_s5_status[0]) >> 9) & 0x7f)
#define BCM56504_A0_FP_CAM_BIST_S5_STATUSr_AINDEXf_SET(r,f) (r).fp_cam_bist_s5_status[0]=(((r).fp_cam_bist_s5_status[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access FP_CAM_BIST_S5_STATUS.
 *
 */
#define BCM56504_A0_READ_FP_CAM_BIST_S5_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_FP_CAM_BIST_S5_STATUSr,(r._fp_cam_bist_s5_status))
#define BCM56504_A0_WRITE_FP_CAM_BIST_S5_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_FP_CAM_BIST_S5_STATUSr,&(r._fp_cam_bist_s5_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_CAM_BIST_S5_STATUSr BCM56504_A0_FP_CAM_BIST_S5_STATUSr
#define FP_CAM_BIST_S5_STATUSr_SIZE BCM56504_A0_FP_CAM_BIST_S5_STATUSr_SIZE
typedef BCM56504_A0_FP_CAM_BIST_S5_STATUSr_t FP_CAM_BIST_S5_STATUSr_t;
#define FP_CAM_BIST_S5_STATUSr_CLR BCM56504_A0_FP_CAM_BIST_S5_STATUSr_CLR
#define FP_CAM_BIST_S5_STATUSr_SET BCM56504_A0_FP_CAM_BIST_S5_STATUSr_SET
#define FP_CAM_BIST_S5_STATUSr_GET BCM56504_A0_FP_CAM_BIST_S5_STATUSr_GET
#define FP_CAM_BIST_S5_STATUSr_MATCH_STATUSf_GET BCM56504_A0_FP_CAM_BIST_S5_STATUSr_MATCH_STATUSf_GET
#define FP_CAM_BIST_S5_STATUSr_MATCH_STATUSf_SET BCM56504_A0_FP_CAM_BIST_S5_STATUSr_MATCH_STATUSf_SET
#define FP_CAM_BIST_S5_STATUSr_BIT_POSf_GET BCM56504_A0_FP_CAM_BIST_S5_STATUSr_BIT_POSf_GET
#define FP_CAM_BIST_S5_STATUSr_BIT_POSf_SET BCM56504_A0_FP_CAM_BIST_S5_STATUSr_BIT_POSf_SET
#define FP_CAM_BIST_S5_STATUSr_AINDEXf_GET BCM56504_A0_FP_CAM_BIST_S5_STATUSr_AINDEXf_GET
#define FP_CAM_BIST_S5_STATUSr_AINDEXf_SET BCM56504_A0_FP_CAM_BIST_S5_STATUSr_AINDEXf_SET
#define READ_FP_CAM_BIST_S5_STATUSr BCM56504_A0_READ_FP_CAM_BIST_S5_STATUSr
#define WRITE_FP_CAM_BIST_S5_STATUSr BCM56504_A0_WRITE_FP_CAM_BIST_S5_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_FP_CAM_BIST_S5_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  FP_CAM_BIST_S6_STATUS
 * BLOCKS:   IPIPE
 * DESC:     FP_CAM_BIST_S6_STATUS
 * SIZE:     32
 * FIELDS:
 *     MATCH_STATUS     Match status
 *     AINDEX_STATUS    AIndex status
 *     ACTUAL_AINDEX    Actual AIndex when CAM reported a match
 *     EXPECTED_AINDEX  Expected AIndex
 *
 ******************************************************************************/
#define BCM56504_A0_FP_CAM_BIST_S6_STATUSr 0x0c780003

#define BCM56504_A0_FP_CAM_BIST_S6_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program FP_CAM_BIST_S6_STATUS.
 *
 */
typedef union BCM56504_A0_FP_CAM_BIST_S6_STATUSr_s {
	uint32_t v[1];
	uint32_t fp_cam_bist_s6_status[1];
	uint32_t _fp_cam_bist_s6_status;
} BCM56504_A0_FP_CAM_BIST_S6_STATUSr_t;

#define BCM56504_A0_FP_CAM_BIST_S6_STATUSr_CLR(r) (r).fp_cam_bist_s6_status[0] = 0
#define BCM56504_A0_FP_CAM_BIST_S6_STATUSr_SET(r,d) (r).fp_cam_bist_s6_status[0] = d
#define BCM56504_A0_FP_CAM_BIST_S6_STATUSr_GET(r) (r).fp_cam_bist_s6_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_FP_CAM_BIST_S6_STATUSr_MATCH_STATUSf_GET(r) (((r).fp_cam_bist_s6_status[0]) & 0x1)
#define BCM56504_A0_FP_CAM_BIST_S6_STATUSr_MATCH_STATUSf_SET(r,f) (r).fp_cam_bist_s6_status[0]=(((r).fp_cam_bist_s6_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_FP_CAM_BIST_S6_STATUSr_AINDEX_STATUSf_GET(r) ((((r).fp_cam_bist_s6_status[0]) >> 1) & 0x1)
#define BCM56504_A0_FP_CAM_BIST_S6_STATUSr_AINDEX_STATUSf_SET(r,f) (r).fp_cam_bist_s6_status[0]=(((r).fp_cam_bist_s6_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_FP_CAM_BIST_S6_STATUSr_ACTUAL_AINDEXf_GET(r) ((((r).fp_cam_bist_s6_status[0]) >> 2) & 0x7f)
#define BCM56504_A0_FP_CAM_BIST_S6_STATUSr_ACTUAL_AINDEXf_SET(r,f) (r).fp_cam_bist_s6_status[0]=(((r).fp_cam_bist_s6_status[0] & ~((uint32_t)0x7f << 2)) | ((((uint32_t)f) & 0x7f) << 2))
#define BCM56504_A0_FP_CAM_BIST_S6_STATUSr_EXPECTED_AINDEXf_GET(r) ((((r).fp_cam_bist_s6_status[0]) >> 9) & 0x7f)
#define BCM56504_A0_FP_CAM_BIST_S6_STATUSr_EXPECTED_AINDEXf_SET(r,f) (r).fp_cam_bist_s6_status[0]=(((r).fp_cam_bist_s6_status[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access FP_CAM_BIST_S6_STATUS.
 *
 */
#define BCM56504_A0_READ_FP_CAM_BIST_S6_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_FP_CAM_BIST_S6_STATUSr,(r._fp_cam_bist_s6_status))
#define BCM56504_A0_WRITE_FP_CAM_BIST_S6_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_FP_CAM_BIST_S6_STATUSr,&(r._fp_cam_bist_s6_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_CAM_BIST_S6_STATUSr BCM56504_A0_FP_CAM_BIST_S6_STATUSr
#define FP_CAM_BIST_S6_STATUSr_SIZE BCM56504_A0_FP_CAM_BIST_S6_STATUSr_SIZE
typedef BCM56504_A0_FP_CAM_BIST_S6_STATUSr_t FP_CAM_BIST_S6_STATUSr_t;
#define FP_CAM_BIST_S6_STATUSr_CLR BCM56504_A0_FP_CAM_BIST_S6_STATUSr_CLR
#define FP_CAM_BIST_S6_STATUSr_SET BCM56504_A0_FP_CAM_BIST_S6_STATUSr_SET
#define FP_CAM_BIST_S6_STATUSr_GET BCM56504_A0_FP_CAM_BIST_S6_STATUSr_GET
#define FP_CAM_BIST_S6_STATUSr_MATCH_STATUSf_GET BCM56504_A0_FP_CAM_BIST_S6_STATUSr_MATCH_STATUSf_GET
#define FP_CAM_BIST_S6_STATUSr_MATCH_STATUSf_SET BCM56504_A0_FP_CAM_BIST_S6_STATUSr_MATCH_STATUSf_SET
#define FP_CAM_BIST_S6_STATUSr_AINDEX_STATUSf_GET BCM56504_A0_FP_CAM_BIST_S6_STATUSr_AINDEX_STATUSf_GET
#define FP_CAM_BIST_S6_STATUSr_AINDEX_STATUSf_SET BCM56504_A0_FP_CAM_BIST_S6_STATUSr_AINDEX_STATUSf_SET
#define FP_CAM_BIST_S6_STATUSr_ACTUAL_AINDEXf_GET BCM56504_A0_FP_CAM_BIST_S6_STATUSr_ACTUAL_AINDEXf_GET
#define FP_CAM_BIST_S6_STATUSr_ACTUAL_AINDEXf_SET BCM56504_A0_FP_CAM_BIST_S6_STATUSr_ACTUAL_AINDEXf_SET
#define FP_CAM_BIST_S6_STATUSr_EXPECTED_AINDEXf_GET BCM56504_A0_FP_CAM_BIST_S6_STATUSr_EXPECTED_AINDEXf_GET
#define FP_CAM_BIST_S6_STATUSr_EXPECTED_AINDEXf_SET BCM56504_A0_FP_CAM_BIST_S6_STATUSr_EXPECTED_AINDEXf_SET
#define READ_FP_CAM_BIST_S6_STATUSr BCM56504_A0_READ_FP_CAM_BIST_S6_STATUSr
#define WRITE_FP_CAM_BIST_S6_STATUSr BCM56504_A0_WRITE_FP_CAM_BIST_S6_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_FP_CAM_BIST_S6_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  FP_CAM_BIST_S8_STATUS
 * BLOCKS:   IPIPE
 * DESC:     FP_CAM_BIST_S8_STATUS
 * SIZE:     32
 * FIELDS:
 *     MATCH_STATUS     Match status
 *     AINDEX_STATUS    AIndex status
 *     ACTUAL_AINDEX    Actual AIndex when CAM reported a match
 *     EXPECTED_AINDEX  Expected AIndex
 *
 ******************************************************************************/
#define BCM56504_A0_FP_CAM_BIST_S8_STATUSr 0x0c780004

#define BCM56504_A0_FP_CAM_BIST_S8_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program FP_CAM_BIST_S8_STATUS.
 *
 */
typedef union BCM56504_A0_FP_CAM_BIST_S8_STATUSr_s {
	uint32_t v[1];
	uint32_t fp_cam_bist_s8_status[1];
	uint32_t _fp_cam_bist_s8_status;
} BCM56504_A0_FP_CAM_BIST_S8_STATUSr_t;

#define BCM56504_A0_FP_CAM_BIST_S8_STATUSr_CLR(r) (r).fp_cam_bist_s8_status[0] = 0
#define BCM56504_A0_FP_CAM_BIST_S8_STATUSr_SET(r,d) (r).fp_cam_bist_s8_status[0] = d
#define BCM56504_A0_FP_CAM_BIST_S8_STATUSr_GET(r) (r).fp_cam_bist_s8_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_FP_CAM_BIST_S8_STATUSr_MATCH_STATUSf_GET(r) (((r).fp_cam_bist_s8_status[0]) & 0x1)
#define BCM56504_A0_FP_CAM_BIST_S8_STATUSr_MATCH_STATUSf_SET(r,f) (r).fp_cam_bist_s8_status[0]=(((r).fp_cam_bist_s8_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_FP_CAM_BIST_S8_STATUSr_AINDEX_STATUSf_GET(r) ((((r).fp_cam_bist_s8_status[0]) >> 1) & 0x1)
#define BCM56504_A0_FP_CAM_BIST_S8_STATUSr_AINDEX_STATUSf_SET(r,f) (r).fp_cam_bist_s8_status[0]=(((r).fp_cam_bist_s8_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_FP_CAM_BIST_S8_STATUSr_ACTUAL_AINDEXf_GET(r) ((((r).fp_cam_bist_s8_status[0]) >> 2) & 0x7f)
#define BCM56504_A0_FP_CAM_BIST_S8_STATUSr_ACTUAL_AINDEXf_SET(r,f) (r).fp_cam_bist_s8_status[0]=(((r).fp_cam_bist_s8_status[0] & ~((uint32_t)0x7f << 2)) | ((((uint32_t)f) & 0x7f) << 2))
#define BCM56504_A0_FP_CAM_BIST_S8_STATUSr_EXPECTED_AINDEXf_GET(r) ((((r).fp_cam_bist_s8_status[0]) >> 9) & 0x7f)
#define BCM56504_A0_FP_CAM_BIST_S8_STATUSr_EXPECTED_AINDEXf_SET(r,f) (r).fp_cam_bist_s8_status[0]=(((r).fp_cam_bist_s8_status[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access FP_CAM_BIST_S8_STATUS.
 *
 */
#define BCM56504_A0_READ_FP_CAM_BIST_S8_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_FP_CAM_BIST_S8_STATUSr,(r._fp_cam_bist_s8_status))
#define BCM56504_A0_WRITE_FP_CAM_BIST_S8_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_FP_CAM_BIST_S8_STATUSr,&(r._fp_cam_bist_s8_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_CAM_BIST_S8_STATUSr BCM56504_A0_FP_CAM_BIST_S8_STATUSr
#define FP_CAM_BIST_S8_STATUSr_SIZE BCM56504_A0_FP_CAM_BIST_S8_STATUSr_SIZE
typedef BCM56504_A0_FP_CAM_BIST_S8_STATUSr_t FP_CAM_BIST_S8_STATUSr_t;
#define FP_CAM_BIST_S8_STATUSr_CLR BCM56504_A0_FP_CAM_BIST_S8_STATUSr_CLR
#define FP_CAM_BIST_S8_STATUSr_SET BCM56504_A0_FP_CAM_BIST_S8_STATUSr_SET
#define FP_CAM_BIST_S8_STATUSr_GET BCM56504_A0_FP_CAM_BIST_S8_STATUSr_GET
#define FP_CAM_BIST_S8_STATUSr_MATCH_STATUSf_GET BCM56504_A0_FP_CAM_BIST_S8_STATUSr_MATCH_STATUSf_GET
#define FP_CAM_BIST_S8_STATUSr_MATCH_STATUSf_SET BCM56504_A0_FP_CAM_BIST_S8_STATUSr_MATCH_STATUSf_SET
#define FP_CAM_BIST_S8_STATUSr_AINDEX_STATUSf_GET BCM56504_A0_FP_CAM_BIST_S8_STATUSr_AINDEX_STATUSf_GET
#define FP_CAM_BIST_S8_STATUSr_AINDEX_STATUSf_SET BCM56504_A0_FP_CAM_BIST_S8_STATUSr_AINDEX_STATUSf_SET
#define FP_CAM_BIST_S8_STATUSr_ACTUAL_AINDEXf_GET BCM56504_A0_FP_CAM_BIST_S8_STATUSr_ACTUAL_AINDEXf_GET
#define FP_CAM_BIST_S8_STATUSr_ACTUAL_AINDEXf_SET BCM56504_A0_FP_CAM_BIST_S8_STATUSr_ACTUAL_AINDEXf_SET
#define FP_CAM_BIST_S8_STATUSr_EXPECTED_AINDEXf_GET BCM56504_A0_FP_CAM_BIST_S8_STATUSr_EXPECTED_AINDEXf_GET
#define FP_CAM_BIST_S8_STATUSr_EXPECTED_AINDEXf_SET BCM56504_A0_FP_CAM_BIST_S8_STATUSr_EXPECTED_AINDEXf_SET
#define READ_FP_CAM_BIST_S8_STATUSr BCM56504_A0_READ_FP_CAM_BIST_S8_STATUSr
#define WRITE_FP_CAM_BIST_S8_STATUSr BCM56504_A0_WRITE_FP_CAM_BIST_S8_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_FP_CAM_BIST_S8_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  FP_CAM_BIST_STATUS
 * BLOCKS:   IPIPE
 * DESC:     FP_CAM_BIST_STATUS
 * SIZE:     32
 * FIELDS:
 *     FP_CAM_BIST_GO   CAM_BIST_GO_STATUS
 *     FP_CAM_BIST_DONE CAM_BIST_DONE_STATUS
 *
 ******************************************************************************/
#define BCM56504_A0_FP_CAM_BIST_STATUSr 0x0c780007

#define BCM56504_A0_FP_CAM_BIST_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program FP_CAM_BIST_STATUS.
 *
 */
typedef union BCM56504_A0_FP_CAM_BIST_STATUSr_s {
	uint32_t v[1];
	uint32_t fp_cam_bist_status[1];
	uint32_t _fp_cam_bist_status;
} BCM56504_A0_FP_CAM_BIST_STATUSr_t;

#define BCM56504_A0_FP_CAM_BIST_STATUSr_CLR(r) (r).fp_cam_bist_status[0] = 0
#define BCM56504_A0_FP_CAM_BIST_STATUSr_SET(r,d) (r).fp_cam_bist_status[0] = d
#define BCM56504_A0_FP_CAM_BIST_STATUSr_GET(r) (r).fp_cam_bist_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_FP_CAM_BIST_STATUSr_FP_CAM_BIST_GOf_GET(r) (((r).fp_cam_bist_status[0]) & 0x1)
#define BCM56504_A0_FP_CAM_BIST_STATUSr_FP_CAM_BIST_GOf_SET(r,f) (r).fp_cam_bist_status[0]=(((r).fp_cam_bist_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_FP_CAM_BIST_STATUSr_FP_CAM_BIST_DONEf_GET(r) ((((r).fp_cam_bist_status[0]) >> 1) & 0x1)
#define BCM56504_A0_FP_CAM_BIST_STATUSr_FP_CAM_BIST_DONEf_SET(r,f) (r).fp_cam_bist_status[0]=(((r).fp_cam_bist_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access FP_CAM_BIST_STATUS.
 *
 */
#define BCM56504_A0_READ_FP_CAM_BIST_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_FP_CAM_BIST_STATUSr,(r._fp_cam_bist_status))
#define BCM56504_A0_WRITE_FP_CAM_BIST_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_FP_CAM_BIST_STATUSr,&(r._fp_cam_bist_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_CAM_BIST_STATUSr BCM56504_A0_FP_CAM_BIST_STATUSr
#define FP_CAM_BIST_STATUSr_SIZE BCM56504_A0_FP_CAM_BIST_STATUSr_SIZE
typedef BCM56504_A0_FP_CAM_BIST_STATUSr_t FP_CAM_BIST_STATUSr_t;
#define FP_CAM_BIST_STATUSr_CLR BCM56504_A0_FP_CAM_BIST_STATUSr_CLR
#define FP_CAM_BIST_STATUSr_SET BCM56504_A0_FP_CAM_BIST_STATUSr_SET
#define FP_CAM_BIST_STATUSr_GET BCM56504_A0_FP_CAM_BIST_STATUSr_GET
#define FP_CAM_BIST_STATUSr_FP_CAM_BIST_GOf_GET BCM56504_A0_FP_CAM_BIST_STATUSr_FP_CAM_BIST_GOf_GET
#define FP_CAM_BIST_STATUSr_FP_CAM_BIST_GOf_SET BCM56504_A0_FP_CAM_BIST_STATUSr_FP_CAM_BIST_GOf_SET
#define FP_CAM_BIST_STATUSr_FP_CAM_BIST_DONEf_GET BCM56504_A0_FP_CAM_BIST_STATUSr_FP_CAM_BIST_DONEf_GET
#define FP_CAM_BIST_STATUSr_FP_CAM_BIST_DONEf_SET BCM56504_A0_FP_CAM_BIST_STATUSr_FP_CAM_BIST_DONEf_SET
#define READ_FP_CAM_BIST_STATUSr BCM56504_A0_READ_FP_CAM_BIST_STATUSr
#define WRITE_FP_CAM_BIST_STATUSr BCM56504_A0_WRITE_FP_CAM_BIST_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_FP_CAM_BIST_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  FP_CAM_CONTROL_LOWER
 * BLOCKS:   IPIPE
 * DESC:     FP_CAM_CONTROL_LOWER
 * SIZE:     32
 * FIELDS:
 *     FP_CAM_CONTROL_SLICE_0 FP_CAM_CONTROL FOR FP SLICE 0
 *     FP_CAM_CONTROL_SLICE_1 FP_CAM_CONTROL FOR FP SLICE 1
 *     FP_CAM_CONTROL_SLICE_2 FP_CAM_CONTROL FOR FP SLICE 2
 *     FP_CAM_CONTROL_SLICE_3 FP_CAM_CONTROL FOR FP SLICE 3
 *     FP_CAM_CONTROL_SLICE_4 FP_CAM_CONTROL FOR FP SLICE 4
 *     FP_CAM_CONTROL_SLICE_5 FP_CAM_CONTROL FOR FP SLICE 5
 *     FP_CAM_CONTROL_SLICE_6 FP_CAM_CONTROL FOR FP SLICE 6
 *     FP_CAM_CONTROL_SLICE_7 FP_CAM_CONTROL FOR FP SLICE 7
 *
 ******************************************************************************/
#define BCM56504_A0_FP_CAM_CONTROL_LOWERr 0x0c78000b

#define BCM56504_A0_FP_CAM_CONTROL_LOWERr_SIZE 4

/*
 * This structure should be used to declare and program FP_CAM_CONTROL_LOWER.
 *
 */
typedef union BCM56504_A0_FP_CAM_CONTROL_LOWERr_s {
	uint32_t v[1];
	uint32_t fp_cam_control_lower[1];
	uint32_t _fp_cam_control_lower;
} BCM56504_A0_FP_CAM_CONTROL_LOWERr_t;

#define BCM56504_A0_FP_CAM_CONTROL_LOWERr_CLR(r) (r).fp_cam_control_lower[0] = 0
#define BCM56504_A0_FP_CAM_CONTROL_LOWERr_SET(r,d) (r).fp_cam_control_lower[0] = d
#define BCM56504_A0_FP_CAM_CONTROL_LOWERr_GET(r) (r).fp_cam_control_lower[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_0f_GET(r) (((r).fp_cam_control_lower[0]) & 0x7)
#define BCM56504_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_0f_SET(r,f) (r).fp_cam_control_lower[0]=(((r).fp_cam_control_lower[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM56504_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_1f_GET(r) ((((r).fp_cam_control_lower[0]) >> 3) & 0x7)
#define BCM56504_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_1f_SET(r,f) (r).fp_cam_control_lower[0]=(((r).fp_cam_control_lower[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM56504_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_2f_GET(r) ((((r).fp_cam_control_lower[0]) >> 6) & 0x7)
#define BCM56504_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_2f_SET(r,f) (r).fp_cam_control_lower[0]=(((r).fp_cam_control_lower[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM56504_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_3f_GET(r) ((((r).fp_cam_control_lower[0]) >> 9) & 0x7)
#define BCM56504_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_3f_SET(r,f) (r).fp_cam_control_lower[0]=(((r).fp_cam_control_lower[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM56504_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_4f_GET(r) ((((r).fp_cam_control_lower[0]) >> 12) & 0x7)
#define BCM56504_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_4f_SET(r,f) (r).fp_cam_control_lower[0]=(((r).fp_cam_control_lower[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM56504_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_5f_GET(r) ((((r).fp_cam_control_lower[0]) >> 15) & 0x7)
#define BCM56504_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_5f_SET(r,f) (r).fp_cam_control_lower[0]=(((r).fp_cam_control_lower[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM56504_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_6f_GET(r) ((((r).fp_cam_control_lower[0]) >> 18) & 0x7)
#define BCM56504_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_6f_SET(r,f) (r).fp_cam_control_lower[0]=(((r).fp_cam_control_lower[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM56504_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_7f_GET(r) ((((r).fp_cam_control_lower[0]) >> 21) & 0x7)
#define BCM56504_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_7f_SET(r,f) (r).fp_cam_control_lower[0]=(((r).fp_cam_control_lower[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))

/*
 * These macros can be used to access FP_CAM_CONTROL_LOWER.
 *
 */
#define BCM56504_A0_READ_FP_CAM_CONTROL_LOWERr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_FP_CAM_CONTROL_LOWERr,(r._fp_cam_control_lower))
#define BCM56504_A0_WRITE_FP_CAM_CONTROL_LOWERr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_FP_CAM_CONTROL_LOWERr,&(r._fp_cam_control_lower))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_CAM_CONTROL_LOWERr BCM56504_A0_FP_CAM_CONTROL_LOWERr
#define FP_CAM_CONTROL_LOWERr_SIZE BCM56504_A0_FP_CAM_CONTROL_LOWERr_SIZE
typedef BCM56504_A0_FP_CAM_CONTROL_LOWERr_t FP_CAM_CONTROL_LOWERr_t;
#define FP_CAM_CONTROL_LOWERr_CLR BCM56504_A0_FP_CAM_CONTROL_LOWERr_CLR
#define FP_CAM_CONTROL_LOWERr_SET BCM56504_A0_FP_CAM_CONTROL_LOWERr_SET
#define FP_CAM_CONTROL_LOWERr_GET BCM56504_A0_FP_CAM_CONTROL_LOWERr_GET
#define FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_0f_GET BCM56504_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_0f_GET
#define FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_0f_SET BCM56504_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_0f_SET
#define FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_1f_GET BCM56504_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_1f_GET
#define FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_1f_SET BCM56504_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_1f_SET
#define FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_2f_GET BCM56504_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_2f_GET
#define FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_2f_SET BCM56504_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_2f_SET
#define FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_3f_GET BCM56504_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_3f_GET
#define FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_3f_SET BCM56504_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_3f_SET
#define FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_4f_GET BCM56504_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_4f_GET
#define FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_4f_SET BCM56504_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_4f_SET
#define FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_5f_GET BCM56504_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_5f_GET
#define FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_5f_SET BCM56504_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_5f_SET
#define FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_6f_GET BCM56504_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_6f_GET
#define FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_6f_SET BCM56504_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_6f_SET
#define FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_7f_GET BCM56504_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_7f_GET
#define FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_7f_SET BCM56504_A0_FP_CAM_CONTROL_LOWERr_FP_CAM_CONTROL_SLICE_7f_SET
#define READ_FP_CAM_CONTROL_LOWERr BCM56504_A0_READ_FP_CAM_CONTROL_LOWERr
#define WRITE_FP_CAM_CONTROL_LOWERr BCM56504_A0_WRITE_FP_CAM_CONTROL_LOWERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_FP_CAM_CONTROL_LOWERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  FP_CAM_CONTROL_UPPER
 * BLOCKS:   IPIPE
 * DESC:     FP_CAM_CONTROL_UPPER
 * SIZE:     32
 * FIELDS:
 *     FP_CAM_CONTROL_SLICE_8 FP_CAM_CONTROL FOR FP SLICE 8
 *     FP_CAM_CONTROL_SLICE_9 FP_CAM_CONTROL FOR FP SLICE 9
 *     FP_CAM_CONTROL_SLICE_10 FP_CAM_CONTROL FOR FP SLICE 10
 *     FP_CAM_CONTROL_SLICE_11 FP_CAM_CONTROL FOR FP SLICE 11
 *     FP_CAM_CONTROL_SLICE_12 FP_CAM_CONTROL FOR FP SLICE 12
 *     FP_CAM_CONTROL_SLICE_13 FP_CAM_CONTROL FOR FP SLICE 13
 *     FP_CAM_CONTROL_SLICE_14 FP_CAM_CONTROL FOR FP SLICE 14
 *     FP_CAM_CONTROL_SLICE_15 FP_CAM_CONTROL FOR FP SLICE 15
 *     SECRET_CHAIN_MODE ENABLES SECRET CHAINING MODE FOR ENTIRE FP.  THE DEFAULT VALUE IS DISABLED.
 *
 ******************************************************************************/
#define BCM56504_A0_FP_CAM_CONTROL_UPPERr 0x0c78000a

#define BCM56504_A0_FP_CAM_CONTROL_UPPERr_SIZE 4

/*
 * This structure should be used to declare and program FP_CAM_CONTROL_UPPER.
 *
 */
typedef union BCM56504_A0_FP_CAM_CONTROL_UPPERr_s {
	uint32_t v[1];
	uint32_t fp_cam_control_upper[1];
	uint32_t _fp_cam_control_upper;
} BCM56504_A0_FP_CAM_CONTROL_UPPERr_t;

#define BCM56504_A0_FP_CAM_CONTROL_UPPERr_CLR(r) (r).fp_cam_control_upper[0] = 0
#define BCM56504_A0_FP_CAM_CONTROL_UPPERr_SET(r,d) (r).fp_cam_control_upper[0] = d
#define BCM56504_A0_FP_CAM_CONTROL_UPPERr_GET(r) (r).fp_cam_control_upper[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_FP_CAM_CONTROL_UPPERr_FP_CAM_CONTROL_SLICE_8f_GET(r) (((r).fp_cam_control_upper[0]) & 0x7)
#define BCM56504_A0_FP_CAM_CONTROL_UPPERr_FP_CAM_CONTROL_SLICE_8f_SET(r,f) (r).fp_cam_control_upper[0]=(((r).fp_cam_control_upper[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM56504_A0_FP_CAM_CONTROL_UPPERr_FP_CAM_CONTROL_SLICE_9f_GET(r) ((((r).fp_cam_control_upper[0]) >> 3) & 0x7)
#define BCM56504_A0_FP_CAM_CONTROL_UPPERr_FP_CAM_CONTROL_SLICE_9f_SET(r,f) (r).fp_cam_control_upper[0]=(((r).fp_cam_control_upper[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM56504_A0_FP_CAM_CONTROL_UPPERr_FP_CAM_CONTROL_SLICE_10f_GET(r) ((((r).fp_cam_control_upper[0]) >> 6) & 0x7)
#define BCM56504_A0_FP_CAM_CONTROL_UPPERr_FP_CAM_CONTROL_SLICE_10f_SET(r,f) (r).fp_cam_control_upper[0]=(((r).fp_cam_control_upper[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM56504_A0_FP_CAM_CONTROL_UPPERr_FP_CAM_CONTROL_SLICE_11f_GET(r) ((((r).fp_cam_control_upper[0]) >> 9) & 0x7)
#define BCM56504_A0_FP_CAM_CONTROL_UPPERr_FP_CAM_CONTROL_SLICE_11f_SET(r,f) (r).fp_cam_control_upper[0]=(((r).fp_cam_control_upper[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM56504_A0_FP_CAM_CONTROL_UPPERr_FP_CAM_CONTROL_SLICE_12f_GET(r) ((((r).fp_cam_control_upper[0]) >> 12) & 0x7)
#define BCM56504_A0_FP_CAM_CONTROL_UPPERr_FP_CAM_CONTROL_SLICE_12f_SET(r,f) (r).fp_cam_control_upper[0]=(((r).fp_cam_control_upper[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM56504_A0_FP_CAM_CONTROL_UPPERr_FP_CAM_CONTROL_SLICE_13f_GET(r) ((((r).fp_cam_control_upper[0]) >> 15) & 0x7)
#define BCM56504_A0_FP_CAM_CONTROL_UPPERr_FP_CAM_CONTROL_SLICE_13f_SET(r,f) (r).fp_cam_control_upper[0]=(((r).fp_cam_control_upper[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM56504_A0_FP_CAM_CONTROL_UPPERr_FP_CAM_CONTROL_SLICE_14f_GET(r) ((((r).fp_cam_control_upper[0]) >> 18) & 0x7)
#define BCM56504_A0_FP_CAM_CONTROL_UPPERr_FP_CAM_CONTROL_SLICE_14f_SET(r,f) (r).fp_cam_control_upper[0]=(((r).fp_cam_control_upper[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM56504_A0_FP_CAM_CONTROL_UPPERr_FP_CAM_CONTROL_SLICE_15f_GET(r) ((((r).fp_cam_control_upper[0]) >> 21) & 0x7)
#define BCM56504_A0_FP_CAM_CONTROL_UPPERr_FP_CAM_CONTROL_SLICE_15f_SET(r,f) (r).fp_cam_control_upper[0]=(((r).fp_cam_control_upper[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM56504_A0_FP_CAM_CONTROL_UPPERr_SECRET_CHAIN_MODEf_GET(r) ((((r).fp_cam_control_upper[0]) >> 24) & 0x1)
#define BCM56504_A0_FP_CAM_CONTROL_UPPERr_SECRET_CHAIN_MODEf_SET(r,f) (r).fp_cam_control_upper[0]=(((r).fp_cam_control_upper[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))

/*
 * These macros can be used to access FP_CAM_CONTROL_UPPER.
 *
 */
#define BCM56504_A0_READ_FP_CAM_CONTROL_UPPERr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_FP_CAM_CONTROL_UPPERr,(r._fp_cam_control_upper))
#define BCM56504_A0_WRITE_FP_CAM_CONTROL_UPPERr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_FP_CAM_CONTROL_UPPERr,&(r._fp_cam_control_upper))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_CAM_CONTROL_UPPERr BCM56504_A0_FP_CAM_CONTROL_UPPERr
#define FP_CAM_CONTROL_UPPERr_SIZE BCM56504_A0_FP_CAM_CONTROL_UPPERr_SIZE
typedef BCM56504_A0_FP_CAM_CONTROL_UPPERr_t FP_CAM_CONTROL_UPPERr_t;
#define FP_CAM_CONTROL_UPPERr_CLR BCM56504_A0_FP_CAM_CONTROL_UPPERr_CLR
#define FP_CAM_CONTROL_UPPERr_SET BCM56504_A0_FP_CAM_CONTROL_UPPERr_SET
#define FP_CAM_CONTROL_UPPERr_GET BCM56504_A0_FP_CAM_CONTROL_UPPERr_GET
#define FP_CAM_CONTROL_UPPERr_FP_CAM_CONTROL_SLICE_8f_GET BCM56504_A0_FP_CAM_CONTROL_UPPERr_FP_CAM_CONTROL_SLICE_8f_GET
#define FP_CAM_CONTROL_UPPERr_FP_CAM_CONTROL_SLICE_8f_SET BCM56504_A0_FP_CAM_CONTROL_UPPERr_FP_CAM_CONTROL_SLICE_8f_SET
#define FP_CAM_CONTROL_UPPERr_FP_CAM_CONTROL_SLICE_9f_GET BCM56504_A0_FP_CAM_CONTROL_UPPERr_FP_CAM_CONTROL_SLICE_9f_GET
#define FP_CAM_CONTROL_UPPERr_FP_CAM_CONTROL_SLICE_9f_SET BCM56504_A0_FP_CAM_CONTROL_UPPERr_FP_CAM_CONTROL_SLICE_9f_SET
#define FP_CAM_CONTROL_UPPERr_FP_CAM_CONTROL_SLICE_10f_GET BCM56504_A0_FP_CAM_CONTROL_UPPERr_FP_CAM_CONTROL_SLICE_10f_GET
#define FP_CAM_CONTROL_UPPERr_FP_CAM_CONTROL_SLICE_10f_SET BCM56504_A0_FP_CAM_CONTROL_UPPERr_FP_CAM_CONTROL_SLICE_10f_SET
#define FP_CAM_CONTROL_UPPERr_FP_CAM_CONTROL_SLICE_11f_GET BCM56504_A0_FP_CAM_CONTROL_UPPERr_FP_CAM_CONTROL_SLICE_11f_GET
#define FP_CAM_CONTROL_UPPERr_FP_CAM_CONTROL_SLICE_11f_SET BCM56504_A0_FP_CAM_CONTROL_UPPERr_FP_CAM_CONTROL_SLICE_11f_SET
#define FP_CAM_CONTROL_UPPERr_FP_CAM_CONTROL_SLICE_12f_GET BCM56504_A0_FP_CAM_CONTROL_UPPERr_FP_CAM_CONTROL_SLICE_12f_GET
#define FP_CAM_CONTROL_UPPERr_FP_CAM_CONTROL_SLICE_12f_SET BCM56504_A0_FP_CAM_CONTROL_UPPERr_FP_CAM_CONTROL_SLICE_12f_SET
#define FP_CAM_CONTROL_UPPERr_FP_CAM_CONTROL_SLICE_13f_GET BCM56504_A0_FP_CAM_CONTROL_UPPERr_FP_CAM_CONTROL_SLICE_13f_GET
#define FP_CAM_CONTROL_UPPERr_FP_CAM_CONTROL_SLICE_13f_SET BCM56504_A0_FP_CAM_CONTROL_UPPERr_FP_CAM_CONTROL_SLICE_13f_SET
#define FP_CAM_CONTROL_UPPERr_FP_CAM_CONTROL_SLICE_14f_GET BCM56504_A0_FP_CAM_CONTROL_UPPERr_FP_CAM_CONTROL_SLICE_14f_GET
#define FP_CAM_CONTROL_UPPERr_FP_CAM_CONTROL_SLICE_14f_SET BCM56504_A0_FP_CAM_CONTROL_UPPERr_FP_CAM_CONTROL_SLICE_14f_SET
#define FP_CAM_CONTROL_UPPERr_FP_CAM_CONTROL_SLICE_15f_GET BCM56504_A0_FP_CAM_CONTROL_UPPERr_FP_CAM_CONTROL_SLICE_15f_GET
#define FP_CAM_CONTROL_UPPERr_FP_CAM_CONTROL_SLICE_15f_SET BCM56504_A0_FP_CAM_CONTROL_UPPERr_FP_CAM_CONTROL_SLICE_15f_SET
#define FP_CAM_CONTROL_UPPERr_SECRET_CHAIN_MODEf_GET BCM56504_A0_FP_CAM_CONTROL_UPPERr_SECRET_CHAIN_MODEf_GET
#define FP_CAM_CONTROL_UPPERr_SECRET_CHAIN_MODEf_SET BCM56504_A0_FP_CAM_CONTROL_UPPERr_SECRET_CHAIN_MODEf_SET
#define READ_FP_CAM_CONTROL_UPPERr BCM56504_A0_READ_FP_CAM_CONTROL_UPPERr
#define WRITE_FP_CAM_CONTROL_UPPERr BCM56504_A0_WRITE_FP_CAM_CONTROL_UPPERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_FP_CAM_CONTROL_UPPERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  FP_CAM_ENABLE
 * BLOCKS:   IPIPE
 * DESC:     FP_CAM_ENABLE
 * SIZE:     32
 * FIELDS:
 *     FP_CAM_ENABLE_SLICE_0 FP_CAM_ENABLE FOR FP SLICE 0
 *     FP_CAM_ENABLE_SLICE_1 FP_CAM_ENABLE FOR FP SLICE 1
 *     FP_CAM_ENABLE_SLICE_2 FP_CAM_ENABLE FOR FP SLICE 2
 *     FP_CAM_ENABLE_SLICE_3 FP_CAM_ENABLE FOR FP SLICE 3
 *     FP_CAM_ENABLE_SLICE_4 FP_CAM_ENABLE FOR FP SLICE 4
 *     FP_CAM_ENABLE_SLICE_5 FP_CAM_ENABLE FOR FP SLICE 5
 *     FP_CAM_ENABLE_SLICE_6 FP_CAM_ENABLE FOR FP SLICE 6
 *     FP_CAM_ENABLE_SLICE_7 FP_CAM_ENABLE FOR FP SLICE 7
 *     FP_CAM_ENABLE_SLICE_8 FP_CAM_ENABLE FOR FP SLICE 8
 *     FP_CAM_ENABLE_SLICE_9 FP_CAM_ENABLE FOR FP SLICE 9
 *     FP_CAM_ENABLE_SLICE_10 FP_CAM_ENABLE FOR FP SLICE 10
 *     FP_CAM_ENABLE_SLICE_11 FP_CAM_ENABLE FOR FP SLICE 11
 *     FP_CAM_ENABLE_SLICE_12 FP_CAM_ENABLE FOR FP SLICE 12
 *     FP_CAM_ENABLE_SLICE_13 FP_CAM_ENABLE FOR FP SLICE 13
 *     FP_CAM_ENABLE_SLICE_14 FP_CAM_ENABLE FOR FP SLICE 14
 *     FP_CAM_ENABLE_SLICE_15 FP_CAM_ENABLE FOR FP SLICE 15
 *
 ******************************************************************************/
#define BCM56504_A0_FP_CAM_ENABLEr 0x0c780009

#define BCM56504_A0_FP_CAM_ENABLEr_SIZE 4

/*
 * This structure should be used to declare and program FP_CAM_ENABLE.
 *
 */
typedef union BCM56504_A0_FP_CAM_ENABLEr_s {
	uint32_t v[1];
	uint32_t fp_cam_enable[1];
	uint32_t _fp_cam_enable;
} BCM56504_A0_FP_CAM_ENABLEr_t;

#define BCM56504_A0_FP_CAM_ENABLEr_CLR(r) (r).fp_cam_enable[0] = 0
#define BCM56504_A0_FP_CAM_ENABLEr_SET(r,d) (r).fp_cam_enable[0] = d
#define BCM56504_A0_FP_CAM_ENABLEr_GET(r) (r).fp_cam_enable[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_0f_GET(r) (((r).fp_cam_enable[0]) & 0x1)
#define BCM56504_A0_FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_0f_SET(r,f) (r).fp_cam_enable[0]=(((r).fp_cam_enable[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_1f_GET(r) ((((r).fp_cam_enable[0]) >> 1) & 0x1)
#define BCM56504_A0_FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_1f_SET(r,f) (r).fp_cam_enable[0]=(((r).fp_cam_enable[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_2f_GET(r) ((((r).fp_cam_enable[0]) >> 2) & 0x1)
#define BCM56504_A0_FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_2f_SET(r,f) (r).fp_cam_enable[0]=(((r).fp_cam_enable[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_3f_GET(r) ((((r).fp_cam_enable[0]) >> 3) & 0x1)
#define BCM56504_A0_FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_3f_SET(r,f) (r).fp_cam_enable[0]=(((r).fp_cam_enable[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_4f_GET(r) ((((r).fp_cam_enable[0]) >> 4) & 0x1)
#define BCM56504_A0_FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_4f_SET(r,f) (r).fp_cam_enable[0]=(((r).fp_cam_enable[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56504_A0_FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_5f_GET(r) ((((r).fp_cam_enable[0]) >> 5) & 0x1)
#define BCM56504_A0_FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_5f_SET(r,f) (r).fp_cam_enable[0]=(((r).fp_cam_enable[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56504_A0_FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_6f_GET(r) ((((r).fp_cam_enable[0]) >> 6) & 0x1)
#define BCM56504_A0_FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_6f_SET(r,f) (r).fp_cam_enable[0]=(((r).fp_cam_enable[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56504_A0_FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_7f_GET(r) ((((r).fp_cam_enable[0]) >> 7) & 0x1)
#define BCM56504_A0_FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_7f_SET(r,f) (r).fp_cam_enable[0]=(((r).fp_cam_enable[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56504_A0_FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_8f_GET(r) ((((r).fp_cam_enable[0]) >> 8) & 0x1)
#define BCM56504_A0_FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_8f_SET(r,f) (r).fp_cam_enable[0]=(((r).fp_cam_enable[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56504_A0_FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_9f_GET(r) ((((r).fp_cam_enable[0]) >> 9) & 0x1)
#define BCM56504_A0_FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_9f_SET(r,f) (r).fp_cam_enable[0]=(((r).fp_cam_enable[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56504_A0_FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_10f_GET(r) ((((r).fp_cam_enable[0]) >> 10) & 0x1)
#define BCM56504_A0_FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_10f_SET(r,f) (r).fp_cam_enable[0]=(((r).fp_cam_enable[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56504_A0_FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_11f_GET(r) ((((r).fp_cam_enable[0]) >> 11) & 0x1)
#define BCM56504_A0_FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_11f_SET(r,f) (r).fp_cam_enable[0]=(((r).fp_cam_enable[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56504_A0_FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_12f_GET(r) ((((r).fp_cam_enable[0]) >> 12) & 0x1)
#define BCM56504_A0_FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_12f_SET(r,f) (r).fp_cam_enable[0]=(((r).fp_cam_enable[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM56504_A0_FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_13f_GET(r) ((((r).fp_cam_enable[0]) >> 13) & 0x1)
#define BCM56504_A0_FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_13f_SET(r,f) (r).fp_cam_enable[0]=(((r).fp_cam_enable[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56504_A0_FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_14f_GET(r) ((((r).fp_cam_enable[0]) >> 14) & 0x1)
#define BCM56504_A0_FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_14f_SET(r,f) (r).fp_cam_enable[0]=(((r).fp_cam_enable[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM56504_A0_FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_15f_GET(r) ((((r).fp_cam_enable[0]) >> 15) & 0x1)
#define BCM56504_A0_FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_15f_SET(r,f) (r).fp_cam_enable[0]=(((r).fp_cam_enable[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access FP_CAM_ENABLE.
 *
 */
#define BCM56504_A0_READ_FP_CAM_ENABLEr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_FP_CAM_ENABLEr,(r._fp_cam_enable))
#define BCM56504_A0_WRITE_FP_CAM_ENABLEr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_FP_CAM_ENABLEr,&(r._fp_cam_enable))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_CAM_ENABLEr BCM56504_A0_FP_CAM_ENABLEr
#define FP_CAM_ENABLEr_SIZE BCM56504_A0_FP_CAM_ENABLEr_SIZE
typedef BCM56504_A0_FP_CAM_ENABLEr_t FP_CAM_ENABLEr_t;
#define FP_CAM_ENABLEr_CLR BCM56504_A0_FP_CAM_ENABLEr_CLR
#define FP_CAM_ENABLEr_SET BCM56504_A0_FP_CAM_ENABLEr_SET
#define FP_CAM_ENABLEr_GET BCM56504_A0_FP_CAM_ENABLEr_GET
#define FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_0f_GET BCM56504_A0_FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_0f_GET
#define FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_0f_SET BCM56504_A0_FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_0f_SET
#define FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_1f_GET BCM56504_A0_FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_1f_GET
#define FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_1f_SET BCM56504_A0_FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_1f_SET
#define FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_2f_GET BCM56504_A0_FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_2f_GET
#define FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_2f_SET BCM56504_A0_FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_2f_SET
#define FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_3f_GET BCM56504_A0_FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_3f_GET
#define FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_3f_SET BCM56504_A0_FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_3f_SET
#define FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_4f_GET BCM56504_A0_FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_4f_GET
#define FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_4f_SET BCM56504_A0_FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_4f_SET
#define FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_5f_GET BCM56504_A0_FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_5f_GET
#define FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_5f_SET BCM56504_A0_FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_5f_SET
#define FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_6f_GET BCM56504_A0_FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_6f_GET
#define FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_6f_SET BCM56504_A0_FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_6f_SET
#define FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_7f_GET BCM56504_A0_FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_7f_GET
#define FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_7f_SET BCM56504_A0_FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_7f_SET
#define FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_8f_GET BCM56504_A0_FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_8f_GET
#define FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_8f_SET BCM56504_A0_FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_8f_SET
#define FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_9f_GET BCM56504_A0_FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_9f_GET
#define FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_9f_SET BCM56504_A0_FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_9f_SET
#define FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_10f_GET BCM56504_A0_FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_10f_GET
#define FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_10f_SET BCM56504_A0_FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_10f_SET
#define FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_11f_GET BCM56504_A0_FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_11f_GET
#define FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_11f_SET BCM56504_A0_FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_11f_SET
#define FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_12f_GET BCM56504_A0_FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_12f_GET
#define FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_12f_SET BCM56504_A0_FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_12f_SET
#define FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_13f_GET BCM56504_A0_FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_13f_GET
#define FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_13f_SET BCM56504_A0_FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_13f_SET
#define FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_14f_GET BCM56504_A0_FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_14f_GET
#define FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_14f_SET BCM56504_A0_FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_14f_SET
#define FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_15f_GET BCM56504_A0_FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_15f_GET
#define FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_15f_SET BCM56504_A0_FP_CAM_ENABLEr_FP_CAM_ENABLE_SLICE_15f_SET
#define READ_FP_CAM_ENABLEr BCM56504_A0_READ_FP_CAM_ENABLEr
#define WRITE_FP_CAM_ENABLEr BCM56504_A0_WRITE_FP_CAM_ENABLEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_FP_CAM_ENABLEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  FP_COUNTER_TABLE
 * BLOCKS:   IPIPE
 * DESC:     COUNTER TABLE FOR THE FP
 * SIZE:     32
 * FIELDS:
 *     COUNTER          COUNTER
 *
 ******************************************************************************/
#define BCM56504_A0_FP_COUNTER_TABLEm 0x0c770000

#define BCM56504_A0_FP_COUNTER_TABLEm_MIN 0
#define BCM56504_A0_FP_COUNTER_TABLEm_MAX 2047
#define BCM56504_A0_FP_COUNTER_TABLEm_CMAX(u) 2047
#define BCM56504_A0_FP_COUNTER_TABLEm_SIZE 4

/*
 * This structure should be used to declare and program FP_COUNTER_TABLE.
 *
 */
typedef union BCM56504_A0_FP_COUNTER_TABLEm_s {
	uint32_t v[1];
	uint32_t fp_counter_table[1];
	uint32_t _fp_counter_table;
} BCM56504_A0_FP_COUNTER_TABLEm_t;

#define BCM56504_A0_FP_COUNTER_TABLEm_CLR(r) (r).fp_counter_table[0] = 0
#define BCM56504_A0_FP_COUNTER_TABLEm_SET(r,d) (r).fp_counter_table[0] = d
#define BCM56504_A0_FP_COUNTER_TABLEm_GET(r) (r).fp_counter_table[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_FP_COUNTER_TABLEm_COUNTERf_GET(r) ((r).fp_counter_table[0])
#define BCM56504_A0_FP_COUNTER_TABLEm_COUNTERf_SET(r,f) (r).fp_counter_table[0]=((uint32_t)f)

/*
 * These macros can be used to access FP_COUNTER_TABLE.
 *
 */
#define BCM56504_A0_READ_FP_COUNTER_TABLEm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_FP_COUNTER_TABLEm,i,(m._fp_counter_table),1)
#define BCM56504_A0_WRITE_FP_COUNTER_TABLEm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_FP_COUNTER_TABLEm,i,&(m._fp_counter_table),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_COUNTER_TABLEm BCM56504_A0_FP_COUNTER_TABLEm
#define FP_COUNTER_TABLEm_MIN BCM56504_A0_FP_COUNTER_TABLEm_MIN
#define FP_COUNTER_TABLEm_MAX BCM56504_A0_FP_COUNTER_TABLEm_MAX
#define FP_COUNTER_TABLEm_CMAX(u) BCM56504_A0_FP_COUNTER_TABLEm_CMAX(u)
#define FP_COUNTER_TABLEm_SIZE BCM56504_A0_FP_COUNTER_TABLEm_SIZE
typedef BCM56504_A0_FP_COUNTER_TABLEm_t FP_COUNTER_TABLEm_t;
#define FP_COUNTER_TABLEm_CLR BCM56504_A0_FP_COUNTER_TABLEm_CLR
#define FP_COUNTER_TABLEm_SET BCM56504_A0_FP_COUNTER_TABLEm_SET
#define FP_COUNTER_TABLEm_GET BCM56504_A0_FP_COUNTER_TABLEm_GET
#define FP_COUNTER_TABLEm_COUNTERf_GET BCM56504_A0_FP_COUNTER_TABLEm_COUNTERf_GET
#define FP_COUNTER_TABLEm_COUNTERf_SET BCM56504_A0_FP_COUNTER_TABLEm_COUNTERf_SET
#define READ_FP_COUNTER_TABLEm BCM56504_A0_READ_FP_COUNTER_TABLEm
#define WRITE_FP_COUNTER_TABLEm BCM56504_A0_WRITE_FP_COUNTER_TABLEm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_FP_COUNTER_TABLEm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  FP_METER_TABLE
 * BLOCKS:   IPIPE
 * DESC:     METER TABLE STRUCTURES FOR THE FP
 * SIZE:     56
 * FIELDS:
 *     BUCKETCOUNT      BUCKETCOUNT
 *     BUCKETSIZE       BUCKETSIZE
 *     REFRESHCOUNT     REFRESHCOUNT
 *     REFRESH_MODE     REFRESH_MODE
 *     RESERVED_UNUSED  UNUSED BY SW
 *
 ******************************************************************************/
#define BCM56504_A0_FP_METER_TABLEm 0x0c760000

#define BCM56504_A0_FP_METER_TABLEm_MIN 0
#define BCM56504_A0_FP_METER_TABLEm_MAX 2047
#define BCM56504_A0_FP_METER_TABLEm_CMAX(u) 2047
#define BCM56504_A0_FP_METER_TABLEm_SIZE 7

/*
 * This structure should be used to declare and program FP_METER_TABLE.
 *
 */
typedef union BCM56504_A0_FP_METER_TABLEm_s {
	uint32_t v[2];
	uint32_t fp_meter_table[2];
	uint32_t _fp_meter_table;
} BCM56504_A0_FP_METER_TABLEm_t;

#define BCM56504_A0_FP_METER_TABLEm_CLR(r) CDK_MEMSET(&((r)._fp_meter_table), 0, sizeof(BCM56504_A0_FP_METER_TABLEm_t))
#define BCM56504_A0_FP_METER_TABLEm_SET(r,i,d) (r).fp_meter_table[i] = d
#define BCM56504_A0_FP_METER_TABLEm_GET(r,i) (r).fp_meter_table[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_FP_METER_TABLEm_BUCKETCOUNTf_GET(r) (((r).fp_meter_table[0]) & 0x3fffffff)
#define BCM56504_A0_FP_METER_TABLEm_BUCKETCOUNTf_SET(r,f) (r).fp_meter_table[0]=(((r).fp_meter_table[0] & ~((uint32_t)0x3fffffff)) | (((uint32_t)f) & 0x3fffffff))
#define BCM56504_A0_FP_METER_TABLEm_BUCKETSIZEf_GET(r) cdk_field32_get((r).fp_meter_table,30,33)
#define BCM56504_A0_FP_METER_TABLEm_BUCKETSIZEf_SET(r,f) cdk_field32_set((r).fp_meter_table,30,33,f)
#define BCM56504_A0_FP_METER_TABLEm_REFRESHCOUNTf_GET(r) ((((r).fp_meter_table[1]) >> 2) & 0x7ffff)
#define BCM56504_A0_FP_METER_TABLEm_REFRESHCOUNTf_SET(r,f) (r).fp_meter_table[1]=(((r).fp_meter_table[1] & ~((uint32_t)0x7ffff << 2)) | ((((uint32_t)f) & 0x7ffff) << 2))
#define BCM56504_A0_FP_METER_TABLEm_REFRESH_MODEf_GET(r) ((((r).fp_meter_table[1]) >> 21) & 0x1)
#define BCM56504_A0_FP_METER_TABLEm_REFRESH_MODEf_SET(r,f) (r).fp_meter_table[1]=(((r).fp_meter_table[1] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM56504_A0_FP_METER_TABLEm_RESERVED_UNUSEDf_GET(r) ((((r).fp_meter_table[1]) >> 22) & 0x3)
#define BCM56504_A0_FP_METER_TABLEm_RESERVED_UNUSEDf_SET(r,f) (r).fp_meter_table[1]=(((r).fp_meter_table[1] & ~((uint32_t)0x3 << 22)) | ((((uint32_t)f) & 0x3) << 22))

/*
 * These macros can be used to access FP_METER_TABLE.
 *
 */
#define BCM56504_A0_READ_FP_METER_TABLEm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_FP_METER_TABLEm,i,(m._fp_meter_table),2)
#define BCM56504_A0_WRITE_FP_METER_TABLEm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_FP_METER_TABLEm,i,&(m._fp_meter_table),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_METER_TABLEm BCM56504_A0_FP_METER_TABLEm
#define FP_METER_TABLEm_MIN BCM56504_A0_FP_METER_TABLEm_MIN
#define FP_METER_TABLEm_MAX BCM56504_A0_FP_METER_TABLEm_MAX
#define FP_METER_TABLEm_CMAX(u) BCM56504_A0_FP_METER_TABLEm_CMAX(u)
#define FP_METER_TABLEm_SIZE BCM56504_A0_FP_METER_TABLEm_SIZE
typedef BCM56504_A0_FP_METER_TABLEm_t FP_METER_TABLEm_t;
#define FP_METER_TABLEm_CLR BCM56504_A0_FP_METER_TABLEm_CLR
#define FP_METER_TABLEm_SET BCM56504_A0_FP_METER_TABLEm_SET
#define FP_METER_TABLEm_GET BCM56504_A0_FP_METER_TABLEm_GET
#define FP_METER_TABLEm_BUCKETCOUNTf_GET BCM56504_A0_FP_METER_TABLEm_BUCKETCOUNTf_GET
#define FP_METER_TABLEm_BUCKETCOUNTf_SET BCM56504_A0_FP_METER_TABLEm_BUCKETCOUNTf_SET
#define FP_METER_TABLEm_BUCKETSIZEf_GET BCM56504_A0_FP_METER_TABLEm_BUCKETSIZEf_GET
#define FP_METER_TABLEm_BUCKETSIZEf_SET BCM56504_A0_FP_METER_TABLEm_BUCKETSIZEf_SET
#define FP_METER_TABLEm_REFRESHCOUNTf_GET BCM56504_A0_FP_METER_TABLEm_REFRESHCOUNTf_GET
#define FP_METER_TABLEm_REFRESHCOUNTf_SET BCM56504_A0_FP_METER_TABLEm_REFRESHCOUNTf_SET
#define FP_METER_TABLEm_REFRESH_MODEf_GET BCM56504_A0_FP_METER_TABLEm_REFRESH_MODEf_GET
#define FP_METER_TABLEm_REFRESH_MODEf_SET BCM56504_A0_FP_METER_TABLEm_REFRESH_MODEf_SET
#define FP_METER_TABLEm_RESERVED_UNUSEDf_GET BCM56504_A0_FP_METER_TABLEm_RESERVED_UNUSEDf_GET
#define FP_METER_TABLEm_RESERVED_UNUSEDf_SET BCM56504_A0_FP_METER_TABLEm_RESERVED_UNUSEDf_SET
#define READ_FP_METER_TABLEm BCM56504_A0_READ_FP_METER_TABLEm
#define WRITE_FP_METER_TABLEm BCM56504_A0_WRITE_FP_METER_TABLEm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_FP_METER_TABLEm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  FP_POLICY_TABLE
 * BLOCKS:   IPIPE
 * DESC:     POLICY TABLE FOR DETERMINING ACTIONS IN THE FP
 * SIZE:     140
 * FIELDS:
 *     EM_MTP_INDEX     EM_MTP_INDEX
 *     IM_MTP_INDEX     IM_MTP_INDEX
 *     MTP_INDEX_SPARE  MTP_INDEX_SPARE
 *     REDIRECTION      REDIRECTION
 *     ECMP_PTR         ECMP_PTR
 *     ECMP_COUNT       ECMP_COUNT
 *     ECMP             ECMP
 *     YP_DSCP          YP_DSCP
 *     RP_DSCP          RP_DSCP
 *     NEWDSCP_TOS      NEWDSCP_TOS
 *     NEWPRI           NEWPRI
 *     METER_PAIR_MODE  METER_PAIR_MODE
 *     METER_TEST_EVEN  METER_TEST_EVEN
 *     METER_TEST_ODD   METER_TEST_ODD
 *     METER_UPDATE_EVEN METER_UPDATE_EVEN
 *     METER_UPDATE_ODD METER_UPDATE_ODD
 *     METER_INDEX_EVEN METER_INDEX_EVEN
 *     METER_INDEX_ODD  METER_INDEX_ODD
 *     COUNTER_MODE     COUNTER_MODE
 *     COUNTER_INDEX    COUNTER_INDEX
 *     YP_CHANGE_DSCP   YP_CHANGE_DSCP
 *     YP_COPY_TO_CPU   YP_COPY_TO_CPU
 *     YP_DROP_PRECEDENCE YP_DROP_PRECEDENCE
 *     YP_DROP          YP_DROP
 *     RP_CHANGE_DSCP   RP_CHANGE_DSCP
 *     RP_COPY_TO_CPU   RP_COPY_TO_CPU
 *     RP_DROP_PRECEDENCE RP_DROP_PRECEDENCE
 *     RP_DROP          RP_DROP
 *     DROP_PRECEDENCE  DROP_PRECEDENCE
 *     L3SW_CHANGE_MACDA_OR_VLAN L3SW_CHANGE_MACDA_OR_VLAN
 *     MIRROR           MIRROR
 *     DROP             DROP
 *     CHAIN            CHAIN
 *     PACKET_REDIRECTION PACKET_REDIRECTION
 *     COPY_TO_CPU      COPY_TO_CPU
 *     CHANGE_DSCP_TOS  CHANGE_DSCP_TOS
 *     CHANGE_PRIORITY  CHANGE_PRIORITY
 *     RESERVED_PT1     RESERVED
 *     CHAIN_INDEX      CHAIN_INDEX
 *     CHAIN_VALID      CHAIN_VALID
 *     NEXT_HOP_INDEX   NEXT_HOP_INDEX
 *     CLASSIFICATION_TAG CLASSIFICATION_TAG
 *     MATCHED_RULE     MATCHED_RULE
 *
 ******************************************************************************/
#define BCM56504_A0_FP_POLICY_TABLEm 0x0c750000

#define BCM56504_A0_FP_POLICY_TABLEm_MIN 0
#define BCM56504_A0_FP_POLICY_TABLEm_MAX 2047
#define BCM56504_A0_FP_POLICY_TABLEm_CMAX(u) 2047
#define BCM56504_A0_FP_POLICY_TABLEm_SIZE 18

/*
 * This structure should be used to declare and program FP_POLICY_TABLE.
 *
 */
typedef union BCM56504_A0_FP_POLICY_TABLEm_s {
	uint32_t v[5];
	uint32_t fp_policy_table[5];
	uint32_t _fp_policy_table;
} BCM56504_A0_FP_POLICY_TABLEm_t;

#define BCM56504_A0_FP_POLICY_TABLEm_CLR(r) CDK_MEMSET(&((r)._fp_policy_table), 0, sizeof(BCM56504_A0_FP_POLICY_TABLEm_t))
#define BCM56504_A0_FP_POLICY_TABLEm_SET(r,i,d) (r).fp_policy_table[i] = d
#define BCM56504_A0_FP_POLICY_TABLEm_GET(r,i) (r).fp_policy_table[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_FP_POLICY_TABLEm_EM_MTP_INDEXf_GET(r) (((r).fp_policy_table[0]) & 0x3)
#define BCM56504_A0_FP_POLICY_TABLEm_EM_MTP_INDEXf_SET(r,f) (r).fp_policy_table[0]=(((r).fp_policy_table[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56504_A0_FP_POLICY_TABLEm_IM_MTP_INDEXf_GET(r) ((((r).fp_policy_table[0]) >> 2) & 0x3)
#define BCM56504_A0_FP_POLICY_TABLEm_IM_MTP_INDEXf_SET(r,f) (r).fp_policy_table[0]=(((r).fp_policy_table[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM56504_A0_FP_POLICY_TABLEm_MTP_INDEX_SPAREf_GET(r) ((((r).fp_policy_table[0]) >> 4) & 0x1)
#define BCM56504_A0_FP_POLICY_TABLEm_MTP_INDEX_SPAREf_SET(r,f) (r).fp_policy_table[0]=(((r).fp_policy_table[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56504_A0_FP_POLICY_TABLEm_REDIRECTIONf_GET(r) cdk_field32_get((r).fp_policy_table,5,33)
#define BCM56504_A0_FP_POLICY_TABLEm_REDIRECTIONf_SET(r,f) cdk_field32_set((r).fp_policy_table,5,33,f)
#define BCM56504_A0_FP_POLICY_TABLEm_ECMP_PTRf_GET(r) ((((r).fp_policy_table[1]) >> 2) & 0x7ff)
#define BCM56504_A0_FP_POLICY_TABLEm_ECMP_PTRf_SET(r,f) (r).fp_policy_table[1]=(((r).fp_policy_table[1] & ~((uint32_t)0x7ff << 2)) | ((((uint32_t)f) & 0x7ff) << 2))
#define BCM56504_A0_FP_POLICY_TABLEm_ECMP_COUNTf_GET(r) ((((r).fp_policy_table[1]) >> 13) & 0x1f)
#define BCM56504_A0_FP_POLICY_TABLEm_ECMP_COUNTf_SET(r,f) (r).fp_policy_table[1]=(((r).fp_policy_table[1] & ~((uint32_t)0x1f << 13)) | ((((uint32_t)f) & 0x1f) << 13))
#define BCM56504_A0_FP_POLICY_TABLEm_ECMPf_GET(r) ((((r).fp_policy_table[1]) >> 18) & 0x1)
#define BCM56504_A0_FP_POLICY_TABLEm_ECMPf_SET(r,f) (r).fp_policy_table[1]=(((r).fp_policy_table[1] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56504_A0_FP_POLICY_TABLEm_YP_DSCPf_GET(r) ((((r).fp_policy_table[1]) >> 21) & 0x3f)
#define BCM56504_A0_FP_POLICY_TABLEm_YP_DSCPf_SET(r,f) (r).fp_policy_table[1]=(((r).fp_policy_table[1] & ~((uint32_t)0x3f << 21)) | ((((uint32_t)f) & 0x3f) << 21))
#define BCM56504_A0_FP_POLICY_TABLEm_RP_DSCPf_GET(r) cdk_field32_get((r).fp_policy_table,59,64)
#define BCM56504_A0_FP_POLICY_TABLEm_RP_DSCPf_SET(r,f) cdk_field32_set((r).fp_policy_table,59,64,f)
#define BCM56504_A0_FP_POLICY_TABLEm_NEWDSCP_TOSf_GET(r) ((((r).fp_policy_table[2]) >> 1) & 0x3f)
#define BCM56504_A0_FP_POLICY_TABLEm_NEWDSCP_TOSf_SET(r,f) (r).fp_policy_table[2]=(((r).fp_policy_table[2] & ~((uint32_t)0x3f << 1)) | ((((uint32_t)f) & 0x3f) << 1))
#define BCM56504_A0_FP_POLICY_TABLEm_NEWPRIf_GET(r) ((((r).fp_policy_table[2]) >> 7) & 0x7)
#define BCM56504_A0_FP_POLICY_TABLEm_NEWPRIf_SET(r,f) (r).fp_policy_table[2]=(((r).fp_policy_table[2] & ~((uint32_t)0x7 << 7)) | ((((uint32_t)f) & 0x7) << 7))
#define BCM56504_A0_FP_POLICY_TABLEm_METER_PAIR_MODEf_GET(r) ((((r).fp_policy_table[2]) >> 10) & 0x7)
#define BCM56504_A0_FP_POLICY_TABLEm_METER_PAIR_MODEf_SET(r,f) (r).fp_policy_table[2]=(((r).fp_policy_table[2] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10))
#define BCM56504_A0_FP_POLICY_TABLEm_METER_TEST_EVENf_GET(r) ((((r).fp_policy_table[2]) >> 13) & 0x1)
#define BCM56504_A0_FP_POLICY_TABLEm_METER_TEST_EVENf_SET(r,f) (r).fp_policy_table[2]=(((r).fp_policy_table[2] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56504_A0_FP_POLICY_TABLEm_METER_TEST_ODDf_GET(r) ((((r).fp_policy_table[2]) >> 14) & 0x1)
#define BCM56504_A0_FP_POLICY_TABLEm_METER_TEST_ODDf_SET(r,f) (r).fp_policy_table[2]=(((r).fp_policy_table[2] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM56504_A0_FP_POLICY_TABLEm_METER_UPDATE_EVENf_GET(r) ((((r).fp_policy_table[2]) >> 15) & 0x1)
#define BCM56504_A0_FP_POLICY_TABLEm_METER_UPDATE_EVENf_SET(r,f) (r).fp_policy_table[2]=(((r).fp_policy_table[2] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56504_A0_FP_POLICY_TABLEm_METER_UPDATE_ODDf_GET(r) ((((r).fp_policy_table[2]) >> 16) & 0x1)
#define BCM56504_A0_FP_POLICY_TABLEm_METER_UPDATE_ODDf_SET(r,f) (r).fp_policy_table[2]=(((r).fp_policy_table[2] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56504_A0_FP_POLICY_TABLEm_METER_INDEX_EVENf_GET(r) ((((r).fp_policy_table[2]) >> 17) & 0x3f)
#define BCM56504_A0_FP_POLICY_TABLEm_METER_INDEX_EVENf_SET(r,f) (r).fp_policy_table[2]=(((r).fp_policy_table[2] & ~((uint32_t)0x3f << 17)) | ((((uint32_t)f) & 0x3f) << 17))
#define BCM56504_A0_FP_POLICY_TABLEm_METER_INDEX_ODDf_GET(r) ((((r).fp_policy_table[2]) >> 23) & 0x3f)
#define BCM56504_A0_FP_POLICY_TABLEm_METER_INDEX_ODDf_SET(r,f) (r).fp_policy_table[2]=(((r).fp_policy_table[2] & ~((uint32_t)0x3f << 23)) | ((((uint32_t)f) & 0x3f) << 23))
#define BCM56504_A0_FP_POLICY_TABLEm_COUNTER_MODEf_GET(r) cdk_field32_get((r).fp_policy_table,93,96)
#define BCM56504_A0_FP_POLICY_TABLEm_COUNTER_MODEf_SET(r,f) cdk_field32_set((r).fp_policy_table,93,96,f)
#define BCM56504_A0_FP_POLICY_TABLEm_COUNTER_INDEXf_GET(r) ((((r).fp_policy_table[3]) >> 1) & 0x3f)
#define BCM56504_A0_FP_POLICY_TABLEm_COUNTER_INDEXf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32_t)0x3f << 1)) | ((((uint32_t)f) & 0x3f) << 1))
#define BCM56504_A0_FP_POLICY_TABLEm_YP_CHANGE_DSCPf_GET(r) ((((r).fp_policy_table[3]) >> 7) & 0x1)
#define BCM56504_A0_FP_POLICY_TABLEm_YP_CHANGE_DSCPf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56504_A0_FP_POLICY_TABLEm_YP_COPY_TO_CPUf_GET(r) ((((r).fp_policy_table[3]) >> 8) & 0x3)
#define BCM56504_A0_FP_POLICY_TABLEm_YP_COPY_TO_CPUf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM56504_A0_FP_POLICY_TABLEm_YP_DROP_PRECEDENCEf_GET(r) ((((r).fp_policy_table[3]) >> 10) & 0x3)
#define BCM56504_A0_FP_POLICY_TABLEm_YP_DROP_PRECEDENCEf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCM56504_A0_FP_POLICY_TABLEm_YP_DROPf_GET(r) ((((r).fp_policy_table[3]) >> 12) & 0x3)
#define BCM56504_A0_FP_POLICY_TABLEm_YP_DROPf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM56504_A0_FP_POLICY_TABLEm_RP_CHANGE_DSCPf_GET(r) ((((r).fp_policy_table[3]) >> 14) & 0x1)
#define BCM56504_A0_FP_POLICY_TABLEm_RP_CHANGE_DSCPf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM56504_A0_FP_POLICY_TABLEm_RP_COPY_TO_CPUf_GET(r) ((((r).fp_policy_table[3]) >> 15) & 0x3)
#define BCM56504_A0_FP_POLICY_TABLEm_RP_COPY_TO_CPUf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32_t)0x3 << 15)) | ((((uint32_t)f) & 0x3) << 15))
#define BCM56504_A0_FP_POLICY_TABLEm_RP_DROP_PRECEDENCEf_GET(r) ((((r).fp_policy_table[3]) >> 17) & 0x3)
#define BCM56504_A0_FP_POLICY_TABLEm_RP_DROP_PRECEDENCEf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32_t)0x3 << 17)) | ((((uint32_t)f) & 0x3) << 17))
#define BCM56504_A0_FP_POLICY_TABLEm_RP_DROPf_GET(r) ((((r).fp_policy_table[3]) >> 19) & 0x3)
#define BCM56504_A0_FP_POLICY_TABLEm_RP_DROPf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32_t)0x3 << 19)) | ((((uint32_t)f) & 0x3) << 19))
#define BCM56504_A0_FP_POLICY_TABLEm_DROP_PRECEDENCEf_GET(r) ((((r).fp_policy_table[3]) >> 21) & 0x3)
#define BCM56504_A0_FP_POLICY_TABLEm_DROP_PRECEDENCEf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32_t)0x3 << 21)) | ((((uint32_t)f) & 0x3) << 21))
#define BCM56504_A0_FP_POLICY_TABLEm_L3SW_CHANGE_MACDA_OR_VLANf_GET(r) ((((r).fp_policy_table[3]) >> 23) & 0x7)
#define BCM56504_A0_FP_POLICY_TABLEm_L3SW_CHANGE_MACDA_OR_VLANf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32_t)0x7 << 23)) | ((((uint32_t)f) & 0x7) << 23))
#define BCM56504_A0_FP_POLICY_TABLEm_MIRRORf_GET(r) ((((r).fp_policy_table[3]) >> 26) & 0x3)
#define BCM56504_A0_FP_POLICY_TABLEm_MIRRORf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32_t)0x3 << 26)) | ((((uint32_t)f) & 0x3) << 26))
#define BCM56504_A0_FP_POLICY_TABLEm_DROPf_GET(r) ((((r).fp_policy_table[3]) >> 28) & 0x3)
#define BCM56504_A0_FP_POLICY_TABLEm_DROPf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32_t)0x3 << 28)) | ((((uint32_t)f) & 0x3) << 28))
#define BCM56504_A0_FP_POLICY_TABLEm_CHAINf_GET(r) ((((r).fp_policy_table[3]) >> 30) & 0x1)
#define BCM56504_A0_FP_POLICY_TABLEm_CHAINf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM56504_A0_FP_POLICY_TABLEm_PACKET_REDIRECTIONf_GET(r) cdk_field32_get((r).fp_policy_table,127,129)
#define BCM56504_A0_FP_POLICY_TABLEm_PACKET_REDIRECTIONf_SET(r,f) cdk_field32_set((r).fp_policy_table,127,129,f)
#define BCM56504_A0_FP_POLICY_TABLEm_COPY_TO_CPUf_GET(r) ((((r).fp_policy_table[4]) >> 2) & 0x3)
#define BCM56504_A0_FP_POLICY_TABLEm_COPY_TO_CPUf_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM56504_A0_FP_POLICY_TABLEm_CHANGE_DSCP_TOSf_GET(r) ((((r).fp_policy_table[4]) >> 4) & 0x7)
#define BCM56504_A0_FP_POLICY_TABLEm_CHANGE_DSCP_TOSf_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4))
#define BCM56504_A0_FP_POLICY_TABLEm_CHANGE_PRIORITYf_GET(r) ((((r).fp_policy_table[4]) >> 7) & 0xf)
#define BCM56504_A0_FP_POLICY_TABLEm_CHANGE_PRIORITYf_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32_t)0xf << 7)) | ((((uint32_t)f) & 0xf) << 7))
#define BCM56504_A0_FP_POLICY_TABLEm_RESERVED_PT1f_GET(r) ((((r).fp_policy_table[4]) >> 11) & 0x1)
#define BCM56504_A0_FP_POLICY_TABLEm_RESERVED_PT1f_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56504_A0_FP_POLICY_TABLEm_CHAIN_INDEXf_GET(r) ((((r).fp_policy_table[0]) >> 5) & 0x7f)
#define BCM56504_A0_FP_POLICY_TABLEm_CHAIN_INDEXf_SET(r,f) (r).fp_policy_table[0]=(((r).fp_policy_table[0] & ~((uint32_t)0x7f << 5)) | ((((uint32_t)f) & 0x7f) << 5))
#define BCM56504_A0_FP_POLICY_TABLEm_CHAIN_VALIDf_GET(r) ((((r).fp_policy_table[0]) >> 12) & 0x1)
#define BCM56504_A0_FP_POLICY_TABLEm_CHAIN_VALIDf_SET(r,f) (r).fp_policy_table[0]=(((r).fp_policy_table[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM56504_A0_FP_POLICY_TABLEm_NEXT_HOP_INDEXf_GET(r) ((((r).fp_policy_table[1]) >> 2) & 0x1fff)
#define BCM56504_A0_FP_POLICY_TABLEm_NEXT_HOP_INDEXf_SET(r,f) (r).fp_policy_table[1]=(((r).fp_policy_table[1] & ~((uint32_t)0x1fff << 2)) | ((((uint32_t)f) & 0x1fff) << 2))
#define BCM56504_A0_FP_POLICY_TABLEm_CLASSIFICATION_TAGf_GET(r) ((((r).fp_policy_table[1]) >> 2) & 0x7ff)
#define BCM56504_A0_FP_POLICY_TABLEm_CLASSIFICATION_TAGf_SET(r,f) (r).fp_policy_table[1]=(((r).fp_policy_table[1] & ~((uint32_t)0x7ff << 2)) | ((((uint32_t)f) & 0x7ff) << 2))
#define BCM56504_A0_FP_POLICY_TABLEm_MATCHED_RULEf_GET(r) ((((r).fp_policy_table[1]) >> 13) & 0xff)
#define BCM56504_A0_FP_POLICY_TABLEm_MATCHED_RULEf_SET(r,f) (r).fp_policy_table[1]=(((r).fp_policy_table[1] & ~((uint32_t)0xff << 13)) | ((((uint32_t)f) & 0xff) << 13))

/*
 * These macros can be used to access FP_POLICY_TABLE.
 *
 */
#define BCM56504_A0_READ_FP_POLICY_TABLEm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_FP_POLICY_TABLEm,i,(m._fp_policy_table),5)
#define BCM56504_A0_WRITE_FP_POLICY_TABLEm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_FP_POLICY_TABLEm,i,&(m._fp_policy_table),5)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_POLICY_TABLEm BCM56504_A0_FP_POLICY_TABLEm
#define FP_POLICY_TABLEm_MIN BCM56504_A0_FP_POLICY_TABLEm_MIN
#define FP_POLICY_TABLEm_MAX BCM56504_A0_FP_POLICY_TABLEm_MAX
#define FP_POLICY_TABLEm_CMAX(u) BCM56504_A0_FP_POLICY_TABLEm_CMAX(u)
#define FP_POLICY_TABLEm_SIZE BCM56504_A0_FP_POLICY_TABLEm_SIZE
typedef BCM56504_A0_FP_POLICY_TABLEm_t FP_POLICY_TABLEm_t;
#define FP_POLICY_TABLEm_CLR BCM56504_A0_FP_POLICY_TABLEm_CLR
#define FP_POLICY_TABLEm_SET BCM56504_A0_FP_POLICY_TABLEm_SET
#define FP_POLICY_TABLEm_GET BCM56504_A0_FP_POLICY_TABLEm_GET
#define FP_POLICY_TABLEm_EM_MTP_INDEXf_GET BCM56504_A0_FP_POLICY_TABLEm_EM_MTP_INDEXf_GET
#define FP_POLICY_TABLEm_EM_MTP_INDEXf_SET BCM56504_A0_FP_POLICY_TABLEm_EM_MTP_INDEXf_SET
#define FP_POLICY_TABLEm_IM_MTP_INDEXf_GET BCM56504_A0_FP_POLICY_TABLEm_IM_MTP_INDEXf_GET
#define FP_POLICY_TABLEm_IM_MTP_INDEXf_SET BCM56504_A0_FP_POLICY_TABLEm_IM_MTP_INDEXf_SET
#define FP_POLICY_TABLEm_MTP_INDEX_SPAREf_GET BCM56504_A0_FP_POLICY_TABLEm_MTP_INDEX_SPAREf_GET
#define FP_POLICY_TABLEm_MTP_INDEX_SPAREf_SET BCM56504_A0_FP_POLICY_TABLEm_MTP_INDEX_SPAREf_SET
#define FP_POLICY_TABLEm_REDIRECTIONf_GET BCM56504_A0_FP_POLICY_TABLEm_REDIRECTIONf_GET
#define FP_POLICY_TABLEm_REDIRECTIONf_SET BCM56504_A0_FP_POLICY_TABLEm_REDIRECTIONf_SET
#define FP_POLICY_TABLEm_ECMP_PTRf_GET BCM56504_A0_FP_POLICY_TABLEm_ECMP_PTRf_GET
#define FP_POLICY_TABLEm_ECMP_PTRf_SET BCM56504_A0_FP_POLICY_TABLEm_ECMP_PTRf_SET
#define FP_POLICY_TABLEm_ECMP_COUNTf_GET BCM56504_A0_FP_POLICY_TABLEm_ECMP_COUNTf_GET
#define FP_POLICY_TABLEm_ECMP_COUNTf_SET BCM56504_A0_FP_POLICY_TABLEm_ECMP_COUNTf_SET
#define FP_POLICY_TABLEm_ECMPf_GET BCM56504_A0_FP_POLICY_TABLEm_ECMPf_GET
#define FP_POLICY_TABLEm_ECMPf_SET BCM56504_A0_FP_POLICY_TABLEm_ECMPf_SET
#define FP_POLICY_TABLEm_YP_DSCPf_GET BCM56504_A0_FP_POLICY_TABLEm_YP_DSCPf_GET
#define FP_POLICY_TABLEm_YP_DSCPf_SET BCM56504_A0_FP_POLICY_TABLEm_YP_DSCPf_SET
#define FP_POLICY_TABLEm_RP_DSCPf_GET BCM56504_A0_FP_POLICY_TABLEm_RP_DSCPf_GET
#define FP_POLICY_TABLEm_RP_DSCPf_SET BCM56504_A0_FP_POLICY_TABLEm_RP_DSCPf_SET
#define FP_POLICY_TABLEm_NEWDSCP_TOSf_GET BCM56504_A0_FP_POLICY_TABLEm_NEWDSCP_TOSf_GET
#define FP_POLICY_TABLEm_NEWDSCP_TOSf_SET BCM56504_A0_FP_POLICY_TABLEm_NEWDSCP_TOSf_SET
#define FP_POLICY_TABLEm_NEWPRIf_GET BCM56504_A0_FP_POLICY_TABLEm_NEWPRIf_GET
#define FP_POLICY_TABLEm_NEWPRIf_SET BCM56504_A0_FP_POLICY_TABLEm_NEWPRIf_SET
#define FP_POLICY_TABLEm_METER_PAIR_MODEf_GET BCM56504_A0_FP_POLICY_TABLEm_METER_PAIR_MODEf_GET
#define FP_POLICY_TABLEm_METER_PAIR_MODEf_SET BCM56504_A0_FP_POLICY_TABLEm_METER_PAIR_MODEf_SET
#define FP_POLICY_TABLEm_METER_TEST_EVENf_GET BCM56504_A0_FP_POLICY_TABLEm_METER_TEST_EVENf_GET
#define FP_POLICY_TABLEm_METER_TEST_EVENf_SET BCM56504_A0_FP_POLICY_TABLEm_METER_TEST_EVENf_SET
#define FP_POLICY_TABLEm_METER_TEST_ODDf_GET BCM56504_A0_FP_POLICY_TABLEm_METER_TEST_ODDf_GET
#define FP_POLICY_TABLEm_METER_TEST_ODDf_SET BCM56504_A0_FP_POLICY_TABLEm_METER_TEST_ODDf_SET
#define FP_POLICY_TABLEm_METER_UPDATE_EVENf_GET BCM56504_A0_FP_POLICY_TABLEm_METER_UPDATE_EVENf_GET
#define FP_POLICY_TABLEm_METER_UPDATE_EVENf_SET BCM56504_A0_FP_POLICY_TABLEm_METER_UPDATE_EVENf_SET
#define FP_POLICY_TABLEm_METER_UPDATE_ODDf_GET BCM56504_A0_FP_POLICY_TABLEm_METER_UPDATE_ODDf_GET
#define FP_POLICY_TABLEm_METER_UPDATE_ODDf_SET BCM56504_A0_FP_POLICY_TABLEm_METER_UPDATE_ODDf_SET
#define FP_POLICY_TABLEm_METER_INDEX_EVENf_GET BCM56504_A0_FP_POLICY_TABLEm_METER_INDEX_EVENf_GET
#define FP_POLICY_TABLEm_METER_INDEX_EVENf_SET BCM56504_A0_FP_POLICY_TABLEm_METER_INDEX_EVENf_SET
#define FP_POLICY_TABLEm_METER_INDEX_ODDf_GET BCM56504_A0_FP_POLICY_TABLEm_METER_INDEX_ODDf_GET
#define FP_POLICY_TABLEm_METER_INDEX_ODDf_SET BCM56504_A0_FP_POLICY_TABLEm_METER_INDEX_ODDf_SET
#define FP_POLICY_TABLEm_COUNTER_MODEf_GET BCM56504_A0_FP_POLICY_TABLEm_COUNTER_MODEf_GET
#define FP_POLICY_TABLEm_COUNTER_MODEf_SET BCM56504_A0_FP_POLICY_TABLEm_COUNTER_MODEf_SET
#define FP_POLICY_TABLEm_COUNTER_INDEXf_GET BCM56504_A0_FP_POLICY_TABLEm_COUNTER_INDEXf_GET
#define FP_POLICY_TABLEm_COUNTER_INDEXf_SET BCM56504_A0_FP_POLICY_TABLEm_COUNTER_INDEXf_SET
#define FP_POLICY_TABLEm_YP_CHANGE_DSCPf_GET BCM56504_A0_FP_POLICY_TABLEm_YP_CHANGE_DSCPf_GET
#define FP_POLICY_TABLEm_YP_CHANGE_DSCPf_SET BCM56504_A0_FP_POLICY_TABLEm_YP_CHANGE_DSCPf_SET
#define FP_POLICY_TABLEm_YP_COPY_TO_CPUf_GET BCM56504_A0_FP_POLICY_TABLEm_YP_COPY_TO_CPUf_GET
#define FP_POLICY_TABLEm_YP_COPY_TO_CPUf_SET BCM56504_A0_FP_POLICY_TABLEm_YP_COPY_TO_CPUf_SET
#define FP_POLICY_TABLEm_YP_DROP_PRECEDENCEf_GET BCM56504_A0_FP_POLICY_TABLEm_YP_DROP_PRECEDENCEf_GET
#define FP_POLICY_TABLEm_YP_DROP_PRECEDENCEf_SET BCM56504_A0_FP_POLICY_TABLEm_YP_DROP_PRECEDENCEf_SET
#define FP_POLICY_TABLEm_YP_DROPf_GET BCM56504_A0_FP_POLICY_TABLEm_YP_DROPf_GET
#define FP_POLICY_TABLEm_YP_DROPf_SET BCM56504_A0_FP_POLICY_TABLEm_YP_DROPf_SET
#define FP_POLICY_TABLEm_RP_CHANGE_DSCPf_GET BCM56504_A0_FP_POLICY_TABLEm_RP_CHANGE_DSCPf_GET
#define FP_POLICY_TABLEm_RP_CHANGE_DSCPf_SET BCM56504_A0_FP_POLICY_TABLEm_RP_CHANGE_DSCPf_SET
#define FP_POLICY_TABLEm_RP_COPY_TO_CPUf_GET BCM56504_A0_FP_POLICY_TABLEm_RP_COPY_TO_CPUf_GET
#define FP_POLICY_TABLEm_RP_COPY_TO_CPUf_SET BCM56504_A0_FP_POLICY_TABLEm_RP_COPY_TO_CPUf_SET
#define FP_POLICY_TABLEm_RP_DROP_PRECEDENCEf_GET BCM56504_A0_FP_POLICY_TABLEm_RP_DROP_PRECEDENCEf_GET
#define FP_POLICY_TABLEm_RP_DROP_PRECEDENCEf_SET BCM56504_A0_FP_POLICY_TABLEm_RP_DROP_PRECEDENCEf_SET
#define FP_POLICY_TABLEm_RP_DROPf_GET BCM56504_A0_FP_POLICY_TABLEm_RP_DROPf_GET
#define FP_POLICY_TABLEm_RP_DROPf_SET BCM56504_A0_FP_POLICY_TABLEm_RP_DROPf_SET
#define FP_POLICY_TABLEm_DROP_PRECEDENCEf_GET BCM56504_A0_FP_POLICY_TABLEm_DROP_PRECEDENCEf_GET
#define FP_POLICY_TABLEm_DROP_PRECEDENCEf_SET BCM56504_A0_FP_POLICY_TABLEm_DROP_PRECEDENCEf_SET
#define FP_POLICY_TABLEm_L3SW_CHANGE_MACDA_OR_VLANf_GET BCM56504_A0_FP_POLICY_TABLEm_L3SW_CHANGE_MACDA_OR_VLANf_GET
#define FP_POLICY_TABLEm_L3SW_CHANGE_MACDA_OR_VLANf_SET BCM56504_A0_FP_POLICY_TABLEm_L3SW_CHANGE_MACDA_OR_VLANf_SET
#define FP_POLICY_TABLEm_MIRRORf_GET BCM56504_A0_FP_POLICY_TABLEm_MIRRORf_GET
#define FP_POLICY_TABLEm_MIRRORf_SET BCM56504_A0_FP_POLICY_TABLEm_MIRRORf_SET
#define FP_POLICY_TABLEm_DROPf_GET BCM56504_A0_FP_POLICY_TABLEm_DROPf_GET
#define FP_POLICY_TABLEm_DROPf_SET BCM56504_A0_FP_POLICY_TABLEm_DROPf_SET
#define FP_POLICY_TABLEm_CHAINf_GET BCM56504_A0_FP_POLICY_TABLEm_CHAINf_GET
#define FP_POLICY_TABLEm_CHAINf_SET BCM56504_A0_FP_POLICY_TABLEm_CHAINf_SET
#define FP_POLICY_TABLEm_PACKET_REDIRECTIONf_GET BCM56504_A0_FP_POLICY_TABLEm_PACKET_REDIRECTIONf_GET
#define FP_POLICY_TABLEm_PACKET_REDIRECTIONf_SET BCM56504_A0_FP_POLICY_TABLEm_PACKET_REDIRECTIONf_SET
#define FP_POLICY_TABLEm_COPY_TO_CPUf_GET BCM56504_A0_FP_POLICY_TABLEm_COPY_TO_CPUf_GET
#define FP_POLICY_TABLEm_COPY_TO_CPUf_SET BCM56504_A0_FP_POLICY_TABLEm_COPY_TO_CPUf_SET
#define FP_POLICY_TABLEm_CHANGE_DSCP_TOSf_GET BCM56504_A0_FP_POLICY_TABLEm_CHANGE_DSCP_TOSf_GET
#define FP_POLICY_TABLEm_CHANGE_DSCP_TOSf_SET BCM56504_A0_FP_POLICY_TABLEm_CHANGE_DSCP_TOSf_SET
#define FP_POLICY_TABLEm_CHANGE_PRIORITYf_GET BCM56504_A0_FP_POLICY_TABLEm_CHANGE_PRIORITYf_GET
#define FP_POLICY_TABLEm_CHANGE_PRIORITYf_SET BCM56504_A0_FP_POLICY_TABLEm_CHANGE_PRIORITYf_SET
#define FP_POLICY_TABLEm_RESERVED_PT1f_GET BCM56504_A0_FP_POLICY_TABLEm_RESERVED_PT1f_GET
#define FP_POLICY_TABLEm_RESERVED_PT1f_SET BCM56504_A0_FP_POLICY_TABLEm_RESERVED_PT1f_SET
#define FP_POLICY_TABLEm_CHAIN_INDEXf_GET BCM56504_A0_FP_POLICY_TABLEm_CHAIN_INDEXf_GET
#define FP_POLICY_TABLEm_CHAIN_INDEXf_SET BCM56504_A0_FP_POLICY_TABLEm_CHAIN_INDEXf_SET
#define FP_POLICY_TABLEm_CHAIN_VALIDf_GET BCM56504_A0_FP_POLICY_TABLEm_CHAIN_VALIDf_GET
#define FP_POLICY_TABLEm_CHAIN_VALIDf_SET BCM56504_A0_FP_POLICY_TABLEm_CHAIN_VALIDf_SET
#define FP_POLICY_TABLEm_NEXT_HOP_INDEXf_GET BCM56504_A0_FP_POLICY_TABLEm_NEXT_HOP_INDEXf_GET
#define FP_POLICY_TABLEm_NEXT_HOP_INDEXf_SET BCM56504_A0_FP_POLICY_TABLEm_NEXT_HOP_INDEXf_SET
#define FP_POLICY_TABLEm_CLASSIFICATION_TAGf_GET BCM56504_A0_FP_POLICY_TABLEm_CLASSIFICATION_TAGf_GET
#define FP_POLICY_TABLEm_CLASSIFICATION_TAGf_SET BCM56504_A0_FP_POLICY_TABLEm_CLASSIFICATION_TAGf_SET
#define FP_POLICY_TABLEm_MATCHED_RULEf_GET BCM56504_A0_FP_POLICY_TABLEm_MATCHED_RULEf_GET
#define FP_POLICY_TABLEm_MATCHED_RULEf_SET BCM56504_A0_FP_POLICY_TABLEm_MATCHED_RULEf_SET
#define READ_FP_POLICY_TABLEm BCM56504_A0_READ_FP_POLICY_TABLEm
#define WRITE_FP_POLICY_TABLEm BCM56504_A0_WRITE_FP_POLICY_TABLEm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_FP_POLICY_TABLEm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  FP_PORT_FIELD_SEL
 * BLOCKS:   IPIPE
 * DESC:     FIELD SELECT VALUE FOR EACH SLICE IN THE FP
 * SIZE:     160
 * FIELDS:
 *     SLICE0_F1        F1 field for slice 0.
 *     SLICE0_F2        F2 field for slice 0
 *     SLICE0_F3        F3 field for slice 0
 *     SLICE1_F1        F1 field for slice 1.
 *     SLICE1_F2        F2 field for slice 1
 *     SLICE1_F3        F3 field for slice 1
 *     SLICE2_F1        F1 field for slice 2.
 *     SLICE2_F2        F2 field for slice 2
 *     SLICE2_F3        F3 field for slice 2
 *     SLICE3_F1        F1 field for slice 3.
 *     SLICE3_F2        F2 field for slice 3
 *     SLICE3_F3        F3 field for slice 3
 *     SLICE4_F1        F1 field for slice 4.
 *     SLICE4_F2        F2 field for slice 4
 *     SLICE4_F3        F3 field for slice 4
 *     SLICE5_F1        F1 field for slice 5.
 *     SLICE5_F2        F2 field for slice 5
 *     SLICE5_F3        F3 field for slice 5
 *     SLICE6_F1        F1 field for slice 6.
 *     SLICE6_F2        F2 field for slice 6
 *     SLICE6_F3        F3 field for slice 6
 *     SLICE7_F1        F1 field for slice 7.
 *     SLICE7_F2        F2 field for slice 7
 *     SLICE7_F3        F3 field for slice 7
 *     SLICE8_F1        F1 field for slice 8.
 *     SLICE8_F2        F2 field for slice 8
 *     SLICE8_F3        F3 field for slice 8
 *     SLICE9_F1        F1 field for slice 9.
 *     SLICE9_F2        F2 field for slice 9
 *     SLICE9_F3        F3 field for slice 9
 *     SLICE10_F1       F1 field for slice 10.
 *     SLICE10_F2       F2 field for slice 10
 *     SLICE10_F3       F3 field for slice 10
 *     SLICE11_F1       F1 field for slice 11.
 *     SLICE11_F2       F2 field for slice 11
 *     SLICE11_F3       F3 field for slice 11
 *     SLICE12_F1       F1 field for slice 12.
 *     SLICE12_F2       F2 field for slice 12
 *     SLICE12_F3       F3 field for slice 12
 *     SLICE13_F1       F1 field for slice 13.
 *     SLICE13_F2       F2 field for slice 13
 *     SLICE13_F3       F3 field for slice 13
 *     SLICE14_F1       F1 field for slice 14.
 *     SLICE14_F2       F2 field for slice 14
 *     SLICE14_F3       F3 field for slice 14
 *     SLICE15_F1       F1 field for slice 15.
 *     SLICE15_F2       F2 field for slice 15
 *     SLICE15_F3       F3 field for slice 15
 *
 ******************************************************************************/
#define BCM56504_A0_FP_PORT_FIELD_SELm 0x0b700000

#define BCM56504_A0_FP_PORT_FIELD_SELm_MIN 0
#define BCM56504_A0_FP_PORT_FIELD_SELm_MAX 28
#define BCM56504_A0_FP_PORT_FIELD_SELm_CMAX(u) 28
#define BCM56504_A0_FP_PORT_FIELD_SELm_SIZE 20

/*
 * This structure should be used to declare and program FP_PORT_FIELD_SEL.
 *
 */
typedef union BCM56504_A0_FP_PORT_FIELD_SELm_s {
	uint32_t v[5];
	uint32_t fp_port_field_sel[5];
	uint32_t _fp_port_field_sel;
} BCM56504_A0_FP_PORT_FIELD_SELm_t;

#define BCM56504_A0_FP_PORT_FIELD_SELm_CLR(r) CDK_MEMSET(&((r)._fp_port_field_sel), 0, sizeof(BCM56504_A0_FP_PORT_FIELD_SELm_t))
#define BCM56504_A0_FP_PORT_FIELD_SELm_SET(r,i,d) (r).fp_port_field_sel[i] = d
#define BCM56504_A0_FP_PORT_FIELD_SELm_GET(r,i) (r).fp_port_field_sel[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE0_F1f_GET(r) (((r).fp_port_field_sel[0]) & 0x7)
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE0_F1f_SET(r,f) (r).fp_port_field_sel[0]=(((r).fp_port_field_sel[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE0_F2f_GET(r) ((((r).fp_port_field_sel[0]) >> 3) & 0xf)
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE0_F2f_SET(r,f) (r).fp_port_field_sel[0]=(((r).fp_port_field_sel[0] & ~((uint32_t)0xf << 3)) | ((((uint32_t)f) & 0xf) << 3))
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE0_F3f_GET(r) ((((r).fp_port_field_sel[0]) >> 7) & 0x7)
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE0_F3f_SET(r,f) (r).fp_port_field_sel[0]=(((r).fp_port_field_sel[0] & ~((uint32_t)0x7 << 7)) | ((((uint32_t)f) & 0x7) << 7))
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE1_F1f_GET(r) ((((r).fp_port_field_sel[0]) >> 10) & 0x7)
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE1_F1f_SET(r,f) (r).fp_port_field_sel[0]=(((r).fp_port_field_sel[0] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10))
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE1_F2f_GET(r) ((((r).fp_port_field_sel[0]) >> 13) & 0xf)
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE1_F2f_SET(r,f) (r).fp_port_field_sel[0]=(((r).fp_port_field_sel[0] & ~((uint32_t)0xf << 13)) | ((((uint32_t)f) & 0xf) << 13))
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE1_F3f_GET(r) ((((r).fp_port_field_sel[0]) >> 17) & 0x7)
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE1_F3f_SET(r,f) (r).fp_port_field_sel[0]=(((r).fp_port_field_sel[0] & ~((uint32_t)0x7 << 17)) | ((((uint32_t)f) & 0x7) << 17))
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE2_F1f_GET(r) ((((r).fp_port_field_sel[0]) >> 20) & 0x7)
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE2_F1f_SET(r,f) (r).fp_port_field_sel[0]=(((r).fp_port_field_sel[0] & ~((uint32_t)0x7 << 20)) | ((((uint32_t)f) & 0x7) << 20))
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE2_F2f_GET(r) ((((r).fp_port_field_sel[0]) >> 23) & 0xf)
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE2_F2f_SET(r,f) (r).fp_port_field_sel[0]=(((r).fp_port_field_sel[0] & ~((uint32_t)0xf << 23)) | ((((uint32_t)f) & 0xf) << 23))
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE2_F3f_GET(r) ((((r).fp_port_field_sel[0]) >> 27) & 0x7)
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE2_F3f_SET(r,f) (r).fp_port_field_sel[0]=(((r).fp_port_field_sel[0] & ~((uint32_t)0x7 << 27)) | ((((uint32_t)f) & 0x7) << 27))
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE3_F1f_GET(r) cdk_field32_get((r).fp_port_field_sel,30,32)
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE3_F1f_SET(r,f) cdk_field32_set((r).fp_port_field_sel,30,32,f)
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE3_F2f_GET(r) ((((r).fp_port_field_sel[1]) >> 1) & 0xf)
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE3_F2f_SET(r,f) (r).fp_port_field_sel[1]=(((r).fp_port_field_sel[1] & ~((uint32_t)0xf << 1)) | ((((uint32_t)f) & 0xf) << 1))
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE3_F3f_GET(r) ((((r).fp_port_field_sel[1]) >> 5) & 0x7)
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE3_F3f_SET(r,f) (r).fp_port_field_sel[1]=(((r).fp_port_field_sel[1] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE4_F1f_GET(r) ((((r).fp_port_field_sel[1]) >> 8) & 0x7)
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE4_F1f_SET(r,f) (r).fp_port_field_sel[1]=(((r).fp_port_field_sel[1] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8))
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE4_F2f_GET(r) ((((r).fp_port_field_sel[1]) >> 11) & 0xf)
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE4_F2f_SET(r,f) (r).fp_port_field_sel[1]=(((r).fp_port_field_sel[1] & ~((uint32_t)0xf << 11)) | ((((uint32_t)f) & 0xf) << 11))
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE4_F3f_GET(r) ((((r).fp_port_field_sel[1]) >> 15) & 0x7)
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE4_F3f_SET(r,f) (r).fp_port_field_sel[1]=(((r).fp_port_field_sel[1] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE5_F1f_GET(r) ((((r).fp_port_field_sel[1]) >> 18) & 0x7)
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE5_F1f_SET(r,f) (r).fp_port_field_sel[1]=(((r).fp_port_field_sel[1] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE5_F2f_GET(r) ((((r).fp_port_field_sel[1]) >> 21) & 0xf)
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE5_F2f_SET(r,f) (r).fp_port_field_sel[1]=(((r).fp_port_field_sel[1] & ~((uint32_t)0xf << 21)) | ((((uint32_t)f) & 0xf) << 21))
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE5_F3f_GET(r) ((((r).fp_port_field_sel[1]) >> 25) & 0x7)
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE5_F3f_SET(r,f) (r).fp_port_field_sel[1]=(((r).fp_port_field_sel[1] & ~((uint32_t)0x7 << 25)) | ((((uint32_t)f) & 0x7) << 25))
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE6_F1f_GET(r) ((((r).fp_port_field_sel[1]) >> 28) & 0x7)
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE6_F1f_SET(r,f) (r).fp_port_field_sel[1]=(((r).fp_port_field_sel[1] & ~((uint32_t)0x7 << 28)) | ((((uint32_t)f) & 0x7) << 28))
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE6_F2f_GET(r) cdk_field32_get((r).fp_port_field_sel,63,66)
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE6_F2f_SET(r,f) cdk_field32_set((r).fp_port_field_sel,63,66,f)
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE6_F3f_GET(r) ((((r).fp_port_field_sel[2]) >> 3) & 0x7)
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE6_F3f_SET(r,f) (r).fp_port_field_sel[2]=(((r).fp_port_field_sel[2] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE7_F1f_GET(r) ((((r).fp_port_field_sel[2]) >> 6) & 0x7)
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE7_F1f_SET(r,f) (r).fp_port_field_sel[2]=(((r).fp_port_field_sel[2] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE7_F2f_GET(r) ((((r).fp_port_field_sel[2]) >> 9) & 0xf)
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE7_F2f_SET(r,f) (r).fp_port_field_sel[2]=(((r).fp_port_field_sel[2] & ~((uint32_t)0xf << 9)) | ((((uint32_t)f) & 0xf) << 9))
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE7_F3f_GET(r) ((((r).fp_port_field_sel[2]) >> 13) & 0x7)
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE7_F3f_SET(r,f) (r).fp_port_field_sel[2]=(((r).fp_port_field_sel[2] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE8_F1f_GET(r) ((((r).fp_port_field_sel[2]) >> 16) & 0x7)
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE8_F1f_SET(r,f) (r).fp_port_field_sel[2]=(((r).fp_port_field_sel[2] & ~((uint32_t)0x7 << 16)) | ((((uint32_t)f) & 0x7) << 16))
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE8_F2f_GET(r) ((((r).fp_port_field_sel[2]) >> 19) & 0xf)
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE8_F2f_SET(r,f) (r).fp_port_field_sel[2]=(((r).fp_port_field_sel[2] & ~((uint32_t)0xf << 19)) | ((((uint32_t)f) & 0xf) << 19))
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE8_F3f_GET(r) ((((r).fp_port_field_sel[2]) >> 23) & 0x7)
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE8_F3f_SET(r,f) (r).fp_port_field_sel[2]=(((r).fp_port_field_sel[2] & ~((uint32_t)0x7 << 23)) | ((((uint32_t)f) & 0x7) << 23))
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE9_F1f_GET(r) ((((r).fp_port_field_sel[2]) >> 26) & 0x7)
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE9_F1f_SET(r,f) (r).fp_port_field_sel[2]=(((r).fp_port_field_sel[2] & ~((uint32_t)0x7 << 26)) | ((((uint32_t)f) & 0x7) << 26))
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE9_F2f_GET(r) cdk_field32_get((r).fp_port_field_sel,93,96)
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE9_F2f_SET(r,f) cdk_field32_set((r).fp_port_field_sel,93,96,f)
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE9_F3f_GET(r) ((((r).fp_port_field_sel[3]) >> 1) & 0x7)
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE9_F3f_SET(r,f) (r).fp_port_field_sel[3]=(((r).fp_port_field_sel[3] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE10_F1f_GET(r) ((((r).fp_port_field_sel[3]) >> 4) & 0x7)
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE10_F1f_SET(r,f) (r).fp_port_field_sel[3]=(((r).fp_port_field_sel[3] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4))
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE10_F2f_GET(r) ((((r).fp_port_field_sel[3]) >> 7) & 0xf)
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE10_F2f_SET(r,f) (r).fp_port_field_sel[3]=(((r).fp_port_field_sel[3] & ~((uint32_t)0xf << 7)) | ((((uint32_t)f) & 0xf) << 7))
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE10_F3f_GET(r) ((((r).fp_port_field_sel[3]) >> 11) & 0x7)
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE10_F3f_SET(r,f) (r).fp_port_field_sel[3]=(((r).fp_port_field_sel[3] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11))
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE11_F1f_GET(r) ((((r).fp_port_field_sel[3]) >> 14) & 0x7)
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE11_F1f_SET(r,f) (r).fp_port_field_sel[3]=(((r).fp_port_field_sel[3] & ~((uint32_t)0x7 << 14)) | ((((uint32_t)f) & 0x7) << 14))
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE11_F2f_GET(r) ((((r).fp_port_field_sel[3]) >> 17) & 0xf)
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE11_F2f_SET(r,f) (r).fp_port_field_sel[3]=(((r).fp_port_field_sel[3] & ~((uint32_t)0xf << 17)) | ((((uint32_t)f) & 0xf) << 17))
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE11_F3f_GET(r) ((((r).fp_port_field_sel[3]) >> 21) & 0x7)
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE11_F3f_SET(r,f) (r).fp_port_field_sel[3]=(((r).fp_port_field_sel[3] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE12_F1f_GET(r) ((((r).fp_port_field_sel[3]) >> 24) & 0x7)
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE12_F1f_SET(r,f) (r).fp_port_field_sel[3]=(((r).fp_port_field_sel[3] & ~((uint32_t)0x7 << 24)) | ((((uint32_t)f) & 0x7) << 24))
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE12_F2f_GET(r) ((((r).fp_port_field_sel[3]) >> 27) & 0xf)
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE12_F2f_SET(r,f) (r).fp_port_field_sel[3]=(((r).fp_port_field_sel[3] & ~((uint32_t)0xf << 27)) | ((((uint32_t)f) & 0xf) << 27))
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE12_F3f_GET(r) cdk_field32_get((r).fp_port_field_sel,127,129)
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE12_F3f_SET(r,f) cdk_field32_set((r).fp_port_field_sel,127,129,f)
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE13_F1f_GET(r) ((((r).fp_port_field_sel[4]) >> 2) & 0x7)
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE13_F1f_SET(r,f) (r).fp_port_field_sel[4]=(((r).fp_port_field_sel[4] & ~((uint32_t)0x7 << 2)) | ((((uint32_t)f) & 0x7) << 2))
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE13_F2f_GET(r) ((((r).fp_port_field_sel[4]) >> 5) & 0xf)
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE13_F2f_SET(r,f) (r).fp_port_field_sel[4]=(((r).fp_port_field_sel[4] & ~((uint32_t)0xf << 5)) | ((((uint32_t)f) & 0xf) << 5))
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE13_F3f_GET(r) ((((r).fp_port_field_sel[4]) >> 9) & 0x7)
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE13_F3f_SET(r,f) (r).fp_port_field_sel[4]=(((r).fp_port_field_sel[4] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE14_F1f_GET(r) ((((r).fp_port_field_sel[4]) >> 12) & 0x7)
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE14_F1f_SET(r,f) (r).fp_port_field_sel[4]=(((r).fp_port_field_sel[4] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE14_F2f_GET(r) ((((r).fp_port_field_sel[4]) >> 15) & 0xf)
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE14_F2f_SET(r,f) (r).fp_port_field_sel[4]=(((r).fp_port_field_sel[4] & ~((uint32_t)0xf << 15)) | ((((uint32_t)f) & 0xf) << 15))
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE14_F3f_GET(r) ((((r).fp_port_field_sel[4]) >> 19) & 0x7)
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE14_F3f_SET(r,f) (r).fp_port_field_sel[4]=(((r).fp_port_field_sel[4] & ~((uint32_t)0x7 << 19)) | ((((uint32_t)f) & 0x7) << 19))
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE15_F1f_GET(r) ((((r).fp_port_field_sel[4]) >> 22) & 0x7)
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE15_F1f_SET(r,f) (r).fp_port_field_sel[4]=(((r).fp_port_field_sel[4] & ~((uint32_t)0x7 << 22)) | ((((uint32_t)f) & 0x7) << 22))
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE15_F2f_GET(r) ((((r).fp_port_field_sel[4]) >> 25) & 0xf)
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE15_F2f_SET(r,f) (r).fp_port_field_sel[4]=(((r).fp_port_field_sel[4] & ~((uint32_t)0xf << 25)) | ((((uint32_t)f) & 0xf) << 25))
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE15_F3f_GET(r) ((((r).fp_port_field_sel[4]) >> 29) & 0x7)
#define BCM56504_A0_FP_PORT_FIELD_SELm_SLICE15_F3f_SET(r,f) (r).fp_port_field_sel[4]=(((r).fp_port_field_sel[4] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access FP_PORT_FIELD_SEL.
 *
 */
#define BCM56504_A0_READ_FP_PORT_FIELD_SELm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_FP_PORT_FIELD_SELm,i,(m._fp_port_field_sel),5)
#define BCM56504_A0_WRITE_FP_PORT_FIELD_SELm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_FP_PORT_FIELD_SELm,i,&(m._fp_port_field_sel),5)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_PORT_FIELD_SELm BCM56504_A0_FP_PORT_FIELD_SELm
#define FP_PORT_FIELD_SELm_MIN BCM56504_A0_FP_PORT_FIELD_SELm_MIN
#define FP_PORT_FIELD_SELm_MAX BCM56504_A0_FP_PORT_FIELD_SELm_MAX
#define FP_PORT_FIELD_SELm_CMAX(u) BCM56504_A0_FP_PORT_FIELD_SELm_CMAX(u)
#define FP_PORT_FIELD_SELm_SIZE BCM56504_A0_FP_PORT_FIELD_SELm_SIZE
typedef BCM56504_A0_FP_PORT_FIELD_SELm_t FP_PORT_FIELD_SELm_t;
#define FP_PORT_FIELD_SELm_CLR BCM56504_A0_FP_PORT_FIELD_SELm_CLR
#define FP_PORT_FIELD_SELm_SET BCM56504_A0_FP_PORT_FIELD_SELm_SET
#define FP_PORT_FIELD_SELm_GET BCM56504_A0_FP_PORT_FIELD_SELm_GET
#define FP_PORT_FIELD_SELm_SLICE0_F1f_GET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE0_F1f_GET
#define FP_PORT_FIELD_SELm_SLICE0_F1f_SET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE0_F1f_SET
#define FP_PORT_FIELD_SELm_SLICE0_F2f_GET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE0_F2f_GET
#define FP_PORT_FIELD_SELm_SLICE0_F2f_SET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE0_F2f_SET
#define FP_PORT_FIELD_SELm_SLICE0_F3f_GET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE0_F3f_GET
#define FP_PORT_FIELD_SELm_SLICE0_F3f_SET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE0_F3f_SET
#define FP_PORT_FIELD_SELm_SLICE1_F1f_GET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE1_F1f_GET
#define FP_PORT_FIELD_SELm_SLICE1_F1f_SET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE1_F1f_SET
#define FP_PORT_FIELD_SELm_SLICE1_F2f_GET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE1_F2f_GET
#define FP_PORT_FIELD_SELm_SLICE1_F2f_SET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE1_F2f_SET
#define FP_PORT_FIELD_SELm_SLICE1_F3f_GET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE1_F3f_GET
#define FP_PORT_FIELD_SELm_SLICE1_F3f_SET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE1_F3f_SET
#define FP_PORT_FIELD_SELm_SLICE2_F1f_GET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE2_F1f_GET
#define FP_PORT_FIELD_SELm_SLICE2_F1f_SET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE2_F1f_SET
#define FP_PORT_FIELD_SELm_SLICE2_F2f_GET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE2_F2f_GET
#define FP_PORT_FIELD_SELm_SLICE2_F2f_SET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE2_F2f_SET
#define FP_PORT_FIELD_SELm_SLICE2_F3f_GET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE2_F3f_GET
#define FP_PORT_FIELD_SELm_SLICE2_F3f_SET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE2_F3f_SET
#define FP_PORT_FIELD_SELm_SLICE3_F1f_GET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE3_F1f_GET
#define FP_PORT_FIELD_SELm_SLICE3_F1f_SET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE3_F1f_SET
#define FP_PORT_FIELD_SELm_SLICE3_F2f_GET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE3_F2f_GET
#define FP_PORT_FIELD_SELm_SLICE3_F2f_SET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE3_F2f_SET
#define FP_PORT_FIELD_SELm_SLICE3_F3f_GET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE3_F3f_GET
#define FP_PORT_FIELD_SELm_SLICE3_F3f_SET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE3_F3f_SET
#define FP_PORT_FIELD_SELm_SLICE4_F1f_GET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE4_F1f_GET
#define FP_PORT_FIELD_SELm_SLICE4_F1f_SET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE4_F1f_SET
#define FP_PORT_FIELD_SELm_SLICE4_F2f_GET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE4_F2f_GET
#define FP_PORT_FIELD_SELm_SLICE4_F2f_SET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE4_F2f_SET
#define FP_PORT_FIELD_SELm_SLICE4_F3f_GET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE4_F3f_GET
#define FP_PORT_FIELD_SELm_SLICE4_F3f_SET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE4_F3f_SET
#define FP_PORT_FIELD_SELm_SLICE5_F1f_GET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE5_F1f_GET
#define FP_PORT_FIELD_SELm_SLICE5_F1f_SET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE5_F1f_SET
#define FP_PORT_FIELD_SELm_SLICE5_F2f_GET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE5_F2f_GET
#define FP_PORT_FIELD_SELm_SLICE5_F2f_SET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE5_F2f_SET
#define FP_PORT_FIELD_SELm_SLICE5_F3f_GET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE5_F3f_GET
#define FP_PORT_FIELD_SELm_SLICE5_F3f_SET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE5_F3f_SET
#define FP_PORT_FIELD_SELm_SLICE6_F1f_GET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE6_F1f_GET
#define FP_PORT_FIELD_SELm_SLICE6_F1f_SET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE6_F1f_SET
#define FP_PORT_FIELD_SELm_SLICE6_F2f_GET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE6_F2f_GET
#define FP_PORT_FIELD_SELm_SLICE6_F2f_SET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE6_F2f_SET
#define FP_PORT_FIELD_SELm_SLICE6_F3f_GET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE6_F3f_GET
#define FP_PORT_FIELD_SELm_SLICE6_F3f_SET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE6_F3f_SET
#define FP_PORT_FIELD_SELm_SLICE7_F1f_GET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE7_F1f_GET
#define FP_PORT_FIELD_SELm_SLICE7_F1f_SET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE7_F1f_SET
#define FP_PORT_FIELD_SELm_SLICE7_F2f_GET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE7_F2f_GET
#define FP_PORT_FIELD_SELm_SLICE7_F2f_SET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE7_F2f_SET
#define FP_PORT_FIELD_SELm_SLICE7_F3f_GET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE7_F3f_GET
#define FP_PORT_FIELD_SELm_SLICE7_F3f_SET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE7_F3f_SET
#define FP_PORT_FIELD_SELm_SLICE8_F1f_GET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE8_F1f_GET
#define FP_PORT_FIELD_SELm_SLICE8_F1f_SET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE8_F1f_SET
#define FP_PORT_FIELD_SELm_SLICE8_F2f_GET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE8_F2f_GET
#define FP_PORT_FIELD_SELm_SLICE8_F2f_SET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE8_F2f_SET
#define FP_PORT_FIELD_SELm_SLICE8_F3f_GET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE8_F3f_GET
#define FP_PORT_FIELD_SELm_SLICE8_F3f_SET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE8_F3f_SET
#define FP_PORT_FIELD_SELm_SLICE9_F1f_GET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE9_F1f_GET
#define FP_PORT_FIELD_SELm_SLICE9_F1f_SET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE9_F1f_SET
#define FP_PORT_FIELD_SELm_SLICE9_F2f_GET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE9_F2f_GET
#define FP_PORT_FIELD_SELm_SLICE9_F2f_SET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE9_F2f_SET
#define FP_PORT_FIELD_SELm_SLICE9_F3f_GET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE9_F3f_GET
#define FP_PORT_FIELD_SELm_SLICE9_F3f_SET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE9_F3f_SET
#define FP_PORT_FIELD_SELm_SLICE10_F1f_GET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE10_F1f_GET
#define FP_PORT_FIELD_SELm_SLICE10_F1f_SET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE10_F1f_SET
#define FP_PORT_FIELD_SELm_SLICE10_F2f_GET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE10_F2f_GET
#define FP_PORT_FIELD_SELm_SLICE10_F2f_SET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE10_F2f_SET
#define FP_PORT_FIELD_SELm_SLICE10_F3f_GET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE10_F3f_GET
#define FP_PORT_FIELD_SELm_SLICE10_F3f_SET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE10_F3f_SET
#define FP_PORT_FIELD_SELm_SLICE11_F1f_GET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE11_F1f_GET
#define FP_PORT_FIELD_SELm_SLICE11_F1f_SET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE11_F1f_SET
#define FP_PORT_FIELD_SELm_SLICE11_F2f_GET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE11_F2f_GET
#define FP_PORT_FIELD_SELm_SLICE11_F2f_SET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE11_F2f_SET
#define FP_PORT_FIELD_SELm_SLICE11_F3f_GET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE11_F3f_GET
#define FP_PORT_FIELD_SELm_SLICE11_F3f_SET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE11_F3f_SET
#define FP_PORT_FIELD_SELm_SLICE12_F1f_GET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE12_F1f_GET
#define FP_PORT_FIELD_SELm_SLICE12_F1f_SET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE12_F1f_SET
#define FP_PORT_FIELD_SELm_SLICE12_F2f_GET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE12_F2f_GET
#define FP_PORT_FIELD_SELm_SLICE12_F2f_SET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE12_F2f_SET
#define FP_PORT_FIELD_SELm_SLICE12_F3f_GET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE12_F3f_GET
#define FP_PORT_FIELD_SELm_SLICE12_F3f_SET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE12_F3f_SET
#define FP_PORT_FIELD_SELm_SLICE13_F1f_GET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE13_F1f_GET
#define FP_PORT_FIELD_SELm_SLICE13_F1f_SET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE13_F1f_SET
#define FP_PORT_FIELD_SELm_SLICE13_F2f_GET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE13_F2f_GET
#define FP_PORT_FIELD_SELm_SLICE13_F2f_SET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE13_F2f_SET
#define FP_PORT_FIELD_SELm_SLICE13_F3f_GET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE13_F3f_GET
#define FP_PORT_FIELD_SELm_SLICE13_F3f_SET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE13_F3f_SET
#define FP_PORT_FIELD_SELm_SLICE14_F1f_GET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE14_F1f_GET
#define FP_PORT_FIELD_SELm_SLICE14_F1f_SET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE14_F1f_SET
#define FP_PORT_FIELD_SELm_SLICE14_F2f_GET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE14_F2f_GET
#define FP_PORT_FIELD_SELm_SLICE14_F2f_SET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE14_F2f_SET
#define FP_PORT_FIELD_SELm_SLICE14_F3f_GET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE14_F3f_GET
#define FP_PORT_FIELD_SELm_SLICE14_F3f_SET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE14_F3f_SET
#define FP_PORT_FIELD_SELm_SLICE15_F1f_GET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE15_F1f_GET
#define FP_PORT_FIELD_SELm_SLICE15_F1f_SET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE15_F1f_SET
#define FP_PORT_FIELD_SELm_SLICE15_F2f_GET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE15_F2f_GET
#define FP_PORT_FIELD_SELm_SLICE15_F2f_SET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE15_F2f_SET
#define FP_PORT_FIELD_SELm_SLICE15_F3f_GET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE15_F3f_GET
#define FP_PORT_FIELD_SELm_SLICE15_F3f_SET BCM56504_A0_FP_PORT_FIELD_SELm_SLICE15_F3f_SET
#define READ_FP_PORT_FIELD_SELm BCM56504_A0_READ_FP_PORT_FIELD_SELm
#define WRITE_FP_PORT_FIELD_SELm BCM56504_A0_WRITE_FP_PORT_FIELD_SELm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_FP_PORT_FIELD_SELm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  FP_RANGE_CHECK
 * BLOCKS:   IPIPE
 * DESC:     RANGE CHECK VALUES FOR FP
 * SIZE:     34
 * FIELDS:
 *     LOWER_BOUNDS     Lower bounds of range to be checked.
 *     UPPER_BOUNDS     Upper bounds of range to be checked.
 *     ENABLE           Enable range check
 *     SOURCE_DESTINATION_SELECT Selects whether the Source or Destination Port is range checked.
 *
 ******************************************************************************/
#define BCM56504_A0_FP_RANGE_CHECKm 0x0c700000

#define BCM56504_A0_FP_RANGE_CHECKm_MIN 0
#define BCM56504_A0_FP_RANGE_CHECKm_MAX 15
#define BCM56504_A0_FP_RANGE_CHECKm_CMAX(u) 15
#define BCM56504_A0_FP_RANGE_CHECKm_SIZE 5

/*
 * This structure should be used to declare and program FP_RANGE_CHECK.
 *
 */
typedef union BCM56504_A0_FP_RANGE_CHECKm_s {
	uint32_t v[2];
	uint32_t fp_range_check[2];
	uint32_t _fp_range_check;
} BCM56504_A0_FP_RANGE_CHECKm_t;

#define BCM56504_A0_FP_RANGE_CHECKm_CLR(r) CDK_MEMSET(&((r)._fp_range_check), 0, sizeof(BCM56504_A0_FP_RANGE_CHECKm_t))
#define BCM56504_A0_FP_RANGE_CHECKm_SET(r,i,d) (r).fp_range_check[i] = d
#define BCM56504_A0_FP_RANGE_CHECKm_GET(r,i) (r).fp_range_check[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_FP_RANGE_CHECKm_LOWER_BOUNDSf_GET(r) (((r).fp_range_check[0]) & 0xffff)
#define BCM56504_A0_FP_RANGE_CHECKm_LOWER_BOUNDSf_SET(r,f) (r).fp_range_check[0]=(((r).fp_range_check[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56504_A0_FP_RANGE_CHECKm_UPPER_BOUNDSf_GET(r) ((((r).fp_range_check[0]) >> 16) & 0xffff)
#define BCM56504_A0_FP_RANGE_CHECKm_UPPER_BOUNDSf_SET(r,f) (r).fp_range_check[0]=(((r).fp_range_check[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))
#define BCM56504_A0_FP_RANGE_CHECKm_ENABLEf_GET(r) (((r).fp_range_check[1]) & 0x1)
#define BCM56504_A0_FP_RANGE_CHECKm_ENABLEf_SET(r,f) (r).fp_range_check[1]=(((r).fp_range_check[1] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_FP_RANGE_CHECKm_SOURCE_DESTINATION_SELECTf_GET(r) ((((r).fp_range_check[1]) >> 1) & 0x1)
#define BCM56504_A0_FP_RANGE_CHECKm_SOURCE_DESTINATION_SELECTf_SET(r,f) (r).fp_range_check[1]=(((r).fp_range_check[1] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access FP_RANGE_CHECK.
 *
 */
#define BCM56504_A0_READ_FP_RANGE_CHECKm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_FP_RANGE_CHECKm,i,(m._fp_range_check),2)
#define BCM56504_A0_WRITE_FP_RANGE_CHECKm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_FP_RANGE_CHECKm,i,&(m._fp_range_check),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_RANGE_CHECKm BCM56504_A0_FP_RANGE_CHECKm
#define FP_RANGE_CHECKm_MIN BCM56504_A0_FP_RANGE_CHECKm_MIN
#define FP_RANGE_CHECKm_MAX BCM56504_A0_FP_RANGE_CHECKm_MAX
#define FP_RANGE_CHECKm_CMAX(u) BCM56504_A0_FP_RANGE_CHECKm_CMAX(u)
#define FP_RANGE_CHECKm_SIZE BCM56504_A0_FP_RANGE_CHECKm_SIZE
typedef BCM56504_A0_FP_RANGE_CHECKm_t FP_RANGE_CHECKm_t;
#define FP_RANGE_CHECKm_CLR BCM56504_A0_FP_RANGE_CHECKm_CLR
#define FP_RANGE_CHECKm_SET BCM56504_A0_FP_RANGE_CHECKm_SET
#define FP_RANGE_CHECKm_GET BCM56504_A0_FP_RANGE_CHECKm_GET
#define FP_RANGE_CHECKm_LOWER_BOUNDSf_GET BCM56504_A0_FP_RANGE_CHECKm_LOWER_BOUNDSf_GET
#define FP_RANGE_CHECKm_LOWER_BOUNDSf_SET BCM56504_A0_FP_RANGE_CHECKm_LOWER_BOUNDSf_SET
#define FP_RANGE_CHECKm_UPPER_BOUNDSf_GET BCM56504_A0_FP_RANGE_CHECKm_UPPER_BOUNDSf_GET
#define FP_RANGE_CHECKm_UPPER_BOUNDSf_SET BCM56504_A0_FP_RANGE_CHECKm_UPPER_BOUNDSf_SET
#define FP_RANGE_CHECKm_ENABLEf_GET BCM56504_A0_FP_RANGE_CHECKm_ENABLEf_GET
#define FP_RANGE_CHECKm_ENABLEf_SET BCM56504_A0_FP_RANGE_CHECKm_ENABLEf_SET
#define FP_RANGE_CHECKm_SOURCE_DESTINATION_SELECTf_GET BCM56504_A0_FP_RANGE_CHECKm_SOURCE_DESTINATION_SELECTf_GET
#define FP_RANGE_CHECKm_SOURCE_DESTINATION_SELECTf_SET BCM56504_A0_FP_RANGE_CHECKm_SOURCE_DESTINATION_SELECTf_SET
#define READ_FP_RANGE_CHECKm BCM56504_A0_READ_FP_RANGE_CHECKm
#define WRITE_FP_RANGE_CHECKm BCM56504_A0_WRITE_FP_RANGE_CHECKm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_FP_RANGE_CHECKm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  FP_TCAM
 * BLOCKS:   IPIPE
 * DESC:     TCAM FOR FP
 * SIZE:     370
 * FIELDS:
 *     VALID            VALID BIT
 *     PKT_TYPE         Indicates if the packet is a HIGIG (1) or non HIGIG (0) packet
 *     SOURCE_PORT_NUMBER SOURCE_PORT_NUMBER
 *     RESERVED_KEY1    RESERVED
 *     IPBM_SEL         Used to indicate the Input Port Bitmap (IPBM) is applied to the TCAM
 *     F3               F3 field
 *     F2               F2 field
 *     F1               F1 field
 *     PKT_TYPE_MASK    PKT TYPE MASK
 *     SOURCE_PORT_NUMBER_MASK SOURCE_PORT_NUMBER MASK
 *     RESERVED_MASK    Reserved bit
 *     IPBM_SEL_MASK    Used to indicate the Input Port Bitmap (IPBM) is applied to the TCAM MASK
 *     F3_MASK          F3 field MASK
 *     F2_MASK          F2 field MASK
 *     F1_MASK          F1 field MASK
 *
 ******************************************************************************/
#define BCM56504_A0_FP_TCAMm 0x0c720000

#define BCM56504_A0_FP_TCAMm_MIN 0
#define BCM56504_A0_FP_TCAMm_MAX 2047
#define BCM56504_A0_FP_TCAMm_CMAX(u) 2047
#define BCM56504_A0_FP_TCAMm_SIZE 47

/*
 * This structure should be used to declare and program FP_TCAM.
 *
 */
typedef union BCM56504_A0_FP_TCAMm_s {
	uint32_t v[12];
	uint32_t fp_tcam[12];
	uint32_t _fp_tcam;
} BCM56504_A0_FP_TCAMm_t;

#define BCM56504_A0_FP_TCAMm_CLR(r) CDK_MEMSET(&((r)._fp_tcam), 0, sizeof(BCM56504_A0_FP_TCAMm_t))
#define BCM56504_A0_FP_TCAMm_SET(r,i,d) (r).fp_tcam[i] = d
#define BCM56504_A0_FP_TCAMm_GET(r,i) (r).fp_tcam[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_FP_TCAMm_VALIDf_GET(r) (((r).fp_tcam[0]) & 0x3)
#define BCM56504_A0_FP_TCAMm_VALIDf_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56504_A0_FP_TCAMm_PKT_TYPEf_GET(r) ((((r).fp_tcam[0]) >> 2) & 0x1)
#define BCM56504_A0_FP_TCAMm_PKT_TYPEf_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_FP_TCAMm_SOURCE_PORT_NUMBERf_GET(r) ((((r).fp_tcam[0]) >> 3) & 0x1f)
#define BCM56504_A0_FP_TCAMm_SOURCE_PORT_NUMBERf_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32_t)0x1f << 3)) | ((((uint32_t)f) & 0x1f) << 3))
#define BCM56504_A0_FP_TCAMm_RESERVED_KEY1f_GET(r) ((((r).fp_tcam[0]) >> 8) & 0x1)
#define BCM56504_A0_FP_TCAMm_RESERVED_KEY1f_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56504_A0_FP_TCAMm_IPBM_SELf_GET(r) ((((r).fp_tcam[0]) >> 9) & 0x1)
#define BCM56504_A0_FP_TCAMm_IPBM_SELf_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56504_A0_FP_TCAMm_F3f_GET(r) ((((r).fp_tcam[0]) >> 10) & 0xffff)
#define BCM56504_A0_FP_TCAMm_F3f_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32_t)0xffff << 10)) | ((((uint32_t)f) & 0xffff) << 10))
#define BCM56504_A0_FP_TCAMm_F2f_GET(r,a) cdk_field_get((r).fp_tcam,26,153,a)
#define BCM56504_A0_FP_TCAMm_F2f_SET(r,a) cdk_field_set((r).fp_tcam,26,153,a)
#define BCM56504_A0_FP_TCAMm_F1f_GET(r) cdk_field32_get((r).fp_tcam,154,185)
#define BCM56504_A0_FP_TCAMm_F1f_SET(r,f) cdk_field32_set((r).fp_tcam,154,185,f)
#define BCM56504_A0_FP_TCAMm_PKT_TYPE_MASKf_GET(r) ((((r).fp_tcam[5]) >> 26) & 0x1)
#define BCM56504_A0_FP_TCAMm_PKT_TYPE_MASKf_SET(r,f) (r).fp_tcam[5]=(((r).fp_tcam[5] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM56504_A0_FP_TCAMm_SOURCE_PORT_NUMBER_MASKf_GET(r) ((((r).fp_tcam[5]) >> 27) & 0x1f)
#define BCM56504_A0_FP_TCAMm_SOURCE_PORT_NUMBER_MASKf_SET(r,f) (r).fp_tcam[5]=(((r).fp_tcam[5] & ~((uint32_t)0x1f << 27)) | ((((uint32_t)f) & 0x1f) << 27))
#define BCM56504_A0_FP_TCAMm_RESERVED_MASKf_GET(r) (((r).fp_tcam[6]) & 0x1)
#define BCM56504_A0_FP_TCAMm_RESERVED_MASKf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_FP_TCAMm_IPBM_SEL_MASKf_GET(r) ((((r).fp_tcam[6]) >> 1) & 0x1)
#define BCM56504_A0_FP_TCAMm_IPBM_SEL_MASKf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_FP_TCAMm_F3_MASKf_GET(r) ((((r).fp_tcam[6]) >> 2) & 0xffff)
#define BCM56504_A0_FP_TCAMm_F3_MASKf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32_t)0xffff << 2)) | ((((uint32_t)f) & 0xffff) << 2))
#define BCM56504_A0_FP_TCAMm_F2_MASKf_GET(r,a) cdk_field_get((r).fp_tcam,210,337,a)
#define BCM56504_A0_FP_TCAMm_F2_MASKf_SET(r,a) cdk_field_set((r).fp_tcam,210,337,a)
#define BCM56504_A0_FP_TCAMm_F1_MASKf_GET(r) cdk_field32_get((r).fp_tcam,338,369)
#define BCM56504_A0_FP_TCAMm_F1_MASKf_SET(r,f) cdk_field32_set((r).fp_tcam,338,369,f)

/*
 * These macros can be used to access FP_TCAM.
 *
 */
#define BCM56504_A0_READ_FP_TCAMm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_FP_TCAMm,i,(m._fp_tcam),12)
#define BCM56504_A0_WRITE_FP_TCAMm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_FP_TCAMm,i,&(m._fp_tcam),12)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_TCAMm BCM56504_A0_FP_TCAMm
#define FP_TCAMm_MIN BCM56504_A0_FP_TCAMm_MIN
#define FP_TCAMm_MAX BCM56504_A0_FP_TCAMm_MAX
#define FP_TCAMm_CMAX(u) BCM56504_A0_FP_TCAMm_CMAX(u)
#define FP_TCAMm_SIZE BCM56504_A0_FP_TCAMm_SIZE
typedef BCM56504_A0_FP_TCAMm_t FP_TCAMm_t;
#define FP_TCAMm_CLR BCM56504_A0_FP_TCAMm_CLR
#define FP_TCAMm_SET BCM56504_A0_FP_TCAMm_SET
#define FP_TCAMm_GET BCM56504_A0_FP_TCAMm_GET
#define FP_TCAMm_VALIDf_GET BCM56504_A0_FP_TCAMm_VALIDf_GET
#define FP_TCAMm_VALIDf_SET BCM56504_A0_FP_TCAMm_VALIDf_SET
#define FP_TCAMm_PKT_TYPEf_GET BCM56504_A0_FP_TCAMm_PKT_TYPEf_GET
#define FP_TCAMm_PKT_TYPEf_SET BCM56504_A0_FP_TCAMm_PKT_TYPEf_SET
#define FP_TCAMm_SOURCE_PORT_NUMBERf_GET BCM56504_A0_FP_TCAMm_SOURCE_PORT_NUMBERf_GET
#define FP_TCAMm_SOURCE_PORT_NUMBERf_SET BCM56504_A0_FP_TCAMm_SOURCE_PORT_NUMBERf_SET
#define FP_TCAMm_RESERVED_KEY1f_GET BCM56504_A0_FP_TCAMm_RESERVED_KEY1f_GET
#define FP_TCAMm_RESERVED_KEY1f_SET BCM56504_A0_FP_TCAMm_RESERVED_KEY1f_SET
#define FP_TCAMm_IPBM_SELf_GET BCM56504_A0_FP_TCAMm_IPBM_SELf_GET
#define FP_TCAMm_IPBM_SELf_SET BCM56504_A0_FP_TCAMm_IPBM_SELf_SET
#define FP_TCAMm_F3f_GET BCM56504_A0_FP_TCAMm_F3f_GET
#define FP_TCAMm_F3f_SET BCM56504_A0_FP_TCAMm_F3f_SET
#define FP_TCAMm_F2f_GET BCM56504_A0_FP_TCAMm_F2f_GET
#define FP_TCAMm_F2f_SET BCM56504_A0_FP_TCAMm_F2f_SET
#define FP_TCAMm_F1f_GET BCM56504_A0_FP_TCAMm_F1f_GET
#define FP_TCAMm_F1f_SET BCM56504_A0_FP_TCAMm_F1f_SET
#define FP_TCAMm_PKT_TYPE_MASKf_GET BCM56504_A0_FP_TCAMm_PKT_TYPE_MASKf_GET
#define FP_TCAMm_PKT_TYPE_MASKf_SET BCM56504_A0_FP_TCAMm_PKT_TYPE_MASKf_SET
#define FP_TCAMm_SOURCE_PORT_NUMBER_MASKf_GET BCM56504_A0_FP_TCAMm_SOURCE_PORT_NUMBER_MASKf_GET
#define FP_TCAMm_SOURCE_PORT_NUMBER_MASKf_SET BCM56504_A0_FP_TCAMm_SOURCE_PORT_NUMBER_MASKf_SET
#define FP_TCAMm_RESERVED_MASKf_GET BCM56504_A0_FP_TCAMm_RESERVED_MASKf_GET
#define FP_TCAMm_RESERVED_MASKf_SET BCM56504_A0_FP_TCAMm_RESERVED_MASKf_SET
#define FP_TCAMm_IPBM_SEL_MASKf_GET BCM56504_A0_FP_TCAMm_IPBM_SEL_MASKf_GET
#define FP_TCAMm_IPBM_SEL_MASKf_SET BCM56504_A0_FP_TCAMm_IPBM_SEL_MASKf_SET
#define FP_TCAMm_F3_MASKf_GET BCM56504_A0_FP_TCAMm_F3_MASKf_GET
#define FP_TCAMm_F3_MASKf_SET BCM56504_A0_FP_TCAMm_F3_MASKf_SET
#define FP_TCAMm_F2_MASKf_GET BCM56504_A0_FP_TCAMm_F2_MASKf_GET
#define FP_TCAMm_F2_MASKf_SET BCM56504_A0_FP_TCAMm_F2_MASKf_SET
#define FP_TCAMm_F1_MASKf_GET BCM56504_A0_FP_TCAMm_F1_MASKf_GET
#define FP_TCAMm_F1_MASKf_SET BCM56504_A0_FP_TCAMm_F1_MASKf_SET
#define READ_FP_TCAMm BCM56504_A0_READ_FP_TCAMm
#define WRITE_FP_TCAMm BCM56504_A0_WRITE_FP_TCAMm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_FP_TCAMm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  FP_TCAM_PLUS_POLICY
 * BLOCKS:   IPIPE
 * DESC:     TCAM AND POLICY TABLE VIEW FOR FP
 * SIZE:     510
 * FIELDS:
 *     VALID            VALID BIT
 *     PKT_TYPE         Indicates if the packet is a HIGIG (1) or non HIGIG (0) packet
 *     RESERVED_KEY1    RESERVED
 *     IPBM_SEL         Used to indicate the Input Port Bitmap (IPBM) is applied to the TCAM
 *     F3               F3 field
 *     F2               F2 field
 *     F1               F1 field
 *     PKT_TYPE_MASK    PKT TYPE MASK
 *     RESERVED_MASK    Reserved bit
 *     IPBM_SEL_MASK    Used to indicate the Input Port Bitmap (IPBM) is applied to the TCAM MASK
 *     F3_MASK          F3 field MASK
 *     F2_MASK          F2 field MASK
 *     F1_MASK          F1 field MASK
 *     EM_MTP_INDEX     EM_MTP_INDEX
 *     IM_MTP_INDEX     IM_MTP_INDEX
 *     MTP_INDEX_SPARE  MTP_INDEX_SPARE
 *     CHAIN_INDEX      CHAIN_INDEX
 *     CHAIN_VALID      CHAIN_VALID
 *     ECMP_PTR         ECMP_PTR
 *     ECMP_COUNT       ECMP_COUNT
 *     ECMP             ECMP
 *     YP_DSCP          YP_DSCP
 *     RP_DSCP          RP_DSCP
 *     NEWDSCP_TOS      NEWDSCP_TOS
 *     NEWPRI           NEWPRI
 *     METER_PAIR_MODE  METER_PAIR_MODE
 *     METER_TEST_EVEN  METER_TEST_EVEN
 *     METER_TEST_ODD   METER_TEST_ODD
 *     METER_UPDATE_EVEN METER_UPDATE_EVEN
 *     METER_UPDATE_ODD METER_UPDATE_ODD
 *     METER_INDEX_EVEN METER_INDEX_EVEN
 *     METER_INDEX_ODD  METER_INDEX_ODD
 *     COUNTER_MODE     COUNTER_MODE
 *     COUNTER_INDEX    COUNTER_INDEX
 *     YP_CHANGE_DSCP   YP_CHANGE_DSCP
 *     YP_COPY_TO_CPU   YP_COPY_TO_CPU
 *     YP_DROP_PRECEDENCE YP_DROP_PRECEDENCE
 *     YP_DROP          YP_DROP
 *     RP_CHANGE_DSCP   RP_CHANGE_DSCP
 *     RP_COPY_TO_CPU   RP_COPY_TO_CPU
 *     RP_DROP_PRECEDENCE RP_DROP_PRECEDENCE
 *     RP_DROP          RP_DROP
 *     DROP_PRECEDENCE  DROP_PRECEDENCE
 *     L3SW_CHANGE_MACDA_OR_VLAN L3SW_CHANGE_MACDA_OR_VLAN
 *     MIRROR           MIRROR
 *     DROP             DROP
 *     CHAIN            CHAIN
 *     PACKET_REDIRECTION PACKET_REDIRECTION
 *     COPY_TO_CPU      COPY_TO_CPU
 *     CHANGE_DSCP_TOS  CHANGE_DSCP_TOS
 *     CHANGE_PRIORITY  CHANGE_PRIORITY
 *     RESERVED_PT1     RESERVED
 *     SOURCE_PORT_NUMBER SOURCE_PORT_NUMBER
 *     SOURCE_PORT_NUMBER_MASK SOURCE_PORT_NUMBER MASK
 *     REDIRECTION      REDIRECTION
 *     NEXT_HOP_INDEX   NEXT_HOP_INDEX
 *     CLASSIFICATION_TAG CLASSIFICATION_TAG
 *     MATCHED_RULE     MATCHED_RULE
 *
 ******************************************************************************/
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm 0x0c740000

#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_MIN 0
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_MAX 2047
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_CMAX(u) 2047
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_SIZE 64

/*
 * This structure should be used to declare and program FP_TCAM_PLUS_POLICY.
 *
 */
typedef union BCM56504_A0_FP_TCAM_PLUS_POLICYm_s {
	uint32_t v[16];
	uint32_t fp_tcam_plus_policy[16];
	uint32_t _fp_tcam_plus_policy;
} BCM56504_A0_FP_TCAM_PLUS_POLICYm_t;

#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_CLR(r) CDK_MEMSET(&((r)._fp_tcam_plus_policy), 0, sizeof(BCM56504_A0_FP_TCAM_PLUS_POLICYm_t))
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_SET(r,i,d) (r).fp_tcam_plus_policy[i] = d
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_GET(r,i) (r).fp_tcam_plus_policy[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_VALIDf_GET(r) (((r).fp_tcam_plus_policy[0]) & 0x3)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_VALIDf_SET(r,f) (r).fp_tcam_plus_policy[0]=(((r).fp_tcam_plus_policy[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_PKT_TYPEf_GET(r) ((((r).fp_tcam_plus_policy[0]) >> 2) & 0x1)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_PKT_TYPEf_SET(r,f) (r).fp_tcam_plus_policy[0]=(((r).fp_tcam_plus_policy[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_RESERVED_KEY1f_GET(r) ((((r).fp_tcam_plus_policy[0]) >> 8) & 0x1)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_RESERVED_KEY1f_SET(r,f) (r).fp_tcam_plus_policy[0]=(((r).fp_tcam_plus_policy[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_IPBM_SELf_GET(r) ((((r).fp_tcam_plus_policy[0]) >> 9) & 0x1)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_IPBM_SELf_SET(r,f) (r).fp_tcam_plus_policy[0]=(((r).fp_tcam_plus_policy[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_F3f_GET(r) ((((r).fp_tcam_plus_policy[0]) >> 10) & 0xffff)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_F3f_SET(r,f) (r).fp_tcam_plus_policy[0]=(((r).fp_tcam_plus_policy[0] & ~((uint32_t)0xffff << 10)) | ((((uint32_t)f) & 0xffff) << 10))
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_F2f_GET(r,a) cdk_field_get((r).fp_tcam_plus_policy,26,153,a)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_F2f_SET(r,a) cdk_field_set((r).fp_tcam_plus_policy,26,153,a)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_F1f_GET(r) cdk_field32_get((r).fp_tcam_plus_policy,154,185)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_F1f_SET(r,f) cdk_field32_set((r).fp_tcam_plus_policy,154,185,f)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_PKT_TYPE_MASKf_GET(r) ((((r).fp_tcam_plus_policy[5]) >> 26) & 0x1)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_PKT_TYPE_MASKf_SET(r,f) (r).fp_tcam_plus_policy[5]=(((r).fp_tcam_plus_policy[5] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_RESERVED_MASKf_GET(r) (((r).fp_tcam_plus_policy[6]) & 0x1)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_RESERVED_MASKf_SET(r,f) (r).fp_tcam_plus_policy[6]=(((r).fp_tcam_plus_policy[6] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_IPBM_SEL_MASKf_GET(r) ((((r).fp_tcam_plus_policy[6]) >> 1) & 0x1)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_IPBM_SEL_MASKf_SET(r,f) (r).fp_tcam_plus_policy[6]=(((r).fp_tcam_plus_policy[6] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_F3_MASKf_GET(r) ((((r).fp_tcam_plus_policy[6]) >> 2) & 0xffff)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_F3_MASKf_SET(r,f) (r).fp_tcam_plus_policy[6]=(((r).fp_tcam_plus_policy[6] & ~((uint32_t)0xffff << 2)) | ((((uint32_t)f) & 0xffff) << 2))
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_F2_MASKf_GET(r,a) cdk_field_get((r).fp_tcam_plus_policy,210,337,a)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_F2_MASKf_SET(r,a) cdk_field_set((r).fp_tcam_plus_policy,210,337,a)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_F1_MASKf_GET(r) cdk_field32_get((r).fp_tcam_plus_policy,338,369)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_F1_MASKf_SET(r,f) cdk_field32_set((r).fp_tcam_plus_policy,338,369,f)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_EM_MTP_INDEXf_GET(r) ((((r).fp_tcam_plus_policy[11]) >> 18) & 0x3)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_EM_MTP_INDEXf_SET(r,f) (r).fp_tcam_plus_policy[11]=(((r).fp_tcam_plus_policy[11] & ~((uint32_t)0x3 << 18)) | ((((uint32_t)f) & 0x3) << 18))
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_IM_MTP_INDEXf_GET(r) ((((r).fp_tcam_plus_policy[11]) >> 20) & 0x3)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_IM_MTP_INDEXf_SET(r,f) (r).fp_tcam_plus_policy[11]=(((r).fp_tcam_plus_policy[11] & ~((uint32_t)0x3 << 20)) | ((((uint32_t)f) & 0x3) << 20))
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_MTP_INDEX_SPAREf_GET(r) ((((r).fp_tcam_plus_policy[11]) >> 22) & 0x1)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_MTP_INDEX_SPAREf_SET(r,f) (r).fp_tcam_plus_policy[11]=(((r).fp_tcam_plus_policy[11] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_CHAIN_INDEXf_GET(r) ((((r).fp_tcam_plus_policy[11]) >> 23) & 0x7f)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_CHAIN_INDEXf_SET(r,f) (r).fp_tcam_plus_policy[11]=(((r).fp_tcam_plus_policy[11] & ~((uint32_t)0x7f << 23)) | ((((uint32_t)f) & 0x7f) << 23))
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_CHAIN_VALIDf_GET(r) ((((r).fp_tcam_plus_policy[11]) >> 30) & 0x1)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_CHAIN_VALIDf_SET(r,f) (r).fp_tcam_plus_policy[11]=(((r).fp_tcam_plus_policy[11] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_ECMP_PTRf_GET(r) ((((r).fp_tcam_plus_policy[12]) >> 20) & 0x7ff)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_ECMP_PTRf_SET(r,f) (r).fp_tcam_plus_policy[12]=(((r).fp_tcam_plus_policy[12] & ~((uint32_t)0x7ff << 20)) | ((((uint32_t)f) & 0x7ff) << 20))
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_ECMP_COUNTf_GET(r) cdk_field32_get((r).fp_tcam_plus_policy,415,419)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_ECMP_COUNTf_SET(r,f) cdk_field32_set((r).fp_tcam_plus_policy,415,419,f)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_ECMPf_GET(r) ((((r).fp_tcam_plus_policy[13]) >> 4) & 0x1)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_ECMPf_SET(r,f) (r).fp_tcam_plus_policy[13]=(((r).fp_tcam_plus_policy[13] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_YP_DSCPf_GET(r) ((((r).fp_tcam_plus_policy[13]) >> 7) & 0x3f)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_YP_DSCPf_SET(r,f) (r).fp_tcam_plus_policy[13]=(((r).fp_tcam_plus_policy[13] & ~((uint32_t)0x3f << 7)) | ((((uint32_t)f) & 0x3f) << 7))
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_RP_DSCPf_GET(r) ((((r).fp_tcam_plus_policy[13]) >> 13) & 0x3f)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_RP_DSCPf_SET(r,f) (r).fp_tcam_plus_policy[13]=(((r).fp_tcam_plus_policy[13] & ~((uint32_t)0x3f << 13)) | ((((uint32_t)f) & 0x3f) << 13))
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_NEWDSCP_TOSf_GET(r) ((((r).fp_tcam_plus_policy[13]) >> 19) & 0x3f)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_NEWDSCP_TOSf_SET(r,f) (r).fp_tcam_plus_policy[13]=(((r).fp_tcam_plus_policy[13] & ~((uint32_t)0x3f << 19)) | ((((uint32_t)f) & 0x3f) << 19))
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_NEWPRIf_GET(r) ((((r).fp_tcam_plus_policy[13]) >> 25) & 0x7)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_NEWPRIf_SET(r,f) (r).fp_tcam_plus_policy[13]=(((r).fp_tcam_plus_policy[13] & ~((uint32_t)0x7 << 25)) | ((((uint32_t)f) & 0x7) << 25))
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_METER_PAIR_MODEf_GET(r) ((((r).fp_tcam_plus_policy[13]) >> 28) & 0x7)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_METER_PAIR_MODEf_SET(r,f) (r).fp_tcam_plus_policy[13]=(((r).fp_tcam_plus_policy[13] & ~((uint32_t)0x7 << 28)) | ((((uint32_t)f) & 0x7) << 28))
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_METER_TEST_EVENf_GET(r) ((((r).fp_tcam_plus_policy[13]) >> 31) & 0x1)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_METER_TEST_EVENf_SET(r,f) (r).fp_tcam_plus_policy[13]=(((r).fp_tcam_plus_policy[13] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_METER_TEST_ODDf_GET(r) (((r).fp_tcam_plus_policy[14]) & 0x1)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_METER_TEST_ODDf_SET(r,f) (r).fp_tcam_plus_policy[14]=(((r).fp_tcam_plus_policy[14] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_METER_UPDATE_EVENf_GET(r) ((((r).fp_tcam_plus_policy[14]) >> 1) & 0x1)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_METER_UPDATE_EVENf_SET(r,f) (r).fp_tcam_plus_policy[14]=(((r).fp_tcam_plus_policy[14] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_METER_UPDATE_ODDf_GET(r) ((((r).fp_tcam_plus_policy[14]) >> 2) & 0x1)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_METER_UPDATE_ODDf_SET(r,f) (r).fp_tcam_plus_policy[14]=(((r).fp_tcam_plus_policy[14] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_METER_INDEX_EVENf_GET(r) ((((r).fp_tcam_plus_policy[14]) >> 3) & 0x3f)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_METER_INDEX_EVENf_SET(r,f) (r).fp_tcam_plus_policy[14]=(((r).fp_tcam_plus_policy[14] & ~((uint32_t)0x3f << 3)) | ((((uint32_t)f) & 0x3f) << 3))
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_METER_INDEX_ODDf_GET(r) ((((r).fp_tcam_plus_policy[14]) >> 9) & 0x3f)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_METER_INDEX_ODDf_SET(r,f) (r).fp_tcam_plus_policy[14]=(((r).fp_tcam_plus_policy[14] & ~((uint32_t)0x3f << 9)) | ((((uint32_t)f) & 0x3f) << 9))
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_COUNTER_MODEf_GET(r) ((((r).fp_tcam_plus_policy[14]) >> 15) & 0xf)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_COUNTER_MODEf_SET(r,f) (r).fp_tcam_plus_policy[14]=(((r).fp_tcam_plus_policy[14] & ~((uint32_t)0xf << 15)) | ((((uint32_t)f) & 0xf) << 15))
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_COUNTER_INDEXf_GET(r) ((((r).fp_tcam_plus_policy[14]) >> 19) & 0x3f)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_COUNTER_INDEXf_SET(r,f) (r).fp_tcam_plus_policy[14]=(((r).fp_tcam_plus_policy[14] & ~((uint32_t)0x3f << 19)) | ((((uint32_t)f) & 0x3f) << 19))
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_YP_CHANGE_DSCPf_GET(r) ((((r).fp_tcam_plus_policy[14]) >> 25) & 0x1)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_YP_CHANGE_DSCPf_SET(r,f) (r).fp_tcam_plus_policy[14]=(((r).fp_tcam_plus_policy[14] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_YP_COPY_TO_CPUf_GET(r) ((((r).fp_tcam_plus_policy[14]) >> 26) & 0x3)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_YP_COPY_TO_CPUf_SET(r,f) (r).fp_tcam_plus_policy[14]=(((r).fp_tcam_plus_policy[14] & ~((uint32_t)0x3 << 26)) | ((((uint32_t)f) & 0x3) << 26))
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_YP_DROP_PRECEDENCEf_GET(r) ((((r).fp_tcam_plus_policy[14]) >> 28) & 0x3)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_YP_DROP_PRECEDENCEf_SET(r,f) (r).fp_tcam_plus_policy[14]=(((r).fp_tcam_plus_policy[14] & ~((uint32_t)0x3 << 28)) | ((((uint32_t)f) & 0x3) << 28))
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_YP_DROPf_GET(r) ((((r).fp_tcam_plus_policy[14]) >> 30) & 0x3)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_YP_DROPf_SET(r,f) (r).fp_tcam_plus_policy[14]=(((r).fp_tcam_plus_policy[14] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_RP_CHANGE_DSCPf_GET(r) (((r).fp_tcam_plus_policy[15]) & 0x1)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_RP_CHANGE_DSCPf_SET(r,f) (r).fp_tcam_plus_policy[15]=(((r).fp_tcam_plus_policy[15] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_RP_COPY_TO_CPUf_GET(r) ((((r).fp_tcam_plus_policy[15]) >> 1) & 0x3)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_RP_COPY_TO_CPUf_SET(r,f) (r).fp_tcam_plus_policy[15]=(((r).fp_tcam_plus_policy[15] & ~((uint32_t)0x3 << 1)) | ((((uint32_t)f) & 0x3) << 1))
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_RP_DROP_PRECEDENCEf_GET(r) ((((r).fp_tcam_plus_policy[15]) >> 3) & 0x3)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_RP_DROP_PRECEDENCEf_SET(r,f) (r).fp_tcam_plus_policy[15]=(((r).fp_tcam_plus_policy[15] & ~((uint32_t)0x3 << 3)) | ((((uint32_t)f) & 0x3) << 3))
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_RP_DROPf_GET(r) ((((r).fp_tcam_plus_policy[15]) >> 5) & 0x3)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_RP_DROPf_SET(r,f) (r).fp_tcam_plus_policy[15]=(((r).fp_tcam_plus_policy[15] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5))
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_DROP_PRECEDENCEf_GET(r) ((((r).fp_tcam_plus_policy[15]) >> 7) & 0x3)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_DROP_PRECEDENCEf_SET(r,f) (r).fp_tcam_plus_policy[15]=(((r).fp_tcam_plus_policy[15] & ~((uint32_t)0x3 << 7)) | ((((uint32_t)f) & 0x3) << 7))
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_L3SW_CHANGE_MACDA_OR_VLANf_GET(r) ((((r).fp_tcam_plus_policy[15]) >> 9) & 0x7)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_L3SW_CHANGE_MACDA_OR_VLANf_SET(r,f) (r).fp_tcam_plus_policy[15]=(((r).fp_tcam_plus_policy[15] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_MIRRORf_GET(r) ((((r).fp_tcam_plus_policy[15]) >> 12) & 0x3)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_MIRRORf_SET(r,f) (r).fp_tcam_plus_policy[15]=(((r).fp_tcam_plus_policy[15] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_DROPf_GET(r) ((((r).fp_tcam_plus_policy[15]) >> 14) & 0x3)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_DROPf_SET(r,f) (r).fp_tcam_plus_policy[15]=(((r).fp_tcam_plus_policy[15] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_CHAINf_GET(r) ((((r).fp_tcam_plus_policy[15]) >> 16) & 0x1)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_CHAINf_SET(r,f) (r).fp_tcam_plus_policy[15]=(((r).fp_tcam_plus_policy[15] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_PACKET_REDIRECTIONf_GET(r) ((((r).fp_tcam_plus_policy[15]) >> 17) & 0x7)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_PACKET_REDIRECTIONf_SET(r,f) (r).fp_tcam_plus_policy[15]=(((r).fp_tcam_plus_policy[15] & ~((uint32_t)0x7 << 17)) | ((((uint32_t)f) & 0x7) << 17))
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_COPY_TO_CPUf_GET(r) ((((r).fp_tcam_plus_policy[15]) >> 20) & 0x3)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_COPY_TO_CPUf_SET(r,f) (r).fp_tcam_plus_policy[15]=(((r).fp_tcam_plus_policy[15] & ~((uint32_t)0x3 << 20)) | ((((uint32_t)f) & 0x3) << 20))
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_CHANGE_DSCP_TOSf_GET(r) ((((r).fp_tcam_plus_policy[15]) >> 22) & 0x7)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_CHANGE_DSCP_TOSf_SET(r,f) (r).fp_tcam_plus_policy[15]=(((r).fp_tcam_plus_policy[15] & ~((uint32_t)0x7 << 22)) | ((((uint32_t)f) & 0x7) << 22))
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_CHANGE_PRIORITYf_GET(r) ((((r).fp_tcam_plus_policy[15]) >> 25) & 0xf)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_CHANGE_PRIORITYf_SET(r,f) (r).fp_tcam_plus_policy[15]=(((r).fp_tcam_plus_policy[15] & ~((uint32_t)0xf << 25)) | ((((uint32_t)f) & 0xf) << 25))
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_RESERVED_PT1f_GET(r) ((((r).fp_tcam_plus_policy[15]) >> 29) & 0x1)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_RESERVED_PT1f_SET(r,f) (r).fp_tcam_plus_policy[15]=(((r).fp_tcam_plus_policy[15] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_SOURCE_PORT_NUMBERf_GET(r) ((((r).fp_tcam_plus_policy[0]) >> 3) & 0x1f)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_SOURCE_PORT_NUMBERf_SET(r,f) (r).fp_tcam_plus_policy[0]=(((r).fp_tcam_plus_policy[0] & ~((uint32_t)0x1f << 3)) | ((((uint32_t)f) & 0x1f) << 3))
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_SOURCE_PORT_NUMBER_MASKf_GET(r) ((((r).fp_tcam_plus_policy[5]) >> 27) & 0x1f)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_SOURCE_PORT_NUMBER_MASKf_SET(r,f) (r).fp_tcam_plus_policy[5]=(((r).fp_tcam_plus_policy[5] & ~((uint32_t)0x1f << 27)) | ((((uint32_t)f) & 0x1f) << 27))
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_REDIRECTIONf_GET(r) cdk_field32_get((r).fp_tcam_plus_policy,375,403)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_REDIRECTIONf_SET(r,f) cdk_field32_set((r).fp_tcam_plus_policy,375,403,f)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_NEXT_HOP_INDEXf_GET(r) cdk_field32_get((r).fp_tcam_plus_policy,404,416)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_NEXT_HOP_INDEXf_SET(r,f) cdk_field32_set((r).fp_tcam_plus_policy,404,416,f)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_CLASSIFICATION_TAGf_GET(r) ((((r).fp_tcam_plus_policy[12]) >> 20) & 0x7ff)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_CLASSIFICATION_TAGf_SET(r,f) (r).fp_tcam_plus_policy[12]=(((r).fp_tcam_plus_policy[12] & ~((uint32_t)0x7ff << 20)) | ((((uint32_t)f) & 0x7ff) << 20))
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_MATCHED_RULEf_GET(r) cdk_field32_get((r).fp_tcam_plus_policy,415,422)
#define BCM56504_A0_FP_TCAM_PLUS_POLICYm_MATCHED_RULEf_SET(r,f) cdk_field32_set((r).fp_tcam_plus_policy,415,422,f)

/*
 * These macros can be used to access FP_TCAM_PLUS_POLICY.
 *
 */
#define BCM56504_A0_READ_FP_TCAM_PLUS_POLICYm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_FP_TCAM_PLUS_POLICYm,i,(m._fp_tcam_plus_policy),16)
#define BCM56504_A0_WRITE_FP_TCAM_PLUS_POLICYm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_FP_TCAM_PLUS_POLICYm,i,&(m._fp_tcam_plus_policy),16)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_TCAM_PLUS_POLICYm BCM56504_A0_FP_TCAM_PLUS_POLICYm
#define FP_TCAM_PLUS_POLICYm_MIN BCM56504_A0_FP_TCAM_PLUS_POLICYm_MIN
#define FP_TCAM_PLUS_POLICYm_MAX BCM56504_A0_FP_TCAM_PLUS_POLICYm_MAX
#define FP_TCAM_PLUS_POLICYm_CMAX(u) BCM56504_A0_FP_TCAM_PLUS_POLICYm_CMAX(u)
#define FP_TCAM_PLUS_POLICYm_SIZE BCM56504_A0_FP_TCAM_PLUS_POLICYm_SIZE
typedef BCM56504_A0_FP_TCAM_PLUS_POLICYm_t FP_TCAM_PLUS_POLICYm_t;
#define FP_TCAM_PLUS_POLICYm_CLR BCM56504_A0_FP_TCAM_PLUS_POLICYm_CLR
#define FP_TCAM_PLUS_POLICYm_SET BCM56504_A0_FP_TCAM_PLUS_POLICYm_SET
#define FP_TCAM_PLUS_POLICYm_GET BCM56504_A0_FP_TCAM_PLUS_POLICYm_GET
#define FP_TCAM_PLUS_POLICYm_VALIDf_GET BCM56504_A0_FP_TCAM_PLUS_POLICYm_VALIDf_GET
#define FP_TCAM_PLUS_POLICYm_VALIDf_SET BCM56504_A0_FP_TCAM_PLUS_POLICYm_VALIDf_SET
#define FP_TCAM_PLUS_POLICYm_PKT_TYPEf_GET BCM56504_A0_FP_TCAM_PLUS_POLICYm_PKT_TYPEf_GET
#define FP_TCAM_PLUS_POLICYm_PKT_TYPEf_SET BCM56504_A0_FP_TCAM_PLUS_POLICYm_PKT_TYPEf_SET
#define FP_TCAM_PLUS_POLICYm_RESERVED_KEY1f_GET BCM56504_A0_FP_TCAM_PLUS_POLICYm_RESERVED_KEY1f_GET
#define FP_TCAM_PLUS_POLICYm_RESERVED_KEY1f_SET BCM56504_A0_FP_TCAM_PLUS_POLICYm_RESERVED_KEY1f_SET
#define FP_TCAM_PLUS_POLICYm_IPBM_SELf_GET BCM56504_A0_FP_TCAM_PLUS_POLICYm_IPBM_SELf_GET
#define FP_TCAM_PLUS_POLICYm_IPBM_SELf_SET BCM56504_A0_FP_TCAM_PLUS_POLICYm_IPBM_SELf_SET
#define FP_TCAM_PLUS_POLICYm_F3f_GET BCM56504_A0_FP_TCAM_PLUS_POLICYm_F3f_GET
#define FP_TCAM_PLUS_POLICYm_F3f_SET BCM56504_A0_FP_TCAM_PLUS_POLICYm_F3f_SET
#define FP_TCAM_PLUS_POLICYm_F2f_GET BCM56504_A0_FP_TCAM_PLUS_POLICYm_F2f_GET
#define FP_TCAM_PLUS_POLICYm_F2f_SET BCM56504_A0_FP_TCAM_PLUS_POLICYm_F2f_SET
#define FP_TCAM_PLUS_POLICYm_F1f_GET BCM56504_A0_FP_TCAM_PLUS_POLICYm_F1f_GET
#define FP_TCAM_PLUS_POLICYm_F1f_SET BCM56504_A0_FP_TCAM_PLUS_POLICYm_F1f_SET
#define FP_TCAM_PLUS_POLICYm_PKT_TYPE_MASKf_GET BCM56504_A0_FP_TCAM_PLUS_POLICYm_PKT_TYPE_MASKf_GET
#define FP_TCAM_PLUS_POLICYm_PKT_TYPE_MASKf_SET BCM56504_A0_FP_TCAM_PLUS_POLICYm_PKT_TYPE_MASKf_SET
#define FP_TCAM_PLUS_POLICYm_RESERVED_MASKf_GET BCM56504_A0_FP_TCAM_PLUS_POLICYm_RESERVED_MASKf_GET
#define FP_TCAM_PLUS_POLICYm_RESERVED_MASKf_SET BCM56504_A0_FP_TCAM_PLUS_POLICYm_RESERVED_MASKf_SET
#define FP_TCAM_PLUS_POLICYm_IPBM_SEL_MASKf_GET BCM56504_A0_FP_TCAM_PLUS_POLICYm_IPBM_SEL_MASKf_GET
#define FP_TCAM_PLUS_POLICYm_IPBM_SEL_MASKf_SET BCM56504_A0_FP_TCAM_PLUS_POLICYm_IPBM_SEL_MASKf_SET
#define FP_TCAM_PLUS_POLICYm_F3_MASKf_GET BCM56504_A0_FP_TCAM_PLUS_POLICYm_F3_MASKf_GET
#define FP_TCAM_PLUS_POLICYm_F3_MASKf_SET BCM56504_A0_FP_TCAM_PLUS_POLICYm_F3_MASKf_SET
#define FP_TCAM_PLUS_POLICYm_F2_MASKf_GET BCM56504_A0_FP_TCAM_PLUS_POLICYm_F2_MASKf_GET
#define FP_TCAM_PLUS_POLICYm_F2_MASKf_SET BCM56504_A0_FP_TCAM_PLUS_POLICYm_F2_MASKf_SET
#define FP_TCAM_PLUS_POLICYm_F1_MASKf_GET BCM56504_A0_FP_TCAM_PLUS_POLICYm_F1_MASKf_GET
#define FP_TCAM_PLUS_POLICYm_F1_MASKf_SET BCM56504_A0_FP_TCAM_PLUS_POLICYm_F1_MASKf_SET
#define FP_TCAM_PLUS_POLICYm_EM_MTP_INDEXf_GET BCM56504_A0_FP_TCAM_PLUS_POLICYm_EM_MTP_INDEXf_GET
#define FP_TCAM_PLUS_POLICYm_EM_MTP_INDEXf_SET BCM56504_A0_FP_TCAM_PLUS_POLICYm_EM_MTP_INDEXf_SET
#define FP_TCAM_PLUS_POLICYm_IM_MTP_INDEXf_GET BCM56504_A0_FP_TCAM_PLUS_POLICYm_IM_MTP_INDEXf_GET
#define FP_TCAM_PLUS_POLICYm_IM_MTP_INDEXf_SET BCM56504_A0_FP_TCAM_PLUS_POLICYm_IM_MTP_INDEXf_SET
#define FP_TCAM_PLUS_POLICYm_MTP_INDEX_SPAREf_GET BCM56504_A0_FP_TCAM_PLUS_POLICYm_MTP_INDEX_SPAREf_GET
#define FP_TCAM_PLUS_POLICYm_MTP_INDEX_SPAREf_SET BCM56504_A0_FP_TCAM_PLUS_POLICYm_MTP_INDEX_SPAREf_SET
#define FP_TCAM_PLUS_POLICYm_CHAIN_INDEXf_GET BCM56504_A0_FP_TCAM_PLUS_POLICYm_CHAIN_INDEXf_GET
#define FP_TCAM_PLUS_POLICYm_CHAIN_INDEXf_SET BCM56504_A0_FP_TCAM_PLUS_POLICYm_CHAIN_INDEXf_SET
#define FP_TCAM_PLUS_POLICYm_CHAIN_VALIDf_GET BCM56504_A0_FP_TCAM_PLUS_POLICYm_CHAIN_VALIDf_GET
#define FP_TCAM_PLUS_POLICYm_CHAIN_VALIDf_SET BCM56504_A0_FP_TCAM_PLUS_POLICYm_CHAIN_VALIDf_SET
#define FP_TCAM_PLUS_POLICYm_ECMP_PTRf_GET BCM56504_A0_FP_TCAM_PLUS_POLICYm_ECMP_PTRf_GET
#define FP_TCAM_PLUS_POLICYm_ECMP_PTRf_SET BCM56504_A0_FP_TCAM_PLUS_POLICYm_ECMP_PTRf_SET
#define FP_TCAM_PLUS_POLICYm_ECMP_COUNTf_GET BCM56504_A0_FP_TCAM_PLUS_POLICYm_ECMP_COUNTf_GET
#define FP_TCAM_PLUS_POLICYm_ECMP_COUNTf_SET BCM56504_A0_FP_TCAM_PLUS_POLICYm_ECMP_COUNTf_SET
#define FP_TCAM_PLUS_POLICYm_ECMPf_GET BCM56504_A0_FP_TCAM_PLUS_POLICYm_ECMPf_GET
#define FP_TCAM_PLUS_POLICYm_ECMPf_SET BCM56504_A0_FP_TCAM_PLUS_POLICYm_ECMPf_SET
#define FP_TCAM_PLUS_POLICYm_YP_DSCPf_GET BCM56504_A0_FP_TCAM_PLUS_POLICYm_YP_DSCPf_GET
#define FP_TCAM_PLUS_POLICYm_YP_DSCPf_SET BCM56504_A0_FP_TCAM_PLUS_POLICYm_YP_DSCPf_SET
#define FP_TCAM_PLUS_POLICYm_RP_DSCPf_GET BCM56504_A0_FP_TCAM_PLUS_POLICYm_RP_DSCPf_GET
#define FP_TCAM_PLUS_POLICYm_RP_DSCPf_SET BCM56504_A0_FP_TCAM_PLUS_POLICYm_RP_DSCPf_SET
#define FP_TCAM_PLUS_POLICYm_NEWDSCP_TOSf_GET BCM56504_A0_FP_TCAM_PLUS_POLICYm_NEWDSCP_TOSf_GET
#define FP_TCAM_PLUS_POLICYm_NEWDSCP_TOSf_SET BCM56504_A0_FP_TCAM_PLUS_POLICYm_NEWDSCP_TOSf_SET
#define FP_TCAM_PLUS_POLICYm_NEWPRIf_GET BCM56504_A0_FP_TCAM_PLUS_POLICYm_NEWPRIf_GET
#define FP_TCAM_PLUS_POLICYm_NEWPRIf_SET BCM56504_A0_FP_TCAM_PLUS_POLICYm_NEWPRIf_SET
#define FP_TCAM_PLUS_POLICYm_METER_PAIR_MODEf_GET BCM56504_A0_FP_TCAM_PLUS_POLICYm_METER_PAIR_MODEf_GET
#define FP_TCAM_PLUS_POLICYm_METER_PAIR_MODEf_SET BCM56504_A0_FP_TCAM_PLUS_POLICYm_METER_PAIR_MODEf_SET
#define FP_TCAM_PLUS_POLICYm_METER_TEST_EVENf_GET BCM56504_A0_FP_TCAM_PLUS_POLICYm_METER_TEST_EVENf_GET
#define FP_TCAM_PLUS_POLICYm_METER_TEST_EVENf_SET BCM56504_A0_FP_TCAM_PLUS_POLICYm_METER_TEST_EVENf_SET
#define FP_TCAM_PLUS_POLICYm_METER_TEST_ODDf_GET BCM56504_A0_FP_TCAM_PLUS_POLICYm_METER_TEST_ODDf_GET
#define FP_TCAM_PLUS_POLICYm_METER_TEST_ODDf_SET BCM56504_A0_FP_TCAM_PLUS_POLICYm_METER_TEST_ODDf_SET
#define FP_TCAM_PLUS_POLICYm_METER_UPDATE_EVENf_GET BCM56504_A0_FP_TCAM_PLUS_POLICYm_METER_UPDATE_EVENf_GET
#define FP_TCAM_PLUS_POLICYm_METER_UPDATE_EVENf_SET BCM56504_A0_FP_TCAM_PLUS_POLICYm_METER_UPDATE_EVENf_SET
#define FP_TCAM_PLUS_POLICYm_METER_UPDATE_ODDf_GET BCM56504_A0_FP_TCAM_PLUS_POLICYm_METER_UPDATE_ODDf_GET
#define FP_TCAM_PLUS_POLICYm_METER_UPDATE_ODDf_SET BCM56504_A0_FP_TCAM_PLUS_POLICYm_METER_UPDATE_ODDf_SET
#define FP_TCAM_PLUS_POLICYm_METER_INDEX_EVENf_GET BCM56504_A0_FP_TCAM_PLUS_POLICYm_METER_INDEX_EVENf_GET
#define FP_TCAM_PLUS_POLICYm_METER_INDEX_EVENf_SET BCM56504_A0_FP_TCAM_PLUS_POLICYm_METER_INDEX_EVENf_SET
#define FP_TCAM_PLUS_POLICYm_METER_INDEX_ODDf_GET BCM56504_A0_FP_TCAM_PLUS_POLICYm_METER_INDEX_ODDf_GET
#define FP_TCAM_PLUS_POLICYm_METER_INDEX_ODDf_SET BCM56504_A0_FP_TCAM_PLUS_POLICYm_METER_INDEX_ODDf_SET
#define FP_TCAM_PLUS_POLICYm_COUNTER_MODEf_GET BCM56504_A0_FP_TCAM_PLUS_POLICYm_COUNTER_MODEf_GET
#define FP_TCAM_PLUS_POLICYm_COUNTER_MODEf_SET BCM56504_A0_FP_TCAM_PLUS_POLICYm_COUNTER_MODEf_SET
#define FP_TCAM_PLUS_POLICYm_COUNTER_INDEXf_GET BCM56504_A0_FP_TCAM_PLUS_POLICYm_COUNTER_INDEXf_GET
#define FP_TCAM_PLUS_POLICYm_COUNTER_INDEXf_SET BCM56504_A0_FP_TCAM_PLUS_POLICYm_COUNTER_INDEXf_SET
#define FP_TCAM_PLUS_POLICYm_YP_CHANGE_DSCPf_GET BCM56504_A0_FP_TCAM_PLUS_POLICYm_YP_CHANGE_DSCPf_GET
#define FP_TCAM_PLUS_POLICYm_YP_CHANGE_DSCPf_SET BCM56504_A0_FP_TCAM_PLUS_POLICYm_YP_CHANGE_DSCPf_SET
#define FP_TCAM_PLUS_POLICYm_YP_COPY_TO_CPUf_GET BCM56504_A0_FP_TCAM_PLUS_POLICYm_YP_COPY_TO_CPUf_GET
#define FP_TCAM_PLUS_POLICYm_YP_COPY_TO_CPUf_SET BCM56504_A0_FP_TCAM_PLUS_POLICYm_YP_COPY_TO_CPUf_SET
#define FP_TCAM_PLUS_POLICYm_YP_DROP_PRECEDENCEf_GET BCM56504_A0_FP_TCAM_PLUS_POLICYm_YP_DROP_PRECEDENCEf_GET
#define FP_TCAM_PLUS_POLICYm_YP_DROP_PRECEDENCEf_SET BCM56504_A0_FP_TCAM_PLUS_POLICYm_YP_DROP_PRECEDENCEf_SET
#define FP_TCAM_PLUS_POLICYm_YP_DROPf_GET BCM56504_A0_FP_TCAM_PLUS_POLICYm_YP_DROPf_GET
#define FP_TCAM_PLUS_POLICYm_YP_DROPf_SET BCM56504_A0_FP_TCAM_PLUS_POLICYm_YP_DROPf_SET
#define FP_TCAM_PLUS_POLICYm_RP_CHANGE_DSCPf_GET BCM56504_A0_FP_TCAM_PLUS_POLICYm_RP_CHANGE_DSCPf_GET
#define FP_TCAM_PLUS_POLICYm_RP_CHANGE_DSCPf_SET BCM56504_A0_FP_TCAM_PLUS_POLICYm_RP_CHANGE_DSCPf_SET
#define FP_TCAM_PLUS_POLICYm_RP_COPY_TO_CPUf_GET BCM56504_A0_FP_TCAM_PLUS_POLICYm_RP_COPY_TO_CPUf_GET
#define FP_TCAM_PLUS_POLICYm_RP_COPY_TO_CPUf_SET BCM56504_A0_FP_TCAM_PLUS_POLICYm_RP_COPY_TO_CPUf_SET
#define FP_TCAM_PLUS_POLICYm_RP_DROP_PRECEDENCEf_GET BCM56504_A0_FP_TCAM_PLUS_POLICYm_RP_DROP_PRECEDENCEf_GET
#define FP_TCAM_PLUS_POLICYm_RP_DROP_PRECEDENCEf_SET BCM56504_A0_FP_TCAM_PLUS_POLICYm_RP_DROP_PRECEDENCEf_SET
#define FP_TCAM_PLUS_POLICYm_RP_DROPf_GET BCM56504_A0_FP_TCAM_PLUS_POLICYm_RP_DROPf_GET
#define FP_TCAM_PLUS_POLICYm_RP_DROPf_SET BCM56504_A0_FP_TCAM_PLUS_POLICYm_RP_DROPf_SET
#define FP_TCAM_PLUS_POLICYm_DROP_PRECEDENCEf_GET BCM56504_A0_FP_TCAM_PLUS_POLICYm_DROP_PRECEDENCEf_GET
#define FP_TCAM_PLUS_POLICYm_DROP_PRECEDENCEf_SET BCM56504_A0_FP_TCAM_PLUS_POLICYm_DROP_PRECEDENCEf_SET
#define FP_TCAM_PLUS_POLICYm_L3SW_CHANGE_MACDA_OR_VLANf_GET BCM56504_A0_FP_TCAM_PLUS_POLICYm_L3SW_CHANGE_MACDA_OR_VLANf_GET
#define FP_TCAM_PLUS_POLICYm_L3SW_CHANGE_MACDA_OR_VLANf_SET BCM56504_A0_FP_TCAM_PLUS_POLICYm_L3SW_CHANGE_MACDA_OR_VLANf_SET
#define FP_TCAM_PLUS_POLICYm_MIRRORf_GET BCM56504_A0_FP_TCAM_PLUS_POLICYm_MIRRORf_GET
#define FP_TCAM_PLUS_POLICYm_MIRRORf_SET BCM56504_A0_FP_TCAM_PLUS_POLICYm_MIRRORf_SET
#define FP_TCAM_PLUS_POLICYm_DROPf_GET BCM56504_A0_FP_TCAM_PLUS_POLICYm_DROPf_GET
#define FP_TCAM_PLUS_POLICYm_DROPf_SET BCM56504_A0_FP_TCAM_PLUS_POLICYm_DROPf_SET
#define FP_TCAM_PLUS_POLICYm_CHAINf_GET BCM56504_A0_FP_TCAM_PLUS_POLICYm_CHAINf_GET
#define FP_TCAM_PLUS_POLICYm_CHAINf_SET BCM56504_A0_FP_TCAM_PLUS_POLICYm_CHAINf_SET
#define FP_TCAM_PLUS_POLICYm_PACKET_REDIRECTIONf_GET BCM56504_A0_FP_TCAM_PLUS_POLICYm_PACKET_REDIRECTIONf_GET
#define FP_TCAM_PLUS_POLICYm_PACKET_REDIRECTIONf_SET BCM56504_A0_FP_TCAM_PLUS_POLICYm_PACKET_REDIRECTIONf_SET
#define FP_TCAM_PLUS_POLICYm_COPY_TO_CPUf_GET BCM56504_A0_FP_TCAM_PLUS_POLICYm_COPY_TO_CPUf_GET
#define FP_TCAM_PLUS_POLICYm_COPY_TO_CPUf_SET BCM56504_A0_FP_TCAM_PLUS_POLICYm_COPY_TO_CPUf_SET
#define FP_TCAM_PLUS_POLICYm_CHANGE_DSCP_TOSf_GET BCM56504_A0_FP_TCAM_PLUS_POLICYm_CHANGE_DSCP_TOSf_GET
#define FP_TCAM_PLUS_POLICYm_CHANGE_DSCP_TOSf_SET BCM56504_A0_FP_TCAM_PLUS_POLICYm_CHANGE_DSCP_TOSf_SET
#define FP_TCAM_PLUS_POLICYm_CHANGE_PRIORITYf_GET BCM56504_A0_FP_TCAM_PLUS_POLICYm_CHANGE_PRIORITYf_GET
#define FP_TCAM_PLUS_POLICYm_CHANGE_PRIORITYf_SET BCM56504_A0_FP_TCAM_PLUS_POLICYm_CHANGE_PRIORITYf_SET
#define FP_TCAM_PLUS_POLICYm_RESERVED_PT1f_GET BCM56504_A0_FP_TCAM_PLUS_POLICYm_RESERVED_PT1f_GET
#define FP_TCAM_PLUS_POLICYm_RESERVED_PT1f_SET BCM56504_A0_FP_TCAM_PLUS_POLICYm_RESERVED_PT1f_SET
#define FP_TCAM_PLUS_POLICYm_SOURCE_PORT_NUMBERf_GET BCM56504_A0_FP_TCAM_PLUS_POLICYm_SOURCE_PORT_NUMBERf_GET
#define FP_TCAM_PLUS_POLICYm_SOURCE_PORT_NUMBERf_SET BCM56504_A0_FP_TCAM_PLUS_POLICYm_SOURCE_PORT_NUMBERf_SET
#define FP_TCAM_PLUS_POLICYm_SOURCE_PORT_NUMBER_MASKf_GET BCM56504_A0_FP_TCAM_PLUS_POLICYm_SOURCE_PORT_NUMBER_MASKf_GET
#define FP_TCAM_PLUS_POLICYm_SOURCE_PORT_NUMBER_MASKf_SET BCM56504_A0_FP_TCAM_PLUS_POLICYm_SOURCE_PORT_NUMBER_MASKf_SET
#define FP_TCAM_PLUS_POLICYm_REDIRECTIONf_GET BCM56504_A0_FP_TCAM_PLUS_POLICYm_REDIRECTIONf_GET
#define FP_TCAM_PLUS_POLICYm_REDIRECTIONf_SET BCM56504_A0_FP_TCAM_PLUS_POLICYm_REDIRECTIONf_SET
#define FP_TCAM_PLUS_POLICYm_NEXT_HOP_INDEXf_GET BCM56504_A0_FP_TCAM_PLUS_POLICYm_NEXT_HOP_INDEXf_GET
#define FP_TCAM_PLUS_POLICYm_NEXT_HOP_INDEXf_SET BCM56504_A0_FP_TCAM_PLUS_POLICYm_NEXT_HOP_INDEXf_SET
#define FP_TCAM_PLUS_POLICYm_CLASSIFICATION_TAGf_GET BCM56504_A0_FP_TCAM_PLUS_POLICYm_CLASSIFICATION_TAGf_GET
#define FP_TCAM_PLUS_POLICYm_CLASSIFICATION_TAGf_SET BCM56504_A0_FP_TCAM_PLUS_POLICYm_CLASSIFICATION_TAGf_SET
#define FP_TCAM_PLUS_POLICYm_MATCHED_RULEf_GET BCM56504_A0_FP_TCAM_PLUS_POLICYm_MATCHED_RULEf_GET
#define FP_TCAM_PLUS_POLICYm_MATCHED_RULEf_SET BCM56504_A0_FP_TCAM_PLUS_POLICYm_MATCHED_RULEf_SET
#define READ_FP_TCAM_PLUS_POLICYm BCM56504_A0_READ_FP_TCAM_PLUS_POLICYm
#define WRITE_FP_TCAM_PLUS_POLICYm BCM56504_A0_WRITE_FP_TCAM_PLUS_POLICYm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_FP_TCAM_PLUS_POLICYm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  FP_UDF_OFFSET
 * BLOCKS:   IPIPE
 * DESC:     FP UDF offset table
 * SIZE:     48
 * FIELDS:
 *     UDF1_OFFSET0     Offset value for UDF1.0
 *     UDF1_ADD_IPV4_OPTIONS0 Control bit to enable adding the IPv4 header option length
 *     UDF1_OFFSET1     Offset value for UDF1.1
 *     UDF1_ADD_IPV4_OPTIONS1 Control bit to enable adding the IPv4 header option length
 *     UDF1_OFFSET2     Offset value for UDF1.2
 *     UDF1_ADD_IPV4_OPTIONS2 Control bit to enable adding the IPv4 header option length
 *     UDF1_OFFSET3     Offset value for UDF1.3
 *     UDF1_ADD_IPV4_OPTIONS3 Control bit to enable adding the IPv4 header option length
 *     UDF2_OFFSET0     Offset value for UDF2.0
 *     UDF2_ADD_IPV4_OPTIONS0 Control bit to enable adding the IPv4 header option length
 *     UDF2_OFFSET1     Offset value for UDF2.1
 *     UDF2_ADD_IPV4_OPTIONS1 Control bit to enable adding the IPv4 header option length
 *     UDF2_OFFSET2     Offset value for UDF2.2
 *     UDF2_ADD_IPV4_OPTIONS2 Control bit to enable adding the IPv4 header option length
 *     UDF2_OFFSET3     Offset value for UDF2.3
 *     UDF2_ADD_IPV4_OPTIONS3 Control bit to enable adding the IPv4 header option length
 *
 ******************************************************************************/
#define BCM56504_A0_FP_UDF_OFFSETm 0x02720000

#define BCM56504_A0_FP_UDF_OFFSETm_MIN 0
#define BCM56504_A0_FP_UDF_OFFSETm_MAX 95
#define BCM56504_A0_FP_UDF_OFFSETm_CMAX(u) 95
#define BCM56504_A0_FP_UDF_OFFSETm_SIZE 6

/*
 * This structure should be used to declare and program FP_UDF_OFFSET.
 *
 */
typedef union BCM56504_A0_FP_UDF_OFFSETm_s {
	uint32_t v[2];
	uint32_t fp_udf_offset[2];
	uint32_t _fp_udf_offset;
} BCM56504_A0_FP_UDF_OFFSETm_t;

#define BCM56504_A0_FP_UDF_OFFSETm_CLR(r) CDK_MEMSET(&((r)._fp_udf_offset), 0, sizeof(BCM56504_A0_FP_UDF_OFFSETm_t))
#define BCM56504_A0_FP_UDF_OFFSETm_SET(r,i,d) (r).fp_udf_offset[i] = d
#define BCM56504_A0_FP_UDF_OFFSETm_GET(r,i) (r).fp_udf_offset[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_FP_UDF_OFFSETm_UDF1_OFFSET0f_GET(r) (((r).fp_udf_offset[0]) & 0x1f)
#define BCM56504_A0_FP_UDF_OFFSETm_UDF1_OFFSET0f_SET(r,f) (r).fp_udf_offset[0]=(((r).fp_udf_offset[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56504_A0_FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS0f_GET(r) ((((r).fp_udf_offset[0]) >> 5) & 0x1)
#define BCM56504_A0_FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS0f_SET(r,f) (r).fp_udf_offset[0]=(((r).fp_udf_offset[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56504_A0_FP_UDF_OFFSETm_UDF1_OFFSET1f_GET(r) ((((r).fp_udf_offset[0]) >> 6) & 0x1f)
#define BCM56504_A0_FP_UDF_OFFSETm_UDF1_OFFSET1f_SET(r,f) (r).fp_udf_offset[0]=(((r).fp_udf_offset[0] & ~((uint32_t)0x1f << 6)) | ((((uint32_t)f) & 0x1f) << 6))
#define BCM56504_A0_FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS1f_GET(r) ((((r).fp_udf_offset[0]) >> 11) & 0x1)
#define BCM56504_A0_FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS1f_SET(r,f) (r).fp_udf_offset[0]=(((r).fp_udf_offset[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56504_A0_FP_UDF_OFFSETm_UDF1_OFFSET2f_GET(r) ((((r).fp_udf_offset[0]) >> 12) & 0x1f)
#define BCM56504_A0_FP_UDF_OFFSETm_UDF1_OFFSET2f_SET(r,f) (r).fp_udf_offset[0]=(((r).fp_udf_offset[0] & ~((uint32_t)0x1f << 12)) | ((((uint32_t)f) & 0x1f) << 12))
#define BCM56504_A0_FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS2f_GET(r) ((((r).fp_udf_offset[0]) >> 17) & 0x1)
#define BCM56504_A0_FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS2f_SET(r,f) (r).fp_udf_offset[0]=(((r).fp_udf_offset[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56504_A0_FP_UDF_OFFSETm_UDF1_OFFSET3f_GET(r) ((((r).fp_udf_offset[0]) >> 18) & 0x1f)
#define BCM56504_A0_FP_UDF_OFFSETm_UDF1_OFFSET3f_SET(r,f) (r).fp_udf_offset[0]=(((r).fp_udf_offset[0] & ~((uint32_t)0x1f << 18)) | ((((uint32_t)f) & 0x1f) << 18))
#define BCM56504_A0_FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS3f_GET(r) ((((r).fp_udf_offset[0]) >> 23) & 0x1)
#define BCM56504_A0_FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS3f_SET(r,f) (r).fp_udf_offset[0]=(((r).fp_udf_offset[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM56504_A0_FP_UDF_OFFSETm_UDF2_OFFSET0f_GET(r) ((((r).fp_udf_offset[0]) >> 24) & 0x1f)
#define BCM56504_A0_FP_UDF_OFFSETm_UDF2_OFFSET0f_SET(r,f) (r).fp_udf_offset[0]=(((r).fp_udf_offset[0] & ~((uint32_t)0x1f << 24)) | ((((uint32_t)f) & 0x1f) << 24))
#define BCM56504_A0_FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS0f_GET(r) ((((r).fp_udf_offset[0]) >> 29) & 0x1)
#define BCM56504_A0_FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS0f_SET(r,f) (r).fp_udf_offset[0]=(((r).fp_udf_offset[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM56504_A0_FP_UDF_OFFSETm_UDF2_OFFSET1f_GET(r) cdk_field32_get((r).fp_udf_offset,30,34)
#define BCM56504_A0_FP_UDF_OFFSETm_UDF2_OFFSET1f_SET(r,f) cdk_field32_set((r).fp_udf_offset,30,34,f)
#define BCM56504_A0_FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS1f_GET(r) ((((r).fp_udf_offset[1]) >> 3) & 0x1)
#define BCM56504_A0_FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS1f_SET(r,f) (r).fp_udf_offset[1]=(((r).fp_udf_offset[1] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_FP_UDF_OFFSETm_UDF2_OFFSET2f_GET(r) ((((r).fp_udf_offset[1]) >> 4) & 0x1f)
#define BCM56504_A0_FP_UDF_OFFSETm_UDF2_OFFSET2f_SET(r,f) (r).fp_udf_offset[1]=(((r).fp_udf_offset[1] & ~((uint32_t)0x1f << 4)) | ((((uint32_t)f) & 0x1f) << 4))
#define BCM56504_A0_FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS2f_GET(r) ((((r).fp_udf_offset[1]) >> 9) & 0x1)
#define BCM56504_A0_FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS2f_SET(r,f) (r).fp_udf_offset[1]=(((r).fp_udf_offset[1] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56504_A0_FP_UDF_OFFSETm_UDF2_OFFSET3f_GET(r) ((((r).fp_udf_offset[1]) >> 10) & 0x1f)
#define BCM56504_A0_FP_UDF_OFFSETm_UDF2_OFFSET3f_SET(r,f) (r).fp_udf_offset[1]=(((r).fp_udf_offset[1] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10))
#define BCM56504_A0_FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS3f_GET(r) ((((r).fp_udf_offset[1]) >> 15) & 0x1)
#define BCM56504_A0_FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS3f_SET(r,f) (r).fp_udf_offset[1]=(((r).fp_udf_offset[1] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access FP_UDF_OFFSET.
 *
 */
#define BCM56504_A0_READ_FP_UDF_OFFSETm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_FP_UDF_OFFSETm,i,(m._fp_udf_offset),2)
#define BCM56504_A0_WRITE_FP_UDF_OFFSETm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_FP_UDF_OFFSETm,i,&(m._fp_udf_offset),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_UDF_OFFSETm BCM56504_A0_FP_UDF_OFFSETm
#define FP_UDF_OFFSETm_MIN BCM56504_A0_FP_UDF_OFFSETm_MIN
#define FP_UDF_OFFSETm_MAX BCM56504_A0_FP_UDF_OFFSETm_MAX
#define FP_UDF_OFFSETm_CMAX(u) BCM56504_A0_FP_UDF_OFFSETm_CMAX(u)
#define FP_UDF_OFFSETm_SIZE BCM56504_A0_FP_UDF_OFFSETm_SIZE
typedef BCM56504_A0_FP_UDF_OFFSETm_t FP_UDF_OFFSETm_t;
#define FP_UDF_OFFSETm_CLR BCM56504_A0_FP_UDF_OFFSETm_CLR
#define FP_UDF_OFFSETm_SET BCM56504_A0_FP_UDF_OFFSETm_SET
#define FP_UDF_OFFSETm_GET BCM56504_A0_FP_UDF_OFFSETm_GET
#define FP_UDF_OFFSETm_UDF1_OFFSET0f_GET BCM56504_A0_FP_UDF_OFFSETm_UDF1_OFFSET0f_GET
#define FP_UDF_OFFSETm_UDF1_OFFSET0f_SET BCM56504_A0_FP_UDF_OFFSETm_UDF1_OFFSET0f_SET
#define FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS0f_GET BCM56504_A0_FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS0f_GET
#define FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS0f_SET BCM56504_A0_FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS0f_SET
#define FP_UDF_OFFSETm_UDF1_OFFSET1f_GET BCM56504_A0_FP_UDF_OFFSETm_UDF1_OFFSET1f_GET
#define FP_UDF_OFFSETm_UDF1_OFFSET1f_SET BCM56504_A0_FP_UDF_OFFSETm_UDF1_OFFSET1f_SET
#define FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS1f_GET BCM56504_A0_FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS1f_GET
#define FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS1f_SET BCM56504_A0_FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS1f_SET
#define FP_UDF_OFFSETm_UDF1_OFFSET2f_GET BCM56504_A0_FP_UDF_OFFSETm_UDF1_OFFSET2f_GET
#define FP_UDF_OFFSETm_UDF1_OFFSET2f_SET BCM56504_A0_FP_UDF_OFFSETm_UDF1_OFFSET2f_SET
#define FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS2f_GET BCM56504_A0_FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS2f_GET
#define FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS2f_SET BCM56504_A0_FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS2f_SET
#define FP_UDF_OFFSETm_UDF1_OFFSET3f_GET BCM56504_A0_FP_UDF_OFFSETm_UDF1_OFFSET3f_GET
#define FP_UDF_OFFSETm_UDF1_OFFSET3f_SET BCM56504_A0_FP_UDF_OFFSETm_UDF1_OFFSET3f_SET
#define FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS3f_GET BCM56504_A0_FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS3f_GET
#define FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS3f_SET BCM56504_A0_FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS3f_SET
#define FP_UDF_OFFSETm_UDF2_OFFSET0f_GET BCM56504_A0_FP_UDF_OFFSETm_UDF2_OFFSET0f_GET
#define FP_UDF_OFFSETm_UDF2_OFFSET0f_SET BCM56504_A0_FP_UDF_OFFSETm_UDF2_OFFSET0f_SET
#define FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS0f_GET BCM56504_A0_FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS0f_GET
#define FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS0f_SET BCM56504_A0_FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS0f_SET
#define FP_UDF_OFFSETm_UDF2_OFFSET1f_GET BCM56504_A0_FP_UDF_OFFSETm_UDF2_OFFSET1f_GET
#define FP_UDF_OFFSETm_UDF2_OFFSET1f_SET BCM56504_A0_FP_UDF_OFFSETm_UDF2_OFFSET1f_SET
#define FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS1f_GET BCM56504_A0_FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS1f_GET
#define FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS1f_SET BCM56504_A0_FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS1f_SET
#define FP_UDF_OFFSETm_UDF2_OFFSET2f_GET BCM56504_A0_FP_UDF_OFFSETm_UDF2_OFFSET2f_GET
#define FP_UDF_OFFSETm_UDF2_OFFSET2f_SET BCM56504_A0_FP_UDF_OFFSETm_UDF2_OFFSET2f_SET
#define FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS2f_GET BCM56504_A0_FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS2f_GET
#define FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS2f_SET BCM56504_A0_FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS2f_SET
#define FP_UDF_OFFSETm_UDF2_OFFSET3f_GET BCM56504_A0_FP_UDF_OFFSETm_UDF2_OFFSET3f_GET
#define FP_UDF_OFFSETm_UDF2_OFFSET3f_SET BCM56504_A0_FP_UDF_OFFSETm_UDF2_OFFSET3f_SET
#define FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS3f_GET BCM56504_A0_FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS3f_GET
#define FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS3f_SET BCM56504_A0_FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS3f_SET
#define READ_FP_UDF_OFFSETm BCM56504_A0_READ_FP_UDF_OFFSETm
#define WRITE_FP_UDF_OFFSETm BCM56504_A0_WRITE_FP_UDF_OFFSETm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_FP_UDF_OFFSETm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GE0_GBODE_CELL_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell count register for GE0 
 * SIZE:     32
 * FIELDS:
 *     CELL_CNT         Number of cell counts in GBODE tx fifo.
 *
 ******************************************************************************/
#define BCM56504_A0_GE0_GBODE_CELL_CNTr 0x00f80010

#define BCM56504_A0_GE0_GBODE_CELL_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE0_GBODE_CELL_CNT.
 *
 */
typedef union BCM56504_A0_GE0_GBODE_CELL_CNTr_s {
	uint32_t v[1];
	uint32_t ge0_gbode_cell_cnt[1];
	uint32_t _ge0_gbode_cell_cnt;
} BCM56504_A0_GE0_GBODE_CELL_CNTr_t;

#define BCM56504_A0_GE0_GBODE_CELL_CNTr_CLR(r) (r).ge0_gbode_cell_cnt[0] = 0
#define BCM56504_A0_GE0_GBODE_CELL_CNTr_SET(r,d) (r).ge0_gbode_cell_cnt[0] = d
#define BCM56504_A0_GE0_GBODE_CELL_CNTr_GET(r) (r).ge0_gbode_cell_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_GE0_GBODE_CELL_CNTr_CELL_CNTf_GET(r) (((r).ge0_gbode_cell_cnt[0]) & 0x7)
#define BCM56504_A0_GE0_GBODE_CELL_CNTr_CELL_CNTf_SET(r,f) (r).ge0_gbode_cell_cnt[0]=(((r).ge0_gbode_cell_cnt[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))

/*
 * These macros can be used to access GE0_GBODE_CELL_CNT.
 *
 */
#define BCM56504_A0_READ_GE0_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE0_GBODE_CELL_CNTr,(r._ge0_gbode_cell_cnt))
#define BCM56504_A0_WRITE_GE0_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE0_GBODE_CELL_CNTr,&(r._ge0_gbode_cell_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE0_GBODE_CELL_CNTr BCM56504_A0_GE0_GBODE_CELL_CNTr
#define GE0_GBODE_CELL_CNTr_SIZE BCM56504_A0_GE0_GBODE_CELL_CNTr_SIZE
typedef BCM56504_A0_GE0_GBODE_CELL_CNTr_t GE0_GBODE_CELL_CNTr_t;
#define GE0_GBODE_CELL_CNTr_CLR BCM56504_A0_GE0_GBODE_CELL_CNTr_CLR
#define GE0_GBODE_CELL_CNTr_SET BCM56504_A0_GE0_GBODE_CELL_CNTr_SET
#define GE0_GBODE_CELL_CNTr_GET BCM56504_A0_GE0_GBODE_CELL_CNTr_GET
#define GE0_GBODE_CELL_CNTr_CELL_CNTf_GET BCM56504_A0_GE0_GBODE_CELL_CNTr_CELL_CNTf_GET
#define GE0_GBODE_CELL_CNTr_CELL_CNTf_SET BCM56504_A0_GE0_GBODE_CELL_CNTr_CELL_CNTf_SET
#define READ_GE0_GBODE_CELL_CNTr BCM56504_A0_READ_GE0_GBODE_CELL_CNTr
#define WRITE_GE0_GBODE_CELL_CNTr BCM56504_A0_WRITE_GE0_GBODE_CELL_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GE0_GBODE_CELL_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GE0_GBODE_CELL_REQ_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell request count register for GE0 
 * SIZE:     32
 * FIELDS:
 *     REQ_CNT          Number of cell request made to Egress Pipeline, MAX is 4.
 *
 ******************************************************************************/
#define BCM56504_A0_GE0_GBODE_CELL_REQ_CNTr 0x00f8001c

#define BCM56504_A0_GE0_GBODE_CELL_REQ_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE0_GBODE_CELL_REQ_CNT.
 *
 */
typedef union BCM56504_A0_GE0_GBODE_CELL_REQ_CNTr_s {
	uint32_t v[1];
	uint32_t ge0_gbode_cell_req_cnt[1];
	uint32_t _ge0_gbode_cell_req_cnt;
} BCM56504_A0_GE0_GBODE_CELL_REQ_CNTr_t;

#define BCM56504_A0_GE0_GBODE_CELL_REQ_CNTr_CLR(r) (r).ge0_gbode_cell_req_cnt[0] = 0
#define BCM56504_A0_GE0_GBODE_CELL_REQ_CNTr_SET(r,d) (r).ge0_gbode_cell_req_cnt[0] = d
#define BCM56504_A0_GE0_GBODE_CELL_REQ_CNTr_GET(r) (r).ge0_gbode_cell_req_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_GE0_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET(r) (((r).ge0_gbode_cell_req_cnt[0]) & 0x7)
#define BCM56504_A0_GE0_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET(r,f) (r).ge0_gbode_cell_req_cnt[0]=(((r).ge0_gbode_cell_req_cnt[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))

/*
 * These macros can be used to access GE0_GBODE_CELL_REQ_CNT.
 *
 */
#define BCM56504_A0_READ_GE0_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE0_GBODE_CELL_REQ_CNTr,(r._ge0_gbode_cell_req_cnt))
#define BCM56504_A0_WRITE_GE0_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE0_GBODE_CELL_REQ_CNTr,&(r._ge0_gbode_cell_req_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE0_GBODE_CELL_REQ_CNTr BCM56504_A0_GE0_GBODE_CELL_REQ_CNTr
#define GE0_GBODE_CELL_REQ_CNTr_SIZE BCM56504_A0_GE0_GBODE_CELL_REQ_CNTr_SIZE
typedef BCM56504_A0_GE0_GBODE_CELL_REQ_CNTr_t GE0_GBODE_CELL_REQ_CNTr_t;
#define GE0_GBODE_CELL_REQ_CNTr_CLR BCM56504_A0_GE0_GBODE_CELL_REQ_CNTr_CLR
#define GE0_GBODE_CELL_REQ_CNTr_SET BCM56504_A0_GE0_GBODE_CELL_REQ_CNTr_SET
#define GE0_GBODE_CELL_REQ_CNTr_GET BCM56504_A0_GE0_GBODE_CELL_REQ_CNTr_GET
#define GE0_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET BCM56504_A0_GE0_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET
#define GE0_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET BCM56504_A0_GE0_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET
#define READ_GE0_GBODE_CELL_REQ_CNTr BCM56504_A0_READ_GE0_GBODE_CELL_REQ_CNTr
#define WRITE_GE0_GBODE_CELL_REQ_CNTr BCM56504_A0_WRITE_GE0_GBODE_CELL_REQ_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GE0_GBODE_CELL_REQ_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GE0_GBOD_OVRFLW
 * BLOCKS:   GPORT0
 * DESC:     GBOD RX fifo overflow for GE0 
 * SIZE:     32
 * FIELDS:
 *     OVRFLW           GBOD RX fifo overflow flag.
 *
 ******************************************************************************/
#define BCM56504_A0_GE0_GBOD_OVRFLWr 0x00f80004

#define BCM56504_A0_GE0_GBOD_OVRFLWr_SIZE 4

/*
 * This structure should be used to declare and program GE0_GBOD_OVRFLW.
 *
 */
typedef union BCM56504_A0_GE0_GBOD_OVRFLWr_s {
	uint32_t v[1];
	uint32_t ge0_gbod_ovrflw[1];
	uint32_t _ge0_gbod_ovrflw;
} BCM56504_A0_GE0_GBOD_OVRFLWr_t;

#define BCM56504_A0_GE0_GBOD_OVRFLWr_CLR(r) (r).ge0_gbod_ovrflw[0] = 0
#define BCM56504_A0_GE0_GBOD_OVRFLWr_SET(r,d) (r).ge0_gbod_ovrflw[0] = d
#define BCM56504_A0_GE0_GBOD_OVRFLWr_GET(r) (r).ge0_gbod_ovrflw[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_GE0_GBOD_OVRFLWr_OVRFLWf_GET(r) (((r).ge0_gbod_ovrflw[0]) & 0x1)
#define BCM56504_A0_GE0_GBOD_OVRFLWr_OVRFLWf_SET(r,f) (r).ge0_gbod_ovrflw[0]=(((r).ge0_gbod_ovrflw[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access GE0_GBOD_OVRFLW.
 *
 */
#define BCM56504_A0_READ_GE0_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE0_GBOD_OVRFLWr,(r._ge0_gbod_ovrflw))
#define BCM56504_A0_WRITE_GE0_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE0_GBOD_OVRFLWr,&(r._ge0_gbod_ovrflw))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE0_GBOD_OVRFLWr BCM56504_A0_GE0_GBOD_OVRFLWr
#define GE0_GBOD_OVRFLWr_SIZE BCM56504_A0_GE0_GBOD_OVRFLWr_SIZE
typedef BCM56504_A0_GE0_GBOD_OVRFLWr_t GE0_GBOD_OVRFLWr_t;
#define GE0_GBOD_OVRFLWr_CLR BCM56504_A0_GE0_GBOD_OVRFLWr_CLR
#define GE0_GBOD_OVRFLWr_SET BCM56504_A0_GE0_GBOD_OVRFLWr_SET
#define GE0_GBOD_OVRFLWr_GET BCM56504_A0_GE0_GBOD_OVRFLWr_GET
#define GE0_GBOD_OVRFLWr_OVRFLWf_GET BCM56504_A0_GE0_GBOD_OVRFLWr_OVRFLWf_GET
#define GE0_GBOD_OVRFLWr_OVRFLWf_SET BCM56504_A0_GE0_GBOD_OVRFLWr_OVRFLWf_SET
#define READ_GE0_GBOD_OVRFLWr BCM56504_A0_READ_GE0_GBOD_OVRFLWr
#define WRITE_GE0_GBOD_OVRFLWr BCM56504_A0_WRITE_GE0_GBOD_OVRFLWr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GE0_GBOD_OVRFLWr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GE10_GBODE_CELL_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell count register for GE10 
 * SIZE:     32
 * FIELDS:
 *     CELL_CNT         Number of cell counts in GBODE tx fifo.
 *
 ******************************************************************************/
#define BCM56504_A0_GE10_GBODE_CELL_CNTr 0x00f8001a

#define BCM56504_A0_GE10_GBODE_CELL_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE10_GBODE_CELL_CNT.
 *
 */
typedef union BCM56504_A0_GE10_GBODE_CELL_CNTr_s {
	uint32_t v[1];
	uint32_t ge10_gbode_cell_cnt[1];
	uint32_t _ge10_gbode_cell_cnt;
} BCM56504_A0_GE10_GBODE_CELL_CNTr_t;

#define BCM56504_A0_GE10_GBODE_CELL_CNTr_CLR(r) (r).ge10_gbode_cell_cnt[0] = 0
#define BCM56504_A0_GE10_GBODE_CELL_CNTr_SET(r,d) (r).ge10_gbode_cell_cnt[0] = d
#define BCM56504_A0_GE10_GBODE_CELL_CNTr_GET(r) (r).ge10_gbode_cell_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_GE10_GBODE_CELL_CNTr_CELL_CNTf_GET(r) (((r).ge10_gbode_cell_cnt[0]) & 0x7)
#define BCM56504_A0_GE10_GBODE_CELL_CNTr_CELL_CNTf_SET(r,f) (r).ge10_gbode_cell_cnt[0]=(((r).ge10_gbode_cell_cnt[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))

/*
 * These macros can be used to access GE10_GBODE_CELL_CNT.
 *
 */
#define BCM56504_A0_READ_GE10_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE10_GBODE_CELL_CNTr,(r._ge10_gbode_cell_cnt))
#define BCM56504_A0_WRITE_GE10_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE10_GBODE_CELL_CNTr,&(r._ge10_gbode_cell_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE10_GBODE_CELL_CNTr BCM56504_A0_GE10_GBODE_CELL_CNTr
#define GE10_GBODE_CELL_CNTr_SIZE BCM56504_A0_GE10_GBODE_CELL_CNTr_SIZE
typedef BCM56504_A0_GE10_GBODE_CELL_CNTr_t GE10_GBODE_CELL_CNTr_t;
#define GE10_GBODE_CELL_CNTr_CLR BCM56504_A0_GE10_GBODE_CELL_CNTr_CLR
#define GE10_GBODE_CELL_CNTr_SET BCM56504_A0_GE10_GBODE_CELL_CNTr_SET
#define GE10_GBODE_CELL_CNTr_GET BCM56504_A0_GE10_GBODE_CELL_CNTr_GET
#define GE10_GBODE_CELL_CNTr_CELL_CNTf_GET BCM56504_A0_GE10_GBODE_CELL_CNTr_CELL_CNTf_GET
#define GE10_GBODE_CELL_CNTr_CELL_CNTf_SET BCM56504_A0_GE10_GBODE_CELL_CNTr_CELL_CNTf_SET
#define READ_GE10_GBODE_CELL_CNTr BCM56504_A0_READ_GE10_GBODE_CELL_CNTr
#define WRITE_GE10_GBODE_CELL_CNTr BCM56504_A0_WRITE_GE10_GBODE_CELL_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GE10_GBODE_CELL_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GE10_GBODE_CELL_REQ_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell request count register for GE10 
 * SIZE:     32
 * FIELDS:
 *     REQ_CNT          Number of cell request made to Egress Pipeline, MAX is 4.
 *
 ******************************************************************************/
#define BCM56504_A0_GE10_GBODE_CELL_REQ_CNTr 0x00f80026

#define BCM56504_A0_GE10_GBODE_CELL_REQ_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE10_GBODE_CELL_REQ_CNT.
 *
 */
typedef union BCM56504_A0_GE10_GBODE_CELL_REQ_CNTr_s {
	uint32_t v[1];
	uint32_t ge10_gbode_cell_req_cnt[1];
	uint32_t _ge10_gbode_cell_req_cnt;
} BCM56504_A0_GE10_GBODE_CELL_REQ_CNTr_t;

#define BCM56504_A0_GE10_GBODE_CELL_REQ_CNTr_CLR(r) (r).ge10_gbode_cell_req_cnt[0] = 0
#define BCM56504_A0_GE10_GBODE_CELL_REQ_CNTr_SET(r,d) (r).ge10_gbode_cell_req_cnt[0] = d
#define BCM56504_A0_GE10_GBODE_CELL_REQ_CNTr_GET(r) (r).ge10_gbode_cell_req_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_GE10_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET(r) (((r).ge10_gbode_cell_req_cnt[0]) & 0x7)
#define BCM56504_A0_GE10_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET(r,f) (r).ge10_gbode_cell_req_cnt[0]=(((r).ge10_gbode_cell_req_cnt[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))

/*
 * These macros can be used to access GE10_GBODE_CELL_REQ_CNT.
 *
 */
#define BCM56504_A0_READ_GE10_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE10_GBODE_CELL_REQ_CNTr,(r._ge10_gbode_cell_req_cnt))
#define BCM56504_A0_WRITE_GE10_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE10_GBODE_CELL_REQ_CNTr,&(r._ge10_gbode_cell_req_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE10_GBODE_CELL_REQ_CNTr BCM56504_A0_GE10_GBODE_CELL_REQ_CNTr
#define GE10_GBODE_CELL_REQ_CNTr_SIZE BCM56504_A0_GE10_GBODE_CELL_REQ_CNTr_SIZE
typedef BCM56504_A0_GE10_GBODE_CELL_REQ_CNTr_t GE10_GBODE_CELL_REQ_CNTr_t;
#define GE10_GBODE_CELL_REQ_CNTr_CLR BCM56504_A0_GE10_GBODE_CELL_REQ_CNTr_CLR
#define GE10_GBODE_CELL_REQ_CNTr_SET BCM56504_A0_GE10_GBODE_CELL_REQ_CNTr_SET
#define GE10_GBODE_CELL_REQ_CNTr_GET BCM56504_A0_GE10_GBODE_CELL_REQ_CNTr_GET
#define GE10_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET BCM56504_A0_GE10_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET
#define GE10_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET BCM56504_A0_GE10_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET
#define READ_GE10_GBODE_CELL_REQ_CNTr BCM56504_A0_READ_GE10_GBODE_CELL_REQ_CNTr
#define WRITE_GE10_GBODE_CELL_REQ_CNTr BCM56504_A0_WRITE_GE10_GBODE_CELL_REQ_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GE10_GBODE_CELL_REQ_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GE10_GBOD_OVRFLW
 * BLOCKS:   GPORT0
 * DESC:     GBOD RX fifo overflow for GE10 
 * SIZE:     32
 * FIELDS:
 *     OVRFLW           GBOD RX fifo overflow flag.
 *
 ******************************************************************************/
#define BCM56504_A0_GE10_GBOD_OVRFLWr 0x00f8000e

#define BCM56504_A0_GE10_GBOD_OVRFLWr_SIZE 4

/*
 * This structure should be used to declare and program GE10_GBOD_OVRFLW.
 *
 */
typedef union BCM56504_A0_GE10_GBOD_OVRFLWr_s {
	uint32_t v[1];
	uint32_t ge10_gbod_ovrflw[1];
	uint32_t _ge10_gbod_ovrflw;
} BCM56504_A0_GE10_GBOD_OVRFLWr_t;

#define BCM56504_A0_GE10_GBOD_OVRFLWr_CLR(r) (r).ge10_gbod_ovrflw[0] = 0
#define BCM56504_A0_GE10_GBOD_OVRFLWr_SET(r,d) (r).ge10_gbod_ovrflw[0] = d
#define BCM56504_A0_GE10_GBOD_OVRFLWr_GET(r) (r).ge10_gbod_ovrflw[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_GE10_GBOD_OVRFLWr_OVRFLWf_GET(r) (((r).ge10_gbod_ovrflw[0]) & 0x1)
#define BCM56504_A0_GE10_GBOD_OVRFLWr_OVRFLWf_SET(r,f) (r).ge10_gbod_ovrflw[0]=(((r).ge10_gbod_ovrflw[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access GE10_GBOD_OVRFLW.
 *
 */
#define BCM56504_A0_READ_GE10_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE10_GBOD_OVRFLWr,(r._ge10_gbod_ovrflw))
#define BCM56504_A0_WRITE_GE10_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE10_GBOD_OVRFLWr,&(r._ge10_gbod_ovrflw))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE10_GBOD_OVRFLWr BCM56504_A0_GE10_GBOD_OVRFLWr
#define GE10_GBOD_OVRFLWr_SIZE BCM56504_A0_GE10_GBOD_OVRFLWr_SIZE
typedef BCM56504_A0_GE10_GBOD_OVRFLWr_t GE10_GBOD_OVRFLWr_t;
#define GE10_GBOD_OVRFLWr_CLR BCM56504_A0_GE10_GBOD_OVRFLWr_CLR
#define GE10_GBOD_OVRFLWr_SET BCM56504_A0_GE10_GBOD_OVRFLWr_SET
#define GE10_GBOD_OVRFLWr_GET BCM56504_A0_GE10_GBOD_OVRFLWr_GET
#define GE10_GBOD_OVRFLWr_OVRFLWf_GET BCM56504_A0_GE10_GBOD_OVRFLWr_OVRFLWf_GET
#define GE10_GBOD_OVRFLWr_OVRFLWf_SET BCM56504_A0_GE10_GBOD_OVRFLWr_OVRFLWf_SET
#define READ_GE10_GBOD_OVRFLWr BCM56504_A0_READ_GE10_GBOD_OVRFLWr
#define WRITE_GE10_GBOD_OVRFLWr BCM56504_A0_WRITE_GE10_GBOD_OVRFLWr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GE10_GBOD_OVRFLWr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GE11_GBODE_CELL_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell count register for GE11 
 * SIZE:     32
 * FIELDS:
 *     CELL_CNT         Number of cell counts in GBODE tx fifo.
 *
 ******************************************************************************/
#define BCM56504_A0_GE11_GBODE_CELL_CNTr 0x00f8001b

#define BCM56504_A0_GE11_GBODE_CELL_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE11_GBODE_CELL_CNT.
 *
 */
typedef union BCM56504_A0_GE11_GBODE_CELL_CNTr_s {
	uint32_t v[1];
	uint32_t ge11_gbode_cell_cnt[1];
	uint32_t _ge11_gbode_cell_cnt;
} BCM56504_A0_GE11_GBODE_CELL_CNTr_t;

#define BCM56504_A0_GE11_GBODE_CELL_CNTr_CLR(r) (r).ge11_gbode_cell_cnt[0] = 0
#define BCM56504_A0_GE11_GBODE_CELL_CNTr_SET(r,d) (r).ge11_gbode_cell_cnt[0] = d
#define BCM56504_A0_GE11_GBODE_CELL_CNTr_GET(r) (r).ge11_gbode_cell_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_GE11_GBODE_CELL_CNTr_CELL_CNTf_GET(r) (((r).ge11_gbode_cell_cnt[0]) & 0x7)
#define BCM56504_A0_GE11_GBODE_CELL_CNTr_CELL_CNTf_SET(r,f) (r).ge11_gbode_cell_cnt[0]=(((r).ge11_gbode_cell_cnt[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))

/*
 * These macros can be used to access GE11_GBODE_CELL_CNT.
 *
 */
#define BCM56504_A0_READ_GE11_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE11_GBODE_CELL_CNTr,(r._ge11_gbode_cell_cnt))
#define BCM56504_A0_WRITE_GE11_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE11_GBODE_CELL_CNTr,&(r._ge11_gbode_cell_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE11_GBODE_CELL_CNTr BCM56504_A0_GE11_GBODE_CELL_CNTr
#define GE11_GBODE_CELL_CNTr_SIZE BCM56504_A0_GE11_GBODE_CELL_CNTr_SIZE
typedef BCM56504_A0_GE11_GBODE_CELL_CNTr_t GE11_GBODE_CELL_CNTr_t;
#define GE11_GBODE_CELL_CNTr_CLR BCM56504_A0_GE11_GBODE_CELL_CNTr_CLR
#define GE11_GBODE_CELL_CNTr_SET BCM56504_A0_GE11_GBODE_CELL_CNTr_SET
#define GE11_GBODE_CELL_CNTr_GET BCM56504_A0_GE11_GBODE_CELL_CNTr_GET
#define GE11_GBODE_CELL_CNTr_CELL_CNTf_GET BCM56504_A0_GE11_GBODE_CELL_CNTr_CELL_CNTf_GET
#define GE11_GBODE_CELL_CNTr_CELL_CNTf_SET BCM56504_A0_GE11_GBODE_CELL_CNTr_CELL_CNTf_SET
#define READ_GE11_GBODE_CELL_CNTr BCM56504_A0_READ_GE11_GBODE_CELL_CNTr
#define WRITE_GE11_GBODE_CELL_CNTr BCM56504_A0_WRITE_GE11_GBODE_CELL_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GE11_GBODE_CELL_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GE11_GBODE_CELL_REQ_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell request count register for GE11 
 * SIZE:     32
 * FIELDS:
 *     REQ_CNT          Number of cell request made to Egress Pipeline, MAX is 4.
 *
 ******************************************************************************/
#define BCM56504_A0_GE11_GBODE_CELL_REQ_CNTr 0x00f80027

#define BCM56504_A0_GE11_GBODE_CELL_REQ_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE11_GBODE_CELL_REQ_CNT.
 *
 */
typedef union BCM56504_A0_GE11_GBODE_CELL_REQ_CNTr_s {
	uint32_t v[1];
	uint32_t ge11_gbode_cell_req_cnt[1];
	uint32_t _ge11_gbode_cell_req_cnt;
} BCM56504_A0_GE11_GBODE_CELL_REQ_CNTr_t;

#define BCM56504_A0_GE11_GBODE_CELL_REQ_CNTr_CLR(r) (r).ge11_gbode_cell_req_cnt[0] = 0
#define BCM56504_A0_GE11_GBODE_CELL_REQ_CNTr_SET(r,d) (r).ge11_gbode_cell_req_cnt[0] = d
#define BCM56504_A0_GE11_GBODE_CELL_REQ_CNTr_GET(r) (r).ge11_gbode_cell_req_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_GE11_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET(r) (((r).ge11_gbode_cell_req_cnt[0]) & 0x7)
#define BCM56504_A0_GE11_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET(r,f) (r).ge11_gbode_cell_req_cnt[0]=(((r).ge11_gbode_cell_req_cnt[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))

/*
 * These macros can be used to access GE11_GBODE_CELL_REQ_CNT.
 *
 */
#define BCM56504_A0_READ_GE11_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE11_GBODE_CELL_REQ_CNTr,(r._ge11_gbode_cell_req_cnt))
#define BCM56504_A0_WRITE_GE11_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE11_GBODE_CELL_REQ_CNTr,&(r._ge11_gbode_cell_req_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE11_GBODE_CELL_REQ_CNTr BCM56504_A0_GE11_GBODE_CELL_REQ_CNTr
#define GE11_GBODE_CELL_REQ_CNTr_SIZE BCM56504_A0_GE11_GBODE_CELL_REQ_CNTr_SIZE
typedef BCM56504_A0_GE11_GBODE_CELL_REQ_CNTr_t GE11_GBODE_CELL_REQ_CNTr_t;
#define GE11_GBODE_CELL_REQ_CNTr_CLR BCM56504_A0_GE11_GBODE_CELL_REQ_CNTr_CLR
#define GE11_GBODE_CELL_REQ_CNTr_SET BCM56504_A0_GE11_GBODE_CELL_REQ_CNTr_SET
#define GE11_GBODE_CELL_REQ_CNTr_GET BCM56504_A0_GE11_GBODE_CELL_REQ_CNTr_GET
#define GE11_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET BCM56504_A0_GE11_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET
#define GE11_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET BCM56504_A0_GE11_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET
#define READ_GE11_GBODE_CELL_REQ_CNTr BCM56504_A0_READ_GE11_GBODE_CELL_REQ_CNTr
#define WRITE_GE11_GBODE_CELL_REQ_CNTr BCM56504_A0_WRITE_GE11_GBODE_CELL_REQ_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GE11_GBODE_CELL_REQ_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GE11_GBOD_OVRFLW
 * BLOCKS:   GPORT0
 * DESC:     GBOD RX fifo overflow for GE11 
 * SIZE:     32
 * FIELDS:
 *     OVRFLW           GBOD RX fifo overflow flag.
 *
 ******************************************************************************/
#define BCM56504_A0_GE11_GBOD_OVRFLWr 0x00f8000f

#define BCM56504_A0_GE11_GBOD_OVRFLWr_SIZE 4

/*
 * This structure should be used to declare and program GE11_GBOD_OVRFLW.
 *
 */
typedef union BCM56504_A0_GE11_GBOD_OVRFLWr_s {
	uint32_t v[1];
	uint32_t ge11_gbod_ovrflw[1];
	uint32_t _ge11_gbod_ovrflw;
} BCM56504_A0_GE11_GBOD_OVRFLWr_t;

#define BCM56504_A0_GE11_GBOD_OVRFLWr_CLR(r) (r).ge11_gbod_ovrflw[0] = 0
#define BCM56504_A0_GE11_GBOD_OVRFLWr_SET(r,d) (r).ge11_gbod_ovrflw[0] = d
#define BCM56504_A0_GE11_GBOD_OVRFLWr_GET(r) (r).ge11_gbod_ovrflw[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_GE11_GBOD_OVRFLWr_OVRFLWf_GET(r) (((r).ge11_gbod_ovrflw[0]) & 0x1)
#define BCM56504_A0_GE11_GBOD_OVRFLWr_OVRFLWf_SET(r,f) (r).ge11_gbod_ovrflw[0]=(((r).ge11_gbod_ovrflw[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access GE11_GBOD_OVRFLW.
 *
 */
#define BCM56504_A0_READ_GE11_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE11_GBOD_OVRFLWr,(r._ge11_gbod_ovrflw))
#define BCM56504_A0_WRITE_GE11_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE11_GBOD_OVRFLWr,&(r._ge11_gbod_ovrflw))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE11_GBOD_OVRFLWr BCM56504_A0_GE11_GBOD_OVRFLWr
#define GE11_GBOD_OVRFLWr_SIZE BCM56504_A0_GE11_GBOD_OVRFLWr_SIZE
typedef BCM56504_A0_GE11_GBOD_OVRFLWr_t GE11_GBOD_OVRFLWr_t;
#define GE11_GBOD_OVRFLWr_CLR BCM56504_A0_GE11_GBOD_OVRFLWr_CLR
#define GE11_GBOD_OVRFLWr_SET BCM56504_A0_GE11_GBOD_OVRFLWr_SET
#define GE11_GBOD_OVRFLWr_GET BCM56504_A0_GE11_GBOD_OVRFLWr_GET
#define GE11_GBOD_OVRFLWr_OVRFLWf_GET BCM56504_A0_GE11_GBOD_OVRFLWr_OVRFLWf_GET
#define GE11_GBOD_OVRFLWr_OVRFLWf_SET BCM56504_A0_GE11_GBOD_OVRFLWr_OVRFLWf_SET
#define READ_GE11_GBOD_OVRFLWr BCM56504_A0_READ_GE11_GBOD_OVRFLWr
#define WRITE_GE11_GBOD_OVRFLWr BCM56504_A0_WRITE_GE11_GBOD_OVRFLWr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GE11_GBOD_OVRFLWr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GE1_GBODE_CELL_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell count register for GE1 
 * SIZE:     32
 * FIELDS:
 *     CELL_CNT         Number of cell counts in GBODE tx fifo.
 *
 ******************************************************************************/
#define BCM56504_A0_GE1_GBODE_CELL_CNTr 0x00f80011

#define BCM56504_A0_GE1_GBODE_CELL_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE1_GBODE_CELL_CNT.
 *
 */
typedef union BCM56504_A0_GE1_GBODE_CELL_CNTr_s {
	uint32_t v[1];
	uint32_t ge1_gbode_cell_cnt[1];
	uint32_t _ge1_gbode_cell_cnt;
} BCM56504_A0_GE1_GBODE_CELL_CNTr_t;

#define BCM56504_A0_GE1_GBODE_CELL_CNTr_CLR(r) (r).ge1_gbode_cell_cnt[0] = 0
#define BCM56504_A0_GE1_GBODE_CELL_CNTr_SET(r,d) (r).ge1_gbode_cell_cnt[0] = d
#define BCM56504_A0_GE1_GBODE_CELL_CNTr_GET(r) (r).ge1_gbode_cell_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_GE1_GBODE_CELL_CNTr_CELL_CNTf_GET(r) (((r).ge1_gbode_cell_cnt[0]) & 0x7)
#define BCM56504_A0_GE1_GBODE_CELL_CNTr_CELL_CNTf_SET(r,f) (r).ge1_gbode_cell_cnt[0]=(((r).ge1_gbode_cell_cnt[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))

/*
 * These macros can be used to access GE1_GBODE_CELL_CNT.
 *
 */
#define BCM56504_A0_READ_GE1_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE1_GBODE_CELL_CNTr,(r._ge1_gbode_cell_cnt))
#define BCM56504_A0_WRITE_GE1_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE1_GBODE_CELL_CNTr,&(r._ge1_gbode_cell_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE1_GBODE_CELL_CNTr BCM56504_A0_GE1_GBODE_CELL_CNTr
#define GE1_GBODE_CELL_CNTr_SIZE BCM56504_A0_GE1_GBODE_CELL_CNTr_SIZE
typedef BCM56504_A0_GE1_GBODE_CELL_CNTr_t GE1_GBODE_CELL_CNTr_t;
#define GE1_GBODE_CELL_CNTr_CLR BCM56504_A0_GE1_GBODE_CELL_CNTr_CLR
#define GE1_GBODE_CELL_CNTr_SET BCM56504_A0_GE1_GBODE_CELL_CNTr_SET
#define GE1_GBODE_CELL_CNTr_GET BCM56504_A0_GE1_GBODE_CELL_CNTr_GET
#define GE1_GBODE_CELL_CNTr_CELL_CNTf_GET BCM56504_A0_GE1_GBODE_CELL_CNTr_CELL_CNTf_GET
#define GE1_GBODE_CELL_CNTr_CELL_CNTf_SET BCM56504_A0_GE1_GBODE_CELL_CNTr_CELL_CNTf_SET
#define READ_GE1_GBODE_CELL_CNTr BCM56504_A0_READ_GE1_GBODE_CELL_CNTr
#define WRITE_GE1_GBODE_CELL_CNTr BCM56504_A0_WRITE_GE1_GBODE_CELL_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GE1_GBODE_CELL_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GE1_GBODE_CELL_REQ_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell request count register for GE1 
 * SIZE:     32
 * FIELDS:
 *     REQ_CNT          Number of cell request made to Egress Pipeline, MAX is 4.
 *
 ******************************************************************************/
#define BCM56504_A0_GE1_GBODE_CELL_REQ_CNTr 0x00f8001d

#define BCM56504_A0_GE1_GBODE_CELL_REQ_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE1_GBODE_CELL_REQ_CNT.
 *
 */
typedef union BCM56504_A0_GE1_GBODE_CELL_REQ_CNTr_s {
	uint32_t v[1];
	uint32_t ge1_gbode_cell_req_cnt[1];
	uint32_t _ge1_gbode_cell_req_cnt;
} BCM56504_A0_GE1_GBODE_CELL_REQ_CNTr_t;

#define BCM56504_A0_GE1_GBODE_CELL_REQ_CNTr_CLR(r) (r).ge1_gbode_cell_req_cnt[0] = 0
#define BCM56504_A0_GE1_GBODE_CELL_REQ_CNTr_SET(r,d) (r).ge1_gbode_cell_req_cnt[0] = d
#define BCM56504_A0_GE1_GBODE_CELL_REQ_CNTr_GET(r) (r).ge1_gbode_cell_req_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_GE1_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET(r) (((r).ge1_gbode_cell_req_cnt[0]) & 0x7)
#define BCM56504_A0_GE1_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET(r,f) (r).ge1_gbode_cell_req_cnt[0]=(((r).ge1_gbode_cell_req_cnt[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))

/*
 * These macros can be used to access GE1_GBODE_CELL_REQ_CNT.
 *
 */
#define BCM56504_A0_READ_GE1_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE1_GBODE_CELL_REQ_CNTr,(r._ge1_gbode_cell_req_cnt))
#define BCM56504_A0_WRITE_GE1_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE1_GBODE_CELL_REQ_CNTr,&(r._ge1_gbode_cell_req_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE1_GBODE_CELL_REQ_CNTr BCM56504_A0_GE1_GBODE_CELL_REQ_CNTr
#define GE1_GBODE_CELL_REQ_CNTr_SIZE BCM56504_A0_GE1_GBODE_CELL_REQ_CNTr_SIZE
typedef BCM56504_A0_GE1_GBODE_CELL_REQ_CNTr_t GE1_GBODE_CELL_REQ_CNTr_t;
#define GE1_GBODE_CELL_REQ_CNTr_CLR BCM56504_A0_GE1_GBODE_CELL_REQ_CNTr_CLR
#define GE1_GBODE_CELL_REQ_CNTr_SET BCM56504_A0_GE1_GBODE_CELL_REQ_CNTr_SET
#define GE1_GBODE_CELL_REQ_CNTr_GET BCM56504_A0_GE1_GBODE_CELL_REQ_CNTr_GET
#define GE1_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET BCM56504_A0_GE1_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET
#define GE1_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET BCM56504_A0_GE1_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET
#define READ_GE1_GBODE_CELL_REQ_CNTr BCM56504_A0_READ_GE1_GBODE_CELL_REQ_CNTr
#define WRITE_GE1_GBODE_CELL_REQ_CNTr BCM56504_A0_WRITE_GE1_GBODE_CELL_REQ_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GE1_GBODE_CELL_REQ_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GE1_GBOD_OVRFLW
 * BLOCKS:   GPORT0
 * DESC:     GBOD RX fifo overflow for GE1 
 * SIZE:     32
 * FIELDS:
 *     OVRFLW           GBOD RX fifo overflow flag.
 *
 ******************************************************************************/
#define BCM56504_A0_GE1_GBOD_OVRFLWr 0x00f80005

#define BCM56504_A0_GE1_GBOD_OVRFLWr_SIZE 4

/*
 * This structure should be used to declare and program GE1_GBOD_OVRFLW.
 *
 */
typedef union BCM56504_A0_GE1_GBOD_OVRFLWr_s {
	uint32_t v[1];
	uint32_t ge1_gbod_ovrflw[1];
	uint32_t _ge1_gbod_ovrflw;
} BCM56504_A0_GE1_GBOD_OVRFLWr_t;

#define BCM56504_A0_GE1_GBOD_OVRFLWr_CLR(r) (r).ge1_gbod_ovrflw[0] = 0
#define BCM56504_A0_GE1_GBOD_OVRFLWr_SET(r,d) (r).ge1_gbod_ovrflw[0] = d
#define BCM56504_A0_GE1_GBOD_OVRFLWr_GET(r) (r).ge1_gbod_ovrflw[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_GE1_GBOD_OVRFLWr_OVRFLWf_GET(r) (((r).ge1_gbod_ovrflw[0]) & 0x1)
#define BCM56504_A0_GE1_GBOD_OVRFLWr_OVRFLWf_SET(r,f) (r).ge1_gbod_ovrflw[0]=(((r).ge1_gbod_ovrflw[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access GE1_GBOD_OVRFLW.
 *
 */
#define BCM56504_A0_READ_GE1_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE1_GBOD_OVRFLWr,(r._ge1_gbod_ovrflw))
#define BCM56504_A0_WRITE_GE1_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE1_GBOD_OVRFLWr,&(r._ge1_gbod_ovrflw))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE1_GBOD_OVRFLWr BCM56504_A0_GE1_GBOD_OVRFLWr
#define GE1_GBOD_OVRFLWr_SIZE BCM56504_A0_GE1_GBOD_OVRFLWr_SIZE
typedef BCM56504_A0_GE1_GBOD_OVRFLWr_t GE1_GBOD_OVRFLWr_t;
#define GE1_GBOD_OVRFLWr_CLR BCM56504_A0_GE1_GBOD_OVRFLWr_CLR
#define GE1_GBOD_OVRFLWr_SET BCM56504_A0_GE1_GBOD_OVRFLWr_SET
#define GE1_GBOD_OVRFLWr_GET BCM56504_A0_GE1_GBOD_OVRFLWr_GET
#define GE1_GBOD_OVRFLWr_OVRFLWf_GET BCM56504_A0_GE1_GBOD_OVRFLWr_OVRFLWf_GET
#define GE1_GBOD_OVRFLWr_OVRFLWf_SET BCM56504_A0_GE1_GBOD_OVRFLWr_OVRFLWf_SET
#define READ_GE1_GBOD_OVRFLWr BCM56504_A0_READ_GE1_GBOD_OVRFLWr
#define WRITE_GE1_GBOD_OVRFLWr BCM56504_A0_WRITE_GE1_GBOD_OVRFLWr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GE1_GBOD_OVRFLWr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GE2_GBODE_CELL_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell count register for GE2 
 * SIZE:     32
 * FIELDS:
 *     CELL_CNT         Number of cell counts in GBODE tx fifo.
 *
 ******************************************************************************/
#define BCM56504_A0_GE2_GBODE_CELL_CNTr 0x00f80012

#define BCM56504_A0_GE2_GBODE_CELL_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE2_GBODE_CELL_CNT.
 *
 */
typedef union BCM56504_A0_GE2_GBODE_CELL_CNTr_s {
	uint32_t v[1];
	uint32_t ge2_gbode_cell_cnt[1];
	uint32_t _ge2_gbode_cell_cnt;
} BCM56504_A0_GE2_GBODE_CELL_CNTr_t;

#define BCM56504_A0_GE2_GBODE_CELL_CNTr_CLR(r) (r).ge2_gbode_cell_cnt[0] = 0
#define BCM56504_A0_GE2_GBODE_CELL_CNTr_SET(r,d) (r).ge2_gbode_cell_cnt[0] = d
#define BCM56504_A0_GE2_GBODE_CELL_CNTr_GET(r) (r).ge2_gbode_cell_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_GE2_GBODE_CELL_CNTr_CELL_CNTf_GET(r) (((r).ge2_gbode_cell_cnt[0]) & 0x7)
#define BCM56504_A0_GE2_GBODE_CELL_CNTr_CELL_CNTf_SET(r,f) (r).ge2_gbode_cell_cnt[0]=(((r).ge2_gbode_cell_cnt[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))

/*
 * These macros can be used to access GE2_GBODE_CELL_CNT.
 *
 */
#define BCM56504_A0_READ_GE2_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE2_GBODE_CELL_CNTr,(r._ge2_gbode_cell_cnt))
#define BCM56504_A0_WRITE_GE2_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE2_GBODE_CELL_CNTr,&(r._ge2_gbode_cell_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE2_GBODE_CELL_CNTr BCM56504_A0_GE2_GBODE_CELL_CNTr
#define GE2_GBODE_CELL_CNTr_SIZE BCM56504_A0_GE2_GBODE_CELL_CNTr_SIZE
typedef BCM56504_A0_GE2_GBODE_CELL_CNTr_t GE2_GBODE_CELL_CNTr_t;
#define GE2_GBODE_CELL_CNTr_CLR BCM56504_A0_GE2_GBODE_CELL_CNTr_CLR
#define GE2_GBODE_CELL_CNTr_SET BCM56504_A0_GE2_GBODE_CELL_CNTr_SET
#define GE2_GBODE_CELL_CNTr_GET BCM56504_A0_GE2_GBODE_CELL_CNTr_GET
#define GE2_GBODE_CELL_CNTr_CELL_CNTf_GET BCM56504_A0_GE2_GBODE_CELL_CNTr_CELL_CNTf_GET
#define GE2_GBODE_CELL_CNTr_CELL_CNTf_SET BCM56504_A0_GE2_GBODE_CELL_CNTr_CELL_CNTf_SET
#define READ_GE2_GBODE_CELL_CNTr BCM56504_A0_READ_GE2_GBODE_CELL_CNTr
#define WRITE_GE2_GBODE_CELL_CNTr BCM56504_A0_WRITE_GE2_GBODE_CELL_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GE2_GBODE_CELL_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GE2_GBODE_CELL_REQ_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell request count register for GE2 
 * SIZE:     32
 * FIELDS:
 *     REQ_CNT          Number of cell request made to Egress Pipeline, MAX is 4.
 *
 ******************************************************************************/
#define BCM56504_A0_GE2_GBODE_CELL_REQ_CNTr 0x00f8001e

#define BCM56504_A0_GE2_GBODE_CELL_REQ_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE2_GBODE_CELL_REQ_CNT.
 *
 */
typedef union BCM56504_A0_GE2_GBODE_CELL_REQ_CNTr_s {
	uint32_t v[1];
	uint32_t ge2_gbode_cell_req_cnt[1];
	uint32_t _ge2_gbode_cell_req_cnt;
} BCM56504_A0_GE2_GBODE_CELL_REQ_CNTr_t;

#define BCM56504_A0_GE2_GBODE_CELL_REQ_CNTr_CLR(r) (r).ge2_gbode_cell_req_cnt[0] = 0
#define BCM56504_A0_GE2_GBODE_CELL_REQ_CNTr_SET(r,d) (r).ge2_gbode_cell_req_cnt[0] = d
#define BCM56504_A0_GE2_GBODE_CELL_REQ_CNTr_GET(r) (r).ge2_gbode_cell_req_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_GE2_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET(r) (((r).ge2_gbode_cell_req_cnt[0]) & 0x7)
#define BCM56504_A0_GE2_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET(r,f) (r).ge2_gbode_cell_req_cnt[0]=(((r).ge2_gbode_cell_req_cnt[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))

/*
 * These macros can be used to access GE2_GBODE_CELL_REQ_CNT.
 *
 */
#define BCM56504_A0_READ_GE2_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE2_GBODE_CELL_REQ_CNTr,(r._ge2_gbode_cell_req_cnt))
#define BCM56504_A0_WRITE_GE2_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE2_GBODE_CELL_REQ_CNTr,&(r._ge2_gbode_cell_req_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE2_GBODE_CELL_REQ_CNTr BCM56504_A0_GE2_GBODE_CELL_REQ_CNTr
#define GE2_GBODE_CELL_REQ_CNTr_SIZE BCM56504_A0_GE2_GBODE_CELL_REQ_CNTr_SIZE
typedef BCM56504_A0_GE2_GBODE_CELL_REQ_CNTr_t GE2_GBODE_CELL_REQ_CNTr_t;
#define GE2_GBODE_CELL_REQ_CNTr_CLR BCM56504_A0_GE2_GBODE_CELL_REQ_CNTr_CLR
#define GE2_GBODE_CELL_REQ_CNTr_SET BCM56504_A0_GE2_GBODE_CELL_REQ_CNTr_SET
#define GE2_GBODE_CELL_REQ_CNTr_GET BCM56504_A0_GE2_GBODE_CELL_REQ_CNTr_GET
#define GE2_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET BCM56504_A0_GE2_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET
#define GE2_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET BCM56504_A0_GE2_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET
#define READ_GE2_GBODE_CELL_REQ_CNTr BCM56504_A0_READ_GE2_GBODE_CELL_REQ_CNTr
#define WRITE_GE2_GBODE_CELL_REQ_CNTr BCM56504_A0_WRITE_GE2_GBODE_CELL_REQ_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GE2_GBODE_CELL_REQ_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GE2_GBOD_OVRFLW
 * BLOCKS:   GPORT0
 * DESC:     GBOD RX fifo overflow for GE2 
 * SIZE:     32
 * FIELDS:
 *     OVRFLW           GBOD RX fifo overflow flag.
 *
 ******************************************************************************/
#define BCM56504_A0_GE2_GBOD_OVRFLWr 0x00f80006

#define BCM56504_A0_GE2_GBOD_OVRFLWr_SIZE 4

/*
 * This structure should be used to declare and program GE2_GBOD_OVRFLW.
 *
 */
typedef union BCM56504_A0_GE2_GBOD_OVRFLWr_s {
	uint32_t v[1];
	uint32_t ge2_gbod_ovrflw[1];
	uint32_t _ge2_gbod_ovrflw;
} BCM56504_A0_GE2_GBOD_OVRFLWr_t;

#define BCM56504_A0_GE2_GBOD_OVRFLWr_CLR(r) (r).ge2_gbod_ovrflw[0] = 0
#define BCM56504_A0_GE2_GBOD_OVRFLWr_SET(r,d) (r).ge2_gbod_ovrflw[0] = d
#define BCM56504_A0_GE2_GBOD_OVRFLWr_GET(r) (r).ge2_gbod_ovrflw[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_GE2_GBOD_OVRFLWr_OVRFLWf_GET(r) (((r).ge2_gbod_ovrflw[0]) & 0x1)
#define BCM56504_A0_GE2_GBOD_OVRFLWr_OVRFLWf_SET(r,f) (r).ge2_gbod_ovrflw[0]=(((r).ge2_gbod_ovrflw[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access GE2_GBOD_OVRFLW.
 *
 */
#define BCM56504_A0_READ_GE2_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE2_GBOD_OVRFLWr,(r._ge2_gbod_ovrflw))
#define BCM56504_A0_WRITE_GE2_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE2_GBOD_OVRFLWr,&(r._ge2_gbod_ovrflw))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE2_GBOD_OVRFLWr BCM56504_A0_GE2_GBOD_OVRFLWr
#define GE2_GBOD_OVRFLWr_SIZE BCM56504_A0_GE2_GBOD_OVRFLWr_SIZE
typedef BCM56504_A0_GE2_GBOD_OVRFLWr_t GE2_GBOD_OVRFLWr_t;
#define GE2_GBOD_OVRFLWr_CLR BCM56504_A0_GE2_GBOD_OVRFLWr_CLR
#define GE2_GBOD_OVRFLWr_SET BCM56504_A0_GE2_GBOD_OVRFLWr_SET
#define GE2_GBOD_OVRFLWr_GET BCM56504_A0_GE2_GBOD_OVRFLWr_GET
#define GE2_GBOD_OVRFLWr_OVRFLWf_GET BCM56504_A0_GE2_GBOD_OVRFLWr_OVRFLWf_GET
#define GE2_GBOD_OVRFLWr_OVRFLWf_SET BCM56504_A0_GE2_GBOD_OVRFLWr_OVRFLWf_SET
#define READ_GE2_GBOD_OVRFLWr BCM56504_A0_READ_GE2_GBOD_OVRFLWr
#define WRITE_GE2_GBOD_OVRFLWr BCM56504_A0_WRITE_GE2_GBOD_OVRFLWr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GE2_GBOD_OVRFLWr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GE3_GBODE_CELL_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell count register for GE3 
 * SIZE:     32
 * FIELDS:
 *     CELL_CNT         Number of cell counts in GBODE tx fifo.
 *
 ******************************************************************************/
#define BCM56504_A0_GE3_GBODE_CELL_CNTr 0x00f80013

#define BCM56504_A0_GE3_GBODE_CELL_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE3_GBODE_CELL_CNT.
 *
 */
typedef union BCM56504_A0_GE3_GBODE_CELL_CNTr_s {
	uint32_t v[1];
	uint32_t ge3_gbode_cell_cnt[1];
	uint32_t _ge3_gbode_cell_cnt;
} BCM56504_A0_GE3_GBODE_CELL_CNTr_t;

#define BCM56504_A0_GE3_GBODE_CELL_CNTr_CLR(r) (r).ge3_gbode_cell_cnt[0] = 0
#define BCM56504_A0_GE3_GBODE_CELL_CNTr_SET(r,d) (r).ge3_gbode_cell_cnt[0] = d
#define BCM56504_A0_GE3_GBODE_CELL_CNTr_GET(r) (r).ge3_gbode_cell_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_GE3_GBODE_CELL_CNTr_CELL_CNTf_GET(r) (((r).ge3_gbode_cell_cnt[0]) & 0x7)
#define BCM56504_A0_GE3_GBODE_CELL_CNTr_CELL_CNTf_SET(r,f) (r).ge3_gbode_cell_cnt[0]=(((r).ge3_gbode_cell_cnt[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))

/*
 * These macros can be used to access GE3_GBODE_CELL_CNT.
 *
 */
#define BCM56504_A0_READ_GE3_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE3_GBODE_CELL_CNTr,(r._ge3_gbode_cell_cnt))
#define BCM56504_A0_WRITE_GE3_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE3_GBODE_CELL_CNTr,&(r._ge3_gbode_cell_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE3_GBODE_CELL_CNTr BCM56504_A0_GE3_GBODE_CELL_CNTr
#define GE3_GBODE_CELL_CNTr_SIZE BCM56504_A0_GE3_GBODE_CELL_CNTr_SIZE
typedef BCM56504_A0_GE3_GBODE_CELL_CNTr_t GE3_GBODE_CELL_CNTr_t;
#define GE3_GBODE_CELL_CNTr_CLR BCM56504_A0_GE3_GBODE_CELL_CNTr_CLR
#define GE3_GBODE_CELL_CNTr_SET BCM56504_A0_GE3_GBODE_CELL_CNTr_SET
#define GE3_GBODE_CELL_CNTr_GET BCM56504_A0_GE3_GBODE_CELL_CNTr_GET
#define GE3_GBODE_CELL_CNTr_CELL_CNTf_GET BCM56504_A0_GE3_GBODE_CELL_CNTr_CELL_CNTf_GET
#define GE3_GBODE_CELL_CNTr_CELL_CNTf_SET BCM56504_A0_GE3_GBODE_CELL_CNTr_CELL_CNTf_SET
#define READ_GE3_GBODE_CELL_CNTr BCM56504_A0_READ_GE3_GBODE_CELL_CNTr
#define WRITE_GE3_GBODE_CELL_CNTr BCM56504_A0_WRITE_GE3_GBODE_CELL_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GE3_GBODE_CELL_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GE3_GBODE_CELL_REQ_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell request count register for GE3 
 * SIZE:     32
 * FIELDS:
 *     REQ_CNT          Number of cell request made to Egress Pipeline, MAX is 4.
 *
 ******************************************************************************/
#define BCM56504_A0_GE3_GBODE_CELL_REQ_CNTr 0x00f8001f

#define BCM56504_A0_GE3_GBODE_CELL_REQ_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE3_GBODE_CELL_REQ_CNT.
 *
 */
typedef union BCM56504_A0_GE3_GBODE_CELL_REQ_CNTr_s {
	uint32_t v[1];
	uint32_t ge3_gbode_cell_req_cnt[1];
	uint32_t _ge3_gbode_cell_req_cnt;
} BCM56504_A0_GE3_GBODE_CELL_REQ_CNTr_t;

#define BCM56504_A0_GE3_GBODE_CELL_REQ_CNTr_CLR(r) (r).ge3_gbode_cell_req_cnt[0] = 0
#define BCM56504_A0_GE3_GBODE_CELL_REQ_CNTr_SET(r,d) (r).ge3_gbode_cell_req_cnt[0] = d
#define BCM56504_A0_GE3_GBODE_CELL_REQ_CNTr_GET(r) (r).ge3_gbode_cell_req_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_GE3_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET(r) (((r).ge3_gbode_cell_req_cnt[0]) & 0x7)
#define BCM56504_A0_GE3_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET(r,f) (r).ge3_gbode_cell_req_cnt[0]=(((r).ge3_gbode_cell_req_cnt[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))

/*
 * These macros can be used to access GE3_GBODE_CELL_REQ_CNT.
 *
 */
#define BCM56504_A0_READ_GE3_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE3_GBODE_CELL_REQ_CNTr,(r._ge3_gbode_cell_req_cnt))
#define BCM56504_A0_WRITE_GE3_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE3_GBODE_CELL_REQ_CNTr,&(r._ge3_gbode_cell_req_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE3_GBODE_CELL_REQ_CNTr BCM56504_A0_GE3_GBODE_CELL_REQ_CNTr
#define GE3_GBODE_CELL_REQ_CNTr_SIZE BCM56504_A0_GE3_GBODE_CELL_REQ_CNTr_SIZE
typedef BCM56504_A0_GE3_GBODE_CELL_REQ_CNTr_t GE3_GBODE_CELL_REQ_CNTr_t;
#define GE3_GBODE_CELL_REQ_CNTr_CLR BCM56504_A0_GE3_GBODE_CELL_REQ_CNTr_CLR
#define GE3_GBODE_CELL_REQ_CNTr_SET BCM56504_A0_GE3_GBODE_CELL_REQ_CNTr_SET
#define GE3_GBODE_CELL_REQ_CNTr_GET BCM56504_A0_GE3_GBODE_CELL_REQ_CNTr_GET
#define GE3_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET BCM56504_A0_GE3_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET
#define GE3_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET BCM56504_A0_GE3_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET
#define READ_GE3_GBODE_CELL_REQ_CNTr BCM56504_A0_READ_GE3_GBODE_CELL_REQ_CNTr
#define WRITE_GE3_GBODE_CELL_REQ_CNTr BCM56504_A0_WRITE_GE3_GBODE_CELL_REQ_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GE3_GBODE_CELL_REQ_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GE3_GBOD_OVRFLW
 * BLOCKS:   GPORT0
 * DESC:     GBOD RX fifo overflow for GE3 
 * SIZE:     32
 * FIELDS:
 *     OVRFLW           GBOD RX fifo overflow flag.
 *
 ******************************************************************************/
#define BCM56504_A0_GE3_GBOD_OVRFLWr 0x00f80007

#define BCM56504_A0_GE3_GBOD_OVRFLWr_SIZE 4

/*
 * This structure should be used to declare and program GE3_GBOD_OVRFLW.
 *
 */
typedef union BCM56504_A0_GE3_GBOD_OVRFLWr_s {
	uint32_t v[1];
	uint32_t ge3_gbod_ovrflw[1];
	uint32_t _ge3_gbod_ovrflw;
} BCM56504_A0_GE3_GBOD_OVRFLWr_t;

#define BCM56504_A0_GE3_GBOD_OVRFLWr_CLR(r) (r).ge3_gbod_ovrflw[0] = 0
#define BCM56504_A0_GE3_GBOD_OVRFLWr_SET(r,d) (r).ge3_gbod_ovrflw[0] = d
#define BCM56504_A0_GE3_GBOD_OVRFLWr_GET(r) (r).ge3_gbod_ovrflw[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_GE3_GBOD_OVRFLWr_OVRFLWf_GET(r) (((r).ge3_gbod_ovrflw[0]) & 0x1)
#define BCM56504_A0_GE3_GBOD_OVRFLWr_OVRFLWf_SET(r,f) (r).ge3_gbod_ovrflw[0]=(((r).ge3_gbod_ovrflw[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access GE3_GBOD_OVRFLW.
 *
 */
#define BCM56504_A0_READ_GE3_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE3_GBOD_OVRFLWr,(r._ge3_gbod_ovrflw))
#define BCM56504_A0_WRITE_GE3_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE3_GBOD_OVRFLWr,&(r._ge3_gbod_ovrflw))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE3_GBOD_OVRFLWr BCM56504_A0_GE3_GBOD_OVRFLWr
#define GE3_GBOD_OVRFLWr_SIZE BCM56504_A0_GE3_GBOD_OVRFLWr_SIZE
typedef BCM56504_A0_GE3_GBOD_OVRFLWr_t GE3_GBOD_OVRFLWr_t;
#define GE3_GBOD_OVRFLWr_CLR BCM56504_A0_GE3_GBOD_OVRFLWr_CLR
#define GE3_GBOD_OVRFLWr_SET BCM56504_A0_GE3_GBOD_OVRFLWr_SET
#define GE3_GBOD_OVRFLWr_GET BCM56504_A0_GE3_GBOD_OVRFLWr_GET
#define GE3_GBOD_OVRFLWr_OVRFLWf_GET BCM56504_A0_GE3_GBOD_OVRFLWr_OVRFLWf_GET
#define GE3_GBOD_OVRFLWr_OVRFLWf_SET BCM56504_A0_GE3_GBOD_OVRFLWr_OVRFLWf_SET
#define READ_GE3_GBOD_OVRFLWr BCM56504_A0_READ_GE3_GBOD_OVRFLWr
#define WRITE_GE3_GBOD_OVRFLWr BCM56504_A0_WRITE_GE3_GBOD_OVRFLWr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GE3_GBOD_OVRFLWr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GE4_GBODE_CELL_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell count register for GE4 
 * SIZE:     32
 * FIELDS:
 *     CELL_CNT         Number of cell counts in GBODE tx fifo.
 *
 ******************************************************************************/
#define BCM56504_A0_GE4_GBODE_CELL_CNTr 0x00f80014

#define BCM56504_A0_GE4_GBODE_CELL_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE4_GBODE_CELL_CNT.
 *
 */
typedef union BCM56504_A0_GE4_GBODE_CELL_CNTr_s {
	uint32_t v[1];
	uint32_t ge4_gbode_cell_cnt[1];
	uint32_t _ge4_gbode_cell_cnt;
} BCM56504_A0_GE4_GBODE_CELL_CNTr_t;

#define BCM56504_A0_GE4_GBODE_CELL_CNTr_CLR(r) (r).ge4_gbode_cell_cnt[0] = 0
#define BCM56504_A0_GE4_GBODE_CELL_CNTr_SET(r,d) (r).ge4_gbode_cell_cnt[0] = d
#define BCM56504_A0_GE4_GBODE_CELL_CNTr_GET(r) (r).ge4_gbode_cell_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_GE4_GBODE_CELL_CNTr_CELL_CNTf_GET(r) (((r).ge4_gbode_cell_cnt[0]) & 0x7)
#define BCM56504_A0_GE4_GBODE_CELL_CNTr_CELL_CNTf_SET(r,f) (r).ge4_gbode_cell_cnt[0]=(((r).ge4_gbode_cell_cnt[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))

/*
 * These macros can be used to access GE4_GBODE_CELL_CNT.
 *
 */
#define BCM56504_A0_READ_GE4_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE4_GBODE_CELL_CNTr,(r._ge4_gbode_cell_cnt))
#define BCM56504_A0_WRITE_GE4_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE4_GBODE_CELL_CNTr,&(r._ge4_gbode_cell_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE4_GBODE_CELL_CNTr BCM56504_A0_GE4_GBODE_CELL_CNTr
#define GE4_GBODE_CELL_CNTr_SIZE BCM56504_A0_GE4_GBODE_CELL_CNTr_SIZE
typedef BCM56504_A0_GE4_GBODE_CELL_CNTr_t GE4_GBODE_CELL_CNTr_t;
#define GE4_GBODE_CELL_CNTr_CLR BCM56504_A0_GE4_GBODE_CELL_CNTr_CLR
#define GE4_GBODE_CELL_CNTr_SET BCM56504_A0_GE4_GBODE_CELL_CNTr_SET
#define GE4_GBODE_CELL_CNTr_GET BCM56504_A0_GE4_GBODE_CELL_CNTr_GET
#define GE4_GBODE_CELL_CNTr_CELL_CNTf_GET BCM56504_A0_GE4_GBODE_CELL_CNTr_CELL_CNTf_GET
#define GE4_GBODE_CELL_CNTr_CELL_CNTf_SET BCM56504_A0_GE4_GBODE_CELL_CNTr_CELL_CNTf_SET
#define READ_GE4_GBODE_CELL_CNTr BCM56504_A0_READ_GE4_GBODE_CELL_CNTr
#define WRITE_GE4_GBODE_CELL_CNTr BCM56504_A0_WRITE_GE4_GBODE_CELL_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GE4_GBODE_CELL_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GE4_GBODE_CELL_REQ_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell request count register for GE4 
 * SIZE:     32
 * FIELDS:
 *     REQ_CNT          Number of cell request made to Egress Pipeline, MAX is 4.
 *
 ******************************************************************************/
#define BCM56504_A0_GE4_GBODE_CELL_REQ_CNTr 0x00f80020

#define BCM56504_A0_GE4_GBODE_CELL_REQ_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE4_GBODE_CELL_REQ_CNT.
 *
 */
typedef union BCM56504_A0_GE4_GBODE_CELL_REQ_CNTr_s {
	uint32_t v[1];
	uint32_t ge4_gbode_cell_req_cnt[1];
	uint32_t _ge4_gbode_cell_req_cnt;
} BCM56504_A0_GE4_GBODE_CELL_REQ_CNTr_t;

#define BCM56504_A0_GE4_GBODE_CELL_REQ_CNTr_CLR(r) (r).ge4_gbode_cell_req_cnt[0] = 0
#define BCM56504_A0_GE4_GBODE_CELL_REQ_CNTr_SET(r,d) (r).ge4_gbode_cell_req_cnt[0] = d
#define BCM56504_A0_GE4_GBODE_CELL_REQ_CNTr_GET(r) (r).ge4_gbode_cell_req_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_GE4_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET(r) (((r).ge4_gbode_cell_req_cnt[0]) & 0x7)
#define BCM56504_A0_GE4_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET(r,f) (r).ge4_gbode_cell_req_cnt[0]=(((r).ge4_gbode_cell_req_cnt[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))

/*
 * These macros can be used to access GE4_GBODE_CELL_REQ_CNT.
 *
 */
#define BCM56504_A0_READ_GE4_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE4_GBODE_CELL_REQ_CNTr,(r._ge4_gbode_cell_req_cnt))
#define BCM56504_A0_WRITE_GE4_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE4_GBODE_CELL_REQ_CNTr,&(r._ge4_gbode_cell_req_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE4_GBODE_CELL_REQ_CNTr BCM56504_A0_GE4_GBODE_CELL_REQ_CNTr
#define GE4_GBODE_CELL_REQ_CNTr_SIZE BCM56504_A0_GE4_GBODE_CELL_REQ_CNTr_SIZE
typedef BCM56504_A0_GE4_GBODE_CELL_REQ_CNTr_t GE4_GBODE_CELL_REQ_CNTr_t;
#define GE4_GBODE_CELL_REQ_CNTr_CLR BCM56504_A0_GE4_GBODE_CELL_REQ_CNTr_CLR
#define GE4_GBODE_CELL_REQ_CNTr_SET BCM56504_A0_GE4_GBODE_CELL_REQ_CNTr_SET
#define GE4_GBODE_CELL_REQ_CNTr_GET BCM56504_A0_GE4_GBODE_CELL_REQ_CNTr_GET
#define GE4_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET BCM56504_A0_GE4_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET
#define GE4_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET BCM56504_A0_GE4_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET
#define READ_GE4_GBODE_CELL_REQ_CNTr BCM56504_A0_READ_GE4_GBODE_CELL_REQ_CNTr
#define WRITE_GE4_GBODE_CELL_REQ_CNTr BCM56504_A0_WRITE_GE4_GBODE_CELL_REQ_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GE4_GBODE_CELL_REQ_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GE4_GBOD_OVRFLW
 * BLOCKS:   GPORT0
 * DESC:     GBOD RX fifo overflow for GE4 
 * SIZE:     32
 * FIELDS:
 *     OVRFLW           GBOD RX fifo overflow flag.
 *
 ******************************************************************************/
#define BCM56504_A0_GE4_GBOD_OVRFLWr 0x00f80008

#define BCM56504_A0_GE4_GBOD_OVRFLWr_SIZE 4

/*
 * This structure should be used to declare and program GE4_GBOD_OVRFLW.
 *
 */
typedef union BCM56504_A0_GE4_GBOD_OVRFLWr_s {
	uint32_t v[1];
	uint32_t ge4_gbod_ovrflw[1];
	uint32_t _ge4_gbod_ovrflw;
} BCM56504_A0_GE4_GBOD_OVRFLWr_t;

#define BCM56504_A0_GE4_GBOD_OVRFLWr_CLR(r) (r).ge4_gbod_ovrflw[0] = 0
#define BCM56504_A0_GE4_GBOD_OVRFLWr_SET(r,d) (r).ge4_gbod_ovrflw[0] = d
#define BCM56504_A0_GE4_GBOD_OVRFLWr_GET(r) (r).ge4_gbod_ovrflw[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_GE4_GBOD_OVRFLWr_OVRFLWf_GET(r) (((r).ge4_gbod_ovrflw[0]) & 0x1)
#define BCM56504_A0_GE4_GBOD_OVRFLWr_OVRFLWf_SET(r,f) (r).ge4_gbod_ovrflw[0]=(((r).ge4_gbod_ovrflw[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access GE4_GBOD_OVRFLW.
 *
 */
#define BCM56504_A0_READ_GE4_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE4_GBOD_OVRFLWr,(r._ge4_gbod_ovrflw))
#define BCM56504_A0_WRITE_GE4_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE4_GBOD_OVRFLWr,&(r._ge4_gbod_ovrflw))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE4_GBOD_OVRFLWr BCM56504_A0_GE4_GBOD_OVRFLWr
#define GE4_GBOD_OVRFLWr_SIZE BCM56504_A0_GE4_GBOD_OVRFLWr_SIZE
typedef BCM56504_A0_GE4_GBOD_OVRFLWr_t GE4_GBOD_OVRFLWr_t;
#define GE4_GBOD_OVRFLWr_CLR BCM56504_A0_GE4_GBOD_OVRFLWr_CLR
#define GE4_GBOD_OVRFLWr_SET BCM56504_A0_GE4_GBOD_OVRFLWr_SET
#define GE4_GBOD_OVRFLWr_GET BCM56504_A0_GE4_GBOD_OVRFLWr_GET
#define GE4_GBOD_OVRFLWr_OVRFLWf_GET BCM56504_A0_GE4_GBOD_OVRFLWr_OVRFLWf_GET
#define GE4_GBOD_OVRFLWr_OVRFLWf_SET BCM56504_A0_GE4_GBOD_OVRFLWr_OVRFLWf_SET
#define READ_GE4_GBOD_OVRFLWr BCM56504_A0_READ_GE4_GBOD_OVRFLWr
#define WRITE_GE4_GBOD_OVRFLWr BCM56504_A0_WRITE_GE4_GBOD_OVRFLWr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GE4_GBOD_OVRFLWr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GE5_GBODE_CELL_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell count register for GE5 
 * SIZE:     32
 * FIELDS:
 *     CELL_CNT         Number of cell counts in GBODE tx fifo.
 *
 ******************************************************************************/
#define BCM56504_A0_GE5_GBODE_CELL_CNTr 0x00f80015

#define BCM56504_A0_GE5_GBODE_CELL_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE5_GBODE_CELL_CNT.
 *
 */
typedef union BCM56504_A0_GE5_GBODE_CELL_CNTr_s {
	uint32_t v[1];
	uint32_t ge5_gbode_cell_cnt[1];
	uint32_t _ge5_gbode_cell_cnt;
} BCM56504_A0_GE5_GBODE_CELL_CNTr_t;

#define BCM56504_A0_GE5_GBODE_CELL_CNTr_CLR(r) (r).ge5_gbode_cell_cnt[0] = 0
#define BCM56504_A0_GE5_GBODE_CELL_CNTr_SET(r,d) (r).ge5_gbode_cell_cnt[0] = d
#define BCM56504_A0_GE5_GBODE_CELL_CNTr_GET(r) (r).ge5_gbode_cell_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_GE5_GBODE_CELL_CNTr_CELL_CNTf_GET(r) (((r).ge5_gbode_cell_cnt[0]) & 0x7)
#define BCM56504_A0_GE5_GBODE_CELL_CNTr_CELL_CNTf_SET(r,f) (r).ge5_gbode_cell_cnt[0]=(((r).ge5_gbode_cell_cnt[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))

/*
 * These macros can be used to access GE5_GBODE_CELL_CNT.
 *
 */
#define BCM56504_A0_READ_GE5_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE5_GBODE_CELL_CNTr,(r._ge5_gbode_cell_cnt))
#define BCM56504_A0_WRITE_GE5_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE5_GBODE_CELL_CNTr,&(r._ge5_gbode_cell_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE5_GBODE_CELL_CNTr BCM56504_A0_GE5_GBODE_CELL_CNTr
#define GE5_GBODE_CELL_CNTr_SIZE BCM56504_A0_GE5_GBODE_CELL_CNTr_SIZE
typedef BCM56504_A0_GE5_GBODE_CELL_CNTr_t GE5_GBODE_CELL_CNTr_t;
#define GE5_GBODE_CELL_CNTr_CLR BCM56504_A0_GE5_GBODE_CELL_CNTr_CLR
#define GE5_GBODE_CELL_CNTr_SET BCM56504_A0_GE5_GBODE_CELL_CNTr_SET
#define GE5_GBODE_CELL_CNTr_GET BCM56504_A0_GE5_GBODE_CELL_CNTr_GET
#define GE5_GBODE_CELL_CNTr_CELL_CNTf_GET BCM56504_A0_GE5_GBODE_CELL_CNTr_CELL_CNTf_GET
#define GE5_GBODE_CELL_CNTr_CELL_CNTf_SET BCM56504_A0_GE5_GBODE_CELL_CNTr_CELL_CNTf_SET
#define READ_GE5_GBODE_CELL_CNTr BCM56504_A0_READ_GE5_GBODE_CELL_CNTr
#define WRITE_GE5_GBODE_CELL_CNTr BCM56504_A0_WRITE_GE5_GBODE_CELL_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GE5_GBODE_CELL_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GE5_GBODE_CELL_REQ_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell request count register for GE5 
 * SIZE:     32
 * FIELDS:
 *     REQ_CNT          Number of cell request made to Egress Pipeline, MAX is 4.
 *
 ******************************************************************************/
#define BCM56504_A0_GE5_GBODE_CELL_REQ_CNTr 0x00f80021

#define BCM56504_A0_GE5_GBODE_CELL_REQ_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE5_GBODE_CELL_REQ_CNT.
 *
 */
typedef union BCM56504_A0_GE5_GBODE_CELL_REQ_CNTr_s {
	uint32_t v[1];
	uint32_t ge5_gbode_cell_req_cnt[1];
	uint32_t _ge5_gbode_cell_req_cnt;
} BCM56504_A0_GE5_GBODE_CELL_REQ_CNTr_t;

#define BCM56504_A0_GE5_GBODE_CELL_REQ_CNTr_CLR(r) (r).ge5_gbode_cell_req_cnt[0] = 0
#define BCM56504_A0_GE5_GBODE_CELL_REQ_CNTr_SET(r,d) (r).ge5_gbode_cell_req_cnt[0] = d
#define BCM56504_A0_GE5_GBODE_CELL_REQ_CNTr_GET(r) (r).ge5_gbode_cell_req_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_GE5_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET(r) (((r).ge5_gbode_cell_req_cnt[0]) & 0x7)
#define BCM56504_A0_GE5_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET(r,f) (r).ge5_gbode_cell_req_cnt[0]=(((r).ge5_gbode_cell_req_cnt[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))

/*
 * These macros can be used to access GE5_GBODE_CELL_REQ_CNT.
 *
 */
#define BCM56504_A0_READ_GE5_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE5_GBODE_CELL_REQ_CNTr,(r._ge5_gbode_cell_req_cnt))
#define BCM56504_A0_WRITE_GE5_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE5_GBODE_CELL_REQ_CNTr,&(r._ge5_gbode_cell_req_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE5_GBODE_CELL_REQ_CNTr BCM56504_A0_GE5_GBODE_CELL_REQ_CNTr
#define GE5_GBODE_CELL_REQ_CNTr_SIZE BCM56504_A0_GE5_GBODE_CELL_REQ_CNTr_SIZE
typedef BCM56504_A0_GE5_GBODE_CELL_REQ_CNTr_t GE5_GBODE_CELL_REQ_CNTr_t;
#define GE5_GBODE_CELL_REQ_CNTr_CLR BCM56504_A0_GE5_GBODE_CELL_REQ_CNTr_CLR
#define GE5_GBODE_CELL_REQ_CNTr_SET BCM56504_A0_GE5_GBODE_CELL_REQ_CNTr_SET
#define GE5_GBODE_CELL_REQ_CNTr_GET BCM56504_A0_GE5_GBODE_CELL_REQ_CNTr_GET
#define GE5_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET BCM56504_A0_GE5_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET
#define GE5_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET BCM56504_A0_GE5_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET
#define READ_GE5_GBODE_CELL_REQ_CNTr BCM56504_A0_READ_GE5_GBODE_CELL_REQ_CNTr
#define WRITE_GE5_GBODE_CELL_REQ_CNTr BCM56504_A0_WRITE_GE5_GBODE_CELL_REQ_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GE5_GBODE_CELL_REQ_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GE5_GBOD_OVRFLW
 * BLOCKS:   GPORT0
 * DESC:     GBOD RX fifo overflow for GE5 
 * SIZE:     32
 * FIELDS:
 *     OVRFLW           GBOD RX fifo overflow flag.
 *
 ******************************************************************************/
#define BCM56504_A0_GE5_GBOD_OVRFLWr 0x00f80009

#define BCM56504_A0_GE5_GBOD_OVRFLWr_SIZE 4

/*
 * This structure should be used to declare and program GE5_GBOD_OVRFLW.
 *
 */
typedef union BCM56504_A0_GE5_GBOD_OVRFLWr_s {
	uint32_t v[1];
	uint32_t ge5_gbod_ovrflw[1];
	uint32_t _ge5_gbod_ovrflw;
} BCM56504_A0_GE5_GBOD_OVRFLWr_t;

#define BCM56504_A0_GE5_GBOD_OVRFLWr_CLR(r) (r).ge5_gbod_ovrflw[0] = 0
#define BCM56504_A0_GE5_GBOD_OVRFLWr_SET(r,d) (r).ge5_gbod_ovrflw[0] = d
#define BCM56504_A0_GE5_GBOD_OVRFLWr_GET(r) (r).ge5_gbod_ovrflw[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_GE5_GBOD_OVRFLWr_OVRFLWf_GET(r) (((r).ge5_gbod_ovrflw[0]) & 0x1)
#define BCM56504_A0_GE5_GBOD_OVRFLWr_OVRFLWf_SET(r,f) (r).ge5_gbod_ovrflw[0]=(((r).ge5_gbod_ovrflw[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access GE5_GBOD_OVRFLW.
 *
 */
#define BCM56504_A0_READ_GE5_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE5_GBOD_OVRFLWr,(r._ge5_gbod_ovrflw))
#define BCM56504_A0_WRITE_GE5_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE5_GBOD_OVRFLWr,&(r._ge5_gbod_ovrflw))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE5_GBOD_OVRFLWr BCM56504_A0_GE5_GBOD_OVRFLWr
#define GE5_GBOD_OVRFLWr_SIZE BCM56504_A0_GE5_GBOD_OVRFLWr_SIZE
typedef BCM56504_A0_GE5_GBOD_OVRFLWr_t GE5_GBOD_OVRFLWr_t;
#define GE5_GBOD_OVRFLWr_CLR BCM56504_A0_GE5_GBOD_OVRFLWr_CLR
#define GE5_GBOD_OVRFLWr_SET BCM56504_A0_GE5_GBOD_OVRFLWr_SET
#define GE5_GBOD_OVRFLWr_GET BCM56504_A0_GE5_GBOD_OVRFLWr_GET
#define GE5_GBOD_OVRFLWr_OVRFLWf_GET BCM56504_A0_GE5_GBOD_OVRFLWr_OVRFLWf_GET
#define GE5_GBOD_OVRFLWr_OVRFLWf_SET BCM56504_A0_GE5_GBOD_OVRFLWr_OVRFLWf_SET
#define READ_GE5_GBOD_OVRFLWr BCM56504_A0_READ_GE5_GBOD_OVRFLWr
#define WRITE_GE5_GBOD_OVRFLWr BCM56504_A0_WRITE_GE5_GBOD_OVRFLWr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GE5_GBOD_OVRFLWr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GE6_GBODE_CELL_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell count register for GE6 
 * SIZE:     32
 * FIELDS:
 *     CELL_CNT         Number of cell counts in GBODE tx fifo.
 *
 ******************************************************************************/
#define BCM56504_A0_GE6_GBODE_CELL_CNTr 0x00f80016

#define BCM56504_A0_GE6_GBODE_CELL_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE6_GBODE_CELL_CNT.
 *
 */
typedef union BCM56504_A0_GE6_GBODE_CELL_CNTr_s {
	uint32_t v[1];
	uint32_t ge6_gbode_cell_cnt[1];
	uint32_t _ge6_gbode_cell_cnt;
} BCM56504_A0_GE6_GBODE_CELL_CNTr_t;

#define BCM56504_A0_GE6_GBODE_CELL_CNTr_CLR(r) (r).ge6_gbode_cell_cnt[0] = 0
#define BCM56504_A0_GE6_GBODE_CELL_CNTr_SET(r,d) (r).ge6_gbode_cell_cnt[0] = d
#define BCM56504_A0_GE6_GBODE_CELL_CNTr_GET(r) (r).ge6_gbode_cell_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_GE6_GBODE_CELL_CNTr_CELL_CNTf_GET(r) (((r).ge6_gbode_cell_cnt[0]) & 0x7)
#define BCM56504_A0_GE6_GBODE_CELL_CNTr_CELL_CNTf_SET(r,f) (r).ge6_gbode_cell_cnt[0]=(((r).ge6_gbode_cell_cnt[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))

/*
 * These macros can be used to access GE6_GBODE_CELL_CNT.
 *
 */
#define BCM56504_A0_READ_GE6_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE6_GBODE_CELL_CNTr,(r._ge6_gbode_cell_cnt))
#define BCM56504_A0_WRITE_GE6_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE6_GBODE_CELL_CNTr,&(r._ge6_gbode_cell_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE6_GBODE_CELL_CNTr BCM56504_A0_GE6_GBODE_CELL_CNTr
#define GE6_GBODE_CELL_CNTr_SIZE BCM56504_A0_GE6_GBODE_CELL_CNTr_SIZE
typedef BCM56504_A0_GE6_GBODE_CELL_CNTr_t GE6_GBODE_CELL_CNTr_t;
#define GE6_GBODE_CELL_CNTr_CLR BCM56504_A0_GE6_GBODE_CELL_CNTr_CLR
#define GE6_GBODE_CELL_CNTr_SET BCM56504_A0_GE6_GBODE_CELL_CNTr_SET
#define GE6_GBODE_CELL_CNTr_GET BCM56504_A0_GE6_GBODE_CELL_CNTr_GET
#define GE6_GBODE_CELL_CNTr_CELL_CNTf_GET BCM56504_A0_GE6_GBODE_CELL_CNTr_CELL_CNTf_GET
#define GE6_GBODE_CELL_CNTr_CELL_CNTf_SET BCM56504_A0_GE6_GBODE_CELL_CNTr_CELL_CNTf_SET
#define READ_GE6_GBODE_CELL_CNTr BCM56504_A0_READ_GE6_GBODE_CELL_CNTr
#define WRITE_GE6_GBODE_CELL_CNTr BCM56504_A0_WRITE_GE6_GBODE_CELL_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GE6_GBODE_CELL_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GE6_GBODE_CELL_REQ_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell request count register for GE6 
 * SIZE:     32
 * FIELDS:
 *     REQ_CNT          Number of cell request made to Egress Pipeline, MAX is 4.
 *
 ******************************************************************************/
#define BCM56504_A0_GE6_GBODE_CELL_REQ_CNTr 0x00f80022

#define BCM56504_A0_GE6_GBODE_CELL_REQ_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE6_GBODE_CELL_REQ_CNT.
 *
 */
typedef union BCM56504_A0_GE6_GBODE_CELL_REQ_CNTr_s {
	uint32_t v[1];
	uint32_t ge6_gbode_cell_req_cnt[1];
	uint32_t _ge6_gbode_cell_req_cnt;
} BCM56504_A0_GE6_GBODE_CELL_REQ_CNTr_t;

#define BCM56504_A0_GE6_GBODE_CELL_REQ_CNTr_CLR(r) (r).ge6_gbode_cell_req_cnt[0] = 0
#define BCM56504_A0_GE6_GBODE_CELL_REQ_CNTr_SET(r,d) (r).ge6_gbode_cell_req_cnt[0] = d
#define BCM56504_A0_GE6_GBODE_CELL_REQ_CNTr_GET(r) (r).ge6_gbode_cell_req_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_GE6_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET(r) (((r).ge6_gbode_cell_req_cnt[0]) & 0x7)
#define BCM56504_A0_GE6_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET(r,f) (r).ge6_gbode_cell_req_cnt[0]=(((r).ge6_gbode_cell_req_cnt[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))

/*
 * These macros can be used to access GE6_GBODE_CELL_REQ_CNT.
 *
 */
#define BCM56504_A0_READ_GE6_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE6_GBODE_CELL_REQ_CNTr,(r._ge6_gbode_cell_req_cnt))
#define BCM56504_A0_WRITE_GE6_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE6_GBODE_CELL_REQ_CNTr,&(r._ge6_gbode_cell_req_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE6_GBODE_CELL_REQ_CNTr BCM56504_A0_GE6_GBODE_CELL_REQ_CNTr
#define GE6_GBODE_CELL_REQ_CNTr_SIZE BCM56504_A0_GE6_GBODE_CELL_REQ_CNTr_SIZE
typedef BCM56504_A0_GE6_GBODE_CELL_REQ_CNTr_t GE6_GBODE_CELL_REQ_CNTr_t;
#define GE6_GBODE_CELL_REQ_CNTr_CLR BCM56504_A0_GE6_GBODE_CELL_REQ_CNTr_CLR
#define GE6_GBODE_CELL_REQ_CNTr_SET BCM56504_A0_GE6_GBODE_CELL_REQ_CNTr_SET
#define GE6_GBODE_CELL_REQ_CNTr_GET BCM56504_A0_GE6_GBODE_CELL_REQ_CNTr_GET
#define GE6_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET BCM56504_A0_GE6_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET
#define GE6_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET BCM56504_A0_GE6_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET
#define READ_GE6_GBODE_CELL_REQ_CNTr BCM56504_A0_READ_GE6_GBODE_CELL_REQ_CNTr
#define WRITE_GE6_GBODE_CELL_REQ_CNTr BCM56504_A0_WRITE_GE6_GBODE_CELL_REQ_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GE6_GBODE_CELL_REQ_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GE6_GBOD_OVRFLW
 * BLOCKS:   GPORT0
 * DESC:     GBOD RX fifo overflow for GE6 
 * SIZE:     32
 * FIELDS:
 *     OVRFLW           GBOD RX fifo overflow flag.
 *
 ******************************************************************************/
#define BCM56504_A0_GE6_GBOD_OVRFLWr 0x00f8000a

#define BCM56504_A0_GE6_GBOD_OVRFLWr_SIZE 4

/*
 * This structure should be used to declare and program GE6_GBOD_OVRFLW.
 *
 */
typedef union BCM56504_A0_GE6_GBOD_OVRFLWr_s {
	uint32_t v[1];
	uint32_t ge6_gbod_ovrflw[1];
	uint32_t _ge6_gbod_ovrflw;
} BCM56504_A0_GE6_GBOD_OVRFLWr_t;

#define BCM56504_A0_GE6_GBOD_OVRFLWr_CLR(r) (r).ge6_gbod_ovrflw[0] = 0
#define BCM56504_A0_GE6_GBOD_OVRFLWr_SET(r,d) (r).ge6_gbod_ovrflw[0] = d
#define BCM56504_A0_GE6_GBOD_OVRFLWr_GET(r) (r).ge6_gbod_ovrflw[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_GE6_GBOD_OVRFLWr_OVRFLWf_GET(r) (((r).ge6_gbod_ovrflw[0]) & 0x1)
#define BCM56504_A0_GE6_GBOD_OVRFLWr_OVRFLWf_SET(r,f) (r).ge6_gbod_ovrflw[0]=(((r).ge6_gbod_ovrflw[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access GE6_GBOD_OVRFLW.
 *
 */
#define BCM56504_A0_READ_GE6_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE6_GBOD_OVRFLWr,(r._ge6_gbod_ovrflw))
#define BCM56504_A0_WRITE_GE6_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE6_GBOD_OVRFLWr,&(r._ge6_gbod_ovrflw))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE6_GBOD_OVRFLWr BCM56504_A0_GE6_GBOD_OVRFLWr
#define GE6_GBOD_OVRFLWr_SIZE BCM56504_A0_GE6_GBOD_OVRFLWr_SIZE
typedef BCM56504_A0_GE6_GBOD_OVRFLWr_t GE6_GBOD_OVRFLWr_t;
#define GE6_GBOD_OVRFLWr_CLR BCM56504_A0_GE6_GBOD_OVRFLWr_CLR
#define GE6_GBOD_OVRFLWr_SET BCM56504_A0_GE6_GBOD_OVRFLWr_SET
#define GE6_GBOD_OVRFLWr_GET BCM56504_A0_GE6_GBOD_OVRFLWr_GET
#define GE6_GBOD_OVRFLWr_OVRFLWf_GET BCM56504_A0_GE6_GBOD_OVRFLWr_OVRFLWf_GET
#define GE6_GBOD_OVRFLWr_OVRFLWf_SET BCM56504_A0_GE6_GBOD_OVRFLWr_OVRFLWf_SET
#define READ_GE6_GBOD_OVRFLWr BCM56504_A0_READ_GE6_GBOD_OVRFLWr
#define WRITE_GE6_GBOD_OVRFLWr BCM56504_A0_WRITE_GE6_GBOD_OVRFLWr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GE6_GBOD_OVRFLWr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GE7_GBODE_CELL_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell count register for GE7 
 * SIZE:     32
 * FIELDS:
 *     CELL_CNT         Number of cell counts in GBODE tx fifo.
 *
 ******************************************************************************/
#define BCM56504_A0_GE7_GBODE_CELL_CNTr 0x00f80017

#define BCM56504_A0_GE7_GBODE_CELL_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE7_GBODE_CELL_CNT.
 *
 */
typedef union BCM56504_A0_GE7_GBODE_CELL_CNTr_s {
	uint32_t v[1];
	uint32_t ge7_gbode_cell_cnt[1];
	uint32_t _ge7_gbode_cell_cnt;
} BCM56504_A0_GE7_GBODE_CELL_CNTr_t;

#define BCM56504_A0_GE7_GBODE_CELL_CNTr_CLR(r) (r).ge7_gbode_cell_cnt[0] = 0
#define BCM56504_A0_GE7_GBODE_CELL_CNTr_SET(r,d) (r).ge7_gbode_cell_cnt[0] = d
#define BCM56504_A0_GE7_GBODE_CELL_CNTr_GET(r) (r).ge7_gbode_cell_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_GE7_GBODE_CELL_CNTr_CELL_CNTf_GET(r) (((r).ge7_gbode_cell_cnt[0]) & 0x7)
#define BCM56504_A0_GE7_GBODE_CELL_CNTr_CELL_CNTf_SET(r,f) (r).ge7_gbode_cell_cnt[0]=(((r).ge7_gbode_cell_cnt[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))

/*
 * These macros can be used to access GE7_GBODE_CELL_CNT.
 *
 */
#define BCM56504_A0_READ_GE7_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE7_GBODE_CELL_CNTr,(r._ge7_gbode_cell_cnt))
#define BCM56504_A0_WRITE_GE7_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE7_GBODE_CELL_CNTr,&(r._ge7_gbode_cell_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE7_GBODE_CELL_CNTr BCM56504_A0_GE7_GBODE_CELL_CNTr
#define GE7_GBODE_CELL_CNTr_SIZE BCM56504_A0_GE7_GBODE_CELL_CNTr_SIZE
typedef BCM56504_A0_GE7_GBODE_CELL_CNTr_t GE7_GBODE_CELL_CNTr_t;
#define GE7_GBODE_CELL_CNTr_CLR BCM56504_A0_GE7_GBODE_CELL_CNTr_CLR
#define GE7_GBODE_CELL_CNTr_SET BCM56504_A0_GE7_GBODE_CELL_CNTr_SET
#define GE7_GBODE_CELL_CNTr_GET BCM56504_A0_GE7_GBODE_CELL_CNTr_GET
#define GE7_GBODE_CELL_CNTr_CELL_CNTf_GET BCM56504_A0_GE7_GBODE_CELL_CNTr_CELL_CNTf_GET
#define GE7_GBODE_CELL_CNTr_CELL_CNTf_SET BCM56504_A0_GE7_GBODE_CELL_CNTr_CELL_CNTf_SET
#define READ_GE7_GBODE_CELL_CNTr BCM56504_A0_READ_GE7_GBODE_CELL_CNTr
#define WRITE_GE7_GBODE_CELL_CNTr BCM56504_A0_WRITE_GE7_GBODE_CELL_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GE7_GBODE_CELL_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GE7_GBODE_CELL_REQ_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell request count register for GE7 
 * SIZE:     32
 * FIELDS:
 *     REQ_CNT          Number of cell request made to Egress Pipeline, MAX is 4.
 *
 ******************************************************************************/
#define BCM56504_A0_GE7_GBODE_CELL_REQ_CNTr 0x00f80023

#define BCM56504_A0_GE7_GBODE_CELL_REQ_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE7_GBODE_CELL_REQ_CNT.
 *
 */
typedef union BCM56504_A0_GE7_GBODE_CELL_REQ_CNTr_s {
	uint32_t v[1];
	uint32_t ge7_gbode_cell_req_cnt[1];
	uint32_t _ge7_gbode_cell_req_cnt;
} BCM56504_A0_GE7_GBODE_CELL_REQ_CNTr_t;

#define BCM56504_A0_GE7_GBODE_CELL_REQ_CNTr_CLR(r) (r).ge7_gbode_cell_req_cnt[0] = 0
#define BCM56504_A0_GE7_GBODE_CELL_REQ_CNTr_SET(r,d) (r).ge7_gbode_cell_req_cnt[0] = d
#define BCM56504_A0_GE7_GBODE_CELL_REQ_CNTr_GET(r) (r).ge7_gbode_cell_req_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_GE7_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET(r) (((r).ge7_gbode_cell_req_cnt[0]) & 0x7)
#define BCM56504_A0_GE7_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET(r,f) (r).ge7_gbode_cell_req_cnt[0]=(((r).ge7_gbode_cell_req_cnt[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))

/*
 * These macros can be used to access GE7_GBODE_CELL_REQ_CNT.
 *
 */
#define BCM56504_A0_READ_GE7_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE7_GBODE_CELL_REQ_CNTr,(r._ge7_gbode_cell_req_cnt))
#define BCM56504_A0_WRITE_GE7_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE7_GBODE_CELL_REQ_CNTr,&(r._ge7_gbode_cell_req_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE7_GBODE_CELL_REQ_CNTr BCM56504_A0_GE7_GBODE_CELL_REQ_CNTr
#define GE7_GBODE_CELL_REQ_CNTr_SIZE BCM56504_A0_GE7_GBODE_CELL_REQ_CNTr_SIZE
typedef BCM56504_A0_GE7_GBODE_CELL_REQ_CNTr_t GE7_GBODE_CELL_REQ_CNTr_t;
#define GE7_GBODE_CELL_REQ_CNTr_CLR BCM56504_A0_GE7_GBODE_CELL_REQ_CNTr_CLR
#define GE7_GBODE_CELL_REQ_CNTr_SET BCM56504_A0_GE7_GBODE_CELL_REQ_CNTr_SET
#define GE7_GBODE_CELL_REQ_CNTr_GET BCM56504_A0_GE7_GBODE_CELL_REQ_CNTr_GET
#define GE7_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET BCM56504_A0_GE7_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET
#define GE7_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET BCM56504_A0_GE7_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET
#define READ_GE7_GBODE_CELL_REQ_CNTr BCM56504_A0_READ_GE7_GBODE_CELL_REQ_CNTr
#define WRITE_GE7_GBODE_CELL_REQ_CNTr BCM56504_A0_WRITE_GE7_GBODE_CELL_REQ_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GE7_GBODE_CELL_REQ_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GE7_GBOD_OVRFLW
 * BLOCKS:   GPORT0
 * DESC:     GBOD RX fifo overflow for GE7 
 * SIZE:     32
 * FIELDS:
 *     OVRFLW           GBOD RX fifo overflow flag.
 *
 ******************************************************************************/
#define BCM56504_A0_GE7_GBOD_OVRFLWr 0x00f8000b

#define BCM56504_A0_GE7_GBOD_OVRFLWr_SIZE 4

/*
 * This structure should be used to declare and program GE7_GBOD_OVRFLW.
 *
 */
typedef union BCM56504_A0_GE7_GBOD_OVRFLWr_s {
	uint32_t v[1];
	uint32_t ge7_gbod_ovrflw[1];
	uint32_t _ge7_gbod_ovrflw;
} BCM56504_A0_GE7_GBOD_OVRFLWr_t;

#define BCM56504_A0_GE7_GBOD_OVRFLWr_CLR(r) (r).ge7_gbod_ovrflw[0] = 0
#define BCM56504_A0_GE7_GBOD_OVRFLWr_SET(r,d) (r).ge7_gbod_ovrflw[0] = d
#define BCM56504_A0_GE7_GBOD_OVRFLWr_GET(r) (r).ge7_gbod_ovrflw[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_GE7_GBOD_OVRFLWr_OVRFLWf_GET(r) (((r).ge7_gbod_ovrflw[0]) & 0x1)
#define BCM56504_A0_GE7_GBOD_OVRFLWr_OVRFLWf_SET(r,f) (r).ge7_gbod_ovrflw[0]=(((r).ge7_gbod_ovrflw[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access GE7_GBOD_OVRFLW.
 *
 */
#define BCM56504_A0_READ_GE7_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE7_GBOD_OVRFLWr,(r._ge7_gbod_ovrflw))
#define BCM56504_A0_WRITE_GE7_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE7_GBOD_OVRFLWr,&(r._ge7_gbod_ovrflw))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE7_GBOD_OVRFLWr BCM56504_A0_GE7_GBOD_OVRFLWr
#define GE7_GBOD_OVRFLWr_SIZE BCM56504_A0_GE7_GBOD_OVRFLWr_SIZE
typedef BCM56504_A0_GE7_GBOD_OVRFLWr_t GE7_GBOD_OVRFLWr_t;
#define GE7_GBOD_OVRFLWr_CLR BCM56504_A0_GE7_GBOD_OVRFLWr_CLR
#define GE7_GBOD_OVRFLWr_SET BCM56504_A0_GE7_GBOD_OVRFLWr_SET
#define GE7_GBOD_OVRFLWr_GET BCM56504_A0_GE7_GBOD_OVRFLWr_GET
#define GE7_GBOD_OVRFLWr_OVRFLWf_GET BCM56504_A0_GE7_GBOD_OVRFLWr_OVRFLWf_GET
#define GE7_GBOD_OVRFLWr_OVRFLWf_SET BCM56504_A0_GE7_GBOD_OVRFLWr_OVRFLWf_SET
#define READ_GE7_GBOD_OVRFLWr BCM56504_A0_READ_GE7_GBOD_OVRFLWr
#define WRITE_GE7_GBOD_OVRFLWr BCM56504_A0_WRITE_GE7_GBOD_OVRFLWr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GE7_GBOD_OVRFLWr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GE8_GBODE_CELL_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell count register for GE8 
 * SIZE:     32
 * FIELDS:
 *     CELL_CNT         Number of cell counts in GBODE tx fifo.
 *
 ******************************************************************************/
#define BCM56504_A0_GE8_GBODE_CELL_CNTr 0x00f80018

#define BCM56504_A0_GE8_GBODE_CELL_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE8_GBODE_CELL_CNT.
 *
 */
typedef union BCM56504_A0_GE8_GBODE_CELL_CNTr_s {
	uint32_t v[1];
	uint32_t ge8_gbode_cell_cnt[1];
	uint32_t _ge8_gbode_cell_cnt;
} BCM56504_A0_GE8_GBODE_CELL_CNTr_t;

#define BCM56504_A0_GE8_GBODE_CELL_CNTr_CLR(r) (r).ge8_gbode_cell_cnt[0] = 0
#define BCM56504_A0_GE8_GBODE_CELL_CNTr_SET(r,d) (r).ge8_gbode_cell_cnt[0] = d
#define BCM56504_A0_GE8_GBODE_CELL_CNTr_GET(r) (r).ge8_gbode_cell_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_GE8_GBODE_CELL_CNTr_CELL_CNTf_GET(r) (((r).ge8_gbode_cell_cnt[0]) & 0x7)
#define BCM56504_A0_GE8_GBODE_CELL_CNTr_CELL_CNTf_SET(r,f) (r).ge8_gbode_cell_cnt[0]=(((r).ge8_gbode_cell_cnt[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))

/*
 * These macros can be used to access GE8_GBODE_CELL_CNT.
 *
 */
#define BCM56504_A0_READ_GE8_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE8_GBODE_CELL_CNTr,(r._ge8_gbode_cell_cnt))
#define BCM56504_A0_WRITE_GE8_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE8_GBODE_CELL_CNTr,&(r._ge8_gbode_cell_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE8_GBODE_CELL_CNTr BCM56504_A0_GE8_GBODE_CELL_CNTr
#define GE8_GBODE_CELL_CNTr_SIZE BCM56504_A0_GE8_GBODE_CELL_CNTr_SIZE
typedef BCM56504_A0_GE8_GBODE_CELL_CNTr_t GE8_GBODE_CELL_CNTr_t;
#define GE8_GBODE_CELL_CNTr_CLR BCM56504_A0_GE8_GBODE_CELL_CNTr_CLR
#define GE8_GBODE_CELL_CNTr_SET BCM56504_A0_GE8_GBODE_CELL_CNTr_SET
#define GE8_GBODE_CELL_CNTr_GET BCM56504_A0_GE8_GBODE_CELL_CNTr_GET
#define GE8_GBODE_CELL_CNTr_CELL_CNTf_GET BCM56504_A0_GE8_GBODE_CELL_CNTr_CELL_CNTf_GET
#define GE8_GBODE_CELL_CNTr_CELL_CNTf_SET BCM56504_A0_GE8_GBODE_CELL_CNTr_CELL_CNTf_SET
#define READ_GE8_GBODE_CELL_CNTr BCM56504_A0_READ_GE8_GBODE_CELL_CNTr
#define WRITE_GE8_GBODE_CELL_CNTr BCM56504_A0_WRITE_GE8_GBODE_CELL_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GE8_GBODE_CELL_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GE8_GBODE_CELL_REQ_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell request count register for GE8 
 * SIZE:     32
 * FIELDS:
 *     REQ_CNT          Number of cell request made to Egress Pipeline, MAX is 4.
 *
 ******************************************************************************/
#define BCM56504_A0_GE8_GBODE_CELL_REQ_CNTr 0x00f80024

#define BCM56504_A0_GE8_GBODE_CELL_REQ_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE8_GBODE_CELL_REQ_CNT.
 *
 */
typedef union BCM56504_A0_GE8_GBODE_CELL_REQ_CNTr_s {
	uint32_t v[1];
	uint32_t ge8_gbode_cell_req_cnt[1];
	uint32_t _ge8_gbode_cell_req_cnt;
} BCM56504_A0_GE8_GBODE_CELL_REQ_CNTr_t;

#define BCM56504_A0_GE8_GBODE_CELL_REQ_CNTr_CLR(r) (r).ge8_gbode_cell_req_cnt[0] = 0
#define BCM56504_A0_GE8_GBODE_CELL_REQ_CNTr_SET(r,d) (r).ge8_gbode_cell_req_cnt[0] = d
#define BCM56504_A0_GE8_GBODE_CELL_REQ_CNTr_GET(r) (r).ge8_gbode_cell_req_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_GE8_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET(r) (((r).ge8_gbode_cell_req_cnt[0]) & 0x7)
#define BCM56504_A0_GE8_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET(r,f) (r).ge8_gbode_cell_req_cnt[0]=(((r).ge8_gbode_cell_req_cnt[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))

/*
 * These macros can be used to access GE8_GBODE_CELL_REQ_CNT.
 *
 */
#define BCM56504_A0_READ_GE8_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE8_GBODE_CELL_REQ_CNTr,(r._ge8_gbode_cell_req_cnt))
#define BCM56504_A0_WRITE_GE8_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE8_GBODE_CELL_REQ_CNTr,&(r._ge8_gbode_cell_req_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE8_GBODE_CELL_REQ_CNTr BCM56504_A0_GE8_GBODE_CELL_REQ_CNTr
#define GE8_GBODE_CELL_REQ_CNTr_SIZE BCM56504_A0_GE8_GBODE_CELL_REQ_CNTr_SIZE
typedef BCM56504_A0_GE8_GBODE_CELL_REQ_CNTr_t GE8_GBODE_CELL_REQ_CNTr_t;
#define GE8_GBODE_CELL_REQ_CNTr_CLR BCM56504_A0_GE8_GBODE_CELL_REQ_CNTr_CLR
#define GE8_GBODE_CELL_REQ_CNTr_SET BCM56504_A0_GE8_GBODE_CELL_REQ_CNTr_SET
#define GE8_GBODE_CELL_REQ_CNTr_GET BCM56504_A0_GE8_GBODE_CELL_REQ_CNTr_GET
#define GE8_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET BCM56504_A0_GE8_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET
#define GE8_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET BCM56504_A0_GE8_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET
#define READ_GE8_GBODE_CELL_REQ_CNTr BCM56504_A0_READ_GE8_GBODE_CELL_REQ_CNTr
#define WRITE_GE8_GBODE_CELL_REQ_CNTr BCM56504_A0_WRITE_GE8_GBODE_CELL_REQ_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GE8_GBODE_CELL_REQ_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GE8_GBOD_OVRFLW
 * BLOCKS:   GPORT0
 * DESC:     GBOD RX fifo overflow for GE8 
 * SIZE:     32
 * FIELDS:
 *     OVRFLW           GBOD RX fifo overflow flag.
 *
 ******************************************************************************/
#define BCM56504_A0_GE8_GBOD_OVRFLWr 0x00f8000c

#define BCM56504_A0_GE8_GBOD_OVRFLWr_SIZE 4

/*
 * This structure should be used to declare and program GE8_GBOD_OVRFLW.
 *
 */
typedef union BCM56504_A0_GE8_GBOD_OVRFLWr_s {
	uint32_t v[1];
	uint32_t ge8_gbod_ovrflw[1];
	uint32_t _ge8_gbod_ovrflw;
} BCM56504_A0_GE8_GBOD_OVRFLWr_t;

#define BCM56504_A0_GE8_GBOD_OVRFLWr_CLR(r) (r).ge8_gbod_ovrflw[0] = 0
#define BCM56504_A0_GE8_GBOD_OVRFLWr_SET(r,d) (r).ge8_gbod_ovrflw[0] = d
#define BCM56504_A0_GE8_GBOD_OVRFLWr_GET(r) (r).ge8_gbod_ovrflw[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_GE8_GBOD_OVRFLWr_OVRFLWf_GET(r) (((r).ge8_gbod_ovrflw[0]) & 0x1)
#define BCM56504_A0_GE8_GBOD_OVRFLWr_OVRFLWf_SET(r,f) (r).ge8_gbod_ovrflw[0]=(((r).ge8_gbod_ovrflw[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access GE8_GBOD_OVRFLW.
 *
 */
#define BCM56504_A0_READ_GE8_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE8_GBOD_OVRFLWr,(r._ge8_gbod_ovrflw))
#define BCM56504_A0_WRITE_GE8_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE8_GBOD_OVRFLWr,&(r._ge8_gbod_ovrflw))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE8_GBOD_OVRFLWr BCM56504_A0_GE8_GBOD_OVRFLWr
#define GE8_GBOD_OVRFLWr_SIZE BCM56504_A0_GE8_GBOD_OVRFLWr_SIZE
typedef BCM56504_A0_GE8_GBOD_OVRFLWr_t GE8_GBOD_OVRFLWr_t;
#define GE8_GBOD_OVRFLWr_CLR BCM56504_A0_GE8_GBOD_OVRFLWr_CLR
#define GE8_GBOD_OVRFLWr_SET BCM56504_A0_GE8_GBOD_OVRFLWr_SET
#define GE8_GBOD_OVRFLWr_GET BCM56504_A0_GE8_GBOD_OVRFLWr_GET
#define GE8_GBOD_OVRFLWr_OVRFLWf_GET BCM56504_A0_GE8_GBOD_OVRFLWr_OVRFLWf_GET
#define GE8_GBOD_OVRFLWr_OVRFLWf_SET BCM56504_A0_GE8_GBOD_OVRFLWr_OVRFLWf_SET
#define READ_GE8_GBOD_OVRFLWr BCM56504_A0_READ_GE8_GBOD_OVRFLWr
#define WRITE_GE8_GBOD_OVRFLWr BCM56504_A0_WRITE_GE8_GBOD_OVRFLWr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GE8_GBOD_OVRFLWr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GE9_GBODE_CELL_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell count register for GE9 
 * SIZE:     32
 * FIELDS:
 *     CELL_CNT         Number of cell counts in GBODE tx fifo.
 *
 ******************************************************************************/
#define BCM56504_A0_GE9_GBODE_CELL_CNTr 0x00f80019

#define BCM56504_A0_GE9_GBODE_CELL_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE9_GBODE_CELL_CNT.
 *
 */
typedef union BCM56504_A0_GE9_GBODE_CELL_CNTr_s {
	uint32_t v[1];
	uint32_t ge9_gbode_cell_cnt[1];
	uint32_t _ge9_gbode_cell_cnt;
} BCM56504_A0_GE9_GBODE_CELL_CNTr_t;

#define BCM56504_A0_GE9_GBODE_CELL_CNTr_CLR(r) (r).ge9_gbode_cell_cnt[0] = 0
#define BCM56504_A0_GE9_GBODE_CELL_CNTr_SET(r,d) (r).ge9_gbode_cell_cnt[0] = d
#define BCM56504_A0_GE9_GBODE_CELL_CNTr_GET(r) (r).ge9_gbode_cell_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_GE9_GBODE_CELL_CNTr_CELL_CNTf_GET(r) (((r).ge9_gbode_cell_cnt[0]) & 0x7)
#define BCM56504_A0_GE9_GBODE_CELL_CNTr_CELL_CNTf_SET(r,f) (r).ge9_gbode_cell_cnt[0]=(((r).ge9_gbode_cell_cnt[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))

/*
 * These macros can be used to access GE9_GBODE_CELL_CNT.
 *
 */
#define BCM56504_A0_READ_GE9_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE9_GBODE_CELL_CNTr,(r._ge9_gbode_cell_cnt))
#define BCM56504_A0_WRITE_GE9_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE9_GBODE_CELL_CNTr,&(r._ge9_gbode_cell_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE9_GBODE_CELL_CNTr BCM56504_A0_GE9_GBODE_CELL_CNTr
#define GE9_GBODE_CELL_CNTr_SIZE BCM56504_A0_GE9_GBODE_CELL_CNTr_SIZE
typedef BCM56504_A0_GE9_GBODE_CELL_CNTr_t GE9_GBODE_CELL_CNTr_t;
#define GE9_GBODE_CELL_CNTr_CLR BCM56504_A0_GE9_GBODE_CELL_CNTr_CLR
#define GE9_GBODE_CELL_CNTr_SET BCM56504_A0_GE9_GBODE_CELL_CNTr_SET
#define GE9_GBODE_CELL_CNTr_GET BCM56504_A0_GE9_GBODE_CELL_CNTr_GET
#define GE9_GBODE_CELL_CNTr_CELL_CNTf_GET BCM56504_A0_GE9_GBODE_CELL_CNTr_CELL_CNTf_GET
#define GE9_GBODE_CELL_CNTr_CELL_CNTf_SET BCM56504_A0_GE9_GBODE_CELL_CNTr_CELL_CNTf_SET
#define READ_GE9_GBODE_CELL_CNTr BCM56504_A0_READ_GE9_GBODE_CELL_CNTr
#define WRITE_GE9_GBODE_CELL_CNTr BCM56504_A0_WRITE_GE9_GBODE_CELL_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GE9_GBODE_CELL_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GE9_GBODE_CELL_REQ_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell request count register for GE9 
 * SIZE:     32
 * FIELDS:
 *     REQ_CNT          Number of cell request made to Egress Pipeline, MAX is 4.
 *
 ******************************************************************************/
#define BCM56504_A0_GE9_GBODE_CELL_REQ_CNTr 0x00f80025

#define BCM56504_A0_GE9_GBODE_CELL_REQ_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE9_GBODE_CELL_REQ_CNT.
 *
 */
typedef union BCM56504_A0_GE9_GBODE_CELL_REQ_CNTr_s {
	uint32_t v[1];
	uint32_t ge9_gbode_cell_req_cnt[1];
	uint32_t _ge9_gbode_cell_req_cnt;
} BCM56504_A0_GE9_GBODE_CELL_REQ_CNTr_t;

#define BCM56504_A0_GE9_GBODE_CELL_REQ_CNTr_CLR(r) (r).ge9_gbode_cell_req_cnt[0] = 0
#define BCM56504_A0_GE9_GBODE_CELL_REQ_CNTr_SET(r,d) (r).ge9_gbode_cell_req_cnt[0] = d
#define BCM56504_A0_GE9_GBODE_CELL_REQ_CNTr_GET(r) (r).ge9_gbode_cell_req_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_GE9_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET(r) (((r).ge9_gbode_cell_req_cnt[0]) & 0x7)
#define BCM56504_A0_GE9_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET(r,f) (r).ge9_gbode_cell_req_cnt[0]=(((r).ge9_gbode_cell_req_cnt[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))

/*
 * These macros can be used to access GE9_GBODE_CELL_REQ_CNT.
 *
 */
#define BCM56504_A0_READ_GE9_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE9_GBODE_CELL_REQ_CNTr,(r._ge9_gbode_cell_req_cnt))
#define BCM56504_A0_WRITE_GE9_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE9_GBODE_CELL_REQ_CNTr,&(r._ge9_gbode_cell_req_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE9_GBODE_CELL_REQ_CNTr BCM56504_A0_GE9_GBODE_CELL_REQ_CNTr
#define GE9_GBODE_CELL_REQ_CNTr_SIZE BCM56504_A0_GE9_GBODE_CELL_REQ_CNTr_SIZE
typedef BCM56504_A0_GE9_GBODE_CELL_REQ_CNTr_t GE9_GBODE_CELL_REQ_CNTr_t;
#define GE9_GBODE_CELL_REQ_CNTr_CLR BCM56504_A0_GE9_GBODE_CELL_REQ_CNTr_CLR
#define GE9_GBODE_CELL_REQ_CNTr_SET BCM56504_A0_GE9_GBODE_CELL_REQ_CNTr_SET
#define GE9_GBODE_CELL_REQ_CNTr_GET BCM56504_A0_GE9_GBODE_CELL_REQ_CNTr_GET
#define GE9_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET BCM56504_A0_GE9_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET
#define GE9_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET BCM56504_A0_GE9_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET
#define READ_GE9_GBODE_CELL_REQ_CNTr BCM56504_A0_READ_GE9_GBODE_CELL_REQ_CNTr
#define WRITE_GE9_GBODE_CELL_REQ_CNTr BCM56504_A0_WRITE_GE9_GBODE_CELL_REQ_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GE9_GBODE_CELL_REQ_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GE9_GBOD_OVRFLW
 * BLOCKS:   GPORT0
 * DESC:     GBOD RX fifo overflow for GE9 
 * SIZE:     32
 * FIELDS:
 *     OVRFLW           GBOD RX fifo overflow flag.
 *
 ******************************************************************************/
#define BCM56504_A0_GE9_GBOD_OVRFLWr 0x00f8000d

#define BCM56504_A0_GE9_GBOD_OVRFLWr_SIZE 4

/*
 * This structure should be used to declare and program GE9_GBOD_OVRFLW.
 *
 */
typedef union BCM56504_A0_GE9_GBOD_OVRFLWr_s {
	uint32_t v[1];
	uint32_t ge9_gbod_ovrflw[1];
	uint32_t _ge9_gbod_ovrflw;
} BCM56504_A0_GE9_GBOD_OVRFLWr_t;

#define BCM56504_A0_GE9_GBOD_OVRFLWr_CLR(r) (r).ge9_gbod_ovrflw[0] = 0
#define BCM56504_A0_GE9_GBOD_OVRFLWr_SET(r,d) (r).ge9_gbod_ovrflw[0] = d
#define BCM56504_A0_GE9_GBOD_OVRFLWr_GET(r) (r).ge9_gbod_ovrflw[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_GE9_GBOD_OVRFLWr_OVRFLWf_GET(r) (((r).ge9_gbod_ovrflw[0]) & 0x1)
#define BCM56504_A0_GE9_GBOD_OVRFLWr_OVRFLWf_SET(r,f) (r).ge9_gbod_ovrflw[0]=(((r).ge9_gbod_ovrflw[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access GE9_GBOD_OVRFLW.
 *
 */
#define BCM56504_A0_READ_GE9_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE9_GBOD_OVRFLWr,(r._ge9_gbod_ovrflw))
#define BCM56504_A0_WRITE_GE9_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GE9_GBOD_OVRFLWr,&(r._ge9_gbod_ovrflw))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE9_GBOD_OVRFLWr BCM56504_A0_GE9_GBOD_OVRFLWr
#define GE9_GBOD_OVRFLWr_SIZE BCM56504_A0_GE9_GBOD_OVRFLWr_SIZE
typedef BCM56504_A0_GE9_GBOD_OVRFLWr_t GE9_GBOD_OVRFLWr_t;
#define GE9_GBOD_OVRFLWr_CLR BCM56504_A0_GE9_GBOD_OVRFLWr_CLR
#define GE9_GBOD_OVRFLWr_SET BCM56504_A0_GE9_GBOD_OVRFLWr_SET
#define GE9_GBOD_OVRFLWr_GET BCM56504_A0_GE9_GBOD_OVRFLWr_GET
#define GE9_GBOD_OVRFLWr_OVRFLWf_GET BCM56504_A0_GE9_GBOD_OVRFLWr_OVRFLWf_GET
#define GE9_GBOD_OVRFLWr_OVRFLWf_SET BCM56504_A0_GE9_GBOD_OVRFLWr_OVRFLWf_SET
#define READ_GE9_GBOD_OVRFLWr BCM56504_A0_READ_GE9_GBOD_OVRFLWr
#define WRITE_GE9_GBOD_OVRFLWr BCM56504_A0_WRITE_GE9_GBOD_OVRFLWr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GE9_GBOD_OVRFLWr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GE_EGR_PKT_DROP_CTL
 * BLOCKS:   GPORT0
 * DESC:     Flush enable control for each egress port of GPORT
 * SIZE:     32
 * FIELDS:
 *     FLUSH            Flush enable bit to drop the packets within GPORT for each GE port
 *
 ******************************************************************************/
#define BCM56504_A0_GE_EGR_PKT_DROP_CTLr 0x00f00301

#define BCM56504_A0_GE_EGR_PKT_DROP_CTLr_SIZE 4

/*
 * This structure should be used to declare and program GE_EGR_PKT_DROP_CTL.
 *
 */
typedef union BCM56504_A0_GE_EGR_PKT_DROP_CTLr_s {
	uint32_t v[1];
	uint32_t ge_egr_pkt_drop_ctl[1];
	uint32_t _ge_egr_pkt_drop_ctl;
} BCM56504_A0_GE_EGR_PKT_DROP_CTLr_t;

#define BCM56504_A0_GE_EGR_PKT_DROP_CTLr_CLR(r) (r).ge_egr_pkt_drop_ctl[0] = 0
#define BCM56504_A0_GE_EGR_PKT_DROP_CTLr_SET(r,d) (r).ge_egr_pkt_drop_ctl[0] = d
#define BCM56504_A0_GE_EGR_PKT_DROP_CTLr_GET(r) (r).ge_egr_pkt_drop_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_GE_EGR_PKT_DROP_CTLr_FLUSHf_GET(r) (((r).ge_egr_pkt_drop_ctl[0]) & 0x1)
#define BCM56504_A0_GE_EGR_PKT_DROP_CTLr_FLUSHf_SET(r,f) (r).ge_egr_pkt_drop_ctl[0]=(((r).ge_egr_pkt_drop_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access GE_EGR_PKT_DROP_CTL.
 *
 */
#define BCM56504_A0_READ_GE_EGR_PKT_DROP_CTLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_GE_EGR_PKT_DROP_CTLr,(r._ge_egr_pkt_drop_ctl))
#define BCM56504_A0_WRITE_GE_EGR_PKT_DROP_CTLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_GE_EGR_PKT_DROP_CTLr,&(r._ge_egr_pkt_drop_ctl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE_EGR_PKT_DROP_CTLr BCM56504_A0_GE_EGR_PKT_DROP_CTLr
#define GE_EGR_PKT_DROP_CTLr_SIZE BCM56504_A0_GE_EGR_PKT_DROP_CTLr_SIZE
typedef BCM56504_A0_GE_EGR_PKT_DROP_CTLr_t GE_EGR_PKT_DROP_CTLr_t;
#define GE_EGR_PKT_DROP_CTLr_CLR BCM56504_A0_GE_EGR_PKT_DROP_CTLr_CLR
#define GE_EGR_PKT_DROP_CTLr_SET BCM56504_A0_GE_EGR_PKT_DROP_CTLr_SET
#define GE_EGR_PKT_DROP_CTLr_GET BCM56504_A0_GE_EGR_PKT_DROP_CTLr_GET
#define GE_EGR_PKT_DROP_CTLr_FLUSHf_GET BCM56504_A0_GE_EGR_PKT_DROP_CTLr_FLUSHf_GET
#define GE_EGR_PKT_DROP_CTLr_FLUSHf_SET BCM56504_A0_GE_EGR_PKT_DROP_CTLr_FLUSHf_SET
#define READ_GE_EGR_PKT_DROP_CTLr BCM56504_A0_READ_GE_EGR_PKT_DROP_CTLr
#define WRITE_GE_EGR_PKT_DROP_CTLr BCM56504_A0_WRITE_GE_EGR_PKT_DROP_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GE_EGR_PKT_DROP_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GE_PORT_CONFIG
 * BLOCKS:   GPORT0
 * DESC:     GE port configuration
 * SIZE:     32
 * FIELDS:
 *     JAM_EN           Enable Jamming
 *     SPEED_SELECT     00=Gig, 01=100Mbps, 10=10Mbps, 11=N/A
 *     MAC_CRS_SEL      When set, connect the carrier sense (CRS) from external PHY. Default is from internal Serdes output.
 *     SGN_DET_SEL      When set, connect signal detect from external Fiber module.
 *     CLK_OUT_EN       When set, enable the clock output to SERDES.
 *
 ******************************************************************************/
#define BCM56504_A0_GE_PORT_CONFIGr 0x00f00300

#define BCM56504_A0_GE_PORT_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program GE_PORT_CONFIG.
 *
 */
typedef union BCM56504_A0_GE_PORT_CONFIGr_s {
	uint32_t v[1];
	uint32_t ge_port_config[1];
	uint32_t _ge_port_config;
} BCM56504_A0_GE_PORT_CONFIGr_t;

#define BCM56504_A0_GE_PORT_CONFIGr_CLR(r) (r).ge_port_config[0] = 0
#define BCM56504_A0_GE_PORT_CONFIGr_SET(r,d) (r).ge_port_config[0] = d
#define BCM56504_A0_GE_PORT_CONFIGr_GET(r) (r).ge_port_config[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_GE_PORT_CONFIGr_JAM_ENf_GET(r) (((r).ge_port_config[0]) & 0x1)
#define BCM56504_A0_GE_PORT_CONFIGr_JAM_ENf_SET(r,f) (r).ge_port_config[0]=(((r).ge_port_config[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_GE_PORT_CONFIGr_SPEED_SELECTf_GET(r) ((((r).ge_port_config[0]) >> 1) & 0x3)
#define BCM56504_A0_GE_PORT_CONFIGr_SPEED_SELECTf_SET(r,f) (r).ge_port_config[0]=(((r).ge_port_config[0] & ~((uint32_t)0x3 << 1)) | ((((uint32_t)f) & 0x3) << 1))
#define BCM56504_A0_GE_PORT_CONFIGr_MAC_CRS_SELf_GET(r) ((((r).ge_port_config[0]) >> 3) & 0x1)
#define BCM56504_A0_GE_PORT_CONFIGr_MAC_CRS_SELf_SET(r,f) (r).ge_port_config[0]=(((r).ge_port_config[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_GE_PORT_CONFIGr_SGN_DET_SELf_GET(r) ((((r).ge_port_config[0]) >> 4) & 0x1)
#define BCM56504_A0_GE_PORT_CONFIGr_SGN_DET_SELf_SET(r,f) (r).ge_port_config[0]=(((r).ge_port_config[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56504_A0_GE_PORT_CONFIGr_CLK_OUT_ENf_GET(r) ((((r).ge_port_config[0]) >> 5) & 0x1)
#define BCM56504_A0_GE_PORT_CONFIGr_CLK_OUT_ENf_SET(r,f) (r).ge_port_config[0]=(((r).ge_port_config[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))

/*
 * These macros can be used to access GE_PORT_CONFIG.
 *
 */
#define BCM56504_A0_READ_GE_PORT_CONFIGr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_GE_PORT_CONFIGr,(r._ge_port_config))
#define BCM56504_A0_WRITE_GE_PORT_CONFIGr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_GE_PORT_CONFIGr,&(r._ge_port_config))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE_PORT_CONFIGr BCM56504_A0_GE_PORT_CONFIGr
#define GE_PORT_CONFIGr_SIZE BCM56504_A0_GE_PORT_CONFIGr_SIZE
typedef BCM56504_A0_GE_PORT_CONFIGr_t GE_PORT_CONFIGr_t;
#define GE_PORT_CONFIGr_CLR BCM56504_A0_GE_PORT_CONFIGr_CLR
#define GE_PORT_CONFIGr_SET BCM56504_A0_GE_PORT_CONFIGr_SET
#define GE_PORT_CONFIGr_GET BCM56504_A0_GE_PORT_CONFIGr_GET
#define GE_PORT_CONFIGr_JAM_ENf_GET BCM56504_A0_GE_PORT_CONFIGr_JAM_ENf_GET
#define GE_PORT_CONFIGr_JAM_ENf_SET BCM56504_A0_GE_PORT_CONFIGr_JAM_ENf_SET
#define GE_PORT_CONFIGr_SPEED_SELECTf_GET BCM56504_A0_GE_PORT_CONFIGr_SPEED_SELECTf_GET
#define GE_PORT_CONFIGr_SPEED_SELECTf_SET BCM56504_A0_GE_PORT_CONFIGr_SPEED_SELECTf_SET
#define GE_PORT_CONFIGr_MAC_CRS_SELf_GET BCM56504_A0_GE_PORT_CONFIGr_MAC_CRS_SELf_GET
#define GE_PORT_CONFIGr_MAC_CRS_SELf_SET BCM56504_A0_GE_PORT_CONFIGr_MAC_CRS_SELf_SET
#define GE_PORT_CONFIGr_SGN_DET_SELf_GET BCM56504_A0_GE_PORT_CONFIGr_SGN_DET_SELf_GET
#define GE_PORT_CONFIGr_SGN_DET_SELf_SET BCM56504_A0_GE_PORT_CONFIGr_SGN_DET_SELf_SET
#define GE_PORT_CONFIGr_CLK_OUT_ENf_GET BCM56504_A0_GE_PORT_CONFIGr_CLK_OUT_ENf_GET
#define GE_PORT_CONFIGr_CLK_OUT_ENf_SET BCM56504_A0_GE_PORT_CONFIGr_CLK_OUT_ENf_SET
#define READ_GE_PORT_CONFIGr BCM56504_A0_READ_GE_PORT_CONFIGr
#define WRITE_GE_PORT_CONFIGr BCM56504_A0_WRITE_GE_PORT_CONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GE_PORT_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GMACC0
 * BLOCKS:   GPORT0
 * DESC:     GIG Port Control Reg 0
 * SIZE:     32
 * FIELDS:
 *     TMDS             Test mode select
 *     L32B             Loopback 32B Data
 *     L10B             Loopback 10B Symbols
 *     SRST             Soft Reset
 *
 ******************************************************************************/
#define BCM56504_A0_GMACC0r 0x00f00100

#define BCM56504_A0_GMACC0r_SIZE 4

/*
 * This structure should be used to declare and program GMACC0.
 *
 */
typedef union BCM56504_A0_GMACC0r_s {
	uint32_t v[1];
	uint32_t gmacc0[1];
	uint32_t _gmacc0;
} BCM56504_A0_GMACC0r_t;

#define BCM56504_A0_GMACC0r_CLR(r) (r).gmacc0[0] = 0
#define BCM56504_A0_GMACC0r_SET(r,d) (r).gmacc0[0] = d
#define BCM56504_A0_GMACC0r_GET(r) (r).gmacc0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_GMACC0r_TMDSf_GET(r) (((r).gmacc0[0]) & 0xff)
#define BCM56504_A0_GMACC0r_TMDSf_SET(r,f) (r).gmacc0[0]=(((r).gmacc0[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56504_A0_GMACC0r_L32Bf_GET(r) ((((r).gmacc0[0]) >> 8) & 0x1)
#define BCM56504_A0_GMACC0r_L32Bf_SET(r,f) (r).gmacc0[0]=(((r).gmacc0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56504_A0_GMACC0r_L10Bf_GET(r) ((((r).gmacc0[0]) >> 9) & 0x1)
#define BCM56504_A0_GMACC0r_L10Bf_SET(r,f) (r).gmacc0[0]=(((r).gmacc0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56504_A0_GMACC0r_SRSTf_GET(r) ((((r).gmacc0[0]) >> 31) & 0x1)
#define BCM56504_A0_GMACC0r_SRSTf_SET(r,f) (r).gmacc0[0]=(((r).gmacc0[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access GMACC0.
 *
 */
#define BCM56504_A0_READ_GMACC0r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_GMACC0r,(r._gmacc0))
#define BCM56504_A0_WRITE_GMACC0r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_GMACC0r,&(r._gmacc0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GMACC0r BCM56504_A0_GMACC0r
#define GMACC0r_SIZE BCM56504_A0_GMACC0r_SIZE
typedef BCM56504_A0_GMACC0r_t GMACC0r_t;
#define GMACC0r_CLR BCM56504_A0_GMACC0r_CLR
#define GMACC0r_SET BCM56504_A0_GMACC0r_SET
#define GMACC0r_GET BCM56504_A0_GMACC0r_GET
#define GMACC0r_TMDSf_GET BCM56504_A0_GMACC0r_TMDSf_GET
#define GMACC0r_TMDSf_SET BCM56504_A0_GMACC0r_TMDSf_SET
#define GMACC0r_L32Bf_GET BCM56504_A0_GMACC0r_L32Bf_GET
#define GMACC0r_L32Bf_SET BCM56504_A0_GMACC0r_L32Bf_SET
#define GMACC0r_L10Bf_GET BCM56504_A0_GMACC0r_L10Bf_GET
#define GMACC0r_L10Bf_SET BCM56504_A0_GMACC0r_L10Bf_SET
#define GMACC0r_SRSTf_GET BCM56504_A0_GMACC0r_SRSTf_GET
#define GMACC0r_SRSTf_SET BCM56504_A0_GMACC0r_SRSTf_SET
#define READ_GMACC0r BCM56504_A0_READ_GMACC0r
#define WRITE_GMACC0r BCM56504_A0_WRITE_GMACC0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GMACC0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GMACC1
 * BLOCKS:   GPORT0
 * DESC:     GIG Port Control Reg 1
 * SIZE:     32
 * FIELDS:
 *     FULLD            Full-Duplex (Tied to 1)
 *     PADEN            Pad Enable
 *     VLPAD            VLAN Pad
 *     ADPAD            Auto Detect Pad
 *     CRCEN            CRC Enable
 *     FLCHK            Frame Length Check
 *     HUGEN            Huge Frame Enable
 *     JUMBO            JUMBO Frame Enable
 *     PUREP            Pure Preamble
 *     FCTX             Flow Control: Transmit Capable
 *     FCRX             Flow Control: Receive Capable
 *     PARF             Pass All Receive Frames
 *     LONGP            Accept Preambles over 11 bytes
 *     MIFG             Minimum IFG
 *     GLVR             Gulliver
 *     DCRC12           Delayed CRC = 12 bytes
 *     RXEN0            Receive Enable
 *     TXEN0            Transmit Enable
 *
 ******************************************************************************/
#define BCM56504_A0_GMACC1r 0x00f00101

#define BCM56504_A0_GMACC1r_SIZE 4

/*
 * This structure should be used to declare and program GMACC1.
 *
 */
typedef union BCM56504_A0_GMACC1r_s {
	uint32_t v[1];
	uint32_t gmacc1[1];
	uint32_t _gmacc1;
} BCM56504_A0_GMACC1r_t;

#define BCM56504_A0_GMACC1r_CLR(r) (r).gmacc1[0] = 0
#define BCM56504_A0_GMACC1r_SET(r,d) (r).gmacc1[0] = d
#define BCM56504_A0_GMACC1r_GET(r) (r).gmacc1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_GMACC1r_FULLDf_GET(r) (((r).gmacc1[0]) & 0x1)
#define BCM56504_A0_GMACC1r_FULLDf_SET(r,f) (r).gmacc1[0]=(((r).gmacc1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_GMACC1r_PADENf_GET(r) ((((r).gmacc1[0]) >> 1) & 0x1)
#define BCM56504_A0_GMACC1r_PADENf_SET(r,f) (r).gmacc1[0]=(((r).gmacc1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_GMACC1r_VLPADf_GET(r) ((((r).gmacc1[0]) >> 2) & 0x1)
#define BCM56504_A0_GMACC1r_VLPADf_SET(r,f) (r).gmacc1[0]=(((r).gmacc1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_GMACC1r_ADPADf_GET(r) ((((r).gmacc1[0]) >> 3) & 0x1)
#define BCM56504_A0_GMACC1r_ADPADf_SET(r,f) (r).gmacc1[0]=(((r).gmacc1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_GMACC1r_CRCENf_GET(r) ((((r).gmacc1[0]) >> 4) & 0x1)
#define BCM56504_A0_GMACC1r_CRCENf_SET(r,f) (r).gmacc1[0]=(((r).gmacc1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56504_A0_GMACC1r_FLCHKf_GET(r) ((((r).gmacc1[0]) >> 5) & 0x1)
#define BCM56504_A0_GMACC1r_FLCHKf_SET(r,f) (r).gmacc1[0]=(((r).gmacc1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56504_A0_GMACC1r_HUGENf_GET(r) ((((r).gmacc1[0]) >> 6) & 0x1)
#define BCM56504_A0_GMACC1r_HUGENf_SET(r,f) (r).gmacc1[0]=(((r).gmacc1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56504_A0_GMACC1r_JUMBOf_GET(r) ((((r).gmacc1[0]) >> 7) & 0x1)
#define BCM56504_A0_GMACC1r_JUMBOf_SET(r,f) (r).gmacc1[0]=(((r).gmacc1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56504_A0_GMACC1r_PUREPf_GET(r) ((((r).gmacc1[0]) >> 8) & 0x1)
#define BCM56504_A0_GMACC1r_PUREPf_SET(r,f) (r).gmacc1[0]=(((r).gmacc1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56504_A0_GMACC1r_FCTXf_GET(r) ((((r).gmacc1[0]) >> 9) & 0x1)
#define BCM56504_A0_GMACC1r_FCTXf_SET(r,f) (r).gmacc1[0]=(((r).gmacc1[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56504_A0_GMACC1r_FCRXf_GET(r) ((((r).gmacc1[0]) >> 10) & 0x1)
#define BCM56504_A0_GMACC1r_FCRXf_SET(r,f) (r).gmacc1[0]=(((r).gmacc1[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56504_A0_GMACC1r_PARFf_GET(r) ((((r).gmacc1[0]) >> 11) & 0x1)
#define BCM56504_A0_GMACC1r_PARFf_SET(r,f) (r).gmacc1[0]=(((r).gmacc1[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56504_A0_GMACC1r_LONGPf_GET(r) ((((r).gmacc1[0]) >> 12) & 0x1)
#define BCM56504_A0_GMACC1r_LONGPf_SET(r,f) (r).gmacc1[0]=(((r).gmacc1[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM56504_A0_GMACC1r_MIFGf_GET(r) ((((r).gmacc1[0]) >> 16) & 0x7)
#define BCM56504_A0_GMACC1r_MIFGf_SET(r,f) (r).gmacc1[0]=(((r).gmacc1[0] & ~((uint32_t)0x7 << 16)) | ((((uint32_t)f) & 0x7) << 16))
#define BCM56504_A0_GMACC1r_GLVRf_GET(r) ((((r).gmacc1[0]) >> 19) & 0x1)
#define BCM56504_A0_GMACC1r_GLVRf_SET(r,f) (r).gmacc1[0]=(((r).gmacc1[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56504_A0_GMACC1r_DCRC12f_GET(r) ((((r).gmacc1[0]) >> 22) & 0x3)
#define BCM56504_A0_GMACC1r_DCRC12f_SET(r,f) (r).gmacc1[0]=(((r).gmacc1[0] & ~((uint32_t)0x3 << 22)) | ((((uint32_t)f) & 0x3) << 22))
#define BCM56504_A0_GMACC1r_RXEN0f_GET(r) ((((r).gmacc1[0]) >> 28) & 0x1)
#define BCM56504_A0_GMACC1r_RXEN0f_SET(r,f) (r).gmacc1[0]=(((r).gmacc1[0] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM56504_A0_GMACC1r_TXEN0f_GET(r) ((((r).gmacc1[0]) >> 30) & 0x1)
#define BCM56504_A0_GMACC1r_TXEN0f_SET(r,f) (r).gmacc1[0]=(((r).gmacc1[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))

/*
 * These macros can be used to access GMACC1.
 *
 */
#define BCM56504_A0_READ_GMACC1r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_GMACC1r,(r._gmacc1))
#define BCM56504_A0_WRITE_GMACC1r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_GMACC1r,&(r._gmacc1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GMACC1r BCM56504_A0_GMACC1r
#define GMACC1r_SIZE BCM56504_A0_GMACC1r_SIZE
typedef BCM56504_A0_GMACC1r_t GMACC1r_t;
#define GMACC1r_CLR BCM56504_A0_GMACC1r_CLR
#define GMACC1r_SET BCM56504_A0_GMACC1r_SET
#define GMACC1r_GET BCM56504_A0_GMACC1r_GET
#define GMACC1r_FULLDf_GET BCM56504_A0_GMACC1r_FULLDf_GET
#define GMACC1r_FULLDf_SET BCM56504_A0_GMACC1r_FULLDf_SET
#define GMACC1r_PADENf_GET BCM56504_A0_GMACC1r_PADENf_GET
#define GMACC1r_PADENf_SET BCM56504_A0_GMACC1r_PADENf_SET
#define GMACC1r_VLPADf_GET BCM56504_A0_GMACC1r_VLPADf_GET
#define GMACC1r_VLPADf_SET BCM56504_A0_GMACC1r_VLPADf_SET
#define GMACC1r_ADPADf_GET BCM56504_A0_GMACC1r_ADPADf_GET
#define GMACC1r_ADPADf_SET BCM56504_A0_GMACC1r_ADPADf_SET
#define GMACC1r_CRCENf_GET BCM56504_A0_GMACC1r_CRCENf_GET
#define GMACC1r_CRCENf_SET BCM56504_A0_GMACC1r_CRCENf_SET
#define GMACC1r_FLCHKf_GET BCM56504_A0_GMACC1r_FLCHKf_GET
#define GMACC1r_FLCHKf_SET BCM56504_A0_GMACC1r_FLCHKf_SET
#define GMACC1r_HUGENf_GET BCM56504_A0_GMACC1r_HUGENf_GET
#define GMACC1r_HUGENf_SET BCM56504_A0_GMACC1r_HUGENf_SET
#define GMACC1r_JUMBOf_GET BCM56504_A0_GMACC1r_JUMBOf_GET
#define GMACC1r_JUMBOf_SET BCM56504_A0_GMACC1r_JUMBOf_SET
#define GMACC1r_PUREPf_GET BCM56504_A0_GMACC1r_PUREPf_GET
#define GMACC1r_PUREPf_SET BCM56504_A0_GMACC1r_PUREPf_SET
#define GMACC1r_FCTXf_GET BCM56504_A0_GMACC1r_FCTXf_GET
#define GMACC1r_FCTXf_SET BCM56504_A0_GMACC1r_FCTXf_SET
#define GMACC1r_FCRXf_GET BCM56504_A0_GMACC1r_FCRXf_GET
#define GMACC1r_FCRXf_SET BCM56504_A0_GMACC1r_FCRXf_SET
#define GMACC1r_PARFf_GET BCM56504_A0_GMACC1r_PARFf_GET
#define GMACC1r_PARFf_SET BCM56504_A0_GMACC1r_PARFf_SET
#define GMACC1r_LONGPf_GET BCM56504_A0_GMACC1r_LONGPf_GET
#define GMACC1r_LONGPf_SET BCM56504_A0_GMACC1r_LONGPf_SET
#define GMACC1r_MIFGf_GET BCM56504_A0_GMACC1r_MIFGf_GET
#define GMACC1r_MIFGf_SET BCM56504_A0_GMACC1r_MIFGf_SET
#define GMACC1r_GLVRf_GET BCM56504_A0_GMACC1r_GLVRf_GET
#define GMACC1r_GLVRf_SET BCM56504_A0_GMACC1r_GLVRf_SET
#define GMACC1r_DCRC12f_GET BCM56504_A0_GMACC1r_DCRC12f_GET
#define GMACC1r_DCRC12f_SET BCM56504_A0_GMACC1r_DCRC12f_SET
#define GMACC1r_RXEN0f_GET BCM56504_A0_GMACC1r_RXEN0f_GET
#define GMACC1r_RXEN0f_SET BCM56504_A0_GMACC1r_RXEN0f_SET
#define GMACC1r_TXEN0f_GET BCM56504_A0_GMACC1r_TXEN0f_GET
#define GMACC1r_TXEN0f_SET BCM56504_A0_GMACC1r_TXEN0f_SET
#define READ_GMACC1r BCM56504_A0_READ_GMACC1r
#define WRITE_GMACC1r BCM56504_A0_WRITE_GMACC1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GMACC1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GMACC2
 * BLOCKS:   GPORT0
 * DESC:     GIG Port Control Reg 2
 * SIZE:     32
 * FIELDS:
 *     IPGT             Back-to-Back Transmit IPG
 *
 ******************************************************************************/
#define BCM56504_A0_GMACC2r 0x00f00102

#define BCM56504_A0_GMACC2r_SIZE 4

/*
 * This structure should be used to declare and program GMACC2.
 *
 */
typedef union BCM56504_A0_GMACC2r_s {
	uint32_t v[1];
	uint32_t gmacc2[1];
	uint32_t _gmacc2;
} BCM56504_A0_GMACC2r_t;

#define BCM56504_A0_GMACC2r_CLR(r) (r).gmacc2[0] = 0
#define BCM56504_A0_GMACC2r_SET(r,d) (r).gmacc2[0] = d
#define BCM56504_A0_GMACC2r_GET(r) (r).gmacc2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_GMACC2r_IPGTf_GET(r) (((r).gmacc2[0]) & 0x3f)
#define BCM56504_A0_GMACC2r_IPGTf_SET(r,f) (r).gmacc2[0]=(((r).gmacc2[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))

/*
 * These macros can be used to access GMACC2.
 *
 */
#define BCM56504_A0_READ_GMACC2r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_GMACC2r,(r._gmacc2))
#define BCM56504_A0_WRITE_GMACC2r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_GMACC2r,&(r._gmacc2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GMACC2r BCM56504_A0_GMACC2r
#define GMACC2r_SIZE BCM56504_A0_GMACC2r_SIZE
typedef BCM56504_A0_GMACC2r_t GMACC2r_t;
#define GMACC2r_CLR BCM56504_A0_GMACC2r_CLR
#define GMACC2r_SET BCM56504_A0_GMACC2r_SET
#define GMACC2r_GET BCM56504_A0_GMACC2r_GET
#define GMACC2r_IPGTf_GET BCM56504_A0_GMACC2r_IPGTf_GET
#define GMACC2r_IPGTf_SET BCM56504_A0_GMACC2r_IPGTf_SET
#define READ_GMACC2r BCM56504_A0_READ_GMACC2r
#define WRITE_GMACC2r BCM56504_A0_WRITE_GMACC2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GMACC2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GPCSC
 * BLOCKS:   GPORT0
 * DESC:     Jitter Reg
 * SIZE:     32
 * FIELDS:
 *     EWRAP            Loopback SERDES
 *     RCSEL            Clock select for Receive. 0=TBI(8b10b), 1=GMII
 *
 ******************************************************************************/
#define BCM56504_A0_GPCSCr 0x00f00103

#define BCM56504_A0_GPCSCr_SIZE 4

/*
 * This structure should be used to declare and program GPCSC.
 *
 */
typedef union BCM56504_A0_GPCSCr_s {
	uint32_t v[1];
	uint32_t gpcsc[1];
	uint32_t _gpcsc;
} BCM56504_A0_GPCSCr_t;

#define BCM56504_A0_GPCSCr_CLR(r) (r).gpcsc[0] = 0
#define BCM56504_A0_GPCSCr_SET(r,d) (r).gpcsc[0] = d
#define BCM56504_A0_GPCSCr_GET(r) (r).gpcsc[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_GPCSCr_EWRAPf_GET(r) ((((r).gpcsc[0]) >> 1) & 0x1)
#define BCM56504_A0_GPCSCr_EWRAPf_SET(r,f) (r).gpcsc[0]=(((r).gpcsc[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_GPCSCr_RCSELf_GET(r) ((((r).gpcsc[0]) >> 2) & 0x1)
#define BCM56504_A0_GPCSCr_RCSELf_SET(r,f) (r).gpcsc[0]=(((r).gpcsc[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))

/*
 * These macros can be used to access GPCSC.
 *
 */
#define BCM56504_A0_READ_GPCSCr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_GPCSCr,(r._gpcsc))
#define BCM56504_A0_WRITE_GPCSCr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_GPCSCr,&(r._gpcsc))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GPCSCr BCM56504_A0_GPCSCr
#define GPCSCr_SIZE BCM56504_A0_GPCSCr_SIZE
typedef BCM56504_A0_GPCSCr_t GPCSCr_t;
#define GPCSCr_CLR BCM56504_A0_GPCSCr_CLR
#define GPCSCr_SET BCM56504_A0_GPCSCr_SET
#define GPCSCr_GET BCM56504_A0_GPCSCr_GET
#define GPCSCr_EWRAPf_GET BCM56504_A0_GPCSCr_EWRAPf_GET
#define GPCSCr_EWRAPf_SET BCM56504_A0_GPCSCr_EWRAPf_SET
#define GPCSCr_RCSELf_GET BCM56504_A0_GPCSCr_RCSELf_GET
#define GPCSCr_RCSELf_SET BCM56504_A0_GPCSCr_RCSELf_SET
#define READ_GPCSCr BCM56504_A0_READ_GPCSCr
#define WRITE_GPCSCr BCM56504_A0_WRITE_GPCSCr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GPCSCr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GPORT_CNTMAXSIZE
 * BLOCKS:   GPORT0
 * DESC:     GPORT CNTMAXSIZE register
 * SIZE:     32
 * FIELDS:
 *     CNTMAXSIZE       The max packet size that is used in statistic counter update. Default to 1518.
 *
 ******************************************************************************/
#define BCM56504_A0_GPORT_CNTMAXSIZEr 0x00f80003

#define BCM56504_A0_GPORT_CNTMAXSIZEr_SIZE 4

/*
 * This structure should be used to declare and program GPORT_CNTMAXSIZE.
 *
 */
typedef union BCM56504_A0_GPORT_CNTMAXSIZEr_s {
	uint32_t v[1];
	uint32_t gport_cntmaxsize[1];
	uint32_t _gport_cntmaxsize;
} BCM56504_A0_GPORT_CNTMAXSIZEr_t;

#define BCM56504_A0_GPORT_CNTMAXSIZEr_CLR(r) (r).gport_cntmaxsize[0] = 0
#define BCM56504_A0_GPORT_CNTMAXSIZEr_SET(r,d) (r).gport_cntmaxsize[0] = d
#define BCM56504_A0_GPORT_CNTMAXSIZEr_GET(r) (r).gport_cntmaxsize[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_GPORT_CNTMAXSIZEr_CNTMAXSIZEf_GET(r) (((r).gport_cntmaxsize[0]) & 0x3fff)
#define BCM56504_A0_GPORT_CNTMAXSIZEr_CNTMAXSIZEf_SET(r,f) (r).gport_cntmaxsize[0]=(((r).gport_cntmaxsize[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access GPORT_CNTMAXSIZE.
 *
 */
#define BCM56504_A0_READ_GPORT_CNTMAXSIZEr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GPORT_CNTMAXSIZEr,(r._gport_cntmaxsize))
#define BCM56504_A0_WRITE_GPORT_CNTMAXSIZEr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GPORT_CNTMAXSIZEr,&(r._gport_cntmaxsize))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GPORT_CNTMAXSIZEr BCM56504_A0_GPORT_CNTMAXSIZEr
#define GPORT_CNTMAXSIZEr_SIZE BCM56504_A0_GPORT_CNTMAXSIZEr_SIZE
typedef BCM56504_A0_GPORT_CNTMAXSIZEr_t GPORT_CNTMAXSIZEr_t;
#define GPORT_CNTMAXSIZEr_CLR BCM56504_A0_GPORT_CNTMAXSIZEr_CLR
#define GPORT_CNTMAXSIZEr_SET BCM56504_A0_GPORT_CNTMAXSIZEr_SET
#define GPORT_CNTMAXSIZEr_GET BCM56504_A0_GPORT_CNTMAXSIZEr_GET
#define GPORT_CNTMAXSIZEr_CNTMAXSIZEf_GET BCM56504_A0_GPORT_CNTMAXSIZEr_CNTMAXSIZEf_GET
#define GPORT_CNTMAXSIZEr_CNTMAXSIZEf_SET BCM56504_A0_GPORT_CNTMAXSIZEr_CNTMAXSIZEf_SET
#define READ_GPORT_CNTMAXSIZEr BCM56504_A0_READ_GPORT_CNTMAXSIZEr
#define WRITE_GPORT_CNTMAXSIZEr BCM56504_A0_WRITE_GPORT_CNTMAXSIZEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GPORT_CNTMAXSIZEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GPORT_CONFIG
 * BLOCKS:   GPORT0
 * DESC:     GPORT configuration Register
 * SIZE:     32
 * FIELDS:
 *     GPORT_EN         Enable GPORT.
 *     CLR_CNT          Clear all 12 GE port statistic Counters.
 *
 ******************************************************************************/
#define BCM56504_A0_GPORT_CONFIGr 0x00f80000

#define BCM56504_A0_GPORT_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program GPORT_CONFIG.
 *
 */
typedef union BCM56504_A0_GPORT_CONFIGr_s {
	uint32_t v[1];
	uint32_t gport_config[1];
	uint32_t _gport_config;
} BCM56504_A0_GPORT_CONFIGr_t;

#define BCM56504_A0_GPORT_CONFIGr_CLR(r) (r).gport_config[0] = 0
#define BCM56504_A0_GPORT_CONFIGr_SET(r,d) (r).gport_config[0] = d
#define BCM56504_A0_GPORT_CONFIGr_GET(r) (r).gport_config[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_GPORT_CONFIGr_GPORT_ENf_GET(r) (((r).gport_config[0]) & 0x1)
#define BCM56504_A0_GPORT_CONFIGr_GPORT_ENf_SET(r,f) (r).gport_config[0]=(((r).gport_config[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_GPORT_CONFIGr_CLR_CNTf_GET(r) ((((r).gport_config[0]) >> 1) & 0x1)
#define BCM56504_A0_GPORT_CONFIGr_CLR_CNTf_SET(r,f) (r).gport_config[0]=(((r).gport_config[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access GPORT_CONFIG.
 *
 */
#define BCM56504_A0_READ_GPORT_CONFIGr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GPORT_CONFIGr,(r._gport_config))
#define BCM56504_A0_WRITE_GPORT_CONFIGr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GPORT_CONFIGr,&(r._gport_config))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GPORT_CONFIGr BCM56504_A0_GPORT_CONFIGr
#define GPORT_CONFIGr_SIZE BCM56504_A0_GPORT_CONFIGr_SIZE
typedef BCM56504_A0_GPORT_CONFIGr_t GPORT_CONFIGr_t;
#define GPORT_CONFIGr_CLR BCM56504_A0_GPORT_CONFIGr_CLR
#define GPORT_CONFIGr_SET BCM56504_A0_GPORT_CONFIGr_SET
#define GPORT_CONFIGr_GET BCM56504_A0_GPORT_CONFIGr_GET
#define GPORT_CONFIGr_GPORT_ENf_GET BCM56504_A0_GPORT_CONFIGr_GPORT_ENf_GET
#define GPORT_CONFIGr_GPORT_ENf_SET BCM56504_A0_GPORT_CONFIGr_GPORT_ENf_SET
#define GPORT_CONFIGr_CLR_CNTf_GET BCM56504_A0_GPORT_CONFIGr_CLR_CNTf_GET
#define GPORT_CONFIGr_CLR_CNTf_SET BCM56504_A0_GPORT_CONFIGr_CLR_CNTf_SET
#define READ_GPORT_CONFIGr BCM56504_A0_READ_GPORT_CONFIGr
#define WRITE_GPORT_CONFIGr BCM56504_A0_WRITE_GPORT_CONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GPORT_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GPORT_RSV_MASK
 * BLOCKS:   GPORT0
 * DESC:     GPORT RSV MASK register, used to purge packet data received from the MACs
 * SIZE:     32
 * FIELDS:
 *     MASK             Control which RSV bits cause packets to be purged
 *
 ******************************************************************************/
#define BCM56504_A0_GPORT_RSV_MASKr 0x00f80001

#define BCM56504_A0_GPORT_RSV_MASKr_SIZE 4

/*
 * This structure should be used to declare and program GPORT_RSV_MASK.
 *
 */
typedef union BCM56504_A0_GPORT_RSV_MASKr_s {
	uint32_t v[1];
	uint32_t gport_rsv_mask[1];
	uint32_t _gport_rsv_mask;
} BCM56504_A0_GPORT_RSV_MASKr_t;

#define BCM56504_A0_GPORT_RSV_MASKr_CLR(r) (r).gport_rsv_mask[0] = 0
#define BCM56504_A0_GPORT_RSV_MASKr_SET(r,d) (r).gport_rsv_mask[0] = d
#define BCM56504_A0_GPORT_RSV_MASKr_GET(r) (r).gport_rsv_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_GPORT_RSV_MASKr_MASKf_GET(r) ((((r).gport_rsv_mask[0]) >> 16) & 0x7fff)
#define BCM56504_A0_GPORT_RSV_MASKr_MASKf_SET(r,f) (r).gport_rsv_mask[0]=(((r).gport_rsv_mask[0] & ~((uint32_t)0x7fff << 16)) | ((((uint32_t)f) & 0x7fff) << 16))

/*
 * These macros can be used to access GPORT_RSV_MASK.
 *
 */
#define BCM56504_A0_READ_GPORT_RSV_MASKr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GPORT_RSV_MASKr,(r._gport_rsv_mask))
#define BCM56504_A0_WRITE_GPORT_RSV_MASKr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GPORT_RSV_MASKr,&(r._gport_rsv_mask))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GPORT_RSV_MASKr BCM56504_A0_GPORT_RSV_MASKr
#define GPORT_RSV_MASKr_SIZE BCM56504_A0_GPORT_RSV_MASKr_SIZE
typedef BCM56504_A0_GPORT_RSV_MASKr_t GPORT_RSV_MASKr_t;
#define GPORT_RSV_MASKr_CLR BCM56504_A0_GPORT_RSV_MASKr_CLR
#define GPORT_RSV_MASKr_SET BCM56504_A0_GPORT_RSV_MASKr_SET
#define GPORT_RSV_MASKr_GET BCM56504_A0_GPORT_RSV_MASKr_GET
#define GPORT_RSV_MASKr_MASKf_GET BCM56504_A0_GPORT_RSV_MASKr_MASKf_GET
#define GPORT_RSV_MASKr_MASKf_SET BCM56504_A0_GPORT_RSV_MASKr_MASKf_SET
#define READ_GPORT_RSV_MASKr BCM56504_A0_READ_GPORT_RSV_MASKr
#define WRITE_GPORT_RSV_MASKr BCM56504_A0_WRITE_GPORT_RSV_MASKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GPORT_RSV_MASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GPORT_STAT_UPDATE_MASK
 * BLOCKS:   GPORT0
 * DESC:     GPORT STAT_UPDATE MASK register, used to control the statistic counter update in the Ingress
 * SIZE:     32
 * FIELDS:
 *     MASK             Control which RSV event should have the statistic counter updated in the Ingress.
 *
 ******************************************************************************/
#define BCM56504_A0_GPORT_STAT_UPDATE_MASKr 0x00f80002

#define BCM56504_A0_GPORT_STAT_UPDATE_MASKr_SIZE 4

/*
 * This structure should be used to declare and program GPORT_STAT_UPDATE_MASK.
 *
 */
typedef union BCM56504_A0_GPORT_STAT_UPDATE_MASKr_s {
	uint32_t v[1];
	uint32_t gport_stat_update_mask[1];
	uint32_t _gport_stat_update_mask;
} BCM56504_A0_GPORT_STAT_UPDATE_MASKr_t;

#define BCM56504_A0_GPORT_STAT_UPDATE_MASKr_CLR(r) (r).gport_stat_update_mask[0] = 0
#define BCM56504_A0_GPORT_STAT_UPDATE_MASKr_SET(r,d) (r).gport_stat_update_mask[0] = d
#define BCM56504_A0_GPORT_STAT_UPDATE_MASKr_GET(r) (r).gport_stat_update_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_GPORT_STAT_UPDATE_MASKr_MASKf_GET(r) ((((r).gport_stat_update_mask[0]) >> 16) & 0x7fff)
#define BCM56504_A0_GPORT_STAT_UPDATE_MASKr_MASKf_SET(r,f) (r).gport_stat_update_mask[0]=(((r).gport_stat_update_mask[0] & ~((uint32_t)0x7fff << 16)) | ((((uint32_t)f) & 0x7fff) << 16))

/*
 * These macros can be used to access GPORT_STAT_UPDATE_MASK.
 *
 */
#define BCM56504_A0_READ_GPORT_STAT_UPDATE_MASKr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GPORT_STAT_UPDATE_MASKr,(r._gport_stat_update_mask))
#define BCM56504_A0_WRITE_GPORT_STAT_UPDATE_MASKr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GPORT_STAT_UPDATE_MASKr,&(r._gport_stat_update_mask))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GPORT_STAT_UPDATE_MASKr BCM56504_A0_GPORT_STAT_UPDATE_MASKr
#define GPORT_STAT_UPDATE_MASKr_SIZE BCM56504_A0_GPORT_STAT_UPDATE_MASKr_SIZE
typedef BCM56504_A0_GPORT_STAT_UPDATE_MASKr_t GPORT_STAT_UPDATE_MASKr_t;
#define GPORT_STAT_UPDATE_MASKr_CLR BCM56504_A0_GPORT_STAT_UPDATE_MASKr_CLR
#define GPORT_STAT_UPDATE_MASKr_SET BCM56504_A0_GPORT_STAT_UPDATE_MASKr_SET
#define GPORT_STAT_UPDATE_MASKr_GET BCM56504_A0_GPORT_STAT_UPDATE_MASKr_GET
#define GPORT_STAT_UPDATE_MASKr_MASKf_GET BCM56504_A0_GPORT_STAT_UPDATE_MASKr_MASKf_GET
#define GPORT_STAT_UPDATE_MASKr_MASKf_SET BCM56504_A0_GPORT_STAT_UPDATE_MASKr_MASKf_SET
#define READ_GPORT_STAT_UPDATE_MASKr BCM56504_A0_READ_GPORT_STAT_UPDATE_MASKr
#define WRITE_GPORT_STAT_UPDATE_MASKr BCM56504_A0_WRITE_GPORT_STAT_UPDATE_MASKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GPORT_STAT_UPDATE_MASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GPORT_TPID
 * BLOCKS:   GPORT0
 * DESC:     GPORT VLAN Tag Protocol ID
 * SIZE:     32
 * FIELDS:
 *     TPID             Used in TriMAC to detect VLAN tagged packets.
 *
 ******************************************************************************/
#define BCM56504_A0_GPORT_TPIDr 0x00f80028

#define BCM56504_A0_GPORT_TPIDr_SIZE 4

/*
 * This structure should be used to declare and program GPORT_TPID.
 *
 */
typedef union BCM56504_A0_GPORT_TPIDr_s {
	uint32_t v[1];
	uint32_t gport_tpid[1];
	uint32_t _gport_tpid;
} BCM56504_A0_GPORT_TPIDr_t;

#define BCM56504_A0_GPORT_TPIDr_CLR(r) (r).gport_tpid[0] = 0
#define BCM56504_A0_GPORT_TPIDr_SET(r,d) (r).gport_tpid[0] = d
#define BCM56504_A0_GPORT_TPIDr_GET(r) (r).gport_tpid[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_GPORT_TPIDr_TPIDf_GET(r) (((r).gport_tpid[0]) & 0xffff)
#define BCM56504_A0_GPORT_TPIDr_TPIDf_SET(r,f) (r).gport_tpid[0]=(((r).gport_tpid[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access GPORT_TPID.
 *
 */
#define BCM56504_A0_READ_GPORT_TPIDr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GPORT_TPIDr,(r._gport_tpid))
#define BCM56504_A0_WRITE_GPORT_TPIDr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM56504_A0_BLKTYPE_GPORT),p,BCM56504_A0_GPORT_TPIDr,&(r._gport_tpid))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GPORT_TPIDr BCM56504_A0_GPORT_TPIDr
#define GPORT_TPIDr_SIZE BCM56504_A0_GPORT_TPIDr_SIZE
typedef BCM56504_A0_GPORT_TPIDr_t GPORT_TPIDr_t;
#define GPORT_TPIDr_CLR BCM56504_A0_GPORT_TPIDr_CLR
#define GPORT_TPIDr_SET BCM56504_A0_GPORT_TPIDr_SET
#define GPORT_TPIDr_GET BCM56504_A0_GPORT_TPIDr_GET
#define GPORT_TPIDr_TPIDf_GET BCM56504_A0_GPORT_TPIDr_TPIDf_GET
#define GPORT_TPIDr_TPIDf_SET BCM56504_A0_GPORT_TPIDr_TPIDf_SET
#define READ_GPORT_TPIDr BCM56504_A0_READ_GPORT_TPIDr
#define WRITE_GPORT_TPIDr BCM56504_A0_WRITE_GPORT_TPIDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GPORT_TPIDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GR1023
 * BLOCKS:   GPORT0
 * DESC:     Receive 512 to 1023 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_GR1023r 0x00f00004

#define BCM56504_A0_GR1023r_SIZE 4

/*
 * This structure should be used to declare and program GR1023.
 *
 */
typedef union BCM56504_A0_GR1023r_s {
	uint32_t v[1];
	uint32_t gr1023[1];
	uint32_t _gr1023;
} BCM56504_A0_GR1023r_t;

#define BCM56504_A0_GR1023r_CLR(r) (r).gr1023[0] = 0
#define BCM56504_A0_GR1023r_SET(r,d) (r).gr1023[0] = d
#define BCM56504_A0_GR1023r_GET(r) (r).gr1023[0]


/*
 * These macros can be used to access GR1023.
 *
 */
#define BCM56504_A0_READ_GR1023r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_GR1023r,(r._gr1023))
#define BCM56504_A0_WRITE_GR1023r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_GR1023r,&(r._gr1023))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GR1023r BCM56504_A0_GR1023r
#define GR1023r_SIZE BCM56504_A0_GR1023r_SIZE
typedef BCM56504_A0_GR1023r_t GR1023r_t;
#define GR1023r_CLR BCM56504_A0_GR1023r_CLR
#define GR1023r_SET BCM56504_A0_GR1023r_SET
#define GR1023r_GET BCM56504_A0_GR1023r_GET
#define READ_GR1023r BCM56504_A0_READ_GR1023r
#define WRITE_GR1023r BCM56504_A0_WRITE_GR1023r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GR1023r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GR127
 * BLOCKS:   GPORT0
 * DESC:     Receive 65 to 127 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_GR127r 0x00f00001

#define BCM56504_A0_GR127r_SIZE 4

/*
 * This structure should be used to declare and program GR127.
 *
 */
typedef union BCM56504_A0_GR127r_s {
	uint32_t v[1];
	uint32_t gr127[1];
	uint32_t _gr127;
} BCM56504_A0_GR127r_t;

#define BCM56504_A0_GR127r_CLR(r) (r).gr127[0] = 0
#define BCM56504_A0_GR127r_SET(r,d) (r).gr127[0] = d
#define BCM56504_A0_GR127r_GET(r) (r).gr127[0]


/*
 * These macros can be used to access GR127.
 *
 */
#define BCM56504_A0_READ_GR127r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_GR127r,(r._gr127))
#define BCM56504_A0_WRITE_GR127r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_GR127r,&(r._gr127))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GR127r BCM56504_A0_GR127r
#define GR127r_SIZE BCM56504_A0_GR127r_SIZE
typedef BCM56504_A0_GR127r_t GR127r_t;
#define GR127r_CLR BCM56504_A0_GR127r_CLR
#define GR127r_SET BCM56504_A0_GR127r_SET
#define GR127r_GET BCM56504_A0_GR127r_GET
#define READ_GR127r BCM56504_A0_READ_GR127r
#define WRITE_GR127r BCM56504_A0_WRITE_GR127r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GR127r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GR1518
 * BLOCKS:   GPORT0
 * DESC:     Receive 1024 to 1518 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_GR1518r 0x00f00005

#define BCM56504_A0_GR1518r_SIZE 4

/*
 * This structure should be used to declare and program GR1518.
 *
 */
typedef union BCM56504_A0_GR1518r_s {
	uint32_t v[1];
	uint32_t gr1518[1];
	uint32_t _gr1518;
} BCM56504_A0_GR1518r_t;

#define BCM56504_A0_GR1518r_CLR(r) (r).gr1518[0] = 0
#define BCM56504_A0_GR1518r_SET(r,d) (r).gr1518[0] = d
#define BCM56504_A0_GR1518r_GET(r) (r).gr1518[0]


/*
 * These macros can be used to access GR1518.
 *
 */
#define BCM56504_A0_READ_GR1518r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_GR1518r,(r._gr1518))
#define BCM56504_A0_WRITE_GR1518r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_GR1518r,&(r._gr1518))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GR1518r BCM56504_A0_GR1518r
#define GR1518r_SIZE BCM56504_A0_GR1518r_SIZE
typedef BCM56504_A0_GR1518r_t GR1518r_t;
#define GR1518r_CLR BCM56504_A0_GR1518r_CLR
#define GR1518r_SET BCM56504_A0_GR1518r_SET
#define GR1518r_GET BCM56504_A0_GR1518r_GET
#define READ_GR1518r BCM56504_A0_READ_GR1518r
#define WRITE_GR1518r BCM56504_A0_WRITE_GR1518r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GR1518r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GR2047
 * BLOCKS:   GPORT0
 * DESC:     Receive 1519 to 2047 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_GR2047r 0x00f00007

#define BCM56504_A0_GR2047r_SIZE 4

/*
 * This structure should be used to declare and program GR2047.
 *
 */
typedef union BCM56504_A0_GR2047r_s {
	uint32_t v[1];
	uint32_t gr2047[1];
	uint32_t _gr2047;
} BCM56504_A0_GR2047r_t;

#define BCM56504_A0_GR2047r_CLR(r) (r).gr2047[0] = 0
#define BCM56504_A0_GR2047r_SET(r,d) (r).gr2047[0] = d
#define BCM56504_A0_GR2047r_GET(r) (r).gr2047[0]


/*
 * These macros can be used to access GR2047.
 *
 */
#define BCM56504_A0_READ_GR2047r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_GR2047r,(r._gr2047))
#define BCM56504_A0_WRITE_GR2047r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_GR2047r,&(r._gr2047))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GR2047r BCM56504_A0_GR2047r
#define GR2047r_SIZE BCM56504_A0_GR2047r_SIZE
typedef BCM56504_A0_GR2047r_t GR2047r_t;
#define GR2047r_CLR BCM56504_A0_GR2047r_CLR
#define GR2047r_SET BCM56504_A0_GR2047r_SET
#define GR2047r_GET BCM56504_A0_GR2047r_GET
#define READ_GR2047r BCM56504_A0_READ_GR2047r
#define WRITE_GR2047r BCM56504_A0_WRITE_GR2047r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GR2047r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GR255
 * BLOCKS:   GPORT0
 * DESC:     Receive 128 to 255 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_GR255r 0x00f00002

#define BCM56504_A0_GR255r_SIZE 4

/*
 * This structure should be used to declare and program GR255.
 *
 */
typedef union BCM56504_A0_GR255r_s {
	uint32_t v[1];
	uint32_t gr255[1];
	uint32_t _gr255;
} BCM56504_A0_GR255r_t;

#define BCM56504_A0_GR255r_CLR(r) (r).gr255[0] = 0
#define BCM56504_A0_GR255r_SET(r,d) (r).gr255[0] = d
#define BCM56504_A0_GR255r_GET(r) (r).gr255[0]


/*
 * These macros can be used to access GR255.
 *
 */
#define BCM56504_A0_READ_GR255r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_GR255r,(r._gr255))
#define BCM56504_A0_WRITE_GR255r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_GR255r,&(r._gr255))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GR255r BCM56504_A0_GR255r
#define GR255r_SIZE BCM56504_A0_GR255r_SIZE
typedef BCM56504_A0_GR255r_t GR255r_t;
#define GR255r_CLR BCM56504_A0_GR255r_CLR
#define GR255r_SET BCM56504_A0_GR255r_SET
#define GR255r_GET BCM56504_A0_GR255r_GET
#define READ_GR255r BCM56504_A0_READ_GR255r
#define WRITE_GR255r BCM56504_A0_WRITE_GR255r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GR255r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GR4095
 * BLOCKS:   GPORT0
 * DESC:     Receive 2048 to 4095 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_GR4095r 0x00f00008

#define BCM56504_A0_GR4095r_SIZE 4

/*
 * This structure should be used to declare and program GR4095.
 *
 */
typedef union BCM56504_A0_GR4095r_s {
	uint32_t v[1];
	uint32_t gr4095[1];
	uint32_t _gr4095;
} BCM56504_A0_GR4095r_t;

#define BCM56504_A0_GR4095r_CLR(r) (r).gr4095[0] = 0
#define BCM56504_A0_GR4095r_SET(r,d) (r).gr4095[0] = d
#define BCM56504_A0_GR4095r_GET(r) (r).gr4095[0]


/*
 * These macros can be used to access GR4095.
 *
 */
#define BCM56504_A0_READ_GR4095r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_GR4095r,(r._gr4095))
#define BCM56504_A0_WRITE_GR4095r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_GR4095r,&(r._gr4095))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GR4095r BCM56504_A0_GR4095r
#define GR4095r_SIZE BCM56504_A0_GR4095r_SIZE
typedef BCM56504_A0_GR4095r_t GR4095r_t;
#define GR4095r_CLR BCM56504_A0_GR4095r_CLR
#define GR4095r_SET BCM56504_A0_GR4095r_SET
#define GR4095r_GET BCM56504_A0_GR4095r_GET
#define READ_GR4095r BCM56504_A0_READ_GR4095r
#define WRITE_GR4095r BCM56504_A0_WRITE_GR4095r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GR4095r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GR511
 * BLOCKS:   GPORT0
 * DESC:     Receive 256 to 511 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_GR511r 0x00f00003

#define BCM56504_A0_GR511r_SIZE 4

/*
 * This structure should be used to declare and program GR511.
 *
 */
typedef union BCM56504_A0_GR511r_s {
	uint32_t v[1];
	uint32_t gr511[1];
	uint32_t _gr511;
} BCM56504_A0_GR511r_t;

#define BCM56504_A0_GR511r_CLR(r) (r).gr511[0] = 0
#define BCM56504_A0_GR511r_SET(r,d) (r).gr511[0] = d
#define BCM56504_A0_GR511r_GET(r) (r).gr511[0]


/*
 * These macros can be used to access GR511.
 *
 */
#define BCM56504_A0_READ_GR511r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_GR511r,(r._gr511))
#define BCM56504_A0_WRITE_GR511r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_GR511r,&(r._gr511))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GR511r BCM56504_A0_GR511r
#define GR511r_SIZE BCM56504_A0_GR511r_SIZE
typedef BCM56504_A0_GR511r_t GR511r_t;
#define GR511r_CLR BCM56504_A0_GR511r_CLR
#define GR511r_SET BCM56504_A0_GR511r_SET
#define GR511r_GET BCM56504_A0_GR511r_GET
#define READ_GR511r BCM56504_A0_READ_GR511r
#define WRITE_GR511r BCM56504_A0_WRITE_GR511r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GR511r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GR64
 * BLOCKS:   GPORT0
 * DESC:     Receive 64 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_GR64r 0x00f00000

#define BCM56504_A0_GR64r_SIZE 4

/*
 * This structure should be used to declare and program GR64.
 *
 */
typedef union BCM56504_A0_GR64r_s {
	uint32_t v[1];
	uint32_t gr64[1];
	uint32_t _gr64;
} BCM56504_A0_GR64r_t;

#define BCM56504_A0_GR64r_CLR(r) (r).gr64[0] = 0
#define BCM56504_A0_GR64r_SET(r,d) (r).gr64[0] = d
#define BCM56504_A0_GR64r_GET(r) (r).gr64[0]


/*
 * These macros can be used to access GR64.
 *
 */
#define BCM56504_A0_READ_GR64r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_GR64r,(r._gr64))
#define BCM56504_A0_WRITE_GR64r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_GR64r,&(r._gr64))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GR64r BCM56504_A0_GR64r
#define GR64r_SIZE BCM56504_A0_GR64r_SIZE
typedef BCM56504_A0_GR64r_t GR64r_t;
#define GR64r_CLR BCM56504_A0_GR64r_CLR
#define GR64r_SET BCM56504_A0_GR64r_SET
#define GR64r_GET BCM56504_A0_GR64r_GET
#define READ_GR64r BCM56504_A0_READ_GR64r
#define WRITE_GR64r BCM56504_A0_WRITE_GR64r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GR64r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GR9216
 * BLOCKS:   GPORT0
 * DESC:     Receive 4096 to 9216 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_GR9216r 0x00f00009

#define BCM56504_A0_GR9216r_SIZE 4

/*
 * This structure should be used to declare and program GR9216.
 *
 */
typedef union BCM56504_A0_GR9216r_s {
	uint32_t v[1];
	uint32_t gr9216[1];
	uint32_t _gr9216;
} BCM56504_A0_GR9216r_t;

#define BCM56504_A0_GR9216r_CLR(r) (r).gr9216[0] = 0
#define BCM56504_A0_GR9216r_SET(r,d) (r).gr9216[0] = d
#define BCM56504_A0_GR9216r_GET(r) (r).gr9216[0]


/*
 * These macros can be used to access GR9216.
 *
 */
#define BCM56504_A0_READ_GR9216r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_GR9216r,(r._gr9216))
#define BCM56504_A0_WRITE_GR9216r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_GR9216r,&(r._gr9216))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GR9216r BCM56504_A0_GR9216r
#define GR9216r_SIZE BCM56504_A0_GR9216r_SIZE
typedef BCM56504_A0_GR9216r_t GR9216r_t;
#define GR9216r_CLR BCM56504_A0_GR9216r_CLR
#define GR9216r_SET BCM56504_A0_GR9216r_SET
#define GR9216r_GET BCM56504_A0_GR9216r_GET
#define READ_GR9216r BCM56504_A0_READ_GR9216r
#define WRITE_GR9216r BCM56504_A0_WRITE_GR9216r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GR9216r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GRALN
 * BLOCKS:   GPORT0
 * DESC:     Receive Alignment Error Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_GRALNr 0x00f00012

#define BCM56504_A0_GRALNr_SIZE 4

/*
 * This structure should be used to declare and program GRALN.
 *
 */
typedef union BCM56504_A0_GRALNr_s {
	uint32_t v[1];
	uint32_t graln[1];
	uint32_t _graln;
} BCM56504_A0_GRALNr_t;

#define BCM56504_A0_GRALNr_CLR(r) (r).graln[0] = 0
#define BCM56504_A0_GRALNr_SET(r,d) (r).graln[0] = d
#define BCM56504_A0_GRALNr_GET(r) (r).graln[0]


/*
 * These macros can be used to access GRALN.
 *
 */
#define BCM56504_A0_READ_GRALNr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_GRALNr,(r._graln))
#define BCM56504_A0_WRITE_GRALNr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_GRALNr,&(r._graln))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRALNr BCM56504_A0_GRALNr
#define GRALNr_SIZE BCM56504_A0_GRALNr_SIZE
typedef BCM56504_A0_GRALNr_t GRALNr_t;
#define GRALNr_CLR BCM56504_A0_GRALNr_CLR
#define GRALNr_SET BCM56504_A0_GRALNr_SET
#define GRALNr_GET BCM56504_A0_GRALNr_GET
#define READ_GRALNr BCM56504_A0_READ_GRALNr
#define WRITE_GRALNr BCM56504_A0_WRITE_GRALNr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GRALNr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GRBCA
 * BLOCKS:   GPORT0
 * DESC:     Receive Broadcast Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_GRBCAr 0x00f0000d

#define BCM56504_A0_GRBCAr_SIZE 4

/*
 * This structure should be used to declare and program GRBCA.
 *
 */
typedef union BCM56504_A0_GRBCAr_s {
	uint32_t v[1];
	uint32_t grbca[1];
	uint32_t _grbca;
} BCM56504_A0_GRBCAr_t;

#define BCM56504_A0_GRBCAr_CLR(r) (r).grbca[0] = 0
#define BCM56504_A0_GRBCAr_SET(r,d) (r).grbca[0] = d
#define BCM56504_A0_GRBCAr_GET(r) (r).grbca[0]


/*
 * These macros can be used to access GRBCA.
 *
 */
#define BCM56504_A0_READ_GRBCAr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_GRBCAr,(r._grbca))
#define BCM56504_A0_WRITE_GRBCAr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_GRBCAr,&(r._grbca))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRBCAr BCM56504_A0_GRBCAr
#define GRBCAr_SIZE BCM56504_A0_GRBCAr_SIZE
typedef BCM56504_A0_GRBCAr_t GRBCAr_t;
#define GRBCAr_CLR BCM56504_A0_GRBCAr_CLR
#define GRBCAr_SET BCM56504_A0_GRBCAr_SET
#define GRBCAr_GET BCM56504_A0_GRBCAr_GET
#define READ_GRBCAr BCM56504_A0_READ_GRBCAr
#define WRITE_GRBCAr BCM56504_A0_WRITE_GRBCAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GRBCAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GRBYT
 * BLOCKS:   GPORT0
 * DESC:     Receive Byte Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_GRBYTr 0x00f0000b

#define BCM56504_A0_GRBYTr_SIZE 4

/*
 * This structure should be used to declare and program GRBYT.
 *
 */
typedef union BCM56504_A0_GRBYTr_s {
	uint32_t v[1];
	uint32_t grbyt[1];
	uint32_t _grbyt;
} BCM56504_A0_GRBYTr_t;

#define BCM56504_A0_GRBYTr_CLR(r) (r).grbyt[0] = 0
#define BCM56504_A0_GRBYTr_SET(r,d) (r).grbyt[0] = d
#define BCM56504_A0_GRBYTr_GET(r) (r).grbyt[0]


/*
 * These macros can be used to access GRBYT.
 *
 */
#define BCM56504_A0_READ_GRBYTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_GRBYTr,(r._grbyt))
#define BCM56504_A0_WRITE_GRBYTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_GRBYTr,&(r._grbyt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRBYTr BCM56504_A0_GRBYTr
#define GRBYTr_SIZE BCM56504_A0_GRBYTr_SIZE
typedef BCM56504_A0_GRBYTr_t GRBYTr_t;
#define GRBYTr_CLR BCM56504_A0_GRBYTr_CLR
#define GRBYTr_SET BCM56504_A0_GRBYTr_SET
#define GRBYTr_GET BCM56504_A0_GRBYTr_GET
#define READ_GRBYTr BCM56504_A0_READ_GRBYTr
#define WRITE_GRBYTr BCM56504_A0_WRITE_GRBYTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GRBYTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GRCDE
 * BLOCKS:   GPORT0
 * DESC:     Receive Code Error Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_GRCDEr 0x00f00014

#define BCM56504_A0_GRCDEr_SIZE 4

/*
 * This structure should be used to declare and program GRCDE.
 *
 */
typedef union BCM56504_A0_GRCDEr_s {
	uint32_t v[1];
	uint32_t grcde[1];
	uint32_t _grcde;
} BCM56504_A0_GRCDEr_t;

#define BCM56504_A0_GRCDEr_CLR(r) (r).grcde[0] = 0
#define BCM56504_A0_GRCDEr_SET(r,d) (r).grcde[0] = d
#define BCM56504_A0_GRCDEr_GET(r) (r).grcde[0]


/*
 * These macros can be used to access GRCDE.
 *
 */
#define BCM56504_A0_READ_GRCDEr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_GRCDEr,(r._grcde))
#define BCM56504_A0_WRITE_GRCDEr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_GRCDEr,&(r._grcde))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRCDEr BCM56504_A0_GRCDEr
#define GRCDEr_SIZE BCM56504_A0_GRCDEr_SIZE
typedef BCM56504_A0_GRCDEr_t GRCDEr_t;
#define GRCDEr_CLR BCM56504_A0_GRCDEr_CLR
#define GRCDEr_SET BCM56504_A0_GRCDEr_SET
#define GRCDEr_GET BCM56504_A0_GRCDEr_GET
#define READ_GRCDEr BCM56504_A0_READ_GRCDEr
#define WRITE_GRCDEr BCM56504_A0_WRITE_GRCDEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GRCDEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GRFCR
 * BLOCKS:   GPORT0
 * DESC:     Receive False Carrier Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_GRFCRr 0x00f00015

#define BCM56504_A0_GRFCRr_SIZE 4

/*
 * This structure should be used to declare and program GRFCR.
 *
 */
typedef union BCM56504_A0_GRFCRr_s {
	uint32_t v[1];
	uint32_t grfcr[1];
	uint32_t _grfcr;
} BCM56504_A0_GRFCRr_t;

#define BCM56504_A0_GRFCRr_CLR(r) (r).grfcr[0] = 0
#define BCM56504_A0_GRFCRr_SET(r,d) (r).grfcr[0] = d
#define BCM56504_A0_GRFCRr_GET(r) (r).grfcr[0]


/*
 * These macros can be used to access GRFCR.
 *
 */
#define BCM56504_A0_READ_GRFCRr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_GRFCRr,(r._grfcr))
#define BCM56504_A0_WRITE_GRFCRr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_GRFCRr,&(r._grfcr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRFCRr BCM56504_A0_GRFCRr
#define GRFCRr_SIZE BCM56504_A0_GRFCRr_SIZE
typedef BCM56504_A0_GRFCRr_t GRFCRr_t;
#define GRFCRr_CLR BCM56504_A0_GRFCRr_CLR
#define GRFCRr_SET BCM56504_A0_GRFCRr_SET
#define GRFCRr_GET BCM56504_A0_GRFCRr_GET
#define READ_GRFCRr BCM56504_A0_READ_GRFCRr
#define WRITE_GRFCRr BCM56504_A0_WRITE_GRFCRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GRFCRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GRFCS
 * BLOCKS:   GPORT0
 * DESC:     Receive FCS Error Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_GRFCSr 0x00f0000e

#define BCM56504_A0_GRFCSr_SIZE 4

/*
 * This structure should be used to declare and program GRFCS.
 *
 */
typedef union BCM56504_A0_GRFCSr_s {
	uint32_t v[1];
	uint32_t grfcs[1];
	uint32_t _grfcs;
} BCM56504_A0_GRFCSr_t;

#define BCM56504_A0_GRFCSr_CLR(r) (r).grfcs[0] = 0
#define BCM56504_A0_GRFCSr_SET(r,d) (r).grfcs[0] = d
#define BCM56504_A0_GRFCSr_GET(r) (r).grfcs[0]


/*
 * These macros can be used to access GRFCS.
 *
 */
#define BCM56504_A0_READ_GRFCSr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_GRFCSr,(r._grfcs))
#define BCM56504_A0_WRITE_GRFCSr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_GRFCSr,&(r._grfcs))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRFCSr BCM56504_A0_GRFCSr
#define GRFCSr_SIZE BCM56504_A0_GRFCSr_SIZE
typedef BCM56504_A0_GRFCSr_t GRFCSr_t;
#define GRFCSr_CLR BCM56504_A0_GRFCSr_CLR
#define GRFCSr_SET BCM56504_A0_GRFCSr_SET
#define GRFCSr_GET BCM56504_A0_GRFCSr_GET
#define READ_GRFCSr BCM56504_A0_READ_GRFCSr
#define WRITE_GRFCSr BCM56504_A0_WRITE_GRFCSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GRFCSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GRFLR
 * BLOCKS:   GPORT0
 * DESC:     Receive Length Out of Range Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_GRFLRr 0x00f00013

#define BCM56504_A0_GRFLRr_SIZE 4

/*
 * This structure should be used to declare and program GRFLR.
 *
 */
typedef union BCM56504_A0_GRFLRr_s {
	uint32_t v[1];
	uint32_t grflr[1];
	uint32_t _grflr;
} BCM56504_A0_GRFLRr_t;

#define BCM56504_A0_GRFLRr_CLR(r) (r).grflr[0] = 0
#define BCM56504_A0_GRFLRr_SET(r,d) (r).grflr[0] = d
#define BCM56504_A0_GRFLRr_GET(r) (r).grflr[0]


/*
 * These macros can be used to access GRFLR.
 *
 */
#define BCM56504_A0_READ_GRFLRr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_GRFLRr,(r._grflr))
#define BCM56504_A0_WRITE_GRFLRr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_GRFLRr,&(r._grflr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRFLRr BCM56504_A0_GRFLRr
#define GRFLRr_SIZE BCM56504_A0_GRFLRr_SIZE
typedef BCM56504_A0_GRFLRr_t GRFLRr_t;
#define GRFLRr_CLR BCM56504_A0_GRFLRr_CLR
#define GRFLRr_SET BCM56504_A0_GRFLRr_SET
#define GRFLRr_GET BCM56504_A0_GRFLRr_GET
#define READ_GRFLRr BCM56504_A0_READ_GRFLRr
#define WRITE_GRFLRr BCM56504_A0_WRITE_GRFLRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GRFLRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GRFRG
 * BLOCKS:   GPORT0
 * DESC:     Receive Fragment Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_GRFRGr 0x00f0001b

#define BCM56504_A0_GRFRGr_SIZE 4

/*
 * This structure should be used to declare and program GRFRG.
 *
 */
typedef union BCM56504_A0_GRFRGr_s {
	uint32_t v[1];
	uint32_t grfrg[1];
	uint32_t _grfrg;
} BCM56504_A0_GRFRGr_t;

#define BCM56504_A0_GRFRGr_CLR(r) (r).grfrg[0] = 0
#define BCM56504_A0_GRFRGr_SET(r,d) (r).grfrg[0] = d
#define BCM56504_A0_GRFRGr_GET(r) (r).grfrg[0]


/*
 * These macros can be used to access GRFRG.
 *
 */
#define BCM56504_A0_READ_GRFRGr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_GRFRGr,(r._grfrg))
#define BCM56504_A0_WRITE_GRFRGr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_GRFRGr,&(r._grfrg))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRFRGr BCM56504_A0_GRFRGr
#define GRFRGr_SIZE BCM56504_A0_GRFRGr_SIZE
typedef BCM56504_A0_GRFRGr_t GRFRGr_t;
#define GRFRGr_CLR BCM56504_A0_GRFRGr_CLR
#define GRFRGr_SET BCM56504_A0_GRFRGr_SET
#define GRFRGr_GET BCM56504_A0_GRFRGr_GET
#define READ_GRFRGr BCM56504_A0_READ_GRFRGr
#define WRITE_GRFRGr BCM56504_A0_WRITE_GRFRGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GRFRGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GRJBR
 * BLOCKS:   GPORT0
 * DESC:     Receive Jabber Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_GRJBRr 0x00f00017

#define BCM56504_A0_GRJBRr_SIZE 4

/*
 * This structure should be used to declare and program GRJBR.
 *
 */
typedef union BCM56504_A0_GRJBRr_s {
	uint32_t v[1];
	uint32_t grjbr[1];
	uint32_t _grjbr;
} BCM56504_A0_GRJBRr_t;

#define BCM56504_A0_GRJBRr_CLR(r) (r).grjbr[0] = 0
#define BCM56504_A0_GRJBRr_SET(r,d) (r).grjbr[0] = d
#define BCM56504_A0_GRJBRr_GET(r) (r).grjbr[0]


/*
 * These macros can be used to access GRJBR.
 *
 */
#define BCM56504_A0_READ_GRJBRr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_GRJBRr,(r._grjbr))
#define BCM56504_A0_WRITE_GRJBRr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_GRJBRr,&(r._grjbr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRJBRr BCM56504_A0_GRJBRr
#define GRJBRr_SIZE BCM56504_A0_GRJBRr_SIZE
typedef BCM56504_A0_GRJBRr_t GRJBRr_t;
#define GRJBRr_CLR BCM56504_A0_GRJBRr_CLR
#define GRJBRr_SET BCM56504_A0_GRJBRr_SET
#define GRJBRr_GET BCM56504_A0_GRJBRr_GET
#define READ_GRJBRr BCM56504_A0_READ_GRJBRr
#define WRITE_GRJBRr BCM56504_A0_WRITE_GRJBRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GRJBRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GRMCA
 * BLOCKS:   GPORT0
 * DESC:     Receive Multicast Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_GRMCAr 0x00f0000c

#define BCM56504_A0_GRMCAr_SIZE 4

/*
 * This structure should be used to declare and program GRMCA.
 *
 */
typedef union BCM56504_A0_GRMCAr_s {
	uint32_t v[1];
	uint32_t grmca[1];
	uint32_t _grmca;
} BCM56504_A0_GRMCAr_t;

#define BCM56504_A0_GRMCAr_CLR(r) (r).grmca[0] = 0
#define BCM56504_A0_GRMCAr_SET(r,d) (r).grmca[0] = d
#define BCM56504_A0_GRMCAr_GET(r) (r).grmca[0]


/*
 * These macros can be used to access GRMCA.
 *
 */
#define BCM56504_A0_READ_GRMCAr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_GRMCAr,(r._grmca))
#define BCM56504_A0_WRITE_GRMCAr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_GRMCAr,&(r._grmca))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRMCAr BCM56504_A0_GRMCAr
#define GRMCAr_SIZE BCM56504_A0_GRMCAr_SIZE
typedef BCM56504_A0_GRMCAr_t GRMCAr_t;
#define GRMCAr_CLR BCM56504_A0_GRMCAr_CLR
#define GRMCAr_SET BCM56504_A0_GRMCAr_SET
#define GRMCAr_GET BCM56504_A0_GRMCAr_GET
#define READ_GRMCAr BCM56504_A0_READ_GRMCAr
#define WRITE_GRMCAr BCM56504_A0_WRITE_GRMCAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GRMCAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GRMGV
 * BLOCKS:   GPORT0
 * DESC:     Receive 1519 to 1522 Byte Good VLAN Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_GRMGVr 0x00f00006

#define BCM56504_A0_GRMGVr_SIZE 4

/*
 * This structure should be used to declare and program GRMGV.
 *
 */
typedef union BCM56504_A0_GRMGVr_s {
	uint32_t v[1];
	uint32_t grmgv[1];
	uint32_t _grmgv;
} BCM56504_A0_GRMGVr_t;

#define BCM56504_A0_GRMGVr_CLR(r) (r).grmgv[0] = 0
#define BCM56504_A0_GRMGVr_SET(r,d) (r).grmgv[0] = d
#define BCM56504_A0_GRMGVr_GET(r) (r).grmgv[0]


/*
 * These macros can be used to access GRMGV.
 *
 */
#define BCM56504_A0_READ_GRMGVr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_GRMGVr,(r._grmgv))
#define BCM56504_A0_WRITE_GRMGVr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_GRMGVr,&(r._grmgv))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRMGVr BCM56504_A0_GRMGVr
#define GRMGVr_SIZE BCM56504_A0_GRMGVr_SIZE
typedef BCM56504_A0_GRMGVr_t GRMGVr_t;
#define GRMGVr_CLR BCM56504_A0_GRMGVr_CLR
#define GRMGVr_SET BCM56504_A0_GRMGVr_SET
#define GRMGVr_GET BCM56504_A0_GRMGVr_GET
#define READ_GRMGVr BCM56504_A0_READ_GRMGVr
#define WRITE_GRMGVr BCM56504_A0_WRITE_GRMGVr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GRMGVr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GRMTUE
 * BLOCKS:   GPORT0
 * DESC:     Receive MTU Check Error Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_GRMTUEr 0x00f00018

#define BCM56504_A0_GRMTUEr_SIZE 4

/*
 * This structure should be used to declare and program GRMTUE.
 *
 */
typedef union BCM56504_A0_GRMTUEr_s {
	uint32_t v[1];
	uint32_t grmtue[1];
	uint32_t _grmtue;
} BCM56504_A0_GRMTUEr_t;

#define BCM56504_A0_GRMTUEr_CLR(r) (r).grmtue[0] = 0
#define BCM56504_A0_GRMTUEr_SET(r,d) (r).grmtue[0] = d
#define BCM56504_A0_GRMTUEr_GET(r) (r).grmtue[0]


/*
 * These macros can be used to access GRMTUE.
 *
 */
#define BCM56504_A0_READ_GRMTUEr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_GRMTUEr,(r._grmtue))
#define BCM56504_A0_WRITE_GRMTUEr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_GRMTUEr,&(r._grmtue))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRMTUEr BCM56504_A0_GRMTUEr
#define GRMTUEr_SIZE BCM56504_A0_GRMTUEr_SIZE
typedef BCM56504_A0_GRMTUEr_t GRMTUEr_t;
#define GRMTUEr_CLR BCM56504_A0_GRMTUEr_CLR
#define GRMTUEr_SET BCM56504_A0_GRMTUEr_SET
#define GRMTUEr_GET BCM56504_A0_GRMTUEr_GET
#define READ_GRMTUEr BCM56504_A0_READ_GRMTUEr
#define WRITE_GRMTUEr BCM56504_A0_WRITE_GRMTUEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GRMTUEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GROVR
 * BLOCKS:   GPORT0
 * DESC:     Receive Oversized Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_GROVRr 0x00f00016

#define BCM56504_A0_GROVRr_SIZE 4

/*
 * This structure should be used to declare and program GROVR.
 *
 */
typedef union BCM56504_A0_GROVRr_s {
	uint32_t v[1];
	uint32_t grovr[1];
	uint32_t _grovr;
} BCM56504_A0_GROVRr_t;

#define BCM56504_A0_GROVRr_CLR(r) (r).grovr[0] = 0
#define BCM56504_A0_GROVRr_SET(r,d) (r).grovr[0] = d
#define BCM56504_A0_GROVRr_GET(r) (r).grovr[0]


/*
 * These macros can be used to access GROVR.
 *
 */
#define BCM56504_A0_READ_GROVRr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_GROVRr,(r._grovr))
#define BCM56504_A0_WRITE_GROVRr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_GROVRr,&(r._grovr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GROVRr BCM56504_A0_GROVRr
#define GROVRr_SIZE BCM56504_A0_GROVRr_SIZE
typedef BCM56504_A0_GROVRr_t GROVRr_t;
#define GROVRr_CLR BCM56504_A0_GROVRr_CLR
#define GROVRr_SET BCM56504_A0_GROVRr_SET
#define GROVRr_GET BCM56504_A0_GROVRr_GET
#define READ_GROVRr BCM56504_A0_READ_GROVRr
#define WRITE_GROVRr BCM56504_A0_WRITE_GROVRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GROVRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GRPKT
 * BLOCKS:   GPORT0
 * DESC:     Receive frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_GRPKTr 0x00f0000a

#define BCM56504_A0_GRPKTr_SIZE 4

/*
 * This structure should be used to declare and program GRPKT.
 *
 */
typedef union BCM56504_A0_GRPKTr_s {
	uint32_t v[1];
	uint32_t grpkt[1];
	uint32_t _grpkt;
} BCM56504_A0_GRPKTr_t;

#define BCM56504_A0_GRPKTr_CLR(r) (r).grpkt[0] = 0
#define BCM56504_A0_GRPKTr_SET(r,d) (r).grpkt[0] = d
#define BCM56504_A0_GRPKTr_GET(r) (r).grpkt[0]


/*
 * These macros can be used to access GRPKT.
 *
 */
#define BCM56504_A0_READ_GRPKTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_GRPKTr,(r._grpkt))
#define BCM56504_A0_WRITE_GRPKTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_GRPKTr,&(r._grpkt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRPKTr BCM56504_A0_GRPKTr
#define GRPKTr_SIZE BCM56504_A0_GRPKTr_SIZE
typedef BCM56504_A0_GRPKTr_t GRPKTr_t;
#define GRPKTr_CLR BCM56504_A0_GRPKTr_CLR
#define GRPKTr_SET BCM56504_A0_GRPKTr_SET
#define GRPKTr_GET BCM56504_A0_GRPKTr_GET
#define READ_GRPKTr BCM56504_A0_READ_GRPKTr
#define WRITE_GRPKTr BCM56504_A0_WRITE_GRPKTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GRPKTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GRUND
 * BLOCKS:   GPORT0
 * DESC:     Receive Undersize Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_GRUNDr 0x00f0001a

#define BCM56504_A0_GRUNDr_SIZE 4

/*
 * This structure should be used to declare and program GRUND.
 *
 */
typedef union BCM56504_A0_GRUNDr_s {
	uint32_t v[1];
	uint32_t grund[1];
	uint32_t _grund;
} BCM56504_A0_GRUNDr_t;

#define BCM56504_A0_GRUNDr_CLR(r) (r).grund[0] = 0
#define BCM56504_A0_GRUNDr_SET(r,d) (r).grund[0] = d
#define BCM56504_A0_GRUNDr_GET(r) (r).grund[0]


/*
 * These macros can be used to access GRUND.
 *
 */
#define BCM56504_A0_READ_GRUNDr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_GRUNDr,(r._grund))
#define BCM56504_A0_WRITE_GRUNDr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_GRUNDr,&(r._grund))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRUNDr BCM56504_A0_GRUNDr
#define GRUNDr_SIZE BCM56504_A0_GRUNDr_SIZE
typedef BCM56504_A0_GRUNDr_t GRUNDr_t;
#define GRUNDr_CLR BCM56504_A0_GRUNDr_CLR
#define GRUNDr_SET BCM56504_A0_GRUNDr_SET
#define GRUNDr_GET BCM56504_A0_GRUNDr_GET
#define READ_GRUNDr BCM56504_A0_READ_GRUNDr
#define WRITE_GRUNDr BCM56504_A0_WRITE_GRUNDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GRUNDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GRXCF
 * BLOCKS:   GPORT0
 * DESC:     Receive Control Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_GRXCFr 0x00f0000f

#define BCM56504_A0_GRXCFr_SIZE 4

/*
 * This structure should be used to declare and program GRXCF.
 *
 */
typedef union BCM56504_A0_GRXCFr_s {
	uint32_t v[1];
	uint32_t grxcf[1];
	uint32_t _grxcf;
} BCM56504_A0_GRXCFr_t;

#define BCM56504_A0_GRXCFr_CLR(r) (r).grxcf[0] = 0
#define BCM56504_A0_GRXCFr_SET(r,d) (r).grxcf[0] = d
#define BCM56504_A0_GRXCFr_GET(r) (r).grxcf[0]


/*
 * These macros can be used to access GRXCF.
 *
 */
#define BCM56504_A0_READ_GRXCFr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_GRXCFr,(r._grxcf))
#define BCM56504_A0_WRITE_GRXCFr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_GRXCFr,&(r._grxcf))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRXCFr BCM56504_A0_GRXCFr
#define GRXCFr_SIZE BCM56504_A0_GRXCFr_SIZE
typedef BCM56504_A0_GRXCFr_t GRXCFr_t;
#define GRXCFr_CLR BCM56504_A0_GRXCFr_CLR
#define GRXCFr_SET BCM56504_A0_GRXCFr_SET
#define GRXCFr_GET BCM56504_A0_GRXCFr_GET
#define READ_GRXCFr BCM56504_A0_READ_GRXCFr
#define WRITE_GRXCFr BCM56504_A0_WRITE_GRXCFr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GRXCFr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GRXPF
 * BLOCKS:   GPORT0
 * DESC:     Receive Pause Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_GRXPFr 0x00f00010

#define BCM56504_A0_GRXPFr_SIZE 4

/*
 * This structure should be used to declare and program GRXPF.
 *
 */
typedef union BCM56504_A0_GRXPFr_s {
	uint32_t v[1];
	uint32_t grxpf[1];
	uint32_t _grxpf;
} BCM56504_A0_GRXPFr_t;

#define BCM56504_A0_GRXPFr_CLR(r) (r).grxpf[0] = 0
#define BCM56504_A0_GRXPFr_SET(r,d) (r).grxpf[0] = d
#define BCM56504_A0_GRXPFr_GET(r) (r).grxpf[0]


/*
 * These macros can be used to access GRXPF.
 *
 */
#define BCM56504_A0_READ_GRXPFr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_GRXPFr,(r._grxpf))
#define BCM56504_A0_WRITE_GRXPFr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_GRXPFr,&(r._grxpf))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRXPFr BCM56504_A0_GRXPFr
#define GRXPFr_SIZE BCM56504_A0_GRXPFr_SIZE
typedef BCM56504_A0_GRXPFr_t GRXPFr_t;
#define GRXPFr_CLR BCM56504_A0_GRXPFr_CLR
#define GRXPFr_SET BCM56504_A0_GRXPFr_SET
#define GRXPFr_GET BCM56504_A0_GRXPFr_GET
#define READ_GRXPFr BCM56504_A0_READ_GRXPFr
#define WRITE_GRXPFr BCM56504_A0_WRITE_GRXPFr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GRXPFr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GRXUO
 * BLOCKS:   GPORT0
 * DESC:     Receive Unsupported Opcode Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_GRXUOr 0x00f00011

#define BCM56504_A0_GRXUOr_SIZE 4

/*
 * This structure should be used to declare and program GRXUO.
 *
 */
typedef union BCM56504_A0_GRXUOr_s {
	uint32_t v[1];
	uint32_t grxuo[1];
	uint32_t _grxuo;
} BCM56504_A0_GRXUOr_t;

#define BCM56504_A0_GRXUOr_CLR(r) (r).grxuo[0] = 0
#define BCM56504_A0_GRXUOr_SET(r,d) (r).grxuo[0] = d
#define BCM56504_A0_GRXUOr_GET(r) (r).grxuo[0]


/*
 * These macros can be used to access GRXUO.
 *
 */
#define BCM56504_A0_READ_GRXUOr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_GRXUOr,(r._grxuo))
#define BCM56504_A0_WRITE_GRXUOr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_GRXUOr,&(r._grxuo))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRXUOr BCM56504_A0_GRXUOr
#define GRXUOr_SIZE BCM56504_A0_GRXUOr_SIZE
typedef BCM56504_A0_GRXUOr_t GRXUOr_t;
#define GRXUOr_CLR BCM56504_A0_GRXUOr_CLR
#define GRXUOr_SET BCM56504_A0_GRXUOr_SET
#define GRXUOr_GET BCM56504_A0_GRXUOr_GET
#define READ_GRXUOr BCM56504_A0_READ_GRXUOr
#define WRITE_GRXUOr BCM56504_A0_WRITE_GRXUOr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GRXUOr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GSA0
 * BLOCKS:   GPORT0
 * DESC:     Station Address 31:0
 * SIZE:     32
 * FIELDS:
 *     STAD1            STAD bits 47:16
 *
 ******************************************************************************/
#define BCM56504_A0_GSA0r 0x00f00104

#define BCM56504_A0_GSA0r_SIZE 4

/*
 * This structure should be used to declare and program GSA0.
 *
 */
typedef union BCM56504_A0_GSA0r_s {
	uint32_t v[1];
	uint32_t gsa0[1];
	uint32_t _gsa0;
} BCM56504_A0_GSA0r_t;

#define BCM56504_A0_GSA0r_CLR(r) (r).gsa0[0] = 0
#define BCM56504_A0_GSA0r_SET(r,d) (r).gsa0[0] = d
#define BCM56504_A0_GSA0r_GET(r) (r).gsa0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_GSA0r_STAD1f_GET(r) ((r).gsa0[0])
#define BCM56504_A0_GSA0r_STAD1f_SET(r,f) (r).gsa0[0]=((uint32_t)f)

/*
 * These macros can be used to access GSA0.
 *
 */
#define BCM56504_A0_READ_GSA0r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_GSA0r,(r._gsa0))
#define BCM56504_A0_WRITE_GSA0r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_GSA0r,&(r._gsa0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GSA0r BCM56504_A0_GSA0r
#define GSA0r_SIZE BCM56504_A0_GSA0r_SIZE
typedef BCM56504_A0_GSA0r_t GSA0r_t;
#define GSA0r_CLR BCM56504_A0_GSA0r_CLR
#define GSA0r_SET BCM56504_A0_GSA0r_SET
#define GSA0r_GET BCM56504_A0_GSA0r_GET
#define GSA0r_STAD1f_GET BCM56504_A0_GSA0r_STAD1f_GET
#define GSA0r_STAD1f_SET BCM56504_A0_GSA0r_STAD1f_SET
#define READ_GSA0r BCM56504_A0_READ_GSA0r
#define WRITE_GSA0r BCM56504_A0_WRITE_GSA0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GSA0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GSA1
 * BLOCKS:   GPORT0
 * DESC:     Station Address 47:32
 * SIZE:     32
 * FIELDS:
 *     STAD2            STAD bits 15:0
 *
 ******************************************************************************/
#define BCM56504_A0_GSA1r 0x00f00105

#define BCM56504_A0_GSA1r_SIZE 4

/*
 * This structure should be used to declare and program GSA1.
 *
 */
typedef union BCM56504_A0_GSA1r_s {
	uint32_t v[1];
	uint32_t gsa1[1];
	uint32_t _gsa1;
} BCM56504_A0_GSA1r_t;

#define BCM56504_A0_GSA1r_CLR(r) (r).gsa1[0] = 0
#define BCM56504_A0_GSA1r_SET(r,d) (r).gsa1[0] = d
#define BCM56504_A0_GSA1r_GET(r) (r).gsa1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_GSA1r_STAD2f_GET(r) ((((r).gsa1[0]) >> 16) & 0xffff)
#define BCM56504_A0_GSA1r_STAD2f_SET(r,f) (r).gsa1[0]=(((r).gsa1[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access GSA1.
 *
 */
#define BCM56504_A0_READ_GSA1r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_GSA1r,(r._gsa1))
#define BCM56504_A0_WRITE_GSA1r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_GSA1r,&(r._gsa1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GSA1r BCM56504_A0_GSA1r
#define GSA1r_SIZE BCM56504_A0_GSA1r_SIZE
typedef BCM56504_A0_GSA1r_t GSA1r_t;
#define GSA1r_CLR BCM56504_A0_GSA1r_CLR
#define GSA1r_SET BCM56504_A0_GSA1r_SET
#define GSA1r_GET BCM56504_A0_GSA1r_GET
#define GSA1r_STAD2f_GET BCM56504_A0_GSA1r_STAD2f_GET
#define GSA1r_STAD2f_SET BCM56504_A0_GSA1r_STAD2f_SET
#define READ_GSA1r BCM56504_A0_READ_GSA1r
#define WRITE_GSA1r BCM56504_A0_WRITE_GSA1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GSA1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GT1023
 * BLOCKS:   GPORT0
 * DESC:     Transmit 512 to 1023 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_GT1023r 0x00f00021

#define BCM56504_A0_GT1023r_SIZE 4

/*
 * This structure should be used to declare and program GT1023.
 *
 */
typedef union BCM56504_A0_GT1023r_s {
	uint32_t v[1];
	uint32_t gt1023[1];
	uint32_t _gt1023;
} BCM56504_A0_GT1023r_t;

#define BCM56504_A0_GT1023r_CLR(r) (r).gt1023[0] = 0
#define BCM56504_A0_GT1023r_SET(r,d) (r).gt1023[0] = d
#define BCM56504_A0_GT1023r_GET(r) (r).gt1023[0]


/*
 * These macros can be used to access GT1023.
 *
 */
#define BCM56504_A0_READ_GT1023r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_GT1023r,(r._gt1023))
#define BCM56504_A0_WRITE_GT1023r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_GT1023r,&(r._gt1023))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GT1023r BCM56504_A0_GT1023r
#define GT1023r_SIZE BCM56504_A0_GT1023r_SIZE
typedef BCM56504_A0_GT1023r_t GT1023r_t;
#define GT1023r_CLR BCM56504_A0_GT1023r_CLR
#define GT1023r_SET BCM56504_A0_GT1023r_SET
#define GT1023r_GET BCM56504_A0_GT1023r_GET
#define READ_GT1023r BCM56504_A0_READ_GT1023r
#define WRITE_GT1023r BCM56504_A0_WRITE_GT1023r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GT1023r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GT127
 * BLOCKS:   GPORT0
 * DESC:     Transmit 65 to 127 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_GT127r 0x00f0001e

#define BCM56504_A0_GT127r_SIZE 4

/*
 * This structure should be used to declare and program GT127.
 *
 */
typedef union BCM56504_A0_GT127r_s {
	uint32_t v[1];
	uint32_t gt127[1];
	uint32_t _gt127;
} BCM56504_A0_GT127r_t;

#define BCM56504_A0_GT127r_CLR(r) (r).gt127[0] = 0
#define BCM56504_A0_GT127r_SET(r,d) (r).gt127[0] = d
#define BCM56504_A0_GT127r_GET(r) (r).gt127[0]


/*
 * These macros can be used to access GT127.
 *
 */
#define BCM56504_A0_READ_GT127r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_GT127r,(r._gt127))
#define BCM56504_A0_WRITE_GT127r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_GT127r,&(r._gt127))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GT127r BCM56504_A0_GT127r
#define GT127r_SIZE BCM56504_A0_GT127r_SIZE
typedef BCM56504_A0_GT127r_t GT127r_t;
#define GT127r_CLR BCM56504_A0_GT127r_CLR
#define GT127r_SET BCM56504_A0_GT127r_SET
#define GT127r_GET BCM56504_A0_GT127r_GET
#define READ_GT127r BCM56504_A0_READ_GT127r
#define WRITE_GT127r BCM56504_A0_WRITE_GT127r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GT127r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GT1518
 * BLOCKS:   GPORT0
 * DESC:     Transmit 1024 to 1518 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_GT1518r 0x00f00022

#define BCM56504_A0_GT1518r_SIZE 4

/*
 * This structure should be used to declare and program GT1518.
 *
 */
typedef union BCM56504_A0_GT1518r_s {
	uint32_t v[1];
	uint32_t gt1518[1];
	uint32_t _gt1518;
} BCM56504_A0_GT1518r_t;

#define BCM56504_A0_GT1518r_CLR(r) (r).gt1518[0] = 0
#define BCM56504_A0_GT1518r_SET(r,d) (r).gt1518[0] = d
#define BCM56504_A0_GT1518r_GET(r) (r).gt1518[0]


/*
 * These macros can be used to access GT1518.
 *
 */
#define BCM56504_A0_READ_GT1518r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_GT1518r,(r._gt1518))
#define BCM56504_A0_WRITE_GT1518r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_GT1518r,&(r._gt1518))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GT1518r BCM56504_A0_GT1518r
#define GT1518r_SIZE BCM56504_A0_GT1518r_SIZE
typedef BCM56504_A0_GT1518r_t GT1518r_t;
#define GT1518r_CLR BCM56504_A0_GT1518r_CLR
#define GT1518r_SET BCM56504_A0_GT1518r_SET
#define GT1518r_GET BCM56504_A0_GT1518r_GET
#define READ_GT1518r BCM56504_A0_READ_GT1518r
#define WRITE_GT1518r BCM56504_A0_WRITE_GT1518r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GT1518r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GT2047
 * BLOCKS:   GPORT0
 * DESC:     Transmit 1519 to 2047 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_GT2047r 0x00f00024

#define BCM56504_A0_GT2047r_SIZE 4

/*
 * This structure should be used to declare and program GT2047.
 *
 */
typedef union BCM56504_A0_GT2047r_s {
	uint32_t v[1];
	uint32_t gt2047[1];
	uint32_t _gt2047;
} BCM56504_A0_GT2047r_t;

#define BCM56504_A0_GT2047r_CLR(r) (r).gt2047[0] = 0
#define BCM56504_A0_GT2047r_SET(r,d) (r).gt2047[0] = d
#define BCM56504_A0_GT2047r_GET(r) (r).gt2047[0]


/*
 * These macros can be used to access GT2047.
 *
 */
#define BCM56504_A0_READ_GT2047r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_GT2047r,(r._gt2047))
#define BCM56504_A0_WRITE_GT2047r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_GT2047r,&(r._gt2047))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GT2047r BCM56504_A0_GT2047r
#define GT2047r_SIZE BCM56504_A0_GT2047r_SIZE
typedef BCM56504_A0_GT2047r_t GT2047r_t;
#define GT2047r_CLR BCM56504_A0_GT2047r_CLR
#define GT2047r_SET BCM56504_A0_GT2047r_SET
#define GT2047r_GET BCM56504_A0_GT2047r_GET
#define READ_GT2047r BCM56504_A0_READ_GT2047r
#define WRITE_GT2047r BCM56504_A0_WRITE_GT2047r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GT2047r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GT255
 * BLOCKS:   GPORT0
 * DESC:     Transmit 128 to 255 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_GT255r 0x00f0001f

#define BCM56504_A0_GT255r_SIZE 4

/*
 * This structure should be used to declare and program GT255.
 *
 */
typedef union BCM56504_A0_GT255r_s {
	uint32_t v[1];
	uint32_t gt255[1];
	uint32_t _gt255;
} BCM56504_A0_GT255r_t;

#define BCM56504_A0_GT255r_CLR(r) (r).gt255[0] = 0
#define BCM56504_A0_GT255r_SET(r,d) (r).gt255[0] = d
#define BCM56504_A0_GT255r_GET(r) (r).gt255[0]


/*
 * These macros can be used to access GT255.
 *
 */
#define BCM56504_A0_READ_GT255r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_GT255r,(r._gt255))
#define BCM56504_A0_WRITE_GT255r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_GT255r,&(r._gt255))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GT255r BCM56504_A0_GT255r
#define GT255r_SIZE BCM56504_A0_GT255r_SIZE
typedef BCM56504_A0_GT255r_t GT255r_t;
#define GT255r_CLR BCM56504_A0_GT255r_CLR
#define GT255r_SET BCM56504_A0_GT255r_SET
#define GT255r_GET BCM56504_A0_GT255r_GET
#define READ_GT255r BCM56504_A0_READ_GT255r
#define WRITE_GT255r BCM56504_A0_WRITE_GT255r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GT255r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GT4095
 * BLOCKS:   GPORT0
 * DESC:     Transmit 2048 to 4095 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_GT4095r 0x00f00025

#define BCM56504_A0_GT4095r_SIZE 4

/*
 * This structure should be used to declare and program GT4095.
 *
 */
typedef union BCM56504_A0_GT4095r_s {
	uint32_t v[1];
	uint32_t gt4095[1];
	uint32_t _gt4095;
} BCM56504_A0_GT4095r_t;

#define BCM56504_A0_GT4095r_CLR(r) (r).gt4095[0] = 0
#define BCM56504_A0_GT4095r_SET(r,d) (r).gt4095[0] = d
#define BCM56504_A0_GT4095r_GET(r) (r).gt4095[0]


/*
 * These macros can be used to access GT4095.
 *
 */
#define BCM56504_A0_READ_GT4095r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_GT4095r,(r._gt4095))
#define BCM56504_A0_WRITE_GT4095r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_GT4095r,&(r._gt4095))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GT4095r BCM56504_A0_GT4095r
#define GT4095r_SIZE BCM56504_A0_GT4095r_SIZE
typedef BCM56504_A0_GT4095r_t GT4095r_t;
#define GT4095r_CLR BCM56504_A0_GT4095r_CLR
#define GT4095r_SET BCM56504_A0_GT4095r_SET
#define GT4095r_GET BCM56504_A0_GT4095r_GET
#define READ_GT4095r BCM56504_A0_READ_GT4095r
#define WRITE_GT4095r BCM56504_A0_WRITE_GT4095r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GT4095r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GT511
 * BLOCKS:   GPORT0
 * DESC:     Transmit 256 to 511 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_GT511r 0x00f00020

#define BCM56504_A0_GT511r_SIZE 4

/*
 * This structure should be used to declare and program GT511.
 *
 */
typedef union BCM56504_A0_GT511r_s {
	uint32_t v[1];
	uint32_t gt511[1];
	uint32_t _gt511;
} BCM56504_A0_GT511r_t;

#define BCM56504_A0_GT511r_CLR(r) (r).gt511[0] = 0
#define BCM56504_A0_GT511r_SET(r,d) (r).gt511[0] = d
#define BCM56504_A0_GT511r_GET(r) (r).gt511[0]


/*
 * These macros can be used to access GT511.
 *
 */
#define BCM56504_A0_READ_GT511r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_GT511r,(r._gt511))
#define BCM56504_A0_WRITE_GT511r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_GT511r,&(r._gt511))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GT511r BCM56504_A0_GT511r
#define GT511r_SIZE BCM56504_A0_GT511r_SIZE
typedef BCM56504_A0_GT511r_t GT511r_t;
#define GT511r_CLR BCM56504_A0_GT511r_CLR
#define GT511r_SET BCM56504_A0_GT511r_SET
#define GT511r_GET BCM56504_A0_GT511r_GET
#define READ_GT511r BCM56504_A0_READ_GT511r
#define WRITE_GT511r BCM56504_A0_WRITE_GT511r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GT511r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GT64
 * BLOCKS:   GPORT0
 * DESC:     Transmit 64 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_GT64r 0x00f0001d

#define BCM56504_A0_GT64r_SIZE 4

/*
 * This structure should be used to declare and program GT64.
 *
 */
typedef union BCM56504_A0_GT64r_s {
	uint32_t v[1];
	uint32_t gt64[1];
	uint32_t _gt64;
} BCM56504_A0_GT64r_t;

#define BCM56504_A0_GT64r_CLR(r) (r).gt64[0] = 0
#define BCM56504_A0_GT64r_SET(r,d) (r).gt64[0] = d
#define BCM56504_A0_GT64r_GET(r) (r).gt64[0]


/*
 * These macros can be used to access GT64.
 *
 */
#define BCM56504_A0_READ_GT64r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_GT64r,(r._gt64))
#define BCM56504_A0_WRITE_GT64r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_GT64r,&(r._gt64))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GT64r BCM56504_A0_GT64r
#define GT64r_SIZE BCM56504_A0_GT64r_SIZE
typedef BCM56504_A0_GT64r_t GT64r_t;
#define GT64r_CLR BCM56504_A0_GT64r_CLR
#define GT64r_SET BCM56504_A0_GT64r_SET
#define GT64r_GET BCM56504_A0_GT64r_GET
#define READ_GT64r BCM56504_A0_READ_GT64r
#define WRITE_GT64r BCM56504_A0_WRITE_GT64r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GT64r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GT9216
 * BLOCKS:   GPORT0
 * DESC:     Transmit 4096 to 9216 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_GT9216r 0x00f00026

#define BCM56504_A0_GT9216r_SIZE 4

/*
 * This structure should be used to declare and program GT9216.
 *
 */
typedef union BCM56504_A0_GT9216r_s {
	uint32_t v[1];
	uint32_t gt9216[1];
	uint32_t _gt9216;
} BCM56504_A0_GT9216r_t;

#define BCM56504_A0_GT9216r_CLR(r) (r).gt9216[0] = 0
#define BCM56504_A0_GT9216r_SET(r,d) (r).gt9216[0] = d
#define BCM56504_A0_GT9216r_GET(r) (r).gt9216[0]


/*
 * These macros can be used to access GT9216.
 *
 */
#define BCM56504_A0_READ_GT9216r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_GT9216r,(r._gt9216))
#define BCM56504_A0_WRITE_GT9216r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_GT9216r,&(r._gt9216))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GT9216r BCM56504_A0_GT9216r
#define GT9216r_SIZE BCM56504_A0_GT9216r_SIZE
typedef BCM56504_A0_GT9216r_t GT9216r_t;
#define GT9216r_CLR BCM56504_A0_GT9216r_CLR
#define GT9216r_SET BCM56504_A0_GT9216r_SET
#define GT9216r_GET BCM56504_A0_GT9216r_GET
#define READ_GT9216r BCM56504_A0_READ_GT9216r
#define WRITE_GT9216r BCM56504_A0_WRITE_GT9216r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GT9216r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GTBCA
 * BLOCKS:   GPORT0
 * DESC:     Transmit Broadcast Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_GTBCAr 0x00f00029

#define BCM56504_A0_GTBCAr_SIZE 4

/*
 * This structure should be used to declare and program GTBCA.
 *
 */
typedef union BCM56504_A0_GTBCAr_s {
	uint32_t v[1];
	uint32_t gtbca[1];
	uint32_t _gtbca;
} BCM56504_A0_GTBCAr_t;

#define BCM56504_A0_GTBCAr_CLR(r) (r).gtbca[0] = 0
#define BCM56504_A0_GTBCAr_SET(r,d) (r).gtbca[0] = d
#define BCM56504_A0_GTBCAr_GET(r) (r).gtbca[0]


/*
 * These macros can be used to access GTBCA.
 *
 */
#define BCM56504_A0_READ_GTBCAr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_GTBCAr,(r._gtbca))
#define BCM56504_A0_WRITE_GTBCAr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_GTBCAr,&(r._gtbca))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTBCAr BCM56504_A0_GTBCAr
#define GTBCAr_SIZE BCM56504_A0_GTBCAr_SIZE
typedef BCM56504_A0_GTBCAr_t GTBCAr_t;
#define GTBCAr_CLR BCM56504_A0_GTBCAr_CLR
#define GTBCAr_SET BCM56504_A0_GTBCAr_SET
#define GTBCAr_GET BCM56504_A0_GTBCAr_GET
#define READ_GTBCAr BCM56504_A0_READ_GTBCAr
#define WRITE_GTBCAr BCM56504_A0_WRITE_GTBCAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GTBCAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GTBYT
 * BLOCKS:   GPORT0
 * DESC:     Transmit Byte Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_GTBYTr 0x00f00037

#define BCM56504_A0_GTBYTr_SIZE 4

/*
 * This structure should be used to declare and program GTBYT.
 *
 */
typedef union BCM56504_A0_GTBYTr_s {
	uint32_t v[1];
	uint32_t gtbyt[1];
	uint32_t _gtbyt;
} BCM56504_A0_GTBYTr_t;

#define BCM56504_A0_GTBYTr_CLR(r) (r).gtbyt[0] = 0
#define BCM56504_A0_GTBYTr_SET(r,d) (r).gtbyt[0] = d
#define BCM56504_A0_GTBYTr_GET(r) (r).gtbyt[0]


/*
 * These macros can be used to access GTBYT.
 *
 */
#define BCM56504_A0_READ_GTBYTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_GTBYTr,(r._gtbyt))
#define BCM56504_A0_WRITE_GTBYTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_GTBYTr,&(r._gtbyt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTBYTr BCM56504_A0_GTBYTr
#define GTBYTr_SIZE BCM56504_A0_GTBYTr_SIZE
typedef BCM56504_A0_GTBYTr_t GTBYTr_t;
#define GTBYTr_CLR BCM56504_A0_GTBYTr_CLR
#define GTBYTr_SET BCM56504_A0_GTBYTr_SET
#define GTBYTr_GET BCM56504_A0_GTBYTr_GET
#define READ_GTBYTr BCM56504_A0_READ_GTBYTr
#define WRITE_GTBYTr BCM56504_A0_WRITE_GTBYTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GTBYTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GTDFR
 * BLOCKS:   GPORT0
 * DESC:     Transmit Single Deferral Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_GTDFRr 0x00f0002f

#define BCM56504_A0_GTDFRr_SIZE 4

/*
 * This structure should be used to declare and program GTDFR.
 *
 */
typedef union BCM56504_A0_GTDFRr_s {
	uint32_t v[1];
	uint32_t gtdfr[1];
	uint32_t _gtdfr;
} BCM56504_A0_GTDFRr_t;

#define BCM56504_A0_GTDFRr_CLR(r) (r).gtdfr[0] = 0
#define BCM56504_A0_GTDFRr_SET(r,d) (r).gtdfr[0] = d
#define BCM56504_A0_GTDFRr_GET(r) (r).gtdfr[0]


/*
 * These macros can be used to access GTDFR.
 *
 */
#define BCM56504_A0_READ_GTDFRr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_GTDFRr,(r._gtdfr))
#define BCM56504_A0_WRITE_GTDFRr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_GTDFRr,&(r._gtdfr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTDFRr BCM56504_A0_GTDFRr
#define GTDFRr_SIZE BCM56504_A0_GTDFRr_SIZE
typedef BCM56504_A0_GTDFRr_t GTDFRr_t;
#define GTDFRr_CLR BCM56504_A0_GTDFRr_CLR
#define GTDFRr_SET BCM56504_A0_GTDFRr_SET
#define GTDFRr_GET BCM56504_A0_GTDFRr_GET
#define READ_GTDFRr BCM56504_A0_READ_GTDFRr
#define WRITE_GTDFRr BCM56504_A0_WRITE_GTDFRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GTDFRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GTEDF
 * BLOCKS:   GPORT0
 * DESC:     Transmit Multiple Deferral Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_GTEDFr 0x00f00030

#define BCM56504_A0_GTEDFr_SIZE 4

/*
 * This structure should be used to declare and program GTEDF.
 *
 */
typedef union BCM56504_A0_GTEDFr_s {
	uint32_t v[1];
	uint32_t gtedf[1];
	uint32_t _gtedf;
} BCM56504_A0_GTEDFr_t;

#define BCM56504_A0_GTEDFr_CLR(r) (r).gtedf[0] = 0
#define BCM56504_A0_GTEDFr_SET(r,d) (r).gtedf[0] = d
#define BCM56504_A0_GTEDFr_GET(r) (r).gtedf[0]


/*
 * These macros can be used to access GTEDF.
 *
 */
#define BCM56504_A0_READ_GTEDFr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_GTEDFr,(r._gtedf))
#define BCM56504_A0_WRITE_GTEDFr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_GTEDFr,&(r._gtedf))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTEDFr BCM56504_A0_GTEDFr
#define GTEDFr_SIZE BCM56504_A0_GTEDFr_SIZE
typedef BCM56504_A0_GTEDFr_t GTEDFr_t;
#define GTEDFr_CLR BCM56504_A0_GTEDFr_CLR
#define GTEDFr_SET BCM56504_A0_GTEDFr_SET
#define GTEDFr_GET BCM56504_A0_GTEDFr_GET
#define READ_GTEDFr BCM56504_A0_READ_GTEDFr
#define WRITE_GTEDFr BCM56504_A0_WRITE_GTEDFr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GTEDFr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GTFCS
 * BLOCKS:   GPORT0
 * DESC:     Transmit FCS Error Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_GTFCSr 0x00f0002c

#define BCM56504_A0_GTFCSr_SIZE 4

/*
 * This structure should be used to declare and program GTFCS.
 *
 */
typedef union BCM56504_A0_GTFCSr_s {
	uint32_t v[1];
	uint32_t gtfcs[1];
	uint32_t _gtfcs;
} BCM56504_A0_GTFCSr_t;

#define BCM56504_A0_GTFCSr_CLR(r) (r).gtfcs[0] = 0
#define BCM56504_A0_GTFCSr_SET(r,d) (r).gtfcs[0] = d
#define BCM56504_A0_GTFCSr_GET(r) (r).gtfcs[0]


/*
 * These macros can be used to access GTFCS.
 *
 */
#define BCM56504_A0_READ_GTFCSr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_GTFCSr,(r._gtfcs))
#define BCM56504_A0_WRITE_GTFCSr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_GTFCSr,&(r._gtfcs))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTFCSr BCM56504_A0_GTFCSr
#define GTFCSr_SIZE BCM56504_A0_GTFCSr_SIZE
typedef BCM56504_A0_GTFCSr_t GTFCSr_t;
#define GTFCSr_CLR BCM56504_A0_GTFCSr_CLR
#define GTFCSr_SET BCM56504_A0_GTFCSr_SET
#define GTFCSr_GET BCM56504_A0_GTFCSr_GET
#define READ_GTFCSr BCM56504_A0_READ_GTFCSr
#define WRITE_GTFCSr BCM56504_A0_WRITE_GTFCSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GTFCSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GTFRG
 * BLOCKS:   GPORT0
 * DESC:     Transmit Fragment Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_GTFRGr 0x00f00035

#define BCM56504_A0_GTFRGr_SIZE 4

/*
 * This structure should be used to declare and program GTFRG.
 *
 */
typedef union BCM56504_A0_GTFRGr_s {
	uint32_t v[1];
	uint32_t gtfrg[1];
	uint32_t _gtfrg;
} BCM56504_A0_GTFRGr_t;

#define BCM56504_A0_GTFRGr_CLR(r) (r).gtfrg[0] = 0
#define BCM56504_A0_GTFRGr_SET(r,d) (r).gtfrg[0] = d
#define BCM56504_A0_GTFRGr_GET(r) (r).gtfrg[0]


/*
 * These macros can be used to access GTFRG.
 *
 */
#define BCM56504_A0_READ_GTFRGr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_GTFRGr,(r._gtfrg))
#define BCM56504_A0_WRITE_GTFRGr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_GTFRGr,&(r._gtfrg))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTFRGr BCM56504_A0_GTFRGr
#define GTFRGr_SIZE BCM56504_A0_GTFRGr_SIZE
typedef BCM56504_A0_GTFRGr_t GTFRGr_t;
#define GTFRGr_CLR BCM56504_A0_GTFRGr_CLR
#define GTFRGr_SET BCM56504_A0_GTFRGr_SET
#define GTFRGr_GET BCM56504_A0_GTFRGr_GET
#define READ_GTFRGr BCM56504_A0_READ_GTFRGr
#define WRITE_GTFRGr BCM56504_A0_WRITE_GTFRGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GTFRGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GTJBR
 * BLOCKS:   GPORT0
 * DESC:     Transmit Jabber Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_GTJBRr 0x00f0002b

#define BCM56504_A0_GTJBRr_SIZE 4

/*
 * This structure should be used to declare and program GTJBR.
 *
 */
typedef union BCM56504_A0_GTJBRr_s {
	uint32_t v[1];
	uint32_t gtjbr[1];
	uint32_t _gtjbr;
} BCM56504_A0_GTJBRr_t;

#define BCM56504_A0_GTJBRr_CLR(r) (r).gtjbr[0] = 0
#define BCM56504_A0_GTJBRr_SET(r,d) (r).gtjbr[0] = d
#define BCM56504_A0_GTJBRr_GET(r) (r).gtjbr[0]


/*
 * These macros can be used to access GTJBR.
 *
 */
#define BCM56504_A0_READ_GTJBRr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_GTJBRr,(r._gtjbr))
#define BCM56504_A0_WRITE_GTJBRr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_GTJBRr,&(r._gtjbr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTJBRr BCM56504_A0_GTJBRr
#define GTJBRr_SIZE BCM56504_A0_GTJBRr_SIZE
typedef BCM56504_A0_GTJBRr_t GTJBRr_t;
#define GTJBRr_CLR BCM56504_A0_GTJBRr_CLR
#define GTJBRr_SET BCM56504_A0_GTJBRr_SET
#define GTJBRr_GET BCM56504_A0_GTJBRr_GET
#define READ_GTJBRr BCM56504_A0_READ_GTJBRr
#define WRITE_GTJBRr BCM56504_A0_WRITE_GTJBRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GTJBRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GTLCL
 * BLOCKS:   GPORT0
 * DESC:     Transmit Late Collision Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_GTLCLr 0x00f00033

#define BCM56504_A0_GTLCLr_SIZE 4

/*
 * This structure should be used to declare and program GTLCL.
 *
 */
typedef union BCM56504_A0_GTLCLr_s {
	uint32_t v[1];
	uint32_t gtlcl[1];
	uint32_t _gtlcl;
} BCM56504_A0_GTLCLr_t;

#define BCM56504_A0_GTLCLr_CLR(r) (r).gtlcl[0] = 0
#define BCM56504_A0_GTLCLr_SET(r,d) (r).gtlcl[0] = d
#define BCM56504_A0_GTLCLr_GET(r) (r).gtlcl[0]


/*
 * These macros can be used to access GTLCL.
 *
 */
#define BCM56504_A0_READ_GTLCLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_GTLCLr,(r._gtlcl))
#define BCM56504_A0_WRITE_GTLCLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_GTLCLr,&(r._gtlcl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTLCLr BCM56504_A0_GTLCLr
#define GTLCLr_SIZE BCM56504_A0_GTLCLr_SIZE
typedef BCM56504_A0_GTLCLr_t GTLCLr_t;
#define GTLCLr_CLR BCM56504_A0_GTLCLr_CLR
#define GTLCLr_SET BCM56504_A0_GTLCLr_SET
#define GTLCLr_GET BCM56504_A0_GTLCLr_GET
#define READ_GTLCLr BCM56504_A0_READ_GTLCLr
#define WRITE_GTLCLr BCM56504_A0_WRITE_GTLCLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GTLCLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GTMCA
 * BLOCKS:   GPORT0
 * DESC:     Transmit Multicast Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_GTMCAr 0x00f00028

#define BCM56504_A0_GTMCAr_SIZE 4

/*
 * This structure should be used to declare and program GTMCA.
 *
 */
typedef union BCM56504_A0_GTMCAr_s {
	uint32_t v[1];
	uint32_t gtmca[1];
	uint32_t _gtmca;
} BCM56504_A0_GTMCAr_t;

#define BCM56504_A0_GTMCAr_CLR(r) (r).gtmca[0] = 0
#define BCM56504_A0_GTMCAr_SET(r,d) (r).gtmca[0] = d
#define BCM56504_A0_GTMCAr_GET(r) (r).gtmca[0]


/*
 * These macros can be used to access GTMCA.
 *
 */
#define BCM56504_A0_READ_GTMCAr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_GTMCAr,(r._gtmca))
#define BCM56504_A0_WRITE_GTMCAr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_GTMCAr,&(r._gtmca))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTMCAr BCM56504_A0_GTMCAr
#define GTMCAr_SIZE BCM56504_A0_GTMCAr_SIZE
typedef BCM56504_A0_GTMCAr_t GTMCAr_t;
#define GTMCAr_CLR BCM56504_A0_GTMCAr_CLR
#define GTMCAr_SET BCM56504_A0_GTMCAr_SET
#define GTMCAr_GET BCM56504_A0_GTMCAr_GET
#define READ_GTMCAr BCM56504_A0_READ_GTMCAr
#define WRITE_GTMCAr BCM56504_A0_WRITE_GTMCAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GTMCAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GTMCL
 * BLOCKS:   GPORT0
 * DESC:     Transmit Multiple Collision Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_GTMCLr 0x00f00032

#define BCM56504_A0_GTMCLr_SIZE 4

/*
 * This structure should be used to declare and program GTMCL.
 *
 */
typedef union BCM56504_A0_GTMCLr_s {
	uint32_t v[1];
	uint32_t gtmcl[1];
	uint32_t _gtmcl;
} BCM56504_A0_GTMCLr_t;

#define BCM56504_A0_GTMCLr_CLR(r) (r).gtmcl[0] = 0
#define BCM56504_A0_GTMCLr_SET(r,d) (r).gtmcl[0] = d
#define BCM56504_A0_GTMCLr_GET(r) (r).gtmcl[0]


/*
 * These macros can be used to access GTMCL.
 *
 */
#define BCM56504_A0_READ_GTMCLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_GTMCLr,(r._gtmcl))
#define BCM56504_A0_WRITE_GTMCLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_GTMCLr,&(r._gtmcl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTMCLr BCM56504_A0_GTMCLr
#define GTMCLr_SIZE BCM56504_A0_GTMCLr_SIZE
typedef BCM56504_A0_GTMCLr_t GTMCLr_t;
#define GTMCLr_CLR BCM56504_A0_GTMCLr_CLR
#define GTMCLr_SET BCM56504_A0_GTMCLr_SET
#define GTMCLr_GET BCM56504_A0_GTMCLr_GET
#define READ_GTMCLr BCM56504_A0_READ_GTMCLr
#define WRITE_GTMCLr BCM56504_A0_WRITE_GTMCLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GTMCLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GTMGV
 * BLOCKS:   GPORT0
 * DESC:     Transmit 1519 to 1522 Byte Good VLAN Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_GTMGVr 0x00f00023

#define BCM56504_A0_GTMGVr_SIZE 4

/*
 * This structure should be used to declare and program GTMGV.
 *
 */
typedef union BCM56504_A0_GTMGVr_s {
	uint32_t v[1];
	uint32_t gtmgv[1];
	uint32_t _gtmgv;
} BCM56504_A0_GTMGVr_t;

#define BCM56504_A0_GTMGVr_CLR(r) (r).gtmgv[0] = 0
#define BCM56504_A0_GTMGVr_SET(r,d) (r).gtmgv[0] = d
#define BCM56504_A0_GTMGVr_GET(r) (r).gtmgv[0]


/*
 * These macros can be used to access GTMGV.
 *
 */
#define BCM56504_A0_READ_GTMGVr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_GTMGVr,(r._gtmgv))
#define BCM56504_A0_WRITE_GTMGVr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_GTMGVr,&(r._gtmgv))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTMGVr BCM56504_A0_GTMGVr
#define GTMGVr_SIZE BCM56504_A0_GTMGVr_SIZE
typedef BCM56504_A0_GTMGVr_t GTMGVr_t;
#define GTMGVr_CLR BCM56504_A0_GTMGVr_CLR
#define GTMGVr_SET BCM56504_A0_GTMGVr_SET
#define GTMGVr_GET BCM56504_A0_GTMGVr_GET
#define READ_GTMGVr BCM56504_A0_READ_GTMGVr
#define WRITE_GTMGVr BCM56504_A0_WRITE_GTMGVr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GTMGVr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GTNCL
 * BLOCKS:   GPORT0
 * DESC:     Transmit Total Collision Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_GTNCLr 0x00f00036

#define BCM56504_A0_GTNCLr_SIZE 4

/*
 * This structure should be used to declare and program GTNCL.
 *
 */
typedef union BCM56504_A0_GTNCLr_s {
	uint32_t v[1];
	uint32_t gtncl[1];
	uint32_t _gtncl;
} BCM56504_A0_GTNCLr_t;

#define BCM56504_A0_GTNCLr_CLR(r) (r).gtncl[0] = 0
#define BCM56504_A0_GTNCLr_SET(r,d) (r).gtncl[0] = d
#define BCM56504_A0_GTNCLr_GET(r) (r).gtncl[0]


/*
 * These macros can be used to access GTNCL.
 *
 */
#define BCM56504_A0_READ_GTNCLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_GTNCLr,(r._gtncl))
#define BCM56504_A0_WRITE_GTNCLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_GTNCLr,&(r._gtncl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTNCLr BCM56504_A0_GTNCLr
#define GTNCLr_SIZE BCM56504_A0_GTNCLr_SIZE
typedef BCM56504_A0_GTNCLr_t GTNCLr_t;
#define GTNCLr_CLR BCM56504_A0_GTNCLr_CLR
#define GTNCLr_SET BCM56504_A0_GTNCLr_SET
#define GTNCLr_GET BCM56504_A0_GTNCLr_GET
#define READ_GTNCLr BCM56504_A0_READ_GTNCLr
#define WRITE_GTNCLr BCM56504_A0_WRITE_GTNCLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GTNCLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GTOVR
 * BLOCKS:   GPORT0
 * DESC:     Transmit Oversize Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_GTOVRr 0x00f0002e

#define BCM56504_A0_GTOVRr_SIZE 4

/*
 * This structure should be used to declare and program GTOVR.
 *
 */
typedef union BCM56504_A0_GTOVRr_s {
	uint32_t v[1];
	uint32_t gtovr[1];
	uint32_t _gtovr;
} BCM56504_A0_GTOVRr_t;

#define BCM56504_A0_GTOVRr_CLR(r) (r).gtovr[0] = 0
#define BCM56504_A0_GTOVRr_SET(r,d) (r).gtovr[0] = d
#define BCM56504_A0_GTOVRr_GET(r) (r).gtovr[0]


/*
 * These macros can be used to access GTOVR.
 *
 */
#define BCM56504_A0_READ_GTOVRr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_GTOVRr,(r._gtovr))
#define BCM56504_A0_WRITE_GTOVRr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_GTOVRr,&(r._gtovr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTOVRr BCM56504_A0_GTOVRr
#define GTOVRr_SIZE BCM56504_A0_GTOVRr_SIZE
typedef BCM56504_A0_GTOVRr_t GTOVRr_t;
#define GTOVRr_CLR BCM56504_A0_GTOVRr_CLR
#define GTOVRr_SET BCM56504_A0_GTOVRr_SET
#define GTOVRr_GET BCM56504_A0_GTOVRr_GET
#define READ_GTOVRr BCM56504_A0_READ_GTOVRr
#define WRITE_GTOVRr BCM56504_A0_WRITE_GTOVRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GTOVRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GTPKT
 * BLOCKS:   GPORT0
 * DESC:     Transmit frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_GTPKTr 0x00f00027

#define BCM56504_A0_GTPKTr_SIZE 4

/*
 * This structure should be used to declare and program GTPKT.
 *
 */
typedef union BCM56504_A0_GTPKTr_s {
	uint32_t v[1];
	uint32_t gtpkt[1];
	uint32_t _gtpkt;
} BCM56504_A0_GTPKTr_t;

#define BCM56504_A0_GTPKTr_CLR(r) (r).gtpkt[0] = 0
#define BCM56504_A0_GTPKTr_SET(r,d) (r).gtpkt[0] = d
#define BCM56504_A0_GTPKTr_GET(r) (r).gtpkt[0]


/*
 * These macros can be used to access GTPKT.
 *
 */
#define BCM56504_A0_READ_GTPKTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_GTPKTr,(r._gtpkt))
#define BCM56504_A0_WRITE_GTPKTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_GTPKTr,&(r._gtpkt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTPKTr BCM56504_A0_GTPKTr
#define GTPKTr_SIZE BCM56504_A0_GTPKTr_SIZE
typedef BCM56504_A0_GTPKTr_t GTPKTr_t;
#define GTPKTr_CLR BCM56504_A0_GTPKTr_CLR
#define GTPKTr_SET BCM56504_A0_GTPKTr_SET
#define GTPKTr_GET BCM56504_A0_GTPKTr_GET
#define READ_GTPKTr BCM56504_A0_READ_GTPKTr
#define WRITE_GTPKTr BCM56504_A0_WRITE_GTPKTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GTPKTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GTSCL
 * BLOCKS:   GPORT0
 * DESC:     Transmit Single Collision Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_GTSCLr 0x00f00031

#define BCM56504_A0_GTSCLr_SIZE 4

/*
 * This structure should be used to declare and program GTSCL.
 *
 */
typedef union BCM56504_A0_GTSCLr_s {
	uint32_t v[1];
	uint32_t gtscl[1];
	uint32_t _gtscl;
} BCM56504_A0_GTSCLr_t;

#define BCM56504_A0_GTSCLr_CLR(r) (r).gtscl[0] = 0
#define BCM56504_A0_GTSCLr_SET(r,d) (r).gtscl[0] = d
#define BCM56504_A0_GTSCLr_GET(r) (r).gtscl[0]


/*
 * These macros can be used to access GTSCL.
 *
 */
#define BCM56504_A0_READ_GTSCLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_GTSCLr,(r._gtscl))
#define BCM56504_A0_WRITE_GTSCLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_GTSCLr,&(r._gtscl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTSCLr BCM56504_A0_GTSCLr
#define GTSCLr_SIZE BCM56504_A0_GTSCLr_SIZE
typedef BCM56504_A0_GTSCLr_t GTSCLr_t;
#define GTSCLr_CLR BCM56504_A0_GTSCLr_CLR
#define GTSCLr_SET BCM56504_A0_GTSCLr_SET
#define GTSCLr_GET BCM56504_A0_GTSCLr_GET
#define READ_GTSCLr BCM56504_A0_READ_GTSCLr
#define WRITE_GTSCLr BCM56504_A0_WRITE_GTSCLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GTSCLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GTXCF
 * BLOCKS:   GPORT0
 * DESC:     Transmit Control Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_GTXCFr 0x00f0002d

#define BCM56504_A0_GTXCFr_SIZE 4

/*
 * This structure should be used to declare and program GTXCF.
 *
 */
typedef union BCM56504_A0_GTXCFr_s {
	uint32_t v[1];
	uint32_t gtxcf[1];
	uint32_t _gtxcf;
} BCM56504_A0_GTXCFr_t;

#define BCM56504_A0_GTXCFr_CLR(r) (r).gtxcf[0] = 0
#define BCM56504_A0_GTXCFr_SET(r,d) (r).gtxcf[0] = d
#define BCM56504_A0_GTXCFr_GET(r) (r).gtxcf[0]


/*
 * These macros can be used to access GTXCF.
 *
 */
#define BCM56504_A0_READ_GTXCFr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_GTXCFr,(r._gtxcf))
#define BCM56504_A0_WRITE_GTXCFr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_GTXCFr,&(r._gtxcf))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTXCFr BCM56504_A0_GTXCFr
#define GTXCFr_SIZE BCM56504_A0_GTXCFr_SIZE
typedef BCM56504_A0_GTXCFr_t GTXCFr_t;
#define GTXCFr_CLR BCM56504_A0_GTXCFr_CLR
#define GTXCFr_SET BCM56504_A0_GTXCFr_SET
#define GTXCFr_GET BCM56504_A0_GTXCFr_GET
#define READ_GTXCFr BCM56504_A0_READ_GTXCFr
#define WRITE_GTXCFr BCM56504_A0_WRITE_GTXCFr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GTXCFr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GTXCL
 * BLOCKS:   GPORT0
 * DESC:     Transmit Excessive Collision Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_GTXCLr 0x00f00034

#define BCM56504_A0_GTXCLr_SIZE 4

/*
 * This structure should be used to declare and program GTXCL.
 *
 */
typedef union BCM56504_A0_GTXCLr_s {
	uint32_t v[1];
	uint32_t gtxcl[1];
	uint32_t _gtxcl;
} BCM56504_A0_GTXCLr_t;

#define BCM56504_A0_GTXCLr_CLR(r) (r).gtxcl[0] = 0
#define BCM56504_A0_GTXCLr_SET(r,d) (r).gtxcl[0] = d
#define BCM56504_A0_GTXCLr_GET(r) (r).gtxcl[0]


/*
 * These macros can be used to access GTXCL.
 *
 */
#define BCM56504_A0_READ_GTXCLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_GTXCLr,(r._gtxcl))
#define BCM56504_A0_WRITE_GTXCLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_GTXCLr,&(r._gtxcl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTXCLr BCM56504_A0_GTXCLr
#define GTXCLr_SIZE BCM56504_A0_GTXCLr_SIZE
typedef BCM56504_A0_GTXCLr_t GTXCLr_t;
#define GTXCLr_CLR BCM56504_A0_GTXCLr_CLR
#define GTXCLr_SET BCM56504_A0_GTXCLr_SET
#define GTXCLr_GET BCM56504_A0_GTXCLr_GET
#define READ_GTXCLr BCM56504_A0_READ_GTXCLr
#define WRITE_GTXCLr BCM56504_A0_WRITE_GTXCLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GTXCLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  GTXPF
 * BLOCKS:   GPORT0
 * DESC:     Transmit Pause Control Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_GTXPFr 0x00f0002a

#define BCM56504_A0_GTXPFr_SIZE 4

/*
 * This structure should be used to declare and program GTXPF.
 *
 */
typedef union BCM56504_A0_GTXPFr_s {
	uint32_t v[1];
	uint32_t gtxpf[1];
	uint32_t _gtxpf;
} BCM56504_A0_GTXPFr_t;

#define BCM56504_A0_GTXPFr_CLR(r) (r).gtxpf[0] = 0
#define BCM56504_A0_GTXPFr_SET(r,d) (r).gtxpf[0] = d
#define BCM56504_A0_GTXPFr_GET(r) (r).gtxpf[0]


/*
 * These macros can be used to access GTXPF.
 *
 */
#define BCM56504_A0_READ_GTXPFr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_GTXPFr,(r._gtxpf))
#define BCM56504_A0_WRITE_GTXPFr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_GTXPFr,&(r._gtxpf))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTXPFr BCM56504_A0_GTXPFr
#define GTXPFr_SIZE BCM56504_A0_GTXPFr_SIZE
typedef BCM56504_A0_GTXPFr_t GTXPFr_t;
#define GTXPFr_CLR BCM56504_A0_GTXPFr_CLR
#define GTXPFr_SET BCM56504_A0_GTXPFr_SET
#define GTXPFr_GET BCM56504_A0_GTXPFr_GET
#define READ_GTXPFr BCM56504_A0_READ_GTXPFr
#define WRITE_GTXPFr BCM56504_A0_WRITE_GTXPFr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_GTXPFr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  HASH_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     Hash Control Register
 * SIZE:     32
 * FIELDS:
 *     NON_UC_TRUNK_HASH_MOD_PORT_ENABLE Enables factoring modid/port into non-unicast trunk block mask hashing
 *     NON_UC_TRUNK_HASH_SRC_ENABLE Enables factoring source MAC or source IP into non-unicast trunk block mask hashing
 *     NON_UC_TRUNK_HASH_DST_ENABLE Enables factoring dest MAC or dest IP into non-unicast trunk block mask hashing
 *     UC_TRUNK_HASH_USE_SRC_PORT Use src port in unicast trunk hash
 *     ECMP_HASH_UDF    ECMP hash offset
 *     ECMP_HASH_USE_DIP Use DIP for ECMP hashing
 *     ECMP_HASH_SEL    Selects ECMP hashing algorithm
 *     L2_AND_VLAN_MAC_HASH_SELECT Selects hashing algorithm used for L2 table lookups
 *     L3_HASH_SELECT   Selects hashing algorithm used for L3 table lookups
 *     ENABLE_DRACO1_5_HASH Enable using Draco 1.5 hashing for unicast trunking
 *     USE_TCP_UDP_PORTS Use TCP/UDP ports for ECMP/unicast trunk hashing
 *
 ******************************************************************************/
#define BCM56504_A0_HASH_CONTROLr 0x01780003

#define BCM56504_A0_HASH_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program HASH_CONTROL.
 *
 */
typedef union BCM56504_A0_HASH_CONTROLr_s {
	uint32_t v[1];
	uint32_t hash_control[1];
	uint32_t _hash_control;
} BCM56504_A0_HASH_CONTROLr_t;

#define BCM56504_A0_HASH_CONTROLr_CLR(r) (r).hash_control[0] = 0
#define BCM56504_A0_HASH_CONTROLr_SET(r,d) (r).hash_control[0] = d
#define BCM56504_A0_HASH_CONTROLr_GET(r) (r).hash_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_HASH_CONTROLr_NON_UC_TRUNK_HASH_MOD_PORT_ENABLEf_GET(r) (((r).hash_control[0]) & 0x1)
#define BCM56504_A0_HASH_CONTROLr_NON_UC_TRUNK_HASH_MOD_PORT_ENABLEf_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_HASH_CONTROLr_NON_UC_TRUNK_HASH_SRC_ENABLEf_GET(r) ((((r).hash_control[0]) >> 1) & 0x1)
#define BCM56504_A0_HASH_CONTROLr_NON_UC_TRUNK_HASH_SRC_ENABLEf_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_HASH_CONTROLr_NON_UC_TRUNK_HASH_DST_ENABLEf_GET(r) ((((r).hash_control[0]) >> 2) & 0x1)
#define BCM56504_A0_HASH_CONTROLr_NON_UC_TRUNK_HASH_DST_ENABLEf_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_HASH_CONTROLr_UC_TRUNK_HASH_USE_SRC_PORTf_GET(r) ((((r).hash_control[0]) >> 3) & 0x1)
#define BCM56504_A0_HASH_CONTROLr_UC_TRUNK_HASH_USE_SRC_PORTf_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_HASH_CONTROLr_ECMP_HASH_UDFf_GET(r) ((((r).hash_control[0]) >> 4) & 0xff)
#define BCM56504_A0_HASH_CONTROLr_ECMP_HASH_UDFf_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32_t)0xff << 4)) | ((((uint32_t)f) & 0xff) << 4))
#define BCM56504_A0_HASH_CONTROLr_ECMP_HASH_USE_DIPf_GET(r) ((((r).hash_control[0]) >> 12) & 0x1)
#define BCM56504_A0_HASH_CONTROLr_ECMP_HASH_USE_DIPf_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM56504_A0_HASH_CONTROLr_ECMP_HASH_SELf_GET(r) ((((r).hash_control[0]) >> 13) & 0x3)
#define BCM56504_A0_HASH_CONTROLr_ECMP_HASH_SELf_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13))
#define BCM56504_A0_HASH_CONTROLr_L2_AND_VLAN_MAC_HASH_SELECTf_GET(r) ((((r).hash_control[0]) >> 15) & 0x7)
#define BCM56504_A0_HASH_CONTROLr_L2_AND_VLAN_MAC_HASH_SELECTf_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM56504_A0_HASH_CONTROLr_L3_HASH_SELECTf_GET(r) ((((r).hash_control[0]) >> 18) & 0x7)
#define BCM56504_A0_HASH_CONTROLr_L3_HASH_SELECTf_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM56504_A0_HASH_CONTROLr_ENABLE_DRACO1_5_HASHf_GET(r) ((((r).hash_control[0]) >> 21) & 0x1)
#define BCM56504_A0_HASH_CONTROLr_ENABLE_DRACO1_5_HASHf_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM56504_A0_HASH_CONTROLr_USE_TCP_UDP_PORTSf_GET(r) ((((r).hash_control[0]) >> 22) & 0x1)
#define BCM56504_A0_HASH_CONTROLr_USE_TCP_UDP_PORTSf_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))

/*
 * These macros can be used to access HASH_CONTROL.
 *
 */
#define BCM56504_A0_READ_HASH_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_HASH_CONTROLr,(r._hash_control))
#define BCM56504_A0_WRITE_HASH_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_HASH_CONTROLr,&(r._hash_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HASH_CONTROLr BCM56504_A0_HASH_CONTROLr
#define HASH_CONTROLr_SIZE BCM56504_A0_HASH_CONTROLr_SIZE
typedef BCM56504_A0_HASH_CONTROLr_t HASH_CONTROLr_t;
#define HASH_CONTROLr_CLR BCM56504_A0_HASH_CONTROLr_CLR
#define HASH_CONTROLr_SET BCM56504_A0_HASH_CONTROLr_SET
#define HASH_CONTROLr_GET BCM56504_A0_HASH_CONTROLr_GET
#define HASH_CONTROLr_NON_UC_TRUNK_HASH_MOD_PORT_ENABLEf_GET BCM56504_A0_HASH_CONTROLr_NON_UC_TRUNK_HASH_MOD_PORT_ENABLEf_GET
#define HASH_CONTROLr_NON_UC_TRUNK_HASH_MOD_PORT_ENABLEf_SET BCM56504_A0_HASH_CONTROLr_NON_UC_TRUNK_HASH_MOD_PORT_ENABLEf_SET
#define HASH_CONTROLr_NON_UC_TRUNK_HASH_SRC_ENABLEf_GET BCM56504_A0_HASH_CONTROLr_NON_UC_TRUNK_HASH_SRC_ENABLEf_GET
#define HASH_CONTROLr_NON_UC_TRUNK_HASH_SRC_ENABLEf_SET BCM56504_A0_HASH_CONTROLr_NON_UC_TRUNK_HASH_SRC_ENABLEf_SET
#define HASH_CONTROLr_NON_UC_TRUNK_HASH_DST_ENABLEf_GET BCM56504_A0_HASH_CONTROLr_NON_UC_TRUNK_HASH_DST_ENABLEf_GET
#define HASH_CONTROLr_NON_UC_TRUNK_HASH_DST_ENABLEf_SET BCM56504_A0_HASH_CONTROLr_NON_UC_TRUNK_HASH_DST_ENABLEf_SET
#define HASH_CONTROLr_UC_TRUNK_HASH_USE_SRC_PORTf_GET BCM56504_A0_HASH_CONTROLr_UC_TRUNK_HASH_USE_SRC_PORTf_GET
#define HASH_CONTROLr_UC_TRUNK_HASH_USE_SRC_PORTf_SET BCM56504_A0_HASH_CONTROLr_UC_TRUNK_HASH_USE_SRC_PORTf_SET
#define HASH_CONTROLr_ECMP_HASH_UDFf_GET BCM56504_A0_HASH_CONTROLr_ECMP_HASH_UDFf_GET
#define HASH_CONTROLr_ECMP_HASH_UDFf_SET BCM56504_A0_HASH_CONTROLr_ECMP_HASH_UDFf_SET
#define HASH_CONTROLr_ECMP_HASH_USE_DIPf_GET BCM56504_A0_HASH_CONTROLr_ECMP_HASH_USE_DIPf_GET
#define HASH_CONTROLr_ECMP_HASH_USE_DIPf_SET BCM56504_A0_HASH_CONTROLr_ECMP_HASH_USE_DIPf_SET
#define HASH_CONTROLr_ECMP_HASH_SELf_GET BCM56504_A0_HASH_CONTROLr_ECMP_HASH_SELf_GET
#define HASH_CONTROLr_ECMP_HASH_SELf_SET BCM56504_A0_HASH_CONTROLr_ECMP_HASH_SELf_SET
#define HASH_CONTROLr_L2_AND_VLAN_MAC_HASH_SELECTf_GET BCM56504_A0_HASH_CONTROLr_L2_AND_VLAN_MAC_HASH_SELECTf_GET
#define HASH_CONTROLr_L2_AND_VLAN_MAC_HASH_SELECTf_SET BCM56504_A0_HASH_CONTROLr_L2_AND_VLAN_MAC_HASH_SELECTf_SET
#define HASH_CONTROLr_L3_HASH_SELECTf_GET BCM56504_A0_HASH_CONTROLr_L3_HASH_SELECTf_GET
#define HASH_CONTROLr_L3_HASH_SELECTf_SET BCM56504_A0_HASH_CONTROLr_L3_HASH_SELECTf_SET
#define HASH_CONTROLr_ENABLE_DRACO1_5_HASHf_GET BCM56504_A0_HASH_CONTROLr_ENABLE_DRACO1_5_HASHf_GET
#define HASH_CONTROLr_ENABLE_DRACO1_5_HASHf_SET BCM56504_A0_HASH_CONTROLr_ENABLE_DRACO1_5_HASHf_SET
#define HASH_CONTROLr_USE_TCP_UDP_PORTSf_GET BCM56504_A0_HASH_CONTROLr_USE_TCP_UDP_PORTSf_GET
#define HASH_CONTROLr_USE_TCP_UDP_PORTSf_SET BCM56504_A0_HASH_CONTROLr_USE_TCP_UDP_PORTSf_SET
#define READ_HASH_CONTROLr BCM56504_A0_READ_HASH_CONTROLr
#define WRITE_HASH_CONTROLr BCM56504_A0_WRITE_HASH_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_HASH_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  HIGIG_TRUNK_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     HiGig Trunk Control Register
 * SIZE:     32
 * FIELDS:
 *     HIGIG_TRUNK_ID0  HiGig trunk ID for Port 24 
 *     HIGIG_TRUNK0     HiGig T-bit for Port 24 
 *     HIGIG_TRUNK_ID1  HiGig trunk ID for Port 25 
 *     HIGIG_TRUNK1     HiGig T-bit for Port 25 
 *     HIGIG_TRUNK_ID2  HiGig trunk ID for Port 26 
 *     HIGIG_TRUNK2     HiGig T-bit for Port 26 
 *     HIGIG_TRUNK_ID3  HiGig trunk ID for Port 27 
 *     HIGIG_TRUNK3     HiGig T-bit for Port 27 
 *     HIGIG_TRUNK_BITMAP0 HiGig trunk bitmap for trunk group 0
 *     HIGIG_TRUNK_BITMAP1 HiGig trunk bitmap for trunk group 1
 *     ACTIVE_PORT_BITMAP HiGig ports on which active traffic needs to go out
 *
 ******************************************************************************/
#define BCM56504_A0_HIGIG_TRUNK_CONTROLr 0x0e780109

#define BCM56504_A0_HIGIG_TRUNK_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program HIGIG_TRUNK_CONTROL.
 *
 */
typedef union BCM56504_A0_HIGIG_TRUNK_CONTROLr_s {
	uint32_t v[1];
	uint32_t higig_trunk_control[1];
	uint32_t _higig_trunk_control;
} BCM56504_A0_HIGIG_TRUNK_CONTROLr_t;

#define BCM56504_A0_HIGIG_TRUNK_CONTROLr_CLR(r) (r).higig_trunk_control[0] = 0
#define BCM56504_A0_HIGIG_TRUNK_CONTROLr_SET(r,d) (r).higig_trunk_control[0] = d
#define BCM56504_A0_HIGIG_TRUNK_CONTROLr_GET(r) (r).higig_trunk_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_HIGIG_TRUNK_CONTROLr_HIGIG_TRUNK_ID0f_GET(r) (((r).higig_trunk_control[0]) & 0x1)
#define BCM56504_A0_HIGIG_TRUNK_CONTROLr_HIGIG_TRUNK_ID0f_SET(r,f) (r).higig_trunk_control[0]=(((r).higig_trunk_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_HIGIG_TRUNK_CONTROLr_HIGIG_TRUNK0f_GET(r) ((((r).higig_trunk_control[0]) >> 1) & 0x1)
#define BCM56504_A0_HIGIG_TRUNK_CONTROLr_HIGIG_TRUNK0f_SET(r,f) (r).higig_trunk_control[0]=(((r).higig_trunk_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_HIGIG_TRUNK_CONTROLr_HIGIG_TRUNK_ID1f_GET(r) ((((r).higig_trunk_control[0]) >> 2) & 0x1)
#define BCM56504_A0_HIGIG_TRUNK_CONTROLr_HIGIG_TRUNK_ID1f_SET(r,f) (r).higig_trunk_control[0]=(((r).higig_trunk_control[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_HIGIG_TRUNK_CONTROLr_HIGIG_TRUNK1f_GET(r) ((((r).higig_trunk_control[0]) >> 3) & 0x1)
#define BCM56504_A0_HIGIG_TRUNK_CONTROLr_HIGIG_TRUNK1f_SET(r,f) (r).higig_trunk_control[0]=(((r).higig_trunk_control[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_HIGIG_TRUNK_CONTROLr_HIGIG_TRUNK_ID2f_GET(r) ((((r).higig_trunk_control[0]) >> 4) & 0x1)
#define BCM56504_A0_HIGIG_TRUNK_CONTROLr_HIGIG_TRUNK_ID2f_SET(r,f) (r).higig_trunk_control[0]=(((r).higig_trunk_control[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56504_A0_HIGIG_TRUNK_CONTROLr_HIGIG_TRUNK2f_GET(r) ((((r).higig_trunk_control[0]) >> 5) & 0x1)
#define BCM56504_A0_HIGIG_TRUNK_CONTROLr_HIGIG_TRUNK2f_SET(r,f) (r).higig_trunk_control[0]=(((r).higig_trunk_control[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56504_A0_HIGIG_TRUNK_CONTROLr_HIGIG_TRUNK_ID3f_GET(r) ((((r).higig_trunk_control[0]) >> 6) & 0x1)
#define BCM56504_A0_HIGIG_TRUNK_CONTROLr_HIGIG_TRUNK_ID3f_SET(r,f) (r).higig_trunk_control[0]=(((r).higig_trunk_control[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56504_A0_HIGIG_TRUNK_CONTROLr_HIGIG_TRUNK3f_GET(r) ((((r).higig_trunk_control[0]) >> 7) & 0x1)
#define BCM56504_A0_HIGIG_TRUNK_CONTROLr_HIGIG_TRUNK3f_SET(r,f) (r).higig_trunk_control[0]=(((r).higig_trunk_control[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56504_A0_HIGIG_TRUNK_CONTROLr_HIGIG_TRUNK_BITMAP0f_GET(r) ((((r).higig_trunk_control[0]) >> 8) & 0xf)
#define BCM56504_A0_HIGIG_TRUNK_CONTROLr_HIGIG_TRUNK_BITMAP0f_SET(r,f) (r).higig_trunk_control[0]=(((r).higig_trunk_control[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM56504_A0_HIGIG_TRUNK_CONTROLr_HIGIG_TRUNK_BITMAP1f_GET(r) ((((r).higig_trunk_control[0]) >> 12) & 0xf)
#define BCM56504_A0_HIGIG_TRUNK_CONTROLr_HIGIG_TRUNK_BITMAP1f_SET(r,f) (r).higig_trunk_control[0]=(((r).higig_trunk_control[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM56504_A0_HIGIG_TRUNK_CONTROLr_ACTIVE_PORT_BITMAPf_GET(r) ((((r).higig_trunk_control[0]) >> 16) & 0xf)
#define BCM56504_A0_HIGIG_TRUNK_CONTROLr_ACTIVE_PORT_BITMAPf_SET(r,f) (r).higig_trunk_control[0]=(((r).higig_trunk_control[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))

/*
 * These macros can be used to access HIGIG_TRUNK_CONTROL.
 *
 */
#define BCM56504_A0_READ_HIGIG_TRUNK_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_HIGIG_TRUNK_CONTROLr,(r._higig_trunk_control))
#define BCM56504_A0_WRITE_HIGIG_TRUNK_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_HIGIG_TRUNK_CONTROLr,&(r._higig_trunk_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HIGIG_TRUNK_CONTROLr BCM56504_A0_HIGIG_TRUNK_CONTROLr
#define HIGIG_TRUNK_CONTROLr_SIZE BCM56504_A0_HIGIG_TRUNK_CONTROLr_SIZE
typedef BCM56504_A0_HIGIG_TRUNK_CONTROLr_t HIGIG_TRUNK_CONTROLr_t;
#define HIGIG_TRUNK_CONTROLr_CLR BCM56504_A0_HIGIG_TRUNK_CONTROLr_CLR
#define HIGIG_TRUNK_CONTROLr_SET BCM56504_A0_HIGIG_TRUNK_CONTROLr_SET
#define HIGIG_TRUNK_CONTROLr_GET BCM56504_A0_HIGIG_TRUNK_CONTROLr_GET
#define HIGIG_TRUNK_CONTROLr_HIGIG_TRUNK_ID0f_GET BCM56504_A0_HIGIG_TRUNK_CONTROLr_HIGIG_TRUNK_ID0f_GET
#define HIGIG_TRUNK_CONTROLr_HIGIG_TRUNK_ID0f_SET BCM56504_A0_HIGIG_TRUNK_CONTROLr_HIGIG_TRUNK_ID0f_SET
#define HIGIG_TRUNK_CONTROLr_HIGIG_TRUNK0f_GET BCM56504_A0_HIGIG_TRUNK_CONTROLr_HIGIG_TRUNK0f_GET
#define HIGIG_TRUNK_CONTROLr_HIGIG_TRUNK0f_SET BCM56504_A0_HIGIG_TRUNK_CONTROLr_HIGIG_TRUNK0f_SET
#define HIGIG_TRUNK_CONTROLr_HIGIG_TRUNK_ID1f_GET BCM56504_A0_HIGIG_TRUNK_CONTROLr_HIGIG_TRUNK_ID1f_GET
#define HIGIG_TRUNK_CONTROLr_HIGIG_TRUNK_ID1f_SET BCM56504_A0_HIGIG_TRUNK_CONTROLr_HIGIG_TRUNK_ID1f_SET
#define HIGIG_TRUNK_CONTROLr_HIGIG_TRUNK1f_GET BCM56504_A0_HIGIG_TRUNK_CONTROLr_HIGIG_TRUNK1f_GET
#define HIGIG_TRUNK_CONTROLr_HIGIG_TRUNK1f_SET BCM56504_A0_HIGIG_TRUNK_CONTROLr_HIGIG_TRUNK1f_SET
#define HIGIG_TRUNK_CONTROLr_HIGIG_TRUNK_ID2f_GET BCM56504_A0_HIGIG_TRUNK_CONTROLr_HIGIG_TRUNK_ID2f_GET
#define HIGIG_TRUNK_CONTROLr_HIGIG_TRUNK_ID2f_SET BCM56504_A0_HIGIG_TRUNK_CONTROLr_HIGIG_TRUNK_ID2f_SET
#define HIGIG_TRUNK_CONTROLr_HIGIG_TRUNK2f_GET BCM56504_A0_HIGIG_TRUNK_CONTROLr_HIGIG_TRUNK2f_GET
#define HIGIG_TRUNK_CONTROLr_HIGIG_TRUNK2f_SET BCM56504_A0_HIGIG_TRUNK_CONTROLr_HIGIG_TRUNK2f_SET
#define HIGIG_TRUNK_CONTROLr_HIGIG_TRUNK_ID3f_GET BCM56504_A0_HIGIG_TRUNK_CONTROLr_HIGIG_TRUNK_ID3f_GET
#define HIGIG_TRUNK_CONTROLr_HIGIG_TRUNK_ID3f_SET BCM56504_A0_HIGIG_TRUNK_CONTROLr_HIGIG_TRUNK_ID3f_SET
#define HIGIG_TRUNK_CONTROLr_HIGIG_TRUNK3f_GET BCM56504_A0_HIGIG_TRUNK_CONTROLr_HIGIG_TRUNK3f_GET
#define HIGIG_TRUNK_CONTROLr_HIGIG_TRUNK3f_SET BCM56504_A0_HIGIG_TRUNK_CONTROLr_HIGIG_TRUNK3f_SET
#define HIGIG_TRUNK_CONTROLr_HIGIG_TRUNK_BITMAP0f_GET BCM56504_A0_HIGIG_TRUNK_CONTROLr_HIGIG_TRUNK_BITMAP0f_GET
#define HIGIG_TRUNK_CONTROLr_HIGIG_TRUNK_BITMAP0f_SET BCM56504_A0_HIGIG_TRUNK_CONTROLr_HIGIG_TRUNK_BITMAP0f_SET
#define HIGIG_TRUNK_CONTROLr_HIGIG_TRUNK_BITMAP1f_GET BCM56504_A0_HIGIG_TRUNK_CONTROLr_HIGIG_TRUNK_BITMAP1f_GET
#define HIGIG_TRUNK_CONTROLr_HIGIG_TRUNK_BITMAP1f_SET BCM56504_A0_HIGIG_TRUNK_CONTROLr_HIGIG_TRUNK_BITMAP1f_SET
#define HIGIG_TRUNK_CONTROLr_ACTIVE_PORT_BITMAPf_GET BCM56504_A0_HIGIG_TRUNK_CONTROLr_ACTIVE_PORT_BITMAPf_GET
#define HIGIG_TRUNK_CONTROLr_ACTIVE_PORT_BITMAPf_SET BCM56504_A0_HIGIG_TRUNK_CONTROLr_ACTIVE_PORT_BITMAPf_SET
#define READ_HIGIG_TRUNK_CONTROLr BCM56504_A0_READ_HIGIG_TRUNK_CONTROLr
#define WRITE_HIGIG_TRUNK_CONTROLr BCM56504_A0_WRITE_HIGIG_TRUNK_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_HIGIG_TRUNK_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  HIGIG_TRUNK_GROUP
 * BLOCKS:   IPIPE
 * DESC:     HiGig Trunk Group Register
 * SIZE:     32
 * FIELDS:
 *     HIGIG_TRUNK_RTAG0 HiGig trunk ID #0 RTAG (for encoding values see TRUNK_GROUP.RTAG field)
 *     HIGIG_TRUNK_RTAG1 HiGig trunk ID #1 RTAG (for encoding values see TRUNK_GROUP.RTAG field)
 *     HIGIG_TRUNK_ID0_PORT0 HiGig trunk ID #0 port 0
 *     HIGIG_TRUNK_ID0_PORT1 HiGig trunk ID #0 port 1
 *     HIGIG_TRUNK_ID0_PORT2 HiGig trunk ID #0 port 2
 *     HIGIG_TRUNK_ID0_PORT3 HiGig trunk ID #0 port 3
 *     HIGIG_TRUNK_ID1_PORT0 HiGig trunk ID #1 port 0
 *     HIGIG_TRUNK_ID1_PORT1 HiGig trunk ID #1 port 1
 *     HIGIG_TRUNK_ID1_PORT2 HiGig trunk ID #1 port 2
 *     HIGIG_TRUNK_ID1_PORT3 HiGig trunk ID #1 port 3
 *
 ******************************************************************************/
#define BCM56504_A0_HIGIG_TRUNK_GROUPr 0x0e780108

#define BCM56504_A0_HIGIG_TRUNK_GROUPr_SIZE 4

/*
 * This structure should be used to declare and program HIGIG_TRUNK_GROUP.
 *
 */
typedef union BCM56504_A0_HIGIG_TRUNK_GROUPr_s {
	uint32_t v[1];
	uint32_t higig_trunk_group[1];
	uint32_t _higig_trunk_group;
} BCM56504_A0_HIGIG_TRUNK_GROUPr_t;

#define BCM56504_A0_HIGIG_TRUNK_GROUPr_CLR(r) (r).higig_trunk_group[0] = 0
#define BCM56504_A0_HIGIG_TRUNK_GROUPr_SET(r,d) (r).higig_trunk_group[0] = d
#define BCM56504_A0_HIGIG_TRUNK_GROUPr_GET(r) (r).higig_trunk_group[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_HIGIG_TRUNK_GROUPr_HIGIG_TRUNK_RTAG0f_GET(r) (((r).higig_trunk_group[0]) & 0x7)
#define BCM56504_A0_HIGIG_TRUNK_GROUPr_HIGIG_TRUNK_RTAG0f_SET(r,f) (r).higig_trunk_group[0]=(((r).higig_trunk_group[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM56504_A0_HIGIG_TRUNK_GROUPr_HIGIG_TRUNK_RTAG1f_GET(r) ((((r).higig_trunk_group[0]) >> 3) & 0x7)
#define BCM56504_A0_HIGIG_TRUNK_GROUPr_HIGIG_TRUNK_RTAG1f_SET(r,f) (r).higig_trunk_group[0]=(((r).higig_trunk_group[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM56504_A0_HIGIG_TRUNK_GROUPr_HIGIG_TRUNK_ID0_PORT0f_GET(r) ((((r).higig_trunk_group[0]) >> 6) & 0x3)
#define BCM56504_A0_HIGIG_TRUNK_GROUPr_HIGIG_TRUNK_ID0_PORT0f_SET(r,f) (r).higig_trunk_group[0]=(((r).higig_trunk_group[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM56504_A0_HIGIG_TRUNK_GROUPr_HIGIG_TRUNK_ID0_PORT1f_GET(r) ((((r).higig_trunk_group[0]) >> 8) & 0x3)
#define BCM56504_A0_HIGIG_TRUNK_GROUPr_HIGIG_TRUNK_ID0_PORT1f_SET(r,f) (r).higig_trunk_group[0]=(((r).higig_trunk_group[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM56504_A0_HIGIG_TRUNK_GROUPr_HIGIG_TRUNK_ID0_PORT2f_GET(r) ((((r).higig_trunk_group[0]) >> 10) & 0x3)
#define BCM56504_A0_HIGIG_TRUNK_GROUPr_HIGIG_TRUNK_ID0_PORT2f_SET(r,f) (r).higig_trunk_group[0]=(((r).higig_trunk_group[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCM56504_A0_HIGIG_TRUNK_GROUPr_HIGIG_TRUNK_ID0_PORT3f_GET(r) ((((r).higig_trunk_group[0]) >> 12) & 0x3)
#define BCM56504_A0_HIGIG_TRUNK_GROUPr_HIGIG_TRUNK_ID0_PORT3f_SET(r,f) (r).higig_trunk_group[0]=(((r).higig_trunk_group[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM56504_A0_HIGIG_TRUNK_GROUPr_HIGIG_TRUNK_ID1_PORT0f_GET(r) ((((r).higig_trunk_group[0]) >> 14) & 0x3)
#define BCM56504_A0_HIGIG_TRUNK_GROUPr_HIGIG_TRUNK_ID1_PORT0f_SET(r,f) (r).higig_trunk_group[0]=(((r).higig_trunk_group[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCM56504_A0_HIGIG_TRUNK_GROUPr_HIGIG_TRUNK_ID1_PORT1f_GET(r) ((((r).higig_trunk_group[0]) >> 16) & 0x3)
#define BCM56504_A0_HIGIG_TRUNK_GROUPr_HIGIG_TRUNK_ID1_PORT1f_SET(r,f) (r).higig_trunk_group[0]=(((r).higig_trunk_group[0] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM56504_A0_HIGIG_TRUNK_GROUPr_HIGIG_TRUNK_ID1_PORT2f_GET(r) ((((r).higig_trunk_group[0]) >> 18) & 0x3)
#define BCM56504_A0_HIGIG_TRUNK_GROUPr_HIGIG_TRUNK_ID1_PORT2f_SET(r,f) (r).higig_trunk_group[0]=(((r).higig_trunk_group[0] & ~((uint32_t)0x3 << 18)) | ((((uint32_t)f) & 0x3) << 18))
#define BCM56504_A0_HIGIG_TRUNK_GROUPr_HIGIG_TRUNK_ID1_PORT3f_GET(r) ((((r).higig_trunk_group[0]) >> 20) & 0x3)
#define BCM56504_A0_HIGIG_TRUNK_GROUPr_HIGIG_TRUNK_ID1_PORT3f_SET(r,f) (r).higig_trunk_group[0]=(((r).higig_trunk_group[0] & ~((uint32_t)0x3 << 20)) | ((((uint32_t)f) & 0x3) << 20))

/*
 * These macros can be used to access HIGIG_TRUNK_GROUP.
 *
 */
#define BCM56504_A0_READ_HIGIG_TRUNK_GROUPr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_HIGIG_TRUNK_GROUPr,(r._higig_trunk_group))
#define BCM56504_A0_WRITE_HIGIG_TRUNK_GROUPr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_HIGIG_TRUNK_GROUPr,&(r._higig_trunk_group))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HIGIG_TRUNK_GROUPr BCM56504_A0_HIGIG_TRUNK_GROUPr
#define HIGIG_TRUNK_GROUPr_SIZE BCM56504_A0_HIGIG_TRUNK_GROUPr_SIZE
typedef BCM56504_A0_HIGIG_TRUNK_GROUPr_t HIGIG_TRUNK_GROUPr_t;
#define HIGIG_TRUNK_GROUPr_CLR BCM56504_A0_HIGIG_TRUNK_GROUPr_CLR
#define HIGIG_TRUNK_GROUPr_SET BCM56504_A0_HIGIG_TRUNK_GROUPr_SET
#define HIGIG_TRUNK_GROUPr_GET BCM56504_A0_HIGIG_TRUNK_GROUPr_GET
#define HIGIG_TRUNK_GROUPr_HIGIG_TRUNK_RTAG0f_GET BCM56504_A0_HIGIG_TRUNK_GROUPr_HIGIG_TRUNK_RTAG0f_GET
#define HIGIG_TRUNK_GROUPr_HIGIG_TRUNK_RTAG0f_SET BCM56504_A0_HIGIG_TRUNK_GROUPr_HIGIG_TRUNK_RTAG0f_SET
#define HIGIG_TRUNK_GROUPr_HIGIG_TRUNK_RTAG1f_GET BCM56504_A0_HIGIG_TRUNK_GROUPr_HIGIG_TRUNK_RTAG1f_GET
#define HIGIG_TRUNK_GROUPr_HIGIG_TRUNK_RTAG1f_SET BCM56504_A0_HIGIG_TRUNK_GROUPr_HIGIG_TRUNK_RTAG1f_SET
#define HIGIG_TRUNK_GROUPr_HIGIG_TRUNK_ID0_PORT0f_GET BCM56504_A0_HIGIG_TRUNK_GROUPr_HIGIG_TRUNK_ID0_PORT0f_GET
#define HIGIG_TRUNK_GROUPr_HIGIG_TRUNK_ID0_PORT0f_SET BCM56504_A0_HIGIG_TRUNK_GROUPr_HIGIG_TRUNK_ID0_PORT0f_SET
#define HIGIG_TRUNK_GROUPr_HIGIG_TRUNK_ID0_PORT1f_GET BCM56504_A0_HIGIG_TRUNK_GROUPr_HIGIG_TRUNK_ID0_PORT1f_GET
#define HIGIG_TRUNK_GROUPr_HIGIG_TRUNK_ID0_PORT1f_SET BCM56504_A0_HIGIG_TRUNK_GROUPr_HIGIG_TRUNK_ID0_PORT1f_SET
#define HIGIG_TRUNK_GROUPr_HIGIG_TRUNK_ID0_PORT2f_GET BCM56504_A0_HIGIG_TRUNK_GROUPr_HIGIG_TRUNK_ID0_PORT2f_GET
#define HIGIG_TRUNK_GROUPr_HIGIG_TRUNK_ID0_PORT2f_SET BCM56504_A0_HIGIG_TRUNK_GROUPr_HIGIG_TRUNK_ID0_PORT2f_SET
#define HIGIG_TRUNK_GROUPr_HIGIG_TRUNK_ID0_PORT3f_GET BCM56504_A0_HIGIG_TRUNK_GROUPr_HIGIG_TRUNK_ID0_PORT3f_GET
#define HIGIG_TRUNK_GROUPr_HIGIG_TRUNK_ID0_PORT3f_SET BCM56504_A0_HIGIG_TRUNK_GROUPr_HIGIG_TRUNK_ID0_PORT3f_SET
#define HIGIG_TRUNK_GROUPr_HIGIG_TRUNK_ID1_PORT0f_GET BCM56504_A0_HIGIG_TRUNK_GROUPr_HIGIG_TRUNK_ID1_PORT0f_GET
#define HIGIG_TRUNK_GROUPr_HIGIG_TRUNK_ID1_PORT0f_SET BCM56504_A0_HIGIG_TRUNK_GROUPr_HIGIG_TRUNK_ID1_PORT0f_SET
#define HIGIG_TRUNK_GROUPr_HIGIG_TRUNK_ID1_PORT1f_GET BCM56504_A0_HIGIG_TRUNK_GROUPr_HIGIG_TRUNK_ID1_PORT1f_GET
#define HIGIG_TRUNK_GROUPr_HIGIG_TRUNK_ID1_PORT1f_SET BCM56504_A0_HIGIG_TRUNK_GROUPr_HIGIG_TRUNK_ID1_PORT1f_SET
#define HIGIG_TRUNK_GROUPr_HIGIG_TRUNK_ID1_PORT2f_GET BCM56504_A0_HIGIG_TRUNK_GROUPr_HIGIG_TRUNK_ID1_PORT2f_GET
#define HIGIG_TRUNK_GROUPr_HIGIG_TRUNK_ID1_PORT2f_SET BCM56504_A0_HIGIG_TRUNK_GROUPr_HIGIG_TRUNK_ID1_PORT2f_SET
#define HIGIG_TRUNK_GROUPr_HIGIG_TRUNK_ID1_PORT3f_GET BCM56504_A0_HIGIG_TRUNK_GROUPr_HIGIG_TRUNK_ID1_PORT3f_GET
#define HIGIG_TRUNK_GROUPr_HIGIG_TRUNK_ID1_PORT3f_SET BCM56504_A0_HIGIG_TRUNK_GROUPr_HIGIG_TRUNK_ID1_PORT3f_SET
#define READ_HIGIG_TRUNK_GROUPr BCM56504_A0_READ_HIGIG_TRUNK_GROUPr
#define WRITE_HIGIG_TRUNK_GROUPr BCM56504_A0_WRITE_HIGIG_TRUNK_GROUPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_HIGIG_TRUNK_GROUPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  HOLCOSPKTSETLIMIT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     PKTSETLIMIT      HOL Packet high threshold for cos size of egress XQ COS n.The COS n HOL status will be generated when packet count is over (this setlimit - Skidmark to be configged SKIDMARKER field from MISCCONFIG register). Do not set HOLCOSPKTSETLIMIT lower than Skidmarck or it will be treatedas zero size of this COS n.Please note the sum of an egress port\'s all COS\' pktsetlimit can not over 2k. 
 *     RESETLIMITSEL    HOL COSn Packet Reset Threshold Select opions for all cos of egress ports.When HOL COSn status is set, packet counts have to fall below Reset Threshold in order to clear HOL COSn status. 2'b00: 75% of HOL COS Packet Set Limit.2'b01: 50% of HOL COS Packet Set Limit.        2'b10: 25% of HOL COS Packet Set Limit.        2'b11: 12.5% of HOL COS Packet Set Limit.      
 *
 ******************************************************************************/
#define BCM56504_A0_HOLCOSPKTSETLIMITr 0x00600010

#define BCM56504_A0_HOLCOSPKTSETLIMITr_SIZE 4

/*
 * This structure should be used to declare and program HOLCOSPKTSETLIMIT.
 *
 */
typedef union BCM56504_A0_HOLCOSPKTSETLIMITr_s {
	uint32_t v[1];
	uint32_t holcospktsetlimit[1];
	uint32_t _holcospktsetlimit;
} BCM56504_A0_HOLCOSPKTSETLIMITr_t;

#define BCM56504_A0_HOLCOSPKTSETLIMITr_CLR(r) (r).holcospktsetlimit[0] = 0
#define BCM56504_A0_HOLCOSPKTSETLIMITr_SET(r,d) (r).holcospktsetlimit[0] = d
#define BCM56504_A0_HOLCOSPKTSETLIMITr_GET(r) (r).holcospktsetlimit[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_HOLCOSPKTSETLIMITr_PKTSETLIMITf_GET(r) (((r).holcospktsetlimit[0]) & 0x7ff)
#define BCM56504_A0_HOLCOSPKTSETLIMITr_PKTSETLIMITf_SET(r,f) (r).holcospktsetlimit[0]=(((r).holcospktsetlimit[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM56504_A0_HOLCOSPKTSETLIMITr_RESETLIMITSELf_GET(r) ((((r).holcospktsetlimit[0]) >> 11) & 0x3)
#define BCM56504_A0_HOLCOSPKTSETLIMITr_RESETLIMITSELf_SET(r,f) (r).holcospktsetlimit[0]=(((r).holcospktsetlimit[0] & ~((uint32_t)0x3 << 11)) | ((((uint32_t)f) & 0x3) << 11))

/*
 * These macros can be used to access HOLCOSPKTSETLIMIT.
 *
 */
#define BCM56504_A0_READ_HOLCOSPKTSETLIMITr(u,p,i,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_HOLCOSPKTSETLIMITr+(i),(r._holcospktsetlimit))
#define BCM56504_A0_WRITE_HOLCOSPKTSETLIMITr(u,p,i,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_HOLCOSPKTSETLIMITr+(i),&(r._holcospktsetlimit))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLCOSPKTSETLIMITr BCM56504_A0_HOLCOSPKTSETLIMITr
#define HOLCOSPKTSETLIMITr_SIZE BCM56504_A0_HOLCOSPKTSETLIMITr_SIZE
typedef BCM56504_A0_HOLCOSPKTSETLIMITr_t HOLCOSPKTSETLIMITr_t;
#define HOLCOSPKTSETLIMITr_CLR BCM56504_A0_HOLCOSPKTSETLIMITr_CLR
#define HOLCOSPKTSETLIMITr_SET BCM56504_A0_HOLCOSPKTSETLIMITr_SET
#define HOLCOSPKTSETLIMITr_GET BCM56504_A0_HOLCOSPKTSETLIMITr_GET
#define HOLCOSPKTSETLIMITr_PKTSETLIMITf_GET BCM56504_A0_HOLCOSPKTSETLIMITr_PKTSETLIMITf_GET
#define HOLCOSPKTSETLIMITr_PKTSETLIMITf_SET BCM56504_A0_HOLCOSPKTSETLIMITr_PKTSETLIMITf_SET
#define HOLCOSPKTSETLIMITr_RESETLIMITSELf_GET BCM56504_A0_HOLCOSPKTSETLIMITr_RESETLIMITSELf_GET
#define HOLCOSPKTSETLIMITr_RESETLIMITSELf_SET BCM56504_A0_HOLCOSPKTSETLIMITr_RESETLIMITSELf_SET
#define READ_HOLCOSPKTSETLIMITr BCM56504_A0_READ_HOLCOSPKTSETLIMITr
#define WRITE_HOLCOSPKTSETLIMITr BCM56504_A0_WRITE_HOLCOSPKTSETLIMITr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_HOLCOSPKTSETLIMITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  HOLCOSSTATUS
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     PORT_BITMAP      Current COS n HOL Cell status
 *
 ******************************************************************************/
#define BCM56504_A0_HOLCOSSTATUSr 0x00680008

#define BCM56504_A0_HOLCOSSTATUSr_SIZE 4

/*
 * This structure should be used to declare and program HOLCOSSTATUS.
 *
 */
typedef union BCM56504_A0_HOLCOSSTATUSr_s {
	uint32_t v[1];
	uint32_t holcosstatus[1];
	uint32_t _holcosstatus;
} BCM56504_A0_HOLCOSSTATUSr_t;

#define BCM56504_A0_HOLCOSSTATUSr_CLR(r) (r).holcosstatus[0] = 0
#define BCM56504_A0_HOLCOSSTATUSr_SET(r,d) (r).holcosstatus[0] = d
#define BCM56504_A0_HOLCOSSTATUSr_GET(r) (r).holcosstatus[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_HOLCOSSTATUSr_PORT_BITMAPf_GET(r) (((r).holcosstatus[0]) & 0x1fffffff)
#define BCM56504_A0_HOLCOSSTATUSr_PORT_BITMAPf_SET(r,f) (r).holcosstatus[0]=(((r).holcosstatus[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))

/*
 * These macros can be used to access HOLCOSSTATUS.
 *
 */
#define BCM56504_A0_READ_HOLCOSSTATUSr(u,i,r) cdk_xgs_reg32_read(u,BCM56504_A0_HOLCOSSTATUSr+(i),(r._holcosstatus))
#define BCM56504_A0_WRITE_HOLCOSSTATUSr(u,i,r) cdk_xgs_reg32_write(u,BCM56504_A0_HOLCOSSTATUSr+(i),&(r._holcosstatus))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLCOSSTATUSr BCM56504_A0_HOLCOSSTATUSr
#define HOLCOSSTATUSr_SIZE BCM56504_A0_HOLCOSSTATUSr_SIZE
typedef BCM56504_A0_HOLCOSSTATUSr_t HOLCOSSTATUSr_t;
#define HOLCOSSTATUSr_CLR BCM56504_A0_HOLCOSSTATUSr_CLR
#define HOLCOSSTATUSr_SET BCM56504_A0_HOLCOSSTATUSr_SET
#define HOLCOSSTATUSr_GET BCM56504_A0_HOLCOSSTATUSr_GET
#define HOLCOSSTATUSr_PORT_BITMAPf_GET BCM56504_A0_HOLCOSSTATUSr_PORT_BITMAPf_GET
#define HOLCOSSTATUSr_PORT_BITMAPf_SET BCM56504_A0_HOLCOSSTATUSr_PORT_BITMAPf_SET
#define READ_HOLCOSSTATUSr BCM56504_A0_READ_HOLCOSSTATUSr
#define WRITE_HOLCOSSTATUSr BCM56504_A0_WRITE_HOLCOSSTATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_HOLCOSSTATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  HOLD
 * BLOCKS:   IPIPE
 * DESC:     Egress per port HOL Drop Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_HOLDr 0x0e700014

#define BCM56504_A0_HOLDr_SIZE 4

/*
 * This structure should be used to declare and program HOLD.
 *
 */
typedef union BCM56504_A0_HOLDr_s {
	uint32_t v[1];
	uint32_t hold[1];
	uint32_t _hold;
} BCM56504_A0_HOLDr_t;

#define BCM56504_A0_HOLDr_CLR(r) (r).hold[0] = 0
#define BCM56504_A0_HOLDr_SET(r,d) (r).hold[0] = d
#define BCM56504_A0_HOLDr_GET(r) (r).hold[0]


/*
 * These macros can be used to access HOLD.
 *
 */
#define BCM56504_A0_READ_HOLDr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_HOLDr,(r._hold))
#define BCM56504_A0_WRITE_HOLDr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_HOLDr,&(r._hold))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLDr BCM56504_A0_HOLDr
#define HOLDr_SIZE BCM56504_A0_HOLDr_SIZE
typedef BCM56504_A0_HOLDr_t HOLDr_t;
#define HOLDr_CLR BCM56504_A0_HOLDr_CLR
#define HOLDr_SET BCM56504_A0_HOLDr_SET
#define HOLDr_GET BCM56504_A0_HOLDr_GET
#define READ_HOLDr BCM56504_A0_READ_HOLDr
#define WRITE_HOLDr BCM56504_A0_WRITE_HOLDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_HOLDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  HOLD_COS0
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS0 Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            Incremented for each Packet drop due to Head Of Line blocking per egress port COS
 *
 ******************************************************************************/
#define BCM56504_A0_HOLD_COS0r 0x0e780015

#define BCM56504_A0_HOLD_COS0r_SIZE 4

/*
 * This structure should be used to declare and program HOLD_COS0.
 *
 */
typedef union BCM56504_A0_HOLD_COS0r_s {
	uint32_t v[1];
	uint32_t hold_cos0[1];
	uint32_t _hold_cos0;
} BCM56504_A0_HOLD_COS0r_t;

#define BCM56504_A0_HOLD_COS0r_CLR(r) (r).hold_cos0[0] = 0
#define BCM56504_A0_HOLD_COS0r_SET(r,d) (r).hold_cos0[0] = d
#define BCM56504_A0_HOLD_COS0r_GET(r) (r).hold_cos0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_HOLD_COS0r_COUNTf_GET(r) (((r).hold_cos0[0]) & 0x3ffffff)
#define BCM56504_A0_HOLD_COS0r_COUNTf_SET(r,f) (r).hold_cos0[0]=(((r).hold_cos0[0] & ~((uint32_t)0x3ffffff)) | (((uint32_t)f) & 0x3ffffff))

/*
 * These macros can be used to access HOLD_COS0.
 *
 */
#define BCM56504_A0_READ_HOLD_COS0r(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_HOLD_COS0r,(r._hold_cos0))
#define BCM56504_A0_WRITE_HOLD_COS0r(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_HOLD_COS0r,&(r._hold_cos0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLD_COS0r BCM56504_A0_HOLD_COS0r
#define HOLD_COS0r_SIZE BCM56504_A0_HOLD_COS0r_SIZE
typedef BCM56504_A0_HOLD_COS0r_t HOLD_COS0r_t;
#define HOLD_COS0r_CLR BCM56504_A0_HOLD_COS0r_CLR
#define HOLD_COS0r_SET BCM56504_A0_HOLD_COS0r_SET
#define HOLD_COS0r_GET BCM56504_A0_HOLD_COS0r_GET
#define HOLD_COS0r_COUNTf_GET BCM56504_A0_HOLD_COS0r_COUNTf_GET
#define HOLD_COS0r_COUNTf_SET BCM56504_A0_HOLD_COS0r_COUNTf_SET
#define READ_HOLD_COS0r BCM56504_A0_READ_HOLD_COS0r
#define WRITE_HOLD_COS0r BCM56504_A0_WRITE_HOLD_COS0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_HOLD_COS0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  HOLD_COS1
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS1 Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            Incremented for each Packet drop due to Head Of Line blocking per egress port COS
 *
 ******************************************************************************/
#define BCM56504_A0_HOLD_COS1r 0x0e780016

#define BCM56504_A0_HOLD_COS1r_SIZE 4

/*
 * This structure should be used to declare and program HOLD_COS1.
 *
 */
typedef union BCM56504_A0_HOLD_COS1r_s {
	uint32_t v[1];
	uint32_t hold_cos1[1];
	uint32_t _hold_cos1;
} BCM56504_A0_HOLD_COS1r_t;

#define BCM56504_A0_HOLD_COS1r_CLR(r) (r).hold_cos1[0] = 0
#define BCM56504_A0_HOLD_COS1r_SET(r,d) (r).hold_cos1[0] = d
#define BCM56504_A0_HOLD_COS1r_GET(r) (r).hold_cos1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_HOLD_COS1r_COUNTf_GET(r) (((r).hold_cos1[0]) & 0x3ffffff)
#define BCM56504_A0_HOLD_COS1r_COUNTf_SET(r,f) (r).hold_cos1[0]=(((r).hold_cos1[0] & ~((uint32_t)0x3ffffff)) | (((uint32_t)f) & 0x3ffffff))

/*
 * These macros can be used to access HOLD_COS1.
 *
 */
#define BCM56504_A0_READ_HOLD_COS1r(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_HOLD_COS1r,(r._hold_cos1))
#define BCM56504_A0_WRITE_HOLD_COS1r(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_HOLD_COS1r,&(r._hold_cos1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLD_COS1r BCM56504_A0_HOLD_COS1r
#define HOLD_COS1r_SIZE BCM56504_A0_HOLD_COS1r_SIZE
typedef BCM56504_A0_HOLD_COS1r_t HOLD_COS1r_t;
#define HOLD_COS1r_CLR BCM56504_A0_HOLD_COS1r_CLR
#define HOLD_COS1r_SET BCM56504_A0_HOLD_COS1r_SET
#define HOLD_COS1r_GET BCM56504_A0_HOLD_COS1r_GET
#define HOLD_COS1r_COUNTf_GET BCM56504_A0_HOLD_COS1r_COUNTf_GET
#define HOLD_COS1r_COUNTf_SET BCM56504_A0_HOLD_COS1r_COUNTf_SET
#define READ_HOLD_COS1r BCM56504_A0_READ_HOLD_COS1r
#define WRITE_HOLD_COS1r BCM56504_A0_WRITE_HOLD_COS1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_HOLD_COS1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  HOLD_COS2
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS2 Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            Incremented for each Packet drop due to Head Of Line blocking per egress port COS
 *
 ******************************************************************************/
#define BCM56504_A0_HOLD_COS2r 0x0e780017

#define BCM56504_A0_HOLD_COS2r_SIZE 4

/*
 * This structure should be used to declare and program HOLD_COS2.
 *
 */
typedef union BCM56504_A0_HOLD_COS2r_s {
	uint32_t v[1];
	uint32_t hold_cos2[1];
	uint32_t _hold_cos2;
} BCM56504_A0_HOLD_COS2r_t;

#define BCM56504_A0_HOLD_COS2r_CLR(r) (r).hold_cos2[0] = 0
#define BCM56504_A0_HOLD_COS2r_SET(r,d) (r).hold_cos2[0] = d
#define BCM56504_A0_HOLD_COS2r_GET(r) (r).hold_cos2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_HOLD_COS2r_COUNTf_GET(r) (((r).hold_cos2[0]) & 0x3ffffff)
#define BCM56504_A0_HOLD_COS2r_COUNTf_SET(r,f) (r).hold_cos2[0]=(((r).hold_cos2[0] & ~((uint32_t)0x3ffffff)) | (((uint32_t)f) & 0x3ffffff))

/*
 * These macros can be used to access HOLD_COS2.
 *
 */
#define BCM56504_A0_READ_HOLD_COS2r(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_HOLD_COS2r,(r._hold_cos2))
#define BCM56504_A0_WRITE_HOLD_COS2r(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_HOLD_COS2r,&(r._hold_cos2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLD_COS2r BCM56504_A0_HOLD_COS2r
#define HOLD_COS2r_SIZE BCM56504_A0_HOLD_COS2r_SIZE
typedef BCM56504_A0_HOLD_COS2r_t HOLD_COS2r_t;
#define HOLD_COS2r_CLR BCM56504_A0_HOLD_COS2r_CLR
#define HOLD_COS2r_SET BCM56504_A0_HOLD_COS2r_SET
#define HOLD_COS2r_GET BCM56504_A0_HOLD_COS2r_GET
#define HOLD_COS2r_COUNTf_GET BCM56504_A0_HOLD_COS2r_COUNTf_GET
#define HOLD_COS2r_COUNTf_SET BCM56504_A0_HOLD_COS2r_COUNTf_SET
#define READ_HOLD_COS2r BCM56504_A0_READ_HOLD_COS2r
#define WRITE_HOLD_COS2r BCM56504_A0_WRITE_HOLD_COS2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_HOLD_COS2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  HOLD_COS3
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS3 Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            Incremented for each Packet drop due to Head Of Line blocking per egress port COS
 *
 ******************************************************************************/
#define BCM56504_A0_HOLD_COS3r 0x0e780018

#define BCM56504_A0_HOLD_COS3r_SIZE 4

/*
 * This structure should be used to declare and program HOLD_COS3.
 *
 */
typedef union BCM56504_A0_HOLD_COS3r_s {
	uint32_t v[1];
	uint32_t hold_cos3[1];
	uint32_t _hold_cos3;
} BCM56504_A0_HOLD_COS3r_t;

#define BCM56504_A0_HOLD_COS3r_CLR(r) (r).hold_cos3[0] = 0
#define BCM56504_A0_HOLD_COS3r_SET(r,d) (r).hold_cos3[0] = d
#define BCM56504_A0_HOLD_COS3r_GET(r) (r).hold_cos3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_HOLD_COS3r_COUNTf_GET(r) (((r).hold_cos3[0]) & 0x3ffffff)
#define BCM56504_A0_HOLD_COS3r_COUNTf_SET(r,f) (r).hold_cos3[0]=(((r).hold_cos3[0] & ~((uint32_t)0x3ffffff)) | (((uint32_t)f) & 0x3ffffff))

/*
 * These macros can be used to access HOLD_COS3.
 *
 */
#define BCM56504_A0_READ_HOLD_COS3r(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_HOLD_COS3r,(r._hold_cos3))
#define BCM56504_A0_WRITE_HOLD_COS3r(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_HOLD_COS3r,&(r._hold_cos3))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLD_COS3r BCM56504_A0_HOLD_COS3r
#define HOLD_COS3r_SIZE BCM56504_A0_HOLD_COS3r_SIZE
typedef BCM56504_A0_HOLD_COS3r_t HOLD_COS3r_t;
#define HOLD_COS3r_CLR BCM56504_A0_HOLD_COS3r_CLR
#define HOLD_COS3r_SET BCM56504_A0_HOLD_COS3r_SET
#define HOLD_COS3r_GET BCM56504_A0_HOLD_COS3r_GET
#define HOLD_COS3r_COUNTf_GET BCM56504_A0_HOLD_COS3r_COUNTf_GET
#define HOLD_COS3r_COUNTf_SET BCM56504_A0_HOLD_COS3r_COUNTf_SET
#define READ_HOLD_COS3r BCM56504_A0_READ_HOLD_COS3r
#define WRITE_HOLD_COS3r BCM56504_A0_WRITE_HOLD_COS3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_HOLD_COS3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  HOLD_COS4
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS4 Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            Incremented for each Packet drop due to Head Of Line blocking per egress port COS
 *
 ******************************************************************************/
#define BCM56504_A0_HOLD_COS4r 0x0e780019

#define BCM56504_A0_HOLD_COS4r_SIZE 4

/*
 * This structure should be used to declare and program HOLD_COS4.
 *
 */
typedef union BCM56504_A0_HOLD_COS4r_s {
	uint32_t v[1];
	uint32_t hold_cos4[1];
	uint32_t _hold_cos4;
} BCM56504_A0_HOLD_COS4r_t;

#define BCM56504_A0_HOLD_COS4r_CLR(r) (r).hold_cos4[0] = 0
#define BCM56504_A0_HOLD_COS4r_SET(r,d) (r).hold_cos4[0] = d
#define BCM56504_A0_HOLD_COS4r_GET(r) (r).hold_cos4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_HOLD_COS4r_COUNTf_GET(r) (((r).hold_cos4[0]) & 0x3ffffff)
#define BCM56504_A0_HOLD_COS4r_COUNTf_SET(r,f) (r).hold_cos4[0]=(((r).hold_cos4[0] & ~((uint32_t)0x3ffffff)) | (((uint32_t)f) & 0x3ffffff))

/*
 * These macros can be used to access HOLD_COS4.
 *
 */
#define BCM56504_A0_READ_HOLD_COS4r(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_HOLD_COS4r,(r._hold_cos4))
#define BCM56504_A0_WRITE_HOLD_COS4r(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_HOLD_COS4r,&(r._hold_cos4))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLD_COS4r BCM56504_A0_HOLD_COS4r
#define HOLD_COS4r_SIZE BCM56504_A0_HOLD_COS4r_SIZE
typedef BCM56504_A0_HOLD_COS4r_t HOLD_COS4r_t;
#define HOLD_COS4r_CLR BCM56504_A0_HOLD_COS4r_CLR
#define HOLD_COS4r_SET BCM56504_A0_HOLD_COS4r_SET
#define HOLD_COS4r_GET BCM56504_A0_HOLD_COS4r_GET
#define HOLD_COS4r_COUNTf_GET BCM56504_A0_HOLD_COS4r_COUNTf_GET
#define HOLD_COS4r_COUNTf_SET BCM56504_A0_HOLD_COS4r_COUNTf_SET
#define READ_HOLD_COS4r BCM56504_A0_READ_HOLD_COS4r
#define WRITE_HOLD_COS4r BCM56504_A0_WRITE_HOLD_COS4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_HOLD_COS4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  HOLD_COS5
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS5 Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            Incremented for each Packet drop due to Head Of Line blocking per egress port COS
 *
 ******************************************************************************/
#define BCM56504_A0_HOLD_COS5r 0x0e78001a

#define BCM56504_A0_HOLD_COS5r_SIZE 4

/*
 * This structure should be used to declare and program HOLD_COS5.
 *
 */
typedef union BCM56504_A0_HOLD_COS5r_s {
	uint32_t v[1];
	uint32_t hold_cos5[1];
	uint32_t _hold_cos5;
} BCM56504_A0_HOLD_COS5r_t;

#define BCM56504_A0_HOLD_COS5r_CLR(r) (r).hold_cos5[0] = 0
#define BCM56504_A0_HOLD_COS5r_SET(r,d) (r).hold_cos5[0] = d
#define BCM56504_A0_HOLD_COS5r_GET(r) (r).hold_cos5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_HOLD_COS5r_COUNTf_GET(r) (((r).hold_cos5[0]) & 0x3ffffff)
#define BCM56504_A0_HOLD_COS5r_COUNTf_SET(r,f) (r).hold_cos5[0]=(((r).hold_cos5[0] & ~((uint32_t)0x3ffffff)) | (((uint32_t)f) & 0x3ffffff))

/*
 * These macros can be used to access HOLD_COS5.
 *
 */
#define BCM56504_A0_READ_HOLD_COS5r(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_HOLD_COS5r,(r._hold_cos5))
#define BCM56504_A0_WRITE_HOLD_COS5r(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_HOLD_COS5r,&(r._hold_cos5))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLD_COS5r BCM56504_A0_HOLD_COS5r
#define HOLD_COS5r_SIZE BCM56504_A0_HOLD_COS5r_SIZE
typedef BCM56504_A0_HOLD_COS5r_t HOLD_COS5r_t;
#define HOLD_COS5r_CLR BCM56504_A0_HOLD_COS5r_CLR
#define HOLD_COS5r_SET BCM56504_A0_HOLD_COS5r_SET
#define HOLD_COS5r_GET BCM56504_A0_HOLD_COS5r_GET
#define HOLD_COS5r_COUNTf_GET BCM56504_A0_HOLD_COS5r_COUNTf_GET
#define HOLD_COS5r_COUNTf_SET BCM56504_A0_HOLD_COS5r_COUNTf_SET
#define READ_HOLD_COS5r BCM56504_A0_READ_HOLD_COS5r
#define WRITE_HOLD_COS5r BCM56504_A0_WRITE_HOLD_COS5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_HOLD_COS5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  HOLD_COS6
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS6 Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            Incremented for each Packet drop due to Head Of Line blocking per egress port COS
 *
 ******************************************************************************/
#define BCM56504_A0_HOLD_COS6r 0x0e78001b

#define BCM56504_A0_HOLD_COS6r_SIZE 4

/*
 * This structure should be used to declare and program HOLD_COS6.
 *
 */
typedef union BCM56504_A0_HOLD_COS6r_s {
	uint32_t v[1];
	uint32_t hold_cos6[1];
	uint32_t _hold_cos6;
} BCM56504_A0_HOLD_COS6r_t;

#define BCM56504_A0_HOLD_COS6r_CLR(r) (r).hold_cos6[0] = 0
#define BCM56504_A0_HOLD_COS6r_SET(r,d) (r).hold_cos6[0] = d
#define BCM56504_A0_HOLD_COS6r_GET(r) (r).hold_cos6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_HOLD_COS6r_COUNTf_GET(r) (((r).hold_cos6[0]) & 0x3ffffff)
#define BCM56504_A0_HOLD_COS6r_COUNTf_SET(r,f) (r).hold_cos6[0]=(((r).hold_cos6[0] & ~((uint32_t)0x3ffffff)) | (((uint32_t)f) & 0x3ffffff))

/*
 * These macros can be used to access HOLD_COS6.
 *
 */
#define BCM56504_A0_READ_HOLD_COS6r(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_HOLD_COS6r,(r._hold_cos6))
#define BCM56504_A0_WRITE_HOLD_COS6r(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_HOLD_COS6r,&(r._hold_cos6))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLD_COS6r BCM56504_A0_HOLD_COS6r
#define HOLD_COS6r_SIZE BCM56504_A0_HOLD_COS6r_SIZE
typedef BCM56504_A0_HOLD_COS6r_t HOLD_COS6r_t;
#define HOLD_COS6r_CLR BCM56504_A0_HOLD_COS6r_CLR
#define HOLD_COS6r_SET BCM56504_A0_HOLD_COS6r_SET
#define HOLD_COS6r_GET BCM56504_A0_HOLD_COS6r_GET
#define HOLD_COS6r_COUNTf_GET BCM56504_A0_HOLD_COS6r_COUNTf_GET
#define HOLD_COS6r_COUNTf_SET BCM56504_A0_HOLD_COS6r_COUNTf_SET
#define READ_HOLD_COS6r BCM56504_A0_READ_HOLD_COS6r
#define WRITE_HOLD_COS6r BCM56504_A0_WRITE_HOLD_COS6r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_HOLD_COS6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  HOLD_COS7
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS7 Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            Incremented for each Packet drop due to Head Of Line blocking per egress port COS
 *
 ******************************************************************************/
#define BCM56504_A0_HOLD_COS7r 0x0e78001c

#define BCM56504_A0_HOLD_COS7r_SIZE 4

/*
 * This structure should be used to declare and program HOLD_COS7.
 *
 */
typedef union BCM56504_A0_HOLD_COS7r_s {
	uint32_t v[1];
	uint32_t hold_cos7[1];
	uint32_t _hold_cos7;
} BCM56504_A0_HOLD_COS7r_t;

#define BCM56504_A0_HOLD_COS7r_CLR(r) (r).hold_cos7[0] = 0
#define BCM56504_A0_HOLD_COS7r_SET(r,d) (r).hold_cos7[0] = d
#define BCM56504_A0_HOLD_COS7r_GET(r) (r).hold_cos7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_HOLD_COS7r_COUNTf_GET(r) (((r).hold_cos7[0]) & 0x3ffffff)
#define BCM56504_A0_HOLD_COS7r_COUNTf_SET(r,f) (r).hold_cos7[0]=(((r).hold_cos7[0] & ~((uint32_t)0x3ffffff)) | (((uint32_t)f) & 0x3ffffff))

/*
 * These macros can be used to access HOLD_COS7.
 *
 */
#define BCM56504_A0_READ_HOLD_COS7r(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_HOLD_COS7r,(r._hold_cos7))
#define BCM56504_A0_WRITE_HOLD_COS7r(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_HOLD_COS7r,&(r._hold_cos7))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLD_COS7r BCM56504_A0_HOLD_COS7r
#define HOLD_COS7r_SIZE BCM56504_A0_HOLD_COS7r_SIZE
typedef BCM56504_A0_HOLD_COS7r_t HOLD_COS7r_t;
#define HOLD_COS7r_CLR BCM56504_A0_HOLD_COS7r_CLR
#define HOLD_COS7r_SET BCM56504_A0_HOLD_COS7r_SET
#define HOLD_COS7r_GET BCM56504_A0_HOLD_COS7r_GET
#define HOLD_COS7r_COUNTf_GET BCM56504_A0_HOLD_COS7r_COUNTf_GET
#define HOLD_COS7r_COUNTf_SET BCM56504_A0_HOLD_COS7r_COUNTf_SET
#define READ_HOLD_COS7r BCM56504_A0_READ_HOLD_COS7r
#define WRITE_HOLD_COS7r BCM56504_A0_WRITE_HOLD_COS7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_HOLD_COS7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  HOLD_COS_PORT_SELECT
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS Counter Port Select Register
 * SIZE:     32
 * FIELDS:
 *     PORT_NUM         Port number
 *
 ******************************************************************************/
#define BCM56504_A0_HOLD_COS_PORT_SELECTr 0x0e780118

#define BCM56504_A0_HOLD_COS_PORT_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program HOLD_COS_PORT_SELECT.
 *
 */
typedef union BCM56504_A0_HOLD_COS_PORT_SELECTr_s {
	uint32_t v[1];
	uint32_t hold_cos_port_select[1];
	uint32_t _hold_cos_port_select;
} BCM56504_A0_HOLD_COS_PORT_SELECTr_t;

#define BCM56504_A0_HOLD_COS_PORT_SELECTr_CLR(r) (r).hold_cos_port_select[0] = 0
#define BCM56504_A0_HOLD_COS_PORT_SELECTr_SET(r,d) (r).hold_cos_port_select[0] = d
#define BCM56504_A0_HOLD_COS_PORT_SELECTr_GET(r) (r).hold_cos_port_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_HOLD_COS_PORT_SELECTr_PORT_NUMf_GET(r) (((r).hold_cos_port_select[0]) & 0x1f)
#define BCM56504_A0_HOLD_COS_PORT_SELECTr_PORT_NUMf_SET(r,f) (r).hold_cos_port_select[0]=(((r).hold_cos_port_select[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))

/*
 * These macros can be used to access HOLD_COS_PORT_SELECT.
 *
 */
#define BCM56504_A0_READ_HOLD_COS_PORT_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_HOLD_COS_PORT_SELECTr,(r._hold_cos_port_select))
#define BCM56504_A0_WRITE_HOLD_COS_PORT_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_HOLD_COS_PORT_SELECTr,&(r._hold_cos_port_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLD_COS_PORT_SELECTr BCM56504_A0_HOLD_COS_PORT_SELECTr
#define HOLD_COS_PORT_SELECTr_SIZE BCM56504_A0_HOLD_COS_PORT_SELECTr_SIZE
typedef BCM56504_A0_HOLD_COS_PORT_SELECTr_t HOLD_COS_PORT_SELECTr_t;
#define HOLD_COS_PORT_SELECTr_CLR BCM56504_A0_HOLD_COS_PORT_SELECTr_CLR
#define HOLD_COS_PORT_SELECTr_SET BCM56504_A0_HOLD_COS_PORT_SELECTr_SET
#define HOLD_COS_PORT_SELECTr_GET BCM56504_A0_HOLD_COS_PORT_SELECTr_GET
#define HOLD_COS_PORT_SELECTr_PORT_NUMf_GET BCM56504_A0_HOLD_COS_PORT_SELECTr_PORT_NUMf_GET
#define HOLD_COS_PORT_SELECTr_PORT_NUMf_SET BCM56504_A0_HOLD_COS_PORT_SELECTr_PORT_NUMf_SET
#define READ_HOLD_COS_PORT_SELECTr BCM56504_A0_READ_HOLD_COS_PORT_SELECTr
#define WRITE_HOLD_COS_PORT_SELECTr BCM56504_A0_WRITE_HOLD_COS_PORT_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_HOLD_COS_PORT_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  HOL_STAT_BMAP
 * BLOCKS:   IPIPE
 * DESC:     HOL Status Register
 * SIZE:     32
 * FIELDS:
 *     PORT_BITMAP      HOL status port bitmap 
 *
 ******************************************************************************/
#define BCM56504_A0_HOL_STAT_BMAPr 0x0e78010d

#define BCM56504_A0_HOL_STAT_BMAPr_SIZE 4

/*
 * This structure should be used to declare and program HOL_STAT_BMAP.
 *
 */
typedef union BCM56504_A0_HOL_STAT_BMAPr_s {
	uint32_t v[1];
	uint32_t hol_stat_bmap[1];
	uint32_t _hol_stat_bmap;
} BCM56504_A0_HOL_STAT_BMAPr_t;

#define BCM56504_A0_HOL_STAT_BMAPr_CLR(r) (r).hol_stat_bmap[0] = 0
#define BCM56504_A0_HOL_STAT_BMAPr_SET(r,d) (r).hol_stat_bmap[0] = d
#define BCM56504_A0_HOL_STAT_BMAPr_GET(r) (r).hol_stat_bmap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_HOL_STAT_BMAPr_PORT_BITMAPf_GET(r) (((r).hol_stat_bmap[0]) & 0x1fffffff)
#define BCM56504_A0_HOL_STAT_BMAPr_PORT_BITMAPf_SET(r,f) (r).hol_stat_bmap[0]=(((r).hol_stat_bmap[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))

/*
 * These macros can be used to access HOL_STAT_BMAP.
 *
 */
#define BCM56504_A0_READ_HOL_STAT_BMAPr(u,i,r) cdk_xgs_reg32_read(u,BCM56504_A0_HOL_STAT_BMAPr+(i),(r._hol_stat_bmap))
#define BCM56504_A0_WRITE_HOL_STAT_BMAPr(u,i,r) cdk_xgs_reg32_write(u,BCM56504_A0_HOL_STAT_BMAPr+(i),&(r._hol_stat_bmap))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOL_STAT_BMAPr BCM56504_A0_HOL_STAT_BMAPr
#define HOL_STAT_BMAPr_SIZE BCM56504_A0_HOL_STAT_BMAPr_SIZE
typedef BCM56504_A0_HOL_STAT_BMAPr_t HOL_STAT_BMAPr_t;
#define HOL_STAT_BMAPr_CLR BCM56504_A0_HOL_STAT_BMAPr_CLR
#define HOL_STAT_BMAPr_SET BCM56504_A0_HOL_STAT_BMAPr_SET
#define HOL_STAT_BMAPr_GET BCM56504_A0_HOL_STAT_BMAPr_GET
#define HOL_STAT_BMAPr_PORT_BITMAPf_GET BCM56504_A0_HOL_STAT_BMAPr_PORT_BITMAPf_GET
#define HOL_STAT_BMAPr_PORT_BITMAPf_SET BCM56504_A0_HOL_STAT_BMAPr_PORT_BITMAPf_SET
#define READ_HOL_STAT_BMAPr BCM56504_A0_READ_HOL_STAT_BMAPr
#define WRITE_HOL_STAT_BMAPr BCM56504_A0_WRITE_HOL_STAT_BMAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_HOL_STAT_BMAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  IBCAST_BLOCK_MASK
 * BLOCKS:   IPIPE_HI
 * DESC:     Broadcast Block Mask
 * SIZE:     32
 * FIELDS:
 *     BLK_BITMAP       Bitmap of ports to be blocked
 *
 ******************************************************************************/
#define BCM56504_A0_IBCAST_BLOCK_MASKr 0x0e800102

#define BCM56504_A0_IBCAST_BLOCK_MASKr_SIZE 4

/*
 * This structure should be used to declare and program IBCAST_BLOCK_MASK.
 *
 */
typedef union BCM56504_A0_IBCAST_BLOCK_MASKr_s {
	uint32_t v[1];
	uint32_t ibcast_block_mask[1];
	uint32_t _ibcast_block_mask;
} BCM56504_A0_IBCAST_BLOCK_MASKr_t;

#define BCM56504_A0_IBCAST_BLOCK_MASKr_CLR(r) (r).ibcast_block_mask[0] = 0
#define BCM56504_A0_IBCAST_BLOCK_MASKr_SET(r,d) (r).ibcast_block_mask[0] = d
#define BCM56504_A0_IBCAST_BLOCK_MASKr_GET(r) (r).ibcast_block_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_IBCAST_BLOCK_MASKr_BLK_BITMAPf_GET(r) (((r).ibcast_block_mask[0]) & 0x1fffffff)
#define BCM56504_A0_IBCAST_BLOCK_MASKr_BLK_BITMAPf_SET(r,f) (r).ibcast_block_mask[0]=(((r).ibcast_block_mask[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))

/*
 * These macros can be used to access IBCAST_BLOCK_MASK.
 *
 */
#define BCM56504_A0_READ_IBCAST_BLOCK_MASKr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_IBCAST_BLOCK_MASKr,(r._ibcast_block_mask))
#define BCM56504_A0_WRITE_IBCAST_BLOCK_MASKr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_IBCAST_BLOCK_MASKr,&(r._ibcast_block_mask))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IBCAST_BLOCK_MASKr BCM56504_A0_IBCAST_BLOCK_MASKr
#define IBCAST_BLOCK_MASKr_SIZE BCM56504_A0_IBCAST_BLOCK_MASKr_SIZE
typedef BCM56504_A0_IBCAST_BLOCK_MASKr_t IBCAST_BLOCK_MASKr_t;
#define IBCAST_BLOCK_MASKr_CLR BCM56504_A0_IBCAST_BLOCK_MASKr_CLR
#define IBCAST_BLOCK_MASKr_SET BCM56504_A0_IBCAST_BLOCK_MASKr_SET
#define IBCAST_BLOCK_MASKr_GET BCM56504_A0_IBCAST_BLOCK_MASKr_GET
#define IBCAST_BLOCK_MASKr_BLK_BITMAPf_GET BCM56504_A0_IBCAST_BLOCK_MASKr_BLK_BITMAPf_GET
#define IBCAST_BLOCK_MASKr_BLK_BITMAPf_SET BCM56504_A0_IBCAST_BLOCK_MASKr_BLK_BITMAPf_SET
#define READ_IBCAST_BLOCK_MASKr BCM56504_A0_READ_IBCAST_BLOCK_MASKr
#define WRITE_IBCAST_BLOCK_MASKr BCM56504_A0_WRITE_IBCAST_BLOCK_MASKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_IBCAST_BLOCK_MASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  IBPBKPSTATUS
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     PORT_BITMAP      Current Back Pressure warning status
 *
 ******************************************************************************/
#define BCM56504_A0_IBPBKPSTATUSr 0x00680001

#define BCM56504_A0_IBPBKPSTATUSr_SIZE 4

/*
 * This structure should be used to declare and program IBPBKPSTATUS.
 *
 */
typedef union BCM56504_A0_IBPBKPSTATUSr_s {
	uint32_t v[1];
	uint32_t ibpbkpstatus[1];
	uint32_t _ibpbkpstatus;
} BCM56504_A0_IBPBKPSTATUSr_t;

#define BCM56504_A0_IBPBKPSTATUSr_CLR(r) (r).ibpbkpstatus[0] = 0
#define BCM56504_A0_IBPBKPSTATUSr_SET(r,d) (r).ibpbkpstatus[0] = d
#define BCM56504_A0_IBPBKPSTATUSr_GET(r) (r).ibpbkpstatus[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_IBPBKPSTATUSr_PORT_BITMAPf_GET(r) (((r).ibpbkpstatus[0]) & 0x1fffffff)
#define BCM56504_A0_IBPBKPSTATUSr_PORT_BITMAPf_SET(r,f) (r).ibpbkpstatus[0]=(((r).ibpbkpstatus[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))

/*
 * These macros can be used to access IBPBKPSTATUS.
 *
 */
#define BCM56504_A0_READ_IBPBKPSTATUSr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_IBPBKPSTATUSr,(r._ibpbkpstatus))
#define BCM56504_A0_WRITE_IBPBKPSTATUSr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_IBPBKPSTATUSr,&(r._ibpbkpstatus))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IBPBKPSTATUSr BCM56504_A0_IBPBKPSTATUSr
#define IBPBKPSTATUSr_SIZE BCM56504_A0_IBPBKPSTATUSr_SIZE
typedef BCM56504_A0_IBPBKPSTATUSr_t IBPBKPSTATUSr_t;
#define IBPBKPSTATUSr_CLR BCM56504_A0_IBPBKPSTATUSr_CLR
#define IBPBKPSTATUSr_SET BCM56504_A0_IBPBKPSTATUSr_SET
#define IBPBKPSTATUSr_GET BCM56504_A0_IBPBKPSTATUSr_GET
#define IBPBKPSTATUSr_PORT_BITMAPf_GET BCM56504_A0_IBPBKPSTATUSr_PORT_BITMAPf_GET
#define IBPBKPSTATUSr_PORT_BITMAPf_SET BCM56504_A0_IBPBKPSTATUSr_PORT_BITMAPf_SET
#define READ_IBPBKPSTATUSr BCM56504_A0_READ_IBPBKPSTATUSr
#define WRITE_IBPBKPSTATUSr BCM56504_A0_WRITE_IBPBKPSTATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_IBPBKPSTATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  IBPCELLCOUNT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CELLCOUNT        Ingress cell count for all local ingress ports.Number of cells stored per ingress port in CBP Memory.
 *
 ******************************************************************************/
#define BCM56504_A0_IBPCELLCOUNTr 0x00600004

#define BCM56504_A0_IBPCELLCOUNTr_SIZE 4

/*
 * This structure should be used to declare and program IBPCELLCOUNT.
 *
 */
typedef union BCM56504_A0_IBPCELLCOUNTr_s {
	uint32_t v[1];
	uint32_t ibpcellcount[1];
	uint32_t _ibpcellcount;
} BCM56504_A0_IBPCELLCOUNTr_t;

#define BCM56504_A0_IBPCELLCOUNTr_CLR(r) (r).ibpcellcount[0] = 0
#define BCM56504_A0_IBPCELLCOUNTr_SET(r,d) (r).ibpcellcount[0] = d
#define BCM56504_A0_IBPCELLCOUNTr_GET(r) (r).ibpcellcount[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_IBPCELLCOUNTr_CELLCOUNTf_GET(r) (((r).ibpcellcount[0]) & 0x3fff)
#define BCM56504_A0_IBPCELLCOUNTr_CELLCOUNTf_SET(r,f) (r).ibpcellcount[0]=(((r).ibpcellcount[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access IBPCELLCOUNT.
 *
 */
#define BCM56504_A0_READ_IBPCELLCOUNTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_IBPCELLCOUNTr,(r._ibpcellcount))
#define BCM56504_A0_WRITE_IBPCELLCOUNTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_IBPCELLCOUNTr,&(r._ibpcellcount))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IBPCELLCOUNTr BCM56504_A0_IBPCELLCOUNTr
#define IBPCELLCOUNTr_SIZE BCM56504_A0_IBPCELLCOUNTr_SIZE
typedef BCM56504_A0_IBPCELLCOUNTr_t IBPCELLCOUNTr_t;
#define IBPCELLCOUNTr_CLR BCM56504_A0_IBPCELLCOUNTr_CLR
#define IBPCELLCOUNTr_SET BCM56504_A0_IBPCELLCOUNTr_SET
#define IBPCELLCOUNTr_GET BCM56504_A0_IBPCELLCOUNTr_GET
#define IBPCELLCOUNTr_CELLCOUNTf_GET BCM56504_A0_IBPCELLCOUNTr_CELLCOUNTf_GET
#define IBPCELLCOUNTr_CELLCOUNTf_SET BCM56504_A0_IBPCELLCOUNTr_CELLCOUNTf_SET
#define READ_IBPCELLCOUNTr BCM56504_A0_READ_IBPCELLCOUNTr
#define WRITE_IBPCELLCOUNTr BCM56504_A0_WRITE_IBPCELLCOUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_IBPCELLCOUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  IBPCELLSETLIMIT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CELLSETLIMIT     Back Pressure cell high threshold for all local ingress ports\' cell counts. Unit is the number of cells per port.
 *     RESETLIMITSEL    IBP Cell Reset Threshold for all local ingress ports.When Back pressure status is set, packet counts have to fall below Reset Threshold in order to clear BKP status. 2'b00: 75.0% of IBP Cell Set Limit.2'b01: 50.0% of IBP Cell Set Limit.    2'b10: 25.0% of IBP Cell Set Limit.    2'b11: 12.5% of IBP Cell Set Limit.    
 *
 ******************************************************************************/
#define BCM56504_A0_IBPCELLSETLIMITr 0x00600002

#define BCM56504_A0_IBPCELLSETLIMITr_SIZE 4

/*
 * This structure should be used to declare and program IBPCELLSETLIMIT.
 *
 */
typedef union BCM56504_A0_IBPCELLSETLIMITr_s {
	uint32_t v[1];
	uint32_t ibpcellsetlimit[1];
	uint32_t _ibpcellsetlimit;
} BCM56504_A0_IBPCELLSETLIMITr_t;

#define BCM56504_A0_IBPCELLSETLIMITr_CLR(r) (r).ibpcellsetlimit[0] = 0
#define BCM56504_A0_IBPCELLSETLIMITr_SET(r,d) (r).ibpcellsetlimit[0] = d
#define BCM56504_A0_IBPCELLSETLIMITr_GET(r) (r).ibpcellsetlimit[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_IBPCELLSETLIMITr_CELLSETLIMITf_GET(r) (((r).ibpcellsetlimit[0]) & 0x3fff)
#define BCM56504_A0_IBPCELLSETLIMITr_CELLSETLIMITf_SET(r,f) (r).ibpcellsetlimit[0]=(((r).ibpcellsetlimit[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM56504_A0_IBPCELLSETLIMITr_RESETLIMITSELf_GET(r) ((((r).ibpcellsetlimit[0]) >> 14) & 0x3)
#define BCM56504_A0_IBPCELLSETLIMITr_RESETLIMITSELf_SET(r,f) (r).ibpcellsetlimit[0]=(((r).ibpcellsetlimit[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))

/*
 * These macros can be used to access IBPCELLSETLIMIT.
 *
 */
#define BCM56504_A0_READ_IBPCELLSETLIMITr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_IBPCELLSETLIMITr,(r._ibpcellsetlimit))
#define BCM56504_A0_WRITE_IBPCELLSETLIMITr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_IBPCELLSETLIMITr,&(r._ibpcellsetlimit))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IBPCELLSETLIMITr BCM56504_A0_IBPCELLSETLIMITr
#define IBPCELLSETLIMITr_SIZE BCM56504_A0_IBPCELLSETLIMITr_SIZE
typedef BCM56504_A0_IBPCELLSETLIMITr_t IBPCELLSETLIMITr_t;
#define IBPCELLSETLIMITr_CLR BCM56504_A0_IBPCELLSETLIMITr_CLR
#define IBPCELLSETLIMITr_SET BCM56504_A0_IBPCELLSETLIMITr_SET
#define IBPCELLSETLIMITr_GET BCM56504_A0_IBPCELLSETLIMITr_GET
#define IBPCELLSETLIMITr_CELLSETLIMITf_GET BCM56504_A0_IBPCELLSETLIMITr_CELLSETLIMITf_GET
#define IBPCELLSETLIMITr_CELLSETLIMITf_SET BCM56504_A0_IBPCELLSETLIMITr_CELLSETLIMITf_SET
#define IBPCELLSETLIMITr_RESETLIMITSELf_GET BCM56504_A0_IBPCELLSETLIMITr_RESETLIMITSELf_GET
#define IBPCELLSETLIMITr_RESETLIMITSELf_SET BCM56504_A0_IBPCELLSETLIMITr_RESETLIMITSELf_SET
#define READ_IBPCELLSETLIMITr BCM56504_A0_READ_IBPCELLSETLIMITr
#define WRITE_IBPCELLSETLIMITr BCM56504_A0_WRITE_IBPCELLSETLIMITr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_IBPCELLSETLIMITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  IBPDISCARDSETLIMIT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     DISCARDSETLIMIT  Back Pressure Discard threshold for all local ingress ports cell counts.When an ingress port\'s cell count is above Discard Set Limit, all of incoming packet from this port are discarded. Discard Limit must be set above than IBPCELLSETLIMIT to prevent unexpected behavior. This limit represents an absolute value and is not related to IBPCELLSETLIMIT. Unit is the number of cells per port.
 *
 ******************************************************************************/
#define BCM56504_A0_IBPDISCARDSETLIMITr 0x00600003

#define BCM56504_A0_IBPDISCARDSETLIMITr_SIZE 4

/*
 * This structure should be used to declare and program IBPDISCARDSETLIMIT.
 *
 */
typedef union BCM56504_A0_IBPDISCARDSETLIMITr_s {
	uint32_t v[1];
	uint32_t ibpdiscardsetlimit[1];
	uint32_t _ibpdiscardsetlimit;
} BCM56504_A0_IBPDISCARDSETLIMITr_t;

#define BCM56504_A0_IBPDISCARDSETLIMITr_CLR(r) (r).ibpdiscardsetlimit[0] = 0
#define BCM56504_A0_IBPDISCARDSETLIMITr_SET(r,d) (r).ibpdiscardsetlimit[0] = d
#define BCM56504_A0_IBPDISCARDSETLIMITr_GET(r) (r).ibpdiscardsetlimit[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_IBPDISCARDSETLIMITr_DISCARDSETLIMITf_GET(r) (((r).ibpdiscardsetlimit[0]) & 0x3fff)
#define BCM56504_A0_IBPDISCARDSETLIMITr_DISCARDSETLIMITf_SET(r,f) (r).ibpdiscardsetlimit[0]=(((r).ibpdiscardsetlimit[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access IBPDISCARDSETLIMIT.
 *
 */
#define BCM56504_A0_READ_IBPDISCARDSETLIMITr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_IBPDISCARDSETLIMITr,(r._ibpdiscardsetlimit))
#define BCM56504_A0_WRITE_IBPDISCARDSETLIMITr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_IBPDISCARDSETLIMITr,&(r._ibpdiscardsetlimit))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IBPDISCARDSETLIMITr BCM56504_A0_IBPDISCARDSETLIMITr
#define IBPDISCARDSETLIMITr_SIZE BCM56504_A0_IBPDISCARDSETLIMITr_SIZE
typedef BCM56504_A0_IBPDISCARDSETLIMITr_t IBPDISCARDSETLIMITr_t;
#define IBPDISCARDSETLIMITr_CLR BCM56504_A0_IBPDISCARDSETLIMITr_CLR
#define IBPDISCARDSETLIMITr_SET BCM56504_A0_IBPDISCARDSETLIMITr_SET
#define IBPDISCARDSETLIMITr_GET BCM56504_A0_IBPDISCARDSETLIMITr_GET
#define IBPDISCARDSETLIMITr_DISCARDSETLIMITf_GET BCM56504_A0_IBPDISCARDSETLIMITr_DISCARDSETLIMITf_GET
#define IBPDISCARDSETLIMITr_DISCARDSETLIMITf_SET BCM56504_A0_IBPDISCARDSETLIMITr_DISCARDSETLIMITf_SET
#define READ_IBPDISCARDSETLIMITr BCM56504_A0_READ_IBPDISCARDSETLIMITr
#define WRITE_IBPDISCARDSETLIMITr BCM56504_A0_WRITE_IBPDISCARDSETLIMITr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_IBPDISCARDSETLIMITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  IBPDISCSTATUS
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     PORT_BITMAP      Current IBP discard status
 *
 ******************************************************************************/
#define BCM56504_A0_IBPDISCSTATUSr 0x00680004

#define BCM56504_A0_IBPDISCSTATUSr_SIZE 4

/*
 * This structure should be used to declare and program IBPDISCSTATUS.
 *
 */
typedef union BCM56504_A0_IBPDISCSTATUSr_s {
	uint32_t v[1];
	uint32_t ibpdiscstatus[1];
	uint32_t _ibpdiscstatus;
} BCM56504_A0_IBPDISCSTATUSr_t;

#define BCM56504_A0_IBPDISCSTATUSr_CLR(r) (r).ibpdiscstatus[0] = 0
#define BCM56504_A0_IBPDISCSTATUSr_SET(r,d) (r).ibpdiscstatus[0] = d
#define BCM56504_A0_IBPDISCSTATUSr_GET(r) (r).ibpdiscstatus[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_IBPDISCSTATUSr_PORT_BITMAPf_GET(r) (((r).ibpdiscstatus[0]) & 0x1fffffff)
#define BCM56504_A0_IBPDISCSTATUSr_PORT_BITMAPf_SET(r,f) (r).ibpdiscstatus[0]=(((r).ibpdiscstatus[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))

/*
 * These macros can be used to access IBPDISCSTATUS.
 *
 */
#define BCM56504_A0_READ_IBPDISCSTATUSr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_IBPDISCSTATUSr,(r._ibpdiscstatus))
#define BCM56504_A0_WRITE_IBPDISCSTATUSr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_IBPDISCSTATUSr,&(r._ibpdiscstatus))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IBPDISCSTATUSr BCM56504_A0_IBPDISCSTATUSr
#define IBPDISCSTATUSr_SIZE BCM56504_A0_IBPDISCSTATUSr_SIZE
typedef BCM56504_A0_IBPDISCSTATUSr_t IBPDISCSTATUSr_t;
#define IBPDISCSTATUSr_CLR BCM56504_A0_IBPDISCSTATUSr_CLR
#define IBPDISCSTATUSr_SET BCM56504_A0_IBPDISCSTATUSr_SET
#define IBPDISCSTATUSr_GET BCM56504_A0_IBPDISCSTATUSr_GET
#define IBPDISCSTATUSr_PORT_BITMAPf_GET BCM56504_A0_IBPDISCSTATUSr_PORT_BITMAPf_GET
#define IBPDISCSTATUSr_PORT_BITMAPf_SET BCM56504_A0_IBPDISCSTATUSr_PORT_BITMAPf_SET
#define READ_IBPDISCSTATUSr BCM56504_A0_READ_IBPDISCSTATUSr
#define WRITE_IBPDISCSTATUSr BCM56504_A0_WRITE_IBPDISCSTATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_IBPDISCSTATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  IBPPKTCOUNT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     PKTCOUNT         Ingress packet count for all local ingress ports.Number of packets stored per ingress port in XQ memories.
 *
 ******************************************************************************/
#define BCM56504_A0_IBPPKTCOUNTr 0x00600001

#define BCM56504_A0_IBPPKTCOUNTr_SIZE 4

/*
 * This structure should be used to declare and program IBPPKTCOUNT.
 *
 */
typedef union BCM56504_A0_IBPPKTCOUNTr_s {
	uint32_t v[1];
	uint32_t ibppktcount[1];
	uint32_t _ibppktcount;
} BCM56504_A0_IBPPKTCOUNTr_t;

#define BCM56504_A0_IBPPKTCOUNTr_CLR(r) (r).ibppktcount[0] = 0
#define BCM56504_A0_IBPPKTCOUNTr_SET(r,d) (r).ibppktcount[0] = d
#define BCM56504_A0_IBPPKTCOUNTr_GET(r) (r).ibppktcount[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_IBPPKTCOUNTr_PKTCOUNTf_GET(r) (((r).ibppktcount[0]) & 0x3fff)
#define BCM56504_A0_IBPPKTCOUNTr_PKTCOUNTf_SET(r,f) (r).ibppktcount[0]=(((r).ibppktcount[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access IBPPKTCOUNT.
 *
 */
#define BCM56504_A0_READ_IBPPKTCOUNTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_IBPPKTCOUNTr,(r._ibppktcount))
#define BCM56504_A0_WRITE_IBPPKTCOUNTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_IBPPKTCOUNTr,&(r._ibppktcount))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IBPPKTCOUNTr BCM56504_A0_IBPPKTCOUNTr
#define IBPPKTCOUNTr_SIZE BCM56504_A0_IBPPKTCOUNTr_SIZE
typedef BCM56504_A0_IBPPKTCOUNTr_t IBPPKTCOUNTr_t;
#define IBPPKTCOUNTr_CLR BCM56504_A0_IBPPKTCOUNTr_CLR
#define IBPPKTCOUNTr_SET BCM56504_A0_IBPPKTCOUNTr_SET
#define IBPPKTCOUNTr_GET BCM56504_A0_IBPPKTCOUNTr_GET
#define IBPPKTCOUNTr_PKTCOUNTf_GET BCM56504_A0_IBPPKTCOUNTr_PKTCOUNTf_GET
#define IBPPKTCOUNTr_PKTCOUNTf_SET BCM56504_A0_IBPPKTCOUNTr_PKTCOUNTf_SET
#define READ_IBPPKTCOUNTr BCM56504_A0_READ_IBPPKTCOUNTr
#define WRITE_IBPPKTCOUNTr BCM56504_A0_WRITE_IBPPKTCOUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_IBPPKTCOUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  IBPPKTSETLIMIT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     PKTSETLIMIT      Back Pressure packet high threshold for all local ingress ports packet counts. Unit is the number of packets per port.
 *     RESETLIMITSEL    IBP Packet Reset Threshold Select opions for all local ingress ports.When Back pressure status is set, packet counts have to fall below Reset Threshold in order to clear BKP status. 2'b00: 75.0% of IBP Packet Set Limit.2'b01: 50.0% of IBP Packet Set Limit.  2'b10: 25.0% of IBP Packet Set Limit.  2'b11: 12.5% of IBP Packet Set Limit.  
 *
 ******************************************************************************/
#define BCM56504_A0_IBPPKTSETLIMITr 0x00600000

#define BCM56504_A0_IBPPKTSETLIMITr_SIZE 4

/*
 * This structure should be used to declare and program IBPPKTSETLIMIT.
 *
 */
typedef union BCM56504_A0_IBPPKTSETLIMITr_s {
	uint32_t v[1];
	uint32_t ibppktsetlimit[1];
	uint32_t _ibppktsetlimit;
} BCM56504_A0_IBPPKTSETLIMITr_t;

#define BCM56504_A0_IBPPKTSETLIMITr_CLR(r) (r).ibppktsetlimit[0] = 0
#define BCM56504_A0_IBPPKTSETLIMITr_SET(r,d) (r).ibppktsetlimit[0] = d
#define BCM56504_A0_IBPPKTSETLIMITr_GET(r) (r).ibppktsetlimit[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_IBPPKTSETLIMITr_PKTSETLIMITf_GET(r) (((r).ibppktsetlimit[0]) & 0x3fff)
#define BCM56504_A0_IBPPKTSETLIMITr_PKTSETLIMITf_SET(r,f) (r).ibppktsetlimit[0]=(((r).ibppktsetlimit[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM56504_A0_IBPPKTSETLIMITr_RESETLIMITSELf_GET(r) ((((r).ibppktsetlimit[0]) >> 14) & 0x3)
#define BCM56504_A0_IBPPKTSETLIMITr_RESETLIMITSELf_SET(r,f) (r).ibppktsetlimit[0]=(((r).ibppktsetlimit[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))

/*
 * These macros can be used to access IBPPKTSETLIMIT.
 *
 */
#define BCM56504_A0_READ_IBPPKTSETLIMITr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_IBPPKTSETLIMITr,(r._ibppktsetlimit))
#define BCM56504_A0_WRITE_IBPPKTSETLIMITr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_IBPPKTSETLIMITr,&(r._ibppktsetlimit))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IBPPKTSETLIMITr BCM56504_A0_IBPPKTSETLIMITr
#define IBPPKTSETLIMITr_SIZE BCM56504_A0_IBPPKTSETLIMITr_SIZE
typedef BCM56504_A0_IBPPKTSETLIMITr_t IBPPKTSETLIMITr_t;
#define IBPPKTSETLIMITr_CLR BCM56504_A0_IBPPKTSETLIMITr_CLR
#define IBPPKTSETLIMITr_SET BCM56504_A0_IBPPKTSETLIMITr_SET
#define IBPPKTSETLIMITr_GET BCM56504_A0_IBPPKTSETLIMITr_GET
#define IBPPKTSETLIMITr_PKTSETLIMITf_GET BCM56504_A0_IBPPKTSETLIMITr_PKTSETLIMITf_GET
#define IBPPKTSETLIMITr_PKTSETLIMITf_SET BCM56504_A0_IBPPKTSETLIMITr_PKTSETLIMITf_SET
#define IBPPKTSETLIMITr_RESETLIMITSELf_GET BCM56504_A0_IBPPKTSETLIMITr_RESETLIMITSELf_GET
#define IBPPKTSETLIMITr_RESETLIMITSELf_SET BCM56504_A0_IBPPKTSETLIMITr_RESETLIMITSELf_SET
#define READ_IBPPKTSETLIMITr BCM56504_A0_READ_IBPPKTSETLIMITr
#define WRITE_IBPPKTSETLIMITr BCM56504_A0_WRITE_IBPPKTSETLIMITr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_IBPPKTSETLIMITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  ICONTROL_OPCODE_BITMAP
 * BLOCKS:   IPIPE_HI
 * DESC:     Higig control packet's switching bitmap register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           HiGig CONTROL opcode redirection
 *
 ******************************************************************************/
#define BCM56504_A0_ICONTROL_OPCODE_BITMAPr 0x0b800008

#define BCM56504_A0_ICONTROL_OPCODE_BITMAPr_SIZE 4

/*
 * This structure should be used to declare and program ICONTROL_OPCODE_BITMAP.
 *
 */
typedef union BCM56504_A0_ICONTROL_OPCODE_BITMAPr_s {
	uint32_t v[1];
	uint32_t icontrol_opcode_bitmap[1];
	uint32_t _icontrol_opcode_bitmap;
} BCM56504_A0_ICONTROL_OPCODE_BITMAPr_t;

#define BCM56504_A0_ICONTROL_OPCODE_BITMAPr_CLR(r) (r).icontrol_opcode_bitmap[0] = 0
#define BCM56504_A0_ICONTROL_OPCODE_BITMAPr_SET(r,d) (r).icontrol_opcode_bitmap[0] = d
#define BCM56504_A0_ICONTROL_OPCODE_BITMAPr_GET(r) (r).icontrol_opcode_bitmap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_ICONTROL_OPCODE_BITMAPr_BITMAPf_GET(r) (((r).icontrol_opcode_bitmap[0]) & 0x1f)
#define BCM56504_A0_ICONTROL_OPCODE_BITMAPr_BITMAPf_SET(r,f) (r).icontrol_opcode_bitmap[0]=(((r).icontrol_opcode_bitmap[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))

/*
 * These macros can be used to access ICONTROL_OPCODE_BITMAP.
 *
 */
#define BCM56504_A0_READ_ICONTROL_OPCODE_BITMAPr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_ICONTROL_OPCODE_BITMAPr,(r._icontrol_opcode_bitmap))
#define BCM56504_A0_WRITE_ICONTROL_OPCODE_BITMAPr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_ICONTROL_OPCODE_BITMAPr,&(r._icontrol_opcode_bitmap))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ICONTROL_OPCODE_BITMAPr BCM56504_A0_ICONTROL_OPCODE_BITMAPr
#define ICONTROL_OPCODE_BITMAPr_SIZE BCM56504_A0_ICONTROL_OPCODE_BITMAPr_SIZE
typedef BCM56504_A0_ICONTROL_OPCODE_BITMAPr_t ICONTROL_OPCODE_BITMAPr_t;
#define ICONTROL_OPCODE_BITMAPr_CLR BCM56504_A0_ICONTROL_OPCODE_BITMAPr_CLR
#define ICONTROL_OPCODE_BITMAPr_SET BCM56504_A0_ICONTROL_OPCODE_BITMAPr_SET
#define ICONTROL_OPCODE_BITMAPr_GET BCM56504_A0_ICONTROL_OPCODE_BITMAPr_GET
#define ICONTROL_OPCODE_BITMAPr_BITMAPf_GET BCM56504_A0_ICONTROL_OPCODE_BITMAPr_BITMAPf_GET
#define ICONTROL_OPCODE_BITMAPr_BITMAPf_SET BCM56504_A0_ICONTROL_OPCODE_BITMAPr_BITMAPf_SET
#define READ_ICONTROL_OPCODE_BITMAPr BCM56504_A0_READ_ICONTROL_OPCODE_BITMAPr
#define WRITE_ICONTROL_OPCODE_BITMAPr BCM56504_A0_WRITE_ICONTROL_OPCODE_BITMAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_ICONTROL_OPCODE_BITMAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  ICOS_SEL
 * BLOCKS:   IPIPE_HI
 * DESC:     COS Queue Mapping Register
 * SIZE:     32
 * FIELDS:
 *     COS0             COS-0 Value
 *     COS1             COS-1 Value
 *     COS2             COS-2 Value
 *     COS3             COS-3 Value
 *     COS4             COS-4 Value
 *     COS5             COS-5 Value
 *     COS6             COS-6 Value
 *     COS7             COS-7 Value
 *
 ******************************************************************************/
#define BCM56504_A0_ICOS_SELr 0x0e80010a

#define BCM56504_A0_ICOS_SELr_SIZE 4

/*
 * This structure should be used to declare and program ICOS_SEL.
 *
 */
typedef union BCM56504_A0_ICOS_SELr_s {
	uint32_t v[1];
	uint32_t icos_sel[1];
	uint32_t _icos_sel;
} BCM56504_A0_ICOS_SELr_t;

#define BCM56504_A0_ICOS_SELr_CLR(r) (r).icos_sel[0] = 0
#define BCM56504_A0_ICOS_SELr_SET(r,d) (r).icos_sel[0] = d
#define BCM56504_A0_ICOS_SELr_GET(r) (r).icos_sel[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_ICOS_SELr_COS0f_GET(r) (((r).icos_sel[0]) & 0x7)
#define BCM56504_A0_ICOS_SELr_COS0f_SET(r,f) (r).icos_sel[0]=(((r).icos_sel[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM56504_A0_ICOS_SELr_COS1f_GET(r) ((((r).icos_sel[0]) >> 3) & 0x7)
#define BCM56504_A0_ICOS_SELr_COS1f_SET(r,f) (r).icos_sel[0]=(((r).icos_sel[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM56504_A0_ICOS_SELr_COS2f_GET(r) ((((r).icos_sel[0]) >> 6) & 0x7)
#define BCM56504_A0_ICOS_SELr_COS2f_SET(r,f) (r).icos_sel[0]=(((r).icos_sel[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM56504_A0_ICOS_SELr_COS3f_GET(r) ((((r).icos_sel[0]) >> 9) & 0x7)
#define BCM56504_A0_ICOS_SELr_COS3f_SET(r,f) (r).icos_sel[0]=(((r).icos_sel[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM56504_A0_ICOS_SELr_COS4f_GET(r) ((((r).icos_sel[0]) >> 12) & 0x7)
#define BCM56504_A0_ICOS_SELr_COS4f_SET(r,f) (r).icos_sel[0]=(((r).icos_sel[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM56504_A0_ICOS_SELr_COS5f_GET(r) ((((r).icos_sel[0]) >> 15) & 0x7)
#define BCM56504_A0_ICOS_SELr_COS5f_SET(r,f) (r).icos_sel[0]=(((r).icos_sel[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM56504_A0_ICOS_SELr_COS6f_GET(r) ((((r).icos_sel[0]) >> 18) & 0x7)
#define BCM56504_A0_ICOS_SELr_COS6f_SET(r,f) (r).icos_sel[0]=(((r).icos_sel[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM56504_A0_ICOS_SELr_COS7f_GET(r) ((((r).icos_sel[0]) >> 21) & 0x7)
#define BCM56504_A0_ICOS_SELr_COS7f_SET(r,f) (r).icos_sel[0]=(((r).icos_sel[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))

/*
 * These macros can be used to access ICOS_SEL.
 *
 */
#define BCM56504_A0_READ_ICOS_SELr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_ICOS_SELr,(r._icos_sel))
#define BCM56504_A0_WRITE_ICOS_SELr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_ICOS_SELr,&(r._icos_sel))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ICOS_SELr BCM56504_A0_ICOS_SELr
#define ICOS_SELr_SIZE BCM56504_A0_ICOS_SELr_SIZE
typedef BCM56504_A0_ICOS_SELr_t ICOS_SELr_t;
#define ICOS_SELr_CLR BCM56504_A0_ICOS_SELr_CLR
#define ICOS_SELr_SET BCM56504_A0_ICOS_SELr_SET
#define ICOS_SELr_GET BCM56504_A0_ICOS_SELr_GET
#define ICOS_SELr_COS0f_GET BCM56504_A0_ICOS_SELr_COS0f_GET
#define ICOS_SELr_COS0f_SET BCM56504_A0_ICOS_SELr_COS0f_SET
#define ICOS_SELr_COS1f_GET BCM56504_A0_ICOS_SELr_COS1f_GET
#define ICOS_SELr_COS1f_SET BCM56504_A0_ICOS_SELr_COS1f_SET
#define ICOS_SELr_COS2f_GET BCM56504_A0_ICOS_SELr_COS2f_GET
#define ICOS_SELr_COS2f_SET BCM56504_A0_ICOS_SELr_COS2f_SET
#define ICOS_SELr_COS3f_GET BCM56504_A0_ICOS_SELr_COS3f_GET
#define ICOS_SELr_COS3f_SET BCM56504_A0_ICOS_SELr_COS3f_SET
#define ICOS_SELr_COS4f_GET BCM56504_A0_ICOS_SELr_COS4f_GET
#define ICOS_SELr_COS4f_SET BCM56504_A0_ICOS_SELr_COS4f_SET
#define ICOS_SELr_COS5f_GET BCM56504_A0_ICOS_SELr_COS5f_GET
#define ICOS_SELr_COS5f_SET BCM56504_A0_ICOS_SELr_COS5f_SET
#define ICOS_SELr_COS6f_GET BCM56504_A0_ICOS_SELr_COS6f_GET
#define ICOS_SELr_COS6f_SET BCM56504_A0_ICOS_SELr_COS6f_SET
#define ICOS_SELr_COS7f_GET BCM56504_A0_ICOS_SELr_COS7f_GET
#define ICOS_SELr_COS7f_SET BCM56504_A0_ICOS_SELr_COS7f_SET
#define READ_ICOS_SELr BCM56504_A0_READ_ICOS_SELr
#define WRITE_ICOS_SELr BCM56504_A0_WRITE_ICOS_SELr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_ICOS_SELr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  IE2E_CONTROL
 * BLOCKS:   IPIPE_HI
 * DESC:     End-to-End Control Register
 * SIZE:     32
 * FIELDS:
 *     HOL_TOCPU        End-to-End HOL messages are sent to the CPU
 *     IBP_TOCPU        End-to-End IBP messages are sent to the CPU
 *     HOL_ENABLE       End-to-End HOL messages are detected in Ingress Pipeline
 *     IBP_ENABLE       End-to-End IBP messages are detected in Ingress Pipeline
 *
 ******************************************************************************/
#define BCM56504_A0_IE2E_CONTROLr 0x01800004

#define BCM56504_A0_IE2E_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program IE2E_CONTROL.
 *
 */
typedef union BCM56504_A0_IE2E_CONTROLr_s {
	uint32_t v[1];
	uint32_t ie2e_control[1];
	uint32_t _ie2e_control;
} BCM56504_A0_IE2E_CONTROLr_t;

#define BCM56504_A0_IE2E_CONTROLr_CLR(r) (r).ie2e_control[0] = 0
#define BCM56504_A0_IE2E_CONTROLr_SET(r,d) (r).ie2e_control[0] = d
#define BCM56504_A0_IE2E_CONTROLr_GET(r) (r).ie2e_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_IE2E_CONTROLr_HOL_TOCPUf_GET(r) (((r).ie2e_control[0]) & 0x1)
#define BCM56504_A0_IE2E_CONTROLr_HOL_TOCPUf_SET(r,f) (r).ie2e_control[0]=(((r).ie2e_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_IE2E_CONTROLr_IBP_TOCPUf_GET(r) ((((r).ie2e_control[0]) >> 1) & 0x1)
#define BCM56504_A0_IE2E_CONTROLr_IBP_TOCPUf_SET(r,f) (r).ie2e_control[0]=(((r).ie2e_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_IE2E_CONTROLr_HOL_ENABLEf_GET(r) ((((r).ie2e_control[0]) >> 2) & 0x1)
#define BCM56504_A0_IE2E_CONTROLr_HOL_ENABLEf_SET(r,f) (r).ie2e_control[0]=(((r).ie2e_control[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_IE2E_CONTROLr_IBP_ENABLEf_GET(r) ((((r).ie2e_control[0]) >> 3) & 0x1)
#define BCM56504_A0_IE2E_CONTROLr_IBP_ENABLEf_SET(r,f) (r).ie2e_control[0]=(((r).ie2e_control[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))

/*
 * These macros can be used to access IE2E_CONTROL.
 *
 */
#define BCM56504_A0_READ_IE2E_CONTROLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_IE2E_CONTROLr,(r._ie2e_control))
#define BCM56504_A0_WRITE_IE2E_CONTROLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_IE2E_CONTROLr,&(r._ie2e_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IE2E_CONTROLr BCM56504_A0_IE2E_CONTROLr
#define IE2E_CONTROLr_SIZE BCM56504_A0_IE2E_CONTROLr_SIZE
typedef BCM56504_A0_IE2E_CONTROLr_t IE2E_CONTROLr_t;
#define IE2E_CONTROLr_CLR BCM56504_A0_IE2E_CONTROLr_CLR
#define IE2E_CONTROLr_SET BCM56504_A0_IE2E_CONTROLr_SET
#define IE2E_CONTROLr_GET BCM56504_A0_IE2E_CONTROLr_GET
#define IE2E_CONTROLr_HOL_TOCPUf_GET BCM56504_A0_IE2E_CONTROLr_HOL_TOCPUf_GET
#define IE2E_CONTROLr_HOL_TOCPUf_SET BCM56504_A0_IE2E_CONTROLr_HOL_TOCPUf_SET
#define IE2E_CONTROLr_IBP_TOCPUf_GET BCM56504_A0_IE2E_CONTROLr_IBP_TOCPUf_GET
#define IE2E_CONTROLr_IBP_TOCPUf_SET BCM56504_A0_IE2E_CONTROLr_IBP_TOCPUf_SET
#define IE2E_CONTROLr_HOL_ENABLEf_GET BCM56504_A0_IE2E_CONTROLr_HOL_ENABLEf_GET
#define IE2E_CONTROLr_HOL_ENABLEf_SET BCM56504_A0_IE2E_CONTROLr_HOL_ENABLEf_SET
#define IE2E_CONTROLr_IBP_ENABLEf_GET BCM56504_A0_IE2E_CONTROLr_IBP_ENABLEf_GET
#define IE2E_CONTROLr_IBP_ENABLEf_SET BCM56504_A0_IE2E_CONTROLr_IBP_ENABLEf_SET
#define READ_IE2E_CONTROLr BCM56504_A0_READ_IE2E_CONTROLr
#define WRITE_IE2E_CONTROLr BCM56504_A0_WRITE_IE2E_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_IE2E_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  IEGR_PORT
 * BLOCKS:   EPIPE_HI
 * DESC:     Configuration Register for a Port. This is different for each GE, 10GE port.


 * SIZE:     32
 * FIELDS:
 *     PORT_TYPE        Specifies the type of the port. Bit[0] of PORT_TYPE field is HIGIG_BIT. If it is set, then the port is in Higig Mode.	0 = GE/10GE/CPU Port.	1 = HIGIG Port.Bit[1] of PORT_TYPE field is NNI_BIT. If it is set, then the port is NNI port, else UNI Port.	0 = UNI Port.	1 = NNI Port.
 *     EN_EFILTER       If this bit is set, the VLAN Membership check is done for the outgoing port.
 *     PRESERVE_CPU_TAG Preserve the tag of the packet destines to CPU.
 *     CFI              If CFI-CNG mapping is enabled for the chip, i.e. EGR_CONFIG.CFI_AS_CNG bit is set, then thisfield corresponds to the values of CNG coming from MMU. e.g. If MMU.CNG = 0, then Packet.CFI = CFI[0]     If MMU.CNG = 1, then Packet.CFI = CFI[1] and so on.
 *     HIGIG_PACKET     This port is a higig port.
 *     NNI_PORT         Port is NNI port if set to 1, otherwise UNI port.
 *
 ******************************************************************************/
#define BCM56504_A0_IEGR_PORTr 0x01a00002

#define BCM56504_A0_IEGR_PORTr_SIZE 4

/*
 * This structure should be used to declare and program IEGR_PORT.
 *
 */
typedef union BCM56504_A0_IEGR_PORTr_s {
	uint32_t v[1];
	uint32_t iegr_port[1];
	uint32_t _iegr_port;
} BCM56504_A0_IEGR_PORTr_t;

#define BCM56504_A0_IEGR_PORTr_CLR(r) (r).iegr_port[0] = 0
#define BCM56504_A0_IEGR_PORTr_SET(r,d) (r).iegr_port[0] = d
#define BCM56504_A0_IEGR_PORTr_GET(r) (r).iegr_port[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_IEGR_PORTr_PORT_TYPEf_GET(r) (((r).iegr_port[0]) & 0x3)
#define BCM56504_A0_IEGR_PORTr_PORT_TYPEf_SET(r,f) (r).iegr_port[0]=(((r).iegr_port[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56504_A0_IEGR_PORTr_EN_EFILTERf_GET(r) ((((r).iegr_port[0]) >> 2) & 0x1)
#define BCM56504_A0_IEGR_PORTr_EN_EFILTERf_SET(r,f) (r).iegr_port[0]=(((r).iegr_port[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_IEGR_PORTr_PRESERVE_CPU_TAGf_GET(r) ((((r).iegr_port[0]) >> 3) & 0x1)
#define BCM56504_A0_IEGR_PORTr_PRESERVE_CPU_TAGf_SET(r,f) (r).iegr_port[0]=(((r).iegr_port[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_IEGR_PORTr_CFIf_GET(r) ((((r).iegr_port[0]) >> 4) & 0xf)
#define BCM56504_A0_IEGR_PORTr_CFIf_SET(r,f) (r).iegr_port[0]=(((r).iegr_port[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56504_A0_IEGR_PORTr_HIGIG_PACKETf_GET(r) (((r).iegr_port[0]) & 0x1)
#define BCM56504_A0_IEGR_PORTr_HIGIG_PACKETf_SET(r,f) (r).iegr_port[0]=(((r).iegr_port[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_IEGR_PORTr_NNI_PORTf_GET(r) ((((r).iegr_port[0]) >> 1) & 0x1)
#define BCM56504_A0_IEGR_PORTr_NNI_PORTf_SET(r,f) (r).iegr_port[0]=(((r).iegr_port[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access IEGR_PORT.
 *
 */
#define BCM56504_A0_READ_IEGR_PORTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_IEGR_PORTr,(r._iegr_port))
#define BCM56504_A0_WRITE_IEGR_PORTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_IEGR_PORTr,&(r._iegr_port))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IEGR_PORTr BCM56504_A0_IEGR_PORTr
#define IEGR_PORTr_SIZE BCM56504_A0_IEGR_PORTr_SIZE
typedef BCM56504_A0_IEGR_PORTr_t IEGR_PORTr_t;
#define IEGR_PORTr_CLR BCM56504_A0_IEGR_PORTr_CLR
#define IEGR_PORTr_SET BCM56504_A0_IEGR_PORTr_SET
#define IEGR_PORTr_GET BCM56504_A0_IEGR_PORTr_GET
#define IEGR_PORTr_PORT_TYPEf_GET BCM56504_A0_IEGR_PORTr_PORT_TYPEf_GET
#define IEGR_PORTr_PORT_TYPEf_SET BCM56504_A0_IEGR_PORTr_PORT_TYPEf_SET
#define IEGR_PORTr_EN_EFILTERf_GET BCM56504_A0_IEGR_PORTr_EN_EFILTERf_GET
#define IEGR_PORTr_EN_EFILTERf_SET BCM56504_A0_IEGR_PORTr_EN_EFILTERf_SET
#define IEGR_PORTr_PRESERVE_CPU_TAGf_GET BCM56504_A0_IEGR_PORTr_PRESERVE_CPU_TAGf_GET
#define IEGR_PORTr_PRESERVE_CPU_TAGf_SET BCM56504_A0_IEGR_PORTr_PRESERVE_CPU_TAGf_SET
#define IEGR_PORTr_CFIf_GET BCM56504_A0_IEGR_PORTr_CFIf_GET
#define IEGR_PORTr_CFIf_SET BCM56504_A0_IEGR_PORTr_CFIf_SET
#define IEGR_PORTr_HIGIG_PACKETf_GET BCM56504_A0_IEGR_PORTr_HIGIG_PACKETf_GET
#define IEGR_PORTr_HIGIG_PACKETf_SET BCM56504_A0_IEGR_PORTr_HIGIG_PACKETf_SET
#define IEGR_PORTr_NNI_PORTf_GET BCM56504_A0_IEGR_PORTr_NNI_PORTf_GET
#define IEGR_PORTr_NNI_PORTf_SET BCM56504_A0_IEGR_PORTr_NNI_PORTf_SET
#define READ_IEGR_PORTr BCM56504_A0_READ_IEGR_PORTr
#define WRITE_IEGR_PORTr BCM56504_A0_WRITE_IEGR_PORTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_IEGR_PORTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  IEGR_PORT_L3UC_MODS
 * BLOCKS:   EPIPE_HI
 * DESC:     Configuration Register for IPMC related modifications.


 * SIZE:     32
 * FIELDS:
 *     L3_UC_SA_DISABLE Disable the SA replacement for L3UC packets coming from a particular port. This register is indexed in EP based on the src_port_num.
 *     L3_UC_DA_DISABLE Disable the DA replacement for L3UC packets coming from a particular port. This register is indexed in EP based on the src_port_num.
 *     L3_UC_TTL_DISABLE Disable the TTL decrement for L3UC packets coming from a particular port. This register is indexed in EP based on the src_port_num.
 *     L3_UC_VLAN_DISABLE Disable the outer VID replacement for L3UC packets coming from a particular port. This register is indexed in EP based on the src_port_num.
 *
 ******************************************************************************/
#define BCM56504_A0_IEGR_PORT_L3UC_MODSr 0x06a00002

#define BCM56504_A0_IEGR_PORT_L3UC_MODSr_SIZE 4

/*
 * This structure should be used to declare and program IEGR_PORT_L3UC_MODS.
 *
 */
typedef union BCM56504_A0_IEGR_PORT_L3UC_MODSr_s {
	uint32_t v[1];
	uint32_t iegr_port_l3uc_mods[1];
	uint32_t _iegr_port_l3uc_mods;
} BCM56504_A0_IEGR_PORT_L3UC_MODSr_t;

#define BCM56504_A0_IEGR_PORT_L3UC_MODSr_CLR(r) (r).iegr_port_l3uc_mods[0] = 0
#define BCM56504_A0_IEGR_PORT_L3UC_MODSr_SET(r,d) (r).iegr_port_l3uc_mods[0] = d
#define BCM56504_A0_IEGR_PORT_L3UC_MODSr_GET(r) (r).iegr_port_l3uc_mods[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_IEGR_PORT_L3UC_MODSr_L3_UC_SA_DISABLEf_GET(r) (((r).iegr_port_l3uc_mods[0]) & 0x1)
#define BCM56504_A0_IEGR_PORT_L3UC_MODSr_L3_UC_SA_DISABLEf_SET(r,f) (r).iegr_port_l3uc_mods[0]=(((r).iegr_port_l3uc_mods[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_IEGR_PORT_L3UC_MODSr_L3_UC_DA_DISABLEf_GET(r) ((((r).iegr_port_l3uc_mods[0]) >> 1) & 0x1)
#define BCM56504_A0_IEGR_PORT_L3UC_MODSr_L3_UC_DA_DISABLEf_SET(r,f) (r).iegr_port_l3uc_mods[0]=(((r).iegr_port_l3uc_mods[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_IEGR_PORT_L3UC_MODSr_L3_UC_TTL_DISABLEf_GET(r) ((((r).iegr_port_l3uc_mods[0]) >> 2) & 0x1)
#define BCM56504_A0_IEGR_PORT_L3UC_MODSr_L3_UC_TTL_DISABLEf_SET(r,f) (r).iegr_port_l3uc_mods[0]=(((r).iegr_port_l3uc_mods[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_IEGR_PORT_L3UC_MODSr_L3_UC_VLAN_DISABLEf_GET(r) ((((r).iegr_port_l3uc_mods[0]) >> 3) & 0x1)
#define BCM56504_A0_IEGR_PORT_L3UC_MODSr_L3_UC_VLAN_DISABLEf_SET(r,f) (r).iegr_port_l3uc_mods[0]=(((r).iegr_port_l3uc_mods[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))

/*
 * These macros can be used to access IEGR_PORT_L3UC_MODS.
 *
 */
#define BCM56504_A0_READ_IEGR_PORT_L3UC_MODSr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_IEGR_PORT_L3UC_MODSr,(r._iegr_port_l3uc_mods))
#define BCM56504_A0_WRITE_IEGR_PORT_L3UC_MODSr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_IEGR_PORT_L3UC_MODSr,&(r._iegr_port_l3uc_mods))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IEGR_PORT_L3UC_MODSr BCM56504_A0_IEGR_PORT_L3UC_MODSr
#define IEGR_PORT_L3UC_MODSr_SIZE BCM56504_A0_IEGR_PORT_L3UC_MODSr_SIZE
typedef BCM56504_A0_IEGR_PORT_L3UC_MODSr_t IEGR_PORT_L3UC_MODSr_t;
#define IEGR_PORT_L3UC_MODSr_CLR BCM56504_A0_IEGR_PORT_L3UC_MODSr_CLR
#define IEGR_PORT_L3UC_MODSr_SET BCM56504_A0_IEGR_PORT_L3UC_MODSr_SET
#define IEGR_PORT_L3UC_MODSr_GET BCM56504_A0_IEGR_PORT_L3UC_MODSr_GET
#define IEGR_PORT_L3UC_MODSr_L3_UC_SA_DISABLEf_GET BCM56504_A0_IEGR_PORT_L3UC_MODSr_L3_UC_SA_DISABLEf_GET
#define IEGR_PORT_L3UC_MODSr_L3_UC_SA_DISABLEf_SET BCM56504_A0_IEGR_PORT_L3UC_MODSr_L3_UC_SA_DISABLEf_SET
#define IEGR_PORT_L3UC_MODSr_L3_UC_DA_DISABLEf_GET BCM56504_A0_IEGR_PORT_L3UC_MODSr_L3_UC_DA_DISABLEf_GET
#define IEGR_PORT_L3UC_MODSr_L3_UC_DA_DISABLEf_SET BCM56504_A0_IEGR_PORT_L3UC_MODSr_L3_UC_DA_DISABLEf_SET
#define IEGR_PORT_L3UC_MODSr_L3_UC_TTL_DISABLEf_GET BCM56504_A0_IEGR_PORT_L3UC_MODSr_L3_UC_TTL_DISABLEf_GET
#define IEGR_PORT_L3UC_MODSr_L3_UC_TTL_DISABLEf_SET BCM56504_A0_IEGR_PORT_L3UC_MODSr_L3_UC_TTL_DISABLEf_SET
#define IEGR_PORT_L3UC_MODSr_L3_UC_VLAN_DISABLEf_GET BCM56504_A0_IEGR_PORT_L3UC_MODSr_L3_UC_VLAN_DISABLEf_GET
#define IEGR_PORT_L3UC_MODSr_L3_UC_VLAN_DISABLEf_SET BCM56504_A0_IEGR_PORT_L3UC_MODSr_L3_UC_VLAN_DISABLEf_SET
#define READ_IEGR_PORT_L3UC_MODSr BCM56504_A0_READ_IEGR_PORT_L3UC_MODSr
#define WRITE_IEGR_PORT_L3UC_MODSr BCM56504_A0_WRITE_IEGR_PORT_L3UC_MODSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_IEGR_PORT_L3UC_MODSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  IEMIRROR_CONTROL
 * BLOCKS:   IPIPE_HI
 * DESC:     Egress mirror bitmap register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           Egress mirror bitmap
 *
 ******************************************************************************/
#define BCM56504_A0_IEMIRROR_CONTROLr 0x0e800105

#define BCM56504_A0_IEMIRROR_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program IEMIRROR_CONTROL.
 *
 */
typedef union BCM56504_A0_IEMIRROR_CONTROLr_s {
	uint32_t v[1];
	uint32_t iemirror_control[1];
	uint32_t _iemirror_control;
} BCM56504_A0_IEMIRROR_CONTROLr_t;

#define BCM56504_A0_IEMIRROR_CONTROLr_CLR(r) (r).iemirror_control[0] = 0
#define BCM56504_A0_IEMIRROR_CONTROLr_SET(r,d) (r).iemirror_control[0] = d
#define BCM56504_A0_IEMIRROR_CONTROLr_GET(r) (r).iemirror_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_IEMIRROR_CONTROLr_BITMAPf_GET(r) (((r).iemirror_control[0]) & 0x1fffffff)
#define BCM56504_A0_IEMIRROR_CONTROLr_BITMAPf_SET(r,f) (r).iemirror_control[0]=(((r).iemirror_control[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))

/*
 * These macros can be used to access IEMIRROR_CONTROL.
 *
 */
#define BCM56504_A0_READ_IEMIRROR_CONTROLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_IEMIRROR_CONTROLr,(r._iemirror_control))
#define BCM56504_A0_WRITE_IEMIRROR_CONTROLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_IEMIRROR_CONTROLr,&(r._iemirror_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IEMIRROR_CONTROLr BCM56504_A0_IEMIRROR_CONTROLr
#define IEMIRROR_CONTROLr_SIZE BCM56504_A0_IEMIRROR_CONTROLr_SIZE
typedef BCM56504_A0_IEMIRROR_CONTROLr_t IEMIRROR_CONTROLr_t;
#define IEMIRROR_CONTROLr_CLR BCM56504_A0_IEMIRROR_CONTROLr_CLR
#define IEMIRROR_CONTROLr_SET BCM56504_A0_IEMIRROR_CONTROLr_SET
#define IEMIRROR_CONTROLr_GET BCM56504_A0_IEMIRROR_CONTROLr_GET
#define IEMIRROR_CONTROLr_BITMAPf_GET BCM56504_A0_IEMIRROR_CONTROLr_BITMAPf_GET
#define IEMIRROR_CONTROLr_BITMAPf_SET BCM56504_A0_IEMIRROR_CONTROLr_BITMAPf_SET
#define READ_IEMIRROR_CONTROLr BCM56504_A0_READ_IEMIRROR_CONTROLr
#define WRITE_IEMIRROR_CONTROLr BCM56504_A0_WRITE_IEMIRROR_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_IEMIRROR_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  IMIRROR_CONTROL
 * BLOCKS:   IPIPE_HI
 * DESC:     Mirror control register
 * SIZE:     32
 * FIELDS:
 *     M_ENABLE         Enable mirroring
 *     IM_MTP_INDEX     Ingress MTP index
 *     EM_MTP_INDEX     Egress MTP index
 *     NON_UC_EM_MTP_INDEX Non-unicast egress MTP index
 *
 ******************************************************************************/
#define BCM56504_A0_IMIRROR_CONTROLr 0x0e800104

#define BCM56504_A0_IMIRROR_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program IMIRROR_CONTROL.
 *
 */
typedef union BCM56504_A0_IMIRROR_CONTROLr_s {
	uint32_t v[1];
	uint32_t imirror_control[1];
	uint32_t _imirror_control;
} BCM56504_A0_IMIRROR_CONTROLr_t;

#define BCM56504_A0_IMIRROR_CONTROLr_CLR(r) (r).imirror_control[0] = 0
#define BCM56504_A0_IMIRROR_CONTROLr_SET(r,d) (r).imirror_control[0] = d
#define BCM56504_A0_IMIRROR_CONTROLr_GET(r) (r).imirror_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_IMIRROR_CONTROLr_M_ENABLEf_GET(r) (((r).imirror_control[0]) & 0x1)
#define BCM56504_A0_IMIRROR_CONTROLr_M_ENABLEf_SET(r,f) (r).imirror_control[0]=(((r).imirror_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_IMIRROR_CONTROLr_IM_MTP_INDEXf_GET(r) ((((r).imirror_control[0]) >> 1) & 0x3)
#define BCM56504_A0_IMIRROR_CONTROLr_IM_MTP_INDEXf_SET(r,f) (r).imirror_control[0]=(((r).imirror_control[0] & ~((uint32_t)0x3 << 1)) | ((((uint32_t)f) & 0x3) << 1))
#define BCM56504_A0_IMIRROR_CONTROLr_EM_MTP_INDEXf_GET(r) ((((r).imirror_control[0]) >> 3) & 0x3)
#define BCM56504_A0_IMIRROR_CONTROLr_EM_MTP_INDEXf_SET(r,f) (r).imirror_control[0]=(((r).imirror_control[0] & ~((uint32_t)0x3 << 3)) | ((((uint32_t)f) & 0x3) << 3))
#define BCM56504_A0_IMIRROR_CONTROLr_NON_UC_EM_MTP_INDEXf_GET(r) ((((r).imirror_control[0]) >> 5) & 0x3)
#define BCM56504_A0_IMIRROR_CONTROLr_NON_UC_EM_MTP_INDEXf_SET(r,f) (r).imirror_control[0]=(((r).imirror_control[0] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5))

/*
 * These macros can be used to access IMIRROR_CONTROL.
 *
 */
#define BCM56504_A0_READ_IMIRROR_CONTROLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_IMIRROR_CONTROLr,(r._imirror_control))
#define BCM56504_A0_WRITE_IMIRROR_CONTROLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_IMIRROR_CONTROLr,&(r._imirror_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IMIRROR_CONTROLr BCM56504_A0_IMIRROR_CONTROLr
#define IMIRROR_CONTROLr_SIZE BCM56504_A0_IMIRROR_CONTROLr_SIZE
typedef BCM56504_A0_IMIRROR_CONTROLr_t IMIRROR_CONTROLr_t;
#define IMIRROR_CONTROLr_CLR BCM56504_A0_IMIRROR_CONTROLr_CLR
#define IMIRROR_CONTROLr_SET BCM56504_A0_IMIRROR_CONTROLr_SET
#define IMIRROR_CONTROLr_GET BCM56504_A0_IMIRROR_CONTROLr_GET
#define IMIRROR_CONTROLr_M_ENABLEf_GET BCM56504_A0_IMIRROR_CONTROLr_M_ENABLEf_GET
#define IMIRROR_CONTROLr_M_ENABLEf_SET BCM56504_A0_IMIRROR_CONTROLr_M_ENABLEf_SET
#define IMIRROR_CONTROLr_IM_MTP_INDEXf_GET BCM56504_A0_IMIRROR_CONTROLr_IM_MTP_INDEXf_GET
#define IMIRROR_CONTROLr_IM_MTP_INDEXf_SET BCM56504_A0_IMIRROR_CONTROLr_IM_MTP_INDEXf_SET
#define IMIRROR_CONTROLr_EM_MTP_INDEXf_GET BCM56504_A0_IMIRROR_CONTROLr_EM_MTP_INDEXf_GET
#define IMIRROR_CONTROLr_EM_MTP_INDEXf_SET BCM56504_A0_IMIRROR_CONTROLr_EM_MTP_INDEXf_SET
#define IMIRROR_CONTROLr_NON_UC_EM_MTP_INDEXf_GET BCM56504_A0_IMIRROR_CONTROLr_NON_UC_EM_MTP_INDEXf_GET
#define IMIRROR_CONTROLr_NON_UC_EM_MTP_INDEXf_SET BCM56504_A0_IMIRROR_CONTROLr_NON_UC_EM_MTP_INDEXf_SET
#define READ_IMIRROR_CONTROLr BCM56504_A0_READ_IMIRROR_CONTROLr
#define WRITE_IMIRROR_CONTROLr BCM56504_A0_WRITE_IMIRROR_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_IMIRROR_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  IMRP4
 * BLOCKS:   IPIPE
 * DESC:     Receive IPv4 L3 routed multicast packets
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_IMRP4r 0x0e700003

#define BCM56504_A0_IMRP4r_SIZE 4

/*
 * This structure should be used to declare and program IMRP4.
 *
 */
typedef union BCM56504_A0_IMRP4r_s {
	uint32_t v[1];
	uint32_t imrp4[1];
	uint32_t _imrp4;
} BCM56504_A0_IMRP4r_t;

#define BCM56504_A0_IMRP4r_CLR(r) (r).imrp4[0] = 0
#define BCM56504_A0_IMRP4r_SET(r,d) (r).imrp4[0] = d
#define BCM56504_A0_IMRP4r_GET(r) (r).imrp4[0]


/*
 * These macros can be used to access IMRP4.
 *
 */
#define BCM56504_A0_READ_IMRP4r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_IMRP4r,(r._imrp4))
#define BCM56504_A0_WRITE_IMRP4r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_IMRP4r,&(r._imrp4))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IMRP4r BCM56504_A0_IMRP4r
#define IMRP4r_SIZE BCM56504_A0_IMRP4r_SIZE
typedef BCM56504_A0_IMRP4r_t IMRP4r_t;
#define IMRP4r_CLR BCM56504_A0_IMRP4r_CLR
#define IMRP4r_SET BCM56504_A0_IMRP4r_SET
#define IMRP4r_GET BCM56504_A0_IMRP4r_GET
#define READ_IMRP4r BCM56504_A0_READ_IMRP4r
#define WRITE_IMRP4r BCM56504_A0_WRITE_IMRP4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_IMRP4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  IMRP6
 * BLOCKS:   IPIPE
 * DESC:     Receive IPv6 L3 routed multicast packets
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_IMRP6r 0x0e700007

#define BCM56504_A0_IMRP6r_SIZE 4

/*
 * This structure should be used to declare and program IMRP6.
 *
 */
typedef union BCM56504_A0_IMRP6r_s {
	uint32_t v[1];
	uint32_t imrp6[1];
	uint32_t _imrp6;
} BCM56504_A0_IMRP6r_t;

#define BCM56504_A0_IMRP6r_CLR(r) (r).imrp6[0] = 0
#define BCM56504_A0_IMRP6r_SET(r,d) (r).imrp6[0] = d
#define BCM56504_A0_IMRP6r_GET(r) (r).imrp6[0]


/*
 * These macros can be used to access IMRP6.
 *
 */
#define BCM56504_A0_READ_IMRP6r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_IMRP6r,(r._imrp6))
#define BCM56504_A0_WRITE_IMRP6r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_IMRP6r,&(r._imrp6))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IMRP6r BCM56504_A0_IMRP6r
#define IMRP6r_SIZE BCM56504_A0_IMRP6r_SIZE
typedef BCM56504_A0_IMRP6r_t IMRP6r_t;
#define IMRP6r_CLR BCM56504_A0_IMRP6r_CLR
#define IMRP6r_SET BCM56504_A0_IMRP6r_SET
#define IMRP6r_GET BCM56504_A0_IMRP6r_GET
#define READ_IMRP6r BCM56504_A0_READ_IMRP6r
#define WRITE_IMRP6r BCM56504_A0_WRITE_IMRP6r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_IMRP6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  IM_MTP_INDEX
 * BLOCKS:   IPIPE
 * DESC:     Ingress Mirror to Port Table
 * SIZE:     12
 * FIELDS:
 *     PORT_TGID        Mirror to port port/TGID
 *     MODULE_ID        Mirror to port module ID
 *
 ******************************************************************************/
#define BCM56504_A0_IM_MTP_INDEXm 0x0e780000

#define BCM56504_A0_IM_MTP_INDEXm_MIN 0
#define BCM56504_A0_IM_MTP_INDEXm_MAX 3
#define BCM56504_A0_IM_MTP_INDEXm_CMAX(u) 3
#define BCM56504_A0_IM_MTP_INDEXm_SIZE 2

/*
 * This structure should be used to declare and program IM_MTP_INDEX.
 *
 */
typedef union BCM56504_A0_IM_MTP_INDEXm_s {
	uint32_t v[1];
	uint32_t im_mtp_index[1];
	uint32_t _im_mtp_index;
} BCM56504_A0_IM_MTP_INDEXm_t;

#define BCM56504_A0_IM_MTP_INDEXm_CLR(r) (r).im_mtp_index[0] = 0
#define BCM56504_A0_IM_MTP_INDEXm_SET(r,d) (r).im_mtp_index[0] = d
#define BCM56504_A0_IM_MTP_INDEXm_GET(r) (r).im_mtp_index[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_IM_MTP_INDEXm_PORT_TGIDf_GET(r) (((r).im_mtp_index[0]) & 0x3f)
#define BCM56504_A0_IM_MTP_INDEXm_PORT_TGIDf_SET(r,f) (r).im_mtp_index[0]=(((r).im_mtp_index[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM56504_A0_IM_MTP_INDEXm_MODULE_IDf_GET(r) ((((r).im_mtp_index[0]) >> 6) & 0x3f)
#define BCM56504_A0_IM_MTP_INDEXm_MODULE_IDf_SET(r,f) (r).im_mtp_index[0]=(((r).im_mtp_index[0] & ~((uint32_t)0x3f << 6)) | ((((uint32_t)f) & 0x3f) << 6))

/*
 * These macros can be used to access IM_MTP_INDEX.
 *
 */
#define BCM56504_A0_READ_IM_MTP_INDEXm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_IM_MTP_INDEXm,i,(m._im_mtp_index),1)
#define BCM56504_A0_WRITE_IM_MTP_INDEXm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_IM_MTP_INDEXm,i,&(m._im_mtp_index),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IM_MTP_INDEXm BCM56504_A0_IM_MTP_INDEXm
#define IM_MTP_INDEXm_MIN BCM56504_A0_IM_MTP_INDEXm_MIN
#define IM_MTP_INDEXm_MAX BCM56504_A0_IM_MTP_INDEXm_MAX
#define IM_MTP_INDEXm_CMAX(u) BCM56504_A0_IM_MTP_INDEXm_CMAX(u)
#define IM_MTP_INDEXm_SIZE BCM56504_A0_IM_MTP_INDEXm_SIZE
typedef BCM56504_A0_IM_MTP_INDEXm_t IM_MTP_INDEXm_t;
#define IM_MTP_INDEXm_CLR BCM56504_A0_IM_MTP_INDEXm_CLR
#define IM_MTP_INDEXm_SET BCM56504_A0_IM_MTP_INDEXm_SET
#define IM_MTP_INDEXm_GET BCM56504_A0_IM_MTP_INDEXm_GET
#define IM_MTP_INDEXm_PORT_TGIDf_GET BCM56504_A0_IM_MTP_INDEXm_PORT_TGIDf_GET
#define IM_MTP_INDEXm_PORT_TGIDf_SET BCM56504_A0_IM_MTP_INDEXm_PORT_TGIDf_SET
#define IM_MTP_INDEXm_MODULE_IDf_GET BCM56504_A0_IM_MTP_INDEXm_MODULE_IDf_GET
#define IM_MTP_INDEXm_MODULE_IDf_SET BCM56504_A0_IM_MTP_INDEXm_MODULE_IDf_SET
#define READ_IM_MTP_INDEXm BCM56504_A0_READ_IM_MTP_INDEXm
#define WRITE_IM_MTP_INDEXm BCM56504_A0_WRITE_IM_MTP_INDEXm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_IM_MTP_INDEXm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  ING_CONFIG
 * BLOCKS:   IPIPE
 * DESC:     Switch configuration register
 * SIZE:     32
 * FIELDS:
 *     DT_MODE          Enables double tagging mode
 *     TRUNKS128        Indicates if 128 trunk groups are supported
 *     L2DST_HIT_ENABLE If set, L2 table will update its HIT bit on dest lookup
 *     L3SRC_HIT_ENABLE If set, L3 table will update its HIT bit on src lookup. Only apply to Unicast packets.
 *     DRACO1_5_MIRROR  Enables Draco 1.5 style mirroring
 *     CFI_AS_CNG       For tagged packets, use VLAN's CFI field to map to an internal CNG value (for double tagging)
 *     SNAP_OTHER_DECODE_ENABLE Decode SNAP packets with non-zero OUI for protocol-based VLAN
 *     ENABLE_FP_FOR_MIRROR_PKTS Enable FP for mirror packets
 *     RESERVED0        Reserved bits
 *
 ******************************************************************************/
#define BCM56504_A0_ING_CONFIGr 0x01780000

#define BCM56504_A0_ING_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program ING_CONFIG.
 *
 */
typedef union BCM56504_A0_ING_CONFIGr_s {
	uint32_t v[1];
	uint32_t ing_config[1];
	uint32_t _ing_config;
} BCM56504_A0_ING_CONFIGr_t;

#define BCM56504_A0_ING_CONFIGr_CLR(r) (r).ing_config[0] = 0
#define BCM56504_A0_ING_CONFIGr_SET(r,d) (r).ing_config[0] = d
#define BCM56504_A0_ING_CONFIGr_GET(r) (r).ing_config[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_ING_CONFIGr_DT_MODEf_GET(r) (((r).ing_config[0]) & 0x1)
#define BCM56504_A0_ING_CONFIGr_DT_MODEf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_ING_CONFIGr_TRUNKS128f_GET(r) ((((r).ing_config[0]) >> 1) & 0x1)
#define BCM56504_A0_ING_CONFIGr_TRUNKS128f_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_ING_CONFIGr_L2DST_HIT_ENABLEf_GET(r) ((((r).ing_config[0]) >> 2) & 0x1)
#define BCM56504_A0_ING_CONFIGr_L2DST_HIT_ENABLEf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_ING_CONFIGr_L3SRC_HIT_ENABLEf_GET(r) ((((r).ing_config[0]) >> 3) & 0x1)
#define BCM56504_A0_ING_CONFIGr_L3SRC_HIT_ENABLEf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_ING_CONFIGr_DRACO1_5_MIRRORf_GET(r) ((((r).ing_config[0]) >> 4) & 0x1)
#define BCM56504_A0_ING_CONFIGr_DRACO1_5_MIRRORf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56504_A0_ING_CONFIGr_CFI_AS_CNGf_GET(r) ((((r).ing_config[0]) >> 5) & 0x1)
#define BCM56504_A0_ING_CONFIGr_CFI_AS_CNGf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56504_A0_ING_CONFIGr_SNAP_OTHER_DECODE_ENABLEf_GET(r) ((((r).ing_config[0]) >> 6) & 0x1)
#define BCM56504_A0_ING_CONFIGr_SNAP_OTHER_DECODE_ENABLEf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56504_A0_ING_CONFIGr_ENABLE_FP_FOR_MIRROR_PKTSf_GET(r) ((((r).ing_config[0]) >> 7) & 0x1)
#define BCM56504_A0_ING_CONFIGr_ENABLE_FP_FOR_MIRROR_PKTSf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56504_A0_ING_CONFIGr_RESERVED0f_GET(r) ((((r).ing_config[0]) >> 8) & 0x3)
#define BCM56504_A0_ING_CONFIGr_RESERVED0f_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))

/*
 * These macros can be used to access ING_CONFIG.
 *
 */
#define BCM56504_A0_READ_ING_CONFIGr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_ING_CONFIGr,(r._ing_config))
#define BCM56504_A0_WRITE_ING_CONFIGr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_ING_CONFIGr,&(r._ing_config))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ING_CONFIGr BCM56504_A0_ING_CONFIGr
#define ING_CONFIGr_SIZE BCM56504_A0_ING_CONFIGr_SIZE
typedef BCM56504_A0_ING_CONFIGr_t ING_CONFIGr_t;
#define ING_CONFIGr_CLR BCM56504_A0_ING_CONFIGr_CLR
#define ING_CONFIGr_SET BCM56504_A0_ING_CONFIGr_SET
#define ING_CONFIGr_GET BCM56504_A0_ING_CONFIGr_GET
#define ING_CONFIGr_DT_MODEf_GET BCM56504_A0_ING_CONFIGr_DT_MODEf_GET
#define ING_CONFIGr_DT_MODEf_SET BCM56504_A0_ING_CONFIGr_DT_MODEf_SET
#define ING_CONFIGr_TRUNKS128f_GET BCM56504_A0_ING_CONFIGr_TRUNKS128f_GET
#define ING_CONFIGr_TRUNKS128f_SET BCM56504_A0_ING_CONFIGr_TRUNKS128f_SET
#define ING_CONFIGr_L2DST_HIT_ENABLEf_GET BCM56504_A0_ING_CONFIGr_L2DST_HIT_ENABLEf_GET
#define ING_CONFIGr_L2DST_HIT_ENABLEf_SET BCM56504_A0_ING_CONFIGr_L2DST_HIT_ENABLEf_SET
#define ING_CONFIGr_L3SRC_HIT_ENABLEf_GET BCM56504_A0_ING_CONFIGr_L3SRC_HIT_ENABLEf_GET
#define ING_CONFIGr_L3SRC_HIT_ENABLEf_SET BCM56504_A0_ING_CONFIGr_L3SRC_HIT_ENABLEf_SET
#define ING_CONFIGr_DRACO1_5_MIRRORf_GET BCM56504_A0_ING_CONFIGr_DRACO1_5_MIRRORf_GET
#define ING_CONFIGr_DRACO1_5_MIRRORf_SET BCM56504_A0_ING_CONFIGr_DRACO1_5_MIRRORf_SET
#define ING_CONFIGr_CFI_AS_CNGf_GET BCM56504_A0_ING_CONFIGr_CFI_AS_CNGf_GET
#define ING_CONFIGr_CFI_AS_CNGf_SET BCM56504_A0_ING_CONFIGr_CFI_AS_CNGf_SET
#define ING_CONFIGr_SNAP_OTHER_DECODE_ENABLEf_GET BCM56504_A0_ING_CONFIGr_SNAP_OTHER_DECODE_ENABLEf_GET
#define ING_CONFIGr_SNAP_OTHER_DECODE_ENABLEf_SET BCM56504_A0_ING_CONFIGr_SNAP_OTHER_DECODE_ENABLEf_SET
#define ING_CONFIGr_ENABLE_FP_FOR_MIRROR_PKTSf_GET BCM56504_A0_ING_CONFIGr_ENABLE_FP_FOR_MIRROR_PKTSf_GET
#define ING_CONFIGr_ENABLE_FP_FOR_MIRROR_PKTSf_SET BCM56504_A0_ING_CONFIGr_ENABLE_FP_FOR_MIRROR_PKTSf_SET
#define ING_CONFIGr_RESERVED0f_GET BCM56504_A0_ING_CONFIGr_RESERVED0f_GET
#define ING_CONFIGr_RESERVED0f_SET BCM56504_A0_ING_CONFIGr_RESERVED0f_SET
#define READ_ING_CONFIGr BCM56504_A0_READ_ING_CONFIGr
#define WRITE_ING_CONFIGr BCM56504_A0_WRITE_ING_CONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_ING_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  ING_HW_RESET_CONTROL_1
 * BLOCKS:   IPIPE
 * DESC:     Ingress Pipeline memory hardware initialization register #1
 * SIZE:     32
 * FIELDS:
 *     STAGE_NUMBER     IP stage for the memory table
 *     OFFSET           20-bit starting offset of table for memory
 *
 ******************************************************************************/
#define BCM56504_A0_ING_HW_RESET_CONTROL_1r 0x00780001

#define BCM56504_A0_ING_HW_RESET_CONTROL_1r_SIZE 4

/*
 * This structure should be used to declare and program ING_HW_RESET_CONTROL_1.
 *
 */
typedef union BCM56504_A0_ING_HW_RESET_CONTROL_1r_s {
	uint32_t v[1];
	uint32_t ing_hw_reset_control_1[1];
	uint32_t _ing_hw_reset_control_1;
} BCM56504_A0_ING_HW_RESET_CONTROL_1r_t;

#define BCM56504_A0_ING_HW_RESET_CONTROL_1r_CLR(r) (r).ing_hw_reset_control_1[0] = 0
#define BCM56504_A0_ING_HW_RESET_CONTROL_1r_SET(r,d) (r).ing_hw_reset_control_1[0] = d
#define BCM56504_A0_ING_HW_RESET_CONTROL_1r_GET(r) (r).ing_hw_reset_control_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_ING_HW_RESET_CONTROL_1r_STAGE_NUMBERf_GET(r) (((r).ing_hw_reset_control_1[0]) & 0x3f)
#define BCM56504_A0_ING_HW_RESET_CONTROL_1r_STAGE_NUMBERf_SET(r,f) (r).ing_hw_reset_control_1[0]=(((r).ing_hw_reset_control_1[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM56504_A0_ING_HW_RESET_CONTROL_1r_OFFSETf_GET(r) ((((r).ing_hw_reset_control_1[0]) >> 6) & 0xfffff)
#define BCM56504_A0_ING_HW_RESET_CONTROL_1r_OFFSETf_SET(r,f) (r).ing_hw_reset_control_1[0]=(((r).ing_hw_reset_control_1[0] & ~((uint32_t)0xfffff << 6)) | ((((uint32_t)f) & 0xfffff) << 6))

/*
 * These macros can be used to access ING_HW_RESET_CONTROL_1.
 *
 */
#define BCM56504_A0_READ_ING_HW_RESET_CONTROL_1r(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_ING_HW_RESET_CONTROL_1r,(r._ing_hw_reset_control_1))
#define BCM56504_A0_WRITE_ING_HW_RESET_CONTROL_1r(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_ING_HW_RESET_CONTROL_1r,&(r._ing_hw_reset_control_1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ING_HW_RESET_CONTROL_1r BCM56504_A0_ING_HW_RESET_CONTROL_1r
#define ING_HW_RESET_CONTROL_1r_SIZE BCM56504_A0_ING_HW_RESET_CONTROL_1r_SIZE
typedef BCM56504_A0_ING_HW_RESET_CONTROL_1r_t ING_HW_RESET_CONTROL_1r_t;
#define ING_HW_RESET_CONTROL_1r_CLR BCM56504_A0_ING_HW_RESET_CONTROL_1r_CLR
#define ING_HW_RESET_CONTROL_1r_SET BCM56504_A0_ING_HW_RESET_CONTROL_1r_SET
#define ING_HW_RESET_CONTROL_1r_GET BCM56504_A0_ING_HW_RESET_CONTROL_1r_GET
#define ING_HW_RESET_CONTROL_1r_STAGE_NUMBERf_GET BCM56504_A0_ING_HW_RESET_CONTROL_1r_STAGE_NUMBERf_GET
#define ING_HW_RESET_CONTROL_1r_STAGE_NUMBERf_SET BCM56504_A0_ING_HW_RESET_CONTROL_1r_STAGE_NUMBERf_SET
#define ING_HW_RESET_CONTROL_1r_OFFSETf_GET BCM56504_A0_ING_HW_RESET_CONTROL_1r_OFFSETf_GET
#define ING_HW_RESET_CONTROL_1r_OFFSETf_SET BCM56504_A0_ING_HW_RESET_CONTROL_1r_OFFSETf_SET
#define READ_ING_HW_RESET_CONTROL_1r BCM56504_A0_READ_ING_HW_RESET_CONTROL_1r
#define WRITE_ING_HW_RESET_CONTROL_1r BCM56504_A0_WRITE_ING_HW_RESET_CONTROL_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_ING_HW_RESET_CONTROL_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  ING_HW_RESET_CONTROL_2
 * BLOCKS:   IPIPE
 * DESC:     Ingress Pipeline memory hardware initialization register #2
 * SIZE:     32
 * FIELDS:
 *     COUNT            Number of entries of memory to initialize
 *     RESET_ALL        Indicates all memories in all stages should be initialized (independent of stage or table number)
 *     VALID            Set by software to trigger memory initialization
 *     DONE             Set by arbiter to indicate memory table writes have completed
 *
 ******************************************************************************/
#define BCM56504_A0_ING_HW_RESET_CONTROL_2r 0x00780002

#define BCM56504_A0_ING_HW_RESET_CONTROL_2r_SIZE 4

/*
 * This structure should be used to declare and program ING_HW_RESET_CONTROL_2.
 *
 */
typedef union BCM56504_A0_ING_HW_RESET_CONTROL_2r_s {
	uint32_t v[1];
	uint32_t ing_hw_reset_control_2[1];
	uint32_t _ing_hw_reset_control_2;
} BCM56504_A0_ING_HW_RESET_CONTROL_2r_t;

#define BCM56504_A0_ING_HW_RESET_CONTROL_2r_CLR(r) (r).ing_hw_reset_control_2[0] = 0
#define BCM56504_A0_ING_HW_RESET_CONTROL_2r_SET(r,d) (r).ing_hw_reset_control_2[0] = d
#define BCM56504_A0_ING_HW_RESET_CONTROL_2r_GET(r) (r).ing_hw_reset_control_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_ING_HW_RESET_CONTROL_2r_COUNTf_GET(r) (((r).ing_hw_reset_control_2[0]) & 0xffff)
#define BCM56504_A0_ING_HW_RESET_CONTROL_2r_COUNTf_SET(r,f) (r).ing_hw_reset_control_2[0]=(((r).ing_hw_reset_control_2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56504_A0_ING_HW_RESET_CONTROL_2r_RESET_ALLf_GET(r) ((((r).ing_hw_reset_control_2[0]) >> 16) & 0x1)
#define BCM56504_A0_ING_HW_RESET_CONTROL_2r_RESET_ALLf_SET(r,f) (r).ing_hw_reset_control_2[0]=(((r).ing_hw_reset_control_2[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56504_A0_ING_HW_RESET_CONTROL_2r_VALIDf_GET(r) ((((r).ing_hw_reset_control_2[0]) >> 17) & 0x1)
#define BCM56504_A0_ING_HW_RESET_CONTROL_2r_VALIDf_SET(r,f) (r).ing_hw_reset_control_2[0]=(((r).ing_hw_reset_control_2[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56504_A0_ING_HW_RESET_CONTROL_2r_DONEf_GET(r) ((((r).ing_hw_reset_control_2[0]) >> 18) & 0x1)
#define BCM56504_A0_ING_HW_RESET_CONTROL_2r_DONEf_SET(r,f) (r).ing_hw_reset_control_2[0]=(((r).ing_hw_reset_control_2[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))

/*
 * These macros can be used to access ING_HW_RESET_CONTROL_2.
 *
 */
#define BCM56504_A0_READ_ING_HW_RESET_CONTROL_2r(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_ING_HW_RESET_CONTROL_2r,(r._ing_hw_reset_control_2))
#define BCM56504_A0_WRITE_ING_HW_RESET_CONTROL_2r(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_ING_HW_RESET_CONTROL_2r,&(r._ing_hw_reset_control_2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ING_HW_RESET_CONTROL_2r BCM56504_A0_ING_HW_RESET_CONTROL_2r
#define ING_HW_RESET_CONTROL_2r_SIZE BCM56504_A0_ING_HW_RESET_CONTROL_2r_SIZE
typedef BCM56504_A0_ING_HW_RESET_CONTROL_2r_t ING_HW_RESET_CONTROL_2r_t;
#define ING_HW_RESET_CONTROL_2r_CLR BCM56504_A0_ING_HW_RESET_CONTROL_2r_CLR
#define ING_HW_RESET_CONTROL_2r_SET BCM56504_A0_ING_HW_RESET_CONTROL_2r_SET
#define ING_HW_RESET_CONTROL_2r_GET BCM56504_A0_ING_HW_RESET_CONTROL_2r_GET
#define ING_HW_RESET_CONTROL_2r_COUNTf_GET BCM56504_A0_ING_HW_RESET_CONTROL_2r_COUNTf_GET
#define ING_HW_RESET_CONTROL_2r_COUNTf_SET BCM56504_A0_ING_HW_RESET_CONTROL_2r_COUNTf_SET
#define ING_HW_RESET_CONTROL_2r_RESET_ALLf_GET BCM56504_A0_ING_HW_RESET_CONTROL_2r_RESET_ALLf_GET
#define ING_HW_RESET_CONTROL_2r_RESET_ALLf_SET BCM56504_A0_ING_HW_RESET_CONTROL_2r_RESET_ALLf_SET
#define ING_HW_RESET_CONTROL_2r_VALIDf_GET BCM56504_A0_ING_HW_RESET_CONTROL_2r_VALIDf_GET
#define ING_HW_RESET_CONTROL_2r_VALIDf_SET BCM56504_A0_ING_HW_RESET_CONTROL_2r_VALIDf_SET
#define ING_HW_RESET_CONTROL_2r_DONEf_GET BCM56504_A0_ING_HW_RESET_CONTROL_2r_DONEf_GET
#define ING_HW_RESET_CONTROL_2r_DONEf_SET BCM56504_A0_ING_HW_RESET_CONTROL_2r_DONEf_SET
#define READ_ING_HW_RESET_CONTROL_2r BCM56504_A0_READ_ING_HW_RESET_CONTROL_2r
#define WRITE_ING_HW_RESET_CONTROL_2r BCM56504_A0_WRITE_ING_HW_RESET_CONTROL_2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_ING_HW_RESET_CONTROL_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  ING_IPMC_PTR_CTRL
 * BLOCKS:   IPIPE
 * DESC:     IPMC Index Control Register
 * SIZE:     32
 * FIELDS:
 *     LOWER_LIMIT      IPMC Index Low Marker.
 *     UPPER_LIMIT      IPMC Index High Marker
 *     ENABLE           IPMC Index Increment Mode Enable bit is controlling IPMC index increment featurefor all ipmc replicated packet transmit to Higi port. IPMC index need to bewithin the reange defined by IPMCIdxHighMarker and IPMCIdxLowMarker. New IPMCIndex send will be the original IPMC Index added with replicated packet number.Ex. First packet, New IPMC Index = Original IPMC Index + 1;    Second packet, New IPMC Index = Original IPMC Index + 2;    ....    n-th packet, New IPMC Index = Original IPMC Index + n;1: IPMC Index Increment Mode En.0: IPMC Index Increment Mode Disable.
 *
 ******************************************************************************/
#define BCM56504_A0_ING_IPMC_PTR_CTRLr 0x0b780009

#define BCM56504_A0_ING_IPMC_PTR_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program ING_IPMC_PTR_CTRL.
 *
 */
typedef union BCM56504_A0_ING_IPMC_PTR_CTRLr_s {
	uint32_t v[1];
	uint32_t ing_ipmc_ptr_ctrl[1];
	uint32_t _ing_ipmc_ptr_ctrl;
} BCM56504_A0_ING_IPMC_PTR_CTRLr_t;

#define BCM56504_A0_ING_IPMC_PTR_CTRLr_CLR(r) (r).ing_ipmc_ptr_ctrl[0] = 0
#define BCM56504_A0_ING_IPMC_PTR_CTRLr_SET(r,d) (r).ing_ipmc_ptr_ctrl[0] = d
#define BCM56504_A0_ING_IPMC_PTR_CTRLr_GET(r) (r).ing_ipmc_ptr_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_ING_IPMC_PTR_CTRLr_LOWER_LIMITf_GET(r) (((r).ing_ipmc_ptr_ctrl[0]) & 0x3ff)
#define BCM56504_A0_ING_IPMC_PTR_CTRLr_LOWER_LIMITf_SET(r,f) (r).ing_ipmc_ptr_ctrl[0]=(((r).ing_ipmc_ptr_ctrl[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM56504_A0_ING_IPMC_PTR_CTRLr_UPPER_LIMITf_GET(r) ((((r).ing_ipmc_ptr_ctrl[0]) >> 10) & 0x3ff)
#define BCM56504_A0_ING_IPMC_PTR_CTRLr_UPPER_LIMITf_SET(r,f) (r).ing_ipmc_ptr_ctrl[0]=(((r).ing_ipmc_ptr_ctrl[0] & ~((uint32_t)0x3ff << 10)) | ((((uint32_t)f) & 0x3ff) << 10))
#define BCM56504_A0_ING_IPMC_PTR_CTRLr_ENABLEf_GET(r) ((((r).ing_ipmc_ptr_ctrl[0]) >> 20) & 0x1)
#define BCM56504_A0_ING_IPMC_PTR_CTRLr_ENABLEf_SET(r,f) (r).ing_ipmc_ptr_ctrl[0]=(((r).ing_ipmc_ptr_ctrl[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))

/*
 * These macros can be used to access ING_IPMC_PTR_CTRL.
 *
 */
#define BCM56504_A0_READ_ING_IPMC_PTR_CTRLr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_ING_IPMC_PTR_CTRLr,(r._ing_ipmc_ptr_ctrl))
#define BCM56504_A0_WRITE_ING_IPMC_PTR_CTRLr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_ING_IPMC_PTR_CTRLr,&(r._ing_ipmc_ptr_ctrl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ING_IPMC_PTR_CTRLr BCM56504_A0_ING_IPMC_PTR_CTRLr
#define ING_IPMC_PTR_CTRLr_SIZE BCM56504_A0_ING_IPMC_PTR_CTRLr_SIZE
typedef BCM56504_A0_ING_IPMC_PTR_CTRLr_t ING_IPMC_PTR_CTRLr_t;
#define ING_IPMC_PTR_CTRLr_CLR BCM56504_A0_ING_IPMC_PTR_CTRLr_CLR
#define ING_IPMC_PTR_CTRLr_SET BCM56504_A0_ING_IPMC_PTR_CTRLr_SET
#define ING_IPMC_PTR_CTRLr_GET BCM56504_A0_ING_IPMC_PTR_CTRLr_GET
#define ING_IPMC_PTR_CTRLr_LOWER_LIMITf_GET BCM56504_A0_ING_IPMC_PTR_CTRLr_LOWER_LIMITf_GET
#define ING_IPMC_PTR_CTRLr_LOWER_LIMITf_SET BCM56504_A0_ING_IPMC_PTR_CTRLr_LOWER_LIMITf_SET
#define ING_IPMC_PTR_CTRLr_UPPER_LIMITf_GET BCM56504_A0_ING_IPMC_PTR_CTRLr_UPPER_LIMITf_GET
#define ING_IPMC_PTR_CTRLr_UPPER_LIMITf_SET BCM56504_A0_ING_IPMC_PTR_CTRLr_UPPER_LIMITf_SET
#define ING_IPMC_PTR_CTRLr_ENABLEf_GET BCM56504_A0_ING_IPMC_PTR_CTRLr_ENABLEf_GET
#define ING_IPMC_PTR_CTRLr_ENABLEf_SET BCM56504_A0_ING_IPMC_PTR_CTRLr_ENABLEf_SET
#define READ_ING_IPMC_PTR_CTRLr BCM56504_A0_READ_ING_IPMC_PTR_CTRLr
#define WRITE_ING_IPMC_PTR_CTRLr BCM56504_A0_WRITE_ING_IPMC_PTR_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_ING_IPMC_PTR_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  ING_L3_NEXT_HOP
 * BLOCKS:   IPIPE
 * DESC:     Reduced version of L3_NEXT_HOP table.  Used to provide just mod and port/TGID
 * SIZE:     25
 * FIELDS:
 *     L3UC_TUNNEL_TYPE Tunnel Type
 *     PORT_TGID        Port/TGID of next hop
 *     MODULE_ID        Module ID of next hop
 *     VLAN_ID          VLAN ID of next hop
 *
 ******************************************************************************/
#define BCM56504_A0_ING_L3_NEXT_HOPm 0x0d710000

#define BCM56504_A0_ING_L3_NEXT_HOPm_MIN 0
#define BCM56504_A0_ING_L3_NEXT_HOPm_MAX 8191
#define BCM56504_A0_ING_L3_NEXT_HOPm_CMAX(u) 8191
#define BCM56504_A0_ING_L3_NEXT_HOPm_SIZE 4

/*
 * This structure should be used to declare and program ING_L3_NEXT_HOP.
 *
 */
typedef union BCM56504_A0_ING_L3_NEXT_HOPm_s {
	uint32_t v[1];
	uint32_t ing_l3_next_hop[1];
	uint32_t _ing_l3_next_hop;
} BCM56504_A0_ING_L3_NEXT_HOPm_t;

#define BCM56504_A0_ING_L3_NEXT_HOPm_CLR(r) (r).ing_l3_next_hop[0] = 0
#define BCM56504_A0_ING_L3_NEXT_HOPm_SET(r,d) (r).ing_l3_next_hop[0] = d
#define BCM56504_A0_ING_L3_NEXT_HOPm_GET(r) (r).ing_l3_next_hop[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_ING_L3_NEXT_HOPm_L3UC_TUNNEL_TYPEf_GET(r) (((r).ing_l3_next_hop[0]) & 0x1)
#define BCM56504_A0_ING_L3_NEXT_HOPm_L3UC_TUNNEL_TYPEf_SET(r,f) (r).ing_l3_next_hop[0]=(((r).ing_l3_next_hop[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_ING_L3_NEXT_HOPm_PORT_TGIDf_GET(r) ((((r).ing_l3_next_hop[0]) >> 1) & 0x3f)
#define BCM56504_A0_ING_L3_NEXT_HOPm_PORT_TGIDf_SET(r,f) (r).ing_l3_next_hop[0]=(((r).ing_l3_next_hop[0] & ~((uint32_t)0x3f << 1)) | ((((uint32_t)f) & 0x3f) << 1))
#define BCM56504_A0_ING_L3_NEXT_HOPm_MODULE_IDf_GET(r) ((((r).ing_l3_next_hop[0]) >> 7) & 0x3f)
#define BCM56504_A0_ING_L3_NEXT_HOPm_MODULE_IDf_SET(r,f) (r).ing_l3_next_hop[0]=(((r).ing_l3_next_hop[0] & ~((uint32_t)0x3f << 7)) | ((((uint32_t)f) & 0x3f) << 7))
#define BCM56504_A0_ING_L3_NEXT_HOPm_VLAN_IDf_GET(r) ((((r).ing_l3_next_hop[0]) >> 13) & 0xfff)
#define BCM56504_A0_ING_L3_NEXT_HOPm_VLAN_IDf_SET(r,f) (r).ing_l3_next_hop[0]=(((r).ing_l3_next_hop[0] & ~((uint32_t)0xfff << 13)) | ((((uint32_t)f) & 0xfff) << 13))

/*
 * These macros can be used to access ING_L3_NEXT_HOP.
 *
 */
#define BCM56504_A0_READ_ING_L3_NEXT_HOPm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_ING_L3_NEXT_HOPm,i,(m._ing_l3_next_hop),1)
#define BCM56504_A0_WRITE_ING_L3_NEXT_HOPm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_ING_L3_NEXT_HOPm,i,&(m._ing_l3_next_hop),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ING_L3_NEXT_HOPm BCM56504_A0_ING_L3_NEXT_HOPm
#define ING_L3_NEXT_HOPm_MIN BCM56504_A0_ING_L3_NEXT_HOPm_MIN
#define ING_L3_NEXT_HOPm_MAX BCM56504_A0_ING_L3_NEXT_HOPm_MAX
#define ING_L3_NEXT_HOPm_CMAX(u) BCM56504_A0_ING_L3_NEXT_HOPm_CMAX(u)
#define ING_L3_NEXT_HOPm_SIZE BCM56504_A0_ING_L3_NEXT_HOPm_SIZE
typedef BCM56504_A0_ING_L3_NEXT_HOPm_t ING_L3_NEXT_HOPm_t;
#define ING_L3_NEXT_HOPm_CLR BCM56504_A0_ING_L3_NEXT_HOPm_CLR
#define ING_L3_NEXT_HOPm_SET BCM56504_A0_ING_L3_NEXT_HOPm_SET
#define ING_L3_NEXT_HOPm_GET BCM56504_A0_ING_L3_NEXT_HOPm_GET
#define ING_L3_NEXT_HOPm_L3UC_TUNNEL_TYPEf_GET BCM56504_A0_ING_L3_NEXT_HOPm_L3UC_TUNNEL_TYPEf_GET
#define ING_L3_NEXT_HOPm_L3UC_TUNNEL_TYPEf_SET BCM56504_A0_ING_L3_NEXT_HOPm_L3UC_TUNNEL_TYPEf_SET
#define ING_L3_NEXT_HOPm_PORT_TGIDf_GET BCM56504_A0_ING_L3_NEXT_HOPm_PORT_TGIDf_GET
#define ING_L3_NEXT_HOPm_PORT_TGIDf_SET BCM56504_A0_ING_L3_NEXT_HOPm_PORT_TGIDf_SET
#define ING_L3_NEXT_HOPm_MODULE_IDf_GET BCM56504_A0_ING_L3_NEXT_HOPm_MODULE_IDf_GET
#define ING_L3_NEXT_HOPm_MODULE_IDf_SET BCM56504_A0_ING_L3_NEXT_HOPm_MODULE_IDf_SET
#define ING_L3_NEXT_HOPm_VLAN_IDf_GET BCM56504_A0_ING_L3_NEXT_HOPm_VLAN_IDf_GET
#define ING_L3_NEXT_HOPm_VLAN_IDf_SET BCM56504_A0_ING_L3_NEXT_HOPm_VLAN_IDf_SET
#define READ_ING_L3_NEXT_HOPm BCM56504_A0_READ_ING_L3_NEXT_HOPm
#define WRITE_ING_L3_NEXT_HOPm BCM56504_A0_WRITE_ING_L3_NEXT_HOPm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_ING_L3_NEXT_HOPm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  ING_Q_BEGIN
 * BLOCKS:   IPIPE
 * DESC:     Register starts the IQ Bus which is provided for later ECO reasons, if any.
 * SIZE:     32
 * FIELDS:
 *     L2_HITSA_RM      rm test pin on the L2_HITSA RAM.
 *     L2_HITDA_CCM     ccm test pin on the L2_HITDA RAM.
 *     L2_HITDA_RM      rm test pin on the L2_HITDA RAM.
 *     L2_HITSA_CCM     ccm test pin on the L2_HITSA RAM.
 *     QBUS             Debug BUS introduced for later ECO provisions.
 *
 ******************************************************************************/
#define BCM56504_A0_ING_Q_BEGINr 0x00780006

#define BCM56504_A0_ING_Q_BEGINr_SIZE 4

/*
 * This structure should be used to declare and program ING_Q_BEGIN.
 *
 */
typedef union BCM56504_A0_ING_Q_BEGINr_s {
	uint32_t v[1];
	uint32_t ing_q_begin[1];
	uint32_t _ing_q_begin;
} BCM56504_A0_ING_Q_BEGINr_t;

#define BCM56504_A0_ING_Q_BEGINr_CLR(r) (r).ing_q_begin[0] = 0
#define BCM56504_A0_ING_Q_BEGINr_SET(r,d) (r).ing_q_begin[0] = d
#define BCM56504_A0_ING_Q_BEGINr_GET(r) (r).ing_q_begin[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_ING_Q_BEGINr_L2_HITSA_RMf_GET(r) (((r).ing_q_begin[0]) & 0x1)
#define BCM56504_A0_ING_Q_BEGINr_L2_HITSA_RMf_SET(r,f) (r).ing_q_begin[0]=(((r).ing_q_begin[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_ING_Q_BEGINr_L2_HITDA_CCMf_GET(r) ((((r).ing_q_begin[0]) >> 1) & 0x1)
#define BCM56504_A0_ING_Q_BEGINr_L2_HITDA_CCMf_SET(r,f) (r).ing_q_begin[0]=(((r).ing_q_begin[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_ING_Q_BEGINr_L2_HITDA_RMf_GET(r) ((((r).ing_q_begin[0]) >> 7) & 0x1)
#define BCM56504_A0_ING_Q_BEGINr_L2_HITDA_RMf_SET(r,f) (r).ing_q_begin[0]=(((r).ing_q_begin[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56504_A0_ING_Q_BEGINr_L2_HITSA_CCMf_GET(r) ((((r).ing_q_begin[0]) >> 13) & 0x1)
#define BCM56504_A0_ING_Q_BEGINr_L2_HITSA_CCMf_SET(r,f) (r).ing_q_begin[0]=(((r).ing_q_begin[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56504_A0_ING_Q_BEGINr_QBUSf_GET(r) ((r).ing_q_begin[0])
#define BCM56504_A0_ING_Q_BEGINr_QBUSf_SET(r,f) (r).ing_q_begin[0]=((uint32_t)f)

/*
 * These macros can be used to access ING_Q_BEGIN.
 *
 */
#define BCM56504_A0_READ_ING_Q_BEGINr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_ING_Q_BEGINr,(r._ing_q_begin))
#define BCM56504_A0_WRITE_ING_Q_BEGINr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_ING_Q_BEGINr,&(r._ing_q_begin))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ING_Q_BEGINr BCM56504_A0_ING_Q_BEGINr
#define ING_Q_BEGINr_SIZE BCM56504_A0_ING_Q_BEGINr_SIZE
typedef BCM56504_A0_ING_Q_BEGINr_t ING_Q_BEGINr_t;
#define ING_Q_BEGINr_CLR BCM56504_A0_ING_Q_BEGINr_CLR
#define ING_Q_BEGINr_SET BCM56504_A0_ING_Q_BEGINr_SET
#define ING_Q_BEGINr_GET BCM56504_A0_ING_Q_BEGINr_GET
#define ING_Q_BEGINr_L2_HITSA_RMf_GET BCM56504_A0_ING_Q_BEGINr_L2_HITSA_RMf_GET
#define ING_Q_BEGINr_L2_HITSA_RMf_SET BCM56504_A0_ING_Q_BEGINr_L2_HITSA_RMf_SET
#define ING_Q_BEGINr_L2_HITDA_CCMf_GET BCM56504_A0_ING_Q_BEGINr_L2_HITDA_CCMf_GET
#define ING_Q_BEGINr_L2_HITDA_CCMf_SET BCM56504_A0_ING_Q_BEGINr_L2_HITDA_CCMf_SET
#define ING_Q_BEGINr_L2_HITDA_RMf_GET BCM56504_A0_ING_Q_BEGINr_L2_HITDA_RMf_GET
#define ING_Q_BEGINr_L2_HITDA_RMf_SET BCM56504_A0_ING_Q_BEGINr_L2_HITDA_RMf_SET
#define ING_Q_BEGINr_L2_HITSA_CCMf_GET BCM56504_A0_ING_Q_BEGINr_L2_HITSA_CCMf_GET
#define ING_Q_BEGINr_L2_HITSA_CCMf_SET BCM56504_A0_ING_Q_BEGINr_L2_HITSA_CCMf_SET
#define ING_Q_BEGINr_QBUSf_GET BCM56504_A0_ING_Q_BEGINr_QBUSf_GET
#define ING_Q_BEGINr_QBUSf_SET BCM56504_A0_ING_Q_BEGINr_QBUSf_SET
#define READ_ING_Q_BEGINr BCM56504_A0_READ_ING_Q_BEGINr
#define WRITE_ING_Q_BEGINr BCM56504_A0_WRITE_ING_Q_BEGINr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_ING_Q_BEGINr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  IPMCIDXINCCONFIG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     IPMCIDXLOWMARKER IPMC Index Low Marker.
 *     IPMCIDXHIGHMARKER IPMC Index High Marker
 *     IPMCIDXINCEN     IPMC Index Increment Mode Enable bit is controlling IPMC index increment feature for all ipmc replicated packet transmit to Higi port. IPMC index need to bewithin the reange defined by IPMCIdxHighMarker and IPMCIdxLowMarker. New IPMCIndex send will be the original IPMC Index added with replicated packet number.Ex. First packet, New IPMC Index = Original IPMC Index + 1;    Second packet, New IPMC Index = Original IPMC Index + 2;    ....    n-th packet, New IPMC Index = Original IPMC Index + n;1: IPMC Index Increment Mode En.0: IPMC Index Increment Mode Disable.
 *
 ******************************************************************************/
#define BCM56504_A0_IPMCIDXINCCONFIGr 0x00680018

#define BCM56504_A0_IPMCIDXINCCONFIGr_SIZE 4

/*
 * This structure should be used to declare and program IPMCIDXINCCONFIG.
 *
 */
typedef union BCM56504_A0_IPMCIDXINCCONFIGr_s {
	uint32_t v[1];
	uint32_t ipmcidxincconfig[1];
	uint32_t _ipmcidxincconfig;
} BCM56504_A0_IPMCIDXINCCONFIGr_t;

#define BCM56504_A0_IPMCIDXINCCONFIGr_CLR(r) (r).ipmcidxincconfig[0] = 0
#define BCM56504_A0_IPMCIDXINCCONFIGr_SET(r,d) (r).ipmcidxincconfig[0] = d
#define BCM56504_A0_IPMCIDXINCCONFIGr_GET(r) (r).ipmcidxincconfig[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_IPMCIDXINCCONFIGr_IPMCIDXLOWMARKERf_GET(r) (((r).ipmcidxincconfig[0]) & 0x3ff)
#define BCM56504_A0_IPMCIDXINCCONFIGr_IPMCIDXLOWMARKERf_SET(r,f) (r).ipmcidxincconfig[0]=(((r).ipmcidxincconfig[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM56504_A0_IPMCIDXINCCONFIGr_IPMCIDXHIGHMARKERf_GET(r) ((((r).ipmcidxincconfig[0]) >> 10) & 0x3ff)
#define BCM56504_A0_IPMCIDXINCCONFIGr_IPMCIDXHIGHMARKERf_SET(r,f) (r).ipmcidxincconfig[0]=(((r).ipmcidxincconfig[0] & ~((uint32_t)0x3ff << 10)) | ((((uint32_t)f) & 0x3ff) << 10))
#define BCM56504_A0_IPMCIDXINCCONFIGr_IPMCIDXINCENf_GET(r) ((((r).ipmcidxincconfig[0]) >> 20) & 0x1)
#define BCM56504_A0_IPMCIDXINCCONFIGr_IPMCIDXINCENf_SET(r,f) (r).ipmcidxincconfig[0]=(((r).ipmcidxincconfig[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))

/*
 * These macros can be used to access IPMCIDXINCCONFIG.
 *
 */
#define BCM56504_A0_READ_IPMCIDXINCCONFIGr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_IPMCIDXINCCONFIGr,(r._ipmcidxincconfig))
#define BCM56504_A0_WRITE_IPMCIDXINCCONFIGr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_IPMCIDXINCCONFIGr,&(r._ipmcidxincconfig))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IPMCIDXINCCONFIGr BCM56504_A0_IPMCIDXINCCONFIGr
#define IPMCIDXINCCONFIGr_SIZE BCM56504_A0_IPMCIDXINCCONFIGr_SIZE
typedef BCM56504_A0_IPMCIDXINCCONFIGr_t IPMCIDXINCCONFIGr_t;
#define IPMCIDXINCCONFIGr_CLR BCM56504_A0_IPMCIDXINCCONFIGr_CLR
#define IPMCIDXINCCONFIGr_SET BCM56504_A0_IPMCIDXINCCONFIGr_SET
#define IPMCIDXINCCONFIGr_GET BCM56504_A0_IPMCIDXINCCONFIGr_GET
#define IPMCIDXINCCONFIGr_IPMCIDXLOWMARKERf_GET BCM56504_A0_IPMCIDXINCCONFIGr_IPMCIDXLOWMARKERf_GET
#define IPMCIDXINCCONFIGr_IPMCIDXLOWMARKERf_SET BCM56504_A0_IPMCIDXINCCONFIGr_IPMCIDXLOWMARKERf_SET
#define IPMCIDXINCCONFIGr_IPMCIDXHIGHMARKERf_GET BCM56504_A0_IPMCIDXINCCONFIGr_IPMCIDXHIGHMARKERf_GET
#define IPMCIDXINCCONFIGr_IPMCIDXHIGHMARKERf_SET BCM56504_A0_IPMCIDXINCCONFIGr_IPMCIDXHIGHMARKERf_SET
#define IPMCIDXINCCONFIGr_IPMCIDXINCENf_GET BCM56504_A0_IPMCIDXINCCONFIGr_IPMCIDXINCENf_GET
#define IPMCIDXINCCONFIGr_IPMCIDXINCENf_SET BCM56504_A0_IPMCIDXINCCONFIGr_IPMCIDXINCENf_SET
#define READ_IPMCIDXINCCONFIGr BCM56504_A0_READ_IPMCIDXINCCONFIGr
#define WRITE_IPMCIDXINCCONFIGr BCM56504_A0_WRITE_IPMCIDXINCCONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_IPMCIDXINCCONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  IPMCREPLICATIONCOUNT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     REPLICATION_COUNT Replication Counter for a specified cos of each egress port how many packets are doing IPMC replication. Counter will count any replicated packet for the specified cos on that egrees port.Counter will keep the total number of whole replication if it is over its replication limit. If the limit is not reached for any ipmc replication, Counter will be reset at the end of replication. For the case of replication count over 8191, the counter will not overflow but stay as 8191.
 *     REPLICATION_LIMIT Replication Limit is used on each replication counter to account how manyipmc packet replicated for the specified cos. A s-bus memfail interrupt will be issued (if REPLICATION_COUNT_EN is enabled) when replication countedis reachiing or over the replication limit. If this limit is set to 0 or over 4096, the internal limit will be use 4k for replication limit in stead. 
 *     REPLICATION_COS  Selected COS register for acoounting replicating number on each IPMC port. 
 *     REPLICATION_OVER_LIMIT Replication over limit status register for replication over limit.Once this bit set, a memfail message will be issued. When this bit is set, it needs a read to this register to clear status. 
 *     REPLICATION_COUNT_EN Per port enable register to start counting ipmc replication for specific cos. 
 *     REPLICATION_SRCH_FAIL IPMC replication group or vlan search fail status register is set when for any cos happen on each IPMC port. When this bit is set, it needs a read to this register to clear status. 
 *
 ******************************************************************************/
#define BCM56504_A0_IPMCREPLICATIONCOUNTr 0x0060004a

#define BCM56504_A0_IPMCREPLICATIONCOUNTr_SIZE 4

/*
 * This structure should be used to declare and program IPMCREPLICATIONCOUNT.
 *
 */
typedef union BCM56504_A0_IPMCREPLICATIONCOUNTr_s {
	uint32_t v[1];
	uint32_t ipmcreplicationcount[1];
	uint32_t _ipmcreplicationcount;
} BCM56504_A0_IPMCREPLICATIONCOUNTr_t;

#define BCM56504_A0_IPMCREPLICATIONCOUNTr_CLR(r) (r).ipmcreplicationcount[0] = 0
#define BCM56504_A0_IPMCREPLICATIONCOUNTr_SET(r,d) (r).ipmcreplicationcount[0] = d
#define BCM56504_A0_IPMCREPLICATIONCOUNTr_GET(r) (r).ipmcreplicationcount[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_IPMCREPLICATIONCOUNTr_REPLICATION_COUNTf_GET(r) (((r).ipmcreplicationcount[0]) & 0x1fff)
#define BCM56504_A0_IPMCREPLICATIONCOUNTr_REPLICATION_COUNTf_SET(r,f) (r).ipmcreplicationcount[0]=(((r).ipmcreplicationcount[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))
#define BCM56504_A0_IPMCREPLICATIONCOUNTr_REPLICATION_LIMITf_GET(r) ((((r).ipmcreplicationcount[0]) >> 13) & 0x1fff)
#define BCM56504_A0_IPMCREPLICATIONCOUNTr_REPLICATION_LIMITf_SET(r,f) (r).ipmcreplicationcount[0]=(((r).ipmcreplicationcount[0] & ~((uint32_t)0x1fff << 13)) | ((((uint32_t)f) & 0x1fff) << 13))
#define BCM56504_A0_IPMCREPLICATIONCOUNTr_REPLICATION_COSf_GET(r) ((((r).ipmcreplicationcount[0]) >> 26) & 0x7)
#define BCM56504_A0_IPMCREPLICATIONCOUNTr_REPLICATION_COSf_SET(r,f) (r).ipmcreplicationcount[0]=(((r).ipmcreplicationcount[0] & ~((uint32_t)0x7 << 26)) | ((((uint32_t)f) & 0x7) << 26))
#define BCM56504_A0_IPMCREPLICATIONCOUNTr_REPLICATION_OVER_LIMITf_GET(r) ((((r).ipmcreplicationcount[0]) >> 29) & 0x1)
#define BCM56504_A0_IPMCREPLICATIONCOUNTr_REPLICATION_OVER_LIMITf_SET(r,f) (r).ipmcreplicationcount[0]=(((r).ipmcreplicationcount[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM56504_A0_IPMCREPLICATIONCOUNTr_REPLICATION_COUNT_ENf_GET(r) ((((r).ipmcreplicationcount[0]) >> 30) & 0x1)
#define BCM56504_A0_IPMCREPLICATIONCOUNTr_REPLICATION_COUNT_ENf_SET(r,f) (r).ipmcreplicationcount[0]=(((r).ipmcreplicationcount[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM56504_A0_IPMCREPLICATIONCOUNTr_REPLICATION_SRCH_FAILf_GET(r) ((((r).ipmcreplicationcount[0]) >> 31) & 0x1)
#define BCM56504_A0_IPMCREPLICATIONCOUNTr_REPLICATION_SRCH_FAILf_SET(r,f) (r).ipmcreplicationcount[0]=(((r).ipmcreplicationcount[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access IPMCREPLICATIONCOUNT.
 *
 */
#define BCM56504_A0_READ_IPMCREPLICATIONCOUNTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_IPMCREPLICATIONCOUNTr,(r._ipmcreplicationcount))
#define BCM56504_A0_WRITE_IPMCREPLICATIONCOUNTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_IPMCREPLICATIONCOUNTr,&(r._ipmcreplicationcount))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IPMCREPLICATIONCOUNTr BCM56504_A0_IPMCREPLICATIONCOUNTr
#define IPMCREPLICATIONCOUNTr_SIZE BCM56504_A0_IPMCREPLICATIONCOUNTr_SIZE
typedef BCM56504_A0_IPMCREPLICATIONCOUNTr_t IPMCREPLICATIONCOUNTr_t;
#define IPMCREPLICATIONCOUNTr_CLR BCM56504_A0_IPMCREPLICATIONCOUNTr_CLR
#define IPMCREPLICATIONCOUNTr_SET BCM56504_A0_IPMCREPLICATIONCOUNTr_SET
#define IPMCREPLICATIONCOUNTr_GET BCM56504_A0_IPMCREPLICATIONCOUNTr_GET
#define IPMCREPLICATIONCOUNTr_REPLICATION_COUNTf_GET BCM56504_A0_IPMCREPLICATIONCOUNTr_REPLICATION_COUNTf_GET
#define IPMCREPLICATIONCOUNTr_REPLICATION_COUNTf_SET BCM56504_A0_IPMCREPLICATIONCOUNTr_REPLICATION_COUNTf_SET
#define IPMCREPLICATIONCOUNTr_REPLICATION_LIMITf_GET BCM56504_A0_IPMCREPLICATIONCOUNTr_REPLICATION_LIMITf_GET
#define IPMCREPLICATIONCOUNTr_REPLICATION_LIMITf_SET BCM56504_A0_IPMCREPLICATIONCOUNTr_REPLICATION_LIMITf_SET
#define IPMCREPLICATIONCOUNTr_REPLICATION_COSf_GET BCM56504_A0_IPMCREPLICATIONCOUNTr_REPLICATION_COSf_GET
#define IPMCREPLICATIONCOUNTr_REPLICATION_COSf_SET BCM56504_A0_IPMCREPLICATIONCOUNTr_REPLICATION_COSf_SET
#define IPMCREPLICATIONCOUNTr_REPLICATION_OVER_LIMITf_GET BCM56504_A0_IPMCREPLICATIONCOUNTr_REPLICATION_OVER_LIMITf_GET
#define IPMCREPLICATIONCOUNTr_REPLICATION_OVER_LIMITf_SET BCM56504_A0_IPMCREPLICATIONCOUNTr_REPLICATION_OVER_LIMITf_SET
#define IPMCREPLICATIONCOUNTr_REPLICATION_COUNT_ENf_GET BCM56504_A0_IPMCREPLICATIONCOUNTr_REPLICATION_COUNT_ENf_GET
#define IPMCREPLICATIONCOUNTr_REPLICATION_COUNT_ENf_SET BCM56504_A0_IPMCREPLICATIONCOUNTr_REPLICATION_COUNT_ENf_SET
#define IPMCREPLICATIONCOUNTr_REPLICATION_SRCH_FAILf_GET BCM56504_A0_IPMCREPLICATIONCOUNTr_REPLICATION_SRCH_FAILf_GET
#define IPMCREPLICATIONCOUNTr_REPLICATION_SRCH_FAILf_SET BCM56504_A0_IPMCREPLICATIONCOUNTr_REPLICATION_SRCH_FAILf_SET
#define READ_IPMCREPLICATIONCOUNTr BCM56504_A0_READ_IPMCREPLICATIONCOUNTr
#define WRITE_IPMCREPLICATIONCOUNTr BCM56504_A0_WRITE_IPMCREPLICATIONCOUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_IPMCREPLICATIONCOUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  IPMCREPOVERLMTPBM
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     IPMCREPOVERLMTPBM Egress Port Bitmap indicats which IPMC Replication egress port is over replication limit error. Bitmap will be clear after a register read.
 *
 ******************************************************************************/
#define BCM56504_A0_IPMCREPOVERLMTPBMr 0x00680036

#define BCM56504_A0_IPMCREPOVERLMTPBMr_SIZE 4

/*
 * This structure should be used to declare and program IPMCREPOVERLMTPBM.
 *
 */
typedef union BCM56504_A0_IPMCREPOVERLMTPBMr_s {
	uint32_t v[1];
	uint32_t ipmcrepoverlmtpbm[1];
	uint32_t _ipmcrepoverlmtpbm;
} BCM56504_A0_IPMCREPOVERLMTPBMr_t;

#define BCM56504_A0_IPMCREPOVERLMTPBMr_CLR(r) (r).ipmcrepoverlmtpbm[0] = 0
#define BCM56504_A0_IPMCREPOVERLMTPBMr_SET(r,d) (r).ipmcrepoverlmtpbm[0] = d
#define BCM56504_A0_IPMCREPOVERLMTPBMr_GET(r) (r).ipmcrepoverlmtpbm[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_IPMCREPOVERLMTPBMr_IPMCREPOVERLMTPBMf_GET(r) (((r).ipmcrepoverlmtpbm[0]) & 0xfffffff)
#define BCM56504_A0_IPMCREPOVERLMTPBMr_IPMCREPOVERLMTPBMf_SET(r,f) (r).ipmcrepoverlmtpbm[0]=(((r).ipmcrepoverlmtpbm[0] & ~((uint32_t)0xfffffff)) | (((uint32_t)f) & 0xfffffff))

/*
 * These macros can be used to access IPMCREPOVERLMTPBM.
 *
 */
#define BCM56504_A0_READ_IPMCREPOVERLMTPBMr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_IPMCREPOVERLMTPBMr,(r._ipmcrepoverlmtpbm))
#define BCM56504_A0_WRITE_IPMCREPOVERLMTPBMr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_IPMCREPOVERLMTPBMr,&(r._ipmcrepoverlmtpbm))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IPMCREPOVERLMTPBMr BCM56504_A0_IPMCREPOVERLMTPBMr
#define IPMCREPOVERLMTPBMr_SIZE BCM56504_A0_IPMCREPOVERLMTPBMr_SIZE
typedef BCM56504_A0_IPMCREPOVERLMTPBMr_t IPMCREPOVERLMTPBMr_t;
#define IPMCREPOVERLMTPBMr_CLR BCM56504_A0_IPMCREPOVERLMTPBMr_CLR
#define IPMCREPOVERLMTPBMr_SET BCM56504_A0_IPMCREPOVERLMTPBMr_SET
#define IPMCREPOVERLMTPBMr_GET BCM56504_A0_IPMCREPOVERLMTPBMr_GET
#define IPMCREPOVERLMTPBMr_IPMCREPOVERLMTPBMf_GET BCM56504_A0_IPMCREPOVERLMTPBMr_IPMCREPOVERLMTPBMf_GET
#define IPMCREPOVERLMTPBMr_IPMCREPOVERLMTPBMf_SET BCM56504_A0_IPMCREPOVERLMTPBMr_IPMCREPOVERLMTPBMf_SET
#define READ_IPMCREPOVERLMTPBMr BCM56504_A0_READ_IPMCREPOVERLMTPBMr
#define WRITE_IPMCREPOVERLMTPBMr BCM56504_A0_WRITE_IPMCREPOVERLMTPBMr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_IPMCREPOVERLMTPBMr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  IPORT_TABLE
 * BLOCKS:   IPIPE_HI
 * DESC:     Port Table
 * SIZE:     68
 * FIELDS:
 *     FILTER_ENABLE    Enable Filtering
 *     VT_MISS_DROP     VLAN translation miss drop
 *     VT_ENABLE        VLAN translation enable
 *     TRUST_DSCP_V4    Ingress port is trusted port, trust incoming IPv4 DSCP
 *     TRUST_DSCP_V6    Ingress port is trusted port, trust incoming IPv6 DSCP
 *     EN_IFILTER       Enable ingress filtering
 *     MIRROR           Mirror enable
 *     CML              CPU managed learning
 *     PORT_PRI         Port default priority?
 *     IPMC_DO_VLAN     Unknown
 *     V6IPMC_ENABLE    IPv6 IPMC enable
 *     V4IPMC_ENABLE    IPv4 IPMC enable
 *     V6L3_ENABLE      IPv6 L3 enable
 *     V4L3_ENABLE      IPv4 L3 enable
 *     DROP_BPDU        when set, ingress drops BPDUs
 *     PORT_DIS_TAG     Drop all tagged packets
 *     PORT_DIS_UNTAG   Drop all untagged packets
 *     PASS_CONTROL_FRAMES Pass pause frames through without dropping
 *     SUBNET_BASED_VID_ENABLE Enable subnet-based VLANs
 *     MAC_BASED_VID_ENABLE Enable MAC-based VLANs
 *     PORT_VID         Port VLAN
 *     HIGIG_PACKET     Port is HiGig port
 *     NNI_PORT         Port is NNI port if set to 1, otherwise UNI port
 *     MAP_TAG_PKT_PRIORITY Map the incoming packet priority
 *     MY_MODID         Stacking module ID for this module
 *     OUTER_TPID       Outer (switching) VLAN
 *     VLAN_PRECEDENCE  Determine the priorities for selecting VLAN (MAC-based, subnet-based VLANs)
 *     PORT_BRIDGE      Allows L2 bridging to the incoming port
 *     IGNORE_IPMC_L2_BITMAP Set this bit to disable L2 bridging of IPMC pkts on this port
 *     IGNORE_IPMC_L3_BITMAP Set this bit to disable L3 routing of IPMC pkts on this port
 *     RESERVED         Reserved (spare) bit in the PORT_TABLE
 *
 ******************************************************************************/
#define BCM56504_A0_IPORT_TABLEm 0x01800000

#define BCM56504_A0_IPORT_TABLEm_MIN 24
#define BCM56504_A0_IPORT_TABLEm_MAX 28
#define BCM56504_A0_IPORT_TABLEm_CMAX(u) 28
#define BCM56504_A0_IPORT_TABLEm_SIZE 9

/*
 * This structure should be used to declare and program IPORT_TABLE.
 *
 */
typedef union BCM56504_A0_IPORT_TABLEm_s {
	uint32_t v[3];
	uint32_t iport_table[3];
	uint32_t _iport_table;
} BCM56504_A0_IPORT_TABLEm_t;

#define BCM56504_A0_IPORT_TABLEm_CLR(r) CDK_MEMSET(&((r)._iport_table), 0, sizeof(BCM56504_A0_IPORT_TABLEm_t))
#define BCM56504_A0_IPORT_TABLEm_SET(r,i,d) (r).iport_table[i] = d
#define BCM56504_A0_IPORT_TABLEm_GET(r,i) (r).iport_table[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_IPORT_TABLEm_FILTER_ENABLEf_GET(r) (((r).iport_table[0]) & 0x1)
#define BCM56504_A0_IPORT_TABLEm_FILTER_ENABLEf_SET(r,f) (r).iport_table[0]=(((r).iport_table[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_IPORT_TABLEm_VT_MISS_DROPf_GET(r) ((((r).iport_table[0]) >> 1) & 0x1)
#define BCM56504_A0_IPORT_TABLEm_VT_MISS_DROPf_SET(r,f) (r).iport_table[0]=(((r).iport_table[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_IPORT_TABLEm_VT_ENABLEf_GET(r) ((((r).iport_table[0]) >> 2) & 0x1)
#define BCM56504_A0_IPORT_TABLEm_VT_ENABLEf_SET(r,f) (r).iport_table[0]=(((r).iport_table[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_IPORT_TABLEm_TRUST_DSCP_V4f_GET(r) ((((r).iport_table[0]) >> 3) & 0x1)
#define BCM56504_A0_IPORT_TABLEm_TRUST_DSCP_V4f_SET(r,f) (r).iport_table[0]=(((r).iport_table[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_IPORT_TABLEm_TRUST_DSCP_V6f_GET(r) ((((r).iport_table[0]) >> 4) & 0x1)
#define BCM56504_A0_IPORT_TABLEm_TRUST_DSCP_V6f_SET(r,f) (r).iport_table[0]=(((r).iport_table[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56504_A0_IPORT_TABLEm_EN_IFILTERf_GET(r) ((((r).iport_table[0]) >> 5) & 0x1)
#define BCM56504_A0_IPORT_TABLEm_EN_IFILTERf_SET(r,f) (r).iport_table[0]=(((r).iport_table[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56504_A0_IPORT_TABLEm_MIRRORf_GET(r) ((((r).iport_table[0]) >> 6) & 0x1)
#define BCM56504_A0_IPORT_TABLEm_MIRRORf_SET(r,f) (r).iport_table[0]=(((r).iport_table[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56504_A0_IPORT_TABLEm_CMLf_GET(r) ((((r).iport_table[0]) >> 7) & 0x7)
#define BCM56504_A0_IPORT_TABLEm_CMLf_SET(r,f) (r).iport_table[0]=(((r).iport_table[0] & ~((uint32_t)0x7 << 7)) | ((((uint32_t)f) & 0x7) << 7))
#define BCM56504_A0_IPORT_TABLEm_PORT_PRIf_GET(r) ((((r).iport_table[0]) >> 10) & 0x7)
#define BCM56504_A0_IPORT_TABLEm_PORT_PRIf_SET(r,f) (r).iport_table[0]=(((r).iport_table[0] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10))
#define BCM56504_A0_IPORT_TABLEm_IPMC_DO_VLANf_GET(r) ((((r).iport_table[0]) >> 13) & 0x1)
#define BCM56504_A0_IPORT_TABLEm_IPMC_DO_VLANf_SET(r,f) (r).iport_table[0]=(((r).iport_table[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56504_A0_IPORT_TABLEm_V6IPMC_ENABLEf_GET(r) ((((r).iport_table[0]) >> 14) & 0x1)
#define BCM56504_A0_IPORT_TABLEm_V6IPMC_ENABLEf_SET(r,f) (r).iport_table[0]=(((r).iport_table[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM56504_A0_IPORT_TABLEm_V4IPMC_ENABLEf_GET(r) ((((r).iport_table[0]) >> 15) & 0x1)
#define BCM56504_A0_IPORT_TABLEm_V4IPMC_ENABLEf_SET(r,f) (r).iport_table[0]=(((r).iport_table[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56504_A0_IPORT_TABLEm_V6L3_ENABLEf_GET(r) ((((r).iport_table[0]) >> 16) & 0x1)
#define BCM56504_A0_IPORT_TABLEm_V6L3_ENABLEf_SET(r,f) (r).iport_table[0]=(((r).iport_table[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56504_A0_IPORT_TABLEm_V4L3_ENABLEf_GET(r) ((((r).iport_table[0]) >> 17) & 0x1)
#define BCM56504_A0_IPORT_TABLEm_V4L3_ENABLEf_SET(r,f) (r).iport_table[0]=(((r).iport_table[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56504_A0_IPORT_TABLEm_DROP_BPDUf_GET(r) ((((r).iport_table[0]) >> 18) & 0x1)
#define BCM56504_A0_IPORT_TABLEm_DROP_BPDUf_SET(r,f) (r).iport_table[0]=(((r).iport_table[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56504_A0_IPORT_TABLEm_PORT_DIS_TAGf_GET(r) ((((r).iport_table[0]) >> 19) & 0x1)
#define BCM56504_A0_IPORT_TABLEm_PORT_DIS_TAGf_SET(r,f) (r).iport_table[0]=(((r).iport_table[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56504_A0_IPORT_TABLEm_PORT_DIS_UNTAGf_GET(r) ((((r).iport_table[0]) >> 20) & 0x1)
#define BCM56504_A0_IPORT_TABLEm_PORT_DIS_UNTAGf_SET(r,f) (r).iport_table[0]=(((r).iport_table[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM56504_A0_IPORT_TABLEm_PASS_CONTROL_FRAMESf_GET(r) ((((r).iport_table[0]) >> 21) & 0x1)
#define BCM56504_A0_IPORT_TABLEm_PASS_CONTROL_FRAMESf_SET(r,f) (r).iport_table[0]=(((r).iport_table[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM56504_A0_IPORT_TABLEm_SUBNET_BASED_VID_ENABLEf_GET(r) ((((r).iport_table[0]) >> 22) & 0x1)
#define BCM56504_A0_IPORT_TABLEm_SUBNET_BASED_VID_ENABLEf_SET(r,f) (r).iport_table[0]=(((r).iport_table[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM56504_A0_IPORT_TABLEm_MAC_BASED_VID_ENABLEf_GET(r) ((((r).iport_table[0]) >> 23) & 0x1)
#define BCM56504_A0_IPORT_TABLEm_MAC_BASED_VID_ENABLEf_SET(r,f) (r).iport_table[0]=(((r).iport_table[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM56504_A0_IPORT_TABLEm_PORT_VIDf_GET(r) cdk_field32_get((r).iport_table,24,35)
#define BCM56504_A0_IPORT_TABLEm_PORT_VIDf_SET(r,f) cdk_field32_set((r).iport_table,24,35,f)
#define BCM56504_A0_IPORT_TABLEm_HIGIG_PACKETf_GET(r) ((((r).iport_table[1]) >> 4) & 0x1)
#define BCM56504_A0_IPORT_TABLEm_HIGIG_PACKETf_SET(r,f) (r).iport_table[1]=(((r).iport_table[1] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56504_A0_IPORT_TABLEm_NNI_PORTf_GET(r) ((((r).iport_table[1]) >> 5) & 0x1)
#define BCM56504_A0_IPORT_TABLEm_NNI_PORTf_SET(r,f) (r).iport_table[1]=(((r).iport_table[1] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56504_A0_IPORT_TABLEm_MAP_TAG_PKT_PRIORITYf_GET(r) ((((r).iport_table[1]) >> 6) & 0x1)
#define BCM56504_A0_IPORT_TABLEm_MAP_TAG_PKT_PRIORITYf_SET(r,f) (r).iport_table[1]=(((r).iport_table[1] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56504_A0_IPORT_TABLEm_MY_MODIDf_GET(r) ((((r).iport_table[1]) >> 7) & 0x3f)
#define BCM56504_A0_IPORT_TABLEm_MY_MODIDf_SET(r,f) (r).iport_table[1]=(((r).iport_table[1] & ~((uint32_t)0x3f << 7)) | ((((uint32_t)f) & 0x3f) << 7))
#define BCM56504_A0_IPORT_TABLEm_OUTER_TPIDf_GET(r) ((((r).iport_table[1]) >> 13) & 0xffff)
#define BCM56504_A0_IPORT_TABLEm_OUTER_TPIDf_SET(r,f) (r).iport_table[1]=(((r).iport_table[1] & ~((uint32_t)0xffff << 13)) | ((((uint32_t)f) & 0xffff) << 13))
#define BCM56504_A0_IPORT_TABLEm_VLAN_PRECEDENCEf_GET(r) ((((r).iport_table[1]) >> 29) & 0x1)
#define BCM56504_A0_IPORT_TABLEm_VLAN_PRECEDENCEf_SET(r,f) (r).iport_table[1]=(((r).iport_table[1] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM56504_A0_IPORT_TABLEm_PORT_BRIDGEf_GET(r) ((((r).iport_table[1]) >> 30) & 0x1)
#define BCM56504_A0_IPORT_TABLEm_PORT_BRIDGEf_SET(r,f) (r).iport_table[1]=(((r).iport_table[1] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM56504_A0_IPORT_TABLEm_IGNORE_IPMC_L2_BITMAPf_GET(r) ((((r).iport_table[1]) >> 31) & 0x1)
#define BCM56504_A0_IPORT_TABLEm_IGNORE_IPMC_L2_BITMAPf_SET(r,f) (r).iport_table[1]=(((r).iport_table[1] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM56504_A0_IPORT_TABLEm_IGNORE_IPMC_L3_BITMAPf_GET(r) (((r).iport_table[2]) & 0x1)
#define BCM56504_A0_IPORT_TABLEm_IGNORE_IPMC_L3_BITMAPf_SET(r,f) (r).iport_table[2]=(((r).iport_table[2] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_IPORT_TABLEm_RESERVEDf_GET(r) ((((r).iport_table[2]) >> 1) & 0x7)
#define BCM56504_A0_IPORT_TABLEm_RESERVEDf_SET(r,f) (r).iport_table[2]=(((r).iport_table[2] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))

/*
 * These macros can be used to access IPORT_TABLE.
 *
 */
#define BCM56504_A0_READ_IPORT_TABLEm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_IPORT_TABLEm,i,(m._iport_table),3)
#define BCM56504_A0_WRITE_IPORT_TABLEm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_IPORT_TABLEm,i,&(m._iport_table),3)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IPORT_TABLEm BCM56504_A0_IPORT_TABLEm
#define IPORT_TABLEm_MIN BCM56504_A0_IPORT_TABLEm_MIN
#define IPORT_TABLEm_MAX BCM56504_A0_IPORT_TABLEm_MAX
#define IPORT_TABLEm_CMAX(u) BCM56504_A0_IPORT_TABLEm_CMAX(u)
#define IPORT_TABLEm_SIZE BCM56504_A0_IPORT_TABLEm_SIZE
typedef BCM56504_A0_IPORT_TABLEm_t IPORT_TABLEm_t;
#define IPORT_TABLEm_CLR BCM56504_A0_IPORT_TABLEm_CLR
#define IPORT_TABLEm_SET BCM56504_A0_IPORT_TABLEm_SET
#define IPORT_TABLEm_GET BCM56504_A0_IPORT_TABLEm_GET
#define IPORT_TABLEm_FILTER_ENABLEf_GET BCM56504_A0_IPORT_TABLEm_FILTER_ENABLEf_GET
#define IPORT_TABLEm_FILTER_ENABLEf_SET BCM56504_A0_IPORT_TABLEm_FILTER_ENABLEf_SET
#define IPORT_TABLEm_VT_MISS_DROPf_GET BCM56504_A0_IPORT_TABLEm_VT_MISS_DROPf_GET
#define IPORT_TABLEm_VT_MISS_DROPf_SET BCM56504_A0_IPORT_TABLEm_VT_MISS_DROPf_SET
#define IPORT_TABLEm_VT_ENABLEf_GET BCM56504_A0_IPORT_TABLEm_VT_ENABLEf_GET
#define IPORT_TABLEm_VT_ENABLEf_SET BCM56504_A0_IPORT_TABLEm_VT_ENABLEf_SET
#define IPORT_TABLEm_TRUST_DSCP_V4f_GET BCM56504_A0_IPORT_TABLEm_TRUST_DSCP_V4f_GET
#define IPORT_TABLEm_TRUST_DSCP_V4f_SET BCM56504_A0_IPORT_TABLEm_TRUST_DSCP_V4f_SET
#define IPORT_TABLEm_TRUST_DSCP_V6f_GET BCM56504_A0_IPORT_TABLEm_TRUST_DSCP_V6f_GET
#define IPORT_TABLEm_TRUST_DSCP_V6f_SET BCM56504_A0_IPORT_TABLEm_TRUST_DSCP_V6f_SET
#define IPORT_TABLEm_EN_IFILTERf_GET BCM56504_A0_IPORT_TABLEm_EN_IFILTERf_GET
#define IPORT_TABLEm_EN_IFILTERf_SET BCM56504_A0_IPORT_TABLEm_EN_IFILTERf_SET
#define IPORT_TABLEm_MIRRORf_GET BCM56504_A0_IPORT_TABLEm_MIRRORf_GET
#define IPORT_TABLEm_MIRRORf_SET BCM56504_A0_IPORT_TABLEm_MIRRORf_SET
#define IPORT_TABLEm_CMLf_GET BCM56504_A0_IPORT_TABLEm_CMLf_GET
#define IPORT_TABLEm_CMLf_SET BCM56504_A0_IPORT_TABLEm_CMLf_SET
#define IPORT_TABLEm_PORT_PRIf_GET BCM56504_A0_IPORT_TABLEm_PORT_PRIf_GET
#define IPORT_TABLEm_PORT_PRIf_SET BCM56504_A0_IPORT_TABLEm_PORT_PRIf_SET
#define IPORT_TABLEm_IPMC_DO_VLANf_GET BCM56504_A0_IPORT_TABLEm_IPMC_DO_VLANf_GET
#define IPORT_TABLEm_IPMC_DO_VLANf_SET BCM56504_A0_IPORT_TABLEm_IPMC_DO_VLANf_SET
#define IPORT_TABLEm_V6IPMC_ENABLEf_GET BCM56504_A0_IPORT_TABLEm_V6IPMC_ENABLEf_GET
#define IPORT_TABLEm_V6IPMC_ENABLEf_SET BCM56504_A0_IPORT_TABLEm_V6IPMC_ENABLEf_SET
#define IPORT_TABLEm_V4IPMC_ENABLEf_GET BCM56504_A0_IPORT_TABLEm_V4IPMC_ENABLEf_GET
#define IPORT_TABLEm_V4IPMC_ENABLEf_SET BCM56504_A0_IPORT_TABLEm_V4IPMC_ENABLEf_SET
#define IPORT_TABLEm_V6L3_ENABLEf_GET BCM56504_A0_IPORT_TABLEm_V6L3_ENABLEf_GET
#define IPORT_TABLEm_V6L3_ENABLEf_SET BCM56504_A0_IPORT_TABLEm_V6L3_ENABLEf_SET
#define IPORT_TABLEm_V4L3_ENABLEf_GET BCM56504_A0_IPORT_TABLEm_V4L3_ENABLEf_GET
#define IPORT_TABLEm_V4L3_ENABLEf_SET BCM56504_A0_IPORT_TABLEm_V4L3_ENABLEf_SET
#define IPORT_TABLEm_DROP_BPDUf_GET BCM56504_A0_IPORT_TABLEm_DROP_BPDUf_GET
#define IPORT_TABLEm_DROP_BPDUf_SET BCM56504_A0_IPORT_TABLEm_DROP_BPDUf_SET
#define IPORT_TABLEm_PORT_DIS_TAGf_GET BCM56504_A0_IPORT_TABLEm_PORT_DIS_TAGf_GET
#define IPORT_TABLEm_PORT_DIS_TAGf_SET BCM56504_A0_IPORT_TABLEm_PORT_DIS_TAGf_SET
#define IPORT_TABLEm_PORT_DIS_UNTAGf_GET BCM56504_A0_IPORT_TABLEm_PORT_DIS_UNTAGf_GET
#define IPORT_TABLEm_PORT_DIS_UNTAGf_SET BCM56504_A0_IPORT_TABLEm_PORT_DIS_UNTAGf_SET
#define IPORT_TABLEm_PASS_CONTROL_FRAMESf_GET BCM56504_A0_IPORT_TABLEm_PASS_CONTROL_FRAMESf_GET
#define IPORT_TABLEm_PASS_CONTROL_FRAMESf_SET BCM56504_A0_IPORT_TABLEm_PASS_CONTROL_FRAMESf_SET
#define IPORT_TABLEm_SUBNET_BASED_VID_ENABLEf_GET BCM56504_A0_IPORT_TABLEm_SUBNET_BASED_VID_ENABLEf_GET
#define IPORT_TABLEm_SUBNET_BASED_VID_ENABLEf_SET BCM56504_A0_IPORT_TABLEm_SUBNET_BASED_VID_ENABLEf_SET
#define IPORT_TABLEm_MAC_BASED_VID_ENABLEf_GET BCM56504_A0_IPORT_TABLEm_MAC_BASED_VID_ENABLEf_GET
#define IPORT_TABLEm_MAC_BASED_VID_ENABLEf_SET BCM56504_A0_IPORT_TABLEm_MAC_BASED_VID_ENABLEf_SET
#define IPORT_TABLEm_PORT_VIDf_GET BCM56504_A0_IPORT_TABLEm_PORT_VIDf_GET
#define IPORT_TABLEm_PORT_VIDf_SET BCM56504_A0_IPORT_TABLEm_PORT_VIDf_SET
#define IPORT_TABLEm_HIGIG_PACKETf_GET BCM56504_A0_IPORT_TABLEm_HIGIG_PACKETf_GET
#define IPORT_TABLEm_HIGIG_PACKETf_SET BCM56504_A0_IPORT_TABLEm_HIGIG_PACKETf_SET
#define IPORT_TABLEm_NNI_PORTf_GET BCM56504_A0_IPORT_TABLEm_NNI_PORTf_GET
#define IPORT_TABLEm_NNI_PORTf_SET BCM56504_A0_IPORT_TABLEm_NNI_PORTf_SET
#define IPORT_TABLEm_MAP_TAG_PKT_PRIORITYf_GET BCM56504_A0_IPORT_TABLEm_MAP_TAG_PKT_PRIORITYf_GET
#define IPORT_TABLEm_MAP_TAG_PKT_PRIORITYf_SET BCM56504_A0_IPORT_TABLEm_MAP_TAG_PKT_PRIORITYf_SET
#define IPORT_TABLEm_MY_MODIDf_GET BCM56504_A0_IPORT_TABLEm_MY_MODIDf_GET
#define IPORT_TABLEm_MY_MODIDf_SET BCM56504_A0_IPORT_TABLEm_MY_MODIDf_SET
#define IPORT_TABLEm_OUTER_TPIDf_GET BCM56504_A0_IPORT_TABLEm_OUTER_TPIDf_GET
#define IPORT_TABLEm_OUTER_TPIDf_SET BCM56504_A0_IPORT_TABLEm_OUTER_TPIDf_SET
#define IPORT_TABLEm_VLAN_PRECEDENCEf_GET BCM56504_A0_IPORT_TABLEm_VLAN_PRECEDENCEf_GET
#define IPORT_TABLEm_VLAN_PRECEDENCEf_SET BCM56504_A0_IPORT_TABLEm_VLAN_PRECEDENCEf_SET
#define IPORT_TABLEm_PORT_BRIDGEf_GET BCM56504_A0_IPORT_TABLEm_PORT_BRIDGEf_GET
#define IPORT_TABLEm_PORT_BRIDGEf_SET BCM56504_A0_IPORT_TABLEm_PORT_BRIDGEf_SET
#define IPORT_TABLEm_IGNORE_IPMC_L2_BITMAPf_GET BCM56504_A0_IPORT_TABLEm_IGNORE_IPMC_L2_BITMAPf_GET
#define IPORT_TABLEm_IGNORE_IPMC_L2_BITMAPf_SET BCM56504_A0_IPORT_TABLEm_IGNORE_IPMC_L2_BITMAPf_SET
#define IPORT_TABLEm_IGNORE_IPMC_L3_BITMAPf_GET BCM56504_A0_IPORT_TABLEm_IGNORE_IPMC_L3_BITMAPf_GET
#define IPORT_TABLEm_IGNORE_IPMC_L3_BITMAPf_SET BCM56504_A0_IPORT_TABLEm_IGNORE_IPMC_L3_BITMAPf_SET
#define IPORT_TABLEm_RESERVEDf_GET BCM56504_A0_IPORT_TABLEm_RESERVEDf_GET
#define IPORT_TABLEm_RESERVEDf_SET BCM56504_A0_IPORT_TABLEm_RESERVEDf_SET
#define READ_IPORT_TABLEm BCM56504_A0_READ_IPORT_TABLEm
#define WRITE_IPORT_TABLEm BCM56504_A0_WRITE_IPORT_TABLEm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_IPORT_TABLEm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  IR1023
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Receive 512-1023 byte packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56504_A0_IR1023r 0x00f0002a

#define BCM56504_A0_IR1023r_SIZE 8

/*
 * This structure should be used to declare and program IR1023.
 *
 */
typedef union BCM56504_A0_IR1023r_s {
	uint32_t v[2];
	uint32_t ir1023[2];
	uint32_t _ir1023;
} BCM56504_A0_IR1023r_t;

#define BCM56504_A0_IR1023r_CLR(r) CDK_MEMSET(&((r)._ir1023), 0, sizeof(BCM56504_A0_IR1023r_t))
#define BCM56504_A0_IR1023r_SET(r,i,d) (r).ir1023[i] = d
#define BCM56504_A0_IR1023r_GET(r,i) (r).ir1023[i]


/*
 * These macros can be used to access IR1023.
 *
 */
#define BCM56504_A0_READ_IR1023r(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_IR1023r,(r._ir1023))
#define BCM56504_A0_WRITE_IR1023r(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_IR1023r,&(r._ir1023))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IR1023r BCM56504_A0_IR1023r
#define IR1023r_SIZE BCM56504_A0_IR1023r_SIZE
typedef BCM56504_A0_IR1023r_t IR1023r_t;
#define IR1023r_CLR BCM56504_A0_IR1023r_CLR
#define IR1023r_SET BCM56504_A0_IR1023r_SET
#define IR1023r_GET BCM56504_A0_IR1023r_GET
#define READ_IR1023r BCM56504_A0_READ_IR1023r
#define WRITE_IR1023r BCM56504_A0_WRITE_IR1023r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_IR1023r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  IR127
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Receive 65-127 byte packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56504_A0_IR127r 0x00f00027

#define BCM56504_A0_IR127r_SIZE 8

/*
 * This structure should be used to declare and program IR127.
 *
 */
typedef union BCM56504_A0_IR127r_s {
	uint32_t v[2];
	uint32_t ir127[2];
	uint32_t _ir127;
} BCM56504_A0_IR127r_t;

#define BCM56504_A0_IR127r_CLR(r) CDK_MEMSET(&((r)._ir127), 0, sizeof(BCM56504_A0_IR127r_t))
#define BCM56504_A0_IR127r_SET(r,i,d) (r).ir127[i] = d
#define BCM56504_A0_IR127r_GET(r,i) (r).ir127[i]


/*
 * These macros can be used to access IR127.
 *
 */
#define BCM56504_A0_READ_IR127r(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_IR127r,(r._ir127))
#define BCM56504_A0_WRITE_IR127r(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_IR127r,&(r._ir127))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IR127r BCM56504_A0_IR127r
#define IR127r_SIZE BCM56504_A0_IR127r_SIZE
typedef BCM56504_A0_IR127r_t IR127r_t;
#define IR127r_CLR BCM56504_A0_IR127r_CLR
#define IR127r_SET BCM56504_A0_IR127r_SET
#define IR127r_GET BCM56504_A0_IR127r_GET
#define READ_IR127r BCM56504_A0_READ_IR127r
#define WRITE_IR127r BCM56504_A0_WRITE_IR127r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_IR127r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  IR1518
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Receive 1024-1518 byte packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56504_A0_IR1518r 0x00f0002b

#define BCM56504_A0_IR1518r_SIZE 8

/*
 * This structure should be used to declare and program IR1518.
 *
 */
typedef union BCM56504_A0_IR1518r_s {
	uint32_t v[2];
	uint32_t ir1518[2];
	uint32_t _ir1518;
} BCM56504_A0_IR1518r_t;

#define BCM56504_A0_IR1518r_CLR(r) CDK_MEMSET(&((r)._ir1518), 0, sizeof(BCM56504_A0_IR1518r_t))
#define BCM56504_A0_IR1518r_SET(r,i,d) (r).ir1518[i] = d
#define BCM56504_A0_IR1518r_GET(r,i) (r).ir1518[i]


/*
 * These macros can be used to access IR1518.
 *
 */
#define BCM56504_A0_READ_IR1518r(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_IR1518r,(r._ir1518))
#define BCM56504_A0_WRITE_IR1518r(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_IR1518r,&(r._ir1518))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IR1518r BCM56504_A0_IR1518r
#define IR1518r_SIZE BCM56504_A0_IR1518r_SIZE
typedef BCM56504_A0_IR1518r_t IR1518r_t;
#define IR1518r_CLR BCM56504_A0_IR1518r_CLR
#define IR1518r_SET BCM56504_A0_IR1518r_SET
#define IR1518r_GET BCM56504_A0_IR1518r_GET
#define READ_IR1518r BCM56504_A0_READ_IR1518r
#define WRITE_IR1518r BCM56504_A0_WRITE_IR1518r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_IR1518r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  IR16383
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Receive 9217-16383 byte packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56504_A0_IR16383r 0x00f0002f

#define BCM56504_A0_IR16383r_SIZE 8

/*
 * This structure should be used to declare and program IR16383.
 *
 */
typedef union BCM56504_A0_IR16383r_s {
	uint32_t v[2];
	uint32_t ir16383[2];
	uint32_t _ir16383;
} BCM56504_A0_IR16383r_t;

#define BCM56504_A0_IR16383r_CLR(r) CDK_MEMSET(&((r)._ir16383), 0, sizeof(BCM56504_A0_IR16383r_t))
#define BCM56504_A0_IR16383r_SET(r,i,d) (r).ir16383[i] = d
#define BCM56504_A0_IR16383r_GET(r,i) (r).ir16383[i]


/*
 * These macros can be used to access IR16383.
 *
 */
#define BCM56504_A0_READ_IR16383r(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_IR16383r,(r._ir16383))
#define BCM56504_A0_WRITE_IR16383r(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_IR16383r,&(r._ir16383))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IR16383r BCM56504_A0_IR16383r
#define IR16383r_SIZE BCM56504_A0_IR16383r_SIZE
typedef BCM56504_A0_IR16383r_t IR16383r_t;
#define IR16383r_CLR BCM56504_A0_IR16383r_CLR
#define IR16383r_SET BCM56504_A0_IR16383r_SET
#define IR16383r_GET BCM56504_A0_IR16383r_GET
#define READ_IR16383r BCM56504_A0_READ_IR16383r
#define WRITE_IR16383r BCM56504_A0_WRITE_IR16383r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_IR16383r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  IR2047
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Receive 1519-2047 byte packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56504_A0_IR2047r 0x00f0002c

#define BCM56504_A0_IR2047r_SIZE 8

/*
 * This structure should be used to declare and program IR2047.
 *
 */
typedef union BCM56504_A0_IR2047r_s {
	uint32_t v[2];
	uint32_t ir2047[2];
	uint32_t _ir2047;
} BCM56504_A0_IR2047r_t;

#define BCM56504_A0_IR2047r_CLR(r) CDK_MEMSET(&((r)._ir2047), 0, sizeof(BCM56504_A0_IR2047r_t))
#define BCM56504_A0_IR2047r_SET(r,i,d) (r).ir2047[i] = d
#define BCM56504_A0_IR2047r_GET(r,i) (r).ir2047[i]


/*
 * These macros can be used to access IR2047.
 *
 */
#define BCM56504_A0_READ_IR2047r(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_IR2047r,(r._ir2047))
#define BCM56504_A0_WRITE_IR2047r(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_IR2047r,&(r._ir2047))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IR2047r BCM56504_A0_IR2047r
#define IR2047r_SIZE BCM56504_A0_IR2047r_SIZE
typedef BCM56504_A0_IR2047r_t IR2047r_t;
#define IR2047r_CLR BCM56504_A0_IR2047r_CLR
#define IR2047r_SET BCM56504_A0_IR2047r_SET
#define IR2047r_GET BCM56504_A0_IR2047r_GET
#define READ_IR2047r BCM56504_A0_READ_IR2047r
#define WRITE_IR2047r BCM56504_A0_WRITE_IR2047r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_IR2047r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  IR255
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Receive 128-255 byte packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56504_A0_IR255r 0x00f00028

#define BCM56504_A0_IR255r_SIZE 8

/*
 * This structure should be used to declare and program IR255.
 *
 */
typedef union BCM56504_A0_IR255r_s {
	uint32_t v[2];
	uint32_t ir255[2];
	uint32_t _ir255;
} BCM56504_A0_IR255r_t;

#define BCM56504_A0_IR255r_CLR(r) CDK_MEMSET(&((r)._ir255), 0, sizeof(BCM56504_A0_IR255r_t))
#define BCM56504_A0_IR255r_SET(r,i,d) (r).ir255[i] = d
#define BCM56504_A0_IR255r_GET(r,i) (r).ir255[i]


/*
 * These macros can be used to access IR255.
 *
 */
#define BCM56504_A0_READ_IR255r(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_IR255r,(r._ir255))
#define BCM56504_A0_WRITE_IR255r(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_IR255r,&(r._ir255))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IR255r BCM56504_A0_IR255r
#define IR255r_SIZE BCM56504_A0_IR255r_SIZE
typedef BCM56504_A0_IR255r_t IR255r_t;
#define IR255r_CLR BCM56504_A0_IR255r_CLR
#define IR255r_SET BCM56504_A0_IR255r_SET
#define IR255r_GET BCM56504_A0_IR255r_GET
#define READ_IR255r BCM56504_A0_READ_IR255r
#define WRITE_IR255r BCM56504_A0_WRITE_IR255r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_IR255r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  IR4095
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Receive 2048-4095 byte packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56504_A0_IR4095r 0x00f0002d

#define BCM56504_A0_IR4095r_SIZE 8

/*
 * This structure should be used to declare and program IR4095.
 *
 */
typedef union BCM56504_A0_IR4095r_s {
	uint32_t v[2];
	uint32_t ir4095[2];
	uint32_t _ir4095;
} BCM56504_A0_IR4095r_t;

#define BCM56504_A0_IR4095r_CLR(r) CDK_MEMSET(&((r)._ir4095), 0, sizeof(BCM56504_A0_IR4095r_t))
#define BCM56504_A0_IR4095r_SET(r,i,d) (r).ir4095[i] = d
#define BCM56504_A0_IR4095r_GET(r,i) (r).ir4095[i]


/*
 * These macros can be used to access IR4095.
 *
 */
#define BCM56504_A0_READ_IR4095r(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_IR4095r,(r._ir4095))
#define BCM56504_A0_WRITE_IR4095r(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_IR4095r,&(r._ir4095))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IR4095r BCM56504_A0_IR4095r
#define IR4095r_SIZE BCM56504_A0_IR4095r_SIZE
typedef BCM56504_A0_IR4095r_t IR4095r_t;
#define IR4095r_CLR BCM56504_A0_IR4095r_CLR
#define IR4095r_SET BCM56504_A0_IR4095r_SET
#define IR4095r_GET BCM56504_A0_IR4095r_GET
#define READ_IR4095r BCM56504_A0_READ_IR4095r
#define WRITE_IR4095r BCM56504_A0_WRITE_IR4095r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_IR4095r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  IR511
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Receive 256-511 byte packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56504_A0_IR511r 0x00f00029

#define BCM56504_A0_IR511r_SIZE 8

/*
 * This structure should be used to declare and program IR511.
 *
 */
typedef union BCM56504_A0_IR511r_s {
	uint32_t v[2];
	uint32_t ir511[2];
	uint32_t _ir511;
} BCM56504_A0_IR511r_t;

#define BCM56504_A0_IR511r_CLR(r) CDK_MEMSET(&((r)._ir511), 0, sizeof(BCM56504_A0_IR511r_t))
#define BCM56504_A0_IR511r_SET(r,i,d) (r).ir511[i] = d
#define BCM56504_A0_IR511r_GET(r,i) (r).ir511[i]


/*
 * These macros can be used to access IR511.
 *
 */
#define BCM56504_A0_READ_IR511r(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_IR511r,(r._ir511))
#define BCM56504_A0_WRITE_IR511r(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_IR511r,&(r._ir511))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IR511r BCM56504_A0_IR511r
#define IR511r_SIZE BCM56504_A0_IR511r_SIZE
typedef BCM56504_A0_IR511r_t IR511r_t;
#define IR511r_CLR BCM56504_A0_IR511r_CLR
#define IR511r_SET BCM56504_A0_IR511r_SET
#define IR511r_GET BCM56504_A0_IR511r_GET
#define READ_IR511r BCM56504_A0_READ_IR511r
#define WRITE_IR511r BCM56504_A0_WRITE_IR511r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_IR511r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  IR64
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Receive 64 byte packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56504_A0_IR64r 0x00f00026

#define BCM56504_A0_IR64r_SIZE 8

/*
 * This structure should be used to declare and program IR64.
 *
 */
typedef union BCM56504_A0_IR64r_s {
	uint32_t v[2];
	uint32_t ir64[2];
	uint32_t _ir64;
} BCM56504_A0_IR64r_t;

#define BCM56504_A0_IR64r_CLR(r) CDK_MEMSET(&((r)._ir64), 0, sizeof(BCM56504_A0_IR64r_t))
#define BCM56504_A0_IR64r_SET(r,i,d) (r).ir64[i] = d
#define BCM56504_A0_IR64r_GET(r,i) (r).ir64[i]


/*
 * These macros can be used to access IR64.
 *
 */
#define BCM56504_A0_READ_IR64r(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_IR64r,(r._ir64))
#define BCM56504_A0_WRITE_IR64r(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_IR64r,&(r._ir64))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IR64r BCM56504_A0_IR64r
#define IR64r_SIZE BCM56504_A0_IR64r_SIZE
typedef BCM56504_A0_IR64r_t IR64r_t;
#define IR64r_CLR BCM56504_A0_IR64r_CLR
#define IR64r_SET BCM56504_A0_IR64r_SET
#define IR64r_GET BCM56504_A0_IR64r_GET
#define READ_IR64r BCM56504_A0_READ_IR64r
#define WRITE_IR64r BCM56504_A0_WRITE_IR64r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_IR64r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  IR9216
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Receive 4096-9216 byte packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56504_A0_IR9216r 0x00f0002e

#define BCM56504_A0_IR9216r_SIZE 8

/*
 * This structure should be used to declare and program IR9216.
 *
 */
typedef union BCM56504_A0_IR9216r_s {
	uint32_t v[2];
	uint32_t ir9216[2];
	uint32_t _ir9216;
} BCM56504_A0_IR9216r_t;

#define BCM56504_A0_IR9216r_CLR(r) CDK_MEMSET(&((r)._ir9216), 0, sizeof(BCM56504_A0_IR9216r_t))
#define BCM56504_A0_IR9216r_SET(r,i,d) (r).ir9216[i] = d
#define BCM56504_A0_IR9216r_GET(r,i) (r).ir9216[i]


/*
 * These macros can be used to access IR9216.
 *
 */
#define BCM56504_A0_READ_IR9216r(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_IR9216r,(r._ir9216))
#define BCM56504_A0_WRITE_IR9216r(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_IR9216r,&(r._ir9216))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IR9216r BCM56504_A0_IR9216r
#define IR9216r_SIZE BCM56504_A0_IR9216r_SIZE
typedef BCM56504_A0_IR9216r_t IR9216r_t;
#define IR9216r_CLR BCM56504_A0_IR9216r_CLR
#define IR9216r_SET BCM56504_A0_IR9216r_SET
#define IR9216r_GET BCM56504_A0_IR9216r_GET
#define READ_IR9216r BCM56504_A0_READ_IR9216r
#define WRITE_IR9216r BCM56504_A0_WRITE_IR9216r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_IR9216r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  IRBCA
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Receive broadcast packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56504_A0_IRBCAr 0x00f00034

#define BCM56504_A0_IRBCAr_SIZE 8

/*
 * This structure should be used to declare and program IRBCA.
 *
 */
typedef union BCM56504_A0_IRBCAr_s {
	uint32_t v[2];
	uint32_t irbca[2];
	uint32_t _irbca;
} BCM56504_A0_IRBCAr_t;

#define BCM56504_A0_IRBCAr_CLR(r) CDK_MEMSET(&((r)._irbca), 0, sizeof(BCM56504_A0_IRBCAr_t))
#define BCM56504_A0_IRBCAr_SET(r,i,d) (r).irbca[i] = d
#define BCM56504_A0_IRBCAr_GET(r,i) (r).irbca[i]


/*
 * These macros can be used to access IRBCA.
 *
 */
#define BCM56504_A0_READ_IRBCAr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_IRBCAr,(r._irbca))
#define BCM56504_A0_WRITE_IRBCAr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_IRBCAr,&(r._irbca))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IRBCAr BCM56504_A0_IRBCAr
#define IRBCAr_SIZE BCM56504_A0_IRBCAr_SIZE
typedef BCM56504_A0_IRBCAr_t IRBCAr_t;
#define IRBCAr_CLR BCM56504_A0_IRBCAr_CLR
#define IRBCAr_SET BCM56504_A0_IRBCAr_SET
#define IRBCAr_GET BCM56504_A0_IRBCAr_GET
#define READ_IRBCAr BCM56504_A0_READ_IRBCAr
#define WRITE_IRBCAr BCM56504_A0_WRITE_IRBCAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_IRBCAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  IRBYT
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Receive byte counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56504_A0_IRBYTr 0x00f0003d

#define BCM56504_A0_IRBYTr_SIZE 8

/*
 * This structure should be used to declare and program IRBYT.
 *
 */
typedef union BCM56504_A0_IRBYTr_s {
	uint32_t v[2];
	uint32_t irbyt[2];
	uint32_t _irbyt;
} BCM56504_A0_IRBYTr_t;

#define BCM56504_A0_IRBYTr_CLR(r) CDK_MEMSET(&((r)._irbyt), 0, sizeof(BCM56504_A0_IRBYTr_t))
#define BCM56504_A0_IRBYTr_SET(r,i,d) (r).irbyt[i] = d
#define BCM56504_A0_IRBYTr_GET(r,i) (r).irbyt[i]


/*
 * These macros can be used to access IRBYT.
 *
 */
#define BCM56504_A0_READ_IRBYTr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_IRBYTr,(r._irbyt))
#define BCM56504_A0_WRITE_IRBYTr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_IRBYTr,&(r._irbyt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IRBYTr BCM56504_A0_IRBYTr
#define IRBYTr_SIZE BCM56504_A0_IRBYTr_SIZE
typedef BCM56504_A0_IRBYTr_t IRBYTr_t;
#define IRBYTr_CLR BCM56504_A0_IRBYTr_CLR
#define IRBYTr_SET BCM56504_A0_IRBYTr_SET
#define IRBYTr_GET BCM56504_A0_IRBYTr_GET
#define READ_IRBYTr BCM56504_A0_READ_IRBYTr
#define WRITE_IRBYTr BCM56504_A0_WRITE_IRBYTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_IRBYTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  IRERBYT
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Receive error byte counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56504_A0_IRERBYTr 0x00f00040

#define BCM56504_A0_IRERBYTr_SIZE 8

/*
 * This structure should be used to declare and program IRERBYT.
 *
 */
typedef union BCM56504_A0_IRERBYTr_s {
	uint32_t v[2];
	uint32_t irerbyt[2];
	uint32_t _irerbyt;
} BCM56504_A0_IRERBYTr_t;

#define BCM56504_A0_IRERBYTr_CLR(r) CDK_MEMSET(&((r)._irerbyt), 0, sizeof(BCM56504_A0_IRERBYTr_t))
#define BCM56504_A0_IRERBYTr_SET(r,i,d) (r).irerbyt[i] = d
#define BCM56504_A0_IRERBYTr_GET(r,i) (r).irerbyt[i]


/*
 * These macros can be used to access IRERBYT.
 *
 */
#define BCM56504_A0_READ_IRERBYTr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_IRERBYTr,(r._irerbyt))
#define BCM56504_A0_WRITE_IRERBYTr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_IRERBYTr,&(r._irerbyt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IRERBYTr BCM56504_A0_IRERBYTr
#define IRERBYTr_SIZE BCM56504_A0_IRERBYTr_SIZE
typedef BCM56504_A0_IRERBYTr_t IRERBYTr_t;
#define IRERBYTr_CLR BCM56504_A0_IRERBYTr_CLR
#define IRERBYTr_SET BCM56504_A0_IRERBYTr_SET
#define IRERBYTr_GET BCM56504_A0_IRERBYTr_GET
#define READ_IRERBYTr BCM56504_A0_READ_IRERBYTr
#define WRITE_IRERBYTr BCM56504_A0_WRITE_IRERBYTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_IRERBYTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  IRERPKT
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Received framing error counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56504_A0_IRERPKTr 0x00f00041

#define BCM56504_A0_IRERPKTr_SIZE 8

/*
 * This structure should be used to declare and program IRERPKT.
 *
 */
typedef union BCM56504_A0_IRERPKTr_s {
	uint32_t v[2];
	uint32_t irerpkt[2];
	uint32_t _irerpkt;
} BCM56504_A0_IRERPKTr_t;

#define BCM56504_A0_IRERPKTr_CLR(r) CDK_MEMSET(&((r)._irerpkt), 0, sizeof(BCM56504_A0_IRERPKTr_t))
#define BCM56504_A0_IRERPKTr_SET(r,i,d) (r).irerpkt[i] = d
#define BCM56504_A0_IRERPKTr_GET(r,i) (r).irerpkt[i]


/*
 * These macros can be used to access IRERPKT.
 *
 */
#define BCM56504_A0_READ_IRERPKTr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_IRERPKTr,(r._irerpkt))
#define BCM56504_A0_WRITE_IRERPKTr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_IRERPKTr,&(r._irerpkt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IRERPKTr BCM56504_A0_IRERPKTr
#define IRERPKTr_SIZE BCM56504_A0_IRERPKTr_SIZE
typedef BCM56504_A0_IRERPKTr_t IRERPKTr_t;
#define IRERPKTr_CLR BCM56504_A0_IRERPKTr_CLR
#define IRERPKTr_SET BCM56504_A0_IRERPKTr_SET
#define IRERPKTr_GET BCM56504_A0_IRERPKTr_GET
#define READ_IRERPKTr BCM56504_A0_READ_IRERPKTr
#define WRITE_IRERPKTr BCM56504_A0_WRITE_IRERPKTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_IRERPKTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  IRFCS
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Receive FCS(CRC) error packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56504_A0_IRFCSr 0x00f00032

#define BCM56504_A0_IRFCSr_SIZE 8

/*
 * This structure should be used to declare and program IRFCS.
 *
 */
typedef union BCM56504_A0_IRFCSr_s {
	uint32_t v[2];
	uint32_t irfcs[2];
	uint32_t _irfcs;
} BCM56504_A0_IRFCSr_t;

#define BCM56504_A0_IRFCSr_CLR(r) CDK_MEMSET(&((r)._irfcs), 0, sizeof(BCM56504_A0_IRFCSr_t))
#define BCM56504_A0_IRFCSr_SET(r,i,d) (r).irfcs[i] = d
#define BCM56504_A0_IRFCSr_GET(r,i) (r).irfcs[i]


/*
 * These macros can be used to access IRFCS.
 *
 */
#define BCM56504_A0_READ_IRFCSr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_IRFCSr,(r._irfcs))
#define BCM56504_A0_WRITE_IRFCSr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_IRFCSr,&(r._irfcs))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IRFCSr BCM56504_A0_IRFCSr
#define IRFCSr_SIZE BCM56504_A0_IRFCSr_SIZE
typedef BCM56504_A0_IRFCSr_t IRFCSr_t;
#define IRFCSr_CLR BCM56504_A0_IRFCSr_CLR
#define IRFCSr_SET BCM56504_A0_IRFCSr_SET
#define IRFCSr_GET BCM56504_A0_IRFCSr_GET
#define READ_IRFCSr BCM56504_A0_READ_IRFCSr
#define WRITE_IRFCSr BCM56504_A0_WRITE_IRFCSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_IRFCSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  IRFLR
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Receive length out-of-range packet counter.


 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56504_A0_IRFLRr 0x00f0003a

#define BCM56504_A0_IRFLRr_SIZE 8

/*
 * This structure should be used to declare and program IRFLR.
 *
 */
typedef union BCM56504_A0_IRFLRr_s {
	uint32_t v[2];
	uint32_t irflr[2];
	uint32_t _irflr;
} BCM56504_A0_IRFLRr_t;

#define BCM56504_A0_IRFLRr_CLR(r) CDK_MEMSET(&((r)._irflr), 0, sizeof(BCM56504_A0_IRFLRr_t))
#define BCM56504_A0_IRFLRr_SET(r,i,d) (r).irflr[i] = d
#define BCM56504_A0_IRFLRr_GET(r,i) (r).irflr[i]


/*
 * These macros can be used to access IRFLR.
 *
 */
#define BCM56504_A0_READ_IRFLRr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_IRFLRr,(r._irflr))
#define BCM56504_A0_WRITE_IRFLRr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_IRFLRr,&(r._irflr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IRFLRr BCM56504_A0_IRFLRr
#define IRFLRr_SIZE BCM56504_A0_IRFLRr_SIZE
typedef BCM56504_A0_IRFLRr_t IRFLRr_t;
#define IRFLRr_CLR BCM56504_A0_IRFLRr_CLR
#define IRFLRr_SET BCM56504_A0_IRFLRr_SET
#define IRFLRr_GET BCM56504_A0_IRFLRr_GET
#define READ_IRFLRr BCM56504_A0_READ_IRFLRr
#define WRITE_IRFLRr BCM56504_A0_WRITE_IRFLRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_IRFLRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  IRFRG
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Receive fragment counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56504_A0_IRFRGr 0x00f0003f

#define BCM56504_A0_IRFRGr_SIZE 8

/*
 * This structure should be used to declare and program IRFRG.
 *
 */
typedef union BCM56504_A0_IRFRGr_s {
	uint32_t v[2];
	uint32_t irfrg[2];
	uint32_t _irfrg;
} BCM56504_A0_IRFRGr_t;

#define BCM56504_A0_IRFRGr_CLR(r) CDK_MEMSET(&((r)._irfrg), 0, sizeof(BCM56504_A0_IRFRGr_t))
#define BCM56504_A0_IRFRGr_SET(r,i,d) (r).irfrg[i] = d
#define BCM56504_A0_IRFRGr_GET(r,i) (r).irfrg[i]


/*
 * These macros can be used to access IRFRG.
 *
 */
#define BCM56504_A0_READ_IRFRGr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_IRFRGr,(r._irfrg))
#define BCM56504_A0_WRITE_IRFRGr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_IRFRGr,&(r._irfrg))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IRFRGr BCM56504_A0_IRFRGr
#define IRFRGr_SIZE BCM56504_A0_IRFRGr_SIZE
typedef BCM56504_A0_IRFRGr_t IRFRGr_t;
#define IRFRGr_CLR BCM56504_A0_IRFRGr_CLR
#define IRFRGr_SET BCM56504_A0_IRFRGr_SET
#define IRFRGr_GET BCM56504_A0_IRFRGr_GET
#define READ_IRFRGr BCM56504_A0_READ_IRFRGr
#define WRITE_IRFRGr BCM56504_A0_WRITE_IRFRGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_IRFRGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  IRJBR
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Receive jabber packer counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56504_A0_IRJBRr 0x00f00038

#define BCM56504_A0_IRJBRr_SIZE 8

/*
 * This structure should be used to declare and program IRJBR.
 *
 */
typedef union BCM56504_A0_IRJBRr_s {
	uint32_t v[2];
	uint32_t irjbr[2];
	uint32_t _irjbr;
} BCM56504_A0_IRJBRr_t;

#define BCM56504_A0_IRJBRr_CLR(r) CDK_MEMSET(&((r)._irjbr), 0, sizeof(BCM56504_A0_IRJBRr_t))
#define BCM56504_A0_IRJBRr_SET(r,i,d) (r).irjbr[i] = d
#define BCM56504_A0_IRJBRr_GET(r,i) (r).irjbr[i]


/*
 * These macros can be used to access IRJBR.
 *
 */
#define BCM56504_A0_READ_IRJBRr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_IRJBRr,(r._irjbr))
#define BCM56504_A0_WRITE_IRJBRr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_IRJBRr,&(r._irjbr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IRJBRr BCM56504_A0_IRJBRr
#define IRJBRr_SIZE BCM56504_A0_IRJBRr_SIZE
typedef BCM56504_A0_IRJBRr_t IRJBRr_t;
#define IRJBRr_CLR BCM56504_A0_IRJBRr_CLR
#define IRJBRr_SET BCM56504_A0_IRJBRr_SET
#define IRJBRr_GET BCM56504_A0_IRJBRr_GET
#define READ_IRJBRr BCM56504_A0_READ_IRJBRr
#define WRITE_IRJBRr BCM56504_A0_WRITE_IRJBRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_IRJBRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  IRJUNK
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Receive interpacket junk counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56504_A0_IRJUNKr 0x00f00042

#define BCM56504_A0_IRJUNKr_SIZE 8

/*
 * This structure should be used to declare and program IRJUNK.
 *
 */
typedef union BCM56504_A0_IRJUNKr_s {
	uint32_t v[2];
	uint32_t irjunk[2];
	uint32_t _irjunk;
} BCM56504_A0_IRJUNKr_t;

#define BCM56504_A0_IRJUNKr_CLR(r) CDK_MEMSET(&((r)._irjunk), 0, sizeof(BCM56504_A0_IRJUNKr_t))
#define BCM56504_A0_IRJUNKr_SET(r,i,d) (r).irjunk[i] = d
#define BCM56504_A0_IRJUNKr_GET(r,i) (r).irjunk[i]


/*
 * These macros can be used to access IRJUNK.
 *
 */
#define BCM56504_A0_READ_IRJUNKr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_IRJUNKr,(r._irjunk))
#define BCM56504_A0_WRITE_IRJUNKr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_IRJUNKr,&(r._irjunk))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IRJUNKr BCM56504_A0_IRJUNKr
#define IRJUNKr_SIZE BCM56504_A0_IRJUNKr_SIZE
typedef BCM56504_A0_IRJUNKr_t IRJUNKr_t;
#define IRJUNKr_CLR BCM56504_A0_IRJUNKr_CLR
#define IRJUNKr_SET BCM56504_A0_IRJUNKr_SET
#define IRJUNKr_GET BCM56504_A0_IRJUNKr_GET
#define READ_IRJUNKr BCM56504_A0_READ_IRJUNKr
#define WRITE_IRJUNKr BCM56504_A0_WRITE_IRJUNKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_IRJUNKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  IRMAX
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Receive max size packet counter
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56504_A0_IRMAXr 0x00f00030

#define BCM56504_A0_IRMAXr_SIZE 8

/*
 * This structure should be used to declare and program IRMAX.
 *
 */
typedef union BCM56504_A0_IRMAXr_s {
	uint32_t v[2];
	uint32_t irmax[2];
	uint32_t _irmax;
} BCM56504_A0_IRMAXr_t;

#define BCM56504_A0_IRMAXr_CLR(r) CDK_MEMSET(&((r)._irmax), 0, sizeof(BCM56504_A0_IRMAXr_t))
#define BCM56504_A0_IRMAXr_SET(r,i,d) (r).irmax[i] = d
#define BCM56504_A0_IRMAXr_GET(r,i) (r).irmax[i]


/*
 * These macros can be used to access IRMAX.
 *
 */
#define BCM56504_A0_READ_IRMAXr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_IRMAXr,(r._irmax))
#define BCM56504_A0_WRITE_IRMAXr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_IRMAXr,&(r._irmax))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IRMAXr BCM56504_A0_IRMAXr
#define IRMAXr_SIZE BCM56504_A0_IRMAXr_SIZE
typedef BCM56504_A0_IRMAXr_t IRMAXr_t;
#define IRMAXr_CLR BCM56504_A0_IRMAXr_CLR
#define IRMAXr_SET BCM56504_A0_IRMAXr_SET
#define IRMAXr_GET BCM56504_A0_IRMAXr_GET
#define READ_IRMAXr BCM56504_A0_READ_IRMAXr
#define WRITE_IRMAXr BCM56504_A0_WRITE_IRMAXr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_IRMAXr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  IRMCA
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Receive multicast packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56504_A0_IRMCAr 0x00f00033

#define BCM56504_A0_IRMCAr_SIZE 8

/*
 * This structure should be used to declare and program IRMCA.
 *
 */
typedef union BCM56504_A0_IRMCAr_s {
	uint32_t v[2];
	uint32_t irmca[2];
	uint32_t _irmca;
} BCM56504_A0_IRMCAr_t;

#define BCM56504_A0_IRMCAr_CLR(r) CDK_MEMSET(&((r)._irmca), 0, sizeof(BCM56504_A0_IRMCAr_t))
#define BCM56504_A0_IRMCAr_SET(r,i,d) (r).irmca[i] = d
#define BCM56504_A0_IRMCAr_GET(r,i) (r).irmca[i]


/*
 * These macros can be used to access IRMCA.
 *
 */
#define BCM56504_A0_READ_IRMCAr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_IRMCAr,(r._irmca))
#define BCM56504_A0_WRITE_IRMCAr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_IRMCAr,&(r._irmca))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IRMCAr BCM56504_A0_IRMCAr
#define IRMCAr_SIZE BCM56504_A0_IRMCAr_SIZE
typedef BCM56504_A0_IRMCAr_t IRMCAr_t;
#define IRMCAr_CLR BCM56504_A0_IRMCAr_CLR
#define IRMCAr_SET BCM56504_A0_IRMCAr_SET
#define IRMCAr_GET BCM56504_A0_IRMCAr_GET
#define READ_IRMCAr BCM56504_A0_READ_IRMCAr
#define WRITE_IRMCAr BCM56504_A0_WRITE_IRMCAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_IRMCAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  IRMEB
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Receive MTU size check failed bad packet counter.

 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56504_A0_IRMEBr 0x00f0003c

#define BCM56504_A0_IRMEBr_SIZE 8

/*
 * This structure should be used to declare and program IRMEB.
 *
 */
typedef union BCM56504_A0_IRMEBr_s {
	uint32_t v[2];
	uint32_t irmeb[2];
	uint32_t _irmeb;
} BCM56504_A0_IRMEBr_t;

#define BCM56504_A0_IRMEBr_CLR(r) CDK_MEMSET(&((r)._irmeb), 0, sizeof(BCM56504_A0_IRMEBr_t))
#define BCM56504_A0_IRMEBr_SET(r,i,d) (r).irmeb[i] = d
#define BCM56504_A0_IRMEBr_GET(r,i) (r).irmeb[i]


/*
 * These macros can be used to access IRMEB.
 *
 */
#define BCM56504_A0_READ_IRMEBr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_IRMEBr,(r._irmeb))
#define BCM56504_A0_WRITE_IRMEBr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_IRMEBr,&(r._irmeb))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IRMEBr BCM56504_A0_IRMEBr
#define IRMEBr_SIZE BCM56504_A0_IRMEBr_SIZE
typedef BCM56504_A0_IRMEBr_t IRMEBr_t;
#define IRMEBr_CLR BCM56504_A0_IRMEBr_CLR
#define IRMEBr_SET BCM56504_A0_IRMEBr_SET
#define IRMEBr_GET BCM56504_A0_IRMEBr_GET
#define READ_IRMEBr BCM56504_A0_READ_IRMEBr
#define WRITE_IRMEBr BCM56504_A0_WRITE_IRMEBr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_IRMEBr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  IRMEG
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Receive MTU size check failed good packet counter.

 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56504_A0_IRMEGr 0x00f0003b

#define BCM56504_A0_IRMEGr_SIZE 8

/*
 * This structure should be used to declare and program IRMEG.
 *
 */
typedef union BCM56504_A0_IRMEGr_s {
	uint32_t v[2];
	uint32_t irmeg[2];
	uint32_t _irmeg;
} BCM56504_A0_IRMEGr_t;

#define BCM56504_A0_IRMEGr_CLR(r) CDK_MEMSET(&((r)._irmeg), 0, sizeof(BCM56504_A0_IRMEGr_t))
#define BCM56504_A0_IRMEGr_SET(r,i,d) (r).irmeg[i] = d
#define BCM56504_A0_IRMEGr_GET(r,i) (r).irmeg[i]


/*
 * These macros can be used to access IRMEG.
 *
 */
#define BCM56504_A0_READ_IRMEGr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_IRMEGr,(r._irmeg))
#define BCM56504_A0_WRITE_IRMEGr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_IRMEGr,&(r._irmeg))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IRMEGr BCM56504_A0_IRMEGr
#define IRMEGr_SIZE BCM56504_A0_IRMEGr_SIZE
typedef BCM56504_A0_IRMEGr_t IRMEGr_t;
#define IRMEGr_CLR BCM56504_A0_IRMEGr_CLR
#define IRMEGr_SET BCM56504_A0_IRMEGr_SET
#define IRMEGr_GET BCM56504_A0_IRMEGr_GET
#define READ_IRMEGr BCM56504_A0_READ_IRMEGr
#define WRITE_IRMEGr BCM56504_A0_WRITE_IRMEGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_IRMEGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  IROVR
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Receive oversize packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56504_A0_IROVRr 0x00f00039

#define BCM56504_A0_IROVRr_SIZE 8

/*
 * This structure should be used to declare and program IROVR.
 *
 */
typedef union BCM56504_A0_IROVRr_s {
	uint32_t v[2];
	uint32_t irovr[2];
	uint32_t _irovr;
} BCM56504_A0_IROVRr_t;

#define BCM56504_A0_IROVRr_CLR(r) CDK_MEMSET(&((r)._irovr), 0, sizeof(BCM56504_A0_IROVRr_t))
#define BCM56504_A0_IROVRr_SET(r,i,d) (r).irovr[i] = d
#define BCM56504_A0_IROVRr_GET(r,i) (r).irovr[i]


/*
 * These macros can be used to access IROVR.
 *
 */
#define BCM56504_A0_READ_IROVRr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_IROVRr,(r._irovr))
#define BCM56504_A0_WRITE_IROVRr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_IROVRr,&(r._irovr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IROVRr BCM56504_A0_IROVRr
#define IROVRr_SIZE BCM56504_A0_IROVRr_SIZE
typedef BCM56504_A0_IROVRr_t IROVRr_t;
#define IROVRr_CLR BCM56504_A0_IROVRr_CLR
#define IROVRr_SET BCM56504_A0_IROVRr_SET
#define IROVRr_GET BCM56504_A0_IROVRr_GET
#define READ_IROVRr BCM56504_A0_READ_IROVRr
#define WRITE_IROVRr BCM56504_A0_WRITE_IROVRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_IROVRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  IRPKT
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Receive packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56504_A0_IRPKTr 0x00f00031

#define BCM56504_A0_IRPKTr_SIZE 8

/*
 * This structure should be used to declare and program IRPKT.
 *
 */
typedef union BCM56504_A0_IRPKTr_s {
	uint32_t v[2];
	uint32_t irpkt[2];
	uint32_t _irpkt;
} BCM56504_A0_IRPKTr_t;

#define BCM56504_A0_IRPKTr_CLR(r) CDK_MEMSET(&((r)._irpkt), 0, sizeof(BCM56504_A0_IRPKTr_t))
#define BCM56504_A0_IRPKTr_SET(r,i,d) (r).irpkt[i] = d
#define BCM56504_A0_IRPKTr_GET(r,i) (r).irpkt[i]


/*
 * These macros can be used to access IRPKT.
 *
 */
#define BCM56504_A0_READ_IRPKTr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_IRPKTr,(r._irpkt))
#define BCM56504_A0_WRITE_IRPKTr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_IRPKTr,&(r._irpkt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IRPKTr BCM56504_A0_IRPKTr
#define IRPKTr_SIZE BCM56504_A0_IRPKTr_SIZE
typedef BCM56504_A0_IRPKTr_t IRPKTr_t;
#define IRPKTr_CLR BCM56504_A0_IRPKTr_CLR
#define IRPKTr_SET BCM56504_A0_IRPKTr_SET
#define IRPKTr_GET BCM56504_A0_IRPKTr_GET
#define READ_IRPKTr BCM56504_A0_READ_IRPKTr
#define WRITE_IRPKTr BCM56504_A0_WRITE_IRPKTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_IRPKTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  IRUND
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Received undersize packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56504_A0_IRUNDr 0x00f0003e

#define BCM56504_A0_IRUNDr_SIZE 8

/*
 * This structure should be used to declare and program IRUND.
 *
 */
typedef union BCM56504_A0_IRUNDr_s {
	uint32_t v[2];
	uint32_t irund[2];
	uint32_t _irund;
} BCM56504_A0_IRUNDr_t;

#define BCM56504_A0_IRUNDr_CLR(r) CDK_MEMSET(&((r)._irund), 0, sizeof(BCM56504_A0_IRUNDr_t))
#define BCM56504_A0_IRUNDr_SET(r,i,d) (r).irund[i] = d
#define BCM56504_A0_IRUNDr_GET(r,i) (r).irund[i]


/*
 * These macros can be used to access IRUND.
 *
 */
#define BCM56504_A0_READ_IRUNDr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_IRUNDr,(r._irund))
#define BCM56504_A0_WRITE_IRUNDr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_IRUNDr,&(r._irund))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IRUNDr BCM56504_A0_IRUNDr
#define IRUNDr_SIZE BCM56504_A0_IRUNDr_SIZE
typedef BCM56504_A0_IRUNDr_t IRUNDr_t;
#define IRUNDr_CLR BCM56504_A0_IRUNDr_CLR
#define IRUNDr_SET BCM56504_A0_IRUNDr_SET
#define IRUNDr_GET BCM56504_A0_IRUNDr_GET
#define READ_IRUNDr BCM56504_A0_READ_IRUNDr
#define WRITE_IRUNDr BCM56504_A0_WRITE_IRUNDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_IRUNDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  IRXCF
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Receive control packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56504_A0_IRXCFr 0x00f00035

#define BCM56504_A0_IRXCFr_SIZE 8

/*
 * This structure should be used to declare and program IRXCF.
 *
 */
typedef union BCM56504_A0_IRXCFr_s {
	uint32_t v[2];
	uint32_t irxcf[2];
	uint32_t _irxcf;
} BCM56504_A0_IRXCFr_t;

#define BCM56504_A0_IRXCFr_CLR(r) CDK_MEMSET(&((r)._irxcf), 0, sizeof(BCM56504_A0_IRXCFr_t))
#define BCM56504_A0_IRXCFr_SET(r,i,d) (r).irxcf[i] = d
#define BCM56504_A0_IRXCFr_GET(r,i) (r).irxcf[i]


/*
 * These macros can be used to access IRXCF.
 *
 */
#define BCM56504_A0_READ_IRXCFr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_IRXCFr,(r._irxcf))
#define BCM56504_A0_WRITE_IRXCFr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_IRXCFr,&(r._irxcf))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IRXCFr BCM56504_A0_IRXCFr
#define IRXCFr_SIZE BCM56504_A0_IRXCFr_SIZE
typedef BCM56504_A0_IRXCFr_t IRXCFr_t;
#define IRXCFr_CLR BCM56504_A0_IRXCFr_CLR
#define IRXCFr_SET BCM56504_A0_IRXCFr_SET
#define IRXCFr_GET BCM56504_A0_IRXCFr_GET
#define READ_IRXCFr BCM56504_A0_READ_IRXCFr
#define WRITE_IRXCFr BCM56504_A0_WRITE_IRXCFr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_IRXCFr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  IRXPF
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Receive PAUSE packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56504_A0_IRXPFr 0x00f00036

#define BCM56504_A0_IRXPFr_SIZE 8

/*
 * This structure should be used to declare and program IRXPF.
 *
 */
typedef union BCM56504_A0_IRXPFr_s {
	uint32_t v[2];
	uint32_t irxpf[2];
	uint32_t _irxpf;
} BCM56504_A0_IRXPFr_t;

#define BCM56504_A0_IRXPFr_CLR(r) CDK_MEMSET(&((r)._irxpf), 0, sizeof(BCM56504_A0_IRXPFr_t))
#define BCM56504_A0_IRXPFr_SET(r,i,d) (r).irxpf[i] = d
#define BCM56504_A0_IRXPFr_GET(r,i) (r).irxpf[i]


/*
 * These macros can be used to access IRXPF.
 *
 */
#define BCM56504_A0_READ_IRXPFr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_IRXPFr,(r._irxpf))
#define BCM56504_A0_WRITE_IRXPFr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_IRXPFr,&(r._irxpf))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IRXPFr BCM56504_A0_IRXPFr
#define IRXPFr_SIZE BCM56504_A0_IRXPFr_SIZE
typedef BCM56504_A0_IRXPFr_t IRXPFr_t;
#define IRXPFr_CLR BCM56504_A0_IRXPFr_CLR
#define IRXPFr_SET BCM56504_A0_IRXPFr_SET
#define IRXPFr_GET BCM56504_A0_IRXPFr_GET
#define READ_IRXPFr BCM56504_A0_READ_IRXPFr
#define WRITE_IRXPFr BCM56504_A0_WRITE_IRXPFr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_IRXPFr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  IRXUO
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Receive PAUSE packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56504_A0_IRXUOr 0x00f00037

#define BCM56504_A0_IRXUOr_SIZE 8

/*
 * This structure should be used to declare and program IRXUO.
 *
 */
typedef union BCM56504_A0_IRXUOr_s {
	uint32_t v[2];
	uint32_t irxuo[2];
	uint32_t _irxuo;
} BCM56504_A0_IRXUOr_t;

#define BCM56504_A0_IRXUOr_CLR(r) CDK_MEMSET(&((r)._irxuo), 0, sizeof(BCM56504_A0_IRXUOr_t))
#define BCM56504_A0_IRXUOr_SET(r,i,d) (r).irxuo[i] = d
#define BCM56504_A0_IRXUOr_GET(r,i) (r).irxuo[i]


/*
 * These macros can be used to access IRXUO.
 *
 */
#define BCM56504_A0_READ_IRXUOr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_IRXUOr,(r._irxuo))
#define BCM56504_A0_WRITE_IRXUOr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_IRXUOr,&(r._irxuo))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IRXUOr BCM56504_A0_IRXUOr
#define IRXUOr_SIZE BCM56504_A0_IRXUOr_SIZE
typedef BCM56504_A0_IRXUOr_t IRXUOr_t;
#define IRXUOr_CLR BCM56504_A0_IRXUOr_CLR
#define IRXUOr_SET BCM56504_A0_IRXUOr_SET
#define IRXUOr_GET BCM56504_A0_IRXUOr_GET
#define READ_IRXUOr BCM56504_A0_READ_IRXUOr
#define WRITE_IRXUOr BCM56504_A0_WRITE_IRXUOr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_IRXUOr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  IT1023
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Transmit 512-1023 byte packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56504_A0_IT1023r 0x00f00017

#define BCM56504_A0_IT1023r_SIZE 8

/*
 * This structure should be used to declare and program IT1023.
 *
 */
typedef union BCM56504_A0_IT1023r_s {
	uint32_t v[2];
	uint32_t it1023[2];
	uint32_t _it1023;
} BCM56504_A0_IT1023r_t;

#define BCM56504_A0_IT1023r_CLR(r) CDK_MEMSET(&((r)._it1023), 0, sizeof(BCM56504_A0_IT1023r_t))
#define BCM56504_A0_IT1023r_SET(r,i,d) (r).it1023[i] = d
#define BCM56504_A0_IT1023r_GET(r,i) (r).it1023[i]


/*
 * These macros can be used to access IT1023.
 *
 */
#define BCM56504_A0_READ_IT1023r(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_IT1023r,(r._it1023))
#define BCM56504_A0_WRITE_IT1023r(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_IT1023r,&(r._it1023))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IT1023r BCM56504_A0_IT1023r
#define IT1023r_SIZE BCM56504_A0_IT1023r_SIZE
typedef BCM56504_A0_IT1023r_t IT1023r_t;
#define IT1023r_CLR BCM56504_A0_IT1023r_CLR
#define IT1023r_SET BCM56504_A0_IT1023r_SET
#define IT1023r_GET BCM56504_A0_IT1023r_GET
#define READ_IT1023r BCM56504_A0_READ_IT1023r
#define WRITE_IT1023r BCM56504_A0_WRITE_IT1023r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_IT1023r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  IT127
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Transmit 65-127 byte packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56504_A0_IT127r 0x00f00014

#define BCM56504_A0_IT127r_SIZE 8

/*
 * This structure should be used to declare and program IT127.
 *
 */
typedef union BCM56504_A0_IT127r_s {
	uint32_t v[2];
	uint32_t it127[2];
	uint32_t _it127;
} BCM56504_A0_IT127r_t;

#define BCM56504_A0_IT127r_CLR(r) CDK_MEMSET(&((r)._it127), 0, sizeof(BCM56504_A0_IT127r_t))
#define BCM56504_A0_IT127r_SET(r,i,d) (r).it127[i] = d
#define BCM56504_A0_IT127r_GET(r,i) (r).it127[i]


/*
 * These macros can be used to access IT127.
 *
 */
#define BCM56504_A0_READ_IT127r(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_IT127r,(r._it127))
#define BCM56504_A0_WRITE_IT127r(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_IT127r,&(r._it127))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IT127r BCM56504_A0_IT127r
#define IT127r_SIZE BCM56504_A0_IT127r_SIZE
typedef BCM56504_A0_IT127r_t IT127r_t;
#define IT127r_CLR BCM56504_A0_IT127r_CLR
#define IT127r_SET BCM56504_A0_IT127r_SET
#define IT127r_GET BCM56504_A0_IT127r_GET
#define READ_IT127r BCM56504_A0_READ_IT127r
#define WRITE_IT127r BCM56504_A0_WRITE_IT127r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_IT127r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  IT1518
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Transmit 1024-1518 byte packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56504_A0_IT1518r 0x00f00018

#define BCM56504_A0_IT1518r_SIZE 8

/*
 * This structure should be used to declare and program IT1518.
 *
 */
typedef union BCM56504_A0_IT1518r_s {
	uint32_t v[2];
	uint32_t it1518[2];
	uint32_t _it1518;
} BCM56504_A0_IT1518r_t;

#define BCM56504_A0_IT1518r_CLR(r) CDK_MEMSET(&((r)._it1518), 0, sizeof(BCM56504_A0_IT1518r_t))
#define BCM56504_A0_IT1518r_SET(r,i,d) (r).it1518[i] = d
#define BCM56504_A0_IT1518r_GET(r,i) (r).it1518[i]


/*
 * These macros can be used to access IT1518.
 *
 */
#define BCM56504_A0_READ_IT1518r(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_IT1518r,(r._it1518))
#define BCM56504_A0_WRITE_IT1518r(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_IT1518r,&(r._it1518))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IT1518r BCM56504_A0_IT1518r
#define IT1518r_SIZE BCM56504_A0_IT1518r_SIZE
typedef BCM56504_A0_IT1518r_t IT1518r_t;
#define IT1518r_CLR BCM56504_A0_IT1518r_CLR
#define IT1518r_SET BCM56504_A0_IT1518r_SET
#define IT1518r_GET BCM56504_A0_IT1518r_GET
#define READ_IT1518r BCM56504_A0_READ_IT1518r
#define WRITE_IT1518r BCM56504_A0_WRITE_IT1518r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_IT1518r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  IT16383
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Transmit 9217-16383 byte packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56504_A0_IT16383r 0x00f0001c

#define BCM56504_A0_IT16383r_SIZE 8

/*
 * This structure should be used to declare and program IT16383.
 *
 */
typedef union BCM56504_A0_IT16383r_s {
	uint32_t v[2];
	uint32_t it16383[2];
	uint32_t _it16383;
} BCM56504_A0_IT16383r_t;

#define BCM56504_A0_IT16383r_CLR(r) CDK_MEMSET(&((r)._it16383), 0, sizeof(BCM56504_A0_IT16383r_t))
#define BCM56504_A0_IT16383r_SET(r,i,d) (r).it16383[i] = d
#define BCM56504_A0_IT16383r_GET(r,i) (r).it16383[i]


/*
 * These macros can be used to access IT16383.
 *
 */
#define BCM56504_A0_READ_IT16383r(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_IT16383r,(r._it16383))
#define BCM56504_A0_WRITE_IT16383r(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_IT16383r,&(r._it16383))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IT16383r BCM56504_A0_IT16383r
#define IT16383r_SIZE BCM56504_A0_IT16383r_SIZE
typedef BCM56504_A0_IT16383r_t IT16383r_t;
#define IT16383r_CLR BCM56504_A0_IT16383r_CLR
#define IT16383r_SET BCM56504_A0_IT16383r_SET
#define IT16383r_GET BCM56504_A0_IT16383r_GET
#define READ_IT16383r BCM56504_A0_READ_IT16383r
#define WRITE_IT16383r BCM56504_A0_WRITE_IT16383r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_IT16383r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  IT2047
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Transmit 1519-2047 byte packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56504_A0_IT2047r 0x00f00019

#define BCM56504_A0_IT2047r_SIZE 8

/*
 * This structure should be used to declare and program IT2047.
 *
 */
typedef union BCM56504_A0_IT2047r_s {
	uint32_t v[2];
	uint32_t it2047[2];
	uint32_t _it2047;
} BCM56504_A0_IT2047r_t;

#define BCM56504_A0_IT2047r_CLR(r) CDK_MEMSET(&((r)._it2047), 0, sizeof(BCM56504_A0_IT2047r_t))
#define BCM56504_A0_IT2047r_SET(r,i,d) (r).it2047[i] = d
#define BCM56504_A0_IT2047r_GET(r,i) (r).it2047[i]


/*
 * These macros can be used to access IT2047.
 *
 */
#define BCM56504_A0_READ_IT2047r(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_IT2047r,(r._it2047))
#define BCM56504_A0_WRITE_IT2047r(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_IT2047r,&(r._it2047))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IT2047r BCM56504_A0_IT2047r
#define IT2047r_SIZE BCM56504_A0_IT2047r_SIZE
typedef BCM56504_A0_IT2047r_t IT2047r_t;
#define IT2047r_CLR BCM56504_A0_IT2047r_CLR
#define IT2047r_SET BCM56504_A0_IT2047r_SET
#define IT2047r_GET BCM56504_A0_IT2047r_GET
#define READ_IT2047r BCM56504_A0_READ_IT2047r
#define WRITE_IT2047r BCM56504_A0_WRITE_IT2047r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_IT2047r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  IT255
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Transmit 128-255 byte packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56504_A0_IT255r 0x00f00015

#define BCM56504_A0_IT255r_SIZE 8

/*
 * This structure should be used to declare and program IT255.
 *
 */
typedef union BCM56504_A0_IT255r_s {
	uint32_t v[2];
	uint32_t it255[2];
	uint32_t _it255;
} BCM56504_A0_IT255r_t;

#define BCM56504_A0_IT255r_CLR(r) CDK_MEMSET(&((r)._it255), 0, sizeof(BCM56504_A0_IT255r_t))
#define BCM56504_A0_IT255r_SET(r,i,d) (r).it255[i] = d
#define BCM56504_A0_IT255r_GET(r,i) (r).it255[i]


/*
 * These macros can be used to access IT255.
 *
 */
#define BCM56504_A0_READ_IT255r(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_IT255r,(r._it255))
#define BCM56504_A0_WRITE_IT255r(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_IT255r,&(r._it255))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IT255r BCM56504_A0_IT255r
#define IT255r_SIZE BCM56504_A0_IT255r_SIZE
typedef BCM56504_A0_IT255r_t IT255r_t;
#define IT255r_CLR BCM56504_A0_IT255r_CLR
#define IT255r_SET BCM56504_A0_IT255r_SET
#define IT255r_GET BCM56504_A0_IT255r_GET
#define READ_IT255r BCM56504_A0_READ_IT255r
#define WRITE_IT255r BCM56504_A0_WRITE_IT255r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_IT255r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  IT4095
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Transmit 2048-4095 byte packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56504_A0_IT4095r 0x00f0001a

#define BCM56504_A0_IT4095r_SIZE 8

/*
 * This structure should be used to declare and program IT4095.
 *
 */
typedef union BCM56504_A0_IT4095r_s {
	uint32_t v[2];
	uint32_t it4095[2];
	uint32_t _it4095;
} BCM56504_A0_IT4095r_t;

#define BCM56504_A0_IT4095r_CLR(r) CDK_MEMSET(&((r)._it4095), 0, sizeof(BCM56504_A0_IT4095r_t))
#define BCM56504_A0_IT4095r_SET(r,i,d) (r).it4095[i] = d
#define BCM56504_A0_IT4095r_GET(r,i) (r).it4095[i]


/*
 * These macros can be used to access IT4095.
 *
 */
#define BCM56504_A0_READ_IT4095r(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_IT4095r,(r._it4095))
#define BCM56504_A0_WRITE_IT4095r(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_IT4095r,&(r._it4095))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IT4095r BCM56504_A0_IT4095r
#define IT4095r_SIZE BCM56504_A0_IT4095r_SIZE
typedef BCM56504_A0_IT4095r_t IT4095r_t;
#define IT4095r_CLR BCM56504_A0_IT4095r_CLR
#define IT4095r_SET BCM56504_A0_IT4095r_SET
#define IT4095r_GET BCM56504_A0_IT4095r_GET
#define READ_IT4095r BCM56504_A0_READ_IT4095r
#define WRITE_IT4095r BCM56504_A0_WRITE_IT4095r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_IT4095r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  IT511
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Transmit 256-511 byte packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56504_A0_IT511r 0x00f00016

#define BCM56504_A0_IT511r_SIZE 8

/*
 * This structure should be used to declare and program IT511.
 *
 */
typedef union BCM56504_A0_IT511r_s {
	uint32_t v[2];
	uint32_t it511[2];
	uint32_t _it511;
} BCM56504_A0_IT511r_t;

#define BCM56504_A0_IT511r_CLR(r) CDK_MEMSET(&((r)._it511), 0, sizeof(BCM56504_A0_IT511r_t))
#define BCM56504_A0_IT511r_SET(r,i,d) (r).it511[i] = d
#define BCM56504_A0_IT511r_GET(r,i) (r).it511[i]


/*
 * These macros can be used to access IT511.
 *
 */
#define BCM56504_A0_READ_IT511r(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_IT511r,(r._it511))
#define BCM56504_A0_WRITE_IT511r(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_IT511r,&(r._it511))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IT511r BCM56504_A0_IT511r
#define IT511r_SIZE BCM56504_A0_IT511r_SIZE
typedef BCM56504_A0_IT511r_t IT511r_t;
#define IT511r_CLR BCM56504_A0_IT511r_CLR
#define IT511r_SET BCM56504_A0_IT511r_SET
#define IT511r_GET BCM56504_A0_IT511r_GET
#define READ_IT511r BCM56504_A0_READ_IT511r
#define WRITE_IT511r BCM56504_A0_WRITE_IT511r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_IT511r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  IT64
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Transmit 64 byte packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56504_A0_IT64r 0x00f00013

#define BCM56504_A0_IT64r_SIZE 8

/*
 * This structure should be used to declare and program IT64.
 *
 */
typedef union BCM56504_A0_IT64r_s {
	uint32_t v[2];
	uint32_t it64[2];
	uint32_t _it64;
} BCM56504_A0_IT64r_t;

#define BCM56504_A0_IT64r_CLR(r) CDK_MEMSET(&((r)._it64), 0, sizeof(BCM56504_A0_IT64r_t))
#define BCM56504_A0_IT64r_SET(r,i,d) (r).it64[i] = d
#define BCM56504_A0_IT64r_GET(r,i) (r).it64[i]


/*
 * These macros can be used to access IT64.
 *
 */
#define BCM56504_A0_READ_IT64r(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_IT64r,(r._it64))
#define BCM56504_A0_WRITE_IT64r(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_IT64r,&(r._it64))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IT64r BCM56504_A0_IT64r
#define IT64r_SIZE BCM56504_A0_IT64r_SIZE
typedef BCM56504_A0_IT64r_t IT64r_t;
#define IT64r_CLR BCM56504_A0_IT64r_CLR
#define IT64r_SET BCM56504_A0_IT64r_SET
#define IT64r_GET BCM56504_A0_IT64r_GET
#define READ_IT64r BCM56504_A0_READ_IT64r
#define WRITE_IT64r BCM56504_A0_WRITE_IT64r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_IT64r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  IT9216
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Transmit 4096-9216 byte packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56504_A0_IT9216r 0x00f0001b

#define BCM56504_A0_IT9216r_SIZE 8

/*
 * This structure should be used to declare and program IT9216.
 *
 */
typedef union BCM56504_A0_IT9216r_s {
	uint32_t v[2];
	uint32_t it9216[2];
	uint32_t _it9216;
} BCM56504_A0_IT9216r_t;

#define BCM56504_A0_IT9216r_CLR(r) CDK_MEMSET(&((r)._it9216), 0, sizeof(BCM56504_A0_IT9216r_t))
#define BCM56504_A0_IT9216r_SET(r,i,d) (r).it9216[i] = d
#define BCM56504_A0_IT9216r_GET(r,i) (r).it9216[i]


/*
 * These macros can be used to access IT9216.
 *
 */
#define BCM56504_A0_READ_IT9216r(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_IT9216r,(r._it9216))
#define BCM56504_A0_WRITE_IT9216r(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_IT9216r,&(r._it9216))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IT9216r BCM56504_A0_IT9216r
#define IT9216r_SIZE BCM56504_A0_IT9216r_SIZE
typedef BCM56504_A0_IT9216r_t IT9216r_t;
#define IT9216r_CLR BCM56504_A0_IT9216r_CLR
#define IT9216r_SET BCM56504_A0_IT9216r_SET
#define IT9216r_GET BCM56504_A0_IT9216r_GET
#define READ_IT9216r BCM56504_A0_READ_IT9216r
#define WRITE_IT9216r BCM56504_A0_WRITE_IT9216r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_IT9216r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  ITBCA
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Transmit broadcast packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56504_A0_ITBCAr 0x00f00010

#define BCM56504_A0_ITBCAr_SIZE 8

/*
 * This structure should be used to declare and program ITBCA.
 *
 */
typedef union BCM56504_A0_ITBCAr_s {
	uint32_t v[2];
	uint32_t itbca[2];
	uint32_t _itbca;
} BCM56504_A0_ITBCAr_t;

#define BCM56504_A0_ITBCAr_CLR(r) CDK_MEMSET(&((r)._itbca), 0, sizeof(BCM56504_A0_ITBCAr_t))
#define BCM56504_A0_ITBCAr_SET(r,i,d) (r).itbca[i] = d
#define BCM56504_A0_ITBCAr_GET(r,i) (r).itbca[i]


/*
 * These macros can be used to access ITBCA.
 *
 */
#define BCM56504_A0_READ_ITBCAr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_ITBCAr,(r._itbca))
#define BCM56504_A0_WRITE_ITBCAr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_ITBCAr,&(r._itbca))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ITBCAr BCM56504_A0_ITBCAr
#define ITBCAr_SIZE BCM56504_A0_ITBCAr_SIZE
typedef BCM56504_A0_ITBCAr_t ITBCAr_t;
#define ITBCAr_CLR BCM56504_A0_ITBCAr_CLR
#define ITBCAr_SET BCM56504_A0_ITBCAr_SET
#define ITBCAr_GET BCM56504_A0_ITBCAr_GET
#define READ_ITBCAr BCM56504_A0_READ_ITBCAr
#define WRITE_ITBCAr BCM56504_A0_WRITE_ITBCAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_ITBCAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  ITBYT
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Transmit byte counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56504_A0_ITBYTr 0x00f00020

#define BCM56504_A0_ITBYTr_SIZE 8

/*
 * This structure should be used to declare and program ITBYT.
 *
 */
typedef union BCM56504_A0_ITBYTr_s {
	uint32_t v[2];
	uint32_t itbyt[2];
	uint32_t _itbyt;
} BCM56504_A0_ITBYTr_t;

#define BCM56504_A0_ITBYTr_CLR(r) CDK_MEMSET(&((r)._itbyt), 0, sizeof(BCM56504_A0_ITBYTr_t))
#define BCM56504_A0_ITBYTr_SET(r,i,d) (r).itbyt[i] = d
#define BCM56504_A0_ITBYTr_GET(r,i) (r).itbyt[i]


/*
 * These macros can be used to access ITBYT.
 *
 */
#define BCM56504_A0_READ_ITBYTr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_ITBYTr,(r._itbyt))
#define BCM56504_A0_WRITE_ITBYTr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_ITBYTr,&(r._itbyt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ITBYTr BCM56504_A0_ITBYTr
#define ITBYTr_SIZE BCM56504_A0_ITBYTr_SIZE
typedef BCM56504_A0_ITBYTr_t ITBYTr_t;
#define ITBYTr_CLR BCM56504_A0_ITBYTr_CLR
#define ITBYTr_SET BCM56504_A0_ITBYTr_SET
#define ITBYTr_GET BCM56504_A0_ITBYTr_GET
#define READ_ITBYTr BCM56504_A0_READ_ITBYTr
#define WRITE_ITBYTr BCM56504_A0_WRITE_ITBYTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_ITBYTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  ITERR
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Transmit error packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56504_A0_ITERRr 0x00f0001f

#define BCM56504_A0_ITERRr_SIZE 8

/*
 * This structure should be used to declare and program ITERR.
 *
 */
typedef union BCM56504_A0_ITERRr_s {
	uint32_t v[2];
	uint32_t iterr[2];
	uint32_t _iterr;
} BCM56504_A0_ITERRr_t;

#define BCM56504_A0_ITERRr_CLR(r) CDK_MEMSET(&((r)._iterr), 0, sizeof(BCM56504_A0_ITERRr_t))
#define BCM56504_A0_ITERRr_SET(r,i,d) (r).iterr[i] = d
#define BCM56504_A0_ITERRr_GET(r,i) (r).iterr[i]


/*
 * These macros can be used to access ITERR.
 *
 */
#define BCM56504_A0_READ_ITERRr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_ITERRr,(r._iterr))
#define BCM56504_A0_WRITE_ITERRr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_ITERRr,&(r._iterr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ITERRr BCM56504_A0_ITERRr
#define ITERRr_SIZE BCM56504_A0_ITERRr_SIZE
typedef BCM56504_A0_ITERRr_t ITERRr_t;
#define ITERRr_CLR BCM56504_A0_ITERRr_CLR
#define ITERRr_SET BCM56504_A0_ITERRr_SET
#define ITERRr_GET BCM56504_A0_ITERRr_GET
#define READ_ITERRr BCM56504_A0_READ_ITERRr
#define WRITE_ITERRr BCM56504_A0_WRITE_ITERRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_ITERRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  ITFCS
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Transmit FCS(CRC) error counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56504_A0_ITFCSr 0x00f0000e

#define BCM56504_A0_ITFCSr_SIZE 8

/*
 * This structure should be used to declare and program ITFCS.
 *
 */
typedef union BCM56504_A0_ITFCSr_s {
	uint32_t v[2];
	uint32_t itfcs[2];
	uint32_t _itfcs;
} BCM56504_A0_ITFCSr_t;

#define BCM56504_A0_ITFCSr_CLR(r) CDK_MEMSET(&((r)._itfcs), 0, sizeof(BCM56504_A0_ITFCSr_t))
#define BCM56504_A0_ITFCSr_SET(r,i,d) (r).itfcs[i] = d
#define BCM56504_A0_ITFCSr_GET(r,i) (r).itfcs[i]


/*
 * These macros can be used to access ITFCS.
 *
 */
#define BCM56504_A0_READ_ITFCSr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_ITFCSr,(r._itfcs))
#define BCM56504_A0_WRITE_ITFCSr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_ITFCSr,&(r._itfcs))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ITFCSr BCM56504_A0_ITFCSr
#define ITFCSr_SIZE BCM56504_A0_ITFCSr_SIZE
typedef BCM56504_A0_ITFCSr_t ITFCSr_t;
#define ITFCSr_CLR BCM56504_A0_ITFCSr_CLR
#define ITFCSr_SET BCM56504_A0_ITFCSr_SET
#define ITFCSr_GET BCM56504_A0_ITFCSr_GET
#define READ_ITFCSr BCM56504_A0_READ_ITFCSr
#define WRITE_ITFCSr BCM56504_A0_WRITE_ITFCSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_ITFCSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  ITFRG
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Transmit fragment counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56504_A0_ITFRGr 0x00f00011

#define BCM56504_A0_ITFRGr_SIZE 8

/*
 * This structure should be used to declare and program ITFRG.
 *
 */
typedef union BCM56504_A0_ITFRGr_s {
	uint32_t v[2];
	uint32_t itfrg[2];
	uint32_t _itfrg;
} BCM56504_A0_ITFRGr_t;

#define BCM56504_A0_ITFRGr_CLR(r) CDK_MEMSET(&((r)._itfrg), 0, sizeof(BCM56504_A0_ITFRGr_t))
#define BCM56504_A0_ITFRGr_SET(r,i,d) (r).itfrg[i] = d
#define BCM56504_A0_ITFRGr_GET(r,i) (r).itfrg[i]


/*
 * These macros can be used to access ITFRG.
 *
 */
#define BCM56504_A0_READ_ITFRGr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_ITFRGr,(r._itfrg))
#define BCM56504_A0_WRITE_ITFRGr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_ITFRGr,&(r._itfrg))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ITFRGr BCM56504_A0_ITFRGr
#define ITFRGr_SIZE BCM56504_A0_ITFRGr_SIZE
typedef BCM56504_A0_ITFRGr_t ITFRGr_t;
#define ITFRGr_CLR BCM56504_A0_ITFRGr_CLR
#define ITFRGr_SET BCM56504_A0_ITFRGr_SET
#define ITFRGr_GET BCM56504_A0_ITFRGr_GET
#define READ_ITFRGr BCM56504_A0_READ_ITFRGr
#define WRITE_ITFRGr BCM56504_A0_WRITE_ITFRGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_ITFRGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  ITMAX
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Transmit max size packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56504_A0_ITMAXr 0x00f0001d

#define BCM56504_A0_ITMAXr_SIZE 8

/*
 * This structure should be used to declare and program ITMAX.
 *
 */
typedef union BCM56504_A0_ITMAXr_s {
	uint32_t v[2];
	uint32_t itmax[2];
	uint32_t _itmax;
} BCM56504_A0_ITMAXr_t;

#define BCM56504_A0_ITMAXr_CLR(r) CDK_MEMSET(&((r)._itmax), 0, sizeof(BCM56504_A0_ITMAXr_t))
#define BCM56504_A0_ITMAXr_SET(r,i,d) (r).itmax[i] = d
#define BCM56504_A0_ITMAXr_GET(r,i) (r).itmax[i]


/*
 * These macros can be used to access ITMAX.
 *
 */
#define BCM56504_A0_READ_ITMAXr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_ITMAXr,(r._itmax))
#define BCM56504_A0_WRITE_ITMAXr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_ITMAXr,&(r._itmax))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ITMAXr BCM56504_A0_ITMAXr
#define ITMAXr_SIZE BCM56504_A0_ITMAXr_SIZE
typedef BCM56504_A0_ITMAXr_t ITMAXr_t;
#define ITMAXr_CLR BCM56504_A0_ITMAXr_CLR
#define ITMAXr_SET BCM56504_A0_ITMAXr_SET
#define ITMAXr_GET BCM56504_A0_ITMAXr_GET
#define READ_ITMAXr BCM56504_A0_READ_ITMAXr
#define WRITE_ITMAXr BCM56504_A0_WRITE_ITMAXr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_ITMAXr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  ITMCA
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Transmit multicast packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56504_A0_ITMCAr 0x00f0000f

#define BCM56504_A0_ITMCAr_SIZE 8

/*
 * This structure should be used to declare and program ITMCA.
 *
 */
typedef union BCM56504_A0_ITMCAr_s {
	uint32_t v[2];
	uint32_t itmca[2];
	uint32_t _itmca;
} BCM56504_A0_ITMCAr_t;

#define BCM56504_A0_ITMCAr_CLR(r) CDK_MEMSET(&((r)._itmca), 0, sizeof(BCM56504_A0_ITMCAr_t))
#define BCM56504_A0_ITMCAr_SET(r,i,d) (r).itmca[i] = d
#define BCM56504_A0_ITMCAr_GET(r,i) (r).itmca[i]


/*
 * These macros can be used to access ITMCA.
 *
 */
#define BCM56504_A0_READ_ITMCAr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_ITMCAr,(r._itmca))
#define BCM56504_A0_WRITE_ITMCAr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_ITMCAr,&(r._itmca))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ITMCAr BCM56504_A0_ITMCAr
#define ITMCAr_SIZE BCM56504_A0_ITMCAr_SIZE
typedef BCM56504_A0_ITMCAr_t ITMCAr_t;
#define ITMCAr_CLR BCM56504_A0_ITMCAr_CLR
#define ITMCAr_SET BCM56504_A0_ITMCAr_SET
#define ITMCAr_GET BCM56504_A0_ITMCAr_GET
#define READ_ITMCAr BCM56504_A0_READ_ITMCAr
#define WRITE_ITMCAr BCM56504_A0_WRITE_ITMCAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_ITMCAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  ITOVR
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Transmit oversize packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56504_A0_ITOVRr 0x00f00012

#define BCM56504_A0_ITOVRr_SIZE 8

/*
 * This structure should be used to declare and program ITOVR.
 *
 */
typedef union BCM56504_A0_ITOVRr_s {
	uint32_t v[2];
	uint32_t itovr[2];
	uint32_t _itovr;
} BCM56504_A0_ITOVRr_t;

#define BCM56504_A0_ITOVRr_CLR(r) CDK_MEMSET(&((r)._itovr), 0, sizeof(BCM56504_A0_ITOVRr_t))
#define BCM56504_A0_ITOVRr_SET(r,i,d) (r).itovr[i] = d
#define BCM56504_A0_ITOVRr_GET(r,i) (r).itovr[i]


/*
 * These macros can be used to access ITOVR.
 *
 */
#define BCM56504_A0_READ_ITOVRr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_ITOVRr,(r._itovr))
#define BCM56504_A0_WRITE_ITOVRr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_ITOVRr,&(r._itovr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ITOVRr BCM56504_A0_ITOVRr
#define ITOVRr_SIZE BCM56504_A0_ITOVRr_SIZE
typedef BCM56504_A0_ITOVRr_t ITOVRr_t;
#define ITOVRr_CLR BCM56504_A0_ITOVRr_CLR
#define ITOVRr_SET BCM56504_A0_ITOVRr_SET
#define ITOVRr_GET BCM56504_A0_ITOVRr_GET
#define READ_ITOVRr BCM56504_A0_READ_ITOVRr
#define WRITE_ITOVRr BCM56504_A0_WRITE_ITOVRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_ITOVRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  ITPKT
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Transmit packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56504_A0_ITPKTr 0x00f0000c

#define BCM56504_A0_ITPKTr_SIZE 8

/*
 * This structure should be used to declare and program ITPKT.
 *
 */
typedef union BCM56504_A0_ITPKTr_s {
	uint32_t v[2];
	uint32_t itpkt[2];
	uint32_t _itpkt;
} BCM56504_A0_ITPKTr_t;

#define BCM56504_A0_ITPKTr_CLR(r) CDK_MEMSET(&((r)._itpkt), 0, sizeof(BCM56504_A0_ITPKTr_t))
#define BCM56504_A0_ITPKTr_SET(r,i,d) (r).itpkt[i] = d
#define BCM56504_A0_ITPKTr_GET(r,i) (r).itpkt[i]


/*
 * These macros can be used to access ITPKT.
 *
 */
#define BCM56504_A0_READ_ITPKTr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_ITPKTr,(r._itpkt))
#define BCM56504_A0_WRITE_ITPKTr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_ITPKTr,&(r._itpkt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ITPKTr BCM56504_A0_ITPKTr
#define ITPKTr_SIZE BCM56504_A0_ITPKTr_SIZE
typedef BCM56504_A0_ITPKTr_t ITPKTr_t;
#define ITPKTr_CLR BCM56504_A0_ITPKTr_CLR
#define ITPKTr_SET BCM56504_A0_ITPKTr_SET
#define ITPKTr_GET BCM56504_A0_ITPKTr_GET
#define READ_ITPKTr BCM56504_A0_READ_ITPKTr
#define WRITE_ITPKTr BCM56504_A0_WRITE_ITPKTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_ITPKTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  ITUFL
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Transmit underflow counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56504_A0_ITUFLr 0x00f0001e

#define BCM56504_A0_ITUFLr_SIZE 8

/*
 * This structure should be used to declare and program ITUFL.
 *
 */
typedef union BCM56504_A0_ITUFLr_s {
	uint32_t v[2];
	uint32_t itufl[2];
	uint32_t _itufl;
} BCM56504_A0_ITUFLr_t;

#define BCM56504_A0_ITUFLr_CLR(r) CDK_MEMSET(&((r)._itufl), 0, sizeof(BCM56504_A0_ITUFLr_t))
#define BCM56504_A0_ITUFLr_SET(r,i,d) (r).itufl[i] = d
#define BCM56504_A0_ITUFLr_GET(r,i) (r).itufl[i]


/*
 * These macros can be used to access ITUFL.
 *
 */
#define BCM56504_A0_READ_ITUFLr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_ITUFLr,(r._itufl))
#define BCM56504_A0_WRITE_ITUFLr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_ITUFLr,&(r._itufl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ITUFLr BCM56504_A0_ITUFLr
#define ITUFLr_SIZE BCM56504_A0_ITUFLr_SIZE
typedef BCM56504_A0_ITUFLr_t ITUFLr_t;
#define ITUFLr_CLR BCM56504_A0_ITUFLr_CLR
#define ITUFLr_SET BCM56504_A0_ITUFLr_SET
#define ITUFLr_GET BCM56504_A0_ITUFLr_GET
#define READ_ITUFLr BCM56504_A0_READ_ITUFLr
#define WRITE_ITUFLr BCM56504_A0_WRITE_ITUFLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_ITUFLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  ITXPF
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Transmit pause packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56504_A0_ITXPFr 0x00f0000d

#define BCM56504_A0_ITXPFr_SIZE 8

/*
 * This structure should be used to declare and program ITXPF.
 *
 */
typedef union BCM56504_A0_ITXPFr_s {
	uint32_t v[2];
	uint32_t itxpf[2];
	uint32_t _itxpf;
} BCM56504_A0_ITXPFr_t;

#define BCM56504_A0_ITXPFr_CLR(r) CDK_MEMSET(&((r)._itxpf), 0, sizeof(BCM56504_A0_ITXPFr_t))
#define BCM56504_A0_ITXPFr_SET(r,i,d) (r).itxpf[i] = d
#define BCM56504_A0_ITXPFr_GET(r,i) (r).itxpf[i]


/*
 * These macros can be used to access ITXPF.
 *
 */
#define BCM56504_A0_READ_ITXPFr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_ITXPFr,(r._itxpf))
#define BCM56504_A0_WRITE_ITXPFr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_ITXPFr,&(r._itxpf))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ITXPFr BCM56504_A0_ITXPFr
#define ITXPFr_SIZE BCM56504_A0_ITXPFr_SIZE
typedef BCM56504_A0_ITXPFr_t ITXPFr_t;
#define ITXPFr_CLR BCM56504_A0_ITXPFr_CLR
#define ITXPFr_SET BCM56504_A0_ITXPFr_SET
#define ITXPFr_GET BCM56504_A0_ITXPFr_GET
#define READ_ITXPFr BCM56504_A0_READ_ITXPFr
#define WRITE_ITXPFr BCM56504_A0_WRITE_ITXPFr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_ITXPFr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  IUNKNOWN_MCAST_BLOCK_MASK
 * BLOCKS:   IPIPE_HI
 * DESC:     Unknown Multicast Block Mask
 * SIZE:     32
 * FIELDS:
 *     BLK_BITMAP       Bitmap of ports to be blocked
 *
 ******************************************************************************/
#define BCM56504_A0_IUNKNOWN_MCAST_BLOCK_MASKr 0x0e800101

#define BCM56504_A0_IUNKNOWN_MCAST_BLOCK_MASKr_SIZE 4

/*
 * This structure should be used to declare and program IUNKNOWN_MCAST_BLOCK_MASK.
 *
 */
typedef union BCM56504_A0_IUNKNOWN_MCAST_BLOCK_MASKr_s {
	uint32_t v[1];
	uint32_t iunknown_mcast_block_mask[1];
	uint32_t _iunknown_mcast_block_mask;
} BCM56504_A0_IUNKNOWN_MCAST_BLOCK_MASKr_t;

#define BCM56504_A0_IUNKNOWN_MCAST_BLOCK_MASKr_CLR(r) (r).iunknown_mcast_block_mask[0] = 0
#define BCM56504_A0_IUNKNOWN_MCAST_BLOCK_MASKr_SET(r,d) (r).iunknown_mcast_block_mask[0] = d
#define BCM56504_A0_IUNKNOWN_MCAST_BLOCK_MASKr_GET(r) (r).iunknown_mcast_block_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_IUNKNOWN_MCAST_BLOCK_MASKr_BLK_BITMAPf_GET(r) (((r).iunknown_mcast_block_mask[0]) & 0x1fffffff)
#define BCM56504_A0_IUNKNOWN_MCAST_BLOCK_MASKr_BLK_BITMAPf_SET(r,f) (r).iunknown_mcast_block_mask[0]=(((r).iunknown_mcast_block_mask[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))

/*
 * These macros can be used to access IUNKNOWN_MCAST_BLOCK_MASK.
 *
 */
#define BCM56504_A0_READ_IUNKNOWN_MCAST_BLOCK_MASKr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_IUNKNOWN_MCAST_BLOCK_MASKr,(r._iunknown_mcast_block_mask))
#define BCM56504_A0_WRITE_IUNKNOWN_MCAST_BLOCK_MASKr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_IUNKNOWN_MCAST_BLOCK_MASKr,&(r._iunknown_mcast_block_mask))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IUNKNOWN_MCAST_BLOCK_MASKr BCM56504_A0_IUNKNOWN_MCAST_BLOCK_MASKr
#define IUNKNOWN_MCAST_BLOCK_MASKr_SIZE BCM56504_A0_IUNKNOWN_MCAST_BLOCK_MASKr_SIZE
typedef BCM56504_A0_IUNKNOWN_MCAST_BLOCK_MASKr_t IUNKNOWN_MCAST_BLOCK_MASKr_t;
#define IUNKNOWN_MCAST_BLOCK_MASKr_CLR BCM56504_A0_IUNKNOWN_MCAST_BLOCK_MASKr_CLR
#define IUNKNOWN_MCAST_BLOCK_MASKr_SET BCM56504_A0_IUNKNOWN_MCAST_BLOCK_MASKr_SET
#define IUNKNOWN_MCAST_BLOCK_MASKr_GET BCM56504_A0_IUNKNOWN_MCAST_BLOCK_MASKr_GET
#define IUNKNOWN_MCAST_BLOCK_MASKr_BLK_BITMAPf_GET BCM56504_A0_IUNKNOWN_MCAST_BLOCK_MASKr_BLK_BITMAPf_GET
#define IUNKNOWN_MCAST_BLOCK_MASKr_BLK_BITMAPf_SET BCM56504_A0_IUNKNOWN_MCAST_BLOCK_MASKr_BLK_BITMAPf_SET
#define READ_IUNKNOWN_MCAST_BLOCK_MASKr BCM56504_A0_READ_IUNKNOWN_MCAST_BLOCK_MASKr
#define WRITE_IUNKNOWN_MCAST_BLOCK_MASKr BCM56504_A0_WRITE_IUNKNOWN_MCAST_BLOCK_MASKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_IUNKNOWN_MCAST_BLOCK_MASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  IUNKNOWN_UCAST_BLOCK_MASK
 * BLOCKS:   IPIPE_HI
 * DESC:     Unknown Unicast Block Mask
 * SIZE:     32
 * FIELDS:
 *     BLK_BITMAP       Bitmap of ports to be blocked
 *
 ******************************************************************************/
#define BCM56504_A0_IUNKNOWN_UCAST_BLOCK_MASKr 0x0e800100

#define BCM56504_A0_IUNKNOWN_UCAST_BLOCK_MASKr_SIZE 4

/*
 * This structure should be used to declare and program IUNKNOWN_UCAST_BLOCK_MASK.
 *
 */
typedef union BCM56504_A0_IUNKNOWN_UCAST_BLOCK_MASKr_s {
	uint32_t v[1];
	uint32_t iunknown_ucast_block_mask[1];
	uint32_t _iunknown_ucast_block_mask;
} BCM56504_A0_IUNKNOWN_UCAST_BLOCK_MASKr_t;

#define BCM56504_A0_IUNKNOWN_UCAST_BLOCK_MASKr_CLR(r) (r).iunknown_ucast_block_mask[0] = 0
#define BCM56504_A0_IUNKNOWN_UCAST_BLOCK_MASKr_SET(r,d) (r).iunknown_ucast_block_mask[0] = d
#define BCM56504_A0_IUNKNOWN_UCAST_BLOCK_MASKr_GET(r) (r).iunknown_ucast_block_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_IUNKNOWN_UCAST_BLOCK_MASKr_BLK_BITMAPf_GET(r) (((r).iunknown_ucast_block_mask[0]) & 0x1fffffff)
#define BCM56504_A0_IUNKNOWN_UCAST_BLOCK_MASKr_BLK_BITMAPf_SET(r,f) (r).iunknown_ucast_block_mask[0]=(((r).iunknown_ucast_block_mask[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))

/*
 * These macros can be used to access IUNKNOWN_UCAST_BLOCK_MASK.
 *
 */
#define BCM56504_A0_READ_IUNKNOWN_UCAST_BLOCK_MASKr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_IUNKNOWN_UCAST_BLOCK_MASKr,(r._iunknown_ucast_block_mask))
#define BCM56504_A0_WRITE_IUNKNOWN_UCAST_BLOCK_MASKr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_IUNKNOWN_UCAST_BLOCK_MASKr,&(r._iunknown_ucast_block_mask))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IUNKNOWN_UCAST_BLOCK_MASKr BCM56504_A0_IUNKNOWN_UCAST_BLOCK_MASKr
#define IUNKNOWN_UCAST_BLOCK_MASKr_SIZE BCM56504_A0_IUNKNOWN_UCAST_BLOCK_MASKr_SIZE
typedef BCM56504_A0_IUNKNOWN_UCAST_BLOCK_MASKr_t IUNKNOWN_UCAST_BLOCK_MASKr_t;
#define IUNKNOWN_UCAST_BLOCK_MASKr_CLR BCM56504_A0_IUNKNOWN_UCAST_BLOCK_MASKr_CLR
#define IUNKNOWN_UCAST_BLOCK_MASKr_SET BCM56504_A0_IUNKNOWN_UCAST_BLOCK_MASKr_SET
#define IUNKNOWN_UCAST_BLOCK_MASKr_GET BCM56504_A0_IUNKNOWN_UCAST_BLOCK_MASKr_GET
#define IUNKNOWN_UCAST_BLOCK_MASKr_BLK_BITMAPf_GET BCM56504_A0_IUNKNOWN_UCAST_BLOCK_MASKr_BLK_BITMAPf_GET
#define IUNKNOWN_UCAST_BLOCK_MASKr_BLK_BITMAPf_SET BCM56504_A0_IUNKNOWN_UCAST_BLOCK_MASKr_BLK_BITMAPf_SET
#define READ_IUNKNOWN_UCAST_BLOCK_MASKr BCM56504_A0_READ_IUNKNOWN_UCAST_BLOCK_MASKr
#define WRITE_IUNKNOWN_UCAST_BLOCK_MASKr BCM56504_A0_WRITE_IUNKNOWN_UCAST_BLOCK_MASKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_IUNKNOWN_UCAST_BLOCK_MASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  L2MC
 * BLOCKS:   IPIPE
 * DESC:     L2 Multicast table
 * SIZE:     32
 * FIELDS:
 *     HIGIG_TRUNK_OVERRIDE Higig Trunk Override indication
 *     PORT_BITMAP      Multicast port membership
 *     VALID            Indicates that the entry is valid
 *
 ******************************************************************************/
#define BCM56504_A0_L2MCm 0x07700000

#define BCM56504_A0_L2MCm_MIN 0
#define BCM56504_A0_L2MCm_MAX 1023
#define BCM56504_A0_L2MCm_CMAX(u) 1023
#define BCM56504_A0_L2MCm_SIZE 4

/*
 * This structure should be used to declare and program L2MC.
 *
 */
typedef union BCM56504_A0_L2MCm_s {
	uint32_t v[1];
	uint32_t l2mc[1];
	uint32_t _l2mc;
} BCM56504_A0_L2MCm_t;

#define BCM56504_A0_L2MCm_CLR(r) (r).l2mc[0] = 0
#define BCM56504_A0_L2MCm_SET(r,d) (r).l2mc[0] = d
#define BCM56504_A0_L2MCm_GET(r) (r).l2mc[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_L2MCm_HIGIG_TRUNK_OVERRIDEf_GET(r) (((r).l2mc[0]) & 0x3)
#define BCM56504_A0_L2MCm_HIGIG_TRUNK_OVERRIDEf_SET(r,f) (r).l2mc[0]=(((r).l2mc[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56504_A0_L2MCm_PORT_BITMAPf_GET(r) ((((r).l2mc[0]) >> 2) & 0x1fffffff)
#define BCM56504_A0_L2MCm_PORT_BITMAPf_SET(r,f) (r).l2mc[0]=(((r).l2mc[0] & ~((uint32_t)0x1fffffff << 2)) | ((((uint32_t)f) & 0x1fffffff) << 2))
#define BCM56504_A0_L2MCm_VALIDf_GET(r) ((((r).l2mc[0]) >> 31) & 0x1)
#define BCM56504_A0_L2MCm_VALIDf_SET(r,f) (r).l2mc[0]=(((r).l2mc[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access L2MC.
 *
 */
#define BCM56504_A0_READ_L2MCm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_L2MCm,i,(m._l2mc),1)
#define BCM56504_A0_WRITE_L2MCm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_L2MCm,i,&(m._l2mc),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2MCm BCM56504_A0_L2MCm
#define L2MCm_MIN BCM56504_A0_L2MCm_MIN
#define L2MCm_MAX BCM56504_A0_L2MCm_MAX
#define L2MCm_CMAX(u) BCM56504_A0_L2MCm_CMAX(u)
#define L2MCm_SIZE BCM56504_A0_L2MCm_SIZE
typedef BCM56504_A0_L2MCm_t L2MCm_t;
#define L2MCm_CLR BCM56504_A0_L2MCm_CLR
#define L2MCm_SET BCM56504_A0_L2MCm_SET
#define L2MCm_GET BCM56504_A0_L2MCm_GET
#define L2MCm_HIGIG_TRUNK_OVERRIDEf_GET BCM56504_A0_L2MCm_HIGIG_TRUNK_OVERRIDEf_GET
#define L2MCm_HIGIG_TRUNK_OVERRIDEf_SET BCM56504_A0_L2MCm_HIGIG_TRUNK_OVERRIDEf_SET
#define L2MCm_PORT_BITMAPf_GET BCM56504_A0_L2MCm_PORT_BITMAPf_GET
#define L2MCm_PORT_BITMAPf_SET BCM56504_A0_L2MCm_PORT_BITMAPf_SET
#define L2MCm_VALIDf_GET BCM56504_A0_L2MCm_VALIDf_GET
#define L2MCm_VALIDf_SET BCM56504_A0_L2MCm_VALIDf_SET
#define READ_L2MCm BCM56504_A0_READ_L2MCm
#define WRITE_L2MCm BCM56504_A0_WRITE_L2MCm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_L2MCm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  L2X
 * BLOCKS:   IPIPE
 * DESC:     Combined HW managed L2 entry table.  Includes L2_ENTRY, L2_HITDA, and L2_HITSA
 * SIZE:     92
 * FIELDS:
 *     MAC_ADDR         MAC address
 *     VLAN_ID          VLAN ID
 *     PRI              Priority
 *     CPU              CPU bit
 *     DST_DISCARD      Dst Discard
 *     SRC_DISCARD      Src Discard
 *     SCP              SCP bit
 *     PORT_TGID        Port or TGID
 *     MODULE_ID        Module ID
 *     L3               Indicates an L3 entry
 *     MAC_BLOCK_INDEX  MAC Block Index
 *     STATIC_BIT       Indicates entry is SW programmed and static
 *     RPE              RPE bit
 *     MIRROR           Mirror bit
 *     VALID            Indicates that the entry is valid
 *     HITDA            Dst hit update bit
 *     HITSA            Src hit update bit
 *     L2MC_PTR         Overlay of L2MC pointer
 *     TGID_LO          Overlay of TGID bit only - excludes T bit
 *     T                Trunk bit overlay
 *     TGID_HI          Legacy overlay of TGID on Module_ID
 *     REMOTE_TRUNK     Remote Trunk bit indicates HiGig pkt with remote modid
 *
 ******************************************************************************/
#define BCM56504_A0_L2Xm 0x06700000

#define BCM56504_A0_L2Xm_MIN 0
#define BCM56504_A0_L2Xm_MAX 16383
#define BCM56504_A0_L2Xm_CMAX(u) 16383
#define BCM56504_A0_L2Xm_SIZE 12

/*
 * This structure should be used to declare and program L2X.
 *
 */
typedef union BCM56504_A0_L2Xm_s {
	uint32_t v[3];
	uint32_t l2x[3];
	uint32_t _l2x;
} BCM56504_A0_L2Xm_t;

#define BCM56504_A0_L2Xm_CLR(r) CDK_MEMSET(&((r)._l2x), 0, sizeof(BCM56504_A0_L2Xm_t))
#define BCM56504_A0_L2Xm_SET(r,i,d) (r).l2x[i] = d
#define BCM56504_A0_L2Xm_GET(r,i) (r).l2x[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_L2Xm_MAC_ADDRf_GET(r,a) cdk_field_get((r).l2x,0,47,a)
#define BCM56504_A0_L2Xm_MAC_ADDRf_SET(r,a) cdk_field_set((r).l2x,0,47,a)
#define BCM56504_A0_L2Xm_VLAN_IDf_GET(r) ((((r).l2x[1]) >> 16) & 0xfff)
#define BCM56504_A0_L2Xm_VLAN_IDf_SET(r,f) (r).l2x[1]=(((r).l2x[1] & ~((uint32_t)0xfff << 16)) | ((((uint32_t)f) & 0xfff) << 16))
#define BCM56504_A0_L2Xm_PRIf_GET(r) ((((r).l2x[1]) >> 28) & 0x7)
#define BCM56504_A0_L2Xm_PRIf_SET(r,f) (r).l2x[1]=(((r).l2x[1] & ~((uint32_t)0x7 << 28)) | ((((uint32_t)f) & 0x7) << 28))
#define BCM56504_A0_L2Xm_CPUf_GET(r) ((((r).l2x[1]) >> 31) & 0x1)
#define BCM56504_A0_L2Xm_CPUf_SET(r,f) (r).l2x[1]=(((r).l2x[1] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM56504_A0_L2Xm_DST_DISCARDf_GET(r) (((r).l2x[2]) & 0x1)
#define BCM56504_A0_L2Xm_DST_DISCARDf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_L2Xm_SRC_DISCARDf_GET(r) ((((r).l2x[2]) >> 1) & 0x1)
#define BCM56504_A0_L2Xm_SRC_DISCARDf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_L2Xm_SCPf_GET(r) ((((r).l2x[2]) >> 2) & 0x1)
#define BCM56504_A0_L2Xm_SCPf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_L2Xm_PORT_TGIDf_GET(r) ((((r).l2x[2]) >> 3) & 0x3f)
#define BCM56504_A0_L2Xm_PORT_TGIDf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x3f << 3)) | ((((uint32_t)f) & 0x3f) << 3))
#define BCM56504_A0_L2Xm_MODULE_IDf_GET(r) ((((r).l2x[2]) >> 9) & 0x3f)
#define BCM56504_A0_L2Xm_MODULE_IDf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x3f << 9)) | ((((uint32_t)f) & 0x3f) << 9))
#define BCM56504_A0_L2Xm_L3f_GET(r) ((((r).l2x[2]) >> 15) & 0x1)
#define BCM56504_A0_L2Xm_L3f_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56504_A0_L2Xm_MAC_BLOCK_INDEXf_GET(r) ((((r).l2x[2]) >> 16) & 0x1f)
#define BCM56504_A0_L2Xm_MAC_BLOCK_INDEXf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define BCM56504_A0_L2Xm_STATIC_BITf_GET(r) ((((r).l2x[2]) >> 22) & 0x1)
#define BCM56504_A0_L2Xm_STATIC_BITf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM56504_A0_L2Xm_RPEf_GET(r) ((((r).l2x[2]) >> 23) & 0x1)
#define BCM56504_A0_L2Xm_RPEf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM56504_A0_L2Xm_MIRRORf_GET(r) ((((r).l2x[2]) >> 24) & 0x1)
#define BCM56504_A0_L2Xm_MIRRORf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM56504_A0_L2Xm_VALIDf_GET(r) ((((r).l2x[2]) >> 25) & 0x1)
#define BCM56504_A0_L2Xm_VALIDf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM56504_A0_L2Xm_HITDAf_GET(r) ((((r).l2x[2]) >> 26) & 0x1)
#define BCM56504_A0_L2Xm_HITDAf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM56504_A0_L2Xm_HITSAf_GET(r) ((((r).l2x[2]) >> 27) & 0x1)
#define BCM56504_A0_L2Xm_HITSAf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM56504_A0_L2Xm_L2MC_PTRf_GET(r) ((((r).l2x[2]) >> 3) & 0x3ff)
#define BCM56504_A0_L2Xm_L2MC_PTRf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x3ff << 3)) | ((((uint32_t)f) & 0x3ff) << 3))
#define BCM56504_A0_L2Xm_TGID_LOf_GET(r) ((((r).l2x[2]) >> 3) & 0x1f)
#define BCM56504_A0_L2Xm_TGID_LOf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x1f << 3)) | ((((uint32_t)f) & 0x1f) << 3))
#define BCM56504_A0_L2Xm_Tf_GET(r) ((((r).l2x[2]) >> 8) & 0x1)
#define BCM56504_A0_L2Xm_Tf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56504_A0_L2Xm_TGID_HIf_GET(r) ((((r).l2x[2]) >> 9) & 0x3)
#define BCM56504_A0_L2Xm_TGID_HIf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9))
#define BCM56504_A0_L2Xm_REMOTE_TRUNKf_GET(r) ((((r).l2x[2]) >> 14) & 0x1)
#define BCM56504_A0_L2Xm_REMOTE_TRUNKf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))

/*
 * These macros can be used to access L2X.
 *
 */
#define BCM56504_A0_READ_L2Xm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_L2Xm,i,(m._l2x),3)
#define BCM56504_A0_WRITE_L2Xm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_L2Xm,i,&(m._l2x),3)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2Xm BCM56504_A0_L2Xm
#define L2Xm_MIN BCM56504_A0_L2Xm_MIN
#define L2Xm_MAX BCM56504_A0_L2Xm_MAX
#define L2Xm_CMAX(u) BCM56504_A0_L2Xm_CMAX(u)
#define L2Xm_SIZE BCM56504_A0_L2Xm_SIZE
typedef BCM56504_A0_L2Xm_t L2Xm_t;
#define L2Xm_CLR BCM56504_A0_L2Xm_CLR
#define L2Xm_SET BCM56504_A0_L2Xm_SET
#define L2Xm_GET BCM56504_A0_L2Xm_GET
#define L2Xm_MAC_ADDRf_GET BCM56504_A0_L2Xm_MAC_ADDRf_GET
#define L2Xm_MAC_ADDRf_SET BCM56504_A0_L2Xm_MAC_ADDRf_SET
#define L2Xm_VLAN_IDf_GET BCM56504_A0_L2Xm_VLAN_IDf_GET
#define L2Xm_VLAN_IDf_SET BCM56504_A0_L2Xm_VLAN_IDf_SET
#define L2Xm_PRIf_GET BCM56504_A0_L2Xm_PRIf_GET
#define L2Xm_PRIf_SET BCM56504_A0_L2Xm_PRIf_SET
#define L2Xm_CPUf_GET BCM56504_A0_L2Xm_CPUf_GET
#define L2Xm_CPUf_SET BCM56504_A0_L2Xm_CPUf_SET
#define L2Xm_DST_DISCARDf_GET BCM56504_A0_L2Xm_DST_DISCARDf_GET
#define L2Xm_DST_DISCARDf_SET BCM56504_A0_L2Xm_DST_DISCARDf_SET
#define L2Xm_SRC_DISCARDf_GET BCM56504_A0_L2Xm_SRC_DISCARDf_GET
#define L2Xm_SRC_DISCARDf_SET BCM56504_A0_L2Xm_SRC_DISCARDf_SET
#define L2Xm_SCPf_GET BCM56504_A0_L2Xm_SCPf_GET
#define L2Xm_SCPf_SET BCM56504_A0_L2Xm_SCPf_SET
#define L2Xm_PORT_TGIDf_GET BCM56504_A0_L2Xm_PORT_TGIDf_GET
#define L2Xm_PORT_TGIDf_SET BCM56504_A0_L2Xm_PORT_TGIDf_SET
#define L2Xm_MODULE_IDf_GET BCM56504_A0_L2Xm_MODULE_IDf_GET
#define L2Xm_MODULE_IDf_SET BCM56504_A0_L2Xm_MODULE_IDf_SET
#define L2Xm_L3f_GET BCM56504_A0_L2Xm_L3f_GET
#define L2Xm_L3f_SET BCM56504_A0_L2Xm_L3f_SET
#define L2Xm_MAC_BLOCK_INDEXf_GET BCM56504_A0_L2Xm_MAC_BLOCK_INDEXf_GET
#define L2Xm_MAC_BLOCK_INDEXf_SET BCM56504_A0_L2Xm_MAC_BLOCK_INDEXf_SET
#define L2Xm_STATIC_BITf_GET BCM56504_A0_L2Xm_STATIC_BITf_GET
#define L2Xm_STATIC_BITf_SET BCM56504_A0_L2Xm_STATIC_BITf_SET
#define L2Xm_RPEf_GET BCM56504_A0_L2Xm_RPEf_GET
#define L2Xm_RPEf_SET BCM56504_A0_L2Xm_RPEf_SET
#define L2Xm_MIRRORf_GET BCM56504_A0_L2Xm_MIRRORf_GET
#define L2Xm_MIRRORf_SET BCM56504_A0_L2Xm_MIRRORf_SET
#define L2Xm_VALIDf_GET BCM56504_A0_L2Xm_VALIDf_GET
#define L2Xm_VALIDf_SET BCM56504_A0_L2Xm_VALIDf_SET
#define L2Xm_HITDAf_GET BCM56504_A0_L2Xm_HITDAf_GET
#define L2Xm_HITDAf_SET BCM56504_A0_L2Xm_HITDAf_SET
#define L2Xm_HITSAf_GET BCM56504_A0_L2Xm_HITSAf_GET
#define L2Xm_HITSAf_SET BCM56504_A0_L2Xm_HITSAf_SET
#define L2Xm_L2MC_PTRf_GET BCM56504_A0_L2Xm_L2MC_PTRf_GET
#define L2Xm_L2MC_PTRf_SET BCM56504_A0_L2Xm_L2MC_PTRf_SET
#define L2Xm_TGID_LOf_GET BCM56504_A0_L2Xm_TGID_LOf_GET
#define L2Xm_TGID_LOf_SET BCM56504_A0_L2Xm_TGID_LOf_SET
#define L2Xm_Tf_GET BCM56504_A0_L2Xm_Tf_GET
#define L2Xm_Tf_SET BCM56504_A0_L2Xm_Tf_SET
#define L2Xm_TGID_HIf_GET BCM56504_A0_L2Xm_TGID_HIf_GET
#define L2Xm_TGID_HIf_SET BCM56504_A0_L2Xm_TGID_HIf_SET
#define L2Xm_REMOTE_TRUNKf_GET BCM56504_A0_L2Xm_REMOTE_TRUNKf_GET
#define L2Xm_REMOTE_TRUNKf_SET BCM56504_A0_L2Xm_REMOTE_TRUNKf_SET
#define READ_L2Xm BCM56504_A0_READ_L2Xm
#define WRITE_L2Xm BCM56504_A0_WRITE_L2Xm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_L2Xm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  L2_AGE_DEBUG
 * BLOCKS:   IPIPE
 * DESC:     Age Debug Register
 * SIZE:     32
 * FIELDS:
 *     AGE_COUNT        Indicates last bucket to be aged (for all timer-based and per-port aging)
 *     START            initiate software-based timer aging (should not be started while timer-based aging is enabled)
 *     COMPLETE         signal software-based timer aging is complete
 *
 ******************************************************************************/
#define BCM56504_A0_L2_AGE_DEBUGr 0x00780005

#define BCM56504_A0_L2_AGE_DEBUGr_SIZE 4

/*
 * This structure should be used to declare and program L2_AGE_DEBUG.
 *
 */
typedef union BCM56504_A0_L2_AGE_DEBUGr_s {
	uint32_t v[1];
	uint32_t l2_age_debug[1];
	uint32_t _l2_age_debug;
} BCM56504_A0_L2_AGE_DEBUGr_t;

#define BCM56504_A0_L2_AGE_DEBUGr_CLR(r) (r).l2_age_debug[0] = 0
#define BCM56504_A0_L2_AGE_DEBUGr_SET(r,d) (r).l2_age_debug[0] = d
#define BCM56504_A0_L2_AGE_DEBUGr_GET(r) (r).l2_age_debug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_L2_AGE_DEBUGr_AGE_COUNTf_GET(r) (((r).l2_age_debug[0]) & 0x7ff)
#define BCM56504_A0_L2_AGE_DEBUGr_AGE_COUNTf_SET(r,f) (r).l2_age_debug[0]=(((r).l2_age_debug[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM56504_A0_L2_AGE_DEBUGr_STARTf_GET(r) ((((r).l2_age_debug[0]) >> 11) & 0x1)
#define BCM56504_A0_L2_AGE_DEBUGr_STARTf_SET(r,f) (r).l2_age_debug[0]=(((r).l2_age_debug[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56504_A0_L2_AGE_DEBUGr_COMPLETEf_GET(r) ((((r).l2_age_debug[0]) >> 12) & 0x1)
#define BCM56504_A0_L2_AGE_DEBUGr_COMPLETEf_SET(r,f) (r).l2_age_debug[0]=(((r).l2_age_debug[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))

/*
 * These macros can be used to access L2_AGE_DEBUG.
 *
 */
#define BCM56504_A0_READ_L2_AGE_DEBUGr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_L2_AGE_DEBUGr,(r._l2_age_debug))
#define BCM56504_A0_WRITE_L2_AGE_DEBUGr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_L2_AGE_DEBUGr,&(r._l2_age_debug))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_AGE_DEBUGr BCM56504_A0_L2_AGE_DEBUGr
#define L2_AGE_DEBUGr_SIZE BCM56504_A0_L2_AGE_DEBUGr_SIZE
typedef BCM56504_A0_L2_AGE_DEBUGr_t L2_AGE_DEBUGr_t;
#define L2_AGE_DEBUGr_CLR BCM56504_A0_L2_AGE_DEBUGr_CLR
#define L2_AGE_DEBUGr_SET BCM56504_A0_L2_AGE_DEBUGr_SET
#define L2_AGE_DEBUGr_GET BCM56504_A0_L2_AGE_DEBUGr_GET
#define L2_AGE_DEBUGr_AGE_COUNTf_GET BCM56504_A0_L2_AGE_DEBUGr_AGE_COUNTf_GET
#define L2_AGE_DEBUGr_AGE_COUNTf_SET BCM56504_A0_L2_AGE_DEBUGr_AGE_COUNTf_SET
#define L2_AGE_DEBUGr_STARTf_GET BCM56504_A0_L2_AGE_DEBUGr_STARTf_GET
#define L2_AGE_DEBUGr_STARTf_SET BCM56504_A0_L2_AGE_DEBUGr_STARTf_SET
#define L2_AGE_DEBUGr_COMPLETEf_GET BCM56504_A0_L2_AGE_DEBUGr_COMPLETEf_GET
#define L2_AGE_DEBUGr_COMPLETEf_SET BCM56504_A0_L2_AGE_DEBUGr_COMPLETEf_SET
#define READ_L2_AGE_DEBUGr BCM56504_A0_READ_L2_AGE_DEBUGr
#define WRITE_L2_AGE_DEBUGr BCM56504_A0_WRITE_L2_AGE_DEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_L2_AGE_DEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  L2_AGE_TIMER
 * BLOCKS:   IPIPE
 * DESC:     Age Timer Register
 * SIZE:     32
 * FIELDS:
 *     AGE_VAL          Age Limit
 *     AGE_ENA          Age Enable
 *
 ******************************************************************************/
#define BCM56504_A0_L2_AGE_TIMERr 0x00780003

#define BCM56504_A0_L2_AGE_TIMERr_SIZE 4

/*
 * This structure should be used to declare and program L2_AGE_TIMER.
 *
 */
typedef union BCM56504_A0_L2_AGE_TIMERr_s {
	uint32_t v[1];
	uint32_t l2_age_timer[1];
	uint32_t _l2_age_timer;
} BCM56504_A0_L2_AGE_TIMERr_t;

#define BCM56504_A0_L2_AGE_TIMERr_CLR(r) (r).l2_age_timer[0] = 0
#define BCM56504_A0_L2_AGE_TIMERr_SET(r,d) (r).l2_age_timer[0] = d
#define BCM56504_A0_L2_AGE_TIMERr_GET(r) (r).l2_age_timer[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_L2_AGE_TIMERr_AGE_VALf_GET(r) (((r).l2_age_timer[0]) & 0xfffff)
#define BCM56504_A0_L2_AGE_TIMERr_AGE_VALf_SET(r,f) (r).l2_age_timer[0]=(((r).l2_age_timer[0] & ~((uint32_t)0xfffff)) | (((uint32_t)f) & 0xfffff))
#define BCM56504_A0_L2_AGE_TIMERr_AGE_ENAf_GET(r) ((((r).l2_age_timer[0]) >> 20) & 0x1)
#define BCM56504_A0_L2_AGE_TIMERr_AGE_ENAf_SET(r,f) (r).l2_age_timer[0]=(((r).l2_age_timer[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))

/*
 * These macros can be used to access L2_AGE_TIMER.
 *
 */
#define BCM56504_A0_READ_L2_AGE_TIMERr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_L2_AGE_TIMERr,(r._l2_age_timer))
#define BCM56504_A0_WRITE_L2_AGE_TIMERr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_L2_AGE_TIMERr,&(r._l2_age_timer))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_AGE_TIMERr BCM56504_A0_L2_AGE_TIMERr
#define L2_AGE_TIMERr_SIZE BCM56504_A0_L2_AGE_TIMERr_SIZE
typedef BCM56504_A0_L2_AGE_TIMERr_t L2_AGE_TIMERr_t;
#define L2_AGE_TIMERr_CLR BCM56504_A0_L2_AGE_TIMERr_CLR
#define L2_AGE_TIMERr_SET BCM56504_A0_L2_AGE_TIMERr_SET
#define L2_AGE_TIMERr_GET BCM56504_A0_L2_AGE_TIMERr_GET
#define L2_AGE_TIMERr_AGE_VALf_GET BCM56504_A0_L2_AGE_TIMERr_AGE_VALf_GET
#define L2_AGE_TIMERr_AGE_VALf_SET BCM56504_A0_L2_AGE_TIMERr_AGE_VALf_SET
#define L2_AGE_TIMERr_AGE_ENAf_GET BCM56504_A0_L2_AGE_TIMERr_AGE_ENAf_GET
#define L2_AGE_TIMERr_AGE_ENAf_SET BCM56504_A0_L2_AGE_TIMERr_AGE_ENAf_SET
#define READ_L2_AGE_TIMERr BCM56504_A0_READ_L2_AGE_TIMERr
#define WRITE_L2_AGE_TIMERr BCM56504_A0_WRITE_L2_AGE_TIMERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_L2_AGE_TIMERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  L2_ENTRY_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     L2_ENTRY_CONTROL
 * SIZE:     32
 * FIELDS:
 *     RAM0_CT0         CT debug bit 0 for RAM0
 *     RAM0_CT1         CT debug bit 1 for RAM0
 *     RAM0_CT2         CT debug bit 2 for RAM0
 *     RAM1_CT0         CT debug bit 0 for RAM1
 *     RAM1_CT1         CT debug bit 1 for RAM1
 *     RAM1_CT2         CT debug bit 2 for RAM1
 *     RAM2_CT0         CT debug bit 0 for RAM2
 *     RAM2_CT1         CT debug bit 1 for RAM2
 *     RAM2_CT2         CT debug bit 2 for RAM2
 *     RAM3_CT0         CT debug bit 0 for RAM3
 *     RAM3_CT1         CT debug bit 1 for RAM3
 *     RAM3_CT2         CT debug bit 2 for RAM3
 *     RAM0_SAM         SAM debug bits for RAM0
 *     RAM1_SAM         SAM debug bits for RAM1
 *     RAM2_SAM         SAM debug bits for RAM2
 *     RAM3_SAM         SAM debug bits for RAM3
 *
 ******************************************************************************/
#define BCM56504_A0_L2_ENTRY_CONTROLr 0x06780009

#define BCM56504_A0_L2_ENTRY_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program L2_ENTRY_CONTROL.
 *
 */
typedef union BCM56504_A0_L2_ENTRY_CONTROLr_s {
	uint32_t v[1];
	uint32_t l2_entry_control[1];
	uint32_t _l2_entry_control;
} BCM56504_A0_L2_ENTRY_CONTROLr_t;

#define BCM56504_A0_L2_ENTRY_CONTROLr_CLR(r) (r).l2_entry_control[0] = 0
#define BCM56504_A0_L2_ENTRY_CONTROLr_SET(r,d) (r).l2_entry_control[0] = d
#define BCM56504_A0_L2_ENTRY_CONTROLr_GET(r) (r).l2_entry_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_L2_ENTRY_CONTROLr_RAM0_CT0f_GET(r) (((r).l2_entry_control[0]) & 0x1)
#define BCM56504_A0_L2_ENTRY_CONTROLr_RAM0_CT0f_SET(r,f) (r).l2_entry_control[0]=(((r).l2_entry_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_L2_ENTRY_CONTROLr_RAM0_CT1f_GET(r) ((((r).l2_entry_control[0]) >> 1) & 0x1)
#define BCM56504_A0_L2_ENTRY_CONTROLr_RAM0_CT1f_SET(r,f) (r).l2_entry_control[0]=(((r).l2_entry_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_L2_ENTRY_CONTROLr_RAM0_CT2f_GET(r) ((((r).l2_entry_control[0]) >> 2) & 0x1)
#define BCM56504_A0_L2_ENTRY_CONTROLr_RAM0_CT2f_SET(r,f) (r).l2_entry_control[0]=(((r).l2_entry_control[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_L2_ENTRY_CONTROLr_RAM1_CT0f_GET(r) ((((r).l2_entry_control[0]) >> 3) & 0x1)
#define BCM56504_A0_L2_ENTRY_CONTROLr_RAM1_CT0f_SET(r,f) (r).l2_entry_control[0]=(((r).l2_entry_control[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_L2_ENTRY_CONTROLr_RAM1_CT1f_GET(r) ((((r).l2_entry_control[0]) >> 4) & 0x1)
#define BCM56504_A0_L2_ENTRY_CONTROLr_RAM1_CT1f_SET(r,f) (r).l2_entry_control[0]=(((r).l2_entry_control[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56504_A0_L2_ENTRY_CONTROLr_RAM1_CT2f_GET(r) ((((r).l2_entry_control[0]) >> 5) & 0x1)
#define BCM56504_A0_L2_ENTRY_CONTROLr_RAM1_CT2f_SET(r,f) (r).l2_entry_control[0]=(((r).l2_entry_control[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56504_A0_L2_ENTRY_CONTROLr_RAM2_CT0f_GET(r) ((((r).l2_entry_control[0]) >> 6) & 0x1)
#define BCM56504_A0_L2_ENTRY_CONTROLr_RAM2_CT0f_SET(r,f) (r).l2_entry_control[0]=(((r).l2_entry_control[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56504_A0_L2_ENTRY_CONTROLr_RAM2_CT1f_GET(r) ((((r).l2_entry_control[0]) >> 7) & 0x1)
#define BCM56504_A0_L2_ENTRY_CONTROLr_RAM2_CT1f_SET(r,f) (r).l2_entry_control[0]=(((r).l2_entry_control[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56504_A0_L2_ENTRY_CONTROLr_RAM2_CT2f_GET(r) ((((r).l2_entry_control[0]) >> 8) & 0x1)
#define BCM56504_A0_L2_ENTRY_CONTROLr_RAM2_CT2f_SET(r,f) (r).l2_entry_control[0]=(((r).l2_entry_control[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56504_A0_L2_ENTRY_CONTROLr_RAM3_CT0f_GET(r) ((((r).l2_entry_control[0]) >> 9) & 0x1)
#define BCM56504_A0_L2_ENTRY_CONTROLr_RAM3_CT0f_SET(r,f) (r).l2_entry_control[0]=(((r).l2_entry_control[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56504_A0_L2_ENTRY_CONTROLr_RAM3_CT1f_GET(r) ((((r).l2_entry_control[0]) >> 10) & 0x1)
#define BCM56504_A0_L2_ENTRY_CONTROLr_RAM3_CT1f_SET(r,f) (r).l2_entry_control[0]=(((r).l2_entry_control[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56504_A0_L2_ENTRY_CONTROLr_RAM3_CT2f_GET(r) ((((r).l2_entry_control[0]) >> 11) & 0x1)
#define BCM56504_A0_L2_ENTRY_CONTROLr_RAM3_CT2f_SET(r,f) (r).l2_entry_control[0]=(((r).l2_entry_control[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56504_A0_L2_ENTRY_CONTROLr_RAM0_SAMf_GET(r) ((((r).l2_entry_control[0]) >> 12) & 0x3)
#define BCM56504_A0_L2_ENTRY_CONTROLr_RAM0_SAMf_SET(r,f) (r).l2_entry_control[0]=(((r).l2_entry_control[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM56504_A0_L2_ENTRY_CONTROLr_RAM1_SAMf_GET(r) ((((r).l2_entry_control[0]) >> 14) & 0x3)
#define BCM56504_A0_L2_ENTRY_CONTROLr_RAM1_SAMf_SET(r,f) (r).l2_entry_control[0]=(((r).l2_entry_control[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCM56504_A0_L2_ENTRY_CONTROLr_RAM2_SAMf_GET(r) ((((r).l2_entry_control[0]) >> 16) & 0x3)
#define BCM56504_A0_L2_ENTRY_CONTROLr_RAM2_SAMf_SET(r,f) (r).l2_entry_control[0]=(((r).l2_entry_control[0] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM56504_A0_L2_ENTRY_CONTROLr_RAM3_SAMf_GET(r) ((((r).l2_entry_control[0]) >> 18) & 0x3)
#define BCM56504_A0_L2_ENTRY_CONTROLr_RAM3_SAMf_SET(r,f) (r).l2_entry_control[0]=(((r).l2_entry_control[0] & ~((uint32_t)0x3 << 18)) | ((((uint32_t)f) & 0x3) << 18))

/*
 * These macros can be used to access L2_ENTRY_CONTROL.
 *
 */
#define BCM56504_A0_READ_L2_ENTRY_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_L2_ENTRY_CONTROLr,(r._l2_entry_control))
#define BCM56504_A0_WRITE_L2_ENTRY_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_L2_ENTRY_CONTROLr,&(r._l2_entry_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_ENTRY_CONTROLr BCM56504_A0_L2_ENTRY_CONTROLr
#define L2_ENTRY_CONTROLr_SIZE BCM56504_A0_L2_ENTRY_CONTROLr_SIZE
typedef BCM56504_A0_L2_ENTRY_CONTROLr_t L2_ENTRY_CONTROLr_t;
#define L2_ENTRY_CONTROLr_CLR BCM56504_A0_L2_ENTRY_CONTROLr_CLR
#define L2_ENTRY_CONTROLr_SET BCM56504_A0_L2_ENTRY_CONTROLr_SET
#define L2_ENTRY_CONTROLr_GET BCM56504_A0_L2_ENTRY_CONTROLr_GET
#define L2_ENTRY_CONTROLr_RAM0_CT0f_GET BCM56504_A0_L2_ENTRY_CONTROLr_RAM0_CT0f_GET
#define L2_ENTRY_CONTROLr_RAM0_CT0f_SET BCM56504_A0_L2_ENTRY_CONTROLr_RAM0_CT0f_SET
#define L2_ENTRY_CONTROLr_RAM0_CT1f_GET BCM56504_A0_L2_ENTRY_CONTROLr_RAM0_CT1f_GET
#define L2_ENTRY_CONTROLr_RAM0_CT1f_SET BCM56504_A0_L2_ENTRY_CONTROLr_RAM0_CT1f_SET
#define L2_ENTRY_CONTROLr_RAM0_CT2f_GET BCM56504_A0_L2_ENTRY_CONTROLr_RAM0_CT2f_GET
#define L2_ENTRY_CONTROLr_RAM0_CT2f_SET BCM56504_A0_L2_ENTRY_CONTROLr_RAM0_CT2f_SET
#define L2_ENTRY_CONTROLr_RAM1_CT0f_GET BCM56504_A0_L2_ENTRY_CONTROLr_RAM1_CT0f_GET
#define L2_ENTRY_CONTROLr_RAM1_CT0f_SET BCM56504_A0_L2_ENTRY_CONTROLr_RAM1_CT0f_SET
#define L2_ENTRY_CONTROLr_RAM1_CT1f_GET BCM56504_A0_L2_ENTRY_CONTROLr_RAM1_CT1f_GET
#define L2_ENTRY_CONTROLr_RAM1_CT1f_SET BCM56504_A0_L2_ENTRY_CONTROLr_RAM1_CT1f_SET
#define L2_ENTRY_CONTROLr_RAM1_CT2f_GET BCM56504_A0_L2_ENTRY_CONTROLr_RAM1_CT2f_GET
#define L2_ENTRY_CONTROLr_RAM1_CT2f_SET BCM56504_A0_L2_ENTRY_CONTROLr_RAM1_CT2f_SET
#define L2_ENTRY_CONTROLr_RAM2_CT0f_GET BCM56504_A0_L2_ENTRY_CONTROLr_RAM2_CT0f_GET
#define L2_ENTRY_CONTROLr_RAM2_CT0f_SET BCM56504_A0_L2_ENTRY_CONTROLr_RAM2_CT0f_SET
#define L2_ENTRY_CONTROLr_RAM2_CT1f_GET BCM56504_A0_L2_ENTRY_CONTROLr_RAM2_CT1f_GET
#define L2_ENTRY_CONTROLr_RAM2_CT1f_SET BCM56504_A0_L2_ENTRY_CONTROLr_RAM2_CT1f_SET
#define L2_ENTRY_CONTROLr_RAM2_CT2f_GET BCM56504_A0_L2_ENTRY_CONTROLr_RAM2_CT2f_GET
#define L2_ENTRY_CONTROLr_RAM2_CT2f_SET BCM56504_A0_L2_ENTRY_CONTROLr_RAM2_CT2f_SET
#define L2_ENTRY_CONTROLr_RAM3_CT0f_GET BCM56504_A0_L2_ENTRY_CONTROLr_RAM3_CT0f_GET
#define L2_ENTRY_CONTROLr_RAM3_CT0f_SET BCM56504_A0_L2_ENTRY_CONTROLr_RAM3_CT0f_SET
#define L2_ENTRY_CONTROLr_RAM3_CT1f_GET BCM56504_A0_L2_ENTRY_CONTROLr_RAM3_CT1f_GET
#define L2_ENTRY_CONTROLr_RAM3_CT1f_SET BCM56504_A0_L2_ENTRY_CONTROLr_RAM3_CT1f_SET
#define L2_ENTRY_CONTROLr_RAM3_CT2f_GET BCM56504_A0_L2_ENTRY_CONTROLr_RAM3_CT2f_GET
#define L2_ENTRY_CONTROLr_RAM3_CT2f_SET BCM56504_A0_L2_ENTRY_CONTROLr_RAM3_CT2f_SET
#define L2_ENTRY_CONTROLr_RAM0_SAMf_GET BCM56504_A0_L2_ENTRY_CONTROLr_RAM0_SAMf_GET
#define L2_ENTRY_CONTROLr_RAM0_SAMf_SET BCM56504_A0_L2_ENTRY_CONTROLr_RAM0_SAMf_SET
#define L2_ENTRY_CONTROLr_RAM1_SAMf_GET BCM56504_A0_L2_ENTRY_CONTROLr_RAM1_SAMf_GET
#define L2_ENTRY_CONTROLr_RAM1_SAMf_SET BCM56504_A0_L2_ENTRY_CONTROLr_RAM1_SAMf_SET
#define L2_ENTRY_CONTROLr_RAM2_SAMf_GET BCM56504_A0_L2_ENTRY_CONTROLr_RAM2_SAMf_GET
#define L2_ENTRY_CONTROLr_RAM2_SAMf_SET BCM56504_A0_L2_ENTRY_CONTROLr_RAM2_SAMf_SET
#define L2_ENTRY_CONTROLr_RAM3_SAMf_GET BCM56504_A0_L2_ENTRY_CONTROLr_RAM3_SAMf_GET
#define L2_ENTRY_CONTROLr_RAM3_SAMf_SET BCM56504_A0_L2_ENTRY_CONTROLr_RAM3_SAMf_SET
#define READ_L2_ENTRY_CONTROLr BCM56504_A0_READ_L2_ENTRY_CONTROLr
#define WRITE_L2_ENTRY_CONTROLr BCM56504_A0_WRITE_L2_ENTRY_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_L2_ENTRY_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  L2_ENTRY_ONLY
 * BLOCKS:   IPIPE
 * DESC:     HW managed L2_ENTRY table only.  Does not include L2_HITSA or L2_HITDA
 * SIZE:     90
 * FIELDS:
 *     MAC_ADDR         MAC address
 *     VLAN_ID          VLAN ID
 *     PRI              Priority
 *     CPU              CPU bit
 *     DST_DISCARD      Dst Discard
 *     SRC_DISCARD      Src Discard
 *     SCP              SCP bit
 *     PORT_TGID        Port or TGID
 *     MODULE_ID        Module ID
 *     L3               Indicates an L3 entry
 *     MAC_BLOCK_INDEX  MAC Block Index
 *     STATIC_BIT       Indicates entry is SW programmed and static
 *     RPE              RPE bit
 *     MIRROR           Mirror bit
 *     VALID            Indicates that the entry is valid
 *     L2MC_PTR         Overlay of L2MC pointer
 *     TGID_LO          Overlay of TGID bit only - excludes T bit
 *     T                Trunk bit overlay
 *     TGID_HI          Legacy overlay of TGID on Module_ID
 *     REMOTE_TRUNK     Remote Trunk bit indicates HiGig pkt with remote modid
 *
 ******************************************************************************/
#define BCM56504_A0_L2_ENTRY_ONLYm 0x06710000

#define BCM56504_A0_L2_ENTRY_ONLYm_MIN 0
#define BCM56504_A0_L2_ENTRY_ONLYm_MAX 16383
#define BCM56504_A0_L2_ENTRY_ONLYm_CMAX(u) 16383
#define BCM56504_A0_L2_ENTRY_ONLYm_SIZE 12

/*
 * This structure should be used to declare and program L2_ENTRY_ONLY.
 *
 */
typedef union BCM56504_A0_L2_ENTRY_ONLYm_s {
	uint32_t v[3];
	uint32_t l2_entry_only[3];
	uint32_t _l2_entry_only;
} BCM56504_A0_L2_ENTRY_ONLYm_t;

#define BCM56504_A0_L2_ENTRY_ONLYm_CLR(r) CDK_MEMSET(&((r)._l2_entry_only), 0, sizeof(BCM56504_A0_L2_ENTRY_ONLYm_t))
#define BCM56504_A0_L2_ENTRY_ONLYm_SET(r,i,d) (r).l2_entry_only[i] = d
#define BCM56504_A0_L2_ENTRY_ONLYm_GET(r,i) (r).l2_entry_only[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_L2_ENTRY_ONLYm_MAC_ADDRf_GET(r,a) cdk_field_get((r).l2_entry_only,0,47,a)
#define BCM56504_A0_L2_ENTRY_ONLYm_MAC_ADDRf_SET(r,a) cdk_field_set((r).l2_entry_only,0,47,a)
#define BCM56504_A0_L2_ENTRY_ONLYm_VLAN_IDf_GET(r) ((((r).l2_entry_only[1]) >> 16) & 0xfff)
#define BCM56504_A0_L2_ENTRY_ONLYm_VLAN_IDf_SET(r,f) (r).l2_entry_only[1]=(((r).l2_entry_only[1] & ~((uint32_t)0xfff << 16)) | ((((uint32_t)f) & 0xfff) << 16))
#define BCM56504_A0_L2_ENTRY_ONLYm_PRIf_GET(r) ((((r).l2_entry_only[1]) >> 28) & 0x7)
#define BCM56504_A0_L2_ENTRY_ONLYm_PRIf_SET(r,f) (r).l2_entry_only[1]=(((r).l2_entry_only[1] & ~((uint32_t)0x7 << 28)) | ((((uint32_t)f) & 0x7) << 28))
#define BCM56504_A0_L2_ENTRY_ONLYm_CPUf_GET(r) ((((r).l2_entry_only[1]) >> 31) & 0x1)
#define BCM56504_A0_L2_ENTRY_ONLYm_CPUf_SET(r,f) (r).l2_entry_only[1]=(((r).l2_entry_only[1] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM56504_A0_L2_ENTRY_ONLYm_DST_DISCARDf_GET(r) (((r).l2_entry_only[2]) & 0x1)
#define BCM56504_A0_L2_ENTRY_ONLYm_DST_DISCARDf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_L2_ENTRY_ONLYm_SRC_DISCARDf_GET(r) ((((r).l2_entry_only[2]) >> 1) & 0x1)
#define BCM56504_A0_L2_ENTRY_ONLYm_SRC_DISCARDf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_L2_ENTRY_ONLYm_SCPf_GET(r) ((((r).l2_entry_only[2]) >> 2) & 0x1)
#define BCM56504_A0_L2_ENTRY_ONLYm_SCPf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_L2_ENTRY_ONLYm_PORT_TGIDf_GET(r) ((((r).l2_entry_only[2]) >> 3) & 0x3f)
#define BCM56504_A0_L2_ENTRY_ONLYm_PORT_TGIDf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x3f << 3)) | ((((uint32_t)f) & 0x3f) << 3))
#define BCM56504_A0_L2_ENTRY_ONLYm_MODULE_IDf_GET(r) ((((r).l2_entry_only[2]) >> 9) & 0x3f)
#define BCM56504_A0_L2_ENTRY_ONLYm_MODULE_IDf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x3f << 9)) | ((((uint32_t)f) & 0x3f) << 9))
#define BCM56504_A0_L2_ENTRY_ONLYm_L3f_GET(r) ((((r).l2_entry_only[2]) >> 15) & 0x1)
#define BCM56504_A0_L2_ENTRY_ONLYm_L3f_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56504_A0_L2_ENTRY_ONLYm_MAC_BLOCK_INDEXf_GET(r) ((((r).l2_entry_only[2]) >> 16) & 0x1f)
#define BCM56504_A0_L2_ENTRY_ONLYm_MAC_BLOCK_INDEXf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define BCM56504_A0_L2_ENTRY_ONLYm_STATIC_BITf_GET(r) ((((r).l2_entry_only[2]) >> 22) & 0x1)
#define BCM56504_A0_L2_ENTRY_ONLYm_STATIC_BITf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM56504_A0_L2_ENTRY_ONLYm_RPEf_GET(r) ((((r).l2_entry_only[2]) >> 23) & 0x1)
#define BCM56504_A0_L2_ENTRY_ONLYm_RPEf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM56504_A0_L2_ENTRY_ONLYm_MIRRORf_GET(r) ((((r).l2_entry_only[2]) >> 24) & 0x1)
#define BCM56504_A0_L2_ENTRY_ONLYm_MIRRORf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM56504_A0_L2_ENTRY_ONLYm_VALIDf_GET(r) ((((r).l2_entry_only[2]) >> 25) & 0x1)
#define BCM56504_A0_L2_ENTRY_ONLYm_VALIDf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM56504_A0_L2_ENTRY_ONLYm_L2MC_PTRf_GET(r) ((((r).l2_entry_only[2]) >> 3) & 0x3ff)
#define BCM56504_A0_L2_ENTRY_ONLYm_L2MC_PTRf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x3ff << 3)) | ((((uint32_t)f) & 0x3ff) << 3))
#define BCM56504_A0_L2_ENTRY_ONLYm_TGID_LOf_GET(r) ((((r).l2_entry_only[2]) >> 3) & 0x1f)
#define BCM56504_A0_L2_ENTRY_ONLYm_TGID_LOf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x1f << 3)) | ((((uint32_t)f) & 0x1f) << 3))
#define BCM56504_A0_L2_ENTRY_ONLYm_Tf_GET(r) ((((r).l2_entry_only[2]) >> 8) & 0x1)
#define BCM56504_A0_L2_ENTRY_ONLYm_Tf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56504_A0_L2_ENTRY_ONLYm_TGID_HIf_GET(r) ((((r).l2_entry_only[2]) >> 9) & 0x3)
#define BCM56504_A0_L2_ENTRY_ONLYm_TGID_HIf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9))
#define BCM56504_A0_L2_ENTRY_ONLYm_REMOTE_TRUNKf_GET(r) ((((r).l2_entry_only[2]) >> 14) & 0x1)
#define BCM56504_A0_L2_ENTRY_ONLYm_REMOTE_TRUNKf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))

/*
 * These macros can be used to access L2_ENTRY_ONLY.
 *
 */
#define BCM56504_A0_READ_L2_ENTRY_ONLYm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_L2_ENTRY_ONLYm,i,(m._l2_entry_only),3)
#define BCM56504_A0_WRITE_L2_ENTRY_ONLYm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_L2_ENTRY_ONLYm,i,&(m._l2_entry_only),3)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_ENTRY_ONLYm BCM56504_A0_L2_ENTRY_ONLYm
#define L2_ENTRY_ONLYm_MIN BCM56504_A0_L2_ENTRY_ONLYm_MIN
#define L2_ENTRY_ONLYm_MAX BCM56504_A0_L2_ENTRY_ONLYm_MAX
#define L2_ENTRY_ONLYm_CMAX(u) BCM56504_A0_L2_ENTRY_ONLYm_CMAX(u)
#define L2_ENTRY_ONLYm_SIZE BCM56504_A0_L2_ENTRY_ONLYm_SIZE
typedef BCM56504_A0_L2_ENTRY_ONLYm_t L2_ENTRY_ONLYm_t;
#define L2_ENTRY_ONLYm_CLR BCM56504_A0_L2_ENTRY_ONLYm_CLR
#define L2_ENTRY_ONLYm_SET BCM56504_A0_L2_ENTRY_ONLYm_SET
#define L2_ENTRY_ONLYm_GET BCM56504_A0_L2_ENTRY_ONLYm_GET
#define L2_ENTRY_ONLYm_MAC_ADDRf_GET BCM56504_A0_L2_ENTRY_ONLYm_MAC_ADDRf_GET
#define L2_ENTRY_ONLYm_MAC_ADDRf_SET BCM56504_A0_L2_ENTRY_ONLYm_MAC_ADDRf_SET
#define L2_ENTRY_ONLYm_VLAN_IDf_GET BCM56504_A0_L2_ENTRY_ONLYm_VLAN_IDf_GET
#define L2_ENTRY_ONLYm_VLAN_IDf_SET BCM56504_A0_L2_ENTRY_ONLYm_VLAN_IDf_SET
#define L2_ENTRY_ONLYm_PRIf_GET BCM56504_A0_L2_ENTRY_ONLYm_PRIf_GET
#define L2_ENTRY_ONLYm_PRIf_SET BCM56504_A0_L2_ENTRY_ONLYm_PRIf_SET
#define L2_ENTRY_ONLYm_CPUf_GET BCM56504_A0_L2_ENTRY_ONLYm_CPUf_GET
#define L2_ENTRY_ONLYm_CPUf_SET BCM56504_A0_L2_ENTRY_ONLYm_CPUf_SET
#define L2_ENTRY_ONLYm_DST_DISCARDf_GET BCM56504_A0_L2_ENTRY_ONLYm_DST_DISCARDf_GET
#define L2_ENTRY_ONLYm_DST_DISCARDf_SET BCM56504_A0_L2_ENTRY_ONLYm_DST_DISCARDf_SET
#define L2_ENTRY_ONLYm_SRC_DISCARDf_GET BCM56504_A0_L2_ENTRY_ONLYm_SRC_DISCARDf_GET
#define L2_ENTRY_ONLYm_SRC_DISCARDf_SET BCM56504_A0_L2_ENTRY_ONLYm_SRC_DISCARDf_SET
#define L2_ENTRY_ONLYm_SCPf_GET BCM56504_A0_L2_ENTRY_ONLYm_SCPf_GET
#define L2_ENTRY_ONLYm_SCPf_SET BCM56504_A0_L2_ENTRY_ONLYm_SCPf_SET
#define L2_ENTRY_ONLYm_PORT_TGIDf_GET BCM56504_A0_L2_ENTRY_ONLYm_PORT_TGIDf_GET
#define L2_ENTRY_ONLYm_PORT_TGIDf_SET BCM56504_A0_L2_ENTRY_ONLYm_PORT_TGIDf_SET
#define L2_ENTRY_ONLYm_MODULE_IDf_GET BCM56504_A0_L2_ENTRY_ONLYm_MODULE_IDf_GET
#define L2_ENTRY_ONLYm_MODULE_IDf_SET BCM56504_A0_L2_ENTRY_ONLYm_MODULE_IDf_SET
#define L2_ENTRY_ONLYm_L3f_GET BCM56504_A0_L2_ENTRY_ONLYm_L3f_GET
#define L2_ENTRY_ONLYm_L3f_SET BCM56504_A0_L2_ENTRY_ONLYm_L3f_SET
#define L2_ENTRY_ONLYm_MAC_BLOCK_INDEXf_GET BCM56504_A0_L2_ENTRY_ONLYm_MAC_BLOCK_INDEXf_GET
#define L2_ENTRY_ONLYm_MAC_BLOCK_INDEXf_SET BCM56504_A0_L2_ENTRY_ONLYm_MAC_BLOCK_INDEXf_SET
#define L2_ENTRY_ONLYm_STATIC_BITf_GET BCM56504_A0_L2_ENTRY_ONLYm_STATIC_BITf_GET
#define L2_ENTRY_ONLYm_STATIC_BITf_SET BCM56504_A0_L2_ENTRY_ONLYm_STATIC_BITf_SET
#define L2_ENTRY_ONLYm_RPEf_GET BCM56504_A0_L2_ENTRY_ONLYm_RPEf_GET
#define L2_ENTRY_ONLYm_RPEf_SET BCM56504_A0_L2_ENTRY_ONLYm_RPEf_SET
#define L2_ENTRY_ONLYm_MIRRORf_GET BCM56504_A0_L2_ENTRY_ONLYm_MIRRORf_GET
#define L2_ENTRY_ONLYm_MIRRORf_SET BCM56504_A0_L2_ENTRY_ONLYm_MIRRORf_SET
#define L2_ENTRY_ONLYm_VALIDf_GET BCM56504_A0_L2_ENTRY_ONLYm_VALIDf_GET
#define L2_ENTRY_ONLYm_VALIDf_SET BCM56504_A0_L2_ENTRY_ONLYm_VALIDf_SET
#define L2_ENTRY_ONLYm_L2MC_PTRf_GET BCM56504_A0_L2_ENTRY_ONLYm_L2MC_PTRf_GET
#define L2_ENTRY_ONLYm_L2MC_PTRf_SET BCM56504_A0_L2_ENTRY_ONLYm_L2MC_PTRf_SET
#define L2_ENTRY_ONLYm_TGID_LOf_GET BCM56504_A0_L2_ENTRY_ONLYm_TGID_LOf_GET
#define L2_ENTRY_ONLYm_TGID_LOf_SET BCM56504_A0_L2_ENTRY_ONLYm_TGID_LOf_SET
#define L2_ENTRY_ONLYm_Tf_GET BCM56504_A0_L2_ENTRY_ONLYm_Tf_GET
#define L2_ENTRY_ONLYm_Tf_SET BCM56504_A0_L2_ENTRY_ONLYm_Tf_SET
#define L2_ENTRY_ONLYm_TGID_HIf_GET BCM56504_A0_L2_ENTRY_ONLYm_TGID_HIf_GET
#define L2_ENTRY_ONLYm_TGID_HIf_SET BCM56504_A0_L2_ENTRY_ONLYm_TGID_HIf_SET
#define L2_ENTRY_ONLYm_REMOTE_TRUNKf_GET BCM56504_A0_L2_ENTRY_ONLYm_REMOTE_TRUNKf_GET
#define L2_ENTRY_ONLYm_REMOTE_TRUNKf_SET BCM56504_A0_L2_ENTRY_ONLYm_REMOTE_TRUNKf_SET
#define READ_L2_ENTRY_ONLYm BCM56504_A0_READ_L2_ENTRY_ONLYm
#define WRITE_L2_ENTRY_ONLYm BCM56504_A0_WRITE_L2_ENTRY_ONLYm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_L2_ENTRY_ONLYm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  L2_HITDA_ONLY
 * BLOCKS:   IPIPE
 * DESC:     HW managed L2_HITDA_ONLY table.  Just the DA hit bits.
 * SIZE:     8
 * FIELDS:
 *     HITDA_0          Hit bit set on Destination MAC addrs hits
 *     HITDA_1          Hit bit set on Destination MAC addrs hits
 *     HITDA_2          Hit bit set on Destination MAC addrs hits
 *     HITDA_3          Hit bit set on Destination MAC addrs hits
 *     HITDA_4          Hit bit set on Destination MAC addrs hits
 *     HITDA_5          Hit bit set on Destination MAC addrs hits
 *     HITDA_6          Hit bit set on Destination MAC addrs hits
 *     HITDA_7          Hit bit set on Destination MAC addrs hits
 *
 ******************************************************************************/
#define BCM56504_A0_L2_HITDA_ONLYm 0x06720000

#define BCM56504_A0_L2_HITDA_ONLYm_MIN 0
#define BCM56504_A0_L2_HITDA_ONLYm_MAX 2047
#define BCM56504_A0_L2_HITDA_ONLYm_CMAX(u) 2047
#define BCM56504_A0_L2_HITDA_ONLYm_SIZE 1

/*
 * This structure should be used to declare and program L2_HITDA_ONLY.
 *
 */
typedef union BCM56504_A0_L2_HITDA_ONLYm_s {
	uint32_t v[1];
	uint32_t l2_hitda_only[1];
	uint32_t _l2_hitda_only;
} BCM56504_A0_L2_HITDA_ONLYm_t;

#define BCM56504_A0_L2_HITDA_ONLYm_CLR(r) (r).l2_hitda_only[0] = 0
#define BCM56504_A0_L2_HITDA_ONLYm_SET(r,d) (r).l2_hitda_only[0] = d
#define BCM56504_A0_L2_HITDA_ONLYm_GET(r) (r).l2_hitda_only[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_L2_HITDA_ONLYm_HITDA_0f_GET(r) (((r).l2_hitda_only[0]) & 0x1)
#define BCM56504_A0_L2_HITDA_ONLYm_HITDA_0f_SET(r,f) (r).l2_hitda_only[0]=(((r).l2_hitda_only[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_L2_HITDA_ONLYm_HITDA_1f_GET(r) ((((r).l2_hitda_only[0]) >> 1) & 0x1)
#define BCM56504_A0_L2_HITDA_ONLYm_HITDA_1f_SET(r,f) (r).l2_hitda_only[0]=(((r).l2_hitda_only[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_L2_HITDA_ONLYm_HITDA_2f_GET(r) ((((r).l2_hitda_only[0]) >> 2) & 0x1)
#define BCM56504_A0_L2_HITDA_ONLYm_HITDA_2f_SET(r,f) (r).l2_hitda_only[0]=(((r).l2_hitda_only[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_L2_HITDA_ONLYm_HITDA_3f_GET(r) ((((r).l2_hitda_only[0]) >> 3) & 0x1)
#define BCM56504_A0_L2_HITDA_ONLYm_HITDA_3f_SET(r,f) (r).l2_hitda_only[0]=(((r).l2_hitda_only[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_L2_HITDA_ONLYm_HITDA_4f_GET(r) ((((r).l2_hitda_only[0]) >> 4) & 0x1)
#define BCM56504_A0_L2_HITDA_ONLYm_HITDA_4f_SET(r,f) (r).l2_hitda_only[0]=(((r).l2_hitda_only[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56504_A0_L2_HITDA_ONLYm_HITDA_5f_GET(r) ((((r).l2_hitda_only[0]) >> 5) & 0x1)
#define BCM56504_A0_L2_HITDA_ONLYm_HITDA_5f_SET(r,f) (r).l2_hitda_only[0]=(((r).l2_hitda_only[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56504_A0_L2_HITDA_ONLYm_HITDA_6f_GET(r) ((((r).l2_hitda_only[0]) >> 6) & 0x1)
#define BCM56504_A0_L2_HITDA_ONLYm_HITDA_6f_SET(r,f) (r).l2_hitda_only[0]=(((r).l2_hitda_only[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56504_A0_L2_HITDA_ONLYm_HITDA_7f_GET(r) ((((r).l2_hitda_only[0]) >> 7) & 0x1)
#define BCM56504_A0_L2_HITDA_ONLYm_HITDA_7f_SET(r,f) (r).l2_hitda_only[0]=(((r).l2_hitda_only[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access L2_HITDA_ONLY.
 *
 */
#define BCM56504_A0_READ_L2_HITDA_ONLYm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_L2_HITDA_ONLYm,i,(m._l2_hitda_only),1)
#define BCM56504_A0_WRITE_L2_HITDA_ONLYm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_L2_HITDA_ONLYm,i,&(m._l2_hitda_only),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_HITDA_ONLYm BCM56504_A0_L2_HITDA_ONLYm
#define L2_HITDA_ONLYm_MIN BCM56504_A0_L2_HITDA_ONLYm_MIN
#define L2_HITDA_ONLYm_MAX BCM56504_A0_L2_HITDA_ONLYm_MAX
#define L2_HITDA_ONLYm_CMAX(u) BCM56504_A0_L2_HITDA_ONLYm_CMAX(u)
#define L2_HITDA_ONLYm_SIZE BCM56504_A0_L2_HITDA_ONLYm_SIZE
typedef BCM56504_A0_L2_HITDA_ONLYm_t L2_HITDA_ONLYm_t;
#define L2_HITDA_ONLYm_CLR BCM56504_A0_L2_HITDA_ONLYm_CLR
#define L2_HITDA_ONLYm_SET BCM56504_A0_L2_HITDA_ONLYm_SET
#define L2_HITDA_ONLYm_GET BCM56504_A0_L2_HITDA_ONLYm_GET
#define L2_HITDA_ONLYm_HITDA_0f_GET BCM56504_A0_L2_HITDA_ONLYm_HITDA_0f_GET
#define L2_HITDA_ONLYm_HITDA_0f_SET BCM56504_A0_L2_HITDA_ONLYm_HITDA_0f_SET
#define L2_HITDA_ONLYm_HITDA_1f_GET BCM56504_A0_L2_HITDA_ONLYm_HITDA_1f_GET
#define L2_HITDA_ONLYm_HITDA_1f_SET BCM56504_A0_L2_HITDA_ONLYm_HITDA_1f_SET
#define L2_HITDA_ONLYm_HITDA_2f_GET BCM56504_A0_L2_HITDA_ONLYm_HITDA_2f_GET
#define L2_HITDA_ONLYm_HITDA_2f_SET BCM56504_A0_L2_HITDA_ONLYm_HITDA_2f_SET
#define L2_HITDA_ONLYm_HITDA_3f_GET BCM56504_A0_L2_HITDA_ONLYm_HITDA_3f_GET
#define L2_HITDA_ONLYm_HITDA_3f_SET BCM56504_A0_L2_HITDA_ONLYm_HITDA_3f_SET
#define L2_HITDA_ONLYm_HITDA_4f_GET BCM56504_A0_L2_HITDA_ONLYm_HITDA_4f_GET
#define L2_HITDA_ONLYm_HITDA_4f_SET BCM56504_A0_L2_HITDA_ONLYm_HITDA_4f_SET
#define L2_HITDA_ONLYm_HITDA_5f_GET BCM56504_A0_L2_HITDA_ONLYm_HITDA_5f_GET
#define L2_HITDA_ONLYm_HITDA_5f_SET BCM56504_A0_L2_HITDA_ONLYm_HITDA_5f_SET
#define L2_HITDA_ONLYm_HITDA_6f_GET BCM56504_A0_L2_HITDA_ONLYm_HITDA_6f_GET
#define L2_HITDA_ONLYm_HITDA_6f_SET BCM56504_A0_L2_HITDA_ONLYm_HITDA_6f_SET
#define L2_HITDA_ONLYm_HITDA_7f_GET BCM56504_A0_L2_HITDA_ONLYm_HITDA_7f_GET
#define L2_HITDA_ONLYm_HITDA_7f_SET BCM56504_A0_L2_HITDA_ONLYm_HITDA_7f_SET
#define READ_L2_HITDA_ONLYm BCM56504_A0_READ_L2_HITDA_ONLYm
#define WRITE_L2_HITDA_ONLYm BCM56504_A0_WRITE_L2_HITDA_ONLYm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_L2_HITDA_ONLYm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  L2_HITSA_ONLY
 * BLOCKS:   IPIPE
 * DESC:     HW managed L2_HITSA_ONLY table.  Just the SA hit bits.
 * SIZE:     8
 * FIELDS:
 *     HITSA_0          Hit bit set on Source MAC addrs hits
 *     HITSA_1          Hit bit set on Source MAC addrs hits
 *     HITSA_2          Hit bit set on Source MAC addrs hits
 *     HITSA_3          Hit bit set on Source MAC addrs hits
 *     HITSA_4          Hit bit set on Source MAC addrs hits
 *     HITSA_5          Hit bit set on Source MAC addrs hits
 *     HITSA_6          Hit bit set on Source MAC addrs hits
 *     HITSA_7          Hit bit set on Source MAC addrs hits
 *
 ******************************************************************************/
#define BCM56504_A0_L2_HITSA_ONLYm 0x06730000

#define BCM56504_A0_L2_HITSA_ONLYm_MIN 0
#define BCM56504_A0_L2_HITSA_ONLYm_MAX 2047
#define BCM56504_A0_L2_HITSA_ONLYm_CMAX(u) 2047
#define BCM56504_A0_L2_HITSA_ONLYm_SIZE 1

/*
 * This structure should be used to declare and program L2_HITSA_ONLY.
 *
 */
typedef union BCM56504_A0_L2_HITSA_ONLYm_s {
	uint32_t v[1];
	uint32_t l2_hitsa_only[1];
	uint32_t _l2_hitsa_only;
} BCM56504_A0_L2_HITSA_ONLYm_t;

#define BCM56504_A0_L2_HITSA_ONLYm_CLR(r) (r).l2_hitsa_only[0] = 0
#define BCM56504_A0_L2_HITSA_ONLYm_SET(r,d) (r).l2_hitsa_only[0] = d
#define BCM56504_A0_L2_HITSA_ONLYm_GET(r) (r).l2_hitsa_only[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_L2_HITSA_ONLYm_HITSA_0f_GET(r) (((r).l2_hitsa_only[0]) & 0x1)
#define BCM56504_A0_L2_HITSA_ONLYm_HITSA_0f_SET(r,f) (r).l2_hitsa_only[0]=(((r).l2_hitsa_only[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_L2_HITSA_ONLYm_HITSA_1f_GET(r) ((((r).l2_hitsa_only[0]) >> 1) & 0x1)
#define BCM56504_A0_L2_HITSA_ONLYm_HITSA_1f_SET(r,f) (r).l2_hitsa_only[0]=(((r).l2_hitsa_only[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_L2_HITSA_ONLYm_HITSA_2f_GET(r) ((((r).l2_hitsa_only[0]) >> 2) & 0x1)
#define BCM56504_A0_L2_HITSA_ONLYm_HITSA_2f_SET(r,f) (r).l2_hitsa_only[0]=(((r).l2_hitsa_only[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_L2_HITSA_ONLYm_HITSA_3f_GET(r) ((((r).l2_hitsa_only[0]) >> 3) & 0x1)
#define BCM56504_A0_L2_HITSA_ONLYm_HITSA_3f_SET(r,f) (r).l2_hitsa_only[0]=(((r).l2_hitsa_only[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_L2_HITSA_ONLYm_HITSA_4f_GET(r) ((((r).l2_hitsa_only[0]) >> 4) & 0x1)
#define BCM56504_A0_L2_HITSA_ONLYm_HITSA_4f_SET(r,f) (r).l2_hitsa_only[0]=(((r).l2_hitsa_only[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56504_A0_L2_HITSA_ONLYm_HITSA_5f_GET(r) ((((r).l2_hitsa_only[0]) >> 5) & 0x1)
#define BCM56504_A0_L2_HITSA_ONLYm_HITSA_5f_SET(r,f) (r).l2_hitsa_only[0]=(((r).l2_hitsa_only[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56504_A0_L2_HITSA_ONLYm_HITSA_6f_GET(r) ((((r).l2_hitsa_only[0]) >> 6) & 0x1)
#define BCM56504_A0_L2_HITSA_ONLYm_HITSA_6f_SET(r,f) (r).l2_hitsa_only[0]=(((r).l2_hitsa_only[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56504_A0_L2_HITSA_ONLYm_HITSA_7f_GET(r) ((((r).l2_hitsa_only[0]) >> 7) & 0x1)
#define BCM56504_A0_L2_HITSA_ONLYm_HITSA_7f_SET(r,f) (r).l2_hitsa_only[0]=(((r).l2_hitsa_only[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access L2_HITSA_ONLY.
 *
 */
#define BCM56504_A0_READ_L2_HITSA_ONLYm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_L2_HITSA_ONLYm,i,(m._l2_hitsa_only),1)
#define BCM56504_A0_WRITE_L2_HITSA_ONLYm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_L2_HITSA_ONLYm,i,&(m._l2_hitsa_only),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_HITSA_ONLYm BCM56504_A0_L2_HITSA_ONLYm
#define L2_HITSA_ONLYm_MIN BCM56504_A0_L2_HITSA_ONLYm_MIN
#define L2_HITSA_ONLYm_MAX BCM56504_A0_L2_HITSA_ONLYm_MAX
#define L2_HITSA_ONLYm_CMAX(u) BCM56504_A0_L2_HITSA_ONLYm_CMAX(u)
#define L2_HITSA_ONLYm_SIZE BCM56504_A0_L2_HITSA_ONLYm_SIZE
typedef BCM56504_A0_L2_HITSA_ONLYm_t L2_HITSA_ONLYm_t;
#define L2_HITSA_ONLYm_CLR BCM56504_A0_L2_HITSA_ONLYm_CLR
#define L2_HITSA_ONLYm_SET BCM56504_A0_L2_HITSA_ONLYm_SET
#define L2_HITSA_ONLYm_GET BCM56504_A0_L2_HITSA_ONLYm_GET
#define L2_HITSA_ONLYm_HITSA_0f_GET BCM56504_A0_L2_HITSA_ONLYm_HITSA_0f_GET
#define L2_HITSA_ONLYm_HITSA_0f_SET BCM56504_A0_L2_HITSA_ONLYm_HITSA_0f_SET
#define L2_HITSA_ONLYm_HITSA_1f_GET BCM56504_A0_L2_HITSA_ONLYm_HITSA_1f_GET
#define L2_HITSA_ONLYm_HITSA_1f_SET BCM56504_A0_L2_HITSA_ONLYm_HITSA_1f_SET
#define L2_HITSA_ONLYm_HITSA_2f_GET BCM56504_A0_L2_HITSA_ONLYm_HITSA_2f_GET
#define L2_HITSA_ONLYm_HITSA_2f_SET BCM56504_A0_L2_HITSA_ONLYm_HITSA_2f_SET
#define L2_HITSA_ONLYm_HITSA_3f_GET BCM56504_A0_L2_HITSA_ONLYm_HITSA_3f_GET
#define L2_HITSA_ONLYm_HITSA_3f_SET BCM56504_A0_L2_HITSA_ONLYm_HITSA_3f_SET
#define L2_HITSA_ONLYm_HITSA_4f_GET BCM56504_A0_L2_HITSA_ONLYm_HITSA_4f_GET
#define L2_HITSA_ONLYm_HITSA_4f_SET BCM56504_A0_L2_HITSA_ONLYm_HITSA_4f_SET
#define L2_HITSA_ONLYm_HITSA_5f_GET BCM56504_A0_L2_HITSA_ONLYm_HITSA_5f_GET
#define L2_HITSA_ONLYm_HITSA_5f_SET BCM56504_A0_L2_HITSA_ONLYm_HITSA_5f_SET
#define L2_HITSA_ONLYm_HITSA_6f_GET BCM56504_A0_L2_HITSA_ONLYm_HITSA_6f_GET
#define L2_HITSA_ONLYm_HITSA_6f_SET BCM56504_A0_L2_HITSA_ONLYm_HITSA_6f_SET
#define L2_HITSA_ONLYm_HITSA_7f_GET BCM56504_A0_L2_HITSA_ONLYm_HITSA_7f_GET
#define L2_HITSA_ONLYm_HITSA_7f_SET BCM56504_A0_L2_HITSA_ONLYm_HITSA_7f_SET
#define READ_L2_HITSA_ONLYm BCM56504_A0_READ_L2_HITSA_ONLYm
#define WRITE_L2_HITSA_ONLYm BCM56504_A0_WRITE_L2_HITSA_ONLYm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_L2_HITSA_ONLYm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  L2_MOD_FIFO
 * BLOCKS:   IPIPE
 * DESC:     FIFO for operations that MODify the L2_ENTRY table.
 * SIZE:     106
 * FIELDS:
 *     OPER             Operation type:  11->DELETE, 10->PPA_REPLACE, 00->WRITE, 01->reserved
 *     ENTRY_IDX        Index to the entry of the L2_ENTRY table modified.  Valid only for WRITE operations.
 *     BUCKET_IDX       Index to the bucket of the L2_ENTRY table affected.
 *     DELETE_OR_REPL_BM Overlay for DELETE or PPA REPLACE operations.  Bitmap for bucket entries affected.
 *     WR_DATA          Overlay for WRITE operations.  All the L2_ENTRY fields specified in the L2_ENTRY_ONLY view
 *     WR_DATA_OR_REPL_DEL_BM Overlay for WRITE operation:  All the L2_ENTRY fields specified in the L2_ENTRY_ONLY view; used for L2_INSERT, LEARN, and MEMWR.  ...or...  Bitmap or bucket entries affected for DELETE and PPA_REPLACE operations; only 8 bits are valid for this overlay.
 *
 ******************************************************************************/
#define BCM56504_A0_L2_MOD_FIFOm 0x06770000

#define BCM56504_A0_L2_MOD_FIFOm_MIN 0
#define BCM56504_A0_L2_MOD_FIFOm_MAX 15
#define BCM56504_A0_L2_MOD_FIFOm_CMAX(u) 15
#define BCM56504_A0_L2_MOD_FIFOm_SIZE 14

/*
 * This structure should be used to declare and program L2_MOD_FIFO.
 *
 */
typedef union BCM56504_A0_L2_MOD_FIFOm_s {
	uint32_t v[4];
	uint32_t l2_mod_fifo[4];
	uint32_t _l2_mod_fifo;
} BCM56504_A0_L2_MOD_FIFOm_t;

#define BCM56504_A0_L2_MOD_FIFOm_CLR(r) CDK_MEMSET(&((r)._l2_mod_fifo), 0, sizeof(BCM56504_A0_L2_MOD_FIFOm_t))
#define BCM56504_A0_L2_MOD_FIFOm_SET(r,i,d) (r).l2_mod_fifo[i] = d
#define BCM56504_A0_L2_MOD_FIFOm_GET(r,i) (r).l2_mod_fifo[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_L2_MOD_FIFOm_OPERf_GET(r) (((r).l2_mod_fifo[0]) & 0x3)
#define BCM56504_A0_L2_MOD_FIFOm_OPERf_SET(r,f) (r).l2_mod_fifo[0]=(((r).l2_mod_fifo[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56504_A0_L2_MOD_FIFOm_ENTRY_IDXf_GET(r) ((((r).l2_mod_fifo[0]) >> 2) & 0x7)
#define BCM56504_A0_L2_MOD_FIFOm_ENTRY_IDXf_SET(r,f) (r).l2_mod_fifo[0]=(((r).l2_mod_fifo[0] & ~((uint32_t)0x7 << 2)) | ((((uint32_t)f) & 0x7) << 2))
#define BCM56504_A0_L2_MOD_FIFOm_BUCKET_IDXf_GET(r) ((((r).l2_mod_fifo[0]) >> 5) & 0x7ff)
#define BCM56504_A0_L2_MOD_FIFOm_BUCKET_IDXf_SET(r,f) (r).l2_mod_fifo[0]=(((r).l2_mod_fifo[0] & ~((uint32_t)0x7ff << 5)) | ((((uint32_t)f) & 0x7ff) << 5))
#define BCM56504_A0_L2_MOD_FIFOm_DELETE_OR_REPL_BMf_GET(r) ((((r).l2_mod_fifo[0]) >> 16) & 0xff)
#define BCM56504_A0_L2_MOD_FIFOm_DELETE_OR_REPL_BMf_SET(r,f) (r).l2_mod_fifo[0]=(((r).l2_mod_fifo[0] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define BCM56504_A0_L2_MOD_FIFOm_WR_DATAf_GET(r,a) cdk_field_get((r).l2_mod_fifo,16,105,a)
#define BCM56504_A0_L2_MOD_FIFOm_WR_DATAf_SET(r,a) cdk_field_set((r).l2_mod_fifo,16,105,a)
#define BCM56504_A0_L2_MOD_FIFOm_WR_DATA_OR_REPL_DEL_BMf_GET(r,a) cdk_field_get((r).l2_mod_fifo,16,105,a)
#define BCM56504_A0_L2_MOD_FIFOm_WR_DATA_OR_REPL_DEL_BMf_SET(r,a) cdk_field_set((r).l2_mod_fifo,16,105,a)

/*
 * These macros can be used to access L2_MOD_FIFO.
 *
 */
#define BCM56504_A0_READ_L2_MOD_FIFOm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_L2_MOD_FIFOm,i,(m._l2_mod_fifo),4)
#define BCM56504_A0_WRITE_L2_MOD_FIFOm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_L2_MOD_FIFOm,i,&(m._l2_mod_fifo),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_MOD_FIFOm BCM56504_A0_L2_MOD_FIFOm
#define L2_MOD_FIFOm_MIN BCM56504_A0_L2_MOD_FIFOm_MIN
#define L2_MOD_FIFOm_MAX BCM56504_A0_L2_MOD_FIFOm_MAX
#define L2_MOD_FIFOm_CMAX(u) BCM56504_A0_L2_MOD_FIFOm_CMAX(u)
#define L2_MOD_FIFOm_SIZE BCM56504_A0_L2_MOD_FIFOm_SIZE
typedef BCM56504_A0_L2_MOD_FIFOm_t L2_MOD_FIFOm_t;
#define L2_MOD_FIFOm_CLR BCM56504_A0_L2_MOD_FIFOm_CLR
#define L2_MOD_FIFOm_SET BCM56504_A0_L2_MOD_FIFOm_SET
#define L2_MOD_FIFOm_GET BCM56504_A0_L2_MOD_FIFOm_GET
#define L2_MOD_FIFOm_OPERf_GET BCM56504_A0_L2_MOD_FIFOm_OPERf_GET
#define L2_MOD_FIFOm_OPERf_SET BCM56504_A0_L2_MOD_FIFOm_OPERf_SET
#define L2_MOD_FIFOm_ENTRY_IDXf_GET BCM56504_A0_L2_MOD_FIFOm_ENTRY_IDXf_GET
#define L2_MOD_FIFOm_ENTRY_IDXf_SET BCM56504_A0_L2_MOD_FIFOm_ENTRY_IDXf_SET
#define L2_MOD_FIFOm_BUCKET_IDXf_GET BCM56504_A0_L2_MOD_FIFOm_BUCKET_IDXf_GET
#define L2_MOD_FIFOm_BUCKET_IDXf_SET BCM56504_A0_L2_MOD_FIFOm_BUCKET_IDXf_SET
#define L2_MOD_FIFOm_DELETE_OR_REPL_BMf_GET BCM56504_A0_L2_MOD_FIFOm_DELETE_OR_REPL_BMf_GET
#define L2_MOD_FIFOm_DELETE_OR_REPL_BMf_SET BCM56504_A0_L2_MOD_FIFOm_DELETE_OR_REPL_BMf_SET
#define L2_MOD_FIFOm_WR_DATAf_GET BCM56504_A0_L2_MOD_FIFOm_WR_DATAf_GET
#define L2_MOD_FIFOm_WR_DATAf_SET BCM56504_A0_L2_MOD_FIFOm_WR_DATAf_SET
#define L2_MOD_FIFOm_WR_DATA_OR_REPL_DEL_BMf_GET BCM56504_A0_L2_MOD_FIFOm_WR_DATA_OR_REPL_DEL_BMf_GET
#define L2_MOD_FIFOm_WR_DATA_OR_REPL_DEL_BMf_SET BCM56504_A0_L2_MOD_FIFOm_WR_DATA_OR_REPL_DEL_BMf_SET
#define READ_L2_MOD_FIFOm BCM56504_A0_READ_L2_MOD_FIFOm
#define WRITE_L2_MOD_FIFOm BCM56504_A0_WRITE_L2_MOD_FIFOm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_L2_MOD_FIFOm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  L2_MOD_FIFO_CNT
 * BLOCKS:   IPIPE
 * DESC:     L2_MOD_FIFO_CNT
 * SIZE:     32
 * FIELDS:
 *     NUM_OF_ENTRIES   A count of the number of entries in the L2_MOD_FIFO.  This is actually the hardware write pointer, so it points to the last entry in the buffer.
 *
 ******************************************************************************/
#define BCM56504_A0_L2_MOD_FIFO_CNTr 0x0678000a

#define BCM56504_A0_L2_MOD_FIFO_CNTr_SIZE 4

/*
 * This structure should be used to declare and program L2_MOD_FIFO_CNT.
 *
 */
typedef union BCM56504_A0_L2_MOD_FIFO_CNTr_s {
	uint32_t v[1];
	uint32_t l2_mod_fifo_cnt[1];
	uint32_t _l2_mod_fifo_cnt;
} BCM56504_A0_L2_MOD_FIFO_CNTr_t;

#define BCM56504_A0_L2_MOD_FIFO_CNTr_CLR(r) (r).l2_mod_fifo_cnt[0] = 0
#define BCM56504_A0_L2_MOD_FIFO_CNTr_SET(r,d) (r).l2_mod_fifo_cnt[0] = d
#define BCM56504_A0_L2_MOD_FIFO_CNTr_GET(r) (r).l2_mod_fifo_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_L2_MOD_FIFO_CNTr_NUM_OF_ENTRIESf_GET(r) (((r).l2_mod_fifo_cnt[0]) & 0x1f)
#define BCM56504_A0_L2_MOD_FIFO_CNTr_NUM_OF_ENTRIESf_SET(r,f) (r).l2_mod_fifo_cnt[0]=(((r).l2_mod_fifo_cnt[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))

/*
 * These macros can be used to access L2_MOD_FIFO_CNT.
 *
 */
#define BCM56504_A0_READ_L2_MOD_FIFO_CNTr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_L2_MOD_FIFO_CNTr,(r._l2_mod_fifo_cnt))
#define BCM56504_A0_WRITE_L2_MOD_FIFO_CNTr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_L2_MOD_FIFO_CNTr,&(r._l2_mod_fifo_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_MOD_FIFO_CNTr BCM56504_A0_L2_MOD_FIFO_CNTr
#define L2_MOD_FIFO_CNTr_SIZE BCM56504_A0_L2_MOD_FIFO_CNTr_SIZE
typedef BCM56504_A0_L2_MOD_FIFO_CNTr_t L2_MOD_FIFO_CNTr_t;
#define L2_MOD_FIFO_CNTr_CLR BCM56504_A0_L2_MOD_FIFO_CNTr_CLR
#define L2_MOD_FIFO_CNTr_SET BCM56504_A0_L2_MOD_FIFO_CNTr_SET
#define L2_MOD_FIFO_CNTr_GET BCM56504_A0_L2_MOD_FIFO_CNTr_GET
#define L2_MOD_FIFO_CNTr_NUM_OF_ENTRIESf_GET BCM56504_A0_L2_MOD_FIFO_CNTr_NUM_OF_ENTRIESf_GET
#define L2_MOD_FIFO_CNTr_NUM_OF_ENTRIESf_SET BCM56504_A0_L2_MOD_FIFO_CNTr_NUM_OF_ENTRIESf_SET
#define READ_L2_MOD_FIFO_CNTr BCM56504_A0_READ_L2_MOD_FIFO_CNTr
#define WRITE_L2_MOD_FIFO_CNTr BCM56504_A0_WRITE_L2_MOD_FIFO_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_L2_MOD_FIFO_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  L2_USER_ENTRY
 * BLOCKS:   IPIPE
 * DESC:     Combined L2_ENTRY TCAM/Data RAM for guaranteed L2 entries and BPDUs.
 * SIZE:     142
 * FIELDS:
 *     VALID            Indicates that the entry is valid
 *     MAC_ADDR         MAC address
 *     VLAN_ID          VLAN ID
 *     MASK             Mask for the {VLAN_ID, MAC_ADDR}
 *     PRI              Priority
 *     CPU              CPU bit
 *     L3               Indicates an L3 entry
 *     RPE              RPE bit
 *     MIRROR           Mirror bit
 *     DST_DISCARD      Dst Discard
 *     PORT_TGID        Port or TGID
 *     MODULE_ID        Module ID
 *     BPDU             Indicates entry is a BPDU
 *
 ******************************************************************************/
#define BCM56504_A0_L2_USER_ENTRYm 0x06740000

#define BCM56504_A0_L2_USER_ENTRYm_MIN 0
#define BCM56504_A0_L2_USER_ENTRYm_MAX 127
#define BCM56504_A0_L2_USER_ENTRYm_CMAX(u) 127
#define BCM56504_A0_L2_USER_ENTRYm_SIZE 18

/*
 * This structure should be used to declare and program L2_USER_ENTRY.
 *
 */
typedef union BCM56504_A0_L2_USER_ENTRYm_s {
	uint32_t v[5];
	uint32_t l2_user_entry[5];
	uint32_t _l2_user_entry;
} BCM56504_A0_L2_USER_ENTRYm_t;

#define BCM56504_A0_L2_USER_ENTRYm_CLR(r) CDK_MEMSET(&((r)._l2_user_entry), 0, sizeof(BCM56504_A0_L2_USER_ENTRYm_t))
#define BCM56504_A0_L2_USER_ENTRYm_SET(r,i,d) (r).l2_user_entry[i] = d
#define BCM56504_A0_L2_USER_ENTRYm_GET(r,i) (r).l2_user_entry[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_L2_USER_ENTRYm_VALIDf_GET(r) (((r).l2_user_entry[0]) & 0x1)
#define BCM56504_A0_L2_USER_ENTRYm_VALIDf_SET(r,f) (r).l2_user_entry[0]=(((r).l2_user_entry[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_L2_USER_ENTRYm_MAC_ADDRf_GET(r,a) cdk_field_get((r).l2_user_entry,1,48,a)
#define BCM56504_A0_L2_USER_ENTRYm_MAC_ADDRf_SET(r,a) cdk_field_set((r).l2_user_entry,1,48,a)
#define BCM56504_A0_L2_USER_ENTRYm_VLAN_IDf_GET(r) ((((r).l2_user_entry[1]) >> 17) & 0xfff)
#define BCM56504_A0_L2_USER_ENTRYm_VLAN_IDf_SET(r,f) (r).l2_user_entry[1]=(((r).l2_user_entry[1] & ~((uint32_t)0xfff << 17)) | ((((uint32_t)f) & 0xfff) << 17))
#define BCM56504_A0_L2_USER_ENTRYm_MASKf_GET(r,a) cdk_field_get((r).l2_user_entry,61,120,a)
#define BCM56504_A0_L2_USER_ENTRYm_MASKf_SET(r,a) cdk_field_set((r).l2_user_entry,61,120,a)
#define BCM56504_A0_L2_USER_ENTRYm_PRIf_GET(r) ((((r).l2_user_entry[3]) >> 25) & 0x7)
#define BCM56504_A0_L2_USER_ENTRYm_PRIf_SET(r,f) (r).l2_user_entry[3]=(((r).l2_user_entry[3] & ~((uint32_t)0x7 << 25)) | ((((uint32_t)f) & 0x7) << 25))
#define BCM56504_A0_L2_USER_ENTRYm_CPUf_GET(r) ((((r).l2_user_entry[3]) >> 28) & 0x1)
#define BCM56504_A0_L2_USER_ENTRYm_CPUf_SET(r,f) (r).l2_user_entry[3]=(((r).l2_user_entry[3] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM56504_A0_L2_USER_ENTRYm_L3f_GET(r) ((((r).l2_user_entry[3]) >> 29) & 0x1)
#define BCM56504_A0_L2_USER_ENTRYm_L3f_SET(r,f) (r).l2_user_entry[3]=(((r).l2_user_entry[3] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM56504_A0_L2_USER_ENTRYm_RPEf_GET(r) ((((r).l2_user_entry[3]) >> 30) & 0x1)
#define BCM56504_A0_L2_USER_ENTRYm_RPEf_SET(r,f) (r).l2_user_entry[3]=(((r).l2_user_entry[3] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM56504_A0_L2_USER_ENTRYm_MIRRORf_GET(r) ((((r).l2_user_entry[3]) >> 31) & 0x1)
#define BCM56504_A0_L2_USER_ENTRYm_MIRRORf_SET(r,f) (r).l2_user_entry[3]=(((r).l2_user_entry[3] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM56504_A0_L2_USER_ENTRYm_DST_DISCARDf_GET(r) (((r).l2_user_entry[4]) & 0x1)
#define BCM56504_A0_L2_USER_ENTRYm_DST_DISCARDf_SET(r,f) (r).l2_user_entry[4]=(((r).l2_user_entry[4] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_L2_USER_ENTRYm_PORT_TGIDf_GET(r) ((((r).l2_user_entry[4]) >> 1) & 0x3f)
#define BCM56504_A0_L2_USER_ENTRYm_PORT_TGIDf_SET(r,f) (r).l2_user_entry[4]=(((r).l2_user_entry[4] & ~((uint32_t)0x3f << 1)) | ((((uint32_t)f) & 0x3f) << 1))
#define BCM56504_A0_L2_USER_ENTRYm_MODULE_IDf_GET(r) ((((r).l2_user_entry[4]) >> 7) & 0x3f)
#define BCM56504_A0_L2_USER_ENTRYm_MODULE_IDf_SET(r,f) (r).l2_user_entry[4]=(((r).l2_user_entry[4] & ~((uint32_t)0x3f << 7)) | ((((uint32_t)f) & 0x3f) << 7))
#define BCM56504_A0_L2_USER_ENTRYm_BPDUf_GET(r) ((((r).l2_user_entry[4]) >> 13) & 0x1)
#define BCM56504_A0_L2_USER_ENTRYm_BPDUf_SET(r,f) (r).l2_user_entry[4]=(((r).l2_user_entry[4] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))

/*
 * These macros can be used to access L2_USER_ENTRY.
 *
 */
#define BCM56504_A0_READ_L2_USER_ENTRYm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_L2_USER_ENTRYm,i,(m._l2_user_entry),5)
#define BCM56504_A0_WRITE_L2_USER_ENTRYm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_L2_USER_ENTRYm,i,&(m._l2_user_entry),5)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_USER_ENTRYm BCM56504_A0_L2_USER_ENTRYm
#define L2_USER_ENTRYm_MIN BCM56504_A0_L2_USER_ENTRYm_MIN
#define L2_USER_ENTRYm_MAX BCM56504_A0_L2_USER_ENTRYm_MAX
#define L2_USER_ENTRYm_CMAX(u) BCM56504_A0_L2_USER_ENTRYm_CMAX(u)
#define L2_USER_ENTRYm_SIZE BCM56504_A0_L2_USER_ENTRYm_SIZE
typedef BCM56504_A0_L2_USER_ENTRYm_t L2_USER_ENTRYm_t;
#define L2_USER_ENTRYm_CLR BCM56504_A0_L2_USER_ENTRYm_CLR
#define L2_USER_ENTRYm_SET BCM56504_A0_L2_USER_ENTRYm_SET
#define L2_USER_ENTRYm_GET BCM56504_A0_L2_USER_ENTRYm_GET
#define L2_USER_ENTRYm_VALIDf_GET BCM56504_A0_L2_USER_ENTRYm_VALIDf_GET
#define L2_USER_ENTRYm_VALIDf_SET BCM56504_A0_L2_USER_ENTRYm_VALIDf_SET
#define L2_USER_ENTRYm_MAC_ADDRf_GET BCM56504_A0_L2_USER_ENTRYm_MAC_ADDRf_GET
#define L2_USER_ENTRYm_MAC_ADDRf_SET BCM56504_A0_L2_USER_ENTRYm_MAC_ADDRf_SET
#define L2_USER_ENTRYm_VLAN_IDf_GET BCM56504_A0_L2_USER_ENTRYm_VLAN_IDf_GET
#define L2_USER_ENTRYm_VLAN_IDf_SET BCM56504_A0_L2_USER_ENTRYm_VLAN_IDf_SET
#define L2_USER_ENTRYm_MASKf_GET BCM56504_A0_L2_USER_ENTRYm_MASKf_GET
#define L2_USER_ENTRYm_MASKf_SET BCM56504_A0_L2_USER_ENTRYm_MASKf_SET
#define L2_USER_ENTRYm_PRIf_GET BCM56504_A0_L2_USER_ENTRYm_PRIf_GET
#define L2_USER_ENTRYm_PRIf_SET BCM56504_A0_L2_USER_ENTRYm_PRIf_SET
#define L2_USER_ENTRYm_CPUf_GET BCM56504_A0_L2_USER_ENTRYm_CPUf_GET
#define L2_USER_ENTRYm_CPUf_SET BCM56504_A0_L2_USER_ENTRYm_CPUf_SET
#define L2_USER_ENTRYm_L3f_GET BCM56504_A0_L2_USER_ENTRYm_L3f_GET
#define L2_USER_ENTRYm_L3f_SET BCM56504_A0_L2_USER_ENTRYm_L3f_SET
#define L2_USER_ENTRYm_RPEf_GET BCM56504_A0_L2_USER_ENTRYm_RPEf_GET
#define L2_USER_ENTRYm_RPEf_SET BCM56504_A0_L2_USER_ENTRYm_RPEf_SET
#define L2_USER_ENTRYm_MIRRORf_GET BCM56504_A0_L2_USER_ENTRYm_MIRRORf_GET
#define L2_USER_ENTRYm_MIRRORf_SET BCM56504_A0_L2_USER_ENTRYm_MIRRORf_SET
#define L2_USER_ENTRYm_DST_DISCARDf_GET BCM56504_A0_L2_USER_ENTRYm_DST_DISCARDf_GET
#define L2_USER_ENTRYm_DST_DISCARDf_SET BCM56504_A0_L2_USER_ENTRYm_DST_DISCARDf_SET
#define L2_USER_ENTRYm_PORT_TGIDf_GET BCM56504_A0_L2_USER_ENTRYm_PORT_TGIDf_GET
#define L2_USER_ENTRYm_PORT_TGIDf_SET BCM56504_A0_L2_USER_ENTRYm_PORT_TGIDf_SET
#define L2_USER_ENTRYm_MODULE_IDf_GET BCM56504_A0_L2_USER_ENTRYm_MODULE_IDf_GET
#define L2_USER_ENTRYm_MODULE_IDf_SET BCM56504_A0_L2_USER_ENTRYm_MODULE_IDf_SET
#define L2_USER_ENTRYm_BPDUf_GET BCM56504_A0_L2_USER_ENTRYm_BPDUf_GET
#define L2_USER_ENTRYm_BPDUf_SET BCM56504_A0_L2_USER_ENTRYm_BPDUf_SET
#define READ_L2_USER_ENTRYm BCM56504_A0_READ_L2_USER_ENTRYm
#define WRITE_L2_USER_ENTRYm BCM56504_A0_WRITE_L2_USER_ENTRYm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_L2_USER_ENTRYm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  L2_USER_ENTRY_CAM_BIST_S10_STATUS
 * BLOCKS:   IPIPE
 * DESC:     L2_USER_ENTRY_CAM_BIST_S10_STATUS
 * SIZE:     32
 * FIELDS:
 *     MATCH_STATUS     Match status
 *     AINDEX           Aindex when match happened
 *
 ******************************************************************************/
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S10_STATUSr 0x06780008

#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S10_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program L2_USER_ENTRY_CAM_BIST_S10_STATUS.
 *
 */
typedef union BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S10_STATUSr_s {
	uint32_t v[1];
	uint32_t l2_user_entry_cam_bist_s10_status[1];
	uint32_t _l2_user_entry_cam_bist_s10_status;
} BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S10_STATUSr_t;

#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S10_STATUSr_CLR(r) (r).l2_user_entry_cam_bist_s10_status[0] = 0
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S10_STATUSr_SET(r,d) (r).l2_user_entry_cam_bist_s10_status[0] = d
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S10_STATUSr_GET(r) (r).l2_user_entry_cam_bist_s10_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S10_STATUSr_MATCH_STATUSf_GET(r) (((r).l2_user_entry_cam_bist_s10_status[0]) & 0x1)
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S10_STATUSr_MATCH_STATUSf_SET(r,f) (r).l2_user_entry_cam_bist_s10_status[0]=(((r).l2_user_entry_cam_bist_s10_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S10_STATUSr_AINDEXf_GET(r) ((((r).l2_user_entry_cam_bist_s10_status[0]) >> 1) & 0x7f)
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S10_STATUSr_AINDEXf_SET(r,f) (r).l2_user_entry_cam_bist_s10_status[0]=(((r).l2_user_entry_cam_bist_s10_status[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))

/*
 * These macros can be used to access L2_USER_ENTRY_CAM_BIST_S10_STATUS.
 *
 */
#define BCM56504_A0_READ_L2_USER_ENTRY_CAM_BIST_S10_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S10_STATUSr,(r._l2_user_entry_cam_bist_s10_status))
#define BCM56504_A0_WRITE_L2_USER_ENTRY_CAM_BIST_S10_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S10_STATUSr,&(r._l2_user_entry_cam_bist_s10_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_USER_ENTRY_CAM_BIST_S10_STATUSr BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S10_STATUSr
#define L2_USER_ENTRY_CAM_BIST_S10_STATUSr_SIZE BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S10_STATUSr_SIZE
typedef BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S10_STATUSr_t L2_USER_ENTRY_CAM_BIST_S10_STATUSr_t;
#define L2_USER_ENTRY_CAM_BIST_S10_STATUSr_CLR BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S10_STATUSr_CLR
#define L2_USER_ENTRY_CAM_BIST_S10_STATUSr_SET BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S10_STATUSr_SET
#define L2_USER_ENTRY_CAM_BIST_S10_STATUSr_GET BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S10_STATUSr_GET
#define L2_USER_ENTRY_CAM_BIST_S10_STATUSr_MATCH_STATUSf_GET BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S10_STATUSr_MATCH_STATUSf_GET
#define L2_USER_ENTRY_CAM_BIST_S10_STATUSr_MATCH_STATUSf_SET BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S10_STATUSr_MATCH_STATUSf_SET
#define L2_USER_ENTRY_CAM_BIST_S10_STATUSr_AINDEXf_GET BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S10_STATUSr_AINDEXf_GET
#define L2_USER_ENTRY_CAM_BIST_S10_STATUSr_AINDEXf_SET BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S10_STATUSr_AINDEXf_SET
#define READ_L2_USER_ENTRY_CAM_BIST_S10_STATUSr BCM56504_A0_READ_L2_USER_ENTRY_CAM_BIST_S10_STATUSr
#define WRITE_L2_USER_ENTRY_CAM_BIST_S10_STATUSr BCM56504_A0_WRITE_L2_USER_ENTRY_CAM_BIST_S10_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S10_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  L2_USER_ENTRY_CAM_BIST_S2_STATUS
 * BLOCKS:   IPIPE
 * DESC:     L2_USER_ENTRY_CAM_BIST_S2_STATUS
 * SIZE:     32
 * FIELDS:
 *     MATCH_STATUS     Match status
 *     BIT_POS          Sliding Bit position when match happened
 *     AINDEX           Aindex when match happened
 *
 ******************************************************************************/
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr 0x06780003

#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program L2_USER_ENTRY_CAM_BIST_S2_STATUS.
 *
 */
typedef union BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr_s {
	uint32_t v[1];
	uint32_t l2_user_entry_cam_bist_s2_status[1];
	uint32_t _l2_user_entry_cam_bist_s2_status;
} BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr_t;

#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr_CLR(r) (r).l2_user_entry_cam_bist_s2_status[0] = 0
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr_SET(r,d) (r).l2_user_entry_cam_bist_s2_status[0] = d
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr_GET(r) (r).l2_user_entry_cam_bist_s2_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr_MATCH_STATUSf_GET(r) (((r).l2_user_entry_cam_bist_s2_status[0]) & 0x1)
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr_MATCH_STATUSf_SET(r,f) (r).l2_user_entry_cam_bist_s2_status[0]=(((r).l2_user_entry_cam_bist_s2_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr_BIT_POSf_GET(r) ((((r).l2_user_entry_cam_bist_s2_status[0]) >> 1) & 0x7f)
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr_BIT_POSf_SET(r,f) (r).l2_user_entry_cam_bist_s2_status[0]=(((r).l2_user_entry_cam_bist_s2_status[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr_AINDEXf_GET(r) ((((r).l2_user_entry_cam_bist_s2_status[0]) >> 8) & 0x7f)
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr_AINDEXf_SET(r,f) (r).l2_user_entry_cam_bist_s2_status[0]=(((r).l2_user_entry_cam_bist_s2_status[0] & ~((uint32_t)0x7f << 8)) | ((((uint32_t)f) & 0x7f) << 8))

/*
 * These macros can be used to access L2_USER_ENTRY_CAM_BIST_S2_STATUS.
 *
 */
#define BCM56504_A0_READ_L2_USER_ENTRY_CAM_BIST_S2_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr,(r._l2_user_entry_cam_bist_s2_status))
#define BCM56504_A0_WRITE_L2_USER_ENTRY_CAM_BIST_S2_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr,&(r._l2_user_entry_cam_bist_s2_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_USER_ENTRY_CAM_BIST_S2_STATUSr BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr
#define L2_USER_ENTRY_CAM_BIST_S2_STATUSr_SIZE BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr_SIZE
typedef BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr_t L2_USER_ENTRY_CAM_BIST_S2_STATUSr_t;
#define L2_USER_ENTRY_CAM_BIST_S2_STATUSr_CLR BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr_CLR
#define L2_USER_ENTRY_CAM_BIST_S2_STATUSr_SET BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr_SET
#define L2_USER_ENTRY_CAM_BIST_S2_STATUSr_GET BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr_GET
#define L2_USER_ENTRY_CAM_BIST_S2_STATUSr_MATCH_STATUSf_GET BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr_MATCH_STATUSf_GET
#define L2_USER_ENTRY_CAM_BIST_S2_STATUSr_MATCH_STATUSf_SET BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr_MATCH_STATUSf_SET
#define L2_USER_ENTRY_CAM_BIST_S2_STATUSr_BIT_POSf_GET BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr_BIT_POSf_GET
#define L2_USER_ENTRY_CAM_BIST_S2_STATUSr_BIT_POSf_SET BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr_BIT_POSf_SET
#define L2_USER_ENTRY_CAM_BIST_S2_STATUSr_AINDEXf_GET BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr_AINDEXf_GET
#define L2_USER_ENTRY_CAM_BIST_S2_STATUSr_AINDEXf_SET BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr_AINDEXf_SET
#define READ_L2_USER_ENTRY_CAM_BIST_S2_STATUSr BCM56504_A0_READ_L2_USER_ENTRY_CAM_BIST_S2_STATUSr
#define WRITE_L2_USER_ENTRY_CAM_BIST_S2_STATUSr BCM56504_A0_WRITE_L2_USER_ENTRY_CAM_BIST_S2_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  L2_USER_ENTRY_CAM_BIST_S3_STATUS
 * BLOCKS:   IPIPE
 * DESC:     L2_USER_ENTRY_CAM_BIST_S3_STATUS
 * SIZE:     32
 * FIELDS:
 *     MATCH_STATUS     Match status
 *     AINDEX_STATUS    AIndex status
 *     ACTUAL_AINDEX    Actual AIndex when CAM reported a match
 *     EXPECTED_AINDEX  Expected AIndex
 *
 ******************************************************************************/
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr 0x06780004

#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program L2_USER_ENTRY_CAM_BIST_S3_STATUS.
 *
 */
typedef union BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr_s {
	uint32_t v[1];
	uint32_t l2_user_entry_cam_bist_s3_status[1];
	uint32_t _l2_user_entry_cam_bist_s3_status;
} BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr_t;

#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr_CLR(r) (r).l2_user_entry_cam_bist_s3_status[0] = 0
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr_SET(r,d) (r).l2_user_entry_cam_bist_s3_status[0] = d
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr_GET(r) (r).l2_user_entry_cam_bist_s3_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr_MATCH_STATUSf_GET(r) (((r).l2_user_entry_cam_bist_s3_status[0]) & 0x1)
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr_MATCH_STATUSf_SET(r,f) (r).l2_user_entry_cam_bist_s3_status[0]=(((r).l2_user_entry_cam_bist_s3_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr_AINDEX_STATUSf_GET(r) ((((r).l2_user_entry_cam_bist_s3_status[0]) >> 1) & 0x1)
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr_AINDEX_STATUSf_SET(r,f) (r).l2_user_entry_cam_bist_s3_status[0]=(((r).l2_user_entry_cam_bist_s3_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr_ACTUAL_AINDEXf_GET(r) ((((r).l2_user_entry_cam_bist_s3_status[0]) >> 2) & 0x7f)
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr_ACTUAL_AINDEXf_SET(r,f) (r).l2_user_entry_cam_bist_s3_status[0]=(((r).l2_user_entry_cam_bist_s3_status[0] & ~((uint32_t)0x7f << 2)) | ((((uint32_t)f) & 0x7f) << 2))
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr_EXPECTED_AINDEXf_GET(r) ((((r).l2_user_entry_cam_bist_s3_status[0]) >> 9) & 0x7f)
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr_EXPECTED_AINDEXf_SET(r,f) (r).l2_user_entry_cam_bist_s3_status[0]=(((r).l2_user_entry_cam_bist_s3_status[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access L2_USER_ENTRY_CAM_BIST_S3_STATUS.
 *
 */
#define BCM56504_A0_READ_L2_USER_ENTRY_CAM_BIST_S3_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr,(r._l2_user_entry_cam_bist_s3_status))
#define BCM56504_A0_WRITE_L2_USER_ENTRY_CAM_BIST_S3_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr,&(r._l2_user_entry_cam_bist_s3_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_USER_ENTRY_CAM_BIST_S3_STATUSr BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr
#define L2_USER_ENTRY_CAM_BIST_S3_STATUSr_SIZE BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr_SIZE
typedef BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr_t L2_USER_ENTRY_CAM_BIST_S3_STATUSr_t;
#define L2_USER_ENTRY_CAM_BIST_S3_STATUSr_CLR BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr_CLR
#define L2_USER_ENTRY_CAM_BIST_S3_STATUSr_SET BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr_SET
#define L2_USER_ENTRY_CAM_BIST_S3_STATUSr_GET BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr_GET
#define L2_USER_ENTRY_CAM_BIST_S3_STATUSr_MATCH_STATUSf_GET BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr_MATCH_STATUSf_GET
#define L2_USER_ENTRY_CAM_BIST_S3_STATUSr_MATCH_STATUSf_SET BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr_MATCH_STATUSf_SET
#define L2_USER_ENTRY_CAM_BIST_S3_STATUSr_AINDEX_STATUSf_GET BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr_AINDEX_STATUSf_GET
#define L2_USER_ENTRY_CAM_BIST_S3_STATUSr_AINDEX_STATUSf_SET BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr_AINDEX_STATUSf_SET
#define L2_USER_ENTRY_CAM_BIST_S3_STATUSr_ACTUAL_AINDEXf_GET BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr_ACTUAL_AINDEXf_GET
#define L2_USER_ENTRY_CAM_BIST_S3_STATUSr_ACTUAL_AINDEXf_SET BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr_ACTUAL_AINDEXf_SET
#define L2_USER_ENTRY_CAM_BIST_S3_STATUSr_EXPECTED_AINDEXf_GET BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr_EXPECTED_AINDEXf_GET
#define L2_USER_ENTRY_CAM_BIST_S3_STATUSr_EXPECTED_AINDEXf_SET BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr_EXPECTED_AINDEXf_SET
#define READ_L2_USER_ENTRY_CAM_BIST_S3_STATUSr BCM56504_A0_READ_L2_USER_ENTRY_CAM_BIST_S3_STATUSr
#define WRITE_L2_USER_ENTRY_CAM_BIST_S3_STATUSr BCM56504_A0_WRITE_L2_USER_ENTRY_CAM_BIST_S3_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  L2_USER_ENTRY_CAM_BIST_S5_STATUS
 * BLOCKS:   IPIPE
 * DESC:     L2_USER_ENTRY_CAM_BIST_S5_STATUS
 * SIZE:     32
 * FIELDS:
 *     MATCH_STATUS     Match status
 *     BIT_POS          Sliding Bit position when match happened
 *     AINDEX           Aindex when match happened
 *
 ******************************************************************************/
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr 0x06780005

#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program L2_USER_ENTRY_CAM_BIST_S5_STATUS.
 *
 */
typedef union BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr_s {
	uint32_t v[1];
	uint32_t l2_user_entry_cam_bist_s5_status[1];
	uint32_t _l2_user_entry_cam_bist_s5_status;
} BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr_t;

#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr_CLR(r) (r).l2_user_entry_cam_bist_s5_status[0] = 0
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr_SET(r,d) (r).l2_user_entry_cam_bist_s5_status[0] = d
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr_GET(r) (r).l2_user_entry_cam_bist_s5_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr_MATCH_STATUSf_GET(r) (((r).l2_user_entry_cam_bist_s5_status[0]) & 0x1)
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr_MATCH_STATUSf_SET(r,f) (r).l2_user_entry_cam_bist_s5_status[0]=(((r).l2_user_entry_cam_bist_s5_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr_BIT_POSf_GET(r) ((((r).l2_user_entry_cam_bist_s5_status[0]) >> 1) & 0x7f)
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr_BIT_POSf_SET(r,f) (r).l2_user_entry_cam_bist_s5_status[0]=(((r).l2_user_entry_cam_bist_s5_status[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr_AINDEXf_GET(r) ((((r).l2_user_entry_cam_bist_s5_status[0]) >> 8) & 0x7f)
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr_AINDEXf_SET(r,f) (r).l2_user_entry_cam_bist_s5_status[0]=(((r).l2_user_entry_cam_bist_s5_status[0] & ~((uint32_t)0x7f << 8)) | ((((uint32_t)f) & 0x7f) << 8))

/*
 * These macros can be used to access L2_USER_ENTRY_CAM_BIST_S5_STATUS.
 *
 */
#define BCM56504_A0_READ_L2_USER_ENTRY_CAM_BIST_S5_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr,(r._l2_user_entry_cam_bist_s5_status))
#define BCM56504_A0_WRITE_L2_USER_ENTRY_CAM_BIST_S5_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr,&(r._l2_user_entry_cam_bist_s5_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_USER_ENTRY_CAM_BIST_S5_STATUSr BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr
#define L2_USER_ENTRY_CAM_BIST_S5_STATUSr_SIZE BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr_SIZE
typedef BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr_t L2_USER_ENTRY_CAM_BIST_S5_STATUSr_t;
#define L2_USER_ENTRY_CAM_BIST_S5_STATUSr_CLR BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr_CLR
#define L2_USER_ENTRY_CAM_BIST_S5_STATUSr_SET BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr_SET
#define L2_USER_ENTRY_CAM_BIST_S5_STATUSr_GET BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr_GET
#define L2_USER_ENTRY_CAM_BIST_S5_STATUSr_MATCH_STATUSf_GET BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr_MATCH_STATUSf_GET
#define L2_USER_ENTRY_CAM_BIST_S5_STATUSr_MATCH_STATUSf_SET BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr_MATCH_STATUSf_SET
#define L2_USER_ENTRY_CAM_BIST_S5_STATUSr_BIT_POSf_GET BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr_BIT_POSf_GET
#define L2_USER_ENTRY_CAM_BIST_S5_STATUSr_BIT_POSf_SET BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr_BIT_POSf_SET
#define L2_USER_ENTRY_CAM_BIST_S5_STATUSr_AINDEXf_GET BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr_AINDEXf_GET
#define L2_USER_ENTRY_CAM_BIST_S5_STATUSr_AINDEXf_SET BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr_AINDEXf_SET
#define READ_L2_USER_ENTRY_CAM_BIST_S5_STATUSr BCM56504_A0_READ_L2_USER_ENTRY_CAM_BIST_S5_STATUSr
#define WRITE_L2_USER_ENTRY_CAM_BIST_S5_STATUSr BCM56504_A0_WRITE_L2_USER_ENTRY_CAM_BIST_S5_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  L2_USER_ENTRY_CAM_BIST_S6_STATUS
 * BLOCKS:   IPIPE
 * DESC:     L2_USER_ENTRY_CAM_BIST_S6_STATUS
 * SIZE:     32
 * FIELDS:
 *     MATCH_STATUS     Match status
 *     AINDEX_STATUS    AIndex status
 *     ACTUAL_AINDEX    Actual AIndex when CAM reported a match
 *     EXPECTED_AINDEX  Expected AIndex
 *
 ******************************************************************************/
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr 0x06780006

#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program L2_USER_ENTRY_CAM_BIST_S6_STATUS.
 *
 */
typedef union BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr_s {
	uint32_t v[1];
	uint32_t l2_user_entry_cam_bist_s6_status[1];
	uint32_t _l2_user_entry_cam_bist_s6_status;
} BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr_t;

#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr_CLR(r) (r).l2_user_entry_cam_bist_s6_status[0] = 0
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr_SET(r,d) (r).l2_user_entry_cam_bist_s6_status[0] = d
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr_GET(r) (r).l2_user_entry_cam_bist_s6_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr_MATCH_STATUSf_GET(r) (((r).l2_user_entry_cam_bist_s6_status[0]) & 0x1)
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr_MATCH_STATUSf_SET(r,f) (r).l2_user_entry_cam_bist_s6_status[0]=(((r).l2_user_entry_cam_bist_s6_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr_AINDEX_STATUSf_GET(r) ((((r).l2_user_entry_cam_bist_s6_status[0]) >> 1) & 0x1)
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr_AINDEX_STATUSf_SET(r,f) (r).l2_user_entry_cam_bist_s6_status[0]=(((r).l2_user_entry_cam_bist_s6_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr_ACTUAL_AINDEXf_GET(r) ((((r).l2_user_entry_cam_bist_s6_status[0]) >> 2) & 0x7f)
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr_ACTUAL_AINDEXf_SET(r,f) (r).l2_user_entry_cam_bist_s6_status[0]=(((r).l2_user_entry_cam_bist_s6_status[0] & ~((uint32_t)0x7f << 2)) | ((((uint32_t)f) & 0x7f) << 2))
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr_EXPECTED_AINDEXf_GET(r) ((((r).l2_user_entry_cam_bist_s6_status[0]) >> 9) & 0x7f)
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr_EXPECTED_AINDEXf_SET(r,f) (r).l2_user_entry_cam_bist_s6_status[0]=(((r).l2_user_entry_cam_bist_s6_status[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access L2_USER_ENTRY_CAM_BIST_S6_STATUS.
 *
 */
#define BCM56504_A0_READ_L2_USER_ENTRY_CAM_BIST_S6_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr,(r._l2_user_entry_cam_bist_s6_status))
#define BCM56504_A0_WRITE_L2_USER_ENTRY_CAM_BIST_S6_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr,&(r._l2_user_entry_cam_bist_s6_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_USER_ENTRY_CAM_BIST_S6_STATUSr BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr
#define L2_USER_ENTRY_CAM_BIST_S6_STATUSr_SIZE BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr_SIZE
typedef BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr_t L2_USER_ENTRY_CAM_BIST_S6_STATUSr_t;
#define L2_USER_ENTRY_CAM_BIST_S6_STATUSr_CLR BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr_CLR
#define L2_USER_ENTRY_CAM_BIST_S6_STATUSr_SET BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr_SET
#define L2_USER_ENTRY_CAM_BIST_S6_STATUSr_GET BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr_GET
#define L2_USER_ENTRY_CAM_BIST_S6_STATUSr_MATCH_STATUSf_GET BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr_MATCH_STATUSf_GET
#define L2_USER_ENTRY_CAM_BIST_S6_STATUSr_MATCH_STATUSf_SET BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr_MATCH_STATUSf_SET
#define L2_USER_ENTRY_CAM_BIST_S6_STATUSr_AINDEX_STATUSf_GET BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr_AINDEX_STATUSf_GET
#define L2_USER_ENTRY_CAM_BIST_S6_STATUSr_AINDEX_STATUSf_SET BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr_AINDEX_STATUSf_SET
#define L2_USER_ENTRY_CAM_BIST_S6_STATUSr_ACTUAL_AINDEXf_GET BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr_ACTUAL_AINDEXf_GET
#define L2_USER_ENTRY_CAM_BIST_S6_STATUSr_ACTUAL_AINDEXf_SET BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr_ACTUAL_AINDEXf_SET
#define L2_USER_ENTRY_CAM_BIST_S6_STATUSr_EXPECTED_AINDEXf_GET BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr_EXPECTED_AINDEXf_GET
#define L2_USER_ENTRY_CAM_BIST_S6_STATUSr_EXPECTED_AINDEXf_SET BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr_EXPECTED_AINDEXf_SET
#define READ_L2_USER_ENTRY_CAM_BIST_S6_STATUSr BCM56504_A0_READ_L2_USER_ENTRY_CAM_BIST_S6_STATUSr
#define WRITE_L2_USER_ENTRY_CAM_BIST_S6_STATUSr BCM56504_A0_WRITE_L2_USER_ENTRY_CAM_BIST_S6_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  L2_USER_ENTRY_CAM_BIST_S8_STATUS
 * BLOCKS:   IPIPE
 * DESC:     L2_USER_ENTRY_CAM_BIST_S8_STATUS
 * SIZE:     32
 * FIELDS:
 *     MATCH_STATUS     Match status
 *     AINDEX_STATUS    AIndex status
 *     ACTUAL_AINDEX    Actual AIndex when CAM reported a match
 *     EXPECTED_AINDEX  Expected AIndex
 *
 ******************************************************************************/
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr 0x06780007

#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program L2_USER_ENTRY_CAM_BIST_S8_STATUS.
 *
 */
typedef union BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr_s {
	uint32_t v[1];
	uint32_t l2_user_entry_cam_bist_s8_status[1];
	uint32_t _l2_user_entry_cam_bist_s8_status;
} BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr_t;

#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr_CLR(r) (r).l2_user_entry_cam_bist_s8_status[0] = 0
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr_SET(r,d) (r).l2_user_entry_cam_bist_s8_status[0] = d
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr_GET(r) (r).l2_user_entry_cam_bist_s8_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr_MATCH_STATUSf_GET(r) (((r).l2_user_entry_cam_bist_s8_status[0]) & 0x1)
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr_MATCH_STATUSf_SET(r,f) (r).l2_user_entry_cam_bist_s8_status[0]=(((r).l2_user_entry_cam_bist_s8_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr_AINDEX_STATUSf_GET(r) ((((r).l2_user_entry_cam_bist_s8_status[0]) >> 1) & 0x1)
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr_AINDEX_STATUSf_SET(r,f) (r).l2_user_entry_cam_bist_s8_status[0]=(((r).l2_user_entry_cam_bist_s8_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr_ACTUAL_AINDEXf_GET(r) ((((r).l2_user_entry_cam_bist_s8_status[0]) >> 2) & 0x7f)
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr_ACTUAL_AINDEXf_SET(r,f) (r).l2_user_entry_cam_bist_s8_status[0]=(((r).l2_user_entry_cam_bist_s8_status[0] & ~((uint32_t)0x7f << 2)) | ((((uint32_t)f) & 0x7f) << 2))
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr_EXPECTED_AINDEXf_GET(r) ((((r).l2_user_entry_cam_bist_s8_status[0]) >> 9) & 0x7f)
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr_EXPECTED_AINDEXf_SET(r,f) (r).l2_user_entry_cam_bist_s8_status[0]=(((r).l2_user_entry_cam_bist_s8_status[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access L2_USER_ENTRY_CAM_BIST_S8_STATUS.
 *
 */
#define BCM56504_A0_READ_L2_USER_ENTRY_CAM_BIST_S8_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr,(r._l2_user_entry_cam_bist_s8_status))
#define BCM56504_A0_WRITE_L2_USER_ENTRY_CAM_BIST_S8_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr,&(r._l2_user_entry_cam_bist_s8_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_USER_ENTRY_CAM_BIST_S8_STATUSr BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr
#define L2_USER_ENTRY_CAM_BIST_S8_STATUSr_SIZE BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr_SIZE
typedef BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr_t L2_USER_ENTRY_CAM_BIST_S8_STATUSr_t;
#define L2_USER_ENTRY_CAM_BIST_S8_STATUSr_CLR BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr_CLR
#define L2_USER_ENTRY_CAM_BIST_S8_STATUSr_SET BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr_SET
#define L2_USER_ENTRY_CAM_BIST_S8_STATUSr_GET BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr_GET
#define L2_USER_ENTRY_CAM_BIST_S8_STATUSr_MATCH_STATUSf_GET BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr_MATCH_STATUSf_GET
#define L2_USER_ENTRY_CAM_BIST_S8_STATUSr_MATCH_STATUSf_SET BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr_MATCH_STATUSf_SET
#define L2_USER_ENTRY_CAM_BIST_S8_STATUSr_AINDEX_STATUSf_GET BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr_AINDEX_STATUSf_GET
#define L2_USER_ENTRY_CAM_BIST_S8_STATUSr_AINDEX_STATUSf_SET BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr_AINDEX_STATUSf_SET
#define L2_USER_ENTRY_CAM_BIST_S8_STATUSr_ACTUAL_AINDEXf_GET BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr_ACTUAL_AINDEXf_GET
#define L2_USER_ENTRY_CAM_BIST_S8_STATUSr_ACTUAL_AINDEXf_SET BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr_ACTUAL_AINDEXf_SET
#define L2_USER_ENTRY_CAM_BIST_S8_STATUSr_EXPECTED_AINDEXf_GET BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr_EXPECTED_AINDEXf_GET
#define L2_USER_ENTRY_CAM_BIST_S8_STATUSr_EXPECTED_AINDEXf_SET BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr_EXPECTED_AINDEXf_SET
#define READ_L2_USER_ENTRY_CAM_BIST_S8_STATUSr BCM56504_A0_READ_L2_USER_ENTRY_CAM_BIST_S8_STATUSr
#define WRITE_L2_USER_ENTRY_CAM_BIST_S8_STATUSr BCM56504_A0_WRITE_L2_USER_ENTRY_CAM_BIST_S8_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  L2_USER_ENTRY_CAM_BIST_STATUS
 * BLOCKS:   IPIPE
 * DESC:     L2_USER_ENTRY_CAM_BIST_STATUS
 * SIZE:     32
 * FIELDS:
 *     BIST_GO          BIST pass/fail flag (1->pass)
 *     BIST_DONE        Inicates if the BIST has completed
 *
 ******************************************************************************/
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_STATUSr 0x06780002

#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program L2_USER_ENTRY_CAM_BIST_STATUS.
 *
 */
typedef union BCM56504_A0_L2_USER_ENTRY_CAM_BIST_STATUSr_s {
	uint32_t v[1];
	uint32_t l2_user_entry_cam_bist_status[1];
	uint32_t _l2_user_entry_cam_bist_status;
} BCM56504_A0_L2_USER_ENTRY_CAM_BIST_STATUSr_t;

#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_STATUSr_CLR(r) (r).l2_user_entry_cam_bist_status[0] = 0
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_STATUSr_SET(r,d) (r).l2_user_entry_cam_bist_status[0] = d
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_STATUSr_GET(r) (r).l2_user_entry_cam_bist_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_STATUSr_BIST_GOf_GET(r) (((r).l2_user_entry_cam_bist_status[0]) & 0x1)
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_STATUSr_BIST_GOf_SET(r,f) (r).l2_user_entry_cam_bist_status[0]=(((r).l2_user_entry_cam_bist_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_STATUSr_BIST_DONEf_GET(r) ((((r).l2_user_entry_cam_bist_status[0]) >> 1) & 0x1)
#define BCM56504_A0_L2_USER_ENTRY_CAM_BIST_STATUSr_BIST_DONEf_SET(r,f) (r).l2_user_entry_cam_bist_status[0]=(((r).l2_user_entry_cam_bist_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access L2_USER_ENTRY_CAM_BIST_STATUS.
 *
 */
#define BCM56504_A0_READ_L2_USER_ENTRY_CAM_BIST_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_L2_USER_ENTRY_CAM_BIST_STATUSr,(r._l2_user_entry_cam_bist_status))
#define BCM56504_A0_WRITE_L2_USER_ENTRY_CAM_BIST_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_L2_USER_ENTRY_CAM_BIST_STATUSr,&(r._l2_user_entry_cam_bist_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_USER_ENTRY_CAM_BIST_STATUSr BCM56504_A0_L2_USER_ENTRY_CAM_BIST_STATUSr
#define L2_USER_ENTRY_CAM_BIST_STATUSr_SIZE BCM56504_A0_L2_USER_ENTRY_CAM_BIST_STATUSr_SIZE
typedef BCM56504_A0_L2_USER_ENTRY_CAM_BIST_STATUSr_t L2_USER_ENTRY_CAM_BIST_STATUSr_t;
#define L2_USER_ENTRY_CAM_BIST_STATUSr_CLR BCM56504_A0_L2_USER_ENTRY_CAM_BIST_STATUSr_CLR
#define L2_USER_ENTRY_CAM_BIST_STATUSr_SET BCM56504_A0_L2_USER_ENTRY_CAM_BIST_STATUSr_SET
#define L2_USER_ENTRY_CAM_BIST_STATUSr_GET BCM56504_A0_L2_USER_ENTRY_CAM_BIST_STATUSr_GET
#define L2_USER_ENTRY_CAM_BIST_STATUSr_BIST_GOf_GET BCM56504_A0_L2_USER_ENTRY_CAM_BIST_STATUSr_BIST_GOf_GET
#define L2_USER_ENTRY_CAM_BIST_STATUSr_BIST_GOf_SET BCM56504_A0_L2_USER_ENTRY_CAM_BIST_STATUSr_BIST_GOf_SET
#define L2_USER_ENTRY_CAM_BIST_STATUSr_BIST_DONEf_GET BCM56504_A0_L2_USER_ENTRY_CAM_BIST_STATUSr_BIST_DONEf_GET
#define L2_USER_ENTRY_CAM_BIST_STATUSr_BIST_DONEf_SET BCM56504_A0_L2_USER_ENTRY_CAM_BIST_STATUSr_BIST_DONEf_SET
#define READ_L2_USER_ENTRY_CAM_BIST_STATUSr BCM56504_A0_READ_L2_USER_ENTRY_CAM_BIST_STATUSr
#define WRITE_L2_USER_ENTRY_CAM_BIST_STATUSr BCM56504_A0_WRITE_L2_USER_ENTRY_CAM_BIST_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_L2_USER_ENTRY_CAM_BIST_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  L2_USER_ENTRY_CAM_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     L2_USER_ENTRY_CAM_CONTROL
 * SIZE:     32
 * FIELDS:
 *     BIST_EN          BIST enable for the CAM
 *     SAM              SAM debug bits
 *
 ******************************************************************************/
#define BCM56504_A0_L2_USER_ENTRY_CAM_CONTROLr 0x06780001

#define BCM56504_A0_L2_USER_ENTRY_CAM_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program L2_USER_ENTRY_CAM_CONTROL.
 *
 */
typedef union BCM56504_A0_L2_USER_ENTRY_CAM_CONTROLr_s {
	uint32_t v[1];
	uint32_t l2_user_entry_cam_control[1];
	uint32_t _l2_user_entry_cam_control;
} BCM56504_A0_L2_USER_ENTRY_CAM_CONTROLr_t;

#define BCM56504_A0_L2_USER_ENTRY_CAM_CONTROLr_CLR(r) (r).l2_user_entry_cam_control[0] = 0
#define BCM56504_A0_L2_USER_ENTRY_CAM_CONTROLr_SET(r,d) (r).l2_user_entry_cam_control[0] = d
#define BCM56504_A0_L2_USER_ENTRY_CAM_CONTROLr_GET(r) (r).l2_user_entry_cam_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_L2_USER_ENTRY_CAM_CONTROLr_BIST_ENf_GET(r) (((r).l2_user_entry_cam_control[0]) & 0x1)
#define BCM56504_A0_L2_USER_ENTRY_CAM_CONTROLr_BIST_ENf_SET(r,f) (r).l2_user_entry_cam_control[0]=(((r).l2_user_entry_cam_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_L2_USER_ENTRY_CAM_CONTROLr_SAMf_GET(r) ((((r).l2_user_entry_cam_control[0]) >> 1) & 0x7)
#define BCM56504_A0_L2_USER_ENTRY_CAM_CONTROLr_SAMf_SET(r,f) (r).l2_user_entry_cam_control[0]=(((r).l2_user_entry_cam_control[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))

/*
 * These macros can be used to access L2_USER_ENTRY_CAM_CONTROL.
 *
 */
#define BCM56504_A0_READ_L2_USER_ENTRY_CAM_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_L2_USER_ENTRY_CAM_CONTROLr,(r._l2_user_entry_cam_control))
#define BCM56504_A0_WRITE_L2_USER_ENTRY_CAM_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_L2_USER_ENTRY_CAM_CONTROLr,&(r._l2_user_entry_cam_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_USER_ENTRY_CAM_CONTROLr BCM56504_A0_L2_USER_ENTRY_CAM_CONTROLr
#define L2_USER_ENTRY_CAM_CONTROLr_SIZE BCM56504_A0_L2_USER_ENTRY_CAM_CONTROLr_SIZE
typedef BCM56504_A0_L2_USER_ENTRY_CAM_CONTROLr_t L2_USER_ENTRY_CAM_CONTROLr_t;
#define L2_USER_ENTRY_CAM_CONTROLr_CLR BCM56504_A0_L2_USER_ENTRY_CAM_CONTROLr_CLR
#define L2_USER_ENTRY_CAM_CONTROLr_SET BCM56504_A0_L2_USER_ENTRY_CAM_CONTROLr_SET
#define L2_USER_ENTRY_CAM_CONTROLr_GET BCM56504_A0_L2_USER_ENTRY_CAM_CONTROLr_GET
#define L2_USER_ENTRY_CAM_CONTROLr_BIST_ENf_GET BCM56504_A0_L2_USER_ENTRY_CAM_CONTROLr_BIST_ENf_GET
#define L2_USER_ENTRY_CAM_CONTROLr_BIST_ENf_SET BCM56504_A0_L2_USER_ENTRY_CAM_CONTROLr_BIST_ENf_SET
#define L2_USER_ENTRY_CAM_CONTROLr_SAMf_GET BCM56504_A0_L2_USER_ENTRY_CAM_CONTROLr_SAMf_GET
#define L2_USER_ENTRY_CAM_CONTROLr_SAMf_SET BCM56504_A0_L2_USER_ENTRY_CAM_CONTROLr_SAMf_SET
#define READ_L2_USER_ENTRY_CAM_CONTROLr BCM56504_A0_READ_L2_USER_ENTRY_CAM_CONTROLr
#define WRITE_L2_USER_ENTRY_CAM_CONTROLr BCM56504_A0_WRITE_L2_USER_ENTRY_CAM_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_L2_USER_ENTRY_CAM_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  L2_USER_ENTRY_DATA_ONLY
 * BLOCKS:   IPIPE
 * DESC:     Data SRAM for L2_USER_ENTRY TCAM.
 * SIZE:     21
 * FIELDS:
 *     PRI              Priority
 *     CPU              CPU bit
 *     L3               Indicates an L3 entry
 *     RPE              RPE bit
 *     MIRROR           Mirror bit
 *     DST_DISCARD      Dst Discard
 *     PORT_TGID        Port or TGID
 *     MODULE_ID        Module ID
 *     BPDU             Indicates entry is a BPDU
 *
 ******************************************************************************/
#define BCM56504_A0_L2_USER_ENTRY_DATA_ONLYm 0x06760000

#define BCM56504_A0_L2_USER_ENTRY_DATA_ONLYm_MIN 0
#define BCM56504_A0_L2_USER_ENTRY_DATA_ONLYm_MAX 127
#define BCM56504_A0_L2_USER_ENTRY_DATA_ONLYm_CMAX(u) 127
#define BCM56504_A0_L2_USER_ENTRY_DATA_ONLYm_SIZE 3

/*
 * This structure should be used to declare and program L2_USER_ENTRY_DATA_ONLY.
 *
 */
typedef union BCM56504_A0_L2_USER_ENTRY_DATA_ONLYm_s {
	uint32_t v[1];
	uint32_t l2_user_entry_data_only[1];
	uint32_t _l2_user_entry_data_only;
} BCM56504_A0_L2_USER_ENTRY_DATA_ONLYm_t;

#define BCM56504_A0_L2_USER_ENTRY_DATA_ONLYm_CLR(r) (r).l2_user_entry_data_only[0] = 0
#define BCM56504_A0_L2_USER_ENTRY_DATA_ONLYm_SET(r,d) (r).l2_user_entry_data_only[0] = d
#define BCM56504_A0_L2_USER_ENTRY_DATA_ONLYm_GET(r) (r).l2_user_entry_data_only[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_L2_USER_ENTRY_DATA_ONLYm_PRIf_GET(r) (((r).l2_user_entry_data_only[0]) & 0x7)
#define BCM56504_A0_L2_USER_ENTRY_DATA_ONLYm_PRIf_SET(r,f) (r).l2_user_entry_data_only[0]=(((r).l2_user_entry_data_only[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM56504_A0_L2_USER_ENTRY_DATA_ONLYm_CPUf_GET(r) ((((r).l2_user_entry_data_only[0]) >> 3) & 0x1)
#define BCM56504_A0_L2_USER_ENTRY_DATA_ONLYm_CPUf_SET(r,f) (r).l2_user_entry_data_only[0]=(((r).l2_user_entry_data_only[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_L2_USER_ENTRY_DATA_ONLYm_L3f_GET(r) ((((r).l2_user_entry_data_only[0]) >> 4) & 0x1)
#define BCM56504_A0_L2_USER_ENTRY_DATA_ONLYm_L3f_SET(r,f) (r).l2_user_entry_data_only[0]=(((r).l2_user_entry_data_only[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56504_A0_L2_USER_ENTRY_DATA_ONLYm_RPEf_GET(r) ((((r).l2_user_entry_data_only[0]) >> 5) & 0x1)
#define BCM56504_A0_L2_USER_ENTRY_DATA_ONLYm_RPEf_SET(r,f) (r).l2_user_entry_data_only[0]=(((r).l2_user_entry_data_only[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56504_A0_L2_USER_ENTRY_DATA_ONLYm_MIRRORf_GET(r) ((((r).l2_user_entry_data_only[0]) >> 6) & 0x1)
#define BCM56504_A0_L2_USER_ENTRY_DATA_ONLYm_MIRRORf_SET(r,f) (r).l2_user_entry_data_only[0]=(((r).l2_user_entry_data_only[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56504_A0_L2_USER_ENTRY_DATA_ONLYm_DST_DISCARDf_GET(r) ((((r).l2_user_entry_data_only[0]) >> 7) & 0x1)
#define BCM56504_A0_L2_USER_ENTRY_DATA_ONLYm_DST_DISCARDf_SET(r,f) (r).l2_user_entry_data_only[0]=(((r).l2_user_entry_data_only[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56504_A0_L2_USER_ENTRY_DATA_ONLYm_PORT_TGIDf_GET(r) ((((r).l2_user_entry_data_only[0]) >> 8) & 0x3f)
#define BCM56504_A0_L2_USER_ENTRY_DATA_ONLYm_PORT_TGIDf_SET(r,f) (r).l2_user_entry_data_only[0]=(((r).l2_user_entry_data_only[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define BCM56504_A0_L2_USER_ENTRY_DATA_ONLYm_MODULE_IDf_GET(r) ((((r).l2_user_entry_data_only[0]) >> 14) & 0x3f)
#define BCM56504_A0_L2_USER_ENTRY_DATA_ONLYm_MODULE_IDf_SET(r,f) (r).l2_user_entry_data_only[0]=(((r).l2_user_entry_data_only[0] & ~((uint32_t)0x3f << 14)) | ((((uint32_t)f) & 0x3f) << 14))
#define BCM56504_A0_L2_USER_ENTRY_DATA_ONLYm_BPDUf_GET(r) ((((r).l2_user_entry_data_only[0]) >> 20) & 0x1)
#define BCM56504_A0_L2_USER_ENTRY_DATA_ONLYm_BPDUf_SET(r,f) (r).l2_user_entry_data_only[0]=(((r).l2_user_entry_data_only[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))

/*
 * These macros can be used to access L2_USER_ENTRY_DATA_ONLY.
 *
 */
#define BCM56504_A0_READ_L2_USER_ENTRY_DATA_ONLYm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_L2_USER_ENTRY_DATA_ONLYm,i,(m._l2_user_entry_data_only),1)
#define BCM56504_A0_WRITE_L2_USER_ENTRY_DATA_ONLYm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_L2_USER_ENTRY_DATA_ONLYm,i,&(m._l2_user_entry_data_only),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_USER_ENTRY_DATA_ONLYm BCM56504_A0_L2_USER_ENTRY_DATA_ONLYm
#define L2_USER_ENTRY_DATA_ONLYm_MIN BCM56504_A0_L2_USER_ENTRY_DATA_ONLYm_MIN
#define L2_USER_ENTRY_DATA_ONLYm_MAX BCM56504_A0_L2_USER_ENTRY_DATA_ONLYm_MAX
#define L2_USER_ENTRY_DATA_ONLYm_CMAX(u) BCM56504_A0_L2_USER_ENTRY_DATA_ONLYm_CMAX(u)
#define L2_USER_ENTRY_DATA_ONLYm_SIZE BCM56504_A0_L2_USER_ENTRY_DATA_ONLYm_SIZE
typedef BCM56504_A0_L2_USER_ENTRY_DATA_ONLYm_t L2_USER_ENTRY_DATA_ONLYm_t;
#define L2_USER_ENTRY_DATA_ONLYm_CLR BCM56504_A0_L2_USER_ENTRY_DATA_ONLYm_CLR
#define L2_USER_ENTRY_DATA_ONLYm_SET BCM56504_A0_L2_USER_ENTRY_DATA_ONLYm_SET
#define L2_USER_ENTRY_DATA_ONLYm_GET BCM56504_A0_L2_USER_ENTRY_DATA_ONLYm_GET
#define L2_USER_ENTRY_DATA_ONLYm_PRIf_GET BCM56504_A0_L2_USER_ENTRY_DATA_ONLYm_PRIf_GET
#define L2_USER_ENTRY_DATA_ONLYm_PRIf_SET BCM56504_A0_L2_USER_ENTRY_DATA_ONLYm_PRIf_SET
#define L2_USER_ENTRY_DATA_ONLYm_CPUf_GET BCM56504_A0_L2_USER_ENTRY_DATA_ONLYm_CPUf_GET
#define L2_USER_ENTRY_DATA_ONLYm_CPUf_SET BCM56504_A0_L2_USER_ENTRY_DATA_ONLYm_CPUf_SET
#define L2_USER_ENTRY_DATA_ONLYm_L3f_GET BCM56504_A0_L2_USER_ENTRY_DATA_ONLYm_L3f_GET
#define L2_USER_ENTRY_DATA_ONLYm_L3f_SET BCM56504_A0_L2_USER_ENTRY_DATA_ONLYm_L3f_SET
#define L2_USER_ENTRY_DATA_ONLYm_RPEf_GET BCM56504_A0_L2_USER_ENTRY_DATA_ONLYm_RPEf_GET
#define L2_USER_ENTRY_DATA_ONLYm_RPEf_SET BCM56504_A0_L2_USER_ENTRY_DATA_ONLYm_RPEf_SET
#define L2_USER_ENTRY_DATA_ONLYm_MIRRORf_GET BCM56504_A0_L2_USER_ENTRY_DATA_ONLYm_MIRRORf_GET
#define L2_USER_ENTRY_DATA_ONLYm_MIRRORf_SET BCM56504_A0_L2_USER_ENTRY_DATA_ONLYm_MIRRORf_SET
#define L2_USER_ENTRY_DATA_ONLYm_DST_DISCARDf_GET BCM56504_A0_L2_USER_ENTRY_DATA_ONLYm_DST_DISCARDf_GET
#define L2_USER_ENTRY_DATA_ONLYm_DST_DISCARDf_SET BCM56504_A0_L2_USER_ENTRY_DATA_ONLYm_DST_DISCARDf_SET
#define L2_USER_ENTRY_DATA_ONLYm_PORT_TGIDf_GET BCM56504_A0_L2_USER_ENTRY_DATA_ONLYm_PORT_TGIDf_GET
#define L2_USER_ENTRY_DATA_ONLYm_PORT_TGIDf_SET BCM56504_A0_L2_USER_ENTRY_DATA_ONLYm_PORT_TGIDf_SET
#define L2_USER_ENTRY_DATA_ONLYm_MODULE_IDf_GET BCM56504_A0_L2_USER_ENTRY_DATA_ONLYm_MODULE_IDf_GET
#define L2_USER_ENTRY_DATA_ONLYm_MODULE_IDf_SET BCM56504_A0_L2_USER_ENTRY_DATA_ONLYm_MODULE_IDf_SET
#define L2_USER_ENTRY_DATA_ONLYm_BPDUf_GET BCM56504_A0_L2_USER_ENTRY_DATA_ONLYm_BPDUf_GET
#define L2_USER_ENTRY_DATA_ONLYm_BPDUf_SET BCM56504_A0_L2_USER_ENTRY_DATA_ONLYm_BPDUf_SET
#define READ_L2_USER_ENTRY_DATA_ONLYm BCM56504_A0_READ_L2_USER_ENTRY_DATA_ONLYm
#define WRITE_L2_USER_ENTRY_DATA_ONLYm BCM56504_A0_WRITE_L2_USER_ENTRY_DATA_ONLYm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_L2_USER_ENTRY_DATA_ONLYm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  L2_USER_ENTRY_ONLY
 * BLOCKS:   IPIPE
 * DESC:     TCAM for guaranteed L2 entries and BPDUs.
 * SIZE:     121
 * FIELDS:
 *     VALID            Indicates that the entry is valid
 *     MAC_ADDR         MAC address
 *     VLAN_ID          VLAN ID
 *     MASK             Mask for the {VLAN_ID, MAC_ADDR}
 *
 ******************************************************************************/
#define BCM56504_A0_L2_USER_ENTRY_ONLYm 0x06750000

#define BCM56504_A0_L2_USER_ENTRY_ONLYm_MIN 0
#define BCM56504_A0_L2_USER_ENTRY_ONLYm_MAX 127
#define BCM56504_A0_L2_USER_ENTRY_ONLYm_CMAX(u) 127
#define BCM56504_A0_L2_USER_ENTRY_ONLYm_SIZE 16

/*
 * This structure should be used to declare and program L2_USER_ENTRY_ONLY.
 *
 */
typedef union BCM56504_A0_L2_USER_ENTRY_ONLYm_s {
	uint32_t v[4];
	uint32_t l2_user_entry_only[4];
	uint32_t _l2_user_entry_only;
} BCM56504_A0_L2_USER_ENTRY_ONLYm_t;

#define BCM56504_A0_L2_USER_ENTRY_ONLYm_CLR(r) CDK_MEMSET(&((r)._l2_user_entry_only), 0, sizeof(BCM56504_A0_L2_USER_ENTRY_ONLYm_t))
#define BCM56504_A0_L2_USER_ENTRY_ONLYm_SET(r,i,d) (r).l2_user_entry_only[i] = d
#define BCM56504_A0_L2_USER_ENTRY_ONLYm_GET(r,i) (r).l2_user_entry_only[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_L2_USER_ENTRY_ONLYm_VALIDf_GET(r) (((r).l2_user_entry_only[0]) & 0x1)
#define BCM56504_A0_L2_USER_ENTRY_ONLYm_VALIDf_SET(r,f) (r).l2_user_entry_only[0]=(((r).l2_user_entry_only[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_L2_USER_ENTRY_ONLYm_MAC_ADDRf_GET(r,a) cdk_field_get((r).l2_user_entry_only,1,48,a)
#define BCM56504_A0_L2_USER_ENTRY_ONLYm_MAC_ADDRf_SET(r,a) cdk_field_set((r).l2_user_entry_only,1,48,a)
#define BCM56504_A0_L2_USER_ENTRY_ONLYm_VLAN_IDf_GET(r) ((((r).l2_user_entry_only[1]) >> 17) & 0xfff)
#define BCM56504_A0_L2_USER_ENTRY_ONLYm_VLAN_IDf_SET(r,f) (r).l2_user_entry_only[1]=(((r).l2_user_entry_only[1] & ~((uint32_t)0xfff << 17)) | ((((uint32_t)f) & 0xfff) << 17))
#define BCM56504_A0_L2_USER_ENTRY_ONLYm_MASKf_GET(r,a) cdk_field_get((r).l2_user_entry_only,61,120,a)
#define BCM56504_A0_L2_USER_ENTRY_ONLYm_MASKf_SET(r,a) cdk_field_set((r).l2_user_entry_only,61,120,a)

/*
 * These macros can be used to access L2_USER_ENTRY_ONLY.
 *
 */
#define BCM56504_A0_READ_L2_USER_ENTRY_ONLYm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_L2_USER_ENTRY_ONLYm,i,(m._l2_user_entry_only),4)
#define BCM56504_A0_WRITE_L2_USER_ENTRY_ONLYm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_L2_USER_ENTRY_ONLYm,i,&(m._l2_user_entry_only),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_USER_ENTRY_ONLYm BCM56504_A0_L2_USER_ENTRY_ONLYm
#define L2_USER_ENTRY_ONLYm_MIN BCM56504_A0_L2_USER_ENTRY_ONLYm_MIN
#define L2_USER_ENTRY_ONLYm_MAX BCM56504_A0_L2_USER_ENTRY_ONLYm_MAX
#define L2_USER_ENTRY_ONLYm_CMAX(u) BCM56504_A0_L2_USER_ENTRY_ONLYm_CMAX(u)
#define L2_USER_ENTRY_ONLYm_SIZE BCM56504_A0_L2_USER_ENTRY_ONLYm_SIZE
typedef BCM56504_A0_L2_USER_ENTRY_ONLYm_t L2_USER_ENTRY_ONLYm_t;
#define L2_USER_ENTRY_ONLYm_CLR BCM56504_A0_L2_USER_ENTRY_ONLYm_CLR
#define L2_USER_ENTRY_ONLYm_SET BCM56504_A0_L2_USER_ENTRY_ONLYm_SET
#define L2_USER_ENTRY_ONLYm_GET BCM56504_A0_L2_USER_ENTRY_ONLYm_GET
#define L2_USER_ENTRY_ONLYm_VALIDf_GET BCM56504_A0_L2_USER_ENTRY_ONLYm_VALIDf_GET
#define L2_USER_ENTRY_ONLYm_VALIDf_SET BCM56504_A0_L2_USER_ENTRY_ONLYm_VALIDf_SET
#define L2_USER_ENTRY_ONLYm_MAC_ADDRf_GET BCM56504_A0_L2_USER_ENTRY_ONLYm_MAC_ADDRf_GET
#define L2_USER_ENTRY_ONLYm_MAC_ADDRf_SET BCM56504_A0_L2_USER_ENTRY_ONLYm_MAC_ADDRf_SET
#define L2_USER_ENTRY_ONLYm_VLAN_IDf_GET BCM56504_A0_L2_USER_ENTRY_ONLYm_VLAN_IDf_GET
#define L2_USER_ENTRY_ONLYm_VLAN_IDf_SET BCM56504_A0_L2_USER_ENTRY_ONLYm_VLAN_IDf_SET
#define L2_USER_ENTRY_ONLYm_MASKf_GET BCM56504_A0_L2_USER_ENTRY_ONLYm_MASKf_GET
#define L2_USER_ENTRY_ONLYm_MASKf_SET BCM56504_A0_L2_USER_ENTRY_ONLYm_MASKf_SET
#define READ_L2_USER_ENTRY_ONLYm BCM56504_A0_READ_L2_USER_ENTRY_ONLYm
#define WRITE_L2_USER_ENTRY_ONLYm BCM56504_A0_WRITE_L2_USER_ENTRY_ONLYm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_L2_USER_ENTRY_ONLYm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  L3_DEFIP
 * BLOCKS:   IPIPE
 * DESC:     L3 Default IP Route (LPM) TCAM view with data and hit bits
 * SIZE:     176
 * FIELDS:
 *     VALID0           Indicates half-entry 0 is valid
 *     VALID1           Indicates half-entry 1 is valid
 *     MODE0            Indicates contents of half-entry 0; 0=IPv4, 1=IPv6
 *     MODE1            Indicates contents of half-entry 1; 0=IPv4, 1=IPv6
 *     IP_ADDR0         IP address bits for half-entry 0
 *     IP_ADDR1         IP address bits for half-entry 1
 *     MASK0            Subnet mask for half-entry 0
 *     MASK1            Subnet mask for half-entry 1
 *     ECMP1            Indicates if route for half-entry 1 uses ECMP
 *     ECMP_PTR1        Ptr to ECMP group within ECMP table for half-entry 1
 *     ECMP_COUNT1      No. of ECMP routes in group for half-entry 1
 *     PRI1             Priority for half-entry 1
 *     RPE1             RPE bit for half-entry 1
 *     ECMP0            Indicates if route for half-entry 0 uses ECMP
 *     ECMP_PTR0        Ptr to ECMP group within ECMP table for half-entry 0
 *     ECMP_COUNT0      No. of ECMP routes in group for half-entry 0
 *     PRI0             Priority for half-entry 0
 *     RPE0             RPE bit for half-entry 0
 *     HIT0             Hit bit for half-entry 0
 *     HIT1             Hit bit for half-entry 1
 *     NEXT_HOP_INDEX1  Next Hop Ptr, only valid for non ECMP routes
 *     NEXT_HOP_INDEX0  Next Hop Ptr, only valid for non ECMP routes
 *
 ******************************************************************************/
#define BCM56504_A0_L3_DEFIPm 0x0a700000

#define BCM56504_A0_L3_DEFIPm_MIN 0
#define BCM56504_A0_L3_DEFIPm_MAX 6143
#define BCM56504_A0_L3_DEFIPm_CMAX(u) 6143
#define BCM56504_A0_L3_DEFIPm_SIZE 22

/*
 * This structure should be used to declare and program L3_DEFIP.
 *
 */
typedef union BCM56504_A0_L3_DEFIPm_s {
	uint32_t v[6];
	uint32_t l3_defip[6];
	uint32_t _l3_defip;
} BCM56504_A0_L3_DEFIPm_t;

#define BCM56504_A0_L3_DEFIPm_CLR(r) CDK_MEMSET(&((r)._l3_defip), 0, sizeof(BCM56504_A0_L3_DEFIPm_t))
#define BCM56504_A0_L3_DEFIPm_SET(r,i,d) (r).l3_defip[i] = d
#define BCM56504_A0_L3_DEFIPm_GET(r,i) (r).l3_defip[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_L3_DEFIPm_VALID0f_GET(r) (((r).l3_defip[0]) & 0x1)
#define BCM56504_A0_L3_DEFIPm_VALID0f_SET(r,f) (r).l3_defip[0]=(((r).l3_defip[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_L3_DEFIPm_VALID1f_GET(r) ((((r).l3_defip[0]) >> 1) & 0x1)
#define BCM56504_A0_L3_DEFIPm_VALID1f_SET(r,f) (r).l3_defip[0]=(((r).l3_defip[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_L3_DEFIPm_MODE0f_GET(r) ((((r).l3_defip[0]) >> 2) & 0x1)
#define BCM56504_A0_L3_DEFIPm_MODE0f_SET(r,f) (r).l3_defip[0]=(((r).l3_defip[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_L3_DEFIPm_MODE1f_GET(r) ((((r).l3_defip[0]) >> 3) & 0x1)
#define BCM56504_A0_L3_DEFIPm_MODE1f_SET(r,f) (r).l3_defip[0]=(((r).l3_defip[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_L3_DEFIPm_IP_ADDR0f_GET(r) cdk_field32_get((r).l3_defip,4,35)
#define BCM56504_A0_L3_DEFIPm_IP_ADDR0f_SET(r,f) cdk_field32_set((r).l3_defip,4,35,f)
#define BCM56504_A0_L3_DEFIPm_IP_ADDR1f_GET(r) cdk_field32_get((r).l3_defip,36,67)
#define BCM56504_A0_L3_DEFIPm_IP_ADDR1f_SET(r,f) cdk_field32_set((r).l3_defip,36,67,f)
#define BCM56504_A0_L3_DEFIPm_MASK0f_GET(r) cdk_field32_get((r).l3_defip,68,99)
#define BCM56504_A0_L3_DEFIPm_MASK0f_SET(r,f) cdk_field32_set((r).l3_defip,68,99,f)
#define BCM56504_A0_L3_DEFIPm_MASK1f_GET(r) cdk_field32_get((r).l3_defip,100,131)
#define BCM56504_A0_L3_DEFIPm_MASK1f_SET(r,f) cdk_field32_set((r).l3_defip,100,131,f)
#define BCM56504_A0_L3_DEFIPm_ECMP1f_GET(r) ((((r).l3_defip[4]) >> 4) & 0x1)
#define BCM56504_A0_L3_DEFIPm_ECMP1f_SET(r,f) (r).l3_defip[4]=(((r).l3_defip[4] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56504_A0_L3_DEFIPm_ECMP_PTR1f_GET(r) ((((r).l3_defip[4]) >> 5) & 0x7ff)
#define BCM56504_A0_L3_DEFIPm_ECMP_PTR1f_SET(r,f) (r).l3_defip[4]=(((r).l3_defip[4] & ~((uint32_t)0x7ff << 5)) | ((((uint32_t)f) & 0x7ff) << 5))
#define BCM56504_A0_L3_DEFIPm_ECMP_COUNT1f_GET(r) ((((r).l3_defip[4]) >> 16) & 0x1f)
#define BCM56504_A0_L3_DEFIPm_ECMP_COUNT1f_SET(r,f) (r).l3_defip[4]=(((r).l3_defip[4] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define BCM56504_A0_L3_DEFIPm_PRI1f_GET(r) ((((r).l3_defip[4]) >> 21) & 0x7)
#define BCM56504_A0_L3_DEFIPm_PRI1f_SET(r,f) (r).l3_defip[4]=(((r).l3_defip[4] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM56504_A0_L3_DEFIPm_RPE1f_GET(r) ((((r).l3_defip[4]) >> 24) & 0x1)
#define BCM56504_A0_L3_DEFIPm_RPE1f_SET(r,f) (r).l3_defip[4]=(((r).l3_defip[4] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM56504_A0_L3_DEFIPm_ECMP0f_GET(r) ((((r).l3_defip[4]) >> 25) & 0x1)
#define BCM56504_A0_L3_DEFIPm_ECMP0f_SET(r,f) (r).l3_defip[4]=(((r).l3_defip[4] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM56504_A0_L3_DEFIPm_ECMP_PTR0f_GET(r) cdk_field32_get((r).l3_defip,154,164)
#define BCM56504_A0_L3_DEFIPm_ECMP_PTR0f_SET(r,f) cdk_field32_set((r).l3_defip,154,164,f)
#define BCM56504_A0_L3_DEFIPm_ECMP_COUNT0f_GET(r) ((((r).l3_defip[5]) >> 5) & 0x1f)
#define BCM56504_A0_L3_DEFIPm_ECMP_COUNT0f_SET(r,f) (r).l3_defip[5]=(((r).l3_defip[5] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5))
#define BCM56504_A0_L3_DEFIPm_PRI0f_GET(r) ((((r).l3_defip[5]) >> 10) & 0x7)
#define BCM56504_A0_L3_DEFIPm_PRI0f_SET(r,f) (r).l3_defip[5]=(((r).l3_defip[5] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10))
#define BCM56504_A0_L3_DEFIPm_RPE0f_GET(r) ((((r).l3_defip[5]) >> 13) & 0x1)
#define BCM56504_A0_L3_DEFIPm_RPE0f_SET(r,f) (r).l3_defip[5]=(((r).l3_defip[5] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56504_A0_L3_DEFIPm_HIT0f_GET(r) ((((r).l3_defip[5]) >> 14) & 0x1)
#define BCM56504_A0_L3_DEFIPm_HIT0f_SET(r,f) (r).l3_defip[5]=(((r).l3_defip[5] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM56504_A0_L3_DEFIPm_HIT1f_GET(r) ((((r).l3_defip[5]) >> 15) & 0x1)
#define BCM56504_A0_L3_DEFIPm_HIT1f_SET(r,f) (r).l3_defip[5]=(((r).l3_defip[5] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56504_A0_L3_DEFIPm_NEXT_HOP_INDEX1f_GET(r) ((((r).l3_defip[4]) >> 5) & 0x1fff)
#define BCM56504_A0_L3_DEFIPm_NEXT_HOP_INDEX1f_SET(r,f) (r).l3_defip[4]=(((r).l3_defip[4] & ~((uint32_t)0x1fff << 5)) | ((((uint32_t)f) & 0x1fff) << 5))
#define BCM56504_A0_L3_DEFIPm_NEXT_HOP_INDEX0f_GET(r) cdk_field32_get((r).l3_defip,154,166)
#define BCM56504_A0_L3_DEFIPm_NEXT_HOP_INDEX0f_SET(r,f) cdk_field32_set((r).l3_defip,154,166,f)

/*
 * These macros can be used to access L3_DEFIP.
 *
 */
#define BCM56504_A0_READ_L3_DEFIPm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_L3_DEFIPm,i,(m._l3_defip),6)
#define BCM56504_A0_WRITE_L3_DEFIPm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_L3_DEFIPm,i,&(m._l3_defip),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_DEFIPm BCM56504_A0_L3_DEFIPm
#define L3_DEFIPm_MIN BCM56504_A0_L3_DEFIPm_MIN
#define L3_DEFIPm_MAX BCM56504_A0_L3_DEFIPm_MAX
#define L3_DEFIPm_CMAX(u) BCM56504_A0_L3_DEFIPm_CMAX(u)
#define L3_DEFIPm_SIZE BCM56504_A0_L3_DEFIPm_SIZE
typedef BCM56504_A0_L3_DEFIPm_t L3_DEFIPm_t;
#define L3_DEFIPm_CLR BCM56504_A0_L3_DEFIPm_CLR
#define L3_DEFIPm_SET BCM56504_A0_L3_DEFIPm_SET
#define L3_DEFIPm_GET BCM56504_A0_L3_DEFIPm_GET
#define L3_DEFIPm_VALID0f_GET BCM56504_A0_L3_DEFIPm_VALID0f_GET
#define L3_DEFIPm_VALID0f_SET BCM56504_A0_L3_DEFIPm_VALID0f_SET
#define L3_DEFIPm_VALID1f_GET BCM56504_A0_L3_DEFIPm_VALID1f_GET
#define L3_DEFIPm_VALID1f_SET BCM56504_A0_L3_DEFIPm_VALID1f_SET
#define L3_DEFIPm_MODE0f_GET BCM56504_A0_L3_DEFIPm_MODE0f_GET
#define L3_DEFIPm_MODE0f_SET BCM56504_A0_L3_DEFIPm_MODE0f_SET
#define L3_DEFIPm_MODE1f_GET BCM56504_A0_L3_DEFIPm_MODE1f_GET
#define L3_DEFIPm_MODE1f_SET BCM56504_A0_L3_DEFIPm_MODE1f_SET
#define L3_DEFIPm_IP_ADDR0f_GET BCM56504_A0_L3_DEFIPm_IP_ADDR0f_GET
#define L3_DEFIPm_IP_ADDR0f_SET BCM56504_A0_L3_DEFIPm_IP_ADDR0f_SET
#define L3_DEFIPm_IP_ADDR1f_GET BCM56504_A0_L3_DEFIPm_IP_ADDR1f_GET
#define L3_DEFIPm_IP_ADDR1f_SET BCM56504_A0_L3_DEFIPm_IP_ADDR1f_SET
#define L3_DEFIPm_MASK0f_GET BCM56504_A0_L3_DEFIPm_MASK0f_GET
#define L3_DEFIPm_MASK0f_SET BCM56504_A0_L3_DEFIPm_MASK0f_SET
#define L3_DEFIPm_MASK1f_GET BCM56504_A0_L3_DEFIPm_MASK1f_GET
#define L3_DEFIPm_MASK1f_SET BCM56504_A0_L3_DEFIPm_MASK1f_SET
#define L3_DEFIPm_ECMP1f_GET BCM56504_A0_L3_DEFIPm_ECMP1f_GET
#define L3_DEFIPm_ECMP1f_SET BCM56504_A0_L3_DEFIPm_ECMP1f_SET
#define L3_DEFIPm_ECMP_PTR1f_GET BCM56504_A0_L3_DEFIPm_ECMP_PTR1f_GET
#define L3_DEFIPm_ECMP_PTR1f_SET BCM56504_A0_L3_DEFIPm_ECMP_PTR1f_SET
#define L3_DEFIPm_ECMP_COUNT1f_GET BCM56504_A0_L3_DEFIPm_ECMP_COUNT1f_GET
#define L3_DEFIPm_ECMP_COUNT1f_SET BCM56504_A0_L3_DEFIPm_ECMP_COUNT1f_SET
#define L3_DEFIPm_PRI1f_GET BCM56504_A0_L3_DEFIPm_PRI1f_GET
#define L3_DEFIPm_PRI1f_SET BCM56504_A0_L3_DEFIPm_PRI1f_SET
#define L3_DEFIPm_RPE1f_GET BCM56504_A0_L3_DEFIPm_RPE1f_GET
#define L3_DEFIPm_RPE1f_SET BCM56504_A0_L3_DEFIPm_RPE1f_SET
#define L3_DEFIPm_ECMP0f_GET BCM56504_A0_L3_DEFIPm_ECMP0f_GET
#define L3_DEFIPm_ECMP0f_SET BCM56504_A0_L3_DEFIPm_ECMP0f_SET
#define L3_DEFIPm_ECMP_PTR0f_GET BCM56504_A0_L3_DEFIPm_ECMP_PTR0f_GET
#define L3_DEFIPm_ECMP_PTR0f_SET BCM56504_A0_L3_DEFIPm_ECMP_PTR0f_SET
#define L3_DEFIPm_ECMP_COUNT0f_GET BCM56504_A0_L3_DEFIPm_ECMP_COUNT0f_GET
#define L3_DEFIPm_ECMP_COUNT0f_SET BCM56504_A0_L3_DEFIPm_ECMP_COUNT0f_SET
#define L3_DEFIPm_PRI0f_GET BCM56504_A0_L3_DEFIPm_PRI0f_GET
#define L3_DEFIPm_PRI0f_SET BCM56504_A0_L3_DEFIPm_PRI0f_SET
#define L3_DEFIPm_RPE0f_GET BCM56504_A0_L3_DEFIPm_RPE0f_GET
#define L3_DEFIPm_RPE0f_SET BCM56504_A0_L3_DEFIPm_RPE0f_SET
#define L3_DEFIPm_HIT0f_GET BCM56504_A0_L3_DEFIPm_HIT0f_GET
#define L3_DEFIPm_HIT0f_SET BCM56504_A0_L3_DEFIPm_HIT0f_SET
#define L3_DEFIPm_HIT1f_GET BCM56504_A0_L3_DEFIPm_HIT1f_GET
#define L3_DEFIPm_HIT1f_SET BCM56504_A0_L3_DEFIPm_HIT1f_SET
#define L3_DEFIPm_NEXT_HOP_INDEX1f_GET BCM56504_A0_L3_DEFIPm_NEXT_HOP_INDEX1f_GET
#define L3_DEFIPm_NEXT_HOP_INDEX1f_SET BCM56504_A0_L3_DEFIPm_NEXT_HOP_INDEX1f_SET
#define L3_DEFIPm_NEXT_HOP_INDEX0f_GET BCM56504_A0_L3_DEFIPm_NEXT_HOP_INDEX0f_GET
#define L3_DEFIPm_NEXT_HOP_INDEX0f_SET BCM56504_A0_L3_DEFIPm_NEXT_HOP_INDEX0f_SET
#define READ_L3_DEFIPm BCM56504_A0_READ_L3_DEFIPm
#define WRITE_L3_DEFIPm BCM56504_A0_WRITE_L3_DEFIPm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_L3_DEFIPm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  L3_DEFIP_CAM_BIST_S10_STATUS
 * BLOCKS:   IPIPE
 * DESC:     L3_DEFIP_CAM_BIST_S10_STATUS
 * SIZE:     32
 * FIELDS:
 *     MATCH_STATUS     Match status
 *     AINDEX           Aindex when match happened
 *
 ******************************************************************************/
#define BCM56504_A0_L3_DEFIP_CAM_BIST_S10_STATUSr 0x08780008

#define BCM56504_A0_L3_DEFIP_CAM_BIST_S10_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program L3_DEFIP_CAM_BIST_S10_STATUS.
 *
 */
typedef union BCM56504_A0_L3_DEFIP_CAM_BIST_S10_STATUSr_s {
	uint32_t v[1];
	uint32_t l3_defip_cam_bist_s10_status[1];
	uint32_t _l3_defip_cam_bist_s10_status;
} BCM56504_A0_L3_DEFIP_CAM_BIST_S10_STATUSr_t;

#define BCM56504_A0_L3_DEFIP_CAM_BIST_S10_STATUSr_CLR(r) (r).l3_defip_cam_bist_s10_status[0] = 0
#define BCM56504_A0_L3_DEFIP_CAM_BIST_S10_STATUSr_SET(r,d) (r).l3_defip_cam_bist_s10_status[0] = d
#define BCM56504_A0_L3_DEFIP_CAM_BIST_S10_STATUSr_GET(r) (r).l3_defip_cam_bist_s10_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_L3_DEFIP_CAM_BIST_S10_STATUSr_MATCH_STATUSf_GET(r) (((r).l3_defip_cam_bist_s10_status[0]) & 0x1)
#define BCM56504_A0_L3_DEFIP_CAM_BIST_S10_STATUSr_MATCH_STATUSf_SET(r,f) (r).l3_defip_cam_bist_s10_status[0]=(((r).l3_defip_cam_bist_s10_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_L3_DEFIP_CAM_BIST_S10_STATUSr_AINDEXf_GET(r) ((((r).l3_defip_cam_bist_s10_status[0]) >> 1) & 0x7ff)
#define BCM56504_A0_L3_DEFIP_CAM_BIST_S10_STATUSr_AINDEXf_SET(r,f) (r).l3_defip_cam_bist_s10_status[0]=(((r).l3_defip_cam_bist_s10_status[0] & ~((uint32_t)0x7ff << 1)) | ((((uint32_t)f) & 0x7ff) << 1))

/*
 * These macros can be used to access L3_DEFIP_CAM_BIST_S10_STATUS.
 *
 */
#define BCM56504_A0_READ_L3_DEFIP_CAM_BIST_S10_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_L3_DEFIP_CAM_BIST_S10_STATUSr,(r._l3_defip_cam_bist_s10_status))
#define BCM56504_A0_WRITE_L3_DEFIP_CAM_BIST_S10_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_L3_DEFIP_CAM_BIST_S10_STATUSr,&(r._l3_defip_cam_bist_s10_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_DEFIP_CAM_BIST_S10_STATUSr BCM56504_A0_L3_DEFIP_CAM_BIST_S10_STATUSr
#define L3_DEFIP_CAM_BIST_S10_STATUSr_SIZE BCM56504_A0_L3_DEFIP_CAM_BIST_S10_STATUSr_SIZE
typedef BCM56504_A0_L3_DEFIP_CAM_BIST_S10_STATUSr_t L3_DEFIP_CAM_BIST_S10_STATUSr_t;
#define L3_DEFIP_CAM_BIST_S10_STATUSr_CLR BCM56504_A0_L3_DEFIP_CAM_BIST_S10_STATUSr_CLR
#define L3_DEFIP_CAM_BIST_S10_STATUSr_SET BCM56504_A0_L3_DEFIP_CAM_BIST_S10_STATUSr_SET
#define L3_DEFIP_CAM_BIST_S10_STATUSr_GET BCM56504_A0_L3_DEFIP_CAM_BIST_S10_STATUSr_GET
#define L3_DEFIP_CAM_BIST_S10_STATUSr_MATCH_STATUSf_GET BCM56504_A0_L3_DEFIP_CAM_BIST_S10_STATUSr_MATCH_STATUSf_GET
#define L3_DEFIP_CAM_BIST_S10_STATUSr_MATCH_STATUSf_SET BCM56504_A0_L3_DEFIP_CAM_BIST_S10_STATUSr_MATCH_STATUSf_SET
#define L3_DEFIP_CAM_BIST_S10_STATUSr_AINDEXf_GET BCM56504_A0_L3_DEFIP_CAM_BIST_S10_STATUSr_AINDEXf_GET
#define L3_DEFIP_CAM_BIST_S10_STATUSr_AINDEXf_SET BCM56504_A0_L3_DEFIP_CAM_BIST_S10_STATUSr_AINDEXf_SET
#define READ_L3_DEFIP_CAM_BIST_S10_STATUSr BCM56504_A0_READ_L3_DEFIP_CAM_BIST_S10_STATUSr
#define WRITE_L3_DEFIP_CAM_BIST_S10_STATUSr BCM56504_A0_WRITE_L3_DEFIP_CAM_BIST_S10_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_L3_DEFIP_CAM_BIST_S10_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  L3_DEFIP_CAM_BIST_S2_STATUS
 * BLOCKS:   IPIPE
 * DESC:     L3_DEFIP_CAM_BIST_S2_STATUS
 * SIZE:     32
 * FIELDS:
 *     MATCH_STATUS     Match status
 *     BIT_POS          Sliding Bit position when match happened
 *     AINDEX           Aindex when match happened
 *
 ******************************************************************************/
#define BCM56504_A0_L3_DEFIP_CAM_BIST_S2_STATUSr 0x08780003

#define BCM56504_A0_L3_DEFIP_CAM_BIST_S2_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program L3_DEFIP_CAM_BIST_S2_STATUS.
 *
 */
typedef union BCM56504_A0_L3_DEFIP_CAM_BIST_S2_STATUSr_s {
	uint32_t v[1];
	uint32_t l3_defip_cam_bist_s2_status[1];
	uint32_t _l3_defip_cam_bist_s2_status;
} BCM56504_A0_L3_DEFIP_CAM_BIST_S2_STATUSr_t;

#define BCM56504_A0_L3_DEFIP_CAM_BIST_S2_STATUSr_CLR(r) (r).l3_defip_cam_bist_s2_status[0] = 0
#define BCM56504_A0_L3_DEFIP_CAM_BIST_S2_STATUSr_SET(r,d) (r).l3_defip_cam_bist_s2_status[0] = d
#define BCM56504_A0_L3_DEFIP_CAM_BIST_S2_STATUSr_GET(r) (r).l3_defip_cam_bist_s2_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_L3_DEFIP_CAM_BIST_S2_STATUSr_MATCH_STATUSf_GET(r) (((r).l3_defip_cam_bist_s2_status[0]) & 0x1)
#define BCM56504_A0_L3_DEFIP_CAM_BIST_S2_STATUSr_MATCH_STATUSf_SET(r,f) (r).l3_defip_cam_bist_s2_status[0]=(((r).l3_defip_cam_bist_s2_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_L3_DEFIP_CAM_BIST_S2_STATUSr_BIT_POSf_GET(r) ((((r).l3_defip_cam_bist_s2_status[0]) >> 1) & 0x7f)
#define BCM56504_A0_L3_DEFIP_CAM_BIST_S2_STATUSr_BIT_POSf_SET(r,f) (r).l3_defip_cam_bist_s2_status[0]=(((r).l3_defip_cam_bist_s2_status[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))
#define BCM56504_A0_L3_DEFIP_CAM_BIST_S2_STATUSr_AINDEXf_GET(r) ((((r).l3_defip_cam_bist_s2_status[0]) >> 8) & 0x7ff)
#define BCM56504_A0_L3_DEFIP_CAM_BIST_S2_STATUSr_AINDEXf_SET(r,f) (r).l3_defip_cam_bist_s2_status[0]=(((r).l3_defip_cam_bist_s2_status[0] & ~((uint32_t)0x7ff << 8)) | ((((uint32_t)f) & 0x7ff) << 8))

/*
 * These macros can be used to access L3_DEFIP_CAM_BIST_S2_STATUS.
 *
 */
#define BCM56504_A0_READ_L3_DEFIP_CAM_BIST_S2_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_L3_DEFIP_CAM_BIST_S2_STATUSr,(r._l3_defip_cam_bist_s2_status))
#define BCM56504_A0_WRITE_L3_DEFIP_CAM_BIST_S2_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_L3_DEFIP_CAM_BIST_S2_STATUSr,&(r._l3_defip_cam_bist_s2_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_DEFIP_CAM_BIST_S2_STATUSr BCM56504_A0_L3_DEFIP_CAM_BIST_S2_STATUSr
#define L3_DEFIP_CAM_BIST_S2_STATUSr_SIZE BCM56504_A0_L3_DEFIP_CAM_BIST_S2_STATUSr_SIZE
typedef BCM56504_A0_L3_DEFIP_CAM_BIST_S2_STATUSr_t L3_DEFIP_CAM_BIST_S2_STATUSr_t;
#define L3_DEFIP_CAM_BIST_S2_STATUSr_CLR BCM56504_A0_L3_DEFIP_CAM_BIST_S2_STATUSr_CLR
#define L3_DEFIP_CAM_BIST_S2_STATUSr_SET BCM56504_A0_L3_DEFIP_CAM_BIST_S2_STATUSr_SET
#define L3_DEFIP_CAM_BIST_S2_STATUSr_GET BCM56504_A0_L3_DEFIP_CAM_BIST_S2_STATUSr_GET
#define L3_DEFIP_CAM_BIST_S2_STATUSr_MATCH_STATUSf_GET BCM56504_A0_L3_DEFIP_CAM_BIST_S2_STATUSr_MATCH_STATUSf_GET
#define L3_DEFIP_CAM_BIST_S2_STATUSr_MATCH_STATUSf_SET BCM56504_A0_L3_DEFIP_CAM_BIST_S2_STATUSr_MATCH_STATUSf_SET
#define L3_DEFIP_CAM_BIST_S2_STATUSr_BIT_POSf_GET BCM56504_A0_L3_DEFIP_CAM_BIST_S2_STATUSr_BIT_POSf_GET
#define L3_DEFIP_CAM_BIST_S2_STATUSr_BIT_POSf_SET BCM56504_A0_L3_DEFIP_CAM_BIST_S2_STATUSr_BIT_POSf_SET
#define L3_DEFIP_CAM_BIST_S2_STATUSr_AINDEXf_GET BCM56504_A0_L3_DEFIP_CAM_BIST_S2_STATUSr_AINDEXf_GET
#define L3_DEFIP_CAM_BIST_S2_STATUSr_AINDEXf_SET BCM56504_A0_L3_DEFIP_CAM_BIST_S2_STATUSr_AINDEXf_SET
#define READ_L3_DEFIP_CAM_BIST_S2_STATUSr BCM56504_A0_READ_L3_DEFIP_CAM_BIST_S2_STATUSr
#define WRITE_L3_DEFIP_CAM_BIST_S2_STATUSr BCM56504_A0_WRITE_L3_DEFIP_CAM_BIST_S2_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_L3_DEFIP_CAM_BIST_S2_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  L3_DEFIP_CAM_BIST_S3_STATUS
 * BLOCKS:   IPIPE
 * DESC:     L3_DEFIP_CAM_BIST_S3_STATUS
 * SIZE:     32
 * FIELDS:
 *     MATCH_STATUS     Match status
 *     AINDEX_STATUS    AIndex status
 *     ACTUAL_AINDEX    Actual AIndex when CAM reported a match
 *     EXPECTED_AINDEX  Expected AIndex
 *
 ******************************************************************************/
#define BCM56504_A0_L3_DEFIP_CAM_BIST_S3_STATUSr 0x08780004

#define BCM56504_A0_L3_DEFIP_CAM_BIST_S3_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program L3_DEFIP_CAM_BIST_S3_STATUS.
 *
 */
typedef union BCM56504_A0_L3_DEFIP_CAM_BIST_S3_STATUSr_s {
	uint32_t v[1];
	uint32_t l3_defip_cam_bist_s3_status[1];
	uint32_t _l3_defip_cam_bist_s3_status;
} BCM56504_A0_L3_DEFIP_CAM_BIST_S3_STATUSr_t;

#define BCM56504_A0_L3_DEFIP_CAM_BIST_S3_STATUSr_CLR(r) (r).l3_defip_cam_bist_s3_status[0] = 0
#define BCM56504_A0_L3_DEFIP_CAM_BIST_S3_STATUSr_SET(r,d) (r).l3_defip_cam_bist_s3_status[0] = d
#define BCM56504_A0_L3_DEFIP_CAM_BIST_S3_STATUSr_GET(r) (r).l3_defip_cam_bist_s3_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_L3_DEFIP_CAM_BIST_S3_STATUSr_MATCH_STATUSf_GET(r) (((r).l3_defip_cam_bist_s3_status[0]) & 0x1)
#define BCM56504_A0_L3_DEFIP_CAM_BIST_S3_STATUSr_MATCH_STATUSf_SET(r,f) (r).l3_defip_cam_bist_s3_status[0]=(((r).l3_defip_cam_bist_s3_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_L3_DEFIP_CAM_BIST_S3_STATUSr_AINDEX_STATUSf_GET(r) ((((r).l3_defip_cam_bist_s3_status[0]) >> 1) & 0x1)
#define BCM56504_A0_L3_DEFIP_CAM_BIST_S3_STATUSr_AINDEX_STATUSf_SET(r,f) (r).l3_defip_cam_bist_s3_status[0]=(((r).l3_defip_cam_bist_s3_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_L3_DEFIP_CAM_BIST_S3_STATUSr_ACTUAL_AINDEXf_GET(r) ((((r).l3_defip_cam_bist_s3_status[0]) >> 2) & 0x7ff)
#define BCM56504_A0_L3_DEFIP_CAM_BIST_S3_STATUSr_ACTUAL_AINDEXf_SET(r,f) (r).l3_defip_cam_bist_s3_status[0]=(((r).l3_defip_cam_bist_s3_status[0] & ~((uint32_t)0x7ff << 2)) | ((((uint32_t)f) & 0x7ff) << 2))
#define BCM56504_A0_L3_DEFIP_CAM_BIST_S3_STATUSr_EXPECTED_AINDEXf_GET(r) ((((r).l3_defip_cam_bist_s3_status[0]) >> 13) & 0x7ff)
#define BCM56504_A0_L3_DEFIP_CAM_BIST_S3_STATUSr_EXPECTED_AINDEXf_SET(r,f) (r).l3_defip_cam_bist_s3_status[0]=(((r).l3_defip_cam_bist_s3_status[0] & ~((uint32_t)0x7ff << 13)) | ((((uint32_t)f) & 0x7ff) << 13))

/*
 * These macros can be used to access L3_DEFIP_CAM_BIST_S3_STATUS.
 *
 */
#define BCM56504_A0_READ_L3_DEFIP_CAM_BIST_S3_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_L3_DEFIP_CAM_BIST_S3_STATUSr,(r._l3_defip_cam_bist_s3_status))
#define BCM56504_A0_WRITE_L3_DEFIP_CAM_BIST_S3_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_L3_DEFIP_CAM_BIST_S3_STATUSr,&(r._l3_defip_cam_bist_s3_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_DEFIP_CAM_BIST_S3_STATUSr BCM56504_A0_L3_DEFIP_CAM_BIST_S3_STATUSr
#define L3_DEFIP_CAM_BIST_S3_STATUSr_SIZE BCM56504_A0_L3_DEFIP_CAM_BIST_S3_STATUSr_SIZE
typedef BCM56504_A0_L3_DEFIP_CAM_BIST_S3_STATUSr_t L3_DEFIP_CAM_BIST_S3_STATUSr_t;
#define L3_DEFIP_CAM_BIST_S3_STATUSr_CLR BCM56504_A0_L3_DEFIP_CAM_BIST_S3_STATUSr_CLR
#define L3_DEFIP_CAM_BIST_S3_STATUSr_SET BCM56504_A0_L3_DEFIP_CAM_BIST_S3_STATUSr_SET
#define L3_DEFIP_CAM_BIST_S3_STATUSr_GET BCM56504_A0_L3_DEFIP_CAM_BIST_S3_STATUSr_GET
#define L3_DEFIP_CAM_BIST_S3_STATUSr_MATCH_STATUSf_GET BCM56504_A0_L3_DEFIP_CAM_BIST_S3_STATUSr_MATCH_STATUSf_GET
#define L3_DEFIP_CAM_BIST_S3_STATUSr_MATCH_STATUSf_SET BCM56504_A0_L3_DEFIP_CAM_BIST_S3_STATUSr_MATCH_STATUSf_SET
#define L3_DEFIP_CAM_BIST_S3_STATUSr_AINDEX_STATUSf_GET BCM56504_A0_L3_DEFIP_CAM_BIST_S3_STATUSr_AINDEX_STATUSf_GET
#define L3_DEFIP_CAM_BIST_S3_STATUSr_AINDEX_STATUSf_SET BCM56504_A0_L3_DEFIP_CAM_BIST_S3_STATUSr_AINDEX_STATUSf_SET
#define L3_DEFIP_CAM_BIST_S3_STATUSr_ACTUAL_AINDEXf_GET BCM56504_A0_L3_DEFIP_CAM_BIST_S3_STATUSr_ACTUAL_AINDEXf_GET
#define L3_DEFIP_CAM_BIST_S3_STATUSr_ACTUAL_AINDEXf_SET BCM56504_A0_L3_DEFIP_CAM_BIST_S3_STATUSr_ACTUAL_AINDEXf_SET
#define L3_DEFIP_CAM_BIST_S3_STATUSr_EXPECTED_AINDEXf_GET BCM56504_A0_L3_DEFIP_CAM_BIST_S3_STATUSr_EXPECTED_AINDEXf_GET
#define L3_DEFIP_CAM_BIST_S3_STATUSr_EXPECTED_AINDEXf_SET BCM56504_A0_L3_DEFIP_CAM_BIST_S3_STATUSr_EXPECTED_AINDEXf_SET
#define READ_L3_DEFIP_CAM_BIST_S3_STATUSr BCM56504_A0_READ_L3_DEFIP_CAM_BIST_S3_STATUSr
#define WRITE_L3_DEFIP_CAM_BIST_S3_STATUSr BCM56504_A0_WRITE_L3_DEFIP_CAM_BIST_S3_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_L3_DEFIP_CAM_BIST_S3_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  L3_DEFIP_CAM_BIST_S5_STATUS
 * BLOCKS:   IPIPE
 * DESC:     L3_DEFIP_CAM_BIST_S5_STATUS
 * SIZE:     32
 * FIELDS:
 *     MATCH_STATUS     Match status
 *     BIT_POS          Sliding Bit position when match happened
 *     AINDEX           Aindex when match happened
 *
 ******************************************************************************/
#define BCM56504_A0_L3_DEFIP_CAM_BIST_S5_STATUSr 0x08780005

#define BCM56504_A0_L3_DEFIP_CAM_BIST_S5_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program L3_DEFIP_CAM_BIST_S5_STATUS.
 *
 */
typedef union BCM56504_A0_L3_DEFIP_CAM_BIST_S5_STATUSr_s {
	uint32_t v[1];
	uint32_t l3_defip_cam_bist_s5_status[1];
	uint32_t _l3_defip_cam_bist_s5_status;
} BCM56504_A0_L3_DEFIP_CAM_BIST_S5_STATUSr_t;

#define BCM56504_A0_L3_DEFIP_CAM_BIST_S5_STATUSr_CLR(r) (r).l3_defip_cam_bist_s5_status[0] = 0
#define BCM56504_A0_L3_DEFIP_CAM_BIST_S5_STATUSr_SET(r,d) (r).l3_defip_cam_bist_s5_status[0] = d
#define BCM56504_A0_L3_DEFIP_CAM_BIST_S5_STATUSr_GET(r) (r).l3_defip_cam_bist_s5_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_L3_DEFIP_CAM_BIST_S5_STATUSr_MATCH_STATUSf_GET(r) (((r).l3_defip_cam_bist_s5_status[0]) & 0x1)
#define BCM56504_A0_L3_DEFIP_CAM_BIST_S5_STATUSr_MATCH_STATUSf_SET(r,f) (r).l3_defip_cam_bist_s5_status[0]=(((r).l3_defip_cam_bist_s5_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_L3_DEFIP_CAM_BIST_S5_STATUSr_BIT_POSf_GET(r) ((((r).l3_defip_cam_bist_s5_status[0]) >> 1) & 0x7f)
#define BCM56504_A0_L3_DEFIP_CAM_BIST_S5_STATUSr_BIT_POSf_SET(r,f) (r).l3_defip_cam_bist_s5_status[0]=(((r).l3_defip_cam_bist_s5_status[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))
#define BCM56504_A0_L3_DEFIP_CAM_BIST_S5_STATUSr_AINDEXf_GET(r) ((((r).l3_defip_cam_bist_s5_status[0]) >> 8) & 0x7ff)
#define BCM56504_A0_L3_DEFIP_CAM_BIST_S5_STATUSr_AINDEXf_SET(r,f) (r).l3_defip_cam_bist_s5_status[0]=(((r).l3_defip_cam_bist_s5_status[0] & ~((uint32_t)0x7ff << 8)) | ((((uint32_t)f) & 0x7ff) << 8))

/*
 * These macros can be used to access L3_DEFIP_CAM_BIST_S5_STATUS.
 *
 */
#define BCM56504_A0_READ_L3_DEFIP_CAM_BIST_S5_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_L3_DEFIP_CAM_BIST_S5_STATUSr,(r._l3_defip_cam_bist_s5_status))
#define BCM56504_A0_WRITE_L3_DEFIP_CAM_BIST_S5_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_L3_DEFIP_CAM_BIST_S5_STATUSr,&(r._l3_defip_cam_bist_s5_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_DEFIP_CAM_BIST_S5_STATUSr BCM56504_A0_L3_DEFIP_CAM_BIST_S5_STATUSr
#define L3_DEFIP_CAM_BIST_S5_STATUSr_SIZE BCM56504_A0_L3_DEFIP_CAM_BIST_S5_STATUSr_SIZE
typedef BCM56504_A0_L3_DEFIP_CAM_BIST_S5_STATUSr_t L3_DEFIP_CAM_BIST_S5_STATUSr_t;
#define L3_DEFIP_CAM_BIST_S5_STATUSr_CLR BCM56504_A0_L3_DEFIP_CAM_BIST_S5_STATUSr_CLR
#define L3_DEFIP_CAM_BIST_S5_STATUSr_SET BCM56504_A0_L3_DEFIP_CAM_BIST_S5_STATUSr_SET
#define L3_DEFIP_CAM_BIST_S5_STATUSr_GET BCM56504_A0_L3_DEFIP_CAM_BIST_S5_STATUSr_GET
#define L3_DEFIP_CAM_BIST_S5_STATUSr_MATCH_STATUSf_GET BCM56504_A0_L3_DEFIP_CAM_BIST_S5_STATUSr_MATCH_STATUSf_GET
#define L3_DEFIP_CAM_BIST_S5_STATUSr_MATCH_STATUSf_SET BCM56504_A0_L3_DEFIP_CAM_BIST_S5_STATUSr_MATCH_STATUSf_SET
#define L3_DEFIP_CAM_BIST_S5_STATUSr_BIT_POSf_GET BCM56504_A0_L3_DEFIP_CAM_BIST_S5_STATUSr_BIT_POSf_GET
#define L3_DEFIP_CAM_BIST_S5_STATUSr_BIT_POSf_SET BCM56504_A0_L3_DEFIP_CAM_BIST_S5_STATUSr_BIT_POSf_SET
#define L3_DEFIP_CAM_BIST_S5_STATUSr_AINDEXf_GET BCM56504_A0_L3_DEFIP_CAM_BIST_S5_STATUSr_AINDEXf_GET
#define L3_DEFIP_CAM_BIST_S5_STATUSr_AINDEXf_SET BCM56504_A0_L3_DEFIP_CAM_BIST_S5_STATUSr_AINDEXf_SET
#define READ_L3_DEFIP_CAM_BIST_S5_STATUSr BCM56504_A0_READ_L3_DEFIP_CAM_BIST_S5_STATUSr
#define WRITE_L3_DEFIP_CAM_BIST_S5_STATUSr BCM56504_A0_WRITE_L3_DEFIP_CAM_BIST_S5_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_L3_DEFIP_CAM_BIST_S5_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  L3_DEFIP_CAM_BIST_S6_STATUS
 * BLOCKS:   IPIPE
 * DESC:     L3_DEFIP_CAM_BIST_S6_STATUS
 * SIZE:     32
 * FIELDS:
 *     MATCH_STATUS     Match status
 *     AINDEX_STATUS    AIndex status
 *     ACTUAL_AINDEX    Actual AIndex when CAM reported a match
 *     EXPECTED_AINDEX  Expected AIndex
 *
 ******************************************************************************/
#define BCM56504_A0_L3_DEFIP_CAM_BIST_S6_STATUSr 0x08780006

#define BCM56504_A0_L3_DEFIP_CAM_BIST_S6_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program L3_DEFIP_CAM_BIST_S6_STATUS.
 *
 */
typedef union BCM56504_A0_L3_DEFIP_CAM_BIST_S6_STATUSr_s {
	uint32_t v[1];
	uint32_t l3_defip_cam_bist_s6_status[1];
	uint32_t _l3_defip_cam_bist_s6_status;
} BCM56504_A0_L3_DEFIP_CAM_BIST_S6_STATUSr_t;

#define BCM56504_A0_L3_DEFIP_CAM_BIST_S6_STATUSr_CLR(r) (r).l3_defip_cam_bist_s6_status[0] = 0
#define BCM56504_A0_L3_DEFIP_CAM_BIST_S6_STATUSr_SET(r,d) (r).l3_defip_cam_bist_s6_status[0] = d
#define BCM56504_A0_L3_DEFIP_CAM_BIST_S6_STATUSr_GET(r) (r).l3_defip_cam_bist_s6_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_L3_DEFIP_CAM_BIST_S6_STATUSr_MATCH_STATUSf_GET(r) (((r).l3_defip_cam_bist_s6_status[0]) & 0x1)
#define BCM56504_A0_L3_DEFIP_CAM_BIST_S6_STATUSr_MATCH_STATUSf_SET(r,f) (r).l3_defip_cam_bist_s6_status[0]=(((r).l3_defip_cam_bist_s6_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_L3_DEFIP_CAM_BIST_S6_STATUSr_AINDEX_STATUSf_GET(r) ((((r).l3_defip_cam_bist_s6_status[0]) >> 1) & 0x1)
#define BCM56504_A0_L3_DEFIP_CAM_BIST_S6_STATUSr_AINDEX_STATUSf_SET(r,f) (r).l3_defip_cam_bist_s6_status[0]=(((r).l3_defip_cam_bist_s6_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_L3_DEFIP_CAM_BIST_S6_STATUSr_ACTUAL_AINDEXf_GET(r) ((((r).l3_defip_cam_bist_s6_status[0]) >> 2) & 0x7ff)
#define BCM56504_A0_L3_DEFIP_CAM_BIST_S6_STATUSr_ACTUAL_AINDEXf_SET(r,f) (r).l3_defip_cam_bist_s6_status[0]=(((r).l3_defip_cam_bist_s6_status[0] & ~((uint32_t)0x7ff << 2)) | ((((uint32_t)f) & 0x7ff) << 2))
#define BCM56504_A0_L3_DEFIP_CAM_BIST_S6_STATUSr_EXPECTED_AINDEXf_GET(r) ((((r).l3_defip_cam_bist_s6_status[0]) >> 13) & 0x7ff)
#define BCM56504_A0_L3_DEFIP_CAM_BIST_S6_STATUSr_EXPECTED_AINDEXf_SET(r,f) (r).l3_defip_cam_bist_s6_status[0]=(((r).l3_defip_cam_bist_s6_status[0] & ~((uint32_t)0x7ff << 13)) | ((((uint32_t)f) & 0x7ff) << 13))

/*
 * These macros can be used to access L3_DEFIP_CAM_BIST_S6_STATUS.
 *
 */
#define BCM56504_A0_READ_L3_DEFIP_CAM_BIST_S6_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_L3_DEFIP_CAM_BIST_S6_STATUSr,(r._l3_defip_cam_bist_s6_status))
#define BCM56504_A0_WRITE_L3_DEFIP_CAM_BIST_S6_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_L3_DEFIP_CAM_BIST_S6_STATUSr,&(r._l3_defip_cam_bist_s6_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_DEFIP_CAM_BIST_S6_STATUSr BCM56504_A0_L3_DEFIP_CAM_BIST_S6_STATUSr
#define L3_DEFIP_CAM_BIST_S6_STATUSr_SIZE BCM56504_A0_L3_DEFIP_CAM_BIST_S6_STATUSr_SIZE
typedef BCM56504_A0_L3_DEFIP_CAM_BIST_S6_STATUSr_t L3_DEFIP_CAM_BIST_S6_STATUSr_t;
#define L3_DEFIP_CAM_BIST_S6_STATUSr_CLR BCM56504_A0_L3_DEFIP_CAM_BIST_S6_STATUSr_CLR
#define L3_DEFIP_CAM_BIST_S6_STATUSr_SET BCM56504_A0_L3_DEFIP_CAM_BIST_S6_STATUSr_SET
#define L3_DEFIP_CAM_BIST_S6_STATUSr_GET BCM56504_A0_L3_DEFIP_CAM_BIST_S6_STATUSr_GET
#define L3_DEFIP_CAM_BIST_S6_STATUSr_MATCH_STATUSf_GET BCM56504_A0_L3_DEFIP_CAM_BIST_S6_STATUSr_MATCH_STATUSf_GET
#define L3_DEFIP_CAM_BIST_S6_STATUSr_MATCH_STATUSf_SET BCM56504_A0_L3_DEFIP_CAM_BIST_S6_STATUSr_MATCH_STATUSf_SET
#define L3_DEFIP_CAM_BIST_S6_STATUSr_AINDEX_STATUSf_GET BCM56504_A0_L3_DEFIP_CAM_BIST_S6_STATUSr_AINDEX_STATUSf_GET
#define L3_DEFIP_CAM_BIST_S6_STATUSr_AINDEX_STATUSf_SET BCM56504_A0_L3_DEFIP_CAM_BIST_S6_STATUSr_AINDEX_STATUSf_SET
#define L3_DEFIP_CAM_BIST_S6_STATUSr_ACTUAL_AINDEXf_GET BCM56504_A0_L3_DEFIP_CAM_BIST_S6_STATUSr_ACTUAL_AINDEXf_GET
#define L3_DEFIP_CAM_BIST_S6_STATUSr_ACTUAL_AINDEXf_SET BCM56504_A0_L3_DEFIP_CAM_BIST_S6_STATUSr_ACTUAL_AINDEXf_SET
#define L3_DEFIP_CAM_BIST_S6_STATUSr_EXPECTED_AINDEXf_GET BCM56504_A0_L3_DEFIP_CAM_BIST_S6_STATUSr_EXPECTED_AINDEXf_GET
#define L3_DEFIP_CAM_BIST_S6_STATUSr_EXPECTED_AINDEXf_SET BCM56504_A0_L3_DEFIP_CAM_BIST_S6_STATUSr_EXPECTED_AINDEXf_SET
#define READ_L3_DEFIP_CAM_BIST_S6_STATUSr BCM56504_A0_READ_L3_DEFIP_CAM_BIST_S6_STATUSr
#define WRITE_L3_DEFIP_CAM_BIST_S6_STATUSr BCM56504_A0_WRITE_L3_DEFIP_CAM_BIST_S6_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_L3_DEFIP_CAM_BIST_S6_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  L3_DEFIP_CAM_BIST_S8_STATUS
 * BLOCKS:   IPIPE
 * DESC:     L3_DEFIP_CAM_BIST_S8_STATUS
 * SIZE:     32
 * FIELDS:
 *     MATCH_STATUS     Match status
 *     AINDEX_STATUS    AIndex status
 *     ACTUAL_AINDEX    Actual AIndex when CAM reported a match
 *     EXPECTED_AINDEX  Expected AIndex
 *
 ******************************************************************************/
#define BCM56504_A0_L3_DEFIP_CAM_BIST_S8_STATUSr 0x08780007

#define BCM56504_A0_L3_DEFIP_CAM_BIST_S8_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program L3_DEFIP_CAM_BIST_S8_STATUS.
 *
 */
typedef union BCM56504_A0_L3_DEFIP_CAM_BIST_S8_STATUSr_s {
	uint32_t v[1];
	uint32_t l3_defip_cam_bist_s8_status[1];
	uint32_t _l3_defip_cam_bist_s8_status;
} BCM56504_A0_L3_DEFIP_CAM_BIST_S8_STATUSr_t;

#define BCM56504_A0_L3_DEFIP_CAM_BIST_S8_STATUSr_CLR(r) (r).l3_defip_cam_bist_s8_status[0] = 0
#define BCM56504_A0_L3_DEFIP_CAM_BIST_S8_STATUSr_SET(r,d) (r).l3_defip_cam_bist_s8_status[0] = d
#define BCM56504_A0_L3_DEFIP_CAM_BIST_S8_STATUSr_GET(r) (r).l3_defip_cam_bist_s8_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_L3_DEFIP_CAM_BIST_S8_STATUSr_MATCH_STATUSf_GET(r) (((r).l3_defip_cam_bist_s8_status[0]) & 0x1)
#define BCM56504_A0_L3_DEFIP_CAM_BIST_S8_STATUSr_MATCH_STATUSf_SET(r,f) (r).l3_defip_cam_bist_s8_status[0]=(((r).l3_defip_cam_bist_s8_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_L3_DEFIP_CAM_BIST_S8_STATUSr_AINDEX_STATUSf_GET(r) ((((r).l3_defip_cam_bist_s8_status[0]) >> 1) & 0x1)
#define BCM56504_A0_L3_DEFIP_CAM_BIST_S8_STATUSr_AINDEX_STATUSf_SET(r,f) (r).l3_defip_cam_bist_s8_status[0]=(((r).l3_defip_cam_bist_s8_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_L3_DEFIP_CAM_BIST_S8_STATUSr_ACTUAL_AINDEXf_GET(r) ((((r).l3_defip_cam_bist_s8_status[0]) >> 2) & 0x7ff)
#define BCM56504_A0_L3_DEFIP_CAM_BIST_S8_STATUSr_ACTUAL_AINDEXf_SET(r,f) (r).l3_defip_cam_bist_s8_status[0]=(((r).l3_defip_cam_bist_s8_status[0] & ~((uint32_t)0x7ff << 2)) | ((((uint32_t)f) & 0x7ff) << 2))
#define BCM56504_A0_L3_DEFIP_CAM_BIST_S8_STATUSr_EXPECTED_AINDEXf_GET(r) ((((r).l3_defip_cam_bist_s8_status[0]) >> 13) & 0x7ff)
#define BCM56504_A0_L3_DEFIP_CAM_BIST_S8_STATUSr_EXPECTED_AINDEXf_SET(r,f) (r).l3_defip_cam_bist_s8_status[0]=(((r).l3_defip_cam_bist_s8_status[0] & ~((uint32_t)0x7ff << 13)) | ((((uint32_t)f) & 0x7ff) << 13))

/*
 * These macros can be used to access L3_DEFIP_CAM_BIST_S8_STATUS.
 *
 */
#define BCM56504_A0_READ_L3_DEFIP_CAM_BIST_S8_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_L3_DEFIP_CAM_BIST_S8_STATUSr,(r._l3_defip_cam_bist_s8_status))
#define BCM56504_A0_WRITE_L3_DEFIP_CAM_BIST_S8_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_L3_DEFIP_CAM_BIST_S8_STATUSr,&(r._l3_defip_cam_bist_s8_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_DEFIP_CAM_BIST_S8_STATUSr BCM56504_A0_L3_DEFIP_CAM_BIST_S8_STATUSr
#define L3_DEFIP_CAM_BIST_S8_STATUSr_SIZE BCM56504_A0_L3_DEFIP_CAM_BIST_S8_STATUSr_SIZE
typedef BCM56504_A0_L3_DEFIP_CAM_BIST_S8_STATUSr_t L3_DEFIP_CAM_BIST_S8_STATUSr_t;
#define L3_DEFIP_CAM_BIST_S8_STATUSr_CLR BCM56504_A0_L3_DEFIP_CAM_BIST_S8_STATUSr_CLR
#define L3_DEFIP_CAM_BIST_S8_STATUSr_SET BCM56504_A0_L3_DEFIP_CAM_BIST_S8_STATUSr_SET
#define L3_DEFIP_CAM_BIST_S8_STATUSr_GET BCM56504_A0_L3_DEFIP_CAM_BIST_S8_STATUSr_GET
#define L3_DEFIP_CAM_BIST_S8_STATUSr_MATCH_STATUSf_GET BCM56504_A0_L3_DEFIP_CAM_BIST_S8_STATUSr_MATCH_STATUSf_GET
#define L3_DEFIP_CAM_BIST_S8_STATUSr_MATCH_STATUSf_SET BCM56504_A0_L3_DEFIP_CAM_BIST_S8_STATUSr_MATCH_STATUSf_SET
#define L3_DEFIP_CAM_BIST_S8_STATUSr_AINDEX_STATUSf_GET BCM56504_A0_L3_DEFIP_CAM_BIST_S8_STATUSr_AINDEX_STATUSf_GET
#define L3_DEFIP_CAM_BIST_S8_STATUSr_AINDEX_STATUSf_SET BCM56504_A0_L3_DEFIP_CAM_BIST_S8_STATUSr_AINDEX_STATUSf_SET
#define L3_DEFIP_CAM_BIST_S8_STATUSr_ACTUAL_AINDEXf_GET BCM56504_A0_L3_DEFIP_CAM_BIST_S8_STATUSr_ACTUAL_AINDEXf_GET
#define L3_DEFIP_CAM_BIST_S8_STATUSr_ACTUAL_AINDEXf_SET BCM56504_A0_L3_DEFIP_CAM_BIST_S8_STATUSr_ACTUAL_AINDEXf_SET
#define L3_DEFIP_CAM_BIST_S8_STATUSr_EXPECTED_AINDEXf_GET BCM56504_A0_L3_DEFIP_CAM_BIST_S8_STATUSr_EXPECTED_AINDEXf_GET
#define L3_DEFIP_CAM_BIST_S8_STATUSr_EXPECTED_AINDEXf_SET BCM56504_A0_L3_DEFIP_CAM_BIST_S8_STATUSr_EXPECTED_AINDEXf_SET
#define READ_L3_DEFIP_CAM_BIST_S8_STATUSr BCM56504_A0_READ_L3_DEFIP_CAM_BIST_S8_STATUSr
#define WRITE_L3_DEFIP_CAM_BIST_S8_STATUSr BCM56504_A0_WRITE_L3_DEFIP_CAM_BIST_S8_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_L3_DEFIP_CAM_BIST_S8_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  L3_DEFIP_CAM_BIST_STATUS
 * BLOCKS:   IPIPE
 * DESC:     L3_DEFIP_CAM_BIST_STATUS
 * SIZE:     32
 * FIELDS:
 *     BIST_GO          BIST pass/fail flag (1->pass)
 *     BIST_DONE        Inicates if the BIST has completed
 *
 ******************************************************************************/
#define BCM56504_A0_L3_DEFIP_CAM_BIST_STATUSr 0x08780002

#define BCM56504_A0_L3_DEFIP_CAM_BIST_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program L3_DEFIP_CAM_BIST_STATUS.
 *
 */
typedef union BCM56504_A0_L3_DEFIP_CAM_BIST_STATUSr_s {
	uint32_t v[1];
	uint32_t l3_defip_cam_bist_status[1];
	uint32_t _l3_defip_cam_bist_status;
} BCM56504_A0_L3_DEFIP_CAM_BIST_STATUSr_t;

#define BCM56504_A0_L3_DEFIP_CAM_BIST_STATUSr_CLR(r) (r).l3_defip_cam_bist_status[0] = 0
#define BCM56504_A0_L3_DEFIP_CAM_BIST_STATUSr_SET(r,d) (r).l3_defip_cam_bist_status[0] = d
#define BCM56504_A0_L3_DEFIP_CAM_BIST_STATUSr_GET(r) (r).l3_defip_cam_bist_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_L3_DEFIP_CAM_BIST_STATUSr_BIST_GOf_GET(r) (((r).l3_defip_cam_bist_status[0]) & 0x1)
#define BCM56504_A0_L3_DEFIP_CAM_BIST_STATUSr_BIST_GOf_SET(r,f) (r).l3_defip_cam_bist_status[0]=(((r).l3_defip_cam_bist_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_L3_DEFIP_CAM_BIST_STATUSr_BIST_DONEf_GET(r) ((((r).l3_defip_cam_bist_status[0]) >> 1) & 0x1)
#define BCM56504_A0_L3_DEFIP_CAM_BIST_STATUSr_BIST_DONEf_SET(r,f) (r).l3_defip_cam_bist_status[0]=(((r).l3_defip_cam_bist_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access L3_DEFIP_CAM_BIST_STATUS.
 *
 */
#define BCM56504_A0_READ_L3_DEFIP_CAM_BIST_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_L3_DEFIP_CAM_BIST_STATUSr,(r._l3_defip_cam_bist_status))
#define BCM56504_A0_WRITE_L3_DEFIP_CAM_BIST_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_L3_DEFIP_CAM_BIST_STATUSr,&(r._l3_defip_cam_bist_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_DEFIP_CAM_BIST_STATUSr BCM56504_A0_L3_DEFIP_CAM_BIST_STATUSr
#define L3_DEFIP_CAM_BIST_STATUSr_SIZE BCM56504_A0_L3_DEFIP_CAM_BIST_STATUSr_SIZE
typedef BCM56504_A0_L3_DEFIP_CAM_BIST_STATUSr_t L3_DEFIP_CAM_BIST_STATUSr_t;
#define L3_DEFIP_CAM_BIST_STATUSr_CLR BCM56504_A0_L3_DEFIP_CAM_BIST_STATUSr_CLR
#define L3_DEFIP_CAM_BIST_STATUSr_SET BCM56504_A0_L3_DEFIP_CAM_BIST_STATUSr_SET
#define L3_DEFIP_CAM_BIST_STATUSr_GET BCM56504_A0_L3_DEFIP_CAM_BIST_STATUSr_GET
#define L3_DEFIP_CAM_BIST_STATUSr_BIST_GOf_GET BCM56504_A0_L3_DEFIP_CAM_BIST_STATUSr_BIST_GOf_GET
#define L3_DEFIP_CAM_BIST_STATUSr_BIST_GOf_SET BCM56504_A0_L3_DEFIP_CAM_BIST_STATUSr_BIST_GOf_SET
#define L3_DEFIP_CAM_BIST_STATUSr_BIST_DONEf_GET BCM56504_A0_L3_DEFIP_CAM_BIST_STATUSr_BIST_DONEf_GET
#define L3_DEFIP_CAM_BIST_STATUSr_BIST_DONEf_SET BCM56504_A0_L3_DEFIP_CAM_BIST_STATUSr_BIST_DONEf_SET
#define READ_L3_DEFIP_CAM_BIST_STATUSr BCM56504_A0_READ_L3_DEFIP_CAM_BIST_STATUSr
#define WRITE_L3_DEFIP_CAM_BIST_STATUSr BCM56504_A0_WRITE_L3_DEFIP_CAM_BIST_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_L3_DEFIP_CAM_BIST_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  L3_DEFIP_CAM_CONTROL0
 * BLOCKS:   IPIPE
 * DESC:     L3_DEFIP_CAM_CONTROL0
 * SIZE:     32
 * FIELDS:
 *     CAM0_SAM         SAM debug bits for CAM0
 *     CAM1_SAM         SAM debug bits for CAM1
 *     CAM2_SAM         SAM debug bits for CAM2
 *     CAM3_SAM         SAM debug bits for CAM3
 *     CAM4_SAM         SAM debug bits for CAM4
 *     CAM5_SAM         SAM debug bits for CAM5
 *
 ******************************************************************************/
#define BCM56504_A0_L3_DEFIP_CAM_CONTROL0r 0x08780000

#define BCM56504_A0_L3_DEFIP_CAM_CONTROL0r_SIZE 4

/*
 * This structure should be used to declare and program L3_DEFIP_CAM_CONTROL0.
 *
 */
typedef union BCM56504_A0_L3_DEFIP_CAM_CONTROL0r_s {
	uint32_t v[1];
	uint32_t l3_defip_cam_control0[1];
	uint32_t _l3_defip_cam_control0;
} BCM56504_A0_L3_DEFIP_CAM_CONTROL0r_t;

#define BCM56504_A0_L3_DEFIP_CAM_CONTROL0r_CLR(r) (r).l3_defip_cam_control0[0] = 0
#define BCM56504_A0_L3_DEFIP_CAM_CONTROL0r_SET(r,d) (r).l3_defip_cam_control0[0] = d
#define BCM56504_A0_L3_DEFIP_CAM_CONTROL0r_GET(r) (r).l3_defip_cam_control0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_L3_DEFIP_CAM_CONTROL0r_CAM0_SAMf_GET(r) (((r).l3_defip_cam_control0[0]) & 0x7)
#define BCM56504_A0_L3_DEFIP_CAM_CONTROL0r_CAM0_SAMf_SET(r,f) (r).l3_defip_cam_control0[0]=(((r).l3_defip_cam_control0[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM56504_A0_L3_DEFIP_CAM_CONTROL0r_CAM1_SAMf_GET(r) ((((r).l3_defip_cam_control0[0]) >> 3) & 0x7)
#define BCM56504_A0_L3_DEFIP_CAM_CONTROL0r_CAM1_SAMf_SET(r,f) (r).l3_defip_cam_control0[0]=(((r).l3_defip_cam_control0[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM56504_A0_L3_DEFIP_CAM_CONTROL0r_CAM2_SAMf_GET(r) ((((r).l3_defip_cam_control0[0]) >> 6) & 0x7)
#define BCM56504_A0_L3_DEFIP_CAM_CONTROL0r_CAM2_SAMf_SET(r,f) (r).l3_defip_cam_control0[0]=(((r).l3_defip_cam_control0[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM56504_A0_L3_DEFIP_CAM_CONTROL0r_CAM3_SAMf_GET(r) ((((r).l3_defip_cam_control0[0]) >> 9) & 0x7)
#define BCM56504_A0_L3_DEFIP_CAM_CONTROL0r_CAM3_SAMf_SET(r,f) (r).l3_defip_cam_control0[0]=(((r).l3_defip_cam_control0[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM56504_A0_L3_DEFIP_CAM_CONTROL0r_CAM4_SAMf_GET(r) ((((r).l3_defip_cam_control0[0]) >> 12) & 0x7)
#define BCM56504_A0_L3_DEFIP_CAM_CONTROL0r_CAM4_SAMf_SET(r,f) (r).l3_defip_cam_control0[0]=(((r).l3_defip_cam_control0[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM56504_A0_L3_DEFIP_CAM_CONTROL0r_CAM5_SAMf_GET(r) ((((r).l3_defip_cam_control0[0]) >> 15) & 0x7)
#define BCM56504_A0_L3_DEFIP_CAM_CONTROL0r_CAM5_SAMf_SET(r,f) (r).l3_defip_cam_control0[0]=(((r).l3_defip_cam_control0[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))

/*
 * These macros can be used to access L3_DEFIP_CAM_CONTROL0.
 *
 */
#define BCM56504_A0_READ_L3_DEFIP_CAM_CONTROL0r(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_L3_DEFIP_CAM_CONTROL0r,(r._l3_defip_cam_control0))
#define BCM56504_A0_WRITE_L3_DEFIP_CAM_CONTROL0r(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_L3_DEFIP_CAM_CONTROL0r,&(r._l3_defip_cam_control0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_DEFIP_CAM_CONTROL0r BCM56504_A0_L3_DEFIP_CAM_CONTROL0r
#define L3_DEFIP_CAM_CONTROL0r_SIZE BCM56504_A0_L3_DEFIP_CAM_CONTROL0r_SIZE
typedef BCM56504_A0_L3_DEFIP_CAM_CONTROL0r_t L3_DEFIP_CAM_CONTROL0r_t;
#define L3_DEFIP_CAM_CONTROL0r_CLR BCM56504_A0_L3_DEFIP_CAM_CONTROL0r_CLR
#define L3_DEFIP_CAM_CONTROL0r_SET BCM56504_A0_L3_DEFIP_CAM_CONTROL0r_SET
#define L3_DEFIP_CAM_CONTROL0r_GET BCM56504_A0_L3_DEFIP_CAM_CONTROL0r_GET
#define L3_DEFIP_CAM_CONTROL0r_CAM0_SAMf_GET BCM56504_A0_L3_DEFIP_CAM_CONTROL0r_CAM0_SAMf_GET
#define L3_DEFIP_CAM_CONTROL0r_CAM0_SAMf_SET BCM56504_A0_L3_DEFIP_CAM_CONTROL0r_CAM0_SAMf_SET
#define L3_DEFIP_CAM_CONTROL0r_CAM1_SAMf_GET BCM56504_A0_L3_DEFIP_CAM_CONTROL0r_CAM1_SAMf_GET
#define L3_DEFIP_CAM_CONTROL0r_CAM1_SAMf_SET BCM56504_A0_L3_DEFIP_CAM_CONTROL0r_CAM1_SAMf_SET
#define L3_DEFIP_CAM_CONTROL0r_CAM2_SAMf_GET BCM56504_A0_L3_DEFIP_CAM_CONTROL0r_CAM2_SAMf_GET
#define L3_DEFIP_CAM_CONTROL0r_CAM2_SAMf_SET BCM56504_A0_L3_DEFIP_CAM_CONTROL0r_CAM2_SAMf_SET
#define L3_DEFIP_CAM_CONTROL0r_CAM3_SAMf_GET BCM56504_A0_L3_DEFIP_CAM_CONTROL0r_CAM3_SAMf_GET
#define L3_DEFIP_CAM_CONTROL0r_CAM3_SAMf_SET BCM56504_A0_L3_DEFIP_CAM_CONTROL0r_CAM3_SAMf_SET
#define L3_DEFIP_CAM_CONTROL0r_CAM4_SAMf_GET BCM56504_A0_L3_DEFIP_CAM_CONTROL0r_CAM4_SAMf_GET
#define L3_DEFIP_CAM_CONTROL0r_CAM4_SAMf_SET BCM56504_A0_L3_DEFIP_CAM_CONTROL0r_CAM4_SAMf_SET
#define L3_DEFIP_CAM_CONTROL0r_CAM5_SAMf_GET BCM56504_A0_L3_DEFIP_CAM_CONTROL0r_CAM5_SAMf_GET
#define L3_DEFIP_CAM_CONTROL0r_CAM5_SAMf_SET BCM56504_A0_L3_DEFIP_CAM_CONTROL0r_CAM5_SAMf_SET
#define READ_L3_DEFIP_CAM_CONTROL0r BCM56504_A0_READ_L3_DEFIP_CAM_CONTROL0r
#define WRITE_L3_DEFIP_CAM_CONTROL0r BCM56504_A0_WRITE_L3_DEFIP_CAM_CONTROL0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_L3_DEFIP_CAM_CONTROL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  L3_DEFIP_CAM_CONTROL1
 * BLOCKS:   IPIPE
 * DESC:     L3_DEFIP_CAM_CONTROL1
 * SIZE:     32
 * FIELDS:
 *     BIST_EN0         BIST enable for CAM0
 *     BIST_EN1         BIST enable for CAM1
 *     BIST_EN2         BIST enable for CAM2
 *     BIST_EN3         BIST enable for CAM3
 *     BIST_EN4         BIST enable for CAM4
 *     BIST_EN5         BIST enable for CAM5
 *     MODE             MODE=0 -> 32 bit mode, MODE=1 -> 64 bit mode
 *
 ******************************************************************************/
#define BCM56504_A0_L3_DEFIP_CAM_CONTROL1r 0x08780001

#define BCM56504_A0_L3_DEFIP_CAM_CONTROL1r_SIZE 4

/*
 * This structure should be used to declare and program L3_DEFIP_CAM_CONTROL1.
 *
 */
typedef union BCM56504_A0_L3_DEFIP_CAM_CONTROL1r_s {
	uint32_t v[1];
	uint32_t l3_defip_cam_control1[1];
	uint32_t _l3_defip_cam_control1;
} BCM56504_A0_L3_DEFIP_CAM_CONTROL1r_t;

#define BCM56504_A0_L3_DEFIP_CAM_CONTROL1r_CLR(r) (r).l3_defip_cam_control1[0] = 0
#define BCM56504_A0_L3_DEFIP_CAM_CONTROL1r_SET(r,d) (r).l3_defip_cam_control1[0] = d
#define BCM56504_A0_L3_DEFIP_CAM_CONTROL1r_GET(r) (r).l3_defip_cam_control1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_L3_DEFIP_CAM_CONTROL1r_BIST_EN0f_GET(r) (((r).l3_defip_cam_control1[0]) & 0x1)
#define BCM56504_A0_L3_DEFIP_CAM_CONTROL1r_BIST_EN0f_SET(r,f) (r).l3_defip_cam_control1[0]=(((r).l3_defip_cam_control1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_L3_DEFIP_CAM_CONTROL1r_BIST_EN1f_GET(r) ((((r).l3_defip_cam_control1[0]) >> 1) & 0x1)
#define BCM56504_A0_L3_DEFIP_CAM_CONTROL1r_BIST_EN1f_SET(r,f) (r).l3_defip_cam_control1[0]=(((r).l3_defip_cam_control1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_L3_DEFIP_CAM_CONTROL1r_BIST_EN2f_GET(r) ((((r).l3_defip_cam_control1[0]) >> 2) & 0x1)
#define BCM56504_A0_L3_DEFIP_CAM_CONTROL1r_BIST_EN2f_SET(r,f) (r).l3_defip_cam_control1[0]=(((r).l3_defip_cam_control1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_L3_DEFIP_CAM_CONTROL1r_BIST_EN3f_GET(r) ((((r).l3_defip_cam_control1[0]) >> 3) & 0x1)
#define BCM56504_A0_L3_DEFIP_CAM_CONTROL1r_BIST_EN3f_SET(r,f) (r).l3_defip_cam_control1[0]=(((r).l3_defip_cam_control1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_L3_DEFIP_CAM_CONTROL1r_BIST_EN4f_GET(r) ((((r).l3_defip_cam_control1[0]) >> 4) & 0x1)
#define BCM56504_A0_L3_DEFIP_CAM_CONTROL1r_BIST_EN4f_SET(r,f) (r).l3_defip_cam_control1[0]=(((r).l3_defip_cam_control1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56504_A0_L3_DEFIP_CAM_CONTROL1r_BIST_EN5f_GET(r) ((((r).l3_defip_cam_control1[0]) >> 5) & 0x1)
#define BCM56504_A0_L3_DEFIP_CAM_CONTROL1r_BIST_EN5f_SET(r,f) (r).l3_defip_cam_control1[0]=(((r).l3_defip_cam_control1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56504_A0_L3_DEFIP_CAM_CONTROL1r_MODEf_GET(r) ((((r).l3_defip_cam_control1[0]) >> 6) & 0x1)
#define BCM56504_A0_L3_DEFIP_CAM_CONTROL1r_MODEf_SET(r,f) (r).l3_defip_cam_control1[0]=(((r).l3_defip_cam_control1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))

/*
 * These macros can be used to access L3_DEFIP_CAM_CONTROL1.
 *
 */
#define BCM56504_A0_READ_L3_DEFIP_CAM_CONTROL1r(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_L3_DEFIP_CAM_CONTROL1r,(r._l3_defip_cam_control1))
#define BCM56504_A0_WRITE_L3_DEFIP_CAM_CONTROL1r(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_L3_DEFIP_CAM_CONTROL1r,&(r._l3_defip_cam_control1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_DEFIP_CAM_CONTROL1r BCM56504_A0_L3_DEFIP_CAM_CONTROL1r
#define L3_DEFIP_CAM_CONTROL1r_SIZE BCM56504_A0_L3_DEFIP_CAM_CONTROL1r_SIZE
typedef BCM56504_A0_L3_DEFIP_CAM_CONTROL1r_t L3_DEFIP_CAM_CONTROL1r_t;
#define L3_DEFIP_CAM_CONTROL1r_CLR BCM56504_A0_L3_DEFIP_CAM_CONTROL1r_CLR
#define L3_DEFIP_CAM_CONTROL1r_SET BCM56504_A0_L3_DEFIP_CAM_CONTROL1r_SET
#define L3_DEFIP_CAM_CONTROL1r_GET BCM56504_A0_L3_DEFIP_CAM_CONTROL1r_GET
#define L3_DEFIP_CAM_CONTROL1r_BIST_EN0f_GET BCM56504_A0_L3_DEFIP_CAM_CONTROL1r_BIST_EN0f_GET
#define L3_DEFIP_CAM_CONTROL1r_BIST_EN0f_SET BCM56504_A0_L3_DEFIP_CAM_CONTROL1r_BIST_EN0f_SET
#define L3_DEFIP_CAM_CONTROL1r_BIST_EN1f_GET BCM56504_A0_L3_DEFIP_CAM_CONTROL1r_BIST_EN1f_GET
#define L3_DEFIP_CAM_CONTROL1r_BIST_EN1f_SET BCM56504_A0_L3_DEFIP_CAM_CONTROL1r_BIST_EN1f_SET
#define L3_DEFIP_CAM_CONTROL1r_BIST_EN2f_GET BCM56504_A0_L3_DEFIP_CAM_CONTROL1r_BIST_EN2f_GET
#define L3_DEFIP_CAM_CONTROL1r_BIST_EN2f_SET BCM56504_A0_L3_DEFIP_CAM_CONTROL1r_BIST_EN2f_SET
#define L3_DEFIP_CAM_CONTROL1r_BIST_EN3f_GET BCM56504_A0_L3_DEFIP_CAM_CONTROL1r_BIST_EN3f_GET
#define L3_DEFIP_CAM_CONTROL1r_BIST_EN3f_SET BCM56504_A0_L3_DEFIP_CAM_CONTROL1r_BIST_EN3f_SET
#define L3_DEFIP_CAM_CONTROL1r_BIST_EN4f_GET BCM56504_A0_L3_DEFIP_CAM_CONTROL1r_BIST_EN4f_GET
#define L3_DEFIP_CAM_CONTROL1r_BIST_EN4f_SET BCM56504_A0_L3_DEFIP_CAM_CONTROL1r_BIST_EN4f_SET
#define L3_DEFIP_CAM_CONTROL1r_BIST_EN5f_GET BCM56504_A0_L3_DEFIP_CAM_CONTROL1r_BIST_EN5f_GET
#define L3_DEFIP_CAM_CONTROL1r_BIST_EN5f_SET BCM56504_A0_L3_DEFIP_CAM_CONTROL1r_BIST_EN5f_SET
#define L3_DEFIP_CAM_CONTROL1r_MODEf_GET BCM56504_A0_L3_DEFIP_CAM_CONTROL1r_MODEf_GET
#define L3_DEFIP_CAM_CONTROL1r_MODEf_SET BCM56504_A0_L3_DEFIP_CAM_CONTROL1r_MODEf_SET
#define READ_L3_DEFIP_CAM_CONTROL1r BCM56504_A0_READ_L3_DEFIP_CAM_CONTROL1r
#define WRITE_L3_DEFIP_CAM_CONTROL1r BCM56504_A0_WRITE_L3_DEFIP_CAM_CONTROL1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_L3_DEFIP_CAM_CONTROL1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  L3_DEFIP_CAM_ENABLE
 * BLOCKS:   IPIPE
 * DESC:     L3_DEFIP_CAM_ENABLE
 * SIZE:     32
 * FIELDS:
 *     CAM_0_ENABLE     L3_DEFIP_CAM_ENABLE FOR L3_DEFIP SLICE 0
 *     CAM_1_ENABLE     L3_DEFIP_CAM_ENABLE FOR L3_DEFIP SLICE 1
 *     CAM_2_ENABLE     L3_DEFIP_CAM_ENABLE FOR L3_DEFIP SLICE 2
 *     CAM_3_ENABLE     L3_DEFIP_CAM_ENABLE FOR L3_DEFIP SLICE 3
 *     CAM_4_ENABLE     L3_DEFIP_CAM_ENABLE FOR L3_DEFIP SLICE 4
 *     CAM_5_ENABLE     L3_DEFIP_CAM_ENABLE FOR L3_DEFIP SLICE 5
 *
 ******************************************************************************/
#define BCM56504_A0_L3_DEFIP_CAM_ENABLEr 0x08780009

#define BCM56504_A0_L3_DEFIP_CAM_ENABLEr_SIZE 4

/*
 * This structure should be used to declare and program L3_DEFIP_CAM_ENABLE.
 *
 */
typedef union BCM56504_A0_L3_DEFIP_CAM_ENABLEr_s {
	uint32_t v[1];
	uint32_t l3_defip_cam_enable[1];
	uint32_t _l3_defip_cam_enable;
} BCM56504_A0_L3_DEFIP_CAM_ENABLEr_t;

#define BCM56504_A0_L3_DEFIP_CAM_ENABLEr_CLR(r) (r).l3_defip_cam_enable[0] = 0
#define BCM56504_A0_L3_DEFIP_CAM_ENABLEr_SET(r,d) (r).l3_defip_cam_enable[0] = d
#define BCM56504_A0_L3_DEFIP_CAM_ENABLEr_GET(r) (r).l3_defip_cam_enable[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_L3_DEFIP_CAM_ENABLEr_CAM_0_ENABLEf_GET(r) (((r).l3_defip_cam_enable[0]) & 0x1)
#define BCM56504_A0_L3_DEFIP_CAM_ENABLEr_CAM_0_ENABLEf_SET(r,f) (r).l3_defip_cam_enable[0]=(((r).l3_defip_cam_enable[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_L3_DEFIP_CAM_ENABLEr_CAM_1_ENABLEf_GET(r) ((((r).l3_defip_cam_enable[0]) >> 1) & 0x1)
#define BCM56504_A0_L3_DEFIP_CAM_ENABLEr_CAM_1_ENABLEf_SET(r,f) (r).l3_defip_cam_enable[0]=(((r).l3_defip_cam_enable[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_L3_DEFIP_CAM_ENABLEr_CAM_2_ENABLEf_GET(r) ((((r).l3_defip_cam_enable[0]) >> 2) & 0x1)
#define BCM56504_A0_L3_DEFIP_CAM_ENABLEr_CAM_2_ENABLEf_SET(r,f) (r).l3_defip_cam_enable[0]=(((r).l3_defip_cam_enable[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_L3_DEFIP_CAM_ENABLEr_CAM_3_ENABLEf_GET(r) ((((r).l3_defip_cam_enable[0]) >> 3) & 0x1)
#define BCM56504_A0_L3_DEFIP_CAM_ENABLEr_CAM_3_ENABLEf_SET(r,f) (r).l3_defip_cam_enable[0]=(((r).l3_defip_cam_enable[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_L3_DEFIP_CAM_ENABLEr_CAM_4_ENABLEf_GET(r) ((((r).l3_defip_cam_enable[0]) >> 4) & 0x1)
#define BCM56504_A0_L3_DEFIP_CAM_ENABLEr_CAM_4_ENABLEf_SET(r,f) (r).l3_defip_cam_enable[0]=(((r).l3_defip_cam_enable[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56504_A0_L3_DEFIP_CAM_ENABLEr_CAM_5_ENABLEf_GET(r) ((((r).l3_defip_cam_enable[0]) >> 5) & 0x1)
#define BCM56504_A0_L3_DEFIP_CAM_ENABLEr_CAM_5_ENABLEf_SET(r,f) (r).l3_defip_cam_enable[0]=(((r).l3_defip_cam_enable[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))

/*
 * These macros can be used to access L3_DEFIP_CAM_ENABLE.
 *
 */
#define BCM56504_A0_READ_L3_DEFIP_CAM_ENABLEr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_L3_DEFIP_CAM_ENABLEr,(r._l3_defip_cam_enable))
#define BCM56504_A0_WRITE_L3_DEFIP_CAM_ENABLEr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_L3_DEFIP_CAM_ENABLEr,&(r._l3_defip_cam_enable))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_DEFIP_CAM_ENABLEr BCM56504_A0_L3_DEFIP_CAM_ENABLEr
#define L3_DEFIP_CAM_ENABLEr_SIZE BCM56504_A0_L3_DEFIP_CAM_ENABLEr_SIZE
typedef BCM56504_A0_L3_DEFIP_CAM_ENABLEr_t L3_DEFIP_CAM_ENABLEr_t;
#define L3_DEFIP_CAM_ENABLEr_CLR BCM56504_A0_L3_DEFIP_CAM_ENABLEr_CLR
#define L3_DEFIP_CAM_ENABLEr_SET BCM56504_A0_L3_DEFIP_CAM_ENABLEr_SET
#define L3_DEFIP_CAM_ENABLEr_GET BCM56504_A0_L3_DEFIP_CAM_ENABLEr_GET
#define L3_DEFIP_CAM_ENABLEr_CAM_0_ENABLEf_GET BCM56504_A0_L3_DEFIP_CAM_ENABLEr_CAM_0_ENABLEf_GET
#define L3_DEFIP_CAM_ENABLEr_CAM_0_ENABLEf_SET BCM56504_A0_L3_DEFIP_CAM_ENABLEr_CAM_0_ENABLEf_SET
#define L3_DEFIP_CAM_ENABLEr_CAM_1_ENABLEf_GET BCM56504_A0_L3_DEFIP_CAM_ENABLEr_CAM_1_ENABLEf_GET
#define L3_DEFIP_CAM_ENABLEr_CAM_1_ENABLEf_SET BCM56504_A0_L3_DEFIP_CAM_ENABLEr_CAM_1_ENABLEf_SET
#define L3_DEFIP_CAM_ENABLEr_CAM_2_ENABLEf_GET BCM56504_A0_L3_DEFIP_CAM_ENABLEr_CAM_2_ENABLEf_GET
#define L3_DEFIP_CAM_ENABLEr_CAM_2_ENABLEf_SET BCM56504_A0_L3_DEFIP_CAM_ENABLEr_CAM_2_ENABLEf_SET
#define L3_DEFIP_CAM_ENABLEr_CAM_3_ENABLEf_GET BCM56504_A0_L3_DEFIP_CAM_ENABLEr_CAM_3_ENABLEf_GET
#define L3_DEFIP_CAM_ENABLEr_CAM_3_ENABLEf_SET BCM56504_A0_L3_DEFIP_CAM_ENABLEr_CAM_3_ENABLEf_SET
#define L3_DEFIP_CAM_ENABLEr_CAM_4_ENABLEf_GET BCM56504_A0_L3_DEFIP_CAM_ENABLEr_CAM_4_ENABLEf_GET
#define L3_DEFIP_CAM_ENABLEr_CAM_4_ENABLEf_SET BCM56504_A0_L3_DEFIP_CAM_ENABLEr_CAM_4_ENABLEf_SET
#define L3_DEFIP_CAM_ENABLEr_CAM_5_ENABLEf_GET BCM56504_A0_L3_DEFIP_CAM_ENABLEr_CAM_5_ENABLEf_GET
#define L3_DEFIP_CAM_ENABLEr_CAM_5_ENABLEf_SET BCM56504_A0_L3_DEFIP_CAM_ENABLEr_CAM_5_ENABLEf_SET
#define READ_L3_DEFIP_CAM_ENABLEr BCM56504_A0_READ_L3_DEFIP_CAM_ENABLEr
#define WRITE_L3_DEFIP_CAM_ENABLEr BCM56504_A0_WRITE_L3_DEFIP_CAM_ENABLEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_L3_DEFIP_CAM_ENABLEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  L3_DEFIP_DATA_ONLY
 * BLOCKS:   IPIPE
 * DESC:     L3 Default IP Route (LPM) Data SRAM for the L3_DEFIP TCAM
 * SIZE:     42
 * FIELDS:
 *     ECMP1            Indicates if route for half-entry 1 uses ECMP
 *     ECMP_PTR1        Ptr to ECMP group within ECMP table for half-entry 1
 *     ECMP_COUNT1      No. of ECMP routes in group for half-entry 1
 *     PRI1             Priority for half-entry 1
 *     RPE1             RPE bit for half-entry 1
 *     ECMP0            Indicates if route for half-entry 0 uses ECMP
 *     ECMP_PTR0        Ptr to ECMP group within ECMP table for half-entry 0
 *     ECMP_COUNT0      No. of ECMP routes in group for half-entry 0
 *     PRI0             Priority for half-entry 0
 *     RPE0             RPE bit for half-entry 0
 *     NEXT_HOP_INDEX1  Next hop index pointer for half-entry 1
 *     NEXT_HOP_INDEX0  Next hop index pointer for half-entry 0
 *
 ******************************************************************************/
#define BCM56504_A0_L3_DEFIP_DATA_ONLYm 0x0a720000

#define BCM56504_A0_L3_DEFIP_DATA_ONLYm_MIN 0
#define BCM56504_A0_L3_DEFIP_DATA_ONLYm_MAX 6143
#define BCM56504_A0_L3_DEFIP_DATA_ONLYm_CMAX(u) 6143
#define BCM56504_A0_L3_DEFIP_DATA_ONLYm_SIZE 6

/*
 * This structure should be used to declare and program L3_DEFIP_DATA_ONLY.
 *
 */
typedef union BCM56504_A0_L3_DEFIP_DATA_ONLYm_s {
	uint32_t v[2];
	uint32_t l3_defip_data_only[2];
	uint32_t _l3_defip_data_only;
} BCM56504_A0_L3_DEFIP_DATA_ONLYm_t;

#define BCM56504_A0_L3_DEFIP_DATA_ONLYm_CLR(r) CDK_MEMSET(&((r)._l3_defip_data_only), 0, sizeof(BCM56504_A0_L3_DEFIP_DATA_ONLYm_t))
#define BCM56504_A0_L3_DEFIP_DATA_ONLYm_SET(r,i,d) (r).l3_defip_data_only[i] = d
#define BCM56504_A0_L3_DEFIP_DATA_ONLYm_GET(r,i) (r).l3_defip_data_only[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_L3_DEFIP_DATA_ONLYm_ECMP1f_GET(r) (((r).l3_defip_data_only[0]) & 0x1)
#define BCM56504_A0_L3_DEFIP_DATA_ONLYm_ECMP1f_SET(r,f) (r).l3_defip_data_only[0]=(((r).l3_defip_data_only[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_L3_DEFIP_DATA_ONLYm_ECMP_PTR1f_GET(r) ((((r).l3_defip_data_only[0]) >> 1) & 0x7ff)
#define BCM56504_A0_L3_DEFIP_DATA_ONLYm_ECMP_PTR1f_SET(r,f) (r).l3_defip_data_only[0]=(((r).l3_defip_data_only[0] & ~((uint32_t)0x7ff << 1)) | ((((uint32_t)f) & 0x7ff) << 1))
#define BCM56504_A0_L3_DEFIP_DATA_ONLYm_ECMP_COUNT1f_GET(r) ((((r).l3_defip_data_only[0]) >> 12) & 0x1f)
#define BCM56504_A0_L3_DEFIP_DATA_ONLYm_ECMP_COUNT1f_SET(r,f) (r).l3_defip_data_only[0]=(((r).l3_defip_data_only[0] & ~((uint32_t)0x1f << 12)) | ((((uint32_t)f) & 0x1f) << 12))
#define BCM56504_A0_L3_DEFIP_DATA_ONLYm_PRI1f_GET(r) ((((r).l3_defip_data_only[0]) >> 17) & 0x7)
#define BCM56504_A0_L3_DEFIP_DATA_ONLYm_PRI1f_SET(r,f) (r).l3_defip_data_only[0]=(((r).l3_defip_data_only[0] & ~((uint32_t)0x7 << 17)) | ((((uint32_t)f) & 0x7) << 17))
#define BCM56504_A0_L3_DEFIP_DATA_ONLYm_RPE1f_GET(r) ((((r).l3_defip_data_only[0]) >> 20) & 0x1)
#define BCM56504_A0_L3_DEFIP_DATA_ONLYm_RPE1f_SET(r,f) (r).l3_defip_data_only[0]=(((r).l3_defip_data_only[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM56504_A0_L3_DEFIP_DATA_ONLYm_ECMP0f_GET(r) ((((r).l3_defip_data_only[0]) >> 21) & 0x1)
#define BCM56504_A0_L3_DEFIP_DATA_ONLYm_ECMP0f_SET(r,f) (r).l3_defip_data_only[0]=(((r).l3_defip_data_only[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM56504_A0_L3_DEFIP_DATA_ONLYm_ECMP_PTR0f_GET(r) cdk_field32_get((r).l3_defip_data_only,22,32)
#define BCM56504_A0_L3_DEFIP_DATA_ONLYm_ECMP_PTR0f_SET(r,f) cdk_field32_set((r).l3_defip_data_only,22,32,f)
#define BCM56504_A0_L3_DEFIP_DATA_ONLYm_ECMP_COUNT0f_GET(r) ((((r).l3_defip_data_only[1]) >> 1) & 0x1f)
#define BCM56504_A0_L3_DEFIP_DATA_ONLYm_ECMP_COUNT0f_SET(r,f) (r).l3_defip_data_only[1]=(((r).l3_defip_data_only[1] & ~((uint32_t)0x1f << 1)) | ((((uint32_t)f) & 0x1f) << 1))
#define BCM56504_A0_L3_DEFIP_DATA_ONLYm_PRI0f_GET(r) ((((r).l3_defip_data_only[1]) >> 6) & 0x7)
#define BCM56504_A0_L3_DEFIP_DATA_ONLYm_PRI0f_SET(r,f) (r).l3_defip_data_only[1]=(((r).l3_defip_data_only[1] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM56504_A0_L3_DEFIP_DATA_ONLYm_RPE0f_GET(r) ((((r).l3_defip_data_only[1]) >> 9) & 0x1)
#define BCM56504_A0_L3_DEFIP_DATA_ONLYm_RPE0f_SET(r,f) (r).l3_defip_data_only[1]=(((r).l3_defip_data_only[1] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56504_A0_L3_DEFIP_DATA_ONLYm_NEXT_HOP_INDEX1f_GET(r) ((((r).l3_defip_data_only[0]) >> 1) & 0x1fff)
#define BCM56504_A0_L3_DEFIP_DATA_ONLYm_NEXT_HOP_INDEX1f_SET(r,f) (r).l3_defip_data_only[0]=(((r).l3_defip_data_only[0] & ~((uint32_t)0x1fff << 1)) | ((((uint32_t)f) & 0x1fff) << 1))
#define BCM56504_A0_L3_DEFIP_DATA_ONLYm_NEXT_HOP_INDEX0f_GET(r) cdk_field32_get((r).l3_defip_data_only,22,34)
#define BCM56504_A0_L3_DEFIP_DATA_ONLYm_NEXT_HOP_INDEX0f_SET(r,f) cdk_field32_set((r).l3_defip_data_only,22,34,f)

/*
 * These macros can be used to access L3_DEFIP_DATA_ONLY.
 *
 */
#define BCM56504_A0_READ_L3_DEFIP_DATA_ONLYm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_L3_DEFIP_DATA_ONLYm,i,(m._l3_defip_data_only),2)
#define BCM56504_A0_WRITE_L3_DEFIP_DATA_ONLYm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_L3_DEFIP_DATA_ONLYm,i,&(m._l3_defip_data_only),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_DEFIP_DATA_ONLYm BCM56504_A0_L3_DEFIP_DATA_ONLYm
#define L3_DEFIP_DATA_ONLYm_MIN BCM56504_A0_L3_DEFIP_DATA_ONLYm_MIN
#define L3_DEFIP_DATA_ONLYm_MAX BCM56504_A0_L3_DEFIP_DATA_ONLYm_MAX
#define L3_DEFIP_DATA_ONLYm_CMAX(u) BCM56504_A0_L3_DEFIP_DATA_ONLYm_CMAX(u)
#define L3_DEFIP_DATA_ONLYm_SIZE BCM56504_A0_L3_DEFIP_DATA_ONLYm_SIZE
typedef BCM56504_A0_L3_DEFIP_DATA_ONLYm_t L3_DEFIP_DATA_ONLYm_t;
#define L3_DEFIP_DATA_ONLYm_CLR BCM56504_A0_L3_DEFIP_DATA_ONLYm_CLR
#define L3_DEFIP_DATA_ONLYm_SET BCM56504_A0_L3_DEFIP_DATA_ONLYm_SET
#define L3_DEFIP_DATA_ONLYm_GET BCM56504_A0_L3_DEFIP_DATA_ONLYm_GET
#define L3_DEFIP_DATA_ONLYm_ECMP1f_GET BCM56504_A0_L3_DEFIP_DATA_ONLYm_ECMP1f_GET
#define L3_DEFIP_DATA_ONLYm_ECMP1f_SET BCM56504_A0_L3_DEFIP_DATA_ONLYm_ECMP1f_SET
#define L3_DEFIP_DATA_ONLYm_ECMP_PTR1f_GET BCM56504_A0_L3_DEFIP_DATA_ONLYm_ECMP_PTR1f_GET
#define L3_DEFIP_DATA_ONLYm_ECMP_PTR1f_SET BCM56504_A0_L3_DEFIP_DATA_ONLYm_ECMP_PTR1f_SET
#define L3_DEFIP_DATA_ONLYm_ECMP_COUNT1f_GET BCM56504_A0_L3_DEFIP_DATA_ONLYm_ECMP_COUNT1f_GET
#define L3_DEFIP_DATA_ONLYm_ECMP_COUNT1f_SET BCM56504_A0_L3_DEFIP_DATA_ONLYm_ECMP_COUNT1f_SET
#define L3_DEFIP_DATA_ONLYm_PRI1f_GET BCM56504_A0_L3_DEFIP_DATA_ONLYm_PRI1f_GET
#define L3_DEFIP_DATA_ONLYm_PRI1f_SET BCM56504_A0_L3_DEFIP_DATA_ONLYm_PRI1f_SET
#define L3_DEFIP_DATA_ONLYm_RPE1f_GET BCM56504_A0_L3_DEFIP_DATA_ONLYm_RPE1f_GET
#define L3_DEFIP_DATA_ONLYm_RPE1f_SET BCM56504_A0_L3_DEFIP_DATA_ONLYm_RPE1f_SET
#define L3_DEFIP_DATA_ONLYm_ECMP0f_GET BCM56504_A0_L3_DEFIP_DATA_ONLYm_ECMP0f_GET
#define L3_DEFIP_DATA_ONLYm_ECMP0f_SET BCM56504_A0_L3_DEFIP_DATA_ONLYm_ECMP0f_SET
#define L3_DEFIP_DATA_ONLYm_ECMP_PTR0f_GET BCM56504_A0_L3_DEFIP_DATA_ONLYm_ECMP_PTR0f_GET
#define L3_DEFIP_DATA_ONLYm_ECMP_PTR0f_SET BCM56504_A0_L3_DEFIP_DATA_ONLYm_ECMP_PTR0f_SET
#define L3_DEFIP_DATA_ONLYm_ECMP_COUNT0f_GET BCM56504_A0_L3_DEFIP_DATA_ONLYm_ECMP_COUNT0f_GET
#define L3_DEFIP_DATA_ONLYm_ECMP_COUNT0f_SET BCM56504_A0_L3_DEFIP_DATA_ONLYm_ECMP_COUNT0f_SET
#define L3_DEFIP_DATA_ONLYm_PRI0f_GET BCM56504_A0_L3_DEFIP_DATA_ONLYm_PRI0f_GET
#define L3_DEFIP_DATA_ONLYm_PRI0f_SET BCM56504_A0_L3_DEFIP_DATA_ONLYm_PRI0f_SET
#define L3_DEFIP_DATA_ONLYm_RPE0f_GET BCM56504_A0_L3_DEFIP_DATA_ONLYm_RPE0f_GET
#define L3_DEFIP_DATA_ONLYm_RPE0f_SET BCM56504_A0_L3_DEFIP_DATA_ONLYm_RPE0f_SET
#define L3_DEFIP_DATA_ONLYm_NEXT_HOP_INDEX1f_GET BCM56504_A0_L3_DEFIP_DATA_ONLYm_NEXT_HOP_INDEX1f_GET
#define L3_DEFIP_DATA_ONLYm_NEXT_HOP_INDEX1f_SET BCM56504_A0_L3_DEFIP_DATA_ONLYm_NEXT_HOP_INDEX1f_SET
#define L3_DEFIP_DATA_ONLYm_NEXT_HOP_INDEX0f_GET BCM56504_A0_L3_DEFIP_DATA_ONLYm_NEXT_HOP_INDEX0f_GET
#define L3_DEFIP_DATA_ONLYm_NEXT_HOP_INDEX0f_SET BCM56504_A0_L3_DEFIP_DATA_ONLYm_NEXT_HOP_INDEX0f_SET
#define READ_L3_DEFIP_DATA_ONLYm BCM56504_A0_READ_L3_DEFIP_DATA_ONLYm
#define WRITE_L3_DEFIP_DATA_ONLYm BCM56504_A0_WRITE_L3_DEFIP_DATA_ONLYm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_L3_DEFIP_DATA_ONLYm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  L3_DEFIP_HIT_ONLY
 * BLOCKS:   IPIPE
 * DESC:     L3_DEFIP Hit bit table
 * SIZE:     2
 * FIELDS:
 *     HIT0             Indicates that the entry #0 has been hit
 *     HIT1             Indicates that the entry #1 has been hit
 *
 ******************************************************************************/
#define BCM56504_A0_L3_DEFIP_HIT_ONLYm 0x0b720000

#define BCM56504_A0_L3_DEFIP_HIT_ONLYm_MIN 0
#define BCM56504_A0_L3_DEFIP_HIT_ONLYm_MAX 6143
#define BCM56504_A0_L3_DEFIP_HIT_ONLYm_CMAX(u) 6143
#define BCM56504_A0_L3_DEFIP_HIT_ONLYm_SIZE 1

/*
 * This structure should be used to declare and program L3_DEFIP_HIT_ONLY.
 *
 */
typedef union BCM56504_A0_L3_DEFIP_HIT_ONLYm_s {
	uint32_t v[1];
	uint32_t l3_defip_hit_only[1];
	uint32_t _l3_defip_hit_only;
} BCM56504_A0_L3_DEFIP_HIT_ONLYm_t;

#define BCM56504_A0_L3_DEFIP_HIT_ONLYm_CLR(r) (r).l3_defip_hit_only[0] = 0
#define BCM56504_A0_L3_DEFIP_HIT_ONLYm_SET(r,d) (r).l3_defip_hit_only[0] = d
#define BCM56504_A0_L3_DEFIP_HIT_ONLYm_GET(r) (r).l3_defip_hit_only[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_L3_DEFIP_HIT_ONLYm_HIT0f_GET(r) (((r).l3_defip_hit_only[0]) & 0x1)
#define BCM56504_A0_L3_DEFIP_HIT_ONLYm_HIT0f_SET(r,f) (r).l3_defip_hit_only[0]=(((r).l3_defip_hit_only[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_L3_DEFIP_HIT_ONLYm_HIT1f_GET(r) ((((r).l3_defip_hit_only[0]) >> 1) & 0x1)
#define BCM56504_A0_L3_DEFIP_HIT_ONLYm_HIT1f_SET(r,f) (r).l3_defip_hit_only[0]=(((r).l3_defip_hit_only[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access L3_DEFIP_HIT_ONLY.
 *
 */
#define BCM56504_A0_READ_L3_DEFIP_HIT_ONLYm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_L3_DEFIP_HIT_ONLYm,i,(m._l3_defip_hit_only),1)
#define BCM56504_A0_WRITE_L3_DEFIP_HIT_ONLYm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_L3_DEFIP_HIT_ONLYm,i,&(m._l3_defip_hit_only),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_DEFIP_HIT_ONLYm BCM56504_A0_L3_DEFIP_HIT_ONLYm
#define L3_DEFIP_HIT_ONLYm_MIN BCM56504_A0_L3_DEFIP_HIT_ONLYm_MIN
#define L3_DEFIP_HIT_ONLYm_MAX BCM56504_A0_L3_DEFIP_HIT_ONLYm_MAX
#define L3_DEFIP_HIT_ONLYm_CMAX(u) BCM56504_A0_L3_DEFIP_HIT_ONLYm_CMAX(u)
#define L3_DEFIP_HIT_ONLYm_SIZE BCM56504_A0_L3_DEFIP_HIT_ONLYm_SIZE
typedef BCM56504_A0_L3_DEFIP_HIT_ONLYm_t L3_DEFIP_HIT_ONLYm_t;
#define L3_DEFIP_HIT_ONLYm_CLR BCM56504_A0_L3_DEFIP_HIT_ONLYm_CLR
#define L3_DEFIP_HIT_ONLYm_SET BCM56504_A0_L3_DEFIP_HIT_ONLYm_SET
#define L3_DEFIP_HIT_ONLYm_GET BCM56504_A0_L3_DEFIP_HIT_ONLYm_GET
#define L3_DEFIP_HIT_ONLYm_HIT0f_GET BCM56504_A0_L3_DEFIP_HIT_ONLYm_HIT0f_GET
#define L3_DEFIP_HIT_ONLYm_HIT0f_SET BCM56504_A0_L3_DEFIP_HIT_ONLYm_HIT0f_SET
#define L3_DEFIP_HIT_ONLYm_HIT1f_GET BCM56504_A0_L3_DEFIP_HIT_ONLYm_HIT1f_GET
#define L3_DEFIP_HIT_ONLYm_HIT1f_SET BCM56504_A0_L3_DEFIP_HIT_ONLYm_HIT1f_SET
#define READ_L3_DEFIP_HIT_ONLYm BCM56504_A0_READ_L3_DEFIP_HIT_ONLYm
#define WRITE_L3_DEFIP_HIT_ONLYm BCM56504_A0_WRITE_L3_DEFIP_HIT_ONLYm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_L3_DEFIP_HIT_ONLYm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  L3_DEFIP_ONLY
 * BLOCKS:   IPIPE
 * DESC:     L3 Default IP Route (LPM) TCAM only view
 * SIZE:     132
 * FIELDS:
 *     VALID0           Indicates half-entry 0 is valid
 *     VALID1           Indicates half-entry 1 is valid
 *     MODE0            Indicates contents of half-entry 0; 0=IPv4, 1=IPv6
 *     MODE1            Indicates contents of half-entry 1; 0=IPv4, 1=IPv6
 *     IP_ADDR0         IP address bits for half-entry 0
 *     IP_ADDR1         IP address bits for half-entry 1
 *     MASK0            Subnet mask for half-entry 0
 *     MASK1            Subnet mask for half-entry 1
 *
 ******************************************************************************/
#define BCM56504_A0_L3_DEFIP_ONLYm 0x0a710000

#define BCM56504_A0_L3_DEFIP_ONLYm_MIN 0
#define BCM56504_A0_L3_DEFIP_ONLYm_MAX 6143
#define BCM56504_A0_L3_DEFIP_ONLYm_CMAX(u) 6143
#define BCM56504_A0_L3_DEFIP_ONLYm_SIZE 17

/*
 * This structure should be used to declare and program L3_DEFIP_ONLY.
 *
 */
typedef union BCM56504_A0_L3_DEFIP_ONLYm_s {
	uint32_t v[5];
	uint32_t l3_defip_only[5];
	uint32_t _l3_defip_only;
} BCM56504_A0_L3_DEFIP_ONLYm_t;

#define BCM56504_A0_L3_DEFIP_ONLYm_CLR(r) CDK_MEMSET(&((r)._l3_defip_only), 0, sizeof(BCM56504_A0_L3_DEFIP_ONLYm_t))
#define BCM56504_A0_L3_DEFIP_ONLYm_SET(r,i,d) (r).l3_defip_only[i] = d
#define BCM56504_A0_L3_DEFIP_ONLYm_GET(r,i) (r).l3_defip_only[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_L3_DEFIP_ONLYm_VALID0f_GET(r) (((r).l3_defip_only[0]) & 0x1)
#define BCM56504_A0_L3_DEFIP_ONLYm_VALID0f_SET(r,f) (r).l3_defip_only[0]=(((r).l3_defip_only[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_L3_DEFIP_ONLYm_VALID1f_GET(r) ((((r).l3_defip_only[0]) >> 1) & 0x1)
#define BCM56504_A0_L3_DEFIP_ONLYm_VALID1f_SET(r,f) (r).l3_defip_only[0]=(((r).l3_defip_only[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_L3_DEFIP_ONLYm_MODE0f_GET(r) ((((r).l3_defip_only[0]) >> 2) & 0x1)
#define BCM56504_A0_L3_DEFIP_ONLYm_MODE0f_SET(r,f) (r).l3_defip_only[0]=(((r).l3_defip_only[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_L3_DEFIP_ONLYm_MODE1f_GET(r) ((((r).l3_defip_only[0]) >> 3) & 0x1)
#define BCM56504_A0_L3_DEFIP_ONLYm_MODE1f_SET(r,f) (r).l3_defip_only[0]=(((r).l3_defip_only[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_L3_DEFIP_ONLYm_IP_ADDR0f_GET(r) cdk_field32_get((r).l3_defip_only,4,35)
#define BCM56504_A0_L3_DEFIP_ONLYm_IP_ADDR0f_SET(r,f) cdk_field32_set((r).l3_defip_only,4,35,f)
#define BCM56504_A0_L3_DEFIP_ONLYm_IP_ADDR1f_GET(r) cdk_field32_get((r).l3_defip_only,36,67)
#define BCM56504_A0_L3_DEFIP_ONLYm_IP_ADDR1f_SET(r,f) cdk_field32_set((r).l3_defip_only,36,67,f)
#define BCM56504_A0_L3_DEFIP_ONLYm_MASK0f_GET(r) cdk_field32_get((r).l3_defip_only,68,99)
#define BCM56504_A0_L3_DEFIP_ONLYm_MASK0f_SET(r,f) cdk_field32_set((r).l3_defip_only,68,99,f)
#define BCM56504_A0_L3_DEFIP_ONLYm_MASK1f_GET(r) cdk_field32_get((r).l3_defip_only,100,131)
#define BCM56504_A0_L3_DEFIP_ONLYm_MASK1f_SET(r,f) cdk_field32_set((r).l3_defip_only,100,131,f)

/*
 * These macros can be used to access L3_DEFIP_ONLY.
 *
 */
#define BCM56504_A0_READ_L3_DEFIP_ONLYm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_L3_DEFIP_ONLYm,i,(m._l3_defip_only),5)
#define BCM56504_A0_WRITE_L3_DEFIP_ONLYm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_L3_DEFIP_ONLYm,i,&(m._l3_defip_only),5)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_DEFIP_ONLYm BCM56504_A0_L3_DEFIP_ONLYm
#define L3_DEFIP_ONLYm_MIN BCM56504_A0_L3_DEFIP_ONLYm_MIN
#define L3_DEFIP_ONLYm_MAX BCM56504_A0_L3_DEFIP_ONLYm_MAX
#define L3_DEFIP_ONLYm_CMAX(u) BCM56504_A0_L3_DEFIP_ONLYm_CMAX(u)
#define L3_DEFIP_ONLYm_SIZE BCM56504_A0_L3_DEFIP_ONLYm_SIZE
typedef BCM56504_A0_L3_DEFIP_ONLYm_t L3_DEFIP_ONLYm_t;
#define L3_DEFIP_ONLYm_CLR BCM56504_A0_L3_DEFIP_ONLYm_CLR
#define L3_DEFIP_ONLYm_SET BCM56504_A0_L3_DEFIP_ONLYm_SET
#define L3_DEFIP_ONLYm_GET BCM56504_A0_L3_DEFIP_ONLYm_GET
#define L3_DEFIP_ONLYm_VALID0f_GET BCM56504_A0_L3_DEFIP_ONLYm_VALID0f_GET
#define L3_DEFIP_ONLYm_VALID0f_SET BCM56504_A0_L3_DEFIP_ONLYm_VALID0f_SET
#define L3_DEFIP_ONLYm_VALID1f_GET BCM56504_A0_L3_DEFIP_ONLYm_VALID1f_GET
#define L3_DEFIP_ONLYm_VALID1f_SET BCM56504_A0_L3_DEFIP_ONLYm_VALID1f_SET
#define L3_DEFIP_ONLYm_MODE0f_GET BCM56504_A0_L3_DEFIP_ONLYm_MODE0f_GET
#define L3_DEFIP_ONLYm_MODE0f_SET BCM56504_A0_L3_DEFIP_ONLYm_MODE0f_SET
#define L3_DEFIP_ONLYm_MODE1f_GET BCM56504_A0_L3_DEFIP_ONLYm_MODE1f_GET
#define L3_DEFIP_ONLYm_MODE1f_SET BCM56504_A0_L3_DEFIP_ONLYm_MODE1f_SET
#define L3_DEFIP_ONLYm_IP_ADDR0f_GET BCM56504_A0_L3_DEFIP_ONLYm_IP_ADDR0f_GET
#define L3_DEFIP_ONLYm_IP_ADDR0f_SET BCM56504_A0_L3_DEFIP_ONLYm_IP_ADDR0f_SET
#define L3_DEFIP_ONLYm_IP_ADDR1f_GET BCM56504_A0_L3_DEFIP_ONLYm_IP_ADDR1f_GET
#define L3_DEFIP_ONLYm_IP_ADDR1f_SET BCM56504_A0_L3_DEFIP_ONLYm_IP_ADDR1f_SET
#define L3_DEFIP_ONLYm_MASK0f_GET BCM56504_A0_L3_DEFIP_ONLYm_MASK0f_GET
#define L3_DEFIP_ONLYm_MASK0f_SET BCM56504_A0_L3_DEFIP_ONLYm_MASK0f_SET
#define L3_DEFIP_ONLYm_MASK1f_GET BCM56504_A0_L3_DEFIP_ONLYm_MASK1f_GET
#define L3_DEFIP_ONLYm_MASK1f_SET BCM56504_A0_L3_DEFIP_ONLYm_MASK1f_SET
#define READ_L3_DEFIP_ONLYm BCM56504_A0_READ_L3_DEFIP_ONLYm
#define WRITE_L3_DEFIP_ONLYm BCM56504_A0_WRITE_L3_DEFIP_ONLYm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_L3_DEFIP_ONLYm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  L3_ECMP
 * BLOCKS:   IPIPE
 * DESC:     L3 Equal Cost Multipath table
 * SIZE:     13
 * FIELDS:
 *     NEXT_HOP_INDEX   Index of next hop for this ECMP route
 *
 ******************************************************************************/
#define BCM56504_A0_L3_ECMPm 0x0d700000

#define BCM56504_A0_L3_ECMPm_MIN 0
#define BCM56504_A0_L3_ECMPm_MAX 2047
#define BCM56504_A0_L3_ECMPm_CMAX(u) 2047
#define BCM56504_A0_L3_ECMPm_SIZE 2

/*
 * This structure should be used to declare and program L3_ECMP.
 *
 */
typedef union BCM56504_A0_L3_ECMPm_s {
	uint32_t v[1];
	uint32_t l3_ecmp[1];
	uint32_t _l3_ecmp;
} BCM56504_A0_L3_ECMPm_t;

#define BCM56504_A0_L3_ECMPm_CLR(r) (r).l3_ecmp[0] = 0
#define BCM56504_A0_L3_ECMPm_SET(r,d) (r).l3_ecmp[0] = d
#define BCM56504_A0_L3_ECMPm_GET(r) (r).l3_ecmp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_L3_ECMPm_NEXT_HOP_INDEXf_GET(r) (((r).l3_ecmp[0]) & 0x1fff)
#define BCM56504_A0_L3_ECMPm_NEXT_HOP_INDEXf_SET(r,f) (r).l3_ecmp[0]=(((r).l3_ecmp[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))

/*
 * These macros can be used to access L3_ECMP.
 *
 */
#define BCM56504_A0_READ_L3_ECMPm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_L3_ECMPm,i,(m._l3_ecmp),1)
#define BCM56504_A0_WRITE_L3_ECMPm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_L3_ECMPm,i,&(m._l3_ecmp),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_ECMPm BCM56504_A0_L3_ECMPm
#define L3_ECMPm_MIN BCM56504_A0_L3_ECMPm_MIN
#define L3_ECMPm_MAX BCM56504_A0_L3_ECMPm_MAX
#define L3_ECMPm_CMAX(u) BCM56504_A0_L3_ECMPm_CMAX(u)
#define L3_ECMPm_SIZE BCM56504_A0_L3_ECMPm_SIZE
typedef BCM56504_A0_L3_ECMPm_t L3_ECMPm_t;
#define L3_ECMPm_CLR BCM56504_A0_L3_ECMPm_CLR
#define L3_ECMPm_SET BCM56504_A0_L3_ECMPm_SET
#define L3_ECMPm_GET BCM56504_A0_L3_ECMPm_GET
#define L3_ECMPm_NEXT_HOP_INDEXf_GET BCM56504_A0_L3_ECMPm_NEXT_HOP_INDEXf_GET
#define L3_ECMPm_NEXT_HOP_INDEXf_SET BCM56504_A0_L3_ECMPm_NEXT_HOP_INDEXf_SET
#define READ_L3_ECMPm BCM56504_A0_READ_L3_ECMPm
#define WRITE_L3_ECMPm BCM56504_A0_WRITE_L3_ECMPm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_L3_ECMPm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  L3_ENTRY_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     L3_ENTRY_CONTROL
 * SIZE:     32
 * FIELDS:
 *     RAM0_CT0         CT debug bit 0 for RAM0
 *     RAM0_CT1         CT debug bit 1 for RAM0
 *     RAM0_CT2         CT debug bit 2 for RAM0
 *     RAM1_CT0         CT debug bit 0 for RAM1
 *     RAM1_CT1         CT debug bit 1 for RAM1
 *     RAM1_CT2         CT debug bit 2 for RAM1
 *     RAM2_CT0         CT debug bit 0 for RAM2
 *     RAM2_CT1         CT debug bit 1 for RAM2
 *     RAM2_CT2         CT debug bit 2 for RAM2
 *     RAM3_CT0         CT debug bit 0 for RAM3
 *     RAM3_CT1         CT debug bit 1 for RAM3
 *     RAM3_CT2         CT debug bit 2 for RAM3
 *     RAM0_SAM         SAM debug bits for RAM0
 *     RAM1_SAM         SAM debug bits for RAM1
 *     RAM2_SAM         SAM debug bits for RAM2
 *     RAM3_SAM         SAM debug bits for RAM3
 *
 ******************************************************************************/
#define BCM56504_A0_L3_ENTRY_CONTROLr 0x0878000a

#define BCM56504_A0_L3_ENTRY_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program L3_ENTRY_CONTROL.
 *
 */
typedef union BCM56504_A0_L3_ENTRY_CONTROLr_s {
	uint32_t v[1];
	uint32_t l3_entry_control[1];
	uint32_t _l3_entry_control;
} BCM56504_A0_L3_ENTRY_CONTROLr_t;

#define BCM56504_A0_L3_ENTRY_CONTROLr_CLR(r) (r).l3_entry_control[0] = 0
#define BCM56504_A0_L3_ENTRY_CONTROLr_SET(r,d) (r).l3_entry_control[0] = d
#define BCM56504_A0_L3_ENTRY_CONTROLr_GET(r) (r).l3_entry_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_L3_ENTRY_CONTROLr_RAM0_CT0f_GET(r) (((r).l3_entry_control[0]) & 0x1)
#define BCM56504_A0_L3_ENTRY_CONTROLr_RAM0_CT0f_SET(r,f) (r).l3_entry_control[0]=(((r).l3_entry_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_L3_ENTRY_CONTROLr_RAM0_CT1f_GET(r) ((((r).l3_entry_control[0]) >> 1) & 0x1)
#define BCM56504_A0_L3_ENTRY_CONTROLr_RAM0_CT1f_SET(r,f) (r).l3_entry_control[0]=(((r).l3_entry_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_L3_ENTRY_CONTROLr_RAM0_CT2f_GET(r) ((((r).l3_entry_control[0]) >> 2) & 0x1)
#define BCM56504_A0_L3_ENTRY_CONTROLr_RAM0_CT2f_SET(r,f) (r).l3_entry_control[0]=(((r).l3_entry_control[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_L3_ENTRY_CONTROLr_RAM1_CT0f_GET(r) ((((r).l3_entry_control[0]) >> 3) & 0x1)
#define BCM56504_A0_L3_ENTRY_CONTROLr_RAM1_CT0f_SET(r,f) (r).l3_entry_control[0]=(((r).l3_entry_control[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_L3_ENTRY_CONTROLr_RAM1_CT1f_GET(r) ((((r).l3_entry_control[0]) >> 4) & 0x1)
#define BCM56504_A0_L3_ENTRY_CONTROLr_RAM1_CT1f_SET(r,f) (r).l3_entry_control[0]=(((r).l3_entry_control[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56504_A0_L3_ENTRY_CONTROLr_RAM1_CT2f_GET(r) ((((r).l3_entry_control[0]) >> 5) & 0x1)
#define BCM56504_A0_L3_ENTRY_CONTROLr_RAM1_CT2f_SET(r,f) (r).l3_entry_control[0]=(((r).l3_entry_control[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56504_A0_L3_ENTRY_CONTROLr_RAM2_CT0f_GET(r) ((((r).l3_entry_control[0]) >> 6) & 0x1)
#define BCM56504_A0_L3_ENTRY_CONTROLr_RAM2_CT0f_SET(r,f) (r).l3_entry_control[0]=(((r).l3_entry_control[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56504_A0_L3_ENTRY_CONTROLr_RAM2_CT1f_GET(r) ((((r).l3_entry_control[0]) >> 7) & 0x1)
#define BCM56504_A0_L3_ENTRY_CONTROLr_RAM2_CT1f_SET(r,f) (r).l3_entry_control[0]=(((r).l3_entry_control[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56504_A0_L3_ENTRY_CONTROLr_RAM2_CT2f_GET(r) ((((r).l3_entry_control[0]) >> 8) & 0x1)
#define BCM56504_A0_L3_ENTRY_CONTROLr_RAM2_CT2f_SET(r,f) (r).l3_entry_control[0]=(((r).l3_entry_control[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56504_A0_L3_ENTRY_CONTROLr_RAM3_CT0f_GET(r) ((((r).l3_entry_control[0]) >> 9) & 0x1)
#define BCM56504_A0_L3_ENTRY_CONTROLr_RAM3_CT0f_SET(r,f) (r).l3_entry_control[0]=(((r).l3_entry_control[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56504_A0_L3_ENTRY_CONTROLr_RAM3_CT1f_GET(r) ((((r).l3_entry_control[0]) >> 10) & 0x1)
#define BCM56504_A0_L3_ENTRY_CONTROLr_RAM3_CT1f_SET(r,f) (r).l3_entry_control[0]=(((r).l3_entry_control[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56504_A0_L3_ENTRY_CONTROLr_RAM3_CT2f_GET(r) ((((r).l3_entry_control[0]) >> 11) & 0x1)
#define BCM56504_A0_L3_ENTRY_CONTROLr_RAM3_CT2f_SET(r,f) (r).l3_entry_control[0]=(((r).l3_entry_control[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56504_A0_L3_ENTRY_CONTROLr_RAM0_SAMf_GET(r) ((((r).l3_entry_control[0]) >> 12) & 0x3)
#define BCM56504_A0_L3_ENTRY_CONTROLr_RAM0_SAMf_SET(r,f) (r).l3_entry_control[0]=(((r).l3_entry_control[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM56504_A0_L3_ENTRY_CONTROLr_RAM1_SAMf_GET(r) ((((r).l3_entry_control[0]) >> 14) & 0x3)
#define BCM56504_A0_L3_ENTRY_CONTROLr_RAM1_SAMf_SET(r,f) (r).l3_entry_control[0]=(((r).l3_entry_control[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCM56504_A0_L3_ENTRY_CONTROLr_RAM2_SAMf_GET(r) ((((r).l3_entry_control[0]) >> 16) & 0x3)
#define BCM56504_A0_L3_ENTRY_CONTROLr_RAM2_SAMf_SET(r,f) (r).l3_entry_control[0]=(((r).l3_entry_control[0] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM56504_A0_L3_ENTRY_CONTROLr_RAM3_SAMf_GET(r) ((((r).l3_entry_control[0]) >> 18) & 0x3)
#define BCM56504_A0_L3_ENTRY_CONTROLr_RAM3_SAMf_SET(r,f) (r).l3_entry_control[0]=(((r).l3_entry_control[0] & ~((uint32_t)0x3 << 18)) | ((((uint32_t)f) & 0x3) << 18))

/*
 * These macros can be used to access L3_ENTRY_CONTROL.
 *
 */
#define BCM56504_A0_READ_L3_ENTRY_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_L3_ENTRY_CONTROLr,(r._l3_entry_control))
#define BCM56504_A0_WRITE_L3_ENTRY_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_L3_ENTRY_CONTROLr,&(r._l3_entry_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_ENTRY_CONTROLr BCM56504_A0_L3_ENTRY_CONTROLr
#define L3_ENTRY_CONTROLr_SIZE BCM56504_A0_L3_ENTRY_CONTROLr_SIZE
typedef BCM56504_A0_L3_ENTRY_CONTROLr_t L3_ENTRY_CONTROLr_t;
#define L3_ENTRY_CONTROLr_CLR BCM56504_A0_L3_ENTRY_CONTROLr_CLR
#define L3_ENTRY_CONTROLr_SET BCM56504_A0_L3_ENTRY_CONTROLr_SET
#define L3_ENTRY_CONTROLr_GET BCM56504_A0_L3_ENTRY_CONTROLr_GET
#define L3_ENTRY_CONTROLr_RAM0_CT0f_GET BCM56504_A0_L3_ENTRY_CONTROLr_RAM0_CT0f_GET
#define L3_ENTRY_CONTROLr_RAM0_CT0f_SET BCM56504_A0_L3_ENTRY_CONTROLr_RAM0_CT0f_SET
#define L3_ENTRY_CONTROLr_RAM0_CT1f_GET BCM56504_A0_L3_ENTRY_CONTROLr_RAM0_CT1f_GET
#define L3_ENTRY_CONTROLr_RAM0_CT1f_SET BCM56504_A0_L3_ENTRY_CONTROLr_RAM0_CT1f_SET
#define L3_ENTRY_CONTROLr_RAM0_CT2f_GET BCM56504_A0_L3_ENTRY_CONTROLr_RAM0_CT2f_GET
#define L3_ENTRY_CONTROLr_RAM0_CT2f_SET BCM56504_A0_L3_ENTRY_CONTROLr_RAM0_CT2f_SET
#define L3_ENTRY_CONTROLr_RAM1_CT0f_GET BCM56504_A0_L3_ENTRY_CONTROLr_RAM1_CT0f_GET
#define L3_ENTRY_CONTROLr_RAM1_CT0f_SET BCM56504_A0_L3_ENTRY_CONTROLr_RAM1_CT0f_SET
#define L3_ENTRY_CONTROLr_RAM1_CT1f_GET BCM56504_A0_L3_ENTRY_CONTROLr_RAM1_CT1f_GET
#define L3_ENTRY_CONTROLr_RAM1_CT1f_SET BCM56504_A0_L3_ENTRY_CONTROLr_RAM1_CT1f_SET
#define L3_ENTRY_CONTROLr_RAM1_CT2f_GET BCM56504_A0_L3_ENTRY_CONTROLr_RAM1_CT2f_GET
#define L3_ENTRY_CONTROLr_RAM1_CT2f_SET BCM56504_A0_L3_ENTRY_CONTROLr_RAM1_CT2f_SET
#define L3_ENTRY_CONTROLr_RAM2_CT0f_GET BCM56504_A0_L3_ENTRY_CONTROLr_RAM2_CT0f_GET
#define L3_ENTRY_CONTROLr_RAM2_CT0f_SET BCM56504_A0_L3_ENTRY_CONTROLr_RAM2_CT0f_SET
#define L3_ENTRY_CONTROLr_RAM2_CT1f_GET BCM56504_A0_L3_ENTRY_CONTROLr_RAM2_CT1f_GET
#define L3_ENTRY_CONTROLr_RAM2_CT1f_SET BCM56504_A0_L3_ENTRY_CONTROLr_RAM2_CT1f_SET
#define L3_ENTRY_CONTROLr_RAM2_CT2f_GET BCM56504_A0_L3_ENTRY_CONTROLr_RAM2_CT2f_GET
#define L3_ENTRY_CONTROLr_RAM2_CT2f_SET BCM56504_A0_L3_ENTRY_CONTROLr_RAM2_CT2f_SET
#define L3_ENTRY_CONTROLr_RAM3_CT0f_GET BCM56504_A0_L3_ENTRY_CONTROLr_RAM3_CT0f_GET
#define L3_ENTRY_CONTROLr_RAM3_CT0f_SET BCM56504_A0_L3_ENTRY_CONTROLr_RAM3_CT0f_SET
#define L3_ENTRY_CONTROLr_RAM3_CT1f_GET BCM56504_A0_L3_ENTRY_CONTROLr_RAM3_CT1f_GET
#define L3_ENTRY_CONTROLr_RAM3_CT1f_SET BCM56504_A0_L3_ENTRY_CONTROLr_RAM3_CT1f_SET
#define L3_ENTRY_CONTROLr_RAM3_CT2f_GET BCM56504_A0_L3_ENTRY_CONTROLr_RAM3_CT2f_GET
#define L3_ENTRY_CONTROLr_RAM3_CT2f_SET BCM56504_A0_L3_ENTRY_CONTROLr_RAM3_CT2f_SET
#define L3_ENTRY_CONTROLr_RAM0_SAMf_GET BCM56504_A0_L3_ENTRY_CONTROLr_RAM0_SAMf_GET
#define L3_ENTRY_CONTROLr_RAM0_SAMf_SET BCM56504_A0_L3_ENTRY_CONTROLr_RAM0_SAMf_SET
#define L3_ENTRY_CONTROLr_RAM1_SAMf_GET BCM56504_A0_L3_ENTRY_CONTROLr_RAM1_SAMf_GET
#define L3_ENTRY_CONTROLr_RAM1_SAMf_SET BCM56504_A0_L3_ENTRY_CONTROLr_RAM1_SAMf_SET
#define L3_ENTRY_CONTROLr_RAM2_SAMf_GET BCM56504_A0_L3_ENTRY_CONTROLr_RAM2_SAMf_GET
#define L3_ENTRY_CONTROLr_RAM2_SAMf_SET BCM56504_A0_L3_ENTRY_CONTROLr_RAM2_SAMf_SET
#define L3_ENTRY_CONTROLr_RAM3_SAMf_GET BCM56504_A0_L3_ENTRY_CONTROLr_RAM3_SAMf_GET
#define L3_ENTRY_CONTROLr_RAM3_SAMf_SET BCM56504_A0_L3_ENTRY_CONTROLr_RAM3_SAMf_SET
#define READ_L3_ENTRY_CONTROLr BCM56504_A0_READ_L3_ENTRY_CONTROLr
#define WRITE_L3_ENTRY_CONTROLr BCM56504_A0_WRITE_L3_ENTRY_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_L3_ENTRY_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  L3_ENTRY_HIT_ONLY
 * BLOCKS:   IPIPE
 * DESC:     L3 Hit bit table
 * SIZE:     8
 * FIELDS:
 *     HIT_0            Indicates that the entry has been hit
 *     HIT_1            Indicates that the entry has been hit
 *     HIT_2            Indicates that the entry has been hit
 *     HIT_3            Indicates that the entry has been hit
 *     HIT_4            Indicates that the entry has been hit
 *     HIT_5            Indicates that the entry has been hit
 *     HIT_6            Indicates that the entry has been hit
 *     HIT_7            Indicates that the entry has been hit
 *
 ******************************************************************************/
#define BCM56504_A0_L3_ENTRY_HIT_ONLYm 0x0b710000

#define BCM56504_A0_L3_ENTRY_HIT_ONLYm_MIN 0
#define BCM56504_A0_L3_ENTRY_HIT_ONLYm_MAX 1023
#define BCM56504_A0_L3_ENTRY_HIT_ONLYm_CMAX(u) 1023
#define BCM56504_A0_L3_ENTRY_HIT_ONLYm_SIZE 1

/*
 * This structure should be used to declare and program L3_ENTRY_HIT_ONLY.
 *
 */
typedef union BCM56504_A0_L3_ENTRY_HIT_ONLYm_s {
	uint32_t v[1];
	uint32_t l3_entry_hit_only[1];
	uint32_t _l3_entry_hit_only;
} BCM56504_A0_L3_ENTRY_HIT_ONLYm_t;

#define BCM56504_A0_L3_ENTRY_HIT_ONLYm_CLR(r) (r).l3_entry_hit_only[0] = 0
#define BCM56504_A0_L3_ENTRY_HIT_ONLYm_SET(r,d) (r).l3_entry_hit_only[0] = d
#define BCM56504_A0_L3_ENTRY_HIT_ONLYm_GET(r) (r).l3_entry_hit_only[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_L3_ENTRY_HIT_ONLYm_HIT_0f_GET(r) (((r).l3_entry_hit_only[0]) & 0x1)
#define BCM56504_A0_L3_ENTRY_HIT_ONLYm_HIT_0f_SET(r,f) (r).l3_entry_hit_only[0]=(((r).l3_entry_hit_only[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_L3_ENTRY_HIT_ONLYm_HIT_1f_GET(r) ((((r).l3_entry_hit_only[0]) >> 1) & 0x1)
#define BCM56504_A0_L3_ENTRY_HIT_ONLYm_HIT_1f_SET(r,f) (r).l3_entry_hit_only[0]=(((r).l3_entry_hit_only[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_L3_ENTRY_HIT_ONLYm_HIT_2f_GET(r) ((((r).l3_entry_hit_only[0]) >> 2) & 0x1)
#define BCM56504_A0_L3_ENTRY_HIT_ONLYm_HIT_2f_SET(r,f) (r).l3_entry_hit_only[0]=(((r).l3_entry_hit_only[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_L3_ENTRY_HIT_ONLYm_HIT_3f_GET(r) ((((r).l3_entry_hit_only[0]) >> 3) & 0x1)
#define BCM56504_A0_L3_ENTRY_HIT_ONLYm_HIT_3f_SET(r,f) (r).l3_entry_hit_only[0]=(((r).l3_entry_hit_only[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_L3_ENTRY_HIT_ONLYm_HIT_4f_GET(r) ((((r).l3_entry_hit_only[0]) >> 4) & 0x1)
#define BCM56504_A0_L3_ENTRY_HIT_ONLYm_HIT_4f_SET(r,f) (r).l3_entry_hit_only[0]=(((r).l3_entry_hit_only[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56504_A0_L3_ENTRY_HIT_ONLYm_HIT_5f_GET(r) ((((r).l3_entry_hit_only[0]) >> 5) & 0x1)
#define BCM56504_A0_L3_ENTRY_HIT_ONLYm_HIT_5f_SET(r,f) (r).l3_entry_hit_only[0]=(((r).l3_entry_hit_only[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56504_A0_L3_ENTRY_HIT_ONLYm_HIT_6f_GET(r) ((((r).l3_entry_hit_only[0]) >> 6) & 0x1)
#define BCM56504_A0_L3_ENTRY_HIT_ONLYm_HIT_6f_SET(r,f) (r).l3_entry_hit_only[0]=(((r).l3_entry_hit_only[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56504_A0_L3_ENTRY_HIT_ONLYm_HIT_7f_GET(r) ((((r).l3_entry_hit_only[0]) >> 7) & 0x1)
#define BCM56504_A0_L3_ENTRY_HIT_ONLYm_HIT_7f_SET(r,f) (r).l3_entry_hit_only[0]=(((r).l3_entry_hit_only[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access L3_ENTRY_HIT_ONLY.
 *
 */
#define BCM56504_A0_READ_L3_ENTRY_HIT_ONLYm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_L3_ENTRY_HIT_ONLYm,i,(m._l3_entry_hit_only),1)
#define BCM56504_A0_WRITE_L3_ENTRY_HIT_ONLYm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_L3_ENTRY_HIT_ONLYm,i,&(m._l3_entry_hit_only),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_ENTRY_HIT_ONLYm BCM56504_A0_L3_ENTRY_HIT_ONLYm
#define L3_ENTRY_HIT_ONLYm_MIN BCM56504_A0_L3_ENTRY_HIT_ONLYm_MIN
#define L3_ENTRY_HIT_ONLYm_MAX BCM56504_A0_L3_ENTRY_HIT_ONLYm_MAX
#define L3_ENTRY_HIT_ONLYm_CMAX(u) BCM56504_A0_L3_ENTRY_HIT_ONLYm_CMAX(u)
#define L3_ENTRY_HIT_ONLYm_SIZE BCM56504_A0_L3_ENTRY_HIT_ONLYm_SIZE
typedef BCM56504_A0_L3_ENTRY_HIT_ONLYm_t L3_ENTRY_HIT_ONLYm_t;
#define L3_ENTRY_HIT_ONLYm_CLR BCM56504_A0_L3_ENTRY_HIT_ONLYm_CLR
#define L3_ENTRY_HIT_ONLYm_SET BCM56504_A0_L3_ENTRY_HIT_ONLYm_SET
#define L3_ENTRY_HIT_ONLYm_GET BCM56504_A0_L3_ENTRY_HIT_ONLYm_GET
#define L3_ENTRY_HIT_ONLYm_HIT_0f_GET BCM56504_A0_L3_ENTRY_HIT_ONLYm_HIT_0f_GET
#define L3_ENTRY_HIT_ONLYm_HIT_0f_SET BCM56504_A0_L3_ENTRY_HIT_ONLYm_HIT_0f_SET
#define L3_ENTRY_HIT_ONLYm_HIT_1f_GET BCM56504_A0_L3_ENTRY_HIT_ONLYm_HIT_1f_GET
#define L3_ENTRY_HIT_ONLYm_HIT_1f_SET BCM56504_A0_L3_ENTRY_HIT_ONLYm_HIT_1f_SET
#define L3_ENTRY_HIT_ONLYm_HIT_2f_GET BCM56504_A0_L3_ENTRY_HIT_ONLYm_HIT_2f_GET
#define L3_ENTRY_HIT_ONLYm_HIT_2f_SET BCM56504_A0_L3_ENTRY_HIT_ONLYm_HIT_2f_SET
#define L3_ENTRY_HIT_ONLYm_HIT_3f_GET BCM56504_A0_L3_ENTRY_HIT_ONLYm_HIT_3f_GET
#define L3_ENTRY_HIT_ONLYm_HIT_3f_SET BCM56504_A0_L3_ENTRY_HIT_ONLYm_HIT_3f_SET
#define L3_ENTRY_HIT_ONLYm_HIT_4f_GET BCM56504_A0_L3_ENTRY_HIT_ONLYm_HIT_4f_GET
#define L3_ENTRY_HIT_ONLYm_HIT_4f_SET BCM56504_A0_L3_ENTRY_HIT_ONLYm_HIT_4f_SET
#define L3_ENTRY_HIT_ONLYm_HIT_5f_GET BCM56504_A0_L3_ENTRY_HIT_ONLYm_HIT_5f_GET
#define L3_ENTRY_HIT_ONLYm_HIT_5f_SET BCM56504_A0_L3_ENTRY_HIT_ONLYm_HIT_5f_SET
#define L3_ENTRY_HIT_ONLYm_HIT_6f_GET BCM56504_A0_L3_ENTRY_HIT_ONLYm_HIT_6f_GET
#define L3_ENTRY_HIT_ONLYm_HIT_6f_SET BCM56504_A0_L3_ENTRY_HIT_ONLYm_HIT_6f_SET
#define L3_ENTRY_HIT_ONLYm_HIT_7f_GET BCM56504_A0_L3_ENTRY_HIT_ONLYm_HIT_7f_GET
#define L3_ENTRY_HIT_ONLYm_HIT_7f_SET BCM56504_A0_L3_ENTRY_HIT_ONLYm_HIT_7f_SET
#define READ_L3_ENTRY_HIT_ONLYm BCM56504_A0_READ_L3_ENTRY_HIT_ONLYm
#define WRITE_L3_ENTRY_HIT_ONLYm BCM56504_A0_WRITE_L3_ENTRY_HIT_ONLYm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_L3_ENTRY_HIT_ONLYm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  L3_ENTRY_IPV4_MULTICAST
 * BLOCKS:   IPIPE
 * DESC:     L3 routing table IPV4 MULTICAST view
 * SIZE:     97
 * FIELDS:
 *     GROUP_IP_ADDR    32 bit group IP address
 *     SOURCE_IP_ADDR   32 bit source IP address
 *     V6               Indicates entry is used for an IPv6 route.  Must be zero for this view
 *     IPMC             Indicates entry is used for an IPMC route.  Must be 1 for this view
 *     VLAN_ID          VLAN ID bits.
 *     L3MC_INDEX       Index into the L3MC table.
 *     NEXT_HOP_INDEX_UNUSED One bit of the NEXT_HOP_INDEX, unused for this view.
 *     IPMC_TUNNEL_TYPE Tunnel Type
 *     RPE              RPE bit
 *     PRI              Priority
 *     VALID            Indicates that the entry is valid
 *     HIT              Hit bit for the entry
 *
 ******************************************************************************/
#define BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm 0x08740000

#define BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_MIN 0
#define BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_MAX 8191
#define BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_CMAX(u) 8191
#define BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_SIZE 13

/*
 * This structure should be used to declare and program L3_ENTRY_IPV4_MULTICAST.
 *
 */
typedef union BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_s {
	uint32_t v[4];
	uint32_t l3_entry_ipv4_multicast[4];
	uint32_t _l3_entry_ipv4_multicast;
} BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_t;

#define BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_CLR(r) CDK_MEMSET(&((r)._l3_entry_ipv4_multicast), 0, sizeof(BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_t))
#define BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_SET(r,i,d) (r).l3_entry_ipv4_multicast[i] = d
#define BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_GET(r,i) (r).l3_entry_ipv4_multicast[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_GROUP_IP_ADDRf_GET(r) ((r).l3_entry_ipv4_multicast[0])
#define BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_GROUP_IP_ADDRf_SET(r,f) (r).l3_entry_ipv4_multicast[0]=((uint32_t)f)
#define BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_SOURCE_IP_ADDRf_GET(r) ((r).l3_entry_ipv4_multicast[1])
#define BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_SOURCE_IP_ADDRf_SET(r,f) (r).l3_entry_ipv4_multicast[1]=((uint32_t)f)
#define BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_V6f_GET(r) (((r).l3_entry_ipv4_multicast[2]) & 0x1)
#define BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_V6f_SET(r,f) (r).l3_entry_ipv4_multicast[2]=(((r).l3_entry_ipv4_multicast[2] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_IPMCf_GET(r) ((((r).l3_entry_ipv4_multicast[2]) >> 1) & 0x1)
#define BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_IPMCf_SET(r,f) (r).l3_entry_ipv4_multicast[2]=(((r).l3_entry_ipv4_multicast[2] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_VLAN_IDf_GET(r) ((((r).l3_entry_ipv4_multicast[2]) >> 2) & 0xfff)
#define BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_VLAN_IDf_SET(r,f) (r).l3_entry_ipv4_multicast[2]=(((r).l3_entry_ipv4_multicast[2] & ~((uint32_t)0xfff << 2)) | ((((uint32_t)f) & 0xfff) << 2))
#define BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_L3MC_INDEXf_GET(r) ((((r).l3_entry_ipv4_multicast[2]) >> 14) & 0x3ff)
#define BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_L3MC_INDEXf_SET(r,f) (r).l3_entry_ipv4_multicast[2]=(((r).l3_entry_ipv4_multicast[2] & ~((uint32_t)0x3ff << 14)) | ((((uint32_t)f) & 0x3ff) << 14))
#define BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_NEXT_HOP_INDEX_UNUSEDf_GET(r) ((((r).l3_entry_ipv4_multicast[2]) >> 24) & 0x1)
#define BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_NEXT_HOP_INDEX_UNUSEDf_SET(r,f) (r).l3_entry_ipv4_multicast[2]=(((r).l3_entry_ipv4_multicast[2] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_IPMC_TUNNEL_TYPEf_GET(r) ((((r).l3_entry_ipv4_multicast[2]) >> 25) & 0x3)
#define BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_IPMC_TUNNEL_TYPEf_SET(r,f) (r).l3_entry_ipv4_multicast[2]=(((r).l3_entry_ipv4_multicast[2] & ~((uint32_t)0x3 << 25)) | ((((uint32_t)f) & 0x3) << 25))
#define BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_RPEf_GET(r) ((((r).l3_entry_ipv4_multicast[2]) >> 27) & 0x1)
#define BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_RPEf_SET(r,f) (r).l3_entry_ipv4_multicast[2]=(((r).l3_entry_ipv4_multicast[2] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_PRIf_GET(r) ((((r).l3_entry_ipv4_multicast[2]) >> 28) & 0x7)
#define BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_PRIf_SET(r,f) (r).l3_entry_ipv4_multicast[2]=(((r).l3_entry_ipv4_multicast[2] & ~((uint32_t)0x7 << 28)) | ((((uint32_t)f) & 0x7) << 28))
#define BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_VALIDf_GET(r) ((((r).l3_entry_ipv4_multicast[2]) >> 31) & 0x1)
#define BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_VALIDf_SET(r,f) (r).l3_entry_ipv4_multicast[2]=(((r).l3_entry_ipv4_multicast[2] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_HITf_GET(r) (((r).l3_entry_ipv4_multicast[3]) & 0x1)
#define BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_HITf_SET(r,f) (r).l3_entry_ipv4_multicast[3]=(((r).l3_entry_ipv4_multicast[3] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access L3_ENTRY_IPV4_MULTICAST.
 *
 */
#define BCM56504_A0_READ_L3_ENTRY_IPV4_MULTICASTm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm,i,(m._l3_entry_ipv4_multicast),4)
#define BCM56504_A0_WRITE_L3_ENTRY_IPV4_MULTICASTm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm,i,&(m._l3_entry_ipv4_multicast),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_ENTRY_IPV4_MULTICASTm BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm
#define L3_ENTRY_IPV4_MULTICASTm_MIN BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_MIN
#define L3_ENTRY_IPV4_MULTICASTm_MAX BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_MAX
#define L3_ENTRY_IPV4_MULTICASTm_CMAX(u) BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_CMAX(u)
#define L3_ENTRY_IPV4_MULTICASTm_SIZE BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_SIZE
typedef BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_t L3_ENTRY_IPV4_MULTICASTm_t;
#define L3_ENTRY_IPV4_MULTICASTm_CLR BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_CLR
#define L3_ENTRY_IPV4_MULTICASTm_SET BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_SET
#define L3_ENTRY_IPV4_MULTICASTm_GET BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_GET
#define L3_ENTRY_IPV4_MULTICASTm_GROUP_IP_ADDRf_GET BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_GROUP_IP_ADDRf_GET
#define L3_ENTRY_IPV4_MULTICASTm_GROUP_IP_ADDRf_SET BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_GROUP_IP_ADDRf_SET
#define L3_ENTRY_IPV4_MULTICASTm_SOURCE_IP_ADDRf_GET BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_SOURCE_IP_ADDRf_GET
#define L3_ENTRY_IPV4_MULTICASTm_SOURCE_IP_ADDRf_SET BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_SOURCE_IP_ADDRf_SET
#define L3_ENTRY_IPV4_MULTICASTm_V6f_GET BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_V6f_GET
#define L3_ENTRY_IPV4_MULTICASTm_V6f_SET BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_V6f_SET
#define L3_ENTRY_IPV4_MULTICASTm_IPMCf_GET BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_IPMCf_GET
#define L3_ENTRY_IPV4_MULTICASTm_IPMCf_SET BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_IPMCf_SET
#define L3_ENTRY_IPV4_MULTICASTm_VLAN_IDf_GET BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_VLAN_IDf_GET
#define L3_ENTRY_IPV4_MULTICASTm_VLAN_IDf_SET BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_VLAN_IDf_SET
#define L3_ENTRY_IPV4_MULTICASTm_L3MC_INDEXf_GET BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_L3MC_INDEXf_GET
#define L3_ENTRY_IPV4_MULTICASTm_L3MC_INDEXf_SET BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_L3MC_INDEXf_SET
#define L3_ENTRY_IPV4_MULTICASTm_NEXT_HOP_INDEX_UNUSEDf_GET BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_NEXT_HOP_INDEX_UNUSEDf_GET
#define L3_ENTRY_IPV4_MULTICASTm_NEXT_HOP_INDEX_UNUSEDf_SET BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_NEXT_HOP_INDEX_UNUSEDf_SET
#define L3_ENTRY_IPV4_MULTICASTm_IPMC_TUNNEL_TYPEf_GET BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_IPMC_TUNNEL_TYPEf_GET
#define L3_ENTRY_IPV4_MULTICASTm_IPMC_TUNNEL_TYPEf_SET BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_IPMC_TUNNEL_TYPEf_SET
#define L3_ENTRY_IPV4_MULTICASTm_RPEf_GET BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_RPEf_GET
#define L3_ENTRY_IPV4_MULTICASTm_RPEf_SET BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_RPEf_SET
#define L3_ENTRY_IPV4_MULTICASTm_PRIf_GET BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_PRIf_GET
#define L3_ENTRY_IPV4_MULTICASTm_PRIf_SET BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_PRIf_SET
#define L3_ENTRY_IPV4_MULTICASTm_VALIDf_GET BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_VALIDf_GET
#define L3_ENTRY_IPV4_MULTICASTm_VALIDf_SET BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_VALIDf_SET
#define L3_ENTRY_IPV4_MULTICASTm_HITf_GET BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_HITf_GET
#define L3_ENTRY_IPV4_MULTICASTm_HITf_SET BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm_HITf_SET
#define READ_L3_ENTRY_IPV4_MULTICASTm BCM56504_A0_READ_L3_ENTRY_IPV4_MULTICASTm
#define WRITE_L3_ENTRY_IPV4_MULTICASTm BCM56504_A0_WRITE_L3_ENTRY_IPV4_MULTICASTm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_L3_ENTRY_IPV4_MULTICASTm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  L3_ENTRY_IPV4_UNICAST
 * BLOCKS:   IPIPE
 * DESC:     L3 routing table IPV4 UNICAST view
 * SIZE:     97
 * FIELDS:
 *     IP_ADDR          32 bit IP address
 *     IP_ADDR_UNUSED   IP address bits not used for this view
 *     V6               Indicates entry is used for an IPv6 route.  Must be zero for this view
 *     IPMC             Indicates entry is used for an IPMC route.  Must be zero for this view
 *     VLAN_ID          VLAN ID bits.  Not used for this view.
 *     NEXT_HOP_INDEX   Index for the next hop (overlaid for IPMC packets becomes {IPMC_TUNNEL_TYPE[1:0],reserved,L3MC_INDEX[9:0]})
 *     RPE              RPE bit
 *     PRI              Priority
 *     VALID            Indicates that the entry is valid
 *     HIT              Hit bit for the entry
 *
 ******************************************************************************/
#define BCM56504_A0_L3_ENTRY_IPV4_UNICASTm 0x08730000

#define BCM56504_A0_L3_ENTRY_IPV4_UNICASTm_MIN 0
#define BCM56504_A0_L3_ENTRY_IPV4_UNICASTm_MAX 8191
#define BCM56504_A0_L3_ENTRY_IPV4_UNICASTm_CMAX(u) 8191
#define BCM56504_A0_L3_ENTRY_IPV4_UNICASTm_SIZE 13

/*
 * This structure should be used to declare and program L3_ENTRY_IPV4_UNICAST.
 *
 */
typedef union BCM56504_A0_L3_ENTRY_IPV4_UNICASTm_s {
	uint32_t v[4];
	uint32_t l3_entry_ipv4_unicast[4];
	uint32_t _l3_entry_ipv4_unicast;
} BCM56504_A0_L3_ENTRY_IPV4_UNICASTm_t;

#define BCM56504_A0_L3_ENTRY_IPV4_UNICASTm_CLR(r) CDK_MEMSET(&((r)._l3_entry_ipv4_unicast), 0, sizeof(BCM56504_A0_L3_ENTRY_IPV4_UNICASTm_t))
#define BCM56504_A0_L3_ENTRY_IPV4_UNICASTm_SET(r,i,d) (r).l3_entry_ipv4_unicast[i] = d
#define BCM56504_A0_L3_ENTRY_IPV4_UNICASTm_GET(r,i) (r).l3_entry_ipv4_unicast[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_L3_ENTRY_IPV4_UNICASTm_IP_ADDRf_GET(r) ((r).l3_entry_ipv4_unicast[0])
#define BCM56504_A0_L3_ENTRY_IPV4_UNICASTm_IP_ADDRf_SET(r,f) (r).l3_entry_ipv4_unicast[0]=((uint32_t)f)
#define BCM56504_A0_L3_ENTRY_IPV4_UNICASTm_IP_ADDR_UNUSEDf_GET(r) ((r).l3_entry_ipv4_unicast[1])
#define BCM56504_A0_L3_ENTRY_IPV4_UNICASTm_IP_ADDR_UNUSEDf_SET(r,f) (r).l3_entry_ipv4_unicast[1]=((uint32_t)f)
#define BCM56504_A0_L3_ENTRY_IPV4_UNICASTm_V6f_GET(r) (((r).l3_entry_ipv4_unicast[2]) & 0x1)
#define BCM56504_A0_L3_ENTRY_IPV4_UNICASTm_V6f_SET(r,f) (r).l3_entry_ipv4_unicast[2]=(((r).l3_entry_ipv4_unicast[2] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_L3_ENTRY_IPV4_UNICASTm_IPMCf_GET(r) ((((r).l3_entry_ipv4_unicast[2]) >> 1) & 0x1)
#define BCM56504_A0_L3_ENTRY_IPV4_UNICASTm_IPMCf_SET(r,f) (r).l3_entry_ipv4_unicast[2]=(((r).l3_entry_ipv4_unicast[2] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_L3_ENTRY_IPV4_UNICASTm_VLAN_IDf_GET(r) ((((r).l3_entry_ipv4_unicast[2]) >> 2) & 0xfff)
#define BCM56504_A0_L3_ENTRY_IPV4_UNICASTm_VLAN_IDf_SET(r,f) (r).l3_entry_ipv4_unicast[2]=(((r).l3_entry_ipv4_unicast[2] & ~((uint32_t)0xfff << 2)) | ((((uint32_t)f) & 0xfff) << 2))
#define BCM56504_A0_L3_ENTRY_IPV4_UNICASTm_NEXT_HOP_INDEXf_GET(r) ((((r).l3_entry_ipv4_unicast[2]) >> 14) & 0x1fff)
#define BCM56504_A0_L3_ENTRY_IPV4_UNICASTm_NEXT_HOP_INDEXf_SET(r,f) (r).l3_entry_ipv4_unicast[2]=(((r).l3_entry_ipv4_unicast[2] & ~((uint32_t)0x1fff << 14)) | ((((uint32_t)f) & 0x1fff) << 14))
#define BCM56504_A0_L3_ENTRY_IPV4_UNICASTm_RPEf_GET(r) ((((r).l3_entry_ipv4_unicast[2]) >> 27) & 0x1)
#define BCM56504_A0_L3_ENTRY_IPV4_UNICASTm_RPEf_SET(r,f) (r).l3_entry_ipv4_unicast[2]=(((r).l3_entry_ipv4_unicast[2] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM56504_A0_L3_ENTRY_IPV4_UNICASTm_PRIf_GET(r) ((((r).l3_entry_ipv4_unicast[2]) >> 28) & 0x7)
#define BCM56504_A0_L3_ENTRY_IPV4_UNICASTm_PRIf_SET(r,f) (r).l3_entry_ipv4_unicast[2]=(((r).l3_entry_ipv4_unicast[2] & ~((uint32_t)0x7 << 28)) | ((((uint32_t)f) & 0x7) << 28))
#define BCM56504_A0_L3_ENTRY_IPV4_UNICASTm_VALIDf_GET(r) ((((r).l3_entry_ipv4_unicast[2]) >> 31) & 0x1)
#define BCM56504_A0_L3_ENTRY_IPV4_UNICASTm_VALIDf_SET(r,f) (r).l3_entry_ipv4_unicast[2]=(((r).l3_entry_ipv4_unicast[2] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM56504_A0_L3_ENTRY_IPV4_UNICASTm_HITf_GET(r) (((r).l3_entry_ipv4_unicast[3]) & 0x1)
#define BCM56504_A0_L3_ENTRY_IPV4_UNICASTm_HITf_SET(r,f) (r).l3_entry_ipv4_unicast[3]=(((r).l3_entry_ipv4_unicast[3] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access L3_ENTRY_IPV4_UNICAST.
 *
 */
#define BCM56504_A0_READ_L3_ENTRY_IPV4_UNICASTm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_L3_ENTRY_IPV4_UNICASTm,i,(m._l3_entry_ipv4_unicast),4)
#define BCM56504_A0_WRITE_L3_ENTRY_IPV4_UNICASTm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_L3_ENTRY_IPV4_UNICASTm,i,&(m._l3_entry_ipv4_unicast),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_ENTRY_IPV4_UNICASTm BCM56504_A0_L3_ENTRY_IPV4_UNICASTm
#define L3_ENTRY_IPV4_UNICASTm_MIN BCM56504_A0_L3_ENTRY_IPV4_UNICASTm_MIN
#define L3_ENTRY_IPV4_UNICASTm_MAX BCM56504_A0_L3_ENTRY_IPV4_UNICASTm_MAX
#define L3_ENTRY_IPV4_UNICASTm_CMAX(u) BCM56504_A0_L3_ENTRY_IPV4_UNICASTm_CMAX(u)
#define L3_ENTRY_IPV4_UNICASTm_SIZE BCM56504_A0_L3_ENTRY_IPV4_UNICASTm_SIZE
typedef BCM56504_A0_L3_ENTRY_IPV4_UNICASTm_t L3_ENTRY_IPV4_UNICASTm_t;
#define L3_ENTRY_IPV4_UNICASTm_CLR BCM56504_A0_L3_ENTRY_IPV4_UNICASTm_CLR
#define L3_ENTRY_IPV4_UNICASTm_SET BCM56504_A0_L3_ENTRY_IPV4_UNICASTm_SET
#define L3_ENTRY_IPV4_UNICASTm_GET BCM56504_A0_L3_ENTRY_IPV4_UNICASTm_GET
#define L3_ENTRY_IPV4_UNICASTm_IP_ADDRf_GET BCM56504_A0_L3_ENTRY_IPV4_UNICASTm_IP_ADDRf_GET
#define L3_ENTRY_IPV4_UNICASTm_IP_ADDRf_SET BCM56504_A0_L3_ENTRY_IPV4_UNICASTm_IP_ADDRf_SET
#define L3_ENTRY_IPV4_UNICASTm_IP_ADDR_UNUSEDf_GET BCM56504_A0_L3_ENTRY_IPV4_UNICASTm_IP_ADDR_UNUSEDf_GET
#define L3_ENTRY_IPV4_UNICASTm_IP_ADDR_UNUSEDf_SET BCM56504_A0_L3_ENTRY_IPV4_UNICASTm_IP_ADDR_UNUSEDf_SET
#define L3_ENTRY_IPV4_UNICASTm_V6f_GET BCM56504_A0_L3_ENTRY_IPV4_UNICASTm_V6f_GET
#define L3_ENTRY_IPV4_UNICASTm_V6f_SET BCM56504_A0_L3_ENTRY_IPV4_UNICASTm_V6f_SET
#define L3_ENTRY_IPV4_UNICASTm_IPMCf_GET BCM56504_A0_L3_ENTRY_IPV4_UNICASTm_IPMCf_GET
#define L3_ENTRY_IPV4_UNICASTm_IPMCf_SET BCM56504_A0_L3_ENTRY_IPV4_UNICASTm_IPMCf_SET
#define L3_ENTRY_IPV4_UNICASTm_VLAN_IDf_GET BCM56504_A0_L3_ENTRY_IPV4_UNICASTm_VLAN_IDf_GET
#define L3_ENTRY_IPV4_UNICASTm_VLAN_IDf_SET BCM56504_A0_L3_ENTRY_IPV4_UNICASTm_VLAN_IDf_SET
#define L3_ENTRY_IPV4_UNICASTm_NEXT_HOP_INDEXf_GET BCM56504_A0_L3_ENTRY_IPV4_UNICASTm_NEXT_HOP_INDEXf_GET
#define L3_ENTRY_IPV4_UNICASTm_NEXT_HOP_INDEXf_SET BCM56504_A0_L3_ENTRY_IPV4_UNICASTm_NEXT_HOP_INDEXf_SET
#define L3_ENTRY_IPV4_UNICASTm_RPEf_GET BCM56504_A0_L3_ENTRY_IPV4_UNICASTm_RPEf_GET
#define L3_ENTRY_IPV4_UNICASTm_RPEf_SET BCM56504_A0_L3_ENTRY_IPV4_UNICASTm_RPEf_SET
#define L3_ENTRY_IPV4_UNICASTm_PRIf_GET BCM56504_A0_L3_ENTRY_IPV4_UNICASTm_PRIf_GET
#define L3_ENTRY_IPV4_UNICASTm_PRIf_SET BCM56504_A0_L3_ENTRY_IPV4_UNICASTm_PRIf_SET
#define L3_ENTRY_IPV4_UNICASTm_VALIDf_GET BCM56504_A0_L3_ENTRY_IPV4_UNICASTm_VALIDf_GET
#define L3_ENTRY_IPV4_UNICASTm_VALIDf_SET BCM56504_A0_L3_ENTRY_IPV4_UNICASTm_VALIDf_SET
#define L3_ENTRY_IPV4_UNICASTm_HITf_GET BCM56504_A0_L3_ENTRY_IPV4_UNICASTm_HITf_GET
#define L3_ENTRY_IPV4_UNICASTm_HITf_SET BCM56504_A0_L3_ENTRY_IPV4_UNICASTm_HITf_SET
#define READ_L3_ENTRY_IPV4_UNICASTm BCM56504_A0_READ_L3_ENTRY_IPV4_UNICASTm
#define WRITE_L3_ENTRY_IPV4_UNICASTm BCM56504_A0_WRITE_L3_ENTRY_IPV4_UNICASTm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_L3_ENTRY_IPV4_UNICASTm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  L3_ENTRY_IPV6_MULTICAST
 * BLOCKS:   IPIPE
 * DESC:     L3 routing table IPV6 MULTICAST view
 * SIZE:     388
 * FIELDS:
 *     GROUP_IP_ADDR_LWR_64 Lower 64 bits of the Group IP addrs.
 *     V6_0             Indicates entry is used for an IPv6 route.  Must be 1 for this view
 *     IPMC_0           Indicates entry is used for an IPMC route.  Must be 1 for this view
 *     VLAN_ID_0        VLAN ID bits.  Same as the other 3 VLAN_ID fields in this view.
 *     L3MC_INDEX_0     Index into the L3MC table.  Same as the other 3 L3MC_INDEX fields.
 *     NEXT_HOP_INDEX_UNUSED_0 One bit of the NEXT_HOP_INDEX, unused for this view.
 *     IPMC_TUNNEL_TYPE_0 Tunnel Type.  Same as the other IPMC_TUNNEL_TYPE fields.
 *     RPE_0            RPE bit.  Same as the other RPE fields.
 *     PRI_0            Priority.  Same as the other PRI fields.
 *     VALID_0          Indicates that the entry is valid.  Same as the other VALID fields.
 *     GROUP_IP_ADDR_UPR_56 Lower 64 bits of the Group IP addrs.
 *     GROUP_IP_ADDR_UNUSED IP address bits that are unused for this view.
 *     V6_1             Indicates entry is used for an IPv6 route.  Must be 1 for this view
 *     IPMC_1           Indicates entry is used for an IPMC route.  Must be 1 for this view
 *     VLAN_ID_1        VLAN ID bits.  Same as the other 3 VLAN_ID fields in this view.
 *     L3MC_INDEX_1     Index into the L3MC table.  Same as the other 3 L3MC_INDEX fields.
 *     NEXT_HOP_INDEX_UNUSED_1 One bit of the NEXT_HOP_INDEX, unused for this view.
 *     IPMC_TUNNEL_TYPE_1 Tunnel Type.  Same as the other IPMC_TUNNEL_TYPE fields.
 *     RPE_1            RPE bit.  Same as the other RPE fields.
 *     PRI_1            Priority.  Same as the other PRI fields.
 *     VALID_1          Indicates that the entry is valid.  Same as the other VALID fields.
 *     SOURCE_IP_ADDR_LWR_64 Lower 64 bits of the Source IP addrs.
 *     V6_2             Indicates entry is used for an IPv6 route.  Must be 1 for this view
 *     IPMC_2           Indicates entry is used for an IPMC route.  Must be 1 for this view
 *     VLAN_ID_2        VLAN ID bits.  Same as the other 3 VLAN_ID fields in this view.
 *     L3MC_INDEX_2     Index into the L3MC table.  Same as the other 3 L3MC_INDEX fields.
 *     NEXT_HOP_INDEX_UNUSED_2 One bit of the NEXT_HOP_INDEX, unused for this view.
 *     IPMC_TUNNEL_TYPE_2 Tunnel Type.  Same as the other IPMC_TUNNEL_TYPE fields.
 *     RPE_2            RPE bit.  Same as the other RPE fields.
 *     PRI_2            Priority.  Same as the other PRI fields.
 *     VALID_2          Indicates that the entry is valid.  Same as the other VALID fields.
 *     SOURCE_IP_ADDR_UPR_64 Upper 64 bits of the Source IP addrs.
 *     V6_3             Indicates entry is used for an IPv6 route.  Must be 1 for this view
 *     IPMC_3           Indicates entry is used for an IPMC route.  Must be 1 for this view
 *     VLAN_ID_3        VLAN ID bits.  Same as the other 3 VLAN_ID fields in this view.
 *     L3MC_INDEX_3     Index into the L3MC table.  Same as the other 3 L3MC_INDEX fields.
 *     NEXT_HOP_INDEX_UNUSED_3 One bit of the NEXT_HOP_INDEX, unused for this view.
 *     IPMC_TUNNEL_TYPE_3 Tunnel Type.  Same as the other IPMC_TUNNEL_TYPE fields.
 *     RPE_3            RPE bit.  Same as the other RPE fields.
 *     PRI_3            Priority.  Same as the other PRI fields.
 *     VALID_3          Indicates that the entry is valid.  Same as the other VALID fields.
 *     HIT_0            Indicates that the entry is valid.
 *     HIT_1            Indicates that the entry is valid.  Same value as HIT_0.
 *     HIT_2            Indicates that the entry is valid.  Same value as HIT_0.
 *     HIT_3            Indicates that the entry is valid.  Same value as HIT_0.
 *
 ******************************************************************************/
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm 0x08760000

#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_MIN 0
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_MAX 2047
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_CMAX(u) 2047
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_SIZE 49

/*
 * This structure should be used to declare and program L3_ENTRY_IPV6_MULTICAST.
 *
 */
typedef union BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_s {
	uint32_t v[13];
	uint32_t l3_entry_ipv6_multicast[13];
	uint32_t _l3_entry_ipv6_multicast;
} BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_t;

#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_CLR(r) CDK_MEMSET(&((r)._l3_entry_ipv6_multicast), 0, sizeof(BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_t))
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_SET(r,i,d) (r).l3_entry_ipv6_multicast[i] = d
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_GET(r,i) (r).l3_entry_ipv6_multicast[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_GROUP_IP_ADDR_LWR_64f_GET(r,a) cdk_field_get((r).l3_entry_ipv6_multicast,0,63,a)
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_GROUP_IP_ADDR_LWR_64f_SET(r,a) cdk_field_set((r).l3_entry_ipv6_multicast,0,63,a)
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_V6_0f_GET(r) (((r).l3_entry_ipv6_multicast[2]) & 0x1)
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_V6_0f_SET(r,f) (r).l3_entry_ipv6_multicast[2]=(((r).l3_entry_ipv6_multicast[2] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_IPMC_0f_GET(r) ((((r).l3_entry_ipv6_multicast[2]) >> 1) & 0x1)
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_IPMC_0f_SET(r,f) (r).l3_entry_ipv6_multicast[2]=(((r).l3_entry_ipv6_multicast[2] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_VLAN_ID_0f_GET(r) ((((r).l3_entry_ipv6_multicast[2]) >> 2) & 0xfff)
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_VLAN_ID_0f_SET(r,f) (r).l3_entry_ipv6_multicast[2]=(((r).l3_entry_ipv6_multicast[2] & ~((uint32_t)0xfff << 2)) | ((((uint32_t)f) & 0xfff) << 2))
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_L3MC_INDEX_0f_GET(r) ((((r).l3_entry_ipv6_multicast[2]) >> 14) & 0x3ff)
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_L3MC_INDEX_0f_SET(r,f) (r).l3_entry_ipv6_multicast[2]=(((r).l3_entry_ipv6_multicast[2] & ~((uint32_t)0x3ff << 14)) | ((((uint32_t)f) & 0x3ff) << 14))
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_NEXT_HOP_INDEX_UNUSED_0f_GET(r) ((((r).l3_entry_ipv6_multicast[2]) >> 24) & 0x1)
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_NEXT_HOP_INDEX_UNUSED_0f_SET(r,f) (r).l3_entry_ipv6_multicast[2]=(((r).l3_entry_ipv6_multicast[2] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_IPMC_TUNNEL_TYPE_0f_GET(r) ((((r).l3_entry_ipv6_multicast[2]) >> 25) & 0x3)
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_IPMC_TUNNEL_TYPE_0f_SET(r,f) (r).l3_entry_ipv6_multicast[2]=(((r).l3_entry_ipv6_multicast[2] & ~((uint32_t)0x3 << 25)) | ((((uint32_t)f) & 0x3) << 25))
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_RPE_0f_GET(r) ((((r).l3_entry_ipv6_multicast[2]) >> 27) & 0x1)
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_RPE_0f_SET(r,f) (r).l3_entry_ipv6_multicast[2]=(((r).l3_entry_ipv6_multicast[2] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_PRI_0f_GET(r) ((((r).l3_entry_ipv6_multicast[2]) >> 28) & 0x7)
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_PRI_0f_SET(r,f) (r).l3_entry_ipv6_multicast[2]=(((r).l3_entry_ipv6_multicast[2] & ~((uint32_t)0x7 << 28)) | ((((uint32_t)f) & 0x7) << 28))
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_VALID_0f_GET(r) ((((r).l3_entry_ipv6_multicast[2]) >> 31) & 0x1)
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_VALID_0f_SET(r,f) (r).l3_entry_ipv6_multicast[2]=(((r).l3_entry_ipv6_multicast[2] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_GROUP_IP_ADDR_UPR_56f_GET(r,a) cdk_field_get((r).l3_entry_ipv6_multicast,96,151,a)
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_GROUP_IP_ADDR_UPR_56f_SET(r,a) cdk_field_set((r).l3_entry_ipv6_multicast,96,151,a)
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_GROUP_IP_ADDR_UNUSEDf_GET(r) ((((r).l3_entry_ipv6_multicast[4]) >> 24) & 0xff)
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_GROUP_IP_ADDR_UNUSEDf_SET(r,f) (r).l3_entry_ipv6_multicast[4]=(((r).l3_entry_ipv6_multicast[4] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_V6_1f_GET(r) (((r).l3_entry_ipv6_multicast[5]) & 0x1)
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_V6_1f_SET(r,f) (r).l3_entry_ipv6_multicast[5]=(((r).l3_entry_ipv6_multicast[5] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_IPMC_1f_GET(r) ((((r).l3_entry_ipv6_multicast[5]) >> 1) & 0x1)
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_IPMC_1f_SET(r,f) (r).l3_entry_ipv6_multicast[5]=(((r).l3_entry_ipv6_multicast[5] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_VLAN_ID_1f_GET(r) ((((r).l3_entry_ipv6_multicast[5]) >> 2) & 0xfff)
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_VLAN_ID_1f_SET(r,f) (r).l3_entry_ipv6_multicast[5]=(((r).l3_entry_ipv6_multicast[5] & ~((uint32_t)0xfff << 2)) | ((((uint32_t)f) & 0xfff) << 2))
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_L3MC_INDEX_1f_GET(r) ((((r).l3_entry_ipv6_multicast[5]) >> 14) & 0x3ff)
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_L3MC_INDEX_1f_SET(r,f) (r).l3_entry_ipv6_multicast[5]=(((r).l3_entry_ipv6_multicast[5] & ~((uint32_t)0x3ff << 14)) | ((((uint32_t)f) & 0x3ff) << 14))
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_NEXT_HOP_INDEX_UNUSED_1f_GET(r) ((((r).l3_entry_ipv6_multicast[5]) >> 24) & 0x1)
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_NEXT_HOP_INDEX_UNUSED_1f_SET(r,f) (r).l3_entry_ipv6_multicast[5]=(((r).l3_entry_ipv6_multicast[5] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_IPMC_TUNNEL_TYPE_1f_GET(r) ((((r).l3_entry_ipv6_multicast[5]) >> 25) & 0x3)
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_IPMC_TUNNEL_TYPE_1f_SET(r,f) (r).l3_entry_ipv6_multicast[5]=(((r).l3_entry_ipv6_multicast[5] & ~((uint32_t)0x3 << 25)) | ((((uint32_t)f) & 0x3) << 25))
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_RPE_1f_GET(r) ((((r).l3_entry_ipv6_multicast[5]) >> 27) & 0x1)
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_RPE_1f_SET(r,f) (r).l3_entry_ipv6_multicast[5]=(((r).l3_entry_ipv6_multicast[5] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_PRI_1f_GET(r) ((((r).l3_entry_ipv6_multicast[5]) >> 28) & 0x7)
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_PRI_1f_SET(r,f) (r).l3_entry_ipv6_multicast[5]=(((r).l3_entry_ipv6_multicast[5] & ~((uint32_t)0x7 << 28)) | ((((uint32_t)f) & 0x7) << 28))
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_VALID_1f_GET(r) ((((r).l3_entry_ipv6_multicast[5]) >> 31) & 0x1)
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_VALID_1f_SET(r,f) (r).l3_entry_ipv6_multicast[5]=(((r).l3_entry_ipv6_multicast[5] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_SOURCE_IP_ADDR_LWR_64f_GET(r,a) cdk_field_get((r).l3_entry_ipv6_multicast,192,255,a)
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_SOURCE_IP_ADDR_LWR_64f_SET(r,a) cdk_field_set((r).l3_entry_ipv6_multicast,192,255,a)
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_V6_2f_GET(r) (((r).l3_entry_ipv6_multicast[8]) & 0x1)
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_V6_2f_SET(r,f) (r).l3_entry_ipv6_multicast[8]=(((r).l3_entry_ipv6_multicast[8] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_IPMC_2f_GET(r) ((((r).l3_entry_ipv6_multicast[8]) >> 1) & 0x1)
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_IPMC_2f_SET(r,f) (r).l3_entry_ipv6_multicast[8]=(((r).l3_entry_ipv6_multicast[8] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_VLAN_ID_2f_GET(r) ((((r).l3_entry_ipv6_multicast[8]) >> 2) & 0xfff)
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_VLAN_ID_2f_SET(r,f) (r).l3_entry_ipv6_multicast[8]=(((r).l3_entry_ipv6_multicast[8] & ~((uint32_t)0xfff << 2)) | ((((uint32_t)f) & 0xfff) << 2))
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_L3MC_INDEX_2f_GET(r) ((((r).l3_entry_ipv6_multicast[8]) >> 14) & 0x3ff)
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_L3MC_INDEX_2f_SET(r,f) (r).l3_entry_ipv6_multicast[8]=(((r).l3_entry_ipv6_multicast[8] & ~((uint32_t)0x3ff << 14)) | ((((uint32_t)f) & 0x3ff) << 14))
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_NEXT_HOP_INDEX_UNUSED_2f_GET(r) ((((r).l3_entry_ipv6_multicast[8]) >> 24) & 0x1)
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_NEXT_HOP_INDEX_UNUSED_2f_SET(r,f) (r).l3_entry_ipv6_multicast[8]=(((r).l3_entry_ipv6_multicast[8] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_IPMC_TUNNEL_TYPE_2f_GET(r) ((((r).l3_entry_ipv6_multicast[8]) >> 25) & 0x3)
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_IPMC_TUNNEL_TYPE_2f_SET(r,f) (r).l3_entry_ipv6_multicast[8]=(((r).l3_entry_ipv6_multicast[8] & ~((uint32_t)0x3 << 25)) | ((((uint32_t)f) & 0x3) << 25))
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_RPE_2f_GET(r) ((((r).l3_entry_ipv6_multicast[8]) >> 27) & 0x1)
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_RPE_2f_SET(r,f) (r).l3_entry_ipv6_multicast[8]=(((r).l3_entry_ipv6_multicast[8] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_PRI_2f_GET(r) ((((r).l3_entry_ipv6_multicast[8]) >> 28) & 0x7)
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_PRI_2f_SET(r,f) (r).l3_entry_ipv6_multicast[8]=(((r).l3_entry_ipv6_multicast[8] & ~((uint32_t)0x7 << 28)) | ((((uint32_t)f) & 0x7) << 28))
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_VALID_2f_GET(r) ((((r).l3_entry_ipv6_multicast[8]) >> 31) & 0x1)
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_VALID_2f_SET(r,f) (r).l3_entry_ipv6_multicast[8]=(((r).l3_entry_ipv6_multicast[8] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_SOURCE_IP_ADDR_UPR_64f_GET(r,a) cdk_field_get((r).l3_entry_ipv6_multicast,288,351,a)
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_SOURCE_IP_ADDR_UPR_64f_SET(r,a) cdk_field_set((r).l3_entry_ipv6_multicast,288,351,a)
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_V6_3f_GET(r) (((r).l3_entry_ipv6_multicast[11]) & 0x1)
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_V6_3f_SET(r,f) (r).l3_entry_ipv6_multicast[11]=(((r).l3_entry_ipv6_multicast[11] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_IPMC_3f_GET(r) ((((r).l3_entry_ipv6_multicast[11]) >> 1) & 0x1)
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_IPMC_3f_SET(r,f) (r).l3_entry_ipv6_multicast[11]=(((r).l3_entry_ipv6_multicast[11] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_VLAN_ID_3f_GET(r) ((((r).l3_entry_ipv6_multicast[11]) >> 2) & 0xfff)
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_VLAN_ID_3f_SET(r,f) (r).l3_entry_ipv6_multicast[11]=(((r).l3_entry_ipv6_multicast[11] & ~((uint32_t)0xfff << 2)) | ((((uint32_t)f) & 0xfff) << 2))
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_L3MC_INDEX_3f_GET(r) ((((r).l3_entry_ipv6_multicast[11]) >> 14) & 0x3ff)
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_L3MC_INDEX_3f_SET(r,f) (r).l3_entry_ipv6_multicast[11]=(((r).l3_entry_ipv6_multicast[11] & ~((uint32_t)0x3ff << 14)) | ((((uint32_t)f) & 0x3ff) << 14))
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_NEXT_HOP_INDEX_UNUSED_3f_GET(r) ((((r).l3_entry_ipv6_multicast[11]) >> 24) & 0x1)
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_NEXT_HOP_INDEX_UNUSED_3f_SET(r,f) (r).l3_entry_ipv6_multicast[11]=(((r).l3_entry_ipv6_multicast[11] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_IPMC_TUNNEL_TYPE_3f_GET(r) ((((r).l3_entry_ipv6_multicast[11]) >> 25) & 0x3)
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_IPMC_TUNNEL_TYPE_3f_SET(r,f) (r).l3_entry_ipv6_multicast[11]=(((r).l3_entry_ipv6_multicast[11] & ~((uint32_t)0x3 << 25)) | ((((uint32_t)f) & 0x3) << 25))
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_RPE_3f_GET(r) ((((r).l3_entry_ipv6_multicast[11]) >> 27) & 0x1)
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_RPE_3f_SET(r,f) (r).l3_entry_ipv6_multicast[11]=(((r).l3_entry_ipv6_multicast[11] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_PRI_3f_GET(r) ((((r).l3_entry_ipv6_multicast[11]) >> 28) & 0x7)
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_PRI_3f_SET(r,f) (r).l3_entry_ipv6_multicast[11]=(((r).l3_entry_ipv6_multicast[11] & ~((uint32_t)0x7 << 28)) | ((((uint32_t)f) & 0x7) << 28))
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_VALID_3f_GET(r) ((((r).l3_entry_ipv6_multicast[11]) >> 31) & 0x1)
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_VALID_3f_SET(r,f) (r).l3_entry_ipv6_multicast[11]=(((r).l3_entry_ipv6_multicast[11] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_HIT_0f_GET(r) (((r).l3_entry_ipv6_multicast[12]) & 0x1)
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_HIT_0f_SET(r,f) (r).l3_entry_ipv6_multicast[12]=(((r).l3_entry_ipv6_multicast[12] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_HIT_1f_GET(r) ((((r).l3_entry_ipv6_multicast[12]) >> 1) & 0x1)
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_HIT_1f_SET(r,f) (r).l3_entry_ipv6_multicast[12]=(((r).l3_entry_ipv6_multicast[12] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_HIT_2f_GET(r) ((((r).l3_entry_ipv6_multicast[12]) >> 2) & 0x1)
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_HIT_2f_SET(r,f) (r).l3_entry_ipv6_multicast[12]=(((r).l3_entry_ipv6_multicast[12] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_HIT_3f_GET(r) ((((r).l3_entry_ipv6_multicast[12]) >> 3) & 0x1)
#define BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_HIT_3f_SET(r,f) (r).l3_entry_ipv6_multicast[12]=(((r).l3_entry_ipv6_multicast[12] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))

/*
 * These macros can be used to access L3_ENTRY_IPV6_MULTICAST.
 *
 */
#define BCM56504_A0_READ_L3_ENTRY_IPV6_MULTICASTm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm,i,(m._l3_entry_ipv6_multicast),13)
#define BCM56504_A0_WRITE_L3_ENTRY_IPV6_MULTICASTm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm,i,&(m._l3_entry_ipv6_multicast),13)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_ENTRY_IPV6_MULTICASTm BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm
#define L3_ENTRY_IPV6_MULTICASTm_MIN BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_MIN
#define L3_ENTRY_IPV6_MULTICASTm_MAX BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_MAX
#define L3_ENTRY_IPV6_MULTICASTm_CMAX(u) BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_CMAX(u)
#define L3_ENTRY_IPV6_MULTICASTm_SIZE BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_SIZE
typedef BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_t L3_ENTRY_IPV6_MULTICASTm_t;
#define L3_ENTRY_IPV6_MULTICASTm_CLR BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_CLR
#define L3_ENTRY_IPV6_MULTICASTm_SET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_SET
#define L3_ENTRY_IPV6_MULTICASTm_GET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_GET
#define L3_ENTRY_IPV6_MULTICASTm_GROUP_IP_ADDR_LWR_64f_GET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_GROUP_IP_ADDR_LWR_64f_GET
#define L3_ENTRY_IPV6_MULTICASTm_GROUP_IP_ADDR_LWR_64f_SET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_GROUP_IP_ADDR_LWR_64f_SET
#define L3_ENTRY_IPV6_MULTICASTm_V6_0f_GET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_V6_0f_GET
#define L3_ENTRY_IPV6_MULTICASTm_V6_0f_SET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_V6_0f_SET
#define L3_ENTRY_IPV6_MULTICASTm_IPMC_0f_GET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_IPMC_0f_GET
#define L3_ENTRY_IPV6_MULTICASTm_IPMC_0f_SET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_IPMC_0f_SET
#define L3_ENTRY_IPV6_MULTICASTm_VLAN_ID_0f_GET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_VLAN_ID_0f_GET
#define L3_ENTRY_IPV6_MULTICASTm_VLAN_ID_0f_SET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_VLAN_ID_0f_SET
#define L3_ENTRY_IPV6_MULTICASTm_L3MC_INDEX_0f_GET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_L3MC_INDEX_0f_GET
#define L3_ENTRY_IPV6_MULTICASTm_L3MC_INDEX_0f_SET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_L3MC_INDEX_0f_SET
#define L3_ENTRY_IPV6_MULTICASTm_NEXT_HOP_INDEX_UNUSED_0f_GET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_NEXT_HOP_INDEX_UNUSED_0f_GET
#define L3_ENTRY_IPV6_MULTICASTm_NEXT_HOP_INDEX_UNUSED_0f_SET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_NEXT_HOP_INDEX_UNUSED_0f_SET
#define L3_ENTRY_IPV6_MULTICASTm_IPMC_TUNNEL_TYPE_0f_GET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_IPMC_TUNNEL_TYPE_0f_GET
#define L3_ENTRY_IPV6_MULTICASTm_IPMC_TUNNEL_TYPE_0f_SET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_IPMC_TUNNEL_TYPE_0f_SET
#define L3_ENTRY_IPV6_MULTICASTm_RPE_0f_GET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_RPE_0f_GET
#define L3_ENTRY_IPV6_MULTICASTm_RPE_0f_SET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_RPE_0f_SET
#define L3_ENTRY_IPV6_MULTICASTm_PRI_0f_GET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_PRI_0f_GET
#define L3_ENTRY_IPV6_MULTICASTm_PRI_0f_SET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_PRI_0f_SET
#define L3_ENTRY_IPV6_MULTICASTm_VALID_0f_GET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_VALID_0f_GET
#define L3_ENTRY_IPV6_MULTICASTm_VALID_0f_SET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_VALID_0f_SET
#define L3_ENTRY_IPV6_MULTICASTm_GROUP_IP_ADDR_UPR_56f_GET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_GROUP_IP_ADDR_UPR_56f_GET
#define L3_ENTRY_IPV6_MULTICASTm_GROUP_IP_ADDR_UPR_56f_SET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_GROUP_IP_ADDR_UPR_56f_SET
#define L3_ENTRY_IPV6_MULTICASTm_GROUP_IP_ADDR_UNUSEDf_GET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_GROUP_IP_ADDR_UNUSEDf_GET
#define L3_ENTRY_IPV6_MULTICASTm_GROUP_IP_ADDR_UNUSEDf_SET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_GROUP_IP_ADDR_UNUSEDf_SET
#define L3_ENTRY_IPV6_MULTICASTm_V6_1f_GET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_V6_1f_GET
#define L3_ENTRY_IPV6_MULTICASTm_V6_1f_SET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_V6_1f_SET
#define L3_ENTRY_IPV6_MULTICASTm_IPMC_1f_GET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_IPMC_1f_GET
#define L3_ENTRY_IPV6_MULTICASTm_IPMC_1f_SET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_IPMC_1f_SET
#define L3_ENTRY_IPV6_MULTICASTm_VLAN_ID_1f_GET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_VLAN_ID_1f_GET
#define L3_ENTRY_IPV6_MULTICASTm_VLAN_ID_1f_SET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_VLAN_ID_1f_SET
#define L3_ENTRY_IPV6_MULTICASTm_L3MC_INDEX_1f_GET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_L3MC_INDEX_1f_GET
#define L3_ENTRY_IPV6_MULTICASTm_L3MC_INDEX_1f_SET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_L3MC_INDEX_1f_SET
#define L3_ENTRY_IPV6_MULTICASTm_NEXT_HOP_INDEX_UNUSED_1f_GET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_NEXT_HOP_INDEX_UNUSED_1f_GET
#define L3_ENTRY_IPV6_MULTICASTm_NEXT_HOP_INDEX_UNUSED_1f_SET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_NEXT_HOP_INDEX_UNUSED_1f_SET
#define L3_ENTRY_IPV6_MULTICASTm_IPMC_TUNNEL_TYPE_1f_GET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_IPMC_TUNNEL_TYPE_1f_GET
#define L3_ENTRY_IPV6_MULTICASTm_IPMC_TUNNEL_TYPE_1f_SET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_IPMC_TUNNEL_TYPE_1f_SET
#define L3_ENTRY_IPV6_MULTICASTm_RPE_1f_GET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_RPE_1f_GET
#define L3_ENTRY_IPV6_MULTICASTm_RPE_1f_SET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_RPE_1f_SET
#define L3_ENTRY_IPV6_MULTICASTm_PRI_1f_GET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_PRI_1f_GET
#define L3_ENTRY_IPV6_MULTICASTm_PRI_1f_SET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_PRI_1f_SET
#define L3_ENTRY_IPV6_MULTICASTm_VALID_1f_GET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_VALID_1f_GET
#define L3_ENTRY_IPV6_MULTICASTm_VALID_1f_SET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_VALID_1f_SET
#define L3_ENTRY_IPV6_MULTICASTm_SOURCE_IP_ADDR_LWR_64f_GET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_SOURCE_IP_ADDR_LWR_64f_GET
#define L3_ENTRY_IPV6_MULTICASTm_SOURCE_IP_ADDR_LWR_64f_SET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_SOURCE_IP_ADDR_LWR_64f_SET
#define L3_ENTRY_IPV6_MULTICASTm_V6_2f_GET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_V6_2f_GET
#define L3_ENTRY_IPV6_MULTICASTm_V6_2f_SET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_V6_2f_SET
#define L3_ENTRY_IPV6_MULTICASTm_IPMC_2f_GET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_IPMC_2f_GET
#define L3_ENTRY_IPV6_MULTICASTm_IPMC_2f_SET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_IPMC_2f_SET
#define L3_ENTRY_IPV6_MULTICASTm_VLAN_ID_2f_GET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_VLAN_ID_2f_GET
#define L3_ENTRY_IPV6_MULTICASTm_VLAN_ID_2f_SET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_VLAN_ID_2f_SET
#define L3_ENTRY_IPV6_MULTICASTm_L3MC_INDEX_2f_GET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_L3MC_INDEX_2f_GET
#define L3_ENTRY_IPV6_MULTICASTm_L3MC_INDEX_2f_SET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_L3MC_INDEX_2f_SET
#define L3_ENTRY_IPV6_MULTICASTm_NEXT_HOP_INDEX_UNUSED_2f_GET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_NEXT_HOP_INDEX_UNUSED_2f_GET
#define L3_ENTRY_IPV6_MULTICASTm_NEXT_HOP_INDEX_UNUSED_2f_SET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_NEXT_HOP_INDEX_UNUSED_2f_SET
#define L3_ENTRY_IPV6_MULTICASTm_IPMC_TUNNEL_TYPE_2f_GET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_IPMC_TUNNEL_TYPE_2f_GET
#define L3_ENTRY_IPV6_MULTICASTm_IPMC_TUNNEL_TYPE_2f_SET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_IPMC_TUNNEL_TYPE_2f_SET
#define L3_ENTRY_IPV6_MULTICASTm_RPE_2f_GET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_RPE_2f_GET
#define L3_ENTRY_IPV6_MULTICASTm_RPE_2f_SET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_RPE_2f_SET
#define L3_ENTRY_IPV6_MULTICASTm_PRI_2f_GET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_PRI_2f_GET
#define L3_ENTRY_IPV6_MULTICASTm_PRI_2f_SET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_PRI_2f_SET
#define L3_ENTRY_IPV6_MULTICASTm_VALID_2f_GET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_VALID_2f_GET
#define L3_ENTRY_IPV6_MULTICASTm_VALID_2f_SET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_VALID_2f_SET
#define L3_ENTRY_IPV6_MULTICASTm_SOURCE_IP_ADDR_UPR_64f_GET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_SOURCE_IP_ADDR_UPR_64f_GET
#define L3_ENTRY_IPV6_MULTICASTm_SOURCE_IP_ADDR_UPR_64f_SET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_SOURCE_IP_ADDR_UPR_64f_SET
#define L3_ENTRY_IPV6_MULTICASTm_V6_3f_GET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_V6_3f_GET
#define L3_ENTRY_IPV6_MULTICASTm_V6_3f_SET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_V6_3f_SET
#define L3_ENTRY_IPV6_MULTICASTm_IPMC_3f_GET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_IPMC_3f_GET
#define L3_ENTRY_IPV6_MULTICASTm_IPMC_3f_SET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_IPMC_3f_SET
#define L3_ENTRY_IPV6_MULTICASTm_VLAN_ID_3f_GET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_VLAN_ID_3f_GET
#define L3_ENTRY_IPV6_MULTICASTm_VLAN_ID_3f_SET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_VLAN_ID_3f_SET
#define L3_ENTRY_IPV6_MULTICASTm_L3MC_INDEX_3f_GET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_L3MC_INDEX_3f_GET
#define L3_ENTRY_IPV6_MULTICASTm_L3MC_INDEX_3f_SET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_L3MC_INDEX_3f_SET
#define L3_ENTRY_IPV6_MULTICASTm_NEXT_HOP_INDEX_UNUSED_3f_GET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_NEXT_HOP_INDEX_UNUSED_3f_GET
#define L3_ENTRY_IPV6_MULTICASTm_NEXT_HOP_INDEX_UNUSED_3f_SET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_NEXT_HOP_INDEX_UNUSED_3f_SET
#define L3_ENTRY_IPV6_MULTICASTm_IPMC_TUNNEL_TYPE_3f_GET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_IPMC_TUNNEL_TYPE_3f_GET
#define L3_ENTRY_IPV6_MULTICASTm_IPMC_TUNNEL_TYPE_3f_SET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_IPMC_TUNNEL_TYPE_3f_SET
#define L3_ENTRY_IPV6_MULTICASTm_RPE_3f_GET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_RPE_3f_GET
#define L3_ENTRY_IPV6_MULTICASTm_RPE_3f_SET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_RPE_3f_SET
#define L3_ENTRY_IPV6_MULTICASTm_PRI_3f_GET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_PRI_3f_GET
#define L3_ENTRY_IPV6_MULTICASTm_PRI_3f_SET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_PRI_3f_SET
#define L3_ENTRY_IPV6_MULTICASTm_VALID_3f_GET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_VALID_3f_GET
#define L3_ENTRY_IPV6_MULTICASTm_VALID_3f_SET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_VALID_3f_SET
#define L3_ENTRY_IPV6_MULTICASTm_HIT_0f_GET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_HIT_0f_GET
#define L3_ENTRY_IPV6_MULTICASTm_HIT_0f_SET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_HIT_0f_SET
#define L3_ENTRY_IPV6_MULTICASTm_HIT_1f_GET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_HIT_1f_GET
#define L3_ENTRY_IPV6_MULTICASTm_HIT_1f_SET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_HIT_1f_SET
#define L3_ENTRY_IPV6_MULTICASTm_HIT_2f_GET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_HIT_2f_GET
#define L3_ENTRY_IPV6_MULTICASTm_HIT_2f_SET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_HIT_2f_SET
#define L3_ENTRY_IPV6_MULTICASTm_HIT_3f_GET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_HIT_3f_GET
#define L3_ENTRY_IPV6_MULTICASTm_HIT_3f_SET BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm_HIT_3f_SET
#define READ_L3_ENTRY_IPV6_MULTICASTm BCM56504_A0_READ_L3_ENTRY_IPV6_MULTICASTm
#define WRITE_L3_ENTRY_IPV6_MULTICASTm BCM56504_A0_WRITE_L3_ENTRY_IPV6_MULTICASTm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_L3_ENTRY_IPV6_MULTICASTm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  L3_ENTRY_IPV6_UNICAST
 * BLOCKS:   IPIPE
 * DESC:     L3 routing table IPV6 UNICAST view
 * SIZE:     194
 * FIELDS:
 *     IP_ADDR_LWR_64   Lower 64 bits of the IP address
 *     V6_0             Indicates entry is used for an IPv6 route.  Must be 1 for this view
 *     IPMC_0           Indicates entry is used for an IPMC route.  Must be zero for this view
 *     VLAN_ID_UNUSED_0 VLAN ID bits.  Not used for this view.
 *     NEXT_HOP_INDEX_0 Index for the next hop.  Same value as NEXT_HOP_INDEX_1.
 *     RPE_0            RPE bit.  Same value as RPE_1.
 *     PRI_0            Priority.  Same value as RPE_1.
 *     VALID_0          Indicates that the entry is valid.  Same value as VALID_1.
 *     IP_ADDR_UPR_64   Upper 64 bits of the IP address
 *     V6_1             Indicates entry is used for an IPv6 route.  Must be 1 for this view
 *     IPMC_1           Indicates entry is used for an IPMC route.  Must be zero for this view
 *     VLAN_ID_UNUSED_1 VLAN ID bits.  Not used for this view.
 *     NEXT_HOP_INDEX_1 Index for the next hop.  Same value as NEXT_HOP_INDEX_0.
 *     RPE_1            RPE bit.  Same value as RPE_0.
 *     PRI_1            Priority.  Same value as RPE_0.
 *     VALID_1          Indicates that the entry is valid.  Same value as VALID_0.
 *     HIT_0            Indicates that the entry is valid.  Same value as HIT_1.
 *     HIT_1            Indicates that the entry is valid.  Same value as HIT_0.
 *
 ******************************************************************************/
#define BCM56504_A0_L3_ENTRY_IPV6_UNICASTm 0x08750000

#define BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_MIN 0
#define BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_MAX 4095
#define BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_CMAX(u) 4095
#define BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_SIZE 25

/*
 * This structure should be used to declare and program L3_ENTRY_IPV6_UNICAST.
 *
 */
typedef union BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_s {
	uint32_t v[7];
	uint32_t l3_entry_ipv6_unicast[7];
	uint32_t _l3_entry_ipv6_unicast;
} BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_t;

#define BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_CLR(r) CDK_MEMSET(&((r)._l3_entry_ipv6_unicast), 0, sizeof(BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_t))
#define BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_SET(r,i,d) (r).l3_entry_ipv6_unicast[i] = d
#define BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_GET(r,i) (r).l3_entry_ipv6_unicast[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_IP_ADDR_LWR_64f_GET(r,a) cdk_field_get((r).l3_entry_ipv6_unicast,0,63,a)
#define BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_IP_ADDR_LWR_64f_SET(r,a) cdk_field_set((r).l3_entry_ipv6_unicast,0,63,a)
#define BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_V6_0f_GET(r) (((r).l3_entry_ipv6_unicast[2]) & 0x1)
#define BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_V6_0f_SET(r,f) (r).l3_entry_ipv6_unicast[2]=(((r).l3_entry_ipv6_unicast[2] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_IPMC_0f_GET(r) ((((r).l3_entry_ipv6_unicast[2]) >> 1) & 0x1)
#define BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_IPMC_0f_SET(r,f) (r).l3_entry_ipv6_unicast[2]=(((r).l3_entry_ipv6_unicast[2] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_VLAN_ID_UNUSED_0f_GET(r) ((((r).l3_entry_ipv6_unicast[2]) >> 2) & 0xfff)
#define BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_VLAN_ID_UNUSED_0f_SET(r,f) (r).l3_entry_ipv6_unicast[2]=(((r).l3_entry_ipv6_unicast[2] & ~((uint32_t)0xfff << 2)) | ((((uint32_t)f) & 0xfff) << 2))
#define BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_NEXT_HOP_INDEX_0f_GET(r) ((((r).l3_entry_ipv6_unicast[2]) >> 14) & 0x1fff)
#define BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_NEXT_HOP_INDEX_0f_SET(r,f) (r).l3_entry_ipv6_unicast[2]=(((r).l3_entry_ipv6_unicast[2] & ~((uint32_t)0x1fff << 14)) | ((((uint32_t)f) & 0x1fff) << 14))
#define BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_RPE_0f_GET(r) ((((r).l3_entry_ipv6_unicast[2]) >> 27) & 0x1)
#define BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_RPE_0f_SET(r,f) (r).l3_entry_ipv6_unicast[2]=(((r).l3_entry_ipv6_unicast[2] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_PRI_0f_GET(r) ((((r).l3_entry_ipv6_unicast[2]) >> 28) & 0x7)
#define BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_PRI_0f_SET(r,f) (r).l3_entry_ipv6_unicast[2]=(((r).l3_entry_ipv6_unicast[2] & ~((uint32_t)0x7 << 28)) | ((((uint32_t)f) & 0x7) << 28))
#define BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_VALID_0f_GET(r) ((((r).l3_entry_ipv6_unicast[2]) >> 31) & 0x1)
#define BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_VALID_0f_SET(r,f) (r).l3_entry_ipv6_unicast[2]=(((r).l3_entry_ipv6_unicast[2] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_IP_ADDR_UPR_64f_GET(r,a) cdk_field_get((r).l3_entry_ipv6_unicast,96,159,a)
#define BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_IP_ADDR_UPR_64f_SET(r,a) cdk_field_set((r).l3_entry_ipv6_unicast,96,159,a)
#define BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_V6_1f_GET(r) (((r).l3_entry_ipv6_unicast[5]) & 0x1)
#define BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_V6_1f_SET(r,f) (r).l3_entry_ipv6_unicast[5]=(((r).l3_entry_ipv6_unicast[5] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_IPMC_1f_GET(r) ((((r).l3_entry_ipv6_unicast[5]) >> 1) & 0x1)
#define BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_IPMC_1f_SET(r,f) (r).l3_entry_ipv6_unicast[5]=(((r).l3_entry_ipv6_unicast[5] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_VLAN_ID_UNUSED_1f_GET(r) ((((r).l3_entry_ipv6_unicast[5]) >> 2) & 0xfff)
#define BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_VLAN_ID_UNUSED_1f_SET(r,f) (r).l3_entry_ipv6_unicast[5]=(((r).l3_entry_ipv6_unicast[5] & ~((uint32_t)0xfff << 2)) | ((((uint32_t)f) & 0xfff) << 2))
#define BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_NEXT_HOP_INDEX_1f_GET(r) ((((r).l3_entry_ipv6_unicast[5]) >> 14) & 0x1fff)
#define BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_NEXT_HOP_INDEX_1f_SET(r,f) (r).l3_entry_ipv6_unicast[5]=(((r).l3_entry_ipv6_unicast[5] & ~((uint32_t)0x1fff << 14)) | ((((uint32_t)f) & 0x1fff) << 14))
#define BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_RPE_1f_GET(r) ((((r).l3_entry_ipv6_unicast[5]) >> 27) & 0x1)
#define BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_RPE_1f_SET(r,f) (r).l3_entry_ipv6_unicast[5]=(((r).l3_entry_ipv6_unicast[5] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_PRI_1f_GET(r) ((((r).l3_entry_ipv6_unicast[5]) >> 28) & 0x7)
#define BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_PRI_1f_SET(r,f) (r).l3_entry_ipv6_unicast[5]=(((r).l3_entry_ipv6_unicast[5] & ~((uint32_t)0x7 << 28)) | ((((uint32_t)f) & 0x7) << 28))
#define BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_VALID_1f_GET(r) ((((r).l3_entry_ipv6_unicast[5]) >> 31) & 0x1)
#define BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_VALID_1f_SET(r,f) (r).l3_entry_ipv6_unicast[5]=(((r).l3_entry_ipv6_unicast[5] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_HIT_0f_GET(r) (((r).l3_entry_ipv6_unicast[6]) & 0x1)
#define BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_HIT_0f_SET(r,f) (r).l3_entry_ipv6_unicast[6]=(((r).l3_entry_ipv6_unicast[6] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_HIT_1f_GET(r) ((((r).l3_entry_ipv6_unicast[6]) >> 1) & 0x1)
#define BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_HIT_1f_SET(r,f) (r).l3_entry_ipv6_unicast[6]=(((r).l3_entry_ipv6_unicast[6] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access L3_ENTRY_IPV6_UNICAST.
 *
 */
#define BCM56504_A0_READ_L3_ENTRY_IPV6_UNICASTm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_L3_ENTRY_IPV6_UNICASTm,i,(m._l3_entry_ipv6_unicast),7)
#define BCM56504_A0_WRITE_L3_ENTRY_IPV6_UNICASTm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_L3_ENTRY_IPV6_UNICASTm,i,&(m._l3_entry_ipv6_unicast),7)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_ENTRY_IPV6_UNICASTm BCM56504_A0_L3_ENTRY_IPV6_UNICASTm
#define L3_ENTRY_IPV6_UNICASTm_MIN BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_MIN
#define L3_ENTRY_IPV6_UNICASTm_MAX BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_MAX
#define L3_ENTRY_IPV6_UNICASTm_CMAX(u) BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_CMAX(u)
#define L3_ENTRY_IPV6_UNICASTm_SIZE BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_SIZE
typedef BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_t L3_ENTRY_IPV6_UNICASTm_t;
#define L3_ENTRY_IPV6_UNICASTm_CLR BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_CLR
#define L3_ENTRY_IPV6_UNICASTm_SET BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_SET
#define L3_ENTRY_IPV6_UNICASTm_GET BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_GET
#define L3_ENTRY_IPV6_UNICASTm_IP_ADDR_LWR_64f_GET BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_IP_ADDR_LWR_64f_GET
#define L3_ENTRY_IPV6_UNICASTm_IP_ADDR_LWR_64f_SET BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_IP_ADDR_LWR_64f_SET
#define L3_ENTRY_IPV6_UNICASTm_V6_0f_GET BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_V6_0f_GET
#define L3_ENTRY_IPV6_UNICASTm_V6_0f_SET BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_V6_0f_SET
#define L3_ENTRY_IPV6_UNICASTm_IPMC_0f_GET BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_IPMC_0f_GET
#define L3_ENTRY_IPV6_UNICASTm_IPMC_0f_SET BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_IPMC_0f_SET
#define L3_ENTRY_IPV6_UNICASTm_VLAN_ID_UNUSED_0f_GET BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_VLAN_ID_UNUSED_0f_GET
#define L3_ENTRY_IPV6_UNICASTm_VLAN_ID_UNUSED_0f_SET BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_VLAN_ID_UNUSED_0f_SET
#define L3_ENTRY_IPV6_UNICASTm_NEXT_HOP_INDEX_0f_GET BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_NEXT_HOP_INDEX_0f_GET
#define L3_ENTRY_IPV6_UNICASTm_NEXT_HOP_INDEX_0f_SET BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_NEXT_HOP_INDEX_0f_SET
#define L3_ENTRY_IPV6_UNICASTm_RPE_0f_GET BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_RPE_0f_GET
#define L3_ENTRY_IPV6_UNICASTm_RPE_0f_SET BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_RPE_0f_SET
#define L3_ENTRY_IPV6_UNICASTm_PRI_0f_GET BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_PRI_0f_GET
#define L3_ENTRY_IPV6_UNICASTm_PRI_0f_SET BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_PRI_0f_SET
#define L3_ENTRY_IPV6_UNICASTm_VALID_0f_GET BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_VALID_0f_GET
#define L3_ENTRY_IPV6_UNICASTm_VALID_0f_SET BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_VALID_0f_SET
#define L3_ENTRY_IPV6_UNICASTm_IP_ADDR_UPR_64f_GET BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_IP_ADDR_UPR_64f_GET
#define L3_ENTRY_IPV6_UNICASTm_IP_ADDR_UPR_64f_SET BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_IP_ADDR_UPR_64f_SET
#define L3_ENTRY_IPV6_UNICASTm_V6_1f_GET BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_V6_1f_GET
#define L3_ENTRY_IPV6_UNICASTm_V6_1f_SET BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_V6_1f_SET
#define L3_ENTRY_IPV6_UNICASTm_IPMC_1f_GET BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_IPMC_1f_GET
#define L3_ENTRY_IPV6_UNICASTm_IPMC_1f_SET BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_IPMC_1f_SET
#define L3_ENTRY_IPV6_UNICASTm_VLAN_ID_UNUSED_1f_GET BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_VLAN_ID_UNUSED_1f_GET
#define L3_ENTRY_IPV6_UNICASTm_VLAN_ID_UNUSED_1f_SET BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_VLAN_ID_UNUSED_1f_SET
#define L3_ENTRY_IPV6_UNICASTm_NEXT_HOP_INDEX_1f_GET BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_NEXT_HOP_INDEX_1f_GET
#define L3_ENTRY_IPV6_UNICASTm_NEXT_HOP_INDEX_1f_SET BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_NEXT_HOP_INDEX_1f_SET
#define L3_ENTRY_IPV6_UNICASTm_RPE_1f_GET BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_RPE_1f_GET
#define L3_ENTRY_IPV6_UNICASTm_RPE_1f_SET BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_RPE_1f_SET
#define L3_ENTRY_IPV6_UNICASTm_PRI_1f_GET BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_PRI_1f_GET
#define L3_ENTRY_IPV6_UNICASTm_PRI_1f_SET BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_PRI_1f_SET
#define L3_ENTRY_IPV6_UNICASTm_VALID_1f_GET BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_VALID_1f_GET
#define L3_ENTRY_IPV6_UNICASTm_VALID_1f_SET BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_VALID_1f_SET
#define L3_ENTRY_IPV6_UNICASTm_HIT_0f_GET BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_HIT_0f_GET
#define L3_ENTRY_IPV6_UNICASTm_HIT_0f_SET BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_HIT_0f_SET
#define L3_ENTRY_IPV6_UNICASTm_HIT_1f_GET BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_HIT_1f_GET
#define L3_ENTRY_IPV6_UNICASTm_HIT_1f_SET BCM56504_A0_L3_ENTRY_IPV6_UNICASTm_HIT_1f_SET
#define READ_L3_ENTRY_IPV6_UNICASTm BCM56504_A0_READ_L3_ENTRY_IPV6_UNICASTm
#define WRITE_L3_ENTRY_IPV6_UNICASTm BCM56504_A0_WRITE_L3_ENTRY_IPV6_UNICASTm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_L3_ENTRY_IPV6_UNICASTm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  L3_ENTRY_ONLY
 * BLOCKS:   IPIPE
 * DESC:     L3 routing table with fb_regs arch view.  No hit bits
 * SIZE:     96
 * FIELDS:
 *     IP_ADDR          64 bits of IP address
 *     V6               Indicates entry is used for an IPv6 route.  Must be zero for this view
 *     IPMC             Indicates entry is used for an IPMC route.  Must be zero for this view
 *     VLAN_ID          VLAN ID bits.  Not used for this view.
 *     L3MC_INDEX       Overlay for L3 MC index
 *     IPMC_TUNNEL_TYPE Overlay for IPMC tunnel type
 *     RPE              RPE bit
 *     PRI              Priority
 *     VALID            Indicates that the entry is valid
 *     NEXT_HOP_INDEX   Index for the next hop (overlaid for IPMC packets becomes {IPMC_TUNNEL_TYPE[1:0],reserved,L3MC_INDEX[9:0]})
 *
 ******************************************************************************/
#define BCM56504_A0_L3_ENTRY_ONLYm 0x08720000

#define BCM56504_A0_L3_ENTRY_ONLYm_MIN 0
#define BCM56504_A0_L3_ENTRY_ONLYm_MAX 8191
#define BCM56504_A0_L3_ENTRY_ONLYm_CMAX(u) 8191
#define BCM56504_A0_L3_ENTRY_ONLYm_SIZE 12

/*
 * This structure should be used to declare and program L3_ENTRY_ONLY.
 *
 */
typedef union BCM56504_A0_L3_ENTRY_ONLYm_s {
	uint32_t v[3];
	uint32_t l3_entry_only[3];
	uint32_t _l3_entry_only;
} BCM56504_A0_L3_ENTRY_ONLYm_t;

#define BCM56504_A0_L3_ENTRY_ONLYm_CLR(r) CDK_MEMSET(&((r)._l3_entry_only), 0, sizeof(BCM56504_A0_L3_ENTRY_ONLYm_t))
#define BCM56504_A0_L3_ENTRY_ONLYm_SET(r,i,d) (r).l3_entry_only[i] = d
#define BCM56504_A0_L3_ENTRY_ONLYm_GET(r,i) (r).l3_entry_only[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_L3_ENTRY_ONLYm_IP_ADDRf_GET(r,a) cdk_field_get((r).l3_entry_only,0,63,a)
#define BCM56504_A0_L3_ENTRY_ONLYm_IP_ADDRf_SET(r,a) cdk_field_set((r).l3_entry_only,0,63,a)
#define BCM56504_A0_L3_ENTRY_ONLYm_V6f_GET(r) (((r).l3_entry_only[2]) & 0x1)
#define BCM56504_A0_L3_ENTRY_ONLYm_V6f_SET(r,f) (r).l3_entry_only[2]=(((r).l3_entry_only[2] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_L3_ENTRY_ONLYm_IPMCf_GET(r) ((((r).l3_entry_only[2]) >> 1) & 0x1)
#define BCM56504_A0_L3_ENTRY_ONLYm_IPMCf_SET(r,f) (r).l3_entry_only[2]=(((r).l3_entry_only[2] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_L3_ENTRY_ONLYm_VLAN_IDf_GET(r) ((((r).l3_entry_only[2]) >> 2) & 0xfff)
#define BCM56504_A0_L3_ENTRY_ONLYm_VLAN_IDf_SET(r,f) (r).l3_entry_only[2]=(((r).l3_entry_only[2] & ~((uint32_t)0xfff << 2)) | ((((uint32_t)f) & 0xfff) << 2))
#define BCM56504_A0_L3_ENTRY_ONLYm_L3MC_INDEXf_GET(r) ((((r).l3_entry_only[2]) >> 14) & 0x3ff)
#define BCM56504_A0_L3_ENTRY_ONLYm_L3MC_INDEXf_SET(r,f) (r).l3_entry_only[2]=(((r).l3_entry_only[2] & ~((uint32_t)0x3ff << 14)) | ((((uint32_t)f) & 0x3ff) << 14))
#define BCM56504_A0_L3_ENTRY_ONLYm_IPMC_TUNNEL_TYPEf_GET(r) ((((r).l3_entry_only[2]) >> 25) & 0x3)
#define BCM56504_A0_L3_ENTRY_ONLYm_IPMC_TUNNEL_TYPEf_SET(r,f) (r).l3_entry_only[2]=(((r).l3_entry_only[2] & ~((uint32_t)0x3 << 25)) | ((((uint32_t)f) & 0x3) << 25))
#define BCM56504_A0_L3_ENTRY_ONLYm_RPEf_GET(r) ((((r).l3_entry_only[2]) >> 27) & 0x1)
#define BCM56504_A0_L3_ENTRY_ONLYm_RPEf_SET(r,f) (r).l3_entry_only[2]=(((r).l3_entry_only[2] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM56504_A0_L3_ENTRY_ONLYm_PRIf_GET(r) ((((r).l3_entry_only[2]) >> 28) & 0x7)
#define BCM56504_A0_L3_ENTRY_ONLYm_PRIf_SET(r,f) (r).l3_entry_only[2]=(((r).l3_entry_only[2] & ~((uint32_t)0x7 << 28)) | ((((uint32_t)f) & 0x7) << 28))
#define BCM56504_A0_L3_ENTRY_ONLYm_VALIDf_GET(r) ((((r).l3_entry_only[2]) >> 31) & 0x1)
#define BCM56504_A0_L3_ENTRY_ONLYm_VALIDf_SET(r,f) (r).l3_entry_only[2]=(((r).l3_entry_only[2] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM56504_A0_L3_ENTRY_ONLYm_NEXT_HOP_INDEXf_GET(r) ((((r).l3_entry_only[2]) >> 14) & 0x1fff)
#define BCM56504_A0_L3_ENTRY_ONLYm_NEXT_HOP_INDEXf_SET(r,f) (r).l3_entry_only[2]=(((r).l3_entry_only[2] & ~((uint32_t)0x1fff << 14)) | ((((uint32_t)f) & 0x1fff) << 14))

/*
 * These macros can be used to access L3_ENTRY_ONLY.
 *
 */
#define BCM56504_A0_READ_L3_ENTRY_ONLYm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_L3_ENTRY_ONLYm,i,(m._l3_entry_only),3)
#define BCM56504_A0_WRITE_L3_ENTRY_ONLYm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_L3_ENTRY_ONLYm,i,&(m._l3_entry_only),3)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_ENTRY_ONLYm BCM56504_A0_L3_ENTRY_ONLYm
#define L3_ENTRY_ONLYm_MIN BCM56504_A0_L3_ENTRY_ONLYm_MIN
#define L3_ENTRY_ONLYm_MAX BCM56504_A0_L3_ENTRY_ONLYm_MAX
#define L3_ENTRY_ONLYm_CMAX(u) BCM56504_A0_L3_ENTRY_ONLYm_CMAX(u)
#define L3_ENTRY_ONLYm_SIZE BCM56504_A0_L3_ENTRY_ONLYm_SIZE
typedef BCM56504_A0_L3_ENTRY_ONLYm_t L3_ENTRY_ONLYm_t;
#define L3_ENTRY_ONLYm_CLR BCM56504_A0_L3_ENTRY_ONLYm_CLR
#define L3_ENTRY_ONLYm_SET BCM56504_A0_L3_ENTRY_ONLYm_SET
#define L3_ENTRY_ONLYm_GET BCM56504_A0_L3_ENTRY_ONLYm_GET
#define L3_ENTRY_ONLYm_IP_ADDRf_GET BCM56504_A0_L3_ENTRY_ONLYm_IP_ADDRf_GET
#define L3_ENTRY_ONLYm_IP_ADDRf_SET BCM56504_A0_L3_ENTRY_ONLYm_IP_ADDRf_SET
#define L3_ENTRY_ONLYm_V6f_GET BCM56504_A0_L3_ENTRY_ONLYm_V6f_GET
#define L3_ENTRY_ONLYm_V6f_SET BCM56504_A0_L3_ENTRY_ONLYm_V6f_SET
#define L3_ENTRY_ONLYm_IPMCf_GET BCM56504_A0_L3_ENTRY_ONLYm_IPMCf_GET
#define L3_ENTRY_ONLYm_IPMCf_SET BCM56504_A0_L3_ENTRY_ONLYm_IPMCf_SET
#define L3_ENTRY_ONLYm_VLAN_IDf_GET BCM56504_A0_L3_ENTRY_ONLYm_VLAN_IDf_GET
#define L3_ENTRY_ONLYm_VLAN_IDf_SET BCM56504_A0_L3_ENTRY_ONLYm_VLAN_IDf_SET
#define L3_ENTRY_ONLYm_L3MC_INDEXf_GET BCM56504_A0_L3_ENTRY_ONLYm_L3MC_INDEXf_GET
#define L3_ENTRY_ONLYm_L3MC_INDEXf_SET BCM56504_A0_L3_ENTRY_ONLYm_L3MC_INDEXf_SET
#define L3_ENTRY_ONLYm_IPMC_TUNNEL_TYPEf_GET BCM56504_A0_L3_ENTRY_ONLYm_IPMC_TUNNEL_TYPEf_GET
#define L3_ENTRY_ONLYm_IPMC_TUNNEL_TYPEf_SET BCM56504_A0_L3_ENTRY_ONLYm_IPMC_TUNNEL_TYPEf_SET
#define L3_ENTRY_ONLYm_RPEf_GET BCM56504_A0_L3_ENTRY_ONLYm_RPEf_GET
#define L3_ENTRY_ONLYm_RPEf_SET BCM56504_A0_L3_ENTRY_ONLYm_RPEf_SET
#define L3_ENTRY_ONLYm_PRIf_GET BCM56504_A0_L3_ENTRY_ONLYm_PRIf_GET
#define L3_ENTRY_ONLYm_PRIf_SET BCM56504_A0_L3_ENTRY_ONLYm_PRIf_SET
#define L3_ENTRY_ONLYm_VALIDf_GET BCM56504_A0_L3_ENTRY_ONLYm_VALIDf_GET
#define L3_ENTRY_ONLYm_VALIDf_SET BCM56504_A0_L3_ENTRY_ONLYm_VALIDf_SET
#define L3_ENTRY_ONLYm_NEXT_HOP_INDEXf_GET BCM56504_A0_L3_ENTRY_ONLYm_NEXT_HOP_INDEXf_GET
#define L3_ENTRY_ONLYm_NEXT_HOP_INDEXf_SET BCM56504_A0_L3_ENTRY_ONLYm_NEXT_HOP_INDEXf_SET
#define READ_L3_ENTRY_ONLYm BCM56504_A0_READ_L3_ENTRY_ONLYm
#define WRITE_L3_ENTRY_ONLYm BCM56504_A0_WRITE_L3_ENTRY_ONLYm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_L3_ENTRY_ONLYm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  L3_ENTRY_VALID_ONLY
 * BLOCKS:   IPIPE
 * DESC:     L3 routing table Valid Bits only view.  Organized into buckets
 * SIZE:     8
 * FIELDS:
 *     VALID_0          Indicates that the entry is valid.
 *     VALID_1          Indicates that the entry is valid.
 *     VALID_2          Indicates that the entry is valid.
 *     VALID_3          Indicates that the entry is valid.
 *     VALID_4          Indicates that the entry is valid.
 *     VALID_5          Indicates that the entry is valid.
 *     VALID_6          Indicates that the entry is valid.
 *     VALID_7          Indicates that the entry is valid.
 *
 ******************************************************************************/
#define BCM56504_A0_L3_ENTRY_VALID_ONLYm 0x08770000

#define BCM56504_A0_L3_ENTRY_VALID_ONLYm_MIN 0
#define BCM56504_A0_L3_ENTRY_VALID_ONLYm_MAX 1023
#define BCM56504_A0_L3_ENTRY_VALID_ONLYm_CMAX(u) 1023
#define BCM56504_A0_L3_ENTRY_VALID_ONLYm_SIZE 1

/*
 * This structure should be used to declare and program L3_ENTRY_VALID_ONLY.
 *
 */
typedef union BCM56504_A0_L3_ENTRY_VALID_ONLYm_s {
	uint32_t v[1];
	uint32_t l3_entry_valid_only[1];
	uint32_t _l3_entry_valid_only;
} BCM56504_A0_L3_ENTRY_VALID_ONLYm_t;

#define BCM56504_A0_L3_ENTRY_VALID_ONLYm_CLR(r) (r).l3_entry_valid_only[0] = 0
#define BCM56504_A0_L3_ENTRY_VALID_ONLYm_SET(r,d) (r).l3_entry_valid_only[0] = d
#define BCM56504_A0_L3_ENTRY_VALID_ONLYm_GET(r) (r).l3_entry_valid_only[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_L3_ENTRY_VALID_ONLYm_VALID_0f_GET(r) (((r).l3_entry_valid_only[0]) & 0x1)
#define BCM56504_A0_L3_ENTRY_VALID_ONLYm_VALID_0f_SET(r,f) (r).l3_entry_valid_only[0]=(((r).l3_entry_valid_only[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_L3_ENTRY_VALID_ONLYm_VALID_1f_GET(r) ((((r).l3_entry_valid_only[0]) >> 1) & 0x1)
#define BCM56504_A0_L3_ENTRY_VALID_ONLYm_VALID_1f_SET(r,f) (r).l3_entry_valid_only[0]=(((r).l3_entry_valid_only[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_L3_ENTRY_VALID_ONLYm_VALID_2f_GET(r) ((((r).l3_entry_valid_only[0]) >> 2) & 0x1)
#define BCM56504_A0_L3_ENTRY_VALID_ONLYm_VALID_2f_SET(r,f) (r).l3_entry_valid_only[0]=(((r).l3_entry_valid_only[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_L3_ENTRY_VALID_ONLYm_VALID_3f_GET(r) ((((r).l3_entry_valid_only[0]) >> 3) & 0x1)
#define BCM56504_A0_L3_ENTRY_VALID_ONLYm_VALID_3f_SET(r,f) (r).l3_entry_valid_only[0]=(((r).l3_entry_valid_only[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_L3_ENTRY_VALID_ONLYm_VALID_4f_GET(r) ((((r).l3_entry_valid_only[0]) >> 4) & 0x1)
#define BCM56504_A0_L3_ENTRY_VALID_ONLYm_VALID_4f_SET(r,f) (r).l3_entry_valid_only[0]=(((r).l3_entry_valid_only[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56504_A0_L3_ENTRY_VALID_ONLYm_VALID_5f_GET(r) ((((r).l3_entry_valid_only[0]) >> 5) & 0x1)
#define BCM56504_A0_L3_ENTRY_VALID_ONLYm_VALID_5f_SET(r,f) (r).l3_entry_valid_only[0]=(((r).l3_entry_valid_only[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56504_A0_L3_ENTRY_VALID_ONLYm_VALID_6f_GET(r) ((((r).l3_entry_valid_only[0]) >> 6) & 0x1)
#define BCM56504_A0_L3_ENTRY_VALID_ONLYm_VALID_6f_SET(r,f) (r).l3_entry_valid_only[0]=(((r).l3_entry_valid_only[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56504_A0_L3_ENTRY_VALID_ONLYm_VALID_7f_GET(r) ((((r).l3_entry_valid_only[0]) >> 7) & 0x1)
#define BCM56504_A0_L3_ENTRY_VALID_ONLYm_VALID_7f_SET(r,f) (r).l3_entry_valid_only[0]=(((r).l3_entry_valid_only[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access L3_ENTRY_VALID_ONLY.
 *
 */
#define BCM56504_A0_READ_L3_ENTRY_VALID_ONLYm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_L3_ENTRY_VALID_ONLYm,i,(m._l3_entry_valid_only),1)
#define BCM56504_A0_WRITE_L3_ENTRY_VALID_ONLYm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_L3_ENTRY_VALID_ONLYm,i,&(m._l3_entry_valid_only),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_ENTRY_VALID_ONLYm BCM56504_A0_L3_ENTRY_VALID_ONLYm
#define L3_ENTRY_VALID_ONLYm_MIN BCM56504_A0_L3_ENTRY_VALID_ONLYm_MIN
#define L3_ENTRY_VALID_ONLYm_MAX BCM56504_A0_L3_ENTRY_VALID_ONLYm_MAX
#define L3_ENTRY_VALID_ONLYm_CMAX(u) BCM56504_A0_L3_ENTRY_VALID_ONLYm_CMAX(u)
#define L3_ENTRY_VALID_ONLYm_SIZE BCM56504_A0_L3_ENTRY_VALID_ONLYm_SIZE
typedef BCM56504_A0_L3_ENTRY_VALID_ONLYm_t L3_ENTRY_VALID_ONLYm_t;
#define L3_ENTRY_VALID_ONLYm_CLR BCM56504_A0_L3_ENTRY_VALID_ONLYm_CLR
#define L3_ENTRY_VALID_ONLYm_SET BCM56504_A0_L3_ENTRY_VALID_ONLYm_SET
#define L3_ENTRY_VALID_ONLYm_GET BCM56504_A0_L3_ENTRY_VALID_ONLYm_GET
#define L3_ENTRY_VALID_ONLYm_VALID_0f_GET BCM56504_A0_L3_ENTRY_VALID_ONLYm_VALID_0f_GET
#define L3_ENTRY_VALID_ONLYm_VALID_0f_SET BCM56504_A0_L3_ENTRY_VALID_ONLYm_VALID_0f_SET
#define L3_ENTRY_VALID_ONLYm_VALID_1f_GET BCM56504_A0_L3_ENTRY_VALID_ONLYm_VALID_1f_GET
#define L3_ENTRY_VALID_ONLYm_VALID_1f_SET BCM56504_A0_L3_ENTRY_VALID_ONLYm_VALID_1f_SET
#define L3_ENTRY_VALID_ONLYm_VALID_2f_GET BCM56504_A0_L3_ENTRY_VALID_ONLYm_VALID_2f_GET
#define L3_ENTRY_VALID_ONLYm_VALID_2f_SET BCM56504_A0_L3_ENTRY_VALID_ONLYm_VALID_2f_SET
#define L3_ENTRY_VALID_ONLYm_VALID_3f_GET BCM56504_A0_L3_ENTRY_VALID_ONLYm_VALID_3f_GET
#define L3_ENTRY_VALID_ONLYm_VALID_3f_SET BCM56504_A0_L3_ENTRY_VALID_ONLYm_VALID_3f_SET
#define L3_ENTRY_VALID_ONLYm_VALID_4f_GET BCM56504_A0_L3_ENTRY_VALID_ONLYm_VALID_4f_GET
#define L3_ENTRY_VALID_ONLYm_VALID_4f_SET BCM56504_A0_L3_ENTRY_VALID_ONLYm_VALID_4f_SET
#define L3_ENTRY_VALID_ONLYm_VALID_5f_GET BCM56504_A0_L3_ENTRY_VALID_ONLYm_VALID_5f_GET
#define L3_ENTRY_VALID_ONLYm_VALID_5f_SET BCM56504_A0_L3_ENTRY_VALID_ONLYm_VALID_5f_SET
#define L3_ENTRY_VALID_ONLYm_VALID_6f_GET BCM56504_A0_L3_ENTRY_VALID_ONLYm_VALID_6f_GET
#define L3_ENTRY_VALID_ONLYm_VALID_6f_SET BCM56504_A0_L3_ENTRY_VALID_ONLYm_VALID_6f_SET
#define L3_ENTRY_VALID_ONLYm_VALID_7f_GET BCM56504_A0_L3_ENTRY_VALID_ONLYm_VALID_7f_GET
#define L3_ENTRY_VALID_ONLYm_VALID_7f_SET BCM56504_A0_L3_ENTRY_VALID_ONLYm_VALID_7f_SET
#define READ_L3_ENTRY_VALID_ONLYm BCM56504_A0_READ_L3_ENTRY_VALID_ONLYm
#define WRITE_L3_ENTRY_VALID_ONLYm BCM56504_A0_WRITE_L3_ENTRY_VALID_ONLYm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_L3_ENTRY_VALID_ONLYm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  L3_HIT_DEBUG
 * BLOCKS:   IPIPE
 * DESC:     L3 HIT RAM Debug Register
 * SIZE:     32
 * FIELDS:
 *     CCM              Control core clock margin
 *     RM               Control read margin
 *
 ******************************************************************************/
#define BCM56504_A0_L3_HIT_DEBUGr 0x0b780007

#define BCM56504_A0_L3_HIT_DEBUGr_SIZE 4

/*
 * This structure should be used to declare and program L3_HIT_DEBUG.
 *
 */
typedef union BCM56504_A0_L3_HIT_DEBUGr_s {
	uint32_t v[1];
	uint32_t l3_hit_debug[1];
	uint32_t _l3_hit_debug;
} BCM56504_A0_L3_HIT_DEBUGr_t;

#define BCM56504_A0_L3_HIT_DEBUGr_CLR(r) (r).l3_hit_debug[0] = 0
#define BCM56504_A0_L3_HIT_DEBUGr_SET(r,d) (r).l3_hit_debug[0] = d
#define BCM56504_A0_L3_HIT_DEBUGr_GET(r) (r).l3_hit_debug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_L3_HIT_DEBUGr_CCMf_GET(r) (((r).l3_hit_debug[0]) & 0x1)
#define BCM56504_A0_L3_HIT_DEBUGr_CCMf_SET(r,f) (r).l3_hit_debug[0]=(((r).l3_hit_debug[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_L3_HIT_DEBUGr_RMf_GET(r) ((((r).l3_hit_debug[0]) >> 1) & 0x1)
#define BCM56504_A0_L3_HIT_DEBUGr_RMf_SET(r,f) (r).l3_hit_debug[0]=(((r).l3_hit_debug[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access L3_HIT_DEBUG.
 *
 */
#define BCM56504_A0_READ_L3_HIT_DEBUGr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_L3_HIT_DEBUGr,(r._l3_hit_debug))
#define BCM56504_A0_WRITE_L3_HIT_DEBUGr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_L3_HIT_DEBUGr,&(r._l3_hit_debug))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_HIT_DEBUGr BCM56504_A0_L3_HIT_DEBUGr
#define L3_HIT_DEBUGr_SIZE BCM56504_A0_L3_HIT_DEBUGr_SIZE
typedef BCM56504_A0_L3_HIT_DEBUGr_t L3_HIT_DEBUGr_t;
#define L3_HIT_DEBUGr_CLR BCM56504_A0_L3_HIT_DEBUGr_CLR
#define L3_HIT_DEBUGr_SET BCM56504_A0_L3_HIT_DEBUGr_SET
#define L3_HIT_DEBUGr_GET BCM56504_A0_L3_HIT_DEBUGr_GET
#define L3_HIT_DEBUGr_CCMf_GET BCM56504_A0_L3_HIT_DEBUGr_CCMf_GET
#define L3_HIT_DEBUGr_CCMf_SET BCM56504_A0_L3_HIT_DEBUGr_CCMf_SET
#define L3_HIT_DEBUGr_RMf_GET BCM56504_A0_L3_HIT_DEBUGr_RMf_GET
#define L3_HIT_DEBUGr_RMf_SET BCM56504_A0_L3_HIT_DEBUGr_RMf_SET
#define READ_L3_HIT_DEBUGr BCM56504_A0_READ_L3_HIT_DEBUGr
#define WRITE_L3_HIT_DEBUGr BCM56504_A0_WRITE_L3_HIT_DEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_L3_HIT_DEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  L3_IPMC
 * BLOCKS:   IPIPE
 * DESC:     L3 IPMC Table
 * SIZE:     73
 * FIELDS:
 *     HIGIG_TRUNK_OVERRIDE Higig Trunk Override bits
 *     PORT_TGID        Port or TGID
 *     MODULE_ID        Module ID
 *     VALID            Indicates entry is valid
 *     L2_BITMAP        L2 port bitmap
 *     L3_BITMAP        L3 port bitmap
 *
 ******************************************************************************/
#define BCM56504_A0_L3_IPMCm 0x09700000

#define BCM56504_A0_L3_IPMCm_MIN 0
#define BCM56504_A0_L3_IPMCm_MAX 1023
#define BCM56504_A0_L3_IPMCm_CMAX(u) 1023
#define BCM56504_A0_L3_IPMCm_SIZE 10

/*
 * This structure should be used to declare and program L3_IPMC.
 *
 */
typedef union BCM56504_A0_L3_IPMCm_s {
	uint32_t v[3];
	uint32_t l3_ipmc[3];
	uint32_t _l3_ipmc;
} BCM56504_A0_L3_IPMCm_t;

#define BCM56504_A0_L3_IPMCm_CLR(r) CDK_MEMSET(&((r)._l3_ipmc), 0, sizeof(BCM56504_A0_L3_IPMCm_t))
#define BCM56504_A0_L3_IPMCm_SET(r,i,d) (r).l3_ipmc[i] = d
#define BCM56504_A0_L3_IPMCm_GET(r,i) (r).l3_ipmc[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_L3_IPMCm_HIGIG_TRUNK_OVERRIDEf_GET(r) (((r).l3_ipmc[0]) & 0x3)
#define BCM56504_A0_L3_IPMCm_HIGIG_TRUNK_OVERRIDEf_SET(r,f) (r).l3_ipmc[0]=(((r).l3_ipmc[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56504_A0_L3_IPMCm_PORT_TGIDf_GET(r) ((((r).l3_ipmc[0]) >> 2) & 0x3f)
#define BCM56504_A0_L3_IPMCm_PORT_TGIDf_SET(r,f) (r).l3_ipmc[0]=(((r).l3_ipmc[0] & ~((uint32_t)0x3f << 2)) | ((((uint32_t)f) & 0x3f) << 2))
#define BCM56504_A0_L3_IPMCm_MODULE_IDf_GET(r) ((((r).l3_ipmc[0]) >> 8) & 0x3f)
#define BCM56504_A0_L3_IPMCm_MODULE_IDf_SET(r,f) (r).l3_ipmc[0]=(((r).l3_ipmc[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define BCM56504_A0_L3_IPMCm_VALIDf_GET(r) ((((r).l3_ipmc[0]) >> 14) & 0x1)
#define BCM56504_A0_L3_IPMCm_VALIDf_SET(r,f) (r).l3_ipmc[0]=(((r).l3_ipmc[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM56504_A0_L3_IPMCm_L2_BITMAPf_GET(r) cdk_field32_get((r).l3_ipmc,15,43)
#define BCM56504_A0_L3_IPMCm_L2_BITMAPf_SET(r,f) cdk_field32_set((r).l3_ipmc,15,43,f)
#define BCM56504_A0_L3_IPMCm_L3_BITMAPf_GET(r) cdk_field32_get((r).l3_ipmc,44,72)
#define BCM56504_A0_L3_IPMCm_L3_BITMAPf_SET(r,f) cdk_field32_set((r).l3_ipmc,44,72,f)

/*
 * These macros can be used to access L3_IPMC.
 *
 */
#define BCM56504_A0_READ_L3_IPMCm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_L3_IPMCm,i,(m._l3_ipmc),3)
#define BCM56504_A0_WRITE_L3_IPMCm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_L3_IPMCm,i,&(m._l3_ipmc),3)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_IPMCm BCM56504_A0_L3_IPMCm
#define L3_IPMCm_MIN BCM56504_A0_L3_IPMCm_MIN
#define L3_IPMCm_MAX BCM56504_A0_L3_IPMCm_MAX
#define L3_IPMCm_CMAX(u) BCM56504_A0_L3_IPMCm_CMAX(u)
#define L3_IPMCm_SIZE BCM56504_A0_L3_IPMCm_SIZE
typedef BCM56504_A0_L3_IPMCm_t L3_IPMCm_t;
#define L3_IPMCm_CLR BCM56504_A0_L3_IPMCm_CLR
#define L3_IPMCm_SET BCM56504_A0_L3_IPMCm_SET
#define L3_IPMCm_GET BCM56504_A0_L3_IPMCm_GET
#define L3_IPMCm_HIGIG_TRUNK_OVERRIDEf_GET BCM56504_A0_L3_IPMCm_HIGIG_TRUNK_OVERRIDEf_GET
#define L3_IPMCm_HIGIG_TRUNK_OVERRIDEf_SET BCM56504_A0_L3_IPMCm_HIGIG_TRUNK_OVERRIDEf_SET
#define L3_IPMCm_PORT_TGIDf_GET BCM56504_A0_L3_IPMCm_PORT_TGIDf_GET
#define L3_IPMCm_PORT_TGIDf_SET BCM56504_A0_L3_IPMCm_PORT_TGIDf_SET
#define L3_IPMCm_MODULE_IDf_GET BCM56504_A0_L3_IPMCm_MODULE_IDf_GET
#define L3_IPMCm_MODULE_IDf_SET BCM56504_A0_L3_IPMCm_MODULE_IDf_SET
#define L3_IPMCm_VALIDf_GET BCM56504_A0_L3_IPMCm_VALIDf_GET
#define L3_IPMCm_VALIDf_SET BCM56504_A0_L3_IPMCm_VALIDf_SET
#define L3_IPMCm_L2_BITMAPf_GET BCM56504_A0_L3_IPMCm_L2_BITMAPf_GET
#define L3_IPMCm_L2_BITMAPf_SET BCM56504_A0_L3_IPMCm_L2_BITMAPf_SET
#define L3_IPMCm_L3_BITMAPf_GET BCM56504_A0_L3_IPMCm_L3_BITMAPf_GET
#define L3_IPMCm_L3_BITMAPf_SET BCM56504_A0_L3_IPMCm_L3_BITMAPf_SET
#define READ_L3_IPMCm BCM56504_A0_READ_L3_IPMCm
#define WRITE_L3_IPMCm BCM56504_A0_WRITE_L3_IPMCm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_L3_IPMCm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  L3_TUNNEL
 * BLOCKS:   IPIPE
 * DESC:     L3 Tunnel Table TCAM
 * SIZE:     176
 * FIELDS:
 *     VALID            Valid bit for each TCAM entry
 *     SIP              Source IP Address for tunnel table lookup
 *     DIP              Destination IP Address for tunnel table lookup
 *     SIP_MASK         Source IP Address Mask
 *     DIP_MASK         Destination IP Address Mask
 *     SUB_TUNNEL_TYPE  Indicates L3 tunnel type.  For automatic tunnels it indicates either ISATAP or 6-to-4.  For configured tunnels, it indicates if IPv4 in IPv4 (if sub_tunnel_type[0]==1) and/or IPv6 in IPv4 tunnels (if sub_tunnel_type[1]==1) are allowed.
 *     TUNNEL_TYPE      Indicates whether the tunnel is an auto or configured tunnel
 *     USE_OUTER_HDR_DSCP Use IPv4 outer header's DSCP field
 *     USE_OUTER_HDR_TTL Use IPv4 outer header's TTL field
 *     DONOT_CHANGE_INNER_HDR_DSCP Do not change inner header's DSCP field
 *     ALLOWED_PORT_BITMAP Port bitmap for this tunnel
 *     IINTF            L3 interface for this tunnel for IPMC switching
 *
 ******************************************************************************/
#define BCM56504_A0_L3_TUNNELm 0x02700000

#define BCM56504_A0_L3_TUNNELm_MIN 0
#define BCM56504_A0_L3_TUNNELm_MAX 127
#define BCM56504_A0_L3_TUNNELm_CMAX(u) 127
#define BCM56504_A0_L3_TUNNELm_SIZE 22

/*
 * This structure should be used to declare and program L3_TUNNEL.
 *
 */
typedef union BCM56504_A0_L3_TUNNELm_s {
	uint32_t v[6];
	uint32_t l3_tunnel[6];
	uint32_t _l3_tunnel;
} BCM56504_A0_L3_TUNNELm_t;

#define BCM56504_A0_L3_TUNNELm_CLR(r) CDK_MEMSET(&((r)._l3_tunnel), 0, sizeof(BCM56504_A0_L3_TUNNELm_t))
#define BCM56504_A0_L3_TUNNELm_SET(r,i,d) (r).l3_tunnel[i] = d
#define BCM56504_A0_L3_TUNNELm_GET(r,i) (r).l3_tunnel[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_L3_TUNNELm_VALIDf_GET(r) (((r).l3_tunnel[0]) & 0x1)
#define BCM56504_A0_L3_TUNNELm_VALIDf_SET(r,f) (r).l3_tunnel[0]=(((r).l3_tunnel[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_L3_TUNNELm_SIPf_GET(r) cdk_field32_get((r).l3_tunnel,1,32)
#define BCM56504_A0_L3_TUNNELm_SIPf_SET(r,f) cdk_field32_set((r).l3_tunnel,1,32,f)
#define BCM56504_A0_L3_TUNNELm_DIPf_GET(r) cdk_field32_get((r).l3_tunnel,33,64)
#define BCM56504_A0_L3_TUNNELm_DIPf_SET(r,f) cdk_field32_set((r).l3_tunnel,33,64,f)
#define BCM56504_A0_L3_TUNNELm_SIP_MASKf_GET(r) cdk_field32_get((r).l3_tunnel,65,96)
#define BCM56504_A0_L3_TUNNELm_SIP_MASKf_SET(r,f) cdk_field32_set((r).l3_tunnel,65,96,f)
#define BCM56504_A0_L3_TUNNELm_DIP_MASKf_GET(r) cdk_field32_get((r).l3_tunnel,97,128)
#define BCM56504_A0_L3_TUNNELm_DIP_MASKf_SET(r,f) cdk_field32_set((r).l3_tunnel,97,128,f)
#define BCM56504_A0_L3_TUNNELm_SUB_TUNNEL_TYPEf_GET(r) ((((r).l3_tunnel[4]) >> 1) & 0x3)
#define BCM56504_A0_L3_TUNNELm_SUB_TUNNEL_TYPEf_SET(r,f) (r).l3_tunnel[4]=(((r).l3_tunnel[4] & ~((uint32_t)0x3 << 1)) | ((((uint32_t)f) & 0x3) << 1))
#define BCM56504_A0_L3_TUNNELm_TUNNEL_TYPEf_GET(r) ((((r).l3_tunnel[4]) >> 3) & 0x1)
#define BCM56504_A0_L3_TUNNELm_TUNNEL_TYPEf_SET(r,f) (r).l3_tunnel[4]=(((r).l3_tunnel[4] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_L3_TUNNELm_USE_OUTER_HDR_DSCPf_GET(r) ((((r).l3_tunnel[4]) >> 4) & 0x1)
#define BCM56504_A0_L3_TUNNELm_USE_OUTER_HDR_DSCPf_SET(r,f) (r).l3_tunnel[4]=(((r).l3_tunnel[4] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56504_A0_L3_TUNNELm_USE_OUTER_HDR_TTLf_GET(r) ((((r).l3_tunnel[4]) >> 5) & 0x1)
#define BCM56504_A0_L3_TUNNELm_USE_OUTER_HDR_TTLf_SET(r,f) (r).l3_tunnel[4]=(((r).l3_tunnel[4] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56504_A0_L3_TUNNELm_DONOT_CHANGE_INNER_HDR_DSCPf_GET(r) ((((r).l3_tunnel[4]) >> 6) & 0x1)
#define BCM56504_A0_L3_TUNNELm_DONOT_CHANGE_INNER_HDR_DSCPf_SET(r,f) (r).l3_tunnel[4]=(((r).l3_tunnel[4] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56504_A0_L3_TUNNELm_ALLOWED_PORT_BITMAPf_GET(r) cdk_field32_get((r).l3_tunnel,135,163)
#define BCM56504_A0_L3_TUNNELm_ALLOWED_PORT_BITMAPf_SET(r,f) cdk_field32_set((r).l3_tunnel,135,163,f)
#define BCM56504_A0_L3_TUNNELm_IINTFf_GET(r) ((((r).l3_tunnel[5]) >> 4) & 0xfff)
#define BCM56504_A0_L3_TUNNELm_IINTFf_SET(r,f) (r).l3_tunnel[5]=(((r).l3_tunnel[5] & ~((uint32_t)0xfff << 4)) | ((((uint32_t)f) & 0xfff) << 4))

/*
 * These macros can be used to access L3_TUNNEL.
 *
 */
#define BCM56504_A0_READ_L3_TUNNELm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_L3_TUNNELm,i,(m._l3_tunnel),6)
#define BCM56504_A0_WRITE_L3_TUNNELm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_L3_TUNNELm,i,&(m._l3_tunnel),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_TUNNELm BCM56504_A0_L3_TUNNELm
#define L3_TUNNELm_MIN BCM56504_A0_L3_TUNNELm_MIN
#define L3_TUNNELm_MAX BCM56504_A0_L3_TUNNELm_MAX
#define L3_TUNNELm_CMAX(u) BCM56504_A0_L3_TUNNELm_CMAX(u)
#define L3_TUNNELm_SIZE BCM56504_A0_L3_TUNNELm_SIZE
typedef BCM56504_A0_L3_TUNNELm_t L3_TUNNELm_t;
#define L3_TUNNELm_CLR BCM56504_A0_L3_TUNNELm_CLR
#define L3_TUNNELm_SET BCM56504_A0_L3_TUNNELm_SET
#define L3_TUNNELm_GET BCM56504_A0_L3_TUNNELm_GET
#define L3_TUNNELm_VALIDf_GET BCM56504_A0_L3_TUNNELm_VALIDf_GET
#define L3_TUNNELm_VALIDf_SET BCM56504_A0_L3_TUNNELm_VALIDf_SET
#define L3_TUNNELm_SIPf_GET BCM56504_A0_L3_TUNNELm_SIPf_GET
#define L3_TUNNELm_SIPf_SET BCM56504_A0_L3_TUNNELm_SIPf_SET
#define L3_TUNNELm_DIPf_GET BCM56504_A0_L3_TUNNELm_DIPf_GET
#define L3_TUNNELm_DIPf_SET BCM56504_A0_L3_TUNNELm_DIPf_SET
#define L3_TUNNELm_SIP_MASKf_GET BCM56504_A0_L3_TUNNELm_SIP_MASKf_GET
#define L3_TUNNELm_SIP_MASKf_SET BCM56504_A0_L3_TUNNELm_SIP_MASKf_SET
#define L3_TUNNELm_DIP_MASKf_GET BCM56504_A0_L3_TUNNELm_DIP_MASKf_GET
#define L3_TUNNELm_DIP_MASKf_SET BCM56504_A0_L3_TUNNELm_DIP_MASKf_SET
#define L3_TUNNELm_SUB_TUNNEL_TYPEf_GET BCM56504_A0_L3_TUNNELm_SUB_TUNNEL_TYPEf_GET
#define L3_TUNNELm_SUB_TUNNEL_TYPEf_SET BCM56504_A0_L3_TUNNELm_SUB_TUNNEL_TYPEf_SET
#define L3_TUNNELm_TUNNEL_TYPEf_GET BCM56504_A0_L3_TUNNELm_TUNNEL_TYPEf_GET
#define L3_TUNNELm_TUNNEL_TYPEf_SET BCM56504_A0_L3_TUNNELm_TUNNEL_TYPEf_SET
#define L3_TUNNELm_USE_OUTER_HDR_DSCPf_GET BCM56504_A0_L3_TUNNELm_USE_OUTER_HDR_DSCPf_GET
#define L3_TUNNELm_USE_OUTER_HDR_DSCPf_SET BCM56504_A0_L3_TUNNELm_USE_OUTER_HDR_DSCPf_SET
#define L3_TUNNELm_USE_OUTER_HDR_TTLf_GET BCM56504_A0_L3_TUNNELm_USE_OUTER_HDR_TTLf_GET
#define L3_TUNNELm_USE_OUTER_HDR_TTLf_SET BCM56504_A0_L3_TUNNELm_USE_OUTER_HDR_TTLf_SET
#define L3_TUNNELm_DONOT_CHANGE_INNER_HDR_DSCPf_GET BCM56504_A0_L3_TUNNELm_DONOT_CHANGE_INNER_HDR_DSCPf_GET
#define L3_TUNNELm_DONOT_CHANGE_INNER_HDR_DSCPf_SET BCM56504_A0_L3_TUNNELm_DONOT_CHANGE_INNER_HDR_DSCPf_SET
#define L3_TUNNELm_ALLOWED_PORT_BITMAPf_GET BCM56504_A0_L3_TUNNELm_ALLOWED_PORT_BITMAPf_GET
#define L3_TUNNELm_ALLOWED_PORT_BITMAPf_SET BCM56504_A0_L3_TUNNELm_ALLOWED_PORT_BITMAPf_SET
#define L3_TUNNELm_IINTFf_GET BCM56504_A0_L3_TUNNELm_IINTFf_GET
#define L3_TUNNELm_IINTFf_SET BCM56504_A0_L3_TUNNELm_IINTFf_SET
#define READ_L3_TUNNELm BCM56504_A0_READ_L3_TUNNELm
#define WRITE_L3_TUNNELm BCM56504_A0_WRITE_L3_TUNNELm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_L3_TUNNELm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  L3_TUNNEL_CAM_BIST_S10_STATUS
 * BLOCKS:   IPIPE_HI
 * DESC:     L3_TUNNEL_CAM_BIST_S10_STATUS
 * SIZE:     32
 * FIELDS:
 *     MATCH_STATUS     Match status
 *     AINDEX           Aindex when match happened
 *
 ******************************************************************************/
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S10_STATUSr 0x02880015

#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S10_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program L3_TUNNEL_CAM_BIST_S10_STATUS.
 *
 */
typedef union BCM56504_A0_L3_TUNNEL_CAM_BIST_S10_STATUSr_s {
	uint32_t v[1];
	uint32_t l3_tunnel_cam_bist_s10_status[1];
	uint32_t _l3_tunnel_cam_bist_s10_status;
} BCM56504_A0_L3_TUNNEL_CAM_BIST_S10_STATUSr_t;

#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S10_STATUSr_CLR(r) (r).l3_tunnel_cam_bist_s10_status[0] = 0
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S10_STATUSr_SET(r,d) (r).l3_tunnel_cam_bist_s10_status[0] = d
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S10_STATUSr_GET(r) (r).l3_tunnel_cam_bist_s10_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S10_STATUSr_MATCH_STATUSf_GET(r) (((r).l3_tunnel_cam_bist_s10_status[0]) & 0x1)
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S10_STATUSr_MATCH_STATUSf_SET(r,f) (r).l3_tunnel_cam_bist_s10_status[0]=(((r).l3_tunnel_cam_bist_s10_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S10_STATUSr_AINDEXf_GET(r) ((((r).l3_tunnel_cam_bist_s10_status[0]) >> 1) & 0x7f)
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S10_STATUSr_AINDEXf_SET(r,f) (r).l3_tunnel_cam_bist_s10_status[0]=(((r).l3_tunnel_cam_bist_s10_status[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))

/*
 * These macros can be used to access L3_TUNNEL_CAM_BIST_S10_STATUS.
 *
 */
#define BCM56504_A0_READ_L3_TUNNEL_CAM_BIST_S10_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_L3_TUNNEL_CAM_BIST_S10_STATUSr,(r._l3_tunnel_cam_bist_s10_status))
#define BCM56504_A0_WRITE_L3_TUNNEL_CAM_BIST_S10_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_L3_TUNNEL_CAM_BIST_S10_STATUSr,&(r._l3_tunnel_cam_bist_s10_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_TUNNEL_CAM_BIST_S10_STATUSr BCM56504_A0_L3_TUNNEL_CAM_BIST_S10_STATUSr
#define L3_TUNNEL_CAM_BIST_S10_STATUSr_SIZE BCM56504_A0_L3_TUNNEL_CAM_BIST_S10_STATUSr_SIZE
typedef BCM56504_A0_L3_TUNNEL_CAM_BIST_S10_STATUSr_t L3_TUNNEL_CAM_BIST_S10_STATUSr_t;
#define L3_TUNNEL_CAM_BIST_S10_STATUSr_CLR BCM56504_A0_L3_TUNNEL_CAM_BIST_S10_STATUSr_CLR
#define L3_TUNNEL_CAM_BIST_S10_STATUSr_SET BCM56504_A0_L3_TUNNEL_CAM_BIST_S10_STATUSr_SET
#define L3_TUNNEL_CAM_BIST_S10_STATUSr_GET BCM56504_A0_L3_TUNNEL_CAM_BIST_S10_STATUSr_GET
#define L3_TUNNEL_CAM_BIST_S10_STATUSr_MATCH_STATUSf_GET BCM56504_A0_L3_TUNNEL_CAM_BIST_S10_STATUSr_MATCH_STATUSf_GET
#define L3_TUNNEL_CAM_BIST_S10_STATUSr_MATCH_STATUSf_SET BCM56504_A0_L3_TUNNEL_CAM_BIST_S10_STATUSr_MATCH_STATUSf_SET
#define L3_TUNNEL_CAM_BIST_S10_STATUSr_AINDEXf_GET BCM56504_A0_L3_TUNNEL_CAM_BIST_S10_STATUSr_AINDEXf_GET
#define L3_TUNNEL_CAM_BIST_S10_STATUSr_AINDEXf_SET BCM56504_A0_L3_TUNNEL_CAM_BIST_S10_STATUSr_AINDEXf_SET
#define READ_L3_TUNNEL_CAM_BIST_S10_STATUSr BCM56504_A0_READ_L3_TUNNEL_CAM_BIST_S10_STATUSr
#define WRITE_L3_TUNNEL_CAM_BIST_S10_STATUSr BCM56504_A0_WRITE_L3_TUNNEL_CAM_BIST_S10_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_L3_TUNNEL_CAM_BIST_S10_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  L3_TUNNEL_CAM_BIST_S2_STATUS
 * BLOCKS:   IPIPE_HI
 * DESC:     L3_TUNNEL_CAM_BIST_S2_STATUS
 * SIZE:     32
 * FIELDS:
 *     MATCH_STATUS     Match status
 *     BIT_POS          Sliding Bit position when match happened
 *     AINDEX           Aindex when match happened
 *
 ******************************************************************************/
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S2_STATUSr 0x02880010

#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S2_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program L3_TUNNEL_CAM_BIST_S2_STATUS.
 *
 */
typedef union BCM56504_A0_L3_TUNNEL_CAM_BIST_S2_STATUSr_s {
	uint32_t v[1];
	uint32_t l3_tunnel_cam_bist_s2_status[1];
	uint32_t _l3_tunnel_cam_bist_s2_status;
} BCM56504_A0_L3_TUNNEL_CAM_BIST_S2_STATUSr_t;

#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S2_STATUSr_CLR(r) (r).l3_tunnel_cam_bist_s2_status[0] = 0
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S2_STATUSr_SET(r,d) (r).l3_tunnel_cam_bist_s2_status[0] = d
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S2_STATUSr_GET(r) (r).l3_tunnel_cam_bist_s2_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S2_STATUSr_MATCH_STATUSf_GET(r) (((r).l3_tunnel_cam_bist_s2_status[0]) & 0x1)
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S2_STATUSr_MATCH_STATUSf_SET(r,f) (r).l3_tunnel_cam_bist_s2_status[0]=(((r).l3_tunnel_cam_bist_s2_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S2_STATUSr_BIT_POSf_GET(r) ((((r).l3_tunnel_cam_bist_s2_status[0]) >> 1) & 0x7f)
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S2_STATUSr_BIT_POSf_SET(r,f) (r).l3_tunnel_cam_bist_s2_status[0]=(((r).l3_tunnel_cam_bist_s2_status[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S2_STATUSr_AINDEXf_GET(r) ((((r).l3_tunnel_cam_bist_s2_status[0]) >> 8) & 0x7f)
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S2_STATUSr_AINDEXf_SET(r,f) (r).l3_tunnel_cam_bist_s2_status[0]=(((r).l3_tunnel_cam_bist_s2_status[0] & ~((uint32_t)0x7f << 8)) | ((((uint32_t)f) & 0x7f) << 8))

/*
 * These macros can be used to access L3_TUNNEL_CAM_BIST_S2_STATUS.
 *
 */
#define BCM56504_A0_READ_L3_TUNNEL_CAM_BIST_S2_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_L3_TUNNEL_CAM_BIST_S2_STATUSr,(r._l3_tunnel_cam_bist_s2_status))
#define BCM56504_A0_WRITE_L3_TUNNEL_CAM_BIST_S2_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_L3_TUNNEL_CAM_BIST_S2_STATUSr,&(r._l3_tunnel_cam_bist_s2_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_TUNNEL_CAM_BIST_S2_STATUSr BCM56504_A0_L3_TUNNEL_CAM_BIST_S2_STATUSr
#define L3_TUNNEL_CAM_BIST_S2_STATUSr_SIZE BCM56504_A0_L3_TUNNEL_CAM_BIST_S2_STATUSr_SIZE
typedef BCM56504_A0_L3_TUNNEL_CAM_BIST_S2_STATUSr_t L3_TUNNEL_CAM_BIST_S2_STATUSr_t;
#define L3_TUNNEL_CAM_BIST_S2_STATUSr_CLR BCM56504_A0_L3_TUNNEL_CAM_BIST_S2_STATUSr_CLR
#define L3_TUNNEL_CAM_BIST_S2_STATUSr_SET BCM56504_A0_L3_TUNNEL_CAM_BIST_S2_STATUSr_SET
#define L3_TUNNEL_CAM_BIST_S2_STATUSr_GET BCM56504_A0_L3_TUNNEL_CAM_BIST_S2_STATUSr_GET
#define L3_TUNNEL_CAM_BIST_S2_STATUSr_MATCH_STATUSf_GET BCM56504_A0_L3_TUNNEL_CAM_BIST_S2_STATUSr_MATCH_STATUSf_GET
#define L3_TUNNEL_CAM_BIST_S2_STATUSr_MATCH_STATUSf_SET BCM56504_A0_L3_TUNNEL_CAM_BIST_S2_STATUSr_MATCH_STATUSf_SET
#define L3_TUNNEL_CAM_BIST_S2_STATUSr_BIT_POSf_GET BCM56504_A0_L3_TUNNEL_CAM_BIST_S2_STATUSr_BIT_POSf_GET
#define L3_TUNNEL_CAM_BIST_S2_STATUSr_BIT_POSf_SET BCM56504_A0_L3_TUNNEL_CAM_BIST_S2_STATUSr_BIT_POSf_SET
#define L3_TUNNEL_CAM_BIST_S2_STATUSr_AINDEXf_GET BCM56504_A0_L3_TUNNEL_CAM_BIST_S2_STATUSr_AINDEXf_GET
#define L3_TUNNEL_CAM_BIST_S2_STATUSr_AINDEXf_SET BCM56504_A0_L3_TUNNEL_CAM_BIST_S2_STATUSr_AINDEXf_SET
#define READ_L3_TUNNEL_CAM_BIST_S2_STATUSr BCM56504_A0_READ_L3_TUNNEL_CAM_BIST_S2_STATUSr
#define WRITE_L3_TUNNEL_CAM_BIST_S2_STATUSr BCM56504_A0_WRITE_L3_TUNNEL_CAM_BIST_S2_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_L3_TUNNEL_CAM_BIST_S2_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  L3_TUNNEL_CAM_BIST_S3_STATUS
 * BLOCKS:   IPIPE_HI
 * DESC:     L3_TUNNEL_CAM_BIST_S3_STATUS
 * SIZE:     32
 * FIELDS:
 *     MATCH_STATUS     Match status
 *     AINDEX_STATUS    AIndex status
 *     ACTUAL_AINDEX    Actual AIndex when CAM reported a match
 *     EXPECTED_AINDEX  Expected AIndex
 *
 ******************************************************************************/
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S3_STATUSr 0x02880011

#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S3_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program L3_TUNNEL_CAM_BIST_S3_STATUS.
 *
 */
typedef union BCM56504_A0_L3_TUNNEL_CAM_BIST_S3_STATUSr_s {
	uint32_t v[1];
	uint32_t l3_tunnel_cam_bist_s3_status[1];
	uint32_t _l3_tunnel_cam_bist_s3_status;
} BCM56504_A0_L3_TUNNEL_CAM_BIST_S3_STATUSr_t;

#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S3_STATUSr_CLR(r) (r).l3_tunnel_cam_bist_s3_status[0] = 0
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S3_STATUSr_SET(r,d) (r).l3_tunnel_cam_bist_s3_status[0] = d
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S3_STATUSr_GET(r) (r).l3_tunnel_cam_bist_s3_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S3_STATUSr_MATCH_STATUSf_GET(r) (((r).l3_tunnel_cam_bist_s3_status[0]) & 0x1)
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S3_STATUSr_MATCH_STATUSf_SET(r,f) (r).l3_tunnel_cam_bist_s3_status[0]=(((r).l3_tunnel_cam_bist_s3_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S3_STATUSr_AINDEX_STATUSf_GET(r) ((((r).l3_tunnel_cam_bist_s3_status[0]) >> 1) & 0x1)
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S3_STATUSr_AINDEX_STATUSf_SET(r,f) (r).l3_tunnel_cam_bist_s3_status[0]=(((r).l3_tunnel_cam_bist_s3_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S3_STATUSr_ACTUAL_AINDEXf_GET(r) ((((r).l3_tunnel_cam_bist_s3_status[0]) >> 2) & 0x7f)
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S3_STATUSr_ACTUAL_AINDEXf_SET(r,f) (r).l3_tunnel_cam_bist_s3_status[0]=(((r).l3_tunnel_cam_bist_s3_status[0] & ~((uint32_t)0x7f << 2)) | ((((uint32_t)f) & 0x7f) << 2))
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S3_STATUSr_EXPECTED_AINDEXf_GET(r) ((((r).l3_tunnel_cam_bist_s3_status[0]) >> 9) & 0x7f)
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S3_STATUSr_EXPECTED_AINDEXf_SET(r,f) (r).l3_tunnel_cam_bist_s3_status[0]=(((r).l3_tunnel_cam_bist_s3_status[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access L3_TUNNEL_CAM_BIST_S3_STATUS.
 *
 */
#define BCM56504_A0_READ_L3_TUNNEL_CAM_BIST_S3_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_L3_TUNNEL_CAM_BIST_S3_STATUSr,(r._l3_tunnel_cam_bist_s3_status))
#define BCM56504_A0_WRITE_L3_TUNNEL_CAM_BIST_S3_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_L3_TUNNEL_CAM_BIST_S3_STATUSr,&(r._l3_tunnel_cam_bist_s3_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_TUNNEL_CAM_BIST_S3_STATUSr BCM56504_A0_L3_TUNNEL_CAM_BIST_S3_STATUSr
#define L3_TUNNEL_CAM_BIST_S3_STATUSr_SIZE BCM56504_A0_L3_TUNNEL_CAM_BIST_S3_STATUSr_SIZE
typedef BCM56504_A0_L3_TUNNEL_CAM_BIST_S3_STATUSr_t L3_TUNNEL_CAM_BIST_S3_STATUSr_t;
#define L3_TUNNEL_CAM_BIST_S3_STATUSr_CLR BCM56504_A0_L3_TUNNEL_CAM_BIST_S3_STATUSr_CLR
#define L3_TUNNEL_CAM_BIST_S3_STATUSr_SET BCM56504_A0_L3_TUNNEL_CAM_BIST_S3_STATUSr_SET
#define L3_TUNNEL_CAM_BIST_S3_STATUSr_GET BCM56504_A0_L3_TUNNEL_CAM_BIST_S3_STATUSr_GET
#define L3_TUNNEL_CAM_BIST_S3_STATUSr_MATCH_STATUSf_GET BCM56504_A0_L3_TUNNEL_CAM_BIST_S3_STATUSr_MATCH_STATUSf_GET
#define L3_TUNNEL_CAM_BIST_S3_STATUSr_MATCH_STATUSf_SET BCM56504_A0_L3_TUNNEL_CAM_BIST_S3_STATUSr_MATCH_STATUSf_SET
#define L3_TUNNEL_CAM_BIST_S3_STATUSr_AINDEX_STATUSf_GET BCM56504_A0_L3_TUNNEL_CAM_BIST_S3_STATUSr_AINDEX_STATUSf_GET
#define L3_TUNNEL_CAM_BIST_S3_STATUSr_AINDEX_STATUSf_SET BCM56504_A0_L3_TUNNEL_CAM_BIST_S3_STATUSr_AINDEX_STATUSf_SET
#define L3_TUNNEL_CAM_BIST_S3_STATUSr_ACTUAL_AINDEXf_GET BCM56504_A0_L3_TUNNEL_CAM_BIST_S3_STATUSr_ACTUAL_AINDEXf_GET
#define L3_TUNNEL_CAM_BIST_S3_STATUSr_ACTUAL_AINDEXf_SET BCM56504_A0_L3_TUNNEL_CAM_BIST_S3_STATUSr_ACTUAL_AINDEXf_SET
#define L3_TUNNEL_CAM_BIST_S3_STATUSr_EXPECTED_AINDEXf_GET BCM56504_A0_L3_TUNNEL_CAM_BIST_S3_STATUSr_EXPECTED_AINDEXf_GET
#define L3_TUNNEL_CAM_BIST_S3_STATUSr_EXPECTED_AINDEXf_SET BCM56504_A0_L3_TUNNEL_CAM_BIST_S3_STATUSr_EXPECTED_AINDEXf_SET
#define READ_L3_TUNNEL_CAM_BIST_S3_STATUSr BCM56504_A0_READ_L3_TUNNEL_CAM_BIST_S3_STATUSr
#define WRITE_L3_TUNNEL_CAM_BIST_S3_STATUSr BCM56504_A0_WRITE_L3_TUNNEL_CAM_BIST_S3_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_L3_TUNNEL_CAM_BIST_S3_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  L3_TUNNEL_CAM_BIST_S5_STATUS
 * BLOCKS:   IPIPE_HI
 * DESC:     L3_TUNNEL_CAM_BIST_S5_STATUS
 * SIZE:     32
 * FIELDS:
 *     MATCH_STATUS     Match status
 *     BIT_POS          Sliding Bit position when match happened
 *     AINDEX           Aindex when match happened
 *
 ******************************************************************************/
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S5_STATUSr 0x02880012

#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S5_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program L3_TUNNEL_CAM_BIST_S5_STATUS.
 *
 */
typedef union BCM56504_A0_L3_TUNNEL_CAM_BIST_S5_STATUSr_s {
	uint32_t v[1];
	uint32_t l3_tunnel_cam_bist_s5_status[1];
	uint32_t _l3_tunnel_cam_bist_s5_status;
} BCM56504_A0_L3_TUNNEL_CAM_BIST_S5_STATUSr_t;

#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S5_STATUSr_CLR(r) (r).l3_tunnel_cam_bist_s5_status[0] = 0
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S5_STATUSr_SET(r,d) (r).l3_tunnel_cam_bist_s5_status[0] = d
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S5_STATUSr_GET(r) (r).l3_tunnel_cam_bist_s5_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S5_STATUSr_MATCH_STATUSf_GET(r) (((r).l3_tunnel_cam_bist_s5_status[0]) & 0x1)
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S5_STATUSr_MATCH_STATUSf_SET(r,f) (r).l3_tunnel_cam_bist_s5_status[0]=(((r).l3_tunnel_cam_bist_s5_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S5_STATUSr_BIT_POSf_GET(r) ((((r).l3_tunnel_cam_bist_s5_status[0]) >> 1) & 0x7f)
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S5_STATUSr_BIT_POSf_SET(r,f) (r).l3_tunnel_cam_bist_s5_status[0]=(((r).l3_tunnel_cam_bist_s5_status[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S5_STATUSr_AINDEXf_GET(r) ((((r).l3_tunnel_cam_bist_s5_status[0]) >> 8) & 0x7f)
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S5_STATUSr_AINDEXf_SET(r,f) (r).l3_tunnel_cam_bist_s5_status[0]=(((r).l3_tunnel_cam_bist_s5_status[0] & ~((uint32_t)0x7f << 8)) | ((((uint32_t)f) & 0x7f) << 8))

/*
 * These macros can be used to access L3_TUNNEL_CAM_BIST_S5_STATUS.
 *
 */
#define BCM56504_A0_READ_L3_TUNNEL_CAM_BIST_S5_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_L3_TUNNEL_CAM_BIST_S5_STATUSr,(r._l3_tunnel_cam_bist_s5_status))
#define BCM56504_A0_WRITE_L3_TUNNEL_CAM_BIST_S5_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_L3_TUNNEL_CAM_BIST_S5_STATUSr,&(r._l3_tunnel_cam_bist_s5_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_TUNNEL_CAM_BIST_S5_STATUSr BCM56504_A0_L3_TUNNEL_CAM_BIST_S5_STATUSr
#define L3_TUNNEL_CAM_BIST_S5_STATUSr_SIZE BCM56504_A0_L3_TUNNEL_CAM_BIST_S5_STATUSr_SIZE
typedef BCM56504_A0_L3_TUNNEL_CAM_BIST_S5_STATUSr_t L3_TUNNEL_CAM_BIST_S5_STATUSr_t;
#define L3_TUNNEL_CAM_BIST_S5_STATUSr_CLR BCM56504_A0_L3_TUNNEL_CAM_BIST_S5_STATUSr_CLR
#define L3_TUNNEL_CAM_BIST_S5_STATUSr_SET BCM56504_A0_L3_TUNNEL_CAM_BIST_S5_STATUSr_SET
#define L3_TUNNEL_CAM_BIST_S5_STATUSr_GET BCM56504_A0_L3_TUNNEL_CAM_BIST_S5_STATUSr_GET
#define L3_TUNNEL_CAM_BIST_S5_STATUSr_MATCH_STATUSf_GET BCM56504_A0_L3_TUNNEL_CAM_BIST_S5_STATUSr_MATCH_STATUSf_GET
#define L3_TUNNEL_CAM_BIST_S5_STATUSr_MATCH_STATUSf_SET BCM56504_A0_L3_TUNNEL_CAM_BIST_S5_STATUSr_MATCH_STATUSf_SET
#define L3_TUNNEL_CAM_BIST_S5_STATUSr_BIT_POSf_GET BCM56504_A0_L3_TUNNEL_CAM_BIST_S5_STATUSr_BIT_POSf_GET
#define L3_TUNNEL_CAM_BIST_S5_STATUSr_BIT_POSf_SET BCM56504_A0_L3_TUNNEL_CAM_BIST_S5_STATUSr_BIT_POSf_SET
#define L3_TUNNEL_CAM_BIST_S5_STATUSr_AINDEXf_GET BCM56504_A0_L3_TUNNEL_CAM_BIST_S5_STATUSr_AINDEXf_GET
#define L3_TUNNEL_CAM_BIST_S5_STATUSr_AINDEXf_SET BCM56504_A0_L3_TUNNEL_CAM_BIST_S5_STATUSr_AINDEXf_SET
#define READ_L3_TUNNEL_CAM_BIST_S5_STATUSr BCM56504_A0_READ_L3_TUNNEL_CAM_BIST_S5_STATUSr
#define WRITE_L3_TUNNEL_CAM_BIST_S5_STATUSr BCM56504_A0_WRITE_L3_TUNNEL_CAM_BIST_S5_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_L3_TUNNEL_CAM_BIST_S5_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  L3_TUNNEL_CAM_BIST_S6_STATUS
 * BLOCKS:   IPIPE_HI
 * DESC:     L3_TUNNEL_CAM_BIST_S6_STATUS
 * SIZE:     32
 * FIELDS:
 *     MATCH_STATUS     Match status
 *     AINDEX_STATUS    AIndex status
 *     ACTUAL_AINDEX    Actual AIndex when CAM reported a match
 *     EXPECTED_AINDEX  Expected AIndex
 *
 ******************************************************************************/
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S6_STATUSr 0x02880013

#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S6_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program L3_TUNNEL_CAM_BIST_S6_STATUS.
 *
 */
typedef union BCM56504_A0_L3_TUNNEL_CAM_BIST_S6_STATUSr_s {
	uint32_t v[1];
	uint32_t l3_tunnel_cam_bist_s6_status[1];
	uint32_t _l3_tunnel_cam_bist_s6_status;
} BCM56504_A0_L3_TUNNEL_CAM_BIST_S6_STATUSr_t;

#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S6_STATUSr_CLR(r) (r).l3_tunnel_cam_bist_s6_status[0] = 0
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S6_STATUSr_SET(r,d) (r).l3_tunnel_cam_bist_s6_status[0] = d
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S6_STATUSr_GET(r) (r).l3_tunnel_cam_bist_s6_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S6_STATUSr_MATCH_STATUSf_GET(r) (((r).l3_tunnel_cam_bist_s6_status[0]) & 0x1)
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S6_STATUSr_MATCH_STATUSf_SET(r,f) (r).l3_tunnel_cam_bist_s6_status[0]=(((r).l3_tunnel_cam_bist_s6_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S6_STATUSr_AINDEX_STATUSf_GET(r) ((((r).l3_tunnel_cam_bist_s6_status[0]) >> 1) & 0x1)
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S6_STATUSr_AINDEX_STATUSf_SET(r,f) (r).l3_tunnel_cam_bist_s6_status[0]=(((r).l3_tunnel_cam_bist_s6_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S6_STATUSr_ACTUAL_AINDEXf_GET(r) ((((r).l3_tunnel_cam_bist_s6_status[0]) >> 2) & 0x7f)
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S6_STATUSr_ACTUAL_AINDEXf_SET(r,f) (r).l3_tunnel_cam_bist_s6_status[0]=(((r).l3_tunnel_cam_bist_s6_status[0] & ~((uint32_t)0x7f << 2)) | ((((uint32_t)f) & 0x7f) << 2))
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S6_STATUSr_EXPECTED_AINDEXf_GET(r) ((((r).l3_tunnel_cam_bist_s6_status[0]) >> 9) & 0x7f)
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S6_STATUSr_EXPECTED_AINDEXf_SET(r,f) (r).l3_tunnel_cam_bist_s6_status[0]=(((r).l3_tunnel_cam_bist_s6_status[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access L3_TUNNEL_CAM_BIST_S6_STATUS.
 *
 */
#define BCM56504_A0_READ_L3_TUNNEL_CAM_BIST_S6_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_L3_TUNNEL_CAM_BIST_S6_STATUSr,(r._l3_tunnel_cam_bist_s6_status))
#define BCM56504_A0_WRITE_L3_TUNNEL_CAM_BIST_S6_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_L3_TUNNEL_CAM_BIST_S6_STATUSr,&(r._l3_tunnel_cam_bist_s6_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_TUNNEL_CAM_BIST_S6_STATUSr BCM56504_A0_L3_TUNNEL_CAM_BIST_S6_STATUSr
#define L3_TUNNEL_CAM_BIST_S6_STATUSr_SIZE BCM56504_A0_L3_TUNNEL_CAM_BIST_S6_STATUSr_SIZE
typedef BCM56504_A0_L3_TUNNEL_CAM_BIST_S6_STATUSr_t L3_TUNNEL_CAM_BIST_S6_STATUSr_t;
#define L3_TUNNEL_CAM_BIST_S6_STATUSr_CLR BCM56504_A0_L3_TUNNEL_CAM_BIST_S6_STATUSr_CLR
#define L3_TUNNEL_CAM_BIST_S6_STATUSr_SET BCM56504_A0_L3_TUNNEL_CAM_BIST_S6_STATUSr_SET
#define L3_TUNNEL_CAM_BIST_S6_STATUSr_GET BCM56504_A0_L3_TUNNEL_CAM_BIST_S6_STATUSr_GET
#define L3_TUNNEL_CAM_BIST_S6_STATUSr_MATCH_STATUSf_GET BCM56504_A0_L3_TUNNEL_CAM_BIST_S6_STATUSr_MATCH_STATUSf_GET
#define L3_TUNNEL_CAM_BIST_S6_STATUSr_MATCH_STATUSf_SET BCM56504_A0_L3_TUNNEL_CAM_BIST_S6_STATUSr_MATCH_STATUSf_SET
#define L3_TUNNEL_CAM_BIST_S6_STATUSr_AINDEX_STATUSf_GET BCM56504_A0_L3_TUNNEL_CAM_BIST_S6_STATUSr_AINDEX_STATUSf_GET
#define L3_TUNNEL_CAM_BIST_S6_STATUSr_AINDEX_STATUSf_SET BCM56504_A0_L3_TUNNEL_CAM_BIST_S6_STATUSr_AINDEX_STATUSf_SET
#define L3_TUNNEL_CAM_BIST_S6_STATUSr_ACTUAL_AINDEXf_GET BCM56504_A0_L3_TUNNEL_CAM_BIST_S6_STATUSr_ACTUAL_AINDEXf_GET
#define L3_TUNNEL_CAM_BIST_S6_STATUSr_ACTUAL_AINDEXf_SET BCM56504_A0_L3_TUNNEL_CAM_BIST_S6_STATUSr_ACTUAL_AINDEXf_SET
#define L3_TUNNEL_CAM_BIST_S6_STATUSr_EXPECTED_AINDEXf_GET BCM56504_A0_L3_TUNNEL_CAM_BIST_S6_STATUSr_EXPECTED_AINDEXf_GET
#define L3_TUNNEL_CAM_BIST_S6_STATUSr_EXPECTED_AINDEXf_SET BCM56504_A0_L3_TUNNEL_CAM_BIST_S6_STATUSr_EXPECTED_AINDEXf_SET
#define READ_L3_TUNNEL_CAM_BIST_S6_STATUSr BCM56504_A0_READ_L3_TUNNEL_CAM_BIST_S6_STATUSr
#define WRITE_L3_TUNNEL_CAM_BIST_S6_STATUSr BCM56504_A0_WRITE_L3_TUNNEL_CAM_BIST_S6_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_L3_TUNNEL_CAM_BIST_S6_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  L3_TUNNEL_CAM_BIST_S8_STATUS
 * BLOCKS:   IPIPE_HI
 * DESC:     L3_TUNNEL_CAM_BIST_S8_STATUS
 * SIZE:     32
 * FIELDS:
 *     MATCH_STATUS     Match status
 *     AINDEX_STATUS    AIndex status
 *     ACTUAL_AINDEX    Actual AIndex when CAM reported a match
 *     EXPECTED_AINDEX  Expected AIndex
 *
 ******************************************************************************/
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S8_STATUSr 0x02880014

#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S8_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program L3_TUNNEL_CAM_BIST_S8_STATUS.
 *
 */
typedef union BCM56504_A0_L3_TUNNEL_CAM_BIST_S8_STATUSr_s {
	uint32_t v[1];
	uint32_t l3_tunnel_cam_bist_s8_status[1];
	uint32_t _l3_tunnel_cam_bist_s8_status;
} BCM56504_A0_L3_TUNNEL_CAM_BIST_S8_STATUSr_t;

#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S8_STATUSr_CLR(r) (r).l3_tunnel_cam_bist_s8_status[0] = 0
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S8_STATUSr_SET(r,d) (r).l3_tunnel_cam_bist_s8_status[0] = d
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S8_STATUSr_GET(r) (r).l3_tunnel_cam_bist_s8_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S8_STATUSr_MATCH_STATUSf_GET(r) (((r).l3_tunnel_cam_bist_s8_status[0]) & 0x1)
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S8_STATUSr_MATCH_STATUSf_SET(r,f) (r).l3_tunnel_cam_bist_s8_status[0]=(((r).l3_tunnel_cam_bist_s8_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S8_STATUSr_AINDEX_STATUSf_GET(r) ((((r).l3_tunnel_cam_bist_s8_status[0]) >> 1) & 0x1)
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S8_STATUSr_AINDEX_STATUSf_SET(r,f) (r).l3_tunnel_cam_bist_s8_status[0]=(((r).l3_tunnel_cam_bist_s8_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S8_STATUSr_ACTUAL_AINDEXf_GET(r) ((((r).l3_tunnel_cam_bist_s8_status[0]) >> 2) & 0x7f)
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S8_STATUSr_ACTUAL_AINDEXf_SET(r,f) (r).l3_tunnel_cam_bist_s8_status[0]=(((r).l3_tunnel_cam_bist_s8_status[0] & ~((uint32_t)0x7f << 2)) | ((((uint32_t)f) & 0x7f) << 2))
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S8_STATUSr_EXPECTED_AINDEXf_GET(r) ((((r).l3_tunnel_cam_bist_s8_status[0]) >> 9) & 0x7f)
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_S8_STATUSr_EXPECTED_AINDEXf_SET(r,f) (r).l3_tunnel_cam_bist_s8_status[0]=(((r).l3_tunnel_cam_bist_s8_status[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access L3_TUNNEL_CAM_BIST_S8_STATUS.
 *
 */
#define BCM56504_A0_READ_L3_TUNNEL_CAM_BIST_S8_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_L3_TUNNEL_CAM_BIST_S8_STATUSr,(r._l3_tunnel_cam_bist_s8_status))
#define BCM56504_A0_WRITE_L3_TUNNEL_CAM_BIST_S8_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_L3_TUNNEL_CAM_BIST_S8_STATUSr,&(r._l3_tunnel_cam_bist_s8_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_TUNNEL_CAM_BIST_S8_STATUSr BCM56504_A0_L3_TUNNEL_CAM_BIST_S8_STATUSr
#define L3_TUNNEL_CAM_BIST_S8_STATUSr_SIZE BCM56504_A0_L3_TUNNEL_CAM_BIST_S8_STATUSr_SIZE
typedef BCM56504_A0_L3_TUNNEL_CAM_BIST_S8_STATUSr_t L3_TUNNEL_CAM_BIST_S8_STATUSr_t;
#define L3_TUNNEL_CAM_BIST_S8_STATUSr_CLR BCM56504_A0_L3_TUNNEL_CAM_BIST_S8_STATUSr_CLR
#define L3_TUNNEL_CAM_BIST_S8_STATUSr_SET BCM56504_A0_L3_TUNNEL_CAM_BIST_S8_STATUSr_SET
#define L3_TUNNEL_CAM_BIST_S8_STATUSr_GET BCM56504_A0_L3_TUNNEL_CAM_BIST_S8_STATUSr_GET
#define L3_TUNNEL_CAM_BIST_S8_STATUSr_MATCH_STATUSf_GET BCM56504_A0_L3_TUNNEL_CAM_BIST_S8_STATUSr_MATCH_STATUSf_GET
#define L3_TUNNEL_CAM_BIST_S8_STATUSr_MATCH_STATUSf_SET BCM56504_A0_L3_TUNNEL_CAM_BIST_S8_STATUSr_MATCH_STATUSf_SET
#define L3_TUNNEL_CAM_BIST_S8_STATUSr_AINDEX_STATUSf_GET BCM56504_A0_L3_TUNNEL_CAM_BIST_S8_STATUSr_AINDEX_STATUSf_GET
#define L3_TUNNEL_CAM_BIST_S8_STATUSr_AINDEX_STATUSf_SET BCM56504_A0_L3_TUNNEL_CAM_BIST_S8_STATUSr_AINDEX_STATUSf_SET
#define L3_TUNNEL_CAM_BIST_S8_STATUSr_ACTUAL_AINDEXf_GET BCM56504_A0_L3_TUNNEL_CAM_BIST_S8_STATUSr_ACTUAL_AINDEXf_GET
#define L3_TUNNEL_CAM_BIST_S8_STATUSr_ACTUAL_AINDEXf_SET BCM56504_A0_L3_TUNNEL_CAM_BIST_S8_STATUSr_ACTUAL_AINDEXf_SET
#define L3_TUNNEL_CAM_BIST_S8_STATUSr_EXPECTED_AINDEXf_GET BCM56504_A0_L3_TUNNEL_CAM_BIST_S8_STATUSr_EXPECTED_AINDEXf_GET
#define L3_TUNNEL_CAM_BIST_S8_STATUSr_EXPECTED_AINDEXf_SET BCM56504_A0_L3_TUNNEL_CAM_BIST_S8_STATUSr_EXPECTED_AINDEXf_SET
#define READ_L3_TUNNEL_CAM_BIST_S8_STATUSr BCM56504_A0_READ_L3_TUNNEL_CAM_BIST_S8_STATUSr
#define WRITE_L3_TUNNEL_CAM_BIST_S8_STATUSr BCM56504_A0_WRITE_L3_TUNNEL_CAM_BIST_S8_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_L3_TUNNEL_CAM_BIST_S8_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  L3_TUNNEL_CAM_BIST_STATUS
 * BLOCKS:   IPIPE_HI
 * DESC:     L3_TUNNEL_CAM_BIST_STATUS
 * SIZE:     32
 * FIELDS:
 *     BIST_GO          BIST pass/fail flag
 *     BIST_DONE        BIST completion status
 *
 ******************************************************************************/
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_STATUSr 0x02880017

#define BCM56504_A0_L3_TUNNEL_CAM_BIST_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program L3_TUNNEL_CAM_BIST_STATUS.
 *
 */
typedef union BCM56504_A0_L3_TUNNEL_CAM_BIST_STATUSr_s {
	uint32_t v[1];
	uint32_t l3_tunnel_cam_bist_status[1];
	uint32_t _l3_tunnel_cam_bist_status;
} BCM56504_A0_L3_TUNNEL_CAM_BIST_STATUSr_t;

#define BCM56504_A0_L3_TUNNEL_CAM_BIST_STATUSr_CLR(r) (r).l3_tunnel_cam_bist_status[0] = 0
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_STATUSr_SET(r,d) (r).l3_tunnel_cam_bist_status[0] = d
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_STATUSr_GET(r) (r).l3_tunnel_cam_bist_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_STATUSr_BIST_GOf_GET(r) (((r).l3_tunnel_cam_bist_status[0]) & 0x1)
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_STATUSr_BIST_GOf_SET(r,f) (r).l3_tunnel_cam_bist_status[0]=(((r).l3_tunnel_cam_bist_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_STATUSr_BIST_DONEf_GET(r) ((((r).l3_tunnel_cam_bist_status[0]) >> 1) & 0x1)
#define BCM56504_A0_L3_TUNNEL_CAM_BIST_STATUSr_BIST_DONEf_SET(r,f) (r).l3_tunnel_cam_bist_status[0]=(((r).l3_tunnel_cam_bist_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access L3_TUNNEL_CAM_BIST_STATUS.
 *
 */
#define BCM56504_A0_READ_L3_TUNNEL_CAM_BIST_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_L3_TUNNEL_CAM_BIST_STATUSr,(r._l3_tunnel_cam_bist_status))
#define BCM56504_A0_WRITE_L3_TUNNEL_CAM_BIST_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_L3_TUNNEL_CAM_BIST_STATUSr,&(r._l3_tunnel_cam_bist_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_TUNNEL_CAM_BIST_STATUSr BCM56504_A0_L3_TUNNEL_CAM_BIST_STATUSr
#define L3_TUNNEL_CAM_BIST_STATUSr_SIZE BCM56504_A0_L3_TUNNEL_CAM_BIST_STATUSr_SIZE
typedef BCM56504_A0_L3_TUNNEL_CAM_BIST_STATUSr_t L3_TUNNEL_CAM_BIST_STATUSr_t;
#define L3_TUNNEL_CAM_BIST_STATUSr_CLR BCM56504_A0_L3_TUNNEL_CAM_BIST_STATUSr_CLR
#define L3_TUNNEL_CAM_BIST_STATUSr_SET BCM56504_A0_L3_TUNNEL_CAM_BIST_STATUSr_SET
#define L3_TUNNEL_CAM_BIST_STATUSr_GET BCM56504_A0_L3_TUNNEL_CAM_BIST_STATUSr_GET
#define L3_TUNNEL_CAM_BIST_STATUSr_BIST_GOf_GET BCM56504_A0_L3_TUNNEL_CAM_BIST_STATUSr_BIST_GOf_GET
#define L3_TUNNEL_CAM_BIST_STATUSr_BIST_GOf_SET BCM56504_A0_L3_TUNNEL_CAM_BIST_STATUSr_BIST_GOf_SET
#define L3_TUNNEL_CAM_BIST_STATUSr_BIST_DONEf_GET BCM56504_A0_L3_TUNNEL_CAM_BIST_STATUSr_BIST_DONEf_GET
#define L3_TUNNEL_CAM_BIST_STATUSr_BIST_DONEf_SET BCM56504_A0_L3_TUNNEL_CAM_BIST_STATUSr_BIST_DONEf_SET
#define READ_L3_TUNNEL_CAM_BIST_STATUSr BCM56504_A0_READ_L3_TUNNEL_CAM_BIST_STATUSr
#define WRITE_L3_TUNNEL_CAM_BIST_STATUSr BCM56504_A0_WRITE_L3_TUNNEL_CAM_BIST_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_L3_TUNNEL_CAM_BIST_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  L3_TUNNEL_CAM_CONTROL
 * BLOCKS:   IPIPE_HI
 * DESC:     L3_TUNNEL_CAM_CONTROL
 * SIZE:     32
 * FIELDS:
 *     BIST_EN          BIST enable
 *     SAM              SAM debug bits
 *
 ******************************************************************************/
#define BCM56504_A0_L3_TUNNEL_CAM_CONTROLr 0x02880018

#define BCM56504_A0_L3_TUNNEL_CAM_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program L3_TUNNEL_CAM_CONTROL.
 *
 */
typedef union BCM56504_A0_L3_TUNNEL_CAM_CONTROLr_s {
	uint32_t v[1];
	uint32_t l3_tunnel_cam_control[1];
	uint32_t _l3_tunnel_cam_control;
} BCM56504_A0_L3_TUNNEL_CAM_CONTROLr_t;

#define BCM56504_A0_L3_TUNNEL_CAM_CONTROLr_CLR(r) (r).l3_tunnel_cam_control[0] = 0
#define BCM56504_A0_L3_TUNNEL_CAM_CONTROLr_SET(r,d) (r).l3_tunnel_cam_control[0] = d
#define BCM56504_A0_L3_TUNNEL_CAM_CONTROLr_GET(r) (r).l3_tunnel_cam_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_L3_TUNNEL_CAM_CONTROLr_BIST_ENf_GET(r) (((r).l3_tunnel_cam_control[0]) & 0x1)
#define BCM56504_A0_L3_TUNNEL_CAM_CONTROLr_BIST_ENf_SET(r,f) (r).l3_tunnel_cam_control[0]=(((r).l3_tunnel_cam_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_L3_TUNNEL_CAM_CONTROLr_SAMf_GET(r) ((((r).l3_tunnel_cam_control[0]) >> 1) & 0x7)
#define BCM56504_A0_L3_TUNNEL_CAM_CONTROLr_SAMf_SET(r,f) (r).l3_tunnel_cam_control[0]=(((r).l3_tunnel_cam_control[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))

/*
 * These macros can be used to access L3_TUNNEL_CAM_CONTROL.
 *
 */
#define BCM56504_A0_READ_L3_TUNNEL_CAM_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_L3_TUNNEL_CAM_CONTROLr,(r._l3_tunnel_cam_control))
#define BCM56504_A0_WRITE_L3_TUNNEL_CAM_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_L3_TUNNEL_CAM_CONTROLr,&(r._l3_tunnel_cam_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_TUNNEL_CAM_CONTROLr BCM56504_A0_L3_TUNNEL_CAM_CONTROLr
#define L3_TUNNEL_CAM_CONTROLr_SIZE BCM56504_A0_L3_TUNNEL_CAM_CONTROLr_SIZE
typedef BCM56504_A0_L3_TUNNEL_CAM_CONTROLr_t L3_TUNNEL_CAM_CONTROLr_t;
#define L3_TUNNEL_CAM_CONTROLr_CLR BCM56504_A0_L3_TUNNEL_CAM_CONTROLr_CLR
#define L3_TUNNEL_CAM_CONTROLr_SET BCM56504_A0_L3_TUNNEL_CAM_CONTROLr_SET
#define L3_TUNNEL_CAM_CONTROLr_GET BCM56504_A0_L3_TUNNEL_CAM_CONTROLr_GET
#define L3_TUNNEL_CAM_CONTROLr_BIST_ENf_GET BCM56504_A0_L3_TUNNEL_CAM_CONTROLr_BIST_ENf_GET
#define L3_TUNNEL_CAM_CONTROLr_BIST_ENf_SET BCM56504_A0_L3_TUNNEL_CAM_CONTROLr_BIST_ENf_SET
#define L3_TUNNEL_CAM_CONTROLr_SAMf_GET BCM56504_A0_L3_TUNNEL_CAM_CONTROLr_SAMf_GET
#define L3_TUNNEL_CAM_CONTROLr_SAMf_SET BCM56504_A0_L3_TUNNEL_CAM_CONTROLr_SAMf_SET
#define READ_L3_TUNNEL_CAM_CONTROLr BCM56504_A0_READ_L3_TUNNEL_CAM_CONTROLr
#define WRITE_L3_TUNNEL_CAM_CONTROLr BCM56504_A0_WRITE_L3_TUNNEL_CAM_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_L3_TUNNEL_CAM_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  LWMCOSCELLSETLIMIT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CELLSETLIMIT     In Dynamic Memory mode:This register represents the guaranteed number of CBP cells scheduled for COS n on this egress port. When LCCOUNTcrosses this limit it goes in to dynamiccell area which is shared by other COS and other ports.Dynamic Memory Mode register need to be set for this limit to be in effect.When not in Dynamic Memory Mode, This is the HOL Cell high waterthreshold for egress port packet of COS n, i.e Number of cells per egress port of COS 0.
 *     RESETLIMITSEL    In Dynamic Memory mode,HOL CELL Status Reset Threshold is defined by DYNCELLSETLIMIT registers'RESETLIMITSEL field as a pertange of low water marker. LCCOUNT for a given COS has to fall below the LWM before HOL CELLblocking is cleared.When not in Dynamic Memory mode,HOL Cell Reset Threshold for Egress Port.When in HOL condition, Cell count have to below Reset Threshold to reset HOL condition. 2'b00: 75.0% of HOL Cell Set Limit. 2'b01: 50.0% of HOL Cell Set Limit.    2'b10: 25.0% of HOL Cell Set Limit.    2'b11: 12.5% of HOL Cell Set Limit.    
 *
 ******************************************************************************/
#define BCM56504_A0_LWMCOSCELLSETLIMITr 0x00600030

#define BCM56504_A0_LWMCOSCELLSETLIMITr_SIZE 4

/*
 * This structure should be used to declare and program LWMCOSCELLSETLIMIT.
 *
 */
typedef union BCM56504_A0_LWMCOSCELLSETLIMITr_s {
	uint32_t v[1];
	uint32_t lwmcoscellsetlimit[1];
	uint32_t _lwmcoscellsetlimit;
} BCM56504_A0_LWMCOSCELLSETLIMITr_t;

#define BCM56504_A0_LWMCOSCELLSETLIMITr_CLR(r) (r).lwmcoscellsetlimit[0] = 0
#define BCM56504_A0_LWMCOSCELLSETLIMITr_SET(r,d) (r).lwmcoscellsetlimit[0] = d
#define BCM56504_A0_LWMCOSCELLSETLIMITr_GET(r) (r).lwmcoscellsetlimit[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_LWMCOSCELLSETLIMITr_CELLSETLIMITf_GET(r) (((r).lwmcoscellsetlimit[0]) & 0x3fff)
#define BCM56504_A0_LWMCOSCELLSETLIMITr_CELLSETLIMITf_SET(r,f) (r).lwmcoscellsetlimit[0]=(((r).lwmcoscellsetlimit[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM56504_A0_LWMCOSCELLSETLIMITr_RESETLIMITSELf_GET(r) ((((r).lwmcoscellsetlimit[0]) >> 14) & 0x3)
#define BCM56504_A0_LWMCOSCELLSETLIMITr_RESETLIMITSELf_SET(r,f) (r).lwmcoscellsetlimit[0]=(((r).lwmcoscellsetlimit[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))

/*
 * These macros can be used to access LWMCOSCELLSETLIMIT.
 *
 */
#define BCM56504_A0_READ_LWMCOSCELLSETLIMITr(u,p,i,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_LWMCOSCELLSETLIMITr+(i),(r._lwmcoscellsetlimit))
#define BCM56504_A0_WRITE_LWMCOSCELLSETLIMITr(u,p,i,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_LWMCOSCELLSETLIMITr+(i),&(r._lwmcoscellsetlimit))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LWMCOSCELLSETLIMITr BCM56504_A0_LWMCOSCELLSETLIMITr
#define LWMCOSCELLSETLIMITr_SIZE BCM56504_A0_LWMCOSCELLSETLIMITr_SIZE
typedef BCM56504_A0_LWMCOSCELLSETLIMITr_t LWMCOSCELLSETLIMITr_t;
#define LWMCOSCELLSETLIMITr_CLR BCM56504_A0_LWMCOSCELLSETLIMITr_CLR
#define LWMCOSCELLSETLIMITr_SET BCM56504_A0_LWMCOSCELLSETLIMITr_SET
#define LWMCOSCELLSETLIMITr_GET BCM56504_A0_LWMCOSCELLSETLIMITr_GET
#define LWMCOSCELLSETLIMITr_CELLSETLIMITf_GET BCM56504_A0_LWMCOSCELLSETLIMITr_CELLSETLIMITf_GET
#define LWMCOSCELLSETLIMITr_CELLSETLIMITf_SET BCM56504_A0_LWMCOSCELLSETLIMITr_CELLSETLIMITf_SET
#define LWMCOSCELLSETLIMITr_RESETLIMITSELf_GET BCM56504_A0_LWMCOSCELLSETLIMITr_RESETLIMITSELf_GET
#define LWMCOSCELLSETLIMITr_RESETLIMITSELf_SET BCM56504_A0_LWMCOSCELLSETLIMITr_RESETLIMITSELf_SET
#define READ_LWMCOSCELLSETLIMITr BCM56504_A0_READ_LWMCOSCELLSETLIMITr
#define WRITE_LWMCOSCELLSETLIMITr BCM56504_A0_WRITE_LWMCOSCELLSETLIMITr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_LWMCOSCELLSETLIMITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  MAC_BLOCK
 * BLOCKS:   IPIPE
 * DESC:     Source Trunk Bitmap Table
 * SIZE:     29
 * FIELDS:
 *     MAC_BLOCK_MASK   MAC block mask
 *
 ******************************************************************************/
#define BCM56504_A0_MAC_BLOCKm 0x0e740000

#define BCM56504_A0_MAC_BLOCKm_MIN 0
#define BCM56504_A0_MAC_BLOCKm_MAX 31
#define BCM56504_A0_MAC_BLOCKm_CMAX(u) 31
#define BCM56504_A0_MAC_BLOCKm_SIZE 4

/*
 * This structure should be used to declare and program MAC_BLOCK.
 *
 */
typedef union BCM56504_A0_MAC_BLOCKm_s {
	uint32_t v[1];
	uint32_t mac_block[1];
	uint32_t _mac_block;
} BCM56504_A0_MAC_BLOCKm_t;

#define BCM56504_A0_MAC_BLOCKm_CLR(r) (r).mac_block[0] = 0
#define BCM56504_A0_MAC_BLOCKm_SET(r,d) (r).mac_block[0] = d
#define BCM56504_A0_MAC_BLOCKm_GET(r) (r).mac_block[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MAC_BLOCKm_MAC_BLOCK_MASKf_GET(r) (((r).mac_block[0]) & 0x1fffffff)
#define BCM56504_A0_MAC_BLOCKm_MAC_BLOCK_MASKf_SET(r,f) (r).mac_block[0]=(((r).mac_block[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))

/*
 * These macros can be used to access MAC_BLOCK.
 *
 */
#define BCM56504_A0_READ_MAC_BLOCKm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_MAC_BLOCKm,i,(m._mac_block),1)
#define BCM56504_A0_WRITE_MAC_BLOCKm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_MAC_BLOCKm,i,&(m._mac_block),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAC_BLOCKm BCM56504_A0_MAC_BLOCKm
#define MAC_BLOCKm_MIN BCM56504_A0_MAC_BLOCKm_MIN
#define MAC_BLOCKm_MAX BCM56504_A0_MAC_BLOCKm_MAX
#define MAC_BLOCKm_CMAX(u) BCM56504_A0_MAC_BLOCKm_CMAX(u)
#define MAC_BLOCKm_SIZE BCM56504_A0_MAC_BLOCKm_SIZE
typedef BCM56504_A0_MAC_BLOCKm_t MAC_BLOCKm_t;
#define MAC_BLOCKm_CLR BCM56504_A0_MAC_BLOCKm_CLR
#define MAC_BLOCKm_SET BCM56504_A0_MAC_BLOCKm_SET
#define MAC_BLOCKm_GET BCM56504_A0_MAC_BLOCKm_GET
#define MAC_BLOCKm_MAC_BLOCK_MASKf_GET BCM56504_A0_MAC_BLOCKm_MAC_BLOCK_MASKf_GET
#define MAC_BLOCKm_MAC_BLOCK_MASKf_SET BCM56504_A0_MAC_BLOCKm_MAC_BLOCK_MASKf_SET
#define READ_MAC_BLOCKm BCM56504_A0_READ_MAC_BLOCKm
#define WRITE_MAC_BLOCKm BCM56504_A0_WRITE_MAC_BLOCKm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MAC_BLOCKm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  MAC_CntMaxSz
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Max size packet for counter increment
 * SIZE:     64
 * FIELDS:
 *     SZ               Maximum size of packet received/transmitted that will increment,if appropriate, IRMCA, IRBCA, IRFCS, IRXCF, IRXPF, IRXUO, IROVR, IRJBR,ITMCA, ITBCA, ITFCS, ITXPF, ITOVR
 *
 ******************************************************************************/
#define BCM56504_A0_MAC_CNTMAXSZr 0x00f00005

#define BCM56504_A0_MAC_CNTMAXSZr_SIZE 8

/*
 * This structure should be used to declare and program MAC_CntMaxSz.
 *
 */
typedef union BCM56504_A0_MAC_CNTMAXSZr_s {
	uint32_t v[2];
	uint32_t mac_cntmaxsz[2];
	uint32_t _mac_cntmaxsz;
} BCM56504_A0_MAC_CNTMAXSZr_t;

#define BCM56504_A0_MAC_CNTMAXSZr_CLR(r) CDK_MEMSET(&((r)._mac_cntmaxsz), 0, sizeof(BCM56504_A0_MAC_CNTMAXSZr_t))
#define BCM56504_A0_MAC_CNTMAXSZr_SET(r,i,d) (r).mac_cntmaxsz[i] = d
#define BCM56504_A0_MAC_CNTMAXSZr_GET(r,i) (r).mac_cntmaxsz[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MAC_CNTMAXSZr_SZf_GET(r) (((r).mac_cntmaxsz[0]) & 0x3fff)
#define BCM56504_A0_MAC_CNTMAXSZr_SZf_SET(r,f) (r).mac_cntmaxsz[0]=(((r).mac_cntmaxsz[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access MAC_CntMaxSz.
 *
 */
#define BCM56504_A0_READ_MAC_CNTMAXSZr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_MAC_CNTMAXSZr,(r._mac_cntmaxsz))
#define BCM56504_A0_WRITE_MAC_CNTMAXSZr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_MAC_CNTMAXSZr,&(r._mac_cntmaxsz))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAC_CNTMAXSZr BCM56504_A0_MAC_CNTMAXSZr
#define MAC_CNTMAXSZr_SIZE BCM56504_A0_MAC_CNTMAXSZr_SIZE
typedef BCM56504_A0_MAC_CNTMAXSZr_t MAC_CNTMAXSZr_t;
#define MAC_CNTMAXSZr_CLR BCM56504_A0_MAC_CNTMAXSZr_CLR
#define MAC_CNTMAXSZr_SET BCM56504_A0_MAC_CNTMAXSZr_SET
#define MAC_CNTMAXSZr_GET BCM56504_A0_MAC_CNTMAXSZr_GET
#define MAC_CNTMAXSZr_SZf_GET BCM56504_A0_MAC_CNTMAXSZr_SZf_GET
#define MAC_CNTMAXSZr_SZf_SET BCM56504_A0_MAC_CNTMAXSZr_SZf_SET
#define READ_MAC_CNTMAXSZr BCM56504_A0_READ_MAC_CNTMAXSZr
#define WRITE_MAC_CNTMAXSZr BCM56504_A0_WRITE_MAC_CNTMAXSZr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MAC_CNTMAXSZr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  MAC_CoreSpare0
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Spare reg for ECO on core clock domain
 * SIZE:     64
 * FIELDS:
 *     RSVD             SPARE REGISTERS 0
 *
 ******************************************************************************/
#define BCM56504_A0_MAC_CORESPARE0r 0x00f00006

#define BCM56504_A0_MAC_CORESPARE0r_SIZE 8

/*
 * This structure should be used to declare and program MAC_CoreSpare0.
 *
 */
typedef union BCM56504_A0_MAC_CORESPARE0r_s {
	uint32_t v[2];
	uint32_t mac_corespare0[2];
	uint32_t _mac_corespare0;
} BCM56504_A0_MAC_CORESPARE0r_t;

#define BCM56504_A0_MAC_CORESPARE0r_CLR(r) CDK_MEMSET(&((r)._mac_corespare0), 0, sizeof(BCM56504_A0_MAC_CORESPARE0r_t))
#define BCM56504_A0_MAC_CORESPARE0r_SET(r,i,d) (r).mac_corespare0[i] = d
#define BCM56504_A0_MAC_CORESPARE0r_GET(r,i) (r).mac_corespare0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MAC_CORESPARE0r_RSVDf_GET(r) ((r).mac_corespare0[0])
#define BCM56504_A0_MAC_CORESPARE0r_RSVDf_SET(r,f) (r).mac_corespare0[0]=((uint32_t)f)

/*
 * These macros can be used to access MAC_CoreSpare0.
 *
 */
#define BCM56504_A0_READ_MAC_CORESPARE0r(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_MAC_CORESPARE0r,(r._mac_corespare0))
#define BCM56504_A0_WRITE_MAC_CORESPARE0r(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_MAC_CORESPARE0r,&(r._mac_corespare0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAC_CORESPARE0r BCM56504_A0_MAC_CORESPARE0r
#define MAC_CORESPARE0r_SIZE BCM56504_A0_MAC_CORESPARE0r_SIZE
typedef BCM56504_A0_MAC_CORESPARE0r_t MAC_CORESPARE0r_t;
#define MAC_CORESPARE0r_CLR BCM56504_A0_MAC_CORESPARE0r_CLR
#define MAC_CORESPARE0r_SET BCM56504_A0_MAC_CORESPARE0r_SET
#define MAC_CORESPARE0r_GET BCM56504_A0_MAC_CORESPARE0r_GET
#define MAC_CORESPARE0r_RSVDf_GET BCM56504_A0_MAC_CORESPARE0r_RSVDf_GET
#define MAC_CORESPARE0r_RSVDf_SET BCM56504_A0_MAC_CORESPARE0r_RSVDf_SET
#define READ_MAC_CORESPARE0r BCM56504_A0_READ_MAC_CORESPARE0r
#define WRITE_MAC_CORESPARE0r BCM56504_A0_WRITE_MAC_CORESPARE0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MAC_CORESPARE0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  MAC_Ctrl
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     MAC control.
 * SIZE:     64
 * FIELDS:
 *     TXEN             Transmit enable.
 *     RXEN             Receive enable.
 *     LCLLOOP          Local loopback mode from the Tx FIFO to the Rx FIFO.
 *     RMTLOOP          Remote loopback mode from the XGMII receive to XGMII transmit.
 *
 ******************************************************************************/
#define BCM56504_A0_MAC_CTRLr 0x00f00000

#define BCM56504_A0_MAC_CTRLr_SIZE 8

/*
 * This structure should be used to declare and program MAC_Ctrl.
 *
 */
typedef union BCM56504_A0_MAC_CTRLr_s {
	uint32_t v[2];
	uint32_t mac_ctrl[2];
	uint32_t _mac_ctrl;
} BCM56504_A0_MAC_CTRLr_t;

#define BCM56504_A0_MAC_CTRLr_CLR(r) CDK_MEMSET(&((r)._mac_ctrl), 0, sizeof(BCM56504_A0_MAC_CTRLr_t))
#define BCM56504_A0_MAC_CTRLr_SET(r,i,d) (r).mac_ctrl[i] = d
#define BCM56504_A0_MAC_CTRLr_GET(r,i) (r).mac_ctrl[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MAC_CTRLr_TXENf_GET(r) (((r).mac_ctrl[0]) & 0x1)
#define BCM56504_A0_MAC_CTRLr_TXENf_SET(r,f) (r).mac_ctrl[0]=(((r).mac_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_MAC_CTRLr_RXENf_GET(r) ((((r).mac_ctrl[0]) >> 1) & 0x1)
#define BCM56504_A0_MAC_CTRLr_RXENf_SET(r,f) (r).mac_ctrl[0]=(((r).mac_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_MAC_CTRLr_LCLLOOPf_GET(r) ((((r).mac_ctrl[0]) >> 2) & 0x1)
#define BCM56504_A0_MAC_CTRLr_LCLLOOPf_SET(r,f) (r).mac_ctrl[0]=(((r).mac_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_MAC_CTRLr_RMTLOOPf_GET(r) ((((r).mac_ctrl[0]) >> 3) & 0x1)
#define BCM56504_A0_MAC_CTRLr_RMTLOOPf_SET(r,f) (r).mac_ctrl[0]=(((r).mac_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))

/*
 * These macros can be used to access MAC_Ctrl.
 *
 */
#define BCM56504_A0_READ_MAC_CTRLr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_MAC_CTRLr,(r._mac_ctrl))
#define BCM56504_A0_WRITE_MAC_CTRLr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_MAC_CTRLr,&(r._mac_ctrl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAC_CTRLr BCM56504_A0_MAC_CTRLr
#define MAC_CTRLr_SIZE BCM56504_A0_MAC_CTRLr_SIZE
typedef BCM56504_A0_MAC_CTRLr_t MAC_CTRLr_t;
#define MAC_CTRLr_CLR BCM56504_A0_MAC_CTRLr_CLR
#define MAC_CTRLr_SET BCM56504_A0_MAC_CTRLr_SET
#define MAC_CTRLr_GET BCM56504_A0_MAC_CTRLr_GET
#define MAC_CTRLr_TXENf_GET BCM56504_A0_MAC_CTRLr_TXENf_GET
#define MAC_CTRLr_TXENf_SET BCM56504_A0_MAC_CTRLr_TXENf_SET
#define MAC_CTRLr_RXENf_GET BCM56504_A0_MAC_CTRLr_RXENf_GET
#define MAC_CTRLr_RXENf_SET BCM56504_A0_MAC_CTRLr_RXENf_SET
#define MAC_CTRLr_LCLLOOPf_GET BCM56504_A0_MAC_CTRLr_LCLLOOPf_GET
#define MAC_CTRLr_LCLLOOPf_SET BCM56504_A0_MAC_CTRLr_LCLLOOPf_SET
#define MAC_CTRLr_RMTLOOPf_GET BCM56504_A0_MAC_CTRLr_RMTLOOPf_GET
#define MAC_CTRLr_RMTLOOPf_SET BCM56504_A0_MAC_CTRLr_RMTLOOPf_SET
#define READ_MAC_CTRLr BCM56504_A0_READ_MAC_CTRLr
#define WRITE_MAC_CTRLr BCM56504_A0_WRITE_MAC_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MAC_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  MAC_RxCtrl
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Receive control.
 * SIZE:     64
 * FIELDS:
 *     HDRMODE          Header mode.
 *     STRIPCRC         CRC is checked, then stripped from the packet received.
 *     IGNORECRC        CRC errors are ignored.
 *     STRICTPRMBL      Preamble is set to IEEE Ethernet format.
 *     RXPAUSEN         Received PAUSE packets will inhibit transmission.
 *     RXPASSCTRL       Mac Control packets are passed to the system.
 *     ANYSTART         True to allow any non-Idle character to start a packet.  False to require /Start per XGMII spec 
 *
 ******************************************************************************/
#define BCM56504_A0_MAC_RXCTRLr 0x00f00021

#define BCM56504_A0_MAC_RXCTRLr_SIZE 8

/*
 * This structure should be used to declare and program MAC_RxCtrl.
 *
 */
typedef union BCM56504_A0_MAC_RXCTRLr_s {
	uint32_t v[2];
	uint32_t mac_rxctrl[2];
	uint32_t _mac_rxctrl;
} BCM56504_A0_MAC_RXCTRLr_t;

#define BCM56504_A0_MAC_RXCTRLr_CLR(r) CDK_MEMSET(&((r)._mac_rxctrl), 0, sizeof(BCM56504_A0_MAC_RXCTRLr_t))
#define BCM56504_A0_MAC_RXCTRLr_SET(r,i,d) (r).mac_rxctrl[i] = d
#define BCM56504_A0_MAC_RXCTRLr_GET(r,i) (r).mac_rxctrl[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MAC_RXCTRLr_HDRMODEf_GET(r) (((r).mac_rxctrl[0]) & 0x3)
#define BCM56504_A0_MAC_RXCTRLr_HDRMODEf_SET(r,f) (r).mac_rxctrl[0]=(((r).mac_rxctrl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56504_A0_MAC_RXCTRLr_STRIPCRCf_GET(r) ((((r).mac_rxctrl[0]) >> 2) & 0x1)
#define BCM56504_A0_MAC_RXCTRLr_STRIPCRCf_SET(r,f) (r).mac_rxctrl[0]=(((r).mac_rxctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_MAC_RXCTRLr_IGNORECRCf_GET(r) ((((r).mac_rxctrl[0]) >> 3) & 0x1)
#define BCM56504_A0_MAC_RXCTRLr_IGNORECRCf_SET(r,f) (r).mac_rxctrl[0]=(((r).mac_rxctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_MAC_RXCTRLr_STRICTPRMBLf_GET(r) ((((r).mac_rxctrl[0]) >> 4) & 0x1)
#define BCM56504_A0_MAC_RXCTRLr_STRICTPRMBLf_SET(r,f) (r).mac_rxctrl[0]=(((r).mac_rxctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56504_A0_MAC_RXCTRLr_RXPAUSENf_GET(r) ((((r).mac_rxctrl[0]) >> 5) & 0x1)
#define BCM56504_A0_MAC_RXCTRLr_RXPAUSENf_SET(r,f) (r).mac_rxctrl[0]=(((r).mac_rxctrl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56504_A0_MAC_RXCTRLr_RXPASSCTRLf_GET(r) ((((r).mac_rxctrl[0]) >> 6) & 0x1)
#define BCM56504_A0_MAC_RXCTRLr_RXPASSCTRLf_SET(r,f) (r).mac_rxctrl[0]=(((r).mac_rxctrl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56504_A0_MAC_RXCTRLr_ANYSTARTf_GET(r) ((((r).mac_rxctrl[0]) >> 7) & 0x1)
#define BCM56504_A0_MAC_RXCTRLr_ANYSTARTf_SET(r,f) (r).mac_rxctrl[0]=(((r).mac_rxctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access MAC_RxCtrl.
 *
 */
#define BCM56504_A0_READ_MAC_RXCTRLr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_MAC_RXCTRLr,(r._mac_rxctrl))
#define BCM56504_A0_WRITE_MAC_RXCTRLr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_MAC_RXCTRLr,&(r._mac_rxctrl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAC_RXCTRLr BCM56504_A0_MAC_RXCTRLr
#define MAC_RXCTRLr_SIZE BCM56504_A0_MAC_RXCTRLr_SIZE
typedef BCM56504_A0_MAC_RXCTRLr_t MAC_RXCTRLr_t;
#define MAC_RXCTRLr_CLR BCM56504_A0_MAC_RXCTRLr_CLR
#define MAC_RXCTRLr_SET BCM56504_A0_MAC_RXCTRLr_SET
#define MAC_RXCTRLr_GET BCM56504_A0_MAC_RXCTRLr_GET
#define MAC_RXCTRLr_HDRMODEf_GET BCM56504_A0_MAC_RXCTRLr_HDRMODEf_GET
#define MAC_RXCTRLr_HDRMODEf_SET BCM56504_A0_MAC_RXCTRLr_HDRMODEf_SET
#define MAC_RXCTRLr_STRIPCRCf_GET BCM56504_A0_MAC_RXCTRLr_STRIPCRCf_GET
#define MAC_RXCTRLr_STRIPCRCf_SET BCM56504_A0_MAC_RXCTRLr_STRIPCRCf_SET
#define MAC_RXCTRLr_IGNORECRCf_GET BCM56504_A0_MAC_RXCTRLr_IGNORECRCf_GET
#define MAC_RXCTRLr_IGNORECRCf_SET BCM56504_A0_MAC_RXCTRLr_IGNORECRCf_SET
#define MAC_RXCTRLr_STRICTPRMBLf_GET BCM56504_A0_MAC_RXCTRLr_STRICTPRMBLf_GET
#define MAC_RXCTRLr_STRICTPRMBLf_SET BCM56504_A0_MAC_RXCTRLr_STRICTPRMBLf_SET
#define MAC_RXCTRLr_RXPAUSENf_GET BCM56504_A0_MAC_RXCTRLr_RXPAUSENf_GET
#define MAC_RXCTRLr_RXPAUSENf_SET BCM56504_A0_MAC_RXCTRLr_RXPAUSENf_SET
#define MAC_RXCTRLr_RXPASSCTRLf_GET BCM56504_A0_MAC_RXCTRLr_RXPASSCTRLf_GET
#define MAC_RXCTRLr_RXPASSCTRLf_SET BCM56504_A0_MAC_RXCTRLr_RXPASSCTRLf_SET
#define MAC_RXCTRLr_ANYSTARTf_GET BCM56504_A0_MAC_RXCTRLr_ANYSTARTf_GET
#define MAC_RXCTRLr_ANYSTARTf_SET BCM56504_A0_MAC_RXCTRLr_ANYSTARTf_SET
#define READ_MAC_RXCTRLr BCM56504_A0_READ_MAC_RXCTRLr
#define WRITE_MAC_RXCTRLr BCM56504_A0_WRITE_MAC_RXCTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MAC_RXCTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  MAC_RxLSSCtrl
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Control for LSS (ordered set) messages
 * SIZE:     64
 * FIELDS:
 *     LOCALFAULTDISABLE True to disable enable processing of LSS message type: Local Fault.When clear and a local fault LSS message is received, a continuousstream of "Remote Fault" LSS messages will be transmitted to thelink partner.
 *     REMOTEFAULTDISABLE True to disable processing of LSS message type: Remote Fault.When clear and a remote fault LSS message is received, a continuousstream of IDLES will be transmitted to the link partner.
 *
 ******************************************************************************/
#define BCM56504_A0_MAC_RXLSSCTRLr 0x00f00024

#define BCM56504_A0_MAC_RXLSSCTRLr_SIZE 8

/*
 * This structure should be used to declare and program MAC_RxLSSCtrl.
 *
 */
typedef union BCM56504_A0_MAC_RXLSSCTRLr_s {
	uint32_t v[2];
	uint32_t mac_rxlssctrl[2];
	uint32_t _mac_rxlssctrl;
} BCM56504_A0_MAC_RXLSSCTRLr_t;

#define BCM56504_A0_MAC_RXLSSCTRLr_CLR(r) CDK_MEMSET(&((r)._mac_rxlssctrl), 0, sizeof(BCM56504_A0_MAC_RXLSSCTRLr_t))
#define BCM56504_A0_MAC_RXLSSCTRLr_SET(r,i,d) (r).mac_rxlssctrl[i] = d
#define BCM56504_A0_MAC_RXLSSCTRLr_GET(r,i) (r).mac_rxlssctrl[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MAC_RXLSSCTRLr_LOCALFAULTDISABLEf_GET(r) (((r).mac_rxlssctrl[0]) & 0x1)
#define BCM56504_A0_MAC_RXLSSCTRLr_LOCALFAULTDISABLEf_SET(r,f) (r).mac_rxlssctrl[0]=(((r).mac_rxlssctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_MAC_RXLSSCTRLr_REMOTEFAULTDISABLEf_GET(r) ((((r).mac_rxlssctrl[0]) >> 1) & 0x1)
#define BCM56504_A0_MAC_RXLSSCTRLr_REMOTEFAULTDISABLEf_SET(r,f) (r).mac_rxlssctrl[0]=(((r).mac_rxlssctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access MAC_RxLSSCtrl.
 *
 */
#define BCM56504_A0_READ_MAC_RXLSSCTRLr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_MAC_RXLSSCTRLr,(r._mac_rxlssctrl))
#define BCM56504_A0_WRITE_MAC_RXLSSCTRLr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_MAC_RXLSSCTRLr,&(r._mac_rxlssctrl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAC_RXLSSCTRLr BCM56504_A0_MAC_RXLSSCTRLr
#define MAC_RXLSSCTRLr_SIZE BCM56504_A0_MAC_RXLSSCTRLr_SIZE
typedef BCM56504_A0_MAC_RXLSSCTRLr_t MAC_RXLSSCTRLr_t;
#define MAC_RXLSSCTRLr_CLR BCM56504_A0_MAC_RXLSSCTRLr_CLR
#define MAC_RXLSSCTRLr_SET BCM56504_A0_MAC_RXLSSCTRLr_SET
#define MAC_RXLSSCTRLr_GET BCM56504_A0_MAC_RXLSSCTRLr_GET
#define MAC_RXLSSCTRLr_LOCALFAULTDISABLEf_GET BCM56504_A0_MAC_RXLSSCTRLr_LOCALFAULTDISABLEf_GET
#define MAC_RXLSSCTRLr_LOCALFAULTDISABLEf_SET BCM56504_A0_MAC_RXLSSCTRLr_LOCALFAULTDISABLEf_SET
#define MAC_RXLSSCTRLr_REMOTEFAULTDISABLEf_GET BCM56504_A0_MAC_RXLSSCTRLr_REMOTEFAULTDISABLEf_GET
#define MAC_RXLSSCTRLr_REMOTEFAULTDISABLEf_SET BCM56504_A0_MAC_RXLSSCTRLr_REMOTEFAULTDISABLEf_SET
#define READ_MAC_RXLSSCTRLr BCM56504_A0_READ_MAC_RXLSSCTRLr
#define WRITE_MAC_RXLSSCTRLr BCM56504_A0_WRITE_MAC_RXLSSCTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MAC_RXLSSCTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  MAC_RxLSSStat
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Status for LSS (ordered set) messages
 * SIZE:     64
 * FIELDS:
 *     LOCALFAULTSTAT   True while "local fault" LSS messages are being received
 *     REMOTEFAULTSTAT  True while "remote fault" LSS messages are being received
 *
 ******************************************************************************/
#define BCM56504_A0_MAC_RXLSSSTATr 0x00f00043

#define BCM56504_A0_MAC_RXLSSSTATr_SIZE 8

/*
 * This structure should be used to declare and program MAC_RxLSSStat.
 *
 */
typedef union BCM56504_A0_MAC_RXLSSSTATr_s {
	uint32_t v[2];
	uint32_t mac_rxlssstat[2];
	uint32_t _mac_rxlssstat;
} BCM56504_A0_MAC_RXLSSSTATr_t;

#define BCM56504_A0_MAC_RXLSSSTATr_CLR(r) CDK_MEMSET(&((r)._mac_rxlssstat), 0, sizeof(BCM56504_A0_MAC_RXLSSSTATr_t))
#define BCM56504_A0_MAC_RXLSSSTATr_SET(r,i,d) (r).mac_rxlssstat[i] = d
#define BCM56504_A0_MAC_RXLSSSTATr_GET(r,i) (r).mac_rxlssstat[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MAC_RXLSSSTATr_LOCALFAULTSTATf_GET(r) (((r).mac_rxlssstat[0]) & 0x1)
#define BCM56504_A0_MAC_RXLSSSTATr_LOCALFAULTSTATf_SET(r,f) (r).mac_rxlssstat[0]=(((r).mac_rxlssstat[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_MAC_RXLSSSTATr_REMOTEFAULTSTATf_GET(r) ((((r).mac_rxlssstat[0]) >> 1) & 0x1)
#define BCM56504_A0_MAC_RXLSSSTATr_REMOTEFAULTSTATf_SET(r,f) (r).mac_rxlssstat[0]=(((r).mac_rxlssstat[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access MAC_RxLSSStat.
 *
 */
#define BCM56504_A0_READ_MAC_RXLSSSTATr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_MAC_RXLSSSTATr,(r._mac_rxlssstat))
#define BCM56504_A0_WRITE_MAC_RXLSSSTATr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_MAC_RXLSSSTATr,&(r._mac_rxlssstat))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAC_RXLSSSTATr BCM56504_A0_MAC_RXLSSSTATr
#define MAC_RXLSSSTATr_SIZE BCM56504_A0_MAC_RXLSSSTATr_SIZE
typedef BCM56504_A0_MAC_RXLSSSTATr_t MAC_RXLSSSTATr_t;
#define MAC_RXLSSSTATr_CLR BCM56504_A0_MAC_RXLSSSTATr_CLR
#define MAC_RXLSSSTATr_SET BCM56504_A0_MAC_RXLSSSTATr_SET
#define MAC_RXLSSSTATr_GET BCM56504_A0_MAC_RXLSSSTATr_GET
#define MAC_RXLSSSTATr_LOCALFAULTSTATf_GET BCM56504_A0_MAC_RXLSSSTATr_LOCALFAULTSTATf_GET
#define MAC_RXLSSSTATr_LOCALFAULTSTATf_SET BCM56504_A0_MAC_RXLSSSTATr_LOCALFAULTSTATf_SET
#define MAC_RXLSSSTATr_REMOTEFAULTSTATf_GET BCM56504_A0_MAC_RXLSSSTATr_REMOTEFAULTSTATf_GET
#define MAC_RXLSSSTATr_REMOTEFAULTSTATf_SET BCM56504_A0_MAC_RXLSSSTATr_REMOTEFAULTSTATf_SET
#define READ_MAC_RXLSSSTATr BCM56504_A0_READ_MAC_RXLSSSTATr
#define WRITE_MAC_RXLSSSTATr BCM56504_A0_WRITE_MAC_RXLSSSTATr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MAC_RXLSSSTATr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  MAC_RxMACSA
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Receive source address.
 * SIZE:     64
 * FIELDS:
 *     SA               SA recognized for MAC control packets in addition to the standard 0x0180C2000001. 
 *
 ******************************************************************************/
#define BCM56504_A0_MAC_RXMACSAr 0x00f00022

#define BCM56504_A0_MAC_RXMACSAr_SIZE 8

/*
 * This structure should be used to declare and program MAC_RxMACSA.
 *
 */
typedef union BCM56504_A0_MAC_RXMACSAr_s {
	uint32_t v[2];
	uint32_t mac_rxmacsa[2];
	uint32_t _mac_rxmacsa;
} BCM56504_A0_MAC_RXMACSAr_t;

#define BCM56504_A0_MAC_RXMACSAr_CLR(r) CDK_MEMSET(&((r)._mac_rxmacsa), 0, sizeof(BCM56504_A0_MAC_RXMACSAr_t))
#define BCM56504_A0_MAC_RXMACSAr_SET(r,i,d) (r).mac_rxmacsa[i] = d
#define BCM56504_A0_MAC_RXMACSAr_GET(r,i) (r).mac_rxmacsa[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MAC_RXMACSAr_SAf_GET(r,a) cdk_field_get((r).mac_rxmacsa,0,47,a)
#define BCM56504_A0_MAC_RXMACSAr_SAf_SET(r,a) cdk_field_set((r).mac_rxmacsa,0,47,a)

/*
 * These macros can be used to access MAC_RxMACSA.
 *
 */
#define BCM56504_A0_READ_MAC_RXMACSAr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_MAC_RXMACSAr,(r._mac_rxmacsa))
#define BCM56504_A0_WRITE_MAC_RXMACSAr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_MAC_RXMACSAr,&(r._mac_rxmacsa))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAC_RXMACSAr BCM56504_A0_MAC_RXMACSAr
#define MAC_RXMACSAr_SIZE BCM56504_A0_MAC_RXMACSAr_SIZE
typedef BCM56504_A0_MAC_RXMACSAr_t MAC_RXMACSAr_t;
#define MAC_RXMACSAr_CLR BCM56504_A0_MAC_RXMACSAr_CLR
#define MAC_RXMACSAr_SET BCM56504_A0_MAC_RXMACSAr_SET
#define MAC_RXMACSAr_GET BCM56504_A0_MAC_RXMACSAr_GET
#define MAC_RXMACSAr_SAf_GET BCM56504_A0_MAC_RXMACSAr_SAf_GET
#define MAC_RXMACSAr_SAf_SET BCM56504_A0_MAC_RXMACSAr_SAf_SET
#define READ_MAC_RXMACSAr BCM56504_A0_READ_MAC_RXMACSAr
#define WRITE_MAC_RXMACSAr BCM56504_A0_WRITE_MAC_RXMACSAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MAC_RXMACSAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  MAC_RxMaxSz
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Receive maximum packet size.
 * SIZE:     64
 * FIELDS:
 *     SZ               Maximum byte size of packet received by the MAC.Legal range is 64 to 16360 inclusive.Does not include preamble in IEEE mode or CRC in STRIP mode.
 *
 ******************************************************************************/
#define BCM56504_A0_MAC_RXMAXSZr 0x00f00023

#define BCM56504_A0_MAC_RXMAXSZr_SIZE 8

/*
 * This structure should be used to declare and program MAC_RxMaxSz.
 *
 */
typedef union BCM56504_A0_MAC_RXMAXSZr_s {
	uint32_t v[2];
	uint32_t mac_rxmaxsz[2];
	uint32_t _mac_rxmaxsz;
} BCM56504_A0_MAC_RXMAXSZr_t;

#define BCM56504_A0_MAC_RXMAXSZr_CLR(r) CDK_MEMSET(&((r)._mac_rxmaxsz), 0, sizeof(BCM56504_A0_MAC_RXMAXSZr_t))
#define BCM56504_A0_MAC_RXMAXSZr_SET(r,i,d) (r).mac_rxmaxsz[i] = d
#define BCM56504_A0_MAC_RXMAXSZr_GET(r,i) (r).mac_rxmaxsz[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MAC_RXMAXSZr_SZf_GET(r) (((r).mac_rxmaxsz[0]) & 0x3fff)
#define BCM56504_A0_MAC_RXMAXSZr_SZf_SET(r,f) (r).mac_rxmaxsz[0]=(((r).mac_rxmaxsz[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access MAC_RxMaxSz.
 *
 */
#define BCM56504_A0_READ_MAC_RXMAXSZr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_MAC_RXMAXSZr,(r._mac_rxmaxsz))
#define BCM56504_A0_WRITE_MAC_RXMAXSZr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_MAC_RXMAXSZr,&(r._mac_rxmaxsz))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAC_RXMAXSZr BCM56504_A0_MAC_RXMAXSZr
#define MAC_RXMAXSZr_SIZE BCM56504_A0_MAC_RXMAXSZr_SIZE
typedef BCM56504_A0_MAC_RXMAXSZr_t MAC_RXMAXSZr_t;
#define MAC_RXMAXSZr_CLR BCM56504_A0_MAC_RXMAXSZr_CLR
#define MAC_RXMAXSZr_SET BCM56504_A0_MAC_RXMAXSZr_SET
#define MAC_RXMAXSZr_GET BCM56504_A0_MAC_RXMAXSZr_GET
#define MAC_RXMAXSZr_SZf_GET BCM56504_A0_MAC_RXMAXSZr_SZf_GET
#define MAC_RXMAXSZr_SZf_SET BCM56504_A0_MAC_RXMAXSZr_SZf_SET
#define READ_MAC_RXMAXSZr BCM56504_A0_READ_MAC_RXMAXSZr
#define WRITE_MAC_RXMAXSZr BCM56504_A0_WRITE_MAC_RXMAXSZr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MAC_RXMAXSZr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  MAC_RxMuxCtrl
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Receive test mux control.
 * SIZE:     64
 * FIELDS:
 *     EN               Drive muxed Rx data.
 *     PASSTHRU         Drive rxmux_data_out and rxmux_clk_out from rxmux_data_in and rxmux_clk_in. 
 *     LANE             Selects which lane to output.
 *     TSTMUX           Pass test mux bits from XGXS_IP core on high lane of the Rx mux chain.
 *
 ******************************************************************************/
#define BCM56504_A0_MAC_RXMUXCTRLr 0x00f00004

#define BCM56504_A0_MAC_RXMUXCTRLr_SIZE 8

/*
 * This structure should be used to declare and program MAC_RxMuxCtrl.
 *
 */
typedef union BCM56504_A0_MAC_RXMUXCTRLr_s {
	uint32_t v[2];
	uint32_t mac_rxmuxctrl[2];
	uint32_t _mac_rxmuxctrl;
} BCM56504_A0_MAC_RXMUXCTRLr_t;

#define BCM56504_A0_MAC_RXMUXCTRLr_CLR(r) CDK_MEMSET(&((r)._mac_rxmuxctrl), 0, sizeof(BCM56504_A0_MAC_RXMUXCTRLr_t))
#define BCM56504_A0_MAC_RXMUXCTRLr_SET(r,i,d) (r).mac_rxmuxctrl[i] = d
#define BCM56504_A0_MAC_RXMUXCTRLr_GET(r,i) (r).mac_rxmuxctrl[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MAC_RXMUXCTRLr_ENf_GET(r) (((r).mac_rxmuxctrl[0]) & 0x1)
#define BCM56504_A0_MAC_RXMUXCTRLr_ENf_SET(r,f) (r).mac_rxmuxctrl[0]=(((r).mac_rxmuxctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_MAC_RXMUXCTRLr_PASSTHRUf_GET(r) ((((r).mac_rxmuxctrl[0]) >> 1) & 0x1)
#define BCM56504_A0_MAC_RXMUXCTRLr_PASSTHRUf_SET(r,f) (r).mac_rxmuxctrl[0]=(((r).mac_rxmuxctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_MAC_RXMUXCTRLr_LANEf_GET(r) ((((r).mac_rxmuxctrl[0]) >> 2) & 0x3)
#define BCM56504_A0_MAC_RXMUXCTRLr_LANEf_SET(r,f) (r).mac_rxmuxctrl[0]=(((r).mac_rxmuxctrl[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM56504_A0_MAC_RXMUXCTRLr_TSTMUXf_GET(r) ((((r).mac_rxmuxctrl[0]) >> 4) & 0x1)
#define BCM56504_A0_MAC_RXMUXCTRLr_TSTMUXf_SET(r,f) (r).mac_rxmuxctrl[0]=(((r).mac_rxmuxctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))

/*
 * These macros can be used to access MAC_RxMuxCtrl.
 *
 */
#define BCM56504_A0_READ_MAC_RXMUXCTRLr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_MAC_RXMUXCTRLr,(r._mac_rxmuxctrl))
#define BCM56504_A0_WRITE_MAC_RXMUXCTRLr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_MAC_RXMUXCTRLr,&(r._mac_rxmuxctrl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAC_RXMUXCTRLr BCM56504_A0_MAC_RXMUXCTRLr
#define MAC_RXMUXCTRLr_SIZE BCM56504_A0_MAC_RXMUXCTRLr_SIZE
typedef BCM56504_A0_MAC_RXMUXCTRLr_t MAC_RXMUXCTRLr_t;
#define MAC_RXMUXCTRLr_CLR BCM56504_A0_MAC_RXMUXCTRLr_CLR
#define MAC_RXMUXCTRLr_SET BCM56504_A0_MAC_RXMUXCTRLr_SET
#define MAC_RXMUXCTRLr_GET BCM56504_A0_MAC_RXMUXCTRLr_GET
#define MAC_RXMUXCTRLr_ENf_GET BCM56504_A0_MAC_RXMUXCTRLr_ENf_GET
#define MAC_RXMUXCTRLr_ENf_SET BCM56504_A0_MAC_RXMUXCTRLr_ENf_SET
#define MAC_RXMUXCTRLr_PASSTHRUf_GET BCM56504_A0_MAC_RXMUXCTRLr_PASSTHRUf_GET
#define MAC_RXMUXCTRLr_PASSTHRUf_SET BCM56504_A0_MAC_RXMUXCTRLr_PASSTHRUf_SET
#define MAC_RXMUXCTRLr_LANEf_GET BCM56504_A0_MAC_RXMUXCTRLr_LANEf_GET
#define MAC_RXMUXCTRLr_LANEf_SET BCM56504_A0_MAC_RXMUXCTRLr_LANEf_SET
#define MAC_RXMUXCTRLr_TSTMUXf_GET BCM56504_A0_MAC_RXMUXCTRLr_TSTMUXf_GET
#define MAC_RXMUXCTRLr_TSTMUXf_SET BCM56504_A0_MAC_RXMUXCTRLr_TSTMUXf_SET
#define READ_MAC_RXMUXCTRLr BCM56504_A0_READ_MAC_RXMUXCTRLr
#define WRITE_MAC_RXMUXCTRLr BCM56504_A0_WRITE_MAC_RXMUXCTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MAC_RXMUXCTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  MAC_RxSpare0
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Control for LSS (ordered set) messages
 * SIZE:     64
 * FIELDS:
 *     SPARE            SPARE REGISTERS 0
 *
 ******************************************************************************/
#define BCM56504_A0_MAC_RXSPARE0r 0x00f00025

#define BCM56504_A0_MAC_RXSPARE0r_SIZE 8

/*
 * This structure should be used to declare and program MAC_RxSpare0.
 *
 */
typedef union BCM56504_A0_MAC_RXSPARE0r_s {
	uint32_t v[2];
	uint32_t mac_rxspare0[2];
	uint32_t _mac_rxspare0;
} BCM56504_A0_MAC_RXSPARE0r_t;

#define BCM56504_A0_MAC_RXSPARE0r_CLR(r) CDK_MEMSET(&((r)._mac_rxspare0), 0, sizeof(BCM56504_A0_MAC_RXSPARE0r_t))
#define BCM56504_A0_MAC_RXSPARE0r_SET(r,i,d) (r).mac_rxspare0[i] = d
#define BCM56504_A0_MAC_RXSPARE0r_GET(r,i) (r).mac_rxspare0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MAC_RXSPARE0r_SPAREf_GET(r) ((r).mac_rxspare0[0])
#define BCM56504_A0_MAC_RXSPARE0r_SPAREf_SET(r,f) (r).mac_rxspare0[0]=((uint32_t)f)

/*
 * These macros can be used to access MAC_RxSpare0.
 *
 */
#define BCM56504_A0_READ_MAC_RXSPARE0r(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_MAC_RXSPARE0r,(r._mac_rxspare0))
#define BCM56504_A0_WRITE_MAC_RXSPARE0r(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_MAC_RXSPARE0r,&(r._mac_rxspare0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAC_RXSPARE0r BCM56504_A0_MAC_RXSPARE0r
#define MAC_RXSPARE0r_SIZE BCM56504_A0_MAC_RXSPARE0r_SIZE
typedef BCM56504_A0_MAC_RXSPARE0r_t MAC_RXSPARE0r_t;
#define MAC_RXSPARE0r_CLR BCM56504_A0_MAC_RXSPARE0r_CLR
#define MAC_RXSPARE0r_SET BCM56504_A0_MAC_RXSPARE0r_SET
#define MAC_RXSPARE0r_GET BCM56504_A0_MAC_RXSPARE0r_GET
#define MAC_RXSPARE0r_SPAREf_GET BCM56504_A0_MAC_RXSPARE0r_SPAREf_GET
#define MAC_RXSPARE0r_SPAREf_SET BCM56504_A0_MAC_RXSPARE0r_SPAREf_SET
#define READ_MAC_RXSPARE0r BCM56504_A0_READ_MAC_RXSPARE0r
#define WRITE_MAC_RXSPARE0r BCM56504_A0_WRITE_MAC_RXSPARE0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MAC_RXSPARE0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  MAC_TX_STATUS
 * BLOCKS:   GPORT0
 * DESC:      TriMAC tx status register
 * SIZE:     32
 * FIELDS:
 *     TXFIFO_ERR       When set, indicates TriMAC tx fifo underrun occur.
 *
 ******************************************************************************/
#define BCM56504_A0_MAC_TX_STATUSr 0x00f00303

#define BCM56504_A0_MAC_TX_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program MAC_TX_STATUS.
 *
 */
typedef union BCM56504_A0_MAC_TX_STATUSr_s {
	uint32_t v[1];
	uint32_t mac_tx_status[1];
	uint32_t _mac_tx_status;
} BCM56504_A0_MAC_TX_STATUSr_t;

#define BCM56504_A0_MAC_TX_STATUSr_CLR(r) (r).mac_tx_status[0] = 0
#define BCM56504_A0_MAC_TX_STATUSr_SET(r,d) (r).mac_tx_status[0] = d
#define BCM56504_A0_MAC_TX_STATUSr_GET(r) (r).mac_tx_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MAC_TX_STATUSr_TXFIFO_ERRf_GET(r) (((r).mac_tx_status[0]) & 0x1)
#define BCM56504_A0_MAC_TX_STATUSr_TXFIFO_ERRf_SET(r,f) (r).mac_tx_status[0]=(((r).mac_tx_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access MAC_TX_STATUS.
 *
 */
#define BCM56504_A0_READ_MAC_TX_STATUSr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_MAC_TX_STATUSr,(r._mac_tx_status))
#define BCM56504_A0_WRITE_MAC_TX_STATUSr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_MAC_TX_STATUSr,&(r._mac_tx_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAC_TX_STATUSr BCM56504_A0_MAC_TX_STATUSr
#define MAC_TX_STATUSr_SIZE BCM56504_A0_MAC_TX_STATUSr_SIZE
typedef BCM56504_A0_MAC_TX_STATUSr_t MAC_TX_STATUSr_t;
#define MAC_TX_STATUSr_CLR BCM56504_A0_MAC_TX_STATUSr_CLR
#define MAC_TX_STATUSr_SET BCM56504_A0_MAC_TX_STATUSr_SET
#define MAC_TX_STATUSr_GET BCM56504_A0_MAC_TX_STATUSr_GET
#define MAC_TX_STATUSr_TXFIFO_ERRf_GET BCM56504_A0_MAC_TX_STATUSr_TXFIFO_ERRf_GET
#define MAC_TX_STATUSr_TXFIFO_ERRf_SET BCM56504_A0_MAC_TX_STATUSr_TXFIFO_ERRf_SET
#define READ_MAC_TX_STATUSr BCM56504_A0_READ_MAC_TX_STATUSr
#define WRITE_MAC_TX_STATUSr BCM56504_A0_WRITE_MAC_TX_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MAC_TX_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  MAC_TxCtrl
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Transmit control.
 * SIZE:     64
 * FIELDS:
 *     HDRMODE          Header mode.
 *     CRC_MODE         CRC mode.
 *     AVGIPG           Average interpacket gap. Must be >=8.
 *     THROTNUM         Number of bytes of extra interpacket gap to be forced whenever txThrotDemon bytes have been transmitted. 
 *     THROTDENOM       Number of bytes to transmite before adding txThrotNumer bytes to the IPG. 
 *     PAUSEEN          Send PAUSE packets whenever TxPause input is true.
 *     DISCARD          Accept packets from the host but do not transmit.  Transmite must be enabled. 
 *     ANYSTART         Don\'t force the first byte of a packet to be /Start
 *
 ******************************************************************************/
#define BCM56504_A0_MAC_TXCTRLr 0x00f00007

#define BCM56504_A0_MAC_TXCTRLr_SIZE 8

/*
 * This structure should be used to declare and program MAC_TxCtrl.
 *
 */
typedef union BCM56504_A0_MAC_TXCTRLr_s {
	uint32_t v[2];
	uint32_t mac_txctrl[2];
	uint32_t _mac_txctrl;
} BCM56504_A0_MAC_TXCTRLr_t;

#define BCM56504_A0_MAC_TXCTRLr_CLR(r) CDK_MEMSET(&((r)._mac_txctrl), 0, sizeof(BCM56504_A0_MAC_TXCTRLr_t))
#define BCM56504_A0_MAC_TXCTRLr_SET(r,i,d) (r).mac_txctrl[i] = d
#define BCM56504_A0_MAC_TXCTRLr_GET(r,i) (r).mac_txctrl[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MAC_TXCTRLr_HDRMODEf_GET(r) (((r).mac_txctrl[0]) & 0x3)
#define BCM56504_A0_MAC_TXCTRLr_HDRMODEf_SET(r,f) (r).mac_txctrl[0]=(((r).mac_txctrl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56504_A0_MAC_TXCTRLr_CRC_MODEf_GET(r) ((((r).mac_txctrl[0]) >> 2) & 0x3)
#define BCM56504_A0_MAC_TXCTRLr_CRC_MODEf_SET(r,f) (r).mac_txctrl[0]=(((r).mac_txctrl[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM56504_A0_MAC_TXCTRLr_AVGIPGf_GET(r) ((((r).mac_txctrl[0]) >> 4) & 0x1f)
#define BCM56504_A0_MAC_TXCTRLr_AVGIPGf_SET(r,f) (r).mac_txctrl[0]=(((r).mac_txctrl[0] & ~((uint32_t)0x1f << 4)) | ((((uint32_t)f) & 0x1f) << 4))
#define BCM56504_A0_MAC_TXCTRLr_THROTNUMf_GET(r) ((((r).mac_txctrl[0]) >> 9) & 0x3f)
#define BCM56504_A0_MAC_TXCTRLr_THROTNUMf_SET(r,f) (r).mac_txctrl[0]=(((r).mac_txctrl[0] & ~((uint32_t)0x3f << 9)) | ((((uint32_t)f) & 0x3f) << 9))
#define BCM56504_A0_MAC_TXCTRLr_THROTDENOMf_GET(r) ((((r).mac_txctrl[0]) >> 15) & 0xff)
#define BCM56504_A0_MAC_TXCTRLr_THROTDENOMf_SET(r,f) (r).mac_txctrl[0]=(((r).mac_txctrl[0] & ~((uint32_t)0xff << 15)) | ((((uint32_t)f) & 0xff) << 15))
#define BCM56504_A0_MAC_TXCTRLr_PAUSEENf_GET(r) ((((r).mac_txctrl[0]) >> 23) & 0x1)
#define BCM56504_A0_MAC_TXCTRLr_PAUSEENf_SET(r,f) (r).mac_txctrl[0]=(((r).mac_txctrl[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM56504_A0_MAC_TXCTRLr_DISCARDf_GET(r) ((((r).mac_txctrl[0]) >> 24) & 0x1)
#define BCM56504_A0_MAC_TXCTRLr_DISCARDf_SET(r,f) (r).mac_txctrl[0]=(((r).mac_txctrl[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM56504_A0_MAC_TXCTRLr_ANYSTARTf_GET(r) ((((r).mac_txctrl[0]) >> 25) & 0x1)
#define BCM56504_A0_MAC_TXCTRLr_ANYSTARTf_SET(r,f) (r).mac_txctrl[0]=(((r).mac_txctrl[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))

/*
 * These macros can be used to access MAC_TxCtrl.
 *
 */
#define BCM56504_A0_READ_MAC_TXCTRLr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_MAC_TXCTRLr,(r._mac_txctrl))
#define BCM56504_A0_WRITE_MAC_TXCTRLr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_MAC_TXCTRLr,&(r._mac_txctrl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAC_TXCTRLr BCM56504_A0_MAC_TXCTRLr
#define MAC_TXCTRLr_SIZE BCM56504_A0_MAC_TXCTRLr_SIZE
typedef BCM56504_A0_MAC_TXCTRLr_t MAC_TXCTRLr_t;
#define MAC_TXCTRLr_CLR BCM56504_A0_MAC_TXCTRLr_CLR
#define MAC_TXCTRLr_SET BCM56504_A0_MAC_TXCTRLr_SET
#define MAC_TXCTRLr_GET BCM56504_A0_MAC_TXCTRLr_GET
#define MAC_TXCTRLr_HDRMODEf_GET BCM56504_A0_MAC_TXCTRLr_HDRMODEf_GET
#define MAC_TXCTRLr_HDRMODEf_SET BCM56504_A0_MAC_TXCTRLr_HDRMODEf_SET
#define MAC_TXCTRLr_CRC_MODEf_GET BCM56504_A0_MAC_TXCTRLr_CRC_MODEf_GET
#define MAC_TXCTRLr_CRC_MODEf_SET BCM56504_A0_MAC_TXCTRLr_CRC_MODEf_SET
#define MAC_TXCTRLr_AVGIPGf_GET BCM56504_A0_MAC_TXCTRLr_AVGIPGf_GET
#define MAC_TXCTRLr_AVGIPGf_SET BCM56504_A0_MAC_TXCTRLr_AVGIPGf_SET
#define MAC_TXCTRLr_THROTNUMf_GET BCM56504_A0_MAC_TXCTRLr_THROTNUMf_GET
#define MAC_TXCTRLr_THROTNUMf_SET BCM56504_A0_MAC_TXCTRLr_THROTNUMf_SET
#define MAC_TXCTRLr_THROTDENOMf_GET BCM56504_A0_MAC_TXCTRLr_THROTDENOMf_GET
#define MAC_TXCTRLr_THROTDENOMf_SET BCM56504_A0_MAC_TXCTRLr_THROTDENOMf_SET
#define MAC_TXCTRLr_PAUSEENf_GET BCM56504_A0_MAC_TXCTRLr_PAUSEENf_GET
#define MAC_TXCTRLr_PAUSEENf_SET BCM56504_A0_MAC_TXCTRLr_PAUSEENf_SET
#define MAC_TXCTRLr_DISCARDf_GET BCM56504_A0_MAC_TXCTRLr_DISCARDf_GET
#define MAC_TXCTRLr_DISCARDf_SET BCM56504_A0_MAC_TXCTRLr_DISCARDf_SET
#define MAC_TXCTRLr_ANYSTARTf_GET BCM56504_A0_MAC_TXCTRLr_ANYSTARTf_GET
#define MAC_TXCTRLr_ANYSTARTf_SET BCM56504_A0_MAC_TXCTRLr_ANYSTARTf_SET
#define READ_MAC_TXCTRLr BCM56504_A0_READ_MAC_TXCTRLr
#define WRITE_MAC_TXCTRLr BCM56504_A0_WRITE_MAC_TXCTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MAC_TXCTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  MAC_TxMACSA
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Transmit source address.
 * SIZE:     64
 * FIELDS:
 *     SA               Used as the SA in PAUSE packets transmitted by the MAC.
 *
 ******************************************************************************/
#define BCM56504_A0_MAC_TXMACSAr 0x00f00008

#define BCM56504_A0_MAC_TXMACSAr_SIZE 8

/*
 * This structure should be used to declare and program MAC_TxMACSA.
 *
 */
typedef union BCM56504_A0_MAC_TXMACSAr_s {
	uint32_t v[2];
	uint32_t mac_txmacsa[2];
	uint32_t _mac_txmacsa;
} BCM56504_A0_MAC_TXMACSAr_t;

#define BCM56504_A0_MAC_TXMACSAr_CLR(r) CDK_MEMSET(&((r)._mac_txmacsa), 0, sizeof(BCM56504_A0_MAC_TXMACSAr_t))
#define BCM56504_A0_MAC_TXMACSAr_SET(r,i,d) (r).mac_txmacsa[i] = d
#define BCM56504_A0_MAC_TXMACSAr_GET(r,i) (r).mac_txmacsa[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MAC_TXMACSAr_SAf_GET(r,a) cdk_field_get((r).mac_txmacsa,0,47,a)
#define BCM56504_A0_MAC_TXMACSAr_SAf_SET(r,a) cdk_field_set((r).mac_txmacsa,0,47,a)

/*
 * These macros can be used to access MAC_TxMACSA.
 *
 */
#define BCM56504_A0_READ_MAC_TXMACSAr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_MAC_TXMACSAr,(r._mac_txmacsa))
#define BCM56504_A0_WRITE_MAC_TXMACSAr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_MAC_TXMACSAr,&(r._mac_txmacsa))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAC_TXMACSAr BCM56504_A0_MAC_TXMACSAr
#define MAC_TXMACSAr_SIZE BCM56504_A0_MAC_TXMACSAr_SIZE
typedef BCM56504_A0_MAC_TXMACSAr_t MAC_TXMACSAr_t;
#define MAC_TXMACSAr_CLR BCM56504_A0_MAC_TXMACSAr_CLR
#define MAC_TXMACSAr_SET BCM56504_A0_MAC_TXMACSAr_SET
#define MAC_TXMACSAr_GET BCM56504_A0_MAC_TXMACSAr_GET
#define MAC_TXMACSAr_SAf_GET BCM56504_A0_MAC_TXMACSAr_SAf_GET
#define MAC_TXMACSAr_SAf_SET BCM56504_A0_MAC_TXMACSAr_SAf_SET
#define READ_MAC_TXMACSAr BCM56504_A0_READ_MAC_TXMACSAr
#define WRITE_MAC_TXMACSAr BCM56504_A0_WRITE_MAC_TXMACSAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MAC_TXMACSAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  MAC_TxMaxSz
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Transmit maximum size.
 * SIZE:     64
 * FIELDS:
 *     SZ               Maximum byte size of packets transmitted by the MAC.Legal range is 64 to 16360 inclusive.The size represented here includes the added 8-byte preamble inIEEE mode but does not include the CRC in APPEND mode.
 *
 ******************************************************************************/
#define BCM56504_A0_MAC_TXMAXSZr 0x00f00009

#define BCM56504_A0_MAC_TXMAXSZr_SIZE 8

/*
 * This structure should be used to declare and program MAC_TxMaxSz.
 *
 */
typedef union BCM56504_A0_MAC_TXMAXSZr_s {
	uint32_t v[2];
	uint32_t mac_txmaxsz[2];
	uint32_t _mac_txmaxsz;
} BCM56504_A0_MAC_TXMAXSZr_t;

#define BCM56504_A0_MAC_TXMAXSZr_CLR(r) CDK_MEMSET(&((r)._mac_txmaxsz), 0, sizeof(BCM56504_A0_MAC_TXMAXSZr_t))
#define BCM56504_A0_MAC_TXMAXSZr_SET(r,i,d) (r).mac_txmaxsz[i] = d
#define BCM56504_A0_MAC_TXMAXSZr_GET(r,i) (r).mac_txmaxsz[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MAC_TXMAXSZr_SZf_GET(r) (((r).mac_txmaxsz[0]) & 0x3fff)
#define BCM56504_A0_MAC_TXMAXSZr_SZf_SET(r,f) (r).mac_txmaxsz[0]=(((r).mac_txmaxsz[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access MAC_TxMaxSz.
 *
 */
#define BCM56504_A0_READ_MAC_TXMAXSZr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_MAC_TXMAXSZr,(r._mac_txmaxsz))
#define BCM56504_A0_WRITE_MAC_TXMAXSZr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_MAC_TXMAXSZr,&(r._mac_txmaxsz))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAC_TXMAXSZr BCM56504_A0_MAC_TXMAXSZr
#define MAC_TXMAXSZr_SIZE BCM56504_A0_MAC_TXMAXSZr_SIZE
typedef BCM56504_A0_MAC_TXMAXSZr_t MAC_TXMAXSZr_t;
#define MAC_TXMAXSZr_CLR BCM56504_A0_MAC_TXMAXSZr_CLR
#define MAC_TXMAXSZr_SET BCM56504_A0_MAC_TXMAXSZr_SET
#define MAC_TXMAXSZr_GET BCM56504_A0_MAC_TXMAXSZr_GET
#define MAC_TXMAXSZr_SZf_GET BCM56504_A0_MAC_TXMAXSZr_SZf_GET
#define MAC_TXMAXSZr_SZf_SET BCM56504_A0_MAC_TXMAXSZr_SZf_SET
#define READ_MAC_TXMAXSZr BCM56504_A0_READ_MAC_TXMAXSZr
#define WRITE_MAC_TXMAXSZr BCM56504_A0_WRITE_MAC_TXMAXSZr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MAC_TXMAXSZr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  MAC_TxMuxCtrl
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Transmit test mux control.
 * SIZE:     64
 * FIELDS:
 *     OUTEN            Drive Tx data from the test bypass port.
 *     RINGEN           Drive txmux_data_out and txmux_clk_out.
 *     PASSTHRU         Drive txmux_data_out and txmux_clk_out from txmux_data_in and txmux_clk_in. 
 *     LANE             Lane select when RINGENBL==1 and PASSTHRU==0.
 *
 ******************************************************************************/
#define BCM56504_A0_MAC_TXMUXCTRLr 0x00f00003

#define BCM56504_A0_MAC_TXMUXCTRLr_SIZE 8

/*
 * This structure should be used to declare and program MAC_TxMuxCtrl.
 *
 */
typedef union BCM56504_A0_MAC_TXMUXCTRLr_s {
	uint32_t v[2];
	uint32_t mac_txmuxctrl[2];
	uint32_t _mac_txmuxctrl;
} BCM56504_A0_MAC_TXMUXCTRLr_t;

#define BCM56504_A0_MAC_TXMUXCTRLr_CLR(r) CDK_MEMSET(&((r)._mac_txmuxctrl), 0, sizeof(BCM56504_A0_MAC_TXMUXCTRLr_t))
#define BCM56504_A0_MAC_TXMUXCTRLr_SET(r,i,d) (r).mac_txmuxctrl[i] = d
#define BCM56504_A0_MAC_TXMUXCTRLr_GET(r,i) (r).mac_txmuxctrl[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MAC_TXMUXCTRLr_OUTENf_GET(r) (((r).mac_txmuxctrl[0]) & 0x1)
#define BCM56504_A0_MAC_TXMUXCTRLr_OUTENf_SET(r,f) (r).mac_txmuxctrl[0]=(((r).mac_txmuxctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_MAC_TXMUXCTRLr_RINGENf_GET(r) ((((r).mac_txmuxctrl[0]) >> 1) & 0x1)
#define BCM56504_A0_MAC_TXMUXCTRLr_RINGENf_SET(r,f) (r).mac_txmuxctrl[0]=(((r).mac_txmuxctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_MAC_TXMUXCTRLr_PASSTHRUf_GET(r) ((((r).mac_txmuxctrl[0]) >> 2) & 0x1)
#define BCM56504_A0_MAC_TXMUXCTRLr_PASSTHRUf_SET(r,f) (r).mac_txmuxctrl[0]=(((r).mac_txmuxctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_MAC_TXMUXCTRLr_LANEf_GET(r) ((((r).mac_txmuxctrl[0]) >> 3) & 0x3)
#define BCM56504_A0_MAC_TXMUXCTRLr_LANEf_SET(r,f) (r).mac_txmuxctrl[0]=(((r).mac_txmuxctrl[0] & ~((uint32_t)0x3 << 3)) | ((((uint32_t)f) & 0x3) << 3))

/*
 * These macros can be used to access MAC_TxMuxCtrl.
 *
 */
#define BCM56504_A0_READ_MAC_TXMUXCTRLr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_MAC_TXMUXCTRLr,(r._mac_txmuxctrl))
#define BCM56504_A0_WRITE_MAC_TXMUXCTRLr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_MAC_TXMUXCTRLr,&(r._mac_txmuxctrl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAC_TXMUXCTRLr BCM56504_A0_MAC_TXMUXCTRLr
#define MAC_TXMUXCTRLr_SIZE BCM56504_A0_MAC_TXMUXCTRLr_SIZE
typedef BCM56504_A0_MAC_TXMUXCTRLr_t MAC_TXMUXCTRLr_t;
#define MAC_TXMUXCTRLr_CLR BCM56504_A0_MAC_TXMUXCTRLr_CLR
#define MAC_TXMUXCTRLr_SET BCM56504_A0_MAC_TXMUXCTRLr_SET
#define MAC_TXMUXCTRLr_GET BCM56504_A0_MAC_TXMUXCTRLr_GET
#define MAC_TXMUXCTRLr_OUTENf_GET BCM56504_A0_MAC_TXMUXCTRLr_OUTENf_GET
#define MAC_TXMUXCTRLr_OUTENf_SET BCM56504_A0_MAC_TXMUXCTRLr_OUTENf_SET
#define MAC_TXMUXCTRLr_RINGENf_GET BCM56504_A0_MAC_TXMUXCTRLr_RINGENf_GET
#define MAC_TXMUXCTRLr_RINGENf_SET BCM56504_A0_MAC_TXMUXCTRLr_RINGENf_SET
#define MAC_TXMUXCTRLr_PASSTHRUf_GET BCM56504_A0_MAC_TXMUXCTRLr_PASSTHRUf_GET
#define MAC_TXMUXCTRLr_PASSTHRUf_SET BCM56504_A0_MAC_TXMUXCTRLr_PASSTHRUf_SET
#define MAC_TXMUXCTRLr_LANEf_GET BCM56504_A0_MAC_TXMUXCTRLr_LANEf_GET
#define MAC_TXMUXCTRLr_LANEf_SET BCM56504_A0_MAC_TXMUXCTRLr_LANEf_SET
#define READ_MAC_TXMUXCTRLr BCM56504_A0_READ_MAC_TXMUXCTRLr
#define WRITE_MAC_TXMUXCTRLr BCM56504_A0_WRITE_MAC_TXMUXCTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MAC_TXMUXCTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  MAC_TxPseThr
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Transmit PAUSE threshold.
 * SIZE:     64
 * FIELDS:
 *     XOFF             Threshold for pause timer to cause XOFF to be resent.
 *     XON              Threshold for pause timer before XON is sent.
 *
 ******************************************************************************/
#define BCM56504_A0_MAC_TXPSETHRr 0x00f0000a

#define BCM56504_A0_MAC_TXPSETHRr_SIZE 8

/*
 * This structure should be used to declare and program MAC_TxPseThr.
 *
 */
typedef union BCM56504_A0_MAC_TXPSETHRr_s {
	uint32_t v[2];
	uint32_t mac_txpsethr[2];
	uint32_t _mac_txpsethr;
} BCM56504_A0_MAC_TXPSETHRr_t;

#define BCM56504_A0_MAC_TXPSETHRr_CLR(r) CDK_MEMSET(&((r)._mac_txpsethr), 0, sizeof(BCM56504_A0_MAC_TXPSETHRr_t))
#define BCM56504_A0_MAC_TXPSETHRr_SET(r,i,d) (r).mac_txpsethr[i] = d
#define BCM56504_A0_MAC_TXPSETHRr_GET(r,i) (r).mac_txpsethr[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MAC_TXPSETHRr_XOFFf_GET(r) (((r).mac_txpsethr[0]) & 0xffff)
#define BCM56504_A0_MAC_TXPSETHRr_XOFFf_SET(r,f) (r).mac_txpsethr[0]=(((r).mac_txpsethr[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56504_A0_MAC_TXPSETHRr_XONf_GET(r) ((((r).mac_txpsethr[0]) >> 16) & 0xffff)
#define BCM56504_A0_MAC_TXPSETHRr_XONf_SET(r,f) (r).mac_txpsethr[0]=(((r).mac_txpsethr[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access MAC_TxPseThr.
 *
 */
#define BCM56504_A0_READ_MAC_TXPSETHRr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_MAC_TXPSETHRr,(r._mac_txpsethr))
#define BCM56504_A0_WRITE_MAC_TXPSETHRr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_MAC_TXPSETHRr,&(r._mac_txpsethr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAC_TXPSETHRr BCM56504_A0_MAC_TXPSETHRr
#define MAC_TXPSETHRr_SIZE BCM56504_A0_MAC_TXPSETHRr_SIZE
typedef BCM56504_A0_MAC_TXPSETHRr_t MAC_TXPSETHRr_t;
#define MAC_TXPSETHRr_CLR BCM56504_A0_MAC_TXPSETHRr_CLR
#define MAC_TXPSETHRr_SET BCM56504_A0_MAC_TXPSETHRr_SET
#define MAC_TXPSETHRr_GET BCM56504_A0_MAC_TXPSETHRr_GET
#define MAC_TXPSETHRr_XOFFf_GET BCM56504_A0_MAC_TXPSETHRr_XOFFf_GET
#define MAC_TXPSETHRr_XOFFf_SET BCM56504_A0_MAC_TXPSETHRr_XOFFf_SET
#define MAC_TXPSETHRr_XONf_GET BCM56504_A0_MAC_TXPSETHRr_XONf_GET
#define MAC_TXPSETHRr_XONf_SET BCM56504_A0_MAC_TXPSETHRr_XONf_SET
#define READ_MAC_TXPSETHRr BCM56504_A0_READ_MAC_TXPSETHRr
#define WRITE_MAC_TXPSETHRr BCM56504_A0_WRITE_MAC_TXPSETHRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MAC_TXPSETHRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  MAC_TxSpare0
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     Spare reg for ECO on TX clock domain
 * SIZE:     64
 * FIELDS:
 *     RSVD             SPARE REGISTERS 0
 *
 ******************************************************************************/
#define BCM56504_A0_MAC_TXSPARE0r 0x00f0000b

#define BCM56504_A0_MAC_TXSPARE0r_SIZE 8

/*
 * This structure should be used to declare and program MAC_TxSpare0.
 *
 */
typedef union BCM56504_A0_MAC_TXSPARE0r_s {
	uint32_t v[2];
	uint32_t mac_txspare0[2];
	uint32_t _mac_txspare0;
} BCM56504_A0_MAC_TXSPARE0r_t;

#define BCM56504_A0_MAC_TXSPARE0r_CLR(r) CDK_MEMSET(&((r)._mac_txspare0), 0, sizeof(BCM56504_A0_MAC_TXSPARE0r_t))
#define BCM56504_A0_MAC_TXSPARE0r_SET(r,i,d) (r).mac_txspare0[i] = d
#define BCM56504_A0_MAC_TXSPARE0r_GET(r,i) (r).mac_txspare0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MAC_TXSPARE0r_RSVDf_GET(r) ((r).mac_txspare0[0])
#define BCM56504_A0_MAC_TXSPARE0r_RSVDf_SET(r,f) (r).mac_txspare0[0]=((uint32_t)f)

/*
 * These macros can be used to access MAC_TxSpare0.
 *
 */
#define BCM56504_A0_READ_MAC_TXSPARE0r(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_MAC_TXSPARE0r,(r._mac_txspare0))
#define BCM56504_A0_WRITE_MAC_TXSPARE0r(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_MAC_TXSPARE0r,&(r._mac_txspare0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAC_TXSPARE0r BCM56504_A0_MAC_TXSPARE0r
#define MAC_TXSPARE0r_SIZE BCM56504_A0_MAC_TXSPARE0r_SIZE
typedef BCM56504_A0_MAC_TXSPARE0r_t MAC_TXSPARE0r_t;
#define MAC_TXSPARE0r_CLR BCM56504_A0_MAC_TXSPARE0r_CLR
#define MAC_TXSPARE0r_SET BCM56504_A0_MAC_TXSPARE0r_SET
#define MAC_TXSPARE0r_GET BCM56504_A0_MAC_TXSPARE0r_GET
#define MAC_TXSPARE0r_RSVDf_GET BCM56504_A0_MAC_TXSPARE0r_RSVDf_GET
#define MAC_TXSPARE0r_RSVDf_SET BCM56504_A0_MAC_TXSPARE0r_RSVDf_SET
#define READ_MAC_TXSPARE0r BCM56504_A0_READ_MAC_TXSPARE0r
#define WRITE_MAC_TXSPARE0r BCM56504_A0_WRITE_MAC_TXSPARE0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MAC_TXSPARE0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  MAC_XGXS_Ctrl
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     XGXS_IP control.
 * SIZE:     64
 * FIELDS:
 *     MODE             Clock compensation mode: 0=with, 1=without.
 *     HW_RSTL          Hard reset (active low).
 *     PWRDWN           Shutdown digital clocks.
 *     IDDQ             Shutdown analog clocks but leave analog section powered.
 *     TXFIFO_RSTL      Tx FIFO reset (active low).
 *     AFIFO_RST        Automatically reset Tx FIFO on over/underflow.
 *     RMTLOOP          Enable remote loopback.
 *     PLLBYP           Bypass refclk PLL and run transmit and receive clocks from refclk pin.
 *     MODEFORCE        Force XGXS mode select bootstrap ALWAYS.
 *     RXTRIM           RX DSP core trim (0x0 for Slicer).
 *     TXLANESWAP       Set to 1 to swap lanes in the TX path.
 *     RXLANESWAP       Set to 1 to swap lanes in the RX path.
 *     RSTFLTRBYP       Set to 1 to Reset filter bypass.
 *     LCREFEN          Set to 1 to select clock from LCPLL - otherwise from clock pads.
 *     RESERVED         reserved
 *
 ******************************************************************************/
#define BCM56504_A0_MAC_XGXS_CTRLr 0x00f00001

#define BCM56504_A0_MAC_XGXS_CTRLr_SIZE 8

/*
 * This structure should be used to declare and program MAC_XGXS_Ctrl.
 *
 */
typedef union BCM56504_A0_MAC_XGXS_CTRLr_s {
	uint32_t v[2];
	uint32_t mac_xgxs_ctrl[2];
	uint32_t _mac_xgxs_ctrl;
} BCM56504_A0_MAC_XGXS_CTRLr_t;

#define BCM56504_A0_MAC_XGXS_CTRLr_CLR(r) CDK_MEMSET(&((r)._mac_xgxs_ctrl), 0, sizeof(BCM56504_A0_MAC_XGXS_CTRLr_t))
#define BCM56504_A0_MAC_XGXS_CTRLr_SET(r,i,d) (r).mac_xgxs_ctrl[i] = d
#define BCM56504_A0_MAC_XGXS_CTRLr_GET(r,i) (r).mac_xgxs_ctrl[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MAC_XGXS_CTRLr_MODEf_GET(r) (((r).mac_xgxs_ctrl[0]) & 0xf)
#define BCM56504_A0_MAC_XGXS_CTRLr_MODEf_SET(r,f) (r).mac_xgxs_ctrl[0]=(((r).mac_xgxs_ctrl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56504_A0_MAC_XGXS_CTRLr_HW_RSTLf_GET(r) ((((r).mac_xgxs_ctrl[0]) >> 4) & 0x1)
#define BCM56504_A0_MAC_XGXS_CTRLr_HW_RSTLf_SET(r,f) (r).mac_xgxs_ctrl[0]=(((r).mac_xgxs_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56504_A0_MAC_XGXS_CTRLr_PWRDWNf_GET(r) ((((r).mac_xgxs_ctrl[0]) >> 5) & 0x1)
#define BCM56504_A0_MAC_XGXS_CTRLr_PWRDWNf_SET(r,f) (r).mac_xgxs_ctrl[0]=(((r).mac_xgxs_ctrl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56504_A0_MAC_XGXS_CTRLr_IDDQf_GET(r) ((((r).mac_xgxs_ctrl[0]) >> 6) & 0x1)
#define BCM56504_A0_MAC_XGXS_CTRLr_IDDQf_SET(r,f) (r).mac_xgxs_ctrl[0]=(((r).mac_xgxs_ctrl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56504_A0_MAC_XGXS_CTRLr_TXFIFO_RSTLf_GET(r) ((((r).mac_xgxs_ctrl[0]) >> 7) & 0x1)
#define BCM56504_A0_MAC_XGXS_CTRLr_TXFIFO_RSTLf_SET(r,f) (r).mac_xgxs_ctrl[0]=(((r).mac_xgxs_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56504_A0_MAC_XGXS_CTRLr_AFIFO_RSTf_GET(r) ((((r).mac_xgxs_ctrl[0]) >> 8) & 0x1)
#define BCM56504_A0_MAC_XGXS_CTRLr_AFIFO_RSTf_SET(r,f) (r).mac_xgxs_ctrl[0]=(((r).mac_xgxs_ctrl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56504_A0_MAC_XGXS_CTRLr_RMTLOOPf_GET(r) ((((r).mac_xgxs_ctrl[0]) >> 9) & 0x1)
#define BCM56504_A0_MAC_XGXS_CTRLr_RMTLOOPf_SET(r,f) (r).mac_xgxs_ctrl[0]=(((r).mac_xgxs_ctrl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56504_A0_MAC_XGXS_CTRLr_PLLBYPf_GET(r) ((((r).mac_xgxs_ctrl[0]) >> 10) & 0x1)
#define BCM56504_A0_MAC_XGXS_CTRLr_PLLBYPf_SET(r,f) (r).mac_xgxs_ctrl[0]=(((r).mac_xgxs_ctrl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56504_A0_MAC_XGXS_CTRLr_MODEFORCEf_GET(r) ((((r).mac_xgxs_ctrl[0]) >> 11) & 0x1)
#define BCM56504_A0_MAC_XGXS_CTRLr_MODEFORCEf_SET(r,f) (r).mac_xgxs_ctrl[0]=(((r).mac_xgxs_ctrl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56504_A0_MAC_XGXS_CTRLr_RXTRIMf_GET(r) ((((r).mac_xgxs_ctrl[0]) >> 12) & 0xf)
#define BCM56504_A0_MAC_XGXS_CTRLr_RXTRIMf_SET(r,f) (r).mac_xgxs_ctrl[0]=(((r).mac_xgxs_ctrl[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM56504_A0_MAC_XGXS_CTRLr_TXLANESWAPf_GET(r) ((((r).mac_xgxs_ctrl[0]) >> 16) & 0x1)
#define BCM56504_A0_MAC_XGXS_CTRLr_TXLANESWAPf_SET(r,f) (r).mac_xgxs_ctrl[0]=(((r).mac_xgxs_ctrl[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56504_A0_MAC_XGXS_CTRLr_RXLANESWAPf_GET(r) ((((r).mac_xgxs_ctrl[0]) >> 17) & 0x1)
#define BCM56504_A0_MAC_XGXS_CTRLr_RXLANESWAPf_SET(r,f) (r).mac_xgxs_ctrl[0]=(((r).mac_xgxs_ctrl[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56504_A0_MAC_XGXS_CTRLr_RSTFLTRBYPf_GET(r) ((((r).mac_xgxs_ctrl[0]) >> 18) & 0x1)
#define BCM56504_A0_MAC_XGXS_CTRLr_RSTFLTRBYPf_SET(r,f) (r).mac_xgxs_ctrl[0]=(((r).mac_xgxs_ctrl[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56504_A0_MAC_XGXS_CTRLr_LCREFENf_GET(r) ((((r).mac_xgxs_ctrl[0]) >> 19) & 0x1)
#define BCM56504_A0_MAC_XGXS_CTRLr_LCREFENf_SET(r,f) (r).mac_xgxs_ctrl[0]=(((r).mac_xgxs_ctrl[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56504_A0_MAC_XGXS_CTRLr_RESERVEDf_GET(r) ((((r).mac_xgxs_ctrl[0]) >> 20) & 0xf)
#define BCM56504_A0_MAC_XGXS_CTRLr_RESERVEDf_SET(r,f) (r).mac_xgxs_ctrl[0]=(((r).mac_xgxs_ctrl[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))

/*
 * These macros can be used to access MAC_XGXS_Ctrl.
 *
 */
#define BCM56504_A0_READ_MAC_XGXS_CTRLr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_MAC_XGXS_CTRLr,(r._mac_xgxs_ctrl))
#define BCM56504_A0_WRITE_MAC_XGXS_CTRLr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_MAC_XGXS_CTRLr,&(r._mac_xgxs_ctrl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAC_XGXS_CTRLr BCM56504_A0_MAC_XGXS_CTRLr
#define MAC_XGXS_CTRLr_SIZE BCM56504_A0_MAC_XGXS_CTRLr_SIZE
typedef BCM56504_A0_MAC_XGXS_CTRLr_t MAC_XGXS_CTRLr_t;
#define MAC_XGXS_CTRLr_CLR BCM56504_A0_MAC_XGXS_CTRLr_CLR
#define MAC_XGXS_CTRLr_SET BCM56504_A0_MAC_XGXS_CTRLr_SET
#define MAC_XGXS_CTRLr_GET BCM56504_A0_MAC_XGXS_CTRLr_GET
#define MAC_XGXS_CTRLr_MODEf_GET BCM56504_A0_MAC_XGXS_CTRLr_MODEf_GET
#define MAC_XGXS_CTRLr_MODEf_SET BCM56504_A0_MAC_XGXS_CTRLr_MODEf_SET
#define MAC_XGXS_CTRLr_HW_RSTLf_GET BCM56504_A0_MAC_XGXS_CTRLr_HW_RSTLf_GET
#define MAC_XGXS_CTRLr_HW_RSTLf_SET BCM56504_A0_MAC_XGXS_CTRLr_HW_RSTLf_SET
#define MAC_XGXS_CTRLr_PWRDWNf_GET BCM56504_A0_MAC_XGXS_CTRLr_PWRDWNf_GET
#define MAC_XGXS_CTRLr_PWRDWNf_SET BCM56504_A0_MAC_XGXS_CTRLr_PWRDWNf_SET
#define MAC_XGXS_CTRLr_IDDQf_GET BCM56504_A0_MAC_XGXS_CTRLr_IDDQf_GET
#define MAC_XGXS_CTRLr_IDDQf_SET BCM56504_A0_MAC_XGXS_CTRLr_IDDQf_SET
#define MAC_XGXS_CTRLr_TXFIFO_RSTLf_GET BCM56504_A0_MAC_XGXS_CTRLr_TXFIFO_RSTLf_GET
#define MAC_XGXS_CTRLr_TXFIFO_RSTLf_SET BCM56504_A0_MAC_XGXS_CTRLr_TXFIFO_RSTLf_SET
#define MAC_XGXS_CTRLr_AFIFO_RSTf_GET BCM56504_A0_MAC_XGXS_CTRLr_AFIFO_RSTf_GET
#define MAC_XGXS_CTRLr_AFIFO_RSTf_SET BCM56504_A0_MAC_XGXS_CTRLr_AFIFO_RSTf_SET
#define MAC_XGXS_CTRLr_RMTLOOPf_GET BCM56504_A0_MAC_XGXS_CTRLr_RMTLOOPf_GET
#define MAC_XGXS_CTRLr_RMTLOOPf_SET BCM56504_A0_MAC_XGXS_CTRLr_RMTLOOPf_SET
#define MAC_XGXS_CTRLr_PLLBYPf_GET BCM56504_A0_MAC_XGXS_CTRLr_PLLBYPf_GET
#define MAC_XGXS_CTRLr_PLLBYPf_SET BCM56504_A0_MAC_XGXS_CTRLr_PLLBYPf_SET
#define MAC_XGXS_CTRLr_MODEFORCEf_GET BCM56504_A0_MAC_XGXS_CTRLr_MODEFORCEf_GET
#define MAC_XGXS_CTRLr_MODEFORCEf_SET BCM56504_A0_MAC_XGXS_CTRLr_MODEFORCEf_SET
#define MAC_XGXS_CTRLr_RXTRIMf_GET BCM56504_A0_MAC_XGXS_CTRLr_RXTRIMf_GET
#define MAC_XGXS_CTRLr_RXTRIMf_SET BCM56504_A0_MAC_XGXS_CTRLr_RXTRIMf_SET
#define MAC_XGXS_CTRLr_TXLANESWAPf_GET BCM56504_A0_MAC_XGXS_CTRLr_TXLANESWAPf_GET
#define MAC_XGXS_CTRLr_TXLANESWAPf_SET BCM56504_A0_MAC_XGXS_CTRLr_TXLANESWAPf_SET
#define MAC_XGXS_CTRLr_RXLANESWAPf_GET BCM56504_A0_MAC_XGXS_CTRLr_RXLANESWAPf_GET
#define MAC_XGXS_CTRLr_RXLANESWAPf_SET BCM56504_A0_MAC_XGXS_CTRLr_RXLANESWAPf_SET
#define MAC_XGXS_CTRLr_RSTFLTRBYPf_GET BCM56504_A0_MAC_XGXS_CTRLr_RSTFLTRBYPf_GET
#define MAC_XGXS_CTRLr_RSTFLTRBYPf_SET BCM56504_A0_MAC_XGXS_CTRLr_RSTFLTRBYPf_SET
#define MAC_XGXS_CTRLr_LCREFENf_GET BCM56504_A0_MAC_XGXS_CTRLr_LCREFENf_GET
#define MAC_XGXS_CTRLr_LCREFENf_SET BCM56504_A0_MAC_XGXS_CTRLr_LCREFENf_SET
#define MAC_XGXS_CTRLr_RESERVEDf_GET BCM56504_A0_MAC_XGXS_CTRLr_RESERVEDf_GET
#define MAC_XGXS_CTRLr_RESERVEDf_SET BCM56504_A0_MAC_XGXS_CTRLr_RESERVEDf_SET
#define READ_MAC_XGXS_CTRLr BCM56504_A0_READ_MAC_XGXS_CTRLr
#define WRITE_MAC_XGXS_CTRLr BCM56504_A0_WRITE_MAC_XGXS_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MAC_XGXS_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  MAC_XGXS_Stat
 * BLOCKS:   XPORT0 XPORT1 XPORT2 XPORT3
 * DESC:     XGXS_IP status.
 * SIZE:     64
 * FIELDS:
 *     LINK             Link status signal.
 *     RXACT            Rx active packet.
 *     SEQDONE          Analog initialization sequence complete.
 *     TXPLL_LOCK       Txpll lock status.
 *     TXACT            Tx active packet.
 *     TXFIFO_ERR       Tx FIFO over/under run indicator.
 *     RMTFLT           LSS Remote Link - Remote Fault Status.
 *     BRKLINK          LSS Remote Link - Break Link Status.
 *
 ******************************************************************************/
#define BCM56504_A0_MAC_XGXS_STATr 0x00f00002

#define BCM56504_A0_MAC_XGXS_STATr_SIZE 8

/*
 * This structure should be used to declare and program MAC_XGXS_Stat.
 *
 */
typedef union BCM56504_A0_MAC_XGXS_STATr_s {
	uint32_t v[2];
	uint32_t mac_xgxs_stat[2];
	uint32_t _mac_xgxs_stat;
} BCM56504_A0_MAC_XGXS_STATr_t;

#define BCM56504_A0_MAC_XGXS_STATr_CLR(r) CDK_MEMSET(&((r)._mac_xgxs_stat), 0, sizeof(BCM56504_A0_MAC_XGXS_STATr_t))
#define BCM56504_A0_MAC_XGXS_STATr_SET(r,i,d) (r).mac_xgxs_stat[i] = d
#define BCM56504_A0_MAC_XGXS_STATr_GET(r,i) (r).mac_xgxs_stat[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MAC_XGXS_STATr_LINKf_GET(r) (((r).mac_xgxs_stat[0]) & 0x1)
#define BCM56504_A0_MAC_XGXS_STATr_LINKf_SET(r,f) (r).mac_xgxs_stat[0]=(((r).mac_xgxs_stat[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_MAC_XGXS_STATr_RXACTf_GET(r) ((((r).mac_xgxs_stat[0]) >> 1) & 0x1)
#define BCM56504_A0_MAC_XGXS_STATr_RXACTf_SET(r,f) (r).mac_xgxs_stat[0]=(((r).mac_xgxs_stat[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_MAC_XGXS_STATr_SEQDONEf_GET(r) ((((r).mac_xgxs_stat[0]) >> 2) & 0x1)
#define BCM56504_A0_MAC_XGXS_STATr_SEQDONEf_SET(r,f) (r).mac_xgxs_stat[0]=(((r).mac_xgxs_stat[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_MAC_XGXS_STATr_TXPLL_LOCKf_GET(r) ((((r).mac_xgxs_stat[0]) >> 3) & 0x1)
#define BCM56504_A0_MAC_XGXS_STATr_TXPLL_LOCKf_SET(r,f) (r).mac_xgxs_stat[0]=(((r).mac_xgxs_stat[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_MAC_XGXS_STATr_TXACTf_GET(r) ((((r).mac_xgxs_stat[0]) >> 4) & 0x1)
#define BCM56504_A0_MAC_XGXS_STATr_TXACTf_SET(r,f) (r).mac_xgxs_stat[0]=(((r).mac_xgxs_stat[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56504_A0_MAC_XGXS_STATr_TXFIFO_ERRf_GET(r) ((((r).mac_xgxs_stat[0]) >> 5) & 0x1)
#define BCM56504_A0_MAC_XGXS_STATr_TXFIFO_ERRf_SET(r,f) (r).mac_xgxs_stat[0]=(((r).mac_xgxs_stat[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56504_A0_MAC_XGXS_STATr_RMTFLTf_GET(r) ((((r).mac_xgxs_stat[0]) >> 6) & 0x1)
#define BCM56504_A0_MAC_XGXS_STATr_RMTFLTf_SET(r,f) (r).mac_xgxs_stat[0]=(((r).mac_xgxs_stat[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56504_A0_MAC_XGXS_STATr_BRKLINKf_GET(r) ((((r).mac_xgxs_stat[0]) >> 7) & 0x1)
#define BCM56504_A0_MAC_XGXS_STATr_BRKLINKf_SET(r,f) (r).mac_xgxs_stat[0]=(((r).mac_xgxs_stat[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access MAC_XGXS_Stat.
 *
 */
#define BCM56504_A0_READ_MAC_XGXS_STATr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56504_A0_MAC_XGXS_STATr,(r._mac_xgxs_stat))
#define BCM56504_A0_WRITE_MAC_XGXS_STATr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56504_A0_MAC_XGXS_STATr,&(r._mac_xgxs_stat))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAC_XGXS_STATr BCM56504_A0_MAC_XGXS_STATr
#define MAC_XGXS_STATr_SIZE BCM56504_A0_MAC_XGXS_STATr_SIZE
typedef BCM56504_A0_MAC_XGXS_STATr_t MAC_XGXS_STATr_t;
#define MAC_XGXS_STATr_CLR BCM56504_A0_MAC_XGXS_STATr_CLR
#define MAC_XGXS_STATr_SET BCM56504_A0_MAC_XGXS_STATr_SET
#define MAC_XGXS_STATr_GET BCM56504_A0_MAC_XGXS_STATr_GET
#define MAC_XGXS_STATr_LINKf_GET BCM56504_A0_MAC_XGXS_STATr_LINKf_GET
#define MAC_XGXS_STATr_LINKf_SET BCM56504_A0_MAC_XGXS_STATr_LINKf_SET
#define MAC_XGXS_STATr_RXACTf_GET BCM56504_A0_MAC_XGXS_STATr_RXACTf_GET
#define MAC_XGXS_STATr_RXACTf_SET BCM56504_A0_MAC_XGXS_STATr_RXACTf_SET
#define MAC_XGXS_STATr_SEQDONEf_GET BCM56504_A0_MAC_XGXS_STATr_SEQDONEf_GET
#define MAC_XGXS_STATr_SEQDONEf_SET BCM56504_A0_MAC_XGXS_STATr_SEQDONEf_SET
#define MAC_XGXS_STATr_TXPLL_LOCKf_GET BCM56504_A0_MAC_XGXS_STATr_TXPLL_LOCKf_GET
#define MAC_XGXS_STATr_TXPLL_LOCKf_SET BCM56504_A0_MAC_XGXS_STATr_TXPLL_LOCKf_SET
#define MAC_XGXS_STATr_TXACTf_GET BCM56504_A0_MAC_XGXS_STATr_TXACTf_GET
#define MAC_XGXS_STATr_TXACTf_SET BCM56504_A0_MAC_XGXS_STATr_TXACTf_SET
#define MAC_XGXS_STATr_TXFIFO_ERRf_GET BCM56504_A0_MAC_XGXS_STATr_TXFIFO_ERRf_GET
#define MAC_XGXS_STATr_TXFIFO_ERRf_SET BCM56504_A0_MAC_XGXS_STATr_TXFIFO_ERRf_SET
#define MAC_XGXS_STATr_RMTFLTf_GET BCM56504_A0_MAC_XGXS_STATr_RMTFLTf_GET
#define MAC_XGXS_STATr_RMTFLTf_SET BCM56504_A0_MAC_XGXS_STATr_RMTFLTf_SET
#define MAC_XGXS_STATr_BRKLINKf_GET BCM56504_A0_MAC_XGXS_STATr_BRKLINKf_GET
#define MAC_XGXS_STATr_BRKLINKf_SET BCM56504_A0_MAC_XGXS_STATr_BRKLINKf_SET
#define READ_MAC_XGXS_STATr BCM56504_A0_READ_MAC_XGXS_STATr
#define WRITE_MAC_XGXS_STATr BCM56504_A0_WRITE_MAC_XGXS_STATr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MAC_XGXS_STATr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  MAXBUCKET
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     MAX_BUCKET       Maximum rate bucket. Each unit represents 64k bits.
 *     IN_PROFILE_FLAG  IN_PROFILE_FLAG inidcates the current state of maximum rate bucket1: out of profile0: In profileDefault value is in profile.
 *
 ******************************************************************************/
#define BCM56504_A0_MAXBUCKETr 0x00600068

#define BCM56504_A0_MAXBUCKETr_SIZE 4

/*
 * This structure should be used to declare and program MAXBUCKET.
 *
 */
typedef union BCM56504_A0_MAXBUCKETr_s {
	uint32_t v[1];
	uint32_t maxbucket[1];
	uint32_t _maxbucket;
} BCM56504_A0_MAXBUCKETr_t;

#define BCM56504_A0_MAXBUCKETr_CLR(r) (r).maxbucket[0] = 0
#define BCM56504_A0_MAXBUCKETr_SET(r,d) (r).maxbucket[0] = d
#define BCM56504_A0_MAXBUCKETr_GET(r) (r).maxbucket[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MAXBUCKETr_MAX_BUCKETf_GET(r) (((r).maxbucket[0]) & 0x1fffffff)
#define BCM56504_A0_MAXBUCKETr_MAX_BUCKETf_SET(r,f) (r).maxbucket[0]=(((r).maxbucket[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM56504_A0_MAXBUCKETr_IN_PROFILE_FLAGf_GET(r) ((((r).maxbucket[0]) >> 29) & 0x1)
#define BCM56504_A0_MAXBUCKETr_IN_PROFILE_FLAGf_SET(r,f) (r).maxbucket[0]=(((r).maxbucket[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))

/*
 * These macros can be used to access MAXBUCKET.
 *
 */
#define BCM56504_A0_READ_MAXBUCKETr(u,p,i,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_MAXBUCKETr+(i),(r._maxbucket))
#define BCM56504_A0_WRITE_MAXBUCKETr(u,p,i,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_MAXBUCKETr+(i),&(r._maxbucket))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAXBUCKETr BCM56504_A0_MAXBUCKETr
#define MAXBUCKETr_SIZE BCM56504_A0_MAXBUCKETr_SIZE
typedef BCM56504_A0_MAXBUCKETr_t MAXBUCKETr_t;
#define MAXBUCKETr_CLR BCM56504_A0_MAXBUCKETr_CLR
#define MAXBUCKETr_SET BCM56504_A0_MAXBUCKETr_SET
#define MAXBUCKETr_GET BCM56504_A0_MAXBUCKETr_GET
#define MAXBUCKETr_MAX_BUCKETf_GET BCM56504_A0_MAXBUCKETr_MAX_BUCKETf_GET
#define MAXBUCKETr_MAX_BUCKETf_SET BCM56504_A0_MAXBUCKETr_MAX_BUCKETf_SET
#define MAXBUCKETr_IN_PROFILE_FLAGf_GET BCM56504_A0_MAXBUCKETr_IN_PROFILE_FLAGf_GET
#define MAXBUCKETr_IN_PROFILE_FLAGf_SET BCM56504_A0_MAXBUCKETr_IN_PROFILE_FLAGf_SET
#define READ_MAXBUCKETr BCM56504_A0_READ_MAXBUCKETr
#define WRITE_MAXBUCKETr BCM56504_A0_WRITE_MAXBUCKETr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MAXBUCKETr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  MAXBUCKETCONFIG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     MAX_THD_SEL      Threshold for maximum rate bucket.0x0:  Disable0x1:  32k bits. (32*1024)0x2:  64k bits. (64*1024)0x3: 128k bits. (128*1024)0x4: 256k bits. (256*1024)0x5: 512k bits. (512*1024)0x6:   1M bits. (1024*1024)0x7:   2M bits. (2*1024*1024)0x8:   4M bits. (4*1024*1024)0x9:   8M bits. (8*1024*1024)0xa:  16M bits. (16*1024*1024)0xb:  32M bits. (32*1024*1024)0xc:  64M bits. (64*1024*1024)0xd: 128M bits. (128*1024*1024)0xe: 128M bits. (128*1024*1024) setting satuated at 0xd 0xf: 128M bits. (128*1024*1024) setting satuated at 0xd
 *     MAX_REFRESH      Refresh count for maximum rate bucket. Each unit of REFRESH represents 64 kbps. To use max bucket feature, MISCCONFIG.METERING_CLK_EN need to be set enable.
 *
 ******************************************************************************/
#define BCM56504_A0_MAXBUCKETCONFIGr 0x00600060

#define BCM56504_A0_MAXBUCKETCONFIGr_SIZE 4

/*
 * This structure should be used to declare and program MAXBUCKETCONFIG.
 *
 */
typedef union BCM56504_A0_MAXBUCKETCONFIGr_s {
	uint32_t v[1];
	uint32_t maxbucketconfig[1];
	uint32_t _maxbucketconfig;
} BCM56504_A0_MAXBUCKETCONFIGr_t;

#define BCM56504_A0_MAXBUCKETCONFIGr_CLR(r) (r).maxbucketconfig[0] = 0
#define BCM56504_A0_MAXBUCKETCONFIGr_SET(r,d) (r).maxbucketconfig[0] = d
#define BCM56504_A0_MAXBUCKETCONFIGr_GET(r) (r).maxbucketconfig[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MAXBUCKETCONFIGr_MAX_THD_SELf_GET(r) (((r).maxbucketconfig[0]) & 0xf)
#define BCM56504_A0_MAXBUCKETCONFIGr_MAX_THD_SELf_SET(r,f) (r).maxbucketconfig[0]=(((r).maxbucketconfig[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56504_A0_MAXBUCKETCONFIGr_MAX_REFRESHf_GET(r) ((((r).maxbucketconfig[0]) >> 4) & 0x3ffff)
#define BCM56504_A0_MAXBUCKETCONFIGr_MAX_REFRESHf_SET(r,f) (r).maxbucketconfig[0]=(((r).maxbucketconfig[0] & ~((uint32_t)0x3ffff << 4)) | ((((uint32_t)f) & 0x3ffff) << 4))

/*
 * These macros can be used to access MAXBUCKETCONFIG.
 *
 */
#define BCM56504_A0_READ_MAXBUCKETCONFIGr(u,p,i,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_MAXBUCKETCONFIGr+(i),(r._maxbucketconfig))
#define BCM56504_A0_WRITE_MAXBUCKETCONFIGr(u,p,i,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_MAXBUCKETCONFIGr+(i),&(r._maxbucketconfig))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAXBUCKETCONFIGr BCM56504_A0_MAXBUCKETCONFIGr
#define MAXBUCKETCONFIGr_SIZE BCM56504_A0_MAXBUCKETCONFIGr_SIZE
typedef BCM56504_A0_MAXBUCKETCONFIGr_t MAXBUCKETCONFIGr_t;
#define MAXBUCKETCONFIGr_CLR BCM56504_A0_MAXBUCKETCONFIGr_CLR
#define MAXBUCKETCONFIGr_SET BCM56504_A0_MAXBUCKETCONFIGr_SET
#define MAXBUCKETCONFIGr_GET BCM56504_A0_MAXBUCKETCONFIGr_GET
#define MAXBUCKETCONFIGr_MAX_THD_SELf_GET BCM56504_A0_MAXBUCKETCONFIGr_MAX_THD_SELf_GET
#define MAXBUCKETCONFIGr_MAX_THD_SELf_SET BCM56504_A0_MAXBUCKETCONFIGr_MAX_THD_SELf_SET
#define MAXBUCKETCONFIGr_MAX_REFRESHf_GET BCM56504_A0_MAXBUCKETCONFIGr_MAX_REFRESHf_GET
#define MAXBUCKETCONFIGr_MAX_REFRESHf_SET BCM56504_A0_MAXBUCKETCONFIGr_MAX_REFRESHf_SET
#define READ_MAXBUCKETCONFIGr BCM56504_A0_READ_MAXBUCKETCONFIGr
#define WRITE_MAXBUCKETCONFIGr BCM56504_A0_WRITE_MAXBUCKETCONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MAXBUCKETCONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  MAXFR
 * BLOCKS:   GPORT0
 * DESC:     Max Frame Length
 * SIZE:     32
 * FIELDS:
 *     MAXFR            Max Frame Length is now 1518 Decimal
 *
 ******************************************************************************/
#define BCM56504_A0_MAXFRr 0x00f00108

#define BCM56504_A0_MAXFRr_SIZE 4

/*
 * This structure should be used to declare and program MAXFR.
 *
 */
typedef union BCM56504_A0_MAXFRr_s {
	uint32_t v[1];
	uint32_t maxfr[1];
	uint32_t _maxfr;
} BCM56504_A0_MAXFRr_t;

#define BCM56504_A0_MAXFRr_CLR(r) (r).maxfr[0] = 0
#define BCM56504_A0_MAXFRr_SET(r,d) (r).maxfr[0] = d
#define BCM56504_A0_MAXFRr_GET(r) (r).maxfr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MAXFRr_MAXFRf_GET(r) (((r).maxfr[0]) & 0xffff)
#define BCM56504_A0_MAXFRr_MAXFRf_SET(r,f) (r).maxfr[0]=(((r).maxfr[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access MAXFR.
 *
 */
#define BCM56504_A0_READ_MAXFRr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_MAXFRr,(r._maxfr))
#define BCM56504_A0_WRITE_MAXFRr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_MAXFRr,&(r._maxfr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAXFRr BCM56504_A0_MAXFRr
#define MAXFRr_SIZE BCM56504_A0_MAXFRr_SIZE
typedef BCM56504_A0_MAXFRr_t MAXFRr_t;
#define MAXFRr_CLR BCM56504_A0_MAXFRr_CLR
#define MAXFRr_SET BCM56504_A0_MAXFRr_SET
#define MAXFRr_GET BCM56504_A0_MAXFRr_GET
#define MAXFRr_MAXFRf_GET BCM56504_A0_MAXFRr_MAXFRf_GET
#define MAXFRr_MAXFRf_SET BCM56504_A0_MAXFRr_MAXFRf_SET
#define READ_MAXFRr BCM56504_A0_READ_MAXFRr
#define WRITE_MAXFRr BCM56504_A0_WRITE_MAXFRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MAXFRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  MCAST_STORM_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     Ethernet Multicast Rate Control Registers
 * SIZE:     32
 * FIELDS:
 *     THRESHOLD        Rate Limit, count as number of packets
 *     ENABLE           Multicast rate control enable
 *
 ******************************************************************************/
#define BCM56504_A0_MCAST_STORM_CONTROLr 0x0b700002

#define BCM56504_A0_MCAST_STORM_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program MCAST_STORM_CONTROL.
 *
 */
typedef union BCM56504_A0_MCAST_STORM_CONTROLr_s {
	uint32_t v[1];
	uint32_t mcast_storm_control[1];
	uint32_t _mcast_storm_control;
} BCM56504_A0_MCAST_STORM_CONTROLr_t;

#define BCM56504_A0_MCAST_STORM_CONTROLr_CLR(r) (r).mcast_storm_control[0] = 0
#define BCM56504_A0_MCAST_STORM_CONTROLr_SET(r,d) (r).mcast_storm_control[0] = d
#define BCM56504_A0_MCAST_STORM_CONTROLr_GET(r) (r).mcast_storm_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MCAST_STORM_CONTROLr_THRESHOLDf_GET(r) (((r).mcast_storm_control[0]) & 0x1ffffff)
#define BCM56504_A0_MCAST_STORM_CONTROLr_THRESHOLDf_SET(r,f) (r).mcast_storm_control[0]=(((r).mcast_storm_control[0] & ~((uint32_t)0x1ffffff)) | (((uint32_t)f) & 0x1ffffff))
#define BCM56504_A0_MCAST_STORM_CONTROLr_ENABLEf_GET(r) ((((r).mcast_storm_control[0]) >> 25) & 0x1)
#define BCM56504_A0_MCAST_STORM_CONTROLr_ENABLEf_SET(r,f) (r).mcast_storm_control[0]=(((r).mcast_storm_control[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))

/*
 * These macros can be used to access MCAST_STORM_CONTROL.
 *
 */
#define BCM56504_A0_READ_MCAST_STORM_CONTROLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_MCAST_STORM_CONTROLr,(r._mcast_storm_control))
#define BCM56504_A0_WRITE_MCAST_STORM_CONTROLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_MCAST_STORM_CONTROLr,&(r._mcast_storm_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MCAST_STORM_CONTROLr BCM56504_A0_MCAST_STORM_CONTROLr
#define MCAST_STORM_CONTROLr_SIZE BCM56504_A0_MCAST_STORM_CONTROLr_SIZE
typedef BCM56504_A0_MCAST_STORM_CONTROLr_t MCAST_STORM_CONTROLr_t;
#define MCAST_STORM_CONTROLr_CLR BCM56504_A0_MCAST_STORM_CONTROLr_CLR
#define MCAST_STORM_CONTROLr_SET BCM56504_A0_MCAST_STORM_CONTROLr_SET
#define MCAST_STORM_CONTROLr_GET BCM56504_A0_MCAST_STORM_CONTROLr_GET
#define MCAST_STORM_CONTROLr_THRESHOLDf_GET BCM56504_A0_MCAST_STORM_CONTROLr_THRESHOLDf_GET
#define MCAST_STORM_CONTROLr_THRESHOLDf_SET BCM56504_A0_MCAST_STORM_CONTROLr_THRESHOLDf_SET
#define MCAST_STORM_CONTROLr_ENABLEf_GET BCM56504_A0_MCAST_STORM_CONTROLr_ENABLEf_GET
#define MCAST_STORM_CONTROLr_ENABLEf_SET BCM56504_A0_MCAST_STORM_CONTROLr_ENABLEf_SET
#define READ_MCAST_STORM_CONTROLr BCM56504_A0_READ_MCAST_STORM_CONTROLr
#define WRITE_MCAST_STORM_CONTROLr BCM56504_A0_WRITE_MCAST_STORM_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MCAST_STORM_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  MEMFAILINTMASK
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CFAPFAILINTMASK  MMU Memfail Interrupt enable bit to enable MMU MemFail Interrupt for CFAP memory stack underrun or overrun condition.1: Enable MMU MemFail Interrupt. 0: Disable MMU MemFail Interrupt. Default.
 *     SOFTRESETINTMASK MMU Memfail Interrupt enable bit to enable MMU MemFail Interrupt for receiving a first cell follow by a first cell without end cell condition.1: Enable MMU MemFail Interrupt. 0: Disable MMU MemFail Interrupt. Default. 
 *     CELLNOTIPINTMASK MMU Memfail Interrupt enable bit to enable MMU MemFail Interrupt fordetecting sending out garbage cells not in packet process. ie. Cell after End-Cell without a start bit. or Two Start cell without anEnd Cell in between.1: Enable MMU MemFail Interrupt. 0: Disable MMU MemFail Interrupt. Default. 
 *     CRCERRORINTMASK  MMU Memfail Interrupt Mask bit to enable MMU MemFail Interrupt fordetecting a failure of CBP cell data memory crc error condition.1: Enable MMU MemFail Interrupt. 0: Disable MMU MemFail Interrupt. Default. 
 *     CBPPKTHDRPARITYERRORINTMASK MMU Memfail Interrupt Mask bit to enable MMU MemFail Interrupt fordetecting a failure of CBP packet header memory parity error condition.1: Enable MMU MemFail Interrupt. 0: Disable MMU MemFail Interrupt. Default. 
 *     CBPCELLHDRPARITYERRORINTMASK MMU Memfail Interrupt Mask bit to enable MMU MemFail Interrupt whendetecting a failure of CBP cell header memory parity error condition.1: Enable MMU MemFail Interrupt. 0: Disable MMU MemFail Interrupt. Default. 
 *     XQPARITYERRORINTMASK MMU Memfail Interrupt Mask to enable MMU send out MemFail Interrupt whendetecting a failure of XQ memory parity error condition.1: Enable MMU MemFail Interrupt. 0: Disable MMU MemFail Interrupt. Default. 
 *     CFAPPARITYERRORINTMASK MMU CFAP Memory parity fail status for detecting cfap memory parity error. 1: Enable MMU MemFail Interrupt. 0: Disable MMU MemFail Interrupt. Default. 
 *     CCPPARITYERRORINTMASK MMU CCP Memory parity fail interrupt Mask for detecting ccp memory parity error.1: Enable MMU MemFail Interrupt. 0: Disable MMU MemFail Interrupt. Default. 
 *     IPMCREPOVERLIMITERRORINTMASK IPMC Replication Over Pre-set Replication Limit error Int Mask for egress port sending oevr limit IPMC replication packet on a specific cos. 1: Enable MMU MemFail Interrupt. 0: Disable MMU MemFail Interrupt. Default. 
 *
 ******************************************************************************/
#define BCM56504_A0_MEMFAILINTMASKr 0x00680030

#define BCM56504_A0_MEMFAILINTMASKr_SIZE 4

/*
 * This structure should be used to declare and program MEMFAILINTMASK.
 *
 */
typedef union BCM56504_A0_MEMFAILINTMASKr_s {
	uint32_t v[1];
	uint32_t memfailintmask[1];
	uint32_t _memfailintmask;
} BCM56504_A0_MEMFAILINTMASKr_t;

#define BCM56504_A0_MEMFAILINTMASKr_CLR(r) (r).memfailintmask[0] = 0
#define BCM56504_A0_MEMFAILINTMASKr_SET(r,d) (r).memfailintmask[0] = d
#define BCM56504_A0_MEMFAILINTMASKr_GET(r) (r).memfailintmask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MEMFAILINTMASKr_CFAPFAILINTMASKf_GET(r) (((r).memfailintmask[0]) & 0x1)
#define BCM56504_A0_MEMFAILINTMASKr_CFAPFAILINTMASKf_SET(r,f) (r).memfailintmask[0]=(((r).memfailintmask[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_MEMFAILINTMASKr_SOFTRESETINTMASKf_GET(r) ((((r).memfailintmask[0]) >> 1) & 0x1)
#define BCM56504_A0_MEMFAILINTMASKr_SOFTRESETINTMASKf_SET(r,f) (r).memfailintmask[0]=(((r).memfailintmask[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_MEMFAILINTMASKr_CELLNOTIPINTMASKf_GET(r) ((((r).memfailintmask[0]) >> 2) & 0x1)
#define BCM56504_A0_MEMFAILINTMASKr_CELLNOTIPINTMASKf_SET(r,f) (r).memfailintmask[0]=(((r).memfailintmask[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_MEMFAILINTMASKr_CRCERRORINTMASKf_GET(r) ((((r).memfailintmask[0]) >> 3) & 0x1)
#define BCM56504_A0_MEMFAILINTMASKr_CRCERRORINTMASKf_SET(r,f) (r).memfailintmask[0]=(((r).memfailintmask[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_MEMFAILINTMASKr_CBPPKTHDRPARITYERRORINTMASKf_GET(r) ((((r).memfailintmask[0]) >> 4) & 0x1)
#define BCM56504_A0_MEMFAILINTMASKr_CBPPKTHDRPARITYERRORINTMASKf_SET(r,f) (r).memfailintmask[0]=(((r).memfailintmask[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56504_A0_MEMFAILINTMASKr_CBPCELLHDRPARITYERRORINTMASKf_GET(r) ((((r).memfailintmask[0]) >> 5) & 0x1)
#define BCM56504_A0_MEMFAILINTMASKr_CBPCELLHDRPARITYERRORINTMASKf_SET(r,f) (r).memfailintmask[0]=(((r).memfailintmask[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56504_A0_MEMFAILINTMASKr_XQPARITYERRORINTMASKf_GET(r) ((((r).memfailintmask[0]) >> 6) & 0x1)
#define BCM56504_A0_MEMFAILINTMASKr_XQPARITYERRORINTMASKf_SET(r,f) (r).memfailintmask[0]=(((r).memfailintmask[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56504_A0_MEMFAILINTMASKr_CFAPPARITYERRORINTMASKf_GET(r) ((((r).memfailintmask[0]) >> 7) & 0x1)
#define BCM56504_A0_MEMFAILINTMASKr_CFAPPARITYERRORINTMASKf_SET(r,f) (r).memfailintmask[0]=(((r).memfailintmask[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56504_A0_MEMFAILINTMASKr_CCPPARITYERRORINTMASKf_GET(r) ((((r).memfailintmask[0]) >> 8) & 0x1)
#define BCM56504_A0_MEMFAILINTMASKr_CCPPARITYERRORINTMASKf_SET(r,f) (r).memfailintmask[0]=(((r).memfailintmask[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56504_A0_MEMFAILINTMASKr_IPMCREPOVERLIMITERRORINTMASKf_GET(r) ((((r).memfailintmask[0]) >> 9) & 0x1)
#define BCM56504_A0_MEMFAILINTMASKr_IPMCREPOVERLIMITERRORINTMASKf_SET(r,f) (r).memfailintmask[0]=(((r).memfailintmask[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))

/*
 * These macros can be used to access MEMFAILINTMASK.
 *
 */
#define BCM56504_A0_READ_MEMFAILINTMASKr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_MEMFAILINTMASKr,(r._memfailintmask))
#define BCM56504_A0_WRITE_MEMFAILINTMASKr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_MEMFAILINTMASKr,&(r._memfailintmask))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEMFAILINTMASKr BCM56504_A0_MEMFAILINTMASKr
#define MEMFAILINTMASKr_SIZE BCM56504_A0_MEMFAILINTMASKr_SIZE
typedef BCM56504_A0_MEMFAILINTMASKr_t MEMFAILINTMASKr_t;
#define MEMFAILINTMASKr_CLR BCM56504_A0_MEMFAILINTMASKr_CLR
#define MEMFAILINTMASKr_SET BCM56504_A0_MEMFAILINTMASKr_SET
#define MEMFAILINTMASKr_GET BCM56504_A0_MEMFAILINTMASKr_GET
#define MEMFAILINTMASKr_CFAPFAILINTMASKf_GET BCM56504_A0_MEMFAILINTMASKr_CFAPFAILINTMASKf_GET
#define MEMFAILINTMASKr_CFAPFAILINTMASKf_SET BCM56504_A0_MEMFAILINTMASKr_CFAPFAILINTMASKf_SET
#define MEMFAILINTMASKr_SOFTRESETINTMASKf_GET BCM56504_A0_MEMFAILINTMASKr_SOFTRESETINTMASKf_GET
#define MEMFAILINTMASKr_SOFTRESETINTMASKf_SET BCM56504_A0_MEMFAILINTMASKr_SOFTRESETINTMASKf_SET
#define MEMFAILINTMASKr_CELLNOTIPINTMASKf_GET BCM56504_A0_MEMFAILINTMASKr_CELLNOTIPINTMASKf_GET
#define MEMFAILINTMASKr_CELLNOTIPINTMASKf_SET BCM56504_A0_MEMFAILINTMASKr_CELLNOTIPINTMASKf_SET
#define MEMFAILINTMASKr_CRCERRORINTMASKf_GET BCM56504_A0_MEMFAILINTMASKr_CRCERRORINTMASKf_GET
#define MEMFAILINTMASKr_CRCERRORINTMASKf_SET BCM56504_A0_MEMFAILINTMASKr_CRCERRORINTMASKf_SET
#define MEMFAILINTMASKr_CBPPKTHDRPARITYERRORINTMASKf_GET BCM56504_A0_MEMFAILINTMASKr_CBPPKTHDRPARITYERRORINTMASKf_GET
#define MEMFAILINTMASKr_CBPPKTHDRPARITYERRORINTMASKf_SET BCM56504_A0_MEMFAILINTMASKr_CBPPKTHDRPARITYERRORINTMASKf_SET
#define MEMFAILINTMASKr_CBPCELLHDRPARITYERRORINTMASKf_GET BCM56504_A0_MEMFAILINTMASKr_CBPCELLHDRPARITYERRORINTMASKf_GET
#define MEMFAILINTMASKr_CBPCELLHDRPARITYERRORINTMASKf_SET BCM56504_A0_MEMFAILINTMASKr_CBPCELLHDRPARITYERRORINTMASKf_SET
#define MEMFAILINTMASKr_XQPARITYERRORINTMASKf_GET BCM56504_A0_MEMFAILINTMASKr_XQPARITYERRORINTMASKf_GET
#define MEMFAILINTMASKr_XQPARITYERRORINTMASKf_SET BCM56504_A0_MEMFAILINTMASKr_XQPARITYERRORINTMASKf_SET
#define MEMFAILINTMASKr_CFAPPARITYERRORINTMASKf_GET BCM56504_A0_MEMFAILINTMASKr_CFAPPARITYERRORINTMASKf_GET
#define MEMFAILINTMASKr_CFAPPARITYERRORINTMASKf_SET BCM56504_A0_MEMFAILINTMASKr_CFAPPARITYERRORINTMASKf_SET
#define MEMFAILINTMASKr_CCPPARITYERRORINTMASKf_GET BCM56504_A0_MEMFAILINTMASKr_CCPPARITYERRORINTMASKf_GET
#define MEMFAILINTMASKr_CCPPARITYERRORINTMASKf_SET BCM56504_A0_MEMFAILINTMASKr_CCPPARITYERRORINTMASKf_SET
#define MEMFAILINTMASKr_IPMCREPOVERLIMITERRORINTMASKf_GET BCM56504_A0_MEMFAILINTMASKr_IPMCREPOVERLIMITERRORINTMASKf_GET
#define MEMFAILINTMASKr_IPMCREPOVERLIMITERRORINTMASKf_SET BCM56504_A0_MEMFAILINTMASKr_IPMCREPOVERLIMITERRORINTMASKf_SET
#define READ_MEMFAILINTMASKr BCM56504_A0_READ_MEMFAILINTMASKr
#define WRITE_MEMFAILINTMASKr BCM56504_A0_WRITE_MEMFAILINTMASKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MEMFAILINTMASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  MEMFAILINTSTATUS
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CFAPFAILERROR    MMU CFAP Fail Status for CFAP memory stack underrun or overrun condition. When detect an error it stay set until a register read to clear this status. 
 *     SOFTRESETERROR   MMU detect software reset error status for receiving a first cell follow by a first cell without end cell condition.When detect an error it stay set until a register read to clear this status. 
 *     CELLNOTIPERROR   MMU Sending Cell Not In Progress error status for MMU sending out garbage cells not in packet. ie. Cell after End-Cell without a start bit.When detect an error it stay set until a register read to clear this status. 
 *     CELLCRCERROR     MMU CBP cell data crc fail status for detecting data emory crc error. When detect an error it stay set until a register read to clear this status. 
 *     CBPPKTHDRPARITYERROR MMU CBP Packet Header Memory parity fail status for detecting packet header memory parity error. When detect an error it stay set until a register read to clear this status. 
 *     CBPCELLHDRPARITYERROR MMU CBP Cell Header Memory parity fail status for detecting cell header memory parity error. CBP Cell Header Memory parity bit [32] covered from bit 0 bit 15. Cell CRC checksum field, bit 16 to bit 31, is not covered by paritycheck. When an error is detected, it stays set until a register read to clear this status. 
 *     XQPARITYERROR    MMU XQ Memory parity fail status for detecting xq memory parity error. When detect an error it stay set until a register read to clear this status. 
 *     CFAPPARITYERROR  MMU CFAP Memory parity fail status for detecting cfap memory parity error. When detect an error it stay set until a register read to clear this status. 
 *     CCPPARITYERROR   MMU CCP Memory parity fail status for detecting ccp memory parity error. When detect an error it stay set until a register read to clear this status. 
 *     IPMCREPOVERLIMITERROR IPMC Replication Over Pre-set Replication Limit error status for egress port sending oevr limit IPMC replication packet on a specific cos. 
 *     MEMFAILINTCOUNT  Mem Fail Message Counter to count mem fail events. 
 *
 ******************************************************************************/
#define BCM56504_A0_MEMFAILINTSTATUSr 0x00680031

#define BCM56504_A0_MEMFAILINTSTATUSr_SIZE 4

/*
 * This structure should be used to declare and program MEMFAILINTSTATUS.
 *
 */
typedef union BCM56504_A0_MEMFAILINTSTATUSr_s {
	uint32_t v[1];
	uint32_t memfailintstatus[1];
	uint32_t _memfailintstatus;
} BCM56504_A0_MEMFAILINTSTATUSr_t;

#define BCM56504_A0_MEMFAILINTSTATUSr_CLR(r) (r).memfailintstatus[0] = 0
#define BCM56504_A0_MEMFAILINTSTATUSr_SET(r,d) (r).memfailintstatus[0] = d
#define BCM56504_A0_MEMFAILINTSTATUSr_GET(r) (r).memfailintstatus[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MEMFAILINTSTATUSr_CFAPFAILERRORf_GET(r) (((r).memfailintstatus[0]) & 0x1)
#define BCM56504_A0_MEMFAILINTSTATUSr_CFAPFAILERRORf_SET(r,f) (r).memfailintstatus[0]=(((r).memfailintstatus[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_MEMFAILINTSTATUSr_SOFTRESETERRORf_GET(r) ((((r).memfailintstatus[0]) >> 1) & 0x1)
#define BCM56504_A0_MEMFAILINTSTATUSr_SOFTRESETERRORf_SET(r,f) (r).memfailintstatus[0]=(((r).memfailintstatus[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_MEMFAILINTSTATUSr_CELLNOTIPERRORf_GET(r) ((((r).memfailintstatus[0]) >> 2) & 0x1)
#define BCM56504_A0_MEMFAILINTSTATUSr_CELLNOTIPERRORf_SET(r,f) (r).memfailintstatus[0]=(((r).memfailintstatus[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_MEMFAILINTSTATUSr_CELLCRCERRORf_GET(r) ((((r).memfailintstatus[0]) >> 3) & 0x1)
#define BCM56504_A0_MEMFAILINTSTATUSr_CELLCRCERRORf_SET(r,f) (r).memfailintstatus[0]=(((r).memfailintstatus[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_MEMFAILINTSTATUSr_CBPPKTHDRPARITYERRORf_GET(r) ((((r).memfailintstatus[0]) >> 4) & 0x1)
#define BCM56504_A0_MEMFAILINTSTATUSr_CBPPKTHDRPARITYERRORf_SET(r,f) (r).memfailintstatus[0]=(((r).memfailintstatus[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56504_A0_MEMFAILINTSTATUSr_CBPCELLHDRPARITYERRORf_GET(r) ((((r).memfailintstatus[0]) >> 5) & 0x1)
#define BCM56504_A0_MEMFAILINTSTATUSr_CBPCELLHDRPARITYERRORf_SET(r,f) (r).memfailintstatus[0]=(((r).memfailintstatus[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56504_A0_MEMFAILINTSTATUSr_XQPARITYERRORf_GET(r) ((((r).memfailintstatus[0]) >> 6) & 0x1)
#define BCM56504_A0_MEMFAILINTSTATUSr_XQPARITYERRORf_SET(r,f) (r).memfailintstatus[0]=(((r).memfailintstatus[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56504_A0_MEMFAILINTSTATUSr_CFAPPARITYERRORf_GET(r) ((((r).memfailintstatus[0]) >> 7) & 0x1)
#define BCM56504_A0_MEMFAILINTSTATUSr_CFAPPARITYERRORf_SET(r,f) (r).memfailintstatus[0]=(((r).memfailintstatus[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56504_A0_MEMFAILINTSTATUSr_CCPPARITYERRORf_GET(r) ((((r).memfailintstatus[0]) >> 8) & 0x1)
#define BCM56504_A0_MEMFAILINTSTATUSr_CCPPARITYERRORf_SET(r,f) (r).memfailintstatus[0]=(((r).memfailintstatus[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56504_A0_MEMFAILINTSTATUSr_IPMCREPOVERLIMITERRORf_GET(r) ((((r).memfailintstatus[0]) >> 9) & 0x1)
#define BCM56504_A0_MEMFAILINTSTATUSr_IPMCREPOVERLIMITERRORf_SET(r,f) (r).memfailintstatus[0]=(((r).memfailintstatus[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56504_A0_MEMFAILINTSTATUSr_MEMFAILINTCOUNTf_GET(r) ((((r).memfailintstatus[0]) >> 10) & 0xffff)
#define BCM56504_A0_MEMFAILINTSTATUSr_MEMFAILINTCOUNTf_SET(r,f) (r).memfailintstatus[0]=(((r).memfailintstatus[0] & ~((uint32_t)0xffff << 10)) | ((((uint32_t)f) & 0xffff) << 10))

/*
 * These macros can be used to access MEMFAILINTSTATUS.
 *
 */
#define BCM56504_A0_READ_MEMFAILINTSTATUSr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_MEMFAILINTSTATUSr,(r._memfailintstatus))
#define BCM56504_A0_WRITE_MEMFAILINTSTATUSr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_MEMFAILINTSTATUSr,&(r._memfailintstatus))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEMFAILINTSTATUSr BCM56504_A0_MEMFAILINTSTATUSr
#define MEMFAILINTSTATUSr_SIZE BCM56504_A0_MEMFAILINTSTATUSr_SIZE
typedef BCM56504_A0_MEMFAILINTSTATUSr_t MEMFAILINTSTATUSr_t;
#define MEMFAILINTSTATUSr_CLR BCM56504_A0_MEMFAILINTSTATUSr_CLR
#define MEMFAILINTSTATUSr_SET BCM56504_A0_MEMFAILINTSTATUSr_SET
#define MEMFAILINTSTATUSr_GET BCM56504_A0_MEMFAILINTSTATUSr_GET
#define MEMFAILINTSTATUSr_CFAPFAILERRORf_GET BCM56504_A0_MEMFAILINTSTATUSr_CFAPFAILERRORf_GET
#define MEMFAILINTSTATUSr_CFAPFAILERRORf_SET BCM56504_A0_MEMFAILINTSTATUSr_CFAPFAILERRORf_SET
#define MEMFAILINTSTATUSr_SOFTRESETERRORf_GET BCM56504_A0_MEMFAILINTSTATUSr_SOFTRESETERRORf_GET
#define MEMFAILINTSTATUSr_SOFTRESETERRORf_SET BCM56504_A0_MEMFAILINTSTATUSr_SOFTRESETERRORf_SET
#define MEMFAILINTSTATUSr_CELLNOTIPERRORf_GET BCM56504_A0_MEMFAILINTSTATUSr_CELLNOTIPERRORf_GET
#define MEMFAILINTSTATUSr_CELLNOTIPERRORf_SET BCM56504_A0_MEMFAILINTSTATUSr_CELLNOTIPERRORf_SET
#define MEMFAILINTSTATUSr_CELLCRCERRORf_GET BCM56504_A0_MEMFAILINTSTATUSr_CELLCRCERRORf_GET
#define MEMFAILINTSTATUSr_CELLCRCERRORf_SET BCM56504_A0_MEMFAILINTSTATUSr_CELLCRCERRORf_SET
#define MEMFAILINTSTATUSr_CBPPKTHDRPARITYERRORf_GET BCM56504_A0_MEMFAILINTSTATUSr_CBPPKTHDRPARITYERRORf_GET
#define MEMFAILINTSTATUSr_CBPPKTHDRPARITYERRORf_SET BCM56504_A0_MEMFAILINTSTATUSr_CBPPKTHDRPARITYERRORf_SET
#define MEMFAILINTSTATUSr_CBPCELLHDRPARITYERRORf_GET BCM56504_A0_MEMFAILINTSTATUSr_CBPCELLHDRPARITYERRORf_GET
#define MEMFAILINTSTATUSr_CBPCELLHDRPARITYERRORf_SET BCM56504_A0_MEMFAILINTSTATUSr_CBPCELLHDRPARITYERRORf_SET
#define MEMFAILINTSTATUSr_XQPARITYERRORf_GET BCM56504_A0_MEMFAILINTSTATUSr_XQPARITYERRORf_GET
#define MEMFAILINTSTATUSr_XQPARITYERRORf_SET BCM56504_A0_MEMFAILINTSTATUSr_XQPARITYERRORf_SET
#define MEMFAILINTSTATUSr_CFAPPARITYERRORf_GET BCM56504_A0_MEMFAILINTSTATUSr_CFAPPARITYERRORf_GET
#define MEMFAILINTSTATUSr_CFAPPARITYERRORf_SET BCM56504_A0_MEMFAILINTSTATUSr_CFAPPARITYERRORf_SET
#define MEMFAILINTSTATUSr_CCPPARITYERRORf_GET BCM56504_A0_MEMFAILINTSTATUSr_CCPPARITYERRORf_GET
#define MEMFAILINTSTATUSr_CCPPARITYERRORf_SET BCM56504_A0_MEMFAILINTSTATUSr_CCPPARITYERRORf_SET
#define MEMFAILINTSTATUSr_IPMCREPOVERLIMITERRORf_GET BCM56504_A0_MEMFAILINTSTATUSr_IPMCREPOVERLIMITERRORf_GET
#define MEMFAILINTSTATUSr_IPMCREPOVERLIMITERRORf_SET BCM56504_A0_MEMFAILINTSTATUSr_IPMCREPOVERLIMITERRORf_SET
#define MEMFAILINTSTATUSr_MEMFAILINTCOUNTf_GET BCM56504_A0_MEMFAILINTSTATUSr_MEMFAILINTCOUNTf_GET
#define MEMFAILINTSTATUSr_MEMFAILINTCOUNTf_SET BCM56504_A0_MEMFAILINTSTATUSr_MEMFAILINTCOUNTf_SET
#define READ_MEMFAILINTSTATUSr BCM56504_A0_READ_MEMFAILINTSTATUSr
#define WRITE_MEMFAILINTSTATUSr BCM56504_A0_WRITE_MEMFAILINTSTATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MEMFAILINTSTATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  MINBUCKET
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     MIN_BUCKET       Minimum rate bucket. Each unit represents 64k bits.
 *     IN_PROFILE_FLAG  IN_PROFILE_FLAG inidcates the current state of minimum rate bucket1: out of profile0: In profileDefault value is out of profile.
 *
 ******************************************************************************/
#define BCM56504_A0_MINBUCKETr 0x00600058

#define BCM56504_A0_MINBUCKETr_SIZE 4

/*
 * This structure should be used to declare and program MINBUCKET.
 *
 */
typedef union BCM56504_A0_MINBUCKETr_s {
	uint32_t v[1];
	uint32_t minbucket[1];
	uint32_t _minbucket;
} BCM56504_A0_MINBUCKETr_t;

#define BCM56504_A0_MINBUCKETr_CLR(r) (r).minbucket[0] = 0
#define BCM56504_A0_MINBUCKETr_SET(r,d) (r).minbucket[0] = d
#define BCM56504_A0_MINBUCKETr_GET(r) (r).minbucket[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MINBUCKETr_MIN_BUCKETf_GET(r) (((r).minbucket[0]) & 0x1fffffff)
#define BCM56504_A0_MINBUCKETr_MIN_BUCKETf_SET(r,f) (r).minbucket[0]=(((r).minbucket[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM56504_A0_MINBUCKETr_IN_PROFILE_FLAGf_GET(r) ((((r).minbucket[0]) >> 29) & 0x1)
#define BCM56504_A0_MINBUCKETr_IN_PROFILE_FLAGf_SET(r,f) (r).minbucket[0]=(((r).minbucket[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))

/*
 * These macros can be used to access MINBUCKET.
 *
 */
#define BCM56504_A0_READ_MINBUCKETr(u,p,i,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_MINBUCKETr+(i),(r._minbucket))
#define BCM56504_A0_WRITE_MINBUCKETr(u,p,i,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_MINBUCKETr+(i),&(r._minbucket))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MINBUCKETr BCM56504_A0_MINBUCKETr
#define MINBUCKETr_SIZE BCM56504_A0_MINBUCKETr_SIZE
typedef BCM56504_A0_MINBUCKETr_t MINBUCKETr_t;
#define MINBUCKETr_CLR BCM56504_A0_MINBUCKETr_CLR
#define MINBUCKETr_SET BCM56504_A0_MINBUCKETr_SET
#define MINBUCKETr_GET BCM56504_A0_MINBUCKETr_GET
#define MINBUCKETr_MIN_BUCKETf_GET BCM56504_A0_MINBUCKETr_MIN_BUCKETf_GET
#define MINBUCKETr_MIN_BUCKETf_SET BCM56504_A0_MINBUCKETr_MIN_BUCKETf_SET
#define MINBUCKETr_IN_PROFILE_FLAGf_GET BCM56504_A0_MINBUCKETr_IN_PROFILE_FLAGf_GET
#define MINBUCKETr_IN_PROFILE_FLAGf_SET BCM56504_A0_MINBUCKETr_IN_PROFILE_FLAGf_SET
#define READ_MINBUCKETr BCM56504_A0_READ_MINBUCKETr
#define WRITE_MINBUCKETr BCM56504_A0_WRITE_MINBUCKETr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MINBUCKETr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  MINBUCKETCONFIG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     MIN_LO_THD_SEL   Low Threshold for minimum rate bucket.0x0:  Disable0x1:  32k bits. (32*1024)0x2:  64k bits. (64*1024)0x3: 128k bits. (128*1024)0x4: 256k bits. (256*1024)0x5: 512k bits. (512*1024)0x6:   1M bits. (1024*1024)0x7:   2M bits. (2*1024*1024)0x8:   4M bits. (4*1024*1024)0x9:   8M bits. (8*1024*1024)0xa:  16M bits. (16*1024*1024)0xb:  32M bits. (32*1024*1024)0xc:  64M bits. (64*1024*1024)0xd: 128M bits. (128*1024*1024)0xe: 128M bits. (128*1024*1024) setting satuated at 0xd 0xf: 128M bits. (128*1024*1024) setting satuated at 0xd
 *     MIN_HI_THD_SEL   High Threshold for minimum rate bucket.0x0:  Disable0x1:  32k bits. (32*1024)0x2:  64k bits. (64*1024)0x3: 128k bits. (128*1024)0x4: 256k bits. (256*1024)0x5: 512k bits. (512*1024)0x6:   1M bits. (1024*1024)0x7:   2M bits. (2*1024*1024)0x8:   4M bits. (4*1024*1024)0x9:   8M bits. (8*1024*1024)0xa:  16M bits. (16*1024*1024)0xb:  32M bits. (32*1024*1024)0xc:  64M bits. (64*1024*1024)0xd: 128M bits. (128*1024*1024)0xe: 128M bits. (128*1024*1024) setting satuated at 0xd 0xf: 128M bits. (128*1024*1024) setting satuated at 0xd
 *     MIN_REFRESH      Refresh count for minimum rate bucket. Each unit of REFRESH represents 64 kbps. To use min bucket feature, MISCCONFIG.METERING_CLK_EN need to be set enable.
 *
 ******************************************************************************/
#define BCM56504_A0_MINBUCKETCONFIGr 0x00600050

#define BCM56504_A0_MINBUCKETCONFIGr_SIZE 4

/*
 * This structure should be used to declare and program MINBUCKETCONFIG.
 *
 */
typedef union BCM56504_A0_MINBUCKETCONFIGr_s {
	uint32_t v[1];
	uint32_t minbucketconfig[1];
	uint32_t _minbucketconfig;
} BCM56504_A0_MINBUCKETCONFIGr_t;

#define BCM56504_A0_MINBUCKETCONFIGr_CLR(r) (r).minbucketconfig[0] = 0
#define BCM56504_A0_MINBUCKETCONFIGr_SET(r,d) (r).minbucketconfig[0] = d
#define BCM56504_A0_MINBUCKETCONFIGr_GET(r) (r).minbucketconfig[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MINBUCKETCONFIGr_MIN_LO_THD_SELf_GET(r) (((r).minbucketconfig[0]) & 0xf)
#define BCM56504_A0_MINBUCKETCONFIGr_MIN_LO_THD_SELf_SET(r,f) (r).minbucketconfig[0]=(((r).minbucketconfig[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56504_A0_MINBUCKETCONFIGr_MIN_HI_THD_SELf_GET(r) ((((r).minbucketconfig[0]) >> 4) & 0xf)
#define BCM56504_A0_MINBUCKETCONFIGr_MIN_HI_THD_SELf_SET(r,f) (r).minbucketconfig[0]=(((r).minbucketconfig[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56504_A0_MINBUCKETCONFIGr_MIN_REFRESHf_GET(r) ((((r).minbucketconfig[0]) >> 8) & 0x3ffff)
#define BCM56504_A0_MINBUCKETCONFIGr_MIN_REFRESHf_SET(r,f) (r).minbucketconfig[0]=(((r).minbucketconfig[0] & ~((uint32_t)0x3ffff << 8)) | ((((uint32_t)f) & 0x3ffff) << 8))

/*
 * These macros can be used to access MINBUCKETCONFIG.
 *
 */
#define BCM56504_A0_READ_MINBUCKETCONFIGr(u,p,i,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_MINBUCKETCONFIGr+(i),(r._minbucketconfig))
#define BCM56504_A0_WRITE_MINBUCKETCONFIGr(u,p,i,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_MINBUCKETCONFIGr+(i),&(r._minbucketconfig))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MINBUCKETCONFIGr BCM56504_A0_MINBUCKETCONFIGr
#define MINBUCKETCONFIGr_SIZE BCM56504_A0_MINBUCKETCONFIGr_SIZE
typedef BCM56504_A0_MINBUCKETCONFIGr_t MINBUCKETCONFIGr_t;
#define MINBUCKETCONFIGr_CLR BCM56504_A0_MINBUCKETCONFIGr_CLR
#define MINBUCKETCONFIGr_SET BCM56504_A0_MINBUCKETCONFIGr_SET
#define MINBUCKETCONFIGr_GET BCM56504_A0_MINBUCKETCONFIGr_GET
#define MINBUCKETCONFIGr_MIN_LO_THD_SELf_GET BCM56504_A0_MINBUCKETCONFIGr_MIN_LO_THD_SELf_GET
#define MINBUCKETCONFIGr_MIN_LO_THD_SELf_SET BCM56504_A0_MINBUCKETCONFIGr_MIN_LO_THD_SELf_SET
#define MINBUCKETCONFIGr_MIN_HI_THD_SELf_GET BCM56504_A0_MINBUCKETCONFIGr_MIN_HI_THD_SELf_GET
#define MINBUCKETCONFIGr_MIN_HI_THD_SELf_SET BCM56504_A0_MINBUCKETCONFIGr_MIN_HI_THD_SELf_SET
#define MINBUCKETCONFIGr_MIN_REFRESHf_GET BCM56504_A0_MINBUCKETCONFIGr_MIN_REFRESHf_GET
#define MINBUCKETCONFIGr_MIN_REFRESHf_SET BCM56504_A0_MINBUCKETCONFIGr_MIN_REFRESHf_SET
#define READ_MINBUCKETCONFIGr BCM56504_A0_READ_MINBUCKETCONFIGr
#define WRITE_MINBUCKETCONFIGr BCM56504_A0_WRITE_MINBUCKETCONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MINBUCKETCONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  MIRROR_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     Mirror control register
 * SIZE:     32
 * FIELDS:
 *     M_ENABLE         Enable mirroring
 *     IM_MTP_INDEX     Ingress MTP index
 *     EM_MTP_INDEX     Egress MTP index
 *     NON_UC_EM_MTP_INDEX Non-unicast egress MTP index
 *
 ******************************************************************************/
#define BCM56504_A0_MIRROR_CONTROLr 0x0e700104

#define BCM56504_A0_MIRROR_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program MIRROR_CONTROL.
 *
 */
typedef union BCM56504_A0_MIRROR_CONTROLr_s {
	uint32_t v[1];
	uint32_t mirror_control[1];
	uint32_t _mirror_control;
} BCM56504_A0_MIRROR_CONTROLr_t;

#define BCM56504_A0_MIRROR_CONTROLr_CLR(r) (r).mirror_control[0] = 0
#define BCM56504_A0_MIRROR_CONTROLr_SET(r,d) (r).mirror_control[0] = d
#define BCM56504_A0_MIRROR_CONTROLr_GET(r) (r).mirror_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MIRROR_CONTROLr_M_ENABLEf_GET(r) (((r).mirror_control[0]) & 0x1)
#define BCM56504_A0_MIRROR_CONTROLr_M_ENABLEf_SET(r,f) (r).mirror_control[0]=(((r).mirror_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_MIRROR_CONTROLr_IM_MTP_INDEXf_GET(r) ((((r).mirror_control[0]) >> 1) & 0x3)
#define BCM56504_A0_MIRROR_CONTROLr_IM_MTP_INDEXf_SET(r,f) (r).mirror_control[0]=(((r).mirror_control[0] & ~((uint32_t)0x3 << 1)) | ((((uint32_t)f) & 0x3) << 1))
#define BCM56504_A0_MIRROR_CONTROLr_EM_MTP_INDEXf_GET(r) ((((r).mirror_control[0]) >> 3) & 0x3)
#define BCM56504_A0_MIRROR_CONTROLr_EM_MTP_INDEXf_SET(r,f) (r).mirror_control[0]=(((r).mirror_control[0] & ~((uint32_t)0x3 << 3)) | ((((uint32_t)f) & 0x3) << 3))
#define BCM56504_A0_MIRROR_CONTROLr_NON_UC_EM_MTP_INDEXf_GET(r) ((((r).mirror_control[0]) >> 5) & 0x3)
#define BCM56504_A0_MIRROR_CONTROLr_NON_UC_EM_MTP_INDEXf_SET(r,f) (r).mirror_control[0]=(((r).mirror_control[0] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5))

/*
 * These macros can be used to access MIRROR_CONTROL.
 *
 */
#define BCM56504_A0_READ_MIRROR_CONTROLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_MIRROR_CONTROLr,(r._mirror_control))
#define BCM56504_A0_WRITE_MIRROR_CONTROLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_MIRROR_CONTROLr,&(r._mirror_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIRROR_CONTROLr BCM56504_A0_MIRROR_CONTROLr
#define MIRROR_CONTROLr_SIZE BCM56504_A0_MIRROR_CONTROLr_SIZE
typedef BCM56504_A0_MIRROR_CONTROLr_t MIRROR_CONTROLr_t;
#define MIRROR_CONTROLr_CLR BCM56504_A0_MIRROR_CONTROLr_CLR
#define MIRROR_CONTROLr_SET BCM56504_A0_MIRROR_CONTROLr_SET
#define MIRROR_CONTROLr_GET BCM56504_A0_MIRROR_CONTROLr_GET
#define MIRROR_CONTROLr_M_ENABLEf_GET BCM56504_A0_MIRROR_CONTROLr_M_ENABLEf_GET
#define MIRROR_CONTROLr_M_ENABLEf_SET BCM56504_A0_MIRROR_CONTROLr_M_ENABLEf_SET
#define MIRROR_CONTROLr_IM_MTP_INDEXf_GET BCM56504_A0_MIRROR_CONTROLr_IM_MTP_INDEXf_GET
#define MIRROR_CONTROLr_IM_MTP_INDEXf_SET BCM56504_A0_MIRROR_CONTROLr_IM_MTP_INDEXf_SET
#define MIRROR_CONTROLr_EM_MTP_INDEXf_GET BCM56504_A0_MIRROR_CONTROLr_EM_MTP_INDEXf_GET
#define MIRROR_CONTROLr_EM_MTP_INDEXf_SET BCM56504_A0_MIRROR_CONTROLr_EM_MTP_INDEXf_SET
#define MIRROR_CONTROLr_NON_UC_EM_MTP_INDEXf_GET BCM56504_A0_MIRROR_CONTROLr_NON_UC_EM_MTP_INDEXf_GET
#define MIRROR_CONTROLr_NON_UC_EM_MTP_INDEXf_SET BCM56504_A0_MIRROR_CONTROLr_NON_UC_EM_MTP_INDEXf_SET
#define READ_MIRROR_CONTROLr BCM56504_A0_READ_MIRROR_CONTROLr
#define WRITE_MIRROR_CONTROLr BCM56504_A0_WRITE_MIRROR_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MIRROR_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  MISCCONFIG
 * BLOCKS:   MMU
 * DESC:     Controls various functions in the MMU
 * SIZE:     32
 * FIELDS:
 *     DYNAMIC_MEMORY_EN Dynamic Memory Mode EnableHOL cell limit behavior (dynamic sharing of CBP):1: Dynamic Memory mode is enabled,0: Dynamic Memory mode is disabled.
 *     DRACO_1_5_MIRRORING_MODE_EN Draco 1.5 Style Mirroring Mode EnableMMU will send not out replicated ingress or egress mirror_to_port packet 0: Draco 1.5 style Mirroring mode is disabled,1: Draco 1.5 style Mirroring mode is enabled.
 *     CLRDROPCTR       Clear All Drop Packet CountersWhen set to 1, MMU will clear all port counter of the followings:DROPPEDPKTCOUNT, CNG0DROPCOUNT, CNG1DROPCOUNT  & CELLCRCERRCOUNT.Read to this bit will always return 0.
 *     CELLCRCCHECKEN   MMU cell data CRC checking enable to detect MMU internal memory failure during operation. Failure Cell Pointer can be retrieved from CELLCRCERRPOINTER regsiter. Failure pointer count can be retrieved from CELLCRCERRCOUNT register.This crc checking function can detect bith Cell CRC error and CBP Header Parity error.1: Enable sending sbus Memfail message based Cell CRC error and CBP Header Parity error. on CRC error and infroming egree about this error. Currenttransmitting packet will be corrupted. 0: Disable sending sbus Memfail message based on CRC error and not infroming egree       about this error. Default.
 *     SKIDMARKER       SkidMarker for each HOL Packet Counter, reaserved value for for the packetsalready in the transsion to beaccepted by mmu XQ.The values of SkidMarker are:2\'b00: 4 packets,2\'b01: 5 packets, 2\'b10: 6 packets,2\'b11: 7 packets.
 *     HOLMAXTIMER      HOL Maximum Timer for sending periodic HOL COSx and IBP discard status to IngressPipeline. The values of HOL Maximum Timer counts in the unit of micron second.If se to 0 there will be no periodic status send to Ingress Pipeline only sendon the time when status are changed.Default value is disable.
 *     SLAM_MEM         Write 1 into this register will interrupt CFAP & CCP power-on initialization.After write 1 into this register, users are able to slam cfap and ccp memorieswith desired value. When memoryslamming is done, users need to wirte 1 intoCFAPINIT bit in CFAPCONFIG register to complete CFAP & CCP initialzation.This regsiter should not be programmed while the tarffic is on. It may generateunexpected result.
 *     METERING_CLK_EN  METERING_CLK_EN will enable metering 7.8125us refresh tick to flow into egress portmetering, min/max bucket and ingress back pressure metering function.0: disable refresh tick,1: enable refresh tick.
 *     IPMC_IND_MODE    IPMC_IND_MODE will enable egress port's ppp send out one extra l2 packet with L3IPMC packets when a packet is tagged as both l2 and l3 switching 0: disable sending extra l2 packet,1: enable sending extra l2 packet.
 *     PARITY_CHECK_EN  PARITY_CHECK_EN enable MMU checking the parity of Memory read out data.0: disable memory parity check,1: enable memory parity check.
 *
 ******************************************************************************/
#define BCM56504_A0_MISCCONFIGr 0x00680015

#define BCM56504_A0_MISCCONFIGr_SIZE 4

/*
 * This structure should be used to declare and program MISCCONFIG.
 *
 */
typedef union BCM56504_A0_MISCCONFIGr_s {
	uint32_t v[1];
	uint32_t miscconfig[1];
	uint32_t _miscconfig;
} BCM56504_A0_MISCCONFIGr_t;

#define BCM56504_A0_MISCCONFIGr_CLR(r) (r).miscconfig[0] = 0
#define BCM56504_A0_MISCCONFIGr_SET(r,d) (r).miscconfig[0] = d
#define BCM56504_A0_MISCCONFIGr_GET(r) (r).miscconfig[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MISCCONFIGr_DYNAMIC_MEMORY_ENf_GET(r) (((r).miscconfig[0]) & 0x1)
#define BCM56504_A0_MISCCONFIGr_DYNAMIC_MEMORY_ENf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_MISCCONFIGr_DRACO_1_5_MIRRORING_MODE_ENf_GET(r) ((((r).miscconfig[0]) >> 1) & 0x1)
#define BCM56504_A0_MISCCONFIGr_DRACO_1_5_MIRRORING_MODE_ENf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_MISCCONFIGr_CLRDROPCTRf_GET(r) ((((r).miscconfig[0]) >> 2) & 0x1)
#define BCM56504_A0_MISCCONFIGr_CLRDROPCTRf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_MISCCONFIGr_CELLCRCCHECKENf_GET(r) ((((r).miscconfig[0]) >> 3) & 0x1)
#define BCM56504_A0_MISCCONFIGr_CELLCRCCHECKENf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_MISCCONFIGr_SKIDMARKERf_GET(r) ((((r).miscconfig[0]) >> 4) & 0x3)
#define BCM56504_A0_MISCCONFIGr_SKIDMARKERf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM56504_A0_MISCCONFIGr_HOLMAXTIMERf_GET(r) ((((r).miscconfig[0]) >> 6) & 0x7)
#define BCM56504_A0_MISCCONFIGr_HOLMAXTIMERf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM56504_A0_MISCCONFIGr_SLAM_MEMf_GET(r) ((((r).miscconfig[0]) >> 9) & 0x1)
#define BCM56504_A0_MISCCONFIGr_SLAM_MEMf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56504_A0_MISCCONFIGr_METERING_CLK_ENf_GET(r) ((((r).miscconfig[0]) >> 10) & 0x1)
#define BCM56504_A0_MISCCONFIGr_METERING_CLK_ENf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56504_A0_MISCCONFIGr_IPMC_IND_MODEf_GET(r) ((((r).miscconfig[0]) >> 11) & 0x1)
#define BCM56504_A0_MISCCONFIGr_IPMC_IND_MODEf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56504_A0_MISCCONFIGr_PARITY_CHECK_ENf_GET(r) ((((r).miscconfig[0]) >> 12) & 0x1)
#define BCM56504_A0_MISCCONFIGr_PARITY_CHECK_ENf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))

/*
 * These macros can be used to access MISCCONFIG.
 *
 */
#define BCM56504_A0_READ_MISCCONFIGr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_MISCCONFIGr,(r._miscconfig))
#define BCM56504_A0_WRITE_MISCCONFIGr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_MISCCONFIGr,&(r._miscconfig))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MISCCONFIGr BCM56504_A0_MISCCONFIGr
#define MISCCONFIGr_SIZE BCM56504_A0_MISCCONFIGr_SIZE
typedef BCM56504_A0_MISCCONFIGr_t MISCCONFIGr_t;
#define MISCCONFIGr_CLR BCM56504_A0_MISCCONFIGr_CLR
#define MISCCONFIGr_SET BCM56504_A0_MISCCONFIGr_SET
#define MISCCONFIGr_GET BCM56504_A0_MISCCONFIGr_GET
#define MISCCONFIGr_DYNAMIC_MEMORY_ENf_GET BCM56504_A0_MISCCONFIGr_DYNAMIC_MEMORY_ENf_GET
#define MISCCONFIGr_DYNAMIC_MEMORY_ENf_SET BCM56504_A0_MISCCONFIGr_DYNAMIC_MEMORY_ENf_SET
#define MISCCONFIGr_DRACO_1_5_MIRRORING_MODE_ENf_GET BCM56504_A0_MISCCONFIGr_DRACO_1_5_MIRRORING_MODE_ENf_GET
#define MISCCONFIGr_DRACO_1_5_MIRRORING_MODE_ENf_SET BCM56504_A0_MISCCONFIGr_DRACO_1_5_MIRRORING_MODE_ENf_SET
#define MISCCONFIGr_CLRDROPCTRf_GET BCM56504_A0_MISCCONFIGr_CLRDROPCTRf_GET
#define MISCCONFIGr_CLRDROPCTRf_SET BCM56504_A0_MISCCONFIGr_CLRDROPCTRf_SET
#define MISCCONFIGr_CELLCRCCHECKENf_GET BCM56504_A0_MISCCONFIGr_CELLCRCCHECKENf_GET
#define MISCCONFIGr_CELLCRCCHECKENf_SET BCM56504_A0_MISCCONFIGr_CELLCRCCHECKENf_SET
#define MISCCONFIGr_SKIDMARKERf_GET BCM56504_A0_MISCCONFIGr_SKIDMARKERf_GET
#define MISCCONFIGr_SKIDMARKERf_SET BCM56504_A0_MISCCONFIGr_SKIDMARKERf_SET
#define MISCCONFIGr_HOLMAXTIMERf_GET BCM56504_A0_MISCCONFIGr_HOLMAXTIMERf_GET
#define MISCCONFIGr_HOLMAXTIMERf_SET BCM56504_A0_MISCCONFIGr_HOLMAXTIMERf_SET
#define MISCCONFIGr_SLAM_MEMf_GET BCM56504_A0_MISCCONFIGr_SLAM_MEMf_GET
#define MISCCONFIGr_SLAM_MEMf_SET BCM56504_A0_MISCCONFIGr_SLAM_MEMf_SET
#define MISCCONFIGr_METERING_CLK_ENf_GET BCM56504_A0_MISCCONFIGr_METERING_CLK_ENf_GET
#define MISCCONFIGr_METERING_CLK_ENf_SET BCM56504_A0_MISCCONFIGr_METERING_CLK_ENf_SET
#define MISCCONFIGr_IPMC_IND_MODEf_GET BCM56504_A0_MISCCONFIGr_IPMC_IND_MODEf_GET
#define MISCCONFIGr_IPMC_IND_MODEf_SET BCM56504_A0_MISCCONFIGr_IPMC_IND_MODEf_SET
#define MISCCONFIGr_PARITY_CHECK_ENf_GET BCM56504_A0_MISCCONFIGr_PARITY_CHECK_ENf_GET
#define MISCCONFIGr_PARITY_CHECK_ENf_SET BCM56504_A0_MISCCONFIGr_PARITY_CHECK_ENf_SET
#define READ_MISCCONFIGr BCM56504_A0_READ_MISCCONFIGr
#define WRITE_MISCCONFIGr BCM56504_A0_WRITE_MISCCONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MISCCONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  MMUPORTENABLE
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     MMUPORTENABLE    MMU port enable is to control which mmu egress port can accept packet
 *
 ******************************************************************************/
#define BCM56504_A0_MMUPORTENABLEr 0x0068001d

#define BCM56504_A0_MMUPORTENABLEr_SIZE 4

/*
 * This structure should be used to declare and program MMUPORTENABLE.
 *
 */
typedef union BCM56504_A0_MMUPORTENABLEr_s {
	uint32_t v[1];
	uint32_t mmuportenable[1];
	uint32_t _mmuportenable;
} BCM56504_A0_MMUPORTENABLEr_t;

#define BCM56504_A0_MMUPORTENABLEr_CLR(r) (r).mmuportenable[0] = 0
#define BCM56504_A0_MMUPORTENABLEr_SET(r,d) (r).mmuportenable[0] = d
#define BCM56504_A0_MMUPORTENABLEr_GET(r) (r).mmuportenable[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MMUPORTENABLEr_MMUPORTENABLEf_GET(r) (((r).mmuportenable[0]) & 0x1fffffff)
#define BCM56504_A0_MMUPORTENABLEr_MMUPORTENABLEf_SET(r,f) (r).mmuportenable[0]=(((r).mmuportenable[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))

/*
 * These macros can be used to access MMUPORTENABLE.
 *
 */
#define BCM56504_A0_READ_MMUPORTENABLEr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_MMUPORTENABLEr,(r._mmuportenable))
#define BCM56504_A0_WRITE_MMUPORTENABLEr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_MMUPORTENABLEr,&(r._mmuportenable))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMUPORTENABLEr BCM56504_A0_MMUPORTENABLEr
#define MMUPORTENABLEr_SIZE BCM56504_A0_MMUPORTENABLEr_SIZE
typedef BCM56504_A0_MMUPORTENABLEr_t MMUPORTENABLEr_t;
#define MMUPORTENABLEr_CLR BCM56504_A0_MMUPORTENABLEr_CLR
#define MMUPORTENABLEr_SET BCM56504_A0_MMUPORTENABLEr_SET
#define MMUPORTENABLEr_GET BCM56504_A0_MMUPORTENABLEr_GET
#define MMUPORTENABLEr_MMUPORTENABLEf_GET BCM56504_A0_MMUPORTENABLEr_MMUPORTENABLEf_GET
#define MMUPORTENABLEr_MMUPORTENABLEf_SET BCM56504_A0_MMUPORTENABLEr_MMUPORTENABLEf_SET
#define READ_MMUPORTENABLEr BCM56504_A0_READ_MMUPORTENABLEr
#define WRITE_MMUPORTENABLEr BCM56504_A0_WRITE_MMUPORTENABLEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MMUPORTENABLEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  MMU_AGING_CTR
 * BLOCKS:   MMU
 * DESC:     Aging Counter RAM
 * SIZE:     24
 * FIELDS:
 *     AGING_CTR        AGING_CTR
 *
 ******************************************************************************/
#define BCM56504_A0_MMU_AGING_CTRm 0x0a684000

#define BCM56504_A0_MMU_AGING_CTRm_MIN 0
#define BCM56504_A0_MMU_AGING_CTRm_MAX 2047
#define BCM56504_A0_MMU_AGING_CTRm_CMAX(u) 2047
#define BCM56504_A0_MMU_AGING_CTRm_SIZE 3

/*
 * This structure should be used to declare and program MMU_AGING_CTR.
 *
 */
typedef union BCM56504_A0_MMU_AGING_CTRm_s {
	uint32_t v[1];
	uint32_t mmu_aging_ctr[1];
	uint32_t _mmu_aging_ctr;
} BCM56504_A0_MMU_AGING_CTRm_t;

#define BCM56504_A0_MMU_AGING_CTRm_CLR(r) (r).mmu_aging_ctr[0] = 0
#define BCM56504_A0_MMU_AGING_CTRm_SET(r,d) (r).mmu_aging_ctr[0] = d
#define BCM56504_A0_MMU_AGING_CTRm_GET(r) (r).mmu_aging_ctr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MMU_AGING_CTRm_AGING_CTRf_GET(r) (((r).mmu_aging_ctr[0]) & 0xffffff)
#define BCM56504_A0_MMU_AGING_CTRm_AGING_CTRf_SET(r,f) (r).mmu_aging_ctr[0]=(((r).mmu_aging_ctr[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))

/*
 * These macros can be used to access MMU_AGING_CTR.
 *
 */
#define BCM56504_A0_READ_MMU_AGING_CTRm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_MMU_AGING_CTRm,i,(m._mmu_aging_ctr),1)
#define BCM56504_A0_WRITE_MMU_AGING_CTRm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_MMU_AGING_CTRm,i,&(m._mmu_aging_ctr),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_AGING_CTRm BCM56504_A0_MMU_AGING_CTRm
#define MMU_AGING_CTRm_MIN BCM56504_A0_MMU_AGING_CTRm_MIN
#define MMU_AGING_CTRm_MAX BCM56504_A0_MMU_AGING_CTRm_MAX
#define MMU_AGING_CTRm_CMAX(u) BCM56504_A0_MMU_AGING_CTRm_CMAX(u)
#define MMU_AGING_CTRm_SIZE BCM56504_A0_MMU_AGING_CTRm_SIZE
typedef BCM56504_A0_MMU_AGING_CTRm_t MMU_AGING_CTRm_t;
#define MMU_AGING_CTRm_CLR BCM56504_A0_MMU_AGING_CTRm_CLR
#define MMU_AGING_CTRm_SET BCM56504_A0_MMU_AGING_CTRm_SET
#define MMU_AGING_CTRm_GET BCM56504_A0_MMU_AGING_CTRm_GET
#define MMU_AGING_CTRm_AGING_CTRf_GET BCM56504_A0_MMU_AGING_CTRm_AGING_CTRf_GET
#define MMU_AGING_CTRm_AGING_CTRf_SET BCM56504_A0_MMU_AGING_CTRm_AGING_CTRf_SET
#define READ_MMU_AGING_CTRm BCM56504_A0_READ_MMU_AGING_CTRm
#define WRITE_MMU_AGING_CTRm BCM56504_A0_WRITE_MMU_AGING_CTRm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MMU_AGING_CTRm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  MMU_AGING_EXP
 * BLOCKS:   MMU
 * DESC:     Aging Expiration Status RAM
 * SIZE:     8
 * FIELDS:
 *     AGING_EXP        AGING_EXP
 *
 ******************************************************************************/
#define BCM56504_A0_MMU_AGING_EXPm 0x0a688000

#define BCM56504_A0_MMU_AGING_EXPm_MIN 0
#define BCM56504_A0_MMU_AGING_EXPm_MAX 2047
#define BCM56504_A0_MMU_AGING_EXPm_CMAX(u) 2047
#define BCM56504_A0_MMU_AGING_EXPm_SIZE 1

/*
 * This structure should be used to declare and program MMU_AGING_EXP.
 *
 */
typedef union BCM56504_A0_MMU_AGING_EXPm_s {
	uint32_t v[1];
	uint32_t mmu_aging_exp[1];
	uint32_t _mmu_aging_exp;
} BCM56504_A0_MMU_AGING_EXPm_t;

#define BCM56504_A0_MMU_AGING_EXPm_CLR(r) (r).mmu_aging_exp[0] = 0
#define BCM56504_A0_MMU_AGING_EXPm_SET(r,d) (r).mmu_aging_exp[0] = d
#define BCM56504_A0_MMU_AGING_EXPm_GET(r) (r).mmu_aging_exp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MMU_AGING_EXPm_AGING_EXPf_GET(r) (((r).mmu_aging_exp[0]) & 0xff)
#define BCM56504_A0_MMU_AGING_EXPm_AGING_EXPf_SET(r,f) (r).mmu_aging_exp[0]=(((r).mmu_aging_exp[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access MMU_AGING_EXP.
 *
 */
#define BCM56504_A0_READ_MMU_AGING_EXPm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_MMU_AGING_EXPm,i,(m._mmu_aging_exp),1)
#define BCM56504_A0_WRITE_MMU_AGING_EXPm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_MMU_AGING_EXPm,i,&(m._mmu_aging_exp),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_AGING_EXPm BCM56504_A0_MMU_AGING_EXPm
#define MMU_AGING_EXPm_MIN BCM56504_A0_MMU_AGING_EXPm_MIN
#define MMU_AGING_EXPm_MAX BCM56504_A0_MMU_AGING_EXPm_MAX
#define MMU_AGING_EXPm_CMAX(u) BCM56504_A0_MMU_AGING_EXPm_CMAX(u)
#define MMU_AGING_EXPm_SIZE BCM56504_A0_MMU_AGING_EXPm_SIZE
typedef BCM56504_A0_MMU_AGING_EXPm_t MMU_AGING_EXPm_t;
#define MMU_AGING_EXPm_CLR BCM56504_A0_MMU_AGING_EXPm_CLR
#define MMU_AGING_EXPm_SET BCM56504_A0_MMU_AGING_EXPm_SET
#define MMU_AGING_EXPm_GET BCM56504_A0_MMU_AGING_EXPm_GET
#define MMU_AGING_EXPm_AGING_EXPf_GET BCM56504_A0_MMU_AGING_EXPm_AGING_EXPf_GET
#define MMU_AGING_EXPm_AGING_EXPf_SET BCM56504_A0_MMU_AGING_EXPm_AGING_EXPf_SET
#define READ_MMU_AGING_EXPm BCM56504_A0_READ_MMU_AGING_EXPm
#define WRITE_MMU_AGING_EXPm BCM56504_A0_WRITE_MMU_AGING_EXPm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MMU_AGING_EXPm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  MMU_CBPCellHeader
 * BLOCKS:   MMU
 * DESC:     CBP Header RAM
 * SIZE:     36
 * FIELDS:
 *     PURGE_CELL       How Many copies of this cell are there
 *     END_CELL         End cell flag of a packet
 *     CELL_LENGTH      Last Cell Length is valid when END_CELL is 1
 *     CELL_CRC_SUM     Cell CRC Checksum value
 *     RESERVED_BIT_2   RESERVED_BIT_2
 *     RESERVED_BIT_3   RESERVED_BIT_3
 *     RESERVED_BIT_4   RESERVED_BIT_4
 *     PARITY           Cell header Parity
 *     NEXT_CELL_PTR    Next Cell Pointer is valid when END_CELL is 0
 *
 ******************************************************************************/
#define BCM56504_A0_MMU_CBPCELLHEADERm 0x0a648000

#define BCM56504_A0_MMU_CBPCELLHEADERm_MIN 0
#define BCM56504_A0_MMU_CBPCELLHEADERm_MAX 16383
#define BCM56504_A0_MMU_CBPCELLHEADERm_CMAX(u) 16383
#define BCM56504_A0_MMU_CBPCELLHEADERm_SIZE 5

/*
 * This structure should be used to declare and program MMU_CBPCellHeader.
 *
 */
typedef union BCM56504_A0_MMU_CBPCELLHEADERm_s {
	uint32_t v[2];
	uint32_t mmu_cbpcellheader[2];
	uint32_t _mmu_cbpcellheader;
} BCM56504_A0_MMU_CBPCELLHEADERm_t;

#define BCM56504_A0_MMU_CBPCELLHEADERm_CLR(r) CDK_MEMSET(&((r)._mmu_cbpcellheader), 0, sizeof(BCM56504_A0_MMU_CBPCELLHEADERm_t))
#define BCM56504_A0_MMU_CBPCELLHEADERm_SET(r,i,d) (r).mmu_cbpcellheader[i] = d
#define BCM56504_A0_MMU_CBPCELLHEADERm_GET(r,i) (r).mmu_cbpcellheader[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MMU_CBPCELLHEADERm_PURGE_CELLf_GET(r) (((r).mmu_cbpcellheader[0]) & 0x1)
#define BCM56504_A0_MMU_CBPCELLHEADERm_PURGE_CELLf_SET(r,f) (r).mmu_cbpcellheader[0]=(((r).mmu_cbpcellheader[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_MMU_CBPCELLHEADERm_END_CELLf_GET(r) ((((r).mmu_cbpcellheader[0]) >> 1) & 0x1)
#define BCM56504_A0_MMU_CBPCELLHEADERm_END_CELLf_SET(r,f) (r).mmu_cbpcellheader[0]=(((r).mmu_cbpcellheader[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_MMU_CBPCELLHEADERm_CELL_LENGTHf_GET(r) ((((r).mmu_cbpcellheader[0]) >> 2) & 0xff)
#define BCM56504_A0_MMU_CBPCELLHEADERm_CELL_LENGTHf_SET(r,f) (r).mmu_cbpcellheader[0]=(((r).mmu_cbpcellheader[0] & ~((uint32_t)0xff << 2)) | ((((uint32_t)f) & 0xff) << 2))
#define BCM56504_A0_MMU_CBPCELLHEADERm_CELL_CRC_SUMf_GET(r) ((((r).mmu_cbpcellheader[0]) >> 16) & 0xffff)
#define BCM56504_A0_MMU_CBPCELLHEADERm_CELL_CRC_SUMf_SET(r,f) (r).mmu_cbpcellheader[0]=(((r).mmu_cbpcellheader[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))
#define BCM56504_A0_MMU_CBPCELLHEADERm_RESERVED_BIT_2f_GET(r) (((r).mmu_cbpcellheader[1]) & 0x1)
#define BCM56504_A0_MMU_CBPCELLHEADERm_RESERVED_BIT_2f_SET(r,f) (r).mmu_cbpcellheader[1]=(((r).mmu_cbpcellheader[1] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_MMU_CBPCELLHEADERm_RESERVED_BIT_3f_GET(r) ((((r).mmu_cbpcellheader[1]) >> 1) & 0x1)
#define BCM56504_A0_MMU_CBPCELLHEADERm_RESERVED_BIT_3f_SET(r,f) (r).mmu_cbpcellheader[1]=(((r).mmu_cbpcellheader[1] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_MMU_CBPCELLHEADERm_RESERVED_BIT_4f_GET(r) ((((r).mmu_cbpcellheader[1]) >> 2) & 0x1)
#define BCM56504_A0_MMU_CBPCELLHEADERm_RESERVED_BIT_4f_SET(r,f) (r).mmu_cbpcellheader[1]=(((r).mmu_cbpcellheader[1] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_MMU_CBPCELLHEADERm_PARITYf_GET(r) ((((r).mmu_cbpcellheader[1]) >> 3) & 0x1)
#define BCM56504_A0_MMU_CBPCELLHEADERm_PARITYf_SET(r,f) (r).mmu_cbpcellheader[1]=(((r).mmu_cbpcellheader[1] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_MMU_CBPCELLHEADERm_NEXT_CELL_PTRf_GET(r) ((((r).mmu_cbpcellheader[0]) >> 2) & 0x3fff)
#define BCM56504_A0_MMU_CBPCELLHEADERm_NEXT_CELL_PTRf_SET(r,f) (r).mmu_cbpcellheader[0]=(((r).mmu_cbpcellheader[0] & ~((uint32_t)0x3fff << 2)) | ((((uint32_t)f) & 0x3fff) << 2))

/*
 * These macros can be used to access MMU_CBPCellHeader.
 *
 */
#define BCM56504_A0_READ_MMU_CBPCELLHEADERm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_MMU_CBPCELLHEADERm,i,(m._mmu_cbpcellheader),2)
#define BCM56504_A0_WRITE_MMU_CBPCELLHEADERm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_MMU_CBPCELLHEADERm,i,&(m._mmu_cbpcellheader),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CBPCELLHEADERm BCM56504_A0_MMU_CBPCELLHEADERm
#define MMU_CBPCELLHEADERm_MIN BCM56504_A0_MMU_CBPCELLHEADERm_MIN
#define MMU_CBPCELLHEADERm_MAX BCM56504_A0_MMU_CBPCELLHEADERm_MAX
#define MMU_CBPCELLHEADERm_CMAX(u) BCM56504_A0_MMU_CBPCELLHEADERm_CMAX(u)
#define MMU_CBPCELLHEADERm_SIZE BCM56504_A0_MMU_CBPCELLHEADERm_SIZE
typedef BCM56504_A0_MMU_CBPCELLHEADERm_t MMU_CBPCELLHEADERm_t;
#define MMU_CBPCELLHEADERm_CLR BCM56504_A0_MMU_CBPCELLHEADERm_CLR
#define MMU_CBPCELLHEADERm_SET BCM56504_A0_MMU_CBPCELLHEADERm_SET
#define MMU_CBPCELLHEADERm_GET BCM56504_A0_MMU_CBPCELLHEADERm_GET
#define MMU_CBPCELLHEADERm_PURGE_CELLf_GET BCM56504_A0_MMU_CBPCELLHEADERm_PURGE_CELLf_GET
#define MMU_CBPCELLHEADERm_PURGE_CELLf_SET BCM56504_A0_MMU_CBPCELLHEADERm_PURGE_CELLf_SET
#define MMU_CBPCELLHEADERm_END_CELLf_GET BCM56504_A0_MMU_CBPCELLHEADERm_END_CELLf_GET
#define MMU_CBPCELLHEADERm_END_CELLf_SET BCM56504_A0_MMU_CBPCELLHEADERm_END_CELLf_SET
#define MMU_CBPCELLHEADERm_CELL_LENGTHf_GET BCM56504_A0_MMU_CBPCELLHEADERm_CELL_LENGTHf_GET
#define MMU_CBPCELLHEADERm_CELL_LENGTHf_SET BCM56504_A0_MMU_CBPCELLHEADERm_CELL_LENGTHf_SET
#define MMU_CBPCELLHEADERm_CELL_CRC_SUMf_GET BCM56504_A0_MMU_CBPCELLHEADERm_CELL_CRC_SUMf_GET
#define MMU_CBPCELLHEADERm_CELL_CRC_SUMf_SET BCM56504_A0_MMU_CBPCELLHEADERm_CELL_CRC_SUMf_SET
#define MMU_CBPCELLHEADERm_RESERVED_BIT_2f_GET BCM56504_A0_MMU_CBPCELLHEADERm_RESERVED_BIT_2f_GET
#define MMU_CBPCELLHEADERm_RESERVED_BIT_2f_SET BCM56504_A0_MMU_CBPCELLHEADERm_RESERVED_BIT_2f_SET
#define MMU_CBPCELLHEADERm_RESERVED_BIT_3f_GET BCM56504_A0_MMU_CBPCELLHEADERm_RESERVED_BIT_3f_GET
#define MMU_CBPCELLHEADERm_RESERVED_BIT_3f_SET BCM56504_A0_MMU_CBPCELLHEADERm_RESERVED_BIT_3f_SET
#define MMU_CBPCELLHEADERm_RESERVED_BIT_4f_GET BCM56504_A0_MMU_CBPCELLHEADERm_RESERVED_BIT_4f_GET
#define MMU_CBPCELLHEADERm_RESERVED_BIT_4f_SET BCM56504_A0_MMU_CBPCELLHEADERm_RESERVED_BIT_4f_SET
#define MMU_CBPCELLHEADERm_PARITYf_GET BCM56504_A0_MMU_CBPCELLHEADERm_PARITYf_GET
#define MMU_CBPCELLHEADERm_PARITYf_SET BCM56504_A0_MMU_CBPCELLHEADERm_PARITYf_SET
#define MMU_CBPCELLHEADERm_NEXT_CELL_PTRf_GET BCM56504_A0_MMU_CBPCELLHEADERm_NEXT_CELL_PTRf_GET
#define MMU_CBPCELLHEADERm_NEXT_CELL_PTRf_SET BCM56504_A0_MMU_CBPCELLHEADERm_NEXT_CELL_PTRf_SET
#define READ_MMU_CBPCELLHEADERm BCM56504_A0_READ_MMU_CBPCELLHEADERm
#define WRITE_MMU_CBPCELLHEADERm BCM56504_A0_WRITE_MMU_CBPCELLHEADERm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MMU_CBPCELLHEADERm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  MMU_CBPData0
 * BLOCKS:   MMU
 * DESC:     CBP Data RAM 0
 * SIZE:     64
 * FIELDS:
 *     CBPDATA          CBPData [63:0]
 *
 ******************************************************************************/
#define BCM56504_A0_MMU_CBPDATA0m 0x0a600000

#define BCM56504_A0_MMU_CBPDATA0m_MIN 0
#define BCM56504_A0_MMU_CBPDATA0m_MAX 16383
#define BCM56504_A0_MMU_CBPDATA0m_CMAX(u) 16383
#define BCM56504_A0_MMU_CBPDATA0m_SIZE 8

/*
 * This structure should be used to declare and program MMU_CBPData0.
 *
 */
typedef union BCM56504_A0_MMU_CBPDATA0m_s {
	uint32_t v[2];
	uint32_t mmu_cbpdata0[2];
	uint32_t _mmu_cbpdata0;
} BCM56504_A0_MMU_CBPDATA0m_t;

#define BCM56504_A0_MMU_CBPDATA0m_CLR(r) CDK_MEMSET(&((r)._mmu_cbpdata0), 0, sizeof(BCM56504_A0_MMU_CBPDATA0m_t))
#define BCM56504_A0_MMU_CBPDATA0m_SET(r,i,d) (r).mmu_cbpdata0[i] = d
#define BCM56504_A0_MMU_CBPDATA0m_GET(r,i) (r).mmu_cbpdata0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MMU_CBPDATA0m_CBPDATAf_GET(r,a) cdk_field_get((r).mmu_cbpdata0,0,63,a)
#define BCM56504_A0_MMU_CBPDATA0m_CBPDATAf_SET(r,a) cdk_field_set((r).mmu_cbpdata0,0,63,a)

/*
 * These macros can be used to access MMU_CBPData0.
 *
 */
#define BCM56504_A0_READ_MMU_CBPDATA0m(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_MMU_CBPDATA0m,i,(m._mmu_cbpdata0),2)
#define BCM56504_A0_WRITE_MMU_CBPDATA0m(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_MMU_CBPDATA0m,i,&(m._mmu_cbpdata0),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CBPDATA0m BCM56504_A0_MMU_CBPDATA0m
#define MMU_CBPDATA0m_MIN BCM56504_A0_MMU_CBPDATA0m_MIN
#define MMU_CBPDATA0m_MAX BCM56504_A0_MMU_CBPDATA0m_MAX
#define MMU_CBPDATA0m_CMAX(u) BCM56504_A0_MMU_CBPDATA0m_CMAX(u)
#define MMU_CBPDATA0m_SIZE BCM56504_A0_MMU_CBPDATA0m_SIZE
typedef BCM56504_A0_MMU_CBPDATA0m_t MMU_CBPDATA0m_t;
#define MMU_CBPDATA0m_CLR BCM56504_A0_MMU_CBPDATA0m_CLR
#define MMU_CBPDATA0m_SET BCM56504_A0_MMU_CBPDATA0m_SET
#define MMU_CBPDATA0m_GET BCM56504_A0_MMU_CBPDATA0m_GET
#define MMU_CBPDATA0m_CBPDATAf_GET BCM56504_A0_MMU_CBPDATA0m_CBPDATAf_GET
#define MMU_CBPDATA0m_CBPDATAf_SET BCM56504_A0_MMU_CBPDATA0m_CBPDATAf_SET
#define READ_MMU_CBPDATA0m BCM56504_A0_READ_MMU_CBPDATA0m
#define WRITE_MMU_CBPDATA0m BCM56504_A0_WRITE_MMU_CBPDATA0m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MMU_CBPDATA0m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  MMU_CBPData1
 * BLOCKS:   MMU
 * DESC:     CBP Data RAM 1
 * SIZE:     64
 * FIELDS:
 *     CBPDATA          CBPData [127:64]
 *
 ******************************************************************************/
#define BCM56504_A0_MMU_CBPDATA1m 0x0a604000

#define BCM56504_A0_MMU_CBPDATA1m_MIN 0
#define BCM56504_A0_MMU_CBPDATA1m_MAX 16383
#define BCM56504_A0_MMU_CBPDATA1m_CMAX(u) 16383
#define BCM56504_A0_MMU_CBPDATA1m_SIZE 8

/*
 * This structure should be used to declare and program MMU_CBPData1.
 *
 */
typedef union BCM56504_A0_MMU_CBPDATA1m_s {
	uint32_t v[2];
	uint32_t mmu_cbpdata1[2];
	uint32_t _mmu_cbpdata1;
} BCM56504_A0_MMU_CBPDATA1m_t;

#define BCM56504_A0_MMU_CBPDATA1m_CLR(r) CDK_MEMSET(&((r)._mmu_cbpdata1), 0, sizeof(BCM56504_A0_MMU_CBPDATA1m_t))
#define BCM56504_A0_MMU_CBPDATA1m_SET(r,i,d) (r).mmu_cbpdata1[i] = d
#define BCM56504_A0_MMU_CBPDATA1m_GET(r,i) (r).mmu_cbpdata1[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MMU_CBPDATA1m_CBPDATAf_GET(r,a) cdk_field_get((r).mmu_cbpdata1,0,63,a)
#define BCM56504_A0_MMU_CBPDATA1m_CBPDATAf_SET(r,a) cdk_field_set((r).mmu_cbpdata1,0,63,a)

/*
 * These macros can be used to access MMU_CBPData1.
 *
 */
#define BCM56504_A0_READ_MMU_CBPDATA1m(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_MMU_CBPDATA1m,i,(m._mmu_cbpdata1),2)
#define BCM56504_A0_WRITE_MMU_CBPDATA1m(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_MMU_CBPDATA1m,i,&(m._mmu_cbpdata1),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CBPDATA1m BCM56504_A0_MMU_CBPDATA1m
#define MMU_CBPDATA1m_MIN BCM56504_A0_MMU_CBPDATA1m_MIN
#define MMU_CBPDATA1m_MAX BCM56504_A0_MMU_CBPDATA1m_MAX
#define MMU_CBPDATA1m_CMAX(u) BCM56504_A0_MMU_CBPDATA1m_CMAX(u)
#define MMU_CBPDATA1m_SIZE BCM56504_A0_MMU_CBPDATA1m_SIZE
typedef BCM56504_A0_MMU_CBPDATA1m_t MMU_CBPDATA1m_t;
#define MMU_CBPDATA1m_CLR BCM56504_A0_MMU_CBPDATA1m_CLR
#define MMU_CBPDATA1m_SET BCM56504_A0_MMU_CBPDATA1m_SET
#define MMU_CBPDATA1m_GET BCM56504_A0_MMU_CBPDATA1m_GET
#define MMU_CBPDATA1m_CBPDATAf_GET BCM56504_A0_MMU_CBPDATA1m_CBPDATAf_GET
#define MMU_CBPDATA1m_CBPDATAf_SET BCM56504_A0_MMU_CBPDATA1m_CBPDATAf_SET
#define READ_MMU_CBPDATA1m BCM56504_A0_READ_MMU_CBPDATA1m
#define WRITE_MMU_CBPDATA1m BCM56504_A0_WRITE_MMU_CBPDATA1m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MMU_CBPDATA1m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  MMU_CBPData10
 * BLOCKS:   MMU
 * DESC:     CBP Data RAM 10
 * SIZE:     64
 * FIELDS:
 *     CBPDATA          CBPData [703:640]
 *
 ******************************************************************************/
#define BCM56504_A0_MMU_CBPDATA10m 0x0a628000

#define BCM56504_A0_MMU_CBPDATA10m_MIN 0
#define BCM56504_A0_MMU_CBPDATA10m_MAX 16383
#define BCM56504_A0_MMU_CBPDATA10m_CMAX(u) 16383
#define BCM56504_A0_MMU_CBPDATA10m_SIZE 8

/*
 * This structure should be used to declare and program MMU_CBPData10.
 *
 */
typedef union BCM56504_A0_MMU_CBPDATA10m_s {
	uint32_t v[2];
	uint32_t mmu_cbpdata10[2];
	uint32_t _mmu_cbpdata10;
} BCM56504_A0_MMU_CBPDATA10m_t;

#define BCM56504_A0_MMU_CBPDATA10m_CLR(r) CDK_MEMSET(&((r)._mmu_cbpdata10), 0, sizeof(BCM56504_A0_MMU_CBPDATA10m_t))
#define BCM56504_A0_MMU_CBPDATA10m_SET(r,i,d) (r).mmu_cbpdata10[i] = d
#define BCM56504_A0_MMU_CBPDATA10m_GET(r,i) (r).mmu_cbpdata10[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MMU_CBPDATA10m_CBPDATAf_GET(r,a) cdk_field_get((r).mmu_cbpdata10,0,63,a)
#define BCM56504_A0_MMU_CBPDATA10m_CBPDATAf_SET(r,a) cdk_field_set((r).mmu_cbpdata10,0,63,a)

/*
 * These macros can be used to access MMU_CBPData10.
 *
 */
#define BCM56504_A0_READ_MMU_CBPDATA10m(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_MMU_CBPDATA10m,i,(m._mmu_cbpdata10),2)
#define BCM56504_A0_WRITE_MMU_CBPDATA10m(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_MMU_CBPDATA10m,i,&(m._mmu_cbpdata10),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CBPDATA10m BCM56504_A0_MMU_CBPDATA10m
#define MMU_CBPDATA10m_MIN BCM56504_A0_MMU_CBPDATA10m_MIN
#define MMU_CBPDATA10m_MAX BCM56504_A0_MMU_CBPDATA10m_MAX
#define MMU_CBPDATA10m_CMAX(u) BCM56504_A0_MMU_CBPDATA10m_CMAX(u)
#define MMU_CBPDATA10m_SIZE BCM56504_A0_MMU_CBPDATA10m_SIZE
typedef BCM56504_A0_MMU_CBPDATA10m_t MMU_CBPDATA10m_t;
#define MMU_CBPDATA10m_CLR BCM56504_A0_MMU_CBPDATA10m_CLR
#define MMU_CBPDATA10m_SET BCM56504_A0_MMU_CBPDATA10m_SET
#define MMU_CBPDATA10m_GET BCM56504_A0_MMU_CBPDATA10m_GET
#define MMU_CBPDATA10m_CBPDATAf_GET BCM56504_A0_MMU_CBPDATA10m_CBPDATAf_GET
#define MMU_CBPDATA10m_CBPDATAf_SET BCM56504_A0_MMU_CBPDATA10m_CBPDATAf_SET
#define READ_MMU_CBPDATA10m BCM56504_A0_READ_MMU_CBPDATA10m
#define WRITE_MMU_CBPDATA10m BCM56504_A0_WRITE_MMU_CBPDATA10m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MMU_CBPDATA10m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  MMU_CBPData11
 * BLOCKS:   MMU
 * DESC:     CBP Data RAM 11
 * SIZE:     64
 * FIELDS:
 *     CBPDATA          CBPData [767:704]
 *
 ******************************************************************************/
#define BCM56504_A0_MMU_CBPDATA11m 0x0a62c000

#define BCM56504_A0_MMU_CBPDATA11m_MIN 0
#define BCM56504_A0_MMU_CBPDATA11m_MAX 16383
#define BCM56504_A0_MMU_CBPDATA11m_CMAX(u) 16383
#define BCM56504_A0_MMU_CBPDATA11m_SIZE 8

/*
 * This structure should be used to declare and program MMU_CBPData11.
 *
 */
typedef union BCM56504_A0_MMU_CBPDATA11m_s {
	uint32_t v[2];
	uint32_t mmu_cbpdata11[2];
	uint32_t _mmu_cbpdata11;
} BCM56504_A0_MMU_CBPDATA11m_t;

#define BCM56504_A0_MMU_CBPDATA11m_CLR(r) CDK_MEMSET(&((r)._mmu_cbpdata11), 0, sizeof(BCM56504_A0_MMU_CBPDATA11m_t))
#define BCM56504_A0_MMU_CBPDATA11m_SET(r,i,d) (r).mmu_cbpdata11[i] = d
#define BCM56504_A0_MMU_CBPDATA11m_GET(r,i) (r).mmu_cbpdata11[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MMU_CBPDATA11m_CBPDATAf_GET(r,a) cdk_field_get((r).mmu_cbpdata11,0,63,a)
#define BCM56504_A0_MMU_CBPDATA11m_CBPDATAf_SET(r,a) cdk_field_set((r).mmu_cbpdata11,0,63,a)

/*
 * These macros can be used to access MMU_CBPData11.
 *
 */
#define BCM56504_A0_READ_MMU_CBPDATA11m(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_MMU_CBPDATA11m,i,(m._mmu_cbpdata11),2)
#define BCM56504_A0_WRITE_MMU_CBPDATA11m(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_MMU_CBPDATA11m,i,&(m._mmu_cbpdata11),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CBPDATA11m BCM56504_A0_MMU_CBPDATA11m
#define MMU_CBPDATA11m_MIN BCM56504_A0_MMU_CBPDATA11m_MIN
#define MMU_CBPDATA11m_MAX BCM56504_A0_MMU_CBPDATA11m_MAX
#define MMU_CBPDATA11m_CMAX(u) BCM56504_A0_MMU_CBPDATA11m_CMAX(u)
#define MMU_CBPDATA11m_SIZE BCM56504_A0_MMU_CBPDATA11m_SIZE
typedef BCM56504_A0_MMU_CBPDATA11m_t MMU_CBPDATA11m_t;
#define MMU_CBPDATA11m_CLR BCM56504_A0_MMU_CBPDATA11m_CLR
#define MMU_CBPDATA11m_SET BCM56504_A0_MMU_CBPDATA11m_SET
#define MMU_CBPDATA11m_GET BCM56504_A0_MMU_CBPDATA11m_GET
#define MMU_CBPDATA11m_CBPDATAf_GET BCM56504_A0_MMU_CBPDATA11m_CBPDATAf_GET
#define MMU_CBPDATA11m_CBPDATAf_SET BCM56504_A0_MMU_CBPDATA11m_CBPDATAf_SET
#define READ_MMU_CBPDATA11m BCM56504_A0_READ_MMU_CBPDATA11m
#define WRITE_MMU_CBPDATA11m BCM56504_A0_WRITE_MMU_CBPDATA11m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MMU_CBPDATA11m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  MMU_CBPData12
 * BLOCKS:   MMU
 * DESC:     CBP Data RAM 12
 * SIZE:     64
 * FIELDS:
 *     CBPDATA          CBPData [831:768]
 *
 ******************************************************************************/
#define BCM56504_A0_MMU_CBPDATA12m 0x0a630000

#define BCM56504_A0_MMU_CBPDATA12m_MIN 0
#define BCM56504_A0_MMU_CBPDATA12m_MAX 16383
#define BCM56504_A0_MMU_CBPDATA12m_CMAX(u) 16383
#define BCM56504_A0_MMU_CBPDATA12m_SIZE 8

/*
 * This structure should be used to declare and program MMU_CBPData12.
 *
 */
typedef union BCM56504_A0_MMU_CBPDATA12m_s {
	uint32_t v[2];
	uint32_t mmu_cbpdata12[2];
	uint32_t _mmu_cbpdata12;
} BCM56504_A0_MMU_CBPDATA12m_t;

#define BCM56504_A0_MMU_CBPDATA12m_CLR(r) CDK_MEMSET(&((r)._mmu_cbpdata12), 0, sizeof(BCM56504_A0_MMU_CBPDATA12m_t))
#define BCM56504_A0_MMU_CBPDATA12m_SET(r,i,d) (r).mmu_cbpdata12[i] = d
#define BCM56504_A0_MMU_CBPDATA12m_GET(r,i) (r).mmu_cbpdata12[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MMU_CBPDATA12m_CBPDATAf_GET(r,a) cdk_field_get((r).mmu_cbpdata12,0,63,a)
#define BCM56504_A0_MMU_CBPDATA12m_CBPDATAf_SET(r,a) cdk_field_set((r).mmu_cbpdata12,0,63,a)

/*
 * These macros can be used to access MMU_CBPData12.
 *
 */
#define BCM56504_A0_READ_MMU_CBPDATA12m(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_MMU_CBPDATA12m,i,(m._mmu_cbpdata12),2)
#define BCM56504_A0_WRITE_MMU_CBPDATA12m(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_MMU_CBPDATA12m,i,&(m._mmu_cbpdata12),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CBPDATA12m BCM56504_A0_MMU_CBPDATA12m
#define MMU_CBPDATA12m_MIN BCM56504_A0_MMU_CBPDATA12m_MIN
#define MMU_CBPDATA12m_MAX BCM56504_A0_MMU_CBPDATA12m_MAX
#define MMU_CBPDATA12m_CMAX(u) BCM56504_A0_MMU_CBPDATA12m_CMAX(u)
#define MMU_CBPDATA12m_SIZE BCM56504_A0_MMU_CBPDATA12m_SIZE
typedef BCM56504_A0_MMU_CBPDATA12m_t MMU_CBPDATA12m_t;
#define MMU_CBPDATA12m_CLR BCM56504_A0_MMU_CBPDATA12m_CLR
#define MMU_CBPDATA12m_SET BCM56504_A0_MMU_CBPDATA12m_SET
#define MMU_CBPDATA12m_GET BCM56504_A0_MMU_CBPDATA12m_GET
#define MMU_CBPDATA12m_CBPDATAf_GET BCM56504_A0_MMU_CBPDATA12m_CBPDATAf_GET
#define MMU_CBPDATA12m_CBPDATAf_SET BCM56504_A0_MMU_CBPDATA12m_CBPDATAf_SET
#define READ_MMU_CBPDATA12m BCM56504_A0_READ_MMU_CBPDATA12m
#define WRITE_MMU_CBPDATA12m BCM56504_A0_WRITE_MMU_CBPDATA12m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MMU_CBPDATA12m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  MMU_CBPData13
 * BLOCKS:   MMU
 * DESC:     CBP Data RAM 13
 * SIZE:     64
 * FIELDS:
 *     CBPDATA          CBPData [895:832]
 *
 ******************************************************************************/
#define BCM56504_A0_MMU_CBPDATA13m 0x0a634000

#define BCM56504_A0_MMU_CBPDATA13m_MIN 0
#define BCM56504_A0_MMU_CBPDATA13m_MAX 16383
#define BCM56504_A0_MMU_CBPDATA13m_CMAX(u) 16383
#define BCM56504_A0_MMU_CBPDATA13m_SIZE 8

/*
 * This structure should be used to declare and program MMU_CBPData13.
 *
 */
typedef union BCM56504_A0_MMU_CBPDATA13m_s {
	uint32_t v[2];
	uint32_t mmu_cbpdata13[2];
	uint32_t _mmu_cbpdata13;
} BCM56504_A0_MMU_CBPDATA13m_t;

#define BCM56504_A0_MMU_CBPDATA13m_CLR(r) CDK_MEMSET(&((r)._mmu_cbpdata13), 0, sizeof(BCM56504_A0_MMU_CBPDATA13m_t))
#define BCM56504_A0_MMU_CBPDATA13m_SET(r,i,d) (r).mmu_cbpdata13[i] = d
#define BCM56504_A0_MMU_CBPDATA13m_GET(r,i) (r).mmu_cbpdata13[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MMU_CBPDATA13m_CBPDATAf_GET(r,a) cdk_field_get((r).mmu_cbpdata13,0,63,a)
#define BCM56504_A0_MMU_CBPDATA13m_CBPDATAf_SET(r,a) cdk_field_set((r).mmu_cbpdata13,0,63,a)

/*
 * These macros can be used to access MMU_CBPData13.
 *
 */
#define BCM56504_A0_READ_MMU_CBPDATA13m(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_MMU_CBPDATA13m,i,(m._mmu_cbpdata13),2)
#define BCM56504_A0_WRITE_MMU_CBPDATA13m(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_MMU_CBPDATA13m,i,&(m._mmu_cbpdata13),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CBPDATA13m BCM56504_A0_MMU_CBPDATA13m
#define MMU_CBPDATA13m_MIN BCM56504_A0_MMU_CBPDATA13m_MIN
#define MMU_CBPDATA13m_MAX BCM56504_A0_MMU_CBPDATA13m_MAX
#define MMU_CBPDATA13m_CMAX(u) BCM56504_A0_MMU_CBPDATA13m_CMAX(u)
#define MMU_CBPDATA13m_SIZE BCM56504_A0_MMU_CBPDATA13m_SIZE
typedef BCM56504_A0_MMU_CBPDATA13m_t MMU_CBPDATA13m_t;
#define MMU_CBPDATA13m_CLR BCM56504_A0_MMU_CBPDATA13m_CLR
#define MMU_CBPDATA13m_SET BCM56504_A0_MMU_CBPDATA13m_SET
#define MMU_CBPDATA13m_GET BCM56504_A0_MMU_CBPDATA13m_GET
#define MMU_CBPDATA13m_CBPDATAf_GET BCM56504_A0_MMU_CBPDATA13m_CBPDATAf_GET
#define MMU_CBPDATA13m_CBPDATAf_SET BCM56504_A0_MMU_CBPDATA13m_CBPDATAf_SET
#define READ_MMU_CBPDATA13m BCM56504_A0_READ_MMU_CBPDATA13m
#define WRITE_MMU_CBPDATA13m BCM56504_A0_WRITE_MMU_CBPDATA13m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MMU_CBPDATA13m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  MMU_CBPData14
 * BLOCKS:   MMU
 * DESC:     CBP Data RAM 14
 * SIZE:     64
 * FIELDS:
 *     CBPDATA          CBPData [959:896]
 *
 ******************************************************************************/
#define BCM56504_A0_MMU_CBPDATA14m 0x0a638000

#define BCM56504_A0_MMU_CBPDATA14m_MIN 0
#define BCM56504_A0_MMU_CBPDATA14m_MAX 16383
#define BCM56504_A0_MMU_CBPDATA14m_CMAX(u) 16383
#define BCM56504_A0_MMU_CBPDATA14m_SIZE 8

/*
 * This structure should be used to declare and program MMU_CBPData14.
 *
 */
typedef union BCM56504_A0_MMU_CBPDATA14m_s {
	uint32_t v[2];
	uint32_t mmu_cbpdata14[2];
	uint32_t _mmu_cbpdata14;
} BCM56504_A0_MMU_CBPDATA14m_t;

#define BCM56504_A0_MMU_CBPDATA14m_CLR(r) CDK_MEMSET(&((r)._mmu_cbpdata14), 0, sizeof(BCM56504_A0_MMU_CBPDATA14m_t))
#define BCM56504_A0_MMU_CBPDATA14m_SET(r,i,d) (r).mmu_cbpdata14[i] = d
#define BCM56504_A0_MMU_CBPDATA14m_GET(r,i) (r).mmu_cbpdata14[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MMU_CBPDATA14m_CBPDATAf_GET(r,a) cdk_field_get((r).mmu_cbpdata14,0,63,a)
#define BCM56504_A0_MMU_CBPDATA14m_CBPDATAf_SET(r,a) cdk_field_set((r).mmu_cbpdata14,0,63,a)

/*
 * These macros can be used to access MMU_CBPData14.
 *
 */
#define BCM56504_A0_READ_MMU_CBPDATA14m(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_MMU_CBPDATA14m,i,(m._mmu_cbpdata14),2)
#define BCM56504_A0_WRITE_MMU_CBPDATA14m(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_MMU_CBPDATA14m,i,&(m._mmu_cbpdata14),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CBPDATA14m BCM56504_A0_MMU_CBPDATA14m
#define MMU_CBPDATA14m_MIN BCM56504_A0_MMU_CBPDATA14m_MIN
#define MMU_CBPDATA14m_MAX BCM56504_A0_MMU_CBPDATA14m_MAX
#define MMU_CBPDATA14m_CMAX(u) BCM56504_A0_MMU_CBPDATA14m_CMAX(u)
#define MMU_CBPDATA14m_SIZE BCM56504_A0_MMU_CBPDATA14m_SIZE
typedef BCM56504_A0_MMU_CBPDATA14m_t MMU_CBPDATA14m_t;
#define MMU_CBPDATA14m_CLR BCM56504_A0_MMU_CBPDATA14m_CLR
#define MMU_CBPDATA14m_SET BCM56504_A0_MMU_CBPDATA14m_SET
#define MMU_CBPDATA14m_GET BCM56504_A0_MMU_CBPDATA14m_GET
#define MMU_CBPDATA14m_CBPDATAf_GET BCM56504_A0_MMU_CBPDATA14m_CBPDATAf_GET
#define MMU_CBPDATA14m_CBPDATAf_SET BCM56504_A0_MMU_CBPDATA14m_CBPDATAf_SET
#define READ_MMU_CBPDATA14m BCM56504_A0_READ_MMU_CBPDATA14m
#define WRITE_MMU_CBPDATA14m BCM56504_A0_WRITE_MMU_CBPDATA14m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MMU_CBPDATA14m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  MMU_CBPData15
 * BLOCKS:   MMU
 * DESC:     CBP Data RAM 15
 * SIZE:     64
 * FIELDS:
 *     CBPDATA          CBPData [1023:960]
 *
 ******************************************************************************/
#define BCM56504_A0_MMU_CBPDATA15m 0x0a63c000

#define BCM56504_A0_MMU_CBPDATA15m_MIN 0
#define BCM56504_A0_MMU_CBPDATA15m_MAX 16383
#define BCM56504_A0_MMU_CBPDATA15m_CMAX(u) 16383
#define BCM56504_A0_MMU_CBPDATA15m_SIZE 8

/*
 * This structure should be used to declare and program MMU_CBPData15.
 *
 */
typedef union BCM56504_A0_MMU_CBPDATA15m_s {
	uint32_t v[2];
	uint32_t mmu_cbpdata15[2];
	uint32_t _mmu_cbpdata15;
} BCM56504_A0_MMU_CBPDATA15m_t;

#define BCM56504_A0_MMU_CBPDATA15m_CLR(r) CDK_MEMSET(&((r)._mmu_cbpdata15), 0, sizeof(BCM56504_A0_MMU_CBPDATA15m_t))
#define BCM56504_A0_MMU_CBPDATA15m_SET(r,i,d) (r).mmu_cbpdata15[i] = d
#define BCM56504_A0_MMU_CBPDATA15m_GET(r,i) (r).mmu_cbpdata15[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MMU_CBPDATA15m_CBPDATAf_GET(r,a) cdk_field_get((r).mmu_cbpdata15,0,63,a)
#define BCM56504_A0_MMU_CBPDATA15m_CBPDATAf_SET(r,a) cdk_field_set((r).mmu_cbpdata15,0,63,a)

/*
 * These macros can be used to access MMU_CBPData15.
 *
 */
#define BCM56504_A0_READ_MMU_CBPDATA15m(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_MMU_CBPDATA15m,i,(m._mmu_cbpdata15),2)
#define BCM56504_A0_WRITE_MMU_CBPDATA15m(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_MMU_CBPDATA15m,i,&(m._mmu_cbpdata15),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CBPDATA15m BCM56504_A0_MMU_CBPDATA15m
#define MMU_CBPDATA15m_MIN BCM56504_A0_MMU_CBPDATA15m_MIN
#define MMU_CBPDATA15m_MAX BCM56504_A0_MMU_CBPDATA15m_MAX
#define MMU_CBPDATA15m_CMAX(u) BCM56504_A0_MMU_CBPDATA15m_CMAX(u)
#define MMU_CBPDATA15m_SIZE BCM56504_A0_MMU_CBPDATA15m_SIZE
typedef BCM56504_A0_MMU_CBPDATA15m_t MMU_CBPDATA15m_t;
#define MMU_CBPDATA15m_CLR BCM56504_A0_MMU_CBPDATA15m_CLR
#define MMU_CBPDATA15m_SET BCM56504_A0_MMU_CBPDATA15m_SET
#define MMU_CBPDATA15m_GET BCM56504_A0_MMU_CBPDATA15m_GET
#define MMU_CBPDATA15m_CBPDATAf_GET BCM56504_A0_MMU_CBPDATA15m_CBPDATAf_GET
#define MMU_CBPDATA15m_CBPDATAf_SET BCM56504_A0_MMU_CBPDATA15m_CBPDATAf_SET
#define READ_MMU_CBPDATA15m BCM56504_A0_READ_MMU_CBPDATA15m
#define WRITE_MMU_CBPDATA15m BCM56504_A0_WRITE_MMU_CBPDATA15m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MMU_CBPDATA15m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  MMU_CBPData2
 * BLOCKS:   MMU
 * DESC:     CBP Data RAM 2
 * SIZE:     64
 * FIELDS:
 *     CBPDATA          CBPData [191:128]
 *
 ******************************************************************************/
#define BCM56504_A0_MMU_CBPDATA2m 0x0a608000

#define BCM56504_A0_MMU_CBPDATA2m_MIN 0
#define BCM56504_A0_MMU_CBPDATA2m_MAX 16383
#define BCM56504_A0_MMU_CBPDATA2m_CMAX(u) 16383
#define BCM56504_A0_MMU_CBPDATA2m_SIZE 8

/*
 * This structure should be used to declare and program MMU_CBPData2.
 *
 */
typedef union BCM56504_A0_MMU_CBPDATA2m_s {
	uint32_t v[2];
	uint32_t mmu_cbpdata2[2];
	uint32_t _mmu_cbpdata2;
} BCM56504_A0_MMU_CBPDATA2m_t;

#define BCM56504_A0_MMU_CBPDATA2m_CLR(r) CDK_MEMSET(&((r)._mmu_cbpdata2), 0, sizeof(BCM56504_A0_MMU_CBPDATA2m_t))
#define BCM56504_A0_MMU_CBPDATA2m_SET(r,i,d) (r).mmu_cbpdata2[i] = d
#define BCM56504_A0_MMU_CBPDATA2m_GET(r,i) (r).mmu_cbpdata2[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MMU_CBPDATA2m_CBPDATAf_GET(r,a) cdk_field_get((r).mmu_cbpdata2,0,63,a)
#define BCM56504_A0_MMU_CBPDATA2m_CBPDATAf_SET(r,a) cdk_field_set((r).mmu_cbpdata2,0,63,a)

/*
 * These macros can be used to access MMU_CBPData2.
 *
 */
#define BCM56504_A0_READ_MMU_CBPDATA2m(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_MMU_CBPDATA2m,i,(m._mmu_cbpdata2),2)
#define BCM56504_A0_WRITE_MMU_CBPDATA2m(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_MMU_CBPDATA2m,i,&(m._mmu_cbpdata2),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CBPDATA2m BCM56504_A0_MMU_CBPDATA2m
#define MMU_CBPDATA2m_MIN BCM56504_A0_MMU_CBPDATA2m_MIN
#define MMU_CBPDATA2m_MAX BCM56504_A0_MMU_CBPDATA2m_MAX
#define MMU_CBPDATA2m_CMAX(u) BCM56504_A0_MMU_CBPDATA2m_CMAX(u)
#define MMU_CBPDATA2m_SIZE BCM56504_A0_MMU_CBPDATA2m_SIZE
typedef BCM56504_A0_MMU_CBPDATA2m_t MMU_CBPDATA2m_t;
#define MMU_CBPDATA2m_CLR BCM56504_A0_MMU_CBPDATA2m_CLR
#define MMU_CBPDATA2m_SET BCM56504_A0_MMU_CBPDATA2m_SET
#define MMU_CBPDATA2m_GET BCM56504_A0_MMU_CBPDATA2m_GET
#define MMU_CBPDATA2m_CBPDATAf_GET BCM56504_A0_MMU_CBPDATA2m_CBPDATAf_GET
#define MMU_CBPDATA2m_CBPDATAf_SET BCM56504_A0_MMU_CBPDATA2m_CBPDATAf_SET
#define READ_MMU_CBPDATA2m BCM56504_A0_READ_MMU_CBPDATA2m
#define WRITE_MMU_CBPDATA2m BCM56504_A0_WRITE_MMU_CBPDATA2m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MMU_CBPDATA2m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  MMU_CBPData3
 * BLOCKS:   MMU
 * DESC:     CBP Data RAM 3
 * SIZE:     64
 * FIELDS:
 *     CBPDATA          CBPData [255:192]
 *
 ******************************************************************************/
#define BCM56504_A0_MMU_CBPDATA3m 0x0a60c000

#define BCM56504_A0_MMU_CBPDATA3m_MIN 0
#define BCM56504_A0_MMU_CBPDATA3m_MAX 16383
#define BCM56504_A0_MMU_CBPDATA3m_CMAX(u) 16383
#define BCM56504_A0_MMU_CBPDATA3m_SIZE 8

/*
 * This structure should be used to declare and program MMU_CBPData3.
 *
 */
typedef union BCM56504_A0_MMU_CBPDATA3m_s {
	uint32_t v[2];
	uint32_t mmu_cbpdata3[2];
	uint32_t _mmu_cbpdata3;
} BCM56504_A0_MMU_CBPDATA3m_t;

#define BCM56504_A0_MMU_CBPDATA3m_CLR(r) CDK_MEMSET(&((r)._mmu_cbpdata3), 0, sizeof(BCM56504_A0_MMU_CBPDATA3m_t))
#define BCM56504_A0_MMU_CBPDATA3m_SET(r,i,d) (r).mmu_cbpdata3[i] = d
#define BCM56504_A0_MMU_CBPDATA3m_GET(r,i) (r).mmu_cbpdata3[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MMU_CBPDATA3m_CBPDATAf_GET(r,a) cdk_field_get((r).mmu_cbpdata3,0,63,a)
#define BCM56504_A0_MMU_CBPDATA3m_CBPDATAf_SET(r,a) cdk_field_set((r).mmu_cbpdata3,0,63,a)

/*
 * These macros can be used to access MMU_CBPData3.
 *
 */
#define BCM56504_A0_READ_MMU_CBPDATA3m(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_MMU_CBPDATA3m,i,(m._mmu_cbpdata3),2)
#define BCM56504_A0_WRITE_MMU_CBPDATA3m(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_MMU_CBPDATA3m,i,&(m._mmu_cbpdata3),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CBPDATA3m BCM56504_A0_MMU_CBPDATA3m
#define MMU_CBPDATA3m_MIN BCM56504_A0_MMU_CBPDATA3m_MIN
#define MMU_CBPDATA3m_MAX BCM56504_A0_MMU_CBPDATA3m_MAX
#define MMU_CBPDATA3m_CMAX(u) BCM56504_A0_MMU_CBPDATA3m_CMAX(u)
#define MMU_CBPDATA3m_SIZE BCM56504_A0_MMU_CBPDATA3m_SIZE
typedef BCM56504_A0_MMU_CBPDATA3m_t MMU_CBPDATA3m_t;
#define MMU_CBPDATA3m_CLR BCM56504_A0_MMU_CBPDATA3m_CLR
#define MMU_CBPDATA3m_SET BCM56504_A0_MMU_CBPDATA3m_SET
#define MMU_CBPDATA3m_GET BCM56504_A0_MMU_CBPDATA3m_GET
#define MMU_CBPDATA3m_CBPDATAf_GET BCM56504_A0_MMU_CBPDATA3m_CBPDATAf_GET
#define MMU_CBPDATA3m_CBPDATAf_SET BCM56504_A0_MMU_CBPDATA3m_CBPDATAf_SET
#define READ_MMU_CBPDATA3m BCM56504_A0_READ_MMU_CBPDATA3m
#define WRITE_MMU_CBPDATA3m BCM56504_A0_WRITE_MMU_CBPDATA3m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MMU_CBPDATA3m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  MMU_CBPData4
 * BLOCKS:   MMU
 * DESC:     CBP Data RAM 4
 * SIZE:     64
 * FIELDS:
 *     CBPDATA          CBPData [319:256]
 *
 ******************************************************************************/
#define BCM56504_A0_MMU_CBPDATA4m 0x0a610000

#define BCM56504_A0_MMU_CBPDATA4m_MIN 0
#define BCM56504_A0_MMU_CBPDATA4m_MAX 16383
#define BCM56504_A0_MMU_CBPDATA4m_CMAX(u) 16383
#define BCM56504_A0_MMU_CBPDATA4m_SIZE 8

/*
 * This structure should be used to declare and program MMU_CBPData4.
 *
 */
typedef union BCM56504_A0_MMU_CBPDATA4m_s {
	uint32_t v[2];
	uint32_t mmu_cbpdata4[2];
	uint32_t _mmu_cbpdata4;
} BCM56504_A0_MMU_CBPDATA4m_t;

#define BCM56504_A0_MMU_CBPDATA4m_CLR(r) CDK_MEMSET(&((r)._mmu_cbpdata4), 0, sizeof(BCM56504_A0_MMU_CBPDATA4m_t))
#define BCM56504_A0_MMU_CBPDATA4m_SET(r,i,d) (r).mmu_cbpdata4[i] = d
#define BCM56504_A0_MMU_CBPDATA4m_GET(r,i) (r).mmu_cbpdata4[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MMU_CBPDATA4m_CBPDATAf_GET(r,a) cdk_field_get((r).mmu_cbpdata4,0,63,a)
#define BCM56504_A0_MMU_CBPDATA4m_CBPDATAf_SET(r,a) cdk_field_set((r).mmu_cbpdata4,0,63,a)

/*
 * These macros can be used to access MMU_CBPData4.
 *
 */
#define BCM56504_A0_READ_MMU_CBPDATA4m(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_MMU_CBPDATA4m,i,(m._mmu_cbpdata4),2)
#define BCM56504_A0_WRITE_MMU_CBPDATA4m(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_MMU_CBPDATA4m,i,&(m._mmu_cbpdata4),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CBPDATA4m BCM56504_A0_MMU_CBPDATA4m
#define MMU_CBPDATA4m_MIN BCM56504_A0_MMU_CBPDATA4m_MIN
#define MMU_CBPDATA4m_MAX BCM56504_A0_MMU_CBPDATA4m_MAX
#define MMU_CBPDATA4m_CMAX(u) BCM56504_A0_MMU_CBPDATA4m_CMAX(u)
#define MMU_CBPDATA4m_SIZE BCM56504_A0_MMU_CBPDATA4m_SIZE
typedef BCM56504_A0_MMU_CBPDATA4m_t MMU_CBPDATA4m_t;
#define MMU_CBPDATA4m_CLR BCM56504_A0_MMU_CBPDATA4m_CLR
#define MMU_CBPDATA4m_SET BCM56504_A0_MMU_CBPDATA4m_SET
#define MMU_CBPDATA4m_GET BCM56504_A0_MMU_CBPDATA4m_GET
#define MMU_CBPDATA4m_CBPDATAf_GET BCM56504_A0_MMU_CBPDATA4m_CBPDATAf_GET
#define MMU_CBPDATA4m_CBPDATAf_SET BCM56504_A0_MMU_CBPDATA4m_CBPDATAf_SET
#define READ_MMU_CBPDATA4m BCM56504_A0_READ_MMU_CBPDATA4m
#define WRITE_MMU_CBPDATA4m BCM56504_A0_WRITE_MMU_CBPDATA4m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MMU_CBPDATA4m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  MMU_CBPData5
 * BLOCKS:   MMU
 * DESC:     CBP Data RAM 5
 * SIZE:     64
 * FIELDS:
 *     CBPDATA          CBPData [383:320]
 *
 ******************************************************************************/
#define BCM56504_A0_MMU_CBPDATA5m 0x0a614000

#define BCM56504_A0_MMU_CBPDATA5m_MIN 0
#define BCM56504_A0_MMU_CBPDATA5m_MAX 16383
#define BCM56504_A0_MMU_CBPDATA5m_CMAX(u) 16383
#define BCM56504_A0_MMU_CBPDATA5m_SIZE 8

/*
 * This structure should be used to declare and program MMU_CBPData5.
 *
 */
typedef union BCM56504_A0_MMU_CBPDATA5m_s {
	uint32_t v[2];
	uint32_t mmu_cbpdata5[2];
	uint32_t _mmu_cbpdata5;
} BCM56504_A0_MMU_CBPDATA5m_t;

#define BCM56504_A0_MMU_CBPDATA5m_CLR(r) CDK_MEMSET(&((r)._mmu_cbpdata5), 0, sizeof(BCM56504_A0_MMU_CBPDATA5m_t))
#define BCM56504_A0_MMU_CBPDATA5m_SET(r,i,d) (r).mmu_cbpdata5[i] = d
#define BCM56504_A0_MMU_CBPDATA5m_GET(r,i) (r).mmu_cbpdata5[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MMU_CBPDATA5m_CBPDATAf_GET(r,a) cdk_field_get((r).mmu_cbpdata5,0,63,a)
#define BCM56504_A0_MMU_CBPDATA5m_CBPDATAf_SET(r,a) cdk_field_set((r).mmu_cbpdata5,0,63,a)

/*
 * These macros can be used to access MMU_CBPData5.
 *
 */
#define BCM56504_A0_READ_MMU_CBPDATA5m(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_MMU_CBPDATA5m,i,(m._mmu_cbpdata5),2)
#define BCM56504_A0_WRITE_MMU_CBPDATA5m(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_MMU_CBPDATA5m,i,&(m._mmu_cbpdata5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CBPDATA5m BCM56504_A0_MMU_CBPDATA5m
#define MMU_CBPDATA5m_MIN BCM56504_A0_MMU_CBPDATA5m_MIN
#define MMU_CBPDATA5m_MAX BCM56504_A0_MMU_CBPDATA5m_MAX
#define MMU_CBPDATA5m_CMAX(u) BCM56504_A0_MMU_CBPDATA5m_CMAX(u)
#define MMU_CBPDATA5m_SIZE BCM56504_A0_MMU_CBPDATA5m_SIZE
typedef BCM56504_A0_MMU_CBPDATA5m_t MMU_CBPDATA5m_t;
#define MMU_CBPDATA5m_CLR BCM56504_A0_MMU_CBPDATA5m_CLR
#define MMU_CBPDATA5m_SET BCM56504_A0_MMU_CBPDATA5m_SET
#define MMU_CBPDATA5m_GET BCM56504_A0_MMU_CBPDATA5m_GET
#define MMU_CBPDATA5m_CBPDATAf_GET BCM56504_A0_MMU_CBPDATA5m_CBPDATAf_GET
#define MMU_CBPDATA5m_CBPDATAf_SET BCM56504_A0_MMU_CBPDATA5m_CBPDATAf_SET
#define READ_MMU_CBPDATA5m BCM56504_A0_READ_MMU_CBPDATA5m
#define WRITE_MMU_CBPDATA5m BCM56504_A0_WRITE_MMU_CBPDATA5m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MMU_CBPDATA5m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  MMU_CBPData6
 * BLOCKS:   MMU
 * DESC:     CBP Data RAM 6
 * SIZE:     64
 * FIELDS:
 *     CBPDATA          CBPData [447:384]
 *
 ******************************************************************************/
#define BCM56504_A0_MMU_CBPDATA6m 0x0a618000

#define BCM56504_A0_MMU_CBPDATA6m_MIN 0
#define BCM56504_A0_MMU_CBPDATA6m_MAX 16383
#define BCM56504_A0_MMU_CBPDATA6m_CMAX(u) 16383
#define BCM56504_A0_MMU_CBPDATA6m_SIZE 8

/*
 * This structure should be used to declare and program MMU_CBPData6.
 *
 */
typedef union BCM56504_A0_MMU_CBPDATA6m_s {
	uint32_t v[2];
	uint32_t mmu_cbpdata6[2];
	uint32_t _mmu_cbpdata6;
} BCM56504_A0_MMU_CBPDATA6m_t;

#define BCM56504_A0_MMU_CBPDATA6m_CLR(r) CDK_MEMSET(&((r)._mmu_cbpdata6), 0, sizeof(BCM56504_A0_MMU_CBPDATA6m_t))
#define BCM56504_A0_MMU_CBPDATA6m_SET(r,i,d) (r).mmu_cbpdata6[i] = d
#define BCM56504_A0_MMU_CBPDATA6m_GET(r,i) (r).mmu_cbpdata6[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MMU_CBPDATA6m_CBPDATAf_GET(r,a) cdk_field_get((r).mmu_cbpdata6,0,63,a)
#define BCM56504_A0_MMU_CBPDATA6m_CBPDATAf_SET(r,a) cdk_field_set((r).mmu_cbpdata6,0,63,a)

/*
 * These macros can be used to access MMU_CBPData6.
 *
 */
#define BCM56504_A0_READ_MMU_CBPDATA6m(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_MMU_CBPDATA6m,i,(m._mmu_cbpdata6),2)
#define BCM56504_A0_WRITE_MMU_CBPDATA6m(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_MMU_CBPDATA6m,i,&(m._mmu_cbpdata6),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CBPDATA6m BCM56504_A0_MMU_CBPDATA6m
#define MMU_CBPDATA6m_MIN BCM56504_A0_MMU_CBPDATA6m_MIN
#define MMU_CBPDATA6m_MAX BCM56504_A0_MMU_CBPDATA6m_MAX
#define MMU_CBPDATA6m_CMAX(u) BCM56504_A0_MMU_CBPDATA6m_CMAX(u)
#define MMU_CBPDATA6m_SIZE BCM56504_A0_MMU_CBPDATA6m_SIZE
typedef BCM56504_A0_MMU_CBPDATA6m_t MMU_CBPDATA6m_t;
#define MMU_CBPDATA6m_CLR BCM56504_A0_MMU_CBPDATA6m_CLR
#define MMU_CBPDATA6m_SET BCM56504_A0_MMU_CBPDATA6m_SET
#define MMU_CBPDATA6m_GET BCM56504_A0_MMU_CBPDATA6m_GET
#define MMU_CBPDATA6m_CBPDATAf_GET BCM56504_A0_MMU_CBPDATA6m_CBPDATAf_GET
#define MMU_CBPDATA6m_CBPDATAf_SET BCM56504_A0_MMU_CBPDATA6m_CBPDATAf_SET
#define READ_MMU_CBPDATA6m BCM56504_A0_READ_MMU_CBPDATA6m
#define WRITE_MMU_CBPDATA6m BCM56504_A0_WRITE_MMU_CBPDATA6m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MMU_CBPDATA6m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  MMU_CBPData7
 * BLOCKS:   MMU
 * DESC:     CBP Data RAM 7
 * SIZE:     64
 * FIELDS:
 *     CBPDATA          CBPData [511:448]
 *
 ******************************************************************************/
#define BCM56504_A0_MMU_CBPDATA7m 0x0a61c000

#define BCM56504_A0_MMU_CBPDATA7m_MIN 0
#define BCM56504_A0_MMU_CBPDATA7m_MAX 16383
#define BCM56504_A0_MMU_CBPDATA7m_CMAX(u) 16383
#define BCM56504_A0_MMU_CBPDATA7m_SIZE 8

/*
 * This structure should be used to declare and program MMU_CBPData7.
 *
 */
typedef union BCM56504_A0_MMU_CBPDATA7m_s {
	uint32_t v[2];
	uint32_t mmu_cbpdata7[2];
	uint32_t _mmu_cbpdata7;
} BCM56504_A0_MMU_CBPDATA7m_t;

#define BCM56504_A0_MMU_CBPDATA7m_CLR(r) CDK_MEMSET(&((r)._mmu_cbpdata7), 0, sizeof(BCM56504_A0_MMU_CBPDATA7m_t))
#define BCM56504_A0_MMU_CBPDATA7m_SET(r,i,d) (r).mmu_cbpdata7[i] = d
#define BCM56504_A0_MMU_CBPDATA7m_GET(r,i) (r).mmu_cbpdata7[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MMU_CBPDATA7m_CBPDATAf_GET(r,a) cdk_field_get((r).mmu_cbpdata7,0,63,a)
#define BCM56504_A0_MMU_CBPDATA7m_CBPDATAf_SET(r,a) cdk_field_set((r).mmu_cbpdata7,0,63,a)

/*
 * These macros can be used to access MMU_CBPData7.
 *
 */
#define BCM56504_A0_READ_MMU_CBPDATA7m(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_MMU_CBPDATA7m,i,(m._mmu_cbpdata7),2)
#define BCM56504_A0_WRITE_MMU_CBPDATA7m(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_MMU_CBPDATA7m,i,&(m._mmu_cbpdata7),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CBPDATA7m BCM56504_A0_MMU_CBPDATA7m
#define MMU_CBPDATA7m_MIN BCM56504_A0_MMU_CBPDATA7m_MIN
#define MMU_CBPDATA7m_MAX BCM56504_A0_MMU_CBPDATA7m_MAX
#define MMU_CBPDATA7m_CMAX(u) BCM56504_A0_MMU_CBPDATA7m_CMAX(u)
#define MMU_CBPDATA7m_SIZE BCM56504_A0_MMU_CBPDATA7m_SIZE
typedef BCM56504_A0_MMU_CBPDATA7m_t MMU_CBPDATA7m_t;
#define MMU_CBPDATA7m_CLR BCM56504_A0_MMU_CBPDATA7m_CLR
#define MMU_CBPDATA7m_SET BCM56504_A0_MMU_CBPDATA7m_SET
#define MMU_CBPDATA7m_GET BCM56504_A0_MMU_CBPDATA7m_GET
#define MMU_CBPDATA7m_CBPDATAf_GET BCM56504_A0_MMU_CBPDATA7m_CBPDATAf_GET
#define MMU_CBPDATA7m_CBPDATAf_SET BCM56504_A0_MMU_CBPDATA7m_CBPDATAf_SET
#define READ_MMU_CBPDATA7m BCM56504_A0_READ_MMU_CBPDATA7m
#define WRITE_MMU_CBPDATA7m BCM56504_A0_WRITE_MMU_CBPDATA7m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MMU_CBPDATA7m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  MMU_CBPData8
 * BLOCKS:   MMU
 * DESC:     CBP Data RAM 8
 * SIZE:     64
 * FIELDS:
 *     CBPDATA          CBPData [575:512]
 *
 ******************************************************************************/
#define BCM56504_A0_MMU_CBPDATA8m 0x0a620000

#define BCM56504_A0_MMU_CBPDATA8m_MIN 0
#define BCM56504_A0_MMU_CBPDATA8m_MAX 16383
#define BCM56504_A0_MMU_CBPDATA8m_CMAX(u) 16383
#define BCM56504_A0_MMU_CBPDATA8m_SIZE 8

/*
 * This structure should be used to declare and program MMU_CBPData8.
 *
 */
typedef union BCM56504_A0_MMU_CBPDATA8m_s {
	uint32_t v[2];
	uint32_t mmu_cbpdata8[2];
	uint32_t _mmu_cbpdata8;
} BCM56504_A0_MMU_CBPDATA8m_t;

#define BCM56504_A0_MMU_CBPDATA8m_CLR(r) CDK_MEMSET(&((r)._mmu_cbpdata8), 0, sizeof(BCM56504_A0_MMU_CBPDATA8m_t))
#define BCM56504_A0_MMU_CBPDATA8m_SET(r,i,d) (r).mmu_cbpdata8[i] = d
#define BCM56504_A0_MMU_CBPDATA8m_GET(r,i) (r).mmu_cbpdata8[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MMU_CBPDATA8m_CBPDATAf_GET(r,a) cdk_field_get((r).mmu_cbpdata8,0,63,a)
#define BCM56504_A0_MMU_CBPDATA8m_CBPDATAf_SET(r,a) cdk_field_set((r).mmu_cbpdata8,0,63,a)

/*
 * These macros can be used to access MMU_CBPData8.
 *
 */
#define BCM56504_A0_READ_MMU_CBPDATA8m(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_MMU_CBPDATA8m,i,(m._mmu_cbpdata8),2)
#define BCM56504_A0_WRITE_MMU_CBPDATA8m(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_MMU_CBPDATA8m,i,&(m._mmu_cbpdata8),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CBPDATA8m BCM56504_A0_MMU_CBPDATA8m
#define MMU_CBPDATA8m_MIN BCM56504_A0_MMU_CBPDATA8m_MIN
#define MMU_CBPDATA8m_MAX BCM56504_A0_MMU_CBPDATA8m_MAX
#define MMU_CBPDATA8m_CMAX(u) BCM56504_A0_MMU_CBPDATA8m_CMAX(u)
#define MMU_CBPDATA8m_SIZE BCM56504_A0_MMU_CBPDATA8m_SIZE
typedef BCM56504_A0_MMU_CBPDATA8m_t MMU_CBPDATA8m_t;
#define MMU_CBPDATA8m_CLR BCM56504_A0_MMU_CBPDATA8m_CLR
#define MMU_CBPDATA8m_SET BCM56504_A0_MMU_CBPDATA8m_SET
#define MMU_CBPDATA8m_GET BCM56504_A0_MMU_CBPDATA8m_GET
#define MMU_CBPDATA8m_CBPDATAf_GET BCM56504_A0_MMU_CBPDATA8m_CBPDATAf_GET
#define MMU_CBPDATA8m_CBPDATAf_SET BCM56504_A0_MMU_CBPDATA8m_CBPDATAf_SET
#define READ_MMU_CBPDATA8m BCM56504_A0_READ_MMU_CBPDATA8m
#define WRITE_MMU_CBPDATA8m BCM56504_A0_WRITE_MMU_CBPDATA8m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MMU_CBPDATA8m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  MMU_CBPData9
 * BLOCKS:   MMU
 * DESC:     CBP Data RAM 9
 * SIZE:     64
 * FIELDS:
 *     CBPDATA          CBPData [639:576]
 *
 ******************************************************************************/
#define BCM56504_A0_MMU_CBPDATA9m 0x0a624000

#define BCM56504_A0_MMU_CBPDATA9m_MIN 0
#define BCM56504_A0_MMU_CBPDATA9m_MAX 16383
#define BCM56504_A0_MMU_CBPDATA9m_CMAX(u) 16383
#define BCM56504_A0_MMU_CBPDATA9m_SIZE 8

/*
 * This structure should be used to declare and program MMU_CBPData9.
 *
 */
typedef union BCM56504_A0_MMU_CBPDATA9m_s {
	uint32_t v[2];
	uint32_t mmu_cbpdata9[2];
	uint32_t _mmu_cbpdata9;
} BCM56504_A0_MMU_CBPDATA9m_t;

#define BCM56504_A0_MMU_CBPDATA9m_CLR(r) CDK_MEMSET(&((r)._mmu_cbpdata9), 0, sizeof(BCM56504_A0_MMU_CBPDATA9m_t))
#define BCM56504_A0_MMU_CBPDATA9m_SET(r,i,d) (r).mmu_cbpdata9[i] = d
#define BCM56504_A0_MMU_CBPDATA9m_GET(r,i) (r).mmu_cbpdata9[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MMU_CBPDATA9m_CBPDATAf_GET(r,a) cdk_field_get((r).mmu_cbpdata9,0,63,a)
#define BCM56504_A0_MMU_CBPDATA9m_CBPDATAf_SET(r,a) cdk_field_set((r).mmu_cbpdata9,0,63,a)

/*
 * These macros can be used to access MMU_CBPData9.
 *
 */
#define BCM56504_A0_READ_MMU_CBPDATA9m(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_MMU_CBPDATA9m,i,(m._mmu_cbpdata9),2)
#define BCM56504_A0_WRITE_MMU_CBPDATA9m(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_MMU_CBPDATA9m,i,&(m._mmu_cbpdata9),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CBPDATA9m BCM56504_A0_MMU_CBPDATA9m
#define MMU_CBPDATA9m_MIN BCM56504_A0_MMU_CBPDATA9m_MIN
#define MMU_CBPDATA9m_MAX BCM56504_A0_MMU_CBPDATA9m_MAX
#define MMU_CBPDATA9m_CMAX(u) BCM56504_A0_MMU_CBPDATA9m_CMAX(u)
#define MMU_CBPDATA9m_SIZE BCM56504_A0_MMU_CBPDATA9m_SIZE
typedef BCM56504_A0_MMU_CBPDATA9m_t MMU_CBPDATA9m_t;
#define MMU_CBPDATA9m_CLR BCM56504_A0_MMU_CBPDATA9m_CLR
#define MMU_CBPDATA9m_SET BCM56504_A0_MMU_CBPDATA9m_SET
#define MMU_CBPDATA9m_GET BCM56504_A0_MMU_CBPDATA9m_GET
#define MMU_CBPDATA9m_CBPDATAf_GET BCM56504_A0_MMU_CBPDATA9m_CBPDATAf_GET
#define MMU_CBPDATA9m_CBPDATAf_SET BCM56504_A0_MMU_CBPDATA9m_CBPDATAf_SET
#define READ_MMU_CBPDATA9m BCM56504_A0_READ_MMU_CBPDATA9m
#define WRITE_MMU_CBPDATA9m BCM56504_A0_WRITE_MMU_CBPDATA9m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MMU_CBPDATA9m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  MMU_CBPPktHeader0
 * BLOCKS:   MMU
 * DESC:     CBP Packet Header RAM 0
 * SIZE:     39
 * FIELDS:
 *     SRC_PORT_TGID    Surce Port ID/TGID
 *     SRC_PORT_NUM     Source Port Number
 *     SRC_MODID        Surce Module ID
 *     NHOP_INDEX       Next HOP Index
 *     DSCP             New DSCP
 *     RESERVED_BIT_0   Reserved bit 0 for future use
 *     RESERVED_BIT_1   Reserved bit 1 for future use
 *     PARITY_0         L3 Unicast Packet Flag
 *
 ******************************************************************************/
#define BCM56504_A0_MMU_CBPPKTHEADER0m 0x0a640000

#define BCM56504_A0_MMU_CBPPKTHEADER0m_MIN 0
#define BCM56504_A0_MMU_CBPPKTHEADER0m_MAX 16383
#define BCM56504_A0_MMU_CBPPKTHEADER0m_CMAX(u) 16383
#define BCM56504_A0_MMU_CBPPKTHEADER0m_SIZE 5

/*
 * This structure should be used to declare and program MMU_CBPPktHeader0.
 *
 */
typedef union BCM56504_A0_MMU_CBPPKTHEADER0m_s {
	uint32_t v[2];
	uint32_t mmu_cbppktheader0[2];
	uint32_t _mmu_cbppktheader0;
} BCM56504_A0_MMU_CBPPKTHEADER0m_t;

#define BCM56504_A0_MMU_CBPPKTHEADER0m_CLR(r) CDK_MEMSET(&((r)._mmu_cbppktheader0), 0, sizeof(BCM56504_A0_MMU_CBPPKTHEADER0m_t))
#define BCM56504_A0_MMU_CBPPKTHEADER0m_SET(r,i,d) (r).mmu_cbppktheader0[i] = d
#define BCM56504_A0_MMU_CBPPKTHEADER0m_GET(r,i) (r).mmu_cbppktheader0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MMU_CBPPKTHEADER0m_SRC_PORT_TGIDf_GET(r) (((r).mmu_cbppktheader0[0]) & 0x3f)
#define BCM56504_A0_MMU_CBPPKTHEADER0m_SRC_PORT_TGIDf_SET(r,f) (r).mmu_cbppktheader0[0]=(((r).mmu_cbppktheader0[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM56504_A0_MMU_CBPPKTHEADER0m_SRC_PORT_NUMf_GET(r) ((((r).mmu_cbppktheader0[0]) >> 6) & 0x1f)
#define BCM56504_A0_MMU_CBPPKTHEADER0m_SRC_PORT_NUMf_SET(r,f) (r).mmu_cbppktheader0[0]=(((r).mmu_cbppktheader0[0] & ~((uint32_t)0x1f << 6)) | ((((uint32_t)f) & 0x1f) << 6))
#define BCM56504_A0_MMU_CBPPKTHEADER0m_SRC_MODIDf_GET(r) ((((r).mmu_cbppktheader0[0]) >> 11) & 0x3f)
#define BCM56504_A0_MMU_CBPPKTHEADER0m_SRC_MODIDf_SET(r,f) (r).mmu_cbppktheader0[0]=(((r).mmu_cbppktheader0[0] & ~((uint32_t)0x3f << 11)) | ((((uint32_t)f) & 0x3f) << 11))
#define BCM56504_A0_MMU_CBPPKTHEADER0m_NHOP_INDEXf_GET(r) ((((r).mmu_cbppktheader0[0]) >> 17) & 0x1fff)
#define BCM56504_A0_MMU_CBPPKTHEADER0m_NHOP_INDEXf_SET(r,f) (r).mmu_cbppktheader0[0]=(((r).mmu_cbppktheader0[0] & ~((uint32_t)0x1fff << 17)) | ((((uint32_t)f) & 0x1fff) << 17))
#define BCM56504_A0_MMU_CBPPKTHEADER0m_DSCPf_GET(r) cdk_field32_get((r).mmu_cbppktheader0,30,35)
#define BCM56504_A0_MMU_CBPPKTHEADER0m_DSCPf_SET(r,f) cdk_field32_set((r).mmu_cbppktheader0,30,35,f)
#define BCM56504_A0_MMU_CBPPKTHEADER0m_RESERVED_BIT_0f_GET(r) ((((r).mmu_cbppktheader0[1]) >> 4) & 0x1)
#define BCM56504_A0_MMU_CBPPKTHEADER0m_RESERVED_BIT_0f_SET(r,f) (r).mmu_cbppktheader0[1]=(((r).mmu_cbppktheader0[1] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56504_A0_MMU_CBPPKTHEADER0m_RESERVED_BIT_1f_GET(r) ((((r).mmu_cbppktheader0[1]) >> 5) & 0x1)
#define BCM56504_A0_MMU_CBPPKTHEADER0m_RESERVED_BIT_1f_SET(r,f) (r).mmu_cbppktheader0[1]=(((r).mmu_cbppktheader0[1] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56504_A0_MMU_CBPPKTHEADER0m_PARITY_0f_GET(r) ((((r).mmu_cbppktheader0[1]) >> 6) & 0x1)
#define BCM56504_A0_MMU_CBPPKTHEADER0m_PARITY_0f_SET(r,f) (r).mmu_cbppktheader0[1]=(((r).mmu_cbppktheader0[1] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))

/*
 * These macros can be used to access MMU_CBPPktHeader0.
 *
 */
#define BCM56504_A0_READ_MMU_CBPPKTHEADER0m(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_MMU_CBPPKTHEADER0m,i,(m._mmu_cbppktheader0),2)
#define BCM56504_A0_WRITE_MMU_CBPPKTHEADER0m(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_MMU_CBPPKTHEADER0m,i,&(m._mmu_cbppktheader0),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CBPPKTHEADER0m BCM56504_A0_MMU_CBPPKTHEADER0m
#define MMU_CBPPKTHEADER0m_MIN BCM56504_A0_MMU_CBPPKTHEADER0m_MIN
#define MMU_CBPPKTHEADER0m_MAX BCM56504_A0_MMU_CBPPKTHEADER0m_MAX
#define MMU_CBPPKTHEADER0m_CMAX(u) BCM56504_A0_MMU_CBPPKTHEADER0m_CMAX(u)
#define MMU_CBPPKTHEADER0m_SIZE BCM56504_A0_MMU_CBPPKTHEADER0m_SIZE
typedef BCM56504_A0_MMU_CBPPKTHEADER0m_t MMU_CBPPKTHEADER0m_t;
#define MMU_CBPPKTHEADER0m_CLR BCM56504_A0_MMU_CBPPKTHEADER0m_CLR
#define MMU_CBPPKTHEADER0m_SET BCM56504_A0_MMU_CBPPKTHEADER0m_SET
#define MMU_CBPPKTHEADER0m_GET BCM56504_A0_MMU_CBPPKTHEADER0m_GET
#define MMU_CBPPKTHEADER0m_SRC_PORT_TGIDf_GET BCM56504_A0_MMU_CBPPKTHEADER0m_SRC_PORT_TGIDf_GET
#define MMU_CBPPKTHEADER0m_SRC_PORT_TGIDf_SET BCM56504_A0_MMU_CBPPKTHEADER0m_SRC_PORT_TGIDf_SET
#define MMU_CBPPKTHEADER0m_SRC_PORT_NUMf_GET BCM56504_A0_MMU_CBPPKTHEADER0m_SRC_PORT_NUMf_GET
#define MMU_CBPPKTHEADER0m_SRC_PORT_NUMf_SET BCM56504_A0_MMU_CBPPKTHEADER0m_SRC_PORT_NUMf_SET
#define MMU_CBPPKTHEADER0m_SRC_MODIDf_GET BCM56504_A0_MMU_CBPPKTHEADER0m_SRC_MODIDf_GET
#define MMU_CBPPKTHEADER0m_SRC_MODIDf_SET BCM56504_A0_MMU_CBPPKTHEADER0m_SRC_MODIDf_SET
#define MMU_CBPPKTHEADER0m_NHOP_INDEXf_GET BCM56504_A0_MMU_CBPPKTHEADER0m_NHOP_INDEXf_GET
#define MMU_CBPPKTHEADER0m_NHOP_INDEXf_SET BCM56504_A0_MMU_CBPPKTHEADER0m_NHOP_INDEXf_SET
#define MMU_CBPPKTHEADER0m_DSCPf_GET BCM56504_A0_MMU_CBPPKTHEADER0m_DSCPf_GET
#define MMU_CBPPKTHEADER0m_DSCPf_SET BCM56504_A0_MMU_CBPPKTHEADER0m_DSCPf_SET
#define MMU_CBPPKTHEADER0m_RESERVED_BIT_0f_GET BCM56504_A0_MMU_CBPPKTHEADER0m_RESERVED_BIT_0f_GET
#define MMU_CBPPKTHEADER0m_RESERVED_BIT_0f_SET BCM56504_A0_MMU_CBPPKTHEADER0m_RESERVED_BIT_0f_SET
#define MMU_CBPPKTHEADER0m_RESERVED_BIT_1f_GET BCM56504_A0_MMU_CBPPKTHEADER0m_RESERVED_BIT_1f_GET
#define MMU_CBPPKTHEADER0m_RESERVED_BIT_1f_SET BCM56504_A0_MMU_CBPPKTHEADER0m_RESERVED_BIT_1f_SET
#define MMU_CBPPKTHEADER0m_PARITY_0f_GET BCM56504_A0_MMU_CBPPKTHEADER0m_PARITY_0f_GET
#define MMU_CBPPKTHEADER0m_PARITY_0f_SET BCM56504_A0_MMU_CBPPKTHEADER0m_PARITY_0f_SET
#define READ_MMU_CBPPKTHEADER0m BCM56504_A0_READ_MMU_CBPPKTHEADER0m
#define WRITE_MMU_CBPPKTHEADER0m BCM56504_A0_WRITE_MMU_CBPPKTHEADER0m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MMU_CBPPKTHEADER0m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  MMU_CBPPktHeader1
 * BLOCKS:   MMU
 * DESC:     CBP Packet Header RAM 1
 * SIZE:     39
 * FIELDS:
 *     PKT_PRI          Insert Priority
 *     PKT_VID          Insert Vlan ID
 *     ADD_VID          VLAN ID Added
 *     PKT_CFI          Insert Vlan ID
 *     INGRESS_TAGGED   Ingress Packet Tagged
 *     DST_PORT         Destination Port ID
 *     DST_MODID        Destination Module ID
 *     DECAP_IPTUNNEL   Decap IP Tunneling Packet
 *     BPDU             BPDU bit
 *     L3UC             Parity for CBP Packet Header
 *     COPY_COUNT       How Many copies of this cell are there
 *     USE_OUTER_HDR_TTL Reserved bit 1 for future use.
 *     PARITY_1         Parity for CBP Packet Header
 *
 ******************************************************************************/
#define BCM56504_A0_MMU_CBPPKTHEADER1m 0x0a644000

#define BCM56504_A0_MMU_CBPPKTHEADER1m_MIN 0
#define BCM56504_A0_MMU_CBPPKTHEADER1m_MAX 16383
#define BCM56504_A0_MMU_CBPPKTHEADER1m_CMAX(u) 16383
#define BCM56504_A0_MMU_CBPPKTHEADER1m_SIZE 5

/*
 * This structure should be used to declare and program MMU_CBPPktHeader1.
 *
 */
typedef union BCM56504_A0_MMU_CBPPKTHEADER1m_s {
	uint32_t v[2];
	uint32_t mmu_cbppktheader1[2];
	uint32_t _mmu_cbppktheader1;
} BCM56504_A0_MMU_CBPPKTHEADER1m_t;

#define BCM56504_A0_MMU_CBPPKTHEADER1m_CLR(r) CDK_MEMSET(&((r)._mmu_cbppktheader1), 0, sizeof(BCM56504_A0_MMU_CBPPKTHEADER1m_t))
#define BCM56504_A0_MMU_CBPPKTHEADER1m_SET(r,i,d) (r).mmu_cbppktheader1[i] = d
#define BCM56504_A0_MMU_CBPPKTHEADER1m_GET(r,i) (r).mmu_cbppktheader1[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MMU_CBPPKTHEADER1m_PKT_PRIf_GET(r) (((r).mmu_cbppktheader1[0]) & 0x7)
#define BCM56504_A0_MMU_CBPPKTHEADER1m_PKT_PRIf_SET(r,f) (r).mmu_cbppktheader1[0]=(((r).mmu_cbppktheader1[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM56504_A0_MMU_CBPPKTHEADER1m_PKT_VIDf_GET(r) ((((r).mmu_cbppktheader1[0]) >> 3) & 0xfff)
#define BCM56504_A0_MMU_CBPPKTHEADER1m_PKT_VIDf_SET(r,f) (r).mmu_cbppktheader1[0]=(((r).mmu_cbppktheader1[0] & ~((uint32_t)0xfff << 3)) | ((((uint32_t)f) & 0xfff) << 3))
#define BCM56504_A0_MMU_CBPPKTHEADER1m_ADD_VIDf_GET(r) ((((r).mmu_cbppktheader1[0]) >> 15) & 0x1)
#define BCM56504_A0_MMU_CBPPKTHEADER1m_ADD_VIDf_SET(r,f) (r).mmu_cbppktheader1[0]=(((r).mmu_cbppktheader1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56504_A0_MMU_CBPPKTHEADER1m_PKT_CFIf_GET(r) ((((r).mmu_cbppktheader1[0]) >> 16) & 0x1)
#define BCM56504_A0_MMU_CBPPKTHEADER1m_PKT_CFIf_SET(r,f) (r).mmu_cbppktheader1[0]=(((r).mmu_cbppktheader1[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56504_A0_MMU_CBPPKTHEADER1m_INGRESS_TAGGEDf_GET(r) ((((r).mmu_cbppktheader1[0]) >> 17) & 0x1)
#define BCM56504_A0_MMU_CBPPKTHEADER1m_INGRESS_TAGGEDf_SET(r,f) (r).mmu_cbppktheader1[0]=(((r).mmu_cbppktheader1[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56504_A0_MMU_CBPPKTHEADER1m_DST_PORTf_GET(r) ((((r).mmu_cbppktheader1[0]) >> 18) & 0x1f)
#define BCM56504_A0_MMU_CBPPKTHEADER1m_DST_PORTf_SET(r,f) (r).mmu_cbppktheader1[0]=(((r).mmu_cbppktheader1[0] & ~((uint32_t)0x1f << 18)) | ((((uint32_t)f) & 0x1f) << 18))
#define BCM56504_A0_MMU_CBPPKTHEADER1m_DST_MODIDf_GET(r) ((((r).mmu_cbppktheader1[0]) >> 23) & 0x3f)
#define BCM56504_A0_MMU_CBPPKTHEADER1m_DST_MODIDf_SET(r,f) (r).mmu_cbppktheader1[0]=(((r).mmu_cbppktheader1[0] & ~((uint32_t)0x3f << 23)) | ((((uint32_t)f) & 0x3f) << 23))
#define BCM56504_A0_MMU_CBPPKTHEADER1m_DECAP_IPTUNNELf_GET(r) ((((r).mmu_cbppktheader1[0]) >> 29) & 0x1)
#define BCM56504_A0_MMU_CBPPKTHEADER1m_DECAP_IPTUNNELf_SET(r,f) (r).mmu_cbppktheader1[0]=(((r).mmu_cbppktheader1[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM56504_A0_MMU_CBPPKTHEADER1m_BPDUf_GET(r) ((((r).mmu_cbppktheader1[0]) >> 30) & 0x1)
#define BCM56504_A0_MMU_CBPPKTHEADER1m_BPDUf_SET(r,f) (r).mmu_cbppktheader1[0]=(((r).mmu_cbppktheader1[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM56504_A0_MMU_CBPPKTHEADER1m_L3UCf_GET(r) ((((r).mmu_cbppktheader1[0]) >> 31) & 0x1)
#define BCM56504_A0_MMU_CBPPKTHEADER1m_L3UCf_SET(r,f) (r).mmu_cbppktheader1[0]=(((r).mmu_cbppktheader1[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM56504_A0_MMU_CBPPKTHEADER1m_COPY_COUNTf_GET(r) (((r).mmu_cbppktheader1[1]) & 0x1f)
#define BCM56504_A0_MMU_CBPPKTHEADER1m_COPY_COUNTf_SET(r,f) (r).mmu_cbppktheader1[1]=(((r).mmu_cbppktheader1[1] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56504_A0_MMU_CBPPKTHEADER1m_USE_OUTER_HDR_TTLf_GET(r) ((((r).mmu_cbppktheader1[1]) >> 5) & 0x1)
#define BCM56504_A0_MMU_CBPPKTHEADER1m_USE_OUTER_HDR_TTLf_SET(r,f) (r).mmu_cbppktheader1[1]=(((r).mmu_cbppktheader1[1] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56504_A0_MMU_CBPPKTHEADER1m_PARITY_1f_GET(r) ((((r).mmu_cbppktheader1[1]) >> 6) & 0x1)
#define BCM56504_A0_MMU_CBPPKTHEADER1m_PARITY_1f_SET(r,f) (r).mmu_cbppktheader1[1]=(((r).mmu_cbppktheader1[1] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))

/*
 * These macros can be used to access MMU_CBPPktHeader1.
 *
 */
#define BCM56504_A0_READ_MMU_CBPPKTHEADER1m(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_MMU_CBPPKTHEADER1m,i,(m._mmu_cbppktheader1),2)
#define BCM56504_A0_WRITE_MMU_CBPPKTHEADER1m(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_MMU_CBPPKTHEADER1m,i,&(m._mmu_cbppktheader1),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CBPPKTHEADER1m BCM56504_A0_MMU_CBPPKTHEADER1m
#define MMU_CBPPKTHEADER1m_MIN BCM56504_A0_MMU_CBPPKTHEADER1m_MIN
#define MMU_CBPPKTHEADER1m_MAX BCM56504_A0_MMU_CBPPKTHEADER1m_MAX
#define MMU_CBPPKTHEADER1m_CMAX(u) BCM56504_A0_MMU_CBPPKTHEADER1m_CMAX(u)
#define MMU_CBPPKTHEADER1m_SIZE BCM56504_A0_MMU_CBPPKTHEADER1m_SIZE
typedef BCM56504_A0_MMU_CBPPKTHEADER1m_t MMU_CBPPKTHEADER1m_t;
#define MMU_CBPPKTHEADER1m_CLR BCM56504_A0_MMU_CBPPKTHEADER1m_CLR
#define MMU_CBPPKTHEADER1m_SET BCM56504_A0_MMU_CBPPKTHEADER1m_SET
#define MMU_CBPPKTHEADER1m_GET BCM56504_A0_MMU_CBPPKTHEADER1m_GET
#define MMU_CBPPKTHEADER1m_PKT_PRIf_GET BCM56504_A0_MMU_CBPPKTHEADER1m_PKT_PRIf_GET
#define MMU_CBPPKTHEADER1m_PKT_PRIf_SET BCM56504_A0_MMU_CBPPKTHEADER1m_PKT_PRIf_SET
#define MMU_CBPPKTHEADER1m_PKT_VIDf_GET BCM56504_A0_MMU_CBPPKTHEADER1m_PKT_VIDf_GET
#define MMU_CBPPKTHEADER1m_PKT_VIDf_SET BCM56504_A0_MMU_CBPPKTHEADER1m_PKT_VIDf_SET
#define MMU_CBPPKTHEADER1m_ADD_VIDf_GET BCM56504_A0_MMU_CBPPKTHEADER1m_ADD_VIDf_GET
#define MMU_CBPPKTHEADER1m_ADD_VIDf_SET BCM56504_A0_MMU_CBPPKTHEADER1m_ADD_VIDf_SET
#define MMU_CBPPKTHEADER1m_PKT_CFIf_GET BCM56504_A0_MMU_CBPPKTHEADER1m_PKT_CFIf_GET
#define MMU_CBPPKTHEADER1m_PKT_CFIf_SET BCM56504_A0_MMU_CBPPKTHEADER1m_PKT_CFIf_SET
#define MMU_CBPPKTHEADER1m_INGRESS_TAGGEDf_GET BCM56504_A0_MMU_CBPPKTHEADER1m_INGRESS_TAGGEDf_GET
#define MMU_CBPPKTHEADER1m_INGRESS_TAGGEDf_SET BCM56504_A0_MMU_CBPPKTHEADER1m_INGRESS_TAGGEDf_SET
#define MMU_CBPPKTHEADER1m_DST_PORTf_GET BCM56504_A0_MMU_CBPPKTHEADER1m_DST_PORTf_GET
#define MMU_CBPPKTHEADER1m_DST_PORTf_SET BCM56504_A0_MMU_CBPPKTHEADER1m_DST_PORTf_SET
#define MMU_CBPPKTHEADER1m_DST_MODIDf_GET BCM56504_A0_MMU_CBPPKTHEADER1m_DST_MODIDf_GET
#define MMU_CBPPKTHEADER1m_DST_MODIDf_SET BCM56504_A0_MMU_CBPPKTHEADER1m_DST_MODIDf_SET
#define MMU_CBPPKTHEADER1m_DECAP_IPTUNNELf_GET BCM56504_A0_MMU_CBPPKTHEADER1m_DECAP_IPTUNNELf_GET
#define MMU_CBPPKTHEADER1m_DECAP_IPTUNNELf_SET BCM56504_A0_MMU_CBPPKTHEADER1m_DECAP_IPTUNNELf_SET
#define MMU_CBPPKTHEADER1m_BPDUf_GET BCM56504_A0_MMU_CBPPKTHEADER1m_BPDUf_GET
#define MMU_CBPPKTHEADER1m_BPDUf_SET BCM56504_A0_MMU_CBPPKTHEADER1m_BPDUf_SET
#define MMU_CBPPKTHEADER1m_L3UCf_GET BCM56504_A0_MMU_CBPPKTHEADER1m_L3UCf_GET
#define MMU_CBPPKTHEADER1m_L3UCf_SET BCM56504_A0_MMU_CBPPKTHEADER1m_L3UCf_SET
#define MMU_CBPPKTHEADER1m_COPY_COUNTf_GET BCM56504_A0_MMU_CBPPKTHEADER1m_COPY_COUNTf_GET
#define MMU_CBPPKTHEADER1m_COPY_COUNTf_SET BCM56504_A0_MMU_CBPPKTHEADER1m_COPY_COUNTf_SET
#define MMU_CBPPKTHEADER1m_USE_OUTER_HDR_TTLf_GET BCM56504_A0_MMU_CBPPKTHEADER1m_USE_OUTER_HDR_TTLf_GET
#define MMU_CBPPKTHEADER1m_USE_OUTER_HDR_TTLf_SET BCM56504_A0_MMU_CBPPKTHEADER1m_USE_OUTER_HDR_TTLf_SET
#define MMU_CBPPKTHEADER1m_PARITY_1f_GET BCM56504_A0_MMU_CBPPKTHEADER1m_PARITY_1f_GET
#define MMU_CBPPKTHEADER1m_PARITY_1f_SET BCM56504_A0_MMU_CBPPKTHEADER1m_PARITY_1f_SET
#define READ_MMU_CBPPKTHEADER1m BCM56504_A0_READ_MMU_CBPPKTHEADER1m
#define WRITE_MMU_CBPPKTHEADER1m BCM56504_A0_WRITE_MMU_CBPPKTHEADER1m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MMU_CBPPKTHEADER1m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  MMU_CCP
 * BLOCKS:   MMU
 * DESC:     Copy Count Pool RAM
 * SIZE:     6
 * FIELDS:
 *     CCP              Packet's copy count
 *     PARITY           Packet's copy count parity
 *
 ******************************************************************************/
#define BCM56504_A0_MMU_CCPm 0x0a654000

#define BCM56504_A0_MMU_CCPm_MIN 0
#define BCM56504_A0_MMU_CCPm_MAX 16383
#define BCM56504_A0_MMU_CCPm_CMAX(u) 16383
#define BCM56504_A0_MMU_CCPm_SIZE 1

/*
 * This structure should be used to declare and program MMU_CCP.
 *
 */
typedef union BCM56504_A0_MMU_CCPm_s {
	uint32_t v[1];
	uint32_t mmu_ccp[1];
	uint32_t _mmu_ccp;
} BCM56504_A0_MMU_CCPm_t;

#define BCM56504_A0_MMU_CCPm_CLR(r) (r).mmu_ccp[0] = 0
#define BCM56504_A0_MMU_CCPm_SET(r,d) (r).mmu_ccp[0] = d
#define BCM56504_A0_MMU_CCPm_GET(r) (r).mmu_ccp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MMU_CCPm_CCPf_GET(r) (((r).mmu_ccp[0]) & 0x1f)
#define BCM56504_A0_MMU_CCPm_CCPf_SET(r,f) (r).mmu_ccp[0]=(((r).mmu_ccp[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56504_A0_MMU_CCPm_PARITYf_GET(r) ((((r).mmu_ccp[0]) >> 5) & 0x1)
#define BCM56504_A0_MMU_CCPm_PARITYf_SET(r,f) (r).mmu_ccp[0]=(((r).mmu_ccp[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))

/*
 * These macros can be used to access MMU_CCP.
 *
 */
#define BCM56504_A0_READ_MMU_CCPm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_MMU_CCPm,i,(m._mmu_ccp),1)
#define BCM56504_A0_WRITE_MMU_CCPm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_MMU_CCPm,i,&(m._mmu_ccp),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CCPm BCM56504_A0_MMU_CCPm
#define MMU_CCPm_MIN BCM56504_A0_MMU_CCPm_MIN
#define MMU_CCPm_MAX BCM56504_A0_MMU_CCPm_MAX
#define MMU_CCPm_CMAX(u) BCM56504_A0_MMU_CCPm_CMAX(u)
#define MMU_CCPm_SIZE BCM56504_A0_MMU_CCPm_SIZE
typedef BCM56504_A0_MMU_CCPm_t MMU_CCPm_t;
#define MMU_CCPm_CLR BCM56504_A0_MMU_CCPm_CLR
#define MMU_CCPm_SET BCM56504_A0_MMU_CCPm_SET
#define MMU_CCPm_GET BCM56504_A0_MMU_CCPm_GET
#define MMU_CCPm_CCPf_GET BCM56504_A0_MMU_CCPm_CCPf_GET
#define MMU_CCPm_CCPf_SET BCM56504_A0_MMU_CCPm_CCPf_SET
#define MMU_CCPm_PARITYf_GET BCM56504_A0_MMU_CCPm_PARITYf_GET
#define MMU_CCPm_PARITYf_SET BCM56504_A0_MMU_CCPm_PARITYf_SET
#define READ_MMU_CCPm BCM56504_A0_READ_MMU_CCPm
#define WRITE_MMU_CCPm BCM56504_A0_WRITE_MMU_CCPm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MMU_CCPm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  MMU_CFAP
 * BLOCKS:   MMU
 * DESC:     CBP Free Address Pool RAM
 * SIZE:     15
 * FIELDS:
 *     FREE_PTR         CBP Free Address
 *     PARITY           CBP Free Address Parity
 *
 ******************************************************************************/
#define BCM56504_A0_MMU_CFAPm 0x0a650000

#define BCM56504_A0_MMU_CFAPm_MIN 0
#define BCM56504_A0_MMU_CFAPm_MAX 16383
#define BCM56504_A0_MMU_CFAPm_CMAX(u) 16383
#define BCM56504_A0_MMU_CFAPm_SIZE 2

/*
 * This structure should be used to declare and program MMU_CFAP.
 *
 */
typedef union BCM56504_A0_MMU_CFAPm_s {
	uint32_t v[1];
	uint32_t mmu_cfap[1];
	uint32_t _mmu_cfap;
} BCM56504_A0_MMU_CFAPm_t;

#define BCM56504_A0_MMU_CFAPm_CLR(r) (r).mmu_cfap[0] = 0
#define BCM56504_A0_MMU_CFAPm_SET(r,d) (r).mmu_cfap[0] = d
#define BCM56504_A0_MMU_CFAPm_GET(r) (r).mmu_cfap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MMU_CFAPm_FREE_PTRf_GET(r) (((r).mmu_cfap[0]) & 0x3fff)
#define BCM56504_A0_MMU_CFAPm_FREE_PTRf_SET(r,f) (r).mmu_cfap[0]=(((r).mmu_cfap[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM56504_A0_MMU_CFAPm_PARITYf_GET(r) ((((r).mmu_cfap[0]) >> 14) & 0x1)
#define BCM56504_A0_MMU_CFAPm_PARITYf_SET(r,f) (r).mmu_cfap[0]=(((r).mmu_cfap[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))

/*
 * These macros can be used to access MMU_CFAP.
 *
 */
#define BCM56504_A0_READ_MMU_CFAPm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_MMU_CFAPm,i,(m._mmu_cfap),1)
#define BCM56504_A0_WRITE_MMU_CFAPm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_MMU_CFAPm,i,&(m._mmu_cfap),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CFAPm BCM56504_A0_MMU_CFAPm
#define MMU_CFAPm_MIN BCM56504_A0_MMU_CFAPm_MIN
#define MMU_CFAPm_MAX BCM56504_A0_MMU_CFAPm_MAX
#define MMU_CFAPm_CMAX(u) BCM56504_A0_MMU_CFAPm_CMAX(u)
#define MMU_CFAPm_SIZE BCM56504_A0_MMU_CFAPm_SIZE
typedef BCM56504_A0_MMU_CFAPm_t MMU_CFAPm_t;
#define MMU_CFAPm_CLR BCM56504_A0_MMU_CFAPm_CLR
#define MMU_CFAPm_SET BCM56504_A0_MMU_CFAPm_SET
#define MMU_CFAPm_GET BCM56504_A0_MMU_CFAPm_GET
#define MMU_CFAPm_FREE_PTRf_GET BCM56504_A0_MMU_CFAPm_FREE_PTRf_GET
#define MMU_CFAPm_FREE_PTRf_SET BCM56504_A0_MMU_CFAPm_FREE_PTRf_SET
#define MMU_CFAPm_PARITYf_GET BCM56504_A0_MMU_CFAPm_PARITYf_GET
#define MMU_CFAPm_PARITYf_SET BCM56504_A0_MMU_CFAPm_PARITYf_SET
#define READ_MMU_CFAPm BCM56504_A0_READ_MMU_CFAPm
#define WRITE_MMU_CFAPm BCM56504_A0_WRITE_MMU_CFAPm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MMU_CFAPm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  MMU_IPMC_GROUP_TBL0
 * BLOCKS:   MMU
 * DESC:     IPMC VLAN Group Table 0
 * SIZE:     66
 * FIELDS:
 *     PORT0_1STPTR     11 bit first pointer to LSB VLAN Bitmap for Port 0
 *     PORT1_1STPTR     11 bit first pointer to LSB VLAN Bitmap for Port 1
 *     PORT2_1STPTR     11 bit first pointer to LSB VLAN Bitmap for Port 2
 *     PORT3_1STPTR     11 bit first pointer to LSB VLAN Bitmap for Port 3
 *     PORT4_1STPTR     11 bit first pointer to LSB VLAN Bitmap for Port 4
 *     PORT5_1STPTR     11 bit first pointer to LSB VLAN Bitmap for Port 5
 *
 ******************************************************************************/
#define BCM56504_A0_MMU_IPMC_GROUP_TBL0m 0x0a660000

#define BCM56504_A0_MMU_IPMC_GROUP_TBL0m_MIN 0
#define BCM56504_A0_MMU_IPMC_GROUP_TBL0m_MAX 1023
#define BCM56504_A0_MMU_IPMC_GROUP_TBL0m_CMAX(u) 1023
#define BCM56504_A0_MMU_IPMC_GROUP_TBL0m_SIZE 9

/*
 * This structure should be used to declare and program MMU_IPMC_GROUP_TBL0.
 *
 */
typedef union BCM56504_A0_MMU_IPMC_GROUP_TBL0m_s {
	uint32_t v[3];
	uint32_t mmu_ipmc_group_tbl0[3];
	uint32_t _mmu_ipmc_group_tbl0;
} BCM56504_A0_MMU_IPMC_GROUP_TBL0m_t;

#define BCM56504_A0_MMU_IPMC_GROUP_TBL0m_CLR(r) CDK_MEMSET(&((r)._mmu_ipmc_group_tbl0), 0, sizeof(BCM56504_A0_MMU_IPMC_GROUP_TBL0m_t))
#define BCM56504_A0_MMU_IPMC_GROUP_TBL0m_SET(r,i,d) (r).mmu_ipmc_group_tbl0[i] = d
#define BCM56504_A0_MMU_IPMC_GROUP_TBL0m_GET(r,i) (r).mmu_ipmc_group_tbl0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MMU_IPMC_GROUP_TBL0m_PORT0_1STPTRf_GET(r) (((r).mmu_ipmc_group_tbl0[0]) & 0x7ff)
#define BCM56504_A0_MMU_IPMC_GROUP_TBL0m_PORT0_1STPTRf_SET(r,f) (r).mmu_ipmc_group_tbl0[0]=(((r).mmu_ipmc_group_tbl0[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM56504_A0_MMU_IPMC_GROUP_TBL0m_PORT1_1STPTRf_GET(r) ((((r).mmu_ipmc_group_tbl0[0]) >> 11) & 0x7ff)
#define BCM56504_A0_MMU_IPMC_GROUP_TBL0m_PORT1_1STPTRf_SET(r,f) (r).mmu_ipmc_group_tbl0[0]=(((r).mmu_ipmc_group_tbl0[0] & ~((uint32_t)0x7ff << 11)) | ((((uint32_t)f) & 0x7ff) << 11))
#define BCM56504_A0_MMU_IPMC_GROUP_TBL0m_PORT2_1STPTRf_GET(r) cdk_field32_get((r).mmu_ipmc_group_tbl0,22,32)
#define BCM56504_A0_MMU_IPMC_GROUP_TBL0m_PORT2_1STPTRf_SET(r,f) cdk_field32_set((r).mmu_ipmc_group_tbl0,22,32,f)
#define BCM56504_A0_MMU_IPMC_GROUP_TBL0m_PORT3_1STPTRf_GET(r) ((((r).mmu_ipmc_group_tbl0[1]) >> 1) & 0x7ff)
#define BCM56504_A0_MMU_IPMC_GROUP_TBL0m_PORT3_1STPTRf_SET(r,f) (r).mmu_ipmc_group_tbl0[1]=(((r).mmu_ipmc_group_tbl0[1] & ~((uint32_t)0x7ff << 1)) | ((((uint32_t)f) & 0x7ff) << 1))
#define BCM56504_A0_MMU_IPMC_GROUP_TBL0m_PORT4_1STPTRf_GET(r) ((((r).mmu_ipmc_group_tbl0[1]) >> 12) & 0x7ff)
#define BCM56504_A0_MMU_IPMC_GROUP_TBL0m_PORT4_1STPTRf_SET(r,f) (r).mmu_ipmc_group_tbl0[1]=(((r).mmu_ipmc_group_tbl0[1] & ~((uint32_t)0x7ff << 12)) | ((((uint32_t)f) & 0x7ff) << 12))
#define BCM56504_A0_MMU_IPMC_GROUP_TBL0m_PORT5_1STPTRf_GET(r) cdk_field32_get((r).mmu_ipmc_group_tbl0,55,65)
#define BCM56504_A0_MMU_IPMC_GROUP_TBL0m_PORT5_1STPTRf_SET(r,f) cdk_field32_set((r).mmu_ipmc_group_tbl0,55,65,f)

/*
 * These macros can be used to access MMU_IPMC_GROUP_TBL0.
 *
 */
#define BCM56504_A0_READ_MMU_IPMC_GROUP_TBL0m(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_MMU_IPMC_GROUP_TBL0m,i,(m._mmu_ipmc_group_tbl0),3)
#define BCM56504_A0_WRITE_MMU_IPMC_GROUP_TBL0m(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_MMU_IPMC_GROUP_TBL0m,i,&(m._mmu_ipmc_group_tbl0),3)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_IPMC_GROUP_TBL0m BCM56504_A0_MMU_IPMC_GROUP_TBL0m
#define MMU_IPMC_GROUP_TBL0m_MIN BCM56504_A0_MMU_IPMC_GROUP_TBL0m_MIN
#define MMU_IPMC_GROUP_TBL0m_MAX BCM56504_A0_MMU_IPMC_GROUP_TBL0m_MAX
#define MMU_IPMC_GROUP_TBL0m_CMAX(u) BCM56504_A0_MMU_IPMC_GROUP_TBL0m_CMAX(u)
#define MMU_IPMC_GROUP_TBL0m_SIZE BCM56504_A0_MMU_IPMC_GROUP_TBL0m_SIZE
typedef BCM56504_A0_MMU_IPMC_GROUP_TBL0m_t MMU_IPMC_GROUP_TBL0m_t;
#define MMU_IPMC_GROUP_TBL0m_CLR BCM56504_A0_MMU_IPMC_GROUP_TBL0m_CLR
#define MMU_IPMC_GROUP_TBL0m_SET BCM56504_A0_MMU_IPMC_GROUP_TBL0m_SET
#define MMU_IPMC_GROUP_TBL0m_GET BCM56504_A0_MMU_IPMC_GROUP_TBL0m_GET
#define MMU_IPMC_GROUP_TBL0m_PORT0_1STPTRf_GET BCM56504_A0_MMU_IPMC_GROUP_TBL0m_PORT0_1STPTRf_GET
#define MMU_IPMC_GROUP_TBL0m_PORT0_1STPTRf_SET BCM56504_A0_MMU_IPMC_GROUP_TBL0m_PORT0_1STPTRf_SET
#define MMU_IPMC_GROUP_TBL0m_PORT1_1STPTRf_GET BCM56504_A0_MMU_IPMC_GROUP_TBL0m_PORT1_1STPTRf_GET
#define MMU_IPMC_GROUP_TBL0m_PORT1_1STPTRf_SET BCM56504_A0_MMU_IPMC_GROUP_TBL0m_PORT1_1STPTRf_SET
#define MMU_IPMC_GROUP_TBL0m_PORT2_1STPTRf_GET BCM56504_A0_MMU_IPMC_GROUP_TBL0m_PORT2_1STPTRf_GET
#define MMU_IPMC_GROUP_TBL0m_PORT2_1STPTRf_SET BCM56504_A0_MMU_IPMC_GROUP_TBL0m_PORT2_1STPTRf_SET
#define MMU_IPMC_GROUP_TBL0m_PORT3_1STPTRf_GET BCM56504_A0_MMU_IPMC_GROUP_TBL0m_PORT3_1STPTRf_GET
#define MMU_IPMC_GROUP_TBL0m_PORT3_1STPTRf_SET BCM56504_A0_MMU_IPMC_GROUP_TBL0m_PORT3_1STPTRf_SET
#define MMU_IPMC_GROUP_TBL0m_PORT4_1STPTRf_GET BCM56504_A0_MMU_IPMC_GROUP_TBL0m_PORT4_1STPTRf_GET
#define MMU_IPMC_GROUP_TBL0m_PORT4_1STPTRf_SET BCM56504_A0_MMU_IPMC_GROUP_TBL0m_PORT4_1STPTRf_SET
#define MMU_IPMC_GROUP_TBL0m_PORT5_1STPTRf_GET BCM56504_A0_MMU_IPMC_GROUP_TBL0m_PORT5_1STPTRf_GET
#define MMU_IPMC_GROUP_TBL0m_PORT5_1STPTRf_SET BCM56504_A0_MMU_IPMC_GROUP_TBL0m_PORT5_1STPTRf_SET
#define READ_MMU_IPMC_GROUP_TBL0m BCM56504_A0_READ_MMU_IPMC_GROUP_TBL0m
#define WRITE_MMU_IPMC_GROUP_TBL0m BCM56504_A0_WRITE_MMU_IPMC_GROUP_TBL0m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MMU_IPMC_GROUP_TBL0m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  MMU_IPMC_GROUP_TBL1
 * BLOCKS:   MMU
 * DESC:     IPMC VLAN Group Table 1
 * SIZE:     66
 * FIELDS:
 *     PORT6_1STPTR     11 bit first pointer to LSB VLAN Bitmap for Port 6
 *     PORT7_1STPTR     11 bit first pointer to LSB VLAN Bitmap for Port 7
 *     PORT8_1STPTR     11 bit first pointer to LSB VLAN Bitmap for Port 8
 *     PORT9_1STPTR     11 bit first pointer to LSB VLAN Bitmap for Port 9
 *     PORT10_1STPTR    11 bit first pointer to LSB VLAN Bitmap for Port 10
 *     PORT11_1STPTR    11 bit first pointer to LSB VLAN Bitmap for Port 11
 *
 ******************************************************************************/
#define BCM56504_A0_MMU_IPMC_GROUP_TBL1m 0x0a664000

#define BCM56504_A0_MMU_IPMC_GROUP_TBL1m_MIN 0
#define BCM56504_A0_MMU_IPMC_GROUP_TBL1m_MAX 1023
#define BCM56504_A0_MMU_IPMC_GROUP_TBL1m_CMAX(u) 1023
#define BCM56504_A0_MMU_IPMC_GROUP_TBL1m_SIZE 9

/*
 * This structure should be used to declare and program MMU_IPMC_GROUP_TBL1.
 *
 */
typedef union BCM56504_A0_MMU_IPMC_GROUP_TBL1m_s {
	uint32_t v[3];
	uint32_t mmu_ipmc_group_tbl1[3];
	uint32_t _mmu_ipmc_group_tbl1;
} BCM56504_A0_MMU_IPMC_GROUP_TBL1m_t;

#define BCM56504_A0_MMU_IPMC_GROUP_TBL1m_CLR(r) CDK_MEMSET(&((r)._mmu_ipmc_group_tbl1), 0, sizeof(BCM56504_A0_MMU_IPMC_GROUP_TBL1m_t))
#define BCM56504_A0_MMU_IPMC_GROUP_TBL1m_SET(r,i,d) (r).mmu_ipmc_group_tbl1[i] = d
#define BCM56504_A0_MMU_IPMC_GROUP_TBL1m_GET(r,i) (r).mmu_ipmc_group_tbl1[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MMU_IPMC_GROUP_TBL1m_PORT6_1STPTRf_GET(r) (((r).mmu_ipmc_group_tbl1[0]) & 0x7ff)
#define BCM56504_A0_MMU_IPMC_GROUP_TBL1m_PORT6_1STPTRf_SET(r,f) (r).mmu_ipmc_group_tbl1[0]=(((r).mmu_ipmc_group_tbl1[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM56504_A0_MMU_IPMC_GROUP_TBL1m_PORT7_1STPTRf_GET(r) ((((r).mmu_ipmc_group_tbl1[0]) >> 11) & 0x7ff)
#define BCM56504_A0_MMU_IPMC_GROUP_TBL1m_PORT7_1STPTRf_SET(r,f) (r).mmu_ipmc_group_tbl1[0]=(((r).mmu_ipmc_group_tbl1[0] & ~((uint32_t)0x7ff << 11)) | ((((uint32_t)f) & 0x7ff) << 11))
#define BCM56504_A0_MMU_IPMC_GROUP_TBL1m_PORT8_1STPTRf_GET(r) cdk_field32_get((r).mmu_ipmc_group_tbl1,22,32)
#define BCM56504_A0_MMU_IPMC_GROUP_TBL1m_PORT8_1STPTRf_SET(r,f) cdk_field32_set((r).mmu_ipmc_group_tbl1,22,32,f)
#define BCM56504_A0_MMU_IPMC_GROUP_TBL1m_PORT9_1STPTRf_GET(r) ((((r).mmu_ipmc_group_tbl1[1]) >> 1) & 0x7ff)
#define BCM56504_A0_MMU_IPMC_GROUP_TBL1m_PORT9_1STPTRf_SET(r,f) (r).mmu_ipmc_group_tbl1[1]=(((r).mmu_ipmc_group_tbl1[1] & ~((uint32_t)0x7ff << 1)) | ((((uint32_t)f) & 0x7ff) << 1))
#define BCM56504_A0_MMU_IPMC_GROUP_TBL1m_PORT10_1STPTRf_GET(r) ((((r).mmu_ipmc_group_tbl1[1]) >> 12) & 0x7ff)
#define BCM56504_A0_MMU_IPMC_GROUP_TBL1m_PORT10_1STPTRf_SET(r,f) (r).mmu_ipmc_group_tbl1[1]=(((r).mmu_ipmc_group_tbl1[1] & ~((uint32_t)0x7ff << 12)) | ((((uint32_t)f) & 0x7ff) << 12))
#define BCM56504_A0_MMU_IPMC_GROUP_TBL1m_PORT11_1STPTRf_GET(r) cdk_field32_get((r).mmu_ipmc_group_tbl1,55,65)
#define BCM56504_A0_MMU_IPMC_GROUP_TBL1m_PORT11_1STPTRf_SET(r,f) cdk_field32_set((r).mmu_ipmc_group_tbl1,55,65,f)

/*
 * These macros can be used to access MMU_IPMC_GROUP_TBL1.
 *
 */
#define BCM56504_A0_READ_MMU_IPMC_GROUP_TBL1m(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_MMU_IPMC_GROUP_TBL1m,i,(m._mmu_ipmc_group_tbl1),3)
#define BCM56504_A0_WRITE_MMU_IPMC_GROUP_TBL1m(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_MMU_IPMC_GROUP_TBL1m,i,&(m._mmu_ipmc_group_tbl1),3)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_IPMC_GROUP_TBL1m BCM56504_A0_MMU_IPMC_GROUP_TBL1m
#define MMU_IPMC_GROUP_TBL1m_MIN BCM56504_A0_MMU_IPMC_GROUP_TBL1m_MIN
#define MMU_IPMC_GROUP_TBL1m_MAX BCM56504_A0_MMU_IPMC_GROUP_TBL1m_MAX
#define MMU_IPMC_GROUP_TBL1m_CMAX(u) BCM56504_A0_MMU_IPMC_GROUP_TBL1m_CMAX(u)
#define MMU_IPMC_GROUP_TBL1m_SIZE BCM56504_A0_MMU_IPMC_GROUP_TBL1m_SIZE
typedef BCM56504_A0_MMU_IPMC_GROUP_TBL1m_t MMU_IPMC_GROUP_TBL1m_t;
#define MMU_IPMC_GROUP_TBL1m_CLR BCM56504_A0_MMU_IPMC_GROUP_TBL1m_CLR
#define MMU_IPMC_GROUP_TBL1m_SET BCM56504_A0_MMU_IPMC_GROUP_TBL1m_SET
#define MMU_IPMC_GROUP_TBL1m_GET BCM56504_A0_MMU_IPMC_GROUP_TBL1m_GET
#define MMU_IPMC_GROUP_TBL1m_PORT6_1STPTRf_GET BCM56504_A0_MMU_IPMC_GROUP_TBL1m_PORT6_1STPTRf_GET
#define MMU_IPMC_GROUP_TBL1m_PORT6_1STPTRf_SET BCM56504_A0_MMU_IPMC_GROUP_TBL1m_PORT6_1STPTRf_SET
#define MMU_IPMC_GROUP_TBL1m_PORT7_1STPTRf_GET BCM56504_A0_MMU_IPMC_GROUP_TBL1m_PORT7_1STPTRf_GET
#define MMU_IPMC_GROUP_TBL1m_PORT7_1STPTRf_SET BCM56504_A0_MMU_IPMC_GROUP_TBL1m_PORT7_1STPTRf_SET
#define MMU_IPMC_GROUP_TBL1m_PORT8_1STPTRf_GET BCM56504_A0_MMU_IPMC_GROUP_TBL1m_PORT8_1STPTRf_GET
#define MMU_IPMC_GROUP_TBL1m_PORT8_1STPTRf_SET BCM56504_A0_MMU_IPMC_GROUP_TBL1m_PORT8_1STPTRf_SET
#define MMU_IPMC_GROUP_TBL1m_PORT9_1STPTRf_GET BCM56504_A0_MMU_IPMC_GROUP_TBL1m_PORT9_1STPTRf_GET
#define MMU_IPMC_GROUP_TBL1m_PORT9_1STPTRf_SET BCM56504_A0_MMU_IPMC_GROUP_TBL1m_PORT9_1STPTRf_SET
#define MMU_IPMC_GROUP_TBL1m_PORT10_1STPTRf_GET BCM56504_A0_MMU_IPMC_GROUP_TBL1m_PORT10_1STPTRf_GET
#define MMU_IPMC_GROUP_TBL1m_PORT10_1STPTRf_SET BCM56504_A0_MMU_IPMC_GROUP_TBL1m_PORT10_1STPTRf_SET
#define MMU_IPMC_GROUP_TBL1m_PORT11_1STPTRf_GET BCM56504_A0_MMU_IPMC_GROUP_TBL1m_PORT11_1STPTRf_GET
#define MMU_IPMC_GROUP_TBL1m_PORT11_1STPTRf_SET BCM56504_A0_MMU_IPMC_GROUP_TBL1m_PORT11_1STPTRf_SET
#define READ_MMU_IPMC_GROUP_TBL1m BCM56504_A0_READ_MMU_IPMC_GROUP_TBL1m
#define WRITE_MMU_IPMC_GROUP_TBL1m BCM56504_A0_WRITE_MMU_IPMC_GROUP_TBL1m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MMU_IPMC_GROUP_TBL1m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  MMU_IPMC_GROUP_TBL2
 * BLOCKS:   MMU
 * DESC:     IPMC VLAN Group Table 2
 * SIZE:     66
 * FIELDS:
 *     PORT12_1STPTR    11 bit first pointer to LSB VLAN Bitmap for Port 12
 *     PORT13_1STPTR    11 bit first pointer to LSB VLAN Bitmap for Port 13
 *     PORT14_1STPTR    11 bit first pointer to LSB VLAN Bitmap for Port 14
 *     PORT15_1STPTR    11 bit first pointer to LSB VLAN Bitmap for Port 15
 *     PORT16_1STPTR    11 bit first pointer to LSB VLAN Bitmap for Port 16
 *     PORT17_1STPTR    11 bit first pointer to LSB VLAN Bitmap for Port 17
 *
 ******************************************************************************/
#define BCM56504_A0_MMU_IPMC_GROUP_TBL2m 0x0a668000

#define BCM56504_A0_MMU_IPMC_GROUP_TBL2m_MIN 0
#define BCM56504_A0_MMU_IPMC_GROUP_TBL2m_MAX 1023
#define BCM56504_A0_MMU_IPMC_GROUP_TBL2m_CMAX(u) 1023
#define BCM56504_A0_MMU_IPMC_GROUP_TBL2m_SIZE 9

/*
 * This structure should be used to declare and program MMU_IPMC_GROUP_TBL2.
 *
 */
typedef union BCM56504_A0_MMU_IPMC_GROUP_TBL2m_s {
	uint32_t v[3];
	uint32_t mmu_ipmc_group_tbl2[3];
	uint32_t _mmu_ipmc_group_tbl2;
} BCM56504_A0_MMU_IPMC_GROUP_TBL2m_t;

#define BCM56504_A0_MMU_IPMC_GROUP_TBL2m_CLR(r) CDK_MEMSET(&((r)._mmu_ipmc_group_tbl2), 0, sizeof(BCM56504_A0_MMU_IPMC_GROUP_TBL2m_t))
#define BCM56504_A0_MMU_IPMC_GROUP_TBL2m_SET(r,i,d) (r).mmu_ipmc_group_tbl2[i] = d
#define BCM56504_A0_MMU_IPMC_GROUP_TBL2m_GET(r,i) (r).mmu_ipmc_group_tbl2[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MMU_IPMC_GROUP_TBL2m_PORT12_1STPTRf_GET(r) (((r).mmu_ipmc_group_tbl2[0]) & 0x7ff)
#define BCM56504_A0_MMU_IPMC_GROUP_TBL2m_PORT12_1STPTRf_SET(r,f) (r).mmu_ipmc_group_tbl2[0]=(((r).mmu_ipmc_group_tbl2[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM56504_A0_MMU_IPMC_GROUP_TBL2m_PORT13_1STPTRf_GET(r) ((((r).mmu_ipmc_group_tbl2[0]) >> 11) & 0x7ff)
#define BCM56504_A0_MMU_IPMC_GROUP_TBL2m_PORT13_1STPTRf_SET(r,f) (r).mmu_ipmc_group_tbl2[0]=(((r).mmu_ipmc_group_tbl2[0] & ~((uint32_t)0x7ff << 11)) | ((((uint32_t)f) & 0x7ff) << 11))
#define BCM56504_A0_MMU_IPMC_GROUP_TBL2m_PORT14_1STPTRf_GET(r) cdk_field32_get((r).mmu_ipmc_group_tbl2,22,32)
#define BCM56504_A0_MMU_IPMC_GROUP_TBL2m_PORT14_1STPTRf_SET(r,f) cdk_field32_set((r).mmu_ipmc_group_tbl2,22,32,f)
#define BCM56504_A0_MMU_IPMC_GROUP_TBL2m_PORT15_1STPTRf_GET(r) ((((r).mmu_ipmc_group_tbl2[1]) >> 1) & 0x7ff)
#define BCM56504_A0_MMU_IPMC_GROUP_TBL2m_PORT15_1STPTRf_SET(r,f) (r).mmu_ipmc_group_tbl2[1]=(((r).mmu_ipmc_group_tbl2[1] & ~((uint32_t)0x7ff << 1)) | ((((uint32_t)f) & 0x7ff) << 1))
#define BCM56504_A0_MMU_IPMC_GROUP_TBL2m_PORT16_1STPTRf_GET(r) ((((r).mmu_ipmc_group_tbl2[1]) >> 12) & 0x7ff)
#define BCM56504_A0_MMU_IPMC_GROUP_TBL2m_PORT16_1STPTRf_SET(r,f) (r).mmu_ipmc_group_tbl2[1]=(((r).mmu_ipmc_group_tbl2[1] & ~((uint32_t)0x7ff << 12)) | ((((uint32_t)f) & 0x7ff) << 12))
#define BCM56504_A0_MMU_IPMC_GROUP_TBL2m_PORT17_1STPTRf_GET(r) cdk_field32_get((r).mmu_ipmc_group_tbl2,55,65)
#define BCM56504_A0_MMU_IPMC_GROUP_TBL2m_PORT17_1STPTRf_SET(r,f) cdk_field32_set((r).mmu_ipmc_group_tbl2,55,65,f)

/*
 * These macros can be used to access MMU_IPMC_GROUP_TBL2.
 *
 */
#define BCM56504_A0_READ_MMU_IPMC_GROUP_TBL2m(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_MMU_IPMC_GROUP_TBL2m,i,(m._mmu_ipmc_group_tbl2),3)
#define BCM56504_A0_WRITE_MMU_IPMC_GROUP_TBL2m(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_MMU_IPMC_GROUP_TBL2m,i,&(m._mmu_ipmc_group_tbl2),3)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_IPMC_GROUP_TBL2m BCM56504_A0_MMU_IPMC_GROUP_TBL2m
#define MMU_IPMC_GROUP_TBL2m_MIN BCM56504_A0_MMU_IPMC_GROUP_TBL2m_MIN
#define MMU_IPMC_GROUP_TBL2m_MAX BCM56504_A0_MMU_IPMC_GROUP_TBL2m_MAX
#define MMU_IPMC_GROUP_TBL2m_CMAX(u) BCM56504_A0_MMU_IPMC_GROUP_TBL2m_CMAX(u)
#define MMU_IPMC_GROUP_TBL2m_SIZE BCM56504_A0_MMU_IPMC_GROUP_TBL2m_SIZE
typedef BCM56504_A0_MMU_IPMC_GROUP_TBL2m_t MMU_IPMC_GROUP_TBL2m_t;
#define MMU_IPMC_GROUP_TBL2m_CLR BCM56504_A0_MMU_IPMC_GROUP_TBL2m_CLR
#define MMU_IPMC_GROUP_TBL2m_SET BCM56504_A0_MMU_IPMC_GROUP_TBL2m_SET
#define MMU_IPMC_GROUP_TBL2m_GET BCM56504_A0_MMU_IPMC_GROUP_TBL2m_GET
#define MMU_IPMC_GROUP_TBL2m_PORT12_1STPTRf_GET BCM56504_A0_MMU_IPMC_GROUP_TBL2m_PORT12_1STPTRf_GET
#define MMU_IPMC_GROUP_TBL2m_PORT12_1STPTRf_SET BCM56504_A0_MMU_IPMC_GROUP_TBL2m_PORT12_1STPTRf_SET
#define MMU_IPMC_GROUP_TBL2m_PORT13_1STPTRf_GET BCM56504_A0_MMU_IPMC_GROUP_TBL2m_PORT13_1STPTRf_GET
#define MMU_IPMC_GROUP_TBL2m_PORT13_1STPTRf_SET BCM56504_A0_MMU_IPMC_GROUP_TBL2m_PORT13_1STPTRf_SET
#define MMU_IPMC_GROUP_TBL2m_PORT14_1STPTRf_GET BCM56504_A0_MMU_IPMC_GROUP_TBL2m_PORT14_1STPTRf_GET
#define MMU_IPMC_GROUP_TBL2m_PORT14_1STPTRf_SET BCM56504_A0_MMU_IPMC_GROUP_TBL2m_PORT14_1STPTRf_SET
#define MMU_IPMC_GROUP_TBL2m_PORT15_1STPTRf_GET BCM56504_A0_MMU_IPMC_GROUP_TBL2m_PORT15_1STPTRf_GET
#define MMU_IPMC_GROUP_TBL2m_PORT15_1STPTRf_SET BCM56504_A0_MMU_IPMC_GROUP_TBL2m_PORT15_1STPTRf_SET
#define MMU_IPMC_GROUP_TBL2m_PORT16_1STPTRf_GET BCM56504_A0_MMU_IPMC_GROUP_TBL2m_PORT16_1STPTRf_GET
#define MMU_IPMC_GROUP_TBL2m_PORT16_1STPTRf_SET BCM56504_A0_MMU_IPMC_GROUP_TBL2m_PORT16_1STPTRf_SET
#define MMU_IPMC_GROUP_TBL2m_PORT17_1STPTRf_GET BCM56504_A0_MMU_IPMC_GROUP_TBL2m_PORT17_1STPTRf_GET
#define MMU_IPMC_GROUP_TBL2m_PORT17_1STPTRf_SET BCM56504_A0_MMU_IPMC_GROUP_TBL2m_PORT17_1STPTRf_SET
#define READ_MMU_IPMC_GROUP_TBL2m BCM56504_A0_READ_MMU_IPMC_GROUP_TBL2m
#define WRITE_MMU_IPMC_GROUP_TBL2m BCM56504_A0_WRITE_MMU_IPMC_GROUP_TBL2m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MMU_IPMC_GROUP_TBL2m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  MMU_IPMC_GROUP_TBL3
 * BLOCKS:   MMU
 * DESC:     IPMC VLAN Group Table 3
 * SIZE:     66
 * FIELDS:
 *     PORT18_1STPTR    11 bit first pointer to LSB VLAN Bitmap for Port 18
 *     PORT19_1STPTR    11 bit first pointer to LSB VLAN Bitmap for Port 19
 *     PORT20_1STPTR    11 bit first pointer to LSB VLAN Bitmap for Port 20
 *     PORT21_1STPTR    11 bit first pointer to LSB VLAN Bitmap for Port 21
 *     PORT22_1STPTR    11 bit first pointer to LSB VLAN Bitmap for Port 22
 *     PORT23_1STPTR    11 bit first pointer to LSB VLAN Bitmap for Port 23
 *
 ******************************************************************************/
#define BCM56504_A0_MMU_IPMC_GROUP_TBL3m 0x0a66c000

#define BCM56504_A0_MMU_IPMC_GROUP_TBL3m_MIN 0
#define BCM56504_A0_MMU_IPMC_GROUP_TBL3m_MAX 1023
#define BCM56504_A0_MMU_IPMC_GROUP_TBL3m_CMAX(u) 1023
#define BCM56504_A0_MMU_IPMC_GROUP_TBL3m_SIZE 9

/*
 * This structure should be used to declare and program MMU_IPMC_GROUP_TBL3.
 *
 */
typedef union BCM56504_A0_MMU_IPMC_GROUP_TBL3m_s {
	uint32_t v[3];
	uint32_t mmu_ipmc_group_tbl3[3];
	uint32_t _mmu_ipmc_group_tbl3;
} BCM56504_A0_MMU_IPMC_GROUP_TBL3m_t;

#define BCM56504_A0_MMU_IPMC_GROUP_TBL3m_CLR(r) CDK_MEMSET(&((r)._mmu_ipmc_group_tbl3), 0, sizeof(BCM56504_A0_MMU_IPMC_GROUP_TBL3m_t))
#define BCM56504_A0_MMU_IPMC_GROUP_TBL3m_SET(r,i,d) (r).mmu_ipmc_group_tbl3[i] = d
#define BCM56504_A0_MMU_IPMC_GROUP_TBL3m_GET(r,i) (r).mmu_ipmc_group_tbl3[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MMU_IPMC_GROUP_TBL3m_PORT18_1STPTRf_GET(r) (((r).mmu_ipmc_group_tbl3[0]) & 0x7ff)
#define BCM56504_A0_MMU_IPMC_GROUP_TBL3m_PORT18_1STPTRf_SET(r,f) (r).mmu_ipmc_group_tbl3[0]=(((r).mmu_ipmc_group_tbl3[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM56504_A0_MMU_IPMC_GROUP_TBL3m_PORT19_1STPTRf_GET(r) ((((r).mmu_ipmc_group_tbl3[0]) >> 11) & 0x7ff)
#define BCM56504_A0_MMU_IPMC_GROUP_TBL3m_PORT19_1STPTRf_SET(r,f) (r).mmu_ipmc_group_tbl3[0]=(((r).mmu_ipmc_group_tbl3[0] & ~((uint32_t)0x7ff << 11)) | ((((uint32_t)f) & 0x7ff) << 11))
#define BCM56504_A0_MMU_IPMC_GROUP_TBL3m_PORT20_1STPTRf_GET(r) cdk_field32_get((r).mmu_ipmc_group_tbl3,22,32)
#define BCM56504_A0_MMU_IPMC_GROUP_TBL3m_PORT20_1STPTRf_SET(r,f) cdk_field32_set((r).mmu_ipmc_group_tbl3,22,32,f)
#define BCM56504_A0_MMU_IPMC_GROUP_TBL3m_PORT21_1STPTRf_GET(r) ((((r).mmu_ipmc_group_tbl3[1]) >> 1) & 0x7ff)
#define BCM56504_A0_MMU_IPMC_GROUP_TBL3m_PORT21_1STPTRf_SET(r,f) (r).mmu_ipmc_group_tbl3[1]=(((r).mmu_ipmc_group_tbl3[1] & ~((uint32_t)0x7ff << 1)) | ((((uint32_t)f) & 0x7ff) << 1))
#define BCM56504_A0_MMU_IPMC_GROUP_TBL3m_PORT22_1STPTRf_GET(r) ((((r).mmu_ipmc_group_tbl3[1]) >> 12) & 0x7ff)
#define BCM56504_A0_MMU_IPMC_GROUP_TBL3m_PORT22_1STPTRf_SET(r,f) (r).mmu_ipmc_group_tbl3[1]=(((r).mmu_ipmc_group_tbl3[1] & ~((uint32_t)0x7ff << 12)) | ((((uint32_t)f) & 0x7ff) << 12))
#define BCM56504_A0_MMU_IPMC_GROUP_TBL3m_PORT23_1STPTRf_GET(r) cdk_field32_get((r).mmu_ipmc_group_tbl3,55,65)
#define BCM56504_A0_MMU_IPMC_GROUP_TBL3m_PORT23_1STPTRf_SET(r,f) cdk_field32_set((r).mmu_ipmc_group_tbl3,55,65,f)

/*
 * These macros can be used to access MMU_IPMC_GROUP_TBL3.
 *
 */
#define BCM56504_A0_READ_MMU_IPMC_GROUP_TBL3m(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_MMU_IPMC_GROUP_TBL3m,i,(m._mmu_ipmc_group_tbl3),3)
#define BCM56504_A0_WRITE_MMU_IPMC_GROUP_TBL3m(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_MMU_IPMC_GROUP_TBL3m,i,&(m._mmu_ipmc_group_tbl3),3)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_IPMC_GROUP_TBL3m BCM56504_A0_MMU_IPMC_GROUP_TBL3m
#define MMU_IPMC_GROUP_TBL3m_MIN BCM56504_A0_MMU_IPMC_GROUP_TBL3m_MIN
#define MMU_IPMC_GROUP_TBL3m_MAX BCM56504_A0_MMU_IPMC_GROUP_TBL3m_MAX
#define MMU_IPMC_GROUP_TBL3m_CMAX(u) BCM56504_A0_MMU_IPMC_GROUP_TBL3m_CMAX(u)
#define MMU_IPMC_GROUP_TBL3m_SIZE BCM56504_A0_MMU_IPMC_GROUP_TBL3m_SIZE
typedef BCM56504_A0_MMU_IPMC_GROUP_TBL3m_t MMU_IPMC_GROUP_TBL3m_t;
#define MMU_IPMC_GROUP_TBL3m_CLR BCM56504_A0_MMU_IPMC_GROUP_TBL3m_CLR
#define MMU_IPMC_GROUP_TBL3m_SET BCM56504_A0_MMU_IPMC_GROUP_TBL3m_SET
#define MMU_IPMC_GROUP_TBL3m_GET BCM56504_A0_MMU_IPMC_GROUP_TBL3m_GET
#define MMU_IPMC_GROUP_TBL3m_PORT18_1STPTRf_GET BCM56504_A0_MMU_IPMC_GROUP_TBL3m_PORT18_1STPTRf_GET
#define MMU_IPMC_GROUP_TBL3m_PORT18_1STPTRf_SET BCM56504_A0_MMU_IPMC_GROUP_TBL3m_PORT18_1STPTRf_SET
#define MMU_IPMC_GROUP_TBL3m_PORT19_1STPTRf_GET BCM56504_A0_MMU_IPMC_GROUP_TBL3m_PORT19_1STPTRf_GET
#define MMU_IPMC_GROUP_TBL3m_PORT19_1STPTRf_SET BCM56504_A0_MMU_IPMC_GROUP_TBL3m_PORT19_1STPTRf_SET
#define MMU_IPMC_GROUP_TBL3m_PORT20_1STPTRf_GET BCM56504_A0_MMU_IPMC_GROUP_TBL3m_PORT20_1STPTRf_GET
#define MMU_IPMC_GROUP_TBL3m_PORT20_1STPTRf_SET BCM56504_A0_MMU_IPMC_GROUP_TBL3m_PORT20_1STPTRf_SET
#define MMU_IPMC_GROUP_TBL3m_PORT21_1STPTRf_GET BCM56504_A0_MMU_IPMC_GROUP_TBL3m_PORT21_1STPTRf_GET
#define MMU_IPMC_GROUP_TBL3m_PORT21_1STPTRf_SET BCM56504_A0_MMU_IPMC_GROUP_TBL3m_PORT21_1STPTRf_SET
#define MMU_IPMC_GROUP_TBL3m_PORT22_1STPTRf_GET BCM56504_A0_MMU_IPMC_GROUP_TBL3m_PORT22_1STPTRf_GET
#define MMU_IPMC_GROUP_TBL3m_PORT22_1STPTRf_SET BCM56504_A0_MMU_IPMC_GROUP_TBL3m_PORT22_1STPTRf_SET
#define MMU_IPMC_GROUP_TBL3m_PORT23_1STPTRf_GET BCM56504_A0_MMU_IPMC_GROUP_TBL3m_PORT23_1STPTRf_GET
#define MMU_IPMC_GROUP_TBL3m_PORT23_1STPTRf_SET BCM56504_A0_MMU_IPMC_GROUP_TBL3m_PORT23_1STPTRf_SET
#define READ_MMU_IPMC_GROUP_TBL3m BCM56504_A0_READ_MMU_IPMC_GROUP_TBL3m
#define WRITE_MMU_IPMC_GROUP_TBL3m BCM56504_A0_WRITE_MMU_IPMC_GROUP_TBL3m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MMU_IPMC_GROUP_TBL3m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  MMU_IPMC_GROUP_TBL4
 * BLOCKS:   MMU
 * DESC:     IPMC VLAN Group Table 4
 * SIZE:     11
 * FIELDS:
 *     PORT24_1STPTR    11 bit first pointer to LSB VLAN Bitmap for Port 24
 *
 ******************************************************************************/
#define BCM56504_A0_MMU_IPMC_GROUP_TBL4m 0x0a670000

#define BCM56504_A0_MMU_IPMC_GROUP_TBL4m_MIN 0
#define BCM56504_A0_MMU_IPMC_GROUP_TBL4m_MAX 1023
#define BCM56504_A0_MMU_IPMC_GROUP_TBL4m_CMAX(u) 1023
#define BCM56504_A0_MMU_IPMC_GROUP_TBL4m_SIZE 2

/*
 * This structure should be used to declare and program MMU_IPMC_GROUP_TBL4.
 *
 */
typedef union BCM56504_A0_MMU_IPMC_GROUP_TBL4m_s {
	uint32_t v[1];
	uint32_t mmu_ipmc_group_tbl4[1];
	uint32_t _mmu_ipmc_group_tbl4;
} BCM56504_A0_MMU_IPMC_GROUP_TBL4m_t;

#define BCM56504_A0_MMU_IPMC_GROUP_TBL4m_CLR(r) (r).mmu_ipmc_group_tbl4[0] = 0
#define BCM56504_A0_MMU_IPMC_GROUP_TBL4m_SET(r,d) (r).mmu_ipmc_group_tbl4[0] = d
#define BCM56504_A0_MMU_IPMC_GROUP_TBL4m_GET(r) (r).mmu_ipmc_group_tbl4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MMU_IPMC_GROUP_TBL4m_PORT24_1STPTRf_GET(r) (((r).mmu_ipmc_group_tbl4[0]) & 0x7ff)
#define BCM56504_A0_MMU_IPMC_GROUP_TBL4m_PORT24_1STPTRf_SET(r,f) (r).mmu_ipmc_group_tbl4[0]=(((r).mmu_ipmc_group_tbl4[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))

/*
 * These macros can be used to access MMU_IPMC_GROUP_TBL4.
 *
 */
#define BCM56504_A0_READ_MMU_IPMC_GROUP_TBL4m(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_MMU_IPMC_GROUP_TBL4m,i,(m._mmu_ipmc_group_tbl4),1)
#define BCM56504_A0_WRITE_MMU_IPMC_GROUP_TBL4m(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_MMU_IPMC_GROUP_TBL4m,i,&(m._mmu_ipmc_group_tbl4),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_IPMC_GROUP_TBL4m BCM56504_A0_MMU_IPMC_GROUP_TBL4m
#define MMU_IPMC_GROUP_TBL4m_MIN BCM56504_A0_MMU_IPMC_GROUP_TBL4m_MIN
#define MMU_IPMC_GROUP_TBL4m_MAX BCM56504_A0_MMU_IPMC_GROUP_TBL4m_MAX
#define MMU_IPMC_GROUP_TBL4m_CMAX(u) BCM56504_A0_MMU_IPMC_GROUP_TBL4m_CMAX(u)
#define MMU_IPMC_GROUP_TBL4m_SIZE BCM56504_A0_MMU_IPMC_GROUP_TBL4m_SIZE
typedef BCM56504_A0_MMU_IPMC_GROUP_TBL4m_t MMU_IPMC_GROUP_TBL4m_t;
#define MMU_IPMC_GROUP_TBL4m_CLR BCM56504_A0_MMU_IPMC_GROUP_TBL4m_CLR
#define MMU_IPMC_GROUP_TBL4m_SET BCM56504_A0_MMU_IPMC_GROUP_TBL4m_SET
#define MMU_IPMC_GROUP_TBL4m_GET BCM56504_A0_MMU_IPMC_GROUP_TBL4m_GET
#define MMU_IPMC_GROUP_TBL4m_PORT24_1STPTRf_GET BCM56504_A0_MMU_IPMC_GROUP_TBL4m_PORT24_1STPTRf_GET
#define MMU_IPMC_GROUP_TBL4m_PORT24_1STPTRf_SET BCM56504_A0_MMU_IPMC_GROUP_TBL4m_PORT24_1STPTRf_SET
#define READ_MMU_IPMC_GROUP_TBL4m BCM56504_A0_READ_MMU_IPMC_GROUP_TBL4m
#define WRITE_MMU_IPMC_GROUP_TBL4m BCM56504_A0_WRITE_MMU_IPMC_GROUP_TBL4m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MMU_IPMC_GROUP_TBL4m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  MMU_IPMC_GROUP_TBL5
 * BLOCKS:   MMU
 * DESC:     IPMC VLAN Group Table 5
 * SIZE:     11
 * FIELDS:
 *     PORT25_1STPTR    11 bit first pointer to LSB VLAN Bitmap for Port 25
 *
 ******************************************************************************/
#define BCM56504_A0_MMU_IPMC_GROUP_TBL5m 0x0a674000

#define BCM56504_A0_MMU_IPMC_GROUP_TBL5m_MIN 0
#define BCM56504_A0_MMU_IPMC_GROUP_TBL5m_MAX 1023
#define BCM56504_A0_MMU_IPMC_GROUP_TBL5m_CMAX(u) 1023
#define BCM56504_A0_MMU_IPMC_GROUP_TBL5m_SIZE 2

/*
 * This structure should be used to declare and program MMU_IPMC_GROUP_TBL5.
 *
 */
typedef union BCM56504_A0_MMU_IPMC_GROUP_TBL5m_s {
	uint32_t v[1];
	uint32_t mmu_ipmc_group_tbl5[1];
	uint32_t _mmu_ipmc_group_tbl5;
} BCM56504_A0_MMU_IPMC_GROUP_TBL5m_t;

#define BCM56504_A0_MMU_IPMC_GROUP_TBL5m_CLR(r) (r).mmu_ipmc_group_tbl5[0] = 0
#define BCM56504_A0_MMU_IPMC_GROUP_TBL5m_SET(r,d) (r).mmu_ipmc_group_tbl5[0] = d
#define BCM56504_A0_MMU_IPMC_GROUP_TBL5m_GET(r) (r).mmu_ipmc_group_tbl5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MMU_IPMC_GROUP_TBL5m_PORT25_1STPTRf_GET(r) (((r).mmu_ipmc_group_tbl5[0]) & 0x7ff)
#define BCM56504_A0_MMU_IPMC_GROUP_TBL5m_PORT25_1STPTRf_SET(r,f) (r).mmu_ipmc_group_tbl5[0]=(((r).mmu_ipmc_group_tbl5[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))

/*
 * These macros can be used to access MMU_IPMC_GROUP_TBL5.
 *
 */
#define BCM56504_A0_READ_MMU_IPMC_GROUP_TBL5m(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_MMU_IPMC_GROUP_TBL5m,i,(m._mmu_ipmc_group_tbl5),1)
#define BCM56504_A0_WRITE_MMU_IPMC_GROUP_TBL5m(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_MMU_IPMC_GROUP_TBL5m,i,&(m._mmu_ipmc_group_tbl5),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_IPMC_GROUP_TBL5m BCM56504_A0_MMU_IPMC_GROUP_TBL5m
#define MMU_IPMC_GROUP_TBL5m_MIN BCM56504_A0_MMU_IPMC_GROUP_TBL5m_MIN
#define MMU_IPMC_GROUP_TBL5m_MAX BCM56504_A0_MMU_IPMC_GROUP_TBL5m_MAX
#define MMU_IPMC_GROUP_TBL5m_CMAX(u) BCM56504_A0_MMU_IPMC_GROUP_TBL5m_CMAX(u)
#define MMU_IPMC_GROUP_TBL5m_SIZE BCM56504_A0_MMU_IPMC_GROUP_TBL5m_SIZE
typedef BCM56504_A0_MMU_IPMC_GROUP_TBL5m_t MMU_IPMC_GROUP_TBL5m_t;
#define MMU_IPMC_GROUP_TBL5m_CLR BCM56504_A0_MMU_IPMC_GROUP_TBL5m_CLR
#define MMU_IPMC_GROUP_TBL5m_SET BCM56504_A0_MMU_IPMC_GROUP_TBL5m_SET
#define MMU_IPMC_GROUP_TBL5m_GET BCM56504_A0_MMU_IPMC_GROUP_TBL5m_GET
#define MMU_IPMC_GROUP_TBL5m_PORT25_1STPTRf_GET BCM56504_A0_MMU_IPMC_GROUP_TBL5m_PORT25_1STPTRf_GET
#define MMU_IPMC_GROUP_TBL5m_PORT25_1STPTRf_SET BCM56504_A0_MMU_IPMC_GROUP_TBL5m_PORT25_1STPTRf_SET
#define READ_MMU_IPMC_GROUP_TBL5m BCM56504_A0_READ_MMU_IPMC_GROUP_TBL5m
#define WRITE_MMU_IPMC_GROUP_TBL5m BCM56504_A0_WRITE_MMU_IPMC_GROUP_TBL5m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MMU_IPMC_GROUP_TBL5m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  MMU_IPMC_GROUP_TBL6
 * BLOCKS:   MMU
 * DESC:     IPMC VLAN Group Table 6
 * SIZE:     11
 * FIELDS:
 *     PORT26_1STPTR    11 bit first pointer to LSB VLAN Bitmap for Port 26
 *
 ******************************************************************************/
#define BCM56504_A0_MMU_IPMC_GROUP_TBL6m 0x0a678000

#define BCM56504_A0_MMU_IPMC_GROUP_TBL6m_MIN 0
#define BCM56504_A0_MMU_IPMC_GROUP_TBL6m_MAX 1023
#define BCM56504_A0_MMU_IPMC_GROUP_TBL6m_CMAX(u) 1023
#define BCM56504_A0_MMU_IPMC_GROUP_TBL6m_SIZE 2

/*
 * This structure should be used to declare and program MMU_IPMC_GROUP_TBL6.
 *
 */
typedef union BCM56504_A0_MMU_IPMC_GROUP_TBL6m_s {
	uint32_t v[1];
	uint32_t mmu_ipmc_group_tbl6[1];
	uint32_t _mmu_ipmc_group_tbl6;
} BCM56504_A0_MMU_IPMC_GROUP_TBL6m_t;

#define BCM56504_A0_MMU_IPMC_GROUP_TBL6m_CLR(r) (r).mmu_ipmc_group_tbl6[0] = 0
#define BCM56504_A0_MMU_IPMC_GROUP_TBL6m_SET(r,d) (r).mmu_ipmc_group_tbl6[0] = d
#define BCM56504_A0_MMU_IPMC_GROUP_TBL6m_GET(r) (r).mmu_ipmc_group_tbl6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MMU_IPMC_GROUP_TBL6m_PORT26_1STPTRf_GET(r) (((r).mmu_ipmc_group_tbl6[0]) & 0x7ff)
#define BCM56504_A0_MMU_IPMC_GROUP_TBL6m_PORT26_1STPTRf_SET(r,f) (r).mmu_ipmc_group_tbl6[0]=(((r).mmu_ipmc_group_tbl6[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))

/*
 * These macros can be used to access MMU_IPMC_GROUP_TBL6.
 *
 */
#define BCM56504_A0_READ_MMU_IPMC_GROUP_TBL6m(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_MMU_IPMC_GROUP_TBL6m,i,(m._mmu_ipmc_group_tbl6),1)
#define BCM56504_A0_WRITE_MMU_IPMC_GROUP_TBL6m(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_MMU_IPMC_GROUP_TBL6m,i,&(m._mmu_ipmc_group_tbl6),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_IPMC_GROUP_TBL6m BCM56504_A0_MMU_IPMC_GROUP_TBL6m
#define MMU_IPMC_GROUP_TBL6m_MIN BCM56504_A0_MMU_IPMC_GROUP_TBL6m_MIN
#define MMU_IPMC_GROUP_TBL6m_MAX BCM56504_A0_MMU_IPMC_GROUP_TBL6m_MAX
#define MMU_IPMC_GROUP_TBL6m_CMAX(u) BCM56504_A0_MMU_IPMC_GROUP_TBL6m_CMAX(u)
#define MMU_IPMC_GROUP_TBL6m_SIZE BCM56504_A0_MMU_IPMC_GROUP_TBL6m_SIZE
typedef BCM56504_A0_MMU_IPMC_GROUP_TBL6m_t MMU_IPMC_GROUP_TBL6m_t;
#define MMU_IPMC_GROUP_TBL6m_CLR BCM56504_A0_MMU_IPMC_GROUP_TBL6m_CLR
#define MMU_IPMC_GROUP_TBL6m_SET BCM56504_A0_MMU_IPMC_GROUP_TBL6m_SET
#define MMU_IPMC_GROUP_TBL6m_GET BCM56504_A0_MMU_IPMC_GROUP_TBL6m_GET
#define MMU_IPMC_GROUP_TBL6m_PORT26_1STPTRf_GET BCM56504_A0_MMU_IPMC_GROUP_TBL6m_PORT26_1STPTRf_GET
#define MMU_IPMC_GROUP_TBL6m_PORT26_1STPTRf_SET BCM56504_A0_MMU_IPMC_GROUP_TBL6m_PORT26_1STPTRf_SET
#define READ_MMU_IPMC_GROUP_TBL6m BCM56504_A0_READ_MMU_IPMC_GROUP_TBL6m
#define WRITE_MMU_IPMC_GROUP_TBL6m BCM56504_A0_WRITE_MMU_IPMC_GROUP_TBL6m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MMU_IPMC_GROUP_TBL6m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  MMU_IPMC_GROUP_TBL7
 * BLOCKS:   MMU
 * DESC:     IPMC VLAN Group Table 7
 * SIZE:     11
 * FIELDS:
 *     PORT27_1STPTR    11 bit first pointer to LSB VLAN Bitmap for Port 27
 *
 ******************************************************************************/
#define BCM56504_A0_MMU_IPMC_GROUP_TBL7m 0x0a67c000

#define BCM56504_A0_MMU_IPMC_GROUP_TBL7m_MIN 0
#define BCM56504_A0_MMU_IPMC_GROUP_TBL7m_MAX 1023
#define BCM56504_A0_MMU_IPMC_GROUP_TBL7m_CMAX(u) 1023
#define BCM56504_A0_MMU_IPMC_GROUP_TBL7m_SIZE 2

/*
 * This structure should be used to declare and program MMU_IPMC_GROUP_TBL7.
 *
 */
typedef union BCM56504_A0_MMU_IPMC_GROUP_TBL7m_s {
	uint32_t v[1];
	uint32_t mmu_ipmc_group_tbl7[1];
	uint32_t _mmu_ipmc_group_tbl7;
} BCM56504_A0_MMU_IPMC_GROUP_TBL7m_t;

#define BCM56504_A0_MMU_IPMC_GROUP_TBL7m_CLR(r) (r).mmu_ipmc_group_tbl7[0] = 0
#define BCM56504_A0_MMU_IPMC_GROUP_TBL7m_SET(r,d) (r).mmu_ipmc_group_tbl7[0] = d
#define BCM56504_A0_MMU_IPMC_GROUP_TBL7m_GET(r) (r).mmu_ipmc_group_tbl7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MMU_IPMC_GROUP_TBL7m_PORT27_1STPTRf_GET(r) (((r).mmu_ipmc_group_tbl7[0]) & 0x7ff)
#define BCM56504_A0_MMU_IPMC_GROUP_TBL7m_PORT27_1STPTRf_SET(r,f) (r).mmu_ipmc_group_tbl7[0]=(((r).mmu_ipmc_group_tbl7[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))

/*
 * These macros can be used to access MMU_IPMC_GROUP_TBL7.
 *
 */
#define BCM56504_A0_READ_MMU_IPMC_GROUP_TBL7m(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_MMU_IPMC_GROUP_TBL7m,i,(m._mmu_ipmc_group_tbl7),1)
#define BCM56504_A0_WRITE_MMU_IPMC_GROUP_TBL7m(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_MMU_IPMC_GROUP_TBL7m,i,&(m._mmu_ipmc_group_tbl7),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_IPMC_GROUP_TBL7m BCM56504_A0_MMU_IPMC_GROUP_TBL7m
#define MMU_IPMC_GROUP_TBL7m_MIN BCM56504_A0_MMU_IPMC_GROUP_TBL7m_MIN
#define MMU_IPMC_GROUP_TBL7m_MAX BCM56504_A0_MMU_IPMC_GROUP_TBL7m_MAX
#define MMU_IPMC_GROUP_TBL7m_CMAX(u) BCM56504_A0_MMU_IPMC_GROUP_TBL7m_CMAX(u)
#define MMU_IPMC_GROUP_TBL7m_SIZE BCM56504_A0_MMU_IPMC_GROUP_TBL7m_SIZE
typedef BCM56504_A0_MMU_IPMC_GROUP_TBL7m_t MMU_IPMC_GROUP_TBL7m_t;
#define MMU_IPMC_GROUP_TBL7m_CLR BCM56504_A0_MMU_IPMC_GROUP_TBL7m_CLR
#define MMU_IPMC_GROUP_TBL7m_SET BCM56504_A0_MMU_IPMC_GROUP_TBL7m_SET
#define MMU_IPMC_GROUP_TBL7m_GET BCM56504_A0_MMU_IPMC_GROUP_TBL7m_GET
#define MMU_IPMC_GROUP_TBL7m_PORT27_1STPTRf_GET BCM56504_A0_MMU_IPMC_GROUP_TBL7m_PORT27_1STPTRf_GET
#define MMU_IPMC_GROUP_TBL7m_PORT27_1STPTRf_SET BCM56504_A0_MMU_IPMC_GROUP_TBL7m_PORT27_1STPTRf_SET
#define READ_MMU_IPMC_GROUP_TBL7m BCM56504_A0_READ_MMU_IPMC_GROUP_TBL7m
#define WRITE_MMU_IPMC_GROUP_TBL7m BCM56504_A0_WRITE_MMU_IPMC_GROUP_TBL7m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MMU_IPMC_GROUP_TBL7m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  MMU_IPMC_VLAN_TBL
 * BLOCKS:   MMU
 * DESC:     IPMC VLAN LSB Bitmap Table RAM
 * SIZE:     81
 * FIELDS:
 *     NEXTPTR          11 bits Next VLAN Bitmap Pointer
 *     LSB_VLAN_BM      64 bit LSB VLAN Bitmap
 *     MSB_VLAN         6 bits MSB for VLAN [11:6]
 *
 ******************************************************************************/
#define BCM56504_A0_MMU_IPMC_VLAN_TBLm 0x0a680000

#define BCM56504_A0_MMU_IPMC_VLAN_TBLm_MIN 0
#define BCM56504_A0_MMU_IPMC_VLAN_TBLm_MAX 2047
#define BCM56504_A0_MMU_IPMC_VLAN_TBLm_CMAX(u) 2047
#define BCM56504_A0_MMU_IPMC_VLAN_TBLm_SIZE 11

/*
 * This structure should be used to declare and program MMU_IPMC_VLAN_TBL.
 *
 */
typedef union BCM56504_A0_MMU_IPMC_VLAN_TBLm_s {
	uint32_t v[3];
	uint32_t mmu_ipmc_vlan_tbl[3];
	uint32_t _mmu_ipmc_vlan_tbl;
} BCM56504_A0_MMU_IPMC_VLAN_TBLm_t;

#define BCM56504_A0_MMU_IPMC_VLAN_TBLm_CLR(r) CDK_MEMSET(&((r)._mmu_ipmc_vlan_tbl), 0, sizeof(BCM56504_A0_MMU_IPMC_VLAN_TBLm_t))
#define BCM56504_A0_MMU_IPMC_VLAN_TBLm_SET(r,i,d) (r).mmu_ipmc_vlan_tbl[i] = d
#define BCM56504_A0_MMU_IPMC_VLAN_TBLm_GET(r,i) (r).mmu_ipmc_vlan_tbl[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MMU_IPMC_VLAN_TBLm_NEXTPTRf_GET(r) (((r).mmu_ipmc_vlan_tbl[0]) & 0x7ff)
#define BCM56504_A0_MMU_IPMC_VLAN_TBLm_NEXTPTRf_SET(r,f) (r).mmu_ipmc_vlan_tbl[0]=(((r).mmu_ipmc_vlan_tbl[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM56504_A0_MMU_IPMC_VLAN_TBLm_LSB_VLAN_BMf_GET(r,a) cdk_field_get((r).mmu_ipmc_vlan_tbl,11,74,a)
#define BCM56504_A0_MMU_IPMC_VLAN_TBLm_LSB_VLAN_BMf_SET(r,a) cdk_field_set((r).mmu_ipmc_vlan_tbl,11,74,a)
#define BCM56504_A0_MMU_IPMC_VLAN_TBLm_MSB_VLANf_GET(r) ((((r).mmu_ipmc_vlan_tbl[2]) >> 11) & 0x3f)
#define BCM56504_A0_MMU_IPMC_VLAN_TBLm_MSB_VLANf_SET(r,f) (r).mmu_ipmc_vlan_tbl[2]=(((r).mmu_ipmc_vlan_tbl[2] & ~((uint32_t)0x3f << 11)) | ((((uint32_t)f) & 0x3f) << 11))

/*
 * These macros can be used to access MMU_IPMC_VLAN_TBL.
 *
 */
#define BCM56504_A0_READ_MMU_IPMC_VLAN_TBLm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_MMU_IPMC_VLAN_TBLm,i,(m._mmu_ipmc_vlan_tbl),3)
#define BCM56504_A0_WRITE_MMU_IPMC_VLAN_TBLm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_MMU_IPMC_VLAN_TBLm,i,&(m._mmu_ipmc_vlan_tbl),3)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_IPMC_VLAN_TBLm BCM56504_A0_MMU_IPMC_VLAN_TBLm
#define MMU_IPMC_VLAN_TBLm_MIN BCM56504_A0_MMU_IPMC_VLAN_TBLm_MIN
#define MMU_IPMC_VLAN_TBLm_MAX BCM56504_A0_MMU_IPMC_VLAN_TBLm_MAX
#define MMU_IPMC_VLAN_TBLm_CMAX(u) BCM56504_A0_MMU_IPMC_VLAN_TBLm_CMAX(u)
#define MMU_IPMC_VLAN_TBLm_SIZE BCM56504_A0_MMU_IPMC_VLAN_TBLm_SIZE
typedef BCM56504_A0_MMU_IPMC_VLAN_TBLm_t MMU_IPMC_VLAN_TBLm_t;
#define MMU_IPMC_VLAN_TBLm_CLR BCM56504_A0_MMU_IPMC_VLAN_TBLm_CLR
#define MMU_IPMC_VLAN_TBLm_SET BCM56504_A0_MMU_IPMC_VLAN_TBLm_SET
#define MMU_IPMC_VLAN_TBLm_GET BCM56504_A0_MMU_IPMC_VLAN_TBLm_GET
#define MMU_IPMC_VLAN_TBLm_NEXTPTRf_GET BCM56504_A0_MMU_IPMC_VLAN_TBLm_NEXTPTRf_GET
#define MMU_IPMC_VLAN_TBLm_NEXTPTRf_SET BCM56504_A0_MMU_IPMC_VLAN_TBLm_NEXTPTRf_SET
#define MMU_IPMC_VLAN_TBLm_LSB_VLAN_BMf_GET BCM56504_A0_MMU_IPMC_VLAN_TBLm_LSB_VLAN_BMf_GET
#define MMU_IPMC_VLAN_TBLm_LSB_VLAN_BMf_SET BCM56504_A0_MMU_IPMC_VLAN_TBLm_LSB_VLAN_BMf_SET
#define MMU_IPMC_VLAN_TBLm_MSB_VLANf_GET BCM56504_A0_MMU_IPMC_VLAN_TBLm_MSB_VLANf_GET
#define MMU_IPMC_VLAN_TBLm_MSB_VLANf_SET BCM56504_A0_MMU_IPMC_VLAN_TBLm_MSB_VLANf_SET
#define READ_MMU_IPMC_VLAN_TBLm BCM56504_A0_READ_MMU_IPMC_VLAN_TBLm
#define WRITE_MMU_IPMC_VLAN_TBLm BCM56504_A0_WRITE_MMU_IPMC_VLAN_TBLm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MMU_IPMC_VLAN_TBLm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  MMU_XQ0
 * BLOCKS:   MMU
 * DESC:     XQ0
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     L3IPMC           L3 IP multicast Flag
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56504_A0_MMU_XQ0m 0x0b600000

#define BCM56504_A0_MMU_XQ0m_MIN 0
#define BCM56504_A0_MMU_XQ0m_MAX 2047
#define BCM56504_A0_MMU_XQ0m_CMAX(u) 2047
#define BCM56504_A0_MMU_XQ0m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ0.
 *
 */
typedef union BCM56504_A0_MMU_XQ0m_s {
	uint32_t v[1];
	uint32_t mmu_xq0[1];
	uint32_t _mmu_xq0;
} BCM56504_A0_MMU_XQ0m_t;

#define BCM56504_A0_MMU_XQ0m_CLR(r) (r).mmu_xq0[0] = 0
#define BCM56504_A0_MMU_XQ0m_SET(r,d) (r).mmu_xq0[0] = d
#define BCM56504_A0_MMU_XQ0m_GET(r) (r).mmu_xq0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MMU_XQ0m_PARITY_0f_GET(r) (((r).mmu_xq0[0]) & 0x1)
#define BCM56504_A0_MMU_XQ0m_PARITY_0f_SET(r,f) (r).mmu_xq0[0]=(((r).mmu_xq0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_MMU_XQ0m_L2f_GET(r) ((((r).mmu_xq0[0]) >> 1) & 0x1)
#define BCM56504_A0_MMU_XQ0m_L2f_SET(r,f) (r).mmu_xq0[0]=(((r).mmu_xq0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_MMU_XQ0m_PURGEf_GET(r) ((((r).mmu_xq0[0]) >> 2) & 0x1)
#define BCM56504_A0_MMU_XQ0m_PURGEf_SET(r,f) (r).mmu_xq0[0]=(((r).mmu_xq0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_MMU_XQ0m_PKT_PTRf_GET(r) ((((r).mmu_xq0[0]) >> 3) & 0x3fff)
#define BCM56504_A0_MMU_XQ0m_PKT_PTRf_SET(r,f) (r).mmu_xq0[0]=(((r).mmu_xq0[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56504_A0_MMU_XQ0m_L3IPMCf_GET(r) ((((r).mmu_xq0[0]) >> 17) & 0x1)
#define BCM56504_A0_MMU_XQ0m_L3IPMCf_SET(r,f) (r).mmu_xq0[0]=(((r).mmu_xq0[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56504_A0_MMU_XQ0m_IMIRRORf_GET(r) ((((r).mmu_xq0[0]) >> 18) & 0x1)
#define BCM56504_A0_MMU_XQ0m_IMIRRORf_SET(r,f) (r).mmu_xq0[0]=(((r).mmu_xq0[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56504_A0_MMU_XQ0m_EMIRRORf_GET(r) ((((r).mmu_xq0[0]) >> 19) & 0x1)
#define BCM56504_A0_MMU_XQ0m_EMIRRORf_SET(r,f) (r).mmu_xq0[0]=(((r).mmu_xq0[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ0.
 *
 */
#define BCM56504_A0_READ_MMU_XQ0m(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_MMU_XQ0m,i,(m._mmu_xq0),1)
#define BCM56504_A0_WRITE_MMU_XQ0m(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_MMU_XQ0m,i,&(m._mmu_xq0),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ0m BCM56504_A0_MMU_XQ0m
#define MMU_XQ0m_MIN BCM56504_A0_MMU_XQ0m_MIN
#define MMU_XQ0m_MAX BCM56504_A0_MMU_XQ0m_MAX
#define MMU_XQ0m_CMAX(u) BCM56504_A0_MMU_XQ0m_CMAX(u)
#define MMU_XQ0m_SIZE BCM56504_A0_MMU_XQ0m_SIZE
typedef BCM56504_A0_MMU_XQ0m_t MMU_XQ0m_t;
#define MMU_XQ0m_CLR BCM56504_A0_MMU_XQ0m_CLR
#define MMU_XQ0m_SET BCM56504_A0_MMU_XQ0m_SET
#define MMU_XQ0m_GET BCM56504_A0_MMU_XQ0m_GET
#define MMU_XQ0m_PARITY_0f_GET BCM56504_A0_MMU_XQ0m_PARITY_0f_GET
#define MMU_XQ0m_PARITY_0f_SET BCM56504_A0_MMU_XQ0m_PARITY_0f_SET
#define MMU_XQ0m_L2f_GET BCM56504_A0_MMU_XQ0m_L2f_GET
#define MMU_XQ0m_L2f_SET BCM56504_A0_MMU_XQ0m_L2f_SET
#define MMU_XQ0m_PURGEf_GET BCM56504_A0_MMU_XQ0m_PURGEf_GET
#define MMU_XQ0m_PURGEf_SET BCM56504_A0_MMU_XQ0m_PURGEf_SET
#define MMU_XQ0m_PKT_PTRf_GET BCM56504_A0_MMU_XQ0m_PKT_PTRf_GET
#define MMU_XQ0m_PKT_PTRf_SET BCM56504_A0_MMU_XQ0m_PKT_PTRf_SET
#define MMU_XQ0m_L3IPMCf_GET BCM56504_A0_MMU_XQ0m_L3IPMCf_GET
#define MMU_XQ0m_L3IPMCf_SET BCM56504_A0_MMU_XQ0m_L3IPMCf_SET
#define MMU_XQ0m_IMIRRORf_GET BCM56504_A0_MMU_XQ0m_IMIRRORf_GET
#define MMU_XQ0m_IMIRRORf_SET BCM56504_A0_MMU_XQ0m_IMIRRORf_SET
#define MMU_XQ0m_EMIRRORf_GET BCM56504_A0_MMU_XQ0m_EMIRRORf_GET
#define MMU_XQ0m_EMIRRORf_SET BCM56504_A0_MMU_XQ0m_EMIRRORf_SET
#define READ_MMU_XQ0m BCM56504_A0_READ_MMU_XQ0m
#define WRITE_MMU_XQ0m BCM56504_A0_WRITE_MMU_XQ0m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MMU_XQ0m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  MMU_XQ1
 * BLOCKS:   MMU
 * DESC:     XQ1
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     L3IPMC           L3 IP multicast Flag
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56504_A0_MMU_XQ1m 0x0b604000

#define BCM56504_A0_MMU_XQ1m_MIN 0
#define BCM56504_A0_MMU_XQ1m_MAX 2047
#define BCM56504_A0_MMU_XQ1m_CMAX(u) 2047
#define BCM56504_A0_MMU_XQ1m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ1.
 *
 */
typedef union BCM56504_A0_MMU_XQ1m_s {
	uint32_t v[1];
	uint32_t mmu_xq1[1];
	uint32_t _mmu_xq1;
} BCM56504_A0_MMU_XQ1m_t;

#define BCM56504_A0_MMU_XQ1m_CLR(r) (r).mmu_xq1[0] = 0
#define BCM56504_A0_MMU_XQ1m_SET(r,d) (r).mmu_xq1[0] = d
#define BCM56504_A0_MMU_XQ1m_GET(r) (r).mmu_xq1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MMU_XQ1m_PARITY_0f_GET(r) (((r).mmu_xq1[0]) & 0x1)
#define BCM56504_A0_MMU_XQ1m_PARITY_0f_SET(r,f) (r).mmu_xq1[0]=(((r).mmu_xq1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_MMU_XQ1m_L2f_GET(r) ((((r).mmu_xq1[0]) >> 1) & 0x1)
#define BCM56504_A0_MMU_XQ1m_L2f_SET(r,f) (r).mmu_xq1[0]=(((r).mmu_xq1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_MMU_XQ1m_PURGEf_GET(r) ((((r).mmu_xq1[0]) >> 2) & 0x1)
#define BCM56504_A0_MMU_XQ1m_PURGEf_SET(r,f) (r).mmu_xq1[0]=(((r).mmu_xq1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_MMU_XQ1m_PKT_PTRf_GET(r) ((((r).mmu_xq1[0]) >> 3) & 0x3fff)
#define BCM56504_A0_MMU_XQ1m_PKT_PTRf_SET(r,f) (r).mmu_xq1[0]=(((r).mmu_xq1[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56504_A0_MMU_XQ1m_L3IPMCf_GET(r) ((((r).mmu_xq1[0]) >> 17) & 0x1)
#define BCM56504_A0_MMU_XQ1m_L3IPMCf_SET(r,f) (r).mmu_xq1[0]=(((r).mmu_xq1[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56504_A0_MMU_XQ1m_IMIRRORf_GET(r) ((((r).mmu_xq1[0]) >> 18) & 0x1)
#define BCM56504_A0_MMU_XQ1m_IMIRRORf_SET(r,f) (r).mmu_xq1[0]=(((r).mmu_xq1[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56504_A0_MMU_XQ1m_EMIRRORf_GET(r) ((((r).mmu_xq1[0]) >> 19) & 0x1)
#define BCM56504_A0_MMU_XQ1m_EMIRRORf_SET(r,f) (r).mmu_xq1[0]=(((r).mmu_xq1[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ1.
 *
 */
#define BCM56504_A0_READ_MMU_XQ1m(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_MMU_XQ1m,i,(m._mmu_xq1),1)
#define BCM56504_A0_WRITE_MMU_XQ1m(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_MMU_XQ1m,i,&(m._mmu_xq1),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ1m BCM56504_A0_MMU_XQ1m
#define MMU_XQ1m_MIN BCM56504_A0_MMU_XQ1m_MIN
#define MMU_XQ1m_MAX BCM56504_A0_MMU_XQ1m_MAX
#define MMU_XQ1m_CMAX(u) BCM56504_A0_MMU_XQ1m_CMAX(u)
#define MMU_XQ1m_SIZE BCM56504_A0_MMU_XQ1m_SIZE
typedef BCM56504_A0_MMU_XQ1m_t MMU_XQ1m_t;
#define MMU_XQ1m_CLR BCM56504_A0_MMU_XQ1m_CLR
#define MMU_XQ1m_SET BCM56504_A0_MMU_XQ1m_SET
#define MMU_XQ1m_GET BCM56504_A0_MMU_XQ1m_GET
#define MMU_XQ1m_PARITY_0f_GET BCM56504_A0_MMU_XQ1m_PARITY_0f_GET
#define MMU_XQ1m_PARITY_0f_SET BCM56504_A0_MMU_XQ1m_PARITY_0f_SET
#define MMU_XQ1m_L2f_GET BCM56504_A0_MMU_XQ1m_L2f_GET
#define MMU_XQ1m_L2f_SET BCM56504_A0_MMU_XQ1m_L2f_SET
#define MMU_XQ1m_PURGEf_GET BCM56504_A0_MMU_XQ1m_PURGEf_GET
#define MMU_XQ1m_PURGEf_SET BCM56504_A0_MMU_XQ1m_PURGEf_SET
#define MMU_XQ1m_PKT_PTRf_GET BCM56504_A0_MMU_XQ1m_PKT_PTRf_GET
#define MMU_XQ1m_PKT_PTRf_SET BCM56504_A0_MMU_XQ1m_PKT_PTRf_SET
#define MMU_XQ1m_L3IPMCf_GET BCM56504_A0_MMU_XQ1m_L3IPMCf_GET
#define MMU_XQ1m_L3IPMCf_SET BCM56504_A0_MMU_XQ1m_L3IPMCf_SET
#define MMU_XQ1m_IMIRRORf_GET BCM56504_A0_MMU_XQ1m_IMIRRORf_GET
#define MMU_XQ1m_IMIRRORf_SET BCM56504_A0_MMU_XQ1m_IMIRRORf_SET
#define MMU_XQ1m_EMIRRORf_GET BCM56504_A0_MMU_XQ1m_EMIRRORf_GET
#define MMU_XQ1m_EMIRRORf_SET BCM56504_A0_MMU_XQ1m_EMIRRORf_SET
#define READ_MMU_XQ1m BCM56504_A0_READ_MMU_XQ1m
#define WRITE_MMU_XQ1m BCM56504_A0_WRITE_MMU_XQ1m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MMU_XQ1m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  MMU_XQ10
 * BLOCKS:   MMU
 * DESC:     XQ10
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     L3IPMC           L3 IP multicast Flag
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56504_A0_MMU_XQ10m 0x0b628000

#define BCM56504_A0_MMU_XQ10m_MIN 0
#define BCM56504_A0_MMU_XQ10m_MAX 2047
#define BCM56504_A0_MMU_XQ10m_CMAX(u) 2047
#define BCM56504_A0_MMU_XQ10m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ10.
 *
 */
typedef union BCM56504_A0_MMU_XQ10m_s {
	uint32_t v[1];
	uint32_t mmu_xq10[1];
	uint32_t _mmu_xq10;
} BCM56504_A0_MMU_XQ10m_t;

#define BCM56504_A0_MMU_XQ10m_CLR(r) (r).mmu_xq10[0] = 0
#define BCM56504_A0_MMU_XQ10m_SET(r,d) (r).mmu_xq10[0] = d
#define BCM56504_A0_MMU_XQ10m_GET(r) (r).mmu_xq10[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MMU_XQ10m_PARITY_0f_GET(r) (((r).mmu_xq10[0]) & 0x1)
#define BCM56504_A0_MMU_XQ10m_PARITY_0f_SET(r,f) (r).mmu_xq10[0]=(((r).mmu_xq10[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_MMU_XQ10m_L2f_GET(r) ((((r).mmu_xq10[0]) >> 1) & 0x1)
#define BCM56504_A0_MMU_XQ10m_L2f_SET(r,f) (r).mmu_xq10[0]=(((r).mmu_xq10[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_MMU_XQ10m_PURGEf_GET(r) ((((r).mmu_xq10[0]) >> 2) & 0x1)
#define BCM56504_A0_MMU_XQ10m_PURGEf_SET(r,f) (r).mmu_xq10[0]=(((r).mmu_xq10[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_MMU_XQ10m_PKT_PTRf_GET(r) ((((r).mmu_xq10[0]) >> 3) & 0x3fff)
#define BCM56504_A0_MMU_XQ10m_PKT_PTRf_SET(r,f) (r).mmu_xq10[0]=(((r).mmu_xq10[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56504_A0_MMU_XQ10m_L3IPMCf_GET(r) ((((r).mmu_xq10[0]) >> 17) & 0x1)
#define BCM56504_A0_MMU_XQ10m_L3IPMCf_SET(r,f) (r).mmu_xq10[0]=(((r).mmu_xq10[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56504_A0_MMU_XQ10m_IMIRRORf_GET(r) ((((r).mmu_xq10[0]) >> 18) & 0x1)
#define BCM56504_A0_MMU_XQ10m_IMIRRORf_SET(r,f) (r).mmu_xq10[0]=(((r).mmu_xq10[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56504_A0_MMU_XQ10m_EMIRRORf_GET(r) ((((r).mmu_xq10[0]) >> 19) & 0x1)
#define BCM56504_A0_MMU_XQ10m_EMIRRORf_SET(r,f) (r).mmu_xq10[0]=(((r).mmu_xq10[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ10.
 *
 */
#define BCM56504_A0_READ_MMU_XQ10m(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_MMU_XQ10m,i,(m._mmu_xq10),1)
#define BCM56504_A0_WRITE_MMU_XQ10m(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_MMU_XQ10m,i,&(m._mmu_xq10),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ10m BCM56504_A0_MMU_XQ10m
#define MMU_XQ10m_MIN BCM56504_A0_MMU_XQ10m_MIN
#define MMU_XQ10m_MAX BCM56504_A0_MMU_XQ10m_MAX
#define MMU_XQ10m_CMAX(u) BCM56504_A0_MMU_XQ10m_CMAX(u)
#define MMU_XQ10m_SIZE BCM56504_A0_MMU_XQ10m_SIZE
typedef BCM56504_A0_MMU_XQ10m_t MMU_XQ10m_t;
#define MMU_XQ10m_CLR BCM56504_A0_MMU_XQ10m_CLR
#define MMU_XQ10m_SET BCM56504_A0_MMU_XQ10m_SET
#define MMU_XQ10m_GET BCM56504_A0_MMU_XQ10m_GET
#define MMU_XQ10m_PARITY_0f_GET BCM56504_A0_MMU_XQ10m_PARITY_0f_GET
#define MMU_XQ10m_PARITY_0f_SET BCM56504_A0_MMU_XQ10m_PARITY_0f_SET
#define MMU_XQ10m_L2f_GET BCM56504_A0_MMU_XQ10m_L2f_GET
#define MMU_XQ10m_L2f_SET BCM56504_A0_MMU_XQ10m_L2f_SET
#define MMU_XQ10m_PURGEf_GET BCM56504_A0_MMU_XQ10m_PURGEf_GET
#define MMU_XQ10m_PURGEf_SET BCM56504_A0_MMU_XQ10m_PURGEf_SET
#define MMU_XQ10m_PKT_PTRf_GET BCM56504_A0_MMU_XQ10m_PKT_PTRf_GET
#define MMU_XQ10m_PKT_PTRf_SET BCM56504_A0_MMU_XQ10m_PKT_PTRf_SET
#define MMU_XQ10m_L3IPMCf_GET BCM56504_A0_MMU_XQ10m_L3IPMCf_GET
#define MMU_XQ10m_L3IPMCf_SET BCM56504_A0_MMU_XQ10m_L3IPMCf_SET
#define MMU_XQ10m_IMIRRORf_GET BCM56504_A0_MMU_XQ10m_IMIRRORf_GET
#define MMU_XQ10m_IMIRRORf_SET BCM56504_A0_MMU_XQ10m_IMIRRORf_SET
#define MMU_XQ10m_EMIRRORf_GET BCM56504_A0_MMU_XQ10m_EMIRRORf_GET
#define MMU_XQ10m_EMIRRORf_SET BCM56504_A0_MMU_XQ10m_EMIRRORf_SET
#define READ_MMU_XQ10m BCM56504_A0_READ_MMU_XQ10m
#define WRITE_MMU_XQ10m BCM56504_A0_WRITE_MMU_XQ10m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MMU_XQ10m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  MMU_XQ11
 * BLOCKS:   MMU
 * DESC:     XQ11
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     L3IPMC           L3 IP multicast Flag
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56504_A0_MMU_XQ11m 0x0b62c000

#define BCM56504_A0_MMU_XQ11m_MIN 0
#define BCM56504_A0_MMU_XQ11m_MAX 2047
#define BCM56504_A0_MMU_XQ11m_CMAX(u) 2047
#define BCM56504_A0_MMU_XQ11m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ11.
 *
 */
typedef union BCM56504_A0_MMU_XQ11m_s {
	uint32_t v[1];
	uint32_t mmu_xq11[1];
	uint32_t _mmu_xq11;
} BCM56504_A0_MMU_XQ11m_t;

#define BCM56504_A0_MMU_XQ11m_CLR(r) (r).mmu_xq11[0] = 0
#define BCM56504_A0_MMU_XQ11m_SET(r,d) (r).mmu_xq11[0] = d
#define BCM56504_A0_MMU_XQ11m_GET(r) (r).mmu_xq11[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MMU_XQ11m_PARITY_0f_GET(r) (((r).mmu_xq11[0]) & 0x1)
#define BCM56504_A0_MMU_XQ11m_PARITY_0f_SET(r,f) (r).mmu_xq11[0]=(((r).mmu_xq11[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_MMU_XQ11m_L2f_GET(r) ((((r).mmu_xq11[0]) >> 1) & 0x1)
#define BCM56504_A0_MMU_XQ11m_L2f_SET(r,f) (r).mmu_xq11[0]=(((r).mmu_xq11[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_MMU_XQ11m_PURGEf_GET(r) ((((r).mmu_xq11[0]) >> 2) & 0x1)
#define BCM56504_A0_MMU_XQ11m_PURGEf_SET(r,f) (r).mmu_xq11[0]=(((r).mmu_xq11[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_MMU_XQ11m_PKT_PTRf_GET(r) ((((r).mmu_xq11[0]) >> 3) & 0x3fff)
#define BCM56504_A0_MMU_XQ11m_PKT_PTRf_SET(r,f) (r).mmu_xq11[0]=(((r).mmu_xq11[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56504_A0_MMU_XQ11m_L3IPMCf_GET(r) ((((r).mmu_xq11[0]) >> 17) & 0x1)
#define BCM56504_A0_MMU_XQ11m_L3IPMCf_SET(r,f) (r).mmu_xq11[0]=(((r).mmu_xq11[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56504_A0_MMU_XQ11m_IMIRRORf_GET(r) ((((r).mmu_xq11[0]) >> 18) & 0x1)
#define BCM56504_A0_MMU_XQ11m_IMIRRORf_SET(r,f) (r).mmu_xq11[0]=(((r).mmu_xq11[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56504_A0_MMU_XQ11m_EMIRRORf_GET(r) ((((r).mmu_xq11[0]) >> 19) & 0x1)
#define BCM56504_A0_MMU_XQ11m_EMIRRORf_SET(r,f) (r).mmu_xq11[0]=(((r).mmu_xq11[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ11.
 *
 */
#define BCM56504_A0_READ_MMU_XQ11m(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_MMU_XQ11m,i,(m._mmu_xq11),1)
#define BCM56504_A0_WRITE_MMU_XQ11m(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_MMU_XQ11m,i,&(m._mmu_xq11),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ11m BCM56504_A0_MMU_XQ11m
#define MMU_XQ11m_MIN BCM56504_A0_MMU_XQ11m_MIN
#define MMU_XQ11m_MAX BCM56504_A0_MMU_XQ11m_MAX
#define MMU_XQ11m_CMAX(u) BCM56504_A0_MMU_XQ11m_CMAX(u)
#define MMU_XQ11m_SIZE BCM56504_A0_MMU_XQ11m_SIZE
typedef BCM56504_A0_MMU_XQ11m_t MMU_XQ11m_t;
#define MMU_XQ11m_CLR BCM56504_A0_MMU_XQ11m_CLR
#define MMU_XQ11m_SET BCM56504_A0_MMU_XQ11m_SET
#define MMU_XQ11m_GET BCM56504_A0_MMU_XQ11m_GET
#define MMU_XQ11m_PARITY_0f_GET BCM56504_A0_MMU_XQ11m_PARITY_0f_GET
#define MMU_XQ11m_PARITY_0f_SET BCM56504_A0_MMU_XQ11m_PARITY_0f_SET
#define MMU_XQ11m_L2f_GET BCM56504_A0_MMU_XQ11m_L2f_GET
#define MMU_XQ11m_L2f_SET BCM56504_A0_MMU_XQ11m_L2f_SET
#define MMU_XQ11m_PURGEf_GET BCM56504_A0_MMU_XQ11m_PURGEf_GET
#define MMU_XQ11m_PURGEf_SET BCM56504_A0_MMU_XQ11m_PURGEf_SET
#define MMU_XQ11m_PKT_PTRf_GET BCM56504_A0_MMU_XQ11m_PKT_PTRf_GET
#define MMU_XQ11m_PKT_PTRf_SET BCM56504_A0_MMU_XQ11m_PKT_PTRf_SET
#define MMU_XQ11m_L3IPMCf_GET BCM56504_A0_MMU_XQ11m_L3IPMCf_GET
#define MMU_XQ11m_L3IPMCf_SET BCM56504_A0_MMU_XQ11m_L3IPMCf_SET
#define MMU_XQ11m_IMIRRORf_GET BCM56504_A0_MMU_XQ11m_IMIRRORf_GET
#define MMU_XQ11m_IMIRRORf_SET BCM56504_A0_MMU_XQ11m_IMIRRORf_SET
#define MMU_XQ11m_EMIRRORf_GET BCM56504_A0_MMU_XQ11m_EMIRRORf_GET
#define MMU_XQ11m_EMIRRORf_SET BCM56504_A0_MMU_XQ11m_EMIRRORf_SET
#define READ_MMU_XQ11m BCM56504_A0_READ_MMU_XQ11m
#define WRITE_MMU_XQ11m BCM56504_A0_WRITE_MMU_XQ11m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MMU_XQ11m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  MMU_XQ12
 * BLOCKS:   MMU
 * DESC:     XQ12
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     L3IPMC           L3 IP multicast Flag
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56504_A0_MMU_XQ12m 0x0b630000

#define BCM56504_A0_MMU_XQ12m_MIN 0
#define BCM56504_A0_MMU_XQ12m_MAX 2047
#define BCM56504_A0_MMU_XQ12m_CMAX(u) 2047
#define BCM56504_A0_MMU_XQ12m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ12.
 *
 */
typedef union BCM56504_A0_MMU_XQ12m_s {
	uint32_t v[1];
	uint32_t mmu_xq12[1];
	uint32_t _mmu_xq12;
} BCM56504_A0_MMU_XQ12m_t;

#define BCM56504_A0_MMU_XQ12m_CLR(r) (r).mmu_xq12[0] = 0
#define BCM56504_A0_MMU_XQ12m_SET(r,d) (r).mmu_xq12[0] = d
#define BCM56504_A0_MMU_XQ12m_GET(r) (r).mmu_xq12[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MMU_XQ12m_PARITY_0f_GET(r) (((r).mmu_xq12[0]) & 0x1)
#define BCM56504_A0_MMU_XQ12m_PARITY_0f_SET(r,f) (r).mmu_xq12[0]=(((r).mmu_xq12[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_MMU_XQ12m_L2f_GET(r) ((((r).mmu_xq12[0]) >> 1) & 0x1)
#define BCM56504_A0_MMU_XQ12m_L2f_SET(r,f) (r).mmu_xq12[0]=(((r).mmu_xq12[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_MMU_XQ12m_PURGEf_GET(r) ((((r).mmu_xq12[0]) >> 2) & 0x1)
#define BCM56504_A0_MMU_XQ12m_PURGEf_SET(r,f) (r).mmu_xq12[0]=(((r).mmu_xq12[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_MMU_XQ12m_PKT_PTRf_GET(r) ((((r).mmu_xq12[0]) >> 3) & 0x3fff)
#define BCM56504_A0_MMU_XQ12m_PKT_PTRf_SET(r,f) (r).mmu_xq12[0]=(((r).mmu_xq12[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56504_A0_MMU_XQ12m_L3IPMCf_GET(r) ((((r).mmu_xq12[0]) >> 17) & 0x1)
#define BCM56504_A0_MMU_XQ12m_L3IPMCf_SET(r,f) (r).mmu_xq12[0]=(((r).mmu_xq12[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56504_A0_MMU_XQ12m_IMIRRORf_GET(r) ((((r).mmu_xq12[0]) >> 18) & 0x1)
#define BCM56504_A0_MMU_XQ12m_IMIRRORf_SET(r,f) (r).mmu_xq12[0]=(((r).mmu_xq12[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56504_A0_MMU_XQ12m_EMIRRORf_GET(r) ((((r).mmu_xq12[0]) >> 19) & 0x1)
#define BCM56504_A0_MMU_XQ12m_EMIRRORf_SET(r,f) (r).mmu_xq12[0]=(((r).mmu_xq12[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ12.
 *
 */
#define BCM56504_A0_READ_MMU_XQ12m(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_MMU_XQ12m,i,(m._mmu_xq12),1)
#define BCM56504_A0_WRITE_MMU_XQ12m(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_MMU_XQ12m,i,&(m._mmu_xq12),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ12m BCM56504_A0_MMU_XQ12m
#define MMU_XQ12m_MIN BCM56504_A0_MMU_XQ12m_MIN
#define MMU_XQ12m_MAX BCM56504_A0_MMU_XQ12m_MAX
#define MMU_XQ12m_CMAX(u) BCM56504_A0_MMU_XQ12m_CMAX(u)
#define MMU_XQ12m_SIZE BCM56504_A0_MMU_XQ12m_SIZE
typedef BCM56504_A0_MMU_XQ12m_t MMU_XQ12m_t;
#define MMU_XQ12m_CLR BCM56504_A0_MMU_XQ12m_CLR
#define MMU_XQ12m_SET BCM56504_A0_MMU_XQ12m_SET
#define MMU_XQ12m_GET BCM56504_A0_MMU_XQ12m_GET
#define MMU_XQ12m_PARITY_0f_GET BCM56504_A0_MMU_XQ12m_PARITY_0f_GET
#define MMU_XQ12m_PARITY_0f_SET BCM56504_A0_MMU_XQ12m_PARITY_0f_SET
#define MMU_XQ12m_L2f_GET BCM56504_A0_MMU_XQ12m_L2f_GET
#define MMU_XQ12m_L2f_SET BCM56504_A0_MMU_XQ12m_L2f_SET
#define MMU_XQ12m_PURGEf_GET BCM56504_A0_MMU_XQ12m_PURGEf_GET
#define MMU_XQ12m_PURGEf_SET BCM56504_A0_MMU_XQ12m_PURGEf_SET
#define MMU_XQ12m_PKT_PTRf_GET BCM56504_A0_MMU_XQ12m_PKT_PTRf_GET
#define MMU_XQ12m_PKT_PTRf_SET BCM56504_A0_MMU_XQ12m_PKT_PTRf_SET
#define MMU_XQ12m_L3IPMCf_GET BCM56504_A0_MMU_XQ12m_L3IPMCf_GET
#define MMU_XQ12m_L3IPMCf_SET BCM56504_A0_MMU_XQ12m_L3IPMCf_SET
#define MMU_XQ12m_IMIRRORf_GET BCM56504_A0_MMU_XQ12m_IMIRRORf_GET
#define MMU_XQ12m_IMIRRORf_SET BCM56504_A0_MMU_XQ12m_IMIRRORf_SET
#define MMU_XQ12m_EMIRRORf_GET BCM56504_A0_MMU_XQ12m_EMIRRORf_GET
#define MMU_XQ12m_EMIRRORf_SET BCM56504_A0_MMU_XQ12m_EMIRRORf_SET
#define READ_MMU_XQ12m BCM56504_A0_READ_MMU_XQ12m
#define WRITE_MMU_XQ12m BCM56504_A0_WRITE_MMU_XQ12m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MMU_XQ12m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  MMU_XQ13
 * BLOCKS:   MMU
 * DESC:     XQ13
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     L3IPMC           L3 IP multicast Flag
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56504_A0_MMU_XQ13m 0x0b634000

#define BCM56504_A0_MMU_XQ13m_MIN 0
#define BCM56504_A0_MMU_XQ13m_MAX 2047
#define BCM56504_A0_MMU_XQ13m_CMAX(u) 2047
#define BCM56504_A0_MMU_XQ13m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ13.
 *
 */
typedef union BCM56504_A0_MMU_XQ13m_s {
	uint32_t v[1];
	uint32_t mmu_xq13[1];
	uint32_t _mmu_xq13;
} BCM56504_A0_MMU_XQ13m_t;

#define BCM56504_A0_MMU_XQ13m_CLR(r) (r).mmu_xq13[0] = 0
#define BCM56504_A0_MMU_XQ13m_SET(r,d) (r).mmu_xq13[0] = d
#define BCM56504_A0_MMU_XQ13m_GET(r) (r).mmu_xq13[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MMU_XQ13m_PARITY_0f_GET(r) (((r).mmu_xq13[0]) & 0x1)
#define BCM56504_A0_MMU_XQ13m_PARITY_0f_SET(r,f) (r).mmu_xq13[0]=(((r).mmu_xq13[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_MMU_XQ13m_L2f_GET(r) ((((r).mmu_xq13[0]) >> 1) & 0x1)
#define BCM56504_A0_MMU_XQ13m_L2f_SET(r,f) (r).mmu_xq13[0]=(((r).mmu_xq13[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_MMU_XQ13m_PURGEf_GET(r) ((((r).mmu_xq13[0]) >> 2) & 0x1)
#define BCM56504_A0_MMU_XQ13m_PURGEf_SET(r,f) (r).mmu_xq13[0]=(((r).mmu_xq13[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_MMU_XQ13m_PKT_PTRf_GET(r) ((((r).mmu_xq13[0]) >> 3) & 0x3fff)
#define BCM56504_A0_MMU_XQ13m_PKT_PTRf_SET(r,f) (r).mmu_xq13[0]=(((r).mmu_xq13[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56504_A0_MMU_XQ13m_L3IPMCf_GET(r) ((((r).mmu_xq13[0]) >> 17) & 0x1)
#define BCM56504_A0_MMU_XQ13m_L3IPMCf_SET(r,f) (r).mmu_xq13[0]=(((r).mmu_xq13[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56504_A0_MMU_XQ13m_IMIRRORf_GET(r) ((((r).mmu_xq13[0]) >> 18) & 0x1)
#define BCM56504_A0_MMU_XQ13m_IMIRRORf_SET(r,f) (r).mmu_xq13[0]=(((r).mmu_xq13[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56504_A0_MMU_XQ13m_EMIRRORf_GET(r) ((((r).mmu_xq13[0]) >> 19) & 0x1)
#define BCM56504_A0_MMU_XQ13m_EMIRRORf_SET(r,f) (r).mmu_xq13[0]=(((r).mmu_xq13[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ13.
 *
 */
#define BCM56504_A0_READ_MMU_XQ13m(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_MMU_XQ13m,i,(m._mmu_xq13),1)
#define BCM56504_A0_WRITE_MMU_XQ13m(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_MMU_XQ13m,i,&(m._mmu_xq13),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ13m BCM56504_A0_MMU_XQ13m
#define MMU_XQ13m_MIN BCM56504_A0_MMU_XQ13m_MIN
#define MMU_XQ13m_MAX BCM56504_A0_MMU_XQ13m_MAX
#define MMU_XQ13m_CMAX(u) BCM56504_A0_MMU_XQ13m_CMAX(u)
#define MMU_XQ13m_SIZE BCM56504_A0_MMU_XQ13m_SIZE
typedef BCM56504_A0_MMU_XQ13m_t MMU_XQ13m_t;
#define MMU_XQ13m_CLR BCM56504_A0_MMU_XQ13m_CLR
#define MMU_XQ13m_SET BCM56504_A0_MMU_XQ13m_SET
#define MMU_XQ13m_GET BCM56504_A0_MMU_XQ13m_GET
#define MMU_XQ13m_PARITY_0f_GET BCM56504_A0_MMU_XQ13m_PARITY_0f_GET
#define MMU_XQ13m_PARITY_0f_SET BCM56504_A0_MMU_XQ13m_PARITY_0f_SET
#define MMU_XQ13m_L2f_GET BCM56504_A0_MMU_XQ13m_L2f_GET
#define MMU_XQ13m_L2f_SET BCM56504_A0_MMU_XQ13m_L2f_SET
#define MMU_XQ13m_PURGEf_GET BCM56504_A0_MMU_XQ13m_PURGEf_GET
#define MMU_XQ13m_PURGEf_SET BCM56504_A0_MMU_XQ13m_PURGEf_SET
#define MMU_XQ13m_PKT_PTRf_GET BCM56504_A0_MMU_XQ13m_PKT_PTRf_GET
#define MMU_XQ13m_PKT_PTRf_SET BCM56504_A0_MMU_XQ13m_PKT_PTRf_SET
#define MMU_XQ13m_L3IPMCf_GET BCM56504_A0_MMU_XQ13m_L3IPMCf_GET
#define MMU_XQ13m_L3IPMCf_SET BCM56504_A0_MMU_XQ13m_L3IPMCf_SET
#define MMU_XQ13m_IMIRRORf_GET BCM56504_A0_MMU_XQ13m_IMIRRORf_GET
#define MMU_XQ13m_IMIRRORf_SET BCM56504_A0_MMU_XQ13m_IMIRRORf_SET
#define MMU_XQ13m_EMIRRORf_GET BCM56504_A0_MMU_XQ13m_EMIRRORf_GET
#define MMU_XQ13m_EMIRRORf_SET BCM56504_A0_MMU_XQ13m_EMIRRORf_SET
#define READ_MMU_XQ13m BCM56504_A0_READ_MMU_XQ13m
#define WRITE_MMU_XQ13m BCM56504_A0_WRITE_MMU_XQ13m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MMU_XQ13m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  MMU_XQ14
 * BLOCKS:   MMU
 * DESC:     XQ14
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     L3IPMC           L3 IP multicast Flag
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56504_A0_MMU_XQ14m 0x0b638000

#define BCM56504_A0_MMU_XQ14m_MIN 0
#define BCM56504_A0_MMU_XQ14m_MAX 2047
#define BCM56504_A0_MMU_XQ14m_CMAX(u) 2047
#define BCM56504_A0_MMU_XQ14m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ14.
 *
 */
typedef union BCM56504_A0_MMU_XQ14m_s {
	uint32_t v[1];
	uint32_t mmu_xq14[1];
	uint32_t _mmu_xq14;
} BCM56504_A0_MMU_XQ14m_t;

#define BCM56504_A0_MMU_XQ14m_CLR(r) (r).mmu_xq14[0] = 0
#define BCM56504_A0_MMU_XQ14m_SET(r,d) (r).mmu_xq14[0] = d
#define BCM56504_A0_MMU_XQ14m_GET(r) (r).mmu_xq14[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MMU_XQ14m_PARITY_0f_GET(r) (((r).mmu_xq14[0]) & 0x1)
#define BCM56504_A0_MMU_XQ14m_PARITY_0f_SET(r,f) (r).mmu_xq14[0]=(((r).mmu_xq14[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_MMU_XQ14m_L2f_GET(r) ((((r).mmu_xq14[0]) >> 1) & 0x1)
#define BCM56504_A0_MMU_XQ14m_L2f_SET(r,f) (r).mmu_xq14[0]=(((r).mmu_xq14[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_MMU_XQ14m_PURGEf_GET(r) ((((r).mmu_xq14[0]) >> 2) & 0x1)
#define BCM56504_A0_MMU_XQ14m_PURGEf_SET(r,f) (r).mmu_xq14[0]=(((r).mmu_xq14[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_MMU_XQ14m_PKT_PTRf_GET(r) ((((r).mmu_xq14[0]) >> 3) & 0x3fff)
#define BCM56504_A0_MMU_XQ14m_PKT_PTRf_SET(r,f) (r).mmu_xq14[0]=(((r).mmu_xq14[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56504_A0_MMU_XQ14m_L3IPMCf_GET(r) ((((r).mmu_xq14[0]) >> 17) & 0x1)
#define BCM56504_A0_MMU_XQ14m_L3IPMCf_SET(r,f) (r).mmu_xq14[0]=(((r).mmu_xq14[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56504_A0_MMU_XQ14m_IMIRRORf_GET(r) ((((r).mmu_xq14[0]) >> 18) & 0x1)
#define BCM56504_A0_MMU_XQ14m_IMIRRORf_SET(r,f) (r).mmu_xq14[0]=(((r).mmu_xq14[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56504_A0_MMU_XQ14m_EMIRRORf_GET(r) ((((r).mmu_xq14[0]) >> 19) & 0x1)
#define BCM56504_A0_MMU_XQ14m_EMIRRORf_SET(r,f) (r).mmu_xq14[0]=(((r).mmu_xq14[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ14.
 *
 */
#define BCM56504_A0_READ_MMU_XQ14m(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_MMU_XQ14m,i,(m._mmu_xq14),1)
#define BCM56504_A0_WRITE_MMU_XQ14m(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_MMU_XQ14m,i,&(m._mmu_xq14),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ14m BCM56504_A0_MMU_XQ14m
#define MMU_XQ14m_MIN BCM56504_A0_MMU_XQ14m_MIN
#define MMU_XQ14m_MAX BCM56504_A0_MMU_XQ14m_MAX
#define MMU_XQ14m_CMAX(u) BCM56504_A0_MMU_XQ14m_CMAX(u)
#define MMU_XQ14m_SIZE BCM56504_A0_MMU_XQ14m_SIZE
typedef BCM56504_A0_MMU_XQ14m_t MMU_XQ14m_t;
#define MMU_XQ14m_CLR BCM56504_A0_MMU_XQ14m_CLR
#define MMU_XQ14m_SET BCM56504_A0_MMU_XQ14m_SET
#define MMU_XQ14m_GET BCM56504_A0_MMU_XQ14m_GET
#define MMU_XQ14m_PARITY_0f_GET BCM56504_A0_MMU_XQ14m_PARITY_0f_GET
#define MMU_XQ14m_PARITY_0f_SET BCM56504_A0_MMU_XQ14m_PARITY_0f_SET
#define MMU_XQ14m_L2f_GET BCM56504_A0_MMU_XQ14m_L2f_GET
#define MMU_XQ14m_L2f_SET BCM56504_A0_MMU_XQ14m_L2f_SET
#define MMU_XQ14m_PURGEf_GET BCM56504_A0_MMU_XQ14m_PURGEf_GET
#define MMU_XQ14m_PURGEf_SET BCM56504_A0_MMU_XQ14m_PURGEf_SET
#define MMU_XQ14m_PKT_PTRf_GET BCM56504_A0_MMU_XQ14m_PKT_PTRf_GET
#define MMU_XQ14m_PKT_PTRf_SET BCM56504_A0_MMU_XQ14m_PKT_PTRf_SET
#define MMU_XQ14m_L3IPMCf_GET BCM56504_A0_MMU_XQ14m_L3IPMCf_GET
#define MMU_XQ14m_L3IPMCf_SET BCM56504_A0_MMU_XQ14m_L3IPMCf_SET
#define MMU_XQ14m_IMIRRORf_GET BCM56504_A0_MMU_XQ14m_IMIRRORf_GET
#define MMU_XQ14m_IMIRRORf_SET BCM56504_A0_MMU_XQ14m_IMIRRORf_SET
#define MMU_XQ14m_EMIRRORf_GET BCM56504_A0_MMU_XQ14m_EMIRRORf_GET
#define MMU_XQ14m_EMIRRORf_SET BCM56504_A0_MMU_XQ14m_EMIRRORf_SET
#define READ_MMU_XQ14m BCM56504_A0_READ_MMU_XQ14m
#define WRITE_MMU_XQ14m BCM56504_A0_WRITE_MMU_XQ14m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MMU_XQ14m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  MMU_XQ15
 * BLOCKS:   MMU
 * DESC:     XQ15
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     L3IPMC           L3 IP multicast Flag
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56504_A0_MMU_XQ15m 0x0b63c000

#define BCM56504_A0_MMU_XQ15m_MIN 0
#define BCM56504_A0_MMU_XQ15m_MAX 2047
#define BCM56504_A0_MMU_XQ15m_CMAX(u) 2047
#define BCM56504_A0_MMU_XQ15m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ15.
 *
 */
typedef union BCM56504_A0_MMU_XQ15m_s {
	uint32_t v[1];
	uint32_t mmu_xq15[1];
	uint32_t _mmu_xq15;
} BCM56504_A0_MMU_XQ15m_t;

#define BCM56504_A0_MMU_XQ15m_CLR(r) (r).mmu_xq15[0] = 0
#define BCM56504_A0_MMU_XQ15m_SET(r,d) (r).mmu_xq15[0] = d
#define BCM56504_A0_MMU_XQ15m_GET(r) (r).mmu_xq15[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MMU_XQ15m_PARITY_0f_GET(r) (((r).mmu_xq15[0]) & 0x1)
#define BCM56504_A0_MMU_XQ15m_PARITY_0f_SET(r,f) (r).mmu_xq15[0]=(((r).mmu_xq15[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_MMU_XQ15m_L2f_GET(r) ((((r).mmu_xq15[0]) >> 1) & 0x1)
#define BCM56504_A0_MMU_XQ15m_L2f_SET(r,f) (r).mmu_xq15[0]=(((r).mmu_xq15[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_MMU_XQ15m_PURGEf_GET(r) ((((r).mmu_xq15[0]) >> 2) & 0x1)
#define BCM56504_A0_MMU_XQ15m_PURGEf_SET(r,f) (r).mmu_xq15[0]=(((r).mmu_xq15[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_MMU_XQ15m_PKT_PTRf_GET(r) ((((r).mmu_xq15[0]) >> 3) & 0x3fff)
#define BCM56504_A0_MMU_XQ15m_PKT_PTRf_SET(r,f) (r).mmu_xq15[0]=(((r).mmu_xq15[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56504_A0_MMU_XQ15m_L3IPMCf_GET(r) ((((r).mmu_xq15[0]) >> 17) & 0x1)
#define BCM56504_A0_MMU_XQ15m_L3IPMCf_SET(r,f) (r).mmu_xq15[0]=(((r).mmu_xq15[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56504_A0_MMU_XQ15m_IMIRRORf_GET(r) ((((r).mmu_xq15[0]) >> 18) & 0x1)
#define BCM56504_A0_MMU_XQ15m_IMIRRORf_SET(r,f) (r).mmu_xq15[0]=(((r).mmu_xq15[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56504_A0_MMU_XQ15m_EMIRRORf_GET(r) ((((r).mmu_xq15[0]) >> 19) & 0x1)
#define BCM56504_A0_MMU_XQ15m_EMIRRORf_SET(r,f) (r).mmu_xq15[0]=(((r).mmu_xq15[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ15.
 *
 */
#define BCM56504_A0_READ_MMU_XQ15m(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_MMU_XQ15m,i,(m._mmu_xq15),1)
#define BCM56504_A0_WRITE_MMU_XQ15m(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_MMU_XQ15m,i,&(m._mmu_xq15),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ15m BCM56504_A0_MMU_XQ15m
#define MMU_XQ15m_MIN BCM56504_A0_MMU_XQ15m_MIN
#define MMU_XQ15m_MAX BCM56504_A0_MMU_XQ15m_MAX
#define MMU_XQ15m_CMAX(u) BCM56504_A0_MMU_XQ15m_CMAX(u)
#define MMU_XQ15m_SIZE BCM56504_A0_MMU_XQ15m_SIZE
typedef BCM56504_A0_MMU_XQ15m_t MMU_XQ15m_t;
#define MMU_XQ15m_CLR BCM56504_A0_MMU_XQ15m_CLR
#define MMU_XQ15m_SET BCM56504_A0_MMU_XQ15m_SET
#define MMU_XQ15m_GET BCM56504_A0_MMU_XQ15m_GET
#define MMU_XQ15m_PARITY_0f_GET BCM56504_A0_MMU_XQ15m_PARITY_0f_GET
#define MMU_XQ15m_PARITY_0f_SET BCM56504_A0_MMU_XQ15m_PARITY_0f_SET
#define MMU_XQ15m_L2f_GET BCM56504_A0_MMU_XQ15m_L2f_GET
#define MMU_XQ15m_L2f_SET BCM56504_A0_MMU_XQ15m_L2f_SET
#define MMU_XQ15m_PURGEf_GET BCM56504_A0_MMU_XQ15m_PURGEf_GET
#define MMU_XQ15m_PURGEf_SET BCM56504_A0_MMU_XQ15m_PURGEf_SET
#define MMU_XQ15m_PKT_PTRf_GET BCM56504_A0_MMU_XQ15m_PKT_PTRf_GET
#define MMU_XQ15m_PKT_PTRf_SET BCM56504_A0_MMU_XQ15m_PKT_PTRf_SET
#define MMU_XQ15m_L3IPMCf_GET BCM56504_A0_MMU_XQ15m_L3IPMCf_GET
#define MMU_XQ15m_L3IPMCf_SET BCM56504_A0_MMU_XQ15m_L3IPMCf_SET
#define MMU_XQ15m_IMIRRORf_GET BCM56504_A0_MMU_XQ15m_IMIRRORf_GET
#define MMU_XQ15m_IMIRRORf_SET BCM56504_A0_MMU_XQ15m_IMIRRORf_SET
#define MMU_XQ15m_EMIRRORf_GET BCM56504_A0_MMU_XQ15m_EMIRRORf_GET
#define MMU_XQ15m_EMIRRORf_SET BCM56504_A0_MMU_XQ15m_EMIRRORf_SET
#define READ_MMU_XQ15m BCM56504_A0_READ_MMU_XQ15m
#define WRITE_MMU_XQ15m BCM56504_A0_WRITE_MMU_XQ15m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MMU_XQ15m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  MMU_XQ16
 * BLOCKS:   MMU
 * DESC:     XQ16
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     L3IPMC           L3 IP multicast Flag
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56504_A0_MMU_XQ16m 0x0b640000

#define BCM56504_A0_MMU_XQ16m_MIN 0
#define BCM56504_A0_MMU_XQ16m_MAX 2047
#define BCM56504_A0_MMU_XQ16m_CMAX(u) 2047
#define BCM56504_A0_MMU_XQ16m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ16.
 *
 */
typedef union BCM56504_A0_MMU_XQ16m_s {
	uint32_t v[1];
	uint32_t mmu_xq16[1];
	uint32_t _mmu_xq16;
} BCM56504_A0_MMU_XQ16m_t;

#define BCM56504_A0_MMU_XQ16m_CLR(r) (r).mmu_xq16[0] = 0
#define BCM56504_A0_MMU_XQ16m_SET(r,d) (r).mmu_xq16[0] = d
#define BCM56504_A0_MMU_XQ16m_GET(r) (r).mmu_xq16[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MMU_XQ16m_PARITY_0f_GET(r) (((r).mmu_xq16[0]) & 0x1)
#define BCM56504_A0_MMU_XQ16m_PARITY_0f_SET(r,f) (r).mmu_xq16[0]=(((r).mmu_xq16[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_MMU_XQ16m_L2f_GET(r) ((((r).mmu_xq16[0]) >> 1) & 0x1)
#define BCM56504_A0_MMU_XQ16m_L2f_SET(r,f) (r).mmu_xq16[0]=(((r).mmu_xq16[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_MMU_XQ16m_PURGEf_GET(r) ((((r).mmu_xq16[0]) >> 2) & 0x1)
#define BCM56504_A0_MMU_XQ16m_PURGEf_SET(r,f) (r).mmu_xq16[0]=(((r).mmu_xq16[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_MMU_XQ16m_PKT_PTRf_GET(r) ((((r).mmu_xq16[0]) >> 3) & 0x3fff)
#define BCM56504_A0_MMU_XQ16m_PKT_PTRf_SET(r,f) (r).mmu_xq16[0]=(((r).mmu_xq16[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56504_A0_MMU_XQ16m_L3IPMCf_GET(r) ((((r).mmu_xq16[0]) >> 17) & 0x1)
#define BCM56504_A0_MMU_XQ16m_L3IPMCf_SET(r,f) (r).mmu_xq16[0]=(((r).mmu_xq16[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56504_A0_MMU_XQ16m_IMIRRORf_GET(r) ((((r).mmu_xq16[0]) >> 18) & 0x1)
#define BCM56504_A0_MMU_XQ16m_IMIRRORf_SET(r,f) (r).mmu_xq16[0]=(((r).mmu_xq16[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56504_A0_MMU_XQ16m_EMIRRORf_GET(r) ((((r).mmu_xq16[0]) >> 19) & 0x1)
#define BCM56504_A0_MMU_XQ16m_EMIRRORf_SET(r,f) (r).mmu_xq16[0]=(((r).mmu_xq16[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ16.
 *
 */
#define BCM56504_A0_READ_MMU_XQ16m(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_MMU_XQ16m,i,(m._mmu_xq16),1)
#define BCM56504_A0_WRITE_MMU_XQ16m(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_MMU_XQ16m,i,&(m._mmu_xq16),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ16m BCM56504_A0_MMU_XQ16m
#define MMU_XQ16m_MIN BCM56504_A0_MMU_XQ16m_MIN
#define MMU_XQ16m_MAX BCM56504_A0_MMU_XQ16m_MAX
#define MMU_XQ16m_CMAX(u) BCM56504_A0_MMU_XQ16m_CMAX(u)
#define MMU_XQ16m_SIZE BCM56504_A0_MMU_XQ16m_SIZE
typedef BCM56504_A0_MMU_XQ16m_t MMU_XQ16m_t;
#define MMU_XQ16m_CLR BCM56504_A0_MMU_XQ16m_CLR
#define MMU_XQ16m_SET BCM56504_A0_MMU_XQ16m_SET
#define MMU_XQ16m_GET BCM56504_A0_MMU_XQ16m_GET
#define MMU_XQ16m_PARITY_0f_GET BCM56504_A0_MMU_XQ16m_PARITY_0f_GET
#define MMU_XQ16m_PARITY_0f_SET BCM56504_A0_MMU_XQ16m_PARITY_0f_SET
#define MMU_XQ16m_L2f_GET BCM56504_A0_MMU_XQ16m_L2f_GET
#define MMU_XQ16m_L2f_SET BCM56504_A0_MMU_XQ16m_L2f_SET
#define MMU_XQ16m_PURGEf_GET BCM56504_A0_MMU_XQ16m_PURGEf_GET
#define MMU_XQ16m_PURGEf_SET BCM56504_A0_MMU_XQ16m_PURGEf_SET
#define MMU_XQ16m_PKT_PTRf_GET BCM56504_A0_MMU_XQ16m_PKT_PTRf_GET
#define MMU_XQ16m_PKT_PTRf_SET BCM56504_A0_MMU_XQ16m_PKT_PTRf_SET
#define MMU_XQ16m_L3IPMCf_GET BCM56504_A0_MMU_XQ16m_L3IPMCf_GET
#define MMU_XQ16m_L3IPMCf_SET BCM56504_A0_MMU_XQ16m_L3IPMCf_SET
#define MMU_XQ16m_IMIRRORf_GET BCM56504_A0_MMU_XQ16m_IMIRRORf_GET
#define MMU_XQ16m_IMIRRORf_SET BCM56504_A0_MMU_XQ16m_IMIRRORf_SET
#define MMU_XQ16m_EMIRRORf_GET BCM56504_A0_MMU_XQ16m_EMIRRORf_GET
#define MMU_XQ16m_EMIRRORf_SET BCM56504_A0_MMU_XQ16m_EMIRRORf_SET
#define READ_MMU_XQ16m BCM56504_A0_READ_MMU_XQ16m
#define WRITE_MMU_XQ16m BCM56504_A0_WRITE_MMU_XQ16m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MMU_XQ16m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  MMU_XQ17
 * BLOCKS:   MMU
 * DESC:     XQ17
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     L3IPMC           L3 IP multicast Flag
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56504_A0_MMU_XQ17m 0x0b644000

#define BCM56504_A0_MMU_XQ17m_MIN 0
#define BCM56504_A0_MMU_XQ17m_MAX 2047
#define BCM56504_A0_MMU_XQ17m_CMAX(u) 2047
#define BCM56504_A0_MMU_XQ17m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ17.
 *
 */
typedef union BCM56504_A0_MMU_XQ17m_s {
	uint32_t v[1];
	uint32_t mmu_xq17[1];
	uint32_t _mmu_xq17;
} BCM56504_A0_MMU_XQ17m_t;

#define BCM56504_A0_MMU_XQ17m_CLR(r) (r).mmu_xq17[0] = 0
#define BCM56504_A0_MMU_XQ17m_SET(r,d) (r).mmu_xq17[0] = d
#define BCM56504_A0_MMU_XQ17m_GET(r) (r).mmu_xq17[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MMU_XQ17m_PARITY_0f_GET(r) (((r).mmu_xq17[0]) & 0x1)
#define BCM56504_A0_MMU_XQ17m_PARITY_0f_SET(r,f) (r).mmu_xq17[0]=(((r).mmu_xq17[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_MMU_XQ17m_L2f_GET(r) ((((r).mmu_xq17[0]) >> 1) & 0x1)
#define BCM56504_A0_MMU_XQ17m_L2f_SET(r,f) (r).mmu_xq17[0]=(((r).mmu_xq17[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_MMU_XQ17m_PURGEf_GET(r) ((((r).mmu_xq17[0]) >> 2) & 0x1)
#define BCM56504_A0_MMU_XQ17m_PURGEf_SET(r,f) (r).mmu_xq17[0]=(((r).mmu_xq17[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_MMU_XQ17m_PKT_PTRf_GET(r) ((((r).mmu_xq17[0]) >> 3) & 0x3fff)
#define BCM56504_A0_MMU_XQ17m_PKT_PTRf_SET(r,f) (r).mmu_xq17[0]=(((r).mmu_xq17[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56504_A0_MMU_XQ17m_L3IPMCf_GET(r) ((((r).mmu_xq17[0]) >> 17) & 0x1)
#define BCM56504_A0_MMU_XQ17m_L3IPMCf_SET(r,f) (r).mmu_xq17[0]=(((r).mmu_xq17[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56504_A0_MMU_XQ17m_IMIRRORf_GET(r) ((((r).mmu_xq17[0]) >> 18) & 0x1)
#define BCM56504_A0_MMU_XQ17m_IMIRRORf_SET(r,f) (r).mmu_xq17[0]=(((r).mmu_xq17[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56504_A0_MMU_XQ17m_EMIRRORf_GET(r) ((((r).mmu_xq17[0]) >> 19) & 0x1)
#define BCM56504_A0_MMU_XQ17m_EMIRRORf_SET(r,f) (r).mmu_xq17[0]=(((r).mmu_xq17[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ17.
 *
 */
#define BCM56504_A0_READ_MMU_XQ17m(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_MMU_XQ17m,i,(m._mmu_xq17),1)
#define BCM56504_A0_WRITE_MMU_XQ17m(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_MMU_XQ17m,i,&(m._mmu_xq17),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ17m BCM56504_A0_MMU_XQ17m
#define MMU_XQ17m_MIN BCM56504_A0_MMU_XQ17m_MIN
#define MMU_XQ17m_MAX BCM56504_A0_MMU_XQ17m_MAX
#define MMU_XQ17m_CMAX(u) BCM56504_A0_MMU_XQ17m_CMAX(u)
#define MMU_XQ17m_SIZE BCM56504_A0_MMU_XQ17m_SIZE
typedef BCM56504_A0_MMU_XQ17m_t MMU_XQ17m_t;
#define MMU_XQ17m_CLR BCM56504_A0_MMU_XQ17m_CLR
#define MMU_XQ17m_SET BCM56504_A0_MMU_XQ17m_SET
#define MMU_XQ17m_GET BCM56504_A0_MMU_XQ17m_GET
#define MMU_XQ17m_PARITY_0f_GET BCM56504_A0_MMU_XQ17m_PARITY_0f_GET
#define MMU_XQ17m_PARITY_0f_SET BCM56504_A0_MMU_XQ17m_PARITY_0f_SET
#define MMU_XQ17m_L2f_GET BCM56504_A0_MMU_XQ17m_L2f_GET
#define MMU_XQ17m_L2f_SET BCM56504_A0_MMU_XQ17m_L2f_SET
#define MMU_XQ17m_PURGEf_GET BCM56504_A0_MMU_XQ17m_PURGEf_GET
#define MMU_XQ17m_PURGEf_SET BCM56504_A0_MMU_XQ17m_PURGEf_SET
#define MMU_XQ17m_PKT_PTRf_GET BCM56504_A0_MMU_XQ17m_PKT_PTRf_GET
#define MMU_XQ17m_PKT_PTRf_SET BCM56504_A0_MMU_XQ17m_PKT_PTRf_SET
#define MMU_XQ17m_L3IPMCf_GET BCM56504_A0_MMU_XQ17m_L3IPMCf_GET
#define MMU_XQ17m_L3IPMCf_SET BCM56504_A0_MMU_XQ17m_L3IPMCf_SET
#define MMU_XQ17m_IMIRRORf_GET BCM56504_A0_MMU_XQ17m_IMIRRORf_GET
#define MMU_XQ17m_IMIRRORf_SET BCM56504_A0_MMU_XQ17m_IMIRRORf_SET
#define MMU_XQ17m_EMIRRORf_GET BCM56504_A0_MMU_XQ17m_EMIRRORf_GET
#define MMU_XQ17m_EMIRRORf_SET BCM56504_A0_MMU_XQ17m_EMIRRORf_SET
#define READ_MMU_XQ17m BCM56504_A0_READ_MMU_XQ17m
#define WRITE_MMU_XQ17m BCM56504_A0_WRITE_MMU_XQ17m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MMU_XQ17m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  MMU_XQ18
 * BLOCKS:   MMU
 * DESC:     XQ18
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     L3IPMC           L3 IP multicast Flag
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56504_A0_MMU_XQ18m 0x0b648000

#define BCM56504_A0_MMU_XQ18m_MIN 0
#define BCM56504_A0_MMU_XQ18m_MAX 2047
#define BCM56504_A0_MMU_XQ18m_CMAX(u) 2047
#define BCM56504_A0_MMU_XQ18m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ18.
 *
 */
typedef union BCM56504_A0_MMU_XQ18m_s {
	uint32_t v[1];
	uint32_t mmu_xq18[1];
	uint32_t _mmu_xq18;
} BCM56504_A0_MMU_XQ18m_t;

#define BCM56504_A0_MMU_XQ18m_CLR(r) (r).mmu_xq18[0] = 0
#define BCM56504_A0_MMU_XQ18m_SET(r,d) (r).mmu_xq18[0] = d
#define BCM56504_A0_MMU_XQ18m_GET(r) (r).mmu_xq18[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MMU_XQ18m_PARITY_0f_GET(r) (((r).mmu_xq18[0]) & 0x1)
#define BCM56504_A0_MMU_XQ18m_PARITY_0f_SET(r,f) (r).mmu_xq18[0]=(((r).mmu_xq18[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_MMU_XQ18m_L2f_GET(r) ((((r).mmu_xq18[0]) >> 1) & 0x1)
#define BCM56504_A0_MMU_XQ18m_L2f_SET(r,f) (r).mmu_xq18[0]=(((r).mmu_xq18[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_MMU_XQ18m_PURGEf_GET(r) ((((r).mmu_xq18[0]) >> 2) & 0x1)
#define BCM56504_A0_MMU_XQ18m_PURGEf_SET(r,f) (r).mmu_xq18[0]=(((r).mmu_xq18[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_MMU_XQ18m_PKT_PTRf_GET(r) ((((r).mmu_xq18[0]) >> 3) & 0x3fff)
#define BCM56504_A0_MMU_XQ18m_PKT_PTRf_SET(r,f) (r).mmu_xq18[0]=(((r).mmu_xq18[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56504_A0_MMU_XQ18m_L3IPMCf_GET(r) ((((r).mmu_xq18[0]) >> 17) & 0x1)
#define BCM56504_A0_MMU_XQ18m_L3IPMCf_SET(r,f) (r).mmu_xq18[0]=(((r).mmu_xq18[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56504_A0_MMU_XQ18m_IMIRRORf_GET(r) ((((r).mmu_xq18[0]) >> 18) & 0x1)
#define BCM56504_A0_MMU_XQ18m_IMIRRORf_SET(r,f) (r).mmu_xq18[0]=(((r).mmu_xq18[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56504_A0_MMU_XQ18m_EMIRRORf_GET(r) ((((r).mmu_xq18[0]) >> 19) & 0x1)
#define BCM56504_A0_MMU_XQ18m_EMIRRORf_SET(r,f) (r).mmu_xq18[0]=(((r).mmu_xq18[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ18.
 *
 */
#define BCM56504_A0_READ_MMU_XQ18m(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_MMU_XQ18m,i,(m._mmu_xq18),1)
#define BCM56504_A0_WRITE_MMU_XQ18m(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_MMU_XQ18m,i,&(m._mmu_xq18),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ18m BCM56504_A0_MMU_XQ18m
#define MMU_XQ18m_MIN BCM56504_A0_MMU_XQ18m_MIN
#define MMU_XQ18m_MAX BCM56504_A0_MMU_XQ18m_MAX
#define MMU_XQ18m_CMAX(u) BCM56504_A0_MMU_XQ18m_CMAX(u)
#define MMU_XQ18m_SIZE BCM56504_A0_MMU_XQ18m_SIZE
typedef BCM56504_A0_MMU_XQ18m_t MMU_XQ18m_t;
#define MMU_XQ18m_CLR BCM56504_A0_MMU_XQ18m_CLR
#define MMU_XQ18m_SET BCM56504_A0_MMU_XQ18m_SET
#define MMU_XQ18m_GET BCM56504_A0_MMU_XQ18m_GET
#define MMU_XQ18m_PARITY_0f_GET BCM56504_A0_MMU_XQ18m_PARITY_0f_GET
#define MMU_XQ18m_PARITY_0f_SET BCM56504_A0_MMU_XQ18m_PARITY_0f_SET
#define MMU_XQ18m_L2f_GET BCM56504_A0_MMU_XQ18m_L2f_GET
#define MMU_XQ18m_L2f_SET BCM56504_A0_MMU_XQ18m_L2f_SET
#define MMU_XQ18m_PURGEf_GET BCM56504_A0_MMU_XQ18m_PURGEf_GET
#define MMU_XQ18m_PURGEf_SET BCM56504_A0_MMU_XQ18m_PURGEf_SET
#define MMU_XQ18m_PKT_PTRf_GET BCM56504_A0_MMU_XQ18m_PKT_PTRf_GET
#define MMU_XQ18m_PKT_PTRf_SET BCM56504_A0_MMU_XQ18m_PKT_PTRf_SET
#define MMU_XQ18m_L3IPMCf_GET BCM56504_A0_MMU_XQ18m_L3IPMCf_GET
#define MMU_XQ18m_L3IPMCf_SET BCM56504_A0_MMU_XQ18m_L3IPMCf_SET
#define MMU_XQ18m_IMIRRORf_GET BCM56504_A0_MMU_XQ18m_IMIRRORf_GET
#define MMU_XQ18m_IMIRRORf_SET BCM56504_A0_MMU_XQ18m_IMIRRORf_SET
#define MMU_XQ18m_EMIRRORf_GET BCM56504_A0_MMU_XQ18m_EMIRRORf_GET
#define MMU_XQ18m_EMIRRORf_SET BCM56504_A0_MMU_XQ18m_EMIRRORf_SET
#define READ_MMU_XQ18m BCM56504_A0_READ_MMU_XQ18m
#define WRITE_MMU_XQ18m BCM56504_A0_WRITE_MMU_XQ18m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MMU_XQ18m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  MMU_XQ19
 * BLOCKS:   MMU
 * DESC:     XQ19
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     L3IPMC           L3 IP multicast Flag
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56504_A0_MMU_XQ19m 0x0b64c000

#define BCM56504_A0_MMU_XQ19m_MIN 0
#define BCM56504_A0_MMU_XQ19m_MAX 2047
#define BCM56504_A0_MMU_XQ19m_CMAX(u) 2047
#define BCM56504_A0_MMU_XQ19m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ19.
 *
 */
typedef union BCM56504_A0_MMU_XQ19m_s {
	uint32_t v[1];
	uint32_t mmu_xq19[1];
	uint32_t _mmu_xq19;
} BCM56504_A0_MMU_XQ19m_t;

#define BCM56504_A0_MMU_XQ19m_CLR(r) (r).mmu_xq19[0] = 0
#define BCM56504_A0_MMU_XQ19m_SET(r,d) (r).mmu_xq19[0] = d
#define BCM56504_A0_MMU_XQ19m_GET(r) (r).mmu_xq19[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MMU_XQ19m_PARITY_0f_GET(r) (((r).mmu_xq19[0]) & 0x1)
#define BCM56504_A0_MMU_XQ19m_PARITY_0f_SET(r,f) (r).mmu_xq19[0]=(((r).mmu_xq19[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_MMU_XQ19m_L2f_GET(r) ((((r).mmu_xq19[0]) >> 1) & 0x1)
#define BCM56504_A0_MMU_XQ19m_L2f_SET(r,f) (r).mmu_xq19[0]=(((r).mmu_xq19[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_MMU_XQ19m_PURGEf_GET(r) ((((r).mmu_xq19[0]) >> 2) & 0x1)
#define BCM56504_A0_MMU_XQ19m_PURGEf_SET(r,f) (r).mmu_xq19[0]=(((r).mmu_xq19[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_MMU_XQ19m_PKT_PTRf_GET(r) ((((r).mmu_xq19[0]) >> 3) & 0x3fff)
#define BCM56504_A0_MMU_XQ19m_PKT_PTRf_SET(r,f) (r).mmu_xq19[0]=(((r).mmu_xq19[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56504_A0_MMU_XQ19m_L3IPMCf_GET(r) ((((r).mmu_xq19[0]) >> 17) & 0x1)
#define BCM56504_A0_MMU_XQ19m_L3IPMCf_SET(r,f) (r).mmu_xq19[0]=(((r).mmu_xq19[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56504_A0_MMU_XQ19m_IMIRRORf_GET(r) ((((r).mmu_xq19[0]) >> 18) & 0x1)
#define BCM56504_A0_MMU_XQ19m_IMIRRORf_SET(r,f) (r).mmu_xq19[0]=(((r).mmu_xq19[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56504_A0_MMU_XQ19m_EMIRRORf_GET(r) ((((r).mmu_xq19[0]) >> 19) & 0x1)
#define BCM56504_A0_MMU_XQ19m_EMIRRORf_SET(r,f) (r).mmu_xq19[0]=(((r).mmu_xq19[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ19.
 *
 */
#define BCM56504_A0_READ_MMU_XQ19m(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_MMU_XQ19m,i,(m._mmu_xq19),1)
#define BCM56504_A0_WRITE_MMU_XQ19m(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_MMU_XQ19m,i,&(m._mmu_xq19),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ19m BCM56504_A0_MMU_XQ19m
#define MMU_XQ19m_MIN BCM56504_A0_MMU_XQ19m_MIN
#define MMU_XQ19m_MAX BCM56504_A0_MMU_XQ19m_MAX
#define MMU_XQ19m_CMAX(u) BCM56504_A0_MMU_XQ19m_CMAX(u)
#define MMU_XQ19m_SIZE BCM56504_A0_MMU_XQ19m_SIZE
typedef BCM56504_A0_MMU_XQ19m_t MMU_XQ19m_t;
#define MMU_XQ19m_CLR BCM56504_A0_MMU_XQ19m_CLR
#define MMU_XQ19m_SET BCM56504_A0_MMU_XQ19m_SET
#define MMU_XQ19m_GET BCM56504_A0_MMU_XQ19m_GET
#define MMU_XQ19m_PARITY_0f_GET BCM56504_A0_MMU_XQ19m_PARITY_0f_GET
#define MMU_XQ19m_PARITY_0f_SET BCM56504_A0_MMU_XQ19m_PARITY_0f_SET
#define MMU_XQ19m_L2f_GET BCM56504_A0_MMU_XQ19m_L2f_GET
#define MMU_XQ19m_L2f_SET BCM56504_A0_MMU_XQ19m_L2f_SET
#define MMU_XQ19m_PURGEf_GET BCM56504_A0_MMU_XQ19m_PURGEf_GET
#define MMU_XQ19m_PURGEf_SET BCM56504_A0_MMU_XQ19m_PURGEf_SET
#define MMU_XQ19m_PKT_PTRf_GET BCM56504_A0_MMU_XQ19m_PKT_PTRf_GET
#define MMU_XQ19m_PKT_PTRf_SET BCM56504_A0_MMU_XQ19m_PKT_PTRf_SET
#define MMU_XQ19m_L3IPMCf_GET BCM56504_A0_MMU_XQ19m_L3IPMCf_GET
#define MMU_XQ19m_L3IPMCf_SET BCM56504_A0_MMU_XQ19m_L3IPMCf_SET
#define MMU_XQ19m_IMIRRORf_GET BCM56504_A0_MMU_XQ19m_IMIRRORf_GET
#define MMU_XQ19m_IMIRRORf_SET BCM56504_A0_MMU_XQ19m_IMIRRORf_SET
#define MMU_XQ19m_EMIRRORf_GET BCM56504_A0_MMU_XQ19m_EMIRRORf_GET
#define MMU_XQ19m_EMIRRORf_SET BCM56504_A0_MMU_XQ19m_EMIRRORf_SET
#define READ_MMU_XQ19m BCM56504_A0_READ_MMU_XQ19m
#define WRITE_MMU_XQ19m BCM56504_A0_WRITE_MMU_XQ19m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MMU_XQ19m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  MMU_XQ2
 * BLOCKS:   MMU
 * DESC:     XQ2
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     L3IPMC           L3 IP multicast Flag
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56504_A0_MMU_XQ2m 0x0b608000

#define BCM56504_A0_MMU_XQ2m_MIN 0
#define BCM56504_A0_MMU_XQ2m_MAX 2047
#define BCM56504_A0_MMU_XQ2m_CMAX(u) 2047
#define BCM56504_A0_MMU_XQ2m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ2.
 *
 */
typedef union BCM56504_A0_MMU_XQ2m_s {
	uint32_t v[1];
	uint32_t mmu_xq2[1];
	uint32_t _mmu_xq2;
} BCM56504_A0_MMU_XQ2m_t;

#define BCM56504_A0_MMU_XQ2m_CLR(r) (r).mmu_xq2[0] = 0
#define BCM56504_A0_MMU_XQ2m_SET(r,d) (r).mmu_xq2[0] = d
#define BCM56504_A0_MMU_XQ2m_GET(r) (r).mmu_xq2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MMU_XQ2m_PARITY_0f_GET(r) (((r).mmu_xq2[0]) & 0x1)
#define BCM56504_A0_MMU_XQ2m_PARITY_0f_SET(r,f) (r).mmu_xq2[0]=(((r).mmu_xq2[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_MMU_XQ2m_L2f_GET(r) ((((r).mmu_xq2[0]) >> 1) & 0x1)
#define BCM56504_A0_MMU_XQ2m_L2f_SET(r,f) (r).mmu_xq2[0]=(((r).mmu_xq2[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_MMU_XQ2m_PURGEf_GET(r) ((((r).mmu_xq2[0]) >> 2) & 0x1)
#define BCM56504_A0_MMU_XQ2m_PURGEf_SET(r,f) (r).mmu_xq2[0]=(((r).mmu_xq2[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_MMU_XQ2m_PKT_PTRf_GET(r) ((((r).mmu_xq2[0]) >> 3) & 0x3fff)
#define BCM56504_A0_MMU_XQ2m_PKT_PTRf_SET(r,f) (r).mmu_xq2[0]=(((r).mmu_xq2[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56504_A0_MMU_XQ2m_L3IPMCf_GET(r) ((((r).mmu_xq2[0]) >> 17) & 0x1)
#define BCM56504_A0_MMU_XQ2m_L3IPMCf_SET(r,f) (r).mmu_xq2[0]=(((r).mmu_xq2[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56504_A0_MMU_XQ2m_IMIRRORf_GET(r) ((((r).mmu_xq2[0]) >> 18) & 0x1)
#define BCM56504_A0_MMU_XQ2m_IMIRRORf_SET(r,f) (r).mmu_xq2[0]=(((r).mmu_xq2[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56504_A0_MMU_XQ2m_EMIRRORf_GET(r) ((((r).mmu_xq2[0]) >> 19) & 0x1)
#define BCM56504_A0_MMU_XQ2m_EMIRRORf_SET(r,f) (r).mmu_xq2[0]=(((r).mmu_xq2[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ2.
 *
 */
#define BCM56504_A0_READ_MMU_XQ2m(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_MMU_XQ2m,i,(m._mmu_xq2),1)
#define BCM56504_A0_WRITE_MMU_XQ2m(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_MMU_XQ2m,i,&(m._mmu_xq2),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ2m BCM56504_A0_MMU_XQ2m
#define MMU_XQ2m_MIN BCM56504_A0_MMU_XQ2m_MIN
#define MMU_XQ2m_MAX BCM56504_A0_MMU_XQ2m_MAX
#define MMU_XQ2m_CMAX(u) BCM56504_A0_MMU_XQ2m_CMAX(u)
#define MMU_XQ2m_SIZE BCM56504_A0_MMU_XQ2m_SIZE
typedef BCM56504_A0_MMU_XQ2m_t MMU_XQ2m_t;
#define MMU_XQ2m_CLR BCM56504_A0_MMU_XQ2m_CLR
#define MMU_XQ2m_SET BCM56504_A0_MMU_XQ2m_SET
#define MMU_XQ2m_GET BCM56504_A0_MMU_XQ2m_GET
#define MMU_XQ2m_PARITY_0f_GET BCM56504_A0_MMU_XQ2m_PARITY_0f_GET
#define MMU_XQ2m_PARITY_0f_SET BCM56504_A0_MMU_XQ2m_PARITY_0f_SET
#define MMU_XQ2m_L2f_GET BCM56504_A0_MMU_XQ2m_L2f_GET
#define MMU_XQ2m_L2f_SET BCM56504_A0_MMU_XQ2m_L2f_SET
#define MMU_XQ2m_PURGEf_GET BCM56504_A0_MMU_XQ2m_PURGEf_GET
#define MMU_XQ2m_PURGEf_SET BCM56504_A0_MMU_XQ2m_PURGEf_SET
#define MMU_XQ2m_PKT_PTRf_GET BCM56504_A0_MMU_XQ2m_PKT_PTRf_GET
#define MMU_XQ2m_PKT_PTRf_SET BCM56504_A0_MMU_XQ2m_PKT_PTRf_SET
#define MMU_XQ2m_L3IPMCf_GET BCM56504_A0_MMU_XQ2m_L3IPMCf_GET
#define MMU_XQ2m_L3IPMCf_SET BCM56504_A0_MMU_XQ2m_L3IPMCf_SET
#define MMU_XQ2m_IMIRRORf_GET BCM56504_A0_MMU_XQ2m_IMIRRORf_GET
#define MMU_XQ2m_IMIRRORf_SET BCM56504_A0_MMU_XQ2m_IMIRRORf_SET
#define MMU_XQ2m_EMIRRORf_GET BCM56504_A0_MMU_XQ2m_EMIRRORf_GET
#define MMU_XQ2m_EMIRRORf_SET BCM56504_A0_MMU_XQ2m_EMIRRORf_SET
#define READ_MMU_XQ2m BCM56504_A0_READ_MMU_XQ2m
#define WRITE_MMU_XQ2m BCM56504_A0_WRITE_MMU_XQ2m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MMU_XQ2m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  MMU_XQ20
 * BLOCKS:   MMU
 * DESC:     XQ20
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     L3IPMC           L3 IP multicast Flag
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56504_A0_MMU_XQ20m 0x0b650000

#define BCM56504_A0_MMU_XQ20m_MIN 0
#define BCM56504_A0_MMU_XQ20m_MAX 2047
#define BCM56504_A0_MMU_XQ20m_CMAX(u) 2047
#define BCM56504_A0_MMU_XQ20m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ20.
 *
 */
typedef union BCM56504_A0_MMU_XQ20m_s {
	uint32_t v[1];
	uint32_t mmu_xq20[1];
	uint32_t _mmu_xq20;
} BCM56504_A0_MMU_XQ20m_t;

#define BCM56504_A0_MMU_XQ20m_CLR(r) (r).mmu_xq20[0] = 0
#define BCM56504_A0_MMU_XQ20m_SET(r,d) (r).mmu_xq20[0] = d
#define BCM56504_A0_MMU_XQ20m_GET(r) (r).mmu_xq20[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MMU_XQ20m_PARITY_0f_GET(r) (((r).mmu_xq20[0]) & 0x1)
#define BCM56504_A0_MMU_XQ20m_PARITY_0f_SET(r,f) (r).mmu_xq20[0]=(((r).mmu_xq20[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_MMU_XQ20m_L2f_GET(r) ((((r).mmu_xq20[0]) >> 1) & 0x1)
#define BCM56504_A0_MMU_XQ20m_L2f_SET(r,f) (r).mmu_xq20[0]=(((r).mmu_xq20[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_MMU_XQ20m_PURGEf_GET(r) ((((r).mmu_xq20[0]) >> 2) & 0x1)
#define BCM56504_A0_MMU_XQ20m_PURGEf_SET(r,f) (r).mmu_xq20[0]=(((r).mmu_xq20[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_MMU_XQ20m_PKT_PTRf_GET(r) ((((r).mmu_xq20[0]) >> 3) & 0x3fff)
#define BCM56504_A0_MMU_XQ20m_PKT_PTRf_SET(r,f) (r).mmu_xq20[0]=(((r).mmu_xq20[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56504_A0_MMU_XQ20m_L3IPMCf_GET(r) ((((r).mmu_xq20[0]) >> 17) & 0x1)
#define BCM56504_A0_MMU_XQ20m_L3IPMCf_SET(r,f) (r).mmu_xq20[0]=(((r).mmu_xq20[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56504_A0_MMU_XQ20m_IMIRRORf_GET(r) ((((r).mmu_xq20[0]) >> 18) & 0x1)
#define BCM56504_A0_MMU_XQ20m_IMIRRORf_SET(r,f) (r).mmu_xq20[0]=(((r).mmu_xq20[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56504_A0_MMU_XQ20m_EMIRRORf_GET(r) ((((r).mmu_xq20[0]) >> 19) & 0x1)
#define BCM56504_A0_MMU_XQ20m_EMIRRORf_SET(r,f) (r).mmu_xq20[0]=(((r).mmu_xq20[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ20.
 *
 */
#define BCM56504_A0_READ_MMU_XQ20m(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_MMU_XQ20m,i,(m._mmu_xq20),1)
#define BCM56504_A0_WRITE_MMU_XQ20m(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_MMU_XQ20m,i,&(m._mmu_xq20),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ20m BCM56504_A0_MMU_XQ20m
#define MMU_XQ20m_MIN BCM56504_A0_MMU_XQ20m_MIN
#define MMU_XQ20m_MAX BCM56504_A0_MMU_XQ20m_MAX
#define MMU_XQ20m_CMAX(u) BCM56504_A0_MMU_XQ20m_CMAX(u)
#define MMU_XQ20m_SIZE BCM56504_A0_MMU_XQ20m_SIZE
typedef BCM56504_A0_MMU_XQ20m_t MMU_XQ20m_t;
#define MMU_XQ20m_CLR BCM56504_A0_MMU_XQ20m_CLR
#define MMU_XQ20m_SET BCM56504_A0_MMU_XQ20m_SET
#define MMU_XQ20m_GET BCM56504_A0_MMU_XQ20m_GET
#define MMU_XQ20m_PARITY_0f_GET BCM56504_A0_MMU_XQ20m_PARITY_0f_GET
#define MMU_XQ20m_PARITY_0f_SET BCM56504_A0_MMU_XQ20m_PARITY_0f_SET
#define MMU_XQ20m_L2f_GET BCM56504_A0_MMU_XQ20m_L2f_GET
#define MMU_XQ20m_L2f_SET BCM56504_A0_MMU_XQ20m_L2f_SET
#define MMU_XQ20m_PURGEf_GET BCM56504_A0_MMU_XQ20m_PURGEf_GET
#define MMU_XQ20m_PURGEf_SET BCM56504_A0_MMU_XQ20m_PURGEf_SET
#define MMU_XQ20m_PKT_PTRf_GET BCM56504_A0_MMU_XQ20m_PKT_PTRf_GET
#define MMU_XQ20m_PKT_PTRf_SET BCM56504_A0_MMU_XQ20m_PKT_PTRf_SET
#define MMU_XQ20m_L3IPMCf_GET BCM56504_A0_MMU_XQ20m_L3IPMCf_GET
#define MMU_XQ20m_L3IPMCf_SET BCM56504_A0_MMU_XQ20m_L3IPMCf_SET
#define MMU_XQ20m_IMIRRORf_GET BCM56504_A0_MMU_XQ20m_IMIRRORf_GET
#define MMU_XQ20m_IMIRRORf_SET BCM56504_A0_MMU_XQ20m_IMIRRORf_SET
#define MMU_XQ20m_EMIRRORf_GET BCM56504_A0_MMU_XQ20m_EMIRRORf_GET
#define MMU_XQ20m_EMIRRORf_SET BCM56504_A0_MMU_XQ20m_EMIRRORf_SET
#define READ_MMU_XQ20m BCM56504_A0_READ_MMU_XQ20m
#define WRITE_MMU_XQ20m BCM56504_A0_WRITE_MMU_XQ20m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MMU_XQ20m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  MMU_XQ21
 * BLOCKS:   MMU
 * DESC:     XQ21
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     L3IPMC           L3 IP multicast Flag
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56504_A0_MMU_XQ21m 0x0b654000

#define BCM56504_A0_MMU_XQ21m_MIN 0
#define BCM56504_A0_MMU_XQ21m_MAX 2047
#define BCM56504_A0_MMU_XQ21m_CMAX(u) 2047
#define BCM56504_A0_MMU_XQ21m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ21.
 *
 */
typedef union BCM56504_A0_MMU_XQ21m_s {
	uint32_t v[1];
	uint32_t mmu_xq21[1];
	uint32_t _mmu_xq21;
} BCM56504_A0_MMU_XQ21m_t;

#define BCM56504_A0_MMU_XQ21m_CLR(r) (r).mmu_xq21[0] = 0
#define BCM56504_A0_MMU_XQ21m_SET(r,d) (r).mmu_xq21[0] = d
#define BCM56504_A0_MMU_XQ21m_GET(r) (r).mmu_xq21[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MMU_XQ21m_PARITY_0f_GET(r) (((r).mmu_xq21[0]) & 0x1)
#define BCM56504_A0_MMU_XQ21m_PARITY_0f_SET(r,f) (r).mmu_xq21[0]=(((r).mmu_xq21[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_MMU_XQ21m_L2f_GET(r) ((((r).mmu_xq21[0]) >> 1) & 0x1)
#define BCM56504_A0_MMU_XQ21m_L2f_SET(r,f) (r).mmu_xq21[0]=(((r).mmu_xq21[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_MMU_XQ21m_PURGEf_GET(r) ((((r).mmu_xq21[0]) >> 2) & 0x1)
#define BCM56504_A0_MMU_XQ21m_PURGEf_SET(r,f) (r).mmu_xq21[0]=(((r).mmu_xq21[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_MMU_XQ21m_PKT_PTRf_GET(r) ((((r).mmu_xq21[0]) >> 3) & 0x3fff)
#define BCM56504_A0_MMU_XQ21m_PKT_PTRf_SET(r,f) (r).mmu_xq21[0]=(((r).mmu_xq21[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56504_A0_MMU_XQ21m_L3IPMCf_GET(r) ((((r).mmu_xq21[0]) >> 17) & 0x1)
#define BCM56504_A0_MMU_XQ21m_L3IPMCf_SET(r,f) (r).mmu_xq21[0]=(((r).mmu_xq21[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56504_A0_MMU_XQ21m_IMIRRORf_GET(r) ((((r).mmu_xq21[0]) >> 18) & 0x1)
#define BCM56504_A0_MMU_XQ21m_IMIRRORf_SET(r,f) (r).mmu_xq21[0]=(((r).mmu_xq21[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56504_A0_MMU_XQ21m_EMIRRORf_GET(r) ((((r).mmu_xq21[0]) >> 19) & 0x1)
#define BCM56504_A0_MMU_XQ21m_EMIRRORf_SET(r,f) (r).mmu_xq21[0]=(((r).mmu_xq21[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ21.
 *
 */
#define BCM56504_A0_READ_MMU_XQ21m(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_MMU_XQ21m,i,(m._mmu_xq21),1)
#define BCM56504_A0_WRITE_MMU_XQ21m(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_MMU_XQ21m,i,&(m._mmu_xq21),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ21m BCM56504_A0_MMU_XQ21m
#define MMU_XQ21m_MIN BCM56504_A0_MMU_XQ21m_MIN
#define MMU_XQ21m_MAX BCM56504_A0_MMU_XQ21m_MAX
#define MMU_XQ21m_CMAX(u) BCM56504_A0_MMU_XQ21m_CMAX(u)
#define MMU_XQ21m_SIZE BCM56504_A0_MMU_XQ21m_SIZE
typedef BCM56504_A0_MMU_XQ21m_t MMU_XQ21m_t;
#define MMU_XQ21m_CLR BCM56504_A0_MMU_XQ21m_CLR
#define MMU_XQ21m_SET BCM56504_A0_MMU_XQ21m_SET
#define MMU_XQ21m_GET BCM56504_A0_MMU_XQ21m_GET
#define MMU_XQ21m_PARITY_0f_GET BCM56504_A0_MMU_XQ21m_PARITY_0f_GET
#define MMU_XQ21m_PARITY_0f_SET BCM56504_A0_MMU_XQ21m_PARITY_0f_SET
#define MMU_XQ21m_L2f_GET BCM56504_A0_MMU_XQ21m_L2f_GET
#define MMU_XQ21m_L2f_SET BCM56504_A0_MMU_XQ21m_L2f_SET
#define MMU_XQ21m_PURGEf_GET BCM56504_A0_MMU_XQ21m_PURGEf_GET
#define MMU_XQ21m_PURGEf_SET BCM56504_A0_MMU_XQ21m_PURGEf_SET
#define MMU_XQ21m_PKT_PTRf_GET BCM56504_A0_MMU_XQ21m_PKT_PTRf_GET
#define MMU_XQ21m_PKT_PTRf_SET BCM56504_A0_MMU_XQ21m_PKT_PTRf_SET
#define MMU_XQ21m_L3IPMCf_GET BCM56504_A0_MMU_XQ21m_L3IPMCf_GET
#define MMU_XQ21m_L3IPMCf_SET BCM56504_A0_MMU_XQ21m_L3IPMCf_SET
#define MMU_XQ21m_IMIRRORf_GET BCM56504_A0_MMU_XQ21m_IMIRRORf_GET
#define MMU_XQ21m_IMIRRORf_SET BCM56504_A0_MMU_XQ21m_IMIRRORf_SET
#define MMU_XQ21m_EMIRRORf_GET BCM56504_A0_MMU_XQ21m_EMIRRORf_GET
#define MMU_XQ21m_EMIRRORf_SET BCM56504_A0_MMU_XQ21m_EMIRRORf_SET
#define READ_MMU_XQ21m BCM56504_A0_READ_MMU_XQ21m
#define WRITE_MMU_XQ21m BCM56504_A0_WRITE_MMU_XQ21m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MMU_XQ21m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  MMU_XQ22
 * BLOCKS:   MMU
 * DESC:     XQ22
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     L3IPMC           L3 IP multicast Flag
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56504_A0_MMU_XQ22m 0x0b658000

#define BCM56504_A0_MMU_XQ22m_MIN 0
#define BCM56504_A0_MMU_XQ22m_MAX 2047
#define BCM56504_A0_MMU_XQ22m_CMAX(u) 2047
#define BCM56504_A0_MMU_XQ22m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ22.
 *
 */
typedef union BCM56504_A0_MMU_XQ22m_s {
	uint32_t v[1];
	uint32_t mmu_xq22[1];
	uint32_t _mmu_xq22;
} BCM56504_A0_MMU_XQ22m_t;

#define BCM56504_A0_MMU_XQ22m_CLR(r) (r).mmu_xq22[0] = 0
#define BCM56504_A0_MMU_XQ22m_SET(r,d) (r).mmu_xq22[0] = d
#define BCM56504_A0_MMU_XQ22m_GET(r) (r).mmu_xq22[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MMU_XQ22m_PARITY_0f_GET(r) (((r).mmu_xq22[0]) & 0x1)
#define BCM56504_A0_MMU_XQ22m_PARITY_0f_SET(r,f) (r).mmu_xq22[0]=(((r).mmu_xq22[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_MMU_XQ22m_L2f_GET(r) ((((r).mmu_xq22[0]) >> 1) & 0x1)
#define BCM56504_A0_MMU_XQ22m_L2f_SET(r,f) (r).mmu_xq22[0]=(((r).mmu_xq22[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_MMU_XQ22m_PURGEf_GET(r) ((((r).mmu_xq22[0]) >> 2) & 0x1)
#define BCM56504_A0_MMU_XQ22m_PURGEf_SET(r,f) (r).mmu_xq22[0]=(((r).mmu_xq22[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_MMU_XQ22m_PKT_PTRf_GET(r) ((((r).mmu_xq22[0]) >> 3) & 0x3fff)
#define BCM56504_A0_MMU_XQ22m_PKT_PTRf_SET(r,f) (r).mmu_xq22[0]=(((r).mmu_xq22[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56504_A0_MMU_XQ22m_L3IPMCf_GET(r) ((((r).mmu_xq22[0]) >> 17) & 0x1)
#define BCM56504_A0_MMU_XQ22m_L3IPMCf_SET(r,f) (r).mmu_xq22[0]=(((r).mmu_xq22[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56504_A0_MMU_XQ22m_IMIRRORf_GET(r) ((((r).mmu_xq22[0]) >> 18) & 0x1)
#define BCM56504_A0_MMU_XQ22m_IMIRRORf_SET(r,f) (r).mmu_xq22[0]=(((r).mmu_xq22[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56504_A0_MMU_XQ22m_EMIRRORf_GET(r) ((((r).mmu_xq22[0]) >> 19) & 0x1)
#define BCM56504_A0_MMU_XQ22m_EMIRRORf_SET(r,f) (r).mmu_xq22[0]=(((r).mmu_xq22[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ22.
 *
 */
#define BCM56504_A0_READ_MMU_XQ22m(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_MMU_XQ22m,i,(m._mmu_xq22),1)
#define BCM56504_A0_WRITE_MMU_XQ22m(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_MMU_XQ22m,i,&(m._mmu_xq22),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ22m BCM56504_A0_MMU_XQ22m
#define MMU_XQ22m_MIN BCM56504_A0_MMU_XQ22m_MIN
#define MMU_XQ22m_MAX BCM56504_A0_MMU_XQ22m_MAX
#define MMU_XQ22m_CMAX(u) BCM56504_A0_MMU_XQ22m_CMAX(u)
#define MMU_XQ22m_SIZE BCM56504_A0_MMU_XQ22m_SIZE
typedef BCM56504_A0_MMU_XQ22m_t MMU_XQ22m_t;
#define MMU_XQ22m_CLR BCM56504_A0_MMU_XQ22m_CLR
#define MMU_XQ22m_SET BCM56504_A0_MMU_XQ22m_SET
#define MMU_XQ22m_GET BCM56504_A0_MMU_XQ22m_GET
#define MMU_XQ22m_PARITY_0f_GET BCM56504_A0_MMU_XQ22m_PARITY_0f_GET
#define MMU_XQ22m_PARITY_0f_SET BCM56504_A0_MMU_XQ22m_PARITY_0f_SET
#define MMU_XQ22m_L2f_GET BCM56504_A0_MMU_XQ22m_L2f_GET
#define MMU_XQ22m_L2f_SET BCM56504_A0_MMU_XQ22m_L2f_SET
#define MMU_XQ22m_PURGEf_GET BCM56504_A0_MMU_XQ22m_PURGEf_GET
#define MMU_XQ22m_PURGEf_SET BCM56504_A0_MMU_XQ22m_PURGEf_SET
#define MMU_XQ22m_PKT_PTRf_GET BCM56504_A0_MMU_XQ22m_PKT_PTRf_GET
#define MMU_XQ22m_PKT_PTRf_SET BCM56504_A0_MMU_XQ22m_PKT_PTRf_SET
#define MMU_XQ22m_L3IPMCf_GET BCM56504_A0_MMU_XQ22m_L3IPMCf_GET
#define MMU_XQ22m_L3IPMCf_SET BCM56504_A0_MMU_XQ22m_L3IPMCf_SET
#define MMU_XQ22m_IMIRRORf_GET BCM56504_A0_MMU_XQ22m_IMIRRORf_GET
#define MMU_XQ22m_IMIRRORf_SET BCM56504_A0_MMU_XQ22m_IMIRRORf_SET
#define MMU_XQ22m_EMIRRORf_GET BCM56504_A0_MMU_XQ22m_EMIRRORf_GET
#define MMU_XQ22m_EMIRRORf_SET BCM56504_A0_MMU_XQ22m_EMIRRORf_SET
#define READ_MMU_XQ22m BCM56504_A0_READ_MMU_XQ22m
#define WRITE_MMU_XQ22m BCM56504_A0_WRITE_MMU_XQ22m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MMU_XQ22m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  MMU_XQ23
 * BLOCKS:   MMU
 * DESC:     XQ23
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     L3IPMC           L3 IP multicast Flag
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56504_A0_MMU_XQ23m 0x0b65c000

#define BCM56504_A0_MMU_XQ23m_MIN 0
#define BCM56504_A0_MMU_XQ23m_MAX 2047
#define BCM56504_A0_MMU_XQ23m_CMAX(u) 2047
#define BCM56504_A0_MMU_XQ23m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ23.
 *
 */
typedef union BCM56504_A0_MMU_XQ23m_s {
	uint32_t v[1];
	uint32_t mmu_xq23[1];
	uint32_t _mmu_xq23;
} BCM56504_A0_MMU_XQ23m_t;

#define BCM56504_A0_MMU_XQ23m_CLR(r) (r).mmu_xq23[0] = 0
#define BCM56504_A0_MMU_XQ23m_SET(r,d) (r).mmu_xq23[0] = d
#define BCM56504_A0_MMU_XQ23m_GET(r) (r).mmu_xq23[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MMU_XQ23m_PARITY_0f_GET(r) (((r).mmu_xq23[0]) & 0x1)
#define BCM56504_A0_MMU_XQ23m_PARITY_0f_SET(r,f) (r).mmu_xq23[0]=(((r).mmu_xq23[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_MMU_XQ23m_L2f_GET(r) ((((r).mmu_xq23[0]) >> 1) & 0x1)
#define BCM56504_A0_MMU_XQ23m_L2f_SET(r,f) (r).mmu_xq23[0]=(((r).mmu_xq23[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_MMU_XQ23m_PURGEf_GET(r) ((((r).mmu_xq23[0]) >> 2) & 0x1)
#define BCM56504_A0_MMU_XQ23m_PURGEf_SET(r,f) (r).mmu_xq23[0]=(((r).mmu_xq23[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_MMU_XQ23m_PKT_PTRf_GET(r) ((((r).mmu_xq23[0]) >> 3) & 0x3fff)
#define BCM56504_A0_MMU_XQ23m_PKT_PTRf_SET(r,f) (r).mmu_xq23[0]=(((r).mmu_xq23[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56504_A0_MMU_XQ23m_L3IPMCf_GET(r) ((((r).mmu_xq23[0]) >> 17) & 0x1)
#define BCM56504_A0_MMU_XQ23m_L3IPMCf_SET(r,f) (r).mmu_xq23[0]=(((r).mmu_xq23[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56504_A0_MMU_XQ23m_IMIRRORf_GET(r) ((((r).mmu_xq23[0]) >> 18) & 0x1)
#define BCM56504_A0_MMU_XQ23m_IMIRRORf_SET(r,f) (r).mmu_xq23[0]=(((r).mmu_xq23[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56504_A0_MMU_XQ23m_EMIRRORf_GET(r) ((((r).mmu_xq23[0]) >> 19) & 0x1)
#define BCM56504_A0_MMU_XQ23m_EMIRRORf_SET(r,f) (r).mmu_xq23[0]=(((r).mmu_xq23[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ23.
 *
 */
#define BCM56504_A0_READ_MMU_XQ23m(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_MMU_XQ23m,i,(m._mmu_xq23),1)
#define BCM56504_A0_WRITE_MMU_XQ23m(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_MMU_XQ23m,i,&(m._mmu_xq23),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ23m BCM56504_A0_MMU_XQ23m
#define MMU_XQ23m_MIN BCM56504_A0_MMU_XQ23m_MIN
#define MMU_XQ23m_MAX BCM56504_A0_MMU_XQ23m_MAX
#define MMU_XQ23m_CMAX(u) BCM56504_A0_MMU_XQ23m_CMAX(u)
#define MMU_XQ23m_SIZE BCM56504_A0_MMU_XQ23m_SIZE
typedef BCM56504_A0_MMU_XQ23m_t MMU_XQ23m_t;
#define MMU_XQ23m_CLR BCM56504_A0_MMU_XQ23m_CLR
#define MMU_XQ23m_SET BCM56504_A0_MMU_XQ23m_SET
#define MMU_XQ23m_GET BCM56504_A0_MMU_XQ23m_GET
#define MMU_XQ23m_PARITY_0f_GET BCM56504_A0_MMU_XQ23m_PARITY_0f_GET
#define MMU_XQ23m_PARITY_0f_SET BCM56504_A0_MMU_XQ23m_PARITY_0f_SET
#define MMU_XQ23m_L2f_GET BCM56504_A0_MMU_XQ23m_L2f_GET
#define MMU_XQ23m_L2f_SET BCM56504_A0_MMU_XQ23m_L2f_SET
#define MMU_XQ23m_PURGEf_GET BCM56504_A0_MMU_XQ23m_PURGEf_GET
#define MMU_XQ23m_PURGEf_SET BCM56504_A0_MMU_XQ23m_PURGEf_SET
#define MMU_XQ23m_PKT_PTRf_GET BCM56504_A0_MMU_XQ23m_PKT_PTRf_GET
#define MMU_XQ23m_PKT_PTRf_SET BCM56504_A0_MMU_XQ23m_PKT_PTRf_SET
#define MMU_XQ23m_L3IPMCf_GET BCM56504_A0_MMU_XQ23m_L3IPMCf_GET
#define MMU_XQ23m_L3IPMCf_SET BCM56504_A0_MMU_XQ23m_L3IPMCf_SET
#define MMU_XQ23m_IMIRRORf_GET BCM56504_A0_MMU_XQ23m_IMIRRORf_GET
#define MMU_XQ23m_IMIRRORf_SET BCM56504_A0_MMU_XQ23m_IMIRRORf_SET
#define MMU_XQ23m_EMIRRORf_GET BCM56504_A0_MMU_XQ23m_EMIRRORf_GET
#define MMU_XQ23m_EMIRRORf_SET BCM56504_A0_MMU_XQ23m_EMIRRORf_SET
#define READ_MMU_XQ23m BCM56504_A0_READ_MMU_XQ23m
#define WRITE_MMU_XQ23m BCM56504_A0_WRITE_MMU_XQ23m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MMU_XQ23m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  MMU_XQ24
 * BLOCKS:   MMU
 * DESC:     XQ24
 * SIZE:     59
 * FIELDS:
 *     PARITY_0         Parity bit 0
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     L3IPMC           L3 IP multicast Flag
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *     MTP_INDEX        Mirror-to-Port Index
 *     MH_PRIORITY      Module Header PRIORITY
 *     MH_OPCODE        Module Header OPCode
 *     CLASSIFICATION_TAG Calssification TAG
 *     HEADER_TYPE      Module Header Type
 *     CNG              Congestion bits
 *     IPMC_VLAN_TBL_PTR Pointer to IPMC VLAN TABLE
 *     PARITY_1         Parity bit 1
 *
 ******************************************************************************/
#define BCM56504_A0_MMU_XQ24m 0x0b660000

#define BCM56504_A0_MMU_XQ24m_MIN 0
#define BCM56504_A0_MMU_XQ24m_MAX 2047
#define BCM56504_A0_MMU_XQ24m_CMAX(u) 2047
#define BCM56504_A0_MMU_XQ24m_SIZE 8

/*
 * This structure should be used to declare and program MMU_XQ24.
 *
 */
typedef union BCM56504_A0_MMU_XQ24m_s {
	uint32_t v[2];
	uint32_t mmu_xq24[2];
	uint32_t _mmu_xq24;
} BCM56504_A0_MMU_XQ24m_t;

#define BCM56504_A0_MMU_XQ24m_CLR(r) CDK_MEMSET(&((r)._mmu_xq24), 0, sizeof(BCM56504_A0_MMU_XQ24m_t))
#define BCM56504_A0_MMU_XQ24m_SET(r,i,d) (r).mmu_xq24[i] = d
#define BCM56504_A0_MMU_XQ24m_GET(r,i) (r).mmu_xq24[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MMU_XQ24m_PARITY_0f_GET(r) (((r).mmu_xq24[0]) & 0x1)
#define BCM56504_A0_MMU_XQ24m_PARITY_0f_SET(r,f) (r).mmu_xq24[0]=(((r).mmu_xq24[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_MMU_XQ24m_L2f_GET(r) ((((r).mmu_xq24[0]) >> 1) & 0x1)
#define BCM56504_A0_MMU_XQ24m_L2f_SET(r,f) (r).mmu_xq24[0]=(((r).mmu_xq24[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_MMU_XQ24m_PURGEf_GET(r) ((((r).mmu_xq24[0]) >> 2) & 0x1)
#define BCM56504_A0_MMU_XQ24m_PURGEf_SET(r,f) (r).mmu_xq24[0]=(((r).mmu_xq24[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_MMU_XQ24m_PKT_PTRf_GET(r) ((((r).mmu_xq24[0]) >> 3) & 0x3fff)
#define BCM56504_A0_MMU_XQ24m_PKT_PTRf_SET(r,f) (r).mmu_xq24[0]=(((r).mmu_xq24[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56504_A0_MMU_XQ24m_L3IPMCf_GET(r) ((((r).mmu_xq24[0]) >> 17) & 0x1)
#define BCM56504_A0_MMU_XQ24m_L3IPMCf_SET(r,f) (r).mmu_xq24[0]=(((r).mmu_xq24[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56504_A0_MMU_XQ24m_IMIRRORf_GET(r) ((((r).mmu_xq24[0]) >> 18) & 0x1)
#define BCM56504_A0_MMU_XQ24m_IMIRRORf_SET(r,f) (r).mmu_xq24[0]=(((r).mmu_xq24[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56504_A0_MMU_XQ24m_EMIRRORf_GET(r) ((((r).mmu_xq24[0]) >> 19) & 0x1)
#define BCM56504_A0_MMU_XQ24m_EMIRRORf_SET(r,f) (r).mmu_xq24[0]=(((r).mmu_xq24[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56504_A0_MMU_XQ24m_MTP_INDEXf_GET(r) ((((r).mmu_xq24[0]) >> 20) & 0x7f)
#define BCM56504_A0_MMU_XQ24m_MTP_INDEXf_SET(r,f) (r).mmu_xq24[0]=(((r).mmu_xq24[0] & ~((uint32_t)0x7f << 20)) | ((((uint32_t)f) & 0x7f) << 20))
#define BCM56504_A0_MMU_XQ24m_MH_PRIORITYf_GET(r) ((((r).mmu_xq24[0]) >> 27) & 0x7)
#define BCM56504_A0_MMU_XQ24m_MH_PRIORITYf_SET(r,f) (r).mmu_xq24[0]=(((r).mmu_xq24[0] & ~((uint32_t)0x7 << 27)) | ((((uint32_t)f) & 0x7) << 27))
#define BCM56504_A0_MMU_XQ24m_MH_OPCODEf_GET(r) cdk_field32_get((r).mmu_xq24,30,32)
#define BCM56504_A0_MMU_XQ24m_MH_OPCODEf_SET(r,f) cdk_field32_set((r).mmu_xq24,30,32,f)
#define BCM56504_A0_MMU_XQ24m_CLASSIFICATION_TAGf_GET(r) ((((r).mmu_xq24[1]) >> 1) & 0x7ff)
#define BCM56504_A0_MMU_XQ24m_CLASSIFICATION_TAGf_SET(r,f) (r).mmu_xq24[1]=(((r).mmu_xq24[1] & ~((uint32_t)0x7ff << 1)) | ((((uint32_t)f) & 0x7ff) << 1))
#define BCM56504_A0_MMU_XQ24m_HEADER_TYPEf_GET(r) ((((r).mmu_xq24[1]) >> 12) & 0x3)
#define BCM56504_A0_MMU_XQ24m_HEADER_TYPEf_SET(r,f) (r).mmu_xq24[1]=(((r).mmu_xq24[1] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM56504_A0_MMU_XQ24m_CNGf_GET(r) ((((r).mmu_xq24[1]) >> 14) & 0x3)
#define BCM56504_A0_MMU_XQ24m_CNGf_SET(r,f) (r).mmu_xq24[1]=(((r).mmu_xq24[1] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCM56504_A0_MMU_XQ24m_IPMC_VLAN_TBL_PTRf_GET(r) ((((r).mmu_xq24[1]) >> 16) & 0x3ff)
#define BCM56504_A0_MMU_XQ24m_IPMC_VLAN_TBL_PTRf_SET(r,f) (r).mmu_xq24[1]=(((r).mmu_xq24[1] & ~((uint32_t)0x3ff << 16)) | ((((uint32_t)f) & 0x3ff) << 16))
#define BCM56504_A0_MMU_XQ24m_PARITY_1f_GET(r) ((((r).mmu_xq24[1]) >> 26) & 0x1)
#define BCM56504_A0_MMU_XQ24m_PARITY_1f_SET(r,f) (r).mmu_xq24[1]=(((r).mmu_xq24[1] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))

/*
 * These macros can be used to access MMU_XQ24.
 *
 */
#define BCM56504_A0_READ_MMU_XQ24m(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_MMU_XQ24m,i,(m._mmu_xq24),2)
#define BCM56504_A0_WRITE_MMU_XQ24m(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_MMU_XQ24m,i,&(m._mmu_xq24),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ24m BCM56504_A0_MMU_XQ24m
#define MMU_XQ24m_MIN BCM56504_A0_MMU_XQ24m_MIN
#define MMU_XQ24m_MAX BCM56504_A0_MMU_XQ24m_MAX
#define MMU_XQ24m_CMAX(u) BCM56504_A0_MMU_XQ24m_CMAX(u)
#define MMU_XQ24m_SIZE BCM56504_A0_MMU_XQ24m_SIZE
typedef BCM56504_A0_MMU_XQ24m_t MMU_XQ24m_t;
#define MMU_XQ24m_CLR BCM56504_A0_MMU_XQ24m_CLR
#define MMU_XQ24m_SET BCM56504_A0_MMU_XQ24m_SET
#define MMU_XQ24m_GET BCM56504_A0_MMU_XQ24m_GET
#define MMU_XQ24m_PARITY_0f_GET BCM56504_A0_MMU_XQ24m_PARITY_0f_GET
#define MMU_XQ24m_PARITY_0f_SET BCM56504_A0_MMU_XQ24m_PARITY_0f_SET
#define MMU_XQ24m_L2f_GET BCM56504_A0_MMU_XQ24m_L2f_GET
#define MMU_XQ24m_L2f_SET BCM56504_A0_MMU_XQ24m_L2f_SET
#define MMU_XQ24m_PURGEf_GET BCM56504_A0_MMU_XQ24m_PURGEf_GET
#define MMU_XQ24m_PURGEf_SET BCM56504_A0_MMU_XQ24m_PURGEf_SET
#define MMU_XQ24m_PKT_PTRf_GET BCM56504_A0_MMU_XQ24m_PKT_PTRf_GET
#define MMU_XQ24m_PKT_PTRf_SET BCM56504_A0_MMU_XQ24m_PKT_PTRf_SET
#define MMU_XQ24m_L3IPMCf_GET BCM56504_A0_MMU_XQ24m_L3IPMCf_GET
#define MMU_XQ24m_L3IPMCf_SET BCM56504_A0_MMU_XQ24m_L3IPMCf_SET
#define MMU_XQ24m_IMIRRORf_GET BCM56504_A0_MMU_XQ24m_IMIRRORf_GET
#define MMU_XQ24m_IMIRRORf_SET BCM56504_A0_MMU_XQ24m_IMIRRORf_SET
#define MMU_XQ24m_EMIRRORf_GET BCM56504_A0_MMU_XQ24m_EMIRRORf_GET
#define MMU_XQ24m_EMIRRORf_SET BCM56504_A0_MMU_XQ24m_EMIRRORf_SET
#define MMU_XQ24m_MTP_INDEXf_GET BCM56504_A0_MMU_XQ24m_MTP_INDEXf_GET
#define MMU_XQ24m_MTP_INDEXf_SET BCM56504_A0_MMU_XQ24m_MTP_INDEXf_SET
#define MMU_XQ24m_MH_PRIORITYf_GET BCM56504_A0_MMU_XQ24m_MH_PRIORITYf_GET
#define MMU_XQ24m_MH_PRIORITYf_SET BCM56504_A0_MMU_XQ24m_MH_PRIORITYf_SET
#define MMU_XQ24m_MH_OPCODEf_GET BCM56504_A0_MMU_XQ24m_MH_OPCODEf_GET
#define MMU_XQ24m_MH_OPCODEf_SET BCM56504_A0_MMU_XQ24m_MH_OPCODEf_SET
#define MMU_XQ24m_CLASSIFICATION_TAGf_GET BCM56504_A0_MMU_XQ24m_CLASSIFICATION_TAGf_GET
#define MMU_XQ24m_CLASSIFICATION_TAGf_SET BCM56504_A0_MMU_XQ24m_CLASSIFICATION_TAGf_SET
#define MMU_XQ24m_HEADER_TYPEf_GET BCM56504_A0_MMU_XQ24m_HEADER_TYPEf_GET
#define MMU_XQ24m_HEADER_TYPEf_SET BCM56504_A0_MMU_XQ24m_HEADER_TYPEf_SET
#define MMU_XQ24m_CNGf_GET BCM56504_A0_MMU_XQ24m_CNGf_GET
#define MMU_XQ24m_CNGf_SET BCM56504_A0_MMU_XQ24m_CNGf_SET
#define MMU_XQ24m_IPMC_VLAN_TBL_PTRf_GET BCM56504_A0_MMU_XQ24m_IPMC_VLAN_TBL_PTRf_GET
#define MMU_XQ24m_IPMC_VLAN_TBL_PTRf_SET BCM56504_A0_MMU_XQ24m_IPMC_VLAN_TBL_PTRf_SET
#define MMU_XQ24m_PARITY_1f_GET BCM56504_A0_MMU_XQ24m_PARITY_1f_GET
#define MMU_XQ24m_PARITY_1f_SET BCM56504_A0_MMU_XQ24m_PARITY_1f_SET
#define READ_MMU_XQ24m BCM56504_A0_READ_MMU_XQ24m
#define WRITE_MMU_XQ24m BCM56504_A0_WRITE_MMU_XQ24m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MMU_XQ24m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  MMU_XQ25
 * BLOCKS:   MMU
 * DESC:     XQ25
 * SIZE:     59
 * FIELDS:
 *     PARITY_0         Parity bit 0
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     L3IPMC           L3 IP multicast Flag
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *     MTP_INDEX        Mirror-to-Port Index
 *     MH_PRIORITY      Module Header PRIORITY
 *     MH_OPCODE        Module Header OPCode
 *     CLASSIFICATION_TAG Calssification TAG
 *     HEADER_TYPE      Module Header Type
 *     CNG              Congestion bits
 *     IPMC_VLAN_TBL_PTR Pointer to IPMC VLAN TABLE
 *     PARITY_1         Parity bit 1
 *
 ******************************************************************************/
#define BCM56504_A0_MMU_XQ25m 0x0b664000

#define BCM56504_A0_MMU_XQ25m_MIN 0
#define BCM56504_A0_MMU_XQ25m_MAX 2047
#define BCM56504_A0_MMU_XQ25m_CMAX(u) 2047
#define BCM56504_A0_MMU_XQ25m_SIZE 8

/*
 * This structure should be used to declare and program MMU_XQ25.
 *
 */
typedef union BCM56504_A0_MMU_XQ25m_s {
	uint32_t v[2];
	uint32_t mmu_xq25[2];
	uint32_t _mmu_xq25;
} BCM56504_A0_MMU_XQ25m_t;

#define BCM56504_A0_MMU_XQ25m_CLR(r) CDK_MEMSET(&((r)._mmu_xq25), 0, sizeof(BCM56504_A0_MMU_XQ25m_t))
#define BCM56504_A0_MMU_XQ25m_SET(r,i,d) (r).mmu_xq25[i] = d
#define BCM56504_A0_MMU_XQ25m_GET(r,i) (r).mmu_xq25[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MMU_XQ25m_PARITY_0f_GET(r) (((r).mmu_xq25[0]) & 0x1)
#define BCM56504_A0_MMU_XQ25m_PARITY_0f_SET(r,f) (r).mmu_xq25[0]=(((r).mmu_xq25[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_MMU_XQ25m_L2f_GET(r) ((((r).mmu_xq25[0]) >> 1) & 0x1)
#define BCM56504_A0_MMU_XQ25m_L2f_SET(r,f) (r).mmu_xq25[0]=(((r).mmu_xq25[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_MMU_XQ25m_PURGEf_GET(r) ((((r).mmu_xq25[0]) >> 2) & 0x1)
#define BCM56504_A0_MMU_XQ25m_PURGEf_SET(r,f) (r).mmu_xq25[0]=(((r).mmu_xq25[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_MMU_XQ25m_PKT_PTRf_GET(r) ((((r).mmu_xq25[0]) >> 3) & 0x3fff)
#define BCM56504_A0_MMU_XQ25m_PKT_PTRf_SET(r,f) (r).mmu_xq25[0]=(((r).mmu_xq25[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56504_A0_MMU_XQ25m_L3IPMCf_GET(r) ((((r).mmu_xq25[0]) >> 17) & 0x1)
#define BCM56504_A0_MMU_XQ25m_L3IPMCf_SET(r,f) (r).mmu_xq25[0]=(((r).mmu_xq25[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56504_A0_MMU_XQ25m_IMIRRORf_GET(r) ((((r).mmu_xq25[0]) >> 18) & 0x1)
#define BCM56504_A0_MMU_XQ25m_IMIRRORf_SET(r,f) (r).mmu_xq25[0]=(((r).mmu_xq25[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56504_A0_MMU_XQ25m_EMIRRORf_GET(r) ((((r).mmu_xq25[0]) >> 19) & 0x1)
#define BCM56504_A0_MMU_XQ25m_EMIRRORf_SET(r,f) (r).mmu_xq25[0]=(((r).mmu_xq25[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56504_A0_MMU_XQ25m_MTP_INDEXf_GET(r) ((((r).mmu_xq25[0]) >> 20) & 0x7f)
#define BCM56504_A0_MMU_XQ25m_MTP_INDEXf_SET(r,f) (r).mmu_xq25[0]=(((r).mmu_xq25[0] & ~((uint32_t)0x7f << 20)) | ((((uint32_t)f) & 0x7f) << 20))
#define BCM56504_A0_MMU_XQ25m_MH_PRIORITYf_GET(r) ((((r).mmu_xq25[0]) >> 27) & 0x7)
#define BCM56504_A0_MMU_XQ25m_MH_PRIORITYf_SET(r,f) (r).mmu_xq25[0]=(((r).mmu_xq25[0] & ~((uint32_t)0x7 << 27)) | ((((uint32_t)f) & 0x7) << 27))
#define BCM56504_A0_MMU_XQ25m_MH_OPCODEf_GET(r) cdk_field32_get((r).mmu_xq25,30,32)
#define BCM56504_A0_MMU_XQ25m_MH_OPCODEf_SET(r,f) cdk_field32_set((r).mmu_xq25,30,32,f)
#define BCM56504_A0_MMU_XQ25m_CLASSIFICATION_TAGf_GET(r) ((((r).mmu_xq25[1]) >> 1) & 0x7ff)
#define BCM56504_A0_MMU_XQ25m_CLASSIFICATION_TAGf_SET(r,f) (r).mmu_xq25[1]=(((r).mmu_xq25[1] & ~((uint32_t)0x7ff << 1)) | ((((uint32_t)f) & 0x7ff) << 1))
#define BCM56504_A0_MMU_XQ25m_HEADER_TYPEf_GET(r) ((((r).mmu_xq25[1]) >> 12) & 0x3)
#define BCM56504_A0_MMU_XQ25m_HEADER_TYPEf_SET(r,f) (r).mmu_xq25[1]=(((r).mmu_xq25[1] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM56504_A0_MMU_XQ25m_CNGf_GET(r) ((((r).mmu_xq25[1]) >> 14) & 0x3)
#define BCM56504_A0_MMU_XQ25m_CNGf_SET(r,f) (r).mmu_xq25[1]=(((r).mmu_xq25[1] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCM56504_A0_MMU_XQ25m_IPMC_VLAN_TBL_PTRf_GET(r) ((((r).mmu_xq25[1]) >> 16) & 0x3ff)
#define BCM56504_A0_MMU_XQ25m_IPMC_VLAN_TBL_PTRf_SET(r,f) (r).mmu_xq25[1]=(((r).mmu_xq25[1] & ~((uint32_t)0x3ff << 16)) | ((((uint32_t)f) & 0x3ff) << 16))
#define BCM56504_A0_MMU_XQ25m_PARITY_1f_GET(r) ((((r).mmu_xq25[1]) >> 26) & 0x1)
#define BCM56504_A0_MMU_XQ25m_PARITY_1f_SET(r,f) (r).mmu_xq25[1]=(((r).mmu_xq25[1] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))

/*
 * These macros can be used to access MMU_XQ25.
 *
 */
#define BCM56504_A0_READ_MMU_XQ25m(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_MMU_XQ25m,i,(m._mmu_xq25),2)
#define BCM56504_A0_WRITE_MMU_XQ25m(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_MMU_XQ25m,i,&(m._mmu_xq25),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ25m BCM56504_A0_MMU_XQ25m
#define MMU_XQ25m_MIN BCM56504_A0_MMU_XQ25m_MIN
#define MMU_XQ25m_MAX BCM56504_A0_MMU_XQ25m_MAX
#define MMU_XQ25m_CMAX(u) BCM56504_A0_MMU_XQ25m_CMAX(u)
#define MMU_XQ25m_SIZE BCM56504_A0_MMU_XQ25m_SIZE
typedef BCM56504_A0_MMU_XQ25m_t MMU_XQ25m_t;
#define MMU_XQ25m_CLR BCM56504_A0_MMU_XQ25m_CLR
#define MMU_XQ25m_SET BCM56504_A0_MMU_XQ25m_SET
#define MMU_XQ25m_GET BCM56504_A0_MMU_XQ25m_GET
#define MMU_XQ25m_PARITY_0f_GET BCM56504_A0_MMU_XQ25m_PARITY_0f_GET
#define MMU_XQ25m_PARITY_0f_SET BCM56504_A0_MMU_XQ25m_PARITY_0f_SET
#define MMU_XQ25m_L2f_GET BCM56504_A0_MMU_XQ25m_L2f_GET
#define MMU_XQ25m_L2f_SET BCM56504_A0_MMU_XQ25m_L2f_SET
#define MMU_XQ25m_PURGEf_GET BCM56504_A0_MMU_XQ25m_PURGEf_GET
#define MMU_XQ25m_PURGEf_SET BCM56504_A0_MMU_XQ25m_PURGEf_SET
#define MMU_XQ25m_PKT_PTRf_GET BCM56504_A0_MMU_XQ25m_PKT_PTRf_GET
#define MMU_XQ25m_PKT_PTRf_SET BCM56504_A0_MMU_XQ25m_PKT_PTRf_SET
#define MMU_XQ25m_L3IPMCf_GET BCM56504_A0_MMU_XQ25m_L3IPMCf_GET
#define MMU_XQ25m_L3IPMCf_SET BCM56504_A0_MMU_XQ25m_L3IPMCf_SET
#define MMU_XQ25m_IMIRRORf_GET BCM56504_A0_MMU_XQ25m_IMIRRORf_GET
#define MMU_XQ25m_IMIRRORf_SET BCM56504_A0_MMU_XQ25m_IMIRRORf_SET
#define MMU_XQ25m_EMIRRORf_GET BCM56504_A0_MMU_XQ25m_EMIRRORf_GET
#define MMU_XQ25m_EMIRRORf_SET BCM56504_A0_MMU_XQ25m_EMIRRORf_SET
#define MMU_XQ25m_MTP_INDEXf_GET BCM56504_A0_MMU_XQ25m_MTP_INDEXf_GET
#define MMU_XQ25m_MTP_INDEXf_SET BCM56504_A0_MMU_XQ25m_MTP_INDEXf_SET
#define MMU_XQ25m_MH_PRIORITYf_GET BCM56504_A0_MMU_XQ25m_MH_PRIORITYf_GET
#define MMU_XQ25m_MH_PRIORITYf_SET BCM56504_A0_MMU_XQ25m_MH_PRIORITYf_SET
#define MMU_XQ25m_MH_OPCODEf_GET BCM56504_A0_MMU_XQ25m_MH_OPCODEf_GET
#define MMU_XQ25m_MH_OPCODEf_SET BCM56504_A0_MMU_XQ25m_MH_OPCODEf_SET
#define MMU_XQ25m_CLASSIFICATION_TAGf_GET BCM56504_A0_MMU_XQ25m_CLASSIFICATION_TAGf_GET
#define MMU_XQ25m_CLASSIFICATION_TAGf_SET BCM56504_A0_MMU_XQ25m_CLASSIFICATION_TAGf_SET
#define MMU_XQ25m_HEADER_TYPEf_GET BCM56504_A0_MMU_XQ25m_HEADER_TYPEf_GET
#define MMU_XQ25m_HEADER_TYPEf_SET BCM56504_A0_MMU_XQ25m_HEADER_TYPEf_SET
#define MMU_XQ25m_CNGf_GET BCM56504_A0_MMU_XQ25m_CNGf_GET
#define MMU_XQ25m_CNGf_SET BCM56504_A0_MMU_XQ25m_CNGf_SET
#define MMU_XQ25m_IPMC_VLAN_TBL_PTRf_GET BCM56504_A0_MMU_XQ25m_IPMC_VLAN_TBL_PTRf_GET
#define MMU_XQ25m_IPMC_VLAN_TBL_PTRf_SET BCM56504_A0_MMU_XQ25m_IPMC_VLAN_TBL_PTRf_SET
#define MMU_XQ25m_PARITY_1f_GET BCM56504_A0_MMU_XQ25m_PARITY_1f_GET
#define MMU_XQ25m_PARITY_1f_SET BCM56504_A0_MMU_XQ25m_PARITY_1f_SET
#define READ_MMU_XQ25m BCM56504_A0_READ_MMU_XQ25m
#define WRITE_MMU_XQ25m BCM56504_A0_WRITE_MMU_XQ25m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MMU_XQ25m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  MMU_XQ26
 * BLOCKS:   MMU
 * DESC:     XQ26
 * SIZE:     59
 * FIELDS:
 *     PARITY_0         Parity bit 0
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     L3IPMC           L3 IP multicast Flag
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *     MTP_INDEX        Mirror-to-Port Index
 *     MH_PRIORITY      Module Header PRIORITY
 *     MH_OPCODE        Module Header OPCode
 *     CLASSIFICATION_TAG Calssification TAG
 *     HEADER_TYPE      Module Header Type
 *     CNG              Congestion bits
 *     IPMC_VLAN_TBL_PTR Pointer to IPMC VLAN TABLE
 *     PARITY_1         Parity bit 1
 *
 ******************************************************************************/
#define BCM56504_A0_MMU_XQ26m 0x0b668000

#define BCM56504_A0_MMU_XQ26m_MIN 0
#define BCM56504_A0_MMU_XQ26m_MAX 2047
#define BCM56504_A0_MMU_XQ26m_CMAX(u) 2047
#define BCM56504_A0_MMU_XQ26m_SIZE 8

/*
 * This structure should be used to declare and program MMU_XQ26.
 *
 */
typedef union BCM56504_A0_MMU_XQ26m_s {
	uint32_t v[2];
	uint32_t mmu_xq26[2];
	uint32_t _mmu_xq26;
} BCM56504_A0_MMU_XQ26m_t;

#define BCM56504_A0_MMU_XQ26m_CLR(r) CDK_MEMSET(&((r)._mmu_xq26), 0, sizeof(BCM56504_A0_MMU_XQ26m_t))
#define BCM56504_A0_MMU_XQ26m_SET(r,i,d) (r).mmu_xq26[i] = d
#define BCM56504_A0_MMU_XQ26m_GET(r,i) (r).mmu_xq26[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MMU_XQ26m_PARITY_0f_GET(r) (((r).mmu_xq26[0]) & 0x1)
#define BCM56504_A0_MMU_XQ26m_PARITY_0f_SET(r,f) (r).mmu_xq26[0]=(((r).mmu_xq26[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_MMU_XQ26m_L2f_GET(r) ((((r).mmu_xq26[0]) >> 1) & 0x1)
#define BCM56504_A0_MMU_XQ26m_L2f_SET(r,f) (r).mmu_xq26[0]=(((r).mmu_xq26[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_MMU_XQ26m_PURGEf_GET(r) ((((r).mmu_xq26[0]) >> 2) & 0x1)
#define BCM56504_A0_MMU_XQ26m_PURGEf_SET(r,f) (r).mmu_xq26[0]=(((r).mmu_xq26[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_MMU_XQ26m_PKT_PTRf_GET(r) ((((r).mmu_xq26[0]) >> 3) & 0x3fff)
#define BCM56504_A0_MMU_XQ26m_PKT_PTRf_SET(r,f) (r).mmu_xq26[0]=(((r).mmu_xq26[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56504_A0_MMU_XQ26m_L3IPMCf_GET(r) ((((r).mmu_xq26[0]) >> 17) & 0x1)
#define BCM56504_A0_MMU_XQ26m_L3IPMCf_SET(r,f) (r).mmu_xq26[0]=(((r).mmu_xq26[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56504_A0_MMU_XQ26m_IMIRRORf_GET(r) ((((r).mmu_xq26[0]) >> 18) & 0x1)
#define BCM56504_A0_MMU_XQ26m_IMIRRORf_SET(r,f) (r).mmu_xq26[0]=(((r).mmu_xq26[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56504_A0_MMU_XQ26m_EMIRRORf_GET(r) ((((r).mmu_xq26[0]) >> 19) & 0x1)
#define BCM56504_A0_MMU_XQ26m_EMIRRORf_SET(r,f) (r).mmu_xq26[0]=(((r).mmu_xq26[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56504_A0_MMU_XQ26m_MTP_INDEXf_GET(r) ((((r).mmu_xq26[0]) >> 20) & 0x7f)
#define BCM56504_A0_MMU_XQ26m_MTP_INDEXf_SET(r,f) (r).mmu_xq26[0]=(((r).mmu_xq26[0] & ~((uint32_t)0x7f << 20)) | ((((uint32_t)f) & 0x7f) << 20))
#define BCM56504_A0_MMU_XQ26m_MH_PRIORITYf_GET(r) ((((r).mmu_xq26[0]) >> 27) & 0x7)
#define BCM56504_A0_MMU_XQ26m_MH_PRIORITYf_SET(r,f) (r).mmu_xq26[0]=(((r).mmu_xq26[0] & ~((uint32_t)0x7 << 27)) | ((((uint32_t)f) & 0x7) << 27))
#define BCM56504_A0_MMU_XQ26m_MH_OPCODEf_GET(r) cdk_field32_get((r).mmu_xq26,30,32)
#define BCM56504_A0_MMU_XQ26m_MH_OPCODEf_SET(r,f) cdk_field32_set((r).mmu_xq26,30,32,f)
#define BCM56504_A0_MMU_XQ26m_CLASSIFICATION_TAGf_GET(r) ((((r).mmu_xq26[1]) >> 1) & 0x7ff)
#define BCM56504_A0_MMU_XQ26m_CLASSIFICATION_TAGf_SET(r,f) (r).mmu_xq26[1]=(((r).mmu_xq26[1] & ~((uint32_t)0x7ff << 1)) | ((((uint32_t)f) & 0x7ff) << 1))
#define BCM56504_A0_MMU_XQ26m_HEADER_TYPEf_GET(r) ((((r).mmu_xq26[1]) >> 12) & 0x3)
#define BCM56504_A0_MMU_XQ26m_HEADER_TYPEf_SET(r,f) (r).mmu_xq26[1]=(((r).mmu_xq26[1] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM56504_A0_MMU_XQ26m_CNGf_GET(r) ((((r).mmu_xq26[1]) >> 14) & 0x3)
#define BCM56504_A0_MMU_XQ26m_CNGf_SET(r,f) (r).mmu_xq26[1]=(((r).mmu_xq26[1] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCM56504_A0_MMU_XQ26m_IPMC_VLAN_TBL_PTRf_GET(r) ((((r).mmu_xq26[1]) >> 16) & 0x3ff)
#define BCM56504_A0_MMU_XQ26m_IPMC_VLAN_TBL_PTRf_SET(r,f) (r).mmu_xq26[1]=(((r).mmu_xq26[1] & ~((uint32_t)0x3ff << 16)) | ((((uint32_t)f) & 0x3ff) << 16))
#define BCM56504_A0_MMU_XQ26m_PARITY_1f_GET(r) ((((r).mmu_xq26[1]) >> 26) & 0x1)
#define BCM56504_A0_MMU_XQ26m_PARITY_1f_SET(r,f) (r).mmu_xq26[1]=(((r).mmu_xq26[1] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))

/*
 * These macros can be used to access MMU_XQ26.
 *
 */
#define BCM56504_A0_READ_MMU_XQ26m(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_MMU_XQ26m,i,(m._mmu_xq26),2)
#define BCM56504_A0_WRITE_MMU_XQ26m(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_MMU_XQ26m,i,&(m._mmu_xq26),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ26m BCM56504_A0_MMU_XQ26m
#define MMU_XQ26m_MIN BCM56504_A0_MMU_XQ26m_MIN
#define MMU_XQ26m_MAX BCM56504_A0_MMU_XQ26m_MAX
#define MMU_XQ26m_CMAX(u) BCM56504_A0_MMU_XQ26m_CMAX(u)
#define MMU_XQ26m_SIZE BCM56504_A0_MMU_XQ26m_SIZE
typedef BCM56504_A0_MMU_XQ26m_t MMU_XQ26m_t;
#define MMU_XQ26m_CLR BCM56504_A0_MMU_XQ26m_CLR
#define MMU_XQ26m_SET BCM56504_A0_MMU_XQ26m_SET
#define MMU_XQ26m_GET BCM56504_A0_MMU_XQ26m_GET
#define MMU_XQ26m_PARITY_0f_GET BCM56504_A0_MMU_XQ26m_PARITY_0f_GET
#define MMU_XQ26m_PARITY_0f_SET BCM56504_A0_MMU_XQ26m_PARITY_0f_SET
#define MMU_XQ26m_L2f_GET BCM56504_A0_MMU_XQ26m_L2f_GET
#define MMU_XQ26m_L2f_SET BCM56504_A0_MMU_XQ26m_L2f_SET
#define MMU_XQ26m_PURGEf_GET BCM56504_A0_MMU_XQ26m_PURGEf_GET
#define MMU_XQ26m_PURGEf_SET BCM56504_A0_MMU_XQ26m_PURGEf_SET
#define MMU_XQ26m_PKT_PTRf_GET BCM56504_A0_MMU_XQ26m_PKT_PTRf_GET
#define MMU_XQ26m_PKT_PTRf_SET BCM56504_A0_MMU_XQ26m_PKT_PTRf_SET
#define MMU_XQ26m_L3IPMCf_GET BCM56504_A0_MMU_XQ26m_L3IPMCf_GET
#define MMU_XQ26m_L3IPMCf_SET BCM56504_A0_MMU_XQ26m_L3IPMCf_SET
#define MMU_XQ26m_IMIRRORf_GET BCM56504_A0_MMU_XQ26m_IMIRRORf_GET
#define MMU_XQ26m_IMIRRORf_SET BCM56504_A0_MMU_XQ26m_IMIRRORf_SET
#define MMU_XQ26m_EMIRRORf_GET BCM56504_A0_MMU_XQ26m_EMIRRORf_GET
#define MMU_XQ26m_EMIRRORf_SET BCM56504_A0_MMU_XQ26m_EMIRRORf_SET
#define MMU_XQ26m_MTP_INDEXf_GET BCM56504_A0_MMU_XQ26m_MTP_INDEXf_GET
#define MMU_XQ26m_MTP_INDEXf_SET BCM56504_A0_MMU_XQ26m_MTP_INDEXf_SET
#define MMU_XQ26m_MH_PRIORITYf_GET BCM56504_A0_MMU_XQ26m_MH_PRIORITYf_GET
#define MMU_XQ26m_MH_PRIORITYf_SET BCM56504_A0_MMU_XQ26m_MH_PRIORITYf_SET
#define MMU_XQ26m_MH_OPCODEf_GET BCM56504_A0_MMU_XQ26m_MH_OPCODEf_GET
#define MMU_XQ26m_MH_OPCODEf_SET BCM56504_A0_MMU_XQ26m_MH_OPCODEf_SET
#define MMU_XQ26m_CLASSIFICATION_TAGf_GET BCM56504_A0_MMU_XQ26m_CLASSIFICATION_TAGf_GET
#define MMU_XQ26m_CLASSIFICATION_TAGf_SET BCM56504_A0_MMU_XQ26m_CLASSIFICATION_TAGf_SET
#define MMU_XQ26m_HEADER_TYPEf_GET BCM56504_A0_MMU_XQ26m_HEADER_TYPEf_GET
#define MMU_XQ26m_HEADER_TYPEf_SET BCM56504_A0_MMU_XQ26m_HEADER_TYPEf_SET
#define MMU_XQ26m_CNGf_GET BCM56504_A0_MMU_XQ26m_CNGf_GET
#define MMU_XQ26m_CNGf_SET BCM56504_A0_MMU_XQ26m_CNGf_SET
#define MMU_XQ26m_IPMC_VLAN_TBL_PTRf_GET BCM56504_A0_MMU_XQ26m_IPMC_VLAN_TBL_PTRf_GET
#define MMU_XQ26m_IPMC_VLAN_TBL_PTRf_SET BCM56504_A0_MMU_XQ26m_IPMC_VLAN_TBL_PTRf_SET
#define MMU_XQ26m_PARITY_1f_GET BCM56504_A0_MMU_XQ26m_PARITY_1f_GET
#define MMU_XQ26m_PARITY_1f_SET BCM56504_A0_MMU_XQ26m_PARITY_1f_SET
#define READ_MMU_XQ26m BCM56504_A0_READ_MMU_XQ26m
#define WRITE_MMU_XQ26m BCM56504_A0_WRITE_MMU_XQ26m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MMU_XQ26m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  MMU_XQ27
 * BLOCKS:   MMU
 * DESC:     XQ27
 * SIZE:     59
 * FIELDS:
 *     PARITY_0         Parity bit 0
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     L3IPMC           L3 IP multicast Flag
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *     MTP_INDEX        Mirror-to-Port Index
 *     MH_PRIORITY      Module Header PRIORITY
 *     MH_OPCODE        Module Header OPCode
 *     CLASSIFICATION_TAG Calssification TAG
 *     HEADER_TYPE      Module Header Type
 *     CNG              Congestion bits
 *     IPMC_VLAN_TBL_PTR Pointer to IPMC VLAN TABLE
 *     PARITY_1         Parity bit 1
 *
 ******************************************************************************/
#define BCM56504_A0_MMU_XQ27m 0x0b66c000

#define BCM56504_A0_MMU_XQ27m_MIN 0
#define BCM56504_A0_MMU_XQ27m_MAX 2047
#define BCM56504_A0_MMU_XQ27m_CMAX(u) 2047
#define BCM56504_A0_MMU_XQ27m_SIZE 8

/*
 * This structure should be used to declare and program MMU_XQ27.
 *
 */
typedef union BCM56504_A0_MMU_XQ27m_s {
	uint32_t v[2];
	uint32_t mmu_xq27[2];
	uint32_t _mmu_xq27;
} BCM56504_A0_MMU_XQ27m_t;

#define BCM56504_A0_MMU_XQ27m_CLR(r) CDK_MEMSET(&((r)._mmu_xq27), 0, sizeof(BCM56504_A0_MMU_XQ27m_t))
#define BCM56504_A0_MMU_XQ27m_SET(r,i,d) (r).mmu_xq27[i] = d
#define BCM56504_A0_MMU_XQ27m_GET(r,i) (r).mmu_xq27[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MMU_XQ27m_PARITY_0f_GET(r) (((r).mmu_xq27[0]) & 0x1)
#define BCM56504_A0_MMU_XQ27m_PARITY_0f_SET(r,f) (r).mmu_xq27[0]=(((r).mmu_xq27[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_MMU_XQ27m_L2f_GET(r) ((((r).mmu_xq27[0]) >> 1) & 0x1)
#define BCM56504_A0_MMU_XQ27m_L2f_SET(r,f) (r).mmu_xq27[0]=(((r).mmu_xq27[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_MMU_XQ27m_PURGEf_GET(r) ((((r).mmu_xq27[0]) >> 2) & 0x1)
#define BCM56504_A0_MMU_XQ27m_PURGEf_SET(r,f) (r).mmu_xq27[0]=(((r).mmu_xq27[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_MMU_XQ27m_PKT_PTRf_GET(r) ((((r).mmu_xq27[0]) >> 3) & 0x3fff)
#define BCM56504_A0_MMU_XQ27m_PKT_PTRf_SET(r,f) (r).mmu_xq27[0]=(((r).mmu_xq27[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56504_A0_MMU_XQ27m_L3IPMCf_GET(r) ((((r).mmu_xq27[0]) >> 17) & 0x1)
#define BCM56504_A0_MMU_XQ27m_L3IPMCf_SET(r,f) (r).mmu_xq27[0]=(((r).mmu_xq27[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56504_A0_MMU_XQ27m_IMIRRORf_GET(r) ((((r).mmu_xq27[0]) >> 18) & 0x1)
#define BCM56504_A0_MMU_XQ27m_IMIRRORf_SET(r,f) (r).mmu_xq27[0]=(((r).mmu_xq27[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56504_A0_MMU_XQ27m_EMIRRORf_GET(r) ((((r).mmu_xq27[0]) >> 19) & 0x1)
#define BCM56504_A0_MMU_XQ27m_EMIRRORf_SET(r,f) (r).mmu_xq27[0]=(((r).mmu_xq27[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56504_A0_MMU_XQ27m_MTP_INDEXf_GET(r) ((((r).mmu_xq27[0]) >> 20) & 0x7f)
#define BCM56504_A0_MMU_XQ27m_MTP_INDEXf_SET(r,f) (r).mmu_xq27[0]=(((r).mmu_xq27[0] & ~((uint32_t)0x7f << 20)) | ((((uint32_t)f) & 0x7f) << 20))
#define BCM56504_A0_MMU_XQ27m_MH_PRIORITYf_GET(r) ((((r).mmu_xq27[0]) >> 27) & 0x7)
#define BCM56504_A0_MMU_XQ27m_MH_PRIORITYf_SET(r,f) (r).mmu_xq27[0]=(((r).mmu_xq27[0] & ~((uint32_t)0x7 << 27)) | ((((uint32_t)f) & 0x7) << 27))
#define BCM56504_A0_MMU_XQ27m_MH_OPCODEf_GET(r) cdk_field32_get((r).mmu_xq27,30,32)
#define BCM56504_A0_MMU_XQ27m_MH_OPCODEf_SET(r,f) cdk_field32_set((r).mmu_xq27,30,32,f)
#define BCM56504_A0_MMU_XQ27m_CLASSIFICATION_TAGf_GET(r) ((((r).mmu_xq27[1]) >> 1) & 0x7ff)
#define BCM56504_A0_MMU_XQ27m_CLASSIFICATION_TAGf_SET(r,f) (r).mmu_xq27[1]=(((r).mmu_xq27[1] & ~((uint32_t)0x7ff << 1)) | ((((uint32_t)f) & 0x7ff) << 1))
#define BCM56504_A0_MMU_XQ27m_HEADER_TYPEf_GET(r) ((((r).mmu_xq27[1]) >> 12) & 0x3)
#define BCM56504_A0_MMU_XQ27m_HEADER_TYPEf_SET(r,f) (r).mmu_xq27[1]=(((r).mmu_xq27[1] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM56504_A0_MMU_XQ27m_CNGf_GET(r) ((((r).mmu_xq27[1]) >> 14) & 0x3)
#define BCM56504_A0_MMU_XQ27m_CNGf_SET(r,f) (r).mmu_xq27[1]=(((r).mmu_xq27[1] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCM56504_A0_MMU_XQ27m_IPMC_VLAN_TBL_PTRf_GET(r) ((((r).mmu_xq27[1]) >> 16) & 0x3ff)
#define BCM56504_A0_MMU_XQ27m_IPMC_VLAN_TBL_PTRf_SET(r,f) (r).mmu_xq27[1]=(((r).mmu_xq27[1] & ~((uint32_t)0x3ff << 16)) | ((((uint32_t)f) & 0x3ff) << 16))
#define BCM56504_A0_MMU_XQ27m_PARITY_1f_GET(r) ((((r).mmu_xq27[1]) >> 26) & 0x1)
#define BCM56504_A0_MMU_XQ27m_PARITY_1f_SET(r,f) (r).mmu_xq27[1]=(((r).mmu_xq27[1] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))

/*
 * These macros can be used to access MMU_XQ27.
 *
 */
#define BCM56504_A0_READ_MMU_XQ27m(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_MMU_XQ27m,i,(m._mmu_xq27),2)
#define BCM56504_A0_WRITE_MMU_XQ27m(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_MMU_XQ27m,i,&(m._mmu_xq27),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ27m BCM56504_A0_MMU_XQ27m
#define MMU_XQ27m_MIN BCM56504_A0_MMU_XQ27m_MIN
#define MMU_XQ27m_MAX BCM56504_A0_MMU_XQ27m_MAX
#define MMU_XQ27m_CMAX(u) BCM56504_A0_MMU_XQ27m_CMAX(u)
#define MMU_XQ27m_SIZE BCM56504_A0_MMU_XQ27m_SIZE
typedef BCM56504_A0_MMU_XQ27m_t MMU_XQ27m_t;
#define MMU_XQ27m_CLR BCM56504_A0_MMU_XQ27m_CLR
#define MMU_XQ27m_SET BCM56504_A0_MMU_XQ27m_SET
#define MMU_XQ27m_GET BCM56504_A0_MMU_XQ27m_GET
#define MMU_XQ27m_PARITY_0f_GET BCM56504_A0_MMU_XQ27m_PARITY_0f_GET
#define MMU_XQ27m_PARITY_0f_SET BCM56504_A0_MMU_XQ27m_PARITY_0f_SET
#define MMU_XQ27m_L2f_GET BCM56504_A0_MMU_XQ27m_L2f_GET
#define MMU_XQ27m_L2f_SET BCM56504_A0_MMU_XQ27m_L2f_SET
#define MMU_XQ27m_PURGEf_GET BCM56504_A0_MMU_XQ27m_PURGEf_GET
#define MMU_XQ27m_PURGEf_SET BCM56504_A0_MMU_XQ27m_PURGEf_SET
#define MMU_XQ27m_PKT_PTRf_GET BCM56504_A0_MMU_XQ27m_PKT_PTRf_GET
#define MMU_XQ27m_PKT_PTRf_SET BCM56504_A0_MMU_XQ27m_PKT_PTRf_SET
#define MMU_XQ27m_L3IPMCf_GET BCM56504_A0_MMU_XQ27m_L3IPMCf_GET
#define MMU_XQ27m_L3IPMCf_SET BCM56504_A0_MMU_XQ27m_L3IPMCf_SET
#define MMU_XQ27m_IMIRRORf_GET BCM56504_A0_MMU_XQ27m_IMIRRORf_GET
#define MMU_XQ27m_IMIRRORf_SET BCM56504_A0_MMU_XQ27m_IMIRRORf_SET
#define MMU_XQ27m_EMIRRORf_GET BCM56504_A0_MMU_XQ27m_EMIRRORf_GET
#define MMU_XQ27m_EMIRRORf_SET BCM56504_A0_MMU_XQ27m_EMIRRORf_SET
#define MMU_XQ27m_MTP_INDEXf_GET BCM56504_A0_MMU_XQ27m_MTP_INDEXf_GET
#define MMU_XQ27m_MTP_INDEXf_SET BCM56504_A0_MMU_XQ27m_MTP_INDEXf_SET
#define MMU_XQ27m_MH_PRIORITYf_GET BCM56504_A0_MMU_XQ27m_MH_PRIORITYf_GET
#define MMU_XQ27m_MH_PRIORITYf_SET BCM56504_A0_MMU_XQ27m_MH_PRIORITYf_SET
#define MMU_XQ27m_MH_OPCODEf_GET BCM56504_A0_MMU_XQ27m_MH_OPCODEf_GET
#define MMU_XQ27m_MH_OPCODEf_SET BCM56504_A0_MMU_XQ27m_MH_OPCODEf_SET
#define MMU_XQ27m_CLASSIFICATION_TAGf_GET BCM56504_A0_MMU_XQ27m_CLASSIFICATION_TAGf_GET
#define MMU_XQ27m_CLASSIFICATION_TAGf_SET BCM56504_A0_MMU_XQ27m_CLASSIFICATION_TAGf_SET
#define MMU_XQ27m_HEADER_TYPEf_GET BCM56504_A0_MMU_XQ27m_HEADER_TYPEf_GET
#define MMU_XQ27m_HEADER_TYPEf_SET BCM56504_A0_MMU_XQ27m_HEADER_TYPEf_SET
#define MMU_XQ27m_CNGf_GET BCM56504_A0_MMU_XQ27m_CNGf_GET
#define MMU_XQ27m_CNGf_SET BCM56504_A0_MMU_XQ27m_CNGf_SET
#define MMU_XQ27m_IPMC_VLAN_TBL_PTRf_GET BCM56504_A0_MMU_XQ27m_IPMC_VLAN_TBL_PTRf_GET
#define MMU_XQ27m_IPMC_VLAN_TBL_PTRf_SET BCM56504_A0_MMU_XQ27m_IPMC_VLAN_TBL_PTRf_SET
#define MMU_XQ27m_PARITY_1f_GET BCM56504_A0_MMU_XQ27m_PARITY_1f_GET
#define MMU_XQ27m_PARITY_1f_SET BCM56504_A0_MMU_XQ27m_PARITY_1f_SET
#define READ_MMU_XQ27m BCM56504_A0_READ_MMU_XQ27m
#define WRITE_MMU_XQ27m BCM56504_A0_WRITE_MMU_XQ27m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MMU_XQ27m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  MMU_XQ28
 * BLOCKS:   MMU
 * DESC:     XQ28
 * SIZE:     88
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     L3IPMC           L3 IP multicast Flag
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *     MTP_INDEX        Mirror-to-Port Index
 *     MH_PRIORITY      Module Header PRIORITY
 *     MH_OPCODE        Module Header OPCode
 *     CLASSIFICATION_TAG Calssification TAG
 *     HEADER_TYPE      Module Header Type
 *     CNG              Congestion Bits
 *     MATCHED_RULE     Matched Rule Number to help out the CPU
 *     CPU_OPCODE       CPU OPCode to help out the CPU
 *     COS              Packet COS
 *     PARITY_1         Parity bit 0
 *
 ******************************************************************************/
#define BCM56504_A0_MMU_XQ28m 0x0b670000

#define BCM56504_A0_MMU_XQ28m_MIN 0
#define BCM56504_A0_MMU_XQ28m_MAX 2047
#define BCM56504_A0_MMU_XQ28m_CMAX(u) 2047
#define BCM56504_A0_MMU_XQ28m_SIZE 11

/*
 * This structure should be used to declare and program MMU_XQ28.
 *
 */
typedef union BCM56504_A0_MMU_XQ28m_s {
	uint32_t v[3];
	uint32_t mmu_xq28[3];
	uint32_t _mmu_xq28;
} BCM56504_A0_MMU_XQ28m_t;

#define BCM56504_A0_MMU_XQ28m_CLR(r) CDK_MEMSET(&((r)._mmu_xq28), 0, sizeof(BCM56504_A0_MMU_XQ28m_t))
#define BCM56504_A0_MMU_XQ28m_SET(r,i,d) (r).mmu_xq28[i] = d
#define BCM56504_A0_MMU_XQ28m_GET(r,i) (r).mmu_xq28[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MMU_XQ28m_PARITY_0f_GET(r) (((r).mmu_xq28[0]) & 0x1)
#define BCM56504_A0_MMU_XQ28m_PARITY_0f_SET(r,f) (r).mmu_xq28[0]=(((r).mmu_xq28[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_MMU_XQ28m_L2f_GET(r) ((((r).mmu_xq28[0]) >> 1) & 0x1)
#define BCM56504_A0_MMU_XQ28m_L2f_SET(r,f) (r).mmu_xq28[0]=(((r).mmu_xq28[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_MMU_XQ28m_PURGEf_GET(r) ((((r).mmu_xq28[0]) >> 2) & 0x1)
#define BCM56504_A0_MMU_XQ28m_PURGEf_SET(r,f) (r).mmu_xq28[0]=(((r).mmu_xq28[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_MMU_XQ28m_PKT_PTRf_GET(r) ((((r).mmu_xq28[0]) >> 3) & 0x3fff)
#define BCM56504_A0_MMU_XQ28m_PKT_PTRf_SET(r,f) (r).mmu_xq28[0]=(((r).mmu_xq28[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56504_A0_MMU_XQ28m_L3IPMCf_GET(r) ((((r).mmu_xq28[0]) >> 17) & 0x1)
#define BCM56504_A0_MMU_XQ28m_L3IPMCf_SET(r,f) (r).mmu_xq28[0]=(((r).mmu_xq28[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56504_A0_MMU_XQ28m_IMIRRORf_GET(r) ((((r).mmu_xq28[0]) >> 18) & 0x1)
#define BCM56504_A0_MMU_XQ28m_IMIRRORf_SET(r,f) (r).mmu_xq28[0]=(((r).mmu_xq28[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56504_A0_MMU_XQ28m_EMIRRORf_GET(r) ((((r).mmu_xq28[0]) >> 19) & 0x1)
#define BCM56504_A0_MMU_XQ28m_EMIRRORf_SET(r,f) (r).mmu_xq28[0]=(((r).mmu_xq28[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56504_A0_MMU_XQ28m_MTP_INDEXf_GET(r) ((((r).mmu_xq28[0]) >> 20) & 0x7f)
#define BCM56504_A0_MMU_XQ28m_MTP_INDEXf_SET(r,f) (r).mmu_xq28[0]=(((r).mmu_xq28[0] & ~((uint32_t)0x7f << 20)) | ((((uint32_t)f) & 0x7f) << 20))
#define BCM56504_A0_MMU_XQ28m_MH_PRIORITYf_GET(r) ((((r).mmu_xq28[0]) >> 27) & 0x7)
#define BCM56504_A0_MMU_XQ28m_MH_PRIORITYf_SET(r,f) (r).mmu_xq28[0]=(((r).mmu_xq28[0] & ~((uint32_t)0x7 << 27)) | ((((uint32_t)f) & 0x7) << 27))
#define BCM56504_A0_MMU_XQ28m_MH_OPCODEf_GET(r) cdk_field32_get((r).mmu_xq28,30,32)
#define BCM56504_A0_MMU_XQ28m_MH_OPCODEf_SET(r,f) cdk_field32_set((r).mmu_xq28,30,32,f)
#define BCM56504_A0_MMU_XQ28m_CLASSIFICATION_TAGf_GET(r) ((((r).mmu_xq28[1]) >> 1) & 0x7ff)
#define BCM56504_A0_MMU_XQ28m_CLASSIFICATION_TAGf_SET(r,f) (r).mmu_xq28[1]=(((r).mmu_xq28[1] & ~((uint32_t)0x7ff << 1)) | ((((uint32_t)f) & 0x7ff) << 1))
#define BCM56504_A0_MMU_XQ28m_HEADER_TYPEf_GET(r) ((((r).mmu_xq28[1]) >> 12) & 0x3)
#define BCM56504_A0_MMU_XQ28m_HEADER_TYPEf_SET(r,f) (r).mmu_xq28[1]=(((r).mmu_xq28[1] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM56504_A0_MMU_XQ28m_CNGf_GET(r) ((((r).mmu_xq28[1]) >> 14) & 0x3)
#define BCM56504_A0_MMU_XQ28m_CNGf_SET(r,f) (r).mmu_xq28[1]=(((r).mmu_xq28[1] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCM56504_A0_MMU_XQ28m_MATCHED_RULEf_GET(r) ((((r).mmu_xq28[1]) >> 16) & 0x7ff)
#define BCM56504_A0_MMU_XQ28m_MATCHED_RULEf_SET(r,f) (r).mmu_xq28[1]=(((r).mmu_xq28[1] & ~((uint32_t)0x7ff << 16)) | ((((uint32_t)f) & 0x7ff) << 16))
#define BCM56504_A0_MMU_XQ28m_CPU_OPCODEf_GET(r) cdk_field32_get((r).mmu_xq28,59,83)
#define BCM56504_A0_MMU_XQ28m_CPU_OPCODEf_SET(r,f) cdk_field32_set((r).mmu_xq28,59,83,f)
#define BCM56504_A0_MMU_XQ28m_COSf_GET(r) ((((r).mmu_xq28[2]) >> 20) & 0x7)
#define BCM56504_A0_MMU_XQ28m_COSf_SET(r,f) (r).mmu_xq28[2]=(((r).mmu_xq28[2] & ~((uint32_t)0x7 << 20)) | ((((uint32_t)f) & 0x7) << 20))
#define BCM56504_A0_MMU_XQ28m_PARITY_1f_GET(r) ((((r).mmu_xq28[2]) >> 23) & 0x1)
#define BCM56504_A0_MMU_XQ28m_PARITY_1f_SET(r,f) (r).mmu_xq28[2]=(((r).mmu_xq28[2] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))

/*
 * These macros can be used to access MMU_XQ28.
 *
 */
#define BCM56504_A0_READ_MMU_XQ28m(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_MMU_XQ28m,i,(m._mmu_xq28),3)
#define BCM56504_A0_WRITE_MMU_XQ28m(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_MMU_XQ28m,i,&(m._mmu_xq28),3)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ28m BCM56504_A0_MMU_XQ28m
#define MMU_XQ28m_MIN BCM56504_A0_MMU_XQ28m_MIN
#define MMU_XQ28m_MAX BCM56504_A0_MMU_XQ28m_MAX
#define MMU_XQ28m_CMAX(u) BCM56504_A0_MMU_XQ28m_CMAX(u)
#define MMU_XQ28m_SIZE BCM56504_A0_MMU_XQ28m_SIZE
typedef BCM56504_A0_MMU_XQ28m_t MMU_XQ28m_t;
#define MMU_XQ28m_CLR BCM56504_A0_MMU_XQ28m_CLR
#define MMU_XQ28m_SET BCM56504_A0_MMU_XQ28m_SET
#define MMU_XQ28m_GET BCM56504_A0_MMU_XQ28m_GET
#define MMU_XQ28m_PARITY_0f_GET BCM56504_A0_MMU_XQ28m_PARITY_0f_GET
#define MMU_XQ28m_PARITY_0f_SET BCM56504_A0_MMU_XQ28m_PARITY_0f_SET
#define MMU_XQ28m_L2f_GET BCM56504_A0_MMU_XQ28m_L2f_GET
#define MMU_XQ28m_L2f_SET BCM56504_A0_MMU_XQ28m_L2f_SET
#define MMU_XQ28m_PURGEf_GET BCM56504_A0_MMU_XQ28m_PURGEf_GET
#define MMU_XQ28m_PURGEf_SET BCM56504_A0_MMU_XQ28m_PURGEf_SET
#define MMU_XQ28m_PKT_PTRf_GET BCM56504_A0_MMU_XQ28m_PKT_PTRf_GET
#define MMU_XQ28m_PKT_PTRf_SET BCM56504_A0_MMU_XQ28m_PKT_PTRf_SET
#define MMU_XQ28m_L3IPMCf_GET BCM56504_A0_MMU_XQ28m_L3IPMCf_GET
#define MMU_XQ28m_L3IPMCf_SET BCM56504_A0_MMU_XQ28m_L3IPMCf_SET
#define MMU_XQ28m_IMIRRORf_GET BCM56504_A0_MMU_XQ28m_IMIRRORf_GET
#define MMU_XQ28m_IMIRRORf_SET BCM56504_A0_MMU_XQ28m_IMIRRORf_SET
#define MMU_XQ28m_EMIRRORf_GET BCM56504_A0_MMU_XQ28m_EMIRRORf_GET
#define MMU_XQ28m_EMIRRORf_SET BCM56504_A0_MMU_XQ28m_EMIRRORf_SET
#define MMU_XQ28m_MTP_INDEXf_GET BCM56504_A0_MMU_XQ28m_MTP_INDEXf_GET
#define MMU_XQ28m_MTP_INDEXf_SET BCM56504_A0_MMU_XQ28m_MTP_INDEXf_SET
#define MMU_XQ28m_MH_PRIORITYf_GET BCM56504_A0_MMU_XQ28m_MH_PRIORITYf_GET
#define MMU_XQ28m_MH_PRIORITYf_SET BCM56504_A0_MMU_XQ28m_MH_PRIORITYf_SET
#define MMU_XQ28m_MH_OPCODEf_GET BCM56504_A0_MMU_XQ28m_MH_OPCODEf_GET
#define MMU_XQ28m_MH_OPCODEf_SET BCM56504_A0_MMU_XQ28m_MH_OPCODEf_SET
#define MMU_XQ28m_CLASSIFICATION_TAGf_GET BCM56504_A0_MMU_XQ28m_CLASSIFICATION_TAGf_GET
#define MMU_XQ28m_CLASSIFICATION_TAGf_SET BCM56504_A0_MMU_XQ28m_CLASSIFICATION_TAGf_SET
#define MMU_XQ28m_HEADER_TYPEf_GET BCM56504_A0_MMU_XQ28m_HEADER_TYPEf_GET
#define MMU_XQ28m_HEADER_TYPEf_SET BCM56504_A0_MMU_XQ28m_HEADER_TYPEf_SET
#define MMU_XQ28m_CNGf_GET BCM56504_A0_MMU_XQ28m_CNGf_GET
#define MMU_XQ28m_CNGf_SET BCM56504_A0_MMU_XQ28m_CNGf_SET
#define MMU_XQ28m_MATCHED_RULEf_GET BCM56504_A0_MMU_XQ28m_MATCHED_RULEf_GET
#define MMU_XQ28m_MATCHED_RULEf_SET BCM56504_A0_MMU_XQ28m_MATCHED_RULEf_SET
#define MMU_XQ28m_CPU_OPCODEf_GET BCM56504_A0_MMU_XQ28m_CPU_OPCODEf_GET
#define MMU_XQ28m_CPU_OPCODEf_SET BCM56504_A0_MMU_XQ28m_CPU_OPCODEf_SET
#define MMU_XQ28m_COSf_GET BCM56504_A0_MMU_XQ28m_COSf_GET
#define MMU_XQ28m_COSf_SET BCM56504_A0_MMU_XQ28m_COSf_SET
#define MMU_XQ28m_PARITY_1f_GET BCM56504_A0_MMU_XQ28m_PARITY_1f_GET
#define MMU_XQ28m_PARITY_1f_SET BCM56504_A0_MMU_XQ28m_PARITY_1f_SET
#define READ_MMU_XQ28m BCM56504_A0_READ_MMU_XQ28m
#define WRITE_MMU_XQ28m BCM56504_A0_WRITE_MMU_XQ28m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MMU_XQ28m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  MMU_XQ3
 * BLOCKS:   MMU
 * DESC:     XQ3
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     L3IPMC           L3 IP multicast Flag
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56504_A0_MMU_XQ3m 0x0b60c000

#define BCM56504_A0_MMU_XQ3m_MIN 0
#define BCM56504_A0_MMU_XQ3m_MAX 2047
#define BCM56504_A0_MMU_XQ3m_CMAX(u) 2047
#define BCM56504_A0_MMU_XQ3m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ3.
 *
 */
typedef union BCM56504_A0_MMU_XQ3m_s {
	uint32_t v[1];
	uint32_t mmu_xq3[1];
	uint32_t _mmu_xq3;
} BCM56504_A0_MMU_XQ3m_t;

#define BCM56504_A0_MMU_XQ3m_CLR(r) (r).mmu_xq3[0] = 0
#define BCM56504_A0_MMU_XQ3m_SET(r,d) (r).mmu_xq3[0] = d
#define BCM56504_A0_MMU_XQ3m_GET(r) (r).mmu_xq3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MMU_XQ3m_PARITY_0f_GET(r) (((r).mmu_xq3[0]) & 0x1)
#define BCM56504_A0_MMU_XQ3m_PARITY_0f_SET(r,f) (r).mmu_xq3[0]=(((r).mmu_xq3[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_MMU_XQ3m_L2f_GET(r) ((((r).mmu_xq3[0]) >> 1) & 0x1)
#define BCM56504_A0_MMU_XQ3m_L2f_SET(r,f) (r).mmu_xq3[0]=(((r).mmu_xq3[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_MMU_XQ3m_PURGEf_GET(r) ((((r).mmu_xq3[0]) >> 2) & 0x1)
#define BCM56504_A0_MMU_XQ3m_PURGEf_SET(r,f) (r).mmu_xq3[0]=(((r).mmu_xq3[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_MMU_XQ3m_PKT_PTRf_GET(r) ((((r).mmu_xq3[0]) >> 3) & 0x3fff)
#define BCM56504_A0_MMU_XQ3m_PKT_PTRf_SET(r,f) (r).mmu_xq3[0]=(((r).mmu_xq3[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56504_A0_MMU_XQ3m_L3IPMCf_GET(r) ((((r).mmu_xq3[0]) >> 17) & 0x1)
#define BCM56504_A0_MMU_XQ3m_L3IPMCf_SET(r,f) (r).mmu_xq3[0]=(((r).mmu_xq3[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56504_A0_MMU_XQ3m_IMIRRORf_GET(r) ((((r).mmu_xq3[0]) >> 18) & 0x1)
#define BCM56504_A0_MMU_XQ3m_IMIRRORf_SET(r,f) (r).mmu_xq3[0]=(((r).mmu_xq3[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56504_A0_MMU_XQ3m_EMIRRORf_GET(r) ((((r).mmu_xq3[0]) >> 19) & 0x1)
#define BCM56504_A0_MMU_XQ3m_EMIRRORf_SET(r,f) (r).mmu_xq3[0]=(((r).mmu_xq3[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ3.
 *
 */
#define BCM56504_A0_READ_MMU_XQ3m(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_MMU_XQ3m,i,(m._mmu_xq3),1)
#define BCM56504_A0_WRITE_MMU_XQ3m(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_MMU_XQ3m,i,&(m._mmu_xq3),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ3m BCM56504_A0_MMU_XQ3m
#define MMU_XQ3m_MIN BCM56504_A0_MMU_XQ3m_MIN
#define MMU_XQ3m_MAX BCM56504_A0_MMU_XQ3m_MAX
#define MMU_XQ3m_CMAX(u) BCM56504_A0_MMU_XQ3m_CMAX(u)
#define MMU_XQ3m_SIZE BCM56504_A0_MMU_XQ3m_SIZE
typedef BCM56504_A0_MMU_XQ3m_t MMU_XQ3m_t;
#define MMU_XQ3m_CLR BCM56504_A0_MMU_XQ3m_CLR
#define MMU_XQ3m_SET BCM56504_A0_MMU_XQ3m_SET
#define MMU_XQ3m_GET BCM56504_A0_MMU_XQ3m_GET
#define MMU_XQ3m_PARITY_0f_GET BCM56504_A0_MMU_XQ3m_PARITY_0f_GET
#define MMU_XQ3m_PARITY_0f_SET BCM56504_A0_MMU_XQ3m_PARITY_0f_SET
#define MMU_XQ3m_L2f_GET BCM56504_A0_MMU_XQ3m_L2f_GET
#define MMU_XQ3m_L2f_SET BCM56504_A0_MMU_XQ3m_L2f_SET
#define MMU_XQ3m_PURGEf_GET BCM56504_A0_MMU_XQ3m_PURGEf_GET
#define MMU_XQ3m_PURGEf_SET BCM56504_A0_MMU_XQ3m_PURGEf_SET
#define MMU_XQ3m_PKT_PTRf_GET BCM56504_A0_MMU_XQ3m_PKT_PTRf_GET
#define MMU_XQ3m_PKT_PTRf_SET BCM56504_A0_MMU_XQ3m_PKT_PTRf_SET
#define MMU_XQ3m_L3IPMCf_GET BCM56504_A0_MMU_XQ3m_L3IPMCf_GET
#define MMU_XQ3m_L3IPMCf_SET BCM56504_A0_MMU_XQ3m_L3IPMCf_SET
#define MMU_XQ3m_IMIRRORf_GET BCM56504_A0_MMU_XQ3m_IMIRRORf_GET
#define MMU_XQ3m_IMIRRORf_SET BCM56504_A0_MMU_XQ3m_IMIRRORf_SET
#define MMU_XQ3m_EMIRRORf_GET BCM56504_A0_MMU_XQ3m_EMIRRORf_GET
#define MMU_XQ3m_EMIRRORf_SET BCM56504_A0_MMU_XQ3m_EMIRRORf_SET
#define READ_MMU_XQ3m BCM56504_A0_READ_MMU_XQ3m
#define WRITE_MMU_XQ3m BCM56504_A0_WRITE_MMU_XQ3m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MMU_XQ3m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  MMU_XQ4
 * BLOCKS:   MMU
 * DESC:     XQ4
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     L3IPMC           L3 IP multicast Flag
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56504_A0_MMU_XQ4m 0x0b610000

#define BCM56504_A0_MMU_XQ4m_MIN 0
#define BCM56504_A0_MMU_XQ4m_MAX 2047
#define BCM56504_A0_MMU_XQ4m_CMAX(u) 2047
#define BCM56504_A0_MMU_XQ4m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ4.
 *
 */
typedef union BCM56504_A0_MMU_XQ4m_s {
	uint32_t v[1];
	uint32_t mmu_xq4[1];
	uint32_t _mmu_xq4;
} BCM56504_A0_MMU_XQ4m_t;

#define BCM56504_A0_MMU_XQ4m_CLR(r) (r).mmu_xq4[0] = 0
#define BCM56504_A0_MMU_XQ4m_SET(r,d) (r).mmu_xq4[0] = d
#define BCM56504_A0_MMU_XQ4m_GET(r) (r).mmu_xq4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MMU_XQ4m_PARITY_0f_GET(r) (((r).mmu_xq4[0]) & 0x1)
#define BCM56504_A0_MMU_XQ4m_PARITY_0f_SET(r,f) (r).mmu_xq4[0]=(((r).mmu_xq4[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_MMU_XQ4m_L2f_GET(r) ((((r).mmu_xq4[0]) >> 1) & 0x1)
#define BCM56504_A0_MMU_XQ4m_L2f_SET(r,f) (r).mmu_xq4[0]=(((r).mmu_xq4[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_MMU_XQ4m_PURGEf_GET(r) ((((r).mmu_xq4[0]) >> 2) & 0x1)
#define BCM56504_A0_MMU_XQ4m_PURGEf_SET(r,f) (r).mmu_xq4[0]=(((r).mmu_xq4[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_MMU_XQ4m_PKT_PTRf_GET(r) ((((r).mmu_xq4[0]) >> 3) & 0x3fff)
#define BCM56504_A0_MMU_XQ4m_PKT_PTRf_SET(r,f) (r).mmu_xq4[0]=(((r).mmu_xq4[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56504_A0_MMU_XQ4m_L3IPMCf_GET(r) ((((r).mmu_xq4[0]) >> 17) & 0x1)
#define BCM56504_A0_MMU_XQ4m_L3IPMCf_SET(r,f) (r).mmu_xq4[0]=(((r).mmu_xq4[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56504_A0_MMU_XQ4m_IMIRRORf_GET(r) ((((r).mmu_xq4[0]) >> 18) & 0x1)
#define BCM56504_A0_MMU_XQ4m_IMIRRORf_SET(r,f) (r).mmu_xq4[0]=(((r).mmu_xq4[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56504_A0_MMU_XQ4m_EMIRRORf_GET(r) ((((r).mmu_xq4[0]) >> 19) & 0x1)
#define BCM56504_A0_MMU_XQ4m_EMIRRORf_SET(r,f) (r).mmu_xq4[0]=(((r).mmu_xq4[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ4.
 *
 */
#define BCM56504_A0_READ_MMU_XQ4m(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_MMU_XQ4m,i,(m._mmu_xq4),1)
#define BCM56504_A0_WRITE_MMU_XQ4m(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_MMU_XQ4m,i,&(m._mmu_xq4),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ4m BCM56504_A0_MMU_XQ4m
#define MMU_XQ4m_MIN BCM56504_A0_MMU_XQ4m_MIN
#define MMU_XQ4m_MAX BCM56504_A0_MMU_XQ4m_MAX
#define MMU_XQ4m_CMAX(u) BCM56504_A0_MMU_XQ4m_CMAX(u)
#define MMU_XQ4m_SIZE BCM56504_A0_MMU_XQ4m_SIZE
typedef BCM56504_A0_MMU_XQ4m_t MMU_XQ4m_t;
#define MMU_XQ4m_CLR BCM56504_A0_MMU_XQ4m_CLR
#define MMU_XQ4m_SET BCM56504_A0_MMU_XQ4m_SET
#define MMU_XQ4m_GET BCM56504_A0_MMU_XQ4m_GET
#define MMU_XQ4m_PARITY_0f_GET BCM56504_A0_MMU_XQ4m_PARITY_0f_GET
#define MMU_XQ4m_PARITY_0f_SET BCM56504_A0_MMU_XQ4m_PARITY_0f_SET
#define MMU_XQ4m_L2f_GET BCM56504_A0_MMU_XQ4m_L2f_GET
#define MMU_XQ4m_L2f_SET BCM56504_A0_MMU_XQ4m_L2f_SET
#define MMU_XQ4m_PURGEf_GET BCM56504_A0_MMU_XQ4m_PURGEf_GET
#define MMU_XQ4m_PURGEf_SET BCM56504_A0_MMU_XQ4m_PURGEf_SET
#define MMU_XQ4m_PKT_PTRf_GET BCM56504_A0_MMU_XQ4m_PKT_PTRf_GET
#define MMU_XQ4m_PKT_PTRf_SET BCM56504_A0_MMU_XQ4m_PKT_PTRf_SET
#define MMU_XQ4m_L3IPMCf_GET BCM56504_A0_MMU_XQ4m_L3IPMCf_GET
#define MMU_XQ4m_L3IPMCf_SET BCM56504_A0_MMU_XQ4m_L3IPMCf_SET
#define MMU_XQ4m_IMIRRORf_GET BCM56504_A0_MMU_XQ4m_IMIRRORf_GET
#define MMU_XQ4m_IMIRRORf_SET BCM56504_A0_MMU_XQ4m_IMIRRORf_SET
#define MMU_XQ4m_EMIRRORf_GET BCM56504_A0_MMU_XQ4m_EMIRRORf_GET
#define MMU_XQ4m_EMIRRORf_SET BCM56504_A0_MMU_XQ4m_EMIRRORf_SET
#define READ_MMU_XQ4m BCM56504_A0_READ_MMU_XQ4m
#define WRITE_MMU_XQ4m BCM56504_A0_WRITE_MMU_XQ4m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MMU_XQ4m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  MMU_XQ5
 * BLOCKS:   MMU
 * DESC:     XQ5
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     L3IPMC           L3 IP multicast Flag
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56504_A0_MMU_XQ5m 0x0b614000

#define BCM56504_A0_MMU_XQ5m_MIN 0
#define BCM56504_A0_MMU_XQ5m_MAX 2047
#define BCM56504_A0_MMU_XQ5m_CMAX(u) 2047
#define BCM56504_A0_MMU_XQ5m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ5.
 *
 */
typedef union BCM56504_A0_MMU_XQ5m_s {
	uint32_t v[1];
	uint32_t mmu_xq5[1];
	uint32_t _mmu_xq5;
} BCM56504_A0_MMU_XQ5m_t;

#define BCM56504_A0_MMU_XQ5m_CLR(r) (r).mmu_xq5[0] = 0
#define BCM56504_A0_MMU_XQ5m_SET(r,d) (r).mmu_xq5[0] = d
#define BCM56504_A0_MMU_XQ5m_GET(r) (r).mmu_xq5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MMU_XQ5m_PARITY_0f_GET(r) (((r).mmu_xq5[0]) & 0x1)
#define BCM56504_A0_MMU_XQ5m_PARITY_0f_SET(r,f) (r).mmu_xq5[0]=(((r).mmu_xq5[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_MMU_XQ5m_L2f_GET(r) ((((r).mmu_xq5[0]) >> 1) & 0x1)
#define BCM56504_A0_MMU_XQ5m_L2f_SET(r,f) (r).mmu_xq5[0]=(((r).mmu_xq5[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_MMU_XQ5m_PURGEf_GET(r) ((((r).mmu_xq5[0]) >> 2) & 0x1)
#define BCM56504_A0_MMU_XQ5m_PURGEf_SET(r,f) (r).mmu_xq5[0]=(((r).mmu_xq5[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_MMU_XQ5m_PKT_PTRf_GET(r) ((((r).mmu_xq5[0]) >> 3) & 0x3fff)
#define BCM56504_A0_MMU_XQ5m_PKT_PTRf_SET(r,f) (r).mmu_xq5[0]=(((r).mmu_xq5[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56504_A0_MMU_XQ5m_L3IPMCf_GET(r) ((((r).mmu_xq5[0]) >> 17) & 0x1)
#define BCM56504_A0_MMU_XQ5m_L3IPMCf_SET(r,f) (r).mmu_xq5[0]=(((r).mmu_xq5[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56504_A0_MMU_XQ5m_IMIRRORf_GET(r) ((((r).mmu_xq5[0]) >> 18) & 0x1)
#define BCM56504_A0_MMU_XQ5m_IMIRRORf_SET(r,f) (r).mmu_xq5[0]=(((r).mmu_xq5[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56504_A0_MMU_XQ5m_EMIRRORf_GET(r) ((((r).mmu_xq5[0]) >> 19) & 0x1)
#define BCM56504_A0_MMU_XQ5m_EMIRRORf_SET(r,f) (r).mmu_xq5[0]=(((r).mmu_xq5[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ5.
 *
 */
#define BCM56504_A0_READ_MMU_XQ5m(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_MMU_XQ5m,i,(m._mmu_xq5),1)
#define BCM56504_A0_WRITE_MMU_XQ5m(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_MMU_XQ5m,i,&(m._mmu_xq5),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ5m BCM56504_A0_MMU_XQ5m
#define MMU_XQ5m_MIN BCM56504_A0_MMU_XQ5m_MIN
#define MMU_XQ5m_MAX BCM56504_A0_MMU_XQ5m_MAX
#define MMU_XQ5m_CMAX(u) BCM56504_A0_MMU_XQ5m_CMAX(u)
#define MMU_XQ5m_SIZE BCM56504_A0_MMU_XQ5m_SIZE
typedef BCM56504_A0_MMU_XQ5m_t MMU_XQ5m_t;
#define MMU_XQ5m_CLR BCM56504_A0_MMU_XQ5m_CLR
#define MMU_XQ5m_SET BCM56504_A0_MMU_XQ5m_SET
#define MMU_XQ5m_GET BCM56504_A0_MMU_XQ5m_GET
#define MMU_XQ5m_PARITY_0f_GET BCM56504_A0_MMU_XQ5m_PARITY_0f_GET
#define MMU_XQ5m_PARITY_0f_SET BCM56504_A0_MMU_XQ5m_PARITY_0f_SET
#define MMU_XQ5m_L2f_GET BCM56504_A0_MMU_XQ5m_L2f_GET
#define MMU_XQ5m_L2f_SET BCM56504_A0_MMU_XQ5m_L2f_SET
#define MMU_XQ5m_PURGEf_GET BCM56504_A0_MMU_XQ5m_PURGEf_GET
#define MMU_XQ5m_PURGEf_SET BCM56504_A0_MMU_XQ5m_PURGEf_SET
#define MMU_XQ5m_PKT_PTRf_GET BCM56504_A0_MMU_XQ5m_PKT_PTRf_GET
#define MMU_XQ5m_PKT_PTRf_SET BCM56504_A0_MMU_XQ5m_PKT_PTRf_SET
#define MMU_XQ5m_L3IPMCf_GET BCM56504_A0_MMU_XQ5m_L3IPMCf_GET
#define MMU_XQ5m_L3IPMCf_SET BCM56504_A0_MMU_XQ5m_L3IPMCf_SET
#define MMU_XQ5m_IMIRRORf_GET BCM56504_A0_MMU_XQ5m_IMIRRORf_GET
#define MMU_XQ5m_IMIRRORf_SET BCM56504_A0_MMU_XQ5m_IMIRRORf_SET
#define MMU_XQ5m_EMIRRORf_GET BCM56504_A0_MMU_XQ5m_EMIRRORf_GET
#define MMU_XQ5m_EMIRRORf_SET BCM56504_A0_MMU_XQ5m_EMIRRORf_SET
#define READ_MMU_XQ5m BCM56504_A0_READ_MMU_XQ5m
#define WRITE_MMU_XQ5m BCM56504_A0_WRITE_MMU_XQ5m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MMU_XQ5m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  MMU_XQ6
 * BLOCKS:   MMU
 * DESC:     XQ6
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     L3IPMC           L3 IP multicast Flag
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56504_A0_MMU_XQ6m 0x0b618000

#define BCM56504_A0_MMU_XQ6m_MIN 0
#define BCM56504_A0_MMU_XQ6m_MAX 2047
#define BCM56504_A0_MMU_XQ6m_CMAX(u) 2047
#define BCM56504_A0_MMU_XQ6m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ6.
 *
 */
typedef union BCM56504_A0_MMU_XQ6m_s {
	uint32_t v[1];
	uint32_t mmu_xq6[1];
	uint32_t _mmu_xq6;
} BCM56504_A0_MMU_XQ6m_t;

#define BCM56504_A0_MMU_XQ6m_CLR(r) (r).mmu_xq6[0] = 0
#define BCM56504_A0_MMU_XQ6m_SET(r,d) (r).mmu_xq6[0] = d
#define BCM56504_A0_MMU_XQ6m_GET(r) (r).mmu_xq6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MMU_XQ6m_PARITY_0f_GET(r) (((r).mmu_xq6[0]) & 0x1)
#define BCM56504_A0_MMU_XQ6m_PARITY_0f_SET(r,f) (r).mmu_xq6[0]=(((r).mmu_xq6[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_MMU_XQ6m_L2f_GET(r) ((((r).mmu_xq6[0]) >> 1) & 0x1)
#define BCM56504_A0_MMU_XQ6m_L2f_SET(r,f) (r).mmu_xq6[0]=(((r).mmu_xq6[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_MMU_XQ6m_PURGEf_GET(r) ((((r).mmu_xq6[0]) >> 2) & 0x1)
#define BCM56504_A0_MMU_XQ6m_PURGEf_SET(r,f) (r).mmu_xq6[0]=(((r).mmu_xq6[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_MMU_XQ6m_PKT_PTRf_GET(r) ((((r).mmu_xq6[0]) >> 3) & 0x3fff)
#define BCM56504_A0_MMU_XQ6m_PKT_PTRf_SET(r,f) (r).mmu_xq6[0]=(((r).mmu_xq6[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56504_A0_MMU_XQ6m_L3IPMCf_GET(r) ((((r).mmu_xq6[0]) >> 17) & 0x1)
#define BCM56504_A0_MMU_XQ6m_L3IPMCf_SET(r,f) (r).mmu_xq6[0]=(((r).mmu_xq6[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56504_A0_MMU_XQ6m_IMIRRORf_GET(r) ((((r).mmu_xq6[0]) >> 18) & 0x1)
#define BCM56504_A0_MMU_XQ6m_IMIRRORf_SET(r,f) (r).mmu_xq6[0]=(((r).mmu_xq6[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56504_A0_MMU_XQ6m_EMIRRORf_GET(r) ((((r).mmu_xq6[0]) >> 19) & 0x1)
#define BCM56504_A0_MMU_XQ6m_EMIRRORf_SET(r,f) (r).mmu_xq6[0]=(((r).mmu_xq6[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ6.
 *
 */
#define BCM56504_A0_READ_MMU_XQ6m(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_MMU_XQ6m,i,(m._mmu_xq6),1)
#define BCM56504_A0_WRITE_MMU_XQ6m(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_MMU_XQ6m,i,&(m._mmu_xq6),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ6m BCM56504_A0_MMU_XQ6m
#define MMU_XQ6m_MIN BCM56504_A0_MMU_XQ6m_MIN
#define MMU_XQ6m_MAX BCM56504_A0_MMU_XQ6m_MAX
#define MMU_XQ6m_CMAX(u) BCM56504_A0_MMU_XQ6m_CMAX(u)
#define MMU_XQ6m_SIZE BCM56504_A0_MMU_XQ6m_SIZE
typedef BCM56504_A0_MMU_XQ6m_t MMU_XQ6m_t;
#define MMU_XQ6m_CLR BCM56504_A0_MMU_XQ6m_CLR
#define MMU_XQ6m_SET BCM56504_A0_MMU_XQ6m_SET
#define MMU_XQ6m_GET BCM56504_A0_MMU_XQ6m_GET
#define MMU_XQ6m_PARITY_0f_GET BCM56504_A0_MMU_XQ6m_PARITY_0f_GET
#define MMU_XQ6m_PARITY_0f_SET BCM56504_A0_MMU_XQ6m_PARITY_0f_SET
#define MMU_XQ6m_L2f_GET BCM56504_A0_MMU_XQ6m_L2f_GET
#define MMU_XQ6m_L2f_SET BCM56504_A0_MMU_XQ6m_L2f_SET
#define MMU_XQ6m_PURGEf_GET BCM56504_A0_MMU_XQ6m_PURGEf_GET
#define MMU_XQ6m_PURGEf_SET BCM56504_A0_MMU_XQ6m_PURGEf_SET
#define MMU_XQ6m_PKT_PTRf_GET BCM56504_A0_MMU_XQ6m_PKT_PTRf_GET
#define MMU_XQ6m_PKT_PTRf_SET BCM56504_A0_MMU_XQ6m_PKT_PTRf_SET
#define MMU_XQ6m_L3IPMCf_GET BCM56504_A0_MMU_XQ6m_L3IPMCf_GET
#define MMU_XQ6m_L3IPMCf_SET BCM56504_A0_MMU_XQ6m_L3IPMCf_SET
#define MMU_XQ6m_IMIRRORf_GET BCM56504_A0_MMU_XQ6m_IMIRRORf_GET
#define MMU_XQ6m_IMIRRORf_SET BCM56504_A0_MMU_XQ6m_IMIRRORf_SET
#define MMU_XQ6m_EMIRRORf_GET BCM56504_A0_MMU_XQ6m_EMIRRORf_GET
#define MMU_XQ6m_EMIRRORf_SET BCM56504_A0_MMU_XQ6m_EMIRRORf_SET
#define READ_MMU_XQ6m BCM56504_A0_READ_MMU_XQ6m
#define WRITE_MMU_XQ6m BCM56504_A0_WRITE_MMU_XQ6m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MMU_XQ6m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  MMU_XQ7
 * BLOCKS:   MMU
 * DESC:     XQ7
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     L3IPMC           L3 IP multicast Flag
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56504_A0_MMU_XQ7m 0x0b61c000

#define BCM56504_A0_MMU_XQ7m_MIN 0
#define BCM56504_A0_MMU_XQ7m_MAX 2047
#define BCM56504_A0_MMU_XQ7m_CMAX(u) 2047
#define BCM56504_A0_MMU_XQ7m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ7.
 *
 */
typedef union BCM56504_A0_MMU_XQ7m_s {
	uint32_t v[1];
	uint32_t mmu_xq7[1];
	uint32_t _mmu_xq7;
} BCM56504_A0_MMU_XQ7m_t;

#define BCM56504_A0_MMU_XQ7m_CLR(r) (r).mmu_xq7[0] = 0
#define BCM56504_A0_MMU_XQ7m_SET(r,d) (r).mmu_xq7[0] = d
#define BCM56504_A0_MMU_XQ7m_GET(r) (r).mmu_xq7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MMU_XQ7m_PARITY_0f_GET(r) (((r).mmu_xq7[0]) & 0x1)
#define BCM56504_A0_MMU_XQ7m_PARITY_0f_SET(r,f) (r).mmu_xq7[0]=(((r).mmu_xq7[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_MMU_XQ7m_L2f_GET(r) ((((r).mmu_xq7[0]) >> 1) & 0x1)
#define BCM56504_A0_MMU_XQ7m_L2f_SET(r,f) (r).mmu_xq7[0]=(((r).mmu_xq7[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_MMU_XQ7m_PURGEf_GET(r) ((((r).mmu_xq7[0]) >> 2) & 0x1)
#define BCM56504_A0_MMU_XQ7m_PURGEf_SET(r,f) (r).mmu_xq7[0]=(((r).mmu_xq7[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_MMU_XQ7m_PKT_PTRf_GET(r) ((((r).mmu_xq7[0]) >> 3) & 0x3fff)
#define BCM56504_A0_MMU_XQ7m_PKT_PTRf_SET(r,f) (r).mmu_xq7[0]=(((r).mmu_xq7[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56504_A0_MMU_XQ7m_L3IPMCf_GET(r) ((((r).mmu_xq7[0]) >> 17) & 0x1)
#define BCM56504_A0_MMU_XQ7m_L3IPMCf_SET(r,f) (r).mmu_xq7[0]=(((r).mmu_xq7[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56504_A0_MMU_XQ7m_IMIRRORf_GET(r) ((((r).mmu_xq7[0]) >> 18) & 0x1)
#define BCM56504_A0_MMU_XQ7m_IMIRRORf_SET(r,f) (r).mmu_xq7[0]=(((r).mmu_xq7[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56504_A0_MMU_XQ7m_EMIRRORf_GET(r) ((((r).mmu_xq7[0]) >> 19) & 0x1)
#define BCM56504_A0_MMU_XQ7m_EMIRRORf_SET(r,f) (r).mmu_xq7[0]=(((r).mmu_xq7[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ7.
 *
 */
#define BCM56504_A0_READ_MMU_XQ7m(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_MMU_XQ7m,i,(m._mmu_xq7),1)
#define BCM56504_A0_WRITE_MMU_XQ7m(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_MMU_XQ7m,i,&(m._mmu_xq7),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ7m BCM56504_A0_MMU_XQ7m
#define MMU_XQ7m_MIN BCM56504_A0_MMU_XQ7m_MIN
#define MMU_XQ7m_MAX BCM56504_A0_MMU_XQ7m_MAX
#define MMU_XQ7m_CMAX(u) BCM56504_A0_MMU_XQ7m_CMAX(u)
#define MMU_XQ7m_SIZE BCM56504_A0_MMU_XQ7m_SIZE
typedef BCM56504_A0_MMU_XQ7m_t MMU_XQ7m_t;
#define MMU_XQ7m_CLR BCM56504_A0_MMU_XQ7m_CLR
#define MMU_XQ7m_SET BCM56504_A0_MMU_XQ7m_SET
#define MMU_XQ7m_GET BCM56504_A0_MMU_XQ7m_GET
#define MMU_XQ7m_PARITY_0f_GET BCM56504_A0_MMU_XQ7m_PARITY_0f_GET
#define MMU_XQ7m_PARITY_0f_SET BCM56504_A0_MMU_XQ7m_PARITY_0f_SET
#define MMU_XQ7m_L2f_GET BCM56504_A0_MMU_XQ7m_L2f_GET
#define MMU_XQ7m_L2f_SET BCM56504_A0_MMU_XQ7m_L2f_SET
#define MMU_XQ7m_PURGEf_GET BCM56504_A0_MMU_XQ7m_PURGEf_GET
#define MMU_XQ7m_PURGEf_SET BCM56504_A0_MMU_XQ7m_PURGEf_SET
#define MMU_XQ7m_PKT_PTRf_GET BCM56504_A0_MMU_XQ7m_PKT_PTRf_GET
#define MMU_XQ7m_PKT_PTRf_SET BCM56504_A0_MMU_XQ7m_PKT_PTRf_SET
#define MMU_XQ7m_L3IPMCf_GET BCM56504_A0_MMU_XQ7m_L3IPMCf_GET
#define MMU_XQ7m_L3IPMCf_SET BCM56504_A0_MMU_XQ7m_L3IPMCf_SET
#define MMU_XQ7m_IMIRRORf_GET BCM56504_A0_MMU_XQ7m_IMIRRORf_GET
#define MMU_XQ7m_IMIRRORf_SET BCM56504_A0_MMU_XQ7m_IMIRRORf_SET
#define MMU_XQ7m_EMIRRORf_GET BCM56504_A0_MMU_XQ7m_EMIRRORf_GET
#define MMU_XQ7m_EMIRRORf_SET BCM56504_A0_MMU_XQ7m_EMIRRORf_SET
#define READ_MMU_XQ7m BCM56504_A0_READ_MMU_XQ7m
#define WRITE_MMU_XQ7m BCM56504_A0_WRITE_MMU_XQ7m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MMU_XQ7m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  MMU_XQ8
 * BLOCKS:   MMU
 * DESC:     XQ8
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     L3IPMC           L3 IP multicast Flag
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56504_A0_MMU_XQ8m 0x0b620000

#define BCM56504_A0_MMU_XQ8m_MIN 0
#define BCM56504_A0_MMU_XQ8m_MAX 2047
#define BCM56504_A0_MMU_XQ8m_CMAX(u) 2047
#define BCM56504_A0_MMU_XQ8m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ8.
 *
 */
typedef union BCM56504_A0_MMU_XQ8m_s {
	uint32_t v[1];
	uint32_t mmu_xq8[1];
	uint32_t _mmu_xq8;
} BCM56504_A0_MMU_XQ8m_t;

#define BCM56504_A0_MMU_XQ8m_CLR(r) (r).mmu_xq8[0] = 0
#define BCM56504_A0_MMU_XQ8m_SET(r,d) (r).mmu_xq8[0] = d
#define BCM56504_A0_MMU_XQ8m_GET(r) (r).mmu_xq8[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MMU_XQ8m_PARITY_0f_GET(r) (((r).mmu_xq8[0]) & 0x1)
#define BCM56504_A0_MMU_XQ8m_PARITY_0f_SET(r,f) (r).mmu_xq8[0]=(((r).mmu_xq8[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_MMU_XQ8m_L2f_GET(r) ((((r).mmu_xq8[0]) >> 1) & 0x1)
#define BCM56504_A0_MMU_XQ8m_L2f_SET(r,f) (r).mmu_xq8[0]=(((r).mmu_xq8[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_MMU_XQ8m_PURGEf_GET(r) ((((r).mmu_xq8[0]) >> 2) & 0x1)
#define BCM56504_A0_MMU_XQ8m_PURGEf_SET(r,f) (r).mmu_xq8[0]=(((r).mmu_xq8[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_MMU_XQ8m_PKT_PTRf_GET(r) ((((r).mmu_xq8[0]) >> 3) & 0x3fff)
#define BCM56504_A0_MMU_XQ8m_PKT_PTRf_SET(r,f) (r).mmu_xq8[0]=(((r).mmu_xq8[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56504_A0_MMU_XQ8m_L3IPMCf_GET(r) ((((r).mmu_xq8[0]) >> 17) & 0x1)
#define BCM56504_A0_MMU_XQ8m_L3IPMCf_SET(r,f) (r).mmu_xq8[0]=(((r).mmu_xq8[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56504_A0_MMU_XQ8m_IMIRRORf_GET(r) ((((r).mmu_xq8[0]) >> 18) & 0x1)
#define BCM56504_A0_MMU_XQ8m_IMIRRORf_SET(r,f) (r).mmu_xq8[0]=(((r).mmu_xq8[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56504_A0_MMU_XQ8m_EMIRRORf_GET(r) ((((r).mmu_xq8[0]) >> 19) & 0x1)
#define BCM56504_A0_MMU_XQ8m_EMIRRORf_SET(r,f) (r).mmu_xq8[0]=(((r).mmu_xq8[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ8.
 *
 */
#define BCM56504_A0_READ_MMU_XQ8m(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_MMU_XQ8m,i,(m._mmu_xq8),1)
#define BCM56504_A0_WRITE_MMU_XQ8m(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_MMU_XQ8m,i,&(m._mmu_xq8),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ8m BCM56504_A0_MMU_XQ8m
#define MMU_XQ8m_MIN BCM56504_A0_MMU_XQ8m_MIN
#define MMU_XQ8m_MAX BCM56504_A0_MMU_XQ8m_MAX
#define MMU_XQ8m_CMAX(u) BCM56504_A0_MMU_XQ8m_CMAX(u)
#define MMU_XQ8m_SIZE BCM56504_A0_MMU_XQ8m_SIZE
typedef BCM56504_A0_MMU_XQ8m_t MMU_XQ8m_t;
#define MMU_XQ8m_CLR BCM56504_A0_MMU_XQ8m_CLR
#define MMU_XQ8m_SET BCM56504_A0_MMU_XQ8m_SET
#define MMU_XQ8m_GET BCM56504_A0_MMU_XQ8m_GET
#define MMU_XQ8m_PARITY_0f_GET BCM56504_A0_MMU_XQ8m_PARITY_0f_GET
#define MMU_XQ8m_PARITY_0f_SET BCM56504_A0_MMU_XQ8m_PARITY_0f_SET
#define MMU_XQ8m_L2f_GET BCM56504_A0_MMU_XQ8m_L2f_GET
#define MMU_XQ8m_L2f_SET BCM56504_A0_MMU_XQ8m_L2f_SET
#define MMU_XQ8m_PURGEf_GET BCM56504_A0_MMU_XQ8m_PURGEf_GET
#define MMU_XQ8m_PURGEf_SET BCM56504_A0_MMU_XQ8m_PURGEf_SET
#define MMU_XQ8m_PKT_PTRf_GET BCM56504_A0_MMU_XQ8m_PKT_PTRf_GET
#define MMU_XQ8m_PKT_PTRf_SET BCM56504_A0_MMU_XQ8m_PKT_PTRf_SET
#define MMU_XQ8m_L3IPMCf_GET BCM56504_A0_MMU_XQ8m_L3IPMCf_GET
#define MMU_XQ8m_L3IPMCf_SET BCM56504_A0_MMU_XQ8m_L3IPMCf_SET
#define MMU_XQ8m_IMIRRORf_GET BCM56504_A0_MMU_XQ8m_IMIRRORf_GET
#define MMU_XQ8m_IMIRRORf_SET BCM56504_A0_MMU_XQ8m_IMIRRORf_SET
#define MMU_XQ8m_EMIRRORf_GET BCM56504_A0_MMU_XQ8m_EMIRRORf_GET
#define MMU_XQ8m_EMIRRORf_SET BCM56504_A0_MMU_XQ8m_EMIRRORf_SET
#define READ_MMU_XQ8m BCM56504_A0_READ_MMU_XQ8m
#define WRITE_MMU_XQ8m BCM56504_A0_WRITE_MMU_XQ8m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MMU_XQ8m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  MMU_XQ9
 * BLOCKS:   MMU
 * DESC:     XQ9
 * SIZE:     20
 * FIELDS:
 *     PARITY_0         Parity bit
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     L3IPMC           L3 IP multicast Flag
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *
 ******************************************************************************/
#define BCM56504_A0_MMU_XQ9m 0x0b624000

#define BCM56504_A0_MMU_XQ9m_MIN 0
#define BCM56504_A0_MMU_XQ9m_MAX 2047
#define BCM56504_A0_MMU_XQ9m_CMAX(u) 2047
#define BCM56504_A0_MMU_XQ9m_SIZE 3

/*
 * This structure should be used to declare and program MMU_XQ9.
 *
 */
typedef union BCM56504_A0_MMU_XQ9m_s {
	uint32_t v[1];
	uint32_t mmu_xq9[1];
	uint32_t _mmu_xq9;
} BCM56504_A0_MMU_XQ9m_t;

#define BCM56504_A0_MMU_XQ9m_CLR(r) (r).mmu_xq9[0] = 0
#define BCM56504_A0_MMU_XQ9m_SET(r,d) (r).mmu_xq9[0] = d
#define BCM56504_A0_MMU_XQ9m_GET(r) (r).mmu_xq9[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MMU_XQ9m_PARITY_0f_GET(r) (((r).mmu_xq9[0]) & 0x1)
#define BCM56504_A0_MMU_XQ9m_PARITY_0f_SET(r,f) (r).mmu_xq9[0]=(((r).mmu_xq9[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_MMU_XQ9m_L2f_GET(r) ((((r).mmu_xq9[0]) >> 1) & 0x1)
#define BCM56504_A0_MMU_XQ9m_L2f_SET(r,f) (r).mmu_xq9[0]=(((r).mmu_xq9[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_MMU_XQ9m_PURGEf_GET(r) ((((r).mmu_xq9[0]) >> 2) & 0x1)
#define BCM56504_A0_MMU_XQ9m_PURGEf_SET(r,f) (r).mmu_xq9[0]=(((r).mmu_xq9[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_MMU_XQ9m_PKT_PTRf_GET(r) ((((r).mmu_xq9[0]) >> 3) & 0x3fff)
#define BCM56504_A0_MMU_XQ9m_PKT_PTRf_SET(r,f) (r).mmu_xq9[0]=(((r).mmu_xq9[0] & ~((uint32_t)0x3fff << 3)) | ((((uint32_t)f) & 0x3fff) << 3))
#define BCM56504_A0_MMU_XQ9m_L3IPMCf_GET(r) ((((r).mmu_xq9[0]) >> 17) & 0x1)
#define BCM56504_A0_MMU_XQ9m_L3IPMCf_SET(r,f) (r).mmu_xq9[0]=(((r).mmu_xq9[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56504_A0_MMU_XQ9m_IMIRRORf_GET(r) ((((r).mmu_xq9[0]) >> 18) & 0x1)
#define BCM56504_A0_MMU_XQ9m_IMIRRORf_SET(r,f) (r).mmu_xq9[0]=(((r).mmu_xq9[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56504_A0_MMU_XQ9m_EMIRRORf_GET(r) ((((r).mmu_xq9[0]) >> 19) & 0x1)
#define BCM56504_A0_MMU_XQ9m_EMIRRORf_SET(r,f) (r).mmu_xq9[0]=(((r).mmu_xq9[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access MMU_XQ9.
 *
 */
#define BCM56504_A0_READ_MMU_XQ9m(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_MMU_XQ9m,i,(m._mmu_xq9),1)
#define BCM56504_A0_WRITE_MMU_XQ9m(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_MMU_XQ9m,i,&(m._mmu_xq9),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ9m BCM56504_A0_MMU_XQ9m
#define MMU_XQ9m_MIN BCM56504_A0_MMU_XQ9m_MIN
#define MMU_XQ9m_MAX BCM56504_A0_MMU_XQ9m_MAX
#define MMU_XQ9m_CMAX(u) BCM56504_A0_MMU_XQ9m_CMAX(u)
#define MMU_XQ9m_SIZE BCM56504_A0_MMU_XQ9m_SIZE
typedef BCM56504_A0_MMU_XQ9m_t MMU_XQ9m_t;
#define MMU_XQ9m_CLR BCM56504_A0_MMU_XQ9m_CLR
#define MMU_XQ9m_SET BCM56504_A0_MMU_XQ9m_SET
#define MMU_XQ9m_GET BCM56504_A0_MMU_XQ9m_GET
#define MMU_XQ9m_PARITY_0f_GET BCM56504_A0_MMU_XQ9m_PARITY_0f_GET
#define MMU_XQ9m_PARITY_0f_SET BCM56504_A0_MMU_XQ9m_PARITY_0f_SET
#define MMU_XQ9m_L2f_GET BCM56504_A0_MMU_XQ9m_L2f_GET
#define MMU_XQ9m_L2f_SET BCM56504_A0_MMU_XQ9m_L2f_SET
#define MMU_XQ9m_PURGEf_GET BCM56504_A0_MMU_XQ9m_PURGEf_GET
#define MMU_XQ9m_PURGEf_SET BCM56504_A0_MMU_XQ9m_PURGEf_SET
#define MMU_XQ9m_PKT_PTRf_GET BCM56504_A0_MMU_XQ9m_PKT_PTRf_GET
#define MMU_XQ9m_PKT_PTRf_SET BCM56504_A0_MMU_XQ9m_PKT_PTRf_SET
#define MMU_XQ9m_L3IPMCf_GET BCM56504_A0_MMU_XQ9m_L3IPMCf_GET
#define MMU_XQ9m_L3IPMCf_SET BCM56504_A0_MMU_XQ9m_L3IPMCf_SET
#define MMU_XQ9m_IMIRRORf_GET BCM56504_A0_MMU_XQ9m_IMIRRORf_GET
#define MMU_XQ9m_IMIRRORf_SET BCM56504_A0_MMU_XQ9m_IMIRRORf_SET
#define MMU_XQ9m_EMIRRORf_GET BCM56504_A0_MMU_XQ9m_EMIRRORf_GET
#define MMU_XQ9m_EMIRRORf_SET BCM56504_A0_MMU_XQ9m_EMIRRORf_SET
#define READ_MMU_XQ9m BCM56504_A0_READ_MMU_XQ9m
#define WRITE_MMU_XQ9m BCM56504_A0_WRITE_MMU_XQ9m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MMU_XQ9m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  MODPORT_MAP
 * BLOCKS:   IPIPE
 * DESC:     Module Port Mapping Table
 * SIZE:     6
 * FIELDS:
 *     HIGIG_PORT_BITMAP HiGig destination port bitmap
 *     HIGIG_TRUNK_OVERRIDE HiGig trunk override
 *
 ******************************************************************************/
#define BCM56504_A0_MODPORT_MAPm 0x0e750000

#define BCM56504_A0_MODPORT_MAPm_MIN 0
#define BCM56504_A0_MODPORT_MAPm_MAX 63
#define BCM56504_A0_MODPORT_MAPm_CMAX(u) 63
#define BCM56504_A0_MODPORT_MAPm_SIZE 1

/*
 * This structure should be used to declare and program MODPORT_MAP.
 *
 */
typedef union BCM56504_A0_MODPORT_MAPm_s {
	uint32_t v[1];
	uint32_t modport_map[1];
	uint32_t _modport_map;
} BCM56504_A0_MODPORT_MAPm_t;

#define BCM56504_A0_MODPORT_MAPm_CLR(r) (r).modport_map[0] = 0
#define BCM56504_A0_MODPORT_MAPm_SET(r,d) (r).modport_map[0] = d
#define BCM56504_A0_MODPORT_MAPm_GET(r) (r).modport_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_MODPORT_MAPm_HIGIG_PORT_BITMAPf_GET(r) (((r).modport_map[0]) & 0xf)
#define BCM56504_A0_MODPORT_MAPm_HIGIG_PORT_BITMAPf_SET(r,f) (r).modport_map[0]=(((r).modport_map[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56504_A0_MODPORT_MAPm_HIGIG_TRUNK_OVERRIDEf_GET(r) ((((r).modport_map[0]) >> 4) & 0x3)
#define BCM56504_A0_MODPORT_MAPm_HIGIG_TRUNK_OVERRIDEf_SET(r,f) (r).modport_map[0]=(((r).modport_map[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))

/*
 * These macros can be used to access MODPORT_MAP.
 *
 */
#define BCM56504_A0_READ_MODPORT_MAPm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_MODPORT_MAPm,i,(m._modport_map),1)
#define BCM56504_A0_WRITE_MODPORT_MAPm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_MODPORT_MAPm,i,&(m._modport_map),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MODPORT_MAPm BCM56504_A0_MODPORT_MAPm
#define MODPORT_MAPm_MIN BCM56504_A0_MODPORT_MAPm_MIN
#define MODPORT_MAPm_MAX BCM56504_A0_MODPORT_MAPm_MAX
#define MODPORT_MAPm_CMAX(u) BCM56504_A0_MODPORT_MAPm_CMAX(u)
#define MODPORT_MAPm_SIZE BCM56504_A0_MODPORT_MAPm_SIZE
typedef BCM56504_A0_MODPORT_MAPm_t MODPORT_MAPm_t;
#define MODPORT_MAPm_CLR BCM56504_A0_MODPORT_MAPm_CLR
#define MODPORT_MAPm_SET BCM56504_A0_MODPORT_MAPm_SET
#define MODPORT_MAPm_GET BCM56504_A0_MODPORT_MAPm_GET
#define MODPORT_MAPm_HIGIG_PORT_BITMAPf_GET BCM56504_A0_MODPORT_MAPm_HIGIG_PORT_BITMAPf_GET
#define MODPORT_MAPm_HIGIG_PORT_BITMAPf_SET BCM56504_A0_MODPORT_MAPm_HIGIG_PORT_BITMAPf_SET
#define MODPORT_MAPm_HIGIG_TRUNK_OVERRIDEf_GET BCM56504_A0_MODPORT_MAPm_HIGIG_TRUNK_OVERRIDEf_GET
#define MODPORT_MAPm_HIGIG_TRUNK_OVERRIDEf_SET BCM56504_A0_MODPORT_MAPm_HIGIG_TRUNK_OVERRIDEf_SET
#define READ_MODPORT_MAPm BCM56504_A0_READ_MODPORT_MAPm
#define WRITE_MODPORT_MAPm BCM56504_A0_WRITE_MODPORT_MAPm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_MODPORT_MAPm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  NONUCAST_TRUNK_BLOCK_MASK
 * BLOCKS:   IPIPE
 * DESC:     Multicast and Broadcast Trunk Block Mask Table
 * SIZE:     29
 * FIELDS:
 *     BLOCK_MASK       Multicast/broadcast trunk block mask
 *
 ******************************************************************************/
#define BCM56504_A0_NONUCAST_TRUNK_BLOCK_MASKm 0x0e760000

#define BCM56504_A0_NONUCAST_TRUNK_BLOCK_MASKm_MIN 0
#define BCM56504_A0_NONUCAST_TRUNK_BLOCK_MASKm_MAX 15
#define BCM56504_A0_NONUCAST_TRUNK_BLOCK_MASKm_CMAX(u) 15
#define BCM56504_A0_NONUCAST_TRUNK_BLOCK_MASKm_SIZE 4

/*
 * This structure should be used to declare and program NONUCAST_TRUNK_BLOCK_MASK.
 *
 */
typedef union BCM56504_A0_NONUCAST_TRUNK_BLOCK_MASKm_s {
	uint32_t v[1];
	uint32_t nonucast_trunk_block_mask[1];
	uint32_t _nonucast_trunk_block_mask;
} BCM56504_A0_NONUCAST_TRUNK_BLOCK_MASKm_t;

#define BCM56504_A0_NONUCAST_TRUNK_BLOCK_MASKm_CLR(r) (r).nonucast_trunk_block_mask[0] = 0
#define BCM56504_A0_NONUCAST_TRUNK_BLOCK_MASKm_SET(r,d) (r).nonucast_trunk_block_mask[0] = d
#define BCM56504_A0_NONUCAST_TRUNK_BLOCK_MASKm_GET(r) (r).nonucast_trunk_block_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_NONUCAST_TRUNK_BLOCK_MASKm_BLOCK_MASKf_GET(r) (((r).nonucast_trunk_block_mask[0]) & 0x1fffffff)
#define BCM56504_A0_NONUCAST_TRUNK_BLOCK_MASKm_BLOCK_MASKf_SET(r,f) (r).nonucast_trunk_block_mask[0]=(((r).nonucast_trunk_block_mask[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))

/*
 * These macros can be used to access NONUCAST_TRUNK_BLOCK_MASK.
 *
 */
#define BCM56504_A0_READ_NONUCAST_TRUNK_BLOCK_MASKm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_NONUCAST_TRUNK_BLOCK_MASKm,i,(m._nonucast_trunk_block_mask),1)
#define BCM56504_A0_WRITE_NONUCAST_TRUNK_BLOCK_MASKm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_NONUCAST_TRUNK_BLOCK_MASKm,i,&(m._nonucast_trunk_block_mask),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define NONUCAST_TRUNK_BLOCK_MASKm BCM56504_A0_NONUCAST_TRUNK_BLOCK_MASKm
#define NONUCAST_TRUNK_BLOCK_MASKm_MIN BCM56504_A0_NONUCAST_TRUNK_BLOCK_MASKm_MIN
#define NONUCAST_TRUNK_BLOCK_MASKm_MAX BCM56504_A0_NONUCAST_TRUNK_BLOCK_MASKm_MAX
#define NONUCAST_TRUNK_BLOCK_MASKm_CMAX(u) BCM56504_A0_NONUCAST_TRUNK_BLOCK_MASKm_CMAX(u)
#define NONUCAST_TRUNK_BLOCK_MASKm_SIZE BCM56504_A0_NONUCAST_TRUNK_BLOCK_MASKm_SIZE
typedef BCM56504_A0_NONUCAST_TRUNK_BLOCK_MASKm_t NONUCAST_TRUNK_BLOCK_MASKm_t;
#define NONUCAST_TRUNK_BLOCK_MASKm_CLR BCM56504_A0_NONUCAST_TRUNK_BLOCK_MASKm_CLR
#define NONUCAST_TRUNK_BLOCK_MASKm_SET BCM56504_A0_NONUCAST_TRUNK_BLOCK_MASKm_SET
#define NONUCAST_TRUNK_BLOCK_MASKm_GET BCM56504_A0_NONUCAST_TRUNK_BLOCK_MASKm_GET
#define NONUCAST_TRUNK_BLOCK_MASKm_BLOCK_MASKf_GET BCM56504_A0_NONUCAST_TRUNK_BLOCK_MASKm_BLOCK_MASKf_GET
#define NONUCAST_TRUNK_BLOCK_MASKm_BLOCK_MASKf_SET BCM56504_A0_NONUCAST_TRUNK_BLOCK_MASKm_BLOCK_MASKf_SET
#define READ_NONUCAST_TRUNK_BLOCK_MASKm BCM56504_A0_READ_NONUCAST_TRUNK_BLOCK_MASKm
#define WRITE_NONUCAST_TRUNK_BLOCK_MASKm BCM56504_A0_WRITE_NONUCAST_TRUNK_BLOCK_MASKm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_NONUCAST_TRUNK_BLOCK_MASKm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  PAUSE_CONTROL
 * BLOCKS:   GPORT0
 * DESC:     PAUSE frame timer control register
 * SIZE:     32
 * FIELDS:
 *     VALUE            Each bit in this register represents 512 bit times independent of the port speed. Values of 0 and 1 are illegal.
 *     ENABLE           Enable Extra Pause Frames.
 *
 ******************************************************************************/
#define BCM56504_A0_PAUSE_CONTROLr 0x00f00302

#define BCM56504_A0_PAUSE_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program PAUSE_CONTROL.
 *
 */
typedef union BCM56504_A0_PAUSE_CONTROLr_s {
	uint32_t v[1];
	uint32_t pause_control[1];
	uint32_t _pause_control;
} BCM56504_A0_PAUSE_CONTROLr_t;

#define BCM56504_A0_PAUSE_CONTROLr_CLR(r) (r).pause_control[0] = 0
#define BCM56504_A0_PAUSE_CONTROLr_SET(r,d) (r).pause_control[0] = d
#define BCM56504_A0_PAUSE_CONTROLr_GET(r) (r).pause_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_PAUSE_CONTROLr_VALUEf_GET(r) (((r).pause_control[0]) & 0x1ffff)
#define BCM56504_A0_PAUSE_CONTROLr_VALUEf_SET(r,f) (r).pause_control[0]=(((r).pause_control[0] & ~((uint32_t)0x1ffff)) | (((uint32_t)f) & 0x1ffff))
#define BCM56504_A0_PAUSE_CONTROLr_ENABLEf_GET(r) ((((r).pause_control[0]) >> 17) & 0x1)
#define BCM56504_A0_PAUSE_CONTROLr_ENABLEf_SET(r,f) (r).pause_control[0]=(((r).pause_control[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))

/*
 * These macros can be used to access PAUSE_CONTROL.
 *
 */
#define BCM56504_A0_READ_PAUSE_CONTROLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_PAUSE_CONTROLr,(r._pause_control))
#define BCM56504_A0_WRITE_PAUSE_CONTROLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_PAUSE_CONTROLr,&(r._pause_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PAUSE_CONTROLr BCM56504_A0_PAUSE_CONTROLr
#define PAUSE_CONTROLr_SIZE BCM56504_A0_PAUSE_CONTROLr_SIZE
typedef BCM56504_A0_PAUSE_CONTROLr_t PAUSE_CONTROLr_t;
#define PAUSE_CONTROLr_CLR BCM56504_A0_PAUSE_CONTROLr_CLR
#define PAUSE_CONTROLr_SET BCM56504_A0_PAUSE_CONTROLr_SET
#define PAUSE_CONTROLr_GET BCM56504_A0_PAUSE_CONTROLr_GET
#define PAUSE_CONTROLr_VALUEf_GET BCM56504_A0_PAUSE_CONTROLr_VALUEf_GET
#define PAUSE_CONTROLr_VALUEf_SET BCM56504_A0_PAUSE_CONTROLr_VALUEf_SET
#define PAUSE_CONTROLr_ENABLEf_GET BCM56504_A0_PAUSE_CONTROLr_ENABLEf_GET
#define PAUSE_CONTROLr_ENABLEf_SET BCM56504_A0_PAUSE_CONTROLr_ENABLEf_SET
#define READ_PAUSE_CONTROLr BCM56504_A0_READ_PAUSE_CONTROLr
#define WRITE_PAUSE_CONTROLr BCM56504_A0_WRITE_PAUSE_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_PAUSE_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  PER_PORT_AGE_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     Per Port Aging Control Register
 * SIZE:     32
 * FIELDS:
 *     TGID_PORT        trunk group or port number
 *     MODULE_ID        module id
 *     VLAN_ID          vlan id
 *     PPA_MODE         indicates selection criteria, deletion versus replacement
 *     EXCL_STATIC      exclude static entries from deletion and replacement
 *     START            initiate per port aging
 *     COMPLETE         signal per port aging is complete
 *
 ******************************************************************************/
#define BCM56504_A0_PER_PORT_AGE_CONTROLr 0x00780004

#define BCM56504_A0_PER_PORT_AGE_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program PER_PORT_AGE_CONTROL.
 *
 */
typedef union BCM56504_A0_PER_PORT_AGE_CONTROLr_s {
	uint32_t v[1];
	uint32_t per_port_age_control[1];
	uint32_t _per_port_age_control;
} BCM56504_A0_PER_PORT_AGE_CONTROLr_t;

#define BCM56504_A0_PER_PORT_AGE_CONTROLr_CLR(r) (r).per_port_age_control[0] = 0
#define BCM56504_A0_PER_PORT_AGE_CONTROLr_SET(r,d) (r).per_port_age_control[0] = d
#define BCM56504_A0_PER_PORT_AGE_CONTROLr_GET(r) (r).per_port_age_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_PER_PORT_AGE_CONTROLr_TGID_PORTf_GET(r) (((r).per_port_age_control[0]) & 0x3f)
#define BCM56504_A0_PER_PORT_AGE_CONTROLr_TGID_PORTf_SET(r,f) (r).per_port_age_control[0]=(((r).per_port_age_control[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM56504_A0_PER_PORT_AGE_CONTROLr_MODULE_IDf_GET(r) ((((r).per_port_age_control[0]) >> 6) & 0x3f)
#define BCM56504_A0_PER_PORT_AGE_CONTROLr_MODULE_IDf_SET(r,f) (r).per_port_age_control[0]=(((r).per_port_age_control[0] & ~((uint32_t)0x3f << 6)) | ((((uint32_t)f) & 0x3f) << 6))
#define BCM56504_A0_PER_PORT_AGE_CONTROLr_VLAN_IDf_GET(r) ((((r).per_port_age_control[0]) >> 12) & 0xfff)
#define BCM56504_A0_PER_PORT_AGE_CONTROLr_VLAN_IDf_SET(r,f) (r).per_port_age_control[0]=(((r).per_port_age_control[0] & ~((uint32_t)0xfff << 12)) | ((((uint32_t)f) & 0xfff) << 12))
#define BCM56504_A0_PER_PORT_AGE_CONTROLr_PPA_MODEf_GET(r) ((((r).per_port_age_control[0]) >> 24) & 0x7)
#define BCM56504_A0_PER_PORT_AGE_CONTROLr_PPA_MODEf_SET(r,f) (r).per_port_age_control[0]=(((r).per_port_age_control[0] & ~((uint32_t)0x7 << 24)) | ((((uint32_t)f) & 0x7) << 24))
#define BCM56504_A0_PER_PORT_AGE_CONTROLr_EXCL_STATICf_GET(r) ((((r).per_port_age_control[0]) >> 27) & 0x1)
#define BCM56504_A0_PER_PORT_AGE_CONTROLr_EXCL_STATICf_SET(r,f) (r).per_port_age_control[0]=(((r).per_port_age_control[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM56504_A0_PER_PORT_AGE_CONTROLr_STARTf_GET(r) ((((r).per_port_age_control[0]) >> 28) & 0x1)
#define BCM56504_A0_PER_PORT_AGE_CONTROLr_STARTf_SET(r,f) (r).per_port_age_control[0]=(((r).per_port_age_control[0] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM56504_A0_PER_PORT_AGE_CONTROLr_COMPLETEf_GET(r) ((((r).per_port_age_control[0]) >> 29) & 0x1)
#define BCM56504_A0_PER_PORT_AGE_CONTROLr_COMPLETEf_SET(r,f) (r).per_port_age_control[0]=(((r).per_port_age_control[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))

/*
 * These macros can be used to access PER_PORT_AGE_CONTROL.
 *
 */
#define BCM56504_A0_READ_PER_PORT_AGE_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_PER_PORT_AGE_CONTROLr,(r._per_port_age_control))
#define BCM56504_A0_WRITE_PER_PORT_AGE_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_PER_PORT_AGE_CONTROLr,&(r._per_port_age_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PER_PORT_AGE_CONTROLr BCM56504_A0_PER_PORT_AGE_CONTROLr
#define PER_PORT_AGE_CONTROLr_SIZE BCM56504_A0_PER_PORT_AGE_CONTROLr_SIZE
typedef BCM56504_A0_PER_PORT_AGE_CONTROLr_t PER_PORT_AGE_CONTROLr_t;
#define PER_PORT_AGE_CONTROLr_CLR BCM56504_A0_PER_PORT_AGE_CONTROLr_CLR
#define PER_PORT_AGE_CONTROLr_SET BCM56504_A0_PER_PORT_AGE_CONTROLr_SET
#define PER_PORT_AGE_CONTROLr_GET BCM56504_A0_PER_PORT_AGE_CONTROLr_GET
#define PER_PORT_AGE_CONTROLr_TGID_PORTf_GET BCM56504_A0_PER_PORT_AGE_CONTROLr_TGID_PORTf_GET
#define PER_PORT_AGE_CONTROLr_TGID_PORTf_SET BCM56504_A0_PER_PORT_AGE_CONTROLr_TGID_PORTf_SET
#define PER_PORT_AGE_CONTROLr_MODULE_IDf_GET BCM56504_A0_PER_PORT_AGE_CONTROLr_MODULE_IDf_GET
#define PER_PORT_AGE_CONTROLr_MODULE_IDf_SET BCM56504_A0_PER_PORT_AGE_CONTROLr_MODULE_IDf_SET
#define PER_PORT_AGE_CONTROLr_VLAN_IDf_GET BCM56504_A0_PER_PORT_AGE_CONTROLr_VLAN_IDf_GET
#define PER_PORT_AGE_CONTROLr_VLAN_IDf_SET BCM56504_A0_PER_PORT_AGE_CONTROLr_VLAN_IDf_SET
#define PER_PORT_AGE_CONTROLr_PPA_MODEf_GET BCM56504_A0_PER_PORT_AGE_CONTROLr_PPA_MODEf_GET
#define PER_PORT_AGE_CONTROLr_PPA_MODEf_SET BCM56504_A0_PER_PORT_AGE_CONTROLr_PPA_MODEf_SET
#define PER_PORT_AGE_CONTROLr_EXCL_STATICf_GET BCM56504_A0_PER_PORT_AGE_CONTROLr_EXCL_STATICf_GET
#define PER_PORT_AGE_CONTROLr_EXCL_STATICf_SET BCM56504_A0_PER_PORT_AGE_CONTROLr_EXCL_STATICf_SET
#define PER_PORT_AGE_CONTROLr_STARTf_GET BCM56504_A0_PER_PORT_AGE_CONTROLr_STARTf_GET
#define PER_PORT_AGE_CONTROLr_STARTf_SET BCM56504_A0_PER_PORT_AGE_CONTROLr_STARTf_SET
#define PER_PORT_AGE_CONTROLr_COMPLETEf_GET BCM56504_A0_PER_PORT_AGE_CONTROLr_COMPLETEf_GET
#define PER_PORT_AGE_CONTROLr_COMPLETEf_SET BCM56504_A0_PER_PORT_AGE_CONTROLr_COMPLETEf_SET
#define READ_PER_PORT_AGE_CONTROLr BCM56504_A0_READ_PER_PORT_AGE_CONTROLr
#define WRITE_PER_PORT_AGE_CONTROLr BCM56504_A0_WRITE_PER_PORT_AGE_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_PER_PORT_AGE_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  PER_PORT_REPL_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     Per-Port-Aging Replacement Register
 * SIZE:     32
 * FIELDS:
 *     PORT_TGID        Port_TGID value to be used in replacment.
 *     MODULE_ID        Module_Id value to be used in replacement.
 *
 ******************************************************************************/
#define BCM56504_A0_PER_PORT_REPL_CONTROLr 0x06780000

#define BCM56504_A0_PER_PORT_REPL_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program PER_PORT_REPL_CONTROL.
 *
 */
typedef union BCM56504_A0_PER_PORT_REPL_CONTROLr_s {
	uint32_t v[1];
	uint32_t per_port_repl_control[1];
	uint32_t _per_port_repl_control;
} BCM56504_A0_PER_PORT_REPL_CONTROLr_t;

#define BCM56504_A0_PER_PORT_REPL_CONTROLr_CLR(r) (r).per_port_repl_control[0] = 0
#define BCM56504_A0_PER_PORT_REPL_CONTROLr_SET(r,d) (r).per_port_repl_control[0] = d
#define BCM56504_A0_PER_PORT_REPL_CONTROLr_GET(r) (r).per_port_repl_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_PER_PORT_REPL_CONTROLr_PORT_TGIDf_GET(r) (((r).per_port_repl_control[0]) & 0x3f)
#define BCM56504_A0_PER_PORT_REPL_CONTROLr_PORT_TGIDf_SET(r,f) (r).per_port_repl_control[0]=(((r).per_port_repl_control[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM56504_A0_PER_PORT_REPL_CONTROLr_MODULE_IDf_GET(r) ((((r).per_port_repl_control[0]) >> 6) & 0x3f)
#define BCM56504_A0_PER_PORT_REPL_CONTROLr_MODULE_IDf_SET(r,f) (r).per_port_repl_control[0]=(((r).per_port_repl_control[0] & ~((uint32_t)0x3f << 6)) | ((((uint32_t)f) & 0x3f) << 6))

/*
 * These macros can be used to access PER_PORT_REPL_CONTROL.
 *
 */
#define BCM56504_A0_READ_PER_PORT_REPL_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_PER_PORT_REPL_CONTROLr,(r._per_port_repl_control))
#define BCM56504_A0_WRITE_PER_PORT_REPL_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_PER_PORT_REPL_CONTROLr,&(r._per_port_repl_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PER_PORT_REPL_CONTROLr BCM56504_A0_PER_PORT_REPL_CONTROLr
#define PER_PORT_REPL_CONTROLr_SIZE BCM56504_A0_PER_PORT_REPL_CONTROLr_SIZE
typedef BCM56504_A0_PER_PORT_REPL_CONTROLr_t PER_PORT_REPL_CONTROLr_t;
#define PER_PORT_REPL_CONTROLr_CLR BCM56504_A0_PER_PORT_REPL_CONTROLr_CLR
#define PER_PORT_REPL_CONTROLr_SET BCM56504_A0_PER_PORT_REPL_CONTROLr_SET
#define PER_PORT_REPL_CONTROLr_GET BCM56504_A0_PER_PORT_REPL_CONTROLr_GET
#define PER_PORT_REPL_CONTROLr_PORT_TGIDf_GET BCM56504_A0_PER_PORT_REPL_CONTROLr_PORT_TGIDf_GET
#define PER_PORT_REPL_CONTROLr_PORT_TGIDf_SET BCM56504_A0_PER_PORT_REPL_CONTROLr_PORT_TGIDf_SET
#define PER_PORT_REPL_CONTROLr_MODULE_IDf_GET BCM56504_A0_PER_PORT_REPL_CONTROLr_MODULE_IDf_GET
#define PER_PORT_REPL_CONTROLr_MODULE_IDf_SET BCM56504_A0_PER_PORT_REPL_CONTROLr_MODULE_IDf_SET
#define READ_PER_PORT_REPL_CONTROLr BCM56504_A0_READ_PER_PORT_REPL_CONTROLr
#define WRITE_PER_PORT_REPL_CONTROLr BCM56504_A0_WRITE_PER_PORT_REPL_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_PER_PORT_REPL_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  PKTAGINGLIMIT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     AGINGLIMITCOS0   Package aging timer limit for cos 0.Valid number from 0 to 5 to select durations stay in switch. Do not set value to 6 or 7 this may cause packet early aging. 
 *     AGINGLIMITCOS1   Package aging timer limit for cos 1.Valid number from 0 to 5 to select durations stay in switch. Do not set value to 6 or 7 this may cause packet early aging. 
 *     AGINGLIMITCOS2   Package aging timer limit for cos 2.Valid number from 0 to 5 to select durations stay in switch. Do not set value to 6 or 7 this may cause packet early aging. 
 *     AGINGLIMITCOS3   Package aging timer limit for cos 3.Valid number from 0 to 5 to select durations stay in switch. Do not set value to 6 or 7 this may cause packet early aging. 
 *     AGINGLIMITCOS4   Package aging timer limit for cos 4.Valid number from 0 to 5 to select durations stay in switch. Do not set value to 6 or 7 this may cause packet early aging. 
 *     AGINGLIMITCOS5   Package aging timer limit for cos 5.Valid number from 0 to 5 to select durations stay in switch. Do not set value to 6 or 7 this may cause packet early aging. 
 *     AGINGLIMITCOS6   Package aging timer limit for cos 6.Valid number from 0 to 5 to select durations stay in switch. Do not set value to 6 or 7 this may cause packet early aging. 
 *     AGINGLIMITCOS7   Package aging timer limit for cos 7.Valid number from 0 to 5 to select durations stay in switch. Do not set value to 6 or 7 this may cause packet early aging. 
 *
 ******************************************************************************/
#define BCM56504_A0_PKTAGINGLIMITr 0x00680014

#define BCM56504_A0_PKTAGINGLIMITr_SIZE 4

/*
 * This structure should be used to declare and program PKTAGINGLIMIT.
 *
 */
typedef union BCM56504_A0_PKTAGINGLIMITr_s {
	uint32_t v[1];
	uint32_t pktaginglimit[1];
	uint32_t _pktaginglimit;
} BCM56504_A0_PKTAGINGLIMITr_t;

#define BCM56504_A0_PKTAGINGLIMITr_CLR(r) (r).pktaginglimit[0] = 0
#define BCM56504_A0_PKTAGINGLIMITr_SET(r,d) (r).pktaginglimit[0] = d
#define BCM56504_A0_PKTAGINGLIMITr_GET(r) (r).pktaginglimit[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_PKTAGINGLIMITr_AGINGLIMITCOS0f_GET(r) (((r).pktaginglimit[0]) & 0x7)
#define BCM56504_A0_PKTAGINGLIMITr_AGINGLIMITCOS0f_SET(r,f) (r).pktaginglimit[0]=(((r).pktaginglimit[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM56504_A0_PKTAGINGLIMITr_AGINGLIMITCOS1f_GET(r) ((((r).pktaginglimit[0]) >> 3) & 0x7)
#define BCM56504_A0_PKTAGINGLIMITr_AGINGLIMITCOS1f_SET(r,f) (r).pktaginglimit[0]=(((r).pktaginglimit[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM56504_A0_PKTAGINGLIMITr_AGINGLIMITCOS2f_GET(r) ((((r).pktaginglimit[0]) >> 6) & 0x7)
#define BCM56504_A0_PKTAGINGLIMITr_AGINGLIMITCOS2f_SET(r,f) (r).pktaginglimit[0]=(((r).pktaginglimit[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM56504_A0_PKTAGINGLIMITr_AGINGLIMITCOS3f_GET(r) ((((r).pktaginglimit[0]) >> 9) & 0x7)
#define BCM56504_A0_PKTAGINGLIMITr_AGINGLIMITCOS3f_SET(r,f) (r).pktaginglimit[0]=(((r).pktaginglimit[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM56504_A0_PKTAGINGLIMITr_AGINGLIMITCOS4f_GET(r) ((((r).pktaginglimit[0]) >> 12) & 0x7)
#define BCM56504_A0_PKTAGINGLIMITr_AGINGLIMITCOS4f_SET(r,f) (r).pktaginglimit[0]=(((r).pktaginglimit[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM56504_A0_PKTAGINGLIMITr_AGINGLIMITCOS5f_GET(r) ((((r).pktaginglimit[0]) >> 15) & 0x7)
#define BCM56504_A0_PKTAGINGLIMITr_AGINGLIMITCOS5f_SET(r,f) (r).pktaginglimit[0]=(((r).pktaginglimit[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM56504_A0_PKTAGINGLIMITr_AGINGLIMITCOS6f_GET(r) ((((r).pktaginglimit[0]) >> 18) & 0x7)
#define BCM56504_A0_PKTAGINGLIMITr_AGINGLIMITCOS6f_SET(r,f) (r).pktaginglimit[0]=(((r).pktaginglimit[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM56504_A0_PKTAGINGLIMITr_AGINGLIMITCOS7f_GET(r) ((((r).pktaginglimit[0]) >> 21) & 0x7)
#define BCM56504_A0_PKTAGINGLIMITr_AGINGLIMITCOS7f_SET(r,f) (r).pktaginglimit[0]=(((r).pktaginglimit[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))

/*
 * These macros can be used to access PKTAGINGLIMIT.
 *
 */
#define BCM56504_A0_READ_PKTAGINGLIMITr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_PKTAGINGLIMITr,(r._pktaginglimit))
#define BCM56504_A0_WRITE_PKTAGINGLIMITr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_PKTAGINGLIMITr,&(r._pktaginglimit))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTAGINGLIMITr BCM56504_A0_PKTAGINGLIMITr
#define PKTAGINGLIMITr_SIZE BCM56504_A0_PKTAGINGLIMITr_SIZE
typedef BCM56504_A0_PKTAGINGLIMITr_t PKTAGINGLIMITr_t;
#define PKTAGINGLIMITr_CLR BCM56504_A0_PKTAGINGLIMITr_CLR
#define PKTAGINGLIMITr_SET BCM56504_A0_PKTAGINGLIMITr_SET
#define PKTAGINGLIMITr_GET BCM56504_A0_PKTAGINGLIMITr_GET
#define PKTAGINGLIMITr_AGINGLIMITCOS0f_GET BCM56504_A0_PKTAGINGLIMITr_AGINGLIMITCOS0f_GET
#define PKTAGINGLIMITr_AGINGLIMITCOS0f_SET BCM56504_A0_PKTAGINGLIMITr_AGINGLIMITCOS0f_SET
#define PKTAGINGLIMITr_AGINGLIMITCOS1f_GET BCM56504_A0_PKTAGINGLIMITr_AGINGLIMITCOS1f_GET
#define PKTAGINGLIMITr_AGINGLIMITCOS1f_SET BCM56504_A0_PKTAGINGLIMITr_AGINGLIMITCOS1f_SET
#define PKTAGINGLIMITr_AGINGLIMITCOS2f_GET BCM56504_A0_PKTAGINGLIMITr_AGINGLIMITCOS2f_GET
#define PKTAGINGLIMITr_AGINGLIMITCOS2f_SET BCM56504_A0_PKTAGINGLIMITr_AGINGLIMITCOS2f_SET
#define PKTAGINGLIMITr_AGINGLIMITCOS3f_GET BCM56504_A0_PKTAGINGLIMITr_AGINGLIMITCOS3f_GET
#define PKTAGINGLIMITr_AGINGLIMITCOS3f_SET BCM56504_A0_PKTAGINGLIMITr_AGINGLIMITCOS3f_SET
#define PKTAGINGLIMITr_AGINGLIMITCOS4f_GET BCM56504_A0_PKTAGINGLIMITr_AGINGLIMITCOS4f_GET
#define PKTAGINGLIMITr_AGINGLIMITCOS4f_SET BCM56504_A0_PKTAGINGLIMITr_AGINGLIMITCOS4f_SET
#define PKTAGINGLIMITr_AGINGLIMITCOS5f_GET BCM56504_A0_PKTAGINGLIMITr_AGINGLIMITCOS5f_GET
#define PKTAGINGLIMITr_AGINGLIMITCOS5f_SET BCM56504_A0_PKTAGINGLIMITr_AGINGLIMITCOS5f_SET
#define PKTAGINGLIMITr_AGINGLIMITCOS6f_GET BCM56504_A0_PKTAGINGLIMITr_AGINGLIMITCOS6f_GET
#define PKTAGINGLIMITr_AGINGLIMITCOS6f_SET BCM56504_A0_PKTAGINGLIMITr_AGINGLIMITCOS6f_SET
#define PKTAGINGLIMITr_AGINGLIMITCOS7f_GET BCM56504_A0_PKTAGINGLIMITr_AGINGLIMITCOS7f_GET
#define PKTAGINGLIMITr_AGINGLIMITCOS7f_SET BCM56504_A0_PKTAGINGLIMITr_AGINGLIMITCOS7f_SET
#define READ_PKTAGINGLIMITr BCM56504_A0_READ_PKTAGINGLIMITr
#define WRITE_PKTAGINGLIMITr BCM56504_A0_WRITE_PKTAGINGLIMITr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_PKTAGINGLIMITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  PKTAGINGTIMER
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     DURATIONSELECT   13 bits aging interval duration select registers. Duration select determines the interval at which the age timergets incremented. After DURATIONSELECT number of clock timer ticks (pulses) the age timer will be incremented by 1.Packet aging function is disabled when set this register to 0.Packet aging function is disabled by default after power-on reset.
 *     AGINGTICKSEL     Select Aging tick clock source.0: 125us clock pulse.1: 500ms clock pulse
 *
 ******************************************************************************/
#define BCM56504_A0_PKTAGINGTIMERr 0x00680013

#define BCM56504_A0_PKTAGINGTIMERr_SIZE 4

/*
 * This structure should be used to declare and program PKTAGINGTIMER.
 *
 */
typedef union BCM56504_A0_PKTAGINGTIMERr_s {
	uint32_t v[1];
	uint32_t pktagingtimer[1];
	uint32_t _pktagingtimer;
} BCM56504_A0_PKTAGINGTIMERr_t;

#define BCM56504_A0_PKTAGINGTIMERr_CLR(r) (r).pktagingtimer[0] = 0
#define BCM56504_A0_PKTAGINGTIMERr_SET(r,d) (r).pktagingtimer[0] = d
#define BCM56504_A0_PKTAGINGTIMERr_GET(r) (r).pktagingtimer[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_PKTAGINGTIMERr_DURATIONSELECTf_GET(r) (((r).pktagingtimer[0]) & 0x1fff)
#define BCM56504_A0_PKTAGINGTIMERr_DURATIONSELECTf_SET(r,f) (r).pktagingtimer[0]=(((r).pktagingtimer[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))
#define BCM56504_A0_PKTAGINGTIMERr_AGINGTICKSELf_GET(r) ((((r).pktagingtimer[0]) >> 13) & 0x1)
#define BCM56504_A0_PKTAGINGTIMERr_AGINGTICKSELf_SET(r,f) (r).pktagingtimer[0]=(((r).pktagingtimer[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))

/*
 * These macros can be used to access PKTAGINGTIMER.
 *
 */
#define BCM56504_A0_READ_PKTAGINGTIMERr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_PKTAGINGTIMERr,(r._pktagingtimer))
#define BCM56504_A0_WRITE_PKTAGINGTIMERr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_PKTAGINGTIMERr,&(r._pktagingtimer))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTAGINGTIMERr BCM56504_A0_PKTAGINGTIMERr
#define PKTAGINGTIMERr_SIZE BCM56504_A0_PKTAGINGTIMERr_SIZE
typedef BCM56504_A0_PKTAGINGTIMERr_t PKTAGINGTIMERr_t;
#define PKTAGINGTIMERr_CLR BCM56504_A0_PKTAGINGTIMERr_CLR
#define PKTAGINGTIMERr_SET BCM56504_A0_PKTAGINGTIMERr_SET
#define PKTAGINGTIMERr_GET BCM56504_A0_PKTAGINGTIMERr_GET
#define PKTAGINGTIMERr_DURATIONSELECTf_GET BCM56504_A0_PKTAGINGTIMERr_DURATIONSELECTf_GET
#define PKTAGINGTIMERr_DURATIONSELECTf_SET BCM56504_A0_PKTAGINGTIMERr_DURATIONSELECTf_SET
#define PKTAGINGTIMERr_AGINGTICKSELf_GET BCM56504_A0_PKTAGINGTIMERr_AGINGTICKSELf_GET
#define PKTAGINGTIMERr_AGINGTICKSELf_SET BCM56504_A0_PKTAGINGTIMERr_AGINGTICKSELf_SET
#define READ_PKTAGINGTIMERr BCM56504_A0_READ_PKTAGINGTIMERr
#define WRITE_PKTAGINGTIMERr BCM56504_A0_WRITE_PKTAGINGTIMERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_PKTAGINGTIMERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  PORT_TAB
 * BLOCKS:   IPIPE
 * DESC:     Port Table
 * SIZE:     68
 * FIELDS:
 *     FILTER_ENABLE    Enable Filtering
 *     VT_MISS_DROP     VLAN translation miss drop
 *     VT_ENABLE        VLAN translation enable
 *     TRUST_DSCP_V4    Ingress port is trusted port, trust incoming IPv4 DSCP
 *     TRUST_DSCP_V6    Ingress port is trusted port, trust incoming IPv6 DSCP
 *     EN_IFILTER       Enable ingress filtering
 *     MIRROR           Mirror enable
 *     CML              CPU managed learning
 *     PORT_PRI         Port default priority?
 *     IPMC_DO_VLAN     Unknown
 *     V6IPMC_ENABLE    IPv6 IPMC enable
 *     V4IPMC_ENABLE    IPv4 IPMC enable
 *     V6L3_ENABLE      IPv6 L3 enable
 *     V4L3_ENABLE      IPv4 L3 enable
 *     DROP_BPDU        when set, ingress drops BPDUs
 *     PORT_DIS_TAG     Drop all tagged packets
 *     PORT_DIS_UNTAG   Drop all untagged packets
 *     PASS_CONTROL_FRAMES Pass pause frames through without dropping
 *     SUBNET_BASED_VID_ENABLE Enable subnet-based VLANs
 *     MAC_BASED_VID_ENABLE Enable MAC-based VLANs
 *     PORT_VID         Port VLAN
 *     HIGIG_PACKET     Port is HiGig port
 *     NNI_PORT         Port is NNI port if set to 1, otherwise UNI port
 *     MAP_TAG_PKT_PRIORITY Map the incoming packet priority
 *     MY_MODID         Stacking module ID for this module
 *     OUTER_TPID       Outer (switching) VLAN
 *     VLAN_PRECEDENCE  Determine the priorities for selecting VLAN (MAC-based, subnet-based VLANs)
 *     PORT_BRIDGE      Allows L2 bridging to the incoming port
 *     IGNORE_IPMC_L2_BITMAP Set this bit to disable L2 bridging of IPMC pkts on this port
 *     IGNORE_IPMC_L3_BITMAP Set this bit to disable L3 routing of IPMC pkts on this port
 *     RESERVED         Reserved (spare) bit in the PORT_TABLE
 *
 ******************************************************************************/
#define BCM56504_A0_PORT_TABm 0x01700000

#define BCM56504_A0_PORT_TABm_MIN 0
#define BCM56504_A0_PORT_TABm_MAX 28
#define BCM56504_A0_PORT_TABm_CMAX(u) 28
#define BCM56504_A0_PORT_TABm_SIZE 9

/*
 * This structure should be used to declare and program PORT_TAB.
 *
 */
typedef union BCM56504_A0_PORT_TABm_s {
	uint32_t v[3];
	uint32_t port_tab[3];
	uint32_t _port_tab;
} BCM56504_A0_PORT_TABm_t;

#define BCM56504_A0_PORT_TABm_CLR(r) CDK_MEMSET(&((r)._port_tab), 0, sizeof(BCM56504_A0_PORT_TABm_t))
#define BCM56504_A0_PORT_TABm_SET(r,i,d) (r).port_tab[i] = d
#define BCM56504_A0_PORT_TABm_GET(r,i) (r).port_tab[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_PORT_TABm_FILTER_ENABLEf_GET(r) (((r).port_tab[0]) & 0x1)
#define BCM56504_A0_PORT_TABm_FILTER_ENABLEf_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_PORT_TABm_VT_MISS_DROPf_GET(r) ((((r).port_tab[0]) >> 1) & 0x1)
#define BCM56504_A0_PORT_TABm_VT_MISS_DROPf_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_PORT_TABm_VT_ENABLEf_GET(r) ((((r).port_tab[0]) >> 2) & 0x1)
#define BCM56504_A0_PORT_TABm_VT_ENABLEf_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_PORT_TABm_TRUST_DSCP_V4f_GET(r) ((((r).port_tab[0]) >> 3) & 0x1)
#define BCM56504_A0_PORT_TABm_TRUST_DSCP_V4f_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_PORT_TABm_TRUST_DSCP_V6f_GET(r) ((((r).port_tab[0]) >> 4) & 0x1)
#define BCM56504_A0_PORT_TABm_TRUST_DSCP_V6f_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56504_A0_PORT_TABm_EN_IFILTERf_GET(r) ((((r).port_tab[0]) >> 5) & 0x1)
#define BCM56504_A0_PORT_TABm_EN_IFILTERf_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56504_A0_PORT_TABm_MIRRORf_GET(r) ((((r).port_tab[0]) >> 6) & 0x1)
#define BCM56504_A0_PORT_TABm_MIRRORf_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56504_A0_PORT_TABm_CMLf_GET(r) ((((r).port_tab[0]) >> 7) & 0x7)
#define BCM56504_A0_PORT_TABm_CMLf_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x7 << 7)) | ((((uint32_t)f) & 0x7) << 7))
#define BCM56504_A0_PORT_TABm_PORT_PRIf_GET(r) ((((r).port_tab[0]) >> 10) & 0x7)
#define BCM56504_A0_PORT_TABm_PORT_PRIf_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10))
#define BCM56504_A0_PORT_TABm_IPMC_DO_VLANf_GET(r) ((((r).port_tab[0]) >> 13) & 0x1)
#define BCM56504_A0_PORT_TABm_IPMC_DO_VLANf_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56504_A0_PORT_TABm_V6IPMC_ENABLEf_GET(r) ((((r).port_tab[0]) >> 14) & 0x1)
#define BCM56504_A0_PORT_TABm_V6IPMC_ENABLEf_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM56504_A0_PORT_TABm_V4IPMC_ENABLEf_GET(r) ((((r).port_tab[0]) >> 15) & 0x1)
#define BCM56504_A0_PORT_TABm_V4IPMC_ENABLEf_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56504_A0_PORT_TABm_V6L3_ENABLEf_GET(r) ((((r).port_tab[0]) >> 16) & 0x1)
#define BCM56504_A0_PORT_TABm_V6L3_ENABLEf_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56504_A0_PORT_TABm_V4L3_ENABLEf_GET(r) ((((r).port_tab[0]) >> 17) & 0x1)
#define BCM56504_A0_PORT_TABm_V4L3_ENABLEf_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56504_A0_PORT_TABm_DROP_BPDUf_GET(r) ((((r).port_tab[0]) >> 18) & 0x1)
#define BCM56504_A0_PORT_TABm_DROP_BPDUf_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56504_A0_PORT_TABm_PORT_DIS_TAGf_GET(r) ((((r).port_tab[0]) >> 19) & 0x1)
#define BCM56504_A0_PORT_TABm_PORT_DIS_TAGf_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56504_A0_PORT_TABm_PORT_DIS_UNTAGf_GET(r) ((((r).port_tab[0]) >> 20) & 0x1)
#define BCM56504_A0_PORT_TABm_PORT_DIS_UNTAGf_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM56504_A0_PORT_TABm_PASS_CONTROL_FRAMESf_GET(r) ((((r).port_tab[0]) >> 21) & 0x1)
#define BCM56504_A0_PORT_TABm_PASS_CONTROL_FRAMESf_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM56504_A0_PORT_TABm_SUBNET_BASED_VID_ENABLEf_GET(r) ((((r).port_tab[0]) >> 22) & 0x1)
#define BCM56504_A0_PORT_TABm_SUBNET_BASED_VID_ENABLEf_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM56504_A0_PORT_TABm_MAC_BASED_VID_ENABLEf_GET(r) ((((r).port_tab[0]) >> 23) & 0x1)
#define BCM56504_A0_PORT_TABm_MAC_BASED_VID_ENABLEf_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM56504_A0_PORT_TABm_PORT_VIDf_GET(r) cdk_field32_get((r).port_tab,24,35)
#define BCM56504_A0_PORT_TABm_PORT_VIDf_SET(r,f) cdk_field32_set((r).port_tab,24,35,f)
#define BCM56504_A0_PORT_TABm_HIGIG_PACKETf_GET(r) ((((r).port_tab[1]) >> 4) & 0x1)
#define BCM56504_A0_PORT_TABm_HIGIG_PACKETf_SET(r,f) (r).port_tab[1]=(((r).port_tab[1] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56504_A0_PORT_TABm_NNI_PORTf_GET(r) ((((r).port_tab[1]) >> 5) & 0x1)
#define BCM56504_A0_PORT_TABm_NNI_PORTf_SET(r,f) (r).port_tab[1]=(((r).port_tab[1] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56504_A0_PORT_TABm_MAP_TAG_PKT_PRIORITYf_GET(r) ((((r).port_tab[1]) >> 6) & 0x1)
#define BCM56504_A0_PORT_TABm_MAP_TAG_PKT_PRIORITYf_SET(r,f) (r).port_tab[1]=(((r).port_tab[1] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56504_A0_PORT_TABm_MY_MODIDf_GET(r) ((((r).port_tab[1]) >> 7) & 0x3f)
#define BCM56504_A0_PORT_TABm_MY_MODIDf_SET(r,f) (r).port_tab[1]=(((r).port_tab[1] & ~((uint32_t)0x3f << 7)) | ((((uint32_t)f) & 0x3f) << 7))
#define BCM56504_A0_PORT_TABm_OUTER_TPIDf_GET(r) ((((r).port_tab[1]) >> 13) & 0xffff)
#define BCM56504_A0_PORT_TABm_OUTER_TPIDf_SET(r,f) (r).port_tab[1]=(((r).port_tab[1] & ~((uint32_t)0xffff << 13)) | ((((uint32_t)f) & 0xffff) << 13))
#define BCM56504_A0_PORT_TABm_VLAN_PRECEDENCEf_GET(r) ((((r).port_tab[1]) >> 29) & 0x1)
#define BCM56504_A0_PORT_TABm_VLAN_PRECEDENCEf_SET(r,f) (r).port_tab[1]=(((r).port_tab[1] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM56504_A0_PORT_TABm_PORT_BRIDGEf_GET(r) ((((r).port_tab[1]) >> 30) & 0x1)
#define BCM56504_A0_PORT_TABm_PORT_BRIDGEf_SET(r,f) (r).port_tab[1]=(((r).port_tab[1] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM56504_A0_PORT_TABm_IGNORE_IPMC_L2_BITMAPf_GET(r) ((((r).port_tab[1]) >> 31) & 0x1)
#define BCM56504_A0_PORT_TABm_IGNORE_IPMC_L2_BITMAPf_SET(r,f) (r).port_tab[1]=(((r).port_tab[1] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM56504_A0_PORT_TABm_IGNORE_IPMC_L3_BITMAPf_GET(r) (((r).port_tab[2]) & 0x1)
#define BCM56504_A0_PORT_TABm_IGNORE_IPMC_L3_BITMAPf_SET(r,f) (r).port_tab[2]=(((r).port_tab[2] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_PORT_TABm_RESERVEDf_GET(r) ((((r).port_tab[2]) >> 1) & 0x7)
#define BCM56504_A0_PORT_TABm_RESERVEDf_SET(r,f) (r).port_tab[2]=(((r).port_tab[2] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))

/*
 * These macros can be used to access PORT_TAB.
 *
 */
#define BCM56504_A0_READ_PORT_TABm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_PORT_TABm,i,(m._port_tab),3)
#define BCM56504_A0_WRITE_PORT_TABm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_PORT_TABm,i,&(m._port_tab),3)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_TABm BCM56504_A0_PORT_TABm
#define PORT_TABm_MIN BCM56504_A0_PORT_TABm_MIN
#define PORT_TABm_MAX BCM56504_A0_PORT_TABm_MAX
#define PORT_TABm_CMAX(u) BCM56504_A0_PORT_TABm_CMAX(u)
#define PORT_TABm_SIZE BCM56504_A0_PORT_TABm_SIZE
typedef BCM56504_A0_PORT_TABm_t PORT_TABm_t;
#define PORT_TABm_CLR BCM56504_A0_PORT_TABm_CLR
#define PORT_TABm_SET BCM56504_A0_PORT_TABm_SET
#define PORT_TABm_GET BCM56504_A0_PORT_TABm_GET
#define PORT_TABm_FILTER_ENABLEf_GET BCM56504_A0_PORT_TABm_FILTER_ENABLEf_GET
#define PORT_TABm_FILTER_ENABLEf_SET BCM56504_A0_PORT_TABm_FILTER_ENABLEf_SET
#define PORT_TABm_VT_MISS_DROPf_GET BCM56504_A0_PORT_TABm_VT_MISS_DROPf_GET
#define PORT_TABm_VT_MISS_DROPf_SET BCM56504_A0_PORT_TABm_VT_MISS_DROPf_SET
#define PORT_TABm_VT_ENABLEf_GET BCM56504_A0_PORT_TABm_VT_ENABLEf_GET
#define PORT_TABm_VT_ENABLEf_SET BCM56504_A0_PORT_TABm_VT_ENABLEf_SET
#define PORT_TABm_TRUST_DSCP_V4f_GET BCM56504_A0_PORT_TABm_TRUST_DSCP_V4f_GET
#define PORT_TABm_TRUST_DSCP_V4f_SET BCM56504_A0_PORT_TABm_TRUST_DSCP_V4f_SET
#define PORT_TABm_TRUST_DSCP_V6f_GET BCM56504_A0_PORT_TABm_TRUST_DSCP_V6f_GET
#define PORT_TABm_TRUST_DSCP_V6f_SET BCM56504_A0_PORT_TABm_TRUST_DSCP_V6f_SET
#define PORT_TABm_EN_IFILTERf_GET BCM56504_A0_PORT_TABm_EN_IFILTERf_GET
#define PORT_TABm_EN_IFILTERf_SET BCM56504_A0_PORT_TABm_EN_IFILTERf_SET
#define PORT_TABm_MIRRORf_GET BCM56504_A0_PORT_TABm_MIRRORf_GET
#define PORT_TABm_MIRRORf_SET BCM56504_A0_PORT_TABm_MIRRORf_SET
#define PORT_TABm_CMLf_GET BCM56504_A0_PORT_TABm_CMLf_GET
#define PORT_TABm_CMLf_SET BCM56504_A0_PORT_TABm_CMLf_SET
#define PORT_TABm_PORT_PRIf_GET BCM56504_A0_PORT_TABm_PORT_PRIf_GET
#define PORT_TABm_PORT_PRIf_SET BCM56504_A0_PORT_TABm_PORT_PRIf_SET
#define PORT_TABm_IPMC_DO_VLANf_GET BCM56504_A0_PORT_TABm_IPMC_DO_VLANf_GET
#define PORT_TABm_IPMC_DO_VLANf_SET BCM56504_A0_PORT_TABm_IPMC_DO_VLANf_SET
#define PORT_TABm_V6IPMC_ENABLEf_GET BCM56504_A0_PORT_TABm_V6IPMC_ENABLEf_GET
#define PORT_TABm_V6IPMC_ENABLEf_SET BCM56504_A0_PORT_TABm_V6IPMC_ENABLEf_SET
#define PORT_TABm_V4IPMC_ENABLEf_GET BCM56504_A0_PORT_TABm_V4IPMC_ENABLEf_GET
#define PORT_TABm_V4IPMC_ENABLEf_SET BCM56504_A0_PORT_TABm_V4IPMC_ENABLEf_SET
#define PORT_TABm_V6L3_ENABLEf_GET BCM56504_A0_PORT_TABm_V6L3_ENABLEf_GET
#define PORT_TABm_V6L3_ENABLEf_SET BCM56504_A0_PORT_TABm_V6L3_ENABLEf_SET
#define PORT_TABm_V4L3_ENABLEf_GET BCM56504_A0_PORT_TABm_V4L3_ENABLEf_GET
#define PORT_TABm_V4L3_ENABLEf_SET BCM56504_A0_PORT_TABm_V4L3_ENABLEf_SET
#define PORT_TABm_DROP_BPDUf_GET BCM56504_A0_PORT_TABm_DROP_BPDUf_GET
#define PORT_TABm_DROP_BPDUf_SET BCM56504_A0_PORT_TABm_DROP_BPDUf_SET
#define PORT_TABm_PORT_DIS_TAGf_GET BCM56504_A0_PORT_TABm_PORT_DIS_TAGf_GET
#define PORT_TABm_PORT_DIS_TAGf_SET BCM56504_A0_PORT_TABm_PORT_DIS_TAGf_SET
#define PORT_TABm_PORT_DIS_UNTAGf_GET BCM56504_A0_PORT_TABm_PORT_DIS_UNTAGf_GET
#define PORT_TABm_PORT_DIS_UNTAGf_SET BCM56504_A0_PORT_TABm_PORT_DIS_UNTAGf_SET
#define PORT_TABm_PASS_CONTROL_FRAMESf_GET BCM56504_A0_PORT_TABm_PASS_CONTROL_FRAMESf_GET
#define PORT_TABm_PASS_CONTROL_FRAMESf_SET BCM56504_A0_PORT_TABm_PASS_CONTROL_FRAMESf_SET
#define PORT_TABm_SUBNET_BASED_VID_ENABLEf_GET BCM56504_A0_PORT_TABm_SUBNET_BASED_VID_ENABLEf_GET
#define PORT_TABm_SUBNET_BASED_VID_ENABLEf_SET BCM56504_A0_PORT_TABm_SUBNET_BASED_VID_ENABLEf_SET
#define PORT_TABm_MAC_BASED_VID_ENABLEf_GET BCM56504_A0_PORT_TABm_MAC_BASED_VID_ENABLEf_GET
#define PORT_TABm_MAC_BASED_VID_ENABLEf_SET BCM56504_A0_PORT_TABm_MAC_BASED_VID_ENABLEf_SET
#define PORT_TABm_PORT_VIDf_GET BCM56504_A0_PORT_TABm_PORT_VIDf_GET
#define PORT_TABm_PORT_VIDf_SET BCM56504_A0_PORT_TABm_PORT_VIDf_SET
#define PORT_TABm_HIGIG_PACKETf_GET BCM56504_A0_PORT_TABm_HIGIG_PACKETf_GET
#define PORT_TABm_HIGIG_PACKETf_SET BCM56504_A0_PORT_TABm_HIGIG_PACKETf_SET
#define PORT_TABm_NNI_PORTf_GET BCM56504_A0_PORT_TABm_NNI_PORTf_GET
#define PORT_TABm_NNI_PORTf_SET BCM56504_A0_PORT_TABm_NNI_PORTf_SET
#define PORT_TABm_MAP_TAG_PKT_PRIORITYf_GET BCM56504_A0_PORT_TABm_MAP_TAG_PKT_PRIORITYf_GET
#define PORT_TABm_MAP_TAG_PKT_PRIORITYf_SET BCM56504_A0_PORT_TABm_MAP_TAG_PKT_PRIORITYf_SET
#define PORT_TABm_MY_MODIDf_GET BCM56504_A0_PORT_TABm_MY_MODIDf_GET
#define PORT_TABm_MY_MODIDf_SET BCM56504_A0_PORT_TABm_MY_MODIDf_SET
#define PORT_TABm_OUTER_TPIDf_GET BCM56504_A0_PORT_TABm_OUTER_TPIDf_GET
#define PORT_TABm_OUTER_TPIDf_SET BCM56504_A0_PORT_TABm_OUTER_TPIDf_SET
#define PORT_TABm_VLAN_PRECEDENCEf_GET BCM56504_A0_PORT_TABm_VLAN_PRECEDENCEf_GET
#define PORT_TABm_VLAN_PRECEDENCEf_SET BCM56504_A0_PORT_TABm_VLAN_PRECEDENCEf_SET
#define PORT_TABm_PORT_BRIDGEf_GET BCM56504_A0_PORT_TABm_PORT_BRIDGEf_GET
#define PORT_TABm_PORT_BRIDGEf_SET BCM56504_A0_PORT_TABm_PORT_BRIDGEf_SET
#define PORT_TABm_IGNORE_IPMC_L2_BITMAPf_GET BCM56504_A0_PORT_TABm_IGNORE_IPMC_L2_BITMAPf_GET
#define PORT_TABm_IGNORE_IPMC_L2_BITMAPf_SET BCM56504_A0_PORT_TABm_IGNORE_IPMC_L2_BITMAPf_SET
#define PORT_TABm_IGNORE_IPMC_L3_BITMAPf_GET BCM56504_A0_PORT_TABm_IGNORE_IPMC_L3_BITMAPf_GET
#define PORT_TABm_IGNORE_IPMC_L3_BITMAPf_SET BCM56504_A0_PORT_TABm_IGNORE_IPMC_L3_BITMAPf_SET
#define PORT_TABm_RESERVEDf_GET BCM56504_A0_PORT_TABm_RESERVEDf_GET
#define PORT_TABm_RESERVEDf_SET BCM56504_A0_PORT_TABm_RESERVEDf_SET
#define READ_PORT_TABm BCM56504_A0_READ_PORT_TABm
#define WRITE_PORT_TABm BCM56504_A0_WRITE_PORT_TABm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_PORT_TABm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  PPPEMPTYSTATUS
 * BLOCKS:   MMU
 * DESC:     Displays the PPP Empty status
 * SIZE:     32
 * FIELDS:
 *     PORT_BITMAP      PPP for port is empty
 *
 ******************************************************************************/
#define BCM56504_A0_PPPEMPTYSTATUSr 0x00680000

#define BCM56504_A0_PPPEMPTYSTATUSr_SIZE 4

/*
 * This structure should be used to declare and program PPPEMPTYSTATUS.
 *
 */
typedef union BCM56504_A0_PPPEMPTYSTATUSr_s {
	uint32_t v[1];
	uint32_t pppemptystatus[1];
	uint32_t _pppemptystatus;
} BCM56504_A0_PPPEMPTYSTATUSr_t;

#define BCM56504_A0_PPPEMPTYSTATUSr_CLR(r) (r).pppemptystatus[0] = 0
#define BCM56504_A0_PPPEMPTYSTATUSr_SET(r,d) (r).pppemptystatus[0] = d
#define BCM56504_A0_PPPEMPTYSTATUSr_GET(r) (r).pppemptystatus[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_PPPEMPTYSTATUSr_PORT_BITMAPf_GET(r) (((r).pppemptystatus[0]) & 0x1fffffff)
#define BCM56504_A0_PPPEMPTYSTATUSr_PORT_BITMAPf_SET(r,f) (r).pppemptystatus[0]=(((r).pppemptystatus[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))

/*
 * These macros can be used to access PPPEMPTYSTATUS.
 *
 */
#define BCM56504_A0_READ_PPPEMPTYSTATUSr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_PPPEMPTYSTATUSr,(r._pppemptystatus))
#define BCM56504_A0_WRITE_PPPEMPTYSTATUSr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_PPPEMPTYSTATUSr,&(r._pppemptystatus))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PPPEMPTYSTATUSr BCM56504_A0_PPPEMPTYSTATUSr
#define PPPEMPTYSTATUSr_SIZE BCM56504_A0_PPPEMPTYSTATUSr_SIZE
typedef BCM56504_A0_PPPEMPTYSTATUSr_t PPPEMPTYSTATUSr_t;
#define PPPEMPTYSTATUSr_CLR BCM56504_A0_PPPEMPTYSTATUSr_CLR
#define PPPEMPTYSTATUSr_SET BCM56504_A0_PPPEMPTYSTATUSr_SET
#define PPPEMPTYSTATUSr_GET BCM56504_A0_PPPEMPTYSTATUSr_GET
#define PPPEMPTYSTATUSr_PORT_BITMAPf_GET BCM56504_A0_PPPEMPTYSTATUSr_PORT_BITMAPf_GET
#define PPPEMPTYSTATUSr_PORT_BITMAPf_SET BCM56504_A0_PPPEMPTYSTATUSr_PORT_BITMAPf_SET
#define READ_PPPEMPTYSTATUSr BCM56504_A0_READ_PPPEMPTYSTATUSr
#define WRITE_PPPEMPTYSTATUSr BCM56504_A0_WRITE_PPPEMPTYSTATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_PPPEMPTYSTATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  PROTOCOL_PKT_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     Protocol Packet Control Register
 * SIZE:     32
 * FIELDS:
 *     DHCP_PKT_TO_CPU  Send DHCP Packets to the CPU
 *     DHCP_PKT_DROP    Drop DHCP Packets
 *     IPV6_RESVD_MC_PKT_TO_CPU Send IPv6 reserved multicast packets to the CPU
 *     IPV6_RESVD_MC_PKT_DROP Drop IPv6 reserved multicast packets
 *     IPV4_RESVD_MC_PKT_TO_CPU Send IPv4 reserved multicast packets to the CPU
 *     IPV4_RESVD_MC_PKT_DROP Drop IPv4 reserved multicast packets
 *     MLD_PKT_TO_CPU   Send MLD Packets to the CPU
 *     MLD_PKT_DROP     Drop MLD Packets
 *     IGMP_PKT_TO_CPU  Send IGMP Packets to the CPU
 *     IGMP_PKT_DROP    Drop IGMP Packets
 *     ND_PKT_TO_CPU    Send ND Packets to the CPU
 *     ND_PKT_DROP      Drop ND Packets
 *     ARP_REQUEST_TO_CPU Send ARP Request Packets to the CPU
 *     ARP_REQUEST_DROP Drop ARP Request Packets
 *     ARP_REPLY_TO_CPU Send ARP Reply Packets to the CPU
 *     ARP_REPLY_DROP   Drop ARP Reply Packets
 *
 ******************************************************************************/
#define BCM56504_A0_PROTOCOL_PKT_CONTROLr 0x0b700006

#define BCM56504_A0_PROTOCOL_PKT_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program PROTOCOL_PKT_CONTROL.
 *
 */
typedef union BCM56504_A0_PROTOCOL_PKT_CONTROLr_s {
	uint32_t v[1];
	uint32_t protocol_pkt_control[1];
	uint32_t _protocol_pkt_control;
} BCM56504_A0_PROTOCOL_PKT_CONTROLr_t;

#define BCM56504_A0_PROTOCOL_PKT_CONTROLr_CLR(r) (r).protocol_pkt_control[0] = 0
#define BCM56504_A0_PROTOCOL_PKT_CONTROLr_SET(r,d) (r).protocol_pkt_control[0] = d
#define BCM56504_A0_PROTOCOL_PKT_CONTROLr_GET(r) (r).protocol_pkt_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_PROTOCOL_PKT_CONTROLr_DHCP_PKT_TO_CPUf_GET(r) (((r).protocol_pkt_control[0]) & 0x1)
#define BCM56504_A0_PROTOCOL_PKT_CONTROLr_DHCP_PKT_TO_CPUf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_PROTOCOL_PKT_CONTROLr_DHCP_PKT_DROPf_GET(r) ((((r).protocol_pkt_control[0]) >> 1) & 0x1)
#define BCM56504_A0_PROTOCOL_PKT_CONTROLr_DHCP_PKT_DROPf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_PROTOCOL_PKT_CONTROLr_IPV6_RESVD_MC_PKT_TO_CPUf_GET(r) ((((r).protocol_pkt_control[0]) >> 2) & 0x1)
#define BCM56504_A0_PROTOCOL_PKT_CONTROLr_IPV6_RESVD_MC_PKT_TO_CPUf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_PROTOCOL_PKT_CONTROLr_IPV6_RESVD_MC_PKT_DROPf_GET(r) ((((r).protocol_pkt_control[0]) >> 3) & 0x1)
#define BCM56504_A0_PROTOCOL_PKT_CONTROLr_IPV6_RESVD_MC_PKT_DROPf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_PROTOCOL_PKT_CONTROLr_IPV4_RESVD_MC_PKT_TO_CPUf_GET(r) ((((r).protocol_pkt_control[0]) >> 4) & 0x1)
#define BCM56504_A0_PROTOCOL_PKT_CONTROLr_IPV4_RESVD_MC_PKT_TO_CPUf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56504_A0_PROTOCOL_PKT_CONTROLr_IPV4_RESVD_MC_PKT_DROPf_GET(r) ((((r).protocol_pkt_control[0]) >> 5) & 0x1)
#define BCM56504_A0_PROTOCOL_PKT_CONTROLr_IPV4_RESVD_MC_PKT_DROPf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56504_A0_PROTOCOL_PKT_CONTROLr_MLD_PKT_TO_CPUf_GET(r) ((((r).protocol_pkt_control[0]) >> 6) & 0x1)
#define BCM56504_A0_PROTOCOL_PKT_CONTROLr_MLD_PKT_TO_CPUf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56504_A0_PROTOCOL_PKT_CONTROLr_MLD_PKT_DROPf_GET(r) ((((r).protocol_pkt_control[0]) >> 7) & 0x1)
#define BCM56504_A0_PROTOCOL_PKT_CONTROLr_MLD_PKT_DROPf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56504_A0_PROTOCOL_PKT_CONTROLr_IGMP_PKT_TO_CPUf_GET(r) ((((r).protocol_pkt_control[0]) >> 8) & 0x1)
#define BCM56504_A0_PROTOCOL_PKT_CONTROLr_IGMP_PKT_TO_CPUf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56504_A0_PROTOCOL_PKT_CONTROLr_IGMP_PKT_DROPf_GET(r) ((((r).protocol_pkt_control[0]) >> 9) & 0x1)
#define BCM56504_A0_PROTOCOL_PKT_CONTROLr_IGMP_PKT_DROPf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56504_A0_PROTOCOL_PKT_CONTROLr_ND_PKT_TO_CPUf_GET(r) ((((r).protocol_pkt_control[0]) >> 10) & 0x1)
#define BCM56504_A0_PROTOCOL_PKT_CONTROLr_ND_PKT_TO_CPUf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56504_A0_PROTOCOL_PKT_CONTROLr_ND_PKT_DROPf_GET(r) ((((r).protocol_pkt_control[0]) >> 11) & 0x1)
#define BCM56504_A0_PROTOCOL_PKT_CONTROLr_ND_PKT_DROPf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56504_A0_PROTOCOL_PKT_CONTROLr_ARP_REQUEST_TO_CPUf_GET(r) ((((r).protocol_pkt_control[0]) >> 12) & 0x1)
#define BCM56504_A0_PROTOCOL_PKT_CONTROLr_ARP_REQUEST_TO_CPUf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM56504_A0_PROTOCOL_PKT_CONTROLr_ARP_REQUEST_DROPf_GET(r) ((((r).protocol_pkt_control[0]) >> 13) & 0x1)
#define BCM56504_A0_PROTOCOL_PKT_CONTROLr_ARP_REQUEST_DROPf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56504_A0_PROTOCOL_PKT_CONTROLr_ARP_REPLY_TO_CPUf_GET(r) ((((r).protocol_pkt_control[0]) >> 14) & 0x1)
#define BCM56504_A0_PROTOCOL_PKT_CONTROLr_ARP_REPLY_TO_CPUf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM56504_A0_PROTOCOL_PKT_CONTROLr_ARP_REPLY_DROPf_GET(r) ((((r).protocol_pkt_control[0]) >> 15) & 0x1)
#define BCM56504_A0_PROTOCOL_PKT_CONTROLr_ARP_REPLY_DROPf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access PROTOCOL_PKT_CONTROL.
 *
 */
#define BCM56504_A0_READ_PROTOCOL_PKT_CONTROLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_PROTOCOL_PKT_CONTROLr,(r._protocol_pkt_control))
#define BCM56504_A0_WRITE_PROTOCOL_PKT_CONTROLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_PROTOCOL_PKT_CONTROLr,&(r._protocol_pkt_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PROTOCOL_PKT_CONTROLr BCM56504_A0_PROTOCOL_PKT_CONTROLr
#define PROTOCOL_PKT_CONTROLr_SIZE BCM56504_A0_PROTOCOL_PKT_CONTROLr_SIZE
typedef BCM56504_A0_PROTOCOL_PKT_CONTROLr_t PROTOCOL_PKT_CONTROLr_t;
#define PROTOCOL_PKT_CONTROLr_CLR BCM56504_A0_PROTOCOL_PKT_CONTROLr_CLR
#define PROTOCOL_PKT_CONTROLr_SET BCM56504_A0_PROTOCOL_PKT_CONTROLr_SET
#define PROTOCOL_PKT_CONTROLr_GET BCM56504_A0_PROTOCOL_PKT_CONTROLr_GET
#define PROTOCOL_PKT_CONTROLr_DHCP_PKT_TO_CPUf_GET BCM56504_A0_PROTOCOL_PKT_CONTROLr_DHCP_PKT_TO_CPUf_GET
#define PROTOCOL_PKT_CONTROLr_DHCP_PKT_TO_CPUf_SET BCM56504_A0_PROTOCOL_PKT_CONTROLr_DHCP_PKT_TO_CPUf_SET
#define PROTOCOL_PKT_CONTROLr_DHCP_PKT_DROPf_GET BCM56504_A0_PROTOCOL_PKT_CONTROLr_DHCP_PKT_DROPf_GET
#define PROTOCOL_PKT_CONTROLr_DHCP_PKT_DROPf_SET BCM56504_A0_PROTOCOL_PKT_CONTROLr_DHCP_PKT_DROPf_SET
#define PROTOCOL_PKT_CONTROLr_IPV6_RESVD_MC_PKT_TO_CPUf_GET BCM56504_A0_PROTOCOL_PKT_CONTROLr_IPV6_RESVD_MC_PKT_TO_CPUf_GET
#define PROTOCOL_PKT_CONTROLr_IPV6_RESVD_MC_PKT_TO_CPUf_SET BCM56504_A0_PROTOCOL_PKT_CONTROLr_IPV6_RESVD_MC_PKT_TO_CPUf_SET
#define PROTOCOL_PKT_CONTROLr_IPV6_RESVD_MC_PKT_DROPf_GET BCM56504_A0_PROTOCOL_PKT_CONTROLr_IPV6_RESVD_MC_PKT_DROPf_GET
#define PROTOCOL_PKT_CONTROLr_IPV6_RESVD_MC_PKT_DROPf_SET BCM56504_A0_PROTOCOL_PKT_CONTROLr_IPV6_RESVD_MC_PKT_DROPf_SET
#define PROTOCOL_PKT_CONTROLr_IPV4_RESVD_MC_PKT_TO_CPUf_GET BCM56504_A0_PROTOCOL_PKT_CONTROLr_IPV4_RESVD_MC_PKT_TO_CPUf_GET
#define PROTOCOL_PKT_CONTROLr_IPV4_RESVD_MC_PKT_TO_CPUf_SET BCM56504_A0_PROTOCOL_PKT_CONTROLr_IPV4_RESVD_MC_PKT_TO_CPUf_SET
#define PROTOCOL_PKT_CONTROLr_IPV4_RESVD_MC_PKT_DROPf_GET BCM56504_A0_PROTOCOL_PKT_CONTROLr_IPV4_RESVD_MC_PKT_DROPf_GET
#define PROTOCOL_PKT_CONTROLr_IPV4_RESVD_MC_PKT_DROPf_SET BCM56504_A0_PROTOCOL_PKT_CONTROLr_IPV4_RESVD_MC_PKT_DROPf_SET
#define PROTOCOL_PKT_CONTROLr_MLD_PKT_TO_CPUf_GET BCM56504_A0_PROTOCOL_PKT_CONTROLr_MLD_PKT_TO_CPUf_GET
#define PROTOCOL_PKT_CONTROLr_MLD_PKT_TO_CPUf_SET BCM56504_A0_PROTOCOL_PKT_CONTROLr_MLD_PKT_TO_CPUf_SET
#define PROTOCOL_PKT_CONTROLr_MLD_PKT_DROPf_GET BCM56504_A0_PROTOCOL_PKT_CONTROLr_MLD_PKT_DROPf_GET
#define PROTOCOL_PKT_CONTROLr_MLD_PKT_DROPf_SET BCM56504_A0_PROTOCOL_PKT_CONTROLr_MLD_PKT_DROPf_SET
#define PROTOCOL_PKT_CONTROLr_IGMP_PKT_TO_CPUf_GET BCM56504_A0_PROTOCOL_PKT_CONTROLr_IGMP_PKT_TO_CPUf_GET
#define PROTOCOL_PKT_CONTROLr_IGMP_PKT_TO_CPUf_SET BCM56504_A0_PROTOCOL_PKT_CONTROLr_IGMP_PKT_TO_CPUf_SET
#define PROTOCOL_PKT_CONTROLr_IGMP_PKT_DROPf_GET BCM56504_A0_PROTOCOL_PKT_CONTROLr_IGMP_PKT_DROPf_GET
#define PROTOCOL_PKT_CONTROLr_IGMP_PKT_DROPf_SET BCM56504_A0_PROTOCOL_PKT_CONTROLr_IGMP_PKT_DROPf_SET
#define PROTOCOL_PKT_CONTROLr_ND_PKT_TO_CPUf_GET BCM56504_A0_PROTOCOL_PKT_CONTROLr_ND_PKT_TO_CPUf_GET
#define PROTOCOL_PKT_CONTROLr_ND_PKT_TO_CPUf_SET BCM56504_A0_PROTOCOL_PKT_CONTROLr_ND_PKT_TO_CPUf_SET
#define PROTOCOL_PKT_CONTROLr_ND_PKT_DROPf_GET BCM56504_A0_PROTOCOL_PKT_CONTROLr_ND_PKT_DROPf_GET
#define PROTOCOL_PKT_CONTROLr_ND_PKT_DROPf_SET BCM56504_A0_PROTOCOL_PKT_CONTROLr_ND_PKT_DROPf_SET
#define PROTOCOL_PKT_CONTROLr_ARP_REQUEST_TO_CPUf_GET BCM56504_A0_PROTOCOL_PKT_CONTROLr_ARP_REQUEST_TO_CPUf_GET
#define PROTOCOL_PKT_CONTROLr_ARP_REQUEST_TO_CPUf_SET BCM56504_A0_PROTOCOL_PKT_CONTROLr_ARP_REQUEST_TO_CPUf_SET
#define PROTOCOL_PKT_CONTROLr_ARP_REQUEST_DROPf_GET BCM56504_A0_PROTOCOL_PKT_CONTROLr_ARP_REQUEST_DROPf_GET
#define PROTOCOL_PKT_CONTROLr_ARP_REQUEST_DROPf_SET BCM56504_A0_PROTOCOL_PKT_CONTROLr_ARP_REQUEST_DROPf_SET
#define PROTOCOL_PKT_CONTROLr_ARP_REPLY_TO_CPUf_GET BCM56504_A0_PROTOCOL_PKT_CONTROLr_ARP_REPLY_TO_CPUf_GET
#define PROTOCOL_PKT_CONTROLr_ARP_REPLY_TO_CPUf_SET BCM56504_A0_PROTOCOL_PKT_CONTROLr_ARP_REPLY_TO_CPUf_SET
#define PROTOCOL_PKT_CONTROLr_ARP_REPLY_DROPf_GET BCM56504_A0_PROTOCOL_PKT_CONTROLr_ARP_REPLY_DROPf_GET
#define PROTOCOL_PKT_CONTROLr_ARP_REPLY_DROPf_SET BCM56504_A0_PROTOCOL_PKT_CONTROLr_ARP_REPLY_DROPf_SET
#define READ_PROTOCOL_PKT_CONTROLr BCM56504_A0_READ_PROTOCOL_PKT_CONTROLr
#define WRITE_PROTOCOL_PKT_CONTROLr BCM56504_A0_WRITE_PROTOCOL_PKT_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_PROTOCOL_PKT_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  RDBGC0
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #0
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_RDBGC0r 0x0e70000b

#define BCM56504_A0_RDBGC0r_SIZE 4

/*
 * This structure should be used to declare and program RDBGC0.
 *
 */
typedef union BCM56504_A0_RDBGC0r_s {
	uint32_t v[1];
	uint32_t rdbgc0[1];
	uint32_t _rdbgc0;
} BCM56504_A0_RDBGC0r_t;

#define BCM56504_A0_RDBGC0r_CLR(r) (r).rdbgc0[0] = 0
#define BCM56504_A0_RDBGC0r_SET(r,d) (r).rdbgc0[0] = d
#define BCM56504_A0_RDBGC0r_GET(r) (r).rdbgc0[0]


/*
 * These macros can be used to access RDBGC0.
 *
 */
#define BCM56504_A0_READ_RDBGC0r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_RDBGC0r,(r._rdbgc0))
#define BCM56504_A0_WRITE_RDBGC0r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_RDBGC0r,&(r._rdbgc0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC0r BCM56504_A0_RDBGC0r
#define RDBGC0r_SIZE BCM56504_A0_RDBGC0r_SIZE
typedef BCM56504_A0_RDBGC0r_t RDBGC0r_t;
#define RDBGC0r_CLR BCM56504_A0_RDBGC0r_CLR
#define RDBGC0r_SET BCM56504_A0_RDBGC0r_SET
#define RDBGC0r_GET BCM56504_A0_RDBGC0r_GET
#define READ_RDBGC0r BCM56504_A0_READ_RDBGC0r
#define WRITE_RDBGC0r BCM56504_A0_WRITE_RDBGC0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_RDBGC0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  RDBGC0_SELECT
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #0 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The RDBGC0_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM56504_A0_RDBGC0_SELECTr 0x0e780020

#define BCM56504_A0_RDBGC0_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program RDBGC0_SELECT.
 *
 */
typedef union BCM56504_A0_RDBGC0_SELECTr_s {
	uint32_t v[1];
	uint32_t rdbgc0_select[1];
	uint32_t _rdbgc0_select;
} BCM56504_A0_RDBGC0_SELECTr_t;

#define BCM56504_A0_RDBGC0_SELECTr_CLR(r) (r).rdbgc0_select[0] = 0
#define BCM56504_A0_RDBGC0_SELECTr_SET(r,d) (r).rdbgc0_select[0] = d
#define BCM56504_A0_RDBGC0_SELECTr_GET(r) (r).rdbgc0_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_RDBGC0_SELECTr_BITMAPf_GET(r) (((r).rdbgc0_select[0]) & 0x7ffffff)
#define BCM56504_A0_RDBGC0_SELECTr_BITMAPf_SET(r,f) (r).rdbgc0_select[0]=(((r).rdbgc0_select[0] & ~((uint32_t)0x7ffffff)) | (((uint32_t)f) & 0x7ffffff))

/*
 * These macros can be used to access RDBGC0_SELECT.
 *
 */
#define BCM56504_A0_READ_RDBGC0_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_RDBGC0_SELECTr,(r._rdbgc0_select))
#define BCM56504_A0_WRITE_RDBGC0_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_RDBGC0_SELECTr,&(r._rdbgc0_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC0_SELECTr BCM56504_A0_RDBGC0_SELECTr
#define RDBGC0_SELECTr_SIZE BCM56504_A0_RDBGC0_SELECTr_SIZE
typedef BCM56504_A0_RDBGC0_SELECTr_t RDBGC0_SELECTr_t;
#define RDBGC0_SELECTr_CLR BCM56504_A0_RDBGC0_SELECTr_CLR
#define RDBGC0_SELECTr_SET BCM56504_A0_RDBGC0_SELECTr_SET
#define RDBGC0_SELECTr_GET BCM56504_A0_RDBGC0_SELECTr_GET
#define RDBGC0_SELECTr_BITMAPf_GET BCM56504_A0_RDBGC0_SELECTr_BITMAPf_GET
#define RDBGC0_SELECTr_BITMAPf_SET BCM56504_A0_RDBGC0_SELECTr_BITMAPf_SET
#define READ_RDBGC0_SELECTr BCM56504_A0_READ_RDBGC0_SELECTr
#define WRITE_RDBGC0_SELECTr BCM56504_A0_WRITE_RDBGC0_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_RDBGC0_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  RDBGC1
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #1
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_RDBGC1r 0x0e70000c

#define BCM56504_A0_RDBGC1r_SIZE 4

/*
 * This structure should be used to declare and program RDBGC1.
 *
 */
typedef union BCM56504_A0_RDBGC1r_s {
	uint32_t v[1];
	uint32_t rdbgc1[1];
	uint32_t _rdbgc1;
} BCM56504_A0_RDBGC1r_t;

#define BCM56504_A0_RDBGC1r_CLR(r) (r).rdbgc1[0] = 0
#define BCM56504_A0_RDBGC1r_SET(r,d) (r).rdbgc1[0] = d
#define BCM56504_A0_RDBGC1r_GET(r) (r).rdbgc1[0]


/*
 * These macros can be used to access RDBGC1.
 *
 */
#define BCM56504_A0_READ_RDBGC1r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_RDBGC1r,(r._rdbgc1))
#define BCM56504_A0_WRITE_RDBGC1r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_RDBGC1r,&(r._rdbgc1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC1r BCM56504_A0_RDBGC1r
#define RDBGC1r_SIZE BCM56504_A0_RDBGC1r_SIZE
typedef BCM56504_A0_RDBGC1r_t RDBGC1r_t;
#define RDBGC1r_CLR BCM56504_A0_RDBGC1r_CLR
#define RDBGC1r_SET BCM56504_A0_RDBGC1r_SET
#define RDBGC1r_GET BCM56504_A0_RDBGC1r_GET
#define READ_RDBGC1r BCM56504_A0_READ_RDBGC1r
#define WRITE_RDBGC1r BCM56504_A0_WRITE_RDBGC1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_RDBGC1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  RDBGC1_SELECT
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #1 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The RDBGC1_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM56504_A0_RDBGC1_SELECTr 0x0e780021

#define BCM56504_A0_RDBGC1_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program RDBGC1_SELECT.
 *
 */
typedef union BCM56504_A0_RDBGC1_SELECTr_s {
	uint32_t v[1];
	uint32_t rdbgc1_select[1];
	uint32_t _rdbgc1_select;
} BCM56504_A0_RDBGC1_SELECTr_t;

#define BCM56504_A0_RDBGC1_SELECTr_CLR(r) (r).rdbgc1_select[0] = 0
#define BCM56504_A0_RDBGC1_SELECTr_SET(r,d) (r).rdbgc1_select[0] = d
#define BCM56504_A0_RDBGC1_SELECTr_GET(r) (r).rdbgc1_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_RDBGC1_SELECTr_BITMAPf_GET(r) (((r).rdbgc1_select[0]) & 0x7ffffff)
#define BCM56504_A0_RDBGC1_SELECTr_BITMAPf_SET(r,f) (r).rdbgc1_select[0]=(((r).rdbgc1_select[0] & ~((uint32_t)0x7ffffff)) | (((uint32_t)f) & 0x7ffffff))

/*
 * These macros can be used to access RDBGC1_SELECT.
 *
 */
#define BCM56504_A0_READ_RDBGC1_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_RDBGC1_SELECTr,(r._rdbgc1_select))
#define BCM56504_A0_WRITE_RDBGC1_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_RDBGC1_SELECTr,&(r._rdbgc1_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC1_SELECTr BCM56504_A0_RDBGC1_SELECTr
#define RDBGC1_SELECTr_SIZE BCM56504_A0_RDBGC1_SELECTr_SIZE
typedef BCM56504_A0_RDBGC1_SELECTr_t RDBGC1_SELECTr_t;
#define RDBGC1_SELECTr_CLR BCM56504_A0_RDBGC1_SELECTr_CLR
#define RDBGC1_SELECTr_SET BCM56504_A0_RDBGC1_SELECTr_SET
#define RDBGC1_SELECTr_GET BCM56504_A0_RDBGC1_SELECTr_GET
#define RDBGC1_SELECTr_BITMAPf_GET BCM56504_A0_RDBGC1_SELECTr_BITMAPf_GET
#define RDBGC1_SELECTr_BITMAPf_SET BCM56504_A0_RDBGC1_SELECTr_BITMAPf_SET
#define READ_RDBGC1_SELECTr BCM56504_A0_READ_RDBGC1_SELECTr
#define WRITE_RDBGC1_SELECTr BCM56504_A0_WRITE_RDBGC1_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_RDBGC1_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  RDBGC2
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #2
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_RDBGC2r 0x0e70000d

#define BCM56504_A0_RDBGC2r_SIZE 4

/*
 * This structure should be used to declare and program RDBGC2.
 *
 */
typedef union BCM56504_A0_RDBGC2r_s {
	uint32_t v[1];
	uint32_t rdbgc2[1];
	uint32_t _rdbgc2;
} BCM56504_A0_RDBGC2r_t;

#define BCM56504_A0_RDBGC2r_CLR(r) (r).rdbgc2[0] = 0
#define BCM56504_A0_RDBGC2r_SET(r,d) (r).rdbgc2[0] = d
#define BCM56504_A0_RDBGC2r_GET(r) (r).rdbgc2[0]


/*
 * These macros can be used to access RDBGC2.
 *
 */
#define BCM56504_A0_READ_RDBGC2r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_RDBGC2r,(r._rdbgc2))
#define BCM56504_A0_WRITE_RDBGC2r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_RDBGC2r,&(r._rdbgc2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC2r BCM56504_A0_RDBGC2r
#define RDBGC2r_SIZE BCM56504_A0_RDBGC2r_SIZE
typedef BCM56504_A0_RDBGC2r_t RDBGC2r_t;
#define RDBGC2r_CLR BCM56504_A0_RDBGC2r_CLR
#define RDBGC2r_SET BCM56504_A0_RDBGC2r_SET
#define RDBGC2r_GET BCM56504_A0_RDBGC2r_GET
#define READ_RDBGC2r BCM56504_A0_READ_RDBGC2r
#define WRITE_RDBGC2r BCM56504_A0_WRITE_RDBGC2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_RDBGC2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  RDBGC2_SELECT
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #2 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The RDBGC2_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM56504_A0_RDBGC2_SELECTr 0x0e780022

#define BCM56504_A0_RDBGC2_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program RDBGC2_SELECT.
 *
 */
typedef union BCM56504_A0_RDBGC2_SELECTr_s {
	uint32_t v[1];
	uint32_t rdbgc2_select[1];
	uint32_t _rdbgc2_select;
} BCM56504_A0_RDBGC2_SELECTr_t;

#define BCM56504_A0_RDBGC2_SELECTr_CLR(r) (r).rdbgc2_select[0] = 0
#define BCM56504_A0_RDBGC2_SELECTr_SET(r,d) (r).rdbgc2_select[0] = d
#define BCM56504_A0_RDBGC2_SELECTr_GET(r) (r).rdbgc2_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_RDBGC2_SELECTr_BITMAPf_GET(r) (((r).rdbgc2_select[0]) & 0x7ffffff)
#define BCM56504_A0_RDBGC2_SELECTr_BITMAPf_SET(r,f) (r).rdbgc2_select[0]=(((r).rdbgc2_select[0] & ~((uint32_t)0x7ffffff)) | (((uint32_t)f) & 0x7ffffff))

/*
 * These macros can be used to access RDBGC2_SELECT.
 *
 */
#define BCM56504_A0_READ_RDBGC2_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_RDBGC2_SELECTr,(r._rdbgc2_select))
#define BCM56504_A0_WRITE_RDBGC2_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_RDBGC2_SELECTr,&(r._rdbgc2_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC2_SELECTr BCM56504_A0_RDBGC2_SELECTr
#define RDBGC2_SELECTr_SIZE BCM56504_A0_RDBGC2_SELECTr_SIZE
typedef BCM56504_A0_RDBGC2_SELECTr_t RDBGC2_SELECTr_t;
#define RDBGC2_SELECTr_CLR BCM56504_A0_RDBGC2_SELECTr_CLR
#define RDBGC2_SELECTr_SET BCM56504_A0_RDBGC2_SELECTr_SET
#define RDBGC2_SELECTr_GET BCM56504_A0_RDBGC2_SELECTr_GET
#define RDBGC2_SELECTr_BITMAPf_GET BCM56504_A0_RDBGC2_SELECTr_BITMAPf_GET
#define RDBGC2_SELECTr_BITMAPf_SET BCM56504_A0_RDBGC2_SELECTr_BITMAPf_SET
#define READ_RDBGC2_SELECTr BCM56504_A0_READ_RDBGC2_SELECTr
#define WRITE_RDBGC2_SELECTr BCM56504_A0_WRITE_RDBGC2_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_RDBGC2_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  RDBGC3
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #3
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_RDBGC3r 0x0e70000e

#define BCM56504_A0_RDBGC3r_SIZE 4

/*
 * This structure should be used to declare and program RDBGC3.
 *
 */
typedef union BCM56504_A0_RDBGC3r_s {
	uint32_t v[1];
	uint32_t rdbgc3[1];
	uint32_t _rdbgc3;
} BCM56504_A0_RDBGC3r_t;

#define BCM56504_A0_RDBGC3r_CLR(r) (r).rdbgc3[0] = 0
#define BCM56504_A0_RDBGC3r_SET(r,d) (r).rdbgc3[0] = d
#define BCM56504_A0_RDBGC3r_GET(r) (r).rdbgc3[0]


/*
 * These macros can be used to access RDBGC3.
 *
 */
#define BCM56504_A0_READ_RDBGC3r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_RDBGC3r,(r._rdbgc3))
#define BCM56504_A0_WRITE_RDBGC3r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_RDBGC3r,&(r._rdbgc3))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC3r BCM56504_A0_RDBGC3r
#define RDBGC3r_SIZE BCM56504_A0_RDBGC3r_SIZE
typedef BCM56504_A0_RDBGC3r_t RDBGC3r_t;
#define RDBGC3r_CLR BCM56504_A0_RDBGC3r_CLR
#define RDBGC3r_SET BCM56504_A0_RDBGC3r_SET
#define RDBGC3r_GET BCM56504_A0_RDBGC3r_GET
#define READ_RDBGC3r BCM56504_A0_READ_RDBGC3r
#define WRITE_RDBGC3r BCM56504_A0_WRITE_RDBGC3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_RDBGC3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  RDBGC3_SELECT
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #3 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The RDBGC3_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM56504_A0_RDBGC3_SELECTr 0x0e780023

#define BCM56504_A0_RDBGC3_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program RDBGC3_SELECT.
 *
 */
typedef union BCM56504_A0_RDBGC3_SELECTr_s {
	uint32_t v[1];
	uint32_t rdbgc3_select[1];
	uint32_t _rdbgc3_select;
} BCM56504_A0_RDBGC3_SELECTr_t;

#define BCM56504_A0_RDBGC3_SELECTr_CLR(r) (r).rdbgc3_select[0] = 0
#define BCM56504_A0_RDBGC3_SELECTr_SET(r,d) (r).rdbgc3_select[0] = d
#define BCM56504_A0_RDBGC3_SELECTr_GET(r) (r).rdbgc3_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_RDBGC3_SELECTr_BITMAPf_GET(r) (((r).rdbgc3_select[0]) & 0x7ffffff)
#define BCM56504_A0_RDBGC3_SELECTr_BITMAPf_SET(r,f) (r).rdbgc3_select[0]=(((r).rdbgc3_select[0] & ~((uint32_t)0x7ffffff)) | (((uint32_t)f) & 0x7ffffff))

/*
 * These macros can be used to access RDBGC3_SELECT.
 *
 */
#define BCM56504_A0_READ_RDBGC3_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_RDBGC3_SELECTr,(r._rdbgc3_select))
#define BCM56504_A0_WRITE_RDBGC3_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_RDBGC3_SELECTr,&(r._rdbgc3_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC3_SELECTr BCM56504_A0_RDBGC3_SELECTr
#define RDBGC3_SELECTr_SIZE BCM56504_A0_RDBGC3_SELECTr_SIZE
typedef BCM56504_A0_RDBGC3_SELECTr_t RDBGC3_SELECTr_t;
#define RDBGC3_SELECTr_CLR BCM56504_A0_RDBGC3_SELECTr_CLR
#define RDBGC3_SELECTr_SET BCM56504_A0_RDBGC3_SELECTr_SET
#define RDBGC3_SELECTr_GET BCM56504_A0_RDBGC3_SELECTr_GET
#define RDBGC3_SELECTr_BITMAPf_GET BCM56504_A0_RDBGC3_SELECTr_BITMAPf_GET
#define RDBGC3_SELECTr_BITMAPf_SET BCM56504_A0_RDBGC3_SELECTr_BITMAPf_SET
#define READ_RDBGC3_SELECTr BCM56504_A0_READ_RDBGC3_SELECTr
#define WRITE_RDBGC3_SELECTr BCM56504_A0_WRITE_RDBGC3_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_RDBGC3_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  RDBGC4
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #4
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_RDBGC4r 0x0e70000f

#define BCM56504_A0_RDBGC4r_SIZE 4

/*
 * This structure should be used to declare and program RDBGC4.
 *
 */
typedef union BCM56504_A0_RDBGC4r_s {
	uint32_t v[1];
	uint32_t rdbgc4[1];
	uint32_t _rdbgc4;
} BCM56504_A0_RDBGC4r_t;

#define BCM56504_A0_RDBGC4r_CLR(r) (r).rdbgc4[0] = 0
#define BCM56504_A0_RDBGC4r_SET(r,d) (r).rdbgc4[0] = d
#define BCM56504_A0_RDBGC4r_GET(r) (r).rdbgc4[0]


/*
 * These macros can be used to access RDBGC4.
 *
 */
#define BCM56504_A0_READ_RDBGC4r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_RDBGC4r,(r._rdbgc4))
#define BCM56504_A0_WRITE_RDBGC4r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_RDBGC4r,&(r._rdbgc4))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC4r BCM56504_A0_RDBGC4r
#define RDBGC4r_SIZE BCM56504_A0_RDBGC4r_SIZE
typedef BCM56504_A0_RDBGC4r_t RDBGC4r_t;
#define RDBGC4r_CLR BCM56504_A0_RDBGC4r_CLR
#define RDBGC4r_SET BCM56504_A0_RDBGC4r_SET
#define RDBGC4r_GET BCM56504_A0_RDBGC4r_GET
#define READ_RDBGC4r BCM56504_A0_READ_RDBGC4r
#define WRITE_RDBGC4r BCM56504_A0_WRITE_RDBGC4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_RDBGC4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  RDBGC4_SELECT
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #4 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The RDBGC4_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM56504_A0_RDBGC4_SELECTr 0x0e780024

#define BCM56504_A0_RDBGC4_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program RDBGC4_SELECT.
 *
 */
typedef union BCM56504_A0_RDBGC4_SELECTr_s {
	uint32_t v[1];
	uint32_t rdbgc4_select[1];
	uint32_t _rdbgc4_select;
} BCM56504_A0_RDBGC4_SELECTr_t;

#define BCM56504_A0_RDBGC4_SELECTr_CLR(r) (r).rdbgc4_select[0] = 0
#define BCM56504_A0_RDBGC4_SELECTr_SET(r,d) (r).rdbgc4_select[0] = d
#define BCM56504_A0_RDBGC4_SELECTr_GET(r) (r).rdbgc4_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_RDBGC4_SELECTr_BITMAPf_GET(r) (((r).rdbgc4_select[0]) & 0x7ffffff)
#define BCM56504_A0_RDBGC4_SELECTr_BITMAPf_SET(r,f) (r).rdbgc4_select[0]=(((r).rdbgc4_select[0] & ~((uint32_t)0x7ffffff)) | (((uint32_t)f) & 0x7ffffff))

/*
 * These macros can be used to access RDBGC4_SELECT.
 *
 */
#define BCM56504_A0_READ_RDBGC4_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_RDBGC4_SELECTr,(r._rdbgc4_select))
#define BCM56504_A0_WRITE_RDBGC4_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_RDBGC4_SELECTr,&(r._rdbgc4_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC4_SELECTr BCM56504_A0_RDBGC4_SELECTr
#define RDBGC4_SELECTr_SIZE BCM56504_A0_RDBGC4_SELECTr_SIZE
typedef BCM56504_A0_RDBGC4_SELECTr_t RDBGC4_SELECTr_t;
#define RDBGC4_SELECTr_CLR BCM56504_A0_RDBGC4_SELECTr_CLR
#define RDBGC4_SELECTr_SET BCM56504_A0_RDBGC4_SELECTr_SET
#define RDBGC4_SELECTr_GET BCM56504_A0_RDBGC4_SELECTr_GET
#define RDBGC4_SELECTr_BITMAPf_GET BCM56504_A0_RDBGC4_SELECTr_BITMAPf_GET
#define RDBGC4_SELECTr_BITMAPf_SET BCM56504_A0_RDBGC4_SELECTr_BITMAPf_SET
#define READ_RDBGC4_SELECTr BCM56504_A0_READ_RDBGC4_SELECTr
#define WRITE_RDBGC4_SELECTr BCM56504_A0_WRITE_RDBGC4_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_RDBGC4_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  RDBGC5
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #5
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_RDBGC5r 0x0e700010

#define BCM56504_A0_RDBGC5r_SIZE 4

/*
 * This structure should be used to declare and program RDBGC5.
 *
 */
typedef union BCM56504_A0_RDBGC5r_s {
	uint32_t v[1];
	uint32_t rdbgc5[1];
	uint32_t _rdbgc5;
} BCM56504_A0_RDBGC5r_t;

#define BCM56504_A0_RDBGC5r_CLR(r) (r).rdbgc5[0] = 0
#define BCM56504_A0_RDBGC5r_SET(r,d) (r).rdbgc5[0] = d
#define BCM56504_A0_RDBGC5r_GET(r) (r).rdbgc5[0]


/*
 * These macros can be used to access RDBGC5.
 *
 */
#define BCM56504_A0_READ_RDBGC5r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_RDBGC5r,(r._rdbgc5))
#define BCM56504_A0_WRITE_RDBGC5r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_RDBGC5r,&(r._rdbgc5))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC5r BCM56504_A0_RDBGC5r
#define RDBGC5r_SIZE BCM56504_A0_RDBGC5r_SIZE
typedef BCM56504_A0_RDBGC5r_t RDBGC5r_t;
#define RDBGC5r_CLR BCM56504_A0_RDBGC5r_CLR
#define RDBGC5r_SET BCM56504_A0_RDBGC5r_SET
#define RDBGC5r_GET BCM56504_A0_RDBGC5r_GET
#define READ_RDBGC5r BCM56504_A0_READ_RDBGC5r
#define WRITE_RDBGC5r BCM56504_A0_WRITE_RDBGC5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_RDBGC5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  RDBGC5_SELECT
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #5 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The RDBGC5_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM56504_A0_RDBGC5_SELECTr 0x0e780025

#define BCM56504_A0_RDBGC5_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program RDBGC5_SELECT.
 *
 */
typedef union BCM56504_A0_RDBGC5_SELECTr_s {
	uint32_t v[1];
	uint32_t rdbgc5_select[1];
	uint32_t _rdbgc5_select;
} BCM56504_A0_RDBGC5_SELECTr_t;

#define BCM56504_A0_RDBGC5_SELECTr_CLR(r) (r).rdbgc5_select[0] = 0
#define BCM56504_A0_RDBGC5_SELECTr_SET(r,d) (r).rdbgc5_select[0] = d
#define BCM56504_A0_RDBGC5_SELECTr_GET(r) (r).rdbgc5_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_RDBGC5_SELECTr_BITMAPf_GET(r) (((r).rdbgc5_select[0]) & 0x7ffffff)
#define BCM56504_A0_RDBGC5_SELECTr_BITMAPf_SET(r,f) (r).rdbgc5_select[0]=(((r).rdbgc5_select[0] & ~((uint32_t)0x7ffffff)) | (((uint32_t)f) & 0x7ffffff))

/*
 * These macros can be used to access RDBGC5_SELECT.
 *
 */
#define BCM56504_A0_READ_RDBGC5_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_RDBGC5_SELECTr,(r._rdbgc5_select))
#define BCM56504_A0_WRITE_RDBGC5_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_RDBGC5_SELECTr,&(r._rdbgc5_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC5_SELECTr BCM56504_A0_RDBGC5_SELECTr
#define RDBGC5_SELECTr_SIZE BCM56504_A0_RDBGC5_SELECTr_SIZE
typedef BCM56504_A0_RDBGC5_SELECTr_t RDBGC5_SELECTr_t;
#define RDBGC5_SELECTr_CLR BCM56504_A0_RDBGC5_SELECTr_CLR
#define RDBGC5_SELECTr_SET BCM56504_A0_RDBGC5_SELECTr_SET
#define RDBGC5_SELECTr_GET BCM56504_A0_RDBGC5_SELECTr_GET
#define RDBGC5_SELECTr_BITMAPf_GET BCM56504_A0_RDBGC5_SELECTr_BITMAPf_GET
#define RDBGC5_SELECTr_BITMAPf_SET BCM56504_A0_RDBGC5_SELECTr_BITMAPf_SET
#define READ_RDBGC5_SELECTr BCM56504_A0_READ_RDBGC5_SELECTr
#define WRITE_RDBGC5_SELECTr BCM56504_A0_WRITE_RDBGC5_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_RDBGC5_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  RDBGC6
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #6
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_RDBGC6r 0x0e700011

#define BCM56504_A0_RDBGC6r_SIZE 4

/*
 * This structure should be used to declare and program RDBGC6.
 *
 */
typedef union BCM56504_A0_RDBGC6r_s {
	uint32_t v[1];
	uint32_t rdbgc6[1];
	uint32_t _rdbgc6;
} BCM56504_A0_RDBGC6r_t;

#define BCM56504_A0_RDBGC6r_CLR(r) (r).rdbgc6[0] = 0
#define BCM56504_A0_RDBGC6r_SET(r,d) (r).rdbgc6[0] = d
#define BCM56504_A0_RDBGC6r_GET(r) (r).rdbgc6[0]


/*
 * These macros can be used to access RDBGC6.
 *
 */
#define BCM56504_A0_READ_RDBGC6r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_RDBGC6r,(r._rdbgc6))
#define BCM56504_A0_WRITE_RDBGC6r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_RDBGC6r,&(r._rdbgc6))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC6r BCM56504_A0_RDBGC6r
#define RDBGC6r_SIZE BCM56504_A0_RDBGC6r_SIZE
typedef BCM56504_A0_RDBGC6r_t RDBGC6r_t;
#define RDBGC6r_CLR BCM56504_A0_RDBGC6r_CLR
#define RDBGC6r_SET BCM56504_A0_RDBGC6r_SET
#define RDBGC6r_GET BCM56504_A0_RDBGC6r_GET
#define READ_RDBGC6r BCM56504_A0_READ_RDBGC6r
#define WRITE_RDBGC6r BCM56504_A0_WRITE_RDBGC6r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_RDBGC6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  RDBGC6_SELECT
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #6 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The RDBGC6_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM56504_A0_RDBGC6_SELECTr 0x0e780026

#define BCM56504_A0_RDBGC6_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program RDBGC6_SELECT.
 *
 */
typedef union BCM56504_A0_RDBGC6_SELECTr_s {
	uint32_t v[1];
	uint32_t rdbgc6_select[1];
	uint32_t _rdbgc6_select;
} BCM56504_A0_RDBGC6_SELECTr_t;

#define BCM56504_A0_RDBGC6_SELECTr_CLR(r) (r).rdbgc6_select[0] = 0
#define BCM56504_A0_RDBGC6_SELECTr_SET(r,d) (r).rdbgc6_select[0] = d
#define BCM56504_A0_RDBGC6_SELECTr_GET(r) (r).rdbgc6_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_RDBGC6_SELECTr_BITMAPf_GET(r) (((r).rdbgc6_select[0]) & 0x7ffffff)
#define BCM56504_A0_RDBGC6_SELECTr_BITMAPf_SET(r,f) (r).rdbgc6_select[0]=(((r).rdbgc6_select[0] & ~((uint32_t)0x7ffffff)) | (((uint32_t)f) & 0x7ffffff))

/*
 * These macros can be used to access RDBGC6_SELECT.
 *
 */
#define BCM56504_A0_READ_RDBGC6_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_RDBGC6_SELECTr,(r._rdbgc6_select))
#define BCM56504_A0_WRITE_RDBGC6_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_RDBGC6_SELECTr,&(r._rdbgc6_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC6_SELECTr BCM56504_A0_RDBGC6_SELECTr
#define RDBGC6_SELECTr_SIZE BCM56504_A0_RDBGC6_SELECTr_SIZE
typedef BCM56504_A0_RDBGC6_SELECTr_t RDBGC6_SELECTr_t;
#define RDBGC6_SELECTr_CLR BCM56504_A0_RDBGC6_SELECTr_CLR
#define RDBGC6_SELECTr_SET BCM56504_A0_RDBGC6_SELECTr_SET
#define RDBGC6_SELECTr_GET BCM56504_A0_RDBGC6_SELECTr_GET
#define RDBGC6_SELECTr_BITMAPf_GET BCM56504_A0_RDBGC6_SELECTr_BITMAPf_GET
#define RDBGC6_SELECTr_BITMAPf_SET BCM56504_A0_RDBGC6_SELECTr_BITMAPf_SET
#define READ_RDBGC6_SELECTr BCM56504_A0_READ_RDBGC6_SELECTr
#define WRITE_RDBGC6_SELECTr BCM56504_A0_WRITE_RDBGC6_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_RDBGC6_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  RDBGC7
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #7
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_RDBGC7r 0x0e700012

#define BCM56504_A0_RDBGC7r_SIZE 4

/*
 * This structure should be used to declare and program RDBGC7.
 *
 */
typedef union BCM56504_A0_RDBGC7r_s {
	uint32_t v[1];
	uint32_t rdbgc7[1];
	uint32_t _rdbgc7;
} BCM56504_A0_RDBGC7r_t;

#define BCM56504_A0_RDBGC7r_CLR(r) (r).rdbgc7[0] = 0
#define BCM56504_A0_RDBGC7r_SET(r,d) (r).rdbgc7[0] = d
#define BCM56504_A0_RDBGC7r_GET(r) (r).rdbgc7[0]


/*
 * These macros can be used to access RDBGC7.
 *
 */
#define BCM56504_A0_READ_RDBGC7r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_RDBGC7r,(r._rdbgc7))
#define BCM56504_A0_WRITE_RDBGC7r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_RDBGC7r,&(r._rdbgc7))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC7r BCM56504_A0_RDBGC7r
#define RDBGC7r_SIZE BCM56504_A0_RDBGC7r_SIZE
typedef BCM56504_A0_RDBGC7r_t RDBGC7r_t;
#define RDBGC7r_CLR BCM56504_A0_RDBGC7r_CLR
#define RDBGC7r_SET BCM56504_A0_RDBGC7r_SET
#define RDBGC7r_GET BCM56504_A0_RDBGC7r_GET
#define READ_RDBGC7r BCM56504_A0_READ_RDBGC7r
#define WRITE_RDBGC7r BCM56504_A0_WRITE_RDBGC7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_RDBGC7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  RDBGC7_SELECT
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #7 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The RDBGC7_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM56504_A0_RDBGC7_SELECTr 0x0e780027

#define BCM56504_A0_RDBGC7_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program RDBGC7_SELECT.
 *
 */
typedef union BCM56504_A0_RDBGC7_SELECTr_s {
	uint32_t v[1];
	uint32_t rdbgc7_select[1];
	uint32_t _rdbgc7_select;
} BCM56504_A0_RDBGC7_SELECTr_t;

#define BCM56504_A0_RDBGC7_SELECTr_CLR(r) (r).rdbgc7_select[0] = 0
#define BCM56504_A0_RDBGC7_SELECTr_SET(r,d) (r).rdbgc7_select[0] = d
#define BCM56504_A0_RDBGC7_SELECTr_GET(r) (r).rdbgc7_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_RDBGC7_SELECTr_BITMAPf_GET(r) (((r).rdbgc7_select[0]) & 0x7ffffff)
#define BCM56504_A0_RDBGC7_SELECTr_BITMAPf_SET(r,f) (r).rdbgc7_select[0]=(((r).rdbgc7_select[0] & ~((uint32_t)0x7ffffff)) | (((uint32_t)f) & 0x7ffffff))

/*
 * These macros can be used to access RDBGC7_SELECT.
 *
 */
#define BCM56504_A0_READ_RDBGC7_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_RDBGC7_SELECTr,(r._rdbgc7_select))
#define BCM56504_A0_WRITE_RDBGC7_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_RDBGC7_SELECTr,&(r._rdbgc7_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC7_SELECTr BCM56504_A0_RDBGC7_SELECTr
#define RDBGC7_SELECTr_SIZE BCM56504_A0_RDBGC7_SELECTr_SIZE
typedef BCM56504_A0_RDBGC7_SELECTr_t RDBGC7_SELECTr_t;
#define RDBGC7_SELECTr_CLR BCM56504_A0_RDBGC7_SELECTr_CLR
#define RDBGC7_SELECTr_SET BCM56504_A0_RDBGC7_SELECTr_SET
#define RDBGC7_SELECTr_GET BCM56504_A0_RDBGC7_SELECTr_GET
#define RDBGC7_SELECTr_BITMAPf_GET BCM56504_A0_RDBGC7_SELECTr_BITMAPf_GET
#define RDBGC7_SELECTr_BITMAPf_SET BCM56504_A0_RDBGC7_SELECTr_BITMAPf_SET
#define READ_RDBGC7_SELECTr BCM56504_A0_READ_RDBGC7_SELECTr
#define WRITE_RDBGC7_SELECTr BCM56504_A0_WRITE_RDBGC7_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_RDBGC7_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  RDBGC8
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #8
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_RDBGC8r 0x0e700013

#define BCM56504_A0_RDBGC8r_SIZE 4

/*
 * This structure should be used to declare and program RDBGC8.
 *
 */
typedef union BCM56504_A0_RDBGC8r_s {
	uint32_t v[1];
	uint32_t rdbgc8[1];
	uint32_t _rdbgc8;
} BCM56504_A0_RDBGC8r_t;

#define BCM56504_A0_RDBGC8r_CLR(r) (r).rdbgc8[0] = 0
#define BCM56504_A0_RDBGC8r_SET(r,d) (r).rdbgc8[0] = d
#define BCM56504_A0_RDBGC8r_GET(r) (r).rdbgc8[0]


/*
 * These macros can be used to access RDBGC8.
 *
 */
#define BCM56504_A0_READ_RDBGC8r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_RDBGC8r,(r._rdbgc8))
#define BCM56504_A0_WRITE_RDBGC8r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_RDBGC8r,&(r._rdbgc8))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC8r BCM56504_A0_RDBGC8r
#define RDBGC8r_SIZE BCM56504_A0_RDBGC8r_SIZE
typedef BCM56504_A0_RDBGC8r_t RDBGC8r_t;
#define RDBGC8r_CLR BCM56504_A0_RDBGC8r_CLR
#define RDBGC8r_SET BCM56504_A0_RDBGC8r_SET
#define RDBGC8r_GET BCM56504_A0_RDBGC8r_GET
#define READ_RDBGC8r BCM56504_A0_READ_RDBGC8r
#define WRITE_RDBGC8r BCM56504_A0_WRITE_RDBGC8r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_RDBGC8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  RDBGC8_SELECT
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #8 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The RDBGC8_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM56504_A0_RDBGC8_SELECTr 0x0e780028

#define BCM56504_A0_RDBGC8_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program RDBGC8_SELECT.
 *
 */
typedef union BCM56504_A0_RDBGC8_SELECTr_s {
	uint32_t v[1];
	uint32_t rdbgc8_select[1];
	uint32_t _rdbgc8_select;
} BCM56504_A0_RDBGC8_SELECTr_t;

#define BCM56504_A0_RDBGC8_SELECTr_CLR(r) (r).rdbgc8_select[0] = 0
#define BCM56504_A0_RDBGC8_SELECTr_SET(r,d) (r).rdbgc8_select[0] = d
#define BCM56504_A0_RDBGC8_SELECTr_GET(r) (r).rdbgc8_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_RDBGC8_SELECTr_BITMAPf_GET(r) (((r).rdbgc8_select[0]) & 0x7ffffff)
#define BCM56504_A0_RDBGC8_SELECTr_BITMAPf_SET(r,f) (r).rdbgc8_select[0]=(((r).rdbgc8_select[0] & ~((uint32_t)0x7ffffff)) | (((uint32_t)f) & 0x7ffffff))

/*
 * These macros can be used to access RDBGC8_SELECT.
 *
 */
#define BCM56504_A0_READ_RDBGC8_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_RDBGC8_SELECTr,(r._rdbgc8_select))
#define BCM56504_A0_WRITE_RDBGC8_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_RDBGC8_SELECTr,&(r._rdbgc8_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC8_SELECTr BCM56504_A0_RDBGC8_SELECTr
#define RDBGC8_SELECTr_SIZE BCM56504_A0_RDBGC8_SELECTr_SIZE
typedef BCM56504_A0_RDBGC8_SELECTr_t RDBGC8_SELECTr_t;
#define RDBGC8_SELECTr_CLR BCM56504_A0_RDBGC8_SELECTr_CLR
#define RDBGC8_SELECTr_SET BCM56504_A0_RDBGC8_SELECTr_SET
#define RDBGC8_SELECTr_GET BCM56504_A0_RDBGC8_SELECTr_GET
#define RDBGC8_SELECTr_BITMAPf_GET BCM56504_A0_RDBGC8_SELECTr_BITMAPf_GET
#define RDBGC8_SELECTr_BITMAPf_SET BCM56504_A0_RDBGC8_SELECTr_BITMAPf_SET
#define READ_RDBGC8_SELECTr BCM56504_A0_READ_RDBGC8_SELECTr
#define WRITE_RDBGC8_SELECTr BCM56504_A0_WRITE_RDBGC8_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_RDBGC8_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  RDISC
 * BLOCKS:   IPIPE
 * DESC:     Receive Discard Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_RDISCr 0x0e700008

#define BCM56504_A0_RDISCr_SIZE 4

/*
 * This structure should be used to declare and program RDISC.
 *
 */
typedef union BCM56504_A0_RDISCr_s {
	uint32_t v[1];
	uint32_t rdisc[1];
	uint32_t _rdisc;
} BCM56504_A0_RDISCr_t;

#define BCM56504_A0_RDISCr_CLR(r) (r).rdisc[0] = 0
#define BCM56504_A0_RDISCr_SET(r,d) (r).rdisc[0] = d
#define BCM56504_A0_RDISCr_GET(r) (r).rdisc[0]


/*
 * These macros can be used to access RDISC.
 *
 */
#define BCM56504_A0_READ_RDISCr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_RDISCr,(r._rdisc))
#define BCM56504_A0_WRITE_RDISCr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_RDISCr,&(r._rdisc))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDISCr BCM56504_A0_RDISCr
#define RDISCr_SIZE BCM56504_A0_RDISCr_SIZE
typedef BCM56504_A0_RDISCr_t RDISCr_t;
#define RDISCr_CLR BCM56504_A0_RDISCr_CLR
#define RDISCr_SET BCM56504_A0_RDISCr_SET
#define RDISCr_GET BCM56504_A0_RDISCr_GET
#define READ_RDISCr BCM56504_A0_READ_RDISCr
#define WRITE_RDISCr BCM56504_A0_WRITE_RDISCr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_RDISCr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  REVCD
 * BLOCKS:   GPORT0
 * DESC:     Revision Info
 * SIZE:     32
 * FIELDS:
 *     REV              Revision Number
 *     MONTH            Revision Month
 *     YEAR             Revision Year
 *
 ******************************************************************************/
#define BCM56504_A0_REVCDr 0x00f0010b

#define BCM56504_A0_REVCDr_SIZE 4

/*
 * This structure should be used to declare and program REVCD.
 *
 */
typedef union BCM56504_A0_REVCDr_s {
	uint32_t v[1];
	uint32_t revcd[1];
	uint32_t _revcd;
} BCM56504_A0_REVCDr_t;

#define BCM56504_A0_REVCDr_CLR(r) (r).revcd[0] = 0
#define BCM56504_A0_REVCDr_SET(r,d) (r).revcd[0] = d
#define BCM56504_A0_REVCDr_GET(r) (r).revcd[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_REVCDr_REVf_GET(r) (((r).revcd[0]) & 0xf)
#define BCM56504_A0_REVCDr_REVf_SET(r,f) (r).revcd[0]=(((r).revcd[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56504_A0_REVCDr_MONTHf_GET(r) ((((r).revcd[0]) >> 4) & 0xf)
#define BCM56504_A0_REVCDr_MONTHf_SET(r,f) (r).revcd[0]=(((r).revcd[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56504_A0_REVCDr_YEARf_GET(r) ((((r).revcd[0]) >> 8) & 0xff)
#define BCM56504_A0_REVCDr_YEARf_SET(r,f) (r).revcd[0]=(((r).revcd[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access REVCD.
 *
 */
#define BCM56504_A0_READ_REVCDr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_REVCDr,(r._revcd))
#define BCM56504_A0_WRITE_REVCDr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_REVCDr,&(r._revcd))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define REVCDr BCM56504_A0_REVCDr
#define REVCDr_SIZE BCM56504_A0_REVCDr_SIZE
typedef BCM56504_A0_REVCDr_t REVCDr_t;
#define REVCDr_CLR BCM56504_A0_REVCDr_CLR
#define REVCDr_SET BCM56504_A0_REVCDr_SET
#define REVCDr_GET BCM56504_A0_REVCDr_GET
#define REVCDr_REVf_GET BCM56504_A0_REVCDr_REVf_GET
#define REVCDr_REVf_SET BCM56504_A0_REVCDr_REVf_SET
#define REVCDr_MONTHf_GET BCM56504_A0_REVCDr_MONTHf_GET
#define REVCDr_MONTHf_SET BCM56504_A0_REVCDr_MONTHf_SET
#define REVCDr_YEARf_GET BCM56504_A0_REVCDr_YEARf_GET
#define REVCDr_YEARf_SET BCM56504_A0_REVCDr_YEARf_SET
#define READ_REVCDr BCM56504_A0_READ_REVCDr
#define WRITE_REVCDr BCM56504_A0_WRITE_REVCDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_REVCDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  RIPC4
 * BLOCKS:   IPIPE
 * DESC:     Receive IPv4 L3 Unicast Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_RIPC4r 0x0e700001

#define BCM56504_A0_RIPC4r_SIZE 4

/*
 * This structure should be used to declare and program RIPC4.
 *
 */
typedef union BCM56504_A0_RIPC4r_s {
	uint32_t v[1];
	uint32_t ripc4[1];
	uint32_t _ripc4;
} BCM56504_A0_RIPC4r_t;

#define BCM56504_A0_RIPC4r_CLR(r) (r).ripc4[0] = 0
#define BCM56504_A0_RIPC4r_SET(r,d) (r).ripc4[0] = d
#define BCM56504_A0_RIPC4r_GET(r) (r).ripc4[0]


/*
 * These macros can be used to access RIPC4.
 *
 */
#define BCM56504_A0_READ_RIPC4r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_RIPC4r,(r._ripc4))
#define BCM56504_A0_WRITE_RIPC4r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_RIPC4r,&(r._ripc4))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RIPC4r BCM56504_A0_RIPC4r
#define RIPC4r_SIZE BCM56504_A0_RIPC4r_SIZE
typedef BCM56504_A0_RIPC4r_t RIPC4r_t;
#define RIPC4r_CLR BCM56504_A0_RIPC4r_CLR
#define RIPC4r_SET BCM56504_A0_RIPC4r_SET
#define RIPC4r_GET BCM56504_A0_RIPC4r_GET
#define READ_RIPC4r BCM56504_A0_READ_RIPC4r
#define WRITE_RIPC4r BCM56504_A0_WRITE_RIPC4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_RIPC4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  RIPC6
 * BLOCKS:   IPIPE
 * DESC:     Receive IPv6 L3 Unicast Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_RIPC6r 0x0e700005

#define BCM56504_A0_RIPC6r_SIZE 4

/*
 * This structure should be used to declare and program RIPC6.
 *
 */
typedef union BCM56504_A0_RIPC6r_s {
	uint32_t v[1];
	uint32_t ripc6[1];
	uint32_t _ripc6;
} BCM56504_A0_RIPC6r_t;

#define BCM56504_A0_RIPC6r_CLR(r) (r).ripc6[0] = 0
#define BCM56504_A0_RIPC6r_SET(r,d) (r).ripc6[0] = d
#define BCM56504_A0_RIPC6r_GET(r) (r).ripc6[0]


/*
 * These macros can be used to access RIPC6.
 *
 */
#define BCM56504_A0_READ_RIPC6r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_RIPC6r,(r._ripc6))
#define BCM56504_A0_WRITE_RIPC6r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_RIPC6r,&(r._ripc6))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RIPC6r BCM56504_A0_RIPC6r
#define RIPC6r_SIZE BCM56504_A0_RIPC6r_SIZE
typedef BCM56504_A0_RIPC6r_t RIPC6r_t;
#define RIPC6r_CLR BCM56504_A0_RIPC6r_CLR
#define RIPC6r_SET BCM56504_A0_RIPC6r_SET
#define RIPC6r_GET BCM56504_A0_RIPC6r_GET
#define READ_RIPC6r BCM56504_A0_READ_RIPC6r
#define WRITE_RIPC6r BCM56504_A0_WRITE_RIPC6r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_RIPC6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  RIPD4
 * BLOCKS:   IPIPE
 * DESC:     Receive IPv4 L3 Discard Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_RIPD4r 0x0e700000

#define BCM56504_A0_RIPD4r_SIZE 4

/*
 * This structure should be used to declare and program RIPD4.
 *
 */
typedef union BCM56504_A0_RIPD4r_s {
	uint32_t v[1];
	uint32_t ripd4[1];
	uint32_t _ripd4;
} BCM56504_A0_RIPD4r_t;

#define BCM56504_A0_RIPD4r_CLR(r) (r).ripd4[0] = 0
#define BCM56504_A0_RIPD4r_SET(r,d) (r).ripd4[0] = d
#define BCM56504_A0_RIPD4r_GET(r) (r).ripd4[0]


/*
 * These macros can be used to access RIPD4.
 *
 */
#define BCM56504_A0_READ_RIPD4r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_RIPD4r,(r._ripd4))
#define BCM56504_A0_WRITE_RIPD4r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_RIPD4r,&(r._ripd4))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RIPD4r BCM56504_A0_RIPD4r
#define RIPD4r_SIZE BCM56504_A0_RIPD4r_SIZE
typedef BCM56504_A0_RIPD4r_t RIPD4r_t;
#define RIPD4r_CLR BCM56504_A0_RIPD4r_CLR
#define RIPD4r_SET BCM56504_A0_RIPD4r_SET
#define RIPD4r_GET BCM56504_A0_RIPD4r_GET
#define READ_RIPD4r BCM56504_A0_READ_RIPD4r
#define WRITE_RIPD4r BCM56504_A0_WRITE_RIPD4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_RIPD4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  RIPD6
 * BLOCKS:   IPIPE
 * DESC:     Receive IPv6 L3 Discard Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_RIPD6r 0x0e700004

#define BCM56504_A0_RIPD6r_SIZE 4

/*
 * This structure should be used to declare and program RIPD6.
 *
 */
typedef union BCM56504_A0_RIPD6r_s {
	uint32_t v[1];
	uint32_t ripd6[1];
	uint32_t _ripd6;
} BCM56504_A0_RIPD6r_t;

#define BCM56504_A0_RIPD6r_CLR(r) (r).ripd6[0] = 0
#define BCM56504_A0_RIPD6r_SET(r,d) (r).ripd6[0] = d
#define BCM56504_A0_RIPD6r_GET(r) (r).ripd6[0]


/*
 * These macros can be used to access RIPD6.
 *
 */
#define BCM56504_A0_READ_RIPD6r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_RIPD6r,(r._ripd6))
#define BCM56504_A0_WRITE_RIPD6r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_RIPD6r,&(r._ripd6))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RIPD6r BCM56504_A0_RIPD6r
#define RIPD6r_SIZE BCM56504_A0_RIPD6r_SIZE
typedef BCM56504_A0_RIPD6r_t RIPD6r_t;
#define RIPD6r_CLR BCM56504_A0_RIPD6r_CLR
#define RIPD6r_SET BCM56504_A0_RIPD6r_SET
#define RIPD6r_GET BCM56504_A0_RIPD6r_GET
#define READ_RIPD6r BCM56504_A0_READ_RIPD6r
#define WRITE_RIPD6r BCM56504_A0_WRITE_RIPD6r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_RIPD6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  RIPHE4
 * BLOCKS:   IPIPE
 * DESC:     Receive IPv4 L3 IP Header Error Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_RIPHE4r 0x0e700002

#define BCM56504_A0_RIPHE4r_SIZE 4

/*
 * This structure should be used to declare and program RIPHE4.
 *
 */
typedef union BCM56504_A0_RIPHE4r_s {
	uint32_t v[1];
	uint32_t riphe4[1];
	uint32_t _riphe4;
} BCM56504_A0_RIPHE4r_t;

#define BCM56504_A0_RIPHE4r_CLR(r) (r).riphe4[0] = 0
#define BCM56504_A0_RIPHE4r_SET(r,d) (r).riphe4[0] = d
#define BCM56504_A0_RIPHE4r_GET(r) (r).riphe4[0]


/*
 * These macros can be used to access RIPHE4.
 *
 */
#define BCM56504_A0_READ_RIPHE4r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_RIPHE4r,(r._riphe4))
#define BCM56504_A0_WRITE_RIPHE4r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_RIPHE4r,&(r._riphe4))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RIPHE4r BCM56504_A0_RIPHE4r
#define RIPHE4r_SIZE BCM56504_A0_RIPHE4r_SIZE
typedef BCM56504_A0_RIPHE4r_t RIPHE4r_t;
#define RIPHE4r_CLR BCM56504_A0_RIPHE4r_CLR
#define RIPHE4r_SET BCM56504_A0_RIPHE4r_SET
#define RIPHE4r_GET BCM56504_A0_RIPHE4r_GET
#define READ_RIPHE4r BCM56504_A0_READ_RIPHE4r
#define WRITE_RIPHE4r BCM56504_A0_WRITE_RIPHE4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_RIPHE4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  RIPHE6
 * BLOCKS:   IPIPE
 * DESC:     Receive IPv6 L3 IP Header Error Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_RIPHE6r 0x0e700006

#define BCM56504_A0_RIPHE6r_SIZE 4

/*
 * This structure should be used to declare and program RIPHE6.
 *
 */
typedef union BCM56504_A0_RIPHE6r_s {
	uint32_t v[1];
	uint32_t riphe6[1];
	uint32_t _riphe6;
} BCM56504_A0_RIPHE6r_t;

#define BCM56504_A0_RIPHE6r_CLR(r) (r).riphe6[0] = 0
#define BCM56504_A0_RIPHE6r_SET(r,d) (r).riphe6[0] = d
#define BCM56504_A0_RIPHE6r_GET(r) (r).riphe6[0]


/*
 * These macros can be used to access RIPHE6.
 *
 */
#define BCM56504_A0_READ_RIPHE6r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_RIPHE6r,(r._riphe6))
#define BCM56504_A0_WRITE_RIPHE6r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_RIPHE6r,&(r._riphe6))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RIPHE6r BCM56504_A0_RIPHE6r
#define RIPHE6r_SIZE BCM56504_A0_RIPHE6r_SIZE
typedef BCM56504_A0_RIPHE6r_t RIPHE6r_t;
#define RIPHE6r_CLR BCM56504_A0_RIPHE6r_CLR
#define RIPHE6r_SET BCM56504_A0_RIPHE6r_SET
#define RIPHE6r_GET BCM56504_A0_RIPHE6r_GET
#define READ_RIPHE6r BCM56504_A0_READ_RIPHE6r
#define WRITE_RIPHE6r BCM56504_A0_WRITE_RIPHE6r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_RIPHE6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  RPORTD
 * BLOCKS:   IPIPE
 * DESC:     PortInDiscard Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_RPORTDr 0x0e70000a

#define BCM56504_A0_RPORTDr_SIZE 4

/*
 * This structure should be used to declare and program RPORTD.
 *
 */
typedef union BCM56504_A0_RPORTDr_s {
	uint32_t v[1];
	uint32_t rportd[1];
	uint32_t _rportd;
} BCM56504_A0_RPORTDr_t;

#define BCM56504_A0_RPORTDr_CLR(r) (r).rportd[0] = 0
#define BCM56504_A0_RPORTDr_SET(r,d) (r).rportd[0] = d
#define BCM56504_A0_RPORTDr_GET(r) (r).rportd[0]


/*
 * These macros can be used to access RPORTD.
 *
 */
#define BCM56504_A0_READ_RPORTDr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_RPORTDr,(r._rportd))
#define BCM56504_A0_WRITE_RPORTDr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_RPORTDr,&(r._rportd))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RPORTDr BCM56504_A0_RPORTDr
#define RPORTDr_SIZE BCM56504_A0_RPORTDr_SIZE
typedef BCM56504_A0_RPORTDr_t RPORTDr_t;
#define RPORTDr_CLR BCM56504_A0_RPORTDr_CLR
#define RPORTDr_SET BCM56504_A0_RPORTDr_SET
#define RPORTDr_GET BCM56504_A0_RPORTDr_GET
#define READ_RPORTDr BCM56504_A0_READ_RPORTDr
#define WRITE_RPORTDr BCM56504_A0_WRITE_RPORTDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_RPORTDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  RRBYT
 * BLOCKS:   GPORT0
 * DESC:     Receive Runt Byte Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_RRBYTr 0x00f0001c

#define BCM56504_A0_RRBYTr_SIZE 4

/*
 * This structure should be used to declare and program RRBYT.
 *
 */
typedef union BCM56504_A0_RRBYTr_s {
	uint32_t v[1];
	uint32_t rrbyt[1];
	uint32_t _rrbyt;
} BCM56504_A0_RRBYTr_t;

#define BCM56504_A0_RRBYTr_CLR(r) (r).rrbyt[0] = 0
#define BCM56504_A0_RRBYTr_SET(r,d) (r).rrbyt[0] = d
#define BCM56504_A0_RRBYTr_GET(r) (r).rrbyt[0]


/*
 * These macros can be used to access RRBYT.
 *
 */
#define BCM56504_A0_READ_RRBYTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_RRBYTr,(r._rrbyt))
#define BCM56504_A0_WRITE_RRBYTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_RRBYTr,&(r._rrbyt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RRBYTr BCM56504_A0_RRBYTr
#define RRBYTr_SIZE BCM56504_A0_RRBYTr_SIZE
typedef BCM56504_A0_RRBYTr_t RRBYTr_t;
#define RRBYTr_CLR BCM56504_A0_RRBYTr_CLR
#define RRBYTr_SET BCM56504_A0_RRBYTr_SET
#define RRBYTr_GET BCM56504_A0_RRBYTr_GET
#define READ_RRBYTr BCM56504_A0_READ_RRBYTr
#define WRITE_RRBYTr BCM56504_A0_WRITE_RRBYTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_RRBYTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  RRPKT
 * BLOCKS:   GPORT0
 * DESC:     Receive RUNT Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_RRPKTr 0x00f00019

#define BCM56504_A0_RRPKTr_SIZE 4

/*
 * This structure should be used to declare and program RRPKT.
 *
 */
typedef union BCM56504_A0_RRPKTr_s {
	uint32_t v[1];
	uint32_t rrpkt[1];
	uint32_t _rrpkt;
} BCM56504_A0_RRPKTr_t;

#define BCM56504_A0_RRPKTr_CLR(r) (r).rrpkt[0] = 0
#define BCM56504_A0_RRPKTr_SET(r,d) (r).rrpkt[0] = d
#define BCM56504_A0_RRPKTr_GET(r) (r).rrpkt[0]


/*
 * These macros can be used to access RRPKT.
 *
 */
#define BCM56504_A0_READ_RRPKTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_RRPKTr,(r._rrpkt))
#define BCM56504_A0_WRITE_RRPKTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_RRPKTr,&(r._rrpkt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RRPKTr BCM56504_A0_RRPKTr
#define RRPKTr_SIZE BCM56504_A0_RRPKTr_SIZE
typedef BCM56504_A0_RRPKTr_t RRPKTr_t;
#define RRPKTr_CLR BCM56504_A0_RRPKTr_CLR
#define RRPKTr_SET BCM56504_A0_RRPKTr_SET
#define RRPKTr_GET BCM56504_A0_RRPKTr_GET
#define READ_RRPKTr BCM56504_A0_READ_RRPKTr
#define WRITE_RRPKTr BCM56504_A0_WRITE_RRPKTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_RRPKTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  RSV_READ
 * BLOCKS:   GPORT0
 * DESC:     MAC RSV (Receive Status Vector) debug register
 * SIZE:     32
 * FIELDS:
 *     ENABLE           Debug register, this provides a copy of the most recent RSV from the MAC to the core.
 *
 ******************************************************************************/
#define BCM56504_A0_RSV_READr 0x00f00304

#define BCM56504_A0_RSV_READr_SIZE 4

/*
 * This structure should be used to declare and program RSV_READ.
 *
 */
typedef union BCM56504_A0_RSV_READr_s {
	uint32_t v[1];
	uint32_t rsv_read[1];
	uint32_t _rsv_read;
} BCM56504_A0_RSV_READr_t;

#define BCM56504_A0_RSV_READr_CLR(r) (r).rsv_read[0] = 0
#define BCM56504_A0_RSV_READr_SET(r,d) (r).rsv_read[0] = d
#define BCM56504_A0_RSV_READr_GET(r) (r).rsv_read[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_RSV_READr_ENABLEf_GET(r) (((r).rsv_read[0]) & 0x7fffffff)
#define BCM56504_A0_RSV_READr_ENABLEf_SET(r,f) (r).rsv_read[0]=(((r).rsv_read[0] & ~((uint32_t)0x7fffffff)) | (((uint32_t)f) & 0x7fffffff))

/*
 * These macros can be used to access RSV_READ.
 *
 */
#define BCM56504_A0_READ_RSV_READr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_RSV_READr,(r._rsv_read))
#define BCM56504_A0_WRITE_RSV_READr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_RSV_READr,&(r._rsv_read))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RSV_READr BCM56504_A0_RSV_READr
#define RSV_READr_SIZE BCM56504_A0_RSV_READr_SIZE
typedef BCM56504_A0_RSV_READr_t RSV_READr_t;
#define RSV_READr_CLR BCM56504_A0_RSV_READr_CLR
#define RSV_READr_SET BCM56504_A0_RSV_READr_SET
#define RSV_READr_GET BCM56504_A0_RSV_READr_GET
#define RSV_READr_ENABLEf_GET BCM56504_A0_RSV_READr_ENABLEf_GET
#define RSV_READr_ENABLEf_SET BCM56504_A0_RSV_READr_ENABLEf_SET
#define READ_RSV_READr BCM56504_A0_READ_RSV_READr
#define WRITE_RSV_READr BCM56504_A0_WRITE_RSV_READr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_RSV_READr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  RUC
 * BLOCKS:   IPIPE
 * DESC:     Receive Unicast Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_RUCr 0x0e700009

#define BCM56504_A0_RUCr_SIZE 4

/*
 * This structure should be used to declare and program RUC.
 *
 */
typedef union BCM56504_A0_RUCr_s {
	uint32_t v[1];
	uint32_t ruc[1];
	uint32_t _ruc;
} BCM56504_A0_RUCr_t;

#define BCM56504_A0_RUCr_CLR(r) (r).ruc[0] = 0
#define BCM56504_A0_RUCr_SET(r,d) (r).ruc[0] = d
#define BCM56504_A0_RUCr_GET(r) (r).ruc[0]


/*
 * These macros can be used to access RUC.
 *
 */
#define BCM56504_A0_READ_RUCr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_RUCr,(r._ruc))
#define BCM56504_A0_WRITE_RUCr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_RUCr,&(r._ruc))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RUCr BCM56504_A0_RUCr
#define RUCr_SIZE BCM56504_A0_RUCr_SIZE
typedef BCM56504_A0_RUCr_t RUCr_t;
#define RUCr_CLR BCM56504_A0_RUCr_CLR
#define RUCr_SET BCM56504_A0_RUCr_SET
#define RUCr_GET BCM56504_A0_RUCr_GET
#define READ_RUCr BCM56504_A0_READ_RUCr
#define WRITE_RUCr BCM56504_A0_WRITE_RUCr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_RUCr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  RXE2EIBPBKPSTATUS
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     PORT_BITMAP      E2E IBP status received from remote module through e2e ibp packet.
 *
 ******************************************************************************/
#define BCM56504_A0_RXE2EIBPBKPSTATUSr 0x00680007

#define BCM56504_A0_RXE2EIBPBKPSTATUSr_SIZE 4

/*
 * This structure should be used to declare and program RXE2EIBPBKPSTATUS.
 *
 */
typedef union BCM56504_A0_RXE2EIBPBKPSTATUSr_s {
	uint32_t v[1];
	uint32_t rxe2eibpbkpstatus[1];
	uint32_t _rxe2eibpbkpstatus;
} BCM56504_A0_RXE2EIBPBKPSTATUSr_t;

#define BCM56504_A0_RXE2EIBPBKPSTATUSr_CLR(r) (r).rxe2eibpbkpstatus[0] = 0
#define BCM56504_A0_RXE2EIBPBKPSTATUSr_SET(r,d) (r).rxe2eibpbkpstatus[0] = d
#define BCM56504_A0_RXE2EIBPBKPSTATUSr_GET(r) (r).rxe2eibpbkpstatus[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_RXE2EIBPBKPSTATUSr_PORT_BITMAPf_GET(r) (((r).rxe2eibpbkpstatus[0]) & 0x1fffffff)
#define BCM56504_A0_RXE2EIBPBKPSTATUSr_PORT_BITMAPf_SET(r,f) (r).rxe2eibpbkpstatus[0]=(((r).rxe2eibpbkpstatus[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))

/*
 * These macros can be used to access RXE2EIBPBKPSTATUS.
 *
 */
#define BCM56504_A0_READ_RXE2EIBPBKPSTATUSr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_RXE2EIBPBKPSTATUSr,(r._rxe2eibpbkpstatus))
#define BCM56504_A0_WRITE_RXE2EIBPBKPSTATUSr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_RXE2EIBPBKPSTATUSr,&(r._rxe2eibpbkpstatus))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXE2EIBPBKPSTATUSr BCM56504_A0_RXE2EIBPBKPSTATUSr
#define RXE2EIBPBKPSTATUSr_SIZE BCM56504_A0_RXE2EIBPBKPSTATUSr_SIZE
typedef BCM56504_A0_RXE2EIBPBKPSTATUSr_t RXE2EIBPBKPSTATUSr_t;
#define RXE2EIBPBKPSTATUSr_CLR BCM56504_A0_RXE2EIBPBKPSTATUSr_CLR
#define RXE2EIBPBKPSTATUSr_SET BCM56504_A0_RXE2EIBPBKPSTATUSr_SET
#define RXE2EIBPBKPSTATUSr_GET BCM56504_A0_RXE2EIBPBKPSTATUSr_GET
#define RXE2EIBPBKPSTATUSr_PORT_BITMAPf_GET BCM56504_A0_RXE2EIBPBKPSTATUSr_PORT_BITMAPf_GET
#define RXE2EIBPBKPSTATUSr_PORT_BITMAPf_SET BCM56504_A0_RXE2EIBPBKPSTATUSr_PORT_BITMAPf_SET
#define READ_RXE2EIBPBKPSTATUSr BCM56504_A0_READ_RXE2EIBPBKPSTATUSr
#define WRITE_RXE2EIBPBKPSTATUSr BCM56504_A0_WRITE_RXE2EIBPBKPSTATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_RXE2EIBPBKPSTATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * SWFORMAT:  RX_DCB
 * BLOCKS:  
 * DESC:     Packet DMA descriptor.
 * SIZE:     352
 * FIELDS:
 *     BYTES_TRANSFERRED Number of bytes transferred.
 *     END_BIT          Descriptor is for last (or only) packet fragment.
 *     START_BIT        Descriptor is for first (or only) packet fragment.
 *     ERROR            Internal RX error encountered.
 *     DONE             Descriptor done.
 *     ADD_INNER_VLAN   Indicates if an inner VLAN tag was added to the packet.
 *     PKT_WAS_UNTAGGED Packet ingressed untagged on an Ethernet (non-HiGig) port.
 *     OUTER_VID        Outer VLAN ID of the packet.
 *     OUTER_CFI        Outer CFI assigned to the packet.
 *     OUTER_PRI        Outer priority assigned to the packet.
 *     DSCP             New DCSP value computed by the switch chip.
 *     SRC_PORT         Source port number.
 *     NHOP_INDEX       Next Hop index.
 *     MATCHED_RULE     Matched Field Processor rule.
 *     DECAP_IPTUNNEL   IP tunnel encapsulation was stripped from packet.
 *     REASON           CPU opcode, reason the packet was copied to the CPU. Bit 22 - L3 MTU check fail to CPU  Bit 21 - Parity error on IP tables  Bit 20 - L3 slow path CPU processed packets  Bit 19 - ICMP redirect copy to CPU  Bit 18 - L2 MTU check fail to CPU  Bit 17 - Tunnel error trap to CPU  Bit 16 - Martian address trap to CPU  Bit 15 - DOS attack trap to CPU  Bit 14 - Protocol packet  Bit 13 - L3 header  - IP options, TTL=0, !IPv4 etc."  Bit 12 - FP action - copy to CPU  Bit 11 - IPMC miss - {SIP, DIP} miss or DIP miss"  Bit 10 - Multicast miss   Bit 9  - Station movement - L3  Bit 8  - L3 DIP miss  Bit 7  - L3 SIP miss  Bit 6  - sFlow - Dst  Bit 5  - sFlow - Src  Bit 4  - L2_table - copy to CPU  Bit 3  - Station movement - L2  Bit 2  - Destination lookup failure   Bit 1  - Source lookup failure  Bit 0  - Learning enabled in port table and SA is learnt; Unknown VLAN ID; VLAN ID = 0xfff  
 *     REGEN_CRC        Packet was modified and CRC is no longer valid.
 *     SWITCH           Switched packet (as opposed to mirrored packet.)
 *     SRC_HG           Source is HiGig.
 *     PURGE_CELL       Packet is marked for purging.
 *     PKT_AGED         Packet is aged.
 *     MTP_INDEX        Mirror-to-Port index.
 *     L3UC             Packet is a L3 unicast packet.
 *     L3ONLY           Packet is for L3 IPMC only.
 *     L3IPMC           L3 IP multicast packet
 *     IPMC_INTF_NUM    Index to L3 table for IPMC packets.
 *     IMIRROR          Ingress mirror packet.
 *     EMIRROR          Egress mirror packet.
 *     COS              Queue number used internally for non-CPU ports.
 *     CPU_COS          Queue number used internally for the CPU port.
 *     CHANGE_DSCP      DSCP value was changed.
 *     CELL_ERROR       Packet cell had CRC or parity error.
 *     BPDU             BPDU packet
 *     ADD_VID          VLAN ID was added.
 *     MODULE_HEADER    Valid only if the SRC_HG bit is set to 1 in this descriptor.
 *     BYTE_COUNT       Maximum number of bytes for this transfer.
 *     CHAIN            Indicates that next sequential descriptor is valid.
 *     SG               Scatter/Gather - packet may continue in the next DMA descriptor.
 *     RELOAD           Load next descriptor from address in ADDR field.
 *     ADDR             Physical memory address for the transfer.
 *
 ******************************************************************************/
#define BCM56504_A0_RX_DCB 0x00000000

#define BCM56504_A0_RX_DCB_SIZE 44

/*
 * This structure should be used to declare and program RX_DCB.
 *
 */
typedef union BCM56504_A0_RX_DCB_s {
	uint32_t v[11];
	uint32_t rx_dcb[11];
	uint32_t _rx_dcb;
} BCM56504_A0_RX_DCB_t;

#define BCM56504_A0_RX_DCB_CLR(r) CDK_MEMSET(&((r)._rx_dcb), 0, sizeof(BCM56504_A0_RX_DCB_t))
#define BCM56504_A0_RX_DCB_SET(r,i,d) (r).rx_dcb[i] = d
#define BCM56504_A0_RX_DCB_GET(r,i) (r).rx_dcb[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_RX_DCB_BYTES_TRANSFERREDf_GET(r) (((r).rx_dcb[10]) & 0xffff)
#define BCM56504_A0_RX_DCB_BYTES_TRANSFERREDf_SET(r,f) (r).rx_dcb[10]=(((r).rx_dcb[10] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56504_A0_RX_DCB_END_BITf_GET(r) ((((r).rx_dcb[10]) >> 16) & 0x1)
#define BCM56504_A0_RX_DCB_END_BITf_SET(r,f) (r).rx_dcb[10]=(((r).rx_dcb[10] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56504_A0_RX_DCB_START_BITf_GET(r) ((((r).rx_dcb[10]) >> 17) & 0x1)
#define BCM56504_A0_RX_DCB_START_BITf_SET(r,f) (r).rx_dcb[10]=(((r).rx_dcb[10] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56504_A0_RX_DCB_ERRORf_GET(r) ((((r).rx_dcb[10]) >> 18) & 0x1)
#define BCM56504_A0_RX_DCB_ERRORf_SET(r,f) (r).rx_dcb[10]=(((r).rx_dcb[10] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56504_A0_RX_DCB_DONEf_GET(r) ((((r).rx_dcb[10]) >> 31) & 0x1)
#define BCM56504_A0_RX_DCB_DONEf_SET(r,f) (r).rx_dcb[10]=(((r).rx_dcb[10] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM56504_A0_RX_DCB_ADD_INNER_VLANf_GET(r) ((((r).rx_dcb[8]) >> 8) & 0x1)
#define BCM56504_A0_RX_DCB_ADD_INNER_VLANf_SET(r,f) (r).rx_dcb[8]=(((r).rx_dcb[8] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56504_A0_RX_DCB_PKT_WAS_UNTAGGEDf_GET(r) ((((r).rx_dcb[8]) >> 9) & 0x1)
#define BCM56504_A0_RX_DCB_PKT_WAS_UNTAGGEDf_SET(r,f) (r).rx_dcb[8]=(((r).rx_dcb[8] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56504_A0_RX_DCB_OUTER_VIDf_GET(r) ((((r).rx_dcb[8]) >> 10) & 0xfff)
#define BCM56504_A0_RX_DCB_OUTER_VIDf_SET(r,f) (r).rx_dcb[8]=(((r).rx_dcb[8] & ~((uint32_t)0xfff << 10)) | ((((uint32_t)f) & 0xfff) << 10))
#define BCM56504_A0_RX_DCB_OUTER_CFIf_GET(r) ((((r).rx_dcb[8]) >> 22) & 0x1)
#define BCM56504_A0_RX_DCB_OUTER_CFIf_SET(r,f) (r).rx_dcb[8]=(((r).rx_dcb[8] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM56504_A0_RX_DCB_OUTER_PRIf_GET(r) ((((r).rx_dcb[8]) >> 23) & 0x7)
#define BCM56504_A0_RX_DCB_OUTER_PRIf_SET(r,f) (r).rx_dcb[8]=(((r).rx_dcb[8] & ~((uint32_t)0x7 << 23)) | ((((uint32_t)f) & 0x7) << 23))
#define BCM56504_A0_RX_DCB_DSCPf_GET(r) cdk_field32_be_get((r).rx_dcb,11,90,)
#define BCM56504_A0_RX_DCB_DSCPf_SET(r,f) cdk_field32_be_set((r).rx_dcb,11,90,97,f)
#define BCM56504_A0_RX_DCB_SRC_PORTf_GET(r) ((((r).rx_dcb[7]) >> 2) & 0x1f)
#define BCM56504_A0_RX_DCB_SRC_PORTf_SET(r,f) (r).rx_dcb[7]=(((r).rx_dcb[7] & ~((uint32_t)0x1f << 2)) | ((((uint32_t)f) & 0x1f) << 2))
#define BCM56504_A0_RX_DCB_NHOP_INDEXf_GET(r) ((((r).rx_dcb[7]) >> 7) & 0x1fff)
#define BCM56504_A0_RX_DCB_NHOP_INDEXf_SET(r,f) (r).rx_dcb[7]=(((r).rx_dcb[7] & ~((uint32_t)0x1fff << 7)) | ((((uint32_t)f) & 0x1fff) << 7))
#define BCM56504_A0_RX_DCB_MATCHED_RULEf_GET(r) ((((r).rx_dcb[7]) >> 20) & 0x7ff)
#define BCM56504_A0_RX_DCB_MATCHED_RULEf_SET(r,f) (r).rx_dcb[7]=(((r).rx_dcb[7] & ~((uint32_t)0x7ff << 20)) | ((((uint32_t)f) & 0x7ff) << 20))
#define BCM56504_A0_RX_DCB_DECAP_IPTUNNELf_GET(r) ((((r).rx_dcb[7]) >> 31) & 0x1)
#define BCM56504_A0_RX_DCB_DECAP_IPTUNNELf_SET(r,f) (r).rx_dcb[7]=(((r).rx_dcb[7] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM56504_A0_RX_DCB_REASONf_GET(r) (((r).rx_dcb[6]) & 0x1ffffff)
#define BCM56504_A0_RX_DCB_REASONf_SET(r,f) (r).rx_dcb[6]=(((r).rx_dcb[6] & ~((uint32_t)0x1ffffff)) | (((uint32_t)f) & 0x1ffffff))
#define BCM56504_A0_RX_DCB_REGEN_CRCf_GET(r) ((((r).rx_dcb[6]) >> 25) & 0x1)
#define BCM56504_A0_RX_DCB_REGEN_CRCf_SET(r,f) (r).rx_dcb[6]=(((r).rx_dcb[6] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM56504_A0_RX_DCB_SWITCHf_GET(r) ((((r).rx_dcb[6]) >> 26) & 0x1)
#define BCM56504_A0_RX_DCB_SWITCHf_SET(r,f) (r).rx_dcb[6]=(((r).rx_dcb[6] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM56504_A0_RX_DCB_SRC_HGf_GET(r) ((((r).rx_dcb[6]) >> 27) & 0x1)
#define BCM56504_A0_RX_DCB_SRC_HGf_SET(r,f) (r).rx_dcb[6]=(((r).rx_dcb[6] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM56504_A0_RX_DCB_PURGE_CELLf_GET(r) ((((r).rx_dcb[6]) >> 28) & 0x1)
#define BCM56504_A0_RX_DCB_PURGE_CELLf_SET(r,f) (r).rx_dcb[6]=(((r).rx_dcb[6] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM56504_A0_RX_DCB_PKT_AGEDf_GET(r) ((((r).rx_dcb[6]) >> 29) & 0x1)
#define BCM56504_A0_RX_DCB_PKT_AGEDf_SET(r,f) (r).rx_dcb[6]=(((r).rx_dcb[6] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM56504_A0_RX_DCB_MTP_INDEXf_GET(r) cdk_field32_be_get((r).rx_dcb,11,158,)
#define BCM56504_A0_RX_DCB_MTP_INDEXf_SET(r,f) cdk_field32_be_set((r).rx_dcb,11,158,164,f)
#define BCM56504_A0_RX_DCB_L3UCf_GET(r) ((((r).rx_dcb[5]) >> 5) & 0x1)
#define BCM56504_A0_RX_DCB_L3UCf_SET(r,f) (r).rx_dcb[5]=(((r).rx_dcb[5] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56504_A0_RX_DCB_L3ONLYf_GET(r) ((((r).rx_dcb[5]) >> 6) & 0x1)
#define BCM56504_A0_RX_DCB_L3ONLYf_SET(r,f) (r).rx_dcb[5]=(((r).rx_dcb[5] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56504_A0_RX_DCB_L3IPMCf_GET(r) ((((r).rx_dcb[5]) >> 7) & 0x1)
#define BCM56504_A0_RX_DCB_L3IPMCf_SET(r,f) (r).rx_dcb[5]=(((r).rx_dcb[5] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56504_A0_RX_DCB_IPMC_INTF_NUMf_GET(r) ((((r).rx_dcb[5]) >> 8) & 0xfff)
#define BCM56504_A0_RX_DCB_IPMC_INTF_NUMf_SET(r,f) (r).rx_dcb[5]=(((r).rx_dcb[5] & ~((uint32_t)0xfff << 8)) | ((((uint32_t)f) & 0xfff) << 8))
#define BCM56504_A0_RX_DCB_IMIRRORf_GET(r) ((((r).rx_dcb[5]) >> 20) & 0x1)
#define BCM56504_A0_RX_DCB_IMIRRORf_SET(r,f) (r).rx_dcb[5]=(((r).rx_dcb[5] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM56504_A0_RX_DCB_EMIRRORf_GET(r) ((((r).rx_dcb[5]) >> 21) & 0x1)
#define BCM56504_A0_RX_DCB_EMIRRORf_SET(r,f) (r).rx_dcb[5]=(((r).rx_dcb[5] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM56504_A0_RX_DCB_COSf_GET(r) ((((r).rx_dcb[5]) >> 22) & 0x7)
#define BCM56504_A0_RX_DCB_COSf_SET(r,f) (r).rx_dcb[5]=(((r).rx_dcb[5] & ~((uint32_t)0x7 << 22)) | ((((uint32_t)f) & 0x7) << 22))
#define BCM56504_A0_RX_DCB_CPU_COSf_GET(r) ((((r).rx_dcb[5]) >> 25) & 0x7)
#define BCM56504_A0_RX_DCB_CPU_COSf_SET(r,f) (r).rx_dcb[5]=(((r).rx_dcb[5] & ~((uint32_t)0x7 << 25)) | ((((uint32_t)f) & 0x7) << 25))
#define BCM56504_A0_RX_DCB_CHANGE_DSCPf_GET(r) ((((r).rx_dcb[5]) >> 28) & 0x1)
#define BCM56504_A0_RX_DCB_CHANGE_DSCPf_SET(r,f) (r).rx_dcb[5]=(((r).rx_dcb[5] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM56504_A0_RX_DCB_CELL_ERRORf_GET(r) ((((r).rx_dcb[5]) >> 29) & 0x1)
#define BCM56504_A0_RX_DCB_CELL_ERRORf_SET(r,f) (r).rx_dcb[5]=(((r).rx_dcb[5] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM56504_A0_RX_DCB_BPDUf_GET(r) ((((r).rx_dcb[5]) >> 30) & 0x1)
#define BCM56504_A0_RX_DCB_BPDUf_SET(r,f) (r).rx_dcb[5]=(((r).rx_dcb[5] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM56504_A0_RX_DCB_ADD_VIDf_GET(r) ((((r).rx_dcb[5]) >> 31) & 0x1)
#define BCM56504_A0_RX_DCB_ADD_VIDf_SET(r,f) (r).rx_dcb[5]=(((r).rx_dcb[5] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM56504_A0_RX_DCB_MODULE_HEADERf_GET(r,a) cdk_field_be_get((r).rx_dcb,11,192,287,a)
#define BCM56504_A0_RX_DCB_MODULE_HEADERf_SET(r,a) cdk_field_be_set((r).rx_dcb,11,192,287,a)
#define BCM56504_A0_RX_DCB_MODULE_HEADERf_PTR(r) ((void*)&(r).rx_dcb[2])
#define BCM56504_A0_RX_DCB_BYTE_COUNTf_GET(r) (((r).rx_dcb[1]) & 0xffff)
#define BCM56504_A0_RX_DCB_BYTE_COUNTf_SET(r,f) (r).rx_dcb[1]=(((r).rx_dcb[1] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56504_A0_RX_DCB_CHAINf_GET(r) ((((r).rx_dcb[1]) >> 16) & 0x1)
#define BCM56504_A0_RX_DCB_CHAINf_SET(r,f) (r).rx_dcb[1]=(((r).rx_dcb[1] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56504_A0_RX_DCB_SGf_GET(r) ((((r).rx_dcb[1]) >> 17) & 0x1)
#define BCM56504_A0_RX_DCB_SGf_SET(r,f) (r).rx_dcb[1]=(((r).rx_dcb[1] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56504_A0_RX_DCB_RELOADf_GET(r) ((((r).rx_dcb[1]) >> 18) & 0x1)
#define BCM56504_A0_RX_DCB_RELOADf_SET(r,f) (r).rx_dcb[1]=(((r).rx_dcb[1] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56504_A0_RX_DCB_ADDRf_GET(r) ((r).rx_dcb[0])
#define BCM56504_A0_RX_DCB_ADDRf_SET(r,f) (r).rx_dcb[0]=((uint32_t)f)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RX_DCB BCM56504_A0_RX_DCB
#define RX_DCB_SIZE BCM56504_A0_RX_DCB_SIZE
typedef BCM56504_A0_RX_DCB_t RX_DCB_t;
#define RX_DCB_CLR BCM56504_A0_RX_DCB_CLR
#define RX_DCB_SET BCM56504_A0_RX_DCB_SET
#define RX_DCB_GET BCM56504_A0_RX_DCB_GET
#define RX_DCB_BYTES_TRANSFERREDf_GET BCM56504_A0_RX_DCB_BYTES_TRANSFERREDf_GET
#define RX_DCB_BYTES_TRANSFERREDf_SET BCM56504_A0_RX_DCB_BYTES_TRANSFERREDf_SET
#define RX_DCB_END_BITf_GET BCM56504_A0_RX_DCB_END_BITf_GET
#define RX_DCB_END_BITf_SET BCM56504_A0_RX_DCB_END_BITf_SET
#define RX_DCB_START_BITf_GET BCM56504_A0_RX_DCB_START_BITf_GET
#define RX_DCB_START_BITf_SET BCM56504_A0_RX_DCB_START_BITf_SET
#define RX_DCB_ERRORf_GET BCM56504_A0_RX_DCB_ERRORf_GET
#define RX_DCB_ERRORf_SET BCM56504_A0_RX_DCB_ERRORf_SET
#define RX_DCB_DONEf_GET BCM56504_A0_RX_DCB_DONEf_GET
#define RX_DCB_DONEf_SET BCM56504_A0_RX_DCB_DONEf_SET
#define RX_DCB_ADD_INNER_VLANf_GET BCM56504_A0_RX_DCB_ADD_INNER_VLANf_GET
#define RX_DCB_ADD_INNER_VLANf_SET BCM56504_A0_RX_DCB_ADD_INNER_VLANf_SET
#define RX_DCB_PKT_WAS_UNTAGGEDf_GET BCM56504_A0_RX_DCB_PKT_WAS_UNTAGGEDf_GET
#define RX_DCB_PKT_WAS_UNTAGGEDf_SET BCM56504_A0_RX_DCB_PKT_WAS_UNTAGGEDf_SET
#define RX_DCB_OUTER_VIDf_GET BCM56504_A0_RX_DCB_OUTER_VIDf_GET
#define RX_DCB_OUTER_VIDf_SET BCM56504_A0_RX_DCB_OUTER_VIDf_SET
#define RX_DCB_OUTER_CFIf_GET BCM56504_A0_RX_DCB_OUTER_CFIf_GET
#define RX_DCB_OUTER_CFIf_SET BCM56504_A0_RX_DCB_OUTER_CFIf_SET
#define RX_DCB_OUTER_PRIf_GET BCM56504_A0_RX_DCB_OUTER_PRIf_GET
#define RX_DCB_OUTER_PRIf_SET BCM56504_A0_RX_DCB_OUTER_PRIf_SET
#define RX_DCB_DSCPf_GET BCM56504_A0_RX_DCB_DSCPf_GET
#define RX_DCB_DSCPf_SET BCM56504_A0_RX_DCB_DSCPf_SET
#define RX_DCB_SRC_PORTf_GET BCM56504_A0_RX_DCB_SRC_PORTf_GET
#define RX_DCB_SRC_PORTf_SET BCM56504_A0_RX_DCB_SRC_PORTf_SET
#define RX_DCB_NHOP_INDEXf_GET BCM56504_A0_RX_DCB_NHOP_INDEXf_GET
#define RX_DCB_NHOP_INDEXf_SET BCM56504_A0_RX_DCB_NHOP_INDEXf_SET
#define RX_DCB_MATCHED_RULEf_GET BCM56504_A0_RX_DCB_MATCHED_RULEf_GET
#define RX_DCB_MATCHED_RULEf_SET BCM56504_A0_RX_DCB_MATCHED_RULEf_SET
#define RX_DCB_DECAP_IPTUNNELf_GET BCM56504_A0_RX_DCB_DECAP_IPTUNNELf_GET
#define RX_DCB_DECAP_IPTUNNELf_SET BCM56504_A0_RX_DCB_DECAP_IPTUNNELf_SET
#define RX_DCB_REASONf_GET BCM56504_A0_RX_DCB_REASONf_GET
#define RX_DCB_REASONf_SET BCM56504_A0_RX_DCB_REASONf_SET
#define RX_DCB_REGEN_CRCf_GET BCM56504_A0_RX_DCB_REGEN_CRCf_GET
#define RX_DCB_REGEN_CRCf_SET BCM56504_A0_RX_DCB_REGEN_CRCf_SET
#define RX_DCB_SWITCHf_GET BCM56504_A0_RX_DCB_SWITCHf_GET
#define RX_DCB_SWITCHf_SET BCM56504_A0_RX_DCB_SWITCHf_SET
#define RX_DCB_SRC_HGf_GET BCM56504_A0_RX_DCB_SRC_HGf_GET
#define RX_DCB_SRC_HGf_SET BCM56504_A0_RX_DCB_SRC_HGf_SET
#define RX_DCB_PURGE_CELLf_GET BCM56504_A0_RX_DCB_PURGE_CELLf_GET
#define RX_DCB_PURGE_CELLf_SET BCM56504_A0_RX_DCB_PURGE_CELLf_SET
#define RX_DCB_PKT_AGEDf_GET BCM56504_A0_RX_DCB_PKT_AGEDf_GET
#define RX_DCB_PKT_AGEDf_SET BCM56504_A0_RX_DCB_PKT_AGEDf_SET
#define RX_DCB_MTP_INDEXf_GET BCM56504_A0_RX_DCB_MTP_INDEXf_GET
#define RX_DCB_MTP_INDEXf_SET BCM56504_A0_RX_DCB_MTP_INDEXf_SET
#define RX_DCB_L3UCf_GET BCM56504_A0_RX_DCB_L3UCf_GET
#define RX_DCB_L3UCf_SET BCM56504_A0_RX_DCB_L3UCf_SET
#define RX_DCB_L3ONLYf_GET BCM56504_A0_RX_DCB_L3ONLYf_GET
#define RX_DCB_L3ONLYf_SET BCM56504_A0_RX_DCB_L3ONLYf_SET
#define RX_DCB_L3IPMCf_GET BCM56504_A0_RX_DCB_L3IPMCf_GET
#define RX_DCB_L3IPMCf_SET BCM56504_A0_RX_DCB_L3IPMCf_SET
#define RX_DCB_IPMC_INTF_NUMf_GET BCM56504_A0_RX_DCB_IPMC_INTF_NUMf_GET
#define RX_DCB_IPMC_INTF_NUMf_SET BCM56504_A0_RX_DCB_IPMC_INTF_NUMf_SET
#define RX_DCB_IMIRRORf_GET BCM56504_A0_RX_DCB_IMIRRORf_GET
#define RX_DCB_IMIRRORf_SET BCM56504_A0_RX_DCB_IMIRRORf_SET
#define RX_DCB_EMIRRORf_GET BCM56504_A0_RX_DCB_EMIRRORf_GET
#define RX_DCB_EMIRRORf_SET BCM56504_A0_RX_DCB_EMIRRORf_SET
#define RX_DCB_COSf_GET BCM56504_A0_RX_DCB_COSf_GET
#define RX_DCB_COSf_SET BCM56504_A0_RX_DCB_COSf_SET
#define RX_DCB_CPU_COSf_GET BCM56504_A0_RX_DCB_CPU_COSf_GET
#define RX_DCB_CPU_COSf_SET BCM56504_A0_RX_DCB_CPU_COSf_SET
#define RX_DCB_CHANGE_DSCPf_GET BCM56504_A0_RX_DCB_CHANGE_DSCPf_GET
#define RX_DCB_CHANGE_DSCPf_SET BCM56504_A0_RX_DCB_CHANGE_DSCPf_SET
#define RX_DCB_CELL_ERRORf_GET BCM56504_A0_RX_DCB_CELL_ERRORf_GET
#define RX_DCB_CELL_ERRORf_SET BCM56504_A0_RX_DCB_CELL_ERRORf_SET
#define RX_DCB_BPDUf_GET BCM56504_A0_RX_DCB_BPDUf_GET
#define RX_DCB_BPDUf_SET BCM56504_A0_RX_DCB_BPDUf_SET
#define RX_DCB_ADD_VIDf_GET BCM56504_A0_RX_DCB_ADD_VIDf_GET
#define RX_DCB_ADD_VIDf_SET BCM56504_A0_RX_DCB_ADD_VIDf_SET
#define RX_DCB_MODULE_HEADERf_GET BCM56504_A0_RX_DCB_MODULE_HEADERf_GET
#define RX_DCB_MODULE_HEADERf_SET BCM56504_A0_RX_DCB_MODULE_HEADERf_SET
#define RX_DCB_MODULE_HEADERf_PTR BCM56504_A0_RX_DCB_MODULE_HEADERf_PTR
#define RX_DCB_BYTE_COUNTf_GET BCM56504_A0_RX_DCB_BYTE_COUNTf_GET
#define RX_DCB_BYTE_COUNTf_SET BCM56504_A0_RX_DCB_BYTE_COUNTf_SET
#define RX_DCB_CHAINf_GET BCM56504_A0_RX_DCB_CHAINf_GET
#define RX_DCB_CHAINf_SET BCM56504_A0_RX_DCB_CHAINf_SET
#define RX_DCB_SGf_GET BCM56504_A0_RX_DCB_SGf_GET
#define RX_DCB_SGf_SET BCM56504_A0_RX_DCB_SGf_SET
#define RX_DCB_RELOADf_GET BCM56504_A0_RX_DCB_RELOADf_GET
#define RX_DCB_RELOADf_SET BCM56504_A0_RX_DCB_RELOADf_SET
#define RX_DCB_ADDRf_GET BCM56504_A0_RX_DCB_ADDRf_GET
#define RX_DCB_ADDRf_SET BCM56504_A0_RX_DCB_ADDRf_SET
#define READ_RX_DCB BCM56504_A0_READ_RX_DCB
#define WRITE_RX_DCB BCM56504_A0_WRITE_RX_DCB

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_RX_DCB'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  SFLOW_EGR_RAND_SEED
 * BLOCKS:   IPIPE
 * DESC:     sFlow Egress Random Number Generator Seed Register
 * SIZE:     32
 * FIELDS:
 *     SEED             Seed for sFlow Egress Random Number Generator
 *
 ******************************************************************************/
#define BCM56504_A0_SFLOW_EGR_RAND_SEEDr 0x0e780117

#define BCM56504_A0_SFLOW_EGR_RAND_SEEDr_SIZE 4

/*
 * This structure should be used to declare and program SFLOW_EGR_RAND_SEED.
 *
 */
typedef union BCM56504_A0_SFLOW_EGR_RAND_SEEDr_s {
	uint32_t v[1];
	uint32_t sflow_egr_rand_seed[1];
	uint32_t _sflow_egr_rand_seed;
} BCM56504_A0_SFLOW_EGR_RAND_SEEDr_t;

#define BCM56504_A0_SFLOW_EGR_RAND_SEEDr_CLR(r) (r).sflow_egr_rand_seed[0] = 0
#define BCM56504_A0_SFLOW_EGR_RAND_SEEDr_SET(r,d) (r).sflow_egr_rand_seed[0] = d
#define BCM56504_A0_SFLOW_EGR_RAND_SEEDr_GET(r) (r).sflow_egr_rand_seed[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_SFLOW_EGR_RAND_SEEDr_SEEDf_GET(r) (((r).sflow_egr_rand_seed[0]) & 0x1ffffff)
#define BCM56504_A0_SFLOW_EGR_RAND_SEEDr_SEEDf_SET(r,f) (r).sflow_egr_rand_seed[0]=(((r).sflow_egr_rand_seed[0] & ~((uint32_t)0x1ffffff)) | (((uint32_t)f) & 0x1ffffff))

/*
 * These macros can be used to access SFLOW_EGR_RAND_SEED.
 *
 */
#define BCM56504_A0_READ_SFLOW_EGR_RAND_SEEDr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_SFLOW_EGR_RAND_SEEDr,(r._sflow_egr_rand_seed))
#define BCM56504_A0_WRITE_SFLOW_EGR_RAND_SEEDr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_SFLOW_EGR_RAND_SEEDr,&(r._sflow_egr_rand_seed))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SFLOW_EGR_RAND_SEEDr BCM56504_A0_SFLOW_EGR_RAND_SEEDr
#define SFLOW_EGR_RAND_SEEDr_SIZE BCM56504_A0_SFLOW_EGR_RAND_SEEDr_SIZE
typedef BCM56504_A0_SFLOW_EGR_RAND_SEEDr_t SFLOW_EGR_RAND_SEEDr_t;
#define SFLOW_EGR_RAND_SEEDr_CLR BCM56504_A0_SFLOW_EGR_RAND_SEEDr_CLR
#define SFLOW_EGR_RAND_SEEDr_SET BCM56504_A0_SFLOW_EGR_RAND_SEEDr_SET
#define SFLOW_EGR_RAND_SEEDr_GET BCM56504_A0_SFLOW_EGR_RAND_SEEDr_GET
#define SFLOW_EGR_RAND_SEEDr_SEEDf_GET BCM56504_A0_SFLOW_EGR_RAND_SEEDr_SEEDf_GET
#define SFLOW_EGR_RAND_SEEDr_SEEDf_SET BCM56504_A0_SFLOW_EGR_RAND_SEEDr_SEEDf_SET
#define READ_SFLOW_EGR_RAND_SEEDr BCM56504_A0_READ_SFLOW_EGR_RAND_SEEDr
#define WRITE_SFLOW_EGR_RAND_SEEDr BCM56504_A0_WRITE_SFLOW_EGR_RAND_SEEDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_SFLOW_EGR_RAND_SEEDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  SFLOW_EGR_THRESHOLD
 * BLOCKS:   IPIPE
 * DESC:     sFlow Egress Threshold Register
 * SIZE:     32
 * FIELDS:
 *     THRESHOLD        sFlow Egress Threshold Value
 *     ENABLE           Enable sFlow Egress
 *
 ******************************************************************************/
#define BCM56504_A0_SFLOW_EGR_THRESHOLDr 0x0e700107

#define BCM56504_A0_SFLOW_EGR_THRESHOLDr_SIZE 4

/*
 * This structure should be used to declare and program SFLOW_EGR_THRESHOLD.
 *
 */
typedef union BCM56504_A0_SFLOW_EGR_THRESHOLDr_s {
	uint32_t v[1];
	uint32_t sflow_egr_threshold[1];
	uint32_t _sflow_egr_threshold;
} BCM56504_A0_SFLOW_EGR_THRESHOLDr_t;

#define BCM56504_A0_SFLOW_EGR_THRESHOLDr_CLR(r) (r).sflow_egr_threshold[0] = 0
#define BCM56504_A0_SFLOW_EGR_THRESHOLDr_SET(r,d) (r).sflow_egr_threshold[0] = d
#define BCM56504_A0_SFLOW_EGR_THRESHOLDr_GET(r) (r).sflow_egr_threshold[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_SFLOW_EGR_THRESHOLDr_THRESHOLDf_GET(r) (((r).sflow_egr_threshold[0]) & 0xffff)
#define BCM56504_A0_SFLOW_EGR_THRESHOLDr_THRESHOLDf_SET(r,f) (r).sflow_egr_threshold[0]=(((r).sflow_egr_threshold[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56504_A0_SFLOW_EGR_THRESHOLDr_ENABLEf_GET(r) ((((r).sflow_egr_threshold[0]) >> 16) & 0x1)
#define BCM56504_A0_SFLOW_EGR_THRESHOLDr_ENABLEf_SET(r,f) (r).sflow_egr_threshold[0]=(((r).sflow_egr_threshold[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))

/*
 * These macros can be used to access SFLOW_EGR_THRESHOLD.
 *
 */
#define BCM56504_A0_READ_SFLOW_EGR_THRESHOLDr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_SFLOW_EGR_THRESHOLDr,(r._sflow_egr_threshold))
#define BCM56504_A0_WRITE_SFLOW_EGR_THRESHOLDr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_SFLOW_EGR_THRESHOLDr,&(r._sflow_egr_threshold))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SFLOW_EGR_THRESHOLDr BCM56504_A0_SFLOW_EGR_THRESHOLDr
#define SFLOW_EGR_THRESHOLDr_SIZE BCM56504_A0_SFLOW_EGR_THRESHOLDr_SIZE
typedef BCM56504_A0_SFLOW_EGR_THRESHOLDr_t SFLOW_EGR_THRESHOLDr_t;
#define SFLOW_EGR_THRESHOLDr_CLR BCM56504_A0_SFLOW_EGR_THRESHOLDr_CLR
#define SFLOW_EGR_THRESHOLDr_SET BCM56504_A0_SFLOW_EGR_THRESHOLDr_SET
#define SFLOW_EGR_THRESHOLDr_GET BCM56504_A0_SFLOW_EGR_THRESHOLDr_GET
#define SFLOW_EGR_THRESHOLDr_THRESHOLDf_GET BCM56504_A0_SFLOW_EGR_THRESHOLDr_THRESHOLDf_GET
#define SFLOW_EGR_THRESHOLDr_THRESHOLDf_SET BCM56504_A0_SFLOW_EGR_THRESHOLDr_THRESHOLDf_SET
#define SFLOW_EGR_THRESHOLDr_ENABLEf_GET BCM56504_A0_SFLOW_EGR_THRESHOLDr_ENABLEf_GET
#define SFLOW_EGR_THRESHOLDr_ENABLEf_SET BCM56504_A0_SFLOW_EGR_THRESHOLDr_ENABLEf_SET
#define READ_SFLOW_EGR_THRESHOLDr BCM56504_A0_READ_SFLOW_EGR_THRESHOLDr
#define WRITE_SFLOW_EGR_THRESHOLDr BCM56504_A0_WRITE_SFLOW_EGR_THRESHOLDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_SFLOW_EGR_THRESHOLDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  SFLOW_ING_RAND_SEED
 * BLOCKS:   IPIPE
 * DESC:     sFlow Ingress Random Number Generator Seed Register
 * SIZE:     32
 * FIELDS:
 *     SEED             Seed for sFlow Ingress Random Number Generator
 *
 ******************************************************************************/
#define BCM56504_A0_SFLOW_ING_RAND_SEEDr 0x0e780116

#define BCM56504_A0_SFLOW_ING_RAND_SEEDr_SIZE 4

/*
 * This structure should be used to declare and program SFLOW_ING_RAND_SEED.
 *
 */
typedef union BCM56504_A0_SFLOW_ING_RAND_SEEDr_s {
	uint32_t v[1];
	uint32_t sflow_ing_rand_seed[1];
	uint32_t _sflow_ing_rand_seed;
} BCM56504_A0_SFLOW_ING_RAND_SEEDr_t;

#define BCM56504_A0_SFLOW_ING_RAND_SEEDr_CLR(r) (r).sflow_ing_rand_seed[0] = 0
#define BCM56504_A0_SFLOW_ING_RAND_SEEDr_SET(r,d) (r).sflow_ing_rand_seed[0] = d
#define BCM56504_A0_SFLOW_ING_RAND_SEEDr_GET(r) (r).sflow_ing_rand_seed[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_SFLOW_ING_RAND_SEEDr_SEEDf_GET(r) (((r).sflow_ing_rand_seed[0]) & 0x1ffffff)
#define BCM56504_A0_SFLOW_ING_RAND_SEEDr_SEEDf_SET(r,f) (r).sflow_ing_rand_seed[0]=(((r).sflow_ing_rand_seed[0] & ~((uint32_t)0x1ffffff)) | (((uint32_t)f) & 0x1ffffff))

/*
 * These macros can be used to access SFLOW_ING_RAND_SEED.
 *
 */
#define BCM56504_A0_READ_SFLOW_ING_RAND_SEEDr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_SFLOW_ING_RAND_SEEDr,(r._sflow_ing_rand_seed))
#define BCM56504_A0_WRITE_SFLOW_ING_RAND_SEEDr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_SFLOW_ING_RAND_SEEDr,&(r._sflow_ing_rand_seed))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SFLOW_ING_RAND_SEEDr BCM56504_A0_SFLOW_ING_RAND_SEEDr
#define SFLOW_ING_RAND_SEEDr_SIZE BCM56504_A0_SFLOW_ING_RAND_SEEDr_SIZE
typedef BCM56504_A0_SFLOW_ING_RAND_SEEDr_t SFLOW_ING_RAND_SEEDr_t;
#define SFLOW_ING_RAND_SEEDr_CLR BCM56504_A0_SFLOW_ING_RAND_SEEDr_CLR
#define SFLOW_ING_RAND_SEEDr_SET BCM56504_A0_SFLOW_ING_RAND_SEEDr_SET
#define SFLOW_ING_RAND_SEEDr_GET BCM56504_A0_SFLOW_ING_RAND_SEEDr_GET
#define SFLOW_ING_RAND_SEEDr_SEEDf_GET BCM56504_A0_SFLOW_ING_RAND_SEEDr_SEEDf_GET
#define SFLOW_ING_RAND_SEEDr_SEEDf_SET BCM56504_A0_SFLOW_ING_RAND_SEEDr_SEEDf_SET
#define READ_SFLOW_ING_RAND_SEEDr BCM56504_A0_READ_SFLOW_ING_RAND_SEEDr
#define WRITE_SFLOW_ING_RAND_SEEDr BCM56504_A0_WRITE_SFLOW_ING_RAND_SEEDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_SFLOW_ING_RAND_SEEDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  SFLOW_ING_THRESHOLD
 * BLOCKS:   IPIPE
 * DESC:     sFlow Ingress Threshold Register
 * SIZE:     32
 * FIELDS:
 *     THRESHOLD        sFlow Ingress Threshold Value
 *     ENABLE           Enable sFlow Ingress
 *
 ******************************************************************************/
#define BCM56504_A0_SFLOW_ING_THRESHOLDr 0x0e700106

#define BCM56504_A0_SFLOW_ING_THRESHOLDr_SIZE 4

/*
 * This structure should be used to declare and program SFLOW_ING_THRESHOLD.
 *
 */
typedef union BCM56504_A0_SFLOW_ING_THRESHOLDr_s {
	uint32_t v[1];
	uint32_t sflow_ing_threshold[1];
	uint32_t _sflow_ing_threshold;
} BCM56504_A0_SFLOW_ING_THRESHOLDr_t;

#define BCM56504_A0_SFLOW_ING_THRESHOLDr_CLR(r) (r).sflow_ing_threshold[0] = 0
#define BCM56504_A0_SFLOW_ING_THRESHOLDr_SET(r,d) (r).sflow_ing_threshold[0] = d
#define BCM56504_A0_SFLOW_ING_THRESHOLDr_GET(r) (r).sflow_ing_threshold[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_SFLOW_ING_THRESHOLDr_THRESHOLDf_GET(r) (((r).sflow_ing_threshold[0]) & 0xffff)
#define BCM56504_A0_SFLOW_ING_THRESHOLDr_THRESHOLDf_SET(r,f) (r).sflow_ing_threshold[0]=(((r).sflow_ing_threshold[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56504_A0_SFLOW_ING_THRESHOLDr_ENABLEf_GET(r) ((((r).sflow_ing_threshold[0]) >> 16) & 0x1)
#define BCM56504_A0_SFLOW_ING_THRESHOLDr_ENABLEf_SET(r,f) (r).sflow_ing_threshold[0]=(((r).sflow_ing_threshold[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))

/*
 * These macros can be used to access SFLOW_ING_THRESHOLD.
 *
 */
#define BCM56504_A0_READ_SFLOW_ING_THRESHOLDr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_SFLOW_ING_THRESHOLDr,(r._sflow_ing_threshold))
#define BCM56504_A0_WRITE_SFLOW_ING_THRESHOLDr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_SFLOW_ING_THRESHOLDr,&(r._sflow_ing_threshold))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SFLOW_ING_THRESHOLDr BCM56504_A0_SFLOW_ING_THRESHOLDr
#define SFLOW_ING_THRESHOLDr_SIZE BCM56504_A0_SFLOW_ING_THRESHOLDr_SIZE
typedef BCM56504_A0_SFLOW_ING_THRESHOLDr_t SFLOW_ING_THRESHOLDr_t;
#define SFLOW_ING_THRESHOLDr_CLR BCM56504_A0_SFLOW_ING_THRESHOLDr_CLR
#define SFLOW_ING_THRESHOLDr_SET BCM56504_A0_SFLOW_ING_THRESHOLDr_SET
#define SFLOW_ING_THRESHOLDr_GET BCM56504_A0_SFLOW_ING_THRESHOLDr_GET
#define SFLOW_ING_THRESHOLDr_THRESHOLDf_GET BCM56504_A0_SFLOW_ING_THRESHOLDr_THRESHOLDf_GET
#define SFLOW_ING_THRESHOLDr_THRESHOLDf_SET BCM56504_A0_SFLOW_ING_THRESHOLDr_THRESHOLDf_SET
#define SFLOW_ING_THRESHOLDr_ENABLEf_GET BCM56504_A0_SFLOW_ING_THRESHOLDr_ENABLEf_GET
#define SFLOW_ING_THRESHOLDr_ENABLEf_SET BCM56504_A0_SFLOW_ING_THRESHOLDr_ENABLEf_SET
#define READ_SFLOW_ING_THRESHOLDr BCM56504_A0_READ_SFLOW_ING_THRESHOLDr
#define WRITE_SFLOW_ING_THRESHOLDr BCM56504_A0_WRITE_SFLOW_ING_THRESHOLDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_SFLOW_ING_THRESHOLDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  SOFTRESETPBM
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     SOFTRESETPBM     Ingress Port Bitmap indicats which Ingress Port is generating software reset error. Bitmap will be clear after a register read.
 *
 ******************************************************************************/
#define BCM56504_A0_SOFTRESETPBMr 0x00680035

#define BCM56504_A0_SOFTRESETPBMr_SIZE 4

/*
 * This structure should be used to declare and program SOFTRESETPBM.
 *
 */
typedef union BCM56504_A0_SOFTRESETPBMr_s {
	uint32_t v[1];
	uint32_t softresetpbm[1];
	uint32_t _softresetpbm;
} BCM56504_A0_SOFTRESETPBMr_t;

#define BCM56504_A0_SOFTRESETPBMr_CLR(r) (r).softresetpbm[0] = 0
#define BCM56504_A0_SOFTRESETPBMr_SET(r,d) (r).softresetpbm[0] = d
#define BCM56504_A0_SOFTRESETPBMr_GET(r) (r).softresetpbm[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_SOFTRESETPBMr_SOFTRESETPBMf_GET(r) (((r).softresetpbm[0]) & 0x1fffffff)
#define BCM56504_A0_SOFTRESETPBMr_SOFTRESETPBMf_SET(r,f) (r).softresetpbm[0]=(((r).softresetpbm[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))

/*
 * These macros can be used to access SOFTRESETPBM.
 *
 */
#define BCM56504_A0_READ_SOFTRESETPBMr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_SOFTRESETPBMr,(r._softresetpbm))
#define BCM56504_A0_WRITE_SOFTRESETPBMr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_SOFTRESETPBMr,&(r._softresetpbm))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SOFTRESETPBMr BCM56504_A0_SOFTRESETPBMr
#define SOFTRESETPBMr_SIZE BCM56504_A0_SOFTRESETPBMr_SIZE
typedef BCM56504_A0_SOFTRESETPBMr_t SOFTRESETPBMr_t;
#define SOFTRESETPBMr_CLR BCM56504_A0_SOFTRESETPBMr_CLR
#define SOFTRESETPBMr_SET BCM56504_A0_SOFTRESETPBMr_SET
#define SOFTRESETPBMr_GET BCM56504_A0_SOFTRESETPBMr_GET
#define SOFTRESETPBMr_SOFTRESETPBMf_GET BCM56504_A0_SOFTRESETPBMr_SOFTRESETPBMf_GET
#define SOFTRESETPBMr_SOFTRESETPBMf_SET BCM56504_A0_SOFTRESETPBMr_SOFTRESETPBMf_SET
#define READ_SOFTRESETPBMr BCM56504_A0_READ_SOFTRESETPBMr
#define WRITE_SOFTRESETPBMr BCM56504_A0_WRITE_SOFTRESETPBMr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_SOFTRESETPBMr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * SWFORMAT:  SOFTWARE_BLOCKMAP
 * BLOCKS:  
 * DESC:     Software Blockmap
 * SIZE:     9
 * FIELDS:
 *     BSAFE            Software Block Flag for BSAFE
 *     CMIC             Software Block Flag for CMIC
 *     EPIPE            Software Block Flag for EPIPE
 *     EPIPE_HI         Software Block Flag for EPIPE_HI
 *     GPORT            Software Block Flag for GPORT
 *     IPIPE            Software Block Flag for IPIPE
 *     IPIPE_HI         Software Block Flag for IPIPE_HI
 *     MMU              Software Block Flag for MMU
 *     XPORT            Software Block Flag for XPORT
 *
 ******************************************************************************/
#define BCM56504_A0_SOFTWARE_BLOCKMAP 0x00000000

#define BCM56504_A0_SOFTWARE_BLOCKMAP_SIZE 2

/*
 * This structure should be used to declare and program SOFTWARE_BLOCKMAP.
 *
 */
typedef union BCM56504_A0_SOFTWARE_BLOCKMAP_s {
	uint32_t v[1];
	uint32_t software_blockmap[1];
	uint32_t _software_blockmap;
} BCM56504_A0_SOFTWARE_BLOCKMAP_t;

#define BCM56504_A0_SOFTWARE_BLOCKMAP_CLR(r) (r).software_blockmap[0] = 0
#define BCM56504_A0_SOFTWARE_BLOCKMAP_SET(r,d) (r).software_blockmap[0] = d
#define BCM56504_A0_SOFTWARE_BLOCKMAP_GET(r) (r).software_blockmap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_SOFTWARE_BLOCKMAP_BSAFEf_GET(r) (((r).software_blockmap[0]) & 0x1)
#define BCM56504_A0_SOFTWARE_BLOCKMAP_BSAFEf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_SOFTWARE_BLOCKMAP_CMICf_GET(r) ((((r).software_blockmap[0]) >> 1) & 0x1)
#define BCM56504_A0_SOFTWARE_BLOCKMAP_CMICf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_SOFTWARE_BLOCKMAP_EPIPEf_GET(r) ((((r).software_blockmap[0]) >> 2) & 0x1)
#define BCM56504_A0_SOFTWARE_BLOCKMAP_EPIPEf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_SOFTWARE_BLOCKMAP_EPIPE_HIf_GET(r) ((((r).software_blockmap[0]) >> 3) & 0x1)
#define BCM56504_A0_SOFTWARE_BLOCKMAP_EPIPE_HIf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_SOFTWARE_BLOCKMAP_GPORTf_GET(r) ((((r).software_blockmap[0]) >> 4) & 0x1)
#define BCM56504_A0_SOFTWARE_BLOCKMAP_GPORTf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56504_A0_SOFTWARE_BLOCKMAP_IPIPEf_GET(r) ((((r).software_blockmap[0]) >> 5) & 0x1)
#define BCM56504_A0_SOFTWARE_BLOCKMAP_IPIPEf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56504_A0_SOFTWARE_BLOCKMAP_IPIPE_HIf_GET(r) ((((r).software_blockmap[0]) >> 6) & 0x1)
#define BCM56504_A0_SOFTWARE_BLOCKMAP_IPIPE_HIf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56504_A0_SOFTWARE_BLOCKMAP_MMUf_GET(r) ((((r).software_blockmap[0]) >> 7) & 0x1)
#define BCM56504_A0_SOFTWARE_BLOCKMAP_MMUf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56504_A0_SOFTWARE_BLOCKMAP_XPORTf_GET(r) ((((r).software_blockmap[0]) >> 8) & 0x1)
#define BCM56504_A0_SOFTWARE_BLOCKMAP_XPORTf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SOFTWARE_BLOCKMAP BCM56504_A0_SOFTWARE_BLOCKMAP
#define SOFTWARE_BLOCKMAP_SIZE BCM56504_A0_SOFTWARE_BLOCKMAP_SIZE
typedef BCM56504_A0_SOFTWARE_BLOCKMAP_t SOFTWARE_BLOCKMAP_t;
#define SOFTWARE_BLOCKMAP_CLR BCM56504_A0_SOFTWARE_BLOCKMAP_CLR
#define SOFTWARE_BLOCKMAP_SET BCM56504_A0_SOFTWARE_BLOCKMAP_SET
#define SOFTWARE_BLOCKMAP_GET BCM56504_A0_SOFTWARE_BLOCKMAP_GET
#define SOFTWARE_BLOCKMAP_BSAFEf_GET BCM56504_A0_SOFTWARE_BLOCKMAP_BSAFEf_GET
#define SOFTWARE_BLOCKMAP_BSAFEf_SET BCM56504_A0_SOFTWARE_BLOCKMAP_BSAFEf_SET
#define SOFTWARE_BLOCKMAP_CMICf_GET BCM56504_A0_SOFTWARE_BLOCKMAP_CMICf_GET
#define SOFTWARE_BLOCKMAP_CMICf_SET BCM56504_A0_SOFTWARE_BLOCKMAP_CMICf_SET
#define SOFTWARE_BLOCKMAP_EPIPEf_GET BCM56504_A0_SOFTWARE_BLOCKMAP_EPIPEf_GET
#define SOFTWARE_BLOCKMAP_EPIPEf_SET BCM56504_A0_SOFTWARE_BLOCKMAP_EPIPEf_SET
#define SOFTWARE_BLOCKMAP_EPIPE_HIf_GET BCM56504_A0_SOFTWARE_BLOCKMAP_EPIPE_HIf_GET
#define SOFTWARE_BLOCKMAP_EPIPE_HIf_SET BCM56504_A0_SOFTWARE_BLOCKMAP_EPIPE_HIf_SET
#define SOFTWARE_BLOCKMAP_GPORTf_GET BCM56504_A0_SOFTWARE_BLOCKMAP_GPORTf_GET
#define SOFTWARE_BLOCKMAP_GPORTf_SET BCM56504_A0_SOFTWARE_BLOCKMAP_GPORTf_SET
#define SOFTWARE_BLOCKMAP_IPIPEf_GET BCM56504_A0_SOFTWARE_BLOCKMAP_IPIPEf_GET
#define SOFTWARE_BLOCKMAP_IPIPEf_SET BCM56504_A0_SOFTWARE_BLOCKMAP_IPIPEf_SET
#define SOFTWARE_BLOCKMAP_IPIPE_HIf_GET BCM56504_A0_SOFTWARE_BLOCKMAP_IPIPE_HIf_GET
#define SOFTWARE_BLOCKMAP_IPIPE_HIf_SET BCM56504_A0_SOFTWARE_BLOCKMAP_IPIPE_HIf_SET
#define SOFTWARE_BLOCKMAP_MMUf_GET BCM56504_A0_SOFTWARE_BLOCKMAP_MMUf_GET
#define SOFTWARE_BLOCKMAP_MMUf_SET BCM56504_A0_SOFTWARE_BLOCKMAP_MMUf_SET
#define SOFTWARE_BLOCKMAP_XPORTf_GET BCM56504_A0_SOFTWARE_BLOCKMAP_XPORTf_GET
#define SOFTWARE_BLOCKMAP_XPORTf_SET BCM56504_A0_SOFTWARE_BLOCKMAP_XPORTf_SET
#define READ_SOFTWARE_BLOCKMAP BCM56504_A0_READ_SOFTWARE_BLOCKMAP
#define WRITE_SOFTWARE_BLOCKMAP BCM56504_A0_WRITE_SOFTWARE_BLOCKMAP

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_SOFTWARE_BLOCKMAP'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  SOURCE_TRUNK_MAP_TABLE
 * BLOCKS:   IPIPE
 * DESC:     Source Trunk Map Table
 * SIZE:     9
 * FIELDS:
 *     PORT_TYPE        Indicates source port type
 *     TGID             Source port TGID
 *
 ******************************************************************************/
#define BCM56504_A0_SOURCE_TRUNK_MAP_TABLEm 0x02710000

#define BCM56504_A0_SOURCE_TRUNK_MAP_TABLEm_MIN 0
#define BCM56504_A0_SOURCE_TRUNK_MAP_TABLEm_MAX 2047
#define BCM56504_A0_SOURCE_TRUNK_MAP_TABLEm_CMAX(u) 2047
#define BCM56504_A0_SOURCE_TRUNK_MAP_TABLEm_SIZE 2

/*
 * This structure should be used to declare and program SOURCE_TRUNK_MAP_TABLE.
 *
 */
typedef union BCM56504_A0_SOURCE_TRUNK_MAP_TABLEm_s {
	uint32_t v[1];
	uint32_t source_trunk_map_table[1];
	uint32_t _source_trunk_map_table;
} BCM56504_A0_SOURCE_TRUNK_MAP_TABLEm_t;

#define BCM56504_A0_SOURCE_TRUNK_MAP_TABLEm_CLR(r) (r).source_trunk_map_table[0] = 0
#define BCM56504_A0_SOURCE_TRUNK_MAP_TABLEm_SET(r,d) (r).source_trunk_map_table[0] = d
#define BCM56504_A0_SOURCE_TRUNK_MAP_TABLEm_GET(r) (r).source_trunk_map_table[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_SOURCE_TRUNK_MAP_TABLEm_PORT_TYPEf_GET(r) (((r).source_trunk_map_table[0]) & 0x3)
#define BCM56504_A0_SOURCE_TRUNK_MAP_TABLEm_PORT_TYPEf_SET(r,f) (r).source_trunk_map_table[0]=(((r).source_trunk_map_table[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56504_A0_SOURCE_TRUNK_MAP_TABLEm_TGIDf_GET(r) ((((r).source_trunk_map_table[0]) >> 2) & 0x7f)
#define BCM56504_A0_SOURCE_TRUNK_MAP_TABLEm_TGIDf_SET(r,f) (r).source_trunk_map_table[0]=(((r).source_trunk_map_table[0] & ~((uint32_t)0x7f << 2)) | ((((uint32_t)f) & 0x7f) << 2))

/*
 * These macros can be used to access SOURCE_TRUNK_MAP_TABLE.
 *
 */
#define BCM56504_A0_READ_SOURCE_TRUNK_MAP_TABLEm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_SOURCE_TRUNK_MAP_TABLEm,i,(m._source_trunk_map_table),1)
#define BCM56504_A0_WRITE_SOURCE_TRUNK_MAP_TABLEm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_SOURCE_TRUNK_MAP_TABLEm,i,&(m._source_trunk_map_table),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SOURCE_TRUNK_MAP_TABLEm BCM56504_A0_SOURCE_TRUNK_MAP_TABLEm
#define SOURCE_TRUNK_MAP_TABLEm_MIN BCM56504_A0_SOURCE_TRUNK_MAP_TABLEm_MIN
#define SOURCE_TRUNK_MAP_TABLEm_MAX BCM56504_A0_SOURCE_TRUNK_MAP_TABLEm_MAX
#define SOURCE_TRUNK_MAP_TABLEm_CMAX(u) BCM56504_A0_SOURCE_TRUNK_MAP_TABLEm_CMAX(u)
#define SOURCE_TRUNK_MAP_TABLEm_SIZE BCM56504_A0_SOURCE_TRUNK_MAP_TABLEm_SIZE
typedef BCM56504_A0_SOURCE_TRUNK_MAP_TABLEm_t SOURCE_TRUNK_MAP_TABLEm_t;
#define SOURCE_TRUNK_MAP_TABLEm_CLR BCM56504_A0_SOURCE_TRUNK_MAP_TABLEm_CLR
#define SOURCE_TRUNK_MAP_TABLEm_SET BCM56504_A0_SOURCE_TRUNK_MAP_TABLEm_SET
#define SOURCE_TRUNK_MAP_TABLEm_GET BCM56504_A0_SOURCE_TRUNK_MAP_TABLEm_GET
#define SOURCE_TRUNK_MAP_TABLEm_PORT_TYPEf_GET BCM56504_A0_SOURCE_TRUNK_MAP_TABLEm_PORT_TYPEf_GET
#define SOURCE_TRUNK_MAP_TABLEm_PORT_TYPEf_SET BCM56504_A0_SOURCE_TRUNK_MAP_TABLEm_PORT_TYPEf_SET
#define SOURCE_TRUNK_MAP_TABLEm_TGIDf_GET BCM56504_A0_SOURCE_TRUNK_MAP_TABLEm_TGIDf_GET
#define SOURCE_TRUNK_MAP_TABLEm_TGIDf_SET BCM56504_A0_SOURCE_TRUNK_MAP_TABLEm_TGIDf_SET
#define READ_SOURCE_TRUNK_MAP_TABLEm BCM56504_A0_READ_SOURCE_TRUNK_MAP_TABLEm
#define WRITE_SOURCE_TRUNK_MAP_TABLEm BCM56504_A0_WRITE_SOURCE_TRUNK_MAP_TABLEm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_SOURCE_TRUNK_MAP_TABLEm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  STG_TAB
 * BLOCKS:   IPIPE
 * DESC:     Spanning Tree Group state table
 * SIZE:     56
 * FIELDS:
 *     SP_TREE_PORT0    Spanning Tree State for port 0
 *     SP_TREE_PORT1    Spanning Tree State for port 1
 *     SP_TREE_PORT2    Spanning Tree State for port 2
 *     SP_TREE_PORT3    Spanning Tree State for port 3
 *     SP_TREE_PORT4    Spanning Tree State for port 4
 *     SP_TREE_PORT5    Spanning Tree State for port 5
 *     SP_TREE_PORT6    Spanning Tree State for port 6
 *     SP_TREE_PORT7    Spanning Tree State for port 7
 *     SP_TREE_PORT8    Spanning Tree State for port 8
 *     SP_TREE_PORT9    Spanning Tree State for port 9
 *     SP_TREE_PORT10   Spanning Tree State for port 10
 *     SP_TREE_PORT11   Spanning Tree State for port 11
 *     SP_TREE_PORT12   Spanning Tree State for port 12
 *     SP_TREE_PORT13   Spanning Tree State for port 13
 *     SP_TREE_PORT14   Spanning Tree State for port 14
 *     SP_TREE_PORT15   Spanning Tree State for port 15
 *     SP_TREE_PORT16   Spanning Tree State for port 16
 *     SP_TREE_PORT17   Spanning Tree State for port 17
 *     SP_TREE_PORT18   Spanning Tree State for port 18
 *     SP_TREE_PORT19   Spanning Tree State for port 19
 *     SP_TREE_PORT20   Spanning Tree State for port 20
 *     SP_TREE_PORT21   Spanning Tree State for port 21
 *     SP_TREE_PORT22   Spanning Tree State for port 22
 *     SP_TREE_PORT23   Spanning Tree State for port 23
 *     SP_TREE_PORT24   Spanning Tree State for port 24
 *     SP_TREE_PORT25   Spanning Tree State for port 25
 *     SP_TREE_PORT26   Spanning Tree State for port 26
 *     SP_TREE_PORT27   Spanning Tree State for port 27
 *
 ******************************************************************************/
#define BCM56504_A0_STG_TABm 0x05710000

#define BCM56504_A0_STG_TABm_MIN 0
#define BCM56504_A0_STG_TABm_MAX 255
#define BCM56504_A0_STG_TABm_CMAX(u) 255
#define BCM56504_A0_STG_TABm_SIZE 7

/*
 * This structure should be used to declare and program STG_TAB.
 *
 */
typedef union BCM56504_A0_STG_TABm_s {
	uint32_t v[2];
	uint32_t stg_tab[2];
	uint32_t _stg_tab;
} BCM56504_A0_STG_TABm_t;

#define BCM56504_A0_STG_TABm_CLR(r) CDK_MEMSET(&((r)._stg_tab), 0, sizeof(BCM56504_A0_STG_TABm_t))
#define BCM56504_A0_STG_TABm_SET(r,i,d) (r).stg_tab[i] = d
#define BCM56504_A0_STG_TABm_GET(r,i) (r).stg_tab[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_STG_TABm_SP_TREE_PORT0f_GET(r) (((r).stg_tab[0]) & 0x3)
#define BCM56504_A0_STG_TABm_SP_TREE_PORT0f_SET(r,f) (r).stg_tab[0]=(((r).stg_tab[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56504_A0_STG_TABm_SP_TREE_PORT1f_GET(r) ((((r).stg_tab[0]) >> 2) & 0x3)
#define BCM56504_A0_STG_TABm_SP_TREE_PORT1f_SET(r,f) (r).stg_tab[0]=(((r).stg_tab[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM56504_A0_STG_TABm_SP_TREE_PORT2f_GET(r) ((((r).stg_tab[0]) >> 4) & 0x3)
#define BCM56504_A0_STG_TABm_SP_TREE_PORT2f_SET(r,f) (r).stg_tab[0]=(((r).stg_tab[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM56504_A0_STG_TABm_SP_TREE_PORT3f_GET(r) ((((r).stg_tab[0]) >> 6) & 0x3)
#define BCM56504_A0_STG_TABm_SP_TREE_PORT3f_SET(r,f) (r).stg_tab[0]=(((r).stg_tab[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM56504_A0_STG_TABm_SP_TREE_PORT4f_GET(r) ((((r).stg_tab[0]) >> 8) & 0x3)
#define BCM56504_A0_STG_TABm_SP_TREE_PORT4f_SET(r,f) (r).stg_tab[0]=(((r).stg_tab[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM56504_A0_STG_TABm_SP_TREE_PORT5f_GET(r) ((((r).stg_tab[0]) >> 10) & 0x3)
#define BCM56504_A0_STG_TABm_SP_TREE_PORT5f_SET(r,f) (r).stg_tab[0]=(((r).stg_tab[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCM56504_A0_STG_TABm_SP_TREE_PORT6f_GET(r) ((((r).stg_tab[0]) >> 12) & 0x3)
#define BCM56504_A0_STG_TABm_SP_TREE_PORT6f_SET(r,f) (r).stg_tab[0]=(((r).stg_tab[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM56504_A0_STG_TABm_SP_TREE_PORT7f_GET(r) ((((r).stg_tab[0]) >> 14) & 0x3)
#define BCM56504_A0_STG_TABm_SP_TREE_PORT7f_SET(r,f) (r).stg_tab[0]=(((r).stg_tab[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCM56504_A0_STG_TABm_SP_TREE_PORT8f_GET(r) ((((r).stg_tab[0]) >> 16) & 0x3)
#define BCM56504_A0_STG_TABm_SP_TREE_PORT8f_SET(r,f) (r).stg_tab[0]=(((r).stg_tab[0] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM56504_A0_STG_TABm_SP_TREE_PORT9f_GET(r) ((((r).stg_tab[0]) >> 18) & 0x3)
#define BCM56504_A0_STG_TABm_SP_TREE_PORT9f_SET(r,f) (r).stg_tab[0]=(((r).stg_tab[0] & ~((uint32_t)0x3 << 18)) | ((((uint32_t)f) & 0x3) << 18))
#define BCM56504_A0_STG_TABm_SP_TREE_PORT10f_GET(r) ((((r).stg_tab[0]) >> 20) & 0x3)
#define BCM56504_A0_STG_TABm_SP_TREE_PORT10f_SET(r,f) (r).stg_tab[0]=(((r).stg_tab[0] & ~((uint32_t)0x3 << 20)) | ((((uint32_t)f) & 0x3) << 20))
#define BCM56504_A0_STG_TABm_SP_TREE_PORT11f_GET(r) ((((r).stg_tab[0]) >> 22) & 0x3)
#define BCM56504_A0_STG_TABm_SP_TREE_PORT11f_SET(r,f) (r).stg_tab[0]=(((r).stg_tab[0] & ~((uint32_t)0x3 << 22)) | ((((uint32_t)f) & 0x3) << 22))
#define BCM56504_A0_STG_TABm_SP_TREE_PORT12f_GET(r) ((((r).stg_tab[0]) >> 24) & 0x3)
#define BCM56504_A0_STG_TABm_SP_TREE_PORT12f_SET(r,f) (r).stg_tab[0]=(((r).stg_tab[0] & ~((uint32_t)0x3 << 24)) | ((((uint32_t)f) & 0x3) << 24))
#define BCM56504_A0_STG_TABm_SP_TREE_PORT13f_GET(r) ((((r).stg_tab[0]) >> 26) & 0x3)
#define BCM56504_A0_STG_TABm_SP_TREE_PORT13f_SET(r,f) (r).stg_tab[0]=(((r).stg_tab[0] & ~((uint32_t)0x3 << 26)) | ((((uint32_t)f) & 0x3) << 26))
#define BCM56504_A0_STG_TABm_SP_TREE_PORT14f_GET(r) ((((r).stg_tab[0]) >> 28) & 0x3)
#define BCM56504_A0_STG_TABm_SP_TREE_PORT14f_SET(r,f) (r).stg_tab[0]=(((r).stg_tab[0] & ~((uint32_t)0x3 << 28)) | ((((uint32_t)f) & 0x3) << 28))
#define BCM56504_A0_STG_TABm_SP_TREE_PORT15f_GET(r) ((((r).stg_tab[0]) >> 30) & 0x3)
#define BCM56504_A0_STG_TABm_SP_TREE_PORT15f_SET(r,f) (r).stg_tab[0]=(((r).stg_tab[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))
#define BCM56504_A0_STG_TABm_SP_TREE_PORT16f_GET(r) (((r).stg_tab[1]) & 0x3)
#define BCM56504_A0_STG_TABm_SP_TREE_PORT16f_SET(r,f) (r).stg_tab[1]=(((r).stg_tab[1] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56504_A0_STG_TABm_SP_TREE_PORT17f_GET(r) ((((r).stg_tab[1]) >> 2) & 0x3)
#define BCM56504_A0_STG_TABm_SP_TREE_PORT17f_SET(r,f) (r).stg_tab[1]=(((r).stg_tab[1] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM56504_A0_STG_TABm_SP_TREE_PORT18f_GET(r) ((((r).stg_tab[1]) >> 4) & 0x3)
#define BCM56504_A0_STG_TABm_SP_TREE_PORT18f_SET(r,f) (r).stg_tab[1]=(((r).stg_tab[1] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM56504_A0_STG_TABm_SP_TREE_PORT19f_GET(r) ((((r).stg_tab[1]) >> 6) & 0x3)
#define BCM56504_A0_STG_TABm_SP_TREE_PORT19f_SET(r,f) (r).stg_tab[1]=(((r).stg_tab[1] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM56504_A0_STG_TABm_SP_TREE_PORT20f_GET(r) ((((r).stg_tab[1]) >> 8) & 0x3)
#define BCM56504_A0_STG_TABm_SP_TREE_PORT20f_SET(r,f) (r).stg_tab[1]=(((r).stg_tab[1] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM56504_A0_STG_TABm_SP_TREE_PORT21f_GET(r) ((((r).stg_tab[1]) >> 10) & 0x3)
#define BCM56504_A0_STG_TABm_SP_TREE_PORT21f_SET(r,f) (r).stg_tab[1]=(((r).stg_tab[1] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCM56504_A0_STG_TABm_SP_TREE_PORT22f_GET(r) ((((r).stg_tab[1]) >> 12) & 0x3)
#define BCM56504_A0_STG_TABm_SP_TREE_PORT22f_SET(r,f) (r).stg_tab[1]=(((r).stg_tab[1] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM56504_A0_STG_TABm_SP_TREE_PORT23f_GET(r) ((((r).stg_tab[1]) >> 14) & 0x3)
#define BCM56504_A0_STG_TABm_SP_TREE_PORT23f_SET(r,f) (r).stg_tab[1]=(((r).stg_tab[1] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCM56504_A0_STG_TABm_SP_TREE_PORT24f_GET(r) ((((r).stg_tab[1]) >> 16) & 0x3)
#define BCM56504_A0_STG_TABm_SP_TREE_PORT24f_SET(r,f) (r).stg_tab[1]=(((r).stg_tab[1] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM56504_A0_STG_TABm_SP_TREE_PORT25f_GET(r) ((((r).stg_tab[1]) >> 18) & 0x3)
#define BCM56504_A0_STG_TABm_SP_TREE_PORT25f_SET(r,f) (r).stg_tab[1]=(((r).stg_tab[1] & ~((uint32_t)0x3 << 18)) | ((((uint32_t)f) & 0x3) << 18))
#define BCM56504_A0_STG_TABm_SP_TREE_PORT26f_GET(r) ((((r).stg_tab[1]) >> 20) & 0x3)
#define BCM56504_A0_STG_TABm_SP_TREE_PORT26f_SET(r,f) (r).stg_tab[1]=(((r).stg_tab[1] & ~((uint32_t)0x3 << 20)) | ((((uint32_t)f) & 0x3) << 20))
#define BCM56504_A0_STG_TABm_SP_TREE_PORT27f_GET(r) ((((r).stg_tab[1]) >> 22) & 0x3)
#define BCM56504_A0_STG_TABm_SP_TREE_PORT27f_SET(r,f) (r).stg_tab[1]=(((r).stg_tab[1] & ~((uint32_t)0x3 << 22)) | ((((uint32_t)f) & 0x3) << 22))

/*
 * These macros can be used to access STG_TAB.
 *
 */
#define BCM56504_A0_READ_STG_TABm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_STG_TABm,i,(m._stg_tab),2)
#define BCM56504_A0_WRITE_STG_TABm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_STG_TABm,i,&(m._stg_tab),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define STG_TABm BCM56504_A0_STG_TABm
#define STG_TABm_MIN BCM56504_A0_STG_TABm_MIN
#define STG_TABm_MAX BCM56504_A0_STG_TABm_MAX
#define STG_TABm_CMAX(u) BCM56504_A0_STG_TABm_CMAX(u)
#define STG_TABm_SIZE BCM56504_A0_STG_TABm_SIZE
typedef BCM56504_A0_STG_TABm_t STG_TABm_t;
#define STG_TABm_CLR BCM56504_A0_STG_TABm_CLR
#define STG_TABm_SET BCM56504_A0_STG_TABm_SET
#define STG_TABm_GET BCM56504_A0_STG_TABm_GET
#define STG_TABm_SP_TREE_PORT0f_GET BCM56504_A0_STG_TABm_SP_TREE_PORT0f_GET
#define STG_TABm_SP_TREE_PORT0f_SET BCM56504_A0_STG_TABm_SP_TREE_PORT0f_SET
#define STG_TABm_SP_TREE_PORT1f_GET BCM56504_A0_STG_TABm_SP_TREE_PORT1f_GET
#define STG_TABm_SP_TREE_PORT1f_SET BCM56504_A0_STG_TABm_SP_TREE_PORT1f_SET
#define STG_TABm_SP_TREE_PORT2f_GET BCM56504_A0_STG_TABm_SP_TREE_PORT2f_GET
#define STG_TABm_SP_TREE_PORT2f_SET BCM56504_A0_STG_TABm_SP_TREE_PORT2f_SET
#define STG_TABm_SP_TREE_PORT3f_GET BCM56504_A0_STG_TABm_SP_TREE_PORT3f_GET
#define STG_TABm_SP_TREE_PORT3f_SET BCM56504_A0_STG_TABm_SP_TREE_PORT3f_SET
#define STG_TABm_SP_TREE_PORT4f_GET BCM56504_A0_STG_TABm_SP_TREE_PORT4f_GET
#define STG_TABm_SP_TREE_PORT4f_SET BCM56504_A0_STG_TABm_SP_TREE_PORT4f_SET
#define STG_TABm_SP_TREE_PORT5f_GET BCM56504_A0_STG_TABm_SP_TREE_PORT5f_GET
#define STG_TABm_SP_TREE_PORT5f_SET BCM56504_A0_STG_TABm_SP_TREE_PORT5f_SET
#define STG_TABm_SP_TREE_PORT6f_GET BCM56504_A0_STG_TABm_SP_TREE_PORT6f_GET
#define STG_TABm_SP_TREE_PORT6f_SET BCM56504_A0_STG_TABm_SP_TREE_PORT6f_SET
#define STG_TABm_SP_TREE_PORT7f_GET BCM56504_A0_STG_TABm_SP_TREE_PORT7f_GET
#define STG_TABm_SP_TREE_PORT7f_SET BCM56504_A0_STG_TABm_SP_TREE_PORT7f_SET
#define STG_TABm_SP_TREE_PORT8f_GET BCM56504_A0_STG_TABm_SP_TREE_PORT8f_GET
#define STG_TABm_SP_TREE_PORT8f_SET BCM56504_A0_STG_TABm_SP_TREE_PORT8f_SET
#define STG_TABm_SP_TREE_PORT9f_GET BCM56504_A0_STG_TABm_SP_TREE_PORT9f_GET
#define STG_TABm_SP_TREE_PORT9f_SET BCM56504_A0_STG_TABm_SP_TREE_PORT9f_SET
#define STG_TABm_SP_TREE_PORT10f_GET BCM56504_A0_STG_TABm_SP_TREE_PORT10f_GET
#define STG_TABm_SP_TREE_PORT10f_SET BCM56504_A0_STG_TABm_SP_TREE_PORT10f_SET
#define STG_TABm_SP_TREE_PORT11f_GET BCM56504_A0_STG_TABm_SP_TREE_PORT11f_GET
#define STG_TABm_SP_TREE_PORT11f_SET BCM56504_A0_STG_TABm_SP_TREE_PORT11f_SET
#define STG_TABm_SP_TREE_PORT12f_GET BCM56504_A0_STG_TABm_SP_TREE_PORT12f_GET
#define STG_TABm_SP_TREE_PORT12f_SET BCM56504_A0_STG_TABm_SP_TREE_PORT12f_SET
#define STG_TABm_SP_TREE_PORT13f_GET BCM56504_A0_STG_TABm_SP_TREE_PORT13f_GET
#define STG_TABm_SP_TREE_PORT13f_SET BCM56504_A0_STG_TABm_SP_TREE_PORT13f_SET
#define STG_TABm_SP_TREE_PORT14f_GET BCM56504_A0_STG_TABm_SP_TREE_PORT14f_GET
#define STG_TABm_SP_TREE_PORT14f_SET BCM56504_A0_STG_TABm_SP_TREE_PORT14f_SET
#define STG_TABm_SP_TREE_PORT15f_GET BCM56504_A0_STG_TABm_SP_TREE_PORT15f_GET
#define STG_TABm_SP_TREE_PORT15f_SET BCM56504_A0_STG_TABm_SP_TREE_PORT15f_SET
#define STG_TABm_SP_TREE_PORT16f_GET BCM56504_A0_STG_TABm_SP_TREE_PORT16f_GET
#define STG_TABm_SP_TREE_PORT16f_SET BCM56504_A0_STG_TABm_SP_TREE_PORT16f_SET
#define STG_TABm_SP_TREE_PORT17f_GET BCM56504_A0_STG_TABm_SP_TREE_PORT17f_GET
#define STG_TABm_SP_TREE_PORT17f_SET BCM56504_A0_STG_TABm_SP_TREE_PORT17f_SET
#define STG_TABm_SP_TREE_PORT18f_GET BCM56504_A0_STG_TABm_SP_TREE_PORT18f_GET
#define STG_TABm_SP_TREE_PORT18f_SET BCM56504_A0_STG_TABm_SP_TREE_PORT18f_SET
#define STG_TABm_SP_TREE_PORT19f_GET BCM56504_A0_STG_TABm_SP_TREE_PORT19f_GET
#define STG_TABm_SP_TREE_PORT19f_SET BCM56504_A0_STG_TABm_SP_TREE_PORT19f_SET
#define STG_TABm_SP_TREE_PORT20f_GET BCM56504_A0_STG_TABm_SP_TREE_PORT20f_GET
#define STG_TABm_SP_TREE_PORT20f_SET BCM56504_A0_STG_TABm_SP_TREE_PORT20f_SET
#define STG_TABm_SP_TREE_PORT21f_GET BCM56504_A0_STG_TABm_SP_TREE_PORT21f_GET
#define STG_TABm_SP_TREE_PORT21f_SET BCM56504_A0_STG_TABm_SP_TREE_PORT21f_SET
#define STG_TABm_SP_TREE_PORT22f_GET BCM56504_A0_STG_TABm_SP_TREE_PORT22f_GET
#define STG_TABm_SP_TREE_PORT22f_SET BCM56504_A0_STG_TABm_SP_TREE_PORT22f_SET
#define STG_TABm_SP_TREE_PORT23f_GET BCM56504_A0_STG_TABm_SP_TREE_PORT23f_GET
#define STG_TABm_SP_TREE_PORT23f_SET BCM56504_A0_STG_TABm_SP_TREE_PORT23f_SET
#define STG_TABm_SP_TREE_PORT24f_GET BCM56504_A0_STG_TABm_SP_TREE_PORT24f_GET
#define STG_TABm_SP_TREE_PORT24f_SET BCM56504_A0_STG_TABm_SP_TREE_PORT24f_SET
#define STG_TABm_SP_TREE_PORT25f_GET BCM56504_A0_STG_TABm_SP_TREE_PORT25f_GET
#define STG_TABm_SP_TREE_PORT25f_SET BCM56504_A0_STG_TABm_SP_TREE_PORT25f_SET
#define STG_TABm_SP_TREE_PORT26f_GET BCM56504_A0_STG_TABm_SP_TREE_PORT26f_GET
#define STG_TABm_SP_TREE_PORT26f_SET BCM56504_A0_STG_TABm_SP_TREE_PORT26f_SET
#define STG_TABm_SP_TREE_PORT27f_GET BCM56504_A0_STG_TABm_SP_TREE_PORT27f_GET
#define STG_TABm_SP_TREE_PORT27f_SET BCM56504_A0_STG_TABm_SP_TREE_PORT27f_SET
#define READ_STG_TABm BCM56504_A0_READ_STG_TABm
#define WRITE_STG_TABm BCM56504_A0_WRITE_STG_TABm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_STG_TABm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  TDBGC0
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #0
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_TDBGC0r 0x0a900000

#define BCM56504_A0_TDBGC0r_SIZE 4

/*
 * This structure should be used to declare and program TDBGC0.
 *
 */
typedef union BCM56504_A0_TDBGC0r_s {
	uint32_t v[1];
	uint32_t tdbgc0[1];
	uint32_t _tdbgc0;
} BCM56504_A0_TDBGC0r_t;

#define BCM56504_A0_TDBGC0r_CLR(r) (r).tdbgc0[0] = 0
#define BCM56504_A0_TDBGC0r_SET(r,d) (r).tdbgc0[0] = d
#define BCM56504_A0_TDBGC0r_GET(r) (r).tdbgc0[0]


/*
 * These macros can be used to access TDBGC0.
 *
 */
#define BCM56504_A0_READ_TDBGC0r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_TDBGC0r,(r._tdbgc0))
#define BCM56504_A0_WRITE_TDBGC0r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_TDBGC0r,&(r._tdbgc0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC0r BCM56504_A0_TDBGC0r
#define TDBGC0r_SIZE BCM56504_A0_TDBGC0r_SIZE
typedef BCM56504_A0_TDBGC0r_t TDBGC0r_t;
#define TDBGC0r_CLR BCM56504_A0_TDBGC0r_CLR
#define TDBGC0r_SET BCM56504_A0_TDBGC0r_SET
#define TDBGC0r_GET BCM56504_A0_TDBGC0r_GET
#define READ_TDBGC0r BCM56504_A0_READ_TDBGC0r
#define WRITE_TDBGC0r BCM56504_A0_WRITE_TDBGC0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_TDBGC0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  TDBGC0_SELECT
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #0 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The TDBGC0_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM56504_A0_TDBGC0_SELECTr 0x0a980020

#define BCM56504_A0_TDBGC0_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program TDBGC0_SELECT.
 *
 */
typedef union BCM56504_A0_TDBGC0_SELECTr_s {
	uint32_t v[1];
	uint32_t tdbgc0_select[1];
	uint32_t _tdbgc0_select;
} BCM56504_A0_TDBGC0_SELECTr_t;

#define BCM56504_A0_TDBGC0_SELECTr_CLR(r) (r).tdbgc0_select[0] = 0
#define BCM56504_A0_TDBGC0_SELECTr_SET(r,d) (r).tdbgc0_select[0] = d
#define BCM56504_A0_TDBGC0_SELECTr_GET(r) (r).tdbgc0_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_TDBGC0_SELECTr_BITMAPf_GET(r) (((r).tdbgc0_select[0]) & 0x1fffff)
#define BCM56504_A0_TDBGC0_SELECTr_BITMAPf_SET(r,f) (r).tdbgc0_select[0]=(((r).tdbgc0_select[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access TDBGC0_SELECT.
 *
 */
#define BCM56504_A0_READ_TDBGC0_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_TDBGC0_SELECTr,(r._tdbgc0_select))
#define BCM56504_A0_WRITE_TDBGC0_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_TDBGC0_SELECTr,&(r._tdbgc0_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC0_SELECTr BCM56504_A0_TDBGC0_SELECTr
#define TDBGC0_SELECTr_SIZE BCM56504_A0_TDBGC0_SELECTr_SIZE
typedef BCM56504_A0_TDBGC0_SELECTr_t TDBGC0_SELECTr_t;
#define TDBGC0_SELECTr_CLR BCM56504_A0_TDBGC0_SELECTr_CLR
#define TDBGC0_SELECTr_SET BCM56504_A0_TDBGC0_SELECTr_SET
#define TDBGC0_SELECTr_GET BCM56504_A0_TDBGC0_SELECTr_GET
#define TDBGC0_SELECTr_BITMAPf_GET BCM56504_A0_TDBGC0_SELECTr_BITMAPf_GET
#define TDBGC0_SELECTr_BITMAPf_SET BCM56504_A0_TDBGC0_SELECTr_BITMAPf_SET
#define READ_TDBGC0_SELECTr BCM56504_A0_READ_TDBGC0_SELECTr
#define WRITE_TDBGC0_SELECTr BCM56504_A0_WRITE_TDBGC0_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_TDBGC0_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  TDBGC1
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #1
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_TDBGC1r 0x0a900001

#define BCM56504_A0_TDBGC1r_SIZE 4

/*
 * This structure should be used to declare and program TDBGC1.
 *
 */
typedef union BCM56504_A0_TDBGC1r_s {
	uint32_t v[1];
	uint32_t tdbgc1[1];
	uint32_t _tdbgc1;
} BCM56504_A0_TDBGC1r_t;

#define BCM56504_A0_TDBGC1r_CLR(r) (r).tdbgc1[0] = 0
#define BCM56504_A0_TDBGC1r_SET(r,d) (r).tdbgc1[0] = d
#define BCM56504_A0_TDBGC1r_GET(r) (r).tdbgc1[0]


/*
 * These macros can be used to access TDBGC1.
 *
 */
#define BCM56504_A0_READ_TDBGC1r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_TDBGC1r,(r._tdbgc1))
#define BCM56504_A0_WRITE_TDBGC1r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_TDBGC1r,&(r._tdbgc1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC1r BCM56504_A0_TDBGC1r
#define TDBGC1r_SIZE BCM56504_A0_TDBGC1r_SIZE
typedef BCM56504_A0_TDBGC1r_t TDBGC1r_t;
#define TDBGC1r_CLR BCM56504_A0_TDBGC1r_CLR
#define TDBGC1r_SET BCM56504_A0_TDBGC1r_SET
#define TDBGC1r_GET BCM56504_A0_TDBGC1r_GET
#define READ_TDBGC1r BCM56504_A0_READ_TDBGC1r
#define WRITE_TDBGC1r BCM56504_A0_WRITE_TDBGC1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_TDBGC1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  TDBGC10
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #10
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_TDBGC10r 0x0a90000a

#define BCM56504_A0_TDBGC10r_SIZE 4

/*
 * This structure should be used to declare and program TDBGC10.
 *
 */
typedef union BCM56504_A0_TDBGC10r_s {
	uint32_t v[1];
	uint32_t tdbgc10[1];
	uint32_t _tdbgc10;
} BCM56504_A0_TDBGC10r_t;

#define BCM56504_A0_TDBGC10r_CLR(r) (r).tdbgc10[0] = 0
#define BCM56504_A0_TDBGC10r_SET(r,d) (r).tdbgc10[0] = d
#define BCM56504_A0_TDBGC10r_GET(r) (r).tdbgc10[0]


/*
 * These macros can be used to access TDBGC10.
 *
 */
#define BCM56504_A0_READ_TDBGC10r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_TDBGC10r,(r._tdbgc10))
#define BCM56504_A0_WRITE_TDBGC10r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_TDBGC10r,&(r._tdbgc10))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC10r BCM56504_A0_TDBGC10r
#define TDBGC10r_SIZE BCM56504_A0_TDBGC10r_SIZE
typedef BCM56504_A0_TDBGC10r_t TDBGC10r_t;
#define TDBGC10r_CLR BCM56504_A0_TDBGC10r_CLR
#define TDBGC10r_SET BCM56504_A0_TDBGC10r_SET
#define TDBGC10r_GET BCM56504_A0_TDBGC10r_GET
#define READ_TDBGC10r BCM56504_A0_READ_TDBGC10r
#define WRITE_TDBGC10r BCM56504_A0_WRITE_TDBGC10r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_TDBGC10r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  TDBGC10_SELECT
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #10 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The TDBGC10_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM56504_A0_TDBGC10_SELECTr 0x0a98002a

#define BCM56504_A0_TDBGC10_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program TDBGC10_SELECT.
 *
 */
typedef union BCM56504_A0_TDBGC10_SELECTr_s {
	uint32_t v[1];
	uint32_t tdbgc10_select[1];
	uint32_t _tdbgc10_select;
} BCM56504_A0_TDBGC10_SELECTr_t;

#define BCM56504_A0_TDBGC10_SELECTr_CLR(r) (r).tdbgc10_select[0] = 0
#define BCM56504_A0_TDBGC10_SELECTr_SET(r,d) (r).tdbgc10_select[0] = d
#define BCM56504_A0_TDBGC10_SELECTr_GET(r) (r).tdbgc10_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_TDBGC10_SELECTr_BITMAPf_GET(r) (((r).tdbgc10_select[0]) & 0x1fffff)
#define BCM56504_A0_TDBGC10_SELECTr_BITMAPf_SET(r,f) (r).tdbgc10_select[0]=(((r).tdbgc10_select[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access TDBGC10_SELECT.
 *
 */
#define BCM56504_A0_READ_TDBGC10_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_TDBGC10_SELECTr,(r._tdbgc10_select))
#define BCM56504_A0_WRITE_TDBGC10_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_TDBGC10_SELECTr,&(r._tdbgc10_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC10_SELECTr BCM56504_A0_TDBGC10_SELECTr
#define TDBGC10_SELECTr_SIZE BCM56504_A0_TDBGC10_SELECTr_SIZE
typedef BCM56504_A0_TDBGC10_SELECTr_t TDBGC10_SELECTr_t;
#define TDBGC10_SELECTr_CLR BCM56504_A0_TDBGC10_SELECTr_CLR
#define TDBGC10_SELECTr_SET BCM56504_A0_TDBGC10_SELECTr_SET
#define TDBGC10_SELECTr_GET BCM56504_A0_TDBGC10_SELECTr_GET
#define TDBGC10_SELECTr_BITMAPf_GET BCM56504_A0_TDBGC10_SELECTr_BITMAPf_GET
#define TDBGC10_SELECTr_BITMAPf_SET BCM56504_A0_TDBGC10_SELECTr_BITMAPf_SET
#define READ_TDBGC10_SELECTr BCM56504_A0_READ_TDBGC10_SELECTr
#define WRITE_TDBGC10_SELECTr BCM56504_A0_WRITE_TDBGC10_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_TDBGC10_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  TDBGC11
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #11
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_TDBGC11r 0x0a90000b

#define BCM56504_A0_TDBGC11r_SIZE 4

/*
 * This structure should be used to declare and program TDBGC11.
 *
 */
typedef union BCM56504_A0_TDBGC11r_s {
	uint32_t v[1];
	uint32_t tdbgc11[1];
	uint32_t _tdbgc11;
} BCM56504_A0_TDBGC11r_t;

#define BCM56504_A0_TDBGC11r_CLR(r) (r).tdbgc11[0] = 0
#define BCM56504_A0_TDBGC11r_SET(r,d) (r).tdbgc11[0] = d
#define BCM56504_A0_TDBGC11r_GET(r) (r).tdbgc11[0]


/*
 * These macros can be used to access TDBGC11.
 *
 */
#define BCM56504_A0_READ_TDBGC11r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_TDBGC11r,(r._tdbgc11))
#define BCM56504_A0_WRITE_TDBGC11r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_TDBGC11r,&(r._tdbgc11))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC11r BCM56504_A0_TDBGC11r
#define TDBGC11r_SIZE BCM56504_A0_TDBGC11r_SIZE
typedef BCM56504_A0_TDBGC11r_t TDBGC11r_t;
#define TDBGC11r_CLR BCM56504_A0_TDBGC11r_CLR
#define TDBGC11r_SET BCM56504_A0_TDBGC11r_SET
#define TDBGC11r_GET BCM56504_A0_TDBGC11r_GET
#define READ_TDBGC11r BCM56504_A0_READ_TDBGC11r
#define WRITE_TDBGC11r BCM56504_A0_WRITE_TDBGC11r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_TDBGC11r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  TDBGC11_SELECT
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #11 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The TDBGC11_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM56504_A0_TDBGC11_SELECTr 0x0a98002b

#define BCM56504_A0_TDBGC11_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program TDBGC11_SELECT.
 *
 */
typedef union BCM56504_A0_TDBGC11_SELECTr_s {
	uint32_t v[1];
	uint32_t tdbgc11_select[1];
	uint32_t _tdbgc11_select;
} BCM56504_A0_TDBGC11_SELECTr_t;

#define BCM56504_A0_TDBGC11_SELECTr_CLR(r) (r).tdbgc11_select[0] = 0
#define BCM56504_A0_TDBGC11_SELECTr_SET(r,d) (r).tdbgc11_select[0] = d
#define BCM56504_A0_TDBGC11_SELECTr_GET(r) (r).tdbgc11_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_TDBGC11_SELECTr_BITMAPf_GET(r) (((r).tdbgc11_select[0]) & 0x1fffff)
#define BCM56504_A0_TDBGC11_SELECTr_BITMAPf_SET(r,f) (r).tdbgc11_select[0]=(((r).tdbgc11_select[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access TDBGC11_SELECT.
 *
 */
#define BCM56504_A0_READ_TDBGC11_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_TDBGC11_SELECTr,(r._tdbgc11_select))
#define BCM56504_A0_WRITE_TDBGC11_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_TDBGC11_SELECTr,&(r._tdbgc11_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC11_SELECTr BCM56504_A0_TDBGC11_SELECTr
#define TDBGC11_SELECTr_SIZE BCM56504_A0_TDBGC11_SELECTr_SIZE
typedef BCM56504_A0_TDBGC11_SELECTr_t TDBGC11_SELECTr_t;
#define TDBGC11_SELECTr_CLR BCM56504_A0_TDBGC11_SELECTr_CLR
#define TDBGC11_SELECTr_SET BCM56504_A0_TDBGC11_SELECTr_SET
#define TDBGC11_SELECTr_GET BCM56504_A0_TDBGC11_SELECTr_GET
#define TDBGC11_SELECTr_BITMAPf_GET BCM56504_A0_TDBGC11_SELECTr_BITMAPf_GET
#define TDBGC11_SELECTr_BITMAPf_SET BCM56504_A0_TDBGC11_SELECTr_BITMAPf_SET
#define READ_TDBGC11_SELECTr BCM56504_A0_READ_TDBGC11_SELECTr
#define WRITE_TDBGC11_SELECTr BCM56504_A0_WRITE_TDBGC11_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_TDBGC11_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  TDBGC1_SELECT
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #1 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The TDBGC1_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM56504_A0_TDBGC1_SELECTr 0x0a980021

#define BCM56504_A0_TDBGC1_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program TDBGC1_SELECT.
 *
 */
typedef union BCM56504_A0_TDBGC1_SELECTr_s {
	uint32_t v[1];
	uint32_t tdbgc1_select[1];
	uint32_t _tdbgc1_select;
} BCM56504_A0_TDBGC1_SELECTr_t;

#define BCM56504_A0_TDBGC1_SELECTr_CLR(r) (r).tdbgc1_select[0] = 0
#define BCM56504_A0_TDBGC1_SELECTr_SET(r,d) (r).tdbgc1_select[0] = d
#define BCM56504_A0_TDBGC1_SELECTr_GET(r) (r).tdbgc1_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_TDBGC1_SELECTr_BITMAPf_GET(r) (((r).tdbgc1_select[0]) & 0x1fffff)
#define BCM56504_A0_TDBGC1_SELECTr_BITMAPf_SET(r,f) (r).tdbgc1_select[0]=(((r).tdbgc1_select[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access TDBGC1_SELECT.
 *
 */
#define BCM56504_A0_READ_TDBGC1_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_TDBGC1_SELECTr,(r._tdbgc1_select))
#define BCM56504_A0_WRITE_TDBGC1_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_TDBGC1_SELECTr,&(r._tdbgc1_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC1_SELECTr BCM56504_A0_TDBGC1_SELECTr
#define TDBGC1_SELECTr_SIZE BCM56504_A0_TDBGC1_SELECTr_SIZE
typedef BCM56504_A0_TDBGC1_SELECTr_t TDBGC1_SELECTr_t;
#define TDBGC1_SELECTr_CLR BCM56504_A0_TDBGC1_SELECTr_CLR
#define TDBGC1_SELECTr_SET BCM56504_A0_TDBGC1_SELECTr_SET
#define TDBGC1_SELECTr_GET BCM56504_A0_TDBGC1_SELECTr_GET
#define TDBGC1_SELECTr_BITMAPf_GET BCM56504_A0_TDBGC1_SELECTr_BITMAPf_GET
#define TDBGC1_SELECTr_BITMAPf_SET BCM56504_A0_TDBGC1_SELECTr_BITMAPf_SET
#define READ_TDBGC1_SELECTr BCM56504_A0_READ_TDBGC1_SELECTr
#define WRITE_TDBGC1_SELECTr BCM56504_A0_WRITE_TDBGC1_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_TDBGC1_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  TDBGC2
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #2
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_TDBGC2r 0x0a900002

#define BCM56504_A0_TDBGC2r_SIZE 4

/*
 * This structure should be used to declare and program TDBGC2.
 *
 */
typedef union BCM56504_A0_TDBGC2r_s {
	uint32_t v[1];
	uint32_t tdbgc2[1];
	uint32_t _tdbgc2;
} BCM56504_A0_TDBGC2r_t;

#define BCM56504_A0_TDBGC2r_CLR(r) (r).tdbgc2[0] = 0
#define BCM56504_A0_TDBGC2r_SET(r,d) (r).tdbgc2[0] = d
#define BCM56504_A0_TDBGC2r_GET(r) (r).tdbgc2[0]


/*
 * These macros can be used to access TDBGC2.
 *
 */
#define BCM56504_A0_READ_TDBGC2r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_TDBGC2r,(r._tdbgc2))
#define BCM56504_A0_WRITE_TDBGC2r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_TDBGC2r,&(r._tdbgc2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC2r BCM56504_A0_TDBGC2r
#define TDBGC2r_SIZE BCM56504_A0_TDBGC2r_SIZE
typedef BCM56504_A0_TDBGC2r_t TDBGC2r_t;
#define TDBGC2r_CLR BCM56504_A0_TDBGC2r_CLR
#define TDBGC2r_SET BCM56504_A0_TDBGC2r_SET
#define TDBGC2r_GET BCM56504_A0_TDBGC2r_GET
#define READ_TDBGC2r BCM56504_A0_READ_TDBGC2r
#define WRITE_TDBGC2r BCM56504_A0_WRITE_TDBGC2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_TDBGC2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  TDBGC2_SELECT
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #2 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The TDBGC2_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM56504_A0_TDBGC2_SELECTr 0x0a980022

#define BCM56504_A0_TDBGC2_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program TDBGC2_SELECT.
 *
 */
typedef union BCM56504_A0_TDBGC2_SELECTr_s {
	uint32_t v[1];
	uint32_t tdbgc2_select[1];
	uint32_t _tdbgc2_select;
} BCM56504_A0_TDBGC2_SELECTr_t;

#define BCM56504_A0_TDBGC2_SELECTr_CLR(r) (r).tdbgc2_select[0] = 0
#define BCM56504_A0_TDBGC2_SELECTr_SET(r,d) (r).tdbgc2_select[0] = d
#define BCM56504_A0_TDBGC2_SELECTr_GET(r) (r).tdbgc2_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_TDBGC2_SELECTr_BITMAPf_GET(r) (((r).tdbgc2_select[0]) & 0x1fffff)
#define BCM56504_A0_TDBGC2_SELECTr_BITMAPf_SET(r,f) (r).tdbgc2_select[0]=(((r).tdbgc2_select[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access TDBGC2_SELECT.
 *
 */
#define BCM56504_A0_READ_TDBGC2_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_TDBGC2_SELECTr,(r._tdbgc2_select))
#define BCM56504_A0_WRITE_TDBGC2_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_TDBGC2_SELECTr,&(r._tdbgc2_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC2_SELECTr BCM56504_A0_TDBGC2_SELECTr
#define TDBGC2_SELECTr_SIZE BCM56504_A0_TDBGC2_SELECTr_SIZE
typedef BCM56504_A0_TDBGC2_SELECTr_t TDBGC2_SELECTr_t;
#define TDBGC2_SELECTr_CLR BCM56504_A0_TDBGC2_SELECTr_CLR
#define TDBGC2_SELECTr_SET BCM56504_A0_TDBGC2_SELECTr_SET
#define TDBGC2_SELECTr_GET BCM56504_A0_TDBGC2_SELECTr_GET
#define TDBGC2_SELECTr_BITMAPf_GET BCM56504_A0_TDBGC2_SELECTr_BITMAPf_GET
#define TDBGC2_SELECTr_BITMAPf_SET BCM56504_A0_TDBGC2_SELECTr_BITMAPf_SET
#define READ_TDBGC2_SELECTr BCM56504_A0_READ_TDBGC2_SELECTr
#define WRITE_TDBGC2_SELECTr BCM56504_A0_WRITE_TDBGC2_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_TDBGC2_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  TDBGC3
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #3
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_TDBGC3r 0x0a900003

#define BCM56504_A0_TDBGC3r_SIZE 4

/*
 * This structure should be used to declare and program TDBGC3.
 *
 */
typedef union BCM56504_A0_TDBGC3r_s {
	uint32_t v[1];
	uint32_t tdbgc3[1];
	uint32_t _tdbgc3;
} BCM56504_A0_TDBGC3r_t;

#define BCM56504_A0_TDBGC3r_CLR(r) (r).tdbgc3[0] = 0
#define BCM56504_A0_TDBGC3r_SET(r,d) (r).tdbgc3[0] = d
#define BCM56504_A0_TDBGC3r_GET(r) (r).tdbgc3[0]


/*
 * These macros can be used to access TDBGC3.
 *
 */
#define BCM56504_A0_READ_TDBGC3r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_TDBGC3r,(r._tdbgc3))
#define BCM56504_A0_WRITE_TDBGC3r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_TDBGC3r,&(r._tdbgc3))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC3r BCM56504_A0_TDBGC3r
#define TDBGC3r_SIZE BCM56504_A0_TDBGC3r_SIZE
typedef BCM56504_A0_TDBGC3r_t TDBGC3r_t;
#define TDBGC3r_CLR BCM56504_A0_TDBGC3r_CLR
#define TDBGC3r_SET BCM56504_A0_TDBGC3r_SET
#define TDBGC3r_GET BCM56504_A0_TDBGC3r_GET
#define READ_TDBGC3r BCM56504_A0_READ_TDBGC3r
#define WRITE_TDBGC3r BCM56504_A0_WRITE_TDBGC3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_TDBGC3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  TDBGC3_SELECT
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #3 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The TDBGC3_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM56504_A0_TDBGC3_SELECTr 0x0a980023

#define BCM56504_A0_TDBGC3_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program TDBGC3_SELECT.
 *
 */
typedef union BCM56504_A0_TDBGC3_SELECTr_s {
	uint32_t v[1];
	uint32_t tdbgc3_select[1];
	uint32_t _tdbgc3_select;
} BCM56504_A0_TDBGC3_SELECTr_t;

#define BCM56504_A0_TDBGC3_SELECTr_CLR(r) (r).tdbgc3_select[0] = 0
#define BCM56504_A0_TDBGC3_SELECTr_SET(r,d) (r).tdbgc3_select[0] = d
#define BCM56504_A0_TDBGC3_SELECTr_GET(r) (r).tdbgc3_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_TDBGC3_SELECTr_BITMAPf_GET(r) (((r).tdbgc3_select[0]) & 0x1fffff)
#define BCM56504_A0_TDBGC3_SELECTr_BITMAPf_SET(r,f) (r).tdbgc3_select[0]=(((r).tdbgc3_select[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access TDBGC3_SELECT.
 *
 */
#define BCM56504_A0_READ_TDBGC3_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_TDBGC3_SELECTr,(r._tdbgc3_select))
#define BCM56504_A0_WRITE_TDBGC3_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_TDBGC3_SELECTr,&(r._tdbgc3_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC3_SELECTr BCM56504_A0_TDBGC3_SELECTr
#define TDBGC3_SELECTr_SIZE BCM56504_A0_TDBGC3_SELECTr_SIZE
typedef BCM56504_A0_TDBGC3_SELECTr_t TDBGC3_SELECTr_t;
#define TDBGC3_SELECTr_CLR BCM56504_A0_TDBGC3_SELECTr_CLR
#define TDBGC3_SELECTr_SET BCM56504_A0_TDBGC3_SELECTr_SET
#define TDBGC3_SELECTr_GET BCM56504_A0_TDBGC3_SELECTr_GET
#define TDBGC3_SELECTr_BITMAPf_GET BCM56504_A0_TDBGC3_SELECTr_BITMAPf_GET
#define TDBGC3_SELECTr_BITMAPf_SET BCM56504_A0_TDBGC3_SELECTr_BITMAPf_SET
#define READ_TDBGC3_SELECTr BCM56504_A0_READ_TDBGC3_SELECTr
#define WRITE_TDBGC3_SELECTr BCM56504_A0_WRITE_TDBGC3_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_TDBGC3_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  TDBGC4
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #4
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_TDBGC4r 0x0a900004

#define BCM56504_A0_TDBGC4r_SIZE 4

/*
 * This structure should be used to declare and program TDBGC4.
 *
 */
typedef union BCM56504_A0_TDBGC4r_s {
	uint32_t v[1];
	uint32_t tdbgc4[1];
	uint32_t _tdbgc4;
} BCM56504_A0_TDBGC4r_t;

#define BCM56504_A0_TDBGC4r_CLR(r) (r).tdbgc4[0] = 0
#define BCM56504_A0_TDBGC4r_SET(r,d) (r).tdbgc4[0] = d
#define BCM56504_A0_TDBGC4r_GET(r) (r).tdbgc4[0]


/*
 * These macros can be used to access TDBGC4.
 *
 */
#define BCM56504_A0_READ_TDBGC4r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_TDBGC4r,(r._tdbgc4))
#define BCM56504_A0_WRITE_TDBGC4r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_TDBGC4r,&(r._tdbgc4))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC4r BCM56504_A0_TDBGC4r
#define TDBGC4r_SIZE BCM56504_A0_TDBGC4r_SIZE
typedef BCM56504_A0_TDBGC4r_t TDBGC4r_t;
#define TDBGC4r_CLR BCM56504_A0_TDBGC4r_CLR
#define TDBGC4r_SET BCM56504_A0_TDBGC4r_SET
#define TDBGC4r_GET BCM56504_A0_TDBGC4r_GET
#define READ_TDBGC4r BCM56504_A0_READ_TDBGC4r
#define WRITE_TDBGC4r BCM56504_A0_WRITE_TDBGC4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_TDBGC4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  TDBGC4_SELECT
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #4 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The TDBGC4_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM56504_A0_TDBGC4_SELECTr 0x0a980024

#define BCM56504_A0_TDBGC4_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program TDBGC4_SELECT.
 *
 */
typedef union BCM56504_A0_TDBGC4_SELECTr_s {
	uint32_t v[1];
	uint32_t tdbgc4_select[1];
	uint32_t _tdbgc4_select;
} BCM56504_A0_TDBGC4_SELECTr_t;

#define BCM56504_A0_TDBGC4_SELECTr_CLR(r) (r).tdbgc4_select[0] = 0
#define BCM56504_A0_TDBGC4_SELECTr_SET(r,d) (r).tdbgc4_select[0] = d
#define BCM56504_A0_TDBGC4_SELECTr_GET(r) (r).tdbgc4_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_TDBGC4_SELECTr_BITMAPf_GET(r) (((r).tdbgc4_select[0]) & 0x1fffff)
#define BCM56504_A0_TDBGC4_SELECTr_BITMAPf_SET(r,f) (r).tdbgc4_select[0]=(((r).tdbgc4_select[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access TDBGC4_SELECT.
 *
 */
#define BCM56504_A0_READ_TDBGC4_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_TDBGC4_SELECTr,(r._tdbgc4_select))
#define BCM56504_A0_WRITE_TDBGC4_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_TDBGC4_SELECTr,&(r._tdbgc4_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC4_SELECTr BCM56504_A0_TDBGC4_SELECTr
#define TDBGC4_SELECTr_SIZE BCM56504_A0_TDBGC4_SELECTr_SIZE
typedef BCM56504_A0_TDBGC4_SELECTr_t TDBGC4_SELECTr_t;
#define TDBGC4_SELECTr_CLR BCM56504_A0_TDBGC4_SELECTr_CLR
#define TDBGC4_SELECTr_SET BCM56504_A0_TDBGC4_SELECTr_SET
#define TDBGC4_SELECTr_GET BCM56504_A0_TDBGC4_SELECTr_GET
#define TDBGC4_SELECTr_BITMAPf_GET BCM56504_A0_TDBGC4_SELECTr_BITMAPf_GET
#define TDBGC4_SELECTr_BITMAPf_SET BCM56504_A0_TDBGC4_SELECTr_BITMAPf_SET
#define READ_TDBGC4_SELECTr BCM56504_A0_READ_TDBGC4_SELECTr
#define WRITE_TDBGC4_SELECTr BCM56504_A0_WRITE_TDBGC4_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_TDBGC4_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  TDBGC5
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #5
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_TDBGC5r 0x0a900005

#define BCM56504_A0_TDBGC5r_SIZE 4

/*
 * This structure should be used to declare and program TDBGC5.
 *
 */
typedef union BCM56504_A0_TDBGC5r_s {
	uint32_t v[1];
	uint32_t tdbgc5[1];
	uint32_t _tdbgc5;
} BCM56504_A0_TDBGC5r_t;

#define BCM56504_A0_TDBGC5r_CLR(r) (r).tdbgc5[0] = 0
#define BCM56504_A0_TDBGC5r_SET(r,d) (r).tdbgc5[0] = d
#define BCM56504_A0_TDBGC5r_GET(r) (r).tdbgc5[0]


/*
 * These macros can be used to access TDBGC5.
 *
 */
#define BCM56504_A0_READ_TDBGC5r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_TDBGC5r,(r._tdbgc5))
#define BCM56504_A0_WRITE_TDBGC5r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_TDBGC5r,&(r._tdbgc5))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC5r BCM56504_A0_TDBGC5r
#define TDBGC5r_SIZE BCM56504_A0_TDBGC5r_SIZE
typedef BCM56504_A0_TDBGC5r_t TDBGC5r_t;
#define TDBGC5r_CLR BCM56504_A0_TDBGC5r_CLR
#define TDBGC5r_SET BCM56504_A0_TDBGC5r_SET
#define TDBGC5r_GET BCM56504_A0_TDBGC5r_GET
#define READ_TDBGC5r BCM56504_A0_READ_TDBGC5r
#define WRITE_TDBGC5r BCM56504_A0_WRITE_TDBGC5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_TDBGC5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  TDBGC5_SELECT
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #5 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The TDBGC5_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM56504_A0_TDBGC5_SELECTr 0x0a980025

#define BCM56504_A0_TDBGC5_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program TDBGC5_SELECT.
 *
 */
typedef union BCM56504_A0_TDBGC5_SELECTr_s {
	uint32_t v[1];
	uint32_t tdbgc5_select[1];
	uint32_t _tdbgc5_select;
} BCM56504_A0_TDBGC5_SELECTr_t;

#define BCM56504_A0_TDBGC5_SELECTr_CLR(r) (r).tdbgc5_select[0] = 0
#define BCM56504_A0_TDBGC5_SELECTr_SET(r,d) (r).tdbgc5_select[0] = d
#define BCM56504_A0_TDBGC5_SELECTr_GET(r) (r).tdbgc5_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_TDBGC5_SELECTr_BITMAPf_GET(r) (((r).tdbgc5_select[0]) & 0x1fffff)
#define BCM56504_A0_TDBGC5_SELECTr_BITMAPf_SET(r,f) (r).tdbgc5_select[0]=(((r).tdbgc5_select[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access TDBGC5_SELECT.
 *
 */
#define BCM56504_A0_READ_TDBGC5_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_TDBGC5_SELECTr,(r._tdbgc5_select))
#define BCM56504_A0_WRITE_TDBGC5_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_TDBGC5_SELECTr,&(r._tdbgc5_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC5_SELECTr BCM56504_A0_TDBGC5_SELECTr
#define TDBGC5_SELECTr_SIZE BCM56504_A0_TDBGC5_SELECTr_SIZE
typedef BCM56504_A0_TDBGC5_SELECTr_t TDBGC5_SELECTr_t;
#define TDBGC5_SELECTr_CLR BCM56504_A0_TDBGC5_SELECTr_CLR
#define TDBGC5_SELECTr_SET BCM56504_A0_TDBGC5_SELECTr_SET
#define TDBGC5_SELECTr_GET BCM56504_A0_TDBGC5_SELECTr_GET
#define TDBGC5_SELECTr_BITMAPf_GET BCM56504_A0_TDBGC5_SELECTr_BITMAPf_GET
#define TDBGC5_SELECTr_BITMAPf_SET BCM56504_A0_TDBGC5_SELECTr_BITMAPf_SET
#define READ_TDBGC5_SELECTr BCM56504_A0_READ_TDBGC5_SELECTr
#define WRITE_TDBGC5_SELECTr BCM56504_A0_WRITE_TDBGC5_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_TDBGC5_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  TDBGC6
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #6
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_TDBGC6r 0x0a900006

#define BCM56504_A0_TDBGC6r_SIZE 4

/*
 * This structure should be used to declare and program TDBGC6.
 *
 */
typedef union BCM56504_A0_TDBGC6r_s {
	uint32_t v[1];
	uint32_t tdbgc6[1];
	uint32_t _tdbgc6;
} BCM56504_A0_TDBGC6r_t;

#define BCM56504_A0_TDBGC6r_CLR(r) (r).tdbgc6[0] = 0
#define BCM56504_A0_TDBGC6r_SET(r,d) (r).tdbgc6[0] = d
#define BCM56504_A0_TDBGC6r_GET(r) (r).tdbgc6[0]


/*
 * These macros can be used to access TDBGC6.
 *
 */
#define BCM56504_A0_READ_TDBGC6r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_TDBGC6r,(r._tdbgc6))
#define BCM56504_A0_WRITE_TDBGC6r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_TDBGC6r,&(r._tdbgc6))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC6r BCM56504_A0_TDBGC6r
#define TDBGC6r_SIZE BCM56504_A0_TDBGC6r_SIZE
typedef BCM56504_A0_TDBGC6r_t TDBGC6r_t;
#define TDBGC6r_CLR BCM56504_A0_TDBGC6r_CLR
#define TDBGC6r_SET BCM56504_A0_TDBGC6r_SET
#define TDBGC6r_GET BCM56504_A0_TDBGC6r_GET
#define READ_TDBGC6r BCM56504_A0_READ_TDBGC6r
#define WRITE_TDBGC6r BCM56504_A0_WRITE_TDBGC6r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_TDBGC6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  TDBGC6_SELECT
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #6 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The TDBGC6_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM56504_A0_TDBGC6_SELECTr 0x0a980026

#define BCM56504_A0_TDBGC6_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program TDBGC6_SELECT.
 *
 */
typedef union BCM56504_A0_TDBGC6_SELECTr_s {
	uint32_t v[1];
	uint32_t tdbgc6_select[1];
	uint32_t _tdbgc6_select;
} BCM56504_A0_TDBGC6_SELECTr_t;

#define BCM56504_A0_TDBGC6_SELECTr_CLR(r) (r).tdbgc6_select[0] = 0
#define BCM56504_A0_TDBGC6_SELECTr_SET(r,d) (r).tdbgc6_select[0] = d
#define BCM56504_A0_TDBGC6_SELECTr_GET(r) (r).tdbgc6_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_TDBGC6_SELECTr_BITMAPf_GET(r) (((r).tdbgc6_select[0]) & 0x1fffff)
#define BCM56504_A0_TDBGC6_SELECTr_BITMAPf_SET(r,f) (r).tdbgc6_select[0]=(((r).tdbgc6_select[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access TDBGC6_SELECT.
 *
 */
#define BCM56504_A0_READ_TDBGC6_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_TDBGC6_SELECTr,(r._tdbgc6_select))
#define BCM56504_A0_WRITE_TDBGC6_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_TDBGC6_SELECTr,&(r._tdbgc6_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC6_SELECTr BCM56504_A0_TDBGC6_SELECTr
#define TDBGC6_SELECTr_SIZE BCM56504_A0_TDBGC6_SELECTr_SIZE
typedef BCM56504_A0_TDBGC6_SELECTr_t TDBGC6_SELECTr_t;
#define TDBGC6_SELECTr_CLR BCM56504_A0_TDBGC6_SELECTr_CLR
#define TDBGC6_SELECTr_SET BCM56504_A0_TDBGC6_SELECTr_SET
#define TDBGC6_SELECTr_GET BCM56504_A0_TDBGC6_SELECTr_GET
#define TDBGC6_SELECTr_BITMAPf_GET BCM56504_A0_TDBGC6_SELECTr_BITMAPf_GET
#define TDBGC6_SELECTr_BITMAPf_SET BCM56504_A0_TDBGC6_SELECTr_BITMAPf_SET
#define READ_TDBGC6_SELECTr BCM56504_A0_READ_TDBGC6_SELECTr
#define WRITE_TDBGC6_SELECTr BCM56504_A0_WRITE_TDBGC6_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_TDBGC6_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  TDBGC7
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #7
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_TDBGC7r 0x0a900007

#define BCM56504_A0_TDBGC7r_SIZE 4

/*
 * This structure should be used to declare and program TDBGC7.
 *
 */
typedef union BCM56504_A0_TDBGC7r_s {
	uint32_t v[1];
	uint32_t tdbgc7[1];
	uint32_t _tdbgc7;
} BCM56504_A0_TDBGC7r_t;

#define BCM56504_A0_TDBGC7r_CLR(r) (r).tdbgc7[0] = 0
#define BCM56504_A0_TDBGC7r_SET(r,d) (r).tdbgc7[0] = d
#define BCM56504_A0_TDBGC7r_GET(r) (r).tdbgc7[0]


/*
 * These macros can be used to access TDBGC7.
 *
 */
#define BCM56504_A0_READ_TDBGC7r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_TDBGC7r,(r._tdbgc7))
#define BCM56504_A0_WRITE_TDBGC7r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_TDBGC7r,&(r._tdbgc7))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC7r BCM56504_A0_TDBGC7r
#define TDBGC7r_SIZE BCM56504_A0_TDBGC7r_SIZE
typedef BCM56504_A0_TDBGC7r_t TDBGC7r_t;
#define TDBGC7r_CLR BCM56504_A0_TDBGC7r_CLR
#define TDBGC7r_SET BCM56504_A0_TDBGC7r_SET
#define TDBGC7r_GET BCM56504_A0_TDBGC7r_GET
#define READ_TDBGC7r BCM56504_A0_READ_TDBGC7r
#define WRITE_TDBGC7r BCM56504_A0_WRITE_TDBGC7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_TDBGC7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  TDBGC7_SELECT
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #7 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The TDBGC7_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM56504_A0_TDBGC7_SELECTr 0x0a980027

#define BCM56504_A0_TDBGC7_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program TDBGC7_SELECT.
 *
 */
typedef union BCM56504_A0_TDBGC7_SELECTr_s {
	uint32_t v[1];
	uint32_t tdbgc7_select[1];
	uint32_t _tdbgc7_select;
} BCM56504_A0_TDBGC7_SELECTr_t;

#define BCM56504_A0_TDBGC7_SELECTr_CLR(r) (r).tdbgc7_select[0] = 0
#define BCM56504_A0_TDBGC7_SELECTr_SET(r,d) (r).tdbgc7_select[0] = d
#define BCM56504_A0_TDBGC7_SELECTr_GET(r) (r).tdbgc7_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_TDBGC7_SELECTr_BITMAPf_GET(r) (((r).tdbgc7_select[0]) & 0x1fffff)
#define BCM56504_A0_TDBGC7_SELECTr_BITMAPf_SET(r,f) (r).tdbgc7_select[0]=(((r).tdbgc7_select[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access TDBGC7_SELECT.
 *
 */
#define BCM56504_A0_READ_TDBGC7_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_TDBGC7_SELECTr,(r._tdbgc7_select))
#define BCM56504_A0_WRITE_TDBGC7_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_TDBGC7_SELECTr,&(r._tdbgc7_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC7_SELECTr BCM56504_A0_TDBGC7_SELECTr
#define TDBGC7_SELECTr_SIZE BCM56504_A0_TDBGC7_SELECTr_SIZE
typedef BCM56504_A0_TDBGC7_SELECTr_t TDBGC7_SELECTr_t;
#define TDBGC7_SELECTr_CLR BCM56504_A0_TDBGC7_SELECTr_CLR
#define TDBGC7_SELECTr_SET BCM56504_A0_TDBGC7_SELECTr_SET
#define TDBGC7_SELECTr_GET BCM56504_A0_TDBGC7_SELECTr_GET
#define TDBGC7_SELECTr_BITMAPf_GET BCM56504_A0_TDBGC7_SELECTr_BITMAPf_GET
#define TDBGC7_SELECTr_BITMAPf_SET BCM56504_A0_TDBGC7_SELECTr_BITMAPf_SET
#define READ_TDBGC7_SELECTr BCM56504_A0_READ_TDBGC7_SELECTr
#define WRITE_TDBGC7_SELECTr BCM56504_A0_WRITE_TDBGC7_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_TDBGC7_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  TDBGC8
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #8
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_TDBGC8r 0x0a900008

#define BCM56504_A0_TDBGC8r_SIZE 4

/*
 * This structure should be used to declare and program TDBGC8.
 *
 */
typedef union BCM56504_A0_TDBGC8r_s {
	uint32_t v[1];
	uint32_t tdbgc8[1];
	uint32_t _tdbgc8;
} BCM56504_A0_TDBGC8r_t;

#define BCM56504_A0_TDBGC8r_CLR(r) (r).tdbgc8[0] = 0
#define BCM56504_A0_TDBGC8r_SET(r,d) (r).tdbgc8[0] = d
#define BCM56504_A0_TDBGC8r_GET(r) (r).tdbgc8[0]


/*
 * These macros can be used to access TDBGC8.
 *
 */
#define BCM56504_A0_READ_TDBGC8r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_TDBGC8r,(r._tdbgc8))
#define BCM56504_A0_WRITE_TDBGC8r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_TDBGC8r,&(r._tdbgc8))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC8r BCM56504_A0_TDBGC8r
#define TDBGC8r_SIZE BCM56504_A0_TDBGC8r_SIZE
typedef BCM56504_A0_TDBGC8r_t TDBGC8r_t;
#define TDBGC8r_CLR BCM56504_A0_TDBGC8r_CLR
#define TDBGC8r_SET BCM56504_A0_TDBGC8r_SET
#define TDBGC8r_GET BCM56504_A0_TDBGC8r_GET
#define READ_TDBGC8r BCM56504_A0_READ_TDBGC8r
#define WRITE_TDBGC8r BCM56504_A0_WRITE_TDBGC8r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_TDBGC8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  TDBGC8_SELECT
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #8 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The TDBGC8_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM56504_A0_TDBGC8_SELECTr 0x0a980028

#define BCM56504_A0_TDBGC8_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program TDBGC8_SELECT.
 *
 */
typedef union BCM56504_A0_TDBGC8_SELECTr_s {
	uint32_t v[1];
	uint32_t tdbgc8_select[1];
	uint32_t _tdbgc8_select;
} BCM56504_A0_TDBGC8_SELECTr_t;

#define BCM56504_A0_TDBGC8_SELECTr_CLR(r) (r).tdbgc8_select[0] = 0
#define BCM56504_A0_TDBGC8_SELECTr_SET(r,d) (r).tdbgc8_select[0] = d
#define BCM56504_A0_TDBGC8_SELECTr_GET(r) (r).tdbgc8_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_TDBGC8_SELECTr_BITMAPf_GET(r) (((r).tdbgc8_select[0]) & 0x1fffff)
#define BCM56504_A0_TDBGC8_SELECTr_BITMAPf_SET(r,f) (r).tdbgc8_select[0]=(((r).tdbgc8_select[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access TDBGC8_SELECT.
 *
 */
#define BCM56504_A0_READ_TDBGC8_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_TDBGC8_SELECTr,(r._tdbgc8_select))
#define BCM56504_A0_WRITE_TDBGC8_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_TDBGC8_SELECTr,&(r._tdbgc8_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC8_SELECTr BCM56504_A0_TDBGC8_SELECTr
#define TDBGC8_SELECTr_SIZE BCM56504_A0_TDBGC8_SELECTr_SIZE
typedef BCM56504_A0_TDBGC8_SELECTr_t TDBGC8_SELECTr_t;
#define TDBGC8_SELECTr_CLR BCM56504_A0_TDBGC8_SELECTr_CLR
#define TDBGC8_SELECTr_SET BCM56504_A0_TDBGC8_SELECTr_SET
#define TDBGC8_SELECTr_GET BCM56504_A0_TDBGC8_SELECTr_GET
#define TDBGC8_SELECTr_BITMAPf_GET BCM56504_A0_TDBGC8_SELECTr_BITMAPf_GET
#define TDBGC8_SELECTr_BITMAPf_SET BCM56504_A0_TDBGC8_SELECTr_BITMAPf_SET
#define READ_TDBGC8_SELECTr BCM56504_A0_READ_TDBGC8_SELECTr
#define WRITE_TDBGC8_SELECTr BCM56504_A0_WRITE_TDBGC8_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_TDBGC8_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  TDBGC9
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #9
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_TDBGC9r 0x0a900009

#define BCM56504_A0_TDBGC9r_SIZE 4

/*
 * This structure should be used to declare and program TDBGC9.
 *
 */
typedef union BCM56504_A0_TDBGC9r_s {
	uint32_t v[1];
	uint32_t tdbgc9[1];
	uint32_t _tdbgc9;
} BCM56504_A0_TDBGC9r_t;

#define BCM56504_A0_TDBGC9r_CLR(r) (r).tdbgc9[0] = 0
#define BCM56504_A0_TDBGC9r_SET(r,d) (r).tdbgc9[0] = d
#define BCM56504_A0_TDBGC9r_GET(r) (r).tdbgc9[0]


/*
 * These macros can be used to access TDBGC9.
 *
 */
#define BCM56504_A0_READ_TDBGC9r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_TDBGC9r,(r._tdbgc9))
#define BCM56504_A0_WRITE_TDBGC9r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_TDBGC9r,&(r._tdbgc9))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC9r BCM56504_A0_TDBGC9r
#define TDBGC9r_SIZE BCM56504_A0_TDBGC9r_SIZE
typedef BCM56504_A0_TDBGC9r_t TDBGC9r_t;
#define TDBGC9r_CLR BCM56504_A0_TDBGC9r_CLR
#define TDBGC9r_SET BCM56504_A0_TDBGC9r_SET
#define TDBGC9r_GET BCM56504_A0_TDBGC9r_GET
#define READ_TDBGC9r BCM56504_A0_READ_TDBGC9r
#define WRITE_TDBGC9r BCM56504_A0_WRITE_TDBGC9r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_TDBGC9r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  TDBGC9_SELECT
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #9 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The TDBGC9_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM56504_A0_TDBGC9_SELECTr 0x0a980029

#define BCM56504_A0_TDBGC9_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program TDBGC9_SELECT.
 *
 */
typedef union BCM56504_A0_TDBGC9_SELECTr_s {
	uint32_t v[1];
	uint32_t tdbgc9_select[1];
	uint32_t _tdbgc9_select;
} BCM56504_A0_TDBGC9_SELECTr_t;

#define BCM56504_A0_TDBGC9_SELECTr_CLR(r) (r).tdbgc9_select[0] = 0
#define BCM56504_A0_TDBGC9_SELECTr_SET(r,d) (r).tdbgc9_select[0] = d
#define BCM56504_A0_TDBGC9_SELECTr_GET(r) (r).tdbgc9_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_TDBGC9_SELECTr_BITMAPf_GET(r) (((r).tdbgc9_select[0]) & 0x1fffff)
#define BCM56504_A0_TDBGC9_SELECTr_BITMAPf_SET(r,f) (r).tdbgc9_select[0]=(((r).tdbgc9_select[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access TDBGC9_SELECT.
 *
 */
#define BCM56504_A0_READ_TDBGC9_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_TDBGC9_SELECTr,(r._tdbgc9_select))
#define BCM56504_A0_WRITE_TDBGC9_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_TDBGC9_SELECTr,&(r._tdbgc9_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC9_SELECTr BCM56504_A0_TDBGC9_SELECTr
#define TDBGC9_SELECTr_SIZE BCM56504_A0_TDBGC9_SELECTr_SIZE
typedef BCM56504_A0_TDBGC9_SELECTr_t TDBGC9_SELECTr_t;
#define TDBGC9_SELECTr_CLR BCM56504_A0_TDBGC9_SELECTr_CLR
#define TDBGC9_SELECTr_SET BCM56504_A0_TDBGC9_SELECTr_SET
#define TDBGC9_SELECTr_GET BCM56504_A0_TDBGC9_SELECTr_GET
#define TDBGC9_SELECTr_BITMAPf_GET BCM56504_A0_TDBGC9_SELECTr_BITMAPf_GET
#define TDBGC9_SELECTr_BITMAPf_SET BCM56504_A0_TDBGC9_SELECTr_BITMAPf_SET
#define READ_TDBGC9_SELECTr BCM56504_A0_READ_TDBGC9_SELECTr
#define WRITE_TDBGC9_SELECTr BCM56504_A0_WRITE_TDBGC9_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_TDBGC9_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  TEST2
 * BLOCKS:   GPORT0
 * DESC:     Test control
 * SIZE:     32
 * FIELDS:
 *     SPQCT            Shortcut Pause Quanta Counter
 *     TPAUSE           Test Pause
 *
 ******************************************************************************/
#define BCM56504_A0_TEST2r 0x00f00119

#define BCM56504_A0_TEST2r_SIZE 4

/*
 * This structure should be used to declare and program TEST2.
 *
 */
typedef union BCM56504_A0_TEST2r_s {
	uint32_t v[1];
	uint32_t test2[1];
	uint32_t _test2;
} BCM56504_A0_TEST2r_t;

#define BCM56504_A0_TEST2r_CLR(r) (r).test2[0] = 0
#define BCM56504_A0_TEST2r_SET(r,d) (r).test2[0] = d
#define BCM56504_A0_TEST2r_GET(r) (r).test2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_TEST2r_SPQCTf_GET(r) (((r).test2[0]) & 0x1)
#define BCM56504_A0_TEST2r_SPQCTf_SET(r,f) (r).test2[0]=(((r).test2[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_TEST2r_TPAUSEf_GET(r) ((((r).test2[0]) >> 1) & 0x1)
#define BCM56504_A0_TEST2r_TPAUSEf_SET(r,f) (r).test2[0]=(((r).test2[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access TEST2.
 *
 */
#define BCM56504_A0_READ_TEST2r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_TEST2r,(r._test2))
#define BCM56504_A0_WRITE_TEST2r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_TEST2r,&(r._test2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TEST2r BCM56504_A0_TEST2r
#define TEST2r_SIZE BCM56504_A0_TEST2r_SIZE
typedef BCM56504_A0_TEST2r_t TEST2r_t;
#define TEST2r_CLR BCM56504_A0_TEST2r_CLR
#define TEST2r_SET BCM56504_A0_TEST2r_SET
#define TEST2r_GET BCM56504_A0_TEST2r_GET
#define TEST2r_SPQCTf_GET BCM56504_A0_TEST2r_SPQCTf_GET
#define TEST2r_SPQCTf_SET BCM56504_A0_TEST2r_SPQCTf_SET
#define TEST2r_TPAUSEf_GET BCM56504_A0_TEST2r_TPAUSEf_GET
#define TEST2r_TPAUSEf_SET BCM56504_A0_TEST2r_TPAUSEf_SET
#define READ_TEST2r BCM56504_A0_READ_TEST2r
#define WRITE_TEST2r BCM56504_A0_WRITE_TEST2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_TEST2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  TOTALDYNCELLLIMIT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     TOTALDYNCELLLIMIT Total Dynamic Cell Count Limit for whole CBP memory. This represents thetotal dynamic cells that can be used by all {ports,cos}.Default value is 0xfa0.
 *     TOTALDYNCELLRESETLIMITSEL This regs is the reset limit on the percentage of TOTALDYNCELLLIMIT. Each COS hol status will be reset when CBP cells is under the percentage of TOTALDYNCELLUSED, (TOTALDYNCELLUSED < %(TOTALDYNCELLLIMIT)), and its port DYNCELLCOUNT is not over its own DYNCELLSETLIMIT. Selection are2'b000: 75% of TOTALDYNCELLLIMIT. (default setting)2'b001: 50% of TOTALDYNCELLLIMIT. 2'b010: 25% of TOTALDYNCELLLIMIT.2'b011: 12.5% of TOTALDYNCELLLIMIT.
 *
 ******************************************************************************/
#define BCM56504_A0_TOTALDYNCELLLIMITr 0x00680019

#define BCM56504_A0_TOTALDYNCELLLIMITr_SIZE 4

/*
 * This structure should be used to declare and program TOTALDYNCELLLIMIT.
 *
 */
typedef union BCM56504_A0_TOTALDYNCELLLIMITr_s {
	uint32_t v[1];
	uint32_t totaldyncelllimit[1];
	uint32_t _totaldyncelllimit;
} BCM56504_A0_TOTALDYNCELLLIMITr_t;

#define BCM56504_A0_TOTALDYNCELLLIMITr_CLR(r) (r).totaldyncelllimit[0] = 0
#define BCM56504_A0_TOTALDYNCELLLIMITr_SET(r,d) (r).totaldyncelllimit[0] = d
#define BCM56504_A0_TOTALDYNCELLLIMITr_GET(r) (r).totaldyncelllimit[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_TOTALDYNCELLLIMITr_TOTALDYNCELLLIMITf_GET(r) (((r).totaldyncelllimit[0]) & 0x3fff)
#define BCM56504_A0_TOTALDYNCELLLIMITr_TOTALDYNCELLLIMITf_SET(r,f) (r).totaldyncelllimit[0]=(((r).totaldyncelllimit[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM56504_A0_TOTALDYNCELLLIMITr_TOTALDYNCELLRESETLIMITSELf_GET(r) ((((r).totaldyncelllimit[0]) >> 14) & 0x3)
#define BCM56504_A0_TOTALDYNCELLLIMITr_TOTALDYNCELLRESETLIMITSELf_SET(r,f) (r).totaldyncelllimit[0]=(((r).totaldyncelllimit[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))

/*
 * These macros can be used to access TOTALDYNCELLLIMIT.
 *
 */
#define BCM56504_A0_READ_TOTALDYNCELLLIMITr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_TOTALDYNCELLLIMITr,(r._totaldyncelllimit))
#define BCM56504_A0_WRITE_TOTALDYNCELLLIMITr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_TOTALDYNCELLLIMITr,&(r._totaldyncelllimit))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TOTALDYNCELLLIMITr BCM56504_A0_TOTALDYNCELLLIMITr
#define TOTALDYNCELLLIMITr_SIZE BCM56504_A0_TOTALDYNCELLLIMITr_SIZE
typedef BCM56504_A0_TOTALDYNCELLLIMITr_t TOTALDYNCELLLIMITr_t;
#define TOTALDYNCELLLIMITr_CLR BCM56504_A0_TOTALDYNCELLLIMITr_CLR
#define TOTALDYNCELLLIMITr_SET BCM56504_A0_TOTALDYNCELLLIMITr_SET
#define TOTALDYNCELLLIMITr_GET BCM56504_A0_TOTALDYNCELLLIMITr_GET
#define TOTALDYNCELLLIMITr_TOTALDYNCELLLIMITf_GET BCM56504_A0_TOTALDYNCELLLIMITr_TOTALDYNCELLLIMITf_GET
#define TOTALDYNCELLLIMITr_TOTALDYNCELLLIMITf_SET BCM56504_A0_TOTALDYNCELLLIMITr_TOTALDYNCELLLIMITf_SET
#define TOTALDYNCELLLIMITr_TOTALDYNCELLRESETLIMITSELf_GET BCM56504_A0_TOTALDYNCELLLIMITr_TOTALDYNCELLRESETLIMITSELf_GET
#define TOTALDYNCELLLIMITr_TOTALDYNCELLRESETLIMITSELf_SET BCM56504_A0_TOTALDYNCELLLIMITr_TOTALDYNCELLRESETLIMITSELf_SET
#define READ_TOTALDYNCELLLIMITr BCM56504_A0_READ_TOTALDYNCELLLIMITr
#define WRITE_TOTALDYNCELLLIMITr BCM56504_A0_WRITE_TOTALDYNCELLLIMITr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_TOTALDYNCELLLIMITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  TOTALDYNCELLUSED
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     TOTALDYNCELLUSED Total Dynamic Cell Count for whole CBP memory.This represents thetotal dynamic cells that are be used by all {ports,cos}.
 *
 ******************************************************************************/
#define BCM56504_A0_TOTALDYNCELLUSEDr 0x0068001a

#define BCM56504_A0_TOTALDYNCELLUSEDr_SIZE 4

/*
 * This structure should be used to declare and program TOTALDYNCELLUSED.
 *
 */
typedef union BCM56504_A0_TOTALDYNCELLUSEDr_s {
	uint32_t v[1];
	uint32_t totaldyncellused[1];
	uint32_t _totaldyncellused;
} BCM56504_A0_TOTALDYNCELLUSEDr_t;

#define BCM56504_A0_TOTALDYNCELLUSEDr_CLR(r) (r).totaldyncellused[0] = 0
#define BCM56504_A0_TOTALDYNCELLUSEDr_SET(r,d) (r).totaldyncellused[0] = d
#define BCM56504_A0_TOTALDYNCELLUSEDr_GET(r) (r).totaldyncellused[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_TOTALDYNCELLUSEDr_TOTALDYNCELLUSEDf_GET(r) (((r).totaldyncellused[0]) & 0x3fff)
#define BCM56504_A0_TOTALDYNCELLUSEDr_TOTALDYNCELLUSEDf_SET(r,f) (r).totaldyncellused[0]=(((r).totaldyncellused[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access TOTALDYNCELLUSED.
 *
 */
#define BCM56504_A0_READ_TOTALDYNCELLUSEDr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_TOTALDYNCELLUSEDr,(r._totaldyncellused))
#define BCM56504_A0_WRITE_TOTALDYNCELLUSEDr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_TOTALDYNCELLUSEDr,&(r._totaldyncellused))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TOTALDYNCELLUSEDr BCM56504_A0_TOTALDYNCELLUSEDr
#define TOTALDYNCELLUSEDr_SIZE BCM56504_A0_TOTALDYNCELLUSEDr_SIZE
typedef BCM56504_A0_TOTALDYNCELLUSEDr_t TOTALDYNCELLUSEDr_t;
#define TOTALDYNCELLUSEDr_CLR BCM56504_A0_TOTALDYNCELLUSEDr_CLR
#define TOTALDYNCELLUSEDr_SET BCM56504_A0_TOTALDYNCELLUSEDr_SET
#define TOTALDYNCELLUSEDr_GET BCM56504_A0_TOTALDYNCELLUSEDr_GET
#define TOTALDYNCELLUSEDr_TOTALDYNCELLUSEDf_GET BCM56504_A0_TOTALDYNCELLUSEDr_TOTALDYNCELLUSEDf_GET
#define TOTALDYNCELLUSEDr_TOTALDYNCELLUSEDf_SET BCM56504_A0_TOTALDYNCELLUSEDr_TOTALDYNCELLUSEDf_SET
#define READ_TOTALDYNCELLUSEDr BCM56504_A0_READ_TOTALDYNCELLUSEDr
#define WRITE_TOTALDYNCELLUSEDr BCM56504_A0_WRITE_TOTALDYNCELLUSEDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_TOTALDYNCELLUSEDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  TPCE
 * BLOCKS:   EPIPE
 * DESC:     Egress Purge and Cell Error Drop Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56504_A0_TPCEr 0x0a90000c

#define BCM56504_A0_TPCEr_SIZE 4

/*
 * This structure should be used to declare and program TPCE.
 *
 */
typedef union BCM56504_A0_TPCEr_s {
	uint32_t v[1];
	uint32_t tpce[1];
	uint32_t _tpce;
} BCM56504_A0_TPCEr_t;

#define BCM56504_A0_TPCEr_CLR(r) (r).tpce[0] = 0
#define BCM56504_A0_TPCEr_SET(r,d) (r).tpce[0] = d
#define BCM56504_A0_TPCEr_GET(r) (r).tpce[0]


/*
 * These macros can be used to access TPCE.
 *
 */
#define BCM56504_A0_READ_TPCEr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_TPCEr,(r._tpce))
#define BCM56504_A0_WRITE_TPCEr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_TPCEr,&(r._tpce))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TPCEr BCM56504_A0_TPCEr
#define TPCEr_SIZE BCM56504_A0_TPCEr_SIZE
typedef BCM56504_A0_TPCEr_t TPCEr_t;
#define TPCEr_CLR BCM56504_A0_TPCEr_CLR
#define TPCEr_SET BCM56504_A0_TPCEr_SET
#define TPCEr_GET BCM56504_A0_TPCEr_GET
#define READ_TPCEr BCM56504_A0_READ_TPCEr
#define WRITE_TPCEr BCM56504_A0_WRITE_TPCEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_TPCEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  TRUNK_BITMAP
 * BLOCKS:   IPIPE
 * DESC:     Source Trunk Bitmap Table
 * SIZE:     29
 * FIELDS:
 *     TRUNK_BITMAP     Source Trunk Bitmap Table
 *
 ******************************************************************************/
#define BCM56504_A0_TRUNK_BITMAPm 0x0e730000

#define BCM56504_A0_TRUNK_BITMAPm_MIN 0
#define BCM56504_A0_TRUNK_BITMAPm_MAX 127
#define BCM56504_A0_TRUNK_BITMAPm_CMAX(u) 127
#define BCM56504_A0_TRUNK_BITMAPm_SIZE 4

/*
 * This structure should be used to declare and program TRUNK_BITMAP.
 *
 */
typedef union BCM56504_A0_TRUNK_BITMAPm_s {
	uint32_t v[1];
	uint32_t trunk_bitmap[1];
	uint32_t _trunk_bitmap;
} BCM56504_A0_TRUNK_BITMAPm_t;

#define BCM56504_A0_TRUNK_BITMAPm_CLR(r) (r).trunk_bitmap[0] = 0
#define BCM56504_A0_TRUNK_BITMAPm_SET(r,d) (r).trunk_bitmap[0] = d
#define BCM56504_A0_TRUNK_BITMAPm_GET(r) (r).trunk_bitmap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_TRUNK_BITMAPm_TRUNK_BITMAPf_GET(r) (((r).trunk_bitmap[0]) & 0x1fffffff)
#define BCM56504_A0_TRUNK_BITMAPm_TRUNK_BITMAPf_SET(r,f) (r).trunk_bitmap[0]=(((r).trunk_bitmap[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))

/*
 * These macros can be used to access TRUNK_BITMAP.
 *
 */
#define BCM56504_A0_READ_TRUNK_BITMAPm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_TRUNK_BITMAPm,i,(m._trunk_bitmap),1)
#define BCM56504_A0_WRITE_TRUNK_BITMAPm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_TRUNK_BITMAPm,i,&(m._trunk_bitmap),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TRUNK_BITMAPm BCM56504_A0_TRUNK_BITMAPm
#define TRUNK_BITMAPm_MIN BCM56504_A0_TRUNK_BITMAPm_MIN
#define TRUNK_BITMAPm_MAX BCM56504_A0_TRUNK_BITMAPm_MAX
#define TRUNK_BITMAPm_CMAX(u) BCM56504_A0_TRUNK_BITMAPm_CMAX(u)
#define TRUNK_BITMAPm_SIZE BCM56504_A0_TRUNK_BITMAPm_SIZE
typedef BCM56504_A0_TRUNK_BITMAPm_t TRUNK_BITMAPm_t;
#define TRUNK_BITMAPm_CLR BCM56504_A0_TRUNK_BITMAPm_CLR
#define TRUNK_BITMAPm_SET BCM56504_A0_TRUNK_BITMAPm_SET
#define TRUNK_BITMAPm_GET BCM56504_A0_TRUNK_BITMAPm_GET
#define TRUNK_BITMAPm_TRUNK_BITMAPf_GET BCM56504_A0_TRUNK_BITMAPm_TRUNK_BITMAPf_GET
#define TRUNK_BITMAPm_TRUNK_BITMAPf_SET BCM56504_A0_TRUNK_BITMAPm_TRUNK_BITMAPf_SET
#define READ_TRUNK_BITMAPm BCM56504_A0_READ_TRUNK_BITMAPm
#define WRITE_TRUNK_BITMAPm BCM56504_A0_WRITE_TRUNK_BITMAPm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_TRUNK_BITMAPm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  TRUNK_EGR_MASK
 * BLOCKS:   IPIPE
 * DESC:     Trunk Egress Block Mask Table
 * SIZE:     29
 * FIELDS:
 *     TRUNK_EGRESS_MASK Egress block mask for trunk group
 *
 ******************************************************************************/
#define BCM56504_A0_TRUNK_EGR_MASKm 0x0e710000

#define BCM56504_A0_TRUNK_EGR_MASKm_MIN 0
#define BCM56504_A0_TRUNK_EGR_MASKm_MAX 127
#define BCM56504_A0_TRUNK_EGR_MASKm_CMAX(u) 127
#define BCM56504_A0_TRUNK_EGR_MASKm_SIZE 4

/*
 * This structure should be used to declare and program TRUNK_EGR_MASK.
 *
 */
typedef union BCM56504_A0_TRUNK_EGR_MASKm_s {
	uint32_t v[1];
	uint32_t trunk_egr_mask[1];
	uint32_t _trunk_egr_mask;
} BCM56504_A0_TRUNK_EGR_MASKm_t;

#define BCM56504_A0_TRUNK_EGR_MASKm_CLR(r) (r).trunk_egr_mask[0] = 0
#define BCM56504_A0_TRUNK_EGR_MASKm_SET(r,d) (r).trunk_egr_mask[0] = d
#define BCM56504_A0_TRUNK_EGR_MASKm_GET(r) (r).trunk_egr_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_TRUNK_EGR_MASKm_TRUNK_EGRESS_MASKf_GET(r) (((r).trunk_egr_mask[0]) & 0x1fffffff)
#define BCM56504_A0_TRUNK_EGR_MASKm_TRUNK_EGRESS_MASKf_SET(r,f) (r).trunk_egr_mask[0]=(((r).trunk_egr_mask[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))

/*
 * These macros can be used to access TRUNK_EGR_MASK.
 *
 */
#define BCM56504_A0_READ_TRUNK_EGR_MASKm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_TRUNK_EGR_MASKm,i,(m._trunk_egr_mask),1)
#define BCM56504_A0_WRITE_TRUNK_EGR_MASKm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_TRUNK_EGR_MASKm,i,&(m._trunk_egr_mask),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TRUNK_EGR_MASKm BCM56504_A0_TRUNK_EGR_MASKm
#define TRUNK_EGR_MASKm_MIN BCM56504_A0_TRUNK_EGR_MASKm_MIN
#define TRUNK_EGR_MASKm_MAX BCM56504_A0_TRUNK_EGR_MASKm_MAX
#define TRUNK_EGR_MASKm_CMAX(u) BCM56504_A0_TRUNK_EGR_MASKm_CMAX(u)
#define TRUNK_EGR_MASKm_SIZE BCM56504_A0_TRUNK_EGR_MASKm_SIZE
typedef BCM56504_A0_TRUNK_EGR_MASKm_t TRUNK_EGR_MASKm_t;
#define TRUNK_EGR_MASKm_CLR BCM56504_A0_TRUNK_EGR_MASKm_CLR
#define TRUNK_EGR_MASKm_SET BCM56504_A0_TRUNK_EGR_MASKm_SET
#define TRUNK_EGR_MASKm_GET BCM56504_A0_TRUNK_EGR_MASKm_GET
#define TRUNK_EGR_MASKm_TRUNK_EGRESS_MASKf_GET BCM56504_A0_TRUNK_EGR_MASKm_TRUNK_EGRESS_MASKf_GET
#define TRUNK_EGR_MASKm_TRUNK_EGRESS_MASKf_SET BCM56504_A0_TRUNK_EGR_MASKm_TRUNK_EGRESS_MASKf_SET
#define READ_TRUNK_EGR_MASKm BCM56504_A0_READ_TRUNK_EGR_MASKm
#define WRITE_TRUNK_EGR_MASKm BCM56504_A0_WRITE_TRUNK_EGR_MASKm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_TRUNK_EGR_MASKm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  TRUNK_GROUP
 * BLOCKS:   IPIPE
 * DESC:     Egress Mask Table
 * SIZE:     91
 * FIELDS:
 *     PORT0            trunk port 0
 *     MODULE0          module id 0
 *     PORT1            trunk port 1
 *     MODULE1          module id 1
 *     PORT2            trunk port 2
 *     MODULE2          module id 2
 *     PORT3            trunk port 3
 *     MODULE3          module id 3
 *     PORT4            trunk port 4
 *     MODULE4          module id 4
 *     PORT5            trunk port 5
 *     MODULE5          module id 5
 *     PORT6            trunk port 6
 *     MODULE6          module id 6
 *     PORT7            trunk port 7
 *     MODULE7          module id 7
 *     RTAG             Supported RTAG values
 *
 ******************************************************************************/
#define BCM56504_A0_TRUNK_GROUPm 0x0e720000

#define BCM56504_A0_TRUNK_GROUPm_MIN 0
#define BCM56504_A0_TRUNK_GROUPm_MAX 127
#define BCM56504_A0_TRUNK_GROUPm_CMAX(u) 127
#define BCM56504_A0_TRUNK_GROUPm_SIZE 12

/*
 * This structure should be used to declare and program TRUNK_GROUP.
 *
 */
typedef union BCM56504_A0_TRUNK_GROUPm_s {
	uint32_t v[3];
	uint32_t trunk_group[3];
	uint32_t _trunk_group;
} BCM56504_A0_TRUNK_GROUPm_t;

#define BCM56504_A0_TRUNK_GROUPm_CLR(r) CDK_MEMSET(&((r)._trunk_group), 0, sizeof(BCM56504_A0_TRUNK_GROUPm_t))
#define BCM56504_A0_TRUNK_GROUPm_SET(r,i,d) (r).trunk_group[i] = d
#define BCM56504_A0_TRUNK_GROUPm_GET(r,i) (r).trunk_group[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_TRUNK_GROUPm_PORT0f_GET(r) (((r).trunk_group[0]) & 0x1f)
#define BCM56504_A0_TRUNK_GROUPm_PORT0f_SET(r,f) (r).trunk_group[0]=(((r).trunk_group[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56504_A0_TRUNK_GROUPm_MODULE0f_GET(r) ((((r).trunk_group[0]) >> 5) & 0x3f)
#define BCM56504_A0_TRUNK_GROUPm_MODULE0f_SET(r,f) (r).trunk_group[0]=(((r).trunk_group[0] & ~((uint32_t)0x3f << 5)) | ((((uint32_t)f) & 0x3f) << 5))
#define BCM56504_A0_TRUNK_GROUPm_PORT1f_GET(r) ((((r).trunk_group[0]) >> 11) & 0x1f)
#define BCM56504_A0_TRUNK_GROUPm_PORT1f_SET(r,f) (r).trunk_group[0]=(((r).trunk_group[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))
#define BCM56504_A0_TRUNK_GROUPm_MODULE1f_GET(r) ((((r).trunk_group[0]) >> 16) & 0x3f)
#define BCM56504_A0_TRUNK_GROUPm_MODULE1f_SET(r,f) (r).trunk_group[0]=(((r).trunk_group[0] & ~((uint32_t)0x3f << 16)) | ((((uint32_t)f) & 0x3f) << 16))
#define BCM56504_A0_TRUNK_GROUPm_PORT2f_GET(r) ((((r).trunk_group[0]) >> 22) & 0x1f)
#define BCM56504_A0_TRUNK_GROUPm_PORT2f_SET(r,f) (r).trunk_group[0]=(((r).trunk_group[0] & ~((uint32_t)0x1f << 22)) | ((((uint32_t)f) & 0x1f) << 22))
#define BCM56504_A0_TRUNK_GROUPm_MODULE2f_GET(r) cdk_field32_get((r).trunk_group,27,32)
#define BCM56504_A0_TRUNK_GROUPm_MODULE2f_SET(r,f) cdk_field32_set((r).trunk_group,27,32,f)
#define BCM56504_A0_TRUNK_GROUPm_PORT3f_GET(r) ((((r).trunk_group[1]) >> 1) & 0x1f)
#define BCM56504_A0_TRUNK_GROUPm_PORT3f_SET(r,f) (r).trunk_group[1]=(((r).trunk_group[1] & ~((uint32_t)0x1f << 1)) | ((((uint32_t)f) & 0x1f) << 1))
#define BCM56504_A0_TRUNK_GROUPm_MODULE3f_GET(r) ((((r).trunk_group[1]) >> 6) & 0x3f)
#define BCM56504_A0_TRUNK_GROUPm_MODULE3f_SET(r,f) (r).trunk_group[1]=(((r).trunk_group[1] & ~((uint32_t)0x3f << 6)) | ((((uint32_t)f) & 0x3f) << 6))
#define BCM56504_A0_TRUNK_GROUPm_PORT4f_GET(r) ((((r).trunk_group[1]) >> 12) & 0x1f)
#define BCM56504_A0_TRUNK_GROUPm_PORT4f_SET(r,f) (r).trunk_group[1]=(((r).trunk_group[1] & ~((uint32_t)0x1f << 12)) | ((((uint32_t)f) & 0x1f) << 12))
#define BCM56504_A0_TRUNK_GROUPm_MODULE4f_GET(r) ((((r).trunk_group[1]) >> 17) & 0x3f)
#define BCM56504_A0_TRUNK_GROUPm_MODULE4f_SET(r,f) (r).trunk_group[1]=(((r).trunk_group[1] & ~((uint32_t)0x3f << 17)) | ((((uint32_t)f) & 0x3f) << 17))
#define BCM56504_A0_TRUNK_GROUPm_PORT5f_GET(r) ((((r).trunk_group[1]) >> 23) & 0x1f)
#define BCM56504_A0_TRUNK_GROUPm_PORT5f_SET(r,f) (r).trunk_group[1]=(((r).trunk_group[1] & ~((uint32_t)0x1f << 23)) | ((((uint32_t)f) & 0x1f) << 23))
#define BCM56504_A0_TRUNK_GROUPm_MODULE5f_GET(r) cdk_field32_get((r).trunk_group,60,65)
#define BCM56504_A0_TRUNK_GROUPm_MODULE5f_SET(r,f) cdk_field32_set((r).trunk_group,60,65,f)
#define BCM56504_A0_TRUNK_GROUPm_PORT6f_GET(r) ((((r).trunk_group[2]) >> 2) & 0x1f)
#define BCM56504_A0_TRUNK_GROUPm_PORT6f_SET(r,f) (r).trunk_group[2]=(((r).trunk_group[2] & ~((uint32_t)0x1f << 2)) | ((((uint32_t)f) & 0x1f) << 2))
#define BCM56504_A0_TRUNK_GROUPm_MODULE6f_GET(r) ((((r).trunk_group[2]) >> 7) & 0x3f)
#define BCM56504_A0_TRUNK_GROUPm_MODULE6f_SET(r,f) (r).trunk_group[2]=(((r).trunk_group[2] & ~((uint32_t)0x3f << 7)) | ((((uint32_t)f) & 0x3f) << 7))
#define BCM56504_A0_TRUNK_GROUPm_PORT7f_GET(r) ((((r).trunk_group[2]) >> 13) & 0x1f)
#define BCM56504_A0_TRUNK_GROUPm_PORT7f_SET(r,f) (r).trunk_group[2]=(((r).trunk_group[2] & ~((uint32_t)0x1f << 13)) | ((((uint32_t)f) & 0x1f) << 13))
#define BCM56504_A0_TRUNK_GROUPm_MODULE7f_GET(r) ((((r).trunk_group[2]) >> 18) & 0x3f)
#define BCM56504_A0_TRUNK_GROUPm_MODULE7f_SET(r,f) (r).trunk_group[2]=(((r).trunk_group[2] & ~((uint32_t)0x3f << 18)) | ((((uint32_t)f) & 0x3f) << 18))
#define BCM56504_A0_TRUNK_GROUPm_RTAGf_GET(r) ((((r).trunk_group[2]) >> 24) & 0x7)
#define BCM56504_A0_TRUNK_GROUPm_RTAGf_SET(r,f) (r).trunk_group[2]=(((r).trunk_group[2] & ~((uint32_t)0x7 << 24)) | ((((uint32_t)f) & 0x7) << 24))

/*
 * These macros can be used to access TRUNK_GROUP.
 *
 */
#define BCM56504_A0_READ_TRUNK_GROUPm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_TRUNK_GROUPm,i,(m._trunk_group),3)
#define BCM56504_A0_WRITE_TRUNK_GROUPm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_TRUNK_GROUPm,i,&(m._trunk_group),3)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TRUNK_GROUPm BCM56504_A0_TRUNK_GROUPm
#define TRUNK_GROUPm_MIN BCM56504_A0_TRUNK_GROUPm_MIN
#define TRUNK_GROUPm_MAX BCM56504_A0_TRUNK_GROUPm_MAX
#define TRUNK_GROUPm_CMAX(u) BCM56504_A0_TRUNK_GROUPm_CMAX(u)
#define TRUNK_GROUPm_SIZE BCM56504_A0_TRUNK_GROUPm_SIZE
typedef BCM56504_A0_TRUNK_GROUPm_t TRUNK_GROUPm_t;
#define TRUNK_GROUPm_CLR BCM56504_A0_TRUNK_GROUPm_CLR
#define TRUNK_GROUPm_SET BCM56504_A0_TRUNK_GROUPm_SET
#define TRUNK_GROUPm_GET BCM56504_A0_TRUNK_GROUPm_GET
#define TRUNK_GROUPm_PORT0f_GET BCM56504_A0_TRUNK_GROUPm_PORT0f_GET
#define TRUNK_GROUPm_PORT0f_SET BCM56504_A0_TRUNK_GROUPm_PORT0f_SET
#define TRUNK_GROUPm_MODULE0f_GET BCM56504_A0_TRUNK_GROUPm_MODULE0f_GET
#define TRUNK_GROUPm_MODULE0f_SET BCM56504_A0_TRUNK_GROUPm_MODULE0f_SET
#define TRUNK_GROUPm_PORT1f_GET BCM56504_A0_TRUNK_GROUPm_PORT1f_GET
#define TRUNK_GROUPm_PORT1f_SET BCM56504_A0_TRUNK_GROUPm_PORT1f_SET
#define TRUNK_GROUPm_MODULE1f_GET BCM56504_A0_TRUNK_GROUPm_MODULE1f_GET
#define TRUNK_GROUPm_MODULE1f_SET BCM56504_A0_TRUNK_GROUPm_MODULE1f_SET
#define TRUNK_GROUPm_PORT2f_GET BCM56504_A0_TRUNK_GROUPm_PORT2f_GET
#define TRUNK_GROUPm_PORT2f_SET BCM56504_A0_TRUNK_GROUPm_PORT2f_SET
#define TRUNK_GROUPm_MODULE2f_GET BCM56504_A0_TRUNK_GROUPm_MODULE2f_GET
#define TRUNK_GROUPm_MODULE2f_SET BCM56504_A0_TRUNK_GROUPm_MODULE2f_SET
#define TRUNK_GROUPm_PORT3f_GET BCM56504_A0_TRUNK_GROUPm_PORT3f_GET
#define TRUNK_GROUPm_PORT3f_SET BCM56504_A0_TRUNK_GROUPm_PORT3f_SET
#define TRUNK_GROUPm_MODULE3f_GET BCM56504_A0_TRUNK_GROUPm_MODULE3f_GET
#define TRUNK_GROUPm_MODULE3f_SET BCM56504_A0_TRUNK_GROUPm_MODULE3f_SET
#define TRUNK_GROUPm_PORT4f_GET BCM56504_A0_TRUNK_GROUPm_PORT4f_GET
#define TRUNK_GROUPm_PORT4f_SET BCM56504_A0_TRUNK_GROUPm_PORT4f_SET
#define TRUNK_GROUPm_MODULE4f_GET BCM56504_A0_TRUNK_GROUPm_MODULE4f_GET
#define TRUNK_GROUPm_MODULE4f_SET BCM56504_A0_TRUNK_GROUPm_MODULE4f_SET
#define TRUNK_GROUPm_PORT5f_GET BCM56504_A0_TRUNK_GROUPm_PORT5f_GET
#define TRUNK_GROUPm_PORT5f_SET BCM56504_A0_TRUNK_GROUPm_PORT5f_SET
#define TRUNK_GROUPm_MODULE5f_GET BCM56504_A0_TRUNK_GROUPm_MODULE5f_GET
#define TRUNK_GROUPm_MODULE5f_SET BCM56504_A0_TRUNK_GROUPm_MODULE5f_SET
#define TRUNK_GROUPm_PORT6f_GET BCM56504_A0_TRUNK_GROUPm_PORT6f_GET
#define TRUNK_GROUPm_PORT6f_SET BCM56504_A0_TRUNK_GROUPm_PORT6f_SET
#define TRUNK_GROUPm_MODULE6f_GET BCM56504_A0_TRUNK_GROUPm_MODULE6f_GET
#define TRUNK_GROUPm_MODULE6f_SET BCM56504_A0_TRUNK_GROUPm_MODULE6f_SET
#define TRUNK_GROUPm_PORT7f_GET BCM56504_A0_TRUNK_GROUPm_PORT7f_GET
#define TRUNK_GROUPm_PORT7f_SET BCM56504_A0_TRUNK_GROUPm_PORT7f_SET
#define TRUNK_GROUPm_MODULE7f_GET BCM56504_A0_TRUNK_GROUPm_MODULE7f_GET
#define TRUNK_GROUPm_MODULE7f_SET BCM56504_A0_TRUNK_GROUPm_MODULE7f_SET
#define TRUNK_GROUPm_RTAGf_GET BCM56504_A0_TRUNK_GROUPm_RTAGf_GET
#define TRUNK_GROUPm_RTAGf_SET BCM56504_A0_TRUNK_GROUPm_RTAGf_SET
#define READ_TRUNK_GROUPm BCM56504_A0_READ_TRUNK_GROUPm
#define WRITE_TRUNK_GROUPm BCM56504_A0_WRITE_TRUNK_GROUPm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_TRUNK_GROUPm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * SWFORMAT:  TX_DCB
 * BLOCKS:  
 * DESC:     Packet DMA descriptor.
 * SIZE:     352
 * FIELDS:
 *     BYTES_TRANSFERRED Number of bytes transferred.
 *     DONE             Descriptor done.
 *     MODULE_HEADER    Valid only if the HG bit is set to 1 in this descriptor.
 *     BYTE_COUNT       Byte count for the transfer.
 *     CHAIN            Indicates that next sequential descriptor is valid.
 *     SG               Scatter/Gather - packet continues in the next DMA descriptor.
 *     RELOAD           Load next descriptor from address in ADDR field.
 *     HG               Specifies whether the current packet is in HiGig format.0=Regular Ethernet format, 1=HiGig format
 *     STAT             Update statistics counters (TX packet).
 *     PAUSE            Set to indicate that TX packet is a pause frame.
 *     PURGE            Set to indicate that TX packet should be purged.
 *     ADDR             Physical memory address for the transfer.
 *
 ******************************************************************************/
#define BCM56504_A0_TX_DCB 0x00000000

#define BCM56504_A0_TX_DCB_SIZE 44

/*
 * This structure should be used to declare and program TX_DCB.
 *
 */
typedef union BCM56504_A0_TX_DCB_s {
	uint32_t v[11];
	uint32_t tx_dcb[11];
	uint32_t _tx_dcb;
} BCM56504_A0_TX_DCB_t;

#define BCM56504_A0_TX_DCB_CLR(r) CDK_MEMSET(&((r)._tx_dcb), 0, sizeof(BCM56504_A0_TX_DCB_t))
#define BCM56504_A0_TX_DCB_SET(r,i,d) (r).tx_dcb[i] = d
#define BCM56504_A0_TX_DCB_GET(r,i) (r).tx_dcb[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_TX_DCB_BYTES_TRANSFERREDf_GET(r) (((r).tx_dcb[10]) & 0xffff)
#define BCM56504_A0_TX_DCB_BYTES_TRANSFERREDf_SET(r,f) (r).tx_dcb[10]=(((r).tx_dcb[10] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56504_A0_TX_DCB_DONEf_GET(r) ((((r).tx_dcb[10]) >> 31) & 0x1)
#define BCM56504_A0_TX_DCB_DONEf_SET(r,f) (r).tx_dcb[10]=(((r).tx_dcb[10] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM56504_A0_TX_DCB_MODULE_HEADERf_GET(r,a) cdk_field_be_get((r).tx_dcb,11,192,287,a)
#define BCM56504_A0_TX_DCB_MODULE_HEADERf_SET(r,a) cdk_field_be_set((r).tx_dcb,11,192,287,a)
#define BCM56504_A0_TX_DCB_MODULE_HEADERf_PTR(r) ((void*)&(r).tx_dcb[2])
#define BCM56504_A0_TX_DCB_BYTE_COUNTf_GET(r) (((r).tx_dcb[1]) & 0xffff)
#define BCM56504_A0_TX_DCB_BYTE_COUNTf_SET(r,f) (r).tx_dcb[1]=(((r).tx_dcb[1] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56504_A0_TX_DCB_CHAINf_GET(r) ((((r).tx_dcb[1]) >> 16) & 0x1)
#define BCM56504_A0_TX_DCB_CHAINf_SET(r,f) (r).tx_dcb[1]=(((r).tx_dcb[1] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56504_A0_TX_DCB_SGf_GET(r) ((((r).tx_dcb[1]) >> 17) & 0x1)
#define BCM56504_A0_TX_DCB_SGf_SET(r,f) (r).tx_dcb[1]=(((r).tx_dcb[1] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56504_A0_TX_DCB_RELOADf_GET(r) ((((r).tx_dcb[1]) >> 18) & 0x1)
#define BCM56504_A0_TX_DCB_RELOADf_SET(r,f) (r).tx_dcb[1]=(((r).tx_dcb[1] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56504_A0_TX_DCB_HGf_GET(r) ((((r).tx_dcb[1]) >> 19) & 0x1)
#define BCM56504_A0_TX_DCB_HGf_SET(r,f) (r).tx_dcb[1]=(((r).tx_dcb[1] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56504_A0_TX_DCB_STATf_GET(r) ((((r).tx_dcb[1]) >> 20) & 0x1)
#define BCM56504_A0_TX_DCB_STATf_SET(r,f) (r).tx_dcb[1]=(((r).tx_dcb[1] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM56504_A0_TX_DCB_PAUSEf_GET(r) ((((r).tx_dcb[1]) >> 21) & 0x1)
#define BCM56504_A0_TX_DCB_PAUSEf_SET(r,f) (r).tx_dcb[1]=(((r).tx_dcb[1] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM56504_A0_TX_DCB_PURGEf_GET(r) ((((r).tx_dcb[1]) >> 22) & 0x1)
#define BCM56504_A0_TX_DCB_PURGEf_SET(r,f) (r).tx_dcb[1]=(((r).tx_dcb[1] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM56504_A0_TX_DCB_ADDRf_GET(r) ((r).tx_dcb[0])
#define BCM56504_A0_TX_DCB_ADDRf_SET(r,f) (r).tx_dcb[0]=((uint32_t)f)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TX_DCB BCM56504_A0_TX_DCB
#define TX_DCB_SIZE BCM56504_A0_TX_DCB_SIZE
typedef BCM56504_A0_TX_DCB_t TX_DCB_t;
#define TX_DCB_CLR BCM56504_A0_TX_DCB_CLR
#define TX_DCB_SET BCM56504_A0_TX_DCB_SET
#define TX_DCB_GET BCM56504_A0_TX_DCB_GET
#define TX_DCB_BYTES_TRANSFERREDf_GET BCM56504_A0_TX_DCB_BYTES_TRANSFERREDf_GET
#define TX_DCB_BYTES_TRANSFERREDf_SET BCM56504_A0_TX_DCB_BYTES_TRANSFERREDf_SET
#define TX_DCB_DONEf_GET BCM56504_A0_TX_DCB_DONEf_GET
#define TX_DCB_DONEf_SET BCM56504_A0_TX_DCB_DONEf_SET
#define TX_DCB_MODULE_HEADERf_GET BCM56504_A0_TX_DCB_MODULE_HEADERf_GET
#define TX_DCB_MODULE_HEADERf_SET BCM56504_A0_TX_DCB_MODULE_HEADERf_SET
#define TX_DCB_MODULE_HEADERf_PTR BCM56504_A0_TX_DCB_MODULE_HEADERf_PTR
#define TX_DCB_BYTE_COUNTf_GET BCM56504_A0_TX_DCB_BYTE_COUNTf_GET
#define TX_DCB_BYTE_COUNTf_SET BCM56504_A0_TX_DCB_BYTE_COUNTf_SET
#define TX_DCB_CHAINf_GET BCM56504_A0_TX_DCB_CHAINf_GET
#define TX_DCB_CHAINf_SET BCM56504_A0_TX_DCB_CHAINf_SET
#define TX_DCB_SGf_GET BCM56504_A0_TX_DCB_SGf_GET
#define TX_DCB_SGf_SET BCM56504_A0_TX_DCB_SGf_SET
#define TX_DCB_RELOADf_GET BCM56504_A0_TX_DCB_RELOADf_GET
#define TX_DCB_RELOADf_SET BCM56504_A0_TX_DCB_RELOADf_SET
#define TX_DCB_HGf_GET BCM56504_A0_TX_DCB_HGf_GET
#define TX_DCB_HGf_SET BCM56504_A0_TX_DCB_HGf_SET
#define TX_DCB_STATf_GET BCM56504_A0_TX_DCB_STATf_GET
#define TX_DCB_STATf_SET BCM56504_A0_TX_DCB_STATf_SET
#define TX_DCB_PAUSEf_GET BCM56504_A0_TX_DCB_PAUSEf_GET
#define TX_DCB_PAUSEf_SET BCM56504_A0_TX_DCB_PAUSEf_SET
#define TX_DCB_PURGEf_GET BCM56504_A0_TX_DCB_PURGEf_GET
#define TX_DCB_PURGEf_SET BCM56504_A0_TX_DCB_PURGEf_SET
#define TX_DCB_ADDRf_GET BCM56504_A0_TX_DCB_ADDRf_GET
#define TX_DCB_ADDRf_SET BCM56504_A0_TX_DCB_ADDRf_SET
#define READ_TX_DCB BCM56504_A0_READ_TX_DCB
#define WRITE_TX_DCB BCM56504_A0_WRITE_TX_DCB

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_TX_DCB'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  UNKNOWN_MCAST_BLOCK_MASK
 * BLOCKS:   IPIPE
 * DESC:     Unknown Multicast Block Mask
 * SIZE:     32
 * FIELDS:
 *     BLK_BITMAP       Bitmap of ports to be blocked
 *
 ******************************************************************************/
#define BCM56504_A0_UNKNOWN_MCAST_BLOCK_MASKr 0x0e700101

#define BCM56504_A0_UNKNOWN_MCAST_BLOCK_MASKr_SIZE 4

/*
 * This structure should be used to declare and program UNKNOWN_MCAST_BLOCK_MASK.
 *
 */
typedef union BCM56504_A0_UNKNOWN_MCAST_BLOCK_MASKr_s {
	uint32_t v[1];
	uint32_t unknown_mcast_block_mask[1];
	uint32_t _unknown_mcast_block_mask;
} BCM56504_A0_UNKNOWN_MCAST_BLOCK_MASKr_t;

#define BCM56504_A0_UNKNOWN_MCAST_BLOCK_MASKr_CLR(r) (r).unknown_mcast_block_mask[0] = 0
#define BCM56504_A0_UNKNOWN_MCAST_BLOCK_MASKr_SET(r,d) (r).unknown_mcast_block_mask[0] = d
#define BCM56504_A0_UNKNOWN_MCAST_BLOCK_MASKr_GET(r) (r).unknown_mcast_block_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_UNKNOWN_MCAST_BLOCK_MASKr_BLK_BITMAPf_GET(r) (((r).unknown_mcast_block_mask[0]) & 0x1fffffff)
#define BCM56504_A0_UNKNOWN_MCAST_BLOCK_MASKr_BLK_BITMAPf_SET(r,f) (r).unknown_mcast_block_mask[0]=(((r).unknown_mcast_block_mask[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))

/*
 * These macros can be used to access UNKNOWN_MCAST_BLOCK_MASK.
 *
 */
#define BCM56504_A0_READ_UNKNOWN_MCAST_BLOCK_MASKr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_UNKNOWN_MCAST_BLOCK_MASKr,(r._unknown_mcast_block_mask))
#define BCM56504_A0_WRITE_UNKNOWN_MCAST_BLOCK_MASKr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_UNKNOWN_MCAST_BLOCK_MASKr,&(r._unknown_mcast_block_mask))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define UNKNOWN_MCAST_BLOCK_MASKr BCM56504_A0_UNKNOWN_MCAST_BLOCK_MASKr
#define UNKNOWN_MCAST_BLOCK_MASKr_SIZE BCM56504_A0_UNKNOWN_MCAST_BLOCK_MASKr_SIZE
typedef BCM56504_A0_UNKNOWN_MCAST_BLOCK_MASKr_t UNKNOWN_MCAST_BLOCK_MASKr_t;
#define UNKNOWN_MCAST_BLOCK_MASKr_CLR BCM56504_A0_UNKNOWN_MCAST_BLOCK_MASKr_CLR
#define UNKNOWN_MCAST_BLOCK_MASKr_SET BCM56504_A0_UNKNOWN_MCAST_BLOCK_MASKr_SET
#define UNKNOWN_MCAST_BLOCK_MASKr_GET BCM56504_A0_UNKNOWN_MCAST_BLOCK_MASKr_GET
#define UNKNOWN_MCAST_BLOCK_MASKr_BLK_BITMAPf_GET BCM56504_A0_UNKNOWN_MCAST_BLOCK_MASKr_BLK_BITMAPf_GET
#define UNKNOWN_MCAST_BLOCK_MASKr_BLK_BITMAPf_SET BCM56504_A0_UNKNOWN_MCAST_BLOCK_MASKr_BLK_BITMAPf_SET
#define READ_UNKNOWN_MCAST_BLOCK_MASKr BCM56504_A0_READ_UNKNOWN_MCAST_BLOCK_MASKr
#define WRITE_UNKNOWN_MCAST_BLOCK_MASKr BCM56504_A0_WRITE_UNKNOWN_MCAST_BLOCK_MASKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_UNKNOWN_MCAST_BLOCK_MASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  UNKNOWN_UCAST_BLOCK_MASK
 * BLOCKS:   IPIPE
 * DESC:     Unknown Unicast Block Mask
 * SIZE:     32
 * FIELDS:
 *     BLK_BITMAP       Bitmap of ports to be blocked
 *
 ******************************************************************************/
#define BCM56504_A0_UNKNOWN_UCAST_BLOCK_MASKr 0x0e700100

#define BCM56504_A0_UNKNOWN_UCAST_BLOCK_MASKr_SIZE 4

/*
 * This structure should be used to declare and program UNKNOWN_UCAST_BLOCK_MASK.
 *
 */
typedef union BCM56504_A0_UNKNOWN_UCAST_BLOCK_MASKr_s {
	uint32_t v[1];
	uint32_t unknown_ucast_block_mask[1];
	uint32_t _unknown_ucast_block_mask;
} BCM56504_A0_UNKNOWN_UCAST_BLOCK_MASKr_t;

#define BCM56504_A0_UNKNOWN_UCAST_BLOCK_MASKr_CLR(r) (r).unknown_ucast_block_mask[0] = 0
#define BCM56504_A0_UNKNOWN_UCAST_BLOCK_MASKr_SET(r,d) (r).unknown_ucast_block_mask[0] = d
#define BCM56504_A0_UNKNOWN_UCAST_BLOCK_MASKr_GET(r) (r).unknown_ucast_block_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_UNKNOWN_UCAST_BLOCK_MASKr_BLK_BITMAPf_GET(r) (((r).unknown_ucast_block_mask[0]) & 0x1fffffff)
#define BCM56504_A0_UNKNOWN_UCAST_BLOCK_MASKr_BLK_BITMAPf_SET(r,f) (r).unknown_ucast_block_mask[0]=(((r).unknown_ucast_block_mask[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))

/*
 * These macros can be used to access UNKNOWN_UCAST_BLOCK_MASK.
 *
 */
#define BCM56504_A0_READ_UNKNOWN_UCAST_BLOCK_MASKr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_UNKNOWN_UCAST_BLOCK_MASKr,(r._unknown_ucast_block_mask))
#define BCM56504_A0_WRITE_UNKNOWN_UCAST_BLOCK_MASKr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_UNKNOWN_UCAST_BLOCK_MASKr,&(r._unknown_ucast_block_mask))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define UNKNOWN_UCAST_BLOCK_MASKr BCM56504_A0_UNKNOWN_UCAST_BLOCK_MASKr
#define UNKNOWN_UCAST_BLOCK_MASKr_SIZE BCM56504_A0_UNKNOWN_UCAST_BLOCK_MASKr_SIZE
typedef BCM56504_A0_UNKNOWN_UCAST_BLOCK_MASKr_t UNKNOWN_UCAST_BLOCK_MASKr_t;
#define UNKNOWN_UCAST_BLOCK_MASKr_CLR BCM56504_A0_UNKNOWN_UCAST_BLOCK_MASKr_CLR
#define UNKNOWN_UCAST_BLOCK_MASKr_SET BCM56504_A0_UNKNOWN_UCAST_BLOCK_MASKr_SET
#define UNKNOWN_UCAST_BLOCK_MASKr_GET BCM56504_A0_UNKNOWN_UCAST_BLOCK_MASKr_GET
#define UNKNOWN_UCAST_BLOCK_MASKr_BLK_BITMAPf_GET BCM56504_A0_UNKNOWN_UCAST_BLOCK_MASKr_BLK_BITMAPf_GET
#define UNKNOWN_UCAST_BLOCK_MASKr_BLK_BITMAPf_SET BCM56504_A0_UNKNOWN_UCAST_BLOCK_MASKr_BLK_BITMAPf_SET
#define READ_UNKNOWN_UCAST_BLOCK_MASKr BCM56504_A0_READ_UNKNOWN_UCAST_BLOCK_MASKr
#define WRITE_UNKNOWN_UCAST_BLOCK_MASKr BCM56504_A0_WRITE_UNKNOWN_UCAST_BLOCK_MASKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_UNKNOWN_UCAST_BLOCK_MASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  VLAN_CTRL
 * BLOCKS:   IPIPE
 * DESC:     VLAN Control Register #1
 * SIZE:     32
 * FIELDS:
 *     LEARN_VID        LEARN_VID for ARL learning
 *     USE_LEARN_VID    USE LEARN_VID field from this register for ARL learning
 *     INNER_TPID       TPID for inner VLAN, used for double tagging modes only
 *
 ******************************************************************************/
#define BCM56504_A0_VLAN_CTRLr 0x01780002

#define BCM56504_A0_VLAN_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program VLAN_CTRL.
 *
 */
typedef union BCM56504_A0_VLAN_CTRLr_s {
	uint32_t v[1];
	uint32_t vlan_ctrl[1];
	uint32_t _vlan_ctrl;
} BCM56504_A0_VLAN_CTRLr_t;

#define BCM56504_A0_VLAN_CTRLr_CLR(r) (r).vlan_ctrl[0] = 0
#define BCM56504_A0_VLAN_CTRLr_SET(r,d) (r).vlan_ctrl[0] = d
#define BCM56504_A0_VLAN_CTRLr_GET(r) (r).vlan_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_VLAN_CTRLr_LEARN_VIDf_GET(r) (((r).vlan_ctrl[0]) & 0xfff)
#define BCM56504_A0_VLAN_CTRLr_LEARN_VIDf_SET(r,f) (r).vlan_ctrl[0]=(((r).vlan_ctrl[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM56504_A0_VLAN_CTRLr_USE_LEARN_VIDf_GET(r) ((((r).vlan_ctrl[0]) >> 12) & 0x1)
#define BCM56504_A0_VLAN_CTRLr_USE_LEARN_VIDf_SET(r,f) (r).vlan_ctrl[0]=(((r).vlan_ctrl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM56504_A0_VLAN_CTRLr_INNER_TPIDf_GET(r) ((((r).vlan_ctrl[0]) >> 13) & 0xffff)
#define BCM56504_A0_VLAN_CTRLr_INNER_TPIDf_SET(r,f) (r).vlan_ctrl[0]=(((r).vlan_ctrl[0] & ~((uint32_t)0xffff << 13)) | ((((uint32_t)f) & 0xffff) << 13))

/*
 * These macros can be used to access VLAN_CTRL.
 *
 */
#define BCM56504_A0_READ_VLAN_CTRLr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_VLAN_CTRLr,(r._vlan_ctrl))
#define BCM56504_A0_WRITE_VLAN_CTRLr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_VLAN_CTRLr,&(r._vlan_ctrl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_CTRLr BCM56504_A0_VLAN_CTRLr
#define VLAN_CTRLr_SIZE BCM56504_A0_VLAN_CTRLr_SIZE
typedef BCM56504_A0_VLAN_CTRLr_t VLAN_CTRLr_t;
#define VLAN_CTRLr_CLR BCM56504_A0_VLAN_CTRLr_CLR
#define VLAN_CTRLr_SET BCM56504_A0_VLAN_CTRLr_SET
#define VLAN_CTRLr_GET BCM56504_A0_VLAN_CTRLr_GET
#define VLAN_CTRLr_LEARN_VIDf_GET BCM56504_A0_VLAN_CTRLr_LEARN_VIDf_GET
#define VLAN_CTRLr_LEARN_VIDf_SET BCM56504_A0_VLAN_CTRLr_LEARN_VIDf_SET
#define VLAN_CTRLr_USE_LEARN_VIDf_GET BCM56504_A0_VLAN_CTRLr_USE_LEARN_VIDf_GET
#define VLAN_CTRLr_USE_LEARN_VIDf_SET BCM56504_A0_VLAN_CTRLr_USE_LEARN_VIDf_SET
#define VLAN_CTRLr_INNER_TPIDf_GET BCM56504_A0_VLAN_CTRLr_INNER_TPIDf_GET
#define VLAN_CTRLr_INNER_TPIDf_SET BCM56504_A0_VLAN_CTRLr_INNER_TPIDf_SET
#define READ_VLAN_CTRLr BCM56504_A0_READ_VLAN_CTRLr
#define WRITE_VLAN_CTRLr BCM56504_A0_WRITE_VLAN_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_VLAN_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  VLAN_MAC
 * BLOCKS:   IPIPE
 * DESC:     Holds key & data for MAC-based VLAN substitution
 * SIZE:     64
 * FIELDS:
 *     MAC_ADDR         MAC address key
 *     VLAN_ID          VLAN ID
 *     PRI              Priority
 *     VALID            VLAN ID
 *
 ******************************************************************************/
#define BCM56504_A0_VLAN_MACm 0x04750000

#define BCM56504_A0_VLAN_MACm_MIN 0
#define BCM56504_A0_VLAN_MACm_MAX 1023
#define BCM56504_A0_VLAN_MACm_CMAX(u) 1023
#define BCM56504_A0_VLAN_MACm_SIZE 8

/*
 * This structure should be used to declare and program VLAN_MAC.
 *
 */
typedef union BCM56504_A0_VLAN_MACm_s {
	uint32_t v[2];
	uint32_t vlan_mac[2];
	uint32_t _vlan_mac;
} BCM56504_A0_VLAN_MACm_t;

#define BCM56504_A0_VLAN_MACm_CLR(r) CDK_MEMSET(&((r)._vlan_mac), 0, sizeof(BCM56504_A0_VLAN_MACm_t))
#define BCM56504_A0_VLAN_MACm_SET(r,i,d) (r).vlan_mac[i] = d
#define BCM56504_A0_VLAN_MACm_GET(r,i) (r).vlan_mac[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_VLAN_MACm_MAC_ADDRf_GET(r,a) cdk_field_get((r).vlan_mac,0,47,a)
#define BCM56504_A0_VLAN_MACm_MAC_ADDRf_SET(r,a) cdk_field_set((r).vlan_mac,0,47,a)
#define BCM56504_A0_VLAN_MACm_VLAN_IDf_GET(r) ((((r).vlan_mac[1]) >> 16) & 0xfff)
#define BCM56504_A0_VLAN_MACm_VLAN_IDf_SET(r,f) (r).vlan_mac[1]=(((r).vlan_mac[1] & ~((uint32_t)0xfff << 16)) | ((((uint32_t)f) & 0xfff) << 16))
#define BCM56504_A0_VLAN_MACm_PRIf_GET(r) ((((r).vlan_mac[1]) >> 28) & 0x7)
#define BCM56504_A0_VLAN_MACm_PRIf_SET(r,f) (r).vlan_mac[1]=(((r).vlan_mac[1] & ~((uint32_t)0x7 << 28)) | ((((uint32_t)f) & 0x7) << 28))
#define BCM56504_A0_VLAN_MACm_VALIDf_GET(r) ((((r).vlan_mac[1]) >> 31) & 0x1)
#define BCM56504_A0_VLAN_MACm_VALIDf_SET(r,f) (r).vlan_mac[1]=(((r).vlan_mac[1] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access VLAN_MAC.
 *
 */
#define BCM56504_A0_READ_VLAN_MACm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_VLAN_MACm,i,(m._vlan_mac),2)
#define BCM56504_A0_WRITE_VLAN_MACm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_VLAN_MACm,i,&(m._vlan_mac),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_MACm BCM56504_A0_VLAN_MACm
#define VLAN_MACm_MIN BCM56504_A0_VLAN_MACm_MIN
#define VLAN_MACm_MAX BCM56504_A0_VLAN_MACm_MAX
#define VLAN_MACm_CMAX(u) BCM56504_A0_VLAN_MACm_CMAX(u)
#define VLAN_MACm_SIZE BCM56504_A0_VLAN_MACm_SIZE
typedef BCM56504_A0_VLAN_MACm_t VLAN_MACm_t;
#define VLAN_MACm_CLR BCM56504_A0_VLAN_MACm_CLR
#define VLAN_MACm_SET BCM56504_A0_VLAN_MACm_SET
#define VLAN_MACm_GET BCM56504_A0_VLAN_MACm_GET
#define VLAN_MACm_MAC_ADDRf_GET BCM56504_A0_VLAN_MACm_MAC_ADDRf_GET
#define VLAN_MACm_MAC_ADDRf_SET BCM56504_A0_VLAN_MACm_MAC_ADDRf_SET
#define VLAN_MACm_VLAN_IDf_GET BCM56504_A0_VLAN_MACm_VLAN_IDf_GET
#define VLAN_MACm_VLAN_IDf_SET BCM56504_A0_VLAN_MACm_VLAN_IDf_SET
#define VLAN_MACm_PRIf_GET BCM56504_A0_VLAN_MACm_PRIf_GET
#define VLAN_MACm_PRIf_SET BCM56504_A0_VLAN_MACm_PRIf_SET
#define VLAN_MACm_VALIDf_GET BCM56504_A0_VLAN_MACm_VALIDf_GET
#define VLAN_MACm_VALIDf_SET BCM56504_A0_VLAN_MACm_VALIDf_SET
#define READ_VLAN_MACm BCM56504_A0_READ_VLAN_MACm
#define WRITE_VLAN_MACm BCM56504_A0_WRITE_VLAN_MACm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_VLAN_MACm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  VLAN_PROTOCOL
 * BLOCKS:   IPIPE
 * DESC:     Holds data for Protocol-based VLAN substitution.  Just the VLAN_PROTOCOL RAM.
 * SIZE:     21
 * FIELDS:
 *     ETHERTYPE        Ethertype field
 *     LLC              LLC type pkt
 *     SNAP             SNAP type pkt
 *     ETHERII          Ethernet 2 type pkt
 *     MATCHLOWER       Match lower
 *     MATCHUPPER       Match upper
 *
 ******************************************************************************/
#define BCM56504_A0_VLAN_PROTOCOLm 0x04700000

#define BCM56504_A0_VLAN_PROTOCOLm_MIN 0
#define BCM56504_A0_VLAN_PROTOCOLm_MAX 15
#define BCM56504_A0_VLAN_PROTOCOLm_CMAX(u) 15
#define BCM56504_A0_VLAN_PROTOCOLm_SIZE 3

/*
 * This structure should be used to declare and program VLAN_PROTOCOL.
 *
 */
typedef union BCM56504_A0_VLAN_PROTOCOLm_s {
	uint32_t v[1];
	uint32_t vlan_protocol[1];
	uint32_t _vlan_protocol;
} BCM56504_A0_VLAN_PROTOCOLm_t;

#define BCM56504_A0_VLAN_PROTOCOLm_CLR(r) (r).vlan_protocol[0] = 0
#define BCM56504_A0_VLAN_PROTOCOLm_SET(r,d) (r).vlan_protocol[0] = d
#define BCM56504_A0_VLAN_PROTOCOLm_GET(r) (r).vlan_protocol[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_VLAN_PROTOCOLm_ETHERTYPEf_GET(r) (((r).vlan_protocol[0]) & 0xffff)
#define BCM56504_A0_VLAN_PROTOCOLm_ETHERTYPEf_SET(r,f) (r).vlan_protocol[0]=(((r).vlan_protocol[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56504_A0_VLAN_PROTOCOLm_LLCf_GET(r) ((((r).vlan_protocol[0]) >> 16) & 0x1)
#define BCM56504_A0_VLAN_PROTOCOLm_LLCf_SET(r,f) (r).vlan_protocol[0]=(((r).vlan_protocol[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56504_A0_VLAN_PROTOCOLm_SNAPf_GET(r) ((((r).vlan_protocol[0]) >> 17) & 0x1)
#define BCM56504_A0_VLAN_PROTOCOLm_SNAPf_SET(r,f) (r).vlan_protocol[0]=(((r).vlan_protocol[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56504_A0_VLAN_PROTOCOLm_ETHERIIf_GET(r) ((((r).vlan_protocol[0]) >> 18) & 0x1)
#define BCM56504_A0_VLAN_PROTOCOLm_ETHERIIf_SET(r,f) (r).vlan_protocol[0]=(((r).vlan_protocol[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56504_A0_VLAN_PROTOCOLm_MATCHLOWERf_GET(r) ((((r).vlan_protocol[0]) >> 19) & 0x1)
#define BCM56504_A0_VLAN_PROTOCOLm_MATCHLOWERf_SET(r,f) (r).vlan_protocol[0]=(((r).vlan_protocol[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56504_A0_VLAN_PROTOCOLm_MATCHUPPERf_GET(r) ((((r).vlan_protocol[0]) >> 20) & 0x1)
#define BCM56504_A0_VLAN_PROTOCOLm_MATCHUPPERf_SET(r,f) (r).vlan_protocol[0]=(((r).vlan_protocol[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))

/*
 * These macros can be used to access VLAN_PROTOCOL.
 *
 */
#define BCM56504_A0_READ_VLAN_PROTOCOLm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_VLAN_PROTOCOLm,i,(m._vlan_protocol),1)
#define BCM56504_A0_WRITE_VLAN_PROTOCOLm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_VLAN_PROTOCOLm,i,&(m._vlan_protocol),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_PROTOCOLm BCM56504_A0_VLAN_PROTOCOLm
#define VLAN_PROTOCOLm_MIN BCM56504_A0_VLAN_PROTOCOLm_MIN
#define VLAN_PROTOCOLm_MAX BCM56504_A0_VLAN_PROTOCOLm_MAX
#define VLAN_PROTOCOLm_CMAX(u) BCM56504_A0_VLAN_PROTOCOLm_CMAX(u)
#define VLAN_PROTOCOLm_SIZE BCM56504_A0_VLAN_PROTOCOLm_SIZE
typedef BCM56504_A0_VLAN_PROTOCOLm_t VLAN_PROTOCOLm_t;
#define VLAN_PROTOCOLm_CLR BCM56504_A0_VLAN_PROTOCOLm_CLR
#define VLAN_PROTOCOLm_SET BCM56504_A0_VLAN_PROTOCOLm_SET
#define VLAN_PROTOCOLm_GET BCM56504_A0_VLAN_PROTOCOLm_GET
#define VLAN_PROTOCOLm_ETHERTYPEf_GET BCM56504_A0_VLAN_PROTOCOLm_ETHERTYPEf_GET
#define VLAN_PROTOCOLm_ETHERTYPEf_SET BCM56504_A0_VLAN_PROTOCOLm_ETHERTYPEf_SET
#define VLAN_PROTOCOLm_LLCf_GET BCM56504_A0_VLAN_PROTOCOLm_LLCf_GET
#define VLAN_PROTOCOLm_LLCf_SET BCM56504_A0_VLAN_PROTOCOLm_LLCf_SET
#define VLAN_PROTOCOLm_SNAPf_GET BCM56504_A0_VLAN_PROTOCOLm_SNAPf_GET
#define VLAN_PROTOCOLm_SNAPf_SET BCM56504_A0_VLAN_PROTOCOLm_SNAPf_SET
#define VLAN_PROTOCOLm_ETHERIIf_GET BCM56504_A0_VLAN_PROTOCOLm_ETHERIIf_GET
#define VLAN_PROTOCOLm_ETHERIIf_SET BCM56504_A0_VLAN_PROTOCOLm_ETHERIIf_SET
#define VLAN_PROTOCOLm_MATCHLOWERf_GET BCM56504_A0_VLAN_PROTOCOLm_MATCHLOWERf_GET
#define VLAN_PROTOCOLm_MATCHLOWERf_SET BCM56504_A0_VLAN_PROTOCOLm_MATCHLOWERf_SET
#define VLAN_PROTOCOLm_MATCHUPPERf_GET BCM56504_A0_VLAN_PROTOCOLm_MATCHUPPERf_GET
#define VLAN_PROTOCOLm_MATCHUPPERf_SET BCM56504_A0_VLAN_PROTOCOLm_MATCHUPPERf_SET
#define READ_VLAN_PROTOCOLm BCM56504_A0_READ_VLAN_PROTOCOLm
#define WRITE_VLAN_PROTOCOLm BCM56504_A0_WRITE_VLAN_PROTOCOLm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_VLAN_PROTOCOLm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  VLAN_PROTOCOL_DATA
 * BLOCKS:   IPIPE
 * DESC:     Holds data for Protocol-based VLAN substitution
 * SIZE:     15
 * FIELDS:
 *     PRI              Priority field
 *     VLAN_ID          VLAN ID
 *
 ******************************************************************************/
#define BCM56504_A0_VLAN_PROTOCOL_DATAm 0x04710000

#define BCM56504_A0_VLAN_PROTOCOL_DATAm_MIN 0
#define BCM56504_A0_VLAN_PROTOCOL_DATAm_MAX 463
#define BCM56504_A0_VLAN_PROTOCOL_DATAm_CMAX(u) 463
#define BCM56504_A0_VLAN_PROTOCOL_DATAm_SIZE 2

/*
 * This structure should be used to declare and program VLAN_PROTOCOL_DATA.
 *
 */
typedef union BCM56504_A0_VLAN_PROTOCOL_DATAm_s {
	uint32_t v[1];
	uint32_t vlan_protocol_data[1];
	uint32_t _vlan_protocol_data;
} BCM56504_A0_VLAN_PROTOCOL_DATAm_t;

#define BCM56504_A0_VLAN_PROTOCOL_DATAm_CLR(r) (r).vlan_protocol_data[0] = 0
#define BCM56504_A0_VLAN_PROTOCOL_DATAm_SET(r,d) (r).vlan_protocol_data[0] = d
#define BCM56504_A0_VLAN_PROTOCOL_DATAm_GET(r) (r).vlan_protocol_data[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_VLAN_PROTOCOL_DATAm_PRIf_GET(r) (((r).vlan_protocol_data[0]) & 0x7)
#define BCM56504_A0_VLAN_PROTOCOL_DATAm_PRIf_SET(r,f) (r).vlan_protocol_data[0]=(((r).vlan_protocol_data[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM56504_A0_VLAN_PROTOCOL_DATAm_VLAN_IDf_GET(r) ((((r).vlan_protocol_data[0]) >> 3) & 0xfff)
#define BCM56504_A0_VLAN_PROTOCOL_DATAm_VLAN_IDf_SET(r,f) (r).vlan_protocol_data[0]=(((r).vlan_protocol_data[0] & ~((uint32_t)0xfff << 3)) | ((((uint32_t)f) & 0xfff) << 3))

/*
 * These macros can be used to access VLAN_PROTOCOL_DATA.
 *
 */
#define BCM56504_A0_READ_VLAN_PROTOCOL_DATAm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_VLAN_PROTOCOL_DATAm,i,(m._vlan_protocol_data),1)
#define BCM56504_A0_WRITE_VLAN_PROTOCOL_DATAm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_VLAN_PROTOCOL_DATAm,i,&(m._vlan_protocol_data),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_PROTOCOL_DATAm BCM56504_A0_VLAN_PROTOCOL_DATAm
#define VLAN_PROTOCOL_DATAm_MIN BCM56504_A0_VLAN_PROTOCOL_DATAm_MIN
#define VLAN_PROTOCOL_DATAm_MAX BCM56504_A0_VLAN_PROTOCOL_DATAm_MAX
#define VLAN_PROTOCOL_DATAm_CMAX(u) BCM56504_A0_VLAN_PROTOCOL_DATAm_CMAX(u)
#define VLAN_PROTOCOL_DATAm_SIZE BCM56504_A0_VLAN_PROTOCOL_DATAm_SIZE
typedef BCM56504_A0_VLAN_PROTOCOL_DATAm_t VLAN_PROTOCOL_DATAm_t;
#define VLAN_PROTOCOL_DATAm_CLR BCM56504_A0_VLAN_PROTOCOL_DATAm_CLR
#define VLAN_PROTOCOL_DATAm_SET BCM56504_A0_VLAN_PROTOCOL_DATAm_SET
#define VLAN_PROTOCOL_DATAm_GET BCM56504_A0_VLAN_PROTOCOL_DATAm_GET
#define VLAN_PROTOCOL_DATAm_PRIf_GET BCM56504_A0_VLAN_PROTOCOL_DATAm_PRIf_GET
#define VLAN_PROTOCOL_DATAm_PRIf_SET BCM56504_A0_VLAN_PROTOCOL_DATAm_PRIf_SET
#define VLAN_PROTOCOL_DATAm_VLAN_IDf_GET BCM56504_A0_VLAN_PROTOCOL_DATAm_VLAN_IDf_GET
#define VLAN_PROTOCOL_DATAm_VLAN_IDf_SET BCM56504_A0_VLAN_PROTOCOL_DATAm_VLAN_IDf_SET
#define READ_VLAN_PROTOCOL_DATAm BCM56504_A0_READ_VLAN_PROTOCOL_DATAm
#define WRITE_VLAN_PROTOCOL_DATAm BCM56504_A0_WRITE_VLAN_PROTOCOL_DATAm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_VLAN_PROTOCOL_DATAm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  VLAN_SUBNET
 * BLOCKS:   IPIPE
 * DESC:     TCAM for IP subnet based VLAN substitution
 * SIZE:     144
 * FIELDS:
 *     VALID            IP Subnet mask
 *     IP_ADDR          IP Address key
 *     MASK             IP Subnet mask
 *     PRI              Priority field
 *     VLAN_ID          VLAN ID
 *
 ******************************************************************************/
#define BCM56504_A0_VLAN_SUBNETm 0x04720000

#define BCM56504_A0_VLAN_SUBNETm_MIN 0
#define BCM56504_A0_VLAN_SUBNETm_MAX 255
#define BCM56504_A0_VLAN_SUBNETm_CMAX(u) 255
#define BCM56504_A0_VLAN_SUBNETm_SIZE 18

/*
 * This structure should be used to declare and program VLAN_SUBNET.
 *
 */
typedef union BCM56504_A0_VLAN_SUBNETm_s {
	uint32_t v[5];
	uint32_t vlan_subnet[5];
	uint32_t _vlan_subnet;
} BCM56504_A0_VLAN_SUBNETm_t;

#define BCM56504_A0_VLAN_SUBNETm_CLR(r) CDK_MEMSET(&((r)._vlan_subnet), 0, sizeof(BCM56504_A0_VLAN_SUBNETm_t))
#define BCM56504_A0_VLAN_SUBNETm_SET(r,i,d) (r).vlan_subnet[i] = d
#define BCM56504_A0_VLAN_SUBNETm_GET(r,i) (r).vlan_subnet[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_VLAN_SUBNETm_VALIDf_GET(r) (((r).vlan_subnet[0]) & 0x1)
#define BCM56504_A0_VLAN_SUBNETm_VALIDf_SET(r,f) (r).vlan_subnet[0]=(((r).vlan_subnet[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_VLAN_SUBNETm_IP_ADDRf_GET(r,a) cdk_field_get((r).vlan_subnet,1,64,a)
#define BCM56504_A0_VLAN_SUBNETm_IP_ADDRf_SET(r,a) cdk_field_set((r).vlan_subnet,1,64,a)
#define BCM56504_A0_VLAN_SUBNETm_MASKf_GET(r,a) cdk_field_get((r).vlan_subnet,65,128,a)
#define BCM56504_A0_VLAN_SUBNETm_MASKf_SET(r,a) cdk_field_set((r).vlan_subnet,65,128,a)
#define BCM56504_A0_VLAN_SUBNETm_PRIf_GET(r) ((((r).vlan_subnet[4]) >> 1) & 0x7)
#define BCM56504_A0_VLAN_SUBNETm_PRIf_SET(r,f) (r).vlan_subnet[4]=(((r).vlan_subnet[4] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define BCM56504_A0_VLAN_SUBNETm_VLAN_IDf_GET(r) ((((r).vlan_subnet[4]) >> 4) & 0xfff)
#define BCM56504_A0_VLAN_SUBNETm_VLAN_IDf_SET(r,f) (r).vlan_subnet[4]=(((r).vlan_subnet[4] & ~((uint32_t)0xfff << 4)) | ((((uint32_t)f) & 0xfff) << 4))

/*
 * These macros can be used to access VLAN_SUBNET.
 *
 */
#define BCM56504_A0_READ_VLAN_SUBNETm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_VLAN_SUBNETm,i,(m._vlan_subnet),5)
#define BCM56504_A0_WRITE_VLAN_SUBNETm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_VLAN_SUBNETm,i,&(m._vlan_subnet),5)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_SUBNETm BCM56504_A0_VLAN_SUBNETm
#define VLAN_SUBNETm_MIN BCM56504_A0_VLAN_SUBNETm_MIN
#define VLAN_SUBNETm_MAX BCM56504_A0_VLAN_SUBNETm_MAX
#define VLAN_SUBNETm_CMAX(u) BCM56504_A0_VLAN_SUBNETm_CMAX(u)
#define VLAN_SUBNETm_SIZE BCM56504_A0_VLAN_SUBNETm_SIZE
typedef BCM56504_A0_VLAN_SUBNETm_t VLAN_SUBNETm_t;
#define VLAN_SUBNETm_CLR BCM56504_A0_VLAN_SUBNETm_CLR
#define VLAN_SUBNETm_SET BCM56504_A0_VLAN_SUBNETm_SET
#define VLAN_SUBNETm_GET BCM56504_A0_VLAN_SUBNETm_GET
#define VLAN_SUBNETm_VALIDf_GET BCM56504_A0_VLAN_SUBNETm_VALIDf_GET
#define VLAN_SUBNETm_VALIDf_SET BCM56504_A0_VLAN_SUBNETm_VALIDf_SET
#define VLAN_SUBNETm_IP_ADDRf_GET BCM56504_A0_VLAN_SUBNETm_IP_ADDRf_GET
#define VLAN_SUBNETm_IP_ADDRf_SET BCM56504_A0_VLAN_SUBNETm_IP_ADDRf_SET
#define VLAN_SUBNETm_MASKf_GET BCM56504_A0_VLAN_SUBNETm_MASKf_GET
#define VLAN_SUBNETm_MASKf_SET BCM56504_A0_VLAN_SUBNETm_MASKf_SET
#define VLAN_SUBNETm_PRIf_GET BCM56504_A0_VLAN_SUBNETm_PRIf_GET
#define VLAN_SUBNETm_PRIf_SET BCM56504_A0_VLAN_SUBNETm_PRIf_SET
#define VLAN_SUBNETm_VLAN_IDf_GET BCM56504_A0_VLAN_SUBNETm_VLAN_IDf_GET
#define VLAN_SUBNETm_VLAN_IDf_SET BCM56504_A0_VLAN_SUBNETm_VLAN_IDf_SET
#define READ_VLAN_SUBNETm BCM56504_A0_READ_VLAN_SUBNETm
#define WRITE_VLAN_SUBNETm BCM56504_A0_WRITE_VLAN_SUBNETm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_VLAN_SUBNETm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  VLAN_SUBNET_CAM_BIST_S10_STATUS
 * BLOCKS:   IPIPE
 * DESC:     VLAN_SUBNET_CAM_BIST_S10_STATUS
 * SIZE:     32
 * FIELDS:
 *     MATCH_STATUS     Match status
 *     AINDEX           Aindex when match happened
 *
 ******************************************************************************/
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S10_STATUSr 0x04780007

#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S10_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program VLAN_SUBNET_CAM_BIST_S10_STATUS.
 *
 */
typedef union BCM56504_A0_VLAN_SUBNET_CAM_BIST_S10_STATUSr_s {
	uint32_t v[1];
	uint32_t vlan_subnet_cam_bist_s10_status[1];
	uint32_t _vlan_subnet_cam_bist_s10_status;
} BCM56504_A0_VLAN_SUBNET_CAM_BIST_S10_STATUSr_t;

#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S10_STATUSr_CLR(r) (r).vlan_subnet_cam_bist_s10_status[0] = 0
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S10_STATUSr_SET(r,d) (r).vlan_subnet_cam_bist_s10_status[0] = d
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S10_STATUSr_GET(r) (r).vlan_subnet_cam_bist_s10_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S10_STATUSr_MATCH_STATUSf_GET(r) (((r).vlan_subnet_cam_bist_s10_status[0]) & 0x1)
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S10_STATUSr_MATCH_STATUSf_SET(r,f) (r).vlan_subnet_cam_bist_s10_status[0]=(((r).vlan_subnet_cam_bist_s10_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S10_STATUSr_AINDEXf_GET(r) ((((r).vlan_subnet_cam_bist_s10_status[0]) >> 1) & 0x7f)
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S10_STATUSr_AINDEXf_SET(r,f) (r).vlan_subnet_cam_bist_s10_status[0]=(((r).vlan_subnet_cam_bist_s10_status[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))

/*
 * These macros can be used to access VLAN_SUBNET_CAM_BIST_S10_STATUS.
 *
 */
#define BCM56504_A0_READ_VLAN_SUBNET_CAM_BIST_S10_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_VLAN_SUBNET_CAM_BIST_S10_STATUSr,(r._vlan_subnet_cam_bist_s10_status))
#define BCM56504_A0_WRITE_VLAN_SUBNET_CAM_BIST_S10_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_VLAN_SUBNET_CAM_BIST_S10_STATUSr,&(r._vlan_subnet_cam_bist_s10_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_SUBNET_CAM_BIST_S10_STATUSr BCM56504_A0_VLAN_SUBNET_CAM_BIST_S10_STATUSr
#define VLAN_SUBNET_CAM_BIST_S10_STATUSr_SIZE BCM56504_A0_VLAN_SUBNET_CAM_BIST_S10_STATUSr_SIZE
typedef BCM56504_A0_VLAN_SUBNET_CAM_BIST_S10_STATUSr_t VLAN_SUBNET_CAM_BIST_S10_STATUSr_t;
#define VLAN_SUBNET_CAM_BIST_S10_STATUSr_CLR BCM56504_A0_VLAN_SUBNET_CAM_BIST_S10_STATUSr_CLR
#define VLAN_SUBNET_CAM_BIST_S10_STATUSr_SET BCM56504_A0_VLAN_SUBNET_CAM_BIST_S10_STATUSr_SET
#define VLAN_SUBNET_CAM_BIST_S10_STATUSr_GET BCM56504_A0_VLAN_SUBNET_CAM_BIST_S10_STATUSr_GET
#define VLAN_SUBNET_CAM_BIST_S10_STATUSr_MATCH_STATUSf_GET BCM56504_A0_VLAN_SUBNET_CAM_BIST_S10_STATUSr_MATCH_STATUSf_GET
#define VLAN_SUBNET_CAM_BIST_S10_STATUSr_MATCH_STATUSf_SET BCM56504_A0_VLAN_SUBNET_CAM_BIST_S10_STATUSr_MATCH_STATUSf_SET
#define VLAN_SUBNET_CAM_BIST_S10_STATUSr_AINDEXf_GET BCM56504_A0_VLAN_SUBNET_CAM_BIST_S10_STATUSr_AINDEXf_GET
#define VLAN_SUBNET_CAM_BIST_S10_STATUSr_AINDEXf_SET BCM56504_A0_VLAN_SUBNET_CAM_BIST_S10_STATUSr_AINDEXf_SET
#define READ_VLAN_SUBNET_CAM_BIST_S10_STATUSr BCM56504_A0_READ_VLAN_SUBNET_CAM_BIST_S10_STATUSr
#define WRITE_VLAN_SUBNET_CAM_BIST_S10_STATUSr BCM56504_A0_WRITE_VLAN_SUBNET_CAM_BIST_S10_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_VLAN_SUBNET_CAM_BIST_S10_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  VLAN_SUBNET_CAM_BIST_S2_STATUS
 * BLOCKS:   IPIPE
 * DESC:     VLAN_SUBNET_CAM_BIST_S2_STATUS
 * SIZE:     32
 * FIELDS:
 *     MATCH_STATUS     Match status
 *     BIT_POS          Sliding Bit position when match happened
 *     AINDEX           Aindex when match happened
 *
 ******************************************************************************/
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr 0x04780002

#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program VLAN_SUBNET_CAM_BIST_S2_STATUS.
 *
 */
typedef union BCM56504_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr_s {
	uint32_t v[1];
	uint32_t vlan_subnet_cam_bist_s2_status[1];
	uint32_t _vlan_subnet_cam_bist_s2_status;
} BCM56504_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr_t;

#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr_CLR(r) (r).vlan_subnet_cam_bist_s2_status[0] = 0
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr_SET(r,d) (r).vlan_subnet_cam_bist_s2_status[0] = d
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr_GET(r) (r).vlan_subnet_cam_bist_s2_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr_MATCH_STATUSf_GET(r) (((r).vlan_subnet_cam_bist_s2_status[0]) & 0x1)
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr_MATCH_STATUSf_SET(r,f) (r).vlan_subnet_cam_bist_s2_status[0]=(((r).vlan_subnet_cam_bist_s2_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr_BIT_POSf_GET(r) ((((r).vlan_subnet_cam_bist_s2_status[0]) >> 1) & 0x7f)
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr_BIT_POSf_SET(r,f) (r).vlan_subnet_cam_bist_s2_status[0]=(((r).vlan_subnet_cam_bist_s2_status[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr_AINDEXf_GET(r) ((((r).vlan_subnet_cam_bist_s2_status[0]) >> 8) & 0x7f)
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr_AINDEXf_SET(r,f) (r).vlan_subnet_cam_bist_s2_status[0]=(((r).vlan_subnet_cam_bist_s2_status[0] & ~((uint32_t)0x7f << 8)) | ((((uint32_t)f) & 0x7f) << 8))

/*
 * These macros can be used to access VLAN_SUBNET_CAM_BIST_S2_STATUS.
 *
 */
#define BCM56504_A0_READ_VLAN_SUBNET_CAM_BIST_S2_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr,(r._vlan_subnet_cam_bist_s2_status))
#define BCM56504_A0_WRITE_VLAN_SUBNET_CAM_BIST_S2_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr,&(r._vlan_subnet_cam_bist_s2_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_SUBNET_CAM_BIST_S2_STATUSr BCM56504_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr
#define VLAN_SUBNET_CAM_BIST_S2_STATUSr_SIZE BCM56504_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr_SIZE
typedef BCM56504_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr_t VLAN_SUBNET_CAM_BIST_S2_STATUSr_t;
#define VLAN_SUBNET_CAM_BIST_S2_STATUSr_CLR BCM56504_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr_CLR
#define VLAN_SUBNET_CAM_BIST_S2_STATUSr_SET BCM56504_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr_SET
#define VLAN_SUBNET_CAM_BIST_S2_STATUSr_GET BCM56504_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr_GET
#define VLAN_SUBNET_CAM_BIST_S2_STATUSr_MATCH_STATUSf_GET BCM56504_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr_MATCH_STATUSf_GET
#define VLAN_SUBNET_CAM_BIST_S2_STATUSr_MATCH_STATUSf_SET BCM56504_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr_MATCH_STATUSf_SET
#define VLAN_SUBNET_CAM_BIST_S2_STATUSr_BIT_POSf_GET BCM56504_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr_BIT_POSf_GET
#define VLAN_SUBNET_CAM_BIST_S2_STATUSr_BIT_POSf_SET BCM56504_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr_BIT_POSf_SET
#define VLAN_SUBNET_CAM_BIST_S2_STATUSr_AINDEXf_GET BCM56504_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr_AINDEXf_GET
#define VLAN_SUBNET_CAM_BIST_S2_STATUSr_AINDEXf_SET BCM56504_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr_AINDEXf_SET
#define READ_VLAN_SUBNET_CAM_BIST_S2_STATUSr BCM56504_A0_READ_VLAN_SUBNET_CAM_BIST_S2_STATUSr
#define WRITE_VLAN_SUBNET_CAM_BIST_S2_STATUSr BCM56504_A0_WRITE_VLAN_SUBNET_CAM_BIST_S2_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  VLAN_SUBNET_CAM_BIST_S3_STATUS
 * BLOCKS:   IPIPE
 * DESC:     VLAN_SUBNET_CAM_BIST_S3_STATUS
 * SIZE:     32
 * FIELDS:
 *     MATCH_STATUS     Match status
 *     AINDEX_STATUS    AIndex status
 *     ACTUAL_AINDEX    Actual AIndex when CAM reported a match
 *     EXPECTED_AINDEX  Expected AIndex
 *
 ******************************************************************************/
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr 0x04780003

#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program VLAN_SUBNET_CAM_BIST_S3_STATUS.
 *
 */
typedef union BCM56504_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr_s {
	uint32_t v[1];
	uint32_t vlan_subnet_cam_bist_s3_status[1];
	uint32_t _vlan_subnet_cam_bist_s3_status;
} BCM56504_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr_t;

#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr_CLR(r) (r).vlan_subnet_cam_bist_s3_status[0] = 0
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr_SET(r,d) (r).vlan_subnet_cam_bist_s3_status[0] = d
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr_GET(r) (r).vlan_subnet_cam_bist_s3_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr_MATCH_STATUSf_GET(r) (((r).vlan_subnet_cam_bist_s3_status[0]) & 0x1)
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr_MATCH_STATUSf_SET(r,f) (r).vlan_subnet_cam_bist_s3_status[0]=(((r).vlan_subnet_cam_bist_s3_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr_AINDEX_STATUSf_GET(r) ((((r).vlan_subnet_cam_bist_s3_status[0]) >> 1) & 0x1)
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr_AINDEX_STATUSf_SET(r,f) (r).vlan_subnet_cam_bist_s3_status[0]=(((r).vlan_subnet_cam_bist_s3_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr_ACTUAL_AINDEXf_GET(r) ((((r).vlan_subnet_cam_bist_s3_status[0]) >> 2) & 0x7f)
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr_ACTUAL_AINDEXf_SET(r,f) (r).vlan_subnet_cam_bist_s3_status[0]=(((r).vlan_subnet_cam_bist_s3_status[0] & ~((uint32_t)0x7f << 2)) | ((((uint32_t)f) & 0x7f) << 2))
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr_EXPECTED_AINDEXf_GET(r) ((((r).vlan_subnet_cam_bist_s3_status[0]) >> 9) & 0x7f)
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr_EXPECTED_AINDEXf_SET(r,f) (r).vlan_subnet_cam_bist_s3_status[0]=(((r).vlan_subnet_cam_bist_s3_status[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access VLAN_SUBNET_CAM_BIST_S3_STATUS.
 *
 */
#define BCM56504_A0_READ_VLAN_SUBNET_CAM_BIST_S3_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr,(r._vlan_subnet_cam_bist_s3_status))
#define BCM56504_A0_WRITE_VLAN_SUBNET_CAM_BIST_S3_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr,&(r._vlan_subnet_cam_bist_s3_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_SUBNET_CAM_BIST_S3_STATUSr BCM56504_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr
#define VLAN_SUBNET_CAM_BIST_S3_STATUSr_SIZE BCM56504_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr_SIZE
typedef BCM56504_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr_t VLAN_SUBNET_CAM_BIST_S3_STATUSr_t;
#define VLAN_SUBNET_CAM_BIST_S3_STATUSr_CLR BCM56504_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr_CLR
#define VLAN_SUBNET_CAM_BIST_S3_STATUSr_SET BCM56504_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr_SET
#define VLAN_SUBNET_CAM_BIST_S3_STATUSr_GET BCM56504_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr_GET
#define VLAN_SUBNET_CAM_BIST_S3_STATUSr_MATCH_STATUSf_GET BCM56504_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr_MATCH_STATUSf_GET
#define VLAN_SUBNET_CAM_BIST_S3_STATUSr_MATCH_STATUSf_SET BCM56504_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr_MATCH_STATUSf_SET
#define VLAN_SUBNET_CAM_BIST_S3_STATUSr_AINDEX_STATUSf_GET BCM56504_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr_AINDEX_STATUSf_GET
#define VLAN_SUBNET_CAM_BIST_S3_STATUSr_AINDEX_STATUSf_SET BCM56504_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr_AINDEX_STATUSf_SET
#define VLAN_SUBNET_CAM_BIST_S3_STATUSr_ACTUAL_AINDEXf_GET BCM56504_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr_ACTUAL_AINDEXf_GET
#define VLAN_SUBNET_CAM_BIST_S3_STATUSr_ACTUAL_AINDEXf_SET BCM56504_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr_ACTUAL_AINDEXf_SET
#define VLAN_SUBNET_CAM_BIST_S3_STATUSr_EXPECTED_AINDEXf_GET BCM56504_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr_EXPECTED_AINDEXf_GET
#define VLAN_SUBNET_CAM_BIST_S3_STATUSr_EXPECTED_AINDEXf_SET BCM56504_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr_EXPECTED_AINDEXf_SET
#define READ_VLAN_SUBNET_CAM_BIST_S3_STATUSr BCM56504_A0_READ_VLAN_SUBNET_CAM_BIST_S3_STATUSr
#define WRITE_VLAN_SUBNET_CAM_BIST_S3_STATUSr BCM56504_A0_WRITE_VLAN_SUBNET_CAM_BIST_S3_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  VLAN_SUBNET_CAM_BIST_S5_STATUS
 * BLOCKS:   IPIPE
 * DESC:     VLAN_SUBNET_CAM_BIST_S5_STATUS
 * SIZE:     32
 * FIELDS:
 *     MATCH_STATUS     Match status
 *     BIT_POS          Sliding Bit position when match happened
 *     AINDEX           Aindex when match happened
 *
 ******************************************************************************/
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr 0x04780004

#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program VLAN_SUBNET_CAM_BIST_S5_STATUS.
 *
 */
typedef union BCM56504_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr_s {
	uint32_t v[1];
	uint32_t vlan_subnet_cam_bist_s5_status[1];
	uint32_t _vlan_subnet_cam_bist_s5_status;
} BCM56504_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr_t;

#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr_CLR(r) (r).vlan_subnet_cam_bist_s5_status[0] = 0
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr_SET(r,d) (r).vlan_subnet_cam_bist_s5_status[0] = d
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr_GET(r) (r).vlan_subnet_cam_bist_s5_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr_MATCH_STATUSf_GET(r) (((r).vlan_subnet_cam_bist_s5_status[0]) & 0x1)
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr_MATCH_STATUSf_SET(r,f) (r).vlan_subnet_cam_bist_s5_status[0]=(((r).vlan_subnet_cam_bist_s5_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr_BIT_POSf_GET(r) ((((r).vlan_subnet_cam_bist_s5_status[0]) >> 1) & 0x7f)
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr_BIT_POSf_SET(r,f) (r).vlan_subnet_cam_bist_s5_status[0]=(((r).vlan_subnet_cam_bist_s5_status[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr_AINDEXf_GET(r) ((((r).vlan_subnet_cam_bist_s5_status[0]) >> 8) & 0x7f)
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr_AINDEXf_SET(r,f) (r).vlan_subnet_cam_bist_s5_status[0]=(((r).vlan_subnet_cam_bist_s5_status[0] & ~((uint32_t)0x7f << 8)) | ((((uint32_t)f) & 0x7f) << 8))

/*
 * These macros can be used to access VLAN_SUBNET_CAM_BIST_S5_STATUS.
 *
 */
#define BCM56504_A0_READ_VLAN_SUBNET_CAM_BIST_S5_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr,(r._vlan_subnet_cam_bist_s5_status))
#define BCM56504_A0_WRITE_VLAN_SUBNET_CAM_BIST_S5_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr,&(r._vlan_subnet_cam_bist_s5_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_SUBNET_CAM_BIST_S5_STATUSr BCM56504_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr
#define VLAN_SUBNET_CAM_BIST_S5_STATUSr_SIZE BCM56504_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr_SIZE
typedef BCM56504_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr_t VLAN_SUBNET_CAM_BIST_S5_STATUSr_t;
#define VLAN_SUBNET_CAM_BIST_S5_STATUSr_CLR BCM56504_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr_CLR
#define VLAN_SUBNET_CAM_BIST_S5_STATUSr_SET BCM56504_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr_SET
#define VLAN_SUBNET_CAM_BIST_S5_STATUSr_GET BCM56504_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr_GET
#define VLAN_SUBNET_CAM_BIST_S5_STATUSr_MATCH_STATUSf_GET BCM56504_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr_MATCH_STATUSf_GET
#define VLAN_SUBNET_CAM_BIST_S5_STATUSr_MATCH_STATUSf_SET BCM56504_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr_MATCH_STATUSf_SET
#define VLAN_SUBNET_CAM_BIST_S5_STATUSr_BIT_POSf_GET BCM56504_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr_BIT_POSf_GET
#define VLAN_SUBNET_CAM_BIST_S5_STATUSr_BIT_POSf_SET BCM56504_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr_BIT_POSf_SET
#define VLAN_SUBNET_CAM_BIST_S5_STATUSr_AINDEXf_GET BCM56504_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr_AINDEXf_GET
#define VLAN_SUBNET_CAM_BIST_S5_STATUSr_AINDEXf_SET BCM56504_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr_AINDEXf_SET
#define READ_VLAN_SUBNET_CAM_BIST_S5_STATUSr BCM56504_A0_READ_VLAN_SUBNET_CAM_BIST_S5_STATUSr
#define WRITE_VLAN_SUBNET_CAM_BIST_S5_STATUSr BCM56504_A0_WRITE_VLAN_SUBNET_CAM_BIST_S5_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  VLAN_SUBNET_CAM_BIST_S6_STATUS
 * BLOCKS:   IPIPE
 * DESC:     VLAN_SUBNET_CAM_BIST_S6_STATUS
 * SIZE:     32
 * FIELDS:
 *     MATCH_STATUS     Match status
 *     AINDEX_STATUS    AIndex status
 *     ACTUAL_AINDEX    Actual AIndex when CAM reported a match
 *     EXPECTED_AINDEX  Expected AIndex
 *
 ******************************************************************************/
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr 0x04780005

#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program VLAN_SUBNET_CAM_BIST_S6_STATUS.
 *
 */
typedef union BCM56504_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr_s {
	uint32_t v[1];
	uint32_t vlan_subnet_cam_bist_s6_status[1];
	uint32_t _vlan_subnet_cam_bist_s6_status;
} BCM56504_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr_t;

#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr_CLR(r) (r).vlan_subnet_cam_bist_s6_status[0] = 0
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr_SET(r,d) (r).vlan_subnet_cam_bist_s6_status[0] = d
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr_GET(r) (r).vlan_subnet_cam_bist_s6_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr_MATCH_STATUSf_GET(r) (((r).vlan_subnet_cam_bist_s6_status[0]) & 0x1)
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr_MATCH_STATUSf_SET(r,f) (r).vlan_subnet_cam_bist_s6_status[0]=(((r).vlan_subnet_cam_bist_s6_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr_AINDEX_STATUSf_GET(r) ((((r).vlan_subnet_cam_bist_s6_status[0]) >> 1) & 0x1)
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr_AINDEX_STATUSf_SET(r,f) (r).vlan_subnet_cam_bist_s6_status[0]=(((r).vlan_subnet_cam_bist_s6_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr_ACTUAL_AINDEXf_GET(r) ((((r).vlan_subnet_cam_bist_s6_status[0]) >> 2) & 0x7f)
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr_ACTUAL_AINDEXf_SET(r,f) (r).vlan_subnet_cam_bist_s6_status[0]=(((r).vlan_subnet_cam_bist_s6_status[0] & ~((uint32_t)0x7f << 2)) | ((((uint32_t)f) & 0x7f) << 2))
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr_EXPECTED_AINDEXf_GET(r) ((((r).vlan_subnet_cam_bist_s6_status[0]) >> 9) & 0x7f)
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr_EXPECTED_AINDEXf_SET(r,f) (r).vlan_subnet_cam_bist_s6_status[0]=(((r).vlan_subnet_cam_bist_s6_status[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access VLAN_SUBNET_CAM_BIST_S6_STATUS.
 *
 */
#define BCM56504_A0_READ_VLAN_SUBNET_CAM_BIST_S6_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr,(r._vlan_subnet_cam_bist_s6_status))
#define BCM56504_A0_WRITE_VLAN_SUBNET_CAM_BIST_S6_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr,&(r._vlan_subnet_cam_bist_s6_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_SUBNET_CAM_BIST_S6_STATUSr BCM56504_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr
#define VLAN_SUBNET_CAM_BIST_S6_STATUSr_SIZE BCM56504_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr_SIZE
typedef BCM56504_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr_t VLAN_SUBNET_CAM_BIST_S6_STATUSr_t;
#define VLAN_SUBNET_CAM_BIST_S6_STATUSr_CLR BCM56504_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr_CLR
#define VLAN_SUBNET_CAM_BIST_S6_STATUSr_SET BCM56504_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr_SET
#define VLAN_SUBNET_CAM_BIST_S6_STATUSr_GET BCM56504_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr_GET
#define VLAN_SUBNET_CAM_BIST_S6_STATUSr_MATCH_STATUSf_GET BCM56504_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr_MATCH_STATUSf_GET
#define VLAN_SUBNET_CAM_BIST_S6_STATUSr_MATCH_STATUSf_SET BCM56504_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr_MATCH_STATUSf_SET
#define VLAN_SUBNET_CAM_BIST_S6_STATUSr_AINDEX_STATUSf_GET BCM56504_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr_AINDEX_STATUSf_GET
#define VLAN_SUBNET_CAM_BIST_S6_STATUSr_AINDEX_STATUSf_SET BCM56504_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr_AINDEX_STATUSf_SET
#define VLAN_SUBNET_CAM_BIST_S6_STATUSr_ACTUAL_AINDEXf_GET BCM56504_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr_ACTUAL_AINDEXf_GET
#define VLAN_SUBNET_CAM_BIST_S6_STATUSr_ACTUAL_AINDEXf_SET BCM56504_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr_ACTUAL_AINDEXf_SET
#define VLAN_SUBNET_CAM_BIST_S6_STATUSr_EXPECTED_AINDEXf_GET BCM56504_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr_EXPECTED_AINDEXf_GET
#define VLAN_SUBNET_CAM_BIST_S6_STATUSr_EXPECTED_AINDEXf_SET BCM56504_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr_EXPECTED_AINDEXf_SET
#define READ_VLAN_SUBNET_CAM_BIST_S6_STATUSr BCM56504_A0_READ_VLAN_SUBNET_CAM_BIST_S6_STATUSr
#define WRITE_VLAN_SUBNET_CAM_BIST_S6_STATUSr BCM56504_A0_WRITE_VLAN_SUBNET_CAM_BIST_S6_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  VLAN_SUBNET_CAM_BIST_S8_STATUS
 * BLOCKS:   IPIPE
 * DESC:     VLAN_SUBNET_CAM_BIST_S8_STATUS
 * SIZE:     32
 * FIELDS:
 *     MATCH_STATUS     Match status
 *     AINDEX_STATUS    AIndex status
 *     ACTUAL_AINDEX    Actual AIndex when CAM reported a match
 *     EXPECTED_AINDEX  Expected AIndex
 *
 ******************************************************************************/
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr 0x04780006

#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program VLAN_SUBNET_CAM_BIST_S8_STATUS.
 *
 */
typedef union BCM56504_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr_s {
	uint32_t v[1];
	uint32_t vlan_subnet_cam_bist_s8_status[1];
	uint32_t _vlan_subnet_cam_bist_s8_status;
} BCM56504_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr_t;

#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr_CLR(r) (r).vlan_subnet_cam_bist_s8_status[0] = 0
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr_SET(r,d) (r).vlan_subnet_cam_bist_s8_status[0] = d
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr_GET(r) (r).vlan_subnet_cam_bist_s8_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr_MATCH_STATUSf_GET(r) (((r).vlan_subnet_cam_bist_s8_status[0]) & 0x1)
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr_MATCH_STATUSf_SET(r,f) (r).vlan_subnet_cam_bist_s8_status[0]=(((r).vlan_subnet_cam_bist_s8_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr_AINDEX_STATUSf_GET(r) ((((r).vlan_subnet_cam_bist_s8_status[0]) >> 1) & 0x1)
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr_AINDEX_STATUSf_SET(r,f) (r).vlan_subnet_cam_bist_s8_status[0]=(((r).vlan_subnet_cam_bist_s8_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr_ACTUAL_AINDEXf_GET(r) ((((r).vlan_subnet_cam_bist_s8_status[0]) >> 2) & 0x7f)
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr_ACTUAL_AINDEXf_SET(r,f) (r).vlan_subnet_cam_bist_s8_status[0]=(((r).vlan_subnet_cam_bist_s8_status[0] & ~((uint32_t)0x7f << 2)) | ((((uint32_t)f) & 0x7f) << 2))
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr_EXPECTED_AINDEXf_GET(r) ((((r).vlan_subnet_cam_bist_s8_status[0]) >> 9) & 0x7f)
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr_EXPECTED_AINDEXf_SET(r,f) (r).vlan_subnet_cam_bist_s8_status[0]=(((r).vlan_subnet_cam_bist_s8_status[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access VLAN_SUBNET_CAM_BIST_S8_STATUS.
 *
 */
#define BCM56504_A0_READ_VLAN_SUBNET_CAM_BIST_S8_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr,(r._vlan_subnet_cam_bist_s8_status))
#define BCM56504_A0_WRITE_VLAN_SUBNET_CAM_BIST_S8_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr,&(r._vlan_subnet_cam_bist_s8_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_SUBNET_CAM_BIST_S8_STATUSr BCM56504_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr
#define VLAN_SUBNET_CAM_BIST_S8_STATUSr_SIZE BCM56504_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr_SIZE
typedef BCM56504_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr_t VLAN_SUBNET_CAM_BIST_S8_STATUSr_t;
#define VLAN_SUBNET_CAM_BIST_S8_STATUSr_CLR BCM56504_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr_CLR
#define VLAN_SUBNET_CAM_BIST_S8_STATUSr_SET BCM56504_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr_SET
#define VLAN_SUBNET_CAM_BIST_S8_STATUSr_GET BCM56504_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr_GET
#define VLAN_SUBNET_CAM_BIST_S8_STATUSr_MATCH_STATUSf_GET BCM56504_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr_MATCH_STATUSf_GET
#define VLAN_SUBNET_CAM_BIST_S8_STATUSr_MATCH_STATUSf_SET BCM56504_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr_MATCH_STATUSf_SET
#define VLAN_SUBNET_CAM_BIST_S8_STATUSr_AINDEX_STATUSf_GET BCM56504_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr_AINDEX_STATUSf_GET
#define VLAN_SUBNET_CAM_BIST_S8_STATUSr_AINDEX_STATUSf_SET BCM56504_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr_AINDEX_STATUSf_SET
#define VLAN_SUBNET_CAM_BIST_S8_STATUSr_ACTUAL_AINDEXf_GET BCM56504_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr_ACTUAL_AINDEXf_GET
#define VLAN_SUBNET_CAM_BIST_S8_STATUSr_ACTUAL_AINDEXf_SET BCM56504_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr_ACTUAL_AINDEXf_SET
#define VLAN_SUBNET_CAM_BIST_S8_STATUSr_EXPECTED_AINDEXf_GET BCM56504_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr_EXPECTED_AINDEXf_GET
#define VLAN_SUBNET_CAM_BIST_S8_STATUSr_EXPECTED_AINDEXf_SET BCM56504_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr_EXPECTED_AINDEXf_SET
#define READ_VLAN_SUBNET_CAM_BIST_S8_STATUSr BCM56504_A0_READ_VLAN_SUBNET_CAM_BIST_S8_STATUSr
#define WRITE_VLAN_SUBNET_CAM_BIST_S8_STATUSr BCM56504_A0_WRITE_VLAN_SUBNET_CAM_BIST_S8_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  VLAN_SUBNET_CAM_BIST_STATUS
 * BLOCKS:   IPIPE
 * DESC:     VLAN_SUBNET_CAM_BIST_STATUS
 * SIZE:     32
 * FIELDS:
 *     BIST_GO          BIST pass/fail flag (1->pass)
 *     BIST_DONE        Inicates if the BIST has completed
 *
 ******************************************************************************/
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_STATUSr 0x04780001

#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program VLAN_SUBNET_CAM_BIST_STATUS.
 *
 */
typedef union BCM56504_A0_VLAN_SUBNET_CAM_BIST_STATUSr_s {
	uint32_t v[1];
	uint32_t vlan_subnet_cam_bist_status[1];
	uint32_t _vlan_subnet_cam_bist_status;
} BCM56504_A0_VLAN_SUBNET_CAM_BIST_STATUSr_t;

#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_STATUSr_CLR(r) (r).vlan_subnet_cam_bist_status[0] = 0
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_STATUSr_SET(r,d) (r).vlan_subnet_cam_bist_status[0] = d
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_STATUSr_GET(r) (r).vlan_subnet_cam_bist_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_STATUSr_BIST_GOf_GET(r) (((r).vlan_subnet_cam_bist_status[0]) & 0x1)
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_STATUSr_BIST_GOf_SET(r,f) (r).vlan_subnet_cam_bist_status[0]=(((r).vlan_subnet_cam_bist_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_STATUSr_BIST_DONEf_GET(r) ((((r).vlan_subnet_cam_bist_status[0]) >> 1) & 0x1)
#define BCM56504_A0_VLAN_SUBNET_CAM_BIST_STATUSr_BIST_DONEf_SET(r,f) (r).vlan_subnet_cam_bist_status[0]=(((r).vlan_subnet_cam_bist_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access VLAN_SUBNET_CAM_BIST_STATUS.
 *
 */
#define BCM56504_A0_READ_VLAN_SUBNET_CAM_BIST_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_VLAN_SUBNET_CAM_BIST_STATUSr,(r._vlan_subnet_cam_bist_status))
#define BCM56504_A0_WRITE_VLAN_SUBNET_CAM_BIST_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_VLAN_SUBNET_CAM_BIST_STATUSr,&(r._vlan_subnet_cam_bist_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_SUBNET_CAM_BIST_STATUSr BCM56504_A0_VLAN_SUBNET_CAM_BIST_STATUSr
#define VLAN_SUBNET_CAM_BIST_STATUSr_SIZE BCM56504_A0_VLAN_SUBNET_CAM_BIST_STATUSr_SIZE
typedef BCM56504_A0_VLAN_SUBNET_CAM_BIST_STATUSr_t VLAN_SUBNET_CAM_BIST_STATUSr_t;
#define VLAN_SUBNET_CAM_BIST_STATUSr_CLR BCM56504_A0_VLAN_SUBNET_CAM_BIST_STATUSr_CLR
#define VLAN_SUBNET_CAM_BIST_STATUSr_SET BCM56504_A0_VLAN_SUBNET_CAM_BIST_STATUSr_SET
#define VLAN_SUBNET_CAM_BIST_STATUSr_GET BCM56504_A0_VLAN_SUBNET_CAM_BIST_STATUSr_GET
#define VLAN_SUBNET_CAM_BIST_STATUSr_BIST_GOf_GET BCM56504_A0_VLAN_SUBNET_CAM_BIST_STATUSr_BIST_GOf_GET
#define VLAN_SUBNET_CAM_BIST_STATUSr_BIST_GOf_SET BCM56504_A0_VLAN_SUBNET_CAM_BIST_STATUSr_BIST_GOf_SET
#define VLAN_SUBNET_CAM_BIST_STATUSr_BIST_DONEf_GET BCM56504_A0_VLAN_SUBNET_CAM_BIST_STATUSr_BIST_DONEf_GET
#define VLAN_SUBNET_CAM_BIST_STATUSr_BIST_DONEf_SET BCM56504_A0_VLAN_SUBNET_CAM_BIST_STATUSr_BIST_DONEf_SET
#define READ_VLAN_SUBNET_CAM_BIST_STATUSr BCM56504_A0_READ_VLAN_SUBNET_CAM_BIST_STATUSr
#define WRITE_VLAN_SUBNET_CAM_BIST_STATUSr BCM56504_A0_WRITE_VLAN_SUBNET_CAM_BIST_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_VLAN_SUBNET_CAM_BIST_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  VLAN_SUBNET_CAM_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     VLAN_SUBNET_CAM_CONTROL
 * SIZE:     32
 * FIELDS:
 *     BIST_EN0         BIST enable for CAM0
 *     BIST_EN1         BIST enable for CAM1
 *     SAM              SAM debug bits
 *
 ******************************************************************************/
#define BCM56504_A0_VLAN_SUBNET_CAM_CONTROLr 0x04780000

#define BCM56504_A0_VLAN_SUBNET_CAM_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program VLAN_SUBNET_CAM_CONTROL.
 *
 */
typedef union BCM56504_A0_VLAN_SUBNET_CAM_CONTROLr_s {
	uint32_t v[1];
	uint32_t vlan_subnet_cam_control[1];
	uint32_t _vlan_subnet_cam_control;
} BCM56504_A0_VLAN_SUBNET_CAM_CONTROLr_t;

#define BCM56504_A0_VLAN_SUBNET_CAM_CONTROLr_CLR(r) (r).vlan_subnet_cam_control[0] = 0
#define BCM56504_A0_VLAN_SUBNET_CAM_CONTROLr_SET(r,d) (r).vlan_subnet_cam_control[0] = d
#define BCM56504_A0_VLAN_SUBNET_CAM_CONTROLr_GET(r) (r).vlan_subnet_cam_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_VLAN_SUBNET_CAM_CONTROLr_BIST_EN0f_GET(r) (((r).vlan_subnet_cam_control[0]) & 0x1)
#define BCM56504_A0_VLAN_SUBNET_CAM_CONTROLr_BIST_EN0f_SET(r,f) (r).vlan_subnet_cam_control[0]=(((r).vlan_subnet_cam_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_VLAN_SUBNET_CAM_CONTROLr_BIST_EN1f_GET(r) ((((r).vlan_subnet_cam_control[0]) >> 1) & 0x1)
#define BCM56504_A0_VLAN_SUBNET_CAM_CONTROLr_BIST_EN1f_SET(r,f) (r).vlan_subnet_cam_control[0]=(((r).vlan_subnet_cam_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_VLAN_SUBNET_CAM_CONTROLr_SAMf_GET(r) ((((r).vlan_subnet_cam_control[0]) >> 2) & 0x7)
#define BCM56504_A0_VLAN_SUBNET_CAM_CONTROLr_SAMf_SET(r,f) (r).vlan_subnet_cam_control[0]=(((r).vlan_subnet_cam_control[0] & ~((uint32_t)0x7 << 2)) | ((((uint32_t)f) & 0x7) << 2))

/*
 * These macros can be used to access VLAN_SUBNET_CAM_CONTROL.
 *
 */
#define BCM56504_A0_READ_VLAN_SUBNET_CAM_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_VLAN_SUBNET_CAM_CONTROLr,(r._vlan_subnet_cam_control))
#define BCM56504_A0_WRITE_VLAN_SUBNET_CAM_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_VLAN_SUBNET_CAM_CONTROLr,&(r._vlan_subnet_cam_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_SUBNET_CAM_CONTROLr BCM56504_A0_VLAN_SUBNET_CAM_CONTROLr
#define VLAN_SUBNET_CAM_CONTROLr_SIZE BCM56504_A0_VLAN_SUBNET_CAM_CONTROLr_SIZE
typedef BCM56504_A0_VLAN_SUBNET_CAM_CONTROLr_t VLAN_SUBNET_CAM_CONTROLr_t;
#define VLAN_SUBNET_CAM_CONTROLr_CLR BCM56504_A0_VLAN_SUBNET_CAM_CONTROLr_CLR
#define VLAN_SUBNET_CAM_CONTROLr_SET BCM56504_A0_VLAN_SUBNET_CAM_CONTROLr_SET
#define VLAN_SUBNET_CAM_CONTROLr_GET BCM56504_A0_VLAN_SUBNET_CAM_CONTROLr_GET
#define VLAN_SUBNET_CAM_CONTROLr_BIST_EN0f_GET BCM56504_A0_VLAN_SUBNET_CAM_CONTROLr_BIST_EN0f_GET
#define VLAN_SUBNET_CAM_CONTROLr_BIST_EN0f_SET BCM56504_A0_VLAN_SUBNET_CAM_CONTROLr_BIST_EN0f_SET
#define VLAN_SUBNET_CAM_CONTROLr_BIST_EN1f_GET BCM56504_A0_VLAN_SUBNET_CAM_CONTROLr_BIST_EN1f_GET
#define VLAN_SUBNET_CAM_CONTROLr_BIST_EN1f_SET BCM56504_A0_VLAN_SUBNET_CAM_CONTROLr_BIST_EN1f_SET
#define VLAN_SUBNET_CAM_CONTROLr_SAMf_GET BCM56504_A0_VLAN_SUBNET_CAM_CONTROLr_SAMf_GET
#define VLAN_SUBNET_CAM_CONTROLr_SAMf_SET BCM56504_A0_VLAN_SUBNET_CAM_CONTROLr_SAMf_SET
#define READ_VLAN_SUBNET_CAM_CONTROLr BCM56504_A0_READ_VLAN_SUBNET_CAM_CONTROLr
#define WRITE_VLAN_SUBNET_CAM_CONTROLr BCM56504_A0_WRITE_VLAN_SUBNET_CAM_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_VLAN_SUBNET_CAM_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  VLAN_SUBNET_DATA_ONLY
 * BLOCKS:   IPIPE
 * DESC:     Holds data for IP Subnet-based VLAN substitution
 * SIZE:     15
 * FIELDS:
 *     PRI              Priority field
 *     VLAN_ID          VLAN ID
 *
 ******************************************************************************/
#define BCM56504_A0_VLAN_SUBNET_DATA_ONLYm 0x04740000

#define BCM56504_A0_VLAN_SUBNET_DATA_ONLYm_MIN 0
#define BCM56504_A0_VLAN_SUBNET_DATA_ONLYm_MAX 255
#define BCM56504_A0_VLAN_SUBNET_DATA_ONLYm_CMAX(u) 255
#define BCM56504_A0_VLAN_SUBNET_DATA_ONLYm_SIZE 2

/*
 * This structure should be used to declare and program VLAN_SUBNET_DATA_ONLY.
 *
 */
typedef union BCM56504_A0_VLAN_SUBNET_DATA_ONLYm_s {
	uint32_t v[1];
	uint32_t vlan_subnet_data_only[1];
	uint32_t _vlan_subnet_data_only;
} BCM56504_A0_VLAN_SUBNET_DATA_ONLYm_t;

#define BCM56504_A0_VLAN_SUBNET_DATA_ONLYm_CLR(r) (r).vlan_subnet_data_only[0] = 0
#define BCM56504_A0_VLAN_SUBNET_DATA_ONLYm_SET(r,d) (r).vlan_subnet_data_only[0] = d
#define BCM56504_A0_VLAN_SUBNET_DATA_ONLYm_GET(r) (r).vlan_subnet_data_only[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_VLAN_SUBNET_DATA_ONLYm_PRIf_GET(r) (((r).vlan_subnet_data_only[0]) & 0x7)
#define BCM56504_A0_VLAN_SUBNET_DATA_ONLYm_PRIf_SET(r,f) (r).vlan_subnet_data_only[0]=(((r).vlan_subnet_data_only[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM56504_A0_VLAN_SUBNET_DATA_ONLYm_VLAN_IDf_GET(r) ((((r).vlan_subnet_data_only[0]) >> 3) & 0xfff)
#define BCM56504_A0_VLAN_SUBNET_DATA_ONLYm_VLAN_IDf_SET(r,f) (r).vlan_subnet_data_only[0]=(((r).vlan_subnet_data_only[0] & ~((uint32_t)0xfff << 3)) | ((((uint32_t)f) & 0xfff) << 3))

/*
 * These macros can be used to access VLAN_SUBNET_DATA_ONLY.
 *
 */
#define BCM56504_A0_READ_VLAN_SUBNET_DATA_ONLYm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_VLAN_SUBNET_DATA_ONLYm,i,(m._vlan_subnet_data_only),1)
#define BCM56504_A0_WRITE_VLAN_SUBNET_DATA_ONLYm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_VLAN_SUBNET_DATA_ONLYm,i,&(m._vlan_subnet_data_only),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_SUBNET_DATA_ONLYm BCM56504_A0_VLAN_SUBNET_DATA_ONLYm
#define VLAN_SUBNET_DATA_ONLYm_MIN BCM56504_A0_VLAN_SUBNET_DATA_ONLYm_MIN
#define VLAN_SUBNET_DATA_ONLYm_MAX BCM56504_A0_VLAN_SUBNET_DATA_ONLYm_MAX
#define VLAN_SUBNET_DATA_ONLYm_CMAX(u) BCM56504_A0_VLAN_SUBNET_DATA_ONLYm_CMAX(u)
#define VLAN_SUBNET_DATA_ONLYm_SIZE BCM56504_A0_VLAN_SUBNET_DATA_ONLYm_SIZE
typedef BCM56504_A0_VLAN_SUBNET_DATA_ONLYm_t VLAN_SUBNET_DATA_ONLYm_t;
#define VLAN_SUBNET_DATA_ONLYm_CLR BCM56504_A0_VLAN_SUBNET_DATA_ONLYm_CLR
#define VLAN_SUBNET_DATA_ONLYm_SET BCM56504_A0_VLAN_SUBNET_DATA_ONLYm_SET
#define VLAN_SUBNET_DATA_ONLYm_GET BCM56504_A0_VLAN_SUBNET_DATA_ONLYm_GET
#define VLAN_SUBNET_DATA_ONLYm_PRIf_GET BCM56504_A0_VLAN_SUBNET_DATA_ONLYm_PRIf_GET
#define VLAN_SUBNET_DATA_ONLYm_PRIf_SET BCM56504_A0_VLAN_SUBNET_DATA_ONLYm_PRIf_SET
#define VLAN_SUBNET_DATA_ONLYm_VLAN_IDf_GET BCM56504_A0_VLAN_SUBNET_DATA_ONLYm_VLAN_IDf_GET
#define VLAN_SUBNET_DATA_ONLYm_VLAN_IDf_SET BCM56504_A0_VLAN_SUBNET_DATA_ONLYm_VLAN_IDf_SET
#define READ_VLAN_SUBNET_DATA_ONLYm BCM56504_A0_READ_VLAN_SUBNET_DATA_ONLYm
#define WRITE_VLAN_SUBNET_DATA_ONLYm BCM56504_A0_WRITE_VLAN_SUBNET_DATA_ONLYm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_VLAN_SUBNET_DATA_ONLYm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  VLAN_SUBNET_ONLY
 * BLOCKS:   IPIPE
 * DESC:     TCAM for IP subnet based VLAN substitution
 * SIZE:     129
 * FIELDS:
 *     VALID            IP Subnet mask
 *     IP_ADDR          IP Address key
 *     MASK             IP Subnet mask
 *
 ******************************************************************************/
#define BCM56504_A0_VLAN_SUBNET_ONLYm 0x04730000

#define BCM56504_A0_VLAN_SUBNET_ONLYm_MIN 0
#define BCM56504_A0_VLAN_SUBNET_ONLYm_MAX 255
#define BCM56504_A0_VLAN_SUBNET_ONLYm_CMAX(u) 255
#define BCM56504_A0_VLAN_SUBNET_ONLYm_SIZE 17

/*
 * This structure should be used to declare and program VLAN_SUBNET_ONLY.
 *
 */
typedef union BCM56504_A0_VLAN_SUBNET_ONLYm_s {
	uint32_t v[5];
	uint32_t vlan_subnet_only[5];
	uint32_t _vlan_subnet_only;
} BCM56504_A0_VLAN_SUBNET_ONLYm_t;

#define BCM56504_A0_VLAN_SUBNET_ONLYm_CLR(r) CDK_MEMSET(&((r)._vlan_subnet_only), 0, sizeof(BCM56504_A0_VLAN_SUBNET_ONLYm_t))
#define BCM56504_A0_VLAN_SUBNET_ONLYm_SET(r,i,d) (r).vlan_subnet_only[i] = d
#define BCM56504_A0_VLAN_SUBNET_ONLYm_GET(r,i) (r).vlan_subnet_only[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_VLAN_SUBNET_ONLYm_VALIDf_GET(r) (((r).vlan_subnet_only[0]) & 0x1)
#define BCM56504_A0_VLAN_SUBNET_ONLYm_VALIDf_SET(r,f) (r).vlan_subnet_only[0]=(((r).vlan_subnet_only[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_VLAN_SUBNET_ONLYm_IP_ADDRf_GET(r,a) cdk_field_get((r).vlan_subnet_only,1,64,a)
#define BCM56504_A0_VLAN_SUBNET_ONLYm_IP_ADDRf_SET(r,a) cdk_field_set((r).vlan_subnet_only,1,64,a)
#define BCM56504_A0_VLAN_SUBNET_ONLYm_MASKf_GET(r,a) cdk_field_get((r).vlan_subnet_only,65,128,a)
#define BCM56504_A0_VLAN_SUBNET_ONLYm_MASKf_SET(r,a) cdk_field_set((r).vlan_subnet_only,65,128,a)

/*
 * These macros can be used to access VLAN_SUBNET_ONLY.
 *
 */
#define BCM56504_A0_READ_VLAN_SUBNET_ONLYm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_VLAN_SUBNET_ONLYm,i,(m._vlan_subnet_only),5)
#define BCM56504_A0_WRITE_VLAN_SUBNET_ONLYm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_VLAN_SUBNET_ONLYm,i,&(m._vlan_subnet_only),5)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_SUBNET_ONLYm BCM56504_A0_VLAN_SUBNET_ONLYm
#define VLAN_SUBNET_ONLYm_MIN BCM56504_A0_VLAN_SUBNET_ONLYm_MIN
#define VLAN_SUBNET_ONLYm_MAX BCM56504_A0_VLAN_SUBNET_ONLYm_MAX
#define VLAN_SUBNET_ONLYm_CMAX(u) BCM56504_A0_VLAN_SUBNET_ONLYm_CMAX(u)
#define VLAN_SUBNET_ONLYm_SIZE BCM56504_A0_VLAN_SUBNET_ONLYm_SIZE
typedef BCM56504_A0_VLAN_SUBNET_ONLYm_t VLAN_SUBNET_ONLYm_t;
#define VLAN_SUBNET_ONLYm_CLR BCM56504_A0_VLAN_SUBNET_ONLYm_CLR
#define VLAN_SUBNET_ONLYm_SET BCM56504_A0_VLAN_SUBNET_ONLYm_SET
#define VLAN_SUBNET_ONLYm_GET BCM56504_A0_VLAN_SUBNET_ONLYm_GET
#define VLAN_SUBNET_ONLYm_VALIDf_GET BCM56504_A0_VLAN_SUBNET_ONLYm_VALIDf_GET
#define VLAN_SUBNET_ONLYm_VALIDf_SET BCM56504_A0_VLAN_SUBNET_ONLYm_VALIDf_SET
#define VLAN_SUBNET_ONLYm_IP_ADDRf_GET BCM56504_A0_VLAN_SUBNET_ONLYm_IP_ADDRf_GET
#define VLAN_SUBNET_ONLYm_IP_ADDRf_SET BCM56504_A0_VLAN_SUBNET_ONLYm_IP_ADDRf_SET
#define VLAN_SUBNET_ONLYm_MASKf_GET BCM56504_A0_VLAN_SUBNET_ONLYm_MASKf_GET
#define VLAN_SUBNET_ONLYm_MASKf_SET BCM56504_A0_VLAN_SUBNET_ONLYm_MASKf_SET
#define READ_VLAN_SUBNET_ONLYm BCM56504_A0_READ_VLAN_SUBNET_ONLYm
#define WRITE_VLAN_SUBNET_ONLYm BCM56504_A0_WRITE_VLAN_SUBNET_ONLYm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_VLAN_SUBNET_ONLYm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  VLAN_TAB
 * BLOCKS:   IPIPE
 * DESC:     Contains cntrls assoc with the 4K VLANs.
 * SIZE:     42
 * FIELDS:
 *     PORT_BITMAP      VLAN port membership bitmap
 *     HIGIG_TRUNK_OVERRIDE Add the VLAN ID
 *     VALID            Valid VLAN ID
 *     STG              Spanning Tree Group ID
 *     PFM              Port Filtering Mode
 *
 ******************************************************************************/
#define BCM56504_A0_VLAN_TABm 0x05700000

#define BCM56504_A0_VLAN_TABm_MIN 0
#define BCM56504_A0_VLAN_TABm_MAX 4095
#define BCM56504_A0_VLAN_TABm_CMAX(u) 4095
#define BCM56504_A0_VLAN_TABm_SIZE 6

/*
 * This structure should be used to declare and program VLAN_TAB.
 *
 */
typedef union BCM56504_A0_VLAN_TABm_s {
	uint32_t v[2];
	uint32_t vlan_tab[2];
	uint32_t _vlan_tab;
} BCM56504_A0_VLAN_TABm_t;

#define BCM56504_A0_VLAN_TABm_CLR(r) CDK_MEMSET(&((r)._vlan_tab), 0, sizeof(BCM56504_A0_VLAN_TABm_t))
#define BCM56504_A0_VLAN_TABm_SET(r,i,d) (r).vlan_tab[i] = d
#define BCM56504_A0_VLAN_TABm_GET(r,i) (r).vlan_tab[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_VLAN_TABm_PORT_BITMAPf_GET(r) (((r).vlan_tab[0]) & 0x1fffffff)
#define BCM56504_A0_VLAN_TABm_PORT_BITMAPf_SET(r,f) (r).vlan_tab[0]=(((r).vlan_tab[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM56504_A0_VLAN_TABm_HIGIG_TRUNK_OVERRIDEf_GET(r) ((((r).vlan_tab[0]) >> 29) & 0x3)
#define BCM56504_A0_VLAN_TABm_HIGIG_TRUNK_OVERRIDEf_SET(r,f) (r).vlan_tab[0]=(((r).vlan_tab[0] & ~((uint32_t)0x3 << 29)) | ((((uint32_t)f) & 0x3) << 29))
#define BCM56504_A0_VLAN_TABm_VALIDf_GET(r) ((((r).vlan_tab[0]) >> 31) & 0x1)
#define BCM56504_A0_VLAN_TABm_VALIDf_SET(r,f) (r).vlan_tab[0]=(((r).vlan_tab[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM56504_A0_VLAN_TABm_STGf_GET(r) (((r).vlan_tab[1]) & 0xff)
#define BCM56504_A0_VLAN_TABm_STGf_SET(r,f) (r).vlan_tab[1]=(((r).vlan_tab[1] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56504_A0_VLAN_TABm_PFMf_GET(r) ((((r).vlan_tab[1]) >> 8) & 0x3)
#define BCM56504_A0_VLAN_TABm_PFMf_SET(r,f) (r).vlan_tab[1]=(((r).vlan_tab[1] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))

/*
 * These macros can be used to access VLAN_TAB.
 *
 */
#define BCM56504_A0_READ_VLAN_TABm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_VLAN_TABm,i,(m._vlan_tab),2)
#define BCM56504_A0_WRITE_VLAN_TABm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_VLAN_TABm,i,&(m._vlan_tab),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_TABm BCM56504_A0_VLAN_TABm
#define VLAN_TABm_MIN BCM56504_A0_VLAN_TABm_MIN
#define VLAN_TABm_MAX BCM56504_A0_VLAN_TABm_MAX
#define VLAN_TABm_CMAX(u) BCM56504_A0_VLAN_TABm_CMAX(u)
#define VLAN_TABm_SIZE BCM56504_A0_VLAN_TABm_SIZE
typedef BCM56504_A0_VLAN_TABm_t VLAN_TABm_t;
#define VLAN_TABm_CLR BCM56504_A0_VLAN_TABm_CLR
#define VLAN_TABm_SET BCM56504_A0_VLAN_TABm_SET
#define VLAN_TABm_GET BCM56504_A0_VLAN_TABm_GET
#define VLAN_TABm_PORT_BITMAPf_GET BCM56504_A0_VLAN_TABm_PORT_BITMAPf_GET
#define VLAN_TABm_PORT_BITMAPf_SET BCM56504_A0_VLAN_TABm_PORT_BITMAPf_SET
#define VLAN_TABm_HIGIG_TRUNK_OVERRIDEf_GET BCM56504_A0_VLAN_TABm_HIGIG_TRUNK_OVERRIDEf_GET
#define VLAN_TABm_HIGIG_TRUNK_OVERRIDEf_SET BCM56504_A0_VLAN_TABm_HIGIG_TRUNK_OVERRIDEf_SET
#define VLAN_TABm_VALIDf_GET BCM56504_A0_VLAN_TABm_VALIDf_GET
#define VLAN_TABm_VALIDf_SET BCM56504_A0_VLAN_TABm_VALIDf_SET
#define VLAN_TABm_STGf_GET BCM56504_A0_VLAN_TABm_STGf_GET
#define VLAN_TABm_STGf_SET BCM56504_A0_VLAN_TABm_STGf_SET
#define VLAN_TABm_PFMf_GET BCM56504_A0_VLAN_TABm_PFMf_GET
#define VLAN_TABm_PFMf_SET BCM56504_A0_VLAN_TABm_PFMf_SET
#define READ_VLAN_TABm BCM56504_A0_READ_VLAN_TABm
#define WRITE_VLAN_TABm BCM56504_A0_WRITE_VLAN_TABm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_VLAN_TABm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  VLAN_XLATE
 * BLOCKS:   IPIPE
 * DESC:     BCAM for VLAN trans of tagged pkts.
 * SIZE:     35
 * FIELDS:
 *     VALID            Indicates that the entry is valid.
 *     INGRESS_PORT     Source port part of the key
 *     VLAN_ID          VLAN ID part of the key
 *     RPE              RPE bit
 *     PRI              Priority to be assigned
 *     NEW_VLAN_ID      VLAN ID to be assigned
 *     ADD_VID          Add the VLAN ID
 *
 ******************************************************************************/
#define BCM56504_A0_VLAN_XLATEm 0x04760000

#define BCM56504_A0_VLAN_XLATEm_MIN 0
#define BCM56504_A0_VLAN_XLATEm_MAX 767
#define BCM56504_A0_VLAN_XLATEm_CMAX(u) 767
#define BCM56504_A0_VLAN_XLATEm_SIZE 5

/*
 * This structure should be used to declare and program VLAN_XLATE.
 *
 */
typedef union BCM56504_A0_VLAN_XLATEm_s {
	uint32_t v[2];
	uint32_t vlan_xlate[2];
	uint32_t _vlan_xlate;
} BCM56504_A0_VLAN_XLATEm_t;

#define BCM56504_A0_VLAN_XLATEm_CLR(r) CDK_MEMSET(&((r)._vlan_xlate), 0, sizeof(BCM56504_A0_VLAN_XLATEm_t))
#define BCM56504_A0_VLAN_XLATEm_SET(r,i,d) (r).vlan_xlate[i] = d
#define BCM56504_A0_VLAN_XLATEm_GET(r,i) (r).vlan_xlate[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_VLAN_XLATEm_VALIDf_GET(r) (((r).vlan_xlate[0]) & 0x1)
#define BCM56504_A0_VLAN_XLATEm_VALIDf_SET(r,f) (r).vlan_xlate[0]=(((r).vlan_xlate[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_VLAN_XLATEm_INGRESS_PORTf_GET(r) ((((r).vlan_xlate[0]) >> 1) & 0x1f)
#define BCM56504_A0_VLAN_XLATEm_INGRESS_PORTf_SET(r,f) (r).vlan_xlate[0]=(((r).vlan_xlate[0] & ~((uint32_t)0x1f << 1)) | ((((uint32_t)f) & 0x1f) << 1))
#define BCM56504_A0_VLAN_XLATEm_VLAN_IDf_GET(r) ((((r).vlan_xlate[0]) >> 6) & 0xfff)
#define BCM56504_A0_VLAN_XLATEm_VLAN_IDf_SET(r,f) (r).vlan_xlate[0]=(((r).vlan_xlate[0] & ~((uint32_t)0xfff << 6)) | ((((uint32_t)f) & 0xfff) << 6))
#define BCM56504_A0_VLAN_XLATEm_RPEf_GET(r) ((((r).vlan_xlate[0]) >> 18) & 0x1)
#define BCM56504_A0_VLAN_XLATEm_RPEf_SET(r,f) (r).vlan_xlate[0]=(((r).vlan_xlate[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56504_A0_VLAN_XLATEm_PRIf_GET(r) ((((r).vlan_xlate[0]) >> 19) & 0x7)
#define BCM56504_A0_VLAN_XLATEm_PRIf_SET(r,f) (r).vlan_xlate[0]=(((r).vlan_xlate[0] & ~((uint32_t)0x7 << 19)) | ((((uint32_t)f) & 0x7) << 19))
#define BCM56504_A0_VLAN_XLATEm_NEW_VLAN_IDf_GET(r) cdk_field32_get((r).vlan_xlate,22,33)
#define BCM56504_A0_VLAN_XLATEm_NEW_VLAN_IDf_SET(r,f) cdk_field32_set((r).vlan_xlate,22,33,f)
#define BCM56504_A0_VLAN_XLATEm_ADD_VIDf_GET(r) ((((r).vlan_xlate[1]) >> 2) & 0x1)
#define BCM56504_A0_VLAN_XLATEm_ADD_VIDf_SET(r,f) (r).vlan_xlate[1]=(((r).vlan_xlate[1] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))

/*
 * These macros can be used to access VLAN_XLATE.
 *
 */
#define BCM56504_A0_READ_VLAN_XLATEm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_VLAN_XLATEm,i,(m._vlan_xlate),2)
#define BCM56504_A0_WRITE_VLAN_XLATEm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_VLAN_XLATEm,i,&(m._vlan_xlate),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_XLATEm BCM56504_A0_VLAN_XLATEm
#define VLAN_XLATEm_MIN BCM56504_A0_VLAN_XLATEm_MIN
#define VLAN_XLATEm_MAX BCM56504_A0_VLAN_XLATEm_MAX
#define VLAN_XLATEm_CMAX(u) BCM56504_A0_VLAN_XLATEm_CMAX(u)
#define VLAN_XLATEm_SIZE BCM56504_A0_VLAN_XLATEm_SIZE
typedef BCM56504_A0_VLAN_XLATEm_t VLAN_XLATEm_t;
#define VLAN_XLATEm_CLR BCM56504_A0_VLAN_XLATEm_CLR
#define VLAN_XLATEm_SET BCM56504_A0_VLAN_XLATEm_SET
#define VLAN_XLATEm_GET BCM56504_A0_VLAN_XLATEm_GET
#define VLAN_XLATEm_VALIDf_GET BCM56504_A0_VLAN_XLATEm_VALIDf_GET
#define VLAN_XLATEm_VALIDf_SET BCM56504_A0_VLAN_XLATEm_VALIDf_SET
#define VLAN_XLATEm_INGRESS_PORTf_GET BCM56504_A0_VLAN_XLATEm_INGRESS_PORTf_GET
#define VLAN_XLATEm_INGRESS_PORTf_SET BCM56504_A0_VLAN_XLATEm_INGRESS_PORTf_SET
#define VLAN_XLATEm_VLAN_IDf_GET BCM56504_A0_VLAN_XLATEm_VLAN_IDf_GET
#define VLAN_XLATEm_VLAN_IDf_SET BCM56504_A0_VLAN_XLATEm_VLAN_IDf_SET
#define VLAN_XLATEm_RPEf_GET BCM56504_A0_VLAN_XLATEm_RPEf_GET
#define VLAN_XLATEm_RPEf_SET BCM56504_A0_VLAN_XLATEm_RPEf_SET
#define VLAN_XLATEm_PRIf_GET BCM56504_A0_VLAN_XLATEm_PRIf_GET
#define VLAN_XLATEm_PRIf_SET BCM56504_A0_VLAN_XLATEm_PRIf_SET
#define VLAN_XLATEm_NEW_VLAN_IDf_GET BCM56504_A0_VLAN_XLATEm_NEW_VLAN_IDf_GET
#define VLAN_XLATEm_NEW_VLAN_IDf_SET BCM56504_A0_VLAN_XLATEm_NEW_VLAN_IDf_SET
#define VLAN_XLATEm_ADD_VIDf_GET BCM56504_A0_VLAN_XLATEm_ADD_VIDf_GET
#define VLAN_XLATEm_ADD_VIDf_SET BCM56504_A0_VLAN_XLATEm_ADD_VIDf_SET
#define READ_VLAN_XLATEm BCM56504_A0_READ_VLAN_XLATEm
#define WRITE_VLAN_XLATEm BCM56504_A0_WRITE_VLAN_XLATEm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_VLAN_XLATEm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  VLAN_XLATE_CAM_BIST_S2_STATUS
 * BLOCKS:   IPIPE
 * DESC:     VLAN_XLATE_CAM_BIST_S2_STATUS
 * SIZE:     32
 * FIELDS:
 *     MATCH_STATUS     Match status
 *     BIT_POS          Sliding Bit position when match happened
 *     AINDEX           Aindex when match happened
 *
 ******************************************************************************/
#define BCM56504_A0_VLAN_XLATE_CAM_BIST_S2_STATUSr 0x0478000a

#define BCM56504_A0_VLAN_XLATE_CAM_BIST_S2_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program VLAN_XLATE_CAM_BIST_S2_STATUS.
 *
 */
typedef union BCM56504_A0_VLAN_XLATE_CAM_BIST_S2_STATUSr_s {
	uint32_t v[1];
	uint32_t vlan_xlate_cam_bist_s2_status[1];
	uint32_t _vlan_xlate_cam_bist_s2_status;
} BCM56504_A0_VLAN_XLATE_CAM_BIST_S2_STATUSr_t;

#define BCM56504_A0_VLAN_XLATE_CAM_BIST_S2_STATUSr_CLR(r) (r).vlan_xlate_cam_bist_s2_status[0] = 0
#define BCM56504_A0_VLAN_XLATE_CAM_BIST_S2_STATUSr_SET(r,d) (r).vlan_xlate_cam_bist_s2_status[0] = d
#define BCM56504_A0_VLAN_XLATE_CAM_BIST_S2_STATUSr_GET(r) (r).vlan_xlate_cam_bist_s2_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_VLAN_XLATE_CAM_BIST_S2_STATUSr_MATCH_STATUSf_GET(r) (((r).vlan_xlate_cam_bist_s2_status[0]) & 0x1)
#define BCM56504_A0_VLAN_XLATE_CAM_BIST_S2_STATUSr_MATCH_STATUSf_SET(r,f) (r).vlan_xlate_cam_bist_s2_status[0]=(((r).vlan_xlate_cam_bist_s2_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_VLAN_XLATE_CAM_BIST_S2_STATUSr_BIT_POSf_GET(r) ((((r).vlan_xlate_cam_bist_s2_status[0]) >> 1) & 0x1f)
#define BCM56504_A0_VLAN_XLATE_CAM_BIST_S2_STATUSr_BIT_POSf_SET(r,f) (r).vlan_xlate_cam_bist_s2_status[0]=(((r).vlan_xlate_cam_bist_s2_status[0] & ~((uint32_t)0x1f << 1)) | ((((uint32_t)f) & 0x1f) << 1))
#define BCM56504_A0_VLAN_XLATE_CAM_BIST_S2_STATUSr_AINDEXf_GET(r) ((((r).vlan_xlate_cam_bist_s2_status[0]) >> 6) & 0x3ff)
#define BCM56504_A0_VLAN_XLATE_CAM_BIST_S2_STATUSr_AINDEXf_SET(r,f) (r).vlan_xlate_cam_bist_s2_status[0]=(((r).vlan_xlate_cam_bist_s2_status[0] & ~((uint32_t)0x3ff << 6)) | ((((uint32_t)f) & 0x3ff) << 6))

/*
 * These macros can be used to access VLAN_XLATE_CAM_BIST_S2_STATUS.
 *
 */
#define BCM56504_A0_READ_VLAN_XLATE_CAM_BIST_S2_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_VLAN_XLATE_CAM_BIST_S2_STATUSr,(r._vlan_xlate_cam_bist_s2_status))
#define BCM56504_A0_WRITE_VLAN_XLATE_CAM_BIST_S2_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_VLAN_XLATE_CAM_BIST_S2_STATUSr,&(r._vlan_xlate_cam_bist_s2_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_XLATE_CAM_BIST_S2_STATUSr BCM56504_A0_VLAN_XLATE_CAM_BIST_S2_STATUSr
#define VLAN_XLATE_CAM_BIST_S2_STATUSr_SIZE BCM56504_A0_VLAN_XLATE_CAM_BIST_S2_STATUSr_SIZE
typedef BCM56504_A0_VLAN_XLATE_CAM_BIST_S2_STATUSr_t VLAN_XLATE_CAM_BIST_S2_STATUSr_t;
#define VLAN_XLATE_CAM_BIST_S2_STATUSr_CLR BCM56504_A0_VLAN_XLATE_CAM_BIST_S2_STATUSr_CLR
#define VLAN_XLATE_CAM_BIST_S2_STATUSr_SET BCM56504_A0_VLAN_XLATE_CAM_BIST_S2_STATUSr_SET
#define VLAN_XLATE_CAM_BIST_S2_STATUSr_GET BCM56504_A0_VLAN_XLATE_CAM_BIST_S2_STATUSr_GET
#define VLAN_XLATE_CAM_BIST_S2_STATUSr_MATCH_STATUSf_GET BCM56504_A0_VLAN_XLATE_CAM_BIST_S2_STATUSr_MATCH_STATUSf_GET
#define VLAN_XLATE_CAM_BIST_S2_STATUSr_MATCH_STATUSf_SET BCM56504_A0_VLAN_XLATE_CAM_BIST_S2_STATUSr_MATCH_STATUSf_SET
#define VLAN_XLATE_CAM_BIST_S2_STATUSr_BIT_POSf_GET BCM56504_A0_VLAN_XLATE_CAM_BIST_S2_STATUSr_BIT_POSf_GET
#define VLAN_XLATE_CAM_BIST_S2_STATUSr_BIT_POSf_SET BCM56504_A0_VLAN_XLATE_CAM_BIST_S2_STATUSr_BIT_POSf_SET
#define VLAN_XLATE_CAM_BIST_S2_STATUSr_AINDEXf_GET BCM56504_A0_VLAN_XLATE_CAM_BIST_S2_STATUSr_AINDEXf_GET
#define VLAN_XLATE_CAM_BIST_S2_STATUSr_AINDEXf_SET BCM56504_A0_VLAN_XLATE_CAM_BIST_S2_STATUSr_AINDEXf_SET
#define READ_VLAN_XLATE_CAM_BIST_S2_STATUSr BCM56504_A0_READ_VLAN_XLATE_CAM_BIST_S2_STATUSr
#define WRITE_VLAN_XLATE_CAM_BIST_S2_STATUSr BCM56504_A0_WRITE_VLAN_XLATE_CAM_BIST_S2_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_VLAN_XLATE_CAM_BIST_S2_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  VLAN_XLATE_CAM_BIST_S3_STATUS
 * BLOCKS:   IPIPE
 * DESC:     VLAN_XLATE_CAM_BIST_S3_STATUS
 * SIZE:     32
 * FIELDS:
 *     MATCH_STATUS     Match status
 *     AINDEX_STATUS    AIndex status
 *     ACTUAL_AINDEX    Actual AIndex when CAM reported a match
 *     EXPECTED_AINDEX  Expected AIndex
 *
 ******************************************************************************/
#define BCM56504_A0_VLAN_XLATE_CAM_BIST_S3_STATUSr 0x0478000b

#define BCM56504_A0_VLAN_XLATE_CAM_BIST_S3_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program VLAN_XLATE_CAM_BIST_S3_STATUS.
 *
 */
typedef union BCM56504_A0_VLAN_XLATE_CAM_BIST_S3_STATUSr_s {
	uint32_t v[1];
	uint32_t vlan_xlate_cam_bist_s3_status[1];
	uint32_t _vlan_xlate_cam_bist_s3_status;
} BCM56504_A0_VLAN_XLATE_CAM_BIST_S3_STATUSr_t;

#define BCM56504_A0_VLAN_XLATE_CAM_BIST_S3_STATUSr_CLR(r) (r).vlan_xlate_cam_bist_s3_status[0] = 0
#define BCM56504_A0_VLAN_XLATE_CAM_BIST_S3_STATUSr_SET(r,d) (r).vlan_xlate_cam_bist_s3_status[0] = d
#define BCM56504_A0_VLAN_XLATE_CAM_BIST_S3_STATUSr_GET(r) (r).vlan_xlate_cam_bist_s3_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_VLAN_XLATE_CAM_BIST_S3_STATUSr_MATCH_STATUSf_GET(r) (((r).vlan_xlate_cam_bist_s3_status[0]) & 0x1)
#define BCM56504_A0_VLAN_XLATE_CAM_BIST_S3_STATUSr_MATCH_STATUSf_SET(r,f) (r).vlan_xlate_cam_bist_s3_status[0]=(((r).vlan_xlate_cam_bist_s3_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_VLAN_XLATE_CAM_BIST_S3_STATUSr_AINDEX_STATUSf_GET(r) ((((r).vlan_xlate_cam_bist_s3_status[0]) >> 1) & 0x1)
#define BCM56504_A0_VLAN_XLATE_CAM_BIST_S3_STATUSr_AINDEX_STATUSf_SET(r,f) (r).vlan_xlate_cam_bist_s3_status[0]=(((r).vlan_xlate_cam_bist_s3_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_VLAN_XLATE_CAM_BIST_S3_STATUSr_ACTUAL_AINDEXf_GET(r) ((((r).vlan_xlate_cam_bist_s3_status[0]) >> 2) & 0x3ff)
#define BCM56504_A0_VLAN_XLATE_CAM_BIST_S3_STATUSr_ACTUAL_AINDEXf_SET(r,f) (r).vlan_xlate_cam_bist_s3_status[0]=(((r).vlan_xlate_cam_bist_s3_status[0] & ~((uint32_t)0x3ff << 2)) | ((((uint32_t)f) & 0x3ff) << 2))
#define BCM56504_A0_VLAN_XLATE_CAM_BIST_S3_STATUSr_EXPECTED_AINDEXf_GET(r) ((((r).vlan_xlate_cam_bist_s3_status[0]) >> 12) & 0x3ff)
#define BCM56504_A0_VLAN_XLATE_CAM_BIST_S3_STATUSr_EXPECTED_AINDEXf_SET(r,f) (r).vlan_xlate_cam_bist_s3_status[0]=(((r).vlan_xlate_cam_bist_s3_status[0] & ~((uint32_t)0x3ff << 12)) | ((((uint32_t)f) & 0x3ff) << 12))

/*
 * These macros can be used to access VLAN_XLATE_CAM_BIST_S3_STATUS.
 *
 */
#define BCM56504_A0_READ_VLAN_XLATE_CAM_BIST_S3_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_VLAN_XLATE_CAM_BIST_S3_STATUSr,(r._vlan_xlate_cam_bist_s3_status))
#define BCM56504_A0_WRITE_VLAN_XLATE_CAM_BIST_S3_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_VLAN_XLATE_CAM_BIST_S3_STATUSr,&(r._vlan_xlate_cam_bist_s3_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_XLATE_CAM_BIST_S3_STATUSr BCM56504_A0_VLAN_XLATE_CAM_BIST_S3_STATUSr
#define VLAN_XLATE_CAM_BIST_S3_STATUSr_SIZE BCM56504_A0_VLAN_XLATE_CAM_BIST_S3_STATUSr_SIZE
typedef BCM56504_A0_VLAN_XLATE_CAM_BIST_S3_STATUSr_t VLAN_XLATE_CAM_BIST_S3_STATUSr_t;
#define VLAN_XLATE_CAM_BIST_S3_STATUSr_CLR BCM56504_A0_VLAN_XLATE_CAM_BIST_S3_STATUSr_CLR
#define VLAN_XLATE_CAM_BIST_S3_STATUSr_SET BCM56504_A0_VLAN_XLATE_CAM_BIST_S3_STATUSr_SET
#define VLAN_XLATE_CAM_BIST_S3_STATUSr_GET BCM56504_A0_VLAN_XLATE_CAM_BIST_S3_STATUSr_GET
#define VLAN_XLATE_CAM_BIST_S3_STATUSr_MATCH_STATUSf_GET BCM56504_A0_VLAN_XLATE_CAM_BIST_S3_STATUSr_MATCH_STATUSf_GET
#define VLAN_XLATE_CAM_BIST_S3_STATUSr_MATCH_STATUSf_SET BCM56504_A0_VLAN_XLATE_CAM_BIST_S3_STATUSr_MATCH_STATUSf_SET
#define VLAN_XLATE_CAM_BIST_S3_STATUSr_AINDEX_STATUSf_GET BCM56504_A0_VLAN_XLATE_CAM_BIST_S3_STATUSr_AINDEX_STATUSf_GET
#define VLAN_XLATE_CAM_BIST_S3_STATUSr_AINDEX_STATUSf_SET BCM56504_A0_VLAN_XLATE_CAM_BIST_S3_STATUSr_AINDEX_STATUSf_SET
#define VLAN_XLATE_CAM_BIST_S3_STATUSr_ACTUAL_AINDEXf_GET BCM56504_A0_VLAN_XLATE_CAM_BIST_S3_STATUSr_ACTUAL_AINDEXf_GET
#define VLAN_XLATE_CAM_BIST_S3_STATUSr_ACTUAL_AINDEXf_SET BCM56504_A0_VLAN_XLATE_CAM_BIST_S3_STATUSr_ACTUAL_AINDEXf_SET
#define VLAN_XLATE_CAM_BIST_S3_STATUSr_EXPECTED_AINDEXf_GET BCM56504_A0_VLAN_XLATE_CAM_BIST_S3_STATUSr_EXPECTED_AINDEXf_GET
#define VLAN_XLATE_CAM_BIST_S3_STATUSr_EXPECTED_AINDEXf_SET BCM56504_A0_VLAN_XLATE_CAM_BIST_S3_STATUSr_EXPECTED_AINDEXf_SET
#define READ_VLAN_XLATE_CAM_BIST_S3_STATUSr BCM56504_A0_READ_VLAN_XLATE_CAM_BIST_S3_STATUSr
#define WRITE_VLAN_XLATE_CAM_BIST_S3_STATUSr BCM56504_A0_WRITE_VLAN_XLATE_CAM_BIST_S3_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_VLAN_XLATE_CAM_BIST_S3_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  VLAN_XLATE_CAM_BIST_S5_STATUS
 * BLOCKS:   IPIPE
 * DESC:     VLAN_XLATE_CAM_BIST_S5_STATUS
 * SIZE:     32
 * FIELDS:
 *     MATCH_STATUS     Match status
 *     BIT_POS          Sliding Bit position when match happened
 *     AINDEX           Aindex when match happened
 *
 ******************************************************************************/
#define BCM56504_A0_VLAN_XLATE_CAM_BIST_S5_STATUSr 0x0478000c

#define BCM56504_A0_VLAN_XLATE_CAM_BIST_S5_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program VLAN_XLATE_CAM_BIST_S5_STATUS.
 *
 */
typedef union BCM56504_A0_VLAN_XLATE_CAM_BIST_S5_STATUSr_s {
	uint32_t v[1];
	uint32_t vlan_xlate_cam_bist_s5_status[1];
	uint32_t _vlan_xlate_cam_bist_s5_status;
} BCM56504_A0_VLAN_XLATE_CAM_BIST_S5_STATUSr_t;

#define BCM56504_A0_VLAN_XLATE_CAM_BIST_S5_STATUSr_CLR(r) (r).vlan_xlate_cam_bist_s5_status[0] = 0
#define BCM56504_A0_VLAN_XLATE_CAM_BIST_S5_STATUSr_SET(r,d) (r).vlan_xlate_cam_bist_s5_status[0] = d
#define BCM56504_A0_VLAN_XLATE_CAM_BIST_S5_STATUSr_GET(r) (r).vlan_xlate_cam_bist_s5_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_VLAN_XLATE_CAM_BIST_S5_STATUSr_MATCH_STATUSf_GET(r) (((r).vlan_xlate_cam_bist_s5_status[0]) & 0x1)
#define BCM56504_A0_VLAN_XLATE_CAM_BIST_S5_STATUSr_MATCH_STATUSf_SET(r,f) (r).vlan_xlate_cam_bist_s5_status[0]=(((r).vlan_xlate_cam_bist_s5_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_VLAN_XLATE_CAM_BIST_S5_STATUSr_BIT_POSf_GET(r) ((((r).vlan_xlate_cam_bist_s5_status[0]) >> 1) & 0x1f)
#define BCM56504_A0_VLAN_XLATE_CAM_BIST_S5_STATUSr_BIT_POSf_SET(r,f) (r).vlan_xlate_cam_bist_s5_status[0]=(((r).vlan_xlate_cam_bist_s5_status[0] & ~((uint32_t)0x1f << 1)) | ((((uint32_t)f) & 0x1f) << 1))
#define BCM56504_A0_VLAN_XLATE_CAM_BIST_S5_STATUSr_AINDEXf_GET(r) ((((r).vlan_xlate_cam_bist_s5_status[0]) >> 6) & 0x3ff)
#define BCM56504_A0_VLAN_XLATE_CAM_BIST_S5_STATUSr_AINDEXf_SET(r,f) (r).vlan_xlate_cam_bist_s5_status[0]=(((r).vlan_xlate_cam_bist_s5_status[0] & ~((uint32_t)0x3ff << 6)) | ((((uint32_t)f) & 0x3ff) << 6))

/*
 * These macros can be used to access VLAN_XLATE_CAM_BIST_S5_STATUS.
 *
 */
#define BCM56504_A0_READ_VLAN_XLATE_CAM_BIST_S5_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_VLAN_XLATE_CAM_BIST_S5_STATUSr,(r._vlan_xlate_cam_bist_s5_status))
#define BCM56504_A0_WRITE_VLAN_XLATE_CAM_BIST_S5_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_VLAN_XLATE_CAM_BIST_S5_STATUSr,&(r._vlan_xlate_cam_bist_s5_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_XLATE_CAM_BIST_S5_STATUSr BCM56504_A0_VLAN_XLATE_CAM_BIST_S5_STATUSr
#define VLAN_XLATE_CAM_BIST_S5_STATUSr_SIZE BCM56504_A0_VLAN_XLATE_CAM_BIST_S5_STATUSr_SIZE
typedef BCM56504_A0_VLAN_XLATE_CAM_BIST_S5_STATUSr_t VLAN_XLATE_CAM_BIST_S5_STATUSr_t;
#define VLAN_XLATE_CAM_BIST_S5_STATUSr_CLR BCM56504_A0_VLAN_XLATE_CAM_BIST_S5_STATUSr_CLR
#define VLAN_XLATE_CAM_BIST_S5_STATUSr_SET BCM56504_A0_VLAN_XLATE_CAM_BIST_S5_STATUSr_SET
#define VLAN_XLATE_CAM_BIST_S5_STATUSr_GET BCM56504_A0_VLAN_XLATE_CAM_BIST_S5_STATUSr_GET
#define VLAN_XLATE_CAM_BIST_S5_STATUSr_MATCH_STATUSf_GET BCM56504_A0_VLAN_XLATE_CAM_BIST_S5_STATUSr_MATCH_STATUSf_GET
#define VLAN_XLATE_CAM_BIST_S5_STATUSr_MATCH_STATUSf_SET BCM56504_A0_VLAN_XLATE_CAM_BIST_S5_STATUSr_MATCH_STATUSf_SET
#define VLAN_XLATE_CAM_BIST_S5_STATUSr_BIT_POSf_GET BCM56504_A0_VLAN_XLATE_CAM_BIST_S5_STATUSr_BIT_POSf_GET
#define VLAN_XLATE_CAM_BIST_S5_STATUSr_BIT_POSf_SET BCM56504_A0_VLAN_XLATE_CAM_BIST_S5_STATUSr_BIT_POSf_SET
#define VLAN_XLATE_CAM_BIST_S5_STATUSr_AINDEXf_GET BCM56504_A0_VLAN_XLATE_CAM_BIST_S5_STATUSr_AINDEXf_GET
#define VLAN_XLATE_CAM_BIST_S5_STATUSr_AINDEXf_SET BCM56504_A0_VLAN_XLATE_CAM_BIST_S5_STATUSr_AINDEXf_SET
#define READ_VLAN_XLATE_CAM_BIST_S5_STATUSr BCM56504_A0_READ_VLAN_XLATE_CAM_BIST_S5_STATUSr
#define WRITE_VLAN_XLATE_CAM_BIST_S5_STATUSr BCM56504_A0_WRITE_VLAN_XLATE_CAM_BIST_S5_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_VLAN_XLATE_CAM_BIST_S5_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  VLAN_XLATE_CAM_BIST_S6_STATUS
 * BLOCKS:   IPIPE
 * DESC:     VLAN_XLATE_CAM_BIST_S6_STATUS
 * SIZE:     32
 * FIELDS:
 *     MATCH_STATUS     Match status
 *     AINDEX_STATUS    AIndex status
 *     ACTUAL_AINDEX    Actual AIndex when CAM reported a match
 *     EXPECTED_AINDEX  Expected AIndex
 *
 ******************************************************************************/
#define BCM56504_A0_VLAN_XLATE_CAM_BIST_S6_STATUSr 0x0478000d

#define BCM56504_A0_VLAN_XLATE_CAM_BIST_S6_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program VLAN_XLATE_CAM_BIST_S6_STATUS.
 *
 */
typedef union BCM56504_A0_VLAN_XLATE_CAM_BIST_S6_STATUSr_s {
	uint32_t v[1];
	uint32_t vlan_xlate_cam_bist_s6_status[1];
	uint32_t _vlan_xlate_cam_bist_s6_status;
} BCM56504_A0_VLAN_XLATE_CAM_BIST_S6_STATUSr_t;

#define BCM56504_A0_VLAN_XLATE_CAM_BIST_S6_STATUSr_CLR(r) (r).vlan_xlate_cam_bist_s6_status[0] = 0
#define BCM56504_A0_VLAN_XLATE_CAM_BIST_S6_STATUSr_SET(r,d) (r).vlan_xlate_cam_bist_s6_status[0] = d
#define BCM56504_A0_VLAN_XLATE_CAM_BIST_S6_STATUSr_GET(r) (r).vlan_xlate_cam_bist_s6_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_VLAN_XLATE_CAM_BIST_S6_STATUSr_MATCH_STATUSf_GET(r) (((r).vlan_xlate_cam_bist_s6_status[0]) & 0x1)
#define BCM56504_A0_VLAN_XLATE_CAM_BIST_S6_STATUSr_MATCH_STATUSf_SET(r,f) (r).vlan_xlate_cam_bist_s6_status[0]=(((r).vlan_xlate_cam_bist_s6_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_VLAN_XLATE_CAM_BIST_S6_STATUSr_AINDEX_STATUSf_GET(r) ((((r).vlan_xlate_cam_bist_s6_status[0]) >> 1) & 0x1)
#define BCM56504_A0_VLAN_XLATE_CAM_BIST_S6_STATUSr_AINDEX_STATUSf_SET(r,f) (r).vlan_xlate_cam_bist_s6_status[0]=(((r).vlan_xlate_cam_bist_s6_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_VLAN_XLATE_CAM_BIST_S6_STATUSr_ACTUAL_AINDEXf_GET(r) ((((r).vlan_xlate_cam_bist_s6_status[0]) >> 2) & 0x3ff)
#define BCM56504_A0_VLAN_XLATE_CAM_BIST_S6_STATUSr_ACTUAL_AINDEXf_SET(r,f) (r).vlan_xlate_cam_bist_s6_status[0]=(((r).vlan_xlate_cam_bist_s6_status[0] & ~((uint32_t)0x3ff << 2)) | ((((uint32_t)f) & 0x3ff) << 2))
#define BCM56504_A0_VLAN_XLATE_CAM_BIST_S6_STATUSr_EXPECTED_AINDEXf_GET(r) ((((r).vlan_xlate_cam_bist_s6_status[0]) >> 12) & 0x3ff)
#define BCM56504_A0_VLAN_XLATE_CAM_BIST_S6_STATUSr_EXPECTED_AINDEXf_SET(r,f) (r).vlan_xlate_cam_bist_s6_status[0]=(((r).vlan_xlate_cam_bist_s6_status[0] & ~((uint32_t)0x3ff << 12)) | ((((uint32_t)f) & 0x3ff) << 12))

/*
 * These macros can be used to access VLAN_XLATE_CAM_BIST_S6_STATUS.
 *
 */
#define BCM56504_A0_READ_VLAN_XLATE_CAM_BIST_S6_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_VLAN_XLATE_CAM_BIST_S6_STATUSr,(r._vlan_xlate_cam_bist_s6_status))
#define BCM56504_A0_WRITE_VLAN_XLATE_CAM_BIST_S6_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_VLAN_XLATE_CAM_BIST_S6_STATUSr,&(r._vlan_xlate_cam_bist_s6_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_XLATE_CAM_BIST_S6_STATUSr BCM56504_A0_VLAN_XLATE_CAM_BIST_S6_STATUSr
#define VLAN_XLATE_CAM_BIST_S6_STATUSr_SIZE BCM56504_A0_VLAN_XLATE_CAM_BIST_S6_STATUSr_SIZE
typedef BCM56504_A0_VLAN_XLATE_CAM_BIST_S6_STATUSr_t VLAN_XLATE_CAM_BIST_S6_STATUSr_t;
#define VLAN_XLATE_CAM_BIST_S6_STATUSr_CLR BCM56504_A0_VLAN_XLATE_CAM_BIST_S6_STATUSr_CLR
#define VLAN_XLATE_CAM_BIST_S6_STATUSr_SET BCM56504_A0_VLAN_XLATE_CAM_BIST_S6_STATUSr_SET
#define VLAN_XLATE_CAM_BIST_S6_STATUSr_GET BCM56504_A0_VLAN_XLATE_CAM_BIST_S6_STATUSr_GET
#define VLAN_XLATE_CAM_BIST_S6_STATUSr_MATCH_STATUSf_GET BCM56504_A0_VLAN_XLATE_CAM_BIST_S6_STATUSr_MATCH_STATUSf_GET
#define VLAN_XLATE_CAM_BIST_S6_STATUSr_MATCH_STATUSf_SET BCM56504_A0_VLAN_XLATE_CAM_BIST_S6_STATUSr_MATCH_STATUSf_SET
#define VLAN_XLATE_CAM_BIST_S6_STATUSr_AINDEX_STATUSf_GET BCM56504_A0_VLAN_XLATE_CAM_BIST_S6_STATUSr_AINDEX_STATUSf_GET
#define VLAN_XLATE_CAM_BIST_S6_STATUSr_AINDEX_STATUSf_SET BCM56504_A0_VLAN_XLATE_CAM_BIST_S6_STATUSr_AINDEX_STATUSf_SET
#define VLAN_XLATE_CAM_BIST_S6_STATUSr_ACTUAL_AINDEXf_GET BCM56504_A0_VLAN_XLATE_CAM_BIST_S6_STATUSr_ACTUAL_AINDEXf_GET
#define VLAN_XLATE_CAM_BIST_S6_STATUSr_ACTUAL_AINDEXf_SET BCM56504_A0_VLAN_XLATE_CAM_BIST_S6_STATUSr_ACTUAL_AINDEXf_SET
#define VLAN_XLATE_CAM_BIST_S6_STATUSr_EXPECTED_AINDEXf_GET BCM56504_A0_VLAN_XLATE_CAM_BIST_S6_STATUSr_EXPECTED_AINDEXf_GET
#define VLAN_XLATE_CAM_BIST_S6_STATUSr_EXPECTED_AINDEXf_SET BCM56504_A0_VLAN_XLATE_CAM_BIST_S6_STATUSr_EXPECTED_AINDEXf_SET
#define READ_VLAN_XLATE_CAM_BIST_S6_STATUSr BCM56504_A0_READ_VLAN_XLATE_CAM_BIST_S6_STATUSr
#define WRITE_VLAN_XLATE_CAM_BIST_S6_STATUSr BCM56504_A0_WRITE_VLAN_XLATE_CAM_BIST_S6_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_VLAN_XLATE_CAM_BIST_S6_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  VLAN_XLATE_CAM_BIST_S8_STATUS
 * BLOCKS:   IPIPE
 * DESC:     VLAN_XLATE_CAM_BIST_S8_STATUS
 * SIZE:     32
 * FIELDS:
 *     MATCH_STATUS     Match status
 *     AINDEX           Aindex when match happened
 *
 ******************************************************************************/
#define BCM56504_A0_VLAN_XLATE_CAM_BIST_S8_STATUSr 0x0478000e

#define BCM56504_A0_VLAN_XLATE_CAM_BIST_S8_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program VLAN_XLATE_CAM_BIST_S8_STATUS.
 *
 */
typedef union BCM56504_A0_VLAN_XLATE_CAM_BIST_S8_STATUSr_s {
	uint32_t v[1];
	uint32_t vlan_xlate_cam_bist_s8_status[1];
	uint32_t _vlan_xlate_cam_bist_s8_status;
} BCM56504_A0_VLAN_XLATE_CAM_BIST_S8_STATUSr_t;

#define BCM56504_A0_VLAN_XLATE_CAM_BIST_S8_STATUSr_CLR(r) (r).vlan_xlate_cam_bist_s8_status[0] = 0
#define BCM56504_A0_VLAN_XLATE_CAM_BIST_S8_STATUSr_SET(r,d) (r).vlan_xlate_cam_bist_s8_status[0] = d
#define BCM56504_A0_VLAN_XLATE_CAM_BIST_S8_STATUSr_GET(r) (r).vlan_xlate_cam_bist_s8_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_VLAN_XLATE_CAM_BIST_S8_STATUSr_MATCH_STATUSf_GET(r) (((r).vlan_xlate_cam_bist_s8_status[0]) & 0x1)
#define BCM56504_A0_VLAN_XLATE_CAM_BIST_S8_STATUSr_MATCH_STATUSf_SET(r,f) (r).vlan_xlate_cam_bist_s8_status[0]=(((r).vlan_xlate_cam_bist_s8_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_VLAN_XLATE_CAM_BIST_S8_STATUSr_AINDEXf_GET(r) ((((r).vlan_xlate_cam_bist_s8_status[0]) >> 1) & 0x3ff)
#define BCM56504_A0_VLAN_XLATE_CAM_BIST_S8_STATUSr_AINDEXf_SET(r,f) (r).vlan_xlate_cam_bist_s8_status[0]=(((r).vlan_xlate_cam_bist_s8_status[0] & ~((uint32_t)0x3ff << 1)) | ((((uint32_t)f) & 0x3ff) << 1))

/*
 * These macros can be used to access VLAN_XLATE_CAM_BIST_S8_STATUS.
 *
 */
#define BCM56504_A0_READ_VLAN_XLATE_CAM_BIST_S8_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_VLAN_XLATE_CAM_BIST_S8_STATUSr,(r._vlan_xlate_cam_bist_s8_status))
#define BCM56504_A0_WRITE_VLAN_XLATE_CAM_BIST_S8_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_VLAN_XLATE_CAM_BIST_S8_STATUSr,&(r._vlan_xlate_cam_bist_s8_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_XLATE_CAM_BIST_S8_STATUSr BCM56504_A0_VLAN_XLATE_CAM_BIST_S8_STATUSr
#define VLAN_XLATE_CAM_BIST_S8_STATUSr_SIZE BCM56504_A0_VLAN_XLATE_CAM_BIST_S8_STATUSr_SIZE
typedef BCM56504_A0_VLAN_XLATE_CAM_BIST_S8_STATUSr_t VLAN_XLATE_CAM_BIST_S8_STATUSr_t;
#define VLAN_XLATE_CAM_BIST_S8_STATUSr_CLR BCM56504_A0_VLAN_XLATE_CAM_BIST_S8_STATUSr_CLR
#define VLAN_XLATE_CAM_BIST_S8_STATUSr_SET BCM56504_A0_VLAN_XLATE_CAM_BIST_S8_STATUSr_SET
#define VLAN_XLATE_CAM_BIST_S8_STATUSr_GET BCM56504_A0_VLAN_XLATE_CAM_BIST_S8_STATUSr_GET
#define VLAN_XLATE_CAM_BIST_S8_STATUSr_MATCH_STATUSf_GET BCM56504_A0_VLAN_XLATE_CAM_BIST_S8_STATUSr_MATCH_STATUSf_GET
#define VLAN_XLATE_CAM_BIST_S8_STATUSr_MATCH_STATUSf_SET BCM56504_A0_VLAN_XLATE_CAM_BIST_S8_STATUSr_MATCH_STATUSf_SET
#define VLAN_XLATE_CAM_BIST_S8_STATUSr_AINDEXf_GET BCM56504_A0_VLAN_XLATE_CAM_BIST_S8_STATUSr_AINDEXf_GET
#define VLAN_XLATE_CAM_BIST_S8_STATUSr_AINDEXf_SET BCM56504_A0_VLAN_XLATE_CAM_BIST_S8_STATUSr_AINDEXf_SET
#define READ_VLAN_XLATE_CAM_BIST_S8_STATUSr BCM56504_A0_READ_VLAN_XLATE_CAM_BIST_S8_STATUSr
#define WRITE_VLAN_XLATE_CAM_BIST_S8_STATUSr BCM56504_A0_WRITE_VLAN_XLATE_CAM_BIST_S8_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_VLAN_XLATE_CAM_BIST_S8_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  VLAN_XLATE_CAM_BIST_STATUS
 * BLOCKS:   IPIPE
 * DESC:     VLAN_XLATE_CAM_BIST_STATUS
 * SIZE:     32
 * FIELDS:
 *     BIST_GO          BIST pass/fail flag (1->pass)
 *     BIST_DONE        Inicates if the BIST has completed
 *
 ******************************************************************************/
#define BCM56504_A0_VLAN_XLATE_CAM_BIST_STATUSr 0x04780009

#define BCM56504_A0_VLAN_XLATE_CAM_BIST_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program VLAN_XLATE_CAM_BIST_STATUS.
 *
 */
typedef union BCM56504_A0_VLAN_XLATE_CAM_BIST_STATUSr_s {
	uint32_t v[1];
	uint32_t vlan_xlate_cam_bist_status[1];
	uint32_t _vlan_xlate_cam_bist_status;
} BCM56504_A0_VLAN_XLATE_CAM_BIST_STATUSr_t;

#define BCM56504_A0_VLAN_XLATE_CAM_BIST_STATUSr_CLR(r) (r).vlan_xlate_cam_bist_status[0] = 0
#define BCM56504_A0_VLAN_XLATE_CAM_BIST_STATUSr_SET(r,d) (r).vlan_xlate_cam_bist_status[0] = d
#define BCM56504_A0_VLAN_XLATE_CAM_BIST_STATUSr_GET(r) (r).vlan_xlate_cam_bist_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_VLAN_XLATE_CAM_BIST_STATUSr_BIST_GOf_GET(r) (((r).vlan_xlate_cam_bist_status[0]) & 0x1)
#define BCM56504_A0_VLAN_XLATE_CAM_BIST_STATUSr_BIST_GOf_SET(r,f) (r).vlan_xlate_cam_bist_status[0]=(((r).vlan_xlate_cam_bist_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_VLAN_XLATE_CAM_BIST_STATUSr_BIST_DONEf_GET(r) ((((r).vlan_xlate_cam_bist_status[0]) >> 1) & 0x1)
#define BCM56504_A0_VLAN_XLATE_CAM_BIST_STATUSr_BIST_DONEf_SET(r,f) (r).vlan_xlate_cam_bist_status[0]=(((r).vlan_xlate_cam_bist_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access VLAN_XLATE_CAM_BIST_STATUS.
 *
 */
#define BCM56504_A0_READ_VLAN_XLATE_CAM_BIST_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_VLAN_XLATE_CAM_BIST_STATUSr,(r._vlan_xlate_cam_bist_status))
#define BCM56504_A0_WRITE_VLAN_XLATE_CAM_BIST_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_VLAN_XLATE_CAM_BIST_STATUSr,&(r._vlan_xlate_cam_bist_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_XLATE_CAM_BIST_STATUSr BCM56504_A0_VLAN_XLATE_CAM_BIST_STATUSr
#define VLAN_XLATE_CAM_BIST_STATUSr_SIZE BCM56504_A0_VLAN_XLATE_CAM_BIST_STATUSr_SIZE
typedef BCM56504_A0_VLAN_XLATE_CAM_BIST_STATUSr_t VLAN_XLATE_CAM_BIST_STATUSr_t;
#define VLAN_XLATE_CAM_BIST_STATUSr_CLR BCM56504_A0_VLAN_XLATE_CAM_BIST_STATUSr_CLR
#define VLAN_XLATE_CAM_BIST_STATUSr_SET BCM56504_A0_VLAN_XLATE_CAM_BIST_STATUSr_SET
#define VLAN_XLATE_CAM_BIST_STATUSr_GET BCM56504_A0_VLAN_XLATE_CAM_BIST_STATUSr_GET
#define VLAN_XLATE_CAM_BIST_STATUSr_BIST_GOf_GET BCM56504_A0_VLAN_XLATE_CAM_BIST_STATUSr_BIST_GOf_GET
#define VLAN_XLATE_CAM_BIST_STATUSr_BIST_GOf_SET BCM56504_A0_VLAN_XLATE_CAM_BIST_STATUSr_BIST_GOf_SET
#define VLAN_XLATE_CAM_BIST_STATUSr_BIST_DONEf_GET BCM56504_A0_VLAN_XLATE_CAM_BIST_STATUSr_BIST_DONEf_GET
#define VLAN_XLATE_CAM_BIST_STATUSr_BIST_DONEf_SET BCM56504_A0_VLAN_XLATE_CAM_BIST_STATUSr_BIST_DONEf_SET
#define READ_VLAN_XLATE_CAM_BIST_STATUSr BCM56504_A0_READ_VLAN_XLATE_CAM_BIST_STATUSr
#define WRITE_VLAN_XLATE_CAM_BIST_STATUSr BCM56504_A0_WRITE_VLAN_XLATE_CAM_BIST_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_VLAN_XLATE_CAM_BIST_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  VLAN_XLATE_CAM_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     VLAN_XLATE_CAM_CONTROL
 * SIZE:     32
 * FIELDS:
 *     BIST_EN          BIST enable
 *     SAM              SAM debug bits
 *
 ******************************************************************************/
#define BCM56504_A0_VLAN_XLATE_CAM_CONTROLr 0x04780008

#define BCM56504_A0_VLAN_XLATE_CAM_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program VLAN_XLATE_CAM_CONTROL.
 *
 */
typedef union BCM56504_A0_VLAN_XLATE_CAM_CONTROLr_s {
	uint32_t v[1];
	uint32_t vlan_xlate_cam_control[1];
	uint32_t _vlan_xlate_cam_control;
} BCM56504_A0_VLAN_XLATE_CAM_CONTROLr_t;

#define BCM56504_A0_VLAN_XLATE_CAM_CONTROLr_CLR(r) (r).vlan_xlate_cam_control[0] = 0
#define BCM56504_A0_VLAN_XLATE_CAM_CONTROLr_SET(r,d) (r).vlan_xlate_cam_control[0] = d
#define BCM56504_A0_VLAN_XLATE_CAM_CONTROLr_GET(r) (r).vlan_xlate_cam_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_VLAN_XLATE_CAM_CONTROLr_BIST_ENf_GET(r) (((r).vlan_xlate_cam_control[0]) & 0x1)
#define BCM56504_A0_VLAN_XLATE_CAM_CONTROLr_BIST_ENf_SET(r,f) (r).vlan_xlate_cam_control[0]=(((r).vlan_xlate_cam_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_VLAN_XLATE_CAM_CONTROLr_SAMf_GET(r) ((((r).vlan_xlate_cam_control[0]) >> 1) & 0x7)
#define BCM56504_A0_VLAN_XLATE_CAM_CONTROLr_SAMf_SET(r,f) (r).vlan_xlate_cam_control[0]=(((r).vlan_xlate_cam_control[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))

/*
 * These macros can be used to access VLAN_XLATE_CAM_CONTROL.
 *
 */
#define BCM56504_A0_READ_VLAN_XLATE_CAM_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_VLAN_XLATE_CAM_CONTROLr,(r._vlan_xlate_cam_control))
#define BCM56504_A0_WRITE_VLAN_XLATE_CAM_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_VLAN_XLATE_CAM_CONTROLr,&(r._vlan_xlate_cam_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_XLATE_CAM_CONTROLr BCM56504_A0_VLAN_XLATE_CAM_CONTROLr
#define VLAN_XLATE_CAM_CONTROLr_SIZE BCM56504_A0_VLAN_XLATE_CAM_CONTROLr_SIZE
typedef BCM56504_A0_VLAN_XLATE_CAM_CONTROLr_t VLAN_XLATE_CAM_CONTROLr_t;
#define VLAN_XLATE_CAM_CONTROLr_CLR BCM56504_A0_VLAN_XLATE_CAM_CONTROLr_CLR
#define VLAN_XLATE_CAM_CONTROLr_SET BCM56504_A0_VLAN_XLATE_CAM_CONTROLr_SET
#define VLAN_XLATE_CAM_CONTROLr_GET BCM56504_A0_VLAN_XLATE_CAM_CONTROLr_GET
#define VLAN_XLATE_CAM_CONTROLr_BIST_ENf_GET BCM56504_A0_VLAN_XLATE_CAM_CONTROLr_BIST_ENf_GET
#define VLAN_XLATE_CAM_CONTROLr_BIST_ENf_SET BCM56504_A0_VLAN_XLATE_CAM_CONTROLr_BIST_ENf_SET
#define VLAN_XLATE_CAM_CONTROLr_SAMf_GET BCM56504_A0_VLAN_XLATE_CAM_CONTROLr_SAMf_GET
#define VLAN_XLATE_CAM_CONTROLr_SAMf_SET BCM56504_A0_VLAN_XLATE_CAM_CONTROLr_SAMf_SET
#define READ_VLAN_XLATE_CAM_CONTROLr BCM56504_A0_READ_VLAN_XLATE_CAM_CONTROLr
#define WRITE_VLAN_XLATE_CAM_CONTROLr BCM56504_A0_WRITE_VLAN_XLATE_CAM_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_VLAN_XLATE_CAM_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  VLAN_XLATE_DATA_ONLY
 * BLOCKS:   IPIPE
 * DESC:     Data SRAM for VLAN_XLATE BCAM.
 * SIZE:     17
 * FIELDS:
 *     RPE              RPE bit
 *     PRI              Priority to be assigned
 *     NEW_VLAN_ID      VLAN ID to be assigned
 *     ADD_VID          Add the VLAN ID
 *
 ******************************************************************************/
#define BCM56504_A0_VLAN_XLATE_DATA_ONLYm 0x04780000

#define BCM56504_A0_VLAN_XLATE_DATA_ONLYm_MIN 0
#define BCM56504_A0_VLAN_XLATE_DATA_ONLYm_MAX 767
#define BCM56504_A0_VLAN_XLATE_DATA_ONLYm_CMAX(u) 767
#define BCM56504_A0_VLAN_XLATE_DATA_ONLYm_SIZE 3

/*
 * This structure should be used to declare and program VLAN_XLATE_DATA_ONLY.
 *
 */
typedef union BCM56504_A0_VLAN_XLATE_DATA_ONLYm_s {
	uint32_t v[1];
	uint32_t vlan_xlate_data_only[1];
	uint32_t _vlan_xlate_data_only;
} BCM56504_A0_VLAN_XLATE_DATA_ONLYm_t;

#define BCM56504_A0_VLAN_XLATE_DATA_ONLYm_CLR(r) (r).vlan_xlate_data_only[0] = 0
#define BCM56504_A0_VLAN_XLATE_DATA_ONLYm_SET(r,d) (r).vlan_xlate_data_only[0] = d
#define BCM56504_A0_VLAN_XLATE_DATA_ONLYm_GET(r) (r).vlan_xlate_data_only[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_VLAN_XLATE_DATA_ONLYm_RPEf_GET(r) (((r).vlan_xlate_data_only[0]) & 0x1)
#define BCM56504_A0_VLAN_XLATE_DATA_ONLYm_RPEf_SET(r,f) (r).vlan_xlate_data_only[0]=(((r).vlan_xlate_data_only[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_VLAN_XLATE_DATA_ONLYm_PRIf_GET(r) ((((r).vlan_xlate_data_only[0]) >> 1) & 0x7)
#define BCM56504_A0_VLAN_XLATE_DATA_ONLYm_PRIf_SET(r,f) (r).vlan_xlate_data_only[0]=(((r).vlan_xlate_data_only[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define BCM56504_A0_VLAN_XLATE_DATA_ONLYm_NEW_VLAN_IDf_GET(r) ((((r).vlan_xlate_data_only[0]) >> 4) & 0xfff)
#define BCM56504_A0_VLAN_XLATE_DATA_ONLYm_NEW_VLAN_IDf_SET(r,f) (r).vlan_xlate_data_only[0]=(((r).vlan_xlate_data_only[0] & ~((uint32_t)0xfff << 4)) | ((((uint32_t)f) & 0xfff) << 4))
#define BCM56504_A0_VLAN_XLATE_DATA_ONLYm_ADD_VIDf_GET(r) ((((r).vlan_xlate_data_only[0]) >> 16) & 0x1)
#define BCM56504_A0_VLAN_XLATE_DATA_ONLYm_ADD_VIDf_SET(r,f) (r).vlan_xlate_data_only[0]=(((r).vlan_xlate_data_only[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))

/*
 * These macros can be used to access VLAN_XLATE_DATA_ONLY.
 *
 */
#define BCM56504_A0_READ_VLAN_XLATE_DATA_ONLYm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_VLAN_XLATE_DATA_ONLYm,i,(m._vlan_xlate_data_only),1)
#define BCM56504_A0_WRITE_VLAN_XLATE_DATA_ONLYm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_VLAN_XLATE_DATA_ONLYm,i,&(m._vlan_xlate_data_only),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_XLATE_DATA_ONLYm BCM56504_A0_VLAN_XLATE_DATA_ONLYm
#define VLAN_XLATE_DATA_ONLYm_MIN BCM56504_A0_VLAN_XLATE_DATA_ONLYm_MIN
#define VLAN_XLATE_DATA_ONLYm_MAX BCM56504_A0_VLAN_XLATE_DATA_ONLYm_MAX
#define VLAN_XLATE_DATA_ONLYm_CMAX(u) BCM56504_A0_VLAN_XLATE_DATA_ONLYm_CMAX(u)
#define VLAN_XLATE_DATA_ONLYm_SIZE BCM56504_A0_VLAN_XLATE_DATA_ONLYm_SIZE
typedef BCM56504_A0_VLAN_XLATE_DATA_ONLYm_t VLAN_XLATE_DATA_ONLYm_t;
#define VLAN_XLATE_DATA_ONLYm_CLR BCM56504_A0_VLAN_XLATE_DATA_ONLYm_CLR
#define VLAN_XLATE_DATA_ONLYm_SET BCM56504_A0_VLAN_XLATE_DATA_ONLYm_SET
#define VLAN_XLATE_DATA_ONLYm_GET BCM56504_A0_VLAN_XLATE_DATA_ONLYm_GET
#define VLAN_XLATE_DATA_ONLYm_RPEf_GET BCM56504_A0_VLAN_XLATE_DATA_ONLYm_RPEf_GET
#define VLAN_XLATE_DATA_ONLYm_RPEf_SET BCM56504_A0_VLAN_XLATE_DATA_ONLYm_RPEf_SET
#define VLAN_XLATE_DATA_ONLYm_PRIf_GET BCM56504_A0_VLAN_XLATE_DATA_ONLYm_PRIf_GET
#define VLAN_XLATE_DATA_ONLYm_PRIf_SET BCM56504_A0_VLAN_XLATE_DATA_ONLYm_PRIf_SET
#define VLAN_XLATE_DATA_ONLYm_NEW_VLAN_IDf_GET BCM56504_A0_VLAN_XLATE_DATA_ONLYm_NEW_VLAN_IDf_GET
#define VLAN_XLATE_DATA_ONLYm_NEW_VLAN_IDf_SET BCM56504_A0_VLAN_XLATE_DATA_ONLYm_NEW_VLAN_IDf_SET
#define VLAN_XLATE_DATA_ONLYm_ADD_VIDf_GET BCM56504_A0_VLAN_XLATE_DATA_ONLYm_ADD_VIDf_GET
#define VLAN_XLATE_DATA_ONLYm_ADD_VIDf_SET BCM56504_A0_VLAN_XLATE_DATA_ONLYm_ADD_VIDf_SET
#define READ_VLAN_XLATE_DATA_ONLYm BCM56504_A0_READ_VLAN_XLATE_DATA_ONLYm
#define WRITE_VLAN_XLATE_DATA_ONLYm BCM56504_A0_WRITE_VLAN_XLATE_DATA_ONLYm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_VLAN_XLATE_DATA_ONLYm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * MEMORY:  VLAN_XLATE_ONLY
 * BLOCKS:   IPIPE
 * DESC:     BCAM for VLAN trans of tagged pkts.
 * SIZE:     18
 * FIELDS:
 *     VALID            Indicates that the entry is valid.
 *     INGRESS_PORT     Source port part of the key
 *     VLAN_ID          VLAN ID part of the key
 *
 ******************************************************************************/
#define BCM56504_A0_VLAN_XLATE_ONLYm 0x04770000

#define BCM56504_A0_VLAN_XLATE_ONLYm_MIN 0
#define BCM56504_A0_VLAN_XLATE_ONLYm_MAX 767
#define BCM56504_A0_VLAN_XLATE_ONLYm_CMAX(u) 767
#define BCM56504_A0_VLAN_XLATE_ONLYm_SIZE 3

/*
 * This structure should be used to declare and program VLAN_XLATE_ONLY.
 *
 */
typedef union BCM56504_A0_VLAN_XLATE_ONLYm_s {
	uint32_t v[1];
	uint32_t vlan_xlate_only[1];
	uint32_t _vlan_xlate_only;
} BCM56504_A0_VLAN_XLATE_ONLYm_t;

#define BCM56504_A0_VLAN_XLATE_ONLYm_CLR(r) (r).vlan_xlate_only[0] = 0
#define BCM56504_A0_VLAN_XLATE_ONLYm_SET(r,d) (r).vlan_xlate_only[0] = d
#define BCM56504_A0_VLAN_XLATE_ONLYm_GET(r) (r).vlan_xlate_only[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_VLAN_XLATE_ONLYm_VALIDf_GET(r) (((r).vlan_xlate_only[0]) & 0x1)
#define BCM56504_A0_VLAN_XLATE_ONLYm_VALIDf_SET(r,f) (r).vlan_xlate_only[0]=(((r).vlan_xlate_only[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_VLAN_XLATE_ONLYm_INGRESS_PORTf_GET(r) ((((r).vlan_xlate_only[0]) >> 1) & 0x1f)
#define BCM56504_A0_VLAN_XLATE_ONLYm_INGRESS_PORTf_SET(r,f) (r).vlan_xlate_only[0]=(((r).vlan_xlate_only[0] & ~((uint32_t)0x1f << 1)) | ((((uint32_t)f) & 0x1f) << 1))
#define BCM56504_A0_VLAN_XLATE_ONLYm_VLAN_IDf_GET(r) ((((r).vlan_xlate_only[0]) >> 6) & 0xfff)
#define BCM56504_A0_VLAN_XLATE_ONLYm_VLAN_IDf_SET(r,f) (r).vlan_xlate_only[0]=(((r).vlan_xlate_only[0] & ~((uint32_t)0xfff << 6)) | ((((uint32_t)f) & 0xfff) << 6))

/*
 * These macros can be used to access VLAN_XLATE_ONLY.
 *
 */
#define BCM56504_A0_READ_VLAN_XLATE_ONLYm(u,i,m) cdk_xgs_mem_read(u,BCM56504_A0_VLAN_XLATE_ONLYm,i,(m._vlan_xlate_only),1)
#define BCM56504_A0_WRITE_VLAN_XLATE_ONLYm(u,i,m) cdk_xgs_mem_write(u,BCM56504_A0_VLAN_XLATE_ONLYm,i,&(m._vlan_xlate_only),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_XLATE_ONLYm BCM56504_A0_VLAN_XLATE_ONLYm
#define VLAN_XLATE_ONLYm_MIN BCM56504_A0_VLAN_XLATE_ONLYm_MIN
#define VLAN_XLATE_ONLYm_MAX BCM56504_A0_VLAN_XLATE_ONLYm_MAX
#define VLAN_XLATE_ONLYm_CMAX(u) BCM56504_A0_VLAN_XLATE_ONLYm_CMAX(u)
#define VLAN_XLATE_ONLYm_SIZE BCM56504_A0_VLAN_XLATE_ONLYm_SIZE
typedef BCM56504_A0_VLAN_XLATE_ONLYm_t VLAN_XLATE_ONLYm_t;
#define VLAN_XLATE_ONLYm_CLR BCM56504_A0_VLAN_XLATE_ONLYm_CLR
#define VLAN_XLATE_ONLYm_SET BCM56504_A0_VLAN_XLATE_ONLYm_SET
#define VLAN_XLATE_ONLYm_GET BCM56504_A0_VLAN_XLATE_ONLYm_GET
#define VLAN_XLATE_ONLYm_VALIDf_GET BCM56504_A0_VLAN_XLATE_ONLYm_VALIDf_GET
#define VLAN_XLATE_ONLYm_VALIDf_SET BCM56504_A0_VLAN_XLATE_ONLYm_VALIDf_SET
#define VLAN_XLATE_ONLYm_INGRESS_PORTf_GET BCM56504_A0_VLAN_XLATE_ONLYm_INGRESS_PORTf_GET
#define VLAN_XLATE_ONLYm_INGRESS_PORTf_SET BCM56504_A0_VLAN_XLATE_ONLYm_INGRESS_PORTf_SET
#define VLAN_XLATE_ONLYm_VLAN_IDf_GET BCM56504_A0_VLAN_XLATE_ONLYm_VLAN_IDf_GET
#define VLAN_XLATE_ONLYm_VLAN_IDf_SET BCM56504_A0_VLAN_XLATE_ONLYm_VLAN_IDf_SET
#define READ_VLAN_XLATE_ONLYm BCM56504_A0_READ_VLAN_XLATE_ONLYm
#define WRITE_VLAN_XLATE_ONLYm BCM56504_A0_WRITE_VLAN_XLATE_ONLYm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_VLAN_XLATE_ONLYm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  WRRWEIGHTS
 * BLOCKS:   MMU
 * DESC:      WRR Weight for each COS
 * SIZE:     32
 * FIELDS:
 *     COS0WEIGHT       When Weighted Round Robin selects, this register is COS 0 Weight,Define how many packet can  be trasmitted in one run.If value is zero, this COS 0 will be a pure priority scheduling.When Deficit Round Robin Queueing selects, this register is COS 0,Define how many bytes can  be trasmitted in one run.If value is zero, this COS 0 will be a pure priority scheduling.COS0Weight=0x0:   pure prioirty,COS0Weight=0x1:    10k Bytes,COS0Weight=0x2:    20k Bytes,COS0Weight=0x3:    40k Bytes,COS0Weight=0x4:    80k Bytes,COS0Weight=0x5:   160k Byets,COS0Weight=0x6:   320k Byets,COS0Weight=0x7:   640k Byets.COS0Weight=0x8:  1280k Bytes,COS0Weight=0x9:  2560k Bytes,COS0Weight=0xa:  5120k Bytes,COS0Weight=0xb:    10M Bytes,COS0Weight=0xc:    20M Byets,COS0Weight=0xd:    40M Byets,COS0Weight=0xe:    80M Byets,COS0Weight=0xf:   160M Byets.
 *     COS1WEIGHT       When Weighted Round Robin selects, this register is COS 1 Weight,Define how many packet can  be trasmitted in one run.If value is zero, this COS 1 will be a pure priority scheduling.When Deficit Round Robin Queueing selects, this register is COS 1,Define how many bytes can  be trasmitted in one run. If value is zero, this COS 1 will be a pure priority scheduling.COS1Weight=0x0:   pure prioirty,COS1Weight=0x1:    10k Bytes,COS1Weight=0x2:    20k Bytes,COS1Weight=0x3:    40k Bytes,COS1Weight=0x4:    80k Bytes,COS1Weight=0x5:   160k Byets,COS1Weight=0x6:   320k Byets,COS1Weight=0x7:   640k Byets.COS1Weight=0x8:  1280k Bytes,COS1Weight=0x9:  2560k Bytes,COS1Weight=0xa:  5120k Bytes,COS1Weight=0xb:    10M Bytes,COS1Weight=0xc:    20M Byets,COS1Weight=0xd:    40M Byets,COS1Weight=0xe:    80M Byets,COS1Weight=0xf:   160M Byets.
 *     COS2WEIGHT       When Weighted Round Robin selects, this register is COS 2 Weight,Define how many packet can  be trasmitted in one run.If value is zero, this COS 2 will be a pure priority scheduling.When Deficit Round Robin Queueing selects, this register is COS 2,Define how many bytes can  be trasmitted in one run. If value is zero, this COS 2 will be a pure priority scheduling.COS2Weight=0x0:   pure prioirty,COS2Weight=0x1:    10k Bytes,COS2Weight=0x2:    20k Bytes,COS2Weight=0x3:    40k Bytes,COS2Weight=0x4:    80k Bytes,COS2Weight=0x5:   160k Byets,COS2Weight=0x6:   320k Byets,COS2Weight=0x7:   640k Byets.COS2Weight=0x8:  1280k Bytes,COS2Weight=0x9:  2560k Bytes,COS2Weight=0xa:  5120k Bytes,COS2Weight=0xb:    10M Bytes,COS2Weight=0xc:    20M Byets,COS2Weight=0xd:    40M Byets,COS2Weight=0xe:    80M Byets,COS2Weight=0xf:   160M Byets.
 *     COS3WEIGHT       When Weighted Round Robin selects, this register is COS 3 Weight,Define how many packet can  be trasmitted in one run.If value is zero, this COS 3 will be a pure priority scheduling.When Deficit Round Robin Queueing selects, this register is COS 3,Define how many bytes can  be trasmitted in one run. If value is zero, this COS 3 will be a pure priority scheduling.COS3Weight=0x0:   pure prioirty,COS3Weight=0x1:    10k Bytes,COS3Weight=0x2:    20k Bytes,COS3Weight=0x3:    40k Bytes,COS3Weight=0x4:    80k Bytes,COS3Weight=0x5:   160k Byets,COS3Weight=0x6:   320k Byets,COS3Weight=0x7:   640k Byets.COS3Weight=0x8:  1280k Bytes,COS3Weight=0x9:  2560k Bytes,COS3Weight=0xa:  5120k Bytes,COS3Weight=0xb:    10M Bytes,COS3Weight=0xc:    20M Byets,COS3Weight=0xd:    40M Byets,COS3Weight=0xe:    80M Byets,COS3Weight=0xf:   160M Byets.
 *     COS4WEIGHT       When Weighted Round Robin selects, this register is COS 4 Weight,Define how many packet can  be trasmitted in one run.If value is zero, this COS 4 will be a pure priority scheduling.When Deficit Round Robin Queueing selects, this register is COS 4,Define how many bytes can  be trasmitted in one run. If value is zero, this COS 4 will be a pure priority scheduling.COS4Weight=0x0:   pure prioirty,COS4Weight=0x1:    10k Bytes,COS4Weight=0x2:    20k Bytes,COS4Weight=0x3:    40k Bytes,COS4Weight=0x4:    80k Bytes,COS4Weight=0x5:   160k Byets,COS4Weight=0x6:   320k Byets,COS4Weight=0x7:   640k Byets.COS4Weight=0x8:  1280k Bytes,COS4Weight=0x9:  2560k Bytes,COS4Weight=0xa:  5120k Bytes,COS4Weight=0xb:    10M Bytes,COS4Weight=0xc:    20M Byets,COS4Weight=0xd:    40M Byets,COS4Weight=0xe:    80M Byets,COS4Weight=0xf:   160M Byets.
 *     COS5WEIGHT       When Weighted Round Robin selects, this register is COS 5 Weight,Define how many packet can  be trasmitted in one run.If value is zero, this COS 5 will be a pure priority scheduling.When Deficit Round Robin Queueing selects, this register is COS 5,Define how many bytes can  be trasmitted in one run. Only 3 bits of this 4 bits register are used in DRR queueing mode.If value is zero, this COS 5 will be a pure priority scheduling.COS5Weight=0x0:   pure prioirty,COS5Weight=0x1:    10k Bytes,COS5Weight=0x2:    20k Bytes,COS5Weight=0x3:    40k Bytes,COS5Weight=0x4:    80k Bytes,COS5Weight=0x5:   160k Byets,COS5Weight=0x6:   320k Byets,COS5Weight=0x7:   640k Byets.COS5Weight=0x8:  1280k Bytes,COS5Weight=0x9:  2560k Bytes,COS5Weight=0xa:  5120k Bytes,COS5Weight=0xb:    10M Bytes,COS5Weight=0xc:    20M Byets,COS5Weight=0xd:    40M Byets,COS5Weight=0xe:    80M Byets,COS5Weight=0xf:   160M Byets.
 *     COS6WEIGHT       When Weighted Round Robin selects, this register is COS 6 Weight,Define how many packet can  be trasmitted in one run.If value is zero, this COS 6 will be a pure priority scheduling.When Deficit Round Robin Queueing selects, this register is COS 6,Define how many bytes can  be trasmitted in one run. If value is zero, this COS 6 will be a pure priority scheduling.COS6Weight=0x0:   pure prioirty,COS6Weight=0x1:    10k Bytes,COS6Weight=0x2:    20k Bytes,COS6Weight=0x3:    40k Bytes,COS6Weight=0x4:    80k Bytes,COS6Weight=0x5:   160k Byets,COS6Weight=0x6:   320k Byets,COS6Weight=0x7:   640k Byets.COS6Weight=0x8:  1280k Bytes,COS6Weight=0x9:  2560k Bytes,COS6Weight=0xa:  5120k Bytes,COS6Weight=0xb:    10M Bytes,COS6Weight=0xc:    20M Byets,COS6Weight=0xd:    40M Byets,COS6Weight=0xe:    80M Byets,COS6Weight=0xf:   160M Byets.
 *     COS7WEIGHT       When Weighted Round Robin selects, this register is COS 7 Weight,Define how many packet can  be trasmitted in one run.If value is zero, this COS 7 will be a pure priority scheduling.When Deficit Round Robin Queueing selects, this register is COS 7,Define how many bytes can  be trasmitted in one run. If value is zero, this COS 7 will be a pure priority scheduling.COS7Weight=0x0:   pure prioirty,COS7Weight=0x1:    10k Bytes,COS7Weight=0x2:    20k Bytes,COS7Weight=0x3:    40k Bytes,COS7Weight=0x4:    80k Bytes,COS7Weight=0x5:   160k Byets,COS7Weight=0x6:   320k Byets,COS7Weight=0x7:   640k Byets.COS7Weight=0x8:  1280k Bytes,COS7Weight=0x9:  2560k Bytes,COS7Weight=0xa:  5120k Bytes,COS7Weight=0xb:    10M Bytes,COS7Weight=0xc:    20M Byets,COS7Weight=0xd:    40M Byets,COS7Weight=0xe:    80M Byets,COS7Weight=0xf:   160M Byets.
 *
 ******************************************************************************/
#define BCM56504_A0_WRRWEIGHTSr 0x00600046

#define BCM56504_A0_WRRWEIGHTSr_SIZE 4

/*
 * This structure should be used to declare and program WRRWEIGHTS.
 *
 */
typedef union BCM56504_A0_WRRWEIGHTSr_s {
	uint32_t v[1];
	uint32_t wrrweights[1];
	uint32_t _wrrweights;
} BCM56504_A0_WRRWEIGHTSr_t;

#define BCM56504_A0_WRRWEIGHTSr_CLR(r) (r).wrrweights[0] = 0
#define BCM56504_A0_WRRWEIGHTSr_SET(r,d) (r).wrrweights[0] = d
#define BCM56504_A0_WRRWEIGHTSr_GET(r) (r).wrrweights[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_WRRWEIGHTSr_COS0WEIGHTf_GET(r) (((r).wrrweights[0]) & 0xf)
#define BCM56504_A0_WRRWEIGHTSr_COS0WEIGHTf_SET(r,f) (r).wrrweights[0]=(((r).wrrweights[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56504_A0_WRRWEIGHTSr_COS1WEIGHTf_GET(r) ((((r).wrrweights[0]) >> 4) & 0xf)
#define BCM56504_A0_WRRWEIGHTSr_COS1WEIGHTf_SET(r,f) (r).wrrweights[0]=(((r).wrrweights[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56504_A0_WRRWEIGHTSr_COS2WEIGHTf_GET(r) ((((r).wrrweights[0]) >> 8) & 0xf)
#define BCM56504_A0_WRRWEIGHTSr_COS2WEIGHTf_SET(r,f) (r).wrrweights[0]=(((r).wrrweights[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM56504_A0_WRRWEIGHTSr_COS3WEIGHTf_GET(r) ((((r).wrrweights[0]) >> 12) & 0xf)
#define BCM56504_A0_WRRWEIGHTSr_COS3WEIGHTf_SET(r,f) (r).wrrweights[0]=(((r).wrrweights[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM56504_A0_WRRWEIGHTSr_COS4WEIGHTf_GET(r) ((((r).wrrweights[0]) >> 16) & 0xf)
#define BCM56504_A0_WRRWEIGHTSr_COS4WEIGHTf_SET(r,f) (r).wrrweights[0]=(((r).wrrweights[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM56504_A0_WRRWEIGHTSr_COS5WEIGHTf_GET(r) ((((r).wrrweights[0]) >> 20) & 0xf)
#define BCM56504_A0_WRRWEIGHTSr_COS5WEIGHTf_SET(r,f) (r).wrrweights[0]=(((r).wrrweights[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM56504_A0_WRRWEIGHTSr_COS6WEIGHTf_GET(r) ((((r).wrrweights[0]) >> 24) & 0xf)
#define BCM56504_A0_WRRWEIGHTSr_COS6WEIGHTf_SET(r,f) (r).wrrweights[0]=(((r).wrrweights[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM56504_A0_WRRWEIGHTSr_COS7WEIGHTf_GET(r) ((((r).wrrweights[0]) >> 28) & 0xf)
#define BCM56504_A0_WRRWEIGHTSr_COS7WEIGHTf_SET(r,f) (r).wrrweights[0]=(((r).wrrweights[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access WRRWEIGHTS.
 *
 */
#define BCM56504_A0_READ_WRRWEIGHTSr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_WRRWEIGHTSr,(r._wrrweights))
#define BCM56504_A0_WRITE_WRRWEIGHTSr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_WRRWEIGHTSr,&(r._wrrweights))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define WRRWEIGHTSr BCM56504_A0_WRRWEIGHTSr
#define WRRWEIGHTSr_SIZE BCM56504_A0_WRRWEIGHTSr_SIZE
typedef BCM56504_A0_WRRWEIGHTSr_t WRRWEIGHTSr_t;
#define WRRWEIGHTSr_CLR BCM56504_A0_WRRWEIGHTSr_CLR
#define WRRWEIGHTSr_SET BCM56504_A0_WRRWEIGHTSr_SET
#define WRRWEIGHTSr_GET BCM56504_A0_WRRWEIGHTSr_GET
#define WRRWEIGHTSr_COS0WEIGHTf_GET BCM56504_A0_WRRWEIGHTSr_COS0WEIGHTf_GET
#define WRRWEIGHTSr_COS0WEIGHTf_SET BCM56504_A0_WRRWEIGHTSr_COS0WEIGHTf_SET
#define WRRWEIGHTSr_COS1WEIGHTf_GET BCM56504_A0_WRRWEIGHTSr_COS1WEIGHTf_GET
#define WRRWEIGHTSr_COS1WEIGHTf_SET BCM56504_A0_WRRWEIGHTSr_COS1WEIGHTf_SET
#define WRRWEIGHTSr_COS2WEIGHTf_GET BCM56504_A0_WRRWEIGHTSr_COS2WEIGHTf_GET
#define WRRWEIGHTSr_COS2WEIGHTf_SET BCM56504_A0_WRRWEIGHTSr_COS2WEIGHTf_SET
#define WRRWEIGHTSr_COS3WEIGHTf_GET BCM56504_A0_WRRWEIGHTSr_COS3WEIGHTf_GET
#define WRRWEIGHTSr_COS3WEIGHTf_SET BCM56504_A0_WRRWEIGHTSr_COS3WEIGHTf_SET
#define WRRWEIGHTSr_COS4WEIGHTf_GET BCM56504_A0_WRRWEIGHTSr_COS4WEIGHTf_GET
#define WRRWEIGHTSr_COS4WEIGHTf_SET BCM56504_A0_WRRWEIGHTSr_COS4WEIGHTf_SET
#define WRRWEIGHTSr_COS5WEIGHTf_GET BCM56504_A0_WRRWEIGHTSr_COS5WEIGHTf_GET
#define WRRWEIGHTSr_COS5WEIGHTf_SET BCM56504_A0_WRRWEIGHTSr_COS5WEIGHTf_SET
#define WRRWEIGHTSr_COS6WEIGHTf_GET BCM56504_A0_WRRWEIGHTSr_COS6WEIGHTf_GET
#define WRRWEIGHTSr_COS6WEIGHTf_SET BCM56504_A0_WRRWEIGHTSr_COS6WEIGHTf_SET
#define WRRWEIGHTSr_COS7WEIGHTf_GET BCM56504_A0_WRRWEIGHTSr_COS7WEIGHTf_GET
#define WRRWEIGHTSr_COS7WEIGHTf_SET BCM56504_A0_WRRWEIGHTSr_COS7WEIGHTf_SET
#define READ_WRRWEIGHTSr BCM56504_A0_READ_WRRWEIGHTSr
#define WRITE_WRRWEIGHTSr BCM56504_A0_WRITE_WRRWEIGHTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_WRRWEIGHTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  XBOD_OVRFLW
 * BLOCKS:   XPORT0
 * DESC:     XBOD overflow status register
 * SIZE:     32
 * FIELDS:
 *     OVRFLW           XBOD FIFO overflow flag
 *
 ******************************************************************************/
#define BCM56504_A0_XBOD_OVRFLWr 0x00f80020

#define BCM56504_A0_XBOD_OVRFLWr_SIZE 4

/*
 * This structure should be used to declare and program XBOD_OVRFLW.
 *
 */
typedef union BCM56504_A0_XBOD_OVRFLWr_s {
	uint32_t v[1];
	uint32_t xbod_ovrflw[1];
	uint32_t _xbod_ovrflw;
} BCM56504_A0_XBOD_OVRFLWr_t;

#define BCM56504_A0_XBOD_OVRFLWr_CLR(r) (r).xbod_ovrflw[0] = 0
#define BCM56504_A0_XBOD_OVRFLWr_SET(r,d) (r).xbod_ovrflw[0] = d
#define BCM56504_A0_XBOD_OVRFLWr_GET(r) (r).xbod_ovrflw[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_XBOD_OVRFLWr_OVRFLWf_GET(r) (((r).xbod_ovrflw[0]) & 0x1)
#define BCM56504_A0_XBOD_OVRFLWr_OVRFLWf_SET(r,f) (r).xbod_ovrflw[0]=(((r).xbod_ovrflw[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access XBOD_OVRFLW.
 *
 */
#define BCM56504_A0_READ_XBOD_OVRFLWr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_XBOD_OVRFLWr,(r._xbod_ovrflw))
#define BCM56504_A0_WRITE_XBOD_OVRFLWr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_XBOD_OVRFLWr,&(r._xbod_ovrflw))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XBOD_OVRFLWr BCM56504_A0_XBOD_OVRFLWr
#define XBOD_OVRFLWr_SIZE BCM56504_A0_XBOD_OVRFLWr_SIZE
typedef BCM56504_A0_XBOD_OVRFLWr_t XBOD_OVRFLWr_t;
#define XBOD_OVRFLWr_CLR BCM56504_A0_XBOD_OVRFLWr_CLR
#define XBOD_OVRFLWr_SET BCM56504_A0_XBOD_OVRFLWr_SET
#define XBOD_OVRFLWr_GET BCM56504_A0_XBOD_OVRFLWr_GET
#define XBOD_OVRFLWr_OVRFLWf_GET BCM56504_A0_XBOD_OVRFLWr_OVRFLWf_GET
#define XBOD_OVRFLWr_OVRFLWf_SET BCM56504_A0_XBOD_OVRFLWr_OVRFLWf_SET
#define READ_XBOD_OVRFLWr BCM56504_A0_READ_XBOD_OVRFLWr
#define WRITE_XBOD_OVRFLWr BCM56504_A0_WRITE_XBOD_OVRFLWr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_XBOD_OVRFLWr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  XHOL_D0
 * BLOCKS:   XPORT0
 * DESC:     XPORT E2E HOL Data 1st 4 bytes
 * SIZE:     32
 * FIELDS:
 *     DATA_BYTES_0_3   XPORT E2E HOL Data 1st 4 bytes
 *
 ******************************************************************************/
#define BCM56504_A0_XHOL_D0r 0x00f8000e

#define BCM56504_A0_XHOL_D0r_SIZE 4

/*
 * This structure should be used to declare and program XHOL_D0.
 *
 */
typedef union BCM56504_A0_XHOL_D0r_s {
	uint32_t v[1];
	uint32_t xhol_d0[1];
	uint32_t _xhol_d0;
} BCM56504_A0_XHOL_D0r_t;

#define BCM56504_A0_XHOL_D0r_CLR(r) (r).xhol_d0[0] = 0
#define BCM56504_A0_XHOL_D0r_SET(r,d) (r).xhol_d0[0] = d
#define BCM56504_A0_XHOL_D0r_GET(r) (r).xhol_d0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_XHOL_D0r_DATA_BYTES_0_3f_GET(r) ((r).xhol_d0[0])
#define BCM56504_A0_XHOL_D0r_DATA_BYTES_0_3f_SET(r,f) (r).xhol_d0[0]=((uint32_t)f)

/*
 * These macros can be used to access XHOL_D0.
 *
 */
#define BCM56504_A0_READ_XHOL_D0r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_XHOL_D0r,(r._xhol_d0))
#define BCM56504_A0_WRITE_XHOL_D0r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_XHOL_D0r,&(r._xhol_d0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XHOL_D0r BCM56504_A0_XHOL_D0r
#define XHOL_D0r_SIZE BCM56504_A0_XHOL_D0r_SIZE
typedef BCM56504_A0_XHOL_D0r_t XHOL_D0r_t;
#define XHOL_D0r_CLR BCM56504_A0_XHOL_D0r_CLR
#define XHOL_D0r_SET BCM56504_A0_XHOL_D0r_SET
#define XHOL_D0r_GET BCM56504_A0_XHOL_D0r_GET
#define XHOL_D0r_DATA_BYTES_0_3f_GET BCM56504_A0_XHOL_D0r_DATA_BYTES_0_3f_GET
#define XHOL_D0r_DATA_BYTES_0_3f_SET BCM56504_A0_XHOL_D0r_DATA_BYTES_0_3f_SET
#define READ_XHOL_D0r BCM56504_A0_READ_XHOL_D0r
#define WRITE_XHOL_D0r BCM56504_A0_WRITE_XHOL_D0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_XHOL_D0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  XHOL_D1
 * BLOCKS:   XPORT0
 * DESC:     XPORT E2E HOL Data 2nd 4 bytes
 * SIZE:     32
 * FIELDS:
 *     DATA_BYTES_4_7   XPORT E2E HOL Data 2nd 4 bytes
 *
 ******************************************************************************/
#define BCM56504_A0_XHOL_D1r 0x00f8000f

#define BCM56504_A0_XHOL_D1r_SIZE 4

/*
 * This structure should be used to declare and program XHOL_D1.
 *
 */
typedef union BCM56504_A0_XHOL_D1r_s {
	uint32_t v[1];
	uint32_t xhol_d1[1];
	uint32_t _xhol_d1;
} BCM56504_A0_XHOL_D1r_t;

#define BCM56504_A0_XHOL_D1r_CLR(r) (r).xhol_d1[0] = 0
#define BCM56504_A0_XHOL_D1r_SET(r,d) (r).xhol_d1[0] = d
#define BCM56504_A0_XHOL_D1r_GET(r) (r).xhol_d1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_XHOL_D1r_DATA_BYTES_4_7f_GET(r) ((r).xhol_d1[0])
#define BCM56504_A0_XHOL_D1r_DATA_BYTES_4_7f_SET(r,f) (r).xhol_d1[0]=((uint32_t)f)

/*
 * These macros can be used to access XHOL_D1.
 *
 */
#define BCM56504_A0_READ_XHOL_D1r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_XHOL_D1r,(r._xhol_d1))
#define BCM56504_A0_WRITE_XHOL_D1r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_XHOL_D1r,&(r._xhol_d1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XHOL_D1r BCM56504_A0_XHOL_D1r
#define XHOL_D1r_SIZE BCM56504_A0_XHOL_D1r_SIZE
typedef BCM56504_A0_XHOL_D1r_t XHOL_D1r_t;
#define XHOL_D1r_CLR BCM56504_A0_XHOL_D1r_CLR
#define XHOL_D1r_SET BCM56504_A0_XHOL_D1r_SET
#define XHOL_D1r_GET BCM56504_A0_XHOL_D1r_GET
#define XHOL_D1r_DATA_BYTES_4_7f_GET BCM56504_A0_XHOL_D1r_DATA_BYTES_4_7f_GET
#define XHOL_D1r_DATA_BYTES_4_7f_SET BCM56504_A0_XHOL_D1r_DATA_BYTES_4_7f_SET
#define READ_XHOL_D1r BCM56504_A0_READ_XHOL_D1r
#define WRITE_XHOL_D1r BCM56504_A0_WRITE_XHOL_D1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_XHOL_D1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  XHOL_D2
 * BLOCKS:   XPORT0
 * DESC:     XPORT E2E HOL Data 3rd 4 bytes
 * SIZE:     32
 * FIELDS:
 *     DATA_BYTES_8_11  XPORT E2E HOL Data 3rd 4 bytes
 *
 ******************************************************************************/
#define BCM56504_A0_XHOL_D2r 0x00f80010

#define BCM56504_A0_XHOL_D2r_SIZE 4

/*
 * This structure should be used to declare and program XHOL_D2.
 *
 */
typedef union BCM56504_A0_XHOL_D2r_s {
	uint32_t v[1];
	uint32_t xhol_d2[1];
	uint32_t _xhol_d2;
} BCM56504_A0_XHOL_D2r_t;

#define BCM56504_A0_XHOL_D2r_CLR(r) (r).xhol_d2[0] = 0
#define BCM56504_A0_XHOL_D2r_SET(r,d) (r).xhol_d2[0] = d
#define BCM56504_A0_XHOL_D2r_GET(r) (r).xhol_d2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_XHOL_D2r_DATA_BYTES_8_11f_GET(r) ((r).xhol_d2[0])
#define BCM56504_A0_XHOL_D2r_DATA_BYTES_8_11f_SET(r,f) (r).xhol_d2[0]=((uint32_t)f)

/*
 * These macros can be used to access XHOL_D2.
 *
 */
#define BCM56504_A0_READ_XHOL_D2r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_XHOL_D2r,(r._xhol_d2))
#define BCM56504_A0_WRITE_XHOL_D2r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_XHOL_D2r,&(r._xhol_d2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XHOL_D2r BCM56504_A0_XHOL_D2r
#define XHOL_D2r_SIZE BCM56504_A0_XHOL_D2r_SIZE
typedef BCM56504_A0_XHOL_D2r_t XHOL_D2r_t;
#define XHOL_D2r_CLR BCM56504_A0_XHOL_D2r_CLR
#define XHOL_D2r_SET BCM56504_A0_XHOL_D2r_SET
#define XHOL_D2r_GET BCM56504_A0_XHOL_D2r_GET
#define XHOL_D2r_DATA_BYTES_8_11f_GET BCM56504_A0_XHOL_D2r_DATA_BYTES_8_11f_GET
#define XHOL_D2r_DATA_BYTES_8_11f_SET BCM56504_A0_XHOL_D2r_DATA_BYTES_8_11f_SET
#define READ_XHOL_D2r BCM56504_A0_READ_XHOL_D2r
#define WRITE_XHOL_D2r BCM56504_A0_WRITE_XHOL_D2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_XHOL_D2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  XHOL_D3
 * BLOCKS:   XPORT0
 * DESC:     XPORT E2E HOL Data 4th 4 bytes
 * SIZE:     32
 * FIELDS:
 *     D_BYTES_12_15    XPORT E2E HOL Data 4th 4 bytes
 *
 ******************************************************************************/
#define BCM56504_A0_XHOL_D3r 0x00f80011

#define BCM56504_A0_XHOL_D3r_SIZE 4

/*
 * This structure should be used to declare and program XHOL_D3.
 *
 */
typedef union BCM56504_A0_XHOL_D3r_s {
	uint32_t v[1];
	uint32_t xhol_d3[1];
	uint32_t _xhol_d3;
} BCM56504_A0_XHOL_D3r_t;

#define BCM56504_A0_XHOL_D3r_CLR(r) (r).xhol_d3[0] = 0
#define BCM56504_A0_XHOL_D3r_SET(r,d) (r).xhol_d3[0] = d
#define BCM56504_A0_XHOL_D3r_GET(r) (r).xhol_d3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_XHOL_D3r_D_BYTES_12_15f_GET(r) ((r).xhol_d3[0])
#define BCM56504_A0_XHOL_D3r_D_BYTES_12_15f_SET(r,f) (r).xhol_d3[0]=((uint32_t)f)

/*
 * These macros can be used to access XHOL_D3.
 *
 */
#define BCM56504_A0_READ_XHOL_D3r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_XHOL_D3r,(r._xhol_d3))
#define BCM56504_A0_WRITE_XHOL_D3r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_XHOL_D3r,&(r._xhol_d3))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XHOL_D3r BCM56504_A0_XHOL_D3r
#define XHOL_D3r_SIZE BCM56504_A0_XHOL_D3r_SIZE
typedef BCM56504_A0_XHOL_D3r_t XHOL_D3r_t;
#define XHOL_D3r_CLR BCM56504_A0_XHOL_D3r_CLR
#define XHOL_D3r_SET BCM56504_A0_XHOL_D3r_SET
#define XHOL_D3r_GET BCM56504_A0_XHOL_D3r_GET
#define XHOL_D3r_D_BYTES_12_15f_GET BCM56504_A0_XHOL_D3r_D_BYTES_12_15f_GET
#define XHOL_D3r_D_BYTES_12_15f_SET BCM56504_A0_XHOL_D3r_D_BYTES_12_15f_SET
#define READ_XHOL_D3r BCM56504_A0_READ_XHOL_D3r
#define WRITE_XHOL_D3r BCM56504_A0_WRITE_XHOL_D3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_XHOL_D3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  XHOL_MH0
 * BLOCKS:   XPORT0
 * DESC:     XPORT E2E HOL pkt MH 1st 4 bytes
 * SIZE:     32
 * FIELDS:
 *     MH_BYTES_0_3     XPORT E2E HOL pkt MH 1st 4 bytes
 *
 ******************************************************************************/
#define BCM56504_A0_XHOL_MH0r 0x00f8000b

#define BCM56504_A0_XHOL_MH0r_SIZE 4

/*
 * This structure should be used to declare and program XHOL_MH0.
 *
 */
typedef union BCM56504_A0_XHOL_MH0r_s {
	uint32_t v[1];
	uint32_t xhol_mh0[1];
	uint32_t _xhol_mh0;
} BCM56504_A0_XHOL_MH0r_t;

#define BCM56504_A0_XHOL_MH0r_CLR(r) (r).xhol_mh0[0] = 0
#define BCM56504_A0_XHOL_MH0r_SET(r,d) (r).xhol_mh0[0] = d
#define BCM56504_A0_XHOL_MH0r_GET(r) (r).xhol_mh0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_XHOL_MH0r_MH_BYTES_0_3f_GET(r) ((r).xhol_mh0[0])
#define BCM56504_A0_XHOL_MH0r_MH_BYTES_0_3f_SET(r,f) (r).xhol_mh0[0]=((uint32_t)f)

/*
 * These macros can be used to access XHOL_MH0.
 *
 */
#define BCM56504_A0_READ_XHOL_MH0r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_XHOL_MH0r,(r._xhol_mh0))
#define BCM56504_A0_WRITE_XHOL_MH0r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_XHOL_MH0r,&(r._xhol_mh0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XHOL_MH0r BCM56504_A0_XHOL_MH0r
#define XHOL_MH0r_SIZE BCM56504_A0_XHOL_MH0r_SIZE
typedef BCM56504_A0_XHOL_MH0r_t XHOL_MH0r_t;
#define XHOL_MH0r_CLR BCM56504_A0_XHOL_MH0r_CLR
#define XHOL_MH0r_SET BCM56504_A0_XHOL_MH0r_SET
#define XHOL_MH0r_GET BCM56504_A0_XHOL_MH0r_GET
#define XHOL_MH0r_MH_BYTES_0_3f_GET BCM56504_A0_XHOL_MH0r_MH_BYTES_0_3f_GET
#define XHOL_MH0r_MH_BYTES_0_3f_SET BCM56504_A0_XHOL_MH0r_MH_BYTES_0_3f_SET
#define READ_XHOL_MH0r BCM56504_A0_READ_XHOL_MH0r
#define WRITE_XHOL_MH0r BCM56504_A0_WRITE_XHOL_MH0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_XHOL_MH0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  XHOL_MH1
 * BLOCKS:   XPORT0
 * DESC:     XPORT E2E HOL pkt MH 2nd 4 bytes
 * SIZE:     32
 * FIELDS:
 *     MH_BYTES_4_7     XPORT E2E HOL pkt MH 2nd 4 bytes
 *
 ******************************************************************************/
#define BCM56504_A0_XHOL_MH1r 0x00f8000c

#define BCM56504_A0_XHOL_MH1r_SIZE 4

/*
 * This structure should be used to declare and program XHOL_MH1.
 *
 */
typedef union BCM56504_A0_XHOL_MH1r_s {
	uint32_t v[1];
	uint32_t xhol_mh1[1];
	uint32_t _xhol_mh1;
} BCM56504_A0_XHOL_MH1r_t;

#define BCM56504_A0_XHOL_MH1r_CLR(r) (r).xhol_mh1[0] = 0
#define BCM56504_A0_XHOL_MH1r_SET(r,d) (r).xhol_mh1[0] = d
#define BCM56504_A0_XHOL_MH1r_GET(r) (r).xhol_mh1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_XHOL_MH1r_MH_BYTES_4_7f_GET(r) ((r).xhol_mh1[0])
#define BCM56504_A0_XHOL_MH1r_MH_BYTES_4_7f_SET(r,f) (r).xhol_mh1[0]=((uint32_t)f)

/*
 * These macros can be used to access XHOL_MH1.
 *
 */
#define BCM56504_A0_READ_XHOL_MH1r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_XHOL_MH1r,(r._xhol_mh1))
#define BCM56504_A0_WRITE_XHOL_MH1r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_XHOL_MH1r,&(r._xhol_mh1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XHOL_MH1r BCM56504_A0_XHOL_MH1r
#define XHOL_MH1r_SIZE BCM56504_A0_XHOL_MH1r_SIZE
typedef BCM56504_A0_XHOL_MH1r_t XHOL_MH1r_t;
#define XHOL_MH1r_CLR BCM56504_A0_XHOL_MH1r_CLR
#define XHOL_MH1r_SET BCM56504_A0_XHOL_MH1r_SET
#define XHOL_MH1r_GET BCM56504_A0_XHOL_MH1r_GET
#define XHOL_MH1r_MH_BYTES_4_7f_GET BCM56504_A0_XHOL_MH1r_MH_BYTES_4_7f_GET
#define XHOL_MH1r_MH_BYTES_4_7f_SET BCM56504_A0_XHOL_MH1r_MH_BYTES_4_7f_SET
#define READ_XHOL_MH1r BCM56504_A0_READ_XHOL_MH1r
#define WRITE_XHOL_MH1r BCM56504_A0_WRITE_XHOL_MH1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_XHOL_MH1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  XHOL_MH2
 * BLOCKS:   XPORT0
 * DESC:     XPORT E2E HOL pkt MH 3rd 4 bytes
 * SIZE:     32
 * FIELDS:
 *     MH_BYTES_8_11    XPORT E2E HOL pkt MH 3rd 4 bytes
 *
 ******************************************************************************/
#define BCM56504_A0_XHOL_MH2r 0x00f8000d

#define BCM56504_A0_XHOL_MH2r_SIZE 4

/*
 * This structure should be used to declare and program XHOL_MH2.
 *
 */
typedef union BCM56504_A0_XHOL_MH2r_s {
	uint32_t v[1];
	uint32_t xhol_mh2[1];
	uint32_t _xhol_mh2;
} BCM56504_A0_XHOL_MH2r_t;

#define BCM56504_A0_XHOL_MH2r_CLR(r) (r).xhol_mh2[0] = 0
#define BCM56504_A0_XHOL_MH2r_SET(r,d) (r).xhol_mh2[0] = d
#define BCM56504_A0_XHOL_MH2r_GET(r) (r).xhol_mh2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_XHOL_MH2r_MH_BYTES_8_11f_GET(r) ((r).xhol_mh2[0])
#define BCM56504_A0_XHOL_MH2r_MH_BYTES_8_11f_SET(r,f) (r).xhol_mh2[0]=((uint32_t)f)

/*
 * These macros can be used to access XHOL_MH2.
 *
 */
#define BCM56504_A0_READ_XHOL_MH2r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_XHOL_MH2r,(r._xhol_mh2))
#define BCM56504_A0_WRITE_XHOL_MH2r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_XHOL_MH2r,&(r._xhol_mh2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XHOL_MH2r BCM56504_A0_XHOL_MH2r
#define XHOL_MH2r_SIZE BCM56504_A0_XHOL_MH2r_SIZE
typedef BCM56504_A0_XHOL_MH2r_t XHOL_MH2r_t;
#define XHOL_MH2r_CLR BCM56504_A0_XHOL_MH2r_CLR
#define XHOL_MH2r_SET BCM56504_A0_XHOL_MH2r_SET
#define XHOL_MH2r_GET BCM56504_A0_XHOL_MH2r_GET
#define XHOL_MH2r_MH_BYTES_8_11f_GET BCM56504_A0_XHOL_MH2r_MH_BYTES_8_11f_GET
#define XHOL_MH2r_MH_BYTES_8_11f_SET BCM56504_A0_XHOL_MH2r_MH_BYTES_8_11f_SET
#define READ_XHOL_MH2r BCM56504_A0_READ_XHOL_MH2r
#define WRITE_XHOL_MH2r BCM56504_A0_WRITE_XHOL_MH2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_XHOL_MH2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  XIBP_D0
 * BLOCKS:   XPORT0
 * DESC:     XPORT E2E IBP Data 1st 4 bytes
 * SIZE:     32
 * FIELDS:
 *     DATA_BYTES_0_3   XPORT E2E IBP Data 1st 4 bytes
 *
 ******************************************************************************/
#define BCM56504_A0_XIBP_D0r 0x00f80015

#define BCM56504_A0_XIBP_D0r_SIZE 4

/*
 * This structure should be used to declare and program XIBP_D0.
 *
 */
typedef union BCM56504_A0_XIBP_D0r_s {
	uint32_t v[1];
	uint32_t xibp_d0[1];
	uint32_t _xibp_d0;
} BCM56504_A0_XIBP_D0r_t;

#define BCM56504_A0_XIBP_D0r_CLR(r) (r).xibp_d0[0] = 0
#define BCM56504_A0_XIBP_D0r_SET(r,d) (r).xibp_d0[0] = d
#define BCM56504_A0_XIBP_D0r_GET(r) (r).xibp_d0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_XIBP_D0r_DATA_BYTES_0_3f_GET(r) ((r).xibp_d0[0])
#define BCM56504_A0_XIBP_D0r_DATA_BYTES_0_3f_SET(r,f) (r).xibp_d0[0]=((uint32_t)f)

/*
 * These macros can be used to access XIBP_D0.
 *
 */
#define BCM56504_A0_READ_XIBP_D0r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_XIBP_D0r,(r._xibp_d0))
#define BCM56504_A0_WRITE_XIBP_D0r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_XIBP_D0r,&(r._xibp_d0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XIBP_D0r BCM56504_A0_XIBP_D0r
#define XIBP_D0r_SIZE BCM56504_A0_XIBP_D0r_SIZE
typedef BCM56504_A0_XIBP_D0r_t XIBP_D0r_t;
#define XIBP_D0r_CLR BCM56504_A0_XIBP_D0r_CLR
#define XIBP_D0r_SET BCM56504_A0_XIBP_D0r_SET
#define XIBP_D0r_GET BCM56504_A0_XIBP_D0r_GET
#define XIBP_D0r_DATA_BYTES_0_3f_GET BCM56504_A0_XIBP_D0r_DATA_BYTES_0_3f_GET
#define XIBP_D0r_DATA_BYTES_0_3f_SET BCM56504_A0_XIBP_D0r_DATA_BYTES_0_3f_SET
#define READ_XIBP_D0r BCM56504_A0_READ_XIBP_D0r
#define WRITE_XIBP_D0r BCM56504_A0_WRITE_XIBP_D0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_XIBP_D0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  XIBP_D1
 * BLOCKS:   XPORT0
 * DESC:     XPORT E2E IBP Data 2nd 4 bytes
 * SIZE:     32
 * FIELDS:
 *     DATA_BYTES_4_7   XPORT E2E IBP Data 2nd 4 bytes
 *
 ******************************************************************************/
#define BCM56504_A0_XIBP_D1r 0x00f80016

#define BCM56504_A0_XIBP_D1r_SIZE 4

/*
 * This structure should be used to declare and program XIBP_D1.
 *
 */
typedef union BCM56504_A0_XIBP_D1r_s {
	uint32_t v[1];
	uint32_t xibp_d1[1];
	uint32_t _xibp_d1;
} BCM56504_A0_XIBP_D1r_t;

#define BCM56504_A0_XIBP_D1r_CLR(r) (r).xibp_d1[0] = 0
#define BCM56504_A0_XIBP_D1r_SET(r,d) (r).xibp_d1[0] = d
#define BCM56504_A0_XIBP_D1r_GET(r) (r).xibp_d1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_XIBP_D1r_DATA_BYTES_4_7f_GET(r) ((r).xibp_d1[0])
#define BCM56504_A0_XIBP_D1r_DATA_BYTES_4_7f_SET(r,f) (r).xibp_d1[0]=((uint32_t)f)

/*
 * These macros can be used to access XIBP_D1.
 *
 */
#define BCM56504_A0_READ_XIBP_D1r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_XIBP_D1r,(r._xibp_d1))
#define BCM56504_A0_WRITE_XIBP_D1r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_XIBP_D1r,&(r._xibp_d1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XIBP_D1r BCM56504_A0_XIBP_D1r
#define XIBP_D1r_SIZE BCM56504_A0_XIBP_D1r_SIZE
typedef BCM56504_A0_XIBP_D1r_t XIBP_D1r_t;
#define XIBP_D1r_CLR BCM56504_A0_XIBP_D1r_CLR
#define XIBP_D1r_SET BCM56504_A0_XIBP_D1r_SET
#define XIBP_D1r_GET BCM56504_A0_XIBP_D1r_GET
#define XIBP_D1r_DATA_BYTES_4_7f_GET BCM56504_A0_XIBP_D1r_DATA_BYTES_4_7f_GET
#define XIBP_D1r_DATA_BYTES_4_7f_SET BCM56504_A0_XIBP_D1r_DATA_BYTES_4_7f_SET
#define READ_XIBP_D1r BCM56504_A0_READ_XIBP_D1r
#define WRITE_XIBP_D1r BCM56504_A0_WRITE_XIBP_D1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_XIBP_D1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  XIBP_D2
 * BLOCKS:   XPORT0
 * DESC:     XPORT E2E IBP Data 3rd 4 bytes
 * SIZE:     32
 * FIELDS:
 *     DATA_BYTES_8_11  XPORT E2E IBP Data 3rd 4 bytes
 *
 ******************************************************************************/
#define BCM56504_A0_XIBP_D2r 0x00f80017

#define BCM56504_A0_XIBP_D2r_SIZE 4

/*
 * This structure should be used to declare and program XIBP_D2.
 *
 */
typedef union BCM56504_A0_XIBP_D2r_s {
	uint32_t v[1];
	uint32_t xibp_d2[1];
	uint32_t _xibp_d2;
} BCM56504_A0_XIBP_D2r_t;

#define BCM56504_A0_XIBP_D2r_CLR(r) (r).xibp_d2[0] = 0
#define BCM56504_A0_XIBP_D2r_SET(r,d) (r).xibp_d2[0] = d
#define BCM56504_A0_XIBP_D2r_GET(r) (r).xibp_d2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_XIBP_D2r_DATA_BYTES_8_11f_GET(r) ((r).xibp_d2[0])
#define BCM56504_A0_XIBP_D2r_DATA_BYTES_8_11f_SET(r,f) (r).xibp_d2[0]=((uint32_t)f)

/*
 * These macros can be used to access XIBP_D2.
 *
 */
#define BCM56504_A0_READ_XIBP_D2r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_XIBP_D2r,(r._xibp_d2))
#define BCM56504_A0_WRITE_XIBP_D2r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_XIBP_D2r,&(r._xibp_d2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XIBP_D2r BCM56504_A0_XIBP_D2r
#define XIBP_D2r_SIZE BCM56504_A0_XIBP_D2r_SIZE
typedef BCM56504_A0_XIBP_D2r_t XIBP_D2r_t;
#define XIBP_D2r_CLR BCM56504_A0_XIBP_D2r_CLR
#define XIBP_D2r_SET BCM56504_A0_XIBP_D2r_SET
#define XIBP_D2r_GET BCM56504_A0_XIBP_D2r_GET
#define XIBP_D2r_DATA_BYTES_8_11f_GET BCM56504_A0_XIBP_D2r_DATA_BYTES_8_11f_GET
#define XIBP_D2r_DATA_BYTES_8_11f_SET BCM56504_A0_XIBP_D2r_DATA_BYTES_8_11f_SET
#define READ_XIBP_D2r BCM56504_A0_READ_XIBP_D2r
#define WRITE_XIBP_D2r BCM56504_A0_WRITE_XIBP_D2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_XIBP_D2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  XIBP_D3
 * BLOCKS:   XPORT0
 * DESC:     XPORT E2E IBP Data 4th 4 bytes
 * SIZE:     32
 * FIELDS:
 *     D_BYTES_12_15    XPORT E2E IBP Data 4th 4 bytes
 *
 ******************************************************************************/
#define BCM56504_A0_XIBP_D3r 0x00f80018

#define BCM56504_A0_XIBP_D3r_SIZE 4

/*
 * This structure should be used to declare and program XIBP_D3.
 *
 */
typedef union BCM56504_A0_XIBP_D3r_s {
	uint32_t v[1];
	uint32_t xibp_d3[1];
	uint32_t _xibp_d3;
} BCM56504_A0_XIBP_D3r_t;

#define BCM56504_A0_XIBP_D3r_CLR(r) (r).xibp_d3[0] = 0
#define BCM56504_A0_XIBP_D3r_SET(r,d) (r).xibp_d3[0] = d
#define BCM56504_A0_XIBP_D3r_GET(r) (r).xibp_d3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_XIBP_D3r_D_BYTES_12_15f_GET(r) ((r).xibp_d3[0])
#define BCM56504_A0_XIBP_D3r_D_BYTES_12_15f_SET(r,f) (r).xibp_d3[0]=((uint32_t)f)

/*
 * These macros can be used to access XIBP_D3.
 *
 */
#define BCM56504_A0_READ_XIBP_D3r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_XIBP_D3r,(r._xibp_d3))
#define BCM56504_A0_WRITE_XIBP_D3r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_XIBP_D3r,&(r._xibp_d3))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XIBP_D3r BCM56504_A0_XIBP_D3r
#define XIBP_D3r_SIZE BCM56504_A0_XIBP_D3r_SIZE
typedef BCM56504_A0_XIBP_D3r_t XIBP_D3r_t;
#define XIBP_D3r_CLR BCM56504_A0_XIBP_D3r_CLR
#define XIBP_D3r_SET BCM56504_A0_XIBP_D3r_SET
#define XIBP_D3r_GET BCM56504_A0_XIBP_D3r_GET
#define XIBP_D3r_D_BYTES_12_15f_GET BCM56504_A0_XIBP_D3r_D_BYTES_12_15f_GET
#define XIBP_D3r_D_BYTES_12_15f_SET BCM56504_A0_XIBP_D3r_D_BYTES_12_15f_SET
#define READ_XIBP_D3r BCM56504_A0_READ_XIBP_D3r
#define WRITE_XIBP_D3r BCM56504_A0_WRITE_XIBP_D3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_XIBP_D3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  XIBP_MH0
 * BLOCKS:   XPORT0
 * DESC:     XPORT E2E IBP pkt MH 1st 4 bytes
 * SIZE:     32
 * FIELDS:
 *     MH_BYTES_0_3     XPORT E2E IBP pkt MH 1st 4 bytes
 *
 ******************************************************************************/
#define BCM56504_A0_XIBP_MH0r 0x00f80012

#define BCM56504_A0_XIBP_MH0r_SIZE 4

/*
 * This structure should be used to declare and program XIBP_MH0.
 *
 */
typedef union BCM56504_A0_XIBP_MH0r_s {
	uint32_t v[1];
	uint32_t xibp_mh0[1];
	uint32_t _xibp_mh0;
} BCM56504_A0_XIBP_MH0r_t;

#define BCM56504_A0_XIBP_MH0r_CLR(r) (r).xibp_mh0[0] = 0
#define BCM56504_A0_XIBP_MH0r_SET(r,d) (r).xibp_mh0[0] = d
#define BCM56504_A0_XIBP_MH0r_GET(r) (r).xibp_mh0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_XIBP_MH0r_MH_BYTES_0_3f_GET(r) ((r).xibp_mh0[0])
#define BCM56504_A0_XIBP_MH0r_MH_BYTES_0_3f_SET(r,f) (r).xibp_mh0[0]=((uint32_t)f)

/*
 * These macros can be used to access XIBP_MH0.
 *
 */
#define BCM56504_A0_READ_XIBP_MH0r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_XIBP_MH0r,(r._xibp_mh0))
#define BCM56504_A0_WRITE_XIBP_MH0r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_XIBP_MH0r,&(r._xibp_mh0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XIBP_MH0r BCM56504_A0_XIBP_MH0r
#define XIBP_MH0r_SIZE BCM56504_A0_XIBP_MH0r_SIZE
typedef BCM56504_A0_XIBP_MH0r_t XIBP_MH0r_t;
#define XIBP_MH0r_CLR BCM56504_A0_XIBP_MH0r_CLR
#define XIBP_MH0r_SET BCM56504_A0_XIBP_MH0r_SET
#define XIBP_MH0r_GET BCM56504_A0_XIBP_MH0r_GET
#define XIBP_MH0r_MH_BYTES_0_3f_GET BCM56504_A0_XIBP_MH0r_MH_BYTES_0_3f_GET
#define XIBP_MH0r_MH_BYTES_0_3f_SET BCM56504_A0_XIBP_MH0r_MH_BYTES_0_3f_SET
#define READ_XIBP_MH0r BCM56504_A0_READ_XIBP_MH0r
#define WRITE_XIBP_MH0r BCM56504_A0_WRITE_XIBP_MH0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_XIBP_MH0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  XIBP_MH1
 * BLOCKS:   XPORT0
 * DESC:     XPORT E2E IBP pkt MH 2nd 4 bytes
 * SIZE:     32
 * FIELDS:
 *     MH_BYTES_4_7     XPORT E2E IBP pkt MH 2nd 4 bytes
 *
 ******************************************************************************/
#define BCM56504_A0_XIBP_MH1r 0x00f80013

#define BCM56504_A0_XIBP_MH1r_SIZE 4

/*
 * This structure should be used to declare and program XIBP_MH1.
 *
 */
typedef union BCM56504_A0_XIBP_MH1r_s {
	uint32_t v[1];
	uint32_t xibp_mh1[1];
	uint32_t _xibp_mh1;
} BCM56504_A0_XIBP_MH1r_t;

#define BCM56504_A0_XIBP_MH1r_CLR(r) (r).xibp_mh1[0] = 0
#define BCM56504_A0_XIBP_MH1r_SET(r,d) (r).xibp_mh1[0] = d
#define BCM56504_A0_XIBP_MH1r_GET(r) (r).xibp_mh1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_XIBP_MH1r_MH_BYTES_4_7f_GET(r) ((r).xibp_mh1[0])
#define BCM56504_A0_XIBP_MH1r_MH_BYTES_4_7f_SET(r,f) (r).xibp_mh1[0]=((uint32_t)f)

/*
 * These macros can be used to access XIBP_MH1.
 *
 */
#define BCM56504_A0_READ_XIBP_MH1r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_XIBP_MH1r,(r._xibp_mh1))
#define BCM56504_A0_WRITE_XIBP_MH1r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_XIBP_MH1r,&(r._xibp_mh1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XIBP_MH1r BCM56504_A0_XIBP_MH1r
#define XIBP_MH1r_SIZE BCM56504_A0_XIBP_MH1r_SIZE
typedef BCM56504_A0_XIBP_MH1r_t XIBP_MH1r_t;
#define XIBP_MH1r_CLR BCM56504_A0_XIBP_MH1r_CLR
#define XIBP_MH1r_SET BCM56504_A0_XIBP_MH1r_SET
#define XIBP_MH1r_GET BCM56504_A0_XIBP_MH1r_GET
#define XIBP_MH1r_MH_BYTES_4_7f_GET BCM56504_A0_XIBP_MH1r_MH_BYTES_4_7f_GET
#define XIBP_MH1r_MH_BYTES_4_7f_SET BCM56504_A0_XIBP_MH1r_MH_BYTES_4_7f_SET
#define READ_XIBP_MH1r BCM56504_A0_READ_XIBP_MH1r
#define WRITE_XIBP_MH1r BCM56504_A0_WRITE_XIBP_MH1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_XIBP_MH1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  XIBP_MH2
 * BLOCKS:   XPORT0
 * DESC:     XPORT E2E IBP pkt MH 3rd 4 bytes
 * SIZE:     32
 * FIELDS:
 *     MH_BYTES_8_11    XPORT E2E IBP pkt MH 3rd 4 bytes
 *
 ******************************************************************************/
#define BCM56504_A0_XIBP_MH2r 0x00f80014

#define BCM56504_A0_XIBP_MH2r_SIZE 4

/*
 * This structure should be used to declare and program XIBP_MH2.
 *
 */
typedef union BCM56504_A0_XIBP_MH2r_s {
	uint32_t v[1];
	uint32_t xibp_mh2[1];
	uint32_t _xibp_mh2;
} BCM56504_A0_XIBP_MH2r_t;

#define BCM56504_A0_XIBP_MH2r_CLR(r) (r).xibp_mh2[0] = 0
#define BCM56504_A0_XIBP_MH2r_SET(r,d) (r).xibp_mh2[0] = d
#define BCM56504_A0_XIBP_MH2r_GET(r) (r).xibp_mh2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_XIBP_MH2r_MH_BYTES_8_11f_GET(r) ((r).xibp_mh2[0])
#define BCM56504_A0_XIBP_MH2r_MH_BYTES_8_11f_SET(r,f) (r).xibp_mh2[0]=((uint32_t)f)

/*
 * These macros can be used to access XIBP_MH2.
 *
 */
#define BCM56504_A0_READ_XIBP_MH2r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_XIBP_MH2r,(r._xibp_mh2))
#define BCM56504_A0_WRITE_XIBP_MH2r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_XIBP_MH2r,&(r._xibp_mh2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XIBP_MH2r BCM56504_A0_XIBP_MH2r
#define XIBP_MH2r_SIZE BCM56504_A0_XIBP_MH2r_SIZE
typedef BCM56504_A0_XIBP_MH2r_t XIBP_MH2r_t;
#define XIBP_MH2r_CLR BCM56504_A0_XIBP_MH2r_CLR
#define XIBP_MH2r_SET BCM56504_A0_XIBP_MH2r_SET
#define XIBP_MH2r_GET BCM56504_A0_XIBP_MH2r_GET
#define XIBP_MH2r_MH_BYTES_8_11f_GET BCM56504_A0_XIBP_MH2r_MH_BYTES_8_11f_GET
#define XIBP_MH2r_MH_BYTES_8_11f_SET BCM56504_A0_XIBP_MH2r_MH_BYTES_8_11f_SET
#define READ_XIBP_MH2r BCM56504_A0_READ_XIBP_MH2r
#define WRITE_XIBP_MH2r BCM56504_A0_WRITE_XIBP_MH2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_XIBP_MH2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  XPAUSE_D0
 * BLOCKS:   XPORT0
 * DESC:     XPORT PAUSE Data 1st 4 bytes
 * SIZE:     32
 * FIELDS:
 *     DATA_BYTES_0_3   XPORT PAUSE Data 1st 4 bytes
 *
 ******************************************************************************/
#define BCM56504_A0_XPAUSE_D0r 0x00f80007

#define BCM56504_A0_XPAUSE_D0r_SIZE 4

/*
 * This structure should be used to declare and program XPAUSE_D0.
 *
 */
typedef union BCM56504_A0_XPAUSE_D0r_s {
	uint32_t v[1];
	uint32_t xpause_d0[1];
	uint32_t _xpause_d0;
} BCM56504_A0_XPAUSE_D0r_t;

#define BCM56504_A0_XPAUSE_D0r_CLR(r) (r).xpause_d0[0] = 0
#define BCM56504_A0_XPAUSE_D0r_SET(r,d) (r).xpause_d0[0] = d
#define BCM56504_A0_XPAUSE_D0r_GET(r) (r).xpause_d0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_XPAUSE_D0r_DATA_BYTES_0_3f_GET(r) ((r).xpause_d0[0])
#define BCM56504_A0_XPAUSE_D0r_DATA_BYTES_0_3f_SET(r,f) (r).xpause_d0[0]=((uint32_t)f)

/*
 * These macros can be used to access XPAUSE_D0.
 *
 */
#define BCM56504_A0_READ_XPAUSE_D0r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_XPAUSE_D0r,(r._xpause_d0))
#define BCM56504_A0_WRITE_XPAUSE_D0r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_XPAUSE_D0r,&(r._xpause_d0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XPAUSE_D0r BCM56504_A0_XPAUSE_D0r
#define XPAUSE_D0r_SIZE BCM56504_A0_XPAUSE_D0r_SIZE
typedef BCM56504_A0_XPAUSE_D0r_t XPAUSE_D0r_t;
#define XPAUSE_D0r_CLR BCM56504_A0_XPAUSE_D0r_CLR
#define XPAUSE_D0r_SET BCM56504_A0_XPAUSE_D0r_SET
#define XPAUSE_D0r_GET BCM56504_A0_XPAUSE_D0r_GET
#define XPAUSE_D0r_DATA_BYTES_0_3f_GET BCM56504_A0_XPAUSE_D0r_DATA_BYTES_0_3f_GET
#define XPAUSE_D0r_DATA_BYTES_0_3f_SET BCM56504_A0_XPAUSE_D0r_DATA_BYTES_0_3f_SET
#define READ_XPAUSE_D0r BCM56504_A0_READ_XPAUSE_D0r
#define WRITE_XPAUSE_D0r BCM56504_A0_WRITE_XPAUSE_D0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_XPAUSE_D0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  XPAUSE_D1
 * BLOCKS:   XPORT0
 * DESC:     XPORT PAUSE Data 2nd 4 bytes
 * SIZE:     32
 * FIELDS:
 *     DATA_BYTES_4_7   XPORT PAUSE Data 2nd 4 bytes
 *
 ******************************************************************************/
#define BCM56504_A0_XPAUSE_D1r 0x00f80008

#define BCM56504_A0_XPAUSE_D1r_SIZE 4

/*
 * This structure should be used to declare and program XPAUSE_D1.
 *
 */
typedef union BCM56504_A0_XPAUSE_D1r_s {
	uint32_t v[1];
	uint32_t xpause_d1[1];
	uint32_t _xpause_d1;
} BCM56504_A0_XPAUSE_D1r_t;

#define BCM56504_A0_XPAUSE_D1r_CLR(r) (r).xpause_d1[0] = 0
#define BCM56504_A0_XPAUSE_D1r_SET(r,d) (r).xpause_d1[0] = d
#define BCM56504_A0_XPAUSE_D1r_GET(r) (r).xpause_d1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_XPAUSE_D1r_DATA_BYTES_4_7f_GET(r) ((r).xpause_d1[0])
#define BCM56504_A0_XPAUSE_D1r_DATA_BYTES_4_7f_SET(r,f) (r).xpause_d1[0]=((uint32_t)f)

/*
 * These macros can be used to access XPAUSE_D1.
 *
 */
#define BCM56504_A0_READ_XPAUSE_D1r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_XPAUSE_D1r,(r._xpause_d1))
#define BCM56504_A0_WRITE_XPAUSE_D1r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_XPAUSE_D1r,&(r._xpause_d1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XPAUSE_D1r BCM56504_A0_XPAUSE_D1r
#define XPAUSE_D1r_SIZE BCM56504_A0_XPAUSE_D1r_SIZE
typedef BCM56504_A0_XPAUSE_D1r_t XPAUSE_D1r_t;
#define XPAUSE_D1r_CLR BCM56504_A0_XPAUSE_D1r_CLR
#define XPAUSE_D1r_SET BCM56504_A0_XPAUSE_D1r_SET
#define XPAUSE_D1r_GET BCM56504_A0_XPAUSE_D1r_GET
#define XPAUSE_D1r_DATA_BYTES_4_7f_GET BCM56504_A0_XPAUSE_D1r_DATA_BYTES_4_7f_GET
#define XPAUSE_D1r_DATA_BYTES_4_7f_SET BCM56504_A0_XPAUSE_D1r_DATA_BYTES_4_7f_SET
#define READ_XPAUSE_D1r BCM56504_A0_READ_XPAUSE_D1r
#define WRITE_XPAUSE_D1r BCM56504_A0_WRITE_XPAUSE_D1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_XPAUSE_D1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  XPAUSE_D2
 * BLOCKS:   XPORT0
 * DESC:     XPORT PAUSE Data 3rd 4 bytes
 * SIZE:     32
 * FIELDS:
 *     DATA_BYTES_8_11  XPORT PAUSE Data 3rd 4 bytes
 *
 ******************************************************************************/
#define BCM56504_A0_XPAUSE_D2r 0x00f80009

#define BCM56504_A0_XPAUSE_D2r_SIZE 4

/*
 * This structure should be used to declare and program XPAUSE_D2.
 *
 */
typedef union BCM56504_A0_XPAUSE_D2r_s {
	uint32_t v[1];
	uint32_t xpause_d2[1];
	uint32_t _xpause_d2;
} BCM56504_A0_XPAUSE_D2r_t;

#define BCM56504_A0_XPAUSE_D2r_CLR(r) (r).xpause_d2[0] = 0
#define BCM56504_A0_XPAUSE_D2r_SET(r,d) (r).xpause_d2[0] = d
#define BCM56504_A0_XPAUSE_D2r_GET(r) (r).xpause_d2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_XPAUSE_D2r_DATA_BYTES_8_11f_GET(r) ((r).xpause_d2[0])
#define BCM56504_A0_XPAUSE_D2r_DATA_BYTES_8_11f_SET(r,f) (r).xpause_d2[0]=((uint32_t)f)

/*
 * These macros can be used to access XPAUSE_D2.
 *
 */
#define BCM56504_A0_READ_XPAUSE_D2r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_XPAUSE_D2r,(r._xpause_d2))
#define BCM56504_A0_WRITE_XPAUSE_D2r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_XPAUSE_D2r,&(r._xpause_d2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XPAUSE_D2r BCM56504_A0_XPAUSE_D2r
#define XPAUSE_D2r_SIZE BCM56504_A0_XPAUSE_D2r_SIZE
typedef BCM56504_A0_XPAUSE_D2r_t XPAUSE_D2r_t;
#define XPAUSE_D2r_CLR BCM56504_A0_XPAUSE_D2r_CLR
#define XPAUSE_D2r_SET BCM56504_A0_XPAUSE_D2r_SET
#define XPAUSE_D2r_GET BCM56504_A0_XPAUSE_D2r_GET
#define XPAUSE_D2r_DATA_BYTES_8_11f_GET BCM56504_A0_XPAUSE_D2r_DATA_BYTES_8_11f_GET
#define XPAUSE_D2r_DATA_BYTES_8_11f_SET BCM56504_A0_XPAUSE_D2r_DATA_BYTES_8_11f_SET
#define READ_XPAUSE_D2r BCM56504_A0_READ_XPAUSE_D2r
#define WRITE_XPAUSE_D2r BCM56504_A0_WRITE_XPAUSE_D2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_XPAUSE_D2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  XPAUSE_D3
 * BLOCKS:   XPORT0
 * DESC:     XPORT PAUSE Data 4th 4 bytes
 * SIZE:     32
 * FIELDS:
 *     DATA_BYTES_12_15 XPORT PAUSE Data 4th 4 bytes
 *
 ******************************************************************************/
#define BCM56504_A0_XPAUSE_D3r 0x00f8000a

#define BCM56504_A0_XPAUSE_D3r_SIZE 4

/*
 * This structure should be used to declare and program XPAUSE_D3.
 *
 */
typedef union BCM56504_A0_XPAUSE_D3r_s {
	uint32_t v[1];
	uint32_t xpause_d3[1];
	uint32_t _xpause_d3;
} BCM56504_A0_XPAUSE_D3r_t;

#define BCM56504_A0_XPAUSE_D3r_CLR(r) (r).xpause_d3[0] = 0
#define BCM56504_A0_XPAUSE_D3r_SET(r,d) (r).xpause_d3[0] = d
#define BCM56504_A0_XPAUSE_D3r_GET(r) (r).xpause_d3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_XPAUSE_D3r_DATA_BYTES_12_15f_GET(r) ((r).xpause_d3[0])
#define BCM56504_A0_XPAUSE_D3r_DATA_BYTES_12_15f_SET(r,f) (r).xpause_d3[0]=((uint32_t)f)

/*
 * These macros can be used to access XPAUSE_D3.
 *
 */
#define BCM56504_A0_READ_XPAUSE_D3r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_XPAUSE_D3r,(r._xpause_d3))
#define BCM56504_A0_WRITE_XPAUSE_D3r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_XPAUSE_D3r,&(r._xpause_d3))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XPAUSE_D3r BCM56504_A0_XPAUSE_D3r
#define XPAUSE_D3r_SIZE BCM56504_A0_XPAUSE_D3r_SIZE
typedef BCM56504_A0_XPAUSE_D3r_t XPAUSE_D3r_t;
#define XPAUSE_D3r_CLR BCM56504_A0_XPAUSE_D3r_CLR
#define XPAUSE_D3r_SET BCM56504_A0_XPAUSE_D3r_SET
#define XPAUSE_D3r_GET BCM56504_A0_XPAUSE_D3r_GET
#define XPAUSE_D3r_DATA_BYTES_12_15f_GET BCM56504_A0_XPAUSE_D3r_DATA_BYTES_12_15f_GET
#define XPAUSE_D3r_DATA_BYTES_12_15f_SET BCM56504_A0_XPAUSE_D3r_DATA_BYTES_12_15f_SET
#define READ_XPAUSE_D3r BCM56504_A0_READ_XPAUSE_D3r
#define WRITE_XPAUSE_D3r BCM56504_A0_WRITE_XPAUSE_D3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_XPAUSE_D3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  XPAUSE_MH0
 * BLOCKS:   XPORT0
 * DESC:     XPORT PAUSE MH 1st 4 bytes
 * SIZE:     32
 * FIELDS:
 *     MH_BYTES_0_3     XPORT PAUSE MH 1st 4 bytes
 *
 ******************************************************************************/
#define BCM56504_A0_XPAUSE_MH0r 0x00f80004

#define BCM56504_A0_XPAUSE_MH0r_SIZE 4

/*
 * This structure should be used to declare and program XPAUSE_MH0.
 *
 */
typedef union BCM56504_A0_XPAUSE_MH0r_s {
	uint32_t v[1];
	uint32_t xpause_mh0[1];
	uint32_t _xpause_mh0;
} BCM56504_A0_XPAUSE_MH0r_t;

#define BCM56504_A0_XPAUSE_MH0r_CLR(r) (r).xpause_mh0[0] = 0
#define BCM56504_A0_XPAUSE_MH0r_SET(r,d) (r).xpause_mh0[0] = d
#define BCM56504_A0_XPAUSE_MH0r_GET(r) (r).xpause_mh0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_XPAUSE_MH0r_MH_BYTES_0_3f_GET(r) ((r).xpause_mh0[0])
#define BCM56504_A0_XPAUSE_MH0r_MH_BYTES_0_3f_SET(r,f) (r).xpause_mh0[0]=((uint32_t)f)

/*
 * These macros can be used to access XPAUSE_MH0.
 *
 */
#define BCM56504_A0_READ_XPAUSE_MH0r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_XPAUSE_MH0r,(r._xpause_mh0))
#define BCM56504_A0_WRITE_XPAUSE_MH0r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_XPAUSE_MH0r,&(r._xpause_mh0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XPAUSE_MH0r BCM56504_A0_XPAUSE_MH0r
#define XPAUSE_MH0r_SIZE BCM56504_A0_XPAUSE_MH0r_SIZE
typedef BCM56504_A0_XPAUSE_MH0r_t XPAUSE_MH0r_t;
#define XPAUSE_MH0r_CLR BCM56504_A0_XPAUSE_MH0r_CLR
#define XPAUSE_MH0r_SET BCM56504_A0_XPAUSE_MH0r_SET
#define XPAUSE_MH0r_GET BCM56504_A0_XPAUSE_MH0r_GET
#define XPAUSE_MH0r_MH_BYTES_0_3f_GET BCM56504_A0_XPAUSE_MH0r_MH_BYTES_0_3f_GET
#define XPAUSE_MH0r_MH_BYTES_0_3f_SET BCM56504_A0_XPAUSE_MH0r_MH_BYTES_0_3f_SET
#define READ_XPAUSE_MH0r BCM56504_A0_READ_XPAUSE_MH0r
#define WRITE_XPAUSE_MH0r BCM56504_A0_WRITE_XPAUSE_MH0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_XPAUSE_MH0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  XPAUSE_MH1
 * BLOCKS:   XPORT0
 * DESC:     XPORT PAUSE MH 2nd 4 bytes
 * SIZE:     32
 * FIELDS:
 *     MH_BYTES_4_7     XPORT PAUSE MH 2nd 4 bytes
 *
 ******************************************************************************/
#define BCM56504_A0_XPAUSE_MH1r 0x00f80005

#define BCM56504_A0_XPAUSE_MH1r_SIZE 4

/*
 * This structure should be used to declare and program XPAUSE_MH1.
 *
 */
typedef union BCM56504_A0_XPAUSE_MH1r_s {
	uint32_t v[1];
	uint32_t xpause_mh1[1];
	uint32_t _xpause_mh1;
} BCM56504_A0_XPAUSE_MH1r_t;

#define BCM56504_A0_XPAUSE_MH1r_CLR(r) (r).xpause_mh1[0] = 0
#define BCM56504_A0_XPAUSE_MH1r_SET(r,d) (r).xpause_mh1[0] = d
#define BCM56504_A0_XPAUSE_MH1r_GET(r) (r).xpause_mh1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_XPAUSE_MH1r_MH_BYTES_4_7f_GET(r) ((r).xpause_mh1[0])
#define BCM56504_A0_XPAUSE_MH1r_MH_BYTES_4_7f_SET(r,f) (r).xpause_mh1[0]=((uint32_t)f)

/*
 * These macros can be used to access XPAUSE_MH1.
 *
 */
#define BCM56504_A0_READ_XPAUSE_MH1r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_XPAUSE_MH1r,(r._xpause_mh1))
#define BCM56504_A0_WRITE_XPAUSE_MH1r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_XPAUSE_MH1r,&(r._xpause_mh1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XPAUSE_MH1r BCM56504_A0_XPAUSE_MH1r
#define XPAUSE_MH1r_SIZE BCM56504_A0_XPAUSE_MH1r_SIZE
typedef BCM56504_A0_XPAUSE_MH1r_t XPAUSE_MH1r_t;
#define XPAUSE_MH1r_CLR BCM56504_A0_XPAUSE_MH1r_CLR
#define XPAUSE_MH1r_SET BCM56504_A0_XPAUSE_MH1r_SET
#define XPAUSE_MH1r_GET BCM56504_A0_XPAUSE_MH1r_GET
#define XPAUSE_MH1r_MH_BYTES_4_7f_GET BCM56504_A0_XPAUSE_MH1r_MH_BYTES_4_7f_GET
#define XPAUSE_MH1r_MH_BYTES_4_7f_SET BCM56504_A0_XPAUSE_MH1r_MH_BYTES_4_7f_SET
#define READ_XPAUSE_MH1r BCM56504_A0_READ_XPAUSE_MH1r
#define WRITE_XPAUSE_MH1r BCM56504_A0_WRITE_XPAUSE_MH1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_XPAUSE_MH1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  XPAUSE_MH2
 * BLOCKS:   XPORT0
 * DESC:     XPORT PAUSE MH 3rd 4 bytes
 * SIZE:     32
 * FIELDS:
 *     MH_BYTES_8_11    XPORT PAUSE MH 3rd 4 bytes
 *
 ******************************************************************************/
#define BCM56504_A0_XPAUSE_MH2r 0x00f80006

#define BCM56504_A0_XPAUSE_MH2r_SIZE 4

/*
 * This structure should be used to declare and program XPAUSE_MH2.
 *
 */
typedef union BCM56504_A0_XPAUSE_MH2r_s {
	uint32_t v[1];
	uint32_t xpause_mh2[1];
	uint32_t _xpause_mh2;
} BCM56504_A0_XPAUSE_MH2r_t;

#define BCM56504_A0_XPAUSE_MH2r_CLR(r) (r).xpause_mh2[0] = 0
#define BCM56504_A0_XPAUSE_MH2r_SET(r,d) (r).xpause_mh2[0] = d
#define BCM56504_A0_XPAUSE_MH2r_GET(r) (r).xpause_mh2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_XPAUSE_MH2r_MH_BYTES_8_11f_GET(r) ((r).xpause_mh2[0])
#define BCM56504_A0_XPAUSE_MH2r_MH_BYTES_8_11f_SET(r,f) (r).xpause_mh2[0]=((uint32_t)f)

/*
 * These macros can be used to access XPAUSE_MH2.
 *
 */
#define BCM56504_A0_READ_XPAUSE_MH2r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_XPAUSE_MH2r,(r._xpause_mh2))
#define BCM56504_A0_WRITE_XPAUSE_MH2r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_XPAUSE_MH2r,&(r._xpause_mh2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XPAUSE_MH2r BCM56504_A0_XPAUSE_MH2r
#define XPAUSE_MH2r_SIZE BCM56504_A0_XPAUSE_MH2r_SIZE
typedef BCM56504_A0_XPAUSE_MH2r_t XPAUSE_MH2r_t;
#define XPAUSE_MH2r_CLR BCM56504_A0_XPAUSE_MH2r_CLR
#define XPAUSE_MH2r_SET BCM56504_A0_XPAUSE_MH2r_SET
#define XPAUSE_MH2r_GET BCM56504_A0_XPAUSE_MH2r_GET
#define XPAUSE_MH2r_MH_BYTES_8_11f_GET BCM56504_A0_XPAUSE_MH2r_MH_BYTES_8_11f_GET
#define XPAUSE_MH2r_MH_BYTES_8_11f_SET BCM56504_A0_XPAUSE_MH2r_MH_BYTES_8_11f_SET
#define READ_XPAUSE_MH2r BCM56504_A0_READ_XPAUSE_MH2r
#define WRITE_XPAUSE_MH2r BCM56504_A0_WRITE_XPAUSE_MH2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_XPAUSE_MH2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  XPAUSE_RX_DA_LS
 * BLOCKS:   XPORT0
 * DESC:     XPORT PAUSE RX pkt DA - lower 32 bits
 * SIZE:     32
 * FIELDS:
 *     DA               IPIC Rx pkt expected DA - lower 32 bits
 *
 ******************************************************************************/
#define BCM56504_A0_XPAUSE_RX_DA_LSr 0x00f8001a

#define BCM56504_A0_XPAUSE_RX_DA_LSr_SIZE 4

/*
 * This structure should be used to declare and program XPAUSE_RX_DA_LS.
 *
 */
typedef union BCM56504_A0_XPAUSE_RX_DA_LSr_s {
	uint32_t v[1];
	uint32_t xpause_rx_da_ls[1];
	uint32_t _xpause_rx_da_ls;
} BCM56504_A0_XPAUSE_RX_DA_LSr_t;

#define BCM56504_A0_XPAUSE_RX_DA_LSr_CLR(r) (r).xpause_rx_da_ls[0] = 0
#define BCM56504_A0_XPAUSE_RX_DA_LSr_SET(r,d) (r).xpause_rx_da_ls[0] = d
#define BCM56504_A0_XPAUSE_RX_DA_LSr_GET(r) (r).xpause_rx_da_ls[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_XPAUSE_RX_DA_LSr_DAf_GET(r) ((r).xpause_rx_da_ls[0])
#define BCM56504_A0_XPAUSE_RX_DA_LSr_DAf_SET(r,f) (r).xpause_rx_da_ls[0]=((uint32_t)f)

/*
 * These macros can be used to access XPAUSE_RX_DA_LS.
 *
 */
#define BCM56504_A0_READ_XPAUSE_RX_DA_LSr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_XPAUSE_RX_DA_LSr,(r._xpause_rx_da_ls))
#define BCM56504_A0_WRITE_XPAUSE_RX_DA_LSr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_XPAUSE_RX_DA_LSr,&(r._xpause_rx_da_ls))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XPAUSE_RX_DA_LSr BCM56504_A0_XPAUSE_RX_DA_LSr
#define XPAUSE_RX_DA_LSr_SIZE BCM56504_A0_XPAUSE_RX_DA_LSr_SIZE
typedef BCM56504_A0_XPAUSE_RX_DA_LSr_t XPAUSE_RX_DA_LSr_t;
#define XPAUSE_RX_DA_LSr_CLR BCM56504_A0_XPAUSE_RX_DA_LSr_CLR
#define XPAUSE_RX_DA_LSr_SET BCM56504_A0_XPAUSE_RX_DA_LSr_SET
#define XPAUSE_RX_DA_LSr_GET BCM56504_A0_XPAUSE_RX_DA_LSr_GET
#define XPAUSE_RX_DA_LSr_DAf_GET BCM56504_A0_XPAUSE_RX_DA_LSr_DAf_GET
#define XPAUSE_RX_DA_LSr_DAf_SET BCM56504_A0_XPAUSE_RX_DA_LSr_DAf_SET
#define READ_XPAUSE_RX_DA_LSr BCM56504_A0_READ_XPAUSE_RX_DA_LSr
#define WRITE_XPAUSE_RX_DA_LSr BCM56504_A0_WRITE_XPAUSE_RX_DA_LSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_XPAUSE_RX_DA_LSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  XPAUSE_RX_DA_MS
 * BLOCKS:   XPORT0
 * DESC:     XPORT PAUSE RX pkt DA - upper 16 bits
 * SIZE:     32
 * FIELDS:
 *     DA               XPORT RX pkt expected DA - upper 16 bits
 *
 ******************************************************************************/
#define BCM56504_A0_XPAUSE_RX_DA_MSr 0x00f80019

#define BCM56504_A0_XPAUSE_RX_DA_MSr_SIZE 4

/*
 * This structure should be used to declare and program XPAUSE_RX_DA_MS.
 *
 */
typedef union BCM56504_A0_XPAUSE_RX_DA_MSr_s {
	uint32_t v[1];
	uint32_t xpause_rx_da_ms[1];
	uint32_t _xpause_rx_da_ms;
} BCM56504_A0_XPAUSE_RX_DA_MSr_t;

#define BCM56504_A0_XPAUSE_RX_DA_MSr_CLR(r) (r).xpause_rx_da_ms[0] = 0
#define BCM56504_A0_XPAUSE_RX_DA_MSr_SET(r,d) (r).xpause_rx_da_ms[0] = d
#define BCM56504_A0_XPAUSE_RX_DA_MSr_GET(r) (r).xpause_rx_da_ms[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_XPAUSE_RX_DA_MSr_DAf_GET(r) (((r).xpause_rx_da_ms[0]) & 0xffff)
#define BCM56504_A0_XPAUSE_RX_DA_MSr_DAf_SET(r,f) (r).xpause_rx_da_ms[0]=(((r).xpause_rx_da_ms[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access XPAUSE_RX_DA_MS.
 *
 */
#define BCM56504_A0_READ_XPAUSE_RX_DA_MSr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_XPAUSE_RX_DA_MSr,(r._xpause_rx_da_ms))
#define BCM56504_A0_WRITE_XPAUSE_RX_DA_MSr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_XPAUSE_RX_DA_MSr,&(r._xpause_rx_da_ms))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XPAUSE_RX_DA_MSr BCM56504_A0_XPAUSE_RX_DA_MSr
#define XPAUSE_RX_DA_MSr_SIZE BCM56504_A0_XPAUSE_RX_DA_MSr_SIZE
typedef BCM56504_A0_XPAUSE_RX_DA_MSr_t XPAUSE_RX_DA_MSr_t;
#define XPAUSE_RX_DA_MSr_CLR BCM56504_A0_XPAUSE_RX_DA_MSr_CLR
#define XPAUSE_RX_DA_MSr_SET BCM56504_A0_XPAUSE_RX_DA_MSr_SET
#define XPAUSE_RX_DA_MSr_GET BCM56504_A0_XPAUSE_RX_DA_MSr_GET
#define XPAUSE_RX_DA_MSr_DAf_GET BCM56504_A0_XPAUSE_RX_DA_MSr_DAf_GET
#define XPAUSE_RX_DA_MSr_DAf_SET BCM56504_A0_XPAUSE_RX_DA_MSr_DAf_SET
#define READ_XPAUSE_RX_DA_MSr BCM56504_A0_READ_XPAUSE_RX_DA_MSr
#define WRITE_XPAUSE_RX_DA_MSr BCM56504_A0_WRITE_XPAUSE_RX_DA_MSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_XPAUSE_RX_DA_MSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  XPAUSE_RX_LENGTH_TYPE
 * BLOCKS:   XPORT0
 * DESC:     XPORT PAUSE Rx pkt expected Length/Type field
 * SIZE:     32
 * FIELDS:
 *     LENGTH_TYPE      XPORT PAUSE Rx pkt expected Length/Type field
 *
 ******************************************************************************/
#define BCM56504_A0_XPAUSE_RX_LENGTH_TYPEr 0x00f8001b

#define BCM56504_A0_XPAUSE_RX_LENGTH_TYPEr_SIZE 4

/*
 * This structure should be used to declare and program XPAUSE_RX_LENGTH_TYPE.
 *
 */
typedef union BCM56504_A0_XPAUSE_RX_LENGTH_TYPEr_s {
	uint32_t v[1];
	uint32_t xpause_rx_length_type[1];
	uint32_t _xpause_rx_length_type;
} BCM56504_A0_XPAUSE_RX_LENGTH_TYPEr_t;

#define BCM56504_A0_XPAUSE_RX_LENGTH_TYPEr_CLR(r) (r).xpause_rx_length_type[0] = 0
#define BCM56504_A0_XPAUSE_RX_LENGTH_TYPEr_SET(r,d) (r).xpause_rx_length_type[0] = d
#define BCM56504_A0_XPAUSE_RX_LENGTH_TYPEr_GET(r) (r).xpause_rx_length_type[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_XPAUSE_RX_LENGTH_TYPEr_LENGTH_TYPEf_GET(r) (((r).xpause_rx_length_type[0]) & 0xffff)
#define BCM56504_A0_XPAUSE_RX_LENGTH_TYPEr_LENGTH_TYPEf_SET(r,f) (r).xpause_rx_length_type[0]=(((r).xpause_rx_length_type[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access XPAUSE_RX_LENGTH_TYPE.
 *
 */
#define BCM56504_A0_READ_XPAUSE_RX_LENGTH_TYPEr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_XPAUSE_RX_LENGTH_TYPEr,(r._xpause_rx_length_type))
#define BCM56504_A0_WRITE_XPAUSE_RX_LENGTH_TYPEr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_XPAUSE_RX_LENGTH_TYPEr,&(r._xpause_rx_length_type))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XPAUSE_RX_LENGTH_TYPEr BCM56504_A0_XPAUSE_RX_LENGTH_TYPEr
#define XPAUSE_RX_LENGTH_TYPEr_SIZE BCM56504_A0_XPAUSE_RX_LENGTH_TYPEr_SIZE
typedef BCM56504_A0_XPAUSE_RX_LENGTH_TYPEr_t XPAUSE_RX_LENGTH_TYPEr_t;
#define XPAUSE_RX_LENGTH_TYPEr_CLR BCM56504_A0_XPAUSE_RX_LENGTH_TYPEr_CLR
#define XPAUSE_RX_LENGTH_TYPEr_SET BCM56504_A0_XPAUSE_RX_LENGTH_TYPEr_SET
#define XPAUSE_RX_LENGTH_TYPEr_GET BCM56504_A0_XPAUSE_RX_LENGTH_TYPEr_GET
#define XPAUSE_RX_LENGTH_TYPEr_LENGTH_TYPEf_GET BCM56504_A0_XPAUSE_RX_LENGTH_TYPEr_LENGTH_TYPEf_GET
#define XPAUSE_RX_LENGTH_TYPEr_LENGTH_TYPEf_SET BCM56504_A0_XPAUSE_RX_LENGTH_TYPEr_LENGTH_TYPEf_SET
#define READ_XPAUSE_RX_LENGTH_TYPEr BCM56504_A0_READ_XPAUSE_RX_LENGTH_TYPEr
#define WRITE_XPAUSE_RX_LENGTH_TYPEr BCM56504_A0_WRITE_XPAUSE_RX_LENGTH_TYPEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_XPAUSE_RX_LENGTH_TYPEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  XPAUSE_RX_OPCODE
 * BLOCKS:   XPORT0
 * DESC:     XPORT PAUSE Rx pkt expected Opcode field
 * SIZE:     32
 * FIELDS:
 *     OPCODE           XPORT PAUSE Rx pkt expected Opcode field
 *
 ******************************************************************************/
#define BCM56504_A0_XPAUSE_RX_OPCODEr 0x00f8001c

#define BCM56504_A0_XPAUSE_RX_OPCODEr_SIZE 4

/*
 * This structure should be used to declare and program XPAUSE_RX_OPCODE.
 *
 */
typedef union BCM56504_A0_XPAUSE_RX_OPCODEr_s {
	uint32_t v[1];
	uint32_t xpause_rx_opcode[1];
	uint32_t _xpause_rx_opcode;
} BCM56504_A0_XPAUSE_RX_OPCODEr_t;

#define BCM56504_A0_XPAUSE_RX_OPCODEr_CLR(r) (r).xpause_rx_opcode[0] = 0
#define BCM56504_A0_XPAUSE_RX_OPCODEr_SET(r,d) (r).xpause_rx_opcode[0] = d
#define BCM56504_A0_XPAUSE_RX_OPCODEr_GET(r) (r).xpause_rx_opcode[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_XPAUSE_RX_OPCODEr_OPCODEf_GET(r) (((r).xpause_rx_opcode[0]) & 0xffff)
#define BCM56504_A0_XPAUSE_RX_OPCODEr_OPCODEf_SET(r,f) (r).xpause_rx_opcode[0]=(((r).xpause_rx_opcode[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access XPAUSE_RX_OPCODE.
 *
 */
#define BCM56504_A0_READ_XPAUSE_RX_OPCODEr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_XPAUSE_RX_OPCODEr,(r._xpause_rx_opcode))
#define BCM56504_A0_WRITE_XPAUSE_RX_OPCODEr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_XPAUSE_RX_OPCODEr,&(r._xpause_rx_opcode))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XPAUSE_RX_OPCODEr BCM56504_A0_XPAUSE_RX_OPCODEr
#define XPAUSE_RX_OPCODEr_SIZE BCM56504_A0_XPAUSE_RX_OPCODEr_SIZE
typedef BCM56504_A0_XPAUSE_RX_OPCODEr_t XPAUSE_RX_OPCODEr_t;
#define XPAUSE_RX_OPCODEr_CLR BCM56504_A0_XPAUSE_RX_OPCODEr_CLR
#define XPAUSE_RX_OPCODEr_SET BCM56504_A0_XPAUSE_RX_OPCODEr_SET
#define XPAUSE_RX_OPCODEr_GET BCM56504_A0_XPAUSE_RX_OPCODEr_GET
#define XPAUSE_RX_OPCODEr_OPCODEf_GET BCM56504_A0_XPAUSE_RX_OPCODEr_OPCODEf_GET
#define XPAUSE_RX_OPCODEr_OPCODEf_SET BCM56504_A0_XPAUSE_RX_OPCODEr_OPCODEf_SET
#define READ_XPAUSE_RX_OPCODEr BCM56504_A0_READ_XPAUSE_RX_OPCODEr
#define WRITE_XPAUSE_RX_OPCODEr BCM56504_A0_WRITE_XPAUSE_RX_OPCODEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_XPAUSE_RX_OPCODEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  XPAUSE_TX_PKT_XOFF_VAL
 * BLOCKS:   XPORT0
 * DESC:     XPORT PAUSE XOFF timer value
 * SIZE:     32
 * FIELDS:
 *     XOFF_VAL         XPORT PAUSE XOFF timer value.
 *
 ******************************************************************************/
#define BCM56504_A0_XPAUSE_TX_PKT_XOFF_VALr 0x00f80001

#define BCM56504_A0_XPAUSE_TX_PKT_XOFF_VALr_SIZE 4

/*
 * This structure should be used to declare and program XPAUSE_TX_PKT_XOFF_VAL.
 *
 */
typedef union BCM56504_A0_XPAUSE_TX_PKT_XOFF_VALr_s {
	uint32_t v[1];
	uint32_t xpause_tx_pkt_xoff_val[1];
	uint32_t _xpause_tx_pkt_xoff_val;
} BCM56504_A0_XPAUSE_TX_PKT_XOFF_VALr_t;

#define BCM56504_A0_XPAUSE_TX_PKT_XOFF_VALr_CLR(r) (r).xpause_tx_pkt_xoff_val[0] = 0
#define BCM56504_A0_XPAUSE_TX_PKT_XOFF_VALr_SET(r,d) (r).xpause_tx_pkt_xoff_val[0] = d
#define BCM56504_A0_XPAUSE_TX_PKT_XOFF_VALr_GET(r) (r).xpause_tx_pkt_xoff_val[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_XPAUSE_TX_PKT_XOFF_VALr_XOFF_VALf_GET(r) (((r).xpause_tx_pkt_xoff_val[0]) & 0xffff)
#define BCM56504_A0_XPAUSE_TX_PKT_XOFF_VALr_XOFF_VALf_SET(r,f) (r).xpause_tx_pkt_xoff_val[0]=(((r).xpause_tx_pkt_xoff_val[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access XPAUSE_TX_PKT_XOFF_VAL.
 *
 */
#define BCM56504_A0_READ_XPAUSE_TX_PKT_XOFF_VALr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_XPAUSE_TX_PKT_XOFF_VALr,(r._xpause_tx_pkt_xoff_val))
#define BCM56504_A0_WRITE_XPAUSE_TX_PKT_XOFF_VALr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_XPAUSE_TX_PKT_XOFF_VALr,&(r._xpause_tx_pkt_xoff_val))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XPAUSE_TX_PKT_XOFF_VALr BCM56504_A0_XPAUSE_TX_PKT_XOFF_VALr
#define XPAUSE_TX_PKT_XOFF_VALr_SIZE BCM56504_A0_XPAUSE_TX_PKT_XOFF_VALr_SIZE
typedef BCM56504_A0_XPAUSE_TX_PKT_XOFF_VALr_t XPAUSE_TX_PKT_XOFF_VALr_t;
#define XPAUSE_TX_PKT_XOFF_VALr_CLR BCM56504_A0_XPAUSE_TX_PKT_XOFF_VALr_CLR
#define XPAUSE_TX_PKT_XOFF_VALr_SET BCM56504_A0_XPAUSE_TX_PKT_XOFF_VALr_SET
#define XPAUSE_TX_PKT_XOFF_VALr_GET BCM56504_A0_XPAUSE_TX_PKT_XOFF_VALr_GET
#define XPAUSE_TX_PKT_XOFF_VALr_XOFF_VALf_GET BCM56504_A0_XPAUSE_TX_PKT_XOFF_VALr_XOFF_VALf_GET
#define XPAUSE_TX_PKT_XOFF_VALr_XOFF_VALf_SET BCM56504_A0_XPAUSE_TX_PKT_XOFF_VALr_XOFF_VALf_SET
#define READ_XPAUSE_TX_PKT_XOFF_VALr BCM56504_A0_READ_XPAUSE_TX_PKT_XOFF_VALr
#define WRITE_XPAUSE_TX_PKT_XOFF_VALr BCM56504_A0_WRITE_XPAUSE_TX_PKT_XOFF_VALr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_XPAUSE_TX_PKT_XOFF_VALr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  XPAUSE_WATCHDOG_INIT_VAL
 * BLOCKS:   XPORT0
 * DESC:     XPORT PAUSE Watchdog initial timer loading value
 * SIZE:     32
 * FIELDS:
 *     INIT_VAL         XPORT PAUSE Watchdog timer initial loading value
 *
 ******************************************************************************/
#define BCM56504_A0_XPAUSE_WATCHDOG_INIT_VALr 0x00f80002

#define BCM56504_A0_XPAUSE_WATCHDOG_INIT_VALr_SIZE 4

/*
 * This structure should be used to declare and program XPAUSE_WATCHDOG_INIT_VAL.
 *
 */
typedef union BCM56504_A0_XPAUSE_WATCHDOG_INIT_VALr_s {
	uint32_t v[1];
	uint32_t xpause_watchdog_init_val[1];
	uint32_t _xpause_watchdog_init_val;
} BCM56504_A0_XPAUSE_WATCHDOG_INIT_VALr_t;

#define BCM56504_A0_XPAUSE_WATCHDOG_INIT_VALr_CLR(r) (r).xpause_watchdog_init_val[0] = 0
#define BCM56504_A0_XPAUSE_WATCHDOG_INIT_VALr_SET(r,d) (r).xpause_watchdog_init_val[0] = d
#define BCM56504_A0_XPAUSE_WATCHDOG_INIT_VALr_GET(r) (r).xpause_watchdog_init_val[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_XPAUSE_WATCHDOG_INIT_VALr_INIT_VALf_GET(r) (((r).xpause_watchdog_init_val[0]) & 0xffff)
#define BCM56504_A0_XPAUSE_WATCHDOG_INIT_VALr_INIT_VALf_SET(r,f) (r).xpause_watchdog_init_val[0]=(((r).xpause_watchdog_init_val[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access XPAUSE_WATCHDOG_INIT_VAL.
 *
 */
#define BCM56504_A0_READ_XPAUSE_WATCHDOG_INIT_VALr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_XPAUSE_WATCHDOG_INIT_VALr,(r._xpause_watchdog_init_val))
#define BCM56504_A0_WRITE_XPAUSE_WATCHDOG_INIT_VALr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_XPAUSE_WATCHDOG_INIT_VALr,&(r._xpause_watchdog_init_val))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XPAUSE_WATCHDOG_INIT_VALr BCM56504_A0_XPAUSE_WATCHDOG_INIT_VALr
#define XPAUSE_WATCHDOG_INIT_VALr_SIZE BCM56504_A0_XPAUSE_WATCHDOG_INIT_VALr_SIZE
typedef BCM56504_A0_XPAUSE_WATCHDOG_INIT_VALr_t XPAUSE_WATCHDOG_INIT_VALr_t;
#define XPAUSE_WATCHDOG_INIT_VALr_CLR BCM56504_A0_XPAUSE_WATCHDOG_INIT_VALr_CLR
#define XPAUSE_WATCHDOG_INIT_VALr_SET BCM56504_A0_XPAUSE_WATCHDOG_INIT_VALr_SET
#define XPAUSE_WATCHDOG_INIT_VALr_GET BCM56504_A0_XPAUSE_WATCHDOG_INIT_VALr_GET
#define XPAUSE_WATCHDOG_INIT_VALr_INIT_VALf_GET BCM56504_A0_XPAUSE_WATCHDOG_INIT_VALr_INIT_VALf_GET
#define XPAUSE_WATCHDOG_INIT_VALr_INIT_VALf_SET BCM56504_A0_XPAUSE_WATCHDOG_INIT_VALr_INIT_VALf_SET
#define READ_XPAUSE_WATCHDOG_INIT_VALr BCM56504_A0_READ_XPAUSE_WATCHDOG_INIT_VALr
#define WRITE_XPAUSE_WATCHDOG_INIT_VALr BCM56504_A0_WRITE_XPAUSE_WATCHDOG_INIT_VALr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_XPAUSE_WATCHDOG_INIT_VALr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  XPAUSE_WATCHDOG_THRESH
 * BLOCKS:   XPORT0
 * DESC:     XPORT PAUSE Watchdog XOFF retransmit timer threshold.
 * SIZE:     32
 * FIELDS:
 *     THRESH           XPORT PAUSE Watchdog XOFF retransmit timer threshold
 *
 ******************************************************************************/
#define BCM56504_A0_XPAUSE_WATCHDOG_THRESHr 0x00f80003

#define BCM56504_A0_XPAUSE_WATCHDOG_THRESHr_SIZE 4

/*
 * This structure should be used to declare and program XPAUSE_WATCHDOG_THRESH.
 *
 */
typedef union BCM56504_A0_XPAUSE_WATCHDOG_THRESHr_s {
	uint32_t v[1];
	uint32_t xpause_watchdog_thresh[1];
	uint32_t _xpause_watchdog_thresh;
} BCM56504_A0_XPAUSE_WATCHDOG_THRESHr_t;

#define BCM56504_A0_XPAUSE_WATCHDOG_THRESHr_CLR(r) (r).xpause_watchdog_thresh[0] = 0
#define BCM56504_A0_XPAUSE_WATCHDOG_THRESHr_SET(r,d) (r).xpause_watchdog_thresh[0] = d
#define BCM56504_A0_XPAUSE_WATCHDOG_THRESHr_GET(r) (r).xpause_watchdog_thresh[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_XPAUSE_WATCHDOG_THRESHr_THRESHf_GET(r) (((r).xpause_watchdog_thresh[0]) & 0xffff)
#define BCM56504_A0_XPAUSE_WATCHDOG_THRESHr_THRESHf_SET(r,f) (r).xpause_watchdog_thresh[0]=(((r).xpause_watchdog_thresh[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access XPAUSE_WATCHDOG_THRESH.
 *
 */
#define BCM56504_A0_READ_XPAUSE_WATCHDOG_THRESHr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_XPAUSE_WATCHDOG_THRESHr,(r._xpause_watchdog_thresh))
#define BCM56504_A0_WRITE_XPAUSE_WATCHDOG_THRESHr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_XPAUSE_WATCHDOG_THRESHr,&(r._xpause_watchdog_thresh))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XPAUSE_WATCHDOG_THRESHr BCM56504_A0_XPAUSE_WATCHDOG_THRESHr
#define XPAUSE_WATCHDOG_THRESHr_SIZE BCM56504_A0_XPAUSE_WATCHDOG_THRESHr_SIZE
typedef BCM56504_A0_XPAUSE_WATCHDOG_THRESHr_t XPAUSE_WATCHDOG_THRESHr_t;
#define XPAUSE_WATCHDOG_THRESHr_CLR BCM56504_A0_XPAUSE_WATCHDOG_THRESHr_CLR
#define XPAUSE_WATCHDOG_THRESHr_SET BCM56504_A0_XPAUSE_WATCHDOG_THRESHr_SET
#define XPAUSE_WATCHDOG_THRESHr_GET BCM56504_A0_XPAUSE_WATCHDOG_THRESHr_GET
#define XPAUSE_WATCHDOG_THRESHr_THRESHf_GET BCM56504_A0_XPAUSE_WATCHDOG_THRESHr_THRESHf_GET
#define XPAUSE_WATCHDOG_THRESHr_THRESHf_SET BCM56504_A0_XPAUSE_WATCHDOG_THRESHr_THRESHf_SET
#define READ_XPAUSE_WATCHDOG_THRESHr BCM56504_A0_READ_XPAUSE_WATCHDOG_THRESHr
#define WRITE_XPAUSE_WATCHDOG_THRESHr BCM56504_A0_WRITE_XPAUSE_WATCHDOG_THRESHr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_XPAUSE_WATCHDOG_THRESHr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  XPORT_CONFIG
 * BLOCKS:   XPORT0
 * DESC:     XPORT Configuration register
 * SIZE:     32
 * FIELDS:
 *     XPORT_EN         XPORT enable.
 *     HIGIG_MODE       XPORT is configured as HIGIG port.
 *     XPAUSE_EN        XPORT pausing enable.
 *     E2E_HOL_EN       Enable E2E HOL packet transmit.
 *     E2E_IBP_EN       Enable E2E IBP packet transmit.
 *     MY_MODID         My module ID.
 *     HONOR_PAUSE_FOR_E2E When set, no E2E packets TX if local port is paused.
 *     BIGMAC_RESET     Software control BigMAC reset (active High).
 *
 ******************************************************************************/
#define BCM56504_A0_XPORT_CONFIGr 0x00f80000

#define BCM56504_A0_XPORT_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program XPORT_CONFIG.
 *
 */
typedef union BCM56504_A0_XPORT_CONFIGr_s {
	uint32_t v[1];
	uint32_t xport_config[1];
	uint32_t _xport_config;
} BCM56504_A0_XPORT_CONFIGr_t;

#define BCM56504_A0_XPORT_CONFIGr_CLR(r) (r).xport_config[0] = 0
#define BCM56504_A0_XPORT_CONFIGr_SET(r,d) (r).xport_config[0] = d
#define BCM56504_A0_XPORT_CONFIGr_GET(r) (r).xport_config[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_XPORT_CONFIGr_XPORT_ENf_GET(r) (((r).xport_config[0]) & 0x1)
#define BCM56504_A0_XPORT_CONFIGr_XPORT_ENf_SET(r,f) (r).xport_config[0]=(((r).xport_config[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_XPORT_CONFIGr_HIGIG_MODEf_GET(r) ((((r).xport_config[0]) >> 1) & 0x1)
#define BCM56504_A0_XPORT_CONFIGr_HIGIG_MODEf_SET(r,f) (r).xport_config[0]=(((r).xport_config[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_XPORT_CONFIGr_XPAUSE_ENf_GET(r) ((((r).xport_config[0]) >> 2) & 0x1)
#define BCM56504_A0_XPORT_CONFIGr_XPAUSE_ENf_SET(r,f) (r).xport_config[0]=(((r).xport_config[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_XPORT_CONFIGr_E2E_HOL_ENf_GET(r) ((((r).xport_config[0]) >> 3) & 0x1)
#define BCM56504_A0_XPORT_CONFIGr_E2E_HOL_ENf_SET(r,f) (r).xport_config[0]=(((r).xport_config[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_XPORT_CONFIGr_E2E_IBP_ENf_GET(r) ((((r).xport_config[0]) >> 4) & 0x1)
#define BCM56504_A0_XPORT_CONFIGr_E2E_IBP_ENf_SET(r,f) (r).xport_config[0]=(((r).xport_config[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56504_A0_XPORT_CONFIGr_MY_MODIDf_GET(r) ((((r).xport_config[0]) >> 5) & 0x3f)
#define BCM56504_A0_XPORT_CONFIGr_MY_MODIDf_SET(r,f) (r).xport_config[0]=(((r).xport_config[0] & ~((uint32_t)0x3f << 5)) | ((((uint32_t)f) & 0x3f) << 5))
#define BCM56504_A0_XPORT_CONFIGr_HONOR_PAUSE_FOR_E2Ef_GET(r) ((((r).xport_config[0]) >> 11) & 0x1)
#define BCM56504_A0_XPORT_CONFIGr_HONOR_PAUSE_FOR_E2Ef_SET(r,f) (r).xport_config[0]=(((r).xport_config[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56504_A0_XPORT_CONFIGr_BIGMAC_RESETf_GET(r) ((((r).xport_config[0]) >> 12) & 0x1)
#define BCM56504_A0_XPORT_CONFIGr_BIGMAC_RESETf_SET(r,f) (r).xport_config[0]=(((r).xport_config[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))

/*
 * These macros can be used to access XPORT_CONFIG.
 *
 */
#define BCM56504_A0_READ_XPORT_CONFIGr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_XPORT_CONFIGr,(r._xport_config))
#define BCM56504_A0_WRITE_XPORT_CONFIGr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_XPORT_CONFIGr,&(r._xport_config))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XPORT_CONFIGr BCM56504_A0_XPORT_CONFIGr
#define XPORT_CONFIGr_SIZE BCM56504_A0_XPORT_CONFIGr_SIZE
typedef BCM56504_A0_XPORT_CONFIGr_t XPORT_CONFIGr_t;
#define XPORT_CONFIGr_CLR BCM56504_A0_XPORT_CONFIGr_CLR
#define XPORT_CONFIGr_SET BCM56504_A0_XPORT_CONFIGr_SET
#define XPORT_CONFIGr_GET BCM56504_A0_XPORT_CONFIGr_GET
#define XPORT_CONFIGr_XPORT_ENf_GET BCM56504_A0_XPORT_CONFIGr_XPORT_ENf_GET
#define XPORT_CONFIGr_XPORT_ENf_SET BCM56504_A0_XPORT_CONFIGr_XPORT_ENf_SET
#define XPORT_CONFIGr_HIGIG_MODEf_GET BCM56504_A0_XPORT_CONFIGr_HIGIG_MODEf_GET
#define XPORT_CONFIGr_HIGIG_MODEf_SET BCM56504_A0_XPORT_CONFIGr_HIGIG_MODEf_SET
#define XPORT_CONFIGr_XPAUSE_ENf_GET BCM56504_A0_XPORT_CONFIGr_XPAUSE_ENf_GET
#define XPORT_CONFIGr_XPAUSE_ENf_SET BCM56504_A0_XPORT_CONFIGr_XPAUSE_ENf_SET
#define XPORT_CONFIGr_E2E_HOL_ENf_GET BCM56504_A0_XPORT_CONFIGr_E2E_HOL_ENf_GET
#define XPORT_CONFIGr_E2E_HOL_ENf_SET BCM56504_A0_XPORT_CONFIGr_E2E_HOL_ENf_SET
#define XPORT_CONFIGr_E2E_IBP_ENf_GET BCM56504_A0_XPORT_CONFIGr_E2E_IBP_ENf_GET
#define XPORT_CONFIGr_E2E_IBP_ENf_SET BCM56504_A0_XPORT_CONFIGr_E2E_IBP_ENf_SET
#define XPORT_CONFIGr_MY_MODIDf_GET BCM56504_A0_XPORT_CONFIGr_MY_MODIDf_GET
#define XPORT_CONFIGr_MY_MODIDf_SET BCM56504_A0_XPORT_CONFIGr_MY_MODIDf_SET
#define XPORT_CONFIGr_HONOR_PAUSE_FOR_E2Ef_GET BCM56504_A0_XPORT_CONFIGr_HONOR_PAUSE_FOR_E2Ef_GET
#define XPORT_CONFIGr_HONOR_PAUSE_FOR_E2Ef_SET BCM56504_A0_XPORT_CONFIGr_HONOR_PAUSE_FOR_E2Ef_SET
#define XPORT_CONFIGr_BIGMAC_RESETf_GET BCM56504_A0_XPORT_CONFIGr_BIGMAC_RESETf_GET
#define XPORT_CONFIGr_BIGMAC_RESETf_SET BCM56504_A0_XPORT_CONFIGr_BIGMAC_RESETf_SET
#define READ_XPORT_CONFIGr BCM56504_A0_READ_XPORT_CONFIGr
#define WRITE_XPORT_CONFIGr BCM56504_A0_WRITE_XPORT_CONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_XPORT_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  XP_EGR_PKT_DROP_CTL
 * BLOCKS:   XPORT0
 * DESC:     Flush enable control of XPORT register
 * SIZE:     32
 * FIELDS:
 *     FLUSH            Flush enable bit to drop packets in XPORT
 *
 ******************************************************************************/
#define BCM56504_A0_XP_EGR_PKT_DROP_CTLr 0x00f8001d

#define BCM56504_A0_XP_EGR_PKT_DROP_CTLr_SIZE 4

/*
 * This structure should be used to declare and program XP_EGR_PKT_DROP_CTL.
 *
 */
typedef union BCM56504_A0_XP_EGR_PKT_DROP_CTLr_s {
	uint32_t v[1];
	uint32_t xp_egr_pkt_drop_ctl[1];
	uint32_t _xp_egr_pkt_drop_ctl;
} BCM56504_A0_XP_EGR_PKT_DROP_CTLr_t;

#define BCM56504_A0_XP_EGR_PKT_DROP_CTLr_CLR(r) (r).xp_egr_pkt_drop_ctl[0] = 0
#define BCM56504_A0_XP_EGR_PKT_DROP_CTLr_SET(r,d) (r).xp_egr_pkt_drop_ctl[0] = d
#define BCM56504_A0_XP_EGR_PKT_DROP_CTLr_GET(r) (r).xp_egr_pkt_drop_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_XP_EGR_PKT_DROP_CTLr_FLUSHf_GET(r) (((r).xp_egr_pkt_drop_ctl[0]) & 0x1)
#define BCM56504_A0_XP_EGR_PKT_DROP_CTLr_FLUSHf_SET(r,f) (r).xp_egr_pkt_drop_ctl[0]=(((r).xp_egr_pkt_drop_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access XP_EGR_PKT_DROP_CTL.
 *
 */
#define BCM56504_A0_READ_XP_EGR_PKT_DROP_CTLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_XP_EGR_PKT_DROP_CTLr,(r._xp_egr_pkt_drop_ctl))
#define BCM56504_A0_WRITE_XP_EGR_PKT_DROP_CTLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_XP_EGR_PKT_DROP_CTLr,&(r._xp_egr_pkt_drop_ctl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XP_EGR_PKT_DROP_CTLr BCM56504_A0_XP_EGR_PKT_DROP_CTLr
#define XP_EGR_PKT_DROP_CTLr_SIZE BCM56504_A0_XP_EGR_PKT_DROP_CTLr_SIZE
typedef BCM56504_A0_XP_EGR_PKT_DROP_CTLr_t XP_EGR_PKT_DROP_CTLr_t;
#define XP_EGR_PKT_DROP_CTLr_CLR BCM56504_A0_XP_EGR_PKT_DROP_CTLr_CLR
#define XP_EGR_PKT_DROP_CTLr_SET BCM56504_A0_XP_EGR_PKT_DROP_CTLr_SET
#define XP_EGR_PKT_DROP_CTLr_GET BCM56504_A0_XP_EGR_PKT_DROP_CTLr_GET
#define XP_EGR_PKT_DROP_CTLr_FLUSHf_GET BCM56504_A0_XP_EGR_PKT_DROP_CTLr_FLUSHf_GET
#define XP_EGR_PKT_DROP_CTLr_FLUSHf_SET BCM56504_A0_XP_EGR_PKT_DROP_CTLr_FLUSHf_SET
#define READ_XP_EGR_PKT_DROP_CTLr BCM56504_A0_READ_XP_EGR_PKT_DROP_CTLr
#define WRITE_XP_EGR_PKT_DROP_CTLr BCM56504_A0_WRITE_XP_EGR_PKT_DROP_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_XP_EGR_PKT_DROP_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  XP_XBODE_CELL_CNT
 * BLOCKS:   XPORT0
 * DESC:     XBODE cell count register
 * SIZE:     32
 * FIELDS:
 *     CELL_CNT         Number of cell counts in XBODE tx fifo
 *
 ******************************************************************************/
#define BCM56504_A0_XP_XBODE_CELL_CNTr 0x00f8001e

#define BCM56504_A0_XP_XBODE_CELL_CNTr_SIZE 4

/*
 * This structure should be used to declare and program XP_XBODE_CELL_CNT.
 *
 */
typedef union BCM56504_A0_XP_XBODE_CELL_CNTr_s {
	uint32_t v[1];
	uint32_t xp_xbode_cell_cnt[1];
	uint32_t _xp_xbode_cell_cnt;
} BCM56504_A0_XP_XBODE_CELL_CNTr_t;

#define BCM56504_A0_XP_XBODE_CELL_CNTr_CLR(r) (r).xp_xbode_cell_cnt[0] = 0
#define BCM56504_A0_XP_XBODE_CELL_CNTr_SET(r,d) (r).xp_xbode_cell_cnt[0] = d
#define BCM56504_A0_XP_XBODE_CELL_CNTr_GET(r) (r).xp_xbode_cell_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_XP_XBODE_CELL_CNTr_CELL_CNTf_GET(r) (((r).xp_xbode_cell_cnt[0]) & 0xf)
#define BCM56504_A0_XP_XBODE_CELL_CNTr_CELL_CNTf_SET(r,f) (r).xp_xbode_cell_cnt[0]=(((r).xp_xbode_cell_cnt[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access XP_XBODE_CELL_CNT.
 *
 */
#define BCM56504_A0_READ_XP_XBODE_CELL_CNTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_XP_XBODE_CELL_CNTr,(r._xp_xbode_cell_cnt))
#define BCM56504_A0_WRITE_XP_XBODE_CELL_CNTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_XP_XBODE_CELL_CNTr,&(r._xp_xbode_cell_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XP_XBODE_CELL_CNTr BCM56504_A0_XP_XBODE_CELL_CNTr
#define XP_XBODE_CELL_CNTr_SIZE BCM56504_A0_XP_XBODE_CELL_CNTr_SIZE
typedef BCM56504_A0_XP_XBODE_CELL_CNTr_t XP_XBODE_CELL_CNTr_t;
#define XP_XBODE_CELL_CNTr_CLR BCM56504_A0_XP_XBODE_CELL_CNTr_CLR
#define XP_XBODE_CELL_CNTr_SET BCM56504_A0_XP_XBODE_CELL_CNTr_SET
#define XP_XBODE_CELL_CNTr_GET BCM56504_A0_XP_XBODE_CELL_CNTr_GET
#define XP_XBODE_CELL_CNTr_CELL_CNTf_GET BCM56504_A0_XP_XBODE_CELL_CNTr_CELL_CNTf_GET
#define XP_XBODE_CELL_CNTr_CELL_CNTf_SET BCM56504_A0_XP_XBODE_CELL_CNTr_CELL_CNTf_SET
#define READ_XP_XBODE_CELL_CNTr BCM56504_A0_READ_XP_XBODE_CELL_CNTr
#define WRITE_XP_XBODE_CELL_CNTr BCM56504_A0_WRITE_XP_XBODE_CELL_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_XP_XBODE_CELL_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  XP_XBODE_CELL_REQ_CNT
 * BLOCKS:   XPORT0
 * DESC:     XBODE cell request count register
 * SIZE:     32
 * FIELDS:
 *     REQ_CNT          Number of cell requests made to Egress Pipeline, MAX is 12
 *
 ******************************************************************************/
#define BCM56504_A0_XP_XBODE_CELL_REQ_CNTr 0x00f8001f

#define BCM56504_A0_XP_XBODE_CELL_REQ_CNTr_SIZE 4

/*
 * This structure should be used to declare and program XP_XBODE_CELL_REQ_CNT.
 *
 */
typedef union BCM56504_A0_XP_XBODE_CELL_REQ_CNTr_s {
	uint32_t v[1];
	uint32_t xp_xbode_cell_req_cnt[1];
	uint32_t _xp_xbode_cell_req_cnt;
} BCM56504_A0_XP_XBODE_CELL_REQ_CNTr_t;

#define BCM56504_A0_XP_XBODE_CELL_REQ_CNTr_CLR(r) (r).xp_xbode_cell_req_cnt[0] = 0
#define BCM56504_A0_XP_XBODE_CELL_REQ_CNTr_SET(r,d) (r).xp_xbode_cell_req_cnt[0] = d
#define BCM56504_A0_XP_XBODE_CELL_REQ_CNTr_GET(r) (r).xp_xbode_cell_req_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_XP_XBODE_CELL_REQ_CNTr_REQ_CNTf_GET(r) (((r).xp_xbode_cell_req_cnt[0]) & 0xf)
#define BCM56504_A0_XP_XBODE_CELL_REQ_CNTr_REQ_CNTf_SET(r,f) (r).xp_xbode_cell_req_cnt[0]=(((r).xp_xbode_cell_req_cnt[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access XP_XBODE_CELL_REQ_CNT.
 *
 */
#define BCM56504_A0_READ_XP_XBODE_CELL_REQ_CNTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_XP_XBODE_CELL_REQ_CNTr,(r._xp_xbode_cell_req_cnt))
#define BCM56504_A0_WRITE_XP_XBODE_CELL_REQ_CNTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_XP_XBODE_CELL_REQ_CNTr,&(r._xp_xbode_cell_req_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XP_XBODE_CELL_REQ_CNTr BCM56504_A0_XP_XBODE_CELL_REQ_CNTr
#define XP_XBODE_CELL_REQ_CNTr_SIZE BCM56504_A0_XP_XBODE_CELL_REQ_CNTr_SIZE
typedef BCM56504_A0_XP_XBODE_CELL_REQ_CNTr_t XP_XBODE_CELL_REQ_CNTr_t;
#define XP_XBODE_CELL_REQ_CNTr_CLR BCM56504_A0_XP_XBODE_CELL_REQ_CNTr_CLR
#define XP_XBODE_CELL_REQ_CNTr_SET BCM56504_A0_XP_XBODE_CELL_REQ_CNTr_SET
#define XP_XBODE_CELL_REQ_CNTr_GET BCM56504_A0_XP_XBODE_CELL_REQ_CNTr_GET
#define XP_XBODE_CELL_REQ_CNTr_REQ_CNTf_GET BCM56504_A0_XP_XBODE_CELL_REQ_CNTr_REQ_CNTf_GET
#define XP_XBODE_CELL_REQ_CNTr_REQ_CNTf_SET BCM56504_A0_XP_XBODE_CELL_REQ_CNTr_REQ_CNTf_SET
#define READ_XP_XBODE_CELL_REQ_CNTr BCM56504_A0_READ_XP_XBODE_CELL_REQ_CNTr
#define WRITE_XP_XBODE_CELL_REQ_CNTr BCM56504_A0_WRITE_XP_XBODE_CELL_REQ_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_XP_XBODE_CELL_REQ_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  XQCOSARBSEL
 * BLOCKS:   MMU
 * DESC:     Scheduler Control Selection
 * SIZE:     32
 * FIELDS:
 *     COSARB           Scheduler Control OptionscosArb[1:0]=0: Strict priority among valid COSs. (default value.)cosArb[1:0]=1: Round Robin Queueing among valid COSs.cosArb[1:0]=2: Weightd Round Robin Queueing, WRR, scheduling according to WRR Weight.cosArb[1:0]=3: Deficit Round Robin Queueing, DRR, scheduling according to WRR Weight.
 *
 ******************************************************************************/
#define BCM56504_A0_XQCOSARBSELr 0x00600045

#define BCM56504_A0_XQCOSARBSELr_SIZE 4

/*
 * This structure should be used to declare and program XQCOSARBSEL.
 *
 */
typedef union BCM56504_A0_XQCOSARBSELr_s {
	uint32_t v[1];
	uint32_t xqcosarbsel[1];
	uint32_t _xqcosarbsel;
} BCM56504_A0_XQCOSARBSELr_t;

#define BCM56504_A0_XQCOSARBSELr_CLR(r) (r).xqcosarbsel[0] = 0
#define BCM56504_A0_XQCOSARBSELr_SET(r,d) (r).xqcosarbsel[0] = d
#define BCM56504_A0_XQCOSARBSELr_GET(r) (r).xqcosarbsel[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_XQCOSARBSELr_COSARBf_GET(r) (((r).xqcosarbsel[0]) & 0x3)
#define BCM56504_A0_XQCOSARBSELr_COSARBf_SET(r,f) (r).xqcosarbsel[0]=(((r).xqcosarbsel[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))

/*
 * These macros can be used to access XQCOSARBSEL.
 *
 */
#define BCM56504_A0_READ_XQCOSARBSELr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_XQCOSARBSELr,(r._xqcosarbsel))
#define BCM56504_A0_WRITE_XQCOSARBSELr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_XQCOSARBSELr,&(r._xqcosarbsel))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XQCOSARBSELr BCM56504_A0_XQCOSARBSELr
#define XQCOSARBSELr_SIZE BCM56504_A0_XQCOSARBSELr_SIZE
typedef BCM56504_A0_XQCOSARBSELr_t XQCOSARBSELr_t;
#define XQCOSARBSELr_CLR BCM56504_A0_XQCOSARBSELr_CLR
#define XQCOSARBSELr_SET BCM56504_A0_XQCOSARBSELr_SET
#define XQCOSARBSELr_GET BCM56504_A0_XQCOSARBSELr_GET
#define XQCOSARBSELr_COSARBf_GET BCM56504_A0_XQCOSARBSELr_COSARBf_GET
#define XQCOSARBSELr_COSARBf_SET BCM56504_A0_XQCOSARBSELr_COSARBf_SET
#define READ_XQCOSARBSELr BCM56504_A0_READ_XQCOSARBSELr
#define WRITE_XQCOSARBSELr BCM56504_A0_WRITE_XQCOSARBSELr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_XQCOSARBSELr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  XQEMPTY
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     COS0             COS0 has no entries for this port
 *     COS1             COS1 has no entries for this port
 *     COS2             COS2 has no entries for this port
 *     COS3             COS3 has no entries for this port
 *     COS4             COS4 has no entries for this port
 *     COS5             COS5 has no entries for this port
 *     COS6             COS6 has no entries for this port
 *     COS7             COS7 has no entries for this port
 *
 ******************************************************************************/
#define BCM56504_A0_XQEMPTYr 0x00600042

#define BCM56504_A0_XQEMPTYr_SIZE 4

/*
 * This structure should be used to declare and program XQEMPTY.
 *
 */
typedef union BCM56504_A0_XQEMPTYr_s {
	uint32_t v[1];
	uint32_t xqempty[1];
	uint32_t _xqempty;
} BCM56504_A0_XQEMPTYr_t;

#define BCM56504_A0_XQEMPTYr_CLR(r) (r).xqempty[0] = 0
#define BCM56504_A0_XQEMPTYr_SET(r,d) (r).xqempty[0] = d
#define BCM56504_A0_XQEMPTYr_GET(r) (r).xqempty[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_XQEMPTYr_COS0f_GET(r) (((r).xqempty[0]) & 0x1)
#define BCM56504_A0_XQEMPTYr_COS0f_SET(r,f) (r).xqempty[0]=(((r).xqempty[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_XQEMPTYr_COS1f_GET(r) ((((r).xqempty[0]) >> 1) & 0x1)
#define BCM56504_A0_XQEMPTYr_COS1f_SET(r,f) (r).xqempty[0]=(((r).xqempty[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56504_A0_XQEMPTYr_COS2f_GET(r) ((((r).xqempty[0]) >> 2) & 0x1)
#define BCM56504_A0_XQEMPTYr_COS2f_SET(r,f) (r).xqempty[0]=(((r).xqempty[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56504_A0_XQEMPTYr_COS3f_GET(r) ((((r).xqempty[0]) >> 3) & 0x1)
#define BCM56504_A0_XQEMPTYr_COS3f_SET(r,f) (r).xqempty[0]=(((r).xqempty[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56504_A0_XQEMPTYr_COS4f_GET(r) ((((r).xqempty[0]) >> 4) & 0x1)
#define BCM56504_A0_XQEMPTYr_COS4f_SET(r,f) (r).xqempty[0]=(((r).xqempty[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56504_A0_XQEMPTYr_COS5f_GET(r) ((((r).xqempty[0]) >> 5) & 0x1)
#define BCM56504_A0_XQEMPTYr_COS5f_SET(r,f) (r).xqempty[0]=(((r).xqempty[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56504_A0_XQEMPTYr_COS6f_GET(r) ((((r).xqempty[0]) >> 6) & 0x1)
#define BCM56504_A0_XQEMPTYr_COS6f_SET(r,f) (r).xqempty[0]=(((r).xqempty[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56504_A0_XQEMPTYr_COS7f_GET(r) ((((r).xqempty[0]) >> 7) & 0x1)
#define BCM56504_A0_XQEMPTYr_COS7f_SET(r,f) (r).xqempty[0]=(((r).xqempty[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access XQEMPTY.
 *
 */
#define BCM56504_A0_READ_XQEMPTYr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_XQEMPTYr,(r._xqempty))
#define BCM56504_A0_WRITE_XQEMPTYr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_XQEMPTYr,&(r._xqempty))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XQEMPTYr BCM56504_A0_XQEMPTYr
#define XQEMPTYr_SIZE BCM56504_A0_XQEMPTYr_SIZE
typedef BCM56504_A0_XQEMPTYr_t XQEMPTYr_t;
#define XQEMPTYr_CLR BCM56504_A0_XQEMPTYr_CLR
#define XQEMPTYr_SET BCM56504_A0_XQEMPTYr_SET
#define XQEMPTYr_GET BCM56504_A0_XQEMPTYr_GET
#define XQEMPTYr_COS0f_GET BCM56504_A0_XQEMPTYr_COS0f_GET
#define XQEMPTYr_COS0f_SET BCM56504_A0_XQEMPTYr_COS0f_SET
#define XQEMPTYr_COS1f_GET BCM56504_A0_XQEMPTYr_COS1f_GET
#define XQEMPTYr_COS1f_SET BCM56504_A0_XQEMPTYr_COS1f_SET
#define XQEMPTYr_COS2f_GET BCM56504_A0_XQEMPTYr_COS2f_GET
#define XQEMPTYr_COS2f_SET BCM56504_A0_XQEMPTYr_COS2f_SET
#define XQEMPTYr_COS3f_GET BCM56504_A0_XQEMPTYr_COS3f_GET
#define XQEMPTYr_COS3f_SET BCM56504_A0_XQEMPTYr_COS3f_SET
#define XQEMPTYr_COS4f_GET BCM56504_A0_XQEMPTYr_COS4f_GET
#define XQEMPTYr_COS4f_SET BCM56504_A0_XQEMPTYr_COS4f_SET
#define XQEMPTYr_COS5f_GET BCM56504_A0_XQEMPTYr_COS5f_GET
#define XQEMPTYr_COS5f_SET BCM56504_A0_XQEMPTYr_COS5f_SET
#define XQEMPTYr_COS6f_GET BCM56504_A0_XQEMPTYr_COS6f_GET
#define XQEMPTYr_COS6f_SET BCM56504_A0_XQEMPTYr_COS6f_SET
#define XQEMPTYr_COS7f_GET BCM56504_A0_XQEMPTYr_COS7f_GET
#define XQEMPTYr_COS7f_SET BCM56504_A0_XQEMPTYr_COS7f_SET
#define READ_XQEMPTYr BCM56504_A0_READ_XQEMPTYr
#define WRITE_XQEMPTYr BCM56504_A0_WRITE_XQEMPTYr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_XQEMPTYr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  XQMEMDEBUG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CCM              ccm registers.
 *     RM               rm registers.
 *
 ******************************************************************************/
#define BCM56504_A0_XQMEMDEBUGr 0x00600073

#define BCM56504_A0_XQMEMDEBUGr_SIZE 4

/*
 * This structure should be used to declare and program XQMEMDEBUG.
 *
 */
typedef union BCM56504_A0_XQMEMDEBUGr_s {
	uint32_t v[1];
	uint32_t xqmemdebug[1];
	uint32_t _xqmemdebug;
} BCM56504_A0_XQMEMDEBUGr_t;

#define BCM56504_A0_XQMEMDEBUGr_CLR(r) (r).xqmemdebug[0] = 0
#define BCM56504_A0_XQMEMDEBUGr_SET(r,d) (r).xqmemdebug[0] = d
#define BCM56504_A0_XQMEMDEBUGr_GET(r) (r).xqmemdebug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_XQMEMDEBUGr_CCMf_GET(r) (((r).xqmemdebug[0]) & 0x1)
#define BCM56504_A0_XQMEMDEBUGr_CCMf_SET(r,f) (r).xqmemdebug[0]=(((r).xqmemdebug[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56504_A0_XQMEMDEBUGr_RMf_GET(r) ((((r).xqmemdebug[0]) >> 1) & 0x1)
#define BCM56504_A0_XQMEMDEBUGr_RMf_SET(r,f) (r).xqmemdebug[0]=(((r).xqmemdebug[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access XQMEMDEBUG.
 *
 */
#define BCM56504_A0_READ_XQMEMDEBUGr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_XQMEMDEBUGr,(r._xqmemdebug))
#define BCM56504_A0_WRITE_XQMEMDEBUGr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_XQMEMDEBUGr,&(r._xqmemdebug))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XQMEMDEBUGr BCM56504_A0_XQMEMDEBUGr
#define XQMEMDEBUGr_SIZE BCM56504_A0_XQMEMDEBUGr_SIZE
typedef BCM56504_A0_XQMEMDEBUGr_t XQMEMDEBUGr_t;
#define XQMEMDEBUGr_CLR BCM56504_A0_XQMEMDEBUGr_CLR
#define XQMEMDEBUGr_SET BCM56504_A0_XQMEMDEBUGr_SET
#define XQMEMDEBUGr_GET BCM56504_A0_XQMEMDEBUGr_GET
#define XQMEMDEBUGr_CCMf_GET BCM56504_A0_XQMEMDEBUGr_CCMf_GET
#define XQMEMDEBUGr_CCMf_SET BCM56504_A0_XQMEMDEBUGr_CCMf_SET
#define XQMEMDEBUGr_RMf_GET BCM56504_A0_XQMEMDEBUGr_RMf_GET
#define XQMEMDEBUGr_RMf_SET BCM56504_A0_XQMEMDEBUGr_RMf_SET
#define READ_XQMEMDEBUGr BCM56504_A0_READ_XQMEMDEBUGr
#define WRITE_XQMEMDEBUGr BCM56504_A0_WRITE_XQMEMDEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_XQMEMDEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  XQPARITYERRORPBM
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     XQPARITYERRORPBM Egress Port Bitmap indicats which egress port detects XQ parity error.Bitmap will be clear after a register read.
 *
 ******************************************************************************/
#define BCM56504_A0_XQPARITYERRORPBMr 0x00680037

#define BCM56504_A0_XQPARITYERRORPBMr_SIZE 4

/*
 * This structure should be used to declare and program XQPARITYERRORPBM.
 *
 */
typedef union BCM56504_A0_XQPARITYERRORPBMr_s {
	uint32_t v[1];
	uint32_t xqparityerrorpbm[1];
	uint32_t _xqparityerrorpbm;
} BCM56504_A0_XQPARITYERRORPBMr_t;

#define BCM56504_A0_XQPARITYERRORPBMr_CLR(r) (r).xqparityerrorpbm[0] = 0
#define BCM56504_A0_XQPARITYERRORPBMr_SET(r,d) (r).xqparityerrorpbm[0] = d
#define BCM56504_A0_XQPARITYERRORPBMr_GET(r) (r).xqparityerrorpbm[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_XQPARITYERRORPBMr_XQPARITYERRORPBMf_GET(r) (((r).xqparityerrorpbm[0]) & 0x1fffffff)
#define BCM56504_A0_XQPARITYERRORPBMr_XQPARITYERRORPBMf_SET(r,f) (r).xqparityerrorpbm[0]=(((r).xqparityerrorpbm[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))

/*
 * These macros can be used to access XQPARITYERRORPBM.
 *
 */
#define BCM56504_A0_READ_XQPARITYERRORPBMr(u,r) cdk_xgs_reg32_read(u,BCM56504_A0_XQPARITYERRORPBMr,(r._xqparityerrorpbm))
#define BCM56504_A0_WRITE_XQPARITYERRORPBMr(u,r) cdk_xgs_reg32_write(u,BCM56504_A0_XQPARITYERRORPBMr,&(r._xqparityerrorpbm))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XQPARITYERRORPBMr BCM56504_A0_XQPARITYERRORPBMr
#define XQPARITYERRORPBMr_SIZE BCM56504_A0_XQPARITYERRORPBMr_SIZE
typedef BCM56504_A0_XQPARITYERRORPBMr_t XQPARITYERRORPBMr_t;
#define XQPARITYERRORPBMr_CLR BCM56504_A0_XQPARITYERRORPBMr_CLR
#define XQPARITYERRORPBMr_SET BCM56504_A0_XQPARITYERRORPBMr_SET
#define XQPARITYERRORPBMr_GET BCM56504_A0_XQPARITYERRORPBMr_GET
#define XQPARITYERRORPBMr_XQPARITYERRORPBMf_GET BCM56504_A0_XQPARITYERRORPBMr_XQPARITYERRORPBMf_GET
#define XQPARITYERRORPBMr_XQPARITYERRORPBMf_SET BCM56504_A0_XQPARITYERRORPBMr_XQPARITYERRORPBMf_SET
#define READ_XQPARITYERRORPBMr BCM56504_A0_READ_XQPARITYERRORPBMr
#define WRITE_XQPARITYERRORPBMr BCM56504_A0_WRITE_XQPARITYERRORPBMr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_XQPARITYERRORPBMr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  XQPARITYERRORPTR
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     XQPARITYERRORPTR Egress Port XQ's parity error packet pointer keeps the abandonedxq parity errored memory address.
 *     XQPARITYERRORPKTPTR Egress Port XQ's parity error packet pointer keeps the abandonedxq parity errored memory read data's packet pointer.
 *
 ******************************************************************************/
#define BCM56504_A0_XQPARITYERRORPTRr 0x00600072

#define BCM56504_A0_XQPARITYERRORPTRr_SIZE 4

/*
 * This structure should be used to declare and program XQPARITYERRORPTR.
 *
 */
typedef union BCM56504_A0_XQPARITYERRORPTRr_s {
	uint32_t v[1];
	uint32_t xqparityerrorptr[1];
	uint32_t _xqparityerrorptr;
} BCM56504_A0_XQPARITYERRORPTRr_t;

#define BCM56504_A0_XQPARITYERRORPTRr_CLR(r) (r).xqparityerrorptr[0] = 0
#define BCM56504_A0_XQPARITYERRORPTRr_SET(r,d) (r).xqparityerrorptr[0] = d
#define BCM56504_A0_XQPARITYERRORPTRr_GET(r) (r).xqparityerrorptr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_XQPARITYERRORPTRr_XQPARITYERRORPTRf_GET(r) (((r).xqparityerrorptr[0]) & 0x7ff)
#define BCM56504_A0_XQPARITYERRORPTRr_XQPARITYERRORPTRf_SET(r,f) (r).xqparityerrorptr[0]=(((r).xqparityerrorptr[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM56504_A0_XQPARITYERRORPTRr_XQPARITYERRORPKTPTRf_GET(r) ((((r).xqparityerrorptr[0]) >> 11) & 0x3fff)
#define BCM56504_A0_XQPARITYERRORPTRr_XQPARITYERRORPKTPTRf_SET(r,f) (r).xqparityerrorptr[0]=(((r).xqparityerrorptr[0] & ~((uint32_t)0x3fff << 11)) | ((((uint32_t)f) & 0x3fff) << 11))

/*
 * These macros can be used to access XQPARITYERRORPTR.
 *
 */
#define BCM56504_A0_READ_XQPARITYERRORPTRr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_XQPARITYERRORPTRr,(r._xqparityerrorptr))
#define BCM56504_A0_WRITE_XQPARITYERRORPTRr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_XQPARITYERRORPTRr,&(r._xqparityerrorptr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XQPARITYERRORPTRr BCM56504_A0_XQPARITYERRORPTRr
#define XQPARITYERRORPTRr_SIZE BCM56504_A0_XQPARITYERRORPTRr_SIZE
typedef BCM56504_A0_XQPARITYERRORPTRr_t XQPARITYERRORPTRr_t;
#define XQPARITYERRORPTRr_CLR BCM56504_A0_XQPARITYERRORPTRr_CLR
#define XQPARITYERRORPTRr_SET BCM56504_A0_XQPARITYERRORPTRr_SET
#define XQPARITYERRORPTRr_GET BCM56504_A0_XQPARITYERRORPTRr_GET
#define XQPARITYERRORPTRr_XQPARITYERRORPTRf_GET BCM56504_A0_XQPARITYERRORPTRr_XQPARITYERRORPTRf_GET
#define XQPARITYERRORPTRr_XQPARITYERRORPTRf_SET BCM56504_A0_XQPARITYERRORPTRr_XQPARITYERRORPTRf_SET
#define XQPARITYERRORPTRr_XQPARITYERRORPKTPTRf_GET BCM56504_A0_XQPARITYERRORPTRr_XQPARITYERRORPKTPTRf_GET
#define XQPARITYERRORPTRr_XQPARITYERRORPKTPTRf_SET BCM56504_A0_XQPARITYERRORPTRr_XQPARITYERRORPKTPTRf_SET
#define READ_XQPARITYERRORPTRr BCM56504_A0_READ_XQPARITYERRORPTRr
#define WRITE_XQPARITYERRORPTRr BCM56504_A0_WRITE_XQPARITYERRORPTRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_XQPARITYERRORPTRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  XQREADPOINTER
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     READPOINTER      Current read address of XQ memory.
 *     COS              Currnet COS of XQ read pointer.
 *
 ******************************************************************************/
#define BCM56504_A0_XQREADPOINTERr 0x00600043

#define BCM56504_A0_XQREADPOINTERr_SIZE 4

/*
 * This structure should be used to declare and program XQREADPOINTER.
 *
 */
typedef union BCM56504_A0_XQREADPOINTERr_s {
	uint32_t v[1];
	uint32_t xqreadpointer[1];
	uint32_t _xqreadpointer;
} BCM56504_A0_XQREADPOINTERr_t;

#define BCM56504_A0_XQREADPOINTERr_CLR(r) (r).xqreadpointer[0] = 0
#define BCM56504_A0_XQREADPOINTERr_SET(r,d) (r).xqreadpointer[0] = d
#define BCM56504_A0_XQREADPOINTERr_GET(r) (r).xqreadpointer[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_XQREADPOINTERr_READPOINTERf_GET(r) (((r).xqreadpointer[0]) & 0x7ff)
#define BCM56504_A0_XQREADPOINTERr_READPOINTERf_SET(r,f) (r).xqreadpointer[0]=(((r).xqreadpointer[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM56504_A0_XQREADPOINTERr_COSf_GET(r) ((((r).xqreadpointer[0]) >> 11) & 0x7)
#define BCM56504_A0_XQREADPOINTERr_COSf_SET(r,f) (r).xqreadpointer[0]=(((r).xqreadpointer[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11))

/*
 * These macros can be used to access XQREADPOINTER.
 *
 */
#define BCM56504_A0_READ_XQREADPOINTERr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_XQREADPOINTERr,(r._xqreadpointer))
#define BCM56504_A0_WRITE_XQREADPOINTERr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_XQREADPOINTERr,&(r._xqreadpointer))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XQREADPOINTERr BCM56504_A0_XQREADPOINTERr
#define XQREADPOINTERr_SIZE BCM56504_A0_XQREADPOINTERr_SIZE
typedef BCM56504_A0_XQREADPOINTERr_t XQREADPOINTERr_t;
#define XQREADPOINTERr_CLR BCM56504_A0_XQREADPOINTERr_CLR
#define XQREADPOINTERr_SET BCM56504_A0_XQREADPOINTERr_SET
#define XQREADPOINTERr_GET BCM56504_A0_XQREADPOINTERr_GET
#define XQREADPOINTERr_READPOINTERf_GET BCM56504_A0_XQREADPOINTERr_READPOINTERf_GET
#define XQREADPOINTERr_READPOINTERf_SET BCM56504_A0_XQREADPOINTERr_READPOINTERf_SET
#define XQREADPOINTERr_COSf_GET BCM56504_A0_XQREADPOINTERr_COSf_GET
#define XQREADPOINTERr_COSf_SET BCM56504_A0_XQREADPOINTERr_COSf_SET
#define READ_XQREADPOINTERr BCM56504_A0_READ_XQREADPOINTERr
#define WRITE_XQREADPOINTERr BCM56504_A0_WRITE_XQREADPOINTERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_XQREADPOINTERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  XTHOL
 * BLOCKS:   XPORT0
 * DESC:     Transmit End-to-End HOL packet counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            Incremented for each E2E HOL packet transmitted.
 *
 ******************************************************************************/
#define BCM56504_A0_XTHOLr 0x00f00101

#define BCM56504_A0_XTHOLr_SIZE 4

/*
 * This structure should be used to declare and program XTHOL.
 *
 */
typedef union BCM56504_A0_XTHOLr_s {
	uint32_t v[1];
	uint32_t xthol[1];
	uint32_t _xthol;
} BCM56504_A0_XTHOLr_t;

#define BCM56504_A0_XTHOLr_CLR(r) (r).xthol[0] = 0
#define BCM56504_A0_XTHOLr_SET(r,d) (r).xthol[0] = d
#define BCM56504_A0_XTHOLr_GET(r) (r).xthol[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_XTHOLr_COUNTf_GET(r) ((r).xthol[0])
#define BCM56504_A0_XTHOLr_COUNTf_SET(r,f) (r).xthol[0]=((uint32_t)f)

/*
 * These macros can be used to access XTHOL.
 *
 */
#define BCM56504_A0_READ_XTHOLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_XTHOLr,(r._xthol))
#define BCM56504_A0_WRITE_XTHOLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_XTHOLr,&(r._xthol))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XTHOLr BCM56504_A0_XTHOLr
#define XTHOLr_SIZE BCM56504_A0_XTHOLr_SIZE
typedef BCM56504_A0_XTHOLr_t XTHOLr_t;
#define XTHOLr_CLR BCM56504_A0_XTHOLr_CLR
#define XTHOLr_SET BCM56504_A0_XTHOLr_SET
#define XTHOLr_GET BCM56504_A0_XTHOLr_GET
#define XTHOLr_COUNTf_GET BCM56504_A0_XTHOLr_COUNTf_GET
#define XTHOLr_COUNTf_SET BCM56504_A0_XTHOLr_COUNTf_SET
#define READ_XTHOLr BCM56504_A0_READ_XTHOLr
#define WRITE_XTHOLr BCM56504_A0_WRITE_XTHOLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_XTHOLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  XTIBP
 * BLOCKS:   XPORT0
 * DESC:     Transmit End-to-End IBP packet counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            Incremented for each E2E IBP packet transmitted.
 *
 ******************************************************************************/
#define BCM56504_A0_XTIBPr 0x00f00102

#define BCM56504_A0_XTIBPr_SIZE 4

/*
 * This structure should be used to declare and program XTIBP.
 *
 */
typedef union BCM56504_A0_XTIBPr_s {
	uint32_t v[1];
	uint32_t xtibp[1];
	uint32_t _xtibp;
} BCM56504_A0_XTIBPr_t;

#define BCM56504_A0_XTIBPr_CLR(r) (r).xtibp[0] = 0
#define BCM56504_A0_XTIBPr_SET(r,d) (r).xtibp[0] = d
#define BCM56504_A0_XTIBPr_GET(r) (r).xtibp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_XTIBPr_COUNTf_GET(r) ((r).xtibp[0])
#define BCM56504_A0_XTIBPr_COUNTf_SET(r,f) (r).xtibp[0]=((uint32_t)f)

/*
 * These macros can be used to access XTIBP.
 *
 */
#define BCM56504_A0_READ_XTIBPr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_XTIBPr,(r._xtibp))
#define BCM56504_A0_WRITE_XTIBPr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_XTIBPr,&(r._xtibp))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XTIBPr BCM56504_A0_XTIBPr
#define XTIBPr_SIZE BCM56504_A0_XTIBPr_SIZE
typedef BCM56504_A0_XTIBPr_t XTIBPr_t;
#define XTIBPr_CLR BCM56504_A0_XTIBPr_CLR
#define XTIBPr_SET BCM56504_A0_XTIBPr_SET
#define XTIBPr_GET BCM56504_A0_XTIBPr_GET
#define XTIBPr_COUNTf_GET BCM56504_A0_XTIBPr_COUNTf_GET
#define XTIBPr_COUNTf_SET BCM56504_A0_XTIBPr_COUNTf_SET
#define READ_XTIBPr BCM56504_A0_READ_XTIBPr
#define WRITE_XTIBPr BCM56504_A0_WRITE_XTIBPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_XTIBPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56504_A0
 * REGISTER:  XTPSE
 * BLOCKS:   XPORT0
 * DESC:     Transmit PAUSE Control Frame Counter under XPORT pausing mode
 * SIZE:     32
 * FIELDS:
 *     COUNT            Incremented for each PAUSE packet transmitted when XPORT pausing is enabled.
 *
 ******************************************************************************/
#define BCM56504_A0_XTPSEr 0x00f00100

#define BCM56504_A0_XTPSEr_SIZE 4

/*
 * This structure should be used to declare and program XTPSE.
 *
 */
typedef union BCM56504_A0_XTPSEr_s {
	uint32_t v[1];
	uint32_t xtpse[1];
	uint32_t _xtpse;
} BCM56504_A0_XTPSEr_t;

#define BCM56504_A0_XTPSEr_CLR(r) (r).xtpse[0] = 0
#define BCM56504_A0_XTPSEr_SET(r,d) (r).xtpse[0] = d
#define BCM56504_A0_XTPSEr_GET(r) (r).xtpse[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56504_A0_XTPSEr_COUNTf_GET(r) ((r).xtpse[0])
#define BCM56504_A0_XTPSEr_COUNTf_SET(r,f) (r).xtpse[0]=((uint32_t)f)

/*
 * These macros can be used to access XTPSE.
 *
 */
#define BCM56504_A0_READ_XTPSEr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56504_A0_XTPSEr,(r._xtpse))
#define BCM56504_A0_WRITE_XTPSEr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56504_A0_XTPSEr,&(r._xtpse))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XTPSEr BCM56504_A0_XTPSEr
#define XTPSEr_SIZE BCM56504_A0_XTPSEr_SIZE
typedef BCM56504_A0_XTPSEr_t XTPSEr_t;
#define XTPSEr_CLR BCM56504_A0_XTPSEr_CLR
#define XTPSEr_SET BCM56504_A0_XTPSEr_SET
#define XTPSEr_GET BCM56504_A0_XTPSEr_GET
#define XTPSEr_COUNTf_GET BCM56504_A0_XTPSEr_COUNTf_GET
#define XTPSEr_COUNTf_SET BCM56504_A0_XTPSEr_COUNTf_SET
#define READ_XTPSEr BCM56504_A0_READ_XTPSEr
#define WRITE_XTPSEr BCM56504_A0_WRITE_XTPSEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56504_A0_XTPSEr'
 ******************************************************************************/




#endif /* CDK_CONFIG_CHIP_DEFS_USE_DSYMS */
#endif /* __BCM56504_A0_DEFS_H__ */
