#ifndef __CDK_XGS_CMIC_H__
#define __CDK_XGS_CMIC_H__
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated from the registers file.
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Copyright 2013 Broadcom Corporation.
 * This program is the proprietary software of Broadcom Corporation
 * and/or its licensors, and may only be used, duplicated, modified
 * or distributed pursuant to the terms and conditions of a separate,
 * written license agreement executed between you and Broadcom
 * (an "Authorized License").  Except as set forth in an Authorized
 * License, Broadcom grants no license (express or implied), right
 * to use, or waiver of any kind with respect to the Software, and
 * Broadcom expressly reserves all rights in and to the Software
 * and all intellectual property rights therein.  IF YOU HAVE
 * NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
 * IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
 * ALL USE OF THE SOFTWARE.  
 *  
 * Except as expressly set forth in the Authorized License,
 *  
 * 1.     This program, including its structure, sequence and organization,
 * constitutes the valuable trade secrets of Broadcom, and you shall use
 * all reasonable efforts to protect the confidentiality thereof,
 * and to use this information only in connection with your use of
 * Broadcom integrated circuit products.
 *  
 * 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
 * PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
 * REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
 * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
 * DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
 * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
 * ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
 * CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
 * OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
 * 
 * 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
 * BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
 * INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
 * ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
 * TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
 * THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR USD 1.00,
 * WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
 * ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
 *
 * Definition file for the ALL.
 * This file provides all basic definitions required to program the ALL.
 *
 ******************************************************************************/

#include <cdk/cdk_string.h>
#include <cdk/cdk_field.h>
#include <cdk/arch/xgs_reg.h>
#include <cdk/arch/xgs_mem.h>

/*******************************************************************************
 *
 *                    CHIP DEFINITIONS BEGIN HERE
 *
 ******************************************************************************/



/*******************************************************************************
 * REGISTER:  CMIC_CONFIG
 * BLOCKS:   CMIC
 * DESC:     Configuration Register
 * SIZE:     32
 * FIELDS:
 *     RD_BRST_EN       When set (1), CMIC supports PIO Read Bursts
 *     WR_BRST_EN       When set (1), CMIC supports PIO Write Bursts
 *     BE_CHECK_EN      When set (1), CMIC Does BE Check (32-bit) on PCI writes
 *     MSTR_Q_MAX_EN    When set (1), CMIC can queue up to 4 PCI master requests
 *     RESERVED_1       Reserved
 *     RESET_CPS        When set CMIC drives CPS-Channel reset
 *     ACT_LOW_INT      When set CMIC drives INTR pin as Active LOW (0) - Default is Active low
 *     SCHAN_ABORT      When set CMIC aborts any pending SCH operation
 *     UNTAG_ALL_RCV_EN When set CMIC removes the TAG field from all received Packets
 *     UNTAG_EN         When set CMIC can remove the TAG field
 *     LE_DMA_EN        When set CMIC the DMA data transfer will be done in Little Endian format
 *     I2C_EN           When set CMIC PCI access to I2C interface is Enabled
 *     RESERVED_2       Reserved
 *     IGNORE_ADR_ALIGN_EN When set, allow DMA (PCI->SOC) to be aligned to any address boundary.
 *     RESERVED_3       Reserved
 *     DMA_GARBAGE_COLLECT_EN When set CMIC collects packets with Purge bit set
 *     RESET_PCI_EN     If set, CPS reset will also  reset the internal CMIC PCI interface.
 *     TIME_STAMP_UPD_DIS Disable packet time stamp update operation.  DEBUG ONLY.
 *     SG_ENABLE        Enable scatter/gather operation.
 *     SG_RELOAD_ENABLE Enable scatter/gather reload operation.
 *     RLD_STS_UPD_DIS  When set, do not update status fields on reload operation.
 *     STOP_LS_ON_CHANGE When set, on link change detection, stop link scanning
 *     ABORT_STAT_DMA   Abort the current stat DMA operation.  Not for normal operation.
 *     RESERVED_4       Reserved
 *     COS_RX_EN        When set, packet DMA is based on received COS.  Multiple write channels can be active. 
 *     RESERVED_5       Reserved
 *     OVER_RIDE_EXT_MDIO_MSTR_CNTRL When set, external MDIO master access is disabled,and CMIC becomes the MDIO master, allowing hardware link scan. MUST BE 1 FOR NORMAL OPERATION. Set to 0x0 by default to allow ATE tests to access XAUI/SERDES cores.
 *     MIIM_ADDR_MAP_ENABLE When set, use the MDIO Address Map Table to get the Phy IDfrom the port number for both Wr/Rd and link scan.Else, use the Phy ID as-is.
 *     RESERVED_6       Reserved
 *
 ******************************************************************************/
#define CMIC_CONFIGr 0x0000010c

#define CMIC_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CONFIG.
 *
 */
typedef union CMIC_CONFIGr_s {
	uint32_t v[1];
	uint32_t cmic_config[1];
	uint32_t _cmic_config;
} CMIC_CONFIGr_t;

#define CMIC_CONFIGr_CLR(r) (r).cmic_config[0] = 0
#define CMIC_CONFIGr_SET(r,d) (r).cmic_config[0] = d
#define CMIC_CONFIGr_GET(r) (r).cmic_config[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define CMIC_CONFIGr_RD_BRST_ENf_GET(r) (((r).cmic_config[0]) & 0x1)
#define CMIC_CONFIGr_RD_BRST_ENf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CMIC_CONFIGr_WR_BRST_ENf_GET(r) ((((r).cmic_config[0]) >> 1) & 0x1)
#define CMIC_CONFIGr_WR_BRST_ENf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CMIC_CONFIGr_BE_CHECK_ENf_GET(r) ((((r).cmic_config[0]) >> 2) & 0x1)
#define CMIC_CONFIGr_BE_CHECK_ENf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define CMIC_CONFIGr_MSTR_Q_MAX_ENf_GET(r) ((((r).cmic_config[0]) >> 3) & 0x1)
#define CMIC_CONFIGr_MSTR_Q_MAX_ENf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define CMIC_CONFIGr_RESERVED_1f_GET(r) ((((r).cmic_config[0]) >> 4) & 0x1)
#define CMIC_CONFIGr_RESERVED_1f_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define CMIC_CONFIGr_RESET_CPSf_GET(r) ((((r).cmic_config[0]) >> 5) & 0x1)
#define CMIC_CONFIGr_RESET_CPSf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define CMIC_CONFIGr_ACT_LOW_INTf_GET(r) ((((r).cmic_config[0]) >> 6) & 0x1)
#define CMIC_CONFIGr_ACT_LOW_INTf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define CMIC_CONFIGr_SCHAN_ABORTf_GET(r) ((((r).cmic_config[0]) >> 7) & 0x1)
#define CMIC_CONFIGr_SCHAN_ABORTf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define CMIC_CONFIGr_UNTAG_ALL_RCV_ENf_GET(r) ((((r).cmic_config[0]) >> 8) & 0x1)
#define CMIC_CONFIGr_UNTAG_ALL_RCV_ENf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define CMIC_CONFIGr_UNTAG_ENf_GET(r) ((((r).cmic_config[0]) >> 9) & 0x1)
#define CMIC_CONFIGr_UNTAG_ENf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define CMIC_CONFIGr_LE_DMA_ENf_GET(r) ((((r).cmic_config[0]) >> 10) & 0x1)
#define CMIC_CONFIGr_LE_DMA_ENf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define CMIC_CONFIGr_I2C_ENf_GET(r) ((((r).cmic_config[0]) >> 11) & 0x1)
#define CMIC_CONFIGr_I2C_ENf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define CMIC_CONFIGr_RESERVED_2f_GET(r) ((((r).cmic_config[0]) >> 12) & 0x1)
#define CMIC_CONFIGr_RESERVED_2f_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define CMIC_CONFIGr_IGNORE_ADR_ALIGN_ENf_GET(r) ((((r).cmic_config[0]) >> 13) & 0x1)
#define CMIC_CONFIGr_IGNORE_ADR_ALIGN_ENf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define CMIC_CONFIGr_RESERVED_3f_GET(r) ((((r).cmic_config[0]) >> 14) & 0x1)
#define CMIC_CONFIGr_RESERVED_3f_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define CMIC_CONFIGr_DMA_GARBAGE_COLLECT_ENf_GET(r) ((((r).cmic_config[0]) >> 15) & 0x1)
#define CMIC_CONFIGr_DMA_GARBAGE_COLLECT_ENf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define CMIC_CONFIGr_RESET_PCI_ENf_GET(r) ((((r).cmic_config[0]) >> 16) & 0x1)
#define CMIC_CONFIGr_RESET_PCI_ENf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define CMIC_CONFIGr_TIME_STAMP_UPD_DISf_GET(r) ((((r).cmic_config[0]) >> 17) & 0x1)
#define CMIC_CONFIGr_TIME_STAMP_UPD_DISf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define CMIC_CONFIGr_SG_ENABLEf_GET(r) ((((r).cmic_config[0]) >> 18) & 0x1)
#define CMIC_CONFIGr_SG_ENABLEf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define CMIC_CONFIGr_SG_RELOAD_ENABLEf_GET(r) ((((r).cmic_config[0]) >> 19) & 0x1)
#define CMIC_CONFIGr_SG_RELOAD_ENABLEf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define CMIC_CONFIGr_RLD_STS_UPD_DISf_GET(r) ((((r).cmic_config[0]) >> 20) & 0x1)
#define CMIC_CONFIGr_RLD_STS_UPD_DISf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define CMIC_CONFIGr_STOP_LS_ON_CHANGEf_GET(r) ((((r).cmic_config[0]) >> 21) & 0x1)
#define CMIC_CONFIGr_STOP_LS_ON_CHANGEf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define CMIC_CONFIGr_ABORT_STAT_DMAf_GET(r) ((((r).cmic_config[0]) >> 22) & 0x1)
#define CMIC_CONFIGr_ABORT_STAT_DMAf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define CMIC_CONFIGr_RESERVED_4f_GET(r) ((((r).cmic_config[0]) >> 23) & 0x1)
#define CMIC_CONFIGr_RESERVED_4f_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define CMIC_CONFIGr_COS_RX_ENf_GET(r) ((((r).cmic_config[0]) >> 24) & 0x1)
#define CMIC_CONFIGr_COS_RX_ENf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define CMIC_CONFIGr_RESERVED_5f_GET(r) ((((r).cmic_config[0]) >> 25) & 0x1)
#define CMIC_CONFIGr_RESERVED_5f_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define CMIC_CONFIGr_OVER_RIDE_EXT_MDIO_MSTR_CNTRLf_GET(r) ((((r).cmic_config[0]) >> 26) & 0x1)
#define CMIC_CONFIGr_OVER_RIDE_EXT_MDIO_MSTR_CNTRLf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define CMIC_CONFIGr_MIIM_ADDR_MAP_ENABLEf_GET(r) ((((r).cmic_config[0]) >> 27) & 0x1)
#define CMIC_CONFIGr_MIIM_ADDR_MAP_ENABLEf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define CMIC_CONFIGr_RESERVED_6f_GET(r) ((((r).cmic_config[0]) >> 28) & 0xf)
#define CMIC_CONFIGr_RESERVED_6f_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access CMIC_CONFIG.
 *
 */
#define READ_CMIC_CONFIGr(u,r) CDK_DEV_READ32(u,CMIC_CONFIGr,r._cmic_config)
#define WRITE_CMIC_CONFIGr(u,r) CDK_DEV_WRITE32(u,CMIC_CONFIGr,r._cmic_config)

/*******************************************************************************
 * End of 'CMIC_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * REGISTER:  CMIC_DMA_CTRL
 * BLOCKS:   CMIC
 * DESC:     DMA Control Register
 * SIZE:     32
 * FIELDS:
 *     CH0_DIRECTION    DMA channel 0 direction:1=Mem->SOC, 0=SOC->Mem
 *     RESERVED_1_CH0   Reserved
 *     CH0_ABORT_DMA    DMA channel 0 abort
 *     CH0_SEL_INTR_ON_DESC_OR_PKT DMA channel 0 interrupt select:1=after descriptor, 0=after packet
 *     RESERVED_2_CH0   Reserved
 *     RESERVED_3_CH0   Reserved
 *     CH0_DROP_RX_PKT_ON_CHAIN_END DMA channel 0 setting for handling packet received after hittingend of chain (and hence no descriptors are available)1=drop the packet, 0=block, waiting for descriptor to be available
 *     CH1_DIRECTION    DMA channel 1 direction:1=Mem->SOC, 0=SOC->Mem
 *     RESERVED_1_CH1   Reserved
 *     CH1_ABORT_DMA    DMA channel 1 abort
 *     CH1_SEL_INTR_ON_DESC_OR_PKT DMA channel 1 interrupt select:1=after descriptor, 0=after packet
 *     RESERVED_2_CH1   Reserved
 *     RESERVED_3_CH1   Reserved
 *     CH1_DROP_RX_PKT_ON_CHAIN_END DMA channel 1 setting for handling packet received after hittingend of chain (and hence no descriptors are available)1=drop the packet, 0=block, waiting for descriptor to be available
 *     CH2_DIRECTION    DMA channel 2 direction:1=Mem->SOC, 0=SOC->Mem
 *     RESERVED_1_CH2   Reserved
 *     CH2_ABORT_DMA    DMA channel 2 abort
 *     CH2_SEL_INTR_ON_DESC_OR_PKT DMA channel 2 interrupt select:1=after descriptor, 0=after packet
 *     RESERVED_2_CH2   Reserved
 *     RESERVED_3_CH2   Reserved
 *     CH2_DROP_RX_PKT_ON_CHAIN_END DMA channel 2 setting for handling packet received after hittingend of chain (and hence no descriptors are available)1=drop the packet, 0=block, waiting for descriptor to be available
 *     CH3_DIRECTION    DMA channel 3 direction:1=Mem->SOC, 0=SOC->Mem
 *     RESERVED_1_CH3   Reserved
 *     CH3_ABORT_DMA    DMA channel 3 abort
 *     CH3_SEL_INTR_ON_DESC_OR_PKT DMA channel 3 interrupt select:1=after descriptor, 0=after packet
 *     RESERVED_2_CH3   Reserved
 *     RESERVED_3_CH3   Reserved
 *     CH3_DROP_RX_PKT_ON_CHAIN_END DMA channel 3 setting for handling packet received after hittingend of chain (and hence no descriptors are available)1=drop the packet, 0=block, waiting for descriptor to be available
 *
 ******************************************************************************/
#define CMIC_DMA_CTRLr 0x00000100

#define CMIC_DMA_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_DMA_CTRL.
 *
 */
typedef union CMIC_DMA_CTRLr_s {
	uint32_t v[1];
	uint32_t cmic_dma_ctrl[1];
	uint32_t _cmic_dma_ctrl;
} CMIC_DMA_CTRLr_t;

#define CMIC_DMA_CTRLr_CLR(r) (r).cmic_dma_ctrl[0] = 0
#define CMIC_DMA_CTRLr_SET(r,d) (r).cmic_dma_ctrl[0] = d
#define CMIC_DMA_CTRLr_GET(r) (r).cmic_dma_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define CMIC_DMA_CTRLr_CH0_DIRECTIONf_GET(r) (((r).cmic_dma_ctrl[0]) & 0x1)
#define CMIC_DMA_CTRLr_CH0_DIRECTIONf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CMIC_DMA_CTRLr_RESERVED_1_CH0f_GET(r) ((((r).cmic_dma_ctrl[0]) >> 1) & 0x1)
#define CMIC_DMA_CTRLr_RESERVED_1_CH0f_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CMIC_DMA_CTRLr_CH0_ABORT_DMAf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 2) & 0x1)
#define CMIC_DMA_CTRLr_CH0_ABORT_DMAf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define CMIC_DMA_CTRLr_CH0_SEL_INTR_ON_DESC_OR_PKTf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 3) & 0x1)
#define CMIC_DMA_CTRLr_CH0_SEL_INTR_ON_DESC_OR_PKTf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define CMIC_DMA_CTRLr_RESERVED_2_CH0f_GET(r) ((((r).cmic_dma_ctrl[0]) >> 4) & 0x1)
#define CMIC_DMA_CTRLr_RESERVED_2_CH0f_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define CMIC_DMA_CTRLr_RESERVED_3_CH0f_GET(r) ((((r).cmic_dma_ctrl[0]) >> 5) & 0x3)
#define CMIC_DMA_CTRLr_RESERVED_3_CH0f_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5))
#define CMIC_DMA_CTRLr_CH0_DROP_RX_PKT_ON_CHAIN_ENDf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 7) & 0x1)
#define CMIC_DMA_CTRLr_CH0_DROP_RX_PKT_ON_CHAIN_ENDf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define CMIC_DMA_CTRLr_CH1_DIRECTIONf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 8) & 0x1)
#define CMIC_DMA_CTRLr_CH1_DIRECTIONf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define CMIC_DMA_CTRLr_RESERVED_1_CH1f_GET(r) ((((r).cmic_dma_ctrl[0]) >> 9) & 0x1)
#define CMIC_DMA_CTRLr_RESERVED_1_CH1f_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define CMIC_DMA_CTRLr_CH1_ABORT_DMAf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 10) & 0x1)
#define CMIC_DMA_CTRLr_CH1_ABORT_DMAf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define CMIC_DMA_CTRLr_CH1_SEL_INTR_ON_DESC_OR_PKTf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 11) & 0x1)
#define CMIC_DMA_CTRLr_CH1_SEL_INTR_ON_DESC_OR_PKTf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define CMIC_DMA_CTRLr_RESERVED_2_CH1f_GET(r) ((((r).cmic_dma_ctrl[0]) >> 12) & 0x1)
#define CMIC_DMA_CTRLr_RESERVED_2_CH1f_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define CMIC_DMA_CTRLr_RESERVED_3_CH1f_GET(r) ((((r).cmic_dma_ctrl[0]) >> 13) & 0x3)
#define CMIC_DMA_CTRLr_RESERVED_3_CH1f_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13))
#define CMIC_DMA_CTRLr_CH1_DROP_RX_PKT_ON_CHAIN_ENDf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 15) & 0x1)
#define CMIC_DMA_CTRLr_CH1_DROP_RX_PKT_ON_CHAIN_ENDf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define CMIC_DMA_CTRLr_CH2_DIRECTIONf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 16) & 0x1)
#define CMIC_DMA_CTRLr_CH2_DIRECTIONf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define CMIC_DMA_CTRLr_RESERVED_1_CH2f_GET(r) ((((r).cmic_dma_ctrl[0]) >> 17) & 0x1)
#define CMIC_DMA_CTRLr_RESERVED_1_CH2f_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define CMIC_DMA_CTRLr_CH2_ABORT_DMAf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 18) & 0x1)
#define CMIC_DMA_CTRLr_CH2_ABORT_DMAf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define CMIC_DMA_CTRLr_CH2_SEL_INTR_ON_DESC_OR_PKTf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 19) & 0x1)
#define CMIC_DMA_CTRLr_CH2_SEL_INTR_ON_DESC_OR_PKTf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define CMIC_DMA_CTRLr_RESERVED_2_CH2f_GET(r) ((((r).cmic_dma_ctrl[0]) >> 20) & 0x1)
#define CMIC_DMA_CTRLr_RESERVED_2_CH2f_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define CMIC_DMA_CTRLr_RESERVED_3_CH2f_GET(r) ((((r).cmic_dma_ctrl[0]) >> 21) & 0x3)
#define CMIC_DMA_CTRLr_RESERVED_3_CH2f_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x3 << 21)) | ((((uint32_t)f) & 0x3) << 21))
#define CMIC_DMA_CTRLr_CH2_DROP_RX_PKT_ON_CHAIN_ENDf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 23) & 0x1)
#define CMIC_DMA_CTRLr_CH2_DROP_RX_PKT_ON_CHAIN_ENDf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define CMIC_DMA_CTRLr_CH3_DIRECTIONf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 24) & 0x1)
#define CMIC_DMA_CTRLr_CH3_DIRECTIONf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define CMIC_DMA_CTRLr_RESERVED_1_CH3f_GET(r) ((((r).cmic_dma_ctrl[0]) >> 25) & 0x1)
#define CMIC_DMA_CTRLr_RESERVED_1_CH3f_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define CMIC_DMA_CTRLr_CH3_ABORT_DMAf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 26) & 0x1)
#define CMIC_DMA_CTRLr_CH3_ABORT_DMAf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define CMIC_DMA_CTRLr_CH3_SEL_INTR_ON_DESC_OR_PKTf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 27) & 0x1)
#define CMIC_DMA_CTRLr_CH3_SEL_INTR_ON_DESC_OR_PKTf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define CMIC_DMA_CTRLr_RESERVED_2_CH3f_GET(r) ((((r).cmic_dma_ctrl[0]) >> 28) & 0x1)
#define CMIC_DMA_CTRLr_RESERVED_2_CH3f_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define CMIC_DMA_CTRLr_RESERVED_3_CH3f_GET(r) ((((r).cmic_dma_ctrl[0]) >> 29) & 0x3)
#define CMIC_DMA_CTRLr_RESERVED_3_CH3f_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x3 << 29)) | ((((uint32_t)f) & 0x3) << 29))
#define CMIC_DMA_CTRLr_CH3_DROP_RX_PKT_ON_CHAIN_ENDf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 31) & 0x1)
#define CMIC_DMA_CTRLr_CH3_DROP_RX_PKT_ON_CHAIN_ENDf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access CMIC_DMA_CTRL.
 *
 */
#define READ_CMIC_DMA_CTRLr(u,r) CDK_DEV_READ32(u,CMIC_DMA_CTRLr,r._cmic_dma_ctrl)
#define WRITE_CMIC_DMA_CTRLr(u,r) CDK_DEV_WRITE32(u,CMIC_DMA_CTRLr,r._cmic_dma_ctrl)

/*******************************************************************************
 * End of 'CMIC_DMA_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * REGISTER:  CMIC_DMA_DESC0
 * BLOCKS:   CMIC
 * DESC:     DMA Channel 0 Descriptor Address
 * SIZE:     32
 * FIELDS:
 *     ADDR             DMA CH0 DESCRIPTOR ADDRESS REGISTER
 *
 ******************************************************************************/
#define CMIC_DMA_DESC0r 0x00000110

#define CMIC_DMA_DESC0r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_DMA_DESC0.
 *
 */
typedef union CMIC_DMA_DESC0r_s {
	uint32_t v[1];
	uint32_t cmic_dma_desc0[1];
	uint32_t _cmic_dma_desc0;
} CMIC_DMA_DESC0r_t;

#define CMIC_DMA_DESC0r_CLR(r) (r).cmic_dma_desc0[0] = 0
#define CMIC_DMA_DESC0r_SET(r,d) (r).cmic_dma_desc0[0] = d
#define CMIC_DMA_DESC0r_GET(r) (r).cmic_dma_desc0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define CMIC_DMA_DESC0r_ADDRf_GET(r) ((r).cmic_dma_desc0[0])
#define CMIC_DMA_DESC0r_ADDRf_SET(r,f) (r).cmic_dma_desc0[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_DMA_DESC0.
 *
 */
#define READ_CMIC_DMA_DESC0r(u,r) CDK_DEV_READ32(u,CMIC_DMA_DESC0r,r._cmic_dma_desc0)
#define WRITE_CMIC_DMA_DESC0r(u,r) CDK_DEV_WRITE32(u,CMIC_DMA_DESC0r,r._cmic_dma_desc0)

/*******************************************************************************
 * End of 'CMIC_DMA_DESC0r'
 ******************************************************************************/




/*******************************************************************************
 * REGISTER:  CMIC_DMA_STAT
 * BLOCKS:   CMIC
 * DESC:     DMA Status and Control Register
 * SIZE:     32
 * FIELDS:
 *     CH0_DMA_EN       Set by CPU to start a DMA on CH0 
 *     CH1_DMA_EN       Set by CPU to start a DMA on CH1 
 *     CH2_DMA_EN       Set by CPU to start a DMA on CH2 
 *     CH3_DMA_EN       Set by CPU to start a DMA on CH3 
 *     CH0_CHAIN_DONE   Set by CMIC indicating DMA Completion 
 *     CH1_CHAIN_DONE   Set by CMIC indicating DMA Completion 
 *     CH2_CHAIN_DONE   Set by CMIC indicating DMA Completion 
 *     CH3_CHAIN_DONE   Set by CMIC indicating DMA Completion 
 *     CH0_DESC_DONE    Set by CMIC indicating Current DMA DES Completion 
 *     CH1_DESC_DONE    Set by CMIC indicating Current DMA DES Completion 
 *     CH2_DESC_DONE    Set by CMIC indicating Current DMA DES Completion 
 *     CH3_DESC_DONE    Set by CMIC indicating Current DMA DES Completion 
 *     DMA_RESET        Set by CPU to reset DMA Controller
 *     STATS_DMA_OPN_COMPLETE Set by CPU to indicate Stats DMA operation complete
 *     STATS_DMA_ITER_DONE Set by CPU to indicate Stats DMA iteration done
 *     TX_DMA_ABORT_NEEDS_CLEANUP Set by CPU to indicate that the previous TX DMA was aborted inthe middle of a packet (i.e., not at packet boundary). The CPU needs to clean up by forcing an eop packet with purge bit set.
 *     STATS_DMA_ERROR  Set by CPU to indicate Stats DMA resulted in an error
 *     STATS_DMA_ACTIVE Set by CPU to indicate Stats DMA currently active
 *     CH0_DMA_ACTIVE   Set by CMIC to indicate DMA channel is Active
 *     CH1_DMA_ACTIVE   Set by CMIC to indicate DMA channel is Active
 *     CH2_DMA_ACTIVE   Set by CMIC to indicate DMA channel is Active
 *     CH3_DMA_ACTIVE   Set by CMIC to indicate DMA channel is Active
 *     PCI_PARITY_ERR   Set by CMIC to indicate DMA Resulting in PCI Parity Error
 *     PCI_FATAL_ERR    Set by CMIC to indicate DMA Resulting in PCI Fatal Error
 *     BIT_POS          Selects one of 32 bits positions to be Set/Reset
 *     BIT_VAL          Set to 1 to set a bit, 0 to reset a bit
 *
 ******************************************************************************/
#define CMIC_DMA_STATr 0x00000104

#define CMIC_DMA_STATr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_DMA_STAT.
 *
 */
typedef union CMIC_DMA_STATr_s {
	uint32_t v[1];
	uint32_t cmic_dma_stat[1];
	uint32_t _cmic_dma_stat;
} CMIC_DMA_STATr_t;

#define CMIC_DMA_STATr_CLR(r) (r).cmic_dma_stat[0] = 0
#define CMIC_DMA_STATr_SET(r,d) (r).cmic_dma_stat[0] = d
#define CMIC_DMA_STATr_GET(r) (r).cmic_dma_stat[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define CMIC_DMA_STATr_CH0_DMA_ENf_GET(r) (((r).cmic_dma_stat[0]) & 0x1)
#define CMIC_DMA_STATr_CH0_DMA_ENf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CMIC_DMA_STATr_CH1_DMA_ENf_GET(r) ((((r).cmic_dma_stat[0]) >> 1) & 0x1)
#define CMIC_DMA_STATr_CH1_DMA_ENf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CMIC_DMA_STATr_CH2_DMA_ENf_GET(r) ((((r).cmic_dma_stat[0]) >> 2) & 0x1)
#define CMIC_DMA_STATr_CH2_DMA_ENf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define CMIC_DMA_STATr_CH3_DMA_ENf_GET(r) ((((r).cmic_dma_stat[0]) >> 3) & 0x1)
#define CMIC_DMA_STATr_CH3_DMA_ENf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define CMIC_DMA_STATr_CH0_CHAIN_DONEf_GET(r) ((((r).cmic_dma_stat[0]) >> 4) & 0x1)
#define CMIC_DMA_STATr_CH0_CHAIN_DONEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define CMIC_DMA_STATr_CH1_CHAIN_DONEf_GET(r) ((((r).cmic_dma_stat[0]) >> 5) & 0x1)
#define CMIC_DMA_STATr_CH1_CHAIN_DONEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define CMIC_DMA_STATr_CH2_CHAIN_DONEf_GET(r) ((((r).cmic_dma_stat[0]) >> 6) & 0x1)
#define CMIC_DMA_STATr_CH2_CHAIN_DONEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define CMIC_DMA_STATr_CH3_CHAIN_DONEf_GET(r) ((((r).cmic_dma_stat[0]) >> 7) & 0x1)
#define CMIC_DMA_STATr_CH3_CHAIN_DONEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define CMIC_DMA_STATr_CH0_DESC_DONEf_GET(r) ((((r).cmic_dma_stat[0]) >> 8) & 0x1)
#define CMIC_DMA_STATr_CH0_DESC_DONEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define CMIC_DMA_STATr_CH1_DESC_DONEf_GET(r) ((((r).cmic_dma_stat[0]) >> 9) & 0x1)
#define CMIC_DMA_STATr_CH1_DESC_DONEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define CMIC_DMA_STATr_CH2_DESC_DONEf_GET(r) ((((r).cmic_dma_stat[0]) >> 10) & 0x1)
#define CMIC_DMA_STATr_CH2_DESC_DONEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define CMIC_DMA_STATr_CH3_DESC_DONEf_GET(r) ((((r).cmic_dma_stat[0]) >> 11) & 0x1)
#define CMIC_DMA_STATr_CH3_DESC_DONEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define CMIC_DMA_STATr_DMA_RESETf_GET(r) ((((r).cmic_dma_stat[0]) >> 12) & 0x1)
#define CMIC_DMA_STATr_DMA_RESETf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define CMIC_DMA_STATr_STATS_DMA_OPN_COMPLETEf_GET(r) ((((r).cmic_dma_stat[0]) >> 13) & 0x1)
#define CMIC_DMA_STATr_STATS_DMA_OPN_COMPLETEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define CMIC_DMA_STATr_STATS_DMA_ITER_DONEf_GET(r) ((((r).cmic_dma_stat[0]) >> 14) & 0x1)
#define CMIC_DMA_STATr_STATS_DMA_ITER_DONEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define CMIC_DMA_STATr_TX_DMA_ABORT_NEEDS_CLEANUPf_GET(r) ((((r).cmic_dma_stat[0]) >> 15) & 0x1)
#define CMIC_DMA_STATr_TX_DMA_ABORT_NEEDS_CLEANUPf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define CMIC_DMA_STATr_STATS_DMA_ERRORf_GET(r) ((((r).cmic_dma_stat[0]) >> 16) & 0x1)
#define CMIC_DMA_STATr_STATS_DMA_ERRORf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define CMIC_DMA_STATr_STATS_DMA_ACTIVEf_GET(r) ((((r).cmic_dma_stat[0]) >> 17) & 0x1)
#define CMIC_DMA_STATr_STATS_DMA_ACTIVEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define CMIC_DMA_STATr_CH0_DMA_ACTIVEf_GET(r) ((((r).cmic_dma_stat[0]) >> 18) & 0x1)
#define CMIC_DMA_STATr_CH0_DMA_ACTIVEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define CMIC_DMA_STATr_CH1_DMA_ACTIVEf_GET(r) ((((r).cmic_dma_stat[0]) >> 19) & 0x1)
#define CMIC_DMA_STATr_CH1_DMA_ACTIVEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define CMIC_DMA_STATr_CH2_DMA_ACTIVEf_GET(r) ((((r).cmic_dma_stat[0]) >> 20) & 0x1)
#define CMIC_DMA_STATr_CH2_DMA_ACTIVEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define CMIC_DMA_STATr_CH3_DMA_ACTIVEf_GET(r) ((((r).cmic_dma_stat[0]) >> 21) & 0x1)
#define CMIC_DMA_STATr_CH3_DMA_ACTIVEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define CMIC_DMA_STATr_PCI_PARITY_ERRf_GET(r) ((((r).cmic_dma_stat[0]) >> 22) & 0x1f)
#define CMIC_DMA_STATr_PCI_PARITY_ERRf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1f << 22)) | ((((uint32_t)f) & 0x1f) << 22))
#define CMIC_DMA_STATr_PCI_FATAL_ERRf_GET(r) ((((r).cmic_dma_stat[0]) >> 27) & 0x1f)
#define CMIC_DMA_STATr_PCI_FATAL_ERRf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1f << 27)) | ((((uint32_t)f) & 0x1f) << 27))
#define CMIC_DMA_STATr_BIT_POSf_GET(r) (((r).cmic_dma_stat[0]) & 0x1f)
#define CMIC_DMA_STATr_BIT_POSf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define CMIC_DMA_STATr_BIT_VALf_GET(r) ((((r).cmic_dma_stat[0]) >> 7) & 0x1)
#define CMIC_DMA_STATr_BIT_VALf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access CMIC_DMA_STAT.
 *
 */
#define READ_CMIC_DMA_STATr(u,r) CDK_DEV_READ32(u,CMIC_DMA_STATr,r._cmic_dma_stat)
#define WRITE_CMIC_DMA_STATr(u,r) CDK_DEV_WRITE32(u,CMIC_DMA_STATr,r._cmic_dma_stat)

/*******************************************************************************
 * End of 'CMIC_DMA_STATr'
 ******************************************************************************/




/*******************************************************************************
 * REGISTER:  CMIC_ENDIANESS_SEL
 * BLOCKS:   CMIC
 * DESC:     Endianness selection register (for various CMIC operations)

 * SIZE:     32
 * FIELDS:
 *     BYTELANE0        Each byte lane must carry the same data value,especially the MSB byte and the LSB byte.The various bits in the byte are interpretedas explained below:
 *     BYTELANE1        Byte Lane 1 (see BYTELANE0)Each byte lane must carry the same data value.
 *     BYTELANE2        Byte Lane 2 (see BYTELANE0)Each byte lane must carry the same data value.
 *     BYTELANE3        Byte Lane 3 (see BYTELANE0)Each byte lane must carry the same data value.
 *
 ******************************************************************************/
#define CMIC_ENDIANESS_SELr 0x00000174

#define CMIC_ENDIANESS_SELr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_ENDIANESS_SEL.
 *
 */
typedef union CMIC_ENDIANESS_SELr_s {
	uint32_t v[1];
	uint32_t cmic_endianess_sel[1];
	uint32_t _cmic_endianess_sel;
} CMIC_ENDIANESS_SELr_t;

#define CMIC_ENDIANESS_SELr_CLR(r) (r).cmic_endianess_sel[0] = 0
#define CMIC_ENDIANESS_SELr_SET(r,d) (r).cmic_endianess_sel[0] = d
#define CMIC_ENDIANESS_SELr_GET(r) (r).cmic_endianess_sel[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define CMIC_ENDIANESS_SELr_BYTELANE0f_GET(r) (((r).cmic_endianess_sel[0]) & 0xff)
#define CMIC_ENDIANESS_SELr_BYTELANE0f_SET(r,f) (r).cmic_endianess_sel[0]=(((r).cmic_endianess_sel[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define CMIC_ENDIANESS_SELr_BYTELANE1f_GET(r) ((((r).cmic_endianess_sel[0]) >> 8) & 0xff)
#define CMIC_ENDIANESS_SELr_BYTELANE1f_SET(r,f) (r).cmic_endianess_sel[0]=(((r).cmic_endianess_sel[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define CMIC_ENDIANESS_SELr_BYTELANE2f_GET(r) ((((r).cmic_endianess_sel[0]) >> 16) & 0xff)
#define CMIC_ENDIANESS_SELr_BYTELANE2f_SET(r,f) (r).cmic_endianess_sel[0]=(((r).cmic_endianess_sel[0] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define CMIC_ENDIANESS_SELr_BYTELANE3f_GET(r) ((((r).cmic_endianess_sel[0]) >> 24) & 0xff)
#define CMIC_ENDIANESS_SELr_BYTELANE3f_SET(r,f) (r).cmic_endianess_sel[0]=(((r).cmic_endianess_sel[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access CMIC_ENDIANESS_SEL.
 *
 */
#define READ_CMIC_ENDIANESS_SELr(u,r) CDK_DEV_READ32(u,CMIC_ENDIANESS_SELr,r._cmic_endianess_sel)
#define WRITE_CMIC_ENDIANESS_SELr(u,r) CDK_DEV_WRITE32(u,CMIC_ENDIANESS_SELr,r._cmic_endianess_sel)

/*******************************************************************************
 * End of 'CMIC_ENDIANESS_SELr'
 ******************************************************************************/




/*******************************************************************************
 * REGISTER:  CMIC_IRQ_MASK
 * BLOCKS:   CMIC
 * DESC:     Interrupt Mask Register
 * SIZE:     32
 * FIELDS:
 *     SCH_MSG_DONE     SCH Message Operation Complete Mask
 *     RESERVED_1       Reserved
 *     LINK_STAT_MOD    Link Status Change Mask
 *     L2_MOD_FIFO_NOT_EMPTY L2 MOD Fifo is full
 *     RESERVED_2       Reserved
 *     CH0_DESC_DONE    DMA CH0 Next Descriptor Execution Complete Mask
 *     CH0_CHAIN_DONE   DMA CH0 End Of Chain Mask
 *     CH1_DESC_DONE    DMA CH1 Next Descriptor Execution Complete Mask
 *     CH1_CHAIN_DONE   DMA CH1 ENd Of Chain Mask
 *     CH2_DESC_DONE    DMA CH2 Next Descriptor Execution Complete Mask
 *     CH2_CHAIN_DONE   DMA CH2 End Of Chain Mask
 *     CH3_DESC_DONE    DMA CH3 Next Descriptor Execution Complete Mask
 *     CH3_CHAIN_DONE   DMA CH3 End Of Chain Mask
 *     PCI_PARITY_ERR   PCI Bus Parity Error Mask
 *     PCI_FATAL_ERR    PCI Bus Fatal Error Mask
 *     SCHAN_ERR        SCH Bus Error Mask
 *     I2C_INTR         I2C Mask
 *     MIIM_OP_DONE     MIIM Operation Complete Mask
 *     STAT_DMA_DONE    Stats DMA Iteration Complete Mask
 *     RESERVED_3       Reserved
 *     BSE_CMDMEM_DONE  BSE CMDMEM DONE
 *     CSE_CMDMEM_DONE  CSE CMDMEM DONE
 *     HSE_CMDMEM_DONE  HSE CMDMEM DONE
 *     MEM_FAIL         MMU Memory Failed
 *     TABLE_DMA_COMPLETE Table DMA operation complete Mask
 *     SLAM_DMA_COMPLETE Slam DMA operation complete Mask
 *     BSAFE_OP_DONE    Broadsafe operation complete
 *
 ******************************************************************************/
#define CMIC_IRQ_MASKr 0x00000148

#define CMIC_IRQ_MASKr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_IRQ_MASK.
 *
 */
typedef union CMIC_IRQ_MASKr_s {
	uint32_t v[1];
	uint32_t cmic_irq_mask[1];
	uint32_t _cmic_irq_mask;
} CMIC_IRQ_MASKr_t;

#define CMIC_IRQ_MASKr_CLR(r) (r).cmic_irq_mask[0] = 0
#define CMIC_IRQ_MASKr_SET(r,d) (r).cmic_irq_mask[0] = d
#define CMIC_IRQ_MASKr_GET(r) (r).cmic_irq_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define CMIC_IRQ_MASKr_SCH_MSG_DONEf_GET(r) (((r).cmic_irq_mask[0]) & 0x1)
#define CMIC_IRQ_MASKr_SCH_MSG_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CMIC_IRQ_MASKr_RESERVED_1f_GET(r) ((((r).cmic_irq_mask[0]) >> 1) & 0x7)
#define CMIC_IRQ_MASKr_RESERVED_1f_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define CMIC_IRQ_MASKr_LINK_STAT_MODf_GET(r) ((((r).cmic_irq_mask[0]) >> 4) & 0x1)
#define CMIC_IRQ_MASKr_LINK_STAT_MODf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define CMIC_IRQ_MASKr_L2_MOD_FIFO_NOT_EMPTYf_GET(r) ((((r).cmic_irq_mask[0]) >> 5) & 0x1)
#define CMIC_IRQ_MASKr_L2_MOD_FIFO_NOT_EMPTYf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define CMIC_IRQ_MASKr_RESERVED_2f_GET(r) ((((r).cmic_irq_mask[0]) >> 6) & 0x1)
#define CMIC_IRQ_MASKr_RESERVED_2f_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define CMIC_IRQ_MASKr_CH0_DESC_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 7) & 0x1)
#define CMIC_IRQ_MASKr_CH0_DESC_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define CMIC_IRQ_MASKr_CH0_CHAIN_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 8) & 0x1)
#define CMIC_IRQ_MASKr_CH0_CHAIN_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define CMIC_IRQ_MASKr_CH1_DESC_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 9) & 0x1)
#define CMIC_IRQ_MASKr_CH1_DESC_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define CMIC_IRQ_MASKr_CH1_CHAIN_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 10) & 0x1)
#define CMIC_IRQ_MASKr_CH1_CHAIN_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define CMIC_IRQ_MASKr_CH2_DESC_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 11) & 0x1)
#define CMIC_IRQ_MASKr_CH2_DESC_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define CMIC_IRQ_MASKr_CH2_CHAIN_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 12) & 0x1)
#define CMIC_IRQ_MASKr_CH2_CHAIN_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define CMIC_IRQ_MASKr_CH3_DESC_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 13) & 0x1)
#define CMIC_IRQ_MASKr_CH3_DESC_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define CMIC_IRQ_MASKr_CH3_CHAIN_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 14) & 0x1)
#define CMIC_IRQ_MASKr_CH3_CHAIN_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define CMIC_IRQ_MASKr_PCI_PARITY_ERRf_GET(r) ((((r).cmic_irq_mask[0]) >> 15) & 0x1)
#define CMIC_IRQ_MASKr_PCI_PARITY_ERRf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define CMIC_IRQ_MASKr_PCI_FATAL_ERRf_GET(r) ((((r).cmic_irq_mask[0]) >> 16) & 0x1)
#define CMIC_IRQ_MASKr_PCI_FATAL_ERRf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define CMIC_IRQ_MASKr_SCHAN_ERRf_GET(r) ((((r).cmic_irq_mask[0]) >> 17) & 0x1)
#define CMIC_IRQ_MASKr_SCHAN_ERRf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define CMIC_IRQ_MASKr_I2C_INTRf_GET(r) ((((r).cmic_irq_mask[0]) >> 18) & 0x1)
#define CMIC_IRQ_MASKr_I2C_INTRf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define CMIC_IRQ_MASKr_MIIM_OP_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 19) & 0x1)
#define CMIC_IRQ_MASKr_MIIM_OP_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define CMIC_IRQ_MASKr_STAT_DMA_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 20) & 0x1)
#define CMIC_IRQ_MASKr_STAT_DMA_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define CMIC_IRQ_MASKr_RESERVED_3f_GET(r) ((((r).cmic_irq_mask[0]) >> 21) & 0xf)
#define CMIC_IRQ_MASKr_RESERVED_3f_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0xf << 21)) | ((((uint32_t)f) & 0xf) << 21))
#define CMIC_IRQ_MASKr_BSE_CMDMEM_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 25) & 0x1)
#define CMIC_IRQ_MASKr_BSE_CMDMEM_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define CMIC_IRQ_MASKr_CSE_CMDMEM_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 26) & 0x1)
#define CMIC_IRQ_MASKr_CSE_CMDMEM_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define CMIC_IRQ_MASKr_HSE_CMDMEM_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 27) & 0x1)
#define CMIC_IRQ_MASKr_HSE_CMDMEM_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define CMIC_IRQ_MASKr_MEM_FAILf_GET(r) ((((r).cmic_irq_mask[0]) >> 28) & 0x1)
#define CMIC_IRQ_MASKr_MEM_FAILf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define CMIC_IRQ_MASKr_TABLE_DMA_COMPLETEf_GET(r) ((((r).cmic_irq_mask[0]) >> 29) & 0x1)
#define CMIC_IRQ_MASKr_TABLE_DMA_COMPLETEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define CMIC_IRQ_MASKr_SLAM_DMA_COMPLETEf_GET(r) ((((r).cmic_irq_mask[0]) >> 30) & 0x1)
#define CMIC_IRQ_MASKr_SLAM_DMA_COMPLETEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define CMIC_IRQ_MASKr_BSAFE_OP_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 31) & 0x1)
#define CMIC_IRQ_MASKr_BSAFE_OP_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access CMIC_IRQ_MASK.
 *
 */
#define READ_CMIC_IRQ_MASKr(u,r) CDK_DEV_READ32(u,CMIC_IRQ_MASKr,r._cmic_irq_mask)
#define WRITE_CMIC_IRQ_MASKr(u,r) CDK_DEV_WRITE32(u,CMIC_IRQ_MASKr,r._cmic_irq_mask)

/*******************************************************************************
 * End of 'CMIC_IRQ_MASKr'
 ******************************************************************************/




/*******************************************************************************
 * REGISTER:  CMIC_IRQ_STAT
 * BLOCKS:   CMIC
 * DESC:     Interrupt Status Register
 * SIZE:     32
 * FIELDS:
 *     SCH_MSG_DONE     SCH Message Operation Complete Interrupt
 *     RESERVED_1       Reserved
 *     LINK_STAT_MOD    Link Status Change Interrupt
 *     L2_MOD_FIFO_NOT_EMPTY L2 MOD Fifo is full
 *     RESERVED_2       Reserved
 *     CH0_DESC_DONE    DMA CH0 Next Descriptor Execution Complete Interrupt
 *     CH0_CHAIN_DONE   DMA CH0 End Of Chain Interrupt
 *     CH1_DESC_DONE    DMA CH1 Next Descriptor Execution Complete Interrupt
 *     CH1_CHAIN_DONE   DMA CH1 End Of Chain Interrupt
 *     CH2_DESC_DONE    DMA CH2 Next Descriptor Execution Complete Interrupt
 *     CH2_CHAIN_DONE   DMA CH2 End Of Chain Interrupt
 *     CH3_DESC_DONE    DMA CH3 Next Descriptor Execution Complete Interrupt
 *     CH3_CHAIN_DONE   DMA CH3 End Of Chain Interrupt
 *     PCI_PARITY_ERR   PCI Bus Parity Error Interrupt
 *     PCI_FATAL_ERR    PCI Bus Fatal Error Interrupt
 *     SCHAN_ERR        SCH Bus Error Interrupt
 *     I2C_INTR         I2C Interrupt
 *     MIIM_OP_DONE     MIIM Operation Complete Interrupt
 *     STAT_DMA_DONE    Stats DMA Iteration Complete Interrupt
 *     RESERVED_3       Reserved
 *     BSE_CMDMEM_DONE  BSE CMDMEM DONE
 *     CSE_CMDMEM_DONE  CSE CMDMEM DONE
 *     HSE_CMDMEM_DONE  HSE CMDMEM DONE
 *     MEM_FAIL         MMU Memory Failed
 *     TABLE_DMA_COMPLETE Table DMA operation complete
 *     SLAM_DMA_COMPLETE Slam DMA operation complete
 *     BSAFE_OP_DONE    Broadsafe operation complete
 *
 ******************************************************************************/
#define CMIC_IRQ_STATr 0x00000144

#define CMIC_IRQ_STATr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_IRQ_STAT.
 *
 */
typedef union CMIC_IRQ_STATr_s {
	uint32_t v[1];
	uint32_t cmic_irq_stat[1];
	uint32_t _cmic_irq_stat;
} CMIC_IRQ_STATr_t;

#define CMIC_IRQ_STATr_CLR(r) (r).cmic_irq_stat[0] = 0
#define CMIC_IRQ_STATr_SET(r,d) (r).cmic_irq_stat[0] = d
#define CMIC_IRQ_STATr_GET(r) (r).cmic_irq_stat[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define CMIC_IRQ_STATr_SCH_MSG_DONEf_GET(r) (((r).cmic_irq_stat[0]) & 0x1)
#define CMIC_IRQ_STATr_SCH_MSG_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CMIC_IRQ_STATr_RESERVED_1f_GET(r) ((((r).cmic_irq_stat[0]) >> 1) & 0x7)
#define CMIC_IRQ_STATr_RESERVED_1f_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define CMIC_IRQ_STATr_LINK_STAT_MODf_GET(r) ((((r).cmic_irq_stat[0]) >> 4) & 0x1)
#define CMIC_IRQ_STATr_LINK_STAT_MODf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define CMIC_IRQ_STATr_L2_MOD_FIFO_NOT_EMPTYf_GET(r) ((((r).cmic_irq_stat[0]) >> 5) & 0x1)
#define CMIC_IRQ_STATr_L2_MOD_FIFO_NOT_EMPTYf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define CMIC_IRQ_STATr_RESERVED_2f_GET(r) ((((r).cmic_irq_stat[0]) >> 6) & 0x1)
#define CMIC_IRQ_STATr_RESERVED_2f_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define CMIC_IRQ_STATr_CH0_DESC_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 7) & 0x1)
#define CMIC_IRQ_STATr_CH0_DESC_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define CMIC_IRQ_STATr_CH0_CHAIN_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 8) & 0x1)
#define CMIC_IRQ_STATr_CH0_CHAIN_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define CMIC_IRQ_STATr_CH1_DESC_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 9) & 0x1)
#define CMIC_IRQ_STATr_CH1_DESC_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define CMIC_IRQ_STATr_CH1_CHAIN_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 10) & 0x1)
#define CMIC_IRQ_STATr_CH1_CHAIN_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define CMIC_IRQ_STATr_CH2_DESC_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 11) & 0x1)
#define CMIC_IRQ_STATr_CH2_DESC_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define CMIC_IRQ_STATr_CH2_CHAIN_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 12) & 0x1)
#define CMIC_IRQ_STATr_CH2_CHAIN_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define CMIC_IRQ_STATr_CH3_DESC_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 13) & 0x1)
#define CMIC_IRQ_STATr_CH3_DESC_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define CMIC_IRQ_STATr_CH3_CHAIN_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 14) & 0x1)
#define CMIC_IRQ_STATr_CH3_CHAIN_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define CMIC_IRQ_STATr_PCI_PARITY_ERRf_GET(r) ((((r).cmic_irq_stat[0]) >> 15) & 0x1)
#define CMIC_IRQ_STATr_PCI_PARITY_ERRf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define CMIC_IRQ_STATr_PCI_FATAL_ERRf_GET(r) ((((r).cmic_irq_stat[0]) >> 16) & 0x1)
#define CMIC_IRQ_STATr_PCI_FATAL_ERRf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define CMIC_IRQ_STATr_SCHAN_ERRf_GET(r) ((((r).cmic_irq_stat[0]) >> 17) & 0x1)
#define CMIC_IRQ_STATr_SCHAN_ERRf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define CMIC_IRQ_STATr_I2C_INTRf_GET(r) ((((r).cmic_irq_stat[0]) >> 18) & 0x1)
#define CMIC_IRQ_STATr_I2C_INTRf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define CMIC_IRQ_STATr_MIIM_OP_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 19) & 0x1)
#define CMIC_IRQ_STATr_MIIM_OP_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define CMIC_IRQ_STATr_STAT_DMA_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 20) & 0x1)
#define CMIC_IRQ_STATr_STAT_DMA_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define CMIC_IRQ_STATr_RESERVED_3f_GET(r) ((((r).cmic_irq_stat[0]) >> 21) & 0xf)
#define CMIC_IRQ_STATr_RESERVED_3f_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0xf << 21)) | ((((uint32_t)f) & 0xf) << 21))
#define CMIC_IRQ_STATr_BSE_CMDMEM_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 25) & 0x1)
#define CMIC_IRQ_STATr_BSE_CMDMEM_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define CMIC_IRQ_STATr_CSE_CMDMEM_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 26) & 0x1)
#define CMIC_IRQ_STATr_CSE_CMDMEM_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define CMIC_IRQ_STATr_HSE_CMDMEM_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 27) & 0x1)
#define CMIC_IRQ_STATr_HSE_CMDMEM_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define CMIC_IRQ_STATr_MEM_FAILf_GET(r) ((((r).cmic_irq_stat[0]) >> 28) & 0x1)
#define CMIC_IRQ_STATr_MEM_FAILf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define CMIC_IRQ_STATr_TABLE_DMA_COMPLETEf_GET(r) ((((r).cmic_irq_stat[0]) >> 29) & 0x1)
#define CMIC_IRQ_STATr_TABLE_DMA_COMPLETEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define CMIC_IRQ_STATr_SLAM_DMA_COMPLETEf_GET(r) ((((r).cmic_irq_stat[0]) >> 30) & 0x1)
#define CMIC_IRQ_STATr_SLAM_DMA_COMPLETEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define CMIC_IRQ_STATr_BSAFE_OP_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 31) & 0x1)
#define CMIC_IRQ_STATr_BSAFE_OP_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access CMIC_IRQ_STAT.
 *
 */
#define READ_CMIC_IRQ_STATr(u,r) CDK_DEV_READ32(u,CMIC_IRQ_STATr,r._cmic_irq_stat)
#define WRITE_CMIC_IRQ_STATr(u,r) CDK_DEV_WRITE32(u,CMIC_IRQ_STATr,r._cmic_irq_stat)

/*******************************************************************************
 * End of 'CMIC_IRQ_STATr'
 ******************************************************************************/




/*******************************************************************************
 * REGISTER:  CMIC_MIIM_PARAM
 * BLOCKS:   CMIC
 * DESC:     MIIM Parameter Register
 * SIZE:     32
 * FIELDS:
 *     PHY_DATA         PHY register data
 *     PHY_ID           Port number (Phy ID is looked up from port number)
 *     C45_SEL          When set, send MIIM transaction using Clause 45.Otherwise, send as Clause 22 transaction.
 *     HG_SEL           When set, send MIIM transaction on Higig MDIO bus.Otherwise, send on Gig MDIO bus.
 *     INTERNAL_SEL     When set, send MIIM transaction on Internal MDIO bus.Otherwise, send on External MDIO bus.
 *     RESERVED_2       Reserved
 *     MIIM_CYCLE       This field is used to select which type of MIIM cycle to run.Normally, it should just be set to 000.    000: Automatically runs the proper read or write cycle based         on the ports' protocol preference, and whether a read         or write cycle was requested.  If the port is clause 45         enabled, then the read or write will be preceeded by         an address cycle.    001: requests a clause 22 write cycle;         use MIIM_WR_REG_EN control    010: requests a clause 22 read cycle;         use MIIM_RD_REG_EN control    100: requests a clause 45 address cycle;         use MIIM_WR_REG_EN control    101: requests a clause 45 write cycle;         use MIIM_WR_REG_EN control    110: requests a clause 45 read cycle w/addr increment;         use MIIM_RD_REG_EN control    111: requests a clause 45 read cycle;         use MIIM_RD_REG_EN control
 *
 ******************************************************************************/
#define CMIC_MIIM_PARAMr 0x00000158

#define CMIC_MIIM_PARAMr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_PARAM.
 *
 */
typedef union CMIC_MIIM_PARAMr_s {
	uint32_t v[1];
	uint32_t cmic_miim_param[1];
	uint32_t _cmic_miim_param;
} CMIC_MIIM_PARAMr_t;

#define CMIC_MIIM_PARAMr_CLR(r) (r).cmic_miim_param[0] = 0
#define CMIC_MIIM_PARAMr_SET(r,d) (r).cmic_miim_param[0] = d
#define CMIC_MIIM_PARAMr_GET(r) (r).cmic_miim_param[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define CMIC_MIIM_PARAMr_PHY_DATAf_GET(r) (((r).cmic_miim_param[0]) & 0xffff)
#define CMIC_MIIM_PARAMr_PHY_DATAf_SET(r,f) (r).cmic_miim_param[0]=(((r).cmic_miim_param[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define CMIC_MIIM_PARAMr_PHY_IDf_GET(r) ((((r).cmic_miim_param[0]) >> 16) & 0x1f)
#define CMIC_MIIM_PARAMr_PHY_IDf_SET(r,f) (r).cmic_miim_param[0]=(((r).cmic_miim_param[0] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define CMIC_MIIM_PARAMr_C45_SELf_GET(r) ((((r).cmic_miim_param[0]) >> 21) & 0x1)
#define CMIC_MIIM_PARAMr_C45_SELf_SET(r,f) (r).cmic_miim_param[0]=(((r).cmic_miim_param[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define CMIC_MIIM_PARAMr_HG_SELf_GET(r) ((((r).cmic_miim_param[0]) >> 22) & 0x1)
#define CMIC_MIIM_PARAMr_HG_SELf_SET(r,f) (r).cmic_miim_param[0]=(((r).cmic_miim_param[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define CMIC_MIIM_PARAMr_INTERNAL_SELf_GET(r) ((((r).cmic_miim_param[0]) >> 23) & 0x1)
#define CMIC_MIIM_PARAMr_INTERNAL_SELf_SET(r,f) (r).cmic_miim_param[0]=(((r).cmic_miim_param[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define CMIC_MIIM_PARAMr_RESERVED_2f_GET(r) ((((r).cmic_miim_param[0]) >> 24) & 0x1f)
#define CMIC_MIIM_PARAMr_RESERVED_2f_SET(r,f) (r).cmic_miim_param[0]=(((r).cmic_miim_param[0] & ~((uint32_t)0x1f << 24)) | ((((uint32_t)f) & 0x1f) << 24))
#define CMIC_MIIM_PARAMr_MIIM_CYCLEf_GET(r) ((((r).cmic_miim_param[0]) >> 29) & 0x7)
#define CMIC_MIIM_PARAMr_MIIM_CYCLEf_SET(r,f) (r).cmic_miim_param[0]=(((r).cmic_miim_param[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access CMIC_MIIM_PARAM.
 *
 */
#define READ_CMIC_MIIM_PARAMr(u,r) CDK_DEV_READ32(u,CMIC_MIIM_PARAMr,r._cmic_miim_param)
#define WRITE_CMIC_MIIM_PARAMr(u,r) CDK_DEV_WRITE32(u,CMIC_MIIM_PARAMr,r._cmic_miim_param)

/*******************************************************************************
 * End of 'CMIC_MIIM_PARAMr'
 ******************************************************************************/




/*******************************************************************************
 * REGISTER:  CMIC_MIIM_READ_DATA
 * BLOCKS:   CMIC
 * DESC:     MIIM Read Data Register
 * SIZE:     32
 * FIELDS:
 *     DATA             MIIM Read Data Register
 *
 ******************************************************************************/
#define CMIC_MIIM_READ_DATAr 0x0000015c

#define CMIC_MIIM_READ_DATAr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_READ_DATA.
 *
 */
typedef union CMIC_MIIM_READ_DATAr_s {
	uint32_t v[1];
	uint32_t cmic_miim_read_data[1];
	uint32_t _cmic_miim_read_data;
} CMIC_MIIM_READ_DATAr_t;

#define CMIC_MIIM_READ_DATAr_CLR(r) (r).cmic_miim_read_data[0] = 0
#define CMIC_MIIM_READ_DATAr_SET(r,d) (r).cmic_miim_read_data[0] = d
#define CMIC_MIIM_READ_DATAr_GET(r) (r).cmic_miim_read_data[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define CMIC_MIIM_READ_DATAr_DATAf_GET(r) (((r).cmic_miim_read_data[0]) & 0xffff)
#define CMIC_MIIM_READ_DATAr_DATAf_SET(r,f) (r).cmic_miim_read_data[0]=(((r).cmic_miim_read_data[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access CMIC_MIIM_READ_DATA.
 *
 */
#define READ_CMIC_MIIM_READ_DATAr(u,r) CDK_DEV_READ32(u,CMIC_MIIM_READ_DATAr,r._cmic_miim_read_data)
#define WRITE_CMIC_MIIM_READ_DATAr(u,r) CDK_DEV_WRITE32(u,CMIC_MIIM_READ_DATAr,r._cmic_miim_read_data)

/*******************************************************************************
 * End of 'CMIC_MIIM_READ_DATAr'
 ******************************************************************************/




/*******************************************************************************
 * REGISTER:  CMIC_SCHAN_CTRL
 * BLOCKS:   CMIC
 * DESC:     Status and Control Register
 * SIZE:     32
 * FIELDS:
 *     MSG_START        Set by CPU to start an SCH operation
 *     MSG_DONE         Set by CMIC to indicate an SCH operation completion
 *     RESERVED_1       Reserved
 *     LINK_STATUS_CHANGE Set by CMIC to indicate Link status changed
 *     PCI_FATAL_ERR    Set by CMIC to indicate a Fatal Error during PCI master Operation
 *     PCI_PARITY_ERR   Set by CMIC to indicate a Parity Error during PCI master Operation
 *     RESERVED_3       Reserved
 *     MIIM_SCAN_BUSY   Set by CMIC indicating that MIIM scan cycle is in progress
 *     RESERVED_4       Reserved
 *     MIIM_RD_START    Set by CPU to start a Read operation on MIIM Interface
 *     MIIM_WR_START    Set by CPU to start a Write operation on MIIM Interface
 *     MIIM_OP_DONE     Set by CMIC to indicate Completion of MIIM Rd/Wr Operation
 *     MIIM_LINK_SCAN_EN Set by CPU to start automatic Link Status scanning
 *     RESERVED_5       Reserved
 *     NACK             Set by CMIC to indicate last S-bus operation resulted in a NACK(i.e., command was legal, but could not be serviced due tohardware resource limitations)Clearing the SCH_PIO_OPN_COMPLETE bit or starting a new SCH operation will automatically clear this bit
 *     TIMEOUT          Set by CMIC to indicate last S-bus operation resulted in a TIMEOUT.(i.e., no ACK was received by CMIC within the TIMEOUT intervalspecified in CMIC_SBUS_TIMEOUT)Clearing the SCH_PIO_OPN_COMPLETE bit or starting a new SCH operation will automatically clear this bit
 *     BIT_POS          Selects one of 32 bits positions to be Set/Reset
 *     BIT_VAL          Set to 1 to set a bit, 0 to reset a bit
 *     RESERVED_6       Reserved
 *
 ******************************************************************************/
#define CMIC_SCHAN_CTRLr 0x00000050

#define CMIC_SCHAN_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SCHAN_CTRL.
 *
 */
typedef union CMIC_SCHAN_CTRLr_s {
	uint32_t v[1];
	uint32_t cmic_schan_ctrl[1];
	uint32_t _cmic_schan_ctrl;
} CMIC_SCHAN_CTRLr_t;

#define CMIC_SCHAN_CTRLr_CLR(r) (r).cmic_schan_ctrl[0] = 0
#define CMIC_SCHAN_CTRLr_SET(r,d) (r).cmic_schan_ctrl[0] = d
#define CMIC_SCHAN_CTRLr_GET(r) (r).cmic_schan_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define CMIC_SCHAN_CTRLr_MSG_STARTf_GET(r) (((r).cmic_schan_ctrl[0]) & 0x1)
#define CMIC_SCHAN_CTRLr_MSG_STARTf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CMIC_SCHAN_CTRLr_MSG_DONEf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 1) & 0x1)
#define CMIC_SCHAN_CTRLr_MSG_DONEf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CMIC_SCHAN_CTRLr_RESERVED_1f_GET(r) ((((r).cmic_schan_ctrl[0]) >> 2) & 0x3f)
#define CMIC_SCHAN_CTRLr_RESERVED_1f_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x3f << 2)) | ((((uint32_t)f) & 0x3f) << 2))
#define CMIC_SCHAN_CTRLr_LINK_STATUS_CHANGEf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 8) & 0x1)
#define CMIC_SCHAN_CTRLr_LINK_STATUS_CHANGEf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define CMIC_SCHAN_CTRLr_PCI_FATAL_ERRf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 9) & 0x1)
#define CMIC_SCHAN_CTRLr_PCI_FATAL_ERRf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define CMIC_SCHAN_CTRLr_PCI_PARITY_ERRf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 10) & 0x1)
#define CMIC_SCHAN_CTRLr_PCI_PARITY_ERRf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define CMIC_SCHAN_CTRLr_RESERVED_3f_GET(r) ((((r).cmic_schan_ctrl[0]) >> 11) & 0x7)
#define CMIC_SCHAN_CTRLr_RESERVED_3f_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11))
#define CMIC_SCHAN_CTRLr_MIIM_SCAN_BUSYf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 14) & 0x1)
#define CMIC_SCHAN_CTRLr_MIIM_SCAN_BUSYf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define CMIC_SCHAN_CTRLr_RESERVED_4f_GET(r) ((((r).cmic_schan_ctrl[0]) >> 15) & 0x1)
#define CMIC_SCHAN_CTRLr_RESERVED_4f_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define CMIC_SCHAN_CTRLr_MIIM_RD_STARTf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 16) & 0x1)
#define CMIC_SCHAN_CTRLr_MIIM_RD_STARTf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define CMIC_SCHAN_CTRLr_MIIM_WR_STARTf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 17) & 0x1)
#define CMIC_SCHAN_CTRLr_MIIM_WR_STARTf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define CMIC_SCHAN_CTRLr_MIIM_OP_DONEf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 18) & 0x1)
#define CMIC_SCHAN_CTRLr_MIIM_OP_DONEf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define CMIC_SCHAN_CTRLr_MIIM_LINK_SCAN_ENf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 19) & 0x1)
#define CMIC_SCHAN_CTRLr_MIIM_LINK_SCAN_ENf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define CMIC_SCHAN_CTRLr_RESERVED_5f_GET(r) ((((r).cmic_schan_ctrl[0]) >> 20) & 0x1)
#define CMIC_SCHAN_CTRLr_RESERVED_5f_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define CMIC_SCHAN_CTRLr_NACKf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 21) & 0x1)
#define CMIC_SCHAN_CTRLr_NACKf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define CMIC_SCHAN_CTRLr_TIMEOUTf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 22) & 0x1)
#define CMIC_SCHAN_CTRLr_TIMEOUTf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define CMIC_SCHAN_CTRLr_BIT_POSf_GET(r) (((r).cmic_schan_ctrl[0]) & 0x1f)
#define CMIC_SCHAN_CTRLr_BIT_POSf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define CMIC_SCHAN_CTRLr_BIT_VALf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 7) & 0x1)
#define CMIC_SCHAN_CTRLr_BIT_VALf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define CMIC_SCHAN_CTRLr_RESERVED_6f_GET(r) ((((r).cmic_schan_ctrl[0]) >> 22) & 0x3ff)
#define CMIC_SCHAN_CTRLr_RESERVED_6f_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x3ff << 22)) | ((((uint32_t)f) & 0x3ff) << 22))

/*
 * These macros can be used to access CMIC_SCHAN_CTRL.
 *
 */
#define READ_CMIC_SCHAN_CTRLr(u,r) CDK_DEV_READ32(u,CMIC_SCHAN_CTRLr,r._cmic_schan_ctrl)
#define WRITE_CMIC_SCHAN_CTRLr(u,r) CDK_DEV_WRITE32(u,CMIC_SCHAN_CTRLr,r._cmic_schan_ctrl)

/*******************************************************************************
 * End of 'CMIC_SCHAN_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * REGISTER:  CMIC_SCHAN_ERR
 * BLOCKS:   CMIC
 * DESC:     Error Status Register
 * SIZE:     32
 * FIELDS:
 *     NACK             When set, indicates the last S-bus command resulted in an NACK(i.e., could not be fulfilled due to hardware resource limitations).
 *     RESERVED_1       Reserved
 *     ERR_CODE         Error code in the SCH Error message
 *     ERRBIT           When set, indicates the last S-bus command resulted in an error(i.e., the command was illegal, or accessed an invalid address)
 *     DATA_LEN         Data length in the SCH Error ACK message
 *     SRC_PORT         Source port in the SCH Error ACK message(not guaranteed to be set by all blocks)
 *     DST_PORT         Dest port in the SCH Error ACK message
 *     OP_CODE          Opcode in the SCH Error ACK message
 *
 ******************************************************************************/
#define CMIC_SCHAN_ERRr 0x0000005c

#define CMIC_SCHAN_ERRr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SCHAN_ERR.
 *
 */
typedef union CMIC_SCHAN_ERRr_s {
	uint32_t v[1];
	uint32_t cmic_schan_err[1];
	uint32_t _cmic_schan_err;
} CMIC_SCHAN_ERRr_t;

#define CMIC_SCHAN_ERRr_CLR(r) (r).cmic_schan_err[0] = 0
#define CMIC_SCHAN_ERRr_SET(r,d) (r).cmic_schan_err[0] = d
#define CMIC_SCHAN_ERRr_GET(r) (r).cmic_schan_err[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define CMIC_SCHAN_ERRr_NACKf_GET(r) (((r).cmic_schan_err[0]) & 0x1)
#define CMIC_SCHAN_ERRr_NACKf_SET(r,f) (r).cmic_schan_err[0]=(((r).cmic_schan_err[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CMIC_SCHAN_ERRr_RESERVED_1f_GET(r) ((((r).cmic_schan_err[0]) >> 1) & 0x7)
#define CMIC_SCHAN_ERRr_RESERVED_1f_SET(r,f) (r).cmic_schan_err[0]=(((r).cmic_schan_err[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define CMIC_SCHAN_ERRr_ERR_CODEf_GET(r) ((((r).cmic_schan_err[0]) >> 4) & 0x3)
#define CMIC_SCHAN_ERRr_ERR_CODEf_SET(r,f) (r).cmic_schan_err[0]=(((r).cmic_schan_err[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define CMIC_SCHAN_ERRr_ERRBITf_GET(r) ((((r).cmic_schan_err[0]) >> 6) & 0x1)
#define CMIC_SCHAN_ERRr_ERRBITf_SET(r,f) (r).cmic_schan_err[0]=(((r).cmic_schan_err[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define CMIC_SCHAN_ERRr_DATA_LENf_GET(r) ((((r).cmic_schan_err[0]) >> 7) & 0x7f)
#define CMIC_SCHAN_ERRr_DATA_LENf_SET(r,f) (r).cmic_schan_err[0]=(((r).cmic_schan_err[0] & ~((uint32_t)0x7f << 7)) | ((((uint32_t)f) & 0x7f) << 7))
#define CMIC_SCHAN_ERRr_SRC_PORTf_GET(r) ((((r).cmic_schan_err[0]) >> 14) & 0x3f)
#define CMIC_SCHAN_ERRr_SRC_PORTf_SET(r,f) (r).cmic_schan_err[0]=(((r).cmic_schan_err[0] & ~((uint32_t)0x3f << 14)) | ((((uint32_t)f) & 0x3f) << 14))
#define CMIC_SCHAN_ERRr_DST_PORTf_GET(r) ((((r).cmic_schan_err[0]) >> 20) & 0x3f)
#define CMIC_SCHAN_ERRr_DST_PORTf_SET(r,f) (r).cmic_schan_err[0]=(((r).cmic_schan_err[0] & ~((uint32_t)0x3f << 20)) | ((((uint32_t)f) & 0x3f) << 20))
#define CMIC_SCHAN_ERRr_OP_CODEf_GET(r) ((((r).cmic_schan_err[0]) >> 26) & 0x3f)
#define CMIC_SCHAN_ERRr_OP_CODEf_SET(r,f) (r).cmic_schan_err[0]=(((r).cmic_schan_err[0] & ~((uint32_t)0x3f << 26)) | ((((uint32_t)f) & 0x3f) << 26))

/*
 * These macros can be used to access CMIC_SCHAN_ERR.
 *
 */
#define READ_CMIC_SCHAN_ERRr(u,r) CDK_DEV_READ32(u,CMIC_SCHAN_ERRr,r._cmic_schan_err)
#define WRITE_CMIC_SCHAN_ERRr(u,r) CDK_DEV_WRITE32(u,CMIC_SCHAN_ERRr,r._cmic_schan_err)

/*******************************************************************************
 * End of 'CMIC_SCHAN_ERRr'
 ******************************************************************************/




#endif /* __CDK_XGS_CMIC_H__ */
