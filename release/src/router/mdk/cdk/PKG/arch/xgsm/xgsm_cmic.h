#ifndef __CDK_XGSM_CMIC_H__
#define __CDK_XGSM_CMIC_H__
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated from the registers file.
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Copyright 2013 Broadcom Corporation.
 * This program is the proprietary software of Broadcom Corporation
 * and/or its licensors, and may only be used, duplicated, modified
 * or distributed pursuant to the terms and conditions of a separate,
 * written license agreement executed between you and Broadcom
 * (an "Authorized License").  Except as set forth in an Authorized
 * License, Broadcom grants no license (express or implied), right
 * to use, or waiver of any kind with respect to the Software, and
 * Broadcom expressly reserves all rights in and to the Software
 * and all intellectual property rights therein.  IF YOU HAVE
 * NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
 * IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
 * ALL USE OF THE SOFTWARE.  
 *  
 * Except as expressly set forth in the Authorized License,
 *  
 * 1.     This program, including its structure, sequence and organization,
 * constitutes the valuable trade secrets of Broadcom, and you shall use
 * all reasonable efforts to protect the confidentiality thereof,
 * and to use this information only in connection with your use of
 * Broadcom integrated circuit products.
 *  
 * 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
 * PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
 * REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
 * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
 * DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
 * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
 * ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
 * CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
 * OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
 * 
 * 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
 * BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
 * INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
 * ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
 * TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
 * THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR USD 1.00,
 * WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
 * ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
 *
 * Definition file for the ALL.
 * This file provides all basic definitions required to program the ALL.
 *
 ******************************************************************************/

#include <cdk/cdk_string.h>
#include <cdk/cdk_field.h>
#include <cdk/arch/xgsm_reg.h>
#include <cdk/arch/xgsm_mem.h>

/*******************************************************************************
 *
 *                    CHIP DEFINITIONS BEGIN HERE
 *
 ******************************************************************************/



/*******************************************************************************
 * REGISTER:  CMIC_CMC_COS_CTRL_RX_0
 * BLOCKS:   CMIC
 * DESC:     When COS_RX_EN of CMIC_CONFIG is set, this register
indicates which cos are admitted by channel. This register
gives only the LS byte.

 * SIZE:     32
 * FIELDS:
 *     COS_BMP          Channel 0 COS bitmap
 *
 ******************************************************************************/
#define CMIC_CMC_COS_CTRL_RX_0r 0x00031168

#define CMIC_CMC_COS_CTRL_RX_0r_ENUM 0
#define CMIC_CMC_COS_CTRL_RX_0r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_COS_CTRL_RX_0.
 *
 */
typedef union CMIC_CMC_COS_CTRL_RX_0r_s {
	uint32_t v[1];
	uint32_t cmic_cmc_cos_ctrl_rx_0[1];
	uint32_t _cmic_cmc_cos_ctrl_rx_0;
} CMIC_CMC_COS_CTRL_RX_0r_t;

#define CMIC_CMC_COS_CTRL_RX_0r_CLR(r) (r).cmic_cmc_cos_ctrl_rx_0[0] = 0
#define CMIC_CMC_COS_CTRL_RX_0r_SET(r,d) (r).cmic_cmc_cos_ctrl_rx_0[0] = d
#define CMIC_CMC_COS_CTRL_RX_0r_GET(r) (r).cmic_cmc_cos_ctrl_rx_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define CMIC_CMC_COS_CTRL_RX_0r_COS_BMPf_GET(r) ((r).cmic_cmc_cos_ctrl_rx_0[0])
#define CMIC_CMC_COS_CTRL_RX_0r_COS_BMPf_SET(r,f) (r).cmic_cmc_cos_ctrl_rx_0[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_CMC_COS_CTRL_RX_0.
 *
 */
#define READ_CMIC_CMC_COS_CTRL_RX_0r(u,i,r) CDK_XGSM_CMC_READ(u,CMIC_CMC_COS_CTRL_RX_0r+(4*(i)),r._cmic_cmc_cos_ctrl_rx_0)
#define WRITE_CMIC_CMC_COS_CTRL_RX_0r(u,i,r) CDK_XGSM_CMC_WRITE(u,CMIC_CMC_COS_CTRL_RX_0r+(4*(i)),r._cmic_cmc_cos_ctrl_rx_0)

/*******************************************************************************
 * End of 'CMIC_CMC_COS_CTRL_RX_0r'
 ******************************************************************************/




/*******************************************************************************
 * REGISTER:  CMIC_CMC_COS_CTRL_RX_1
 * BLOCKS:   CMIC
 * DESC:     When COS_RX_EN of CMIC_CONFIG is set, this register
indicates which cos are admitted by channel. This register
gives only the LS byte.

 * SIZE:     32
 * FIELDS:
 *     COS_BMP          Channel 0 COS bitmap
 *
 ******************************************************************************/
#define CMIC_CMC_COS_CTRL_RX_1r 0x0003116c

#define CMIC_CMC_COS_CTRL_RX_1r_ENUM 1
#define CMIC_CMC_COS_CTRL_RX_1r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_COS_CTRL_RX_1.
 *
 */
typedef union CMIC_CMC_COS_CTRL_RX_1r_s {
	uint32_t v[1];
	uint32_t cmic_cmc_cos_ctrl_rx_1[1];
	uint32_t _cmic_cmc_cos_ctrl_rx_1;
} CMIC_CMC_COS_CTRL_RX_1r_t;

#define CMIC_CMC_COS_CTRL_RX_1r_CLR(r) (r).cmic_cmc_cos_ctrl_rx_1[0] = 0
#define CMIC_CMC_COS_CTRL_RX_1r_SET(r,d) (r).cmic_cmc_cos_ctrl_rx_1[0] = d
#define CMIC_CMC_COS_CTRL_RX_1r_GET(r) (r).cmic_cmc_cos_ctrl_rx_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define CMIC_CMC_COS_CTRL_RX_1r_COS_BMPf_GET(r) ((r).cmic_cmc_cos_ctrl_rx_1[0])
#define CMIC_CMC_COS_CTRL_RX_1r_COS_BMPf_SET(r,f) (r).cmic_cmc_cos_ctrl_rx_1[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_CMC_COS_CTRL_RX_1.
 *
 */
#define READ_CMIC_CMC_COS_CTRL_RX_1r(u,i,r) CDK_XGSM_CMC_READ(u,CMIC_CMC_COS_CTRL_RX_1r+(4*(i)),r._cmic_cmc_cos_ctrl_rx_1)
#define WRITE_CMIC_CMC_COS_CTRL_RX_1r(u,i,r) CDK_XGSM_CMC_WRITE(u,CMIC_CMC_COS_CTRL_RX_1r+(4*(i)),r._cmic_cmc_cos_ctrl_rx_1)

/*******************************************************************************
 * End of 'CMIC_CMC_COS_CTRL_RX_1r'
 ******************************************************************************/




/*******************************************************************************
 * REGISTER:  CMIC_CMC_DMA_CTRL
 * BLOCKS:   CMIC
 * DESC:     DMA Control Register
 * SIZE:     32
 * FIELDS:
 *     DIRECTION        DMA channel 0 direction:1=Mem->SOC, 0=SOC->Mem
 *     DMA_EN           Set by CPU to start a DMA on CH0 
 *     ABORT_DMA        DMA channel 0 abort
 *     SEL_INTR_ON_DESC_OR_PKT DMA channel 0 interrupt select:1=after descriptor, 0=after packet
 *     PKTDMA_ENDIANESS (Bit 1) 0 = 1 = big word order for Packet DMA operations
 *     DESC_ENDIANESS   (Bit 1) 0 = 1 = big word order for Descriptor operations
 *     DROP_RX_PKT_ON_CHAIN_END DMA channel 0 setting for handling packet received after hittingend of chain (and hence no descriptors are available)1=drop the packet, 0=block, waiting for descriptor to be available
 *     RLD_STS_UPD_DIS  When set, do not update status fields on reload operation.
 *
 ******************************************************************************/
#define CMIC_CMC_DMA_CTRLr 0x00031140

#define CMIC_CMC_DMA_CTRLr_ENUM 2
#define CMIC_CMC_DMA_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_DMA_CTRL.
 *
 */
typedef union CMIC_CMC_DMA_CTRLr_s {
	uint32_t v[1];
	uint32_t cmic_cmc_dma_ctrl[1];
	uint32_t _cmic_cmc_dma_ctrl;
} CMIC_CMC_DMA_CTRLr_t;

#define CMIC_CMC_DMA_CTRLr_CLR(r) (r).cmic_cmc_dma_ctrl[0] = 0
#define CMIC_CMC_DMA_CTRLr_SET(r,d) (r).cmic_cmc_dma_ctrl[0] = d
#define CMIC_CMC_DMA_CTRLr_GET(r) (r).cmic_cmc_dma_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define CMIC_CMC_DMA_CTRLr_DIRECTIONf_GET(r) (((r).cmic_cmc_dma_ctrl[0]) & 0x1)
#define CMIC_CMC_DMA_CTRLr_DIRECTIONf_SET(r,f) (r).cmic_cmc_dma_ctrl[0]=(((r).cmic_cmc_dma_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CMIC_CMC_DMA_CTRLr_DMA_ENf_GET(r) ((((r).cmic_cmc_dma_ctrl[0]) >> 1) & 0x1)
#define CMIC_CMC_DMA_CTRLr_DMA_ENf_SET(r,f) (r).cmic_cmc_dma_ctrl[0]=(((r).cmic_cmc_dma_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CMIC_CMC_DMA_CTRLr_ABORT_DMAf_GET(r) ((((r).cmic_cmc_dma_ctrl[0]) >> 2) & 0x1)
#define CMIC_CMC_DMA_CTRLr_ABORT_DMAf_SET(r,f) (r).cmic_cmc_dma_ctrl[0]=(((r).cmic_cmc_dma_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define CMIC_CMC_DMA_CTRLr_SEL_INTR_ON_DESC_OR_PKTf_GET(r) ((((r).cmic_cmc_dma_ctrl[0]) >> 3) & 0x1)
#define CMIC_CMC_DMA_CTRLr_SEL_INTR_ON_DESC_OR_PKTf_SET(r,f) (r).cmic_cmc_dma_ctrl[0]=(((r).cmic_cmc_dma_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define CMIC_CMC_DMA_CTRLr_PKTDMA_ENDIANESSf_GET(r) ((((r).cmic_cmc_dma_ctrl[0]) >> 4) & 0x1)
#define CMIC_CMC_DMA_CTRLr_PKTDMA_ENDIANESSf_SET(r,f) (r).cmic_cmc_dma_ctrl[0]=(((r).cmic_cmc_dma_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define CMIC_CMC_DMA_CTRLr_DESC_ENDIANESSf_GET(r) ((((r).cmic_cmc_dma_ctrl[0]) >> 5) & 0x1)
#define CMIC_CMC_DMA_CTRLr_DESC_ENDIANESSf_SET(r,f) (r).cmic_cmc_dma_ctrl[0]=(((r).cmic_cmc_dma_ctrl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define CMIC_CMC_DMA_CTRLr_DROP_RX_PKT_ON_CHAIN_ENDf_GET(r) ((((r).cmic_cmc_dma_ctrl[0]) >> 6) & 0x1)
#define CMIC_CMC_DMA_CTRLr_DROP_RX_PKT_ON_CHAIN_ENDf_SET(r,f) (r).cmic_cmc_dma_ctrl[0]=(((r).cmic_cmc_dma_ctrl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define CMIC_CMC_DMA_CTRLr_RLD_STS_UPD_DISf_GET(r) ((((r).cmic_cmc_dma_ctrl[0]) >> 7) & 0x1)
#define CMIC_CMC_DMA_CTRLr_RLD_STS_UPD_DISf_SET(r,f) (r).cmic_cmc_dma_ctrl[0]=(((r).cmic_cmc_dma_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access CMIC_CMC_DMA_CTRL.
 *
 */
#define READ_CMIC_CMC_DMA_CTRLr(u,i,r) CDK_XGSM_CMC_READ(u,CMIC_CMC_DMA_CTRLr+(4*(i)),r._cmic_cmc_dma_ctrl)
#define WRITE_CMIC_CMC_DMA_CTRLr(u,i,r) CDK_XGSM_CMC_WRITE(u,CMIC_CMC_DMA_CTRLr+(4*(i)),r._cmic_cmc_dma_ctrl)

/*******************************************************************************
 * End of 'CMIC_CMC_DMA_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * REGISTER:  CMIC_CMC_DMA_DESC
 * BLOCKS:   CMIC
 * DESC:     DMA Channel 0 Descriptor Address
 * SIZE:     32
 * FIELDS:
 *     ADDR             DMA CH0 DESCRIPTOR ADDRESS REGISTER
 *
 ******************************************************************************/
#define CMIC_CMC_DMA_DESCr 0x00031158

#define CMIC_CMC_DMA_DESCr_ENUM 3
#define CMIC_CMC_DMA_DESCr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_DMA_DESC.
 *
 */
typedef union CMIC_CMC_DMA_DESCr_s {
	uint32_t v[1];
	uint32_t cmic_cmc_dma_desc[1];
	uint32_t _cmic_cmc_dma_desc;
} CMIC_CMC_DMA_DESCr_t;

#define CMIC_CMC_DMA_DESCr_CLR(r) (r).cmic_cmc_dma_desc[0] = 0
#define CMIC_CMC_DMA_DESCr_SET(r,d) (r).cmic_cmc_dma_desc[0] = d
#define CMIC_CMC_DMA_DESCr_GET(r) (r).cmic_cmc_dma_desc[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define CMIC_CMC_DMA_DESCr_ADDRf_GET(r) ((r).cmic_cmc_dma_desc[0])
#define CMIC_CMC_DMA_DESCr_ADDRf_SET(r,f) (r).cmic_cmc_dma_desc[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_CMC_DMA_DESC.
 *
 */
#define READ_CMIC_CMC_DMA_DESCr(u,i,r) CDK_XGSM_CMC_READ(u,CMIC_CMC_DMA_DESCr+(4*(i)),r._cmic_cmc_dma_desc)
#define WRITE_CMIC_CMC_DMA_DESCr(u,i,r) CDK_XGSM_CMC_WRITE(u,CMIC_CMC_DMA_DESCr+(4*(i)),r._cmic_cmc_dma_desc)

/*******************************************************************************
 * End of 'CMIC_CMC_DMA_DESCr'
 ******************************************************************************/




/*******************************************************************************
 * REGISTER:  CMIC_CMC_DMA_STAT
 * BLOCKS:   CMIC
 * DESC:     DMA Status and Control Register
 * SIZE:     32
 * FIELDS:
 *     CHAIN_DONE       
 *     CH0_CHAIN_DONE   Set by CMIC indicating DMA Completion 
 *     CH1_CHAIN_DONE   Set by CMIC indicating DMA Completion 
 *     CH2_CHAIN_DONE   Set by CMIC indicating DMA Completion 
 *     CH3_CHAIN_DONE   Set by CMIC indicating DMA Completion 
 *     DESC_DONE        
 *     CH0_DESC_DONE    Set by CMIC indicating Current DMA DES Completion 
 *     CH1_DESC_DONE    Set by CMIC indicating Current DMA DES Completion 
 *     CH2_DESC_DONE    Set by CMIC indicating Current DMA DES Completion 
 *     CH3_DESC_DONE    Set by CMIC indicating Current DMA DES Completion 
 *     DMA_ACTIVE       
 *     CH0_DMA_ACTIVE   Set by CMIC to indicate DMA channel is Active
 *     CH1_DMA_ACTIVE   Set by CMIC to indicate DMA channel is Active
 *     CH2_DMA_ACTIVE   Set by CMIC to indicate DMA channel is Active
 *     CH3_DMA_ACTIVE   Set by CMIC to indicate DMA channel is Active
 *     STWT_ADDR_DECODE_ERR 
 *     CH0_STWT_ADDR_DECODE_ERR Set by CMIC to indicate STATUS WRITE access happend to a address not defined in CMICM memory Map. This can be cleared by resetting ENABLE bit. 
 *     CH1_STWT_ADDR_DECODE_ERR Set by CMIC to indicate STATUS WRITE access happend to a address not defined in CMICM memory Map. This can be cleared by resetting ENABLE bit. 
 *     CH2_STWT_ADDR_DECODE_ERR Set by CMIC to indicate STATUS WRITE access happend to a address not defined in CMICM memory Map. This can be cleared by resetting ENABLE bit. 
 *     CH3_STWT_ADDR_DECODE_ERR Set by CMIC to indicate STATUS WRITE access happend to a address not defined in CMICM memory Map. This can be cleared by resetting ENABLE bit. 
 *     PKTWRRD_ADDR_DECODE_ERR 
 *     CH0_PKTWRRD_ADDR_DECODE_ERR Set by CMIC to indicate PACKET WRITE/READ access happend to a address not defined in CMICM memory Map. This can be cleared by resetting ENABLE bit. 
 *     CH1_PKTWRRD_ADDR_DECODE_ERR Set by CMIC to indicate PACKET WRITE/READ access happend to a address not defined in CMICM memory Map. This can be cleared by resetting ENABLE bit. 
 *     CH2_PKTWRRD_ADDR_DECODE_ERR Set by CMIC to indicate PACKET WRITE/READ access happend to a address not defined in CMICM memory Map. This can be cleared by resetting ENABLE bit. 
 *     CH3_PKTWRRD_ADDR_DECODE_ERR Set by CMIC to indicate PACKET WRITE/READ access happend to a address not defined in CMICM memory Map. This can be cleared by resetting ENABLE bit. 
 *     DESCRD_ADDR_DECODE_ERR 
 *     CH0_DESCRD_ADDR_DECODE_ERR Set by CMIC to indicate DESCRIPTOR READ access happend to a address not defined in CMICM memory Map. This can be cleared by resetting ENABLE bit. 
 *     CH1_DESCRD_ADDR_DECODE_ERR Set by CMIC to indicate DESCRIPTOR READ access happend to a address not defined in CMICM memory Map. This can be cleared by resetting ENABLE bit. 
 *     CH2_DESCRD_ADDR_DECODE_ERR Set by CMIC to indicate DESCRIPTOR READ access happend to a address not defined in CMICM memory Map. This can be cleared by resetting ENABLE bit. 
 *     CH3_DESCRD_ADDR_DECODE_ERR Set by CMIC to indicate DESCRIPTOR READ access happend to a address not defined in CMICM memory Map. This can be cleared by resetting ENABLE bit. 
 *     STWR_ECC_ERR     
 *     CH0_STWR_ECC_ERR Set by CMIC to indicate ECC error found while reading status buffer. This can be cleared by resetting ENABLE bit. 
 *     CH1_STWR_ECC_ERR Set by CMIC to indicate ECC error found while reading status buffer. This can be cleared by resetting ENABLE bit. 
 *     CH2_STWR_ECC_ERR Set by CMIC to indicate ECC error found while reading status buffer. This can be cleared by resetting ENABLE bit. 
 *     CH3_STWR_ECC_ERR Set by CMIC to indicate ECC error found while reading status buffer. This can be cleared by resetting ENABLE bit. 
 *     PKTWR_ECC_ERR    
 *     CH0_PKTWR_ECC_ERR Set by CMIC to indicate ECC error found while reading Rx Packet buffer. This can be cleared by resetting ENABLE bit. 
 *     CH1_PKTWR_ECC_ERR Set by CMIC to indicate ECC error found while reading Rx Packet buffer. This can be cleared by resetting ENABLE bit. 
 *     CH2_PKTWR_ECC_ERR Set by CMIC to indicate ECC error found while reading Rx Packet buffer. This can be cleared by resetting ENABLE bit. 
 *     CH3_PKTWR_ECC_ERR Set by CMIC to indicate ECC error found while reading Rx Packet buffer. This can be cleared by resetting ENABLE bit. 
 *
 ******************************************************************************/
#define CMIC_CMC_DMA_STATr 0x00031150

#define CMIC_CMC_DMA_STATr_ENUM 4
#define CMIC_CMC_DMA_STATr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_DMA_STAT.
 *
 */
typedef union CMIC_CMC_DMA_STATr_s {
	uint32_t v[1];
	uint32_t cmic_cmc_dma_stat[1];
	uint32_t _cmic_cmc_dma_stat;
} CMIC_CMC_DMA_STATr_t;

#define CMIC_CMC_DMA_STATr_CLR(r) (r).cmic_cmc_dma_stat[0] = 0
#define CMIC_CMC_DMA_STATr_SET(r,d) (r).cmic_cmc_dma_stat[0] = d
#define CMIC_CMC_DMA_STATr_GET(r) (r).cmic_cmc_dma_stat[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define CMIC_CMC_DMA_STATr_CHAIN_DONEf_GET(r) (((r).cmic_cmc_dma_stat[0]) & 0xf)
#define CMIC_CMC_DMA_STATr_CHAIN_DONEf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define CMIC_CMC_DMA_STATr_CH0_CHAIN_DONEf_GET(r) (((r).cmic_cmc_dma_stat[0]) & 0x1)
#define CMIC_CMC_DMA_STATr_CH0_CHAIN_DONEf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CMIC_CMC_DMA_STATr_CH1_CHAIN_DONEf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 1) & 0x1)
#define CMIC_CMC_DMA_STATr_CH1_CHAIN_DONEf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CMIC_CMC_DMA_STATr_CH2_CHAIN_DONEf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 2) & 0x1)
#define CMIC_CMC_DMA_STATr_CH2_CHAIN_DONEf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define CMIC_CMC_DMA_STATr_CH3_CHAIN_DONEf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 3) & 0x1)
#define CMIC_CMC_DMA_STATr_CH3_CHAIN_DONEf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define CMIC_CMC_DMA_STATr_DESC_DONEf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 4) & 0xf)
#define CMIC_CMC_DMA_STATr_DESC_DONEf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define CMIC_CMC_DMA_STATr_CH0_DESC_DONEf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 4) & 0x1)
#define CMIC_CMC_DMA_STATr_CH0_DESC_DONEf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define CMIC_CMC_DMA_STATr_CH1_DESC_DONEf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 5) & 0x1)
#define CMIC_CMC_DMA_STATr_CH1_DESC_DONEf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define CMIC_CMC_DMA_STATr_CH2_DESC_DONEf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 6) & 0x1)
#define CMIC_CMC_DMA_STATr_CH2_DESC_DONEf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define CMIC_CMC_DMA_STATr_CH3_DESC_DONEf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 7) & 0x1)
#define CMIC_CMC_DMA_STATr_CH3_DESC_DONEf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define CMIC_CMC_DMA_STATr_DMA_ACTIVEf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 8) & 0xf)
#define CMIC_CMC_DMA_STATr_DMA_ACTIVEf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define CMIC_CMC_DMA_STATr_CH0_DMA_ACTIVEf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 8) & 0x1)
#define CMIC_CMC_DMA_STATr_CH0_DMA_ACTIVEf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define CMIC_CMC_DMA_STATr_CH1_DMA_ACTIVEf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 9) & 0x1)
#define CMIC_CMC_DMA_STATr_CH1_DMA_ACTIVEf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define CMIC_CMC_DMA_STATr_CH2_DMA_ACTIVEf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 10) & 0x1)
#define CMIC_CMC_DMA_STATr_CH2_DMA_ACTIVEf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define CMIC_CMC_DMA_STATr_CH3_DMA_ACTIVEf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 11) & 0x1)
#define CMIC_CMC_DMA_STATr_CH3_DMA_ACTIVEf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define CMIC_CMC_DMA_STATr_STWT_ADDR_DECODE_ERRf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 12) & 0xf)
#define CMIC_CMC_DMA_STATr_STWT_ADDR_DECODE_ERRf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define CMIC_CMC_DMA_STATr_CH0_STWT_ADDR_DECODE_ERRf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 12) & 0x1)
#define CMIC_CMC_DMA_STATr_CH0_STWT_ADDR_DECODE_ERRf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define CMIC_CMC_DMA_STATr_CH1_STWT_ADDR_DECODE_ERRf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 13) & 0x1)
#define CMIC_CMC_DMA_STATr_CH1_STWT_ADDR_DECODE_ERRf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define CMIC_CMC_DMA_STATr_CH2_STWT_ADDR_DECODE_ERRf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 14) & 0x1)
#define CMIC_CMC_DMA_STATr_CH2_STWT_ADDR_DECODE_ERRf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define CMIC_CMC_DMA_STATr_CH3_STWT_ADDR_DECODE_ERRf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 15) & 0x1)
#define CMIC_CMC_DMA_STATr_CH3_STWT_ADDR_DECODE_ERRf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define CMIC_CMC_DMA_STATr_PKTWRRD_ADDR_DECODE_ERRf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 16) & 0xf)
#define CMIC_CMC_DMA_STATr_PKTWRRD_ADDR_DECODE_ERRf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define CMIC_CMC_DMA_STATr_CH0_PKTWRRD_ADDR_DECODE_ERRf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 16) & 0x1)
#define CMIC_CMC_DMA_STATr_CH0_PKTWRRD_ADDR_DECODE_ERRf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define CMIC_CMC_DMA_STATr_CH1_PKTWRRD_ADDR_DECODE_ERRf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 17) & 0x1)
#define CMIC_CMC_DMA_STATr_CH1_PKTWRRD_ADDR_DECODE_ERRf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define CMIC_CMC_DMA_STATr_CH2_PKTWRRD_ADDR_DECODE_ERRf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 18) & 0x1)
#define CMIC_CMC_DMA_STATr_CH2_PKTWRRD_ADDR_DECODE_ERRf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define CMIC_CMC_DMA_STATr_CH3_PKTWRRD_ADDR_DECODE_ERRf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 19) & 0x1)
#define CMIC_CMC_DMA_STATr_CH3_PKTWRRD_ADDR_DECODE_ERRf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define CMIC_CMC_DMA_STATr_DESCRD_ADDR_DECODE_ERRf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 20) & 0xf)
#define CMIC_CMC_DMA_STATr_DESCRD_ADDR_DECODE_ERRf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define CMIC_CMC_DMA_STATr_CH0_DESCRD_ADDR_DECODE_ERRf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 20) & 0x1)
#define CMIC_CMC_DMA_STATr_CH0_DESCRD_ADDR_DECODE_ERRf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define CMIC_CMC_DMA_STATr_CH1_DESCRD_ADDR_DECODE_ERRf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 21) & 0x1)
#define CMIC_CMC_DMA_STATr_CH1_DESCRD_ADDR_DECODE_ERRf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define CMIC_CMC_DMA_STATr_CH2_DESCRD_ADDR_DECODE_ERRf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 22) & 0x1)
#define CMIC_CMC_DMA_STATr_CH2_DESCRD_ADDR_DECODE_ERRf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define CMIC_CMC_DMA_STATr_CH3_DESCRD_ADDR_DECODE_ERRf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 23) & 0x1)
#define CMIC_CMC_DMA_STATr_CH3_DESCRD_ADDR_DECODE_ERRf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define CMIC_CMC_DMA_STATr_STWR_ECC_ERRf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 24) & 0xf)
#define CMIC_CMC_DMA_STATr_STWR_ECC_ERRf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define CMIC_CMC_DMA_STATr_CH0_STWR_ECC_ERRf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 24) & 0x1)
#define CMIC_CMC_DMA_STATr_CH0_STWR_ECC_ERRf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define CMIC_CMC_DMA_STATr_CH1_STWR_ECC_ERRf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 25) & 0x1)
#define CMIC_CMC_DMA_STATr_CH1_STWR_ECC_ERRf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define CMIC_CMC_DMA_STATr_CH2_STWR_ECC_ERRf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 26) & 0x1)
#define CMIC_CMC_DMA_STATr_CH2_STWR_ECC_ERRf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define CMIC_CMC_DMA_STATr_CH3_STWR_ECC_ERRf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 27) & 0x1)
#define CMIC_CMC_DMA_STATr_CH3_STWR_ECC_ERRf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define CMIC_CMC_DMA_STATr_PKTWR_ECC_ERRf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 28) & 0xf)
#define CMIC_CMC_DMA_STATr_PKTWR_ECC_ERRf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))
#define CMIC_CMC_DMA_STATr_CH0_PKTWR_ECC_ERRf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 28) & 0x1)
#define CMIC_CMC_DMA_STATr_CH0_PKTWR_ECC_ERRf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define CMIC_CMC_DMA_STATr_CH1_PKTWR_ECC_ERRf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 29) & 0x1)
#define CMIC_CMC_DMA_STATr_CH1_PKTWR_ECC_ERRf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define CMIC_CMC_DMA_STATr_CH2_PKTWR_ECC_ERRf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 30) & 0x1)
#define CMIC_CMC_DMA_STATr_CH2_PKTWR_ECC_ERRf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define CMIC_CMC_DMA_STATr_CH3_PKTWR_ECC_ERRf_GET(r) ((((r).cmic_cmc_dma_stat[0]) >> 31) & 0x1)
#define CMIC_CMC_DMA_STATr_CH3_PKTWR_ECC_ERRf_SET(r,f) (r).cmic_cmc_dma_stat[0]=(((r).cmic_cmc_dma_stat[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access CMIC_CMC_DMA_STAT.
 *
 */
#define READ_CMIC_CMC_DMA_STATr(u,r) CDK_XGSM_CMC_READ(u,CMIC_CMC_DMA_STATr,r._cmic_cmc_dma_stat)
#define WRITE_CMIC_CMC_DMA_STATr(u,r) CDK_XGSM_CMC_WRITE(u,CMIC_CMC_DMA_STATr,r._cmic_cmc_dma_stat)

/*******************************************************************************
 * End of 'CMIC_CMC_DMA_STATr'
 ******************************************************************************/




/*******************************************************************************
 * REGISTER:  CMIC_CMC_DMA_STAT_CLR
 * BLOCKS:   CMIC
 * DESC:     Desc read complete information in CMIC_CMC_DMA_STAT can be cleared using this register.


 * SIZE:     32
 * FIELDS:
 *     DESCRD_CMPLT_CLR 
 *     CH0_DESCRD_CMPLT_CLR Write 0x1 to cleat descrd_cmplt in DMA_STAT register.
 *     CH1_DESCRD_CMPLT_CLR Write 0x2 to cleat descrd_cmplt in DMA_STAT register.
 *     CH2_DESCRD_CMPLT_CLR Write 0x4 to cleat descrd_cmplt in DMA_STAT register.
 *     CH3_DESCRD_CMPLT_CLR Write 0x8 to cleat descrd_cmplt in DMA_STAT register.
 *     INTR_COALESCING_CLR 
 *     CH0_INTR_COALESCING_CLR Write 0x10 to clear ch0 intr_coalescing.
 *     CH1_INTR_COALESCING_CLR Write 0x20 to clear ch1 intr_coalescing.
 *     CH2_INTR_COALESCING_CLR Write 0x40 to clear ch2 intr_coalescing.
 *     CH3_INTR_COALESCING_CLR Write 0x80 to clear ch3 intr_coalescing.
 *
 ******************************************************************************/
#define CMIC_CMC_DMA_STAT_CLRr 0x000311a4

#define CMIC_CMC_DMA_STAT_CLRr_ENUM 5
#define CMIC_CMC_DMA_STAT_CLRr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_DMA_STAT_CLR.
 *
 */
typedef union CMIC_CMC_DMA_STAT_CLRr_s {
	uint32_t v[1];
	uint32_t cmic_cmc_dma_stat_clr[1];
	uint32_t _cmic_cmc_dma_stat_clr;
} CMIC_CMC_DMA_STAT_CLRr_t;

#define CMIC_CMC_DMA_STAT_CLRr_CLR(r) (r).cmic_cmc_dma_stat_clr[0] = 0
#define CMIC_CMC_DMA_STAT_CLRr_SET(r,d) (r).cmic_cmc_dma_stat_clr[0] = d
#define CMIC_CMC_DMA_STAT_CLRr_GET(r) (r).cmic_cmc_dma_stat_clr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define CMIC_CMC_DMA_STAT_CLRr_DESCRD_CMPLT_CLRf_GET(r) (((r).cmic_cmc_dma_stat_clr[0]) & 0xf)
#define CMIC_CMC_DMA_STAT_CLRr_DESCRD_CMPLT_CLRf_SET(r,f) (r).cmic_cmc_dma_stat_clr[0]=(((r).cmic_cmc_dma_stat_clr[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define CMIC_CMC_DMA_STAT_CLRr_CH0_DESCRD_CMPLT_CLRf_GET(r) (((r).cmic_cmc_dma_stat_clr[0]) & 0x1)
#define CMIC_CMC_DMA_STAT_CLRr_CH0_DESCRD_CMPLT_CLRf_SET(r,f) (r).cmic_cmc_dma_stat_clr[0]=(((r).cmic_cmc_dma_stat_clr[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CMIC_CMC_DMA_STAT_CLRr_CH1_DESCRD_CMPLT_CLRf_GET(r) ((((r).cmic_cmc_dma_stat_clr[0]) >> 1) & 0x1)
#define CMIC_CMC_DMA_STAT_CLRr_CH1_DESCRD_CMPLT_CLRf_SET(r,f) (r).cmic_cmc_dma_stat_clr[0]=(((r).cmic_cmc_dma_stat_clr[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CMIC_CMC_DMA_STAT_CLRr_CH2_DESCRD_CMPLT_CLRf_GET(r) ((((r).cmic_cmc_dma_stat_clr[0]) >> 2) & 0x1)
#define CMIC_CMC_DMA_STAT_CLRr_CH2_DESCRD_CMPLT_CLRf_SET(r,f) (r).cmic_cmc_dma_stat_clr[0]=(((r).cmic_cmc_dma_stat_clr[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define CMIC_CMC_DMA_STAT_CLRr_CH3_DESCRD_CMPLT_CLRf_GET(r) ((((r).cmic_cmc_dma_stat_clr[0]) >> 3) & 0x1)
#define CMIC_CMC_DMA_STAT_CLRr_CH3_DESCRD_CMPLT_CLRf_SET(r,f) (r).cmic_cmc_dma_stat_clr[0]=(((r).cmic_cmc_dma_stat_clr[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define CMIC_CMC_DMA_STAT_CLRr_INTR_COALESCING_CLRf_GET(r) ((((r).cmic_cmc_dma_stat_clr[0]) >> 4) & 0xf)
#define CMIC_CMC_DMA_STAT_CLRr_INTR_COALESCING_CLRf_SET(r,f) (r).cmic_cmc_dma_stat_clr[0]=(((r).cmic_cmc_dma_stat_clr[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define CMIC_CMC_DMA_STAT_CLRr_CH0_INTR_COALESCING_CLRf_GET(r) ((((r).cmic_cmc_dma_stat_clr[0]) >> 4) & 0x1)
#define CMIC_CMC_DMA_STAT_CLRr_CH0_INTR_COALESCING_CLRf_SET(r,f) (r).cmic_cmc_dma_stat_clr[0]=(((r).cmic_cmc_dma_stat_clr[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define CMIC_CMC_DMA_STAT_CLRr_CH1_INTR_COALESCING_CLRf_GET(r) ((((r).cmic_cmc_dma_stat_clr[0]) >> 5) & 0x1)
#define CMIC_CMC_DMA_STAT_CLRr_CH1_INTR_COALESCING_CLRf_SET(r,f) (r).cmic_cmc_dma_stat_clr[0]=(((r).cmic_cmc_dma_stat_clr[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define CMIC_CMC_DMA_STAT_CLRr_CH2_INTR_COALESCING_CLRf_GET(r) ((((r).cmic_cmc_dma_stat_clr[0]) >> 6) & 0x1)
#define CMIC_CMC_DMA_STAT_CLRr_CH2_INTR_COALESCING_CLRf_SET(r,f) (r).cmic_cmc_dma_stat_clr[0]=(((r).cmic_cmc_dma_stat_clr[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define CMIC_CMC_DMA_STAT_CLRr_CH3_INTR_COALESCING_CLRf_GET(r) ((((r).cmic_cmc_dma_stat_clr[0]) >> 7) & 0x1)
#define CMIC_CMC_DMA_STAT_CLRr_CH3_INTR_COALESCING_CLRf_SET(r,f) (r).cmic_cmc_dma_stat_clr[0]=(((r).cmic_cmc_dma_stat_clr[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access CMIC_CMC_DMA_STAT_CLR.
 *
 */
#define READ_CMIC_CMC_DMA_STAT_CLRr(u,r) CDK_XGSM_CMC_READ(u,CMIC_CMC_DMA_STAT_CLRr,r._cmic_cmc_dma_stat_clr)
#define WRITE_CMIC_CMC_DMA_STAT_CLRr(u,r) CDK_XGSM_CMC_WRITE(u,CMIC_CMC_DMA_STAT_CLRr,r._cmic_cmc_dma_stat_clr)

/*******************************************************************************
 * End of 'CMIC_CMC_DMA_STAT_CLRr'
 ******************************************************************************/




/*******************************************************************************
 * REGISTER:  CMIC_CMC_IRQ_STAT0
 * BLOCKS:   CMIC
 * DESC:     Capturs CMC specific funtions status.
 * SIZE:     32
 * FIELDS:
 *     SBUSDMA_CH1_DONE Set if Slam DMA is complete. Clear  DONE CMIC_CMC_SLAM_DMA_STAT register to clear the interrupt
 *     SBUSDMA_CH0_DONE Set if Table DMA is complete. Clear  DONE CMIC_CMC_TABLE_DMA_STAT register to clear the interrupt
 *     FIFO_CH3_DMA_INTR Set if TIMEOUT/overflow happens while FIFO DMA in progress. This can be cleared by resetting both Timeout & Overflow status from FIFO_CH3_RD_DMA_STAT register
 *     FIFO_CH2_DMA_INTR Set if TIMEOUT/overflow happens while FIFO DMA in progress. This can be cleared by resetting both Timeout & Overflow status from FIFO_CH2_RD_DMA_STAT register
 *     FIFO_CH1_DMA_INTR Set if TIMEOUT/overflow happens while FIFO DMA in progress. This can be cleared by resetting both Timeout & Overflow status from FIFO_CH1_RD_DMA_STAT register
 *     FIFO_CH0_DMA_INTR Set if TIMEOUT/overflow happens while FIFO DMA in progress. This can be cleared by resetting both Timeout & Overflow status from FIFO_CH0_RD_DMA_STAT register
 *     SBUSDMA_CH2_DONE Set if SBUSDMA CH2 operation is complete. Clear SBUSDMA CH2 enable bit to clear this interrpt. 
 *     MIIM_OP_DONE     Set if CMIC_CMC0_MIIM_STAT.MIIM_OP_DONE is set, Clear MIIM_STAT.MIIM_OP_DONE to clear the interrupt.. 
 *     CH3_DESC_DONE    Set/clear of DMA_STAT.CH3_DESC_DONE will set/clear this interrupt. 
 *     CH3_CHAIN_DONE   Set/clear of DMA_STAT.CH3_CHAIN_DONE will set/clear this interrupt. 
 *     CH2_DESC_DONE    Set/clear of DMA_STAT.CH2_DESC_DONE will set/clear this interrupt. 
 *     CH2_CHAIN_DONE   Set/clear of DMA_STAT.CH2_CHAIN_DONE will set/clear this interrupt. 
 *     CH1_DESC_DONE    Set/clear of DMA_STAT.CH1_DESC_DONE will set/clear this interrupt. 
 *     CH1_CHAIN_DONE   Set/clear of DMA_STAT.CH1_CHAIN_DONE will set/clear this interrupt. 
 *     CH0_DESC_DONE    Set/clear of DMA_STAT.CH0_DESC_DONE will set/clear this interrupt. 
 *     CH0_CHAIN_DONE   Set/clear of DMA_STAT.CH0_CHAIN_DONE will set/clear this interrupt. 
 *     CH3_INTR_COALESCING_INTR Set by CH3  interrupt coalescing logic and cleared by setting CH3_INTR_COALESCING_CLR. 
 *     CH2_INTR_COALESCING_INTR Set by CH2  interrupt coalescing logic and cleared by setting CH2_INTR_COALESCING_CLR. 
 *     CH1_INTR_COALESCING_INTR Set by CH1  interrupt coalescing logic and cleared by setting CH1_INTR_COALESCING_CLR. 
 *     CH0_INTR_COALESCING_INTR Set by CH0  interrupt coalescing logic and cleared by setting CH0_INTR_COALESCING_CLR. 
 *     SCHAN_OP_DONE    Set/reset CMIC_SCHAN_CTRL.DONE will set/clear this interrupt.. 
 *     CROSS_COUPLED_MEMORYDMA_DONE Set/reset CROSS_COUPLED_MEMORYDMA_DONE will set/clear this interrupt.. 
 *     SW_INTR          SW interrupt.
 *     SBUSDMA_ECCERR   ECC error detected in one or more sbusdma channels/fifo dma channels/ccm dma channels. S/W should read CMIC_CMC0_2BIT_ECC_ERROR_STATUS register
 *
 ******************************************************************************/
#define CMIC_CMC_IRQ_STAT0r 0x00031400

#define CMIC_CMC_IRQ_STAT0r_ENUM 6
#define CMIC_CMC_IRQ_STAT0r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_IRQ_STAT0.
 *
 */
typedef union CMIC_CMC_IRQ_STAT0r_s {
	uint32_t v[1];
	uint32_t cmic_cmc_irq_stat0[1];
	uint32_t _cmic_cmc_irq_stat0;
} CMIC_CMC_IRQ_STAT0r_t;

#define CMIC_CMC_IRQ_STAT0r_CLR(r) (r).cmic_cmc_irq_stat0[0] = 0
#define CMIC_CMC_IRQ_STAT0r_SET(r,d) (r).cmic_cmc_irq_stat0[0] = d
#define CMIC_CMC_IRQ_STAT0r_GET(r) (r).cmic_cmc_irq_stat0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define CMIC_CMC_IRQ_STAT0r_SBUSDMA_CH1_DONEf_GET(r) (((r).cmic_cmc_irq_stat0[0]) & 0x1)
#define CMIC_CMC_IRQ_STAT0r_SBUSDMA_CH1_DONEf_SET(r,f) (r).cmic_cmc_irq_stat0[0]=(((r).cmic_cmc_irq_stat0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CMIC_CMC_IRQ_STAT0r_SBUSDMA_CH0_DONEf_GET(r) ((((r).cmic_cmc_irq_stat0[0]) >> 1) & 0x1)
#define CMIC_CMC_IRQ_STAT0r_SBUSDMA_CH0_DONEf_SET(r,f) (r).cmic_cmc_irq_stat0[0]=(((r).cmic_cmc_irq_stat0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CMIC_CMC_IRQ_STAT0r_FIFO_CH3_DMA_INTRf_GET(r) ((((r).cmic_cmc_irq_stat0[0]) >> 2) & 0x1)
#define CMIC_CMC_IRQ_STAT0r_FIFO_CH3_DMA_INTRf_SET(r,f) (r).cmic_cmc_irq_stat0[0]=(((r).cmic_cmc_irq_stat0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define CMIC_CMC_IRQ_STAT0r_FIFO_CH2_DMA_INTRf_GET(r) ((((r).cmic_cmc_irq_stat0[0]) >> 3) & 0x1)
#define CMIC_CMC_IRQ_STAT0r_FIFO_CH2_DMA_INTRf_SET(r,f) (r).cmic_cmc_irq_stat0[0]=(((r).cmic_cmc_irq_stat0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define CMIC_CMC_IRQ_STAT0r_FIFO_CH1_DMA_INTRf_GET(r) ((((r).cmic_cmc_irq_stat0[0]) >> 4) & 0x1)
#define CMIC_CMC_IRQ_STAT0r_FIFO_CH1_DMA_INTRf_SET(r,f) (r).cmic_cmc_irq_stat0[0]=(((r).cmic_cmc_irq_stat0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define CMIC_CMC_IRQ_STAT0r_FIFO_CH0_DMA_INTRf_GET(r) ((((r).cmic_cmc_irq_stat0[0]) >> 5) & 0x1)
#define CMIC_CMC_IRQ_STAT0r_FIFO_CH0_DMA_INTRf_SET(r,f) (r).cmic_cmc_irq_stat0[0]=(((r).cmic_cmc_irq_stat0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define CMIC_CMC_IRQ_STAT0r_SBUSDMA_CH2_DONEf_GET(r) ((((r).cmic_cmc_irq_stat0[0]) >> 6) & 0x1)
#define CMIC_CMC_IRQ_STAT0r_SBUSDMA_CH2_DONEf_SET(r,f) (r).cmic_cmc_irq_stat0[0]=(((r).cmic_cmc_irq_stat0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define CMIC_CMC_IRQ_STAT0r_MIIM_OP_DONEf_GET(r) ((((r).cmic_cmc_irq_stat0[0]) >> 7) & 0x1)
#define CMIC_CMC_IRQ_STAT0r_MIIM_OP_DONEf_SET(r,f) (r).cmic_cmc_irq_stat0[0]=(((r).cmic_cmc_irq_stat0[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define CMIC_CMC_IRQ_STAT0r_CH3_DESC_DONEf_GET(r) ((((r).cmic_cmc_irq_stat0[0]) >> 8) & 0x1)
#define CMIC_CMC_IRQ_STAT0r_CH3_DESC_DONEf_SET(r,f) (r).cmic_cmc_irq_stat0[0]=(((r).cmic_cmc_irq_stat0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define CMIC_CMC_IRQ_STAT0r_CH3_CHAIN_DONEf_GET(r) ((((r).cmic_cmc_irq_stat0[0]) >> 9) & 0x1)
#define CMIC_CMC_IRQ_STAT0r_CH3_CHAIN_DONEf_SET(r,f) (r).cmic_cmc_irq_stat0[0]=(((r).cmic_cmc_irq_stat0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define CMIC_CMC_IRQ_STAT0r_CH2_DESC_DONEf_GET(r) ((((r).cmic_cmc_irq_stat0[0]) >> 10) & 0x1)
#define CMIC_CMC_IRQ_STAT0r_CH2_DESC_DONEf_SET(r,f) (r).cmic_cmc_irq_stat0[0]=(((r).cmic_cmc_irq_stat0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define CMIC_CMC_IRQ_STAT0r_CH2_CHAIN_DONEf_GET(r) ((((r).cmic_cmc_irq_stat0[0]) >> 11) & 0x1)
#define CMIC_CMC_IRQ_STAT0r_CH2_CHAIN_DONEf_SET(r,f) (r).cmic_cmc_irq_stat0[0]=(((r).cmic_cmc_irq_stat0[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define CMIC_CMC_IRQ_STAT0r_CH1_DESC_DONEf_GET(r) ((((r).cmic_cmc_irq_stat0[0]) >> 12) & 0x1)
#define CMIC_CMC_IRQ_STAT0r_CH1_DESC_DONEf_SET(r,f) (r).cmic_cmc_irq_stat0[0]=(((r).cmic_cmc_irq_stat0[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define CMIC_CMC_IRQ_STAT0r_CH1_CHAIN_DONEf_GET(r) ((((r).cmic_cmc_irq_stat0[0]) >> 13) & 0x1)
#define CMIC_CMC_IRQ_STAT0r_CH1_CHAIN_DONEf_SET(r,f) (r).cmic_cmc_irq_stat0[0]=(((r).cmic_cmc_irq_stat0[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define CMIC_CMC_IRQ_STAT0r_CH0_DESC_DONEf_GET(r) ((((r).cmic_cmc_irq_stat0[0]) >> 14) & 0x1)
#define CMIC_CMC_IRQ_STAT0r_CH0_DESC_DONEf_SET(r,f) (r).cmic_cmc_irq_stat0[0]=(((r).cmic_cmc_irq_stat0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define CMIC_CMC_IRQ_STAT0r_CH0_CHAIN_DONEf_GET(r) ((((r).cmic_cmc_irq_stat0[0]) >> 15) & 0x1)
#define CMIC_CMC_IRQ_STAT0r_CH0_CHAIN_DONEf_SET(r,f) (r).cmic_cmc_irq_stat0[0]=(((r).cmic_cmc_irq_stat0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define CMIC_CMC_IRQ_STAT0r_CH3_INTR_COALESCING_INTRf_GET(r) ((((r).cmic_cmc_irq_stat0[0]) >> 16) & 0x1)
#define CMIC_CMC_IRQ_STAT0r_CH3_INTR_COALESCING_INTRf_SET(r,f) (r).cmic_cmc_irq_stat0[0]=(((r).cmic_cmc_irq_stat0[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define CMIC_CMC_IRQ_STAT0r_CH2_INTR_COALESCING_INTRf_GET(r) ((((r).cmic_cmc_irq_stat0[0]) >> 17) & 0x1)
#define CMIC_CMC_IRQ_STAT0r_CH2_INTR_COALESCING_INTRf_SET(r,f) (r).cmic_cmc_irq_stat0[0]=(((r).cmic_cmc_irq_stat0[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define CMIC_CMC_IRQ_STAT0r_CH1_INTR_COALESCING_INTRf_GET(r) ((((r).cmic_cmc_irq_stat0[0]) >> 18) & 0x1)
#define CMIC_CMC_IRQ_STAT0r_CH1_INTR_COALESCING_INTRf_SET(r,f) (r).cmic_cmc_irq_stat0[0]=(((r).cmic_cmc_irq_stat0[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define CMIC_CMC_IRQ_STAT0r_CH0_INTR_COALESCING_INTRf_GET(r) ((((r).cmic_cmc_irq_stat0[0]) >> 19) & 0x1)
#define CMIC_CMC_IRQ_STAT0r_CH0_INTR_COALESCING_INTRf_SET(r,f) (r).cmic_cmc_irq_stat0[0]=(((r).cmic_cmc_irq_stat0[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define CMIC_CMC_IRQ_STAT0r_SCHAN_OP_DONEf_GET(r) ((((r).cmic_cmc_irq_stat0[0]) >> 20) & 0x1)
#define CMIC_CMC_IRQ_STAT0r_SCHAN_OP_DONEf_SET(r,f) (r).cmic_cmc_irq_stat0[0]=(((r).cmic_cmc_irq_stat0[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define CMIC_CMC_IRQ_STAT0r_CROSS_COUPLED_MEMORYDMA_DONEf_GET(r) ((((r).cmic_cmc_irq_stat0[0]) >> 21) & 0x1)
#define CMIC_CMC_IRQ_STAT0r_CROSS_COUPLED_MEMORYDMA_DONEf_SET(r,f) (r).cmic_cmc_irq_stat0[0]=(((r).cmic_cmc_irq_stat0[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define CMIC_CMC_IRQ_STAT0r_SW_INTRf_GET(r) ((((r).cmic_cmc_irq_stat0[0]) >> 22) & 0xf)
#define CMIC_CMC_IRQ_STAT0r_SW_INTRf_SET(r,f) (r).cmic_cmc_irq_stat0[0]=(((r).cmic_cmc_irq_stat0[0] & ~((uint32_t)0xf << 22)) | ((((uint32_t)f) & 0xf) << 22))
#define CMIC_CMC_IRQ_STAT0r_SBUSDMA_ECCERRf_GET(r) ((((r).cmic_cmc_irq_stat0[0]) >> 26) & 0x1)
#define CMIC_CMC_IRQ_STAT0r_SBUSDMA_ECCERRf_SET(r,f) (r).cmic_cmc_irq_stat0[0]=(((r).cmic_cmc_irq_stat0[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))

/*
 * These macros can be used to access CMIC_CMC_IRQ_STAT0.
 *
 */
#define READ_CMIC_CMC_IRQ_STAT0r(u,r) CDK_XGSM_CMC_READ(u,CMIC_CMC_IRQ_STAT0r,r._cmic_cmc_irq_stat0)
#define WRITE_CMIC_CMC_IRQ_STAT0r(u,r) CDK_XGSM_CMC_WRITE(u,CMIC_CMC_IRQ_STAT0r,r._cmic_cmc_irq_stat0)

/*******************************************************************************
 * End of 'CMIC_CMC_IRQ_STAT0r'
 ******************************************************************************/




/*******************************************************************************
 * REGISTER:  CMIC_CMC_IRQ_STAT1
 * BLOCKS:   CMIC
 * DESC:     captures interrupt events from CMICM_COMMON, Switch specific interrupts and uc_0/uc_1 PMUIRQ
 * SIZE:     32
 * FIELDS:
 *     I2C_INTR         Interrupt in CPU contolled I2C master mode. S/W need to clear I2C STATUS register.
 *     PCIE_ECRC_ERR_INTR PCIE_ECRC_ERR interrupt.
 *     TIMESYNC_INTR    timesync interrupt.
 *     PHY_LINKSCAN_LINKSTATUS_CHD Hardware linkscan detetcted a change in link from one of the configured ports.
 *     PHY_PAUSESCAN_PAUSESTATUS_CHD Pause linkscan detetcted a change in pause capability from one of the configured ports.
 *     SPI_INTERRUPT    SPI INTERRUPT.
 *     UART0_INTERRUPT  UART0 INTERRUPT.
 *     UART1_INTERRUPT  UART1 INTERRUPT.
 *     COMMON_SCHAN_DONE SCHAN DONE using schan module in CMIC COMMON. This interrupt can be cleared by resetting CMIC_COMMON_SCHAN_CTRL.DONE
 *     MIIM_OP_DONE     MIIM PHY wr/rd is complete. This interrupt can be cleared by restting CMIC_COMMON.MIIM_EN.
 *     GPIO_INTR        GPIO_INTR.
 *     CHIP_FUNC_INTR   CHIP Functional Interrupts.  CMICM will provide a 8 bit port and chip team can drive interrupt as per chip requirement. Field definition/location should be part of chip_formats.regs as this is not going to be unique accross projects.It is upto the CHIP team to map individual bit as per requirement. 
 *     UC_0_PMUIRQ      Interrupt request from uc_0 Performance Monitor Unit.
 *     UC_1_PMUIRQ      Interrupt request from uc_1 Performance Monitor Unit.
 *     WDT_0_INTR       Interrupt request from WDT_0
 *     WDT_1_INTR       Interrupt request from WDT_1
 *     TIM0_INTR1       TIM0_INTR1.
 *     TIM0_INTR2       TIM0_INTR2.
 *     TIM1_INTR1       TIM1_INTR1.
 *     TIM1_INTR2       TIM1_INTR2.
 *     PCIEINTF_NEEDS_CLEANUP This interupt indicates PCIe link is down and S/W needs to purge any outstanding commands and also S/W should abort all active DMAs that are destined on PCIe Interface.
 *     SRAM_ECC_INTR    SRAM ECC Interrupt. Upon detecting this interrupt, the SW has to read SRAM_#_ECC_ERROR_STATUS to find out ECC error details
 *
 ******************************************************************************/
#define CMIC_CMC_IRQ_STAT1r 0x00031404

#define CMIC_CMC_IRQ_STAT1r_ENUM 7
#define CMIC_CMC_IRQ_STAT1r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_IRQ_STAT1.
 *
 */
typedef union CMIC_CMC_IRQ_STAT1r_s {
	uint32_t v[1];
	uint32_t cmic_cmc_irq_stat1[1];
	uint32_t _cmic_cmc_irq_stat1;
} CMIC_CMC_IRQ_STAT1r_t;

#define CMIC_CMC_IRQ_STAT1r_CLR(r) (r).cmic_cmc_irq_stat1[0] = 0
#define CMIC_CMC_IRQ_STAT1r_SET(r,d) (r).cmic_cmc_irq_stat1[0] = d
#define CMIC_CMC_IRQ_STAT1r_GET(r) (r).cmic_cmc_irq_stat1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define CMIC_CMC_IRQ_STAT1r_I2C_INTRf_GET(r) (((r).cmic_cmc_irq_stat1[0]) & 0x1)
#define CMIC_CMC_IRQ_STAT1r_I2C_INTRf_SET(r,f) (r).cmic_cmc_irq_stat1[0]=(((r).cmic_cmc_irq_stat1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CMIC_CMC_IRQ_STAT1r_PCIE_ECRC_ERR_INTRf_GET(r) ((((r).cmic_cmc_irq_stat1[0]) >> 1) & 0x1)
#define CMIC_CMC_IRQ_STAT1r_PCIE_ECRC_ERR_INTRf_SET(r,f) (r).cmic_cmc_irq_stat1[0]=(((r).cmic_cmc_irq_stat1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CMIC_CMC_IRQ_STAT1r_TIMESYNC_INTRf_GET(r) ((((r).cmic_cmc_irq_stat1[0]) >> 2) & 0x1)
#define CMIC_CMC_IRQ_STAT1r_TIMESYNC_INTRf_SET(r,f) (r).cmic_cmc_irq_stat1[0]=(((r).cmic_cmc_irq_stat1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define CMIC_CMC_IRQ_STAT1r_PHY_LINKSCAN_LINKSTATUS_CHDf_GET(r) ((((r).cmic_cmc_irq_stat1[0]) >> 3) & 0x1)
#define CMIC_CMC_IRQ_STAT1r_PHY_LINKSCAN_LINKSTATUS_CHDf_SET(r,f) (r).cmic_cmc_irq_stat1[0]=(((r).cmic_cmc_irq_stat1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define CMIC_CMC_IRQ_STAT1r_PHY_PAUSESCAN_PAUSESTATUS_CHDf_GET(r) ((((r).cmic_cmc_irq_stat1[0]) >> 4) & 0x1)
#define CMIC_CMC_IRQ_STAT1r_PHY_PAUSESCAN_PAUSESTATUS_CHDf_SET(r,f) (r).cmic_cmc_irq_stat1[0]=(((r).cmic_cmc_irq_stat1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define CMIC_CMC_IRQ_STAT1r_SPI_INTERRUPTf_GET(r) ((((r).cmic_cmc_irq_stat1[0]) >> 5) & 0x1)
#define CMIC_CMC_IRQ_STAT1r_SPI_INTERRUPTf_SET(r,f) (r).cmic_cmc_irq_stat1[0]=(((r).cmic_cmc_irq_stat1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define CMIC_CMC_IRQ_STAT1r_UART0_INTERRUPTf_GET(r) ((((r).cmic_cmc_irq_stat1[0]) >> 6) & 0x1)
#define CMIC_CMC_IRQ_STAT1r_UART0_INTERRUPTf_SET(r,f) (r).cmic_cmc_irq_stat1[0]=(((r).cmic_cmc_irq_stat1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define CMIC_CMC_IRQ_STAT1r_UART1_INTERRUPTf_GET(r) ((((r).cmic_cmc_irq_stat1[0]) >> 7) & 0x1)
#define CMIC_CMC_IRQ_STAT1r_UART1_INTERRUPTf_SET(r,f) (r).cmic_cmc_irq_stat1[0]=(((r).cmic_cmc_irq_stat1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define CMIC_CMC_IRQ_STAT1r_COMMON_SCHAN_DONEf_GET(r) ((((r).cmic_cmc_irq_stat1[0]) >> 8) & 0x1)
#define CMIC_CMC_IRQ_STAT1r_COMMON_SCHAN_DONEf_SET(r,f) (r).cmic_cmc_irq_stat1[0]=(((r).cmic_cmc_irq_stat1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define CMIC_CMC_IRQ_STAT1r_MIIM_OP_DONEf_GET(r) ((((r).cmic_cmc_irq_stat1[0]) >> 9) & 0x1)
#define CMIC_CMC_IRQ_STAT1r_MIIM_OP_DONEf_SET(r,f) (r).cmic_cmc_irq_stat1[0]=(((r).cmic_cmc_irq_stat1[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define CMIC_CMC_IRQ_STAT1r_GPIO_INTRf_GET(r) ((((r).cmic_cmc_irq_stat1[0]) >> 10) & 0x1)
#define CMIC_CMC_IRQ_STAT1r_GPIO_INTRf_SET(r,f) (r).cmic_cmc_irq_stat1[0]=(((r).cmic_cmc_irq_stat1[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define CMIC_CMC_IRQ_STAT1r_CHIP_FUNC_INTRf_GET(r) ((((r).cmic_cmc_irq_stat1[0]) >> 11) & 0xff)
#define CMIC_CMC_IRQ_STAT1r_CHIP_FUNC_INTRf_SET(r,f) (r).cmic_cmc_irq_stat1[0]=(((r).cmic_cmc_irq_stat1[0] & ~((uint32_t)0xff << 11)) | ((((uint32_t)f) & 0xff) << 11))
#define CMIC_CMC_IRQ_STAT1r_UC_0_PMUIRQf_GET(r) ((((r).cmic_cmc_irq_stat1[0]) >> 19) & 0x1)
#define CMIC_CMC_IRQ_STAT1r_UC_0_PMUIRQf_SET(r,f) (r).cmic_cmc_irq_stat1[0]=(((r).cmic_cmc_irq_stat1[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define CMIC_CMC_IRQ_STAT1r_UC_1_PMUIRQf_GET(r) ((((r).cmic_cmc_irq_stat1[0]) >> 20) & 0x1)
#define CMIC_CMC_IRQ_STAT1r_UC_1_PMUIRQf_SET(r,f) (r).cmic_cmc_irq_stat1[0]=(((r).cmic_cmc_irq_stat1[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define CMIC_CMC_IRQ_STAT1r_WDT_0_INTRf_GET(r) ((((r).cmic_cmc_irq_stat1[0]) >> 21) & 0x1)
#define CMIC_CMC_IRQ_STAT1r_WDT_0_INTRf_SET(r,f) (r).cmic_cmc_irq_stat1[0]=(((r).cmic_cmc_irq_stat1[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define CMIC_CMC_IRQ_STAT1r_WDT_1_INTRf_GET(r) ((((r).cmic_cmc_irq_stat1[0]) >> 22) & 0x1)
#define CMIC_CMC_IRQ_STAT1r_WDT_1_INTRf_SET(r,f) (r).cmic_cmc_irq_stat1[0]=(((r).cmic_cmc_irq_stat1[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define CMIC_CMC_IRQ_STAT1r_TIM0_INTR1f_GET(r) ((((r).cmic_cmc_irq_stat1[0]) >> 23) & 0x1)
#define CMIC_CMC_IRQ_STAT1r_TIM0_INTR1f_SET(r,f) (r).cmic_cmc_irq_stat1[0]=(((r).cmic_cmc_irq_stat1[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define CMIC_CMC_IRQ_STAT1r_TIM0_INTR2f_GET(r) ((((r).cmic_cmc_irq_stat1[0]) >> 24) & 0x1)
#define CMIC_CMC_IRQ_STAT1r_TIM0_INTR2f_SET(r,f) (r).cmic_cmc_irq_stat1[0]=(((r).cmic_cmc_irq_stat1[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define CMIC_CMC_IRQ_STAT1r_TIM1_INTR1f_GET(r) ((((r).cmic_cmc_irq_stat1[0]) >> 25) & 0x1)
#define CMIC_CMC_IRQ_STAT1r_TIM1_INTR1f_SET(r,f) (r).cmic_cmc_irq_stat1[0]=(((r).cmic_cmc_irq_stat1[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define CMIC_CMC_IRQ_STAT1r_TIM1_INTR2f_GET(r) ((((r).cmic_cmc_irq_stat1[0]) >> 26) & 0x1)
#define CMIC_CMC_IRQ_STAT1r_TIM1_INTR2f_SET(r,f) (r).cmic_cmc_irq_stat1[0]=(((r).cmic_cmc_irq_stat1[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define CMIC_CMC_IRQ_STAT1r_PCIEINTF_NEEDS_CLEANUPf_GET(r) ((((r).cmic_cmc_irq_stat1[0]) >> 27) & 0x1)
#define CMIC_CMC_IRQ_STAT1r_PCIEINTF_NEEDS_CLEANUPf_SET(r,f) (r).cmic_cmc_irq_stat1[0]=(((r).cmic_cmc_irq_stat1[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define CMIC_CMC_IRQ_STAT1r_SRAM_ECC_INTRf_GET(r) ((((r).cmic_cmc_irq_stat1[0]) >> 28) & 0x1)
#define CMIC_CMC_IRQ_STAT1r_SRAM_ECC_INTRf_SET(r,f) (r).cmic_cmc_irq_stat1[0]=(((r).cmic_cmc_irq_stat1[0] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))

/*
 * These macros can be used to access CMIC_CMC_IRQ_STAT1.
 *
 */
#define READ_CMIC_CMC_IRQ_STAT1r(u,r) CDK_XGSM_CMC_READ(u,CMIC_CMC_IRQ_STAT1r,r._cmic_cmc_irq_stat1)
#define WRITE_CMIC_CMC_IRQ_STAT1r(u,r) CDK_XGSM_CMC_WRITE(u,CMIC_CMC_IRQ_STAT1r,r._cmic_cmc_irq_stat1)

/*******************************************************************************
 * End of 'CMIC_CMC_IRQ_STAT1r'
 ******************************************************************************/




/*******************************************************************************
 * REGISTER:  CMIC_CMC_MIIM_ADDRESS
 * BLOCKS:   CMIC
 * DESC:     Supplies the register address of MIIM reads and writes.
For clause 22 devices, bits [4:0] supply the REGAD.
For clause 45 devices, bits [20:16] supply the DTYPE,
                   and bits [15: 0] supply the reg address

 * SIZE:     32
 * FIELDS:
 *     CLAUSE_45_REGADR Register address for associated read or write
 *     CLAUSE_22_REGADR Register address for associated read or write
 *     CLAUSE_45_DTYPE  Block-within-PHY address for associated read or write
 *
 ******************************************************************************/
#define CMIC_CMC_MIIM_ADDRESSr 0x00031088

#define CMIC_CMC_MIIM_ADDRESSr_ENUM 8
#define CMIC_CMC_MIIM_ADDRESSr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_MIIM_ADDRESS.
 *
 */
typedef union CMIC_CMC_MIIM_ADDRESSr_s {
	uint32_t v[1];
	uint32_t cmic_cmc_miim_address[1];
	uint32_t _cmic_cmc_miim_address;
} CMIC_CMC_MIIM_ADDRESSr_t;

#define CMIC_CMC_MIIM_ADDRESSr_CLR(r) (r).cmic_cmc_miim_address[0] = 0
#define CMIC_CMC_MIIM_ADDRESSr_SET(r,d) (r).cmic_cmc_miim_address[0] = d
#define CMIC_CMC_MIIM_ADDRESSr_GET(r) (r).cmic_cmc_miim_address[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define CMIC_CMC_MIIM_ADDRESSr_CLAUSE_45_REGADRf_GET(r) (((r).cmic_cmc_miim_address[0]) & 0xffff)
#define CMIC_CMC_MIIM_ADDRESSr_CLAUSE_45_REGADRf_SET(r,f) (r).cmic_cmc_miim_address[0]=(((r).cmic_cmc_miim_address[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define CMIC_CMC_MIIM_ADDRESSr_CLAUSE_22_REGADRf_GET(r) (((r).cmic_cmc_miim_address[0]) & 0x1f)
#define CMIC_CMC_MIIM_ADDRESSr_CLAUSE_22_REGADRf_SET(r,f) (r).cmic_cmc_miim_address[0]=(((r).cmic_cmc_miim_address[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define CMIC_CMC_MIIM_ADDRESSr_CLAUSE_45_DTYPEf_GET(r) ((((r).cmic_cmc_miim_address[0]) >> 16) & 0x1f)
#define CMIC_CMC_MIIM_ADDRESSr_CLAUSE_45_DTYPEf_SET(r,f) (r).cmic_cmc_miim_address[0]=(((r).cmic_cmc_miim_address[0] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))

/*
 * These macros can be used to access CMIC_CMC_MIIM_ADDRESS.
 *
 */
#define READ_CMIC_CMC_MIIM_ADDRESSr(u,r) CDK_XGSM_CMC_READ(u,CMIC_CMC_MIIM_ADDRESSr,r._cmic_cmc_miim_address)
#define WRITE_CMIC_CMC_MIIM_ADDRESSr(u,r) CDK_XGSM_CMC_WRITE(u,CMIC_CMC_MIIM_ADDRESSr,r._cmic_cmc_miim_address)

/*******************************************************************************
 * End of 'CMIC_CMC_MIIM_ADDRESSr'
 ******************************************************************************/




/*******************************************************************************
 * REGISTER:  CMIC_CMC_MIIM_CTRL
 * BLOCKS:   CMIC
 * DESC:     register to enable MIIM read and Writes.

 * SIZE:     32
 * FIELDS:
 *     MIIM_WR_START    Set this bit to initiate MDIO read operation. This bit needs to be cleared to reset MDIO COMPLETE bit
 *     MIIM_RD_START    Set this bit to initiate MDIO read operation. This bit needs to be cleared to reset MDIO COMPLETE bit
 *
 ******************************************************************************/
#define CMIC_CMC_MIIM_CTRLr 0x0003108c

#define CMIC_CMC_MIIM_CTRLr_ENUM 9
#define CMIC_CMC_MIIM_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_MIIM_CTRL.
 *
 */
typedef union CMIC_CMC_MIIM_CTRLr_s {
	uint32_t v[1];
	uint32_t cmic_cmc_miim_ctrl[1];
	uint32_t _cmic_cmc_miim_ctrl;
} CMIC_CMC_MIIM_CTRLr_t;

#define CMIC_CMC_MIIM_CTRLr_CLR(r) (r).cmic_cmc_miim_ctrl[0] = 0
#define CMIC_CMC_MIIM_CTRLr_SET(r,d) (r).cmic_cmc_miim_ctrl[0] = d
#define CMIC_CMC_MIIM_CTRLr_GET(r) (r).cmic_cmc_miim_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define CMIC_CMC_MIIM_CTRLr_MIIM_WR_STARTf_GET(r) (((r).cmic_cmc_miim_ctrl[0]) & 0x1)
#define CMIC_CMC_MIIM_CTRLr_MIIM_WR_STARTf_SET(r,f) (r).cmic_cmc_miim_ctrl[0]=(((r).cmic_cmc_miim_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CMIC_CMC_MIIM_CTRLr_MIIM_RD_STARTf_GET(r) ((((r).cmic_cmc_miim_ctrl[0]) >> 1) & 0x1)
#define CMIC_CMC_MIIM_CTRLr_MIIM_RD_STARTf_SET(r,f) (r).cmic_cmc_miim_ctrl[0]=(((r).cmic_cmc_miim_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access CMIC_CMC_MIIM_CTRL.
 *
 */
#define READ_CMIC_CMC_MIIM_CTRLr(u,r) CDK_XGSM_CMC_READ(u,CMIC_CMC_MIIM_CTRLr,r._cmic_cmc_miim_ctrl)
#define WRITE_CMIC_CMC_MIIM_CTRLr(u,r) CDK_XGSM_CMC_WRITE(u,CMIC_CMC_MIIM_CTRLr,r._cmic_cmc_miim_ctrl)

/*******************************************************************************
 * End of 'CMIC_CMC_MIIM_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * REGISTER:  CMIC_CMC_MIIM_PARAM
 * BLOCKS:   CMIC
 * DESC:     MIIM Parameter Register
 * SIZE:     32
 * FIELDS:
 *     PHY_DATA         PHY register data
 *     PHY_ID           Port number (Phy ID is looked up from port number)
 *     C45_SEL          When set, send MIIM transaction using Clause 45.Otherwise, send as Clause 22 transaction.
 *     BUS_ID           Select MIIM Bus number from  6 of available MIIM busses.
 *     INTERNAL_SEL     When set, send MIIM transaction on Internal MDIO bus.Otherwise, send on External MDIO bus.
 *     MIIM_CYCLE       This field is used to select which type of MIIM cycle to run.Normally, it should just be set to 000.    000: Automatically runs the proper read or write cycle based         on the ports' protocol preference, and whether a read         or write cycle was requested.  If the port is clause 45         enabled, then the read or write will be preceeded by         an address cycle.    001: requests a clause 22 write cycle;         use MIIM_WR_REG_EN control    010: requests a clause 22 read cycle;         use MIIM_RD_REG_EN control    100: requests a clause 45 address cycle;         use MIIM_WR_REG_EN control    101: requests a clause 45 write cycle;         use MIIM_WR_REG_EN control    110: requests a clause 45 read cycle w/addr increment;         use MIIM_RD_REG_EN control    111: requests a clause 45 read cycle;         use MIIM_RD_REG_EN control
 *
 ******************************************************************************/
#define CMIC_CMC_MIIM_PARAMr 0x00031080

#define CMIC_CMC_MIIM_PARAMr_ENUM 10
#define CMIC_CMC_MIIM_PARAMr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_MIIM_PARAM.
 *
 */
typedef union CMIC_CMC_MIIM_PARAMr_s {
	uint32_t v[1];
	uint32_t cmic_cmc_miim_param[1];
	uint32_t _cmic_cmc_miim_param;
} CMIC_CMC_MIIM_PARAMr_t;

#define CMIC_CMC_MIIM_PARAMr_CLR(r) (r).cmic_cmc_miim_param[0] = 0
#define CMIC_CMC_MIIM_PARAMr_SET(r,d) (r).cmic_cmc_miim_param[0] = d
#define CMIC_CMC_MIIM_PARAMr_GET(r) (r).cmic_cmc_miim_param[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define CMIC_CMC_MIIM_PARAMr_PHY_DATAf_GET(r) (((r).cmic_cmc_miim_param[0]) & 0xffff)
#define CMIC_CMC_MIIM_PARAMr_PHY_DATAf_SET(r,f) (r).cmic_cmc_miim_param[0]=(((r).cmic_cmc_miim_param[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define CMIC_CMC_MIIM_PARAMr_PHY_IDf_GET(r) ((((r).cmic_cmc_miim_param[0]) >> 16) & 0x1f)
#define CMIC_CMC_MIIM_PARAMr_PHY_IDf_SET(r,f) (r).cmic_cmc_miim_param[0]=(((r).cmic_cmc_miim_param[0] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define CMIC_CMC_MIIM_PARAMr_C45_SELf_GET(r) ((((r).cmic_cmc_miim_param[0]) >> 21) & 0x1)
#define CMIC_CMC_MIIM_PARAMr_C45_SELf_SET(r,f) (r).cmic_cmc_miim_param[0]=(((r).cmic_cmc_miim_param[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define CMIC_CMC_MIIM_PARAMr_BUS_IDf_GET(r) ((((r).cmic_cmc_miim_param[0]) >> 22) & 0x7)
#define CMIC_CMC_MIIM_PARAMr_BUS_IDf_SET(r,f) (r).cmic_cmc_miim_param[0]=(((r).cmic_cmc_miim_param[0] & ~((uint32_t)0x7 << 22)) | ((((uint32_t)f) & 0x7) << 22))
#define CMIC_CMC_MIIM_PARAMr_INTERNAL_SELf_GET(r) ((((r).cmic_cmc_miim_param[0]) >> 25) & 0x1)
#define CMIC_CMC_MIIM_PARAMr_INTERNAL_SELf_SET(r,f) (r).cmic_cmc_miim_param[0]=(((r).cmic_cmc_miim_param[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define CMIC_CMC_MIIM_PARAMr_MIIM_CYCLEf_GET(r) ((((r).cmic_cmc_miim_param[0]) >> 29) & 0x7)
#define CMIC_CMC_MIIM_PARAMr_MIIM_CYCLEf_SET(r,f) (r).cmic_cmc_miim_param[0]=(((r).cmic_cmc_miim_param[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access CMIC_CMC_MIIM_PARAM.
 *
 */
#define READ_CMIC_CMC_MIIM_PARAMr(u,r) CDK_XGSM_CMC_READ(u,CMIC_CMC_MIIM_PARAMr,r._cmic_cmc_miim_param)
#define WRITE_CMIC_CMC_MIIM_PARAMr(u,r) CDK_XGSM_CMC_WRITE(u,CMIC_CMC_MIIM_PARAMr,r._cmic_cmc_miim_param)

/*******************************************************************************
 * End of 'CMIC_CMC_MIIM_PARAMr'
 ******************************************************************************/




/*******************************************************************************
 * REGISTER:  CMIC_CMC_MIIM_READ_DATA
 * BLOCKS:   CMIC
 * DESC:     MIIM Read Data Register
 * SIZE:     32
 * FIELDS:
 *     DATA             MIIM Read Data Register
 *
 ******************************************************************************/
#define CMIC_CMC_MIIM_READ_DATAr 0x00031084

#define CMIC_CMC_MIIM_READ_DATAr_ENUM 11
#define CMIC_CMC_MIIM_READ_DATAr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_MIIM_READ_DATA.
 *
 */
typedef union CMIC_CMC_MIIM_READ_DATAr_s {
	uint32_t v[1];
	uint32_t cmic_cmc_miim_read_data[1];
	uint32_t _cmic_cmc_miim_read_data;
} CMIC_CMC_MIIM_READ_DATAr_t;

#define CMIC_CMC_MIIM_READ_DATAr_CLR(r) (r).cmic_cmc_miim_read_data[0] = 0
#define CMIC_CMC_MIIM_READ_DATAr_SET(r,d) (r).cmic_cmc_miim_read_data[0] = d
#define CMIC_CMC_MIIM_READ_DATAr_GET(r) (r).cmic_cmc_miim_read_data[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define CMIC_CMC_MIIM_READ_DATAr_DATAf_GET(r) (((r).cmic_cmc_miim_read_data[0]) & 0xffff)
#define CMIC_CMC_MIIM_READ_DATAr_DATAf_SET(r,f) (r).cmic_cmc_miim_read_data[0]=(((r).cmic_cmc_miim_read_data[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access CMIC_CMC_MIIM_READ_DATA.
 *
 */
#define READ_CMIC_CMC_MIIM_READ_DATAr(u,r) CDK_XGSM_CMC_READ(u,CMIC_CMC_MIIM_READ_DATAr,r._cmic_cmc_miim_read_data)
#define WRITE_CMIC_CMC_MIIM_READ_DATAr(u,r) CDK_XGSM_CMC_WRITE(u,CMIC_CMC_MIIM_READ_DATAr,r._cmic_cmc_miim_read_data)

/*******************************************************************************
 * End of 'CMIC_CMC_MIIM_READ_DATAr'
 ******************************************************************************/




/*******************************************************************************
 * REGISTER:  CMIC_CMC_MIIM_STAT
 * BLOCKS:   CMIC
 * DESC:     register to enable MIIM read and Writes.

 * SIZE:     32
 * FIELDS:
 *     MIIM_OPN_DONE    MIIM read operation is complete. This bit will be cleared if MIIM_RD/WR_START are disabled.
 *
 ******************************************************************************/
#define CMIC_CMC_MIIM_STATr 0x00031090

#define CMIC_CMC_MIIM_STATr_ENUM 12
#define CMIC_CMC_MIIM_STATr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_MIIM_STAT.
 *
 */
typedef union CMIC_CMC_MIIM_STATr_s {
	uint32_t v[1];
	uint32_t cmic_cmc_miim_stat[1];
	uint32_t _cmic_cmc_miim_stat;
} CMIC_CMC_MIIM_STATr_t;

#define CMIC_CMC_MIIM_STATr_CLR(r) (r).cmic_cmc_miim_stat[0] = 0
#define CMIC_CMC_MIIM_STATr_SET(r,d) (r).cmic_cmc_miim_stat[0] = d
#define CMIC_CMC_MIIM_STATr_GET(r) (r).cmic_cmc_miim_stat[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define CMIC_CMC_MIIM_STATr_MIIM_OPN_DONEf_GET(r) (((r).cmic_cmc_miim_stat[0]) & 0x1)
#define CMIC_CMC_MIIM_STATr_MIIM_OPN_DONEf_SET(r,f) (r).cmic_cmc_miim_stat[0]=(((r).cmic_cmc_miim_stat[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access CMIC_CMC_MIIM_STAT.
 *
 */
#define READ_CMIC_CMC_MIIM_STATr(u,r) CDK_XGSM_CMC_READ(u,CMIC_CMC_MIIM_STATr,r._cmic_cmc_miim_stat)
#define WRITE_CMIC_CMC_MIIM_STATr(u,r) CDK_XGSM_CMC_WRITE(u,CMIC_CMC_MIIM_STATr,r._cmic_cmc_miim_stat)

/*******************************************************************************
 * End of 'CMIC_CMC_MIIM_STATr'
 ******************************************************************************/




/*******************************************************************************
 * REGISTER:  CMIC_CMC_PCIE_IRQ_MASK0
 * BLOCKS:   CMIC
 * DESC:     PCIe IRQ MASK register coresponding to CMIC_CMC0_IRQ_STAT0.
 * SIZE:     32
 * FIELDS:
 *     SBUSDMA_CH1_DONE 1- enable interrupt 0- disable interrupt.
 *     SBUSDMA_CH0_DONE 1- enable interrupt 0- disable interrupt.
 *     FIFO_CH3_DMA_INTR 1- enable interrupt 0- disable interrupt.
 *     FIFO_CH2_DMA_INTR 1- enable interrupt 0- disable interrupt.
 *     FIFO_CH1_DMA_INTR 1- enable interrupt 0- disable interrupt.
 *     FIFO_CH0_DMA_INTR 1- enable interrupt 0- disable interrupt.
 *     SBUSDMA_CH2_DONE 1- enable interrupt 0- disable interrupt.
 *     MIIM_OP_DONE     1- enable interrupt 0- disable interrupt.
 *     CH3_DESC_DONE    1- enable interrupt 0- disable interrupt.
 *     CH3_CHAIN_DONE   1- enable interrupt 0- disable interrupt.
 *     CH2_DESC_DONE    1- enable interrupt 0- disable interrupt.
 *     CH2_CHAIN_DONE   1- enable interrupt 0- disable interrupt.
 *     CH1_DESC_DONE    1- enable interrupt 0- disable interrupt.
 *     CH1_CHAIN_DONE   1- enable interrupt 0- disable interrupt.
 *     CH0_DESC_DONE    1- enable interrupt 0- disable interrupt.
 *     CH0_CHAIN_DONE   1- enable interrupt 0- disable interrupt.
 *     CH3_INTR_COALESCING_INTR 1- enable interrupt 0- disable interrupt.
 *     CH2_INTR_COALESCING_INTR 1- enable interrupt 0- disable interrupt.
 *     CH1_INTR_COALESCING_INTR 1- enable interrupt 0- disable interrupt.
 *     CH0_INTR_COALESCING_INTR 1- enable interrupt 0- disable interrupt. 
 *     SCHAN_OP_DONE    1- enable interrupt 0- disable interrupt. 
 *     CROSS_COUPLED_MEMORYDMA_DONE 1- enable interrupt 0- disable interrupt. 
 *     SW_INTR          1- enable interrupt 0- disable interrupt.
 *     SBUSDMA_ECCERR   1- enable interrupt 0- disable interrupt.
 *
 ******************************************************************************/
#define CMIC_CMC_PCIE_IRQ_MASK0r 0x00031414

#define CMIC_CMC_PCIE_IRQ_MASK0r_ENUM 13
#define CMIC_CMC_PCIE_IRQ_MASK0r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_PCIE_IRQ_MASK0.
 *
 */
typedef union CMIC_CMC_PCIE_IRQ_MASK0r_s {
	uint32_t v[1];
	uint32_t cmic_cmc_pcie_irq_mask0[1];
	uint32_t _cmic_cmc_pcie_irq_mask0;
} CMIC_CMC_PCIE_IRQ_MASK0r_t;

#define CMIC_CMC_PCIE_IRQ_MASK0r_CLR(r) (r).cmic_cmc_pcie_irq_mask0[0] = 0
#define CMIC_CMC_PCIE_IRQ_MASK0r_SET(r,d) (r).cmic_cmc_pcie_irq_mask0[0] = d
#define CMIC_CMC_PCIE_IRQ_MASK0r_GET(r) (r).cmic_cmc_pcie_irq_mask0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define CMIC_CMC_PCIE_IRQ_MASK0r_SBUSDMA_CH1_DONEf_GET(r) (((r).cmic_cmc_pcie_irq_mask0[0]) & 0x1)
#define CMIC_CMC_PCIE_IRQ_MASK0r_SBUSDMA_CH1_DONEf_SET(r,f) (r).cmic_cmc_pcie_irq_mask0[0]=(((r).cmic_cmc_pcie_irq_mask0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CMIC_CMC_PCIE_IRQ_MASK0r_SBUSDMA_CH0_DONEf_GET(r) ((((r).cmic_cmc_pcie_irq_mask0[0]) >> 1) & 0x1)
#define CMIC_CMC_PCIE_IRQ_MASK0r_SBUSDMA_CH0_DONEf_SET(r,f) (r).cmic_cmc_pcie_irq_mask0[0]=(((r).cmic_cmc_pcie_irq_mask0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CMIC_CMC_PCIE_IRQ_MASK0r_FIFO_CH3_DMA_INTRf_GET(r) ((((r).cmic_cmc_pcie_irq_mask0[0]) >> 2) & 0x1)
#define CMIC_CMC_PCIE_IRQ_MASK0r_FIFO_CH3_DMA_INTRf_SET(r,f) (r).cmic_cmc_pcie_irq_mask0[0]=(((r).cmic_cmc_pcie_irq_mask0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define CMIC_CMC_PCIE_IRQ_MASK0r_FIFO_CH2_DMA_INTRf_GET(r) ((((r).cmic_cmc_pcie_irq_mask0[0]) >> 3) & 0x1)
#define CMIC_CMC_PCIE_IRQ_MASK0r_FIFO_CH2_DMA_INTRf_SET(r,f) (r).cmic_cmc_pcie_irq_mask0[0]=(((r).cmic_cmc_pcie_irq_mask0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define CMIC_CMC_PCIE_IRQ_MASK0r_FIFO_CH1_DMA_INTRf_GET(r) ((((r).cmic_cmc_pcie_irq_mask0[0]) >> 4) & 0x1)
#define CMIC_CMC_PCIE_IRQ_MASK0r_FIFO_CH1_DMA_INTRf_SET(r,f) (r).cmic_cmc_pcie_irq_mask0[0]=(((r).cmic_cmc_pcie_irq_mask0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define CMIC_CMC_PCIE_IRQ_MASK0r_FIFO_CH0_DMA_INTRf_GET(r) ((((r).cmic_cmc_pcie_irq_mask0[0]) >> 5) & 0x1)
#define CMIC_CMC_PCIE_IRQ_MASK0r_FIFO_CH0_DMA_INTRf_SET(r,f) (r).cmic_cmc_pcie_irq_mask0[0]=(((r).cmic_cmc_pcie_irq_mask0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define CMIC_CMC_PCIE_IRQ_MASK0r_SBUSDMA_CH2_DONEf_GET(r) ((((r).cmic_cmc_pcie_irq_mask0[0]) >> 6) & 0x1)
#define CMIC_CMC_PCIE_IRQ_MASK0r_SBUSDMA_CH2_DONEf_SET(r,f) (r).cmic_cmc_pcie_irq_mask0[0]=(((r).cmic_cmc_pcie_irq_mask0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define CMIC_CMC_PCIE_IRQ_MASK0r_MIIM_OP_DONEf_GET(r) ((((r).cmic_cmc_pcie_irq_mask0[0]) >> 7) & 0x1)
#define CMIC_CMC_PCIE_IRQ_MASK0r_MIIM_OP_DONEf_SET(r,f) (r).cmic_cmc_pcie_irq_mask0[0]=(((r).cmic_cmc_pcie_irq_mask0[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define CMIC_CMC_PCIE_IRQ_MASK0r_CH3_DESC_DONEf_GET(r) ((((r).cmic_cmc_pcie_irq_mask0[0]) >> 8) & 0x1)
#define CMIC_CMC_PCIE_IRQ_MASK0r_CH3_DESC_DONEf_SET(r,f) (r).cmic_cmc_pcie_irq_mask0[0]=(((r).cmic_cmc_pcie_irq_mask0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define CMIC_CMC_PCIE_IRQ_MASK0r_CH3_CHAIN_DONEf_GET(r) ((((r).cmic_cmc_pcie_irq_mask0[0]) >> 9) & 0x1)
#define CMIC_CMC_PCIE_IRQ_MASK0r_CH3_CHAIN_DONEf_SET(r,f) (r).cmic_cmc_pcie_irq_mask0[0]=(((r).cmic_cmc_pcie_irq_mask0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define CMIC_CMC_PCIE_IRQ_MASK0r_CH2_DESC_DONEf_GET(r) ((((r).cmic_cmc_pcie_irq_mask0[0]) >> 10) & 0x1)
#define CMIC_CMC_PCIE_IRQ_MASK0r_CH2_DESC_DONEf_SET(r,f) (r).cmic_cmc_pcie_irq_mask0[0]=(((r).cmic_cmc_pcie_irq_mask0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define CMIC_CMC_PCIE_IRQ_MASK0r_CH2_CHAIN_DONEf_GET(r) ((((r).cmic_cmc_pcie_irq_mask0[0]) >> 11) & 0x1)
#define CMIC_CMC_PCIE_IRQ_MASK0r_CH2_CHAIN_DONEf_SET(r,f) (r).cmic_cmc_pcie_irq_mask0[0]=(((r).cmic_cmc_pcie_irq_mask0[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define CMIC_CMC_PCIE_IRQ_MASK0r_CH1_DESC_DONEf_GET(r) ((((r).cmic_cmc_pcie_irq_mask0[0]) >> 12) & 0x1)
#define CMIC_CMC_PCIE_IRQ_MASK0r_CH1_DESC_DONEf_SET(r,f) (r).cmic_cmc_pcie_irq_mask0[0]=(((r).cmic_cmc_pcie_irq_mask0[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define CMIC_CMC_PCIE_IRQ_MASK0r_CH1_CHAIN_DONEf_GET(r) ((((r).cmic_cmc_pcie_irq_mask0[0]) >> 13) & 0x1)
#define CMIC_CMC_PCIE_IRQ_MASK0r_CH1_CHAIN_DONEf_SET(r,f) (r).cmic_cmc_pcie_irq_mask0[0]=(((r).cmic_cmc_pcie_irq_mask0[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define CMIC_CMC_PCIE_IRQ_MASK0r_CH0_DESC_DONEf_GET(r) ((((r).cmic_cmc_pcie_irq_mask0[0]) >> 14) & 0x1)
#define CMIC_CMC_PCIE_IRQ_MASK0r_CH0_DESC_DONEf_SET(r,f) (r).cmic_cmc_pcie_irq_mask0[0]=(((r).cmic_cmc_pcie_irq_mask0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define CMIC_CMC_PCIE_IRQ_MASK0r_CH0_CHAIN_DONEf_GET(r) ((((r).cmic_cmc_pcie_irq_mask0[0]) >> 15) & 0x1)
#define CMIC_CMC_PCIE_IRQ_MASK0r_CH0_CHAIN_DONEf_SET(r,f) (r).cmic_cmc_pcie_irq_mask0[0]=(((r).cmic_cmc_pcie_irq_mask0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define CMIC_CMC_PCIE_IRQ_MASK0r_CH3_INTR_COALESCING_INTRf_GET(r) ((((r).cmic_cmc_pcie_irq_mask0[0]) >> 16) & 0x1)
#define CMIC_CMC_PCIE_IRQ_MASK0r_CH3_INTR_COALESCING_INTRf_SET(r,f) (r).cmic_cmc_pcie_irq_mask0[0]=(((r).cmic_cmc_pcie_irq_mask0[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define CMIC_CMC_PCIE_IRQ_MASK0r_CH2_INTR_COALESCING_INTRf_GET(r) ((((r).cmic_cmc_pcie_irq_mask0[0]) >> 17) & 0x1)
#define CMIC_CMC_PCIE_IRQ_MASK0r_CH2_INTR_COALESCING_INTRf_SET(r,f) (r).cmic_cmc_pcie_irq_mask0[0]=(((r).cmic_cmc_pcie_irq_mask0[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define CMIC_CMC_PCIE_IRQ_MASK0r_CH1_INTR_COALESCING_INTRf_GET(r) ((((r).cmic_cmc_pcie_irq_mask0[0]) >> 18) & 0x1)
#define CMIC_CMC_PCIE_IRQ_MASK0r_CH1_INTR_COALESCING_INTRf_SET(r,f) (r).cmic_cmc_pcie_irq_mask0[0]=(((r).cmic_cmc_pcie_irq_mask0[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define CMIC_CMC_PCIE_IRQ_MASK0r_CH0_INTR_COALESCING_INTRf_GET(r) ((((r).cmic_cmc_pcie_irq_mask0[0]) >> 19) & 0x1)
#define CMIC_CMC_PCIE_IRQ_MASK0r_CH0_INTR_COALESCING_INTRf_SET(r,f) (r).cmic_cmc_pcie_irq_mask0[0]=(((r).cmic_cmc_pcie_irq_mask0[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define CMIC_CMC_PCIE_IRQ_MASK0r_SCHAN_OP_DONEf_GET(r) ((((r).cmic_cmc_pcie_irq_mask0[0]) >> 20) & 0x1)
#define CMIC_CMC_PCIE_IRQ_MASK0r_SCHAN_OP_DONEf_SET(r,f) (r).cmic_cmc_pcie_irq_mask0[0]=(((r).cmic_cmc_pcie_irq_mask0[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define CMIC_CMC_PCIE_IRQ_MASK0r_CROSS_COUPLED_MEMORYDMA_DONEf_GET(r) ((((r).cmic_cmc_pcie_irq_mask0[0]) >> 21) & 0x1)
#define CMIC_CMC_PCIE_IRQ_MASK0r_CROSS_COUPLED_MEMORYDMA_DONEf_SET(r,f) (r).cmic_cmc_pcie_irq_mask0[0]=(((r).cmic_cmc_pcie_irq_mask0[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define CMIC_CMC_PCIE_IRQ_MASK0r_SW_INTRf_GET(r) ((((r).cmic_cmc_pcie_irq_mask0[0]) >> 22) & 0xf)
#define CMIC_CMC_PCIE_IRQ_MASK0r_SW_INTRf_SET(r,f) (r).cmic_cmc_pcie_irq_mask0[0]=(((r).cmic_cmc_pcie_irq_mask0[0] & ~((uint32_t)0xf << 22)) | ((((uint32_t)f) & 0xf) << 22))
#define CMIC_CMC_PCIE_IRQ_MASK0r_SBUSDMA_ECCERRf_GET(r) ((((r).cmic_cmc_pcie_irq_mask0[0]) >> 26) & 0x1)
#define CMIC_CMC_PCIE_IRQ_MASK0r_SBUSDMA_ECCERRf_SET(r,f) (r).cmic_cmc_pcie_irq_mask0[0]=(((r).cmic_cmc_pcie_irq_mask0[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))

/*
 * These macros can be used to access CMIC_CMC_PCIE_IRQ_MASK0.
 *
 */
#define READ_CMIC_CMC_PCIE_IRQ_MASK0r(u,r) CDK_XGSM_CMC_READ(u,CMIC_CMC_PCIE_IRQ_MASK0r,r._cmic_cmc_pcie_irq_mask0)
#define WRITE_CMIC_CMC_PCIE_IRQ_MASK0r(u,r) CDK_XGSM_CMC_WRITE(u,CMIC_CMC_PCIE_IRQ_MASK0r,r._cmic_cmc_pcie_irq_mask0)

/*******************************************************************************
 * End of 'CMIC_CMC_PCIE_IRQ_MASK0r'
 ******************************************************************************/




/*******************************************************************************
 * REGISTER:  CMIC_CMC_PCIE_IRQ_MASK1
 * BLOCKS:   CMIC
 * DESC:     PCIe IRQ MASK register coresponding to CMIC_CMC0_IRQ_STAT1
 * SIZE:     32
 * FIELDS:
 *     I2C_INTR         1- enable interrupt 0- disable interrupt.
 *     PCIE_ECRC_ERR_INTR 1- enable interrupt 0- disable interrupt.
 *     TIMESYNC_INTR    1- enable interrupt 0- disable interrupt.
 *     PHY_LINKSCAN_LINKSTATUS_CHD 1- enable interrupt 0- disable interrupt.
 *     PHY_PAUSESCAN_PAUSESTATUS_CHD 1- enable interrupt 0- disable interrupt.
 *     SPI_INTERRUPT    1- enable interrupt 0- disable interrupt.
 *     UART0_INTERRUPT  1- enable interrupt 0- disable interrupt.
 *     UART1_INTERRUPT  1- enable interrupt 0- disable interrupt.
 *     COMMON_SCHAN_DONE 1- enable interrupt 0- disable interrupt.
 *     MIIM_OP_DONE     1- enable interrupt 0- disable interrupt.
 *     GPIO_INTR        1- enable interrupt 0- disable interrupt..
 *     CHIP_FUNC_INTR   1- enable interrupt 0- disable interrupt.
 *     UC_0_PMUIRQ      1- enable interrupt 0- disable interrupt.
 *     UC_1_PMUIRQ      1- enable interrupt 0- disable interrupt.
 *     WDT_0_INTR       1- enable interrupt 0- disable interrupt.
 *     WDT_1_INTR       1- enable interrupt 0- disable interrupt.
 *     TIM0_INTR1       1- enable interrupt 0- disable interrupt..
 *     TIM0_INTR2       1- enable interrupt 0- disable interrupt..
 *     TIM1_INTR1       1- enable interrupt 0- disable interrupt..
 *     TIM1_INTR2       1- enable interrupt 0- disable interrupt..
 *     PCIEINTF_NEEDS_CLEANUP 1- enable interrupt 0- disable interrupt..
 *     SRAM_ECC_INTR    1- enable interrupt 0- disable interrupt..
 *
 ******************************************************************************/
#define CMIC_CMC_PCIE_IRQ_MASK1r 0x00031418

#define CMIC_CMC_PCIE_IRQ_MASK1r_ENUM 14
#define CMIC_CMC_PCIE_IRQ_MASK1r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_PCIE_IRQ_MASK1.
 *
 */
typedef union CMIC_CMC_PCIE_IRQ_MASK1r_s {
	uint32_t v[1];
	uint32_t cmic_cmc_pcie_irq_mask1[1];
	uint32_t _cmic_cmc_pcie_irq_mask1;
} CMIC_CMC_PCIE_IRQ_MASK1r_t;

#define CMIC_CMC_PCIE_IRQ_MASK1r_CLR(r) (r).cmic_cmc_pcie_irq_mask1[0] = 0
#define CMIC_CMC_PCIE_IRQ_MASK1r_SET(r,d) (r).cmic_cmc_pcie_irq_mask1[0] = d
#define CMIC_CMC_PCIE_IRQ_MASK1r_GET(r) (r).cmic_cmc_pcie_irq_mask1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define CMIC_CMC_PCIE_IRQ_MASK1r_I2C_INTRf_GET(r) (((r).cmic_cmc_pcie_irq_mask1[0]) & 0x1)
#define CMIC_CMC_PCIE_IRQ_MASK1r_I2C_INTRf_SET(r,f) (r).cmic_cmc_pcie_irq_mask1[0]=(((r).cmic_cmc_pcie_irq_mask1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CMIC_CMC_PCIE_IRQ_MASK1r_PCIE_ECRC_ERR_INTRf_GET(r) ((((r).cmic_cmc_pcie_irq_mask1[0]) >> 1) & 0x1)
#define CMIC_CMC_PCIE_IRQ_MASK1r_PCIE_ECRC_ERR_INTRf_SET(r,f) (r).cmic_cmc_pcie_irq_mask1[0]=(((r).cmic_cmc_pcie_irq_mask1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CMIC_CMC_PCIE_IRQ_MASK1r_TIMESYNC_INTRf_GET(r) ((((r).cmic_cmc_pcie_irq_mask1[0]) >> 2) & 0x1)
#define CMIC_CMC_PCIE_IRQ_MASK1r_TIMESYNC_INTRf_SET(r,f) (r).cmic_cmc_pcie_irq_mask1[0]=(((r).cmic_cmc_pcie_irq_mask1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define CMIC_CMC_PCIE_IRQ_MASK1r_PHY_LINKSCAN_LINKSTATUS_CHDf_GET(r) ((((r).cmic_cmc_pcie_irq_mask1[0]) >> 3) & 0x1)
#define CMIC_CMC_PCIE_IRQ_MASK1r_PHY_LINKSCAN_LINKSTATUS_CHDf_SET(r,f) (r).cmic_cmc_pcie_irq_mask1[0]=(((r).cmic_cmc_pcie_irq_mask1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define CMIC_CMC_PCIE_IRQ_MASK1r_PHY_PAUSESCAN_PAUSESTATUS_CHDf_GET(r) ((((r).cmic_cmc_pcie_irq_mask1[0]) >> 4) & 0x1)
#define CMIC_CMC_PCIE_IRQ_MASK1r_PHY_PAUSESCAN_PAUSESTATUS_CHDf_SET(r,f) (r).cmic_cmc_pcie_irq_mask1[0]=(((r).cmic_cmc_pcie_irq_mask1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define CMIC_CMC_PCIE_IRQ_MASK1r_SPI_INTERRUPTf_GET(r) ((((r).cmic_cmc_pcie_irq_mask1[0]) >> 5) & 0x1)
#define CMIC_CMC_PCIE_IRQ_MASK1r_SPI_INTERRUPTf_SET(r,f) (r).cmic_cmc_pcie_irq_mask1[0]=(((r).cmic_cmc_pcie_irq_mask1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define CMIC_CMC_PCIE_IRQ_MASK1r_UART0_INTERRUPTf_GET(r) ((((r).cmic_cmc_pcie_irq_mask1[0]) >> 6) & 0x1)
#define CMIC_CMC_PCIE_IRQ_MASK1r_UART0_INTERRUPTf_SET(r,f) (r).cmic_cmc_pcie_irq_mask1[0]=(((r).cmic_cmc_pcie_irq_mask1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define CMIC_CMC_PCIE_IRQ_MASK1r_UART1_INTERRUPTf_GET(r) ((((r).cmic_cmc_pcie_irq_mask1[0]) >> 7) & 0x1)
#define CMIC_CMC_PCIE_IRQ_MASK1r_UART1_INTERRUPTf_SET(r,f) (r).cmic_cmc_pcie_irq_mask1[0]=(((r).cmic_cmc_pcie_irq_mask1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define CMIC_CMC_PCIE_IRQ_MASK1r_COMMON_SCHAN_DONEf_GET(r) ((((r).cmic_cmc_pcie_irq_mask1[0]) >> 8) & 0x1)
#define CMIC_CMC_PCIE_IRQ_MASK1r_COMMON_SCHAN_DONEf_SET(r,f) (r).cmic_cmc_pcie_irq_mask1[0]=(((r).cmic_cmc_pcie_irq_mask1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define CMIC_CMC_PCIE_IRQ_MASK1r_MIIM_OP_DONEf_GET(r) ((((r).cmic_cmc_pcie_irq_mask1[0]) >> 9) & 0x1)
#define CMIC_CMC_PCIE_IRQ_MASK1r_MIIM_OP_DONEf_SET(r,f) (r).cmic_cmc_pcie_irq_mask1[0]=(((r).cmic_cmc_pcie_irq_mask1[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define CMIC_CMC_PCIE_IRQ_MASK1r_GPIO_INTRf_GET(r) ((((r).cmic_cmc_pcie_irq_mask1[0]) >> 10) & 0x1)
#define CMIC_CMC_PCIE_IRQ_MASK1r_GPIO_INTRf_SET(r,f) (r).cmic_cmc_pcie_irq_mask1[0]=(((r).cmic_cmc_pcie_irq_mask1[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define CMIC_CMC_PCIE_IRQ_MASK1r_CHIP_FUNC_INTRf_GET(r) ((((r).cmic_cmc_pcie_irq_mask1[0]) >> 11) & 0xff)
#define CMIC_CMC_PCIE_IRQ_MASK1r_CHIP_FUNC_INTRf_SET(r,f) (r).cmic_cmc_pcie_irq_mask1[0]=(((r).cmic_cmc_pcie_irq_mask1[0] & ~((uint32_t)0xff << 11)) | ((((uint32_t)f) & 0xff) << 11))
#define CMIC_CMC_PCIE_IRQ_MASK1r_UC_0_PMUIRQf_GET(r) ((((r).cmic_cmc_pcie_irq_mask1[0]) >> 19) & 0x1)
#define CMIC_CMC_PCIE_IRQ_MASK1r_UC_0_PMUIRQf_SET(r,f) (r).cmic_cmc_pcie_irq_mask1[0]=(((r).cmic_cmc_pcie_irq_mask1[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define CMIC_CMC_PCIE_IRQ_MASK1r_UC_1_PMUIRQf_GET(r) ((((r).cmic_cmc_pcie_irq_mask1[0]) >> 20) & 0x1)
#define CMIC_CMC_PCIE_IRQ_MASK1r_UC_1_PMUIRQf_SET(r,f) (r).cmic_cmc_pcie_irq_mask1[0]=(((r).cmic_cmc_pcie_irq_mask1[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define CMIC_CMC_PCIE_IRQ_MASK1r_WDT_0_INTRf_GET(r) ((((r).cmic_cmc_pcie_irq_mask1[0]) >> 21) & 0x1)
#define CMIC_CMC_PCIE_IRQ_MASK1r_WDT_0_INTRf_SET(r,f) (r).cmic_cmc_pcie_irq_mask1[0]=(((r).cmic_cmc_pcie_irq_mask1[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define CMIC_CMC_PCIE_IRQ_MASK1r_WDT_1_INTRf_GET(r) ((((r).cmic_cmc_pcie_irq_mask1[0]) >> 22) & 0x1)
#define CMIC_CMC_PCIE_IRQ_MASK1r_WDT_1_INTRf_SET(r,f) (r).cmic_cmc_pcie_irq_mask1[0]=(((r).cmic_cmc_pcie_irq_mask1[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define CMIC_CMC_PCIE_IRQ_MASK1r_TIM0_INTR1f_GET(r) ((((r).cmic_cmc_pcie_irq_mask1[0]) >> 23) & 0x1)
#define CMIC_CMC_PCIE_IRQ_MASK1r_TIM0_INTR1f_SET(r,f) (r).cmic_cmc_pcie_irq_mask1[0]=(((r).cmic_cmc_pcie_irq_mask1[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define CMIC_CMC_PCIE_IRQ_MASK1r_TIM0_INTR2f_GET(r) ((((r).cmic_cmc_pcie_irq_mask1[0]) >> 24) & 0x1)
#define CMIC_CMC_PCIE_IRQ_MASK1r_TIM0_INTR2f_SET(r,f) (r).cmic_cmc_pcie_irq_mask1[0]=(((r).cmic_cmc_pcie_irq_mask1[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define CMIC_CMC_PCIE_IRQ_MASK1r_TIM1_INTR1f_GET(r) ((((r).cmic_cmc_pcie_irq_mask1[0]) >> 25) & 0x1)
#define CMIC_CMC_PCIE_IRQ_MASK1r_TIM1_INTR1f_SET(r,f) (r).cmic_cmc_pcie_irq_mask1[0]=(((r).cmic_cmc_pcie_irq_mask1[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define CMIC_CMC_PCIE_IRQ_MASK1r_TIM1_INTR2f_GET(r) ((((r).cmic_cmc_pcie_irq_mask1[0]) >> 26) & 0x1)
#define CMIC_CMC_PCIE_IRQ_MASK1r_TIM1_INTR2f_SET(r,f) (r).cmic_cmc_pcie_irq_mask1[0]=(((r).cmic_cmc_pcie_irq_mask1[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define CMIC_CMC_PCIE_IRQ_MASK1r_PCIEINTF_NEEDS_CLEANUPf_GET(r) ((((r).cmic_cmc_pcie_irq_mask1[0]) >> 27) & 0x1)
#define CMIC_CMC_PCIE_IRQ_MASK1r_PCIEINTF_NEEDS_CLEANUPf_SET(r,f) (r).cmic_cmc_pcie_irq_mask1[0]=(((r).cmic_cmc_pcie_irq_mask1[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define CMIC_CMC_PCIE_IRQ_MASK1r_SRAM_ECC_INTRf_GET(r) ((((r).cmic_cmc_pcie_irq_mask1[0]) >> 28) & 0x1)
#define CMIC_CMC_PCIE_IRQ_MASK1r_SRAM_ECC_INTRf_SET(r,f) (r).cmic_cmc_pcie_irq_mask1[0]=(((r).cmic_cmc_pcie_irq_mask1[0] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))

/*
 * These macros can be used to access CMIC_CMC_PCIE_IRQ_MASK1.
 *
 */
#define READ_CMIC_CMC_PCIE_IRQ_MASK1r(u,r) CDK_XGSM_CMC_READ(u,CMIC_CMC_PCIE_IRQ_MASK1r,r._cmic_cmc_pcie_irq_mask1)
#define WRITE_CMIC_CMC_PCIE_IRQ_MASK1r(u,r) CDK_XGSM_CMC_WRITE(u,CMIC_CMC_PCIE_IRQ_MASK1r,r._cmic_cmc_pcie_irq_mask1)

/*******************************************************************************
 * End of 'CMIC_CMC_PCIE_IRQ_MASK1r'
 ******************************************************************************/




/*******************************************************************************
 * REGISTER:  CMIC_CMC_SCHAN_CTRL
 * BLOCKS:   CMIC
 * DESC:     Status and Control Register
 * SIZE:     32
 * FIELDS:
 *     MSG_START        Set by SW to start an SCH operation. Cleared by HW.
 *     MSG_DONE         Set by CMIC to indicate an SCH operation completion. When SW clears this bit, the status bits TIMEOUT, NACK and SER_CHECK_FAILED arecleared.
 *     ABORT            Set by SW to ABORT ongoing SCHAN Operation. SCHAN operation can be aborted only if SBus grant has not ben received. Once grant isreceived, the entire message should be sent and complete ack received. 
 *     SER_CHECK_FAIL   Set by CMIC to indicate last S-bus operation resulted in a SER Parity Check errorClearing the SCHAN_MSG_DONE bit or starting a new SCHAN operation will automatically clear this bit
 *     NACK             Set by CMIC to indicate last S-bus operation resulted in a NACK(i.e., command was legal, but could not be serviced due tohardware resource limitations)Clearing the SCHAN_MSG_DONE bit or starting a new SCHAN operation will automatically clear this bit
 *     TIMEOUT          Set by CMIC to indicate last S-bus operation resulted in a TIMEOUT.(i.e., no ACK was received by CMIC within the TIMEOUT intervalspecified in CMIC_SBUS_TIMEOUT)Clearing the SCHAN_MSG_DONE bit or starting a new SCHAN operation will automatically clear this bit
 *
 ******************************************************************************/
#define CMIC_CMC_SCHAN_CTRLr 0x00031000

#define CMIC_CMC_SCHAN_CTRLr_ENUM 15
#define CMIC_CMC_SCHAN_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_SCHAN_CTRL.
 *
 */
typedef union CMIC_CMC_SCHAN_CTRLr_s {
	uint32_t v[1];
	uint32_t cmic_cmc_schan_ctrl[1];
	uint32_t _cmic_cmc_schan_ctrl;
} CMIC_CMC_SCHAN_CTRLr_t;

#define CMIC_CMC_SCHAN_CTRLr_CLR(r) (r).cmic_cmc_schan_ctrl[0] = 0
#define CMIC_CMC_SCHAN_CTRLr_SET(r,d) (r).cmic_cmc_schan_ctrl[0] = d
#define CMIC_CMC_SCHAN_CTRLr_GET(r) (r).cmic_cmc_schan_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define CMIC_CMC_SCHAN_CTRLr_MSG_STARTf_GET(r) (((r).cmic_cmc_schan_ctrl[0]) & 0x1)
#define CMIC_CMC_SCHAN_CTRLr_MSG_STARTf_SET(r,f) (r).cmic_cmc_schan_ctrl[0]=(((r).cmic_cmc_schan_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CMIC_CMC_SCHAN_CTRLr_MSG_DONEf_GET(r) ((((r).cmic_cmc_schan_ctrl[0]) >> 1) & 0x1)
#define CMIC_CMC_SCHAN_CTRLr_MSG_DONEf_SET(r,f) (r).cmic_cmc_schan_ctrl[0]=(((r).cmic_cmc_schan_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CMIC_CMC_SCHAN_CTRLr_ABORTf_GET(r) ((((r).cmic_cmc_schan_ctrl[0]) >> 2) & 0x1)
#define CMIC_CMC_SCHAN_CTRLr_ABORTf_SET(r,f) (r).cmic_cmc_schan_ctrl[0]=(((r).cmic_cmc_schan_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define CMIC_CMC_SCHAN_CTRLr_SER_CHECK_FAILf_GET(r) ((((r).cmic_cmc_schan_ctrl[0]) >> 20) & 0x1)
#define CMIC_CMC_SCHAN_CTRLr_SER_CHECK_FAILf_SET(r,f) (r).cmic_cmc_schan_ctrl[0]=(((r).cmic_cmc_schan_ctrl[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define CMIC_CMC_SCHAN_CTRLr_NACKf_GET(r) ((((r).cmic_cmc_schan_ctrl[0]) >> 21) & 0x1)
#define CMIC_CMC_SCHAN_CTRLr_NACKf_SET(r,f) (r).cmic_cmc_schan_ctrl[0]=(((r).cmic_cmc_schan_ctrl[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define CMIC_CMC_SCHAN_CTRLr_TIMEOUTf_GET(r) ((((r).cmic_cmc_schan_ctrl[0]) >> 22) & 0x1)
#define CMIC_CMC_SCHAN_CTRLr_TIMEOUTf_SET(r,f) (r).cmic_cmc_schan_ctrl[0]=(((r).cmic_cmc_schan_ctrl[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))

/*
 * These macros can be used to access CMIC_CMC_SCHAN_CTRL.
 *
 */
#define READ_CMIC_CMC_SCHAN_CTRLr(u,r) CDK_XGSM_CMC_READ(u,CMIC_CMC_SCHAN_CTRLr,r._cmic_cmc_schan_ctrl)
#define WRITE_CMIC_CMC_SCHAN_CTRLr(u,r) CDK_XGSM_CMC_WRITE(u,CMIC_CMC_SCHAN_CTRLr,r._cmic_cmc_schan_ctrl)

/*******************************************************************************
 * End of 'CMIC_CMC_SCHAN_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * REGISTER:  CMIC_CMC_SCHAN_ERR
 * BLOCKS:   CMIC
 * DESC:     Error Status Register
 * SIZE:     32
 * FIELDS:
 *     NACK             When set, indicates the last S-bus command resulted in an NACK(i.e., could not be fulfilled due to hardware resource limitations).
 *     ERR_CODE         Error code in the SCH Error message
 *     ERRBIT           When set, indicates the last S-bus command resulted in an error(i.e., the command was illegal, or accessed an invalid address)
 *     DATA_LEN         Data length in the SCH Error ACK message
 *     SRC_PORT         Source port in the SCH Error ACK message(not guaranteed to be set by all blocks)
 *     DST_PORT         Dest port in the SCH Error ACK message
 *     OP_CODE          Opcode in the SCH Error ACK message
 *
 ******************************************************************************/
#define CMIC_CMC_SCHAN_ERRr 0x00031008

#define CMIC_CMC_SCHAN_ERRr_ENUM 16
#define CMIC_CMC_SCHAN_ERRr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_SCHAN_ERR.
 *
 */
typedef union CMIC_CMC_SCHAN_ERRr_s {
	uint32_t v[1];
	uint32_t cmic_cmc_schan_err[1];
	uint32_t _cmic_cmc_schan_err;
} CMIC_CMC_SCHAN_ERRr_t;

#define CMIC_CMC_SCHAN_ERRr_CLR(r) (r).cmic_cmc_schan_err[0] = 0
#define CMIC_CMC_SCHAN_ERRr_SET(r,d) (r).cmic_cmc_schan_err[0] = d
#define CMIC_CMC_SCHAN_ERRr_GET(r) (r).cmic_cmc_schan_err[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define CMIC_CMC_SCHAN_ERRr_NACKf_GET(r) (((r).cmic_cmc_schan_err[0]) & 0x1)
#define CMIC_CMC_SCHAN_ERRr_NACKf_SET(r,f) (r).cmic_cmc_schan_err[0]=(((r).cmic_cmc_schan_err[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CMIC_CMC_SCHAN_ERRr_ERR_CODEf_GET(r) ((((r).cmic_cmc_schan_err[0]) >> 4) & 0x3)
#define CMIC_CMC_SCHAN_ERRr_ERR_CODEf_SET(r,f) (r).cmic_cmc_schan_err[0]=(((r).cmic_cmc_schan_err[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define CMIC_CMC_SCHAN_ERRr_ERRBITf_GET(r) ((((r).cmic_cmc_schan_err[0]) >> 6) & 0x1)
#define CMIC_CMC_SCHAN_ERRr_ERRBITf_SET(r,f) (r).cmic_cmc_schan_err[0]=(((r).cmic_cmc_schan_err[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define CMIC_CMC_SCHAN_ERRr_DATA_LENf_GET(r) ((((r).cmic_cmc_schan_err[0]) >> 7) & 0x7f)
#define CMIC_CMC_SCHAN_ERRr_DATA_LENf_SET(r,f) (r).cmic_cmc_schan_err[0]=(((r).cmic_cmc_schan_err[0] & ~((uint32_t)0x7f << 7)) | ((((uint32_t)f) & 0x7f) << 7))
#define CMIC_CMC_SCHAN_ERRr_SRC_PORTf_GET(r) ((((r).cmic_cmc_schan_err[0]) >> 14) & 0x3f)
#define CMIC_CMC_SCHAN_ERRr_SRC_PORTf_SET(r,f) (r).cmic_cmc_schan_err[0]=(((r).cmic_cmc_schan_err[0] & ~((uint32_t)0x3f << 14)) | ((((uint32_t)f) & 0x3f) << 14))
#define CMIC_CMC_SCHAN_ERRr_DST_PORTf_GET(r) ((((r).cmic_cmc_schan_err[0]) >> 20) & 0x3f)
#define CMIC_CMC_SCHAN_ERRr_DST_PORTf_SET(r,f) (r).cmic_cmc_schan_err[0]=(((r).cmic_cmc_schan_err[0] & ~((uint32_t)0x3f << 20)) | ((((uint32_t)f) & 0x3f) << 20))
#define CMIC_CMC_SCHAN_ERRr_OP_CODEf_GET(r) ((((r).cmic_cmc_schan_err[0]) >> 26) & 0x3f)
#define CMIC_CMC_SCHAN_ERRr_OP_CODEf_SET(r,f) (r).cmic_cmc_schan_err[0]=(((r).cmic_cmc_schan_err[0] & ~((uint32_t)0x3f << 26)) | ((((uint32_t)f) & 0x3f) << 26))

/*
 * These macros can be used to access CMIC_CMC_SCHAN_ERR.
 *
 */
#define READ_CMIC_CMC_SCHAN_ERRr(u,r) CDK_XGSM_CMC_READ(u,CMIC_CMC_SCHAN_ERRr,r._cmic_cmc_schan_err)
#define WRITE_CMIC_CMC_SCHAN_ERRr(u,r) CDK_XGSM_CMC_WRITE(u,CMIC_CMC_SCHAN_ERRr,r._cmic_cmc_schan_err)

/*******************************************************************************
 * End of 'CMIC_CMC_SCHAN_ERRr'
 ******************************************************************************/




/*******************************************************************************
 * REGISTER:  CMIC_CMC_SCHAN_MESSAGE
 * BLOCKS:   CMIC
 * DESC:     S-bus PIO Message Register Set
 * SIZE:     32
 * FIELDS:
 *     DATA             S-channel data (Rd/Wr) word
 *
 ******************************************************************************/
#define CMIC_CMC_SCHAN_MESSAGEr 0x0003100c

#define CMIC_CMC_SCHAN_MESSAGEr_ENUM 17
#define CMIC_CMC_SCHAN_MESSAGEr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CMC_SCHAN_MESSAGE.
 *
 */
typedef union CMIC_CMC_SCHAN_MESSAGEr_s {
	uint32_t v[1];
	uint32_t cmic_cmc_schan_message[1];
	uint32_t _cmic_cmc_schan_message;
} CMIC_CMC_SCHAN_MESSAGEr_t;

#define CMIC_CMC_SCHAN_MESSAGEr_CLR(r) (r).cmic_cmc_schan_message[0] = 0
#define CMIC_CMC_SCHAN_MESSAGEr_SET(r,d) (r).cmic_cmc_schan_message[0] = d
#define CMIC_CMC_SCHAN_MESSAGEr_GET(r) (r).cmic_cmc_schan_message[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define CMIC_CMC_SCHAN_MESSAGEr_DATAf_GET(r) ((r).cmic_cmc_schan_message[0])
#define CMIC_CMC_SCHAN_MESSAGEr_DATAf_SET(r,f) (r).cmic_cmc_schan_message[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_CMC_SCHAN_MESSAGE.
 *
 */
#define READ_CMIC_CMC_SCHAN_MESSAGEr(u,i,r) CDK_XGSM_CMC_READ(u,CMIC_CMC_SCHAN_MESSAGEr+(4*(i)),r._cmic_cmc_schan_message)
#define WRITE_CMIC_CMC_SCHAN_MESSAGEr(u,i,r) CDK_XGSM_CMC_WRITE(u,CMIC_CMC_SCHAN_MESSAGEr+(4*(i)),r._cmic_cmc_schan_message)

/*******************************************************************************
 * End of 'CMIC_CMC_SCHAN_MESSAGEr'
 ******************************************************************************/




/*******************************************************************************
 * REGISTER:  CMIC_COMMON_PCIE_PIO_ENDIANESS
 * BLOCKS:   CMIC
 * DESC:     PCIE PIO Endianess.
 * SIZE:     32
 * FIELDS:
 *     ENDIANESS        1- PCIE PIO is Big Endian 0- PCIE PIo is Little endian. S/W Should write 32x0101_0101 to set this bit and write 32x0 to reset this bit. 
 *
 ******************************************************************************/
#define CMIC_COMMON_PCIE_PIO_ENDIANESSr 0x000101ec

#define CMIC_COMMON_PCIE_PIO_ENDIANESSr_ENUM 18
#define CMIC_COMMON_PCIE_PIO_ENDIANESSr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_COMMON_PCIE_PIO_ENDIANESS.
 *
 */
typedef union CMIC_COMMON_PCIE_PIO_ENDIANESSr_s {
	uint32_t v[1];
	uint32_t cmic_common_pcie_pio_endianess[1];
	uint32_t _cmic_common_pcie_pio_endianess;
} CMIC_COMMON_PCIE_PIO_ENDIANESSr_t;

#define CMIC_COMMON_PCIE_PIO_ENDIANESSr_CLR(r) (r).cmic_common_pcie_pio_endianess[0] = 0
#define CMIC_COMMON_PCIE_PIO_ENDIANESSr_SET(r,d) (r).cmic_common_pcie_pio_endianess[0] = d
#define CMIC_COMMON_PCIE_PIO_ENDIANESSr_GET(r) (r).cmic_common_pcie_pio_endianess[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define CMIC_COMMON_PCIE_PIO_ENDIANESSr_ENDIANESSf_GET(r) (((r).cmic_common_pcie_pio_endianess[0]) & 0x1)
#define CMIC_COMMON_PCIE_PIO_ENDIANESSr_ENDIANESSf_SET(r,f) (r).cmic_common_pcie_pio_endianess[0]=(((r).cmic_common_pcie_pio_endianess[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access CMIC_COMMON_PCIE_PIO_ENDIANESS.
 *
 */
#define READ_CMIC_COMMON_PCIE_PIO_ENDIANESSr(u,r) CDK_DEV_READ32(u,CMIC_COMMON_PCIE_PIO_ENDIANESSr,r._cmic_common_pcie_pio_endianess)
#define WRITE_CMIC_COMMON_PCIE_PIO_ENDIANESSr(u,r) CDK_DEV_WRITE32(u,CMIC_COMMON_PCIE_PIO_ENDIANESSr,r._cmic_common_pcie_pio_endianess)

/*******************************************************************************
 * End of 'CMIC_COMMON_PCIE_PIO_ENDIANESSr'
 ******************************************************************************/




/*******************************************************************************
 * REGISTER:  CMIC_PCIE_CONFIG
 * BLOCKS:   CMIC
 * DESC:     PCIe Interrupt polarity.
 * SIZE:     32
 * FIELDS:
 *     ACT_LOW_INTR     Level interrupt polarity.
 *     WRITEREQ_PLD_SIZE 0 - MPS, 1 - MRRS, 2 - Min of MPS & MRRS, 3 - Max of MPS & MRRS.
 *     READREQ_PLD_SIZE 0 - MPS, 1 - MRRS, 2 - Min of MPS & MRRS, 3 - Max of MPS & MRRS.
 *
 ******************************************************************************/
#define CMIC_PCIE_CONFIGr 0x00010208

#define CMIC_PCIE_CONFIGr_ENUM 19
#define CMIC_PCIE_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_PCIE_CONFIG.
 *
 */
typedef union CMIC_PCIE_CONFIGr_s {
	uint32_t v[1];
	uint32_t cmic_pcie_config[1];
	uint32_t _cmic_pcie_config;
} CMIC_PCIE_CONFIGr_t;

#define CMIC_PCIE_CONFIGr_CLR(r) (r).cmic_pcie_config[0] = 0
#define CMIC_PCIE_CONFIGr_SET(r,d) (r).cmic_pcie_config[0] = d
#define CMIC_PCIE_CONFIGr_GET(r) (r).cmic_pcie_config[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define CMIC_PCIE_CONFIGr_ACT_LOW_INTRf_GET(r) (((r).cmic_pcie_config[0]) & 0x1)
#define CMIC_PCIE_CONFIGr_ACT_LOW_INTRf_SET(r,f) (r).cmic_pcie_config[0]=(((r).cmic_pcie_config[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CMIC_PCIE_CONFIGr_WRITEREQ_PLD_SIZEf_GET(r) ((((r).cmic_pcie_config[0]) >> 1) & 0x3)
#define CMIC_PCIE_CONFIGr_WRITEREQ_PLD_SIZEf_SET(r,f) (r).cmic_pcie_config[0]=(((r).cmic_pcie_config[0] & ~((uint32_t)0x3 << 1)) | ((((uint32_t)f) & 0x3) << 1))
#define CMIC_PCIE_CONFIGr_READREQ_PLD_SIZEf_GET(r) ((((r).cmic_pcie_config[0]) >> 3) & 0x3)
#define CMIC_PCIE_CONFIGr_READREQ_PLD_SIZEf_SET(r,f) (r).cmic_pcie_config[0]=(((r).cmic_pcie_config[0] & ~((uint32_t)0x3 << 3)) | ((((uint32_t)f) & 0x3) << 3))

/*
 * These macros can be used to access CMIC_PCIE_CONFIG.
 *
 */
#define READ_CMIC_PCIE_CONFIGr(u,r) CDK_DEV_READ32(u,CMIC_PCIE_CONFIGr,r._cmic_pcie_config)
#define WRITE_CMIC_PCIE_CONFIGr(u,r) CDK_DEV_WRITE32(u,CMIC_PCIE_CONFIGr,r._cmic_pcie_config)

/*******************************************************************************
 * End of 'CMIC_PCIE_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * REGISTER:  CMIC_RXBUF_EP_RLS_CRED
 * BLOCKS:   CMIC
 * DESC:     This register has the config bit which when written to 1 will release the max number of credits to the EP block so EP block can send data worth number of credits times 8B. This has to be done only once after both CMIC and EP blocks are out of reset. If EP block is not out of reset, it will not be able to sample the number of credits released to it resulting in hang scenario. Once ininitial credits are released, CMIC block will continue to release the credits as it reads the interface buffer.

 * SIZE:     32
 * FIELDS:
 *     RELEASE_ALL_CREDITS Changing this from 0 to 1, will cause the credits to be released
 *
 ******************************************************************************/
#define CMIC_RXBUF_EP_RLS_CREDr 0x0001a000

#define CMIC_RXBUF_EP_RLS_CREDr_ENUM 20
#define CMIC_RXBUF_EP_RLS_CREDr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_RXBUF_EP_RLS_CRED.
 *
 */
typedef union CMIC_RXBUF_EP_RLS_CREDr_s {
	uint32_t v[1];
	uint32_t cmic_rxbuf_ep_rls_cred[1];
	uint32_t _cmic_rxbuf_ep_rls_cred;
} CMIC_RXBUF_EP_RLS_CREDr_t;

#define CMIC_RXBUF_EP_RLS_CREDr_CLR(r) (r).cmic_rxbuf_ep_rls_cred[0] = 0
#define CMIC_RXBUF_EP_RLS_CREDr_SET(r,d) (r).cmic_rxbuf_ep_rls_cred[0] = d
#define CMIC_RXBUF_EP_RLS_CREDr_GET(r) (r).cmic_rxbuf_ep_rls_cred[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define CMIC_RXBUF_EP_RLS_CREDr_RELEASE_ALL_CREDITSf_GET(r) (((r).cmic_rxbuf_ep_rls_cred[0]) & 0x1)
#define CMIC_RXBUF_EP_RLS_CREDr_RELEASE_ALL_CREDITSf_SET(r,f) (r).cmic_rxbuf_ep_rls_cred[0]=(((r).cmic_rxbuf_ep_rls_cred[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access CMIC_RXBUF_EP_RLS_CRED.
 *
 */
#define READ_CMIC_RXBUF_EP_RLS_CREDr(u,r) CDK_DEV_READ32(u,CMIC_RXBUF_EP_RLS_CREDr,r._cmic_rxbuf_ep_rls_cred)
#define WRITE_CMIC_RXBUF_EP_RLS_CREDr(u,r) CDK_DEV_WRITE32(u,CMIC_RXBUF_EP_RLS_CREDr,r._cmic_rxbuf_ep_rls_cred)

/*******************************************************************************
 * End of 'CMIC_RXBUF_EP_RLS_CREDr'
 ******************************************************************************/




#endif /* __CDK_XGSM_CMIC_H__ */
