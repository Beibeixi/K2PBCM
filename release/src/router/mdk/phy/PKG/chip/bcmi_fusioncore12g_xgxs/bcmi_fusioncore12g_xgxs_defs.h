#ifndef __BCMI_FUSIONCORE12G_XGXS_DEFS_H__
#define __BCMI_FUSIONCORE12G_XGXS_DEFS_H__
/*******************************************************************************
 *
 * $Copyright: Copyright 2013 Broadcom Corporation.
 * This program is the proprietary software of Broadcom Corporation
 * and/or its licensors, and may only be used, duplicated, modified
 * or distributed pursuant to the terms and conditions of a separate,
 * written license agreement executed between you and Broadcom
 * (an "Authorized License").  Except as set forth in an Authorized
 * License, Broadcom grants no license (express or implied), right
 * to use, or waiver of any kind with respect to the Software, and
 * Broadcom expressly reserves all rights in and to the Software
 * and all intellectual property rights therein.  IF YOU HAVE
 * NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
 * IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
 * ALL USE OF THE SOFTWARE.  
 *  
 * Except as expressly set forth in the Authorized License,
 *  
 * 1.     This program, including its structure, sequence and organization,
 * constitutes the valuable trade secrets of Broadcom, and you shall use
 * all reasonable efforts to protect the confidentiality thereof,
 * and to use this information only in connection with your use of
 * Broadcom integrated circuit products.
 *  
 * 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
 * PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
 * REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
 * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
 * DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
 * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
 * ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
 * CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
 * OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
 * 
 * 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
 * BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
 * INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
 * ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
 * TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
 * THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR USD 1.00,
 * WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
 * ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated from the registers file.
 * Edits to this file will be lost when it is regenerated.
 *
 * Definition file for the BCMI_FUSIONCORE12G_XGXS.
 * This file provides all basic definitions required to program the BCMI_FUSIONCORE12G_XGXS.
 *
 * This file is autogenerated. Please do not edit.
 *
 ******************************************************************************/

#include <phy/phy_xgs_iblk.h>

/*******************************************************************************
 *
 *                    CHIP DEFINITIONS BEGIN HERE
 *
 ******************************************************************************/



/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  MII_CTRL
 * BLOCKS:   XAUI
 * REGADDR:  0x0000
 * DESC:     XAUI MII Control Register (Addr 00h)
 * SIZE:     32
 * FIELDS:
 *     MII_CTRL         MII_CTRL
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_MII_CTRLr (0x00000000 | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_MII_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program MII_CTRL.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_MII_CTRLr_s {
	uint32_t v[1];
	uint32_t mii_ctrl[1];
	uint32_t _mii_ctrl;
} BCMI_FUSIONCORE12G_XGXS_MII_CTRLr_t;

#define BCMI_FUSIONCORE12G_XGXS_MII_CTRLr_CLR(r) (r).mii_ctrl[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_MII_CTRLr_SET(r,d) (r).mii_ctrl[0] = d
#define BCMI_FUSIONCORE12G_XGXS_MII_CTRLr_GET(r) (r).mii_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_MII_CTRLr_MII_CTRLf_GET(r) (((r).mii_ctrl[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_MII_CTRLr_MII_CTRLf_SET(r,f) (r).mii_ctrl[0]=(((r).mii_ctrl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access MII_CTRL.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_MII_CTRLr(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_MII_CTRLr,(_r._mii_ctrl))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_MII_CTRLr(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_MII_CTRLr,(_r._mii_ctrl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MII_CTRLr BCMI_FUSIONCORE12G_XGXS_MII_CTRLr
#define MII_CTRLr_SIZE BCMI_FUSIONCORE12G_XGXS_MII_CTRLr_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_MII_CTRLr_t MII_CTRLr_t;
#define MII_CTRLr_CLR BCMI_FUSIONCORE12G_XGXS_MII_CTRLr_CLR
#define MII_CTRLr_SET BCMI_FUSIONCORE12G_XGXS_MII_CTRLr_SET
#define MII_CTRLr_GET BCMI_FUSIONCORE12G_XGXS_MII_CTRLr_GET
#define MII_CTRLr_MII_CTRLf_GET BCMI_FUSIONCORE12G_XGXS_MII_CTRLr_MII_CTRLf_GET
#define MII_CTRLr_MII_CTRLf_SET BCMI_FUSIONCORE12G_XGXS_MII_CTRLr_MII_CTRLf_SET
#define READ_MII_CTRLr BCMI_FUSIONCORE12G_XGXS_READ_MII_CTRLr
#define WRITE_MII_CTRLr BCMI_FUSIONCORE12G_XGXS_WRITE_MII_CTRLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_MII_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  MII_STAT
 * BLOCKS:   XAUI
 * REGADDR:  0x0001
 * DESC:     XAUI MII Status Register (Addr 01h)
 * SIZE:     32
 * FIELDS:
 *     MII_STAT         MII_STAT
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_MII_STATr (0x00000001 | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_MII_STATr_SIZE 4

/*
 * This structure should be used to declare and program MII_STAT.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_MII_STATr_s {
	uint32_t v[1];
	uint32_t mii_stat[1];
	uint32_t _mii_stat;
} BCMI_FUSIONCORE12G_XGXS_MII_STATr_t;

#define BCMI_FUSIONCORE12G_XGXS_MII_STATr_CLR(r) (r).mii_stat[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_MII_STATr_SET(r,d) (r).mii_stat[0] = d
#define BCMI_FUSIONCORE12G_XGXS_MII_STATr_GET(r) (r).mii_stat[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_MII_STATr_MII_STATf_GET(r) (((r).mii_stat[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_MII_STATr_MII_STATf_SET(r,f) (r).mii_stat[0]=(((r).mii_stat[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access MII_STAT.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_MII_STATr(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_MII_STATr,(_r._mii_stat))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_MII_STATr(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_MII_STATr,(_r._mii_stat))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MII_STATr BCMI_FUSIONCORE12G_XGXS_MII_STATr
#define MII_STATr_SIZE BCMI_FUSIONCORE12G_XGXS_MII_STATr_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_MII_STATr_t MII_STATr_t;
#define MII_STATr_CLR BCMI_FUSIONCORE12G_XGXS_MII_STATr_CLR
#define MII_STATr_SET BCMI_FUSIONCORE12G_XGXS_MII_STATr_SET
#define MII_STATr_GET BCMI_FUSIONCORE12G_XGXS_MII_STATr_GET
#define MII_STATr_MII_STATf_GET BCMI_FUSIONCORE12G_XGXS_MII_STATr_MII_STATf_GET
#define MII_STATr_MII_STATf_SET BCMI_FUSIONCORE12G_XGXS_MII_STATr_MII_STATf_SET
#define READ_MII_STATr BCMI_FUSIONCORE12G_XGXS_READ_MII_STATr
#define WRITE_MII_STATr BCMI_FUSIONCORE12G_XGXS_WRITE_MII_STATr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_MII_STATr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  MII_PHY_ID0
 * BLOCKS:   XAUI
 * REGADDR:  0x0002
 * DESC:     XAUI PHY Identifier Register (Addr 02h)
 * SIZE:     32
 * FIELDS:
 *     MII_PHY_ID0      MII_PHY_ID0
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_MII_PHY_ID0r (0x00000002 | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_MII_PHY_ID0r_SIZE 4

/*
 * This structure should be used to declare and program MII_PHY_ID0.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_MII_PHY_ID0r_s {
	uint32_t v[1];
	uint32_t mii_phy_id0[1];
	uint32_t _mii_phy_id0;
} BCMI_FUSIONCORE12G_XGXS_MII_PHY_ID0r_t;

#define BCMI_FUSIONCORE12G_XGXS_MII_PHY_ID0r_CLR(r) (r).mii_phy_id0[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_MII_PHY_ID0r_SET(r,d) (r).mii_phy_id0[0] = d
#define BCMI_FUSIONCORE12G_XGXS_MII_PHY_ID0r_GET(r) (r).mii_phy_id0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_MII_PHY_ID0r_MII_PHY_ID0f_GET(r) (((r).mii_phy_id0[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_MII_PHY_ID0r_MII_PHY_ID0f_SET(r,f) (r).mii_phy_id0[0]=(((r).mii_phy_id0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access MII_PHY_ID0.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_MII_PHY_ID0r(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_MII_PHY_ID0r,(_r._mii_phy_id0))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_MII_PHY_ID0r(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_MII_PHY_ID0r,(_r._mii_phy_id0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MII_PHY_ID0r BCMI_FUSIONCORE12G_XGXS_MII_PHY_ID0r
#define MII_PHY_ID0r_SIZE BCMI_FUSIONCORE12G_XGXS_MII_PHY_ID0r_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_MII_PHY_ID0r_t MII_PHY_ID0r_t;
#define MII_PHY_ID0r_CLR BCMI_FUSIONCORE12G_XGXS_MII_PHY_ID0r_CLR
#define MII_PHY_ID0r_SET BCMI_FUSIONCORE12G_XGXS_MII_PHY_ID0r_SET
#define MII_PHY_ID0r_GET BCMI_FUSIONCORE12G_XGXS_MII_PHY_ID0r_GET
#define MII_PHY_ID0r_MII_PHY_ID0f_GET BCMI_FUSIONCORE12G_XGXS_MII_PHY_ID0r_MII_PHY_ID0f_GET
#define MII_PHY_ID0r_MII_PHY_ID0f_SET BCMI_FUSIONCORE12G_XGXS_MII_PHY_ID0r_MII_PHY_ID0f_SET
#define READ_MII_PHY_ID0r BCMI_FUSIONCORE12G_XGXS_READ_MII_PHY_ID0r
#define WRITE_MII_PHY_ID0r BCMI_FUSIONCORE12G_XGXS_WRITE_MII_PHY_ID0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_MII_PHY_ID0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  MII_PHY_ID1
 * BLOCKS:   XAUI
 * REGADDR:  0x0003
 * DESC:     XAUI PHY Identifier Register (Addr 03h)
 * SIZE:     32
 * FIELDS:
 *     MII_PHY_ID1      MII_PHY_ID1
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_MII_PHY_ID1r (0x00000003 | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_MII_PHY_ID1r_SIZE 4

/*
 * This structure should be used to declare and program MII_PHY_ID1.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_MII_PHY_ID1r_s {
	uint32_t v[1];
	uint32_t mii_phy_id1[1];
	uint32_t _mii_phy_id1;
} BCMI_FUSIONCORE12G_XGXS_MII_PHY_ID1r_t;

#define BCMI_FUSIONCORE12G_XGXS_MII_PHY_ID1r_CLR(r) (r).mii_phy_id1[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_MII_PHY_ID1r_SET(r,d) (r).mii_phy_id1[0] = d
#define BCMI_FUSIONCORE12G_XGXS_MII_PHY_ID1r_GET(r) (r).mii_phy_id1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_MII_PHY_ID1r_MII_PHY_ID1f_GET(r) (((r).mii_phy_id1[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_MII_PHY_ID1r_MII_PHY_ID1f_SET(r,f) (r).mii_phy_id1[0]=(((r).mii_phy_id1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access MII_PHY_ID1.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_MII_PHY_ID1r(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_MII_PHY_ID1r,(_r._mii_phy_id1))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_MII_PHY_ID1r(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_MII_PHY_ID1r,(_r._mii_phy_id1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MII_PHY_ID1r BCMI_FUSIONCORE12G_XGXS_MII_PHY_ID1r
#define MII_PHY_ID1r_SIZE BCMI_FUSIONCORE12G_XGXS_MII_PHY_ID1r_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_MII_PHY_ID1r_t MII_PHY_ID1r_t;
#define MII_PHY_ID1r_CLR BCMI_FUSIONCORE12G_XGXS_MII_PHY_ID1r_CLR
#define MII_PHY_ID1r_SET BCMI_FUSIONCORE12G_XGXS_MII_PHY_ID1r_SET
#define MII_PHY_ID1r_GET BCMI_FUSIONCORE12G_XGXS_MII_PHY_ID1r_GET
#define MII_PHY_ID1r_MII_PHY_ID1f_GET BCMI_FUSIONCORE12G_XGXS_MII_PHY_ID1r_MII_PHY_ID1f_GET
#define MII_PHY_ID1r_MII_PHY_ID1f_SET BCMI_FUSIONCORE12G_XGXS_MII_PHY_ID1r_MII_PHY_ID1f_SET
#define READ_MII_PHY_ID1r BCMI_FUSIONCORE12G_XGXS_READ_MII_PHY_ID1r
#define WRITE_MII_PHY_ID1r BCMI_FUSIONCORE12G_XGXS_WRITE_MII_PHY_ID1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_MII_PHY_ID1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  TX_DISABLE
 * BLOCKS:   XAUI
 * REGADDR:  0x0009
 * DESC:     IEEE Tx Disable (Addr 09h)
 * SIZE:     32
 * FIELDS:
 *     TX_DISABLE       TX_DISABLE
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_TX_DISABLEr (0x00000009 | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_TX_DISABLEr_SIZE 4

/*
 * This structure should be used to declare and program TX_DISABLE.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_TX_DISABLEr_s {
	uint32_t v[1];
	uint32_t tx_disable[1];
	uint32_t _tx_disable;
} BCMI_FUSIONCORE12G_XGXS_TX_DISABLEr_t;

#define BCMI_FUSIONCORE12G_XGXS_TX_DISABLEr_CLR(r) (r).tx_disable[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_TX_DISABLEr_SET(r,d) (r).tx_disable[0] = d
#define BCMI_FUSIONCORE12G_XGXS_TX_DISABLEr_GET(r) (r).tx_disable[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_TX_DISABLEr_TX_DISABLEf_GET(r) (((r).tx_disable[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_TX_DISABLEr_TX_DISABLEf_SET(r,f) (r).tx_disable[0]=(((r).tx_disable[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access TX_DISABLE.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_TX_DISABLEr(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_TX_DISABLEr,(_r._tx_disable))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_TX_DISABLEr(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_TX_DISABLEr,(_r._tx_disable))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TX_DISABLEr BCMI_FUSIONCORE12G_XGXS_TX_DISABLEr
#define TX_DISABLEr_SIZE BCMI_FUSIONCORE12G_XGXS_TX_DISABLEr_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_TX_DISABLEr_t TX_DISABLEr_t;
#define TX_DISABLEr_CLR BCMI_FUSIONCORE12G_XGXS_TX_DISABLEr_CLR
#define TX_DISABLEr_SET BCMI_FUSIONCORE12G_XGXS_TX_DISABLEr_SET
#define TX_DISABLEr_GET BCMI_FUSIONCORE12G_XGXS_TX_DISABLEr_GET
#define TX_DISABLEr_TX_DISABLEf_GET BCMI_FUSIONCORE12G_XGXS_TX_DISABLEr_TX_DISABLEf_GET
#define TX_DISABLEr_TX_DISABLEf_SET BCMI_FUSIONCORE12G_XGXS_TX_DISABLEr_TX_DISABLEf_SET
#define READ_TX_DISABLEr BCMI_FUSIONCORE12G_XGXS_READ_TX_DISABLEr
#define WRITE_TX_DISABLEr BCMI_FUSIONCORE12G_XGXS_WRITE_TX_DISABLEr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_TX_DISABLEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  LANE_STAT
 * BLOCKS:   IEEE1
 * REGADDR:  0x0018
 * DESC:     Lane Status (Addr 0x0018)
 * SIZE:     32
 * FIELDS:
 *     LANE_STAT        LANE_STAT
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_LANE_STATr (0x00001008 | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_LANE_STATr_SIZE 4

/*
 * This structure should be used to declare and program LANE_STAT.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_LANE_STATr_s {
	uint32_t v[1];
	uint32_t lane_stat[1];
	uint32_t _lane_stat;
} BCMI_FUSIONCORE12G_XGXS_LANE_STATr_t;

#define BCMI_FUSIONCORE12G_XGXS_LANE_STATr_CLR(r) (r).lane_stat[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_LANE_STATr_SET(r,d) (r).lane_stat[0] = d
#define BCMI_FUSIONCORE12G_XGXS_LANE_STATr_GET(r) (r).lane_stat[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_LANE_STATr_LANE_STATf_GET(r) (((r).lane_stat[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_LANE_STATr_LANE_STATf_SET(r,f) (r).lane_stat[0]=(((r).lane_stat[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access LANE_STAT.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_LANE_STATr(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_LANE_STATr,(_r._lane_stat))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_LANE_STATr(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_LANE_STATr,(_r._lane_stat))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define LANE_STATr BCMI_FUSIONCORE12G_XGXS_LANE_STATr
#define LANE_STATr_SIZE BCMI_FUSIONCORE12G_XGXS_LANE_STATr_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_LANE_STATr_t LANE_STATr_t;
#define LANE_STATr_CLR BCMI_FUSIONCORE12G_XGXS_LANE_STATr_CLR
#define LANE_STATr_SET BCMI_FUSIONCORE12G_XGXS_LANE_STATr_SET
#define LANE_STATr_GET BCMI_FUSIONCORE12G_XGXS_LANE_STATr_GET
#define LANE_STATr_LANE_STATf_GET BCMI_FUSIONCORE12G_XGXS_LANE_STATr_LANE_STATf_GET
#define LANE_STATr_LANE_STATf_SET BCMI_FUSIONCORE12G_XGXS_LANE_STATr_LANE_STATf_SET
#define READ_LANE_STATr BCMI_FUSIONCORE12G_XGXS_READ_LANE_STATr
#define WRITE_LANE_STATr BCMI_FUSIONCORE12G_XGXS_WRITE_LANE_STATr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_LANE_STATr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  CTRL
 * BLOCKS:   BLK0
 * REGADDR:  0x8000
 * DESC:     XGXS5 Control (Addr 0x8000)
 * SIZE:     32
 * FIELDS:
 *     CTRL             CTRL
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_CTRLr (0x00000010 | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program CTRL.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_CTRLr_s {
	uint32_t v[1];
	uint32_t ctrl[1];
	uint32_t _ctrl;
} BCMI_FUSIONCORE12G_XGXS_CTRLr_t;

#define BCMI_FUSIONCORE12G_XGXS_CTRLr_CLR(r) (r).ctrl[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_CTRLr_SET(r,d) (r).ctrl[0] = d
#define BCMI_FUSIONCORE12G_XGXS_CTRLr_GET(r) (r).ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_CTRLr_CTRLf_GET(r) (((r).ctrl[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_CTRLr_CTRLf_SET(r,f) (r).ctrl[0]=(((r).ctrl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access CTRL.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_CTRLr(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_CTRLr,(_r._ctrl))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_CTRLr(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_CTRLr,(_r._ctrl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CTRLr BCMI_FUSIONCORE12G_XGXS_CTRLr
#define CTRLr_SIZE BCMI_FUSIONCORE12G_XGXS_CTRLr_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_CTRLr_t CTRLr_t;
#define CTRLr_CLR BCMI_FUSIONCORE12G_XGXS_CTRLr_CLR
#define CTRLr_SET BCMI_FUSIONCORE12G_XGXS_CTRLr_SET
#define CTRLr_GET BCMI_FUSIONCORE12G_XGXS_CTRLr_GET
#define CTRLr_CTRLf_GET BCMI_FUSIONCORE12G_XGXS_CTRLr_CTRLf_GET
#define CTRLr_CTRLf_SET BCMI_FUSIONCORE12G_XGXS_CTRLr_CTRLf_SET
#define READ_CTRLr BCMI_FUSIONCORE12G_XGXS_READ_CTRLr
#define WRITE_CTRLr BCMI_FUSIONCORE12G_XGXS_WRITE_CTRLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  STAT
 * BLOCKS:   BLK0
 * REGADDR:  0x8001
 * DESC:     XGXS5 Status (Addr 0x8001)
 * SIZE:     32
 * FIELDS:
 *     STAT             STAT
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_STATr (0x00000011 | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_STATr_SIZE 4

/*
 * This structure should be used to declare and program STAT.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_STATr_s {
	uint32_t v[1];
	uint32_t stat[1];
	uint32_t _stat;
} BCMI_FUSIONCORE12G_XGXS_STATr_t;

#define BCMI_FUSIONCORE12G_XGXS_STATr_CLR(r) (r).stat[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_STATr_SET(r,d) (r).stat[0] = d
#define BCMI_FUSIONCORE12G_XGXS_STATr_GET(r) (r).stat[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_STATr_STATf_GET(r) (((r).stat[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_STATr_STATf_SET(r,f) (r).stat[0]=(((r).stat[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access STAT.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_STATr(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_STATr,(_r._stat))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_STATr(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_STATr,(_r._stat))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define STATr BCMI_FUSIONCORE12G_XGXS_STATr
#define STATr_SIZE BCMI_FUSIONCORE12G_XGXS_STATr_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_STATr_t STATr_t;
#define STATr_CLR BCMI_FUSIONCORE12G_XGXS_STATr_CLR
#define STATr_SET BCMI_FUSIONCORE12G_XGXS_STATr_SET
#define STATr_GET BCMI_FUSIONCORE12G_XGXS_STATr_GET
#define STATr_STATf_GET BCMI_FUSIONCORE12G_XGXS_STATr_STATf_GET
#define STATr_STATf_SET BCMI_FUSIONCORE12G_XGXS_STATr_STATf_SET
#define READ_STATr BCMI_FUSIONCORE12G_XGXS_READ_STATr
#define WRITE_STATr BCMI_FUSIONCORE12G_XGXS_WRITE_STATr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_STATr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  XGMII_IDLE
 * BLOCKS:   BLK0
 * REGADDR:  0x8002
 * DESC:     XGMII Idle (Addr 0x8002)
 * SIZE:     32
 * FIELDS:
 *     XGMII_IDLE       XGMII_IDLE
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_XGMII_IDLEr (0x00000012 | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_XGMII_IDLEr_SIZE 4

/*
 * This structure should be used to declare and program XGMII_IDLE.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_XGMII_IDLEr_s {
	uint32_t v[1];
	uint32_t xgmii_idle[1];
	uint32_t _xgmii_idle;
} BCMI_FUSIONCORE12G_XGXS_XGMII_IDLEr_t;

#define BCMI_FUSIONCORE12G_XGXS_XGMII_IDLEr_CLR(r) (r).xgmii_idle[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_XGMII_IDLEr_SET(r,d) (r).xgmii_idle[0] = d
#define BCMI_FUSIONCORE12G_XGXS_XGMII_IDLEr_GET(r) (r).xgmii_idle[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_XGMII_IDLEr_XGMII_IDLEf_GET(r) (((r).xgmii_idle[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_XGMII_IDLEr_XGMII_IDLEf_SET(r,f) (r).xgmii_idle[0]=(((r).xgmii_idle[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access XGMII_IDLE.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_XGMII_IDLEr(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_XGMII_IDLEr,(_r._xgmii_idle))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_XGMII_IDLEr(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_XGMII_IDLEr,(_r._xgmii_idle))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define XGMII_IDLEr BCMI_FUSIONCORE12G_XGXS_XGMII_IDLEr
#define XGMII_IDLEr_SIZE BCMI_FUSIONCORE12G_XGXS_XGMII_IDLEr_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_XGMII_IDLEr_t XGMII_IDLEr_t;
#define XGMII_IDLEr_CLR BCMI_FUSIONCORE12G_XGXS_XGMII_IDLEr_CLR
#define XGMII_IDLEr_SET BCMI_FUSIONCORE12G_XGXS_XGMII_IDLEr_SET
#define XGMII_IDLEr_GET BCMI_FUSIONCORE12G_XGXS_XGMII_IDLEr_GET
#define XGMII_IDLEr_XGMII_IDLEf_GET BCMI_FUSIONCORE12G_XGXS_XGMII_IDLEr_XGMII_IDLEf_GET
#define XGMII_IDLEr_XGMII_IDLEf_SET BCMI_FUSIONCORE12G_XGXS_XGMII_IDLEr_XGMII_IDLEf_SET
#define READ_XGMII_IDLEr BCMI_FUSIONCORE12G_XGXS_READ_XGMII_IDLEr
#define WRITE_XGMII_IDLEr BCMI_FUSIONCORE12G_XGXS_WRITE_XGMII_IDLEr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_XGMII_IDLEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  XGMII_SYNC
 * BLOCKS:   BLK0
 * REGADDR:  0x8003
 * DESC:     XGMII Sync (Addr 0x8003)
 * SIZE:     32
 * FIELDS:
 *     XGMII_SYNC       XGMII_SYNC
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_XGMII_SYNCr (0x00000013 | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_XGMII_SYNCr_SIZE 4

/*
 * This structure should be used to declare and program XGMII_SYNC.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_XGMII_SYNCr_s {
	uint32_t v[1];
	uint32_t xgmii_sync[1];
	uint32_t _xgmii_sync;
} BCMI_FUSIONCORE12G_XGXS_XGMII_SYNCr_t;

#define BCMI_FUSIONCORE12G_XGXS_XGMII_SYNCr_CLR(r) (r).xgmii_sync[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_XGMII_SYNCr_SET(r,d) (r).xgmii_sync[0] = d
#define BCMI_FUSIONCORE12G_XGXS_XGMII_SYNCr_GET(r) (r).xgmii_sync[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_XGMII_SYNCr_XGMII_SYNCf_GET(r) (((r).xgmii_sync[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_XGMII_SYNCr_XGMII_SYNCf_SET(r,f) (r).xgmii_sync[0]=(((r).xgmii_sync[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access XGMII_SYNC.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_XGMII_SYNCr(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_XGMII_SYNCr,(_r._xgmii_sync))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_XGMII_SYNCr(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_XGMII_SYNCr,(_r._xgmii_sync))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define XGMII_SYNCr BCMI_FUSIONCORE12G_XGXS_XGMII_SYNCr
#define XGMII_SYNCr_SIZE BCMI_FUSIONCORE12G_XGXS_XGMII_SYNCr_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_XGMII_SYNCr_t XGMII_SYNCr_t;
#define XGMII_SYNCr_CLR BCMI_FUSIONCORE12G_XGXS_XGMII_SYNCr_CLR
#define XGMII_SYNCr_SET BCMI_FUSIONCORE12G_XGXS_XGMII_SYNCr_SET
#define XGMII_SYNCr_GET BCMI_FUSIONCORE12G_XGXS_XGMII_SYNCr_GET
#define XGMII_SYNCr_XGMII_SYNCf_GET BCMI_FUSIONCORE12G_XGXS_XGMII_SYNCr_XGMII_SYNCf_GET
#define XGMII_SYNCr_XGMII_SYNCf_SET BCMI_FUSIONCORE12G_XGXS_XGMII_SYNCr_XGMII_SYNCf_SET
#define READ_XGMII_SYNCr BCMI_FUSIONCORE12G_XGXS_READ_XGMII_SYNCr
#define WRITE_XGMII_SYNCr BCMI_FUSIONCORE12G_XGXS_WRITE_XGMII_SYNCr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_XGMII_SYNCr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  XGMII_SKIP
 * BLOCKS:   BLK0
 * REGADDR:  0x8004
 * DESC:     XGMII Skip (Addr 0x8004)
 * SIZE:     32
 * FIELDS:
 *     XGMII_SKIP       XGMII_SKIP
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_XGMII_SKIPr (0x00000014 | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_XGMII_SKIPr_SIZE 4

/*
 * This structure should be used to declare and program XGMII_SKIP.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_XGMII_SKIPr_s {
	uint32_t v[1];
	uint32_t xgmii_skip[1];
	uint32_t _xgmii_skip;
} BCMI_FUSIONCORE12G_XGXS_XGMII_SKIPr_t;

#define BCMI_FUSIONCORE12G_XGXS_XGMII_SKIPr_CLR(r) (r).xgmii_skip[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_XGMII_SKIPr_SET(r,d) (r).xgmii_skip[0] = d
#define BCMI_FUSIONCORE12G_XGXS_XGMII_SKIPr_GET(r) (r).xgmii_skip[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_XGMII_SKIPr_XGMII_SKIPf_GET(r) (((r).xgmii_skip[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_XGMII_SKIPr_XGMII_SKIPf_SET(r,f) (r).xgmii_skip[0]=(((r).xgmii_skip[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access XGMII_SKIP.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_XGMII_SKIPr(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_XGMII_SKIPr,(_r._xgmii_skip))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_XGMII_SKIPr(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_XGMII_SKIPr,(_r._xgmii_skip))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define XGMII_SKIPr BCMI_FUSIONCORE12G_XGXS_XGMII_SKIPr
#define XGMII_SKIPr_SIZE BCMI_FUSIONCORE12G_XGXS_XGMII_SKIPr_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_XGMII_SKIPr_t XGMII_SKIPr_t;
#define XGMII_SKIPr_CLR BCMI_FUSIONCORE12G_XGXS_XGMII_SKIPr_CLR
#define XGMII_SKIPr_SET BCMI_FUSIONCORE12G_XGXS_XGMII_SKIPr_SET
#define XGMII_SKIPr_GET BCMI_FUSIONCORE12G_XGXS_XGMII_SKIPr_GET
#define XGMII_SKIPr_XGMII_SKIPf_GET BCMI_FUSIONCORE12G_XGXS_XGMII_SKIPr_XGMII_SKIPf_GET
#define XGMII_SKIPr_XGMII_SKIPf_SET BCMI_FUSIONCORE12G_XGXS_XGMII_SKIPr_XGMII_SKIPf_SET
#define READ_XGMII_SKIPr BCMI_FUSIONCORE12G_XGXS_READ_XGMII_SKIPr
#define WRITE_XGMII_SKIPr BCMI_FUSIONCORE12G_XGXS_WRITE_XGMII_SKIPr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_XGMII_SKIPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  XGMII_SOP_EOP
 * BLOCKS:   BLK0
 * REGADDR:  0x8005
 * DESC:     XGMII Sop Eop (Addr 0x8005)
 * SIZE:     32
 * FIELDS:
 *     XGMII_SOP_EOP    XGMII_SOP_EOP
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_XGMII_SOP_EOPr (0x00000015 | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_XGMII_SOP_EOPr_SIZE 4

/*
 * This structure should be used to declare and program XGMII_SOP_EOP.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_XGMII_SOP_EOPr_s {
	uint32_t v[1];
	uint32_t xgmii_sop_eop[1];
	uint32_t _xgmii_sop_eop;
} BCMI_FUSIONCORE12G_XGXS_XGMII_SOP_EOPr_t;

#define BCMI_FUSIONCORE12G_XGXS_XGMII_SOP_EOPr_CLR(r) (r).xgmii_sop_eop[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_XGMII_SOP_EOPr_SET(r,d) (r).xgmii_sop_eop[0] = d
#define BCMI_FUSIONCORE12G_XGXS_XGMII_SOP_EOPr_GET(r) (r).xgmii_sop_eop[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_XGMII_SOP_EOPr_XGMII_SOP_EOPf_GET(r) (((r).xgmii_sop_eop[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_XGMII_SOP_EOPr_XGMII_SOP_EOPf_SET(r,f) (r).xgmii_sop_eop[0]=(((r).xgmii_sop_eop[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access XGMII_SOP_EOP.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_XGMII_SOP_EOPr(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_XGMII_SOP_EOPr,(_r._xgmii_sop_eop))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_XGMII_SOP_EOPr(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_XGMII_SOP_EOPr,(_r._xgmii_sop_eop))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define XGMII_SOP_EOPr BCMI_FUSIONCORE12G_XGXS_XGMII_SOP_EOPr
#define XGMII_SOP_EOPr_SIZE BCMI_FUSIONCORE12G_XGXS_XGMII_SOP_EOPr_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_XGMII_SOP_EOPr_t XGMII_SOP_EOPr_t;
#define XGMII_SOP_EOPr_CLR BCMI_FUSIONCORE12G_XGXS_XGMII_SOP_EOPr_CLR
#define XGMII_SOP_EOPr_SET BCMI_FUSIONCORE12G_XGXS_XGMII_SOP_EOPr_SET
#define XGMII_SOP_EOPr_GET BCMI_FUSIONCORE12G_XGXS_XGMII_SOP_EOPr_GET
#define XGMII_SOP_EOPr_XGMII_SOP_EOPf_GET BCMI_FUSIONCORE12G_XGXS_XGMII_SOP_EOPr_XGMII_SOP_EOPf_GET
#define XGMII_SOP_EOPr_XGMII_SOP_EOPf_SET BCMI_FUSIONCORE12G_XGXS_XGMII_SOP_EOPr_XGMII_SOP_EOPf_SET
#define READ_XGMII_SOP_EOPr BCMI_FUSIONCORE12G_XGXS_READ_XGMII_SOP_EOPr
#define WRITE_XGMII_SOP_EOPr BCMI_FUSIONCORE12G_XGXS_WRITE_XGMII_SOP_EOPr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_XGMII_SOP_EOPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  XGMII_ALIGN
 * BLOCKS:   BLK0
 * REGADDR:  0x8006
 * DESC:     XGMII Align (Addr 0x8006)
 * SIZE:     32
 * FIELDS:
 *     XGMII_ALIGN      XGMII_ALIGN
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_XGMII_ALIGNr (0x00000016 | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_XGMII_ALIGNr_SIZE 4

/*
 * This structure should be used to declare and program XGMII_ALIGN.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_XGMII_ALIGNr_s {
	uint32_t v[1];
	uint32_t xgmii_align[1];
	uint32_t _xgmii_align;
} BCMI_FUSIONCORE12G_XGXS_XGMII_ALIGNr_t;

#define BCMI_FUSIONCORE12G_XGXS_XGMII_ALIGNr_CLR(r) (r).xgmii_align[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_XGMII_ALIGNr_SET(r,d) (r).xgmii_align[0] = d
#define BCMI_FUSIONCORE12G_XGXS_XGMII_ALIGNr_GET(r) (r).xgmii_align[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_XGMII_ALIGNr_XGMII_ALIGNf_GET(r) (((r).xgmii_align[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_XGMII_ALIGNr_XGMII_ALIGNf_SET(r,f) (r).xgmii_align[0]=(((r).xgmii_align[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access XGMII_ALIGN.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_XGMII_ALIGNr(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_XGMII_ALIGNr,(_r._xgmii_align))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_XGMII_ALIGNr(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_XGMII_ALIGNr,(_r._xgmii_align))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define XGMII_ALIGNr BCMI_FUSIONCORE12G_XGXS_XGMII_ALIGNr
#define XGMII_ALIGNr_SIZE BCMI_FUSIONCORE12G_XGXS_XGMII_ALIGNr_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_XGMII_ALIGNr_t XGMII_ALIGNr_t;
#define XGMII_ALIGNr_CLR BCMI_FUSIONCORE12G_XGXS_XGMII_ALIGNr_CLR
#define XGMII_ALIGNr_SET BCMI_FUSIONCORE12G_XGXS_XGMII_ALIGNr_SET
#define XGMII_ALIGNr_GET BCMI_FUSIONCORE12G_XGXS_XGMII_ALIGNr_GET
#define XGMII_ALIGNr_XGMII_ALIGNf_GET BCMI_FUSIONCORE12G_XGXS_XGMII_ALIGNr_XGMII_ALIGNf_GET
#define XGMII_ALIGNr_XGMII_ALIGNf_SET BCMI_FUSIONCORE12G_XGXS_XGMII_ALIGNr_XGMII_ALIGNf_SET
#define READ_XGMII_ALIGNr BCMI_FUSIONCORE12G_XGXS_READ_XGMII_ALIGNr
#define WRITE_XGMII_ALIGNr BCMI_FUSIONCORE12G_XGXS_WRITE_XGMII_ALIGNr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_XGMII_ALIGNr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  XGMII_RCTRL
 * BLOCKS:   BLK0
 * REGADDR:  0x8007
 * DESC:     XGMII R Control (Addr 0x8007)
 * SIZE:     32
 * FIELDS:
 *     XGMII_RCTRL      XGMII_RCTRL
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_XGMII_RCTRLr (0x00000017 | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_XGMII_RCTRLr_SIZE 4

/*
 * This structure should be used to declare and program XGMII_RCTRL.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_XGMII_RCTRLr_s {
	uint32_t v[1];
	uint32_t xgmii_rctrl[1];
	uint32_t _xgmii_rctrl;
} BCMI_FUSIONCORE12G_XGXS_XGMII_RCTRLr_t;

#define BCMI_FUSIONCORE12G_XGXS_XGMII_RCTRLr_CLR(r) (r).xgmii_rctrl[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_XGMII_RCTRLr_SET(r,d) (r).xgmii_rctrl[0] = d
#define BCMI_FUSIONCORE12G_XGXS_XGMII_RCTRLr_GET(r) (r).xgmii_rctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_XGMII_RCTRLr_XGMII_RCTRLf_GET(r) (((r).xgmii_rctrl[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_XGMII_RCTRLr_XGMII_RCTRLf_SET(r,f) (r).xgmii_rctrl[0]=(((r).xgmii_rctrl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access XGMII_RCTRL.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_XGMII_RCTRLr(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_XGMII_RCTRLr,(_r._xgmii_rctrl))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_XGMII_RCTRLr(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_XGMII_RCTRLr,(_r._xgmii_rctrl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define XGMII_RCTRLr BCMI_FUSIONCORE12G_XGXS_XGMII_RCTRLr
#define XGMII_RCTRLr_SIZE BCMI_FUSIONCORE12G_XGXS_XGMII_RCTRLr_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_XGMII_RCTRLr_t XGMII_RCTRLr_t;
#define XGMII_RCTRLr_CLR BCMI_FUSIONCORE12G_XGXS_XGMII_RCTRLr_CLR
#define XGMII_RCTRLr_SET BCMI_FUSIONCORE12G_XGXS_XGMII_RCTRLr_SET
#define XGMII_RCTRLr_GET BCMI_FUSIONCORE12G_XGXS_XGMII_RCTRLr_GET
#define XGMII_RCTRLr_XGMII_RCTRLf_GET BCMI_FUSIONCORE12G_XGXS_XGMII_RCTRLr_XGMII_RCTRLf_GET
#define XGMII_RCTRLr_XGMII_RCTRLf_SET BCMI_FUSIONCORE12G_XGXS_XGMII_RCTRLr_XGMII_RCTRLf_SET
#define READ_XGMII_RCTRLr BCMI_FUSIONCORE12G_XGXS_READ_XGMII_RCTRLr
#define WRITE_XGMII_RCTRLr BCMI_FUSIONCORE12G_XGXS_WRITE_XGMII_RCTRLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_XGMII_RCTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  XGMII_TCTRL
 * BLOCKS:   BLK0
 * REGADDR:  0x8008
 * DESC:     XGMII T Control (Addr 0x8008)
 * SIZE:     32
 * FIELDS:
 *     XGMII_TCTRL      XGMII_TCTRL
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_XGMII_TCTRLr (0x00000018 | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_XGMII_TCTRLr_SIZE 4

/*
 * This structure should be used to declare and program XGMII_TCTRL.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_XGMII_TCTRLr_s {
	uint32_t v[1];
	uint32_t xgmii_tctrl[1];
	uint32_t _xgmii_tctrl;
} BCMI_FUSIONCORE12G_XGXS_XGMII_TCTRLr_t;

#define BCMI_FUSIONCORE12G_XGXS_XGMII_TCTRLr_CLR(r) (r).xgmii_tctrl[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_XGMII_TCTRLr_SET(r,d) (r).xgmii_tctrl[0] = d
#define BCMI_FUSIONCORE12G_XGXS_XGMII_TCTRLr_GET(r) (r).xgmii_tctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_XGMII_TCTRLr_XGMII_TCTRLf_GET(r) (((r).xgmii_tctrl[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_XGMII_TCTRLr_XGMII_TCTRLf_SET(r,f) (r).xgmii_tctrl[0]=(((r).xgmii_tctrl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access XGMII_TCTRL.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_XGMII_TCTRLr(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_XGMII_TCTRLr,(_r._xgmii_tctrl))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_XGMII_TCTRLr(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_XGMII_TCTRLr,(_r._xgmii_tctrl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define XGMII_TCTRLr BCMI_FUSIONCORE12G_XGXS_XGMII_TCTRLr
#define XGMII_TCTRLr_SIZE BCMI_FUSIONCORE12G_XGXS_XGMII_TCTRLr_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_XGMII_TCTRLr_t XGMII_TCTRLr_t;
#define XGMII_TCTRLr_CLR BCMI_FUSIONCORE12G_XGXS_XGMII_TCTRLr_CLR
#define XGMII_TCTRLr_SET BCMI_FUSIONCORE12G_XGXS_XGMII_TCTRLr_SET
#define XGMII_TCTRLr_GET BCMI_FUSIONCORE12G_XGXS_XGMII_TCTRLr_GET
#define XGMII_TCTRLr_XGMII_TCTRLf_GET BCMI_FUSIONCORE12G_XGXS_XGMII_TCTRLr_XGMII_TCTRLf_GET
#define XGMII_TCTRLr_XGMII_TCTRLf_SET BCMI_FUSIONCORE12G_XGXS_XGMII_TCTRLr_XGMII_TCTRLf_SET
#define READ_XGMII_TCTRLr BCMI_FUSIONCORE12G_XGXS_READ_XGMII_TCTRLr
#define WRITE_XGMII_TCTRLr BCMI_FUSIONCORE12G_XGXS_WRITE_XGMII_TCTRLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_XGMII_TCTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  XGMII_SWAP
 * BLOCKS:   BLK0
 * REGADDR:  0x8009
 * DESC:     XGMII Swap (Addr 0x8009)
 * SIZE:     32
 * FIELDS:
 *     XGMII_SWAP       XGMII_SWAP
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_XGMII_SWAPr (0x00000019 | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_XGMII_SWAPr_SIZE 4

/*
 * This structure should be used to declare and program XGMII_SWAP.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_XGMII_SWAPr_s {
	uint32_t v[1];
	uint32_t xgmii_swap[1];
	uint32_t _xgmii_swap;
} BCMI_FUSIONCORE12G_XGXS_XGMII_SWAPr_t;

#define BCMI_FUSIONCORE12G_XGXS_XGMII_SWAPr_CLR(r) (r).xgmii_swap[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_XGMII_SWAPr_SET(r,d) (r).xgmii_swap[0] = d
#define BCMI_FUSIONCORE12G_XGXS_XGMII_SWAPr_GET(r) (r).xgmii_swap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_XGMII_SWAPr_XGMII_SWAPf_GET(r) (((r).xgmii_swap[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_XGMII_SWAPr_XGMII_SWAPf_SET(r,f) (r).xgmii_swap[0]=(((r).xgmii_swap[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access XGMII_SWAP.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_XGMII_SWAPr(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_XGMII_SWAPr,(_r._xgmii_swap))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_XGMII_SWAPr(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_XGMII_SWAPr,(_r._xgmii_swap))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define XGMII_SWAPr BCMI_FUSIONCORE12G_XGXS_XGMII_SWAPr
#define XGMII_SWAPr_SIZE BCMI_FUSIONCORE12G_XGXS_XGMII_SWAPr_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_XGMII_SWAPr_t XGMII_SWAPr_t;
#define XGMII_SWAPr_CLR BCMI_FUSIONCORE12G_XGXS_XGMII_SWAPr_CLR
#define XGMII_SWAPr_SET BCMI_FUSIONCORE12G_XGXS_XGMII_SWAPr_SET
#define XGMII_SWAPr_GET BCMI_FUSIONCORE12G_XGXS_XGMII_SWAPr_GET
#define XGMII_SWAPr_XGMII_SWAPf_GET BCMI_FUSIONCORE12G_XGXS_XGMII_SWAPr_XGMII_SWAPf_GET
#define XGMII_SWAPr_XGMII_SWAPf_SET BCMI_FUSIONCORE12G_XGXS_XGMII_SWAPr_XGMII_SWAPf_SET
#define READ_XGMII_SWAPr BCMI_FUSIONCORE12G_XGXS_READ_XGMII_SWAPr
#define WRITE_XGMII_SWAPr BCMI_FUSIONCORE12G_XGXS_WRITE_XGMII_SWAPr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_XGMII_SWAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  ISS_LSID
 * BLOCKS:   BLK0
 * REGADDR:  0x800a
 * DESC:     IssLsid (Addr 0x800A)
 * SIZE:     32
 * FIELDS:
 *     ISS_LSID         ISS_LSID
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_ISS_LSIDr (0x0000001a | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_ISS_LSIDr_SIZE 4

/*
 * This structure should be used to declare and program ISS_LSID.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_ISS_LSIDr_s {
	uint32_t v[1];
	uint32_t iss_lsid[1];
	uint32_t _iss_lsid;
} BCMI_FUSIONCORE12G_XGXS_ISS_LSIDr_t;

#define BCMI_FUSIONCORE12G_XGXS_ISS_LSIDr_CLR(r) (r).iss_lsid[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_ISS_LSIDr_SET(r,d) (r).iss_lsid[0] = d
#define BCMI_FUSIONCORE12G_XGXS_ISS_LSIDr_GET(r) (r).iss_lsid[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_ISS_LSIDr_ISS_LSIDf_GET(r) (((r).iss_lsid[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_ISS_LSIDr_ISS_LSIDf_SET(r,f) (r).iss_lsid[0]=(((r).iss_lsid[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access ISS_LSID.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_ISS_LSIDr(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_ISS_LSIDr,(_r._iss_lsid))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_ISS_LSIDr(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_ISS_LSIDr,(_r._iss_lsid))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define ISS_LSIDr BCMI_FUSIONCORE12G_XGXS_ISS_LSIDr
#define ISS_LSIDr_SIZE BCMI_FUSIONCORE12G_XGXS_ISS_LSIDr_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_ISS_LSIDr_t ISS_LSIDr_t;
#define ISS_LSIDr_CLR BCMI_FUSIONCORE12G_XGXS_ISS_LSIDr_CLR
#define ISS_LSIDr_SET BCMI_FUSIONCORE12G_XGXS_ISS_LSIDr_SET
#define ISS_LSIDr_GET BCMI_FUSIONCORE12G_XGXS_ISS_LSIDr_GET
#define ISS_LSIDr_ISS_LSIDf_GET BCMI_FUSIONCORE12G_XGXS_ISS_LSIDr_ISS_LSIDf_GET
#define ISS_LSIDr_ISS_LSIDf_SET BCMI_FUSIONCORE12G_XGXS_ISS_LSIDr_ISS_LSIDf_SET
#define READ_ISS_LSIDr BCMI_FUSIONCORE12G_XGXS_READ_ISS_LSIDr
#define WRITE_ISS_LSIDr BCMI_FUSIONCORE12G_XGXS_WRITE_ISS_LSIDr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_ISS_LSIDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  ISS_TINFO
 * BLOCKS:   BLK0
 * REGADDR:  0x800b
 * DESC:     IssTinfo (Addr 0x800B)
 * SIZE:     32
 * FIELDS:
 *     ISS_TINFO        ISS_TINFO
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_ISS_TINFOr (0x0000001b | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_ISS_TINFOr_SIZE 4

/*
 * This structure should be used to declare and program ISS_TINFO.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_ISS_TINFOr_s {
	uint32_t v[1];
	uint32_t iss_tinfo[1];
	uint32_t _iss_tinfo;
} BCMI_FUSIONCORE12G_XGXS_ISS_TINFOr_t;

#define BCMI_FUSIONCORE12G_XGXS_ISS_TINFOr_CLR(r) (r).iss_tinfo[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_ISS_TINFOr_SET(r,d) (r).iss_tinfo[0] = d
#define BCMI_FUSIONCORE12G_XGXS_ISS_TINFOr_GET(r) (r).iss_tinfo[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_ISS_TINFOr_ISS_TINFOf_GET(r) (((r).iss_tinfo[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_ISS_TINFOr_ISS_TINFOf_SET(r,f) (r).iss_tinfo[0]=(((r).iss_tinfo[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access ISS_TINFO.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_ISS_TINFOr(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_ISS_TINFOr,(_r._iss_tinfo))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_ISS_TINFOr(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_ISS_TINFOr,(_r._iss_tinfo))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define ISS_TINFOr BCMI_FUSIONCORE12G_XGXS_ISS_TINFOr
#define ISS_TINFOr_SIZE BCMI_FUSIONCORE12G_XGXS_ISS_TINFOr_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_ISS_TINFOr_t ISS_TINFOr_t;
#define ISS_TINFOr_CLR BCMI_FUSIONCORE12G_XGXS_ISS_TINFOr_CLR
#define ISS_TINFOr_SET BCMI_FUSIONCORE12G_XGXS_ISS_TINFOr_SET
#define ISS_TINFOr_GET BCMI_FUSIONCORE12G_XGXS_ISS_TINFOr_GET
#define ISS_TINFOr_ISS_TINFOf_GET BCMI_FUSIONCORE12G_XGXS_ISS_TINFOr_ISS_TINFOf_GET
#define ISS_TINFOr_ISS_TINFOf_SET BCMI_FUSIONCORE12G_XGXS_ISS_TINFOr_ISS_TINFOf_SET
#define READ_ISS_TINFOr BCMI_FUSIONCORE12G_XGXS_READ_ISS_TINFOr
#define WRITE_ISS_TINFOr BCMI_FUSIONCORE12G_XGXS_WRITE_ISS_TINFOr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_ISS_TINFOr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  ISS_RINFO
 * BLOCKS:   BLK0
 * REGADDR:  0x800c
 * DESC:     IssRinfo (Addr 0x800C)
 * SIZE:     32
 * FIELDS:
 *     ISS_RINFO        ISS_RINFO
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_ISS_RINFOr (0x0000001c | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_ISS_RINFOr_SIZE 4

/*
 * This structure should be used to declare and program ISS_RINFO.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_ISS_RINFOr_s {
	uint32_t v[1];
	uint32_t iss_rinfo[1];
	uint32_t _iss_rinfo;
} BCMI_FUSIONCORE12G_XGXS_ISS_RINFOr_t;

#define BCMI_FUSIONCORE12G_XGXS_ISS_RINFOr_CLR(r) (r).iss_rinfo[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_ISS_RINFOr_SET(r,d) (r).iss_rinfo[0] = d
#define BCMI_FUSIONCORE12G_XGXS_ISS_RINFOr_GET(r) (r).iss_rinfo[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_ISS_RINFOr_ISS_RINFOf_GET(r) (((r).iss_rinfo[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_ISS_RINFOr_ISS_RINFOf_SET(r,f) (r).iss_rinfo[0]=(((r).iss_rinfo[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access ISS_RINFO.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_ISS_RINFOr(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_ISS_RINFOr,(_r._iss_rinfo))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_ISS_RINFOr(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_ISS_RINFOr,(_r._iss_rinfo))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define ISS_RINFOr BCMI_FUSIONCORE12G_XGXS_ISS_RINFOr
#define ISS_RINFOr_SIZE BCMI_FUSIONCORE12G_XGXS_ISS_RINFOr_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_ISS_RINFOr_t ISS_RINFOr_t;
#define ISS_RINFOr_CLR BCMI_FUSIONCORE12G_XGXS_ISS_RINFOr_CLR
#define ISS_RINFOr_SET BCMI_FUSIONCORE12G_XGXS_ISS_RINFOr_SET
#define ISS_RINFOr_GET BCMI_FUSIONCORE12G_XGXS_ISS_RINFOr_GET
#define ISS_RINFOr_ISS_RINFOf_GET BCMI_FUSIONCORE12G_XGXS_ISS_RINFOr_ISS_RINFOf_GET
#define ISS_RINFOr_ISS_RINFOf_SET BCMI_FUSIONCORE12G_XGXS_ISS_RINFOr_ISS_RINFOf_SET
#define READ_ISS_RINFOr BCMI_FUSIONCORE12G_XGXS_READ_ISS_RINFOr
#define WRITE_ISS_RINFOr BCMI_FUSIONCORE12G_XGXS_WRITE_ISS_RINFOr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_ISS_RINFOr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  CX4_SIGDET_COUNTER
 * BLOCKS:   BLK0
 * REGADDR:  0x800d
 * DESC:     CX4 SigDet Cnt (Addr 0x800D)
 * SIZE:     32
 * FIELDS:
 *     CX4_SIGDET_COUNTER CX4_SIGDET_COUNTER
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_CX4_SIGDET_COUNTERr (0x0000001d | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_CX4_SIGDET_COUNTERr_SIZE 4

/*
 * This structure should be used to declare and program CX4_SIGDET_COUNTER.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_CX4_SIGDET_COUNTERr_s {
	uint32_t v[1];
	uint32_t cx4_sigdet_counter[1];
	uint32_t _cx4_sigdet_counter;
} BCMI_FUSIONCORE12G_XGXS_CX4_SIGDET_COUNTERr_t;

#define BCMI_FUSIONCORE12G_XGXS_CX4_SIGDET_COUNTERr_CLR(r) (r).cx4_sigdet_counter[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_CX4_SIGDET_COUNTERr_SET(r,d) (r).cx4_sigdet_counter[0] = d
#define BCMI_FUSIONCORE12G_XGXS_CX4_SIGDET_COUNTERr_GET(r) (r).cx4_sigdet_counter[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_CX4_SIGDET_COUNTERr_CX4_SIGDET_COUNTERf_GET(r) (((r).cx4_sigdet_counter[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_CX4_SIGDET_COUNTERr_CX4_SIGDET_COUNTERf_SET(r,f) (r).cx4_sigdet_counter[0]=(((r).cx4_sigdet_counter[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access CX4_SIGDET_COUNTER.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_CX4_SIGDET_COUNTERr(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_CX4_SIGDET_COUNTERr,(_r._cx4_sigdet_counter))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_CX4_SIGDET_COUNTERr(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_CX4_SIGDET_COUNTERr,(_r._cx4_sigdet_counter))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CX4_SIGDET_COUNTERr BCMI_FUSIONCORE12G_XGXS_CX4_SIGDET_COUNTERr
#define CX4_SIGDET_COUNTERr_SIZE BCMI_FUSIONCORE12G_XGXS_CX4_SIGDET_COUNTERr_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_CX4_SIGDET_COUNTERr_t CX4_SIGDET_COUNTERr_t;
#define CX4_SIGDET_COUNTERr_CLR BCMI_FUSIONCORE12G_XGXS_CX4_SIGDET_COUNTERr_CLR
#define CX4_SIGDET_COUNTERr_SET BCMI_FUSIONCORE12G_XGXS_CX4_SIGDET_COUNTERr_SET
#define CX4_SIGDET_COUNTERr_GET BCMI_FUSIONCORE12G_XGXS_CX4_SIGDET_COUNTERr_GET
#define CX4_SIGDET_COUNTERr_CX4_SIGDET_COUNTERf_GET BCMI_FUSIONCORE12G_XGXS_CX4_SIGDET_COUNTERr_CX4_SIGDET_COUNTERf_GET
#define CX4_SIGDET_COUNTERr_CX4_SIGDET_COUNTERf_SET BCMI_FUSIONCORE12G_XGXS_CX4_SIGDET_COUNTERr_CX4_SIGDET_COUNTERf_SET
#define READ_CX4_SIGDET_COUNTERr BCMI_FUSIONCORE12G_XGXS_READ_CX4_SIGDET_COUNTERr
#define WRITE_CX4_SIGDET_COUNTERr BCMI_FUSIONCORE12G_XGXS_WRITE_CX4_SIGDET_COUNTERr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_CX4_SIGDET_COUNTERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  MISC_CTRL1
 * BLOCKS:   BLK0
 * REGADDR:  0x800e
 * DESC:     Misc Control 1 (Addr 0x800E)
 * SIZE:     32
 * FIELDS:
 *     MISC_CTRL1       MISC_CTRL1
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_MISC_CTRL1r (0x0000001e | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_MISC_CTRL1r_SIZE 4

/*
 * This structure should be used to declare and program MISC_CTRL1.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_MISC_CTRL1r_s {
	uint32_t v[1];
	uint32_t misc_ctrl1[1];
	uint32_t _misc_ctrl1;
} BCMI_FUSIONCORE12G_XGXS_MISC_CTRL1r_t;

#define BCMI_FUSIONCORE12G_XGXS_MISC_CTRL1r_CLR(r) (r).misc_ctrl1[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_MISC_CTRL1r_SET(r,d) (r).misc_ctrl1[0] = d
#define BCMI_FUSIONCORE12G_XGXS_MISC_CTRL1r_GET(r) (r).misc_ctrl1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_MISC_CTRL1r_MISC_CTRL1f_GET(r) (((r).misc_ctrl1[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_MISC_CTRL1r_MISC_CTRL1f_SET(r,f) (r).misc_ctrl1[0]=(((r).misc_ctrl1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access MISC_CTRL1.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_MISC_CTRL1r(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_MISC_CTRL1r,(_r._misc_ctrl1))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_MISC_CTRL1r(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_MISC_CTRL1r,(_r._misc_ctrl1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MISC_CTRL1r BCMI_FUSIONCORE12G_XGXS_MISC_CTRL1r
#define MISC_CTRL1r_SIZE BCMI_FUSIONCORE12G_XGXS_MISC_CTRL1r_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_MISC_CTRL1r_t MISC_CTRL1r_t;
#define MISC_CTRL1r_CLR BCMI_FUSIONCORE12G_XGXS_MISC_CTRL1r_CLR
#define MISC_CTRL1r_SET BCMI_FUSIONCORE12G_XGXS_MISC_CTRL1r_SET
#define MISC_CTRL1r_GET BCMI_FUSIONCORE12G_XGXS_MISC_CTRL1r_GET
#define MISC_CTRL1r_MISC_CTRL1f_GET BCMI_FUSIONCORE12G_XGXS_MISC_CTRL1r_MISC_CTRL1f_GET
#define MISC_CTRL1r_MISC_CTRL1f_SET BCMI_FUSIONCORE12G_XGXS_MISC_CTRL1r_MISC_CTRL1f_SET
#define READ_MISC_CTRL1r BCMI_FUSIONCORE12G_XGXS_READ_MISC_CTRL1r
#define WRITE_MISC_CTRL1r BCMI_FUSIONCORE12G_XGXS_WRITE_MISC_CTRL1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_MISC_CTRL1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  DESKEW
 * BLOCKS:   BLK1
 * REGADDR:  0x8010
 * DESC:     deskew (Addr 0x8010)
 * SIZE:     32
 * FIELDS:
 *     DESKEW           DESKEW
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_DESKEWr (0x00001010 | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_DESKEWr_SIZE 4

/*
 * This structure should be used to declare and program DESKEW.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_DESKEWr_s {
	uint32_t v[1];
	uint32_t deskew[1];
	uint32_t _deskew;
} BCMI_FUSIONCORE12G_XGXS_DESKEWr_t;

#define BCMI_FUSIONCORE12G_XGXS_DESKEWr_CLR(r) (r).deskew[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_DESKEWr_SET(r,d) (r).deskew[0] = d
#define BCMI_FUSIONCORE12G_XGXS_DESKEWr_GET(r) (r).deskew[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_DESKEWr_DESKEWf_GET(r) (((r).deskew[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_DESKEWr_DESKEWf_SET(r,f) (r).deskew[0]=(((r).deskew[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access DESKEW.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_DESKEWr(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_DESKEWr,(_r._deskew))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_DESKEWr(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_DESKEWr,(_r._deskew))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DESKEWr BCMI_FUSIONCORE12G_XGXS_DESKEWr
#define DESKEWr_SIZE BCMI_FUSIONCORE12G_XGXS_DESKEWr_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_DESKEWr_t DESKEWr_t;
#define DESKEWr_CLR BCMI_FUSIONCORE12G_XGXS_DESKEWr_CLR
#define DESKEWr_SET BCMI_FUSIONCORE12G_XGXS_DESKEWr_SET
#define DESKEWr_GET BCMI_FUSIONCORE12G_XGXS_DESKEWr_GET
#define DESKEWr_DESKEWf_GET BCMI_FUSIONCORE12G_XGXS_DESKEWr_DESKEWf_GET
#define DESKEWr_DESKEWf_SET BCMI_FUSIONCORE12G_XGXS_DESKEWr_DESKEWf_SET
#define READ_DESKEWr BCMI_FUSIONCORE12G_XGXS_READ_DESKEWr
#define WRITE_DESKEWr BCMI_FUSIONCORE12G_XGXS_WRITE_DESKEWr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_DESKEWr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  LINK
 * BLOCKS:   BLK1
 * REGADDR:  0x8011
 * DESC:     link (Addr 0x8011)
 * SIZE:     32
 * FIELDS:
 *     LINK             LINK
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_LINKr (0x00001011 | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_LINKr_SIZE 4

/*
 * This structure should be used to declare and program LINK.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_LINKr_s {
	uint32_t v[1];
	uint32_t link[1];
	uint32_t _link;
} BCMI_FUSIONCORE12G_XGXS_LINKr_t;

#define BCMI_FUSIONCORE12G_XGXS_LINKr_CLR(r) (r).link[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_LINKr_SET(r,d) (r).link[0] = d
#define BCMI_FUSIONCORE12G_XGXS_LINKr_GET(r) (r).link[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_LINKr_LINKf_GET(r) (((r).link[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_LINKr_LINKf_SET(r,f) (r).link[0]=(((r).link[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access LINK.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_LINKr(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_LINKr,(_r._link))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_LINKr(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_LINKr,(_r._link))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define LINKr BCMI_FUSIONCORE12G_XGXS_LINKr
#define LINKr_SIZE BCMI_FUSIONCORE12G_XGXS_LINKr_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_LINKr_t LINKr_t;
#define LINKr_CLR BCMI_FUSIONCORE12G_XGXS_LINKr_CLR
#define LINKr_SET BCMI_FUSIONCORE12G_XGXS_LINKr_SET
#define LINKr_GET BCMI_FUSIONCORE12G_XGXS_LINKr_GET
#define LINKr_LINKf_GET BCMI_FUSIONCORE12G_XGXS_LINKr_LINKf_GET
#define LINKr_LINKf_SET BCMI_FUSIONCORE12G_XGXS_LINKr_LINKf_SET
#define READ_LINKr BCMI_FUSIONCORE12G_XGXS_READ_LINKr
#define WRITE_LINKr BCMI_FUSIONCORE12G_XGXS_WRITE_LINKr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_LINKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  LANE_CTRL1
 * BLOCKS:   BLK1
 * REGADDR:  0x8016
 * DESC:     laneCtrl1 (Addr 0x8016)
 * SIZE:     32
 * FIELDS:
 *     LANE_CTRL1       LANE_CTRL1
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_LANE_CTRL1r (0x00001016 | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_LANE_CTRL1r_SIZE 4

/*
 * This structure should be used to declare and program LANE_CTRL1.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_LANE_CTRL1r_s {
	uint32_t v[1];
	uint32_t lane_ctrl1[1];
	uint32_t _lane_ctrl1;
} BCMI_FUSIONCORE12G_XGXS_LANE_CTRL1r_t;

#define BCMI_FUSIONCORE12G_XGXS_LANE_CTRL1r_CLR(r) (r).lane_ctrl1[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_LANE_CTRL1r_SET(r,d) (r).lane_ctrl1[0] = d
#define BCMI_FUSIONCORE12G_XGXS_LANE_CTRL1r_GET(r) (r).lane_ctrl1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_LANE_CTRL1r_LANE_CTRL1f_GET(r) (((r).lane_ctrl1[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_LANE_CTRL1r_LANE_CTRL1f_SET(r,f) (r).lane_ctrl1[0]=(((r).lane_ctrl1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access LANE_CTRL1.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_LANE_CTRL1r(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_LANE_CTRL1r,(_r._lane_ctrl1))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_LANE_CTRL1r(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_LANE_CTRL1r,(_r._lane_ctrl1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define LANE_CTRL1r BCMI_FUSIONCORE12G_XGXS_LANE_CTRL1r
#define LANE_CTRL1r_SIZE BCMI_FUSIONCORE12G_XGXS_LANE_CTRL1r_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_LANE_CTRL1r_t LANE_CTRL1r_t;
#define LANE_CTRL1r_CLR BCMI_FUSIONCORE12G_XGXS_LANE_CTRL1r_CLR
#define LANE_CTRL1r_SET BCMI_FUSIONCORE12G_XGXS_LANE_CTRL1r_SET
#define LANE_CTRL1r_GET BCMI_FUSIONCORE12G_XGXS_LANE_CTRL1r_GET
#define LANE_CTRL1r_LANE_CTRL1f_GET BCMI_FUSIONCORE12G_XGXS_LANE_CTRL1r_LANE_CTRL1f_GET
#define LANE_CTRL1r_LANE_CTRL1f_SET BCMI_FUSIONCORE12G_XGXS_LANE_CTRL1r_LANE_CTRL1f_SET
#define READ_LANE_CTRL1r BCMI_FUSIONCORE12G_XGXS_READ_LANE_CTRL1r
#define WRITE_LANE_CTRL1r BCMI_FUSIONCORE12G_XGXS_WRITE_LANE_CTRL1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_LANE_CTRL1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  LANE_CTRL2
 * BLOCKS:   BLK1
 * REGADDR:  0x8017
 * DESC:     laneCtrl2 (Addr 0x8017)
 * SIZE:     32
 * FIELDS:
 *     LANE_CTRL2       LANE_CTRL2
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_LANE_CTRL2r (0x00001017 | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_LANE_CTRL2r_SIZE 4

/*
 * This structure should be used to declare and program LANE_CTRL2.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_LANE_CTRL2r_s {
	uint32_t v[1];
	uint32_t lane_ctrl2[1];
	uint32_t _lane_ctrl2;
} BCMI_FUSIONCORE12G_XGXS_LANE_CTRL2r_t;

#define BCMI_FUSIONCORE12G_XGXS_LANE_CTRL2r_CLR(r) (r).lane_ctrl2[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_LANE_CTRL2r_SET(r,d) (r).lane_ctrl2[0] = d
#define BCMI_FUSIONCORE12G_XGXS_LANE_CTRL2r_GET(r) (r).lane_ctrl2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_LANE_CTRL2r_LANE_CTRL2f_GET(r) (((r).lane_ctrl2[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_LANE_CTRL2r_LANE_CTRL2f_SET(r,f) (r).lane_ctrl2[0]=(((r).lane_ctrl2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access LANE_CTRL2.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_LANE_CTRL2r(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_LANE_CTRL2r,(_r._lane_ctrl2))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_LANE_CTRL2r(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_LANE_CTRL2r,(_r._lane_ctrl2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define LANE_CTRL2r BCMI_FUSIONCORE12G_XGXS_LANE_CTRL2r
#define LANE_CTRL2r_SIZE BCMI_FUSIONCORE12G_XGXS_LANE_CTRL2r_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_LANE_CTRL2r_t LANE_CTRL2r_t;
#define LANE_CTRL2r_CLR BCMI_FUSIONCORE12G_XGXS_LANE_CTRL2r_CLR
#define LANE_CTRL2r_SET BCMI_FUSIONCORE12G_XGXS_LANE_CTRL2r_SET
#define LANE_CTRL2r_GET BCMI_FUSIONCORE12G_XGXS_LANE_CTRL2r_GET
#define LANE_CTRL2r_LANE_CTRL2f_GET BCMI_FUSIONCORE12G_XGXS_LANE_CTRL2r_LANE_CTRL2f_GET
#define LANE_CTRL2r_LANE_CTRL2f_SET BCMI_FUSIONCORE12G_XGXS_LANE_CTRL2r_LANE_CTRL2f_SET
#define READ_LANE_CTRL2r BCMI_FUSIONCORE12G_XGXS_READ_LANE_CTRL2r
#define WRITE_LANE_CTRL2r BCMI_FUSIONCORE12G_XGXS_WRITE_LANE_CTRL2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_LANE_CTRL2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  LANE_CTRL3
 * BLOCKS:   BLK1
 * REGADDR:  0x8018
 * DESC:     laneCtrl3 (Addr 0x8018)
 * SIZE:     32
 * FIELDS:
 *     LANE_CTRL3       LANE_CTRL3
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_LANE_CTRL3r (0x00001018 | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_LANE_CTRL3r_SIZE 4

/*
 * This structure should be used to declare and program LANE_CTRL3.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_LANE_CTRL3r_s {
	uint32_t v[1];
	uint32_t lane_ctrl3[1];
	uint32_t _lane_ctrl3;
} BCMI_FUSIONCORE12G_XGXS_LANE_CTRL3r_t;

#define BCMI_FUSIONCORE12G_XGXS_LANE_CTRL3r_CLR(r) (r).lane_ctrl3[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_LANE_CTRL3r_SET(r,d) (r).lane_ctrl3[0] = d
#define BCMI_FUSIONCORE12G_XGXS_LANE_CTRL3r_GET(r) (r).lane_ctrl3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_LANE_CTRL3r_LANE_CTRL3f_GET(r) (((r).lane_ctrl3[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_LANE_CTRL3r_LANE_CTRL3f_SET(r,f) (r).lane_ctrl3[0]=(((r).lane_ctrl3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access LANE_CTRL3.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_LANE_CTRL3r(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_LANE_CTRL3r,(_r._lane_ctrl3))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_LANE_CTRL3r(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_LANE_CTRL3r,(_r._lane_ctrl3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define LANE_CTRL3r BCMI_FUSIONCORE12G_XGXS_LANE_CTRL3r
#define LANE_CTRL3r_SIZE BCMI_FUSIONCORE12G_XGXS_LANE_CTRL3r_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_LANE_CTRL3r_t LANE_CTRL3r_t;
#define LANE_CTRL3r_CLR BCMI_FUSIONCORE12G_XGXS_LANE_CTRL3r_CLR
#define LANE_CTRL3r_SET BCMI_FUSIONCORE12G_XGXS_LANE_CTRL3r_SET
#define LANE_CTRL3r_GET BCMI_FUSIONCORE12G_XGXS_LANE_CTRL3r_GET
#define LANE_CTRL3r_LANE_CTRL3f_GET BCMI_FUSIONCORE12G_XGXS_LANE_CTRL3r_LANE_CTRL3f_GET
#define LANE_CTRL3r_LANE_CTRL3f_SET BCMI_FUSIONCORE12G_XGXS_LANE_CTRL3r_LANE_CTRL3f_SET
#define READ_LANE_CTRL3r BCMI_FUSIONCORE12G_XGXS_READ_LANE_CTRL3r
#define WRITE_LANE_CTRL3r BCMI_FUSIONCORE12G_XGXS_WRITE_LANE_CTRL3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_LANE_CTRL3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  LANE_TEST
 * BLOCKS:   BLK1
 * REGADDR:  0x801a
 * DESC:     laneTest (Addr 0x801A)
 * SIZE:     32
 * FIELDS:
 *     LANE_TEST        LANE_TEST
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_LANE_TESTr (0x0000101a | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_LANE_TESTr_SIZE 4

/*
 * This structure should be used to declare and program LANE_TEST.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_LANE_TESTr_s {
	uint32_t v[1];
	uint32_t lane_test[1];
	uint32_t _lane_test;
} BCMI_FUSIONCORE12G_XGXS_LANE_TESTr_t;

#define BCMI_FUSIONCORE12G_XGXS_LANE_TESTr_CLR(r) (r).lane_test[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_LANE_TESTr_SET(r,d) (r).lane_test[0] = d
#define BCMI_FUSIONCORE12G_XGXS_LANE_TESTr_GET(r) (r).lane_test[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_LANE_TESTr_LANE_TESTf_GET(r) (((r).lane_test[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_LANE_TESTr_LANE_TESTf_SET(r,f) (r).lane_test[0]=(((r).lane_test[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access LANE_TEST.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_LANE_TESTr(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_LANE_TESTr,(_r._lane_test))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_LANE_TESTr(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_LANE_TESTr,(_r._lane_test))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define LANE_TESTr BCMI_FUSIONCORE12G_XGXS_LANE_TESTr
#define LANE_TESTr_SIZE BCMI_FUSIONCORE12G_XGXS_LANE_TESTr_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_LANE_TESTr_t LANE_TESTr_t;
#define LANE_TESTr_CLR BCMI_FUSIONCORE12G_XGXS_LANE_TESTr_CLR
#define LANE_TESTr_SET BCMI_FUSIONCORE12G_XGXS_LANE_TESTr_SET
#define LANE_TESTr_GET BCMI_FUSIONCORE12G_XGXS_LANE_TESTr_GET
#define LANE_TESTr_LANE_TESTf_GET BCMI_FUSIONCORE12G_XGXS_LANE_TESTr_LANE_TESTf_GET
#define LANE_TESTr_LANE_TESTf_SET BCMI_FUSIONCORE12G_XGXS_LANE_TESTr_LANE_TESTf_SET
#define READ_LANE_TESTr BCMI_FUSIONCORE12G_XGXS_READ_LANE_TESTr
#define WRITE_LANE_TESTr BCMI_FUSIONCORE12G_XGXS_WRITE_LANE_TESTr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_LANE_TESTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  PLL_STAT
 * BLOCKS:   PLL
 * REGADDR:  0x8050
 * DESC:     PLL STATUS (Addr 0x8050)
 * SIZE:     32
 * FIELDS:
 *     PLL_STAT         PLL_STAT
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_PLL_STATr (0x00005010 | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_PLL_STATr_SIZE 4

/*
 * This structure should be used to declare and program PLL_STAT.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_PLL_STATr_s {
	uint32_t v[1];
	uint32_t pll_stat[1];
	uint32_t _pll_stat;
} BCMI_FUSIONCORE12G_XGXS_PLL_STATr_t;

#define BCMI_FUSIONCORE12G_XGXS_PLL_STATr_CLR(r) (r).pll_stat[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_PLL_STATr_SET(r,d) (r).pll_stat[0] = d
#define BCMI_FUSIONCORE12G_XGXS_PLL_STATr_GET(r) (r).pll_stat[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_PLL_STATr_PLL_STATf_GET(r) (((r).pll_stat[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_PLL_STATr_PLL_STATf_SET(r,f) (r).pll_stat[0]=(((r).pll_stat[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PLL_STAT.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_PLL_STATr(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_PLL_STATr,(_r._pll_stat))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_PLL_STATr(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_PLL_STATr,(_r._pll_stat))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PLL_STATr BCMI_FUSIONCORE12G_XGXS_PLL_STATr
#define PLL_STATr_SIZE BCMI_FUSIONCORE12G_XGXS_PLL_STATr_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_PLL_STATr_t PLL_STATr_t;
#define PLL_STATr_CLR BCMI_FUSIONCORE12G_XGXS_PLL_STATr_CLR
#define PLL_STATr_SET BCMI_FUSIONCORE12G_XGXS_PLL_STATr_SET
#define PLL_STATr_GET BCMI_FUSIONCORE12G_XGXS_PLL_STATr_GET
#define PLL_STATr_PLL_STATf_GET BCMI_FUSIONCORE12G_XGXS_PLL_STATr_PLL_STATf_GET
#define PLL_STATr_PLL_STATf_SET BCMI_FUSIONCORE12G_XGXS_PLL_STATr_PLL_STATf_SET
#define READ_PLL_STATr BCMI_FUSIONCORE12G_XGXS_READ_PLL_STATr
#define WRITE_PLL_STATr BCMI_FUSIONCORE12G_XGXS_WRITE_PLL_STATr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_PLL_STATr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  PLL_CTRL
 * BLOCKS:   PLL
 * REGADDR:  0x8051
 * DESC:     PLL Control (Addr 0x8051)
 * SIZE:     32
 * FIELDS:
 *     PLL_CTRL         PLL_CTRL
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_PLL_CTRLr (0x00005011 | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_PLL_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program PLL_CTRL.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_PLL_CTRLr_s {
	uint32_t v[1];
	uint32_t pll_ctrl[1];
	uint32_t _pll_ctrl;
} BCMI_FUSIONCORE12G_XGXS_PLL_CTRLr_t;

#define BCMI_FUSIONCORE12G_XGXS_PLL_CTRLr_CLR(r) (r).pll_ctrl[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_PLL_CTRLr_SET(r,d) (r).pll_ctrl[0] = d
#define BCMI_FUSIONCORE12G_XGXS_PLL_CTRLr_GET(r) (r).pll_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_PLL_CTRLr_PLL_CTRLf_GET(r) (((r).pll_ctrl[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_PLL_CTRLr_PLL_CTRLf_SET(r,f) (r).pll_ctrl[0]=(((r).pll_ctrl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PLL_CTRL.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_PLL_CTRLr(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_PLL_CTRLr,(_r._pll_ctrl))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_PLL_CTRLr(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_PLL_CTRLr,(_r._pll_ctrl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PLL_CTRLr BCMI_FUSIONCORE12G_XGXS_PLL_CTRLr
#define PLL_CTRLr_SIZE BCMI_FUSIONCORE12G_XGXS_PLL_CTRLr_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_PLL_CTRLr_t PLL_CTRLr_t;
#define PLL_CTRLr_CLR BCMI_FUSIONCORE12G_XGXS_PLL_CTRLr_CLR
#define PLL_CTRLr_SET BCMI_FUSIONCORE12G_XGXS_PLL_CTRLr_SET
#define PLL_CTRLr_GET BCMI_FUSIONCORE12G_XGXS_PLL_CTRLr_GET
#define PLL_CTRLr_PLL_CTRLf_GET BCMI_FUSIONCORE12G_XGXS_PLL_CTRLr_PLL_CTRLf_GET
#define PLL_CTRLr_PLL_CTRLf_SET BCMI_FUSIONCORE12G_XGXS_PLL_CTRLr_PLL_CTRLf_SET
#define READ_PLL_CTRLr BCMI_FUSIONCORE12G_XGXS_READ_PLL_CTRLr
#define WRITE_PLL_CTRLr BCMI_FUSIONCORE12G_XGXS_WRITE_PLL_CTRLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_PLL_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  TIMER1
 * BLOCKS:   PLL
 * REGADDR:  0x8052
 * DESC:     PLL Timer 1 (Addr 0x8052)
 * SIZE:     32
 * FIELDS:
 *     TIMER1           TIMER1
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_TIMER1r (0x00005012 | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_TIMER1r_SIZE 4

/*
 * This structure should be used to declare and program TIMER1.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_TIMER1r_s {
	uint32_t v[1];
	uint32_t timer1[1];
	uint32_t _timer1;
} BCMI_FUSIONCORE12G_XGXS_TIMER1r_t;

#define BCMI_FUSIONCORE12G_XGXS_TIMER1r_CLR(r) (r).timer1[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_TIMER1r_SET(r,d) (r).timer1[0] = d
#define BCMI_FUSIONCORE12G_XGXS_TIMER1r_GET(r) (r).timer1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_TIMER1r_TIMER1f_GET(r) (((r).timer1[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_TIMER1r_TIMER1f_SET(r,f) (r).timer1[0]=(((r).timer1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access TIMER1.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_TIMER1r(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_TIMER1r,(_r._timer1))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_TIMER1r(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_TIMER1r,(_r._timer1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TIMER1r BCMI_FUSIONCORE12G_XGXS_TIMER1r
#define TIMER1r_SIZE BCMI_FUSIONCORE12G_XGXS_TIMER1r_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_TIMER1r_t TIMER1r_t;
#define TIMER1r_CLR BCMI_FUSIONCORE12G_XGXS_TIMER1r_CLR
#define TIMER1r_SET BCMI_FUSIONCORE12G_XGXS_TIMER1r_SET
#define TIMER1r_GET BCMI_FUSIONCORE12G_XGXS_TIMER1r_GET
#define TIMER1r_TIMER1f_GET BCMI_FUSIONCORE12G_XGXS_TIMER1r_TIMER1f_GET
#define TIMER1r_TIMER1f_SET BCMI_FUSIONCORE12G_XGXS_TIMER1r_TIMER1f_SET
#define READ_TIMER1r BCMI_FUSIONCORE12G_XGXS_READ_TIMER1r
#define WRITE_TIMER1r BCMI_FUSIONCORE12G_XGXS_WRITE_TIMER1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_TIMER1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  TIMER2
 * BLOCKS:   PLL
 * REGADDR:  0x8053
 * DESC:     PLL Timer 2 (Addr 0x8053)
 * SIZE:     32
 * FIELDS:
 *     TIMER2           TIMER2
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_TIMER2r (0x00005013 | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_TIMER2r_SIZE 4

/*
 * This structure should be used to declare and program TIMER2.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_TIMER2r_s {
	uint32_t v[1];
	uint32_t timer2[1];
	uint32_t _timer2;
} BCMI_FUSIONCORE12G_XGXS_TIMER2r_t;

#define BCMI_FUSIONCORE12G_XGXS_TIMER2r_CLR(r) (r).timer2[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_TIMER2r_SET(r,d) (r).timer2[0] = d
#define BCMI_FUSIONCORE12G_XGXS_TIMER2r_GET(r) (r).timer2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_TIMER2r_TIMER2f_GET(r) (((r).timer2[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_TIMER2r_TIMER2f_SET(r,f) (r).timer2[0]=(((r).timer2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access TIMER2.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_TIMER2r(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_TIMER2r,(_r._timer2))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_TIMER2r(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_TIMER2r,(_r._timer2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TIMER2r BCMI_FUSIONCORE12G_XGXS_TIMER2r
#define TIMER2r_SIZE BCMI_FUSIONCORE12G_XGXS_TIMER2r_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_TIMER2r_t TIMER2r_t;
#define TIMER2r_CLR BCMI_FUSIONCORE12G_XGXS_TIMER2r_CLR
#define TIMER2r_SET BCMI_FUSIONCORE12G_XGXS_TIMER2r_SET
#define TIMER2r_GET BCMI_FUSIONCORE12G_XGXS_TIMER2r_GET
#define TIMER2r_TIMER2f_GET BCMI_FUSIONCORE12G_XGXS_TIMER2r_TIMER2f_GET
#define TIMER2r_TIMER2f_SET BCMI_FUSIONCORE12G_XGXS_TIMER2r_TIMER2f_SET
#define READ_TIMER2r BCMI_FUSIONCORE12G_XGXS_READ_TIMER2r
#define WRITE_TIMER2r BCMI_FUSIONCORE12G_XGXS_WRITE_TIMER2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_TIMER2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  TIMER3
 * BLOCKS:   PLL
 * REGADDR:  0x8054
 * DESC:     PLL Timer 3 (Addr 0x8054)
 * SIZE:     32
 * FIELDS:
 *     TIMER3           TIMER3
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_TIMER3r (0x00005014 | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_TIMER3r_SIZE 4

/*
 * This structure should be used to declare and program TIMER3.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_TIMER3r_s {
	uint32_t v[1];
	uint32_t timer3[1];
	uint32_t _timer3;
} BCMI_FUSIONCORE12G_XGXS_TIMER3r_t;

#define BCMI_FUSIONCORE12G_XGXS_TIMER3r_CLR(r) (r).timer3[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_TIMER3r_SET(r,d) (r).timer3[0] = d
#define BCMI_FUSIONCORE12G_XGXS_TIMER3r_GET(r) (r).timer3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_TIMER3r_TIMER3f_GET(r) (((r).timer3[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_TIMER3r_TIMER3f_SET(r,f) (r).timer3[0]=(((r).timer3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access TIMER3.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_TIMER3r(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_TIMER3r,(_r._timer3))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_TIMER3r(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_TIMER3r,(_r._timer3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TIMER3r BCMI_FUSIONCORE12G_XGXS_TIMER3r
#define TIMER3r_SIZE BCMI_FUSIONCORE12G_XGXS_TIMER3r_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_TIMER3r_t TIMER3r_t;
#define TIMER3r_CLR BCMI_FUSIONCORE12G_XGXS_TIMER3r_CLR
#define TIMER3r_SET BCMI_FUSIONCORE12G_XGXS_TIMER3r_SET
#define TIMER3r_GET BCMI_FUSIONCORE12G_XGXS_TIMER3r_GET
#define TIMER3r_TIMER3f_GET BCMI_FUSIONCORE12G_XGXS_TIMER3r_TIMER3f_GET
#define TIMER3r_TIMER3f_SET BCMI_FUSIONCORE12G_XGXS_TIMER3r_TIMER3f_SET
#define READ_TIMER3r BCMI_FUSIONCORE12G_XGXS_READ_TIMER3r
#define WRITE_TIMER3r BCMI_FUSIONCORE12G_XGXS_WRITE_TIMER3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_TIMER3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  CAP_CTRL
 * BLOCKS:   PLL
 * REGADDR:  0x8055
 * DESC:     CAP Control (Addr 0x8055)
 * SIZE:     32
 * FIELDS:
 *     CAP_CTRL         CAP_CTRL
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_CAP_CTRLr (0x00005015 | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_CAP_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program CAP_CTRL.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_CAP_CTRLr_s {
	uint32_t v[1];
	uint32_t cap_ctrl[1];
	uint32_t _cap_ctrl;
} BCMI_FUSIONCORE12G_XGXS_CAP_CTRLr_t;

#define BCMI_FUSIONCORE12G_XGXS_CAP_CTRLr_CLR(r) (r).cap_ctrl[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_CAP_CTRLr_SET(r,d) (r).cap_ctrl[0] = d
#define BCMI_FUSIONCORE12G_XGXS_CAP_CTRLr_GET(r) (r).cap_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_CAP_CTRLr_CAP_CTRLf_GET(r) (((r).cap_ctrl[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_CAP_CTRLr_CAP_CTRLf_SET(r,f) (r).cap_ctrl[0]=(((r).cap_ctrl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access CAP_CTRL.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_CAP_CTRLr(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_CAP_CTRLr,(_r._cap_ctrl))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_CAP_CTRLr(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_CAP_CTRLr,(_r._cap_ctrl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CAP_CTRLr BCMI_FUSIONCORE12G_XGXS_CAP_CTRLr
#define CAP_CTRLr_SIZE BCMI_FUSIONCORE12G_XGXS_CAP_CTRLr_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_CAP_CTRLr_t CAP_CTRLr_t;
#define CAP_CTRLr_CLR BCMI_FUSIONCORE12G_XGXS_CAP_CTRLr_CLR
#define CAP_CTRLr_SET BCMI_FUSIONCORE12G_XGXS_CAP_CTRLr_SET
#define CAP_CTRLr_GET BCMI_FUSIONCORE12G_XGXS_CAP_CTRLr_GET
#define CAP_CTRLr_CAP_CTRLf_GET BCMI_FUSIONCORE12G_XGXS_CAP_CTRLr_CAP_CTRLf_GET
#define CAP_CTRLr_CAP_CTRLf_SET BCMI_FUSIONCORE12G_XGXS_CAP_CTRLr_CAP_CTRLf_SET
#define READ_CAP_CTRLr BCMI_FUSIONCORE12G_XGXS_READ_CAP_CTRLr
#define WRITE_CAP_CTRLr BCMI_FUSIONCORE12G_XGXS_WRITE_CAP_CTRLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_CAP_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  AMP_CTRL
 * BLOCKS:   PLL
 * REGADDR:  0x8056
 * DESC:     AMP Control (Addr 0x8056)
 * SIZE:     32
 * FIELDS:
 *     AMP_CTRL         AMP_CTRL
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_AMP_CTRLr (0x00005016 | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_AMP_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program AMP_CTRL.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_AMP_CTRLr_s {
	uint32_t v[1];
	uint32_t amp_ctrl[1];
	uint32_t _amp_ctrl;
} BCMI_FUSIONCORE12G_XGXS_AMP_CTRLr_t;

#define BCMI_FUSIONCORE12G_XGXS_AMP_CTRLr_CLR(r) (r).amp_ctrl[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_AMP_CTRLr_SET(r,d) (r).amp_ctrl[0] = d
#define BCMI_FUSIONCORE12G_XGXS_AMP_CTRLr_GET(r) (r).amp_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_AMP_CTRLr_AMP_CTRLf_GET(r) (((r).amp_ctrl[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_AMP_CTRLr_AMP_CTRLf_SET(r,f) (r).amp_ctrl[0]=(((r).amp_ctrl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access AMP_CTRL.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_AMP_CTRLr(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_AMP_CTRLr,(_r._amp_ctrl))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_AMP_CTRLr(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_AMP_CTRLr,(_r._amp_ctrl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AMP_CTRLr BCMI_FUSIONCORE12G_XGXS_AMP_CTRLr
#define AMP_CTRLr_SIZE BCMI_FUSIONCORE12G_XGXS_AMP_CTRLr_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_AMP_CTRLr_t AMP_CTRLr_t;
#define AMP_CTRLr_CLR BCMI_FUSIONCORE12G_XGXS_AMP_CTRLr_CLR
#define AMP_CTRLr_SET BCMI_FUSIONCORE12G_XGXS_AMP_CTRLr_SET
#define AMP_CTRLr_GET BCMI_FUSIONCORE12G_XGXS_AMP_CTRLr_GET
#define AMP_CTRLr_AMP_CTRLf_GET BCMI_FUSIONCORE12G_XGXS_AMP_CTRLr_AMP_CTRLf_GET
#define AMP_CTRLr_AMP_CTRLf_SET BCMI_FUSIONCORE12G_XGXS_AMP_CTRLr_AMP_CTRLf_SET
#define READ_AMP_CTRLr BCMI_FUSIONCORE12G_XGXS_READ_AMP_CTRLr
#define WRITE_AMP_CTRLr BCMI_FUSIONCORE12G_XGXS_WRITE_AMP_CTRLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_AMP_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  FREQ_DET_COUNTER
 * BLOCKS:   PLL
 * REGADDR:  0x8057
 * DESC:     Freq Det Counter (Addr 0x8057)
 * SIZE:     32
 * FIELDS:
 *     FREQ_DET_COUNTER FREQ_DET_COUNTER
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_FREQ_DET_COUNTERr (0x00005017 | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_FREQ_DET_COUNTERr_SIZE 4

/*
 * This structure should be used to declare and program FREQ_DET_COUNTER.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_FREQ_DET_COUNTERr_s {
	uint32_t v[1];
	uint32_t freq_det_counter[1];
	uint32_t _freq_det_counter;
} BCMI_FUSIONCORE12G_XGXS_FREQ_DET_COUNTERr_t;

#define BCMI_FUSIONCORE12G_XGXS_FREQ_DET_COUNTERr_CLR(r) (r).freq_det_counter[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_FREQ_DET_COUNTERr_SET(r,d) (r).freq_det_counter[0] = d
#define BCMI_FUSIONCORE12G_XGXS_FREQ_DET_COUNTERr_GET(r) (r).freq_det_counter[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_FREQ_DET_COUNTERr_FREQ_DET_COUNTERf_GET(r) (((r).freq_det_counter[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_FREQ_DET_COUNTERr_FREQ_DET_COUNTERf_SET(r,f) (r).freq_det_counter[0]=(((r).freq_det_counter[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access FREQ_DET_COUNTER.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_FREQ_DET_COUNTERr(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_FREQ_DET_COUNTERr,(_r._freq_det_counter))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_FREQ_DET_COUNTERr(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_FREQ_DET_COUNTERr,(_r._freq_det_counter))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define FREQ_DET_COUNTERr BCMI_FUSIONCORE12G_XGXS_FREQ_DET_COUNTERr
#define FREQ_DET_COUNTERr_SIZE BCMI_FUSIONCORE12G_XGXS_FREQ_DET_COUNTERr_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_FREQ_DET_COUNTERr_t FREQ_DET_COUNTERr_t;
#define FREQ_DET_COUNTERr_CLR BCMI_FUSIONCORE12G_XGXS_FREQ_DET_COUNTERr_CLR
#define FREQ_DET_COUNTERr_SET BCMI_FUSIONCORE12G_XGXS_FREQ_DET_COUNTERr_SET
#define FREQ_DET_COUNTERr_GET BCMI_FUSIONCORE12G_XGXS_FREQ_DET_COUNTERr_GET
#define FREQ_DET_COUNTERr_FREQ_DET_COUNTERf_GET BCMI_FUSIONCORE12G_XGXS_FREQ_DET_COUNTERr_FREQ_DET_COUNTERf_GET
#define FREQ_DET_COUNTERr_FREQ_DET_COUNTERf_SET BCMI_FUSIONCORE12G_XGXS_FREQ_DET_COUNTERr_FREQ_DET_COUNTERf_SET
#define READ_FREQ_DET_COUNTERr BCMI_FUSIONCORE12G_XGXS_READ_FREQ_DET_COUNTERr
#define WRITE_FREQ_DET_COUNTERr BCMI_FUSIONCORE12G_XGXS_WRITE_FREQ_DET_COUNTERr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_FREQ_DET_COUNTERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  ASTAT1
 * BLOCKS:   PLL
 * REGADDR:  0x8058
 * DESC:     PLL Astatus 1 (Addr 0x8058)
 * SIZE:     32
 * FIELDS:
 *     ASTAT1           ASTAT1
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_ASTAT1r (0x00005018 | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_ASTAT1r_SIZE 4

/*
 * This structure should be used to declare and program ASTAT1.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_ASTAT1r_s {
	uint32_t v[1];
	uint32_t astat1[1];
	uint32_t _astat1;
} BCMI_FUSIONCORE12G_XGXS_ASTAT1r_t;

#define BCMI_FUSIONCORE12G_XGXS_ASTAT1r_CLR(r) (r).astat1[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_ASTAT1r_SET(r,d) (r).astat1[0] = d
#define BCMI_FUSIONCORE12G_XGXS_ASTAT1r_GET(r) (r).astat1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_ASTAT1r_ASTAT1f_GET(r) (((r).astat1[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_ASTAT1r_ASTAT1f_SET(r,f) (r).astat1[0]=(((r).astat1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access ASTAT1.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_ASTAT1r(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_ASTAT1r,(_r._astat1))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_ASTAT1r(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_ASTAT1r,(_r._astat1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define ASTAT1r BCMI_FUSIONCORE12G_XGXS_ASTAT1r
#define ASTAT1r_SIZE BCMI_FUSIONCORE12G_XGXS_ASTAT1r_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_ASTAT1r_t ASTAT1r_t;
#define ASTAT1r_CLR BCMI_FUSIONCORE12G_XGXS_ASTAT1r_CLR
#define ASTAT1r_SET BCMI_FUSIONCORE12G_XGXS_ASTAT1r_SET
#define ASTAT1r_GET BCMI_FUSIONCORE12G_XGXS_ASTAT1r_GET
#define ASTAT1r_ASTAT1f_GET BCMI_FUSIONCORE12G_XGXS_ASTAT1r_ASTAT1f_GET
#define ASTAT1r_ASTAT1f_SET BCMI_FUSIONCORE12G_XGXS_ASTAT1r_ASTAT1f_SET
#define READ_ASTAT1r BCMI_FUSIONCORE12G_XGXS_READ_ASTAT1r
#define WRITE_ASTAT1r BCMI_FUSIONCORE12G_XGXS_WRITE_ASTAT1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_ASTAT1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  ASTAT2
 * BLOCKS:   PLL
 * REGADDR:  0x8059
 * DESC:     PLL Astatus 2 (Addr 0x8059)
 * SIZE:     32
 * FIELDS:
 *     ASTAT2           ASTAT2
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_ASTAT2r (0x00005019 | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_ASTAT2r_SIZE 4

/*
 * This structure should be used to declare and program ASTAT2.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_ASTAT2r_s {
	uint32_t v[1];
	uint32_t astat2[1];
	uint32_t _astat2;
} BCMI_FUSIONCORE12G_XGXS_ASTAT2r_t;

#define BCMI_FUSIONCORE12G_XGXS_ASTAT2r_CLR(r) (r).astat2[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_ASTAT2r_SET(r,d) (r).astat2[0] = d
#define BCMI_FUSIONCORE12G_XGXS_ASTAT2r_GET(r) (r).astat2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_ASTAT2r_ASTAT2f_GET(r) (((r).astat2[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_ASTAT2r_ASTAT2f_SET(r,f) (r).astat2[0]=(((r).astat2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access ASTAT2.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_ASTAT2r(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_ASTAT2r,(_r._astat2))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_ASTAT2r(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_ASTAT2r,(_r._astat2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define ASTAT2r BCMI_FUSIONCORE12G_XGXS_ASTAT2r
#define ASTAT2r_SIZE BCMI_FUSIONCORE12G_XGXS_ASTAT2r_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_ASTAT2r_t ASTAT2r_t;
#define ASTAT2r_CLR BCMI_FUSIONCORE12G_XGXS_ASTAT2r_CLR
#define ASTAT2r_SET BCMI_FUSIONCORE12G_XGXS_ASTAT2r_SET
#define ASTAT2r_GET BCMI_FUSIONCORE12G_XGXS_ASTAT2r_GET
#define ASTAT2r_ASTAT2f_GET BCMI_FUSIONCORE12G_XGXS_ASTAT2r_ASTAT2f_GET
#define ASTAT2r_ASTAT2f_SET BCMI_FUSIONCORE12G_XGXS_ASTAT2r_ASTAT2f_SET
#define READ_ASTAT2r BCMI_FUSIONCORE12G_XGXS_READ_ASTAT2r
#define WRITE_ASTAT2r BCMI_FUSIONCORE12G_XGXS_WRITE_ASTAT2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_ASTAT2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  CLK_GEN
 * BLOCKS:   PLL
 * REGADDR:  0x805a
 * DESC:     PLL Clock Gen (Addr 0x805A)
 * SIZE:     32
 * FIELDS:
 *     CLK_GEN          CLK_GEN
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_CLK_GENr (0x0000501a | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_CLK_GENr_SIZE 4

/*
 * This structure should be used to declare and program CLK_GEN.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_CLK_GENr_s {
	uint32_t v[1];
	uint32_t clk_gen[1];
	uint32_t _clk_gen;
} BCMI_FUSIONCORE12G_XGXS_CLK_GENr_t;

#define BCMI_FUSIONCORE12G_XGXS_CLK_GENr_CLR(r) (r).clk_gen[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_CLK_GENr_SET(r,d) (r).clk_gen[0] = d
#define BCMI_FUSIONCORE12G_XGXS_CLK_GENr_GET(r) (r).clk_gen[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_CLK_GENr_CLK_GENf_GET(r) (((r).clk_gen[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_CLK_GENr_CLK_GENf_SET(r,f) (r).clk_gen[0]=(((r).clk_gen[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access CLK_GEN.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_CLK_GENr(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_CLK_GENr,(_r._clk_gen))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_CLK_GENr(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_CLK_GENr,(_r._clk_gen))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CLK_GENr BCMI_FUSIONCORE12G_XGXS_CLK_GENr
#define CLK_GENr_SIZE BCMI_FUSIONCORE12G_XGXS_CLK_GENr_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_CLK_GENr_t CLK_GENr_t;
#define CLK_GENr_CLR BCMI_FUSIONCORE12G_XGXS_CLK_GENr_CLR
#define CLK_GENr_SET BCMI_FUSIONCORE12G_XGXS_CLK_GENr_SET
#define CLK_GENr_GET BCMI_FUSIONCORE12G_XGXS_CLK_GENr_GET
#define CLK_GENr_CLK_GENf_GET BCMI_FUSIONCORE12G_XGXS_CLK_GENr_CLK_GENf_GET
#define CLK_GENr_CLK_GENf_SET BCMI_FUSIONCORE12G_XGXS_CLK_GENr_CLK_GENf_SET
#define READ_CLK_GENr BCMI_FUSIONCORE12G_XGXS_READ_CLK_GENr
#define WRITE_CLK_GENr BCMI_FUSIONCORE12G_XGXS_WRITE_CLK_GENr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_CLK_GENr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  NDIV
 * BLOCKS:   PLL
 * REGADDR:  0x805b
 * DESC:     PLL Ndiv (Addr 0x805B)
 * SIZE:     32
 * FIELDS:
 *     NDIV             NDIV
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_NDIVr (0x0000501b | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_NDIVr_SIZE 4

/*
 * This structure should be used to declare and program NDIV.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_NDIVr_s {
	uint32_t v[1];
	uint32_t ndiv[1];
	uint32_t _ndiv;
} BCMI_FUSIONCORE12G_XGXS_NDIVr_t;

#define BCMI_FUSIONCORE12G_XGXS_NDIVr_CLR(r) (r).ndiv[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_NDIVr_SET(r,d) (r).ndiv[0] = d
#define BCMI_FUSIONCORE12G_XGXS_NDIVr_GET(r) (r).ndiv[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_NDIVr_NDIVf_GET(r) (((r).ndiv[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_NDIVr_NDIVf_SET(r,f) (r).ndiv[0]=(((r).ndiv[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access NDIV.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_NDIVr(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_NDIVr,(_r._ndiv))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_NDIVr(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_NDIVr,(_r._ndiv))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define NDIVr BCMI_FUSIONCORE12G_XGXS_NDIVr
#define NDIVr_SIZE BCMI_FUSIONCORE12G_XGXS_NDIVr_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_NDIVr_t NDIVr_t;
#define NDIVr_CLR BCMI_FUSIONCORE12G_XGXS_NDIVr_CLR
#define NDIVr_SET BCMI_FUSIONCORE12G_XGXS_NDIVr_SET
#define NDIVr_GET BCMI_FUSIONCORE12G_XGXS_NDIVr_GET
#define NDIVr_NDIVf_GET BCMI_FUSIONCORE12G_XGXS_NDIVr_NDIVf_GET
#define NDIVr_NDIVf_SET BCMI_FUSIONCORE12G_XGXS_NDIVr_NDIVf_SET
#define READ_NDIVr BCMI_FUSIONCORE12G_XGXS_READ_NDIVr
#define WRITE_NDIVr BCMI_FUSIONCORE12G_XGXS_WRITE_NDIVr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_NDIVr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  BGLQP
 * BLOCKS:   PLL
 * REGADDR:  0x805c
 * DESC:     PLL Bglqp (Addr 0x805C)
 * SIZE:     32
 * FIELDS:
 *     BGLQP            BGLQP
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_BGLQPr (0x0000501c | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_BGLQPr_SIZE 4

/*
 * This structure should be used to declare and program BGLQP.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_BGLQPr_s {
	uint32_t v[1];
	uint32_t bglqp[1];
	uint32_t _bglqp;
} BCMI_FUSIONCORE12G_XGXS_BGLQPr_t;

#define BCMI_FUSIONCORE12G_XGXS_BGLQPr_CLR(r) (r).bglqp[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_BGLQPr_SET(r,d) (r).bglqp[0] = d
#define BCMI_FUSIONCORE12G_XGXS_BGLQPr_GET(r) (r).bglqp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_BGLQPr_BGLQPf_GET(r) (((r).bglqp[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_BGLQPr_BGLQPf_SET(r,f) (r).bglqp[0]=(((r).bglqp[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access BGLQP.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_BGLQPr(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_BGLQPr,(_r._bglqp))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_BGLQPr(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_BGLQPr,(_r._bglqp))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define BGLQPr BCMI_FUSIONCORE12G_XGXS_BGLQPr
#define BGLQPr_SIZE BCMI_FUSIONCORE12G_XGXS_BGLQPr_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_BGLQPr_t BGLQPr_t;
#define BGLQPr_CLR BCMI_FUSIONCORE12G_XGXS_BGLQPr_CLR
#define BGLQPr_SET BCMI_FUSIONCORE12G_XGXS_BGLQPr_SET
#define BGLQPr_GET BCMI_FUSIONCORE12G_XGXS_BGLQPr_GET
#define BGLQPr_BGLQPf_GET BCMI_FUSIONCORE12G_XGXS_BGLQPr_BGLQPf_GET
#define BGLQPr_BGLQPf_SET BCMI_FUSIONCORE12G_XGXS_BGLQPr_BGLQPf_SET
#define READ_BGLQPr BCMI_FUSIONCORE12G_XGXS_READ_BGLQPr
#define WRITE_BGLQPr BCMI_FUSIONCORE12G_XGXS_WRITE_BGLQPr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_BGLQPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  TEST_KVH
 * BLOCKS:   PLL
 * REGADDR:  0x805d
 * DESC:     PLL Test Kvh (Addr 0x805D)
 * SIZE:     32
 * FIELDS:
 *     TEST_KVH         TEST_KVH
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_TEST_KVHr (0x0000501d | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_TEST_KVHr_SIZE 4

/*
 * This structure should be used to declare and program TEST_KVH.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_TEST_KVHr_s {
	uint32_t v[1];
	uint32_t test_kvh[1];
	uint32_t _test_kvh;
} BCMI_FUSIONCORE12G_XGXS_TEST_KVHr_t;

#define BCMI_FUSIONCORE12G_XGXS_TEST_KVHr_CLR(r) (r).test_kvh[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_TEST_KVHr_SET(r,d) (r).test_kvh[0] = d
#define BCMI_FUSIONCORE12G_XGXS_TEST_KVHr_GET(r) (r).test_kvh[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_TEST_KVHr_TEST_KVHf_GET(r) (((r).test_kvh[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_TEST_KVHr_TEST_KVHf_SET(r,f) (r).test_kvh[0]=(((r).test_kvh[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access TEST_KVH.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_TEST_KVHr(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_TEST_KVHr,(_r._test_kvh))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_TEST_KVHr(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_TEST_KVHr,(_r._test_kvh))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TEST_KVHr BCMI_FUSIONCORE12G_XGXS_TEST_KVHr
#define TEST_KVHr_SIZE BCMI_FUSIONCORE12G_XGXS_TEST_KVHr_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_TEST_KVHr_t TEST_KVHr_t;
#define TEST_KVHr_CLR BCMI_FUSIONCORE12G_XGXS_TEST_KVHr_CLR
#define TEST_KVHr_SET BCMI_FUSIONCORE12G_XGXS_TEST_KVHr_SET
#define TEST_KVHr_GET BCMI_FUSIONCORE12G_XGXS_TEST_KVHr_GET
#define TEST_KVHr_TEST_KVHf_GET BCMI_FUSIONCORE12G_XGXS_TEST_KVHr_TEST_KVHf_GET
#define TEST_KVHr_TEST_KVHf_SET BCMI_FUSIONCORE12G_XGXS_TEST_KVHr_TEST_KVHf_SET
#define READ_TEST_KVHr BCMI_FUSIONCORE12G_XGXS_READ_TEST_KVHr
#define WRITE_TEST_KVHr BCMI_FUSIONCORE12G_XGXS_WRITE_TEST_KVHr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_TEST_KVHr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  ACTRL5
 * BLOCKS:   PLL
 * REGADDR:  0x805e
 * DESC:     PLL AControl 5 (Addr 0x805E)
 * SIZE:     32
 * FIELDS:
 *     ACTRL5           ACTRL5
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_ACTRL5r (0x0000501e | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_ACTRL5r_SIZE 4

/*
 * This structure should be used to declare and program ACTRL5.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_ACTRL5r_s {
	uint32_t v[1];
	uint32_t actrl5[1];
	uint32_t _actrl5;
} BCMI_FUSIONCORE12G_XGXS_ACTRL5r_t;

#define BCMI_FUSIONCORE12G_XGXS_ACTRL5r_CLR(r) (r).actrl5[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_ACTRL5r_SET(r,d) (r).actrl5[0] = d
#define BCMI_FUSIONCORE12G_XGXS_ACTRL5r_GET(r) (r).actrl5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_ACTRL5r_ACTRL5f_GET(r) (((r).actrl5[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_ACTRL5r_ACTRL5f_SET(r,f) (r).actrl5[0]=(((r).actrl5[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access ACTRL5.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_ACTRL5r(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_ACTRL5r,(_r._actrl5))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_ACTRL5r(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_ACTRL5r,(_r._actrl5))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define ACTRL5r BCMI_FUSIONCORE12G_XGXS_ACTRL5r
#define ACTRL5r_SIZE BCMI_FUSIONCORE12G_XGXS_ACTRL5r_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_ACTRL5r_t ACTRL5r_t;
#define ACTRL5r_CLR BCMI_FUSIONCORE12G_XGXS_ACTRL5r_CLR
#define ACTRL5r_SET BCMI_FUSIONCORE12G_XGXS_ACTRL5r_SET
#define ACTRL5r_GET BCMI_FUSIONCORE12G_XGXS_ACTRL5r_GET
#define ACTRL5r_ACTRL5f_GET BCMI_FUSIONCORE12G_XGXS_ACTRL5r_ACTRL5f_GET
#define ACTRL5r_ACTRL5f_SET BCMI_FUSIONCORE12G_XGXS_ACTRL5r_ACTRL5f_SET
#define READ_ACTRL5r BCMI_FUSIONCORE12G_XGXS_READ_ACTRL5r
#define WRITE_ACTRL5r BCMI_FUSIONCORE12G_XGXS_WRITE_ACTRL5r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_ACTRL5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  ACTRL0
 * BLOCKS:   TXALL
 * REGADDR:  0x80a1
 * DESC:     Tx AControl 0 (Addr 0x80A1)
 * SIZE:     32
 * FIELDS:
 *     ACTRL0           ACTRL0
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_ACTRL0r (0x0000a011 | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_ACTRL0r_SIZE 4

/*
 * This structure should be used to declare and program ACTRL0.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_ACTRL0r_s {
	uint32_t v[1];
	uint32_t actrl0[1];
	uint32_t _actrl0;
} BCMI_FUSIONCORE12G_XGXS_ACTRL0r_t;

#define BCMI_FUSIONCORE12G_XGXS_ACTRL0r_CLR(r) (r).actrl0[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_ACTRL0r_SET(r,d) (r).actrl0[0] = d
#define BCMI_FUSIONCORE12G_XGXS_ACTRL0r_GET(r) (r).actrl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_ACTRL0r_ACTRL0f_GET(r) (((r).actrl0[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_ACTRL0r_ACTRL0f_SET(r,f) (r).actrl0[0]=(((r).actrl0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access ACTRL0.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_ACTRL0r(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_ACTRL0r,(_r._actrl0))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_ACTRL0r(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_ACTRL0r,(_r._actrl0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define ACTRL0r BCMI_FUSIONCORE12G_XGXS_ACTRL0r
#define ACTRL0r_SIZE BCMI_FUSIONCORE12G_XGXS_ACTRL0r_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_ACTRL0r_t ACTRL0r_t;
#define ACTRL0r_CLR BCMI_FUSIONCORE12G_XGXS_ACTRL0r_CLR
#define ACTRL0r_SET BCMI_FUSIONCORE12G_XGXS_ACTRL0r_SET
#define ACTRL0r_GET BCMI_FUSIONCORE12G_XGXS_ACTRL0r_GET
#define ACTRL0r_ACTRL0f_GET BCMI_FUSIONCORE12G_XGXS_ACTRL0r_ACTRL0f_GET
#define ACTRL0r_ACTRL0f_SET BCMI_FUSIONCORE12G_XGXS_ACTRL0r_ACTRL0f_SET
#define READ_ACTRL0r BCMI_FUSIONCORE12G_XGXS_READ_ACTRL0r
#define WRITE_ACTRL0r BCMI_FUSIONCORE12G_XGXS_WRITE_ACTRL0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_ACTRL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  DRIVER
 * BLOCKS:   TXALL
 * REGADDR:  0x80a7
 * DESC:     Tx Driver (Addr 0x80A7)
 * SIZE:     32
 * FIELDS:
 *     DRIVER           DRIVER
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_DRIVERr (0x0000a017 | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_DRIVERr_SIZE 4

/*
 * This structure should be used to declare and program DRIVER.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_DRIVERr_s {
	uint32_t v[1];
	uint32_t driver[1];
	uint32_t _driver;
} BCMI_FUSIONCORE12G_XGXS_DRIVERr_t;

#define BCMI_FUSIONCORE12G_XGXS_DRIVERr_CLR(r) (r).driver[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_DRIVERr_SET(r,d) (r).driver[0] = d
#define BCMI_FUSIONCORE12G_XGXS_DRIVERr_GET(r) (r).driver[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_DRIVERr_DRIVERf_GET(r) (((r).driver[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_DRIVERr_DRIVERf_SET(r,f) (r).driver[0]=(((r).driver[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access DRIVER.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_DRIVERr(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_DRIVERr,(_r._driver))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_DRIVERr(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_DRIVERr,(_r._driver))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DRIVERr BCMI_FUSIONCORE12G_XGXS_DRIVERr
#define DRIVERr_SIZE BCMI_FUSIONCORE12G_XGXS_DRIVERr_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_DRIVERr_t DRIVERr_t;
#define DRIVERr_CLR BCMI_FUSIONCORE12G_XGXS_DRIVERr_CLR
#define DRIVERr_SET BCMI_FUSIONCORE12G_XGXS_DRIVERr_SET
#define DRIVERr_GET BCMI_FUSIONCORE12G_XGXS_DRIVERr_GET
#define DRIVERr_DRIVERf_GET BCMI_FUSIONCORE12G_XGXS_DRIVERr_DRIVERf_GET
#define DRIVERr_DRIVERf_SET BCMI_FUSIONCORE12G_XGXS_DRIVERr_DRIVERf_SET
#define READ_DRIVERr BCMI_FUSIONCORE12G_XGXS_READ_DRIVERr
#define WRITE_DRIVERr BCMI_FUSIONCORE12G_XGXS_WRITE_DRIVERr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_DRIVERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  RXALL_STAT
 * BLOCKS:   RXALL
 * REGADDR:  0x80f0
 * DESC:     Rx Status (Address 0x80F0)
 * SIZE:     32
 * FIELDS:
 *     RXALL_STAT       RXALL_STAT
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_RXALL_STATr (0x0000f010 | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_RXALL_STATr_SIZE 4

/*
 * This structure should be used to declare and program RXALL_STAT.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_RXALL_STATr_s {
	uint32_t v[1];
	uint32_t rxall_stat[1];
	uint32_t _rxall_stat;
} BCMI_FUSIONCORE12G_XGXS_RXALL_STATr_t;

#define BCMI_FUSIONCORE12G_XGXS_RXALL_STATr_CLR(r) (r).rxall_stat[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_RXALL_STATr_SET(r,d) (r).rxall_stat[0] = d
#define BCMI_FUSIONCORE12G_XGXS_RXALL_STATr_GET(r) (r).rxall_stat[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_RXALL_STATr_RXALL_STATf_GET(r) (((r).rxall_stat[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_RXALL_STATr_RXALL_STATf_SET(r,f) (r).rxall_stat[0]=(((r).rxall_stat[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access RXALL_STAT.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_RXALL_STATr(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_RXALL_STATr,(_r._rxall_stat))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_RXALL_STATr(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_RXALL_STATr,(_r._rxall_stat))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RXALL_STATr BCMI_FUSIONCORE12G_XGXS_RXALL_STATr
#define RXALL_STATr_SIZE BCMI_FUSIONCORE12G_XGXS_RXALL_STATr_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_RXALL_STATr_t RXALL_STATr_t;
#define RXALL_STATr_CLR BCMI_FUSIONCORE12G_XGXS_RXALL_STATr_CLR
#define RXALL_STATr_SET BCMI_FUSIONCORE12G_XGXS_RXALL_STATr_SET
#define RXALL_STATr_GET BCMI_FUSIONCORE12G_XGXS_RXALL_STATr_GET
#define RXALL_STATr_RXALL_STATf_GET BCMI_FUSIONCORE12G_XGXS_RXALL_STATr_RXALL_STATf_GET
#define RXALL_STATr_RXALL_STATf_SET BCMI_FUSIONCORE12G_XGXS_RXALL_STATr_RXALL_STATf_SET
#define READ_RXALL_STATr BCMI_FUSIONCORE12G_XGXS_READ_RXALL_STATr
#define WRITE_RXALL_STATr BCMI_FUSIONCORE12G_XGXS_WRITE_RXALL_STATr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_RXALL_STATr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  RXALL_CTRL
 * BLOCKS:   RXALL
 * REGADDR:  0x80f1
 * DESC:     Rx Control (Address 0x80F1)
 * SIZE:     32
 * FIELDS:
 *     RXALL_CTRL       RXALL_CTRL
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_RXALL_CTRLr (0x0000f011 | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_RXALL_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program RXALL_CTRL.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_RXALL_CTRLr_s {
	uint32_t v[1];
	uint32_t rxall_ctrl[1];
	uint32_t _rxall_ctrl;
} BCMI_FUSIONCORE12G_XGXS_RXALL_CTRLr_t;

#define BCMI_FUSIONCORE12G_XGXS_RXALL_CTRLr_CLR(r) (r).rxall_ctrl[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_RXALL_CTRLr_SET(r,d) (r).rxall_ctrl[0] = d
#define BCMI_FUSIONCORE12G_XGXS_RXALL_CTRLr_GET(r) (r).rxall_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_RXALL_CTRLr_RXALL_CTRLf_GET(r) (((r).rxall_ctrl[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_RXALL_CTRLr_RXALL_CTRLf_SET(r,f) (r).rxall_ctrl[0]=(((r).rxall_ctrl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access RXALL_CTRL.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_RXALL_CTRLr(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_RXALL_CTRLr,(_r._rxall_ctrl))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_RXALL_CTRLr(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_RXALL_CTRLr,(_r._rxall_ctrl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RXALL_CTRLr BCMI_FUSIONCORE12G_XGXS_RXALL_CTRLr
#define RXALL_CTRLr_SIZE BCMI_FUSIONCORE12G_XGXS_RXALL_CTRLr_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_RXALL_CTRLr_t RXALL_CTRLr_t;
#define RXALL_CTRLr_CLR BCMI_FUSIONCORE12G_XGXS_RXALL_CTRLr_CLR
#define RXALL_CTRLr_SET BCMI_FUSIONCORE12G_XGXS_RXALL_CTRLr_SET
#define RXALL_CTRLr_GET BCMI_FUSIONCORE12G_XGXS_RXALL_CTRLr_GET
#define RXALL_CTRLr_RXALL_CTRLf_GET BCMI_FUSIONCORE12G_XGXS_RXALL_CTRLr_RXALL_CTRLf_GET
#define RXALL_CTRLr_RXALL_CTRLf_SET BCMI_FUSIONCORE12G_XGXS_RXALL_CTRLr_RXALL_CTRLf_SET
#define READ_RXALL_CTRLr BCMI_FUSIONCORE12G_XGXS_READ_RXALL_CTRLr
#define WRITE_RXALL_CTRLr BCMI_FUSIONCORE12G_XGXS_WRITE_RXALL_CTRLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_RXALL_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  RXALL_TIMER1
 * BLOCKS:   RXALL
 * REGADDR:  0x80f2
 * DESC:     Rx Timer 1 (Address 0x80F2)
 * SIZE:     32
 * FIELDS:
 *     RXALL_TIMER1     RXALL_TIMER1
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_RXALL_TIMER1r (0x0000f012 | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_RXALL_TIMER1r_SIZE 4

/*
 * This structure should be used to declare and program RXALL_TIMER1.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_RXALL_TIMER1r_s {
	uint32_t v[1];
	uint32_t rxall_timer1[1];
	uint32_t _rxall_timer1;
} BCMI_FUSIONCORE12G_XGXS_RXALL_TIMER1r_t;

#define BCMI_FUSIONCORE12G_XGXS_RXALL_TIMER1r_CLR(r) (r).rxall_timer1[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_RXALL_TIMER1r_SET(r,d) (r).rxall_timer1[0] = d
#define BCMI_FUSIONCORE12G_XGXS_RXALL_TIMER1r_GET(r) (r).rxall_timer1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_RXALL_TIMER1r_RXALL_TIMER1f_GET(r) (((r).rxall_timer1[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_RXALL_TIMER1r_RXALL_TIMER1f_SET(r,f) (r).rxall_timer1[0]=(((r).rxall_timer1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access RXALL_TIMER1.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_RXALL_TIMER1r(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_RXALL_TIMER1r,(_r._rxall_timer1))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_RXALL_TIMER1r(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_RXALL_TIMER1r,(_r._rxall_timer1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RXALL_TIMER1r BCMI_FUSIONCORE12G_XGXS_RXALL_TIMER1r
#define RXALL_TIMER1r_SIZE BCMI_FUSIONCORE12G_XGXS_RXALL_TIMER1r_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_RXALL_TIMER1r_t RXALL_TIMER1r_t;
#define RXALL_TIMER1r_CLR BCMI_FUSIONCORE12G_XGXS_RXALL_TIMER1r_CLR
#define RXALL_TIMER1r_SET BCMI_FUSIONCORE12G_XGXS_RXALL_TIMER1r_SET
#define RXALL_TIMER1r_GET BCMI_FUSIONCORE12G_XGXS_RXALL_TIMER1r_GET
#define RXALL_TIMER1r_RXALL_TIMER1f_GET BCMI_FUSIONCORE12G_XGXS_RXALL_TIMER1r_RXALL_TIMER1f_GET
#define RXALL_TIMER1r_RXALL_TIMER1f_SET BCMI_FUSIONCORE12G_XGXS_RXALL_TIMER1r_RXALL_TIMER1f_SET
#define READ_RXALL_TIMER1r BCMI_FUSIONCORE12G_XGXS_READ_RXALL_TIMER1r
#define WRITE_RXALL_TIMER1r BCMI_FUSIONCORE12G_XGXS_WRITE_RXALL_TIMER1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_RXALL_TIMER1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  RXALL_TIMER2
 * BLOCKS:   RXALL
 * REGADDR:  0x80f3
 * DESC:     Rx Timer 2 (Address 0x80F3)
 * SIZE:     32
 * FIELDS:
 *     RXALL_TIMER2     RXALL_TIMER2
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_RXALL_TIMER2r (0x0000f013 | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_RXALL_TIMER2r_SIZE 4

/*
 * This structure should be used to declare and program RXALL_TIMER2.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_RXALL_TIMER2r_s {
	uint32_t v[1];
	uint32_t rxall_timer2[1];
	uint32_t _rxall_timer2;
} BCMI_FUSIONCORE12G_XGXS_RXALL_TIMER2r_t;

#define BCMI_FUSIONCORE12G_XGXS_RXALL_TIMER2r_CLR(r) (r).rxall_timer2[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_RXALL_TIMER2r_SET(r,d) (r).rxall_timer2[0] = d
#define BCMI_FUSIONCORE12G_XGXS_RXALL_TIMER2r_GET(r) (r).rxall_timer2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_RXALL_TIMER2r_RXALL_TIMER2f_GET(r) (((r).rxall_timer2[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_RXALL_TIMER2r_RXALL_TIMER2f_SET(r,f) (r).rxall_timer2[0]=(((r).rxall_timer2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access RXALL_TIMER2.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_RXALL_TIMER2r(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_RXALL_TIMER2r,(_r._rxall_timer2))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_RXALL_TIMER2r(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_RXALL_TIMER2r,(_r._rxall_timer2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RXALL_TIMER2r BCMI_FUSIONCORE12G_XGXS_RXALL_TIMER2r
#define RXALL_TIMER2r_SIZE BCMI_FUSIONCORE12G_XGXS_RXALL_TIMER2r_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_RXALL_TIMER2r_t RXALL_TIMER2r_t;
#define RXALL_TIMER2r_CLR BCMI_FUSIONCORE12G_XGXS_RXALL_TIMER2r_CLR
#define RXALL_TIMER2r_SET BCMI_FUSIONCORE12G_XGXS_RXALL_TIMER2r_SET
#define RXALL_TIMER2r_GET BCMI_FUSIONCORE12G_XGXS_RXALL_TIMER2r_GET
#define RXALL_TIMER2r_RXALL_TIMER2f_GET BCMI_FUSIONCORE12G_XGXS_RXALL_TIMER2r_RXALL_TIMER2f_GET
#define RXALL_TIMER2r_RXALL_TIMER2f_SET BCMI_FUSIONCORE12G_XGXS_RXALL_TIMER2r_RXALL_TIMER2f_SET
#define READ_RXALL_TIMER2r BCMI_FUSIONCORE12G_XGXS_READ_RXALL_TIMER2r
#define WRITE_RXALL_TIMER2r BCMI_FUSIONCORE12G_XGXS_WRITE_RXALL_TIMER2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_RXALL_TIMER2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  SIG_DET
 * BLOCKS:   RXALL
 * REGADDR:  0x80f4
 * DESC:     Rx SigDet (Address 0x80F4)
 * SIZE:     32
 * FIELDS:
 *     SIG_DET          SIG_DET
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_SIG_DETr (0x0000f014 | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_SIG_DETr_SIZE 4

/*
 * This structure should be used to declare and program SIG_DET.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_SIG_DETr_s {
	uint32_t v[1];
	uint32_t sig_det[1];
	uint32_t _sig_det;
} BCMI_FUSIONCORE12G_XGXS_SIG_DETr_t;

#define BCMI_FUSIONCORE12G_XGXS_SIG_DETr_CLR(r) (r).sig_det[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_SIG_DETr_SET(r,d) (r).sig_det[0] = d
#define BCMI_FUSIONCORE12G_XGXS_SIG_DETr_GET(r) (r).sig_det[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_SIG_DETr_SIG_DETf_GET(r) (((r).sig_det[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_SIG_DETr_SIG_DETf_SET(r,f) (r).sig_det[0]=(((r).sig_det[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access SIG_DET.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_SIG_DETr(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_SIG_DETr,(_r._sig_det))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_SIG_DETr(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_SIG_DETr,(_r._sig_det))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SIG_DETr BCMI_FUSIONCORE12G_XGXS_SIG_DETr
#define SIG_DETr_SIZE BCMI_FUSIONCORE12G_XGXS_SIG_DETr_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_SIG_DETr_t SIG_DETr_t;
#define SIG_DETr_CLR BCMI_FUSIONCORE12G_XGXS_SIG_DETr_CLR
#define SIG_DETr_SET BCMI_FUSIONCORE12G_XGXS_SIG_DETr_SET
#define SIG_DETr_GET BCMI_FUSIONCORE12G_XGXS_SIG_DETr_GET
#define SIG_DETr_SIG_DETf_GET BCMI_FUSIONCORE12G_XGXS_SIG_DETr_SIG_DETf_GET
#define SIG_DETr_SIG_DETf_SET BCMI_FUSIONCORE12G_XGXS_SIG_DETr_SIG_DETf_SET
#define READ_SIG_DETr BCMI_FUSIONCORE12G_XGXS_READ_SIG_DETr
#define WRITE_SIG_DETr BCMI_FUSIONCORE12G_XGXS_WRITE_SIG_DETr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_SIG_DETr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  CDR_PHASE
 * BLOCKS:   RXALL
 * REGADDR:  0x80f5
 * DESC:     Rx CdrPhase (Address 0x80F5)
 * SIZE:     32
 * FIELDS:
 *     CDR_PHASE        CDR_PHASE
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_CDR_PHASEr (0x0000f015 | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_CDR_PHASEr_SIZE 4

/*
 * This structure should be used to declare and program CDR_PHASE.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_CDR_PHASEr_s {
	uint32_t v[1];
	uint32_t cdr_phase[1];
	uint32_t _cdr_phase;
} BCMI_FUSIONCORE12G_XGXS_CDR_PHASEr_t;

#define BCMI_FUSIONCORE12G_XGXS_CDR_PHASEr_CLR(r) (r).cdr_phase[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_CDR_PHASEr_SET(r,d) (r).cdr_phase[0] = d
#define BCMI_FUSIONCORE12G_XGXS_CDR_PHASEr_GET(r) (r).cdr_phase[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_CDR_PHASEr_CDR_PHASEf_GET(r) (((r).cdr_phase[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_CDR_PHASEr_CDR_PHASEf_SET(r,f) (r).cdr_phase[0]=(((r).cdr_phase[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access CDR_PHASE.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_CDR_PHASEr(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_CDR_PHASEr,(_r._cdr_phase))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_CDR_PHASEr(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_CDR_PHASEr,(_r._cdr_phase))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CDR_PHASEr BCMI_FUSIONCORE12G_XGXS_CDR_PHASEr
#define CDR_PHASEr_SIZE BCMI_FUSIONCORE12G_XGXS_CDR_PHASEr_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_CDR_PHASEr_t CDR_PHASEr_t;
#define CDR_PHASEr_CLR BCMI_FUSIONCORE12G_XGXS_CDR_PHASEr_CLR
#define CDR_PHASEr_SET BCMI_FUSIONCORE12G_XGXS_CDR_PHASEr_SET
#define CDR_PHASEr_GET BCMI_FUSIONCORE12G_XGXS_CDR_PHASEr_GET
#define CDR_PHASEr_CDR_PHASEf_GET BCMI_FUSIONCORE12G_XGXS_CDR_PHASEr_CDR_PHASEf_GET
#define CDR_PHASEr_CDR_PHASEf_SET BCMI_FUSIONCORE12G_XGXS_CDR_PHASEr_CDR_PHASEf_SET
#define READ_CDR_PHASEr BCMI_FUSIONCORE12G_XGXS_READ_CDR_PHASEr
#define WRITE_CDR_PHASEr BCMI_FUSIONCORE12G_XGXS_WRITE_CDR_PHASEr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_CDR_PHASEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  CDR_FREQ
 * BLOCKS:   RXALL
 * REGADDR:  0x80f6
 * DESC:     Rx CdrFreq (Address 0x80F6)
 * SIZE:     32
 * FIELDS:
 *     CDR_FREQ         CDR_FREQ
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_CDR_FREQr (0x0000f016 | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_CDR_FREQr_SIZE 4

/*
 * This structure should be used to declare and program CDR_FREQ.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_CDR_FREQr_s {
	uint32_t v[1];
	uint32_t cdr_freq[1];
	uint32_t _cdr_freq;
} BCMI_FUSIONCORE12G_XGXS_CDR_FREQr_t;

#define BCMI_FUSIONCORE12G_XGXS_CDR_FREQr_CLR(r) (r).cdr_freq[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_CDR_FREQr_SET(r,d) (r).cdr_freq[0] = d
#define BCMI_FUSIONCORE12G_XGXS_CDR_FREQr_GET(r) (r).cdr_freq[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_CDR_FREQr_CDR_FREQf_GET(r) (((r).cdr_freq[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_CDR_FREQr_CDR_FREQf_SET(r,f) (r).cdr_freq[0]=(((r).cdr_freq[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access CDR_FREQ.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_CDR_FREQr(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_CDR_FREQr,(_r._cdr_freq))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_CDR_FREQr(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_CDR_FREQr,(_r._cdr_freq))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CDR_FREQr BCMI_FUSIONCORE12G_XGXS_CDR_FREQr
#define CDR_FREQr_SIZE BCMI_FUSIONCORE12G_XGXS_CDR_FREQr_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_CDR_FREQr_t CDR_FREQr_t;
#define CDR_FREQr_CLR BCMI_FUSIONCORE12G_XGXS_CDR_FREQr_CLR
#define CDR_FREQr_SET BCMI_FUSIONCORE12G_XGXS_CDR_FREQr_SET
#define CDR_FREQr_GET BCMI_FUSIONCORE12G_XGXS_CDR_FREQr_GET
#define CDR_FREQr_CDR_FREQf_GET BCMI_FUSIONCORE12G_XGXS_CDR_FREQr_CDR_FREQf_GET
#define CDR_FREQr_CDR_FREQf_SET BCMI_FUSIONCORE12G_XGXS_CDR_FREQr_CDR_FREQf_SET
#define READ_CDR_FREQr BCMI_FUSIONCORE12G_XGXS_READ_CDR_FREQr
#define WRITE_CDR_FREQr BCMI_FUSIONCORE12G_XGXS_WRITE_CDR_FREQr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_CDR_FREQr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  EQ_CONFIG
 * BLOCKS:   RXALL
 * REGADDR:  0x80f7
 * DESC:     Rx EqConfig (Address 0x80F7)
 * SIZE:     32
 * FIELDS:
 *     EQ_CONFIG        EQ_CONFIG
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_EQ_CONFIGr (0x0000f017 | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_EQ_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program EQ_CONFIG.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_EQ_CONFIGr_s {
	uint32_t v[1];
	uint32_t eq_config[1];
	uint32_t _eq_config;
} BCMI_FUSIONCORE12G_XGXS_EQ_CONFIGr_t;

#define BCMI_FUSIONCORE12G_XGXS_EQ_CONFIGr_CLR(r) (r).eq_config[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_EQ_CONFIGr_SET(r,d) (r).eq_config[0] = d
#define BCMI_FUSIONCORE12G_XGXS_EQ_CONFIGr_GET(r) (r).eq_config[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_EQ_CONFIGr_EQ_CONFIGf_GET(r) (((r).eq_config[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_EQ_CONFIGr_EQ_CONFIGf_SET(r,f) (r).eq_config[0]=(((r).eq_config[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access EQ_CONFIG.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_EQ_CONFIGr(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_EQ_CONFIGr,(_r._eq_config))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_EQ_CONFIGr(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_EQ_CONFIGr,(_r._eq_config))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define EQ_CONFIGr BCMI_FUSIONCORE12G_XGXS_EQ_CONFIGr
#define EQ_CONFIGr_SIZE BCMI_FUSIONCORE12G_XGXS_EQ_CONFIGr_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_EQ_CONFIGr_t EQ_CONFIGr_t;
#define EQ_CONFIGr_CLR BCMI_FUSIONCORE12G_XGXS_EQ_CONFIGr_CLR
#define EQ_CONFIGr_SET BCMI_FUSIONCORE12G_XGXS_EQ_CONFIGr_SET
#define EQ_CONFIGr_GET BCMI_FUSIONCORE12G_XGXS_EQ_CONFIGr_GET
#define EQ_CONFIGr_EQ_CONFIGf_GET BCMI_FUSIONCORE12G_XGXS_EQ_CONFIGr_EQ_CONFIGf_GET
#define EQ_CONFIGr_EQ_CONFIGf_SET BCMI_FUSIONCORE12G_XGXS_EQ_CONFIGr_EQ_CONFIGf_SET
#define READ_EQ_CONFIGr BCMI_FUSIONCORE12G_XGXS_READ_EQ_CONFIGr
#define WRITE_EQ_CONFIGr BCMI_FUSIONCORE12G_XGXS_WRITE_EQ_CONFIGr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_EQ_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  EQ_FORCE
 * BLOCKS:   RXALL
 * REGADDR:  0x80f8
 * DESC:     Rx EqForce (Address 0x80F8)
 * SIZE:     32
 * FIELDS:
 *     EQ_FORCE         EQ_FORCE
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_EQ_FORCEr (0x0000f018 | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_EQ_FORCEr_SIZE 4

/*
 * This structure should be used to declare and program EQ_FORCE.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_EQ_FORCEr_s {
	uint32_t v[1];
	uint32_t eq_force[1];
	uint32_t _eq_force;
} BCMI_FUSIONCORE12G_XGXS_EQ_FORCEr_t;

#define BCMI_FUSIONCORE12G_XGXS_EQ_FORCEr_CLR(r) (r).eq_force[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_EQ_FORCEr_SET(r,d) (r).eq_force[0] = d
#define BCMI_FUSIONCORE12G_XGXS_EQ_FORCEr_GET(r) (r).eq_force[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_EQ_FORCEr_EQ_FORCEf_GET(r) (((r).eq_force[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_EQ_FORCEr_EQ_FORCEf_SET(r,f) (r).eq_force[0]=(((r).eq_force[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access EQ_FORCE.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_EQ_FORCEr(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_EQ_FORCEr,(_r._eq_force))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_EQ_FORCEr(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_EQ_FORCEr,(_r._eq_force))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define EQ_FORCEr BCMI_FUSIONCORE12G_XGXS_EQ_FORCEr
#define EQ_FORCEr_SIZE BCMI_FUSIONCORE12G_XGXS_EQ_FORCEr_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_EQ_FORCEr_t EQ_FORCEr_t;
#define EQ_FORCEr_CLR BCMI_FUSIONCORE12G_XGXS_EQ_FORCEr_CLR
#define EQ_FORCEr_SET BCMI_FUSIONCORE12G_XGXS_EQ_FORCEr_SET
#define EQ_FORCEr_GET BCMI_FUSIONCORE12G_XGXS_EQ_FORCEr_GET
#define EQ_FORCEr_EQ_FORCEf_GET BCMI_FUSIONCORE12G_XGXS_EQ_FORCEr_EQ_FORCEf_GET
#define EQ_FORCEr_EQ_FORCEf_SET BCMI_FUSIONCORE12G_XGXS_EQ_FORCEr_EQ_FORCEf_SET
#define READ_EQ_FORCEr BCMI_FUSIONCORE12G_XGXS_READ_EQ_FORCEr
#define WRITE_EQ_FORCEr BCMI_FUSIONCORE12G_XGXS_WRITE_EQ_FORCEr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_EQ_FORCEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  CTRL_1G
 * BLOCKS:   RXALL
 * REGADDR:  0x80f9
 * DESC:     Rx Control 1G (Address 0x80F9)
 * SIZE:     32
 * FIELDS:
 *     CTRL_1G          CTRL_1G
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_CTRL_1Gr (0x0000f019 | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_CTRL_1Gr_SIZE 4

/*
 * This structure should be used to declare and program CTRL_1G.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_CTRL_1Gr_s {
	uint32_t v[1];
	uint32_t ctrl_1g[1];
	uint32_t _ctrl_1g;
} BCMI_FUSIONCORE12G_XGXS_CTRL_1Gr_t;

#define BCMI_FUSIONCORE12G_XGXS_CTRL_1Gr_CLR(r) (r).ctrl_1g[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_CTRL_1Gr_SET(r,d) (r).ctrl_1g[0] = d
#define BCMI_FUSIONCORE12G_XGXS_CTRL_1Gr_GET(r) (r).ctrl_1g[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_CTRL_1Gr_CTRL_1Gf_GET(r) (((r).ctrl_1g[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_CTRL_1Gr_CTRL_1Gf_SET(r,f) (r).ctrl_1g[0]=(((r).ctrl_1g[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access CTRL_1G.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_CTRL_1Gr(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_CTRL_1Gr,(_r._ctrl_1g))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_CTRL_1Gr(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_CTRL_1Gr,(_r._ctrl_1g))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CTRL_1Gr BCMI_FUSIONCORE12G_XGXS_CTRL_1Gr
#define CTRL_1Gr_SIZE BCMI_FUSIONCORE12G_XGXS_CTRL_1Gr_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_CTRL_1Gr_t CTRL_1Gr_t;
#define CTRL_1Gr_CLR BCMI_FUSIONCORE12G_XGXS_CTRL_1Gr_CLR
#define CTRL_1Gr_SET BCMI_FUSIONCORE12G_XGXS_CTRL_1Gr_SET
#define CTRL_1Gr_GET BCMI_FUSIONCORE12G_XGXS_CTRL_1Gr_GET
#define CTRL_1Gr_CTRL_1Gf_GET BCMI_FUSIONCORE12G_XGXS_CTRL_1Gr_CTRL_1Gf_GET
#define CTRL_1Gr_CTRL_1Gf_SET BCMI_FUSIONCORE12G_XGXS_CTRL_1Gr_CTRL_1Gf_SET
#define READ_CTRL_1Gr BCMI_FUSIONCORE12G_XGXS_READ_CTRL_1Gr
#define WRITE_CTRL_1Gr BCMI_FUSIONCORE12G_XGXS_WRITE_CTRL_1Gr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_CTRL_1Gr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  CTRL_PCIE
 * BLOCKS:   RXALL
 * REGADDR:  0x80fa
 * DESC:     Rx Control PCIE (Address 0x80FA)
 * SIZE:     32
 * FIELDS:
 *     CTRL_PCIE        CTRL_PCIE
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_CTRL_PCIEr (0x0000f01a | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_CTRL_PCIEr_SIZE 4

/*
 * This structure should be used to declare and program CTRL_PCIE.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_CTRL_PCIEr_s {
	uint32_t v[1];
	uint32_t ctrl_pcie[1];
	uint32_t _ctrl_pcie;
} BCMI_FUSIONCORE12G_XGXS_CTRL_PCIEr_t;

#define BCMI_FUSIONCORE12G_XGXS_CTRL_PCIEr_CLR(r) (r).ctrl_pcie[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_CTRL_PCIEr_SET(r,d) (r).ctrl_pcie[0] = d
#define BCMI_FUSIONCORE12G_XGXS_CTRL_PCIEr_GET(r) (r).ctrl_pcie[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_CTRL_PCIEr_CTRL_PCIEf_GET(r) (((r).ctrl_pcie[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_CTRL_PCIEr_CTRL_PCIEf_SET(r,f) (r).ctrl_pcie[0]=(((r).ctrl_pcie[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access CTRL_PCIE.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_CTRL_PCIEr(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_CTRL_PCIEr,(_r._ctrl_pcie))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_CTRL_PCIEr(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_CTRL_PCIEr,(_r._ctrl_pcie))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CTRL_PCIEr BCMI_FUSIONCORE12G_XGXS_CTRL_PCIEr
#define CTRL_PCIEr_SIZE BCMI_FUSIONCORE12G_XGXS_CTRL_PCIEr_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_CTRL_PCIEr_t CTRL_PCIEr_t;
#define CTRL_PCIEr_CLR BCMI_FUSIONCORE12G_XGXS_CTRL_PCIEr_CLR
#define CTRL_PCIEr_SET BCMI_FUSIONCORE12G_XGXS_CTRL_PCIEr_SET
#define CTRL_PCIEr_GET BCMI_FUSIONCORE12G_XGXS_CTRL_PCIEr_GET
#define CTRL_PCIEr_CTRL_PCIEf_GET BCMI_FUSIONCORE12G_XGXS_CTRL_PCIEr_CTRL_PCIEf_GET
#define CTRL_PCIEr_CTRL_PCIEf_SET BCMI_FUSIONCORE12G_XGXS_CTRL_PCIEr_CTRL_PCIEf_SET
#define READ_CTRL_PCIEr BCMI_FUSIONCORE12G_XGXS_READ_CTRL_PCIEr
#define WRITE_CTRL_PCIEr BCMI_FUSIONCORE12G_XGXS_WRITE_CTRL_PCIEr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_CTRL_PCIEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  ASTAT
 * BLOCKS:   RXALL
 * REGADDR:  0x80fb
 * DESC:     Rx Astatus (Address 0x80FB)
 * SIZE:     32
 * FIELDS:
 *     ASTAT            ASTAT
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_ASTATr (0x0000f01b | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_ASTATr_SIZE 4

/*
 * This structure should be used to declare and program ASTAT.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_ASTATr_s {
	uint32_t v[1];
	uint32_t astat[1];
	uint32_t _astat;
} BCMI_FUSIONCORE12G_XGXS_ASTATr_t;

#define BCMI_FUSIONCORE12G_XGXS_ASTATr_CLR(r) (r).astat[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_ASTATr_SET(r,d) (r).astat[0] = d
#define BCMI_FUSIONCORE12G_XGXS_ASTATr_GET(r) (r).astat[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_ASTATr_ASTATf_GET(r) (((r).astat[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_ASTATr_ASTATf_SET(r,f) (r).astat[0]=(((r).astat[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access ASTAT.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_ASTATr(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_ASTATr,(_r._astat))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_ASTATr(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_ASTATr,(_r._astat))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define ASTATr BCMI_FUSIONCORE12G_XGXS_ASTATr
#define ASTATr_SIZE BCMI_FUSIONCORE12G_XGXS_ASTATr_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_ASTATr_t ASTATr_t;
#define ASTATr_CLR BCMI_FUSIONCORE12G_XGXS_ASTATr_CLR
#define ASTATr_SET BCMI_FUSIONCORE12G_XGXS_ASTATr_SET
#define ASTATr_GET BCMI_FUSIONCORE12G_XGXS_ASTATr_GET
#define ASTATr_ASTATf_GET BCMI_FUSIONCORE12G_XGXS_ASTATr_ASTATf_GET
#define ASTATr_ASTATf_SET BCMI_FUSIONCORE12G_XGXS_ASTATr_ASTATf_SET
#define READ_ASTATr BCMI_FUSIONCORE12G_XGXS_READ_ASTATr
#define WRITE_ASTATr BCMI_FUSIONCORE12G_XGXS_WRITE_ASTATr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_ASTATr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  EQ_BOOST
 * BLOCKS:   RXALL
 * REGADDR:  0x80fc
 * DESC:     Rx Eq Boost (Address 0x80FC)
 * SIZE:     32
 * FIELDS:
 *     EQ_BOOST         EQ_BOOST
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_EQ_BOOSTr (0x0000f01c | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_EQ_BOOSTr_SIZE 4

/*
 * This structure should be used to declare and program EQ_BOOST.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_EQ_BOOSTr_s {
	uint32_t v[1];
	uint32_t eq_boost[1];
	uint32_t _eq_boost;
} BCMI_FUSIONCORE12G_XGXS_EQ_BOOSTr_t;

#define BCMI_FUSIONCORE12G_XGXS_EQ_BOOSTr_CLR(r) (r).eq_boost[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_EQ_BOOSTr_SET(r,d) (r).eq_boost[0] = d
#define BCMI_FUSIONCORE12G_XGXS_EQ_BOOSTr_GET(r) (r).eq_boost[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_EQ_BOOSTr_EQ_BOOSTf_GET(r) (((r).eq_boost[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_EQ_BOOSTr_EQ_BOOSTf_SET(r,f) (r).eq_boost[0]=(((r).eq_boost[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access EQ_BOOST.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_EQ_BOOSTr(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_EQ_BOOSTr,(_r._eq_boost))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_EQ_BOOSTr(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_EQ_BOOSTr,(_r._eq_boost))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define EQ_BOOSTr BCMI_FUSIONCORE12G_XGXS_EQ_BOOSTr
#define EQ_BOOSTr_SIZE BCMI_FUSIONCORE12G_XGXS_EQ_BOOSTr_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_EQ_BOOSTr_t EQ_BOOSTr_t;
#define EQ_BOOSTr_CLR BCMI_FUSIONCORE12G_XGXS_EQ_BOOSTr_CLR
#define EQ_BOOSTr_SET BCMI_FUSIONCORE12G_XGXS_EQ_BOOSTr_SET
#define EQ_BOOSTr_GET BCMI_FUSIONCORE12G_XGXS_EQ_BOOSTr_GET
#define EQ_BOOSTr_EQ_BOOSTf_GET BCMI_FUSIONCORE12G_XGXS_EQ_BOOSTr_EQ_BOOSTf_GET
#define EQ_BOOSTr_EQ_BOOSTf_SET BCMI_FUSIONCORE12G_XGXS_EQ_BOOSTr_EQ_BOOSTf_SET
#define READ_EQ_BOOSTr BCMI_FUSIONCORE12G_XGXS_READ_EQ_BOOSTr
#define WRITE_EQ_BOOSTr BCMI_FUSIONCORE12G_XGXS_WRITE_EQ_BOOSTr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_EQ_BOOSTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  LB_DATA_EQ
 * BLOCKS:   RXALL
 * REGADDR:  0x80fd
 * DESC:     Rx lb Data Eq (Address 0x80FD)
 * SIZE:     32
 * FIELDS:
 *     LB_DATA_EQ       LB_DATA_EQ
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_LB_DATA_EQr (0x0000f01d | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_LB_DATA_EQr_SIZE 4

/*
 * This structure should be used to declare and program LB_DATA_EQ.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_LB_DATA_EQr_s {
	uint32_t v[1];
	uint32_t lb_data_eq[1];
	uint32_t _lb_data_eq;
} BCMI_FUSIONCORE12G_XGXS_LB_DATA_EQr_t;

#define BCMI_FUSIONCORE12G_XGXS_LB_DATA_EQr_CLR(r) (r).lb_data_eq[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_LB_DATA_EQr_SET(r,d) (r).lb_data_eq[0] = d
#define BCMI_FUSIONCORE12G_XGXS_LB_DATA_EQr_GET(r) (r).lb_data_eq[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_LB_DATA_EQr_LB_DATA_EQf_GET(r) (((r).lb_data_eq[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_LB_DATA_EQr_LB_DATA_EQf_SET(r,f) (r).lb_data_eq[0]=(((r).lb_data_eq[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access LB_DATA_EQ.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_LB_DATA_EQr(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_LB_DATA_EQr,(_r._lb_data_eq))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_LB_DATA_EQr(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_LB_DATA_EQr,(_r._lb_data_eq))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define LB_DATA_EQr BCMI_FUSIONCORE12G_XGXS_LB_DATA_EQr
#define LB_DATA_EQr_SIZE BCMI_FUSIONCORE12G_XGXS_LB_DATA_EQr_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_LB_DATA_EQr_t LB_DATA_EQr_t;
#define LB_DATA_EQr_CLR BCMI_FUSIONCORE12G_XGXS_LB_DATA_EQr_CLR
#define LB_DATA_EQr_SET BCMI_FUSIONCORE12G_XGXS_LB_DATA_EQr_SET
#define LB_DATA_EQr_GET BCMI_FUSIONCORE12G_XGXS_LB_DATA_EQr_GET
#define LB_DATA_EQr_LB_DATA_EQf_GET BCMI_FUSIONCORE12G_XGXS_LB_DATA_EQr_LB_DATA_EQf_GET
#define LB_DATA_EQr_LB_DATA_EQf_SET BCMI_FUSIONCORE12G_XGXS_LB_DATA_EQr_LB_DATA_EQf_SET
#define READ_LB_DATA_EQr BCMI_FUSIONCORE12G_XGXS_READ_LB_DATA_EQr
#define WRITE_LB_DATA_EQr BCMI_FUSIONCORE12G_XGXS_WRITE_LB_DATA_EQr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_LB_DATA_EQr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  LB_ADC_BUFF
 * BLOCKS:   RXALL
 * REGADDR:  0x80fe
 * DESC:     Rx lb ADC Buff (Address 0x80FE)
 * SIZE:     32
 * FIELDS:
 *     LB_ADC_BUFF      LB_ADC_BUFF
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_LB_ADC_BUFFr (0x0000f01e | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_LB_ADC_BUFFr_SIZE 4

/*
 * This structure should be used to declare and program LB_ADC_BUFF.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_LB_ADC_BUFFr_s {
	uint32_t v[1];
	uint32_t lb_adc_buff[1];
	uint32_t _lb_adc_buff;
} BCMI_FUSIONCORE12G_XGXS_LB_ADC_BUFFr_t;

#define BCMI_FUSIONCORE12G_XGXS_LB_ADC_BUFFr_CLR(r) (r).lb_adc_buff[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_LB_ADC_BUFFr_SET(r,d) (r).lb_adc_buff[0] = d
#define BCMI_FUSIONCORE12G_XGXS_LB_ADC_BUFFr_GET(r) (r).lb_adc_buff[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_LB_ADC_BUFFr_LB_ADC_BUFFf_GET(r) (((r).lb_adc_buff[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_LB_ADC_BUFFr_LB_ADC_BUFFf_SET(r,f) (r).lb_adc_buff[0]=(((r).lb_adc_buff[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access LB_ADC_BUFF.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_LB_ADC_BUFFr(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_LB_ADC_BUFFr,(_r._lb_adc_buff))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_LB_ADC_BUFFr(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_LB_ADC_BUFFr,(_r._lb_adc_buff))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define LB_ADC_BUFFr BCMI_FUSIONCORE12G_XGXS_LB_ADC_BUFFr
#define LB_ADC_BUFFr_SIZE BCMI_FUSIONCORE12G_XGXS_LB_ADC_BUFFr_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_LB_ADC_BUFFr_t LB_ADC_BUFFr_t;
#define LB_ADC_BUFFr_CLR BCMI_FUSIONCORE12G_XGXS_LB_ADC_BUFFr_CLR
#define LB_ADC_BUFFr_SET BCMI_FUSIONCORE12G_XGXS_LB_ADC_BUFFr_SET
#define LB_ADC_BUFFr_GET BCMI_FUSIONCORE12G_XGXS_LB_ADC_BUFFr_GET
#define LB_ADC_BUFFr_LB_ADC_BUFFf_GET BCMI_FUSIONCORE12G_XGXS_LB_ADC_BUFFr_LB_ADC_BUFFf_GET
#define LB_ADC_BUFFr_LB_ADC_BUFFf_SET BCMI_FUSIONCORE12G_XGXS_LB_ADC_BUFFr_LB_ADC_BUFFf_SET
#define READ_LB_ADC_BUFFr BCMI_FUSIONCORE12G_XGXS_READ_LB_ADC_BUFFr
#define WRITE_LB_ADC_BUFFr BCMI_FUSIONCORE12G_XGXS_WRITE_LB_ADC_BUFFr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_LB_ADC_BUFFr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  RX_LANE_SWAP
 * BLOCKS:   BLK2
 * REGADDR:  0x8100
 * DESC:     Rx Lane Swap (Addr 0x8100)
 * SIZE:     32
 * FIELDS:
 *     RX_LANE_SWAP     RX_LANE_SWAP
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_RX_LANE_SWAPr (0x00010010 | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_RX_LANE_SWAPr_SIZE 4

/*
 * This structure should be used to declare and program RX_LANE_SWAP.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_RX_LANE_SWAPr_s {
	uint32_t v[1];
	uint32_t rx_lane_swap[1];
	uint32_t _rx_lane_swap;
} BCMI_FUSIONCORE12G_XGXS_RX_LANE_SWAPr_t;

#define BCMI_FUSIONCORE12G_XGXS_RX_LANE_SWAPr_CLR(r) (r).rx_lane_swap[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_RX_LANE_SWAPr_SET(r,d) (r).rx_lane_swap[0] = d
#define BCMI_FUSIONCORE12G_XGXS_RX_LANE_SWAPr_GET(r) (r).rx_lane_swap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_RX_LANE_SWAPr_RX_LANE_SWAPf_GET(r) (((r).rx_lane_swap[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_RX_LANE_SWAPr_RX_LANE_SWAPf_SET(r,f) (r).rx_lane_swap[0]=(((r).rx_lane_swap[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access RX_LANE_SWAP.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_RX_LANE_SWAPr(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_RX_LANE_SWAPr,(_r._rx_lane_swap))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_RX_LANE_SWAPr(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_RX_LANE_SWAPr,(_r._rx_lane_swap))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_LANE_SWAPr BCMI_FUSIONCORE12G_XGXS_RX_LANE_SWAPr
#define RX_LANE_SWAPr_SIZE BCMI_FUSIONCORE12G_XGXS_RX_LANE_SWAPr_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_RX_LANE_SWAPr_t RX_LANE_SWAPr_t;
#define RX_LANE_SWAPr_CLR BCMI_FUSIONCORE12G_XGXS_RX_LANE_SWAPr_CLR
#define RX_LANE_SWAPr_SET BCMI_FUSIONCORE12G_XGXS_RX_LANE_SWAPr_SET
#define RX_LANE_SWAPr_GET BCMI_FUSIONCORE12G_XGXS_RX_LANE_SWAPr_GET
#define RX_LANE_SWAPr_RX_LANE_SWAPf_GET BCMI_FUSIONCORE12G_XGXS_RX_LANE_SWAPr_RX_LANE_SWAPf_GET
#define RX_LANE_SWAPr_RX_LANE_SWAPf_SET BCMI_FUSIONCORE12G_XGXS_RX_LANE_SWAPr_RX_LANE_SWAPf_SET
#define READ_RX_LANE_SWAPr BCMI_FUSIONCORE12G_XGXS_READ_RX_LANE_SWAPr
#define WRITE_RX_LANE_SWAPr BCMI_FUSIONCORE12G_XGXS_WRITE_RX_LANE_SWAPr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_RX_LANE_SWAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  TX_LANE_SWAP
 * BLOCKS:   BLK2
 * REGADDR:  0x8101
 * DESC:     Tx Lane Swap (Addr 0x8101)
 * SIZE:     32
 * FIELDS:
 *     TX_LANE_SWAP     TX_LANE_SWAP
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_TX_LANE_SWAPr (0x00010011 | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_TX_LANE_SWAPr_SIZE 4

/*
 * This structure should be used to declare and program TX_LANE_SWAP.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_TX_LANE_SWAPr_s {
	uint32_t v[1];
	uint32_t tx_lane_swap[1];
	uint32_t _tx_lane_swap;
} BCMI_FUSIONCORE12G_XGXS_TX_LANE_SWAPr_t;

#define BCMI_FUSIONCORE12G_XGXS_TX_LANE_SWAPr_CLR(r) (r).tx_lane_swap[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_TX_LANE_SWAPr_SET(r,d) (r).tx_lane_swap[0] = d
#define BCMI_FUSIONCORE12G_XGXS_TX_LANE_SWAPr_GET(r) (r).tx_lane_swap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_TX_LANE_SWAPr_TX_LANE_SWAPf_GET(r) (((r).tx_lane_swap[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_TX_LANE_SWAPr_TX_LANE_SWAPf_SET(r,f) (r).tx_lane_swap[0]=(((r).tx_lane_swap[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access TX_LANE_SWAP.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_TX_LANE_SWAPr(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_TX_LANE_SWAPr,(_r._tx_lane_swap))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_TX_LANE_SWAPr(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_TX_LANE_SWAPr,(_r._tx_lane_swap))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TX_LANE_SWAPr BCMI_FUSIONCORE12G_XGXS_TX_LANE_SWAPr
#define TX_LANE_SWAPr_SIZE BCMI_FUSIONCORE12G_XGXS_TX_LANE_SWAPr_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_TX_LANE_SWAPr_t TX_LANE_SWAPr_t;
#define TX_LANE_SWAPr_CLR BCMI_FUSIONCORE12G_XGXS_TX_LANE_SWAPr_CLR
#define TX_LANE_SWAPr_SET BCMI_FUSIONCORE12G_XGXS_TX_LANE_SWAPr_SET
#define TX_LANE_SWAPr_GET BCMI_FUSIONCORE12G_XGXS_TX_LANE_SWAPr_GET
#define TX_LANE_SWAPr_TX_LANE_SWAPf_GET BCMI_FUSIONCORE12G_XGXS_TX_LANE_SWAPr_TX_LANE_SWAPf_GET
#define TX_LANE_SWAPr_TX_LANE_SWAPf_SET BCMI_FUSIONCORE12G_XGXS_TX_LANE_SWAPr_TX_LANE_SWAPf_SET
#define READ_TX_LANE_SWAPr BCMI_FUSIONCORE12G_XGXS_READ_TX_LANE_SWAPr
#define WRITE_TX_LANE_SWAPr BCMI_FUSIONCORE12G_XGXS_WRITE_TX_LANE_SWAPr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_TX_LANE_SWAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  DIGITAL_1000X_CTRL1
 * BLOCKS:   SERDES
 * REGADDR:  0x8300
 * DESC:     1000XControl1 (Addr 0x8300)
 * SIZE:     32
 * FIELDS:
 *     DIGITAL_1000X_CTRL1 DIGITAL_1000X_CTRL1
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL1r (0x00030010 | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL1r_SIZE 4

/*
 * This structure should be used to declare and program DIGITAL_1000X_CTRL1.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL1r_s {
	uint32_t v[1];
	uint32_t digital_1000x_ctrl1[1];
	uint32_t _digital_1000x_ctrl1;
} BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL1r_t;

#define BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL1r_CLR(r) (r).digital_1000x_ctrl1[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL1r_SET(r,d) (r).digital_1000x_ctrl1[0] = d
#define BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL1r_GET(r) (r).digital_1000x_ctrl1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL1r_DIGITAL_1000X_CTRL1f_GET(r) (((r).digital_1000x_ctrl1[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL1r_DIGITAL_1000X_CTRL1f_SET(r,f) (r).digital_1000x_ctrl1[0]=(((r).digital_1000x_ctrl1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access DIGITAL_1000X_CTRL1.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_DIGITAL_1000X_CTRL1r(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL1r,(_r._digital_1000x_ctrl1))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_DIGITAL_1000X_CTRL1r(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL1r,(_r._digital_1000x_ctrl1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DIGITAL_1000X_CTRL1r BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL1r
#define DIGITAL_1000X_CTRL1r_SIZE BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL1r_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL1r_t DIGITAL_1000X_CTRL1r_t;
#define DIGITAL_1000X_CTRL1r_CLR BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL1r_CLR
#define DIGITAL_1000X_CTRL1r_SET BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL1r_SET
#define DIGITAL_1000X_CTRL1r_GET BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL1r_GET
#define DIGITAL_1000X_CTRL1r_DIGITAL_1000X_CTRL1f_GET BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL1r_DIGITAL_1000X_CTRL1f_GET
#define DIGITAL_1000X_CTRL1r_DIGITAL_1000X_CTRL1f_SET BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL1r_DIGITAL_1000X_CTRL1f_SET
#define READ_DIGITAL_1000X_CTRL1r BCMI_FUSIONCORE12G_XGXS_READ_DIGITAL_1000X_CTRL1r
#define WRITE_DIGITAL_1000X_CTRL1r BCMI_FUSIONCORE12G_XGXS_WRITE_DIGITAL_1000X_CTRL1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  DIGITAL_1000X_CTRL2
 * BLOCKS:   SERDES
 * REGADDR:  0x8301
 * DESC:     1000XControl2 (Addr 0x8301)
 * SIZE:     32
 * FIELDS:
 *     DIGITAL_1000X_CTRL2 DIGITAL_1000X_CTRL2
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL2r (0x00030011 | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL2r_SIZE 4

/*
 * This structure should be used to declare and program DIGITAL_1000X_CTRL2.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL2r_s {
	uint32_t v[1];
	uint32_t digital_1000x_ctrl2[1];
	uint32_t _digital_1000x_ctrl2;
} BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL2r_t;

#define BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL2r_CLR(r) (r).digital_1000x_ctrl2[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL2r_SET(r,d) (r).digital_1000x_ctrl2[0] = d
#define BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL2r_GET(r) (r).digital_1000x_ctrl2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL2r_DIGITAL_1000X_CTRL2f_GET(r) (((r).digital_1000x_ctrl2[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL2r_DIGITAL_1000X_CTRL2f_SET(r,f) (r).digital_1000x_ctrl2[0]=(((r).digital_1000x_ctrl2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access DIGITAL_1000X_CTRL2.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_DIGITAL_1000X_CTRL2r(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL2r,(_r._digital_1000x_ctrl2))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_DIGITAL_1000X_CTRL2r(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL2r,(_r._digital_1000x_ctrl2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DIGITAL_1000X_CTRL2r BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL2r
#define DIGITAL_1000X_CTRL2r_SIZE BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL2r_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL2r_t DIGITAL_1000X_CTRL2r_t;
#define DIGITAL_1000X_CTRL2r_CLR BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL2r_CLR
#define DIGITAL_1000X_CTRL2r_SET BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL2r_SET
#define DIGITAL_1000X_CTRL2r_GET BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL2r_GET
#define DIGITAL_1000X_CTRL2r_DIGITAL_1000X_CTRL2f_GET BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL2r_DIGITAL_1000X_CTRL2f_GET
#define DIGITAL_1000X_CTRL2r_DIGITAL_1000X_CTRL2f_SET BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL2r_DIGITAL_1000X_CTRL2f_SET
#define READ_DIGITAL_1000X_CTRL2r BCMI_FUSIONCORE12G_XGXS_READ_DIGITAL_1000X_CTRL2r
#define WRITE_DIGITAL_1000X_CTRL2r BCMI_FUSIONCORE12G_XGXS_WRITE_DIGITAL_1000X_CTRL2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  DIGITAL_1000X_CTRL3
 * BLOCKS:   SERDES
 * REGADDR:  0x8302
 * DESC:     1000XControl3 (Addr 0x8302)
 * SIZE:     32
 * FIELDS:
 *     DIGITAL_1000X_CTRL3 DIGITAL_1000X_CTRL3
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL3r (0x00030012 | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL3r_SIZE 4

/*
 * This structure should be used to declare and program DIGITAL_1000X_CTRL3.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL3r_s {
	uint32_t v[1];
	uint32_t digital_1000x_ctrl3[1];
	uint32_t _digital_1000x_ctrl3;
} BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL3r_t;

#define BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL3r_CLR(r) (r).digital_1000x_ctrl3[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL3r_SET(r,d) (r).digital_1000x_ctrl3[0] = d
#define BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL3r_GET(r) (r).digital_1000x_ctrl3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL3r_DIGITAL_1000X_CTRL3f_GET(r) (((r).digital_1000x_ctrl3[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL3r_DIGITAL_1000X_CTRL3f_SET(r,f) (r).digital_1000x_ctrl3[0]=(((r).digital_1000x_ctrl3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access DIGITAL_1000X_CTRL3.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_DIGITAL_1000X_CTRL3r(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL3r,(_r._digital_1000x_ctrl3))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_DIGITAL_1000X_CTRL3r(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL3r,(_r._digital_1000x_ctrl3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DIGITAL_1000X_CTRL3r BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL3r
#define DIGITAL_1000X_CTRL3r_SIZE BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL3r_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL3r_t DIGITAL_1000X_CTRL3r_t;
#define DIGITAL_1000X_CTRL3r_CLR BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL3r_CLR
#define DIGITAL_1000X_CTRL3r_SET BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL3r_SET
#define DIGITAL_1000X_CTRL3r_GET BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL3r_GET
#define DIGITAL_1000X_CTRL3r_DIGITAL_1000X_CTRL3f_GET BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL3r_DIGITAL_1000X_CTRL3f_GET
#define DIGITAL_1000X_CTRL3r_DIGITAL_1000X_CTRL3f_SET BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL3r_DIGITAL_1000X_CTRL3f_SET
#define READ_DIGITAL_1000X_CTRL3r BCMI_FUSIONCORE12G_XGXS_READ_DIGITAL_1000X_CTRL3r
#define WRITE_DIGITAL_1000X_CTRL3r BCMI_FUSIONCORE12G_XGXS_WRITE_DIGITAL_1000X_CTRL3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  DIGITAL_1000X_CTRL4
 * BLOCKS:   SERDES
 * REGADDR:  0x8303
 * DESC:     1000XControl4 (Addr 0x8303)
 * SIZE:     32
 * FIELDS:
 *     DIGITAL_1000X_CTRL4 DIGITAL_1000X_CTRL4
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL4r (0x00030013 | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL4r_SIZE 4

/*
 * This structure should be used to declare and program DIGITAL_1000X_CTRL4.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL4r_s {
	uint32_t v[1];
	uint32_t digital_1000x_ctrl4[1];
	uint32_t _digital_1000x_ctrl4;
} BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL4r_t;

#define BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL4r_CLR(r) (r).digital_1000x_ctrl4[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL4r_SET(r,d) (r).digital_1000x_ctrl4[0] = d
#define BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL4r_GET(r) (r).digital_1000x_ctrl4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL4r_DIGITAL_1000X_CTRL4f_GET(r) (((r).digital_1000x_ctrl4[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL4r_DIGITAL_1000X_CTRL4f_SET(r,f) (r).digital_1000x_ctrl4[0]=(((r).digital_1000x_ctrl4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access DIGITAL_1000X_CTRL4.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_DIGITAL_1000X_CTRL4r(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL4r,(_r._digital_1000x_ctrl4))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_DIGITAL_1000X_CTRL4r(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL4r,(_r._digital_1000x_ctrl4))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DIGITAL_1000X_CTRL4r BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL4r
#define DIGITAL_1000X_CTRL4r_SIZE BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL4r_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL4r_t DIGITAL_1000X_CTRL4r_t;
#define DIGITAL_1000X_CTRL4r_CLR BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL4r_CLR
#define DIGITAL_1000X_CTRL4r_SET BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL4r_SET
#define DIGITAL_1000X_CTRL4r_GET BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL4r_GET
#define DIGITAL_1000X_CTRL4r_DIGITAL_1000X_CTRL4f_GET BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL4r_DIGITAL_1000X_CTRL4f_GET
#define DIGITAL_1000X_CTRL4r_DIGITAL_1000X_CTRL4f_SET BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL4r_DIGITAL_1000X_CTRL4f_SET
#define READ_DIGITAL_1000X_CTRL4r BCMI_FUSIONCORE12G_XGXS_READ_DIGITAL_1000X_CTRL4r
#define WRITE_DIGITAL_1000X_CTRL4r BCMI_FUSIONCORE12G_XGXS_WRITE_DIGITAL_1000X_CTRL4r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_CTRL4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  DIGITAL_1000X_STAT1
 * BLOCKS:   SERDES
 * REGADDR:  0x8304
 * DESC:     1000XStatus1 (Addr 0x8304)
 * SIZE:     32
 * FIELDS:
 *     DIGITAL_1000X_STAT1 DIGITAL_1000X_STAT1
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_STAT1r (0x00030014 | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_STAT1r_SIZE 4

/*
 * This structure should be used to declare and program DIGITAL_1000X_STAT1.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_STAT1r_s {
	uint32_t v[1];
	uint32_t digital_1000x_stat1[1];
	uint32_t _digital_1000x_stat1;
} BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_STAT1r_t;

#define BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_STAT1r_CLR(r) (r).digital_1000x_stat1[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_STAT1r_SET(r,d) (r).digital_1000x_stat1[0] = d
#define BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_STAT1r_GET(r) (r).digital_1000x_stat1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_STAT1r_DIGITAL_1000X_STAT1f_GET(r) (((r).digital_1000x_stat1[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_STAT1r_DIGITAL_1000X_STAT1f_SET(r,f) (r).digital_1000x_stat1[0]=(((r).digital_1000x_stat1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access DIGITAL_1000X_STAT1.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_DIGITAL_1000X_STAT1r(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_STAT1r,(_r._digital_1000x_stat1))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_DIGITAL_1000X_STAT1r(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_STAT1r,(_r._digital_1000x_stat1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DIGITAL_1000X_STAT1r BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_STAT1r
#define DIGITAL_1000X_STAT1r_SIZE BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_STAT1r_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_STAT1r_t DIGITAL_1000X_STAT1r_t;
#define DIGITAL_1000X_STAT1r_CLR BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_STAT1r_CLR
#define DIGITAL_1000X_STAT1r_SET BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_STAT1r_SET
#define DIGITAL_1000X_STAT1r_GET BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_STAT1r_GET
#define DIGITAL_1000X_STAT1r_DIGITAL_1000X_STAT1f_GET BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_STAT1r_DIGITAL_1000X_STAT1f_GET
#define DIGITAL_1000X_STAT1r_DIGITAL_1000X_STAT1f_SET BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_STAT1r_DIGITAL_1000X_STAT1f_SET
#define READ_DIGITAL_1000X_STAT1r BCMI_FUSIONCORE12G_XGXS_READ_DIGITAL_1000X_STAT1r
#define WRITE_DIGITAL_1000X_STAT1r BCMI_FUSIONCORE12G_XGXS_WRITE_DIGITAL_1000X_STAT1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_STAT1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  DIGITAL_1000X_STAT2
 * BLOCKS:   SERDES
 * REGADDR:  0x8305
 * DESC:     1000XStatus2 (Addr 0x8305)
 * SIZE:     32
 * FIELDS:
 *     DIGITAL_1000X_STAT2 DIGITAL_1000X_STAT2
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_STAT2r (0x00030015 | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_STAT2r_SIZE 4

/*
 * This structure should be used to declare and program DIGITAL_1000X_STAT2.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_STAT2r_s {
	uint32_t v[1];
	uint32_t digital_1000x_stat2[1];
	uint32_t _digital_1000x_stat2;
} BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_STAT2r_t;

#define BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_STAT2r_CLR(r) (r).digital_1000x_stat2[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_STAT2r_SET(r,d) (r).digital_1000x_stat2[0] = d
#define BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_STAT2r_GET(r) (r).digital_1000x_stat2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_STAT2r_DIGITAL_1000X_STAT2f_GET(r) (((r).digital_1000x_stat2[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_STAT2r_DIGITAL_1000X_STAT2f_SET(r,f) (r).digital_1000x_stat2[0]=(((r).digital_1000x_stat2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access DIGITAL_1000X_STAT2.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_DIGITAL_1000X_STAT2r(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_STAT2r,(_r._digital_1000x_stat2))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_DIGITAL_1000X_STAT2r(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_STAT2r,(_r._digital_1000x_stat2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DIGITAL_1000X_STAT2r BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_STAT2r
#define DIGITAL_1000X_STAT2r_SIZE BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_STAT2r_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_STAT2r_t DIGITAL_1000X_STAT2r_t;
#define DIGITAL_1000X_STAT2r_CLR BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_STAT2r_CLR
#define DIGITAL_1000X_STAT2r_SET BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_STAT2r_SET
#define DIGITAL_1000X_STAT2r_GET BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_STAT2r_GET
#define DIGITAL_1000X_STAT2r_DIGITAL_1000X_STAT2f_GET BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_STAT2r_DIGITAL_1000X_STAT2f_GET
#define DIGITAL_1000X_STAT2r_DIGITAL_1000X_STAT2f_SET BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_STAT2r_DIGITAL_1000X_STAT2f_SET
#define READ_DIGITAL_1000X_STAT2r BCMI_FUSIONCORE12G_XGXS_READ_DIGITAL_1000X_STAT2r
#define WRITE_DIGITAL_1000X_STAT2r BCMI_FUSIONCORE12G_XGXS_WRITE_DIGITAL_1000X_STAT2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_STAT2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  DIGITAL_1000X_STAT3
 * BLOCKS:   SERDES
 * REGADDR:  0x8306
 * DESC:     1000XStatus3 (Addr 0x8306)
 * SIZE:     32
 * FIELDS:
 *     DIGITAL_1000X_STAT3 DIGITAL_1000X_STAT3
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_STAT3r (0x00030016 | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_STAT3r_SIZE 4

/*
 * This structure should be used to declare and program DIGITAL_1000X_STAT3.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_STAT3r_s {
	uint32_t v[1];
	uint32_t digital_1000x_stat3[1];
	uint32_t _digital_1000x_stat3;
} BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_STAT3r_t;

#define BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_STAT3r_CLR(r) (r).digital_1000x_stat3[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_STAT3r_SET(r,d) (r).digital_1000x_stat3[0] = d
#define BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_STAT3r_GET(r) (r).digital_1000x_stat3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_STAT3r_DIGITAL_1000X_STAT3f_GET(r) (((r).digital_1000x_stat3[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_STAT3r_DIGITAL_1000X_STAT3f_SET(r,f) (r).digital_1000x_stat3[0]=(((r).digital_1000x_stat3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access DIGITAL_1000X_STAT3.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_DIGITAL_1000X_STAT3r(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_STAT3r,(_r._digital_1000x_stat3))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_DIGITAL_1000X_STAT3r(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_STAT3r,(_r._digital_1000x_stat3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DIGITAL_1000X_STAT3r BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_STAT3r
#define DIGITAL_1000X_STAT3r_SIZE BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_STAT3r_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_STAT3r_t DIGITAL_1000X_STAT3r_t;
#define DIGITAL_1000X_STAT3r_CLR BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_STAT3r_CLR
#define DIGITAL_1000X_STAT3r_SET BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_STAT3r_SET
#define DIGITAL_1000X_STAT3r_GET BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_STAT3r_GET
#define DIGITAL_1000X_STAT3r_DIGITAL_1000X_STAT3f_GET BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_STAT3r_DIGITAL_1000X_STAT3f_GET
#define DIGITAL_1000X_STAT3r_DIGITAL_1000X_STAT3f_SET BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_STAT3r_DIGITAL_1000X_STAT3f_SET
#define READ_DIGITAL_1000X_STAT3r BCMI_FUSIONCORE12G_XGXS_READ_DIGITAL_1000X_STAT3r
#define WRITE_DIGITAL_1000X_STAT3r BCMI_FUSIONCORE12G_XGXS_WRITE_DIGITAL_1000X_STAT3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_DIGITAL_1000X_STAT3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  DIGITAL_MISC1
 * BLOCKS:   SERDES
 * REGADDR:  0x8308
 * DESC:     Misc1 (Addr 0x8308)
 * SIZE:     32
 * FIELDS:
 *     DIGITAL_MISC1    DIGITAL_MISC1
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_DIGITAL_MISC1r (0x00030018 | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_DIGITAL_MISC1r_SIZE 4

/*
 * This structure should be used to declare and program DIGITAL_MISC1.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_DIGITAL_MISC1r_s {
	uint32_t v[1];
	uint32_t digital_misc1[1];
	uint32_t _digital_misc1;
} BCMI_FUSIONCORE12G_XGXS_DIGITAL_MISC1r_t;

#define BCMI_FUSIONCORE12G_XGXS_DIGITAL_MISC1r_CLR(r) (r).digital_misc1[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_DIGITAL_MISC1r_SET(r,d) (r).digital_misc1[0] = d
#define BCMI_FUSIONCORE12G_XGXS_DIGITAL_MISC1r_GET(r) (r).digital_misc1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_DIGITAL_MISC1r_DIGITAL_MISC1f_GET(r) (((r).digital_misc1[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_DIGITAL_MISC1r_DIGITAL_MISC1f_SET(r,f) (r).digital_misc1[0]=(((r).digital_misc1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access DIGITAL_MISC1.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_DIGITAL_MISC1r(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_DIGITAL_MISC1r,(_r._digital_misc1))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_DIGITAL_MISC1r(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_DIGITAL_MISC1r,(_r._digital_misc1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DIGITAL_MISC1r BCMI_FUSIONCORE12G_XGXS_DIGITAL_MISC1r
#define DIGITAL_MISC1r_SIZE BCMI_FUSIONCORE12G_XGXS_DIGITAL_MISC1r_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_DIGITAL_MISC1r_t DIGITAL_MISC1r_t;
#define DIGITAL_MISC1r_CLR BCMI_FUSIONCORE12G_XGXS_DIGITAL_MISC1r_CLR
#define DIGITAL_MISC1r_SET BCMI_FUSIONCORE12G_XGXS_DIGITAL_MISC1r_SET
#define DIGITAL_MISC1r_GET BCMI_FUSIONCORE12G_XGXS_DIGITAL_MISC1r_GET
#define DIGITAL_MISC1r_DIGITAL_MISC1f_GET BCMI_FUSIONCORE12G_XGXS_DIGITAL_MISC1r_DIGITAL_MISC1f_GET
#define DIGITAL_MISC1r_DIGITAL_MISC1f_SET BCMI_FUSIONCORE12G_XGXS_DIGITAL_MISC1r_DIGITAL_MISC1f_SET
#define READ_DIGITAL_MISC1r BCMI_FUSIONCORE12G_XGXS_READ_DIGITAL_MISC1r
#define WRITE_DIGITAL_MISC1r BCMI_FUSIONCORE12G_XGXS_WRITE_DIGITAL_MISC1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_DIGITAL_MISC1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  DIGITAL_MISC2
 * BLOCKS:   SERDES
 * REGADDR:  0x8309
 * DESC:     Misc2 (Addr 0x8309)
 * SIZE:     32
 * FIELDS:
 *     DIGITAL_MISC2    DIGITAL_MISC2
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_DIGITAL_MISC2r (0x00030019 | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_DIGITAL_MISC2r_SIZE 4

/*
 * This structure should be used to declare and program DIGITAL_MISC2.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_DIGITAL_MISC2r_s {
	uint32_t v[1];
	uint32_t digital_misc2[1];
	uint32_t _digital_misc2;
} BCMI_FUSIONCORE12G_XGXS_DIGITAL_MISC2r_t;

#define BCMI_FUSIONCORE12G_XGXS_DIGITAL_MISC2r_CLR(r) (r).digital_misc2[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_DIGITAL_MISC2r_SET(r,d) (r).digital_misc2[0] = d
#define BCMI_FUSIONCORE12G_XGXS_DIGITAL_MISC2r_GET(r) (r).digital_misc2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_DIGITAL_MISC2r_DIGITAL_MISC2f_GET(r) (((r).digital_misc2[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_DIGITAL_MISC2r_DIGITAL_MISC2f_SET(r,f) (r).digital_misc2[0]=(((r).digital_misc2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access DIGITAL_MISC2.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_DIGITAL_MISC2r(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_DIGITAL_MISC2r,(_r._digital_misc2))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_DIGITAL_MISC2r(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_DIGITAL_MISC2r,(_r._digital_misc2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DIGITAL_MISC2r BCMI_FUSIONCORE12G_XGXS_DIGITAL_MISC2r
#define DIGITAL_MISC2r_SIZE BCMI_FUSIONCORE12G_XGXS_DIGITAL_MISC2r_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_DIGITAL_MISC2r_t DIGITAL_MISC2r_t;
#define DIGITAL_MISC2r_CLR BCMI_FUSIONCORE12G_XGXS_DIGITAL_MISC2r_CLR
#define DIGITAL_MISC2r_SET BCMI_FUSIONCORE12G_XGXS_DIGITAL_MISC2r_SET
#define DIGITAL_MISC2r_GET BCMI_FUSIONCORE12G_XGXS_DIGITAL_MISC2r_GET
#define DIGITAL_MISC2r_DIGITAL_MISC2f_GET BCMI_FUSIONCORE12G_XGXS_DIGITAL_MISC2r_DIGITAL_MISC2f_GET
#define DIGITAL_MISC2r_DIGITAL_MISC2f_SET BCMI_FUSIONCORE12G_XGXS_DIGITAL_MISC2r_DIGITAL_MISC2f_SET
#define READ_DIGITAL_MISC2r BCMI_FUSIONCORE12G_XGXS_READ_DIGITAL_MISC2r
#define WRITE_DIGITAL_MISC2r BCMI_FUSIONCORE12G_XGXS_WRITE_DIGITAL_MISC2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_DIGITAL_MISC2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  UP1
 * BLOCKS:   OVER1G
 * REGADDR:  0x8329
 * DESC:     UP 1 (Addr 0x8329)
 * SIZE:     32
 * FIELDS:
 *     UP1              UP1
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_UP1r (0x00032019 | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_UP1r_SIZE 4

/*
 * This structure should be used to declare and program UP1.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_UP1r_s {
	uint32_t v[1];
	uint32_t up1[1];
	uint32_t _up1;
} BCMI_FUSIONCORE12G_XGXS_UP1r_t;

#define BCMI_FUSIONCORE12G_XGXS_UP1r_CLR(r) (r).up1[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_UP1r_SET(r,d) (r).up1[0] = d
#define BCMI_FUSIONCORE12G_XGXS_UP1r_GET(r) (r).up1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_UP1r_UP1f_GET(r) (((r).up1[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_UP1r_UP1f_SET(r,f) (r).up1[0]=(((r).up1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access UP1.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_UP1r(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_UP1r,(_r._up1))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_UP1r(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_UP1r,(_r._up1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define UP1r BCMI_FUSIONCORE12G_XGXS_UP1r
#define UP1r_SIZE BCMI_FUSIONCORE12G_XGXS_UP1r_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_UP1r_t UP1r_t;
#define UP1r_CLR BCMI_FUSIONCORE12G_XGXS_UP1r_CLR
#define UP1r_SET BCMI_FUSIONCORE12G_XGXS_UP1r_SET
#define UP1r_GET BCMI_FUSIONCORE12G_XGXS_UP1r_GET
#define UP1r_UP1f_GET BCMI_FUSIONCORE12G_XGXS_UP1r_UP1f_GET
#define UP1r_UP1f_SET BCMI_FUSIONCORE12G_XGXS_UP1r_UP1f_SET
#define READ_UP1r BCMI_FUSIONCORE12G_XGXS_READ_UP1r
#define WRITE_UP1r BCMI_FUSIONCORE12G_XGXS_WRITE_UP1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_UP1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  LP_UP1
 * BLOCKS:   OVER1G
 * REGADDR:  0x832c
 * DESC:     LP UP 1 (Addr 0x832C)
 * SIZE:     32
 * FIELDS:
 *     LP_UP1           LP_UP1
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_LP_UP1r (0x0003201c | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_LP_UP1r_SIZE 4

/*
 * This structure should be used to declare and program LP_UP1.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_LP_UP1r_s {
	uint32_t v[1];
	uint32_t lp_up1[1];
	uint32_t _lp_up1;
} BCMI_FUSIONCORE12G_XGXS_LP_UP1r_t;

#define BCMI_FUSIONCORE12G_XGXS_LP_UP1r_CLR(r) (r).lp_up1[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_LP_UP1r_SET(r,d) (r).lp_up1[0] = d
#define BCMI_FUSIONCORE12G_XGXS_LP_UP1r_GET(r) (r).lp_up1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_LP_UP1r_LP_UP1f_GET(r) (((r).lp_up1[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_LP_UP1r_LP_UP1f_SET(r,f) (r).lp_up1[0]=(((r).lp_up1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access LP_UP1.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_LP_UP1r(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_LP_UP1r,(_r._lp_up1))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_LP_UP1r(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_LP_UP1r,(_r._lp_up1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define LP_UP1r BCMI_FUSIONCORE12G_XGXS_LP_UP1r
#define LP_UP1r_SIZE BCMI_FUSIONCORE12G_XGXS_LP_UP1r_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_LP_UP1r_t LP_UP1r_t;
#define LP_UP1r_CLR BCMI_FUSIONCORE12G_XGXS_LP_UP1r_CLR
#define LP_UP1r_SET BCMI_FUSIONCORE12G_XGXS_LP_UP1r_SET
#define LP_UP1r_GET BCMI_FUSIONCORE12G_XGXS_LP_UP1r_GET
#define LP_UP1r_LP_UP1f_GET BCMI_FUSIONCORE12G_XGXS_LP_UP1r_LP_UP1f_GET
#define LP_UP1r_LP_UP1f_SET BCMI_FUSIONCORE12G_XGXS_LP_UP1r_LP_UP1f_SET
#define READ_LP_UP1r BCMI_FUSIONCORE12G_XGXS_READ_LP_UP1r
#define WRITE_LP_UP1r BCMI_FUSIONCORE12G_XGXS_WRITE_LP_UP1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_LP_UP1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  PARDET10G_STAT
 * BLOCKS:   PARDET10G
 * REGADDR:  0x8340
 * DESC:     parDet10GStatus (Addr 0x8340)
 * SIZE:     32
 * FIELDS:
 *     PARDET10G_STAT   PARDET10G_STAT
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_PARDET10G_STATr (0x00034010 | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_PARDET10G_STATr_SIZE 4

/*
 * This structure should be used to declare and program PARDET10G_STAT.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_PARDET10G_STATr_s {
	uint32_t v[1];
	uint32_t pardet10g_stat[1];
	uint32_t _pardet10g_stat;
} BCMI_FUSIONCORE12G_XGXS_PARDET10G_STATr_t;

#define BCMI_FUSIONCORE12G_XGXS_PARDET10G_STATr_CLR(r) (r).pardet10g_stat[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_PARDET10G_STATr_SET(r,d) (r).pardet10g_stat[0] = d
#define BCMI_FUSIONCORE12G_XGXS_PARDET10G_STATr_GET(r) (r).pardet10g_stat[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_PARDET10G_STATr_PARDET10G_STATf_GET(r) (((r).pardet10g_stat[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_PARDET10G_STATr_PARDET10G_STATf_SET(r,f) (r).pardet10g_stat[0]=(((r).pardet10g_stat[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PARDET10G_STAT.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_PARDET10G_STATr(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_PARDET10G_STATr,(_r._pardet10g_stat))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_PARDET10G_STATr(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_PARDET10G_STATr,(_r._pardet10g_stat))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PARDET10G_STATr BCMI_FUSIONCORE12G_XGXS_PARDET10G_STATr
#define PARDET10G_STATr_SIZE BCMI_FUSIONCORE12G_XGXS_PARDET10G_STATr_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_PARDET10G_STATr_t PARDET10G_STATr_t;
#define PARDET10G_STATr_CLR BCMI_FUSIONCORE12G_XGXS_PARDET10G_STATr_CLR
#define PARDET10G_STATr_SET BCMI_FUSIONCORE12G_XGXS_PARDET10G_STATr_SET
#define PARDET10G_STATr_GET BCMI_FUSIONCORE12G_XGXS_PARDET10G_STATr_GET
#define PARDET10G_STATr_PARDET10G_STATf_GET BCMI_FUSIONCORE12G_XGXS_PARDET10G_STATr_PARDET10G_STATf_GET
#define PARDET10G_STATr_PARDET10G_STATf_SET BCMI_FUSIONCORE12G_XGXS_PARDET10G_STATr_PARDET10G_STATf_SET
#define READ_PARDET10G_STATr BCMI_FUSIONCORE12G_XGXS_READ_PARDET10G_STATr
#define WRITE_PARDET10G_STATr BCMI_FUSIONCORE12G_XGXS_WRITE_PARDET10G_STATr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_PARDET10G_STATr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  PARDET10G_CTRL
 * BLOCKS:   PARDET10G
 * REGADDR:  0x8341
 * DESC:     parDet10GControl (Addr 0x8341)
 * SIZE:     32
 * FIELDS:
 *     PARDET10G_CTRL   PARDET10G_CTRL
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_PARDET10G_CTRLr (0x00034011 | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_PARDET10G_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program PARDET10G_CTRL.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_PARDET10G_CTRLr_s {
	uint32_t v[1];
	uint32_t pardet10g_ctrl[1];
	uint32_t _pardet10g_ctrl;
} BCMI_FUSIONCORE12G_XGXS_PARDET10G_CTRLr_t;

#define BCMI_FUSIONCORE12G_XGXS_PARDET10G_CTRLr_CLR(r) (r).pardet10g_ctrl[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_PARDET10G_CTRLr_SET(r,d) (r).pardet10g_ctrl[0] = d
#define BCMI_FUSIONCORE12G_XGXS_PARDET10G_CTRLr_GET(r) (r).pardet10g_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_PARDET10G_CTRLr_PARDET10G_CTRLf_GET(r) (((r).pardet10g_ctrl[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_PARDET10G_CTRLr_PARDET10G_CTRLf_SET(r,f) (r).pardet10g_ctrl[0]=(((r).pardet10g_ctrl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PARDET10G_CTRL.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_PARDET10G_CTRLr(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_PARDET10G_CTRLr,(_r._pardet10g_ctrl))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_PARDET10G_CTRLr(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_PARDET10G_CTRLr,(_r._pardet10g_ctrl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PARDET10G_CTRLr BCMI_FUSIONCORE12G_XGXS_PARDET10G_CTRLr
#define PARDET10G_CTRLr_SIZE BCMI_FUSIONCORE12G_XGXS_PARDET10G_CTRLr_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_PARDET10G_CTRLr_t PARDET10G_CTRLr_t;
#define PARDET10G_CTRLr_CLR BCMI_FUSIONCORE12G_XGXS_PARDET10G_CTRLr_CLR
#define PARDET10G_CTRLr_SET BCMI_FUSIONCORE12G_XGXS_PARDET10G_CTRLr_SET
#define PARDET10G_CTRLr_GET BCMI_FUSIONCORE12G_XGXS_PARDET10G_CTRLr_GET
#define PARDET10G_CTRLr_PARDET10G_CTRLf_GET BCMI_FUSIONCORE12G_XGXS_PARDET10G_CTRLr_PARDET10G_CTRLf_GET
#define PARDET10G_CTRLr_PARDET10G_CTRLf_SET BCMI_FUSIONCORE12G_XGXS_PARDET10G_CTRLr_PARDET10G_CTRLf_SET
#define READ_PARDET10G_CTRLr BCMI_FUSIONCORE12G_XGXS_READ_PARDET10G_CTRLr
#define WRITE_PARDET10G_CTRLr BCMI_FUSIONCORE12G_XGXS_WRITE_PARDET10G_CTRLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_PARDET10G_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  SIGDET
 * BLOCKS:   PARDET10G
 * REGADDR:  0x8342
 * DESC:     parDet10GSigDet (Addr 0x8342)
 * SIZE:     32
 * FIELDS:
 *     SIGDET           SIGDET
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_SIGDETr (0x00034012 | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_SIGDETr_SIZE 4

/*
 * This structure should be used to declare and program SIGDET.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_SIGDETr_s {
	uint32_t v[1];
	uint32_t sigdet[1];
	uint32_t _sigdet;
} BCMI_FUSIONCORE12G_XGXS_SIGDETr_t;

#define BCMI_FUSIONCORE12G_XGXS_SIGDETr_CLR(r) (r).sigdet[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_SIGDETr_SET(r,d) (r).sigdet[0] = d
#define BCMI_FUSIONCORE12G_XGXS_SIGDETr_GET(r) (r).sigdet[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_SIGDETr_SIGDETf_GET(r) (((r).sigdet[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_SIGDETr_SIGDETf_SET(r,f) (r).sigdet[0]=(((r).sigdet[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access SIGDET.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_SIGDETr(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_SIGDETr,(_r._sigdet))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_SIGDETr(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_SIGDETr,(_r._sigdet))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SIGDETr BCMI_FUSIONCORE12G_XGXS_SIGDETr
#define SIGDETr_SIZE BCMI_FUSIONCORE12G_XGXS_SIGDETr_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_SIGDETr_t SIGDETr_t;
#define SIGDETr_CLR BCMI_FUSIONCORE12G_XGXS_SIGDETr_CLR
#define SIGDETr_SET BCMI_FUSIONCORE12G_XGXS_SIGDETr_SET
#define SIGDETr_GET BCMI_FUSIONCORE12G_XGXS_SIGDETr_GET
#define SIGDETr_SIGDETf_GET BCMI_FUSIONCORE12G_XGXS_SIGDETr_SIGDETf_GET
#define SIGDETr_SIGDETf_SET BCMI_FUSIONCORE12G_XGXS_SIGDETr_SIGDETf_SET
#define READ_SIGDETr BCMI_FUSIONCORE12G_XGXS_READ_SIGDETr
#define WRITE_SIGDETr BCMI_FUSIONCORE12G_XGXS_WRITE_SIGDETr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_SIGDETr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  PARDET10G_LINK
 * BLOCKS:   PARDET10G
 * REGADDR:  0x8343
 * DESC:     parDet10GLink (Addr 0x8343)
 * SIZE:     32
 * FIELDS:
 *     PARDET10G_LINK   PARDET10G_LINK
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_PARDET10G_LINKr (0x00034013 | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_PARDET10G_LINKr_SIZE 4

/*
 * This structure should be used to declare and program PARDET10G_LINK.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_PARDET10G_LINKr_s {
	uint32_t v[1];
	uint32_t pardet10g_link[1];
	uint32_t _pardet10g_link;
} BCMI_FUSIONCORE12G_XGXS_PARDET10G_LINKr_t;

#define BCMI_FUSIONCORE12G_XGXS_PARDET10G_LINKr_CLR(r) (r).pardet10g_link[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_PARDET10G_LINKr_SET(r,d) (r).pardet10g_link[0] = d
#define BCMI_FUSIONCORE12G_XGXS_PARDET10G_LINKr_GET(r) (r).pardet10g_link[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_PARDET10G_LINKr_PARDET10G_LINKf_GET(r) (((r).pardet10g_link[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_PARDET10G_LINKr_PARDET10G_LINKf_SET(r,f) (r).pardet10g_link[0]=(((r).pardet10g_link[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PARDET10G_LINK.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_PARDET10G_LINKr(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_PARDET10G_LINKr,(_r._pardet10g_link))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_PARDET10G_LINKr(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_PARDET10G_LINKr,(_r._pardet10g_link))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PARDET10G_LINKr BCMI_FUSIONCORE12G_XGXS_PARDET10G_LINKr
#define PARDET10G_LINKr_SIZE BCMI_FUSIONCORE12G_XGXS_PARDET10G_LINKr_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_PARDET10G_LINKr_t PARDET10G_LINKr_t;
#define PARDET10G_LINKr_CLR BCMI_FUSIONCORE12G_XGXS_PARDET10G_LINKr_CLR
#define PARDET10G_LINKr_SET BCMI_FUSIONCORE12G_XGXS_PARDET10G_LINKr_SET
#define PARDET10G_LINKr_GET BCMI_FUSIONCORE12G_XGXS_PARDET10G_LINKr_GET
#define PARDET10G_LINKr_PARDET10G_LINKf_GET BCMI_FUSIONCORE12G_XGXS_PARDET10G_LINKr_PARDET10G_LINKf_GET
#define PARDET10G_LINKr_PARDET10G_LINKf_SET BCMI_FUSIONCORE12G_XGXS_PARDET10G_LINKr_PARDET10G_LINKf_SET
#define READ_PARDET10G_LINKr BCMI_FUSIONCORE12G_XGXS_READ_PARDET10G_LINKr
#define WRITE_PARDET10G_LINKr BCMI_FUSIONCORE12G_XGXS_WRITE_PARDET10G_LINKr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_PARDET10G_LINKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_FUSIONCORE12G_XGXS
 * REGISTER:  LOSLINK
 * BLOCKS:   PARDET10G
 * REGADDR:  0x8344
 * DESC:     parDet10GLosLink (Addr 0x8344)
 * SIZE:     32
 * FIELDS:
 *     LOSLINK          LOSLINK
 *
 ******************************************************************************/
#define BCMI_FUSIONCORE12G_XGXS_LOSLINKr (0x00034014 | PHY_REG_ACC_XGS_IBLK)

#define BCMI_FUSIONCORE12G_XGXS_LOSLINKr_SIZE 4

/*
 * This structure should be used to declare and program LOSLINK.
 *
 */
typedef union BCMI_FUSIONCORE12G_XGXS_LOSLINKr_s {
	uint32_t v[1];
	uint32_t loslink[1];
	uint32_t _loslink;
} BCMI_FUSIONCORE12G_XGXS_LOSLINKr_t;

#define BCMI_FUSIONCORE12G_XGXS_LOSLINKr_CLR(r) (r).loslink[0] = 0
#define BCMI_FUSIONCORE12G_XGXS_LOSLINKr_SET(r,d) (r).loslink[0] = d
#define BCMI_FUSIONCORE12G_XGXS_LOSLINKr_GET(r) (r).loslink[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_LOSLINKr_LOSLINKf_GET(r) (((r).loslink[0]) & 0xffff)
#define BCMI_FUSIONCORE12G_XGXS_LOSLINKr_LOSLINKf_SET(r,f) (r).loslink[0]=(((r).loslink[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access LOSLINK.
 *
 */
#define BCMI_FUSIONCORE12G_XGXS_READ_LOSLINKr(_pc,_r) phy_xgs_iblk_read(_pc,BCMI_FUSIONCORE12G_XGXS_LOSLINKr,(_r._loslink))
#define BCMI_FUSIONCORE12G_XGXS_WRITE_LOSLINKr(_pc,_r) phy_xgs_iblk_write(_pc,BCMI_FUSIONCORE12G_XGXS_LOSLINKr,(_r._loslink))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define LOSLINKr BCMI_FUSIONCORE12G_XGXS_LOSLINKr
#define LOSLINKr_SIZE BCMI_FUSIONCORE12G_XGXS_LOSLINKr_SIZE
typedef BCMI_FUSIONCORE12G_XGXS_LOSLINKr_t LOSLINKr_t;
#define LOSLINKr_CLR BCMI_FUSIONCORE12G_XGXS_LOSLINKr_CLR
#define LOSLINKr_SET BCMI_FUSIONCORE12G_XGXS_LOSLINKr_SET
#define LOSLINKr_GET BCMI_FUSIONCORE12G_XGXS_LOSLINKr_GET
#define LOSLINKr_LOSLINKf_GET BCMI_FUSIONCORE12G_XGXS_LOSLINKr_LOSLINKf_GET
#define LOSLINKr_LOSLINKf_SET BCMI_FUSIONCORE12G_XGXS_LOSLINKr_LOSLINKf_SET
#define READ_LOSLINKr BCMI_FUSIONCORE12G_XGXS_READ_LOSLINKr
#define WRITE_LOSLINKr BCMI_FUSIONCORE12G_XGXS_WRITE_LOSLINKr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FUSIONCORE12G_XGXS_LOSLINKr'
 ******************************************************************************/




#endif /* __BCMI_FUSIONCORE12G_XGXS_DEFS_H__ */
