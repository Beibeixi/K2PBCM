#ifndef __BCMI_TSC_XGXS_DEFS_H__
#define __BCMI_TSC_XGXS_DEFS_H__
/*******************************************************************************
 *
 * $Copyright: Copyright 2013 Broadcom Corporation.
 * This program is the proprietary software of Broadcom Corporation
 * and/or its licensors, and may only be used, duplicated, modified
 * or distributed pursuant to the terms and conditions of a separate,
 * written license agreement executed between you and Broadcom
 * (an "Authorized License").  Except as set forth in an Authorized
 * License, Broadcom grants no license (express or implied), right
 * to use, or waiver of any kind with respect to the Software, and
 * Broadcom expressly reserves all rights in and to the Software
 * and all intellectual property rights therein.  IF YOU HAVE
 * NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
 * IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
 * ALL USE OF THE SOFTWARE.  
 *  
 * Except as expressly set forth in the Authorized License,
 *  
 * 1.     This program, including its structure, sequence and organization,
 * constitutes the valuable trade secrets of Broadcom, and you shall use
 * all reasonable efforts to protect the confidentiality thereof,
 * and to use this information only in connection with your use of
 * Broadcom integrated circuit products.
 *  
 * 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
 * PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
 * REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
 * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
 * DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
 * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
 * ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
 * CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
 * OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
 * 
 * 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
 * BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
 * INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
 * ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
 * TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
 * THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR USD 1.00,
 * WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
 * ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated from the registers file.
 * Edits to this file will be lost when it is regenerated.
 *
 * Definition file for the BCMI_TSC_XGXS.
 * This file provides all basic definitions required to program the BCMI_TSC_XGXS.
 *
 * This file is autogenerated. Please do not edit.
 *
 ******************************************************************************/

#include <phy/phy_tsc_iblk.h>

/*******************************************************************************
 *
 *                    CHIP DEFINITIONS BEGIN HERE
 *
 ******************************************************************************/



/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CL22_PHYID2
 * BLOCKS:   CL22_B0
 * REGADDR:  0x0002
 * DESC:     IEEE phyID2 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     REGID1           
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CL22_PHYID2r (0x00000002 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CL22_PHYID2r_SIZE 4

/*
 * This structure should be used to declare and program CL22_PHYID2.
 *
 */
typedef union BCMI_TSC_XGXS_CL22_PHYID2r_s {
	uint32_t v[1];
	uint32_t cl22_phyid2[1];
	uint32_t _cl22_phyid2;
} BCMI_TSC_XGXS_CL22_PHYID2r_t;

#define BCMI_TSC_XGXS_CL22_PHYID2r_CLR(r) (r).cl22_phyid2[0] = 0
#define BCMI_TSC_XGXS_CL22_PHYID2r_SET(r,d) (r).cl22_phyid2[0] = d
#define BCMI_TSC_XGXS_CL22_PHYID2r_GET(r) (r).cl22_phyid2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CL22_PHYID2r_REGID1f_GET(r) (((r).cl22_phyid2[0]) & 0xffff)
#define BCMI_TSC_XGXS_CL22_PHYID2r_REGID1f_SET(r,f) (r).cl22_phyid2[0]=(((r).cl22_phyid2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access CL22_PHYID2.
 *
 */
#define BCMI_TSC_XGXS_READ_CL22_PHYID2r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CL22_PHYID2r,(_r._cl22_phyid2))
#define BCMI_TSC_XGXS_WRITE_CL22_PHYID2r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CL22_PHYID2r,(_r._cl22_phyid2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL22_PHYID2r BCMI_TSC_XGXS_CL22_PHYID2r
#define CL22_PHYID2r_SIZE BCMI_TSC_XGXS_CL22_PHYID2r_SIZE
typedef BCMI_TSC_XGXS_CL22_PHYID2r_t CL22_PHYID2r_t;
#define CL22_PHYID2r_CLR BCMI_TSC_XGXS_CL22_PHYID2r_CLR
#define CL22_PHYID2r_SET BCMI_TSC_XGXS_CL22_PHYID2r_SET
#define CL22_PHYID2r_GET BCMI_TSC_XGXS_CL22_PHYID2r_GET
#define CL22_PHYID2r_REGID1f_GET BCMI_TSC_XGXS_CL22_PHYID2r_REGID1f_GET
#define CL22_PHYID2r_REGID1f_SET BCMI_TSC_XGXS_CL22_PHYID2r_REGID1f_SET
#define READ_CL22_PHYID2r BCMI_TSC_XGXS_READ_CL22_PHYID2r
#define WRITE_CL22_PHYID2r BCMI_TSC_XGXS_WRITE_CL22_PHYID2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CL22_PHYID2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CL22_PHYID3
 * BLOCKS:   CL22_B0
 * REGADDR:  0x0003
 * DESC:     IEEE phyID3 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     REGID2           
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CL22_PHYID3r (0x00000003 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CL22_PHYID3r_SIZE 4

/*
 * This structure should be used to declare and program CL22_PHYID3.
 *
 */
typedef union BCMI_TSC_XGXS_CL22_PHYID3r_s {
	uint32_t v[1];
	uint32_t cl22_phyid3[1];
	uint32_t _cl22_phyid3;
} BCMI_TSC_XGXS_CL22_PHYID3r_t;

#define BCMI_TSC_XGXS_CL22_PHYID3r_CLR(r) (r).cl22_phyid3[0] = 0
#define BCMI_TSC_XGXS_CL22_PHYID3r_SET(r,d) (r).cl22_phyid3[0] = d
#define BCMI_TSC_XGXS_CL22_PHYID3r_GET(r) (r).cl22_phyid3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CL22_PHYID3r_REGID2f_GET(r) (((r).cl22_phyid3[0]) & 0xffff)
#define BCMI_TSC_XGXS_CL22_PHYID3r_REGID2f_SET(r,f) (r).cl22_phyid3[0]=(((r).cl22_phyid3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access CL22_PHYID3.
 *
 */
#define BCMI_TSC_XGXS_READ_CL22_PHYID3r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CL22_PHYID3r,(_r._cl22_phyid3))
#define BCMI_TSC_XGXS_WRITE_CL22_PHYID3r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CL22_PHYID3r,(_r._cl22_phyid3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL22_PHYID3r BCMI_TSC_XGXS_CL22_PHYID3r
#define CL22_PHYID3r_SIZE BCMI_TSC_XGXS_CL22_PHYID3r_SIZE
typedef BCMI_TSC_XGXS_CL22_PHYID3r_t CL22_PHYID3r_t;
#define CL22_PHYID3r_CLR BCMI_TSC_XGXS_CL22_PHYID3r_CLR
#define CL22_PHYID3r_SET BCMI_TSC_XGXS_CL22_PHYID3r_SET
#define CL22_PHYID3r_GET BCMI_TSC_XGXS_CL22_PHYID3r_GET
#define CL22_PHYID3r_REGID2f_GET BCMI_TSC_XGXS_CL22_PHYID3r_REGID2f_GET
#define CL22_PHYID3r_REGID2f_SET BCMI_TSC_XGXS_CL22_PHYID3r_REGID2f_SET
#define READ_CL22_PHYID3r BCMI_TSC_XGXS_READ_CL22_PHYID3r
#define WRITE_CL22_PHYID3r BCMI_TSC_XGXS_WRITE_CL22_PHYID3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CL22_PHYID3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CL22_MMDACCESSCONTROL
 * BLOCKS:   CL22_B0
 * REGADDR:  0x000d
 * DESC:     IEEE MMD Access Control Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     DEVAD            
 *     RESERVED0        
 *     INCREMENT_CONTROL 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CL22_MMDACCESSCONTROLr (0x0000000d | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CL22_MMDACCESSCONTROLr_SIZE 4

/*
 * This structure should be used to declare and program CL22_MMDACCESSCONTROL.
 *
 */
typedef union BCMI_TSC_XGXS_CL22_MMDACCESSCONTROLr_s {
	uint32_t v[1];
	uint32_t cl22_mmdaccesscontrol[1];
	uint32_t _cl22_mmdaccesscontrol;
} BCMI_TSC_XGXS_CL22_MMDACCESSCONTROLr_t;

#define BCMI_TSC_XGXS_CL22_MMDACCESSCONTROLr_CLR(r) (r).cl22_mmdaccesscontrol[0] = 0
#define BCMI_TSC_XGXS_CL22_MMDACCESSCONTROLr_SET(r,d) (r).cl22_mmdaccesscontrol[0] = d
#define BCMI_TSC_XGXS_CL22_MMDACCESSCONTROLr_GET(r) (r).cl22_mmdaccesscontrol[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CL22_MMDACCESSCONTROLr_INCREMENT_CONTROLf_GET(r) ((((r).cl22_mmdaccesscontrol[0]) >> 14) & 0x3)
#define BCMI_TSC_XGXS_CL22_MMDACCESSCONTROLr_INCREMENT_CONTROLf_SET(r,f) (r).cl22_mmdaccesscontrol[0]=(((r).cl22_mmdaccesscontrol[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCMI_TSC_XGXS_CL22_MMDACCESSCONTROLr_RESERVED0f_GET(r) ((((r).cl22_mmdaccesscontrol[0]) >> 5) & 0x1ff)
#define BCMI_TSC_XGXS_CL22_MMDACCESSCONTROLr_RESERVED0f_SET(r,f) (r).cl22_mmdaccesscontrol[0]=(((r).cl22_mmdaccesscontrol[0] & ~((uint32_t)0x1ff << 5)) | ((((uint32_t)f) & 0x1ff) << 5))
#define BCMI_TSC_XGXS_CL22_MMDACCESSCONTROLr_DEVADf_GET(r) (((r).cl22_mmdaccesscontrol[0]) & 0x1f)
#define BCMI_TSC_XGXS_CL22_MMDACCESSCONTROLr_DEVADf_SET(r,f) (r).cl22_mmdaccesscontrol[0]=(((r).cl22_mmdaccesscontrol[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))

/*
 * These macros can be used to access CL22_MMDACCESSCONTROL.
 *
 */
#define BCMI_TSC_XGXS_READ_CL22_MMDACCESSCONTROLr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CL22_MMDACCESSCONTROLr,(_r._cl22_mmdaccesscontrol))
#define BCMI_TSC_XGXS_WRITE_CL22_MMDACCESSCONTROLr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CL22_MMDACCESSCONTROLr,(_r._cl22_mmdaccesscontrol))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL22_MMDACCESSCONTROLr BCMI_TSC_XGXS_CL22_MMDACCESSCONTROLr
#define CL22_MMDACCESSCONTROLr_SIZE BCMI_TSC_XGXS_CL22_MMDACCESSCONTROLr_SIZE
typedef BCMI_TSC_XGXS_CL22_MMDACCESSCONTROLr_t CL22_MMDACCESSCONTROLr_t;
#define CL22_MMDACCESSCONTROLr_CLR BCMI_TSC_XGXS_CL22_MMDACCESSCONTROLr_CLR
#define CL22_MMDACCESSCONTROLr_SET BCMI_TSC_XGXS_CL22_MMDACCESSCONTROLr_SET
#define CL22_MMDACCESSCONTROLr_GET BCMI_TSC_XGXS_CL22_MMDACCESSCONTROLr_GET
#define CL22_MMDACCESSCONTROLr_INCREMENT_CONTROLf_GET BCMI_TSC_XGXS_CL22_MMDACCESSCONTROLr_INCREMENT_CONTROLf_GET
#define CL22_MMDACCESSCONTROLr_INCREMENT_CONTROLf_SET BCMI_TSC_XGXS_CL22_MMDACCESSCONTROLr_INCREMENT_CONTROLf_SET
#define CL22_MMDACCESSCONTROLr_RESERVED0f_GET BCMI_TSC_XGXS_CL22_MMDACCESSCONTROLr_RESERVED0f_GET
#define CL22_MMDACCESSCONTROLr_RESERVED0f_SET BCMI_TSC_XGXS_CL22_MMDACCESSCONTROLr_RESERVED0f_SET
#define CL22_MMDACCESSCONTROLr_DEVADf_GET BCMI_TSC_XGXS_CL22_MMDACCESSCONTROLr_DEVADf_GET
#define CL22_MMDACCESSCONTROLr_DEVADf_SET BCMI_TSC_XGXS_CL22_MMDACCESSCONTROLr_DEVADf_SET
#define READ_CL22_MMDACCESSCONTROLr BCMI_TSC_XGXS_READ_CL22_MMDACCESSCONTROLr
#define WRITE_CL22_MMDACCESSCONTROLr BCMI_TSC_XGXS_WRITE_CL22_MMDACCESSCONTROLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CL22_MMDACCESSCONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CL22_MMDACCESSADDRESSDATA
 * BLOCKS:   CL22_B0
 * REGADDR:  0x000e
 * DESC:     IEEE MMD Address Data Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     ADDRESSDATA      
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CL22_MMDACCESSADDRESSDATAr (0x0000000e | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CL22_MMDACCESSADDRESSDATAr_SIZE 4

/*
 * This structure should be used to declare and program CL22_MMDACCESSADDRESSDATA.
 *
 */
typedef union BCMI_TSC_XGXS_CL22_MMDACCESSADDRESSDATAr_s {
	uint32_t v[1];
	uint32_t cl22_mmdaccessaddressdata[1];
	uint32_t _cl22_mmdaccessaddressdata;
} BCMI_TSC_XGXS_CL22_MMDACCESSADDRESSDATAr_t;

#define BCMI_TSC_XGXS_CL22_MMDACCESSADDRESSDATAr_CLR(r) (r).cl22_mmdaccessaddressdata[0] = 0
#define BCMI_TSC_XGXS_CL22_MMDACCESSADDRESSDATAr_SET(r,d) (r).cl22_mmdaccessaddressdata[0] = d
#define BCMI_TSC_XGXS_CL22_MMDACCESSADDRESSDATAr_GET(r) (r).cl22_mmdaccessaddressdata[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CL22_MMDACCESSADDRESSDATAr_ADDRESSDATAf_GET(r) (((r).cl22_mmdaccessaddressdata[0]) & 0xffff)
#define BCMI_TSC_XGXS_CL22_MMDACCESSADDRESSDATAr_ADDRESSDATAf_SET(r,f) (r).cl22_mmdaccessaddressdata[0]=(((r).cl22_mmdaccessaddressdata[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access CL22_MMDACCESSADDRESSDATA.
 *
 */
#define BCMI_TSC_XGXS_READ_CL22_MMDACCESSADDRESSDATAr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CL22_MMDACCESSADDRESSDATAr,(_r._cl22_mmdaccessaddressdata))
#define BCMI_TSC_XGXS_WRITE_CL22_MMDACCESSADDRESSDATAr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CL22_MMDACCESSADDRESSDATAr,(_r._cl22_mmdaccessaddressdata))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL22_MMDACCESSADDRESSDATAr BCMI_TSC_XGXS_CL22_MMDACCESSADDRESSDATAr
#define CL22_MMDACCESSADDRESSDATAr_SIZE BCMI_TSC_XGXS_CL22_MMDACCESSADDRESSDATAr_SIZE
typedef BCMI_TSC_XGXS_CL22_MMDACCESSADDRESSDATAr_t CL22_MMDACCESSADDRESSDATAr_t;
#define CL22_MMDACCESSADDRESSDATAr_CLR BCMI_TSC_XGXS_CL22_MMDACCESSADDRESSDATAr_CLR
#define CL22_MMDACCESSADDRESSDATAr_SET BCMI_TSC_XGXS_CL22_MMDACCESSADDRESSDATAr_SET
#define CL22_MMDACCESSADDRESSDATAr_GET BCMI_TSC_XGXS_CL22_MMDACCESSADDRESSDATAr_GET
#define CL22_MMDACCESSADDRESSDATAr_ADDRESSDATAf_GET BCMI_TSC_XGXS_CL22_MMDACCESSADDRESSDATAr_ADDRESSDATAf_GET
#define CL22_MMDACCESSADDRESSDATAr_ADDRESSDATAf_SET BCMI_TSC_XGXS_CL22_MMDACCESSADDRESSDATAr_ADDRESSDATAf_SET
#define READ_CL22_MMDACCESSADDRESSDATAr BCMI_TSC_XGXS_READ_CL22_MMDACCESSADDRESSDATAr
#define WRITE_CL22_MMDACCESSADDRESSDATAr BCMI_TSC_XGXS_WRITE_CL22_MMDACCESSADDRESSDATAr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CL22_MMDACCESSADDRESSDATAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CL22_BLKADR
 * BLOCKS:   CL22_B1
 * REGADDR:  0x001f
 * DESC:     Block Address Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     BLKADR           
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CL22_BLKADRr (0x0000001f | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CL22_BLKADRr_SIZE 4

/*
 * This structure should be used to declare and program CL22_BLKADR.
 *
 */
typedef union BCMI_TSC_XGXS_CL22_BLKADRr_s {
	uint32_t v[1];
	uint32_t cl22_blkadr[1];
	uint32_t _cl22_blkadr;
} BCMI_TSC_XGXS_CL22_BLKADRr_t;

#define BCMI_TSC_XGXS_CL22_BLKADRr_CLR(r) (r).cl22_blkadr[0] = 0
#define BCMI_TSC_XGXS_CL22_BLKADRr_SET(r,d) (r).cl22_blkadr[0] = d
#define BCMI_TSC_XGXS_CL22_BLKADRr_GET(r) (r).cl22_blkadr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CL22_BLKADRr_BLKADRf_GET(r) (((r).cl22_blkadr[0]) & 0xffff)
#define BCMI_TSC_XGXS_CL22_BLKADRr_BLKADRf_SET(r,f) (r).cl22_blkadr[0]=(((r).cl22_blkadr[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access CL22_BLKADR.
 *
 */
#define BCMI_TSC_XGXS_READ_CL22_BLKADRr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CL22_BLKADRr,(_r._cl22_blkadr))
#define BCMI_TSC_XGXS_WRITE_CL22_BLKADRr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CL22_BLKADRr,(_r._cl22_blkadr))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL22_BLKADRr BCMI_TSC_XGXS_CL22_BLKADRr
#define CL22_BLKADRr_SIZE BCMI_TSC_XGXS_CL22_BLKADRr_SIZE
typedef BCMI_TSC_XGXS_CL22_BLKADRr_t CL22_BLKADRr_t;
#define CL22_BLKADRr_CLR BCMI_TSC_XGXS_CL22_BLKADRr_CLR
#define CL22_BLKADRr_SET BCMI_TSC_XGXS_CL22_BLKADRr_SET
#define CL22_BLKADRr_GET BCMI_TSC_XGXS_CL22_BLKADRr_GET
#define CL22_BLKADRr_BLKADRf_GET BCMI_TSC_XGXS_CL22_BLKADRr_BLKADRf_GET
#define CL22_BLKADRr_BLKADRf_SET BCMI_TSC_XGXS_CL22_BLKADRr_BLKADRf_SET
#define READ_CL22_BLKADRr BCMI_TSC_XGXS_READ_CL22_BLKADRr
#define WRITE_CL22_BLKADRr BCMI_TSC_XGXS_WRITE_CL22_BLKADRr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CL22_BLKADRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  SETUP
 * BLOCKS:   MAIN0
 * REGADDR:  0x9000
 * DESC:     main control register: 00000000
 * SIZE:     32
 * FIELDS:
 *     RESERVED0        
 *     STAND_ALONE_MODE 
 *     SINGLE_PORT_MODE 
 *     PORT_MODE_SEL    
 *     START_SEQUENCER  
 *     DEFAULT_PLL_MODE_AFE 
 *     FORCE_PLL_MODE_AFE_SEL 
 *     REFCLK_SEL       
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_SETUPr (0x00109000 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_SETUPr_SIZE 4

/*
 * This structure should be used to declare and program SETUP.
 *
 */
typedef union BCMI_TSC_XGXS_SETUPr_s {
	uint32_t v[1];
	uint32_t setup[1];
	uint32_t _setup;
} BCMI_TSC_XGXS_SETUPr_t;

#define BCMI_TSC_XGXS_SETUPr_CLR(r) (r).setup[0] = 0
#define BCMI_TSC_XGXS_SETUPr_SET(r,d) (r).setup[0] = d
#define BCMI_TSC_XGXS_SETUPr_GET(r) (r).setup[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_SETUPr_REFCLK_SELf_GET(r) ((((r).setup[0]) >> 13) & 0x7)
#define BCMI_TSC_XGXS_SETUPr_REFCLK_SELf_SET(r,f) (r).setup[0]=(((r).setup[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))
#define BCMI_TSC_XGXS_SETUPr_FORCE_PLL_MODE_AFE_SELf_GET(r) ((((r).setup[0]) >> 12) & 0x1)
#define BCMI_TSC_XGXS_SETUPr_FORCE_PLL_MODE_AFE_SELf_SET(r,f) (r).setup[0]=(((r).setup[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCMI_TSC_XGXS_SETUPr_DEFAULT_PLL_MODE_AFEf_GET(r) ((((r).setup[0]) >> 8) & 0xf)
#define BCMI_TSC_XGXS_SETUPr_DEFAULT_PLL_MODE_AFEf_SET(r,f) (r).setup[0]=(((r).setup[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCMI_TSC_XGXS_SETUPr_START_SEQUENCERf_GET(r) ((((r).setup[0]) >> 7) & 0x1)
#define BCMI_TSC_XGXS_SETUPr_START_SEQUENCERf_SET(r,f) (r).setup[0]=(((r).setup[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCMI_TSC_XGXS_SETUPr_PORT_MODE_SELf_GET(r) ((((r).setup[0]) >> 4) & 0x7)
#define BCMI_TSC_XGXS_SETUPr_PORT_MODE_SELf_SET(r,f) (r).setup[0]=(((r).setup[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4))
#define BCMI_TSC_XGXS_SETUPr_SINGLE_PORT_MODEf_GET(r) ((((r).setup[0]) >> 3) & 0x1)
#define BCMI_TSC_XGXS_SETUPr_SINGLE_PORT_MODEf_SET(r,f) (r).setup[0]=(((r).setup[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCMI_TSC_XGXS_SETUPr_STAND_ALONE_MODEf_GET(r) ((((r).setup[0]) >> 2) & 0x1)
#define BCMI_TSC_XGXS_SETUPr_STAND_ALONE_MODEf_SET(r,f) (r).setup[0]=(((r).setup[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCMI_TSC_XGXS_SETUPr_RESERVED0f_GET(r) (((r).setup[0]) & 0x3)
#define BCMI_TSC_XGXS_SETUPr_RESERVED0f_SET(r,f) (r).setup[0]=(((r).setup[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))

/*
 * These macros can be used to access SETUP.
 *
 */
#define BCMI_TSC_XGXS_READ_SETUPr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_SETUPr,(_r._setup))
#define BCMI_TSC_XGXS_WRITE_SETUPr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_SETUPr,(_r._setup))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SETUPr BCMI_TSC_XGXS_SETUPr
#define SETUPr_SIZE BCMI_TSC_XGXS_SETUPr_SIZE
typedef BCMI_TSC_XGXS_SETUPr_t SETUPr_t;
#define SETUPr_CLR BCMI_TSC_XGXS_SETUPr_CLR
#define SETUPr_SET BCMI_TSC_XGXS_SETUPr_SET
#define SETUPr_GET BCMI_TSC_XGXS_SETUPr_GET
#define SETUPr_REFCLK_SELf_GET BCMI_TSC_XGXS_SETUPr_REFCLK_SELf_GET
#define SETUPr_REFCLK_SELf_SET BCMI_TSC_XGXS_SETUPr_REFCLK_SELf_SET
#define SETUPr_FORCE_PLL_MODE_AFE_SELf_GET BCMI_TSC_XGXS_SETUPr_FORCE_PLL_MODE_AFE_SELf_GET
#define SETUPr_FORCE_PLL_MODE_AFE_SELf_SET BCMI_TSC_XGXS_SETUPr_FORCE_PLL_MODE_AFE_SELf_SET
#define SETUPr_DEFAULT_PLL_MODE_AFEf_GET BCMI_TSC_XGXS_SETUPr_DEFAULT_PLL_MODE_AFEf_GET
#define SETUPr_DEFAULT_PLL_MODE_AFEf_SET BCMI_TSC_XGXS_SETUPr_DEFAULT_PLL_MODE_AFEf_SET
#define SETUPr_START_SEQUENCERf_GET BCMI_TSC_XGXS_SETUPr_START_SEQUENCERf_GET
#define SETUPr_START_SEQUENCERf_SET BCMI_TSC_XGXS_SETUPr_START_SEQUENCERf_SET
#define SETUPr_PORT_MODE_SELf_GET BCMI_TSC_XGXS_SETUPr_PORT_MODE_SELf_GET
#define SETUPr_PORT_MODE_SELf_SET BCMI_TSC_XGXS_SETUPr_PORT_MODE_SELf_SET
#define SETUPr_SINGLE_PORT_MODEf_GET BCMI_TSC_XGXS_SETUPr_SINGLE_PORT_MODEf_GET
#define SETUPr_SINGLE_PORT_MODEf_SET BCMI_TSC_XGXS_SETUPr_SINGLE_PORT_MODEf_SET
#define SETUPr_STAND_ALONE_MODEf_GET BCMI_TSC_XGXS_SETUPr_STAND_ALONE_MODEf_GET
#define SETUPr_STAND_ALONE_MODEf_SET BCMI_TSC_XGXS_SETUPr_STAND_ALONE_MODEf_SET
#define SETUPr_RESERVED0f_GET BCMI_TSC_XGXS_SETUPr_RESERVED0f_GET
#define SETUPr_RESERVED0f_SET BCMI_TSC_XGXS_SETUPr_RESERVED0f_SET
#define READ_SETUPr BCMI_TSC_XGXS_READ_SETUPr
#define WRITE_SETUPr BCMI_TSC_XGXS_WRITE_SETUPr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_SETUPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RESET
 * BLOCKS:   MAIN0
 * REGADDR:  0x9001
 * DESC:     reset control register: 00000000
 * SIZE:     32
 * FIELDS:
 *     RESERVED0        
 *     RX_DSC_RESET     
 *     PLL_BYPASS       
 *     RESET_PLL        
 *     TX_RESET_ANALOG  
 *     RX_RESET_ANALOG  
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RESETr (0x00109001 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RESETr_SIZE 4

/*
 * This structure should be used to declare and program RESET.
 *
 */
typedef union BCMI_TSC_XGXS_RESETr_s {
	uint32_t v[1];
	uint32_t reset[1];
	uint32_t _reset;
} BCMI_TSC_XGXS_RESETr_t;

#define BCMI_TSC_XGXS_RESETr_CLR(r) (r).reset[0] = 0
#define BCMI_TSC_XGXS_RESETr_SET(r,d) (r).reset[0] = d
#define BCMI_TSC_XGXS_RESETr_GET(r) (r).reset[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RESETr_RX_RESET_ANALOGf_GET(r) ((((r).reset[0]) >> 12) & 0xf)
#define BCMI_TSC_XGXS_RESETr_RX_RESET_ANALOGf_SET(r,f) (r).reset[0]=(((r).reset[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCMI_TSC_XGXS_RESETr_TX_RESET_ANALOGf_GET(r) ((((r).reset[0]) >> 8) & 0xf)
#define BCMI_TSC_XGXS_RESETr_TX_RESET_ANALOGf_SET(r,f) (r).reset[0]=(((r).reset[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCMI_TSC_XGXS_RESETr_RESET_PLLf_GET(r) ((((r).reset[0]) >> 7) & 0x1)
#define BCMI_TSC_XGXS_RESETr_RESET_PLLf_SET(r,f) (r).reset[0]=(((r).reset[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCMI_TSC_XGXS_RESETr_PLL_BYPASSf_GET(r) ((((r).reset[0]) >> 6) & 0x1)
#define BCMI_TSC_XGXS_RESETr_PLL_BYPASSf_SET(r,f) (r).reset[0]=(((r).reset[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCMI_TSC_XGXS_RESETr_RX_DSC_RESETf_GET(r) ((((r).reset[0]) >> 2) & 0xf)
#define BCMI_TSC_XGXS_RESETr_RX_DSC_RESETf_SET(r,f) (r).reset[0]=(((r).reset[0] & ~((uint32_t)0xf << 2)) | ((((uint32_t)f) & 0xf) << 2))
#define BCMI_TSC_XGXS_RESETr_RESERVED0f_GET(r) (((r).reset[0]) & 0x3)
#define BCMI_TSC_XGXS_RESETr_RESERVED0f_SET(r,f) (r).reset[0]=(((r).reset[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))

/*
 * These macros can be used to access RESET.
 *
 */
#define BCMI_TSC_XGXS_READ_RESETr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RESETr,(_r._reset))
#define BCMI_TSC_XGXS_WRITE_RESETr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RESETr,(_r._reset))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RESETr BCMI_TSC_XGXS_RESETr
#define RESETr_SIZE BCMI_TSC_XGXS_RESETr_SIZE
typedef BCMI_TSC_XGXS_RESETr_t RESETr_t;
#define RESETr_CLR BCMI_TSC_XGXS_RESETr_CLR
#define RESETr_SET BCMI_TSC_XGXS_RESETr_SET
#define RESETr_GET BCMI_TSC_XGXS_RESETr_GET
#define RESETr_RX_RESET_ANALOGf_GET BCMI_TSC_XGXS_RESETr_RX_RESET_ANALOGf_GET
#define RESETr_RX_RESET_ANALOGf_SET BCMI_TSC_XGXS_RESETr_RX_RESET_ANALOGf_SET
#define RESETr_TX_RESET_ANALOGf_GET BCMI_TSC_XGXS_RESETr_TX_RESET_ANALOGf_GET
#define RESETr_TX_RESET_ANALOGf_SET BCMI_TSC_XGXS_RESETr_TX_RESET_ANALOGf_SET
#define RESETr_RESET_PLLf_GET BCMI_TSC_XGXS_RESETr_RESET_PLLf_GET
#define RESETr_RESET_PLLf_SET BCMI_TSC_XGXS_RESETr_RESET_PLLf_SET
#define RESETr_PLL_BYPASSf_GET BCMI_TSC_XGXS_RESETr_PLL_BYPASSf_GET
#define RESETr_PLL_BYPASSf_SET BCMI_TSC_XGXS_RESETr_PLL_BYPASSf_SET
#define RESETr_RX_DSC_RESETf_GET BCMI_TSC_XGXS_RESETr_RX_DSC_RESETf_GET
#define RESETr_RX_DSC_RESETf_SET BCMI_TSC_XGXS_RESETr_RX_DSC_RESETf_SET
#define RESETr_RESERVED0f_GET BCMI_TSC_XGXS_RESETr_RESERVED0f_GET
#define RESETr_RESERVED0f_SET BCMI_TSC_XGXS_RESETr_RESERVED0f_SET
#define READ_RESETr BCMI_TSC_XGXS_READ_RESETr
#define WRITE_RESETr BCMI_TSC_XGXS_WRITE_RESETr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RESETr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  POWER
 * BLOCKS:   MAIN0
 * REGADDR:  0x9002
 * DESC:     power control register: 00000000
 * SIZE:     32
 * FIELDS:
 *     RESERVED0        
 *     POWER_ON_TIMER_ENABLE 
 *     TX_LOWPWR_6G_OVERRIDE_ENABLE 
 *     TX_LOWPWR_6G_OVER_VAL 
 *     PWRDWN_PLL       
 *     TX_PWRDWN_ANALOG 
 *     RX_PWRDWN_ANALOG 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_POWERr (0x00109002 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_POWERr_SIZE 4

/*
 * This structure should be used to declare and program POWER.
 *
 */
typedef union BCMI_TSC_XGXS_POWERr_s {
	uint32_t v[1];
	uint32_t power[1];
	uint32_t _power;
} BCMI_TSC_XGXS_POWERr_t;

#define BCMI_TSC_XGXS_POWERr_CLR(r) (r).power[0] = 0
#define BCMI_TSC_XGXS_POWERr_SET(r,d) (r).power[0] = d
#define BCMI_TSC_XGXS_POWERr_GET(r) (r).power[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_POWERr_RX_PWRDWN_ANALOGf_GET(r) ((((r).power[0]) >> 12) & 0xf)
#define BCMI_TSC_XGXS_POWERr_RX_PWRDWN_ANALOGf_SET(r,f) (r).power[0]=(((r).power[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCMI_TSC_XGXS_POWERr_TX_PWRDWN_ANALOGf_GET(r) ((((r).power[0]) >> 8) & 0xf)
#define BCMI_TSC_XGXS_POWERr_TX_PWRDWN_ANALOGf_SET(r,f) (r).power[0]=(((r).power[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCMI_TSC_XGXS_POWERr_PWRDWN_PLLf_GET(r) ((((r).power[0]) >> 7) & 0x1)
#define BCMI_TSC_XGXS_POWERr_PWRDWN_PLLf_SET(r,f) (r).power[0]=(((r).power[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCMI_TSC_XGXS_POWERr_TX_LOWPWR_6G_OVER_VALf_GET(r) ((((r).power[0]) >> 6) & 0x1)
#define BCMI_TSC_XGXS_POWERr_TX_LOWPWR_6G_OVER_VALf_SET(r,f) (r).power[0]=(((r).power[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCMI_TSC_XGXS_POWERr_TX_LOWPWR_6G_OVERRIDE_ENABLEf_GET(r) ((((r).power[0]) >> 5) & 0x1)
#define BCMI_TSC_XGXS_POWERr_TX_LOWPWR_6G_OVERRIDE_ENABLEf_SET(r,f) (r).power[0]=(((r).power[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCMI_TSC_XGXS_POWERr_POWER_ON_TIMER_ENABLEf_GET(r) ((((r).power[0]) >> 4) & 0x1)
#define BCMI_TSC_XGXS_POWERr_POWER_ON_TIMER_ENABLEf_SET(r,f) (r).power[0]=(((r).power[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCMI_TSC_XGXS_POWERr_RESERVED0f_GET(r) (((r).power[0]) & 0xf)
#define BCMI_TSC_XGXS_POWERr_RESERVED0f_SET(r,f) (r).power[0]=(((r).power[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access POWER.
 *
 */
#define BCMI_TSC_XGXS_READ_POWERr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_POWERr,(_r._power))
#define BCMI_TSC_XGXS_WRITE_POWERr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_POWERr,(_r._power))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define POWERr BCMI_TSC_XGXS_POWERr
#define POWERr_SIZE BCMI_TSC_XGXS_POWERr_SIZE
typedef BCMI_TSC_XGXS_POWERr_t POWERr_t;
#define POWERr_CLR BCMI_TSC_XGXS_POWERr_CLR
#define POWERr_SET BCMI_TSC_XGXS_POWERr_SET
#define POWERr_GET BCMI_TSC_XGXS_POWERr_GET
#define POWERr_RX_PWRDWN_ANALOGf_GET BCMI_TSC_XGXS_POWERr_RX_PWRDWN_ANALOGf_GET
#define POWERr_RX_PWRDWN_ANALOGf_SET BCMI_TSC_XGXS_POWERr_RX_PWRDWN_ANALOGf_SET
#define POWERr_TX_PWRDWN_ANALOGf_GET BCMI_TSC_XGXS_POWERr_TX_PWRDWN_ANALOGf_GET
#define POWERr_TX_PWRDWN_ANALOGf_SET BCMI_TSC_XGXS_POWERr_TX_PWRDWN_ANALOGf_SET
#define POWERr_PWRDWN_PLLf_GET BCMI_TSC_XGXS_POWERr_PWRDWN_PLLf_GET
#define POWERr_PWRDWN_PLLf_SET BCMI_TSC_XGXS_POWERr_PWRDWN_PLLf_SET
#define POWERr_TX_LOWPWR_6G_OVER_VALf_GET BCMI_TSC_XGXS_POWERr_TX_LOWPWR_6G_OVER_VALf_GET
#define POWERr_TX_LOWPWR_6G_OVER_VALf_SET BCMI_TSC_XGXS_POWERr_TX_LOWPWR_6G_OVER_VALf_SET
#define POWERr_TX_LOWPWR_6G_OVERRIDE_ENABLEf_GET BCMI_TSC_XGXS_POWERr_TX_LOWPWR_6G_OVERRIDE_ENABLEf_GET
#define POWERr_TX_LOWPWR_6G_OVERRIDE_ENABLEf_SET BCMI_TSC_XGXS_POWERr_TX_LOWPWR_6G_OVERRIDE_ENABLEf_SET
#define POWERr_POWER_ON_TIMER_ENABLEf_GET BCMI_TSC_XGXS_POWERr_POWER_ON_TIMER_ENABLEf_GET
#define POWERr_POWER_ON_TIMER_ENABLEf_SET BCMI_TSC_XGXS_POWERr_POWER_ON_TIMER_ENABLEf_SET
#define POWERr_RESERVED0f_GET BCMI_TSC_XGXS_POWERr_RESERVED0f_GET
#define POWERr_RESERVED0f_SET BCMI_TSC_XGXS_POWERr_RESERVED0f_SET
#define READ_POWERr BCMI_TSC_XGXS_READ_POWERr
#define WRITE_POWERr BCMI_TSC_XGXS_WRITE_POWERr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_POWERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  LANE_SWAP
 * BLOCKS:   MAIN0
 * REGADDR:  0x9003
 * DESC:     Lane Swap Control Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     TX0_LNSWAP_SEL   
 *     TX1_LNSWAP_SEL   
 *     TX2_LNSWAP_SEL   
 *     TX3_LNSWAP_SEL   
 *     RX0_LNSWAP_SEL   
 *     RX1_LNSWAP_SEL   
 *     RX2_LNSWAP_SEL   
 *     RX3_LNSWAP_SEL   
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_LANE_SWAPr (0x00109003 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_LANE_SWAPr_SIZE 4

/*
 * This structure should be used to declare and program LANE_SWAP.
 *
 */
typedef union BCMI_TSC_XGXS_LANE_SWAPr_s {
	uint32_t v[1];
	uint32_t lane_swap[1];
	uint32_t _lane_swap;
} BCMI_TSC_XGXS_LANE_SWAPr_t;

#define BCMI_TSC_XGXS_LANE_SWAPr_CLR(r) (r).lane_swap[0] = 0
#define BCMI_TSC_XGXS_LANE_SWAPr_SET(r,d) (r).lane_swap[0] = d
#define BCMI_TSC_XGXS_LANE_SWAPr_GET(r) (r).lane_swap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_LANE_SWAPr_RX3_LNSWAP_SELf_GET(r) ((((r).lane_swap[0]) >> 14) & 0x3)
#define BCMI_TSC_XGXS_LANE_SWAPr_RX3_LNSWAP_SELf_SET(r,f) (r).lane_swap[0]=(((r).lane_swap[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCMI_TSC_XGXS_LANE_SWAPr_RX2_LNSWAP_SELf_GET(r) ((((r).lane_swap[0]) >> 12) & 0x3)
#define BCMI_TSC_XGXS_LANE_SWAPr_RX2_LNSWAP_SELf_SET(r,f) (r).lane_swap[0]=(((r).lane_swap[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCMI_TSC_XGXS_LANE_SWAPr_RX1_LNSWAP_SELf_GET(r) ((((r).lane_swap[0]) >> 10) & 0x3)
#define BCMI_TSC_XGXS_LANE_SWAPr_RX1_LNSWAP_SELf_SET(r,f) (r).lane_swap[0]=(((r).lane_swap[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCMI_TSC_XGXS_LANE_SWAPr_RX0_LNSWAP_SELf_GET(r) ((((r).lane_swap[0]) >> 8) & 0x3)
#define BCMI_TSC_XGXS_LANE_SWAPr_RX0_LNSWAP_SELf_SET(r,f) (r).lane_swap[0]=(((r).lane_swap[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCMI_TSC_XGXS_LANE_SWAPr_TX3_LNSWAP_SELf_GET(r) ((((r).lane_swap[0]) >> 6) & 0x3)
#define BCMI_TSC_XGXS_LANE_SWAPr_TX3_LNSWAP_SELf_SET(r,f) (r).lane_swap[0]=(((r).lane_swap[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCMI_TSC_XGXS_LANE_SWAPr_TX2_LNSWAP_SELf_GET(r) ((((r).lane_swap[0]) >> 4) & 0x3)
#define BCMI_TSC_XGXS_LANE_SWAPr_TX2_LNSWAP_SELf_SET(r,f) (r).lane_swap[0]=(((r).lane_swap[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCMI_TSC_XGXS_LANE_SWAPr_TX1_LNSWAP_SELf_GET(r) ((((r).lane_swap[0]) >> 2) & 0x3)
#define BCMI_TSC_XGXS_LANE_SWAPr_TX1_LNSWAP_SELf_SET(r,f) (r).lane_swap[0]=(((r).lane_swap[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCMI_TSC_XGXS_LANE_SWAPr_TX0_LNSWAP_SELf_GET(r) (((r).lane_swap[0]) & 0x3)
#define BCMI_TSC_XGXS_LANE_SWAPr_TX0_LNSWAP_SELf_SET(r,f) (r).lane_swap[0]=(((r).lane_swap[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))

/*
 * These macros can be used to access LANE_SWAP.
 *
 */
#define BCMI_TSC_XGXS_READ_LANE_SWAPr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_LANE_SWAPr,(_r._lane_swap))
#define BCMI_TSC_XGXS_WRITE_LANE_SWAPr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_LANE_SWAPr,(_r._lane_swap))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define LANE_SWAPr BCMI_TSC_XGXS_LANE_SWAPr
#define LANE_SWAPr_SIZE BCMI_TSC_XGXS_LANE_SWAPr_SIZE
typedef BCMI_TSC_XGXS_LANE_SWAPr_t LANE_SWAPr_t;
#define LANE_SWAPr_CLR BCMI_TSC_XGXS_LANE_SWAPr_CLR
#define LANE_SWAPr_SET BCMI_TSC_XGXS_LANE_SWAPr_SET
#define LANE_SWAPr_GET BCMI_TSC_XGXS_LANE_SWAPr_GET
#define LANE_SWAPr_RX3_LNSWAP_SELf_GET BCMI_TSC_XGXS_LANE_SWAPr_RX3_LNSWAP_SELf_GET
#define LANE_SWAPr_RX3_LNSWAP_SELf_SET BCMI_TSC_XGXS_LANE_SWAPr_RX3_LNSWAP_SELf_SET
#define LANE_SWAPr_RX2_LNSWAP_SELf_GET BCMI_TSC_XGXS_LANE_SWAPr_RX2_LNSWAP_SELf_GET
#define LANE_SWAPr_RX2_LNSWAP_SELf_SET BCMI_TSC_XGXS_LANE_SWAPr_RX2_LNSWAP_SELf_SET
#define LANE_SWAPr_RX1_LNSWAP_SELf_GET BCMI_TSC_XGXS_LANE_SWAPr_RX1_LNSWAP_SELf_GET
#define LANE_SWAPr_RX1_LNSWAP_SELf_SET BCMI_TSC_XGXS_LANE_SWAPr_RX1_LNSWAP_SELf_SET
#define LANE_SWAPr_RX0_LNSWAP_SELf_GET BCMI_TSC_XGXS_LANE_SWAPr_RX0_LNSWAP_SELf_GET
#define LANE_SWAPr_RX0_LNSWAP_SELf_SET BCMI_TSC_XGXS_LANE_SWAPr_RX0_LNSWAP_SELf_SET
#define LANE_SWAPr_TX3_LNSWAP_SELf_GET BCMI_TSC_XGXS_LANE_SWAPr_TX3_LNSWAP_SELf_GET
#define LANE_SWAPr_TX3_LNSWAP_SELf_SET BCMI_TSC_XGXS_LANE_SWAPr_TX3_LNSWAP_SELf_SET
#define LANE_SWAPr_TX2_LNSWAP_SELf_GET BCMI_TSC_XGXS_LANE_SWAPr_TX2_LNSWAP_SELf_GET
#define LANE_SWAPr_TX2_LNSWAP_SELf_SET BCMI_TSC_XGXS_LANE_SWAPr_TX2_LNSWAP_SELf_SET
#define LANE_SWAPr_TX1_LNSWAP_SELf_GET BCMI_TSC_XGXS_LANE_SWAPr_TX1_LNSWAP_SELf_GET
#define LANE_SWAPr_TX1_LNSWAP_SELf_SET BCMI_TSC_XGXS_LANE_SWAPr_TX1_LNSWAP_SELf_SET
#define LANE_SWAPr_TX0_LNSWAP_SELf_GET BCMI_TSC_XGXS_LANE_SWAPr_TX0_LNSWAP_SELf_GET
#define LANE_SWAPr_TX0_LNSWAP_SELf_SET BCMI_TSC_XGXS_LANE_SWAPr_TX0_LNSWAP_SELf_SET
#define READ_LANE_SWAPr BCMI_TSC_XGXS_READ_LANE_SWAPr
#define WRITE_LANE_SWAPr BCMI_TSC_XGXS_WRITE_LANE_SWAPr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_LANE_SWAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  DEVICEINPKG5
 * BLOCKS:   MAIN0
 * REGADDR:  0x9004
 * DESC:     Devices in Package5: 00000000
 * SIZE:     32
 * FIELDS:
 *     CLAUSE22         
 *     PMA_PMD          
 *     WIS              
 *     PCS_XS           
 *     PHY_XS           
 *     DTE_XS           
 *     TC               
 *     AN               
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_DEVICEINPKG5r (0x00109004 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_DEVICEINPKG5r_SIZE 4

/*
 * This structure should be used to declare and program DEVICEINPKG5.
 *
 */
typedef union BCMI_TSC_XGXS_DEVICEINPKG5r_s {
	uint32_t v[1];
	uint32_t deviceinpkg5[1];
	uint32_t _deviceinpkg5;
} BCMI_TSC_XGXS_DEVICEINPKG5r_t;

#define BCMI_TSC_XGXS_DEVICEINPKG5r_CLR(r) (r).deviceinpkg5[0] = 0
#define BCMI_TSC_XGXS_DEVICEINPKG5r_SET(r,d) (r).deviceinpkg5[0] = d
#define BCMI_TSC_XGXS_DEVICEINPKG5r_GET(r) (r).deviceinpkg5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_DEVICEINPKG5r_RESERVED0f_GET(r) ((((r).deviceinpkg5[0]) >> 8) & 0xff)
#define BCMI_TSC_XGXS_DEVICEINPKG5r_RESERVED0f_SET(r,f) (r).deviceinpkg5[0]=(((r).deviceinpkg5[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCMI_TSC_XGXS_DEVICEINPKG5r_ANf_GET(r) ((((r).deviceinpkg5[0]) >> 7) & 0x1)
#define BCMI_TSC_XGXS_DEVICEINPKG5r_ANf_SET(r,f) (r).deviceinpkg5[0]=(((r).deviceinpkg5[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCMI_TSC_XGXS_DEVICEINPKG5r_TCf_GET(r) ((((r).deviceinpkg5[0]) >> 6) & 0x1)
#define BCMI_TSC_XGXS_DEVICEINPKG5r_TCf_SET(r,f) (r).deviceinpkg5[0]=(((r).deviceinpkg5[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCMI_TSC_XGXS_DEVICEINPKG5r_DTE_XSf_GET(r) ((((r).deviceinpkg5[0]) >> 5) & 0x1)
#define BCMI_TSC_XGXS_DEVICEINPKG5r_DTE_XSf_SET(r,f) (r).deviceinpkg5[0]=(((r).deviceinpkg5[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCMI_TSC_XGXS_DEVICEINPKG5r_PHY_XSf_GET(r) ((((r).deviceinpkg5[0]) >> 4) & 0x1)
#define BCMI_TSC_XGXS_DEVICEINPKG5r_PHY_XSf_SET(r,f) (r).deviceinpkg5[0]=(((r).deviceinpkg5[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCMI_TSC_XGXS_DEVICEINPKG5r_PCS_XSf_GET(r) ((((r).deviceinpkg5[0]) >> 3) & 0x1)
#define BCMI_TSC_XGXS_DEVICEINPKG5r_PCS_XSf_SET(r,f) (r).deviceinpkg5[0]=(((r).deviceinpkg5[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCMI_TSC_XGXS_DEVICEINPKG5r_WISf_GET(r) ((((r).deviceinpkg5[0]) >> 2) & 0x1)
#define BCMI_TSC_XGXS_DEVICEINPKG5r_WISf_SET(r,f) (r).deviceinpkg5[0]=(((r).deviceinpkg5[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCMI_TSC_XGXS_DEVICEINPKG5r_PMA_PMDf_GET(r) ((((r).deviceinpkg5[0]) >> 1) & 0x1)
#define BCMI_TSC_XGXS_DEVICEINPKG5r_PMA_PMDf_SET(r,f) (r).deviceinpkg5[0]=(((r).deviceinpkg5[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCMI_TSC_XGXS_DEVICEINPKG5r_CLAUSE22f_GET(r) (((r).deviceinpkg5[0]) & 0x1)
#define BCMI_TSC_XGXS_DEVICEINPKG5r_CLAUSE22f_SET(r,f) (r).deviceinpkg5[0]=(((r).deviceinpkg5[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access DEVICEINPKG5.
 *
 */
#define BCMI_TSC_XGXS_READ_DEVICEINPKG5r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_DEVICEINPKG5r,(_r._deviceinpkg5))
#define BCMI_TSC_XGXS_WRITE_DEVICEINPKG5r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_DEVICEINPKG5r,(_r._deviceinpkg5))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DEVICEINPKG5r BCMI_TSC_XGXS_DEVICEINPKG5r
#define DEVICEINPKG5r_SIZE BCMI_TSC_XGXS_DEVICEINPKG5r_SIZE
typedef BCMI_TSC_XGXS_DEVICEINPKG5r_t DEVICEINPKG5r_t;
#define DEVICEINPKG5r_CLR BCMI_TSC_XGXS_DEVICEINPKG5r_CLR
#define DEVICEINPKG5r_SET BCMI_TSC_XGXS_DEVICEINPKG5r_SET
#define DEVICEINPKG5r_GET BCMI_TSC_XGXS_DEVICEINPKG5r_GET
#define DEVICEINPKG5r_RESERVED0f_GET BCMI_TSC_XGXS_DEVICEINPKG5r_RESERVED0f_GET
#define DEVICEINPKG5r_RESERVED0f_SET BCMI_TSC_XGXS_DEVICEINPKG5r_RESERVED0f_SET
#define DEVICEINPKG5r_ANf_GET BCMI_TSC_XGXS_DEVICEINPKG5r_ANf_GET
#define DEVICEINPKG5r_ANf_SET BCMI_TSC_XGXS_DEVICEINPKG5r_ANf_SET
#define DEVICEINPKG5r_TCf_GET BCMI_TSC_XGXS_DEVICEINPKG5r_TCf_GET
#define DEVICEINPKG5r_TCf_SET BCMI_TSC_XGXS_DEVICEINPKG5r_TCf_SET
#define DEVICEINPKG5r_DTE_XSf_GET BCMI_TSC_XGXS_DEVICEINPKG5r_DTE_XSf_GET
#define DEVICEINPKG5r_DTE_XSf_SET BCMI_TSC_XGXS_DEVICEINPKG5r_DTE_XSf_SET
#define DEVICEINPKG5r_PHY_XSf_GET BCMI_TSC_XGXS_DEVICEINPKG5r_PHY_XSf_GET
#define DEVICEINPKG5r_PHY_XSf_SET BCMI_TSC_XGXS_DEVICEINPKG5r_PHY_XSf_SET
#define DEVICEINPKG5r_PCS_XSf_GET BCMI_TSC_XGXS_DEVICEINPKG5r_PCS_XSf_GET
#define DEVICEINPKG5r_PCS_XSf_SET BCMI_TSC_XGXS_DEVICEINPKG5r_PCS_XSf_SET
#define DEVICEINPKG5r_WISf_GET BCMI_TSC_XGXS_DEVICEINPKG5r_WISf_GET
#define DEVICEINPKG5r_WISf_SET BCMI_TSC_XGXS_DEVICEINPKG5r_WISf_SET
#define DEVICEINPKG5r_PMA_PMDf_GET BCMI_TSC_XGXS_DEVICEINPKG5r_PMA_PMDf_GET
#define DEVICEINPKG5r_PMA_PMDf_SET BCMI_TSC_XGXS_DEVICEINPKG5r_PMA_PMDf_SET
#define DEVICEINPKG5r_CLAUSE22f_GET BCMI_TSC_XGXS_DEVICEINPKG5r_CLAUSE22f_GET
#define DEVICEINPKG5r_CLAUSE22f_SET BCMI_TSC_XGXS_DEVICEINPKG5r_CLAUSE22f_SET
#define READ_DEVICEINPKG5r BCMI_TSC_XGXS_READ_DEVICEINPKG5r
#define WRITE_DEVICEINPKG5r BCMI_TSC_XGXS_WRITE_DEVICEINPKG5r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_DEVICEINPKG5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  MISC
 * BLOCKS:   MAIN0
 * REGADDR:  0x9005
 * DESC:     Miscellaneous Controls: 00000000
 * SIZE:     32
 * FIELDS:
 *     RESERVED1        
 *     TEMP_SENSOR_BG_PWRDN 
 *     TEMP_SENSOR_PWRDN 
 *     TEMP_SENSOR_RESETB 
 *     CL82_MLD_PHYS_MAP 
 *     CL82_MULTI_PIPE_MODE 
 *     CL49_LOW_LATENCY_EN 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_MISCr (0x00109005 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_MISCr_SIZE 4

/*
 * This structure should be used to declare and program MISC.
 *
 */
typedef union BCMI_TSC_XGXS_MISCr_s {
	uint32_t v[1];
	uint32_t misc[1];
	uint32_t _misc;
} BCMI_TSC_XGXS_MISCr_t;

#define BCMI_TSC_XGXS_MISCr_CLR(r) (r).misc[0] = 0
#define BCMI_TSC_XGXS_MISCr_SET(r,d) (r).misc[0] = d
#define BCMI_TSC_XGXS_MISCr_GET(r) (r).misc[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_MISCr_RESERVED0f_GET(r) ((((r).misc[0]) >> 12) & 0xf)
#define BCMI_TSC_XGXS_MISCr_RESERVED0f_SET(r,f) (r).misc[0]=(((r).misc[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCMI_TSC_XGXS_MISCr_CL49_LOW_LATENCY_ENf_GET(r) ((((r).misc[0]) >> 11) & 0x1)
#define BCMI_TSC_XGXS_MISCr_CL49_LOW_LATENCY_ENf_SET(r,f) (r).misc[0]=(((r).misc[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCMI_TSC_XGXS_MISCr_CL82_MULTI_PIPE_MODEf_GET(r) ((((r).misc[0]) >> 9) & 0x3)
#define BCMI_TSC_XGXS_MISCr_CL82_MULTI_PIPE_MODEf_SET(r,f) (r).misc[0]=(((r).misc[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9))
#define BCMI_TSC_XGXS_MISCr_CL82_MLD_PHYS_MAPf_GET(r) ((((r).misc[0]) >> 7) & 0x3)
#define BCMI_TSC_XGXS_MISCr_CL82_MLD_PHYS_MAPf_SET(r,f) (r).misc[0]=(((r).misc[0] & ~((uint32_t)0x3 << 7)) | ((((uint32_t)f) & 0x3) << 7))
#define BCMI_TSC_XGXS_MISCr_TEMP_SENSOR_RESETBf_GET(r) ((((r).misc[0]) >> 6) & 0x1)
#define BCMI_TSC_XGXS_MISCr_TEMP_SENSOR_RESETBf_SET(r,f) (r).misc[0]=(((r).misc[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCMI_TSC_XGXS_MISCr_TEMP_SENSOR_PWRDNf_GET(r) ((((r).misc[0]) >> 5) & 0x1)
#define BCMI_TSC_XGXS_MISCr_TEMP_SENSOR_PWRDNf_SET(r,f) (r).misc[0]=(((r).misc[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCMI_TSC_XGXS_MISCr_TEMP_SENSOR_BG_PWRDNf_GET(r) ((((r).misc[0]) >> 4) & 0x1)
#define BCMI_TSC_XGXS_MISCr_TEMP_SENSOR_BG_PWRDNf_SET(r,f) (r).misc[0]=(((r).misc[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCMI_TSC_XGXS_MISCr_RESERVED1f_GET(r) (((r).misc[0]) & 0xf)
#define BCMI_TSC_XGXS_MISCr_RESERVED1f_SET(r,f) (r).misc[0]=(((r).misc[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access MISC.
 *
 */
#define BCMI_TSC_XGXS_READ_MISCr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_MISCr,(_r._misc))
#define BCMI_TSC_XGXS_WRITE_MISCr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_MISCr,(_r._misc))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MISCr BCMI_TSC_XGXS_MISCr
#define MISCr_SIZE BCMI_TSC_XGXS_MISCr_SIZE
typedef BCMI_TSC_XGXS_MISCr_t MISCr_t;
#define MISCr_CLR BCMI_TSC_XGXS_MISCr_CLR
#define MISCr_SET BCMI_TSC_XGXS_MISCr_SET
#define MISCr_GET BCMI_TSC_XGXS_MISCr_GET
#define MISCr_RESERVED0f_GET BCMI_TSC_XGXS_MISCr_RESERVED0f_GET
#define MISCr_RESERVED0f_SET BCMI_TSC_XGXS_MISCr_RESERVED0f_SET
#define MISCr_CL49_LOW_LATENCY_ENf_GET BCMI_TSC_XGXS_MISCr_CL49_LOW_LATENCY_ENf_GET
#define MISCr_CL49_LOW_LATENCY_ENf_SET BCMI_TSC_XGXS_MISCr_CL49_LOW_LATENCY_ENf_SET
#define MISCr_CL82_MULTI_PIPE_MODEf_GET BCMI_TSC_XGXS_MISCr_CL82_MULTI_PIPE_MODEf_GET
#define MISCr_CL82_MULTI_PIPE_MODEf_SET BCMI_TSC_XGXS_MISCr_CL82_MULTI_PIPE_MODEf_SET
#define MISCr_CL82_MLD_PHYS_MAPf_GET BCMI_TSC_XGXS_MISCr_CL82_MLD_PHYS_MAPf_GET
#define MISCr_CL82_MLD_PHYS_MAPf_SET BCMI_TSC_XGXS_MISCr_CL82_MLD_PHYS_MAPf_SET
#define MISCr_TEMP_SENSOR_RESETBf_GET BCMI_TSC_XGXS_MISCr_TEMP_SENSOR_RESETBf_GET
#define MISCr_TEMP_SENSOR_RESETBf_SET BCMI_TSC_XGXS_MISCr_TEMP_SENSOR_RESETBf_SET
#define MISCr_TEMP_SENSOR_PWRDNf_GET BCMI_TSC_XGXS_MISCr_TEMP_SENSOR_PWRDNf_GET
#define MISCr_TEMP_SENSOR_PWRDNf_SET BCMI_TSC_XGXS_MISCr_TEMP_SENSOR_PWRDNf_SET
#define MISCr_TEMP_SENSOR_BG_PWRDNf_GET BCMI_TSC_XGXS_MISCr_TEMP_SENSOR_BG_PWRDNf_GET
#define MISCr_TEMP_SENSOR_BG_PWRDNf_SET BCMI_TSC_XGXS_MISCr_TEMP_SENSOR_BG_PWRDNf_SET
#define MISCr_RESERVED1f_GET BCMI_TSC_XGXS_MISCr_RESERVED1f_GET
#define MISCr_RESERVED1f_SET BCMI_TSC_XGXS_MISCr_RESERVED1f_SET
#define READ_MISCr BCMI_TSC_XGXS_READ_MISCr
#define WRITE_MISCr BCMI_TSC_XGXS_WRITE_MISCr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_MISCr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  TEMP_SENSOR
 * BLOCKS:   MAIN0
 * REGADDR:  0x9006
 * DESC:     Temp Sensor Control Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     TEMP_SENSOR_CONTROL 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_TEMP_SENSORr (0x00109006 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_TEMP_SENSORr_SIZE 4

/*
 * This structure should be used to declare and program TEMP_SENSOR.
 *
 */
typedef union BCMI_TSC_XGXS_TEMP_SENSORr_s {
	uint32_t v[1];
	uint32_t temp_sensor[1];
	uint32_t _temp_sensor;
} BCMI_TSC_XGXS_TEMP_SENSORr_t;

#define BCMI_TSC_XGXS_TEMP_SENSORr_CLR(r) (r).temp_sensor[0] = 0
#define BCMI_TSC_XGXS_TEMP_SENSORr_SET(r,d) (r).temp_sensor[0] = d
#define BCMI_TSC_XGXS_TEMP_SENSORr_GET(r) (r).temp_sensor[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_TEMP_SENSORr_TEMP_SENSOR_CONTROLf_GET(r) (((r).temp_sensor[0]) & 0xffff)
#define BCMI_TSC_XGXS_TEMP_SENSORr_TEMP_SENSOR_CONTROLf_SET(r,f) (r).temp_sensor[0]=(((r).temp_sensor[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access TEMP_SENSOR.
 *
 */
#define BCMI_TSC_XGXS_READ_TEMP_SENSORr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_TEMP_SENSORr,(_r._temp_sensor))
#define BCMI_TSC_XGXS_WRITE_TEMP_SENSORr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_TEMP_SENSORr,(_r._temp_sensor))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TEMP_SENSORr BCMI_TSC_XGXS_TEMP_SENSORr
#define TEMP_SENSORr_SIZE BCMI_TSC_XGXS_TEMP_SENSORr_SIZE
typedef BCMI_TSC_XGXS_TEMP_SENSORr_t TEMP_SENSORr_t;
#define TEMP_SENSORr_CLR BCMI_TSC_XGXS_TEMP_SENSORr_CLR
#define TEMP_SENSORr_SET BCMI_TSC_XGXS_TEMP_SENSORr_SET
#define TEMP_SENSORr_GET BCMI_TSC_XGXS_TEMP_SENSORr_GET
#define TEMP_SENSORr_TEMP_SENSOR_CONTROLf_GET BCMI_TSC_XGXS_TEMP_SENSORr_TEMP_SENSOR_CONTROLf_GET
#define TEMP_SENSORr_TEMP_SENSOR_CONTROLf_SET BCMI_TSC_XGXS_TEMP_SENSORr_TEMP_SENSOR_CONTROLf_SET
#define READ_TEMP_SENSORr BCMI_TSC_XGXS_READ_TEMP_SENSORr
#define WRITE_TEMP_SENSORr BCMI_TSC_XGXS_WRITE_TEMP_SENSORr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_TEMP_SENSORr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  TICK_CONTROL_1
 * BLOCKS:   MAIN0
 * REGADDR:  0x9007
 * DESC:     TICK GENERATION CONTROL REGISTER 1: 00000000
 * SIZE:     32
 * FIELDS:
 *     TICK_NUMERATOR_UPPER 
 *     TICK_OVERRIDE    
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_TICK_CONTROL_1r (0x00109007 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_TICK_CONTROL_1r_SIZE 4

/*
 * This structure should be used to declare and program TICK_CONTROL_1.
 *
 */
typedef union BCMI_TSC_XGXS_TICK_CONTROL_1r_s {
	uint32_t v[1];
	uint32_t tick_control_1[1];
	uint32_t _tick_control_1;
} BCMI_TSC_XGXS_TICK_CONTROL_1r_t;

#define BCMI_TSC_XGXS_TICK_CONTROL_1r_CLR(r) (r).tick_control_1[0] = 0
#define BCMI_TSC_XGXS_TICK_CONTROL_1r_SET(r,d) (r).tick_control_1[0] = d
#define BCMI_TSC_XGXS_TICK_CONTROL_1r_GET(r) (r).tick_control_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_TICK_CONTROL_1r_TICK_OVERRIDEf_GET(r) ((((r).tick_control_1[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_TICK_CONTROL_1r_TICK_OVERRIDEf_SET(r,f) (r).tick_control_1[0]=(((r).tick_control_1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_TICK_CONTROL_1r_TICK_NUMERATOR_UPPERf_GET(r) (((r).tick_control_1[0]) & 0x7fff)
#define BCMI_TSC_XGXS_TICK_CONTROL_1r_TICK_NUMERATOR_UPPERf_SET(r,f) (r).tick_control_1[0]=(((r).tick_control_1[0] & ~((uint32_t)0x7fff)) | (((uint32_t)f) & 0x7fff))

/*
 * These macros can be used to access TICK_CONTROL_1.
 *
 */
#define BCMI_TSC_XGXS_READ_TICK_CONTROL_1r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_TICK_CONTROL_1r,(_r._tick_control_1))
#define BCMI_TSC_XGXS_WRITE_TICK_CONTROL_1r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_TICK_CONTROL_1r,(_r._tick_control_1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TICK_CONTROL_1r BCMI_TSC_XGXS_TICK_CONTROL_1r
#define TICK_CONTROL_1r_SIZE BCMI_TSC_XGXS_TICK_CONTROL_1r_SIZE
typedef BCMI_TSC_XGXS_TICK_CONTROL_1r_t TICK_CONTROL_1r_t;
#define TICK_CONTROL_1r_CLR BCMI_TSC_XGXS_TICK_CONTROL_1r_CLR
#define TICK_CONTROL_1r_SET BCMI_TSC_XGXS_TICK_CONTROL_1r_SET
#define TICK_CONTROL_1r_GET BCMI_TSC_XGXS_TICK_CONTROL_1r_GET
#define TICK_CONTROL_1r_TICK_OVERRIDEf_GET BCMI_TSC_XGXS_TICK_CONTROL_1r_TICK_OVERRIDEf_GET
#define TICK_CONTROL_1r_TICK_OVERRIDEf_SET BCMI_TSC_XGXS_TICK_CONTROL_1r_TICK_OVERRIDEf_SET
#define TICK_CONTROL_1r_TICK_NUMERATOR_UPPERf_GET BCMI_TSC_XGXS_TICK_CONTROL_1r_TICK_NUMERATOR_UPPERf_GET
#define TICK_CONTROL_1r_TICK_NUMERATOR_UPPERf_SET BCMI_TSC_XGXS_TICK_CONTROL_1r_TICK_NUMERATOR_UPPERf_SET
#define READ_TICK_CONTROL_1r BCMI_TSC_XGXS_READ_TICK_CONTROL_1r
#define WRITE_TICK_CONTROL_1r BCMI_TSC_XGXS_WRITE_TICK_CONTROL_1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_TICK_CONTROL_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  TICK_CONTROL_0
 * BLOCKS:   MAIN0
 * REGADDR:  0x9008
 * DESC:     TICK GENERATION CONTROL REGISTER 1: 00000000
 * SIZE:     32
 * FIELDS:
 *     RESERVED0        
 *     TICK_DENOMINATOR 
 *     TICK_NUMERATOR_LOWER 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_TICK_CONTROL_0r (0x00109008 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_TICK_CONTROL_0r_SIZE 4

/*
 * This structure should be used to declare and program TICK_CONTROL_0.
 *
 */
typedef union BCMI_TSC_XGXS_TICK_CONTROL_0r_s {
	uint32_t v[1];
	uint32_t tick_control_0[1];
	uint32_t _tick_control_0;
} BCMI_TSC_XGXS_TICK_CONTROL_0r_t;

#define BCMI_TSC_XGXS_TICK_CONTROL_0r_CLR(r) (r).tick_control_0[0] = 0
#define BCMI_TSC_XGXS_TICK_CONTROL_0r_SET(r,d) (r).tick_control_0[0] = d
#define BCMI_TSC_XGXS_TICK_CONTROL_0r_GET(r) (r).tick_control_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_TICK_CONTROL_0r_TICK_NUMERATOR_LOWERf_GET(r) ((((r).tick_control_0[0]) >> 12) & 0xf)
#define BCMI_TSC_XGXS_TICK_CONTROL_0r_TICK_NUMERATOR_LOWERf_SET(r,f) (r).tick_control_0[0]=(((r).tick_control_0[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCMI_TSC_XGXS_TICK_CONTROL_0r_TICK_DENOMINATORf_GET(r) ((((r).tick_control_0[0]) >> 2) & 0x3ff)
#define BCMI_TSC_XGXS_TICK_CONTROL_0r_TICK_DENOMINATORf_SET(r,f) (r).tick_control_0[0]=(((r).tick_control_0[0] & ~((uint32_t)0x3ff << 2)) | ((((uint32_t)f) & 0x3ff) << 2))
#define BCMI_TSC_XGXS_TICK_CONTROL_0r_RESERVED0f_GET(r) (((r).tick_control_0[0]) & 0x3)
#define BCMI_TSC_XGXS_TICK_CONTROL_0r_RESERVED0f_SET(r,f) (r).tick_control_0[0]=(((r).tick_control_0[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))

/*
 * These macros can be used to access TICK_CONTROL_0.
 *
 */
#define BCMI_TSC_XGXS_READ_TICK_CONTROL_0r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_TICK_CONTROL_0r,(_r._tick_control_0))
#define BCMI_TSC_XGXS_WRITE_TICK_CONTROL_0r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_TICK_CONTROL_0r,(_r._tick_control_0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TICK_CONTROL_0r BCMI_TSC_XGXS_TICK_CONTROL_0r
#define TICK_CONTROL_0r_SIZE BCMI_TSC_XGXS_TICK_CONTROL_0r_SIZE
typedef BCMI_TSC_XGXS_TICK_CONTROL_0r_t TICK_CONTROL_0r_t;
#define TICK_CONTROL_0r_CLR BCMI_TSC_XGXS_TICK_CONTROL_0r_CLR
#define TICK_CONTROL_0r_SET BCMI_TSC_XGXS_TICK_CONTROL_0r_SET
#define TICK_CONTROL_0r_GET BCMI_TSC_XGXS_TICK_CONTROL_0r_GET
#define TICK_CONTROL_0r_TICK_NUMERATOR_LOWERf_GET BCMI_TSC_XGXS_TICK_CONTROL_0r_TICK_NUMERATOR_LOWERf_GET
#define TICK_CONTROL_0r_TICK_NUMERATOR_LOWERf_SET BCMI_TSC_XGXS_TICK_CONTROL_0r_TICK_NUMERATOR_LOWERf_SET
#define TICK_CONTROL_0r_TICK_DENOMINATORf_GET BCMI_TSC_XGXS_TICK_CONTROL_0r_TICK_DENOMINATORf_GET
#define TICK_CONTROL_0r_TICK_DENOMINATORf_SET BCMI_TSC_XGXS_TICK_CONTROL_0r_TICK_DENOMINATORf_SET
#define TICK_CONTROL_0r_RESERVED0f_GET BCMI_TSC_XGXS_TICK_CONTROL_0r_RESERVED0f_GET
#define TICK_CONTROL_0r_RESERVED0f_SET BCMI_TSC_XGXS_TICK_CONTROL_0r_RESERVED0f_SET
#define READ_TICK_CONTROL_0r BCMI_TSC_XGXS_READ_TICK_CONTROL_0r
#define WRITE_TICK_CONTROL_0r BCMI_TSC_XGXS_WRITE_TICK_CONTROL_0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_TICK_CONTROL_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  LOOPBACK_CONTROL
 * BLOCKS:   MAIN0
 * REGADDR:  0x9009
 * DESC:     LOOPBACK CONTROL REGISTER: 00000000
 * SIZE:     32
 * FIELDS:
 *     RESERVED0        
 *     LOCAL_PCS_LOOPBACK_ENABLE 
 *     REMOTE_PMD_LOOPBACK_ENABLE 
 *     REMOTE_PCS_LOOPBACK_ENABLE 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_LOOPBACK_CONTROLr (0x00109009 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_LOOPBACK_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program LOOPBACK_CONTROL.
 *
 */
typedef union BCMI_TSC_XGXS_LOOPBACK_CONTROLr_s {
	uint32_t v[1];
	uint32_t loopback_control[1];
	uint32_t _loopback_control;
} BCMI_TSC_XGXS_LOOPBACK_CONTROLr_t;

#define BCMI_TSC_XGXS_LOOPBACK_CONTROLr_CLR(r) (r).loopback_control[0] = 0
#define BCMI_TSC_XGXS_LOOPBACK_CONTROLr_SET(r,d) (r).loopback_control[0] = d
#define BCMI_TSC_XGXS_LOOPBACK_CONTROLr_GET(r) (r).loopback_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_LOOPBACK_CONTROLr_REMOTE_PCS_LOOPBACK_ENABLEf_GET(r) ((((r).loopback_control[0]) >> 12) & 0xf)
#define BCMI_TSC_XGXS_LOOPBACK_CONTROLr_REMOTE_PCS_LOOPBACK_ENABLEf_SET(r,f) (r).loopback_control[0]=(((r).loopback_control[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCMI_TSC_XGXS_LOOPBACK_CONTROLr_REMOTE_PMD_LOOPBACK_ENABLEf_GET(r) ((((r).loopback_control[0]) >> 8) & 0xf)
#define BCMI_TSC_XGXS_LOOPBACK_CONTROLr_REMOTE_PMD_LOOPBACK_ENABLEf_SET(r,f) (r).loopback_control[0]=(((r).loopback_control[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCMI_TSC_XGXS_LOOPBACK_CONTROLr_LOCAL_PCS_LOOPBACK_ENABLEf_GET(r) ((((r).loopback_control[0]) >> 4) & 0xf)
#define BCMI_TSC_XGXS_LOOPBACK_CONTROLr_LOCAL_PCS_LOOPBACK_ENABLEf_SET(r,f) (r).loopback_control[0]=(((r).loopback_control[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCMI_TSC_XGXS_LOOPBACK_CONTROLr_RESERVED0f_GET(r) (((r).loopback_control[0]) & 0xf)
#define BCMI_TSC_XGXS_LOOPBACK_CONTROLr_RESERVED0f_SET(r,f) (r).loopback_control[0]=(((r).loopback_control[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access LOOPBACK_CONTROL.
 *
 */
#define BCMI_TSC_XGXS_READ_LOOPBACK_CONTROLr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_LOOPBACK_CONTROLr,(_r._loopback_control))
#define BCMI_TSC_XGXS_WRITE_LOOPBACK_CONTROLr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_LOOPBACK_CONTROLr,(_r._loopback_control))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define LOOPBACK_CONTROLr BCMI_TSC_XGXS_LOOPBACK_CONTROLr
#define LOOPBACK_CONTROLr_SIZE BCMI_TSC_XGXS_LOOPBACK_CONTROLr_SIZE
typedef BCMI_TSC_XGXS_LOOPBACK_CONTROLr_t LOOPBACK_CONTROLr_t;
#define LOOPBACK_CONTROLr_CLR BCMI_TSC_XGXS_LOOPBACK_CONTROLr_CLR
#define LOOPBACK_CONTROLr_SET BCMI_TSC_XGXS_LOOPBACK_CONTROLr_SET
#define LOOPBACK_CONTROLr_GET BCMI_TSC_XGXS_LOOPBACK_CONTROLr_GET
#define LOOPBACK_CONTROLr_REMOTE_PCS_LOOPBACK_ENABLEf_GET BCMI_TSC_XGXS_LOOPBACK_CONTROLr_REMOTE_PCS_LOOPBACK_ENABLEf_GET
#define LOOPBACK_CONTROLr_REMOTE_PCS_LOOPBACK_ENABLEf_SET BCMI_TSC_XGXS_LOOPBACK_CONTROLr_REMOTE_PCS_LOOPBACK_ENABLEf_SET
#define LOOPBACK_CONTROLr_REMOTE_PMD_LOOPBACK_ENABLEf_GET BCMI_TSC_XGXS_LOOPBACK_CONTROLr_REMOTE_PMD_LOOPBACK_ENABLEf_GET
#define LOOPBACK_CONTROLr_REMOTE_PMD_LOOPBACK_ENABLEf_SET BCMI_TSC_XGXS_LOOPBACK_CONTROLr_REMOTE_PMD_LOOPBACK_ENABLEf_SET
#define LOOPBACK_CONTROLr_LOCAL_PCS_LOOPBACK_ENABLEf_GET BCMI_TSC_XGXS_LOOPBACK_CONTROLr_LOCAL_PCS_LOOPBACK_ENABLEf_GET
#define LOOPBACK_CONTROLr_LOCAL_PCS_LOOPBACK_ENABLEf_SET BCMI_TSC_XGXS_LOOPBACK_CONTROLr_LOCAL_PCS_LOOPBACK_ENABLEf_SET
#define LOOPBACK_CONTROLr_RESERVED0f_GET BCMI_TSC_XGXS_LOOPBACK_CONTROLr_RESERVED0f_GET
#define LOOPBACK_CONTROLr_RESERVED0f_SET BCMI_TSC_XGXS_LOOPBACK_CONTROLr_RESERVED0f_SET
#define READ_LOOPBACK_CONTROLr BCMI_TSC_XGXS_READ_LOOPBACK_CONTROLr
#define WRITE_LOOPBACK_CONTROLr BCMI_TSC_XGXS_WRITE_LOOPBACK_CONTROLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_LOOPBACK_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  MDIO_BROADCAST
 * BLOCKS:   MAIN0
 * REGADDR:  0x900a
 * DESC:     PRTAD Broadcast Values: 00000000
 * SIZE:     32
 * FIELDS:
 *     RESERVED0        
 *     MULTIPRTS_EN     
 *     PRTAD_BCST       
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_MDIO_BROADCASTr (0x0010900a | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_MDIO_BROADCASTr_SIZE 4

/*
 * This structure should be used to declare and program MDIO_BROADCAST.
 *
 */
typedef union BCMI_TSC_XGXS_MDIO_BROADCASTr_s {
	uint32_t v[1];
	uint32_t mdio_broadcast[1];
	uint32_t _mdio_broadcast;
} BCMI_TSC_XGXS_MDIO_BROADCASTr_t;

#define BCMI_TSC_XGXS_MDIO_BROADCASTr_CLR(r) (r).mdio_broadcast[0] = 0
#define BCMI_TSC_XGXS_MDIO_BROADCASTr_SET(r,d) (r).mdio_broadcast[0] = d
#define BCMI_TSC_XGXS_MDIO_BROADCASTr_GET(r) (r).mdio_broadcast[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_MDIO_BROADCASTr_PRTAD_BCSTf_GET(r) ((((r).mdio_broadcast[0]) >> 11) & 0x1f)
#define BCMI_TSC_XGXS_MDIO_BROADCASTr_PRTAD_BCSTf_SET(r,f) (r).mdio_broadcast[0]=(((r).mdio_broadcast[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))
#define BCMI_TSC_XGXS_MDIO_BROADCASTr_MULTIPRTS_ENf_GET(r) ((((r).mdio_broadcast[0]) >> 7) & 0xf)
#define BCMI_TSC_XGXS_MDIO_BROADCASTr_MULTIPRTS_ENf_SET(r,f) (r).mdio_broadcast[0]=(((r).mdio_broadcast[0] & ~((uint32_t)0xf << 7)) | ((((uint32_t)f) & 0xf) << 7))
#define BCMI_TSC_XGXS_MDIO_BROADCASTr_RESERVED0f_GET(r) (((r).mdio_broadcast[0]) & 0x7f)
#define BCMI_TSC_XGXS_MDIO_BROADCASTr_RESERVED0f_SET(r,f) (r).mdio_broadcast[0]=(((r).mdio_broadcast[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f))

/*
 * These macros can be used to access MDIO_BROADCAST.
 *
 */
#define BCMI_TSC_XGXS_READ_MDIO_BROADCASTr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_MDIO_BROADCASTr,(_r._mdio_broadcast))
#define BCMI_TSC_XGXS_WRITE_MDIO_BROADCASTr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_MDIO_BROADCASTr,(_r._mdio_broadcast))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MDIO_BROADCASTr BCMI_TSC_XGXS_MDIO_BROADCASTr
#define MDIO_BROADCASTr_SIZE BCMI_TSC_XGXS_MDIO_BROADCASTr_SIZE
typedef BCMI_TSC_XGXS_MDIO_BROADCASTr_t MDIO_BROADCASTr_t;
#define MDIO_BROADCASTr_CLR BCMI_TSC_XGXS_MDIO_BROADCASTr_CLR
#define MDIO_BROADCASTr_SET BCMI_TSC_XGXS_MDIO_BROADCASTr_SET
#define MDIO_BROADCASTr_GET BCMI_TSC_XGXS_MDIO_BROADCASTr_GET
#define MDIO_BROADCASTr_PRTAD_BCSTf_GET BCMI_TSC_XGXS_MDIO_BROADCASTr_PRTAD_BCSTf_GET
#define MDIO_BROADCASTr_PRTAD_BCSTf_SET BCMI_TSC_XGXS_MDIO_BROADCASTr_PRTAD_BCSTf_SET
#define MDIO_BROADCASTr_MULTIPRTS_ENf_GET BCMI_TSC_XGXS_MDIO_BROADCASTr_MULTIPRTS_ENf_GET
#define MDIO_BROADCASTr_MULTIPRTS_ENf_SET BCMI_TSC_XGXS_MDIO_BROADCASTr_MULTIPRTS_ENf_SET
#define MDIO_BROADCASTr_RESERVED0f_GET BCMI_TSC_XGXS_MDIO_BROADCASTr_RESERVED0f_GET
#define MDIO_BROADCASTr_RESERVED0f_SET BCMI_TSC_XGXS_MDIO_BROADCASTr_RESERVED0f_SET
#define READ_MDIO_BROADCASTr BCMI_TSC_XGXS_READ_MDIO_BROADCASTr
#define WRITE_MDIO_BROADCASTr BCMI_TSC_XGXS_WRITE_MDIO_BROADCASTr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_MDIO_BROADCASTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  SERDESID
 * BLOCKS:   MAIN0
 * REGADDR:  0x900e
 * DESC:     Serdes ID Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     MODEL_NUMBER     
 *     TECH_PROC        
 *     BONDING          
 *     REV_NUMBER       
 *     REV_LETTER       
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_SERDESIDr (0x0010900e | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_SERDESIDr_SIZE 4

/*
 * This structure should be used to declare and program SERDESID.
 *
 */
typedef union BCMI_TSC_XGXS_SERDESIDr_s {
	uint32_t v[1];
	uint32_t serdesid[1];
	uint32_t _serdesid;
} BCMI_TSC_XGXS_SERDESIDr_t;

#define BCMI_TSC_XGXS_SERDESIDr_CLR(r) (r).serdesid[0] = 0
#define BCMI_TSC_XGXS_SERDESIDr_SET(r,d) (r).serdesid[0] = d
#define BCMI_TSC_XGXS_SERDESIDr_GET(r) (r).serdesid[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_SERDESIDr_REV_LETTERf_GET(r) ((((r).serdesid[0]) >> 14) & 0x3)
#define BCMI_TSC_XGXS_SERDESIDr_REV_LETTERf_SET(r,f) (r).serdesid[0]=(((r).serdesid[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCMI_TSC_XGXS_SERDESIDr_REV_NUMBERf_GET(r) ((((r).serdesid[0]) >> 11) & 0x7)
#define BCMI_TSC_XGXS_SERDESIDr_REV_NUMBERf_SET(r,f) (r).serdesid[0]=(((r).serdesid[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11))
#define BCMI_TSC_XGXS_SERDESIDr_BONDINGf_GET(r) ((((r).serdesid[0]) >> 9) & 0x3)
#define BCMI_TSC_XGXS_SERDESIDr_BONDINGf_SET(r,f) (r).serdesid[0]=(((r).serdesid[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9))
#define BCMI_TSC_XGXS_SERDESIDr_TECH_PROCf_GET(r) ((((r).serdesid[0]) >> 6) & 0x7)
#define BCMI_TSC_XGXS_SERDESIDr_TECH_PROCf_SET(r,f) (r).serdesid[0]=(((r).serdesid[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCMI_TSC_XGXS_SERDESIDr_MODEL_NUMBERf_GET(r) (((r).serdesid[0]) & 0x3f)
#define BCMI_TSC_XGXS_SERDESIDr_MODEL_NUMBERf_SET(r,f) (r).serdesid[0]=(((r).serdesid[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))

/*
 * These macros can be used to access SERDESID.
 *
 */
#define BCMI_TSC_XGXS_READ_SERDESIDr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_SERDESIDr,(_r._serdesid))
#define BCMI_TSC_XGXS_WRITE_SERDESIDr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_SERDESIDr,(_r._serdesid))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SERDESIDr BCMI_TSC_XGXS_SERDESIDr
#define SERDESIDr_SIZE BCMI_TSC_XGXS_SERDESIDr_SIZE
typedef BCMI_TSC_XGXS_SERDESIDr_t SERDESIDr_t;
#define SERDESIDr_CLR BCMI_TSC_XGXS_SERDESIDr_CLR
#define SERDESIDr_SET BCMI_TSC_XGXS_SERDESIDr_SET
#define SERDESIDr_GET BCMI_TSC_XGXS_SERDESIDr_GET
#define SERDESIDr_REV_LETTERf_GET BCMI_TSC_XGXS_SERDESIDr_REV_LETTERf_GET
#define SERDESIDr_REV_LETTERf_SET BCMI_TSC_XGXS_SERDESIDr_REV_LETTERf_SET
#define SERDESIDr_REV_NUMBERf_GET BCMI_TSC_XGXS_SERDESIDr_REV_NUMBERf_GET
#define SERDESIDr_REV_NUMBERf_SET BCMI_TSC_XGXS_SERDESIDr_REV_NUMBERf_SET
#define SERDESIDr_BONDINGf_GET BCMI_TSC_XGXS_SERDESIDr_BONDINGf_GET
#define SERDESIDr_BONDINGf_SET BCMI_TSC_XGXS_SERDESIDr_BONDINGf_SET
#define SERDESIDr_TECH_PROCf_GET BCMI_TSC_XGXS_SERDESIDr_TECH_PROCf_GET
#define SERDESIDr_TECH_PROCf_SET BCMI_TSC_XGXS_SERDESIDr_TECH_PROCf_SET
#define SERDESIDr_MODEL_NUMBERf_GET BCMI_TSC_XGXS_SERDESIDr_MODEL_NUMBERf_GET
#define SERDESIDr_MODEL_NUMBERf_SET BCMI_TSC_XGXS_SERDESIDr_MODEL_NUMBERf_SET
#define READ_SERDESIDr BCMI_TSC_XGXS_READ_SERDESIDr
#define WRITE_SERDESIDr BCMI_TSC_XGXS_WRITE_SERDESIDr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_SERDESIDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  ANAPLL_STATUS
 * BLOCKS:   ANAPLL
 * REGADDR:  0x9010
 * DESC:     PLL status register: 00000000
 * SIZE:     32
 * FIELDS:
 *     PLL_MODE_AFE     
 *     RESERVED2        
 *     LOSTPLLLOCK_SM   
 *     SLOWDN           
 *     RESERVED1        
 *     VCOPASS          
 *     FREQPASS         
 *     PLLSEQPASS       
 *     RESERVED0        
 *     VCODONE          
 *     FREQDONE         
 *     PLLSEQDONE       
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_ANAPLL_STATUSr (0x00109010 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_ANAPLL_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program ANAPLL_STATUS.
 *
 */
typedef union BCMI_TSC_XGXS_ANAPLL_STATUSr_s {
	uint32_t v[1];
	uint32_t anapll_status[1];
	uint32_t _anapll_status;
} BCMI_TSC_XGXS_ANAPLL_STATUSr_t;

#define BCMI_TSC_XGXS_ANAPLL_STATUSr_CLR(r) (r).anapll_status[0] = 0
#define BCMI_TSC_XGXS_ANAPLL_STATUSr_SET(r,d) (r).anapll_status[0] = d
#define BCMI_TSC_XGXS_ANAPLL_STATUSr_GET(r) (r).anapll_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_ANAPLL_STATUSr_PLLSEQDONEf_GET(r) ((((r).anapll_status[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_STATUSr_PLLSEQDONEf_SET(r,f) (r).anapll_status[0]=(((r).anapll_status[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_ANAPLL_STATUSr_FREQDONEf_GET(r) ((((r).anapll_status[0]) >> 14) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_STATUSr_FREQDONEf_SET(r,f) (r).anapll_status[0]=(((r).anapll_status[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCMI_TSC_XGXS_ANAPLL_STATUSr_VCODONEf_GET(r) ((((r).anapll_status[0]) >> 13) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_STATUSr_VCODONEf_SET(r,f) (r).anapll_status[0]=(((r).anapll_status[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCMI_TSC_XGXS_ANAPLL_STATUSr_RESERVED0f_GET(r) ((((r).anapll_status[0]) >> 12) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_STATUSr_RESERVED0f_SET(r,f) (r).anapll_status[0]=(((r).anapll_status[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCMI_TSC_XGXS_ANAPLL_STATUSr_PLLSEQPASSf_GET(r) ((((r).anapll_status[0]) >> 11) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_STATUSr_PLLSEQPASSf_SET(r,f) (r).anapll_status[0]=(((r).anapll_status[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCMI_TSC_XGXS_ANAPLL_STATUSr_FREQPASSf_GET(r) ((((r).anapll_status[0]) >> 10) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_STATUSr_FREQPASSf_SET(r,f) (r).anapll_status[0]=(((r).anapll_status[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCMI_TSC_XGXS_ANAPLL_STATUSr_VCOPASSf_GET(r) ((((r).anapll_status[0]) >> 9) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_STATUSr_VCOPASSf_SET(r,f) (r).anapll_status[0]=(((r).anapll_status[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCMI_TSC_XGXS_ANAPLL_STATUSr_RESERVED1f_GET(r) ((((r).anapll_status[0]) >> 8) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_STATUSr_RESERVED1f_SET(r,f) (r).anapll_status[0]=(((r).anapll_status[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCMI_TSC_XGXS_ANAPLL_STATUSr_SLOWDNf_GET(r) ((((r).anapll_status[0]) >> 7) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_STATUSr_SLOWDNf_SET(r,f) (r).anapll_status[0]=(((r).anapll_status[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCMI_TSC_XGXS_ANAPLL_STATUSr_LOSTPLLLOCK_SMf_GET(r) ((((r).anapll_status[0]) >> 6) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_STATUSr_LOSTPLLLOCK_SMf_SET(r,f) (r).anapll_status[0]=(((r).anapll_status[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCMI_TSC_XGXS_ANAPLL_STATUSr_RESERVED2f_GET(r) ((((r).anapll_status[0]) >> 4) & 0x3)
#define BCMI_TSC_XGXS_ANAPLL_STATUSr_RESERVED2f_SET(r,f) (r).anapll_status[0]=(((r).anapll_status[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCMI_TSC_XGXS_ANAPLL_STATUSr_PLL_MODE_AFEf_GET(r) (((r).anapll_status[0]) & 0xf)
#define BCMI_TSC_XGXS_ANAPLL_STATUSr_PLL_MODE_AFEf_SET(r,f) (r).anapll_status[0]=(((r).anapll_status[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access ANAPLL_STATUS.
 *
 */
#define BCMI_TSC_XGXS_READ_ANAPLL_STATUSr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_ANAPLL_STATUSr,(_r._anapll_status))
#define BCMI_TSC_XGXS_WRITE_ANAPLL_STATUSr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_ANAPLL_STATUSr,(_r._anapll_status))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define ANAPLL_STATUSr BCMI_TSC_XGXS_ANAPLL_STATUSr
#define ANAPLL_STATUSr_SIZE BCMI_TSC_XGXS_ANAPLL_STATUSr_SIZE
typedef BCMI_TSC_XGXS_ANAPLL_STATUSr_t ANAPLL_STATUSr_t;
#define ANAPLL_STATUSr_CLR BCMI_TSC_XGXS_ANAPLL_STATUSr_CLR
#define ANAPLL_STATUSr_SET BCMI_TSC_XGXS_ANAPLL_STATUSr_SET
#define ANAPLL_STATUSr_GET BCMI_TSC_XGXS_ANAPLL_STATUSr_GET
#define ANAPLL_STATUSr_PLLSEQDONEf_GET BCMI_TSC_XGXS_ANAPLL_STATUSr_PLLSEQDONEf_GET
#define ANAPLL_STATUSr_PLLSEQDONEf_SET BCMI_TSC_XGXS_ANAPLL_STATUSr_PLLSEQDONEf_SET
#define ANAPLL_STATUSr_FREQDONEf_GET BCMI_TSC_XGXS_ANAPLL_STATUSr_FREQDONEf_GET
#define ANAPLL_STATUSr_FREQDONEf_SET BCMI_TSC_XGXS_ANAPLL_STATUSr_FREQDONEf_SET
#define ANAPLL_STATUSr_VCODONEf_GET BCMI_TSC_XGXS_ANAPLL_STATUSr_VCODONEf_GET
#define ANAPLL_STATUSr_VCODONEf_SET BCMI_TSC_XGXS_ANAPLL_STATUSr_VCODONEf_SET
#define ANAPLL_STATUSr_RESERVED0f_GET BCMI_TSC_XGXS_ANAPLL_STATUSr_RESERVED0f_GET
#define ANAPLL_STATUSr_RESERVED0f_SET BCMI_TSC_XGXS_ANAPLL_STATUSr_RESERVED0f_SET
#define ANAPLL_STATUSr_PLLSEQPASSf_GET BCMI_TSC_XGXS_ANAPLL_STATUSr_PLLSEQPASSf_GET
#define ANAPLL_STATUSr_PLLSEQPASSf_SET BCMI_TSC_XGXS_ANAPLL_STATUSr_PLLSEQPASSf_SET
#define ANAPLL_STATUSr_FREQPASSf_GET BCMI_TSC_XGXS_ANAPLL_STATUSr_FREQPASSf_GET
#define ANAPLL_STATUSr_FREQPASSf_SET BCMI_TSC_XGXS_ANAPLL_STATUSr_FREQPASSf_SET
#define ANAPLL_STATUSr_VCOPASSf_GET BCMI_TSC_XGXS_ANAPLL_STATUSr_VCOPASSf_GET
#define ANAPLL_STATUSr_VCOPASSf_SET BCMI_TSC_XGXS_ANAPLL_STATUSr_VCOPASSf_SET
#define ANAPLL_STATUSr_RESERVED1f_GET BCMI_TSC_XGXS_ANAPLL_STATUSr_RESERVED1f_GET
#define ANAPLL_STATUSr_RESERVED1f_SET BCMI_TSC_XGXS_ANAPLL_STATUSr_RESERVED1f_SET
#define ANAPLL_STATUSr_SLOWDNf_GET BCMI_TSC_XGXS_ANAPLL_STATUSr_SLOWDNf_GET
#define ANAPLL_STATUSr_SLOWDNf_SET BCMI_TSC_XGXS_ANAPLL_STATUSr_SLOWDNf_SET
#define ANAPLL_STATUSr_LOSTPLLLOCK_SMf_GET BCMI_TSC_XGXS_ANAPLL_STATUSr_LOSTPLLLOCK_SMf_GET
#define ANAPLL_STATUSr_LOSTPLLLOCK_SMf_SET BCMI_TSC_XGXS_ANAPLL_STATUSr_LOSTPLLLOCK_SMf_SET
#define ANAPLL_STATUSr_RESERVED2f_GET BCMI_TSC_XGXS_ANAPLL_STATUSr_RESERVED2f_GET
#define ANAPLL_STATUSr_RESERVED2f_SET BCMI_TSC_XGXS_ANAPLL_STATUSr_RESERVED2f_SET
#define ANAPLL_STATUSr_PLL_MODE_AFEf_GET BCMI_TSC_XGXS_ANAPLL_STATUSr_PLL_MODE_AFEf_GET
#define ANAPLL_STATUSr_PLL_MODE_AFEf_SET BCMI_TSC_XGXS_ANAPLL_STATUSr_PLL_MODE_AFEf_SET
#define READ_ANAPLL_STATUSr BCMI_TSC_XGXS_READ_ANAPLL_STATUSr
#define WRITE_ANAPLL_STATUSr BCMI_TSC_XGXS_WRITE_ANAPLL_STATUSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_ANAPLL_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  ANAPLL_CONTROL
 * BLOCKS:   ANAPLL
 * REGADDR:  0x9011
 * DESC:     PLL control register: 00000000
 * SIZE:     32
 * FIELDS:
 *     PLLFORCEPLLLOCK  
 *     PLLFORCEVCOPASS  
 *     PLLFORCEVCOPASS_EN 
 *     PLLFORCEVCODONE  
 *     PLLFORCEVCODONE_EN 
 *     PLLFORCEPASS     
 *     PLLFORCEDONE     
 *     PLLFORCEDONE_EN  
 *     BYTESYNCRESTART_EN 
 *     LINKRESTART_EN   
 *     VCODONE_EN       
 *     VCOPRETRY_EN     
 *     FREQMONITOR_EN   
 *     FREQDETRESTART_EN 
 *     FREQDETRETRY_EN  
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_ANAPLL_CONTROLr (0x00109011 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_ANAPLL_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program ANAPLL_CONTROL.
 *
 */
typedef union BCMI_TSC_XGXS_ANAPLL_CONTROLr_s {
	uint32_t v[1];
	uint32_t anapll_control[1];
	uint32_t _anapll_control;
} BCMI_TSC_XGXS_ANAPLL_CONTROLr_t;

#define BCMI_TSC_XGXS_ANAPLL_CONTROLr_CLR(r) (r).anapll_control[0] = 0
#define BCMI_TSC_XGXS_ANAPLL_CONTROLr_SET(r,d) (r).anapll_control[0] = d
#define BCMI_TSC_XGXS_ANAPLL_CONTROLr_GET(r) (r).anapll_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_ANAPLL_CONTROLr_RESERVED0f_GET(r) ((((r).anapll_control[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_CONTROLr_RESERVED0f_SET(r,f) (r).anapll_control[0]=(((r).anapll_control[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_ANAPLL_CONTROLr_FREQDETRETRY_ENf_GET(r) ((((r).anapll_control[0]) >> 14) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_CONTROLr_FREQDETRETRY_ENf_SET(r,f) (r).anapll_control[0]=(((r).anapll_control[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCMI_TSC_XGXS_ANAPLL_CONTROLr_FREQDETRESTART_ENf_GET(r) ((((r).anapll_control[0]) >> 13) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_CONTROLr_FREQDETRESTART_ENf_SET(r,f) (r).anapll_control[0]=(((r).anapll_control[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCMI_TSC_XGXS_ANAPLL_CONTROLr_FREQMONITOR_ENf_GET(r) ((((r).anapll_control[0]) >> 12) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_CONTROLr_FREQMONITOR_ENf_SET(r,f) (r).anapll_control[0]=(((r).anapll_control[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCMI_TSC_XGXS_ANAPLL_CONTROLr_VCOPRETRY_ENf_GET(r) ((((r).anapll_control[0]) >> 11) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_CONTROLr_VCOPRETRY_ENf_SET(r,f) (r).anapll_control[0]=(((r).anapll_control[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCMI_TSC_XGXS_ANAPLL_CONTROLr_VCODONE_ENf_GET(r) ((((r).anapll_control[0]) >> 10) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_CONTROLr_VCODONE_ENf_SET(r,f) (r).anapll_control[0]=(((r).anapll_control[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCMI_TSC_XGXS_ANAPLL_CONTROLr_LINKRESTART_ENf_GET(r) ((((r).anapll_control[0]) >> 9) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_CONTROLr_LINKRESTART_ENf_SET(r,f) (r).anapll_control[0]=(((r).anapll_control[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCMI_TSC_XGXS_ANAPLL_CONTROLr_BYTESYNCRESTART_ENf_GET(r) ((((r).anapll_control[0]) >> 8) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_CONTROLr_BYTESYNCRESTART_ENf_SET(r,f) (r).anapll_control[0]=(((r).anapll_control[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCMI_TSC_XGXS_ANAPLL_CONTROLr_PLLFORCEDONE_ENf_GET(r) ((((r).anapll_control[0]) >> 7) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_CONTROLr_PLLFORCEDONE_ENf_SET(r,f) (r).anapll_control[0]=(((r).anapll_control[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCMI_TSC_XGXS_ANAPLL_CONTROLr_PLLFORCEDONEf_GET(r) ((((r).anapll_control[0]) >> 6) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_CONTROLr_PLLFORCEDONEf_SET(r,f) (r).anapll_control[0]=(((r).anapll_control[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCMI_TSC_XGXS_ANAPLL_CONTROLr_PLLFORCEPASSf_GET(r) ((((r).anapll_control[0]) >> 5) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_CONTROLr_PLLFORCEPASSf_SET(r,f) (r).anapll_control[0]=(((r).anapll_control[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCMI_TSC_XGXS_ANAPLL_CONTROLr_PLLFORCEVCODONE_ENf_GET(r) ((((r).anapll_control[0]) >> 4) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_CONTROLr_PLLFORCEVCODONE_ENf_SET(r,f) (r).anapll_control[0]=(((r).anapll_control[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCMI_TSC_XGXS_ANAPLL_CONTROLr_PLLFORCEVCODONEf_GET(r) ((((r).anapll_control[0]) >> 3) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_CONTROLr_PLLFORCEVCODONEf_SET(r,f) (r).anapll_control[0]=(((r).anapll_control[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCMI_TSC_XGXS_ANAPLL_CONTROLr_PLLFORCEVCOPASS_ENf_GET(r) ((((r).anapll_control[0]) >> 2) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_CONTROLr_PLLFORCEVCOPASS_ENf_SET(r,f) (r).anapll_control[0]=(((r).anapll_control[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCMI_TSC_XGXS_ANAPLL_CONTROLr_PLLFORCEVCOPASSf_GET(r) ((((r).anapll_control[0]) >> 1) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_CONTROLr_PLLFORCEVCOPASSf_SET(r,f) (r).anapll_control[0]=(((r).anapll_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCMI_TSC_XGXS_ANAPLL_CONTROLr_PLLFORCEPLLLOCKf_GET(r) (((r).anapll_control[0]) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_CONTROLr_PLLFORCEPLLLOCKf_SET(r,f) (r).anapll_control[0]=(((r).anapll_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access ANAPLL_CONTROL.
 *
 */
#define BCMI_TSC_XGXS_READ_ANAPLL_CONTROLr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_ANAPLL_CONTROLr,(_r._anapll_control))
#define BCMI_TSC_XGXS_WRITE_ANAPLL_CONTROLr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_ANAPLL_CONTROLr,(_r._anapll_control))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define ANAPLL_CONTROLr BCMI_TSC_XGXS_ANAPLL_CONTROLr
#define ANAPLL_CONTROLr_SIZE BCMI_TSC_XGXS_ANAPLL_CONTROLr_SIZE
typedef BCMI_TSC_XGXS_ANAPLL_CONTROLr_t ANAPLL_CONTROLr_t;
#define ANAPLL_CONTROLr_CLR BCMI_TSC_XGXS_ANAPLL_CONTROLr_CLR
#define ANAPLL_CONTROLr_SET BCMI_TSC_XGXS_ANAPLL_CONTROLr_SET
#define ANAPLL_CONTROLr_GET BCMI_TSC_XGXS_ANAPLL_CONTROLr_GET
#define ANAPLL_CONTROLr_RESERVED0f_GET BCMI_TSC_XGXS_ANAPLL_CONTROLr_RESERVED0f_GET
#define ANAPLL_CONTROLr_RESERVED0f_SET BCMI_TSC_XGXS_ANAPLL_CONTROLr_RESERVED0f_SET
#define ANAPLL_CONTROLr_FREQDETRETRY_ENf_GET BCMI_TSC_XGXS_ANAPLL_CONTROLr_FREQDETRETRY_ENf_GET
#define ANAPLL_CONTROLr_FREQDETRETRY_ENf_SET BCMI_TSC_XGXS_ANAPLL_CONTROLr_FREQDETRETRY_ENf_SET
#define ANAPLL_CONTROLr_FREQDETRESTART_ENf_GET BCMI_TSC_XGXS_ANAPLL_CONTROLr_FREQDETRESTART_ENf_GET
#define ANAPLL_CONTROLr_FREQDETRESTART_ENf_SET BCMI_TSC_XGXS_ANAPLL_CONTROLr_FREQDETRESTART_ENf_SET
#define ANAPLL_CONTROLr_FREQMONITOR_ENf_GET BCMI_TSC_XGXS_ANAPLL_CONTROLr_FREQMONITOR_ENf_GET
#define ANAPLL_CONTROLr_FREQMONITOR_ENf_SET BCMI_TSC_XGXS_ANAPLL_CONTROLr_FREQMONITOR_ENf_SET
#define ANAPLL_CONTROLr_VCOPRETRY_ENf_GET BCMI_TSC_XGXS_ANAPLL_CONTROLr_VCOPRETRY_ENf_GET
#define ANAPLL_CONTROLr_VCOPRETRY_ENf_SET BCMI_TSC_XGXS_ANAPLL_CONTROLr_VCOPRETRY_ENf_SET
#define ANAPLL_CONTROLr_VCODONE_ENf_GET BCMI_TSC_XGXS_ANAPLL_CONTROLr_VCODONE_ENf_GET
#define ANAPLL_CONTROLr_VCODONE_ENf_SET BCMI_TSC_XGXS_ANAPLL_CONTROLr_VCODONE_ENf_SET
#define ANAPLL_CONTROLr_LINKRESTART_ENf_GET BCMI_TSC_XGXS_ANAPLL_CONTROLr_LINKRESTART_ENf_GET
#define ANAPLL_CONTROLr_LINKRESTART_ENf_SET BCMI_TSC_XGXS_ANAPLL_CONTROLr_LINKRESTART_ENf_SET
#define ANAPLL_CONTROLr_BYTESYNCRESTART_ENf_GET BCMI_TSC_XGXS_ANAPLL_CONTROLr_BYTESYNCRESTART_ENf_GET
#define ANAPLL_CONTROLr_BYTESYNCRESTART_ENf_SET BCMI_TSC_XGXS_ANAPLL_CONTROLr_BYTESYNCRESTART_ENf_SET
#define ANAPLL_CONTROLr_PLLFORCEDONE_ENf_GET BCMI_TSC_XGXS_ANAPLL_CONTROLr_PLLFORCEDONE_ENf_GET
#define ANAPLL_CONTROLr_PLLFORCEDONE_ENf_SET BCMI_TSC_XGXS_ANAPLL_CONTROLr_PLLFORCEDONE_ENf_SET
#define ANAPLL_CONTROLr_PLLFORCEDONEf_GET BCMI_TSC_XGXS_ANAPLL_CONTROLr_PLLFORCEDONEf_GET
#define ANAPLL_CONTROLr_PLLFORCEDONEf_SET BCMI_TSC_XGXS_ANAPLL_CONTROLr_PLLFORCEDONEf_SET
#define ANAPLL_CONTROLr_PLLFORCEPASSf_GET BCMI_TSC_XGXS_ANAPLL_CONTROLr_PLLFORCEPASSf_GET
#define ANAPLL_CONTROLr_PLLFORCEPASSf_SET BCMI_TSC_XGXS_ANAPLL_CONTROLr_PLLFORCEPASSf_SET
#define ANAPLL_CONTROLr_PLLFORCEVCODONE_ENf_GET BCMI_TSC_XGXS_ANAPLL_CONTROLr_PLLFORCEVCODONE_ENf_GET
#define ANAPLL_CONTROLr_PLLFORCEVCODONE_ENf_SET BCMI_TSC_XGXS_ANAPLL_CONTROLr_PLLFORCEVCODONE_ENf_SET
#define ANAPLL_CONTROLr_PLLFORCEVCODONEf_GET BCMI_TSC_XGXS_ANAPLL_CONTROLr_PLLFORCEVCODONEf_GET
#define ANAPLL_CONTROLr_PLLFORCEVCODONEf_SET BCMI_TSC_XGXS_ANAPLL_CONTROLr_PLLFORCEVCODONEf_SET
#define ANAPLL_CONTROLr_PLLFORCEVCOPASS_ENf_GET BCMI_TSC_XGXS_ANAPLL_CONTROLr_PLLFORCEVCOPASS_ENf_GET
#define ANAPLL_CONTROLr_PLLFORCEVCOPASS_ENf_SET BCMI_TSC_XGXS_ANAPLL_CONTROLr_PLLFORCEVCOPASS_ENf_SET
#define ANAPLL_CONTROLr_PLLFORCEVCOPASSf_GET BCMI_TSC_XGXS_ANAPLL_CONTROLr_PLLFORCEVCOPASSf_GET
#define ANAPLL_CONTROLr_PLLFORCEVCOPASSf_SET BCMI_TSC_XGXS_ANAPLL_CONTROLr_PLLFORCEVCOPASSf_SET
#define ANAPLL_CONTROLr_PLLFORCEPLLLOCKf_GET BCMI_TSC_XGXS_ANAPLL_CONTROLr_PLLFORCEPLLLOCKf_GET
#define ANAPLL_CONTROLr_PLLFORCEPLLLOCKf_SET BCMI_TSC_XGXS_ANAPLL_CONTROLr_PLLFORCEPLLLOCKf_SET
#define READ_ANAPLL_CONTROLr BCMI_TSC_XGXS_READ_ANAPLL_CONTROLr
#define WRITE_ANAPLL_CONTROLr BCMI_TSC_XGXS_WRITE_ANAPLL_CONTROLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_ANAPLL_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  ANAPLL_TIMER1
 * BLOCKS:   ANAPLL
 * REGADDR:  0x9012
 * DESC:     PLL start up state machine vco timers: 00000000
 * SIZE:     32
 * FIELDS:
 *     VCOSTARTTIME     
 *     VCOSTEPTIME      
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_ANAPLL_TIMER1r (0x00109012 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_ANAPLL_TIMER1r_SIZE 4

/*
 * This structure should be used to declare and program ANAPLL_TIMER1.
 *
 */
typedef union BCMI_TSC_XGXS_ANAPLL_TIMER1r_s {
	uint32_t v[1];
	uint32_t anapll_timer1[1];
	uint32_t _anapll_timer1;
} BCMI_TSC_XGXS_ANAPLL_TIMER1r_t;

#define BCMI_TSC_XGXS_ANAPLL_TIMER1r_CLR(r) (r).anapll_timer1[0] = 0
#define BCMI_TSC_XGXS_ANAPLL_TIMER1r_SET(r,d) (r).anapll_timer1[0] = d
#define BCMI_TSC_XGXS_ANAPLL_TIMER1r_GET(r) (r).anapll_timer1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_ANAPLL_TIMER1r_VCOSTEPTIMEf_GET(r) ((((r).anapll_timer1[0]) >> 8) & 0xff)
#define BCMI_TSC_XGXS_ANAPLL_TIMER1r_VCOSTEPTIMEf_SET(r,f) (r).anapll_timer1[0]=(((r).anapll_timer1[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCMI_TSC_XGXS_ANAPLL_TIMER1r_VCOSTARTTIMEf_GET(r) (((r).anapll_timer1[0]) & 0xff)
#define BCMI_TSC_XGXS_ANAPLL_TIMER1r_VCOSTARTTIMEf_SET(r,f) (r).anapll_timer1[0]=(((r).anapll_timer1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access ANAPLL_TIMER1.
 *
 */
#define BCMI_TSC_XGXS_READ_ANAPLL_TIMER1r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_ANAPLL_TIMER1r,(_r._anapll_timer1))
#define BCMI_TSC_XGXS_WRITE_ANAPLL_TIMER1r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_ANAPLL_TIMER1r,(_r._anapll_timer1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define ANAPLL_TIMER1r BCMI_TSC_XGXS_ANAPLL_TIMER1r
#define ANAPLL_TIMER1r_SIZE BCMI_TSC_XGXS_ANAPLL_TIMER1r_SIZE
typedef BCMI_TSC_XGXS_ANAPLL_TIMER1r_t ANAPLL_TIMER1r_t;
#define ANAPLL_TIMER1r_CLR BCMI_TSC_XGXS_ANAPLL_TIMER1r_CLR
#define ANAPLL_TIMER1r_SET BCMI_TSC_XGXS_ANAPLL_TIMER1r_SET
#define ANAPLL_TIMER1r_GET BCMI_TSC_XGXS_ANAPLL_TIMER1r_GET
#define ANAPLL_TIMER1r_VCOSTEPTIMEf_GET BCMI_TSC_XGXS_ANAPLL_TIMER1r_VCOSTEPTIMEf_GET
#define ANAPLL_TIMER1r_VCOSTEPTIMEf_SET BCMI_TSC_XGXS_ANAPLL_TIMER1r_VCOSTEPTIMEf_SET
#define ANAPLL_TIMER1r_VCOSTARTTIMEf_GET BCMI_TSC_XGXS_ANAPLL_TIMER1r_VCOSTARTTIMEf_GET
#define ANAPLL_TIMER1r_VCOSTARTTIMEf_SET BCMI_TSC_XGXS_ANAPLL_TIMER1r_VCOSTARTTIMEf_SET
#define READ_ANAPLL_TIMER1r BCMI_TSC_XGXS_READ_ANAPLL_TIMER1r
#define WRITE_ANAPLL_TIMER1r BCMI_TSC_XGXS_WRITE_ANAPLL_TIMER1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_ANAPLL_TIMER1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  ANAPLL_TIMER2
 * BLOCKS:   ANAPLL
 * REGADDR:  0x9013
 * DESC:     PLL start up state machine retry timer: 00000000
 * SIZE:     32
 * FIELDS:
 *     RETRYTIME        
 *     TESTMUXSEL       
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_ANAPLL_TIMER2r (0x00109013 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_ANAPLL_TIMER2r_SIZE 4

/*
 * This structure should be used to declare and program ANAPLL_TIMER2.
 *
 */
typedef union BCMI_TSC_XGXS_ANAPLL_TIMER2r_s {
	uint32_t v[1];
	uint32_t anapll_timer2[1];
	uint32_t _anapll_timer2;
} BCMI_TSC_XGXS_ANAPLL_TIMER2r_t;

#define BCMI_TSC_XGXS_ANAPLL_TIMER2r_CLR(r) (r).anapll_timer2[0] = 0
#define BCMI_TSC_XGXS_ANAPLL_TIMER2r_SET(r,d) (r).anapll_timer2[0] = d
#define BCMI_TSC_XGXS_ANAPLL_TIMER2r_GET(r) (r).anapll_timer2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_ANAPLL_TIMER2r_RESERVED0f_GET(r) ((((r).anapll_timer2[0]) >> 13) & 0x7)
#define BCMI_TSC_XGXS_ANAPLL_TIMER2r_RESERVED0f_SET(r,f) (r).anapll_timer2[0]=(((r).anapll_timer2[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))
#define BCMI_TSC_XGXS_ANAPLL_TIMER2r_TESTMUXSELf_GET(r) ((((r).anapll_timer2[0]) >> 8) & 0x1f)
#define BCMI_TSC_XGXS_ANAPLL_TIMER2r_TESTMUXSELf_SET(r,f) (r).anapll_timer2[0]=(((r).anapll_timer2[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCMI_TSC_XGXS_ANAPLL_TIMER2r_RETRYTIMEf_GET(r) (((r).anapll_timer2[0]) & 0xff)
#define BCMI_TSC_XGXS_ANAPLL_TIMER2r_RETRYTIMEf_SET(r,f) (r).anapll_timer2[0]=(((r).anapll_timer2[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access ANAPLL_TIMER2.
 *
 */
#define BCMI_TSC_XGXS_READ_ANAPLL_TIMER2r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_ANAPLL_TIMER2r,(_r._anapll_timer2))
#define BCMI_TSC_XGXS_WRITE_ANAPLL_TIMER2r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_ANAPLL_TIMER2r,(_r._anapll_timer2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define ANAPLL_TIMER2r BCMI_TSC_XGXS_ANAPLL_TIMER2r
#define ANAPLL_TIMER2r_SIZE BCMI_TSC_XGXS_ANAPLL_TIMER2r_SIZE
typedef BCMI_TSC_XGXS_ANAPLL_TIMER2r_t ANAPLL_TIMER2r_t;
#define ANAPLL_TIMER2r_CLR BCMI_TSC_XGXS_ANAPLL_TIMER2r_CLR
#define ANAPLL_TIMER2r_SET BCMI_TSC_XGXS_ANAPLL_TIMER2r_SET
#define ANAPLL_TIMER2r_GET BCMI_TSC_XGXS_ANAPLL_TIMER2r_GET
#define ANAPLL_TIMER2r_RESERVED0f_GET BCMI_TSC_XGXS_ANAPLL_TIMER2r_RESERVED0f_GET
#define ANAPLL_TIMER2r_RESERVED0f_SET BCMI_TSC_XGXS_ANAPLL_TIMER2r_RESERVED0f_SET
#define ANAPLL_TIMER2r_TESTMUXSELf_GET BCMI_TSC_XGXS_ANAPLL_TIMER2r_TESTMUXSELf_GET
#define ANAPLL_TIMER2r_TESTMUXSELf_SET BCMI_TSC_XGXS_ANAPLL_TIMER2r_TESTMUXSELf_SET
#define ANAPLL_TIMER2r_RETRYTIMEf_GET BCMI_TSC_XGXS_ANAPLL_TIMER2r_RETRYTIMEf_GET
#define ANAPLL_TIMER2r_RETRYTIMEf_SET BCMI_TSC_XGXS_ANAPLL_TIMER2r_RETRYTIMEf_SET
#define READ_ANAPLL_TIMER2r BCMI_TSC_XGXS_READ_ANAPLL_TIMER2r
#define WRITE_ANAPLL_TIMER2r BCMI_TSC_XGXS_WRITE_ANAPLL_TIMER2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_ANAPLL_TIMER2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  ANAPLL_TIMER3
 * BLOCKS:   ANAPLL
 * REGADDR:  0x9014
 * DESC:     PLL start up state machine freq. detect timer: 00000000
 * SIZE:     32
 * FIELDS:
 *     FREQDETTIME      
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_ANAPLL_TIMER3r (0x00109014 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_ANAPLL_TIMER3r_SIZE 4

/*
 * This structure should be used to declare and program ANAPLL_TIMER3.
 *
 */
typedef union BCMI_TSC_XGXS_ANAPLL_TIMER3r_s {
	uint32_t v[1];
	uint32_t anapll_timer3[1];
	uint32_t _anapll_timer3;
} BCMI_TSC_XGXS_ANAPLL_TIMER3r_t;

#define BCMI_TSC_XGXS_ANAPLL_TIMER3r_CLR(r) (r).anapll_timer3[0] = 0
#define BCMI_TSC_XGXS_ANAPLL_TIMER3r_SET(r,d) (r).anapll_timer3[0] = d
#define BCMI_TSC_XGXS_ANAPLL_TIMER3r_GET(r) (r).anapll_timer3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_ANAPLL_TIMER3r_RESERVED0f_GET(r) ((((r).anapll_timer3[0]) >> 8) & 0xff)
#define BCMI_TSC_XGXS_ANAPLL_TIMER3r_RESERVED0f_SET(r,f) (r).anapll_timer3[0]=(((r).anapll_timer3[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCMI_TSC_XGXS_ANAPLL_TIMER3r_FREQDETTIMEf_GET(r) (((r).anapll_timer3[0]) & 0xff)
#define BCMI_TSC_XGXS_ANAPLL_TIMER3r_FREQDETTIMEf_SET(r,f) (r).anapll_timer3[0]=(((r).anapll_timer3[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access ANAPLL_TIMER3.
 *
 */
#define BCMI_TSC_XGXS_READ_ANAPLL_TIMER3r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_ANAPLL_TIMER3r,(_r._anapll_timer3))
#define BCMI_TSC_XGXS_WRITE_ANAPLL_TIMER3r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_ANAPLL_TIMER3r,(_r._anapll_timer3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define ANAPLL_TIMER3r BCMI_TSC_XGXS_ANAPLL_TIMER3r
#define ANAPLL_TIMER3r_SIZE BCMI_TSC_XGXS_ANAPLL_TIMER3r_SIZE
typedef BCMI_TSC_XGXS_ANAPLL_TIMER3r_t ANAPLL_TIMER3r_t;
#define ANAPLL_TIMER3r_CLR BCMI_TSC_XGXS_ANAPLL_TIMER3r_CLR
#define ANAPLL_TIMER3r_SET BCMI_TSC_XGXS_ANAPLL_TIMER3r_SET
#define ANAPLL_TIMER3r_GET BCMI_TSC_XGXS_ANAPLL_TIMER3r_GET
#define ANAPLL_TIMER3r_RESERVED0f_GET BCMI_TSC_XGXS_ANAPLL_TIMER3r_RESERVED0f_GET
#define ANAPLL_TIMER3r_RESERVED0f_SET BCMI_TSC_XGXS_ANAPLL_TIMER3r_RESERVED0f_SET
#define ANAPLL_TIMER3r_FREQDETTIMEf_GET BCMI_TSC_XGXS_ANAPLL_TIMER3r_FREQDETTIMEf_GET
#define ANAPLL_TIMER3r_FREQDETTIMEf_SET BCMI_TSC_XGXS_ANAPLL_TIMER3r_FREQDETTIMEf_SET
#define READ_ANAPLL_TIMER3r BCMI_TSC_XGXS_READ_ANAPLL_TIMER3r
#define WRITE_ANAPLL_TIMER3r BCMI_TSC_XGXS_WRITE_ANAPLL_TIMER3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_ANAPLL_TIMER3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  ANAPLL_CAPCONTROL
 * BLOCKS:   ANAPLL
 * REGADDR:  0x9015
 * DESC:     PLL vco range control state machine: 00000000
 * SIZE:     32
 * FIELDS:
 *     VCOSELECTM       
 *     VCOFORCESLOWDOWN 
 *     SLOWDN_XOR       
 *     VCOCNTMASK_EN    
 *     VCORSTEN         
 *     VCOFORCESLOWDN_EN 
 *     VCOSELECTM_EN    
 *     VCORESTART       
 *     VCOSEQCYA        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_ANAPLL_CAPCONTROLr (0x00109015 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_ANAPLL_CAPCONTROLr_SIZE 4

/*
 * This structure should be used to declare and program ANAPLL_CAPCONTROL.
 *
 */
typedef union BCMI_TSC_XGXS_ANAPLL_CAPCONTROLr_s {
	uint32_t v[1];
	uint32_t anapll_capcontrol[1];
	uint32_t _anapll_capcontrol;
} BCMI_TSC_XGXS_ANAPLL_CAPCONTROLr_t;

#define BCMI_TSC_XGXS_ANAPLL_CAPCONTROLr_CLR(r) (r).anapll_capcontrol[0] = 0
#define BCMI_TSC_XGXS_ANAPLL_CAPCONTROLr_SET(r,d) (r).anapll_capcontrol[0] = d
#define BCMI_TSC_XGXS_ANAPLL_CAPCONTROLr_GET(r) (r).anapll_capcontrol[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_ANAPLL_CAPCONTROLr_VCOSEQCYAf_GET(r) ((((r).anapll_capcontrol[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_CAPCONTROLr_VCOSEQCYAf_SET(r,f) (r).anapll_capcontrol[0]=(((r).anapll_capcontrol[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_ANAPLL_CAPCONTROLr_VCORESTARTf_GET(r) ((((r).anapll_capcontrol[0]) >> 14) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_CAPCONTROLr_VCORESTARTf_SET(r,f) (r).anapll_capcontrol[0]=(((r).anapll_capcontrol[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCMI_TSC_XGXS_ANAPLL_CAPCONTROLr_VCOSELECTM_ENf_GET(r) ((((r).anapll_capcontrol[0]) >> 13) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_CAPCONTROLr_VCOSELECTM_ENf_SET(r,f) (r).anapll_capcontrol[0]=(((r).anapll_capcontrol[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCMI_TSC_XGXS_ANAPLL_CAPCONTROLr_VCOFORCESLOWDN_ENf_GET(r) ((((r).anapll_capcontrol[0]) >> 12) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_CAPCONTROLr_VCOFORCESLOWDN_ENf_SET(r,f) (r).anapll_capcontrol[0]=(((r).anapll_capcontrol[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCMI_TSC_XGXS_ANAPLL_CAPCONTROLr_VCORSTENf_GET(r) ((((r).anapll_capcontrol[0]) >> 11) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_CAPCONTROLr_VCORSTENf_SET(r,f) (r).anapll_capcontrol[0]=(((r).anapll_capcontrol[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCMI_TSC_XGXS_ANAPLL_CAPCONTROLr_VCOCNTMASK_ENf_GET(r) ((((r).anapll_capcontrol[0]) >> 10) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_CAPCONTROLr_VCOCNTMASK_ENf_SET(r,f) (r).anapll_capcontrol[0]=(((r).anapll_capcontrol[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCMI_TSC_XGXS_ANAPLL_CAPCONTROLr_SLOWDN_XORf_GET(r) ((((r).anapll_capcontrol[0]) >> 9) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_CAPCONTROLr_SLOWDN_XORf_SET(r,f) (r).anapll_capcontrol[0]=(((r).anapll_capcontrol[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCMI_TSC_XGXS_ANAPLL_CAPCONTROLr_VCOFORCESLOWDOWNf_GET(r) ((((r).anapll_capcontrol[0]) >> 8) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_CAPCONTROLr_VCOFORCESLOWDOWNf_SET(r,f) (r).anapll_capcontrol[0]=(((r).anapll_capcontrol[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCMI_TSC_XGXS_ANAPLL_CAPCONTROLr_VCOSELECTMf_GET(r) (((r).anapll_capcontrol[0]) & 0xff)
#define BCMI_TSC_XGXS_ANAPLL_CAPCONTROLr_VCOSELECTMf_SET(r,f) (r).anapll_capcontrol[0]=(((r).anapll_capcontrol[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access ANAPLL_CAPCONTROL.
 *
 */
#define BCMI_TSC_XGXS_READ_ANAPLL_CAPCONTROLr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_ANAPLL_CAPCONTROLr,(_r._anapll_capcontrol))
#define BCMI_TSC_XGXS_WRITE_ANAPLL_CAPCONTROLr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_ANAPLL_CAPCONTROLr,(_r._anapll_capcontrol))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define ANAPLL_CAPCONTROLr BCMI_TSC_XGXS_ANAPLL_CAPCONTROLr
#define ANAPLL_CAPCONTROLr_SIZE BCMI_TSC_XGXS_ANAPLL_CAPCONTROLr_SIZE
typedef BCMI_TSC_XGXS_ANAPLL_CAPCONTROLr_t ANAPLL_CAPCONTROLr_t;
#define ANAPLL_CAPCONTROLr_CLR BCMI_TSC_XGXS_ANAPLL_CAPCONTROLr_CLR
#define ANAPLL_CAPCONTROLr_SET BCMI_TSC_XGXS_ANAPLL_CAPCONTROLr_SET
#define ANAPLL_CAPCONTROLr_GET BCMI_TSC_XGXS_ANAPLL_CAPCONTROLr_GET
#define ANAPLL_CAPCONTROLr_VCOSEQCYAf_GET BCMI_TSC_XGXS_ANAPLL_CAPCONTROLr_VCOSEQCYAf_GET
#define ANAPLL_CAPCONTROLr_VCOSEQCYAf_SET BCMI_TSC_XGXS_ANAPLL_CAPCONTROLr_VCOSEQCYAf_SET
#define ANAPLL_CAPCONTROLr_VCORESTARTf_GET BCMI_TSC_XGXS_ANAPLL_CAPCONTROLr_VCORESTARTf_GET
#define ANAPLL_CAPCONTROLr_VCORESTARTf_SET BCMI_TSC_XGXS_ANAPLL_CAPCONTROLr_VCORESTARTf_SET
#define ANAPLL_CAPCONTROLr_VCOSELECTM_ENf_GET BCMI_TSC_XGXS_ANAPLL_CAPCONTROLr_VCOSELECTM_ENf_GET
#define ANAPLL_CAPCONTROLr_VCOSELECTM_ENf_SET BCMI_TSC_XGXS_ANAPLL_CAPCONTROLr_VCOSELECTM_ENf_SET
#define ANAPLL_CAPCONTROLr_VCOFORCESLOWDN_ENf_GET BCMI_TSC_XGXS_ANAPLL_CAPCONTROLr_VCOFORCESLOWDN_ENf_GET
#define ANAPLL_CAPCONTROLr_VCOFORCESLOWDN_ENf_SET BCMI_TSC_XGXS_ANAPLL_CAPCONTROLr_VCOFORCESLOWDN_ENf_SET
#define ANAPLL_CAPCONTROLr_VCORSTENf_GET BCMI_TSC_XGXS_ANAPLL_CAPCONTROLr_VCORSTENf_GET
#define ANAPLL_CAPCONTROLr_VCORSTENf_SET BCMI_TSC_XGXS_ANAPLL_CAPCONTROLr_VCORSTENf_SET
#define ANAPLL_CAPCONTROLr_VCOCNTMASK_ENf_GET BCMI_TSC_XGXS_ANAPLL_CAPCONTROLr_VCOCNTMASK_ENf_GET
#define ANAPLL_CAPCONTROLr_VCOCNTMASK_ENf_SET BCMI_TSC_XGXS_ANAPLL_CAPCONTROLr_VCOCNTMASK_ENf_SET
#define ANAPLL_CAPCONTROLr_SLOWDN_XORf_GET BCMI_TSC_XGXS_ANAPLL_CAPCONTROLr_SLOWDN_XORf_GET
#define ANAPLL_CAPCONTROLr_SLOWDN_XORf_SET BCMI_TSC_XGXS_ANAPLL_CAPCONTROLr_SLOWDN_XORf_SET
#define ANAPLL_CAPCONTROLr_VCOFORCESLOWDOWNf_GET BCMI_TSC_XGXS_ANAPLL_CAPCONTROLr_VCOFORCESLOWDOWNf_GET
#define ANAPLL_CAPCONTROLr_VCOFORCESLOWDOWNf_SET BCMI_TSC_XGXS_ANAPLL_CAPCONTROLr_VCOFORCESLOWDOWNf_SET
#define ANAPLL_CAPCONTROLr_VCOSELECTMf_GET BCMI_TSC_XGXS_ANAPLL_CAPCONTROLr_VCOSELECTMf_GET
#define ANAPLL_CAPCONTROLr_VCOSELECTMf_SET BCMI_TSC_XGXS_ANAPLL_CAPCONTROLr_VCOSELECTMf_SET
#define READ_ANAPLL_CAPCONTROLr BCMI_TSC_XGXS_READ_ANAPLL_CAPCONTROLr
#define WRITE_ANAPLL_CAPCONTROLr BCMI_TSC_XGXS_WRITE_ANAPLL_CAPCONTROLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_ANAPLL_CAPCONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  ANAPLL_DEBUG_STATUS
 * BLOCKS:   ANAPLL
 * REGADDR:  0x9016
 * DESC:     Debug status testmux bus: 00000000
 * SIZE:     32
 * FIELDS:
 *     TX_PLL_TMUX      
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_ANAPLL_DEBUG_STATUSr (0x00109016 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_ANAPLL_DEBUG_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program ANAPLL_DEBUG_STATUS.
 *
 */
typedef union BCMI_TSC_XGXS_ANAPLL_DEBUG_STATUSr_s {
	uint32_t v[1];
	uint32_t anapll_debug_status[1];
	uint32_t _anapll_debug_status;
} BCMI_TSC_XGXS_ANAPLL_DEBUG_STATUSr_t;

#define BCMI_TSC_XGXS_ANAPLL_DEBUG_STATUSr_CLR(r) (r).anapll_debug_status[0] = 0
#define BCMI_TSC_XGXS_ANAPLL_DEBUG_STATUSr_SET(r,d) (r).anapll_debug_status[0] = d
#define BCMI_TSC_XGXS_ANAPLL_DEBUG_STATUSr_GET(r) (r).anapll_debug_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_ANAPLL_DEBUG_STATUSr_RESERVED0f_GET(r) ((((r).anapll_debug_status[0]) >> 8) & 0xff)
#define BCMI_TSC_XGXS_ANAPLL_DEBUG_STATUSr_RESERVED0f_SET(r,f) (r).anapll_debug_status[0]=(((r).anapll_debug_status[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCMI_TSC_XGXS_ANAPLL_DEBUG_STATUSr_TX_PLL_TMUXf_GET(r) (((r).anapll_debug_status[0]) & 0xff)
#define BCMI_TSC_XGXS_ANAPLL_DEBUG_STATUSr_TX_PLL_TMUXf_SET(r,f) (r).anapll_debug_status[0]=(((r).anapll_debug_status[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access ANAPLL_DEBUG_STATUS.
 *
 */
#define BCMI_TSC_XGXS_READ_ANAPLL_DEBUG_STATUSr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_ANAPLL_DEBUG_STATUSr,(_r._anapll_debug_status))
#define BCMI_TSC_XGXS_WRITE_ANAPLL_DEBUG_STATUSr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_ANAPLL_DEBUG_STATUSr,(_r._anapll_debug_status))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define ANAPLL_DEBUG_STATUSr BCMI_TSC_XGXS_ANAPLL_DEBUG_STATUSr
#define ANAPLL_DEBUG_STATUSr_SIZE BCMI_TSC_XGXS_ANAPLL_DEBUG_STATUSr_SIZE
typedef BCMI_TSC_XGXS_ANAPLL_DEBUG_STATUSr_t ANAPLL_DEBUG_STATUSr_t;
#define ANAPLL_DEBUG_STATUSr_CLR BCMI_TSC_XGXS_ANAPLL_DEBUG_STATUSr_CLR
#define ANAPLL_DEBUG_STATUSr_SET BCMI_TSC_XGXS_ANAPLL_DEBUG_STATUSr_SET
#define ANAPLL_DEBUG_STATUSr_GET BCMI_TSC_XGXS_ANAPLL_DEBUG_STATUSr_GET
#define ANAPLL_DEBUG_STATUSr_RESERVED0f_GET BCMI_TSC_XGXS_ANAPLL_DEBUG_STATUSr_RESERVED0f_GET
#define ANAPLL_DEBUG_STATUSr_RESERVED0f_SET BCMI_TSC_XGXS_ANAPLL_DEBUG_STATUSr_RESERVED0f_SET
#define ANAPLL_DEBUG_STATUSr_TX_PLL_TMUXf_GET BCMI_TSC_XGXS_ANAPLL_DEBUG_STATUSr_TX_PLL_TMUXf_GET
#define ANAPLL_DEBUG_STATUSr_TX_PLL_TMUXf_SET BCMI_TSC_XGXS_ANAPLL_DEBUG_STATUSr_TX_PLL_TMUXf_SET
#define READ_ANAPLL_DEBUG_STATUSr BCMI_TSC_XGXS_READ_ANAPLL_DEBUG_STATUSr
#define WRITE_ANAPLL_DEBUG_STATUSr BCMI_TSC_XGXS_WRITE_ANAPLL_DEBUG_STATUSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_ANAPLL_DEBUG_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  ANAPLL_FREQDETCNTR
 * BLOCKS:   ANAPLL
 * REGADDR:  0x9017
 * DESC:     Frequency detector control: 00000000
 * SIZE:     32
 * FIELDS:
 *     WINDOW           
 *     RESOLUTION       
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_ANAPLL_FREQDETCNTRr (0x00109017 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_ANAPLL_FREQDETCNTRr_SIZE 4

/*
 * This structure should be used to declare and program ANAPLL_FREQDETCNTR.
 *
 */
typedef union BCMI_TSC_XGXS_ANAPLL_FREQDETCNTRr_s {
	uint32_t v[1];
	uint32_t anapll_freqdetcntr[1];
	uint32_t _anapll_freqdetcntr;
} BCMI_TSC_XGXS_ANAPLL_FREQDETCNTRr_t;

#define BCMI_TSC_XGXS_ANAPLL_FREQDETCNTRr_CLR(r) (r).anapll_freqdetcntr[0] = 0
#define BCMI_TSC_XGXS_ANAPLL_FREQDETCNTRr_SET(r,d) (r).anapll_freqdetcntr[0] = d
#define BCMI_TSC_XGXS_ANAPLL_FREQDETCNTRr_GET(r) (r).anapll_freqdetcntr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_ANAPLL_FREQDETCNTRr_RESOLUTIONf_GET(r) ((((r).anapll_freqdetcntr[0]) >> 8) & 0xff)
#define BCMI_TSC_XGXS_ANAPLL_FREQDETCNTRr_RESOLUTIONf_SET(r,f) (r).anapll_freqdetcntr[0]=(((r).anapll_freqdetcntr[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCMI_TSC_XGXS_ANAPLL_FREQDETCNTRr_WINDOWf_GET(r) (((r).anapll_freqdetcntr[0]) & 0xff)
#define BCMI_TSC_XGXS_ANAPLL_FREQDETCNTRr_WINDOWf_SET(r,f) (r).anapll_freqdetcntr[0]=(((r).anapll_freqdetcntr[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access ANAPLL_FREQDETCNTR.
 *
 */
#define BCMI_TSC_XGXS_READ_ANAPLL_FREQDETCNTRr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_ANAPLL_FREQDETCNTRr,(_r._anapll_freqdetcntr))
#define BCMI_TSC_XGXS_WRITE_ANAPLL_FREQDETCNTRr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_ANAPLL_FREQDETCNTRr,(_r._anapll_freqdetcntr))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define ANAPLL_FREQDETCNTRr BCMI_TSC_XGXS_ANAPLL_FREQDETCNTRr
#define ANAPLL_FREQDETCNTRr_SIZE BCMI_TSC_XGXS_ANAPLL_FREQDETCNTRr_SIZE
typedef BCMI_TSC_XGXS_ANAPLL_FREQDETCNTRr_t ANAPLL_FREQDETCNTRr_t;
#define ANAPLL_FREQDETCNTRr_CLR BCMI_TSC_XGXS_ANAPLL_FREQDETCNTRr_CLR
#define ANAPLL_FREQDETCNTRr_SET BCMI_TSC_XGXS_ANAPLL_FREQDETCNTRr_SET
#define ANAPLL_FREQDETCNTRr_GET BCMI_TSC_XGXS_ANAPLL_FREQDETCNTRr_GET
#define ANAPLL_FREQDETCNTRr_RESOLUTIONf_GET BCMI_TSC_XGXS_ANAPLL_FREQDETCNTRr_RESOLUTIONf_GET
#define ANAPLL_FREQDETCNTRr_RESOLUTIONf_SET BCMI_TSC_XGXS_ANAPLL_FREQDETCNTRr_RESOLUTIONf_SET
#define ANAPLL_FREQDETCNTRr_WINDOWf_GET BCMI_TSC_XGXS_ANAPLL_FREQDETCNTRr_WINDOWf_GET
#define ANAPLL_FREQDETCNTRr_WINDOWf_SET BCMI_TSC_XGXS_ANAPLL_FREQDETCNTRr_WINDOWf_SET
#define READ_ANAPLL_FREQDETCNTRr BCMI_TSC_XGXS_READ_ANAPLL_FREQDETCNTRr
#define WRITE_ANAPLL_FREQDETCNTRr BCMI_TSC_XGXS_WRITE_ANAPLL_FREQDETCNTRr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_ANAPLL_FREQDETCNTRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  ANAPLL_STATUS1
 * BLOCKS:   ANAPLL
 * REGADDR:  0x9018
 * DESC:     PLL analog status (AFE pll_sts[15:0], not applicable to XFICore): 00000000
 * SIZE:     32
 * FIELDS:
 *     PLL_NDIV         
 *     RESERVED0        
 *     PLL_LOW          
 *     PLL_RANGE        
 *     KVH              
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_ANAPLL_STATUS1r (0x00109018 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_ANAPLL_STATUS1r_SIZE 4

/*
 * This structure should be used to declare and program ANAPLL_STATUS1.
 *
 */
typedef union BCMI_TSC_XGXS_ANAPLL_STATUS1r_s {
	uint32_t v[1];
	uint32_t anapll_status1[1];
	uint32_t _anapll_status1;
} BCMI_TSC_XGXS_ANAPLL_STATUS1r_t;

#define BCMI_TSC_XGXS_ANAPLL_STATUS1r_CLR(r) (r).anapll_status1[0] = 0
#define BCMI_TSC_XGXS_ANAPLL_STATUS1r_SET(r,d) (r).anapll_status1[0] = d
#define BCMI_TSC_XGXS_ANAPLL_STATUS1r_GET(r) (r).anapll_status1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_ANAPLL_STATUS1r_KVHf_GET(r) ((((r).anapll_status1[0]) >> 14) & 0x3)
#define BCMI_TSC_XGXS_ANAPLL_STATUS1r_KVHf_SET(r,f) (r).anapll_status1[0]=(((r).anapll_status1[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCMI_TSC_XGXS_ANAPLL_STATUS1r_PLL_RANGEf_GET(r) ((((r).anapll_status1[0]) >> 6) & 0xff)
#define BCMI_TSC_XGXS_ANAPLL_STATUS1r_PLL_RANGEf_SET(r,f) (r).anapll_status1[0]=(((r).anapll_status1[0] & ~((uint32_t)0xff << 6)) | ((((uint32_t)f) & 0xff) << 6))
#define BCMI_TSC_XGXS_ANAPLL_STATUS1r_PLL_LOWf_GET(r) ((((r).anapll_status1[0]) >> 5) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_STATUS1r_PLL_LOWf_SET(r,f) (r).anapll_status1[0]=(((r).anapll_status1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCMI_TSC_XGXS_ANAPLL_STATUS1r_RESERVED0f_GET(r) ((((r).anapll_status1[0]) >> 4) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_STATUS1r_RESERVED0f_SET(r,f) (r).anapll_status1[0]=(((r).anapll_status1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCMI_TSC_XGXS_ANAPLL_STATUS1r_PLL_NDIVf_GET(r) (((r).anapll_status1[0]) & 0xf)
#define BCMI_TSC_XGXS_ANAPLL_STATUS1r_PLL_NDIVf_SET(r,f) (r).anapll_status1[0]=(((r).anapll_status1[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access ANAPLL_STATUS1.
 *
 */
#define BCMI_TSC_XGXS_READ_ANAPLL_STATUS1r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_ANAPLL_STATUS1r,(_r._anapll_status1))
#define BCMI_TSC_XGXS_WRITE_ANAPLL_STATUS1r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_ANAPLL_STATUS1r,(_r._anapll_status1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define ANAPLL_STATUS1r BCMI_TSC_XGXS_ANAPLL_STATUS1r
#define ANAPLL_STATUS1r_SIZE BCMI_TSC_XGXS_ANAPLL_STATUS1r_SIZE
typedef BCMI_TSC_XGXS_ANAPLL_STATUS1r_t ANAPLL_STATUS1r_t;
#define ANAPLL_STATUS1r_CLR BCMI_TSC_XGXS_ANAPLL_STATUS1r_CLR
#define ANAPLL_STATUS1r_SET BCMI_TSC_XGXS_ANAPLL_STATUS1r_SET
#define ANAPLL_STATUS1r_GET BCMI_TSC_XGXS_ANAPLL_STATUS1r_GET
#define ANAPLL_STATUS1r_KVHf_GET BCMI_TSC_XGXS_ANAPLL_STATUS1r_KVHf_GET
#define ANAPLL_STATUS1r_KVHf_SET BCMI_TSC_XGXS_ANAPLL_STATUS1r_KVHf_SET
#define ANAPLL_STATUS1r_PLL_RANGEf_GET BCMI_TSC_XGXS_ANAPLL_STATUS1r_PLL_RANGEf_GET
#define ANAPLL_STATUS1r_PLL_RANGEf_SET BCMI_TSC_XGXS_ANAPLL_STATUS1r_PLL_RANGEf_SET
#define ANAPLL_STATUS1r_PLL_LOWf_GET BCMI_TSC_XGXS_ANAPLL_STATUS1r_PLL_LOWf_GET
#define ANAPLL_STATUS1r_PLL_LOWf_SET BCMI_TSC_XGXS_ANAPLL_STATUS1r_PLL_LOWf_SET
#define ANAPLL_STATUS1r_RESERVED0f_GET BCMI_TSC_XGXS_ANAPLL_STATUS1r_RESERVED0f_GET
#define ANAPLL_STATUS1r_RESERVED0f_SET BCMI_TSC_XGXS_ANAPLL_STATUS1r_RESERVED0f_SET
#define ANAPLL_STATUS1r_PLL_NDIVf_GET BCMI_TSC_XGXS_ANAPLL_STATUS1r_PLL_NDIVf_GET
#define ANAPLL_STATUS1r_PLL_NDIVf_SET BCMI_TSC_XGXS_ANAPLL_STATUS1r_PLL_NDIVf_SET
#define READ_ANAPLL_STATUS1r BCMI_TSC_XGXS_READ_ANAPLL_STATUS1r
#define WRITE_ANAPLL_STATUS1r BCMI_TSC_XGXS_WRITE_ANAPLL_STATUS1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_ANAPLL_STATUS1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  ANAPLL_CONTROL0
 * BLOCKS:   ANAPLL
 * REGADDR:  0x901a
 * DESC:     PLL analog controls (AFE pll_clrl[15:00], not applicable to XFICore): 00000000
 * SIZE:     32
 * FIELDS:
 *     AMP_CTRL         
 *     VDDR_BGB         
 *     RESERVED0        
 *     ICLKDIV2         
 *     ICLKODRV2        
 *     ICLKODRV1        
 *     ICLKIDRV1        
 *     REFL_CLKGEN      
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_ANAPLL_CONTROL0r (0x0010901a | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_ANAPLL_CONTROL0r_SIZE 4

/*
 * This structure should be used to declare and program ANAPLL_CONTROL0.
 *
 */
typedef union BCMI_TSC_XGXS_ANAPLL_CONTROL0r_s {
	uint32_t v[1];
	uint32_t anapll_control0[1];
	uint32_t _anapll_control0;
} BCMI_TSC_XGXS_ANAPLL_CONTROL0r_t;

#define BCMI_TSC_XGXS_ANAPLL_CONTROL0r_CLR(r) (r).anapll_control0[0] = 0
#define BCMI_TSC_XGXS_ANAPLL_CONTROL0r_SET(r,d) (r).anapll_control0[0] = d
#define BCMI_TSC_XGXS_ANAPLL_CONTROL0r_GET(r) (r).anapll_control0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_ANAPLL_CONTROL0r_REFL_CLKGENf_GET(r) ((((r).anapll_control0[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_CONTROL0r_REFL_CLKGENf_SET(r,f) (r).anapll_control0[0]=(((r).anapll_control0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_ANAPLL_CONTROL0r_ICLKIDRV1f_GET(r) ((((r).anapll_control0[0]) >> 12) & 0x7)
#define BCMI_TSC_XGXS_ANAPLL_CONTROL0r_ICLKIDRV1f_SET(r,f) (r).anapll_control0[0]=(((r).anapll_control0[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCMI_TSC_XGXS_ANAPLL_CONTROL0r_ICLKODRV1f_GET(r) ((((r).anapll_control0[0]) >> 9) & 0x7)
#define BCMI_TSC_XGXS_ANAPLL_CONTROL0r_ICLKODRV1f_SET(r,f) (r).anapll_control0[0]=(((r).anapll_control0[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCMI_TSC_XGXS_ANAPLL_CONTROL0r_ICLKODRV2f_GET(r) ((((r).anapll_control0[0]) >> 6) & 0x7)
#define BCMI_TSC_XGXS_ANAPLL_CONTROL0r_ICLKODRV2f_SET(r,f) (r).anapll_control0[0]=(((r).anapll_control0[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCMI_TSC_XGXS_ANAPLL_CONTROL0r_ICLKDIV2f_GET(r) ((((r).anapll_control0[0]) >> 3) & 0x7)
#define BCMI_TSC_XGXS_ANAPLL_CONTROL0r_ICLKDIV2f_SET(r,f) (r).anapll_control0[0]=(((r).anapll_control0[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCMI_TSC_XGXS_ANAPLL_CONTROL0r_RESERVED0f_GET(r) ((((r).anapll_control0[0]) >> 2) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_CONTROL0r_RESERVED0f_SET(r,f) (r).anapll_control0[0]=(((r).anapll_control0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCMI_TSC_XGXS_ANAPLL_CONTROL0r_VDDR_BGBf_GET(r) ((((r).anapll_control0[0]) >> 1) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_CONTROL0r_VDDR_BGBf_SET(r,f) (r).anapll_control0[0]=(((r).anapll_control0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCMI_TSC_XGXS_ANAPLL_CONTROL0r_AMP_CTRLf_GET(r) (((r).anapll_control0[0]) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_CONTROL0r_AMP_CTRLf_SET(r,f) (r).anapll_control0[0]=(((r).anapll_control0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access ANAPLL_CONTROL0.
 *
 */
#define BCMI_TSC_XGXS_READ_ANAPLL_CONTROL0r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_ANAPLL_CONTROL0r,(_r._anapll_control0))
#define BCMI_TSC_XGXS_WRITE_ANAPLL_CONTROL0r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_ANAPLL_CONTROL0r,(_r._anapll_control0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define ANAPLL_CONTROL0r BCMI_TSC_XGXS_ANAPLL_CONTROL0r
#define ANAPLL_CONTROL0r_SIZE BCMI_TSC_XGXS_ANAPLL_CONTROL0r_SIZE
typedef BCMI_TSC_XGXS_ANAPLL_CONTROL0r_t ANAPLL_CONTROL0r_t;
#define ANAPLL_CONTROL0r_CLR BCMI_TSC_XGXS_ANAPLL_CONTROL0r_CLR
#define ANAPLL_CONTROL0r_SET BCMI_TSC_XGXS_ANAPLL_CONTROL0r_SET
#define ANAPLL_CONTROL0r_GET BCMI_TSC_XGXS_ANAPLL_CONTROL0r_GET
#define ANAPLL_CONTROL0r_REFL_CLKGENf_GET BCMI_TSC_XGXS_ANAPLL_CONTROL0r_REFL_CLKGENf_GET
#define ANAPLL_CONTROL0r_REFL_CLKGENf_SET BCMI_TSC_XGXS_ANAPLL_CONTROL0r_REFL_CLKGENf_SET
#define ANAPLL_CONTROL0r_ICLKIDRV1f_GET BCMI_TSC_XGXS_ANAPLL_CONTROL0r_ICLKIDRV1f_GET
#define ANAPLL_CONTROL0r_ICLKIDRV1f_SET BCMI_TSC_XGXS_ANAPLL_CONTROL0r_ICLKIDRV1f_SET
#define ANAPLL_CONTROL0r_ICLKODRV1f_GET BCMI_TSC_XGXS_ANAPLL_CONTROL0r_ICLKODRV1f_GET
#define ANAPLL_CONTROL0r_ICLKODRV1f_SET BCMI_TSC_XGXS_ANAPLL_CONTROL0r_ICLKODRV1f_SET
#define ANAPLL_CONTROL0r_ICLKODRV2f_GET BCMI_TSC_XGXS_ANAPLL_CONTROL0r_ICLKODRV2f_GET
#define ANAPLL_CONTROL0r_ICLKODRV2f_SET BCMI_TSC_XGXS_ANAPLL_CONTROL0r_ICLKODRV2f_SET
#define ANAPLL_CONTROL0r_ICLKDIV2f_GET BCMI_TSC_XGXS_ANAPLL_CONTROL0r_ICLKDIV2f_GET
#define ANAPLL_CONTROL0r_ICLKDIV2f_SET BCMI_TSC_XGXS_ANAPLL_CONTROL0r_ICLKDIV2f_SET
#define ANAPLL_CONTROL0r_RESERVED0f_GET BCMI_TSC_XGXS_ANAPLL_CONTROL0r_RESERVED0f_GET
#define ANAPLL_CONTROL0r_RESERVED0f_SET BCMI_TSC_XGXS_ANAPLL_CONTROL0r_RESERVED0f_SET
#define ANAPLL_CONTROL0r_VDDR_BGBf_GET BCMI_TSC_XGXS_ANAPLL_CONTROL0r_VDDR_BGBf_GET
#define ANAPLL_CONTROL0r_VDDR_BGBf_SET BCMI_TSC_XGXS_ANAPLL_CONTROL0r_VDDR_BGBf_SET
#define ANAPLL_CONTROL0r_AMP_CTRLf_GET BCMI_TSC_XGXS_ANAPLL_CONTROL0r_AMP_CTRLf_GET
#define ANAPLL_CONTROL0r_AMP_CTRLf_SET BCMI_TSC_XGXS_ANAPLL_CONTROL0r_AMP_CTRLf_SET
#define READ_ANAPLL_CONTROL0r BCMI_TSC_XGXS_READ_ANAPLL_CONTROL0r
#define WRITE_ANAPLL_CONTROL0r BCMI_TSC_XGXS_WRITE_ANAPLL_CONTROL0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_ANAPLL_CONTROL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  ANAPLL_CONTROL1
 * BLOCKS:   ANAPLL
 * REGADDR:  0x901b
 * DESC:     PLL analog controls (AFE pll_ctrl[31:16], not applicable to XFICore): 00000000
 * SIZE:     32
 * FIELDS:
 *     REFH_CLKGEN      
 *     RESERVED1        
 *     ICKGEN           
 *     RESERVED0        
 *     PLL_RESET        
 *     ENABLE_FTUNE     
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_ANAPLL_CONTROL1r (0x0010901b | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_ANAPLL_CONTROL1r_SIZE 4

/*
 * This structure should be used to declare and program ANAPLL_CONTROL1.
 *
 */
typedef union BCMI_TSC_XGXS_ANAPLL_CONTROL1r_s {
	uint32_t v[1];
	uint32_t anapll_control1[1];
	uint32_t _anapll_control1;
} BCMI_TSC_XGXS_ANAPLL_CONTROL1r_t;

#define BCMI_TSC_XGXS_ANAPLL_CONTROL1r_CLR(r) (r).anapll_control1[0] = 0
#define BCMI_TSC_XGXS_ANAPLL_CONTROL1r_SET(r,d) (r).anapll_control1[0] = d
#define BCMI_TSC_XGXS_ANAPLL_CONTROL1r_GET(r) (r).anapll_control1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_ANAPLL_CONTROL1r_ENABLE_FTUNEf_GET(r) ((((r).anapll_control1[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_CONTROL1r_ENABLE_FTUNEf_SET(r,f) (r).anapll_control1[0]=(((r).anapll_control1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_ANAPLL_CONTROL1r_PLL_RESETf_GET(r) ((((r).anapll_control1[0]) >> 14) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_CONTROL1r_PLL_RESETf_SET(r,f) (r).anapll_control1[0]=(((r).anapll_control1[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCMI_TSC_XGXS_ANAPLL_CONTROL1r_RESERVED0f_GET(r) ((((r).anapll_control1[0]) >> 8) & 0x3f)
#define BCMI_TSC_XGXS_ANAPLL_CONTROL1r_RESERVED0f_SET(r,f) (r).anapll_control1[0]=(((r).anapll_control1[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define BCMI_TSC_XGXS_ANAPLL_CONTROL1r_ICKGENf_GET(r) ((((r).anapll_control1[0]) >> 5) & 0x7)
#define BCMI_TSC_XGXS_ANAPLL_CONTROL1r_ICKGENf_SET(r,f) (r).anapll_control1[0]=(((r).anapll_control1[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))
#define BCMI_TSC_XGXS_ANAPLL_CONTROL1r_RESERVED1f_GET(r) ((((r).anapll_control1[0]) >> 1) & 0xf)
#define BCMI_TSC_XGXS_ANAPLL_CONTROL1r_RESERVED1f_SET(r,f) (r).anapll_control1[0]=(((r).anapll_control1[0] & ~((uint32_t)0xf << 1)) | ((((uint32_t)f) & 0xf) << 1))
#define BCMI_TSC_XGXS_ANAPLL_CONTROL1r_REFH_CLKGENf_GET(r) (((r).anapll_control1[0]) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_CONTROL1r_REFH_CLKGENf_SET(r,f) (r).anapll_control1[0]=(((r).anapll_control1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access ANAPLL_CONTROL1.
 *
 */
#define BCMI_TSC_XGXS_READ_ANAPLL_CONTROL1r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_ANAPLL_CONTROL1r,(_r._anapll_control1))
#define BCMI_TSC_XGXS_WRITE_ANAPLL_CONTROL1r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_ANAPLL_CONTROL1r,(_r._anapll_control1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define ANAPLL_CONTROL1r BCMI_TSC_XGXS_ANAPLL_CONTROL1r
#define ANAPLL_CONTROL1r_SIZE BCMI_TSC_XGXS_ANAPLL_CONTROL1r_SIZE
typedef BCMI_TSC_XGXS_ANAPLL_CONTROL1r_t ANAPLL_CONTROL1r_t;
#define ANAPLL_CONTROL1r_CLR BCMI_TSC_XGXS_ANAPLL_CONTROL1r_CLR
#define ANAPLL_CONTROL1r_SET BCMI_TSC_XGXS_ANAPLL_CONTROL1r_SET
#define ANAPLL_CONTROL1r_GET BCMI_TSC_XGXS_ANAPLL_CONTROL1r_GET
#define ANAPLL_CONTROL1r_ENABLE_FTUNEf_GET BCMI_TSC_XGXS_ANAPLL_CONTROL1r_ENABLE_FTUNEf_GET
#define ANAPLL_CONTROL1r_ENABLE_FTUNEf_SET BCMI_TSC_XGXS_ANAPLL_CONTROL1r_ENABLE_FTUNEf_SET
#define ANAPLL_CONTROL1r_PLL_RESETf_GET BCMI_TSC_XGXS_ANAPLL_CONTROL1r_PLL_RESETf_GET
#define ANAPLL_CONTROL1r_PLL_RESETf_SET BCMI_TSC_XGXS_ANAPLL_CONTROL1r_PLL_RESETf_SET
#define ANAPLL_CONTROL1r_RESERVED0f_GET BCMI_TSC_XGXS_ANAPLL_CONTROL1r_RESERVED0f_GET
#define ANAPLL_CONTROL1r_RESERVED0f_SET BCMI_TSC_XGXS_ANAPLL_CONTROL1r_RESERVED0f_SET
#define ANAPLL_CONTROL1r_ICKGENf_GET BCMI_TSC_XGXS_ANAPLL_CONTROL1r_ICKGENf_GET
#define ANAPLL_CONTROL1r_ICKGENf_SET BCMI_TSC_XGXS_ANAPLL_CONTROL1r_ICKGENf_SET
#define ANAPLL_CONTROL1r_RESERVED1f_GET BCMI_TSC_XGXS_ANAPLL_CONTROL1r_RESERVED1f_GET
#define ANAPLL_CONTROL1r_RESERVED1f_SET BCMI_TSC_XGXS_ANAPLL_CONTROL1r_RESERVED1f_SET
#define ANAPLL_CONTROL1r_REFH_CLKGENf_GET BCMI_TSC_XGXS_ANAPLL_CONTROL1r_REFH_CLKGENf_GET
#define ANAPLL_CONTROL1r_REFH_CLKGENf_SET BCMI_TSC_XGXS_ANAPLL_CONTROL1r_REFH_CLKGENf_SET
#define READ_ANAPLL_CONTROL1r BCMI_TSC_XGXS_READ_ANAPLL_CONTROL1r
#define WRITE_ANAPLL_CONTROL1r BCMI_TSC_XGXS_WRITE_ANAPLL_CONTROL1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_ANAPLL_CONTROL1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  ANAPLL_CONTROL2
 * BLOCKS:   ANAPLL
 * REGADDR:  0x901c
 * DESC:     PLL analog controls (AFE pll_ctrl[47:32], not applicable to XFICore): 00000000
 * SIZE:     32
 * FIELDS:
 *     EN_HRZ           
 *     IQP              
 *     REFL_PLL         
 *     REFH_PLL         
 *     IBMIN            
 *     IBMODE           
 *     IBMAX            
 *     ICP1             
 *     ICP0             
 *     ICP2             
 *     ICK1             
 *     ICK0             
 *     ICK2             
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_ANAPLL_CONTROL2r (0x0010901c | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_ANAPLL_CONTROL2r_SIZE 4

/*
 * This structure should be used to declare and program ANAPLL_CONTROL2.
 *
 */
typedef union BCMI_TSC_XGXS_ANAPLL_CONTROL2r_s {
	uint32_t v[1];
	uint32_t anapll_control2[1];
	uint32_t _anapll_control2;
} BCMI_TSC_XGXS_ANAPLL_CONTROL2r_t;

#define BCMI_TSC_XGXS_ANAPLL_CONTROL2r_CLR(r) (r).anapll_control2[0] = 0
#define BCMI_TSC_XGXS_ANAPLL_CONTROL2r_SET(r,d) (r).anapll_control2[0] = d
#define BCMI_TSC_XGXS_ANAPLL_CONTROL2r_GET(r) (r).anapll_control2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_ANAPLL_CONTROL2r_ICK2f_GET(r) ((((r).anapll_control2[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_CONTROL2r_ICK2f_SET(r,f) (r).anapll_control2[0]=(((r).anapll_control2[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_ANAPLL_CONTROL2r_ICK0f_GET(r) ((((r).anapll_control2[0]) >> 14) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_CONTROL2r_ICK0f_SET(r,f) (r).anapll_control2[0]=(((r).anapll_control2[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCMI_TSC_XGXS_ANAPLL_CONTROL2r_ICK1f_GET(r) ((((r).anapll_control2[0]) >> 13) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_CONTROL2r_ICK1f_SET(r,f) (r).anapll_control2[0]=(((r).anapll_control2[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCMI_TSC_XGXS_ANAPLL_CONTROL2r_ICP2f_GET(r) ((((r).anapll_control2[0]) >> 12) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_CONTROL2r_ICP2f_SET(r,f) (r).anapll_control2[0]=(((r).anapll_control2[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCMI_TSC_XGXS_ANAPLL_CONTROL2r_ICP0f_GET(r) ((((r).anapll_control2[0]) >> 11) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_CONTROL2r_ICP0f_SET(r,f) (r).anapll_control2[0]=(((r).anapll_control2[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCMI_TSC_XGXS_ANAPLL_CONTROL2r_ICP1f_GET(r) ((((r).anapll_control2[0]) >> 10) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_CONTROL2r_ICP1f_SET(r,f) (r).anapll_control2[0]=(((r).anapll_control2[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCMI_TSC_XGXS_ANAPLL_CONTROL2r_IBMAXf_GET(r) ((((r).anapll_control2[0]) >> 9) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_CONTROL2r_IBMAXf_SET(r,f) (r).anapll_control2[0]=(((r).anapll_control2[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCMI_TSC_XGXS_ANAPLL_CONTROL2r_IBMODEf_GET(r) ((((r).anapll_control2[0]) >> 8) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_CONTROL2r_IBMODEf_SET(r,f) (r).anapll_control2[0]=(((r).anapll_control2[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCMI_TSC_XGXS_ANAPLL_CONTROL2r_IBMINf_GET(r) ((((r).anapll_control2[0]) >> 7) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_CONTROL2r_IBMINf_SET(r,f) (r).anapll_control2[0]=(((r).anapll_control2[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCMI_TSC_XGXS_ANAPLL_CONTROL2r_REFH_PLLf_GET(r) ((((r).anapll_control2[0]) >> 6) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_CONTROL2r_REFH_PLLf_SET(r,f) (r).anapll_control2[0]=(((r).anapll_control2[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCMI_TSC_XGXS_ANAPLL_CONTROL2r_REFL_PLLf_GET(r) ((((r).anapll_control2[0]) >> 5) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_CONTROL2r_REFL_PLLf_SET(r,f) (r).anapll_control2[0]=(((r).anapll_control2[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCMI_TSC_XGXS_ANAPLL_CONTROL2r_IQPf_GET(r) ((((r).anapll_control2[0]) >> 1) & 0xf)
#define BCMI_TSC_XGXS_ANAPLL_CONTROL2r_IQPf_SET(r,f) (r).anapll_control2[0]=(((r).anapll_control2[0] & ~((uint32_t)0xf << 1)) | ((((uint32_t)f) & 0xf) << 1))
#define BCMI_TSC_XGXS_ANAPLL_CONTROL2r_EN_HRZf_GET(r) (((r).anapll_control2[0]) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_CONTROL2r_EN_HRZf_SET(r,f) (r).anapll_control2[0]=(((r).anapll_control2[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access ANAPLL_CONTROL2.
 *
 */
#define BCMI_TSC_XGXS_READ_ANAPLL_CONTROL2r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_ANAPLL_CONTROL2r,(_r._anapll_control2))
#define BCMI_TSC_XGXS_WRITE_ANAPLL_CONTROL2r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_ANAPLL_CONTROL2r,(_r._anapll_control2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define ANAPLL_CONTROL2r BCMI_TSC_XGXS_ANAPLL_CONTROL2r
#define ANAPLL_CONTROL2r_SIZE BCMI_TSC_XGXS_ANAPLL_CONTROL2r_SIZE
typedef BCMI_TSC_XGXS_ANAPLL_CONTROL2r_t ANAPLL_CONTROL2r_t;
#define ANAPLL_CONTROL2r_CLR BCMI_TSC_XGXS_ANAPLL_CONTROL2r_CLR
#define ANAPLL_CONTROL2r_SET BCMI_TSC_XGXS_ANAPLL_CONTROL2r_SET
#define ANAPLL_CONTROL2r_GET BCMI_TSC_XGXS_ANAPLL_CONTROL2r_GET
#define ANAPLL_CONTROL2r_ICK2f_GET BCMI_TSC_XGXS_ANAPLL_CONTROL2r_ICK2f_GET
#define ANAPLL_CONTROL2r_ICK2f_SET BCMI_TSC_XGXS_ANAPLL_CONTROL2r_ICK2f_SET
#define ANAPLL_CONTROL2r_ICK0f_GET BCMI_TSC_XGXS_ANAPLL_CONTROL2r_ICK0f_GET
#define ANAPLL_CONTROL2r_ICK0f_SET BCMI_TSC_XGXS_ANAPLL_CONTROL2r_ICK0f_SET
#define ANAPLL_CONTROL2r_ICK1f_GET BCMI_TSC_XGXS_ANAPLL_CONTROL2r_ICK1f_GET
#define ANAPLL_CONTROL2r_ICK1f_SET BCMI_TSC_XGXS_ANAPLL_CONTROL2r_ICK1f_SET
#define ANAPLL_CONTROL2r_ICP2f_GET BCMI_TSC_XGXS_ANAPLL_CONTROL2r_ICP2f_GET
#define ANAPLL_CONTROL2r_ICP2f_SET BCMI_TSC_XGXS_ANAPLL_CONTROL2r_ICP2f_SET
#define ANAPLL_CONTROL2r_ICP0f_GET BCMI_TSC_XGXS_ANAPLL_CONTROL2r_ICP0f_GET
#define ANAPLL_CONTROL2r_ICP0f_SET BCMI_TSC_XGXS_ANAPLL_CONTROL2r_ICP0f_SET
#define ANAPLL_CONTROL2r_ICP1f_GET BCMI_TSC_XGXS_ANAPLL_CONTROL2r_ICP1f_GET
#define ANAPLL_CONTROL2r_ICP1f_SET BCMI_TSC_XGXS_ANAPLL_CONTROL2r_ICP1f_SET
#define ANAPLL_CONTROL2r_IBMAXf_GET BCMI_TSC_XGXS_ANAPLL_CONTROL2r_IBMAXf_GET
#define ANAPLL_CONTROL2r_IBMAXf_SET BCMI_TSC_XGXS_ANAPLL_CONTROL2r_IBMAXf_SET
#define ANAPLL_CONTROL2r_IBMODEf_GET BCMI_TSC_XGXS_ANAPLL_CONTROL2r_IBMODEf_GET
#define ANAPLL_CONTROL2r_IBMODEf_SET BCMI_TSC_XGXS_ANAPLL_CONTROL2r_IBMODEf_SET
#define ANAPLL_CONTROL2r_IBMINf_GET BCMI_TSC_XGXS_ANAPLL_CONTROL2r_IBMINf_GET
#define ANAPLL_CONTROL2r_IBMINf_SET BCMI_TSC_XGXS_ANAPLL_CONTROL2r_IBMINf_SET
#define ANAPLL_CONTROL2r_REFH_PLLf_GET BCMI_TSC_XGXS_ANAPLL_CONTROL2r_REFH_PLLf_GET
#define ANAPLL_CONTROL2r_REFH_PLLf_SET BCMI_TSC_XGXS_ANAPLL_CONTROL2r_REFH_PLLf_SET
#define ANAPLL_CONTROL2r_REFL_PLLf_GET BCMI_TSC_XGXS_ANAPLL_CONTROL2r_REFL_PLLf_GET
#define ANAPLL_CONTROL2r_REFL_PLLf_SET BCMI_TSC_XGXS_ANAPLL_CONTROL2r_REFL_PLLf_SET
#define ANAPLL_CONTROL2r_IQPf_GET BCMI_TSC_XGXS_ANAPLL_CONTROL2r_IQPf_GET
#define ANAPLL_CONTROL2r_IQPf_SET BCMI_TSC_XGXS_ANAPLL_CONTROL2r_IQPf_SET
#define ANAPLL_CONTROL2r_EN_HRZf_GET BCMI_TSC_XGXS_ANAPLL_CONTROL2r_EN_HRZf_GET
#define ANAPLL_CONTROL2r_EN_HRZf_SET BCMI_TSC_XGXS_ANAPLL_CONTROL2r_EN_HRZf_SET
#define READ_ANAPLL_CONTROL2r BCMI_TSC_XGXS_READ_ANAPLL_CONTROL2r
#define WRITE_ANAPLL_CONTROL2r BCMI_TSC_XGXS_WRITE_ANAPLL_CONTROL2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_ANAPLL_CONTROL2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  ANAPLL_CONTROL3
 * BLOCKS:   ANAPLL
 * REGADDR:  0x901d
 * DESC:     PLL analog controls (AFE pll_ctrl[63:48], not applicable to XFICore): 00000000
 * SIZE:     32
 * FIELDS:
 *     I10GBUF1         
 *     I10GBUF0         
 *     I10GBUF2         
 *     ICML1            
 *     ICML0            
 *     ICML2            
 *     ICOMP1           
 *     ICOMP0           
 *     ICOMP2           
 *     IOP1             
 *     IOP0             
 *     IOP2             
 *     TEST_VREF        
 *     TEST_VC          
 *     TEST_PLL         
 *     TEST_RX          
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_ANAPLL_CONTROL3r (0x0010901d | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_ANAPLL_CONTROL3r_SIZE 4

/*
 * This structure should be used to declare and program ANAPLL_CONTROL3.
 *
 */
typedef union BCMI_TSC_XGXS_ANAPLL_CONTROL3r_s {
	uint32_t v[1];
	uint32_t anapll_control3[1];
	uint32_t _anapll_control3;
} BCMI_TSC_XGXS_ANAPLL_CONTROL3r_t;

#define BCMI_TSC_XGXS_ANAPLL_CONTROL3r_CLR(r) (r).anapll_control3[0] = 0
#define BCMI_TSC_XGXS_ANAPLL_CONTROL3r_SET(r,d) (r).anapll_control3[0] = d
#define BCMI_TSC_XGXS_ANAPLL_CONTROL3r_GET(r) (r).anapll_control3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_ANAPLL_CONTROL3r_TEST_RXf_GET(r) ((((r).anapll_control3[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_CONTROL3r_TEST_RXf_SET(r,f) (r).anapll_control3[0]=(((r).anapll_control3[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_ANAPLL_CONTROL3r_TEST_PLLf_GET(r) ((((r).anapll_control3[0]) >> 14) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_CONTROL3r_TEST_PLLf_SET(r,f) (r).anapll_control3[0]=(((r).anapll_control3[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCMI_TSC_XGXS_ANAPLL_CONTROL3r_TEST_VCf_GET(r) ((((r).anapll_control3[0]) >> 13) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_CONTROL3r_TEST_VCf_SET(r,f) (r).anapll_control3[0]=(((r).anapll_control3[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCMI_TSC_XGXS_ANAPLL_CONTROL3r_TEST_VREFf_GET(r) ((((r).anapll_control3[0]) >> 12) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_CONTROL3r_TEST_VREFf_SET(r,f) (r).anapll_control3[0]=(((r).anapll_control3[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCMI_TSC_XGXS_ANAPLL_CONTROL3r_IOP2f_GET(r) ((((r).anapll_control3[0]) >> 11) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_CONTROL3r_IOP2f_SET(r,f) (r).anapll_control3[0]=(((r).anapll_control3[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCMI_TSC_XGXS_ANAPLL_CONTROL3r_IOP0f_GET(r) ((((r).anapll_control3[0]) >> 10) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_CONTROL3r_IOP0f_SET(r,f) (r).anapll_control3[0]=(((r).anapll_control3[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCMI_TSC_XGXS_ANAPLL_CONTROL3r_IOP1f_GET(r) ((((r).anapll_control3[0]) >> 9) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_CONTROL3r_IOP1f_SET(r,f) (r).anapll_control3[0]=(((r).anapll_control3[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCMI_TSC_XGXS_ANAPLL_CONTROL3r_ICOMP2f_GET(r) ((((r).anapll_control3[0]) >> 8) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_CONTROL3r_ICOMP2f_SET(r,f) (r).anapll_control3[0]=(((r).anapll_control3[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCMI_TSC_XGXS_ANAPLL_CONTROL3r_ICOMP0f_GET(r) ((((r).anapll_control3[0]) >> 7) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_CONTROL3r_ICOMP0f_SET(r,f) (r).anapll_control3[0]=(((r).anapll_control3[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCMI_TSC_XGXS_ANAPLL_CONTROL3r_ICOMP1f_GET(r) ((((r).anapll_control3[0]) >> 6) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_CONTROL3r_ICOMP1f_SET(r,f) (r).anapll_control3[0]=(((r).anapll_control3[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCMI_TSC_XGXS_ANAPLL_CONTROL3r_ICML2f_GET(r) ((((r).anapll_control3[0]) >> 5) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_CONTROL3r_ICML2f_SET(r,f) (r).anapll_control3[0]=(((r).anapll_control3[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCMI_TSC_XGXS_ANAPLL_CONTROL3r_ICML0f_GET(r) ((((r).anapll_control3[0]) >> 4) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_CONTROL3r_ICML0f_SET(r,f) (r).anapll_control3[0]=(((r).anapll_control3[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCMI_TSC_XGXS_ANAPLL_CONTROL3r_ICML1f_GET(r) ((((r).anapll_control3[0]) >> 3) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_CONTROL3r_ICML1f_SET(r,f) (r).anapll_control3[0]=(((r).anapll_control3[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCMI_TSC_XGXS_ANAPLL_CONTROL3r_I10GBUF2f_GET(r) ((((r).anapll_control3[0]) >> 2) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_CONTROL3r_I10GBUF2f_SET(r,f) (r).anapll_control3[0]=(((r).anapll_control3[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCMI_TSC_XGXS_ANAPLL_CONTROL3r_I10GBUF0f_GET(r) ((((r).anapll_control3[0]) >> 1) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_CONTROL3r_I10GBUF0f_SET(r,f) (r).anapll_control3[0]=(((r).anapll_control3[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCMI_TSC_XGXS_ANAPLL_CONTROL3r_I10GBUF1f_GET(r) (((r).anapll_control3[0]) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_CONTROL3r_I10GBUF1f_SET(r,f) (r).anapll_control3[0]=(((r).anapll_control3[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access ANAPLL_CONTROL3.
 *
 */
#define BCMI_TSC_XGXS_READ_ANAPLL_CONTROL3r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_ANAPLL_CONTROL3r,(_r._anapll_control3))
#define BCMI_TSC_XGXS_WRITE_ANAPLL_CONTROL3r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_ANAPLL_CONTROL3r,(_r._anapll_control3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define ANAPLL_CONTROL3r BCMI_TSC_XGXS_ANAPLL_CONTROL3r
#define ANAPLL_CONTROL3r_SIZE BCMI_TSC_XGXS_ANAPLL_CONTROL3r_SIZE
typedef BCMI_TSC_XGXS_ANAPLL_CONTROL3r_t ANAPLL_CONTROL3r_t;
#define ANAPLL_CONTROL3r_CLR BCMI_TSC_XGXS_ANAPLL_CONTROL3r_CLR
#define ANAPLL_CONTROL3r_SET BCMI_TSC_XGXS_ANAPLL_CONTROL3r_SET
#define ANAPLL_CONTROL3r_GET BCMI_TSC_XGXS_ANAPLL_CONTROL3r_GET
#define ANAPLL_CONTROL3r_TEST_RXf_GET BCMI_TSC_XGXS_ANAPLL_CONTROL3r_TEST_RXf_GET
#define ANAPLL_CONTROL3r_TEST_RXf_SET BCMI_TSC_XGXS_ANAPLL_CONTROL3r_TEST_RXf_SET
#define ANAPLL_CONTROL3r_TEST_PLLf_GET BCMI_TSC_XGXS_ANAPLL_CONTROL3r_TEST_PLLf_GET
#define ANAPLL_CONTROL3r_TEST_PLLf_SET BCMI_TSC_XGXS_ANAPLL_CONTROL3r_TEST_PLLf_SET
#define ANAPLL_CONTROL3r_TEST_VCf_GET BCMI_TSC_XGXS_ANAPLL_CONTROL3r_TEST_VCf_GET
#define ANAPLL_CONTROL3r_TEST_VCf_SET BCMI_TSC_XGXS_ANAPLL_CONTROL3r_TEST_VCf_SET
#define ANAPLL_CONTROL3r_TEST_VREFf_GET BCMI_TSC_XGXS_ANAPLL_CONTROL3r_TEST_VREFf_GET
#define ANAPLL_CONTROL3r_TEST_VREFf_SET BCMI_TSC_XGXS_ANAPLL_CONTROL3r_TEST_VREFf_SET
#define ANAPLL_CONTROL3r_IOP2f_GET BCMI_TSC_XGXS_ANAPLL_CONTROL3r_IOP2f_GET
#define ANAPLL_CONTROL3r_IOP2f_SET BCMI_TSC_XGXS_ANAPLL_CONTROL3r_IOP2f_SET
#define ANAPLL_CONTROL3r_IOP0f_GET BCMI_TSC_XGXS_ANAPLL_CONTROL3r_IOP0f_GET
#define ANAPLL_CONTROL3r_IOP0f_SET BCMI_TSC_XGXS_ANAPLL_CONTROL3r_IOP0f_SET
#define ANAPLL_CONTROL3r_IOP1f_GET BCMI_TSC_XGXS_ANAPLL_CONTROL3r_IOP1f_GET
#define ANAPLL_CONTROL3r_IOP1f_SET BCMI_TSC_XGXS_ANAPLL_CONTROL3r_IOP1f_SET
#define ANAPLL_CONTROL3r_ICOMP2f_GET BCMI_TSC_XGXS_ANAPLL_CONTROL3r_ICOMP2f_GET
#define ANAPLL_CONTROL3r_ICOMP2f_SET BCMI_TSC_XGXS_ANAPLL_CONTROL3r_ICOMP2f_SET
#define ANAPLL_CONTROL3r_ICOMP0f_GET BCMI_TSC_XGXS_ANAPLL_CONTROL3r_ICOMP0f_GET
#define ANAPLL_CONTROL3r_ICOMP0f_SET BCMI_TSC_XGXS_ANAPLL_CONTROL3r_ICOMP0f_SET
#define ANAPLL_CONTROL3r_ICOMP1f_GET BCMI_TSC_XGXS_ANAPLL_CONTROL3r_ICOMP1f_GET
#define ANAPLL_CONTROL3r_ICOMP1f_SET BCMI_TSC_XGXS_ANAPLL_CONTROL3r_ICOMP1f_SET
#define ANAPLL_CONTROL3r_ICML2f_GET BCMI_TSC_XGXS_ANAPLL_CONTROL3r_ICML2f_GET
#define ANAPLL_CONTROL3r_ICML2f_SET BCMI_TSC_XGXS_ANAPLL_CONTROL3r_ICML2f_SET
#define ANAPLL_CONTROL3r_ICML0f_GET BCMI_TSC_XGXS_ANAPLL_CONTROL3r_ICML0f_GET
#define ANAPLL_CONTROL3r_ICML0f_SET BCMI_TSC_XGXS_ANAPLL_CONTROL3r_ICML0f_SET
#define ANAPLL_CONTROL3r_ICML1f_GET BCMI_TSC_XGXS_ANAPLL_CONTROL3r_ICML1f_GET
#define ANAPLL_CONTROL3r_ICML1f_SET BCMI_TSC_XGXS_ANAPLL_CONTROL3r_ICML1f_SET
#define ANAPLL_CONTROL3r_I10GBUF2f_GET BCMI_TSC_XGXS_ANAPLL_CONTROL3r_I10GBUF2f_GET
#define ANAPLL_CONTROL3r_I10GBUF2f_SET BCMI_TSC_XGXS_ANAPLL_CONTROL3r_I10GBUF2f_SET
#define ANAPLL_CONTROL3r_I10GBUF0f_GET BCMI_TSC_XGXS_ANAPLL_CONTROL3r_I10GBUF0f_GET
#define ANAPLL_CONTROL3r_I10GBUF0f_SET BCMI_TSC_XGXS_ANAPLL_CONTROL3r_I10GBUF0f_SET
#define ANAPLL_CONTROL3r_I10GBUF1f_GET BCMI_TSC_XGXS_ANAPLL_CONTROL3r_I10GBUF1f_GET
#define ANAPLL_CONTROL3r_I10GBUF1f_SET BCMI_TSC_XGXS_ANAPLL_CONTROL3r_I10GBUF1f_SET
#define READ_ANAPLL_CONTROL3r BCMI_TSC_XGXS_READ_ANAPLL_CONTROL3r
#define WRITE_ANAPLL_CONTROL3r BCMI_TSC_XGXS_WRITE_ANAPLL_CONTROL3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_ANAPLL_CONTROL3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  ANAPLL_CONTROL4
 * BLOCKS:   ANAPLL
 * REGADDR:  0x901e
 * DESC:     PLL analog controls (AFE pll_ctrl[79:64], not applicable to XFICore): 00000000
 * SIZE:     32
 * FIELDS:
 *     PTATADJ          
 *     CTATADJ          
 *     PLL2RX_CLKBW     
 *     COMP_VTH         
 *     VVDDR_BGB        
 *     KVH_FORCE        
 *     VCO_IMAX         
 *     EN40LP           
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_ANAPLL_CONTROL4r (0x0010901e | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_ANAPLL_CONTROL4r_SIZE 4

/*
 * This structure should be used to declare and program ANAPLL_CONTROL4.
 *
 */
typedef union BCMI_TSC_XGXS_ANAPLL_CONTROL4r_s {
	uint32_t v[1];
	uint32_t anapll_control4[1];
	uint32_t _anapll_control4;
} BCMI_TSC_XGXS_ANAPLL_CONTROL4r_t;

#define BCMI_TSC_XGXS_ANAPLL_CONTROL4r_CLR(r) (r).anapll_control4[0] = 0
#define BCMI_TSC_XGXS_ANAPLL_CONTROL4r_SET(r,d) (r).anapll_control4[0] = d
#define BCMI_TSC_XGXS_ANAPLL_CONTROL4r_GET(r) (r).anapll_control4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_ANAPLL_CONTROL4r_EN40LPf_GET(r) ((((r).anapll_control4[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_CONTROL4r_EN40LPf_SET(r,f) (r).anapll_control4[0]=(((r).anapll_control4[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_ANAPLL_CONTROL4r_VCO_IMAXf_GET(r) ((((r).anapll_control4[0]) >> 14) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_CONTROL4r_VCO_IMAXf_SET(r,f) (r).anapll_control4[0]=(((r).anapll_control4[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCMI_TSC_XGXS_ANAPLL_CONTROL4r_KVH_FORCEf_GET(r) ((((r).anapll_control4[0]) >> 12) & 0x3)
#define BCMI_TSC_XGXS_ANAPLL_CONTROL4r_KVH_FORCEf_SET(r,f) (r).anapll_control4[0]=(((r).anapll_control4[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCMI_TSC_XGXS_ANAPLL_CONTROL4r_VVDDR_BGBf_GET(r) ((((r).anapll_control4[0]) >> 11) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_CONTROL4r_VVDDR_BGBf_SET(r,f) (r).anapll_control4[0]=(((r).anapll_control4[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCMI_TSC_XGXS_ANAPLL_CONTROL4r_COMP_VTHf_GET(r) ((((r).anapll_control4[0]) >> 10) & 0x1)
#define BCMI_TSC_XGXS_ANAPLL_CONTROL4r_COMP_VTHf_SET(r,f) (r).anapll_control4[0]=(((r).anapll_control4[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCMI_TSC_XGXS_ANAPLL_CONTROL4r_PLL2RX_CLKBWf_GET(r) ((((r).anapll_control4[0]) >> 8) & 0x3)
#define BCMI_TSC_XGXS_ANAPLL_CONTROL4r_PLL2RX_CLKBWf_SET(r,f) (r).anapll_control4[0]=(((r).anapll_control4[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCMI_TSC_XGXS_ANAPLL_CONTROL4r_CTATADJf_GET(r) ((((r).anapll_control4[0]) >> 4) & 0xf)
#define BCMI_TSC_XGXS_ANAPLL_CONTROL4r_CTATADJf_SET(r,f) (r).anapll_control4[0]=(((r).anapll_control4[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCMI_TSC_XGXS_ANAPLL_CONTROL4r_PTATADJf_GET(r) (((r).anapll_control4[0]) & 0xf)
#define BCMI_TSC_XGXS_ANAPLL_CONTROL4r_PTATADJf_SET(r,f) (r).anapll_control4[0]=(((r).anapll_control4[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access ANAPLL_CONTROL4.
 *
 */
#define BCMI_TSC_XGXS_READ_ANAPLL_CONTROL4r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_ANAPLL_CONTROL4r,(_r._anapll_control4))
#define BCMI_TSC_XGXS_WRITE_ANAPLL_CONTROL4r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_ANAPLL_CONTROL4r,(_r._anapll_control4))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define ANAPLL_CONTROL4r BCMI_TSC_XGXS_ANAPLL_CONTROL4r
#define ANAPLL_CONTROL4r_SIZE BCMI_TSC_XGXS_ANAPLL_CONTROL4r_SIZE
typedef BCMI_TSC_XGXS_ANAPLL_CONTROL4r_t ANAPLL_CONTROL4r_t;
#define ANAPLL_CONTROL4r_CLR BCMI_TSC_XGXS_ANAPLL_CONTROL4r_CLR
#define ANAPLL_CONTROL4r_SET BCMI_TSC_XGXS_ANAPLL_CONTROL4r_SET
#define ANAPLL_CONTROL4r_GET BCMI_TSC_XGXS_ANAPLL_CONTROL4r_GET
#define ANAPLL_CONTROL4r_EN40LPf_GET BCMI_TSC_XGXS_ANAPLL_CONTROL4r_EN40LPf_GET
#define ANAPLL_CONTROL4r_EN40LPf_SET BCMI_TSC_XGXS_ANAPLL_CONTROL4r_EN40LPf_SET
#define ANAPLL_CONTROL4r_VCO_IMAXf_GET BCMI_TSC_XGXS_ANAPLL_CONTROL4r_VCO_IMAXf_GET
#define ANAPLL_CONTROL4r_VCO_IMAXf_SET BCMI_TSC_XGXS_ANAPLL_CONTROL4r_VCO_IMAXf_SET
#define ANAPLL_CONTROL4r_KVH_FORCEf_GET BCMI_TSC_XGXS_ANAPLL_CONTROL4r_KVH_FORCEf_GET
#define ANAPLL_CONTROL4r_KVH_FORCEf_SET BCMI_TSC_XGXS_ANAPLL_CONTROL4r_KVH_FORCEf_SET
#define ANAPLL_CONTROL4r_VVDDR_BGBf_GET BCMI_TSC_XGXS_ANAPLL_CONTROL4r_VVDDR_BGBf_GET
#define ANAPLL_CONTROL4r_VVDDR_BGBf_SET BCMI_TSC_XGXS_ANAPLL_CONTROL4r_VVDDR_BGBf_SET
#define ANAPLL_CONTROL4r_COMP_VTHf_GET BCMI_TSC_XGXS_ANAPLL_CONTROL4r_COMP_VTHf_GET
#define ANAPLL_CONTROL4r_COMP_VTHf_SET BCMI_TSC_XGXS_ANAPLL_CONTROL4r_COMP_VTHf_SET
#define ANAPLL_CONTROL4r_PLL2RX_CLKBWf_GET BCMI_TSC_XGXS_ANAPLL_CONTROL4r_PLL2RX_CLKBWf_GET
#define ANAPLL_CONTROL4r_PLL2RX_CLKBWf_SET BCMI_TSC_XGXS_ANAPLL_CONTROL4r_PLL2RX_CLKBWf_SET
#define ANAPLL_CONTROL4r_CTATADJf_GET BCMI_TSC_XGXS_ANAPLL_CONTROL4r_CTATADJf_GET
#define ANAPLL_CONTROL4r_CTATADJf_SET BCMI_TSC_XGXS_ANAPLL_CONTROL4r_CTATADJf_SET
#define ANAPLL_CONTROL4r_PTATADJf_GET BCMI_TSC_XGXS_ANAPLL_CONTROL4r_PTATADJf_GET
#define ANAPLL_CONTROL4r_PTATADJf_SET BCMI_TSC_XGXS_ANAPLL_CONTROL4r_PTATADJf_SET
#define READ_ANAPLL_CONTROL4r BCMI_TSC_XGXS_READ_ANAPLL_CONTROL4r
#define WRITE_ANAPLL_CONTROL4r BCMI_TSC_XGXS_WRITE_ANAPLL_CONTROL4r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_ANAPLL_CONTROL4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  PKTGENCTRL1
 * BLOCKS:   PKTGEN0
 * REGADDR:  0x9030
 * DESC:     Number of Packets: 00000000
 * SIZE:     32
 * FIELDS:
 *     PKT_OR_PRTP      
 *     TX_TEST_PORT_SEL 
 *     LPI_EN           
 *     RESERVED0        
 *     PRTP_DATA_PATTERN_SEL 
 *     TX_PRTP_EN       
 *     RX_PORT_SEL      
 *     CLR_CRCCNT       
 *     RX_MSBUS_TYPE    
 *     RX_PKT_CHECK_EN  
 *     NUMBER_PKT       
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_PKTGENCTRL1r (0x00109030 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_PKTGENCTRL1r_SIZE 4

/*
 * This structure should be used to declare and program PKTGENCTRL1.
 *
 */
typedef union BCMI_TSC_XGXS_PKTGENCTRL1r_s {
	uint32_t v[1];
	uint32_t pktgenctrl1[1];
	uint32_t _pktgenctrl1;
} BCMI_TSC_XGXS_PKTGENCTRL1r_t;

#define BCMI_TSC_XGXS_PKTGENCTRL1r_CLR(r) (r).pktgenctrl1[0] = 0
#define BCMI_TSC_XGXS_PKTGENCTRL1r_SET(r,d) (r).pktgenctrl1[0] = d
#define BCMI_TSC_XGXS_PKTGENCTRL1r_GET(r) (r).pktgenctrl1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_PKTGENCTRL1r_NUMBER_PKTf_GET(r) ((((r).pktgenctrl1[0]) >> 12) & 0xf)
#define BCMI_TSC_XGXS_PKTGENCTRL1r_NUMBER_PKTf_SET(r,f) (r).pktgenctrl1[0]=(((r).pktgenctrl1[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCMI_TSC_XGXS_PKTGENCTRL1r_RX_PKT_CHECK_ENf_GET(r) ((((r).pktgenctrl1[0]) >> 11) & 0x1)
#define BCMI_TSC_XGXS_PKTGENCTRL1r_RX_PKT_CHECK_ENf_SET(r,f) (r).pktgenctrl1[0]=(((r).pktgenctrl1[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCMI_TSC_XGXS_PKTGENCTRL1r_RX_MSBUS_TYPEf_GET(r) ((((r).pktgenctrl1[0]) >> 10) & 0x1)
#define BCMI_TSC_XGXS_PKTGENCTRL1r_RX_MSBUS_TYPEf_SET(r,f) (r).pktgenctrl1[0]=(((r).pktgenctrl1[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCMI_TSC_XGXS_PKTGENCTRL1r_CLR_CRCCNTf_GET(r) ((((r).pktgenctrl1[0]) >> 9) & 0x1)
#define BCMI_TSC_XGXS_PKTGENCTRL1r_CLR_CRCCNTf_SET(r,f) (r).pktgenctrl1[0]=(((r).pktgenctrl1[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCMI_TSC_XGXS_PKTGENCTRL1r_RX_PORT_SELf_GET(r) ((((r).pktgenctrl1[0]) >> 7) & 0x3)
#define BCMI_TSC_XGXS_PKTGENCTRL1r_RX_PORT_SELf_SET(r,f) (r).pktgenctrl1[0]=(((r).pktgenctrl1[0] & ~((uint32_t)0x3 << 7)) | ((((uint32_t)f) & 0x3) << 7))
#define BCMI_TSC_XGXS_PKTGENCTRL1r_TX_PRTP_ENf_GET(r) ((((r).pktgenctrl1[0]) >> 6) & 0x1)
#define BCMI_TSC_XGXS_PKTGENCTRL1r_TX_PRTP_ENf_SET(r,f) (r).pktgenctrl1[0]=(((r).pktgenctrl1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCMI_TSC_XGXS_PKTGENCTRL1r_PRTP_DATA_PATTERN_SELf_GET(r) ((((r).pktgenctrl1[0]) >> 5) & 0x1)
#define BCMI_TSC_XGXS_PKTGENCTRL1r_PRTP_DATA_PATTERN_SELf_SET(r,f) (r).pktgenctrl1[0]=(((r).pktgenctrl1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCMI_TSC_XGXS_PKTGENCTRL1r_RESERVED0f_GET(r) ((((r).pktgenctrl1[0]) >> 4) & 0x1)
#define BCMI_TSC_XGXS_PKTGENCTRL1r_RESERVED0f_SET(r,f) (r).pktgenctrl1[0]=(((r).pktgenctrl1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCMI_TSC_XGXS_PKTGENCTRL1r_LPI_ENf_GET(r) ((((r).pktgenctrl1[0]) >> 3) & 0x1)
#define BCMI_TSC_XGXS_PKTGENCTRL1r_LPI_ENf_SET(r,f) (r).pktgenctrl1[0]=(((r).pktgenctrl1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCMI_TSC_XGXS_PKTGENCTRL1r_TX_TEST_PORT_SELf_GET(r) ((((r).pktgenctrl1[0]) >> 1) & 0x3)
#define BCMI_TSC_XGXS_PKTGENCTRL1r_TX_TEST_PORT_SELf_SET(r,f) (r).pktgenctrl1[0]=(((r).pktgenctrl1[0] & ~((uint32_t)0x3 << 1)) | ((((uint32_t)f) & 0x3) << 1))
#define BCMI_TSC_XGXS_PKTGENCTRL1r_PKT_OR_PRTPf_GET(r) (((r).pktgenctrl1[0]) & 0x1)
#define BCMI_TSC_XGXS_PKTGENCTRL1r_PKT_OR_PRTPf_SET(r,f) (r).pktgenctrl1[0]=(((r).pktgenctrl1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access PKTGENCTRL1.
 *
 */
#define BCMI_TSC_XGXS_READ_PKTGENCTRL1r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_PKTGENCTRL1r,(_r._pktgenctrl1))
#define BCMI_TSC_XGXS_WRITE_PKTGENCTRL1r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_PKTGENCTRL1r,(_r._pktgenctrl1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PKTGENCTRL1r BCMI_TSC_XGXS_PKTGENCTRL1r
#define PKTGENCTRL1r_SIZE BCMI_TSC_XGXS_PKTGENCTRL1r_SIZE
typedef BCMI_TSC_XGXS_PKTGENCTRL1r_t PKTGENCTRL1r_t;
#define PKTGENCTRL1r_CLR BCMI_TSC_XGXS_PKTGENCTRL1r_CLR
#define PKTGENCTRL1r_SET BCMI_TSC_XGXS_PKTGENCTRL1r_SET
#define PKTGENCTRL1r_GET BCMI_TSC_XGXS_PKTGENCTRL1r_GET
#define PKTGENCTRL1r_NUMBER_PKTf_GET BCMI_TSC_XGXS_PKTGENCTRL1r_NUMBER_PKTf_GET
#define PKTGENCTRL1r_NUMBER_PKTf_SET BCMI_TSC_XGXS_PKTGENCTRL1r_NUMBER_PKTf_SET
#define PKTGENCTRL1r_RX_PKT_CHECK_ENf_GET BCMI_TSC_XGXS_PKTGENCTRL1r_RX_PKT_CHECK_ENf_GET
#define PKTGENCTRL1r_RX_PKT_CHECK_ENf_SET BCMI_TSC_XGXS_PKTGENCTRL1r_RX_PKT_CHECK_ENf_SET
#define PKTGENCTRL1r_RX_MSBUS_TYPEf_GET BCMI_TSC_XGXS_PKTGENCTRL1r_RX_MSBUS_TYPEf_GET
#define PKTGENCTRL1r_RX_MSBUS_TYPEf_SET BCMI_TSC_XGXS_PKTGENCTRL1r_RX_MSBUS_TYPEf_SET
#define PKTGENCTRL1r_CLR_CRCCNTf_GET BCMI_TSC_XGXS_PKTGENCTRL1r_CLR_CRCCNTf_GET
#define PKTGENCTRL1r_CLR_CRCCNTf_SET BCMI_TSC_XGXS_PKTGENCTRL1r_CLR_CRCCNTf_SET
#define PKTGENCTRL1r_RX_PORT_SELf_GET BCMI_TSC_XGXS_PKTGENCTRL1r_RX_PORT_SELf_GET
#define PKTGENCTRL1r_RX_PORT_SELf_SET BCMI_TSC_XGXS_PKTGENCTRL1r_RX_PORT_SELf_SET
#define PKTGENCTRL1r_TX_PRTP_ENf_GET BCMI_TSC_XGXS_PKTGENCTRL1r_TX_PRTP_ENf_GET
#define PKTGENCTRL1r_TX_PRTP_ENf_SET BCMI_TSC_XGXS_PKTGENCTRL1r_TX_PRTP_ENf_SET
#define PKTGENCTRL1r_PRTP_DATA_PATTERN_SELf_GET BCMI_TSC_XGXS_PKTGENCTRL1r_PRTP_DATA_PATTERN_SELf_GET
#define PKTGENCTRL1r_PRTP_DATA_PATTERN_SELf_SET BCMI_TSC_XGXS_PKTGENCTRL1r_PRTP_DATA_PATTERN_SELf_SET
#define PKTGENCTRL1r_RESERVED0f_GET BCMI_TSC_XGXS_PKTGENCTRL1r_RESERVED0f_GET
#define PKTGENCTRL1r_RESERVED0f_SET BCMI_TSC_XGXS_PKTGENCTRL1r_RESERVED0f_SET
#define PKTGENCTRL1r_LPI_ENf_GET BCMI_TSC_XGXS_PKTGENCTRL1r_LPI_ENf_GET
#define PKTGENCTRL1r_LPI_ENf_SET BCMI_TSC_XGXS_PKTGENCTRL1r_LPI_ENf_SET
#define PKTGENCTRL1r_TX_TEST_PORT_SELf_GET BCMI_TSC_XGXS_PKTGENCTRL1r_TX_TEST_PORT_SELf_GET
#define PKTGENCTRL1r_TX_TEST_PORT_SELf_SET BCMI_TSC_XGXS_PKTGENCTRL1r_TX_TEST_PORT_SELf_SET
#define PKTGENCTRL1r_PKT_OR_PRTPf_GET BCMI_TSC_XGXS_PKTGENCTRL1r_PKT_OR_PRTPf_GET
#define PKTGENCTRL1r_PKT_OR_PRTPf_SET BCMI_TSC_XGXS_PKTGENCTRL1r_PKT_OR_PRTPf_SET
#define READ_PKTGENCTRL1r BCMI_TSC_XGXS_READ_PKTGENCTRL1r
#define WRITE_PKTGENCTRL1r BCMI_TSC_XGXS_WRITE_PKTGENCTRL1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_PKTGENCTRL1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  PKTGENCTRL2
 * BLOCKS:   PKTGEN0
 * REGADDR:  0x9031
 * DESC:     Packet and IPG Size: 00000000
 * SIZE:     32
 * FIELDS:
 *     IPG_SIZE         
 *     PKT_SIZE         
 *     PAYLOAD_TYPE     
 *     TX_MSBUS_TYPE    
 *     PKTGEN_EN        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_PKTGENCTRL2r (0x00109031 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_PKTGENCTRL2r_SIZE 4

/*
 * This structure should be used to declare and program PKTGENCTRL2.
 *
 */
typedef union BCMI_TSC_XGXS_PKTGENCTRL2r_s {
	uint32_t v[1];
	uint32_t pktgenctrl2[1];
	uint32_t _pktgenctrl2;
} BCMI_TSC_XGXS_PKTGENCTRL2r_t;

#define BCMI_TSC_XGXS_PKTGENCTRL2r_CLR(r) (r).pktgenctrl2[0] = 0
#define BCMI_TSC_XGXS_PKTGENCTRL2r_SET(r,d) (r).pktgenctrl2[0] = d
#define BCMI_TSC_XGXS_PKTGENCTRL2r_GET(r) (r).pktgenctrl2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_PKTGENCTRL2r_PKTGEN_ENf_GET(r) ((((r).pktgenctrl2[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_PKTGENCTRL2r_PKTGEN_ENf_SET(r,f) (r).pktgenctrl2[0]=(((r).pktgenctrl2[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_PKTGENCTRL2r_TX_MSBUS_TYPEf_GET(r) ((((r).pktgenctrl2[0]) >> 14) & 0x1)
#define BCMI_TSC_XGXS_PKTGENCTRL2r_TX_MSBUS_TYPEf_SET(r,f) (r).pktgenctrl2[0]=(((r).pktgenctrl2[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCMI_TSC_XGXS_PKTGENCTRL2r_PAYLOAD_TYPEf_GET(r) ((((r).pktgenctrl2[0]) >> 11) & 0x7)
#define BCMI_TSC_XGXS_PKTGENCTRL2r_PAYLOAD_TYPEf_SET(r,f) (r).pktgenctrl2[0]=(((r).pktgenctrl2[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11))
#define BCMI_TSC_XGXS_PKTGENCTRL2r_PKT_SIZEf_GET(r) ((((r).pktgenctrl2[0]) >> 5) & 0x3f)
#define BCMI_TSC_XGXS_PKTGENCTRL2r_PKT_SIZEf_SET(r,f) (r).pktgenctrl2[0]=(((r).pktgenctrl2[0] & ~((uint32_t)0x3f << 5)) | ((((uint32_t)f) & 0x3f) << 5))
#define BCMI_TSC_XGXS_PKTGENCTRL2r_IPG_SIZEf_GET(r) (((r).pktgenctrl2[0]) & 0x1f)
#define BCMI_TSC_XGXS_PKTGENCTRL2r_IPG_SIZEf_SET(r,f) (r).pktgenctrl2[0]=(((r).pktgenctrl2[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))

/*
 * These macros can be used to access PKTGENCTRL2.
 *
 */
#define BCMI_TSC_XGXS_READ_PKTGENCTRL2r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_PKTGENCTRL2r,(_r._pktgenctrl2))
#define BCMI_TSC_XGXS_WRITE_PKTGENCTRL2r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_PKTGENCTRL2r,(_r._pktgenctrl2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PKTGENCTRL2r BCMI_TSC_XGXS_PKTGENCTRL2r
#define PKTGENCTRL2r_SIZE BCMI_TSC_XGXS_PKTGENCTRL2r_SIZE
typedef BCMI_TSC_XGXS_PKTGENCTRL2r_t PKTGENCTRL2r_t;
#define PKTGENCTRL2r_CLR BCMI_TSC_XGXS_PKTGENCTRL2r_CLR
#define PKTGENCTRL2r_SET BCMI_TSC_XGXS_PKTGENCTRL2r_SET
#define PKTGENCTRL2r_GET BCMI_TSC_XGXS_PKTGENCTRL2r_GET
#define PKTGENCTRL2r_PKTGEN_ENf_GET BCMI_TSC_XGXS_PKTGENCTRL2r_PKTGEN_ENf_GET
#define PKTGENCTRL2r_PKTGEN_ENf_SET BCMI_TSC_XGXS_PKTGENCTRL2r_PKTGEN_ENf_SET
#define PKTGENCTRL2r_TX_MSBUS_TYPEf_GET BCMI_TSC_XGXS_PKTGENCTRL2r_TX_MSBUS_TYPEf_GET
#define PKTGENCTRL2r_TX_MSBUS_TYPEf_SET BCMI_TSC_XGXS_PKTGENCTRL2r_TX_MSBUS_TYPEf_SET
#define PKTGENCTRL2r_PAYLOAD_TYPEf_GET BCMI_TSC_XGXS_PKTGENCTRL2r_PAYLOAD_TYPEf_GET
#define PKTGENCTRL2r_PAYLOAD_TYPEf_SET BCMI_TSC_XGXS_PKTGENCTRL2r_PAYLOAD_TYPEf_SET
#define PKTGENCTRL2r_PKT_SIZEf_GET BCMI_TSC_XGXS_PKTGENCTRL2r_PKT_SIZEf_GET
#define PKTGENCTRL2r_PKT_SIZEf_SET BCMI_TSC_XGXS_PKTGENCTRL2r_PKT_SIZEf_SET
#define PKTGENCTRL2r_IPG_SIZEf_GET BCMI_TSC_XGXS_PKTGENCTRL2r_IPG_SIZEf_GET
#define PKTGENCTRL2r_IPG_SIZEf_SET BCMI_TSC_XGXS_PKTGENCTRL2r_IPG_SIZEf_SET
#define READ_PKTGENCTRL2r BCMI_TSC_XGXS_READ_PKTGENCTRL2r
#define WRITE_PKTGENCTRL2r BCMI_TSC_XGXS_WRITE_PKTGENCTRL2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_PKTGENCTRL2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  PRTPCONTROL
 * BLOCKS:   PKTGEN0
 * REGADDR:  0x9032
 * DESC:     PRTP CONTROLS: 00000000
 * SIZE:     32
 * FIELDS:
 *     PRTP_MATCH_CNT   
 *     RX_PRTP_EN       
 *     ERRGEN_EN        
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_PRTPCONTROLr (0x00109032 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_PRTPCONTROLr_SIZE 4

/*
 * This structure should be used to declare and program PRTPCONTROL.
 *
 */
typedef union BCMI_TSC_XGXS_PRTPCONTROLr_s {
	uint32_t v[1];
	uint32_t prtpcontrol[1];
	uint32_t _prtpcontrol;
} BCMI_TSC_XGXS_PRTPCONTROLr_t;

#define BCMI_TSC_XGXS_PRTPCONTROLr_CLR(r) (r).prtpcontrol[0] = 0
#define BCMI_TSC_XGXS_PRTPCONTROLr_SET(r,d) (r).prtpcontrol[0] = d
#define BCMI_TSC_XGXS_PRTPCONTROLr_GET(r) (r).prtpcontrol[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_PRTPCONTROLr_RESERVED0f_GET(r) ((((r).prtpcontrol[0]) >> 9) & 0x7f)
#define BCMI_TSC_XGXS_PRTPCONTROLr_RESERVED0f_SET(r,f) (r).prtpcontrol[0]=(((r).prtpcontrol[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))
#define BCMI_TSC_XGXS_PRTPCONTROLr_ERRGEN_ENf_GET(r) ((((r).prtpcontrol[0]) >> 5) & 0xf)
#define BCMI_TSC_XGXS_PRTPCONTROLr_ERRGEN_ENf_SET(r,f) (r).prtpcontrol[0]=(((r).prtpcontrol[0] & ~((uint32_t)0xf << 5)) | ((((uint32_t)f) & 0xf) << 5))
#define BCMI_TSC_XGXS_PRTPCONTROLr_RX_PRTP_ENf_GET(r) ((((r).prtpcontrol[0]) >> 4) & 0x1)
#define BCMI_TSC_XGXS_PRTPCONTROLr_RX_PRTP_ENf_SET(r,f) (r).prtpcontrol[0]=(((r).prtpcontrol[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCMI_TSC_XGXS_PRTPCONTROLr_PRTP_MATCH_CNTf_GET(r) (((r).prtpcontrol[0]) & 0xf)
#define BCMI_TSC_XGXS_PRTPCONTROLr_PRTP_MATCH_CNTf_SET(r,f) (r).prtpcontrol[0]=(((r).prtpcontrol[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access PRTPCONTROL.
 *
 */
#define BCMI_TSC_XGXS_READ_PRTPCONTROLr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_PRTPCONTROLr,(_r._prtpcontrol))
#define BCMI_TSC_XGXS_WRITE_PRTPCONTROLr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_PRTPCONTROLr,(_r._prtpcontrol))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PRTPCONTROLr BCMI_TSC_XGXS_PRTPCONTROLr
#define PRTPCONTROLr_SIZE BCMI_TSC_XGXS_PRTPCONTROLr_SIZE
typedef BCMI_TSC_XGXS_PRTPCONTROLr_t PRTPCONTROLr_t;
#define PRTPCONTROLr_CLR BCMI_TSC_XGXS_PRTPCONTROLr_CLR
#define PRTPCONTROLr_SET BCMI_TSC_XGXS_PRTPCONTROLr_SET
#define PRTPCONTROLr_GET BCMI_TSC_XGXS_PRTPCONTROLr_GET
#define PRTPCONTROLr_RESERVED0f_GET BCMI_TSC_XGXS_PRTPCONTROLr_RESERVED0f_GET
#define PRTPCONTROLr_RESERVED0f_SET BCMI_TSC_XGXS_PRTPCONTROLr_RESERVED0f_SET
#define PRTPCONTROLr_ERRGEN_ENf_GET BCMI_TSC_XGXS_PRTPCONTROLr_ERRGEN_ENf_GET
#define PRTPCONTROLr_ERRGEN_ENf_SET BCMI_TSC_XGXS_PRTPCONTROLr_ERRGEN_ENf_SET
#define PRTPCONTROLr_RX_PRTP_ENf_GET BCMI_TSC_XGXS_PRTPCONTROLr_RX_PRTP_ENf_GET
#define PRTPCONTROLr_RX_PRTP_ENf_SET BCMI_TSC_XGXS_PRTPCONTROLr_RX_PRTP_ENf_SET
#define PRTPCONTROLr_PRTP_MATCH_CNTf_GET BCMI_TSC_XGXS_PRTPCONTROLr_PRTP_MATCH_CNTf_GET
#define PRTPCONTROLr_PRTP_MATCH_CNTf_SET BCMI_TSC_XGXS_PRTPCONTROLr_PRTP_MATCH_CNTf_SET
#define READ_PRTPCONTROLr BCMI_TSC_XGXS_READ_PRTPCONTROLr
#define WRITE_PRTPCONTROLr BCMI_TSC_XGXS_WRITE_PRTPCONTROLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_PRTPCONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CRCERRORCOUNT
 * BLOCKS:   PKTGEN0
 * REGADDR:  0x9033
 * DESC:     CRC Error Count Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     CRCERRCNT        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CRCERRORCOUNTr (0x00109033 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CRCERRORCOUNTr_SIZE 4

/*
 * This structure should be used to declare and program CRCERRORCOUNT.
 *
 */
typedef union BCMI_TSC_XGXS_CRCERRORCOUNTr_s {
	uint32_t v[1];
	uint32_t crcerrorcount[1];
	uint32_t _crcerrorcount;
} BCMI_TSC_XGXS_CRCERRORCOUNTr_t;

#define BCMI_TSC_XGXS_CRCERRORCOUNTr_CLR(r) (r).crcerrorcount[0] = 0
#define BCMI_TSC_XGXS_CRCERRORCOUNTr_SET(r,d) (r).crcerrorcount[0] = d
#define BCMI_TSC_XGXS_CRCERRORCOUNTr_GET(r) (r).crcerrorcount[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CRCERRORCOUNTr_CRCERRCNTf_GET(r) (((r).crcerrorcount[0]) & 0xffff)
#define BCMI_TSC_XGXS_CRCERRORCOUNTr_CRCERRCNTf_SET(r,f) (r).crcerrorcount[0]=(((r).crcerrorcount[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access CRCERRORCOUNT.
 *
 */
#define BCMI_TSC_XGXS_READ_CRCERRORCOUNTr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CRCERRORCOUNTr,(_r._crcerrorcount))
#define BCMI_TSC_XGXS_WRITE_CRCERRORCOUNTr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CRCERRORCOUNTr,(_r._crcerrorcount))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CRCERRORCOUNTr BCMI_TSC_XGXS_CRCERRORCOUNTr
#define CRCERRORCOUNTr_SIZE BCMI_TSC_XGXS_CRCERRORCOUNTr_SIZE
typedef BCMI_TSC_XGXS_CRCERRORCOUNTr_t CRCERRORCOUNTr_t;
#define CRCERRORCOUNTr_CLR BCMI_TSC_XGXS_CRCERRORCOUNTr_CLR
#define CRCERRORCOUNTr_SET BCMI_TSC_XGXS_CRCERRORCOUNTr_SET
#define CRCERRORCOUNTr_GET BCMI_TSC_XGXS_CRCERRORCOUNTr_GET
#define CRCERRORCOUNTr_CRCERRCNTf_GET BCMI_TSC_XGXS_CRCERRORCOUNTr_CRCERRCNTf_GET
#define CRCERRORCOUNTr_CRCERRCNTf_SET BCMI_TSC_XGXS_CRCERRORCOUNTr_CRCERRCNTf_SET
#define READ_CRCERRORCOUNTr BCMI_TSC_XGXS_READ_CRCERRORCOUNTr
#define WRITE_CRCERRORCOUNTr BCMI_TSC_XGXS_WRITE_CRCERRORCOUNTr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CRCERRORCOUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  PRTPERRORCOUNTER
 * BLOCKS:   PKTGEN0
 * REGADDR:  0x9034
 * DESC:     PRTP Error Count Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     PRTP_ERR_COUNT   
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_PRTPERRORCOUNTERr (0x00109034 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_PRTPERRORCOUNTERr_SIZE 4

/*
 * This structure should be used to declare and program PRTPERRORCOUNTER.
 *
 */
typedef union BCMI_TSC_XGXS_PRTPERRORCOUNTERr_s {
	uint32_t v[1];
	uint32_t prtperrorcounter[1];
	uint32_t _prtperrorcounter;
} BCMI_TSC_XGXS_PRTPERRORCOUNTERr_t;

#define BCMI_TSC_XGXS_PRTPERRORCOUNTERr_CLR(r) (r).prtperrorcounter[0] = 0
#define BCMI_TSC_XGXS_PRTPERRORCOUNTERr_SET(r,d) (r).prtperrorcounter[0] = d
#define BCMI_TSC_XGXS_PRTPERRORCOUNTERr_GET(r) (r).prtperrorcounter[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_PRTPERRORCOUNTERr_PRTP_ERR_COUNTf_GET(r) (((r).prtperrorcounter[0]) & 0xffff)
#define BCMI_TSC_XGXS_PRTPERRORCOUNTERr_PRTP_ERR_COUNTf_SET(r,f) (r).prtperrorcounter[0]=(((r).prtperrorcounter[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PRTPERRORCOUNTER.
 *
 */
#define BCMI_TSC_XGXS_READ_PRTPERRORCOUNTERr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_PRTPERRORCOUNTERr,(_r._prtperrorcounter))
#define BCMI_TSC_XGXS_WRITE_PRTPERRORCOUNTERr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_PRTPERRORCOUNTERr,(_r._prtperrorcounter))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PRTPERRORCOUNTERr BCMI_TSC_XGXS_PRTPERRORCOUNTERr
#define PRTPERRORCOUNTERr_SIZE BCMI_TSC_XGXS_PRTPERRORCOUNTERr_SIZE
typedef BCMI_TSC_XGXS_PRTPERRORCOUNTERr_t PRTPERRORCOUNTERr_t;
#define PRTPERRORCOUNTERr_CLR BCMI_TSC_XGXS_PRTPERRORCOUNTERr_CLR
#define PRTPERRORCOUNTERr_SET BCMI_TSC_XGXS_PRTPERRORCOUNTERr_SET
#define PRTPERRORCOUNTERr_GET BCMI_TSC_XGXS_PRTPERRORCOUNTERr_GET
#define PRTPERRORCOUNTERr_PRTP_ERR_COUNTf_GET BCMI_TSC_XGXS_PRTPERRORCOUNTERr_PRTP_ERR_COUNTf_GET
#define PRTPERRORCOUNTERr_PRTP_ERR_COUNTf_SET BCMI_TSC_XGXS_PRTPERRORCOUNTERr_PRTP_ERR_COUNTf_SET
#define READ_PRTPERRORCOUNTERr BCMI_TSC_XGXS_READ_PRTPERRORCOUNTERr
#define WRITE_PRTPERRORCOUNTERr BCMI_TSC_XGXS_WRITE_PRTPERRORCOUNTERr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_PRTPERRORCOUNTERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  PCS_SEEDA0
 * BLOCKS:   PKTGEN0
 * REGADDR:  0x9037
 * DESC:     10GBASE-R PCS 0022 test pattern seed A word bits 15:00: 00000000
 * SIZE:     32
 * FIELDS:
 *     SEEDA0           
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_PCS_SEEDA0r (0x00109037 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_PCS_SEEDA0r_SIZE 4

/*
 * This structure should be used to declare and program PCS_SEEDA0.
 *
 */
typedef union BCMI_TSC_XGXS_PCS_SEEDA0r_s {
	uint32_t v[1];
	uint32_t pcs_seeda0[1];
	uint32_t _pcs_seeda0;
} BCMI_TSC_XGXS_PCS_SEEDA0r_t;

#define BCMI_TSC_XGXS_PCS_SEEDA0r_CLR(r) (r).pcs_seeda0[0] = 0
#define BCMI_TSC_XGXS_PCS_SEEDA0r_SET(r,d) (r).pcs_seeda0[0] = d
#define BCMI_TSC_XGXS_PCS_SEEDA0r_GET(r) (r).pcs_seeda0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_PCS_SEEDA0r_SEEDA0f_GET(r) (((r).pcs_seeda0[0]) & 0xffff)
#define BCMI_TSC_XGXS_PCS_SEEDA0r_SEEDA0f_SET(r,f) (r).pcs_seeda0[0]=(((r).pcs_seeda0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PCS_SEEDA0.
 *
 */
#define BCMI_TSC_XGXS_READ_PCS_SEEDA0r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_PCS_SEEDA0r,(_r._pcs_seeda0))
#define BCMI_TSC_XGXS_WRITE_PCS_SEEDA0r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_PCS_SEEDA0r,(_r._pcs_seeda0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PCS_SEEDA0r BCMI_TSC_XGXS_PCS_SEEDA0r
#define PCS_SEEDA0r_SIZE BCMI_TSC_XGXS_PCS_SEEDA0r_SIZE
typedef BCMI_TSC_XGXS_PCS_SEEDA0r_t PCS_SEEDA0r_t;
#define PCS_SEEDA0r_CLR BCMI_TSC_XGXS_PCS_SEEDA0r_CLR
#define PCS_SEEDA0r_SET BCMI_TSC_XGXS_PCS_SEEDA0r_SET
#define PCS_SEEDA0r_GET BCMI_TSC_XGXS_PCS_SEEDA0r_GET
#define PCS_SEEDA0r_SEEDA0f_GET BCMI_TSC_XGXS_PCS_SEEDA0r_SEEDA0f_GET
#define PCS_SEEDA0r_SEEDA0f_SET BCMI_TSC_XGXS_PCS_SEEDA0r_SEEDA0f_SET
#define READ_PCS_SEEDA0r BCMI_TSC_XGXS_READ_PCS_SEEDA0r
#define WRITE_PCS_SEEDA0r BCMI_TSC_XGXS_WRITE_PCS_SEEDA0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_PCS_SEEDA0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  PCS_SEEDA1
 * BLOCKS:   PKTGEN0
 * REGADDR:  0x9038
 * DESC:     10GBASE-R PCS 0023 test pattern seed A word bits 31:16: 00000000
 * SIZE:     32
 * FIELDS:
 *     SEEDA1           
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_PCS_SEEDA1r (0x00109038 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_PCS_SEEDA1r_SIZE 4

/*
 * This structure should be used to declare and program PCS_SEEDA1.
 *
 */
typedef union BCMI_TSC_XGXS_PCS_SEEDA1r_s {
	uint32_t v[1];
	uint32_t pcs_seeda1[1];
	uint32_t _pcs_seeda1;
} BCMI_TSC_XGXS_PCS_SEEDA1r_t;

#define BCMI_TSC_XGXS_PCS_SEEDA1r_CLR(r) (r).pcs_seeda1[0] = 0
#define BCMI_TSC_XGXS_PCS_SEEDA1r_SET(r,d) (r).pcs_seeda1[0] = d
#define BCMI_TSC_XGXS_PCS_SEEDA1r_GET(r) (r).pcs_seeda1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_PCS_SEEDA1r_SEEDA1f_GET(r) (((r).pcs_seeda1[0]) & 0xffff)
#define BCMI_TSC_XGXS_PCS_SEEDA1r_SEEDA1f_SET(r,f) (r).pcs_seeda1[0]=(((r).pcs_seeda1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PCS_SEEDA1.
 *
 */
#define BCMI_TSC_XGXS_READ_PCS_SEEDA1r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_PCS_SEEDA1r,(_r._pcs_seeda1))
#define BCMI_TSC_XGXS_WRITE_PCS_SEEDA1r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_PCS_SEEDA1r,(_r._pcs_seeda1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PCS_SEEDA1r BCMI_TSC_XGXS_PCS_SEEDA1r
#define PCS_SEEDA1r_SIZE BCMI_TSC_XGXS_PCS_SEEDA1r_SIZE
typedef BCMI_TSC_XGXS_PCS_SEEDA1r_t PCS_SEEDA1r_t;
#define PCS_SEEDA1r_CLR BCMI_TSC_XGXS_PCS_SEEDA1r_CLR
#define PCS_SEEDA1r_SET BCMI_TSC_XGXS_PCS_SEEDA1r_SET
#define PCS_SEEDA1r_GET BCMI_TSC_XGXS_PCS_SEEDA1r_GET
#define PCS_SEEDA1r_SEEDA1f_GET BCMI_TSC_XGXS_PCS_SEEDA1r_SEEDA1f_GET
#define PCS_SEEDA1r_SEEDA1f_SET BCMI_TSC_XGXS_PCS_SEEDA1r_SEEDA1f_SET
#define READ_PCS_SEEDA1r BCMI_TSC_XGXS_READ_PCS_SEEDA1r
#define WRITE_PCS_SEEDA1r BCMI_TSC_XGXS_WRITE_PCS_SEEDA1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_PCS_SEEDA1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  PCS_SEEDA2
 * BLOCKS:   PKTGEN0
 * REGADDR:  0x9039
 * DESC:     10GBASE-R PCS 0024 test pattern seed A word bits 47:32: 00000000
 * SIZE:     32
 * FIELDS:
 *     SEEDA2           
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_PCS_SEEDA2r (0x00109039 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_PCS_SEEDA2r_SIZE 4

/*
 * This structure should be used to declare and program PCS_SEEDA2.
 *
 */
typedef union BCMI_TSC_XGXS_PCS_SEEDA2r_s {
	uint32_t v[1];
	uint32_t pcs_seeda2[1];
	uint32_t _pcs_seeda2;
} BCMI_TSC_XGXS_PCS_SEEDA2r_t;

#define BCMI_TSC_XGXS_PCS_SEEDA2r_CLR(r) (r).pcs_seeda2[0] = 0
#define BCMI_TSC_XGXS_PCS_SEEDA2r_SET(r,d) (r).pcs_seeda2[0] = d
#define BCMI_TSC_XGXS_PCS_SEEDA2r_GET(r) (r).pcs_seeda2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_PCS_SEEDA2r_SEEDA2f_GET(r) (((r).pcs_seeda2[0]) & 0xffff)
#define BCMI_TSC_XGXS_PCS_SEEDA2r_SEEDA2f_SET(r,f) (r).pcs_seeda2[0]=(((r).pcs_seeda2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PCS_SEEDA2.
 *
 */
#define BCMI_TSC_XGXS_READ_PCS_SEEDA2r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_PCS_SEEDA2r,(_r._pcs_seeda2))
#define BCMI_TSC_XGXS_WRITE_PCS_SEEDA2r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_PCS_SEEDA2r,(_r._pcs_seeda2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PCS_SEEDA2r BCMI_TSC_XGXS_PCS_SEEDA2r
#define PCS_SEEDA2r_SIZE BCMI_TSC_XGXS_PCS_SEEDA2r_SIZE
typedef BCMI_TSC_XGXS_PCS_SEEDA2r_t PCS_SEEDA2r_t;
#define PCS_SEEDA2r_CLR BCMI_TSC_XGXS_PCS_SEEDA2r_CLR
#define PCS_SEEDA2r_SET BCMI_TSC_XGXS_PCS_SEEDA2r_SET
#define PCS_SEEDA2r_GET BCMI_TSC_XGXS_PCS_SEEDA2r_GET
#define PCS_SEEDA2r_SEEDA2f_GET BCMI_TSC_XGXS_PCS_SEEDA2r_SEEDA2f_GET
#define PCS_SEEDA2r_SEEDA2f_SET BCMI_TSC_XGXS_PCS_SEEDA2r_SEEDA2f_SET
#define READ_PCS_SEEDA2r BCMI_TSC_XGXS_READ_PCS_SEEDA2r
#define WRITE_PCS_SEEDA2r BCMI_TSC_XGXS_WRITE_PCS_SEEDA2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_PCS_SEEDA2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  PCS_SEEDA3
 * BLOCKS:   PKTGEN0
 * REGADDR:  0x903a
 * DESC:     10GBASE-R PCS 0025 test pattern seed A word bits 57:48: 00000000
 * SIZE:     32
 * FIELDS:
 *     SEEDA3           
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_PCS_SEEDA3r (0x0010903a | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_PCS_SEEDA3r_SIZE 4

/*
 * This structure should be used to declare and program PCS_SEEDA3.
 *
 */
typedef union BCMI_TSC_XGXS_PCS_SEEDA3r_s {
	uint32_t v[1];
	uint32_t pcs_seeda3[1];
	uint32_t _pcs_seeda3;
} BCMI_TSC_XGXS_PCS_SEEDA3r_t;

#define BCMI_TSC_XGXS_PCS_SEEDA3r_CLR(r) (r).pcs_seeda3[0] = 0
#define BCMI_TSC_XGXS_PCS_SEEDA3r_SET(r,d) (r).pcs_seeda3[0] = d
#define BCMI_TSC_XGXS_PCS_SEEDA3r_GET(r) (r).pcs_seeda3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_PCS_SEEDA3r_RESERVED0f_GET(r) ((((r).pcs_seeda3[0]) >> 10) & 0x3f)
#define BCMI_TSC_XGXS_PCS_SEEDA3r_RESERVED0f_SET(r,f) (r).pcs_seeda3[0]=(((r).pcs_seeda3[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))
#define BCMI_TSC_XGXS_PCS_SEEDA3r_SEEDA3f_GET(r) (((r).pcs_seeda3[0]) & 0x3ff)
#define BCMI_TSC_XGXS_PCS_SEEDA3r_SEEDA3f_SET(r,f) (r).pcs_seeda3[0]=(((r).pcs_seeda3[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))

/*
 * These macros can be used to access PCS_SEEDA3.
 *
 */
#define BCMI_TSC_XGXS_READ_PCS_SEEDA3r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_PCS_SEEDA3r,(_r._pcs_seeda3))
#define BCMI_TSC_XGXS_WRITE_PCS_SEEDA3r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_PCS_SEEDA3r,(_r._pcs_seeda3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PCS_SEEDA3r BCMI_TSC_XGXS_PCS_SEEDA3r
#define PCS_SEEDA3r_SIZE BCMI_TSC_XGXS_PCS_SEEDA3r_SIZE
typedef BCMI_TSC_XGXS_PCS_SEEDA3r_t PCS_SEEDA3r_t;
#define PCS_SEEDA3r_CLR BCMI_TSC_XGXS_PCS_SEEDA3r_CLR
#define PCS_SEEDA3r_SET BCMI_TSC_XGXS_PCS_SEEDA3r_SET
#define PCS_SEEDA3r_GET BCMI_TSC_XGXS_PCS_SEEDA3r_GET
#define PCS_SEEDA3r_RESERVED0f_GET BCMI_TSC_XGXS_PCS_SEEDA3r_RESERVED0f_GET
#define PCS_SEEDA3r_RESERVED0f_SET BCMI_TSC_XGXS_PCS_SEEDA3r_RESERVED0f_SET
#define PCS_SEEDA3r_SEEDA3f_GET BCMI_TSC_XGXS_PCS_SEEDA3r_SEEDA3f_GET
#define PCS_SEEDA3r_SEEDA3f_SET BCMI_TSC_XGXS_PCS_SEEDA3r_SEEDA3f_SET
#define READ_PCS_SEEDA3r BCMI_TSC_XGXS_READ_PCS_SEEDA3r
#define WRITE_PCS_SEEDA3r BCMI_TSC_XGXS_WRITE_PCS_SEEDA3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_PCS_SEEDA3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  PCS_SEEDB0
 * BLOCKS:   PKTGEN0
 * REGADDR:  0x903b
 * DESC:     10GBASE-R PCS 0026 test pattern seed B word bits 15:00: 00000000
 * SIZE:     32
 * FIELDS:
 *     SEEDB0           
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_PCS_SEEDB0r (0x0010903b | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_PCS_SEEDB0r_SIZE 4

/*
 * This structure should be used to declare and program PCS_SEEDB0.
 *
 */
typedef union BCMI_TSC_XGXS_PCS_SEEDB0r_s {
	uint32_t v[1];
	uint32_t pcs_seedb0[1];
	uint32_t _pcs_seedb0;
} BCMI_TSC_XGXS_PCS_SEEDB0r_t;

#define BCMI_TSC_XGXS_PCS_SEEDB0r_CLR(r) (r).pcs_seedb0[0] = 0
#define BCMI_TSC_XGXS_PCS_SEEDB0r_SET(r,d) (r).pcs_seedb0[0] = d
#define BCMI_TSC_XGXS_PCS_SEEDB0r_GET(r) (r).pcs_seedb0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_PCS_SEEDB0r_SEEDB0f_GET(r) (((r).pcs_seedb0[0]) & 0xffff)
#define BCMI_TSC_XGXS_PCS_SEEDB0r_SEEDB0f_SET(r,f) (r).pcs_seedb0[0]=(((r).pcs_seedb0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PCS_SEEDB0.
 *
 */
#define BCMI_TSC_XGXS_READ_PCS_SEEDB0r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_PCS_SEEDB0r,(_r._pcs_seedb0))
#define BCMI_TSC_XGXS_WRITE_PCS_SEEDB0r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_PCS_SEEDB0r,(_r._pcs_seedb0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PCS_SEEDB0r BCMI_TSC_XGXS_PCS_SEEDB0r
#define PCS_SEEDB0r_SIZE BCMI_TSC_XGXS_PCS_SEEDB0r_SIZE
typedef BCMI_TSC_XGXS_PCS_SEEDB0r_t PCS_SEEDB0r_t;
#define PCS_SEEDB0r_CLR BCMI_TSC_XGXS_PCS_SEEDB0r_CLR
#define PCS_SEEDB0r_SET BCMI_TSC_XGXS_PCS_SEEDB0r_SET
#define PCS_SEEDB0r_GET BCMI_TSC_XGXS_PCS_SEEDB0r_GET
#define PCS_SEEDB0r_SEEDB0f_GET BCMI_TSC_XGXS_PCS_SEEDB0r_SEEDB0f_GET
#define PCS_SEEDB0r_SEEDB0f_SET BCMI_TSC_XGXS_PCS_SEEDB0r_SEEDB0f_SET
#define READ_PCS_SEEDB0r BCMI_TSC_XGXS_READ_PCS_SEEDB0r
#define WRITE_PCS_SEEDB0r BCMI_TSC_XGXS_WRITE_PCS_SEEDB0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_PCS_SEEDB0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  PCS_SEEDB1
 * BLOCKS:   PKTGEN0
 * REGADDR:  0x903c
 * DESC:     10GBASE-R PCS 0027 test pattern seed B word bits 31:16: 00000000
 * SIZE:     32
 * FIELDS:
 *     SEEDB1           
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_PCS_SEEDB1r (0x0010903c | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_PCS_SEEDB1r_SIZE 4

/*
 * This structure should be used to declare and program PCS_SEEDB1.
 *
 */
typedef union BCMI_TSC_XGXS_PCS_SEEDB1r_s {
	uint32_t v[1];
	uint32_t pcs_seedb1[1];
	uint32_t _pcs_seedb1;
} BCMI_TSC_XGXS_PCS_SEEDB1r_t;

#define BCMI_TSC_XGXS_PCS_SEEDB1r_CLR(r) (r).pcs_seedb1[0] = 0
#define BCMI_TSC_XGXS_PCS_SEEDB1r_SET(r,d) (r).pcs_seedb1[0] = d
#define BCMI_TSC_XGXS_PCS_SEEDB1r_GET(r) (r).pcs_seedb1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_PCS_SEEDB1r_SEEDB1f_GET(r) (((r).pcs_seedb1[0]) & 0xffff)
#define BCMI_TSC_XGXS_PCS_SEEDB1r_SEEDB1f_SET(r,f) (r).pcs_seedb1[0]=(((r).pcs_seedb1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PCS_SEEDB1.
 *
 */
#define BCMI_TSC_XGXS_READ_PCS_SEEDB1r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_PCS_SEEDB1r,(_r._pcs_seedb1))
#define BCMI_TSC_XGXS_WRITE_PCS_SEEDB1r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_PCS_SEEDB1r,(_r._pcs_seedb1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PCS_SEEDB1r BCMI_TSC_XGXS_PCS_SEEDB1r
#define PCS_SEEDB1r_SIZE BCMI_TSC_XGXS_PCS_SEEDB1r_SIZE
typedef BCMI_TSC_XGXS_PCS_SEEDB1r_t PCS_SEEDB1r_t;
#define PCS_SEEDB1r_CLR BCMI_TSC_XGXS_PCS_SEEDB1r_CLR
#define PCS_SEEDB1r_SET BCMI_TSC_XGXS_PCS_SEEDB1r_SET
#define PCS_SEEDB1r_GET BCMI_TSC_XGXS_PCS_SEEDB1r_GET
#define PCS_SEEDB1r_SEEDB1f_GET BCMI_TSC_XGXS_PCS_SEEDB1r_SEEDB1f_GET
#define PCS_SEEDB1r_SEEDB1f_SET BCMI_TSC_XGXS_PCS_SEEDB1r_SEEDB1f_SET
#define READ_PCS_SEEDB1r BCMI_TSC_XGXS_READ_PCS_SEEDB1r
#define WRITE_PCS_SEEDB1r BCMI_TSC_XGXS_WRITE_PCS_SEEDB1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_PCS_SEEDB1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  PCS_SEEDB2
 * BLOCKS:   PKTGEN0
 * REGADDR:  0x903d
 * DESC:     10GBASE-R PCS 0028 test pattern seed B word bits 47:32: 00000000
 * SIZE:     32
 * FIELDS:
 *     SEEDB2           
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_PCS_SEEDB2r (0x0010903d | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_PCS_SEEDB2r_SIZE 4

/*
 * This structure should be used to declare and program PCS_SEEDB2.
 *
 */
typedef union BCMI_TSC_XGXS_PCS_SEEDB2r_s {
	uint32_t v[1];
	uint32_t pcs_seedb2[1];
	uint32_t _pcs_seedb2;
} BCMI_TSC_XGXS_PCS_SEEDB2r_t;

#define BCMI_TSC_XGXS_PCS_SEEDB2r_CLR(r) (r).pcs_seedb2[0] = 0
#define BCMI_TSC_XGXS_PCS_SEEDB2r_SET(r,d) (r).pcs_seedb2[0] = d
#define BCMI_TSC_XGXS_PCS_SEEDB2r_GET(r) (r).pcs_seedb2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_PCS_SEEDB2r_SEEDB2f_GET(r) (((r).pcs_seedb2[0]) & 0xffff)
#define BCMI_TSC_XGXS_PCS_SEEDB2r_SEEDB2f_SET(r,f) (r).pcs_seedb2[0]=(((r).pcs_seedb2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PCS_SEEDB2.
 *
 */
#define BCMI_TSC_XGXS_READ_PCS_SEEDB2r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_PCS_SEEDB2r,(_r._pcs_seedb2))
#define BCMI_TSC_XGXS_WRITE_PCS_SEEDB2r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_PCS_SEEDB2r,(_r._pcs_seedb2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PCS_SEEDB2r BCMI_TSC_XGXS_PCS_SEEDB2r
#define PCS_SEEDB2r_SIZE BCMI_TSC_XGXS_PCS_SEEDB2r_SIZE
typedef BCMI_TSC_XGXS_PCS_SEEDB2r_t PCS_SEEDB2r_t;
#define PCS_SEEDB2r_CLR BCMI_TSC_XGXS_PCS_SEEDB2r_CLR
#define PCS_SEEDB2r_SET BCMI_TSC_XGXS_PCS_SEEDB2r_SET
#define PCS_SEEDB2r_GET BCMI_TSC_XGXS_PCS_SEEDB2r_GET
#define PCS_SEEDB2r_SEEDB2f_GET BCMI_TSC_XGXS_PCS_SEEDB2r_SEEDB2f_GET
#define PCS_SEEDB2r_SEEDB2f_SET BCMI_TSC_XGXS_PCS_SEEDB2r_SEEDB2f_SET
#define READ_PCS_SEEDB2r BCMI_TSC_XGXS_READ_PCS_SEEDB2r
#define WRITE_PCS_SEEDB2r BCMI_TSC_XGXS_WRITE_PCS_SEEDB2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_PCS_SEEDB2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  PCS_SEEDB3
 * BLOCKS:   PKTGEN0
 * REGADDR:  0x903e
 * DESC:     10GBASE-R PCS 0029 test pattern seed B word bits 57:48: 00000000
 * SIZE:     32
 * FIELDS:
 *     SEEDB3           
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_PCS_SEEDB3r (0x0010903e | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_PCS_SEEDB3r_SIZE 4

/*
 * This structure should be used to declare and program PCS_SEEDB3.
 *
 */
typedef union BCMI_TSC_XGXS_PCS_SEEDB3r_s {
	uint32_t v[1];
	uint32_t pcs_seedb3[1];
	uint32_t _pcs_seedb3;
} BCMI_TSC_XGXS_PCS_SEEDB3r_t;

#define BCMI_TSC_XGXS_PCS_SEEDB3r_CLR(r) (r).pcs_seedb3[0] = 0
#define BCMI_TSC_XGXS_PCS_SEEDB3r_SET(r,d) (r).pcs_seedb3[0] = d
#define BCMI_TSC_XGXS_PCS_SEEDB3r_GET(r) (r).pcs_seedb3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_PCS_SEEDB3r_RESERVED0f_GET(r) ((((r).pcs_seedb3[0]) >> 10) & 0x3f)
#define BCMI_TSC_XGXS_PCS_SEEDB3r_RESERVED0f_SET(r,f) (r).pcs_seedb3[0]=(((r).pcs_seedb3[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))
#define BCMI_TSC_XGXS_PCS_SEEDB3r_SEEDB3f_GET(r) (((r).pcs_seedb3[0]) & 0x3ff)
#define BCMI_TSC_XGXS_PCS_SEEDB3r_SEEDB3f_SET(r,f) (r).pcs_seedb3[0]=(((r).pcs_seedb3[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))

/*
 * These macros can be used to access PCS_SEEDB3.
 *
 */
#define BCMI_TSC_XGXS_READ_PCS_SEEDB3r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_PCS_SEEDB3r,(_r._pcs_seedb3))
#define BCMI_TSC_XGXS_WRITE_PCS_SEEDB3r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_PCS_SEEDB3r,(_r._pcs_seedb3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PCS_SEEDB3r BCMI_TSC_XGXS_PCS_SEEDB3r
#define PCS_SEEDB3r_SIZE BCMI_TSC_XGXS_PCS_SEEDB3r_SIZE
typedef BCMI_TSC_XGXS_PCS_SEEDB3r_t PCS_SEEDB3r_t;
#define PCS_SEEDB3r_CLR BCMI_TSC_XGXS_PCS_SEEDB3r_CLR
#define PCS_SEEDB3r_SET BCMI_TSC_XGXS_PCS_SEEDB3r_SET
#define PCS_SEEDB3r_GET BCMI_TSC_XGXS_PCS_SEEDB3r_GET
#define PCS_SEEDB3r_RESERVED0f_GET BCMI_TSC_XGXS_PCS_SEEDB3r_RESERVED0f_GET
#define PCS_SEEDB3r_RESERVED0f_SET BCMI_TSC_XGXS_PCS_SEEDB3r_RESERVED0f_SET
#define PCS_SEEDB3r_SEEDB3f_GET BCMI_TSC_XGXS_PCS_SEEDB3r_SEEDB3f_GET
#define PCS_SEEDB3r_SEEDB3f_SET BCMI_TSC_XGXS_PCS_SEEDB3r_SEEDB3f_SET
#define READ_PCS_SEEDB3r BCMI_TSC_XGXS_READ_PCS_SEEDB3r
#define WRITE_PCS_SEEDB3r BCMI_TSC_XGXS_WRITE_PCS_SEEDB3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_PCS_SEEDB3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  PAYLOADBYTES
 * BLOCKS:   PKTGEN1
 * REGADDR:  0x9040
 * DESC:     Repeated Payload Bytes: 00000000
 * SIZE:     32
 * FIELDS:
 *     BYTE0            
 *     BYTE1            
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_PAYLOADBYTESr (0x00109040 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_PAYLOADBYTESr_SIZE 4

/*
 * This structure should be used to declare and program PAYLOADBYTES.
 *
 */
typedef union BCMI_TSC_XGXS_PAYLOADBYTESr_s {
	uint32_t v[1];
	uint32_t payloadbytes[1];
	uint32_t _payloadbytes;
} BCMI_TSC_XGXS_PAYLOADBYTESr_t;

#define BCMI_TSC_XGXS_PAYLOADBYTESr_CLR(r) (r).payloadbytes[0] = 0
#define BCMI_TSC_XGXS_PAYLOADBYTESr_SET(r,d) (r).payloadbytes[0] = d
#define BCMI_TSC_XGXS_PAYLOADBYTESr_GET(r) (r).payloadbytes[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_PAYLOADBYTESr_BYTE1f_GET(r) ((((r).payloadbytes[0]) >> 8) & 0xff)
#define BCMI_TSC_XGXS_PAYLOADBYTESr_BYTE1f_SET(r,f) (r).payloadbytes[0]=(((r).payloadbytes[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCMI_TSC_XGXS_PAYLOADBYTESr_BYTE0f_GET(r) (((r).payloadbytes[0]) & 0xff)
#define BCMI_TSC_XGXS_PAYLOADBYTESr_BYTE0f_SET(r,f) (r).payloadbytes[0]=(((r).payloadbytes[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access PAYLOADBYTES.
 *
 */
#define BCMI_TSC_XGXS_READ_PAYLOADBYTESr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_PAYLOADBYTESr,(_r._payloadbytes))
#define BCMI_TSC_XGXS_WRITE_PAYLOADBYTESr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_PAYLOADBYTESr,(_r._payloadbytes))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PAYLOADBYTESr BCMI_TSC_XGXS_PAYLOADBYTESr
#define PAYLOADBYTESr_SIZE BCMI_TSC_XGXS_PAYLOADBYTESr_SIZE
typedef BCMI_TSC_XGXS_PAYLOADBYTESr_t PAYLOADBYTESr_t;
#define PAYLOADBYTESr_CLR BCMI_TSC_XGXS_PAYLOADBYTESr_CLR
#define PAYLOADBYTESr_SET BCMI_TSC_XGXS_PAYLOADBYTESr_SET
#define PAYLOADBYTESr_GET BCMI_TSC_XGXS_PAYLOADBYTESr_GET
#define PAYLOADBYTESr_BYTE1f_GET BCMI_TSC_XGXS_PAYLOADBYTESr_BYTE1f_GET
#define PAYLOADBYTESr_BYTE1f_SET BCMI_TSC_XGXS_PAYLOADBYTESr_BYTE1f_SET
#define PAYLOADBYTESr_BYTE0f_GET BCMI_TSC_XGXS_PAYLOADBYTESr_BYTE0f_GET
#define PAYLOADBYTESr_BYTE0f_SET BCMI_TSC_XGXS_PAYLOADBYTESr_BYTE0f_SET
#define READ_PAYLOADBYTESr BCMI_TSC_XGXS_READ_PAYLOADBYTESr
#define WRITE_PAYLOADBYTESr BCMI_TSC_XGXS_WRITE_PAYLOADBYTESr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_PAYLOADBYTESr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  ERRORMASK4
 * BLOCKS:   PKTGEN1
 * REGADDR:  0x9041
 * DESC:     Error mask bits 79:64: 00000000
 * SIZE:     32
 * FIELDS:
 *     ERROR_MASK_79_64 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_ERRORMASK4r (0x00109041 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_ERRORMASK4r_SIZE 4

/*
 * This structure should be used to declare and program ERRORMASK4.
 *
 */
typedef union BCMI_TSC_XGXS_ERRORMASK4r_s {
	uint32_t v[1];
	uint32_t errormask4[1];
	uint32_t _errormask4;
} BCMI_TSC_XGXS_ERRORMASK4r_t;

#define BCMI_TSC_XGXS_ERRORMASK4r_CLR(r) (r).errormask4[0] = 0
#define BCMI_TSC_XGXS_ERRORMASK4r_SET(r,d) (r).errormask4[0] = d
#define BCMI_TSC_XGXS_ERRORMASK4r_GET(r) (r).errormask4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_ERRORMASK4r_ERROR_MASK_79_64f_GET(r) (((r).errormask4[0]) & 0xffff)
#define BCMI_TSC_XGXS_ERRORMASK4r_ERROR_MASK_79_64f_SET(r,f) (r).errormask4[0]=(((r).errormask4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access ERRORMASK4.
 *
 */
#define BCMI_TSC_XGXS_READ_ERRORMASK4r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_ERRORMASK4r,(_r._errormask4))
#define BCMI_TSC_XGXS_WRITE_ERRORMASK4r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_ERRORMASK4r,(_r._errormask4))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define ERRORMASK4r BCMI_TSC_XGXS_ERRORMASK4r
#define ERRORMASK4r_SIZE BCMI_TSC_XGXS_ERRORMASK4r_SIZE
typedef BCMI_TSC_XGXS_ERRORMASK4r_t ERRORMASK4r_t;
#define ERRORMASK4r_CLR BCMI_TSC_XGXS_ERRORMASK4r_CLR
#define ERRORMASK4r_SET BCMI_TSC_XGXS_ERRORMASK4r_SET
#define ERRORMASK4r_GET BCMI_TSC_XGXS_ERRORMASK4r_GET
#define ERRORMASK4r_ERROR_MASK_79_64f_GET BCMI_TSC_XGXS_ERRORMASK4r_ERROR_MASK_79_64f_GET
#define ERRORMASK4r_ERROR_MASK_79_64f_SET BCMI_TSC_XGXS_ERRORMASK4r_ERROR_MASK_79_64f_SET
#define READ_ERRORMASK4r BCMI_TSC_XGXS_READ_ERRORMASK4r
#define WRITE_ERRORMASK4r BCMI_TSC_XGXS_WRITE_ERRORMASK4r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_ERRORMASK4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  ERRORMASK3
 * BLOCKS:   PKTGEN1
 * REGADDR:  0x9042
 * DESC:     Error mask bits 63:48: 00000000
 * SIZE:     32
 * FIELDS:
 *     ERROR_MASK_63_48 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_ERRORMASK3r (0x00109042 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_ERRORMASK3r_SIZE 4

/*
 * This structure should be used to declare and program ERRORMASK3.
 *
 */
typedef union BCMI_TSC_XGXS_ERRORMASK3r_s {
	uint32_t v[1];
	uint32_t errormask3[1];
	uint32_t _errormask3;
} BCMI_TSC_XGXS_ERRORMASK3r_t;

#define BCMI_TSC_XGXS_ERRORMASK3r_CLR(r) (r).errormask3[0] = 0
#define BCMI_TSC_XGXS_ERRORMASK3r_SET(r,d) (r).errormask3[0] = d
#define BCMI_TSC_XGXS_ERRORMASK3r_GET(r) (r).errormask3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_ERRORMASK3r_ERROR_MASK_63_48f_GET(r) (((r).errormask3[0]) & 0xffff)
#define BCMI_TSC_XGXS_ERRORMASK3r_ERROR_MASK_63_48f_SET(r,f) (r).errormask3[0]=(((r).errormask3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access ERRORMASK3.
 *
 */
#define BCMI_TSC_XGXS_READ_ERRORMASK3r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_ERRORMASK3r,(_r._errormask3))
#define BCMI_TSC_XGXS_WRITE_ERRORMASK3r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_ERRORMASK3r,(_r._errormask3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define ERRORMASK3r BCMI_TSC_XGXS_ERRORMASK3r
#define ERRORMASK3r_SIZE BCMI_TSC_XGXS_ERRORMASK3r_SIZE
typedef BCMI_TSC_XGXS_ERRORMASK3r_t ERRORMASK3r_t;
#define ERRORMASK3r_CLR BCMI_TSC_XGXS_ERRORMASK3r_CLR
#define ERRORMASK3r_SET BCMI_TSC_XGXS_ERRORMASK3r_SET
#define ERRORMASK3r_GET BCMI_TSC_XGXS_ERRORMASK3r_GET
#define ERRORMASK3r_ERROR_MASK_63_48f_GET BCMI_TSC_XGXS_ERRORMASK3r_ERROR_MASK_63_48f_GET
#define ERRORMASK3r_ERROR_MASK_63_48f_SET BCMI_TSC_XGXS_ERRORMASK3r_ERROR_MASK_63_48f_SET
#define READ_ERRORMASK3r BCMI_TSC_XGXS_READ_ERRORMASK3r
#define WRITE_ERRORMASK3r BCMI_TSC_XGXS_WRITE_ERRORMASK3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_ERRORMASK3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  ERRORMASK2
 * BLOCKS:   PKTGEN1
 * REGADDR:  0x9043
 * DESC:     Error mask bits 47:32: 00000000
 * SIZE:     32
 * FIELDS:
 *     ERROR_MASK_47_32 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_ERRORMASK2r (0x00109043 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_ERRORMASK2r_SIZE 4

/*
 * This structure should be used to declare and program ERRORMASK2.
 *
 */
typedef union BCMI_TSC_XGXS_ERRORMASK2r_s {
	uint32_t v[1];
	uint32_t errormask2[1];
	uint32_t _errormask2;
} BCMI_TSC_XGXS_ERRORMASK2r_t;

#define BCMI_TSC_XGXS_ERRORMASK2r_CLR(r) (r).errormask2[0] = 0
#define BCMI_TSC_XGXS_ERRORMASK2r_SET(r,d) (r).errormask2[0] = d
#define BCMI_TSC_XGXS_ERRORMASK2r_GET(r) (r).errormask2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_ERRORMASK2r_ERROR_MASK_47_32f_GET(r) (((r).errormask2[0]) & 0xffff)
#define BCMI_TSC_XGXS_ERRORMASK2r_ERROR_MASK_47_32f_SET(r,f) (r).errormask2[0]=(((r).errormask2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access ERRORMASK2.
 *
 */
#define BCMI_TSC_XGXS_READ_ERRORMASK2r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_ERRORMASK2r,(_r._errormask2))
#define BCMI_TSC_XGXS_WRITE_ERRORMASK2r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_ERRORMASK2r,(_r._errormask2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define ERRORMASK2r BCMI_TSC_XGXS_ERRORMASK2r
#define ERRORMASK2r_SIZE BCMI_TSC_XGXS_ERRORMASK2r_SIZE
typedef BCMI_TSC_XGXS_ERRORMASK2r_t ERRORMASK2r_t;
#define ERRORMASK2r_CLR BCMI_TSC_XGXS_ERRORMASK2r_CLR
#define ERRORMASK2r_SET BCMI_TSC_XGXS_ERRORMASK2r_SET
#define ERRORMASK2r_GET BCMI_TSC_XGXS_ERRORMASK2r_GET
#define ERRORMASK2r_ERROR_MASK_47_32f_GET BCMI_TSC_XGXS_ERRORMASK2r_ERROR_MASK_47_32f_GET
#define ERRORMASK2r_ERROR_MASK_47_32f_SET BCMI_TSC_XGXS_ERRORMASK2r_ERROR_MASK_47_32f_SET
#define READ_ERRORMASK2r BCMI_TSC_XGXS_READ_ERRORMASK2r
#define WRITE_ERRORMASK2r BCMI_TSC_XGXS_WRITE_ERRORMASK2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_ERRORMASK2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  ERRORMASK1
 * BLOCKS:   PKTGEN1
 * REGADDR:  0x9044
 * DESC:     Error mask bits 31:16: 00000000
 * SIZE:     32
 * FIELDS:
 *     ERROR_MASK_31_16 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_ERRORMASK1r (0x00109044 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_ERRORMASK1r_SIZE 4

/*
 * This structure should be used to declare and program ERRORMASK1.
 *
 */
typedef union BCMI_TSC_XGXS_ERRORMASK1r_s {
	uint32_t v[1];
	uint32_t errormask1[1];
	uint32_t _errormask1;
} BCMI_TSC_XGXS_ERRORMASK1r_t;

#define BCMI_TSC_XGXS_ERRORMASK1r_CLR(r) (r).errormask1[0] = 0
#define BCMI_TSC_XGXS_ERRORMASK1r_SET(r,d) (r).errormask1[0] = d
#define BCMI_TSC_XGXS_ERRORMASK1r_GET(r) (r).errormask1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_ERRORMASK1r_ERROR_MASK_31_16f_GET(r) (((r).errormask1[0]) & 0xffff)
#define BCMI_TSC_XGXS_ERRORMASK1r_ERROR_MASK_31_16f_SET(r,f) (r).errormask1[0]=(((r).errormask1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access ERRORMASK1.
 *
 */
#define BCMI_TSC_XGXS_READ_ERRORMASK1r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_ERRORMASK1r,(_r._errormask1))
#define BCMI_TSC_XGXS_WRITE_ERRORMASK1r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_ERRORMASK1r,(_r._errormask1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define ERRORMASK1r BCMI_TSC_XGXS_ERRORMASK1r
#define ERRORMASK1r_SIZE BCMI_TSC_XGXS_ERRORMASK1r_SIZE
typedef BCMI_TSC_XGXS_ERRORMASK1r_t ERRORMASK1r_t;
#define ERRORMASK1r_CLR BCMI_TSC_XGXS_ERRORMASK1r_CLR
#define ERRORMASK1r_SET BCMI_TSC_XGXS_ERRORMASK1r_SET
#define ERRORMASK1r_GET BCMI_TSC_XGXS_ERRORMASK1r_GET
#define ERRORMASK1r_ERROR_MASK_31_16f_GET BCMI_TSC_XGXS_ERRORMASK1r_ERROR_MASK_31_16f_GET
#define ERRORMASK1r_ERROR_MASK_31_16f_SET BCMI_TSC_XGXS_ERRORMASK1r_ERROR_MASK_31_16f_SET
#define READ_ERRORMASK1r BCMI_TSC_XGXS_READ_ERRORMASK1r
#define WRITE_ERRORMASK1r BCMI_TSC_XGXS_WRITE_ERRORMASK1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_ERRORMASK1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  ERRORMASK0
 * BLOCKS:   PKTGEN1
 * REGADDR:  0x9045
 * DESC:     Error mask bits 15:0: 00000000
 * SIZE:     32
 * FIELDS:
 *     ERROR_MASK_15_0  
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_ERRORMASK0r (0x00109045 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_ERRORMASK0r_SIZE 4

/*
 * This structure should be used to declare and program ERRORMASK0.
 *
 */
typedef union BCMI_TSC_XGXS_ERRORMASK0r_s {
	uint32_t v[1];
	uint32_t errormask0[1];
	uint32_t _errormask0;
} BCMI_TSC_XGXS_ERRORMASK0r_t;

#define BCMI_TSC_XGXS_ERRORMASK0r_CLR(r) (r).errormask0[0] = 0
#define BCMI_TSC_XGXS_ERRORMASK0r_SET(r,d) (r).errormask0[0] = d
#define BCMI_TSC_XGXS_ERRORMASK0r_GET(r) (r).errormask0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_ERRORMASK0r_ERROR_MASK_15_0f_GET(r) (((r).errormask0[0]) & 0xffff)
#define BCMI_TSC_XGXS_ERRORMASK0r_ERROR_MASK_15_0f_SET(r,f) (r).errormask0[0]=(((r).errormask0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access ERRORMASK0.
 *
 */
#define BCMI_TSC_XGXS_READ_ERRORMASK0r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_ERRORMASK0r,(_r._errormask0))
#define BCMI_TSC_XGXS_WRITE_ERRORMASK0r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_ERRORMASK0r,(_r._errormask0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define ERRORMASK0r BCMI_TSC_XGXS_ERRORMASK0r
#define ERRORMASK0r_SIZE BCMI_TSC_XGXS_ERRORMASK0r_SIZE
typedef BCMI_TSC_XGXS_ERRORMASK0r_t ERRORMASK0r_t;
#define ERRORMASK0r_CLR BCMI_TSC_XGXS_ERRORMASK0r_CLR
#define ERRORMASK0r_SET BCMI_TSC_XGXS_ERRORMASK0r_SET
#define ERRORMASK0r_GET BCMI_TSC_XGXS_ERRORMASK0r_GET
#define ERRORMASK0r_ERROR_MASK_15_0f_GET BCMI_TSC_XGXS_ERRORMASK0r_ERROR_MASK_15_0f_GET
#define ERRORMASK0r_ERROR_MASK_15_0f_SET BCMI_TSC_XGXS_ERRORMASK0r_ERROR_MASK_15_0f_SET
#define READ_ERRORMASK0r BCMI_TSC_XGXS_READ_ERRORMASK0r
#define WRITE_ERRORMASK0r BCMI_TSC_XGXS_WRITE_ERRORMASK0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_ERRORMASK0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  PRTP_TEST_COUNTS
 * BLOCKS:   PKTGEN1
 * REGADDR:  0x9046
 * DESC:     test control register: 00000000
 * SIZE:     32
 * FIELDS:
 *     BLOCK_CNT        
 *     SYNC_CNT         
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_PRTP_TEST_COUNTSr (0x00109046 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_PRTP_TEST_COUNTSr_SIZE 4

/*
 * This structure should be used to declare and program PRTP_TEST_COUNTS.
 *
 */
typedef union BCMI_TSC_XGXS_PRTP_TEST_COUNTSr_s {
	uint32_t v[1];
	uint32_t prtp_test_counts[1];
	uint32_t _prtp_test_counts;
} BCMI_TSC_XGXS_PRTP_TEST_COUNTSr_t;

#define BCMI_TSC_XGXS_PRTP_TEST_COUNTSr_CLR(r) (r).prtp_test_counts[0] = 0
#define BCMI_TSC_XGXS_PRTP_TEST_COUNTSr_SET(r,d) (r).prtp_test_counts[0] = d
#define BCMI_TSC_XGXS_PRTP_TEST_COUNTSr_GET(r) (r).prtp_test_counts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_PRTP_TEST_COUNTSr_SYNC_CNTf_GET(r) ((((r).prtp_test_counts[0]) >> 8) & 0xff)
#define BCMI_TSC_XGXS_PRTP_TEST_COUNTSr_SYNC_CNTf_SET(r,f) (r).prtp_test_counts[0]=(((r).prtp_test_counts[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCMI_TSC_XGXS_PRTP_TEST_COUNTSr_BLOCK_CNTf_GET(r) (((r).prtp_test_counts[0]) & 0xff)
#define BCMI_TSC_XGXS_PRTP_TEST_COUNTSr_BLOCK_CNTf_SET(r,f) (r).prtp_test_counts[0]=(((r).prtp_test_counts[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access PRTP_TEST_COUNTS.
 *
 */
#define BCMI_TSC_XGXS_READ_PRTP_TEST_COUNTSr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_PRTP_TEST_COUNTSr,(_r._prtp_test_counts))
#define BCMI_TSC_XGXS_WRITE_PRTP_TEST_COUNTSr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_PRTP_TEST_COUNTSr,(_r._prtp_test_counts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PRTP_TEST_COUNTSr BCMI_TSC_XGXS_PRTP_TEST_COUNTSr
#define PRTP_TEST_COUNTSr_SIZE BCMI_TSC_XGXS_PRTP_TEST_COUNTSr_SIZE
typedef BCMI_TSC_XGXS_PRTP_TEST_COUNTSr_t PRTP_TEST_COUNTSr_t;
#define PRTP_TEST_COUNTSr_CLR BCMI_TSC_XGXS_PRTP_TEST_COUNTSr_CLR
#define PRTP_TEST_COUNTSr_SET BCMI_TSC_XGXS_PRTP_TEST_COUNTSr_SET
#define PRTP_TEST_COUNTSr_GET BCMI_TSC_XGXS_PRTP_TEST_COUNTSr_GET
#define PRTP_TEST_COUNTSr_SYNC_CNTf_GET BCMI_TSC_XGXS_PRTP_TEST_COUNTSr_SYNC_CNTf_GET
#define PRTP_TEST_COUNTSr_SYNC_CNTf_SET BCMI_TSC_XGXS_PRTP_TEST_COUNTSr_SYNC_CNTf_SET
#define PRTP_TEST_COUNTSr_BLOCK_CNTf_GET BCMI_TSC_XGXS_PRTP_TEST_COUNTSr_BLOCK_CNTf_GET
#define PRTP_TEST_COUNTSr_BLOCK_CNTf_SET BCMI_TSC_XGXS_PRTP_TEST_COUNTSr_BLOCK_CNTf_SET
#define READ_PRTP_TEST_COUNTSr BCMI_TSC_XGXS_READ_PRTP_TEST_COUNTSr
#define WRITE_PRTP_TEST_COUNTSr BCMI_TSC_XGXS_WRITE_PRTP_TEST_COUNTSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_PRTP_TEST_COUNTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  PATGEN0
 * BLOCKS:   PATGEN_256_0
 * REGADDR:  0x9050
 * DESC:     Pattern Genertor 0 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     REG0             
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_PATGEN0r (0x00109050 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_PATGEN0r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN0.
 *
 */
typedef union BCMI_TSC_XGXS_PATGEN0r_s {
	uint32_t v[1];
	uint32_t patgen0[1];
	uint32_t _patgen0;
} BCMI_TSC_XGXS_PATGEN0r_t;

#define BCMI_TSC_XGXS_PATGEN0r_CLR(r) (r).patgen0[0] = 0
#define BCMI_TSC_XGXS_PATGEN0r_SET(r,d) (r).patgen0[0] = d
#define BCMI_TSC_XGXS_PATGEN0r_GET(r) (r).patgen0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_PATGEN0r_REG0f_GET(r) (((r).patgen0[0]) & 0xffff)
#define BCMI_TSC_XGXS_PATGEN0r_REG0f_SET(r,f) (r).patgen0[0]=(((r).patgen0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PATGEN0.
 *
 */
#define BCMI_TSC_XGXS_READ_PATGEN0r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_PATGEN0r,(_r._patgen0))
#define BCMI_TSC_XGXS_WRITE_PATGEN0r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_PATGEN0r,(_r._patgen0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PATGEN0r BCMI_TSC_XGXS_PATGEN0r
#define PATGEN0r_SIZE BCMI_TSC_XGXS_PATGEN0r_SIZE
typedef BCMI_TSC_XGXS_PATGEN0r_t PATGEN0r_t;
#define PATGEN0r_CLR BCMI_TSC_XGXS_PATGEN0r_CLR
#define PATGEN0r_SET BCMI_TSC_XGXS_PATGEN0r_SET
#define PATGEN0r_GET BCMI_TSC_XGXS_PATGEN0r_GET
#define PATGEN0r_REG0f_GET BCMI_TSC_XGXS_PATGEN0r_REG0f_GET
#define PATGEN0r_REG0f_SET BCMI_TSC_XGXS_PATGEN0r_REG0f_SET
#define READ_PATGEN0r BCMI_TSC_XGXS_READ_PATGEN0r
#define WRITE_PATGEN0r BCMI_TSC_XGXS_WRITE_PATGEN0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_PATGEN0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  PATGEN1
 * BLOCKS:   PATGEN_256_0
 * REGADDR:  0x9051
 * DESC:     Pattern Genertor 1 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     REG1             
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_PATGEN1r (0x00109051 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_PATGEN1r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN1.
 *
 */
typedef union BCMI_TSC_XGXS_PATGEN1r_s {
	uint32_t v[1];
	uint32_t patgen1[1];
	uint32_t _patgen1;
} BCMI_TSC_XGXS_PATGEN1r_t;

#define BCMI_TSC_XGXS_PATGEN1r_CLR(r) (r).patgen1[0] = 0
#define BCMI_TSC_XGXS_PATGEN1r_SET(r,d) (r).patgen1[0] = d
#define BCMI_TSC_XGXS_PATGEN1r_GET(r) (r).patgen1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_PATGEN1r_REG1f_GET(r) (((r).patgen1[0]) & 0xffff)
#define BCMI_TSC_XGXS_PATGEN1r_REG1f_SET(r,f) (r).patgen1[0]=(((r).patgen1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PATGEN1.
 *
 */
#define BCMI_TSC_XGXS_READ_PATGEN1r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_PATGEN1r,(_r._patgen1))
#define BCMI_TSC_XGXS_WRITE_PATGEN1r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_PATGEN1r,(_r._patgen1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PATGEN1r BCMI_TSC_XGXS_PATGEN1r
#define PATGEN1r_SIZE BCMI_TSC_XGXS_PATGEN1r_SIZE
typedef BCMI_TSC_XGXS_PATGEN1r_t PATGEN1r_t;
#define PATGEN1r_CLR BCMI_TSC_XGXS_PATGEN1r_CLR
#define PATGEN1r_SET BCMI_TSC_XGXS_PATGEN1r_SET
#define PATGEN1r_GET BCMI_TSC_XGXS_PATGEN1r_GET
#define PATGEN1r_REG1f_GET BCMI_TSC_XGXS_PATGEN1r_REG1f_GET
#define PATGEN1r_REG1f_SET BCMI_TSC_XGXS_PATGEN1r_REG1f_SET
#define READ_PATGEN1r BCMI_TSC_XGXS_READ_PATGEN1r
#define WRITE_PATGEN1r BCMI_TSC_XGXS_WRITE_PATGEN1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_PATGEN1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  PATGEN2
 * BLOCKS:   PATGEN_256_0
 * REGADDR:  0x9052
 * DESC:     Pattern Genertor 2 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     REG2             
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_PATGEN2r (0x00109052 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_PATGEN2r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN2.
 *
 */
typedef union BCMI_TSC_XGXS_PATGEN2r_s {
	uint32_t v[1];
	uint32_t patgen2[1];
	uint32_t _patgen2;
} BCMI_TSC_XGXS_PATGEN2r_t;

#define BCMI_TSC_XGXS_PATGEN2r_CLR(r) (r).patgen2[0] = 0
#define BCMI_TSC_XGXS_PATGEN2r_SET(r,d) (r).patgen2[0] = d
#define BCMI_TSC_XGXS_PATGEN2r_GET(r) (r).patgen2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_PATGEN2r_REG2f_GET(r) (((r).patgen2[0]) & 0xffff)
#define BCMI_TSC_XGXS_PATGEN2r_REG2f_SET(r,f) (r).patgen2[0]=(((r).patgen2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PATGEN2.
 *
 */
#define BCMI_TSC_XGXS_READ_PATGEN2r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_PATGEN2r,(_r._patgen2))
#define BCMI_TSC_XGXS_WRITE_PATGEN2r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_PATGEN2r,(_r._patgen2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PATGEN2r BCMI_TSC_XGXS_PATGEN2r
#define PATGEN2r_SIZE BCMI_TSC_XGXS_PATGEN2r_SIZE
typedef BCMI_TSC_XGXS_PATGEN2r_t PATGEN2r_t;
#define PATGEN2r_CLR BCMI_TSC_XGXS_PATGEN2r_CLR
#define PATGEN2r_SET BCMI_TSC_XGXS_PATGEN2r_SET
#define PATGEN2r_GET BCMI_TSC_XGXS_PATGEN2r_GET
#define PATGEN2r_REG2f_GET BCMI_TSC_XGXS_PATGEN2r_REG2f_GET
#define PATGEN2r_REG2f_SET BCMI_TSC_XGXS_PATGEN2r_REG2f_SET
#define READ_PATGEN2r BCMI_TSC_XGXS_READ_PATGEN2r
#define WRITE_PATGEN2r BCMI_TSC_XGXS_WRITE_PATGEN2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_PATGEN2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  PATGEN3
 * BLOCKS:   PATGEN_256_0
 * REGADDR:  0x9053
 * DESC:     Pattern Genertor 3 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     REG3             
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_PATGEN3r (0x00109053 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_PATGEN3r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN3.
 *
 */
typedef union BCMI_TSC_XGXS_PATGEN3r_s {
	uint32_t v[1];
	uint32_t patgen3[1];
	uint32_t _patgen3;
} BCMI_TSC_XGXS_PATGEN3r_t;

#define BCMI_TSC_XGXS_PATGEN3r_CLR(r) (r).patgen3[0] = 0
#define BCMI_TSC_XGXS_PATGEN3r_SET(r,d) (r).patgen3[0] = d
#define BCMI_TSC_XGXS_PATGEN3r_GET(r) (r).patgen3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_PATGEN3r_REG3f_GET(r) (((r).patgen3[0]) & 0xffff)
#define BCMI_TSC_XGXS_PATGEN3r_REG3f_SET(r,f) (r).patgen3[0]=(((r).patgen3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PATGEN3.
 *
 */
#define BCMI_TSC_XGXS_READ_PATGEN3r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_PATGEN3r,(_r._patgen3))
#define BCMI_TSC_XGXS_WRITE_PATGEN3r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_PATGEN3r,(_r._patgen3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PATGEN3r BCMI_TSC_XGXS_PATGEN3r
#define PATGEN3r_SIZE BCMI_TSC_XGXS_PATGEN3r_SIZE
typedef BCMI_TSC_XGXS_PATGEN3r_t PATGEN3r_t;
#define PATGEN3r_CLR BCMI_TSC_XGXS_PATGEN3r_CLR
#define PATGEN3r_SET BCMI_TSC_XGXS_PATGEN3r_SET
#define PATGEN3r_GET BCMI_TSC_XGXS_PATGEN3r_GET
#define PATGEN3r_REG3f_GET BCMI_TSC_XGXS_PATGEN3r_REG3f_GET
#define PATGEN3r_REG3f_SET BCMI_TSC_XGXS_PATGEN3r_REG3f_SET
#define READ_PATGEN3r BCMI_TSC_XGXS_READ_PATGEN3r
#define WRITE_PATGEN3r BCMI_TSC_XGXS_WRITE_PATGEN3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_PATGEN3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  PATGEN4
 * BLOCKS:   PATGEN_256_0
 * REGADDR:  0x9054
 * DESC:     Pattern Genertor 4 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     REG4             
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_PATGEN4r (0x00109054 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_PATGEN4r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN4.
 *
 */
typedef union BCMI_TSC_XGXS_PATGEN4r_s {
	uint32_t v[1];
	uint32_t patgen4[1];
	uint32_t _patgen4;
} BCMI_TSC_XGXS_PATGEN4r_t;

#define BCMI_TSC_XGXS_PATGEN4r_CLR(r) (r).patgen4[0] = 0
#define BCMI_TSC_XGXS_PATGEN4r_SET(r,d) (r).patgen4[0] = d
#define BCMI_TSC_XGXS_PATGEN4r_GET(r) (r).patgen4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_PATGEN4r_REG4f_GET(r) (((r).patgen4[0]) & 0xffff)
#define BCMI_TSC_XGXS_PATGEN4r_REG4f_SET(r,f) (r).patgen4[0]=(((r).patgen4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PATGEN4.
 *
 */
#define BCMI_TSC_XGXS_READ_PATGEN4r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_PATGEN4r,(_r._patgen4))
#define BCMI_TSC_XGXS_WRITE_PATGEN4r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_PATGEN4r,(_r._patgen4))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PATGEN4r BCMI_TSC_XGXS_PATGEN4r
#define PATGEN4r_SIZE BCMI_TSC_XGXS_PATGEN4r_SIZE
typedef BCMI_TSC_XGXS_PATGEN4r_t PATGEN4r_t;
#define PATGEN4r_CLR BCMI_TSC_XGXS_PATGEN4r_CLR
#define PATGEN4r_SET BCMI_TSC_XGXS_PATGEN4r_SET
#define PATGEN4r_GET BCMI_TSC_XGXS_PATGEN4r_GET
#define PATGEN4r_REG4f_GET BCMI_TSC_XGXS_PATGEN4r_REG4f_GET
#define PATGEN4r_REG4f_SET BCMI_TSC_XGXS_PATGEN4r_REG4f_SET
#define READ_PATGEN4r BCMI_TSC_XGXS_READ_PATGEN4r
#define WRITE_PATGEN4r BCMI_TSC_XGXS_WRITE_PATGEN4r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_PATGEN4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  PATGEN5
 * BLOCKS:   PATGEN_256_0
 * REGADDR:  0x9055
 * DESC:     Pattern Genertor 5 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     REG5             
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_PATGEN5r (0x00109055 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_PATGEN5r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN5.
 *
 */
typedef union BCMI_TSC_XGXS_PATGEN5r_s {
	uint32_t v[1];
	uint32_t patgen5[1];
	uint32_t _patgen5;
} BCMI_TSC_XGXS_PATGEN5r_t;

#define BCMI_TSC_XGXS_PATGEN5r_CLR(r) (r).patgen5[0] = 0
#define BCMI_TSC_XGXS_PATGEN5r_SET(r,d) (r).patgen5[0] = d
#define BCMI_TSC_XGXS_PATGEN5r_GET(r) (r).patgen5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_PATGEN5r_REG5f_GET(r) (((r).patgen5[0]) & 0xffff)
#define BCMI_TSC_XGXS_PATGEN5r_REG5f_SET(r,f) (r).patgen5[0]=(((r).patgen5[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PATGEN5.
 *
 */
#define BCMI_TSC_XGXS_READ_PATGEN5r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_PATGEN5r,(_r._patgen5))
#define BCMI_TSC_XGXS_WRITE_PATGEN5r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_PATGEN5r,(_r._patgen5))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PATGEN5r BCMI_TSC_XGXS_PATGEN5r
#define PATGEN5r_SIZE BCMI_TSC_XGXS_PATGEN5r_SIZE
typedef BCMI_TSC_XGXS_PATGEN5r_t PATGEN5r_t;
#define PATGEN5r_CLR BCMI_TSC_XGXS_PATGEN5r_CLR
#define PATGEN5r_SET BCMI_TSC_XGXS_PATGEN5r_SET
#define PATGEN5r_GET BCMI_TSC_XGXS_PATGEN5r_GET
#define PATGEN5r_REG5f_GET BCMI_TSC_XGXS_PATGEN5r_REG5f_GET
#define PATGEN5r_REG5f_SET BCMI_TSC_XGXS_PATGEN5r_REG5f_SET
#define READ_PATGEN5r BCMI_TSC_XGXS_READ_PATGEN5r
#define WRITE_PATGEN5r BCMI_TSC_XGXS_WRITE_PATGEN5r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_PATGEN5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  PATGEN6
 * BLOCKS:   PATGEN_256_0
 * REGADDR:  0x9056
 * DESC:     Pattern Genertor 6 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     REG6             
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_PATGEN6r (0x00109056 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_PATGEN6r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN6.
 *
 */
typedef union BCMI_TSC_XGXS_PATGEN6r_s {
	uint32_t v[1];
	uint32_t patgen6[1];
	uint32_t _patgen6;
} BCMI_TSC_XGXS_PATGEN6r_t;

#define BCMI_TSC_XGXS_PATGEN6r_CLR(r) (r).patgen6[0] = 0
#define BCMI_TSC_XGXS_PATGEN6r_SET(r,d) (r).patgen6[0] = d
#define BCMI_TSC_XGXS_PATGEN6r_GET(r) (r).patgen6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_PATGEN6r_REG6f_GET(r) (((r).patgen6[0]) & 0xffff)
#define BCMI_TSC_XGXS_PATGEN6r_REG6f_SET(r,f) (r).patgen6[0]=(((r).patgen6[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PATGEN6.
 *
 */
#define BCMI_TSC_XGXS_READ_PATGEN6r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_PATGEN6r,(_r._patgen6))
#define BCMI_TSC_XGXS_WRITE_PATGEN6r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_PATGEN6r,(_r._patgen6))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PATGEN6r BCMI_TSC_XGXS_PATGEN6r
#define PATGEN6r_SIZE BCMI_TSC_XGXS_PATGEN6r_SIZE
typedef BCMI_TSC_XGXS_PATGEN6r_t PATGEN6r_t;
#define PATGEN6r_CLR BCMI_TSC_XGXS_PATGEN6r_CLR
#define PATGEN6r_SET BCMI_TSC_XGXS_PATGEN6r_SET
#define PATGEN6r_GET BCMI_TSC_XGXS_PATGEN6r_GET
#define PATGEN6r_REG6f_GET BCMI_TSC_XGXS_PATGEN6r_REG6f_GET
#define PATGEN6r_REG6f_SET BCMI_TSC_XGXS_PATGEN6r_REG6f_SET
#define READ_PATGEN6r BCMI_TSC_XGXS_READ_PATGEN6r
#define WRITE_PATGEN6r BCMI_TSC_XGXS_WRITE_PATGEN6r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_PATGEN6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  PATGEN7
 * BLOCKS:   PATGEN_256_0
 * REGADDR:  0x9057
 * DESC:     Pattern Genertor 7 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     REG7             
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_PATGEN7r (0x00109057 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_PATGEN7r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN7.
 *
 */
typedef union BCMI_TSC_XGXS_PATGEN7r_s {
	uint32_t v[1];
	uint32_t patgen7[1];
	uint32_t _patgen7;
} BCMI_TSC_XGXS_PATGEN7r_t;

#define BCMI_TSC_XGXS_PATGEN7r_CLR(r) (r).patgen7[0] = 0
#define BCMI_TSC_XGXS_PATGEN7r_SET(r,d) (r).patgen7[0] = d
#define BCMI_TSC_XGXS_PATGEN7r_GET(r) (r).patgen7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_PATGEN7r_REG7f_GET(r) (((r).patgen7[0]) & 0xffff)
#define BCMI_TSC_XGXS_PATGEN7r_REG7f_SET(r,f) (r).patgen7[0]=(((r).patgen7[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PATGEN7.
 *
 */
#define BCMI_TSC_XGXS_READ_PATGEN7r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_PATGEN7r,(_r._patgen7))
#define BCMI_TSC_XGXS_WRITE_PATGEN7r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_PATGEN7r,(_r._patgen7))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PATGEN7r BCMI_TSC_XGXS_PATGEN7r
#define PATGEN7r_SIZE BCMI_TSC_XGXS_PATGEN7r_SIZE
typedef BCMI_TSC_XGXS_PATGEN7r_t PATGEN7r_t;
#define PATGEN7r_CLR BCMI_TSC_XGXS_PATGEN7r_CLR
#define PATGEN7r_SET BCMI_TSC_XGXS_PATGEN7r_SET
#define PATGEN7r_GET BCMI_TSC_XGXS_PATGEN7r_GET
#define PATGEN7r_REG7f_GET BCMI_TSC_XGXS_PATGEN7r_REG7f_GET
#define PATGEN7r_REG7f_SET BCMI_TSC_XGXS_PATGEN7r_REG7f_SET
#define READ_PATGEN7r BCMI_TSC_XGXS_READ_PATGEN7r
#define WRITE_PATGEN7r BCMI_TSC_XGXS_WRITE_PATGEN7r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_PATGEN7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  PATGEN8
 * BLOCKS:   PATGEN_256_0
 * REGADDR:  0x9058
 * DESC:     Pattern Genertor 8 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     REG8             
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_PATGEN8r (0x00109058 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_PATGEN8r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN8.
 *
 */
typedef union BCMI_TSC_XGXS_PATGEN8r_s {
	uint32_t v[1];
	uint32_t patgen8[1];
	uint32_t _patgen8;
} BCMI_TSC_XGXS_PATGEN8r_t;

#define BCMI_TSC_XGXS_PATGEN8r_CLR(r) (r).patgen8[0] = 0
#define BCMI_TSC_XGXS_PATGEN8r_SET(r,d) (r).patgen8[0] = d
#define BCMI_TSC_XGXS_PATGEN8r_GET(r) (r).patgen8[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_PATGEN8r_REG8f_GET(r) (((r).patgen8[0]) & 0xffff)
#define BCMI_TSC_XGXS_PATGEN8r_REG8f_SET(r,f) (r).patgen8[0]=(((r).patgen8[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PATGEN8.
 *
 */
#define BCMI_TSC_XGXS_READ_PATGEN8r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_PATGEN8r,(_r._patgen8))
#define BCMI_TSC_XGXS_WRITE_PATGEN8r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_PATGEN8r,(_r._patgen8))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PATGEN8r BCMI_TSC_XGXS_PATGEN8r
#define PATGEN8r_SIZE BCMI_TSC_XGXS_PATGEN8r_SIZE
typedef BCMI_TSC_XGXS_PATGEN8r_t PATGEN8r_t;
#define PATGEN8r_CLR BCMI_TSC_XGXS_PATGEN8r_CLR
#define PATGEN8r_SET BCMI_TSC_XGXS_PATGEN8r_SET
#define PATGEN8r_GET BCMI_TSC_XGXS_PATGEN8r_GET
#define PATGEN8r_REG8f_GET BCMI_TSC_XGXS_PATGEN8r_REG8f_GET
#define PATGEN8r_REG8f_SET BCMI_TSC_XGXS_PATGEN8r_REG8f_SET
#define READ_PATGEN8r BCMI_TSC_XGXS_READ_PATGEN8r
#define WRITE_PATGEN8r BCMI_TSC_XGXS_WRITE_PATGEN8r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_PATGEN8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  PATGEN9
 * BLOCKS:   PATGEN_256_0
 * REGADDR:  0x9059
 * DESC:     Pattern Genertor 9 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     REG9             
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_PATGEN9r (0x00109059 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_PATGEN9r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN9.
 *
 */
typedef union BCMI_TSC_XGXS_PATGEN9r_s {
	uint32_t v[1];
	uint32_t patgen9[1];
	uint32_t _patgen9;
} BCMI_TSC_XGXS_PATGEN9r_t;

#define BCMI_TSC_XGXS_PATGEN9r_CLR(r) (r).patgen9[0] = 0
#define BCMI_TSC_XGXS_PATGEN9r_SET(r,d) (r).patgen9[0] = d
#define BCMI_TSC_XGXS_PATGEN9r_GET(r) (r).patgen9[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_PATGEN9r_REG9f_GET(r) (((r).patgen9[0]) & 0xffff)
#define BCMI_TSC_XGXS_PATGEN9r_REG9f_SET(r,f) (r).patgen9[0]=(((r).patgen9[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PATGEN9.
 *
 */
#define BCMI_TSC_XGXS_READ_PATGEN9r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_PATGEN9r,(_r._patgen9))
#define BCMI_TSC_XGXS_WRITE_PATGEN9r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_PATGEN9r,(_r._patgen9))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PATGEN9r BCMI_TSC_XGXS_PATGEN9r
#define PATGEN9r_SIZE BCMI_TSC_XGXS_PATGEN9r_SIZE
typedef BCMI_TSC_XGXS_PATGEN9r_t PATGEN9r_t;
#define PATGEN9r_CLR BCMI_TSC_XGXS_PATGEN9r_CLR
#define PATGEN9r_SET BCMI_TSC_XGXS_PATGEN9r_SET
#define PATGEN9r_GET BCMI_TSC_XGXS_PATGEN9r_GET
#define PATGEN9r_REG9f_GET BCMI_TSC_XGXS_PATGEN9r_REG9f_GET
#define PATGEN9r_REG9f_SET BCMI_TSC_XGXS_PATGEN9r_REG9f_SET
#define READ_PATGEN9r BCMI_TSC_XGXS_READ_PATGEN9r
#define WRITE_PATGEN9r BCMI_TSC_XGXS_WRITE_PATGEN9r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_PATGEN9r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  PATGEN10
 * BLOCKS:   PATGEN_256_0
 * REGADDR:  0x905a
 * DESC:     Pattern Genertor 10 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     REG10            
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_PATGEN10r (0x0010905a | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_PATGEN10r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN10.
 *
 */
typedef union BCMI_TSC_XGXS_PATGEN10r_s {
	uint32_t v[1];
	uint32_t patgen10[1];
	uint32_t _patgen10;
} BCMI_TSC_XGXS_PATGEN10r_t;

#define BCMI_TSC_XGXS_PATGEN10r_CLR(r) (r).patgen10[0] = 0
#define BCMI_TSC_XGXS_PATGEN10r_SET(r,d) (r).patgen10[0] = d
#define BCMI_TSC_XGXS_PATGEN10r_GET(r) (r).patgen10[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_PATGEN10r_REG10f_GET(r) (((r).patgen10[0]) & 0xffff)
#define BCMI_TSC_XGXS_PATGEN10r_REG10f_SET(r,f) (r).patgen10[0]=(((r).patgen10[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PATGEN10.
 *
 */
#define BCMI_TSC_XGXS_READ_PATGEN10r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_PATGEN10r,(_r._patgen10))
#define BCMI_TSC_XGXS_WRITE_PATGEN10r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_PATGEN10r,(_r._patgen10))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PATGEN10r BCMI_TSC_XGXS_PATGEN10r
#define PATGEN10r_SIZE BCMI_TSC_XGXS_PATGEN10r_SIZE
typedef BCMI_TSC_XGXS_PATGEN10r_t PATGEN10r_t;
#define PATGEN10r_CLR BCMI_TSC_XGXS_PATGEN10r_CLR
#define PATGEN10r_SET BCMI_TSC_XGXS_PATGEN10r_SET
#define PATGEN10r_GET BCMI_TSC_XGXS_PATGEN10r_GET
#define PATGEN10r_REG10f_GET BCMI_TSC_XGXS_PATGEN10r_REG10f_GET
#define PATGEN10r_REG10f_SET BCMI_TSC_XGXS_PATGEN10r_REG10f_SET
#define READ_PATGEN10r BCMI_TSC_XGXS_READ_PATGEN10r
#define WRITE_PATGEN10r BCMI_TSC_XGXS_WRITE_PATGEN10r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_PATGEN10r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  PATGEN11
 * BLOCKS:   PATGEN_256_0
 * REGADDR:  0x905b
 * DESC:     Pattern Genertor 11 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     REG11            
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_PATGEN11r (0x0010905b | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_PATGEN11r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN11.
 *
 */
typedef union BCMI_TSC_XGXS_PATGEN11r_s {
	uint32_t v[1];
	uint32_t patgen11[1];
	uint32_t _patgen11;
} BCMI_TSC_XGXS_PATGEN11r_t;

#define BCMI_TSC_XGXS_PATGEN11r_CLR(r) (r).patgen11[0] = 0
#define BCMI_TSC_XGXS_PATGEN11r_SET(r,d) (r).patgen11[0] = d
#define BCMI_TSC_XGXS_PATGEN11r_GET(r) (r).patgen11[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_PATGEN11r_REG11f_GET(r) (((r).patgen11[0]) & 0xffff)
#define BCMI_TSC_XGXS_PATGEN11r_REG11f_SET(r,f) (r).patgen11[0]=(((r).patgen11[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PATGEN11.
 *
 */
#define BCMI_TSC_XGXS_READ_PATGEN11r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_PATGEN11r,(_r._patgen11))
#define BCMI_TSC_XGXS_WRITE_PATGEN11r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_PATGEN11r,(_r._patgen11))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PATGEN11r BCMI_TSC_XGXS_PATGEN11r
#define PATGEN11r_SIZE BCMI_TSC_XGXS_PATGEN11r_SIZE
typedef BCMI_TSC_XGXS_PATGEN11r_t PATGEN11r_t;
#define PATGEN11r_CLR BCMI_TSC_XGXS_PATGEN11r_CLR
#define PATGEN11r_SET BCMI_TSC_XGXS_PATGEN11r_SET
#define PATGEN11r_GET BCMI_TSC_XGXS_PATGEN11r_GET
#define PATGEN11r_REG11f_GET BCMI_TSC_XGXS_PATGEN11r_REG11f_GET
#define PATGEN11r_REG11f_SET BCMI_TSC_XGXS_PATGEN11r_REG11f_SET
#define READ_PATGEN11r BCMI_TSC_XGXS_READ_PATGEN11r
#define WRITE_PATGEN11r BCMI_TSC_XGXS_WRITE_PATGEN11r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_PATGEN11r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  PATGEN12
 * BLOCKS:   PATGEN_256_0
 * REGADDR:  0x905c
 * DESC:     Pattern Genertor 12 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     REG12            
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_PATGEN12r (0x0010905c | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_PATGEN12r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN12.
 *
 */
typedef union BCMI_TSC_XGXS_PATGEN12r_s {
	uint32_t v[1];
	uint32_t patgen12[1];
	uint32_t _patgen12;
} BCMI_TSC_XGXS_PATGEN12r_t;

#define BCMI_TSC_XGXS_PATGEN12r_CLR(r) (r).patgen12[0] = 0
#define BCMI_TSC_XGXS_PATGEN12r_SET(r,d) (r).patgen12[0] = d
#define BCMI_TSC_XGXS_PATGEN12r_GET(r) (r).patgen12[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_PATGEN12r_REG12f_GET(r) (((r).patgen12[0]) & 0xffff)
#define BCMI_TSC_XGXS_PATGEN12r_REG12f_SET(r,f) (r).patgen12[0]=(((r).patgen12[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PATGEN12.
 *
 */
#define BCMI_TSC_XGXS_READ_PATGEN12r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_PATGEN12r,(_r._patgen12))
#define BCMI_TSC_XGXS_WRITE_PATGEN12r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_PATGEN12r,(_r._patgen12))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PATGEN12r BCMI_TSC_XGXS_PATGEN12r
#define PATGEN12r_SIZE BCMI_TSC_XGXS_PATGEN12r_SIZE
typedef BCMI_TSC_XGXS_PATGEN12r_t PATGEN12r_t;
#define PATGEN12r_CLR BCMI_TSC_XGXS_PATGEN12r_CLR
#define PATGEN12r_SET BCMI_TSC_XGXS_PATGEN12r_SET
#define PATGEN12r_GET BCMI_TSC_XGXS_PATGEN12r_GET
#define PATGEN12r_REG12f_GET BCMI_TSC_XGXS_PATGEN12r_REG12f_GET
#define PATGEN12r_REG12f_SET BCMI_TSC_XGXS_PATGEN12r_REG12f_SET
#define READ_PATGEN12r BCMI_TSC_XGXS_READ_PATGEN12r
#define WRITE_PATGEN12r BCMI_TSC_XGXS_WRITE_PATGEN12r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_PATGEN12r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  PATGEN13
 * BLOCKS:   PATGEN_256_0
 * REGADDR:  0x905d
 * DESC:     Pattern Genertor 13 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     REG13            
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_PATGEN13r (0x0010905d | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_PATGEN13r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN13.
 *
 */
typedef union BCMI_TSC_XGXS_PATGEN13r_s {
	uint32_t v[1];
	uint32_t patgen13[1];
	uint32_t _patgen13;
} BCMI_TSC_XGXS_PATGEN13r_t;

#define BCMI_TSC_XGXS_PATGEN13r_CLR(r) (r).patgen13[0] = 0
#define BCMI_TSC_XGXS_PATGEN13r_SET(r,d) (r).patgen13[0] = d
#define BCMI_TSC_XGXS_PATGEN13r_GET(r) (r).patgen13[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_PATGEN13r_REG13f_GET(r) (((r).patgen13[0]) & 0xffff)
#define BCMI_TSC_XGXS_PATGEN13r_REG13f_SET(r,f) (r).patgen13[0]=(((r).patgen13[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PATGEN13.
 *
 */
#define BCMI_TSC_XGXS_READ_PATGEN13r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_PATGEN13r,(_r._patgen13))
#define BCMI_TSC_XGXS_WRITE_PATGEN13r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_PATGEN13r,(_r._patgen13))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PATGEN13r BCMI_TSC_XGXS_PATGEN13r
#define PATGEN13r_SIZE BCMI_TSC_XGXS_PATGEN13r_SIZE
typedef BCMI_TSC_XGXS_PATGEN13r_t PATGEN13r_t;
#define PATGEN13r_CLR BCMI_TSC_XGXS_PATGEN13r_CLR
#define PATGEN13r_SET BCMI_TSC_XGXS_PATGEN13r_SET
#define PATGEN13r_GET BCMI_TSC_XGXS_PATGEN13r_GET
#define PATGEN13r_REG13f_GET BCMI_TSC_XGXS_PATGEN13r_REG13f_GET
#define PATGEN13r_REG13f_SET BCMI_TSC_XGXS_PATGEN13r_REG13f_SET
#define READ_PATGEN13r BCMI_TSC_XGXS_READ_PATGEN13r
#define WRITE_PATGEN13r BCMI_TSC_XGXS_WRITE_PATGEN13r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_PATGEN13r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  PATGEN14
 * BLOCKS:   PATGEN_256_0
 * REGADDR:  0x905e
 * DESC:     Pattern Genertor 14 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     REG14            
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_PATGEN14r (0x0010905e | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_PATGEN14r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN14.
 *
 */
typedef union BCMI_TSC_XGXS_PATGEN14r_s {
	uint32_t v[1];
	uint32_t patgen14[1];
	uint32_t _patgen14;
} BCMI_TSC_XGXS_PATGEN14r_t;

#define BCMI_TSC_XGXS_PATGEN14r_CLR(r) (r).patgen14[0] = 0
#define BCMI_TSC_XGXS_PATGEN14r_SET(r,d) (r).patgen14[0] = d
#define BCMI_TSC_XGXS_PATGEN14r_GET(r) (r).patgen14[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_PATGEN14r_REG14f_GET(r) (((r).patgen14[0]) & 0xffff)
#define BCMI_TSC_XGXS_PATGEN14r_REG14f_SET(r,f) (r).patgen14[0]=(((r).patgen14[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PATGEN14.
 *
 */
#define BCMI_TSC_XGXS_READ_PATGEN14r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_PATGEN14r,(_r._patgen14))
#define BCMI_TSC_XGXS_WRITE_PATGEN14r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_PATGEN14r,(_r._patgen14))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PATGEN14r BCMI_TSC_XGXS_PATGEN14r
#define PATGEN14r_SIZE BCMI_TSC_XGXS_PATGEN14r_SIZE
typedef BCMI_TSC_XGXS_PATGEN14r_t PATGEN14r_t;
#define PATGEN14r_CLR BCMI_TSC_XGXS_PATGEN14r_CLR
#define PATGEN14r_SET BCMI_TSC_XGXS_PATGEN14r_SET
#define PATGEN14r_GET BCMI_TSC_XGXS_PATGEN14r_GET
#define PATGEN14r_REG14f_GET BCMI_TSC_XGXS_PATGEN14r_REG14f_GET
#define PATGEN14r_REG14f_SET BCMI_TSC_XGXS_PATGEN14r_REG14f_SET
#define READ_PATGEN14r BCMI_TSC_XGXS_READ_PATGEN14r
#define WRITE_PATGEN14r BCMI_TSC_XGXS_WRITE_PATGEN14r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_PATGEN14r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  PATGENF
 * BLOCKS:   PATGEN_256_1
 * REGADDR:  0x9060
 * DESC:     Pattern Genertor F Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     REG15            
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_PATGENFr (0x00109060 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_PATGENFr_SIZE 4

/*
 * This structure should be used to declare and program PATGENF.
 *
 */
typedef union BCMI_TSC_XGXS_PATGENFr_s {
	uint32_t v[1];
	uint32_t patgenf[1];
	uint32_t _patgenf;
} BCMI_TSC_XGXS_PATGENFr_t;

#define BCMI_TSC_XGXS_PATGENFr_CLR(r) (r).patgenf[0] = 0
#define BCMI_TSC_XGXS_PATGENFr_SET(r,d) (r).patgenf[0] = d
#define BCMI_TSC_XGXS_PATGENFr_GET(r) (r).patgenf[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_PATGENFr_REG15f_GET(r) (((r).patgenf[0]) & 0xffff)
#define BCMI_TSC_XGXS_PATGENFr_REG15f_SET(r,f) (r).patgenf[0]=(((r).patgenf[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PATGENF.
 *
 */
#define BCMI_TSC_XGXS_READ_PATGENFr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_PATGENFr,(_r._patgenf))
#define BCMI_TSC_XGXS_WRITE_PATGENFr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_PATGENFr,(_r._patgenf))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PATGENFr BCMI_TSC_XGXS_PATGENFr
#define PATGENFr_SIZE BCMI_TSC_XGXS_PATGENFr_SIZE
typedef BCMI_TSC_XGXS_PATGENFr_t PATGENFr_t;
#define PATGENFr_CLR BCMI_TSC_XGXS_PATGENFr_CLR
#define PATGENFr_SET BCMI_TSC_XGXS_PATGENFr_SET
#define PATGENFr_GET BCMI_TSC_XGXS_PATGENFr_GET
#define PATGENFr_REG15f_GET BCMI_TSC_XGXS_PATGENFr_REG15f_GET
#define PATGENFr_REG15f_SET BCMI_TSC_XGXS_PATGENFr_REG15f_SET
#define READ_PATGENFr BCMI_TSC_XGXS_READ_PATGENFr
#define WRITE_PATGENFr BCMI_TSC_XGXS_WRITE_PATGENFr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_PATGENFr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  PRBSERRCHKCFG
 * BLOCKS:   PATGEN_256_1
 * REGADDR:  0x9061
 * DESC:     Prbs Error Check Config: 00000000
 * SIZE:     32
 * FIELDS:
 *     BURST_IGNORE_CNT 
 *     ERR_BLK_CNT_TO_UNLOCK 
 *     GOOD_BLK_CNT_TO_LOCK 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_PRBSERRCHKCFGr (0x00109061 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_PRBSERRCHKCFGr_SIZE 4

/*
 * This structure should be used to declare and program PRBSERRCHKCFG.
 *
 */
typedef union BCMI_TSC_XGXS_PRBSERRCHKCFGr_s {
	uint32_t v[1];
	uint32_t prbserrchkcfg[1];
	uint32_t _prbserrchkcfg;
} BCMI_TSC_XGXS_PRBSERRCHKCFGr_t;

#define BCMI_TSC_XGXS_PRBSERRCHKCFGr_CLR(r) (r).prbserrchkcfg[0] = 0
#define BCMI_TSC_XGXS_PRBSERRCHKCFGr_SET(r,d) (r).prbserrchkcfg[0] = d
#define BCMI_TSC_XGXS_PRBSERRCHKCFGr_GET(r) (r).prbserrchkcfg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_PRBSERRCHKCFGr_RESERVED0f_GET(r) ((((r).prbserrchkcfg[0]) >> 11) & 0x1f)
#define BCMI_TSC_XGXS_PRBSERRCHKCFGr_RESERVED0f_SET(r,f) (r).prbserrchkcfg[0]=(((r).prbserrchkcfg[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))
#define BCMI_TSC_XGXS_PRBSERRCHKCFGr_GOOD_BLK_CNT_TO_LOCKf_GET(r) ((((r).prbserrchkcfg[0]) >> 8) & 0x7)
#define BCMI_TSC_XGXS_PRBSERRCHKCFGr_GOOD_BLK_CNT_TO_LOCKf_SET(r,f) (r).prbserrchkcfg[0]=(((r).prbserrchkcfg[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8))
#define BCMI_TSC_XGXS_PRBSERRCHKCFGr_ERR_BLK_CNT_TO_UNLOCKf_GET(r) ((((r).prbserrchkcfg[0]) >> 3) & 0x1f)
#define BCMI_TSC_XGXS_PRBSERRCHKCFGr_ERR_BLK_CNT_TO_UNLOCKf_SET(r,f) (r).prbserrchkcfg[0]=(((r).prbserrchkcfg[0] & ~((uint32_t)0x1f << 3)) | ((((uint32_t)f) & 0x1f) << 3))
#define BCMI_TSC_XGXS_PRBSERRCHKCFGr_BURST_IGNORE_CNTf_GET(r) (((r).prbserrchkcfg[0]) & 0x7)
#define BCMI_TSC_XGXS_PRBSERRCHKCFGr_BURST_IGNORE_CNTf_SET(r,f) (r).prbserrchkcfg[0]=(((r).prbserrchkcfg[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))

/*
 * These macros can be used to access PRBSERRCHKCFG.
 *
 */
#define BCMI_TSC_XGXS_READ_PRBSERRCHKCFGr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_PRBSERRCHKCFGr,(_r._prbserrchkcfg))
#define BCMI_TSC_XGXS_WRITE_PRBSERRCHKCFGr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_PRBSERRCHKCFGr,(_r._prbserrchkcfg))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PRBSERRCHKCFGr BCMI_TSC_XGXS_PRBSERRCHKCFGr
#define PRBSERRCHKCFGr_SIZE BCMI_TSC_XGXS_PRBSERRCHKCFGr_SIZE
typedef BCMI_TSC_XGXS_PRBSERRCHKCFGr_t PRBSERRCHKCFGr_t;
#define PRBSERRCHKCFGr_CLR BCMI_TSC_XGXS_PRBSERRCHKCFGr_CLR
#define PRBSERRCHKCFGr_SET BCMI_TSC_XGXS_PRBSERRCHKCFGr_SET
#define PRBSERRCHKCFGr_GET BCMI_TSC_XGXS_PRBSERRCHKCFGr_GET
#define PRBSERRCHKCFGr_RESERVED0f_GET BCMI_TSC_XGXS_PRBSERRCHKCFGr_RESERVED0f_GET
#define PRBSERRCHKCFGr_RESERVED0f_SET BCMI_TSC_XGXS_PRBSERRCHKCFGr_RESERVED0f_SET
#define PRBSERRCHKCFGr_GOOD_BLK_CNT_TO_LOCKf_GET BCMI_TSC_XGXS_PRBSERRCHKCFGr_GOOD_BLK_CNT_TO_LOCKf_GET
#define PRBSERRCHKCFGr_GOOD_BLK_CNT_TO_LOCKf_SET BCMI_TSC_XGXS_PRBSERRCHKCFGr_GOOD_BLK_CNT_TO_LOCKf_SET
#define PRBSERRCHKCFGr_ERR_BLK_CNT_TO_UNLOCKf_GET BCMI_TSC_XGXS_PRBSERRCHKCFGr_ERR_BLK_CNT_TO_UNLOCKf_GET
#define PRBSERRCHKCFGr_ERR_BLK_CNT_TO_UNLOCKf_SET BCMI_TSC_XGXS_PRBSERRCHKCFGr_ERR_BLK_CNT_TO_UNLOCKf_SET
#define PRBSERRCHKCFGr_BURST_IGNORE_CNTf_GET BCMI_TSC_XGXS_PRBSERRCHKCFGr_BURST_IGNORE_CNTf_GET
#define PRBSERRCHKCFGr_BURST_IGNORE_CNTf_SET BCMI_TSC_XGXS_PRBSERRCHKCFGr_BURST_IGNORE_CNTf_SET
#define READ_PRBSERRCHKCFGr BCMI_TSC_XGXS_READ_PRBSERRCHKCFGr
#define WRITE_PRBSERRCHKCFGr BCMI_TSC_XGXS_WRITE_PRBSERRCHKCFGr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_PRBSERRCHKCFGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  LANETEST
 * BLOCKS:   XGXSBLK1
 * REGADDR:  0x909a
 * DESC:     Lane test control register: 00000000
 * SIZE:     32
 * FIELDS:
 *     RESERVED2        
 *     LFCK_BYPASS      
 *     RESERVED1        
 *     PWRDWN_CLKS_EN   
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_LANETESTr (0x0010909a | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_LANETESTr_SIZE 4

/*
 * This structure should be used to declare and program LANETEST.
 *
 */
typedef union BCMI_TSC_XGXS_LANETESTr_s {
	uint32_t v[1];
	uint32_t lanetest[1];
	uint32_t _lanetest;
} BCMI_TSC_XGXS_LANETESTr_t;

#define BCMI_TSC_XGXS_LANETESTr_CLR(r) (r).lanetest[0] = 0
#define BCMI_TSC_XGXS_LANETESTr_SET(r,d) (r).lanetest[0] = d
#define BCMI_TSC_XGXS_LANETESTr_GET(r) (r).lanetest[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_LANETESTr_RESERVED0f_GET(r) ((((r).lanetest[0]) >> 9) & 0x7f)
#define BCMI_TSC_XGXS_LANETESTr_RESERVED0f_SET(r,f) (r).lanetest[0]=(((r).lanetest[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))
#define BCMI_TSC_XGXS_LANETESTr_PWRDWN_CLKS_ENf_GET(r) ((((r).lanetest[0]) >> 8) & 0x1)
#define BCMI_TSC_XGXS_LANETESTr_PWRDWN_CLKS_ENf_SET(r,f) (r).lanetest[0]=(((r).lanetest[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCMI_TSC_XGXS_LANETESTr_RESERVED1f_GET(r) ((((r).lanetest[0]) >> 6) & 0x3)
#define BCMI_TSC_XGXS_LANETESTr_RESERVED1f_SET(r,f) (r).lanetest[0]=(((r).lanetest[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCMI_TSC_XGXS_LANETESTr_LFCK_BYPASSf_GET(r) ((((r).lanetest[0]) >> 5) & 0x1)
#define BCMI_TSC_XGXS_LANETESTr_LFCK_BYPASSf_SET(r,f) (r).lanetest[0]=(((r).lanetest[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCMI_TSC_XGXS_LANETESTr_RESERVED2f_GET(r) (((r).lanetest[0]) & 0x1f)
#define BCMI_TSC_XGXS_LANETESTr_RESERVED2f_SET(r,f) (r).lanetest[0]=(((r).lanetest[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))

/*
 * These macros can be used to access LANETEST.
 *
 */
#define BCMI_TSC_XGXS_READ_LANETESTr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_LANETESTr,(_r._lanetest))
#define BCMI_TSC_XGXS_WRITE_LANETESTr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_LANETESTr,(_r._lanetest))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define LANETESTr BCMI_TSC_XGXS_LANETESTr
#define LANETESTr_SIZE BCMI_TSC_XGXS_LANETESTr_SIZE
typedef BCMI_TSC_XGXS_LANETESTr_t LANETESTr_t;
#define LANETESTr_CLR BCMI_TSC_XGXS_LANETESTr_CLR
#define LANETESTr_SET BCMI_TSC_XGXS_LANETESTr_SET
#define LANETESTr_GET BCMI_TSC_XGXS_LANETESTr_GET
#define LANETESTr_RESERVED0f_GET BCMI_TSC_XGXS_LANETESTr_RESERVED0f_GET
#define LANETESTr_RESERVED0f_SET BCMI_TSC_XGXS_LANETESTr_RESERVED0f_SET
#define LANETESTr_PWRDWN_CLKS_ENf_GET BCMI_TSC_XGXS_LANETESTr_PWRDWN_CLKS_ENf_GET
#define LANETESTr_PWRDWN_CLKS_ENf_SET BCMI_TSC_XGXS_LANETESTr_PWRDWN_CLKS_ENf_SET
#define LANETESTr_RESERVED1f_GET BCMI_TSC_XGXS_LANETESTr_RESERVED1f_GET
#define LANETESTr_RESERVED1f_SET BCMI_TSC_XGXS_LANETESTr_RESERVED1f_SET
#define LANETESTr_LFCK_BYPASSf_GET BCMI_TSC_XGXS_LANETESTr_LFCK_BYPASSf_GET
#define LANETESTr_LFCK_BYPASSf_SET BCMI_TSC_XGXS_LANETESTr_LFCK_BYPASSf_SET
#define LANETESTr_RESERVED2f_GET BCMI_TSC_XGXS_LANETESTr_RESERVED2f_GET
#define LANETESTr_RESERVED2f_SET BCMI_TSC_XGXS_LANETESTr_RESERVED2f_SET
#define READ_LANETESTr BCMI_TSC_XGXS_READ_LANETESTr
#define WRITE_LANETESTr BCMI_TSC_XGXS_WRITE_LANETESTr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_LANETESTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  XGXSSTATUS0
 * BLOCKS:   XGXSBLK4
 * REGADDR:  0x90b1
 * DESC:     XGXS status register: 00000000
 * SIZE:     32
 * FIELDS:
 *     SKEW_STATUS      
 *     RESERVED0        
 *     STATUS_EN        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_XGXSSTATUS0r (0x001090b1 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_XGXSSTATUS0r_SIZE 4

/*
 * This structure should be used to declare and program XGXSSTATUS0.
 *
 */
typedef union BCMI_TSC_XGXS_XGXSSTATUS0r_s {
	uint32_t v[1];
	uint32_t xgxsstatus0[1];
	uint32_t _xgxsstatus0;
} BCMI_TSC_XGXS_XGXSSTATUS0r_t;

#define BCMI_TSC_XGXS_XGXSSTATUS0r_CLR(r) (r).xgxsstatus0[0] = 0
#define BCMI_TSC_XGXS_XGXSSTATUS0r_SET(r,d) (r).xgxsstatus0[0] = d
#define BCMI_TSC_XGXS_XGXSSTATUS0r_GET(r) (r).xgxsstatus0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_XGXSSTATUS0r_STATUS_ENf_GET(r) ((((r).xgxsstatus0[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_XGXSSTATUS0r_STATUS_ENf_SET(r,f) (r).xgxsstatus0[0]=(((r).xgxsstatus0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_XGXSSTATUS0r_RESERVED0f_GET(r) ((((r).xgxsstatus0[0]) >> 1) & 0x3fff)
#define BCMI_TSC_XGXS_XGXSSTATUS0r_RESERVED0f_SET(r,f) (r).xgxsstatus0[0]=(((r).xgxsstatus0[0] & ~((uint32_t)0x3fff << 1)) | ((((uint32_t)f) & 0x3fff) << 1))
#define BCMI_TSC_XGXS_XGXSSTATUS0r_SKEW_STATUSf_GET(r) (((r).xgxsstatus0[0]) & 0x1)
#define BCMI_TSC_XGXS_XGXSSTATUS0r_SKEW_STATUSf_SET(r,f) (r).xgxsstatus0[0]=(((r).xgxsstatus0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access XGXSSTATUS0.
 *
 */
#define BCMI_TSC_XGXS_READ_XGXSSTATUS0r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_XGXSSTATUS0r,(_r._xgxsstatus0))
#define BCMI_TSC_XGXS_WRITE_XGXSSTATUS0r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_XGXSSTATUS0r,(_r._xgxsstatus0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define XGXSSTATUS0r BCMI_TSC_XGXS_XGXSSTATUS0r
#define XGXSSTATUS0r_SIZE BCMI_TSC_XGXS_XGXSSTATUS0r_SIZE
typedef BCMI_TSC_XGXS_XGXSSTATUS0r_t XGXSSTATUS0r_t;
#define XGXSSTATUS0r_CLR BCMI_TSC_XGXS_XGXSSTATUS0r_CLR
#define XGXSSTATUS0r_SET BCMI_TSC_XGXS_XGXSSTATUS0r_SET
#define XGXSSTATUS0r_GET BCMI_TSC_XGXS_XGXSSTATUS0r_GET
#define XGXSSTATUS0r_STATUS_ENf_GET BCMI_TSC_XGXS_XGXSSTATUS0r_STATUS_ENf_GET
#define XGXSSTATUS0r_STATUS_ENf_SET BCMI_TSC_XGXS_XGXSSTATUS0r_STATUS_ENf_SET
#define XGXSSTATUS0r_RESERVED0f_GET BCMI_TSC_XGXS_XGXSSTATUS0r_RESERVED0f_GET
#define XGXSSTATUS0r_RESERVED0f_SET BCMI_TSC_XGXS_XGXSSTATUS0r_RESERVED0f_SET
#define XGXSSTATUS0r_SKEW_STATUSf_GET BCMI_TSC_XGXS_XGXSSTATUS0r_SKEW_STATUSf_GET
#define XGXSSTATUS0r_SKEW_STATUSf_SET BCMI_TSC_XGXS_XGXSSTATUS0r_SKEW_STATUSf_SET
#define READ_XGXSSTATUS0r BCMI_TSC_XGXS_READ_XGXSSTATUS0r
#define WRITE_XGXSSTATUS0r BCMI_TSC_XGXS_WRITE_XGXSSTATUS0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_XGXSSTATUS0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  REG_8
 * BLOCKS:   GP2
 * REGADDR:  0x9108
 * DESC:     GP2 status 8 register: 00000000
 * SIZE:     32
 * FIELDS:
 *     MICRO_WDOG       
 *     MICRO_ERR        
 *     MICRO_FSM        
 *     MICRO_INIT_DONE  
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_REG_8r (0x00109108 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_REG_8r_SIZE 4

/*
 * This structure should be used to declare and program REG_8.
 *
 */
typedef union BCMI_TSC_XGXS_REG_8r_s {
	uint32_t v[1];
	uint32_t reg_8[1];
	uint32_t _reg_8;
} BCMI_TSC_XGXS_REG_8r_t;

#define BCMI_TSC_XGXS_REG_8r_CLR(r) (r).reg_8[0] = 0
#define BCMI_TSC_XGXS_REG_8r_SET(r,d) (r).reg_8[0] = d
#define BCMI_TSC_XGXS_REG_8r_GET(r) (r).reg_8[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_REG_8r_RESERVED0f_GET(r) ((((r).reg_8[0]) >> 9) & 0x7f)
#define BCMI_TSC_XGXS_REG_8r_RESERVED0f_SET(r,f) (r).reg_8[0]=(((r).reg_8[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))
#define BCMI_TSC_XGXS_REG_8r_MICRO_INIT_DONEf_GET(r) ((((r).reg_8[0]) >> 8) & 0x1)
#define BCMI_TSC_XGXS_REG_8r_MICRO_INIT_DONEf_SET(r,f) (r).reg_8[0]=(((r).reg_8[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCMI_TSC_XGXS_REG_8r_MICRO_FSMf_GET(r) ((((r).reg_8[0]) >> 4) & 0xf)
#define BCMI_TSC_XGXS_REG_8r_MICRO_FSMf_SET(r,f) (r).reg_8[0]=(((r).reg_8[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCMI_TSC_XGXS_REG_8r_MICRO_ERRf_GET(r) ((((r).reg_8[0]) >> 2) & 0x3)
#define BCMI_TSC_XGXS_REG_8r_MICRO_ERRf_SET(r,f) (r).reg_8[0]=(((r).reg_8[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCMI_TSC_XGXS_REG_8r_MICRO_WDOGf_GET(r) (((r).reg_8[0]) & 0x3)
#define BCMI_TSC_XGXS_REG_8r_MICRO_WDOGf_SET(r,f) (r).reg_8[0]=(((r).reg_8[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))

/*
 * These macros can be used to access REG_8.
 *
 */
#define BCMI_TSC_XGXS_READ_REG_8r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_REG_8r,(_r._reg_8))
#define BCMI_TSC_XGXS_WRITE_REG_8r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_REG_8r,(_r._reg_8))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define REG_8r BCMI_TSC_XGXS_REG_8r
#define REG_8r_SIZE BCMI_TSC_XGXS_REG_8r_SIZE
typedef BCMI_TSC_XGXS_REG_8r_t REG_8r_t;
#define REG_8r_CLR BCMI_TSC_XGXS_REG_8r_CLR
#define REG_8r_SET BCMI_TSC_XGXS_REG_8r_SET
#define REG_8r_GET BCMI_TSC_XGXS_REG_8r_GET
#define REG_8r_RESERVED0f_GET BCMI_TSC_XGXS_REG_8r_RESERVED0f_GET
#define REG_8r_RESERVED0f_SET BCMI_TSC_XGXS_REG_8r_RESERVED0f_SET
#define REG_8r_MICRO_INIT_DONEf_GET BCMI_TSC_XGXS_REG_8r_MICRO_INIT_DONEf_GET
#define REG_8r_MICRO_INIT_DONEf_SET BCMI_TSC_XGXS_REG_8r_MICRO_INIT_DONEf_SET
#define REG_8r_MICRO_FSMf_GET BCMI_TSC_XGXS_REG_8r_MICRO_FSMf_GET
#define REG_8r_MICRO_FSMf_SET BCMI_TSC_XGXS_REG_8r_MICRO_FSMf_SET
#define REG_8r_MICRO_ERRf_GET BCMI_TSC_XGXS_REG_8r_MICRO_ERRf_GET
#define REG_8r_MICRO_ERRf_SET BCMI_TSC_XGXS_REG_8r_MICRO_ERRf_SET
#define REG_8r_MICRO_WDOGf_GET BCMI_TSC_XGXS_REG_8r_MICRO_WDOGf_GET
#define REG_8r_MICRO_WDOGf_SET BCMI_TSC_XGXS_REG_8r_MICRO_WDOGf_SET
#define READ_REG_8r BCMI_TSC_XGXS_READ_REG_8r
#define WRITE_REG_8r BCMI_TSC_XGXS_WRITE_REG_8r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_REG_8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CL72_AN_OS_DEFAULT_CONTROL
 * BLOCKS:   CL72_SHARED
 * REGADDR:  0x9111
 * DESC:     AN OS Default Control Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     TX_FIR_TAP_PRE_OS_INIT_VAL 
 *     TX_FIR_TAP_MAIN_OS_INIT_VAL 
 *     TX_FIR_TAP_POST_OS_INIT_VAL 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CL72_AN_OS_DEFAULT_CONTROLr (0x00109111 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CL72_AN_OS_DEFAULT_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program CL72_AN_OS_DEFAULT_CONTROL.
 *
 */
typedef union BCMI_TSC_XGXS_CL72_AN_OS_DEFAULT_CONTROLr_s {
	uint32_t v[1];
	uint32_t cl72_an_os_default_control[1];
	uint32_t _cl72_an_os_default_control;
} BCMI_TSC_XGXS_CL72_AN_OS_DEFAULT_CONTROLr_t;

#define BCMI_TSC_XGXS_CL72_AN_OS_DEFAULT_CONTROLr_CLR(r) (r).cl72_an_os_default_control[0] = 0
#define BCMI_TSC_XGXS_CL72_AN_OS_DEFAULT_CONTROLr_SET(r,d) (r).cl72_an_os_default_control[0] = d
#define BCMI_TSC_XGXS_CL72_AN_OS_DEFAULT_CONTROLr_GET(r) (r).cl72_an_os_default_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CL72_AN_OS_DEFAULT_CONTROLr_RESERVED0f_GET(r) ((((r).cl72_an_os_default_control[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_CL72_AN_OS_DEFAULT_CONTROLr_RESERVED0f_SET(r,f) (r).cl72_an_os_default_control[0]=(((r).cl72_an_os_default_control[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_CL72_AN_OS_DEFAULT_CONTROLr_TX_FIR_TAP_POST_OS_INIT_VALf_GET(r) ((((r).cl72_an_os_default_control[0]) >> 10) & 0x1f)
#define BCMI_TSC_XGXS_CL72_AN_OS_DEFAULT_CONTROLr_TX_FIR_TAP_POST_OS_INIT_VALf_SET(r,f) (r).cl72_an_os_default_control[0]=(((r).cl72_an_os_default_control[0] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10))
#define BCMI_TSC_XGXS_CL72_AN_OS_DEFAULT_CONTROLr_TX_FIR_TAP_MAIN_OS_INIT_VALf_GET(r) ((((r).cl72_an_os_default_control[0]) >> 4) & 0x3f)
#define BCMI_TSC_XGXS_CL72_AN_OS_DEFAULT_CONTROLr_TX_FIR_TAP_MAIN_OS_INIT_VALf_SET(r,f) (r).cl72_an_os_default_control[0]=(((r).cl72_an_os_default_control[0] & ~((uint32_t)0x3f << 4)) | ((((uint32_t)f) & 0x3f) << 4))
#define BCMI_TSC_XGXS_CL72_AN_OS_DEFAULT_CONTROLr_TX_FIR_TAP_PRE_OS_INIT_VALf_GET(r) (((r).cl72_an_os_default_control[0]) & 0xf)
#define BCMI_TSC_XGXS_CL72_AN_OS_DEFAULT_CONTROLr_TX_FIR_TAP_PRE_OS_INIT_VALf_SET(r,f) (r).cl72_an_os_default_control[0]=(((r).cl72_an_os_default_control[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access CL72_AN_OS_DEFAULT_CONTROL.
 *
 */
#define BCMI_TSC_XGXS_READ_CL72_AN_OS_DEFAULT_CONTROLr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CL72_AN_OS_DEFAULT_CONTROLr,(_r._cl72_an_os_default_control))
#define BCMI_TSC_XGXS_WRITE_CL72_AN_OS_DEFAULT_CONTROLr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CL72_AN_OS_DEFAULT_CONTROLr,(_r._cl72_an_os_default_control))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL72_AN_OS_DEFAULT_CONTROLr BCMI_TSC_XGXS_CL72_AN_OS_DEFAULT_CONTROLr
#define CL72_AN_OS_DEFAULT_CONTROLr_SIZE BCMI_TSC_XGXS_CL72_AN_OS_DEFAULT_CONTROLr_SIZE
typedef BCMI_TSC_XGXS_CL72_AN_OS_DEFAULT_CONTROLr_t CL72_AN_OS_DEFAULT_CONTROLr_t;
#define CL72_AN_OS_DEFAULT_CONTROLr_CLR BCMI_TSC_XGXS_CL72_AN_OS_DEFAULT_CONTROLr_CLR
#define CL72_AN_OS_DEFAULT_CONTROLr_SET BCMI_TSC_XGXS_CL72_AN_OS_DEFAULT_CONTROLr_SET
#define CL72_AN_OS_DEFAULT_CONTROLr_GET BCMI_TSC_XGXS_CL72_AN_OS_DEFAULT_CONTROLr_GET
#define CL72_AN_OS_DEFAULT_CONTROLr_RESERVED0f_GET BCMI_TSC_XGXS_CL72_AN_OS_DEFAULT_CONTROLr_RESERVED0f_GET
#define CL72_AN_OS_DEFAULT_CONTROLr_RESERVED0f_SET BCMI_TSC_XGXS_CL72_AN_OS_DEFAULT_CONTROLr_RESERVED0f_SET
#define CL72_AN_OS_DEFAULT_CONTROLr_TX_FIR_TAP_POST_OS_INIT_VALf_GET BCMI_TSC_XGXS_CL72_AN_OS_DEFAULT_CONTROLr_TX_FIR_TAP_POST_OS_INIT_VALf_GET
#define CL72_AN_OS_DEFAULT_CONTROLr_TX_FIR_TAP_POST_OS_INIT_VALf_SET BCMI_TSC_XGXS_CL72_AN_OS_DEFAULT_CONTROLr_TX_FIR_TAP_POST_OS_INIT_VALf_SET
#define CL72_AN_OS_DEFAULT_CONTROLr_TX_FIR_TAP_MAIN_OS_INIT_VALf_GET BCMI_TSC_XGXS_CL72_AN_OS_DEFAULT_CONTROLr_TX_FIR_TAP_MAIN_OS_INIT_VALf_GET
#define CL72_AN_OS_DEFAULT_CONTROLr_TX_FIR_TAP_MAIN_OS_INIT_VALf_SET BCMI_TSC_XGXS_CL72_AN_OS_DEFAULT_CONTROLr_TX_FIR_TAP_MAIN_OS_INIT_VALf_SET
#define CL72_AN_OS_DEFAULT_CONTROLr_TX_FIR_TAP_PRE_OS_INIT_VALf_GET BCMI_TSC_XGXS_CL72_AN_OS_DEFAULT_CONTROLr_TX_FIR_TAP_PRE_OS_INIT_VALf_GET
#define CL72_AN_OS_DEFAULT_CONTROLr_TX_FIR_TAP_PRE_OS_INIT_VALf_SET BCMI_TSC_XGXS_CL72_AN_OS_DEFAULT_CONTROLr_TX_FIR_TAP_PRE_OS_INIT_VALf_SET
#define READ_CL72_AN_OS_DEFAULT_CONTROLr BCMI_TSC_XGXS_READ_CL72_AN_OS_DEFAULT_CONTROLr
#define WRITE_CL72_AN_OS_DEFAULT_CONTROLr BCMI_TSC_XGXS_WRITE_CL72_AN_OS_DEFAULT_CONTROLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CL72_AN_OS_DEFAULT_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CL72_AN_BR_DEFAULT_CONTROL
 * BLOCKS:   CL72_SHARED
 * REGADDR:  0x9112
 * DESC:     AN BR Default Control Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     TX_FIR_TAP_PRE_BR_INIT_VAL 
 *     TX_FIR_TAP_MAIN_BR_INIT_VAL 
 *     TX_FIR_TAP_POST_BR_INIT_VAL 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CL72_AN_BR_DEFAULT_CONTROLr (0x00109112 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CL72_AN_BR_DEFAULT_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program CL72_AN_BR_DEFAULT_CONTROL.
 *
 */
typedef union BCMI_TSC_XGXS_CL72_AN_BR_DEFAULT_CONTROLr_s {
	uint32_t v[1];
	uint32_t cl72_an_br_default_control[1];
	uint32_t _cl72_an_br_default_control;
} BCMI_TSC_XGXS_CL72_AN_BR_DEFAULT_CONTROLr_t;

#define BCMI_TSC_XGXS_CL72_AN_BR_DEFAULT_CONTROLr_CLR(r) (r).cl72_an_br_default_control[0] = 0
#define BCMI_TSC_XGXS_CL72_AN_BR_DEFAULT_CONTROLr_SET(r,d) (r).cl72_an_br_default_control[0] = d
#define BCMI_TSC_XGXS_CL72_AN_BR_DEFAULT_CONTROLr_GET(r) (r).cl72_an_br_default_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CL72_AN_BR_DEFAULT_CONTROLr_RESERVED0f_GET(r) ((((r).cl72_an_br_default_control[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_CL72_AN_BR_DEFAULT_CONTROLr_RESERVED0f_SET(r,f) (r).cl72_an_br_default_control[0]=(((r).cl72_an_br_default_control[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_CL72_AN_BR_DEFAULT_CONTROLr_TX_FIR_TAP_POST_BR_INIT_VALf_GET(r) ((((r).cl72_an_br_default_control[0]) >> 10) & 0x1f)
#define BCMI_TSC_XGXS_CL72_AN_BR_DEFAULT_CONTROLr_TX_FIR_TAP_POST_BR_INIT_VALf_SET(r,f) (r).cl72_an_br_default_control[0]=(((r).cl72_an_br_default_control[0] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10))
#define BCMI_TSC_XGXS_CL72_AN_BR_DEFAULT_CONTROLr_TX_FIR_TAP_MAIN_BR_INIT_VALf_GET(r) ((((r).cl72_an_br_default_control[0]) >> 4) & 0x3f)
#define BCMI_TSC_XGXS_CL72_AN_BR_DEFAULT_CONTROLr_TX_FIR_TAP_MAIN_BR_INIT_VALf_SET(r,f) (r).cl72_an_br_default_control[0]=(((r).cl72_an_br_default_control[0] & ~((uint32_t)0x3f << 4)) | ((((uint32_t)f) & 0x3f) << 4))
#define BCMI_TSC_XGXS_CL72_AN_BR_DEFAULT_CONTROLr_TX_FIR_TAP_PRE_BR_INIT_VALf_GET(r) (((r).cl72_an_br_default_control[0]) & 0xf)
#define BCMI_TSC_XGXS_CL72_AN_BR_DEFAULT_CONTROLr_TX_FIR_TAP_PRE_BR_INIT_VALf_SET(r,f) (r).cl72_an_br_default_control[0]=(((r).cl72_an_br_default_control[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access CL72_AN_BR_DEFAULT_CONTROL.
 *
 */
#define BCMI_TSC_XGXS_READ_CL72_AN_BR_DEFAULT_CONTROLr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CL72_AN_BR_DEFAULT_CONTROLr,(_r._cl72_an_br_default_control))
#define BCMI_TSC_XGXS_WRITE_CL72_AN_BR_DEFAULT_CONTROLr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CL72_AN_BR_DEFAULT_CONTROLr,(_r._cl72_an_br_default_control))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL72_AN_BR_DEFAULT_CONTROLr BCMI_TSC_XGXS_CL72_AN_BR_DEFAULT_CONTROLr
#define CL72_AN_BR_DEFAULT_CONTROLr_SIZE BCMI_TSC_XGXS_CL72_AN_BR_DEFAULT_CONTROLr_SIZE
typedef BCMI_TSC_XGXS_CL72_AN_BR_DEFAULT_CONTROLr_t CL72_AN_BR_DEFAULT_CONTROLr_t;
#define CL72_AN_BR_DEFAULT_CONTROLr_CLR BCMI_TSC_XGXS_CL72_AN_BR_DEFAULT_CONTROLr_CLR
#define CL72_AN_BR_DEFAULT_CONTROLr_SET BCMI_TSC_XGXS_CL72_AN_BR_DEFAULT_CONTROLr_SET
#define CL72_AN_BR_DEFAULT_CONTROLr_GET BCMI_TSC_XGXS_CL72_AN_BR_DEFAULT_CONTROLr_GET
#define CL72_AN_BR_DEFAULT_CONTROLr_RESERVED0f_GET BCMI_TSC_XGXS_CL72_AN_BR_DEFAULT_CONTROLr_RESERVED0f_GET
#define CL72_AN_BR_DEFAULT_CONTROLr_RESERVED0f_SET BCMI_TSC_XGXS_CL72_AN_BR_DEFAULT_CONTROLr_RESERVED0f_SET
#define CL72_AN_BR_DEFAULT_CONTROLr_TX_FIR_TAP_POST_BR_INIT_VALf_GET BCMI_TSC_XGXS_CL72_AN_BR_DEFAULT_CONTROLr_TX_FIR_TAP_POST_BR_INIT_VALf_GET
#define CL72_AN_BR_DEFAULT_CONTROLr_TX_FIR_TAP_POST_BR_INIT_VALf_SET BCMI_TSC_XGXS_CL72_AN_BR_DEFAULT_CONTROLr_TX_FIR_TAP_POST_BR_INIT_VALf_SET
#define CL72_AN_BR_DEFAULT_CONTROLr_TX_FIR_TAP_MAIN_BR_INIT_VALf_GET BCMI_TSC_XGXS_CL72_AN_BR_DEFAULT_CONTROLr_TX_FIR_TAP_MAIN_BR_INIT_VALf_GET
#define CL72_AN_BR_DEFAULT_CONTROLr_TX_FIR_TAP_MAIN_BR_INIT_VALf_SET BCMI_TSC_XGXS_CL72_AN_BR_DEFAULT_CONTROLr_TX_FIR_TAP_MAIN_BR_INIT_VALf_SET
#define CL72_AN_BR_DEFAULT_CONTROLr_TX_FIR_TAP_PRE_BR_INIT_VALf_GET BCMI_TSC_XGXS_CL72_AN_BR_DEFAULT_CONTROLr_TX_FIR_TAP_PRE_BR_INIT_VALf_GET
#define CL72_AN_BR_DEFAULT_CONTROLr_TX_FIR_TAP_PRE_BR_INIT_VALf_SET BCMI_TSC_XGXS_CL72_AN_BR_DEFAULT_CONTROLr_TX_FIR_TAP_PRE_BR_INIT_VALf_SET
#define READ_CL72_AN_BR_DEFAULT_CONTROLr BCMI_TSC_XGXS_READ_CL72_AN_BR_DEFAULT_CONTROLr
#define WRITE_CL72_AN_BR_DEFAULT_CONTROLr BCMI_TSC_XGXS_WRITE_CL72_AN_BR_DEFAULT_CONTROLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CL72_AN_BR_DEFAULT_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CL72_AN_TWOP5_DEFAULT_CONTROL
 * BLOCKS:   CL72_SHARED
 * REGADDR:  0x9113
 * DESC:     AN 2p5 Default Control Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     TX_FIR_TAP_PRE_2P5_INIT_VAL 
 *     TX_FIR_TAP_MAIN_2P5_INIT_VAL 
 *     TX_FIR_TAP_POST_2P5_INIT_VAL 
 *     CL72_EN_MASK     
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CL72_AN_TWOP5_DEFAULT_CONTROLr (0x00109113 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CL72_AN_TWOP5_DEFAULT_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program CL72_AN_TWOP5_DEFAULT_CONTROL.
 *
 */
typedef union BCMI_TSC_XGXS_CL72_AN_TWOP5_DEFAULT_CONTROLr_s {
	uint32_t v[1];
	uint32_t cl72_an_twop5_default_control[1];
	uint32_t _cl72_an_twop5_default_control;
} BCMI_TSC_XGXS_CL72_AN_TWOP5_DEFAULT_CONTROLr_t;

#define BCMI_TSC_XGXS_CL72_AN_TWOP5_DEFAULT_CONTROLr_CLR(r) (r).cl72_an_twop5_default_control[0] = 0
#define BCMI_TSC_XGXS_CL72_AN_TWOP5_DEFAULT_CONTROLr_SET(r,d) (r).cl72_an_twop5_default_control[0] = d
#define BCMI_TSC_XGXS_CL72_AN_TWOP5_DEFAULT_CONTROLr_GET(r) (r).cl72_an_twop5_default_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CL72_AN_TWOP5_DEFAULT_CONTROLr_CL72_EN_MASKf_GET(r) ((((r).cl72_an_twop5_default_control[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_CL72_AN_TWOP5_DEFAULT_CONTROLr_CL72_EN_MASKf_SET(r,f) (r).cl72_an_twop5_default_control[0]=(((r).cl72_an_twop5_default_control[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_CL72_AN_TWOP5_DEFAULT_CONTROLr_TX_FIR_TAP_POST_2P5_INIT_VALf_GET(r) ((((r).cl72_an_twop5_default_control[0]) >> 10) & 0x1f)
#define BCMI_TSC_XGXS_CL72_AN_TWOP5_DEFAULT_CONTROLr_TX_FIR_TAP_POST_2P5_INIT_VALf_SET(r,f) (r).cl72_an_twop5_default_control[0]=(((r).cl72_an_twop5_default_control[0] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10))
#define BCMI_TSC_XGXS_CL72_AN_TWOP5_DEFAULT_CONTROLr_TX_FIR_TAP_MAIN_2P5_INIT_VALf_GET(r) ((((r).cl72_an_twop5_default_control[0]) >> 4) & 0x3f)
#define BCMI_TSC_XGXS_CL72_AN_TWOP5_DEFAULT_CONTROLr_TX_FIR_TAP_MAIN_2P5_INIT_VALf_SET(r,f) (r).cl72_an_twop5_default_control[0]=(((r).cl72_an_twop5_default_control[0] & ~((uint32_t)0x3f << 4)) | ((((uint32_t)f) & 0x3f) << 4))
#define BCMI_TSC_XGXS_CL72_AN_TWOP5_DEFAULT_CONTROLr_TX_FIR_TAP_PRE_2P5_INIT_VALf_GET(r) (((r).cl72_an_twop5_default_control[0]) & 0xf)
#define BCMI_TSC_XGXS_CL72_AN_TWOP5_DEFAULT_CONTROLr_TX_FIR_TAP_PRE_2P5_INIT_VALf_SET(r,f) (r).cl72_an_twop5_default_control[0]=(((r).cl72_an_twop5_default_control[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access CL72_AN_TWOP5_DEFAULT_CONTROL.
 *
 */
#define BCMI_TSC_XGXS_READ_CL72_AN_TWOP5_DEFAULT_CONTROLr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CL72_AN_TWOP5_DEFAULT_CONTROLr,(_r._cl72_an_twop5_default_control))
#define BCMI_TSC_XGXS_WRITE_CL72_AN_TWOP5_DEFAULT_CONTROLr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CL72_AN_TWOP5_DEFAULT_CONTROLr,(_r._cl72_an_twop5_default_control))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL72_AN_TWOP5_DEFAULT_CONTROLr BCMI_TSC_XGXS_CL72_AN_TWOP5_DEFAULT_CONTROLr
#define CL72_AN_TWOP5_DEFAULT_CONTROLr_SIZE BCMI_TSC_XGXS_CL72_AN_TWOP5_DEFAULT_CONTROLr_SIZE
typedef BCMI_TSC_XGXS_CL72_AN_TWOP5_DEFAULT_CONTROLr_t CL72_AN_TWOP5_DEFAULT_CONTROLr_t;
#define CL72_AN_TWOP5_DEFAULT_CONTROLr_CLR BCMI_TSC_XGXS_CL72_AN_TWOP5_DEFAULT_CONTROLr_CLR
#define CL72_AN_TWOP5_DEFAULT_CONTROLr_SET BCMI_TSC_XGXS_CL72_AN_TWOP5_DEFAULT_CONTROLr_SET
#define CL72_AN_TWOP5_DEFAULT_CONTROLr_GET BCMI_TSC_XGXS_CL72_AN_TWOP5_DEFAULT_CONTROLr_GET
#define CL72_AN_TWOP5_DEFAULT_CONTROLr_CL72_EN_MASKf_GET BCMI_TSC_XGXS_CL72_AN_TWOP5_DEFAULT_CONTROLr_CL72_EN_MASKf_GET
#define CL72_AN_TWOP5_DEFAULT_CONTROLr_CL72_EN_MASKf_SET BCMI_TSC_XGXS_CL72_AN_TWOP5_DEFAULT_CONTROLr_CL72_EN_MASKf_SET
#define CL72_AN_TWOP5_DEFAULT_CONTROLr_TX_FIR_TAP_POST_2P5_INIT_VALf_GET BCMI_TSC_XGXS_CL72_AN_TWOP5_DEFAULT_CONTROLr_TX_FIR_TAP_POST_2P5_INIT_VALf_GET
#define CL72_AN_TWOP5_DEFAULT_CONTROLr_TX_FIR_TAP_POST_2P5_INIT_VALf_SET BCMI_TSC_XGXS_CL72_AN_TWOP5_DEFAULT_CONTROLr_TX_FIR_TAP_POST_2P5_INIT_VALf_SET
#define CL72_AN_TWOP5_DEFAULT_CONTROLr_TX_FIR_TAP_MAIN_2P5_INIT_VALf_GET BCMI_TSC_XGXS_CL72_AN_TWOP5_DEFAULT_CONTROLr_TX_FIR_TAP_MAIN_2P5_INIT_VALf_GET
#define CL72_AN_TWOP5_DEFAULT_CONTROLr_TX_FIR_TAP_MAIN_2P5_INIT_VALf_SET BCMI_TSC_XGXS_CL72_AN_TWOP5_DEFAULT_CONTROLr_TX_FIR_TAP_MAIN_2P5_INIT_VALf_SET
#define CL72_AN_TWOP5_DEFAULT_CONTROLr_TX_FIR_TAP_PRE_2P5_INIT_VALf_GET BCMI_TSC_XGXS_CL72_AN_TWOP5_DEFAULT_CONTROLr_TX_FIR_TAP_PRE_2P5_INIT_VALf_GET
#define CL72_AN_TWOP5_DEFAULT_CONTROLr_TX_FIR_TAP_PRE_2P5_INIT_VALf_SET BCMI_TSC_XGXS_CL72_AN_TWOP5_DEFAULT_CONTROLr_TX_FIR_TAP_PRE_2P5_INIT_VALf_SET
#define READ_CL72_AN_TWOP5_DEFAULT_CONTROLr BCMI_TSC_XGXS_READ_CL72_AN_TWOP5_DEFAULT_CONTROLr
#define WRITE_CL72_AN_TWOP5_DEFAULT_CONTROLr BCMI_TSC_XGXS_WRITE_CL72_AN_TWOP5_DEFAULT_CONTROLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CL72_AN_TWOP5_DEFAULT_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CL72_TAP_LIMIT_CONTROL
 * BLOCKS:   CL72_SHARED
 * REGADDR:  0x9114
 * DESC:     CL72 Tap Limit Control Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     PRE_TAP_LIMIT    
 *     MAIN_TAP_LIMIT   
 *     POST_TAP_LIMIT   
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CL72_TAP_LIMIT_CONTROLr (0x00109114 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CL72_TAP_LIMIT_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program CL72_TAP_LIMIT_CONTROL.
 *
 */
typedef union BCMI_TSC_XGXS_CL72_TAP_LIMIT_CONTROLr_s {
	uint32_t v[1];
	uint32_t cl72_tap_limit_control[1];
	uint32_t _cl72_tap_limit_control;
} BCMI_TSC_XGXS_CL72_TAP_LIMIT_CONTROLr_t;

#define BCMI_TSC_XGXS_CL72_TAP_LIMIT_CONTROLr_CLR(r) (r).cl72_tap_limit_control[0] = 0
#define BCMI_TSC_XGXS_CL72_TAP_LIMIT_CONTROLr_SET(r,d) (r).cl72_tap_limit_control[0] = d
#define BCMI_TSC_XGXS_CL72_TAP_LIMIT_CONTROLr_GET(r) (r).cl72_tap_limit_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CL72_TAP_LIMIT_CONTROLr_RESERVED0f_GET(r) ((((r).cl72_tap_limit_control[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_CL72_TAP_LIMIT_CONTROLr_RESERVED0f_SET(r,f) (r).cl72_tap_limit_control[0]=(((r).cl72_tap_limit_control[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_CL72_TAP_LIMIT_CONTROLr_POST_TAP_LIMITf_GET(r) ((((r).cl72_tap_limit_control[0]) >> 10) & 0x1f)
#define BCMI_TSC_XGXS_CL72_TAP_LIMIT_CONTROLr_POST_TAP_LIMITf_SET(r,f) (r).cl72_tap_limit_control[0]=(((r).cl72_tap_limit_control[0] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10))
#define BCMI_TSC_XGXS_CL72_TAP_LIMIT_CONTROLr_MAIN_TAP_LIMITf_GET(r) ((((r).cl72_tap_limit_control[0]) >> 4) & 0x3f)
#define BCMI_TSC_XGXS_CL72_TAP_LIMIT_CONTROLr_MAIN_TAP_LIMITf_SET(r,f) (r).cl72_tap_limit_control[0]=(((r).cl72_tap_limit_control[0] & ~((uint32_t)0x3f << 4)) | ((((uint32_t)f) & 0x3f) << 4))
#define BCMI_TSC_XGXS_CL72_TAP_LIMIT_CONTROLr_PRE_TAP_LIMITf_GET(r) (((r).cl72_tap_limit_control[0]) & 0xf)
#define BCMI_TSC_XGXS_CL72_TAP_LIMIT_CONTROLr_PRE_TAP_LIMITf_SET(r,f) (r).cl72_tap_limit_control[0]=(((r).cl72_tap_limit_control[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access CL72_TAP_LIMIT_CONTROL.
 *
 */
#define BCMI_TSC_XGXS_READ_CL72_TAP_LIMIT_CONTROLr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CL72_TAP_LIMIT_CONTROLr,(_r._cl72_tap_limit_control))
#define BCMI_TSC_XGXS_WRITE_CL72_TAP_LIMIT_CONTROLr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CL72_TAP_LIMIT_CONTROLr,(_r._cl72_tap_limit_control))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL72_TAP_LIMIT_CONTROLr BCMI_TSC_XGXS_CL72_TAP_LIMIT_CONTROLr
#define CL72_TAP_LIMIT_CONTROLr_SIZE BCMI_TSC_XGXS_CL72_TAP_LIMIT_CONTROLr_SIZE
typedef BCMI_TSC_XGXS_CL72_TAP_LIMIT_CONTROLr_t CL72_TAP_LIMIT_CONTROLr_t;
#define CL72_TAP_LIMIT_CONTROLr_CLR BCMI_TSC_XGXS_CL72_TAP_LIMIT_CONTROLr_CLR
#define CL72_TAP_LIMIT_CONTROLr_SET BCMI_TSC_XGXS_CL72_TAP_LIMIT_CONTROLr_SET
#define CL72_TAP_LIMIT_CONTROLr_GET BCMI_TSC_XGXS_CL72_TAP_LIMIT_CONTROLr_GET
#define CL72_TAP_LIMIT_CONTROLr_RESERVED0f_GET BCMI_TSC_XGXS_CL72_TAP_LIMIT_CONTROLr_RESERVED0f_GET
#define CL72_TAP_LIMIT_CONTROLr_RESERVED0f_SET BCMI_TSC_XGXS_CL72_TAP_LIMIT_CONTROLr_RESERVED0f_SET
#define CL72_TAP_LIMIT_CONTROLr_POST_TAP_LIMITf_GET BCMI_TSC_XGXS_CL72_TAP_LIMIT_CONTROLr_POST_TAP_LIMITf_GET
#define CL72_TAP_LIMIT_CONTROLr_POST_TAP_LIMITf_SET BCMI_TSC_XGXS_CL72_TAP_LIMIT_CONTROLr_POST_TAP_LIMITf_SET
#define CL72_TAP_LIMIT_CONTROLr_MAIN_TAP_LIMITf_GET BCMI_TSC_XGXS_CL72_TAP_LIMIT_CONTROLr_MAIN_TAP_LIMITf_GET
#define CL72_TAP_LIMIT_CONTROLr_MAIN_TAP_LIMITf_SET BCMI_TSC_XGXS_CL72_TAP_LIMIT_CONTROLr_MAIN_TAP_LIMITf_SET
#define CL72_TAP_LIMIT_CONTROLr_PRE_TAP_LIMITf_GET BCMI_TSC_XGXS_CL72_TAP_LIMIT_CONTROLr_PRE_TAP_LIMITf_GET
#define CL72_TAP_LIMIT_CONTROLr_PRE_TAP_LIMITf_SET BCMI_TSC_XGXS_CL72_TAP_LIMIT_CONTROLr_PRE_TAP_LIMITf_SET
#define READ_CL72_TAP_LIMIT_CONTROLr BCMI_TSC_XGXS_READ_CL72_TAP_LIMIT_CONTROLr
#define WRITE_CL72_TAP_LIMIT_CONTROLr BCMI_TSC_XGXS_WRITE_CL72_TAP_LIMIT_CONTROLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CL72_TAP_LIMIT_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CL72_MISC3_CONTROL
 * BLOCKS:   CL72_SHARED
 * REGADDR:  0x9115
 * DESC:     CL72 Miscellaneous_3 Control Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     CL72_EN_MASK_EN  
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CL72_MISC3_CONTROLr (0x00109115 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CL72_MISC3_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program CL72_MISC3_CONTROL.
 *
 */
typedef union BCMI_TSC_XGXS_CL72_MISC3_CONTROLr_s {
	uint32_t v[1];
	uint32_t cl72_misc3_control[1];
	uint32_t _cl72_misc3_control;
} BCMI_TSC_XGXS_CL72_MISC3_CONTROLr_t;

#define BCMI_TSC_XGXS_CL72_MISC3_CONTROLr_CLR(r) (r).cl72_misc3_control[0] = 0
#define BCMI_TSC_XGXS_CL72_MISC3_CONTROLr_SET(r,d) (r).cl72_misc3_control[0] = d
#define BCMI_TSC_XGXS_CL72_MISC3_CONTROLr_GET(r) (r).cl72_misc3_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CL72_MISC3_CONTROLr_CL72_EN_MASK_ENf_GET(r) (((r).cl72_misc3_control[0]) & 0xffff)
#define BCMI_TSC_XGXS_CL72_MISC3_CONTROLr_CL72_EN_MASK_ENf_SET(r,f) (r).cl72_misc3_control[0]=(((r).cl72_misc3_control[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access CL72_MISC3_CONTROL.
 *
 */
#define BCMI_TSC_XGXS_READ_CL72_MISC3_CONTROLr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CL72_MISC3_CONTROLr,(_r._cl72_misc3_control))
#define BCMI_TSC_XGXS_WRITE_CL72_MISC3_CONTROLr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CL72_MISC3_CONTROLr,(_r._cl72_misc3_control))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL72_MISC3_CONTROLr BCMI_TSC_XGXS_CL72_MISC3_CONTROLr
#define CL72_MISC3_CONTROLr_SIZE BCMI_TSC_XGXS_CL72_MISC3_CONTROLr_SIZE
typedef BCMI_TSC_XGXS_CL72_MISC3_CONTROLr_t CL72_MISC3_CONTROLr_t;
#define CL72_MISC3_CONTROLr_CLR BCMI_TSC_XGXS_CL72_MISC3_CONTROLr_CLR
#define CL72_MISC3_CONTROLr_SET BCMI_TSC_XGXS_CL72_MISC3_CONTROLr_SET
#define CL72_MISC3_CONTROLr_GET BCMI_TSC_XGXS_CL72_MISC3_CONTROLr_GET
#define CL72_MISC3_CONTROLr_CL72_EN_MASK_ENf_GET BCMI_TSC_XGXS_CL72_MISC3_CONTROLr_CL72_EN_MASK_ENf_GET
#define CL72_MISC3_CONTROLr_CL72_EN_MASK_ENf_SET BCMI_TSC_XGXS_CL72_MISC3_CONTROLr_CL72_EN_MASK_ENf_SET
#define READ_CL72_MISC3_CONTROLr BCMI_TSC_XGXS_READ_CL72_MISC3_CONTROLr
#define WRITE_CL72_MISC3_CONTROLr BCMI_TSC_XGXS_WRITE_CL72_MISC3_CONTROLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CL72_MISC3_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CL72_TAP_PRESET_CONTROL
 * BLOCKS:   CL72_SHARED
 * REGADDR:  0x9116
 * DESC:     CL72 Tap Present Control Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     POST_INIT_VAL    
 *     PRE_INIT_VAL     
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CL72_TAP_PRESET_CONTROLr (0x00109116 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CL72_TAP_PRESET_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program CL72_TAP_PRESET_CONTROL.
 *
 */
typedef union BCMI_TSC_XGXS_CL72_TAP_PRESET_CONTROLr_s {
	uint32_t v[1];
	uint32_t cl72_tap_preset_control[1];
	uint32_t _cl72_tap_preset_control;
} BCMI_TSC_XGXS_CL72_TAP_PRESET_CONTROLr_t;

#define BCMI_TSC_XGXS_CL72_TAP_PRESET_CONTROLr_CLR(r) (r).cl72_tap_preset_control[0] = 0
#define BCMI_TSC_XGXS_CL72_TAP_PRESET_CONTROLr_SET(r,d) (r).cl72_tap_preset_control[0] = d
#define BCMI_TSC_XGXS_CL72_TAP_PRESET_CONTROLr_GET(r) (r).cl72_tap_preset_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CL72_TAP_PRESET_CONTROLr_RESERVED0f_GET(r) ((((r).cl72_tap_preset_control[0]) >> 9) & 0x7f)
#define BCMI_TSC_XGXS_CL72_TAP_PRESET_CONTROLr_RESERVED0f_SET(r,f) (r).cl72_tap_preset_control[0]=(((r).cl72_tap_preset_control[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))
#define BCMI_TSC_XGXS_CL72_TAP_PRESET_CONTROLr_PRE_INIT_VALf_GET(r) ((((r).cl72_tap_preset_control[0]) >> 5) & 0xf)
#define BCMI_TSC_XGXS_CL72_TAP_PRESET_CONTROLr_PRE_INIT_VALf_SET(r,f) (r).cl72_tap_preset_control[0]=(((r).cl72_tap_preset_control[0] & ~((uint32_t)0xf << 5)) | ((((uint32_t)f) & 0xf) << 5))
#define BCMI_TSC_XGXS_CL72_TAP_PRESET_CONTROLr_POST_INIT_VALf_GET(r) (((r).cl72_tap_preset_control[0]) & 0x1f)
#define BCMI_TSC_XGXS_CL72_TAP_PRESET_CONTROLr_POST_INIT_VALf_SET(r,f) (r).cl72_tap_preset_control[0]=(((r).cl72_tap_preset_control[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))

/*
 * These macros can be used to access CL72_TAP_PRESET_CONTROL.
 *
 */
#define BCMI_TSC_XGXS_READ_CL72_TAP_PRESET_CONTROLr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CL72_TAP_PRESET_CONTROLr,(_r._cl72_tap_preset_control))
#define BCMI_TSC_XGXS_WRITE_CL72_TAP_PRESET_CONTROLr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CL72_TAP_PRESET_CONTROLr,(_r._cl72_tap_preset_control))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL72_TAP_PRESET_CONTROLr BCMI_TSC_XGXS_CL72_TAP_PRESET_CONTROLr
#define CL72_TAP_PRESET_CONTROLr_SIZE BCMI_TSC_XGXS_CL72_TAP_PRESET_CONTROLr_SIZE
typedef BCMI_TSC_XGXS_CL72_TAP_PRESET_CONTROLr_t CL72_TAP_PRESET_CONTROLr_t;
#define CL72_TAP_PRESET_CONTROLr_CLR BCMI_TSC_XGXS_CL72_TAP_PRESET_CONTROLr_CLR
#define CL72_TAP_PRESET_CONTROLr_SET BCMI_TSC_XGXS_CL72_TAP_PRESET_CONTROLr_SET
#define CL72_TAP_PRESET_CONTROLr_GET BCMI_TSC_XGXS_CL72_TAP_PRESET_CONTROLr_GET
#define CL72_TAP_PRESET_CONTROLr_RESERVED0f_GET BCMI_TSC_XGXS_CL72_TAP_PRESET_CONTROLr_RESERVED0f_GET
#define CL72_TAP_PRESET_CONTROLr_RESERVED0f_SET BCMI_TSC_XGXS_CL72_TAP_PRESET_CONTROLr_RESERVED0f_SET
#define CL72_TAP_PRESET_CONTROLr_PRE_INIT_VALf_GET BCMI_TSC_XGXS_CL72_TAP_PRESET_CONTROLr_PRE_INIT_VALf_GET
#define CL72_TAP_PRESET_CONTROLr_PRE_INIT_VALf_SET BCMI_TSC_XGXS_CL72_TAP_PRESET_CONTROLr_PRE_INIT_VALf_SET
#define CL72_TAP_PRESET_CONTROLr_POST_INIT_VALf_GET BCMI_TSC_XGXS_CL72_TAP_PRESET_CONTROLr_POST_INIT_VALf_GET
#define CL72_TAP_PRESET_CONTROLr_POST_INIT_VALf_SET BCMI_TSC_XGXS_CL72_TAP_PRESET_CONTROLr_POST_INIT_VALf_SET
#define READ_CL72_TAP_PRESET_CONTROLr BCMI_TSC_XGXS_READ_CL72_TAP_PRESET_CONTROLr
#define WRITE_CL72_TAP_PRESET_CONTROLr BCMI_TSC_XGXS_WRITE_CL72_TAP_PRESET_CONTROLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CL72_TAP_PRESET_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CL72_DEBUG_1
 * BLOCKS:   CL72_SHARED
 * REGADDR:  0x9117
 * DESC:     CL72 Debug 1 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     TAP_MIN_VAL      
 *     TAP_MAX_VAL      
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CL72_DEBUG_1r (0x00109117 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CL72_DEBUG_1r_SIZE 4

/*
 * This structure should be used to declare and program CL72_DEBUG_1.
 *
 */
typedef union BCMI_TSC_XGXS_CL72_DEBUG_1r_s {
	uint32_t v[1];
	uint32_t cl72_debug_1[1];
	uint32_t _cl72_debug_1;
} BCMI_TSC_XGXS_CL72_DEBUG_1r_t;

#define BCMI_TSC_XGXS_CL72_DEBUG_1r_CLR(r) (r).cl72_debug_1[0] = 0
#define BCMI_TSC_XGXS_CL72_DEBUG_1r_SET(r,d) (r).cl72_debug_1[0] = d
#define BCMI_TSC_XGXS_CL72_DEBUG_1r_GET(r) (r).cl72_debug_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CL72_DEBUG_1r_RESERVED0f_GET(r) ((((r).cl72_debug_1[0]) >> 12) & 0xf)
#define BCMI_TSC_XGXS_CL72_DEBUG_1r_RESERVED0f_SET(r,f) (r).cl72_debug_1[0]=(((r).cl72_debug_1[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCMI_TSC_XGXS_CL72_DEBUG_1r_TAP_MAX_VALf_GET(r) ((((r).cl72_debug_1[0]) >> 6) & 0x3f)
#define BCMI_TSC_XGXS_CL72_DEBUG_1r_TAP_MAX_VALf_SET(r,f) (r).cl72_debug_1[0]=(((r).cl72_debug_1[0] & ~((uint32_t)0x3f << 6)) | ((((uint32_t)f) & 0x3f) << 6))
#define BCMI_TSC_XGXS_CL72_DEBUG_1r_TAP_MIN_VALf_GET(r) (((r).cl72_debug_1[0]) & 0x3f)
#define BCMI_TSC_XGXS_CL72_DEBUG_1r_TAP_MIN_VALf_SET(r,f) (r).cl72_debug_1[0]=(((r).cl72_debug_1[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))

/*
 * These macros can be used to access CL72_DEBUG_1.
 *
 */
#define BCMI_TSC_XGXS_READ_CL72_DEBUG_1r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CL72_DEBUG_1r,(_r._cl72_debug_1))
#define BCMI_TSC_XGXS_WRITE_CL72_DEBUG_1r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CL72_DEBUG_1r,(_r._cl72_debug_1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL72_DEBUG_1r BCMI_TSC_XGXS_CL72_DEBUG_1r
#define CL72_DEBUG_1r_SIZE BCMI_TSC_XGXS_CL72_DEBUG_1r_SIZE
typedef BCMI_TSC_XGXS_CL72_DEBUG_1r_t CL72_DEBUG_1r_t;
#define CL72_DEBUG_1r_CLR BCMI_TSC_XGXS_CL72_DEBUG_1r_CLR
#define CL72_DEBUG_1r_SET BCMI_TSC_XGXS_CL72_DEBUG_1r_SET
#define CL72_DEBUG_1r_GET BCMI_TSC_XGXS_CL72_DEBUG_1r_GET
#define CL72_DEBUG_1r_RESERVED0f_GET BCMI_TSC_XGXS_CL72_DEBUG_1r_RESERVED0f_GET
#define CL72_DEBUG_1r_RESERVED0f_SET BCMI_TSC_XGXS_CL72_DEBUG_1r_RESERVED0f_SET
#define CL72_DEBUG_1r_TAP_MAX_VALf_GET BCMI_TSC_XGXS_CL72_DEBUG_1r_TAP_MAX_VALf_GET
#define CL72_DEBUG_1r_TAP_MAX_VALf_SET BCMI_TSC_XGXS_CL72_DEBUG_1r_TAP_MAX_VALf_SET
#define CL72_DEBUG_1r_TAP_MIN_VALf_GET BCMI_TSC_XGXS_CL72_DEBUG_1r_TAP_MIN_VALf_GET
#define CL72_DEBUG_1r_TAP_MIN_VALf_SET BCMI_TSC_XGXS_CL72_DEBUG_1r_TAP_MIN_VALf_SET
#define READ_CL72_DEBUG_1r BCMI_TSC_XGXS_READ_CL72_DEBUG_1r
#define WRITE_CL72_DEBUG_1r BCMI_TSC_XGXS_WRITE_CL72_DEBUG_1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CL72_DEBUG_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CL72_DEBUG_2_TYPE
 * BLOCKS:   CL72_SHARED
 * REGADDR:  0x9118
 * DESC:     CL72 PRBS CONTROL REGISTER: 00000000
 * SIZE:     32
 * FIELDS:
 *     CL72_PRBS_ENABLE 
 *     CL72_PRBS_TYPE   
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CL72_DEBUG_2_TYPEr (0x00109118 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CL72_DEBUG_2_TYPEr_SIZE 4

/*
 * This structure should be used to declare and program CL72_DEBUG_2_TYPE.
 *
 */
typedef union BCMI_TSC_XGXS_CL72_DEBUG_2_TYPEr_s {
	uint32_t v[1];
	uint32_t cl72_debug_2_type[1];
	uint32_t _cl72_debug_2_type;
} BCMI_TSC_XGXS_CL72_DEBUG_2_TYPEr_t;

#define BCMI_TSC_XGXS_CL72_DEBUG_2_TYPEr_CLR(r) (r).cl72_debug_2_type[0] = 0
#define BCMI_TSC_XGXS_CL72_DEBUG_2_TYPEr_SET(r,d) (r).cl72_debug_2_type[0] = d
#define BCMI_TSC_XGXS_CL72_DEBUG_2_TYPEr_GET(r) (r).cl72_debug_2_type[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CL72_DEBUG_2_TYPEr_RESERVED0f_GET(r) ((((r).cl72_debug_2_type[0]) >> 5) & 0x7ff)
#define BCMI_TSC_XGXS_CL72_DEBUG_2_TYPEr_RESERVED0f_SET(r,f) (r).cl72_debug_2_type[0]=(((r).cl72_debug_2_type[0] & ~((uint32_t)0x7ff << 5)) | ((((uint32_t)f) & 0x7ff) << 5))
#define BCMI_TSC_XGXS_CL72_DEBUG_2_TYPEr_CL72_PRBS_TYPEf_GET(r) ((((r).cl72_debug_2_type[0]) >> 4) & 0x1)
#define BCMI_TSC_XGXS_CL72_DEBUG_2_TYPEr_CL72_PRBS_TYPEf_SET(r,f) (r).cl72_debug_2_type[0]=(((r).cl72_debug_2_type[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCMI_TSC_XGXS_CL72_DEBUG_2_TYPEr_CL72_PRBS_ENABLEf_GET(r) (((r).cl72_debug_2_type[0]) & 0xf)
#define BCMI_TSC_XGXS_CL72_DEBUG_2_TYPEr_CL72_PRBS_ENABLEf_SET(r,f) (r).cl72_debug_2_type[0]=(((r).cl72_debug_2_type[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access CL72_DEBUG_2_TYPE.
 *
 */
#define BCMI_TSC_XGXS_READ_CL72_DEBUG_2_TYPEr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CL72_DEBUG_2_TYPEr,(_r._cl72_debug_2_type))
#define BCMI_TSC_XGXS_WRITE_CL72_DEBUG_2_TYPEr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CL72_DEBUG_2_TYPEr,(_r._cl72_debug_2_type))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL72_DEBUG_2_TYPEr BCMI_TSC_XGXS_CL72_DEBUG_2_TYPEr
#define CL72_DEBUG_2_TYPEr_SIZE BCMI_TSC_XGXS_CL72_DEBUG_2_TYPEr_SIZE
typedef BCMI_TSC_XGXS_CL72_DEBUG_2_TYPEr_t CL72_DEBUG_2_TYPEr_t;
#define CL72_DEBUG_2_TYPEr_CLR BCMI_TSC_XGXS_CL72_DEBUG_2_TYPEr_CLR
#define CL72_DEBUG_2_TYPEr_SET BCMI_TSC_XGXS_CL72_DEBUG_2_TYPEr_SET
#define CL72_DEBUG_2_TYPEr_GET BCMI_TSC_XGXS_CL72_DEBUG_2_TYPEr_GET
#define CL72_DEBUG_2_TYPEr_RESERVED0f_GET BCMI_TSC_XGXS_CL72_DEBUG_2_TYPEr_RESERVED0f_GET
#define CL72_DEBUG_2_TYPEr_RESERVED0f_SET BCMI_TSC_XGXS_CL72_DEBUG_2_TYPEr_RESERVED0f_SET
#define CL72_DEBUG_2_TYPEr_CL72_PRBS_TYPEf_GET BCMI_TSC_XGXS_CL72_DEBUG_2_TYPEr_CL72_PRBS_TYPEf_GET
#define CL72_DEBUG_2_TYPEr_CL72_PRBS_TYPEf_SET BCMI_TSC_XGXS_CL72_DEBUG_2_TYPEr_CL72_PRBS_TYPEf_SET
#define CL72_DEBUG_2_TYPEr_CL72_PRBS_ENABLEf_GET BCMI_TSC_XGXS_CL72_DEBUG_2_TYPEr_CL72_PRBS_ENABLEf_GET
#define CL72_DEBUG_2_TYPEr_CL72_PRBS_ENABLEf_SET BCMI_TSC_XGXS_CL72_DEBUG_2_TYPEr_CL72_PRBS_ENABLEf_SET
#define READ_CL72_DEBUG_2_TYPEr BCMI_TSC_XGXS_READ_CL72_DEBUG_2_TYPEr
#define WRITE_CL72_DEBUG_2_TYPEr BCMI_TSC_XGXS_WRITE_CL72_DEBUG_2_TYPEr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CL72_DEBUG_2_TYPEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CL82_RX_AM_TIMER
 * BLOCKS:   CL82_SHARED
 * REGADDR:  0x9123
 * DESC:     cl82 rx AM timer register: 00000000
 * SIZE:     32
 * FIELDS:
 *     AM_TIMER_INIT_RX_VAL 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CL82_RX_AM_TIMERr (0x00109123 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CL82_RX_AM_TIMERr_SIZE 4

/*
 * This structure should be used to declare and program CL82_RX_AM_TIMER.
 *
 */
typedef union BCMI_TSC_XGXS_CL82_RX_AM_TIMERr_s {
	uint32_t v[1];
	uint32_t cl82_rx_am_timer[1];
	uint32_t _cl82_rx_am_timer;
} BCMI_TSC_XGXS_CL82_RX_AM_TIMERr_t;

#define BCMI_TSC_XGXS_CL82_RX_AM_TIMERr_CLR(r) (r).cl82_rx_am_timer[0] = 0
#define BCMI_TSC_XGXS_CL82_RX_AM_TIMERr_SET(r,d) (r).cl82_rx_am_timer[0] = d
#define BCMI_TSC_XGXS_CL82_RX_AM_TIMERr_GET(r) (r).cl82_rx_am_timer[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CL82_RX_AM_TIMERr_AM_TIMER_INIT_RX_VALf_GET(r) (((r).cl82_rx_am_timer[0]) & 0xffff)
#define BCMI_TSC_XGXS_CL82_RX_AM_TIMERr_AM_TIMER_INIT_RX_VALf_SET(r,f) (r).cl82_rx_am_timer[0]=(((r).cl82_rx_am_timer[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access CL82_RX_AM_TIMER.
 *
 */
#define BCMI_TSC_XGXS_READ_CL82_RX_AM_TIMERr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CL82_RX_AM_TIMERr,(_r._cl82_rx_am_timer))
#define BCMI_TSC_XGXS_WRITE_CL82_RX_AM_TIMERr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CL82_RX_AM_TIMERr,(_r._cl82_rx_am_timer))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL82_RX_AM_TIMERr BCMI_TSC_XGXS_CL82_RX_AM_TIMERr
#define CL82_RX_AM_TIMERr_SIZE BCMI_TSC_XGXS_CL82_RX_AM_TIMERr_SIZE
typedef BCMI_TSC_XGXS_CL82_RX_AM_TIMERr_t CL82_RX_AM_TIMERr_t;
#define CL82_RX_AM_TIMERr_CLR BCMI_TSC_XGXS_CL82_RX_AM_TIMERr_CLR
#define CL82_RX_AM_TIMERr_SET BCMI_TSC_XGXS_CL82_RX_AM_TIMERr_SET
#define CL82_RX_AM_TIMERr_GET BCMI_TSC_XGXS_CL82_RX_AM_TIMERr_GET
#define CL82_RX_AM_TIMERr_AM_TIMER_INIT_RX_VALf_GET BCMI_TSC_XGXS_CL82_RX_AM_TIMERr_AM_TIMER_INIT_RX_VALf_GET
#define CL82_RX_AM_TIMERr_AM_TIMER_INIT_RX_VALf_SET BCMI_TSC_XGXS_CL82_RX_AM_TIMERr_AM_TIMER_INIT_RX_VALf_SET
#define READ_CL82_RX_AM_TIMERr BCMI_TSC_XGXS_READ_CL82_RX_AM_TIMERr
#define WRITE_CL82_RX_AM_TIMERr BCMI_TSC_XGXS_WRITE_CL82_RX_AM_TIMERr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CL82_RX_AM_TIMERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CL82_LANE_0_AM_BYTE10
 * BLOCKS:   CL82_AM_REGS
 * REGADDR:  0x9130
 * DESC:     cl82 LANE 0 AM BYTES 1 AND 0 register: 00000000
 * SIZE:     32
 * FIELDS:
 *     LANE_0_AM_1_0    
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CL82_LANE_0_AM_BYTE10r (0x00109130 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CL82_LANE_0_AM_BYTE10r_SIZE 4

/*
 * This structure should be used to declare and program CL82_LANE_0_AM_BYTE10.
 *
 */
typedef union BCMI_TSC_XGXS_CL82_LANE_0_AM_BYTE10r_s {
	uint32_t v[1];
	uint32_t cl82_lane_0_am_byte10[1];
	uint32_t _cl82_lane_0_am_byte10;
} BCMI_TSC_XGXS_CL82_LANE_0_AM_BYTE10r_t;

#define BCMI_TSC_XGXS_CL82_LANE_0_AM_BYTE10r_CLR(r) (r).cl82_lane_0_am_byte10[0] = 0
#define BCMI_TSC_XGXS_CL82_LANE_0_AM_BYTE10r_SET(r,d) (r).cl82_lane_0_am_byte10[0] = d
#define BCMI_TSC_XGXS_CL82_LANE_0_AM_BYTE10r_GET(r) (r).cl82_lane_0_am_byte10[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CL82_LANE_0_AM_BYTE10r_LANE_0_AM_1_0f_GET(r) (((r).cl82_lane_0_am_byte10[0]) & 0xffff)
#define BCMI_TSC_XGXS_CL82_LANE_0_AM_BYTE10r_LANE_0_AM_1_0f_SET(r,f) (r).cl82_lane_0_am_byte10[0]=(((r).cl82_lane_0_am_byte10[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access CL82_LANE_0_AM_BYTE10.
 *
 */
#define BCMI_TSC_XGXS_READ_CL82_LANE_0_AM_BYTE10r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CL82_LANE_0_AM_BYTE10r,(_r._cl82_lane_0_am_byte10))
#define BCMI_TSC_XGXS_WRITE_CL82_LANE_0_AM_BYTE10r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CL82_LANE_0_AM_BYTE10r,(_r._cl82_lane_0_am_byte10))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL82_LANE_0_AM_BYTE10r BCMI_TSC_XGXS_CL82_LANE_0_AM_BYTE10r
#define CL82_LANE_0_AM_BYTE10r_SIZE BCMI_TSC_XGXS_CL82_LANE_0_AM_BYTE10r_SIZE
typedef BCMI_TSC_XGXS_CL82_LANE_0_AM_BYTE10r_t CL82_LANE_0_AM_BYTE10r_t;
#define CL82_LANE_0_AM_BYTE10r_CLR BCMI_TSC_XGXS_CL82_LANE_0_AM_BYTE10r_CLR
#define CL82_LANE_0_AM_BYTE10r_SET BCMI_TSC_XGXS_CL82_LANE_0_AM_BYTE10r_SET
#define CL82_LANE_0_AM_BYTE10r_GET BCMI_TSC_XGXS_CL82_LANE_0_AM_BYTE10r_GET
#define CL82_LANE_0_AM_BYTE10r_LANE_0_AM_1_0f_GET BCMI_TSC_XGXS_CL82_LANE_0_AM_BYTE10r_LANE_0_AM_1_0f_GET
#define CL82_LANE_0_AM_BYTE10r_LANE_0_AM_1_0f_SET BCMI_TSC_XGXS_CL82_LANE_0_AM_BYTE10r_LANE_0_AM_1_0f_SET
#define READ_CL82_LANE_0_AM_BYTE10r BCMI_TSC_XGXS_READ_CL82_LANE_0_AM_BYTE10r
#define WRITE_CL82_LANE_0_AM_BYTE10r BCMI_TSC_XGXS_WRITE_CL82_LANE_0_AM_BYTE10r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CL82_LANE_0_AM_BYTE10r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CL82_LANE_1_AM_BYTE10
 * BLOCKS:   CL82_AM_REGS
 * REGADDR:  0x9131
 * DESC:     cl82 LANE 1 AM BYTES 1 AND 0 register: 00000000
 * SIZE:     32
 * FIELDS:
 *     LANE_1_AM_1_0    
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CL82_LANE_1_AM_BYTE10r (0x00109131 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CL82_LANE_1_AM_BYTE10r_SIZE 4

/*
 * This structure should be used to declare and program CL82_LANE_1_AM_BYTE10.
 *
 */
typedef union BCMI_TSC_XGXS_CL82_LANE_1_AM_BYTE10r_s {
	uint32_t v[1];
	uint32_t cl82_lane_1_am_byte10[1];
	uint32_t _cl82_lane_1_am_byte10;
} BCMI_TSC_XGXS_CL82_LANE_1_AM_BYTE10r_t;

#define BCMI_TSC_XGXS_CL82_LANE_1_AM_BYTE10r_CLR(r) (r).cl82_lane_1_am_byte10[0] = 0
#define BCMI_TSC_XGXS_CL82_LANE_1_AM_BYTE10r_SET(r,d) (r).cl82_lane_1_am_byte10[0] = d
#define BCMI_TSC_XGXS_CL82_LANE_1_AM_BYTE10r_GET(r) (r).cl82_lane_1_am_byte10[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CL82_LANE_1_AM_BYTE10r_LANE_1_AM_1_0f_GET(r) (((r).cl82_lane_1_am_byte10[0]) & 0xffff)
#define BCMI_TSC_XGXS_CL82_LANE_1_AM_BYTE10r_LANE_1_AM_1_0f_SET(r,f) (r).cl82_lane_1_am_byte10[0]=(((r).cl82_lane_1_am_byte10[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access CL82_LANE_1_AM_BYTE10.
 *
 */
#define BCMI_TSC_XGXS_READ_CL82_LANE_1_AM_BYTE10r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CL82_LANE_1_AM_BYTE10r,(_r._cl82_lane_1_am_byte10))
#define BCMI_TSC_XGXS_WRITE_CL82_LANE_1_AM_BYTE10r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CL82_LANE_1_AM_BYTE10r,(_r._cl82_lane_1_am_byte10))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL82_LANE_1_AM_BYTE10r BCMI_TSC_XGXS_CL82_LANE_1_AM_BYTE10r
#define CL82_LANE_1_AM_BYTE10r_SIZE BCMI_TSC_XGXS_CL82_LANE_1_AM_BYTE10r_SIZE
typedef BCMI_TSC_XGXS_CL82_LANE_1_AM_BYTE10r_t CL82_LANE_1_AM_BYTE10r_t;
#define CL82_LANE_1_AM_BYTE10r_CLR BCMI_TSC_XGXS_CL82_LANE_1_AM_BYTE10r_CLR
#define CL82_LANE_1_AM_BYTE10r_SET BCMI_TSC_XGXS_CL82_LANE_1_AM_BYTE10r_SET
#define CL82_LANE_1_AM_BYTE10r_GET BCMI_TSC_XGXS_CL82_LANE_1_AM_BYTE10r_GET
#define CL82_LANE_1_AM_BYTE10r_LANE_1_AM_1_0f_GET BCMI_TSC_XGXS_CL82_LANE_1_AM_BYTE10r_LANE_1_AM_1_0f_GET
#define CL82_LANE_1_AM_BYTE10r_LANE_1_AM_1_0f_SET BCMI_TSC_XGXS_CL82_LANE_1_AM_BYTE10r_LANE_1_AM_1_0f_SET
#define READ_CL82_LANE_1_AM_BYTE10r BCMI_TSC_XGXS_READ_CL82_LANE_1_AM_BYTE10r
#define WRITE_CL82_LANE_1_AM_BYTE10r BCMI_TSC_XGXS_WRITE_CL82_LANE_1_AM_BYTE10r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CL82_LANE_1_AM_BYTE10r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CL82_LANES_1_0_AM_BYTE2
 * BLOCKS:   CL82_AM_REGS
 * REGADDR:  0x9132
 * DESC:     cl82 LANES 1 and 0 AM BYTE 2 register: 00000000
 * SIZE:     32
 * FIELDS:
 *     LANE_0_AM_0      
 *     LANE_1_AM_0      
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CL82_LANES_1_0_AM_BYTE2r (0x00109132 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CL82_LANES_1_0_AM_BYTE2r_SIZE 4

/*
 * This structure should be used to declare and program CL82_LANES_1_0_AM_BYTE2.
 *
 */
typedef union BCMI_TSC_XGXS_CL82_LANES_1_0_AM_BYTE2r_s {
	uint32_t v[1];
	uint32_t cl82_lanes_1_0_am_byte2[1];
	uint32_t _cl82_lanes_1_0_am_byte2;
} BCMI_TSC_XGXS_CL82_LANES_1_0_AM_BYTE2r_t;

#define BCMI_TSC_XGXS_CL82_LANES_1_0_AM_BYTE2r_CLR(r) (r).cl82_lanes_1_0_am_byte2[0] = 0
#define BCMI_TSC_XGXS_CL82_LANES_1_0_AM_BYTE2r_SET(r,d) (r).cl82_lanes_1_0_am_byte2[0] = d
#define BCMI_TSC_XGXS_CL82_LANES_1_0_AM_BYTE2r_GET(r) (r).cl82_lanes_1_0_am_byte2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CL82_LANES_1_0_AM_BYTE2r_LANE_1_AM_0f_GET(r) ((((r).cl82_lanes_1_0_am_byte2[0]) >> 8) & 0xff)
#define BCMI_TSC_XGXS_CL82_LANES_1_0_AM_BYTE2r_LANE_1_AM_0f_SET(r,f) (r).cl82_lanes_1_0_am_byte2[0]=(((r).cl82_lanes_1_0_am_byte2[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCMI_TSC_XGXS_CL82_LANES_1_0_AM_BYTE2r_LANE_0_AM_0f_GET(r) (((r).cl82_lanes_1_0_am_byte2[0]) & 0xff)
#define BCMI_TSC_XGXS_CL82_LANES_1_0_AM_BYTE2r_LANE_0_AM_0f_SET(r,f) (r).cl82_lanes_1_0_am_byte2[0]=(((r).cl82_lanes_1_0_am_byte2[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access CL82_LANES_1_0_AM_BYTE2.
 *
 */
#define BCMI_TSC_XGXS_READ_CL82_LANES_1_0_AM_BYTE2r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CL82_LANES_1_0_AM_BYTE2r,(_r._cl82_lanes_1_0_am_byte2))
#define BCMI_TSC_XGXS_WRITE_CL82_LANES_1_0_AM_BYTE2r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CL82_LANES_1_0_AM_BYTE2r,(_r._cl82_lanes_1_0_am_byte2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL82_LANES_1_0_AM_BYTE2r BCMI_TSC_XGXS_CL82_LANES_1_0_AM_BYTE2r
#define CL82_LANES_1_0_AM_BYTE2r_SIZE BCMI_TSC_XGXS_CL82_LANES_1_0_AM_BYTE2r_SIZE
typedef BCMI_TSC_XGXS_CL82_LANES_1_0_AM_BYTE2r_t CL82_LANES_1_0_AM_BYTE2r_t;
#define CL82_LANES_1_0_AM_BYTE2r_CLR BCMI_TSC_XGXS_CL82_LANES_1_0_AM_BYTE2r_CLR
#define CL82_LANES_1_0_AM_BYTE2r_SET BCMI_TSC_XGXS_CL82_LANES_1_0_AM_BYTE2r_SET
#define CL82_LANES_1_0_AM_BYTE2r_GET BCMI_TSC_XGXS_CL82_LANES_1_0_AM_BYTE2r_GET
#define CL82_LANES_1_0_AM_BYTE2r_LANE_1_AM_0f_GET BCMI_TSC_XGXS_CL82_LANES_1_0_AM_BYTE2r_LANE_1_AM_0f_GET
#define CL82_LANES_1_0_AM_BYTE2r_LANE_1_AM_0f_SET BCMI_TSC_XGXS_CL82_LANES_1_0_AM_BYTE2r_LANE_1_AM_0f_SET
#define CL82_LANES_1_0_AM_BYTE2r_LANE_0_AM_0f_GET BCMI_TSC_XGXS_CL82_LANES_1_0_AM_BYTE2r_LANE_0_AM_0f_GET
#define CL82_LANES_1_0_AM_BYTE2r_LANE_0_AM_0f_SET BCMI_TSC_XGXS_CL82_LANES_1_0_AM_BYTE2r_LANE_0_AM_0f_SET
#define READ_CL82_LANES_1_0_AM_BYTE2r BCMI_TSC_XGXS_READ_CL82_LANES_1_0_AM_BYTE2r
#define WRITE_CL82_LANES_1_0_AM_BYTE2r BCMI_TSC_XGXS_WRITE_CL82_LANES_1_0_AM_BYTE2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CL82_LANES_1_0_AM_BYTE2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CL82_TSC_12_LANE_2_AM_BYTE10
 * BLOCKS:   CL82_AM_REGS
 * REGADDR:  0x9140
 * DESC:     cl82 LANE 2 AM BYTES 1 AND 0 register: 00000000
 * SIZE:     32
 * FIELDS:
 *     LANE_2_AM_1_0    
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CL82_TSC_12_LANE_2_AM_BYTE10r (0x00109140 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CL82_TSC_12_LANE_2_AM_BYTE10r_SIZE 4

/*
 * This structure should be used to declare and program CL82_TSC_12_LANE_2_AM_BYTE10.
 *
 */
typedef union BCMI_TSC_XGXS_CL82_TSC_12_LANE_2_AM_BYTE10r_s {
	uint32_t v[1];
	uint32_t cl82_tsc_12_lane_2_am_byte10[1];
	uint32_t _cl82_tsc_12_lane_2_am_byte10;
} BCMI_TSC_XGXS_CL82_TSC_12_LANE_2_AM_BYTE10r_t;

#define BCMI_TSC_XGXS_CL82_TSC_12_LANE_2_AM_BYTE10r_CLR(r) (r).cl82_tsc_12_lane_2_am_byte10[0] = 0
#define BCMI_TSC_XGXS_CL82_TSC_12_LANE_2_AM_BYTE10r_SET(r,d) (r).cl82_tsc_12_lane_2_am_byte10[0] = d
#define BCMI_TSC_XGXS_CL82_TSC_12_LANE_2_AM_BYTE10r_GET(r) (r).cl82_tsc_12_lane_2_am_byte10[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CL82_TSC_12_LANE_2_AM_BYTE10r_LANE_2_AM_1_0f_GET(r) (((r).cl82_tsc_12_lane_2_am_byte10[0]) & 0xffff)
#define BCMI_TSC_XGXS_CL82_TSC_12_LANE_2_AM_BYTE10r_LANE_2_AM_1_0f_SET(r,f) (r).cl82_tsc_12_lane_2_am_byte10[0]=(((r).cl82_tsc_12_lane_2_am_byte10[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access CL82_TSC_12_LANE_2_AM_BYTE10.
 *
 */
#define BCMI_TSC_XGXS_READ_CL82_TSC_12_LANE_2_AM_BYTE10r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CL82_TSC_12_LANE_2_AM_BYTE10r,(_r._cl82_tsc_12_lane_2_am_byte10))
#define BCMI_TSC_XGXS_WRITE_CL82_TSC_12_LANE_2_AM_BYTE10r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CL82_TSC_12_LANE_2_AM_BYTE10r,(_r._cl82_tsc_12_lane_2_am_byte10))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL82_TSC_12_LANE_2_AM_BYTE10r BCMI_TSC_XGXS_CL82_TSC_12_LANE_2_AM_BYTE10r
#define CL82_TSC_12_LANE_2_AM_BYTE10r_SIZE BCMI_TSC_XGXS_CL82_TSC_12_LANE_2_AM_BYTE10r_SIZE
typedef BCMI_TSC_XGXS_CL82_TSC_12_LANE_2_AM_BYTE10r_t CL82_TSC_12_LANE_2_AM_BYTE10r_t;
#define CL82_TSC_12_LANE_2_AM_BYTE10r_CLR BCMI_TSC_XGXS_CL82_TSC_12_LANE_2_AM_BYTE10r_CLR
#define CL82_TSC_12_LANE_2_AM_BYTE10r_SET BCMI_TSC_XGXS_CL82_TSC_12_LANE_2_AM_BYTE10r_SET
#define CL82_TSC_12_LANE_2_AM_BYTE10r_GET BCMI_TSC_XGXS_CL82_TSC_12_LANE_2_AM_BYTE10r_GET
#define CL82_TSC_12_LANE_2_AM_BYTE10r_LANE_2_AM_1_0f_GET BCMI_TSC_XGXS_CL82_TSC_12_LANE_2_AM_BYTE10r_LANE_2_AM_1_0f_GET
#define CL82_TSC_12_LANE_2_AM_BYTE10r_LANE_2_AM_1_0f_SET BCMI_TSC_XGXS_CL82_TSC_12_LANE_2_AM_BYTE10r_LANE_2_AM_1_0f_SET
#define READ_CL82_TSC_12_LANE_2_AM_BYTE10r BCMI_TSC_XGXS_READ_CL82_TSC_12_LANE_2_AM_BYTE10r
#define WRITE_CL82_TSC_12_LANE_2_AM_BYTE10r BCMI_TSC_XGXS_WRITE_CL82_TSC_12_LANE_2_AM_BYTE10r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CL82_TSC_12_LANE_2_AM_BYTE10r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CL82_TSC_12_LANE_3_AM_BYTE10
 * BLOCKS:   CL82_AM_REGS
 * REGADDR:  0x9141
 * DESC:     cl82 LANE 3 AM BYTES 1 AND 0 register: 00000000
 * SIZE:     32
 * FIELDS:
 *     LANE_3_AM_1_0    
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CL82_TSC_12_LANE_3_AM_BYTE10r (0x00109141 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CL82_TSC_12_LANE_3_AM_BYTE10r_SIZE 4

/*
 * This structure should be used to declare and program CL82_TSC_12_LANE_3_AM_BYTE10.
 *
 */
typedef union BCMI_TSC_XGXS_CL82_TSC_12_LANE_3_AM_BYTE10r_s {
	uint32_t v[1];
	uint32_t cl82_tsc_12_lane_3_am_byte10[1];
	uint32_t _cl82_tsc_12_lane_3_am_byte10;
} BCMI_TSC_XGXS_CL82_TSC_12_LANE_3_AM_BYTE10r_t;

#define BCMI_TSC_XGXS_CL82_TSC_12_LANE_3_AM_BYTE10r_CLR(r) (r).cl82_tsc_12_lane_3_am_byte10[0] = 0
#define BCMI_TSC_XGXS_CL82_TSC_12_LANE_3_AM_BYTE10r_SET(r,d) (r).cl82_tsc_12_lane_3_am_byte10[0] = d
#define BCMI_TSC_XGXS_CL82_TSC_12_LANE_3_AM_BYTE10r_GET(r) (r).cl82_tsc_12_lane_3_am_byte10[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CL82_TSC_12_LANE_3_AM_BYTE10r_LANE_3_AM_1_0f_GET(r) (((r).cl82_tsc_12_lane_3_am_byte10[0]) & 0xffff)
#define BCMI_TSC_XGXS_CL82_TSC_12_LANE_3_AM_BYTE10r_LANE_3_AM_1_0f_SET(r,f) (r).cl82_tsc_12_lane_3_am_byte10[0]=(((r).cl82_tsc_12_lane_3_am_byte10[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access CL82_TSC_12_LANE_3_AM_BYTE10.
 *
 */
#define BCMI_TSC_XGXS_READ_CL82_TSC_12_LANE_3_AM_BYTE10r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CL82_TSC_12_LANE_3_AM_BYTE10r,(_r._cl82_tsc_12_lane_3_am_byte10))
#define BCMI_TSC_XGXS_WRITE_CL82_TSC_12_LANE_3_AM_BYTE10r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CL82_TSC_12_LANE_3_AM_BYTE10r,(_r._cl82_tsc_12_lane_3_am_byte10))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL82_TSC_12_LANE_3_AM_BYTE10r BCMI_TSC_XGXS_CL82_TSC_12_LANE_3_AM_BYTE10r
#define CL82_TSC_12_LANE_3_AM_BYTE10r_SIZE BCMI_TSC_XGXS_CL82_TSC_12_LANE_3_AM_BYTE10r_SIZE
typedef BCMI_TSC_XGXS_CL82_TSC_12_LANE_3_AM_BYTE10r_t CL82_TSC_12_LANE_3_AM_BYTE10r_t;
#define CL82_TSC_12_LANE_3_AM_BYTE10r_CLR BCMI_TSC_XGXS_CL82_TSC_12_LANE_3_AM_BYTE10r_CLR
#define CL82_TSC_12_LANE_3_AM_BYTE10r_SET BCMI_TSC_XGXS_CL82_TSC_12_LANE_3_AM_BYTE10r_SET
#define CL82_TSC_12_LANE_3_AM_BYTE10r_GET BCMI_TSC_XGXS_CL82_TSC_12_LANE_3_AM_BYTE10r_GET
#define CL82_TSC_12_LANE_3_AM_BYTE10r_LANE_3_AM_1_0f_GET BCMI_TSC_XGXS_CL82_TSC_12_LANE_3_AM_BYTE10r_LANE_3_AM_1_0f_GET
#define CL82_TSC_12_LANE_3_AM_BYTE10r_LANE_3_AM_1_0f_SET BCMI_TSC_XGXS_CL82_TSC_12_LANE_3_AM_BYTE10r_LANE_3_AM_1_0f_SET
#define READ_CL82_TSC_12_LANE_3_AM_BYTE10r BCMI_TSC_XGXS_READ_CL82_TSC_12_LANE_3_AM_BYTE10r
#define WRITE_CL82_TSC_12_LANE_3_AM_BYTE10r BCMI_TSC_XGXS_WRITE_CL82_TSC_12_LANE_3_AM_BYTE10r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CL82_TSC_12_LANE_3_AM_BYTE10r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CL82_TSC_12_LANES_3_2_AM_BYTE2
 * BLOCKS:   CL82_AM_REGS
 * REGADDR:  0x9142
 * DESC:     cl82 LANES 3 and 2 AM BYTE 2 register: 00000000
 * SIZE:     32
 * FIELDS:
 *     LANE_2_AM_2      
 *     LANE_3_AM_2      
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CL82_TSC_12_LANES_3_2_AM_BYTE2r (0x00109142 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CL82_TSC_12_LANES_3_2_AM_BYTE2r_SIZE 4

/*
 * This structure should be used to declare and program CL82_TSC_12_LANES_3_2_AM_BYTE2.
 *
 */
typedef union BCMI_TSC_XGXS_CL82_TSC_12_LANES_3_2_AM_BYTE2r_s {
	uint32_t v[1];
	uint32_t cl82_tsc_12_lanes_3_2_am_byte2[1];
	uint32_t _cl82_tsc_12_lanes_3_2_am_byte2;
} BCMI_TSC_XGXS_CL82_TSC_12_LANES_3_2_AM_BYTE2r_t;

#define BCMI_TSC_XGXS_CL82_TSC_12_LANES_3_2_AM_BYTE2r_CLR(r) (r).cl82_tsc_12_lanes_3_2_am_byte2[0] = 0
#define BCMI_TSC_XGXS_CL82_TSC_12_LANES_3_2_AM_BYTE2r_SET(r,d) (r).cl82_tsc_12_lanes_3_2_am_byte2[0] = d
#define BCMI_TSC_XGXS_CL82_TSC_12_LANES_3_2_AM_BYTE2r_GET(r) (r).cl82_tsc_12_lanes_3_2_am_byte2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CL82_TSC_12_LANES_3_2_AM_BYTE2r_LANE_3_AM_2f_GET(r) ((((r).cl82_tsc_12_lanes_3_2_am_byte2[0]) >> 8) & 0xff)
#define BCMI_TSC_XGXS_CL82_TSC_12_LANES_3_2_AM_BYTE2r_LANE_3_AM_2f_SET(r,f) (r).cl82_tsc_12_lanes_3_2_am_byte2[0]=(((r).cl82_tsc_12_lanes_3_2_am_byte2[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCMI_TSC_XGXS_CL82_TSC_12_LANES_3_2_AM_BYTE2r_LANE_2_AM_2f_GET(r) (((r).cl82_tsc_12_lanes_3_2_am_byte2[0]) & 0xff)
#define BCMI_TSC_XGXS_CL82_TSC_12_LANES_3_2_AM_BYTE2r_LANE_2_AM_2f_SET(r,f) (r).cl82_tsc_12_lanes_3_2_am_byte2[0]=(((r).cl82_tsc_12_lanes_3_2_am_byte2[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access CL82_TSC_12_LANES_3_2_AM_BYTE2.
 *
 */
#define BCMI_TSC_XGXS_READ_CL82_TSC_12_LANES_3_2_AM_BYTE2r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CL82_TSC_12_LANES_3_2_AM_BYTE2r,(_r._cl82_tsc_12_lanes_3_2_am_byte2))
#define BCMI_TSC_XGXS_WRITE_CL82_TSC_12_LANES_3_2_AM_BYTE2r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CL82_TSC_12_LANES_3_2_AM_BYTE2r,(_r._cl82_tsc_12_lanes_3_2_am_byte2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL82_TSC_12_LANES_3_2_AM_BYTE2r BCMI_TSC_XGXS_CL82_TSC_12_LANES_3_2_AM_BYTE2r
#define CL82_TSC_12_LANES_3_2_AM_BYTE2r_SIZE BCMI_TSC_XGXS_CL82_TSC_12_LANES_3_2_AM_BYTE2r_SIZE
typedef BCMI_TSC_XGXS_CL82_TSC_12_LANES_3_2_AM_BYTE2r_t CL82_TSC_12_LANES_3_2_AM_BYTE2r_t;
#define CL82_TSC_12_LANES_3_2_AM_BYTE2r_CLR BCMI_TSC_XGXS_CL82_TSC_12_LANES_3_2_AM_BYTE2r_CLR
#define CL82_TSC_12_LANES_3_2_AM_BYTE2r_SET BCMI_TSC_XGXS_CL82_TSC_12_LANES_3_2_AM_BYTE2r_SET
#define CL82_TSC_12_LANES_3_2_AM_BYTE2r_GET BCMI_TSC_XGXS_CL82_TSC_12_LANES_3_2_AM_BYTE2r_GET
#define CL82_TSC_12_LANES_3_2_AM_BYTE2r_LANE_3_AM_2f_GET BCMI_TSC_XGXS_CL82_TSC_12_LANES_3_2_AM_BYTE2r_LANE_3_AM_2f_GET
#define CL82_TSC_12_LANES_3_2_AM_BYTE2r_LANE_3_AM_2f_SET BCMI_TSC_XGXS_CL82_TSC_12_LANES_3_2_AM_BYTE2r_LANE_3_AM_2f_SET
#define CL82_TSC_12_LANES_3_2_AM_BYTE2r_LANE_2_AM_2f_GET BCMI_TSC_XGXS_CL82_TSC_12_LANES_3_2_AM_BYTE2r_LANE_2_AM_2f_GET
#define CL82_TSC_12_LANES_3_2_AM_BYTE2r_LANE_2_AM_2f_SET BCMI_TSC_XGXS_CL82_TSC_12_LANES_3_2_AM_BYTE2r_LANE_2_AM_2f_SET
#define READ_CL82_TSC_12_LANES_3_2_AM_BYTE2r BCMI_TSC_XGXS_READ_CL82_TSC_12_LANES_3_2_AM_BYTE2r
#define WRITE_CL82_TSC_12_LANES_3_2_AM_BYTE2r BCMI_TSC_XGXS_WRITE_CL82_TSC_12_LANES_3_2_AM_BYTE2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CL82_TSC_12_LANES_3_2_AM_BYTE2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  TX_X1_TX_PI_CONTROL1
 * BLOCKS:   TX_X1_CONTROL0
 * REGADDR:  0x9200
 * DESC:     TX Phase interpolator Control 1 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     TX_PI_EN         
 *     TX_PI_BYPASS_MODE 
 *     TX_PI_PHASE_OVERRIDE 
 *     TX_PI_PHASE_STROBE 
 *     TX_PI_PHASE_DELTA 
 *     TX_PI_PHASE_STEP 
 *     TX_PI_PHASE_STEP_DIR 
 *     TX_PI_PHASE_STEP_MULT 
 *     TX_PI_PHASE_INVERT 
 *     TX_PI_INTEG_SAT_1_OR_2 
 *     TX_PI_INTEG_SAT_SEL 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL1r (0x00109200 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL1r_SIZE 4

/*
 * This structure should be used to declare and program TX_X1_TX_PI_CONTROL1.
 *
 */
typedef union BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL1r_s {
	uint32_t v[1];
	uint32_t tx_x1_tx_pi_control1[1];
	uint32_t _tx_x1_tx_pi_control1;
} BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL1r_t;

#define BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL1r_CLR(r) (r).tx_x1_tx_pi_control1[0] = 0
#define BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL1r_SET(r,d) (r).tx_x1_tx_pi_control1[0] = d
#define BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL1r_GET(r) (r).tx_x1_tx_pi_control1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL1r_TX_PI_INTEG_SAT_SELf_GET(r) ((((r).tx_x1_tx_pi_control1[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL1r_TX_PI_INTEG_SAT_SELf_SET(r,f) (r).tx_x1_tx_pi_control1[0]=(((r).tx_x1_tx_pi_control1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL1r_TX_PI_INTEG_SAT_1_OR_2f_GET(r) ((((r).tx_x1_tx_pi_control1[0]) >> 14) & 0x1)
#define BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL1r_TX_PI_INTEG_SAT_1_OR_2f_SET(r,f) (r).tx_x1_tx_pi_control1[0]=(((r).tx_x1_tx_pi_control1[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL1r_TX_PI_PHASE_INVERTf_GET(r) ((((r).tx_x1_tx_pi_control1[0]) >> 13) & 0x1)
#define BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL1r_TX_PI_PHASE_INVERTf_SET(r,f) (r).tx_x1_tx_pi_control1[0]=(((r).tx_x1_tx_pi_control1[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL1r_TX_PI_PHASE_STEP_MULTf_GET(r) ((((r).tx_x1_tx_pi_control1[0]) >> 12) & 0x1)
#define BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL1r_TX_PI_PHASE_STEP_MULTf_SET(r,f) (r).tx_x1_tx_pi_control1[0]=(((r).tx_x1_tx_pi_control1[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL1r_TX_PI_PHASE_STEP_DIRf_GET(r) ((((r).tx_x1_tx_pi_control1[0]) >> 11) & 0x1)
#define BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL1r_TX_PI_PHASE_STEP_DIRf_SET(r,f) (r).tx_x1_tx_pi_control1[0]=(((r).tx_x1_tx_pi_control1[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL1r_TX_PI_PHASE_STEPf_GET(r) ((((r).tx_x1_tx_pi_control1[0]) >> 9) & 0x3)
#define BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL1r_TX_PI_PHASE_STEPf_SET(r,f) (r).tx_x1_tx_pi_control1[0]=(((r).tx_x1_tx_pi_control1[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9))
#define BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL1r_TX_PI_PHASE_DELTAf_GET(r) ((((r).tx_x1_tx_pi_control1[0]) >> 4) & 0x1f)
#define BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL1r_TX_PI_PHASE_DELTAf_SET(r,f) (r).tx_x1_tx_pi_control1[0]=(((r).tx_x1_tx_pi_control1[0] & ~((uint32_t)0x1f << 4)) | ((((uint32_t)f) & 0x1f) << 4))
#define BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL1r_TX_PI_PHASE_STROBEf_GET(r) ((((r).tx_x1_tx_pi_control1[0]) >> 3) & 0x1)
#define BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL1r_TX_PI_PHASE_STROBEf_SET(r,f) (r).tx_x1_tx_pi_control1[0]=(((r).tx_x1_tx_pi_control1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL1r_TX_PI_PHASE_OVERRIDEf_GET(r) ((((r).tx_x1_tx_pi_control1[0]) >> 2) & 0x1)
#define BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL1r_TX_PI_PHASE_OVERRIDEf_SET(r,f) (r).tx_x1_tx_pi_control1[0]=(((r).tx_x1_tx_pi_control1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL1r_TX_PI_BYPASS_MODEf_GET(r) ((((r).tx_x1_tx_pi_control1[0]) >> 1) & 0x1)
#define BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL1r_TX_PI_BYPASS_MODEf_SET(r,f) (r).tx_x1_tx_pi_control1[0]=(((r).tx_x1_tx_pi_control1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL1r_TX_PI_ENf_GET(r) (((r).tx_x1_tx_pi_control1[0]) & 0x1)
#define BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL1r_TX_PI_ENf_SET(r,f) (r).tx_x1_tx_pi_control1[0]=(((r).tx_x1_tx_pi_control1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access TX_X1_TX_PI_CONTROL1.
 *
 */
#define BCMI_TSC_XGXS_READ_TX_X1_TX_PI_CONTROL1r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL1r,(_r._tx_x1_tx_pi_control1))
#define BCMI_TSC_XGXS_WRITE_TX_X1_TX_PI_CONTROL1r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL1r,(_r._tx_x1_tx_pi_control1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TX_X1_TX_PI_CONTROL1r BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL1r
#define TX_X1_TX_PI_CONTROL1r_SIZE BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL1r_SIZE
typedef BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL1r_t TX_X1_TX_PI_CONTROL1r_t;
#define TX_X1_TX_PI_CONTROL1r_CLR BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL1r_CLR
#define TX_X1_TX_PI_CONTROL1r_SET BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL1r_SET
#define TX_X1_TX_PI_CONTROL1r_GET BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL1r_GET
#define TX_X1_TX_PI_CONTROL1r_TX_PI_INTEG_SAT_SELf_GET BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL1r_TX_PI_INTEG_SAT_SELf_GET
#define TX_X1_TX_PI_CONTROL1r_TX_PI_INTEG_SAT_SELf_SET BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL1r_TX_PI_INTEG_SAT_SELf_SET
#define TX_X1_TX_PI_CONTROL1r_TX_PI_INTEG_SAT_1_OR_2f_GET BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL1r_TX_PI_INTEG_SAT_1_OR_2f_GET
#define TX_X1_TX_PI_CONTROL1r_TX_PI_INTEG_SAT_1_OR_2f_SET BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL1r_TX_PI_INTEG_SAT_1_OR_2f_SET
#define TX_X1_TX_PI_CONTROL1r_TX_PI_PHASE_INVERTf_GET BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL1r_TX_PI_PHASE_INVERTf_GET
#define TX_X1_TX_PI_CONTROL1r_TX_PI_PHASE_INVERTf_SET BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL1r_TX_PI_PHASE_INVERTf_SET
#define TX_X1_TX_PI_CONTROL1r_TX_PI_PHASE_STEP_MULTf_GET BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL1r_TX_PI_PHASE_STEP_MULTf_GET
#define TX_X1_TX_PI_CONTROL1r_TX_PI_PHASE_STEP_MULTf_SET BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL1r_TX_PI_PHASE_STEP_MULTf_SET
#define TX_X1_TX_PI_CONTROL1r_TX_PI_PHASE_STEP_DIRf_GET BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL1r_TX_PI_PHASE_STEP_DIRf_GET
#define TX_X1_TX_PI_CONTROL1r_TX_PI_PHASE_STEP_DIRf_SET BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL1r_TX_PI_PHASE_STEP_DIRf_SET
#define TX_X1_TX_PI_CONTROL1r_TX_PI_PHASE_STEPf_GET BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL1r_TX_PI_PHASE_STEPf_GET
#define TX_X1_TX_PI_CONTROL1r_TX_PI_PHASE_STEPf_SET BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL1r_TX_PI_PHASE_STEPf_SET
#define TX_X1_TX_PI_CONTROL1r_TX_PI_PHASE_DELTAf_GET BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL1r_TX_PI_PHASE_DELTAf_GET
#define TX_X1_TX_PI_CONTROL1r_TX_PI_PHASE_DELTAf_SET BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL1r_TX_PI_PHASE_DELTAf_SET
#define TX_X1_TX_PI_CONTROL1r_TX_PI_PHASE_STROBEf_GET BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL1r_TX_PI_PHASE_STROBEf_GET
#define TX_X1_TX_PI_CONTROL1r_TX_PI_PHASE_STROBEf_SET BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL1r_TX_PI_PHASE_STROBEf_SET
#define TX_X1_TX_PI_CONTROL1r_TX_PI_PHASE_OVERRIDEf_GET BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL1r_TX_PI_PHASE_OVERRIDEf_GET
#define TX_X1_TX_PI_CONTROL1r_TX_PI_PHASE_OVERRIDEf_SET BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL1r_TX_PI_PHASE_OVERRIDEf_SET
#define TX_X1_TX_PI_CONTROL1r_TX_PI_BYPASS_MODEf_GET BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL1r_TX_PI_BYPASS_MODEf_GET
#define TX_X1_TX_PI_CONTROL1r_TX_PI_BYPASS_MODEf_SET BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL1r_TX_PI_BYPASS_MODEf_SET
#define TX_X1_TX_PI_CONTROL1r_TX_PI_ENf_GET BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL1r_TX_PI_ENf_GET
#define TX_X1_TX_PI_CONTROL1r_TX_PI_ENf_SET BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL1r_TX_PI_ENf_SET
#define READ_TX_X1_TX_PI_CONTROL1r BCMI_TSC_XGXS_READ_TX_X1_TX_PI_CONTROL1r
#define WRITE_TX_X1_TX_PI_CONTROL1r BCMI_TSC_XGXS_WRITE_TX_X1_TX_PI_CONTROL1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  TX_X1_TX_PI_CONTROL2
 * BLOCKS:   TX_X1_CONTROL0
 * REGADDR:  0x9201
 * DESC:     TX Phase interpolator Control 2 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     TX_PI_RX_LANE_SEL 
 *     TX_PI_BWSEL_INTEG 
 *     TX_PI_INTEG_REG_CLR 
 *     TX_PI_SM_BYPASS  
 *     TX_PI_LOOPBACK_MODE 
 *     TX_PI_CKGATE_EN  
 *     RESERVED0        
 *     TX_PI_SM_EN_OVERRIDE 
 *     TX_PI_SM_DONE_OVERRIDE 
 *     TX_PI_SM_TIMER_SEL 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL2r (0x00109201 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL2r_SIZE 4

/*
 * This structure should be used to declare and program TX_X1_TX_PI_CONTROL2.
 *
 */
typedef union BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL2r_s {
	uint32_t v[1];
	uint32_t tx_x1_tx_pi_control2[1];
	uint32_t _tx_x1_tx_pi_control2;
} BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL2r_t;

#define BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL2r_CLR(r) (r).tx_x1_tx_pi_control2[0] = 0
#define BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL2r_SET(r,d) (r).tx_x1_tx_pi_control2[0] = d
#define BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL2r_GET(r) (r).tx_x1_tx_pi_control2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL2r_TX_PI_SM_TIMER_SELf_GET(r) ((((r).tx_x1_tx_pi_control2[0]) >> 14) & 0x3)
#define BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL2r_TX_PI_SM_TIMER_SELf_SET(r,f) (r).tx_x1_tx_pi_control2[0]=(((r).tx_x1_tx_pi_control2[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL2r_TX_PI_SM_DONE_OVERRIDEf_GET(r) ((((r).tx_x1_tx_pi_control2[0]) >> 13) & 0x1)
#define BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL2r_TX_PI_SM_DONE_OVERRIDEf_SET(r,f) (r).tx_x1_tx_pi_control2[0]=(((r).tx_x1_tx_pi_control2[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL2r_TX_PI_SM_EN_OVERRIDEf_GET(r) ((((r).tx_x1_tx_pi_control2[0]) >> 12) & 0x1)
#define BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL2r_TX_PI_SM_EN_OVERRIDEf_SET(r,f) (r).tx_x1_tx_pi_control2[0]=(((r).tx_x1_tx_pi_control2[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL2r_RESERVED0f_GET(r) ((((r).tx_x1_tx_pi_control2[0]) >> 9) & 0x7)
#define BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL2r_RESERVED0f_SET(r,f) (r).tx_x1_tx_pi_control2[0]=(((r).tx_x1_tx_pi_control2[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL2r_TX_PI_CKGATE_ENf_GET(r) ((((r).tx_x1_tx_pi_control2[0]) >> 8) & 0x1)
#define BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL2r_TX_PI_CKGATE_ENf_SET(r,f) (r).tx_x1_tx_pi_control2[0]=(((r).tx_x1_tx_pi_control2[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL2r_TX_PI_LOOPBACK_MODEf_GET(r) ((((r).tx_x1_tx_pi_control2[0]) >> 7) & 0x1)
#define BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL2r_TX_PI_LOOPBACK_MODEf_SET(r,f) (r).tx_x1_tx_pi_control2[0]=(((r).tx_x1_tx_pi_control2[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL2r_TX_PI_SM_BYPASSf_GET(r) ((((r).tx_x1_tx_pi_control2[0]) >> 6) & 0x1)
#define BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL2r_TX_PI_SM_BYPASSf_SET(r,f) (r).tx_x1_tx_pi_control2[0]=(((r).tx_x1_tx_pi_control2[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL2r_TX_PI_INTEG_REG_CLRf_GET(r) ((((r).tx_x1_tx_pi_control2[0]) >> 5) & 0x1)
#define BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL2r_TX_PI_INTEG_REG_CLRf_SET(r,f) (r).tx_x1_tx_pi_control2[0]=(((r).tx_x1_tx_pi_control2[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL2r_TX_PI_BWSEL_INTEGf_GET(r) ((((r).tx_x1_tx_pi_control2[0]) >> 2) & 0x7)
#define BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL2r_TX_PI_BWSEL_INTEGf_SET(r,f) (r).tx_x1_tx_pi_control2[0]=(((r).tx_x1_tx_pi_control2[0] & ~((uint32_t)0x7 << 2)) | ((((uint32_t)f) & 0x7) << 2))
#define BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL2r_TX_PI_RX_LANE_SELf_GET(r) (((r).tx_x1_tx_pi_control2[0]) & 0x3)
#define BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL2r_TX_PI_RX_LANE_SELf_SET(r,f) (r).tx_x1_tx_pi_control2[0]=(((r).tx_x1_tx_pi_control2[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))

/*
 * These macros can be used to access TX_X1_TX_PI_CONTROL2.
 *
 */
#define BCMI_TSC_XGXS_READ_TX_X1_TX_PI_CONTROL2r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL2r,(_r._tx_x1_tx_pi_control2))
#define BCMI_TSC_XGXS_WRITE_TX_X1_TX_PI_CONTROL2r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL2r,(_r._tx_x1_tx_pi_control2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TX_X1_TX_PI_CONTROL2r BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL2r
#define TX_X1_TX_PI_CONTROL2r_SIZE BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL2r_SIZE
typedef BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL2r_t TX_X1_TX_PI_CONTROL2r_t;
#define TX_X1_TX_PI_CONTROL2r_CLR BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL2r_CLR
#define TX_X1_TX_PI_CONTROL2r_SET BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL2r_SET
#define TX_X1_TX_PI_CONTROL2r_GET BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL2r_GET
#define TX_X1_TX_PI_CONTROL2r_TX_PI_SM_TIMER_SELf_GET BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL2r_TX_PI_SM_TIMER_SELf_GET
#define TX_X1_TX_PI_CONTROL2r_TX_PI_SM_TIMER_SELf_SET BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL2r_TX_PI_SM_TIMER_SELf_SET
#define TX_X1_TX_PI_CONTROL2r_TX_PI_SM_DONE_OVERRIDEf_GET BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL2r_TX_PI_SM_DONE_OVERRIDEf_GET
#define TX_X1_TX_PI_CONTROL2r_TX_PI_SM_DONE_OVERRIDEf_SET BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL2r_TX_PI_SM_DONE_OVERRIDEf_SET
#define TX_X1_TX_PI_CONTROL2r_TX_PI_SM_EN_OVERRIDEf_GET BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL2r_TX_PI_SM_EN_OVERRIDEf_GET
#define TX_X1_TX_PI_CONTROL2r_TX_PI_SM_EN_OVERRIDEf_SET BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL2r_TX_PI_SM_EN_OVERRIDEf_SET
#define TX_X1_TX_PI_CONTROL2r_RESERVED0f_GET BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL2r_RESERVED0f_GET
#define TX_X1_TX_PI_CONTROL2r_RESERVED0f_SET BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL2r_RESERVED0f_SET
#define TX_X1_TX_PI_CONTROL2r_TX_PI_CKGATE_ENf_GET BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL2r_TX_PI_CKGATE_ENf_GET
#define TX_X1_TX_PI_CONTROL2r_TX_PI_CKGATE_ENf_SET BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL2r_TX_PI_CKGATE_ENf_SET
#define TX_X1_TX_PI_CONTROL2r_TX_PI_LOOPBACK_MODEf_GET BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL2r_TX_PI_LOOPBACK_MODEf_GET
#define TX_X1_TX_PI_CONTROL2r_TX_PI_LOOPBACK_MODEf_SET BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL2r_TX_PI_LOOPBACK_MODEf_SET
#define TX_X1_TX_PI_CONTROL2r_TX_PI_SM_BYPASSf_GET BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL2r_TX_PI_SM_BYPASSf_GET
#define TX_X1_TX_PI_CONTROL2r_TX_PI_SM_BYPASSf_SET BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL2r_TX_PI_SM_BYPASSf_SET
#define TX_X1_TX_PI_CONTROL2r_TX_PI_INTEG_REG_CLRf_GET BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL2r_TX_PI_INTEG_REG_CLRf_GET
#define TX_X1_TX_PI_CONTROL2r_TX_PI_INTEG_REG_CLRf_SET BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL2r_TX_PI_INTEG_REG_CLRf_SET
#define TX_X1_TX_PI_CONTROL2r_TX_PI_BWSEL_INTEGf_GET BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL2r_TX_PI_BWSEL_INTEGf_GET
#define TX_X1_TX_PI_CONTROL2r_TX_PI_BWSEL_INTEGf_SET BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL2r_TX_PI_BWSEL_INTEGf_SET
#define TX_X1_TX_PI_CONTROL2r_TX_PI_RX_LANE_SELf_GET BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL2r_TX_PI_RX_LANE_SELf_GET
#define TX_X1_TX_PI_CONTROL2r_TX_PI_RX_LANE_SELf_SET BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL2r_TX_PI_RX_LANE_SELf_SET
#define READ_TX_X1_TX_PI_CONTROL2r BCMI_TSC_XGXS_READ_TX_X1_TX_PI_CONTROL2r
#define WRITE_TX_X1_TX_PI_CONTROL2r BCMI_TSC_XGXS_WRITE_TX_X1_TX_PI_CONTROL2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  TX_X1_TX_PI_CONTROL3
 * BLOCKS:   TX_X1_CONTROL0
 * REGADDR:  0x9202
 * DESC:     TX Phase interpolator Control 3 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     TX_PI_FREQ_OVERRIDE_EN 
 *     TX_PI_FREQ_OVERRIDE_VAL 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL3r (0x00109202 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL3r_SIZE 4

/*
 * This structure should be used to declare and program TX_X1_TX_PI_CONTROL3.
 *
 */
typedef union BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL3r_s {
	uint32_t v[1];
	uint32_t tx_x1_tx_pi_control3[1];
	uint32_t _tx_x1_tx_pi_control3;
} BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL3r_t;

#define BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL3r_CLR(r) (r).tx_x1_tx_pi_control3[0] = 0
#define BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL3r_SET(r,d) (r).tx_x1_tx_pi_control3[0] = d
#define BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL3r_GET(r) (r).tx_x1_tx_pi_control3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL3r_TX_PI_FREQ_OVERRIDE_VALf_GET(r) ((((r).tx_x1_tx_pi_control3[0]) >> 1) & 0x7fff)
#define BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL3r_TX_PI_FREQ_OVERRIDE_VALf_SET(r,f) (r).tx_x1_tx_pi_control3[0]=(((r).tx_x1_tx_pi_control3[0] & ~((uint32_t)0x7fff << 1)) | ((((uint32_t)f) & 0x7fff) << 1))
#define BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL3r_TX_PI_FREQ_OVERRIDE_ENf_GET(r) (((r).tx_x1_tx_pi_control3[0]) & 0x1)
#define BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL3r_TX_PI_FREQ_OVERRIDE_ENf_SET(r,f) (r).tx_x1_tx_pi_control3[0]=(((r).tx_x1_tx_pi_control3[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access TX_X1_TX_PI_CONTROL3.
 *
 */
#define BCMI_TSC_XGXS_READ_TX_X1_TX_PI_CONTROL3r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL3r,(_r._tx_x1_tx_pi_control3))
#define BCMI_TSC_XGXS_WRITE_TX_X1_TX_PI_CONTROL3r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL3r,(_r._tx_x1_tx_pi_control3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TX_X1_TX_PI_CONTROL3r BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL3r
#define TX_X1_TX_PI_CONTROL3r_SIZE BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL3r_SIZE
typedef BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL3r_t TX_X1_TX_PI_CONTROL3r_t;
#define TX_X1_TX_PI_CONTROL3r_CLR BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL3r_CLR
#define TX_X1_TX_PI_CONTROL3r_SET BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL3r_SET
#define TX_X1_TX_PI_CONTROL3r_GET BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL3r_GET
#define TX_X1_TX_PI_CONTROL3r_TX_PI_FREQ_OVERRIDE_VALf_GET BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL3r_TX_PI_FREQ_OVERRIDE_VALf_GET
#define TX_X1_TX_PI_CONTROL3r_TX_PI_FREQ_OVERRIDE_VALf_SET BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL3r_TX_PI_FREQ_OVERRIDE_VALf_SET
#define TX_X1_TX_PI_CONTROL3r_TX_PI_FREQ_OVERRIDE_ENf_GET BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL3r_TX_PI_FREQ_OVERRIDE_ENf_GET
#define TX_X1_TX_PI_CONTROL3r_TX_PI_FREQ_OVERRIDE_ENf_SET BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL3r_TX_PI_FREQ_OVERRIDE_ENf_SET
#define READ_TX_X1_TX_PI_CONTROL3r BCMI_TSC_XGXS_READ_TX_X1_TX_PI_CONTROL3r
#define WRITE_TX_X1_TX_PI_CONTROL3r BCMI_TSC_XGXS_WRITE_TX_X1_TX_PI_CONTROL3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_TX_X1_TX_PI_CONTROL3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  TX_X1_TX_PI_STATUS1
 * BLOCKS:   TX_X1_STATUS0
 * REGADDR:  0x9210
 * DESC:     TX Phase interpolator Status 1 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     TX_PI_INTEG_REG  
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_TX_X1_TX_PI_STATUS1r (0x00109210 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_TX_X1_TX_PI_STATUS1r_SIZE 4

/*
 * This structure should be used to declare and program TX_X1_TX_PI_STATUS1.
 *
 */
typedef union BCMI_TSC_XGXS_TX_X1_TX_PI_STATUS1r_s {
	uint32_t v[1];
	uint32_t tx_x1_tx_pi_status1[1];
	uint32_t _tx_x1_tx_pi_status1;
} BCMI_TSC_XGXS_TX_X1_TX_PI_STATUS1r_t;

#define BCMI_TSC_XGXS_TX_X1_TX_PI_STATUS1r_CLR(r) (r).tx_x1_tx_pi_status1[0] = 0
#define BCMI_TSC_XGXS_TX_X1_TX_PI_STATUS1r_SET(r,d) (r).tx_x1_tx_pi_status1[0] = d
#define BCMI_TSC_XGXS_TX_X1_TX_PI_STATUS1r_GET(r) (r).tx_x1_tx_pi_status1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_TX_X1_TX_PI_STATUS1r_RESERVED0f_GET(r) ((((r).tx_x1_tx_pi_status1[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_TX_X1_TX_PI_STATUS1r_RESERVED0f_SET(r,f) (r).tx_x1_tx_pi_status1[0]=(((r).tx_x1_tx_pi_status1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_TX_X1_TX_PI_STATUS1r_TX_PI_INTEG_REGf_GET(r) (((r).tx_x1_tx_pi_status1[0]) & 0x7fff)
#define BCMI_TSC_XGXS_TX_X1_TX_PI_STATUS1r_TX_PI_INTEG_REGf_SET(r,f) (r).tx_x1_tx_pi_status1[0]=(((r).tx_x1_tx_pi_status1[0] & ~((uint32_t)0x7fff)) | (((uint32_t)f) & 0x7fff))

/*
 * These macros can be used to access TX_X1_TX_PI_STATUS1.
 *
 */
#define BCMI_TSC_XGXS_READ_TX_X1_TX_PI_STATUS1r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_TX_X1_TX_PI_STATUS1r,(_r._tx_x1_tx_pi_status1))
#define BCMI_TSC_XGXS_WRITE_TX_X1_TX_PI_STATUS1r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_TX_X1_TX_PI_STATUS1r,(_r._tx_x1_tx_pi_status1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TX_X1_TX_PI_STATUS1r BCMI_TSC_XGXS_TX_X1_TX_PI_STATUS1r
#define TX_X1_TX_PI_STATUS1r_SIZE BCMI_TSC_XGXS_TX_X1_TX_PI_STATUS1r_SIZE
typedef BCMI_TSC_XGXS_TX_X1_TX_PI_STATUS1r_t TX_X1_TX_PI_STATUS1r_t;
#define TX_X1_TX_PI_STATUS1r_CLR BCMI_TSC_XGXS_TX_X1_TX_PI_STATUS1r_CLR
#define TX_X1_TX_PI_STATUS1r_SET BCMI_TSC_XGXS_TX_X1_TX_PI_STATUS1r_SET
#define TX_X1_TX_PI_STATUS1r_GET BCMI_TSC_XGXS_TX_X1_TX_PI_STATUS1r_GET
#define TX_X1_TX_PI_STATUS1r_RESERVED0f_GET BCMI_TSC_XGXS_TX_X1_TX_PI_STATUS1r_RESERVED0f_GET
#define TX_X1_TX_PI_STATUS1r_RESERVED0f_SET BCMI_TSC_XGXS_TX_X1_TX_PI_STATUS1r_RESERVED0f_SET
#define TX_X1_TX_PI_STATUS1r_TX_PI_INTEG_REGf_GET BCMI_TSC_XGXS_TX_X1_TX_PI_STATUS1r_TX_PI_INTEG_REGf_GET
#define TX_X1_TX_PI_STATUS1r_TX_PI_INTEG_REGf_SET BCMI_TSC_XGXS_TX_X1_TX_PI_STATUS1r_TX_PI_INTEG_REGf_SET
#define READ_TX_X1_TX_PI_STATUS1r BCMI_TSC_XGXS_READ_TX_X1_TX_PI_STATUS1r
#define WRITE_TX_X1_TX_PI_STATUS1r BCMI_TSC_XGXS_WRITE_TX_X1_TX_PI_STATUS1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_TX_X1_TX_PI_STATUS1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  TX_X1_TX_PI_STATUS2
 * BLOCKS:   TX_X1_STATUS0
 * REGADDR:  0x9211
 * DESC:     TX Phase interpolator Status 2 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     TX_PI_PHASE_CNTR 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_TX_X1_TX_PI_STATUS2r (0x00109211 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_TX_X1_TX_PI_STATUS2r_SIZE 4

/*
 * This structure should be used to declare and program TX_X1_TX_PI_STATUS2.
 *
 */
typedef union BCMI_TSC_XGXS_TX_X1_TX_PI_STATUS2r_s {
	uint32_t v[1];
	uint32_t tx_x1_tx_pi_status2[1];
	uint32_t _tx_x1_tx_pi_status2;
} BCMI_TSC_XGXS_TX_X1_TX_PI_STATUS2r_t;

#define BCMI_TSC_XGXS_TX_X1_TX_PI_STATUS2r_CLR(r) (r).tx_x1_tx_pi_status2[0] = 0
#define BCMI_TSC_XGXS_TX_X1_TX_PI_STATUS2r_SET(r,d) (r).tx_x1_tx_pi_status2[0] = d
#define BCMI_TSC_XGXS_TX_X1_TX_PI_STATUS2r_GET(r) (r).tx_x1_tx_pi_status2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_TX_X1_TX_PI_STATUS2r_RESERVED0f_GET(r) ((((r).tx_x1_tx_pi_status2[0]) >> 7) & 0x1ff)
#define BCMI_TSC_XGXS_TX_X1_TX_PI_STATUS2r_RESERVED0f_SET(r,f) (r).tx_x1_tx_pi_status2[0]=(((r).tx_x1_tx_pi_status2[0] & ~((uint32_t)0x1ff << 7)) | ((((uint32_t)f) & 0x1ff) << 7))
#define BCMI_TSC_XGXS_TX_X1_TX_PI_STATUS2r_TX_PI_PHASE_CNTRf_GET(r) (((r).tx_x1_tx_pi_status2[0]) & 0x7f)
#define BCMI_TSC_XGXS_TX_X1_TX_PI_STATUS2r_TX_PI_PHASE_CNTRf_SET(r,f) (r).tx_x1_tx_pi_status2[0]=(((r).tx_x1_tx_pi_status2[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f))

/*
 * These macros can be used to access TX_X1_TX_PI_STATUS2.
 *
 */
#define BCMI_TSC_XGXS_READ_TX_X1_TX_PI_STATUS2r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_TX_X1_TX_PI_STATUS2r,(_r._tx_x1_tx_pi_status2))
#define BCMI_TSC_XGXS_WRITE_TX_X1_TX_PI_STATUS2r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_TX_X1_TX_PI_STATUS2r,(_r._tx_x1_tx_pi_status2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TX_X1_TX_PI_STATUS2r BCMI_TSC_XGXS_TX_X1_TX_PI_STATUS2r
#define TX_X1_TX_PI_STATUS2r_SIZE BCMI_TSC_XGXS_TX_X1_TX_PI_STATUS2r_SIZE
typedef BCMI_TSC_XGXS_TX_X1_TX_PI_STATUS2r_t TX_X1_TX_PI_STATUS2r_t;
#define TX_X1_TX_PI_STATUS2r_CLR BCMI_TSC_XGXS_TX_X1_TX_PI_STATUS2r_CLR
#define TX_X1_TX_PI_STATUS2r_SET BCMI_TSC_XGXS_TX_X1_TX_PI_STATUS2r_SET
#define TX_X1_TX_PI_STATUS2r_GET BCMI_TSC_XGXS_TX_X1_TX_PI_STATUS2r_GET
#define TX_X1_TX_PI_STATUS2r_RESERVED0f_GET BCMI_TSC_XGXS_TX_X1_TX_PI_STATUS2r_RESERVED0f_GET
#define TX_X1_TX_PI_STATUS2r_RESERVED0f_SET BCMI_TSC_XGXS_TX_X1_TX_PI_STATUS2r_RESERVED0f_SET
#define TX_X1_TX_PI_STATUS2r_TX_PI_PHASE_CNTRf_GET BCMI_TSC_XGXS_TX_X1_TX_PI_STATUS2r_TX_PI_PHASE_CNTRf_GET
#define TX_X1_TX_PI_STATUS2r_TX_PI_PHASE_CNTRf_SET BCMI_TSC_XGXS_TX_X1_TX_PI_STATUS2r_TX_PI_PHASE_CNTRf_SET
#define READ_TX_X1_TX_PI_STATUS2r BCMI_TSC_XGXS_READ_TX_X1_TX_PI_STATUS2r
#define WRITE_TX_X1_TX_PI_STATUS2r BCMI_TSC_XGXS_WRITE_TX_X1_TX_PI_STATUS2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_TX_X1_TX_PI_STATUS2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  TX_X1_TLA_STATUS
 * BLOCKS:   TX_X1_STATUS0
 * REGADDR:  0x9212
 * DESC:     TLA STATUS REGISTER: 00000000
 * SIZE:     32
 * FIELDS:
 *     TLA_PLL_SEQUENCER_FSM_STATUS 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_TX_X1_TLA_STATUSr (0x00109212 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_TX_X1_TLA_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program TX_X1_TLA_STATUS.
 *
 */
typedef union BCMI_TSC_XGXS_TX_X1_TLA_STATUSr_s {
	uint32_t v[1];
	uint32_t tx_x1_tla_status[1];
	uint32_t _tx_x1_tla_status;
} BCMI_TSC_XGXS_TX_X1_TLA_STATUSr_t;

#define BCMI_TSC_XGXS_TX_X1_TLA_STATUSr_CLR(r) (r).tx_x1_tla_status[0] = 0
#define BCMI_TSC_XGXS_TX_X1_TLA_STATUSr_SET(r,d) (r).tx_x1_tla_status[0] = d
#define BCMI_TSC_XGXS_TX_X1_TLA_STATUSr_GET(r) (r).tx_x1_tla_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_TX_X1_TLA_STATUSr_RESERVED0f_GET(r) ((((r).tx_x1_tla_status[0]) >> 5) & 0x7ff)
#define BCMI_TSC_XGXS_TX_X1_TLA_STATUSr_RESERVED0f_SET(r,f) (r).tx_x1_tla_status[0]=(((r).tx_x1_tla_status[0] & ~((uint32_t)0x7ff << 5)) | ((((uint32_t)f) & 0x7ff) << 5))
#define BCMI_TSC_XGXS_TX_X1_TLA_STATUSr_TLA_PLL_SEQUENCER_FSM_STATUSf_GET(r) (((r).tx_x1_tla_status[0]) & 0x1f)
#define BCMI_TSC_XGXS_TX_X1_TLA_STATUSr_TLA_PLL_SEQUENCER_FSM_STATUSf_SET(r,f) (r).tx_x1_tla_status[0]=(((r).tx_x1_tla_status[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))

/*
 * These macros can be used to access TX_X1_TLA_STATUS.
 *
 */
#define BCMI_TSC_XGXS_READ_TX_X1_TLA_STATUSr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_TX_X1_TLA_STATUSr,(_r._tx_x1_tla_status))
#define BCMI_TSC_XGXS_WRITE_TX_X1_TLA_STATUSr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_TX_X1_TLA_STATUSr,(_r._tx_x1_tla_status))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TX_X1_TLA_STATUSr BCMI_TSC_XGXS_TX_X1_TLA_STATUSr
#define TX_X1_TLA_STATUSr_SIZE BCMI_TSC_XGXS_TX_X1_TLA_STATUSr_SIZE
typedef BCMI_TSC_XGXS_TX_X1_TLA_STATUSr_t TX_X1_TLA_STATUSr_t;
#define TX_X1_TLA_STATUSr_CLR BCMI_TSC_XGXS_TX_X1_TLA_STATUSr_CLR
#define TX_X1_TLA_STATUSr_SET BCMI_TSC_XGXS_TX_X1_TLA_STATUSr_SET
#define TX_X1_TLA_STATUSr_GET BCMI_TSC_XGXS_TX_X1_TLA_STATUSr_GET
#define TX_X1_TLA_STATUSr_RESERVED0f_GET BCMI_TSC_XGXS_TX_X1_TLA_STATUSr_RESERVED0f_GET
#define TX_X1_TLA_STATUSr_RESERVED0f_SET BCMI_TSC_XGXS_TX_X1_TLA_STATUSr_RESERVED0f_SET
#define TX_X1_TLA_STATUSr_TLA_PLL_SEQUENCER_FSM_STATUSf_GET BCMI_TSC_XGXS_TX_X1_TLA_STATUSr_TLA_PLL_SEQUENCER_FSM_STATUSf_GET
#define TX_X1_TLA_STATUSr_TLA_PLL_SEQUENCER_FSM_STATUSf_SET BCMI_TSC_XGXS_TX_X1_TLA_STATUSr_TLA_PLL_SEQUENCER_FSM_STATUSf_SET
#define READ_TX_X1_TLA_STATUSr BCMI_TSC_XGXS_READ_TX_X1_TLA_STATUSr
#define WRITE_TX_X1_TLA_STATUSr BCMI_TSC_XGXS_WRITE_TX_X1_TLA_STATUSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_TX_X1_TLA_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X1_DECODE_CONTROL_0
 * BLOCKS:   RX_X1_CONTROL0
 * REGADDR:  0x9220
 * DESC:     Sync code word statemachine control register: 00000000
 * SIZE:     32
 * FIELDS:
 *     HYSTCOUNT        
 *     GCWCOUNT         
 *     SCWCOUNT         
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X1_DECODE_CONTROL_0r (0x00109220 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X1_DECODE_CONTROL_0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_DECODE_CONTROL_0.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X1_DECODE_CONTROL_0r_s {
	uint32_t v[1];
	uint32_t rx_x1_decode_control_0[1];
	uint32_t _rx_x1_decode_control_0;
} BCMI_TSC_XGXS_RX_X1_DECODE_CONTROL_0r_t;

#define BCMI_TSC_XGXS_RX_X1_DECODE_CONTROL_0r_CLR(r) (r).rx_x1_decode_control_0[0] = 0
#define BCMI_TSC_XGXS_RX_X1_DECODE_CONTROL_0r_SET(r,d) (r).rx_x1_decode_control_0[0] = d
#define BCMI_TSC_XGXS_RX_X1_DECODE_CONTROL_0r_GET(r) (r).rx_x1_decode_control_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X1_DECODE_CONTROL_0r_RESERVED0f_GET(r) ((((r).rx_x1_decode_control_0[0]) >> 12) & 0xf)
#define BCMI_TSC_XGXS_RX_X1_DECODE_CONTROL_0r_RESERVED0f_SET(r,f) (r).rx_x1_decode_control_0[0]=(((r).rx_x1_decode_control_0[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCMI_TSC_XGXS_RX_X1_DECODE_CONTROL_0r_SCWCOUNTf_GET(r) ((((r).rx_x1_decode_control_0[0]) >> 8) & 0xf)
#define BCMI_TSC_XGXS_RX_X1_DECODE_CONTROL_0r_SCWCOUNTf_SET(r,f) (r).rx_x1_decode_control_0[0]=(((r).rx_x1_decode_control_0[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCMI_TSC_XGXS_RX_X1_DECODE_CONTROL_0r_GCWCOUNTf_GET(r) ((((r).rx_x1_decode_control_0[0]) >> 4) & 0xf)
#define BCMI_TSC_XGXS_RX_X1_DECODE_CONTROL_0r_GCWCOUNTf_SET(r,f) (r).rx_x1_decode_control_0[0]=(((r).rx_x1_decode_control_0[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCMI_TSC_XGXS_RX_X1_DECODE_CONTROL_0r_HYSTCOUNTf_GET(r) (((r).rx_x1_decode_control_0[0]) & 0xf)
#define BCMI_TSC_XGXS_RX_X1_DECODE_CONTROL_0r_HYSTCOUNTf_SET(r,f) (r).rx_x1_decode_control_0[0]=(((r).rx_x1_decode_control_0[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access RX_X1_DECODE_CONTROL_0.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X1_DECODE_CONTROL_0r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X1_DECODE_CONTROL_0r,(_r._rx_x1_decode_control_0))
#define BCMI_TSC_XGXS_WRITE_RX_X1_DECODE_CONTROL_0r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X1_DECODE_CONTROL_0r,(_r._rx_x1_decode_control_0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_DECODE_CONTROL_0r BCMI_TSC_XGXS_RX_X1_DECODE_CONTROL_0r
#define RX_X1_DECODE_CONTROL_0r_SIZE BCMI_TSC_XGXS_RX_X1_DECODE_CONTROL_0r_SIZE
typedef BCMI_TSC_XGXS_RX_X1_DECODE_CONTROL_0r_t RX_X1_DECODE_CONTROL_0r_t;
#define RX_X1_DECODE_CONTROL_0r_CLR BCMI_TSC_XGXS_RX_X1_DECODE_CONTROL_0r_CLR
#define RX_X1_DECODE_CONTROL_0r_SET BCMI_TSC_XGXS_RX_X1_DECODE_CONTROL_0r_SET
#define RX_X1_DECODE_CONTROL_0r_GET BCMI_TSC_XGXS_RX_X1_DECODE_CONTROL_0r_GET
#define RX_X1_DECODE_CONTROL_0r_RESERVED0f_GET BCMI_TSC_XGXS_RX_X1_DECODE_CONTROL_0r_RESERVED0f_GET
#define RX_X1_DECODE_CONTROL_0r_RESERVED0f_SET BCMI_TSC_XGXS_RX_X1_DECODE_CONTROL_0r_RESERVED0f_SET
#define RX_X1_DECODE_CONTROL_0r_SCWCOUNTf_GET BCMI_TSC_XGXS_RX_X1_DECODE_CONTROL_0r_SCWCOUNTf_GET
#define RX_X1_DECODE_CONTROL_0r_SCWCOUNTf_SET BCMI_TSC_XGXS_RX_X1_DECODE_CONTROL_0r_SCWCOUNTf_SET
#define RX_X1_DECODE_CONTROL_0r_GCWCOUNTf_GET BCMI_TSC_XGXS_RX_X1_DECODE_CONTROL_0r_GCWCOUNTf_GET
#define RX_X1_DECODE_CONTROL_0r_GCWCOUNTf_SET BCMI_TSC_XGXS_RX_X1_DECODE_CONTROL_0r_GCWCOUNTf_SET
#define RX_X1_DECODE_CONTROL_0r_HYSTCOUNTf_GET BCMI_TSC_XGXS_RX_X1_DECODE_CONTROL_0r_HYSTCOUNTf_GET
#define RX_X1_DECODE_CONTROL_0r_HYSTCOUNTf_SET BCMI_TSC_XGXS_RX_X1_DECODE_CONTROL_0r_HYSTCOUNTf_SET
#define READ_RX_X1_DECODE_CONTROL_0r BCMI_TSC_XGXS_READ_RX_X1_DECODE_CONTROL_0r
#define WRITE_RX_X1_DECODE_CONTROL_0r BCMI_TSC_XGXS_WRITE_RX_X1_DECODE_CONTROL_0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X1_DECODE_CONTROL_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X1_DECODE_CONTROL_1
 * BLOCKS:   RX_X1_CONTROL0
 * REGADDR:  0x9221
 * DESC:     decode_control_1 register: 00000000
 * SIZE:     32
 * FIELDS:
 *     RESERVED0        
 *     CL49_BER_LIMIT   
 *     CL82_BER_LIMIT   
 *     SET_BER_WINDOW_512 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X1_DECODE_CONTROL_1r (0x00109221 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X1_DECODE_CONTROL_1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_DECODE_CONTROL_1.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X1_DECODE_CONTROL_1r_s {
	uint32_t v[1];
	uint32_t rx_x1_decode_control_1[1];
	uint32_t _rx_x1_decode_control_1;
} BCMI_TSC_XGXS_RX_X1_DECODE_CONTROL_1r_t;

#define BCMI_TSC_XGXS_RX_X1_DECODE_CONTROL_1r_CLR(r) (r).rx_x1_decode_control_1[0] = 0
#define BCMI_TSC_XGXS_RX_X1_DECODE_CONTROL_1r_SET(r,d) (r).rx_x1_decode_control_1[0] = d
#define BCMI_TSC_XGXS_RX_X1_DECODE_CONTROL_1r_GET(r) (r).rx_x1_decode_control_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X1_DECODE_CONTROL_1r_SET_BER_WINDOW_512f_GET(r) ((((r).rx_x1_decode_control_1[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_RX_X1_DECODE_CONTROL_1r_SET_BER_WINDOW_512f_SET(r,f) (r).rx_x1_decode_control_1[0]=(((r).rx_x1_decode_control_1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_RX_X1_DECODE_CONTROL_1r_CL82_BER_LIMITf_GET(r) ((((r).rx_x1_decode_control_1[0]) >> 8) & 0x7f)
#define BCMI_TSC_XGXS_RX_X1_DECODE_CONTROL_1r_CL82_BER_LIMITf_SET(r,f) (r).rx_x1_decode_control_1[0]=(((r).rx_x1_decode_control_1[0] & ~((uint32_t)0x7f << 8)) | ((((uint32_t)f) & 0x7f) << 8))
#define BCMI_TSC_XGXS_RX_X1_DECODE_CONTROL_1r_CL49_BER_LIMITf_GET(r) ((((r).rx_x1_decode_control_1[0]) >> 2) & 0x3f)
#define BCMI_TSC_XGXS_RX_X1_DECODE_CONTROL_1r_CL49_BER_LIMITf_SET(r,f) (r).rx_x1_decode_control_1[0]=(((r).rx_x1_decode_control_1[0] & ~((uint32_t)0x3f << 2)) | ((((uint32_t)f) & 0x3f) << 2))
#define BCMI_TSC_XGXS_RX_X1_DECODE_CONTROL_1r_RESERVED0f_GET(r) (((r).rx_x1_decode_control_1[0]) & 0x3)
#define BCMI_TSC_XGXS_RX_X1_DECODE_CONTROL_1r_RESERVED0f_SET(r,f) (r).rx_x1_decode_control_1[0]=(((r).rx_x1_decode_control_1[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))

/*
 * These macros can be used to access RX_X1_DECODE_CONTROL_1.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X1_DECODE_CONTROL_1r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X1_DECODE_CONTROL_1r,(_r._rx_x1_decode_control_1))
#define BCMI_TSC_XGXS_WRITE_RX_X1_DECODE_CONTROL_1r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X1_DECODE_CONTROL_1r,(_r._rx_x1_decode_control_1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_DECODE_CONTROL_1r BCMI_TSC_XGXS_RX_X1_DECODE_CONTROL_1r
#define RX_X1_DECODE_CONTROL_1r_SIZE BCMI_TSC_XGXS_RX_X1_DECODE_CONTROL_1r_SIZE
typedef BCMI_TSC_XGXS_RX_X1_DECODE_CONTROL_1r_t RX_X1_DECODE_CONTROL_1r_t;
#define RX_X1_DECODE_CONTROL_1r_CLR BCMI_TSC_XGXS_RX_X1_DECODE_CONTROL_1r_CLR
#define RX_X1_DECODE_CONTROL_1r_SET BCMI_TSC_XGXS_RX_X1_DECODE_CONTROL_1r_SET
#define RX_X1_DECODE_CONTROL_1r_GET BCMI_TSC_XGXS_RX_X1_DECODE_CONTROL_1r_GET
#define RX_X1_DECODE_CONTROL_1r_SET_BER_WINDOW_512f_GET BCMI_TSC_XGXS_RX_X1_DECODE_CONTROL_1r_SET_BER_WINDOW_512f_GET
#define RX_X1_DECODE_CONTROL_1r_SET_BER_WINDOW_512f_SET BCMI_TSC_XGXS_RX_X1_DECODE_CONTROL_1r_SET_BER_WINDOW_512f_SET
#define RX_X1_DECODE_CONTROL_1r_CL82_BER_LIMITf_GET BCMI_TSC_XGXS_RX_X1_DECODE_CONTROL_1r_CL82_BER_LIMITf_GET
#define RX_X1_DECODE_CONTROL_1r_CL82_BER_LIMITf_SET BCMI_TSC_XGXS_RX_X1_DECODE_CONTROL_1r_CL82_BER_LIMITf_SET
#define RX_X1_DECODE_CONTROL_1r_CL49_BER_LIMITf_GET BCMI_TSC_XGXS_RX_X1_DECODE_CONTROL_1r_CL49_BER_LIMITf_GET
#define RX_X1_DECODE_CONTROL_1r_CL49_BER_LIMITf_SET BCMI_TSC_XGXS_RX_X1_DECODE_CONTROL_1r_CL49_BER_LIMITf_SET
#define RX_X1_DECODE_CONTROL_1r_RESERVED0f_GET BCMI_TSC_XGXS_RX_X1_DECODE_CONTROL_1r_RESERVED0f_GET
#define RX_X1_DECODE_CONTROL_1r_RESERVED0f_SET BCMI_TSC_XGXS_RX_X1_DECODE_CONTROL_1r_RESERVED0f_SET
#define READ_RX_X1_DECODE_CONTROL_1r BCMI_TSC_XGXS_READ_RX_X1_DECODE_CONTROL_1r
#define WRITE_RX_X1_DECODE_CONTROL_1r BCMI_TSC_XGXS_WRITE_RX_X1_DECODE_CONTROL_1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X1_DECODE_CONTROL_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X1_DESKEW_WINDOWS
 * BLOCKS:   RX_X1_CONTROL0
 * REGADDR:  0x9222
 * DESC:     deskew_windows register: 00000000
 * SIZE:     32
 * FIELDS:
 *     CL48_DSWIN8B10B  
 *     CL48_DSWIN64B66B 
 *     CL82_DSWIN       
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X1_DESKEW_WINDOWSr (0x00109222 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X1_DESKEW_WINDOWSr_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_DESKEW_WINDOWS.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X1_DESKEW_WINDOWSr_s {
	uint32_t v[1];
	uint32_t rx_x1_deskew_windows[1];
	uint32_t _rx_x1_deskew_windows;
} BCMI_TSC_XGXS_RX_X1_DESKEW_WINDOWSr_t;

#define BCMI_TSC_XGXS_RX_X1_DESKEW_WINDOWSr_CLR(r) (r).rx_x1_deskew_windows[0] = 0
#define BCMI_TSC_XGXS_RX_X1_DESKEW_WINDOWSr_SET(r,d) (r).rx_x1_deskew_windows[0] = d
#define BCMI_TSC_XGXS_RX_X1_DESKEW_WINDOWSr_GET(r) (r).rx_x1_deskew_windows[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X1_DESKEW_WINDOWSr_RESERVED0f_GET(r) ((((r).rx_x1_deskew_windows[0]) >> 12) & 0xf)
#define BCMI_TSC_XGXS_RX_X1_DESKEW_WINDOWSr_RESERVED0f_SET(r,f) (r).rx_x1_deskew_windows[0]=(((r).rx_x1_deskew_windows[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCMI_TSC_XGXS_RX_X1_DESKEW_WINDOWSr_CL82_DSWINf_GET(r) ((((r).rx_x1_deskew_windows[0]) >> 7) & 0x1f)
#define BCMI_TSC_XGXS_RX_X1_DESKEW_WINDOWSr_CL82_DSWINf_SET(r,f) (r).rx_x1_deskew_windows[0]=(((r).rx_x1_deskew_windows[0] & ~((uint32_t)0x1f << 7)) | ((((uint32_t)f) & 0x1f) << 7))
#define BCMI_TSC_XGXS_RX_X1_DESKEW_WINDOWSr_CL48_DSWIN64B66Bf_GET(r) ((((r).rx_x1_deskew_windows[0]) >> 4) & 0x7)
#define BCMI_TSC_XGXS_RX_X1_DESKEW_WINDOWSr_CL48_DSWIN64B66Bf_SET(r,f) (r).rx_x1_deskew_windows[0]=(((r).rx_x1_deskew_windows[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4))
#define BCMI_TSC_XGXS_RX_X1_DESKEW_WINDOWSr_CL48_DSWIN8B10Bf_GET(r) (((r).rx_x1_deskew_windows[0]) & 0xf)
#define BCMI_TSC_XGXS_RX_X1_DESKEW_WINDOWSr_CL48_DSWIN8B10Bf_SET(r,f) (r).rx_x1_deskew_windows[0]=(((r).rx_x1_deskew_windows[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access RX_X1_DESKEW_WINDOWS.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X1_DESKEW_WINDOWSr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X1_DESKEW_WINDOWSr,(_r._rx_x1_deskew_windows))
#define BCMI_TSC_XGXS_WRITE_RX_X1_DESKEW_WINDOWSr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X1_DESKEW_WINDOWSr,(_r._rx_x1_deskew_windows))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_DESKEW_WINDOWSr BCMI_TSC_XGXS_RX_X1_DESKEW_WINDOWSr
#define RX_X1_DESKEW_WINDOWSr_SIZE BCMI_TSC_XGXS_RX_X1_DESKEW_WINDOWSr_SIZE
typedef BCMI_TSC_XGXS_RX_X1_DESKEW_WINDOWSr_t RX_X1_DESKEW_WINDOWSr_t;
#define RX_X1_DESKEW_WINDOWSr_CLR BCMI_TSC_XGXS_RX_X1_DESKEW_WINDOWSr_CLR
#define RX_X1_DESKEW_WINDOWSr_SET BCMI_TSC_XGXS_RX_X1_DESKEW_WINDOWSr_SET
#define RX_X1_DESKEW_WINDOWSr_GET BCMI_TSC_XGXS_RX_X1_DESKEW_WINDOWSr_GET
#define RX_X1_DESKEW_WINDOWSr_RESERVED0f_GET BCMI_TSC_XGXS_RX_X1_DESKEW_WINDOWSr_RESERVED0f_GET
#define RX_X1_DESKEW_WINDOWSr_RESERVED0f_SET BCMI_TSC_XGXS_RX_X1_DESKEW_WINDOWSr_RESERVED0f_SET
#define RX_X1_DESKEW_WINDOWSr_CL82_DSWINf_GET BCMI_TSC_XGXS_RX_X1_DESKEW_WINDOWSr_CL82_DSWINf_GET
#define RX_X1_DESKEW_WINDOWSr_CL82_DSWINf_SET BCMI_TSC_XGXS_RX_X1_DESKEW_WINDOWSr_CL82_DSWINf_SET
#define RX_X1_DESKEW_WINDOWSr_CL48_DSWIN64B66Bf_GET BCMI_TSC_XGXS_RX_X1_DESKEW_WINDOWSr_CL48_DSWIN64B66Bf_GET
#define RX_X1_DESKEW_WINDOWSr_CL48_DSWIN64B66Bf_SET BCMI_TSC_XGXS_RX_X1_DESKEW_WINDOWSr_CL48_DSWIN64B66Bf_SET
#define RX_X1_DESKEW_WINDOWSr_CL48_DSWIN8B10Bf_GET BCMI_TSC_XGXS_RX_X1_DESKEW_WINDOWSr_CL48_DSWIN8B10Bf_GET
#define RX_X1_DESKEW_WINDOWSr_CL48_DSWIN8B10Bf_SET BCMI_TSC_XGXS_RX_X1_DESKEW_WINDOWSr_CL48_DSWIN8B10Bf_SET
#define READ_RX_X1_DESKEW_WINDOWSr BCMI_TSC_XGXS_READ_RX_X1_DESKEW_WINDOWSr
#define WRITE_RX_X1_DESKEW_WINDOWSr BCMI_TSC_XGXS_WRITE_RX_X1_DESKEW_WINDOWSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X1_DESKEW_WINDOWSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X1_CX4_SIGDET_FILTER
 * BLOCKS:   RX_X1_CONTROL0
 * REGADDR:  0x9224
 * DESC:     CX4 signal detect filter: 00000000
 * SIZE:     32
 * FIELDS:
 *     CX4_SIGNAL_DETECT_FILTER_PERIOD 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X1_CX4_SIGDET_FILTERr (0x00109224 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X1_CX4_SIGDET_FILTERr_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_CX4_SIGDET_FILTER.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X1_CX4_SIGDET_FILTERr_s {
	uint32_t v[1];
	uint32_t rx_x1_cx4_sigdet_filter[1];
	uint32_t _rx_x1_cx4_sigdet_filter;
} BCMI_TSC_XGXS_RX_X1_CX4_SIGDET_FILTERr_t;

#define BCMI_TSC_XGXS_RX_X1_CX4_SIGDET_FILTERr_CLR(r) (r).rx_x1_cx4_sigdet_filter[0] = 0
#define BCMI_TSC_XGXS_RX_X1_CX4_SIGDET_FILTERr_SET(r,d) (r).rx_x1_cx4_sigdet_filter[0] = d
#define BCMI_TSC_XGXS_RX_X1_CX4_SIGDET_FILTERr_GET(r) (r).rx_x1_cx4_sigdet_filter[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X1_CX4_SIGDET_FILTERr_RESERVED0f_GET(r) ((((r).rx_x1_cx4_sigdet_filter[0]) >> 14) & 0x3)
#define BCMI_TSC_XGXS_RX_X1_CX4_SIGDET_FILTERr_RESERVED0f_SET(r,f) (r).rx_x1_cx4_sigdet_filter[0]=(((r).rx_x1_cx4_sigdet_filter[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCMI_TSC_XGXS_RX_X1_CX4_SIGDET_FILTERr_CX4_SIGNAL_DETECT_FILTER_PERIODf_GET(r) (((r).rx_x1_cx4_sigdet_filter[0]) & 0x3fff)
#define BCMI_TSC_XGXS_RX_X1_CX4_SIGDET_FILTERr_CX4_SIGNAL_DETECT_FILTER_PERIODf_SET(r,f) (r).rx_x1_cx4_sigdet_filter[0]=(((r).rx_x1_cx4_sigdet_filter[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access RX_X1_CX4_SIGDET_FILTER.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X1_CX4_SIGDET_FILTERr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X1_CX4_SIGDET_FILTERr,(_r._rx_x1_cx4_sigdet_filter))
#define BCMI_TSC_XGXS_WRITE_RX_X1_CX4_SIGDET_FILTERr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X1_CX4_SIGDET_FILTERr,(_r._rx_x1_cx4_sigdet_filter))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_CX4_SIGDET_FILTERr BCMI_TSC_XGXS_RX_X1_CX4_SIGDET_FILTERr
#define RX_X1_CX4_SIGDET_FILTERr_SIZE BCMI_TSC_XGXS_RX_X1_CX4_SIGDET_FILTERr_SIZE
typedef BCMI_TSC_XGXS_RX_X1_CX4_SIGDET_FILTERr_t RX_X1_CX4_SIGDET_FILTERr_t;
#define RX_X1_CX4_SIGDET_FILTERr_CLR BCMI_TSC_XGXS_RX_X1_CX4_SIGDET_FILTERr_CLR
#define RX_X1_CX4_SIGDET_FILTERr_SET BCMI_TSC_XGXS_RX_X1_CX4_SIGDET_FILTERr_SET
#define RX_X1_CX4_SIGDET_FILTERr_GET BCMI_TSC_XGXS_RX_X1_CX4_SIGDET_FILTERr_GET
#define RX_X1_CX4_SIGDET_FILTERr_RESERVED0f_GET BCMI_TSC_XGXS_RX_X1_CX4_SIGDET_FILTERr_RESERVED0f_GET
#define RX_X1_CX4_SIGDET_FILTERr_RESERVED0f_SET BCMI_TSC_XGXS_RX_X1_CX4_SIGDET_FILTERr_RESERVED0f_SET
#define RX_X1_CX4_SIGDET_FILTERr_CX4_SIGNAL_DETECT_FILTER_PERIODf_GET BCMI_TSC_XGXS_RX_X1_CX4_SIGDET_FILTERr_CX4_SIGNAL_DETECT_FILTER_PERIODf_GET
#define RX_X1_CX4_SIGDET_FILTERr_CX4_SIGNAL_DETECT_FILTER_PERIODf_SET BCMI_TSC_XGXS_RX_X1_CX4_SIGDET_FILTERr_CX4_SIGNAL_DETECT_FILTER_PERIODf_SET
#define READ_RX_X1_CX4_SIGDET_FILTERr BCMI_TSC_XGXS_READ_RX_X1_CX4_SIGDET_FILTERr
#define WRITE_RX_X1_CX4_SIGDET_FILTERr BCMI_TSC_XGXS_WRITE_RX_X1_CX4_SIGDET_FILTERr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X1_CX4_SIGDET_FILTERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X1_SHCNT_CL49
 * BLOCKS:   RX_X1_CONTROL1
 * REGADDR:  0x9230
 * DESC:     CL49 sync header valid/invalid counters: 00000000
 * SIZE:     32
 * FIELDS:
 *     CL49_INVALID_SH_CNT 
 *     CL49_VALID_SH_CNT 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X1_SHCNT_CL49r (0x00109230 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X1_SHCNT_CL49r_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_SHCNT_CL49.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X1_SHCNT_CL49r_s {
	uint32_t v[1];
	uint32_t rx_x1_shcnt_cl49[1];
	uint32_t _rx_x1_shcnt_cl49;
} BCMI_TSC_XGXS_RX_X1_SHCNT_CL49r_t;

#define BCMI_TSC_XGXS_RX_X1_SHCNT_CL49r_CLR(r) (r).rx_x1_shcnt_cl49[0] = 0
#define BCMI_TSC_XGXS_RX_X1_SHCNT_CL49r_SET(r,d) (r).rx_x1_shcnt_cl49[0] = d
#define BCMI_TSC_XGXS_RX_X1_SHCNT_CL49r_GET(r) (r).rx_x1_shcnt_cl49[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X1_SHCNT_CL49r_CL49_VALID_SH_CNTf_GET(r) ((((r).rx_x1_shcnt_cl49[0]) >> 8) & 0xff)
#define BCMI_TSC_XGXS_RX_X1_SHCNT_CL49r_CL49_VALID_SH_CNTf_SET(r,f) (r).rx_x1_shcnt_cl49[0]=(((r).rx_x1_shcnt_cl49[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCMI_TSC_XGXS_RX_X1_SHCNT_CL49r_CL49_INVALID_SH_CNTf_GET(r) (((r).rx_x1_shcnt_cl49[0]) & 0xff)
#define BCMI_TSC_XGXS_RX_X1_SHCNT_CL49r_CL49_INVALID_SH_CNTf_SET(r,f) (r).rx_x1_shcnt_cl49[0]=(((r).rx_x1_shcnt_cl49[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access RX_X1_SHCNT_CL49.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X1_SHCNT_CL49r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X1_SHCNT_CL49r,(_r._rx_x1_shcnt_cl49))
#define BCMI_TSC_XGXS_WRITE_RX_X1_SHCNT_CL49r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X1_SHCNT_CL49r,(_r._rx_x1_shcnt_cl49))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_SHCNT_CL49r BCMI_TSC_XGXS_RX_X1_SHCNT_CL49r
#define RX_X1_SHCNT_CL49r_SIZE BCMI_TSC_XGXS_RX_X1_SHCNT_CL49r_SIZE
typedef BCMI_TSC_XGXS_RX_X1_SHCNT_CL49r_t RX_X1_SHCNT_CL49r_t;
#define RX_X1_SHCNT_CL49r_CLR BCMI_TSC_XGXS_RX_X1_SHCNT_CL49r_CLR
#define RX_X1_SHCNT_CL49r_SET BCMI_TSC_XGXS_RX_X1_SHCNT_CL49r_SET
#define RX_X1_SHCNT_CL49r_GET BCMI_TSC_XGXS_RX_X1_SHCNT_CL49r_GET
#define RX_X1_SHCNT_CL49r_CL49_VALID_SH_CNTf_GET BCMI_TSC_XGXS_RX_X1_SHCNT_CL49r_CL49_VALID_SH_CNTf_GET
#define RX_X1_SHCNT_CL49r_CL49_VALID_SH_CNTf_SET BCMI_TSC_XGXS_RX_X1_SHCNT_CL49r_CL49_VALID_SH_CNTf_SET
#define RX_X1_SHCNT_CL49r_CL49_INVALID_SH_CNTf_GET BCMI_TSC_XGXS_RX_X1_SHCNT_CL49r_CL49_INVALID_SH_CNTf_GET
#define RX_X1_SHCNT_CL49r_CL49_INVALID_SH_CNTf_SET BCMI_TSC_XGXS_RX_X1_SHCNT_CL49r_CL49_INVALID_SH_CNTf_SET
#define READ_RX_X1_SHCNT_CL49r BCMI_TSC_XGXS_READ_RX_X1_SHCNT_CL49r
#define WRITE_RX_X1_SHCNT_CL49r BCMI_TSC_XGXS_WRITE_RX_X1_SHCNT_CL49r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X1_SHCNT_CL49r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X1_VALID_SHCNT_CL82
 * BLOCKS:   RX_X1_CONTROL1
 * REGADDR:  0x9231
 * DESC:     CL49 sync header valid counter: 00000000
 * SIZE:     32
 * FIELDS:
 *     CL82_VALID_SH_CNT 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X1_VALID_SHCNT_CL82r (0x00109231 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X1_VALID_SHCNT_CL82r_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_VALID_SHCNT_CL82.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X1_VALID_SHCNT_CL82r_s {
	uint32_t v[1];
	uint32_t rx_x1_valid_shcnt_cl82[1];
	uint32_t _rx_x1_valid_shcnt_cl82;
} BCMI_TSC_XGXS_RX_X1_VALID_SHCNT_CL82r_t;

#define BCMI_TSC_XGXS_RX_X1_VALID_SHCNT_CL82r_CLR(r) (r).rx_x1_valid_shcnt_cl82[0] = 0
#define BCMI_TSC_XGXS_RX_X1_VALID_SHCNT_CL82r_SET(r,d) (r).rx_x1_valid_shcnt_cl82[0] = d
#define BCMI_TSC_XGXS_RX_X1_VALID_SHCNT_CL82r_GET(r) (r).rx_x1_valid_shcnt_cl82[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X1_VALID_SHCNT_CL82r_RESERVED0f_GET(r) ((((r).rx_x1_valid_shcnt_cl82[0]) >> 12) & 0xf)
#define BCMI_TSC_XGXS_RX_X1_VALID_SHCNT_CL82r_RESERVED0f_SET(r,f) (r).rx_x1_valid_shcnt_cl82[0]=(((r).rx_x1_valid_shcnt_cl82[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCMI_TSC_XGXS_RX_X1_VALID_SHCNT_CL82r_CL82_VALID_SH_CNTf_GET(r) (((r).rx_x1_valid_shcnt_cl82[0]) & 0xfff)
#define BCMI_TSC_XGXS_RX_X1_VALID_SHCNT_CL82r_CL82_VALID_SH_CNTf_SET(r,f) (r).rx_x1_valid_shcnt_cl82[0]=(((r).rx_x1_valid_shcnt_cl82[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))

/*
 * These macros can be used to access RX_X1_VALID_SHCNT_CL82.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X1_VALID_SHCNT_CL82r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X1_VALID_SHCNT_CL82r,(_r._rx_x1_valid_shcnt_cl82))
#define BCMI_TSC_XGXS_WRITE_RX_X1_VALID_SHCNT_CL82r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X1_VALID_SHCNT_CL82r,(_r._rx_x1_valid_shcnt_cl82))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_VALID_SHCNT_CL82r BCMI_TSC_XGXS_RX_X1_VALID_SHCNT_CL82r
#define RX_X1_VALID_SHCNT_CL82r_SIZE BCMI_TSC_XGXS_RX_X1_VALID_SHCNT_CL82r_SIZE
typedef BCMI_TSC_XGXS_RX_X1_VALID_SHCNT_CL82r_t RX_X1_VALID_SHCNT_CL82r_t;
#define RX_X1_VALID_SHCNT_CL82r_CLR BCMI_TSC_XGXS_RX_X1_VALID_SHCNT_CL82r_CLR
#define RX_X1_VALID_SHCNT_CL82r_SET BCMI_TSC_XGXS_RX_X1_VALID_SHCNT_CL82r_SET
#define RX_X1_VALID_SHCNT_CL82r_GET BCMI_TSC_XGXS_RX_X1_VALID_SHCNT_CL82r_GET
#define RX_X1_VALID_SHCNT_CL82r_RESERVED0f_GET BCMI_TSC_XGXS_RX_X1_VALID_SHCNT_CL82r_RESERVED0f_GET
#define RX_X1_VALID_SHCNT_CL82r_RESERVED0f_SET BCMI_TSC_XGXS_RX_X1_VALID_SHCNT_CL82r_RESERVED0f_SET
#define RX_X1_VALID_SHCNT_CL82r_CL82_VALID_SH_CNTf_GET BCMI_TSC_XGXS_RX_X1_VALID_SHCNT_CL82r_CL82_VALID_SH_CNTf_GET
#define RX_X1_VALID_SHCNT_CL82r_CL82_VALID_SH_CNTf_SET BCMI_TSC_XGXS_RX_X1_VALID_SHCNT_CL82r_CL82_VALID_SH_CNTf_SET
#define READ_RX_X1_VALID_SHCNT_CL82r BCMI_TSC_XGXS_READ_RX_X1_VALID_SHCNT_CL82r
#define WRITE_RX_X1_VALID_SHCNT_CL82r BCMI_TSC_XGXS_WRITE_RX_X1_VALID_SHCNT_CL82r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X1_VALID_SHCNT_CL82r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X1_INVALID_SHCNT_CL82
 * BLOCKS:   RX_X1_CONTROL1
 * REGADDR:  0x9232
 * DESC:     CL49 sync header invalid counter: 00000000
 * SIZE:     32
 * FIELDS:
 *     CL82_INVALID_SH_CNT 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X1_INVALID_SHCNT_CL82r (0x00109232 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X1_INVALID_SHCNT_CL82r_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_INVALID_SHCNT_CL82.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X1_INVALID_SHCNT_CL82r_s {
	uint32_t v[1];
	uint32_t rx_x1_invalid_shcnt_cl82[1];
	uint32_t _rx_x1_invalid_shcnt_cl82;
} BCMI_TSC_XGXS_RX_X1_INVALID_SHCNT_CL82r_t;

#define BCMI_TSC_XGXS_RX_X1_INVALID_SHCNT_CL82r_CLR(r) (r).rx_x1_invalid_shcnt_cl82[0] = 0
#define BCMI_TSC_XGXS_RX_X1_INVALID_SHCNT_CL82r_SET(r,d) (r).rx_x1_invalid_shcnt_cl82[0] = d
#define BCMI_TSC_XGXS_RX_X1_INVALID_SHCNT_CL82r_GET(r) (r).rx_x1_invalid_shcnt_cl82[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X1_INVALID_SHCNT_CL82r_RESERVED0f_GET(r) ((((r).rx_x1_invalid_shcnt_cl82[0]) >> 12) & 0xf)
#define BCMI_TSC_XGXS_RX_X1_INVALID_SHCNT_CL82r_RESERVED0f_SET(r,f) (r).rx_x1_invalid_shcnt_cl82[0]=(((r).rx_x1_invalid_shcnt_cl82[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCMI_TSC_XGXS_RX_X1_INVALID_SHCNT_CL82r_CL82_INVALID_SH_CNTf_GET(r) (((r).rx_x1_invalid_shcnt_cl82[0]) & 0xfff)
#define BCMI_TSC_XGXS_RX_X1_INVALID_SHCNT_CL82r_CL82_INVALID_SH_CNTf_SET(r,f) (r).rx_x1_invalid_shcnt_cl82[0]=(((r).rx_x1_invalid_shcnt_cl82[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))

/*
 * These macros can be used to access RX_X1_INVALID_SHCNT_CL82.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X1_INVALID_SHCNT_CL82r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X1_INVALID_SHCNT_CL82r,(_r._rx_x1_invalid_shcnt_cl82))
#define BCMI_TSC_XGXS_WRITE_RX_X1_INVALID_SHCNT_CL82r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X1_INVALID_SHCNT_CL82r,(_r._rx_x1_invalid_shcnt_cl82))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_INVALID_SHCNT_CL82r BCMI_TSC_XGXS_RX_X1_INVALID_SHCNT_CL82r
#define RX_X1_INVALID_SHCNT_CL82r_SIZE BCMI_TSC_XGXS_RX_X1_INVALID_SHCNT_CL82r_SIZE
typedef BCMI_TSC_XGXS_RX_X1_INVALID_SHCNT_CL82r_t RX_X1_INVALID_SHCNT_CL82r_t;
#define RX_X1_INVALID_SHCNT_CL82r_CLR BCMI_TSC_XGXS_RX_X1_INVALID_SHCNT_CL82r_CLR
#define RX_X1_INVALID_SHCNT_CL82r_SET BCMI_TSC_XGXS_RX_X1_INVALID_SHCNT_CL82r_SET
#define RX_X1_INVALID_SHCNT_CL82r_GET BCMI_TSC_XGXS_RX_X1_INVALID_SHCNT_CL82r_GET
#define RX_X1_INVALID_SHCNT_CL82r_RESERVED0f_GET BCMI_TSC_XGXS_RX_X1_INVALID_SHCNT_CL82r_RESERVED0f_GET
#define RX_X1_INVALID_SHCNT_CL82r_RESERVED0f_SET BCMI_TSC_XGXS_RX_X1_INVALID_SHCNT_CL82r_RESERVED0f_SET
#define RX_X1_INVALID_SHCNT_CL82r_CL82_INVALID_SH_CNTf_GET BCMI_TSC_XGXS_RX_X1_INVALID_SHCNT_CL82r_CL82_INVALID_SH_CNTf_GET
#define RX_X1_INVALID_SHCNT_CL82r_CL82_INVALID_SH_CNTf_SET BCMI_TSC_XGXS_RX_X1_INVALID_SHCNT_CL82r_CL82_INVALID_SH_CNTf_SET
#define READ_RX_X1_INVALID_SHCNT_CL82r BCMI_TSC_XGXS_READ_RX_X1_INVALID_SHCNT_CL82r
#define WRITE_RX_X1_INVALID_SHCNT_CL82r BCMI_TSC_XGXS_WRITE_RX_X1_INVALID_SHCNT_CL82r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X1_INVALID_SHCNT_CL82r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X1_SCW0
 * BLOCKS:   RX_X1_CONTROL1
 * REGADDR:  0x9233
 * DESC:     Sync code word bits 65:50: 00000000
 * SIZE:     32
 * FIELDS:
 *     MASK_SCW0_MASK   
 *     SCW0             
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X1_SCW0r (0x00109233 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X1_SCW0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_SCW0.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X1_SCW0r_s {
	uint32_t v[1];
	uint32_t rx_x1_scw0[1];
	uint32_t _rx_x1_scw0;
} BCMI_TSC_XGXS_RX_X1_SCW0r_t;

#define BCMI_TSC_XGXS_RX_X1_SCW0r_CLR(r) (r).rx_x1_scw0[0] = 0
#define BCMI_TSC_XGXS_RX_X1_SCW0r_SET(r,d) (r).rx_x1_scw0[0] = d
#define BCMI_TSC_XGXS_RX_X1_SCW0r_GET(r) (r).rx_x1_scw0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X1_SCW0r_MASK_SCW0_MASKf_GET(r) (((r).rx_x1_scw0[0]) & 0xffff)
#define BCMI_TSC_XGXS_RX_X1_SCW0r_MASK_SCW0_MASKf_SET(r,f) (r).rx_x1_scw0[0]=(((r).rx_x1_scw0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCMI_TSC_XGXS_RX_X1_SCW0r_SCW0f_GET(r) (((r).rx_x1_scw0[0]) & 0xffff)
#define BCMI_TSC_XGXS_RX_X1_SCW0r_SCW0f_SET(r,f) (r).rx_x1_scw0[0]=(((r).rx_x1_scw0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access RX_X1_SCW0.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X1_SCW0r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X1_SCW0r,(_r._rx_x1_scw0))
#define BCMI_TSC_XGXS_WRITE_RX_X1_SCW0r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X1_SCW0r,(_r._rx_x1_scw0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_SCW0r BCMI_TSC_XGXS_RX_X1_SCW0r
#define RX_X1_SCW0r_SIZE BCMI_TSC_XGXS_RX_X1_SCW0r_SIZE
typedef BCMI_TSC_XGXS_RX_X1_SCW0r_t RX_X1_SCW0r_t;
#define RX_X1_SCW0r_CLR BCMI_TSC_XGXS_RX_X1_SCW0r_CLR
#define RX_X1_SCW0r_SET BCMI_TSC_XGXS_RX_X1_SCW0r_SET
#define RX_X1_SCW0r_GET BCMI_TSC_XGXS_RX_X1_SCW0r_GET
#define RX_X1_SCW0r_MASK_SCW0_MASKf_GET BCMI_TSC_XGXS_RX_X1_SCW0r_MASK_SCW0_MASKf_GET
#define RX_X1_SCW0r_MASK_SCW0_MASKf_SET BCMI_TSC_XGXS_RX_X1_SCW0r_MASK_SCW0_MASKf_SET
#define RX_X1_SCW0r_SCW0f_GET BCMI_TSC_XGXS_RX_X1_SCW0r_SCW0f_GET
#define RX_X1_SCW0r_SCW0f_SET BCMI_TSC_XGXS_RX_X1_SCW0r_SCW0f_SET
#define READ_RX_X1_SCW0r BCMI_TSC_XGXS_READ_RX_X1_SCW0r
#define WRITE_RX_X1_SCW0r BCMI_TSC_XGXS_WRITE_RX_X1_SCW0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X1_SCW0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X1_SCW1
 * BLOCKS:   RX_X1_CONTROL1
 * REGADDR:  0x9234
 * DESC:     Sync code word bits 49;34: 00000000
 * SIZE:     32
 * FIELDS:
 *     MASK_SCW1_MASK   
 *     SCW1             
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X1_SCW1r (0x00109234 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X1_SCW1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_SCW1.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X1_SCW1r_s {
	uint32_t v[1];
	uint32_t rx_x1_scw1[1];
	uint32_t _rx_x1_scw1;
} BCMI_TSC_XGXS_RX_X1_SCW1r_t;

#define BCMI_TSC_XGXS_RX_X1_SCW1r_CLR(r) (r).rx_x1_scw1[0] = 0
#define BCMI_TSC_XGXS_RX_X1_SCW1r_SET(r,d) (r).rx_x1_scw1[0] = d
#define BCMI_TSC_XGXS_RX_X1_SCW1r_GET(r) (r).rx_x1_scw1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X1_SCW1r_MASK_SCW1_MASKf_GET(r) (((r).rx_x1_scw1[0]) & 0xffff)
#define BCMI_TSC_XGXS_RX_X1_SCW1r_MASK_SCW1_MASKf_SET(r,f) (r).rx_x1_scw1[0]=(((r).rx_x1_scw1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCMI_TSC_XGXS_RX_X1_SCW1r_SCW1f_GET(r) (((r).rx_x1_scw1[0]) & 0xffff)
#define BCMI_TSC_XGXS_RX_X1_SCW1r_SCW1f_SET(r,f) (r).rx_x1_scw1[0]=(((r).rx_x1_scw1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access RX_X1_SCW1.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X1_SCW1r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X1_SCW1r,(_r._rx_x1_scw1))
#define BCMI_TSC_XGXS_WRITE_RX_X1_SCW1r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X1_SCW1r,(_r._rx_x1_scw1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_SCW1r BCMI_TSC_XGXS_RX_X1_SCW1r
#define RX_X1_SCW1r_SIZE BCMI_TSC_XGXS_RX_X1_SCW1r_SIZE
typedef BCMI_TSC_XGXS_RX_X1_SCW1r_t RX_X1_SCW1r_t;
#define RX_X1_SCW1r_CLR BCMI_TSC_XGXS_RX_X1_SCW1r_CLR
#define RX_X1_SCW1r_SET BCMI_TSC_XGXS_RX_X1_SCW1r_SET
#define RX_X1_SCW1r_GET BCMI_TSC_XGXS_RX_X1_SCW1r_GET
#define RX_X1_SCW1r_MASK_SCW1_MASKf_GET BCMI_TSC_XGXS_RX_X1_SCW1r_MASK_SCW1_MASKf_GET
#define RX_X1_SCW1r_MASK_SCW1_MASKf_SET BCMI_TSC_XGXS_RX_X1_SCW1r_MASK_SCW1_MASKf_SET
#define RX_X1_SCW1r_SCW1f_GET BCMI_TSC_XGXS_RX_X1_SCW1r_SCW1f_GET
#define RX_X1_SCW1r_SCW1f_SET BCMI_TSC_XGXS_RX_X1_SCW1r_SCW1f_SET
#define READ_RX_X1_SCW1r BCMI_TSC_XGXS_READ_RX_X1_SCW1r
#define WRITE_RX_X1_SCW1r BCMI_TSC_XGXS_WRITE_RX_X1_SCW1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X1_SCW1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X1_SCW2
 * BLOCKS:   RX_X1_CONTROL1
 * REGADDR:  0x9235
 * DESC:     Sync code word bits 33:18: 00000000
 * SIZE:     32
 * FIELDS:
 *     MASK_SCW2_MASK   
 *     SCW2             
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X1_SCW2r (0x00109235 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X1_SCW2r_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_SCW2.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X1_SCW2r_s {
	uint32_t v[1];
	uint32_t rx_x1_scw2[1];
	uint32_t _rx_x1_scw2;
} BCMI_TSC_XGXS_RX_X1_SCW2r_t;

#define BCMI_TSC_XGXS_RX_X1_SCW2r_CLR(r) (r).rx_x1_scw2[0] = 0
#define BCMI_TSC_XGXS_RX_X1_SCW2r_SET(r,d) (r).rx_x1_scw2[0] = d
#define BCMI_TSC_XGXS_RX_X1_SCW2r_GET(r) (r).rx_x1_scw2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X1_SCW2r_MASK_SCW2_MASKf_GET(r) (((r).rx_x1_scw2[0]) & 0xffff)
#define BCMI_TSC_XGXS_RX_X1_SCW2r_MASK_SCW2_MASKf_SET(r,f) (r).rx_x1_scw2[0]=(((r).rx_x1_scw2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCMI_TSC_XGXS_RX_X1_SCW2r_SCW2f_GET(r) (((r).rx_x1_scw2[0]) & 0xffff)
#define BCMI_TSC_XGXS_RX_X1_SCW2r_SCW2f_SET(r,f) (r).rx_x1_scw2[0]=(((r).rx_x1_scw2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access RX_X1_SCW2.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X1_SCW2r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X1_SCW2r,(_r._rx_x1_scw2))
#define BCMI_TSC_XGXS_WRITE_RX_X1_SCW2r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X1_SCW2r,(_r._rx_x1_scw2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_SCW2r BCMI_TSC_XGXS_RX_X1_SCW2r
#define RX_X1_SCW2r_SIZE BCMI_TSC_XGXS_RX_X1_SCW2r_SIZE
typedef BCMI_TSC_XGXS_RX_X1_SCW2r_t RX_X1_SCW2r_t;
#define RX_X1_SCW2r_CLR BCMI_TSC_XGXS_RX_X1_SCW2r_CLR
#define RX_X1_SCW2r_SET BCMI_TSC_XGXS_RX_X1_SCW2r_SET
#define RX_X1_SCW2r_GET BCMI_TSC_XGXS_RX_X1_SCW2r_GET
#define RX_X1_SCW2r_MASK_SCW2_MASKf_GET BCMI_TSC_XGXS_RX_X1_SCW2r_MASK_SCW2_MASKf_GET
#define RX_X1_SCW2r_MASK_SCW2_MASKf_SET BCMI_TSC_XGXS_RX_X1_SCW2r_MASK_SCW2_MASKf_SET
#define RX_X1_SCW2r_SCW2f_GET BCMI_TSC_XGXS_RX_X1_SCW2r_SCW2f_GET
#define RX_X1_SCW2r_SCW2f_SET BCMI_TSC_XGXS_RX_X1_SCW2r_SCW2f_SET
#define READ_RX_X1_SCW2r BCMI_TSC_XGXS_READ_RX_X1_SCW2r
#define WRITE_RX_X1_SCW2r BCMI_TSC_XGXS_WRITE_RX_X1_SCW2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X1_SCW2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X1_SCW3
 * BLOCKS:   RX_X1_CONTROL1
 * REGADDR:  0x9236
 * DESC:     Sync code word bits 17:2: 00000000
 * SIZE:     32
 * FIELDS:
 *     SCW3             
 *     MASK_SCW3_MASK   
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X1_SCW3r (0x00109236 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X1_SCW3r_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_SCW3.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X1_SCW3r_s {
	uint32_t v[1];
	uint32_t rx_x1_scw3[1];
	uint32_t _rx_x1_scw3;
} BCMI_TSC_XGXS_RX_X1_SCW3r_t;

#define BCMI_TSC_XGXS_RX_X1_SCW3r_CLR(r) (r).rx_x1_scw3[0] = 0
#define BCMI_TSC_XGXS_RX_X1_SCW3r_SET(r,d) (r).rx_x1_scw3[0] = d
#define BCMI_TSC_XGXS_RX_X1_SCW3r_GET(r) (r).rx_x1_scw3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X1_SCW3r_SCW3f_GET(r) (((r).rx_x1_scw3[0]) & 0xffff)
#define BCMI_TSC_XGXS_RX_X1_SCW3r_SCW3f_SET(r,f) (r).rx_x1_scw3[0]=(((r).rx_x1_scw3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCMI_TSC_XGXS_RX_X1_SCW3r_MASK_SCW3_MASKf_GET(r) (((r).rx_x1_scw3[0]) & 0xffff)
#define BCMI_TSC_XGXS_RX_X1_SCW3r_MASK_SCW3_MASKf_SET(r,f) (r).rx_x1_scw3[0]=(((r).rx_x1_scw3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access RX_X1_SCW3.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X1_SCW3r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X1_SCW3r,(_r._rx_x1_scw3))
#define BCMI_TSC_XGXS_WRITE_RX_X1_SCW3r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X1_SCW3r,(_r._rx_x1_scw3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_SCW3r BCMI_TSC_XGXS_RX_X1_SCW3r
#define RX_X1_SCW3r_SIZE BCMI_TSC_XGXS_RX_X1_SCW3r_SIZE
typedef BCMI_TSC_XGXS_RX_X1_SCW3r_t RX_X1_SCW3r_t;
#define RX_X1_SCW3r_CLR BCMI_TSC_XGXS_RX_X1_SCW3r_CLR
#define RX_X1_SCW3r_SET BCMI_TSC_XGXS_RX_X1_SCW3r_SET
#define RX_X1_SCW3r_GET BCMI_TSC_XGXS_RX_X1_SCW3r_GET
#define RX_X1_SCW3r_SCW3f_GET BCMI_TSC_XGXS_RX_X1_SCW3r_SCW3f_GET
#define RX_X1_SCW3r_SCW3f_SET BCMI_TSC_XGXS_RX_X1_SCW3r_SCW3f_SET
#define RX_X1_SCW3r_MASK_SCW3_MASKf_GET BCMI_TSC_XGXS_RX_X1_SCW3r_MASK_SCW3_MASKf_GET
#define RX_X1_SCW3r_MASK_SCW3_MASKf_SET BCMI_TSC_XGXS_RX_X1_SCW3r_MASK_SCW3_MASKf_SET
#define READ_RX_X1_SCW3r BCMI_TSC_XGXS_READ_RX_X1_SCW3r
#define WRITE_RX_X1_SCW3r BCMI_TSC_XGXS_WRITE_RX_X1_SCW3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X1_SCW3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X1_SCW4
 * BLOCKS:   RX_X1_CONTROL1
 * REGADDR:  0x9237
 * DESC:     Sync code word bits 1:0: 00000000
 * SIZE:     32
 * FIELDS:
 *     MASK_SCW4_MASK   
 *     SCW4             
 *     RESERVED0        
 *     MASK_RESERVED0   
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X1_SCW4r (0x00109237 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X1_SCW4r_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_SCW4.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X1_SCW4r_s {
	uint32_t v[1];
	uint32_t rx_x1_scw4[1];
	uint32_t _rx_x1_scw4;
} BCMI_TSC_XGXS_RX_X1_SCW4r_t;

#define BCMI_TSC_XGXS_RX_X1_SCW4r_CLR(r) (r).rx_x1_scw4[0] = 0
#define BCMI_TSC_XGXS_RX_X1_SCW4r_SET(r,d) (r).rx_x1_scw4[0] = d
#define BCMI_TSC_XGXS_RX_X1_SCW4r_GET(r) (r).rx_x1_scw4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X1_SCW4r_RESERVED0f_GET(r) ((((r).rx_x1_scw4[0]) >> 2) & 0x3fff)
#define BCMI_TSC_XGXS_RX_X1_SCW4r_RESERVED0f_SET(r,f) (r).rx_x1_scw4[0]=(((r).rx_x1_scw4[0] & ~((uint32_t)0x3fff << 2)) | ((((uint32_t)f) & 0x3fff) << 2))
#define BCMI_TSC_XGXS_RX_X1_SCW4r_MASK_RESERVED0f_GET(r) ((((r).rx_x1_scw4[0]) >> 2) & 0x3fff)
#define BCMI_TSC_XGXS_RX_X1_SCW4r_MASK_RESERVED0f_SET(r,f) (r).rx_x1_scw4[0]=(((r).rx_x1_scw4[0] & ~((uint32_t)0x3fff << 2)) | ((((uint32_t)f) & 0x3fff) << 2))
#define BCMI_TSC_XGXS_RX_X1_SCW4r_MASK_SCW4_MASKf_GET(r) (((r).rx_x1_scw4[0]) & 0x3)
#define BCMI_TSC_XGXS_RX_X1_SCW4r_MASK_SCW4_MASKf_SET(r,f) (r).rx_x1_scw4[0]=(((r).rx_x1_scw4[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCMI_TSC_XGXS_RX_X1_SCW4r_SCW4f_GET(r) (((r).rx_x1_scw4[0]) & 0x3)
#define BCMI_TSC_XGXS_RX_X1_SCW4r_SCW4f_SET(r,f) (r).rx_x1_scw4[0]=(((r).rx_x1_scw4[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))

/*
 * These macros can be used to access RX_X1_SCW4.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X1_SCW4r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X1_SCW4r,(_r._rx_x1_scw4))
#define BCMI_TSC_XGXS_WRITE_RX_X1_SCW4r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X1_SCW4r,(_r._rx_x1_scw4))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_SCW4r BCMI_TSC_XGXS_RX_X1_SCW4r
#define RX_X1_SCW4r_SIZE BCMI_TSC_XGXS_RX_X1_SCW4r_SIZE
typedef BCMI_TSC_XGXS_RX_X1_SCW4r_t RX_X1_SCW4r_t;
#define RX_X1_SCW4r_CLR BCMI_TSC_XGXS_RX_X1_SCW4r_CLR
#define RX_X1_SCW4r_SET BCMI_TSC_XGXS_RX_X1_SCW4r_SET
#define RX_X1_SCW4r_GET BCMI_TSC_XGXS_RX_X1_SCW4r_GET
#define RX_X1_SCW4r_RESERVED0f_GET BCMI_TSC_XGXS_RX_X1_SCW4r_RESERVED0f_GET
#define RX_X1_SCW4r_RESERVED0f_SET BCMI_TSC_XGXS_RX_X1_SCW4r_RESERVED0f_SET
#define RX_X1_SCW4r_MASK_RESERVED0f_GET BCMI_TSC_XGXS_RX_X1_SCW4r_MASK_RESERVED0f_GET
#define RX_X1_SCW4r_MASK_RESERVED0f_SET BCMI_TSC_XGXS_RX_X1_SCW4r_MASK_RESERVED0f_SET
#define RX_X1_SCW4r_MASK_SCW4_MASKf_GET BCMI_TSC_XGXS_RX_X1_SCW4r_MASK_SCW4_MASKf_GET
#define RX_X1_SCW4r_MASK_SCW4_MASKf_SET BCMI_TSC_XGXS_RX_X1_SCW4r_MASK_SCW4_MASKf_SET
#define RX_X1_SCW4r_SCW4f_GET BCMI_TSC_XGXS_RX_X1_SCW4r_SCW4f_GET
#define RX_X1_SCW4r_SCW4f_SET BCMI_TSC_XGXS_RX_X1_SCW4r_SCW4f_SET
#define READ_RX_X1_SCW4r BCMI_TSC_XGXS_READ_RX_X1_SCW4r
#define WRITE_RX_X1_SCW4r BCMI_TSC_XGXS_WRITE_RX_X1_SCW4r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X1_SCW4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X1_SCW0_MASK
 * BLOCKS:   RX_X1_CONTROL1
 * REGADDR:  0x9238
 * DESC:     Sync code word mask bits 65:50: 00000000
 * SIZE:     32
 * FIELDS:
 *     SCW0_MASK        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X1_SCW0_MASKr (0x00109238 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X1_SCW0_MASKr_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_SCW0_MASK.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X1_SCW0_MASKr_s {
	uint32_t v[1];
	uint32_t rx_x1_scw0_mask[1];
	uint32_t _rx_x1_scw0_mask;
} BCMI_TSC_XGXS_RX_X1_SCW0_MASKr_t;

#define BCMI_TSC_XGXS_RX_X1_SCW0_MASKr_CLR(r) (r).rx_x1_scw0_mask[0] = 0
#define BCMI_TSC_XGXS_RX_X1_SCW0_MASKr_SET(r,d) (r).rx_x1_scw0_mask[0] = d
#define BCMI_TSC_XGXS_RX_X1_SCW0_MASKr_GET(r) (r).rx_x1_scw0_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X1_SCW0_MASKr_SCW0_MASKf_GET(r) (((r).rx_x1_scw0_mask[0]) & 0xffff)
#define BCMI_TSC_XGXS_RX_X1_SCW0_MASKr_SCW0_MASKf_SET(r,f) (r).rx_x1_scw0_mask[0]=(((r).rx_x1_scw0_mask[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access RX_X1_SCW0_MASK.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X1_SCW0_MASKr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X1_SCW0_MASKr,(_r._rx_x1_scw0_mask))
#define BCMI_TSC_XGXS_WRITE_RX_X1_SCW0_MASKr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X1_SCW0_MASKr,(_r._rx_x1_scw0_mask))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_SCW0_MASKr BCMI_TSC_XGXS_RX_X1_SCW0_MASKr
#define RX_X1_SCW0_MASKr_SIZE BCMI_TSC_XGXS_RX_X1_SCW0_MASKr_SIZE
typedef BCMI_TSC_XGXS_RX_X1_SCW0_MASKr_t RX_X1_SCW0_MASKr_t;
#define RX_X1_SCW0_MASKr_CLR BCMI_TSC_XGXS_RX_X1_SCW0_MASKr_CLR
#define RX_X1_SCW0_MASKr_SET BCMI_TSC_XGXS_RX_X1_SCW0_MASKr_SET
#define RX_X1_SCW0_MASKr_GET BCMI_TSC_XGXS_RX_X1_SCW0_MASKr_GET
#define RX_X1_SCW0_MASKr_SCW0_MASKf_GET BCMI_TSC_XGXS_RX_X1_SCW0_MASKr_SCW0_MASKf_GET
#define RX_X1_SCW0_MASKr_SCW0_MASKf_SET BCMI_TSC_XGXS_RX_X1_SCW0_MASKr_SCW0_MASKf_SET
#define READ_RX_X1_SCW0_MASKr BCMI_TSC_XGXS_READ_RX_X1_SCW0_MASKr
#define WRITE_RX_X1_SCW0_MASKr BCMI_TSC_XGXS_WRITE_RX_X1_SCW0_MASKr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X1_SCW0_MASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X1_SCW1_MASK
 * BLOCKS:   RX_X1_CONTROL1
 * REGADDR:  0x9239
 * DESC:     Sync code word mask bits 49:34: 00000000
 * SIZE:     32
 * FIELDS:
 *     SCW1_MASK        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X1_SCW1_MASKr (0x00109239 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X1_SCW1_MASKr_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_SCW1_MASK.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X1_SCW1_MASKr_s {
	uint32_t v[1];
	uint32_t rx_x1_scw1_mask[1];
	uint32_t _rx_x1_scw1_mask;
} BCMI_TSC_XGXS_RX_X1_SCW1_MASKr_t;

#define BCMI_TSC_XGXS_RX_X1_SCW1_MASKr_CLR(r) (r).rx_x1_scw1_mask[0] = 0
#define BCMI_TSC_XGXS_RX_X1_SCW1_MASKr_SET(r,d) (r).rx_x1_scw1_mask[0] = d
#define BCMI_TSC_XGXS_RX_X1_SCW1_MASKr_GET(r) (r).rx_x1_scw1_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X1_SCW1_MASKr_SCW1_MASKf_GET(r) (((r).rx_x1_scw1_mask[0]) & 0xffff)
#define BCMI_TSC_XGXS_RX_X1_SCW1_MASKr_SCW1_MASKf_SET(r,f) (r).rx_x1_scw1_mask[0]=(((r).rx_x1_scw1_mask[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access RX_X1_SCW1_MASK.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X1_SCW1_MASKr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X1_SCW1_MASKr,(_r._rx_x1_scw1_mask))
#define BCMI_TSC_XGXS_WRITE_RX_X1_SCW1_MASKr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X1_SCW1_MASKr,(_r._rx_x1_scw1_mask))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_SCW1_MASKr BCMI_TSC_XGXS_RX_X1_SCW1_MASKr
#define RX_X1_SCW1_MASKr_SIZE BCMI_TSC_XGXS_RX_X1_SCW1_MASKr_SIZE
typedef BCMI_TSC_XGXS_RX_X1_SCW1_MASKr_t RX_X1_SCW1_MASKr_t;
#define RX_X1_SCW1_MASKr_CLR BCMI_TSC_XGXS_RX_X1_SCW1_MASKr_CLR
#define RX_X1_SCW1_MASKr_SET BCMI_TSC_XGXS_RX_X1_SCW1_MASKr_SET
#define RX_X1_SCW1_MASKr_GET BCMI_TSC_XGXS_RX_X1_SCW1_MASKr_GET
#define RX_X1_SCW1_MASKr_SCW1_MASKf_GET BCMI_TSC_XGXS_RX_X1_SCW1_MASKr_SCW1_MASKf_GET
#define RX_X1_SCW1_MASKr_SCW1_MASKf_SET BCMI_TSC_XGXS_RX_X1_SCW1_MASKr_SCW1_MASKf_SET
#define READ_RX_X1_SCW1_MASKr BCMI_TSC_XGXS_READ_RX_X1_SCW1_MASKr
#define WRITE_RX_X1_SCW1_MASKr BCMI_TSC_XGXS_WRITE_RX_X1_SCW1_MASKr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X1_SCW1_MASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X1_SCW2_MASK
 * BLOCKS:   RX_X1_CONTROL1
 * REGADDR:  0x923a
 * DESC:     Sync code word mask bits 33:18: 00000000
 * SIZE:     32
 * FIELDS:
 *     SCW2_MASK        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X1_SCW2_MASKr (0x0010923a | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X1_SCW2_MASKr_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_SCW2_MASK.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X1_SCW2_MASKr_s {
	uint32_t v[1];
	uint32_t rx_x1_scw2_mask[1];
	uint32_t _rx_x1_scw2_mask;
} BCMI_TSC_XGXS_RX_X1_SCW2_MASKr_t;

#define BCMI_TSC_XGXS_RX_X1_SCW2_MASKr_CLR(r) (r).rx_x1_scw2_mask[0] = 0
#define BCMI_TSC_XGXS_RX_X1_SCW2_MASKr_SET(r,d) (r).rx_x1_scw2_mask[0] = d
#define BCMI_TSC_XGXS_RX_X1_SCW2_MASKr_GET(r) (r).rx_x1_scw2_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X1_SCW2_MASKr_SCW2_MASKf_GET(r) (((r).rx_x1_scw2_mask[0]) & 0xffff)
#define BCMI_TSC_XGXS_RX_X1_SCW2_MASKr_SCW2_MASKf_SET(r,f) (r).rx_x1_scw2_mask[0]=(((r).rx_x1_scw2_mask[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access RX_X1_SCW2_MASK.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X1_SCW2_MASKr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X1_SCW2_MASKr,(_r._rx_x1_scw2_mask))
#define BCMI_TSC_XGXS_WRITE_RX_X1_SCW2_MASKr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X1_SCW2_MASKr,(_r._rx_x1_scw2_mask))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_SCW2_MASKr BCMI_TSC_XGXS_RX_X1_SCW2_MASKr
#define RX_X1_SCW2_MASKr_SIZE BCMI_TSC_XGXS_RX_X1_SCW2_MASKr_SIZE
typedef BCMI_TSC_XGXS_RX_X1_SCW2_MASKr_t RX_X1_SCW2_MASKr_t;
#define RX_X1_SCW2_MASKr_CLR BCMI_TSC_XGXS_RX_X1_SCW2_MASKr_CLR
#define RX_X1_SCW2_MASKr_SET BCMI_TSC_XGXS_RX_X1_SCW2_MASKr_SET
#define RX_X1_SCW2_MASKr_GET BCMI_TSC_XGXS_RX_X1_SCW2_MASKr_GET
#define RX_X1_SCW2_MASKr_SCW2_MASKf_GET BCMI_TSC_XGXS_RX_X1_SCW2_MASKr_SCW2_MASKf_GET
#define RX_X1_SCW2_MASKr_SCW2_MASKf_SET BCMI_TSC_XGXS_RX_X1_SCW2_MASKr_SCW2_MASKf_SET
#define READ_RX_X1_SCW2_MASKr BCMI_TSC_XGXS_READ_RX_X1_SCW2_MASKr
#define WRITE_RX_X1_SCW2_MASKr BCMI_TSC_XGXS_WRITE_RX_X1_SCW2_MASKr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X1_SCW2_MASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X1_SCW3_MASK
 * BLOCKS:   RX_X1_CONTROL1
 * REGADDR:  0x923b
 * DESC:     Sync code word mask bits 17:2: 00000000
 * SIZE:     32
 * FIELDS:
 *     SCW3_MASK        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X1_SCW3_MASKr (0x0010923b | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X1_SCW3_MASKr_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_SCW3_MASK.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X1_SCW3_MASKr_s {
	uint32_t v[1];
	uint32_t rx_x1_scw3_mask[1];
	uint32_t _rx_x1_scw3_mask;
} BCMI_TSC_XGXS_RX_X1_SCW3_MASKr_t;

#define BCMI_TSC_XGXS_RX_X1_SCW3_MASKr_CLR(r) (r).rx_x1_scw3_mask[0] = 0
#define BCMI_TSC_XGXS_RX_X1_SCW3_MASKr_SET(r,d) (r).rx_x1_scw3_mask[0] = d
#define BCMI_TSC_XGXS_RX_X1_SCW3_MASKr_GET(r) (r).rx_x1_scw3_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X1_SCW3_MASKr_SCW3_MASKf_GET(r) (((r).rx_x1_scw3_mask[0]) & 0xffff)
#define BCMI_TSC_XGXS_RX_X1_SCW3_MASKr_SCW3_MASKf_SET(r,f) (r).rx_x1_scw3_mask[0]=(((r).rx_x1_scw3_mask[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access RX_X1_SCW3_MASK.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X1_SCW3_MASKr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X1_SCW3_MASKr,(_r._rx_x1_scw3_mask))
#define BCMI_TSC_XGXS_WRITE_RX_X1_SCW3_MASKr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X1_SCW3_MASKr,(_r._rx_x1_scw3_mask))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_SCW3_MASKr BCMI_TSC_XGXS_RX_X1_SCW3_MASKr
#define RX_X1_SCW3_MASKr_SIZE BCMI_TSC_XGXS_RX_X1_SCW3_MASKr_SIZE
typedef BCMI_TSC_XGXS_RX_X1_SCW3_MASKr_t RX_X1_SCW3_MASKr_t;
#define RX_X1_SCW3_MASKr_CLR BCMI_TSC_XGXS_RX_X1_SCW3_MASKr_CLR
#define RX_X1_SCW3_MASKr_SET BCMI_TSC_XGXS_RX_X1_SCW3_MASKr_SET
#define RX_X1_SCW3_MASKr_GET BCMI_TSC_XGXS_RX_X1_SCW3_MASKr_GET
#define RX_X1_SCW3_MASKr_SCW3_MASKf_GET BCMI_TSC_XGXS_RX_X1_SCW3_MASKr_SCW3_MASKf_GET
#define RX_X1_SCW3_MASKr_SCW3_MASKf_SET BCMI_TSC_XGXS_RX_X1_SCW3_MASKr_SCW3_MASKf_SET
#define READ_RX_X1_SCW3_MASKr BCMI_TSC_XGXS_READ_RX_X1_SCW3_MASKr
#define WRITE_RX_X1_SCW3_MASKr BCMI_TSC_XGXS_WRITE_RX_X1_SCW3_MASKr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X1_SCW3_MASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X1_SCW4_MASK
 * BLOCKS:   RX_X1_CONTROL1
 * REGADDR:  0x923c
 * DESC:     Sync code word mask bits 1:0: 00000000
 * SIZE:     32
 * FIELDS:
 *     SCW4_MASK        
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X1_SCW4_MASKr (0x0010923c | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X1_SCW4_MASKr_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_SCW4_MASK.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X1_SCW4_MASKr_s {
	uint32_t v[1];
	uint32_t rx_x1_scw4_mask[1];
	uint32_t _rx_x1_scw4_mask;
} BCMI_TSC_XGXS_RX_X1_SCW4_MASKr_t;

#define BCMI_TSC_XGXS_RX_X1_SCW4_MASKr_CLR(r) (r).rx_x1_scw4_mask[0] = 0
#define BCMI_TSC_XGXS_RX_X1_SCW4_MASKr_SET(r,d) (r).rx_x1_scw4_mask[0] = d
#define BCMI_TSC_XGXS_RX_X1_SCW4_MASKr_GET(r) (r).rx_x1_scw4_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X1_SCW4_MASKr_RESERVED0f_GET(r) ((((r).rx_x1_scw4_mask[0]) >> 2) & 0x3fff)
#define BCMI_TSC_XGXS_RX_X1_SCW4_MASKr_RESERVED0f_SET(r,f) (r).rx_x1_scw4_mask[0]=(((r).rx_x1_scw4_mask[0] & ~((uint32_t)0x3fff << 2)) | ((((uint32_t)f) & 0x3fff) << 2))
#define BCMI_TSC_XGXS_RX_X1_SCW4_MASKr_SCW4_MASKf_GET(r) (((r).rx_x1_scw4_mask[0]) & 0x3)
#define BCMI_TSC_XGXS_RX_X1_SCW4_MASKr_SCW4_MASKf_SET(r,f) (r).rx_x1_scw4_mask[0]=(((r).rx_x1_scw4_mask[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))

/*
 * These macros can be used to access RX_X1_SCW4_MASK.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X1_SCW4_MASKr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X1_SCW4_MASKr,(_r._rx_x1_scw4_mask))
#define BCMI_TSC_XGXS_WRITE_RX_X1_SCW4_MASKr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X1_SCW4_MASKr,(_r._rx_x1_scw4_mask))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_SCW4_MASKr BCMI_TSC_XGXS_RX_X1_SCW4_MASKr
#define RX_X1_SCW4_MASKr_SIZE BCMI_TSC_XGXS_RX_X1_SCW4_MASKr_SIZE
typedef BCMI_TSC_XGXS_RX_X1_SCW4_MASKr_t RX_X1_SCW4_MASKr_t;
#define RX_X1_SCW4_MASKr_CLR BCMI_TSC_XGXS_RX_X1_SCW4_MASKr_CLR
#define RX_X1_SCW4_MASKr_SET BCMI_TSC_XGXS_RX_X1_SCW4_MASKr_SET
#define RX_X1_SCW4_MASKr_GET BCMI_TSC_XGXS_RX_X1_SCW4_MASKr_GET
#define RX_X1_SCW4_MASKr_RESERVED0f_GET BCMI_TSC_XGXS_RX_X1_SCW4_MASKr_RESERVED0f_GET
#define RX_X1_SCW4_MASKr_RESERVED0f_SET BCMI_TSC_XGXS_RX_X1_SCW4_MASKr_RESERVED0f_SET
#define RX_X1_SCW4_MASKr_SCW4_MASKf_GET BCMI_TSC_XGXS_RX_X1_SCW4_MASKr_SCW4_MASKf_GET
#define RX_X1_SCW4_MASKr_SCW4_MASKf_SET BCMI_TSC_XGXS_RX_X1_SCW4_MASKr_SCW4_MASKf_SET
#define READ_RX_X1_SCW4_MASKr BCMI_TSC_XGXS_READ_RX_X1_SCW4_MASKr
#define WRITE_RX_X1_SCW4_MASKr BCMI_TSC_XGXS_WRITE_RX_X1_SCW4_MASKr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X1_SCW4_MASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  OUI_UPPER
 * BLOCKS:   AN_X1_CONTROL
 * REGADDR:  0x9240
 * DESC:     OUI UPPER BITS REGISTER: 00000000
 * SIZE:     32
 * FIELDS:
 *     OUI_UPPER_DATA   
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_OUI_UPPERr (0x00109240 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_OUI_UPPERr_SIZE 4

/*
 * This structure should be used to declare and program OUI_UPPER.
 *
 */
typedef union BCMI_TSC_XGXS_OUI_UPPERr_s {
	uint32_t v[1];
	uint32_t oui_upper[1];
	uint32_t _oui_upper;
} BCMI_TSC_XGXS_OUI_UPPERr_t;

#define BCMI_TSC_XGXS_OUI_UPPERr_CLR(r) (r).oui_upper[0] = 0
#define BCMI_TSC_XGXS_OUI_UPPERr_SET(r,d) (r).oui_upper[0] = d
#define BCMI_TSC_XGXS_OUI_UPPERr_GET(r) (r).oui_upper[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_OUI_UPPERr_RESERVED0f_GET(r) ((((r).oui_upper[0]) >> 8) & 0xff)
#define BCMI_TSC_XGXS_OUI_UPPERr_RESERVED0f_SET(r,f) (r).oui_upper[0]=(((r).oui_upper[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCMI_TSC_XGXS_OUI_UPPERr_OUI_UPPER_DATAf_GET(r) (((r).oui_upper[0]) & 0xff)
#define BCMI_TSC_XGXS_OUI_UPPERr_OUI_UPPER_DATAf_SET(r,f) (r).oui_upper[0]=(((r).oui_upper[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access OUI_UPPER.
 *
 */
#define BCMI_TSC_XGXS_READ_OUI_UPPERr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_OUI_UPPERr,(_r._oui_upper))
#define BCMI_TSC_XGXS_WRITE_OUI_UPPERr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_OUI_UPPERr,(_r._oui_upper))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define OUI_UPPERr BCMI_TSC_XGXS_OUI_UPPERr
#define OUI_UPPERr_SIZE BCMI_TSC_XGXS_OUI_UPPERr_SIZE
typedef BCMI_TSC_XGXS_OUI_UPPERr_t OUI_UPPERr_t;
#define OUI_UPPERr_CLR BCMI_TSC_XGXS_OUI_UPPERr_CLR
#define OUI_UPPERr_SET BCMI_TSC_XGXS_OUI_UPPERr_SET
#define OUI_UPPERr_GET BCMI_TSC_XGXS_OUI_UPPERr_GET
#define OUI_UPPERr_RESERVED0f_GET BCMI_TSC_XGXS_OUI_UPPERr_RESERVED0f_GET
#define OUI_UPPERr_RESERVED0f_SET BCMI_TSC_XGXS_OUI_UPPERr_RESERVED0f_SET
#define OUI_UPPERr_OUI_UPPER_DATAf_GET BCMI_TSC_XGXS_OUI_UPPERr_OUI_UPPER_DATAf_GET
#define OUI_UPPERr_OUI_UPPER_DATAf_SET BCMI_TSC_XGXS_OUI_UPPERr_OUI_UPPER_DATAf_SET
#define READ_OUI_UPPERr BCMI_TSC_XGXS_READ_OUI_UPPERr
#define WRITE_OUI_UPPERr BCMI_TSC_XGXS_WRITE_OUI_UPPERr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_OUI_UPPERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  OUI_LOWER
 * BLOCKS:   AN_X1_CONTROL
 * REGADDR:  0x9241
 * DESC:     OUI LOWEr BITS REGISTER: 00000000
 * SIZE:     32
 * FIELDS:
 *     OUI_LOWER_DATA   
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_OUI_LOWERr (0x00109241 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_OUI_LOWERr_SIZE 4

/*
 * This structure should be used to declare and program OUI_LOWER.
 *
 */
typedef union BCMI_TSC_XGXS_OUI_LOWERr_s {
	uint32_t v[1];
	uint32_t oui_lower[1];
	uint32_t _oui_lower;
} BCMI_TSC_XGXS_OUI_LOWERr_t;

#define BCMI_TSC_XGXS_OUI_LOWERr_CLR(r) (r).oui_lower[0] = 0
#define BCMI_TSC_XGXS_OUI_LOWERr_SET(r,d) (r).oui_lower[0] = d
#define BCMI_TSC_XGXS_OUI_LOWERr_GET(r) (r).oui_lower[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_OUI_LOWERr_OUI_LOWER_DATAf_GET(r) (((r).oui_lower[0]) & 0xffff)
#define BCMI_TSC_XGXS_OUI_LOWERr_OUI_LOWER_DATAf_SET(r,f) (r).oui_lower[0]=(((r).oui_lower[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access OUI_LOWER.
 *
 */
#define BCMI_TSC_XGXS_READ_OUI_LOWERr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_OUI_LOWERr,(_r._oui_lower))
#define BCMI_TSC_XGXS_WRITE_OUI_LOWERr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_OUI_LOWERr,(_r._oui_lower))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define OUI_LOWERr BCMI_TSC_XGXS_OUI_LOWERr
#define OUI_LOWERr_SIZE BCMI_TSC_XGXS_OUI_LOWERr_SIZE
typedef BCMI_TSC_XGXS_OUI_LOWERr_t OUI_LOWERr_t;
#define OUI_LOWERr_CLR BCMI_TSC_XGXS_OUI_LOWERr_CLR
#define OUI_LOWERr_SET BCMI_TSC_XGXS_OUI_LOWERr_SET
#define OUI_LOWERr_GET BCMI_TSC_XGXS_OUI_LOWERr_GET
#define OUI_LOWERr_OUI_LOWER_DATAf_GET BCMI_TSC_XGXS_OUI_LOWERr_OUI_LOWER_DATAf_GET
#define OUI_LOWERr_OUI_LOWER_DATAf_SET BCMI_TSC_XGXS_OUI_LOWERr_OUI_LOWER_DATAf_SET
#define READ_OUI_LOWERr BCMI_TSC_XGXS_READ_OUI_LOWERr
#define WRITE_OUI_LOWERr BCMI_TSC_XGXS_WRITE_OUI_LOWERr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_OUI_LOWERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  BAM_SPEED_PRI_5_0
 * BLOCKS:   AN_X1_CONTROL
 * REGADDR:  0x9242
 * DESC:     REMAP PRIORITY REGISTER: 00000000
 * SIZE:     32
 * FIELDS:
 *     AN_PRIORITY_1000M 
 *     AN_PRIORITY_100M 
 *     AN_PRIORITY_10M  
 *     AN_PRIORITY_5GX4 
 *     AN_PRIORITY_2P5GX1 
 *     AN_PRIORITY_1GKX 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_5_0r (0x00109242 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_BAM_SPEED_PRI_5_0r_SIZE 4

/*
 * This structure should be used to declare and program BAM_SPEED_PRI_5_0.
 *
 */
typedef union BCMI_TSC_XGXS_BAM_SPEED_PRI_5_0r_s {
	uint32_t v[1];
	uint32_t bam_speed_pri_5_0[1];
	uint32_t _bam_speed_pri_5_0;
} BCMI_TSC_XGXS_BAM_SPEED_PRI_5_0r_t;

#define BCMI_TSC_XGXS_BAM_SPEED_PRI_5_0r_CLR(r) (r).bam_speed_pri_5_0[0] = 0
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_5_0r_SET(r,d) (r).bam_speed_pri_5_0[0] = d
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_5_0r_GET(r) (r).bam_speed_pri_5_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_5_0r_RESERVED0f_GET(r) ((((r).bam_speed_pri_5_0[0]) >> 12) & 0xf)
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_5_0r_RESERVED0f_SET(r,f) (r).bam_speed_pri_5_0[0]=(((r).bam_speed_pri_5_0[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_5_0r_AN_PRIORITY_1GKXf_GET(r) ((((r).bam_speed_pri_5_0[0]) >> 10) & 0x3)
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_5_0r_AN_PRIORITY_1GKXf_SET(r,f) (r).bam_speed_pri_5_0[0]=(((r).bam_speed_pri_5_0[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_5_0r_AN_PRIORITY_2P5GX1f_GET(r) ((((r).bam_speed_pri_5_0[0]) >> 8) & 0x3)
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_5_0r_AN_PRIORITY_2P5GX1f_SET(r,f) (r).bam_speed_pri_5_0[0]=(((r).bam_speed_pri_5_0[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_5_0r_AN_PRIORITY_5GX4f_GET(r) ((((r).bam_speed_pri_5_0[0]) >> 6) & 0x3)
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_5_0r_AN_PRIORITY_5GX4f_SET(r,f) (r).bam_speed_pri_5_0[0]=(((r).bam_speed_pri_5_0[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_5_0r_AN_PRIORITY_10Mf_GET(r) ((((r).bam_speed_pri_5_0[0]) >> 4) & 0x3)
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_5_0r_AN_PRIORITY_10Mf_SET(r,f) (r).bam_speed_pri_5_0[0]=(((r).bam_speed_pri_5_0[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_5_0r_AN_PRIORITY_100Mf_GET(r) ((((r).bam_speed_pri_5_0[0]) >> 2) & 0x3)
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_5_0r_AN_PRIORITY_100Mf_SET(r,f) (r).bam_speed_pri_5_0[0]=(((r).bam_speed_pri_5_0[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_5_0r_AN_PRIORITY_1000Mf_GET(r) (((r).bam_speed_pri_5_0[0]) & 0x3)
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_5_0r_AN_PRIORITY_1000Mf_SET(r,f) (r).bam_speed_pri_5_0[0]=(((r).bam_speed_pri_5_0[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))

/*
 * These macros can be used to access BAM_SPEED_PRI_5_0.
 *
 */
#define BCMI_TSC_XGXS_READ_BAM_SPEED_PRI_5_0r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_BAM_SPEED_PRI_5_0r,(_r._bam_speed_pri_5_0))
#define BCMI_TSC_XGXS_WRITE_BAM_SPEED_PRI_5_0r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_BAM_SPEED_PRI_5_0r,(_r._bam_speed_pri_5_0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define BAM_SPEED_PRI_5_0r BCMI_TSC_XGXS_BAM_SPEED_PRI_5_0r
#define BAM_SPEED_PRI_5_0r_SIZE BCMI_TSC_XGXS_BAM_SPEED_PRI_5_0r_SIZE
typedef BCMI_TSC_XGXS_BAM_SPEED_PRI_5_0r_t BAM_SPEED_PRI_5_0r_t;
#define BAM_SPEED_PRI_5_0r_CLR BCMI_TSC_XGXS_BAM_SPEED_PRI_5_0r_CLR
#define BAM_SPEED_PRI_5_0r_SET BCMI_TSC_XGXS_BAM_SPEED_PRI_5_0r_SET
#define BAM_SPEED_PRI_5_0r_GET BCMI_TSC_XGXS_BAM_SPEED_PRI_5_0r_GET
#define BAM_SPEED_PRI_5_0r_RESERVED0f_GET BCMI_TSC_XGXS_BAM_SPEED_PRI_5_0r_RESERVED0f_GET
#define BAM_SPEED_PRI_5_0r_RESERVED0f_SET BCMI_TSC_XGXS_BAM_SPEED_PRI_5_0r_RESERVED0f_SET
#define BAM_SPEED_PRI_5_0r_AN_PRIORITY_1GKXf_GET BCMI_TSC_XGXS_BAM_SPEED_PRI_5_0r_AN_PRIORITY_1GKXf_GET
#define BAM_SPEED_PRI_5_0r_AN_PRIORITY_1GKXf_SET BCMI_TSC_XGXS_BAM_SPEED_PRI_5_0r_AN_PRIORITY_1GKXf_SET
#define BAM_SPEED_PRI_5_0r_AN_PRIORITY_2P5GX1f_GET BCMI_TSC_XGXS_BAM_SPEED_PRI_5_0r_AN_PRIORITY_2P5GX1f_GET
#define BAM_SPEED_PRI_5_0r_AN_PRIORITY_2P5GX1f_SET BCMI_TSC_XGXS_BAM_SPEED_PRI_5_0r_AN_PRIORITY_2P5GX1f_SET
#define BAM_SPEED_PRI_5_0r_AN_PRIORITY_5GX4f_GET BCMI_TSC_XGXS_BAM_SPEED_PRI_5_0r_AN_PRIORITY_5GX4f_GET
#define BAM_SPEED_PRI_5_0r_AN_PRIORITY_5GX4f_SET BCMI_TSC_XGXS_BAM_SPEED_PRI_5_0r_AN_PRIORITY_5GX4f_SET
#define BAM_SPEED_PRI_5_0r_AN_PRIORITY_10Mf_GET BCMI_TSC_XGXS_BAM_SPEED_PRI_5_0r_AN_PRIORITY_10Mf_GET
#define BAM_SPEED_PRI_5_0r_AN_PRIORITY_10Mf_SET BCMI_TSC_XGXS_BAM_SPEED_PRI_5_0r_AN_PRIORITY_10Mf_SET
#define BAM_SPEED_PRI_5_0r_AN_PRIORITY_100Mf_GET BCMI_TSC_XGXS_BAM_SPEED_PRI_5_0r_AN_PRIORITY_100Mf_GET
#define BAM_SPEED_PRI_5_0r_AN_PRIORITY_100Mf_SET BCMI_TSC_XGXS_BAM_SPEED_PRI_5_0r_AN_PRIORITY_100Mf_SET
#define BAM_SPEED_PRI_5_0r_AN_PRIORITY_1000Mf_GET BCMI_TSC_XGXS_BAM_SPEED_PRI_5_0r_AN_PRIORITY_1000Mf_GET
#define BAM_SPEED_PRI_5_0r_AN_PRIORITY_1000Mf_SET BCMI_TSC_XGXS_BAM_SPEED_PRI_5_0r_AN_PRIORITY_1000Mf_SET
#define READ_BAM_SPEED_PRI_5_0r BCMI_TSC_XGXS_READ_BAM_SPEED_PRI_5_0r
#define WRITE_BAM_SPEED_PRI_5_0r BCMI_TSC_XGXS_WRITE_BAM_SPEED_PRI_5_0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_BAM_SPEED_PRI_5_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  BAM_SPEED_PRI_11_6
 * BLOCKS:   AN_X1_CONTROL
 * REGADDR:  0x9243
 * DESC:     REMAP PRIORITY REGISTER: 00000000
 * SIZE:     32
 * FIELDS:
 *     AN_PRIORITY_10GCX4 
 *     AN_PRIORITY_10GCX1 
 *     AN_PRIORITY_6GX4 
 *     AN_PRIORITY_10GX4 
 *     AN_PRIORITY_10GKX4 
 *     AN_PRIORITY_10GKR 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_11_6r (0x00109243 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_BAM_SPEED_PRI_11_6r_SIZE 4

/*
 * This structure should be used to declare and program BAM_SPEED_PRI_11_6.
 *
 */
typedef union BCMI_TSC_XGXS_BAM_SPEED_PRI_11_6r_s {
	uint32_t v[1];
	uint32_t bam_speed_pri_11_6[1];
	uint32_t _bam_speed_pri_11_6;
} BCMI_TSC_XGXS_BAM_SPEED_PRI_11_6r_t;

#define BCMI_TSC_XGXS_BAM_SPEED_PRI_11_6r_CLR(r) (r).bam_speed_pri_11_6[0] = 0
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_11_6r_SET(r,d) (r).bam_speed_pri_11_6[0] = d
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_11_6r_GET(r) (r).bam_speed_pri_11_6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_11_6r_RESERVED0f_GET(r) ((((r).bam_speed_pri_11_6[0]) >> 12) & 0xf)
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_11_6r_RESERVED0f_SET(r,f) (r).bam_speed_pri_11_6[0]=(((r).bam_speed_pri_11_6[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_11_6r_AN_PRIORITY_10GKRf_GET(r) ((((r).bam_speed_pri_11_6[0]) >> 10) & 0x3)
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_11_6r_AN_PRIORITY_10GKRf_SET(r,f) (r).bam_speed_pri_11_6[0]=(((r).bam_speed_pri_11_6[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_11_6r_AN_PRIORITY_10GKX4f_GET(r) ((((r).bam_speed_pri_11_6[0]) >> 8) & 0x3)
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_11_6r_AN_PRIORITY_10GKX4f_SET(r,f) (r).bam_speed_pri_11_6[0]=(((r).bam_speed_pri_11_6[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_11_6r_AN_PRIORITY_10GX4f_GET(r) ((((r).bam_speed_pri_11_6[0]) >> 6) & 0x3)
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_11_6r_AN_PRIORITY_10GX4f_SET(r,f) (r).bam_speed_pri_11_6[0]=(((r).bam_speed_pri_11_6[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_11_6r_AN_PRIORITY_6GX4f_GET(r) ((((r).bam_speed_pri_11_6[0]) >> 4) & 0x3)
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_11_6r_AN_PRIORITY_6GX4f_SET(r,f) (r).bam_speed_pri_11_6[0]=(((r).bam_speed_pri_11_6[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_11_6r_AN_PRIORITY_10GCX1f_GET(r) ((((r).bam_speed_pri_11_6[0]) >> 2) & 0x3)
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_11_6r_AN_PRIORITY_10GCX1f_SET(r,f) (r).bam_speed_pri_11_6[0]=(((r).bam_speed_pri_11_6[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_11_6r_AN_PRIORITY_10GCX4f_GET(r) (((r).bam_speed_pri_11_6[0]) & 0x3)
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_11_6r_AN_PRIORITY_10GCX4f_SET(r,f) (r).bam_speed_pri_11_6[0]=(((r).bam_speed_pri_11_6[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))

/*
 * These macros can be used to access BAM_SPEED_PRI_11_6.
 *
 */
#define BCMI_TSC_XGXS_READ_BAM_SPEED_PRI_11_6r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_BAM_SPEED_PRI_11_6r,(_r._bam_speed_pri_11_6))
#define BCMI_TSC_XGXS_WRITE_BAM_SPEED_PRI_11_6r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_BAM_SPEED_PRI_11_6r,(_r._bam_speed_pri_11_6))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define BAM_SPEED_PRI_11_6r BCMI_TSC_XGXS_BAM_SPEED_PRI_11_6r
#define BAM_SPEED_PRI_11_6r_SIZE BCMI_TSC_XGXS_BAM_SPEED_PRI_11_6r_SIZE
typedef BCMI_TSC_XGXS_BAM_SPEED_PRI_11_6r_t BAM_SPEED_PRI_11_6r_t;
#define BAM_SPEED_PRI_11_6r_CLR BCMI_TSC_XGXS_BAM_SPEED_PRI_11_6r_CLR
#define BAM_SPEED_PRI_11_6r_SET BCMI_TSC_XGXS_BAM_SPEED_PRI_11_6r_SET
#define BAM_SPEED_PRI_11_6r_GET BCMI_TSC_XGXS_BAM_SPEED_PRI_11_6r_GET
#define BAM_SPEED_PRI_11_6r_RESERVED0f_GET BCMI_TSC_XGXS_BAM_SPEED_PRI_11_6r_RESERVED0f_GET
#define BAM_SPEED_PRI_11_6r_RESERVED0f_SET BCMI_TSC_XGXS_BAM_SPEED_PRI_11_6r_RESERVED0f_SET
#define BAM_SPEED_PRI_11_6r_AN_PRIORITY_10GKRf_GET BCMI_TSC_XGXS_BAM_SPEED_PRI_11_6r_AN_PRIORITY_10GKRf_GET
#define BAM_SPEED_PRI_11_6r_AN_PRIORITY_10GKRf_SET BCMI_TSC_XGXS_BAM_SPEED_PRI_11_6r_AN_PRIORITY_10GKRf_SET
#define BAM_SPEED_PRI_11_6r_AN_PRIORITY_10GKX4f_GET BCMI_TSC_XGXS_BAM_SPEED_PRI_11_6r_AN_PRIORITY_10GKX4f_GET
#define BAM_SPEED_PRI_11_6r_AN_PRIORITY_10GKX4f_SET BCMI_TSC_XGXS_BAM_SPEED_PRI_11_6r_AN_PRIORITY_10GKX4f_SET
#define BAM_SPEED_PRI_11_6r_AN_PRIORITY_10GX4f_GET BCMI_TSC_XGXS_BAM_SPEED_PRI_11_6r_AN_PRIORITY_10GX4f_GET
#define BAM_SPEED_PRI_11_6r_AN_PRIORITY_10GX4f_SET BCMI_TSC_XGXS_BAM_SPEED_PRI_11_6r_AN_PRIORITY_10GX4f_SET
#define BAM_SPEED_PRI_11_6r_AN_PRIORITY_6GX4f_GET BCMI_TSC_XGXS_BAM_SPEED_PRI_11_6r_AN_PRIORITY_6GX4f_GET
#define BAM_SPEED_PRI_11_6r_AN_PRIORITY_6GX4f_SET BCMI_TSC_XGXS_BAM_SPEED_PRI_11_6r_AN_PRIORITY_6GX4f_SET
#define BAM_SPEED_PRI_11_6r_AN_PRIORITY_10GCX1f_GET BCMI_TSC_XGXS_BAM_SPEED_PRI_11_6r_AN_PRIORITY_10GCX1f_GET
#define BAM_SPEED_PRI_11_6r_AN_PRIORITY_10GCX1f_SET BCMI_TSC_XGXS_BAM_SPEED_PRI_11_6r_AN_PRIORITY_10GCX1f_SET
#define BAM_SPEED_PRI_11_6r_AN_PRIORITY_10GCX4f_GET BCMI_TSC_XGXS_BAM_SPEED_PRI_11_6r_AN_PRIORITY_10GCX4f_GET
#define BAM_SPEED_PRI_11_6r_AN_PRIORITY_10GCX4f_SET BCMI_TSC_XGXS_BAM_SPEED_PRI_11_6r_AN_PRIORITY_10GCX4f_SET
#define READ_BAM_SPEED_PRI_11_6r BCMI_TSC_XGXS_READ_BAM_SPEED_PRI_11_6r
#define WRITE_BAM_SPEED_PRI_11_6r BCMI_TSC_XGXS_WRITE_BAM_SPEED_PRI_11_6r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_BAM_SPEED_PRI_11_6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  BAM_SPEED_PRI_17_12
 * BLOCKS:   AN_X1_CONTROL
 * REGADDR:  0x9244
 * DESC:     REMAP PRIORITY REGISTER: 00000000
 * SIZE:     32
 * FIELDS:
 *     AN_PRIORITY_10P5GX2 
 *     AN_PRIORITY_10GX2 
 *     AN_PRIORITY_10GCX2 
 *     AN_PRIORITY_12P7GX2 
 *     AN_PRIORITY_12P5GX4 
 *     AN_PRIORITY_12GX4 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_17_12r (0x00109244 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_BAM_SPEED_PRI_17_12r_SIZE 4

/*
 * This structure should be used to declare and program BAM_SPEED_PRI_17_12.
 *
 */
typedef union BCMI_TSC_XGXS_BAM_SPEED_PRI_17_12r_s {
	uint32_t v[1];
	uint32_t bam_speed_pri_17_12[1];
	uint32_t _bam_speed_pri_17_12;
} BCMI_TSC_XGXS_BAM_SPEED_PRI_17_12r_t;

#define BCMI_TSC_XGXS_BAM_SPEED_PRI_17_12r_CLR(r) (r).bam_speed_pri_17_12[0] = 0
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_17_12r_SET(r,d) (r).bam_speed_pri_17_12[0] = d
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_17_12r_GET(r) (r).bam_speed_pri_17_12[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_17_12r_RESERVED0f_GET(r) ((((r).bam_speed_pri_17_12[0]) >> 12) & 0xf)
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_17_12r_RESERVED0f_SET(r,f) (r).bam_speed_pri_17_12[0]=(((r).bam_speed_pri_17_12[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_17_12r_AN_PRIORITY_12GX4f_GET(r) ((((r).bam_speed_pri_17_12[0]) >> 10) & 0x3)
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_17_12r_AN_PRIORITY_12GX4f_SET(r,f) (r).bam_speed_pri_17_12[0]=(((r).bam_speed_pri_17_12[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_17_12r_AN_PRIORITY_12P5GX4f_GET(r) ((((r).bam_speed_pri_17_12[0]) >> 8) & 0x3)
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_17_12r_AN_PRIORITY_12P5GX4f_SET(r,f) (r).bam_speed_pri_17_12[0]=(((r).bam_speed_pri_17_12[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_17_12r_AN_PRIORITY_12P7GX2f_GET(r) ((((r).bam_speed_pri_17_12[0]) >> 6) & 0x3)
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_17_12r_AN_PRIORITY_12P7GX2f_SET(r,f) (r).bam_speed_pri_17_12[0]=(((r).bam_speed_pri_17_12[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_17_12r_AN_PRIORITY_10GCX2f_GET(r) ((((r).bam_speed_pri_17_12[0]) >> 4) & 0x3)
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_17_12r_AN_PRIORITY_10GCX2f_SET(r,f) (r).bam_speed_pri_17_12[0]=(((r).bam_speed_pri_17_12[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_17_12r_AN_PRIORITY_10GX2f_GET(r) ((((r).bam_speed_pri_17_12[0]) >> 2) & 0x3)
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_17_12r_AN_PRIORITY_10GX2f_SET(r,f) (r).bam_speed_pri_17_12[0]=(((r).bam_speed_pri_17_12[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_17_12r_AN_PRIORITY_10P5GX2f_GET(r) (((r).bam_speed_pri_17_12[0]) & 0x3)
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_17_12r_AN_PRIORITY_10P5GX2f_SET(r,f) (r).bam_speed_pri_17_12[0]=(((r).bam_speed_pri_17_12[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))

/*
 * These macros can be used to access BAM_SPEED_PRI_17_12.
 *
 */
#define BCMI_TSC_XGXS_READ_BAM_SPEED_PRI_17_12r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_BAM_SPEED_PRI_17_12r,(_r._bam_speed_pri_17_12))
#define BCMI_TSC_XGXS_WRITE_BAM_SPEED_PRI_17_12r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_BAM_SPEED_PRI_17_12r,(_r._bam_speed_pri_17_12))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define BAM_SPEED_PRI_17_12r BCMI_TSC_XGXS_BAM_SPEED_PRI_17_12r
#define BAM_SPEED_PRI_17_12r_SIZE BCMI_TSC_XGXS_BAM_SPEED_PRI_17_12r_SIZE
typedef BCMI_TSC_XGXS_BAM_SPEED_PRI_17_12r_t BAM_SPEED_PRI_17_12r_t;
#define BAM_SPEED_PRI_17_12r_CLR BCMI_TSC_XGXS_BAM_SPEED_PRI_17_12r_CLR
#define BAM_SPEED_PRI_17_12r_SET BCMI_TSC_XGXS_BAM_SPEED_PRI_17_12r_SET
#define BAM_SPEED_PRI_17_12r_GET BCMI_TSC_XGXS_BAM_SPEED_PRI_17_12r_GET
#define BAM_SPEED_PRI_17_12r_RESERVED0f_GET BCMI_TSC_XGXS_BAM_SPEED_PRI_17_12r_RESERVED0f_GET
#define BAM_SPEED_PRI_17_12r_RESERVED0f_SET BCMI_TSC_XGXS_BAM_SPEED_PRI_17_12r_RESERVED0f_SET
#define BAM_SPEED_PRI_17_12r_AN_PRIORITY_12GX4f_GET BCMI_TSC_XGXS_BAM_SPEED_PRI_17_12r_AN_PRIORITY_12GX4f_GET
#define BAM_SPEED_PRI_17_12r_AN_PRIORITY_12GX4f_SET BCMI_TSC_XGXS_BAM_SPEED_PRI_17_12r_AN_PRIORITY_12GX4f_SET
#define BAM_SPEED_PRI_17_12r_AN_PRIORITY_12P5GX4f_GET BCMI_TSC_XGXS_BAM_SPEED_PRI_17_12r_AN_PRIORITY_12P5GX4f_GET
#define BAM_SPEED_PRI_17_12r_AN_PRIORITY_12P5GX4f_SET BCMI_TSC_XGXS_BAM_SPEED_PRI_17_12r_AN_PRIORITY_12P5GX4f_SET
#define BAM_SPEED_PRI_17_12r_AN_PRIORITY_12P7GX2f_GET BCMI_TSC_XGXS_BAM_SPEED_PRI_17_12r_AN_PRIORITY_12P7GX2f_GET
#define BAM_SPEED_PRI_17_12r_AN_PRIORITY_12P7GX2f_SET BCMI_TSC_XGXS_BAM_SPEED_PRI_17_12r_AN_PRIORITY_12P7GX2f_SET
#define BAM_SPEED_PRI_17_12r_AN_PRIORITY_10GCX2f_GET BCMI_TSC_XGXS_BAM_SPEED_PRI_17_12r_AN_PRIORITY_10GCX2f_GET
#define BAM_SPEED_PRI_17_12r_AN_PRIORITY_10GCX2f_SET BCMI_TSC_XGXS_BAM_SPEED_PRI_17_12r_AN_PRIORITY_10GCX2f_SET
#define BAM_SPEED_PRI_17_12r_AN_PRIORITY_10GX2f_GET BCMI_TSC_XGXS_BAM_SPEED_PRI_17_12r_AN_PRIORITY_10GX2f_GET
#define BAM_SPEED_PRI_17_12r_AN_PRIORITY_10GX2f_SET BCMI_TSC_XGXS_BAM_SPEED_PRI_17_12r_AN_PRIORITY_10GX2f_SET
#define BAM_SPEED_PRI_17_12r_AN_PRIORITY_10P5GX2f_GET BCMI_TSC_XGXS_BAM_SPEED_PRI_17_12r_AN_PRIORITY_10P5GX2f_GET
#define BAM_SPEED_PRI_17_12r_AN_PRIORITY_10P5GX2f_SET BCMI_TSC_XGXS_BAM_SPEED_PRI_17_12r_AN_PRIORITY_10P5GX2f_SET
#define READ_BAM_SPEED_PRI_17_12r BCMI_TSC_XGXS_READ_BAM_SPEED_PRI_17_12r
#define WRITE_BAM_SPEED_PRI_17_12r BCMI_TSC_XGXS_WRITE_BAM_SPEED_PRI_17_12r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_BAM_SPEED_PRI_17_12r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  BAM_SPEED_PRI_23_18
 * BLOCKS:   AN_X1_CONTROL
 * REGADDR:  0x9245
 * DESC:     REMAP PRIORITY REGISTER: 00000000
 * SIZE:     32
 * FIELDS:
 *     AN_PRIORITY_15P75GX2 
 *     AN_PRIORITY_15GX4 
 *     AN_PRIORITY_13GX4 
 *     AN_PRIORITY_100GCR10 
 *     AN_PRIORITY_40GKR4 
 *     AN_PRIORITY_40GCR4 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_23_18r (0x00109245 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_BAM_SPEED_PRI_23_18r_SIZE 4

/*
 * This structure should be used to declare and program BAM_SPEED_PRI_23_18.
 *
 */
typedef union BCMI_TSC_XGXS_BAM_SPEED_PRI_23_18r_s {
	uint32_t v[1];
	uint32_t bam_speed_pri_23_18[1];
	uint32_t _bam_speed_pri_23_18;
} BCMI_TSC_XGXS_BAM_SPEED_PRI_23_18r_t;

#define BCMI_TSC_XGXS_BAM_SPEED_PRI_23_18r_CLR(r) (r).bam_speed_pri_23_18[0] = 0
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_23_18r_SET(r,d) (r).bam_speed_pri_23_18[0] = d
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_23_18r_GET(r) (r).bam_speed_pri_23_18[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_23_18r_RESERVED0f_GET(r) ((((r).bam_speed_pri_23_18[0]) >> 12) & 0xf)
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_23_18r_RESERVED0f_SET(r,f) (r).bam_speed_pri_23_18[0]=(((r).bam_speed_pri_23_18[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_23_18r_AN_PRIORITY_40GCR4f_GET(r) ((((r).bam_speed_pri_23_18[0]) >> 10) & 0x3)
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_23_18r_AN_PRIORITY_40GCR4f_SET(r,f) (r).bam_speed_pri_23_18[0]=(((r).bam_speed_pri_23_18[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_23_18r_AN_PRIORITY_40GKR4f_GET(r) ((((r).bam_speed_pri_23_18[0]) >> 8) & 0x3)
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_23_18r_AN_PRIORITY_40GKR4f_SET(r,f) (r).bam_speed_pri_23_18[0]=(((r).bam_speed_pri_23_18[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_23_18r_AN_PRIORITY_100GCR10f_GET(r) ((((r).bam_speed_pri_23_18[0]) >> 6) & 0x3)
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_23_18r_AN_PRIORITY_100GCR10f_SET(r,f) (r).bam_speed_pri_23_18[0]=(((r).bam_speed_pri_23_18[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_23_18r_AN_PRIORITY_13GX4f_GET(r) ((((r).bam_speed_pri_23_18[0]) >> 4) & 0x3)
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_23_18r_AN_PRIORITY_13GX4f_SET(r,f) (r).bam_speed_pri_23_18[0]=(((r).bam_speed_pri_23_18[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_23_18r_AN_PRIORITY_15GX4f_GET(r) ((((r).bam_speed_pri_23_18[0]) >> 2) & 0x3)
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_23_18r_AN_PRIORITY_15GX4f_SET(r,f) (r).bam_speed_pri_23_18[0]=(((r).bam_speed_pri_23_18[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_23_18r_AN_PRIORITY_15P75GX2f_GET(r) (((r).bam_speed_pri_23_18[0]) & 0x3)
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_23_18r_AN_PRIORITY_15P75GX2f_SET(r,f) (r).bam_speed_pri_23_18[0]=(((r).bam_speed_pri_23_18[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))

/*
 * These macros can be used to access BAM_SPEED_PRI_23_18.
 *
 */
#define BCMI_TSC_XGXS_READ_BAM_SPEED_PRI_23_18r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_BAM_SPEED_PRI_23_18r,(_r._bam_speed_pri_23_18))
#define BCMI_TSC_XGXS_WRITE_BAM_SPEED_PRI_23_18r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_BAM_SPEED_PRI_23_18r,(_r._bam_speed_pri_23_18))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define BAM_SPEED_PRI_23_18r BCMI_TSC_XGXS_BAM_SPEED_PRI_23_18r
#define BAM_SPEED_PRI_23_18r_SIZE BCMI_TSC_XGXS_BAM_SPEED_PRI_23_18r_SIZE
typedef BCMI_TSC_XGXS_BAM_SPEED_PRI_23_18r_t BAM_SPEED_PRI_23_18r_t;
#define BAM_SPEED_PRI_23_18r_CLR BCMI_TSC_XGXS_BAM_SPEED_PRI_23_18r_CLR
#define BAM_SPEED_PRI_23_18r_SET BCMI_TSC_XGXS_BAM_SPEED_PRI_23_18r_SET
#define BAM_SPEED_PRI_23_18r_GET BCMI_TSC_XGXS_BAM_SPEED_PRI_23_18r_GET
#define BAM_SPEED_PRI_23_18r_RESERVED0f_GET BCMI_TSC_XGXS_BAM_SPEED_PRI_23_18r_RESERVED0f_GET
#define BAM_SPEED_PRI_23_18r_RESERVED0f_SET BCMI_TSC_XGXS_BAM_SPEED_PRI_23_18r_RESERVED0f_SET
#define BAM_SPEED_PRI_23_18r_AN_PRIORITY_40GCR4f_GET BCMI_TSC_XGXS_BAM_SPEED_PRI_23_18r_AN_PRIORITY_40GCR4f_GET
#define BAM_SPEED_PRI_23_18r_AN_PRIORITY_40GCR4f_SET BCMI_TSC_XGXS_BAM_SPEED_PRI_23_18r_AN_PRIORITY_40GCR4f_SET
#define BAM_SPEED_PRI_23_18r_AN_PRIORITY_40GKR4f_GET BCMI_TSC_XGXS_BAM_SPEED_PRI_23_18r_AN_PRIORITY_40GKR4f_GET
#define BAM_SPEED_PRI_23_18r_AN_PRIORITY_40GKR4f_SET BCMI_TSC_XGXS_BAM_SPEED_PRI_23_18r_AN_PRIORITY_40GKR4f_SET
#define BAM_SPEED_PRI_23_18r_AN_PRIORITY_100GCR10f_GET BCMI_TSC_XGXS_BAM_SPEED_PRI_23_18r_AN_PRIORITY_100GCR10f_GET
#define BAM_SPEED_PRI_23_18r_AN_PRIORITY_100GCR10f_SET BCMI_TSC_XGXS_BAM_SPEED_PRI_23_18r_AN_PRIORITY_100GCR10f_SET
#define BAM_SPEED_PRI_23_18r_AN_PRIORITY_13GX4f_GET BCMI_TSC_XGXS_BAM_SPEED_PRI_23_18r_AN_PRIORITY_13GX4f_GET
#define BAM_SPEED_PRI_23_18r_AN_PRIORITY_13GX4f_SET BCMI_TSC_XGXS_BAM_SPEED_PRI_23_18r_AN_PRIORITY_13GX4f_SET
#define BAM_SPEED_PRI_23_18r_AN_PRIORITY_15GX4f_GET BCMI_TSC_XGXS_BAM_SPEED_PRI_23_18r_AN_PRIORITY_15GX4f_GET
#define BAM_SPEED_PRI_23_18r_AN_PRIORITY_15GX4f_SET BCMI_TSC_XGXS_BAM_SPEED_PRI_23_18r_AN_PRIORITY_15GX4f_SET
#define BAM_SPEED_PRI_23_18r_AN_PRIORITY_15P75GX2f_GET BCMI_TSC_XGXS_BAM_SPEED_PRI_23_18r_AN_PRIORITY_15P75GX2f_GET
#define BAM_SPEED_PRI_23_18r_AN_PRIORITY_15P75GX2f_SET BCMI_TSC_XGXS_BAM_SPEED_PRI_23_18r_AN_PRIORITY_15P75GX2f_SET
#define READ_BAM_SPEED_PRI_23_18r BCMI_TSC_XGXS_READ_BAM_SPEED_PRI_23_18r
#define WRITE_BAM_SPEED_PRI_23_18r BCMI_TSC_XGXS_WRITE_BAM_SPEED_PRI_23_18r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_BAM_SPEED_PRI_23_18r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  BAM_SPEED_PRI_29_24
 * BLOCKS:   AN_X1_CONTROL
 * REGADDR:  0x9246
 * DESC:     REMAP PRIORITY REGISTER: 00000000
 * SIZE:     32
 * FIELDS:
 *     AN_PRIORITY_20GCR2 
 *     AN_PRIORITY_20GCX2 
 *     AN_PRIORITY_16GX4 
 *     AN_PRIORITY_20GX2 
 *     AN_PRIORITY_20GCX4 
 *     AN_PRIORITY_20GKR2 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_29_24r (0x00109246 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_BAM_SPEED_PRI_29_24r_SIZE 4

/*
 * This structure should be used to declare and program BAM_SPEED_PRI_29_24.
 *
 */
typedef union BCMI_TSC_XGXS_BAM_SPEED_PRI_29_24r_s {
	uint32_t v[1];
	uint32_t bam_speed_pri_29_24[1];
	uint32_t _bam_speed_pri_29_24;
} BCMI_TSC_XGXS_BAM_SPEED_PRI_29_24r_t;

#define BCMI_TSC_XGXS_BAM_SPEED_PRI_29_24r_CLR(r) (r).bam_speed_pri_29_24[0] = 0
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_29_24r_SET(r,d) (r).bam_speed_pri_29_24[0] = d
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_29_24r_GET(r) (r).bam_speed_pri_29_24[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_29_24r_RESERVED0f_GET(r) ((((r).bam_speed_pri_29_24[0]) >> 12) & 0xf)
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_29_24r_RESERVED0f_SET(r,f) (r).bam_speed_pri_29_24[0]=(((r).bam_speed_pri_29_24[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_29_24r_AN_PRIORITY_20GKR2f_GET(r) ((((r).bam_speed_pri_29_24[0]) >> 10) & 0x3)
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_29_24r_AN_PRIORITY_20GKR2f_SET(r,f) (r).bam_speed_pri_29_24[0]=(((r).bam_speed_pri_29_24[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_29_24r_AN_PRIORITY_20GCX4f_GET(r) ((((r).bam_speed_pri_29_24[0]) >> 8) & 0x3)
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_29_24r_AN_PRIORITY_20GCX4f_SET(r,f) (r).bam_speed_pri_29_24[0]=(((r).bam_speed_pri_29_24[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_29_24r_AN_PRIORITY_20GX2f_GET(r) ((((r).bam_speed_pri_29_24[0]) >> 6) & 0x3)
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_29_24r_AN_PRIORITY_20GX2f_SET(r,f) (r).bam_speed_pri_29_24[0]=(((r).bam_speed_pri_29_24[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_29_24r_AN_PRIORITY_16GX4f_GET(r) ((((r).bam_speed_pri_29_24[0]) >> 4) & 0x3)
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_29_24r_AN_PRIORITY_16GX4f_SET(r,f) (r).bam_speed_pri_29_24[0]=(((r).bam_speed_pri_29_24[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_29_24r_AN_PRIORITY_20GCX2f_GET(r) ((((r).bam_speed_pri_29_24[0]) >> 2) & 0x3)
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_29_24r_AN_PRIORITY_20GCX2f_SET(r,f) (r).bam_speed_pri_29_24[0]=(((r).bam_speed_pri_29_24[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_29_24r_AN_PRIORITY_20GCR2f_GET(r) (((r).bam_speed_pri_29_24[0]) & 0x3)
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_29_24r_AN_PRIORITY_20GCR2f_SET(r,f) (r).bam_speed_pri_29_24[0]=(((r).bam_speed_pri_29_24[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))

/*
 * These macros can be used to access BAM_SPEED_PRI_29_24.
 *
 */
#define BCMI_TSC_XGXS_READ_BAM_SPEED_PRI_29_24r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_BAM_SPEED_PRI_29_24r,(_r._bam_speed_pri_29_24))
#define BCMI_TSC_XGXS_WRITE_BAM_SPEED_PRI_29_24r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_BAM_SPEED_PRI_29_24r,(_r._bam_speed_pri_29_24))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define BAM_SPEED_PRI_29_24r BCMI_TSC_XGXS_BAM_SPEED_PRI_29_24r
#define BAM_SPEED_PRI_29_24r_SIZE BCMI_TSC_XGXS_BAM_SPEED_PRI_29_24r_SIZE
typedef BCMI_TSC_XGXS_BAM_SPEED_PRI_29_24r_t BAM_SPEED_PRI_29_24r_t;
#define BAM_SPEED_PRI_29_24r_CLR BCMI_TSC_XGXS_BAM_SPEED_PRI_29_24r_CLR
#define BAM_SPEED_PRI_29_24r_SET BCMI_TSC_XGXS_BAM_SPEED_PRI_29_24r_SET
#define BAM_SPEED_PRI_29_24r_GET BCMI_TSC_XGXS_BAM_SPEED_PRI_29_24r_GET
#define BAM_SPEED_PRI_29_24r_RESERVED0f_GET BCMI_TSC_XGXS_BAM_SPEED_PRI_29_24r_RESERVED0f_GET
#define BAM_SPEED_PRI_29_24r_RESERVED0f_SET BCMI_TSC_XGXS_BAM_SPEED_PRI_29_24r_RESERVED0f_SET
#define BAM_SPEED_PRI_29_24r_AN_PRIORITY_20GKR2f_GET BCMI_TSC_XGXS_BAM_SPEED_PRI_29_24r_AN_PRIORITY_20GKR2f_GET
#define BAM_SPEED_PRI_29_24r_AN_PRIORITY_20GKR2f_SET BCMI_TSC_XGXS_BAM_SPEED_PRI_29_24r_AN_PRIORITY_20GKR2f_SET
#define BAM_SPEED_PRI_29_24r_AN_PRIORITY_20GCX4f_GET BCMI_TSC_XGXS_BAM_SPEED_PRI_29_24r_AN_PRIORITY_20GCX4f_GET
#define BAM_SPEED_PRI_29_24r_AN_PRIORITY_20GCX4f_SET BCMI_TSC_XGXS_BAM_SPEED_PRI_29_24r_AN_PRIORITY_20GCX4f_SET
#define BAM_SPEED_PRI_29_24r_AN_PRIORITY_20GX2f_GET BCMI_TSC_XGXS_BAM_SPEED_PRI_29_24r_AN_PRIORITY_20GX2f_GET
#define BAM_SPEED_PRI_29_24r_AN_PRIORITY_20GX2f_SET BCMI_TSC_XGXS_BAM_SPEED_PRI_29_24r_AN_PRIORITY_20GX2f_SET
#define BAM_SPEED_PRI_29_24r_AN_PRIORITY_16GX4f_GET BCMI_TSC_XGXS_BAM_SPEED_PRI_29_24r_AN_PRIORITY_16GX4f_GET
#define BAM_SPEED_PRI_29_24r_AN_PRIORITY_16GX4f_SET BCMI_TSC_XGXS_BAM_SPEED_PRI_29_24r_AN_PRIORITY_16GX4f_SET
#define BAM_SPEED_PRI_29_24r_AN_PRIORITY_20GCX2f_GET BCMI_TSC_XGXS_BAM_SPEED_PRI_29_24r_AN_PRIORITY_20GCX2f_GET
#define BAM_SPEED_PRI_29_24r_AN_PRIORITY_20GCX2f_SET BCMI_TSC_XGXS_BAM_SPEED_PRI_29_24r_AN_PRIORITY_20GCX2f_SET
#define BAM_SPEED_PRI_29_24r_AN_PRIORITY_20GCR2f_GET BCMI_TSC_XGXS_BAM_SPEED_PRI_29_24r_AN_PRIORITY_20GCR2f_GET
#define BAM_SPEED_PRI_29_24r_AN_PRIORITY_20GCR2f_SET BCMI_TSC_XGXS_BAM_SPEED_PRI_29_24r_AN_PRIORITY_20GCR2f_SET
#define READ_BAM_SPEED_PRI_29_24r BCMI_TSC_XGXS_READ_BAM_SPEED_PRI_29_24r
#define WRITE_BAM_SPEED_PRI_29_24r BCMI_TSC_XGXS_WRITE_BAM_SPEED_PRI_29_24r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_BAM_SPEED_PRI_29_24r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  BAM_SPEED_PRI_35_30
 * BLOCKS:   AN_X1_CONTROL
 * REGADDR:  0x9247
 * DESC:     REMAP PRIORITY REGISTER: 00000000
 * SIZE:     32
 * FIELDS:
 *     AN_PRIORITY_25P45GX4 
 *     AN_PRIORITY_21GX4 
 *     AN_PRIORITY_20GX4 
 *     AN_PRIORITY_40GX4 
 *     AN_PRIORITY_32P7G 
 *     AN_PRIORITY_31P5G 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_35_30r (0x00109247 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_BAM_SPEED_PRI_35_30r_SIZE 4

/*
 * This structure should be used to declare and program BAM_SPEED_PRI_35_30.
 *
 */
typedef union BCMI_TSC_XGXS_BAM_SPEED_PRI_35_30r_s {
	uint32_t v[1];
	uint32_t bam_speed_pri_35_30[1];
	uint32_t _bam_speed_pri_35_30;
} BCMI_TSC_XGXS_BAM_SPEED_PRI_35_30r_t;

#define BCMI_TSC_XGXS_BAM_SPEED_PRI_35_30r_CLR(r) (r).bam_speed_pri_35_30[0] = 0
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_35_30r_SET(r,d) (r).bam_speed_pri_35_30[0] = d
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_35_30r_GET(r) (r).bam_speed_pri_35_30[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_35_30r_RESERVED0f_GET(r) ((((r).bam_speed_pri_35_30[0]) >> 12) & 0xf)
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_35_30r_RESERVED0f_SET(r,f) (r).bam_speed_pri_35_30[0]=(((r).bam_speed_pri_35_30[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_35_30r_AN_PRIORITY_31P5Gf_GET(r) ((((r).bam_speed_pri_35_30[0]) >> 10) & 0x3)
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_35_30r_AN_PRIORITY_31P5Gf_SET(r,f) (r).bam_speed_pri_35_30[0]=(((r).bam_speed_pri_35_30[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_35_30r_AN_PRIORITY_32P7Gf_GET(r) ((((r).bam_speed_pri_35_30[0]) >> 8) & 0x3)
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_35_30r_AN_PRIORITY_32P7Gf_SET(r,f) (r).bam_speed_pri_35_30[0]=(((r).bam_speed_pri_35_30[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_35_30r_AN_PRIORITY_40GX4f_GET(r) ((((r).bam_speed_pri_35_30[0]) >> 6) & 0x3)
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_35_30r_AN_PRIORITY_40GX4f_SET(r,f) (r).bam_speed_pri_35_30[0]=(((r).bam_speed_pri_35_30[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_35_30r_AN_PRIORITY_20GX4f_GET(r) ((((r).bam_speed_pri_35_30[0]) >> 4) & 0x3)
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_35_30r_AN_PRIORITY_20GX4f_SET(r,f) (r).bam_speed_pri_35_30[0]=(((r).bam_speed_pri_35_30[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_35_30r_AN_PRIORITY_21GX4f_GET(r) ((((r).bam_speed_pri_35_30[0]) >> 2) & 0x3)
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_35_30r_AN_PRIORITY_21GX4f_SET(r,f) (r).bam_speed_pri_35_30[0]=(((r).bam_speed_pri_35_30[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_35_30r_AN_PRIORITY_25P45GX4f_GET(r) (((r).bam_speed_pri_35_30[0]) & 0x3)
#define BCMI_TSC_XGXS_BAM_SPEED_PRI_35_30r_AN_PRIORITY_25P45GX4f_SET(r,f) (r).bam_speed_pri_35_30[0]=(((r).bam_speed_pri_35_30[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))

/*
 * These macros can be used to access BAM_SPEED_PRI_35_30.
 *
 */
#define BCMI_TSC_XGXS_READ_BAM_SPEED_PRI_35_30r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_BAM_SPEED_PRI_35_30r,(_r._bam_speed_pri_35_30))
#define BCMI_TSC_XGXS_WRITE_BAM_SPEED_PRI_35_30r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_BAM_SPEED_PRI_35_30r,(_r._bam_speed_pri_35_30))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define BAM_SPEED_PRI_35_30r BCMI_TSC_XGXS_BAM_SPEED_PRI_35_30r
#define BAM_SPEED_PRI_35_30r_SIZE BCMI_TSC_XGXS_BAM_SPEED_PRI_35_30r_SIZE
typedef BCMI_TSC_XGXS_BAM_SPEED_PRI_35_30r_t BAM_SPEED_PRI_35_30r_t;
#define BAM_SPEED_PRI_35_30r_CLR BCMI_TSC_XGXS_BAM_SPEED_PRI_35_30r_CLR
#define BAM_SPEED_PRI_35_30r_SET BCMI_TSC_XGXS_BAM_SPEED_PRI_35_30r_SET
#define BAM_SPEED_PRI_35_30r_GET BCMI_TSC_XGXS_BAM_SPEED_PRI_35_30r_GET
#define BAM_SPEED_PRI_35_30r_RESERVED0f_GET BCMI_TSC_XGXS_BAM_SPEED_PRI_35_30r_RESERVED0f_GET
#define BAM_SPEED_PRI_35_30r_RESERVED0f_SET BCMI_TSC_XGXS_BAM_SPEED_PRI_35_30r_RESERVED0f_SET
#define BAM_SPEED_PRI_35_30r_AN_PRIORITY_31P5Gf_GET BCMI_TSC_XGXS_BAM_SPEED_PRI_35_30r_AN_PRIORITY_31P5Gf_GET
#define BAM_SPEED_PRI_35_30r_AN_PRIORITY_31P5Gf_SET BCMI_TSC_XGXS_BAM_SPEED_PRI_35_30r_AN_PRIORITY_31P5Gf_SET
#define BAM_SPEED_PRI_35_30r_AN_PRIORITY_32P7Gf_GET BCMI_TSC_XGXS_BAM_SPEED_PRI_35_30r_AN_PRIORITY_32P7Gf_GET
#define BAM_SPEED_PRI_35_30r_AN_PRIORITY_32P7Gf_SET BCMI_TSC_XGXS_BAM_SPEED_PRI_35_30r_AN_PRIORITY_32P7Gf_SET
#define BAM_SPEED_PRI_35_30r_AN_PRIORITY_40GX4f_GET BCMI_TSC_XGXS_BAM_SPEED_PRI_35_30r_AN_PRIORITY_40GX4f_GET
#define BAM_SPEED_PRI_35_30r_AN_PRIORITY_40GX4f_SET BCMI_TSC_XGXS_BAM_SPEED_PRI_35_30r_AN_PRIORITY_40GX4f_SET
#define BAM_SPEED_PRI_35_30r_AN_PRIORITY_20GX4f_GET BCMI_TSC_XGXS_BAM_SPEED_PRI_35_30r_AN_PRIORITY_20GX4f_GET
#define BAM_SPEED_PRI_35_30r_AN_PRIORITY_20GX4f_SET BCMI_TSC_XGXS_BAM_SPEED_PRI_35_30r_AN_PRIORITY_20GX4f_SET
#define BAM_SPEED_PRI_35_30r_AN_PRIORITY_21GX4f_GET BCMI_TSC_XGXS_BAM_SPEED_PRI_35_30r_AN_PRIORITY_21GX4f_GET
#define BAM_SPEED_PRI_35_30r_AN_PRIORITY_21GX4f_SET BCMI_TSC_XGXS_BAM_SPEED_PRI_35_30r_AN_PRIORITY_21GX4f_SET
#define BAM_SPEED_PRI_35_30r_AN_PRIORITY_25P45GX4f_GET BCMI_TSC_XGXS_BAM_SPEED_PRI_35_30r_AN_PRIORITY_25P45GX4f_GET
#define BAM_SPEED_PRI_35_30r_AN_PRIORITY_25P45GX4f_SET BCMI_TSC_XGXS_BAM_SPEED_PRI_35_30r_AN_PRIORITY_25P45GX4f_SET
#define READ_BAM_SPEED_PRI_35_30r BCMI_TSC_XGXS_READ_BAM_SPEED_PRI_35_30r
#define WRITE_BAM_SPEED_PRI_35_30r BCMI_TSC_XGXS_WRITE_BAM_SPEED_PRI_35_30r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_BAM_SPEED_PRI_35_30r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CONFIG_CONTROL
 * BLOCKS:   AN_X1_CONTROL
 * REGADDR:  0x9248
 * DESC:     REMAP PRIORITY REGISTER: 00000000
 * SIZE:     32
 * FIELDS:
 *     RAM_BASE         
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CONFIG_CONTROLr (0x00109248 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CONFIG_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program CONFIG_CONTROL.
 *
 */
typedef union BCMI_TSC_XGXS_CONFIG_CONTROLr_s {
	uint32_t v[1];
	uint32_t config_control[1];
	uint32_t _config_control;
} BCMI_TSC_XGXS_CONFIG_CONTROLr_t;

#define BCMI_TSC_XGXS_CONFIG_CONTROLr_CLR(r) (r).config_control[0] = 0
#define BCMI_TSC_XGXS_CONFIG_CONTROLr_SET(r,d) (r).config_control[0] = d
#define BCMI_TSC_XGXS_CONFIG_CONTROLr_GET(r) (r).config_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CONFIG_CONTROLr_RAM_BASEf_GET(r) (((r).config_control[0]) & 0xffff)
#define BCMI_TSC_XGXS_CONFIG_CONTROLr_RAM_BASEf_SET(r,f) (r).config_control[0]=(((r).config_control[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access CONFIG_CONTROL.
 *
 */
#define BCMI_TSC_XGXS_READ_CONFIG_CONTROLr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CONFIG_CONTROLr,(_r._config_control))
#define BCMI_TSC_XGXS_WRITE_CONFIG_CONTROLr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CONFIG_CONTROLr,(_r._config_control))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CONFIG_CONTROLr BCMI_TSC_XGXS_CONFIG_CONTROLr
#define CONFIG_CONTROLr_SIZE BCMI_TSC_XGXS_CONFIG_CONTROLr_SIZE
typedef BCMI_TSC_XGXS_CONFIG_CONTROLr_t CONFIG_CONTROLr_t;
#define CONFIG_CONTROLr_CLR BCMI_TSC_XGXS_CONFIG_CONTROLr_CLR
#define CONFIG_CONTROLr_SET BCMI_TSC_XGXS_CONFIG_CONTROLr_SET
#define CONFIG_CONTROLr_GET BCMI_TSC_XGXS_CONFIG_CONTROLr_GET
#define CONFIG_CONTROLr_RAM_BASEf_GET BCMI_TSC_XGXS_CONFIG_CONTROLr_RAM_BASEf_GET
#define CONFIG_CONTROLr_RAM_BASEf_SET BCMI_TSC_XGXS_CONFIG_CONTROLr_RAM_BASEf_SET
#define READ_CONFIG_CONTROLr BCMI_TSC_XGXS_READ_CONFIG_CONTROLr
#define WRITE_CONFIG_CONTROLr BCMI_TSC_XGXS_WRITE_CONFIG_CONTROLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CONFIG_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  PLL_RESET_TIMER
 * BLOCKS:   AN_X1_CONTROL
 * REGADDR:  0x9249
 * DESC:     PLL RESET TIMER PERIOD: 00000000
 * SIZE:     32
 * FIELDS:
 *     PLL_RESET_TIMER_PERIOD 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_PLL_RESET_TIMERr (0x00109249 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_PLL_RESET_TIMERr_SIZE 4

/*
 * This structure should be used to declare and program PLL_RESET_TIMER.
 *
 */
typedef union BCMI_TSC_XGXS_PLL_RESET_TIMERr_s {
	uint32_t v[1];
	uint32_t pll_reset_timer[1];
	uint32_t _pll_reset_timer;
} BCMI_TSC_XGXS_PLL_RESET_TIMERr_t;

#define BCMI_TSC_XGXS_PLL_RESET_TIMERr_CLR(r) (r).pll_reset_timer[0] = 0
#define BCMI_TSC_XGXS_PLL_RESET_TIMERr_SET(r,d) (r).pll_reset_timer[0] = d
#define BCMI_TSC_XGXS_PLL_RESET_TIMERr_GET(r) (r).pll_reset_timer[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_PLL_RESET_TIMERr_PLL_RESET_TIMER_PERIODf_GET(r) (((r).pll_reset_timer[0]) & 0xffff)
#define BCMI_TSC_XGXS_PLL_RESET_TIMERr_PLL_RESET_TIMER_PERIODf_SET(r,f) (r).pll_reset_timer[0]=(((r).pll_reset_timer[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PLL_RESET_TIMER.
 *
 */
#define BCMI_TSC_XGXS_READ_PLL_RESET_TIMERr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_PLL_RESET_TIMERr,(_r._pll_reset_timer))
#define BCMI_TSC_XGXS_WRITE_PLL_RESET_TIMERr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_PLL_RESET_TIMERr,(_r._pll_reset_timer))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PLL_RESET_TIMERr BCMI_TSC_XGXS_PLL_RESET_TIMERr
#define PLL_RESET_TIMERr_SIZE BCMI_TSC_XGXS_PLL_RESET_TIMERr_SIZE
typedef BCMI_TSC_XGXS_PLL_RESET_TIMERr_t PLL_RESET_TIMERr_t;
#define PLL_RESET_TIMERr_CLR BCMI_TSC_XGXS_PLL_RESET_TIMERr_CLR
#define PLL_RESET_TIMERr_SET BCMI_TSC_XGXS_PLL_RESET_TIMERr_SET
#define PLL_RESET_TIMERr_GET BCMI_TSC_XGXS_PLL_RESET_TIMERr_GET
#define PLL_RESET_TIMERr_PLL_RESET_TIMER_PERIODf_GET BCMI_TSC_XGXS_PLL_RESET_TIMERr_PLL_RESET_TIMER_PERIODf_GET
#define PLL_RESET_TIMERr_PLL_RESET_TIMER_PERIODf_SET BCMI_TSC_XGXS_PLL_RESET_TIMERr_PLL_RESET_TIMER_PERIODf_SET
#define READ_PLL_RESET_TIMERr BCMI_TSC_XGXS_READ_PLL_RESET_TIMERr
#define WRITE_PLL_RESET_TIMERr BCMI_TSC_XGXS_WRITE_PLL_RESET_TIMERr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_PLL_RESET_TIMERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CL37_RESTART
 * BLOCKS:   AN_X1_TIMERS
 * REGADDR:  0x9250
 * DESC:     CL37 AUTO-NEG RESTART TIMER: 00000000
 * SIZE:     32
 * FIELDS:
 *     CL37_RESTART_TIMER_PERIOD 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CL37_RESTARTr (0x00109250 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CL37_RESTARTr_SIZE 4

/*
 * This structure should be used to declare and program CL37_RESTART.
 *
 */
typedef union BCMI_TSC_XGXS_CL37_RESTARTr_s {
	uint32_t v[1];
	uint32_t cl37_restart[1];
	uint32_t _cl37_restart;
} BCMI_TSC_XGXS_CL37_RESTARTr_t;

#define BCMI_TSC_XGXS_CL37_RESTARTr_CLR(r) (r).cl37_restart[0] = 0
#define BCMI_TSC_XGXS_CL37_RESTARTr_SET(r,d) (r).cl37_restart[0] = d
#define BCMI_TSC_XGXS_CL37_RESTARTr_GET(r) (r).cl37_restart[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CL37_RESTARTr_CL37_RESTART_TIMER_PERIODf_GET(r) (((r).cl37_restart[0]) & 0xffff)
#define BCMI_TSC_XGXS_CL37_RESTARTr_CL37_RESTART_TIMER_PERIODf_SET(r,f) (r).cl37_restart[0]=(((r).cl37_restart[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access CL37_RESTART.
 *
 */
#define BCMI_TSC_XGXS_READ_CL37_RESTARTr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CL37_RESTARTr,(_r._cl37_restart))
#define BCMI_TSC_XGXS_WRITE_CL37_RESTARTr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CL37_RESTARTr,(_r._cl37_restart))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL37_RESTARTr BCMI_TSC_XGXS_CL37_RESTARTr
#define CL37_RESTARTr_SIZE BCMI_TSC_XGXS_CL37_RESTARTr_SIZE
typedef BCMI_TSC_XGXS_CL37_RESTARTr_t CL37_RESTARTr_t;
#define CL37_RESTARTr_CLR BCMI_TSC_XGXS_CL37_RESTARTr_CLR
#define CL37_RESTARTr_SET BCMI_TSC_XGXS_CL37_RESTARTr_SET
#define CL37_RESTARTr_GET BCMI_TSC_XGXS_CL37_RESTARTr_GET
#define CL37_RESTARTr_CL37_RESTART_TIMER_PERIODf_GET BCMI_TSC_XGXS_CL37_RESTARTr_CL37_RESTART_TIMER_PERIODf_GET
#define CL37_RESTARTr_CL37_RESTART_TIMER_PERIODf_SET BCMI_TSC_XGXS_CL37_RESTARTr_CL37_RESTART_TIMER_PERIODf_SET
#define READ_CL37_RESTARTr BCMI_TSC_XGXS_READ_CL37_RESTARTr
#define WRITE_CL37_RESTARTr BCMI_TSC_XGXS_WRITE_CL37_RESTARTr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CL37_RESTARTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CL37_ACK
 * BLOCKS:   AN_X1_TIMERS
 * REGADDR:  0x9251
 * DESC:     CL37 AUTO-NEG COMPLETE-ACKNOWLEDGE TIMER: 00000000
 * SIZE:     32
 * FIELDS:
 *     CL37_ACK_TIMER_PERIOD 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CL37_ACKr (0x00109251 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CL37_ACKr_SIZE 4

/*
 * This structure should be used to declare and program CL37_ACK.
 *
 */
typedef union BCMI_TSC_XGXS_CL37_ACKr_s {
	uint32_t v[1];
	uint32_t cl37_ack[1];
	uint32_t _cl37_ack;
} BCMI_TSC_XGXS_CL37_ACKr_t;

#define BCMI_TSC_XGXS_CL37_ACKr_CLR(r) (r).cl37_ack[0] = 0
#define BCMI_TSC_XGXS_CL37_ACKr_SET(r,d) (r).cl37_ack[0] = d
#define BCMI_TSC_XGXS_CL37_ACKr_GET(r) (r).cl37_ack[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CL37_ACKr_CL37_ACK_TIMER_PERIODf_GET(r) (((r).cl37_ack[0]) & 0xffff)
#define BCMI_TSC_XGXS_CL37_ACKr_CL37_ACK_TIMER_PERIODf_SET(r,f) (r).cl37_ack[0]=(((r).cl37_ack[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access CL37_ACK.
 *
 */
#define BCMI_TSC_XGXS_READ_CL37_ACKr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CL37_ACKr,(_r._cl37_ack))
#define BCMI_TSC_XGXS_WRITE_CL37_ACKr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CL37_ACKr,(_r._cl37_ack))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL37_ACKr BCMI_TSC_XGXS_CL37_ACKr
#define CL37_ACKr_SIZE BCMI_TSC_XGXS_CL37_ACKr_SIZE
typedef BCMI_TSC_XGXS_CL37_ACKr_t CL37_ACKr_t;
#define CL37_ACKr_CLR BCMI_TSC_XGXS_CL37_ACKr_CLR
#define CL37_ACKr_SET BCMI_TSC_XGXS_CL37_ACKr_SET
#define CL37_ACKr_GET BCMI_TSC_XGXS_CL37_ACKr_GET
#define CL37_ACKr_CL37_ACK_TIMER_PERIODf_GET BCMI_TSC_XGXS_CL37_ACKr_CL37_ACK_TIMER_PERIODf_GET
#define CL37_ACKr_CL37_ACK_TIMER_PERIODf_SET BCMI_TSC_XGXS_CL37_ACKr_CL37_ACK_TIMER_PERIODf_SET
#define READ_CL37_ACKr BCMI_TSC_XGXS_READ_CL37_ACKr
#define WRITE_CL37_ACKr BCMI_TSC_XGXS_WRITE_CL37_ACKr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CL37_ACKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CL37_ERROR
 * BLOCKS:   AN_X1_TIMERS
 * REGADDR:  0x9252
 * DESC:     CL37 AUTO-NEG TIMEOUT-ERROR TIMER: 00000000
 * SIZE:     32
 * FIELDS:
 *     CL37_ERROR_TIMER_PERIOD 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CL37_ERRORr (0x00109252 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CL37_ERRORr_SIZE 4

/*
 * This structure should be used to declare and program CL37_ERROR.
 *
 */
typedef union BCMI_TSC_XGXS_CL37_ERRORr_s {
	uint32_t v[1];
	uint32_t cl37_error[1];
	uint32_t _cl37_error;
} BCMI_TSC_XGXS_CL37_ERRORr_t;

#define BCMI_TSC_XGXS_CL37_ERRORr_CLR(r) (r).cl37_error[0] = 0
#define BCMI_TSC_XGXS_CL37_ERRORr_SET(r,d) (r).cl37_error[0] = d
#define BCMI_TSC_XGXS_CL37_ERRORr_GET(r) (r).cl37_error[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CL37_ERRORr_CL37_ERROR_TIMER_PERIODf_GET(r) (((r).cl37_error[0]) & 0xffff)
#define BCMI_TSC_XGXS_CL37_ERRORr_CL37_ERROR_TIMER_PERIODf_SET(r,f) (r).cl37_error[0]=(((r).cl37_error[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access CL37_ERROR.
 *
 */
#define BCMI_TSC_XGXS_READ_CL37_ERRORr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CL37_ERRORr,(_r._cl37_error))
#define BCMI_TSC_XGXS_WRITE_CL37_ERRORr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CL37_ERRORr,(_r._cl37_error))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL37_ERRORr BCMI_TSC_XGXS_CL37_ERRORr
#define CL37_ERRORr_SIZE BCMI_TSC_XGXS_CL37_ERRORr_SIZE
typedef BCMI_TSC_XGXS_CL37_ERRORr_t CL37_ERRORr_t;
#define CL37_ERRORr_CLR BCMI_TSC_XGXS_CL37_ERRORr_CLR
#define CL37_ERRORr_SET BCMI_TSC_XGXS_CL37_ERRORr_SET
#define CL37_ERRORr_GET BCMI_TSC_XGXS_CL37_ERRORr_GET
#define CL37_ERRORr_CL37_ERROR_TIMER_PERIODf_GET BCMI_TSC_XGXS_CL37_ERRORr_CL37_ERROR_TIMER_PERIODf_GET
#define CL37_ERRORr_CL37_ERROR_TIMER_PERIODf_SET BCMI_TSC_XGXS_CL37_ERRORr_CL37_ERROR_TIMER_PERIODf_SET
#define READ_CL37_ERRORr BCMI_TSC_XGXS_READ_CL37_ERRORr
#define WRITE_CL37_ERRORr BCMI_TSC_XGXS_WRITE_CL37_ERRORr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CL37_ERRORr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CL73_BREAK_LINK
 * BLOCKS:   AN_X1_TIMERS
 * REGADDR:  0x9253
 * DESC:     CL73 AUTO-NEG BREAK-LINK TIMER: 00000000
 * SIZE:     32
 * FIELDS:
 *     TX_DISABLE_TIMER_PERIOD 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CL73_BREAK_LINKr (0x00109253 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CL73_BREAK_LINKr_SIZE 4

/*
 * This structure should be used to declare and program CL73_BREAK_LINK.
 *
 */
typedef union BCMI_TSC_XGXS_CL73_BREAK_LINKr_s {
	uint32_t v[1];
	uint32_t cl73_break_link[1];
	uint32_t _cl73_break_link;
} BCMI_TSC_XGXS_CL73_BREAK_LINKr_t;

#define BCMI_TSC_XGXS_CL73_BREAK_LINKr_CLR(r) (r).cl73_break_link[0] = 0
#define BCMI_TSC_XGXS_CL73_BREAK_LINKr_SET(r,d) (r).cl73_break_link[0] = d
#define BCMI_TSC_XGXS_CL73_BREAK_LINKr_GET(r) (r).cl73_break_link[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CL73_BREAK_LINKr_TX_DISABLE_TIMER_PERIODf_GET(r) (((r).cl73_break_link[0]) & 0xffff)
#define BCMI_TSC_XGXS_CL73_BREAK_LINKr_TX_DISABLE_TIMER_PERIODf_SET(r,f) (r).cl73_break_link[0]=(((r).cl73_break_link[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access CL73_BREAK_LINK.
 *
 */
#define BCMI_TSC_XGXS_READ_CL73_BREAK_LINKr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CL73_BREAK_LINKr,(_r._cl73_break_link))
#define BCMI_TSC_XGXS_WRITE_CL73_BREAK_LINKr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CL73_BREAK_LINKr,(_r._cl73_break_link))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL73_BREAK_LINKr BCMI_TSC_XGXS_CL73_BREAK_LINKr
#define CL73_BREAK_LINKr_SIZE BCMI_TSC_XGXS_CL73_BREAK_LINKr_SIZE
typedef BCMI_TSC_XGXS_CL73_BREAK_LINKr_t CL73_BREAK_LINKr_t;
#define CL73_BREAK_LINKr_CLR BCMI_TSC_XGXS_CL73_BREAK_LINKr_CLR
#define CL73_BREAK_LINKr_SET BCMI_TSC_XGXS_CL73_BREAK_LINKr_SET
#define CL73_BREAK_LINKr_GET BCMI_TSC_XGXS_CL73_BREAK_LINKr_GET
#define CL73_BREAK_LINKr_TX_DISABLE_TIMER_PERIODf_GET BCMI_TSC_XGXS_CL73_BREAK_LINKr_TX_DISABLE_TIMER_PERIODf_GET
#define CL73_BREAK_LINKr_TX_DISABLE_TIMER_PERIODf_SET BCMI_TSC_XGXS_CL73_BREAK_LINKr_TX_DISABLE_TIMER_PERIODf_SET
#define READ_CL73_BREAK_LINKr BCMI_TSC_XGXS_READ_CL73_BREAK_LINKr
#define WRITE_CL73_BREAK_LINKr BCMI_TSC_XGXS_WRITE_CL73_BREAK_LINKr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CL73_BREAK_LINKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CL73_ERROR
 * BLOCKS:   AN_X1_TIMERS
 * REGADDR:  0x9254
 * DESC:     CL73 AUTO-NEG TIMEOUT-ERROR TIMER: 00000000
 * SIZE:     32
 * FIELDS:
 *     CL73_ERROR_TIMER_PERIOD 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CL73_ERRORr (0x00109254 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CL73_ERRORr_SIZE 4

/*
 * This structure should be used to declare and program CL73_ERROR.
 *
 */
typedef union BCMI_TSC_XGXS_CL73_ERRORr_s {
	uint32_t v[1];
	uint32_t cl73_error[1];
	uint32_t _cl73_error;
} BCMI_TSC_XGXS_CL73_ERRORr_t;

#define BCMI_TSC_XGXS_CL73_ERRORr_CLR(r) (r).cl73_error[0] = 0
#define BCMI_TSC_XGXS_CL73_ERRORr_SET(r,d) (r).cl73_error[0] = d
#define BCMI_TSC_XGXS_CL73_ERRORr_GET(r) (r).cl73_error[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CL73_ERRORr_CL73_ERROR_TIMER_PERIODf_GET(r) (((r).cl73_error[0]) & 0xffff)
#define BCMI_TSC_XGXS_CL73_ERRORr_CL73_ERROR_TIMER_PERIODf_SET(r,f) (r).cl73_error[0]=(((r).cl73_error[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access CL73_ERROR.
 *
 */
#define BCMI_TSC_XGXS_READ_CL73_ERRORr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CL73_ERRORr,(_r._cl73_error))
#define BCMI_TSC_XGXS_WRITE_CL73_ERRORr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CL73_ERRORr,(_r._cl73_error))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL73_ERRORr BCMI_TSC_XGXS_CL73_ERRORr
#define CL73_ERRORr_SIZE BCMI_TSC_XGXS_CL73_ERRORr_SIZE
typedef BCMI_TSC_XGXS_CL73_ERRORr_t CL73_ERRORr_t;
#define CL73_ERRORr_CLR BCMI_TSC_XGXS_CL73_ERRORr_CLR
#define CL73_ERRORr_SET BCMI_TSC_XGXS_CL73_ERRORr_SET
#define CL73_ERRORr_GET BCMI_TSC_XGXS_CL73_ERRORr_GET
#define CL73_ERRORr_CL73_ERROR_TIMER_PERIODf_GET BCMI_TSC_XGXS_CL73_ERRORr_CL73_ERROR_TIMER_PERIODf_GET
#define CL73_ERRORr_CL73_ERROR_TIMER_PERIODf_SET BCMI_TSC_XGXS_CL73_ERRORr_CL73_ERROR_TIMER_PERIODf_SET
#define READ_CL73_ERRORr BCMI_TSC_XGXS_READ_CL73_ERRORr
#define WRITE_CL73_ERRORr BCMI_TSC_XGXS_WRITE_CL73_ERRORr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CL73_ERRORr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CL73_DME_LOCK
 * BLOCKS:   AN_X1_TIMERS
 * REGADDR:  0x9255
 * DESC:     CL73 PARALLEL-DETECT DME-CLOCK TIMER: 00000000
 * SIZE:     32
 * FIELDS:
 *     PD_DME_LOCK_TIMER_PERIOD 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CL73_DME_LOCKr (0x00109255 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CL73_DME_LOCKr_SIZE 4

/*
 * This structure should be used to declare and program CL73_DME_LOCK.
 *
 */
typedef union BCMI_TSC_XGXS_CL73_DME_LOCKr_s {
	uint32_t v[1];
	uint32_t cl73_dme_lock[1];
	uint32_t _cl73_dme_lock;
} BCMI_TSC_XGXS_CL73_DME_LOCKr_t;

#define BCMI_TSC_XGXS_CL73_DME_LOCKr_CLR(r) (r).cl73_dme_lock[0] = 0
#define BCMI_TSC_XGXS_CL73_DME_LOCKr_SET(r,d) (r).cl73_dme_lock[0] = d
#define BCMI_TSC_XGXS_CL73_DME_LOCKr_GET(r) (r).cl73_dme_lock[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CL73_DME_LOCKr_PD_DME_LOCK_TIMER_PERIODf_GET(r) (((r).cl73_dme_lock[0]) & 0xffff)
#define BCMI_TSC_XGXS_CL73_DME_LOCKr_PD_DME_LOCK_TIMER_PERIODf_SET(r,f) (r).cl73_dme_lock[0]=(((r).cl73_dme_lock[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access CL73_DME_LOCK.
 *
 */
#define BCMI_TSC_XGXS_READ_CL73_DME_LOCKr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CL73_DME_LOCKr,(_r._cl73_dme_lock))
#define BCMI_TSC_XGXS_WRITE_CL73_DME_LOCKr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CL73_DME_LOCKr,(_r._cl73_dme_lock))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL73_DME_LOCKr BCMI_TSC_XGXS_CL73_DME_LOCKr
#define CL73_DME_LOCKr_SIZE BCMI_TSC_XGXS_CL73_DME_LOCKr_SIZE
typedef BCMI_TSC_XGXS_CL73_DME_LOCKr_t CL73_DME_LOCKr_t;
#define CL73_DME_LOCKr_CLR BCMI_TSC_XGXS_CL73_DME_LOCKr_CLR
#define CL73_DME_LOCKr_SET BCMI_TSC_XGXS_CL73_DME_LOCKr_SET
#define CL73_DME_LOCKr_GET BCMI_TSC_XGXS_CL73_DME_LOCKr_GET
#define CL73_DME_LOCKr_PD_DME_LOCK_TIMER_PERIODf_GET BCMI_TSC_XGXS_CL73_DME_LOCKr_PD_DME_LOCK_TIMER_PERIODf_GET
#define CL73_DME_LOCKr_PD_DME_LOCK_TIMER_PERIODf_SET BCMI_TSC_XGXS_CL73_DME_LOCKr_PD_DME_LOCK_TIMER_PERIODf_SET
#define READ_CL73_DME_LOCKr BCMI_TSC_XGXS_READ_CL73_DME_LOCKr
#define WRITE_CL73_DME_LOCKr BCMI_TSC_XGXS_WRITE_CL73_DME_LOCKr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CL73_DME_LOCKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  LINK_UP
 * BLOCKS:   AN_X1_TIMERS
 * REGADDR:  0x9256
 * DESC:     CL73 LINK-UP TIMER: 00000000
 * SIZE:     32
 * FIELDS:
 *     CL73_LINK_UP_TIMER_PERIOD 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_LINK_UPr (0x00109256 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_LINK_UPr_SIZE 4

/*
 * This structure should be used to declare and program LINK_UP.
 *
 */
typedef union BCMI_TSC_XGXS_LINK_UPr_s {
	uint32_t v[1];
	uint32_t link_up[1];
	uint32_t _link_up;
} BCMI_TSC_XGXS_LINK_UPr_t;

#define BCMI_TSC_XGXS_LINK_UPr_CLR(r) (r).link_up[0] = 0
#define BCMI_TSC_XGXS_LINK_UPr_SET(r,d) (r).link_up[0] = d
#define BCMI_TSC_XGXS_LINK_UPr_GET(r) (r).link_up[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_LINK_UPr_CL73_LINK_UP_TIMER_PERIODf_GET(r) (((r).link_up[0]) & 0xffff)
#define BCMI_TSC_XGXS_LINK_UPr_CL73_LINK_UP_TIMER_PERIODf_SET(r,f) (r).link_up[0]=(((r).link_up[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access LINK_UP.
 *
 */
#define BCMI_TSC_XGXS_READ_LINK_UPr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_LINK_UPr,(_r._link_up))
#define BCMI_TSC_XGXS_WRITE_LINK_UPr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_LINK_UPr,(_r._link_up))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define LINK_UPr BCMI_TSC_XGXS_LINK_UPr
#define LINK_UPr_SIZE BCMI_TSC_XGXS_LINK_UPr_SIZE
typedef BCMI_TSC_XGXS_LINK_UPr_t LINK_UPr_t;
#define LINK_UPr_CLR BCMI_TSC_XGXS_LINK_UPr_CLR
#define LINK_UPr_SET BCMI_TSC_XGXS_LINK_UPr_SET
#define LINK_UPr_GET BCMI_TSC_XGXS_LINK_UPr_GET
#define LINK_UPr_CL73_LINK_UP_TIMER_PERIODf_GET BCMI_TSC_XGXS_LINK_UPr_CL73_LINK_UP_TIMER_PERIODf_GET
#define LINK_UPr_CL73_LINK_UP_TIMER_PERIODf_SET BCMI_TSC_XGXS_LINK_UPr_CL73_LINK_UP_TIMER_PERIODf_SET
#define READ_LINK_UPr BCMI_TSC_XGXS_READ_LINK_UPr
#define WRITE_LINK_UPr BCMI_TSC_XGXS_WRITE_LINK_UPr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_LINK_UPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  LINK_FAIL_INHIBIT_TIMER_CL72
 * BLOCKS:   AN_X1_TIMERS
 * REGADDR:  0x9257
 * DESC:     TIMER FOR QUALIFYING A LINK_STATUS: 00000000
 * SIZE:     32
 * FIELDS:
 *     LINK_FAIL_INHIBIT_TIMER_CL72_PERIOD 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_LINK_FAIL_INHIBIT_TIMER_CL72r (0x00109257 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_LINK_FAIL_INHIBIT_TIMER_CL72r_SIZE 4

/*
 * This structure should be used to declare and program LINK_FAIL_INHIBIT_TIMER_CL72.
 *
 */
typedef union BCMI_TSC_XGXS_LINK_FAIL_INHIBIT_TIMER_CL72r_s {
	uint32_t v[1];
	uint32_t link_fail_inhibit_timer_cl72[1];
	uint32_t _link_fail_inhibit_timer_cl72;
} BCMI_TSC_XGXS_LINK_FAIL_INHIBIT_TIMER_CL72r_t;

#define BCMI_TSC_XGXS_LINK_FAIL_INHIBIT_TIMER_CL72r_CLR(r) (r).link_fail_inhibit_timer_cl72[0] = 0
#define BCMI_TSC_XGXS_LINK_FAIL_INHIBIT_TIMER_CL72r_SET(r,d) (r).link_fail_inhibit_timer_cl72[0] = d
#define BCMI_TSC_XGXS_LINK_FAIL_INHIBIT_TIMER_CL72r_GET(r) (r).link_fail_inhibit_timer_cl72[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_LINK_FAIL_INHIBIT_TIMER_CL72r_LINK_FAIL_INHIBIT_TIMER_CL72_PERIODf_GET(r) (((r).link_fail_inhibit_timer_cl72[0]) & 0xffff)
#define BCMI_TSC_XGXS_LINK_FAIL_INHIBIT_TIMER_CL72r_LINK_FAIL_INHIBIT_TIMER_CL72_PERIODf_SET(r,f) (r).link_fail_inhibit_timer_cl72[0]=(((r).link_fail_inhibit_timer_cl72[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access LINK_FAIL_INHIBIT_TIMER_CL72.
 *
 */
#define BCMI_TSC_XGXS_READ_LINK_FAIL_INHIBIT_TIMER_CL72r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_LINK_FAIL_INHIBIT_TIMER_CL72r,(_r._link_fail_inhibit_timer_cl72))
#define BCMI_TSC_XGXS_WRITE_LINK_FAIL_INHIBIT_TIMER_CL72r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_LINK_FAIL_INHIBIT_TIMER_CL72r,(_r._link_fail_inhibit_timer_cl72))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define LINK_FAIL_INHIBIT_TIMER_CL72r BCMI_TSC_XGXS_LINK_FAIL_INHIBIT_TIMER_CL72r
#define LINK_FAIL_INHIBIT_TIMER_CL72r_SIZE BCMI_TSC_XGXS_LINK_FAIL_INHIBIT_TIMER_CL72r_SIZE
typedef BCMI_TSC_XGXS_LINK_FAIL_INHIBIT_TIMER_CL72r_t LINK_FAIL_INHIBIT_TIMER_CL72r_t;
#define LINK_FAIL_INHIBIT_TIMER_CL72r_CLR BCMI_TSC_XGXS_LINK_FAIL_INHIBIT_TIMER_CL72r_CLR
#define LINK_FAIL_INHIBIT_TIMER_CL72r_SET BCMI_TSC_XGXS_LINK_FAIL_INHIBIT_TIMER_CL72r_SET
#define LINK_FAIL_INHIBIT_TIMER_CL72r_GET BCMI_TSC_XGXS_LINK_FAIL_INHIBIT_TIMER_CL72r_GET
#define LINK_FAIL_INHIBIT_TIMER_CL72r_LINK_FAIL_INHIBIT_TIMER_CL72_PERIODf_GET BCMI_TSC_XGXS_LINK_FAIL_INHIBIT_TIMER_CL72r_LINK_FAIL_INHIBIT_TIMER_CL72_PERIODf_GET
#define LINK_FAIL_INHIBIT_TIMER_CL72r_LINK_FAIL_INHIBIT_TIMER_CL72_PERIODf_SET BCMI_TSC_XGXS_LINK_FAIL_INHIBIT_TIMER_CL72r_LINK_FAIL_INHIBIT_TIMER_CL72_PERIODf_SET
#define READ_LINK_FAIL_INHIBIT_TIMER_CL72r BCMI_TSC_XGXS_READ_LINK_FAIL_INHIBIT_TIMER_CL72r
#define WRITE_LINK_FAIL_INHIBIT_TIMER_CL72r BCMI_TSC_XGXS_WRITE_LINK_FAIL_INHIBIT_TIMER_CL72r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_LINK_FAIL_INHIBIT_TIMER_CL72r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  LINK_FAIL_INHIBIT_TIMER_NOT_CL72
 * BLOCKS:   AN_X1_TIMERS
 * REGADDR:  0x9258
 * DESC:     Timer FOR QUALIFYING A LINK_STATUS: 00000000
 * SIZE:     32
 * FIELDS:
 *     LINK_FAIL_INHIBIT_TIMER_NCL72_PERIOD 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_LINK_FAIL_INHIBIT_TIMER_NOT_CL72r (0x00109258 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_LINK_FAIL_INHIBIT_TIMER_NOT_CL72r_SIZE 4

/*
 * This structure should be used to declare and program LINK_FAIL_INHIBIT_TIMER_NOT_CL72.
 *
 */
typedef union BCMI_TSC_XGXS_LINK_FAIL_INHIBIT_TIMER_NOT_CL72r_s {
	uint32_t v[1];
	uint32_t link_fail_inhibit_timer_not_cl72[1];
	uint32_t _link_fail_inhibit_timer_not_cl72;
} BCMI_TSC_XGXS_LINK_FAIL_INHIBIT_TIMER_NOT_CL72r_t;

#define BCMI_TSC_XGXS_LINK_FAIL_INHIBIT_TIMER_NOT_CL72r_CLR(r) (r).link_fail_inhibit_timer_not_cl72[0] = 0
#define BCMI_TSC_XGXS_LINK_FAIL_INHIBIT_TIMER_NOT_CL72r_SET(r,d) (r).link_fail_inhibit_timer_not_cl72[0] = d
#define BCMI_TSC_XGXS_LINK_FAIL_INHIBIT_TIMER_NOT_CL72r_GET(r) (r).link_fail_inhibit_timer_not_cl72[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_LINK_FAIL_INHIBIT_TIMER_NOT_CL72r_LINK_FAIL_INHIBIT_TIMER_NCL72_PERIODf_GET(r) (((r).link_fail_inhibit_timer_not_cl72[0]) & 0xffff)
#define BCMI_TSC_XGXS_LINK_FAIL_INHIBIT_TIMER_NOT_CL72r_LINK_FAIL_INHIBIT_TIMER_NCL72_PERIODf_SET(r,f) (r).link_fail_inhibit_timer_not_cl72[0]=(((r).link_fail_inhibit_timer_not_cl72[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access LINK_FAIL_INHIBIT_TIMER_NOT_CL72.
 *
 */
#define BCMI_TSC_XGXS_READ_LINK_FAIL_INHIBIT_TIMER_NOT_CL72r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_LINK_FAIL_INHIBIT_TIMER_NOT_CL72r,(_r._link_fail_inhibit_timer_not_cl72))
#define BCMI_TSC_XGXS_WRITE_LINK_FAIL_INHIBIT_TIMER_NOT_CL72r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_LINK_FAIL_INHIBIT_TIMER_NOT_CL72r,(_r._link_fail_inhibit_timer_not_cl72))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define LINK_FAIL_INHIBIT_TIMER_NOT_CL72r BCMI_TSC_XGXS_LINK_FAIL_INHIBIT_TIMER_NOT_CL72r
#define LINK_FAIL_INHIBIT_TIMER_NOT_CL72r_SIZE BCMI_TSC_XGXS_LINK_FAIL_INHIBIT_TIMER_NOT_CL72r_SIZE
typedef BCMI_TSC_XGXS_LINK_FAIL_INHIBIT_TIMER_NOT_CL72r_t LINK_FAIL_INHIBIT_TIMER_NOT_CL72r_t;
#define LINK_FAIL_INHIBIT_TIMER_NOT_CL72r_CLR BCMI_TSC_XGXS_LINK_FAIL_INHIBIT_TIMER_NOT_CL72r_CLR
#define LINK_FAIL_INHIBIT_TIMER_NOT_CL72r_SET BCMI_TSC_XGXS_LINK_FAIL_INHIBIT_TIMER_NOT_CL72r_SET
#define LINK_FAIL_INHIBIT_TIMER_NOT_CL72r_GET BCMI_TSC_XGXS_LINK_FAIL_INHIBIT_TIMER_NOT_CL72r_GET
#define LINK_FAIL_INHIBIT_TIMER_NOT_CL72r_LINK_FAIL_INHIBIT_TIMER_NCL72_PERIODf_GET BCMI_TSC_XGXS_LINK_FAIL_INHIBIT_TIMER_NOT_CL72r_LINK_FAIL_INHIBIT_TIMER_NCL72_PERIODf_GET
#define LINK_FAIL_INHIBIT_TIMER_NOT_CL72r_LINK_FAIL_INHIBIT_TIMER_NCL72_PERIODf_SET BCMI_TSC_XGXS_LINK_FAIL_INHIBIT_TIMER_NOT_CL72r_LINK_FAIL_INHIBIT_TIMER_NCL72_PERIODf_SET
#define READ_LINK_FAIL_INHIBIT_TIMER_NOT_CL72r BCMI_TSC_XGXS_READ_LINK_FAIL_INHIBIT_TIMER_NOT_CL72r
#define WRITE_LINK_FAIL_INHIBIT_TIMER_NOT_CL72r BCMI_TSC_XGXS_WRITE_LINK_FAIL_INHIBIT_TIMER_NOT_CL72r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_LINK_FAIL_INHIBIT_TIMER_NOT_CL72r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  PD_SD_TIMER
 * BLOCKS:   AN_X1_TIMERS
 * REGADDR:  0x9259
 * DESC:     PARALLEL-DETECT SIGNAL DETECT TIMER: 00000000
 * SIZE:     32
 * FIELDS:
 *     PD_SD_TIMER_PERIOD 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_PD_SD_TIMERr (0x00109259 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_PD_SD_TIMERr_SIZE 4

/*
 * This structure should be used to declare and program PD_SD_TIMER.
 *
 */
typedef union BCMI_TSC_XGXS_PD_SD_TIMERr_s {
	uint32_t v[1];
	uint32_t pd_sd_timer[1];
	uint32_t _pd_sd_timer;
} BCMI_TSC_XGXS_PD_SD_TIMERr_t;

#define BCMI_TSC_XGXS_PD_SD_TIMERr_CLR(r) (r).pd_sd_timer[0] = 0
#define BCMI_TSC_XGXS_PD_SD_TIMERr_SET(r,d) (r).pd_sd_timer[0] = d
#define BCMI_TSC_XGXS_PD_SD_TIMERr_GET(r) (r).pd_sd_timer[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_PD_SD_TIMERr_PD_SD_TIMER_PERIODf_GET(r) (((r).pd_sd_timer[0]) & 0xffff)
#define BCMI_TSC_XGXS_PD_SD_TIMERr_PD_SD_TIMER_PERIODf_SET(r,f) (r).pd_sd_timer[0]=(((r).pd_sd_timer[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PD_SD_TIMER.
 *
 */
#define BCMI_TSC_XGXS_READ_PD_SD_TIMERr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_PD_SD_TIMERr,(_r._pd_sd_timer))
#define BCMI_TSC_XGXS_WRITE_PD_SD_TIMERr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_PD_SD_TIMERr,(_r._pd_sd_timer))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PD_SD_TIMERr BCMI_TSC_XGXS_PD_SD_TIMERr
#define PD_SD_TIMERr_SIZE BCMI_TSC_XGXS_PD_SD_TIMERr_SIZE
typedef BCMI_TSC_XGXS_PD_SD_TIMERr_t PD_SD_TIMERr_t;
#define PD_SD_TIMERr_CLR BCMI_TSC_XGXS_PD_SD_TIMERr_CLR
#define PD_SD_TIMERr_SET BCMI_TSC_XGXS_PD_SD_TIMERr_SET
#define PD_SD_TIMERr_GET BCMI_TSC_XGXS_PD_SD_TIMERr_GET
#define PD_SD_TIMERr_PD_SD_TIMER_PERIODf_GET BCMI_TSC_XGXS_PD_SD_TIMERr_PD_SD_TIMER_PERIODf_GET
#define PD_SD_TIMERr_PD_SD_TIMER_PERIODf_SET BCMI_TSC_XGXS_PD_SD_TIMERr_PD_SD_TIMER_PERIODf_SET
#define READ_PD_SD_TIMERr BCMI_TSC_XGXS_READ_PD_SD_TIMERr
#define WRITE_PD_SD_TIMERr BCMI_TSC_XGXS_WRITE_PD_SD_TIMERr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_PD_SD_TIMERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CL72_MAX_WAIT_TIMER
 * BLOCKS:   AN_X1_TIMERS
 * REGADDR:  0x925a
 * DESC:     MAXIMUM TRAINING TIME: 00000000
 * SIZE:     32
 * FIELDS:
 *     CL72_MAX_WAIT_TIMER_PERIOD 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CL72_MAX_WAIT_TIMERr (0x0010925a | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CL72_MAX_WAIT_TIMERr_SIZE 4

/*
 * This structure should be used to declare and program CL72_MAX_WAIT_TIMER.
 *
 */
typedef union BCMI_TSC_XGXS_CL72_MAX_WAIT_TIMERr_s {
	uint32_t v[1];
	uint32_t cl72_max_wait_timer[1];
	uint32_t _cl72_max_wait_timer;
} BCMI_TSC_XGXS_CL72_MAX_WAIT_TIMERr_t;

#define BCMI_TSC_XGXS_CL72_MAX_WAIT_TIMERr_CLR(r) (r).cl72_max_wait_timer[0] = 0
#define BCMI_TSC_XGXS_CL72_MAX_WAIT_TIMERr_SET(r,d) (r).cl72_max_wait_timer[0] = d
#define BCMI_TSC_XGXS_CL72_MAX_WAIT_TIMERr_GET(r) (r).cl72_max_wait_timer[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CL72_MAX_WAIT_TIMERr_CL72_MAX_WAIT_TIMER_PERIODf_GET(r) (((r).cl72_max_wait_timer[0]) & 0xffff)
#define BCMI_TSC_XGXS_CL72_MAX_WAIT_TIMERr_CL72_MAX_WAIT_TIMER_PERIODf_SET(r,f) (r).cl72_max_wait_timer[0]=(((r).cl72_max_wait_timer[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access CL72_MAX_WAIT_TIMER.
 *
 */
#define BCMI_TSC_XGXS_READ_CL72_MAX_WAIT_TIMERr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CL72_MAX_WAIT_TIMERr,(_r._cl72_max_wait_timer))
#define BCMI_TSC_XGXS_WRITE_CL72_MAX_WAIT_TIMERr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CL72_MAX_WAIT_TIMERr,(_r._cl72_max_wait_timer))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL72_MAX_WAIT_TIMERr BCMI_TSC_XGXS_CL72_MAX_WAIT_TIMERr
#define CL72_MAX_WAIT_TIMERr_SIZE BCMI_TSC_XGXS_CL72_MAX_WAIT_TIMERr_SIZE
typedef BCMI_TSC_XGXS_CL72_MAX_WAIT_TIMERr_t CL72_MAX_WAIT_TIMERr_t;
#define CL72_MAX_WAIT_TIMERr_CLR BCMI_TSC_XGXS_CL72_MAX_WAIT_TIMERr_CLR
#define CL72_MAX_WAIT_TIMERr_SET BCMI_TSC_XGXS_CL72_MAX_WAIT_TIMERr_SET
#define CL72_MAX_WAIT_TIMERr_GET BCMI_TSC_XGXS_CL72_MAX_WAIT_TIMERr_GET
#define CL72_MAX_WAIT_TIMERr_CL72_MAX_WAIT_TIMER_PERIODf_GET BCMI_TSC_XGXS_CL72_MAX_WAIT_TIMERr_CL72_MAX_WAIT_TIMER_PERIODf_GET
#define CL72_MAX_WAIT_TIMERr_CL72_MAX_WAIT_TIMER_PERIODf_SET BCMI_TSC_XGXS_CL72_MAX_WAIT_TIMERr_CL72_MAX_WAIT_TIMER_PERIODf_SET
#define READ_CL72_MAX_WAIT_TIMERr BCMI_TSC_XGXS_READ_CL72_MAX_WAIT_TIMERr
#define WRITE_CL72_MAX_WAIT_TIMERr BCMI_TSC_XGXS_WRITE_CL72_MAX_WAIT_TIMERr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CL72_MAX_WAIT_TIMERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CL72_WAIT_TIMER
 * BLOCKS:   AN_X1_TIMERS
 * REGADDR:  0x925b
 * DESC:     PERIOD TO KEEP TRANSIMING FRAMES: 00000000
 * SIZE:     32
 * FIELDS:
 *     CL72_WAIT_TIMER_PERIOD 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CL72_WAIT_TIMERr (0x0010925b | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CL72_WAIT_TIMERr_SIZE 4

/*
 * This structure should be used to declare and program CL72_WAIT_TIMER.
 *
 */
typedef union BCMI_TSC_XGXS_CL72_WAIT_TIMERr_s {
	uint32_t v[1];
	uint32_t cl72_wait_timer[1];
	uint32_t _cl72_wait_timer;
} BCMI_TSC_XGXS_CL72_WAIT_TIMERr_t;

#define BCMI_TSC_XGXS_CL72_WAIT_TIMERr_CLR(r) (r).cl72_wait_timer[0] = 0
#define BCMI_TSC_XGXS_CL72_WAIT_TIMERr_SET(r,d) (r).cl72_wait_timer[0] = d
#define BCMI_TSC_XGXS_CL72_WAIT_TIMERr_GET(r) (r).cl72_wait_timer[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CL72_WAIT_TIMERr_RESERVED0f_GET(r) ((((r).cl72_wait_timer[0]) >> 9) & 0x7f)
#define BCMI_TSC_XGXS_CL72_WAIT_TIMERr_RESERVED0f_SET(r,f) (r).cl72_wait_timer[0]=(((r).cl72_wait_timer[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))
#define BCMI_TSC_XGXS_CL72_WAIT_TIMERr_CL72_WAIT_TIMER_PERIODf_GET(r) (((r).cl72_wait_timer[0]) & 0x1ff)
#define BCMI_TSC_XGXS_CL72_WAIT_TIMERr_CL72_WAIT_TIMER_PERIODf_SET(r,f) (r).cl72_wait_timer[0]=(((r).cl72_wait_timer[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))

/*
 * These macros can be used to access CL72_WAIT_TIMER.
 *
 */
#define BCMI_TSC_XGXS_READ_CL72_WAIT_TIMERr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CL72_WAIT_TIMERr,(_r._cl72_wait_timer))
#define BCMI_TSC_XGXS_WRITE_CL72_WAIT_TIMERr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CL72_WAIT_TIMERr,(_r._cl72_wait_timer))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL72_WAIT_TIMERr BCMI_TSC_XGXS_CL72_WAIT_TIMERr
#define CL72_WAIT_TIMERr_SIZE BCMI_TSC_XGXS_CL72_WAIT_TIMERr_SIZE
typedef BCMI_TSC_XGXS_CL72_WAIT_TIMERr_t CL72_WAIT_TIMERr_t;
#define CL72_WAIT_TIMERr_CLR BCMI_TSC_XGXS_CL72_WAIT_TIMERr_CLR
#define CL72_WAIT_TIMERr_SET BCMI_TSC_XGXS_CL72_WAIT_TIMERr_SET
#define CL72_WAIT_TIMERr_GET BCMI_TSC_XGXS_CL72_WAIT_TIMERr_GET
#define CL72_WAIT_TIMERr_RESERVED0f_GET BCMI_TSC_XGXS_CL72_WAIT_TIMERr_RESERVED0f_GET
#define CL72_WAIT_TIMERr_RESERVED0f_SET BCMI_TSC_XGXS_CL72_WAIT_TIMERr_RESERVED0f_SET
#define CL72_WAIT_TIMERr_CL72_WAIT_TIMER_PERIODf_GET BCMI_TSC_XGXS_CL72_WAIT_TIMERr_CL72_WAIT_TIMER_PERIODf_GET
#define CL72_WAIT_TIMERr_CL72_WAIT_TIMER_PERIODf_SET BCMI_TSC_XGXS_CL72_WAIT_TIMERr_CL72_WAIT_TIMER_PERIODf_SET
#define READ_CL72_WAIT_TIMERr BCMI_TSC_XGXS_READ_CL72_WAIT_TIMERr
#define WRITE_CL72_WAIT_TIMERr BCMI_TSC_XGXS_WRITE_CL72_WAIT_TIMERr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CL72_WAIT_TIMERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  IGNORE_LINK_TIMER
 * BLOCKS:   AN_X1_TIMERS
 * REGADDR:  0x925c
 * DESC:     PERIOD TO IGNORE THE LINK: 00000000
 * SIZE:     32
 * FIELDS:
 *     IGNORE_LINK_TIMER_PERIOD 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_IGNORE_LINK_TIMERr (0x0010925c | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_IGNORE_LINK_TIMERr_SIZE 4

/*
 * This structure should be used to declare and program IGNORE_LINK_TIMER.
 *
 */
typedef union BCMI_TSC_XGXS_IGNORE_LINK_TIMERr_s {
	uint32_t v[1];
	uint32_t ignore_link_timer[1];
	uint32_t _ignore_link_timer;
} BCMI_TSC_XGXS_IGNORE_LINK_TIMERr_t;

#define BCMI_TSC_XGXS_IGNORE_LINK_TIMERr_CLR(r) (r).ignore_link_timer[0] = 0
#define BCMI_TSC_XGXS_IGNORE_LINK_TIMERr_SET(r,d) (r).ignore_link_timer[0] = d
#define BCMI_TSC_XGXS_IGNORE_LINK_TIMERr_GET(r) (r).ignore_link_timer[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_IGNORE_LINK_TIMERr_IGNORE_LINK_TIMER_PERIODf_GET(r) (((r).ignore_link_timer[0]) & 0xffff)
#define BCMI_TSC_XGXS_IGNORE_LINK_TIMERr_IGNORE_LINK_TIMER_PERIODf_SET(r,f) (r).ignore_link_timer[0]=(((r).ignore_link_timer[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access IGNORE_LINK_TIMER.
 *
 */
#define BCMI_TSC_XGXS_READ_IGNORE_LINK_TIMERr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_IGNORE_LINK_TIMERr,(_r._ignore_link_timer))
#define BCMI_TSC_XGXS_WRITE_IGNORE_LINK_TIMERr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_IGNORE_LINK_TIMERr,(_r._ignore_link_timer))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define IGNORE_LINK_TIMERr BCMI_TSC_XGXS_IGNORE_LINK_TIMERr
#define IGNORE_LINK_TIMERr_SIZE BCMI_TSC_XGXS_IGNORE_LINK_TIMERr_SIZE
typedef BCMI_TSC_XGXS_IGNORE_LINK_TIMERr_t IGNORE_LINK_TIMERr_t;
#define IGNORE_LINK_TIMERr_CLR BCMI_TSC_XGXS_IGNORE_LINK_TIMERr_CLR
#define IGNORE_LINK_TIMERr_SET BCMI_TSC_XGXS_IGNORE_LINK_TIMERr_SET
#define IGNORE_LINK_TIMERr_GET BCMI_TSC_XGXS_IGNORE_LINK_TIMERr_GET
#define IGNORE_LINK_TIMERr_IGNORE_LINK_TIMER_PERIODf_GET BCMI_TSC_XGXS_IGNORE_LINK_TIMERr_IGNORE_LINK_TIMER_PERIODf_GET
#define IGNORE_LINK_TIMERr_IGNORE_LINK_TIMER_PERIODf_SET BCMI_TSC_XGXS_IGNORE_LINK_TIMERr_IGNORE_LINK_TIMER_PERIODf_SET
#define READ_IGNORE_LINK_TIMERr BCMI_TSC_XGXS_READ_IGNORE_LINK_TIMERr
#define WRITE_IGNORE_LINK_TIMERr BCMI_TSC_XGXS_WRITE_IGNORE_LINK_TIMERr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_IGNORE_LINK_TIMERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  DME_PAGE_TIMER
 * BLOCKS:   AN_X1_TIMERS
 * REGADDR:  0x925d
 * DESC:     DME PAGE TIMERS: 00000000
 * SIZE:     32
 * FIELDS:
 *     CL73_PAGE_TEST_MIN_TIMER 
 *     CL73_PAGE_TEST_MAX_TIMER 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_DME_PAGE_TIMERr (0x0010925d | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_DME_PAGE_TIMERr_SIZE 4

/*
 * This structure should be used to declare and program DME_PAGE_TIMER.
 *
 */
typedef union BCMI_TSC_XGXS_DME_PAGE_TIMERr_s {
	uint32_t v[1];
	uint32_t dme_page_timer[1];
	uint32_t _dme_page_timer;
} BCMI_TSC_XGXS_DME_PAGE_TIMERr_t;

#define BCMI_TSC_XGXS_DME_PAGE_TIMERr_CLR(r) (r).dme_page_timer[0] = 0
#define BCMI_TSC_XGXS_DME_PAGE_TIMERr_SET(r,d) (r).dme_page_timer[0] = d
#define BCMI_TSC_XGXS_DME_PAGE_TIMERr_GET(r) (r).dme_page_timer[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_DME_PAGE_TIMERr_RESERVED0f_GET(r) ((((r).dme_page_timer[0]) >> 14) & 0x3)
#define BCMI_TSC_XGXS_DME_PAGE_TIMERr_RESERVED0f_SET(r,f) (r).dme_page_timer[0]=(((r).dme_page_timer[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCMI_TSC_XGXS_DME_PAGE_TIMERr_CL73_PAGE_TEST_MAX_TIMERf_GET(r) ((((r).dme_page_timer[0]) >> 7) & 0x7f)
#define BCMI_TSC_XGXS_DME_PAGE_TIMERr_CL73_PAGE_TEST_MAX_TIMERf_SET(r,f) (r).dme_page_timer[0]=(((r).dme_page_timer[0] & ~((uint32_t)0x7f << 7)) | ((((uint32_t)f) & 0x7f) << 7))
#define BCMI_TSC_XGXS_DME_PAGE_TIMERr_CL73_PAGE_TEST_MIN_TIMERf_GET(r) (((r).dme_page_timer[0]) & 0x7f)
#define BCMI_TSC_XGXS_DME_PAGE_TIMERr_CL73_PAGE_TEST_MIN_TIMERf_SET(r,f) (r).dme_page_timer[0]=(((r).dme_page_timer[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f))

/*
 * These macros can be used to access DME_PAGE_TIMER.
 *
 */
#define BCMI_TSC_XGXS_READ_DME_PAGE_TIMERr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_DME_PAGE_TIMERr,(_r._dme_page_timer))
#define BCMI_TSC_XGXS_WRITE_DME_PAGE_TIMERr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_DME_PAGE_TIMERr,(_r._dme_page_timer))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DME_PAGE_TIMERr BCMI_TSC_XGXS_DME_PAGE_TIMERr
#define DME_PAGE_TIMERr_SIZE BCMI_TSC_XGXS_DME_PAGE_TIMERr_SIZE
typedef BCMI_TSC_XGXS_DME_PAGE_TIMERr_t DME_PAGE_TIMERr_t;
#define DME_PAGE_TIMERr_CLR BCMI_TSC_XGXS_DME_PAGE_TIMERr_CLR
#define DME_PAGE_TIMERr_SET BCMI_TSC_XGXS_DME_PAGE_TIMERr_SET
#define DME_PAGE_TIMERr_GET BCMI_TSC_XGXS_DME_PAGE_TIMERr_GET
#define DME_PAGE_TIMERr_RESERVED0f_GET BCMI_TSC_XGXS_DME_PAGE_TIMERr_RESERVED0f_GET
#define DME_PAGE_TIMERr_RESERVED0f_SET BCMI_TSC_XGXS_DME_PAGE_TIMERr_RESERVED0f_SET
#define DME_PAGE_TIMERr_CL73_PAGE_TEST_MAX_TIMERf_GET BCMI_TSC_XGXS_DME_PAGE_TIMERr_CL73_PAGE_TEST_MAX_TIMERf_GET
#define DME_PAGE_TIMERr_CL73_PAGE_TEST_MAX_TIMERf_SET BCMI_TSC_XGXS_DME_PAGE_TIMERr_CL73_PAGE_TEST_MAX_TIMERf_SET
#define DME_PAGE_TIMERr_CL73_PAGE_TEST_MIN_TIMERf_GET BCMI_TSC_XGXS_DME_PAGE_TIMERr_CL73_PAGE_TEST_MIN_TIMERf_GET
#define DME_PAGE_TIMERr_CL73_PAGE_TEST_MIN_TIMERf_SET BCMI_TSC_XGXS_DME_PAGE_TIMERr_CL73_PAGE_TEST_MIN_TIMERf_SET
#define READ_DME_PAGE_TIMERr BCMI_TSC_XGXS_READ_DME_PAGE_TIMERr
#define WRITE_DME_PAGE_TIMERr BCMI_TSC_XGXS_WRITE_DME_PAGE_TIMERr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_DME_PAGE_TIMERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  SGMII_CL73_TIMER_TYPE
 * BLOCKS:   AN_X1_TIMERS
 * REGADDR:  0x925e
 * DESC:     CL73 SGMII TIMER: 00000000
 * SIZE:     32
 * FIELDS:
 *     SGMII_TIMER      
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_SGMII_CL73_TIMER_TYPEr (0x0010925e | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_SGMII_CL73_TIMER_TYPEr_SIZE 4

/*
 * This structure should be used to declare and program SGMII_CL73_TIMER_TYPE.
 *
 */
typedef union BCMI_TSC_XGXS_SGMII_CL73_TIMER_TYPEr_s {
	uint32_t v[1];
	uint32_t sgmii_cl73_timer_type[1];
	uint32_t _sgmii_cl73_timer_type;
} BCMI_TSC_XGXS_SGMII_CL73_TIMER_TYPEr_t;

#define BCMI_TSC_XGXS_SGMII_CL73_TIMER_TYPEr_CLR(r) (r).sgmii_cl73_timer_type[0] = 0
#define BCMI_TSC_XGXS_SGMII_CL73_TIMER_TYPEr_SET(r,d) (r).sgmii_cl73_timer_type[0] = d
#define BCMI_TSC_XGXS_SGMII_CL73_TIMER_TYPEr_GET(r) (r).sgmii_cl73_timer_type[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_SGMII_CL73_TIMER_TYPEr_SGMII_TIMERf_GET(r) (((r).sgmii_cl73_timer_type[0]) & 0xffff)
#define BCMI_TSC_XGXS_SGMII_CL73_TIMER_TYPEr_SGMII_TIMERf_SET(r,f) (r).sgmii_cl73_timer_type[0]=(((r).sgmii_cl73_timer_type[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access SGMII_CL73_TIMER_TYPE.
 *
 */
#define BCMI_TSC_XGXS_READ_SGMII_CL73_TIMER_TYPEr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_SGMII_CL73_TIMER_TYPEr,(_r._sgmii_cl73_timer_type))
#define BCMI_TSC_XGXS_WRITE_SGMII_CL73_TIMER_TYPEr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_SGMII_CL73_TIMER_TYPEr,(_r._sgmii_cl73_timer_type))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SGMII_CL73_TIMER_TYPEr BCMI_TSC_XGXS_SGMII_CL73_TIMER_TYPEr
#define SGMII_CL73_TIMER_TYPEr_SIZE BCMI_TSC_XGXS_SGMII_CL73_TIMER_TYPEr_SIZE
typedef BCMI_TSC_XGXS_SGMII_CL73_TIMER_TYPEr_t SGMII_CL73_TIMER_TYPEr_t;
#define SGMII_CL73_TIMER_TYPEr_CLR BCMI_TSC_XGXS_SGMII_CL73_TIMER_TYPEr_CLR
#define SGMII_CL73_TIMER_TYPEr_SET BCMI_TSC_XGXS_SGMII_CL73_TIMER_TYPEr_SET
#define SGMII_CL73_TIMER_TYPEr_GET BCMI_TSC_XGXS_SGMII_CL73_TIMER_TYPEr_GET
#define SGMII_CL73_TIMER_TYPEr_SGMII_TIMERf_GET BCMI_TSC_XGXS_SGMII_CL73_TIMER_TYPEr_SGMII_TIMERf_GET
#define SGMII_CL73_TIMER_TYPEr_SGMII_TIMERf_SET BCMI_TSC_XGXS_SGMII_CL73_TIMER_TYPEr_SGMII_TIMERf_SET
#define READ_SGMII_CL73_TIMER_TYPEr BCMI_TSC_XGXS_READ_SGMII_CL73_TIMER_TYPEr
#define WRITE_SGMII_CL73_TIMER_TYPEr BCMI_TSC_XGXS_WRITE_SGMII_CL73_TIMER_TYPEr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_SGMII_CL73_TIMER_TYPEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  TX_X2_MLD_SWAP_COUNT
 * BLOCKS:   TX_X2_CONTROL0
 * REGADDR:  0xa000
 * DESC:     Swap Count register: 00000000
 * SIZE:     32
 * FIELDS:
 *     MLD_SWAP_COUNT   
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_TX_X2_MLD_SWAP_COUNTr (0x0020a000 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_TX_X2_MLD_SWAP_COUNTr_SIZE 4

/*
 * This structure should be used to declare and program TX_X2_MLD_SWAP_COUNT.
 *
 */
typedef union BCMI_TSC_XGXS_TX_X2_MLD_SWAP_COUNTr_s {
	uint32_t v[1];
	uint32_t tx_x2_mld_swap_count[1];
	uint32_t _tx_x2_mld_swap_count;
} BCMI_TSC_XGXS_TX_X2_MLD_SWAP_COUNTr_t;

#define BCMI_TSC_XGXS_TX_X2_MLD_SWAP_COUNTr_CLR(r) (r).tx_x2_mld_swap_count[0] = 0
#define BCMI_TSC_XGXS_TX_X2_MLD_SWAP_COUNTr_SET(r,d) (r).tx_x2_mld_swap_count[0] = d
#define BCMI_TSC_XGXS_TX_X2_MLD_SWAP_COUNTr_GET(r) (r).tx_x2_mld_swap_count[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_TX_X2_MLD_SWAP_COUNTr_MLD_SWAP_COUNTf_GET(r) (((r).tx_x2_mld_swap_count[0]) & 0xffff)
#define BCMI_TSC_XGXS_TX_X2_MLD_SWAP_COUNTr_MLD_SWAP_COUNTf_SET(r,f) (r).tx_x2_mld_swap_count[0]=(((r).tx_x2_mld_swap_count[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access TX_X2_MLD_SWAP_COUNT.
 *
 */
#define BCMI_TSC_XGXS_READ_TX_X2_MLD_SWAP_COUNTr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_TX_X2_MLD_SWAP_COUNTr,(_r._tx_x2_mld_swap_count))
#define BCMI_TSC_XGXS_WRITE_TX_X2_MLD_SWAP_COUNTr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_TX_X2_MLD_SWAP_COUNTr,(_r._tx_x2_mld_swap_count))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TX_X2_MLD_SWAP_COUNTr BCMI_TSC_XGXS_TX_X2_MLD_SWAP_COUNTr
#define TX_X2_MLD_SWAP_COUNTr_SIZE BCMI_TSC_XGXS_TX_X2_MLD_SWAP_COUNTr_SIZE
typedef BCMI_TSC_XGXS_TX_X2_MLD_SWAP_COUNTr_t TX_X2_MLD_SWAP_COUNTr_t;
#define TX_X2_MLD_SWAP_COUNTr_CLR BCMI_TSC_XGXS_TX_X2_MLD_SWAP_COUNTr_CLR
#define TX_X2_MLD_SWAP_COUNTr_SET BCMI_TSC_XGXS_TX_X2_MLD_SWAP_COUNTr_SET
#define TX_X2_MLD_SWAP_COUNTr_GET BCMI_TSC_XGXS_TX_X2_MLD_SWAP_COUNTr_GET
#define TX_X2_MLD_SWAP_COUNTr_MLD_SWAP_COUNTf_GET BCMI_TSC_XGXS_TX_X2_MLD_SWAP_COUNTr_MLD_SWAP_COUNTf_GET
#define TX_X2_MLD_SWAP_COUNTr_MLD_SWAP_COUNTf_SET BCMI_TSC_XGXS_TX_X2_MLD_SWAP_COUNTr_MLD_SWAP_COUNTf_SET
#define READ_TX_X2_MLD_SWAP_COUNTr BCMI_TSC_XGXS_READ_TX_X2_MLD_SWAP_COUNTr
#define WRITE_TX_X2_MLD_SWAP_COUNTr BCMI_TSC_XGXS_WRITE_TX_X2_MLD_SWAP_COUNTr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_TX_X2_MLD_SWAP_COUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  TX_X2_CL48_0
 * BLOCKS:   TX_X2_CONTROL0
 * REGADDR:  0xa001
 * DESC:     CL48 register: 00000000
 * SIZE:     32
 * FIELDS:
 *     CL48_TX_QRSVDCTRL 
 *     CL48_TX_RF_ENABLE 
 *     CL48_TX_LF_ENABLE 
 *     CL48_TX_LI_ENABLE 
 *     RESERVED0        
 *     BRCM_MODE_USE_K20PT5 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_TX_X2_CL48_0r (0x0020a001 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_TX_X2_CL48_0r_SIZE 4

/*
 * This structure should be used to declare and program TX_X2_CL48_0.
 *
 */
typedef union BCMI_TSC_XGXS_TX_X2_CL48_0r_s {
	uint32_t v[1];
	uint32_t tx_x2_cl48_0[1];
	uint32_t _tx_x2_cl48_0;
} BCMI_TSC_XGXS_TX_X2_CL48_0r_t;

#define BCMI_TSC_XGXS_TX_X2_CL48_0r_CLR(r) (r).tx_x2_cl48_0[0] = 0
#define BCMI_TSC_XGXS_TX_X2_CL48_0r_SET(r,d) (r).tx_x2_cl48_0[0] = d
#define BCMI_TSC_XGXS_TX_X2_CL48_0r_GET(r) (r).tx_x2_cl48_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_TX_X2_CL48_0r_BRCM_MODE_USE_K20PT5f_GET(r) ((((r).tx_x2_cl48_0[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_TX_X2_CL48_0r_BRCM_MODE_USE_K20PT5f_SET(r,f) (r).tx_x2_cl48_0[0]=(((r).tx_x2_cl48_0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_TX_X2_CL48_0r_RESERVED0f_GET(r) ((((r).tx_x2_cl48_0[0]) >> 7) & 0xff)
#define BCMI_TSC_XGXS_TX_X2_CL48_0r_RESERVED0f_SET(r,f) (r).tx_x2_cl48_0[0]=(((r).tx_x2_cl48_0[0] & ~((uint32_t)0xff << 7)) | ((((uint32_t)f) & 0xff) << 7))
#define BCMI_TSC_XGXS_TX_X2_CL48_0r_CL48_TX_LI_ENABLEf_GET(r) ((((r).tx_x2_cl48_0[0]) >> 6) & 0x1)
#define BCMI_TSC_XGXS_TX_X2_CL48_0r_CL48_TX_LI_ENABLEf_SET(r,f) (r).tx_x2_cl48_0[0]=(((r).tx_x2_cl48_0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCMI_TSC_XGXS_TX_X2_CL48_0r_CL48_TX_LF_ENABLEf_GET(r) ((((r).tx_x2_cl48_0[0]) >> 5) & 0x1)
#define BCMI_TSC_XGXS_TX_X2_CL48_0r_CL48_TX_LF_ENABLEf_SET(r,f) (r).tx_x2_cl48_0[0]=(((r).tx_x2_cl48_0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCMI_TSC_XGXS_TX_X2_CL48_0r_CL48_TX_RF_ENABLEf_GET(r) ((((r).tx_x2_cl48_0[0]) >> 4) & 0x1)
#define BCMI_TSC_XGXS_TX_X2_CL48_0r_CL48_TX_RF_ENABLEf_SET(r,f) (r).tx_x2_cl48_0[0]=(((r).tx_x2_cl48_0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCMI_TSC_XGXS_TX_X2_CL48_0r_CL48_TX_QRSVDCTRLf_GET(r) (((r).tx_x2_cl48_0[0]) & 0xf)
#define BCMI_TSC_XGXS_TX_X2_CL48_0r_CL48_TX_QRSVDCTRLf_SET(r,f) (r).tx_x2_cl48_0[0]=(((r).tx_x2_cl48_0[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access TX_X2_CL48_0.
 *
 */
#define BCMI_TSC_XGXS_READ_TX_X2_CL48_0r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_TX_X2_CL48_0r,(_r._tx_x2_cl48_0))
#define BCMI_TSC_XGXS_WRITE_TX_X2_CL48_0r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_TX_X2_CL48_0r,(_r._tx_x2_cl48_0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TX_X2_CL48_0r BCMI_TSC_XGXS_TX_X2_CL48_0r
#define TX_X2_CL48_0r_SIZE BCMI_TSC_XGXS_TX_X2_CL48_0r_SIZE
typedef BCMI_TSC_XGXS_TX_X2_CL48_0r_t TX_X2_CL48_0r_t;
#define TX_X2_CL48_0r_CLR BCMI_TSC_XGXS_TX_X2_CL48_0r_CLR
#define TX_X2_CL48_0r_SET BCMI_TSC_XGXS_TX_X2_CL48_0r_SET
#define TX_X2_CL48_0r_GET BCMI_TSC_XGXS_TX_X2_CL48_0r_GET
#define TX_X2_CL48_0r_BRCM_MODE_USE_K20PT5f_GET BCMI_TSC_XGXS_TX_X2_CL48_0r_BRCM_MODE_USE_K20PT5f_GET
#define TX_X2_CL48_0r_BRCM_MODE_USE_K20PT5f_SET BCMI_TSC_XGXS_TX_X2_CL48_0r_BRCM_MODE_USE_K20PT5f_SET
#define TX_X2_CL48_0r_RESERVED0f_GET BCMI_TSC_XGXS_TX_X2_CL48_0r_RESERVED0f_GET
#define TX_X2_CL48_0r_RESERVED0f_SET BCMI_TSC_XGXS_TX_X2_CL48_0r_RESERVED0f_SET
#define TX_X2_CL48_0r_CL48_TX_LI_ENABLEf_GET BCMI_TSC_XGXS_TX_X2_CL48_0r_CL48_TX_LI_ENABLEf_GET
#define TX_X2_CL48_0r_CL48_TX_LI_ENABLEf_SET BCMI_TSC_XGXS_TX_X2_CL48_0r_CL48_TX_LI_ENABLEf_SET
#define TX_X2_CL48_0r_CL48_TX_LF_ENABLEf_GET BCMI_TSC_XGXS_TX_X2_CL48_0r_CL48_TX_LF_ENABLEf_GET
#define TX_X2_CL48_0r_CL48_TX_LF_ENABLEf_SET BCMI_TSC_XGXS_TX_X2_CL48_0r_CL48_TX_LF_ENABLEf_SET
#define TX_X2_CL48_0r_CL48_TX_RF_ENABLEf_GET BCMI_TSC_XGXS_TX_X2_CL48_0r_CL48_TX_RF_ENABLEf_GET
#define TX_X2_CL48_0r_CL48_TX_RF_ENABLEf_SET BCMI_TSC_XGXS_TX_X2_CL48_0r_CL48_TX_RF_ENABLEf_SET
#define TX_X2_CL48_0r_CL48_TX_QRSVDCTRLf_GET BCMI_TSC_XGXS_TX_X2_CL48_0r_CL48_TX_QRSVDCTRLf_GET
#define TX_X2_CL48_0r_CL48_TX_QRSVDCTRLf_SET BCMI_TSC_XGXS_TX_X2_CL48_0r_CL48_TX_QRSVDCTRLf_SET
#define READ_TX_X2_CL48_0r BCMI_TSC_XGXS_READ_TX_X2_CL48_0r
#define WRITE_TX_X2_CL48_0r BCMI_TSC_XGXS_WRITE_TX_X2_CL48_0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_TX_X2_CL48_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  TX_X2_CL82_0
 * BLOCKS:   TX_X2_CONTROL0
 * REGADDR:  0xa002
 * DESC:     CL82 register: 00000000
 * SIZE:     32
 * FIELDS:
 *     RESERVED2        
 *     CL82_TX_RF_ENABLE 
 *     CL82_TX_LF_ENABLE 
 *     CL82_TX_LI_ENABLE 
 *     RESERVED1        
 *     CL82_BYPASS_TXSM 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_TX_X2_CL82_0r (0x0020a002 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_TX_X2_CL82_0r_SIZE 4

/*
 * This structure should be used to declare and program TX_X2_CL82_0.
 *
 */
typedef union BCMI_TSC_XGXS_TX_X2_CL82_0r_s {
	uint32_t v[1];
	uint32_t tx_x2_cl82_0[1];
	uint32_t _tx_x2_cl82_0;
} BCMI_TSC_XGXS_TX_X2_CL82_0r_t;

#define BCMI_TSC_XGXS_TX_X2_CL82_0r_CLR(r) (r).tx_x2_cl82_0[0] = 0
#define BCMI_TSC_XGXS_TX_X2_CL82_0r_SET(r,d) (r).tx_x2_cl82_0[0] = d
#define BCMI_TSC_XGXS_TX_X2_CL82_0r_GET(r) (r).tx_x2_cl82_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_TX_X2_CL82_0r_RESERVED0f_GET(r) ((((r).tx_x2_cl82_0[0]) >> 11) & 0x1f)
#define BCMI_TSC_XGXS_TX_X2_CL82_0r_RESERVED0f_SET(r,f) (r).tx_x2_cl82_0[0]=(((r).tx_x2_cl82_0[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))
#define BCMI_TSC_XGXS_TX_X2_CL82_0r_CL82_BYPASS_TXSMf_GET(r) ((((r).tx_x2_cl82_0[0]) >> 10) & 0x1)
#define BCMI_TSC_XGXS_TX_X2_CL82_0r_CL82_BYPASS_TXSMf_SET(r,f) (r).tx_x2_cl82_0[0]=(((r).tx_x2_cl82_0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCMI_TSC_XGXS_TX_X2_CL82_0r_RESERVED1f_GET(r) ((((r).tx_x2_cl82_0[0]) >> 7) & 0x7)
#define BCMI_TSC_XGXS_TX_X2_CL82_0r_RESERVED1f_SET(r,f) (r).tx_x2_cl82_0[0]=(((r).tx_x2_cl82_0[0] & ~((uint32_t)0x7 << 7)) | ((((uint32_t)f) & 0x7) << 7))
#define BCMI_TSC_XGXS_TX_X2_CL82_0r_CL82_TX_LI_ENABLEf_GET(r) ((((r).tx_x2_cl82_0[0]) >> 6) & 0x1)
#define BCMI_TSC_XGXS_TX_X2_CL82_0r_CL82_TX_LI_ENABLEf_SET(r,f) (r).tx_x2_cl82_0[0]=(((r).tx_x2_cl82_0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCMI_TSC_XGXS_TX_X2_CL82_0r_CL82_TX_LF_ENABLEf_GET(r) ((((r).tx_x2_cl82_0[0]) >> 5) & 0x1)
#define BCMI_TSC_XGXS_TX_X2_CL82_0r_CL82_TX_LF_ENABLEf_SET(r,f) (r).tx_x2_cl82_0[0]=(((r).tx_x2_cl82_0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCMI_TSC_XGXS_TX_X2_CL82_0r_CL82_TX_RF_ENABLEf_GET(r) ((((r).tx_x2_cl82_0[0]) >> 4) & 0x1)
#define BCMI_TSC_XGXS_TX_X2_CL82_0r_CL82_TX_RF_ENABLEf_SET(r,f) (r).tx_x2_cl82_0[0]=(((r).tx_x2_cl82_0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCMI_TSC_XGXS_TX_X2_CL82_0r_RESERVED2f_GET(r) (((r).tx_x2_cl82_0[0]) & 0xf)
#define BCMI_TSC_XGXS_TX_X2_CL82_0r_RESERVED2f_SET(r,f) (r).tx_x2_cl82_0[0]=(((r).tx_x2_cl82_0[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access TX_X2_CL82_0.
 *
 */
#define BCMI_TSC_XGXS_READ_TX_X2_CL82_0r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_TX_X2_CL82_0r,(_r._tx_x2_cl82_0))
#define BCMI_TSC_XGXS_WRITE_TX_X2_CL82_0r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_TX_X2_CL82_0r,(_r._tx_x2_cl82_0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TX_X2_CL82_0r BCMI_TSC_XGXS_TX_X2_CL82_0r
#define TX_X2_CL82_0r_SIZE BCMI_TSC_XGXS_TX_X2_CL82_0r_SIZE
typedef BCMI_TSC_XGXS_TX_X2_CL82_0r_t TX_X2_CL82_0r_t;
#define TX_X2_CL82_0r_CLR BCMI_TSC_XGXS_TX_X2_CL82_0r_CLR
#define TX_X2_CL82_0r_SET BCMI_TSC_XGXS_TX_X2_CL82_0r_SET
#define TX_X2_CL82_0r_GET BCMI_TSC_XGXS_TX_X2_CL82_0r_GET
#define TX_X2_CL82_0r_RESERVED0f_GET BCMI_TSC_XGXS_TX_X2_CL82_0r_RESERVED0f_GET
#define TX_X2_CL82_0r_RESERVED0f_SET BCMI_TSC_XGXS_TX_X2_CL82_0r_RESERVED0f_SET
#define TX_X2_CL82_0r_CL82_BYPASS_TXSMf_GET BCMI_TSC_XGXS_TX_X2_CL82_0r_CL82_BYPASS_TXSMf_GET
#define TX_X2_CL82_0r_CL82_BYPASS_TXSMf_SET BCMI_TSC_XGXS_TX_X2_CL82_0r_CL82_BYPASS_TXSMf_SET
#define TX_X2_CL82_0r_RESERVED1f_GET BCMI_TSC_XGXS_TX_X2_CL82_0r_RESERVED1f_GET
#define TX_X2_CL82_0r_RESERVED1f_SET BCMI_TSC_XGXS_TX_X2_CL82_0r_RESERVED1f_SET
#define TX_X2_CL82_0r_CL82_TX_LI_ENABLEf_GET BCMI_TSC_XGXS_TX_X2_CL82_0r_CL82_TX_LI_ENABLEf_GET
#define TX_X2_CL82_0r_CL82_TX_LI_ENABLEf_SET BCMI_TSC_XGXS_TX_X2_CL82_0r_CL82_TX_LI_ENABLEf_SET
#define TX_X2_CL82_0r_CL82_TX_LF_ENABLEf_GET BCMI_TSC_XGXS_TX_X2_CL82_0r_CL82_TX_LF_ENABLEf_GET
#define TX_X2_CL82_0r_CL82_TX_LF_ENABLEf_SET BCMI_TSC_XGXS_TX_X2_CL82_0r_CL82_TX_LF_ENABLEf_SET
#define TX_X2_CL82_0r_CL82_TX_RF_ENABLEf_GET BCMI_TSC_XGXS_TX_X2_CL82_0r_CL82_TX_RF_ENABLEf_GET
#define TX_X2_CL82_0r_CL82_TX_RF_ENABLEf_SET BCMI_TSC_XGXS_TX_X2_CL82_0r_CL82_TX_RF_ENABLEf_SET
#define TX_X2_CL82_0r_RESERVED2f_GET BCMI_TSC_XGXS_TX_X2_CL82_0r_RESERVED2f_GET
#define TX_X2_CL82_0r_RESERVED2f_SET BCMI_TSC_XGXS_TX_X2_CL82_0r_RESERVED2f_SET
#define READ_TX_X2_CL82_0r BCMI_TSC_XGXS_READ_TX_X2_CL82_0r
#define WRITE_TX_X2_CL82_0r BCMI_TSC_XGXS_WRITE_TX_X2_CL82_0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_TX_X2_CL82_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  TX_X2_BRCM_MODE
 * BLOCKS:   TX_X2_CONTROL0
 * REGADDR:  0xa003
 * DESC:     BROADCOM 64/66 ACOL INSERTION COUNT: 00000000
 * SIZE:     32
 * FIELDS:
 *     ACOL_SWAP_COUNT64B66B 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_TX_X2_BRCM_MODEr (0x0020a003 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_TX_X2_BRCM_MODEr_SIZE 4

/*
 * This structure should be used to declare and program TX_X2_BRCM_MODE.
 *
 */
typedef union BCMI_TSC_XGXS_TX_X2_BRCM_MODEr_s {
	uint32_t v[1];
	uint32_t tx_x2_brcm_mode[1];
	uint32_t _tx_x2_brcm_mode;
} BCMI_TSC_XGXS_TX_X2_BRCM_MODEr_t;

#define BCMI_TSC_XGXS_TX_X2_BRCM_MODEr_CLR(r) (r).tx_x2_brcm_mode[0] = 0
#define BCMI_TSC_XGXS_TX_X2_BRCM_MODEr_SET(r,d) (r).tx_x2_brcm_mode[0] = d
#define BCMI_TSC_XGXS_TX_X2_BRCM_MODEr_GET(r) (r).tx_x2_brcm_mode[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_TX_X2_BRCM_MODEr_RESERVED0f_GET(r) ((((r).tx_x2_brcm_mode[0]) >> 8) & 0xff)
#define BCMI_TSC_XGXS_TX_X2_BRCM_MODEr_RESERVED0f_SET(r,f) (r).tx_x2_brcm_mode[0]=(((r).tx_x2_brcm_mode[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCMI_TSC_XGXS_TX_X2_BRCM_MODEr_ACOL_SWAP_COUNT64B66Bf_GET(r) (((r).tx_x2_brcm_mode[0]) & 0xff)
#define BCMI_TSC_XGXS_TX_X2_BRCM_MODEr_ACOL_SWAP_COUNT64B66Bf_SET(r,f) (r).tx_x2_brcm_mode[0]=(((r).tx_x2_brcm_mode[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access TX_X2_BRCM_MODE.
 *
 */
#define BCMI_TSC_XGXS_READ_TX_X2_BRCM_MODEr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_TX_X2_BRCM_MODEr,(_r._tx_x2_brcm_mode))
#define BCMI_TSC_XGXS_WRITE_TX_X2_BRCM_MODEr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_TX_X2_BRCM_MODEr,(_r._tx_x2_brcm_mode))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TX_X2_BRCM_MODEr BCMI_TSC_XGXS_TX_X2_BRCM_MODEr
#define TX_X2_BRCM_MODEr_SIZE BCMI_TSC_XGXS_TX_X2_BRCM_MODEr_SIZE
typedef BCMI_TSC_XGXS_TX_X2_BRCM_MODEr_t TX_X2_BRCM_MODEr_t;
#define TX_X2_BRCM_MODEr_CLR BCMI_TSC_XGXS_TX_X2_BRCM_MODEr_CLR
#define TX_X2_BRCM_MODEr_SET BCMI_TSC_XGXS_TX_X2_BRCM_MODEr_SET
#define TX_X2_BRCM_MODEr_GET BCMI_TSC_XGXS_TX_X2_BRCM_MODEr_GET
#define TX_X2_BRCM_MODEr_RESERVED0f_GET BCMI_TSC_XGXS_TX_X2_BRCM_MODEr_RESERVED0f_GET
#define TX_X2_BRCM_MODEr_RESERVED0f_SET BCMI_TSC_XGXS_TX_X2_BRCM_MODEr_RESERVED0f_SET
#define TX_X2_BRCM_MODEr_ACOL_SWAP_COUNT64B66Bf_GET BCMI_TSC_XGXS_TX_X2_BRCM_MODEr_ACOL_SWAP_COUNT64B66Bf_GET
#define TX_X2_BRCM_MODEr_ACOL_SWAP_COUNT64B66Bf_SET BCMI_TSC_XGXS_TX_X2_BRCM_MODEr_ACOL_SWAP_COUNT64B66Bf_SET
#define READ_TX_X2_BRCM_MODEr BCMI_TSC_XGXS_READ_TX_X2_BRCM_MODEr
#define WRITE_TX_X2_BRCM_MODEr BCMI_TSC_XGXS_WRITE_TX_X2_BRCM_MODEr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_TX_X2_BRCM_MODEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  TX_X2_CL82_TX_STATUS_0
 * BLOCKS:   TX_X2_STATUS0
 * REGADDR:  0xa011
 * DESC:     CL82 Status 0 register: 00000000
 * SIZE:     32
 * FIELDS:
 *     TXSM_STATE       
 *     LTXSM_STATE      
 *     T_TYPE_CODED     
 *     CL82_IDLE_DELETION_UNDERFLOW 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_TX_X2_CL82_TX_STATUS_0r (0x0020a011 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_TX_X2_CL82_TX_STATUS_0r_SIZE 4

/*
 * This structure should be used to declare and program TX_X2_CL82_TX_STATUS_0.
 *
 */
typedef union BCMI_TSC_XGXS_TX_X2_CL82_TX_STATUS_0r_s {
	uint32_t v[1];
	uint32_t tx_x2_cl82_tx_status_0[1];
	uint32_t _tx_x2_cl82_tx_status_0;
} BCMI_TSC_XGXS_TX_X2_CL82_TX_STATUS_0r_t;

#define BCMI_TSC_XGXS_TX_X2_CL82_TX_STATUS_0r_CLR(r) (r).tx_x2_cl82_tx_status_0[0] = 0
#define BCMI_TSC_XGXS_TX_X2_CL82_TX_STATUS_0r_SET(r,d) (r).tx_x2_cl82_tx_status_0[0] = d
#define BCMI_TSC_XGXS_TX_X2_CL82_TX_STATUS_0r_GET(r) (r).tx_x2_cl82_tx_status_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_TX_X2_CL82_TX_STATUS_0r_RESERVED0f_GET(r) ((((r).tx_x2_cl82_tx_status_0[0]) >> 14) & 0x3)
#define BCMI_TSC_XGXS_TX_X2_CL82_TX_STATUS_0r_RESERVED0f_SET(r,f) (r).tx_x2_cl82_tx_status_0[0]=(((r).tx_x2_cl82_tx_status_0[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCMI_TSC_XGXS_TX_X2_CL82_TX_STATUS_0r_CL82_IDLE_DELETION_UNDERFLOWf_GET(r) ((((r).tx_x2_cl82_tx_status_0[0]) >> 13) & 0x1)
#define BCMI_TSC_XGXS_TX_X2_CL82_TX_STATUS_0r_CL82_IDLE_DELETION_UNDERFLOWf_SET(r,f) (r).tx_x2_cl82_tx_status_0[0]=(((r).tx_x2_cl82_tx_status_0[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCMI_TSC_XGXS_TX_X2_CL82_TX_STATUS_0r_T_TYPE_CODEDf_GET(r) ((((r).tx_x2_cl82_tx_status_0[0]) >> 10) & 0x7)
#define BCMI_TSC_XGXS_TX_X2_CL82_TX_STATUS_0r_T_TYPE_CODEDf_SET(r,f) (r).tx_x2_cl82_tx_status_0[0]=(((r).tx_x2_cl82_tx_status_0[0] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10))
#define BCMI_TSC_XGXS_TX_X2_CL82_TX_STATUS_0r_LTXSM_STATEf_GET(r) ((((r).tx_x2_cl82_tx_status_0[0]) >> 3) & 0x7f)
#define BCMI_TSC_XGXS_TX_X2_CL82_TX_STATUS_0r_LTXSM_STATEf_SET(r,f) (r).tx_x2_cl82_tx_status_0[0]=(((r).tx_x2_cl82_tx_status_0[0] & ~((uint32_t)0x7f << 3)) | ((((uint32_t)f) & 0x7f) << 3))
#define BCMI_TSC_XGXS_TX_X2_CL82_TX_STATUS_0r_TXSM_STATEf_GET(r) (((r).tx_x2_cl82_tx_status_0[0]) & 0x7)
#define BCMI_TSC_XGXS_TX_X2_CL82_TX_STATUS_0r_TXSM_STATEf_SET(r,f) (r).tx_x2_cl82_tx_status_0[0]=(((r).tx_x2_cl82_tx_status_0[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))

/*
 * These macros can be used to access TX_X2_CL82_TX_STATUS_0.
 *
 */
#define BCMI_TSC_XGXS_READ_TX_X2_CL82_TX_STATUS_0r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_TX_X2_CL82_TX_STATUS_0r,(_r._tx_x2_cl82_tx_status_0))
#define BCMI_TSC_XGXS_WRITE_TX_X2_CL82_TX_STATUS_0r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_TX_X2_CL82_TX_STATUS_0r,(_r._tx_x2_cl82_tx_status_0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TX_X2_CL82_TX_STATUS_0r BCMI_TSC_XGXS_TX_X2_CL82_TX_STATUS_0r
#define TX_X2_CL82_TX_STATUS_0r_SIZE BCMI_TSC_XGXS_TX_X2_CL82_TX_STATUS_0r_SIZE
typedef BCMI_TSC_XGXS_TX_X2_CL82_TX_STATUS_0r_t TX_X2_CL82_TX_STATUS_0r_t;
#define TX_X2_CL82_TX_STATUS_0r_CLR BCMI_TSC_XGXS_TX_X2_CL82_TX_STATUS_0r_CLR
#define TX_X2_CL82_TX_STATUS_0r_SET BCMI_TSC_XGXS_TX_X2_CL82_TX_STATUS_0r_SET
#define TX_X2_CL82_TX_STATUS_0r_GET BCMI_TSC_XGXS_TX_X2_CL82_TX_STATUS_0r_GET
#define TX_X2_CL82_TX_STATUS_0r_RESERVED0f_GET BCMI_TSC_XGXS_TX_X2_CL82_TX_STATUS_0r_RESERVED0f_GET
#define TX_X2_CL82_TX_STATUS_0r_RESERVED0f_SET BCMI_TSC_XGXS_TX_X2_CL82_TX_STATUS_0r_RESERVED0f_SET
#define TX_X2_CL82_TX_STATUS_0r_CL82_IDLE_DELETION_UNDERFLOWf_GET BCMI_TSC_XGXS_TX_X2_CL82_TX_STATUS_0r_CL82_IDLE_DELETION_UNDERFLOWf_GET
#define TX_X2_CL82_TX_STATUS_0r_CL82_IDLE_DELETION_UNDERFLOWf_SET BCMI_TSC_XGXS_TX_X2_CL82_TX_STATUS_0r_CL82_IDLE_DELETION_UNDERFLOWf_SET
#define TX_X2_CL82_TX_STATUS_0r_T_TYPE_CODEDf_GET BCMI_TSC_XGXS_TX_X2_CL82_TX_STATUS_0r_T_TYPE_CODEDf_GET
#define TX_X2_CL82_TX_STATUS_0r_T_TYPE_CODEDf_SET BCMI_TSC_XGXS_TX_X2_CL82_TX_STATUS_0r_T_TYPE_CODEDf_SET
#define TX_X2_CL82_TX_STATUS_0r_LTXSM_STATEf_GET BCMI_TSC_XGXS_TX_X2_CL82_TX_STATUS_0r_LTXSM_STATEf_GET
#define TX_X2_CL82_TX_STATUS_0r_LTXSM_STATEf_SET BCMI_TSC_XGXS_TX_X2_CL82_TX_STATUS_0r_LTXSM_STATEf_SET
#define TX_X2_CL82_TX_STATUS_0r_TXSM_STATEf_GET BCMI_TSC_XGXS_TX_X2_CL82_TX_STATUS_0r_TXSM_STATEf_GET
#define TX_X2_CL82_TX_STATUS_0r_TXSM_STATEf_SET BCMI_TSC_XGXS_TX_X2_CL82_TX_STATUS_0r_TXSM_STATEf_SET
#define READ_TX_X2_CL82_TX_STATUS_0r BCMI_TSC_XGXS_READ_TX_X2_CL82_TX_STATUS_0r
#define WRITE_TX_X2_CL82_TX_STATUS_0r BCMI_TSC_XGXS_WRITE_TX_X2_CL82_TX_STATUS_0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_TX_X2_CL82_TX_STATUS_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X2_QRSVD_0
 * BLOCKS:   RX_X2_CONTROL0
 * REGADDR:  0xa020
 * DESC:     qrsvd 0 register: 00000000
 * SIZE:     32
 * FIELDS:
 *     RESERVED1        
 *     CL48_RX_QRSVDCTRL 
 *     QRSVDSWAP        
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X2_QRSVD_0r (0x0020a020 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X2_QRSVD_0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X2_QRSVD_0.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X2_QRSVD_0r_s {
	uint32_t v[1];
	uint32_t rx_x2_qrsvd_0[1];
	uint32_t _rx_x2_qrsvd_0;
} BCMI_TSC_XGXS_RX_X2_QRSVD_0r_t;

#define BCMI_TSC_XGXS_RX_X2_QRSVD_0r_CLR(r) (r).rx_x2_qrsvd_0[0] = 0
#define BCMI_TSC_XGXS_RX_X2_QRSVD_0r_SET(r,d) (r).rx_x2_qrsvd_0[0] = d
#define BCMI_TSC_XGXS_RX_X2_QRSVD_0r_GET(r) (r).rx_x2_qrsvd_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X2_QRSVD_0r_RESERVED0f_GET(r) ((((r).rx_x2_qrsvd_0[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_RX_X2_QRSVD_0r_RESERVED0f_SET(r,f) (r).rx_x2_qrsvd_0[0]=(((r).rx_x2_qrsvd_0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_RX_X2_QRSVD_0r_QRSVDSWAPf_GET(r) ((((r).rx_x2_qrsvd_0[0]) >> 5) & 0x3ff)
#define BCMI_TSC_XGXS_RX_X2_QRSVD_0r_QRSVDSWAPf_SET(r,f) (r).rx_x2_qrsvd_0[0]=(((r).rx_x2_qrsvd_0[0] & ~((uint32_t)0x3ff << 5)) | ((((uint32_t)f) & 0x3ff) << 5))
#define BCMI_TSC_XGXS_RX_X2_QRSVD_0r_CL48_RX_QRSVDCTRLf_GET(r) ((((r).rx_x2_qrsvd_0[0]) >> 1) & 0xf)
#define BCMI_TSC_XGXS_RX_X2_QRSVD_0r_CL48_RX_QRSVDCTRLf_SET(r,f) (r).rx_x2_qrsvd_0[0]=(((r).rx_x2_qrsvd_0[0] & ~((uint32_t)0xf << 1)) | ((((uint32_t)f) & 0xf) << 1))
#define BCMI_TSC_XGXS_RX_X2_QRSVD_0r_RESERVED1f_GET(r) (((r).rx_x2_qrsvd_0[0]) & 0x1)
#define BCMI_TSC_XGXS_RX_X2_QRSVD_0r_RESERVED1f_SET(r,f) (r).rx_x2_qrsvd_0[0]=(((r).rx_x2_qrsvd_0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access RX_X2_QRSVD_0.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X2_QRSVD_0r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X2_QRSVD_0r,(_r._rx_x2_qrsvd_0))
#define BCMI_TSC_XGXS_WRITE_RX_X2_QRSVD_0r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X2_QRSVD_0r,(_r._rx_x2_qrsvd_0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X2_QRSVD_0r BCMI_TSC_XGXS_RX_X2_QRSVD_0r
#define RX_X2_QRSVD_0r_SIZE BCMI_TSC_XGXS_RX_X2_QRSVD_0r_SIZE
typedef BCMI_TSC_XGXS_RX_X2_QRSVD_0r_t RX_X2_QRSVD_0r_t;
#define RX_X2_QRSVD_0r_CLR BCMI_TSC_XGXS_RX_X2_QRSVD_0r_CLR
#define RX_X2_QRSVD_0r_SET BCMI_TSC_XGXS_RX_X2_QRSVD_0r_SET
#define RX_X2_QRSVD_0r_GET BCMI_TSC_XGXS_RX_X2_QRSVD_0r_GET
#define RX_X2_QRSVD_0r_RESERVED0f_GET BCMI_TSC_XGXS_RX_X2_QRSVD_0r_RESERVED0f_GET
#define RX_X2_QRSVD_0r_RESERVED0f_SET BCMI_TSC_XGXS_RX_X2_QRSVD_0r_RESERVED0f_SET
#define RX_X2_QRSVD_0r_QRSVDSWAPf_GET BCMI_TSC_XGXS_RX_X2_QRSVD_0r_QRSVDSWAPf_GET
#define RX_X2_QRSVD_0r_QRSVDSWAPf_SET BCMI_TSC_XGXS_RX_X2_QRSVD_0r_QRSVDSWAPf_SET
#define RX_X2_QRSVD_0r_CL48_RX_QRSVDCTRLf_GET BCMI_TSC_XGXS_RX_X2_QRSVD_0r_CL48_RX_QRSVDCTRLf_GET
#define RX_X2_QRSVD_0r_CL48_RX_QRSVDCTRLf_SET BCMI_TSC_XGXS_RX_X2_QRSVD_0r_CL48_RX_QRSVDCTRLf_SET
#define RX_X2_QRSVD_0r_RESERVED1f_GET BCMI_TSC_XGXS_RX_X2_QRSVD_0r_RESERVED1f_GET
#define RX_X2_QRSVD_0r_RESERVED1f_SET BCMI_TSC_XGXS_RX_X2_QRSVD_0r_RESERVED1f_SET
#define READ_RX_X2_QRSVD_0r BCMI_TSC_XGXS_READ_RX_X2_QRSVD_0r
#define WRITE_RX_X2_QRSVD_0r BCMI_TSC_XGXS_WRITE_RX_X2_QRSVD_0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X2_QRSVD_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X2_QRSVD_1
 * BLOCKS:   RX_X2_CONTROL0
 * REGADDR:  0xa021
 * DESC:     qrsvd 1 register: 00000000
 * SIZE:     32
 * FIELDS:
 *     QRSVD2_8_2       
 *     QRSVD1           
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X2_QRSVD_1r (0x0020a021 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X2_QRSVD_1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X2_QRSVD_1.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X2_QRSVD_1r_s {
	uint32_t v[1];
	uint32_t rx_x2_qrsvd_1[1];
	uint32_t _rx_x2_qrsvd_1;
} BCMI_TSC_XGXS_RX_X2_QRSVD_1r_t;

#define BCMI_TSC_XGXS_RX_X2_QRSVD_1r_CLR(r) (r).rx_x2_qrsvd_1[0] = 0
#define BCMI_TSC_XGXS_RX_X2_QRSVD_1r_SET(r,d) (r).rx_x2_qrsvd_1[0] = d
#define BCMI_TSC_XGXS_RX_X2_QRSVD_1r_GET(r) (r).rx_x2_qrsvd_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X2_QRSVD_1r_QRSVD1f_GET(r) ((((r).rx_x2_qrsvd_1[0]) >> 7) & 0x1ff)
#define BCMI_TSC_XGXS_RX_X2_QRSVD_1r_QRSVD1f_SET(r,f) (r).rx_x2_qrsvd_1[0]=(((r).rx_x2_qrsvd_1[0] & ~((uint32_t)0x1ff << 7)) | ((((uint32_t)f) & 0x1ff) << 7))
#define BCMI_TSC_XGXS_RX_X2_QRSVD_1r_QRSVD2_8_2f_GET(r) (((r).rx_x2_qrsvd_1[0]) & 0x7f)
#define BCMI_TSC_XGXS_RX_X2_QRSVD_1r_QRSVD2_8_2f_SET(r,f) (r).rx_x2_qrsvd_1[0]=(((r).rx_x2_qrsvd_1[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f))

/*
 * These macros can be used to access RX_X2_QRSVD_1.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X2_QRSVD_1r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X2_QRSVD_1r,(_r._rx_x2_qrsvd_1))
#define BCMI_TSC_XGXS_WRITE_RX_X2_QRSVD_1r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X2_QRSVD_1r,(_r._rx_x2_qrsvd_1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X2_QRSVD_1r BCMI_TSC_XGXS_RX_X2_QRSVD_1r
#define RX_X2_QRSVD_1r_SIZE BCMI_TSC_XGXS_RX_X2_QRSVD_1r_SIZE
typedef BCMI_TSC_XGXS_RX_X2_QRSVD_1r_t RX_X2_QRSVD_1r_t;
#define RX_X2_QRSVD_1r_CLR BCMI_TSC_XGXS_RX_X2_QRSVD_1r_CLR
#define RX_X2_QRSVD_1r_SET BCMI_TSC_XGXS_RX_X2_QRSVD_1r_SET
#define RX_X2_QRSVD_1r_GET BCMI_TSC_XGXS_RX_X2_QRSVD_1r_GET
#define RX_X2_QRSVD_1r_QRSVD1f_GET BCMI_TSC_XGXS_RX_X2_QRSVD_1r_QRSVD1f_GET
#define RX_X2_QRSVD_1r_QRSVD1f_SET BCMI_TSC_XGXS_RX_X2_QRSVD_1r_QRSVD1f_SET
#define RX_X2_QRSVD_1r_QRSVD2_8_2f_GET BCMI_TSC_XGXS_RX_X2_QRSVD_1r_QRSVD2_8_2f_GET
#define RX_X2_QRSVD_1r_QRSVD2_8_2f_SET BCMI_TSC_XGXS_RX_X2_QRSVD_1r_QRSVD2_8_2f_SET
#define READ_RX_X2_QRSVD_1r BCMI_TSC_XGXS_READ_RX_X2_QRSVD_1r
#define WRITE_RX_X2_QRSVD_1r BCMI_TSC_XGXS_WRITE_RX_X2_QRSVD_1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X2_QRSVD_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X2_QRSVD_2
 * BLOCKS:   RX_X2_CONTROL0
 * REGADDR:  0xa022
 * DESC:     qrsvd 2 register: 00000000
 * SIZE:     32
 * FIELDS:
 *     RESERVED0        
 *     QRSVD3           
 *     QRSVD2_1_0       
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X2_QRSVD_2r (0x0020a022 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X2_QRSVD_2r_SIZE 4

/*
 * This structure should be used to declare and program RX_X2_QRSVD_2.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X2_QRSVD_2r_s {
	uint32_t v[1];
	uint32_t rx_x2_qrsvd_2[1];
	uint32_t _rx_x2_qrsvd_2;
} BCMI_TSC_XGXS_RX_X2_QRSVD_2r_t;

#define BCMI_TSC_XGXS_RX_X2_QRSVD_2r_CLR(r) (r).rx_x2_qrsvd_2[0] = 0
#define BCMI_TSC_XGXS_RX_X2_QRSVD_2r_SET(r,d) (r).rx_x2_qrsvd_2[0] = d
#define BCMI_TSC_XGXS_RX_X2_QRSVD_2r_GET(r) (r).rx_x2_qrsvd_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X2_QRSVD_2r_QRSVD2_1_0f_GET(r) ((((r).rx_x2_qrsvd_2[0]) >> 14) & 0x3)
#define BCMI_TSC_XGXS_RX_X2_QRSVD_2r_QRSVD2_1_0f_SET(r,f) (r).rx_x2_qrsvd_2[0]=(((r).rx_x2_qrsvd_2[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCMI_TSC_XGXS_RX_X2_QRSVD_2r_QRSVD3f_GET(r) ((((r).rx_x2_qrsvd_2[0]) >> 5) & 0x1ff)
#define BCMI_TSC_XGXS_RX_X2_QRSVD_2r_QRSVD3f_SET(r,f) (r).rx_x2_qrsvd_2[0]=(((r).rx_x2_qrsvd_2[0] & ~((uint32_t)0x1ff << 5)) | ((((uint32_t)f) & 0x1ff) << 5))
#define BCMI_TSC_XGXS_RX_X2_QRSVD_2r_RESERVED0f_GET(r) (((r).rx_x2_qrsvd_2[0]) & 0x1f)
#define BCMI_TSC_XGXS_RX_X2_QRSVD_2r_RESERVED0f_SET(r,f) (r).rx_x2_qrsvd_2[0]=(((r).rx_x2_qrsvd_2[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))

/*
 * These macros can be used to access RX_X2_QRSVD_2.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X2_QRSVD_2r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X2_QRSVD_2r,(_r._rx_x2_qrsvd_2))
#define BCMI_TSC_XGXS_WRITE_RX_X2_QRSVD_2r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X2_QRSVD_2r,(_r._rx_x2_qrsvd_2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X2_QRSVD_2r BCMI_TSC_XGXS_RX_X2_QRSVD_2r
#define RX_X2_QRSVD_2r_SIZE BCMI_TSC_XGXS_RX_X2_QRSVD_2r_SIZE
typedef BCMI_TSC_XGXS_RX_X2_QRSVD_2r_t RX_X2_QRSVD_2r_t;
#define RX_X2_QRSVD_2r_CLR BCMI_TSC_XGXS_RX_X2_QRSVD_2r_CLR
#define RX_X2_QRSVD_2r_SET BCMI_TSC_XGXS_RX_X2_QRSVD_2r_SET
#define RX_X2_QRSVD_2r_GET BCMI_TSC_XGXS_RX_X2_QRSVD_2r_GET
#define RX_X2_QRSVD_2r_QRSVD2_1_0f_GET BCMI_TSC_XGXS_RX_X2_QRSVD_2r_QRSVD2_1_0f_GET
#define RX_X2_QRSVD_2r_QRSVD2_1_0f_SET BCMI_TSC_XGXS_RX_X2_QRSVD_2r_QRSVD2_1_0f_SET
#define RX_X2_QRSVD_2r_QRSVD3f_GET BCMI_TSC_XGXS_RX_X2_QRSVD_2r_QRSVD3f_GET
#define RX_X2_QRSVD_2r_QRSVD3f_SET BCMI_TSC_XGXS_RX_X2_QRSVD_2r_QRSVD3f_SET
#define RX_X2_QRSVD_2r_RESERVED0f_GET BCMI_TSC_XGXS_RX_X2_QRSVD_2r_RESERVED0f_GET
#define RX_X2_QRSVD_2r_RESERVED0f_SET BCMI_TSC_XGXS_RX_X2_QRSVD_2r_RESERVED0f_SET
#define READ_RX_X2_QRSVD_2r BCMI_TSC_XGXS_READ_RX_X2_QRSVD_2r
#define WRITE_RX_X2_QRSVD_2r BCMI_TSC_XGXS_WRITE_RX_X2_QRSVD_2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X2_QRSVD_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X2_MISC_0
 * BLOCKS:   RX_X2_CONTROL0
 * REGADDR:  0xa023
 * DESC:     misc 0 register: 00000000
 * SIZE:     32
 * FIELDS:
 *     BYPASS_CL82RXSM  
 *     DIS_CL82_BERMON  
 *     RESERVED2        
 *     BRCM_MODE_USE_K20PT5 
 *     CHK_END_OVERRIDE 
 *     CHK_END_EN       
 *     RESERVED1        
 *     LINK_EN          
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X2_MISC_0r (0x0020a023 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X2_MISC_0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X2_MISC_0.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X2_MISC_0r_s {
	uint32_t v[1];
	uint32_t rx_x2_misc_0[1];
	uint32_t _rx_x2_misc_0;
} BCMI_TSC_XGXS_RX_X2_MISC_0r_t;

#define BCMI_TSC_XGXS_RX_X2_MISC_0r_CLR(r) (r).rx_x2_misc_0[0] = 0
#define BCMI_TSC_XGXS_RX_X2_MISC_0r_SET(r,d) (r).rx_x2_misc_0[0] = d
#define BCMI_TSC_XGXS_RX_X2_MISC_0r_GET(r) (r).rx_x2_misc_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X2_MISC_0r_RESERVED0f_GET(r) ((((r).rx_x2_misc_0[0]) >> 13) & 0x7)
#define BCMI_TSC_XGXS_RX_X2_MISC_0r_RESERVED0f_SET(r,f) (r).rx_x2_misc_0[0]=(((r).rx_x2_misc_0[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))
#define BCMI_TSC_XGXS_RX_X2_MISC_0r_LINK_ENf_GET(r) ((((r).rx_x2_misc_0[0]) >> 12) & 0x1)
#define BCMI_TSC_XGXS_RX_X2_MISC_0r_LINK_ENf_SET(r,f) (r).rx_x2_misc_0[0]=(((r).rx_x2_misc_0[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCMI_TSC_XGXS_RX_X2_MISC_0r_RESERVED1f_GET(r) ((((r).rx_x2_misc_0[0]) >> 11) & 0x1)
#define BCMI_TSC_XGXS_RX_X2_MISC_0r_RESERVED1f_SET(r,f) (r).rx_x2_misc_0[0]=(((r).rx_x2_misc_0[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCMI_TSC_XGXS_RX_X2_MISC_0r_CHK_END_ENf_GET(r) ((((r).rx_x2_misc_0[0]) >> 10) & 0x1)
#define BCMI_TSC_XGXS_RX_X2_MISC_0r_CHK_END_ENf_SET(r,f) (r).rx_x2_misc_0[0]=(((r).rx_x2_misc_0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCMI_TSC_XGXS_RX_X2_MISC_0r_CHK_END_OVERRIDEf_GET(r) ((((r).rx_x2_misc_0[0]) >> 9) & 0x1)
#define BCMI_TSC_XGXS_RX_X2_MISC_0r_CHK_END_OVERRIDEf_SET(r,f) (r).rx_x2_misc_0[0]=(((r).rx_x2_misc_0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCMI_TSC_XGXS_RX_X2_MISC_0r_BRCM_MODE_USE_K20PT5f_GET(r) ((((r).rx_x2_misc_0[0]) >> 8) & 0x1)
#define BCMI_TSC_XGXS_RX_X2_MISC_0r_BRCM_MODE_USE_K20PT5f_SET(r,f) (r).rx_x2_misc_0[0]=(((r).rx_x2_misc_0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCMI_TSC_XGXS_RX_X2_MISC_0r_RESERVED2f_GET(r) ((((r).rx_x2_misc_0[0]) >> 2) & 0x3f)
#define BCMI_TSC_XGXS_RX_X2_MISC_0r_RESERVED2f_SET(r,f) (r).rx_x2_misc_0[0]=(((r).rx_x2_misc_0[0] & ~((uint32_t)0x3f << 2)) | ((((uint32_t)f) & 0x3f) << 2))
#define BCMI_TSC_XGXS_RX_X2_MISC_0r_DIS_CL82_BERMONf_GET(r) ((((r).rx_x2_misc_0[0]) >> 1) & 0x1)
#define BCMI_TSC_XGXS_RX_X2_MISC_0r_DIS_CL82_BERMONf_SET(r,f) (r).rx_x2_misc_0[0]=(((r).rx_x2_misc_0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCMI_TSC_XGXS_RX_X2_MISC_0r_BYPASS_CL82RXSMf_GET(r) (((r).rx_x2_misc_0[0]) & 0x1)
#define BCMI_TSC_XGXS_RX_X2_MISC_0r_BYPASS_CL82RXSMf_SET(r,f) (r).rx_x2_misc_0[0]=(((r).rx_x2_misc_0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access RX_X2_MISC_0.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X2_MISC_0r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X2_MISC_0r,(_r._rx_x2_misc_0))
#define BCMI_TSC_XGXS_WRITE_RX_X2_MISC_0r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X2_MISC_0r,(_r._rx_x2_misc_0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X2_MISC_0r BCMI_TSC_XGXS_RX_X2_MISC_0r
#define RX_X2_MISC_0r_SIZE BCMI_TSC_XGXS_RX_X2_MISC_0r_SIZE
typedef BCMI_TSC_XGXS_RX_X2_MISC_0r_t RX_X2_MISC_0r_t;
#define RX_X2_MISC_0r_CLR BCMI_TSC_XGXS_RX_X2_MISC_0r_CLR
#define RX_X2_MISC_0r_SET BCMI_TSC_XGXS_RX_X2_MISC_0r_SET
#define RX_X2_MISC_0r_GET BCMI_TSC_XGXS_RX_X2_MISC_0r_GET
#define RX_X2_MISC_0r_RESERVED0f_GET BCMI_TSC_XGXS_RX_X2_MISC_0r_RESERVED0f_GET
#define RX_X2_MISC_0r_RESERVED0f_SET BCMI_TSC_XGXS_RX_X2_MISC_0r_RESERVED0f_SET
#define RX_X2_MISC_0r_LINK_ENf_GET BCMI_TSC_XGXS_RX_X2_MISC_0r_LINK_ENf_GET
#define RX_X2_MISC_0r_LINK_ENf_SET BCMI_TSC_XGXS_RX_X2_MISC_0r_LINK_ENf_SET
#define RX_X2_MISC_0r_RESERVED1f_GET BCMI_TSC_XGXS_RX_X2_MISC_0r_RESERVED1f_GET
#define RX_X2_MISC_0r_RESERVED1f_SET BCMI_TSC_XGXS_RX_X2_MISC_0r_RESERVED1f_SET
#define RX_X2_MISC_0r_CHK_END_ENf_GET BCMI_TSC_XGXS_RX_X2_MISC_0r_CHK_END_ENf_GET
#define RX_X2_MISC_0r_CHK_END_ENf_SET BCMI_TSC_XGXS_RX_X2_MISC_0r_CHK_END_ENf_SET
#define RX_X2_MISC_0r_CHK_END_OVERRIDEf_GET BCMI_TSC_XGXS_RX_X2_MISC_0r_CHK_END_OVERRIDEf_GET
#define RX_X2_MISC_0r_CHK_END_OVERRIDEf_SET BCMI_TSC_XGXS_RX_X2_MISC_0r_CHK_END_OVERRIDEf_SET
#define RX_X2_MISC_0r_BRCM_MODE_USE_K20PT5f_GET BCMI_TSC_XGXS_RX_X2_MISC_0r_BRCM_MODE_USE_K20PT5f_GET
#define RX_X2_MISC_0r_BRCM_MODE_USE_K20PT5f_SET BCMI_TSC_XGXS_RX_X2_MISC_0r_BRCM_MODE_USE_K20PT5f_SET
#define RX_X2_MISC_0r_RESERVED2f_GET BCMI_TSC_XGXS_RX_X2_MISC_0r_RESERVED2f_GET
#define RX_X2_MISC_0r_RESERVED2f_SET BCMI_TSC_XGXS_RX_X2_MISC_0r_RESERVED2f_SET
#define RX_X2_MISC_0r_DIS_CL82_BERMONf_GET BCMI_TSC_XGXS_RX_X2_MISC_0r_DIS_CL82_BERMONf_GET
#define RX_X2_MISC_0r_DIS_CL82_BERMONf_SET BCMI_TSC_XGXS_RX_X2_MISC_0r_DIS_CL82_BERMONf_SET
#define RX_X2_MISC_0r_BYPASS_CL82RXSMf_GET BCMI_TSC_XGXS_RX_X2_MISC_0r_BYPASS_CL82RXSMf_GET
#define RX_X2_MISC_0r_BYPASS_CL82RXSMf_SET BCMI_TSC_XGXS_RX_X2_MISC_0r_BYPASS_CL82RXSMf_SET
#define READ_RX_X2_MISC_0r BCMI_TSC_XGXS_READ_RX_X2_MISC_0r
#define WRITE_RX_X2_MISC_0r BCMI_TSC_XGXS_WRITE_RX_X2_MISC_0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X2_MISC_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X2_MISC_1
 * BLOCKS:   RX_X2_CONTROL0
 * REGADDR:  0xa024
 * DESC:     misc 1 register: 00000000
 * SIZE:     32
 * FIELDS:
 *     CL82_RX_RF_ENABLE 
 *     CL82_RX_LF_ENABLE 
 *     CL48_RX_RF_ENABLE 
 *     CL48_RX_LF_ENABLE 
 *     RESERVED1        
 *     CL48_RX_LI_ENABLE 
 *     CL82_RX_LI_ENABLE 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X2_MISC_1r (0x0020a024 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X2_MISC_1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X2_MISC_1.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X2_MISC_1r_s {
	uint32_t v[1];
	uint32_t rx_x2_misc_1[1];
	uint32_t _rx_x2_misc_1;
} BCMI_TSC_XGXS_RX_X2_MISC_1r_t;

#define BCMI_TSC_XGXS_RX_X2_MISC_1r_CLR(r) (r).rx_x2_misc_1[0] = 0
#define BCMI_TSC_XGXS_RX_X2_MISC_1r_SET(r,d) (r).rx_x2_misc_1[0] = d
#define BCMI_TSC_XGXS_RX_X2_MISC_1r_GET(r) (r).rx_x2_misc_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X2_MISC_1r_RESERVED0f_GET(r) ((((r).rx_x2_misc_1[0]) >> 10) & 0x3f)
#define BCMI_TSC_XGXS_RX_X2_MISC_1r_RESERVED0f_SET(r,f) (r).rx_x2_misc_1[0]=(((r).rx_x2_misc_1[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))
#define BCMI_TSC_XGXS_RX_X2_MISC_1r_CL82_RX_LI_ENABLEf_GET(r) ((((r).rx_x2_misc_1[0]) >> 9) & 0x1)
#define BCMI_TSC_XGXS_RX_X2_MISC_1r_CL82_RX_LI_ENABLEf_SET(r,f) (r).rx_x2_misc_1[0]=(((r).rx_x2_misc_1[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCMI_TSC_XGXS_RX_X2_MISC_1r_CL48_RX_LI_ENABLEf_GET(r) ((((r).rx_x2_misc_1[0]) >> 8) & 0x1)
#define BCMI_TSC_XGXS_RX_X2_MISC_1r_CL48_RX_LI_ENABLEf_SET(r,f) (r).rx_x2_misc_1[0]=(((r).rx_x2_misc_1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCMI_TSC_XGXS_RX_X2_MISC_1r_RESERVED1f_GET(r) ((((r).rx_x2_misc_1[0]) >> 4) & 0xf)
#define BCMI_TSC_XGXS_RX_X2_MISC_1r_RESERVED1f_SET(r,f) (r).rx_x2_misc_1[0]=(((r).rx_x2_misc_1[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCMI_TSC_XGXS_RX_X2_MISC_1r_CL48_RX_LF_ENABLEf_GET(r) ((((r).rx_x2_misc_1[0]) >> 3) & 0x1)
#define BCMI_TSC_XGXS_RX_X2_MISC_1r_CL48_RX_LF_ENABLEf_SET(r,f) (r).rx_x2_misc_1[0]=(((r).rx_x2_misc_1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCMI_TSC_XGXS_RX_X2_MISC_1r_CL48_RX_RF_ENABLEf_GET(r) ((((r).rx_x2_misc_1[0]) >> 2) & 0x1)
#define BCMI_TSC_XGXS_RX_X2_MISC_1r_CL48_RX_RF_ENABLEf_SET(r,f) (r).rx_x2_misc_1[0]=(((r).rx_x2_misc_1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCMI_TSC_XGXS_RX_X2_MISC_1r_CL82_RX_LF_ENABLEf_GET(r) ((((r).rx_x2_misc_1[0]) >> 1) & 0x1)
#define BCMI_TSC_XGXS_RX_X2_MISC_1r_CL82_RX_LF_ENABLEf_SET(r,f) (r).rx_x2_misc_1[0]=(((r).rx_x2_misc_1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCMI_TSC_XGXS_RX_X2_MISC_1r_CL82_RX_RF_ENABLEf_GET(r) (((r).rx_x2_misc_1[0]) & 0x1)
#define BCMI_TSC_XGXS_RX_X2_MISC_1r_CL82_RX_RF_ENABLEf_SET(r,f) (r).rx_x2_misc_1[0]=(((r).rx_x2_misc_1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access RX_X2_MISC_1.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X2_MISC_1r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X2_MISC_1r,(_r._rx_x2_misc_1))
#define BCMI_TSC_XGXS_WRITE_RX_X2_MISC_1r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X2_MISC_1r,(_r._rx_x2_misc_1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X2_MISC_1r BCMI_TSC_XGXS_RX_X2_MISC_1r
#define RX_X2_MISC_1r_SIZE BCMI_TSC_XGXS_RX_X2_MISC_1r_SIZE
typedef BCMI_TSC_XGXS_RX_X2_MISC_1r_t RX_X2_MISC_1r_t;
#define RX_X2_MISC_1r_CLR BCMI_TSC_XGXS_RX_X2_MISC_1r_CLR
#define RX_X2_MISC_1r_SET BCMI_TSC_XGXS_RX_X2_MISC_1r_SET
#define RX_X2_MISC_1r_GET BCMI_TSC_XGXS_RX_X2_MISC_1r_GET
#define RX_X2_MISC_1r_RESERVED0f_GET BCMI_TSC_XGXS_RX_X2_MISC_1r_RESERVED0f_GET
#define RX_X2_MISC_1r_RESERVED0f_SET BCMI_TSC_XGXS_RX_X2_MISC_1r_RESERVED0f_SET
#define RX_X2_MISC_1r_CL82_RX_LI_ENABLEf_GET BCMI_TSC_XGXS_RX_X2_MISC_1r_CL82_RX_LI_ENABLEf_GET
#define RX_X2_MISC_1r_CL82_RX_LI_ENABLEf_SET BCMI_TSC_XGXS_RX_X2_MISC_1r_CL82_RX_LI_ENABLEf_SET
#define RX_X2_MISC_1r_CL48_RX_LI_ENABLEf_GET BCMI_TSC_XGXS_RX_X2_MISC_1r_CL48_RX_LI_ENABLEf_GET
#define RX_X2_MISC_1r_CL48_RX_LI_ENABLEf_SET BCMI_TSC_XGXS_RX_X2_MISC_1r_CL48_RX_LI_ENABLEf_SET
#define RX_X2_MISC_1r_RESERVED1f_GET BCMI_TSC_XGXS_RX_X2_MISC_1r_RESERVED1f_GET
#define RX_X2_MISC_1r_RESERVED1f_SET BCMI_TSC_XGXS_RX_X2_MISC_1r_RESERVED1f_SET
#define RX_X2_MISC_1r_CL48_RX_LF_ENABLEf_GET BCMI_TSC_XGXS_RX_X2_MISC_1r_CL48_RX_LF_ENABLEf_GET
#define RX_X2_MISC_1r_CL48_RX_LF_ENABLEf_SET BCMI_TSC_XGXS_RX_X2_MISC_1r_CL48_RX_LF_ENABLEf_SET
#define RX_X2_MISC_1r_CL48_RX_RF_ENABLEf_GET BCMI_TSC_XGXS_RX_X2_MISC_1r_CL48_RX_RF_ENABLEf_GET
#define RX_X2_MISC_1r_CL48_RX_RF_ENABLEf_SET BCMI_TSC_XGXS_RX_X2_MISC_1r_CL48_RX_RF_ENABLEf_SET
#define RX_X2_MISC_1r_CL82_RX_LF_ENABLEf_GET BCMI_TSC_XGXS_RX_X2_MISC_1r_CL82_RX_LF_ENABLEf_GET
#define RX_X2_MISC_1r_CL82_RX_LF_ENABLEf_SET BCMI_TSC_XGXS_RX_X2_MISC_1r_CL82_RX_LF_ENABLEf_SET
#define RX_X2_MISC_1r_CL82_RX_RF_ENABLEf_GET BCMI_TSC_XGXS_RX_X2_MISC_1r_CL82_RX_RF_ENABLEf_GET
#define RX_X2_MISC_1r_CL82_RX_RF_ENABLEf_SET BCMI_TSC_XGXS_RX_X2_MISC_1r_CL82_RX_RF_ENABLEf_SET
#define READ_RX_X2_MISC_1r BCMI_TSC_XGXS_READ_RX_X2_MISC_1r
#define WRITE_RX_X2_MISC_1r BCMI_TSC_XGXS_WRITE_RX_X2_MISC_1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X2_MISC_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X2_SKEW_STATUS_0
 * BLOCKS:   RX_X2_STATUS0
 * REGADDR:  0xa031
 * DESC:     skew_status_0 register: 00000000
 * SIZE:     32
 * FIELDS:
 *     RESERVED0        
 *     CL48_SKEWACQ_STATE_D_3 
 *     CL48_SKEWACQ_STATE_D_2 
 *     CL48_SKEWACQ_STATE_D_1 
 *     CL48_SKEWACQ_STATE_D_0 
 *     CL48_SKEW_STATUS 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X2_SKEW_STATUS_0r (0x0020a031 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X2_SKEW_STATUS_0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X2_SKEW_STATUS_0.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X2_SKEW_STATUS_0r_s {
	uint32_t v[1];
	uint32_t rx_x2_skew_status_0[1];
	uint32_t _rx_x2_skew_status_0;
} BCMI_TSC_XGXS_RX_X2_SKEW_STATUS_0r_t;

#define BCMI_TSC_XGXS_RX_X2_SKEW_STATUS_0r_CLR(r) (r).rx_x2_skew_status_0[0] = 0
#define BCMI_TSC_XGXS_RX_X2_SKEW_STATUS_0r_SET(r,d) (r).rx_x2_skew_status_0[0] = d
#define BCMI_TSC_XGXS_RX_X2_SKEW_STATUS_0r_GET(r) (r).rx_x2_skew_status_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X2_SKEW_STATUS_0r_CL48_SKEW_STATUSf_GET(r) ((((r).rx_x2_skew_status_0[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_RX_X2_SKEW_STATUS_0r_CL48_SKEW_STATUSf_SET(r,f) (r).rx_x2_skew_status_0[0]=(((r).rx_x2_skew_status_0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_RX_X2_SKEW_STATUS_0r_CL48_SKEWACQ_STATE_D_0f_GET(r) ((((r).rx_x2_skew_status_0[0]) >> 12) & 0x7)
#define BCMI_TSC_XGXS_RX_X2_SKEW_STATUS_0r_CL48_SKEWACQ_STATE_D_0f_SET(r,f) (r).rx_x2_skew_status_0[0]=(((r).rx_x2_skew_status_0[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCMI_TSC_XGXS_RX_X2_SKEW_STATUS_0r_CL48_SKEWACQ_STATE_D_1f_GET(r) ((((r).rx_x2_skew_status_0[0]) >> 9) & 0x7)
#define BCMI_TSC_XGXS_RX_X2_SKEW_STATUS_0r_CL48_SKEWACQ_STATE_D_1f_SET(r,f) (r).rx_x2_skew_status_0[0]=(((r).rx_x2_skew_status_0[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCMI_TSC_XGXS_RX_X2_SKEW_STATUS_0r_CL48_SKEWACQ_STATE_D_2f_GET(r) ((((r).rx_x2_skew_status_0[0]) >> 6) & 0x7)
#define BCMI_TSC_XGXS_RX_X2_SKEW_STATUS_0r_CL48_SKEWACQ_STATE_D_2f_SET(r,f) (r).rx_x2_skew_status_0[0]=(((r).rx_x2_skew_status_0[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCMI_TSC_XGXS_RX_X2_SKEW_STATUS_0r_CL48_SKEWACQ_STATE_D_3f_GET(r) ((((r).rx_x2_skew_status_0[0]) >> 3) & 0x7)
#define BCMI_TSC_XGXS_RX_X2_SKEW_STATUS_0r_CL48_SKEWACQ_STATE_D_3f_SET(r,f) (r).rx_x2_skew_status_0[0]=(((r).rx_x2_skew_status_0[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCMI_TSC_XGXS_RX_X2_SKEW_STATUS_0r_RESERVED0f_GET(r) (((r).rx_x2_skew_status_0[0]) & 0x7)
#define BCMI_TSC_XGXS_RX_X2_SKEW_STATUS_0r_RESERVED0f_SET(r,f) (r).rx_x2_skew_status_0[0]=(((r).rx_x2_skew_status_0[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))

/*
 * These macros can be used to access RX_X2_SKEW_STATUS_0.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X2_SKEW_STATUS_0r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X2_SKEW_STATUS_0r,(_r._rx_x2_skew_status_0))
#define BCMI_TSC_XGXS_WRITE_RX_X2_SKEW_STATUS_0r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X2_SKEW_STATUS_0r,(_r._rx_x2_skew_status_0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X2_SKEW_STATUS_0r BCMI_TSC_XGXS_RX_X2_SKEW_STATUS_0r
#define RX_X2_SKEW_STATUS_0r_SIZE BCMI_TSC_XGXS_RX_X2_SKEW_STATUS_0r_SIZE
typedef BCMI_TSC_XGXS_RX_X2_SKEW_STATUS_0r_t RX_X2_SKEW_STATUS_0r_t;
#define RX_X2_SKEW_STATUS_0r_CLR BCMI_TSC_XGXS_RX_X2_SKEW_STATUS_0r_CLR
#define RX_X2_SKEW_STATUS_0r_SET BCMI_TSC_XGXS_RX_X2_SKEW_STATUS_0r_SET
#define RX_X2_SKEW_STATUS_0r_GET BCMI_TSC_XGXS_RX_X2_SKEW_STATUS_0r_GET
#define RX_X2_SKEW_STATUS_0r_CL48_SKEW_STATUSf_GET BCMI_TSC_XGXS_RX_X2_SKEW_STATUS_0r_CL48_SKEW_STATUSf_GET
#define RX_X2_SKEW_STATUS_0r_CL48_SKEW_STATUSf_SET BCMI_TSC_XGXS_RX_X2_SKEW_STATUS_0r_CL48_SKEW_STATUSf_SET
#define RX_X2_SKEW_STATUS_0r_CL48_SKEWACQ_STATE_D_0f_GET BCMI_TSC_XGXS_RX_X2_SKEW_STATUS_0r_CL48_SKEWACQ_STATE_D_0f_GET
#define RX_X2_SKEW_STATUS_0r_CL48_SKEWACQ_STATE_D_0f_SET BCMI_TSC_XGXS_RX_X2_SKEW_STATUS_0r_CL48_SKEWACQ_STATE_D_0f_SET
#define RX_X2_SKEW_STATUS_0r_CL48_SKEWACQ_STATE_D_1f_GET BCMI_TSC_XGXS_RX_X2_SKEW_STATUS_0r_CL48_SKEWACQ_STATE_D_1f_GET
#define RX_X2_SKEW_STATUS_0r_CL48_SKEWACQ_STATE_D_1f_SET BCMI_TSC_XGXS_RX_X2_SKEW_STATUS_0r_CL48_SKEWACQ_STATE_D_1f_SET
#define RX_X2_SKEW_STATUS_0r_CL48_SKEWACQ_STATE_D_2f_GET BCMI_TSC_XGXS_RX_X2_SKEW_STATUS_0r_CL48_SKEWACQ_STATE_D_2f_GET
#define RX_X2_SKEW_STATUS_0r_CL48_SKEWACQ_STATE_D_2f_SET BCMI_TSC_XGXS_RX_X2_SKEW_STATUS_0r_CL48_SKEWACQ_STATE_D_2f_SET
#define RX_X2_SKEW_STATUS_0r_CL48_SKEWACQ_STATE_D_3f_GET BCMI_TSC_XGXS_RX_X2_SKEW_STATUS_0r_CL48_SKEWACQ_STATE_D_3f_GET
#define RX_X2_SKEW_STATUS_0r_CL48_SKEWACQ_STATE_D_3f_SET BCMI_TSC_XGXS_RX_X2_SKEW_STATUS_0r_CL48_SKEWACQ_STATE_D_3f_SET
#define RX_X2_SKEW_STATUS_0r_RESERVED0f_GET BCMI_TSC_XGXS_RX_X2_SKEW_STATUS_0r_RESERVED0f_GET
#define RX_X2_SKEW_STATUS_0r_RESERVED0f_SET BCMI_TSC_XGXS_RX_X2_SKEW_STATUS_0r_RESERVED0f_SET
#define READ_RX_X2_SKEW_STATUS_0r BCMI_TSC_XGXS_READ_RX_X2_SKEW_STATUS_0r
#define WRITE_RX_X2_SKEW_STATUS_0r BCMI_TSC_XGXS_WRITE_RX_X2_SKEW_STATUS_0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X2_SKEW_STATUS_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X2_SKEW_STATUS_1
 * BLOCKS:   RX_X2_STATUS0
 * REGADDR:  0xa032
 * DESC:     skew_status_1 register: 00000000
 * SIZE:     32
 * FIELDS:
 *     CL48_SKEWACQ_STATE_L 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X2_SKEW_STATUS_1r (0x0020a032 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X2_SKEW_STATUS_1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X2_SKEW_STATUS_1.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X2_SKEW_STATUS_1r_s {
	uint32_t v[1];
	uint32_t rx_x2_skew_status_1[1];
	uint32_t _rx_x2_skew_status_1;
} BCMI_TSC_XGXS_RX_X2_SKEW_STATUS_1r_t;

#define BCMI_TSC_XGXS_RX_X2_SKEW_STATUS_1r_CLR(r) (r).rx_x2_skew_status_1[0] = 0
#define BCMI_TSC_XGXS_RX_X2_SKEW_STATUS_1r_SET(r,d) (r).rx_x2_skew_status_1[0] = d
#define BCMI_TSC_XGXS_RX_X2_SKEW_STATUS_1r_GET(r) (r).rx_x2_skew_status_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X2_SKEW_STATUS_1r_RESERVED0f_GET(r) ((((r).rx_x2_skew_status_1[0]) >> 8) & 0xff)
#define BCMI_TSC_XGXS_RX_X2_SKEW_STATUS_1r_RESERVED0f_SET(r,f) (r).rx_x2_skew_status_1[0]=(((r).rx_x2_skew_status_1[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCMI_TSC_XGXS_RX_X2_SKEW_STATUS_1r_CL48_SKEWACQ_STATE_Lf_GET(r) (((r).rx_x2_skew_status_1[0]) & 0xff)
#define BCMI_TSC_XGXS_RX_X2_SKEW_STATUS_1r_CL48_SKEWACQ_STATE_Lf_SET(r,f) (r).rx_x2_skew_status_1[0]=(((r).rx_x2_skew_status_1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access RX_X2_SKEW_STATUS_1.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X2_SKEW_STATUS_1r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X2_SKEW_STATUS_1r,(_r._rx_x2_skew_status_1))
#define BCMI_TSC_XGXS_WRITE_RX_X2_SKEW_STATUS_1r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X2_SKEW_STATUS_1r,(_r._rx_x2_skew_status_1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X2_SKEW_STATUS_1r BCMI_TSC_XGXS_RX_X2_SKEW_STATUS_1r
#define RX_X2_SKEW_STATUS_1r_SIZE BCMI_TSC_XGXS_RX_X2_SKEW_STATUS_1r_SIZE
typedef BCMI_TSC_XGXS_RX_X2_SKEW_STATUS_1r_t RX_X2_SKEW_STATUS_1r_t;
#define RX_X2_SKEW_STATUS_1r_CLR BCMI_TSC_XGXS_RX_X2_SKEW_STATUS_1r_CLR
#define RX_X2_SKEW_STATUS_1r_SET BCMI_TSC_XGXS_RX_X2_SKEW_STATUS_1r_SET
#define RX_X2_SKEW_STATUS_1r_GET BCMI_TSC_XGXS_RX_X2_SKEW_STATUS_1r_GET
#define RX_X2_SKEW_STATUS_1r_RESERVED0f_GET BCMI_TSC_XGXS_RX_X2_SKEW_STATUS_1r_RESERVED0f_GET
#define RX_X2_SKEW_STATUS_1r_RESERVED0f_SET BCMI_TSC_XGXS_RX_X2_SKEW_STATUS_1r_RESERVED0f_SET
#define RX_X2_SKEW_STATUS_1r_CL48_SKEWACQ_STATE_Lf_GET BCMI_TSC_XGXS_RX_X2_SKEW_STATUS_1r_CL48_SKEWACQ_STATE_Lf_GET
#define RX_X2_SKEW_STATUS_1r_CL48_SKEWACQ_STATE_Lf_SET BCMI_TSC_XGXS_RX_X2_SKEW_STATUS_1r_CL48_SKEWACQ_STATE_Lf_SET
#define READ_RX_X2_SKEW_STATUS_1r BCMI_TSC_XGXS_READ_RX_X2_SKEW_STATUS_1r
#define WRITE_RX_X2_SKEW_STATUS_1r BCMI_TSC_XGXS_WRITE_RX_X2_SKEW_STATUS_1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X2_SKEW_STATUS_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CL82_RX_DECODER_STATUS
 * BLOCKS:   CL82
 * REGADDR:  0xa080
 * DESC:     cl82 rx decoder status register: 00000000
 * SIZE:     32
 * FIELDS:
 *     RXSM_STATE       
 *     R_TYPE_CODED     
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CL82_RX_DECODER_STATUSr (0x0020a080 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CL82_RX_DECODER_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program CL82_RX_DECODER_STATUS.
 *
 */
typedef union BCMI_TSC_XGXS_CL82_RX_DECODER_STATUSr_s {
	uint32_t v[1];
	uint32_t cl82_rx_decoder_status[1];
	uint32_t _cl82_rx_decoder_status;
} BCMI_TSC_XGXS_CL82_RX_DECODER_STATUSr_t;

#define BCMI_TSC_XGXS_CL82_RX_DECODER_STATUSr_CLR(r) (r).cl82_rx_decoder_status[0] = 0
#define BCMI_TSC_XGXS_CL82_RX_DECODER_STATUSr_SET(r,d) (r).cl82_rx_decoder_status[0] = d
#define BCMI_TSC_XGXS_CL82_RX_DECODER_STATUSr_GET(r) (r).cl82_rx_decoder_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CL82_RX_DECODER_STATUSr_RESERVED0f_GET(r) ((((r).cl82_rx_decoder_status[0]) >> 13) & 0x7)
#define BCMI_TSC_XGXS_CL82_RX_DECODER_STATUSr_RESERVED0f_SET(r,f) (r).cl82_rx_decoder_status[0]=(((r).cl82_rx_decoder_status[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))
#define BCMI_TSC_XGXS_CL82_RX_DECODER_STATUSr_R_TYPE_CODEDf_GET(r) ((((r).cl82_rx_decoder_status[0]) >> 7) & 0x3f)
#define BCMI_TSC_XGXS_CL82_RX_DECODER_STATUSr_R_TYPE_CODEDf_SET(r,f) (r).cl82_rx_decoder_status[0]=(((r).cl82_rx_decoder_status[0] & ~((uint32_t)0x3f << 7)) | ((((uint32_t)f) & 0x3f) << 7))
#define BCMI_TSC_XGXS_CL82_RX_DECODER_STATUSr_RXSM_STATEf_GET(r) (((r).cl82_rx_decoder_status[0]) & 0x7f)
#define BCMI_TSC_XGXS_CL82_RX_DECODER_STATUSr_RXSM_STATEf_SET(r,f) (r).cl82_rx_decoder_status[0]=(((r).cl82_rx_decoder_status[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f))

/*
 * These macros can be used to access CL82_RX_DECODER_STATUS.
 *
 */
#define BCMI_TSC_XGXS_READ_CL82_RX_DECODER_STATUSr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CL82_RX_DECODER_STATUSr,(_r._cl82_rx_decoder_status))
#define BCMI_TSC_XGXS_WRITE_CL82_RX_DECODER_STATUSr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CL82_RX_DECODER_STATUSr,(_r._cl82_rx_decoder_status))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL82_RX_DECODER_STATUSr BCMI_TSC_XGXS_CL82_RX_DECODER_STATUSr
#define CL82_RX_DECODER_STATUSr_SIZE BCMI_TSC_XGXS_CL82_RX_DECODER_STATUSr_SIZE
typedef BCMI_TSC_XGXS_CL82_RX_DECODER_STATUSr_t CL82_RX_DECODER_STATUSr_t;
#define CL82_RX_DECODER_STATUSr_CLR BCMI_TSC_XGXS_CL82_RX_DECODER_STATUSr_CLR
#define CL82_RX_DECODER_STATUSr_SET BCMI_TSC_XGXS_CL82_RX_DECODER_STATUSr_SET
#define CL82_RX_DECODER_STATUSr_GET BCMI_TSC_XGXS_CL82_RX_DECODER_STATUSr_GET
#define CL82_RX_DECODER_STATUSr_RESERVED0f_GET BCMI_TSC_XGXS_CL82_RX_DECODER_STATUSr_RESERVED0f_GET
#define CL82_RX_DECODER_STATUSr_RESERVED0f_SET BCMI_TSC_XGXS_CL82_RX_DECODER_STATUSr_RESERVED0f_SET
#define CL82_RX_DECODER_STATUSr_R_TYPE_CODEDf_GET BCMI_TSC_XGXS_CL82_RX_DECODER_STATUSr_R_TYPE_CODEDf_GET
#define CL82_RX_DECODER_STATUSr_R_TYPE_CODEDf_SET BCMI_TSC_XGXS_CL82_RX_DECODER_STATUSr_R_TYPE_CODEDf_SET
#define CL82_RX_DECODER_STATUSr_RXSM_STATEf_GET BCMI_TSC_XGXS_CL82_RX_DECODER_STATUSr_RXSM_STATEf_GET
#define CL82_RX_DECODER_STATUSr_RXSM_STATEf_SET BCMI_TSC_XGXS_CL82_RX_DECODER_STATUSr_RXSM_STATEf_SET
#define READ_CL82_RX_DECODER_STATUSr BCMI_TSC_XGXS_READ_CL82_RX_DECODER_STATUSr
#define WRITE_CL82_RX_DECODER_STATUSr BCMI_TSC_XGXS_WRITE_CL82_RX_DECODER_STATUSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CL82_RX_DECODER_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CL82_RX_DESKEW_BER_STATUS
 * BLOCKS:   CL82
 * REGADDR:  0xa081
 * DESC:     cl82 rx deskew status register: 00000000
 * SIZE:     32
 * FIELDS:
 *     BERMON_STATE     
 *     LBERMON_STATE    
 *     DESKEW_HIS_STATE 
 *     DESKEW_STATE     
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CL82_RX_DESKEW_BER_STATUSr (0x0020a081 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CL82_RX_DESKEW_BER_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program CL82_RX_DESKEW_BER_STATUS.
 *
 */
typedef union BCMI_TSC_XGXS_CL82_RX_DESKEW_BER_STATUSr_s {
	uint32_t v[1];
	uint32_t cl82_rx_deskew_ber_status[1];
	uint32_t _cl82_rx_deskew_ber_status;
} BCMI_TSC_XGXS_CL82_RX_DESKEW_BER_STATUSr_t;

#define BCMI_TSC_XGXS_CL82_RX_DESKEW_BER_STATUSr_CLR(r) (r).cl82_rx_deskew_ber_status[0] = 0
#define BCMI_TSC_XGXS_CL82_RX_DESKEW_BER_STATUSr_SET(r,d) (r).cl82_rx_deskew_ber_status[0] = d
#define BCMI_TSC_XGXS_CL82_RX_DESKEW_BER_STATUSr_GET(r) (r).cl82_rx_deskew_ber_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CL82_RX_DESKEW_BER_STATUSr_DESKEW_STATEf_GET(r) ((((r).cl82_rx_deskew_ber_status[0]) >> 14) & 0x3)
#define BCMI_TSC_XGXS_CL82_RX_DESKEW_BER_STATUSr_DESKEW_STATEf_SET(r,f) (r).cl82_rx_deskew_ber_status[0]=(((r).cl82_rx_deskew_ber_status[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCMI_TSC_XGXS_CL82_RX_DESKEW_BER_STATUSr_DESKEW_HIS_STATEf_GET(r) ((((r).cl82_rx_deskew_ber_status[0]) >> 12) & 0x3)
#define BCMI_TSC_XGXS_CL82_RX_DESKEW_BER_STATUSr_DESKEW_HIS_STATEf_SET(r,f) (r).cl82_rx_deskew_ber_status[0]=(((r).cl82_rx_deskew_ber_status[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCMI_TSC_XGXS_CL82_RX_DESKEW_BER_STATUSr_LBERMON_STATEf_GET(r) ((((r).cl82_rx_deskew_ber_status[0]) >> 6) & 0x3f)
#define BCMI_TSC_XGXS_CL82_RX_DESKEW_BER_STATUSr_LBERMON_STATEf_SET(r,f) (r).cl82_rx_deskew_ber_status[0]=(((r).cl82_rx_deskew_ber_status[0] & ~((uint32_t)0x3f << 6)) | ((((uint32_t)f) & 0x3f) << 6))
#define BCMI_TSC_XGXS_CL82_RX_DESKEW_BER_STATUSr_BERMON_STATEf_GET(r) (((r).cl82_rx_deskew_ber_status[0]) & 0x3f)
#define BCMI_TSC_XGXS_CL82_RX_DESKEW_BER_STATUSr_BERMON_STATEf_SET(r,f) (r).cl82_rx_deskew_ber_status[0]=(((r).cl82_rx_deskew_ber_status[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))

/*
 * These macros can be used to access CL82_RX_DESKEW_BER_STATUS.
 *
 */
#define BCMI_TSC_XGXS_READ_CL82_RX_DESKEW_BER_STATUSr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CL82_RX_DESKEW_BER_STATUSr,(_r._cl82_rx_deskew_ber_status))
#define BCMI_TSC_XGXS_WRITE_CL82_RX_DESKEW_BER_STATUSr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CL82_RX_DESKEW_BER_STATUSr,(_r._cl82_rx_deskew_ber_status))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL82_RX_DESKEW_BER_STATUSr BCMI_TSC_XGXS_CL82_RX_DESKEW_BER_STATUSr
#define CL82_RX_DESKEW_BER_STATUSr_SIZE BCMI_TSC_XGXS_CL82_RX_DESKEW_BER_STATUSr_SIZE
typedef BCMI_TSC_XGXS_CL82_RX_DESKEW_BER_STATUSr_t CL82_RX_DESKEW_BER_STATUSr_t;
#define CL82_RX_DESKEW_BER_STATUSr_CLR BCMI_TSC_XGXS_CL82_RX_DESKEW_BER_STATUSr_CLR
#define CL82_RX_DESKEW_BER_STATUSr_SET BCMI_TSC_XGXS_CL82_RX_DESKEW_BER_STATUSr_SET
#define CL82_RX_DESKEW_BER_STATUSr_GET BCMI_TSC_XGXS_CL82_RX_DESKEW_BER_STATUSr_GET
#define CL82_RX_DESKEW_BER_STATUSr_DESKEW_STATEf_GET BCMI_TSC_XGXS_CL82_RX_DESKEW_BER_STATUSr_DESKEW_STATEf_GET
#define CL82_RX_DESKEW_BER_STATUSr_DESKEW_STATEf_SET BCMI_TSC_XGXS_CL82_RX_DESKEW_BER_STATUSr_DESKEW_STATEf_SET
#define CL82_RX_DESKEW_BER_STATUSr_DESKEW_HIS_STATEf_GET BCMI_TSC_XGXS_CL82_RX_DESKEW_BER_STATUSr_DESKEW_HIS_STATEf_GET
#define CL82_RX_DESKEW_BER_STATUSr_DESKEW_HIS_STATEf_SET BCMI_TSC_XGXS_CL82_RX_DESKEW_BER_STATUSr_DESKEW_HIS_STATEf_SET
#define CL82_RX_DESKEW_BER_STATUSr_LBERMON_STATEf_GET BCMI_TSC_XGXS_CL82_RX_DESKEW_BER_STATUSr_LBERMON_STATEf_GET
#define CL82_RX_DESKEW_BER_STATUSr_LBERMON_STATEf_SET BCMI_TSC_XGXS_CL82_RX_DESKEW_BER_STATUSr_LBERMON_STATEf_SET
#define CL82_RX_DESKEW_BER_STATUSr_BERMON_STATEf_GET BCMI_TSC_XGXS_CL82_RX_DESKEW_BER_STATUSr_BERMON_STATEf_GET
#define CL82_RX_DESKEW_BER_STATUSr_BERMON_STATEf_SET BCMI_TSC_XGXS_CL82_RX_DESKEW_BER_STATUSr_BERMON_STATEf_SET
#define READ_CL82_RX_DESKEW_BER_STATUSr BCMI_TSC_XGXS_READ_CL82_RX_DESKEW_BER_STATUSr
#define WRITE_CL82_RX_DESKEW_BER_STATUSr BCMI_TSC_XGXS_WRITE_CL82_RX_DESKEW_BER_STATUSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CL82_RX_DESKEW_BER_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CL82_BER_HO
 * BLOCKS:   CL82
 * REGADDR:  0xa085
 * DESC:     CL82 BER HIGH ORDER bits register: 00000000
 * SIZE:     32
 * FIELDS:
 *     CL82_BER_HO      
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CL82_BER_HOr (0x0020a085 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CL82_BER_HOr_SIZE 4

/*
 * This structure should be used to declare and program CL82_BER_HO.
 *
 */
typedef union BCMI_TSC_XGXS_CL82_BER_HOr_s {
	uint32_t v[1];
	uint32_t cl82_ber_ho[1];
	uint32_t _cl82_ber_ho;
} BCMI_TSC_XGXS_CL82_BER_HOr_t;

#define BCMI_TSC_XGXS_CL82_BER_HOr_CLR(r) (r).cl82_ber_ho[0] = 0
#define BCMI_TSC_XGXS_CL82_BER_HOr_SET(r,d) (r).cl82_ber_ho[0] = d
#define BCMI_TSC_XGXS_CL82_BER_HOr_GET(r) (r).cl82_ber_ho[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CL82_BER_HOr_RESERVED0f_GET(r) ((((r).cl82_ber_ho[0]) >> 14) & 0x3)
#define BCMI_TSC_XGXS_CL82_BER_HOr_RESERVED0f_SET(r,f) (r).cl82_ber_ho[0]=(((r).cl82_ber_ho[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCMI_TSC_XGXS_CL82_BER_HOr_CL82_BER_HOf_GET(r) (((r).cl82_ber_ho[0]) & 0x3fff)
#define BCMI_TSC_XGXS_CL82_BER_HOr_CL82_BER_HOf_SET(r,f) (r).cl82_ber_ho[0]=(((r).cl82_ber_ho[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access CL82_BER_HO.
 *
 */
#define BCMI_TSC_XGXS_READ_CL82_BER_HOr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CL82_BER_HOr,(_r._cl82_ber_ho))
#define BCMI_TSC_XGXS_WRITE_CL82_BER_HOr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CL82_BER_HOr,(_r._cl82_ber_ho))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL82_BER_HOr BCMI_TSC_XGXS_CL82_BER_HOr
#define CL82_BER_HOr_SIZE BCMI_TSC_XGXS_CL82_BER_HOr_SIZE
typedef BCMI_TSC_XGXS_CL82_BER_HOr_t CL82_BER_HOr_t;
#define CL82_BER_HOr_CLR BCMI_TSC_XGXS_CL82_BER_HOr_CLR
#define CL82_BER_HOr_SET BCMI_TSC_XGXS_CL82_BER_HOr_SET
#define CL82_BER_HOr_GET BCMI_TSC_XGXS_CL82_BER_HOr_GET
#define CL82_BER_HOr_RESERVED0f_GET BCMI_TSC_XGXS_CL82_BER_HOr_RESERVED0f_GET
#define CL82_BER_HOr_RESERVED0f_SET BCMI_TSC_XGXS_CL82_BER_HOr_RESERVED0f_SET
#define CL82_BER_HOr_CL82_BER_HOf_GET BCMI_TSC_XGXS_CL82_BER_HOr_CL82_BER_HOf_GET
#define CL82_BER_HOr_CL82_BER_HOf_SET BCMI_TSC_XGXS_CL82_BER_HOr_CL82_BER_HOf_SET
#define READ_CL82_BER_HOr BCMI_TSC_XGXS_READ_CL82_BER_HOr
#define WRITE_CL82_BER_HOr BCMI_TSC_XGXS_WRITE_CL82_BER_HOr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CL82_BER_HOr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  ANATX_STATUS0
 * BLOCKS:   ANATX
 * REGADDR:  0xc010
 * DESC:     Tx analog status 0 register: 00000000
 * SIZE:     32
 * FIELDS:
 *     TX_FIR_TAP_PRE   
 *     TX_FIR_TAP_MAIN  
 *     TX_FIR_TAP_POST  
 *     TX_SEL_HALFRATE  
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_ANATX_STATUS0r (0x0000c010 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_ANATX_STATUS0r_SIZE 4

/*
 * This structure should be used to declare and program ANATX_STATUS0.
 *
 */
typedef union BCMI_TSC_XGXS_ANATX_STATUS0r_s {
	uint32_t v[1];
	uint32_t anatx_status0[1];
	uint32_t _anatx_status0;
} BCMI_TSC_XGXS_ANATX_STATUS0r_t;

#define BCMI_TSC_XGXS_ANATX_STATUS0r_CLR(r) (r).anatx_status0[0] = 0
#define BCMI_TSC_XGXS_ANATX_STATUS0r_SET(r,d) (r).anatx_status0[0] = d
#define BCMI_TSC_XGXS_ANATX_STATUS0r_GET(r) (r).anatx_status0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_ANATX_STATUS0r_TX_SEL_HALFRATEf_GET(r) ((((r).anatx_status0[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_ANATX_STATUS0r_TX_SEL_HALFRATEf_SET(r,f) (r).anatx_status0[0]=(((r).anatx_status0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_ANATX_STATUS0r_TX_FIR_TAP_POSTf_GET(r) ((((r).anatx_status0[0]) >> 10) & 0x1f)
#define BCMI_TSC_XGXS_ANATX_STATUS0r_TX_FIR_TAP_POSTf_SET(r,f) (r).anatx_status0[0]=(((r).anatx_status0[0] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10))
#define BCMI_TSC_XGXS_ANATX_STATUS0r_TX_FIR_TAP_MAINf_GET(r) ((((r).anatx_status0[0]) >> 4) & 0x3f)
#define BCMI_TSC_XGXS_ANATX_STATUS0r_TX_FIR_TAP_MAINf_SET(r,f) (r).anatx_status0[0]=(((r).anatx_status0[0] & ~((uint32_t)0x3f << 4)) | ((((uint32_t)f) & 0x3f) << 4))
#define BCMI_TSC_XGXS_ANATX_STATUS0r_TX_FIR_TAP_PREf_GET(r) (((r).anatx_status0[0]) & 0xf)
#define BCMI_TSC_XGXS_ANATX_STATUS0r_TX_FIR_TAP_PREf_SET(r,f) (r).anatx_status0[0]=(((r).anatx_status0[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access ANATX_STATUS0.
 *
 */
#define BCMI_TSC_XGXS_READ_ANATX_STATUS0r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_ANATX_STATUS0r,(_r._anatx_status0))
#define BCMI_TSC_XGXS_WRITE_ANATX_STATUS0r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_ANATX_STATUS0r,(_r._anatx_status0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define ANATX_STATUS0r BCMI_TSC_XGXS_ANATX_STATUS0r
#define ANATX_STATUS0r_SIZE BCMI_TSC_XGXS_ANATX_STATUS0r_SIZE
typedef BCMI_TSC_XGXS_ANATX_STATUS0r_t ANATX_STATUS0r_t;
#define ANATX_STATUS0r_CLR BCMI_TSC_XGXS_ANATX_STATUS0r_CLR
#define ANATX_STATUS0r_SET BCMI_TSC_XGXS_ANATX_STATUS0r_SET
#define ANATX_STATUS0r_GET BCMI_TSC_XGXS_ANATX_STATUS0r_GET
#define ANATX_STATUS0r_TX_SEL_HALFRATEf_GET BCMI_TSC_XGXS_ANATX_STATUS0r_TX_SEL_HALFRATEf_GET
#define ANATX_STATUS0r_TX_SEL_HALFRATEf_SET BCMI_TSC_XGXS_ANATX_STATUS0r_TX_SEL_HALFRATEf_SET
#define ANATX_STATUS0r_TX_FIR_TAP_POSTf_GET BCMI_TSC_XGXS_ANATX_STATUS0r_TX_FIR_TAP_POSTf_GET
#define ANATX_STATUS0r_TX_FIR_TAP_POSTf_SET BCMI_TSC_XGXS_ANATX_STATUS0r_TX_FIR_TAP_POSTf_SET
#define ANATX_STATUS0r_TX_FIR_TAP_MAINf_GET BCMI_TSC_XGXS_ANATX_STATUS0r_TX_FIR_TAP_MAINf_GET
#define ANATX_STATUS0r_TX_FIR_TAP_MAINf_SET BCMI_TSC_XGXS_ANATX_STATUS0r_TX_FIR_TAP_MAINf_SET
#define ANATX_STATUS0r_TX_FIR_TAP_PREf_GET BCMI_TSC_XGXS_ANATX_STATUS0r_TX_FIR_TAP_PREf_GET
#define ANATX_STATUS0r_TX_FIR_TAP_PREf_SET BCMI_TSC_XGXS_ANATX_STATUS0r_TX_FIR_TAP_PREf_SET
#define READ_ANATX_STATUS0r BCMI_TSC_XGXS_READ_ANATX_STATUS0r
#define WRITE_ANATX_STATUS0r BCMI_TSC_XGXS_WRITE_ANATX_STATUS0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_ANATX_STATUS0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  ANATX_CONTROL0
 * BLOCKS:   ANATX
 * REGADDR:  0xc011
 * DESC:     Tx analog control 0 register: 00000000
 * SIZE:     32
 * FIELDS:
 *     RESERVED1        
 *     TXPOL_FLIP       
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_ANATX_CONTROL0r (0x0000c011 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_ANATX_CONTROL0r_SIZE 4

/*
 * This structure should be used to declare and program ANATX_CONTROL0.
 *
 */
typedef union BCMI_TSC_XGXS_ANATX_CONTROL0r_s {
	uint32_t v[1];
	uint32_t anatx_control0[1];
	uint32_t _anatx_control0;
} BCMI_TSC_XGXS_ANATX_CONTROL0r_t;

#define BCMI_TSC_XGXS_ANATX_CONTROL0r_CLR(r) (r).anatx_control0[0] = 0
#define BCMI_TSC_XGXS_ANATX_CONTROL0r_SET(r,d) (r).anatx_control0[0] = d
#define BCMI_TSC_XGXS_ANATX_CONTROL0r_GET(r) (r).anatx_control0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_ANATX_CONTROL0r_RESERVED0f_GET(r) ((((r).anatx_control0[0]) >> 6) & 0x3ff)
#define BCMI_TSC_XGXS_ANATX_CONTROL0r_RESERVED0f_SET(r,f) (r).anatx_control0[0]=(((r).anatx_control0[0] & ~((uint32_t)0x3ff << 6)) | ((((uint32_t)f) & 0x3ff) << 6))
#define BCMI_TSC_XGXS_ANATX_CONTROL0r_TXPOL_FLIPf_GET(r) ((((r).anatx_control0[0]) >> 5) & 0x1)
#define BCMI_TSC_XGXS_ANATX_CONTROL0r_TXPOL_FLIPf_SET(r,f) (r).anatx_control0[0]=(((r).anatx_control0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCMI_TSC_XGXS_ANATX_CONTROL0r_RESERVED1f_GET(r) (((r).anatx_control0[0]) & 0x1f)
#define BCMI_TSC_XGXS_ANATX_CONTROL0r_RESERVED1f_SET(r,f) (r).anatx_control0[0]=(((r).anatx_control0[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))

/*
 * These macros can be used to access ANATX_CONTROL0.
 *
 */
#define BCMI_TSC_XGXS_READ_ANATX_CONTROL0r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_ANATX_CONTROL0r,(_r._anatx_control0))
#define BCMI_TSC_XGXS_WRITE_ANATX_CONTROL0r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_ANATX_CONTROL0r,(_r._anatx_control0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define ANATX_CONTROL0r BCMI_TSC_XGXS_ANATX_CONTROL0r
#define ANATX_CONTROL0r_SIZE BCMI_TSC_XGXS_ANATX_CONTROL0r_SIZE
typedef BCMI_TSC_XGXS_ANATX_CONTROL0r_t ANATX_CONTROL0r_t;
#define ANATX_CONTROL0r_CLR BCMI_TSC_XGXS_ANATX_CONTROL0r_CLR
#define ANATX_CONTROL0r_SET BCMI_TSC_XGXS_ANATX_CONTROL0r_SET
#define ANATX_CONTROL0r_GET BCMI_TSC_XGXS_ANATX_CONTROL0r_GET
#define ANATX_CONTROL0r_RESERVED0f_GET BCMI_TSC_XGXS_ANATX_CONTROL0r_RESERVED0f_GET
#define ANATX_CONTROL0r_RESERVED0f_SET BCMI_TSC_XGXS_ANATX_CONTROL0r_RESERVED0f_SET
#define ANATX_CONTROL0r_TXPOL_FLIPf_GET BCMI_TSC_XGXS_ANATX_CONTROL0r_TXPOL_FLIPf_GET
#define ANATX_CONTROL0r_TXPOL_FLIPf_SET BCMI_TSC_XGXS_ANATX_CONTROL0r_TXPOL_FLIPf_SET
#define ANATX_CONTROL0r_RESERVED1f_GET BCMI_TSC_XGXS_ANATX_CONTROL0r_RESERVED1f_GET
#define ANATX_CONTROL0r_RESERVED1f_SET BCMI_TSC_XGXS_ANATX_CONTROL0r_RESERVED1f_SET
#define READ_ANATX_CONTROL0r BCMI_TSC_XGXS_READ_ANATX_CONTROL0r
#define WRITE_ANATX_CONTROL0r BCMI_TSC_XGXS_WRITE_ANATX_CONTROL0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_ANATX_CONTROL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  ANATX_STATUS1
 * BLOCKS:   ANATX
 * REGADDR:  0xc014
 * DESC:     Tx analog status 1 register (AFE tx_sts[15:0]): 00000000
 * SIZE:     32
 * FIELDS:
 *     TX_STS           
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_ANATX_STATUS1r (0x0000c014 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_ANATX_STATUS1r_SIZE 4

/*
 * This structure should be used to declare and program ANATX_STATUS1.
 *
 */
typedef union BCMI_TSC_XGXS_ANATX_STATUS1r_s {
	uint32_t v[1];
	uint32_t anatx_status1[1];
	uint32_t _anatx_status1;
} BCMI_TSC_XGXS_ANATX_STATUS1r_t;

#define BCMI_TSC_XGXS_ANATX_STATUS1r_CLR(r) (r).anatx_status1[0] = 0
#define BCMI_TSC_XGXS_ANATX_STATUS1r_SET(r,d) (r).anatx_status1[0] = d
#define BCMI_TSC_XGXS_ANATX_STATUS1r_GET(r) (r).anatx_status1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_ANATX_STATUS1r_TX_STSf_GET(r) (((r).anatx_status1[0]) & 0xffff)
#define BCMI_TSC_XGXS_ANATX_STATUS1r_TX_STSf_SET(r,f) (r).anatx_status1[0]=(((r).anatx_status1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access ANATX_STATUS1.
 *
 */
#define BCMI_TSC_XGXS_READ_ANATX_STATUS1r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_ANATX_STATUS1r,(_r._anatx_status1))
#define BCMI_TSC_XGXS_WRITE_ANATX_STATUS1r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_ANATX_STATUS1r,(_r._anatx_status1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define ANATX_STATUS1r BCMI_TSC_XGXS_ANATX_STATUS1r
#define ANATX_STATUS1r_SIZE BCMI_TSC_XGXS_ANATX_STATUS1r_SIZE
typedef BCMI_TSC_XGXS_ANATX_STATUS1r_t ANATX_STATUS1r_t;
#define ANATX_STATUS1r_CLR BCMI_TSC_XGXS_ANATX_STATUS1r_CLR
#define ANATX_STATUS1r_SET BCMI_TSC_XGXS_ANATX_STATUS1r_SET
#define ANATX_STATUS1r_GET BCMI_TSC_XGXS_ANATX_STATUS1r_GET
#define ANATX_STATUS1r_TX_STSf_GET BCMI_TSC_XGXS_ANATX_STATUS1r_TX_STSf_GET
#define ANATX_STATUS1r_TX_STSf_SET BCMI_TSC_XGXS_ANATX_STATUS1r_TX_STSf_SET
#define READ_ANATX_STATUS1r BCMI_TSC_XGXS_READ_ANATX_STATUS1r
#define WRITE_ANATX_STATUS1r BCMI_TSC_XGXS_WRITE_ANATX_STATUS1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_ANATX_STATUS1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  ANATX_CONTROL1
 * BLOCKS:   ANATX
 * REGADDR:  0xc015
 * DESC:     Tx reserved analog control register (AFE tx_ctrl[15:00], not applicable to XFICore): 00000000
 * SIZE:     32
 * FIELDS:
 *     IBIAS            
 *     AMP_CTRL         
 *     RESERVED0        
 *     TICKSEL          
 *     VDDR_BGB         
 *     DRIVERMODE       
 *     NEWBIAS_EN       
 *     REFH_TX          
 *     REFL_TX          
 *     IPREDRV          
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_ANATX_CONTROL1r (0x0000c015 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_ANATX_CONTROL1r_SIZE 4

/*
 * This structure should be used to declare and program ANATX_CONTROL1.
 *
 */
typedef union BCMI_TSC_XGXS_ANATX_CONTROL1r_s {
	uint32_t v[1];
	uint32_t anatx_control1[1];
	uint32_t _anatx_control1;
} BCMI_TSC_XGXS_ANATX_CONTROL1r_t;

#define BCMI_TSC_XGXS_ANATX_CONTROL1r_CLR(r) (r).anatx_control1[0] = 0
#define BCMI_TSC_XGXS_ANATX_CONTROL1r_SET(r,d) (r).anatx_control1[0] = d
#define BCMI_TSC_XGXS_ANATX_CONTROL1r_GET(r) (r).anatx_control1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_ANATX_CONTROL1r_IPREDRVf_GET(r) ((((r).anatx_control1[0]) >> 13) & 0x7)
#define BCMI_TSC_XGXS_ANATX_CONTROL1r_IPREDRVf_SET(r,f) (r).anatx_control1[0]=(((r).anatx_control1[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))
#define BCMI_TSC_XGXS_ANATX_CONTROL1r_REFL_TXf_GET(r) ((((r).anatx_control1[0]) >> 12) & 0x1)
#define BCMI_TSC_XGXS_ANATX_CONTROL1r_REFL_TXf_SET(r,f) (r).anatx_control1[0]=(((r).anatx_control1[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCMI_TSC_XGXS_ANATX_CONTROL1r_REFH_TXf_GET(r) ((((r).anatx_control1[0]) >> 11) & 0x1)
#define BCMI_TSC_XGXS_ANATX_CONTROL1r_REFH_TXf_SET(r,f) (r).anatx_control1[0]=(((r).anatx_control1[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCMI_TSC_XGXS_ANATX_CONTROL1r_NEWBIAS_ENf_GET(r) ((((r).anatx_control1[0]) >> 10) & 0x1)
#define BCMI_TSC_XGXS_ANATX_CONTROL1r_NEWBIAS_ENf_SET(r,f) (r).anatx_control1[0]=(((r).anatx_control1[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCMI_TSC_XGXS_ANATX_CONTROL1r_DRIVERMODEf_GET(r) ((((r).anatx_control1[0]) >> 9) & 0x1)
#define BCMI_TSC_XGXS_ANATX_CONTROL1r_DRIVERMODEf_SET(r,f) (r).anatx_control1[0]=(((r).anatx_control1[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCMI_TSC_XGXS_ANATX_CONTROL1r_VDDR_BGBf_GET(r) ((((r).anatx_control1[0]) >> 8) & 0x1)
#define BCMI_TSC_XGXS_ANATX_CONTROL1r_VDDR_BGBf_SET(r,f) (r).anatx_control1[0]=(((r).anatx_control1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCMI_TSC_XGXS_ANATX_CONTROL1r_TICKSELf_GET(r) ((((r).anatx_control1[0]) >> 6) & 0x3)
#define BCMI_TSC_XGXS_ANATX_CONTROL1r_TICKSELf_SET(r,f) (r).anatx_control1[0]=(((r).anatx_control1[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCMI_TSC_XGXS_ANATX_CONTROL1r_RESERVED0f_GET(r) ((((r).anatx_control1[0]) >> 4) & 0x3)
#define BCMI_TSC_XGXS_ANATX_CONTROL1r_RESERVED0f_SET(r,f) (r).anatx_control1[0]=(((r).anatx_control1[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCMI_TSC_XGXS_ANATX_CONTROL1r_AMP_CTRLf_GET(r) ((((r).anatx_control1[0]) >> 3) & 0x1)
#define BCMI_TSC_XGXS_ANATX_CONTROL1r_AMP_CTRLf_SET(r,f) (r).anatx_control1[0]=(((r).anatx_control1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCMI_TSC_XGXS_ANATX_CONTROL1r_IBIASf_GET(r) (((r).anatx_control1[0]) & 0x7)
#define BCMI_TSC_XGXS_ANATX_CONTROL1r_IBIASf_SET(r,f) (r).anatx_control1[0]=(((r).anatx_control1[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))

/*
 * These macros can be used to access ANATX_CONTROL1.
 *
 */
#define BCMI_TSC_XGXS_READ_ANATX_CONTROL1r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_ANATX_CONTROL1r,(_r._anatx_control1))
#define BCMI_TSC_XGXS_WRITE_ANATX_CONTROL1r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_ANATX_CONTROL1r,(_r._anatx_control1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define ANATX_CONTROL1r BCMI_TSC_XGXS_ANATX_CONTROL1r
#define ANATX_CONTROL1r_SIZE BCMI_TSC_XGXS_ANATX_CONTROL1r_SIZE
typedef BCMI_TSC_XGXS_ANATX_CONTROL1r_t ANATX_CONTROL1r_t;
#define ANATX_CONTROL1r_CLR BCMI_TSC_XGXS_ANATX_CONTROL1r_CLR
#define ANATX_CONTROL1r_SET BCMI_TSC_XGXS_ANATX_CONTROL1r_SET
#define ANATX_CONTROL1r_GET BCMI_TSC_XGXS_ANATX_CONTROL1r_GET
#define ANATX_CONTROL1r_IPREDRVf_GET BCMI_TSC_XGXS_ANATX_CONTROL1r_IPREDRVf_GET
#define ANATX_CONTROL1r_IPREDRVf_SET BCMI_TSC_XGXS_ANATX_CONTROL1r_IPREDRVf_SET
#define ANATX_CONTROL1r_REFL_TXf_GET BCMI_TSC_XGXS_ANATX_CONTROL1r_REFL_TXf_GET
#define ANATX_CONTROL1r_REFL_TXf_SET BCMI_TSC_XGXS_ANATX_CONTROL1r_REFL_TXf_SET
#define ANATX_CONTROL1r_REFH_TXf_GET BCMI_TSC_XGXS_ANATX_CONTROL1r_REFH_TXf_GET
#define ANATX_CONTROL1r_REFH_TXf_SET BCMI_TSC_XGXS_ANATX_CONTROL1r_REFH_TXf_SET
#define ANATX_CONTROL1r_NEWBIAS_ENf_GET BCMI_TSC_XGXS_ANATX_CONTROL1r_NEWBIAS_ENf_GET
#define ANATX_CONTROL1r_NEWBIAS_ENf_SET BCMI_TSC_XGXS_ANATX_CONTROL1r_NEWBIAS_ENf_SET
#define ANATX_CONTROL1r_DRIVERMODEf_GET BCMI_TSC_XGXS_ANATX_CONTROL1r_DRIVERMODEf_GET
#define ANATX_CONTROL1r_DRIVERMODEf_SET BCMI_TSC_XGXS_ANATX_CONTROL1r_DRIVERMODEf_SET
#define ANATX_CONTROL1r_VDDR_BGBf_GET BCMI_TSC_XGXS_ANATX_CONTROL1r_VDDR_BGBf_GET
#define ANATX_CONTROL1r_VDDR_BGBf_SET BCMI_TSC_XGXS_ANATX_CONTROL1r_VDDR_BGBf_SET
#define ANATX_CONTROL1r_TICKSELf_GET BCMI_TSC_XGXS_ANATX_CONTROL1r_TICKSELf_GET
#define ANATX_CONTROL1r_TICKSELf_SET BCMI_TSC_XGXS_ANATX_CONTROL1r_TICKSELf_SET
#define ANATX_CONTROL1r_RESERVED0f_GET BCMI_TSC_XGXS_ANATX_CONTROL1r_RESERVED0f_GET
#define ANATX_CONTROL1r_RESERVED0f_SET BCMI_TSC_XGXS_ANATX_CONTROL1r_RESERVED0f_SET
#define ANATX_CONTROL1r_AMP_CTRLf_GET BCMI_TSC_XGXS_ANATX_CONTROL1r_AMP_CTRLf_GET
#define ANATX_CONTROL1r_AMP_CTRLf_SET BCMI_TSC_XGXS_ANATX_CONTROL1r_AMP_CTRLf_SET
#define ANATX_CONTROL1r_IBIASf_GET BCMI_TSC_XGXS_ANATX_CONTROL1r_IBIASf_GET
#define ANATX_CONTROL1r_IBIASf_SET BCMI_TSC_XGXS_ANATX_CONTROL1r_IBIASf_SET
#define READ_ANATX_CONTROL1r BCMI_TSC_XGXS_READ_ANATX_CONTROL1r
#define WRITE_ANATX_CONTROL1r BCMI_TSC_XGXS_WRITE_ANATX_CONTROL1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_ANATX_CONTROL1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  ANATX_CONTROL2
 * BLOCKS:   ANATX
 * REGADDR:  0xc016
 * DESC:     Tx reserved analog control register (AFE tx_ctrl[31:16], not applicable to XFICore): 00000000
 * SIZE:     32
 * FIELDS:
 *     RESERVED0        
 *     IMODE_DRVR       
 *     IMAX_DRVR        
 *     IMIN_DRVR        
 *     IMUX             
 *     IMODE_PREDRV     
 *     IMAX_PREDRV      
 *     IMIN_PREDRV      
 *     ICKBUF2T         
 *     ICKBUF           
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_ANATX_CONTROL2r (0x0000c016 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_ANATX_CONTROL2r_SIZE 4

/*
 * This structure should be used to declare and program ANATX_CONTROL2.
 *
 */
typedef union BCMI_TSC_XGXS_ANATX_CONTROL2r_s {
	uint32_t v[1];
	uint32_t anatx_control2[1];
	uint32_t _anatx_control2;
} BCMI_TSC_XGXS_ANATX_CONTROL2r_t;

#define BCMI_TSC_XGXS_ANATX_CONTROL2r_CLR(r) (r).anatx_control2[0] = 0
#define BCMI_TSC_XGXS_ANATX_CONTROL2r_SET(r,d) (r).anatx_control2[0] = d
#define BCMI_TSC_XGXS_ANATX_CONTROL2r_GET(r) (r).anatx_control2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_ANATX_CONTROL2r_ICKBUFf_GET(r) ((((r).anatx_control2[0]) >> 14) & 0x3)
#define BCMI_TSC_XGXS_ANATX_CONTROL2r_ICKBUFf_SET(r,f) (r).anatx_control2[0]=(((r).anatx_control2[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCMI_TSC_XGXS_ANATX_CONTROL2r_ICKBUF2Tf_GET(r) ((((r).anatx_control2[0]) >> 11) & 0x7)
#define BCMI_TSC_XGXS_ANATX_CONTROL2r_ICKBUF2Tf_SET(r,f) (r).anatx_control2[0]=(((r).anatx_control2[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11))
#define BCMI_TSC_XGXS_ANATX_CONTROL2r_IMIN_PREDRVf_GET(r) ((((r).anatx_control2[0]) >> 10) & 0x1)
#define BCMI_TSC_XGXS_ANATX_CONTROL2r_IMIN_PREDRVf_SET(r,f) (r).anatx_control2[0]=(((r).anatx_control2[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCMI_TSC_XGXS_ANATX_CONTROL2r_IMAX_PREDRVf_GET(r) ((((r).anatx_control2[0]) >> 9) & 0x1)
#define BCMI_TSC_XGXS_ANATX_CONTROL2r_IMAX_PREDRVf_SET(r,f) (r).anatx_control2[0]=(((r).anatx_control2[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCMI_TSC_XGXS_ANATX_CONTROL2r_IMODE_PREDRVf_GET(r) ((((r).anatx_control2[0]) >> 8) & 0x1)
#define BCMI_TSC_XGXS_ANATX_CONTROL2r_IMODE_PREDRVf_SET(r,f) (r).anatx_control2[0]=(((r).anatx_control2[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCMI_TSC_XGXS_ANATX_CONTROL2r_IMUXf_GET(r) ((((r).anatx_control2[0]) >> 5) & 0x7)
#define BCMI_TSC_XGXS_ANATX_CONTROL2r_IMUXf_SET(r,f) (r).anatx_control2[0]=(((r).anatx_control2[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))
#define BCMI_TSC_XGXS_ANATX_CONTROL2r_IMIN_DRVRf_GET(r) ((((r).anatx_control2[0]) >> 4) & 0x1)
#define BCMI_TSC_XGXS_ANATX_CONTROL2r_IMIN_DRVRf_SET(r,f) (r).anatx_control2[0]=(((r).anatx_control2[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCMI_TSC_XGXS_ANATX_CONTROL2r_IMAX_DRVRf_GET(r) ((((r).anatx_control2[0]) >> 3) & 0x1)
#define BCMI_TSC_XGXS_ANATX_CONTROL2r_IMAX_DRVRf_SET(r,f) (r).anatx_control2[0]=(((r).anatx_control2[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCMI_TSC_XGXS_ANATX_CONTROL2r_IMODE_DRVRf_GET(r) ((((r).anatx_control2[0]) >> 2) & 0x1)
#define BCMI_TSC_XGXS_ANATX_CONTROL2r_IMODE_DRVRf_SET(r,f) (r).anatx_control2[0]=(((r).anatx_control2[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCMI_TSC_XGXS_ANATX_CONTROL2r_RESERVED0f_GET(r) (((r).anatx_control2[0]) & 0x3)
#define BCMI_TSC_XGXS_ANATX_CONTROL2r_RESERVED0f_SET(r,f) (r).anatx_control2[0]=(((r).anatx_control2[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))

/*
 * These macros can be used to access ANATX_CONTROL2.
 *
 */
#define BCMI_TSC_XGXS_READ_ANATX_CONTROL2r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_ANATX_CONTROL2r,(_r._anatx_control2))
#define BCMI_TSC_XGXS_WRITE_ANATX_CONTROL2r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_ANATX_CONTROL2r,(_r._anatx_control2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define ANATX_CONTROL2r BCMI_TSC_XGXS_ANATX_CONTROL2r
#define ANATX_CONTROL2r_SIZE BCMI_TSC_XGXS_ANATX_CONTROL2r_SIZE
typedef BCMI_TSC_XGXS_ANATX_CONTROL2r_t ANATX_CONTROL2r_t;
#define ANATX_CONTROL2r_CLR BCMI_TSC_XGXS_ANATX_CONTROL2r_CLR
#define ANATX_CONTROL2r_SET BCMI_TSC_XGXS_ANATX_CONTROL2r_SET
#define ANATX_CONTROL2r_GET BCMI_TSC_XGXS_ANATX_CONTROL2r_GET
#define ANATX_CONTROL2r_ICKBUFf_GET BCMI_TSC_XGXS_ANATX_CONTROL2r_ICKBUFf_GET
#define ANATX_CONTROL2r_ICKBUFf_SET BCMI_TSC_XGXS_ANATX_CONTROL2r_ICKBUFf_SET
#define ANATX_CONTROL2r_ICKBUF2Tf_GET BCMI_TSC_XGXS_ANATX_CONTROL2r_ICKBUF2Tf_GET
#define ANATX_CONTROL2r_ICKBUF2Tf_SET BCMI_TSC_XGXS_ANATX_CONTROL2r_ICKBUF2Tf_SET
#define ANATX_CONTROL2r_IMIN_PREDRVf_GET BCMI_TSC_XGXS_ANATX_CONTROL2r_IMIN_PREDRVf_GET
#define ANATX_CONTROL2r_IMIN_PREDRVf_SET BCMI_TSC_XGXS_ANATX_CONTROL2r_IMIN_PREDRVf_SET
#define ANATX_CONTROL2r_IMAX_PREDRVf_GET BCMI_TSC_XGXS_ANATX_CONTROL2r_IMAX_PREDRVf_GET
#define ANATX_CONTROL2r_IMAX_PREDRVf_SET BCMI_TSC_XGXS_ANATX_CONTROL2r_IMAX_PREDRVf_SET
#define ANATX_CONTROL2r_IMODE_PREDRVf_GET BCMI_TSC_XGXS_ANATX_CONTROL2r_IMODE_PREDRVf_GET
#define ANATX_CONTROL2r_IMODE_PREDRVf_SET BCMI_TSC_XGXS_ANATX_CONTROL2r_IMODE_PREDRVf_SET
#define ANATX_CONTROL2r_IMUXf_GET BCMI_TSC_XGXS_ANATX_CONTROL2r_IMUXf_GET
#define ANATX_CONTROL2r_IMUXf_SET BCMI_TSC_XGXS_ANATX_CONTROL2r_IMUXf_SET
#define ANATX_CONTROL2r_IMIN_DRVRf_GET BCMI_TSC_XGXS_ANATX_CONTROL2r_IMIN_DRVRf_GET
#define ANATX_CONTROL2r_IMIN_DRVRf_SET BCMI_TSC_XGXS_ANATX_CONTROL2r_IMIN_DRVRf_SET
#define ANATX_CONTROL2r_IMAX_DRVRf_GET BCMI_TSC_XGXS_ANATX_CONTROL2r_IMAX_DRVRf_GET
#define ANATX_CONTROL2r_IMAX_DRVRf_SET BCMI_TSC_XGXS_ANATX_CONTROL2r_IMAX_DRVRf_SET
#define ANATX_CONTROL2r_IMODE_DRVRf_GET BCMI_TSC_XGXS_ANATX_CONTROL2r_IMODE_DRVRf_GET
#define ANATX_CONTROL2r_IMODE_DRVRf_SET BCMI_TSC_XGXS_ANATX_CONTROL2r_IMODE_DRVRf_SET
#define ANATX_CONTROL2r_RESERVED0f_GET BCMI_TSC_XGXS_ANATX_CONTROL2r_RESERVED0f_GET
#define ANATX_CONTROL2r_RESERVED0f_SET BCMI_TSC_XGXS_ANATX_CONTROL2r_RESERVED0f_SET
#define READ_ANATX_CONTROL2r BCMI_TSC_XGXS_READ_ANATX_CONTROL2r
#define WRITE_ANATX_CONTROL2r BCMI_TSC_XGXS_WRITE_ANATX_CONTROL2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_ANATX_CONTROL2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  ANATX_DRIVER
 * BLOCKS:   ANATX
 * REGADDR:  0xc017
 * DESC:     Tx reserved analog control register (AFE tx_ctrl[47:32], not applicable to XFICore): 00000000
 * SIZE:     32
 * FIELDS:
 *     ICKBUF2          
 *     IFIR             
 *     IPREDRIVER       
 *     IDRIVER          
 *     POST2_COEFF      
 *     ELEC_IDLE        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_ANATX_DRIVERr (0x0000c017 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_ANATX_DRIVERr_SIZE 4

/*
 * This structure should be used to declare and program ANATX_DRIVER.
 *
 */
typedef union BCMI_TSC_XGXS_ANATX_DRIVERr_s {
	uint32_t v[1];
	uint32_t anatx_driver[1];
	uint32_t _anatx_driver;
} BCMI_TSC_XGXS_ANATX_DRIVERr_t;

#define BCMI_TSC_XGXS_ANATX_DRIVERr_CLR(r) (r).anatx_driver[0] = 0
#define BCMI_TSC_XGXS_ANATX_DRIVERr_SET(r,d) (r).anatx_driver[0] = d
#define BCMI_TSC_XGXS_ANATX_DRIVERr_GET(r) (r).anatx_driver[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_ANATX_DRIVERr_ELEC_IDLEf_GET(r) ((((r).anatx_driver[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_ANATX_DRIVERr_ELEC_IDLEf_SET(r,f) (r).anatx_driver[0]=(((r).anatx_driver[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_ANATX_DRIVERr_POST2_COEFFf_GET(r) ((((r).anatx_driver[0]) >> 12) & 0x7)
#define BCMI_TSC_XGXS_ANATX_DRIVERr_POST2_COEFFf_SET(r,f) (r).anatx_driver[0]=(((r).anatx_driver[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCMI_TSC_XGXS_ANATX_DRIVERr_IDRIVERf_GET(r) ((((r).anatx_driver[0]) >> 8) & 0xf)
#define BCMI_TSC_XGXS_ANATX_DRIVERr_IDRIVERf_SET(r,f) (r).anatx_driver[0]=(((r).anatx_driver[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCMI_TSC_XGXS_ANATX_DRIVERr_IPREDRIVERf_GET(r) ((((r).anatx_driver[0]) >> 4) & 0xf)
#define BCMI_TSC_XGXS_ANATX_DRIVERr_IPREDRIVERf_SET(r,f) (r).anatx_driver[0]=(((r).anatx_driver[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCMI_TSC_XGXS_ANATX_DRIVERr_IFIRf_GET(r) ((((r).anatx_driver[0]) >> 1) & 0x7)
#define BCMI_TSC_XGXS_ANATX_DRIVERr_IFIRf_SET(r,f) (r).anatx_driver[0]=(((r).anatx_driver[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define BCMI_TSC_XGXS_ANATX_DRIVERr_ICKBUF2f_GET(r) (((r).anatx_driver[0]) & 0x1)
#define BCMI_TSC_XGXS_ANATX_DRIVERr_ICKBUF2f_SET(r,f) (r).anatx_driver[0]=(((r).anatx_driver[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access ANATX_DRIVER.
 *
 */
#define BCMI_TSC_XGXS_READ_ANATX_DRIVERr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_ANATX_DRIVERr,(_r._anatx_driver))
#define BCMI_TSC_XGXS_WRITE_ANATX_DRIVERr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_ANATX_DRIVERr,(_r._anatx_driver))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define ANATX_DRIVERr BCMI_TSC_XGXS_ANATX_DRIVERr
#define ANATX_DRIVERr_SIZE BCMI_TSC_XGXS_ANATX_DRIVERr_SIZE
typedef BCMI_TSC_XGXS_ANATX_DRIVERr_t ANATX_DRIVERr_t;
#define ANATX_DRIVERr_CLR BCMI_TSC_XGXS_ANATX_DRIVERr_CLR
#define ANATX_DRIVERr_SET BCMI_TSC_XGXS_ANATX_DRIVERr_SET
#define ANATX_DRIVERr_GET BCMI_TSC_XGXS_ANATX_DRIVERr_GET
#define ANATX_DRIVERr_ELEC_IDLEf_GET BCMI_TSC_XGXS_ANATX_DRIVERr_ELEC_IDLEf_GET
#define ANATX_DRIVERr_ELEC_IDLEf_SET BCMI_TSC_XGXS_ANATX_DRIVERr_ELEC_IDLEf_SET
#define ANATX_DRIVERr_POST2_COEFFf_GET BCMI_TSC_XGXS_ANATX_DRIVERr_POST2_COEFFf_GET
#define ANATX_DRIVERr_POST2_COEFFf_SET BCMI_TSC_XGXS_ANATX_DRIVERr_POST2_COEFFf_SET
#define ANATX_DRIVERr_IDRIVERf_GET BCMI_TSC_XGXS_ANATX_DRIVERr_IDRIVERf_GET
#define ANATX_DRIVERr_IDRIVERf_SET BCMI_TSC_XGXS_ANATX_DRIVERr_IDRIVERf_SET
#define ANATX_DRIVERr_IPREDRIVERf_GET BCMI_TSC_XGXS_ANATX_DRIVERr_IPREDRIVERf_GET
#define ANATX_DRIVERr_IPREDRIVERf_SET BCMI_TSC_XGXS_ANATX_DRIVERr_IPREDRIVERf_SET
#define ANATX_DRIVERr_IFIRf_GET BCMI_TSC_XGXS_ANATX_DRIVERr_IFIRf_GET
#define ANATX_DRIVERr_IFIRf_SET BCMI_TSC_XGXS_ANATX_DRIVERr_IFIRf_SET
#define ANATX_DRIVERr_ICKBUF2f_GET BCMI_TSC_XGXS_ANATX_DRIVERr_ICKBUF2f_GET
#define ANATX_DRIVERr_ICKBUF2f_SET BCMI_TSC_XGXS_ANATX_DRIVERr_ICKBUF2f_SET
#define READ_ANATX_DRIVERr BCMI_TSC_XGXS_READ_ANATX_DRIVERr
#define WRITE_ANATX_DRIVERr BCMI_TSC_XGXS_WRITE_ANATX_DRIVERr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_ANATX_DRIVERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  ANATX_CONTROL5
 * BLOCKS:   ANATX
 * REGADDR:  0xc019
 * DESC:     Tx analog control 5 register: 00000000
 * SIZE:     32
 * FIELDS:
 *     FORCE_TX_SEL_HALFRATE 
 *     FORCE_TX_SEL_HALFRATE_VAL 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_ANATX_CONTROL5r (0x0000c019 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_ANATX_CONTROL5r_SIZE 4

/*
 * This structure should be used to declare and program ANATX_CONTROL5.
 *
 */
typedef union BCMI_TSC_XGXS_ANATX_CONTROL5r_s {
	uint32_t v[1];
	uint32_t anatx_control5[1];
	uint32_t _anatx_control5;
} BCMI_TSC_XGXS_ANATX_CONTROL5r_t;

#define BCMI_TSC_XGXS_ANATX_CONTROL5r_CLR(r) (r).anatx_control5[0] = 0
#define BCMI_TSC_XGXS_ANATX_CONTROL5r_SET(r,d) (r).anatx_control5[0] = d
#define BCMI_TSC_XGXS_ANATX_CONTROL5r_GET(r) (r).anatx_control5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_ANATX_CONTROL5r_RESERVED0f_GET(r) ((((r).anatx_control5[0]) >> 2) & 0x3fff)
#define BCMI_TSC_XGXS_ANATX_CONTROL5r_RESERVED0f_SET(r,f) (r).anatx_control5[0]=(((r).anatx_control5[0] & ~((uint32_t)0x3fff << 2)) | ((((uint32_t)f) & 0x3fff) << 2))
#define BCMI_TSC_XGXS_ANATX_CONTROL5r_FORCE_TX_SEL_HALFRATE_VALf_GET(r) ((((r).anatx_control5[0]) >> 1) & 0x1)
#define BCMI_TSC_XGXS_ANATX_CONTROL5r_FORCE_TX_SEL_HALFRATE_VALf_SET(r,f) (r).anatx_control5[0]=(((r).anatx_control5[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCMI_TSC_XGXS_ANATX_CONTROL5r_FORCE_TX_SEL_HALFRATEf_GET(r) (((r).anatx_control5[0]) & 0x1)
#define BCMI_TSC_XGXS_ANATX_CONTROL5r_FORCE_TX_SEL_HALFRATEf_SET(r,f) (r).anatx_control5[0]=(((r).anatx_control5[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access ANATX_CONTROL5.
 *
 */
#define BCMI_TSC_XGXS_READ_ANATX_CONTROL5r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_ANATX_CONTROL5r,(_r._anatx_control5))
#define BCMI_TSC_XGXS_WRITE_ANATX_CONTROL5r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_ANATX_CONTROL5r,(_r._anatx_control5))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define ANATX_CONTROL5r BCMI_TSC_XGXS_ANATX_CONTROL5r
#define ANATX_CONTROL5r_SIZE BCMI_TSC_XGXS_ANATX_CONTROL5r_SIZE
typedef BCMI_TSC_XGXS_ANATX_CONTROL5r_t ANATX_CONTROL5r_t;
#define ANATX_CONTROL5r_CLR BCMI_TSC_XGXS_ANATX_CONTROL5r_CLR
#define ANATX_CONTROL5r_SET BCMI_TSC_XGXS_ANATX_CONTROL5r_SET
#define ANATX_CONTROL5r_GET BCMI_TSC_XGXS_ANATX_CONTROL5r_GET
#define ANATX_CONTROL5r_RESERVED0f_GET BCMI_TSC_XGXS_ANATX_CONTROL5r_RESERVED0f_GET
#define ANATX_CONTROL5r_RESERVED0f_SET BCMI_TSC_XGXS_ANATX_CONTROL5r_RESERVED0f_SET
#define ANATX_CONTROL5r_FORCE_TX_SEL_HALFRATE_VALf_GET BCMI_TSC_XGXS_ANATX_CONTROL5r_FORCE_TX_SEL_HALFRATE_VALf_GET
#define ANATX_CONTROL5r_FORCE_TX_SEL_HALFRATE_VALf_SET BCMI_TSC_XGXS_ANATX_CONTROL5r_FORCE_TX_SEL_HALFRATE_VALf_SET
#define ANATX_CONTROL5r_FORCE_TX_SEL_HALFRATEf_GET BCMI_TSC_XGXS_ANATX_CONTROL5r_FORCE_TX_SEL_HALFRATEf_GET
#define ANATX_CONTROL5r_FORCE_TX_SEL_HALFRATEf_SET BCMI_TSC_XGXS_ANATX_CONTROL5r_FORCE_TX_SEL_HALFRATEf_SET
#define READ_ANATX_CONTROL5r BCMI_TSC_XGXS_READ_ANATX_CONTROL5r
#define WRITE_ANATX_CONTROL5r BCMI_TSC_XGXS_WRITE_ANATX_CONTROL5r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_ANATX_CONTROL5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  ANATX_CONTROL6
 * BLOCKS:   ANATX
 * REGADDR:  0xc01a
 * DESC:     Tx analog control 6 register: 00000000
 * SIZE:     32
 * FIELDS:
 *     DISABLE_TX_R     
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_ANATX_CONTROL6r (0x0000c01a | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_ANATX_CONTROL6r_SIZE 4

/*
 * This structure should be used to declare and program ANATX_CONTROL6.
 *
 */
typedef union BCMI_TSC_XGXS_ANATX_CONTROL6r_s {
	uint32_t v[1];
	uint32_t anatx_control6[1];
	uint32_t _anatx_control6;
} BCMI_TSC_XGXS_ANATX_CONTROL6r_t;

#define BCMI_TSC_XGXS_ANATX_CONTROL6r_CLR(r) (r).anatx_control6[0] = 0
#define BCMI_TSC_XGXS_ANATX_CONTROL6r_SET(r,d) (r).anatx_control6[0] = d
#define BCMI_TSC_XGXS_ANATX_CONTROL6r_GET(r) (r).anatx_control6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_ANATX_CONTROL6r_RESERVED0f_GET(r) ((((r).anatx_control6[0]) >> 1) & 0x7fff)
#define BCMI_TSC_XGXS_ANATX_CONTROL6r_RESERVED0f_SET(r,f) (r).anatx_control6[0]=(((r).anatx_control6[0] & ~((uint32_t)0x7fff << 1)) | ((((uint32_t)f) & 0x7fff) << 1))
#define BCMI_TSC_XGXS_ANATX_CONTROL6r_DISABLE_TX_Rf_GET(r) (((r).anatx_control6[0]) & 0x1)
#define BCMI_TSC_XGXS_ANATX_CONTROL6r_DISABLE_TX_Rf_SET(r,f) (r).anatx_control6[0]=(((r).anatx_control6[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access ANATX_CONTROL6.
 *
 */
#define BCMI_TSC_XGXS_READ_ANATX_CONTROL6r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_ANATX_CONTROL6r,(_r._anatx_control6))
#define BCMI_TSC_XGXS_WRITE_ANATX_CONTROL6r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_ANATX_CONTROL6r,(_r._anatx_control6))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define ANATX_CONTROL6r BCMI_TSC_XGXS_ANATX_CONTROL6r
#define ANATX_CONTROL6r_SIZE BCMI_TSC_XGXS_ANATX_CONTROL6r_SIZE
typedef BCMI_TSC_XGXS_ANATX_CONTROL6r_t ANATX_CONTROL6r_t;
#define ANATX_CONTROL6r_CLR BCMI_TSC_XGXS_ANATX_CONTROL6r_CLR
#define ANATX_CONTROL6r_SET BCMI_TSC_XGXS_ANATX_CONTROL6r_SET
#define ANATX_CONTROL6r_GET BCMI_TSC_XGXS_ANATX_CONTROL6r_GET
#define ANATX_CONTROL6r_RESERVED0f_GET BCMI_TSC_XGXS_ANATX_CONTROL6r_RESERVED0f_GET
#define ANATX_CONTROL6r_RESERVED0f_SET BCMI_TSC_XGXS_ANATX_CONTROL6r_RESERVED0f_SET
#define ANATX_CONTROL6r_DISABLE_TX_Rf_GET BCMI_TSC_XGXS_ANATX_CONTROL6r_DISABLE_TX_Rf_GET
#define ANATX_CONTROL6r_DISABLE_TX_Rf_SET BCMI_TSC_XGXS_ANATX_CONTROL6r_DISABLE_TX_Rf_SET
#define READ_ANATX_CONTROL6r BCMI_TSC_XGXS_READ_ANATX_CONTROL6r
#define WRITE_ANATX_CONTROL6r BCMI_TSC_XGXS_WRITE_ANATX_CONTROL6r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_ANATX_CONTROL6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  ANARX_CONTROL0
 * BLOCKS:   ANARX
 * REGADDR:  0xc021
 * DESC:     Rx lane control register: 00000000
 * SIZE:     32
 * FIELDS:
 *     RESERVED1        
 *     NON_CX4_SIGNAL_DETECT_FILTER_PERIOD 
 *     RESERVED0        
 *     RXPOL_FLIP       
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_ANARX_CONTROL0r (0x0000c021 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_ANARX_CONTROL0r_SIZE 4

/*
 * This structure should be used to declare and program ANARX_CONTROL0.
 *
 */
typedef union BCMI_TSC_XGXS_ANARX_CONTROL0r_s {
	uint32_t v[1];
	uint32_t anarx_control0[1];
	uint32_t _anarx_control0;
} BCMI_TSC_XGXS_ANARX_CONTROL0r_t;

#define BCMI_TSC_XGXS_ANARX_CONTROL0r_CLR(r) (r).anarx_control0[0] = 0
#define BCMI_TSC_XGXS_ANARX_CONTROL0r_SET(r,d) (r).anarx_control0[0] = d
#define BCMI_TSC_XGXS_ANARX_CONTROL0r_GET(r) (r).anarx_control0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_ANARX_CONTROL0r_RXPOL_FLIPf_GET(r) ((((r).anarx_control0[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_ANARX_CONTROL0r_RXPOL_FLIPf_SET(r,f) (r).anarx_control0[0]=(((r).anarx_control0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_ANARX_CONTROL0r_RESERVED0f_GET(r) ((((r).anarx_control0[0]) >> 12) & 0x7)
#define BCMI_TSC_XGXS_ANARX_CONTROL0r_RESERVED0f_SET(r,f) (r).anarx_control0[0]=(((r).anarx_control0[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCMI_TSC_XGXS_ANARX_CONTROL0r_NON_CX4_SIGNAL_DETECT_FILTER_PERIODf_GET(r) ((((r).anarx_control0[0]) >> 3) & 0x1ff)
#define BCMI_TSC_XGXS_ANARX_CONTROL0r_NON_CX4_SIGNAL_DETECT_FILTER_PERIODf_SET(r,f) (r).anarx_control0[0]=(((r).anarx_control0[0] & ~((uint32_t)0x1ff << 3)) | ((((uint32_t)f) & 0x1ff) << 3))
#define BCMI_TSC_XGXS_ANARX_CONTROL0r_RESERVED1f_GET(r) (((r).anarx_control0[0]) & 0x7)
#define BCMI_TSC_XGXS_ANARX_CONTROL0r_RESERVED1f_SET(r,f) (r).anarx_control0[0]=(((r).anarx_control0[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))

/*
 * These macros can be used to access ANARX_CONTROL0.
 *
 */
#define BCMI_TSC_XGXS_READ_ANARX_CONTROL0r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_ANARX_CONTROL0r,(_r._anarx_control0))
#define BCMI_TSC_XGXS_WRITE_ANARX_CONTROL0r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_ANARX_CONTROL0r,(_r._anarx_control0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define ANARX_CONTROL0r BCMI_TSC_XGXS_ANARX_CONTROL0r
#define ANARX_CONTROL0r_SIZE BCMI_TSC_XGXS_ANARX_CONTROL0r_SIZE
typedef BCMI_TSC_XGXS_ANARX_CONTROL0r_t ANARX_CONTROL0r_t;
#define ANARX_CONTROL0r_CLR BCMI_TSC_XGXS_ANARX_CONTROL0r_CLR
#define ANARX_CONTROL0r_SET BCMI_TSC_XGXS_ANARX_CONTROL0r_SET
#define ANARX_CONTROL0r_GET BCMI_TSC_XGXS_ANARX_CONTROL0r_GET
#define ANARX_CONTROL0r_RXPOL_FLIPf_GET BCMI_TSC_XGXS_ANARX_CONTROL0r_RXPOL_FLIPf_GET
#define ANARX_CONTROL0r_RXPOL_FLIPf_SET BCMI_TSC_XGXS_ANARX_CONTROL0r_RXPOL_FLIPf_SET
#define ANARX_CONTROL0r_RESERVED0f_GET BCMI_TSC_XGXS_ANARX_CONTROL0r_RESERVED0f_GET
#define ANARX_CONTROL0r_RESERVED0f_SET BCMI_TSC_XGXS_ANARX_CONTROL0r_RESERVED0f_SET
#define ANARX_CONTROL0r_NON_CX4_SIGNAL_DETECT_FILTER_PERIODf_GET BCMI_TSC_XGXS_ANARX_CONTROL0r_NON_CX4_SIGNAL_DETECT_FILTER_PERIODf_GET
#define ANARX_CONTROL0r_NON_CX4_SIGNAL_DETECT_FILTER_PERIODf_SET BCMI_TSC_XGXS_ANARX_CONTROL0r_NON_CX4_SIGNAL_DETECT_FILTER_PERIODf_SET
#define ANARX_CONTROL0r_RESERVED1f_GET BCMI_TSC_XGXS_ANARX_CONTROL0r_RESERVED1f_GET
#define ANARX_CONTROL0r_RESERVED1f_SET BCMI_TSC_XGXS_ANARX_CONTROL0r_RESERVED1f_SET
#define READ_ANARX_CONTROL0r BCMI_TSC_XGXS_READ_ANARX_CONTROL0r
#define WRITE_ANARX_CONTROL0r BCMI_TSC_XGXS_WRITE_ANARX_CONTROL0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_ANARX_CONTROL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  ANARX_STATUS1
 * BLOCKS:   ANARX
 * REGADDR:  0xc02b
 * DESC:     Rx analog status register (AFE rx_sts[15:0]): 00000000
 * SIZE:     32
 * FIELDS:
 *     VGA              
 *     TAP1_DFE_GRAY    
 *     RX_PF            
 *     SIGDET           
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_ANARX_STATUS1r (0x0000c02b | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_ANARX_STATUS1r_SIZE 4

/*
 * This structure should be used to declare and program ANARX_STATUS1.
 *
 */
typedef union BCMI_TSC_XGXS_ANARX_STATUS1r_s {
	uint32_t v[1];
	uint32_t anarx_status1[1];
	uint32_t _anarx_status1;
} BCMI_TSC_XGXS_ANARX_STATUS1r_t;

#define BCMI_TSC_XGXS_ANARX_STATUS1r_CLR(r) (r).anarx_status1[0] = 0
#define BCMI_TSC_XGXS_ANARX_STATUS1r_SET(r,d) (r).anarx_status1[0] = d
#define BCMI_TSC_XGXS_ANARX_STATUS1r_GET(r) (r).anarx_status1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_ANARX_STATUS1r_SIGDETf_GET(r) ((((r).anarx_status1[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_ANARX_STATUS1r_SIGDETf_SET(r,f) (r).anarx_status1[0]=(((r).anarx_status1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_ANARX_STATUS1r_RX_PFf_GET(r) ((((r).anarx_status1[0]) >> 11) & 0xf)
#define BCMI_TSC_XGXS_ANARX_STATUS1r_RX_PFf_SET(r,f) (r).anarx_status1[0]=(((r).anarx_status1[0] & ~((uint32_t)0xf << 11)) | ((((uint32_t)f) & 0xf) << 11))
#define BCMI_TSC_XGXS_ANARX_STATUS1r_TAP1_DFE_GRAYf_GET(r) ((((r).anarx_status1[0]) >> 5) & 0x3f)
#define BCMI_TSC_XGXS_ANARX_STATUS1r_TAP1_DFE_GRAYf_SET(r,f) (r).anarx_status1[0]=(((r).anarx_status1[0] & ~((uint32_t)0x3f << 5)) | ((((uint32_t)f) & 0x3f) << 5))
#define BCMI_TSC_XGXS_ANARX_STATUS1r_VGAf_GET(r) (((r).anarx_status1[0]) & 0x1f)
#define BCMI_TSC_XGXS_ANARX_STATUS1r_VGAf_SET(r,f) (r).anarx_status1[0]=(((r).anarx_status1[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))

/*
 * These macros can be used to access ANARX_STATUS1.
 *
 */
#define BCMI_TSC_XGXS_READ_ANARX_STATUS1r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_ANARX_STATUS1r,(_r._anarx_status1))
#define BCMI_TSC_XGXS_WRITE_ANARX_STATUS1r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_ANARX_STATUS1r,(_r._anarx_status1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define ANARX_STATUS1r BCMI_TSC_XGXS_ANARX_STATUS1r
#define ANARX_STATUS1r_SIZE BCMI_TSC_XGXS_ANARX_STATUS1r_SIZE
typedef BCMI_TSC_XGXS_ANARX_STATUS1r_t ANARX_STATUS1r_t;
#define ANARX_STATUS1r_CLR BCMI_TSC_XGXS_ANARX_STATUS1r_CLR
#define ANARX_STATUS1r_SET BCMI_TSC_XGXS_ANARX_STATUS1r_SET
#define ANARX_STATUS1r_GET BCMI_TSC_XGXS_ANARX_STATUS1r_GET
#define ANARX_STATUS1r_SIGDETf_GET BCMI_TSC_XGXS_ANARX_STATUS1r_SIGDETf_GET
#define ANARX_STATUS1r_SIGDETf_SET BCMI_TSC_XGXS_ANARX_STATUS1r_SIGDETf_SET
#define ANARX_STATUS1r_RX_PFf_GET BCMI_TSC_XGXS_ANARX_STATUS1r_RX_PFf_GET
#define ANARX_STATUS1r_RX_PFf_SET BCMI_TSC_XGXS_ANARX_STATUS1r_RX_PFf_SET
#define ANARX_STATUS1r_TAP1_DFE_GRAYf_GET BCMI_TSC_XGXS_ANARX_STATUS1r_TAP1_DFE_GRAYf_GET
#define ANARX_STATUS1r_TAP1_DFE_GRAYf_SET BCMI_TSC_XGXS_ANARX_STATUS1r_TAP1_DFE_GRAYf_SET
#define ANARX_STATUS1r_VGAf_GET BCMI_TSC_XGXS_ANARX_STATUS1r_VGAf_GET
#define ANARX_STATUS1r_VGAf_SET BCMI_TSC_XGXS_ANARX_STATUS1r_VGAf_SET
#define READ_ANARX_STATUS1r BCMI_TSC_XGXS_READ_ANARX_STATUS1r
#define WRITE_ANARX_STATUS1r BCMI_TSC_XGXS_WRITE_ANARX_STATUS1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_ANARX_STATUS1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  ANARX_CONTROL1
 * BLOCKS:   ANARX
 * REGADDR:  0xc02c
 * DESC:     Rx reserved analog control register (AFE rx_ctrl[15:00], not applicable to XFICore): 00000000
 * SIZE:     32
 * FIELDS:
 *     SEL_DFECKDELAY0  
 *     SEL_DFECKDELAY1  
 *     OFFSET_SEL       
 *     OFFSET_CTRL      
 *     SIG_PWRDN        
 *     VDDR_BG          
 *     TPORT_EN         
 *     REFL_RX          
 *     REFH_RX          
 *     VGA_BW_EXT       
 *     IMODE_SIGDET     
 *     EN_10GMODE       
 *     IMIN_VCM         
 *     IMODE_VCM        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_ANARX_CONTROL1r (0x0000c02c | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_ANARX_CONTROL1r_SIZE 4

/*
 * This structure should be used to declare and program ANARX_CONTROL1.
 *
 */
typedef union BCMI_TSC_XGXS_ANARX_CONTROL1r_s {
	uint32_t v[1];
	uint32_t anarx_control1[1];
	uint32_t _anarx_control1;
} BCMI_TSC_XGXS_ANARX_CONTROL1r_t;

#define BCMI_TSC_XGXS_ANARX_CONTROL1r_CLR(r) (r).anarx_control1[0] = 0
#define BCMI_TSC_XGXS_ANARX_CONTROL1r_SET(r,d) (r).anarx_control1[0] = d
#define BCMI_TSC_XGXS_ANARX_CONTROL1r_GET(r) (r).anarx_control1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_ANARX_CONTROL1r_IMODE_VCMf_GET(r) ((((r).anarx_control1[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_ANARX_CONTROL1r_IMODE_VCMf_SET(r,f) (r).anarx_control1[0]=(((r).anarx_control1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_ANARX_CONTROL1r_IMIN_VCMf_GET(r) ((((r).anarx_control1[0]) >> 14) & 0x1)
#define BCMI_TSC_XGXS_ANARX_CONTROL1r_IMIN_VCMf_SET(r,f) (r).anarx_control1[0]=(((r).anarx_control1[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCMI_TSC_XGXS_ANARX_CONTROL1r_EN_10GMODEf_GET(r) ((((r).anarx_control1[0]) >> 13) & 0x1)
#define BCMI_TSC_XGXS_ANARX_CONTROL1r_EN_10GMODEf_SET(r,f) (r).anarx_control1[0]=(((r).anarx_control1[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCMI_TSC_XGXS_ANARX_CONTROL1r_IMODE_SIGDETf_GET(r) ((((r).anarx_control1[0]) >> 12) & 0x1)
#define BCMI_TSC_XGXS_ANARX_CONTROL1r_IMODE_SIGDETf_SET(r,f) (r).anarx_control1[0]=(((r).anarx_control1[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCMI_TSC_XGXS_ANARX_CONTROL1r_VGA_BW_EXTf_GET(r) ((((r).anarx_control1[0]) >> 11) & 0x1)
#define BCMI_TSC_XGXS_ANARX_CONTROL1r_VGA_BW_EXTf_SET(r,f) (r).anarx_control1[0]=(((r).anarx_control1[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCMI_TSC_XGXS_ANARX_CONTROL1r_REFH_RXf_GET(r) ((((r).anarx_control1[0]) >> 10) & 0x1)
#define BCMI_TSC_XGXS_ANARX_CONTROL1r_REFH_RXf_SET(r,f) (r).anarx_control1[0]=(((r).anarx_control1[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCMI_TSC_XGXS_ANARX_CONTROL1r_REFL_RXf_GET(r) ((((r).anarx_control1[0]) >> 9) & 0x1)
#define BCMI_TSC_XGXS_ANARX_CONTROL1r_REFL_RXf_SET(r,f) (r).anarx_control1[0]=(((r).anarx_control1[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCMI_TSC_XGXS_ANARX_CONTROL1r_TPORT_ENf_GET(r) ((((r).anarx_control1[0]) >> 8) & 0x1)
#define BCMI_TSC_XGXS_ANARX_CONTROL1r_TPORT_ENf_SET(r,f) (r).anarx_control1[0]=(((r).anarx_control1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCMI_TSC_XGXS_ANARX_CONTROL1r_VDDR_BGf_GET(r) ((((r).anarx_control1[0]) >> 7) & 0x1)
#define BCMI_TSC_XGXS_ANARX_CONTROL1r_VDDR_BGf_SET(r,f) (r).anarx_control1[0]=(((r).anarx_control1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCMI_TSC_XGXS_ANARX_CONTROL1r_SIG_PWRDNf_GET(r) ((((r).anarx_control1[0]) >> 6) & 0x1)
#define BCMI_TSC_XGXS_ANARX_CONTROL1r_SIG_PWRDNf_SET(r,f) (r).anarx_control1[0]=(((r).anarx_control1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCMI_TSC_XGXS_ANARX_CONTROL1r_OFFSET_CTRLf_GET(r) ((((r).anarx_control1[0]) >> 3) & 0x7)
#define BCMI_TSC_XGXS_ANARX_CONTROL1r_OFFSET_CTRLf_SET(r,f) (r).anarx_control1[0]=(((r).anarx_control1[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCMI_TSC_XGXS_ANARX_CONTROL1r_OFFSET_SELf_GET(r) ((((r).anarx_control1[0]) >> 2) & 0x1)
#define BCMI_TSC_XGXS_ANARX_CONTROL1r_OFFSET_SELf_SET(r,f) (r).anarx_control1[0]=(((r).anarx_control1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCMI_TSC_XGXS_ANARX_CONTROL1r_SEL_DFECKDELAY1f_GET(r) ((((r).anarx_control1[0]) >> 1) & 0x1)
#define BCMI_TSC_XGXS_ANARX_CONTROL1r_SEL_DFECKDELAY1f_SET(r,f) (r).anarx_control1[0]=(((r).anarx_control1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCMI_TSC_XGXS_ANARX_CONTROL1r_SEL_DFECKDELAY0f_GET(r) (((r).anarx_control1[0]) & 0x1)
#define BCMI_TSC_XGXS_ANARX_CONTROL1r_SEL_DFECKDELAY0f_SET(r,f) (r).anarx_control1[0]=(((r).anarx_control1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access ANARX_CONTROL1.
 *
 */
#define BCMI_TSC_XGXS_READ_ANARX_CONTROL1r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_ANARX_CONTROL1r,(_r._anarx_control1))
#define BCMI_TSC_XGXS_WRITE_ANARX_CONTROL1r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_ANARX_CONTROL1r,(_r._anarx_control1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define ANARX_CONTROL1r BCMI_TSC_XGXS_ANARX_CONTROL1r
#define ANARX_CONTROL1r_SIZE BCMI_TSC_XGXS_ANARX_CONTROL1r_SIZE
typedef BCMI_TSC_XGXS_ANARX_CONTROL1r_t ANARX_CONTROL1r_t;
#define ANARX_CONTROL1r_CLR BCMI_TSC_XGXS_ANARX_CONTROL1r_CLR
#define ANARX_CONTROL1r_SET BCMI_TSC_XGXS_ANARX_CONTROL1r_SET
#define ANARX_CONTROL1r_GET BCMI_TSC_XGXS_ANARX_CONTROL1r_GET
#define ANARX_CONTROL1r_IMODE_VCMf_GET BCMI_TSC_XGXS_ANARX_CONTROL1r_IMODE_VCMf_GET
#define ANARX_CONTROL1r_IMODE_VCMf_SET BCMI_TSC_XGXS_ANARX_CONTROL1r_IMODE_VCMf_SET
#define ANARX_CONTROL1r_IMIN_VCMf_GET BCMI_TSC_XGXS_ANARX_CONTROL1r_IMIN_VCMf_GET
#define ANARX_CONTROL1r_IMIN_VCMf_SET BCMI_TSC_XGXS_ANARX_CONTROL1r_IMIN_VCMf_SET
#define ANARX_CONTROL1r_EN_10GMODEf_GET BCMI_TSC_XGXS_ANARX_CONTROL1r_EN_10GMODEf_GET
#define ANARX_CONTROL1r_EN_10GMODEf_SET BCMI_TSC_XGXS_ANARX_CONTROL1r_EN_10GMODEf_SET
#define ANARX_CONTROL1r_IMODE_SIGDETf_GET BCMI_TSC_XGXS_ANARX_CONTROL1r_IMODE_SIGDETf_GET
#define ANARX_CONTROL1r_IMODE_SIGDETf_SET BCMI_TSC_XGXS_ANARX_CONTROL1r_IMODE_SIGDETf_SET
#define ANARX_CONTROL1r_VGA_BW_EXTf_GET BCMI_TSC_XGXS_ANARX_CONTROL1r_VGA_BW_EXTf_GET
#define ANARX_CONTROL1r_VGA_BW_EXTf_SET BCMI_TSC_XGXS_ANARX_CONTROL1r_VGA_BW_EXTf_SET
#define ANARX_CONTROL1r_REFH_RXf_GET BCMI_TSC_XGXS_ANARX_CONTROL1r_REFH_RXf_GET
#define ANARX_CONTROL1r_REFH_RXf_SET BCMI_TSC_XGXS_ANARX_CONTROL1r_REFH_RXf_SET
#define ANARX_CONTROL1r_REFL_RXf_GET BCMI_TSC_XGXS_ANARX_CONTROL1r_REFL_RXf_GET
#define ANARX_CONTROL1r_REFL_RXf_SET BCMI_TSC_XGXS_ANARX_CONTROL1r_REFL_RXf_SET
#define ANARX_CONTROL1r_TPORT_ENf_GET BCMI_TSC_XGXS_ANARX_CONTROL1r_TPORT_ENf_GET
#define ANARX_CONTROL1r_TPORT_ENf_SET BCMI_TSC_XGXS_ANARX_CONTROL1r_TPORT_ENf_SET
#define ANARX_CONTROL1r_VDDR_BGf_GET BCMI_TSC_XGXS_ANARX_CONTROL1r_VDDR_BGf_GET
#define ANARX_CONTROL1r_VDDR_BGf_SET BCMI_TSC_XGXS_ANARX_CONTROL1r_VDDR_BGf_SET
#define ANARX_CONTROL1r_SIG_PWRDNf_GET BCMI_TSC_XGXS_ANARX_CONTROL1r_SIG_PWRDNf_GET
#define ANARX_CONTROL1r_SIG_PWRDNf_SET BCMI_TSC_XGXS_ANARX_CONTROL1r_SIG_PWRDNf_SET
#define ANARX_CONTROL1r_OFFSET_CTRLf_GET BCMI_TSC_XGXS_ANARX_CONTROL1r_OFFSET_CTRLf_GET
#define ANARX_CONTROL1r_OFFSET_CTRLf_SET BCMI_TSC_XGXS_ANARX_CONTROL1r_OFFSET_CTRLf_SET
#define ANARX_CONTROL1r_OFFSET_SELf_GET BCMI_TSC_XGXS_ANARX_CONTROL1r_OFFSET_SELf_GET
#define ANARX_CONTROL1r_OFFSET_SELf_SET BCMI_TSC_XGXS_ANARX_CONTROL1r_OFFSET_SELf_SET
#define ANARX_CONTROL1r_SEL_DFECKDELAY1f_GET BCMI_TSC_XGXS_ANARX_CONTROL1r_SEL_DFECKDELAY1f_GET
#define ANARX_CONTROL1r_SEL_DFECKDELAY1f_SET BCMI_TSC_XGXS_ANARX_CONTROL1r_SEL_DFECKDELAY1f_SET
#define ANARX_CONTROL1r_SEL_DFECKDELAY0f_GET BCMI_TSC_XGXS_ANARX_CONTROL1r_SEL_DFECKDELAY0f_GET
#define ANARX_CONTROL1r_SEL_DFECKDELAY0f_SET BCMI_TSC_XGXS_ANARX_CONTROL1r_SEL_DFECKDELAY0f_SET
#define READ_ANARX_CONTROL1r BCMI_TSC_XGXS_READ_ANARX_CONTROL1r
#define WRITE_ANARX_CONTROL1r BCMI_TSC_XGXS_WRITE_ANARX_CONTROL1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_ANARX_CONTROL1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  ANARX_CONTROL2
 * BLOCKS:   ANARX
 * REGADDR:  0xc02d
 * DESC:     Rx reserved analog control register (AFE rx_ctrl[31:16], not applicable to XFICore): 00000000
 * SIZE:     32
 * FIELDS:
 *     IMAX_VCM         
 *     IMIN_INTERP      
 *     IMODE_INTERP     
 *     IMAX_INTERP      
 *     IMIN_VGA         
 *     IMODE_VGA        
 *     IMAX_VGA         
 *     IMIN_DFESUM      
 *     IMODE_DFESUM     
 *     IMAX_DFESUM      
 *     IMIN_EQFL        
 *     IMODE_EQFL       
 *     IMAX_EQFL        
 *     IMIN_CTAT        
 *     IMODE_CTAT       
 *     IMAX_CTAT        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_ANARX_CONTROL2r (0x0000c02d | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_ANARX_CONTROL2r_SIZE 4

/*
 * This structure should be used to declare and program ANARX_CONTROL2.
 *
 */
typedef union BCMI_TSC_XGXS_ANARX_CONTROL2r_s {
	uint32_t v[1];
	uint32_t anarx_control2[1];
	uint32_t _anarx_control2;
} BCMI_TSC_XGXS_ANARX_CONTROL2r_t;

#define BCMI_TSC_XGXS_ANARX_CONTROL2r_CLR(r) (r).anarx_control2[0] = 0
#define BCMI_TSC_XGXS_ANARX_CONTROL2r_SET(r,d) (r).anarx_control2[0] = d
#define BCMI_TSC_XGXS_ANARX_CONTROL2r_GET(r) (r).anarx_control2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_ANARX_CONTROL2r_IMAX_CTATf_GET(r) ((((r).anarx_control2[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_ANARX_CONTROL2r_IMAX_CTATf_SET(r,f) (r).anarx_control2[0]=(((r).anarx_control2[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_ANARX_CONTROL2r_IMODE_CTATf_GET(r) ((((r).anarx_control2[0]) >> 14) & 0x1)
#define BCMI_TSC_XGXS_ANARX_CONTROL2r_IMODE_CTATf_SET(r,f) (r).anarx_control2[0]=(((r).anarx_control2[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCMI_TSC_XGXS_ANARX_CONTROL2r_IMIN_CTATf_GET(r) ((((r).anarx_control2[0]) >> 13) & 0x1)
#define BCMI_TSC_XGXS_ANARX_CONTROL2r_IMIN_CTATf_SET(r,f) (r).anarx_control2[0]=(((r).anarx_control2[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCMI_TSC_XGXS_ANARX_CONTROL2r_IMAX_EQFLf_GET(r) ((((r).anarx_control2[0]) >> 12) & 0x1)
#define BCMI_TSC_XGXS_ANARX_CONTROL2r_IMAX_EQFLf_SET(r,f) (r).anarx_control2[0]=(((r).anarx_control2[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCMI_TSC_XGXS_ANARX_CONTROL2r_IMODE_EQFLf_GET(r) ((((r).anarx_control2[0]) >> 11) & 0x1)
#define BCMI_TSC_XGXS_ANARX_CONTROL2r_IMODE_EQFLf_SET(r,f) (r).anarx_control2[0]=(((r).anarx_control2[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCMI_TSC_XGXS_ANARX_CONTROL2r_IMIN_EQFLf_GET(r) ((((r).anarx_control2[0]) >> 10) & 0x1)
#define BCMI_TSC_XGXS_ANARX_CONTROL2r_IMIN_EQFLf_SET(r,f) (r).anarx_control2[0]=(((r).anarx_control2[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCMI_TSC_XGXS_ANARX_CONTROL2r_IMAX_DFESUMf_GET(r) ((((r).anarx_control2[0]) >> 9) & 0x1)
#define BCMI_TSC_XGXS_ANARX_CONTROL2r_IMAX_DFESUMf_SET(r,f) (r).anarx_control2[0]=(((r).anarx_control2[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCMI_TSC_XGXS_ANARX_CONTROL2r_IMODE_DFESUMf_GET(r) ((((r).anarx_control2[0]) >> 8) & 0x1)
#define BCMI_TSC_XGXS_ANARX_CONTROL2r_IMODE_DFESUMf_SET(r,f) (r).anarx_control2[0]=(((r).anarx_control2[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCMI_TSC_XGXS_ANARX_CONTROL2r_IMIN_DFESUMf_GET(r) ((((r).anarx_control2[0]) >> 7) & 0x1)
#define BCMI_TSC_XGXS_ANARX_CONTROL2r_IMIN_DFESUMf_SET(r,f) (r).anarx_control2[0]=(((r).anarx_control2[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCMI_TSC_XGXS_ANARX_CONTROL2r_IMAX_VGAf_GET(r) ((((r).anarx_control2[0]) >> 6) & 0x1)
#define BCMI_TSC_XGXS_ANARX_CONTROL2r_IMAX_VGAf_SET(r,f) (r).anarx_control2[0]=(((r).anarx_control2[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCMI_TSC_XGXS_ANARX_CONTROL2r_IMODE_VGAf_GET(r) ((((r).anarx_control2[0]) >> 5) & 0x1)
#define BCMI_TSC_XGXS_ANARX_CONTROL2r_IMODE_VGAf_SET(r,f) (r).anarx_control2[0]=(((r).anarx_control2[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCMI_TSC_XGXS_ANARX_CONTROL2r_IMIN_VGAf_GET(r) ((((r).anarx_control2[0]) >> 4) & 0x1)
#define BCMI_TSC_XGXS_ANARX_CONTROL2r_IMIN_VGAf_SET(r,f) (r).anarx_control2[0]=(((r).anarx_control2[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCMI_TSC_XGXS_ANARX_CONTROL2r_IMAX_INTERPf_GET(r) ((((r).anarx_control2[0]) >> 3) & 0x1)
#define BCMI_TSC_XGXS_ANARX_CONTROL2r_IMAX_INTERPf_SET(r,f) (r).anarx_control2[0]=(((r).anarx_control2[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCMI_TSC_XGXS_ANARX_CONTROL2r_IMODE_INTERPf_GET(r) ((((r).anarx_control2[0]) >> 2) & 0x1)
#define BCMI_TSC_XGXS_ANARX_CONTROL2r_IMODE_INTERPf_SET(r,f) (r).anarx_control2[0]=(((r).anarx_control2[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCMI_TSC_XGXS_ANARX_CONTROL2r_IMIN_INTERPf_GET(r) ((((r).anarx_control2[0]) >> 1) & 0x1)
#define BCMI_TSC_XGXS_ANARX_CONTROL2r_IMIN_INTERPf_SET(r,f) (r).anarx_control2[0]=(((r).anarx_control2[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCMI_TSC_XGXS_ANARX_CONTROL2r_IMAX_VCMf_GET(r) (((r).anarx_control2[0]) & 0x1)
#define BCMI_TSC_XGXS_ANARX_CONTROL2r_IMAX_VCMf_SET(r,f) (r).anarx_control2[0]=(((r).anarx_control2[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access ANARX_CONTROL2.
 *
 */
#define BCMI_TSC_XGXS_READ_ANARX_CONTROL2r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_ANARX_CONTROL2r,(_r._anarx_control2))
#define BCMI_TSC_XGXS_WRITE_ANARX_CONTROL2r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_ANARX_CONTROL2r,(_r._anarx_control2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define ANARX_CONTROL2r BCMI_TSC_XGXS_ANARX_CONTROL2r
#define ANARX_CONTROL2r_SIZE BCMI_TSC_XGXS_ANARX_CONTROL2r_SIZE
typedef BCMI_TSC_XGXS_ANARX_CONTROL2r_t ANARX_CONTROL2r_t;
#define ANARX_CONTROL2r_CLR BCMI_TSC_XGXS_ANARX_CONTROL2r_CLR
#define ANARX_CONTROL2r_SET BCMI_TSC_XGXS_ANARX_CONTROL2r_SET
#define ANARX_CONTROL2r_GET BCMI_TSC_XGXS_ANARX_CONTROL2r_GET
#define ANARX_CONTROL2r_IMAX_CTATf_GET BCMI_TSC_XGXS_ANARX_CONTROL2r_IMAX_CTATf_GET
#define ANARX_CONTROL2r_IMAX_CTATf_SET BCMI_TSC_XGXS_ANARX_CONTROL2r_IMAX_CTATf_SET
#define ANARX_CONTROL2r_IMODE_CTATf_GET BCMI_TSC_XGXS_ANARX_CONTROL2r_IMODE_CTATf_GET
#define ANARX_CONTROL2r_IMODE_CTATf_SET BCMI_TSC_XGXS_ANARX_CONTROL2r_IMODE_CTATf_SET
#define ANARX_CONTROL2r_IMIN_CTATf_GET BCMI_TSC_XGXS_ANARX_CONTROL2r_IMIN_CTATf_GET
#define ANARX_CONTROL2r_IMIN_CTATf_SET BCMI_TSC_XGXS_ANARX_CONTROL2r_IMIN_CTATf_SET
#define ANARX_CONTROL2r_IMAX_EQFLf_GET BCMI_TSC_XGXS_ANARX_CONTROL2r_IMAX_EQFLf_GET
#define ANARX_CONTROL2r_IMAX_EQFLf_SET BCMI_TSC_XGXS_ANARX_CONTROL2r_IMAX_EQFLf_SET
#define ANARX_CONTROL2r_IMODE_EQFLf_GET BCMI_TSC_XGXS_ANARX_CONTROL2r_IMODE_EQFLf_GET
#define ANARX_CONTROL2r_IMODE_EQFLf_SET BCMI_TSC_XGXS_ANARX_CONTROL2r_IMODE_EQFLf_SET
#define ANARX_CONTROL2r_IMIN_EQFLf_GET BCMI_TSC_XGXS_ANARX_CONTROL2r_IMIN_EQFLf_GET
#define ANARX_CONTROL2r_IMIN_EQFLf_SET BCMI_TSC_XGXS_ANARX_CONTROL2r_IMIN_EQFLf_SET
#define ANARX_CONTROL2r_IMAX_DFESUMf_GET BCMI_TSC_XGXS_ANARX_CONTROL2r_IMAX_DFESUMf_GET
#define ANARX_CONTROL2r_IMAX_DFESUMf_SET BCMI_TSC_XGXS_ANARX_CONTROL2r_IMAX_DFESUMf_SET
#define ANARX_CONTROL2r_IMODE_DFESUMf_GET BCMI_TSC_XGXS_ANARX_CONTROL2r_IMODE_DFESUMf_GET
#define ANARX_CONTROL2r_IMODE_DFESUMf_SET BCMI_TSC_XGXS_ANARX_CONTROL2r_IMODE_DFESUMf_SET
#define ANARX_CONTROL2r_IMIN_DFESUMf_GET BCMI_TSC_XGXS_ANARX_CONTROL2r_IMIN_DFESUMf_GET
#define ANARX_CONTROL2r_IMIN_DFESUMf_SET BCMI_TSC_XGXS_ANARX_CONTROL2r_IMIN_DFESUMf_SET
#define ANARX_CONTROL2r_IMAX_VGAf_GET BCMI_TSC_XGXS_ANARX_CONTROL2r_IMAX_VGAf_GET
#define ANARX_CONTROL2r_IMAX_VGAf_SET BCMI_TSC_XGXS_ANARX_CONTROL2r_IMAX_VGAf_SET
#define ANARX_CONTROL2r_IMODE_VGAf_GET BCMI_TSC_XGXS_ANARX_CONTROL2r_IMODE_VGAf_GET
#define ANARX_CONTROL2r_IMODE_VGAf_SET BCMI_TSC_XGXS_ANARX_CONTROL2r_IMODE_VGAf_SET
#define ANARX_CONTROL2r_IMIN_VGAf_GET BCMI_TSC_XGXS_ANARX_CONTROL2r_IMIN_VGAf_GET
#define ANARX_CONTROL2r_IMIN_VGAf_SET BCMI_TSC_XGXS_ANARX_CONTROL2r_IMIN_VGAf_SET
#define ANARX_CONTROL2r_IMAX_INTERPf_GET BCMI_TSC_XGXS_ANARX_CONTROL2r_IMAX_INTERPf_GET
#define ANARX_CONTROL2r_IMAX_INTERPf_SET BCMI_TSC_XGXS_ANARX_CONTROL2r_IMAX_INTERPf_SET
#define ANARX_CONTROL2r_IMODE_INTERPf_GET BCMI_TSC_XGXS_ANARX_CONTROL2r_IMODE_INTERPf_GET
#define ANARX_CONTROL2r_IMODE_INTERPf_SET BCMI_TSC_XGXS_ANARX_CONTROL2r_IMODE_INTERPf_SET
#define ANARX_CONTROL2r_IMIN_INTERPf_GET BCMI_TSC_XGXS_ANARX_CONTROL2r_IMIN_INTERPf_GET
#define ANARX_CONTROL2r_IMIN_INTERPf_SET BCMI_TSC_XGXS_ANARX_CONTROL2r_IMIN_INTERPf_SET
#define ANARX_CONTROL2r_IMAX_VCMf_GET BCMI_TSC_XGXS_ANARX_CONTROL2r_IMAX_VCMf_GET
#define ANARX_CONTROL2r_IMAX_VCMf_SET BCMI_TSC_XGXS_ANARX_CONTROL2r_IMAX_VCMf_SET
#define READ_ANARX_CONTROL2r BCMI_TSC_XGXS_READ_ANARX_CONTROL2r
#define WRITE_ANARX_CONTROL2r BCMI_TSC_XGXS_WRITE_ANARX_CONTROL2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_ANARX_CONTROL2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  ANARX_CONTROL3
 * BLOCKS:   ANARX
 * REGADDR:  0xc02e
 * DESC:     Rx reserved analog control register (AFE rx_ctrl[47:32], not applicable to XFICore): 00000000
 * SIZE:     32
 * FIELDS:
 *     IMIN_DFEVREF     
 *     IMODE_DFEVREF    
 *     IMAX_DFEVREF     
 *     IMIN_SLCD2C      
 *     IMODE_SLCD2C     
 *     IMAX_SLCD2C      
 *     IMIN_DFETAP      
 *     IMODE_DFETAP     
 *     IMAX_DFETAP      
 *     SELUGBW0         
 *     SELUGBW1         
 *     SEL_TH4DFE0      
 *     SEL_TH4DFE1      
 *     EN_VCCTRL        
 *     EN_CLK33         
 *     EN_CLK16         
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_ANARX_CONTROL3r (0x0000c02e | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_ANARX_CONTROL3r_SIZE 4

/*
 * This structure should be used to declare and program ANARX_CONTROL3.
 *
 */
typedef union BCMI_TSC_XGXS_ANARX_CONTROL3r_s {
	uint32_t v[1];
	uint32_t anarx_control3[1];
	uint32_t _anarx_control3;
} BCMI_TSC_XGXS_ANARX_CONTROL3r_t;

#define BCMI_TSC_XGXS_ANARX_CONTROL3r_CLR(r) (r).anarx_control3[0] = 0
#define BCMI_TSC_XGXS_ANARX_CONTROL3r_SET(r,d) (r).anarx_control3[0] = d
#define BCMI_TSC_XGXS_ANARX_CONTROL3r_GET(r) (r).anarx_control3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_ANARX_CONTROL3r_EN_CLK16f_GET(r) ((((r).anarx_control3[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_ANARX_CONTROL3r_EN_CLK16f_SET(r,f) (r).anarx_control3[0]=(((r).anarx_control3[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_ANARX_CONTROL3r_EN_CLK33f_GET(r) ((((r).anarx_control3[0]) >> 14) & 0x1)
#define BCMI_TSC_XGXS_ANARX_CONTROL3r_EN_CLK33f_SET(r,f) (r).anarx_control3[0]=(((r).anarx_control3[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCMI_TSC_XGXS_ANARX_CONTROL3r_EN_VCCTRLf_GET(r) ((((r).anarx_control3[0]) >> 13) & 0x1)
#define BCMI_TSC_XGXS_ANARX_CONTROL3r_EN_VCCTRLf_SET(r,f) (r).anarx_control3[0]=(((r).anarx_control3[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCMI_TSC_XGXS_ANARX_CONTROL3r_SEL_TH4DFE1f_GET(r) ((((r).anarx_control3[0]) >> 12) & 0x1)
#define BCMI_TSC_XGXS_ANARX_CONTROL3r_SEL_TH4DFE1f_SET(r,f) (r).anarx_control3[0]=(((r).anarx_control3[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCMI_TSC_XGXS_ANARX_CONTROL3r_SEL_TH4DFE0f_GET(r) ((((r).anarx_control3[0]) >> 11) & 0x1)
#define BCMI_TSC_XGXS_ANARX_CONTROL3r_SEL_TH4DFE0f_SET(r,f) (r).anarx_control3[0]=(((r).anarx_control3[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCMI_TSC_XGXS_ANARX_CONTROL3r_SELUGBW1f_GET(r) ((((r).anarx_control3[0]) >> 10) & 0x1)
#define BCMI_TSC_XGXS_ANARX_CONTROL3r_SELUGBW1f_SET(r,f) (r).anarx_control3[0]=(((r).anarx_control3[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCMI_TSC_XGXS_ANARX_CONTROL3r_SELUGBW0f_GET(r) ((((r).anarx_control3[0]) >> 9) & 0x1)
#define BCMI_TSC_XGXS_ANARX_CONTROL3r_SELUGBW0f_SET(r,f) (r).anarx_control3[0]=(((r).anarx_control3[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCMI_TSC_XGXS_ANARX_CONTROL3r_IMAX_DFETAPf_GET(r) ((((r).anarx_control3[0]) >> 8) & 0x1)
#define BCMI_TSC_XGXS_ANARX_CONTROL3r_IMAX_DFETAPf_SET(r,f) (r).anarx_control3[0]=(((r).anarx_control3[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCMI_TSC_XGXS_ANARX_CONTROL3r_IMODE_DFETAPf_GET(r) ((((r).anarx_control3[0]) >> 7) & 0x1)
#define BCMI_TSC_XGXS_ANARX_CONTROL3r_IMODE_DFETAPf_SET(r,f) (r).anarx_control3[0]=(((r).anarx_control3[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCMI_TSC_XGXS_ANARX_CONTROL3r_IMIN_DFETAPf_GET(r) ((((r).anarx_control3[0]) >> 6) & 0x1)
#define BCMI_TSC_XGXS_ANARX_CONTROL3r_IMIN_DFETAPf_SET(r,f) (r).anarx_control3[0]=(((r).anarx_control3[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCMI_TSC_XGXS_ANARX_CONTROL3r_IMAX_SLCD2Cf_GET(r) ((((r).anarx_control3[0]) >> 5) & 0x1)
#define BCMI_TSC_XGXS_ANARX_CONTROL3r_IMAX_SLCD2Cf_SET(r,f) (r).anarx_control3[0]=(((r).anarx_control3[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCMI_TSC_XGXS_ANARX_CONTROL3r_IMODE_SLCD2Cf_GET(r) ((((r).anarx_control3[0]) >> 4) & 0x1)
#define BCMI_TSC_XGXS_ANARX_CONTROL3r_IMODE_SLCD2Cf_SET(r,f) (r).anarx_control3[0]=(((r).anarx_control3[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCMI_TSC_XGXS_ANARX_CONTROL3r_IMIN_SLCD2Cf_GET(r) ((((r).anarx_control3[0]) >> 3) & 0x1)
#define BCMI_TSC_XGXS_ANARX_CONTROL3r_IMIN_SLCD2Cf_SET(r,f) (r).anarx_control3[0]=(((r).anarx_control3[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCMI_TSC_XGXS_ANARX_CONTROL3r_IMAX_DFEVREFf_GET(r) ((((r).anarx_control3[0]) >> 2) & 0x1)
#define BCMI_TSC_XGXS_ANARX_CONTROL3r_IMAX_DFEVREFf_SET(r,f) (r).anarx_control3[0]=(((r).anarx_control3[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCMI_TSC_XGXS_ANARX_CONTROL3r_IMODE_DFEVREFf_GET(r) ((((r).anarx_control3[0]) >> 1) & 0x1)
#define BCMI_TSC_XGXS_ANARX_CONTROL3r_IMODE_DFEVREFf_SET(r,f) (r).anarx_control3[0]=(((r).anarx_control3[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCMI_TSC_XGXS_ANARX_CONTROL3r_IMIN_DFEVREFf_GET(r) (((r).anarx_control3[0]) & 0x1)
#define BCMI_TSC_XGXS_ANARX_CONTROL3r_IMIN_DFEVREFf_SET(r,f) (r).anarx_control3[0]=(((r).anarx_control3[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access ANARX_CONTROL3.
 *
 */
#define BCMI_TSC_XGXS_READ_ANARX_CONTROL3r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_ANARX_CONTROL3r,(_r._anarx_control3))
#define BCMI_TSC_XGXS_WRITE_ANARX_CONTROL3r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_ANARX_CONTROL3r,(_r._anarx_control3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define ANARX_CONTROL3r BCMI_TSC_XGXS_ANARX_CONTROL3r
#define ANARX_CONTROL3r_SIZE BCMI_TSC_XGXS_ANARX_CONTROL3r_SIZE
typedef BCMI_TSC_XGXS_ANARX_CONTROL3r_t ANARX_CONTROL3r_t;
#define ANARX_CONTROL3r_CLR BCMI_TSC_XGXS_ANARX_CONTROL3r_CLR
#define ANARX_CONTROL3r_SET BCMI_TSC_XGXS_ANARX_CONTROL3r_SET
#define ANARX_CONTROL3r_GET BCMI_TSC_XGXS_ANARX_CONTROL3r_GET
#define ANARX_CONTROL3r_EN_CLK16f_GET BCMI_TSC_XGXS_ANARX_CONTROL3r_EN_CLK16f_GET
#define ANARX_CONTROL3r_EN_CLK16f_SET BCMI_TSC_XGXS_ANARX_CONTROL3r_EN_CLK16f_SET
#define ANARX_CONTROL3r_EN_CLK33f_GET BCMI_TSC_XGXS_ANARX_CONTROL3r_EN_CLK33f_GET
#define ANARX_CONTROL3r_EN_CLK33f_SET BCMI_TSC_XGXS_ANARX_CONTROL3r_EN_CLK33f_SET
#define ANARX_CONTROL3r_EN_VCCTRLf_GET BCMI_TSC_XGXS_ANARX_CONTROL3r_EN_VCCTRLf_GET
#define ANARX_CONTROL3r_EN_VCCTRLf_SET BCMI_TSC_XGXS_ANARX_CONTROL3r_EN_VCCTRLf_SET
#define ANARX_CONTROL3r_SEL_TH4DFE1f_GET BCMI_TSC_XGXS_ANARX_CONTROL3r_SEL_TH4DFE1f_GET
#define ANARX_CONTROL3r_SEL_TH4DFE1f_SET BCMI_TSC_XGXS_ANARX_CONTROL3r_SEL_TH4DFE1f_SET
#define ANARX_CONTROL3r_SEL_TH4DFE0f_GET BCMI_TSC_XGXS_ANARX_CONTROL3r_SEL_TH4DFE0f_GET
#define ANARX_CONTROL3r_SEL_TH4DFE0f_SET BCMI_TSC_XGXS_ANARX_CONTROL3r_SEL_TH4DFE0f_SET
#define ANARX_CONTROL3r_SELUGBW1f_GET BCMI_TSC_XGXS_ANARX_CONTROL3r_SELUGBW1f_GET
#define ANARX_CONTROL3r_SELUGBW1f_SET BCMI_TSC_XGXS_ANARX_CONTROL3r_SELUGBW1f_SET
#define ANARX_CONTROL3r_SELUGBW0f_GET BCMI_TSC_XGXS_ANARX_CONTROL3r_SELUGBW0f_GET
#define ANARX_CONTROL3r_SELUGBW0f_SET BCMI_TSC_XGXS_ANARX_CONTROL3r_SELUGBW0f_SET
#define ANARX_CONTROL3r_IMAX_DFETAPf_GET BCMI_TSC_XGXS_ANARX_CONTROL3r_IMAX_DFETAPf_GET
#define ANARX_CONTROL3r_IMAX_DFETAPf_SET BCMI_TSC_XGXS_ANARX_CONTROL3r_IMAX_DFETAPf_SET
#define ANARX_CONTROL3r_IMODE_DFETAPf_GET BCMI_TSC_XGXS_ANARX_CONTROL3r_IMODE_DFETAPf_GET
#define ANARX_CONTROL3r_IMODE_DFETAPf_SET BCMI_TSC_XGXS_ANARX_CONTROL3r_IMODE_DFETAPf_SET
#define ANARX_CONTROL3r_IMIN_DFETAPf_GET BCMI_TSC_XGXS_ANARX_CONTROL3r_IMIN_DFETAPf_GET
#define ANARX_CONTROL3r_IMIN_DFETAPf_SET BCMI_TSC_XGXS_ANARX_CONTROL3r_IMIN_DFETAPf_SET
#define ANARX_CONTROL3r_IMAX_SLCD2Cf_GET BCMI_TSC_XGXS_ANARX_CONTROL3r_IMAX_SLCD2Cf_GET
#define ANARX_CONTROL3r_IMAX_SLCD2Cf_SET BCMI_TSC_XGXS_ANARX_CONTROL3r_IMAX_SLCD2Cf_SET
#define ANARX_CONTROL3r_IMODE_SLCD2Cf_GET BCMI_TSC_XGXS_ANARX_CONTROL3r_IMODE_SLCD2Cf_GET
#define ANARX_CONTROL3r_IMODE_SLCD2Cf_SET BCMI_TSC_XGXS_ANARX_CONTROL3r_IMODE_SLCD2Cf_SET
#define ANARX_CONTROL3r_IMIN_SLCD2Cf_GET BCMI_TSC_XGXS_ANARX_CONTROL3r_IMIN_SLCD2Cf_GET
#define ANARX_CONTROL3r_IMIN_SLCD2Cf_SET BCMI_TSC_XGXS_ANARX_CONTROL3r_IMIN_SLCD2Cf_SET
#define ANARX_CONTROL3r_IMAX_DFEVREFf_GET BCMI_TSC_XGXS_ANARX_CONTROL3r_IMAX_DFEVREFf_GET
#define ANARX_CONTROL3r_IMAX_DFEVREFf_SET BCMI_TSC_XGXS_ANARX_CONTROL3r_IMAX_DFEVREFf_SET
#define ANARX_CONTROL3r_IMODE_DFEVREFf_GET BCMI_TSC_XGXS_ANARX_CONTROL3r_IMODE_DFEVREFf_GET
#define ANARX_CONTROL3r_IMODE_DFEVREFf_SET BCMI_TSC_XGXS_ANARX_CONTROL3r_IMODE_DFEVREFf_SET
#define ANARX_CONTROL3r_IMIN_DFEVREFf_GET BCMI_TSC_XGXS_ANARX_CONTROL3r_IMIN_DFEVREFf_GET
#define ANARX_CONTROL3r_IMIN_DFEVREFf_SET BCMI_TSC_XGXS_ANARX_CONTROL3r_IMIN_DFEVREFf_SET
#define READ_ANARX_CONTROL3r BCMI_TSC_XGXS_READ_ANARX_CONTROL3r
#define WRITE_ANARX_CONTROL3r BCMI_TSC_XGXS_WRITE_ANARX_CONTROL3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_ANARX_CONTROL3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  PATGENCTRL
 * BLOCKS:   PATGEN0
 * REGADDR:  0xc030
 * DESC:     Pattern Generator Control: 00000000
 * SIZE:     32
 * FIELDS:
 *     TESTSOURCE_SEL   
 *     PRBS_TX_EN       
 *     PRBS_RX_EN       
 *     PATGEN_EN        
 *     CLR_TXCNT        
 *     CLR_RXCNT        
 *     TESTGEN_BUS_WIDTH_TX 
 *     TESTGEN_BUS_WIDTH_RX 
 *     RX_FIXED_PATTERN_CHECK_ENABLE 
 *     RESERVED0        
 *     NUMBER_BIT       
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_PATGENCTRLr (0x0000c030 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_PATGENCTRLr_SIZE 4

/*
 * This structure should be used to declare and program PATGENCTRL.
 *
 */
typedef union BCMI_TSC_XGXS_PATGENCTRLr_s {
	uint32_t v[1];
	uint32_t patgenctrl[1];
	uint32_t _patgenctrl;
} BCMI_TSC_XGXS_PATGENCTRLr_t;

#define BCMI_TSC_XGXS_PATGENCTRLr_CLR(r) (r).patgenctrl[0] = 0
#define BCMI_TSC_XGXS_PATGENCTRLr_SET(r,d) (r).patgenctrl[0] = d
#define BCMI_TSC_XGXS_PATGENCTRLr_GET(r) (r).patgenctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_PATGENCTRLr_NUMBER_BITf_GET(r) ((((r).patgenctrl[0]) >> 13) & 0x7)
#define BCMI_TSC_XGXS_PATGENCTRLr_NUMBER_BITf_SET(r,f) (r).patgenctrl[0]=(((r).patgenctrl[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))
#define BCMI_TSC_XGXS_PATGENCTRLr_RESERVED0f_GET(r) ((((r).patgenctrl[0]) >> 9) & 0xf)
#define BCMI_TSC_XGXS_PATGENCTRLr_RESERVED0f_SET(r,f) (r).patgenctrl[0]=(((r).patgenctrl[0] & ~((uint32_t)0xf << 9)) | ((((uint32_t)f) & 0xf) << 9))
#define BCMI_TSC_XGXS_PATGENCTRLr_RX_FIXED_PATTERN_CHECK_ENABLEf_GET(r) ((((r).patgenctrl[0]) >> 8) & 0x1)
#define BCMI_TSC_XGXS_PATGENCTRLr_RX_FIXED_PATTERN_CHECK_ENABLEf_SET(r,f) (r).patgenctrl[0]=(((r).patgenctrl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCMI_TSC_XGXS_PATGENCTRLr_TESTGEN_BUS_WIDTH_RXf_GET(r) ((((r).patgenctrl[0]) >> 7) & 0x1)
#define BCMI_TSC_XGXS_PATGENCTRLr_TESTGEN_BUS_WIDTH_RXf_SET(r,f) (r).patgenctrl[0]=(((r).patgenctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCMI_TSC_XGXS_PATGENCTRLr_TESTGEN_BUS_WIDTH_TXf_GET(r) ((((r).patgenctrl[0]) >> 6) & 0x1)
#define BCMI_TSC_XGXS_PATGENCTRLr_TESTGEN_BUS_WIDTH_TXf_SET(r,f) (r).patgenctrl[0]=(((r).patgenctrl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCMI_TSC_XGXS_PATGENCTRLr_CLR_RXCNTf_GET(r) ((((r).patgenctrl[0]) >> 5) & 0x1)
#define BCMI_TSC_XGXS_PATGENCTRLr_CLR_RXCNTf_SET(r,f) (r).patgenctrl[0]=(((r).patgenctrl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCMI_TSC_XGXS_PATGENCTRLr_CLR_TXCNTf_GET(r) ((((r).patgenctrl[0]) >> 4) & 0x1)
#define BCMI_TSC_XGXS_PATGENCTRLr_CLR_TXCNTf_SET(r,f) (r).patgenctrl[0]=(((r).patgenctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCMI_TSC_XGXS_PATGENCTRLr_PATGEN_ENf_GET(r) ((((r).patgenctrl[0]) >> 3) & 0x1)
#define BCMI_TSC_XGXS_PATGENCTRLr_PATGEN_ENf_SET(r,f) (r).patgenctrl[0]=(((r).patgenctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCMI_TSC_XGXS_PATGENCTRLr_PRBS_RX_ENf_GET(r) ((((r).patgenctrl[0]) >> 2) & 0x1)
#define BCMI_TSC_XGXS_PATGENCTRLr_PRBS_RX_ENf_SET(r,f) (r).patgenctrl[0]=(((r).patgenctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCMI_TSC_XGXS_PATGENCTRLr_PRBS_TX_ENf_GET(r) ((((r).patgenctrl[0]) >> 1) & 0x1)
#define BCMI_TSC_XGXS_PATGENCTRLr_PRBS_TX_ENf_SET(r,f) (r).patgenctrl[0]=(((r).patgenctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCMI_TSC_XGXS_PATGENCTRLr_TESTSOURCE_SELf_GET(r) (((r).patgenctrl[0]) & 0x1)
#define BCMI_TSC_XGXS_PATGENCTRLr_TESTSOURCE_SELf_SET(r,f) (r).patgenctrl[0]=(((r).patgenctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access PATGENCTRL.
 *
 */
#define BCMI_TSC_XGXS_READ_PATGENCTRLr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_PATGENCTRLr,(_r._patgenctrl))
#define BCMI_TSC_XGXS_WRITE_PATGENCTRLr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_PATGENCTRLr,(_r._patgenctrl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PATGENCTRLr BCMI_TSC_XGXS_PATGENCTRLr
#define PATGENCTRLr_SIZE BCMI_TSC_XGXS_PATGENCTRLr_SIZE
typedef BCMI_TSC_XGXS_PATGENCTRLr_t PATGENCTRLr_t;
#define PATGENCTRLr_CLR BCMI_TSC_XGXS_PATGENCTRLr_CLR
#define PATGENCTRLr_SET BCMI_TSC_XGXS_PATGENCTRLr_SET
#define PATGENCTRLr_GET BCMI_TSC_XGXS_PATGENCTRLr_GET
#define PATGENCTRLr_NUMBER_BITf_GET BCMI_TSC_XGXS_PATGENCTRLr_NUMBER_BITf_GET
#define PATGENCTRLr_NUMBER_BITf_SET BCMI_TSC_XGXS_PATGENCTRLr_NUMBER_BITf_SET
#define PATGENCTRLr_RESERVED0f_GET BCMI_TSC_XGXS_PATGENCTRLr_RESERVED0f_GET
#define PATGENCTRLr_RESERVED0f_SET BCMI_TSC_XGXS_PATGENCTRLr_RESERVED0f_SET
#define PATGENCTRLr_RX_FIXED_PATTERN_CHECK_ENABLEf_GET BCMI_TSC_XGXS_PATGENCTRLr_RX_FIXED_PATTERN_CHECK_ENABLEf_GET
#define PATGENCTRLr_RX_FIXED_PATTERN_CHECK_ENABLEf_SET BCMI_TSC_XGXS_PATGENCTRLr_RX_FIXED_PATTERN_CHECK_ENABLEf_SET
#define PATGENCTRLr_TESTGEN_BUS_WIDTH_RXf_GET BCMI_TSC_XGXS_PATGENCTRLr_TESTGEN_BUS_WIDTH_RXf_GET
#define PATGENCTRLr_TESTGEN_BUS_WIDTH_RXf_SET BCMI_TSC_XGXS_PATGENCTRLr_TESTGEN_BUS_WIDTH_RXf_SET
#define PATGENCTRLr_TESTGEN_BUS_WIDTH_TXf_GET BCMI_TSC_XGXS_PATGENCTRLr_TESTGEN_BUS_WIDTH_TXf_GET
#define PATGENCTRLr_TESTGEN_BUS_WIDTH_TXf_SET BCMI_TSC_XGXS_PATGENCTRLr_TESTGEN_BUS_WIDTH_TXf_SET
#define PATGENCTRLr_CLR_RXCNTf_GET BCMI_TSC_XGXS_PATGENCTRLr_CLR_RXCNTf_GET
#define PATGENCTRLr_CLR_RXCNTf_SET BCMI_TSC_XGXS_PATGENCTRLr_CLR_RXCNTf_SET
#define PATGENCTRLr_CLR_TXCNTf_GET BCMI_TSC_XGXS_PATGENCTRLr_CLR_TXCNTf_GET
#define PATGENCTRLr_CLR_TXCNTf_SET BCMI_TSC_XGXS_PATGENCTRLr_CLR_TXCNTf_SET
#define PATGENCTRLr_PATGEN_ENf_GET BCMI_TSC_XGXS_PATGENCTRLr_PATGEN_ENf_GET
#define PATGENCTRLr_PATGEN_ENf_SET BCMI_TSC_XGXS_PATGENCTRLr_PATGEN_ENf_SET
#define PATGENCTRLr_PRBS_RX_ENf_GET BCMI_TSC_XGXS_PATGENCTRLr_PRBS_RX_ENf_GET
#define PATGENCTRLr_PRBS_RX_ENf_SET BCMI_TSC_XGXS_PATGENCTRLr_PRBS_RX_ENf_SET
#define PATGENCTRLr_PRBS_TX_ENf_GET BCMI_TSC_XGXS_PATGENCTRLr_PRBS_TX_ENf_GET
#define PATGENCTRLr_PRBS_TX_ENf_SET BCMI_TSC_XGXS_PATGENCTRLr_PRBS_TX_ENf_SET
#define PATGENCTRLr_TESTSOURCE_SELf_GET BCMI_TSC_XGXS_PATGENCTRLr_TESTSOURCE_SELf_GET
#define PATGENCTRLr_TESTSOURCE_SELf_SET BCMI_TSC_XGXS_PATGENCTRLr_TESTSOURCE_SELf_SET
#define READ_PATGENCTRLr BCMI_TSC_XGXS_READ_PATGENCTRLr
#define WRITE_PATGENCTRLr BCMI_TSC_XGXS_WRITE_PATGENCTRLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_PATGENCTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  PRBSCTRL
 * BLOCKS:   PATGEN0
 * REGADDR:  0xc031
 * DESC:     PRBS Control: 00000000
 * SIZE:     32
 * FIELDS:
 *     PRBS_SEL_TX      
 *     PRBS_INV_TX      
 *     LOAD_PRBS_SEED   
 *     RESERVED1        
 *     PRBS_SEL_RX      
 *     PRBS_INV_RX      
 *     PRBS_CHECK_MODE  
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_PRBSCTRLr (0x0000c031 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_PRBSCTRLr_SIZE 4

/*
 * This structure should be used to declare and program PRBSCTRL.
 *
 */
typedef union BCMI_TSC_XGXS_PRBSCTRLr_s {
	uint32_t v[1];
	uint32_t prbsctrl[1];
	uint32_t _prbsctrl;
} BCMI_TSC_XGXS_PRBSCTRLr_t;

#define BCMI_TSC_XGXS_PRBSCTRLr_CLR(r) (r).prbsctrl[0] = 0
#define BCMI_TSC_XGXS_PRBSCTRLr_SET(r,d) (r).prbsctrl[0] = d
#define BCMI_TSC_XGXS_PRBSCTRLr_GET(r) (r).prbsctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_PRBSCTRLr_RESERVED0f_GET(r) ((((r).prbsctrl[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_PRBSCTRLr_RESERVED0f_SET(r,f) (r).prbsctrl[0]=(((r).prbsctrl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_PRBSCTRLr_PRBS_CHECK_MODEf_GET(r) ((((r).prbsctrl[0]) >> 12) & 0x7)
#define BCMI_TSC_XGXS_PRBSCTRLr_PRBS_CHECK_MODEf_SET(r,f) (r).prbsctrl[0]=(((r).prbsctrl[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCMI_TSC_XGXS_PRBSCTRLr_PRBS_INV_RXf_GET(r) ((((r).prbsctrl[0]) >> 11) & 0x1)
#define BCMI_TSC_XGXS_PRBSCTRLr_PRBS_INV_RXf_SET(r,f) (r).prbsctrl[0]=(((r).prbsctrl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCMI_TSC_XGXS_PRBSCTRLr_PRBS_SEL_RXf_GET(r) ((((r).prbsctrl[0]) >> 8) & 0x7)
#define BCMI_TSC_XGXS_PRBSCTRLr_PRBS_SEL_RXf_SET(r,f) (r).prbsctrl[0]=(((r).prbsctrl[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8))
#define BCMI_TSC_XGXS_PRBSCTRLr_RESERVED1f_GET(r) ((((r).prbsctrl[0]) >> 5) & 0x7)
#define BCMI_TSC_XGXS_PRBSCTRLr_RESERVED1f_SET(r,f) (r).prbsctrl[0]=(((r).prbsctrl[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))
#define BCMI_TSC_XGXS_PRBSCTRLr_LOAD_PRBS_SEEDf_GET(r) ((((r).prbsctrl[0]) >> 4) & 0x1)
#define BCMI_TSC_XGXS_PRBSCTRLr_LOAD_PRBS_SEEDf_SET(r,f) (r).prbsctrl[0]=(((r).prbsctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCMI_TSC_XGXS_PRBSCTRLr_PRBS_INV_TXf_GET(r) ((((r).prbsctrl[0]) >> 3) & 0x1)
#define BCMI_TSC_XGXS_PRBSCTRLr_PRBS_INV_TXf_SET(r,f) (r).prbsctrl[0]=(((r).prbsctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCMI_TSC_XGXS_PRBSCTRLr_PRBS_SEL_TXf_GET(r) (((r).prbsctrl[0]) & 0x7)
#define BCMI_TSC_XGXS_PRBSCTRLr_PRBS_SEL_TXf_SET(r,f) (r).prbsctrl[0]=(((r).prbsctrl[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))

/*
 * These macros can be used to access PRBSCTRL.
 *
 */
#define BCMI_TSC_XGXS_READ_PRBSCTRLr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_PRBSCTRLr,(_r._prbsctrl))
#define BCMI_TSC_XGXS_WRITE_PRBSCTRLr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_PRBSCTRLr,(_r._prbsctrl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PRBSCTRLr BCMI_TSC_XGXS_PRBSCTRLr
#define PRBSCTRLr_SIZE BCMI_TSC_XGXS_PRBSCTRLr_SIZE
typedef BCMI_TSC_XGXS_PRBSCTRLr_t PRBSCTRLr_t;
#define PRBSCTRLr_CLR BCMI_TSC_XGXS_PRBSCTRLr_CLR
#define PRBSCTRLr_SET BCMI_TSC_XGXS_PRBSCTRLr_SET
#define PRBSCTRLr_GET BCMI_TSC_XGXS_PRBSCTRLr_GET
#define PRBSCTRLr_RESERVED0f_GET BCMI_TSC_XGXS_PRBSCTRLr_RESERVED0f_GET
#define PRBSCTRLr_RESERVED0f_SET BCMI_TSC_XGXS_PRBSCTRLr_RESERVED0f_SET
#define PRBSCTRLr_PRBS_CHECK_MODEf_GET BCMI_TSC_XGXS_PRBSCTRLr_PRBS_CHECK_MODEf_GET
#define PRBSCTRLr_PRBS_CHECK_MODEf_SET BCMI_TSC_XGXS_PRBSCTRLr_PRBS_CHECK_MODEf_SET
#define PRBSCTRLr_PRBS_INV_RXf_GET BCMI_TSC_XGXS_PRBSCTRLr_PRBS_INV_RXf_GET
#define PRBSCTRLr_PRBS_INV_RXf_SET BCMI_TSC_XGXS_PRBSCTRLr_PRBS_INV_RXf_SET
#define PRBSCTRLr_PRBS_SEL_RXf_GET BCMI_TSC_XGXS_PRBSCTRLr_PRBS_SEL_RXf_GET
#define PRBSCTRLr_PRBS_SEL_RXf_SET BCMI_TSC_XGXS_PRBSCTRLr_PRBS_SEL_RXf_SET
#define PRBSCTRLr_RESERVED1f_GET BCMI_TSC_XGXS_PRBSCTRLr_RESERVED1f_GET
#define PRBSCTRLr_RESERVED1f_SET BCMI_TSC_XGXS_PRBSCTRLr_RESERVED1f_SET
#define PRBSCTRLr_LOAD_PRBS_SEEDf_GET BCMI_TSC_XGXS_PRBSCTRLr_LOAD_PRBS_SEEDf_GET
#define PRBSCTRLr_LOAD_PRBS_SEEDf_SET BCMI_TSC_XGXS_PRBSCTRLr_LOAD_PRBS_SEEDf_SET
#define PRBSCTRLr_PRBS_INV_TXf_GET BCMI_TSC_XGXS_PRBSCTRLr_PRBS_INV_TXf_GET
#define PRBSCTRLr_PRBS_INV_TXf_SET BCMI_TSC_XGXS_PRBSCTRLr_PRBS_INV_TXf_SET
#define PRBSCTRLr_PRBS_SEL_TXf_GET BCMI_TSC_XGXS_PRBSCTRLr_PRBS_SEL_TXf_GET
#define PRBSCTRLr_PRBS_SEL_TXf_SET BCMI_TSC_XGXS_PRBSCTRLr_PRBS_SEL_TXf_SET
#define READ_PRBSCTRLr BCMI_TSC_XGXS_READ_PRBSCTRLr
#define WRITE_PRBSCTRLr BCMI_TSC_XGXS_WRITE_PRBSCTRLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_PRBSCTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  PRBSSTAT0
 * BLOCKS:   PATGEN0
 * REGADDR:  0xc032
 * DESC:     PRBS Status: 00000000
 * SIZE:     32
 * FIELDS:
 *     PRBS_ERROR_HI    
 *     PRBS_LOCK_LOST_LH 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_PRBSSTAT0r (0x0000c032 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_PRBSSTAT0r_SIZE 4

/*
 * This structure should be used to declare and program PRBSSTAT0.
 *
 */
typedef union BCMI_TSC_XGXS_PRBSSTAT0r_s {
	uint32_t v[1];
	uint32_t prbsstat0[1];
	uint32_t _prbsstat0;
} BCMI_TSC_XGXS_PRBSSTAT0r_t;

#define BCMI_TSC_XGXS_PRBSSTAT0r_CLR(r) (r).prbsstat0[0] = 0
#define BCMI_TSC_XGXS_PRBSSTAT0r_SET(r,d) (r).prbsstat0[0] = d
#define BCMI_TSC_XGXS_PRBSSTAT0r_GET(r) (r).prbsstat0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_PRBSSTAT0r_PRBS_LOCK_LOST_LHf_GET(r) ((((r).prbsstat0[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_PRBSSTAT0r_PRBS_LOCK_LOST_LHf_SET(r,f) (r).prbsstat0[0]=(((r).prbsstat0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_PRBSSTAT0r_PRBS_ERROR_HIf_GET(r) (((r).prbsstat0[0]) & 0x7fff)
#define BCMI_TSC_XGXS_PRBSSTAT0r_PRBS_ERROR_HIf_SET(r,f) (r).prbsstat0[0]=(((r).prbsstat0[0] & ~((uint32_t)0x7fff)) | (((uint32_t)f) & 0x7fff))

/*
 * These macros can be used to access PRBSSTAT0.
 *
 */
#define BCMI_TSC_XGXS_READ_PRBSSTAT0r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_PRBSSTAT0r,(_r._prbsstat0))
#define BCMI_TSC_XGXS_WRITE_PRBSSTAT0r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_PRBSSTAT0r,(_r._prbsstat0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PRBSSTAT0r BCMI_TSC_XGXS_PRBSSTAT0r
#define PRBSSTAT0r_SIZE BCMI_TSC_XGXS_PRBSSTAT0r_SIZE
typedef BCMI_TSC_XGXS_PRBSSTAT0r_t PRBSSTAT0r_t;
#define PRBSSTAT0r_CLR BCMI_TSC_XGXS_PRBSSTAT0r_CLR
#define PRBSSTAT0r_SET BCMI_TSC_XGXS_PRBSSTAT0r_SET
#define PRBSSTAT0r_GET BCMI_TSC_XGXS_PRBSSTAT0r_GET
#define PRBSSTAT0r_PRBS_LOCK_LOST_LHf_GET BCMI_TSC_XGXS_PRBSSTAT0r_PRBS_LOCK_LOST_LHf_GET
#define PRBSSTAT0r_PRBS_LOCK_LOST_LHf_SET BCMI_TSC_XGXS_PRBSSTAT0r_PRBS_LOCK_LOST_LHf_SET
#define PRBSSTAT0r_PRBS_ERROR_HIf_GET BCMI_TSC_XGXS_PRBSSTAT0r_PRBS_ERROR_HIf_GET
#define PRBSSTAT0r_PRBS_ERROR_HIf_SET BCMI_TSC_XGXS_PRBSSTAT0r_PRBS_ERROR_HIf_SET
#define READ_PRBSSTAT0r BCMI_TSC_XGXS_READ_PRBSSTAT0r
#define WRITE_PRBSSTAT0r BCMI_TSC_XGXS_WRITE_PRBSSTAT0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_PRBSSTAT0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  PRBSSTAT1
 * BLOCKS:   PATGEN0
 * REGADDR:  0xc033
 * DESC:     PRBS Status: 00000000
 * SIZE:     32
 * FIELDS:
 *     PRBS_ERROR_LO    
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_PRBSSTAT1r (0x0000c033 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_PRBSSTAT1r_SIZE 4

/*
 * This structure should be used to declare and program PRBSSTAT1.
 *
 */
typedef union BCMI_TSC_XGXS_PRBSSTAT1r_s {
	uint32_t v[1];
	uint32_t prbsstat1[1];
	uint32_t _prbsstat1;
} BCMI_TSC_XGXS_PRBSSTAT1r_t;

#define BCMI_TSC_XGXS_PRBSSTAT1r_CLR(r) (r).prbsstat1[0] = 0
#define BCMI_TSC_XGXS_PRBSSTAT1r_SET(r,d) (r).prbsstat1[0] = d
#define BCMI_TSC_XGXS_PRBSSTAT1r_GET(r) (r).prbsstat1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_PRBSSTAT1r_PRBS_ERROR_LOf_GET(r) (((r).prbsstat1[0]) & 0xffff)
#define BCMI_TSC_XGXS_PRBSSTAT1r_PRBS_ERROR_LOf_SET(r,f) (r).prbsstat1[0]=(((r).prbsstat1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PRBSSTAT1.
 *
 */
#define BCMI_TSC_XGXS_READ_PRBSSTAT1r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_PRBSSTAT1r,(_r._prbsstat1))
#define BCMI_TSC_XGXS_WRITE_PRBSSTAT1r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_PRBSSTAT1r,(_r._prbsstat1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PRBSSTAT1r BCMI_TSC_XGXS_PRBSSTAT1r
#define PRBSSTAT1r_SIZE BCMI_TSC_XGXS_PRBSSTAT1r_SIZE
typedef BCMI_TSC_XGXS_PRBSSTAT1r_t PRBSSTAT1r_t;
#define PRBSSTAT1r_CLR BCMI_TSC_XGXS_PRBSSTAT1r_CLR
#define PRBSSTAT1r_SET BCMI_TSC_XGXS_PRBSSTAT1r_SET
#define PRBSSTAT1r_GET BCMI_TSC_XGXS_PRBSSTAT1r_GET
#define PRBSSTAT1r_PRBS_ERROR_LOf_GET BCMI_TSC_XGXS_PRBSSTAT1r_PRBS_ERROR_LOf_GET
#define PRBSSTAT1r_PRBS_ERROR_LOf_SET BCMI_TSC_XGXS_PRBSSTAT1r_PRBS_ERROR_LOf_SET
#define READ_PRBSSTAT1r BCMI_TSC_XGXS_READ_PRBSSTAT1r
#define WRITE_PRBSSTAT1r BCMI_TSC_XGXS_WRITE_PRBSSTAT1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_PRBSSTAT1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  TESTMISCSTATUS
 * BLOCKS:   PATGEN0
 * REGADDR:  0xc034
 * DESC:     MISCELLANEOUS TEST Status: 00000000
 * SIZE:     32
 * FIELDS:
 *     PRTP_LOCK        
 *     PRBS_LOCK        
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_TESTMISCSTATUSr (0x0000c034 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_TESTMISCSTATUSr_SIZE 4

/*
 * This structure should be used to declare and program TESTMISCSTATUS.
 *
 */
typedef union BCMI_TSC_XGXS_TESTMISCSTATUSr_s {
	uint32_t v[1];
	uint32_t testmiscstatus[1];
	uint32_t _testmiscstatus;
} BCMI_TSC_XGXS_TESTMISCSTATUSr_t;

#define BCMI_TSC_XGXS_TESTMISCSTATUSr_CLR(r) (r).testmiscstatus[0] = 0
#define BCMI_TSC_XGXS_TESTMISCSTATUSr_SET(r,d) (r).testmiscstatus[0] = d
#define BCMI_TSC_XGXS_TESTMISCSTATUSr_GET(r) (r).testmiscstatus[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_TESTMISCSTATUSr_RESERVED0f_GET(r) ((((r).testmiscstatus[0]) >> 2) & 0x3fff)
#define BCMI_TSC_XGXS_TESTMISCSTATUSr_RESERVED0f_SET(r,f) (r).testmiscstatus[0]=(((r).testmiscstatus[0] & ~((uint32_t)0x3fff << 2)) | ((((uint32_t)f) & 0x3fff) << 2))
#define BCMI_TSC_XGXS_TESTMISCSTATUSr_PRBS_LOCKf_GET(r) ((((r).testmiscstatus[0]) >> 1) & 0x1)
#define BCMI_TSC_XGXS_TESTMISCSTATUSr_PRBS_LOCKf_SET(r,f) (r).testmiscstatus[0]=(((r).testmiscstatus[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCMI_TSC_XGXS_TESTMISCSTATUSr_PRTP_LOCKf_GET(r) (((r).testmiscstatus[0]) & 0x1)
#define BCMI_TSC_XGXS_TESTMISCSTATUSr_PRTP_LOCKf_SET(r,f) (r).testmiscstatus[0]=(((r).testmiscstatus[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access TESTMISCSTATUS.
 *
 */
#define BCMI_TSC_XGXS_READ_TESTMISCSTATUSr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_TESTMISCSTATUSr,(_r._testmiscstatus))
#define BCMI_TSC_XGXS_WRITE_TESTMISCSTATUSr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_TESTMISCSTATUSr,(_r._testmiscstatus))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TESTMISCSTATUSr BCMI_TSC_XGXS_TESTMISCSTATUSr
#define TESTMISCSTATUSr_SIZE BCMI_TSC_XGXS_TESTMISCSTATUSr_SIZE
typedef BCMI_TSC_XGXS_TESTMISCSTATUSr_t TESTMISCSTATUSr_t;
#define TESTMISCSTATUSr_CLR BCMI_TSC_XGXS_TESTMISCSTATUSr_CLR
#define TESTMISCSTATUSr_SET BCMI_TSC_XGXS_TESTMISCSTATUSr_SET
#define TESTMISCSTATUSr_GET BCMI_TSC_XGXS_TESTMISCSTATUSr_GET
#define TESTMISCSTATUSr_RESERVED0f_GET BCMI_TSC_XGXS_TESTMISCSTATUSr_RESERVED0f_GET
#define TESTMISCSTATUSr_RESERVED0f_SET BCMI_TSC_XGXS_TESTMISCSTATUSr_RESERVED0f_SET
#define TESTMISCSTATUSr_PRBS_LOCKf_GET BCMI_TSC_XGXS_TESTMISCSTATUSr_PRBS_LOCKf_GET
#define TESTMISCSTATUSr_PRBS_LOCKf_SET BCMI_TSC_XGXS_TESTMISCSTATUSr_PRBS_LOCKf_SET
#define TESTMISCSTATUSr_PRTP_LOCKf_GET BCMI_TSC_XGXS_TESTMISCSTATUSr_PRTP_LOCKf_GET
#define TESTMISCSTATUSr_PRTP_LOCKf_SET BCMI_TSC_XGXS_TESTMISCSTATUSr_PRTP_LOCKf_SET
#define READ_TESTMISCSTATUSr BCMI_TSC_XGXS_READ_TESTMISCSTATUSr
#define WRITE_TESTMISCSTATUSr BCMI_TSC_XGXS_WRITE_TESTMISCSTATUSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_TESTMISCSTATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  TXPKTCNT_U
 * BLOCKS:   PATGEN1
 * REGADDR:  0xc040
 * DESC:     TX Packet Count Upper Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     TXPKTCNT_U       
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_TXPKTCNT_Ur (0x0000c040 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_TXPKTCNT_Ur_SIZE 4

/*
 * This structure should be used to declare and program TXPKTCNT_U.
 *
 */
typedef union BCMI_TSC_XGXS_TXPKTCNT_Ur_s {
	uint32_t v[1];
	uint32_t txpktcnt_u[1];
	uint32_t _txpktcnt_u;
} BCMI_TSC_XGXS_TXPKTCNT_Ur_t;

#define BCMI_TSC_XGXS_TXPKTCNT_Ur_CLR(r) (r).txpktcnt_u[0] = 0
#define BCMI_TSC_XGXS_TXPKTCNT_Ur_SET(r,d) (r).txpktcnt_u[0] = d
#define BCMI_TSC_XGXS_TXPKTCNT_Ur_GET(r) (r).txpktcnt_u[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_TXPKTCNT_Ur_TXPKTCNT_Uf_GET(r) (((r).txpktcnt_u[0]) & 0xffff)
#define BCMI_TSC_XGXS_TXPKTCNT_Ur_TXPKTCNT_Uf_SET(r,f) (r).txpktcnt_u[0]=(((r).txpktcnt_u[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access TXPKTCNT_U.
 *
 */
#define BCMI_TSC_XGXS_READ_TXPKTCNT_Ur(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_TXPKTCNT_Ur,(_r._txpktcnt_u))
#define BCMI_TSC_XGXS_WRITE_TXPKTCNT_Ur(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_TXPKTCNT_Ur,(_r._txpktcnt_u))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TXPKTCNT_Ur BCMI_TSC_XGXS_TXPKTCNT_Ur
#define TXPKTCNT_Ur_SIZE BCMI_TSC_XGXS_TXPKTCNT_Ur_SIZE
typedef BCMI_TSC_XGXS_TXPKTCNT_Ur_t TXPKTCNT_Ur_t;
#define TXPKTCNT_Ur_CLR BCMI_TSC_XGXS_TXPKTCNT_Ur_CLR
#define TXPKTCNT_Ur_SET BCMI_TSC_XGXS_TXPKTCNT_Ur_SET
#define TXPKTCNT_Ur_GET BCMI_TSC_XGXS_TXPKTCNT_Ur_GET
#define TXPKTCNT_Ur_TXPKTCNT_Uf_GET BCMI_TSC_XGXS_TXPKTCNT_Ur_TXPKTCNT_Uf_GET
#define TXPKTCNT_Ur_TXPKTCNT_Uf_SET BCMI_TSC_XGXS_TXPKTCNT_Ur_TXPKTCNT_Uf_SET
#define READ_TXPKTCNT_Ur BCMI_TSC_XGXS_READ_TXPKTCNT_Ur
#define WRITE_TXPKTCNT_Ur BCMI_TSC_XGXS_WRITE_TXPKTCNT_Ur

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_TXPKTCNT_Ur'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  TXPKTCNT_L
 * BLOCKS:   PATGEN1
 * REGADDR:  0xc041
 * DESC:     TX Packet Count Lower Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     TXPKTCNT_L       
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_TXPKTCNT_Lr (0x0000c041 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_TXPKTCNT_Lr_SIZE 4

/*
 * This structure should be used to declare and program TXPKTCNT_L.
 *
 */
typedef union BCMI_TSC_XGXS_TXPKTCNT_Lr_s {
	uint32_t v[1];
	uint32_t txpktcnt_l[1];
	uint32_t _txpktcnt_l;
} BCMI_TSC_XGXS_TXPKTCNT_Lr_t;

#define BCMI_TSC_XGXS_TXPKTCNT_Lr_CLR(r) (r).txpktcnt_l[0] = 0
#define BCMI_TSC_XGXS_TXPKTCNT_Lr_SET(r,d) (r).txpktcnt_l[0] = d
#define BCMI_TSC_XGXS_TXPKTCNT_Lr_GET(r) (r).txpktcnt_l[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_TXPKTCNT_Lr_TXPKTCNT_Lf_GET(r) (((r).txpktcnt_l[0]) & 0xffff)
#define BCMI_TSC_XGXS_TXPKTCNT_Lr_TXPKTCNT_Lf_SET(r,f) (r).txpktcnt_l[0]=(((r).txpktcnt_l[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access TXPKTCNT_L.
 *
 */
#define BCMI_TSC_XGXS_READ_TXPKTCNT_Lr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_TXPKTCNT_Lr,(_r._txpktcnt_l))
#define BCMI_TSC_XGXS_WRITE_TXPKTCNT_Lr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_TXPKTCNT_Lr,(_r._txpktcnt_l))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TXPKTCNT_Lr BCMI_TSC_XGXS_TXPKTCNT_Lr
#define TXPKTCNT_Lr_SIZE BCMI_TSC_XGXS_TXPKTCNT_Lr_SIZE
typedef BCMI_TSC_XGXS_TXPKTCNT_Lr_t TXPKTCNT_Lr_t;
#define TXPKTCNT_Lr_CLR BCMI_TSC_XGXS_TXPKTCNT_Lr_CLR
#define TXPKTCNT_Lr_SET BCMI_TSC_XGXS_TXPKTCNT_Lr_SET
#define TXPKTCNT_Lr_GET BCMI_TSC_XGXS_TXPKTCNT_Lr_GET
#define TXPKTCNT_Lr_TXPKTCNT_Lf_GET BCMI_TSC_XGXS_TXPKTCNT_Lr_TXPKTCNT_Lf_GET
#define TXPKTCNT_Lr_TXPKTCNT_Lf_SET BCMI_TSC_XGXS_TXPKTCNT_Lr_TXPKTCNT_Lf_SET
#define READ_TXPKTCNT_Lr BCMI_TSC_XGXS_READ_TXPKTCNT_Lr
#define WRITE_TXPKTCNT_Lr BCMI_TSC_XGXS_WRITE_TXPKTCNT_Lr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_TXPKTCNT_Lr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RXPKTCNT_U
 * BLOCKS:   PATGEN1
 * REGADDR:  0xc042
 * DESC:     RX Packet Count Upper Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     RXPKTCNT_U       
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RXPKTCNT_Ur (0x0000c042 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RXPKTCNT_Ur_SIZE 4

/*
 * This structure should be used to declare and program RXPKTCNT_U.
 *
 */
typedef union BCMI_TSC_XGXS_RXPKTCNT_Ur_s {
	uint32_t v[1];
	uint32_t rxpktcnt_u[1];
	uint32_t _rxpktcnt_u;
} BCMI_TSC_XGXS_RXPKTCNT_Ur_t;

#define BCMI_TSC_XGXS_RXPKTCNT_Ur_CLR(r) (r).rxpktcnt_u[0] = 0
#define BCMI_TSC_XGXS_RXPKTCNT_Ur_SET(r,d) (r).rxpktcnt_u[0] = d
#define BCMI_TSC_XGXS_RXPKTCNT_Ur_GET(r) (r).rxpktcnt_u[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RXPKTCNT_Ur_RXPKTCNT_Uf_GET(r) (((r).rxpktcnt_u[0]) & 0xffff)
#define BCMI_TSC_XGXS_RXPKTCNT_Ur_RXPKTCNT_Uf_SET(r,f) (r).rxpktcnt_u[0]=(((r).rxpktcnt_u[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access RXPKTCNT_U.
 *
 */
#define BCMI_TSC_XGXS_READ_RXPKTCNT_Ur(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RXPKTCNT_Ur,(_r._rxpktcnt_u))
#define BCMI_TSC_XGXS_WRITE_RXPKTCNT_Ur(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RXPKTCNT_Ur,(_r._rxpktcnt_u))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RXPKTCNT_Ur BCMI_TSC_XGXS_RXPKTCNT_Ur
#define RXPKTCNT_Ur_SIZE BCMI_TSC_XGXS_RXPKTCNT_Ur_SIZE
typedef BCMI_TSC_XGXS_RXPKTCNT_Ur_t RXPKTCNT_Ur_t;
#define RXPKTCNT_Ur_CLR BCMI_TSC_XGXS_RXPKTCNT_Ur_CLR
#define RXPKTCNT_Ur_SET BCMI_TSC_XGXS_RXPKTCNT_Ur_SET
#define RXPKTCNT_Ur_GET BCMI_TSC_XGXS_RXPKTCNT_Ur_GET
#define RXPKTCNT_Ur_RXPKTCNT_Uf_GET BCMI_TSC_XGXS_RXPKTCNT_Ur_RXPKTCNT_Uf_GET
#define RXPKTCNT_Ur_RXPKTCNT_Uf_SET BCMI_TSC_XGXS_RXPKTCNT_Ur_RXPKTCNT_Uf_SET
#define READ_RXPKTCNT_Ur BCMI_TSC_XGXS_READ_RXPKTCNT_Ur
#define WRITE_RXPKTCNT_Ur BCMI_TSC_XGXS_WRITE_RXPKTCNT_Ur

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RXPKTCNT_Ur'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RXPKTCNT_L
 * BLOCKS:   PATGEN1
 * REGADDR:  0xc043
 * DESC:     RX Packet Count Lower Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     RXPKTCNT_L       
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RXPKTCNT_Lr (0x0000c043 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RXPKTCNT_Lr_SIZE 4

/*
 * This structure should be used to declare and program RXPKTCNT_L.
 *
 */
typedef union BCMI_TSC_XGXS_RXPKTCNT_Lr_s {
	uint32_t v[1];
	uint32_t rxpktcnt_l[1];
	uint32_t _rxpktcnt_l;
} BCMI_TSC_XGXS_RXPKTCNT_Lr_t;

#define BCMI_TSC_XGXS_RXPKTCNT_Lr_CLR(r) (r).rxpktcnt_l[0] = 0
#define BCMI_TSC_XGXS_RXPKTCNT_Lr_SET(r,d) (r).rxpktcnt_l[0] = d
#define BCMI_TSC_XGXS_RXPKTCNT_Lr_GET(r) (r).rxpktcnt_l[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RXPKTCNT_Lr_RXPKTCNT_Lf_GET(r) (((r).rxpktcnt_l[0]) & 0xffff)
#define BCMI_TSC_XGXS_RXPKTCNT_Lr_RXPKTCNT_Lf_SET(r,f) (r).rxpktcnt_l[0]=(((r).rxpktcnt_l[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access RXPKTCNT_L.
 *
 */
#define BCMI_TSC_XGXS_READ_RXPKTCNT_Lr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RXPKTCNT_Lr,(_r._rxpktcnt_l))
#define BCMI_TSC_XGXS_WRITE_RXPKTCNT_Lr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RXPKTCNT_Lr,(_r._rxpktcnt_l))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RXPKTCNT_Lr BCMI_TSC_XGXS_RXPKTCNT_Lr
#define RXPKTCNT_Lr_SIZE BCMI_TSC_XGXS_RXPKTCNT_Lr_SIZE
typedef BCMI_TSC_XGXS_RXPKTCNT_Lr_t RXPKTCNT_Lr_t;
#define RXPKTCNT_Lr_CLR BCMI_TSC_XGXS_RXPKTCNT_Lr_CLR
#define RXPKTCNT_Lr_SET BCMI_TSC_XGXS_RXPKTCNT_Lr_SET
#define RXPKTCNT_Lr_GET BCMI_TSC_XGXS_RXPKTCNT_Lr_GET
#define RXPKTCNT_Lr_RXPKTCNT_Lf_GET BCMI_TSC_XGXS_RXPKTCNT_Lr_RXPKTCNT_Lf_GET
#define RXPKTCNT_Lr_RXPKTCNT_Lf_SET BCMI_TSC_XGXS_RXPKTCNT_Lr_RXPKTCNT_Lf_SET
#define READ_RXPKTCNT_Lr BCMI_TSC_XGXS_READ_RXPKTCNT_Lr
#define WRITE_RXPKTCNT_Lr BCMI_TSC_XGXS_WRITE_RXPKTCNT_Lr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RXPKTCNT_Lr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  TX_X4_CREDIT0
 * BLOCKS:   TX_X4_CREDIT0
 * REGADDR:  0xc100
 * DESC:     clock count 0 register: 00000000
 * SIZE:     32
 * FIELDS:
 *     CLOCKCNT0        
 *     CREDITENABLE     
 *     SGMII_SPD_SWITCH 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_TX_X4_CREDIT0r (0x0000c100 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_TX_X4_CREDIT0r_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_CREDIT0.
 *
 */
typedef union BCMI_TSC_XGXS_TX_X4_CREDIT0r_s {
	uint32_t v[1];
	uint32_t tx_x4_credit0[1];
	uint32_t _tx_x4_credit0;
} BCMI_TSC_XGXS_TX_X4_CREDIT0r_t;

#define BCMI_TSC_XGXS_TX_X4_CREDIT0r_CLR(r) (r).tx_x4_credit0[0] = 0
#define BCMI_TSC_XGXS_TX_X4_CREDIT0r_SET(r,d) (r).tx_x4_credit0[0] = d
#define BCMI_TSC_XGXS_TX_X4_CREDIT0r_GET(r) (r).tx_x4_credit0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_TX_X4_CREDIT0r_SGMII_SPD_SWITCHf_GET(r) ((((r).tx_x4_credit0[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_TX_X4_CREDIT0r_SGMII_SPD_SWITCHf_SET(r,f) (r).tx_x4_credit0[0]=(((r).tx_x4_credit0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_TX_X4_CREDIT0r_CREDITENABLEf_GET(r) ((((r).tx_x4_credit0[0]) >> 14) & 0x1)
#define BCMI_TSC_XGXS_TX_X4_CREDIT0r_CREDITENABLEf_SET(r,f) (r).tx_x4_credit0[0]=(((r).tx_x4_credit0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCMI_TSC_XGXS_TX_X4_CREDIT0r_CLOCKCNT0f_GET(r) (((r).tx_x4_credit0[0]) & 0x3fff)
#define BCMI_TSC_XGXS_TX_X4_CREDIT0r_CLOCKCNT0f_SET(r,f) (r).tx_x4_credit0[0]=(((r).tx_x4_credit0[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access TX_X4_CREDIT0.
 *
 */
#define BCMI_TSC_XGXS_READ_TX_X4_CREDIT0r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_TX_X4_CREDIT0r,(_r._tx_x4_credit0))
#define BCMI_TSC_XGXS_WRITE_TX_X4_CREDIT0r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_TX_X4_CREDIT0r,(_r._tx_x4_credit0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_CREDIT0r BCMI_TSC_XGXS_TX_X4_CREDIT0r
#define TX_X4_CREDIT0r_SIZE BCMI_TSC_XGXS_TX_X4_CREDIT0r_SIZE
typedef BCMI_TSC_XGXS_TX_X4_CREDIT0r_t TX_X4_CREDIT0r_t;
#define TX_X4_CREDIT0r_CLR BCMI_TSC_XGXS_TX_X4_CREDIT0r_CLR
#define TX_X4_CREDIT0r_SET BCMI_TSC_XGXS_TX_X4_CREDIT0r_SET
#define TX_X4_CREDIT0r_GET BCMI_TSC_XGXS_TX_X4_CREDIT0r_GET
#define TX_X4_CREDIT0r_SGMII_SPD_SWITCHf_GET BCMI_TSC_XGXS_TX_X4_CREDIT0r_SGMII_SPD_SWITCHf_GET
#define TX_X4_CREDIT0r_SGMII_SPD_SWITCHf_SET BCMI_TSC_XGXS_TX_X4_CREDIT0r_SGMII_SPD_SWITCHf_SET
#define TX_X4_CREDIT0r_CREDITENABLEf_GET BCMI_TSC_XGXS_TX_X4_CREDIT0r_CREDITENABLEf_GET
#define TX_X4_CREDIT0r_CREDITENABLEf_SET BCMI_TSC_XGXS_TX_X4_CREDIT0r_CREDITENABLEf_SET
#define TX_X4_CREDIT0r_CLOCKCNT0f_GET BCMI_TSC_XGXS_TX_X4_CREDIT0r_CLOCKCNT0f_GET
#define TX_X4_CREDIT0r_CLOCKCNT0f_SET BCMI_TSC_XGXS_TX_X4_CREDIT0r_CLOCKCNT0f_SET
#define READ_TX_X4_CREDIT0r BCMI_TSC_XGXS_READ_TX_X4_CREDIT0r
#define WRITE_TX_X4_CREDIT0r BCMI_TSC_XGXS_WRITE_TX_X4_CREDIT0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_TX_X4_CREDIT0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  TX_X4_CREDIT1
 * BLOCKS:   TX_X4_CREDIT0
 * REGADDR:  0xc101
 * DESC:     clock count 1 register: 00000000
 * SIZE:     32
 * FIELDS:
 *     CLOCKCNT1        
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_TX_X4_CREDIT1r (0x0000c101 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_TX_X4_CREDIT1r_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_CREDIT1.
 *
 */
typedef union BCMI_TSC_XGXS_TX_X4_CREDIT1r_s {
	uint32_t v[1];
	uint32_t tx_x4_credit1[1];
	uint32_t _tx_x4_credit1;
} BCMI_TSC_XGXS_TX_X4_CREDIT1r_t;

#define BCMI_TSC_XGXS_TX_X4_CREDIT1r_CLR(r) (r).tx_x4_credit1[0] = 0
#define BCMI_TSC_XGXS_TX_X4_CREDIT1r_SET(r,d) (r).tx_x4_credit1[0] = d
#define BCMI_TSC_XGXS_TX_X4_CREDIT1r_GET(r) (r).tx_x4_credit1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_TX_X4_CREDIT1r_RESERVED0f_GET(r) ((((r).tx_x4_credit1[0]) >> 8) & 0xff)
#define BCMI_TSC_XGXS_TX_X4_CREDIT1r_RESERVED0f_SET(r,f) (r).tx_x4_credit1[0]=(((r).tx_x4_credit1[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCMI_TSC_XGXS_TX_X4_CREDIT1r_CLOCKCNT1f_GET(r) (((r).tx_x4_credit1[0]) & 0xff)
#define BCMI_TSC_XGXS_TX_X4_CREDIT1r_CLOCKCNT1f_SET(r,f) (r).tx_x4_credit1[0]=(((r).tx_x4_credit1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access TX_X4_CREDIT1.
 *
 */
#define BCMI_TSC_XGXS_READ_TX_X4_CREDIT1r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_TX_X4_CREDIT1r,(_r._tx_x4_credit1))
#define BCMI_TSC_XGXS_WRITE_TX_X4_CREDIT1r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_TX_X4_CREDIT1r,(_r._tx_x4_credit1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_CREDIT1r BCMI_TSC_XGXS_TX_X4_CREDIT1r
#define TX_X4_CREDIT1r_SIZE BCMI_TSC_XGXS_TX_X4_CREDIT1r_SIZE
typedef BCMI_TSC_XGXS_TX_X4_CREDIT1r_t TX_X4_CREDIT1r_t;
#define TX_X4_CREDIT1r_CLR BCMI_TSC_XGXS_TX_X4_CREDIT1r_CLR
#define TX_X4_CREDIT1r_SET BCMI_TSC_XGXS_TX_X4_CREDIT1r_SET
#define TX_X4_CREDIT1r_GET BCMI_TSC_XGXS_TX_X4_CREDIT1r_GET
#define TX_X4_CREDIT1r_RESERVED0f_GET BCMI_TSC_XGXS_TX_X4_CREDIT1r_RESERVED0f_GET
#define TX_X4_CREDIT1r_RESERVED0f_SET BCMI_TSC_XGXS_TX_X4_CREDIT1r_RESERVED0f_SET
#define TX_X4_CREDIT1r_CLOCKCNT1f_GET BCMI_TSC_XGXS_TX_X4_CREDIT1r_CLOCKCNT1f_GET
#define TX_X4_CREDIT1r_CLOCKCNT1f_SET BCMI_TSC_XGXS_TX_X4_CREDIT1r_CLOCKCNT1f_SET
#define READ_TX_X4_CREDIT1r BCMI_TSC_XGXS_READ_TX_X4_CREDIT1r
#define WRITE_TX_X4_CREDIT1r BCMI_TSC_XGXS_WRITE_TX_X4_CREDIT1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_TX_X4_CREDIT1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  TX_X4_LOOPCNT
 * BLOCKS:   TX_X4_CREDIT0
 * REGADDR:  0xc102
 * DESC:     loop count 1_0 register: 00000000
 * SIZE:     32
 * FIELDS:
 *     LOOPCNT1         
 *     LOOPCNT0         
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_TX_X4_LOOPCNTr (0x0000c102 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_TX_X4_LOOPCNTr_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_LOOPCNT.
 *
 */
typedef union BCMI_TSC_XGXS_TX_X4_LOOPCNTr_s {
	uint32_t v[1];
	uint32_t tx_x4_loopcnt[1];
	uint32_t _tx_x4_loopcnt;
} BCMI_TSC_XGXS_TX_X4_LOOPCNTr_t;

#define BCMI_TSC_XGXS_TX_X4_LOOPCNTr_CLR(r) (r).tx_x4_loopcnt[0] = 0
#define BCMI_TSC_XGXS_TX_X4_LOOPCNTr_SET(r,d) (r).tx_x4_loopcnt[0] = d
#define BCMI_TSC_XGXS_TX_X4_LOOPCNTr_GET(r) (r).tx_x4_loopcnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_TX_X4_LOOPCNTr_RESERVED0f_GET(r) ((((r).tx_x4_loopcnt[0]) >> 14) & 0x3)
#define BCMI_TSC_XGXS_TX_X4_LOOPCNTr_RESERVED0f_SET(r,f) (r).tx_x4_loopcnt[0]=(((r).tx_x4_loopcnt[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCMI_TSC_XGXS_TX_X4_LOOPCNTr_LOOPCNT0f_GET(r) ((((r).tx_x4_loopcnt[0]) >> 6) & 0xff)
#define BCMI_TSC_XGXS_TX_X4_LOOPCNTr_LOOPCNT0f_SET(r,f) (r).tx_x4_loopcnt[0]=(((r).tx_x4_loopcnt[0] & ~((uint32_t)0xff << 6)) | ((((uint32_t)f) & 0xff) << 6))
#define BCMI_TSC_XGXS_TX_X4_LOOPCNTr_LOOPCNT1f_GET(r) (((r).tx_x4_loopcnt[0]) & 0x3f)
#define BCMI_TSC_XGXS_TX_X4_LOOPCNTr_LOOPCNT1f_SET(r,f) (r).tx_x4_loopcnt[0]=(((r).tx_x4_loopcnt[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))

/*
 * These macros can be used to access TX_X4_LOOPCNT.
 *
 */
#define BCMI_TSC_XGXS_READ_TX_X4_LOOPCNTr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_TX_X4_LOOPCNTr,(_r._tx_x4_loopcnt))
#define BCMI_TSC_XGXS_WRITE_TX_X4_LOOPCNTr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_TX_X4_LOOPCNTr,(_r._tx_x4_loopcnt))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_LOOPCNTr BCMI_TSC_XGXS_TX_X4_LOOPCNTr
#define TX_X4_LOOPCNTr_SIZE BCMI_TSC_XGXS_TX_X4_LOOPCNTr_SIZE
typedef BCMI_TSC_XGXS_TX_X4_LOOPCNTr_t TX_X4_LOOPCNTr_t;
#define TX_X4_LOOPCNTr_CLR BCMI_TSC_XGXS_TX_X4_LOOPCNTr_CLR
#define TX_X4_LOOPCNTr_SET BCMI_TSC_XGXS_TX_X4_LOOPCNTr_SET
#define TX_X4_LOOPCNTr_GET BCMI_TSC_XGXS_TX_X4_LOOPCNTr_GET
#define TX_X4_LOOPCNTr_RESERVED0f_GET BCMI_TSC_XGXS_TX_X4_LOOPCNTr_RESERVED0f_GET
#define TX_X4_LOOPCNTr_RESERVED0f_SET BCMI_TSC_XGXS_TX_X4_LOOPCNTr_RESERVED0f_SET
#define TX_X4_LOOPCNTr_LOOPCNT0f_GET BCMI_TSC_XGXS_TX_X4_LOOPCNTr_LOOPCNT0f_GET
#define TX_X4_LOOPCNTr_LOOPCNT0f_SET BCMI_TSC_XGXS_TX_X4_LOOPCNTr_LOOPCNT0f_SET
#define TX_X4_LOOPCNTr_LOOPCNT1f_GET BCMI_TSC_XGXS_TX_X4_LOOPCNTr_LOOPCNT1f_GET
#define TX_X4_LOOPCNTr_LOOPCNT1f_SET BCMI_TSC_XGXS_TX_X4_LOOPCNTr_LOOPCNT1f_SET
#define READ_TX_X4_LOOPCNTr BCMI_TSC_XGXS_READ_TX_X4_LOOPCNTr
#define WRITE_TX_X4_LOOPCNTr BCMI_TSC_XGXS_WRITE_TX_X4_LOOPCNTr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_TX_X4_LOOPCNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  TX_X4_MAC_CREDITGENCNT
 * BLOCKS:   TX_X4_CREDIT0
 * REGADDR:  0xc103
 * DESC:     credit gen count register: 00000000
 * SIZE:     32
 * FIELDS:
 *     MAC_CREDITGENCNT 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_TX_X4_MAC_CREDITGENCNTr (0x0000c103 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_TX_X4_MAC_CREDITGENCNTr_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_MAC_CREDITGENCNT.
 *
 */
typedef union BCMI_TSC_XGXS_TX_X4_MAC_CREDITGENCNTr_s {
	uint32_t v[1];
	uint32_t tx_x4_mac_creditgencnt[1];
	uint32_t _tx_x4_mac_creditgencnt;
} BCMI_TSC_XGXS_TX_X4_MAC_CREDITGENCNTr_t;

#define BCMI_TSC_XGXS_TX_X4_MAC_CREDITGENCNTr_CLR(r) (r).tx_x4_mac_creditgencnt[0] = 0
#define BCMI_TSC_XGXS_TX_X4_MAC_CREDITGENCNTr_SET(r,d) (r).tx_x4_mac_creditgencnt[0] = d
#define BCMI_TSC_XGXS_TX_X4_MAC_CREDITGENCNTr_GET(r) (r).tx_x4_mac_creditgencnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_TX_X4_MAC_CREDITGENCNTr_RESERVED0f_GET(r) ((((r).tx_x4_mac_creditgencnt[0]) >> 13) & 0x7)
#define BCMI_TSC_XGXS_TX_X4_MAC_CREDITGENCNTr_RESERVED0f_SET(r,f) (r).tx_x4_mac_creditgencnt[0]=(((r).tx_x4_mac_creditgencnt[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))
#define BCMI_TSC_XGXS_TX_X4_MAC_CREDITGENCNTr_MAC_CREDITGENCNTf_GET(r) (((r).tx_x4_mac_creditgencnt[0]) & 0x1fff)
#define BCMI_TSC_XGXS_TX_X4_MAC_CREDITGENCNTr_MAC_CREDITGENCNTf_SET(r,f) (r).tx_x4_mac_creditgencnt[0]=(((r).tx_x4_mac_creditgencnt[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))

/*
 * These macros can be used to access TX_X4_MAC_CREDITGENCNT.
 *
 */
#define BCMI_TSC_XGXS_READ_TX_X4_MAC_CREDITGENCNTr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_TX_X4_MAC_CREDITGENCNTr,(_r._tx_x4_mac_creditgencnt))
#define BCMI_TSC_XGXS_WRITE_TX_X4_MAC_CREDITGENCNTr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_TX_X4_MAC_CREDITGENCNTr,(_r._tx_x4_mac_creditgencnt))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_MAC_CREDITGENCNTr BCMI_TSC_XGXS_TX_X4_MAC_CREDITGENCNTr
#define TX_X4_MAC_CREDITGENCNTr_SIZE BCMI_TSC_XGXS_TX_X4_MAC_CREDITGENCNTr_SIZE
typedef BCMI_TSC_XGXS_TX_X4_MAC_CREDITGENCNTr_t TX_X4_MAC_CREDITGENCNTr_t;
#define TX_X4_MAC_CREDITGENCNTr_CLR BCMI_TSC_XGXS_TX_X4_MAC_CREDITGENCNTr_CLR
#define TX_X4_MAC_CREDITGENCNTr_SET BCMI_TSC_XGXS_TX_X4_MAC_CREDITGENCNTr_SET
#define TX_X4_MAC_CREDITGENCNTr_GET BCMI_TSC_XGXS_TX_X4_MAC_CREDITGENCNTr_GET
#define TX_X4_MAC_CREDITGENCNTr_RESERVED0f_GET BCMI_TSC_XGXS_TX_X4_MAC_CREDITGENCNTr_RESERVED0f_GET
#define TX_X4_MAC_CREDITGENCNTr_RESERVED0f_SET BCMI_TSC_XGXS_TX_X4_MAC_CREDITGENCNTr_RESERVED0f_SET
#define TX_X4_MAC_CREDITGENCNTr_MAC_CREDITGENCNTf_GET BCMI_TSC_XGXS_TX_X4_MAC_CREDITGENCNTr_MAC_CREDITGENCNTf_GET
#define TX_X4_MAC_CREDITGENCNTr_MAC_CREDITGENCNTf_SET BCMI_TSC_XGXS_TX_X4_MAC_CREDITGENCNTr_MAC_CREDITGENCNTf_SET
#define READ_TX_X4_MAC_CREDITGENCNTr BCMI_TSC_XGXS_READ_TX_X4_MAC_CREDITGENCNTr
#define WRITE_TX_X4_MAC_CREDITGENCNTr BCMI_TSC_XGXS_WRITE_TX_X4_MAC_CREDITGENCNTr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_TX_X4_MAC_CREDITGENCNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  TX_X4_PCS_CLOCKCNT0
 * BLOCKS:   TX_X4_CREDIT0
 * REGADDR:  0xc104
 * DESC:     pcs clock count 0 register: 00000000
 * SIZE:     32
 * FIELDS:
 *     PCS_CLOCKCNT0    
 *     PCS_CREDITENABLE 
 *     REPLICATION_CNT  
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_TX_X4_PCS_CLOCKCNT0r (0x0000c104 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_TX_X4_PCS_CLOCKCNT0r_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_PCS_CLOCKCNT0.
 *
 */
typedef union BCMI_TSC_XGXS_TX_X4_PCS_CLOCKCNT0r_s {
	uint32_t v[1];
	uint32_t tx_x4_pcs_clockcnt0[1];
	uint32_t _tx_x4_pcs_clockcnt0;
} BCMI_TSC_XGXS_TX_X4_PCS_CLOCKCNT0r_t;

#define BCMI_TSC_XGXS_TX_X4_PCS_CLOCKCNT0r_CLR(r) (r).tx_x4_pcs_clockcnt0[0] = 0
#define BCMI_TSC_XGXS_TX_X4_PCS_CLOCKCNT0r_SET(r,d) (r).tx_x4_pcs_clockcnt0[0] = d
#define BCMI_TSC_XGXS_TX_X4_PCS_CLOCKCNT0r_GET(r) (r).tx_x4_pcs_clockcnt0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_TX_X4_PCS_CLOCKCNT0r_REPLICATION_CNTf_GET(r) ((((r).tx_x4_pcs_clockcnt0[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_TX_X4_PCS_CLOCKCNT0r_REPLICATION_CNTf_SET(r,f) (r).tx_x4_pcs_clockcnt0[0]=(((r).tx_x4_pcs_clockcnt0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_TX_X4_PCS_CLOCKCNT0r_PCS_CREDITENABLEf_GET(r) ((((r).tx_x4_pcs_clockcnt0[0]) >> 14) & 0x1)
#define BCMI_TSC_XGXS_TX_X4_PCS_CLOCKCNT0r_PCS_CREDITENABLEf_SET(r,f) (r).tx_x4_pcs_clockcnt0[0]=(((r).tx_x4_pcs_clockcnt0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCMI_TSC_XGXS_TX_X4_PCS_CLOCKCNT0r_PCS_CLOCKCNT0f_GET(r) (((r).tx_x4_pcs_clockcnt0[0]) & 0x3fff)
#define BCMI_TSC_XGXS_TX_X4_PCS_CLOCKCNT0r_PCS_CLOCKCNT0f_SET(r,f) (r).tx_x4_pcs_clockcnt0[0]=(((r).tx_x4_pcs_clockcnt0[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access TX_X4_PCS_CLOCKCNT0.
 *
 */
#define BCMI_TSC_XGXS_READ_TX_X4_PCS_CLOCKCNT0r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_TX_X4_PCS_CLOCKCNT0r,(_r._tx_x4_pcs_clockcnt0))
#define BCMI_TSC_XGXS_WRITE_TX_X4_PCS_CLOCKCNT0r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_TX_X4_PCS_CLOCKCNT0r,(_r._tx_x4_pcs_clockcnt0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_PCS_CLOCKCNT0r BCMI_TSC_XGXS_TX_X4_PCS_CLOCKCNT0r
#define TX_X4_PCS_CLOCKCNT0r_SIZE BCMI_TSC_XGXS_TX_X4_PCS_CLOCKCNT0r_SIZE
typedef BCMI_TSC_XGXS_TX_X4_PCS_CLOCKCNT0r_t TX_X4_PCS_CLOCKCNT0r_t;
#define TX_X4_PCS_CLOCKCNT0r_CLR BCMI_TSC_XGXS_TX_X4_PCS_CLOCKCNT0r_CLR
#define TX_X4_PCS_CLOCKCNT0r_SET BCMI_TSC_XGXS_TX_X4_PCS_CLOCKCNT0r_SET
#define TX_X4_PCS_CLOCKCNT0r_GET BCMI_TSC_XGXS_TX_X4_PCS_CLOCKCNT0r_GET
#define TX_X4_PCS_CLOCKCNT0r_REPLICATION_CNTf_GET BCMI_TSC_XGXS_TX_X4_PCS_CLOCKCNT0r_REPLICATION_CNTf_GET
#define TX_X4_PCS_CLOCKCNT0r_REPLICATION_CNTf_SET BCMI_TSC_XGXS_TX_X4_PCS_CLOCKCNT0r_REPLICATION_CNTf_SET
#define TX_X4_PCS_CLOCKCNT0r_PCS_CREDITENABLEf_GET BCMI_TSC_XGXS_TX_X4_PCS_CLOCKCNT0r_PCS_CREDITENABLEf_GET
#define TX_X4_PCS_CLOCKCNT0r_PCS_CREDITENABLEf_SET BCMI_TSC_XGXS_TX_X4_PCS_CLOCKCNT0r_PCS_CREDITENABLEf_SET
#define TX_X4_PCS_CLOCKCNT0r_PCS_CLOCKCNT0f_GET BCMI_TSC_XGXS_TX_X4_PCS_CLOCKCNT0r_PCS_CLOCKCNT0f_GET
#define TX_X4_PCS_CLOCKCNT0r_PCS_CLOCKCNT0f_SET BCMI_TSC_XGXS_TX_X4_PCS_CLOCKCNT0r_PCS_CLOCKCNT0f_SET
#define READ_TX_X4_PCS_CLOCKCNT0r BCMI_TSC_XGXS_READ_TX_X4_PCS_CLOCKCNT0r
#define WRITE_TX_X4_PCS_CLOCKCNT0r BCMI_TSC_XGXS_WRITE_TX_X4_PCS_CLOCKCNT0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_TX_X4_PCS_CLOCKCNT0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  TX_X4_PCS_CREDITGENCNT
 * BLOCKS:   TX_X4_CREDIT0
 * REGADDR:  0xc105
 * DESC:     pcs credit gen count register: 00000000
 * SIZE:     32
 * FIELDS:
 *     PCS_CREDITGENCNT 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_TX_X4_PCS_CREDITGENCNTr (0x0000c105 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_TX_X4_PCS_CREDITGENCNTr_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_PCS_CREDITGENCNT.
 *
 */
typedef union BCMI_TSC_XGXS_TX_X4_PCS_CREDITGENCNTr_s {
	uint32_t v[1];
	uint32_t tx_x4_pcs_creditgencnt[1];
	uint32_t _tx_x4_pcs_creditgencnt;
} BCMI_TSC_XGXS_TX_X4_PCS_CREDITGENCNTr_t;

#define BCMI_TSC_XGXS_TX_X4_PCS_CREDITGENCNTr_CLR(r) (r).tx_x4_pcs_creditgencnt[0] = 0
#define BCMI_TSC_XGXS_TX_X4_PCS_CREDITGENCNTr_SET(r,d) (r).tx_x4_pcs_creditgencnt[0] = d
#define BCMI_TSC_XGXS_TX_X4_PCS_CREDITGENCNTr_GET(r) (r).tx_x4_pcs_creditgencnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_TX_X4_PCS_CREDITGENCNTr_RESERVED0f_GET(r) ((((r).tx_x4_pcs_creditgencnt[0]) >> 13) & 0x7)
#define BCMI_TSC_XGXS_TX_X4_PCS_CREDITGENCNTr_RESERVED0f_SET(r,f) (r).tx_x4_pcs_creditgencnt[0]=(((r).tx_x4_pcs_creditgencnt[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))
#define BCMI_TSC_XGXS_TX_X4_PCS_CREDITGENCNTr_PCS_CREDITGENCNTf_GET(r) (((r).tx_x4_pcs_creditgencnt[0]) & 0x1fff)
#define BCMI_TSC_XGXS_TX_X4_PCS_CREDITGENCNTr_PCS_CREDITGENCNTf_SET(r,f) (r).tx_x4_pcs_creditgencnt[0]=(((r).tx_x4_pcs_creditgencnt[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))

/*
 * These macros can be used to access TX_X4_PCS_CREDITGENCNT.
 *
 */
#define BCMI_TSC_XGXS_READ_TX_X4_PCS_CREDITGENCNTr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_TX_X4_PCS_CREDITGENCNTr,(_r._tx_x4_pcs_creditgencnt))
#define BCMI_TSC_XGXS_WRITE_TX_X4_PCS_CREDITGENCNTr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_TX_X4_PCS_CREDITGENCNTr,(_r._tx_x4_pcs_creditgencnt))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_PCS_CREDITGENCNTr BCMI_TSC_XGXS_TX_X4_PCS_CREDITGENCNTr
#define TX_X4_PCS_CREDITGENCNTr_SIZE BCMI_TSC_XGXS_TX_X4_PCS_CREDITGENCNTr_SIZE
typedef BCMI_TSC_XGXS_TX_X4_PCS_CREDITGENCNTr_t TX_X4_PCS_CREDITGENCNTr_t;
#define TX_X4_PCS_CREDITGENCNTr_CLR BCMI_TSC_XGXS_TX_X4_PCS_CREDITGENCNTr_CLR
#define TX_X4_PCS_CREDITGENCNTr_SET BCMI_TSC_XGXS_TX_X4_PCS_CREDITGENCNTr_SET
#define TX_X4_PCS_CREDITGENCNTr_GET BCMI_TSC_XGXS_TX_X4_PCS_CREDITGENCNTr_GET
#define TX_X4_PCS_CREDITGENCNTr_RESERVED0f_GET BCMI_TSC_XGXS_TX_X4_PCS_CREDITGENCNTr_RESERVED0f_GET
#define TX_X4_PCS_CREDITGENCNTr_RESERVED0f_SET BCMI_TSC_XGXS_TX_X4_PCS_CREDITGENCNTr_RESERVED0f_SET
#define TX_X4_PCS_CREDITGENCNTr_PCS_CREDITGENCNTf_GET BCMI_TSC_XGXS_TX_X4_PCS_CREDITGENCNTr_PCS_CREDITGENCNTf_GET
#define TX_X4_PCS_CREDITGENCNTr_PCS_CREDITGENCNTf_SET BCMI_TSC_XGXS_TX_X4_PCS_CREDITGENCNTr_PCS_CREDITGENCNTf_SET
#define READ_TX_X4_PCS_CREDITGENCNTr BCMI_TSC_XGXS_READ_TX_X4_PCS_CREDITGENCNTr
#define WRITE_TX_X4_PCS_CREDITGENCNTr BCMI_TSC_XGXS_WRITE_TX_X4_PCS_CREDITGENCNTr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_TX_X4_PCS_CREDITGENCNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  TX_X4_KR_DEFAULT_CONTROL
 * BLOCKS:   TX_X4_CONTROL0
 * REGADDR:  0xc110
 * DESC:     CL72 KR Default Control Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     TX_FIR_TAP_PRE_KR_INIT_VAL 
 *     TX_FIR_TAP_MAIN_KR_INIT_VAL 
 *     TX_FIR_TAP_POST_KR_INIT_VAL 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_TX_X4_KR_DEFAULT_CONTROLr (0x0000c110 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_TX_X4_KR_DEFAULT_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_KR_DEFAULT_CONTROL.
 *
 */
typedef union BCMI_TSC_XGXS_TX_X4_KR_DEFAULT_CONTROLr_s {
	uint32_t v[1];
	uint32_t tx_x4_kr_default_control[1];
	uint32_t _tx_x4_kr_default_control;
} BCMI_TSC_XGXS_TX_X4_KR_DEFAULT_CONTROLr_t;

#define BCMI_TSC_XGXS_TX_X4_KR_DEFAULT_CONTROLr_CLR(r) (r).tx_x4_kr_default_control[0] = 0
#define BCMI_TSC_XGXS_TX_X4_KR_DEFAULT_CONTROLr_SET(r,d) (r).tx_x4_kr_default_control[0] = d
#define BCMI_TSC_XGXS_TX_X4_KR_DEFAULT_CONTROLr_GET(r) (r).tx_x4_kr_default_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_TX_X4_KR_DEFAULT_CONTROLr_RESERVED0f_GET(r) ((((r).tx_x4_kr_default_control[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_TX_X4_KR_DEFAULT_CONTROLr_RESERVED0f_SET(r,f) (r).tx_x4_kr_default_control[0]=(((r).tx_x4_kr_default_control[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_TX_X4_KR_DEFAULT_CONTROLr_TX_FIR_TAP_POST_KR_INIT_VALf_GET(r) ((((r).tx_x4_kr_default_control[0]) >> 10) & 0x1f)
#define BCMI_TSC_XGXS_TX_X4_KR_DEFAULT_CONTROLr_TX_FIR_TAP_POST_KR_INIT_VALf_SET(r,f) (r).tx_x4_kr_default_control[0]=(((r).tx_x4_kr_default_control[0] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10))
#define BCMI_TSC_XGXS_TX_X4_KR_DEFAULT_CONTROLr_TX_FIR_TAP_MAIN_KR_INIT_VALf_GET(r) ((((r).tx_x4_kr_default_control[0]) >> 4) & 0x3f)
#define BCMI_TSC_XGXS_TX_X4_KR_DEFAULT_CONTROLr_TX_FIR_TAP_MAIN_KR_INIT_VALf_SET(r,f) (r).tx_x4_kr_default_control[0]=(((r).tx_x4_kr_default_control[0] & ~((uint32_t)0x3f << 4)) | ((((uint32_t)f) & 0x3f) << 4))
#define BCMI_TSC_XGXS_TX_X4_KR_DEFAULT_CONTROLr_TX_FIR_TAP_PRE_KR_INIT_VALf_GET(r) (((r).tx_x4_kr_default_control[0]) & 0xf)
#define BCMI_TSC_XGXS_TX_X4_KR_DEFAULT_CONTROLr_TX_FIR_TAP_PRE_KR_INIT_VALf_SET(r,f) (r).tx_x4_kr_default_control[0]=(((r).tx_x4_kr_default_control[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access TX_X4_KR_DEFAULT_CONTROL.
 *
 */
#define BCMI_TSC_XGXS_READ_TX_X4_KR_DEFAULT_CONTROLr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_TX_X4_KR_DEFAULT_CONTROLr,(_r._tx_x4_kr_default_control))
#define BCMI_TSC_XGXS_WRITE_TX_X4_KR_DEFAULT_CONTROLr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_TX_X4_KR_DEFAULT_CONTROLr,(_r._tx_x4_kr_default_control))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_KR_DEFAULT_CONTROLr BCMI_TSC_XGXS_TX_X4_KR_DEFAULT_CONTROLr
#define TX_X4_KR_DEFAULT_CONTROLr_SIZE BCMI_TSC_XGXS_TX_X4_KR_DEFAULT_CONTROLr_SIZE
typedef BCMI_TSC_XGXS_TX_X4_KR_DEFAULT_CONTROLr_t TX_X4_KR_DEFAULT_CONTROLr_t;
#define TX_X4_KR_DEFAULT_CONTROLr_CLR BCMI_TSC_XGXS_TX_X4_KR_DEFAULT_CONTROLr_CLR
#define TX_X4_KR_DEFAULT_CONTROLr_SET BCMI_TSC_XGXS_TX_X4_KR_DEFAULT_CONTROLr_SET
#define TX_X4_KR_DEFAULT_CONTROLr_GET BCMI_TSC_XGXS_TX_X4_KR_DEFAULT_CONTROLr_GET
#define TX_X4_KR_DEFAULT_CONTROLr_RESERVED0f_GET BCMI_TSC_XGXS_TX_X4_KR_DEFAULT_CONTROLr_RESERVED0f_GET
#define TX_X4_KR_DEFAULT_CONTROLr_RESERVED0f_SET BCMI_TSC_XGXS_TX_X4_KR_DEFAULT_CONTROLr_RESERVED0f_SET
#define TX_X4_KR_DEFAULT_CONTROLr_TX_FIR_TAP_POST_KR_INIT_VALf_GET BCMI_TSC_XGXS_TX_X4_KR_DEFAULT_CONTROLr_TX_FIR_TAP_POST_KR_INIT_VALf_GET
#define TX_X4_KR_DEFAULT_CONTROLr_TX_FIR_TAP_POST_KR_INIT_VALf_SET BCMI_TSC_XGXS_TX_X4_KR_DEFAULT_CONTROLr_TX_FIR_TAP_POST_KR_INIT_VALf_SET
#define TX_X4_KR_DEFAULT_CONTROLr_TX_FIR_TAP_MAIN_KR_INIT_VALf_GET BCMI_TSC_XGXS_TX_X4_KR_DEFAULT_CONTROLr_TX_FIR_TAP_MAIN_KR_INIT_VALf_GET
#define TX_X4_KR_DEFAULT_CONTROLr_TX_FIR_TAP_MAIN_KR_INIT_VALf_SET BCMI_TSC_XGXS_TX_X4_KR_DEFAULT_CONTROLr_TX_FIR_TAP_MAIN_KR_INIT_VALf_SET
#define TX_X4_KR_DEFAULT_CONTROLr_TX_FIR_TAP_PRE_KR_INIT_VALf_GET BCMI_TSC_XGXS_TX_X4_KR_DEFAULT_CONTROLr_TX_FIR_TAP_PRE_KR_INIT_VALf_GET
#define TX_X4_KR_DEFAULT_CONTROLr_TX_FIR_TAP_PRE_KR_INIT_VALf_SET BCMI_TSC_XGXS_TX_X4_KR_DEFAULT_CONTROLr_TX_FIR_TAP_PRE_KR_INIT_VALf_SET
#define READ_TX_X4_KR_DEFAULT_CONTROLr BCMI_TSC_XGXS_READ_TX_X4_KR_DEFAULT_CONTROLr
#define WRITE_TX_X4_KR_DEFAULT_CONTROLr BCMI_TSC_XGXS_WRITE_TX_X4_KR_DEFAULT_CONTROLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_TX_X4_KR_DEFAULT_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  TX_X4_ENCODE_0
 * BLOCKS:   TX_X4_CONTROL0
 * REGADDR:  0xc111
 * DESC:     Encode 0 register: 00000000
 * SIZE:     32
 * FIELDS:
 *     RESERVED2        
 *     ENCODEMODE       
 *     CL49_TX_TL_MODE  
 *     RESERVED1        
 *     CL49_BYPASS_TXSM 
 *     HG2_ENABLE       
 *     HG2_MESSAGE_INVALID_CODE_ENABLE 
 *     HG2_CODEC        
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_TX_X4_ENCODE_0r (0x0000c111 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_TX_X4_ENCODE_0r_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_ENCODE_0.
 *
 */
typedef union BCMI_TSC_XGXS_TX_X4_ENCODE_0r_s {
	uint32_t v[1];
	uint32_t tx_x4_encode_0[1];
	uint32_t _tx_x4_encode_0;
} BCMI_TSC_XGXS_TX_X4_ENCODE_0r_t;

#define BCMI_TSC_XGXS_TX_X4_ENCODE_0r_CLR(r) (r).tx_x4_encode_0[0] = 0
#define BCMI_TSC_XGXS_TX_X4_ENCODE_0r_SET(r,d) (r).tx_x4_encode_0[0] = d
#define BCMI_TSC_XGXS_TX_X4_ENCODE_0r_GET(r) (r).tx_x4_encode_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_TX_X4_ENCODE_0r_RESERVED0f_GET(r) ((((r).tx_x4_encode_0[0]) >> 13) & 0x7)
#define BCMI_TSC_XGXS_TX_X4_ENCODE_0r_RESERVED0f_SET(r,f) (r).tx_x4_encode_0[0]=(((r).tx_x4_encode_0[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))
#define BCMI_TSC_XGXS_TX_X4_ENCODE_0r_HG2_CODECf_GET(r) ((((r).tx_x4_encode_0[0]) >> 12) & 0x1)
#define BCMI_TSC_XGXS_TX_X4_ENCODE_0r_HG2_CODECf_SET(r,f) (r).tx_x4_encode_0[0]=(((r).tx_x4_encode_0[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCMI_TSC_XGXS_TX_X4_ENCODE_0r_HG2_MESSAGE_INVALID_CODE_ENABLEf_GET(r) ((((r).tx_x4_encode_0[0]) >> 11) & 0x1)
#define BCMI_TSC_XGXS_TX_X4_ENCODE_0r_HG2_MESSAGE_INVALID_CODE_ENABLEf_SET(r,f) (r).tx_x4_encode_0[0]=(((r).tx_x4_encode_0[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCMI_TSC_XGXS_TX_X4_ENCODE_0r_HG2_ENABLEf_GET(r) ((((r).tx_x4_encode_0[0]) >> 10) & 0x1)
#define BCMI_TSC_XGXS_TX_X4_ENCODE_0r_HG2_ENABLEf_SET(r,f) (r).tx_x4_encode_0[0]=(((r).tx_x4_encode_0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCMI_TSC_XGXS_TX_X4_ENCODE_0r_CL49_BYPASS_TXSMf_GET(r) ((((r).tx_x4_encode_0[0]) >> 9) & 0x1)
#define BCMI_TSC_XGXS_TX_X4_ENCODE_0r_CL49_BYPASS_TXSMf_SET(r,f) (r).tx_x4_encode_0[0]=(((r).tx_x4_encode_0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCMI_TSC_XGXS_TX_X4_ENCODE_0r_RESERVED1f_GET(r) ((((r).tx_x4_encode_0[0]) >> 7) & 0x3)
#define BCMI_TSC_XGXS_TX_X4_ENCODE_0r_RESERVED1f_SET(r,f) (r).tx_x4_encode_0[0]=(((r).tx_x4_encode_0[0] & ~((uint32_t)0x3 << 7)) | ((((uint32_t)f) & 0x3) << 7))
#define BCMI_TSC_XGXS_TX_X4_ENCODE_0r_CL49_TX_TL_MODEf_GET(r) ((((r).tx_x4_encode_0[0]) >> 5) & 0x3)
#define BCMI_TSC_XGXS_TX_X4_ENCODE_0r_CL49_TX_TL_MODEf_SET(r,f) (r).tx_x4_encode_0[0]=(((r).tx_x4_encode_0[0] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5))
#define BCMI_TSC_XGXS_TX_X4_ENCODE_0r_ENCODEMODEf_GET(r) ((((r).tx_x4_encode_0[0]) >> 2) & 0x7)
#define BCMI_TSC_XGXS_TX_X4_ENCODE_0r_ENCODEMODEf_SET(r,f) (r).tx_x4_encode_0[0]=(((r).tx_x4_encode_0[0] & ~((uint32_t)0x7 << 2)) | ((((uint32_t)f) & 0x7) << 2))
#define BCMI_TSC_XGXS_TX_X4_ENCODE_0r_RESERVED2f_GET(r) (((r).tx_x4_encode_0[0]) & 0x3)
#define BCMI_TSC_XGXS_TX_X4_ENCODE_0r_RESERVED2f_SET(r,f) (r).tx_x4_encode_0[0]=(((r).tx_x4_encode_0[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))

/*
 * These macros can be used to access TX_X4_ENCODE_0.
 *
 */
#define BCMI_TSC_XGXS_READ_TX_X4_ENCODE_0r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_TX_X4_ENCODE_0r,(_r._tx_x4_encode_0))
#define BCMI_TSC_XGXS_WRITE_TX_X4_ENCODE_0r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_TX_X4_ENCODE_0r,(_r._tx_x4_encode_0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_ENCODE_0r BCMI_TSC_XGXS_TX_X4_ENCODE_0r
#define TX_X4_ENCODE_0r_SIZE BCMI_TSC_XGXS_TX_X4_ENCODE_0r_SIZE
typedef BCMI_TSC_XGXS_TX_X4_ENCODE_0r_t TX_X4_ENCODE_0r_t;
#define TX_X4_ENCODE_0r_CLR BCMI_TSC_XGXS_TX_X4_ENCODE_0r_CLR
#define TX_X4_ENCODE_0r_SET BCMI_TSC_XGXS_TX_X4_ENCODE_0r_SET
#define TX_X4_ENCODE_0r_GET BCMI_TSC_XGXS_TX_X4_ENCODE_0r_GET
#define TX_X4_ENCODE_0r_RESERVED0f_GET BCMI_TSC_XGXS_TX_X4_ENCODE_0r_RESERVED0f_GET
#define TX_X4_ENCODE_0r_RESERVED0f_SET BCMI_TSC_XGXS_TX_X4_ENCODE_0r_RESERVED0f_SET
#define TX_X4_ENCODE_0r_HG2_CODECf_GET BCMI_TSC_XGXS_TX_X4_ENCODE_0r_HG2_CODECf_GET
#define TX_X4_ENCODE_0r_HG2_CODECf_SET BCMI_TSC_XGXS_TX_X4_ENCODE_0r_HG2_CODECf_SET
#define TX_X4_ENCODE_0r_HG2_MESSAGE_INVALID_CODE_ENABLEf_GET BCMI_TSC_XGXS_TX_X4_ENCODE_0r_HG2_MESSAGE_INVALID_CODE_ENABLEf_GET
#define TX_X4_ENCODE_0r_HG2_MESSAGE_INVALID_CODE_ENABLEf_SET BCMI_TSC_XGXS_TX_X4_ENCODE_0r_HG2_MESSAGE_INVALID_CODE_ENABLEf_SET
#define TX_X4_ENCODE_0r_HG2_ENABLEf_GET BCMI_TSC_XGXS_TX_X4_ENCODE_0r_HG2_ENABLEf_GET
#define TX_X4_ENCODE_0r_HG2_ENABLEf_SET BCMI_TSC_XGXS_TX_X4_ENCODE_0r_HG2_ENABLEf_SET
#define TX_X4_ENCODE_0r_CL49_BYPASS_TXSMf_GET BCMI_TSC_XGXS_TX_X4_ENCODE_0r_CL49_BYPASS_TXSMf_GET
#define TX_X4_ENCODE_0r_CL49_BYPASS_TXSMf_SET BCMI_TSC_XGXS_TX_X4_ENCODE_0r_CL49_BYPASS_TXSMf_SET
#define TX_X4_ENCODE_0r_RESERVED1f_GET BCMI_TSC_XGXS_TX_X4_ENCODE_0r_RESERVED1f_GET
#define TX_X4_ENCODE_0r_RESERVED1f_SET BCMI_TSC_XGXS_TX_X4_ENCODE_0r_RESERVED1f_SET
#define TX_X4_ENCODE_0r_CL49_TX_TL_MODEf_GET BCMI_TSC_XGXS_TX_X4_ENCODE_0r_CL49_TX_TL_MODEf_GET
#define TX_X4_ENCODE_0r_CL49_TX_TL_MODEf_SET BCMI_TSC_XGXS_TX_X4_ENCODE_0r_CL49_TX_TL_MODEf_SET
#define TX_X4_ENCODE_0r_ENCODEMODEf_GET BCMI_TSC_XGXS_TX_X4_ENCODE_0r_ENCODEMODEf_GET
#define TX_X4_ENCODE_0r_ENCODEMODEf_SET BCMI_TSC_XGXS_TX_X4_ENCODE_0r_ENCODEMODEf_SET
#define TX_X4_ENCODE_0r_RESERVED2f_GET BCMI_TSC_XGXS_TX_X4_ENCODE_0r_RESERVED2f_GET
#define TX_X4_ENCODE_0r_RESERVED2f_SET BCMI_TSC_XGXS_TX_X4_ENCODE_0r_RESERVED2f_SET
#define READ_TX_X4_ENCODE_0r BCMI_TSC_XGXS_READ_TX_X4_ENCODE_0r
#define WRITE_TX_X4_ENCODE_0r BCMI_TSC_XGXS_WRITE_TX_X4_ENCODE_0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_TX_X4_ENCODE_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  TX_X4_ENCODE_1
 * BLOCKS:   TX_X4_CONTROL0
 * REGADDR:  0xc112
 * DESC:     Encode 1 register 64/66 Encoder Programmable Table Lookup Control Character: 00000000
 * SIZE:     32
 * FIELDS:
 *     PROG_TL_CHAR     
 *     PROG_TL_EN       
 *     CATCH_ALL_8B10B_DIS 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_TX_X4_ENCODE_1r (0x0000c112 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_TX_X4_ENCODE_1r_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_ENCODE_1.
 *
 */
typedef union BCMI_TSC_XGXS_TX_X4_ENCODE_1r_s {
	uint32_t v[1];
	uint32_t tx_x4_encode_1[1];
	uint32_t _tx_x4_encode_1;
} BCMI_TSC_XGXS_TX_X4_ENCODE_1r_t;

#define BCMI_TSC_XGXS_TX_X4_ENCODE_1r_CLR(r) (r).tx_x4_encode_1[0] = 0
#define BCMI_TSC_XGXS_TX_X4_ENCODE_1r_SET(r,d) (r).tx_x4_encode_1[0] = d
#define BCMI_TSC_XGXS_TX_X4_ENCODE_1r_GET(r) (r).tx_x4_encode_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_TX_X4_ENCODE_1r_RESERVED0f_GET(r) ((((r).tx_x4_encode_1[0]) >> 10) & 0x3f)
#define BCMI_TSC_XGXS_TX_X4_ENCODE_1r_RESERVED0f_SET(r,f) (r).tx_x4_encode_1[0]=(((r).tx_x4_encode_1[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))
#define BCMI_TSC_XGXS_TX_X4_ENCODE_1r_CATCH_ALL_8B10B_DISf_GET(r) ((((r).tx_x4_encode_1[0]) >> 9) & 0x1)
#define BCMI_TSC_XGXS_TX_X4_ENCODE_1r_CATCH_ALL_8B10B_DISf_SET(r,f) (r).tx_x4_encode_1[0]=(((r).tx_x4_encode_1[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCMI_TSC_XGXS_TX_X4_ENCODE_1r_PROG_TL_ENf_GET(r) ((((r).tx_x4_encode_1[0]) >> 8) & 0x1)
#define BCMI_TSC_XGXS_TX_X4_ENCODE_1r_PROG_TL_ENf_SET(r,f) (r).tx_x4_encode_1[0]=(((r).tx_x4_encode_1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCMI_TSC_XGXS_TX_X4_ENCODE_1r_PROG_TL_CHARf_GET(r) (((r).tx_x4_encode_1[0]) & 0xff)
#define BCMI_TSC_XGXS_TX_X4_ENCODE_1r_PROG_TL_CHARf_SET(r,f) (r).tx_x4_encode_1[0]=(((r).tx_x4_encode_1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access TX_X4_ENCODE_1.
 *
 */
#define BCMI_TSC_XGXS_READ_TX_X4_ENCODE_1r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_TX_X4_ENCODE_1r,(_r._tx_x4_encode_1))
#define BCMI_TSC_XGXS_WRITE_TX_X4_ENCODE_1r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_TX_X4_ENCODE_1r,(_r._tx_x4_encode_1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_ENCODE_1r BCMI_TSC_XGXS_TX_X4_ENCODE_1r
#define TX_X4_ENCODE_1r_SIZE BCMI_TSC_XGXS_TX_X4_ENCODE_1r_SIZE
typedef BCMI_TSC_XGXS_TX_X4_ENCODE_1r_t TX_X4_ENCODE_1r_t;
#define TX_X4_ENCODE_1r_CLR BCMI_TSC_XGXS_TX_X4_ENCODE_1r_CLR
#define TX_X4_ENCODE_1r_SET BCMI_TSC_XGXS_TX_X4_ENCODE_1r_SET
#define TX_X4_ENCODE_1r_GET BCMI_TSC_XGXS_TX_X4_ENCODE_1r_GET
#define TX_X4_ENCODE_1r_RESERVED0f_GET BCMI_TSC_XGXS_TX_X4_ENCODE_1r_RESERVED0f_GET
#define TX_X4_ENCODE_1r_RESERVED0f_SET BCMI_TSC_XGXS_TX_X4_ENCODE_1r_RESERVED0f_SET
#define TX_X4_ENCODE_1r_CATCH_ALL_8B10B_DISf_GET BCMI_TSC_XGXS_TX_X4_ENCODE_1r_CATCH_ALL_8B10B_DISf_GET
#define TX_X4_ENCODE_1r_CATCH_ALL_8B10B_DISf_SET BCMI_TSC_XGXS_TX_X4_ENCODE_1r_CATCH_ALL_8B10B_DISf_SET
#define TX_X4_ENCODE_1r_PROG_TL_ENf_GET BCMI_TSC_XGXS_TX_X4_ENCODE_1r_PROG_TL_ENf_GET
#define TX_X4_ENCODE_1r_PROG_TL_ENf_SET BCMI_TSC_XGXS_TX_X4_ENCODE_1r_PROG_TL_ENf_SET
#define TX_X4_ENCODE_1r_PROG_TL_CHARf_GET BCMI_TSC_XGXS_TX_X4_ENCODE_1r_PROG_TL_CHARf_GET
#define TX_X4_ENCODE_1r_PROG_TL_CHARf_SET BCMI_TSC_XGXS_TX_X4_ENCODE_1r_PROG_TL_CHARf_SET
#define READ_TX_X4_ENCODE_1r BCMI_TSC_XGXS_READ_TX_X4_ENCODE_1r
#define WRITE_TX_X4_ENCODE_1r BCMI_TSC_XGXS_WRITE_TX_X4_ENCODE_1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_TX_X4_ENCODE_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  TX_X4_MISC
 * BLOCKS:   TX_X4_CONTROL0
 * REGADDR:  0xc113
 * DESC:     Misc register: 00000000
 * SIZE:     32
 * FIELDS:
 *     ENABLE_TX_LANE   
 *     RSTB_TX_LANE     
 *     TX_FIFO_WATERMARK 
 *     RESERVED2        
 *     CL49_TX_RF_ENABLE 
 *     CL49_TX_LF_ENABLE 
 *     CL49_TX_LI_ENABLE 
 *     RESERVED1        
 *     FEC_ENABLE       
 *     RESERVED0        
 *     SCR_MODE         
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_TX_X4_MISCr (0x0000c113 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_TX_X4_MISCr_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_MISC.
 *
 */
typedef union BCMI_TSC_XGXS_TX_X4_MISCr_s {
	uint32_t v[1];
	uint32_t tx_x4_misc[1];
	uint32_t _tx_x4_misc;
} BCMI_TSC_XGXS_TX_X4_MISCr_t;

#define BCMI_TSC_XGXS_TX_X4_MISCr_CLR(r) (r).tx_x4_misc[0] = 0
#define BCMI_TSC_XGXS_TX_X4_MISCr_SET(r,d) (r).tx_x4_misc[0] = d
#define BCMI_TSC_XGXS_TX_X4_MISCr_GET(r) (r).tx_x4_misc[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_TX_X4_MISCr_SCR_MODEf_GET(r) ((((r).tx_x4_misc[0]) >> 14) & 0x3)
#define BCMI_TSC_XGXS_TX_X4_MISCr_SCR_MODEf_SET(r,f) (r).tx_x4_misc[0]=(((r).tx_x4_misc[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCMI_TSC_XGXS_TX_X4_MISCr_RESERVED0f_GET(r) ((((r).tx_x4_misc[0]) >> 11) & 0x7)
#define BCMI_TSC_XGXS_TX_X4_MISCr_RESERVED0f_SET(r,f) (r).tx_x4_misc[0]=(((r).tx_x4_misc[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11))
#define BCMI_TSC_XGXS_TX_X4_MISCr_FEC_ENABLEf_GET(r) ((((r).tx_x4_misc[0]) >> 10) & 0x1)
#define BCMI_TSC_XGXS_TX_X4_MISCr_FEC_ENABLEf_SET(r,f) (r).tx_x4_misc[0]=(((r).tx_x4_misc[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCMI_TSC_XGXS_TX_X4_MISCr_RESERVED1f_GET(r) ((((r).tx_x4_misc[0]) >> 9) & 0x1)
#define BCMI_TSC_XGXS_TX_X4_MISCr_RESERVED1f_SET(r,f) (r).tx_x4_misc[0]=(((r).tx_x4_misc[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCMI_TSC_XGXS_TX_X4_MISCr_CL49_TX_LI_ENABLEf_GET(r) ((((r).tx_x4_misc[0]) >> 8) & 0x1)
#define BCMI_TSC_XGXS_TX_X4_MISCr_CL49_TX_LI_ENABLEf_SET(r,f) (r).tx_x4_misc[0]=(((r).tx_x4_misc[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCMI_TSC_XGXS_TX_X4_MISCr_CL49_TX_LF_ENABLEf_GET(r) ((((r).tx_x4_misc[0]) >> 7) & 0x1)
#define BCMI_TSC_XGXS_TX_X4_MISCr_CL49_TX_LF_ENABLEf_SET(r,f) (r).tx_x4_misc[0]=(((r).tx_x4_misc[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCMI_TSC_XGXS_TX_X4_MISCr_CL49_TX_RF_ENABLEf_GET(r) ((((r).tx_x4_misc[0]) >> 6) & 0x1)
#define BCMI_TSC_XGXS_TX_X4_MISCr_CL49_TX_RF_ENABLEf_SET(r,f) (r).tx_x4_misc[0]=(((r).tx_x4_misc[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCMI_TSC_XGXS_TX_X4_MISCr_RESERVED2f_GET(r) ((((r).tx_x4_misc[0]) >> 4) & 0x3)
#define BCMI_TSC_XGXS_TX_X4_MISCr_RESERVED2f_SET(r,f) (r).tx_x4_misc[0]=(((r).tx_x4_misc[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCMI_TSC_XGXS_TX_X4_MISCr_TX_FIFO_WATERMARKf_GET(r) ((((r).tx_x4_misc[0]) >> 2) & 0x3)
#define BCMI_TSC_XGXS_TX_X4_MISCr_TX_FIFO_WATERMARKf_SET(r,f) (r).tx_x4_misc[0]=(((r).tx_x4_misc[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCMI_TSC_XGXS_TX_X4_MISCr_RSTB_TX_LANEf_GET(r) ((((r).tx_x4_misc[0]) >> 1) & 0x1)
#define BCMI_TSC_XGXS_TX_X4_MISCr_RSTB_TX_LANEf_SET(r,f) (r).tx_x4_misc[0]=(((r).tx_x4_misc[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCMI_TSC_XGXS_TX_X4_MISCr_ENABLE_TX_LANEf_GET(r) (((r).tx_x4_misc[0]) & 0x1)
#define BCMI_TSC_XGXS_TX_X4_MISCr_ENABLE_TX_LANEf_SET(r,f) (r).tx_x4_misc[0]=(((r).tx_x4_misc[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access TX_X4_MISC.
 *
 */
#define BCMI_TSC_XGXS_READ_TX_X4_MISCr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_TX_X4_MISCr,(_r._tx_x4_misc))
#define BCMI_TSC_XGXS_WRITE_TX_X4_MISCr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_TX_X4_MISCr,(_r._tx_x4_misc))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_MISCr BCMI_TSC_XGXS_TX_X4_MISCr
#define TX_X4_MISCr_SIZE BCMI_TSC_XGXS_TX_X4_MISCr_SIZE
typedef BCMI_TSC_XGXS_TX_X4_MISCr_t TX_X4_MISCr_t;
#define TX_X4_MISCr_CLR BCMI_TSC_XGXS_TX_X4_MISCr_CLR
#define TX_X4_MISCr_SET BCMI_TSC_XGXS_TX_X4_MISCr_SET
#define TX_X4_MISCr_GET BCMI_TSC_XGXS_TX_X4_MISCr_GET
#define TX_X4_MISCr_SCR_MODEf_GET BCMI_TSC_XGXS_TX_X4_MISCr_SCR_MODEf_GET
#define TX_X4_MISCr_SCR_MODEf_SET BCMI_TSC_XGXS_TX_X4_MISCr_SCR_MODEf_SET
#define TX_X4_MISCr_RESERVED0f_GET BCMI_TSC_XGXS_TX_X4_MISCr_RESERVED0f_GET
#define TX_X4_MISCr_RESERVED0f_SET BCMI_TSC_XGXS_TX_X4_MISCr_RESERVED0f_SET
#define TX_X4_MISCr_FEC_ENABLEf_GET BCMI_TSC_XGXS_TX_X4_MISCr_FEC_ENABLEf_GET
#define TX_X4_MISCr_FEC_ENABLEf_SET BCMI_TSC_XGXS_TX_X4_MISCr_FEC_ENABLEf_SET
#define TX_X4_MISCr_RESERVED1f_GET BCMI_TSC_XGXS_TX_X4_MISCr_RESERVED1f_GET
#define TX_X4_MISCr_RESERVED1f_SET BCMI_TSC_XGXS_TX_X4_MISCr_RESERVED1f_SET
#define TX_X4_MISCr_CL49_TX_LI_ENABLEf_GET BCMI_TSC_XGXS_TX_X4_MISCr_CL49_TX_LI_ENABLEf_GET
#define TX_X4_MISCr_CL49_TX_LI_ENABLEf_SET BCMI_TSC_XGXS_TX_X4_MISCr_CL49_TX_LI_ENABLEf_SET
#define TX_X4_MISCr_CL49_TX_LF_ENABLEf_GET BCMI_TSC_XGXS_TX_X4_MISCr_CL49_TX_LF_ENABLEf_GET
#define TX_X4_MISCr_CL49_TX_LF_ENABLEf_SET BCMI_TSC_XGXS_TX_X4_MISCr_CL49_TX_LF_ENABLEf_SET
#define TX_X4_MISCr_CL49_TX_RF_ENABLEf_GET BCMI_TSC_XGXS_TX_X4_MISCr_CL49_TX_RF_ENABLEf_GET
#define TX_X4_MISCr_CL49_TX_RF_ENABLEf_SET BCMI_TSC_XGXS_TX_X4_MISCr_CL49_TX_RF_ENABLEf_SET
#define TX_X4_MISCr_RESERVED2f_GET BCMI_TSC_XGXS_TX_X4_MISCr_RESERVED2f_GET
#define TX_X4_MISCr_RESERVED2f_SET BCMI_TSC_XGXS_TX_X4_MISCr_RESERVED2f_SET
#define TX_X4_MISCr_TX_FIFO_WATERMARKf_GET BCMI_TSC_XGXS_TX_X4_MISCr_TX_FIFO_WATERMARKf_GET
#define TX_X4_MISCr_TX_FIFO_WATERMARKf_SET BCMI_TSC_XGXS_TX_X4_MISCr_TX_FIFO_WATERMARKf_SET
#define TX_X4_MISCr_RSTB_TX_LANEf_GET BCMI_TSC_XGXS_TX_X4_MISCr_RSTB_TX_LANEf_GET
#define TX_X4_MISCr_RSTB_TX_LANEf_SET BCMI_TSC_XGXS_TX_X4_MISCr_RSTB_TX_LANEf_SET
#define TX_X4_MISCr_ENABLE_TX_LANEf_GET BCMI_TSC_XGXS_TX_X4_MISCr_ENABLE_TX_LANEf_GET
#define TX_X4_MISCr_ENABLE_TX_LANEf_SET BCMI_TSC_XGXS_TX_X4_MISCr_ENABLE_TX_LANEf_SET
#define READ_TX_X4_MISCr BCMI_TSC_XGXS_READ_TX_X4_MISCr
#define WRITE_TX_X4_MISCr BCMI_TSC_XGXS_WRITE_TX_X4_MISCr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_TX_X4_MISCr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  TX_X4_CL36_TX_0
 * BLOCKS:   TX_X4_CONTROL0
 * REGADDR:  0xc114
 * DESC:     cl36 tx 0 register: 00000000
 * SIZE:     32
 * FIELDS:
 *     RESERVED2        
 *     DISABLE_PACKET_MISALIGN 
 *     RESERVED1        
 *     DISABLE_TRRR_TX  
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_TX_X4_CL36_TX_0r (0x0000c114 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_TX_X4_CL36_TX_0r_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_CL36_TX_0.
 *
 */
typedef union BCMI_TSC_XGXS_TX_X4_CL36_TX_0r_s {
	uint32_t v[1];
	uint32_t tx_x4_cl36_tx_0[1];
	uint32_t _tx_x4_cl36_tx_0;
} BCMI_TSC_XGXS_TX_X4_CL36_TX_0r_t;

#define BCMI_TSC_XGXS_TX_X4_CL36_TX_0r_CLR(r) (r).tx_x4_cl36_tx_0[0] = 0
#define BCMI_TSC_XGXS_TX_X4_CL36_TX_0r_SET(r,d) (r).tx_x4_cl36_tx_0[0] = d
#define BCMI_TSC_XGXS_TX_X4_CL36_TX_0r_GET(r) (r).tx_x4_cl36_tx_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_TX_X4_CL36_TX_0r_RESERVED0f_GET(r) ((((r).tx_x4_cl36_tx_0[0]) >> 5) & 0x7ff)
#define BCMI_TSC_XGXS_TX_X4_CL36_TX_0r_RESERVED0f_SET(r,f) (r).tx_x4_cl36_tx_0[0]=(((r).tx_x4_cl36_tx_0[0] & ~((uint32_t)0x7ff << 5)) | ((((uint32_t)f) & 0x7ff) << 5))
#define BCMI_TSC_XGXS_TX_X4_CL36_TX_0r_DISABLE_TRRR_TXf_GET(r) ((((r).tx_x4_cl36_tx_0[0]) >> 4) & 0x1)
#define BCMI_TSC_XGXS_TX_X4_CL36_TX_0r_DISABLE_TRRR_TXf_SET(r,f) (r).tx_x4_cl36_tx_0[0]=(((r).tx_x4_cl36_tx_0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCMI_TSC_XGXS_TX_X4_CL36_TX_0r_RESERVED1f_GET(r) ((((r).tx_x4_cl36_tx_0[0]) >> 3) & 0x1)
#define BCMI_TSC_XGXS_TX_X4_CL36_TX_0r_RESERVED1f_SET(r,f) (r).tx_x4_cl36_tx_0[0]=(((r).tx_x4_cl36_tx_0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCMI_TSC_XGXS_TX_X4_CL36_TX_0r_DISABLE_PACKET_MISALIGNf_GET(r) ((((r).tx_x4_cl36_tx_0[0]) >> 2) & 0x1)
#define BCMI_TSC_XGXS_TX_X4_CL36_TX_0r_DISABLE_PACKET_MISALIGNf_SET(r,f) (r).tx_x4_cl36_tx_0[0]=(((r).tx_x4_cl36_tx_0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCMI_TSC_XGXS_TX_X4_CL36_TX_0r_RESERVED2f_GET(r) (((r).tx_x4_cl36_tx_0[0]) & 0x3)
#define BCMI_TSC_XGXS_TX_X4_CL36_TX_0r_RESERVED2f_SET(r,f) (r).tx_x4_cl36_tx_0[0]=(((r).tx_x4_cl36_tx_0[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))

/*
 * These macros can be used to access TX_X4_CL36_TX_0.
 *
 */
#define BCMI_TSC_XGXS_READ_TX_X4_CL36_TX_0r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_TX_X4_CL36_TX_0r,(_r._tx_x4_cl36_tx_0))
#define BCMI_TSC_XGXS_WRITE_TX_X4_CL36_TX_0r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_TX_X4_CL36_TX_0r,(_r._tx_x4_cl36_tx_0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_CL36_TX_0r BCMI_TSC_XGXS_TX_X4_CL36_TX_0r
#define TX_X4_CL36_TX_0r_SIZE BCMI_TSC_XGXS_TX_X4_CL36_TX_0r_SIZE
typedef BCMI_TSC_XGXS_TX_X4_CL36_TX_0r_t TX_X4_CL36_TX_0r_t;
#define TX_X4_CL36_TX_0r_CLR BCMI_TSC_XGXS_TX_X4_CL36_TX_0r_CLR
#define TX_X4_CL36_TX_0r_SET BCMI_TSC_XGXS_TX_X4_CL36_TX_0r_SET
#define TX_X4_CL36_TX_0r_GET BCMI_TSC_XGXS_TX_X4_CL36_TX_0r_GET
#define TX_X4_CL36_TX_0r_RESERVED0f_GET BCMI_TSC_XGXS_TX_X4_CL36_TX_0r_RESERVED0f_GET
#define TX_X4_CL36_TX_0r_RESERVED0f_SET BCMI_TSC_XGXS_TX_X4_CL36_TX_0r_RESERVED0f_SET
#define TX_X4_CL36_TX_0r_DISABLE_TRRR_TXf_GET BCMI_TSC_XGXS_TX_X4_CL36_TX_0r_DISABLE_TRRR_TXf_GET
#define TX_X4_CL36_TX_0r_DISABLE_TRRR_TXf_SET BCMI_TSC_XGXS_TX_X4_CL36_TX_0r_DISABLE_TRRR_TXf_SET
#define TX_X4_CL36_TX_0r_RESERVED1f_GET BCMI_TSC_XGXS_TX_X4_CL36_TX_0r_RESERVED1f_GET
#define TX_X4_CL36_TX_0r_RESERVED1f_SET BCMI_TSC_XGXS_TX_X4_CL36_TX_0r_RESERVED1f_SET
#define TX_X4_CL36_TX_0r_DISABLE_PACKET_MISALIGNf_GET BCMI_TSC_XGXS_TX_X4_CL36_TX_0r_DISABLE_PACKET_MISALIGNf_GET
#define TX_X4_CL36_TX_0r_DISABLE_PACKET_MISALIGNf_SET BCMI_TSC_XGXS_TX_X4_CL36_TX_0r_DISABLE_PACKET_MISALIGNf_SET
#define TX_X4_CL36_TX_0r_RESERVED2f_GET BCMI_TSC_XGXS_TX_X4_CL36_TX_0r_RESERVED2f_GET
#define TX_X4_CL36_TX_0r_RESERVED2f_SET BCMI_TSC_XGXS_TX_X4_CL36_TX_0r_RESERVED2f_SET
#define READ_TX_X4_CL36_TX_0r BCMI_TSC_XGXS_READ_TX_X4_CL36_TX_0r
#define WRITE_TX_X4_CL36_TX_0r BCMI_TSC_XGXS_WRITE_TX_X4_CL36_TX_0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_TX_X4_CL36_TX_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  TX_X4_ENCODE_STATUS_0
 * BLOCKS:   TX_X4_STATUS0
 * REGADDR:  0xc120
 * DESC:     Encode Status 0 register: 00000000
 * SIZE:     32
 * FIELDS:
 *     CL49_TXSM_STATE  
 *     CL49_LTXSM_STATE 
 *     CL49_TX_FAULT_DET 
 *     CL49_T_TYPE_CODED 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_TX_X4_ENCODE_STATUS_0r (0x0000c120 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_TX_X4_ENCODE_STATUS_0r_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_ENCODE_STATUS_0.
 *
 */
typedef union BCMI_TSC_XGXS_TX_X4_ENCODE_STATUS_0r_s {
	uint32_t v[1];
	uint32_t tx_x4_encode_status_0[1];
	uint32_t _tx_x4_encode_status_0;
} BCMI_TSC_XGXS_TX_X4_ENCODE_STATUS_0r_t;

#define BCMI_TSC_XGXS_TX_X4_ENCODE_STATUS_0r_CLR(r) (r).tx_x4_encode_status_0[0] = 0
#define BCMI_TSC_XGXS_TX_X4_ENCODE_STATUS_0r_SET(r,d) (r).tx_x4_encode_status_0[0] = d
#define BCMI_TSC_XGXS_TX_X4_ENCODE_STATUS_0r_GET(r) (r).tx_x4_encode_status_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_TX_X4_ENCODE_STATUS_0r_CL49_T_TYPE_CODEDf_GET(r) ((((r).tx_x4_encode_status_0[0]) >> 12) & 0xf)
#define BCMI_TSC_XGXS_TX_X4_ENCODE_STATUS_0r_CL49_T_TYPE_CODEDf_SET(r,f) (r).tx_x4_encode_status_0[0]=(((r).tx_x4_encode_status_0[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCMI_TSC_XGXS_TX_X4_ENCODE_STATUS_0r_CL49_TX_FAULT_DETf_GET(r) ((((r).tx_x4_encode_status_0[0]) >> 11) & 0x1)
#define BCMI_TSC_XGXS_TX_X4_ENCODE_STATUS_0r_CL49_TX_FAULT_DETf_SET(r,f) (r).tx_x4_encode_status_0[0]=(((r).tx_x4_encode_status_0[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCMI_TSC_XGXS_TX_X4_ENCODE_STATUS_0r_CL49_LTXSM_STATEf_GET(r) ((((r).tx_x4_encode_status_0[0]) >> 3) & 0xff)
#define BCMI_TSC_XGXS_TX_X4_ENCODE_STATUS_0r_CL49_LTXSM_STATEf_SET(r,f) (r).tx_x4_encode_status_0[0]=(((r).tx_x4_encode_status_0[0] & ~((uint32_t)0xff << 3)) | ((((uint32_t)f) & 0xff) << 3))
#define BCMI_TSC_XGXS_TX_X4_ENCODE_STATUS_0r_CL49_TXSM_STATEf_GET(r) (((r).tx_x4_encode_status_0[0]) & 0x7)
#define BCMI_TSC_XGXS_TX_X4_ENCODE_STATUS_0r_CL49_TXSM_STATEf_SET(r,f) (r).tx_x4_encode_status_0[0]=(((r).tx_x4_encode_status_0[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))

/*
 * These macros can be used to access TX_X4_ENCODE_STATUS_0.
 *
 */
#define BCMI_TSC_XGXS_READ_TX_X4_ENCODE_STATUS_0r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_TX_X4_ENCODE_STATUS_0r,(_r._tx_x4_encode_status_0))
#define BCMI_TSC_XGXS_WRITE_TX_X4_ENCODE_STATUS_0r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_TX_X4_ENCODE_STATUS_0r,(_r._tx_x4_encode_status_0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_ENCODE_STATUS_0r BCMI_TSC_XGXS_TX_X4_ENCODE_STATUS_0r
#define TX_X4_ENCODE_STATUS_0r_SIZE BCMI_TSC_XGXS_TX_X4_ENCODE_STATUS_0r_SIZE
typedef BCMI_TSC_XGXS_TX_X4_ENCODE_STATUS_0r_t TX_X4_ENCODE_STATUS_0r_t;
#define TX_X4_ENCODE_STATUS_0r_CLR BCMI_TSC_XGXS_TX_X4_ENCODE_STATUS_0r_CLR
#define TX_X4_ENCODE_STATUS_0r_SET BCMI_TSC_XGXS_TX_X4_ENCODE_STATUS_0r_SET
#define TX_X4_ENCODE_STATUS_0r_GET BCMI_TSC_XGXS_TX_X4_ENCODE_STATUS_0r_GET
#define TX_X4_ENCODE_STATUS_0r_CL49_T_TYPE_CODEDf_GET BCMI_TSC_XGXS_TX_X4_ENCODE_STATUS_0r_CL49_T_TYPE_CODEDf_GET
#define TX_X4_ENCODE_STATUS_0r_CL49_T_TYPE_CODEDf_SET BCMI_TSC_XGXS_TX_X4_ENCODE_STATUS_0r_CL49_T_TYPE_CODEDf_SET
#define TX_X4_ENCODE_STATUS_0r_CL49_TX_FAULT_DETf_GET BCMI_TSC_XGXS_TX_X4_ENCODE_STATUS_0r_CL49_TX_FAULT_DETf_GET
#define TX_X4_ENCODE_STATUS_0r_CL49_TX_FAULT_DETf_SET BCMI_TSC_XGXS_TX_X4_ENCODE_STATUS_0r_CL49_TX_FAULT_DETf_SET
#define TX_X4_ENCODE_STATUS_0r_CL49_LTXSM_STATEf_GET BCMI_TSC_XGXS_TX_X4_ENCODE_STATUS_0r_CL49_LTXSM_STATEf_GET
#define TX_X4_ENCODE_STATUS_0r_CL49_LTXSM_STATEf_SET BCMI_TSC_XGXS_TX_X4_ENCODE_STATUS_0r_CL49_LTXSM_STATEf_SET
#define TX_X4_ENCODE_STATUS_0r_CL49_TXSM_STATEf_GET BCMI_TSC_XGXS_TX_X4_ENCODE_STATUS_0r_CL49_TXSM_STATEf_GET
#define TX_X4_ENCODE_STATUS_0r_CL49_TXSM_STATEf_SET BCMI_TSC_XGXS_TX_X4_ENCODE_STATUS_0r_CL49_TXSM_STATEf_SET
#define READ_TX_X4_ENCODE_STATUS_0r BCMI_TSC_XGXS_READ_TX_X4_ENCODE_STATUS_0r
#define WRITE_TX_X4_ENCODE_STATUS_0r BCMI_TSC_XGXS_WRITE_TX_X4_ENCODE_STATUS_0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_TX_X4_ENCODE_STATUS_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  TX_X4_PCS_STATUS
 * BLOCKS:   TX_X4_STATUS0
 * REGADDR:  0xc121
 * DESC:     "Status of PCS Information": 00000000
 * SIZE:     32
 * FIELDS:
 *     LPI_RECEIVED_LH  
 *     RESERVED_ORDERED_SET_LH 
 *     REMOTE_FAULT_LH  
 *     LOCAL_FAULT_LH   
 *     LINK_INTERRUPT_LH 
 *     TX_LPI_RECEIVED  
 *     TX_LINK_INTERRUPT 
 *     TX_REMOTE_FAULT  
 *     TX_LOCAL_FAULT   
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_TX_X4_PCS_STATUSr (0x0000c121 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_TX_X4_PCS_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_PCS_STATUS.
 *
 */
typedef union BCMI_TSC_XGXS_TX_X4_PCS_STATUSr_s {
	uint32_t v[1];
	uint32_t tx_x4_pcs_status[1];
	uint32_t _tx_x4_pcs_status;
} BCMI_TSC_XGXS_TX_X4_PCS_STATUSr_t;

#define BCMI_TSC_XGXS_TX_X4_PCS_STATUSr_CLR(r) (r).tx_x4_pcs_status[0] = 0
#define BCMI_TSC_XGXS_TX_X4_PCS_STATUSr_SET(r,d) (r).tx_x4_pcs_status[0] = d
#define BCMI_TSC_XGXS_TX_X4_PCS_STATUSr_GET(r) (r).tx_x4_pcs_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_TX_X4_PCS_STATUSr_RESERVED0f_GET(r) ((((r).tx_x4_pcs_status[0]) >> 9) & 0x7f)
#define BCMI_TSC_XGXS_TX_X4_PCS_STATUSr_RESERVED0f_SET(r,f) (r).tx_x4_pcs_status[0]=(((r).tx_x4_pcs_status[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))
#define BCMI_TSC_XGXS_TX_X4_PCS_STATUSr_TX_LOCAL_FAULTf_GET(r) ((((r).tx_x4_pcs_status[0]) >> 8) & 0x1)
#define BCMI_TSC_XGXS_TX_X4_PCS_STATUSr_TX_LOCAL_FAULTf_SET(r,f) (r).tx_x4_pcs_status[0]=(((r).tx_x4_pcs_status[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCMI_TSC_XGXS_TX_X4_PCS_STATUSr_TX_REMOTE_FAULTf_GET(r) ((((r).tx_x4_pcs_status[0]) >> 7) & 0x1)
#define BCMI_TSC_XGXS_TX_X4_PCS_STATUSr_TX_REMOTE_FAULTf_SET(r,f) (r).tx_x4_pcs_status[0]=(((r).tx_x4_pcs_status[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCMI_TSC_XGXS_TX_X4_PCS_STATUSr_TX_LINK_INTERRUPTf_GET(r) ((((r).tx_x4_pcs_status[0]) >> 6) & 0x1)
#define BCMI_TSC_XGXS_TX_X4_PCS_STATUSr_TX_LINK_INTERRUPTf_SET(r,f) (r).tx_x4_pcs_status[0]=(((r).tx_x4_pcs_status[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCMI_TSC_XGXS_TX_X4_PCS_STATUSr_TX_LPI_RECEIVEDf_GET(r) ((((r).tx_x4_pcs_status[0]) >> 5) & 0x1)
#define BCMI_TSC_XGXS_TX_X4_PCS_STATUSr_TX_LPI_RECEIVEDf_SET(r,f) (r).tx_x4_pcs_status[0]=(((r).tx_x4_pcs_status[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCMI_TSC_XGXS_TX_X4_PCS_STATUSr_LINK_INTERRUPT_LHf_GET(r) ((((r).tx_x4_pcs_status[0]) >> 4) & 0x1)
#define BCMI_TSC_XGXS_TX_X4_PCS_STATUSr_LINK_INTERRUPT_LHf_SET(r,f) (r).tx_x4_pcs_status[0]=(((r).tx_x4_pcs_status[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCMI_TSC_XGXS_TX_X4_PCS_STATUSr_LOCAL_FAULT_LHf_GET(r) ((((r).tx_x4_pcs_status[0]) >> 3) & 0x1)
#define BCMI_TSC_XGXS_TX_X4_PCS_STATUSr_LOCAL_FAULT_LHf_SET(r,f) (r).tx_x4_pcs_status[0]=(((r).tx_x4_pcs_status[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCMI_TSC_XGXS_TX_X4_PCS_STATUSr_REMOTE_FAULT_LHf_GET(r) ((((r).tx_x4_pcs_status[0]) >> 2) & 0x1)
#define BCMI_TSC_XGXS_TX_X4_PCS_STATUSr_REMOTE_FAULT_LHf_SET(r,f) (r).tx_x4_pcs_status[0]=(((r).tx_x4_pcs_status[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCMI_TSC_XGXS_TX_X4_PCS_STATUSr_RESERVED_ORDERED_SET_LHf_GET(r) ((((r).tx_x4_pcs_status[0]) >> 1) & 0x1)
#define BCMI_TSC_XGXS_TX_X4_PCS_STATUSr_RESERVED_ORDERED_SET_LHf_SET(r,f) (r).tx_x4_pcs_status[0]=(((r).tx_x4_pcs_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCMI_TSC_XGXS_TX_X4_PCS_STATUSr_LPI_RECEIVED_LHf_GET(r) (((r).tx_x4_pcs_status[0]) & 0x1)
#define BCMI_TSC_XGXS_TX_X4_PCS_STATUSr_LPI_RECEIVED_LHf_SET(r,f) (r).tx_x4_pcs_status[0]=(((r).tx_x4_pcs_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access TX_X4_PCS_STATUS.
 *
 */
#define BCMI_TSC_XGXS_READ_TX_X4_PCS_STATUSr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_TX_X4_PCS_STATUSr,(_r._tx_x4_pcs_status))
#define BCMI_TSC_XGXS_WRITE_TX_X4_PCS_STATUSr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_TX_X4_PCS_STATUSr,(_r._tx_x4_pcs_status))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_PCS_STATUSr BCMI_TSC_XGXS_TX_X4_PCS_STATUSr
#define TX_X4_PCS_STATUSr_SIZE BCMI_TSC_XGXS_TX_X4_PCS_STATUSr_SIZE
typedef BCMI_TSC_XGXS_TX_X4_PCS_STATUSr_t TX_X4_PCS_STATUSr_t;
#define TX_X4_PCS_STATUSr_CLR BCMI_TSC_XGXS_TX_X4_PCS_STATUSr_CLR
#define TX_X4_PCS_STATUSr_SET BCMI_TSC_XGXS_TX_X4_PCS_STATUSr_SET
#define TX_X4_PCS_STATUSr_GET BCMI_TSC_XGXS_TX_X4_PCS_STATUSr_GET
#define TX_X4_PCS_STATUSr_RESERVED0f_GET BCMI_TSC_XGXS_TX_X4_PCS_STATUSr_RESERVED0f_GET
#define TX_X4_PCS_STATUSr_RESERVED0f_SET BCMI_TSC_XGXS_TX_X4_PCS_STATUSr_RESERVED0f_SET
#define TX_X4_PCS_STATUSr_TX_LOCAL_FAULTf_GET BCMI_TSC_XGXS_TX_X4_PCS_STATUSr_TX_LOCAL_FAULTf_GET
#define TX_X4_PCS_STATUSr_TX_LOCAL_FAULTf_SET BCMI_TSC_XGXS_TX_X4_PCS_STATUSr_TX_LOCAL_FAULTf_SET
#define TX_X4_PCS_STATUSr_TX_REMOTE_FAULTf_GET BCMI_TSC_XGXS_TX_X4_PCS_STATUSr_TX_REMOTE_FAULTf_GET
#define TX_X4_PCS_STATUSr_TX_REMOTE_FAULTf_SET BCMI_TSC_XGXS_TX_X4_PCS_STATUSr_TX_REMOTE_FAULTf_SET
#define TX_X4_PCS_STATUSr_TX_LINK_INTERRUPTf_GET BCMI_TSC_XGXS_TX_X4_PCS_STATUSr_TX_LINK_INTERRUPTf_GET
#define TX_X4_PCS_STATUSr_TX_LINK_INTERRUPTf_SET BCMI_TSC_XGXS_TX_X4_PCS_STATUSr_TX_LINK_INTERRUPTf_SET
#define TX_X4_PCS_STATUSr_TX_LPI_RECEIVEDf_GET BCMI_TSC_XGXS_TX_X4_PCS_STATUSr_TX_LPI_RECEIVEDf_GET
#define TX_X4_PCS_STATUSr_TX_LPI_RECEIVEDf_SET BCMI_TSC_XGXS_TX_X4_PCS_STATUSr_TX_LPI_RECEIVEDf_SET
#define TX_X4_PCS_STATUSr_LINK_INTERRUPT_LHf_GET BCMI_TSC_XGXS_TX_X4_PCS_STATUSr_LINK_INTERRUPT_LHf_GET
#define TX_X4_PCS_STATUSr_LINK_INTERRUPT_LHf_SET BCMI_TSC_XGXS_TX_X4_PCS_STATUSr_LINK_INTERRUPT_LHf_SET
#define TX_X4_PCS_STATUSr_LOCAL_FAULT_LHf_GET BCMI_TSC_XGXS_TX_X4_PCS_STATUSr_LOCAL_FAULT_LHf_GET
#define TX_X4_PCS_STATUSr_LOCAL_FAULT_LHf_SET BCMI_TSC_XGXS_TX_X4_PCS_STATUSr_LOCAL_FAULT_LHf_SET
#define TX_X4_PCS_STATUSr_REMOTE_FAULT_LHf_GET BCMI_TSC_XGXS_TX_X4_PCS_STATUSr_REMOTE_FAULT_LHf_GET
#define TX_X4_PCS_STATUSr_REMOTE_FAULT_LHf_SET BCMI_TSC_XGXS_TX_X4_PCS_STATUSr_REMOTE_FAULT_LHf_SET
#define TX_X4_PCS_STATUSr_RESERVED_ORDERED_SET_LHf_GET BCMI_TSC_XGXS_TX_X4_PCS_STATUSr_RESERVED_ORDERED_SET_LHf_GET
#define TX_X4_PCS_STATUSr_RESERVED_ORDERED_SET_LHf_SET BCMI_TSC_XGXS_TX_X4_PCS_STATUSr_RESERVED_ORDERED_SET_LHf_SET
#define TX_X4_PCS_STATUSr_LPI_RECEIVED_LHf_GET BCMI_TSC_XGXS_TX_X4_PCS_STATUSr_LPI_RECEIVED_LHf_GET
#define TX_X4_PCS_STATUSr_LPI_RECEIVED_LHf_SET BCMI_TSC_XGXS_TX_X4_PCS_STATUSr_LPI_RECEIVED_LHf_SET
#define READ_TX_X4_PCS_STATUSr BCMI_TSC_XGXS_READ_TX_X4_PCS_STATUSr
#define WRITE_TX_X4_PCS_STATUSr BCMI_TSC_XGXS_WRITE_TX_X4_PCS_STATUSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_TX_X4_PCS_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X4_PCS_CONTROL_0
 * BLOCKS:   RX_X4_CONTROL0
 * REGADDR:  0xc130
 * DESC:     pcs control 0 register: 00000000
 * SIZE:     32
 * FIELDS:
 *     RESERVED0        
 *     BRCM64B66_DESCRAMBLER_ENABLE 
 *     LPI_ENABLE       
 *     CL36BYTEDELETEMODE 
 *     DESC2_MODE       
 *     DESKEWMODE       
 *     DECODERMODE      
 *     DESCRAMBLERMODE  
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X4_PCS_CONTROL_0r (0x0000c130 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X4_PCS_CONTROL_0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_PCS_CONTROL_0.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X4_PCS_CONTROL_0r_s {
	uint32_t v[1];
	uint32_t rx_x4_pcs_control_0[1];
	uint32_t _rx_x4_pcs_control_0;
} BCMI_TSC_XGXS_RX_X4_PCS_CONTROL_0r_t;

#define BCMI_TSC_XGXS_RX_X4_PCS_CONTROL_0r_CLR(r) (r).rx_x4_pcs_control_0[0] = 0
#define BCMI_TSC_XGXS_RX_X4_PCS_CONTROL_0r_SET(r,d) (r).rx_x4_pcs_control_0[0] = d
#define BCMI_TSC_XGXS_RX_X4_PCS_CONTROL_0r_GET(r) (r).rx_x4_pcs_control_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X4_PCS_CONTROL_0r_DESCRAMBLERMODEf_GET(r) ((((r).rx_x4_pcs_control_0[0]) >> 14) & 0x3)
#define BCMI_TSC_XGXS_RX_X4_PCS_CONTROL_0r_DESCRAMBLERMODEf_SET(r,f) (r).rx_x4_pcs_control_0[0]=(((r).rx_x4_pcs_control_0[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCMI_TSC_XGXS_RX_X4_PCS_CONTROL_0r_DECODERMODEf_GET(r) ((((r).rx_x4_pcs_control_0[0]) >> 11) & 0x7)
#define BCMI_TSC_XGXS_RX_X4_PCS_CONTROL_0r_DECODERMODEf_SET(r,f) (r).rx_x4_pcs_control_0[0]=(((r).rx_x4_pcs_control_0[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11))
#define BCMI_TSC_XGXS_RX_X4_PCS_CONTROL_0r_DESKEWMODEf_GET(r) ((((r).rx_x4_pcs_control_0[0]) >> 8) & 0x7)
#define BCMI_TSC_XGXS_RX_X4_PCS_CONTROL_0r_DESKEWMODEf_SET(r,f) (r).rx_x4_pcs_control_0[0]=(((r).rx_x4_pcs_control_0[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8))
#define BCMI_TSC_XGXS_RX_X4_PCS_CONTROL_0r_DESC2_MODEf_GET(r) ((((r).rx_x4_pcs_control_0[0]) >> 5) & 0x7)
#define BCMI_TSC_XGXS_RX_X4_PCS_CONTROL_0r_DESC2_MODEf_SET(r,f) (r).rx_x4_pcs_control_0[0]=(((r).rx_x4_pcs_control_0[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))
#define BCMI_TSC_XGXS_RX_X4_PCS_CONTROL_0r_CL36BYTEDELETEMODEf_GET(r) ((((r).rx_x4_pcs_control_0[0]) >> 3) & 0x3)
#define BCMI_TSC_XGXS_RX_X4_PCS_CONTROL_0r_CL36BYTEDELETEMODEf_SET(r,f) (r).rx_x4_pcs_control_0[0]=(((r).rx_x4_pcs_control_0[0] & ~((uint32_t)0x3 << 3)) | ((((uint32_t)f) & 0x3) << 3))
#define BCMI_TSC_XGXS_RX_X4_PCS_CONTROL_0r_LPI_ENABLEf_GET(r) ((((r).rx_x4_pcs_control_0[0]) >> 2) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_PCS_CONTROL_0r_LPI_ENABLEf_SET(r,f) (r).rx_x4_pcs_control_0[0]=(((r).rx_x4_pcs_control_0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCMI_TSC_XGXS_RX_X4_PCS_CONTROL_0r_BRCM64B66_DESCRAMBLER_ENABLEf_GET(r) ((((r).rx_x4_pcs_control_0[0]) >> 1) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_PCS_CONTROL_0r_BRCM64B66_DESCRAMBLER_ENABLEf_SET(r,f) (r).rx_x4_pcs_control_0[0]=(((r).rx_x4_pcs_control_0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCMI_TSC_XGXS_RX_X4_PCS_CONTROL_0r_RESERVED0f_GET(r) (((r).rx_x4_pcs_control_0[0]) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_PCS_CONTROL_0r_RESERVED0f_SET(r,f) (r).rx_x4_pcs_control_0[0]=(((r).rx_x4_pcs_control_0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access RX_X4_PCS_CONTROL_0.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X4_PCS_CONTROL_0r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X4_PCS_CONTROL_0r,(_r._rx_x4_pcs_control_0))
#define BCMI_TSC_XGXS_WRITE_RX_X4_PCS_CONTROL_0r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X4_PCS_CONTROL_0r,(_r._rx_x4_pcs_control_0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_PCS_CONTROL_0r BCMI_TSC_XGXS_RX_X4_PCS_CONTROL_0r
#define RX_X4_PCS_CONTROL_0r_SIZE BCMI_TSC_XGXS_RX_X4_PCS_CONTROL_0r_SIZE
typedef BCMI_TSC_XGXS_RX_X4_PCS_CONTROL_0r_t RX_X4_PCS_CONTROL_0r_t;
#define RX_X4_PCS_CONTROL_0r_CLR BCMI_TSC_XGXS_RX_X4_PCS_CONTROL_0r_CLR
#define RX_X4_PCS_CONTROL_0r_SET BCMI_TSC_XGXS_RX_X4_PCS_CONTROL_0r_SET
#define RX_X4_PCS_CONTROL_0r_GET BCMI_TSC_XGXS_RX_X4_PCS_CONTROL_0r_GET
#define RX_X4_PCS_CONTROL_0r_DESCRAMBLERMODEf_GET BCMI_TSC_XGXS_RX_X4_PCS_CONTROL_0r_DESCRAMBLERMODEf_GET
#define RX_X4_PCS_CONTROL_0r_DESCRAMBLERMODEf_SET BCMI_TSC_XGXS_RX_X4_PCS_CONTROL_0r_DESCRAMBLERMODEf_SET
#define RX_X4_PCS_CONTROL_0r_DECODERMODEf_GET BCMI_TSC_XGXS_RX_X4_PCS_CONTROL_0r_DECODERMODEf_GET
#define RX_X4_PCS_CONTROL_0r_DECODERMODEf_SET BCMI_TSC_XGXS_RX_X4_PCS_CONTROL_0r_DECODERMODEf_SET
#define RX_X4_PCS_CONTROL_0r_DESKEWMODEf_GET BCMI_TSC_XGXS_RX_X4_PCS_CONTROL_0r_DESKEWMODEf_GET
#define RX_X4_PCS_CONTROL_0r_DESKEWMODEf_SET BCMI_TSC_XGXS_RX_X4_PCS_CONTROL_0r_DESKEWMODEf_SET
#define RX_X4_PCS_CONTROL_0r_DESC2_MODEf_GET BCMI_TSC_XGXS_RX_X4_PCS_CONTROL_0r_DESC2_MODEf_GET
#define RX_X4_PCS_CONTROL_0r_DESC2_MODEf_SET BCMI_TSC_XGXS_RX_X4_PCS_CONTROL_0r_DESC2_MODEf_SET
#define RX_X4_PCS_CONTROL_0r_CL36BYTEDELETEMODEf_GET BCMI_TSC_XGXS_RX_X4_PCS_CONTROL_0r_CL36BYTEDELETEMODEf_GET
#define RX_X4_PCS_CONTROL_0r_CL36BYTEDELETEMODEf_SET BCMI_TSC_XGXS_RX_X4_PCS_CONTROL_0r_CL36BYTEDELETEMODEf_SET
#define RX_X4_PCS_CONTROL_0r_LPI_ENABLEf_GET BCMI_TSC_XGXS_RX_X4_PCS_CONTROL_0r_LPI_ENABLEf_GET
#define RX_X4_PCS_CONTROL_0r_LPI_ENABLEf_SET BCMI_TSC_XGXS_RX_X4_PCS_CONTROL_0r_LPI_ENABLEf_SET
#define RX_X4_PCS_CONTROL_0r_BRCM64B66_DESCRAMBLER_ENABLEf_GET BCMI_TSC_XGXS_RX_X4_PCS_CONTROL_0r_BRCM64B66_DESCRAMBLER_ENABLEf_GET
#define RX_X4_PCS_CONTROL_0r_BRCM64B66_DESCRAMBLER_ENABLEf_SET BCMI_TSC_XGXS_RX_X4_PCS_CONTROL_0r_BRCM64B66_DESCRAMBLER_ENABLEf_SET
#define RX_X4_PCS_CONTROL_0r_RESERVED0f_GET BCMI_TSC_XGXS_RX_X4_PCS_CONTROL_0r_RESERVED0f_GET
#define RX_X4_PCS_CONTROL_0r_RESERVED0f_SET BCMI_TSC_XGXS_RX_X4_PCS_CONTROL_0r_RESERVED0f_SET
#define READ_RX_X4_PCS_CONTROL_0r BCMI_TSC_XGXS_READ_RX_X4_PCS_CONTROL_0r
#define WRITE_RX_X4_PCS_CONTROL_0r BCMI_TSC_XGXS_WRITE_RX_X4_PCS_CONTROL_0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X4_PCS_CONTROL_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X4_FEC_0
 * BLOCKS:   RX_X4_CONTROL0
 * REGADDR:  0xc131
 * DESC:     User FEC Control 0 register: 00000000
 * SIZE:     32
 * FIELDS:
 *     RESERVED1        
 *     FAST_LOCK_EN     
 *     DBG_ENABLE       
 *     ERROR_EN_OVR_VAL 
 *     ERROR_EN_OVR     
 *     FEC_ERR_ENABLE   
 *     RESERVED0        
 *     BLOCK_SYNC_OVERRIDE 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X4_FEC_0r (0x0000c131 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X4_FEC_0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_0.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X4_FEC_0r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_0[1];
	uint32_t _rx_x4_fec_0;
} BCMI_TSC_XGXS_RX_X4_FEC_0r_t;

#define BCMI_TSC_XGXS_RX_X4_FEC_0r_CLR(r) (r).rx_x4_fec_0[0] = 0
#define BCMI_TSC_XGXS_RX_X4_FEC_0r_SET(r,d) (r).rx_x4_fec_0[0] = d
#define BCMI_TSC_XGXS_RX_X4_FEC_0r_GET(r) (r).rx_x4_fec_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X4_FEC_0r_BLOCK_SYNC_OVERRIDEf_GET(r) ((((r).rx_x4_fec_0[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_FEC_0r_BLOCK_SYNC_OVERRIDEf_SET(r,f) (r).rx_x4_fec_0[0]=(((r).rx_x4_fec_0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_RX_X4_FEC_0r_RESERVED0f_GET(r) ((((r).rx_x4_fec_0[0]) >> 14) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_FEC_0r_RESERVED0f_SET(r,f) (r).rx_x4_fec_0[0]=(((r).rx_x4_fec_0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCMI_TSC_XGXS_RX_X4_FEC_0r_FEC_ERR_ENABLEf_GET(r) ((((r).rx_x4_fec_0[0]) >> 13) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_FEC_0r_FEC_ERR_ENABLEf_SET(r,f) (r).rx_x4_fec_0[0]=(((r).rx_x4_fec_0[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCMI_TSC_XGXS_RX_X4_FEC_0r_ERROR_EN_OVRf_GET(r) ((((r).rx_x4_fec_0[0]) >> 12) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_FEC_0r_ERROR_EN_OVRf_SET(r,f) (r).rx_x4_fec_0[0]=(((r).rx_x4_fec_0[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCMI_TSC_XGXS_RX_X4_FEC_0r_ERROR_EN_OVR_VALf_GET(r) ((((r).rx_x4_fec_0[0]) >> 11) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_FEC_0r_ERROR_EN_OVR_VALf_SET(r,f) (r).rx_x4_fec_0[0]=(((r).rx_x4_fec_0[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCMI_TSC_XGXS_RX_X4_FEC_0r_DBG_ENABLEf_GET(r) ((((r).rx_x4_fec_0[0]) >> 10) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_FEC_0r_DBG_ENABLEf_SET(r,f) (r).rx_x4_fec_0[0]=(((r).rx_x4_fec_0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCMI_TSC_XGXS_RX_X4_FEC_0r_FAST_LOCK_ENf_GET(r) ((((r).rx_x4_fec_0[0]) >> 9) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_FEC_0r_FAST_LOCK_ENf_SET(r,f) (r).rx_x4_fec_0[0]=(((r).rx_x4_fec_0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCMI_TSC_XGXS_RX_X4_FEC_0r_RESERVED1f_GET(r) (((r).rx_x4_fec_0[0]) & 0x1ff)
#define BCMI_TSC_XGXS_RX_X4_FEC_0r_RESERVED1f_SET(r,f) (r).rx_x4_fec_0[0]=(((r).rx_x4_fec_0[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))

/*
 * These macros can be used to access RX_X4_FEC_0.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X4_FEC_0r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X4_FEC_0r,(_r._rx_x4_fec_0))
#define BCMI_TSC_XGXS_WRITE_RX_X4_FEC_0r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X4_FEC_0r,(_r._rx_x4_fec_0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_0r BCMI_TSC_XGXS_RX_X4_FEC_0r
#define RX_X4_FEC_0r_SIZE BCMI_TSC_XGXS_RX_X4_FEC_0r_SIZE
typedef BCMI_TSC_XGXS_RX_X4_FEC_0r_t RX_X4_FEC_0r_t;
#define RX_X4_FEC_0r_CLR BCMI_TSC_XGXS_RX_X4_FEC_0r_CLR
#define RX_X4_FEC_0r_SET BCMI_TSC_XGXS_RX_X4_FEC_0r_SET
#define RX_X4_FEC_0r_GET BCMI_TSC_XGXS_RX_X4_FEC_0r_GET
#define RX_X4_FEC_0r_BLOCK_SYNC_OVERRIDEf_GET BCMI_TSC_XGXS_RX_X4_FEC_0r_BLOCK_SYNC_OVERRIDEf_GET
#define RX_X4_FEC_0r_BLOCK_SYNC_OVERRIDEf_SET BCMI_TSC_XGXS_RX_X4_FEC_0r_BLOCK_SYNC_OVERRIDEf_SET
#define RX_X4_FEC_0r_RESERVED0f_GET BCMI_TSC_XGXS_RX_X4_FEC_0r_RESERVED0f_GET
#define RX_X4_FEC_0r_RESERVED0f_SET BCMI_TSC_XGXS_RX_X4_FEC_0r_RESERVED0f_SET
#define RX_X4_FEC_0r_FEC_ERR_ENABLEf_GET BCMI_TSC_XGXS_RX_X4_FEC_0r_FEC_ERR_ENABLEf_GET
#define RX_X4_FEC_0r_FEC_ERR_ENABLEf_SET BCMI_TSC_XGXS_RX_X4_FEC_0r_FEC_ERR_ENABLEf_SET
#define RX_X4_FEC_0r_ERROR_EN_OVRf_GET BCMI_TSC_XGXS_RX_X4_FEC_0r_ERROR_EN_OVRf_GET
#define RX_X4_FEC_0r_ERROR_EN_OVRf_SET BCMI_TSC_XGXS_RX_X4_FEC_0r_ERROR_EN_OVRf_SET
#define RX_X4_FEC_0r_ERROR_EN_OVR_VALf_GET BCMI_TSC_XGXS_RX_X4_FEC_0r_ERROR_EN_OVR_VALf_GET
#define RX_X4_FEC_0r_ERROR_EN_OVR_VALf_SET BCMI_TSC_XGXS_RX_X4_FEC_0r_ERROR_EN_OVR_VALf_SET
#define RX_X4_FEC_0r_DBG_ENABLEf_GET BCMI_TSC_XGXS_RX_X4_FEC_0r_DBG_ENABLEf_GET
#define RX_X4_FEC_0r_DBG_ENABLEf_SET BCMI_TSC_XGXS_RX_X4_FEC_0r_DBG_ENABLEf_SET
#define RX_X4_FEC_0r_FAST_LOCK_ENf_GET BCMI_TSC_XGXS_RX_X4_FEC_0r_FAST_LOCK_ENf_GET
#define RX_X4_FEC_0r_FAST_LOCK_ENf_SET BCMI_TSC_XGXS_RX_X4_FEC_0r_FAST_LOCK_ENf_SET
#define RX_X4_FEC_0r_RESERVED1f_GET BCMI_TSC_XGXS_RX_X4_FEC_0r_RESERVED1f_GET
#define RX_X4_FEC_0r_RESERVED1f_SET BCMI_TSC_XGXS_RX_X4_FEC_0r_RESERVED1f_SET
#define READ_RX_X4_FEC_0r BCMI_TSC_XGXS_READ_RX_X4_FEC_0r
#define WRITE_RX_X4_FEC_0r BCMI_TSC_XGXS_WRITE_RX_X4_FEC_0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X4_FEC_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X4_FEC_1
 * BLOCKS:   RX_X4_CONTROL0
 * REGADDR:  0xc132
 * DESC:     User FEC Control 1 register: 00000000
 * SIZE:     32
 * FIELDS:
 *     DBG_ERR_MODE     
 *     BURST_ERR_STATUS_MODE 
 *     DEC_MAX_PM       
 *     INVALID_PARITY_CNT 
 *     GOOD_PARITY_CNT  
 *     FEC_ERROR_CODE_ALL 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X4_FEC_1r (0x0000c132 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X4_FEC_1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_1.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X4_FEC_1r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_1[1];
	uint32_t _rx_x4_fec_1;
} BCMI_TSC_XGXS_RX_X4_FEC_1r_t;

#define BCMI_TSC_XGXS_RX_X4_FEC_1r_CLR(r) (r).rx_x4_fec_1[0] = 0
#define BCMI_TSC_XGXS_RX_X4_FEC_1r_SET(r,d) (r).rx_x4_fec_1[0] = d
#define BCMI_TSC_XGXS_RX_X4_FEC_1r_GET(r) (r).rx_x4_fec_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X4_FEC_1r_FEC_ERROR_CODE_ALLf_GET(r) ((((r).rx_x4_fec_1[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_FEC_1r_FEC_ERROR_CODE_ALLf_SET(r,f) (r).rx_x4_fec_1[0]=(((r).rx_x4_fec_1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_RX_X4_FEC_1r_GOOD_PARITY_CNTf_GET(r) ((((r).rx_x4_fec_1[0]) >> 12) & 0x7)
#define BCMI_TSC_XGXS_RX_X4_FEC_1r_GOOD_PARITY_CNTf_SET(r,f) (r).rx_x4_fec_1[0]=(((r).rx_x4_fec_1[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCMI_TSC_XGXS_RX_X4_FEC_1r_INVALID_PARITY_CNTf_GET(r) ((((r).rx_x4_fec_1[0]) >> 8) & 0xf)
#define BCMI_TSC_XGXS_RX_X4_FEC_1r_INVALID_PARITY_CNTf_SET(r,f) (r).rx_x4_fec_1[0]=(((r).rx_x4_fec_1[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCMI_TSC_XGXS_RX_X4_FEC_1r_DEC_MAX_PMf_GET(r) ((((r).rx_x4_fec_1[0]) >> 2) & 0x3f)
#define BCMI_TSC_XGXS_RX_X4_FEC_1r_DEC_MAX_PMf_SET(r,f) (r).rx_x4_fec_1[0]=(((r).rx_x4_fec_1[0] & ~((uint32_t)0x3f << 2)) | ((((uint32_t)f) & 0x3f) << 2))
#define BCMI_TSC_XGXS_RX_X4_FEC_1r_BURST_ERR_STATUS_MODEf_GET(r) ((((r).rx_x4_fec_1[0]) >> 1) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_FEC_1r_BURST_ERR_STATUS_MODEf_SET(r,f) (r).rx_x4_fec_1[0]=(((r).rx_x4_fec_1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCMI_TSC_XGXS_RX_X4_FEC_1r_DBG_ERR_MODEf_GET(r) (((r).rx_x4_fec_1[0]) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_FEC_1r_DBG_ERR_MODEf_SET(r,f) (r).rx_x4_fec_1[0]=(((r).rx_x4_fec_1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access RX_X4_FEC_1.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X4_FEC_1r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X4_FEC_1r,(_r._rx_x4_fec_1))
#define BCMI_TSC_XGXS_WRITE_RX_X4_FEC_1r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X4_FEC_1r,(_r._rx_x4_fec_1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_1r BCMI_TSC_XGXS_RX_X4_FEC_1r
#define RX_X4_FEC_1r_SIZE BCMI_TSC_XGXS_RX_X4_FEC_1r_SIZE
typedef BCMI_TSC_XGXS_RX_X4_FEC_1r_t RX_X4_FEC_1r_t;
#define RX_X4_FEC_1r_CLR BCMI_TSC_XGXS_RX_X4_FEC_1r_CLR
#define RX_X4_FEC_1r_SET BCMI_TSC_XGXS_RX_X4_FEC_1r_SET
#define RX_X4_FEC_1r_GET BCMI_TSC_XGXS_RX_X4_FEC_1r_GET
#define RX_X4_FEC_1r_FEC_ERROR_CODE_ALLf_GET BCMI_TSC_XGXS_RX_X4_FEC_1r_FEC_ERROR_CODE_ALLf_GET
#define RX_X4_FEC_1r_FEC_ERROR_CODE_ALLf_SET BCMI_TSC_XGXS_RX_X4_FEC_1r_FEC_ERROR_CODE_ALLf_SET
#define RX_X4_FEC_1r_GOOD_PARITY_CNTf_GET BCMI_TSC_XGXS_RX_X4_FEC_1r_GOOD_PARITY_CNTf_GET
#define RX_X4_FEC_1r_GOOD_PARITY_CNTf_SET BCMI_TSC_XGXS_RX_X4_FEC_1r_GOOD_PARITY_CNTf_SET
#define RX_X4_FEC_1r_INVALID_PARITY_CNTf_GET BCMI_TSC_XGXS_RX_X4_FEC_1r_INVALID_PARITY_CNTf_GET
#define RX_X4_FEC_1r_INVALID_PARITY_CNTf_SET BCMI_TSC_XGXS_RX_X4_FEC_1r_INVALID_PARITY_CNTf_SET
#define RX_X4_FEC_1r_DEC_MAX_PMf_GET BCMI_TSC_XGXS_RX_X4_FEC_1r_DEC_MAX_PMf_GET
#define RX_X4_FEC_1r_DEC_MAX_PMf_SET BCMI_TSC_XGXS_RX_X4_FEC_1r_DEC_MAX_PMf_SET
#define RX_X4_FEC_1r_BURST_ERR_STATUS_MODEf_GET BCMI_TSC_XGXS_RX_X4_FEC_1r_BURST_ERR_STATUS_MODEf_GET
#define RX_X4_FEC_1r_BURST_ERR_STATUS_MODEf_SET BCMI_TSC_XGXS_RX_X4_FEC_1r_BURST_ERR_STATUS_MODEf_SET
#define RX_X4_FEC_1r_DBG_ERR_MODEf_GET BCMI_TSC_XGXS_RX_X4_FEC_1r_DBG_ERR_MODEf_GET
#define RX_X4_FEC_1r_DBG_ERR_MODEf_SET BCMI_TSC_XGXS_RX_X4_FEC_1r_DBG_ERR_MODEf_SET
#define READ_RX_X4_FEC_1r BCMI_TSC_XGXS_READ_RX_X4_FEC_1r
#define WRITE_RX_X4_FEC_1r BCMI_TSC_XGXS_WRITE_RX_X4_FEC_1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X4_FEC_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X4_FEC_2
 * BLOCKS:   RX_X4_CONTROL0
 * REGADDR:  0xc133
 * DESC:     User FEC Control 2 register: 00000000
 * SIZE:     32
 * FIELDS:
 *     RESERVED0        
 *     DEC_GAP_COUNT_MODE 
 *     DEC_17B_BURST_GAP_COUNT 
 *     DEC_18B_BURST_GAP_COUNT 
 *     DEC_19B_BURST_GAP_COUNT 
 *     DEC_PM_MODE      
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X4_FEC_2r (0x0000c133 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X4_FEC_2r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_2.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X4_FEC_2r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_2[1];
	uint32_t _rx_x4_fec_2;
} BCMI_TSC_XGXS_RX_X4_FEC_2r_t;

#define BCMI_TSC_XGXS_RX_X4_FEC_2r_CLR(r) (r).rx_x4_fec_2[0] = 0
#define BCMI_TSC_XGXS_RX_X4_FEC_2r_SET(r,d) (r).rx_x4_fec_2[0] = d
#define BCMI_TSC_XGXS_RX_X4_FEC_2r_GET(r) (r).rx_x4_fec_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X4_FEC_2r_DEC_PM_MODEf_GET(r) ((((r).rx_x4_fec_2[0]) >> 11) & 0x1f)
#define BCMI_TSC_XGXS_RX_X4_FEC_2r_DEC_PM_MODEf_SET(r,f) (r).rx_x4_fec_2[0]=(((r).rx_x4_fec_2[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))
#define BCMI_TSC_XGXS_RX_X4_FEC_2r_DEC_19B_BURST_GAP_COUNTf_GET(r) ((((r).rx_x4_fec_2[0]) >> 8) & 0x7)
#define BCMI_TSC_XGXS_RX_X4_FEC_2r_DEC_19B_BURST_GAP_COUNTf_SET(r,f) (r).rx_x4_fec_2[0]=(((r).rx_x4_fec_2[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8))
#define BCMI_TSC_XGXS_RX_X4_FEC_2r_DEC_18B_BURST_GAP_COUNTf_GET(r) ((((r).rx_x4_fec_2[0]) >> 5) & 0x7)
#define BCMI_TSC_XGXS_RX_X4_FEC_2r_DEC_18B_BURST_GAP_COUNTf_SET(r,f) (r).rx_x4_fec_2[0]=(((r).rx_x4_fec_2[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))
#define BCMI_TSC_XGXS_RX_X4_FEC_2r_DEC_17B_BURST_GAP_COUNTf_GET(r) ((((r).rx_x4_fec_2[0]) >> 2) & 0x7)
#define BCMI_TSC_XGXS_RX_X4_FEC_2r_DEC_17B_BURST_GAP_COUNTf_SET(r,f) (r).rx_x4_fec_2[0]=(((r).rx_x4_fec_2[0] & ~((uint32_t)0x7 << 2)) | ((((uint32_t)f) & 0x7) << 2))
#define BCMI_TSC_XGXS_RX_X4_FEC_2r_DEC_GAP_COUNT_MODEf_GET(r) ((((r).rx_x4_fec_2[0]) >> 1) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_FEC_2r_DEC_GAP_COUNT_MODEf_SET(r,f) (r).rx_x4_fec_2[0]=(((r).rx_x4_fec_2[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCMI_TSC_XGXS_RX_X4_FEC_2r_RESERVED0f_GET(r) (((r).rx_x4_fec_2[0]) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_FEC_2r_RESERVED0f_SET(r,f) (r).rx_x4_fec_2[0]=(((r).rx_x4_fec_2[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access RX_X4_FEC_2.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X4_FEC_2r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X4_FEC_2r,(_r._rx_x4_fec_2))
#define BCMI_TSC_XGXS_WRITE_RX_X4_FEC_2r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X4_FEC_2r,(_r._rx_x4_fec_2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_2r BCMI_TSC_XGXS_RX_X4_FEC_2r
#define RX_X4_FEC_2r_SIZE BCMI_TSC_XGXS_RX_X4_FEC_2r_SIZE
typedef BCMI_TSC_XGXS_RX_X4_FEC_2r_t RX_X4_FEC_2r_t;
#define RX_X4_FEC_2r_CLR BCMI_TSC_XGXS_RX_X4_FEC_2r_CLR
#define RX_X4_FEC_2r_SET BCMI_TSC_XGXS_RX_X4_FEC_2r_SET
#define RX_X4_FEC_2r_GET BCMI_TSC_XGXS_RX_X4_FEC_2r_GET
#define RX_X4_FEC_2r_DEC_PM_MODEf_GET BCMI_TSC_XGXS_RX_X4_FEC_2r_DEC_PM_MODEf_GET
#define RX_X4_FEC_2r_DEC_PM_MODEf_SET BCMI_TSC_XGXS_RX_X4_FEC_2r_DEC_PM_MODEf_SET
#define RX_X4_FEC_2r_DEC_19B_BURST_GAP_COUNTf_GET BCMI_TSC_XGXS_RX_X4_FEC_2r_DEC_19B_BURST_GAP_COUNTf_GET
#define RX_X4_FEC_2r_DEC_19B_BURST_GAP_COUNTf_SET BCMI_TSC_XGXS_RX_X4_FEC_2r_DEC_19B_BURST_GAP_COUNTf_SET
#define RX_X4_FEC_2r_DEC_18B_BURST_GAP_COUNTf_GET BCMI_TSC_XGXS_RX_X4_FEC_2r_DEC_18B_BURST_GAP_COUNTf_GET
#define RX_X4_FEC_2r_DEC_18B_BURST_GAP_COUNTf_SET BCMI_TSC_XGXS_RX_X4_FEC_2r_DEC_18B_BURST_GAP_COUNTf_SET
#define RX_X4_FEC_2r_DEC_17B_BURST_GAP_COUNTf_GET BCMI_TSC_XGXS_RX_X4_FEC_2r_DEC_17B_BURST_GAP_COUNTf_GET
#define RX_X4_FEC_2r_DEC_17B_BURST_GAP_COUNTf_SET BCMI_TSC_XGXS_RX_X4_FEC_2r_DEC_17B_BURST_GAP_COUNTf_SET
#define RX_X4_FEC_2r_DEC_GAP_COUNT_MODEf_GET BCMI_TSC_XGXS_RX_X4_FEC_2r_DEC_GAP_COUNT_MODEf_GET
#define RX_X4_FEC_2r_DEC_GAP_COUNT_MODEf_SET BCMI_TSC_XGXS_RX_X4_FEC_2r_DEC_GAP_COUNT_MODEf_SET
#define RX_X4_FEC_2r_RESERVED0f_GET BCMI_TSC_XGXS_RX_X4_FEC_2r_RESERVED0f_GET
#define RX_X4_FEC_2r_RESERVED0f_SET BCMI_TSC_XGXS_RX_X4_FEC_2r_RESERVED0f_SET
#define READ_RX_X4_FEC_2r BCMI_TSC_XGXS_READ_RX_X4_FEC_2r
#define WRITE_RX_X4_FEC_2r BCMI_TSC_XGXS_WRITE_RX_X4_FEC_2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X4_FEC_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X4_DECODE_CONTROL_0
 * BLOCKS:   RX_X4_CONTROL0
 * REGADDR:  0xc134
 * DESC:     Decoder control 0 register: 00000000
 * SIZE:     32
 * FIELDS:
 *     BLOCK_SYNC_MODE  
 *     RESERVED1        
 *     CL49_RX_RF_ENABLE 
 *     CL49_RX_LF_ENABLE 
 *     CL49_RX_LI_ENABLE 
 *     RESERVED0        
 *     DISABLE_CL49_BERMON 
 *     HG2_CODEC        
 *     CL48_CGBAD_EN    
 *     CL48_SYNCACQ_EN  
 *     HG2_ENABLE       
 *     HG2_MESSAGE_INVALID_CODE_ENABLE 
 *     R_TEST_MODE_CFG  
 *     BYPASS_CL49RXSM  
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r (0x0000c134 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_DECODE_CONTROL_0.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_s {
	uint32_t v[1];
	uint32_t rx_x4_decode_control_0[1];
	uint32_t _rx_x4_decode_control_0;
} BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_t;

#define BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_CLR(r) (r).rx_x4_decode_control_0[0] = 0
#define BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_SET(r,d) (r).rx_x4_decode_control_0[0] = d
#define BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_GET(r) (r).rx_x4_decode_control_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_BYPASS_CL49RXSMf_GET(r) ((((r).rx_x4_decode_control_0[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_BYPASS_CL49RXSMf_SET(r,f) (r).rx_x4_decode_control_0[0]=(((r).rx_x4_decode_control_0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_R_TEST_MODE_CFGf_GET(r) ((((r).rx_x4_decode_control_0[0]) >> 14) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_R_TEST_MODE_CFGf_SET(r,f) (r).rx_x4_decode_control_0[0]=(((r).rx_x4_decode_control_0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_HG2_MESSAGE_INVALID_CODE_ENABLEf_GET(r) ((((r).rx_x4_decode_control_0[0]) >> 13) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_HG2_MESSAGE_INVALID_CODE_ENABLEf_SET(r,f) (r).rx_x4_decode_control_0[0]=(((r).rx_x4_decode_control_0[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_HG2_ENABLEf_GET(r) ((((r).rx_x4_decode_control_0[0]) >> 12) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_HG2_ENABLEf_SET(r,f) (r).rx_x4_decode_control_0[0]=(((r).rx_x4_decode_control_0[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_CL48_SYNCACQ_ENf_GET(r) ((((r).rx_x4_decode_control_0[0]) >> 11) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_CL48_SYNCACQ_ENf_SET(r,f) (r).rx_x4_decode_control_0[0]=(((r).rx_x4_decode_control_0[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_CL48_CGBAD_ENf_GET(r) ((((r).rx_x4_decode_control_0[0]) >> 10) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_CL48_CGBAD_ENf_SET(r,f) (r).rx_x4_decode_control_0[0]=(((r).rx_x4_decode_control_0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_HG2_CODECf_GET(r) ((((r).rx_x4_decode_control_0[0]) >> 9) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_HG2_CODECf_SET(r,f) (r).rx_x4_decode_control_0[0]=(((r).rx_x4_decode_control_0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_DISABLE_CL49_BERMONf_GET(r) ((((r).rx_x4_decode_control_0[0]) >> 8) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_DISABLE_CL49_BERMONf_SET(r,f) (r).rx_x4_decode_control_0[0]=(((r).rx_x4_decode_control_0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_RESERVED0f_GET(r) ((((r).rx_x4_decode_control_0[0]) >> 7) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_RESERVED0f_SET(r,f) (r).rx_x4_decode_control_0[0]=(((r).rx_x4_decode_control_0[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_CL49_RX_LI_ENABLEf_GET(r) ((((r).rx_x4_decode_control_0[0]) >> 6) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_CL49_RX_LI_ENABLEf_SET(r,f) (r).rx_x4_decode_control_0[0]=(((r).rx_x4_decode_control_0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_CL49_RX_LF_ENABLEf_GET(r) ((((r).rx_x4_decode_control_0[0]) >> 5) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_CL49_RX_LF_ENABLEf_SET(r,f) (r).rx_x4_decode_control_0[0]=(((r).rx_x4_decode_control_0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_CL49_RX_RF_ENABLEf_GET(r) ((((r).rx_x4_decode_control_0[0]) >> 4) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_CL49_RX_RF_ENABLEf_SET(r,f) (r).rx_x4_decode_control_0[0]=(((r).rx_x4_decode_control_0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_RESERVED1f_GET(r) ((((r).rx_x4_decode_control_0[0]) >> 3) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_RESERVED1f_SET(r,f) (r).rx_x4_decode_control_0[0]=(((r).rx_x4_decode_control_0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_BLOCK_SYNC_MODEf_GET(r) (((r).rx_x4_decode_control_0[0]) & 0x7)
#define BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_BLOCK_SYNC_MODEf_SET(r,f) (r).rx_x4_decode_control_0[0]=(((r).rx_x4_decode_control_0[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))

/*
 * These macros can be used to access RX_X4_DECODE_CONTROL_0.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X4_DECODE_CONTROL_0r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r,(_r._rx_x4_decode_control_0))
#define BCMI_TSC_XGXS_WRITE_RX_X4_DECODE_CONTROL_0r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r,(_r._rx_x4_decode_control_0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_DECODE_CONTROL_0r BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r
#define RX_X4_DECODE_CONTROL_0r_SIZE BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_SIZE
typedef BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_t RX_X4_DECODE_CONTROL_0r_t;
#define RX_X4_DECODE_CONTROL_0r_CLR BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_CLR
#define RX_X4_DECODE_CONTROL_0r_SET BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_SET
#define RX_X4_DECODE_CONTROL_0r_GET BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_GET
#define RX_X4_DECODE_CONTROL_0r_BYPASS_CL49RXSMf_GET BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_BYPASS_CL49RXSMf_GET
#define RX_X4_DECODE_CONTROL_0r_BYPASS_CL49RXSMf_SET BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_BYPASS_CL49RXSMf_SET
#define RX_X4_DECODE_CONTROL_0r_R_TEST_MODE_CFGf_GET BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_R_TEST_MODE_CFGf_GET
#define RX_X4_DECODE_CONTROL_0r_R_TEST_MODE_CFGf_SET BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_R_TEST_MODE_CFGf_SET
#define RX_X4_DECODE_CONTROL_0r_HG2_MESSAGE_INVALID_CODE_ENABLEf_GET BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_HG2_MESSAGE_INVALID_CODE_ENABLEf_GET
#define RX_X4_DECODE_CONTROL_0r_HG2_MESSAGE_INVALID_CODE_ENABLEf_SET BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_HG2_MESSAGE_INVALID_CODE_ENABLEf_SET
#define RX_X4_DECODE_CONTROL_0r_HG2_ENABLEf_GET BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_HG2_ENABLEf_GET
#define RX_X4_DECODE_CONTROL_0r_HG2_ENABLEf_SET BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_HG2_ENABLEf_SET
#define RX_X4_DECODE_CONTROL_0r_CL48_SYNCACQ_ENf_GET BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_CL48_SYNCACQ_ENf_GET
#define RX_X4_DECODE_CONTROL_0r_CL48_SYNCACQ_ENf_SET BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_CL48_SYNCACQ_ENf_SET
#define RX_X4_DECODE_CONTROL_0r_CL48_CGBAD_ENf_GET BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_CL48_CGBAD_ENf_GET
#define RX_X4_DECODE_CONTROL_0r_CL48_CGBAD_ENf_SET BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_CL48_CGBAD_ENf_SET
#define RX_X4_DECODE_CONTROL_0r_HG2_CODECf_GET BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_HG2_CODECf_GET
#define RX_X4_DECODE_CONTROL_0r_HG2_CODECf_SET BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_HG2_CODECf_SET
#define RX_X4_DECODE_CONTROL_0r_DISABLE_CL49_BERMONf_GET BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_DISABLE_CL49_BERMONf_GET
#define RX_X4_DECODE_CONTROL_0r_DISABLE_CL49_BERMONf_SET BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_DISABLE_CL49_BERMONf_SET
#define RX_X4_DECODE_CONTROL_0r_RESERVED0f_GET BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_RESERVED0f_GET
#define RX_X4_DECODE_CONTROL_0r_RESERVED0f_SET BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_RESERVED0f_SET
#define RX_X4_DECODE_CONTROL_0r_CL49_RX_LI_ENABLEf_GET BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_CL49_RX_LI_ENABLEf_GET
#define RX_X4_DECODE_CONTROL_0r_CL49_RX_LI_ENABLEf_SET BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_CL49_RX_LI_ENABLEf_SET
#define RX_X4_DECODE_CONTROL_0r_CL49_RX_LF_ENABLEf_GET BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_CL49_RX_LF_ENABLEf_GET
#define RX_X4_DECODE_CONTROL_0r_CL49_RX_LF_ENABLEf_SET BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_CL49_RX_LF_ENABLEf_SET
#define RX_X4_DECODE_CONTROL_0r_CL49_RX_RF_ENABLEf_GET BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_CL49_RX_RF_ENABLEf_GET
#define RX_X4_DECODE_CONTROL_0r_CL49_RX_RF_ENABLEf_SET BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_CL49_RX_RF_ENABLEf_SET
#define RX_X4_DECODE_CONTROL_0r_RESERVED1f_GET BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_RESERVED1f_GET
#define RX_X4_DECODE_CONTROL_0r_RESERVED1f_SET BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_RESERVED1f_SET
#define RX_X4_DECODE_CONTROL_0r_BLOCK_SYNC_MODEf_GET BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_BLOCK_SYNC_MODEf_GET
#define RX_X4_DECODE_CONTROL_0r_BLOCK_SYNC_MODEf_SET BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r_BLOCK_SYNC_MODEf_SET
#define READ_RX_X4_DECODE_CONTROL_0r BCMI_TSC_XGXS_READ_RX_X4_DECODE_CONTROL_0r
#define WRITE_RX_X4_DECODE_CONTROL_0r BCMI_TSC_XGXS_WRITE_RX_X4_DECODE_CONTROL_0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X4_DECODE_CONTROL_1
 * BLOCKS:   RX_X4_CONTROL0
 * REGADDR:  0xc135
 * DESC:     Decoder control 1 register: 00000000
 * SIZE:     32
 * FIELDS:
 *     B66DEC_CGBAD_EN  
 *     B66DEC_SYNCERRCOUNT_EN 
 *     B66DEC_KCODE66ERRCOUNT_EN 
 *     B66DEC_FAULT_DET_EN 
 *     B66DEC_PROG_TL_CHAR 
 *     B66DEC_PROG_TL_EN 
 *     B66DEC_NOBLOCKLOCK_DOUT_SEL 
 *     B66DEC_DOUT_ERRORS_IF_BAD_SYNC 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_1r (0x0000c135 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_DECODE_CONTROL_1.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_1r_s {
	uint32_t v[1];
	uint32_t rx_x4_decode_control_1[1];
	uint32_t _rx_x4_decode_control_1;
} BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_1r_t;

#define BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_1r_CLR(r) (r).rx_x4_decode_control_1[0] = 0
#define BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_1r_SET(r,d) (r).rx_x4_decode_control_1[0] = d
#define BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_1r_GET(r) (r).rx_x4_decode_control_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_1r_B66DEC_DOUT_ERRORS_IF_BAD_SYNCf_GET(r) ((((r).rx_x4_decode_control_1[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_1r_B66DEC_DOUT_ERRORS_IF_BAD_SYNCf_SET(r,f) (r).rx_x4_decode_control_1[0]=(((r).rx_x4_decode_control_1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_1r_B66DEC_NOBLOCKLOCK_DOUT_SELf_GET(r) ((((r).rx_x4_decode_control_1[0]) >> 13) & 0x3)
#define BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_1r_B66DEC_NOBLOCKLOCK_DOUT_SELf_SET(r,f) (r).rx_x4_decode_control_1[0]=(((r).rx_x4_decode_control_1[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13))
#define BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_1r_B66DEC_PROG_TL_ENf_GET(r) ((((r).rx_x4_decode_control_1[0]) >> 12) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_1r_B66DEC_PROG_TL_ENf_SET(r,f) (r).rx_x4_decode_control_1[0]=(((r).rx_x4_decode_control_1[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_1r_B66DEC_PROG_TL_CHARf_GET(r) ((((r).rx_x4_decode_control_1[0]) >> 4) & 0xff)
#define BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_1r_B66DEC_PROG_TL_CHARf_SET(r,f) (r).rx_x4_decode_control_1[0]=(((r).rx_x4_decode_control_1[0] & ~((uint32_t)0xff << 4)) | ((((uint32_t)f) & 0xff) << 4))
#define BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_1r_B66DEC_FAULT_DET_ENf_GET(r) ((((r).rx_x4_decode_control_1[0]) >> 3) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_1r_B66DEC_FAULT_DET_ENf_SET(r,f) (r).rx_x4_decode_control_1[0]=(((r).rx_x4_decode_control_1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_1r_B66DEC_KCODE66ERRCOUNT_ENf_GET(r) ((((r).rx_x4_decode_control_1[0]) >> 2) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_1r_B66DEC_KCODE66ERRCOUNT_ENf_SET(r,f) (r).rx_x4_decode_control_1[0]=(((r).rx_x4_decode_control_1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_1r_B66DEC_SYNCERRCOUNT_ENf_GET(r) ((((r).rx_x4_decode_control_1[0]) >> 1) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_1r_B66DEC_SYNCERRCOUNT_ENf_SET(r,f) (r).rx_x4_decode_control_1[0]=(((r).rx_x4_decode_control_1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_1r_B66DEC_CGBAD_ENf_GET(r) (((r).rx_x4_decode_control_1[0]) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_1r_B66DEC_CGBAD_ENf_SET(r,f) (r).rx_x4_decode_control_1[0]=(((r).rx_x4_decode_control_1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access RX_X4_DECODE_CONTROL_1.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X4_DECODE_CONTROL_1r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_1r,(_r._rx_x4_decode_control_1))
#define BCMI_TSC_XGXS_WRITE_RX_X4_DECODE_CONTROL_1r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_1r,(_r._rx_x4_decode_control_1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_DECODE_CONTROL_1r BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_1r
#define RX_X4_DECODE_CONTROL_1r_SIZE BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_1r_SIZE
typedef BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_1r_t RX_X4_DECODE_CONTROL_1r_t;
#define RX_X4_DECODE_CONTROL_1r_CLR BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_1r_CLR
#define RX_X4_DECODE_CONTROL_1r_SET BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_1r_SET
#define RX_X4_DECODE_CONTROL_1r_GET BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_1r_GET
#define RX_X4_DECODE_CONTROL_1r_B66DEC_DOUT_ERRORS_IF_BAD_SYNCf_GET BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_1r_B66DEC_DOUT_ERRORS_IF_BAD_SYNCf_GET
#define RX_X4_DECODE_CONTROL_1r_B66DEC_DOUT_ERRORS_IF_BAD_SYNCf_SET BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_1r_B66DEC_DOUT_ERRORS_IF_BAD_SYNCf_SET
#define RX_X4_DECODE_CONTROL_1r_B66DEC_NOBLOCKLOCK_DOUT_SELf_GET BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_1r_B66DEC_NOBLOCKLOCK_DOUT_SELf_GET
#define RX_X4_DECODE_CONTROL_1r_B66DEC_NOBLOCKLOCK_DOUT_SELf_SET BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_1r_B66DEC_NOBLOCKLOCK_DOUT_SELf_SET
#define RX_X4_DECODE_CONTROL_1r_B66DEC_PROG_TL_ENf_GET BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_1r_B66DEC_PROG_TL_ENf_GET
#define RX_X4_DECODE_CONTROL_1r_B66DEC_PROG_TL_ENf_SET BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_1r_B66DEC_PROG_TL_ENf_SET
#define RX_X4_DECODE_CONTROL_1r_B66DEC_PROG_TL_CHARf_GET BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_1r_B66DEC_PROG_TL_CHARf_GET
#define RX_X4_DECODE_CONTROL_1r_B66DEC_PROG_TL_CHARf_SET BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_1r_B66DEC_PROG_TL_CHARf_SET
#define RX_X4_DECODE_CONTROL_1r_B66DEC_FAULT_DET_ENf_GET BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_1r_B66DEC_FAULT_DET_ENf_GET
#define RX_X4_DECODE_CONTROL_1r_B66DEC_FAULT_DET_ENf_SET BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_1r_B66DEC_FAULT_DET_ENf_SET
#define RX_X4_DECODE_CONTROL_1r_B66DEC_KCODE66ERRCOUNT_ENf_GET BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_1r_B66DEC_KCODE66ERRCOUNT_ENf_GET
#define RX_X4_DECODE_CONTROL_1r_B66DEC_KCODE66ERRCOUNT_ENf_SET BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_1r_B66DEC_KCODE66ERRCOUNT_ENf_SET
#define RX_X4_DECODE_CONTROL_1r_B66DEC_SYNCERRCOUNT_ENf_GET BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_1r_B66DEC_SYNCERRCOUNT_ENf_GET
#define RX_X4_DECODE_CONTROL_1r_B66DEC_SYNCERRCOUNT_ENf_SET BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_1r_B66DEC_SYNCERRCOUNT_ENf_SET
#define RX_X4_DECODE_CONTROL_1r_B66DEC_CGBAD_ENf_GET BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_1r_B66DEC_CGBAD_ENf_GET
#define RX_X4_DECODE_CONTROL_1r_B66DEC_CGBAD_ENf_SET BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_1r_B66DEC_CGBAD_ENf_SET
#define READ_RX_X4_DECODE_CONTROL_1r BCMI_TSC_XGXS_READ_RX_X4_DECODE_CONTROL_1r
#define WRITE_RX_X4_DECODE_CONTROL_1r BCMI_TSC_XGXS_WRITE_RX_X4_DECODE_CONTROL_1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X4_DECODE_CONTROL_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X4_CL36_RX_0
 * BLOCKS:   RX_X4_CONTROL0
 * REGADDR:  0xc136
 * DESC:     cl36_rx_0 register: 00000000
 * SIZE:     32
 * FIELDS:
 *     CL36_EN          
 *     REORDER_EN       
 *     DISABLE_CARRIER_EXTEND 
 *     CL36_FORCE_COMMA_ALIGN_ENABLE 
 *     RESERVED1        
 *     CL36_BER_EN      
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X4_CL36_RX_0r (0x0000c136 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X4_CL36_RX_0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_CL36_RX_0.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X4_CL36_RX_0r_s {
	uint32_t v[1];
	uint32_t rx_x4_cl36_rx_0[1];
	uint32_t _rx_x4_cl36_rx_0;
} BCMI_TSC_XGXS_RX_X4_CL36_RX_0r_t;

#define BCMI_TSC_XGXS_RX_X4_CL36_RX_0r_CLR(r) (r).rx_x4_cl36_rx_0[0] = 0
#define BCMI_TSC_XGXS_RX_X4_CL36_RX_0r_SET(r,d) (r).rx_x4_cl36_rx_0[0] = d
#define BCMI_TSC_XGXS_RX_X4_CL36_RX_0r_GET(r) (r).rx_x4_cl36_rx_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X4_CL36_RX_0r_RESERVED0f_GET(r) ((((r).rx_x4_cl36_rx_0[0]) >> 6) & 0x3ff)
#define BCMI_TSC_XGXS_RX_X4_CL36_RX_0r_RESERVED0f_SET(r,f) (r).rx_x4_cl36_rx_0[0]=(((r).rx_x4_cl36_rx_0[0] & ~((uint32_t)0x3ff << 6)) | ((((uint32_t)f) & 0x3ff) << 6))
#define BCMI_TSC_XGXS_RX_X4_CL36_RX_0r_CL36_BER_ENf_GET(r) ((((r).rx_x4_cl36_rx_0[0]) >> 5) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_CL36_RX_0r_CL36_BER_ENf_SET(r,f) (r).rx_x4_cl36_rx_0[0]=(((r).rx_x4_cl36_rx_0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCMI_TSC_XGXS_RX_X4_CL36_RX_0r_RESERVED1f_GET(r) ((((r).rx_x4_cl36_rx_0[0]) >> 4) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_CL36_RX_0r_RESERVED1f_SET(r,f) (r).rx_x4_cl36_rx_0[0]=(((r).rx_x4_cl36_rx_0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCMI_TSC_XGXS_RX_X4_CL36_RX_0r_CL36_FORCE_COMMA_ALIGN_ENABLEf_GET(r) ((((r).rx_x4_cl36_rx_0[0]) >> 3) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_CL36_RX_0r_CL36_FORCE_COMMA_ALIGN_ENABLEf_SET(r,f) (r).rx_x4_cl36_rx_0[0]=(((r).rx_x4_cl36_rx_0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCMI_TSC_XGXS_RX_X4_CL36_RX_0r_DISABLE_CARRIER_EXTENDf_GET(r) ((((r).rx_x4_cl36_rx_0[0]) >> 2) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_CL36_RX_0r_DISABLE_CARRIER_EXTENDf_SET(r,f) (r).rx_x4_cl36_rx_0[0]=(((r).rx_x4_cl36_rx_0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCMI_TSC_XGXS_RX_X4_CL36_RX_0r_REORDER_ENf_GET(r) ((((r).rx_x4_cl36_rx_0[0]) >> 1) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_CL36_RX_0r_REORDER_ENf_SET(r,f) (r).rx_x4_cl36_rx_0[0]=(((r).rx_x4_cl36_rx_0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCMI_TSC_XGXS_RX_X4_CL36_RX_0r_CL36_ENf_GET(r) (((r).rx_x4_cl36_rx_0[0]) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_CL36_RX_0r_CL36_ENf_SET(r,f) (r).rx_x4_cl36_rx_0[0]=(((r).rx_x4_cl36_rx_0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access RX_X4_CL36_RX_0.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X4_CL36_RX_0r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X4_CL36_RX_0r,(_r._rx_x4_cl36_rx_0))
#define BCMI_TSC_XGXS_WRITE_RX_X4_CL36_RX_0r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X4_CL36_RX_0r,(_r._rx_x4_cl36_rx_0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_CL36_RX_0r BCMI_TSC_XGXS_RX_X4_CL36_RX_0r
#define RX_X4_CL36_RX_0r_SIZE BCMI_TSC_XGXS_RX_X4_CL36_RX_0r_SIZE
typedef BCMI_TSC_XGXS_RX_X4_CL36_RX_0r_t RX_X4_CL36_RX_0r_t;
#define RX_X4_CL36_RX_0r_CLR BCMI_TSC_XGXS_RX_X4_CL36_RX_0r_CLR
#define RX_X4_CL36_RX_0r_SET BCMI_TSC_XGXS_RX_X4_CL36_RX_0r_SET
#define RX_X4_CL36_RX_0r_GET BCMI_TSC_XGXS_RX_X4_CL36_RX_0r_GET
#define RX_X4_CL36_RX_0r_RESERVED0f_GET BCMI_TSC_XGXS_RX_X4_CL36_RX_0r_RESERVED0f_GET
#define RX_X4_CL36_RX_0r_RESERVED0f_SET BCMI_TSC_XGXS_RX_X4_CL36_RX_0r_RESERVED0f_SET
#define RX_X4_CL36_RX_0r_CL36_BER_ENf_GET BCMI_TSC_XGXS_RX_X4_CL36_RX_0r_CL36_BER_ENf_GET
#define RX_X4_CL36_RX_0r_CL36_BER_ENf_SET BCMI_TSC_XGXS_RX_X4_CL36_RX_0r_CL36_BER_ENf_SET
#define RX_X4_CL36_RX_0r_RESERVED1f_GET BCMI_TSC_XGXS_RX_X4_CL36_RX_0r_RESERVED1f_GET
#define RX_X4_CL36_RX_0r_RESERVED1f_SET BCMI_TSC_XGXS_RX_X4_CL36_RX_0r_RESERVED1f_SET
#define RX_X4_CL36_RX_0r_CL36_FORCE_COMMA_ALIGN_ENABLEf_GET BCMI_TSC_XGXS_RX_X4_CL36_RX_0r_CL36_FORCE_COMMA_ALIGN_ENABLEf_GET
#define RX_X4_CL36_RX_0r_CL36_FORCE_COMMA_ALIGN_ENABLEf_SET BCMI_TSC_XGXS_RX_X4_CL36_RX_0r_CL36_FORCE_COMMA_ALIGN_ENABLEf_SET
#define RX_X4_CL36_RX_0r_DISABLE_CARRIER_EXTENDf_GET BCMI_TSC_XGXS_RX_X4_CL36_RX_0r_DISABLE_CARRIER_EXTENDf_GET
#define RX_X4_CL36_RX_0r_DISABLE_CARRIER_EXTENDf_SET BCMI_TSC_XGXS_RX_X4_CL36_RX_0r_DISABLE_CARRIER_EXTENDf_SET
#define RX_X4_CL36_RX_0r_REORDER_ENf_GET BCMI_TSC_XGXS_RX_X4_CL36_RX_0r_REORDER_ENf_GET
#define RX_X4_CL36_RX_0r_REORDER_ENf_SET BCMI_TSC_XGXS_RX_X4_CL36_RX_0r_REORDER_ENf_SET
#define RX_X4_CL36_RX_0r_CL36_ENf_GET BCMI_TSC_XGXS_RX_X4_CL36_RX_0r_CL36_ENf_GET
#define RX_X4_CL36_RX_0r_CL36_ENf_SET BCMI_TSC_XGXS_RX_X4_CL36_RX_0r_CL36_ENf_SET
#define READ_RX_X4_CL36_RX_0r BCMI_TSC_XGXS_READ_RX_X4_CL36_RX_0r
#define WRITE_RX_X4_CL36_RX_0r BCMI_TSC_XGXS_WRITE_RX_X4_CL36_RX_0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X4_CL36_RX_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X4_PMA_CONTROL_0
 * BLOCKS:   RX_X4_CONTROL0
 * REGADDR:  0xc137
 * DESC:     pma_control_0 register: 00000000
 * SIZE:     32
 * FIELDS:
 *     RSTB_LANE        
 *     RX_GBOX_AFRST_EN 
 *     RESERVED1        
 *     OS_MODE          
 *     OVERRIDE_OS_MODE 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X4_PMA_CONTROL_0r (0x0000c137 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X4_PMA_CONTROL_0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_PMA_CONTROL_0.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X4_PMA_CONTROL_0r_s {
	uint32_t v[1];
	uint32_t rx_x4_pma_control_0[1];
	uint32_t _rx_x4_pma_control_0;
} BCMI_TSC_XGXS_RX_X4_PMA_CONTROL_0r_t;

#define BCMI_TSC_XGXS_RX_X4_PMA_CONTROL_0r_CLR(r) (r).rx_x4_pma_control_0[0] = 0
#define BCMI_TSC_XGXS_RX_X4_PMA_CONTROL_0r_SET(r,d) (r).rx_x4_pma_control_0[0] = d
#define BCMI_TSC_XGXS_RX_X4_PMA_CONTROL_0r_GET(r) (r).rx_x4_pma_control_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X4_PMA_CONTROL_0r_RESERVED0f_GET(r) ((((r).rx_x4_pma_control_0[0]) >> 8) & 0xff)
#define BCMI_TSC_XGXS_RX_X4_PMA_CONTROL_0r_RESERVED0f_SET(r,f) (r).rx_x4_pma_control_0[0]=(((r).rx_x4_pma_control_0[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCMI_TSC_XGXS_RX_X4_PMA_CONTROL_0r_OVERRIDE_OS_MODEf_GET(r) ((((r).rx_x4_pma_control_0[0]) >> 7) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_PMA_CONTROL_0r_OVERRIDE_OS_MODEf_SET(r,f) (r).rx_x4_pma_control_0[0]=(((r).rx_x4_pma_control_0[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCMI_TSC_XGXS_RX_X4_PMA_CONTROL_0r_OS_MODEf_GET(r) ((((r).rx_x4_pma_control_0[0]) >> 3) & 0xf)
#define BCMI_TSC_XGXS_RX_X4_PMA_CONTROL_0r_OS_MODEf_SET(r,f) (r).rx_x4_pma_control_0[0]=(((r).rx_x4_pma_control_0[0] & ~((uint32_t)0xf << 3)) | ((((uint32_t)f) & 0xf) << 3))
#define BCMI_TSC_XGXS_RX_X4_PMA_CONTROL_0r_RESERVED1f_GET(r) ((((r).rx_x4_pma_control_0[0]) >> 2) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_PMA_CONTROL_0r_RESERVED1f_SET(r,f) (r).rx_x4_pma_control_0[0]=(((r).rx_x4_pma_control_0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCMI_TSC_XGXS_RX_X4_PMA_CONTROL_0r_RX_GBOX_AFRST_ENf_GET(r) ((((r).rx_x4_pma_control_0[0]) >> 1) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_PMA_CONTROL_0r_RX_GBOX_AFRST_ENf_SET(r,f) (r).rx_x4_pma_control_0[0]=(((r).rx_x4_pma_control_0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCMI_TSC_XGXS_RX_X4_PMA_CONTROL_0r_RSTB_LANEf_GET(r) (((r).rx_x4_pma_control_0[0]) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_PMA_CONTROL_0r_RSTB_LANEf_SET(r,f) (r).rx_x4_pma_control_0[0]=(((r).rx_x4_pma_control_0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access RX_X4_PMA_CONTROL_0.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X4_PMA_CONTROL_0r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X4_PMA_CONTROL_0r,(_r._rx_x4_pma_control_0))
#define BCMI_TSC_XGXS_WRITE_RX_X4_PMA_CONTROL_0r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X4_PMA_CONTROL_0r,(_r._rx_x4_pma_control_0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_PMA_CONTROL_0r BCMI_TSC_XGXS_RX_X4_PMA_CONTROL_0r
#define RX_X4_PMA_CONTROL_0r_SIZE BCMI_TSC_XGXS_RX_X4_PMA_CONTROL_0r_SIZE
typedef BCMI_TSC_XGXS_RX_X4_PMA_CONTROL_0r_t RX_X4_PMA_CONTROL_0r_t;
#define RX_X4_PMA_CONTROL_0r_CLR BCMI_TSC_XGXS_RX_X4_PMA_CONTROL_0r_CLR
#define RX_X4_PMA_CONTROL_0r_SET BCMI_TSC_XGXS_RX_X4_PMA_CONTROL_0r_SET
#define RX_X4_PMA_CONTROL_0r_GET BCMI_TSC_XGXS_RX_X4_PMA_CONTROL_0r_GET
#define RX_X4_PMA_CONTROL_0r_RESERVED0f_GET BCMI_TSC_XGXS_RX_X4_PMA_CONTROL_0r_RESERVED0f_GET
#define RX_X4_PMA_CONTROL_0r_RESERVED0f_SET BCMI_TSC_XGXS_RX_X4_PMA_CONTROL_0r_RESERVED0f_SET
#define RX_X4_PMA_CONTROL_0r_OVERRIDE_OS_MODEf_GET BCMI_TSC_XGXS_RX_X4_PMA_CONTROL_0r_OVERRIDE_OS_MODEf_GET
#define RX_X4_PMA_CONTROL_0r_OVERRIDE_OS_MODEf_SET BCMI_TSC_XGXS_RX_X4_PMA_CONTROL_0r_OVERRIDE_OS_MODEf_SET
#define RX_X4_PMA_CONTROL_0r_OS_MODEf_GET BCMI_TSC_XGXS_RX_X4_PMA_CONTROL_0r_OS_MODEf_GET
#define RX_X4_PMA_CONTROL_0r_OS_MODEf_SET BCMI_TSC_XGXS_RX_X4_PMA_CONTROL_0r_OS_MODEf_SET
#define RX_X4_PMA_CONTROL_0r_RESERVED1f_GET BCMI_TSC_XGXS_RX_X4_PMA_CONTROL_0r_RESERVED1f_GET
#define RX_X4_PMA_CONTROL_0r_RESERVED1f_SET BCMI_TSC_XGXS_RX_X4_PMA_CONTROL_0r_RESERVED1f_SET
#define RX_X4_PMA_CONTROL_0r_RX_GBOX_AFRST_ENf_GET BCMI_TSC_XGXS_RX_X4_PMA_CONTROL_0r_RX_GBOX_AFRST_ENf_GET
#define RX_X4_PMA_CONTROL_0r_RX_GBOX_AFRST_ENf_SET BCMI_TSC_XGXS_RX_X4_PMA_CONTROL_0r_RX_GBOX_AFRST_ENf_SET
#define RX_X4_PMA_CONTROL_0r_RSTB_LANEf_GET BCMI_TSC_XGXS_RX_X4_PMA_CONTROL_0r_RSTB_LANEf_GET
#define RX_X4_PMA_CONTROL_0r_RSTB_LANEf_SET BCMI_TSC_XGXS_RX_X4_PMA_CONTROL_0r_RSTB_LANEf_SET
#define READ_RX_X4_PMA_CONTROL_0r BCMI_TSC_XGXS_READ_RX_X4_PMA_CONTROL_0r
#define WRITE_RX_X4_PMA_CONTROL_0r BCMI_TSC_XGXS_WRITE_RX_X4_PMA_CONTROL_0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X4_PMA_CONTROL_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X4_RX_SIGDET
 * BLOCKS:   RX_X4_CONTROL0
 * REGADDR:  0xc138
 * DESC:     Rx Sigdet Control: 00000000
 * SIZE:     32
 * FIELDS:
 *     ENABLE_AFE_SIGNAL_DETECT_FILTERING 
 *     OVERRIDE_VALUE_SIGNAL_OK 
 *     OVERRIDE_SIGNAL_OK 
 *     AFE_SIGNAL_DETECT_ENABLE 
 *     EXTERNAL_SIGNAL_DETECT_ENABLE 
 *     AFE_SIGNAL_DETECT_INVERT 
 *     EXTERNAL_SIGNAL_DETECT_INVERT 
 *     ENABLE_AN_SIGNAL_DETECT_FILTER_SEL 
 *     USE_CX4_SIGNAL_DETECT_FILTER_SEL 
 *     ENABLE_EXT_SIGNAL_DETECT_FILTERING 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X4_RX_SIGDETr (0x0000c138 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X4_RX_SIGDETr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_RX_SIGDET.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X4_RX_SIGDETr_s {
	uint32_t v[1];
	uint32_t rx_x4_rx_sigdet[1];
	uint32_t _rx_x4_rx_sigdet;
} BCMI_TSC_XGXS_RX_X4_RX_SIGDETr_t;

#define BCMI_TSC_XGXS_RX_X4_RX_SIGDETr_CLR(r) (r).rx_x4_rx_sigdet[0] = 0
#define BCMI_TSC_XGXS_RX_X4_RX_SIGDETr_SET(r,d) (r).rx_x4_rx_sigdet[0] = d
#define BCMI_TSC_XGXS_RX_X4_RX_SIGDETr_GET(r) (r).rx_x4_rx_sigdet[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X4_RX_SIGDETr_RESERVED0f_GET(r) ((((r).rx_x4_rx_sigdet[0]) >> 10) & 0x3f)
#define BCMI_TSC_XGXS_RX_X4_RX_SIGDETr_RESERVED0f_SET(r,f) (r).rx_x4_rx_sigdet[0]=(((r).rx_x4_rx_sigdet[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))
#define BCMI_TSC_XGXS_RX_X4_RX_SIGDETr_ENABLE_EXT_SIGNAL_DETECT_FILTERINGf_GET(r) ((((r).rx_x4_rx_sigdet[0]) >> 9) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_RX_SIGDETr_ENABLE_EXT_SIGNAL_DETECT_FILTERINGf_SET(r,f) (r).rx_x4_rx_sigdet[0]=(((r).rx_x4_rx_sigdet[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCMI_TSC_XGXS_RX_X4_RX_SIGDETr_USE_CX4_SIGNAL_DETECT_FILTER_SELf_GET(r) ((((r).rx_x4_rx_sigdet[0]) >> 8) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_RX_SIGDETr_USE_CX4_SIGNAL_DETECT_FILTER_SELf_SET(r,f) (r).rx_x4_rx_sigdet[0]=(((r).rx_x4_rx_sigdet[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCMI_TSC_XGXS_RX_X4_RX_SIGDETr_ENABLE_AN_SIGNAL_DETECT_FILTER_SELf_GET(r) ((((r).rx_x4_rx_sigdet[0]) >> 7) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_RX_SIGDETr_ENABLE_AN_SIGNAL_DETECT_FILTER_SELf_SET(r,f) (r).rx_x4_rx_sigdet[0]=(((r).rx_x4_rx_sigdet[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCMI_TSC_XGXS_RX_X4_RX_SIGDETr_EXTERNAL_SIGNAL_DETECT_INVERTf_GET(r) ((((r).rx_x4_rx_sigdet[0]) >> 6) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_RX_SIGDETr_EXTERNAL_SIGNAL_DETECT_INVERTf_SET(r,f) (r).rx_x4_rx_sigdet[0]=(((r).rx_x4_rx_sigdet[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCMI_TSC_XGXS_RX_X4_RX_SIGDETr_AFE_SIGNAL_DETECT_INVERTf_GET(r) ((((r).rx_x4_rx_sigdet[0]) >> 5) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_RX_SIGDETr_AFE_SIGNAL_DETECT_INVERTf_SET(r,f) (r).rx_x4_rx_sigdet[0]=(((r).rx_x4_rx_sigdet[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCMI_TSC_XGXS_RX_X4_RX_SIGDETr_EXTERNAL_SIGNAL_DETECT_ENABLEf_GET(r) ((((r).rx_x4_rx_sigdet[0]) >> 4) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_RX_SIGDETr_EXTERNAL_SIGNAL_DETECT_ENABLEf_SET(r,f) (r).rx_x4_rx_sigdet[0]=(((r).rx_x4_rx_sigdet[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCMI_TSC_XGXS_RX_X4_RX_SIGDETr_AFE_SIGNAL_DETECT_ENABLEf_GET(r) ((((r).rx_x4_rx_sigdet[0]) >> 3) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_RX_SIGDETr_AFE_SIGNAL_DETECT_ENABLEf_SET(r,f) (r).rx_x4_rx_sigdet[0]=(((r).rx_x4_rx_sigdet[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCMI_TSC_XGXS_RX_X4_RX_SIGDETr_OVERRIDE_SIGNAL_OKf_GET(r) ((((r).rx_x4_rx_sigdet[0]) >> 2) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_RX_SIGDETr_OVERRIDE_SIGNAL_OKf_SET(r,f) (r).rx_x4_rx_sigdet[0]=(((r).rx_x4_rx_sigdet[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCMI_TSC_XGXS_RX_X4_RX_SIGDETr_OVERRIDE_VALUE_SIGNAL_OKf_GET(r) ((((r).rx_x4_rx_sigdet[0]) >> 1) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_RX_SIGDETr_OVERRIDE_VALUE_SIGNAL_OKf_SET(r,f) (r).rx_x4_rx_sigdet[0]=(((r).rx_x4_rx_sigdet[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCMI_TSC_XGXS_RX_X4_RX_SIGDETr_ENABLE_AFE_SIGNAL_DETECT_FILTERINGf_GET(r) (((r).rx_x4_rx_sigdet[0]) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_RX_SIGDETr_ENABLE_AFE_SIGNAL_DETECT_FILTERINGf_SET(r,f) (r).rx_x4_rx_sigdet[0]=(((r).rx_x4_rx_sigdet[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access RX_X4_RX_SIGDET.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X4_RX_SIGDETr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X4_RX_SIGDETr,(_r._rx_x4_rx_sigdet))
#define BCMI_TSC_XGXS_WRITE_RX_X4_RX_SIGDETr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X4_RX_SIGDETr,(_r._rx_x4_rx_sigdet))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_RX_SIGDETr BCMI_TSC_XGXS_RX_X4_RX_SIGDETr
#define RX_X4_RX_SIGDETr_SIZE BCMI_TSC_XGXS_RX_X4_RX_SIGDETr_SIZE
typedef BCMI_TSC_XGXS_RX_X4_RX_SIGDETr_t RX_X4_RX_SIGDETr_t;
#define RX_X4_RX_SIGDETr_CLR BCMI_TSC_XGXS_RX_X4_RX_SIGDETr_CLR
#define RX_X4_RX_SIGDETr_SET BCMI_TSC_XGXS_RX_X4_RX_SIGDETr_SET
#define RX_X4_RX_SIGDETr_GET BCMI_TSC_XGXS_RX_X4_RX_SIGDETr_GET
#define RX_X4_RX_SIGDETr_RESERVED0f_GET BCMI_TSC_XGXS_RX_X4_RX_SIGDETr_RESERVED0f_GET
#define RX_X4_RX_SIGDETr_RESERVED0f_SET BCMI_TSC_XGXS_RX_X4_RX_SIGDETr_RESERVED0f_SET
#define RX_X4_RX_SIGDETr_ENABLE_EXT_SIGNAL_DETECT_FILTERINGf_GET BCMI_TSC_XGXS_RX_X4_RX_SIGDETr_ENABLE_EXT_SIGNAL_DETECT_FILTERINGf_GET
#define RX_X4_RX_SIGDETr_ENABLE_EXT_SIGNAL_DETECT_FILTERINGf_SET BCMI_TSC_XGXS_RX_X4_RX_SIGDETr_ENABLE_EXT_SIGNAL_DETECT_FILTERINGf_SET
#define RX_X4_RX_SIGDETr_USE_CX4_SIGNAL_DETECT_FILTER_SELf_GET BCMI_TSC_XGXS_RX_X4_RX_SIGDETr_USE_CX4_SIGNAL_DETECT_FILTER_SELf_GET
#define RX_X4_RX_SIGDETr_USE_CX4_SIGNAL_DETECT_FILTER_SELf_SET BCMI_TSC_XGXS_RX_X4_RX_SIGDETr_USE_CX4_SIGNAL_DETECT_FILTER_SELf_SET
#define RX_X4_RX_SIGDETr_ENABLE_AN_SIGNAL_DETECT_FILTER_SELf_GET BCMI_TSC_XGXS_RX_X4_RX_SIGDETr_ENABLE_AN_SIGNAL_DETECT_FILTER_SELf_GET
#define RX_X4_RX_SIGDETr_ENABLE_AN_SIGNAL_DETECT_FILTER_SELf_SET BCMI_TSC_XGXS_RX_X4_RX_SIGDETr_ENABLE_AN_SIGNAL_DETECT_FILTER_SELf_SET
#define RX_X4_RX_SIGDETr_EXTERNAL_SIGNAL_DETECT_INVERTf_GET BCMI_TSC_XGXS_RX_X4_RX_SIGDETr_EXTERNAL_SIGNAL_DETECT_INVERTf_GET
#define RX_X4_RX_SIGDETr_EXTERNAL_SIGNAL_DETECT_INVERTf_SET BCMI_TSC_XGXS_RX_X4_RX_SIGDETr_EXTERNAL_SIGNAL_DETECT_INVERTf_SET
#define RX_X4_RX_SIGDETr_AFE_SIGNAL_DETECT_INVERTf_GET BCMI_TSC_XGXS_RX_X4_RX_SIGDETr_AFE_SIGNAL_DETECT_INVERTf_GET
#define RX_X4_RX_SIGDETr_AFE_SIGNAL_DETECT_INVERTf_SET BCMI_TSC_XGXS_RX_X4_RX_SIGDETr_AFE_SIGNAL_DETECT_INVERTf_SET
#define RX_X4_RX_SIGDETr_EXTERNAL_SIGNAL_DETECT_ENABLEf_GET BCMI_TSC_XGXS_RX_X4_RX_SIGDETr_EXTERNAL_SIGNAL_DETECT_ENABLEf_GET
#define RX_X4_RX_SIGDETr_EXTERNAL_SIGNAL_DETECT_ENABLEf_SET BCMI_TSC_XGXS_RX_X4_RX_SIGDETr_EXTERNAL_SIGNAL_DETECT_ENABLEf_SET
#define RX_X4_RX_SIGDETr_AFE_SIGNAL_DETECT_ENABLEf_GET BCMI_TSC_XGXS_RX_X4_RX_SIGDETr_AFE_SIGNAL_DETECT_ENABLEf_GET
#define RX_X4_RX_SIGDETr_AFE_SIGNAL_DETECT_ENABLEf_SET BCMI_TSC_XGXS_RX_X4_RX_SIGDETr_AFE_SIGNAL_DETECT_ENABLEf_SET
#define RX_X4_RX_SIGDETr_OVERRIDE_SIGNAL_OKf_GET BCMI_TSC_XGXS_RX_X4_RX_SIGDETr_OVERRIDE_SIGNAL_OKf_GET
#define RX_X4_RX_SIGDETr_OVERRIDE_SIGNAL_OKf_SET BCMI_TSC_XGXS_RX_X4_RX_SIGDETr_OVERRIDE_SIGNAL_OKf_SET
#define RX_X4_RX_SIGDETr_OVERRIDE_VALUE_SIGNAL_OKf_GET BCMI_TSC_XGXS_RX_X4_RX_SIGDETr_OVERRIDE_VALUE_SIGNAL_OKf_GET
#define RX_X4_RX_SIGDETr_OVERRIDE_VALUE_SIGNAL_OKf_SET BCMI_TSC_XGXS_RX_X4_RX_SIGDETr_OVERRIDE_VALUE_SIGNAL_OKf_SET
#define RX_X4_RX_SIGDETr_ENABLE_AFE_SIGNAL_DETECT_FILTERINGf_GET BCMI_TSC_XGXS_RX_X4_RX_SIGDETr_ENABLE_AFE_SIGNAL_DETECT_FILTERINGf_GET
#define RX_X4_RX_SIGDETr_ENABLE_AFE_SIGNAL_DETECT_FILTERINGf_SET BCMI_TSC_XGXS_RX_X4_RX_SIGDETr_ENABLE_AFE_SIGNAL_DETECT_FILTERINGf_SET
#define READ_RX_X4_RX_SIGDETr BCMI_TSC_XGXS_READ_RX_X4_RX_SIGDETr
#define WRITE_RX_X4_RX_SIGDETr BCMI_TSC_XGXS_WRITE_RX_X4_RX_SIGDETr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X4_RX_SIGDETr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X4_LINK_CONTROL
 * BLOCKS:   RX_X4_CONTROL0
 * REGADDR:  0xc139
 * DESC:     Link status control: 00000000
 * SIZE:     32
 * FIELDS:
 *     LATCH_LINKDOWN_ENABLE 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X4_LINK_CONTROLr (0x0000c139 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X4_LINK_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_LINK_CONTROL.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X4_LINK_CONTROLr_s {
	uint32_t v[1];
	uint32_t rx_x4_link_control[1];
	uint32_t _rx_x4_link_control;
} BCMI_TSC_XGXS_RX_X4_LINK_CONTROLr_t;

#define BCMI_TSC_XGXS_RX_X4_LINK_CONTROLr_CLR(r) (r).rx_x4_link_control[0] = 0
#define BCMI_TSC_XGXS_RX_X4_LINK_CONTROLr_SET(r,d) (r).rx_x4_link_control[0] = d
#define BCMI_TSC_XGXS_RX_X4_LINK_CONTROLr_GET(r) (r).rx_x4_link_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X4_LINK_CONTROLr_RESERVED0f_GET(r) ((((r).rx_x4_link_control[0]) >> 1) & 0x7fff)
#define BCMI_TSC_XGXS_RX_X4_LINK_CONTROLr_RESERVED0f_SET(r,f) (r).rx_x4_link_control[0]=(((r).rx_x4_link_control[0] & ~((uint32_t)0x7fff << 1)) | ((((uint32_t)f) & 0x7fff) << 1))
#define BCMI_TSC_XGXS_RX_X4_LINK_CONTROLr_LATCH_LINKDOWN_ENABLEf_GET(r) (((r).rx_x4_link_control[0]) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_LINK_CONTROLr_LATCH_LINKDOWN_ENABLEf_SET(r,f) (r).rx_x4_link_control[0]=(((r).rx_x4_link_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access RX_X4_LINK_CONTROL.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X4_LINK_CONTROLr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X4_LINK_CONTROLr,(_r._rx_x4_link_control))
#define BCMI_TSC_XGXS_WRITE_RX_X4_LINK_CONTROLr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X4_LINK_CONTROLr,(_r._rx_x4_link_control))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_LINK_CONTROLr BCMI_TSC_XGXS_RX_X4_LINK_CONTROLr
#define RX_X4_LINK_CONTROLr_SIZE BCMI_TSC_XGXS_RX_X4_LINK_CONTROLr_SIZE
typedef BCMI_TSC_XGXS_RX_X4_LINK_CONTROLr_t RX_X4_LINK_CONTROLr_t;
#define RX_X4_LINK_CONTROLr_CLR BCMI_TSC_XGXS_RX_X4_LINK_CONTROLr_CLR
#define RX_X4_LINK_CONTROLr_SET BCMI_TSC_XGXS_RX_X4_LINK_CONTROLr_SET
#define RX_X4_LINK_CONTROLr_GET BCMI_TSC_XGXS_RX_X4_LINK_CONTROLr_GET
#define RX_X4_LINK_CONTROLr_RESERVED0f_GET BCMI_TSC_XGXS_RX_X4_LINK_CONTROLr_RESERVED0f_GET
#define RX_X4_LINK_CONTROLr_RESERVED0f_SET BCMI_TSC_XGXS_RX_X4_LINK_CONTROLr_RESERVED0f_SET
#define RX_X4_LINK_CONTROLr_LATCH_LINKDOWN_ENABLEf_GET BCMI_TSC_XGXS_RX_X4_LINK_CONTROLr_LATCH_LINKDOWN_ENABLEf_GET
#define RX_X4_LINK_CONTROLr_LATCH_LINKDOWN_ENABLEf_SET BCMI_TSC_XGXS_RX_X4_LINK_CONTROLr_LATCH_LINKDOWN_ENABLEf_SET
#define READ_RX_X4_LINK_CONTROLr BCMI_TSC_XGXS_READ_RX_X4_LINK_CONTROLr
#define WRITE_RX_X4_LINK_CONTROLr BCMI_TSC_XGXS_WRITE_RX_X4_LINK_CONTROLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X4_LINK_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X4_FEC_DBG_ERRL
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc140
 * DESC:     "User FEC debug read data [15:0]": 00000000
 * SIZE:     32
 * FIELDS:
 *     DBG_ERRL         
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X4_FEC_DBG_ERRLr (0x0000c140 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X4_FEC_DBG_ERRLr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_DBG_ERRL.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X4_FEC_DBG_ERRLr_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_dbg_errl[1];
	uint32_t _rx_x4_fec_dbg_errl;
} BCMI_TSC_XGXS_RX_X4_FEC_DBG_ERRLr_t;

#define BCMI_TSC_XGXS_RX_X4_FEC_DBG_ERRLr_CLR(r) (r).rx_x4_fec_dbg_errl[0] = 0
#define BCMI_TSC_XGXS_RX_X4_FEC_DBG_ERRLr_SET(r,d) (r).rx_x4_fec_dbg_errl[0] = d
#define BCMI_TSC_XGXS_RX_X4_FEC_DBG_ERRLr_GET(r) (r).rx_x4_fec_dbg_errl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X4_FEC_DBG_ERRLr_DBG_ERRLf_GET(r) (((r).rx_x4_fec_dbg_errl[0]) & 0xffff)
#define BCMI_TSC_XGXS_RX_X4_FEC_DBG_ERRLr_DBG_ERRLf_SET(r,f) (r).rx_x4_fec_dbg_errl[0]=(((r).rx_x4_fec_dbg_errl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access RX_X4_FEC_DBG_ERRL.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X4_FEC_DBG_ERRLr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X4_FEC_DBG_ERRLr,(_r._rx_x4_fec_dbg_errl))
#define BCMI_TSC_XGXS_WRITE_RX_X4_FEC_DBG_ERRLr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X4_FEC_DBG_ERRLr,(_r._rx_x4_fec_dbg_errl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_DBG_ERRLr BCMI_TSC_XGXS_RX_X4_FEC_DBG_ERRLr
#define RX_X4_FEC_DBG_ERRLr_SIZE BCMI_TSC_XGXS_RX_X4_FEC_DBG_ERRLr_SIZE
typedef BCMI_TSC_XGXS_RX_X4_FEC_DBG_ERRLr_t RX_X4_FEC_DBG_ERRLr_t;
#define RX_X4_FEC_DBG_ERRLr_CLR BCMI_TSC_XGXS_RX_X4_FEC_DBG_ERRLr_CLR
#define RX_X4_FEC_DBG_ERRLr_SET BCMI_TSC_XGXS_RX_X4_FEC_DBG_ERRLr_SET
#define RX_X4_FEC_DBG_ERRLr_GET BCMI_TSC_XGXS_RX_X4_FEC_DBG_ERRLr_GET
#define RX_X4_FEC_DBG_ERRLr_DBG_ERRLf_GET BCMI_TSC_XGXS_RX_X4_FEC_DBG_ERRLr_DBG_ERRLf_GET
#define RX_X4_FEC_DBG_ERRLr_DBG_ERRLf_SET BCMI_TSC_XGXS_RX_X4_FEC_DBG_ERRLr_DBG_ERRLf_SET
#define READ_RX_X4_FEC_DBG_ERRLr BCMI_TSC_XGXS_READ_RX_X4_FEC_DBG_ERRLr
#define WRITE_RX_X4_FEC_DBG_ERRLr BCMI_TSC_XGXS_WRITE_RX_X4_FEC_DBG_ERRLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X4_FEC_DBG_ERRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X4_FEC_DBG_ERRAH
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc141
 * DESC:     "User FEC debug read data [31:16]": 00000000
 * SIZE:     32
 * FIELDS:
 *     DBG_ERRH         
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X4_FEC_DBG_ERRAHr (0x0000c141 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X4_FEC_DBG_ERRAHr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_DBG_ERRAH.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X4_FEC_DBG_ERRAHr_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_dbg_errah[1];
	uint32_t _rx_x4_fec_dbg_errah;
} BCMI_TSC_XGXS_RX_X4_FEC_DBG_ERRAHr_t;

#define BCMI_TSC_XGXS_RX_X4_FEC_DBG_ERRAHr_CLR(r) (r).rx_x4_fec_dbg_errah[0] = 0
#define BCMI_TSC_XGXS_RX_X4_FEC_DBG_ERRAHr_SET(r,d) (r).rx_x4_fec_dbg_errah[0] = d
#define BCMI_TSC_XGXS_RX_X4_FEC_DBG_ERRAHr_GET(r) (r).rx_x4_fec_dbg_errah[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X4_FEC_DBG_ERRAHr_DBG_ERRHf_GET(r) (((r).rx_x4_fec_dbg_errah[0]) & 0xffff)
#define BCMI_TSC_XGXS_RX_X4_FEC_DBG_ERRAHr_DBG_ERRHf_SET(r,f) (r).rx_x4_fec_dbg_errah[0]=(((r).rx_x4_fec_dbg_errah[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access RX_X4_FEC_DBG_ERRAH.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X4_FEC_DBG_ERRAHr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X4_FEC_DBG_ERRAHr,(_r._rx_x4_fec_dbg_errah))
#define BCMI_TSC_XGXS_WRITE_RX_X4_FEC_DBG_ERRAHr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X4_FEC_DBG_ERRAHr,(_r._rx_x4_fec_dbg_errah))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_DBG_ERRAHr BCMI_TSC_XGXS_RX_X4_FEC_DBG_ERRAHr
#define RX_X4_FEC_DBG_ERRAHr_SIZE BCMI_TSC_XGXS_RX_X4_FEC_DBG_ERRAHr_SIZE
typedef BCMI_TSC_XGXS_RX_X4_FEC_DBG_ERRAHr_t RX_X4_FEC_DBG_ERRAHr_t;
#define RX_X4_FEC_DBG_ERRAHr_CLR BCMI_TSC_XGXS_RX_X4_FEC_DBG_ERRAHr_CLR
#define RX_X4_FEC_DBG_ERRAHr_SET BCMI_TSC_XGXS_RX_X4_FEC_DBG_ERRAHr_SET
#define RX_X4_FEC_DBG_ERRAHr_GET BCMI_TSC_XGXS_RX_X4_FEC_DBG_ERRAHr_GET
#define RX_X4_FEC_DBG_ERRAHr_DBG_ERRHf_GET BCMI_TSC_XGXS_RX_X4_FEC_DBG_ERRAHr_DBG_ERRHf_GET
#define RX_X4_FEC_DBG_ERRAHr_DBG_ERRHf_SET BCMI_TSC_XGXS_RX_X4_FEC_DBG_ERRAHr_DBG_ERRHf_SET
#define READ_RX_X4_FEC_DBG_ERRAHr BCMI_TSC_XGXS_READ_RX_X4_FEC_DBG_ERRAHr
#define WRITE_RX_X4_FEC_DBG_ERRAHr BCMI_TSC_XGXS_WRITE_RX_X4_FEC_DBG_ERRAHr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X4_FEC_DBG_ERRAHr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X4_FEC_BURST_ERR_STATUSL
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc142
 * DESC:     "fec burst error status lower 16 bits": 00000000
 * SIZE:     32
 * FIELDS:
 *     BURST_ERR_STATUSL 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X4_FEC_BURST_ERR_STATUSLr (0x0000c142 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X4_FEC_BURST_ERR_STATUSLr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_BURST_ERR_STATUSL.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X4_FEC_BURST_ERR_STATUSLr_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_burst_err_statusl[1];
	uint32_t _rx_x4_fec_burst_err_statusl;
} BCMI_TSC_XGXS_RX_X4_FEC_BURST_ERR_STATUSLr_t;

#define BCMI_TSC_XGXS_RX_X4_FEC_BURST_ERR_STATUSLr_CLR(r) (r).rx_x4_fec_burst_err_statusl[0] = 0
#define BCMI_TSC_XGXS_RX_X4_FEC_BURST_ERR_STATUSLr_SET(r,d) (r).rx_x4_fec_burst_err_statusl[0] = d
#define BCMI_TSC_XGXS_RX_X4_FEC_BURST_ERR_STATUSLr_GET(r) (r).rx_x4_fec_burst_err_statusl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X4_FEC_BURST_ERR_STATUSLr_BURST_ERR_STATUSLf_GET(r) (((r).rx_x4_fec_burst_err_statusl[0]) & 0xffff)
#define BCMI_TSC_XGXS_RX_X4_FEC_BURST_ERR_STATUSLr_BURST_ERR_STATUSLf_SET(r,f) (r).rx_x4_fec_burst_err_statusl[0]=(((r).rx_x4_fec_burst_err_statusl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access RX_X4_FEC_BURST_ERR_STATUSL.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X4_FEC_BURST_ERR_STATUSLr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X4_FEC_BURST_ERR_STATUSLr,(_r._rx_x4_fec_burst_err_statusl))
#define BCMI_TSC_XGXS_WRITE_RX_X4_FEC_BURST_ERR_STATUSLr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X4_FEC_BURST_ERR_STATUSLr,(_r._rx_x4_fec_burst_err_statusl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_BURST_ERR_STATUSLr BCMI_TSC_XGXS_RX_X4_FEC_BURST_ERR_STATUSLr
#define RX_X4_FEC_BURST_ERR_STATUSLr_SIZE BCMI_TSC_XGXS_RX_X4_FEC_BURST_ERR_STATUSLr_SIZE
typedef BCMI_TSC_XGXS_RX_X4_FEC_BURST_ERR_STATUSLr_t RX_X4_FEC_BURST_ERR_STATUSLr_t;
#define RX_X4_FEC_BURST_ERR_STATUSLr_CLR BCMI_TSC_XGXS_RX_X4_FEC_BURST_ERR_STATUSLr_CLR
#define RX_X4_FEC_BURST_ERR_STATUSLr_SET BCMI_TSC_XGXS_RX_X4_FEC_BURST_ERR_STATUSLr_SET
#define RX_X4_FEC_BURST_ERR_STATUSLr_GET BCMI_TSC_XGXS_RX_X4_FEC_BURST_ERR_STATUSLr_GET
#define RX_X4_FEC_BURST_ERR_STATUSLr_BURST_ERR_STATUSLf_GET BCMI_TSC_XGXS_RX_X4_FEC_BURST_ERR_STATUSLr_BURST_ERR_STATUSLf_GET
#define RX_X4_FEC_BURST_ERR_STATUSLr_BURST_ERR_STATUSLf_SET BCMI_TSC_XGXS_RX_X4_FEC_BURST_ERR_STATUSLr_BURST_ERR_STATUSLf_SET
#define READ_RX_X4_FEC_BURST_ERR_STATUSLr BCMI_TSC_XGXS_READ_RX_X4_FEC_BURST_ERR_STATUSLr
#define WRITE_RX_X4_FEC_BURST_ERR_STATUSLr BCMI_TSC_XGXS_WRITE_RX_X4_FEC_BURST_ERR_STATUSLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X4_FEC_BURST_ERR_STATUSLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X4_FEC_BURST_ERR_STATUSH
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc143
 * DESC:     "fec burst error status lower 16 bits": 00000000
 * SIZE:     32
 * FIELDS:
 *     BURST_ERR_STATUSH 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X4_FEC_BURST_ERR_STATUSHr (0x0000c143 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X4_FEC_BURST_ERR_STATUSHr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_BURST_ERR_STATUSH.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X4_FEC_BURST_ERR_STATUSHr_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_burst_err_statush[1];
	uint32_t _rx_x4_fec_burst_err_statush;
} BCMI_TSC_XGXS_RX_X4_FEC_BURST_ERR_STATUSHr_t;

#define BCMI_TSC_XGXS_RX_X4_FEC_BURST_ERR_STATUSHr_CLR(r) (r).rx_x4_fec_burst_err_statush[0] = 0
#define BCMI_TSC_XGXS_RX_X4_FEC_BURST_ERR_STATUSHr_SET(r,d) (r).rx_x4_fec_burst_err_statush[0] = d
#define BCMI_TSC_XGXS_RX_X4_FEC_BURST_ERR_STATUSHr_GET(r) (r).rx_x4_fec_burst_err_statush[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X4_FEC_BURST_ERR_STATUSHr_BURST_ERR_STATUSHf_GET(r) (((r).rx_x4_fec_burst_err_statush[0]) & 0xffff)
#define BCMI_TSC_XGXS_RX_X4_FEC_BURST_ERR_STATUSHr_BURST_ERR_STATUSHf_SET(r,f) (r).rx_x4_fec_burst_err_statush[0]=(((r).rx_x4_fec_burst_err_statush[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access RX_X4_FEC_BURST_ERR_STATUSH.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X4_FEC_BURST_ERR_STATUSHr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X4_FEC_BURST_ERR_STATUSHr,(_r._rx_x4_fec_burst_err_statush))
#define BCMI_TSC_XGXS_WRITE_RX_X4_FEC_BURST_ERR_STATUSHr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X4_FEC_BURST_ERR_STATUSHr,(_r._rx_x4_fec_burst_err_statush))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_BURST_ERR_STATUSHr BCMI_TSC_XGXS_RX_X4_FEC_BURST_ERR_STATUSHr
#define RX_X4_FEC_BURST_ERR_STATUSHr_SIZE BCMI_TSC_XGXS_RX_X4_FEC_BURST_ERR_STATUSHr_SIZE
typedef BCMI_TSC_XGXS_RX_X4_FEC_BURST_ERR_STATUSHr_t RX_X4_FEC_BURST_ERR_STATUSHr_t;
#define RX_X4_FEC_BURST_ERR_STATUSHr_CLR BCMI_TSC_XGXS_RX_X4_FEC_BURST_ERR_STATUSHr_CLR
#define RX_X4_FEC_BURST_ERR_STATUSHr_SET BCMI_TSC_XGXS_RX_X4_FEC_BURST_ERR_STATUSHr_SET
#define RX_X4_FEC_BURST_ERR_STATUSHr_GET BCMI_TSC_XGXS_RX_X4_FEC_BURST_ERR_STATUSHr_GET
#define RX_X4_FEC_BURST_ERR_STATUSHr_BURST_ERR_STATUSHf_GET BCMI_TSC_XGXS_RX_X4_FEC_BURST_ERR_STATUSHr_BURST_ERR_STATUSHf_GET
#define RX_X4_FEC_BURST_ERR_STATUSHr_BURST_ERR_STATUSHf_SET BCMI_TSC_XGXS_RX_X4_FEC_BURST_ERR_STATUSHr_BURST_ERR_STATUSHf_SET
#define READ_RX_X4_FEC_BURST_ERR_STATUSHr BCMI_TSC_XGXS_READ_RX_X4_FEC_BURST_ERR_STATUSHr
#define WRITE_RX_X4_FEC_BURST_ERR_STATUSHr BCMI_TSC_XGXS_WRITE_RX_X4_FEC_BURST_ERR_STATUSHr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X4_FEC_BURST_ERR_STATUSHr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X4_BARREL_SHIFTER_STATE
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc144
 * DESC:     "Barrel Shifter State": 00000000
 * SIZE:     32
 * FIELDS:
 *     SHIFT_AMMOUNT    
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X4_BARREL_SHIFTER_STATEr (0x0000c144 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X4_BARREL_SHIFTER_STATEr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_BARREL_SHIFTER_STATE.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X4_BARREL_SHIFTER_STATEr_s {
	uint32_t v[1];
	uint32_t rx_x4_barrel_shifter_state[1];
	uint32_t _rx_x4_barrel_shifter_state;
} BCMI_TSC_XGXS_RX_X4_BARREL_SHIFTER_STATEr_t;

#define BCMI_TSC_XGXS_RX_X4_BARREL_SHIFTER_STATEr_CLR(r) (r).rx_x4_barrel_shifter_state[0] = 0
#define BCMI_TSC_XGXS_RX_X4_BARREL_SHIFTER_STATEr_SET(r,d) (r).rx_x4_barrel_shifter_state[0] = d
#define BCMI_TSC_XGXS_RX_X4_BARREL_SHIFTER_STATEr_GET(r) (r).rx_x4_barrel_shifter_state[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X4_BARREL_SHIFTER_STATEr_RESERVED0f_GET(r) ((((r).rx_x4_barrel_shifter_state[0]) >> 8) & 0xff)
#define BCMI_TSC_XGXS_RX_X4_BARREL_SHIFTER_STATEr_RESERVED0f_SET(r,f) (r).rx_x4_barrel_shifter_state[0]=(((r).rx_x4_barrel_shifter_state[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCMI_TSC_XGXS_RX_X4_BARREL_SHIFTER_STATEr_SHIFT_AMMOUNTf_GET(r) (((r).rx_x4_barrel_shifter_state[0]) & 0xff)
#define BCMI_TSC_XGXS_RX_X4_BARREL_SHIFTER_STATEr_SHIFT_AMMOUNTf_SET(r,f) (r).rx_x4_barrel_shifter_state[0]=(((r).rx_x4_barrel_shifter_state[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access RX_X4_BARREL_SHIFTER_STATE.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X4_BARREL_SHIFTER_STATEr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X4_BARREL_SHIFTER_STATEr,(_r._rx_x4_barrel_shifter_state))
#define BCMI_TSC_XGXS_WRITE_RX_X4_BARREL_SHIFTER_STATEr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X4_BARREL_SHIFTER_STATEr,(_r._rx_x4_barrel_shifter_state))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_BARREL_SHIFTER_STATEr BCMI_TSC_XGXS_RX_X4_BARREL_SHIFTER_STATEr
#define RX_X4_BARREL_SHIFTER_STATEr_SIZE BCMI_TSC_XGXS_RX_X4_BARREL_SHIFTER_STATEr_SIZE
typedef BCMI_TSC_XGXS_RX_X4_BARREL_SHIFTER_STATEr_t RX_X4_BARREL_SHIFTER_STATEr_t;
#define RX_X4_BARREL_SHIFTER_STATEr_CLR BCMI_TSC_XGXS_RX_X4_BARREL_SHIFTER_STATEr_CLR
#define RX_X4_BARREL_SHIFTER_STATEr_SET BCMI_TSC_XGXS_RX_X4_BARREL_SHIFTER_STATEr_SET
#define RX_X4_BARREL_SHIFTER_STATEr_GET BCMI_TSC_XGXS_RX_X4_BARREL_SHIFTER_STATEr_GET
#define RX_X4_BARREL_SHIFTER_STATEr_RESERVED0f_GET BCMI_TSC_XGXS_RX_X4_BARREL_SHIFTER_STATEr_RESERVED0f_GET
#define RX_X4_BARREL_SHIFTER_STATEr_RESERVED0f_SET BCMI_TSC_XGXS_RX_X4_BARREL_SHIFTER_STATEr_RESERVED0f_SET
#define RX_X4_BARREL_SHIFTER_STATEr_SHIFT_AMMOUNTf_GET BCMI_TSC_XGXS_RX_X4_BARREL_SHIFTER_STATEr_SHIFT_AMMOUNTf_GET
#define RX_X4_BARREL_SHIFTER_STATEr_SHIFT_AMMOUNTf_SET BCMI_TSC_XGXS_RX_X4_BARREL_SHIFTER_STATEr_SHIFT_AMMOUNTf_SET
#define READ_RX_X4_BARREL_SHIFTER_STATEr BCMI_TSC_XGXS_READ_RX_X4_BARREL_SHIFTER_STATEr
#define WRITE_RX_X4_BARREL_SHIFTER_STATEr BCMI_TSC_XGXS_WRITE_RX_X4_BARREL_SHIFTER_STATEr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X4_BARREL_SHIFTER_STATEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X4_CL49_LOCK_FSM_STATUS
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc145
 * DESC:     cl49_lock_fsm_status register: 00000000
 * SIZE:     32
 * FIELDS:
 *     LSM_CURR_STATE   
 *     LSM_HIS_STATE    
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X4_CL49_LOCK_FSM_STATUSr (0x0000c145 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X4_CL49_LOCK_FSM_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_CL49_LOCK_FSM_STATUS.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X4_CL49_LOCK_FSM_STATUSr_s {
	uint32_t v[1];
	uint32_t rx_x4_cl49_lock_fsm_status[1];
	uint32_t _rx_x4_cl49_lock_fsm_status;
} BCMI_TSC_XGXS_RX_X4_CL49_LOCK_FSM_STATUSr_t;

#define BCMI_TSC_XGXS_RX_X4_CL49_LOCK_FSM_STATUSr_CLR(r) (r).rx_x4_cl49_lock_fsm_status[0] = 0
#define BCMI_TSC_XGXS_RX_X4_CL49_LOCK_FSM_STATUSr_SET(r,d) (r).rx_x4_cl49_lock_fsm_status[0] = d
#define BCMI_TSC_XGXS_RX_X4_CL49_LOCK_FSM_STATUSr_GET(r) (r).rx_x4_cl49_lock_fsm_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X4_CL49_LOCK_FSM_STATUSr_RESERVED0f_GET(r) ((((r).rx_x4_cl49_lock_fsm_status[0]) >> 5) & 0x7ff)
#define BCMI_TSC_XGXS_RX_X4_CL49_LOCK_FSM_STATUSr_RESERVED0f_SET(r,f) (r).rx_x4_cl49_lock_fsm_status[0]=(((r).rx_x4_cl49_lock_fsm_status[0] & ~((uint32_t)0x7ff << 5)) | ((((uint32_t)f) & 0x7ff) << 5))
#define BCMI_TSC_XGXS_RX_X4_CL49_LOCK_FSM_STATUSr_LSM_HIS_STATEf_GET(r) ((((r).rx_x4_cl49_lock_fsm_status[0]) >> 2) & 0x7)
#define BCMI_TSC_XGXS_RX_X4_CL49_LOCK_FSM_STATUSr_LSM_HIS_STATEf_SET(r,f) (r).rx_x4_cl49_lock_fsm_status[0]=(((r).rx_x4_cl49_lock_fsm_status[0] & ~((uint32_t)0x7 << 2)) | ((((uint32_t)f) & 0x7) << 2))
#define BCMI_TSC_XGXS_RX_X4_CL49_LOCK_FSM_STATUSr_LSM_CURR_STATEf_GET(r) (((r).rx_x4_cl49_lock_fsm_status[0]) & 0x3)
#define BCMI_TSC_XGXS_RX_X4_CL49_LOCK_FSM_STATUSr_LSM_CURR_STATEf_SET(r,f) (r).rx_x4_cl49_lock_fsm_status[0]=(((r).rx_x4_cl49_lock_fsm_status[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))

/*
 * These macros can be used to access RX_X4_CL49_LOCK_FSM_STATUS.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X4_CL49_LOCK_FSM_STATUSr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X4_CL49_LOCK_FSM_STATUSr,(_r._rx_x4_cl49_lock_fsm_status))
#define BCMI_TSC_XGXS_WRITE_RX_X4_CL49_LOCK_FSM_STATUSr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X4_CL49_LOCK_FSM_STATUSr,(_r._rx_x4_cl49_lock_fsm_status))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_CL49_LOCK_FSM_STATUSr BCMI_TSC_XGXS_RX_X4_CL49_LOCK_FSM_STATUSr
#define RX_X4_CL49_LOCK_FSM_STATUSr_SIZE BCMI_TSC_XGXS_RX_X4_CL49_LOCK_FSM_STATUSr_SIZE
typedef BCMI_TSC_XGXS_RX_X4_CL49_LOCK_FSM_STATUSr_t RX_X4_CL49_LOCK_FSM_STATUSr_t;
#define RX_X4_CL49_LOCK_FSM_STATUSr_CLR BCMI_TSC_XGXS_RX_X4_CL49_LOCK_FSM_STATUSr_CLR
#define RX_X4_CL49_LOCK_FSM_STATUSr_SET BCMI_TSC_XGXS_RX_X4_CL49_LOCK_FSM_STATUSr_SET
#define RX_X4_CL49_LOCK_FSM_STATUSr_GET BCMI_TSC_XGXS_RX_X4_CL49_LOCK_FSM_STATUSr_GET
#define RX_X4_CL49_LOCK_FSM_STATUSr_RESERVED0f_GET BCMI_TSC_XGXS_RX_X4_CL49_LOCK_FSM_STATUSr_RESERVED0f_GET
#define RX_X4_CL49_LOCK_FSM_STATUSr_RESERVED0f_SET BCMI_TSC_XGXS_RX_X4_CL49_LOCK_FSM_STATUSr_RESERVED0f_SET
#define RX_X4_CL49_LOCK_FSM_STATUSr_LSM_HIS_STATEf_GET BCMI_TSC_XGXS_RX_X4_CL49_LOCK_FSM_STATUSr_LSM_HIS_STATEf_GET
#define RX_X4_CL49_LOCK_FSM_STATUSr_LSM_HIS_STATEf_SET BCMI_TSC_XGXS_RX_X4_CL49_LOCK_FSM_STATUSr_LSM_HIS_STATEf_SET
#define RX_X4_CL49_LOCK_FSM_STATUSr_LSM_CURR_STATEf_GET BCMI_TSC_XGXS_RX_X4_CL49_LOCK_FSM_STATUSr_LSM_CURR_STATEf_GET
#define RX_X4_CL49_LOCK_FSM_STATUSr_LSM_CURR_STATEf_SET BCMI_TSC_XGXS_RX_X4_CL49_LOCK_FSM_STATUSr_LSM_CURR_STATEf_SET
#define READ_RX_X4_CL49_LOCK_FSM_STATUSr BCMI_TSC_XGXS_READ_RX_X4_CL49_LOCK_FSM_STATUSr
#define WRITE_RX_X4_CL49_LOCK_FSM_STATUSr BCMI_TSC_XGXS_WRITE_RX_X4_CL49_LOCK_FSM_STATUSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X4_CL49_LOCK_FSM_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X4_DECODE_STATUS_0
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc146
 * DESC:     decode status 0 register: 00000000
 * SIZE:     32
 * FIELDS:
 *     CL49_RXSM_CURRENT_STATE 
 *     CL49_RXSM_HISTORY_STATE 
 *     RESERVED0        
 *     CL49_R_TYPE_CODED 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_0r (0x0000c146 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_DECODE_STATUS_0.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_0r_s {
	uint32_t v[1];
	uint32_t rx_x4_decode_status_0[1];
	uint32_t _rx_x4_decode_status_0;
} BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_0r_t;

#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_0r_CLR(r) (r).rx_x4_decode_status_0[0] = 0
#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_0r_SET(r,d) (r).rx_x4_decode_status_0[0] = d
#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_0r_GET(r) (r).rx_x4_decode_status_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_0r_CL49_R_TYPE_CODEDf_GET(r) ((((r).rx_x4_decode_status_0[0]) >> 12) & 0xf)
#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_0r_CL49_R_TYPE_CODEDf_SET(r,f) (r).rx_x4_decode_status_0[0]=(((r).rx_x4_decode_status_0[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_0r_RESERVED0f_GET(r) ((((r).rx_x4_decode_status_0[0]) >> 11) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_0r_RESERVED0f_SET(r,f) (r).rx_x4_decode_status_0[0]=(((r).rx_x4_decode_status_0[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_0r_CL49_RXSM_HISTORY_STATEf_GET(r) ((((r).rx_x4_decode_status_0[0]) >> 3) & 0xff)
#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_0r_CL49_RXSM_HISTORY_STATEf_SET(r,f) (r).rx_x4_decode_status_0[0]=(((r).rx_x4_decode_status_0[0] & ~((uint32_t)0xff << 3)) | ((((uint32_t)f) & 0xff) << 3))
#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_0r_CL49_RXSM_CURRENT_STATEf_GET(r) (((r).rx_x4_decode_status_0[0]) & 0x7)
#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_0r_CL49_RXSM_CURRENT_STATEf_SET(r,f) (r).rx_x4_decode_status_0[0]=(((r).rx_x4_decode_status_0[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))

/*
 * These macros can be used to access RX_X4_DECODE_STATUS_0.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X4_DECODE_STATUS_0r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_0r,(_r._rx_x4_decode_status_0))
#define BCMI_TSC_XGXS_WRITE_RX_X4_DECODE_STATUS_0r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_0r,(_r._rx_x4_decode_status_0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_DECODE_STATUS_0r BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_0r
#define RX_X4_DECODE_STATUS_0r_SIZE BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_0r_SIZE
typedef BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_0r_t RX_X4_DECODE_STATUS_0r_t;
#define RX_X4_DECODE_STATUS_0r_CLR BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_0r_CLR
#define RX_X4_DECODE_STATUS_0r_SET BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_0r_SET
#define RX_X4_DECODE_STATUS_0r_GET BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_0r_GET
#define RX_X4_DECODE_STATUS_0r_CL49_R_TYPE_CODEDf_GET BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_0r_CL49_R_TYPE_CODEDf_GET
#define RX_X4_DECODE_STATUS_0r_CL49_R_TYPE_CODEDf_SET BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_0r_CL49_R_TYPE_CODEDf_SET
#define RX_X4_DECODE_STATUS_0r_RESERVED0f_GET BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_0r_RESERVED0f_GET
#define RX_X4_DECODE_STATUS_0r_RESERVED0f_SET BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_0r_RESERVED0f_SET
#define RX_X4_DECODE_STATUS_0r_CL49_RXSM_HISTORY_STATEf_GET BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_0r_CL49_RXSM_HISTORY_STATEf_GET
#define RX_X4_DECODE_STATUS_0r_CL49_RXSM_HISTORY_STATEf_SET BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_0r_CL49_RXSM_HISTORY_STATEf_SET
#define RX_X4_DECODE_STATUS_0r_CL49_RXSM_CURRENT_STATEf_GET BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_0r_CL49_RXSM_CURRENT_STATEf_GET
#define RX_X4_DECODE_STATUS_0r_CL49_RXSM_CURRENT_STATEf_SET BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_0r_CL49_RXSM_CURRENT_STATEf_SET
#define READ_RX_X4_DECODE_STATUS_0r BCMI_TSC_XGXS_READ_RX_X4_DECODE_STATUS_0r
#define WRITE_RX_X4_DECODE_STATUS_0r BCMI_TSC_XGXS_WRITE_RX_X4_DECODE_STATUS_0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X4_DECODE_STATUS_1
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc147
 * DESC:     decode status 1 register: 00000000
 * SIZE:     32
 * FIELDS:
 *     CL49_BERMON_CURRENT_STATE 
 *     CL49_BERMON_HISTORY_STATE 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_1r (0x0000c147 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_DECODE_STATUS_1.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_1r_s {
	uint32_t v[1];
	uint32_t rx_x4_decode_status_1[1];
	uint32_t _rx_x4_decode_status_1;
} BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_1r_t;

#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_1r_CLR(r) (r).rx_x4_decode_status_1[0] = 0
#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_1r_SET(r,d) (r).rx_x4_decode_status_1[0] = d
#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_1r_GET(r) (r).rx_x4_decode_status_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_1r_RESERVED0f_GET(r) ((((r).rx_x4_decode_status_1[0]) >> 10) & 0x3f)
#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_1r_RESERVED0f_SET(r,f) (r).rx_x4_decode_status_1[0]=(((r).rx_x4_decode_status_1[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))
#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_1r_CL49_BERMON_HISTORY_STATEf_GET(r) ((((r).rx_x4_decode_status_1[0]) >> 5) & 0x1f)
#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_1r_CL49_BERMON_HISTORY_STATEf_SET(r,f) (r).rx_x4_decode_status_1[0]=(((r).rx_x4_decode_status_1[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5))
#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_1r_CL49_BERMON_CURRENT_STATEf_GET(r) (((r).rx_x4_decode_status_1[0]) & 0x1f)
#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_1r_CL49_BERMON_CURRENT_STATEf_SET(r,f) (r).rx_x4_decode_status_1[0]=(((r).rx_x4_decode_status_1[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))

/*
 * These macros can be used to access RX_X4_DECODE_STATUS_1.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X4_DECODE_STATUS_1r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_1r,(_r._rx_x4_decode_status_1))
#define BCMI_TSC_XGXS_WRITE_RX_X4_DECODE_STATUS_1r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_1r,(_r._rx_x4_decode_status_1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_DECODE_STATUS_1r BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_1r
#define RX_X4_DECODE_STATUS_1r_SIZE BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_1r_SIZE
typedef BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_1r_t RX_X4_DECODE_STATUS_1r_t;
#define RX_X4_DECODE_STATUS_1r_CLR BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_1r_CLR
#define RX_X4_DECODE_STATUS_1r_SET BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_1r_SET
#define RX_X4_DECODE_STATUS_1r_GET BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_1r_GET
#define RX_X4_DECODE_STATUS_1r_RESERVED0f_GET BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_1r_RESERVED0f_GET
#define RX_X4_DECODE_STATUS_1r_RESERVED0f_SET BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_1r_RESERVED0f_SET
#define RX_X4_DECODE_STATUS_1r_CL49_BERMON_HISTORY_STATEf_GET BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_1r_CL49_BERMON_HISTORY_STATEf_GET
#define RX_X4_DECODE_STATUS_1r_CL49_BERMON_HISTORY_STATEf_SET BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_1r_CL49_BERMON_HISTORY_STATEf_SET
#define RX_X4_DECODE_STATUS_1r_CL49_BERMON_CURRENT_STATEf_GET BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_1r_CL49_BERMON_CURRENT_STATEf_GET
#define RX_X4_DECODE_STATUS_1r_CL49_BERMON_CURRENT_STATEf_SET BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_1r_CL49_BERMON_CURRENT_STATEf_SET
#define READ_RX_X4_DECODE_STATUS_1r BCMI_TSC_XGXS_READ_RX_X4_DECODE_STATUS_1r
#define WRITE_RX_X4_DECODE_STATUS_1r BCMI_TSC_XGXS_WRITE_RX_X4_DECODE_STATUS_1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X4_DECODE_STATUS_2
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc148
 * DESC:     scw & K-code group error counters: 00000000
 * SIZE:     32
 * FIELDS:
 *     KCODE66ERRCOUNT  
 *     SYNC66ERRCOUNT   
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_2r (0x0000c148 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_2r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_DECODE_STATUS_2.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_2r_s {
	uint32_t v[1];
	uint32_t rx_x4_decode_status_2[1];
	uint32_t _rx_x4_decode_status_2;
} BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_2r_t;

#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_2r_CLR(r) (r).rx_x4_decode_status_2[0] = 0
#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_2r_SET(r,d) (r).rx_x4_decode_status_2[0] = d
#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_2r_GET(r) (r).rx_x4_decode_status_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_2r_SYNC66ERRCOUNTf_GET(r) ((((r).rx_x4_decode_status_2[0]) >> 8) & 0xff)
#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_2r_SYNC66ERRCOUNTf_SET(r,f) (r).rx_x4_decode_status_2[0]=(((r).rx_x4_decode_status_2[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_2r_KCODE66ERRCOUNTf_GET(r) (((r).rx_x4_decode_status_2[0]) & 0xff)
#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_2r_KCODE66ERRCOUNTf_SET(r,f) (r).rx_x4_decode_status_2[0]=(((r).rx_x4_decode_status_2[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access RX_X4_DECODE_STATUS_2.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X4_DECODE_STATUS_2r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_2r,(_r._rx_x4_decode_status_2))
#define BCMI_TSC_XGXS_WRITE_RX_X4_DECODE_STATUS_2r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_2r,(_r._rx_x4_decode_status_2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_DECODE_STATUS_2r BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_2r
#define RX_X4_DECODE_STATUS_2r_SIZE BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_2r_SIZE
typedef BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_2r_t RX_X4_DECODE_STATUS_2r_t;
#define RX_X4_DECODE_STATUS_2r_CLR BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_2r_CLR
#define RX_X4_DECODE_STATUS_2r_SET BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_2r_SET
#define RX_X4_DECODE_STATUS_2r_GET BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_2r_GET
#define RX_X4_DECODE_STATUS_2r_SYNC66ERRCOUNTf_GET BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_2r_SYNC66ERRCOUNTf_GET
#define RX_X4_DECODE_STATUS_2r_SYNC66ERRCOUNTf_SET BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_2r_SYNC66ERRCOUNTf_SET
#define RX_X4_DECODE_STATUS_2r_KCODE66ERRCOUNTf_GET BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_2r_KCODE66ERRCOUNTf_GET
#define RX_X4_DECODE_STATUS_2r_KCODE66ERRCOUNTf_SET BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_2r_KCODE66ERRCOUNTf_SET
#define READ_RX_X4_DECODE_STATUS_2r BCMI_TSC_XGXS_READ_RX_X4_DECODE_STATUS_2r
#define WRITE_RX_X4_DECODE_STATUS_2r BCMI_TSC_XGXS_WRITE_RX_X4_DECODE_STATUS_2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X4_DECODE_STATUS_3
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc149
 * DESC:     decode status 3 register: 00000000
 * SIZE:     32
 * FIELDS:
 *     RESERVED1        
 *     CL49IEEE_ERRORED_BLOCKS 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_3r (0x0000c149 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_3r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_DECODE_STATUS_3.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_3r_s {
	uint32_t v[1];
	uint32_t rx_x4_decode_status_3[1];
	uint32_t _rx_x4_decode_status_3;
} BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_3r_t;

#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_3r_CLR(r) (r).rx_x4_decode_status_3[0] = 0
#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_3r_SET(r,d) (r).rx_x4_decode_status_3[0] = d
#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_3r_GET(r) (r).rx_x4_decode_status_3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_3r_RESERVED0f_GET(r) ((((r).rx_x4_decode_status_3[0]) >> 10) & 0x3f)
#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_3r_RESERVED0f_SET(r,f) (r).rx_x4_decode_status_3[0]=(((r).rx_x4_decode_status_3[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))
#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_3r_CL49IEEE_ERRORED_BLOCKSf_GET(r) ((((r).rx_x4_decode_status_3[0]) >> 2) & 0xff)
#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_3r_CL49IEEE_ERRORED_BLOCKSf_SET(r,f) (r).rx_x4_decode_status_3[0]=(((r).rx_x4_decode_status_3[0] & ~((uint32_t)0xff << 2)) | ((((uint32_t)f) & 0xff) << 2))
#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_3r_RESERVED1f_GET(r) (((r).rx_x4_decode_status_3[0]) & 0x3)
#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_3r_RESERVED1f_SET(r,f) (r).rx_x4_decode_status_3[0]=(((r).rx_x4_decode_status_3[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))

/*
 * These macros can be used to access RX_X4_DECODE_STATUS_3.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X4_DECODE_STATUS_3r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_3r,(_r._rx_x4_decode_status_3))
#define BCMI_TSC_XGXS_WRITE_RX_X4_DECODE_STATUS_3r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_3r,(_r._rx_x4_decode_status_3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_DECODE_STATUS_3r BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_3r
#define RX_X4_DECODE_STATUS_3r_SIZE BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_3r_SIZE
typedef BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_3r_t RX_X4_DECODE_STATUS_3r_t;
#define RX_X4_DECODE_STATUS_3r_CLR BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_3r_CLR
#define RX_X4_DECODE_STATUS_3r_SET BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_3r_SET
#define RX_X4_DECODE_STATUS_3r_GET BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_3r_GET
#define RX_X4_DECODE_STATUS_3r_RESERVED0f_GET BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_3r_RESERVED0f_GET
#define RX_X4_DECODE_STATUS_3r_RESERVED0f_SET BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_3r_RESERVED0f_SET
#define RX_X4_DECODE_STATUS_3r_CL49IEEE_ERRORED_BLOCKSf_GET BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_3r_CL49IEEE_ERRORED_BLOCKSf_GET
#define RX_X4_DECODE_STATUS_3r_CL49IEEE_ERRORED_BLOCKSf_SET BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_3r_CL49IEEE_ERRORED_BLOCKSf_SET
#define RX_X4_DECODE_STATUS_3r_RESERVED1f_GET BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_3r_RESERVED1f_GET
#define RX_X4_DECODE_STATUS_3r_RESERVED1f_SET BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_3r_RESERVED1f_SET
#define READ_RX_X4_DECODE_STATUS_3r BCMI_TSC_XGXS_READ_RX_X4_DECODE_STATUS_3r
#define WRITE_RX_X4_DECODE_STATUS_3r BCMI_TSC_XGXS_WRITE_RX_X4_DECODE_STATUS_3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X4_DECODE_STATUS_4
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc14a
 * DESC:     decode status 4 register: 00000000
 * SIZE:     32
 * FIELDS:
 *     RESERVED0        
 *     CL48_SYNCACQ_STATE_L 
 *     B66DEC_FAULT_DET 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_4r (0x0000c14a | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_4r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_DECODE_STATUS_4.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_4r_s {
	uint32_t v[1];
	uint32_t rx_x4_decode_status_4[1];
	uint32_t _rx_x4_decode_status_4;
} BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_4r_t;

#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_4r_CLR(r) (r).rx_x4_decode_status_4[0] = 0
#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_4r_SET(r,d) (r).rx_x4_decode_status_4[0] = d
#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_4r_GET(r) (r).rx_x4_decode_status_4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_4r_B66DEC_FAULT_DETf_GET(r) ((((r).rx_x4_decode_status_4[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_4r_B66DEC_FAULT_DETf_SET(r,f) (r).rx_x4_decode_status_4[0]=(((r).rx_x4_decode_status_4[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_4r_CL48_SYNCACQ_STATE_Lf_GET(r) ((((r).rx_x4_decode_status_4[0]) >> 4) & 0x7ff)
#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_4r_CL48_SYNCACQ_STATE_Lf_SET(r,f) (r).rx_x4_decode_status_4[0]=(((r).rx_x4_decode_status_4[0] & ~((uint32_t)0x7ff << 4)) | ((((uint32_t)f) & 0x7ff) << 4))
#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_4r_RESERVED0f_GET(r) (((r).rx_x4_decode_status_4[0]) & 0xf)
#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_4r_RESERVED0f_SET(r,f) (r).rx_x4_decode_status_4[0]=(((r).rx_x4_decode_status_4[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access RX_X4_DECODE_STATUS_4.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X4_DECODE_STATUS_4r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_4r,(_r._rx_x4_decode_status_4))
#define BCMI_TSC_XGXS_WRITE_RX_X4_DECODE_STATUS_4r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_4r,(_r._rx_x4_decode_status_4))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_DECODE_STATUS_4r BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_4r
#define RX_X4_DECODE_STATUS_4r_SIZE BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_4r_SIZE
typedef BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_4r_t RX_X4_DECODE_STATUS_4r_t;
#define RX_X4_DECODE_STATUS_4r_CLR BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_4r_CLR
#define RX_X4_DECODE_STATUS_4r_SET BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_4r_SET
#define RX_X4_DECODE_STATUS_4r_GET BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_4r_GET
#define RX_X4_DECODE_STATUS_4r_B66DEC_FAULT_DETf_GET BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_4r_B66DEC_FAULT_DETf_GET
#define RX_X4_DECODE_STATUS_4r_B66DEC_FAULT_DETf_SET BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_4r_B66DEC_FAULT_DETf_SET
#define RX_X4_DECODE_STATUS_4r_CL48_SYNCACQ_STATE_Lf_GET BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_4r_CL48_SYNCACQ_STATE_Lf_GET
#define RX_X4_DECODE_STATUS_4r_CL48_SYNCACQ_STATE_Lf_SET BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_4r_CL48_SYNCACQ_STATE_Lf_SET
#define RX_X4_DECODE_STATUS_4r_RESERVED0f_GET BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_4r_RESERVED0f_GET
#define RX_X4_DECODE_STATUS_4r_RESERVED0f_SET BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_4r_RESERVED0f_SET
#define READ_RX_X4_DECODE_STATUS_4r BCMI_TSC_XGXS_READ_RX_X4_DECODE_STATUS_4r
#define WRITE_RX_X4_DECODE_STATUS_4r BCMI_TSC_XGXS_WRITE_RX_X4_DECODE_STATUS_4r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X4_DECODE_STATUS_5
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc14b
 * DESC:     decode status 5 register: 00000000
 * SIZE:     32
 * FIELDS:
 *     CL48_SYNCACQ_STATE_D_3 
 *     CL48_SYNCACQ_STATE_D_2 
 *     CL48_SYNCACQ_STATE_D_1 
 *     CL48_SYNCACQ_STATE_D_0 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_5r (0x0000c14b | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_5r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_DECODE_STATUS_5.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_5r_s {
	uint32_t v[1];
	uint32_t rx_x4_decode_status_5[1];
	uint32_t _rx_x4_decode_status_5;
} BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_5r_t;

#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_5r_CLR(r) (r).rx_x4_decode_status_5[0] = 0
#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_5r_SET(r,d) (r).rx_x4_decode_status_5[0] = d
#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_5r_GET(r) (r).rx_x4_decode_status_5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_5r_CL48_SYNCACQ_STATE_D_0f_GET(r) ((((r).rx_x4_decode_status_5[0]) >> 12) & 0xf)
#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_5r_CL48_SYNCACQ_STATE_D_0f_SET(r,f) (r).rx_x4_decode_status_5[0]=(((r).rx_x4_decode_status_5[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_5r_CL48_SYNCACQ_STATE_D_1f_GET(r) ((((r).rx_x4_decode_status_5[0]) >> 8) & 0xf)
#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_5r_CL48_SYNCACQ_STATE_D_1f_SET(r,f) (r).rx_x4_decode_status_5[0]=(((r).rx_x4_decode_status_5[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_5r_CL48_SYNCACQ_STATE_D_2f_GET(r) ((((r).rx_x4_decode_status_5[0]) >> 4) & 0xf)
#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_5r_CL48_SYNCACQ_STATE_D_2f_SET(r,f) (r).rx_x4_decode_status_5[0]=(((r).rx_x4_decode_status_5[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_5r_CL48_SYNCACQ_STATE_D_3f_GET(r) (((r).rx_x4_decode_status_5[0]) & 0xf)
#define BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_5r_CL48_SYNCACQ_STATE_D_3f_SET(r,f) (r).rx_x4_decode_status_5[0]=(((r).rx_x4_decode_status_5[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access RX_X4_DECODE_STATUS_5.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X4_DECODE_STATUS_5r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_5r,(_r._rx_x4_decode_status_5))
#define BCMI_TSC_XGXS_WRITE_RX_X4_DECODE_STATUS_5r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_5r,(_r._rx_x4_decode_status_5))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_DECODE_STATUS_5r BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_5r
#define RX_X4_DECODE_STATUS_5r_SIZE BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_5r_SIZE
typedef BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_5r_t RX_X4_DECODE_STATUS_5r_t;
#define RX_X4_DECODE_STATUS_5r_CLR BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_5r_CLR
#define RX_X4_DECODE_STATUS_5r_SET BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_5r_SET
#define RX_X4_DECODE_STATUS_5r_GET BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_5r_GET
#define RX_X4_DECODE_STATUS_5r_CL48_SYNCACQ_STATE_D_0f_GET BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_5r_CL48_SYNCACQ_STATE_D_0f_GET
#define RX_X4_DECODE_STATUS_5r_CL48_SYNCACQ_STATE_D_0f_SET BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_5r_CL48_SYNCACQ_STATE_D_0f_SET
#define RX_X4_DECODE_STATUS_5r_CL48_SYNCACQ_STATE_D_1f_GET BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_5r_CL48_SYNCACQ_STATE_D_1f_GET
#define RX_X4_DECODE_STATUS_5r_CL48_SYNCACQ_STATE_D_1f_SET BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_5r_CL48_SYNCACQ_STATE_D_1f_SET
#define RX_X4_DECODE_STATUS_5r_CL48_SYNCACQ_STATE_D_2f_GET BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_5r_CL48_SYNCACQ_STATE_D_2f_GET
#define RX_X4_DECODE_STATUS_5r_CL48_SYNCACQ_STATE_D_2f_SET BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_5r_CL48_SYNCACQ_STATE_D_2f_SET
#define RX_X4_DECODE_STATUS_5r_CL48_SYNCACQ_STATE_D_3f_GET BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_5r_CL48_SYNCACQ_STATE_D_3f_GET
#define RX_X4_DECODE_STATUS_5r_CL48_SYNCACQ_STATE_D_3f_SET BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_5r_CL48_SYNCACQ_STATE_D_3f_SET
#define READ_RX_X4_DECODE_STATUS_5r BCMI_TSC_XGXS_READ_RX_X4_DECODE_STATUS_5r
#define WRITE_RX_X4_DECODE_STATUS_5r BCMI_TSC_XGXS_WRITE_RX_X4_DECODE_STATUS_5r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X4_DECODE_STATUS_5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X4_SYNCACQ_STATUS_0
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc14c
 * DESC:     syncacq_status_0 register: 00000000
 * SIZE:     32
 * FIELDS:
 *     CL36_SYNCACQ_STATE_CODED_PER_LN 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X4_SYNCACQ_STATUS_0r (0x0000c14c | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X4_SYNCACQ_STATUS_0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_SYNCACQ_STATUS_0.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X4_SYNCACQ_STATUS_0r_s {
	uint32_t v[1];
	uint32_t rx_x4_syncacq_status_0[1];
	uint32_t _rx_x4_syncacq_status_0;
} BCMI_TSC_XGXS_RX_X4_SYNCACQ_STATUS_0r_t;

#define BCMI_TSC_XGXS_RX_X4_SYNCACQ_STATUS_0r_CLR(r) (r).rx_x4_syncacq_status_0[0] = 0
#define BCMI_TSC_XGXS_RX_X4_SYNCACQ_STATUS_0r_SET(r,d) (r).rx_x4_syncacq_status_0[0] = d
#define BCMI_TSC_XGXS_RX_X4_SYNCACQ_STATUS_0r_GET(r) (r).rx_x4_syncacq_status_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X4_SYNCACQ_STATUS_0r_RESERVED0f_GET(r) ((((r).rx_x4_syncacq_status_0[0]) >> 4) & 0xfff)
#define BCMI_TSC_XGXS_RX_X4_SYNCACQ_STATUS_0r_RESERVED0f_SET(r,f) (r).rx_x4_syncacq_status_0[0]=(((r).rx_x4_syncacq_status_0[0] & ~((uint32_t)0xfff << 4)) | ((((uint32_t)f) & 0xfff) << 4))
#define BCMI_TSC_XGXS_RX_X4_SYNCACQ_STATUS_0r_CL36_SYNCACQ_STATE_CODED_PER_LNf_GET(r) (((r).rx_x4_syncacq_status_0[0]) & 0xf)
#define BCMI_TSC_XGXS_RX_X4_SYNCACQ_STATUS_0r_CL36_SYNCACQ_STATE_CODED_PER_LNf_SET(r,f) (r).rx_x4_syncacq_status_0[0]=(((r).rx_x4_syncacq_status_0[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access RX_X4_SYNCACQ_STATUS_0.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X4_SYNCACQ_STATUS_0r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X4_SYNCACQ_STATUS_0r,(_r._rx_x4_syncacq_status_0))
#define BCMI_TSC_XGXS_WRITE_RX_X4_SYNCACQ_STATUS_0r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X4_SYNCACQ_STATUS_0r,(_r._rx_x4_syncacq_status_0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_SYNCACQ_STATUS_0r BCMI_TSC_XGXS_RX_X4_SYNCACQ_STATUS_0r
#define RX_X4_SYNCACQ_STATUS_0r_SIZE BCMI_TSC_XGXS_RX_X4_SYNCACQ_STATUS_0r_SIZE
typedef BCMI_TSC_XGXS_RX_X4_SYNCACQ_STATUS_0r_t RX_X4_SYNCACQ_STATUS_0r_t;
#define RX_X4_SYNCACQ_STATUS_0r_CLR BCMI_TSC_XGXS_RX_X4_SYNCACQ_STATUS_0r_CLR
#define RX_X4_SYNCACQ_STATUS_0r_SET BCMI_TSC_XGXS_RX_X4_SYNCACQ_STATUS_0r_SET
#define RX_X4_SYNCACQ_STATUS_0r_GET BCMI_TSC_XGXS_RX_X4_SYNCACQ_STATUS_0r_GET
#define RX_X4_SYNCACQ_STATUS_0r_RESERVED0f_GET BCMI_TSC_XGXS_RX_X4_SYNCACQ_STATUS_0r_RESERVED0f_GET
#define RX_X4_SYNCACQ_STATUS_0r_RESERVED0f_SET BCMI_TSC_XGXS_RX_X4_SYNCACQ_STATUS_0r_RESERVED0f_SET
#define RX_X4_SYNCACQ_STATUS_0r_CL36_SYNCACQ_STATE_CODED_PER_LNf_GET BCMI_TSC_XGXS_RX_X4_SYNCACQ_STATUS_0r_CL36_SYNCACQ_STATE_CODED_PER_LNf_GET
#define RX_X4_SYNCACQ_STATUS_0r_CL36_SYNCACQ_STATE_CODED_PER_LNf_SET BCMI_TSC_XGXS_RX_X4_SYNCACQ_STATUS_0r_CL36_SYNCACQ_STATE_CODED_PER_LNf_SET
#define READ_RX_X4_SYNCACQ_STATUS_0r BCMI_TSC_XGXS_READ_RX_X4_SYNCACQ_STATUS_0r
#define WRITE_RX_X4_SYNCACQ_STATUS_0r BCMI_TSC_XGXS_WRITE_RX_X4_SYNCACQ_STATUS_0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X4_SYNCACQ_STATUS_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X4_SYNCACQ_STATUS_1
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc14d
 * DESC:     syncacq_status_1 register: 00000000
 * SIZE:     32
 * FIELDS:
 *     CL36_SYNCACQ_HIS_STATE_PER_LN 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X4_SYNCACQ_STATUS_1r (0x0000c14d | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X4_SYNCACQ_STATUS_1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_SYNCACQ_STATUS_1.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X4_SYNCACQ_STATUS_1r_s {
	uint32_t v[1];
	uint32_t rx_x4_syncacq_status_1[1];
	uint32_t _rx_x4_syncacq_status_1;
} BCMI_TSC_XGXS_RX_X4_SYNCACQ_STATUS_1r_t;

#define BCMI_TSC_XGXS_RX_X4_SYNCACQ_STATUS_1r_CLR(r) (r).rx_x4_syncacq_status_1[0] = 0
#define BCMI_TSC_XGXS_RX_X4_SYNCACQ_STATUS_1r_SET(r,d) (r).rx_x4_syncacq_status_1[0] = d
#define BCMI_TSC_XGXS_RX_X4_SYNCACQ_STATUS_1r_GET(r) (r).rx_x4_syncacq_status_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X4_SYNCACQ_STATUS_1r_RESERVED0f_GET(r) ((((r).rx_x4_syncacq_status_1[0]) >> 13) & 0x7)
#define BCMI_TSC_XGXS_RX_X4_SYNCACQ_STATUS_1r_RESERVED0f_SET(r,f) (r).rx_x4_syncacq_status_1[0]=(((r).rx_x4_syncacq_status_1[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))
#define BCMI_TSC_XGXS_RX_X4_SYNCACQ_STATUS_1r_CL36_SYNCACQ_HIS_STATE_PER_LNf_GET(r) (((r).rx_x4_syncacq_status_1[0]) & 0x1fff)
#define BCMI_TSC_XGXS_RX_X4_SYNCACQ_STATUS_1r_CL36_SYNCACQ_HIS_STATE_PER_LNf_SET(r,f) (r).rx_x4_syncacq_status_1[0]=(((r).rx_x4_syncacq_status_1[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))

/*
 * These macros can be used to access RX_X4_SYNCACQ_STATUS_1.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X4_SYNCACQ_STATUS_1r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X4_SYNCACQ_STATUS_1r,(_r._rx_x4_syncacq_status_1))
#define BCMI_TSC_XGXS_WRITE_RX_X4_SYNCACQ_STATUS_1r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X4_SYNCACQ_STATUS_1r,(_r._rx_x4_syncacq_status_1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_SYNCACQ_STATUS_1r BCMI_TSC_XGXS_RX_X4_SYNCACQ_STATUS_1r
#define RX_X4_SYNCACQ_STATUS_1r_SIZE BCMI_TSC_XGXS_RX_X4_SYNCACQ_STATUS_1r_SIZE
typedef BCMI_TSC_XGXS_RX_X4_SYNCACQ_STATUS_1r_t RX_X4_SYNCACQ_STATUS_1r_t;
#define RX_X4_SYNCACQ_STATUS_1r_CLR BCMI_TSC_XGXS_RX_X4_SYNCACQ_STATUS_1r_CLR
#define RX_X4_SYNCACQ_STATUS_1r_SET BCMI_TSC_XGXS_RX_X4_SYNCACQ_STATUS_1r_SET
#define RX_X4_SYNCACQ_STATUS_1r_GET BCMI_TSC_XGXS_RX_X4_SYNCACQ_STATUS_1r_GET
#define RX_X4_SYNCACQ_STATUS_1r_RESERVED0f_GET BCMI_TSC_XGXS_RX_X4_SYNCACQ_STATUS_1r_RESERVED0f_GET
#define RX_X4_SYNCACQ_STATUS_1r_RESERVED0f_SET BCMI_TSC_XGXS_RX_X4_SYNCACQ_STATUS_1r_RESERVED0f_SET
#define RX_X4_SYNCACQ_STATUS_1r_CL36_SYNCACQ_HIS_STATE_PER_LNf_GET BCMI_TSC_XGXS_RX_X4_SYNCACQ_STATUS_1r_CL36_SYNCACQ_HIS_STATE_PER_LNf_GET
#define RX_X4_SYNCACQ_STATUS_1r_CL36_SYNCACQ_HIS_STATE_PER_LNf_SET BCMI_TSC_XGXS_RX_X4_SYNCACQ_STATUS_1r_CL36_SYNCACQ_HIS_STATE_PER_LNf_SET
#define READ_RX_X4_SYNCACQ_STATUS_1r BCMI_TSC_XGXS_READ_RX_X4_SYNCACQ_STATUS_1r
#define WRITE_RX_X4_SYNCACQ_STATUS_1r BCMI_TSC_XGXS_WRITE_RX_X4_SYNCACQ_STATUS_1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X4_SYNCACQ_STATUS_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X4_BERCOUNT
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc14e
 * DESC:     bercount register: 00000000
 * SIZE:     32
 * FIELDS:
 *     BER_COUNT_PER_LN 
 *     BIP_ERROR_COUNT_PER_LANE 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X4_BERCOUNTr (0x0000c14e | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X4_BERCOUNTr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_BERCOUNT.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X4_BERCOUNTr_s {
	uint32_t v[1];
	uint32_t rx_x4_bercount[1];
	uint32_t _rx_x4_bercount;
} BCMI_TSC_XGXS_RX_X4_BERCOUNTr_t;

#define BCMI_TSC_XGXS_RX_X4_BERCOUNTr_CLR(r) (r).rx_x4_bercount[0] = 0
#define BCMI_TSC_XGXS_RX_X4_BERCOUNTr_SET(r,d) (r).rx_x4_bercount[0] = d
#define BCMI_TSC_XGXS_RX_X4_BERCOUNTr_GET(r) (r).rx_x4_bercount[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X4_BERCOUNTr_BIP_ERROR_COUNT_PER_LANEf_GET(r) ((((r).rx_x4_bercount[0]) >> 8) & 0xff)
#define BCMI_TSC_XGXS_RX_X4_BERCOUNTr_BIP_ERROR_COUNT_PER_LANEf_SET(r,f) (r).rx_x4_bercount[0]=(((r).rx_x4_bercount[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCMI_TSC_XGXS_RX_X4_BERCOUNTr_BER_COUNT_PER_LNf_GET(r) (((r).rx_x4_bercount[0]) & 0xff)
#define BCMI_TSC_XGXS_RX_X4_BERCOUNTr_BER_COUNT_PER_LNf_SET(r,f) (r).rx_x4_bercount[0]=(((r).rx_x4_bercount[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access RX_X4_BERCOUNT.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X4_BERCOUNTr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X4_BERCOUNTr,(_r._rx_x4_bercount))
#define BCMI_TSC_XGXS_WRITE_RX_X4_BERCOUNTr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X4_BERCOUNTr,(_r._rx_x4_bercount))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_BERCOUNTr BCMI_TSC_XGXS_RX_X4_BERCOUNTr
#define RX_X4_BERCOUNTr_SIZE BCMI_TSC_XGXS_RX_X4_BERCOUNTr_SIZE
typedef BCMI_TSC_XGXS_RX_X4_BERCOUNTr_t RX_X4_BERCOUNTr_t;
#define RX_X4_BERCOUNTr_CLR BCMI_TSC_XGXS_RX_X4_BERCOUNTr_CLR
#define RX_X4_BERCOUNTr_SET BCMI_TSC_XGXS_RX_X4_BERCOUNTr_SET
#define RX_X4_BERCOUNTr_GET BCMI_TSC_XGXS_RX_X4_BERCOUNTr_GET
#define RX_X4_BERCOUNTr_BIP_ERROR_COUNT_PER_LANEf_GET BCMI_TSC_XGXS_RX_X4_BERCOUNTr_BIP_ERROR_COUNT_PER_LANEf_GET
#define RX_X4_BERCOUNTr_BIP_ERROR_COUNT_PER_LANEf_SET BCMI_TSC_XGXS_RX_X4_BERCOUNTr_BIP_ERROR_COUNT_PER_LANEf_SET
#define RX_X4_BERCOUNTr_BER_COUNT_PER_LNf_GET BCMI_TSC_XGXS_RX_X4_BERCOUNTr_BER_COUNT_PER_LNf_GET
#define RX_X4_BERCOUNTr_BER_COUNT_PER_LNf_SET BCMI_TSC_XGXS_RX_X4_BERCOUNTr_BER_COUNT_PER_LNf_SET
#define READ_RX_X4_BERCOUNTr BCMI_TSC_XGXS_READ_RX_X4_BERCOUNTr
#define WRITE_RX_X4_BERCOUNTr BCMI_TSC_XGXS_WRITE_RX_X4_BERCOUNTr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X4_BERCOUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X4_PMA_PMD_LIVE_STATUS
 * BLOCKS:   RX_X4_STATUS1
 * REGADDR:  0xc150
 * DESC:     "Live status of PMA/PMD Information": 00000000
 * SIZE:     32
 * FIELDS:
 *     SIGNAL_OK        
 *     AFE_SIGNAL_DETECT 
 *     EXTERNAL_SIGNAL_DETECT 
 *     PMD_LOCK         
 *     RX_ANA_RESET     
 *     RX_ANA_POWER_DOWN 
 *     TX_ANA_RESET     
 *     TX_ANA_POWER_DOWN 
 *     TX_LOW_POWER_6G  
 *     PLL_RESET        
 *     PLL_POWER_DOWN   
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X4_PMA_PMD_LIVE_STATUSr (0x0000c150 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X4_PMA_PMD_LIVE_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_PMA_PMD_LIVE_STATUS.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X4_PMA_PMD_LIVE_STATUSr_s {
	uint32_t v[1];
	uint32_t rx_x4_pma_pmd_live_status[1];
	uint32_t _rx_x4_pma_pmd_live_status;
} BCMI_TSC_XGXS_RX_X4_PMA_PMD_LIVE_STATUSr_t;

#define BCMI_TSC_XGXS_RX_X4_PMA_PMD_LIVE_STATUSr_CLR(r) (r).rx_x4_pma_pmd_live_status[0] = 0
#define BCMI_TSC_XGXS_RX_X4_PMA_PMD_LIVE_STATUSr_SET(r,d) (r).rx_x4_pma_pmd_live_status[0] = d
#define BCMI_TSC_XGXS_RX_X4_PMA_PMD_LIVE_STATUSr_GET(r) (r).rx_x4_pma_pmd_live_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X4_PMA_PMD_LIVE_STATUSr_RESERVED0f_GET(r) ((((r).rx_x4_pma_pmd_live_status[0]) >> 11) & 0x1f)
#define BCMI_TSC_XGXS_RX_X4_PMA_PMD_LIVE_STATUSr_RESERVED0f_SET(r,f) (r).rx_x4_pma_pmd_live_status[0]=(((r).rx_x4_pma_pmd_live_status[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))
#define BCMI_TSC_XGXS_RX_X4_PMA_PMD_LIVE_STATUSr_PLL_POWER_DOWNf_GET(r) ((((r).rx_x4_pma_pmd_live_status[0]) >> 10) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_PMA_PMD_LIVE_STATUSr_PLL_POWER_DOWNf_SET(r,f) (r).rx_x4_pma_pmd_live_status[0]=(((r).rx_x4_pma_pmd_live_status[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCMI_TSC_XGXS_RX_X4_PMA_PMD_LIVE_STATUSr_PLL_RESETf_GET(r) ((((r).rx_x4_pma_pmd_live_status[0]) >> 9) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_PMA_PMD_LIVE_STATUSr_PLL_RESETf_SET(r,f) (r).rx_x4_pma_pmd_live_status[0]=(((r).rx_x4_pma_pmd_live_status[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCMI_TSC_XGXS_RX_X4_PMA_PMD_LIVE_STATUSr_TX_LOW_POWER_6Gf_GET(r) ((((r).rx_x4_pma_pmd_live_status[0]) >> 8) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_PMA_PMD_LIVE_STATUSr_TX_LOW_POWER_6Gf_SET(r,f) (r).rx_x4_pma_pmd_live_status[0]=(((r).rx_x4_pma_pmd_live_status[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCMI_TSC_XGXS_RX_X4_PMA_PMD_LIVE_STATUSr_TX_ANA_POWER_DOWNf_GET(r) ((((r).rx_x4_pma_pmd_live_status[0]) >> 7) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_PMA_PMD_LIVE_STATUSr_TX_ANA_POWER_DOWNf_SET(r,f) (r).rx_x4_pma_pmd_live_status[0]=(((r).rx_x4_pma_pmd_live_status[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCMI_TSC_XGXS_RX_X4_PMA_PMD_LIVE_STATUSr_TX_ANA_RESETf_GET(r) ((((r).rx_x4_pma_pmd_live_status[0]) >> 6) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_PMA_PMD_LIVE_STATUSr_TX_ANA_RESETf_SET(r,f) (r).rx_x4_pma_pmd_live_status[0]=(((r).rx_x4_pma_pmd_live_status[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCMI_TSC_XGXS_RX_X4_PMA_PMD_LIVE_STATUSr_RX_ANA_POWER_DOWNf_GET(r) ((((r).rx_x4_pma_pmd_live_status[0]) >> 5) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_PMA_PMD_LIVE_STATUSr_RX_ANA_POWER_DOWNf_SET(r,f) (r).rx_x4_pma_pmd_live_status[0]=(((r).rx_x4_pma_pmd_live_status[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCMI_TSC_XGXS_RX_X4_PMA_PMD_LIVE_STATUSr_RX_ANA_RESETf_GET(r) ((((r).rx_x4_pma_pmd_live_status[0]) >> 4) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_PMA_PMD_LIVE_STATUSr_RX_ANA_RESETf_SET(r,f) (r).rx_x4_pma_pmd_live_status[0]=(((r).rx_x4_pma_pmd_live_status[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCMI_TSC_XGXS_RX_X4_PMA_PMD_LIVE_STATUSr_PMD_LOCKf_GET(r) ((((r).rx_x4_pma_pmd_live_status[0]) >> 3) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_PMA_PMD_LIVE_STATUSr_PMD_LOCKf_SET(r,f) (r).rx_x4_pma_pmd_live_status[0]=(((r).rx_x4_pma_pmd_live_status[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCMI_TSC_XGXS_RX_X4_PMA_PMD_LIVE_STATUSr_EXTERNAL_SIGNAL_DETECTf_GET(r) ((((r).rx_x4_pma_pmd_live_status[0]) >> 2) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_PMA_PMD_LIVE_STATUSr_EXTERNAL_SIGNAL_DETECTf_SET(r,f) (r).rx_x4_pma_pmd_live_status[0]=(((r).rx_x4_pma_pmd_live_status[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCMI_TSC_XGXS_RX_X4_PMA_PMD_LIVE_STATUSr_AFE_SIGNAL_DETECTf_GET(r) ((((r).rx_x4_pma_pmd_live_status[0]) >> 1) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_PMA_PMD_LIVE_STATUSr_AFE_SIGNAL_DETECTf_SET(r,f) (r).rx_x4_pma_pmd_live_status[0]=(((r).rx_x4_pma_pmd_live_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCMI_TSC_XGXS_RX_X4_PMA_PMD_LIVE_STATUSr_SIGNAL_OKf_GET(r) (((r).rx_x4_pma_pmd_live_status[0]) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_PMA_PMD_LIVE_STATUSr_SIGNAL_OKf_SET(r,f) (r).rx_x4_pma_pmd_live_status[0]=(((r).rx_x4_pma_pmd_live_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access RX_X4_PMA_PMD_LIVE_STATUS.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X4_PMA_PMD_LIVE_STATUSr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X4_PMA_PMD_LIVE_STATUSr,(_r._rx_x4_pma_pmd_live_status))
#define BCMI_TSC_XGXS_WRITE_RX_X4_PMA_PMD_LIVE_STATUSr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X4_PMA_PMD_LIVE_STATUSr,(_r._rx_x4_pma_pmd_live_status))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_PMA_PMD_LIVE_STATUSr BCMI_TSC_XGXS_RX_X4_PMA_PMD_LIVE_STATUSr
#define RX_X4_PMA_PMD_LIVE_STATUSr_SIZE BCMI_TSC_XGXS_RX_X4_PMA_PMD_LIVE_STATUSr_SIZE
typedef BCMI_TSC_XGXS_RX_X4_PMA_PMD_LIVE_STATUSr_t RX_X4_PMA_PMD_LIVE_STATUSr_t;
#define RX_X4_PMA_PMD_LIVE_STATUSr_CLR BCMI_TSC_XGXS_RX_X4_PMA_PMD_LIVE_STATUSr_CLR
#define RX_X4_PMA_PMD_LIVE_STATUSr_SET BCMI_TSC_XGXS_RX_X4_PMA_PMD_LIVE_STATUSr_SET
#define RX_X4_PMA_PMD_LIVE_STATUSr_GET BCMI_TSC_XGXS_RX_X4_PMA_PMD_LIVE_STATUSr_GET
#define RX_X4_PMA_PMD_LIVE_STATUSr_RESERVED0f_GET BCMI_TSC_XGXS_RX_X4_PMA_PMD_LIVE_STATUSr_RESERVED0f_GET
#define RX_X4_PMA_PMD_LIVE_STATUSr_RESERVED0f_SET BCMI_TSC_XGXS_RX_X4_PMA_PMD_LIVE_STATUSr_RESERVED0f_SET
#define RX_X4_PMA_PMD_LIVE_STATUSr_PLL_POWER_DOWNf_GET BCMI_TSC_XGXS_RX_X4_PMA_PMD_LIVE_STATUSr_PLL_POWER_DOWNf_GET
#define RX_X4_PMA_PMD_LIVE_STATUSr_PLL_POWER_DOWNf_SET BCMI_TSC_XGXS_RX_X4_PMA_PMD_LIVE_STATUSr_PLL_POWER_DOWNf_SET
#define RX_X4_PMA_PMD_LIVE_STATUSr_PLL_RESETf_GET BCMI_TSC_XGXS_RX_X4_PMA_PMD_LIVE_STATUSr_PLL_RESETf_GET
#define RX_X4_PMA_PMD_LIVE_STATUSr_PLL_RESETf_SET BCMI_TSC_XGXS_RX_X4_PMA_PMD_LIVE_STATUSr_PLL_RESETf_SET
#define RX_X4_PMA_PMD_LIVE_STATUSr_TX_LOW_POWER_6Gf_GET BCMI_TSC_XGXS_RX_X4_PMA_PMD_LIVE_STATUSr_TX_LOW_POWER_6Gf_GET
#define RX_X4_PMA_PMD_LIVE_STATUSr_TX_LOW_POWER_6Gf_SET BCMI_TSC_XGXS_RX_X4_PMA_PMD_LIVE_STATUSr_TX_LOW_POWER_6Gf_SET
#define RX_X4_PMA_PMD_LIVE_STATUSr_TX_ANA_POWER_DOWNf_GET BCMI_TSC_XGXS_RX_X4_PMA_PMD_LIVE_STATUSr_TX_ANA_POWER_DOWNf_GET
#define RX_X4_PMA_PMD_LIVE_STATUSr_TX_ANA_POWER_DOWNf_SET BCMI_TSC_XGXS_RX_X4_PMA_PMD_LIVE_STATUSr_TX_ANA_POWER_DOWNf_SET
#define RX_X4_PMA_PMD_LIVE_STATUSr_TX_ANA_RESETf_GET BCMI_TSC_XGXS_RX_X4_PMA_PMD_LIVE_STATUSr_TX_ANA_RESETf_GET
#define RX_X4_PMA_PMD_LIVE_STATUSr_TX_ANA_RESETf_SET BCMI_TSC_XGXS_RX_X4_PMA_PMD_LIVE_STATUSr_TX_ANA_RESETf_SET
#define RX_X4_PMA_PMD_LIVE_STATUSr_RX_ANA_POWER_DOWNf_GET BCMI_TSC_XGXS_RX_X4_PMA_PMD_LIVE_STATUSr_RX_ANA_POWER_DOWNf_GET
#define RX_X4_PMA_PMD_LIVE_STATUSr_RX_ANA_POWER_DOWNf_SET BCMI_TSC_XGXS_RX_X4_PMA_PMD_LIVE_STATUSr_RX_ANA_POWER_DOWNf_SET
#define RX_X4_PMA_PMD_LIVE_STATUSr_RX_ANA_RESETf_GET BCMI_TSC_XGXS_RX_X4_PMA_PMD_LIVE_STATUSr_RX_ANA_RESETf_GET
#define RX_X4_PMA_PMD_LIVE_STATUSr_RX_ANA_RESETf_SET BCMI_TSC_XGXS_RX_X4_PMA_PMD_LIVE_STATUSr_RX_ANA_RESETf_SET
#define RX_X4_PMA_PMD_LIVE_STATUSr_PMD_LOCKf_GET BCMI_TSC_XGXS_RX_X4_PMA_PMD_LIVE_STATUSr_PMD_LOCKf_GET
#define RX_X4_PMA_PMD_LIVE_STATUSr_PMD_LOCKf_SET BCMI_TSC_XGXS_RX_X4_PMA_PMD_LIVE_STATUSr_PMD_LOCKf_SET
#define RX_X4_PMA_PMD_LIVE_STATUSr_EXTERNAL_SIGNAL_DETECTf_GET BCMI_TSC_XGXS_RX_X4_PMA_PMD_LIVE_STATUSr_EXTERNAL_SIGNAL_DETECTf_GET
#define RX_X4_PMA_PMD_LIVE_STATUSr_EXTERNAL_SIGNAL_DETECTf_SET BCMI_TSC_XGXS_RX_X4_PMA_PMD_LIVE_STATUSr_EXTERNAL_SIGNAL_DETECTf_SET
#define RX_X4_PMA_PMD_LIVE_STATUSr_AFE_SIGNAL_DETECTf_GET BCMI_TSC_XGXS_RX_X4_PMA_PMD_LIVE_STATUSr_AFE_SIGNAL_DETECTf_GET
#define RX_X4_PMA_PMD_LIVE_STATUSr_AFE_SIGNAL_DETECTf_SET BCMI_TSC_XGXS_RX_X4_PMA_PMD_LIVE_STATUSr_AFE_SIGNAL_DETECTf_SET
#define RX_X4_PMA_PMD_LIVE_STATUSr_SIGNAL_OKf_GET BCMI_TSC_XGXS_RX_X4_PMA_PMD_LIVE_STATUSr_SIGNAL_OKf_GET
#define RX_X4_PMA_PMD_LIVE_STATUSr_SIGNAL_OKf_SET BCMI_TSC_XGXS_RX_X4_PMA_PMD_LIVE_STATUSr_SIGNAL_OKf_SET
#define READ_RX_X4_PMA_PMD_LIVE_STATUSr BCMI_TSC_XGXS_READ_RX_X4_PMA_PMD_LIVE_STATUSr
#define WRITE_RX_X4_PMA_PMD_LIVE_STATUSr BCMI_TSC_XGXS_WRITE_RX_X4_PMA_PMD_LIVE_STATUSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X4_PMA_PMD_LIVE_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X4_PMA_PMD_LATCHED_STATUS
 * BLOCKS:   RX_X4_STATUS1
 * REGADDR:  0xc151
 * DESC:     "Latched status of PMA/PMD Information": 00000000
 * SIZE:     32
 * FIELDS:
 *     SIGNAL_OK_LL     
 *     SIGNAL_OK_LH     
 *     AFE_SIGNAL_DETECT_LL 
 *     AFE_SIGNAL_DETECT_LH 
 *     EXTERNAL_SIGNAL_DETECT_LL 
 *     EXTERNAL_SIGNAL_DETECT_LH 
 *     PMD_LOCK_LL      
 *     PMD_LOCK_LH      
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X4_PMA_PMD_LATCHED_STATUSr (0x0000c151 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X4_PMA_PMD_LATCHED_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_PMA_PMD_LATCHED_STATUS.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X4_PMA_PMD_LATCHED_STATUSr_s {
	uint32_t v[1];
	uint32_t rx_x4_pma_pmd_latched_status[1];
	uint32_t _rx_x4_pma_pmd_latched_status;
} BCMI_TSC_XGXS_RX_X4_PMA_PMD_LATCHED_STATUSr_t;

#define BCMI_TSC_XGXS_RX_X4_PMA_PMD_LATCHED_STATUSr_CLR(r) (r).rx_x4_pma_pmd_latched_status[0] = 0
#define BCMI_TSC_XGXS_RX_X4_PMA_PMD_LATCHED_STATUSr_SET(r,d) (r).rx_x4_pma_pmd_latched_status[0] = d
#define BCMI_TSC_XGXS_RX_X4_PMA_PMD_LATCHED_STATUSr_GET(r) (r).rx_x4_pma_pmd_latched_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X4_PMA_PMD_LATCHED_STATUSr_RESERVED0f_GET(r) ((((r).rx_x4_pma_pmd_latched_status[0]) >> 8) & 0xff)
#define BCMI_TSC_XGXS_RX_X4_PMA_PMD_LATCHED_STATUSr_RESERVED0f_SET(r,f) (r).rx_x4_pma_pmd_latched_status[0]=(((r).rx_x4_pma_pmd_latched_status[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCMI_TSC_XGXS_RX_X4_PMA_PMD_LATCHED_STATUSr_PMD_LOCK_LHf_GET(r) ((((r).rx_x4_pma_pmd_latched_status[0]) >> 7) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_PMA_PMD_LATCHED_STATUSr_PMD_LOCK_LHf_SET(r,f) (r).rx_x4_pma_pmd_latched_status[0]=(((r).rx_x4_pma_pmd_latched_status[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCMI_TSC_XGXS_RX_X4_PMA_PMD_LATCHED_STATUSr_PMD_LOCK_LLf_GET(r) ((((r).rx_x4_pma_pmd_latched_status[0]) >> 6) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_PMA_PMD_LATCHED_STATUSr_PMD_LOCK_LLf_SET(r,f) (r).rx_x4_pma_pmd_latched_status[0]=(((r).rx_x4_pma_pmd_latched_status[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCMI_TSC_XGXS_RX_X4_PMA_PMD_LATCHED_STATUSr_EXTERNAL_SIGNAL_DETECT_LHf_GET(r) ((((r).rx_x4_pma_pmd_latched_status[0]) >> 5) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_PMA_PMD_LATCHED_STATUSr_EXTERNAL_SIGNAL_DETECT_LHf_SET(r,f) (r).rx_x4_pma_pmd_latched_status[0]=(((r).rx_x4_pma_pmd_latched_status[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCMI_TSC_XGXS_RX_X4_PMA_PMD_LATCHED_STATUSr_EXTERNAL_SIGNAL_DETECT_LLf_GET(r) ((((r).rx_x4_pma_pmd_latched_status[0]) >> 4) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_PMA_PMD_LATCHED_STATUSr_EXTERNAL_SIGNAL_DETECT_LLf_SET(r,f) (r).rx_x4_pma_pmd_latched_status[0]=(((r).rx_x4_pma_pmd_latched_status[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCMI_TSC_XGXS_RX_X4_PMA_PMD_LATCHED_STATUSr_AFE_SIGNAL_DETECT_LHf_GET(r) ((((r).rx_x4_pma_pmd_latched_status[0]) >> 3) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_PMA_PMD_LATCHED_STATUSr_AFE_SIGNAL_DETECT_LHf_SET(r,f) (r).rx_x4_pma_pmd_latched_status[0]=(((r).rx_x4_pma_pmd_latched_status[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCMI_TSC_XGXS_RX_X4_PMA_PMD_LATCHED_STATUSr_AFE_SIGNAL_DETECT_LLf_GET(r) ((((r).rx_x4_pma_pmd_latched_status[0]) >> 2) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_PMA_PMD_LATCHED_STATUSr_AFE_SIGNAL_DETECT_LLf_SET(r,f) (r).rx_x4_pma_pmd_latched_status[0]=(((r).rx_x4_pma_pmd_latched_status[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCMI_TSC_XGXS_RX_X4_PMA_PMD_LATCHED_STATUSr_SIGNAL_OK_LHf_GET(r) ((((r).rx_x4_pma_pmd_latched_status[0]) >> 1) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_PMA_PMD_LATCHED_STATUSr_SIGNAL_OK_LHf_SET(r,f) (r).rx_x4_pma_pmd_latched_status[0]=(((r).rx_x4_pma_pmd_latched_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCMI_TSC_XGXS_RX_X4_PMA_PMD_LATCHED_STATUSr_SIGNAL_OK_LLf_GET(r) (((r).rx_x4_pma_pmd_latched_status[0]) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_PMA_PMD_LATCHED_STATUSr_SIGNAL_OK_LLf_SET(r,f) (r).rx_x4_pma_pmd_latched_status[0]=(((r).rx_x4_pma_pmd_latched_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access RX_X4_PMA_PMD_LATCHED_STATUS.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X4_PMA_PMD_LATCHED_STATUSr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X4_PMA_PMD_LATCHED_STATUSr,(_r._rx_x4_pma_pmd_latched_status))
#define BCMI_TSC_XGXS_WRITE_RX_X4_PMA_PMD_LATCHED_STATUSr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X4_PMA_PMD_LATCHED_STATUSr,(_r._rx_x4_pma_pmd_latched_status))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_PMA_PMD_LATCHED_STATUSr BCMI_TSC_XGXS_RX_X4_PMA_PMD_LATCHED_STATUSr
#define RX_X4_PMA_PMD_LATCHED_STATUSr_SIZE BCMI_TSC_XGXS_RX_X4_PMA_PMD_LATCHED_STATUSr_SIZE
typedef BCMI_TSC_XGXS_RX_X4_PMA_PMD_LATCHED_STATUSr_t RX_X4_PMA_PMD_LATCHED_STATUSr_t;
#define RX_X4_PMA_PMD_LATCHED_STATUSr_CLR BCMI_TSC_XGXS_RX_X4_PMA_PMD_LATCHED_STATUSr_CLR
#define RX_X4_PMA_PMD_LATCHED_STATUSr_SET BCMI_TSC_XGXS_RX_X4_PMA_PMD_LATCHED_STATUSr_SET
#define RX_X4_PMA_PMD_LATCHED_STATUSr_GET BCMI_TSC_XGXS_RX_X4_PMA_PMD_LATCHED_STATUSr_GET
#define RX_X4_PMA_PMD_LATCHED_STATUSr_RESERVED0f_GET BCMI_TSC_XGXS_RX_X4_PMA_PMD_LATCHED_STATUSr_RESERVED0f_GET
#define RX_X4_PMA_PMD_LATCHED_STATUSr_RESERVED0f_SET BCMI_TSC_XGXS_RX_X4_PMA_PMD_LATCHED_STATUSr_RESERVED0f_SET
#define RX_X4_PMA_PMD_LATCHED_STATUSr_PMD_LOCK_LHf_GET BCMI_TSC_XGXS_RX_X4_PMA_PMD_LATCHED_STATUSr_PMD_LOCK_LHf_GET
#define RX_X4_PMA_PMD_LATCHED_STATUSr_PMD_LOCK_LHf_SET BCMI_TSC_XGXS_RX_X4_PMA_PMD_LATCHED_STATUSr_PMD_LOCK_LHf_SET
#define RX_X4_PMA_PMD_LATCHED_STATUSr_PMD_LOCK_LLf_GET BCMI_TSC_XGXS_RX_X4_PMA_PMD_LATCHED_STATUSr_PMD_LOCK_LLf_GET
#define RX_X4_PMA_PMD_LATCHED_STATUSr_PMD_LOCK_LLf_SET BCMI_TSC_XGXS_RX_X4_PMA_PMD_LATCHED_STATUSr_PMD_LOCK_LLf_SET
#define RX_X4_PMA_PMD_LATCHED_STATUSr_EXTERNAL_SIGNAL_DETECT_LHf_GET BCMI_TSC_XGXS_RX_X4_PMA_PMD_LATCHED_STATUSr_EXTERNAL_SIGNAL_DETECT_LHf_GET
#define RX_X4_PMA_PMD_LATCHED_STATUSr_EXTERNAL_SIGNAL_DETECT_LHf_SET BCMI_TSC_XGXS_RX_X4_PMA_PMD_LATCHED_STATUSr_EXTERNAL_SIGNAL_DETECT_LHf_SET
#define RX_X4_PMA_PMD_LATCHED_STATUSr_EXTERNAL_SIGNAL_DETECT_LLf_GET BCMI_TSC_XGXS_RX_X4_PMA_PMD_LATCHED_STATUSr_EXTERNAL_SIGNAL_DETECT_LLf_GET
#define RX_X4_PMA_PMD_LATCHED_STATUSr_EXTERNAL_SIGNAL_DETECT_LLf_SET BCMI_TSC_XGXS_RX_X4_PMA_PMD_LATCHED_STATUSr_EXTERNAL_SIGNAL_DETECT_LLf_SET
#define RX_X4_PMA_PMD_LATCHED_STATUSr_AFE_SIGNAL_DETECT_LHf_GET BCMI_TSC_XGXS_RX_X4_PMA_PMD_LATCHED_STATUSr_AFE_SIGNAL_DETECT_LHf_GET
#define RX_X4_PMA_PMD_LATCHED_STATUSr_AFE_SIGNAL_DETECT_LHf_SET BCMI_TSC_XGXS_RX_X4_PMA_PMD_LATCHED_STATUSr_AFE_SIGNAL_DETECT_LHf_SET
#define RX_X4_PMA_PMD_LATCHED_STATUSr_AFE_SIGNAL_DETECT_LLf_GET BCMI_TSC_XGXS_RX_X4_PMA_PMD_LATCHED_STATUSr_AFE_SIGNAL_DETECT_LLf_GET
#define RX_X4_PMA_PMD_LATCHED_STATUSr_AFE_SIGNAL_DETECT_LLf_SET BCMI_TSC_XGXS_RX_X4_PMA_PMD_LATCHED_STATUSr_AFE_SIGNAL_DETECT_LLf_SET
#define RX_X4_PMA_PMD_LATCHED_STATUSr_SIGNAL_OK_LHf_GET BCMI_TSC_XGXS_RX_X4_PMA_PMD_LATCHED_STATUSr_SIGNAL_OK_LHf_GET
#define RX_X4_PMA_PMD_LATCHED_STATUSr_SIGNAL_OK_LHf_SET BCMI_TSC_XGXS_RX_X4_PMA_PMD_LATCHED_STATUSr_SIGNAL_OK_LHf_SET
#define RX_X4_PMA_PMD_LATCHED_STATUSr_SIGNAL_OK_LLf_GET BCMI_TSC_XGXS_RX_X4_PMA_PMD_LATCHED_STATUSr_SIGNAL_OK_LLf_GET
#define RX_X4_PMA_PMD_LATCHED_STATUSr_SIGNAL_OK_LLf_SET BCMI_TSC_XGXS_RX_X4_PMA_PMD_LATCHED_STATUSr_SIGNAL_OK_LLf_SET
#define READ_RX_X4_PMA_PMD_LATCHED_STATUSr BCMI_TSC_XGXS_READ_RX_X4_PMA_PMD_LATCHED_STATUSr
#define WRITE_RX_X4_PMA_PMD_LATCHED_STATUSr BCMI_TSC_XGXS_WRITE_RX_X4_PMA_PMD_LATCHED_STATUSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X4_PMA_PMD_LATCHED_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X4_PCS_LATCHED_STATUS_1
 * BLOCKS:   RX_X4_STATUS1
 * REGADDR:  0xc152
 * DESC:     "Latched status of PCS Information": 00000000
 * SIZE:     32
 * FIELDS:
 *     RESERVED0        
 *     LPI_RECEIVED_LH  
 *     RESERVED_ORDERED_BYTE_3 
 *     RESERVED_ORDERED_SET_LH 
 *     LINK_INTERRUPT_LH 
 *     REMOTE_FAULT_LH  
 *     LOCAL_FAULT_LH   
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_1r (0x0000c152 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_PCS_LATCHED_STATUS_1.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_1r_s {
	uint32_t v[1];
	uint32_t rx_x4_pcs_latched_status_1[1];
	uint32_t _rx_x4_pcs_latched_status_1;
} BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_1r_t;

#define BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_1r_CLR(r) (r).rx_x4_pcs_latched_status_1[0] = 0
#define BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_1r_SET(r,d) (r).rx_x4_pcs_latched_status_1[0] = d
#define BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_1r_GET(r) (r).rx_x4_pcs_latched_status_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_1r_LOCAL_FAULT_LHf_GET(r) ((((r).rx_x4_pcs_latched_status_1[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_1r_LOCAL_FAULT_LHf_SET(r,f) (r).rx_x4_pcs_latched_status_1[0]=(((r).rx_x4_pcs_latched_status_1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_1r_REMOTE_FAULT_LHf_GET(r) ((((r).rx_x4_pcs_latched_status_1[0]) >> 14) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_1r_REMOTE_FAULT_LHf_SET(r,f) (r).rx_x4_pcs_latched_status_1[0]=(((r).rx_x4_pcs_latched_status_1[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_1r_LINK_INTERRUPT_LHf_GET(r) ((((r).rx_x4_pcs_latched_status_1[0]) >> 13) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_1r_LINK_INTERRUPT_LHf_SET(r,f) (r).rx_x4_pcs_latched_status_1[0]=(((r).rx_x4_pcs_latched_status_1[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_1r_RESERVED_ORDERED_SET_LHf_GET(r) ((((r).rx_x4_pcs_latched_status_1[0]) >> 12) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_1r_RESERVED_ORDERED_SET_LHf_SET(r,f) (r).rx_x4_pcs_latched_status_1[0]=(((r).rx_x4_pcs_latched_status_1[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_1r_RESERVED_ORDERED_BYTE_3f_GET(r) ((((r).rx_x4_pcs_latched_status_1[0]) >> 4) & 0xff)
#define BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_1r_RESERVED_ORDERED_BYTE_3f_SET(r,f) (r).rx_x4_pcs_latched_status_1[0]=(((r).rx_x4_pcs_latched_status_1[0] & ~((uint32_t)0xff << 4)) | ((((uint32_t)f) & 0xff) << 4))
#define BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_1r_LPI_RECEIVED_LHf_GET(r) ((((r).rx_x4_pcs_latched_status_1[0]) >> 3) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_1r_LPI_RECEIVED_LHf_SET(r,f) (r).rx_x4_pcs_latched_status_1[0]=(((r).rx_x4_pcs_latched_status_1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_1r_RESERVED0f_GET(r) (((r).rx_x4_pcs_latched_status_1[0]) & 0x7)
#define BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_1r_RESERVED0f_SET(r,f) (r).rx_x4_pcs_latched_status_1[0]=(((r).rx_x4_pcs_latched_status_1[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))

/*
 * These macros can be used to access RX_X4_PCS_LATCHED_STATUS_1.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X4_PCS_LATCHED_STATUS_1r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_1r,(_r._rx_x4_pcs_latched_status_1))
#define BCMI_TSC_XGXS_WRITE_RX_X4_PCS_LATCHED_STATUS_1r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_1r,(_r._rx_x4_pcs_latched_status_1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_PCS_LATCHED_STATUS_1r BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_1r
#define RX_X4_PCS_LATCHED_STATUS_1r_SIZE BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_1r_SIZE
typedef BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_1r_t RX_X4_PCS_LATCHED_STATUS_1r_t;
#define RX_X4_PCS_LATCHED_STATUS_1r_CLR BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_1r_CLR
#define RX_X4_PCS_LATCHED_STATUS_1r_SET BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_1r_SET
#define RX_X4_PCS_LATCHED_STATUS_1r_GET BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_1r_GET
#define RX_X4_PCS_LATCHED_STATUS_1r_LOCAL_FAULT_LHf_GET BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_1r_LOCAL_FAULT_LHf_GET
#define RX_X4_PCS_LATCHED_STATUS_1r_LOCAL_FAULT_LHf_SET BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_1r_LOCAL_FAULT_LHf_SET
#define RX_X4_PCS_LATCHED_STATUS_1r_REMOTE_FAULT_LHf_GET BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_1r_REMOTE_FAULT_LHf_GET
#define RX_X4_PCS_LATCHED_STATUS_1r_REMOTE_FAULT_LHf_SET BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_1r_REMOTE_FAULT_LHf_SET
#define RX_X4_PCS_LATCHED_STATUS_1r_LINK_INTERRUPT_LHf_GET BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_1r_LINK_INTERRUPT_LHf_GET
#define RX_X4_PCS_LATCHED_STATUS_1r_LINK_INTERRUPT_LHf_SET BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_1r_LINK_INTERRUPT_LHf_SET
#define RX_X4_PCS_LATCHED_STATUS_1r_RESERVED_ORDERED_SET_LHf_GET BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_1r_RESERVED_ORDERED_SET_LHf_GET
#define RX_X4_PCS_LATCHED_STATUS_1r_RESERVED_ORDERED_SET_LHf_SET BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_1r_RESERVED_ORDERED_SET_LHf_SET
#define RX_X4_PCS_LATCHED_STATUS_1r_RESERVED_ORDERED_BYTE_3f_GET BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_1r_RESERVED_ORDERED_BYTE_3f_GET
#define RX_X4_PCS_LATCHED_STATUS_1r_RESERVED_ORDERED_BYTE_3f_SET BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_1r_RESERVED_ORDERED_BYTE_3f_SET
#define RX_X4_PCS_LATCHED_STATUS_1r_LPI_RECEIVED_LHf_GET BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_1r_LPI_RECEIVED_LHf_GET
#define RX_X4_PCS_LATCHED_STATUS_1r_LPI_RECEIVED_LHf_SET BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_1r_LPI_RECEIVED_LHf_SET
#define RX_X4_PCS_LATCHED_STATUS_1r_RESERVED0f_GET BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_1r_RESERVED0f_GET
#define RX_X4_PCS_LATCHED_STATUS_1r_RESERVED0f_SET BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_1r_RESERVED0f_SET
#define READ_RX_X4_PCS_LATCHED_STATUS_1r BCMI_TSC_XGXS_READ_RX_X4_PCS_LATCHED_STATUS_1r
#define WRITE_RX_X4_PCS_LATCHED_STATUS_1r BCMI_TSC_XGXS_WRITE_RX_X4_PCS_LATCHED_STATUS_1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X4_PCS_LATCHED_STATUS_0
 * BLOCKS:   RX_X4_STATUS1
 * REGADDR:  0xc153
 * DESC:     "Latched status of PCS Information": 00000000
 * SIZE:     32
 * FIELDS:
 *     RESERVED0        
 *     SYNC_STATUS_LL   
 *     SYNC_STATUS_LH   
 *     LINK_STATUS_LL   
 *     LINK_STATUS_LH   
 *     HI_BER_LL        
 *     HI_BER_LH        
 *     DESKEW_STATUS_LL 
 *     DESKEW_STATUS_LH 
 *     AM_LOCK_LL       
 *     AM_LOCK_LH       
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_0r (0x0000c153 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_PCS_LATCHED_STATUS_0.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_0r_s {
	uint32_t v[1];
	uint32_t rx_x4_pcs_latched_status_0[1];
	uint32_t _rx_x4_pcs_latched_status_0;
} BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_0r_t;

#define BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_0r_CLR(r) (r).rx_x4_pcs_latched_status_0[0] = 0
#define BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_0r_SET(r,d) (r).rx_x4_pcs_latched_status_0[0] = d
#define BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_0r_GET(r) (r).rx_x4_pcs_latched_status_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_0r_AM_LOCK_LHf_GET(r) ((((r).rx_x4_pcs_latched_status_0[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_0r_AM_LOCK_LHf_SET(r,f) (r).rx_x4_pcs_latched_status_0[0]=(((r).rx_x4_pcs_latched_status_0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_0r_AM_LOCK_LLf_GET(r) ((((r).rx_x4_pcs_latched_status_0[0]) >> 14) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_0r_AM_LOCK_LLf_SET(r,f) (r).rx_x4_pcs_latched_status_0[0]=(((r).rx_x4_pcs_latched_status_0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_0r_DESKEW_STATUS_LHf_GET(r) ((((r).rx_x4_pcs_latched_status_0[0]) >> 13) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_0r_DESKEW_STATUS_LHf_SET(r,f) (r).rx_x4_pcs_latched_status_0[0]=(((r).rx_x4_pcs_latched_status_0[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_0r_DESKEW_STATUS_LLf_GET(r) ((((r).rx_x4_pcs_latched_status_0[0]) >> 12) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_0r_DESKEW_STATUS_LLf_SET(r,f) (r).rx_x4_pcs_latched_status_0[0]=(((r).rx_x4_pcs_latched_status_0[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_0r_HI_BER_LHf_GET(r) ((((r).rx_x4_pcs_latched_status_0[0]) >> 11) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_0r_HI_BER_LHf_SET(r,f) (r).rx_x4_pcs_latched_status_0[0]=(((r).rx_x4_pcs_latched_status_0[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_0r_HI_BER_LLf_GET(r) ((((r).rx_x4_pcs_latched_status_0[0]) >> 10) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_0r_HI_BER_LLf_SET(r,f) (r).rx_x4_pcs_latched_status_0[0]=(((r).rx_x4_pcs_latched_status_0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_0r_LINK_STATUS_LHf_GET(r) ((((r).rx_x4_pcs_latched_status_0[0]) >> 9) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_0r_LINK_STATUS_LHf_SET(r,f) (r).rx_x4_pcs_latched_status_0[0]=(((r).rx_x4_pcs_latched_status_0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_0r_LINK_STATUS_LLf_GET(r) ((((r).rx_x4_pcs_latched_status_0[0]) >> 8) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_0r_LINK_STATUS_LLf_SET(r,f) (r).rx_x4_pcs_latched_status_0[0]=(((r).rx_x4_pcs_latched_status_0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_0r_SYNC_STATUS_LHf_GET(r) ((((r).rx_x4_pcs_latched_status_0[0]) >> 7) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_0r_SYNC_STATUS_LHf_SET(r,f) (r).rx_x4_pcs_latched_status_0[0]=(((r).rx_x4_pcs_latched_status_0[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_0r_SYNC_STATUS_LLf_GET(r) ((((r).rx_x4_pcs_latched_status_0[0]) >> 6) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_0r_SYNC_STATUS_LLf_SET(r,f) (r).rx_x4_pcs_latched_status_0[0]=(((r).rx_x4_pcs_latched_status_0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_0r_RESERVED0f_GET(r) (((r).rx_x4_pcs_latched_status_0[0]) & 0x3f)
#define BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_0r_RESERVED0f_SET(r,f) (r).rx_x4_pcs_latched_status_0[0]=(((r).rx_x4_pcs_latched_status_0[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))

/*
 * These macros can be used to access RX_X4_PCS_LATCHED_STATUS_0.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X4_PCS_LATCHED_STATUS_0r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_0r,(_r._rx_x4_pcs_latched_status_0))
#define BCMI_TSC_XGXS_WRITE_RX_X4_PCS_LATCHED_STATUS_0r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_0r,(_r._rx_x4_pcs_latched_status_0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_PCS_LATCHED_STATUS_0r BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_0r
#define RX_X4_PCS_LATCHED_STATUS_0r_SIZE BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_0r_SIZE
typedef BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_0r_t RX_X4_PCS_LATCHED_STATUS_0r_t;
#define RX_X4_PCS_LATCHED_STATUS_0r_CLR BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_0r_CLR
#define RX_X4_PCS_LATCHED_STATUS_0r_SET BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_0r_SET
#define RX_X4_PCS_LATCHED_STATUS_0r_GET BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_0r_GET
#define RX_X4_PCS_LATCHED_STATUS_0r_AM_LOCK_LHf_GET BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_0r_AM_LOCK_LHf_GET
#define RX_X4_PCS_LATCHED_STATUS_0r_AM_LOCK_LHf_SET BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_0r_AM_LOCK_LHf_SET
#define RX_X4_PCS_LATCHED_STATUS_0r_AM_LOCK_LLf_GET BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_0r_AM_LOCK_LLf_GET
#define RX_X4_PCS_LATCHED_STATUS_0r_AM_LOCK_LLf_SET BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_0r_AM_LOCK_LLf_SET
#define RX_X4_PCS_LATCHED_STATUS_0r_DESKEW_STATUS_LHf_GET BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_0r_DESKEW_STATUS_LHf_GET
#define RX_X4_PCS_LATCHED_STATUS_0r_DESKEW_STATUS_LHf_SET BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_0r_DESKEW_STATUS_LHf_SET
#define RX_X4_PCS_LATCHED_STATUS_0r_DESKEW_STATUS_LLf_GET BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_0r_DESKEW_STATUS_LLf_GET
#define RX_X4_PCS_LATCHED_STATUS_0r_DESKEW_STATUS_LLf_SET BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_0r_DESKEW_STATUS_LLf_SET
#define RX_X4_PCS_LATCHED_STATUS_0r_HI_BER_LHf_GET BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_0r_HI_BER_LHf_GET
#define RX_X4_PCS_LATCHED_STATUS_0r_HI_BER_LHf_SET BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_0r_HI_BER_LHf_SET
#define RX_X4_PCS_LATCHED_STATUS_0r_HI_BER_LLf_GET BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_0r_HI_BER_LLf_GET
#define RX_X4_PCS_LATCHED_STATUS_0r_HI_BER_LLf_SET BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_0r_HI_BER_LLf_SET
#define RX_X4_PCS_LATCHED_STATUS_0r_LINK_STATUS_LHf_GET BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_0r_LINK_STATUS_LHf_GET
#define RX_X4_PCS_LATCHED_STATUS_0r_LINK_STATUS_LHf_SET BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_0r_LINK_STATUS_LHf_SET
#define RX_X4_PCS_LATCHED_STATUS_0r_LINK_STATUS_LLf_GET BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_0r_LINK_STATUS_LLf_GET
#define RX_X4_PCS_LATCHED_STATUS_0r_LINK_STATUS_LLf_SET BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_0r_LINK_STATUS_LLf_SET
#define RX_X4_PCS_LATCHED_STATUS_0r_SYNC_STATUS_LHf_GET BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_0r_SYNC_STATUS_LHf_GET
#define RX_X4_PCS_LATCHED_STATUS_0r_SYNC_STATUS_LHf_SET BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_0r_SYNC_STATUS_LHf_SET
#define RX_X4_PCS_LATCHED_STATUS_0r_SYNC_STATUS_LLf_GET BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_0r_SYNC_STATUS_LLf_GET
#define RX_X4_PCS_LATCHED_STATUS_0r_SYNC_STATUS_LLf_SET BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_0r_SYNC_STATUS_LLf_SET
#define RX_X4_PCS_LATCHED_STATUS_0r_RESERVED0f_GET BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_0r_RESERVED0f_GET
#define RX_X4_PCS_LATCHED_STATUS_0r_RESERVED0f_SET BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_0r_RESERVED0f_SET
#define READ_RX_X4_PCS_LATCHED_STATUS_0r BCMI_TSC_XGXS_READ_RX_X4_PCS_LATCHED_STATUS_0r
#define WRITE_RX_X4_PCS_LATCHED_STATUS_0r BCMI_TSC_XGXS_WRITE_RX_X4_PCS_LATCHED_STATUS_0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X4_PCS_LATCHED_STATUS_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X4_PCS_LIVE_STATUS
 * BLOCKS:   RX_X4_STATUS1
 * REGADDR:  0xc154
 * DESC:     LiveLatched status of PCS Information": 00000000
 * SIZE:     32
 * FIELDS:
 *     SYNC_STATUS      
 *     LINK_STATUS      
 *     HI_BER           
 *     DESKEW_STATUS    
 *     AM_LOCK          
 *     LPI_RECEIVED     
 *     LINK_INTERRUPT   
 *     REMOTE_FAULT     
 *     LOCAL_FAULT      
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X4_PCS_LIVE_STATUSr (0x0000c154 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X4_PCS_LIVE_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_PCS_LIVE_STATUS.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X4_PCS_LIVE_STATUSr_s {
	uint32_t v[1];
	uint32_t rx_x4_pcs_live_status[1];
	uint32_t _rx_x4_pcs_live_status;
} BCMI_TSC_XGXS_RX_X4_PCS_LIVE_STATUSr_t;

#define BCMI_TSC_XGXS_RX_X4_PCS_LIVE_STATUSr_CLR(r) (r).rx_x4_pcs_live_status[0] = 0
#define BCMI_TSC_XGXS_RX_X4_PCS_LIVE_STATUSr_SET(r,d) (r).rx_x4_pcs_live_status[0] = d
#define BCMI_TSC_XGXS_RX_X4_PCS_LIVE_STATUSr_GET(r) (r).rx_x4_pcs_live_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X4_PCS_LIVE_STATUSr_RESERVED0f_GET(r) ((((r).rx_x4_pcs_live_status[0]) >> 9) & 0x7f)
#define BCMI_TSC_XGXS_RX_X4_PCS_LIVE_STATUSr_RESERVED0f_SET(r,f) (r).rx_x4_pcs_live_status[0]=(((r).rx_x4_pcs_live_status[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))
#define BCMI_TSC_XGXS_RX_X4_PCS_LIVE_STATUSr_LOCAL_FAULTf_GET(r) ((((r).rx_x4_pcs_live_status[0]) >> 8) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_PCS_LIVE_STATUSr_LOCAL_FAULTf_SET(r,f) (r).rx_x4_pcs_live_status[0]=(((r).rx_x4_pcs_live_status[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCMI_TSC_XGXS_RX_X4_PCS_LIVE_STATUSr_REMOTE_FAULTf_GET(r) ((((r).rx_x4_pcs_live_status[0]) >> 7) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_PCS_LIVE_STATUSr_REMOTE_FAULTf_SET(r,f) (r).rx_x4_pcs_live_status[0]=(((r).rx_x4_pcs_live_status[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCMI_TSC_XGXS_RX_X4_PCS_LIVE_STATUSr_LINK_INTERRUPTf_GET(r) ((((r).rx_x4_pcs_live_status[0]) >> 6) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_PCS_LIVE_STATUSr_LINK_INTERRUPTf_SET(r,f) (r).rx_x4_pcs_live_status[0]=(((r).rx_x4_pcs_live_status[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCMI_TSC_XGXS_RX_X4_PCS_LIVE_STATUSr_LPI_RECEIVEDf_GET(r) ((((r).rx_x4_pcs_live_status[0]) >> 5) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_PCS_LIVE_STATUSr_LPI_RECEIVEDf_SET(r,f) (r).rx_x4_pcs_live_status[0]=(((r).rx_x4_pcs_live_status[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCMI_TSC_XGXS_RX_X4_PCS_LIVE_STATUSr_AM_LOCKf_GET(r) ((((r).rx_x4_pcs_live_status[0]) >> 4) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_PCS_LIVE_STATUSr_AM_LOCKf_SET(r,f) (r).rx_x4_pcs_live_status[0]=(((r).rx_x4_pcs_live_status[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCMI_TSC_XGXS_RX_X4_PCS_LIVE_STATUSr_DESKEW_STATUSf_GET(r) ((((r).rx_x4_pcs_live_status[0]) >> 3) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_PCS_LIVE_STATUSr_DESKEW_STATUSf_SET(r,f) (r).rx_x4_pcs_live_status[0]=(((r).rx_x4_pcs_live_status[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCMI_TSC_XGXS_RX_X4_PCS_LIVE_STATUSr_HI_BERf_GET(r) ((((r).rx_x4_pcs_live_status[0]) >> 2) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_PCS_LIVE_STATUSr_HI_BERf_SET(r,f) (r).rx_x4_pcs_live_status[0]=(((r).rx_x4_pcs_live_status[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCMI_TSC_XGXS_RX_X4_PCS_LIVE_STATUSr_LINK_STATUSf_GET(r) ((((r).rx_x4_pcs_live_status[0]) >> 1) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_PCS_LIVE_STATUSr_LINK_STATUSf_SET(r,f) (r).rx_x4_pcs_live_status[0]=(((r).rx_x4_pcs_live_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCMI_TSC_XGXS_RX_X4_PCS_LIVE_STATUSr_SYNC_STATUSf_GET(r) (((r).rx_x4_pcs_live_status[0]) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_PCS_LIVE_STATUSr_SYNC_STATUSf_SET(r,f) (r).rx_x4_pcs_live_status[0]=(((r).rx_x4_pcs_live_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access RX_X4_PCS_LIVE_STATUS.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X4_PCS_LIVE_STATUSr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X4_PCS_LIVE_STATUSr,(_r._rx_x4_pcs_live_status))
#define BCMI_TSC_XGXS_WRITE_RX_X4_PCS_LIVE_STATUSr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X4_PCS_LIVE_STATUSr,(_r._rx_x4_pcs_live_status))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_PCS_LIVE_STATUSr BCMI_TSC_XGXS_RX_X4_PCS_LIVE_STATUSr
#define RX_X4_PCS_LIVE_STATUSr_SIZE BCMI_TSC_XGXS_RX_X4_PCS_LIVE_STATUSr_SIZE
typedef BCMI_TSC_XGXS_RX_X4_PCS_LIVE_STATUSr_t RX_X4_PCS_LIVE_STATUSr_t;
#define RX_X4_PCS_LIVE_STATUSr_CLR BCMI_TSC_XGXS_RX_X4_PCS_LIVE_STATUSr_CLR
#define RX_X4_PCS_LIVE_STATUSr_SET BCMI_TSC_XGXS_RX_X4_PCS_LIVE_STATUSr_SET
#define RX_X4_PCS_LIVE_STATUSr_GET BCMI_TSC_XGXS_RX_X4_PCS_LIVE_STATUSr_GET
#define RX_X4_PCS_LIVE_STATUSr_RESERVED0f_GET BCMI_TSC_XGXS_RX_X4_PCS_LIVE_STATUSr_RESERVED0f_GET
#define RX_X4_PCS_LIVE_STATUSr_RESERVED0f_SET BCMI_TSC_XGXS_RX_X4_PCS_LIVE_STATUSr_RESERVED0f_SET
#define RX_X4_PCS_LIVE_STATUSr_LOCAL_FAULTf_GET BCMI_TSC_XGXS_RX_X4_PCS_LIVE_STATUSr_LOCAL_FAULTf_GET
#define RX_X4_PCS_LIVE_STATUSr_LOCAL_FAULTf_SET BCMI_TSC_XGXS_RX_X4_PCS_LIVE_STATUSr_LOCAL_FAULTf_SET
#define RX_X4_PCS_LIVE_STATUSr_REMOTE_FAULTf_GET BCMI_TSC_XGXS_RX_X4_PCS_LIVE_STATUSr_REMOTE_FAULTf_GET
#define RX_X4_PCS_LIVE_STATUSr_REMOTE_FAULTf_SET BCMI_TSC_XGXS_RX_X4_PCS_LIVE_STATUSr_REMOTE_FAULTf_SET
#define RX_X4_PCS_LIVE_STATUSr_LINK_INTERRUPTf_GET BCMI_TSC_XGXS_RX_X4_PCS_LIVE_STATUSr_LINK_INTERRUPTf_GET
#define RX_X4_PCS_LIVE_STATUSr_LINK_INTERRUPTf_SET BCMI_TSC_XGXS_RX_X4_PCS_LIVE_STATUSr_LINK_INTERRUPTf_SET
#define RX_X4_PCS_LIVE_STATUSr_LPI_RECEIVEDf_GET BCMI_TSC_XGXS_RX_X4_PCS_LIVE_STATUSr_LPI_RECEIVEDf_GET
#define RX_X4_PCS_LIVE_STATUSr_LPI_RECEIVEDf_SET BCMI_TSC_XGXS_RX_X4_PCS_LIVE_STATUSr_LPI_RECEIVEDf_SET
#define RX_X4_PCS_LIVE_STATUSr_AM_LOCKf_GET BCMI_TSC_XGXS_RX_X4_PCS_LIVE_STATUSr_AM_LOCKf_GET
#define RX_X4_PCS_LIVE_STATUSr_AM_LOCKf_SET BCMI_TSC_XGXS_RX_X4_PCS_LIVE_STATUSr_AM_LOCKf_SET
#define RX_X4_PCS_LIVE_STATUSr_DESKEW_STATUSf_GET BCMI_TSC_XGXS_RX_X4_PCS_LIVE_STATUSr_DESKEW_STATUSf_GET
#define RX_X4_PCS_LIVE_STATUSr_DESKEW_STATUSf_SET BCMI_TSC_XGXS_RX_X4_PCS_LIVE_STATUSr_DESKEW_STATUSf_SET
#define RX_X4_PCS_LIVE_STATUSr_HI_BERf_GET BCMI_TSC_XGXS_RX_X4_PCS_LIVE_STATUSr_HI_BERf_GET
#define RX_X4_PCS_LIVE_STATUSr_HI_BERf_SET BCMI_TSC_XGXS_RX_X4_PCS_LIVE_STATUSr_HI_BERf_SET
#define RX_X4_PCS_LIVE_STATUSr_LINK_STATUSf_GET BCMI_TSC_XGXS_RX_X4_PCS_LIVE_STATUSr_LINK_STATUSf_GET
#define RX_X4_PCS_LIVE_STATUSr_LINK_STATUSf_SET BCMI_TSC_XGXS_RX_X4_PCS_LIVE_STATUSr_LINK_STATUSf_SET
#define RX_X4_PCS_LIVE_STATUSr_SYNC_STATUSf_GET BCMI_TSC_XGXS_RX_X4_PCS_LIVE_STATUSr_SYNC_STATUSf_GET
#define RX_X4_PCS_LIVE_STATUSr_SYNC_STATUSf_SET BCMI_TSC_XGXS_RX_X4_PCS_LIVE_STATUSr_SYNC_STATUSf_SET
#define READ_RX_X4_PCS_LIVE_STATUSr BCMI_TSC_XGXS_READ_RX_X4_PCS_LIVE_STATUSr
#define WRITE_RX_X4_PCS_LIVE_STATUSr BCMI_TSC_XGXS_WRITE_RX_X4_PCS_LIVE_STATUSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X4_PCS_LIVE_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X4_CL82_RX_AM_LATCHED_STATUS
 * BLOCKS:   RX_X4_STATUS1
 * REGADDR:  0xc155
 * DESC:     cl82 AM lock state machine latched status per lane: 00000000
 * SIZE:     32
 * FIELDS:
 *     AM_LOCK_HIS_STATE 
 *     AMRKR_SPACING_ERR_LATCH_MUX 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X4_CL82_RX_AM_LATCHED_STATUSr (0x0000c155 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X4_CL82_RX_AM_LATCHED_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_CL82_RX_AM_LATCHED_STATUS.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X4_CL82_RX_AM_LATCHED_STATUSr_s {
	uint32_t v[1];
	uint32_t rx_x4_cl82_rx_am_latched_status[1];
	uint32_t _rx_x4_cl82_rx_am_latched_status;
} BCMI_TSC_XGXS_RX_X4_CL82_RX_AM_LATCHED_STATUSr_t;

#define BCMI_TSC_XGXS_RX_X4_CL82_RX_AM_LATCHED_STATUSr_CLR(r) (r).rx_x4_cl82_rx_am_latched_status[0] = 0
#define BCMI_TSC_XGXS_RX_X4_CL82_RX_AM_LATCHED_STATUSr_SET(r,d) (r).rx_x4_cl82_rx_am_latched_status[0] = d
#define BCMI_TSC_XGXS_RX_X4_CL82_RX_AM_LATCHED_STATUSr_GET(r) (r).rx_x4_cl82_rx_am_latched_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X4_CL82_RX_AM_LATCHED_STATUSr_RESERVED0f_GET(r) ((((r).rx_x4_cl82_rx_am_latched_status[0]) >> 11) & 0x1f)
#define BCMI_TSC_XGXS_RX_X4_CL82_RX_AM_LATCHED_STATUSr_RESERVED0f_SET(r,f) (r).rx_x4_cl82_rx_am_latched_status[0]=(((r).rx_x4_cl82_rx_am_latched_status[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))
#define BCMI_TSC_XGXS_RX_X4_CL82_RX_AM_LATCHED_STATUSr_AMRKR_SPACING_ERR_LATCH_MUXf_GET(r) ((((r).rx_x4_cl82_rx_am_latched_status[0]) >> 10) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_CL82_RX_AM_LATCHED_STATUSr_AMRKR_SPACING_ERR_LATCH_MUXf_SET(r,f) (r).rx_x4_cl82_rx_am_latched_status[0]=(((r).rx_x4_cl82_rx_am_latched_status[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCMI_TSC_XGXS_RX_X4_CL82_RX_AM_LATCHED_STATUSr_AM_LOCK_HIS_STATEf_GET(r) (((r).rx_x4_cl82_rx_am_latched_status[0]) & 0x3ff)
#define BCMI_TSC_XGXS_RX_X4_CL82_RX_AM_LATCHED_STATUSr_AM_LOCK_HIS_STATEf_SET(r,f) (r).rx_x4_cl82_rx_am_latched_status[0]=(((r).rx_x4_cl82_rx_am_latched_status[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))

/*
 * These macros can be used to access RX_X4_CL82_RX_AM_LATCHED_STATUS.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X4_CL82_RX_AM_LATCHED_STATUSr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X4_CL82_RX_AM_LATCHED_STATUSr,(_r._rx_x4_cl82_rx_am_latched_status))
#define BCMI_TSC_XGXS_WRITE_RX_X4_CL82_RX_AM_LATCHED_STATUSr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X4_CL82_RX_AM_LATCHED_STATUSr,(_r._rx_x4_cl82_rx_am_latched_status))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_CL82_RX_AM_LATCHED_STATUSr BCMI_TSC_XGXS_RX_X4_CL82_RX_AM_LATCHED_STATUSr
#define RX_X4_CL82_RX_AM_LATCHED_STATUSr_SIZE BCMI_TSC_XGXS_RX_X4_CL82_RX_AM_LATCHED_STATUSr_SIZE
typedef BCMI_TSC_XGXS_RX_X4_CL82_RX_AM_LATCHED_STATUSr_t RX_X4_CL82_RX_AM_LATCHED_STATUSr_t;
#define RX_X4_CL82_RX_AM_LATCHED_STATUSr_CLR BCMI_TSC_XGXS_RX_X4_CL82_RX_AM_LATCHED_STATUSr_CLR
#define RX_X4_CL82_RX_AM_LATCHED_STATUSr_SET BCMI_TSC_XGXS_RX_X4_CL82_RX_AM_LATCHED_STATUSr_SET
#define RX_X4_CL82_RX_AM_LATCHED_STATUSr_GET BCMI_TSC_XGXS_RX_X4_CL82_RX_AM_LATCHED_STATUSr_GET
#define RX_X4_CL82_RX_AM_LATCHED_STATUSr_RESERVED0f_GET BCMI_TSC_XGXS_RX_X4_CL82_RX_AM_LATCHED_STATUSr_RESERVED0f_GET
#define RX_X4_CL82_RX_AM_LATCHED_STATUSr_RESERVED0f_SET BCMI_TSC_XGXS_RX_X4_CL82_RX_AM_LATCHED_STATUSr_RESERVED0f_SET
#define RX_X4_CL82_RX_AM_LATCHED_STATUSr_AMRKR_SPACING_ERR_LATCH_MUXf_GET BCMI_TSC_XGXS_RX_X4_CL82_RX_AM_LATCHED_STATUSr_AMRKR_SPACING_ERR_LATCH_MUXf_GET
#define RX_X4_CL82_RX_AM_LATCHED_STATUSr_AMRKR_SPACING_ERR_LATCH_MUXf_SET BCMI_TSC_XGXS_RX_X4_CL82_RX_AM_LATCHED_STATUSr_AMRKR_SPACING_ERR_LATCH_MUXf_SET
#define RX_X4_CL82_RX_AM_LATCHED_STATUSr_AM_LOCK_HIS_STATEf_GET BCMI_TSC_XGXS_RX_X4_CL82_RX_AM_LATCHED_STATUSr_AM_LOCK_HIS_STATEf_GET
#define RX_X4_CL82_RX_AM_LATCHED_STATUSr_AM_LOCK_HIS_STATEf_SET BCMI_TSC_XGXS_RX_X4_CL82_RX_AM_LATCHED_STATUSr_AM_LOCK_HIS_STATEf_SET
#define READ_RX_X4_CL82_RX_AM_LATCHED_STATUSr BCMI_TSC_XGXS_READ_RX_X4_CL82_RX_AM_LATCHED_STATUSr
#define WRITE_RX_X4_CL82_RX_AM_LATCHED_STATUSr BCMI_TSC_XGXS_WRITE_RX_X4_CL82_RX_AM_LATCHED_STATUSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X4_CL82_RX_AM_LATCHED_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X4_CL82_RX_AM_LIVE_STATUS
 * BLOCKS:   RX_X4_STATUS1
 * REGADDR:  0xc156
 * DESC:     cl82 AM lock state machine live status per lane: 00000000
 * SIZE:     32
 * FIELDS:
 *     AM_LOCK_STATE    
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X4_CL82_RX_AM_LIVE_STATUSr (0x0000c156 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X4_CL82_RX_AM_LIVE_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_CL82_RX_AM_LIVE_STATUS.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X4_CL82_RX_AM_LIVE_STATUSr_s {
	uint32_t v[1];
	uint32_t rx_x4_cl82_rx_am_live_status[1];
	uint32_t _rx_x4_cl82_rx_am_live_status;
} BCMI_TSC_XGXS_RX_X4_CL82_RX_AM_LIVE_STATUSr_t;

#define BCMI_TSC_XGXS_RX_X4_CL82_RX_AM_LIVE_STATUSr_CLR(r) (r).rx_x4_cl82_rx_am_live_status[0] = 0
#define BCMI_TSC_XGXS_RX_X4_CL82_RX_AM_LIVE_STATUSr_SET(r,d) (r).rx_x4_cl82_rx_am_live_status[0] = d
#define BCMI_TSC_XGXS_RX_X4_CL82_RX_AM_LIVE_STATUSr_GET(r) (r).rx_x4_cl82_rx_am_live_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X4_CL82_RX_AM_LIVE_STATUSr_RESERVED0f_GET(r) ((((r).rx_x4_cl82_rx_am_live_status[0]) >> 10) & 0x3f)
#define BCMI_TSC_XGXS_RX_X4_CL82_RX_AM_LIVE_STATUSr_RESERVED0f_SET(r,f) (r).rx_x4_cl82_rx_am_live_status[0]=(((r).rx_x4_cl82_rx_am_live_status[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))
#define BCMI_TSC_XGXS_RX_X4_CL82_RX_AM_LIVE_STATUSr_AM_LOCK_STATEf_GET(r) (((r).rx_x4_cl82_rx_am_live_status[0]) & 0x3ff)
#define BCMI_TSC_XGXS_RX_X4_CL82_RX_AM_LIVE_STATUSr_AM_LOCK_STATEf_SET(r,f) (r).rx_x4_cl82_rx_am_live_status[0]=(((r).rx_x4_cl82_rx_am_live_status[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))

/*
 * These macros can be used to access RX_X4_CL82_RX_AM_LIVE_STATUS.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X4_CL82_RX_AM_LIVE_STATUSr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X4_CL82_RX_AM_LIVE_STATUSr,(_r._rx_x4_cl82_rx_am_live_status))
#define BCMI_TSC_XGXS_WRITE_RX_X4_CL82_RX_AM_LIVE_STATUSr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X4_CL82_RX_AM_LIVE_STATUSr,(_r._rx_x4_cl82_rx_am_live_status))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_CL82_RX_AM_LIVE_STATUSr BCMI_TSC_XGXS_RX_X4_CL82_RX_AM_LIVE_STATUSr
#define RX_X4_CL82_RX_AM_LIVE_STATUSr_SIZE BCMI_TSC_XGXS_RX_X4_CL82_RX_AM_LIVE_STATUSr_SIZE
typedef BCMI_TSC_XGXS_RX_X4_CL82_RX_AM_LIVE_STATUSr_t RX_X4_CL82_RX_AM_LIVE_STATUSr_t;
#define RX_X4_CL82_RX_AM_LIVE_STATUSr_CLR BCMI_TSC_XGXS_RX_X4_CL82_RX_AM_LIVE_STATUSr_CLR
#define RX_X4_CL82_RX_AM_LIVE_STATUSr_SET BCMI_TSC_XGXS_RX_X4_CL82_RX_AM_LIVE_STATUSr_SET
#define RX_X4_CL82_RX_AM_LIVE_STATUSr_GET BCMI_TSC_XGXS_RX_X4_CL82_RX_AM_LIVE_STATUSr_GET
#define RX_X4_CL82_RX_AM_LIVE_STATUSr_RESERVED0f_GET BCMI_TSC_XGXS_RX_X4_CL82_RX_AM_LIVE_STATUSr_RESERVED0f_GET
#define RX_X4_CL82_RX_AM_LIVE_STATUSr_RESERVED0f_SET BCMI_TSC_XGXS_RX_X4_CL82_RX_AM_LIVE_STATUSr_RESERVED0f_SET
#define RX_X4_CL82_RX_AM_LIVE_STATUSr_AM_LOCK_STATEf_GET BCMI_TSC_XGXS_RX_X4_CL82_RX_AM_LIVE_STATUSr_AM_LOCK_STATEf_GET
#define RX_X4_CL82_RX_AM_LIVE_STATUSr_AM_LOCK_STATEf_SET BCMI_TSC_XGXS_RX_X4_CL82_RX_AM_LIVE_STATUSr_AM_LOCK_STATEf_SET
#define READ_RX_X4_CL82_RX_AM_LIVE_STATUSr BCMI_TSC_XGXS_READ_RX_X4_CL82_RX_AM_LIVE_STATUSr
#define WRITE_RX_X4_CL82_RX_AM_LIVE_STATUSr BCMI_TSC_XGXS_WRITE_RX_X4_CL82_RX_AM_LIVE_STATUSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X4_CL82_RX_AM_LIVE_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X4_TSC_12_FEC_0
 * BLOCKS:   RX_X4_CONTROL0
 * REGADDR:  0xc161
 * DESC:     User FEC Control 0 register: 00000000
 * SIZE:     32
 * FIELDS:
 *     RESERVED1        
 *     FAST_LOCK_EN     
 *     DBG_ENABLE       
 *     ERROR_EN_OVR_VAL 
 *     ERROR_EN_OVR     
 *     FEC_ERR_ENABLE   
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_0r (0x0000c161 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_TSC_12_FEC_0.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_0r_s {
	uint32_t v[1];
	uint32_t rx_x4_tsc_12_fec_0[1];
	uint32_t _rx_x4_tsc_12_fec_0;
} BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_0r_t;

#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_0r_CLR(r) (r).rx_x4_tsc_12_fec_0[0] = 0
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_0r_SET(r,d) (r).rx_x4_tsc_12_fec_0[0] = d
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_0r_GET(r) (r).rx_x4_tsc_12_fec_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_0r_RESERVED0f_GET(r) ((((r).rx_x4_tsc_12_fec_0[0]) >> 14) & 0x3)
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_0r_RESERVED0f_SET(r,f) (r).rx_x4_tsc_12_fec_0[0]=(((r).rx_x4_tsc_12_fec_0[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_0r_FEC_ERR_ENABLEf_GET(r) ((((r).rx_x4_tsc_12_fec_0[0]) >> 13) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_0r_FEC_ERR_ENABLEf_SET(r,f) (r).rx_x4_tsc_12_fec_0[0]=(((r).rx_x4_tsc_12_fec_0[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_0r_ERROR_EN_OVRf_GET(r) ((((r).rx_x4_tsc_12_fec_0[0]) >> 12) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_0r_ERROR_EN_OVRf_SET(r,f) (r).rx_x4_tsc_12_fec_0[0]=(((r).rx_x4_tsc_12_fec_0[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_0r_ERROR_EN_OVR_VALf_GET(r) ((((r).rx_x4_tsc_12_fec_0[0]) >> 11) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_0r_ERROR_EN_OVR_VALf_SET(r,f) (r).rx_x4_tsc_12_fec_0[0]=(((r).rx_x4_tsc_12_fec_0[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_0r_DBG_ENABLEf_GET(r) ((((r).rx_x4_tsc_12_fec_0[0]) >> 10) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_0r_DBG_ENABLEf_SET(r,f) (r).rx_x4_tsc_12_fec_0[0]=(((r).rx_x4_tsc_12_fec_0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_0r_FAST_LOCK_ENf_GET(r) ((((r).rx_x4_tsc_12_fec_0[0]) >> 9) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_0r_FAST_LOCK_ENf_SET(r,f) (r).rx_x4_tsc_12_fec_0[0]=(((r).rx_x4_tsc_12_fec_0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_0r_RESERVED1f_GET(r) (((r).rx_x4_tsc_12_fec_0[0]) & 0x1ff)
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_0r_RESERVED1f_SET(r,f) (r).rx_x4_tsc_12_fec_0[0]=(((r).rx_x4_tsc_12_fec_0[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))

/*
 * These macros can be used to access RX_X4_TSC_12_FEC_0.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X4_TSC_12_FEC_0r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_0r,(_r._rx_x4_tsc_12_fec_0))
#define BCMI_TSC_XGXS_WRITE_RX_X4_TSC_12_FEC_0r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_0r,(_r._rx_x4_tsc_12_fec_0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_TSC_12_FEC_0r BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_0r
#define RX_X4_TSC_12_FEC_0r_SIZE BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_0r_SIZE
typedef BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_0r_t RX_X4_TSC_12_FEC_0r_t;
#define RX_X4_TSC_12_FEC_0r_CLR BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_0r_CLR
#define RX_X4_TSC_12_FEC_0r_SET BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_0r_SET
#define RX_X4_TSC_12_FEC_0r_GET BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_0r_GET
#define RX_X4_TSC_12_FEC_0r_RESERVED0f_GET BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_0r_RESERVED0f_GET
#define RX_X4_TSC_12_FEC_0r_RESERVED0f_SET BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_0r_RESERVED0f_SET
#define RX_X4_TSC_12_FEC_0r_FEC_ERR_ENABLEf_GET BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_0r_FEC_ERR_ENABLEf_GET
#define RX_X4_TSC_12_FEC_0r_FEC_ERR_ENABLEf_SET BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_0r_FEC_ERR_ENABLEf_SET
#define RX_X4_TSC_12_FEC_0r_ERROR_EN_OVRf_GET BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_0r_ERROR_EN_OVRf_GET
#define RX_X4_TSC_12_FEC_0r_ERROR_EN_OVRf_SET BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_0r_ERROR_EN_OVRf_SET
#define RX_X4_TSC_12_FEC_0r_ERROR_EN_OVR_VALf_GET BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_0r_ERROR_EN_OVR_VALf_GET
#define RX_X4_TSC_12_FEC_0r_ERROR_EN_OVR_VALf_SET BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_0r_ERROR_EN_OVR_VALf_SET
#define RX_X4_TSC_12_FEC_0r_DBG_ENABLEf_GET BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_0r_DBG_ENABLEf_GET
#define RX_X4_TSC_12_FEC_0r_DBG_ENABLEf_SET BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_0r_DBG_ENABLEf_SET
#define RX_X4_TSC_12_FEC_0r_FAST_LOCK_ENf_GET BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_0r_FAST_LOCK_ENf_GET
#define RX_X4_TSC_12_FEC_0r_FAST_LOCK_ENf_SET BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_0r_FAST_LOCK_ENf_SET
#define RX_X4_TSC_12_FEC_0r_RESERVED1f_GET BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_0r_RESERVED1f_GET
#define RX_X4_TSC_12_FEC_0r_RESERVED1f_SET BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_0r_RESERVED1f_SET
#define READ_RX_X4_TSC_12_FEC_0r BCMI_TSC_XGXS_READ_RX_X4_TSC_12_FEC_0r
#define WRITE_RX_X4_TSC_12_FEC_0r BCMI_TSC_XGXS_WRITE_RX_X4_TSC_12_FEC_0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X4_TSC_12_FEC_1
 * BLOCKS:   RX_X4_CONTROL0
 * REGADDR:  0xc162
 * DESC:     User FEC Control 1 register: 00000000
 * SIZE:     32
 * FIELDS:
 *     DBG_ERR_MODE     
 *     BURST_ERR_STATUS_MODE 
 *     DEC_MAX_PM       
 *     INVALID_PARITY_CNT 
 *     GOOD_PARITY_CNT  
 *     FEC_ERROR_CODE_ALL 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_1r (0x0000c162 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_TSC_12_FEC_1.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_1r_s {
	uint32_t v[1];
	uint32_t rx_x4_tsc_12_fec_1[1];
	uint32_t _rx_x4_tsc_12_fec_1;
} BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_1r_t;

#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_1r_CLR(r) (r).rx_x4_tsc_12_fec_1[0] = 0
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_1r_SET(r,d) (r).rx_x4_tsc_12_fec_1[0] = d
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_1r_GET(r) (r).rx_x4_tsc_12_fec_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_1r_FEC_ERROR_CODE_ALLf_GET(r) ((((r).rx_x4_tsc_12_fec_1[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_1r_FEC_ERROR_CODE_ALLf_SET(r,f) (r).rx_x4_tsc_12_fec_1[0]=(((r).rx_x4_tsc_12_fec_1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_1r_GOOD_PARITY_CNTf_GET(r) ((((r).rx_x4_tsc_12_fec_1[0]) >> 12) & 0x7)
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_1r_GOOD_PARITY_CNTf_SET(r,f) (r).rx_x4_tsc_12_fec_1[0]=(((r).rx_x4_tsc_12_fec_1[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_1r_INVALID_PARITY_CNTf_GET(r) ((((r).rx_x4_tsc_12_fec_1[0]) >> 8) & 0xf)
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_1r_INVALID_PARITY_CNTf_SET(r,f) (r).rx_x4_tsc_12_fec_1[0]=(((r).rx_x4_tsc_12_fec_1[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_1r_DEC_MAX_PMf_GET(r) ((((r).rx_x4_tsc_12_fec_1[0]) >> 2) & 0x3f)
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_1r_DEC_MAX_PMf_SET(r,f) (r).rx_x4_tsc_12_fec_1[0]=(((r).rx_x4_tsc_12_fec_1[0] & ~((uint32_t)0x3f << 2)) | ((((uint32_t)f) & 0x3f) << 2))
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_1r_BURST_ERR_STATUS_MODEf_GET(r) ((((r).rx_x4_tsc_12_fec_1[0]) >> 1) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_1r_BURST_ERR_STATUS_MODEf_SET(r,f) (r).rx_x4_tsc_12_fec_1[0]=(((r).rx_x4_tsc_12_fec_1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_1r_DBG_ERR_MODEf_GET(r) (((r).rx_x4_tsc_12_fec_1[0]) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_1r_DBG_ERR_MODEf_SET(r,f) (r).rx_x4_tsc_12_fec_1[0]=(((r).rx_x4_tsc_12_fec_1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access RX_X4_TSC_12_FEC_1.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X4_TSC_12_FEC_1r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_1r,(_r._rx_x4_tsc_12_fec_1))
#define BCMI_TSC_XGXS_WRITE_RX_X4_TSC_12_FEC_1r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_1r,(_r._rx_x4_tsc_12_fec_1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_TSC_12_FEC_1r BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_1r
#define RX_X4_TSC_12_FEC_1r_SIZE BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_1r_SIZE
typedef BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_1r_t RX_X4_TSC_12_FEC_1r_t;
#define RX_X4_TSC_12_FEC_1r_CLR BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_1r_CLR
#define RX_X4_TSC_12_FEC_1r_SET BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_1r_SET
#define RX_X4_TSC_12_FEC_1r_GET BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_1r_GET
#define RX_X4_TSC_12_FEC_1r_FEC_ERROR_CODE_ALLf_GET BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_1r_FEC_ERROR_CODE_ALLf_GET
#define RX_X4_TSC_12_FEC_1r_FEC_ERROR_CODE_ALLf_SET BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_1r_FEC_ERROR_CODE_ALLf_SET
#define RX_X4_TSC_12_FEC_1r_GOOD_PARITY_CNTf_GET BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_1r_GOOD_PARITY_CNTf_GET
#define RX_X4_TSC_12_FEC_1r_GOOD_PARITY_CNTf_SET BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_1r_GOOD_PARITY_CNTf_SET
#define RX_X4_TSC_12_FEC_1r_INVALID_PARITY_CNTf_GET BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_1r_INVALID_PARITY_CNTf_GET
#define RX_X4_TSC_12_FEC_1r_INVALID_PARITY_CNTf_SET BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_1r_INVALID_PARITY_CNTf_SET
#define RX_X4_TSC_12_FEC_1r_DEC_MAX_PMf_GET BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_1r_DEC_MAX_PMf_GET
#define RX_X4_TSC_12_FEC_1r_DEC_MAX_PMf_SET BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_1r_DEC_MAX_PMf_SET
#define RX_X4_TSC_12_FEC_1r_BURST_ERR_STATUS_MODEf_GET BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_1r_BURST_ERR_STATUS_MODEf_GET
#define RX_X4_TSC_12_FEC_1r_BURST_ERR_STATUS_MODEf_SET BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_1r_BURST_ERR_STATUS_MODEf_SET
#define RX_X4_TSC_12_FEC_1r_DBG_ERR_MODEf_GET BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_1r_DBG_ERR_MODEf_GET
#define RX_X4_TSC_12_FEC_1r_DBG_ERR_MODEf_SET BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_1r_DBG_ERR_MODEf_SET
#define READ_RX_X4_TSC_12_FEC_1r BCMI_TSC_XGXS_READ_RX_X4_TSC_12_FEC_1r
#define WRITE_RX_X4_TSC_12_FEC_1r BCMI_TSC_XGXS_WRITE_RX_X4_TSC_12_FEC_1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X4_TSC_12_FEC_2
 * BLOCKS:   RX_X4_CONTROL0
 * REGADDR:  0xc163
 * DESC:     User FEC Control 2 register: 00000000
 * SIZE:     32
 * FIELDS:
 *     RESERVED0        
 *     DEC_GAP_COUNT_MODE 
 *     DEC_17B_BURST_GAP_COUNT 
 *     DEC_18B_BURST_GAP_COUNT 
 *     DEC_19B_BURST_GAP_COUNT 
 *     DEC_PM_MODE      
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_2r (0x0000c163 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_2r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_TSC_12_FEC_2.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_2r_s {
	uint32_t v[1];
	uint32_t rx_x4_tsc_12_fec_2[1];
	uint32_t _rx_x4_tsc_12_fec_2;
} BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_2r_t;

#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_2r_CLR(r) (r).rx_x4_tsc_12_fec_2[0] = 0
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_2r_SET(r,d) (r).rx_x4_tsc_12_fec_2[0] = d
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_2r_GET(r) (r).rx_x4_tsc_12_fec_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_2r_DEC_PM_MODEf_GET(r) ((((r).rx_x4_tsc_12_fec_2[0]) >> 11) & 0x1f)
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_2r_DEC_PM_MODEf_SET(r,f) (r).rx_x4_tsc_12_fec_2[0]=(((r).rx_x4_tsc_12_fec_2[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_2r_DEC_19B_BURST_GAP_COUNTf_GET(r) ((((r).rx_x4_tsc_12_fec_2[0]) >> 8) & 0x7)
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_2r_DEC_19B_BURST_GAP_COUNTf_SET(r,f) (r).rx_x4_tsc_12_fec_2[0]=(((r).rx_x4_tsc_12_fec_2[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8))
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_2r_DEC_18B_BURST_GAP_COUNTf_GET(r) ((((r).rx_x4_tsc_12_fec_2[0]) >> 5) & 0x7)
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_2r_DEC_18B_BURST_GAP_COUNTf_SET(r,f) (r).rx_x4_tsc_12_fec_2[0]=(((r).rx_x4_tsc_12_fec_2[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_2r_DEC_17B_BURST_GAP_COUNTf_GET(r) ((((r).rx_x4_tsc_12_fec_2[0]) >> 2) & 0x7)
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_2r_DEC_17B_BURST_GAP_COUNTf_SET(r,f) (r).rx_x4_tsc_12_fec_2[0]=(((r).rx_x4_tsc_12_fec_2[0] & ~((uint32_t)0x7 << 2)) | ((((uint32_t)f) & 0x7) << 2))
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_2r_DEC_GAP_COUNT_MODEf_GET(r) ((((r).rx_x4_tsc_12_fec_2[0]) >> 1) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_2r_DEC_GAP_COUNT_MODEf_SET(r,f) (r).rx_x4_tsc_12_fec_2[0]=(((r).rx_x4_tsc_12_fec_2[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_2r_RESERVED0f_GET(r) (((r).rx_x4_tsc_12_fec_2[0]) & 0x1)
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_2r_RESERVED0f_SET(r,f) (r).rx_x4_tsc_12_fec_2[0]=(((r).rx_x4_tsc_12_fec_2[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access RX_X4_TSC_12_FEC_2.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X4_TSC_12_FEC_2r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_2r,(_r._rx_x4_tsc_12_fec_2))
#define BCMI_TSC_XGXS_WRITE_RX_X4_TSC_12_FEC_2r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_2r,(_r._rx_x4_tsc_12_fec_2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_TSC_12_FEC_2r BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_2r
#define RX_X4_TSC_12_FEC_2r_SIZE BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_2r_SIZE
typedef BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_2r_t RX_X4_TSC_12_FEC_2r_t;
#define RX_X4_TSC_12_FEC_2r_CLR BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_2r_CLR
#define RX_X4_TSC_12_FEC_2r_SET BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_2r_SET
#define RX_X4_TSC_12_FEC_2r_GET BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_2r_GET
#define RX_X4_TSC_12_FEC_2r_DEC_PM_MODEf_GET BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_2r_DEC_PM_MODEf_GET
#define RX_X4_TSC_12_FEC_2r_DEC_PM_MODEf_SET BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_2r_DEC_PM_MODEf_SET
#define RX_X4_TSC_12_FEC_2r_DEC_19B_BURST_GAP_COUNTf_GET BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_2r_DEC_19B_BURST_GAP_COUNTf_GET
#define RX_X4_TSC_12_FEC_2r_DEC_19B_BURST_GAP_COUNTf_SET BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_2r_DEC_19B_BURST_GAP_COUNTf_SET
#define RX_X4_TSC_12_FEC_2r_DEC_18B_BURST_GAP_COUNTf_GET BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_2r_DEC_18B_BURST_GAP_COUNTf_GET
#define RX_X4_TSC_12_FEC_2r_DEC_18B_BURST_GAP_COUNTf_SET BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_2r_DEC_18B_BURST_GAP_COUNTf_SET
#define RX_X4_TSC_12_FEC_2r_DEC_17B_BURST_GAP_COUNTf_GET BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_2r_DEC_17B_BURST_GAP_COUNTf_GET
#define RX_X4_TSC_12_FEC_2r_DEC_17B_BURST_GAP_COUNTf_SET BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_2r_DEC_17B_BURST_GAP_COUNTf_SET
#define RX_X4_TSC_12_FEC_2r_DEC_GAP_COUNT_MODEf_GET BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_2r_DEC_GAP_COUNT_MODEf_GET
#define RX_X4_TSC_12_FEC_2r_DEC_GAP_COUNT_MODEf_SET BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_2r_DEC_GAP_COUNT_MODEf_SET
#define RX_X4_TSC_12_FEC_2r_RESERVED0f_GET BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_2r_RESERVED0f_GET
#define RX_X4_TSC_12_FEC_2r_RESERVED0f_SET BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_2r_RESERVED0f_SET
#define READ_RX_X4_TSC_12_FEC_2r BCMI_TSC_XGXS_READ_RX_X4_TSC_12_FEC_2r
#define WRITE_RX_X4_TSC_12_FEC_2r BCMI_TSC_XGXS_WRITE_RX_X4_TSC_12_FEC_2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X4_TSC_12_FEC_DBG_ERRL
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc170
 * DESC:     "User FEC debug read data [15:0]": 00000000
 * SIZE:     32
 * FIELDS:
 *     DBG_ERRL         
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_DBG_ERRLr (0x0000c170 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_DBG_ERRLr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_TSC_12_FEC_DBG_ERRL.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_DBG_ERRLr_s {
	uint32_t v[1];
	uint32_t rx_x4_tsc_12_fec_dbg_errl[1];
	uint32_t _rx_x4_tsc_12_fec_dbg_errl;
} BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_DBG_ERRLr_t;

#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_DBG_ERRLr_CLR(r) (r).rx_x4_tsc_12_fec_dbg_errl[0] = 0
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_DBG_ERRLr_SET(r,d) (r).rx_x4_tsc_12_fec_dbg_errl[0] = d
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_DBG_ERRLr_GET(r) (r).rx_x4_tsc_12_fec_dbg_errl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_DBG_ERRLr_DBG_ERRLf_GET(r) (((r).rx_x4_tsc_12_fec_dbg_errl[0]) & 0xffff)
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_DBG_ERRLr_DBG_ERRLf_SET(r,f) (r).rx_x4_tsc_12_fec_dbg_errl[0]=(((r).rx_x4_tsc_12_fec_dbg_errl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access RX_X4_TSC_12_FEC_DBG_ERRL.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X4_TSC_12_FEC_DBG_ERRLr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_DBG_ERRLr,(_r._rx_x4_tsc_12_fec_dbg_errl))
#define BCMI_TSC_XGXS_WRITE_RX_X4_TSC_12_FEC_DBG_ERRLr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_DBG_ERRLr,(_r._rx_x4_tsc_12_fec_dbg_errl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_TSC_12_FEC_DBG_ERRLr BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_DBG_ERRLr
#define RX_X4_TSC_12_FEC_DBG_ERRLr_SIZE BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_DBG_ERRLr_SIZE
typedef BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_DBG_ERRLr_t RX_X4_TSC_12_FEC_DBG_ERRLr_t;
#define RX_X4_TSC_12_FEC_DBG_ERRLr_CLR BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_DBG_ERRLr_CLR
#define RX_X4_TSC_12_FEC_DBG_ERRLr_SET BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_DBG_ERRLr_SET
#define RX_X4_TSC_12_FEC_DBG_ERRLr_GET BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_DBG_ERRLr_GET
#define RX_X4_TSC_12_FEC_DBG_ERRLr_DBG_ERRLf_GET BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_DBG_ERRLr_DBG_ERRLf_GET
#define RX_X4_TSC_12_FEC_DBG_ERRLr_DBG_ERRLf_SET BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_DBG_ERRLr_DBG_ERRLf_SET
#define READ_RX_X4_TSC_12_FEC_DBG_ERRLr BCMI_TSC_XGXS_READ_RX_X4_TSC_12_FEC_DBG_ERRLr
#define WRITE_RX_X4_TSC_12_FEC_DBG_ERRLr BCMI_TSC_XGXS_WRITE_RX_X4_TSC_12_FEC_DBG_ERRLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_DBG_ERRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X4_TSC_12_FEC_DBG_ERRAH
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc171
 * DESC:     "User FEC debug read data [31:16]": 00000000
 * SIZE:     32
 * FIELDS:
 *     DBG_ERRH         
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_DBG_ERRAHr (0x0000c171 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_DBG_ERRAHr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_TSC_12_FEC_DBG_ERRAH.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_DBG_ERRAHr_s {
	uint32_t v[1];
	uint32_t rx_x4_tsc_12_fec_dbg_errah[1];
	uint32_t _rx_x4_tsc_12_fec_dbg_errah;
} BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_DBG_ERRAHr_t;

#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_DBG_ERRAHr_CLR(r) (r).rx_x4_tsc_12_fec_dbg_errah[0] = 0
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_DBG_ERRAHr_SET(r,d) (r).rx_x4_tsc_12_fec_dbg_errah[0] = d
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_DBG_ERRAHr_GET(r) (r).rx_x4_tsc_12_fec_dbg_errah[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_DBG_ERRAHr_DBG_ERRHf_GET(r) (((r).rx_x4_tsc_12_fec_dbg_errah[0]) & 0xffff)
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_DBG_ERRAHr_DBG_ERRHf_SET(r,f) (r).rx_x4_tsc_12_fec_dbg_errah[0]=(((r).rx_x4_tsc_12_fec_dbg_errah[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access RX_X4_TSC_12_FEC_DBG_ERRAH.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X4_TSC_12_FEC_DBG_ERRAHr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_DBG_ERRAHr,(_r._rx_x4_tsc_12_fec_dbg_errah))
#define BCMI_TSC_XGXS_WRITE_RX_X4_TSC_12_FEC_DBG_ERRAHr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_DBG_ERRAHr,(_r._rx_x4_tsc_12_fec_dbg_errah))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_TSC_12_FEC_DBG_ERRAHr BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_DBG_ERRAHr
#define RX_X4_TSC_12_FEC_DBG_ERRAHr_SIZE BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_DBG_ERRAHr_SIZE
typedef BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_DBG_ERRAHr_t RX_X4_TSC_12_FEC_DBG_ERRAHr_t;
#define RX_X4_TSC_12_FEC_DBG_ERRAHr_CLR BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_DBG_ERRAHr_CLR
#define RX_X4_TSC_12_FEC_DBG_ERRAHr_SET BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_DBG_ERRAHr_SET
#define RX_X4_TSC_12_FEC_DBG_ERRAHr_GET BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_DBG_ERRAHr_GET
#define RX_X4_TSC_12_FEC_DBG_ERRAHr_DBG_ERRHf_GET BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_DBG_ERRAHr_DBG_ERRHf_GET
#define RX_X4_TSC_12_FEC_DBG_ERRAHr_DBG_ERRHf_SET BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_DBG_ERRAHr_DBG_ERRHf_SET
#define READ_RX_X4_TSC_12_FEC_DBG_ERRAHr BCMI_TSC_XGXS_READ_RX_X4_TSC_12_FEC_DBG_ERRAHr
#define WRITE_RX_X4_TSC_12_FEC_DBG_ERRAHr BCMI_TSC_XGXS_WRITE_RX_X4_TSC_12_FEC_DBG_ERRAHr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_DBG_ERRAHr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X4_TSC_12_FEC_BURST_ERR_STATUSL
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc172
 * DESC:     "fec burst error status lower 16 bits": 00000000
 * SIZE:     32
 * FIELDS:
 *     BURST_ERR_STATUSL 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_BURST_ERR_STATUSLr (0x0000c172 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_BURST_ERR_STATUSLr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_TSC_12_FEC_BURST_ERR_STATUSL.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_BURST_ERR_STATUSLr_s {
	uint32_t v[1];
	uint32_t rx_x4_tsc_12_fec_burst_err_statusl[1];
	uint32_t _rx_x4_tsc_12_fec_burst_err_statusl;
} BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_BURST_ERR_STATUSLr_t;

#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_BURST_ERR_STATUSLr_CLR(r) (r).rx_x4_tsc_12_fec_burst_err_statusl[0] = 0
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_BURST_ERR_STATUSLr_SET(r,d) (r).rx_x4_tsc_12_fec_burst_err_statusl[0] = d
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_BURST_ERR_STATUSLr_GET(r) (r).rx_x4_tsc_12_fec_burst_err_statusl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_BURST_ERR_STATUSLr_BURST_ERR_STATUSLf_GET(r) (((r).rx_x4_tsc_12_fec_burst_err_statusl[0]) & 0xffff)
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_BURST_ERR_STATUSLr_BURST_ERR_STATUSLf_SET(r,f) (r).rx_x4_tsc_12_fec_burst_err_statusl[0]=(((r).rx_x4_tsc_12_fec_burst_err_statusl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access RX_X4_TSC_12_FEC_BURST_ERR_STATUSL.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X4_TSC_12_FEC_BURST_ERR_STATUSLr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_BURST_ERR_STATUSLr,(_r._rx_x4_tsc_12_fec_burst_err_statusl))
#define BCMI_TSC_XGXS_WRITE_RX_X4_TSC_12_FEC_BURST_ERR_STATUSLr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_BURST_ERR_STATUSLr,(_r._rx_x4_tsc_12_fec_burst_err_statusl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_TSC_12_FEC_BURST_ERR_STATUSLr BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_BURST_ERR_STATUSLr
#define RX_X4_TSC_12_FEC_BURST_ERR_STATUSLr_SIZE BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_BURST_ERR_STATUSLr_SIZE
typedef BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_BURST_ERR_STATUSLr_t RX_X4_TSC_12_FEC_BURST_ERR_STATUSLr_t;
#define RX_X4_TSC_12_FEC_BURST_ERR_STATUSLr_CLR BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_BURST_ERR_STATUSLr_CLR
#define RX_X4_TSC_12_FEC_BURST_ERR_STATUSLr_SET BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_BURST_ERR_STATUSLr_SET
#define RX_X4_TSC_12_FEC_BURST_ERR_STATUSLr_GET BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_BURST_ERR_STATUSLr_GET
#define RX_X4_TSC_12_FEC_BURST_ERR_STATUSLr_BURST_ERR_STATUSLf_GET BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_BURST_ERR_STATUSLr_BURST_ERR_STATUSLf_GET
#define RX_X4_TSC_12_FEC_BURST_ERR_STATUSLr_BURST_ERR_STATUSLf_SET BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_BURST_ERR_STATUSLr_BURST_ERR_STATUSLf_SET
#define READ_RX_X4_TSC_12_FEC_BURST_ERR_STATUSLr BCMI_TSC_XGXS_READ_RX_X4_TSC_12_FEC_BURST_ERR_STATUSLr
#define WRITE_RX_X4_TSC_12_FEC_BURST_ERR_STATUSLr BCMI_TSC_XGXS_WRITE_RX_X4_TSC_12_FEC_BURST_ERR_STATUSLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_BURST_ERR_STATUSLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X4_TSC_12_FEC_BURST_ERR_STATUSH
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc173
 * DESC:     "fec burst error status lower 16 bits": 00000000
 * SIZE:     32
 * FIELDS:
 *     BURST_ERR_STATUSH 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_BURST_ERR_STATUSHr (0x0000c173 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_BURST_ERR_STATUSHr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_TSC_12_FEC_BURST_ERR_STATUSH.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_BURST_ERR_STATUSHr_s {
	uint32_t v[1];
	uint32_t rx_x4_tsc_12_fec_burst_err_statush[1];
	uint32_t _rx_x4_tsc_12_fec_burst_err_statush;
} BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_BURST_ERR_STATUSHr_t;

#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_BURST_ERR_STATUSHr_CLR(r) (r).rx_x4_tsc_12_fec_burst_err_statush[0] = 0
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_BURST_ERR_STATUSHr_SET(r,d) (r).rx_x4_tsc_12_fec_burst_err_statush[0] = d
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_BURST_ERR_STATUSHr_GET(r) (r).rx_x4_tsc_12_fec_burst_err_statush[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_BURST_ERR_STATUSHr_BURST_ERR_STATUSHf_GET(r) (((r).rx_x4_tsc_12_fec_burst_err_statush[0]) & 0xffff)
#define BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_BURST_ERR_STATUSHr_BURST_ERR_STATUSHf_SET(r,f) (r).rx_x4_tsc_12_fec_burst_err_statush[0]=(((r).rx_x4_tsc_12_fec_burst_err_statush[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access RX_X4_TSC_12_FEC_BURST_ERR_STATUSH.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X4_TSC_12_FEC_BURST_ERR_STATUSHr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_BURST_ERR_STATUSHr,(_r._rx_x4_tsc_12_fec_burst_err_statush))
#define BCMI_TSC_XGXS_WRITE_RX_X4_TSC_12_FEC_BURST_ERR_STATUSHr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_BURST_ERR_STATUSHr,(_r._rx_x4_tsc_12_fec_burst_err_statush))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_TSC_12_FEC_BURST_ERR_STATUSHr BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_BURST_ERR_STATUSHr
#define RX_X4_TSC_12_FEC_BURST_ERR_STATUSHr_SIZE BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_BURST_ERR_STATUSHr_SIZE
typedef BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_BURST_ERR_STATUSHr_t RX_X4_TSC_12_FEC_BURST_ERR_STATUSHr_t;
#define RX_X4_TSC_12_FEC_BURST_ERR_STATUSHr_CLR BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_BURST_ERR_STATUSHr_CLR
#define RX_X4_TSC_12_FEC_BURST_ERR_STATUSHr_SET BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_BURST_ERR_STATUSHr_SET
#define RX_X4_TSC_12_FEC_BURST_ERR_STATUSHr_GET BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_BURST_ERR_STATUSHr_GET
#define RX_X4_TSC_12_FEC_BURST_ERR_STATUSHr_BURST_ERR_STATUSHf_GET BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_BURST_ERR_STATUSHr_BURST_ERR_STATUSHf_GET
#define RX_X4_TSC_12_FEC_BURST_ERR_STATUSHr_BURST_ERR_STATUSHf_SET BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_BURST_ERR_STATUSHr_BURST_ERR_STATUSHf_SET
#define READ_RX_X4_TSC_12_FEC_BURST_ERR_STATUSHr BCMI_TSC_XGXS_READ_RX_X4_TSC_12_FEC_BURST_ERR_STATUSHr
#define WRITE_RX_X4_TSC_12_FEC_BURST_ERR_STATUSHr BCMI_TSC_XGXS_WRITE_RX_X4_TSC_12_FEC_BURST_ERR_STATUSHr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X4_TSC_12_FEC_BURST_ERR_STATUSHr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X4_TSC_12_BERCOUNT
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc174
 * DESC:     bercount register: 00000000
 * SIZE:     32
 * FIELDS:
 *     BIP_ERROR_COUNT_PER_LANE 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X4_TSC_12_BERCOUNTr (0x0000c174 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X4_TSC_12_BERCOUNTr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_TSC_12_BERCOUNT.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X4_TSC_12_BERCOUNTr_s {
	uint32_t v[1];
	uint32_t rx_x4_tsc_12_bercount[1];
	uint32_t _rx_x4_tsc_12_bercount;
} BCMI_TSC_XGXS_RX_X4_TSC_12_BERCOUNTr_t;

#define BCMI_TSC_XGXS_RX_X4_TSC_12_BERCOUNTr_CLR(r) (r).rx_x4_tsc_12_bercount[0] = 0
#define BCMI_TSC_XGXS_RX_X4_TSC_12_BERCOUNTr_SET(r,d) (r).rx_x4_tsc_12_bercount[0] = d
#define BCMI_TSC_XGXS_RX_X4_TSC_12_BERCOUNTr_GET(r) (r).rx_x4_tsc_12_bercount[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X4_TSC_12_BERCOUNTr_RESERVED0f_GET(r) ((((r).rx_x4_tsc_12_bercount[0]) >> 8) & 0xff)
#define BCMI_TSC_XGXS_RX_X4_TSC_12_BERCOUNTr_RESERVED0f_SET(r,f) (r).rx_x4_tsc_12_bercount[0]=(((r).rx_x4_tsc_12_bercount[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCMI_TSC_XGXS_RX_X4_TSC_12_BERCOUNTr_BIP_ERROR_COUNT_PER_LANEf_GET(r) (((r).rx_x4_tsc_12_bercount[0]) & 0xff)
#define BCMI_TSC_XGXS_RX_X4_TSC_12_BERCOUNTr_BIP_ERROR_COUNT_PER_LANEf_SET(r,f) (r).rx_x4_tsc_12_bercount[0]=(((r).rx_x4_tsc_12_bercount[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access RX_X4_TSC_12_BERCOUNT.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X4_TSC_12_BERCOUNTr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X4_TSC_12_BERCOUNTr,(_r._rx_x4_tsc_12_bercount))
#define BCMI_TSC_XGXS_WRITE_RX_X4_TSC_12_BERCOUNTr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X4_TSC_12_BERCOUNTr,(_r._rx_x4_tsc_12_bercount))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_TSC_12_BERCOUNTr BCMI_TSC_XGXS_RX_X4_TSC_12_BERCOUNTr
#define RX_X4_TSC_12_BERCOUNTr_SIZE BCMI_TSC_XGXS_RX_X4_TSC_12_BERCOUNTr_SIZE
typedef BCMI_TSC_XGXS_RX_X4_TSC_12_BERCOUNTr_t RX_X4_TSC_12_BERCOUNTr_t;
#define RX_X4_TSC_12_BERCOUNTr_CLR BCMI_TSC_XGXS_RX_X4_TSC_12_BERCOUNTr_CLR
#define RX_X4_TSC_12_BERCOUNTr_SET BCMI_TSC_XGXS_RX_X4_TSC_12_BERCOUNTr_SET
#define RX_X4_TSC_12_BERCOUNTr_GET BCMI_TSC_XGXS_RX_X4_TSC_12_BERCOUNTr_GET
#define RX_X4_TSC_12_BERCOUNTr_RESERVED0f_GET BCMI_TSC_XGXS_RX_X4_TSC_12_BERCOUNTr_RESERVED0f_GET
#define RX_X4_TSC_12_BERCOUNTr_RESERVED0f_SET BCMI_TSC_XGXS_RX_X4_TSC_12_BERCOUNTr_RESERVED0f_SET
#define RX_X4_TSC_12_BERCOUNTr_BIP_ERROR_COUNT_PER_LANEf_GET BCMI_TSC_XGXS_RX_X4_TSC_12_BERCOUNTr_BIP_ERROR_COUNT_PER_LANEf_GET
#define RX_X4_TSC_12_BERCOUNTr_BIP_ERROR_COUNT_PER_LANEf_SET BCMI_TSC_XGXS_RX_X4_TSC_12_BERCOUNTr_BIP_ERROR_COUNT_PER_LANEf_SET
#define READ_RX_X4_TSC_12_BERCOUNTr BCMI_TSC_XGXS_READ_RX_X4_TSC_12_BERCOUNTr
#define WRITE_RX_X4_TSC_12_BERCOUNTr BCMI_TSC_XGXS_WRITE_RX_X4_TSC_12_BERCOUNTr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X4_TSC_12_BERCOUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X4_TSC_12_CL49_LOCK_FSM_STATUS_TYPE
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc175
 * DESC:     TSC_12 EXTENSION of CL49 Lock Status register: 00000000
 * SIZE:     32
 * FIELDS:
 *     LSM_CURR_STATE   
 *     LSM_HIS_STATE    
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X4_TSC_12_CL49_LOCK_FSM_STATUS_TYPEr (0x0000c175 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X4_TSC_12_CL49_LOCK_FSM_STATUS_TYPEr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_TSC_12_CL49_LOCK_FSM_STATUS_TYPE.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X4_TSC_12_CL49_LOCK_FSM_STATUS_TYPEr_s {
	uint32_t v[1];
	uint32_t rx_x4_tsc_12_cl49_lock_fsm_status_type[1];
	uint32_t _rx_x4_tsc_12_cl49_lock_fsm_status_type;
} BCMI_TSC_XGXS_RX_X4_TSC_12_CL49_LOCK_FSM_STATUS_TYPEr_t;

#define BCMI_TSC_XGXS_RX_X4_TSC_12_CL49_LOCK_FSM_STATUS_TYPEr_CLR(r) (r).rx_x4_tsc_12_cl49_lock_fsm_status_type[0] = 0
#define BCMI_TSC_XGXS_RX_X4_TSC_12_CL49_LOCK_FSM_STATUS_TYPEr_SET(r,d) (r).rx_x4_tsc_12_cl49_lock_fsm_status_type[0] = d
#define BCMI_TSC_XGXS_RX_X4_TSC_12_CL49_LOCK_FSM_STATUS_TYPEr_GET(r) (r).rx_x4_tsc_12_cl49_lock_fsm_status_type[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X4_TSC_12_CL49_LOCK_FSM_STATUS_TYPEr_RESERVED0f_GET(r) ((((r).rx_x4_tsc_12_cl49_lock_fsm_status_type[0]) >> 5) & 0x7ff)
#define BCMI_TSC_XGXS_RX_X4_TSC_12_CL49_LOCK_FSM_STATUS_TYPEr_RESERVED0f_SET(r,f) (r).rx_x4_tsc_12_cl49_lock_fsm_status_type[0]=(((r).rx_x4_tsc_12_cl49_lock_fsm_status_type[0] & ~((uint32_t)0x7ff << 5)) | ((((uint32_t)f) & 0x7ff) << 5))
#define BCMI_TSC_XGXS_RX_X4_TSC_12_CL49_LOCK_FSM_STATUS_TYPEr_LSM_HIS_STATEf_GET(r) ((((r).rx_x4_tsc_12_cl49_lock_fsm_status_type[0]) >> 2) & 0x7)
#define BCMI_TSC_XGXS_RX_X4_TSC_12_CL49_LOCK_FSM_STATUS_TYPEr_LSM_HIS_STATEf_SET(r,f) (r).rx_x4_tsc_12_cl49_lock_fsm_status_type[0]=(((r).rx_x4_tsc_12_cl49_lock_fsm_status_type[0] & ~((uint32_t)0x7 << 2)) | ((((uint32_t)f) & 0x7) << 2))
#define BCMI_TSC_XGXS_RX_X4_TSC_12_CL49_LOCK_FSM_STATUS_TYPEr_LSM_CURR_STATEf_GET(r) (((r).rx_x4_tsc_12_cl49_lock_fsm_status_type[0]) & 0x3)
#define BCMI_TSC_XGXS_RX_X4_TSC_12_CL49_LOCK_FSM_STATUS_TYPEr_LSM_CURR_STATEf_SET(r,f) (r).rx_x4_tsc_12_cl49_lock_fsm_status_type[0]=(((r).rx_x4_tsc_12_cl49_lock_fsm_status_type[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))

/*
 * These macros can be used to access RX_X4_TSC_12_CL49_LOCK_FSM_STATUS_TYPE.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X4_TSC_12_CL49_LOCK_FSM_STATUS_TYPEr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X4_TSC_12_CL49_LOCK_FSM_STATUS_TYPEr,(_r._rx_x4_tsc_12_cl49_lock_fsm_status_type))
#define BCMI_TSC_XGXS_WRITE_RX_X4_TSC_12_CL49_LOCK_FSM_STATUS_TYPEr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X4_TSC_12_CL49_LOCK_FSM_STATUS_TYPEr,(_r._rx_x4_tsc_12_cl49_lock_fsm_status_type))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_TSC_12_CL49_LOCK_FSM_STATUS_TYPEr BCMI_TSC_XGXS_RX_X4_TSC_12_CL49_LOCK_FSM_STATUS_TYPEr
#define RX_X4_TSC_12_CL49_LOCK_FSM_STATUS_TYPEr_SIZE BCMI_TSC_XGXS_RX_X4_TSC_12_CL49_LOCK_FSM_STATUS_TYPEr_SIZE
typedef BCMI_TSC_XGXS_RX_X4_TSC_12_CL49_LOCK_FSM_STATUS_TYPEr_t RX_X4_TSC_12_CL49_LOCK_FSM_STATUS_TYPEr_t;
#define RX_X4_TSC_12_CL49_LOCK_FSM_STATUS_TYPEr_CLR BCMI_TSC_XGXS_RX_X4_TSC_12_CL49_LOCK_FSM_STATUS_TYPEr_CLR
#define RX_X4_TSC_12_CL49_LOCK_FSM_STATUS_TYPEr_SET BCMI_TSC_XGXS_RX_X4_TSC_12_CL49_LOCK_FSM_STATUS_TYPEr_SET
#define RX_X4_TSC_12_CL49_LOCK_FSM_STATUS_TYPEr_GET BCMI_TSC_XGXS_RX_X4_TSC_12_CL49_LOCK_FSM_STATUS_TYPEr_GET
#define RX_X4_TSC_12_CL49_LOCK_FSM_STATUS_TYPEr_RESERVED0f_GET BCMI_TSC_XGXS_RX_X4_TSC_12_CL49_LOCK_FSM_STATUS_TYPEr_RESERVED0f_GET
#define RX_X4_TSC_12_CL49_LOCK_FSM_STATUS_TYPEr_RESERVED0f_SET BCMI_TSC_XGXS_RX_X4_TSC_12_CL49_LOCK_FSM_STATUS_TYPEr_RESERVED0f_SET
#define RX_X4_TSC_12_CL49_LOCK_FSM_STATUS_TYPEr_LSM_HIS_STATEf_GET BCMI_TSC_XGXS_RX_X4_TSC_12_CL49_LOCK_FSM_STATUS_TYPEr_LSM_HIS_STATEf_GET
#define RX_X4_TSC_12_CL49_LOCK_FSM_STATUS_TYPEr_LSM_HIS_STATEf_SET BCMI_TSC_XGXS_RX_X4_TSC_12_CL49_LOCK_FSM_STATUS_TYPEr_LSM_HIS_STATEf_SET
#define RX_X4_TSC_12_CL49_LOCK_FSM_STATUS_TYPEr_LSM_CURR_STATEf_GET BCMI_TSC_XGXS_RX_X4_TSC_12_CL49_LOCK_FSM_STATUS_TYPEr_LSM_CURR_STATEf_GET
#define RX_X4_TSC_12_CL49_LOCK_FSM_STATUS_TYPEr_LSM_CURR_STATEf_SET BCMI_TSC_XGXS_RX_X4_TSC_12_CL49_LOCK_FSM_STATUS_TYPEr_LSM_CURR_STATEf_SET
#define READ_RX_X4_TSC_12_CL49_LOCK_FSM_STATUS_TYPEr BCMI_TSC_XGXS_READ_RX_X4_TSC_12_CL49_LOCK_FSM_STATUS_TYPEr
#define WRITE_RX_X4_TSC_12_CL49_LOCK_FSM_STATUS_TYPEr BCMI_TSC_XGXS_WRITE_RX_X4_TSC_12_CL49_LOCK_FSM_STATUS_TYPEr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X4_TSC_12_CL49_LOCK_FSM_STATUS_TYPEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X4_TSC_12_MLD_VL_INFO_0
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc176
 * DESC:     TSC_12 VIRTUAL LANE MAPPING: 00000000
 * SIZE:     32
 * FIELDS:
 *     VL_ON_LL_0       
 *     VL_ON_LL_1       
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X4_TSC_12_MLD_VL_INFO_0r (0x0000c176 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X4_TSC_12_MLD_VL_INFO_0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_TSC_12_MLD_VL_INFO_0.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X4_TSC_12_MLD_VL_INFO_0r_s {
	uint32_t v[1];
	uint32_t rx_x4_tsc_12_mld_vl_info_0[1];
	uint32_t _rx_x4_tsc_12_mld_vl_info_0;
} BCMI_TSC_XGXS_RX_X4_TSC_12_MLD_VL_INFO_0r_t;

#define BCMI_TSC_XGXS_RX_X4_TSC_12_MLD_VL_INFO_0r_CLR(r) (r).rx_x4_tsc_12_mld_vl_info_0[0] = 0
#define BCMI_TSC_XGXS_RX_X4_TSC_12_MLD_VL_INFO_0r_SET(r,d) (r).rx_x4_tsc_12_mld_vl_info_0[0] = d
#define BCMI_TSC_XGXS_RX_X4_TSC_12_MLD_VL_INFO_0r_GET(r) (r).rx_x4_tsc_12_mld_vl_info_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X4_TSC_12_MLD_VL_INFO_0r_RESERVED0f_GET(r) ((((r).rx_x4_tsc_12_mld_vl_info_0[0]) >> 10) & 0x3f)
#define BCMI_TSC_XGXS_RX_X4_TSC_12_MLD_VL_INFO_0r_RESERVED0f_SET(r,f) (r).rx_x4_tsc_12_mld_vl_info_0[0]=(((r).rx_x4_tsc_12_mld_vl_info_0[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))
#define BCMI_TSC_XGXS_RX_X4_TSC_12_MLD_VL_INFO_0r_VL_ON_LL_1f_GET(r) ((((r).rx_x4_tsc_12_mld_vl_info_0[0]) >> 5) & 0x1f)
#define BCMI_TSC_XGXS_RX_X4_TSC_12_MLD_VL_INFO_0r_VL_ON_LL_1f_SET(r,f) (r).rx_x4_tsc_12_mld_vl_info_0[0]=(((r).rx_x4_tsc_12_mld_vl_info_0[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5))
#define BCMI_TSC_XGXS_RX_X4_TSC_12_MLD_VL_INFO_0r_VL_ON_LL_0f_GET(r) (((r).rx_x4_tsc_12_mld_vl_info_0[0]) & 0x1f)
#define BCMI_TSC_XGXS_RX_X4_TSC_12_MLD_VL_INFO_0r_VL_ON_LL_0f_SET(r,f) (r).rx_x4_tsc_12_mld_vl_info_0[0]=(((r).rx_x4_tsc_12_mld_vl_info_0[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))

/*
 * These macros can be used to access RX_X4_TSC_12_MLD_VL_INFO_0.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X4_TSC_12_MLD_VL_INFO_0r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X4_TSC_12_MLD_VL_INFO_0r,(_r._rx_x4_tsc_12_mld_vl_info_0))
#define BCMI_TSC_XGXS_WRITE_RX_X4_TSC_12_MLD_VL_INFO_0r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X4_TSC_12_MLD_VL_INFO_0r,(_r._rx_x4_tsc_12_mld_vl_info_0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_TSC_12_MLD_VL_INFO_0r BCMI_TSC_XGXS_RX_X4_TSC_12_MLD_VL_INFO_0r
#define RX_X4_TSC_12_MLD_VL_INFO_0r_SIZE BCMI_TSC_XGXS_RX_X4_TSC_12_MLD_VL_INFO_0r_SIZE
typedef BCMI_TSC_XGXS_RX_X4_TSC_12_MLD_VL_INFO_0r_t RX_X4_TSC_12_MLD_VL_INFO_0r_t;
#define RX_X4_TSC_12_MLD_VL_INFO_0r_CLR BCMI_TSC_XGXS_RX_X4_TSC_12_MLD_VL_INFO_0r_CLR
#define RX_X4_TSC_12_MLD_VL_INFO_0r_SET BCMI_TSC_XGXS_RX_X4_TSC_12_MLD_VL_INFO_0r_SET
#define RX_X4_TSC_12_MLD_VL_INFO_0r_GET BCMI_TSC_XGXS_RX_X4_TSC_12_MLD_VL_INFO_0r_GET
#define RX_X4_TSC_12_MLD_VL_INFO_0r_RESERVED0f_GET BCMI_TSC_XGXS_RX_X4_TSC_12_MLD_VL_INFO_0r_RESERVED0f_GET
#define RX_X4_TSC_12_MLD_VL_INFO_0r_RESERVED0f_SET BCMI_TSC_XGXS_RX_X4_TSC_12_MLD_VL_INFO_0r_RESERVED0f_SET
#define RX_X4_TSC_12_MLD_VL_INFO_0r_VL_ON_LL_1f_GET BCMI_TSC_XGXS_RX_X4_TSC_12_MLD_VL_INFO_0r_VL_ON_LL_1f_GET
#define RX_X4_TSC_12_MLD_VL_INFO_0r_VL_ON_LL_1f_SET BCMI_TSC_XGXS_RX_X4_TSC_12_MLD_VL_INFO_0r_VL_ON_LL_1f_SET
#define RX_X4_TSC_12_MLD_VL_INFO_0r_VL_ON_LL_0f_GET BCMI_TSC_XGXS_RX_X4_TSC_12_MLD_VL_INFO_0r_VL_ON_LL_0f_GET
#define RX_X4_TSC_12_MLD_VL_INFO_0r_VL_ON_LL_0f_SET BCMI_TSC_XGXS_RX_X4_TSC_12_MLD_VL_INFO_0r_VL_ON_LL_0f_SET
#define READ_RX_X4_TSC_12_MLD_VL_INFO_0r BCMI_TSC_XGXS_READ_RX_X4_TSC_12_MLD_VL_INFO_0r
#define WRITE_RX_X4_TSC_12_MLD_VL_INFO_0r BCMI_TSC_XGXS_WRITE_RX_X4_TSC_12_MLD_VL_INFO_0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X4_TSC_12_MLD_VL_INFO_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RX_X4_TSC_12_BARREL_SHIFTER_STATE
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc177
 * DESC:     "Barrel Shifter State": 00000000
 * SIZE:     32
 * FIELDS:
 *     SHIFT_AMMOUNT    
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RX_X4_TSC_12_BARREL_SHIFTER_STATEr (0x0000c177 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RX_X4_TSC_12_BARREL_SHIFTER_STATEr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_TSC_12_BARREL_SHIFTER_STATE.
 *
 */
typedef union BCMI_TSC_XGXS_RX_X4_TSC_12_BARREL_SHIFTER_STATEr_s {
	uint32_t v[1];
	uint32_t rx_x4_tsc_12_barrel_shifter_state[1];
	uint32_t _rx_x4_tsc_12_barrel_shifter_state;
} BCMI_TSC_XGXS_RX_X4_TSC_12_BARREL_SHIFTER_STATEr_t;

#define BCMI_TSC_XGXS_RX_X4_TSC_12_BARREL_SHIFTER_STATEr_CLR(r) (r).rx_x4_tsc_12_barrel_shifter_state[0] = 0
#define BCMI_TSC_XGXS_RX_X4_TSC_12_BARREL_SHIFTER_STATEr_SET(r,d) (r).rx_x4_tsc_12_barrel_shifter_state[0] = d
#define BCMI_TSC_XGXS_RX_X4_TSC_12_BARREL_SHIFTER_STATEr_GET(r) (r).rx_x4_tsc_12_barrel_shifter_state[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RX_X4_TSC_12_BARREL_SHIFTER_STATEr_RESERVED0f_GET(r) ((((r).rx_x4_tsc_12_barrel_shifter_state[0]) >> 8) & 0xff)
#define BCMI_TSC_XGXS_RX_X4_TSC_12_BARREL_SHIFTER_STATEr_RESERVED0f_SET(r,f) (r).rx_x4_tsc_12_barrel_shifter_state[0]=(((r).rx_x4_tsc_12_barrel_shifter_state[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCMI_TSC_XGXS_RX_X4_TSC_12_BARREL_SHIFTER_STATEr_SHIFT_AMMOUNTf_GET(r) (((r).rx_x4_tsc_12_barrel_shifter_state[0]) & 0xff)
#define BCMI_TSC_XGXS_RX_X4_TSC_12_BARREL_SHIFTER_STATEr_SHIFT_AMMOUNTf_SET(r,f) (r).rx_x4_tsc_12_barrel_shifter_state[0]=(((r).rx_x4_tsc_12_barrel_shifter_state[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access RX_X4_TSC_12_BARREL_SHIFTER_STATE.
 *
 */
#define BCMI_TSC_XGXS_READ_RX_X4_TSC_12_BARREL_SHIFTER_STATEr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RX_X4_TSC_12_BARREL_SHIFTER_STATEr,(_r._rx_x4_tsc_12_barrel_shifter_state))
#define BCMI_TSC_XGXS_WRITE_RX_X4_TSC_12_BARREL_SHIFTER_STATEr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RX_X4_TSC_12_BARREL_SHIFTER_STATEr,(_r._rx_x4_tsc_12_barrel_shifter_state))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_TSC_12_BARREL_SHIFTER_STATEr BCMI_TSC_XGXS_RX_X4_TSC_12_BARREL_SHIFTER_STATEr
#define RX_X4_TSC_12_BARREL_SHIFTER_STATEr_SIZE BCMI_TSC_XGXS_RX_X4_TSC_12_BARREL_SHIFTER_STATEr_SIZE
typedef BCMI_TSC_XGXS_RX_X4_TSC_12_BARREL_SHIFTER_STATEr_t RX_X4_TSC_12_BARREL_SHIFTER_STATEr_t;
#define RX_X4_TSC_12_BARREL_SHIFTER_STATEr_CLR BCMI_TSC_XGXS_RX_X4_TSC_12_BARREL_SHIFTER_STATEr_CLR
#define RX_X4_TSC_12_BARREL_SHIFTER_STATEr_SET BCMI_TSC_XGXS_RX_X4_TSC_12_BARREL_SHIFTER_STATEr_SET
#define RX_X4_TSC_12_BARREL_SHIFTER_STATEr_GET BCMI_TSC_XGXS_RX_X4_TSC_12_BARREL_SHIFTER_STATEr_GET
#define RX_X4_TSC_12_BARREL_SHIFTER_STATEr_RESERVED0f_GET BCMI_TSC_XGXS_RX_X4_TSC_12_BARREL_SHIFTER_STATEr_RESERVED0f_GET
#define RX_X4_TSC_12_BARREL_SHIFTER_STATEr_RESERVED0f_SET BCMI_TSC_XGXS_RX_X4_TSC_12_BARREL_SHIFTER_STATEr_RESERVED0f_SET
#define RX_X4_TSC_12_BARREL_SHIFTER_STATEr_SHIFT_AMMOUNTf_GET BCMI_TSC_XGXS_RX_X4_TSC_12_BARREL_SHIFTER_STATEr_SHIFT_AMMOUNTf_GET
#define RX_X4_TSC_12_BARREL_SHIFTER_STATEr_SHIFT_AMMOUNTf_SET BCMI_TSC_XGXS_RX_X4_TSC_12_BARREL_SHIFTER_STATEr_SHIFT_AMMOUNTf_SET
#define READ_RX_X4_TSC_12_BARREL_SHIFTER_STATEr BCMI_TSC_XGXS_READ_RX_X4_TSC_12_BARREL_SHIFTER_STATEr
#define WRITE_RX_X4_TSC_12_BARREL_SHIFTER_STATEr BCMI_TSC_XGXS_WRITE_RX_X4_TSC_12_BARREL_SHIFTER_STATEr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RX_X4_TSC_12_BARREL_SHIFTER_STATEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  ENABLES
 * BLOCKS:   AN_X4_ABILITIES
 * REGADDR:  0xc180
 * DESC:     AN ENABLES: 00000000
 * SIZE:     32
 * FIELDS:
 *     CL73_AN_RESTART  
 *     CL37_AN_RESTART  
 *     HPAM_TO_CL37_AUTO_ENABLE 
 *     CL73_BAM_TO_HPAM_AUTO_ENABLE 
 *     SGMII_TO_CL37_AUTO_ENABLE 
 *     CL37_BAM_TO_SGMII_AUTO_ENABLE 
 *     CL37_ENABLE      
 *     CL37_SGMII_ENABLE 
 *     CL73_ENABLE      
 *     CL73_HPAM_ENABLE 
 *     CL73_BAM_ENABLE  
 *     CL37_BAM_ENABLE  
 *     NUM_ADVERTISED_LANES 
 *     AN_SETUP_ENABLE  
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_ENABLESr (0x0000c180 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_ENABLESr_SIZE 4

/*
 * This structure should be used to declare and program ENABLES.
 *
 */
typedef union BCMI_TSC_XGXS_ENABLESr_s {
	uint32_t v[1];
	uint32_t enables[1];
	uint32_t _enables;
} BCMI_TSC_XGXS_ENABLESr_t;

#define BCMI_TSC_XGXS_ENABLESr_CLR(r) (r).enables[0] = 0
#define BCMI_TSC_XGXS_ENABLESr_SET(r,d) (r).enables[0] = d
#define BCMI_TSC_XGXS_ENABLESr_GET(r) (r).enables[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_ENABLESr_RESERVED0f_GET(r) ((((r).enables[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_ENABLESr_RESERVED0f_SET(r,f) (r).enables[0]=(((r).enables[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_ENABLESr_AN_SETUP_ENABLEf_GET(r) ((((r).enables[0]) >> 14) & 0x1)
#define BCMI_TSC_XGXS_ENABLESr_AN_SETUP_ENABLEf_SET(r,f) (r).enables[0]=(((r).enables[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCMI_TSC_XGXS_ENABLESr_NUM_ADVERTISED_LANESf_GET(r) ((((r).enables[0]) >> 12) & 0x3)
#define BCMI_TSC_XGXS_ENABLESr_NUM_ADVERTISED_LANESf_SET(r,f) (r).enables[0]=(((r).enables[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCMI_TSC_XGXS_ENABLESr_CL37_BAM_ENABLEf_GET(r) ((((r).enables[0]) >> 11) & 0x1)
#define BCMI_TSC_XGXS_ENABLESr_CL37_BAM_ENABLEf_SET(r,f) (r).enables[0]=(((r).enables[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCMI_TSC_XGXS_ENABLESr_CL73_BAM_ENABLEf_GET(r) ((((r).enables[0]) >> 10) & 0x1)
#define BCMI_TSC_XGXS_ENABLESr_CL73_BAM_ENABLEf_SET(r,f) (r).enables[0]=(((r).enables[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCMI_TSC_XGXS_ENABLESr_CL73_HPAM_ENABLEf_GET(r) ((((r).enables[0]) >> 9) & 0x1)
#define BCMI_TSC_XGXS_ENABLESr_CL73_HPAM_ENABLEf_SET(r,f) (r).enables[0]=(((r).enables[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCMI_TSC_XGXS_ENABLESr_CL73_ENABLEf_GET(r) ((((r).enables[0]) >> 8) & 0x1)
#define BCMI_TSC_XGXS_ENABLESr_CL73_ENABLEf_SET(r,f) (r).enables[0]=(((r).enables[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCMI_TSC_XGXS_ENABLESr_CL37_SGMII_ENABLEf_GET(r) ((((r).enables[0]) >> 7) & 0x1)
#define BCMI_TSC_XGXS_ENABLESr_CL37_SGMII_ENABLEf_SET(r,f) (r).enables[0]=(((r).enables[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCMI_TSC_XGXS_ENABLESr_CL37_ENABLEf_GET(r) ((((r).enables[0]) >> 6) & 0x1)
#define BCMI_TSC_XGXS_ENABLESr_CL37_ENABLEf_SET(r,f) (r).enables[0]=(((r).enables[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCMI_TSC_XGXS_ENABLESr_CL37_BAM_TO_SGMII_AUTO_ENABLEf_GET(r) ((((r).enables[0]) >> 5) & 0x1)
#define BCMI_TSC_XGXS_ENABLESr_CL37_BAM_TO_SGMII_AUTO_ENABLEf_SET(r,f) (r).enables[0]=(((r).enables[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCMI_TSC_XGXS_ENABLESr_SGMII_TO_CL37_AUTO_ENABLEf_GET(r) ((((r).enables[0]) >> 4) & 0x1)
#define BCMI_TSC_XGXS_ENABLESr_SGMII_TO_CL37_AUTO_ENABLEf_SET(r,f) (r).enables[0]=(((r).enables[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCMI_TSC_XGXS_ENABLESr_CL73_BAM_TO_HPAM_AUTO_ENABLEf_GET(r) ((((r).enables[0]) >> 3) & 0x1)
#define BCMI_TSC_XGXS_ENABLESr_CL73_BAM_TO_HPAM_AUTO_ENABLEf_SET(r,f) (r).enables[0]=(((r).enables[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCMI_TSC_XGXS_ENABLESr_HPAM_TO_CL37_AUTO_ENABLEf_GET(r) ((((r).enables[0]) >> 2) & 0x1)
#define BCMI_TSC_XGXS_ENABLESr_HPAM_TO_CL37_AUTO_ENABLEf_SET(r,f) (r).enables[0]=(((r).enables[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCMI_TSC_XGXS_ENABLESr_CL37_AN_RESTARTf_GET(r) ((((r).enables[0]) >> 1) & 0x1)
#define BCMI_TSC_XGXS_ENABLESr_CL37_AN_RESTARTf_SET(r,f) (r).enables[0]=(((r).enables[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCMI_TSC_XGXS_ENABLESr_CL73_AN_RESTARTf_GET(r) (((r).enables[0]) & 0x1)
#define BCMI_TSC_XGXS_ENABLESr_CL73_AN_RESTARTf_SET(r,f) (r).enables[0]=(((r).enables[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access ENABLES.
 *
 */
#define BCMI_TSC_XGXS_READ_ENABLESr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_ENABLESr,(_r._enables))
#define BCMI_TSC_XGXS_WRITE_ENABLESr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_ENABLESr,(_r._enables))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define ENABLESr BCMI_TSC_XGXS_ENABLESr
#define ENABLESr_SIZE BCMI_TSC_XGXS_ENABLESr_SIZE
typedef BCMI_TSC_XGXS_ENABLESr_t ENABLESr_t;
#define ENABLESr_CLR BCMI_TSC_XGXS_ENABLESr_CLR
#define ENABLESr_SET BCMI_TSC_XGXS_ENABLESr_SET
#define ENABLESr_GET BCMI_TSC_XGXS_ENABLESr_GET
#define ENABLESr_RESERVED0f_GET BCMI_TSC_XGXS_ENABLESr_RESERVED0f_GET
#define ENABLESr_RESERVED0f_SET BCMI_TSC_XGXS_ENABLESr_RESERVED0f_SET
#define ENABLESr_AN_SETUP_ENABLEf_GET BCMI_TSC_XGXS_ENABLESr_AN_SETUP_ENABLEf_GET
#define ENABLESr_AN_SETUP_ENABLEf_SET BCMI_TSC_XGXS_ENABLESr_AN_SETUP_ENABLEf_SET
#define ENABLESr_NUM_ADVERTISED_LANESf_GET BCMI_TSC_XGXS_ENABLESr_NUM_ADVERTISED_LANESf_GET
#define ENABLESr_NUM_ADVERTISED_LANESf_SET BCMI_TSC_XGXS_ENABLESr_NUM_ADVERTISED_LANESf_SET
#define ENABLESr_CL37_BAM_ENABLEf_GET BCMI_TSC_XGXS_ENABLESr_CL37_BAM_ENABLEf_GET
#define ENABLESr_CL37_BAM_ENABLEf_SET BCMI_TSC_XGXS_ENABLESr_CL37_BAM_ENABLEf_SET
#define ENABLESr_CL73_BAM_ENABLEf_GET BCMI_TSC_XGXS_ENABLESr_CL73_BAM_ENABLEf_GET
#define ENABLESr_CL73_BAM_ENABLEf_SET BCMI_TSC_XGXS_ENABLESr_CL73_BAM_ENABLEf_SET
#define ENABLESr_CL73_HPAM_ENABLEf_GET BCMI_TSC_XGXS_ENABLESr_CL73_HPAM_ENABLEf_GET
#define ENABLESr_CL73_HPAM_ENABLEf_SET BCMI_TSC_XGXS_ENABLESr_CL73_HPAM_ENABLEf_SET
#define ENABLESr_CL73_ENABLEf_GET BCMI_TSC_XGXS_ENABLESr_CL73_ENABLEf_GET
#define ENABLESr_CL73_ENABLEf_SET BCMI_TSC_XGXS_ENABLESr_CL73_ENABLEf_SET
#define ENABLESr_CL37_SGMII_ENABLEf_GET BCMI_TSC_XGXS_ENABLESr_CL37_SGMII_ENABLEf_GET
#define ENABLESr_CL37_SGMII_ENABLEf_SET BCMI_TSC_XGXS_ENABLESr_CL37_SGMII_ENABLEf_SET
#define ENABLESr_CL37_ENABLEf_GET BCMI_TSC_XGXS_ENABLESr_CL37_ENABLEf_GET
#define ENABLESr_CL37_ENABLEf_SET BCMI_TSC_XGXS_ENABLESr_CL37_ENABLEf_SET
#define ENABLESr_CL37_BAM_TO_SGMII_AUTO_ENABLEf_GET BCMI_TSC_XGXS_ENABLESr_CL37_BAM_TO_SGMII_AUTO_ENABLEf_GET
#define ENABLESr_CL37_BAM_TO_SGMII_AUTO_ENABLEf_SET BCMI_TSC_XGXS_ENABLESr_CL37_BAM_TO_SGMII_AUTO_ENABLEf_SET
#define ENABLESr_SGMII_TO_CL37_AUTO_ENABLEf_GET BCMI_TSC_XGXS_ENABLESr_SGMII_TO_CL37_AUTO_ENABLEf_GET
#define ENABLESr_SGMII_TO_CL37_AUTO_ENABLEf_SET BCMI_TSC_XGXS_ENABLESr_SGMII_TO_CL37_AUTO_ENABLEf_SET
#define ENABLESr_CL73_BAM_TO_HPAM_AUTO_ENABLEf_GET BCMI_TSC_XGXS_ENABLESr_CL73_BAM_TO_HPAM_AUTO_ENABLEf_GET
#define ENABLESr_CL73_BAM_TO_HPAM_AUTO_ENABLEf_SET BCMI_TSC_XGXS_ENABLESr_CL73_BAM_TO_HPAM_AUTO_ENABLEf_SET
#define ENABLESr_HPAM_TO_CL37_AUTO_ENABLEf_GET BCMI_TSC_XGXS_ENABLESr_HPAM_TO_CL37_AUTO_ENABLEf_GET
#define ENABLESr_HPAM_TO_CL37_AUTO_ENABLEf_SET BCMI_TSC_XGXS_ENABLESr_HPAM_TO_CL37_AUTO_ENABLEf_SET
#define ENABLESr_CL37_AN_RESTARTf_GET BCMI_TSC_XGXS_ENABLESr_CL37_AN_RESTARTf_GET
#define ENABLESr_CL37_AN_RESTARTf_SET BCMI_TSC_XGXS_ENABLESr_CL37_AN_RESTARTf_SET
#define ENABLESr_CL73_AN_RESTARTf_GET BCMI_TSC_XGXS_ENABLESr_CL73_AN_RESTARTf_GET
#define ENABLESr_CL73_AN_RESTARTf_SET BCMI_TSC_XGXS_ENABLESr_CL73_AN_RESTARTf_SET
#define READ_ENABLESr BCMI_TSC_XGXS_READ_ENABLESr
#define WRITE_ENABLESr BCMI_TSC_XGXS_WRITE_ENABLESr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_ENABLESr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CL37_BASE_ABIL
 * BLOCKS:   AN_X4_ABILITIES_LOCAL_DEVICE
 * REGADDR:  0xc181
 * DESC:     CL37 BASE PAGE ABILITIES: 00000000
 * SIZE:     32
 * FIELDS:
 *     SGMII_SPEED      
 *     SGMII_FULL_DUPLEX 
 *     RESERVED1        
 *     CL37_FULL_DUPLEX 
 *     CL37_HALF_DUPLEX 
 *     CL37_PAUSE       
 *     CL37_NEXT_PAGE   
 *     SGMII_MASTER_MODE 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CL37_BASE_ABILr (0x0000c181 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CL37_BASE_ABILr_SIZE 4

/*
 * This structure should be used to declare and program CL37_BASE_ABIL.
 *
 */
typedef union BCMI_TSC_XGXS_CL37_BASE_ABILr_s {
	uint32_t v[1];
	uint32_t cl37_base_abil[1];
	uint32_t _cl37_base_abil;
} BCMI_TSC_XGXS_CL37_BASE_ABILr_t;

#define BCMI_TSC_XGXS_CL37_BASE_ABILr_CLR(r) (r).cl37_base_abil[0] = 0
#define BCMI_TSC_XGXS_CL37_BASE_ABILr_SET(r,d) (r).cl37_base_abil[0] = d
#define BCMI_TSC_XGXS_CL37_BASE_ABILr_GET(r) (r).cl37_base_abil[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CL37_BASE_ABILr_RESERVED0f_GET(r) ((((r).cl37_base_abil[0]) >> 10) & 0x3f)
#define BCMI_TSC_XGXS_CL37_BASE_ABILr_RESERVED0f_SET(r,f) (r).cl37_base_abil[0]=(((r).cl37_base_abil[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))
#define BCMI_TSC_XGXS_CL37_BASE_ABILr_SGMII_MASTER_MODEf_GET(r) ((((r).cl37_base_abil[0]) >> 9) & 0x1)
#define BCMI_TSC_XGXS_CL37_BASE_ABILr_SGMII_MASTER_MODEf_SET(r,f) (r).cl37_base_abil[0]=(((r).cl37_base_abil[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCMI_TSC_XGXS_CL37_BASE_ABILr_CL37_NEXT_PAGEf_GET(r) ((((r).cl37_base_abil[0]) >> 8) & 0x1)
#define BCMI_TSC_XGXS_CL37_BASE_ABILr_CL37_NEXT_PAGEf_SET(r,f) (r).cl37_base_abil[0]=(((r).cl37_base_abil[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCMI_TSC_XGXS_CL37_BASE_ABILr_CL37_PAUSEf_GET(r) ((((r).cl37_base_abil[0]) >> 6) & 0x3)
#define BCMI_TSC_XGXS_CL37_BASE_ABILr_CL37_PAUSEf_SET(r,f) (r).cl37_base_abil[0]=(((r).cl37_base_abil[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCMI_TSC_XGXS_CL37_BASE_ABILr_CL37_HALF_DUPLEXf_GET(r) ((((r).cl37_base_abil[0]) >> 5) & 0x1)
#define BCMI_TSC_XGXS_CL37_BASE_ABILr_CL37_HALF_DUPLEXf_SET(r,f) (r).cl37_base_abil[0]=(((r).cl37_base_abil[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCMI_TSC_XGXS_CL37_BASE_ABILr_CL37_FULL_DUPLEXf_GET(r) ((((r).cl37_base_abil[0]) >> 4) & 0x1)
#define BCMI_TSC_XGXS_CL37_BASE_ABILr_CL37_FULL_DUPLEXf_SET(r,f) (r).cl37_base_abil[0]=(((r).cl37_base_abil[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCMI_TSC_XGXS_CL37_BASE_ABILr_RESERVED1f_GET(r) ((((r).cl37_base_abil[0]) >> 3) & 0x1)
#define BCMI_TSC_XGXS_CL37_BASE_ABILr_RESERVED1f_SET(r,f) (r).cl37_base_abil[0]=(((r).cl37_base_abil[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCMI_TSC_XGXS_CL37_BASE_ABILr_SGMII_FULL_DUPLEXf_GET(r) ((((r).cl37_base_abil[0]) >> 2) & 0x1)
#define BCMI_TSC_XGXS_CL37_BASE_ABILr_SGMII_FULL_DUPLEXf_SET(r,f) (r).cl37_base_abil[0]=(((r).cl37_base_abil[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCMI_TSC_XGXS_CL37_BASE_ABILr_SGMII_SPEEDf_GET(r) (((r).cl37_base_abil[0]) & 0x3)
#define BCMI_TSC_XGXS_CL37_BASE_ABILr_SGMII_SPEEDf_SET(r,f) (r).cl37_base_abil[0]=(((r).cl37_base_abil[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))

/*
 * These macros can be used to access CL37_BASE_ABIL.
 *
 */
#define BCMI_TSC_XGXS_READ_CL37_BASE_ABILr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CL37_BASE_ABILr,(_r._cl37_base_abil))
#define BCMI_TSC_XGXS_WRITE_CL37_BASE_ABILr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CL37_BASE_ABILr,(_r._cl37_base_abil))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL37_BASE_ABILr BCMI_TSC_XGXS_CL37_BASE_ABILr
#define CL37_BASE_ABILr_SIZE BCMI_TSC_XGXS_CL37_BASE_ABILr_SIZE
typedef BCMI_TSC_XGXS_CL37_BASE_ABILr_t CL37_BASE_ABILr_t;
#define CL37_BASE_ABILr_CLR BCMI_TSC_XGXS_CL37_BASE_ABILr_CLR
#define CL37_BASE_ABILr_SET BCMI_TSC_XGXS_CL37_BASE_ABILr_SET
#define CL37_BASE_ABILr_GET BCMI_TSC_XGXS_CL37_BASE_ABILr_GET
#define CL37_BASE_ABILr_RESERVED0f_GET BCMI_TSC_XGXS_CL37_BASE_ABILr_RESERVED0f_GET
#define CL37_BASE_ABILr_RESERVED0f_SET BCMI_TSC_XGXS_CL37_BASE_ABILr_RESERVED0f_SET
#define CL37_BASE_ABILr_SGMII_MASTER_MODEf_GET BCMI_TSC_XGXS_CL37_BASE_ABILr_SGMII_MASTER_MODEf_GET
#define CL37_BASE_ABILr_SGMII_MASTER_MODEf_SET BCMI_TSC_XGXS_CL37_BASE_ABILr_SGMII_MASTER_MODEf_SET
#define CL37_BASE_ABILr_CL37_NEXT_PAGEf_GET BCMI_TSC_XGXS_CL37_BASE_ABILr_CL37_NEXT_PAGEf_GET
#define CL37_BASE_ABILr_CL37_NEXT_PAGEf_SET BCMI_TSC_XGXS_CL37_BASE_ABILr_CL37_NEXT_PAGEf_SET
#define CL37_BASE_ABILr_CL37_PAUSEf_GET BCMI_TSC_XGXS_CL37_BASE_ABILr_CL37_PAUSEf_GET
#define CL37_BASE_ABILr_CL37_PAUSEf_SET BCMI_TSC_XGXS_CL37_BASE_ABILr_CL37_PAUSEf_SET
#define CL37_BASE_ABILr_CL37_HALF_DUPLEXf_GET BCMI_TSC_XGXS_CL37_BASE_ABILr_CL37_HALF_DUPLEXf_GET
#define CL37_BASE_ABILr_CL37_HALF_DUPLEXf_SET BCMI_TSC_XGXS_CL37_BASE_ABILr_CL37_HALF_DUPLEXf_SET
#define CL37_BASE_ABILr_CL37_FULL_DUPLEXf_GET BCMI_TSC_XGXS_CL37_BASE_ABILr_CL37_FULL_DUPLEXf_GET
#define CL37_BASE_ABILr_CL37_FULL_DUPLEXf_SET BCMI_TSC_XGXS_CL37_BASE_ABILr_CL37_FULL_DUPLEXf_SET
#define CL37_BASE_ABILr_RESERVED1f_GET BCMI_TSC_XGXS_CL37_BASE_ABILr_RESERVED1f_GET
#define CL37_BASE_ABILr_RESERVED1f_SET BCMI_TSC_XGXS_CL37_BASE_ABILr_RESERVED1f_SET
#define CL37_BASE_ABILr_SGMII_FULL_DUPLEXf_GET BCMI_TSC_XGXS_CL37_BASE_ABILr_SGMII_FULL_DUPLEXf_GET
#define CL37_BASE_ABILr_SGMII_FULL_DUPLEXf_SET BCMI_TSC_XGXS_CL37_BASE_ABILr_SGMII_FULL_DUPLEXf_SET
#define CL37_BASE_ABILr_SGMII_SPEEDf_GET BCMI_TSC_XGXS_CL37_BASE_ABILr_SGMII_SPEEDf_GET
#define CL37_BASE_ABILr_SGMII_SPEEDf_SET BCMI_TSC_XGXS_CL37_BASE_ABILr_SGMII_SPEEDf_SET
#define READ_CL37_BASE_ABILr BCMI_TSC_XGXS_READ_CL37_BASE_ABILr
#define WRITE_CL37_BASE_ABILr BCMI_TSC_XGXS_WRITE_CL37_BASE_ABILr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CL37_BASE_ABILr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CL37_BAM_ABIL
 * BLOCKS:   AN_X4_ABILITIES_LOCAL_DEVICE
 * REGADDR:  0xc182
 * DESC:     CL37 BAM ABILITIES: 00000000
 * SIZE:     32
 * FIELDS:
 *     OVER1G_PAGE_COUNT 
 *     OVER1G_ABILITY   
 *     CL37_BAM_CODE    
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CL37_BAM_ABILr (0x0000c182 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CL37_BAM_ABILr_SIZE 4

/*
 * This structure should be used to declare and program CL37_BAM_ABIL.
 *
 */
typedef union BCMI_TSC_XGXS_CL37_BAM_ABILr_s {
	uint32_t v[1];
	uint32_t cl37_bam_abil[1];
	uint32_t _cl37_bam_abil;
} BCMI_TSC_XGXS_CL37_BAM_ABILr_t;

#define BCMI_TSC_XGXS_CL37_BAM_ABILr_CLR(r) (r).cl37_bam_abil[0] = 0
#define BCMI_TSC_XGXS_CL37_BAM_ABILr_SET(r,d) (r).cl37_bam_abil[0] = d
#define BCMI_TSC_XGXS_CL37_BAM_ABILr_GET(r) (r).cl37_bam_abil[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CL37_BAM_ABILr_RESERVED0f_GET(r) ((((r).cl37_bam_abil[0]) >> 12) & 0xf)
#define BCMI_TSC_XGXS_CL37_BAM_ABILr_RESERVED0f_SET(r,f) (r).cl37_bam_abil[0]=(((r).cl37_bam_abil[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCMI_TSC_XGXS_CL37_BAM_ABILr_CL37_BAM_CODEf_GET(r) ((((r).cl37_bam_abil[0]) >> 3) & 0x1ff)
#define BCMI_TSC_XGXS_CL37_BAM_ABILr_CL37_BAM_CODEf_SET(r,f) (r).cl37_bam_abil[0]=(((r).cl37_bam_abil[0] & ~((uint32_t)0x1ff << 3)) | ((((uint32_t)f) & 0x1ff) << 3))
#define BCMI_TSC_XGXS_CL37_BAM_ABILr_OVER1G_ABILITYf_GET(r) ((((r).cl37_bam_abil[0]) >> 2) & 0x1)
#define BCMI_TSC_XGXS_CL37_BAM_ABILr_OVER1G_ABILITYf_SET(r,f) (r).cl37_bam_abil[0]=(((r).cl37_bam_abil[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCMI_TSC_XGXS_CL37_BAM_ABILr_OVER1G_PAGE_COUNTf_GET(r) (((r).cl37_bam_abil[0]) & 0x3)
#define BCMI_TSC_XGXS_CL37_BAM_ABILr_OVER1G_PAGE_COUNTf_SET(r,f) (r).cl37_bam_abil[0]=(((r).cl37_bam_abil[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))

/*
 * These macros can be used to access CL37_BAM_ABIL.
 *
 */
#define BCMI_TSC_XGXS_READ_CL37_BAM_ABILr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CL37_BAM_ABILr,(_r._cl37_bam_abil))
#define BCMI_TSC_XGXS_WRITE_CL37_BAM_ABILr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CL37_BAM_ABILr,(_r._cl37_bam_abil))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL37_BAM_ABILr BCMI_TSC_XGXS_CL37_BAM_ABILr
#define CL37_BAM_ABILr_SIZE BCMI_TSC_XGXS_CL37_BAM_ABILr_SIZE
typedef BCMI_TSC_XGXS_CL37_BAM_ABILr_t CL37_BAM_ABILr_t;
#define CL37_BAM_ABILr_CLR BCMI_TSC_XGXS_CL37_BAM_ABILr_CLR
#define CL37_BAM_ABILr_SET BCMI_TSC_XGXS_CL37_BAM_ABILr_SET
#define CL37_BAM_ABILr_GET BCMI_TSC_XGXS_CL37_BAM_ABILr_GET
#define CL37_BAM_ABILr_RESERVED0f_GET BCMI_TSC_XGXS_CL37_BAM_ABILr_RESERVED0f_GET
#define CL37_BAM_ABILr_RESERVED0f_SET BCMI_TSC_XGXS_CL37_BAM_ABILr_RESERVED0f_SET
#define CL37_BAM_ABILr_CL37_BAM_CODEf_GET BCMI_TSC_XGXS_CL37_BAM_ABILr_CL37_BAM_CODEf_GET
#define CL37_BAM_ABILr_CL37_BAM_CODEf_SET BCMI_TSC_XGXS_CL37_BAM_ABILr_CL37_BAM_CODEf_SET
#define CL37_BAM_ABILr_OVER1G_ABILITYf_GET BCMI_TSC_XGXS_CL37_BAM_ABILr_OVER1G_ABILITYf_GET
#define CL37_BAM_ABILr_OVER1G_ABILITYf_SET BCMI_TSC_XGXS_CL37_BAM_ABILr_OVER1G_ABILITYf_SET
#define CL37_BAM_ABILr_OVER1G_PAGE_COUNTf_GET BCMI_TSC_XGXS_CL37_BAM_ABILr_OVER1G_PAGE_COUNTf_GET
#define CL37_BAM_ABILr_OVER1G_PAGE_COUNTf_SET BCMI_TSC_XGXS_CL37_BAM_ABILr_OVER1G_PAGE_COUNTf_SET
#define READ_CL37_BAM_ABILr BCMI_TSC_XGXS_READ_CL37_BAM_ABILr
#define WRITE_CL37_BAM_ABILr BCMI_TSC_XGXS_WRITE_CL37_BAM_ABILr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CL37_BAM_ABILr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  OVER1G_ABIL_1
 * BLOCKS:   AN_X4_ABILITIES_LOCAL_DEVICE
 * REGADDR:  0xc183
 * DESC:     Cl37 OVER1G ABILITIES REG 1: 00000000
 * SIZE:     32
 * FIELDS:
 *     BAM_13GBASE_X4   
 *     BAM_15GBASE_X4   
 *     BAM_15P75GBASE_X2 
 *     BAM_16GBASE_X4   
 *     BAM_20GBASE_X4_CX4 
 *     BAM_20GBASE_X4   
 *     BAM_20GBASE_X2   
 *     BAM_20GBASE_X2_CX4 
 *     BAM_21GBASE_X4   
 *     BAM_25P455GBASE_X4 
 *     BAM_31P5GBASE_X4 
 *     BAM_32P7GBASE_X4 
 *     BAM_40GBASE_X4   
 *     CL72             
 *     FEC              
 *     HG2              
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_OVER1G_ABIL_1r (0x0000c183 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_OVER1G_ABIL_1r_SIZE 4

/*
 * This structure should be used to declare and program OVER1G_ABIL_1.
 *
 */
typedef union BCMI_TSC_XGXS_OVER1G_ABIL_1r_s {
	uint32_t v[1];
	uint32_t over1g_abil_1[1];
	uint32_t _over1g_abil_1;
} BCMI_TSC_XGXS_OVER1G_ABIL_1r_t;

#define BCMI_TSC_XGXS_OVER1G_ABIL_1r_CLR(r) (r).over1g_abil_1[0] = 0
#define BCMI_TSC_XGXS_OVER1G_ABIL_1r_SET(r,d) (r).over1g_abil_1[0] = d
#define BCMI_TSC_XGXS_OVER1G_ABIL_1r_GET(r) (r).over1g_abil_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_OVER1G_ABIL_1r_HG2f_GET(r) ((((r).over1g_abil_1[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_OVER1G_ABIL_1r_HG2f_SET(r,f) (r).over1g_abil_1[0]=(((r).over1g_abil_1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_OVER1G_ABIL_1r_FECf_GET(r) ((((r).over1g_abil_1[0]) >> 14) & 0x1)
#define BCMI_TSC_XGXS_OVER1G_ABIL_1r_FECf_SET(r,f) (r).over1g_abil_1[0]=(((r).over1g_abil_1[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCMI_TSC_XGXS_OVER1G_ABIL_1r_CL72f_GET(r) ((((r).over1g_abil_1[0]) >> 13) & 0x1)
#define BCMI_TSC_XGXS_OVER1G_ABIL_1r_CL72f_SET(r,f) (r).over1g_abil_1[0]=(((r).over1g_abil_1[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCMI_TSC_XGXS_OVER1G_ABIL_1r_BAM_40GBASE_X4f_GET(r) ((((r).over1g_abil_1[0]) >> 12) & 0x1)
#define BCMI_TSC_XGXS_OVER1G_ABIL_1r_BAM_40GBASE_X4f_SET(r,f) (r).over1g_abil_1[0]=(((r).over1g_abil_1[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCMI_TSC_XGXS_OVER1G_ABIL_1r_BAM_32P7GBASE_X4f_GET(r) ((((r).over1g_abil_1[0]) >> 11) & 0x1)
#define BCMI_TSC_XGXS_OVER1G_ABIL_1r_BAM_32P7GBASE_X4f_SET(r,f) (r).over1g_abil_1[0]=(((r).over1g_abil_1[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCMI_TSC_XGXS_OVER1G_ABIL_1r_BAM_31P5GBASE_X4f_GET(r) ((((r).over1g_abil_1[0]) >> 10) & 0x1)
#define BCMI_TSC_XGXS_OVER1G_ABIL_1r_BAM_31P5GBASE_X4f_SET(r,f) (r).over1g_abil_1[0]=(((r).over1g_abil_1[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCMI_TSC_XGXS_OVER1G_ABIL_1r_BAM_25P455GBASE_X4f_GET(r) ((((r).over1g_abil_1[0]) >> 9) & 0x1)
#define BCMI_TSC_XGXS_OVER1G_ABIL_1r_BAM_25P455GBASE_X4f_SET(r,f) (r).over1g_abil_1[0]=(((r).over1g_abil_1[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCMI_TSC_XGXS_OVER1G_ABIL_1r_BAM_21GBASE_X4f_GET(r) ((((r).over1g_abil_1[0]) >> 8) & 0x1)
#define BCMI_TSC_XGXS_OVER1G_ABIL_1r_BAM_21GBASE_X4f_SET(r,f) (r).over1g_abil_1[0]=(((r).over1g_abil_1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCMI_TSC_XGXS_OVER1G_ABIL_1r_BAM_20GBASE_X2_CX4f_GET(r) ((((r).over1g_abil_1[0]) >> 7) & 0x1)
#define BCMI_TSC_XGXS_OVER1G_ABIL_1r_BAM_20GBASE_X2_CX4f_SET(r,f) (r).over1g_abil_1[0]=(((r).over1g_abil_1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCMI_TSC_XGXS_OVER1G_ABIL_1r_BAM_20GBASE_X2f_GET(r) ((((r).over1g_abil_1[0]) >> 6) & 0x1)
#define BCMI_TSC_XGXS_OVER1G_ABIL_1r_BAM_20GBASE_X2f_SET(r,f) (r).over1g_abil_1[0]=(((r).over1g_abil_1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCMI_TSC_XGXS_OVER1G_ABIL_1r_BAM_20GBASE_X4f_GET(r) ((((r).over1g_abil_1[0]) >> 5) & 0x1)
#define BCMI_TSC_XGXS_OVER1G_ABIL_1r_BAM_20GBASE_X4f_SET(r,f) (r).over1g_abil_1[0]=(((r).over1g_abil_1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCMI_TSC_XGXS_OVER1G_ABIL_1r_BAM_20GBASE_X4_CX4f_GET(r) ((((r).over1g_abil_1[0]) >> 4) & 0x1)
#define BCMI_TSC_XGXS_OVER1G_ABIL_1r_BAM_20GBASE_X4_CX4f_SET(r,f) (r).over1g_abil_1[0]=(((r).over1g_abil_1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCMI_TSC_XGXS_OVER1G_ABIL_1r_BAM_16GBASE_X4f_GET(r) ((((r).over1g_abil_1[0]) >> 3) & 0x1)
#define BCMI_TSC_XGXS_OVER1G_ABIL_1r_BAM_16GBASE_X4f_SET(r,f) (r).over1g_abil_1[0]=(((r).over1g_abil_1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCMI_TSC_XGXS_OVER1G_ABIL_1r_BAM_15P75GBASE_X2f_GET(r) ((((r).over1g_abil_1[0]) >> 2) & 0x1)
#define BCMI_TSC_XGXS_OVER1G_ABIL_1r_BAM_15P75GBASE_X2f_SET(r,f) (r).over1g_abil_1[0]=(((r).over1g_abil_1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCMI_TSC_XGXS_OVER1G_ABIL_1r_BAM_15GBASE_X4f_GET(r) ((((r).over1g_abil_1[0]) >> 1) & 0x1)
#define BCMI_TSC_XGXS_OVER1G_ABIL_1r_BAM_15GBASE_X4f_SET(r,f) (r).over1g_abil_1[0]=(((r).over1g_abil_1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCMI_TSC_XGXS_OVER1G_ABIL_1r_BAM_13GBASE_X4f_GET(r) (((r).over1g_abil_1[0]) & 0x1)
#define BCMI_TSC_XGXS_OVER1G_ABIL_1r_BAM_13GBASE_X4f_SET(r,f) (r).over1g_abil_1[0]=(((r).over1g_abil_1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access OVER1G_ABIL_1.
 *
 */
#define BCMI_TSC_XGXS_READ_OVER1G_ABIL_1r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_OVER1G_ABIL_1r,(_r._over1g_abil_1))
#define BCMI_TSC_XGXS_WRITE_OVER1G_ABIL_1r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_OVER1G_ABIL_1r,(_r._over1g_abil_1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define OVER1G_ABIL_1r BCMI_TSC_XGXS_OVER1G_ABIL_1r
#define OVER1G_ABIL_1r_SIZE BCMI_TSC_XGXS_OVER1G_ABIL_1r_SIZE
typedef BCMI_TSC_XGXS_OVER1G_ABIL_1r_t OVER1G_ABIL_1r_t;
#define OVER1G_ABIL_1r_CLR BCMI_TSC_XGXS_OVER1G_ABIL_1r_CLR
#define OVER1G_ABIL_1r_SET BCMI_TSC_XGXS_OVER1G_ABIL_1r_SET
#define OVER1G_ABIL_1r_GET BCMI_TSC_XGXS_OVER1G_ABIL_1r_GET
#define OVER1G_ABIL_1r_HG2f_GET BCMI_TSC_XGXS_OVER1G_ABIL_1r_HG2f_GET
#define OVER1G_ABIL_1r_HG2f_SET BCMI_TSC_XGXS_OVER1G_ABIL_1r_HG2f_SET
#define OVER1G_ABIL_1r_FECf_GET BCMI_TSC_XGXS_OVER1G_ABIL_1r_FECf_GET
#define OVER1G_ABIL_1r_FECf_SET BCMI_TSC_XGXS_OVER1G_ABIL_1r_FECf_SET
#define OVER1G_ABIL_1r_CL72f_GET BCMI_TSC_XGXS_OVER1G_ABIL_1r_CL72f_GET
#define OVER1G_ABIL_1r_CL72f_SET BCMI_TSC_XGXS_OVER1G_ABIL_1r_CL72f_SET
#define OVER1G_ABIL_1r_BAM_40GBASE_X4f_GET BCMI_TSC_XGXS_OVER1G_ABIL_1r_BAM_40GBASE_X4f_GET
#define OVER1G_ABIL_1r_BAM_40GBASE_X4f_SET BCMI_TSC_XGXS_OVER1G_ABIL_1r_BAM_40GBASE_X4f_SET
#define OVER1G_ABIL_1r_BAM_32P7GBASE_X4f_GET BCMI_TSC_XGXS_OVER1G_ABIL_1r_BAM_32P7GBASE_X4f_GET
#define OVER1G_ABIL_1r_BAM_32P7GBASE_X4f_SET BCMI_TSC_XGXS_OVER1G_ABIL_1r_BAM_32P7GBASE_X4f_SET
#define OVER1G_ABIL_1r_BAM_31P5GBASE_X4f_GET BCMI_TSC_XGXS_OVER1G_ABIL_1r_BAM_31P5GBASE_X4f_GET
#define OVER1G_ABIL_1r_BAM_31P5GBASE_X4f_SET BCMI_TSC_XGXS_OVER1G_ABIL_1r_BAM_31P5GBASE_X4f_SET
#define OVER1G_ABIL_1r_BAM_25P455GBASE_X4f_GET BCMI_TSC_XGXS_OVER1G_ABIL_1r_BAM_25P455GBASE_X4f_GET
#define OVER1G_ABIL_1r_BAM_25P455GBASE_X4f_SET BCMI_TSC_XGXS_OVER1G_ABIL_1r_BAM_25P455GBASE_X4f_SET
#define OVER1G_ABIL_1r_BAM_21GBASE_X4f_GET BCMI_TSC_XGXS_OVER1G_ABIL_1r_BAM_21GBASE_X4f_GET
#define OVER1G_ABIL_1r_BAM_21GBASE_X4f_SET BCMI_TSC_XGXS_OVER1G_ABIL_1r_BAM_21GBASE_X4f_SET
#define OVER1G_ABIL_1r_BAM_20GBASE_X2_CX4f_GET BCMI_TSC_XGXS_OVER1G_ABIL_1r_BAM_20GBASE_X2_CX4f_GET
#define OVER1G_ABIL_1r_BAM_20GBASE_X2_CX4f_SET BCMI_TSC_XGXS_OVER1G_ABIL_1r_BAM_20GBASE_X2_CX4f_SET
#define OVER1G_ABIL_1r_BAM_20GBASE_X2f_GET BCMI_TSC_XGXS_OVER1G_ABIL_1r_BAM_20GBASE_X2f_GET
#define OVER1G_ABIL_1r_BAM_20GBASE_X2f_SET BCMI_TSC_XGXS_OVER1G_ABIL_1r_BAM_20GBASE_X2f_SET
#define OVER1G_ABIL_1r_BAM_20GBASE_X4f_GET BCMI_TSC_XGXS_OVER1G_ABIL_1r_BAM_20GBASE_X4f_GET
#define OVER1G_ABIL_1r_BAM_20GBASE_X4f_SET BCMI_TSC_XGXS_OVER1G_ABIL_1r_BAM_20GBASE_X4f_SET
#define OVER1G_ABIL_1r_BAM_20GBASE_X4_CX4f_GET BCMI_TSC_XGXS_OVER1G_ABIL_1r_BAM_20GBASE_X4_CX4f_GET
#define OVER1G_ABIL_1r_BAM_20GBASE_X4_CX4f_SET BCMI_TSC_XGXS_OVER1G_ABIL_1r_BAM_20GBASE_X4_CX4f_SET
#define OVER1G_ABIL_1r_BAM_16GBASE_X4f_GET BCMI_TSC_XGXS_OVER1G_ABIL_1r_BAM_16GBASE_X4f_GET
#define OVER1G_ABIL_1r_BAM_16GBASE_X4f_SET BCMI_TSC_XGXS_OVER1G_ABIL_1r_BAM_16GBASE_X4f_SET
#define OVER1G_ABIL_1r_BAM_15P75GBASE_X2f_GET BCMI_TSC_XGXS_OVER1G_ABIL_1r_BAM_15P75GBASE_X2f_GET
#define OVER1G_ABIL_1r_BAM_15P75GBASE_X2f_SET BCMI_TSC_XGXS_OVER1G_ABIL_1r_BAM_15P75GBASE_X2f_SET
#define OVER1G_ABIL_1r_BAM_15GBASE_X4f_GET BCMI_TSC_XGXS_OVER1G_ABIL_1r_BAM_15GBASE_X4f_GET
#define OVER1G_ABIL_1r_BAM_15GBASE_X4f_SET BCMI_TSC_XGXS_OVER1G_ABIL_1r_BAM_15GBASE_X4f_SET
#define OVER1G_ABIL_1r_BAM_13GBASE_X4f_GET BCMI_TSC_XGXS_OVER1G_ABIL_1r_BAM_13GBASE_X4f_GET
#define OVER1G_ABIL_1r_BAM_13GBASE_X4f_SET BCMI_TSC_XGXS_OVER1G_ABIL_1r_BAM_13GBASE_X4f_SET
#define READ_OVER1G_ABIL_1r BCMI_TSC_XGXS_READ_OVER1G_ABIL_1r
#define WRITE_OVER1G_ABIL_1r BCMI_TSC_XGXS_WRITE_OVER1G_ABIL_1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_OVER1G_ABIL_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  OVER1G_ABIL_0
 * BLOCKS:   AN_X4_ABILITIES_LOCAL_DEVICE
 * REGADDR:  0xc184
 * DESC:     Cl37 OVER1G ABILITIES REG 0: 00000000
 * SIZE:     32
 * FIELDS:
 *     BAM_2P5GBASE_X   
 *     BAM_5GBASE_X4    
 *     BAM_6GBASE_X4    
 *     BAM_10GBASE_X4   
 *     BAM_10GBASE_X4_CX4 
 *     BAM_10GBASE_X2   
 *     BAM_10GBASE_X2_CX4 
 *     BAM_10P5GBASE_X2 
 *     BAM_12GBASE_X4   
 *     BAM_12P5GBASE_X4 
 *     BAM_12P7GBASE_X2 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_OVER1G_ABIL_0r (0x0000c184 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_OVER1G_ABIL_0r_SIZE 4

/*
 * This structure should be used to declare and program OVER1G_ABIL_0.
 *
 */
typedef union BCMI_TSC_XGXS_OVER1G_ABIL_0r_s {
	uint32_t v[1];
	uint32_t over1g_abil_0[1];
	uint32_t _over1g_abil_0;
} BCMI_TSC_XGXS_OVER1G_ABIL_0r_t;

#define BCMI_TSC_XGXS_OVER1G_ABIL_0r_CLR(r) (r).over1g_abil_0[0] = 0
#define BCMI_TSC_XGXS_OVER1G_ABIL_0r_SET(r,d) (r).over1g_abil_0[0] = d
#define BCMI_TSC_XGXS_OVER1G_ABIL_0r_GET(r) (r).over1g_abil_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_OVER1G_ABIL_0r_RESERVED0f_GET(r) ((((r).over1g_abil_0[0]) >> 11) & 0x1f)
#define BCMI_TSC_XGXS_OVER1G_ABIL_0r_RESERVED0f_SET(r,f) (r).over1g_abil_0[0]=(((r).over1g_abil_0[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))
#define BCMI_TSC_XGXS_OVER1G_ABIL_0r_BAM_12P7GBASE_X2f_GET(r) ((((r).over1g_abil_0[0]) >> 10) & 0x1)
#define BCMI_TSC_XGXS_OVER1G_ABIL_0r_BAM_12P7GBASE_X2f_SET(r,f) (r).over1g_abil_0[0]=(((r).over1g_abil_0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCMI_TSC_XGXS_OVER1G_ABIL_0r_BAM_12P5GBASE_X4f_GET(r) ((((r).over1g_abil_0[0]) >> 9) & 0x1)
#define BCMI_TSC_XGXS_OVER1G_ABIL_0r_BAM_12P5GBASE_X4f_SET(r,f) (r).over1g_abil_0[0]=(((r).over1g_abil_0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCMI_TSC_XGXS_OVER1G_ABIL_0r_BAM_12GBASE_X4f_GET(r) ((((r).over1g_abil_0[0]) >> 8) & 0x1)
#define BCMI_TSC_XGXS_OVER1G_ABIL_0r_BAM_12GBASE_X4f_SET(r,f) (r).over1g_abil_0[0]=(((r).over1g_abil_0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCMI_TSC_XGXS_OVER1G_ABIL_0r_BAM_10P5GBASE_X2f_GET(r) ((((r).over1g_abil_0[0]) >> 7) & 0x1)
#define BCMI_TSC_XGXS_OVER1G_ABIL_0r_BAM_10P5GBASE_X2f_SET(r,f) (r).over1g_abil_0[0]=(((r).over1g_abil_0[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCMI_TSC_XGXS_OVER1G_ABIL_0r_BAM_10GBASE_X2_CX4f_GET(r) ((((r).over1g_abil_0[0]) >> 6) & 0x1)
#define BCMI_TSC_XGXS_OVER1G_ABIL_0r_BAM_10GBASE_X2_CX4f_SET(r,f) (r).over1g_abil_0[0]=(((r).over1g_abil_0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCMI_TSC_XGXS_OVER1G_ABIL_0r_BAM_10GBASE_X2f_GET(r) ((((r).over1g_abil_0[0]) >> 5) & 0x1)
#define BCMI_TSC_XGXS_OVER1G_ABIL_0r_BAM_10GBASE_X2f_SET(r,f) (r).over1g_abil_0[0]=(((r).over1g_abil_0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCMI_TSC_XGXS_OVER1G_ABIL_0r_BAM_10GBASE_X4_CX4f_GET(r) ((((r).over1g_abil_0[0]) >> 4) & 0x1)
#define BCMI_TSC_XGXS_OVER1G_ABIL_0r_BAM_10GBASE_X4_CX4f_SET(r,f) (r).over1g_abil_0[0]=(((r).over1g_abil_0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCMI_TSC_XGXS_OVER1G_ABIL_0r_BAM_10GBASE_X4f_GET(r) ((((r).over1g_abil_0[0]) >> 3) & 0x1)
#define BCMI_TSC_XGXS_OVER1G_ABIL_0r_BAM_10GBASE_X4f_SET(r,f) (r).over1g_abil_0[0]=(((r).over1g_abil_0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCMI_TSC_XGXS_OVER1G_ABIL_0r_BAM_6GBASE_X4f_GET(r) ((((r).over1g_abil_0[0]) >> 2) & 0x1)
#define BCMI_TSC_XGXS_OVER1G_ABIL_0r_BAM_6GBASE_X4f_SET(r,f) (r).over1g_abil_0[0]=(((r).over1g_abil_0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCMI_TSC_XGXS_OVER1G_ABIL_0r_BAM_5GBASE_X4f_GET(r) ((((r).over1g_abil_0[0]) >> 1) & 0x1)
#define BCMI_TSC_XGXS_OVER1G_ABIL_0r_BAM_5GBASE_X4f_SET(r,f) (r).over1g_abil_0[0]=(((r).over1g_abil_0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCMI_TSC_XGXS_OVER1G_ABIL_0r_BAM_2P5GBASE_Xf_GET(r) (((r).over1g_abil_0[0]) & 0x1)
#define BCMI_TSC_XGXS_OVER1G_ABIL_0r_BAM_2P5GBASE_Xf_SET(r,f) (r).over1g_abil_0[0]=(((r).over1g_abil_0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access OVER1G_ABIL_0.
 *
 */
#define BCMI_TSC_XGXS_READ_OVER1G_ABIL_0r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_OVER1G_ABIL_0r,(_r._over1g_abil_0))
#define BCMI_TSC_XGXS_WRITE_OVER1G_ABIL_0r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_OVER1G_ABIL_0r,(_r._over1g_abil_0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define OVER1G_ABIL_0r BCMI_TSC_XGXS_OVER1G_ABIL_0r
#define OVER1G_ABIL_0r_SIZE BCMI_TSC_XGXS_OVER1G_ABIL_0r_SIZE
typedef BCMI_TSC_XGXS_OVER1G_ABIL_0r_t OVER1G_ABIL_0r_t;
#define OVER1G_ABIL_0r_CLR BCMI_TSC_XGXS_OVER1G_ABIL_0r_CLR
#define OVER1G_ABIL_0r_SET BCMI_TSC_XGXS_OVER1G_ABIL_0r_SET
#define OVER1G_ABIL_0r_GET BCMI_TSC_XGXS_OVER1G_ABIL_0r_GET
#define OVER1G_ABIL_0r_RESERVED0f_GET BCMI_TSC_XGXS_OVER1G_ABIL_0r_RESERVED0f_GET
#define OVER1G_ABIL_0r_RESERVED0f_SET BCMI_TSC_XGXS_OVER1G_ABIL_0r_RESERVED0f_SET
#define OVER1G_ABIL_0r_BAM_12P7GBASE_X2f_GET BCMI_TSC_XGXS_OVER1G_ABIL_0r_BAM_12P7GBASE_X2f_GET
#define OVER1G_ABIL_0r_BAM_12P7GBASE_X2f_SET BCMI_TSC_XGXS_OVER1G_ABIL_0r_BAM_12P7GBASE_X2f_SET
#define OVER1G_ABIL_0r_BAM_12P5GBASE_X4f_GET BCMI_TSC_XGXS_OVER1G_ABIL_0r_BAM_12P5GBASE_X4f_GET
#define OVER1G_ABIL_0r_BAM_12P5GBASE_X4f_SET BCMI_TSC_XGXS_OVER1G_ABIL_0r_BAM_12P5GBASE_X4f_SET
#define OVER1G_ABIL_0r_BAM_12GBASE_X4f_GET BCMI_TSC_XGXS_OVER1G_ABIL_0r_BAM_12GBASE_X4f_GET
#define OVER1G_ABIL_0r_BAM_12GBASE_X4f_SET BCMI_TSC_XGXS_OVER1G_ABIL_0r_BAM_12GBASE_X4f_SET
#define OVER1G_ABIL_0r_BAM_10P5GBASE_X2f_GET BCMI_TSC_XGXS_OVER1G_ABIL_0r_BAM_10P5GBASE_X2f_GET
#define OVER1G_ABIL_0r_BAM_10P5GBASE_X2f_SET BCMI_TSC_XGXS_OVER1G_ABIL_0r_BAM_10P5GBASE_X2f_SET
#define OVER1G_ABIL_0r_BAM_10GBASE_X2_CX4f_GET BCMI_TSC_XGXS_OVER1G_ABIL_0r_BAM_10GBASE_X2_CX4f_GET
#define OVER1G_ABIL_0r_BAM_10GBASE_X2_CX4f_SET BCMI_TSC_XGXS_OVER1G_ABIL_0r_BAM_10GBASE_X2_CX4f_SET
#define OVER1G_ABIL_0r_BAM_10GBASE_X2f_GET BCMI_TSC_XGXS_OVER1G_ABIL_0r_BAM_10GBASE_X2f_GET
#define OVER1G_ABIL_0r_BAM_10GBASE_X2f_SET BCMI_TSC_XGXS_OVER1G_ABIL_0r_BAM_10GBASE_X2f_SET
#define OVER1G_ABIL_0r_BAM_10GBASE_X4_CX4f_GET BCMI_TSC_XGXS_OVER1G_ABIL_0r_BAM_10GBASE_X4_CX4f_GET
#define OVER1G_ABIL_0r_BAM_10GBASE_X4_CX4f_SET BCMI_TSC_XGXS_OVER1G_ABIL_0r_BAM_10GBASE_X4_CX4f_SET
#define OVER1G_ABIL_0r_BAM_10GBASE_X4f_GET BCMI_TSC_XGXS_OVER1G_ABIL_0r_BAM_10GBASE_X4f_GET
#define OVER1G_ABIL_0r_BAM_10GBASE_X4f_SET BCMI_TSC_XGXS_OVER1G_ABIL_0r_BAM_10GBASE_X4f_SET
#define OVER1G_ABIL_0r_BAM_6GBASE_X4f_GET BCMI_TSC_XGXS_OVER1G_ABIL_0r_BAM_6GBASE_X4f_GET
#define OVER1G_ABIL_0r_BAM_6GBASE_X4f_SET BCMI_TSC_XGXS_OVER1G_ABIL_0r_BAM_6GBASE_X4f_SET
#define OVER1G_ABIL_0r_BAM_5GBASE_X4f_GET BCMI_TSC_XGXS_OVER1G_ABIL_0r_BAM_5GBASE_X4f_GET
#define OVER1G_ABIL_0r_BAM_5GBASE_X4f_SET BCMI_TSC_XGXS_OVER1G_ABIL_0r_BAM_5GBASE_X4f_SET
#define OVER1G_ABIL_0r_BAM_2P5GBASE_Xf_GET BCMI_TSC_XGXS_OVER1G_ABIL_0r_BAM_2P5GBASE_Xf_GET
#define OVER1G_ABIL_0r_BAM_2P5GBASE_Xf_SET BCMI_TSC_XGXS_OVER1G_ABIL_0r_BAM_2P5GBASE_Xf_SET
#define READ_OVER1G_ABIL_0r BCMI_TSC_XGXS_READ_OVER1G_ABIL_0r
#define WRITE_OVER1G_ABIL_0r BCMI_TSC_XGXS_WRITE_OVER1G_ABIL_0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_OVER1G_ABIL_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CL73_BASE_ABIL_1
 * BLOCKS:   AN_X4_ABILITIES_LOCAL_DEVICE
 * REGADDR:  0xc185
 * DESC:     CL73 BASE PAGE ABILITIES REG 1: 00000000
 * SIZE:     32
 * FIELDS:
 *     BASE_SELECTOR    
 *     TRANSMIT_NONCE   
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CL73_BASE_ABIL_1r (0x0000c185 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CL73_BASE_ABIL_1r_SIZE 4

/*
 * This structure should be used to declare and program CL73_BASE_ABIL_1.
 *
 */
typedef union BCMI_TSC_XGXS_CL73_BASE_ABIL_1r_s {
	uint32_t v[1];
	uint32_t cl73_base_abil_1[1];
	uint32_t _cl73_base_abil_1;
} BCMI_TSC_XGXS_CL73_BASE_ABIL_1r_t;

#define BCMI_TSC_XGXS_CL73_BASE_ABIL_1r_CLR(r) (r).cl73_base_abil_1[0] = 0
#define BCMI_TSC_XGXS_CL73_BASE_ABIL_1r_SET(r,d) (r).cl73_base_abil_1[0] = d
#define BCMI_TSC_XGXS_CL73_BASE_ABIL_1r_GET(r) (r).cl73_base_abil_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CL73_BASE_ABIL_1r_RESERVED0f_GET(r) ((((r).cl73_base_abil_1[0]) >> 10) & 0x3f)
#define BCMI_TSC_XGXS_CL73_BASE_ABIL_1r_RESERVED0f_SET(r,f) (r).cl73_base_abil_1[0]=(((r).cl73_base_abil_1[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))
#define BCMI_TSC_XGXS_CL73_BASE_ABIL_1r_TRANSMIT_NONCEf_GET(r) ((((r).cl73_base_abil_1[0]) >> 5) & 0x1f)
#define BCMI_TSC_XGXS_CL73_BASE_ABIL_1r_TRANSMIT_NONCEf_SET(r,f) (r).cl73_base_abil_1[0]=(((r).cl73_base_abil_1[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5))
#define BCMI_TSC_XGXS_CL73_BASE_ABIL_1r_BASE_SELECTORf_GET(r) (((r).cl73_base_abil_1[0]) & 0x1f)
#define BCMI_TSC_XGXS_CL73_BASE_ABIL_1r_BASE_SELECTORf_SET(r,f) (r).cl73_base_abil_1[0]=(((r).cl73_base_abil_1[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))

/*
 * These macros can be used to access CL73_BASE_ABIL_1.
 *
 */
#define BCMI_TSC_XGXS_READ_CL73_BASE_ABIL_1r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CL73_BASE_ABIL_1r,(_r._cl73_base_abil_1))
#define BCMI_TSC_XGXS_WRITE_CL73_BASE_ABIL_1r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CL73_BASE_ABIL_1r,(_r._cl73_base_abil_1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL73_BASE_ABIL_1r BCMI_TSC_XGXS_CL73_BASE_ABIL_1r
#define CL73_BASE_ABIL_1r_SIZE BCMI_TSC_XGXS_CL73_BASE_ABIL_1r_SIZE
typedef BCMI_TSC_XGXS_CL73_BASE_ABIL_1r_t CL73_BASE_ABIL_1r_t;
#define CL73_BASE_ABIL_1r_CLR BCMI_TSC_XGXS_CL73_BASE_ABIL_1r_CLR
#define CL73_BASE_ABIL_1r_SET BCMI_TSC_XGXS_CL73_BASE_ABIL_1r_SET
#define CL73_BASE_ABIL_1r_GET BCMI_TSC_XGXS_CL73_BASE_ABIL_1r_GET
#define CL73_BASE_ABIL_1r_RESERVED0f_GET BCMI_TSC_XGXS_CL73_BASE_ABIL_1r_RESERVED0f_GET
#define CL73_BASE_ABIL_1r_RESERVED0f_SET BCMI_TSC_XGXS_CL73_BASE_ABIL_1r_RESERVED0f_SET
#define CL73_BASE_ABIL_1r_TRANSMIT_NONCEf_GET BCMI_TSC_XGXS_CL73_BASE_ABIL_1r_TRANSMIT_NONCEf_GET
#define CL73_BASE_ABIL_1r_TRANSMIT_NONCEf_SET BCMI_TSC_XGXS_CL73_BASE_ABIL_1r_TRANSMIT_NONCEf_SET
#define CL73_BASE_ABIL_1r_BASE_SELECTORf_GET BCMI_TSC_XGXS_CL73_BASE_ABIL_1r_BASE_SELECTORf_GET
#define CL73_BASE_ABIL_1r_BASE_SELECTORf_SET BCMI_TSC_XGXS_CL73_BASE_ABIL_1r_BASE_SELECTORf_SET
#define READ_CL73_BASE_ABIL_1r BCMI_TSC_XGXS_READ_CL73_BASE_ABIL_1r
#define WRITE_CL73_BASE_ABIL_1r BCMI_TSC_XGXS_WRITE_CL73_BASE_ABIL_1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CL73_BASE_ABIL_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CL73_BASE_ABIL_0
 * BLOCKS:   AN_X4_ABILITIES_LOCAL_DEVICE
 * REGADDR:  0xc186
 * DESC:     CL73 BASE PAGE ABILITIES REG 0: 00000000
 * SIZE:     32
 * FIELDS:
 *     BASE_100GBASE_CR10 
 *     BASE_40GBASE_CR4 
 *     BASE_40GBASE_KR4 
 *     BASE_10GBASE_KR  
 *     BASE_10GBASE_KX4 
 *     BASE_1000BASE_KX 
 *     CL73_PAUSE       
 *     FEC              
 *     NEXT_PAGE        
 *     CL73_REMOTE_FAULT 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CL73_BASE_ABIL_0r (0x0000c186 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CL73_BASE_ABIL_0r_SIZE 4

/*
 * This structure should be used to declare and program CL73_BASE_ABIL_0.
 *
 */
typedef union BCMI_TSC_XGXS_CL73_BASE_ABIL_0r_s {
	uint32_t v[1];
	uint32_t cl73_base_abil_0[1];
	uint32_t _cl73_base_abil_0;
} BCMI_TSC_XGXS_CL73_BASE_ABIL_0r_t;

#define BCMI_TSC_XGXS_CL73_BASE_ABIL_0r_CLR(r) (r).cl73_base_abil_0[0] = 0
#define BCMI_TSC_XGXS_CL73_BASE_ABIL_0r_SET(r,d) (r).cl73_base_abil_0[0] = d
#define BCMI_TSC_XGXS_CL73_BASE_ABIL_0r_GET(r) (r).cl73_base_abil_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CL73_BASE_ABIL_0r_RESERVED0f_GET(r) ((((r).cl73_base_abil_0[0]) >> 12) & 0xf)
#define BCMI_TSC_XGXS_CL73_BASE_ABIL_0r_RESERVED0f_SET(r,f) (r).cl73_base_abil_0[0]=(((r).cl73_base_abil_0[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCMI_TSC_XGXS_CL73_BASE_ABIL_0r_CL73_REMOTE_FAULTf_GET(r) ((((r).cl73_base_abil_0[0]) >> 11) & 0x1)
#define BCMI_TSC_XGXS_CL73_BASE_ABIL_0r_CL73_REMOTE_FAULTf_SET(r,f) (r).cl73_base_abil_0[0]=(((r).cl73_base_abil_0[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCMI_TSC_XGXS_CL73_BASE_ABIL_0r_NEXT_PAGEf_GET(r) ((((r).cl73_base_abil_0[0]) >> 10) & 0x1)
#define BCMI_TSC_XGXS_CL73_BASE_ABIL_0r_NEXT_PAGEf_SET(r,f) (r).cl73_base_abil_0[0]=(((r).cl73_base_abil_0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCMI_TSC_XGXS_CL73_BASE_ABIL_0r_FECf_GET(r) ((((r).cl73_base_abil_0[0]) >> 8) & 0x3)
#define BCMI_TSC_XGXS_CL73_BASE_ABIL_0r_FECf_SET(r,f) (r).cl73_base_abil_0[0]=(((r).cl73_base_abil_0[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCMI_TSC_XGXS_CL73_BASE_ABIL_0r_CL73_PAUSEf_GET(r) ((((r).cl73_base_abil_0[0]) >> 6) & 0x3)
#define BCMI_TSC_XGXS_CL73_BASE_ABIL_0r_CL73_PAUSEf_SET(r,f) (r).cl73_base_abil_0[0]=(((r).cl73_base_abil_0[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCMI_TSC_XGXS_CL73_BASE_ABIL_0r_BASE_1000BASE_KXf_GET(r) ((((r).cl73_base_abil_0[0]) >> 5) & 0x1)
#define BCMI_TSC_XGXS_CL73_BASE_ABIL_0r_BASE_1000BASE_KXf_SET(r,f) (r).cl73_base_abil_0[0]=(((r).cl73_base_abil_0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCMI_TSC_XGXS_CL73_BASE_ABIL_0r_BASE_10GBASE_KX4f_GET(r) ((((r).cl73_base_abil_0[0]) >> 4) & 0x1)
#define BCMI_TSC_XGXS_CL73_BASE_ABIL_0r_BASE_10GBASE_KX4f_SET(r,f) (r).cl73_base_abil_0[0]=(((r).cl73_base_abil_0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCMI_TSC_XGXS_CL73_BASE_ABIL_0r_BASE_10GBASE_KRf_GET(r) ((((r).cl73_base_abil_0[0]) >> 3) & 0x1)
#define BCMI_TSC_XGXS_CL73_BASE_ABIL_0r_BASE_10GBASE_KRf_SET(r,f) (r).cl73_base_abil_0[0]=(((r).cl73_base_abil_0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCMI_TSC_XGXS_CL73_BASE_ABIL_0r_BASE_40GBASE_KR4f_GET(r) ((((r).cl73_base_abil_0[0]) >> 2) & 0x1)
#define BCMI_TSC_XGXS_CL73_BASE_ABIL_0r_BASE_40GBASE_KR4f_SET(r,f) (r).cl73_base_abil_0[0]=(((r).cl73_base_abil_0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCMI_TSC_XGXS_CL73_BASE_ABIL_0r_BASE_40GBASE_CR4f_GET(r) ((((r).cl73_base_abil_0[0]) >> 1) & 0x1)
#define BCMI_TSC_XGXS_CL73_BASE_ABIL_0r_BASE_40GBASE_CR4f_SET(r,f) (r).cl73_base_abil_0[0]=(((r).cl73_base_abil_0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCMI_TSC_XGXS_CL73_BASE_ABIL_0r_BASE_100GBASE_CR10f_GET(r) (((r).cl73_base_abil_0[0]) & 0x1)
#define BCMI_TSC_XGXS_CL73_BASE_ABIL_0r_BASE_100GBASE_CR10f_SET(r,f) (r).cl73_base_abil_0[0]=(((r).cl73_base_abil_0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access CL73_BASE_ABIL_0.
 *
 */
#define BCMI_TSC_XGXS_READ_CL73_BASE_ABIL_0r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CL73_BASE_ABIL_0r,(_r._cl73_base_abil_0))
#define BCMI_TSC_XGXS_WRITE_CL73_BASE_ABIL_0r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CL73_BASE_ABIL_0r,(_r._cl73_base_abil_0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL73_BASE_ABIL_0r BCMI_TSC_XGXS_CL73_BASE_ABIL_0r
#define CL73_BASE_ABIL_0r_SIZE BCMI_TSC_XGXS_CL73_BASE_ABIL_0r_SIZE
typedef BCMI_TSC_XGXS_CL73_BASE_ABIL_0r_t CL73_BASE_ABIL_0r_t;
#define CL73_BASE_ABIL_0r_CLR BCMI_TSC_XGXS_CL73_BASE_ABIL_0r_CLR
#define CL73_BASE_ABIL_0r_SET BCMI_TSC_XGXS_CL73_BASE_ABIL_0r_SET
#define CL73_BASE_ABIL_0r_GET BCMI_TSC_XGXS_CL73_BASE_ABIL_0r_GET
#define CL73_BASE_ABIL_0r_RESERVED0f_GET BCMI_TSC_XGXS_CL73_BASE_ABIL_0r_RESERVED0f_GET
#define CL73_BASE_ABIL_0r_RESERVED0f_SET BCMI_TSC_XGXS_CL73_BASE_ABIL_0r_RESERVED0f_SET
#define CL73_BASE_ABIL_0r_CL73_REMOTE_FAULTf_GET BCMI_TSC_XGXS_CL73_BASE_ABIL_0r_CL73_REMOTE_FAULTf_GET
#define CL73_BASE_ABIL_0r_CL73_REMOTE_FAULTf_SET BCMI_TSC_XGXS_CL73_BASE_ABIL_0r_CL73_REMOTE_FAULTf_SET
#define CL73_BASE_ABIL_0r_NEXT_PAGEf_GET BCMI_TSC_XGXS_CL73_BASE_ABIL_0r_NEXT_PAGEf_GET
#define CL73_BASE_ABIL_0r_NEXT_PAGEf_SET BCMI_TSC_XGXS_CL73_BASE_ABIL_0r_NEXT_PAGEf_SET
#define CL73_BASE_ABIL_0r_FECf_GET BCMI_TSC_XGXS_CL73_BASE_ABIL_0r_FECf_GET
#define CL73_BASE_ABIL_0r_FECf_SET BCMI_TSC_XGXS_CL73_BASE_ABIL_0r_FECf_SET
#define CL73_BASE_ABIL_0r_CL73_PAUSEf_GET BCMI_TSC_XGXS_CL73_BASE_ABIL_0r_CL73_PAUSEf_GET
#define CL73_BASE_ABIL_0r_CL73_PAUSEf_SET BCMI_TSC_XGXS_CL73_BASE_ABIL_0r_CL73_PAUSEf_SET
#define CL73_BASE_ABIL_0r_BASE_1000BASE_KXf_GET BCMI_TSC_XGXS_CL73_BASE_ABIL_0r_BASE_1000BASE_KXf_GET
#define CL73_BASE_ABIL_0r_BASE_1000BASE_KXf_SET BCMI_TSC_XGXS_CL73_BASE_ABIL_0r_BASE_1000BASE_KXf_SET
#define CL73_BASE_ABIL_0r_BASE_10GBASE_KX4f_GET BCMI_TSC_XGXS_CL73_BASE_ABIL_0r_BASE_10GBASE_KX4f_GET
#define CL73_BASE_ABIL_0r_BASE_10GBASE_KX4f_SET BCMI_TSC_XGXS_CL73_BASE_ABIL_0r_BASE_10GBASE_KX4f_SET
#define CL73_BASE_ABIL_0r_BASE_10GBASE_KRf_GET BCMI_TSC_XGXS_CL73_BASE_ABIL_0r_BASE_10GBASE_KRf_GET
#define CL73_BASE_ABIL_0r_BASE_10GBASE_KRf_SET BCMI_TSC_XGXS_CL73_BASE_ABIL_0r_BASE_10GBASE_KRf_SET
#define CL73_BASE_ABIL_0r_BASE_40GBASE_KR4f_GET BCMI_TSC_XGXS_CL73_BASE_ABIL_0r_BASE_40GBASE_KR4f_GET
#define CL73_BASE_ABIL_0r_BASE_40GBASE_KR4f_SET BCMI_TSC_XGXS_CL73_BASE_ABIL_0r_BASE_40GBASE_KR4f_SET
#define CL73_BASE_ABIL_0r_BASE_40GBASE_CR4f_GET BCMI_TSC_XGXS_CL73_BASE_ABIL_0r_BASE_40GBASE_CR4f_GET
#define CL73_BASE_ABIL_0r_BASE_40GBASE_CR4f_SET BCMI_TSC_XGXS_CL73_BASE_ABIL_0r_BASE_40GBASE_CR4f_SET
#define CL73_BASE_ABIL_0r_BASE_100GBASE_CR10f_GET BCMI_TSC_XGXS_CL73_BASE_ABIL_0r_BASE_100GBASE_CR10f_GET
#define CL73_BASE_ABIL_0r_BASE_100GBASE_CR10f_SET BCMI_TSC_XGXS_CL73_BASE_ABIL_0r_BASE_100GBASE_CR10f_SET
#define READ_CL73_BASE_ABIL_0r BCMI_TSC_XGXS_READ_CL73_BASE_ABIL_0r
#define WRITE_CL73_BASE_ABIL_0r BCMI_TSC_XGXS_WRITE_CL73_BASE_ABIL_0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CL73_BASE_ABIL_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CL73_BAM_ABIL
 * BLOCKS:   AN_X4_ABILITIES_LOCAL_DEVICE
 * REGADDR:  0xc187
 * DESC:     CL73 BAM ABILITIES: 00000000
 * SIZE:     32
 * FIELDS:
 *     BAM_20GBASE_KR2  
 *     BAM_20GBASE_CR2  
 *     CL73_BAM_CODE    
 *     HPAM_20GKR2      
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CL73_BAM_ABILr (0x0000c187 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CL73_BAM_ABILr_SIZE 4

/*
 * This structure should be used to declare and program CL73_BAM_ABIL.
 *
 */
typedef union BCMI_TSC_XGXS_CL73_BAM_ABILr_s {
	uint32_t v[1];
	uint32_t cl73_bam_abil[1];
	uint32_t _cl73_bam_abil;
} BCMI_TSC_XGXS_CL73_BAM_ABILr_t;

#define BCMI_TSC_XGXS_CL73_BAM_ABILr_CLR(r) (r).cl73_bam_abil[0] = 0
#define BCMI_TSC_XGXS_CL73_BAM_ABILr_SET(r,d) (r).cl73_bam_abil[0] = d
#define BCMI_TSC_XGXS_CL73_BAM_ABILr_GET(r) (r).cl73_bam_abil[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CL73_BAM_ABILr_RESERVED0f_GET(r) ((((r).cl73_bam_abil[0]) >> 12) & 0xf)
#define BCMI_TSC_XGXS_CL73_BAM_ABILr_RESERVED0f_SET(r,f) (r).cl73_bam_abil[0]=(((r).cl73_bam_abil[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCMI_TSC_XGXS_CL73_BAM_ABILr_HPAM_20GKR2f_GET(r) ((((r).cl73_bam_abil[0]) >> 11) & 0x1)
#define BCMI_TSC_XGXS_CL73_BAM_ABILr_HPAM_20GKR2f_SET(r,f) (r).cl73_bam_abil[0]=(((r).cl73_bam_abil[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCMI_TSC_XGXS_CL73_BAM_ABILr_CL73_BAM_CODEf_GET(r) ((((r).cl73_bam_abil[0]) >> 2) & 0x1ff)
#define BCMI_TSC_XGXS_CL73_BAM_ABILr_CL73_BAM_CODEf_SET(r,f) (r).cl73_bam_abil[0]=(((r).cl73_bam_abil[0] & ~((uint32_t)0x1ff << 2)) | ((((uint32_t)f) & 0x1ff) << 2))
#define BCMI_TSC_XGXS_CL73_BAM_ABILr_BAM_20GBASE_CR2f_GET(r) ((((r).cl73_bam_abil[0]) >> 1) & 0x1)
#define BCMI_TSC_XGXS_CL73_BAM_ABILr_BAM_20GBASE_CR2f_SET(r,f) (r).cl73_bam_abil[0]=(((r).cl73_bam_abil[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCMI_TSC_XGXS_CL73_BAM_ABILr_BAM_20GBASE_KR2f_GET(r) (((r).cl73_bam_abil[0]) & 0x1)
#define BCMI_TSC_XGXS_CL73_BAM_ABILr_BAM_20GBASE_KR2f_SET(r,f) (r).cl73_bam_abil[0]=(((r).cl73_bam_abil[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access CL73_BAM_ABIL.
 *
 */
#define BCMI_TSC_XGXS_READ_CL73_BAM_ABILr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CL73_BAM_ABILr,(_r._cl73_bam_abil))
#define BCMI_TSC_XGXS_WRITE_CL73_BAM_ABILr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CL73_BAM_ABILr,(_r._cl73_bam_abil))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL73_BAM_ABILr BCMI_TSC_XGXS_CL73_BAM_ABILr
#define CL73_BAM_ABILr_SIZE BCMI_TSC_XGXS_CL73_BAM_ABILr_SIZE
typedef BCMI_TSC_XGXS_CL73_BAM_ABILr_t CL73_BAM_ABILr_t;
#define CL73_BAM_ABILr_CLR BCMI_TSC_XGXS_CL73_BAM_ABILr_CLR
#define CL73_BAM_ABILr_SET BCMI_TSC_XGXS_CL73_BAM_ABILr_SET
#define CL73_BAM_ABILr_GET BCMI_TSC_XGXS_CL73_BAM_ABILr_GET
#define CL73_BAM_ABILr_RESERVED0f_GET BCMI_TSC_XGXS_CL73_BAM_ABILr_RESERVED0f_GET
#define CL73_BAM_ABILr_RESERVED0f_SET BCMI_TSC_XGXS_CL73_BAM_ABILr_RESERVED0f_SET
#define CL73_BAM_ABILr_HPAM_20GKR2f_GET BCMI_TSC_XGXS_CL73_BAM_ABILr_HPAM_20GKR2f_GET
#define CL73_BAM_ABILr_HPAM_20GKR2f_SET BCMI_TSC_XGXS_CL73_BAM_ABILr_HPAM_20GKR2f_SET
#define CL73_BAM_ABILr_CL73_BAM_CODEf_GET BCMI_TSC_XGXS_CL73_BAM_ABILr_CL73_BAM_CODEf_GET
#define CL73_BAM_ABILr_CL73_BAM_CODEf_SET BCMI_TSC_XGXS_CL73_BAM_ABILr_CL73_BAM_CODEf_SET
#define CL73_BAM_ABILr_BAM_20GBASE_CR2f_GET BCMI_TSC_XGXS_CL73_BAM_ABILr_BAM_20GBASE_CR2f_GET
#define CL73_BAM_ABILr_BAM_20GBASE_CR2f_SET BCMI_TSC_XGXS_CL73_BAM_ABILr_BAM_20GBASE_CR2f_SET
#define CL73_BAM_ABILr_BAM_20GBASE_KR2f_GET BCMI_TSC_XGXS_CL73_BAM_ABILr_BAM_20GBASE_KR2f_GET
#define CL73_BAM_ABILr_BAM_20GBASE_KR2f_SET BCMI_TSC_XGXS_CL73_BAM_ABILr_BAM_20GBASE_KR2f_SET
#define READ_CL73_BAM_ABILr BCMI_TSC_XGXS_READ_CL73_BAM_ABILr
#define WRITE_CL73_BAM_ABILr BCMI_TSC_XGXS_WRITE_CL73_BAM_ABILr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CL73_BAM_ABILr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CONTROLS
 * BLOCKS:   AN_X4_ABILITIES
 * REGADDR:  0xc188
 * DESC:     AN MISC CONTROLS: 00000000
 * SIZE:     32
 * FIELDS:
 *     PD_KX4_EN        
 *     PD_KX_EN         
 *     AN_GOOD_TRAP     
 *     AN_GOOD_CHECK_TRAP 
 *     LINKFAILTIMER_DIS 
 *     LINKFAILTIMERQUAL_EN 
 *     AN_FAIL_COUNT_LIMIT 
 *     OUI_CONTROL      
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CONTROLSr (0x0000c188 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CONTROLSr_SIZE 4

/*
 * This structure should be used to declare and program CONTROLS.
 *
 */
typedef union BCMI_TSC_XGXS_CONTROLSr_s {
	uint32_t v[1];
	uint32_t controls[1];
	uint32_t _controls;
} BCMI_TSC_XGXS_CONTROLSr_t;

#define BCMI_TSC_XGXS_CONTROLSr_CLR(r) (r).controls[0] = 0
#define BCMI_TSC_XGXS_CONTROLSr_SET(r,d) (r).controls[0] = d
#define BCMI_TSC_XGXS_CONTROLSr_GET(r) (r).controls[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CONTROLSr_OUI_CONTROLf_GET(r) ((((r).controls[0]) >> 10) & 0x3f)
#define BCMI_TSC_XGXS_CONTROLSr_OUI_CONTROLf_SET(r,f) (r).controls[0]=(((r).controls[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))
#define BCMI_TSC_XGXS_CONTROLSr_AN_FAIL_COUNT_LIMITf_GET(r) ((((r).controls[0]) >> 6) & 0xf)
#define BCMI_TSC_XGXS_CONTROLSr_AN_FAIL_COUNT_LIMITf_SET(r,f) (r).controls[0]=(((r).controls[0] & ~((uint32_t)0xf << 6)) | ((((uint32_t)f) & 0xf) << 6))
#define BCMI_TSC_XGXS_CONTROLSr_LINKFAILTIMERQUAL_ENf_GET(r) ((((r).controls[0]) >> 5) & 0x1)
#define BCMI_TSC_XGXS_CONTROLSr_LINKFAILTIMERQUAL_ENf_SET(r,f) (r).controls[0]=(((r).controls[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCMI_TSC_XGXS_CONTROLSr_LINKFAILTIMER_DISf_GET(r) ((((r).controls[0]) >> 4) & 0x1)
#define BCMI_TSC_XGXS_CONTROLSr_LINKFAILTIMER_DISf_SET(r,f) (r).controls[0]=(((r).controls[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCMI_TSC_XGXS_CONTROLSr_AN_GOOD_CHECK_TRAPf_GET(r) ((((r).controls[0]) >> 3) & 0x1)
#define BCMI_TSC_XGXS_CONTROLSr_AN_GOOD_CHECK_TRAPf_SET(r,f) (r).controls[0]=(((r).controls[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCMI_TSC_XGXS_CONTROLSr_AN_GOOD_TRAPf_GET(r) ((((r).controls[0]) >> 2) & 0x1)
#define BCMI_TSC_XGXS_CONTROLSr_AN_GOOD_TRAPf_SET(r,f) (r).controls[0]=(((r).controls[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCMI_TSC_XGXS_CONTROLSr_PD_KX_ENf_GET(r) ((((r).controls[0]) >> 1) & 0x1)
#define BCMI_TSC_XGXS_CONTROLSr_PD_KX_ENf_SET(r,f) (r).controls[0]=(((r).controls[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCMI_TSC_XGXS_CONTROLSr_PD_KX4_ENf_GET(r) (((r).controls[0]) & 0x1)
#define BCMI_TSC_XGXS_CONTROLSr_PD_KX4_ENf_SET(r,f) (r).controls[0]=(((r).controls[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access CONTROLS.
 *
 */
#define BCMI_TSC_XGXS_READ_CONTROLSr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CONTROLSr,(_r._controls))
#define BCMI_TSC_XGXS_WRITE_CONTROLSr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CONTROLSr,(_r._controls))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CONTROLSr BCMI_TSC_XGXS_CONTROLSr
#define CONTROLSr_SIZE BCMI_TSC_XGXS_CONTROLSr_SIZE
typedef BCMI_TSC_XGXS_CONTROLSr_t CONTROLSr_t;
#define CONTROLSr_CLR BCMI_TSC_XGXS_CONTROLSr_CLR
#define CONTROLSr_SET BCMI_TSC_XGXS_CONTROLSr_SET
#define CONTROLSr_GET BCMI_TSC_XGXS_CONTROLSr_GET
#define CONTROLSr_OUI_CONTROLf_GET BCMI_TSC_XGXS_CONTROLSr_OUI_CONTROLf_GET
#define CONTROLSr_OUI_CONTROLf_SET BCMI_TSC_XGXS_CONTROLSr_OUI_CONTROLf_SET
#define CONTROLSr_AN_FAIL_COUNT_LIMITf_GET BCMI_TSC_XGXS_CONTROLSr_AN_FAIL_COUNT_LIMITf_GET
#define CONTROLSr_AN_FAIL_COUNT_LIMITf_SET BCMI_TSC_XGXS_CONTROLSr_AN_FAIL_COUNT_LIMITf_SET
#define CONTROLSr_LINKFAILTIMERQUAL_ENf_GET BCMI_TSC_XGXS_CONTROLSr_LINKFAILTIMERQUAL_ENf_GET
#define CONTROLSr_LINKFAILTIMERQUAL_ENf_SET BCMI_TSC_XGXS_CONTROLSr_LINKFAILTIMERQUAL_ENf_SET
#define CONTROLSr_LINKFAILTIMER_DISf_GET BCMI_TSC_XGXS_CONTROLSr_LINKFAILTIMER_DISf_GET
#define CONTROLSr_LINKFAILTIMER_DISf_SET BCMI_TSC_XGXS_CONTROLSr_LINKFAILTIMER_DISf_SET
#define CONTROLSr_AN_GOOD_CHECK_TRAPf_GET BCMI_TSC_XGXS_CONTROLSr_AN_GOOD_CHECK_TRAPf_GET
#define CONTROLSr_AN_GOOD_CHECK_TRAPf_SET BCMI_TSC_XGXS_CONTROLSr_AN_GOOD_CHECK_TRAPf_SET
#define CONTROLSr_AN_GOOD_TRAPf_GET BCMI_TSC_XGXS_CONTROLSr_AN_GOOD_TRAPf_GET
#define CONTROLSr_AN_GOOD_TRAPf_SET BCMI_TSC_XGXS_CONTROLSr_AN_GOOD_TRAPf_SET
#define CONTROLSr_PD_KX_ENf_GET BCMI_TSC_XGXS_CONTROLSr_PD_KX_ENf_GET
#define CONTROLSr_PD_KX_ENf_SET BCMI_TSC_XGXS_CONTROLSr_PD_KX_ENf_SET
#define CONTROLSr_PD_KX4_ENf_GET BCMI_TSC_XGXS_CONTROLSr_PD_KX4_ENf_GET
#define CONTROLSr_PD_KX4_ENf_SET BCMI_TSC_XGXS_CONTROLSr_PD_KX4_ENf_SET
#define READ_CONTROLSr BCMI_TSC_XGXS_READ_CONTROLSr
#define WRITE_CONTROLSr BCMI_TSC_XGXS_WRITE_CONTROLSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CONTROLSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  LP_MP5_UP1
 * BLOCKS:   AN_X4_HW_LP_PAGES
 * REGADDR:  0xc190
 * DESC:     LINK PARTNER MESSAGE_PAGE 5 USER PAGE 1: 00000000
 * SIZE:     32
 * FIELDS:
 *     LP_MP5_UP1_PAGE_DATA 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_LP_MP5_UP1r (0x0000c190 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_LP_MP5_UP1r_SIZE 4

/*
 * This structure should be used to declare and program LP_MP5_UP1.
 *
 */
typedef union BCMI_TSC_XGXS_LP_MP5_UP1r_s {
	uint32_t v[1];
	uint32_t lp_mp5_up1[1];
	uint32_t _lp_mp5_up1;
} BCMI_TSC_XGXS_LP_MP5_UP1r_t;

#define BCMI_TSC_XGXS_LP_MP5_UP1r_CLR(r) (r).lp_mp5_up1[0] = 0
#define BCMI_TSC_XGXS_LP_MP5_UP1r_SET(r,d) (r).lp_mp5_up1[0] = d
#define BCMI_TSC_XGXS_LP_MP5_UP1r_GET(r) (r).lp_mp5_up1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_LP_MP5_UP1r_LP_MP5_UP1_PAGE_DATAf_GET(r) (((r).lp_mp5_up1[0]) & 0xffff)
#define BCMI_TSC_XGXS_LP_MP5_UP1r_LP_MP5_UP1_PAGE_DATAf_SET(r,f) (r).lp_mp5_up1[0]=(((r).lp_mp5_up1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access LP_MP5_UP1.
 *
 */
#define BCMI_TSC_XGXS_READ_LP_MP5_UP1r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_LP_MP5_UP1r,(_r._lp_mp5_up1))
#define BCMI_TSC_XGXS_WRITE_LP_MP5_UP1r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_LP_MP5_UP1r,(_r._lp_mp5_up1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define LP_MP5_UP1r BCMI_TSC_XGXS_LP_MP5_UP1r
#define LP_MP5_UP1r_SIZE BCMI_TSC_XGXS_LP_MP5_UP1r_SIZE
typedef BCMI_TSC_XGXS_LP_MP5_UP1r_t LP_MP5_UP1r_t;
#define LP_MP5_UP1r_CLR BCMI_TSC_XGXS_LP_MP5_UP1r_CLR
#define LP_MP5_UP1r_SET BCMI_TSC_XGXS_LP_MP5_UP1r_SET
#define LP_MP5_UP1r_GET BCMI_TSC_XGXS_LP_MP5_UP1r_GET
#define LP_MP5_UP1r_LP_MP5_UP1_PAGE_DATAf_GET BCMI_TSC_XGXS_LP_MP5_UP1r_LP_MP5_UP1_PAGE_DATAf_GET
#define LP_MP5_UP1r_LP_MP5_UP1_PAGE_DATAf_SET BCMI_TSC_XGXS_LP_MP5_UP1r_LP_MP5_UP1_PAGE_DATAf_SET
#define READ_LP_MP5_UP1r BCMI_TSC_XGXS_READ_LP_MP5_UP1r
#define WRITE_LP_MP5_UP1r BCMI_TSC_XGXS_WRITE_LP_MP5_UP1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_LP_MP5_UP1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  LP_MP5_UP2
 * BLOCKS:   AN_X4_HW_LP_PAGES
 * REGADDR:  0xc191
 * DESC:     LINK PARTNER MESSAGE_PAGE 5 USER PAGE 2: 00000000
 * SIZE:     32
 * FIELDS:
 *     LP_MP5_UP2_PAGE_DATA 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_LP_MP5_UP2r (0x0000c191 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_LP_MP5_UP2r_SIZE 4

/*
 * This structure should be used to declare and program LP_MP5_UP2.
 *
 */
typedef union BCMI_TSC_XGXS_LP_MP5_UP2r_s {
	uint32_t v[1];
	uint32_t lp_mp5_up2[1];
	uint32_t _lp_mp5_up2;
} BCMI_TSC_XGXS_LP_MP5_UP2r_t;

#define BCMI_TSC_XGXS_LP_MP5_UP2r_CLR(r) (r).lp_mp5_up2[0] = 0
#define BCMI_TSC_XGXS_LP_MP5_UP2r_SET(r,d) (r).lp_mp5_up2[0] = d
#define BCMI_TSC_XGXS_LP_MP5_UP2r_GET(r) (r).lp_mp5_up2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_LP_MP5_UP2r_LP_MP5_UP2_PAGE_DATAf_GET(r) (((r).lp_mp5_up2[0]) & 0xffff)
#define BCMI_TSC_XGXS_LP_MP5_UP2r_LP_MP5_UP2_PAGE_DATAf_SET(r,f) (r).lp_mp5_up2[0]=(((r).lp_mp5_up2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access LP_MP5_UP2.
 *
 */
#define BCMI_TSC_XGXS_READ_LP_MP5_UP2r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_LP_MP5_UP2r,(_r._lp_mp5_up2))
#define BCMI_TSC_XGXS_WRITE_LP_MP5_UP2r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_LP_MP5_UP2r,(_r._lp_mp5_up2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define LP_MP5_UP2r BCMI_TSC_XGXS_LP_MP5_UP2r
#define LP_MP5_UP2r_SIZE BCMI_TSC_XGXS_LP_MP5_UP2r_SIZE
typedef BCMI_TSC_XGXS_LP_MP5_UP2r_t LP_MP5_UP2r_t;
#define LP_MP5_UP2r_CLR BCMI_TSC_XGXS_LP_MP5_UP2r_CLR
#define LP_MP5_UP2r_SET BCMI_TSC_XGXS_LP_MP5_UP2r_SET
#define LP_MP5_UP2r_GET BCMI_TSC_XGXS_LP_MP5_UP2r_GET
#define LP_MP5_UP2r_LP_MP5_UP2_PAGE_DATAf_GET BCMI_TSC_XGXS_LP_MP5_UP2r_LP_MP5_UP2_PAGE_DATAf_GET
#define LP_MP5_UP2r_LP_MP5_UP2_PAGE_DATAf_SET BCMI_TSC_XGXS_LP_MP5_UP2r_LP_MP5_UP2_PAGE_DATAf_SET
#define READ_LP_MP5_UP2r BCMI_TSC_XGXS_READ_LP_MP5_UP2r
#define WRITE_LP_MP5_UP2r BCMI_TSC_XGXS_WRITE_LP_MP5_UP2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_LP_MP5_UP2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  LP_MP5_UP3
 * BLOCKS:   AN_X4_HW_LP_PAGES
 * REGADDR:  0xc192
 * DESC:     LINK PARTNER MESSAGE_PAGE 5 USER PAGE 3: 00000000
 * SIZE:     32
 * FIELDS:
 *     LP_MP5_UP3_PAGE_DATA 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_LP_MP5_UP3r (0x0000c192 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_LP_MP5_UP3r_SIZE 4

/*
 * This structure should be used to declare and program LP_MP5_UP3.
 *
 */
typedef union BCMI_TSC_XGXS_LP_MP5_UP3r_s {
	uint32_t v[1];
	uint32_t lp_mp5_up3[1];
	uint32_t _lp_mp5_up3;
} BCMI_TSC_XGXS_LP_MP5_UP3r_t;

#define BCMI_TSC_XGXS_LP_MP5_UP3r_CLR(r) (r).lp_mp5_up3[0] = 0
#define BCMI_TSC_XGXS_LP_MP5_UP3r_SET(r,d) (r).lp_mp5_up3[0] = d
#define BCMI_TSC_XGXS_LP_MP5_UP3r_GET(r) (r).lp_mp5_up3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_LP_MP5_UP3r_LP_MP5_UP3_PAGE_DATAf_GET(r) (((r).lp_mp5_up3[0]) & 0xffff)
#define BCMI_TSC_XGXS_LP_MP5_UP3r_LP_MP5_UP3_PAGE_DATAf_SET(r,f) (r).lp_mp5_up3[0]=(((r).lp_mp5_up3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access LP_MP5_UP3.
 *
 */
#define BCMI_TSC_XGXS_READ_LP_MP5_UP3r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_LP_MP5_UP3r,(_r._lp_mp5_up3))
#define BCMI_TSC_XGXS_WRITE_LP_MP5_UP3r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_LP_MP5_UP3r,(_r._lp_mp5_up3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define LP_MP5_UP3r BCMI_TSC_XGXS_LP_MP5_UP3r
#define LP_MP5_UP3r_SIZE BCMI_TSC_XGXS_LP_MP5_UP3r_SIZE
typedef BCMI_TSC_XGXS_LP_MP5_UP3r_t LP_MP5_UP3r_t;
#define LP_MP5_UP3r_CLR BCMI_TSC_XGXS_LP_MP5_UP3r_CLR
#define LP_MP5_UP3r_SET BCMI_TSC_XGXS_LP_MP5_UP3r_SET
#define LP_MP5_UP3r_GET BCMI_TSC_XGXS_LP_MP5_UP3r_GET
#define LP_MP5_UP3r_LP_MP5_UP3_PAGE_DATAf_GET BCMI_TSC_XGXS_LP_MP5_UP3r_LP_MP5_UP3_PAGE_DATAf_GET
#define LP_MP5_UP3r_LP_MP5_UP3_PAGE_DATAf_SET BCMI_TSC_XGXS_LP_MP5_UP3r_LP_MP5_UP3_PAGE_DATAf_SET
#define READ_LP_MP5_UP3r BCMI_TSC_XGXS_READ_LP_MP5_UP3r
#define WRITE_LP_MP5_UP3r BCMI_TSC_XGXS_WRITE_LP_MP5_UP3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_LP_MP5_UP3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  LP_MP5_UP4
 * BLOCKS:   AN_X4_HW_LP_PAGES
 * REGADDR:  0xc193
 * DESC:     LINK PARTNER MESSAGE_PAGE 5 USER PAGE 4: 00000000
 * SIZE:     32
 * FIELDS:
 *     LP_MP5_UP4_PAGE_DATA 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_LP_MP5_UP4r (0x0000c193 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_LP_MP5_UP4r_SIZE 4

/*
 * This structure should be used to declare and program LP_MP5_UP4.
 *
 */
typedef union BCMI_TSC_XGXS_LP_MP5_UP4r_s {
	uint32_t v[1];
	uint32_t lp_mp5_up4[1];
	uint32_t _lp_mp5_up4;
} BCMI_TSC_XGXS_LP_MP5_UP4r_t;

#define BCMI_TSC_XGXS_LP_MP5_UP4r_CLR(r) (r).lp_mp5_up4[0] = 0
#define BCMI_TSC_XGXS_LP_MP5_UP4r_SET(r,d) (r).lp_mp5_up4[0] = d
#define BCMI_TSC_XGXS_LP_MP5_UP4r_GET(r) (r).lp_mp5_up4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_LP_MP5_UP4r_LP_MP5_UP4_PAGE_DATAf_GET(r) (((r).lp_mp5_up4[0]) & 0xffff)
#define BCMI_TSC_XGXS_LP_MP5_UP4r_LP_MP5_UP4_PAGE_DATAf_SET(r,f) (r).lp_mp5_up4[0]=(((r).lp_mp5_up4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access LP_MP5_UP4.
 *
 */
#define BCMI_TSC_XGXS_READ_LP_MP5_UP4r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_LP_MP5_UP4r,(_r._lp_mp5_up4))
#define BCMI_TSC_XGXS_WRITE_LP_MP5_UP4r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_LP_MP5_UP4r,(_r._lp_mp5_up4))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define LP_MP5_UP4r BCMI_TSC_XGXS_LP_MP5_UP4r
#define LP_MP5_UP4r_SIZE BCMI_TSC_XGXS_LP_MP5_UP4r_SIZE
typedef BCMI_TSC_XGXS_LP_MP5_UP4r_t LP_MP5_UP4r_t;
#define LP_MP5_UP4r_CLR BCMI_TSC_XGXS_LP_MP5_UP4r_CLR
#define LP_MP5_UP4r_SET BCMI_TSC_XGXS_LP_MP5_UP4r_SET
#define LP_MP5_UP4r_GET BCMI_TSC_XGXS_LP_MP5_UP4r_GET
#define LP_MP5_UP4r_LP_MP5_UP4_PAGE_DATAf_GET BCMI_TSC_XGXS_LP_MP5_UP4r_LP_MP5_UP4_PAGE_DATAf_GET
#define LP_MP5_UP4r_LP_MP5_UP4_PAGE_DATAf_SET BCMI_TSC_XGXS_LP_MP5_UP4r_LP_MP5_UP4_PAGE_DATAf_SET
#define READ_LP_MP5_UP4r BCMI_TSC_XGXS_READ_LP_MP5_UP4r
#define WRITE_LP_MP5_UP4r BCMI_TSC_XGXS_WRITE_LP_MP5_UP4r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_LP_MP5_UP4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  LP_MP1024_UP1
 * BLOCKS:   AN_X4_HW_LP_PAGES
 * REGADDR:  0xc194
 * DESC:     LINK PARTNER MESSAGE_PAGE 1024 USER PAGE 1: 00000000
 * SIZE:     32
 * FIELDS:
 *     LP_MP1024_UP1_PAGE_DATA 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_LP_MP1024_UP1r (0x0000c194 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_LP_MP1024_UP1r_SIZE 4

/*
 * This structure should be used to declare and program LP_MP1024_UP1.
 *
 */
typedef union BCMI_TSC_XGXS_LP_MP1024_UP1r_s {
	uint32_t v[1];
	uint32_t lp_mp1024_up1[1];
	uint32_t _lp_mp1024_up1;
} BCMI_TSC_XGXS_LP_MP1024_UP1r_t;

#define BCMI_TSC_XGXS_LP_MP1024_UP1r_CLR(r) (r).lp_mp1024_up1[0] = 0
#define BCMI_TSC_XGXS_LP_MP1024_UP1r_SET(r,d) (r).lp_mp1024_up1[0] = d
#define BCMI_TSC_XGXS_LP_MP1024_UP1r_GET(r) (r).lp_mp1024_up1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_LP_MP1024_UP1r_LP_MP1024_UP1_PAGE_DATAf_GET(r) (((r).lp_mp1024_up1[0]) & 0xffff)
#define BCMI_TSC_XGXS_LP_MP1024_UP1r_LP_MP1024_UP1_PAGE_DATAf_SET(r,f) (r).lp_mp1024_up1[0]=(((r).lp_mp1024_up1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access LP_MP1024_UP1.
 *
 */
#define BCMI_TSC_XGXS_READ_LP_MP1024_UP1r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_LP_MP1024_UP1r,(_r._lp_mp1024_up1))
#define BCMI_TSC_XGXS_WRITE_LP_MP1024_UP1r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_LP_MP1024_UP1r,(_r._lp_mp1024_up1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define LP_MP1024_UP1r BCMI_TSC_XGXS_LP_MP1024_UP1r
#define LP_MP1024_UP1r_SIZE BCMI_TSC_XGXS_LP_MP1024_UP1r_SIZE
typedef BCMI_TSC_XGXS_LP_MP1024_UP1r_t LP_MP1024_UP1r_t;
#define LP_MP1024_UP1r_CLR BCMI_TSC_XGXS_LP_MP1024_UP1r_CLR
#define LP_MP1024_UP1r_SET BCMI_TSC_XGXS_LP_MP1024_UP1r_SET
#define LP_MP1024_UP1r_GET BCMI_TSC_XGXS_LP_MP1024_UP1r_GET
#define LP_MP1024_UP1r_LP_MP1024_UP1_PAGE_DATAf_GET BCMI_TSC_XGXS_LP_MP1024_UP1r_LP_MP1024_UP1_PAGE_DATAf_GET
#define LP_MP1024_UP1r_LP_MP1024_UP1_PAGE_DATAf_SET BCMI_TSC_XGXS_LP_MP1024_UP1r_LP_MP1024_UP1_PAGE_DATAf_SET
#define READ_LP_MP1024_UP1r BCMI_TSC_XGXS_READ_LP_MP1024_UP1r
#define WRITE_LP_MP1024_UP1r BCMI_TSC_XGXS_WRITE_LP_MP1024_UP1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_LP_MP1024_UP1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  LP_MP1024_UP2
 * BLOCKS:   AN_X4_HW_LP_PAGES
 * REGADDR:  0xc195
 * DESC:     LINK PARTNER MESSAGE_PAGE 1024 USER PAGE 2: 00000000
 * SIZE:     32
 * FIELDS:
 *     LP_MP1024_UP2_PAGE_DATA 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_LP_MP1024_UP2r (0x0000c195 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_LP_MP1024_UP2r_SIZE 4

/*
 * This structure should be used to declare and program LP_MP1024_UP2.
 *
 */
typedef union BCMI_TSC_XGXS_LP_MP1024_UP2r_s {
	uint32_t v[1];
	uint32_t lp_mp1024_up2[1];
	uint32_t _lp_mp1024_up2;
} BCMI_TSC_XGXS_LP_MP1024_UP2r_t;

#define BCMI_TSC_XGXS_LP_MP1024_UP2r_CLR(r) (r).lp_mp1024_up2[0] = 0
#define BCMI_TSC_XGXS_LP_MP1024_UP2r_SET(r,d) (r).lp_mp1024_up2[0] = d
#define BCMI_TSC_XGXS_LP_MP1024_UP2r_GET(r) (r).lp_mp1024_up2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_LP_MP1024_UP2r_LP_MP1024_UP2_PAGE_DATAf_GET(r) (((r).lp_mp1024_up2[0]) & 0xffff)
#define BCMI_TSC_XGXS_LP_MP1024_UP2r_LP_MP1024_UP2_PAGE_DATAf_SET(r,f) (r).lp_mp1024_up2[0]=(((r).lp_mp1024_up2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access LP_MP1024_UP2.
 *
 */
#define BCMI_TSC_XGXS_READ_LP_MP1024_UP2r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_LP_MP1024_UP2r,(_r._lp_mp1024_up2))
#define BCMI_TSC_XGXS_WRITE_LP_MP1024_UP2r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_LP_MP1024_UP2r,(_r._lp_mp1024_up2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define LP_MP1024_UP2r BCMI_TSC_XGXS_LP_MP1024_UP2r
#define LP_MP1024_UP2r_SIZE BCMI_TSC_XGXS_LP_MP1024_UP2r_SIZE
typedef BCMI_TSC_XGXS_LP_MP1024_UP2r_t LP_MP1024_UP2r_t;
#define LP_MP1024_UP2r_CLR BCMI_TSC_XGXS_LP_MP1024_UP2r_CLR
#define LP_MP1024_UP2r_SET BCMI_TSC_XGXS_LP_MP1024_UP2r_SET
#define LP_MP1024_UP2r_GET BCMI_TSC_XGXS_LP_MP1024_UP2r_GET
#define LP_MP1024_UP2r_LP_MP1024_UP2_PAGE_DATAf_GET BCMI_TSC_XGXS_LP_MP1024_UP2r_LP_MP1024_UP2_PAGE_DATAf_GET
#define LP_MP1024_UP2r_LP_MP1024_UP2_PAGE_DATAf_SET BCMI_TSC_XGXS_LP_MP1024_UP2r_LP_MP1024_UP2_PAGE_DATAf_SET
#define READ_LP_MP1024_UP2r BCMI_TSC_XGXS_READ_LP_MP1024_UP2r
#define WRITE_LP_MP1024_UP2r BCMI_TSC_XGXS_WRITE_LP_MP1024_UP2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_LP_MP1024_UP2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  LP_MP1024_UP3
 * BLOCKS:   AN_X4_HW_LP_PAGES
 * REGADDR:  0xc196
 * DESC:     LINK PARTNER MESSAGE_PAGE 1024 USER PAGE 3: 00000000
 * SIZE:     32
 * FIELDS:
 *     LP_MP1024_UP3_PAGE_DATA 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_LP_MP1024_UP3r (0x0000c196 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_LP_MP1024_UP3r_SIZE 4

/*
 * This structure should be used to declare and program LP_MP1024_UP3.
 *
 */
typedef union BCMI_TSC_XGXS_LP_MP1024_UP3r_s {
	uint32_t v[1];
	uint32_t lp_mp1024_up3[1];
	uint32_t _lp_mp1024_up3;
} BCMI_TSC_XGXS_LP_MP1024_UP3r_t;

#define BCMI_TSC_XGXS_LP_MP1024_UP3r_CLR(r) (r).lp_mp1024_up3[0] = 0
#define BCMI_TSC_XGXS_LP_MP1024_UP3r_SET(r,d) (r).lp_mp1024_up3[0] = d
#define BCMI_TSC_XGXS_LP_MP1024_UP3r_GET(r) (r).lp_mp1024_up3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_LP_MP1024_UP3r_LP_MP1024_UP3_PAGE_DATAf_GET(r) (((r).lp_mp1024_up3[0]) & 0xffff)
#define BCMI_TSC_XGXS_LP_MP1024_UP3r_LP_MP1024_UP3_PAGE_DATAf_SET(r,f) (r).lp_mp1024_up3[0]=(((r).lp_mp1024_up3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access LP_MP1024_UP3.
 *
 */
#define BCMI_TSC_XGXS_READ_LP_MP1024_UP3r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_LP_MP1024_UP3r,(_r._lp_mp1024_up3))
#define BCMI_TSC_XGXS_WRITE_LP_MP1024_UP3r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_LP_MP1024_UP3r,(_r._lp_mp1024_up3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define LP_MP1024_UP3r BCMI_TSC_XGXS_LP_MP1024_UP3r
#define LP_MP1024_UP3r_SIZE BCMI_TSC_XGXS_LP_MP1024_UP3r_SIZE
typedef BCMI_TSC_XGXS_LP_MP1024_UP3r_t LP_MP1024_UP3r_t;
#define LP_MP1024_UP3r_CLR BCMI_TSC_XGXS_LP_MP1024_UP3r_CLR
#define LP_MP1024_UP3r_SET BCMI_TSC_XGXS_LP_MP1024_UP3r_SET
#define LP_MP1024_UP3r_GET BCMI_TSC_XGXS_LP_MP1024_UP3r_GET
#define LP_MP1024_UP3r_LP_MP1024_UP3_PAGE_DATAf_GET BCMI_TSC_XGXS_LP_MP1024_UP3r_LP_MP1024_UP3_PAGE_DATAf_GET
#define LP_MP1024_UP3r_LP_MP1024_UP3_PAGE_DATAf_SET BCMI_TSC_XGXS_LP_MP1024_UP3r_LP_MP1024_UP3_PAGE_DATAf_SET
#define READ_LP_MP1024_UP3r BCMI_TSC_XGXS_READ_LP_MP1024_UP3r
#define WRITE_LP_MP1024_UP3r BCMI_TSC_XGXS_WRITE_LP_MP1024_UP3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_LP_MP1024_UP3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  LP_MP1024_UP4
 * BLOCKS:   AN_X4_HW_LP_PAGES
 * REGADDR:  0xc197
 * DESC:     LINK PARTNER MESSAGE_PAGE 1024 USER PAGE 4: 00000000
 * SIZE:     32
 * FIELDS:
 *     LP_MP1024_UP4_PAGE_DATA 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_LP_MP1024_UP4r (0x0000c197 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_LP_MP1024_UP4r_SIZE 4

/*
 * This structure should be used to declare and program LP_MP1024_UP4.
 *
 */
typedef union BCMI_TSC_XGXS_LP_MP1024_UP4r_s {
	uint32_t v[1];
	uint32_t lp_mp1024_up4[1];
	uint32_t _lp_mp1024_up4;
} BCMI_TSC_XGXS_LP_MP1024_UP4r_t;

#define BCMI_TSC_XGXS_LP_MP1024_UP4r_CLR(r) (r).lp_mp1024_up4[0] = 0
#define BCMI_TSC_XGXS_LP_MP1024_UP4r_SET(r,d) (r).lp_mp1024_up4[0] = d
#define BCMI_TSC_XGXS_LP_MP1024_UP4r_GET(r) (r).lp_mp1024_up4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_LP_MP1024_UP4r_LP_MP1024_UP4_PAGE_DATAf_GET(r) (((r).lp_mp1024_up4[0]) & 0xffff)
#define BCMI_TSC_XGXS_LP_MP1024_UP4r_LP_MP1024_UP4_PAGE_DATAf_SET(r,f) (r).lp_mp1024_up4[0]=(((r).lp_mp1024_up4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access LP_MP1024_UP4.
 *
 */
#define BCMI_TSC_XGXS_READ_LP_MP1024_UP4r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_LP_MP1024_UP4r,(_r._lp_mp1024_up4))
#define BCMI_TSC_XGXS_WRITE_LP_MP1024_UP4r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_LP_MP1024_UP4r,(_r._lp_mp1024_up4))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define LP_MP1024_UP4r BCMI_TSC_XGXS_LP_MP1024_UP4r
#define LP_MP1024_UP4r_SIZE BCMI_TSC_XGXS_LP_MP1024_UP4r_SIZE
typedef BCMI_TSC_XGXS_LP_MP1024_UP4r_t LP_MP1024_UP4r_t;
#define LP_MP1024_UP4r_CLR BCMI_TSC_XGXS_LP_MP1024_UP4r_CLR
#define LP_MP1024_UP4r_SET BCMI_TSC_XGXS_LP_MP1024_UP4r_SET
#define LP_MP1024_UP4r_GET BCMI_TSC_XGXS_LP_MP1024_UP4r_GET
#define LP_MP1024_UP4r_LP_MP1024_UP4_PAGE_DATAf_GET BCMI_TSC_XGXS_LP_MP1024_UP4r_LP_MP1024_UP4_PAGE_DATAf_GET
#define LP_MP1024_UP4r_LP_MP1024_UP4_PAGE_DATAf_SET BCMI_TSC_XGXS_LP_MP1024_UP4r_LP_MP1024_UP4_PAGE_DATAf_SET
#define READ_LP_MP1024_UP4r BCMI_TSC_XGXS_READ_LP_MP1024_UP4r
#define WRITE_LP_MP1024_UP4r BCMI_TSC_XGXS_WRITE_LP_MP1024_UP4r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_LP_MP1024_UP4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  LP_BASE_PAGE1
 * BLOCKS:   AN_X4_HW_LP_PAGES
 * REGADDR:  0xc198
 * DESC:     LINK PARTNER BASE PAGE 1: 00000000
 * SIZE:     32
 * FIELDS:
 *     LP_BASE_PAGE1_PAGE_DATA 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_LP_BASE_PAGE1r (0x0000c198 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_LP_BASE_PAGE1r_SIZE 4

/*
 * This structure should be used to declare and program LP_BASE_PAGE1.
 *
 */
typedef union BCMI_TSC_XGXS_LP_BASE_PAGE1r_s {
	uint32_t v[1];
	uint32_t lp_base_page1[1];
	uint32_t _lp_base_page1;
} BCMI_TSC_XGXS_LP_BASE_PAGE1r_t;

#define BCMI_TSC_XGXS_LP_BASE_PAGE1r_CLR(r) (r).lp_base_page1[0] = 0
#define BCMI_TSC_XGXS_LP_BASE_PAGE1r_SET(r,d) (r).lp_base_page1[0] = d
#define BCMI_TSC_XGXS_LP_BASE_PAGE1r_GET(r) (r).lp_base_page1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_LP_BASE_PAGE1r_LP_BASE_PAGE1_PAGE_DATAf_GET(r) (((r).lp_base_page1[0]) & 0xffff)
#define BCMI_TSC_XGXS_LP_BASE_PAGE1r_LP_BASE_PAGE1_PAGE_DATAf_SET(r,f) (r).lp_base_page1[0]=(((r).lp_base_page1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access LP_BASE_PAGE1.
 *
 */
#define BCMI_TSC_XGXS_READ_LP_BASE_PAGE1r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_LP_BASE_PAGE1r,(_r._lp_base_page1))
#define BCMI_TSC_XGXS_WRITE_LP_BASE_PAGE1r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_LP_BASE_PAGE1r,(_r._lp_base_page1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define LP_BASE_PAGE1r BCMI_TSC_XGXS_LP_BASE_PAGE1r
#define LP_BASE_PAGE1r_SIZE BCMI_TSC_XGXS_LP_BASE_PAGE1r_SIZE
typedef BCMI_TSC_XGXS_LP_BASE_PAGE1r_t LP_BASE_PAGE1r_t;
#define LP_BASE_PAGE1r_CLR BCMI_TSC_XGXS_LP_BASE_PAGE1r_CLR
#define LP_BASE_PAGE1r_SET BCMI_TSC_XGXS_LP_BASE_PAGE1r_SET
#define LP_BASE_PAGE1r_GET BCMI_TSC_XGXS_LP_BASE_PAGE1r_GET
#define LP_BASE_PAGE1r_LP_BASE_PAGE1_PAGE_DATAf_GET BCMI_TSC_XGXS_LP_BASE_PAGE1r_LP_BASE_PAGE1_PAGE_DATAf_GET
#define LP_BASE_PAGE1r_LP_BASE_PAGE1_PAGE_DATAf_SET BCMI_TSC_XGXS_LP_BASE_PAGE1r_LP_BASE_PAGE1_PAGE_DATAf_SET
#define READ_LP_BASE_PAGE1r BCMI_TSC_XGXS_READ_LP_BASE_PAGE1r
#define WRITE_LP_BASE_PAGE1r BCMI_TSC_XGXS_WRITE_LP_BASE_PAGE1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_LP_BASE_PAGE1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  LP_BASE_PAGE2
 * BLOCKS:   AN_X4_HW_LP_PAGES
 * REGADDR:  0xc199
 * DESC:     LINK PARTNER BASE PAGE 2: 00000000
 * SIZE:     32
 * FIELDS:
 *     LP_BASE_PAGE2_PAGE_DATA 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_LP_BASE_PAGE2r (0x0000c199 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_LP_BASE_PAGE2r_SIZE 4

/*
 * This structure should be used to declare and program LP_BASE_PAGE2.
 *
 */
typedef union BCMI_TSC_XGXS_LP_BASE_PAGE2r_s {
	uint32_t v[1];
	uint32_t lp_base_page2[1];
	uint32_t _lp_base_page2;
} BCMI_TSC_XGXS_LP_BASE_PAGE2r_t;

#define BCMI_TSC_XGXS_LP_BASE_PAGE2r_CLR(r) (r).lp_base_page2[0] = 0
#define BCMI_TSC_XGXS_LP_BASE_PAGE2r_SET(r,d) (r).lp_base_page2[0] = d
#define BCMI_TSC_XGXS_LP_BASE_PAGE2r_GET(r) (r).lp_base_page2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_LP_BASE_PAGE2r_LP_BASE_PAGE2_PAGE_DATAf_GET(r) (((r).lp_base_page2[0]) & 0xffff)
#define BCMI_TSC_XGXS_LP_BASE_PAGE2r_LP_BASE_PAGE2_PAGE_DATAf_SET(r,f) (r).lp_base_page2[0]=(((r).lp_base_page2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access LP_BASE_PAGE2.
 *
 */
#define BCMI_TSC_XGXS_READ_LP_BASE_PAGE2r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_LP_BASE_PAGE2r,(_r._lp_base_page2))
#define BCMI_TSC_XGXS_WRITE_LP_BASE_PAGE2r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_LP_BASE_PAGE2r,(_r._lp_base_page2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define LP_BASE_PAGE2r BCMI_TSC_XGXS_LP_BASE_PAGE2r
#define LP_BASE_PAGE2r_SIZE BCMI_TSC_XGXS_LP_BASE_PAGE2r_SIZE
typedef BCMI_TSC_XGXS_LP_BASE_PAGE2r_t LP_BASE_PAGE2r_t;
#define LP_BASE_PAGE2r_CLR BCMI_TSC_XGXS_LP_BASE_PAGE2r_CLR
#define LP_BASE_PAGE2r_SET BCMI_TSC_XGXS_LP_BASE_PAGE2r_SET
#define LP_BASE_PAGE2r_GET BCMI_TSC_XGXS_LP_BASE_PAGE2r_GET
#define LP_BASE_PAGE2r_LP_BASE_PAGE2_PAGE_DATAf_GET BCMI_TSC_XGXS_LP_BASE_PAGE2r_LP_BASE_PAGE2_PAGE_DATAf_GET
#define LP_BASE_PAGE2r_LP_BASE_PAGE2_PAGE_DATAf_SET BCMI_TSC_XGXS_LP_BASE_PAGE2r_LP_BASE_PAGE2_PAGE_DATAf_SET
#define READ_LP_BASE_PAGE2r BCMI_TSC_XGXS_READ_LP_BASE_PAGE2r
#define WRITE_LP_BASE_PAGE2r BCMI_TSC_XGXS_WRITE_LP_BASE_PAGE2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_LP_BASE_PAGE2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  LP_BASE_PAGE3
 * BLOCKS:   AN_X4_HW_LP_PAGES
 * REGADDR:  0xc19a
 * DESC:     LINK PARTNER BASE PAGE 3: 00000000
 * SIZE:     32
 * FIELDS:
 *     LP_BASE_PAGE3_PAGE_DATA 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_LP_BASE_PAGE3r (0x0000c19a | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_LP_BASE_PAGE3r_SIZE 4

/*
 * This structure should be used to declare and program LP_BASE_PAGE3.
 *
 */
typedef union BCMI_TSC_XGXS_LP_BASE_PAGE3r_s {
	uint32_t v[1];
	uint32_t lp_base_page3[1];
	uint32_t _lp_base_page3;
} BCMI_TSC_XGXS_LP_BASE_PAGE3r_t;

#define BCMI_TSC_XGXS_LP_BASE_PAGE3r_CLR(r) (r).lp_base_page3[0] = 0
#define BCMI_TSC_XGXS_LP_BASE_PAGE3r_SET(r,d) (r).lp_base_page3[0] = d
#define BCMI_TSC_XGXS_LP_BASE_PAGE3r_GET(r) (r).lp_base_page3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_LP_BASE_PAGE3r_LP_BASE_PAGE3_PAGE_DATAf_GET(r) (((r).lp_base_page3[0]) & 0xffff)
#define BCMI_TSC_XGXS_LP_BASE_PAGE3r_LP_BASE_PAGE3_PAGE_DATAf_SET(r,f) (r).lp_base_page3[0]=(((r).lp_base_page3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access LP_BASE_PAGE3.
 *
 */
#define BCMI_TSC_XGXS_READ_LP_BASE_PAGE3r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_LP_BASE_PAGE3r,(_r._lp_base_page3))
#define BCMI_TSC_XGXS_WRITE_LP_BASE_PAGE3r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_LP_BASE_PAGE3r,(_r._lp_base_page3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define LP_BASE_PAGE3r BCMI_TSC_XGXS_LP_BASE_PAGE3r
#define LP_BASE_PAGE3r_SIZE BCMI_TSC_XGXS_LP_BASE_PAGE3r_SIZE
typedef BCMI_TSC_XGXS_LP_BASE_PAGE3r_t LP_BASE_PAGE3r_t;
#define LP_BASE_PAGE3r_CLR BCMI_TSC_XGXS_LP_BASE_PAGE3r_CLR
#define LP_BASE_PAGE3r_SET BCMI_TSC_XGXS_LP_BASE_PAGE3r_SET
#define LP_BASE_PAGE3r_GET BCMI_TSC_XGXS_LP_BASE_PAGE3r_GET
#define LP_BASE_PAGE3r_LP_BASE_PAGE3_PAGE_DATAf_GET BCMI_TSC_XGXS_LP_BASE_PAGE3r_LP_BASE_PAGE3_PAGE_DATAf_GET
#define LP_BASE_PAGE3r_LP_BASE_PAGE3_PAGE_DATAf_SET BCMI_TSC_XGXS_LP_BASE_PAGE3r_LP_BASE_PAGE3_PAGE_DATAf_SET
#define READ_LP_BASE_PAGE3r BCMI_TSC_XGXS_READ_LP_BASE_PAGE3r
#define WRITE_LP_BASE_PAGE3r BCMI_TSC_XGXS_WRITE_LP_BASE_PAGE3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_LP_BASE_PAGE3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  LD_PAGE_2
 * BLOCKS:   AN_X4_SW_MANAGEMENT
 * REGADDR:  0xc1a0
 * DESC:     LOCAL DEVICE SW CONTROL PAGE 2: 00000000
 * SIZE:     32
 * FIELDS:
 *     LD_PAGE_2_PAGE_DATA 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_LD_PAGE_2r (0x0000c1a0 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_LD_PAGE_2r_SIZE 4

/*
 * This structure should be used to declare and program LD_PAGE_2.
 *
 */
typedef union BCMI_TSC_XGXS_LD_PAGE_2r_s {
	uint32_t v[1];
	uint32_t ld_page_2[1];
	uint32_t _ld_page_2;
} BCMI_TSC_XGXS_LD_PAGE_2r_t;

#define BCMI_TSC_XGXS_LD_PAGE_2r_CLR(r) (r).ld_page_2[0] = 0
#define BCMI_TSC_XGXS_LD_PAGE_2r_SET(r,d) (r).ld_page_2[0] = d
#define BCMI_TSC_XGXS_LD_PAGE_2r_GET(r) (r).ld_page_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_LD_PAGE_2r_LD_PAGE_2_PAGE_DATAf_GET(r) (((r).ld_page_2[0]) & 0xffff)
#define BCMI_TSC_XGXS_LD_PAGE_2r_LD_PAGE_2_PAGE_DATAf_SET(r,f) (r).ld_page_2[0]=(((r).ld_page_2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access LD_PAGE_2.
 *
 */
#define BCMI_TSC_XGXS_READ_LD_PAGE_2r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_LD_PAGE_2r,(_r._ld_page_2))
#define BCMI_TSC_XGXS_WRITE_LD_PAGE_2r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_LD_PAGE_2r,(_r._ld_page_2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define LD_PAGE_2r BCMI_TSC_XGXS_LD_PAGE_2r
#define LD_PAGE_2r_SIZE BCMI_TSC_XGXS_LD_PAGE_2r_SIZE
typedef BCMI_TSC_XGXS_LD_PAGE_2r_t LD_PAGE_2r_t;
#define LD_PAGE_2r_CLR BCMI_TSC_XGXS_LD_PAGE_2r_CLR
#define LD_PAGE_2r_SET BCMI_TSC_XGXS_LD_PAGE_2r_SET
#define LD_PAGE_2r_GET BCMI_TSC_XGXS_LD_PAGE_2r_GET
#define LD_PAGE_2r_LD_PAGE_2_PAGE_DATAf_GET BCMI_TSC_XGXS_LD_PAGE_2r_LD_PAGE_2_PAGE_DATAf_GET
#define LD_PAGE_2r_LD_PAGE_2_PAGE_DATAf_SET BCMI_TSC_XGXS_LD_PAGE_2r_LD_PAGE_2_PAGE_DATAf_SET
#define READ_LD_PAGE_2r BCMI_TSC_XGXS_READ_LD_PAGE_2r
#define WRITE_LD_PAGE_2r BCMI_TSC_XGXS_WRITE_LD_PAGE_2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_LD_PAGE_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  LD_PAGE_1
 * BLOCKS:   AN_X4_SW_MANAGEMENT
 * REGADDR:  0xc1a1
 * DESC:     LOCAL DEVICE SW CONTROL PAGE 1: 00000000
 * SIZE:     32
 * FIELDS:
 *     LD_PAGE_1_PAGE_DATA 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_LD_PAGE_1r (0x0000c1a1 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_LD_PAGE_1r_SIZE 4

/*
 * This structure should be used to declare and program LD_PAGE_1.
 *
 */
typedef union BCMI_TSC_XGXS_LD_PAGE_1r_s {
	uint32_t v[1];
	uint32_t ld_page_1[1];
	uint32_t _ld_page_1;
} BCMI_TSC_XGXS_LD_PAGE_1r_t;

#define BCMI_TSC_XGXS_LD_PAGE_1r_CLR(r) (r).ld_page_1[0] = 0
#define BCMI_TSC_XGXS_LD_PAGE_1r_SET(r,d) (r).ld_page_1[0] = d
#define BCMI_TSC_XGXS_LD_PAGE_1r_GET(r) (r).ld_page_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_LD_PAGE_1r_LD_PAGE_1_PAGE_DATAf_GET(r) (((r).ld_page_1[0]) & 0xffff)
#define BCMI_TSC_XGXS_LD_PAGE_1r_LD_PAGE_1_PAGE_DATAf_SET(r,f) (r).ld_page_1[0]=(((r).ld_page_1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access LD_PAGE_1.
 *
 */
#define BCMI_TSC_XGXS_READ_LD_PAGE_1r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_LD_PAGE_1r,(_r._ld_page_1))
#define BCMI_TSC_XGXS_WRITE_LD_PAGE_1r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_LD_PAGE_1r,(_r._ld_page_1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define LD_PAGE_1r BCMI_TSC_XGXS_LD_PAGE_1r
#define LD_PAGE_1r_SIZE BCMI_TSC_XGXS_LD_PAGE_1r_SIZE
typedef BCMI_TSC_XGXS_LD_PAGE_1r_t LD_PAGE_1r_t;
#define LD_PAGE_1r_CLR BCMI_TSC_XGXS_LD_PAGE_1r_CLR
#define LD_PAGE_1r_SET BCMI_TSC_XGXS_LD_PAGE_1r_SET
#define LD_PAGE_1r_GET BCMI_TSC_XGXS_LD_PAGE_1r_GET
#define LD_PAGE_1r_LD_PAGE_1_PAGE_DATAf_GET BCMI_TSC_XGXS_LD_PAGE_1r_LD_PAGE_1_PAGE_DATAf_GET
#define LD_PAGE_1r_LD_PAGE_1_PAGE_DATAf_SET BCMI_TSC_XGXS_LD_PAGE_1r_LD_PAGE_1_PAGE_DATAf_SET
#define READ_LD_PAGE_1r BCMI_TSC_XGXS_READ_LD_PAGE_1r
#define WRITE_LD_PAGE_1r BCMI_TSC_XGXS_WRITE_LD_PAGE_1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_LD_PAGE_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  LD_PAGE_0
 * BLOCKS:   AN_X4_SW_MANAGEMENT
 * REGADDR:  0xc1a2
 * DESC:     LOCAL DEVICE SW CONTROL PAGE 0: 00000000
 * SIZE:     32
 * FIELDS:
 *     LD_PAGE_0_PAGE_DATA 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_LD_PAGE_0r (0x0000c1a2 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_LD_PAGE_0r_SIZE 4

/*
 * This structure should be used to declare and program LD_PAGE_0.
 *
 */
typedef union BCMI_TSC_XGXS_LD_PAGE_0r_s {
	uint32_t v[1];
	uint32_t ld_page_0[1];
	uint32_t _ld_page_0;
} BCMI_TSC_XGXS_LD_PAGE_0r_t;

#define BCMI_TSC_XGXS_LD_PAGE_0r_CLR(r) (r).ld_page_0[0] = 0
#define BCMI_TSC_XGXS_LD_PAGE_0r_SET(r,d) (r).ld_page_0[0] = d
#define BCMI_TSC_XGXS_LD_PAGE_0r_GET(r) (r).ld_page_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_LD_PAGE_0r_LD_PAGE_0_PAGE_DATAf_GET(r) (((r).ld_page_0[0]) & 0xffff)
#define BCMI_TSC_XGXS_LD_PAGE_0r_LD_PAGE_0_PAGE_DATAf_SET(r,f) (r).ld_page_0[0]=(((r).ld_page_0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access LD_PAGE_0.
 *
 */
#define BCMI_TSC_XGXS_READ_LD_PAGE_0r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_LD_PAGE_0r,(_r._ld_page_0))
#define BCMI_TSC_XGXS_WRITE_LD_PAGE_0r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_LD_PAGE_0r,(_r._ld_page_0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define LD_PAGE_0r BCMI_TSC_XGXS_LD_PAGE_0r
#define LD_PAGE_0r_SIZE BCMI_TSC_XGXS_LD_PAGE_0r_SIZE
typedef BCMI_TSC_XGXS_LD_PAGE_0r_t LD_PAGE_0r_t;
#define LD_PAGE_0r_CLR BCMI_TSC_XGXS_LD_PAGE_0r_CLR
#define LD_PAGE_0r_SET BCMI_TSC_XGXS_LD_PAGE_0r_SET
#define LD_PAGE_0r_GET BCMI_TSC_XGXS_LD_PAGE_0r_GET
#define LD_PAGE_0r_LD_PAGE_0_PAGE_DATAf_GET BCMI_TSC_XGXS_LD_PAGE_0r_LD_PAGE_0_PAGE_DATAf_GET
#define LD_PAGE_0r_LD_PAGE_0_PAGE_DATAf_SET BCMI_TSC_XGXS_LD_PAGE_0r_LD_PAGE_0_PAGE_DATAf_SET
#define READ_LD_PAGE_0r BCMI_TSC_XGXS_READ_LD_PAGE_0r
#define WRITE_LD_PAGE_0r BCMI_TSC_XGXS_WRITE_LD_PAGE_0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_LD_PAGE_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  LP_PAGE_2
 * BLOCKS:   AN_X4_SW_MANAGEMENT
 * REGADDR:  0xc1a3
 * DESC:     LINK PARNTER SW CONTROL PAGE 2: 00000000
 * SIZE:     32
 * FIELDS:
 *     LP_PAGE_2_PAGE_DATA 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_LP_PAGE_2r (0x0000c1a3 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_LP_PAGE_2r_SIZE 4

/*
 * This structure should be used to declare and program LP_PAGE_2.
 *
 */
typedef union BCMI_TSC_XGXS_LP_PAGE_2r_s {
	uint32_t v[1];
	uint32_t lp_page_2[1];
	uint32_t _lp_page_2;
} BCMI_TSC_XGXS_LP_PAGE_2r_t;

#define BCMI_TSC_XGXS_LP_PAGE_2r_CLR(r) (r).lp_page_2[0] = 0
#define BCMI_TSC_XGXS_LP_PAGE_2r_SET(r,d) (r).lp_page_2[0] = d
#define BCMI_TSC_XGXS_LP_PAGE_2r_GET(r) (r).lp_page_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_LP_PAGE_2r_LP_PAGE_2_PAGE_DATAf_GET(r) (((r).lp_page_2[0]) & 0xffff)
#define BCMI_TSC_XGXS_LP_PAGE_2r_LP_PAGE_2_PAGE_DATAf_SET(r,f) (r).lp_page_2[0]=(((r).lp_page_2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access LP_PAGE_2.
 *
 */
#define BCMI_TSC_XGXS_READ_LP_PAGE_2r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_LP_PAGE_2r,(_r._lp_page_2))
#define BCMI_TSC_XGXS_WRITE_LP_PAGE_2r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_LP_PAGE_2r,(_r._lp_page_2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define LP_PAGE_2r BCMI_TSC_XGXS_LP_PAGE_2r
#define LP_PAGE_2r_SIZE BCMI_TSC_XGXS_LP_PAGE_2r_SIZE
typedef BCMI_TSC_XGXS_LP_PAGE_2r_t LP_PAGE_2r_t;
#define LP_PAGE_2r_CLR BCMI_TSC_XGXS_LP_PAGE_2r_CLR
#define LP_PAGE_2r_SET BCMI_TSC_XGXS_LP_PAGE_2r_SET
#define LP_PAGE_2r_GET BCMI_TSC_XGXS_LP_PAGE_2r_GET
#define LP_PAGE_2r_LP_PAGE_2_PAGE_DATAf_GET BCMI_TSC_XGXS_LP_PAGE_2r_LP_PAGE_2_PAGE_DATAf_GET
#define LP_PAGE_2r_LP_PAGE_2_PAGE_DATAf_SET BCMI_TSC_XGXS_LP_PAGE_2r_LP_PAGE_2_PAGE_DATAf_SET
#define READ_LP_PAGE_2r BCMI_TSC_XGXS_READ_LP_PAGE_2r
#define WRITE_LP_PAGE_2r BCMI_TSC_XGXS_WRITE_LP_PAGE_2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_LP_PAGE_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  LP_PAGE_1
 * BLOCKS:   AN_X4_SW_MANAGEMENT
 * REGADDR:  0xc1a4
 * DESC:     LINK PARNTER SW CONTROL PAGE 1: 00000000
 * SIZE:     32
 * FIELDS:
 *     LP_PAGE_1_PAGE_DATA 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_LP_PAGE_1r (0x0000c1a4 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_LP_PAGE_1r_SIZE 4

/*
 * This structure should be used to declare and program LP_PAGE_1.
 *
 */
typedef union BCMI_TSC_XGXS_LP_PAGE_1r_s {
	uint32_t v[1];
	uint32_t lp_page_1[1];
	uint32_t _lp_page_1;
} BCMI_TSC_XGXS_LP_PAGE_1r_t;

#define BCMI_TSC_XGXS_LP_PAGE_1r_CLR(r) (r).lp_page_1[0] = 0
#define BCMI_TSC_XGXS_LP_PAGE_1r_SET(r,d) (r).lp_page_1[0] = d
#define BCMI_TSC_XGXS_LP_PAGE_1r_GET(r) (r).lp_page_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_LP_PAGE_1r_LP_PAGE_1_PAGE_DATAf_GET(r) (((r).lp_page_1[0]) & 0xffff)
#define BCMI_TSC_XGXS_LP_PAGE_1r_LP_PAGE_1_PAGE_DATAf_SET(r,f) (r).lp_page_1[0]=(((r).lp_page_1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access LP_PAGE_1.
 *
 */
#define BCMI_TSC_XGXS_READ_LP_PAGE_1r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_LP_PAGE_1r,(_r._lp_page_1))
#define BCMI_TSC_XGXS_WRITE_LP_PAGE_1r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_LP_PAGE_1r,(_r._lp_page_1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define LP_PAGE_1r BCMI_TSC_XGXS_LP_PAGE_1r
#define LP_PAGE_1r_SIZE BCMI_TSC_XGXS_LP_PAGE_1r_SIZE
typedef BCMI_TSC_XGXS_LP_PAGE_1r_t LP_PAGE_1r_t;
#define LP_PAGE_1r_CLR BCMI_TSC_XGXS_LP_PAGE_1r_CLR
#define LP_PAGE_1r_SET BCMI_TSC_XGXS_LP_PAGE_1r_SET
#define LP_PAGE_1r_GET BCMI_TSC_XGXS_LP_PAGE_1r_GET
#define LP_PAGE_1r_LP_PAGE_1_PAGE_DATAf_GET BCMI_TSC_XGXS_LP_PAGE_1r_LP_PAGE_1_PAGE_DATAf_GET
#define LP_PAGE_1r_LP_PAGE_1_PAGE_DATAf_SET BCMI_TSC_XGXS_LP_PAGE_1r_LP_PAGE_1_PAGE_DATAf_SET
#define READ_LP_PAGE_1r BCMI_TSC_XGXS_READ_LP_PAGE_1r
#define WRITE_LP_PAGE_1r BCMI_TSC_XGXS_WRITE_LP_PAGE_1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_LP_PAGE_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  LP_PAGE_0
 * BLOCKS:   AN_X4_SW_MANAGEMENT
 * REGADDR:  0xc1a5
 * DESC:     LINK PARNTER SW CONTROL PAGE 0: 00000000
 * SIZE:     32
 * FIELDS:
 *     LP_PAGE_0_PAGE_DATA 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_LP_PAGE_0r (0x0000c1a5 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_LP_PAGE_0r_SIZE 4

/*
 * This structure should be used to declare and program LP_PAGE_0.
 *
 */
typedef union BCMI_TSC_XGXS_LP_PAGE_0r_s {
	uint32_t v[1];
	uint32_t lp_page_0[1];
	uint32_t _lp_page_0;
} BCMI_TSC_XGXS_LP_PAGE_0r_t;

#define BCMI_TSC_XGXS_LP_PAGE_0r_CLR(r) (r).lp_page_0[0] = 0
#define BCMI_TSC_XGXS_LP_PAGE_0r_SET(r,d) (r).lp_page_0[0] = d
#define BCMI_TSC_XGXS_LP_PAGE_0r_GET(r) (r).lp_page_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_LP_PAGE_0r_LP_PAGE_0_PAGE_DATAf_GET(r) (((r).lp_page_0[0]) & 0xffff)
#define BCMI_TSC_XGXS_LP_PAGE_0r_LP_PAGE_0_PAGE_DATAf_SET(r,f) (r).lp_page_0[0]=(((r).lp_page_0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access LP_PAGE_0.
 *
 */
#define BCMI_TSC_XGXS_READ_LP_PAGE_0r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_LP_PAGE_0r,(_r._lp_page_0))
#define BCMI_TSC_XGXS_WRITE_LP_PAGE_0r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_LP_PAGE_0r,(_r._lp_page_0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define LP_PAGE_0r BCMI_TSC_XGXS_LP_PAGE_0r
#define LP_PAGE_0r_SIZE BCMI_TSC_XGXS_LP_PAGE_0r_SIZE
typedef BCMI_TSC_XGXS_LP_PAGE_0r_t LP_PAGE_0r_t;
#define LP_PAGE_0r_CLR BCMI_TSC_XGXS_LP_PAGE_0r_CLR
#define LP_PAGE_0r_SET BCMI_TSC_XGXS_LP_PAGE_0r_SET
#define LP_PAGE_0r_GET BCMI_TSC_XGXS_LP_PAGE_0r_GET
#define LP_PAGE_0r_LP_PAGE_0_PAGE_DATAf_GET BCMI_TSC_XGXS_LP_PAGE_0r_LP_PAGE_0_PAGE_DATAf_GET
#define LP_PAGE_0r_LP_PAGE_0_PAGE_DATAf_SET BCMI_TSC_XGXS_LP_PAGE_0r_LP_PAGE_0_PAGE_DATAf_SET
#define READ_LP_PAGE_0r BCMI_TSC_XGXS_READ_LP_PAGE_0r
#define WRITE_LP_PAGE_0r BCMI_TSC_XGXS_WRITE_LP_PAGE_0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_LP_PAGE_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  SW_CONTROL_STATUS
 * BLOCKS:   AN_X4_SW_MANAGEMENT
 * REGADDR:  0xc1a6
 * DESC:     SW CONTROL STATUS INFORMATION: 00000000
 * SIZE:     32
 * FIELDS:
 *     LP_STATUS_VALID  
 *     LD_CONTROL_VALID 
 *     AN_COMPLETED_SW  
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_SW_CONTROL_STATUSr (0x0000c1a6 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_SW_CONTROL_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program SW_CONTROL_STATUS.
 *
 */
typedef union BCMI_TSC_XGXS_SW_CONTROL_STATUSr_s {
	uint32_t v[1];
	uint32_t sw_control_status[1];
	uint32_t _sw_control_status;
} BCMI_TSC_XGXS_SW_CONTROL_STATUSr_t;

#define BCMI_TSC_XGXS_SW_CONTROL_STATUSr_CLR(r) (r).sw_control_status[0] = 0
#define BCMI_TSC_XGXS_SW_CONTROL_STATUSr_SET(r,d) (r).sw_control_status[0] = d
#define BCMI_TSC_XGXS_SW_CONTROL_STATUSr_GET(r) (r).sw_control_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_SW_CONTROL_STATUSr_RESERVED0f_GET(r) ((((r).sw_control_status[0]) >> 3) & 0x1fff)
#define BCMI_TSC_XGXS_SW_CONTROL_STATUSr_RESERVED0f_SET(r,f) (r).sw_control_status[0]=(((r).sw_control_status[0] & ~((uint32_t)0x1fff << 3)) | ((((uint32_t)f) & 0x1fff) << 3))
#define BCMI_TSC_XGXS_SW_CONTROL_STATUSr_AN_COMPLETED_SWf_GET(r) ((((r).sw_control_status[0]) >> 2) & 0x1)
#define BCMI_TSC_XGXS_SW_CONTROL_STATUSr_AN_COMPLETED_SWf_SET(r,f) (r).sw_control_status[0]=(((r).sw_control_status[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCMI_TSC_XGXS_SW_CONTROL_STATUSr_LD_CONTROL_VALIDf_GET(r) ((((r).sw_control_status[0]) >> 1) & 0x1)
#define BCMI_TSC_XGXS_SW_CONTROL_STATUSr_LD_CONTROL_VALIDf_SET(r,f) (r).sw_control_status[0]=(((r).sw_control_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCMI_TSC_XGXS_SW_CONTROL_STATUSr_LP_STATUS_VALIDf_GET(r) (((r).sw_control_status[0]) & 0x1)
#define BCMI_TSC_XGXS_SW_CONTROL_STATUSr_LP_STATUS_VALIDf_SET(r,f) (r).sw_control_status[0]=(((r).sw_control_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access SW_CONTROL_STATUS.
 *
 */
#define BCMI_TSC_XGXS_READ_SW_CONTROL_STATUSr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_SW_CONTROL_STATUSr,(_r._sw_control_status))
#define BCMI_TSC_XGXS_WRITE_SW_CONTROL_STATUSr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_SW_CONTROL_STATUSr,(_r._sw_control_status))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SW_CONTROL_STATUSr BCMI_TSC_XGXS_SW_CONTROL_STATUSr
#define SW_CONTROL_STATUSr_SIZE BCMI_TSC_XGXS_SW_CONTROL_STATUSr_SIZE
typedef BCMI_TSC_XGXS_SW_CONTROL_STATUSr_t SW_CONTROL_STATUSr_t;
#define SW_CONTROL_STATUSr_CLR BCMI_TSC_XGXS_SW_CONTROL_STATUSr_CLR
#define SW_CONTROL_STATUSr_SET BCMI_TSC_XGXS_SW_CONTROL_STATUSr_SET
#define SW_CONTROL_STATUSr_GET BCMI_TSC_XGXS_SW_CONTROL_STATUSr_GET
#define SW_CONTROL_STATUSr_RESERVED0f_GET BCMI_TSC_XGXS_SW_CONTROL_STATUSr_RESERVED0f_GET
#define SW_CONTROL_STATUSr_RESERVED0f_SET BCMI_TSC_XGXS_SW_CONTROL_STATUSr_RESERVED0f_SET
#define SW_CONTROL_STATUSr_AN_COMPLETED_SWf_GET BCMI_TSC_XGXS_SW_CONTROL_STATUSr_AN_COMPLETED_SWf_GET
#define SW_CONTROL_STATUSr_AN_COMPLETED_SWf_SET BCMI_TSC_XGXS_SW_CONTROL_STATUSr_AN_COMPLETED_SWf_SET
#define SW_CONTROL_STATUSr_LD_CONTROL_VALIDf_GET BCMI_TSC_XGXS_SW_CONTROL_STATUSr_LD_CONTROL_VALIDf_GET
#define SW_CONTROL_STATUSr_LD_CONTROL_VALIDf_SET BCMI_TSC_XGXS_SW_CONTROL_STATUSr_LD_CONTROL_VALIDf_SET
#define SW_CONTROL_STATUSr_LP_STATUS_VALIDf_GET BCMI_TSC_XGXS_SW_CONTROL_STATUSr_LP_STATUS_VALIDf_GET
#define SW_CONTROL_STATUSr_LP_STATUS_VALIDf_SET BCMI_TSC_XGXS_SW_CONTROL_STATUSr_LP_STATUS_VALIDf_SET
#define READ_SW_CONTROL_STATUSr BCMI_TSC_XGXS_READ_SW_CONTROL_STATUSr
#define WRITE_SW_CONTROL_STATUSr BCMI_TSC_XGXS_WRITE_SW_CONTROL_STATUSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_SW_CONTROL_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  LD_CONTROL
 * BLOCKS:   AN_X4_SW_MANAGEMENT
 * REGADDR:  0xc1a7
 * DESC:     LOCAL DEVICE CONTROLS: 00000000
 * SIZE:     32
 * FIELDS:
 *     SW_HCD           
 *     SW_AN            
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_LD_CONTROLr (0x0000c1a7 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_LD_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program LD_CONTROL.
 *
 */
typedef union BCMI_TSC_XGXS_LD_CONTROLr_s {
	uint32_t v[1];
	uint32_t ld_control[1];
	uint32_t _ld_control;
} BCMI_TSC_XGXS_LD_CONTROLr_t;

#define BCMI_TSC_XGXS_LD_CONTROLr_CLR(r) (r).ld_control[0] = 0
#define BCMI_TSC_XGXS_LD_CONTROLr_SET(r,d) (r).ld_control[0] = d
#define BCMI_TSC_XGXS_LD_CONTROLr_GET(r) (r).ld_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_LD_CONTROLr_RESERVED0f_GET(r) ((((r).ld_control[0]) >> 2) & 0x3fff)
#define BCMI_TSC_XGXS_LD_CONTROLr_RESERVED0f_SET(r,f) (r).ld_control[0]=(((r).ld_control[0] & ~((uint32_t)0x3fff << 2)) | ((((uint32_t)f) & 0x3fff) << 2))
#define BCMI_TSC_XGXS_LD_CONTROLr_SW_ANf_GET(r) ((((r).ld_control[0]) >> 1) & 0x1)
#define BCMI_TSC_XGXS_LD_CONTROLr_SW_ANf_SET(r,f) (r).ld_control[0]=(((r).ld_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCMI_TSC_XGXS_LD_CONTROLr_SW_HCDf_GET(r) (((r).ld_control[0]) & 0x1)
#define BCMI_TSC_XGXS_LD_CONTROLr_SW_HCDf_SET(r,f) (r).ld_control[0]=(((r).ld_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access LD_CONTROL.
 *
 */
#define BCMI_TSC_XGXS_READ_LD_CONTROLr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_LD_CONTROLr,(_r._ld_control))
#define BCMI_TSC_XGXS_WRITE_LD_CONTROLr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_LD_CONTROLr,(_r._ld_control))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define LD_CONTROLr BCMI_TSC_XGXS_LD_CONTROLr
#define LD_CONTROLr_SIZE BCMI_TSC_XGXS_LD_CONTROLr_SIZE
typedef BCMI_TSC_XGXS_LD_CONTROLr_t LD_CONTROLr_t;
#define LD_CONTROLr_CLR BCMI_TSC_XGXS_LD_CONTROLr_CLR
#define LD_CONTROLr_SET BCMI_TSC_XGXS_LD_CONTROLr_SET
#define LD_CONTROLr_GET BCMI_TSC_XGXS_LD_CONTROLr_GET
#define LD_CONTROLr_RESERVED0f_GET BCMI_TSC_XGXS_LD_CONTROLr_RESERVED0f_GET
#define LD_CONTROLr_RESERVED0f_SET BCMI_TSC_XGXS_LD_CONTROLr_RESERVED0f_SET
#define LD_CONTROLr_SW_ANf_GET BCMI_TSC_XGXS_LD_CONTROLr_SW_ANf_GET
#define LD_CONTROLr_SW_ANf_SET BCMI_TSC_XGXS_LD_CONTROLr_SW_ANf_SET
#define LD_CONTROLr_SW_HCDf_GET BCMI_TSC_XGXS_LD_CONTROLr_SW_HCDf_GET
#define LD_CONTROLr_SW_HCDf_SET BCMI_TSC_XGXS_LD_CONTROLr_SW_HCDf_SET
#define READ_LD_CONTROLr BCMI_TSC_XGXS_READ_LD_CONTROLr
#define WRITE_LD_CONTROLr BCMI_TSC_XGXS_WRITE_LD_CONTROLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_LD_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  AN_PAGE_SEQUENCER_STATUS
 * BLOCKS:   AN_X4_SW_MANAGEMENT
 * REGADDR:  0xc1a8
 * DESC:     AN PAGE SEQUENCER STATUS: 00000000
 * SIZE:     32
 * FIELDS:
 *     AN_ST_CL73_COMPLETE 
 *     AN_ST_CL37_COMPLETE 
 *     AN_ST_RX_NP_TOGGLE_ERR 
 *     AN_ST_RX_INVALID_SEQ 
 *     AN_ST_RX_UP_OUI_MATCH 
 *     AN_ST_RX_UP_OUI_MISMATCH 
 *     AN_ST_RX_UP_3    
 *     AN_ST_RX_MP_MISMATCH 
 *     AN_ST_RX_MP_OVER1G 
 *     AN_ST_RX_MP_OUI  
 *     AN_ST_RX_MP_NULL 
 *     AN_ST_RX_NP      
 *     AN_ST_RX_BP      
 *     AN_ST_RX_SGMII_MISMATCH 
 *     AN_ST_HP_MODE    
 *     AN_ST_SGMII_MODE 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr (0x0000c1a8 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program AN_PAGE_SEQUENCER_STATUS.
 *
 */
typedef union BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_s {
	uint32_t v[1];
	uint32_t an_page_sequencer_status[1];
	uint32_t _an_page_sequencer_status;
} BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_t;

#define BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_CLR(r) (r).an_page_sequencer_status[0] = 0
#define BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_SET(r,d) (r).an_page_sequencer_status[0] = d
#define BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_GET(r) (r).an_page_sequencer_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_AN_ST_SGMII_MODEf_GET(r) ((((r).an_page_sequencer_status[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_AN_ST_SGMII_MODEf_SET(r,f) (r).an_page_sequencer_status[0]=(((r).an_page_sequencer_status[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_AN_ST_HP_MODEf_GET(r) ((((r).an_page_sequencer_status[0]) >> 14) & 0x1)
#define BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_AN_ST_HP_MODEf_SET(r,f) (r).an_page_sequencer_status[0]=(((r).an_page_sequencer_status[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_SGMII_MISMATCHf_GET(r) ((((r).an_page_sequencer_status[0]) >> 13) & 0x1)
#define BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_SGMII_MISMATCHf_SET(r,f) (r).an_page_sequencer_status[0]=(((r).an_page_sequencer_status[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_BPf_GET(r) ((((r).an_page_sequencer_status[0]) >> 12) & 0x1)
#define BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_BPf_SET(r,f) (r).an_page_sequencer_status[0]=(((r).an_page_sequencer_status[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_NPf_GET(r) ((((r).an_page_sequencer_status[0]) >> 11) & 0x1)
#define BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_NPf_SET(r,f) (r).an_page_sequencer_status[0]=(((r).an_page_sequencer_status[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_MP_NULLf_GET(r) ((((r).an_page_sequencer_status[0]) >> 10) & 0x1)
#define BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_MP_NULLf_SET(r,f) (r).an_page_sequencer_status[0]=(((r).an_page_sequencer_status[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_MP_OUIf_GET(r) ((((r).an_page_sequencer_status[0]) >> 9) & 0x1)
#define BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_MP_OUIf_SET(r,f) (r).an_page_sequencer_status[0]=(((r).an_page_sequencer_status[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_MP_OVER1Gf_GET(r) ((((r).an_page_sequencer_status[0]) >> 8) & 0x1)
#define BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_MP_OVER1Gf_SET(r,f) (r).an_page_sequencer_status[0]=(((r).an_page_sequencer_status[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_MP_MISMATCHf_GET(r) ((((r).an_page_sequencer_status[0]) >> 7) & 0x1)
#define BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_MP_MISMATCHf_SET(r,f) (r).an_page_sequencer_status[0]=(((r).an_page_sequencer_status[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_UP_3f_GET(r) ((((r).an_page_sequencer_status[0]) >> 6) & 0x1)
#define BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_UP_3f_SET(r,f) (r).an_page_sequencer_status[0]=(((r).an_page_sequencer_status[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_UP_OUI_MISMATCHf_GET(r) ((((r).an_page_sequencer_status[0]) >> 5) & 0x1)
#define BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_UP_OUI_MISMATCHf_SET(r,f) (r).an_page_sequencer_status[0]=(((r).an_page_sequencer_status[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_UP_OUI_MATCHf_GET(r) ((((r).an_page_sequencer_status[0]) >> 4) & 0x1)
#define BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_UP_OUI_MATCHf_SET(r,f) (r).an_page_sequencer_status[0]=(((r).an_page_sequencer_status[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_INVALID_SEQf_GET(r) ((((r).an_page_sequencer_status[0]) >> 3) & 0x1)
#define BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_INVALID_SEQf_SET(r,f) (r).an_page_sequencer_status[0]=(((r).an_page_sequencer_status[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_NP_TOGGLE_ERRf_GET(r) ((((r).an_page_sequencer_status[0]) >> 2) & 0x1)
#define BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_NP_TOGGLE_ERRf_SET(r,f) (r).an_page_sequencer_status[0]=(((r).an_page_sequencer_status[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_AN_ST_CL37_COMPLETEf_GET(r) ((((r).an_page_sequencer_status[0]) >> 1) & 0x1)
#define BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_AN_ST_CL37_COMPLETEf_SET(r,f) (r).an_page_sequencer_status[0]=(((r).an_page_sequencer_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_AN_ST_CL73_COMPLETEf_GET(r) (((r).an_page_sequencer_status[0]) & 0x1)
#define BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_AN_ST_CL73_COMPLETEf_SET(r,f) (r).an_page_sequencer_status[0]=(((r).an_page_sequencer_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access AN_PAGE_SEQUENCER_STATUS.
 *
 */
#define BCMI_TSC_XGXS_READ_AN_PAGE_SEQUENCER_STATUSr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr,(_r._an_page_sequencer_status))
#define BCMI_TSC_XGXS_WRITE_AN_PAGE_SEQUENCER_STATUSr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr,(_r._an_page_sequencer_status))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_PAGE_SEQUENCER_STATUSr BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr
#define AN_PAGE_SEQUENCER_STATUSr_SIZE BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_SIZE
typedef BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_t AN_PAGE_SEQUENCER_STATUSr_t;
#define AN_PAGE_SEQUENCER_STATUSr_CLR BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_CLR
#define AN_PAGE_SEQUENCER_STATUSr_SET BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_SET
#define AN_PAGE_SEQUENCER_STATUSr_GET BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_GET
#define AN_PAGE_SEQUENCER_STATUSr_AN_ST_SGMII_MODEf_GET BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_AN_ST_SGMII_MODEf_GET
#define AN_PAGE_SEQUENCER_STATUSr_AN_ST_SGMII_MODEf_SET BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_AN_ST_SGMII_MODEf_SET
#define AN_PAGE_SEQUENCER_STATUSr_AN_ST_HP_MODEf_GET BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_AN_ST_HP_MODEf_GET
#define AN_PAGE_SEQUENCER_STATUSr_AN_ST_HP_MODEf_SET BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_AN_ST_HP_MODEf_SET
#define AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_SGMII_MISMATCHf_GET BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_SGMII_MISMATCHf_GET
#define AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_SGMII_MISMATCHf_SET BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_SGMII_MISMATCHf_SET
#define AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_BPf_GET BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_BPf_GET
#define AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_BPf_SET BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_BPf_SET
#define AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_NPf_GET BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_NPf_GET
#define AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_NPf_SET BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_NPf_SET
#define AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_MP_NULLf_GET BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_MP_NULLf_GET
#define AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_MP_NULLf_SET BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_MP_NULLf_SET
#define AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_MP_OUIf_GET BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_MP_OUIf_GET
#define AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_MP_OUIf_SET BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_MP_OUIf_SET
#define AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_MP_OVER1Gf_GET BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_MP_OVER1Gf_GET
#define AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_MP_OVER1Gf_SET BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_MP_OVER1Gf_SET
#define AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_MP_MISMATCHf_GET BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_MP_MISMATCHf_GET
#define AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_MP_MISMATCHf_SET BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_MP_MISMATCHf_SET
#define AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_UP_3f_GET BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_UP_3f_GET
#define AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_UP_3f_SET BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_UP_3f_SET
#define AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_UP_OUI_MISMATCHf_GET BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_UP_OUI_MISMATCHf_GET
#define AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_UP_OUI_MISMATCHf_SET BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_UP_OUI_MISMATCHf_SET
#define AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_UP_OUI_MATCHf_GET BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_UP_OUI_MATCHf_GET
#define AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_UP_OUI_MATCHf_SET BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_UP_OUI_MATCHf_SET
#define AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_INVALID_SEQf_GET BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_INVALID_SEQf_GET
#define AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_INVALID_SEQf_SET BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_INVALID_SEQf_SET
#define AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_NP_TOGGLE_ERRf_GET BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_NP_TOGGLE_ERRf_GET
#define AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_NP_TOGGLE_ERRf_SET BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_AN_ST_RX_NP_TOGGLE_ERRf_SET
#define AN_PAGE_SEQUENCER_STATUSr_AN_ST_CL37_COMPLETEf_GET BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_AN_ST_CL37_COMPLETEf_GET
#define AN_PAGE_SEQUENCER_STATUSr_AN_ST_CL37_COMPLETEf_SET BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_AN_ST_CL37_COMPLETEf_SET
#define AN_PAGE_SEQUENCER_STATUSr_AN_ST_CL73_COMPLETEf_GET BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_AN_ST_CL73_COMPLETEf_GET
#define AN_PAGE_SEQUENCER_STATUSr_AN_ST_CL73_COMPLETEf_SET BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr_AN_ST_CL73_COMPLETEf_SET
#define READ_AN_PAGE_SEQUENCER_STATUSr BCMI_TSC_XGXS_READ_AN_PAGE_SEQUENCER_STATUSr
#define WRITE_AN_PAGE_SEQUENCER_STATUSr BCMI_TSC_XGXS_WRITE_AN_PAGE_SEQUENCER_STATUSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_AN_PAGE_SEQUENCER_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  AN_PAGE_EXCHANGEER_STATUS
 * BLOCKS:   AN_X4_SW_MANAGEMENT
 * REGADDR:  0xc1a9
 * DESC:     AN PAGE EXCHANGER STATUS: 00000000
 * SIZE:     32
 * FIELDS:
 *     AN_ST_CONFIG_RESTART 
 *     AN_ST_IDLE_DETECT 
 *     AN_ST_DISABLE_LINK 
 *     AN_ST_ERROR_STATE 
 *     AN_ST_AN_ENABLE  
 *     AN_ST_ABILITY_DETECT 
 *     AN_ST_ACK_DETECT 
 *     AN_ST_COMPLETE_ACK 
 *     AN_ST_CONSISTENCY_MISMATCH 
 *     AN_ST_CONFIG_NONZERO 
 *     AN_ST_RESTART    
 *     AN_ST_AN_GOOD_CHECK 
 *     AN_ST_LINK_OK    
 *     AN_ST_NEXT_PAGE_WAIT 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr (0x0000c1a9 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program AN_PAGE_EXCHANGEER_STATUS.
 *
 */
typedef union BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_s {
	uint32_t v[1];
	uint32_t an_page_exchangeer_status[1];
	uint32_t _an_page_exchangeer_status;
} BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_t;

#define BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_CLR(r) (r).an_page_exchangeer_status[0] = 0
#define BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_SET(r,d) (r).an_page_exchangeer_status[0] = d
#define BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_GET(r) (r).an_page_exchangeer_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_RESERVED0f_GET(r) ((((r).an_page_exchangeer_status[0]) >> 14) & 0x3)
#define BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_RESERVED0f_SET(r,f) (r).an_page_exchangeer_status[0]=(((r).an_page_exchangeer_status[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_AN_ST_NEXT_PAGE_WAITf_GET(r) ((((r).an_page_exchangeer_status[0]) >> 13) & 0x1)
#define BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_AN_ST_NEXT_PAGE_WAITf_SET(r,f) (r).an_page_exchangeer_status[0]=(((r).an_page_exchangeer_status[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_AN_ST_LINK_OKf_GET(r) ((((r).an_page_exchangeer_status[0]) >> 12) & 0x1)
#define BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_AN_ST_LINK_OKf_SET(r,f) (r).an_page_exchangeer_status[0]=(((r).an_page_exchangeer_status[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_AN_ST_AN_GOOD_CHECKf_GET(r) ((((r).an_page_exchangeer_status[0]) >> 11) & 0x1)
#define BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_AN_ST_AN_GOOD_CHECKf_SET(r,f) (r).an_page_exchangeer_status[0]=(((r).an_page_exchangeer_status[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_AN_ST_RESTARTf_GET(r) ((((r).an_page_exchangeer_status[0]) >> 10) & 0x1)
#define BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_AN_ST_RESTARTf_SET(r,f) (r).an_page_exchangeer_status[0]=(((r).an_page_exchangeer_status[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_AN_ST_CONFIG_NONZEROf_GET(r) ((((r).an_page_exchangeer_status[0]) >> 9) & 0x1)
#define BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_AN_ST_CONFIG_NONZEROf_SET(r,f) (r).an_page_exchangeer_status[0]=(((r).an_page_exchangeer_status[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_AN_ST_CONSISTENCY_MISMATCHf_GET(r) ((((r).an_page_exchangeer_status[0]) >> 8) & 0x1)
#define BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_AN_ST_CONSISTENCY_MISMATCHf_SET(r,f) (r).an_page_exchangeer_status[0]=(((r).an_page_exchangeer_status[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_AN_ST_COMPLETE_ACKf_GET(r) ((((r).an_page_exchangeer_status[0]) >> 7) & 0x1)
#define BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_AN_ST_COMPLETE_ACKf_SET(r,f) (r).an_page_exchangeer_status[0]=(((r).an_page_exchangeer_status[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_AN_ST_ACK_DETECTf_GET(r) ((((r).an_page_exchangeer_status[0]) >> 6) & 0x1)
#define BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_AN_ST_ACK_DETECTf_SET(r,f) (r).an_page_exchangeer_status[0]=(((r).an_page_exchangeer_status[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_AN_ST_ABILITY_DETECTf_GET(r) ((((r).an_page_exchangeer_status[0]) >> 5) & 0x1)
#define BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_AN_ST_ABILITY_DETECTf_SET(r,f) (r).an_page_exchangeer_status[0]=(((r).an_page_exchangeer_status[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_AN_ST_AN_ENABLEf_GET(r) ((((r).an_page_exchangeer_status[0]) >> 4) & 0x1)
#define BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_AN_ST_AN_ENABLEf_SET(r,f) (r).an_page_exchangeer_status[0]=(((r).an_page_exchangeer_status[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_AN_ST_ERROR_STATEf_GET(r) ((((r).an_page_exchangeer_status[0]) >> 3) & 0x1)
#define BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_AN_ST_ERROR_STATEf_SET(r,f) (r).an_page_exchangeer_status[0]=(((r).an_page_exchangeer_status[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_AN_ST_DISABLE_LINKf_GET(r) ((((r).an_page_exchangeer_status[0]) >> 2) & 0x1)
#define BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_AN_ST_DISABLE_LINKf_SET(r,f) (r).an_page_exchangeer_status[0]=(((r).an_page_exchangeer_status[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_AN_ST_IDLE_DETECTf_GET(r) ((((r).an_page_exchangeer_status[0]) >> 1) & 0x1)
#define BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_AN_ST_IDLE_DETECTf_SET(r,f) (r).an_page_exchangeer_status[0]=(((r).an_page_exchangeer_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_AN_ST_CONFIG_RESTARTf_GET(r) (((r).an_page_exchangeer_status[0]) & 0x1)
#define BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_AN_ST_CONFIG_RESTARTf_SET(r,f) (r).an_page_exchangeer_status[0]=(((r).an_page_exchangeer_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access AN_PAGE_EXCHANGEER_STATUS.
 *
 */
#define BCMI_TSC_XGXS_READ_AN_PAGE_EXCHANGEER_STATUSr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr,(_r._an_page_exchangeer_status))
#define BCMI_TSC_XGXS_WRITE_AN_PAGE_EXCHANGEER_STATUSr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr,(_r._an_page_exchangeer_status))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_PAGE_EXCHANGEER_STATUSr BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr
#define AN_PAGE_EXCHANGEER_STATUSr_SIZE BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_SIZE
typedef BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_t AN_PAGE_EXCHANGEER_STATUSr_t;
#define AN_PAGE_EXCHANGEER_STATUSr_CLR BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_CLR
#define AN_PAGE_EXCHANGEER_STATUSr_SET BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_SET
#define AN_PAGE_EXCHANGEER_STATUSr_GET BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_GET
#define AN_PAGE_EXCHANGEER_STATUSr_RESERVED0f_GET BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_RESERVED0f_GET
#define AN_PAGE_EXCHANGEER_STATUSr_RESERVED0f_SET BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_RESERVED0f_SET
#define AN_PAGE_EXCHANGEER_STATUSr_AN_ST_NEXT_PAGE_WAITf_GET BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_AN_ST_NEXT_PAGE_WAITf_GET
#define AN_PAGE_EXCHANGEER_STATUSr_AN_ST_NEXT_PAGE_WAITf_SET BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_AN_ST_NEXT_PAGE_WAITf_SET
#define AN_PAGE_EXCHANGEER_STATUSr_AN_ST_LINK_OKf_GET BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_AN_ST_LINK_OKf_GET
#define AN_PAGE_EXCHANGEER_STATUSr_AN_ST_LINK_OKf_SET BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_AN_ST_LINK_OKf_SET
#define AN_PAGE_EXCHANGEER_STATUSr_AN_ST_AN_GOOD_CHECKf_GET BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_AN_ST_AN_GOOD_CHECKf_GET
#define AN_PAGE_EXCHANGEER_STATUSr_AN_ST_AN_GOOD_CHECKf_SET BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_AN_ST_AN_GOOD_CHECKf_SET
#define AN_PAGE_EXCHANGEER_STATUSr_AN_ST_RESTARTf_GET BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_AN_ST_RESTARTf_GET
#define AN_PAGE_EXCHANGEER_STATUSr_AN_ST_RESTARTf_SET BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_AN_ST_RESTARTf_SET
#define AN_PAGE_EXCHANGEER_STATUSr_AN_ST_CONFIG_NONZEROf_GET BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_AN_ST_CONFIG_NONZEROf_GET
#define AN_PAGE_EXCHANGEER_STATUSr_AN_ST_CONFIG_NONZEROf_SET BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_AN_ST_CONFIG_NONZEROf_SET
#define AN_PAGE_EXCHANGEER_STATUSr_AN_ST_CONSISTENCY_MISMATCHf_GET BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_AN_ST_CONSISTENCY_MISMATCHf_GET
#define AN_PAGE_EXCHANGEER_STATUSr_AN_ST_CONSISTENCY_MISMATCHf_SET BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_AN_ST_CONSISTENCY_MISMATCHf_SET
#define AN_PAGE_EXCHANGEER_STATUSr_AN_ST_COMPLETE_ACKf_GET BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_AN_ST_COMPLETE_ACKf_GET
#define AN_PAGE_EXCHANGEER_STATUSr_AN_ST_COMPLETE_ACKf_SET BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_AN_ST_COMPLETE_ACKf_SET
#define AN_PAGE_EXCHANGEER_STATUSr_AN_ST_ACK_DETECTf_GET BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_AN_ST_ACK_DETECTf_GET
#define AN_PAGE_EXCHANGEER_STATUSr_AN_ST_ACK_DETECTf_SET BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_AN_ST_ACK_DETECTf_SET
#define AN_PAGE_EXCHANGEER_STATUSr_AN_ST_ABILITY_DETECTf_GET BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_AN_ST_ABILITY_DETECTf_GET
#define AN_PAGE_EXCHANGEER_STATUSr_AN_ST_ABILITY_DETECTf_SET BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_AN_ST_ABILITY_DETECTf_SET
#define AN_PAGE_EXCHANGEER_STATUSr_AN_ST_AN_ENABLEf_GET BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_AN_ST_AN_ENABLEf_GET
#define AN_PAGE_EXCHANGEER_STATUSr_AN_ST_AN_ENABLEf_SET BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_AN_ST_AN_ENABLEf_SET
#define AN_PAGE_EXCHANGEER_STATUSr_AN_ST_ERROR_STATEf_GET BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_AN_ST_ERROR_STATEf_GET
#define AN_PAGE_EXCHANGEER_STATUSr_AN_ST_ERROR_STATEf_SET BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_AN_ST_ERROR_STATEf_SET
#define AN_PAGE_EXCHANGEER_STATUSr_AN_ST_DISABLE_LINKf_GET BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_AN_ST_DISABLE_LINKf_GET
#define AN_PAGE_EXCHANGEER_STATUSr_AN_ST_DISABLE_LINKf_SET BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_AN_ST_DISABLE_LINKf_SET
#define AN_PAGE_EXCHANGEER_STATUSr_AN_ST_IDLE_DETECTf_GET BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_AN_ST_IDLE_DETECTf_GET
#define AN_PAGE_EXCHANGEER_STATUSr_AN_ST_IDLE_DETECTf_SET BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_AN_ST_IDLE_DETECTf_SET
#define AN_PAGE_EXCHANGEER_STATUSr_AN_ST_CONFIG_RESTARTf_GET BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_AN_ST_CONFIG_RESTARTf_GET
#define AN_PAGE_EXCHANGEER_STATUSr_AN_ST_CONFIG_RESTARTf_SET BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr_AN_ST_CONFIG_RESTARTf_SET
#define READ_AN_PAGE_EXCHANGEER_STATUSr BCMI_TSC_XGXS_READ_AN_PAGE_EXCHANGEER_STATUSr
#define WRITE_AN_PAGE_EXCHANGEER_STATUSr BCMI_TSC_XGXS_WRITE_AN_PAGE_EXCHANGEER_STATUSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_AN_PAGE_EXCHANGEER_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  AN_PAGE_DECODER_STATUS
 * BLOCKS:   AN_X4_SW_MANAGEMENT
 * REGADDR:  0xc1aa
 * DESC:     AN PAGE DECODER STATUS: 00000000
 * SIZE:     32
 * FIELDS:
 *     AN_RX_ST_STATE   
 *     AN_RX_ST_RUDI_INVALID 
 *     AN_RX_ST_RUDI_CONFIG 
 *     AN_RX_ST_RUDI_IDLE 
 *     AN_RX_ST_PAGE    
 *     AN_RX_ST_MV_PAIR 
 *     AN_RX_ST_CLK_TRANS_MISS 
 *     AN_RX_ST_PAGE_TOO_LONG 
 *     AN_RX_ST_PAGE_TOO_SHORT 
 *     AN_RX_ST_PULSE_TOO_LONG 
 *     AN_RX_ST_PULSE_TOO_SHORT 
 *     AN_RX_ST_PULSE_TOO_MODERATE 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr (0x0000c1aa | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program AN_PAGE_DECODER_STATUS.
 *
 */
typedef union BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr_s {
	uint32_t v[1];
	uint32_t an_page_decoder_status[1];
	uint32_t _an_page_decoder_status;
} BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr_t;

#define BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr_CLR(r) (r).an_page_decoder_status[0] = 0
#define BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr_SET(r,d) (r).an_page_decoder_status[0] = d
#define BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr_GET(r) (r).an_page_decoder_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr_RESERVED0f_GET(r) ((((r).an_page_decoder_status[0]) >> 13) & 0x7)
#define BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr_RESERVED0f_SET(r,f) (r).an_page_decoder_status[0]=(((r).an_page_decoder_status[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))
#define BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr_AN_RX_ST_PULSE_TOO_MODERATEf_GET(r) ((((r).an_page_decoder_status[0]) >> 12) & 0x1)
#define BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr_AN_RX_ST_PULSE_TOO_MODERATEf_SET(r,f) (r).an_page_decoder_status[0]=(((r).an_page_decoder_status[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr_AN_RX_ST_PULSE_TOO_SHORTf_GET(r) ((((r).an_page_decoder_status[0]) >> 11) & 0x1)
#define BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr_AN_RX_ST_PULSE_TOO_SHORTf_SET(r,f) (r).an_page_decoder_status[0]=(((r).an_page_decoder_status[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr_AN_RX_ST_PULSE_TOO_LONGf_GET(r) ((((r).an_page_decoder_status[0]) >> 10) & 0x1)
#define BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr_AN_RX_ST_PULSE_TOO_LONGf_SET(r,f) (r).an_page_decoder_status[0]=(((r).an_page_decoder_status[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr_AN_RX_ST_PAGE_TOO_SHORTf_GET(r) ((((r).an_page_decoder_status[0]) >> 9) & 0x1)
#define BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr_AN_RX_ST_PAGE_TOO_SHORTf_SET(r,f) (r).an_page_decoder_status[0]=(((r).an_page_decoder_status[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr_AN_RX_ST_PAGE_TOO_LONGf_GET(r) ((((r).an_page_decoder_status[0]) >> 8) & 0x1)
#define BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr_AN_RX_ST_PAGE_TOO_LONGf_SET(r,f) (r).an_page_decoder_status[0]=(((r).an_page_decoder_status[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr_AN_RX_ST_CLK_TRANS_MISSf_GET(r) ((((r).an_page_decoder_status[0]) >> 7) & 0x1)
#define BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr_AN_RX_ST_CLK_TRANS_MISSf_SET(r,f) (r).an_page_decoder_status[0]=(((r).an_page_decoder_status[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr_AN_RX_ST_MV_PAIRf_GET(r) ((((r).an_page_decoder_status[0]) >> 6) & 0x1)
#define BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr_AN_RX_ST_MV_PAIRf_SET(r,f) (r).an_page_decoder_status[0]=(((r).an_page_decoder_status[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr_AN_RX_ST_PAGEf_GET(r) ((((r).an_page_decoder_status[0]) >> 5) & 0x1)
#define BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr_AN_RX_ST_PAGEf_SET(r,f) (r).an_page_decoder_status[0]=(((r).an_page_decoder_status[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr_AN_RX_ST_RUDI_IDLEf_GET(r) ((((r).an_page_decoder_status[0]) >> 4) & 0x1)
#define BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr_AN_RX_ST_RUDI_IDLEf_SET(r,f) (r).an_page_decoder_status[0]=(((r).an_page_decoder_status[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr_AN_RX_ST_RUDI_CONFIGf_GET(r) ((((r).an_page_decoder_status[0]) >> 3) & 0x1)
#define BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr_AN_RX_ST_RUDI_CONFIGf_SET(r,f) (r).an_page_decoder_status[0]=(((r).an_page_decoder_status[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr_AN_RX_ST_RUDI_INVALIDf_GET(r) ((((r).an_page_decoder_status[0]) >> 2) & 0x1)
#define BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr_AN_RX_ST_RUDI_INVALIDf_SET(r,f) (r).an_page_decoder_status[0]=(((r).an_page_decoder_status[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr_AN_RX_ST_STATEf_GET(r) (((r).an_page_decoder_status[0]) & 0x3)
#define BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr_AN_RX_ST_STATEf_SET(r,f) (r).an_page_decoder_status[0]=(((r).an_page_decoder_status[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))

/*
 * These macros can be used to access AN_PAGE_DECODER_STATUS.
 *
 */
#define BCMI_TSC_XGXS_READ_AN_PAGE_DECODER_STATUSr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr,(_r._an_page_decoder_status))
#define BCMI_TSC_XGXS_WRITE_AN_PAGE_DECODER_STATUSr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr,(_r._an_page_decoder_status))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_PAGE_DECODER_STATUSr BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr
#define AN_PAGE_DECODER_STATUSr_SIZE BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr_SIZE
typedef BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr_t AN_PAGE_DECODER_STATUSr_t;
#define AN_PAGE_DECODER_STATUSr_CLR BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr_CLR
#define AN_PAGE_DECODER_STATUSr_SET BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr_SET
#define AN_PAGE_DECODER_STATUSr_GET BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr_GET
#define AN_PAGE_DECODER_STATUSr_RESERVED0f_GET BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr_RESERVED0f_GET
#define AN_PAGE_DECODER_STATUSr_RESERVED0f_SET BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr_RESERVED0f_SET
#define AN_PAGE_DECODER_STATUSr_AN_RX_ST_PULSE_TOO_MODERATEf_GET BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr_AN_RX_ST_PULSE_TOO_MODERATEf_GET
#define AN_PAGE_DECODER_STATUSr_AN_RX_ST_PULSE_TOO_MODERATEf_SET BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr_AN_RX_ST_PULSE_TOO_MODERATEf_SET
#define AN_PAGE_DECODER_STATUSr_AN_RX_ST_PULSE_TOO_SHORTf_GET BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr_AN_RX_ST_PULSE_TOO_SHORTf_GET
#define AN_PAGE_DECODER_STATUSr_AN_RX_ST_PULSE_TOO_SHORTf_SET BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr_AN_RX_ST_PULSE_TOO_SHORTf_SET
#define AN_PAGE_DECODER_STATUSr_AN_RX_ST_PULSE_TOO_LONGf_GET BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr_AN_RX_ST_PULSE_TOO_LONGf_GET
#define AN_PAGE_DECODER_STATUSr_AN_RX_ST_PULSE_TOO_LONGf_SET BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr_AN_RX_ST_PULSE_TOO_LONGf_SET
#define AN_PAGE_DECODER_STATUSr_AN_RX_ST_PAGE_TOO_SHORTf_GET BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr_AN_RX_ST_PAGE_TOO_SHORTf_GET
#define AN_PAGE_DECODER_STATUSr_AN_RX_ST_PAGE_TOO_SHORTf_SET BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr_AN_RX_ST_PAGE_TOO_SHORTf_SET
#define AN_PAGE_DECODER_STATUSr_AN_RX_ST_PAGE_TOO_LONGf_GET BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr_AN_RX_ST_PAGE_TOO_LONGf_GET
#define AN_PAGE_DECODER_STATUSr_AN_RX_ST_PAGE_TOO_LONGf_SET BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr_AN_RX_ST_PAGE_TOO_LONGf_SET
#define AN_PAGE_DECODER_STATUSr_AN_RX_ST_CLK_TRANS_MISSf_GET BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr_AN_RX_ST_CLK_TRANS_MISSf_GET
#define AN_PAGE_DECODER_STATUSr_AN_RX_ST_CLK_TRANS_MISSf_SET BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr_AN_RX_ST_CLK_TRANS_MISSf_SET
#define AN_PAGE_DECODER_STATUSr_AN_RX_ST_MV_PAIRf_GET BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr_AN_RX_ST_MV_PAIRf_GET
#define AN_PAGE_DECODER_STATUSr_AN_RX_ST_MV_PAIRf_SET BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr_AN_RX_ST_MV_PAIRf_SET
#define AN_PAGE_DECODER_STATUSr_AN_RX_ST_PAGEf_GET BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr_AN_RX_ST_PAGEf_GET
#define AN_PAGE_DECODER_STATUSr_AN_RX_ST_PAGEf_SET BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr_AN_RX_ST_PAGEf_SET
#define AN_PAGE_DECODER_STATUSr_AN_RX_ST_RUDI_IDLEf_GET BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr_AN_RX_ST_RUDI_IDLEf_GET
#define AN_PAGE_DECODER_STATUSr_AN_RX_ST_RUDI_IDLEf_SET BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr_AN_RX_ST_RUDI_IDLEf_SET
#define AN_PAGE_DECODER_STATUSr_AN_RX_ST_RUDI_CONFIGf_GET BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr_AN_RX_ST_RUDI_CONFIGf_GET
#define AN_PAGE_DECODER_STATUSr_AN_RX_ST_RUDI_CONFIGf_SET BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr_AN_RX_ST_RUDI_CONFIGf_SET
#define AN_PAGE_DECODER_STATUSr_AN_RX_ST_RUDI_INVALIDf_GET BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr_AN_RX_ST_RUDI_INVALIDf_GET
#define AN_PAGE_DECODER_STATUSr_AN_RX_ST_RUDI_INVALIDf_SET BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr_AN_RX_ST_RUDI_INVALIDf_SET
#define AN_PAGE_DECODER_STATUSr_AN_RX_ST_STATEf_GET BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr_AN_RX_ST_STATEf_GET
#define AN_PAGE_DECODER_STATUSr_AN_RX_ST_STATEf_SET BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr_AN_RX_ST_STATEf_SET
#define READ_AN_PAGE_DECODER_STATUSr BCMI_TSC_XGXS_READ_AN_PAGE_DECODER_STATUSr
#define WRITE_AN_PAGE_DECODER_STATUSr BCMI_TSC_XGXS_WRITE_AN_PAGE_DECODER_STATUSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_AN_PAGE_DECODER_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  AN_ABIL_RESOLUTION_STATUS
 * BLOCKS:   AN_X4_SW_MANAGEMENT
 * REGADDR:  0xc1ab
 * DESC:     AN ABILITY RESOLUTION INFORMATION: 00000000
 * SIZE:     32
 * FIELDS:
 *     AN_HCD_SWITCH_TO_CL37 
 *     AN_HCD_HIGIG2    
 *     AN_HCD_CL72      
 *     AN_HCD_FEC       
 *     AN_HCD_SPEED     
 *     AN_HCD_PAUSE     
 *     AN_HCD_DUPLEX    
 *     AN_ST_RESOLUTION_ERR 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_AN_ABIL_RESOLUTION_STATUSr (0x0000c1ab | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_AN_ABIL_RESOLUTION_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program AN_ABIL_RESOLUTION_STATUS.
 *
 */
typedef union BCMI_TSC_XGXS_AN_ABIL_RESOLUTION_STATUSr_s {
	uint32_t v[1];
	uint32_t an_abil_resolution_status[1];
	uint32_t _an_abil_resolution_status;
} BCMI_TSC_XGXS_AN_ABIL_RESOLUTION_STATUSr_t;

#define BCMI_TSC_XGXS_AN_ABIL_RESOLUTION_STATUSr_CLR(r) (r).an_abil_resolution_status[0] = 0
#define BCMI_TSC_XGXS_AN_ABIL_RESOLUTION_STATUSr_SET(r,d) (r).an_abil_resolution_status[0] = d
#define BCMI_TSC_XGXS_AN_ABIL_RESOLUTION_STATUSr_GET(r) (r).an_abil_resolution_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_AN_ABIL_RESOLUTION_STATUSr_RESERVED0f_GET(r) ((((r).an_abil_resolution_status[0]) >> 14) & 0x3)
#define BCMI_TSC_XGXS_AN_ABIL_RESOLUTION_STATUSr_RESERVED0f_SET(r,f) (r).an_abil_resolution_status[0]=(((r).an_abil_resolution_status[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCMI_TSC_XGXS_AN_ABIL_RESOLUTION_STATUSr_AN_ST_RESOLUTION_ERRf_GET(r) ((((r).an_abil_resolution_status[0]) >> 13) & 0x1)
#define BCMI_TSC_XGXS_AN_ABIL_RESOLUTION_STATUSr_AN_ST_RESOLUTION_ERRf_SET(r,f) (r).an_abil_resolution_status[0]=(((r).an_abil_resolution_status[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCMI_TSC_XGXS_AN_ABIL_RESOLUTION_STATUSr_AN_HCD_DUPLEXf_GET(r) ((((r).an_abil_resolution_status[0]) >> 12) & 0x1)
#define BCMI_TSC_XGXS_AN_ABIL_RESOLUTION_STATUSr_AN_HCD_DUPLEXf_SET(r,f) (r).an_abil_resolution_status[0]=(((r).an_abil_resolution_status[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCMI_TSC_XGXS_AN_ABIL_RESOLUTION_STATUSr_AN_HCD_PAUSEf_GET(r) ((((r).an_abil_resolution_status[0]) >> 10) & 0x3)
#define BCMI_TSC_XGXS_AN_ABIL_RESOLUTION_STATUSr_AN_HCD_PAUSEf_SET(r,f) (r).an_abil_resolution_status[0]=(((r).an_abil_resolution_status[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCMI_TSC_XGXS_AN_ABIL_RESOLUTION_STATUSr_AN_HCD_SPEEDf_GET(r) ((((r).an_abil_resolution_status[0]) >> 4) & 0x3f)
#define BCMI_TSC_XGXS_AN_ABIL_RESOLUTION_STATUSr_AN_HCD_SPEEDf_SET(r,f) (r).an_abil_resolution_status[0]=(((r).an_abil_resolution_status[0] & ~((uint32_t)0x3f << 4)) | ((((uint32_t)f) & 0x3f) << 4))
#define BCMI_TSC_XGXS_AN_ABIL_RESOLUTION_STATUSr_AN_HCD_FECf_GET(r) ((((r).an_abil_resolution_status[0]) >> 3) & 0x1)
#define BCMI_TSC_XGXS_AN_ABIL_RESOLUTION_STATUSr_AN_HCD_FECf_SET(r,f) (r).an_abil_resolution_status[0]=(((r).an_abil_resolution_status[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCMI_TSC_XGXS_AN_ABIL_RESOLUTION_STATUSr_AN_HCD_CL72f_GET(r) ((((r).an_abil_resolution_status[0]) >> 2) & 0x1)
#define BCMI_TSC_XGXS_AN_ABIL_RESOLUTION_STATUSr_AN_HCD_CL72f_SET(r,f) (r).an_abil_resolution_status[0]=(((r).an_abil_resolution_status[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCMI_TSC_XGXS_AN_ABIL_RESOLUTION_STATUSr_AN_HCD_HIGIG2f_GET(r) ((((r).an_abil_resolution_status[0]) >> 1) & 0x1)
#define BCMI_TSC_XGXS_AN_ABIL_RESOLUTION_STATUSr_AN_HCD_HIGIG2f_SET(r,f) (r).an_abil_resolution_status[0]=(((r).an_abil_resolution_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCMI_TSC_XGXS_AN_ABIL_RESOLUTION_STATUSr_AN_HCD_SWITCH_TO_CL37f_GET(r) (((r).an_abil_resolution_status[0]) & 0x1)
#define BCMI_TSC_XGXS_AN_ABIL_RESOLUTION_STATUSr_AN_HCD_SWITCH_TO_CL37f_SET(r,f) (r).an_abil_resolution_status[0]=(((r).an_abil_resolution_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access AN_ABIL_RESOLUTION_STATUS.
 *
 */
#define BCMI_TSC_XGXS_READ_AN_ABIL_RESOLUTION_STATUSr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_AN_ABIL_RESOLUTION_STATUSr,(_r._an_abil_resolution_status))
#define BCMI_TSC_XGXS_WRITE_AN_ABIL_RESOLUTION_STATUSr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_AN_ABIL_RESOLUTION_STATUSr,(_r._an_abil_resolution_status))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_ABIL_RESOLUTION_STATUSr BCMI_TSC_XGXS_AN_ABIL_RESOLUTION_STATUSr
#define AN_ABIL_RESOLUTION_STATUSr_SIZE BCMI_TSC_XGXS_AN_ABIL_RESOLUTION_STATUSr_SIZE
typedef BCMI_TSC_XGXS_AN_ABIL_RESOLUTION_STATUSr_t AN_ABIL_RESOLUTION_STATUSr_t;
#define AN_ABIL_RESOLUTION_STATUSr_CLR BCMI_TSC_XGXS_AN_ABIL_RESOLUTION_STATUSr_CLR
#define AN_ABIL_RESOLUTION_STATUSr_SET BCMI_TSC_XGXS_AN_ABIL_RESOLUTION_STATUSr_SET
#define AN_ABIL_RESOLUTION_STATUSr_GET BCMI_TSC_XGXS_AN_ABIL_RESOLUTION_STATUSr_GET
#define AN_ABIL_RESOLUTION_STATUSr_RESERVED0f_GET BCMI_TSC_XGXS_AN_ABIL_RESOLUTION_STATUSr_RESERVED0f_GET
#define AN_ABIL_RESOLUTION_STATUSr_RESERVED0f_SET BCMI_TSC_XGXS_AN_ABIL_RESOLUTION_STATUSr_RESERVED0f_SET
#define AN_ABIL_RESOLUTION_STATUSr_AN_ST_RESOLUTION_ERRf_GET BCMI_TSC_XGXS_AN_ABIL_RESOLUTION_STATUSr_AN_ST_RESOLUTION_ERRf_GET
#define AN_ABIL_RESOLUTION_STATUSr_AN_ST_RESOLUTION_ERRf_SET BCMI_TSC_XGXS_AN_ABIL_RESOLUTION_STATUSr_AN_ST_RESOLUTION_ERRf_SET
#define AN_ABIL_RESOLUTION_STATUSr_AN_HCD_DUPLEXf_GET BCMI_TSC_XGXS_AN_ABIL_RESOLUTION_STATUSr_AN_HCD_DUPLEXf_GET
#define AN_ABIL_RESOLUTION_STATUSr_AN_HCD_DUPLEXf_SET BCMI_TSC_XGXS_AN_ABIL_RESOLUTION_STATUSr_AN_HCD_DUPLEXf_SET
#define AN_ABIL_RESOLUTION_STATUSr_AN_HCD_PAUSEf_GET BCMI_TSC_XGXS_AN_ABIL_RESOLUTION_STATUSr_AN_HCD_PAUSEf_GET
#define AN_ABIL_RESOLUTION_STATUSr_AN_HCD_PAUSEf_SET BCMI_TSC_XGXS_AN_ABIL_RESOLUTION_STATUSr_AN_HCD_PAUSEf_SET
#define AN_ABIL_RESOLUTION_STATUSr_AN_HCD_SPEEDf_GET BCMI_TSC_XGXS_AN_ABIL_RESOLUTION_STATUSr_AN_HCD_SPEEDf_GET
#define AN_ABIL_RESOLUTION_STATUSr_AN_HCD_SPEEDf_SET BCMI_TSC_XGXS_AN_ABIL_RESOLUTION_STATUSr_AN_HCD_SPEEDf_SET
#define AN_ABIL_RESOLUTION_STATUSr_AN_HCD_FECf_GET BCMI_TSC_XGXS_AN_ABIL_RESOLUTION_STATUSr_AN_HCD_FECf_GET
#define AN_ABIL_RESOLUTION_STATUSr_AN_HCD_FECf_SET BCMI_TSC_XGXS_AN_ABIL_RESOLUTION_STATUSr_AN_HCD_FECf_SET
#define AN_ABIL_RESOLUTION_STATUSr_AN_HCD_CL72f_GET BCMI_TSC_XGXS_AN_ABIL_RESOLUTION_STATUSr_AN_HCD_CL72f_GET
#define AN_ABIL_RESOLUTION_STATUSr_AN_HCD_CL72f_SET BCMI_TSC_XGXS_AN_ABIL_RESOLUTION_STATUSr_AN_HCD_CL72f_SET
#define AN_ABIL_RESOLUTION_STATUSr_AN_HCD_HIGIG2f_GET BCMI_TSC_XGXS_AN_ABIL_RESOLUTION_STATUSr_AN_HCD_HIGIG2f_GET
#define AN_ABIL_RESOLUTION_STATUSr_AN_HCD_HIGIG2f_SET BCMI_TSC_XGXS_AN_ABIL_RESOLUTION_STATUSr_AN_HCD_HIGIG2f_SET
#define AN_ABIL_RESOLUTION_STATUSr_AN_HCD_SWITCH_TO_CL37f_GET BCMI_TSC_XGXS_AN_ABIL_RESOLUTION_STATUSr_AN_HCD_SWITCH_TO_CL37f_GET
#define AN_ABIL_RESOLUTION_STATUSr_AN_HCD_SWITCH_TO_CL37f_SET BCMI_TSC_XGXS_AN_ABIL_RESOLUTION_STATUSr_AN_HCD_SWITCH_TO_CL37f_SET
#define READ_AN_ABIL_RESOLUTION_STATUSr BCMI_TSC_XGXS_READ_AN_ABIL_RESOLUTION_STATUSr
#define WRITE_AN_ABIL_RESOLUTION_STATUSr BCMI_TSC_XGXS_WRITE_AN_ABIL_RESOLUTION_STATUSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_AN_ABIL_RESOLUTION_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  AN_MISC_STATUS
 * BLOCKS:   AN_X4_SW_MANAGEMENT
 * REGADDR:  0xc1ac
 * DESC:     MISCILLANEOUS AN STATUS: 00000000
 * SIZE:     32
 * FIELDS:
 *     PD_HCD_KX4_OR_KX 
 *     PD_IN_PROGRESS   
 *     AN_FAIL_COUNT    
 *     AN_ACTIVE        
 *     PD_COMPLETED     
 *     REMOTE_FAULT_IN_BASE_PAGE 
 *     AN_RETRY_COUNT   
 *     AN_COMPLETE      
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_AN_MISC_STATUSr (0x0000c1ac | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_AN_MISC_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program AN_MISC_STATUS.
 *
 */
typedef union BCMI_TSC_XGXS_AN_MISC_STATUSr_s {
	uint32_t v[1];
	uint32_t an_misc_status[1];
	uint32_t _an_misc_status;
} BCMI_TSC_XGXS_AN_MISC_STATUSr_t;

#define BCMI_TSC_XGXS_AN_MISC_STATUSr_CLR(r) (r).an_misc_status[0] = 0
#define BCMI_TSC_XGXS_AN_MISC_STATUSr_SET(r,d) (r).an_misc_status[0] = d
#define BCMI_TSC_XGXS_AN_MISC_STATUSr_GET(r) (r).an_misc_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_AN_MISC_STATUSr_AN_COMPLETEf_GET(r) ((((r).an_misc_status[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_AN_MISC_STATUSr_AN_COMPLETEf_SET(r,f) (r).an_misc_status[0]=(((r).an_misc_status[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_AN_MISC_STATUSr_AN_RETRY_COUNTf_GET(r) ((((r).an_misc_status[0]) >> 9) & 0x3f)
#define BCMI_TSC_XGXS_AN_MISC_STATUSr_AN_RETRY_COUNTf_SET(r,f) (r).an_misc_status[0]=(((r).an_misc_status[0] & ~((uint32_t)0x3f << 9)) | ((((uint32_t)f) & 0x3f) << 9))
#define BCMI_TSC_XGXS_AN_MISC_STATUSr_REMOTE_FAULT_IN_BASE_PAGEf_GET(r) ((((r).an_misc_status[0]) >> 8) & 0x1)
#define BCMI_TSC_XGXS_AN_MISC_STATUSr_REMOTE_FAULT_IN_BASE_PAGEf_SET(r,f) (r).an_misc_status[0]=(((r).an_misc_status[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCMI_TSC_XGXS_AN_MISC_STATUSr_PD_COMPLETEDf_GET(r) ((((r).an_misc_status[0]) >> 7) & 0x1)
#define BCMI_TSC_XGXS_AN_MISC_STATUSr_PD_COMPLETEDf_SET(r,f) (r).an_misc_status[0]=(((r).an_misc_status[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCMI_TSC_XGXS_AN_MISC_STATUSr_AN_ACTIVEf_GET(r) ((((r).an_misc_status[0]) >> 6) & 0x1)
#define BCMI_TSC_XGXS_AN_MISC_STATUSr_AN_ACTIVEf_SET(r,f) (r).an_misc_status[0]=(((r).an_misc_status[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCMI_TSC_XGXS_AN_MISC_STATUSr_AN_FAIL_COUNTf_GET(r) ((((r).an_misc_status[0]) >> 2) & 0xf)
#define BCMI_TSC_XGXS_AN_MISC_STATUSr_AN_FAIL_COUNTf_SET(r,f) (r).an_misc_status[0]=(((r).an_misc_status[0] & ~((uint32_t)0xf << 2)) | ((((uint32_t)f) & 0xf) << 2))
#define BCMI_TSC_XGXS_AN_MISC_STATUSr_PD_IN_PROGRESSf_GET(r) ((((r).an_misc_status[0]) >> 1) & 0x1)
#define BCMI_TSC_XGXS_AN_MISC_STATUSr_PD_IN_PROGRESSf_SET(r,f) (r).an_misc_status[0]=(((r).an_misc_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCMI_TSC_XGXS_AN_MISC_STATUSr_PD_HCD_KX4_OR_KXf_GET(r) (((r).an_misc_status[0]) & 0x1)
#define BCMI_TSC_XGXS_AN_MISC_STATUSr_PD_HCD_KX4_OR_KXf_SET(r,f) (r).an_misc_status[0]=(((r).an_misc_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access AN_MISC_STATUS.
 *
 */
#define BCMI_TSC_XGXS_READ_AN_MISC_STATUSr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_AN_MISC_STATUSr,(_r._an_misc_status))
#define BCMI_TSC_XGXS_WRITE_AN_MISC_STATUSr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_AN_MISC_STATUSr,(_r._an_misc_status))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_MISC_STATUSr BCMI_TSC_XGXS_AN_MISC_STATUSr
#define AN_MISC_STATUSr_SIZE BCMI_TSC_XGXS_AN_MISC_STATUSr_SIZE
typedef BCMI_TSC_XGXS_AN_MISC_STATUSr_t AN_MISC_STATUSr_t;
#define AN_MISC_STATUSr_CLR BCMI_TSC_XGXS_AN_MISC_STATUSr_CLR
#define AN_MISC_STATUSr_SET BCMI_TSC_XGXS_AN_MISC_STATUSr_SET
#define AN_MISC_STATUSr_GET BCMI_TSC_XGXS_AN_MISC_STATUSr_GET
#define AN_MISC_STATUSr_AN_COMPLETEf_GET BCMI_TSC_XGXS_AN_MISC_STATUSr_AN_COMPLETEf_GET
#define AN_MISC_STATUSr_AN_COMPLETEf_SET BCMI_TSC_XGXS_AN_MISC_STATUSr_AN_COMPLETEf_SET
#define AN_MISC_STATUSr_AN_RETRY_COUNTf_GET BCMI_TSC_XGXS_AN_MISC_STATUSr_AN_RETRY_COUNTf_GET
#define AN_MISC_STATUSr_AN_RETRY_COUNTf_SET BCMI_TSC_XGXS_AN_MISC_STATUSr_AN_RETRY_COUNTf_SET
#define AN_MISC_STATUSr_REMOTE_FAULT_IN_BASE_PAGEf_GET BCMI_TSC_XGXS_AN_MISC_STATUSr_REMOTE_FAULT_IN_BASE_PAGEf_GET
#define AN_MISC_STATUSr_REMOTE_FAULT_IN_BASE_PAGEf_SET BCMI_TSC_XGXS_AN_MISC_STATUSr_REMOTE_FAULT_IN_BASE_PAGEf_SET
#define AN_MISC_STATUSr_PD_COMPLETEDf_GET BCMI_TSC_XGXS_AN_MISC_STATUSr_PD_COMPLETEDf_GET
#define AN_MISC_STATUSr_PD_COMPLETEDf_SET BCMI_TSC_XGXS_AN_MISC_STATUSr_PD_COMPLETEDf_SET
#define AN_MISC_STATUSr_AN_ACTIVEf_GET BCMI_TSC_XGXS_AN_MISC_STATUSr_AN_ACTIVEf_GET
#define AN_MISC_STATUSr_AN_ACTIVEf_SET BCMI_TSC_XGXS_AN_MISC_STATUSr_AN_ACTIVEf_SET
#define AN_MISC_STATUSr_AN_FAIL_COUNTf_GET BCMI_TSC_XGXS_AN_MISC_STATUSr_AN_FAIL_COUNTf_GET
#define AN_MISC_STATUSr_AN_FAIL_COUNTf_SET BCMI_TSC_XGXS_AN_MISC_STATUSr_AN_FAIL_COUNTf_SET
#define AN_MISC_STATUSr_PD_IN_PROGRESSf_GET BCMI_TSC_XGXS_AN_MISC_STATUSr_PD_IN_PROGRESSf_GET
#define AN_MISC_STATUSr_PD_IN_PROGRESSf_SET BCMI_TSC_XGXS_AN_MISC_STATUSr_PD_IN_PROGRESSf_SET
#define AN_MISC_STATUSr_PD_HCD_KX4_OR_KXf_GET BCMI_TSC_XGXS_AN_MISC_STATUSr_PD_HCD_KX4_OR_KXf_GET
#define AN_MISC_STATUSr_PD_HCD_KX4_OR_KXf_SET BCMI_TSC_XGXS_AN_MISC_STATUSr_PD_HCD_KX4_OR_KXf_SET
#define READ_AN_MISC_STATUSr BCMI_TSC_XGXS_READ_AN_MISC_STATUSr
#define WRITE_AN_MISC_STATUSr BCMI_TSC_XGXS_WRITE_AN_MISC_STATUSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_AN_MISC_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  TLA_SEQUENCER_STATUS
 * BLOCKS:   AN_X4_SW_MANAGEMENT
 * REGADDR:  0xc1ad
 * DESC:     TLA SEQUENCER STATUS: 00000000
 * SIZE:     32
 * FIELDS:
 *     TLA_LN_SEQUENCER_FSM_STATUS 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_TLA_SEQUENCER_STATUSr (0x0000c1ad | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_TLA_SEQUENCER_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program TLA_SEQUENCER_STATUS.
 *
 */
typedef union BCMI_TSC_XGXS_TLA_SEQUENCER_STATUSr_s {
	uint32_t v[1];
	uint32_t tla_sequencer_status[1];
	uint32_t _tla_sequencer_status;
} BCMI_TSC_XGXS_TLA_SEQUENCER_STATUSr_t;

#define BCMI_TSC_XGXS_TLA_SEQUENCER_STATUSr_CLR(r) (r).tla_sequencer_status[0] = 0
#define BCMI_TSC_XGXS_TLA_SEQUENCER_STATUSr_SET(r,d) (r).tla_sequencer_status[0] = d
#define BCMI_TSC_XGXS_TLA_SEQUENCER_STATUSr_GET(r) (r).tla_sequencer_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_TLA_SEQUENCER_STATUSr_RESERVED0f_GET(r) ((((r).tla_sequencer_status[0]) >> 11) & 0x1f)
#define BCMI_TSC_XGXS_TLA_SEQUENCER_STATUSr_RESERVED0f_SET(r,f) (r).tla_sequencer_status[0]=(((r).tla_sequencer_status[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))
#define BCMI_TSC_XGXS_TLA_SEQUENCER_STATUSr_TLA_LN_SEQUENCER_FSM_STATUSf_GET(r) (((r).tla_sequencer_status[0]) & 0x7ff)
#define BCMI_TSC_XGXS_TLA_SEQUENCER_STATUSr_TLA_LN_SEQUENCER_FSM_STATUSf_SET(r,f) (r).tla_sequencer_status[0]=(((r).tla_sequencer_status[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))

/*
 * These macros can be used to access TLA_SEQUENCER_STATUS.
 *
 */
#define BCMI_TSC_XGXS_READ_TLA_SEQUENCER_STATUSr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_TLA_SEQUENCER_STATUSr,(_r._tla_sequencer_status))
#define BCMI_TSC_XGXS_WRITE_TLA_SEQUENCER_STATUSr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_TLA_SEQUENCER_STATUSr,(_r._tla_sequencer_status))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TLA_SEQUENCER_STATUSr BCMI_TSC_XGXS_TLA_SEQUENCER_STATUSr
#define TLA_SEQUENCER_STATUSr_SIZE BCMI_TSC_XGXS_TLA_SEQUENCER_STATUSr_SIZE
typedef BCMI_TSC_XGXS_TLA_SEQUENCER_STATUSr_t TLA_SEQUENCER_STATUSr_t;
#define TLA_SEQUENCER_STATUSr_CLR BCMI_TSC_XGXS_TLA_SEQUENCER_STATUSr_CLR
#define TLA_SEQUENCER_STATUSr_SET BCMI_TSC_XGXS_TLA_SEQUENCER_STATUSr_SET
#define TLA_SEQUENCER_STATUSr_GET BCMI_TSC_XGXS_TLA_SEQUENCER_STATUSr_GET
#define TLA_SEQUENCER_STATUSr_RESERVED0f_GET BCMI_TSC_XGXS_TLA_SEQUENCER_STATUSr_RESERVED0f_GET
#define TLA_SEQUENCER_STATUSr_RESERVED0f_SET BCMI_TSC_XGXS_TLA_SEQUENCER_STATUSr_RESERVED0f_SET
#define TLA_SEQUENCER_STATUSr_TLA_LN_SEQUENCER_FSM_STATUSf_GET BCMI_TSC_XGXS_TLA_SEQUENCER_STATUSr_TLA_LN_SEQUENCER_FSM_STATUSf_GET
#define TLA_SEQUENCER_STATUSr_TLA_LN_SEQUENCER_FSM_STATUSf_SET BCMI_TSC_XGXS_TLA_SEQUENCER_STATUSr_TLA_LN_SEQUENCER_FSM_STATUSf_SET
#define READ_TLA_SEQUENCER_STATUSr BCMI_TSC_XGXS_READ_TLA_SEQUENCER_STATUSr
#define WRITE_TLA_SEQUENCER_STATUSr BCMI_TSC_XGXS_WRITE_TLA_SEQUENCER_STATUSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_TLA_SEQUENCER_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  AN_SEQ_UNEXPECTED_PAGE
 * BLOCKS:   AN_X4_SW_MANAGEMENT
 * REGADDR:  0xc1ae
 * DESC:     AN SEQUENCER UNEXPECTED PAGE: 00000000
 * SIZE:     32
 * FIELDS:
 *     SEQ_UNEXPECTED_PAGE 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_AN_SEQ_UNEXPECTED_PAGEr (0x0000c1ae | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_AN_SEQ_UNEXPECTED_PAGEr_SIZE 4

/*
 * This structure should be used to declare and program AN_SEQ_UNEXPECTED_PAGE.
 *
 */
typedef union BCMI_TSC_XGXS_AN_SEQ_UNEXPECTED_PAGEr_s {
	uint32_t v[1];
	uint32_t an_seq_unexpected_page[1];
	uint32_t _an_seq_unexpected_page;
} BCMI_TSC_XGXS_AN_SEQ_UNEXPECTED_PAGEr_t;

#define BCMI_TSC_XGXS_AN_SEQ_UNEXPECTED_PAGEr_CLR(r) (r).an_seq_unexpected_page[0] = 0
#define BCMI_TSC_XGXS_AN_SEQ_UNEXPECTED_PAGEr_SET(r,d) (r).an_seq_unexpected_page[0] = d
#define BCMI_TSC_XGXS_AN_SEQ_UNEXPECTED_PAGEr_GET(r) (r).an_seq_unexpected_page[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_AN_SEQ_UNEXPECTED_PAGEr_SEQ_UNEXPECTED_PAGEf_GET(r) (((r).an_seq_unexpected_page[0]) & 0xffff)
#define BCMI_TSC_XGXS_AN_SEQ_UNEXPECTED_PAGEr_SEQ_UNEXPECTED_PAGEf_SET(r,f) (r).an_seq_unexpected_page[0]=(((r).an_seq_unexpected_page[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access AN_SEQ_UNEXPECTED_PAGE.
 *
 */
#define BCMI_TSC_XGXS_READ_AN_SEQ_UNEXPECTED_PAGEr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_AN_SEQ_UNEXPECTED_PAGEr,(_r._an_seq_unexpected_page))
#define BCMI_TSC_XGXS_WRITE_AN_SEQ_UNEXPECTED_PAGEr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_AN_SEQ_UNEXPECTED_PAGEr,(_r._an_seq_unexpected_page))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_SEQ_UNEXPECTED_PAGEr BCMI_TSC_XGXS_AN_SEQ_UNEXPECTED_PAGEr
#define AN_SEQ_UNEXPECTED_PAGEr_SIZE BCMI_TSC_XGXS_AN_SEQ_UNEXPECTED_PAGEr_SIZE
typedef BCMI_TSC_XGXS_AN_SEQ_UNEXPECTED_PAGEr_t AN_SEQ_UNEXPECTED_PAGEr_t;
#define AN_SEQ_UNEXPECTED_PAGEr_CLR BCMI_TSC_XGXS_AN_SEQ_UNEXPECTED_PAGEr_CLR
#define AN_SEQ_UNEXPECTED_PAGEr_SET BCMI_TSC_XGXS_AN_SEQ_UNEXPECTED_PAGEr_SET
#define AN_SEQ_UNEXPECTED_PAGEr_GET BCMI_TSC_XGXS_AN_SEQ_UNEXPECTED_PAGEr_GET
#define AN_SEQ_UNEXPECTED_PAGEr_SEQ_UNEXPECTED_PAGEf_GET BCMI_TSC_XGXS_AN_SEQ_UNEXPECTED_PAGEr_SEQ_UNEXPECTED_PAGEf_GET
#define AN_SEQ_UNEXPECTED_PAGEr_SEQ_UNEXPECTED_PAGEf_SET BCMI_TSC_XGXS_AN_SEQ_UNEXPECTED_PAGEr_SEQ_UNEXPECTED_PAGEf_SET
#define READ_AN_SEQ_UNEXPECTED_PAGEr BCMI_TSC_XGXS_READ_AN_SEQ_UNEXPECTED_PAGEr
#define WRITE_AN_SEQ_UNEXPECTED_PAGEr BCMI_TSC_XGXS_WRITE_AN_SEQ_UNEXPECTED_PAGEr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_AN_SEQ_UNEXPECTED_PAGEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CDR_CTRL0
 * BLOCKS:   DSC1B0
 * REGADDR:  0xc200
 * DESC:     CDR Control 0 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     CDR_FREQ_OVERRIDE_EN 
 *     CDR_FREQ_EN      
 *     CDR_FREQ_UPD_EN  
 *     CDR_INTEG_REG_CLR 
 *     CDR_PHASE_ERR_FRZ 
 *     CDROS_ZERO_POLARITY 
 *     CDROS_PEAK_POLARITY 
 *     CDROS_PHASE_SAT_CTRL 
 *     CDROS_FALLING_EDGE 
 *     CDROS_RISING_EDGE 
 *     CDRBR_THIRD_VEC_EN 
 *     CDRBR_POLARITY   
 *     CDRBR_P1_SLICER_ONLY 
 *     CDRBR_M1_SLICER_ONLY 
 *     CDROS_XFI_INTEG_SAT_SEL 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CDR_CTRL0r (0x0000c200 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CDR_CTRL0r_SIZE 4

/*
 * This structure should be used to declare and program CDR_CTRL0.
 *
 */
typedef union BCMI_TSC_XGXS_CDR_CTRL0r_s {
	uint32_t v[1];
	uint32_t cdr_ctrl0[1];
	uint32_t _cdr_ctrl0;
} BCMI_TSC_XGXS_CDR_CTRL0r_t;

#define BCMI_TSC_XGXS_CDR_CTRL0r_CLR(r) (r).cdr_ctrl0[0] = 0
#define BCMI_TSC_XGXS_CDR_CTRL0r_SET(r,d) (r).cdr_ctrl0[0] = d
#define BCMI_TSC_XGXS_CDR_CTRL0r_GET(r) (r).cdr_ctrl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CDR_CTRL0r_CDROS_XFI_INTEG_SAT_SELf_GET(r) ((((r).cdr_ctrl0[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_CDR_CTRL0r_CDROS_XFI_INTEG_SAT_SELf_SET(r,f) (r).cdr_ctrl0[0]=(((r).cdr_ctrl0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_CDR_CTRL0r_CDRBR_M1_SLICER_ONLYf_GET(r) ((((r).cdr_ctrl0[0]) >> 14) & 0x1)
#define BCMI_TSC_XGXS_CDR_CTRL0r_CDRBR_M1_SLICER_ONLYf_SET(r,f) (r).cdr_ctrl0[0]=(((r).cdr_ctrl0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCMI_TSC_XGXS_CDR_CTRL0r_CDRBR_P1_SLICER_ONLYf_GET(r) ((((r).cdr_ctrl0[0]) >> 13) & 0x1)
#define BCMI_TSC_XGXS_CDR_CTRL0r_CDRBR_P1_SLICER_ONLYf_SET(r,f) (r).cdr_ctrl0[0]=(((r).cdr_ctrl0[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCMI_TSC_XGXS_CDR_CTRL0r_CDRBR_POLARITYf_GET(r) ((((r).cdr_ctrl0[0]) >> 12) & 0x1)
#define BCMI_TSC_XGXS_CDR_CTRL0r_CDRBR_POLARITYf_SET(r,f) (r).cdr_ctrl0[0]=(((r).cdr_ctrl0[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCMI_TSC_XGXS_CDR_CTRL0r_CDRBR_THIRD_VEC_ENf_GET(r) ((((r).cdr_ctrl0[0]) >> 11) & 0x1)
#define BCMI_TSC_XGXS_CDR_CTRL0r_CDRBR_THIRD_VEC_ENf_SET(r,f) (r).cdr_ctrl0[0]=(((r).cdr_ctrl0[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCMI_TSC_XGXS_CDR_CTRL0r_CDROS_RISING_EDGEf_GET(r) ((((r).cdr_ctrl0[0]) >> 10) & 0x1)
#define BCMI_TSC_XGXS_CDR_CTRL0r_CDROS_RISING_EDGEf_SET(r,f) (r).cdr_ctrl0[0]=(((r).cdr_ctrl0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCMI_TSC_XGXS_CDR_CTRL0r_CDROS_FALLING_EDGEf_GET(r) ((((r).cdr_ctrl0[0]) >> 9) & 0x1)
#define BCMI_TSC_XGXS_CDR_CTRL0r_CDROS_FALLING_EDGEf_SET(r,f) (r).cdr_ctrl0[0]=(((r).cdr_ctrl0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCMI_TSC_XGXS_CDR_CTRL0r_CDROS_PHASE_SAT_CTRLf_GET(r) ((((r).cdr_ctrl0[0]) >> 7) & 0x3)
#define BCMI_TSC_XGXS_CDR_CTRL0r_CDROS_PHASE_SAT_CTRLf_SET(r,f) (r).cdr_ctrl0[0]=(((r).cdr_ctrl0[0] & ~((uint32_t)0x3 << 7)) | ((((uint32_t)f) & 0x3) << 7))
#define BCMI_TSC_XGXS_CDR_CTRL0r_CDROS_PEAK_POLARITYf_GET(r) ((((r).cdr_ctrl0[0]) >> 6) & 0x1)
#define BCMI_TSC_XGXS_CDR_CTRL0r_CDROS_PEAK_POLARITYf_SET(r,f) (r).cdr_ctrl0[0]=(((r).cdr_ctrl0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCMI_TSC_XGXS_CDR_CTRL0r_CDROS_ZERO_POLARITYf_GET(r) ((((r).cdr_ctrl0[0]) >> 5) & 0x1)
#define BCMI_TSC_XGXS_CDR_CTRL0r_CDROS_ZERO_POLARITYf_SET(r,f) (r).cdr_ctrl0[0]=(((r).cdr_ctrl0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCMI_TSC_XGXS_CDR_CTRL0r_CDR_PHASE_ERR_FRZf_GET(r) ((((r).cdr_ctrl0[0]) >> 4) & 0x1)
#define BCMI_TSC_XGXS_CDR_CTRL0r_CDR_PHASE_ERR_FRZf_SET(r,f) (r).cdr_ctrl0[0]=(((r).cdr_ctrl0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCMI_TSC_XGXS_CDR_CTRL0r_CDR_INTEG_REG_CLRf_GET(r) ((((r).cdr_ctrl0[0]) >> 3) & 0x1)
#define BCMI_TSC_XGXS_CDR_CTRL0r_CDR_INTEG_REG_CLRf_SET(r,f) (r).cdr_ctrl0[0]=(((r).cdr_ctrl0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCMI_TSC_XGXS_CDR_CTRL0r_CDR_FREQ_UPD_ENf_GET(r) ((((r).cdr_ctrl0[0]) >> 2) & 0x1)
#define BCMI_TSC_XGXS_CDR_CTRL0r_CDR_FREQ_UPD_ENf_SET(r,f) (r).cdr_ctrl0[0]=(((r).cdr_ctrl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCMI_TSC_XGXS_CDR_CTRL0r_CDR_FREQ_ENf_GET(r) ((((r).cdr_ctrl0[0]) >> 1) & 0x1)
#define BCMI_TSC_XGXS_CDR_CTRL0r_CDR_FREQ_ENf_SET(r,f) (r).cdr_ctrl0[0]=(((r).cdr_ctrl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCMI_TSC_XGXS_CDR_CTRL0r_CDR_FREQ_OVERRIDE_ENf_GET(r) (((r).cdr_ctrl0[0]) & 0x1)
#define BCMI_TSC_XGXS_CDR_CTRL0r_CDR_FREQ_OVERRIDE_ENf_SET(r,f) (r).cdr_ctrl0[0]=(((r).cdr_ctrl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access CDR_CTRL0.
 *
 */
#define BCMI_TSC_XGXS_READ_CDR_CTRL0r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CDR_CTRL0r,(_r._cdr_ctrl0))
#define BCMI_TSC_XGXS_WRITE_CDR_CTRL0r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CDR_CTRL0r,(_r._cdr_ctrl0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CDR_CTRL0r BCMI_TSC_XGXS_CDR_CTRL0r
#define CDR_CTRL0r_SIZE BCMI_TSC_XGXS_CDR_CTRL0r_SIZE
typedef BCMI_TSC_XGXS_CDR_CTRL0r_t CDR_CTRL0r_t;
#define CDR_CTRL0r_CLR BCMI_TSC_XGXS_CDR_CTRL0r_CLR
#define CDR_CTRL0r_SET BCMI_TSC_XGXS_CDR_CTRL0r_SET
#define CDR_CTRL0r_GET BCMI_TSC_XGXS_CDR_CTRL0r_GET
#define CDR_CTRL0r_CDROS_XFI_INTEG_SAT_SELf_GET BCMI_TSC_XGXS_CDR_CTRL0r_CDROS_XFI_INTEG_SAT_SELf_GET
#define CDR_CTRL0r_CDROS_XFI_INTEG_SAT_SELf_SET BCMI_TSC_XGXS_CDR_CTRL0r_CDROS_XFI_INTEG_SAT_SELf_SET
#define CDR_CTRL0r_CDRBR_M1_SLICER_ONLYf_GET BCMI_TSC_XGXS_CDR_CTRL0r_CDRBR_M1_SLICER_ONLYf_GET
#define CDR_CTRL0r_CDRBR_M1_SLICER_ONLYf_SET BCMI_TSC_XGXS_CDR_CTRL0r_CDRBR_M1_SLICER_ONLYf_SET
#define CDR_CTRL0r_CDRBR_P1_SLICER_ONLYf_GET BCMI_TSC_XGXS_CDR_CTRL0r_CDRBR_P1_SLICER_ONLYf_GET
#define CDR_CTRL0r_CDRBR_P1_SLICER_ONLYf_SET BCMI_TSC_XGXS_CDR_CTRL0r_CDRBR_P1_SLICER_ONLYf_SET
#define CDR_CTRL0r_CDRBR_POLARITYf_GET BCMI_TSC_XGXS_CDR_CTRL0r_CDRBR_POLARITYf_GET
#define CDR_CTRL0r_CDRBR_POLARITYf_SET BCMI_TSC_XGXS_CDR_CTRL0r_CDRBR_POLARITYf_SET
#define CDR_CTRL0r_CDRBR_THIRD_VEC_ENf_GET BCMI_TSC_XGXS_CDR_CTRL0r_CDRBR_THIRD_VEC_ENf_GET
#define CDR_CTRL0r_CDRBR_THIRD_VEC_ENf_SET BCMI_TSC_XGXS_CDR_CTRL0r_CDRBR_THIRD_VEC_ENf_SET
#define CDR_CTRL0r_CDROS_RISING_EDGEf_GET BCMI_TSC_XGXS_CDR_CTRL0r_CDROS_RISING_EDGEf_GET
#define CDR_CTRL0r_CDROS_RISING_EDGEf_SET BCMI_TSC_XGXS_CDR_CTRL0r_CDROS_RISING_EDGEf_SET
#define CDR_CTRL0r_CDROS_FALLING_EDGEf_GET BCMI_TSC_XGXS_CDR_CTRL0r_CDROS_FALLING_EDGEf_GET
#define CDR_CTRL0r_CDROS_FALLING_EDGEf_SET BCMI_TSC_XGXS_CDR_CTRL0r_CDROS_FALLING_EDGEf_SET
#define CDR_CTRL0r_CDROS_PHASE_SAT_CTRLf_GET BCMI_TSC_XGXS_CDR_CTRL0r_CDROS_PHASE_SAT_CTRLf_GET
#define CDR_CTRL0r_CDROS_PHASE_SAT_CTRLf_SET BCMI_TSC_XGXS_CDR_CTRL0r_CDROS_PHASE_SAT_CTRLf_SET
#define CDR_CTRL0r_CDROS_PEAK_POLARITYf_GET BCMI_TSC_XGXS_CDR_CTRL0r_CDROS_PEAK_POLARITYf_GET
#define CDR_CTRL0r_CDROS_PEAK_POLARITYf_SET BCMI_TSC_XGXS_CDR_CTRL0r_CDROS_PEAK_POLARITYf_SET
#define CDR_CTRL0r_CDROS_ZERO_POLARITYf_GET BCMI_TSC_XGXS_CDR_CTRL0r_CDROS_ZERO_POLARITYf_GET
#define CDR_CTRL0r_CDROS_ZERO_POLARITYf_SET BCMI_TSC_XGXS_CDR_CTRL0r_CDROS_ZERO_POLARITYf_SET
#define CDR_CTRL0r_CDR_PHASE_ERR_FRZf_GET BCMI_TSC_XGXS_CDR_CTRL0r_CDR_PHASE_ERR_FRZf_GET
#define CDR_CTRL0r_CDR_PHASE_ERR_FRZf_SET BCMI_TSC_XGXS_CDR_CTRL0r_CDR_PHASE_ERR_FRZf_SET
#define CDR_CTRL0r_CDR_INTEG_REG_CLRf_GET BCMI_TSC_XGXS_CDR_CTRL0r_CDR_INTEG_REG_CLRf_GET
#define CDR_CTRL0r_CDR_INTEG_REG_CLRf_SET BCMI_TSC_XGXS_CDR_CTRL0r_CDR_INTEG_REG_CLRf_SET
#define CDR_CTRL0r_CDR_FREQ_UPD_ENf_GET BCMI_TSC_XGXS_CDR_CTRL0r_CDR_FREQ_UPD_ENf_GET
#define CDR_CTRL0r_CDR_FREQ_UPD_ENf_SET BCMI_TSC_XGXS_CDR_CTRL0r_CDR_FREQ_UPD_ENf_SET
#define CDR_CTRL0r_CDR_FREQ_ENf_GET BCMI_TSC_XGXS_CDR_CTRL0r_CDR_FREQ_ENf_GET
#define CDR_CTRL0r_CDR_FREQ_ENf_SET BCMI_TSC_XGXS_CDR_CTRL0r_CDR_FREQ_ENf_SET
#define CDR_CTRL0r_CDR_FREQ_OVERRIDE_ENf_GET BCMI_TSC_XGXS_CDR_CTRL0r_CDR_FREQ_OVERRIDE_ENf_GET
#define CDR_CTRL0r_CDR_FREQ_OVERRIDE_ENf_SET BCMI_TSC_XGXS_CDR_CTRL0r_CDR_FREQ_OVERRIDE_ENf_SET
#define READ_CDR_CTRL0r BCMI_TSC_XGXS_READ_CDR_CTRL0r
#define WRITE_CDR_CTRL0r BCMI_TSC_XGXS_WRITE_CDR_CTRL0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CDR_CTRL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CDR_CTRL1
 * BLOCKS:   DSC1B0
 * REGADDR:  0xc201
 * DESC:     CDR Control 1 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     CDR_FREQ_OVERRIDE_VAL 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CDR_CTRL1r (0x0000c201 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CDR_CTRL1r_SIZE 4

/*
 * This structure should be used to declare and program CDR_CTRL1.
 *
 */
typedef union BCMI_TSC_XGXS_CDR_CTRL1r_s {
	uint32_t v[1];
	uint32_t cdr_ctrl1[1];
	uint32_t _cdr_ctrl1;
} BCMI_TSC_XGXS_CDR_CTRL1r_t;

#define BCMI_TSC_XGXS_CDR_CTRL1r_CLR(r) (r).cdr_ctrl1[0] = 0
#define BCMI_TSC_XGXS_CDR_CTRL1r_SET(r,d) (r).cdr_ctrl1[0] = d
#define BCMI_TSC_XGXS_CDR_CTRL1r_GET(r) (r).cdr_ctrl1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CDR_CTRL1r_CDR_FREQ_OVERRIDE_VALf_GET(r) (((r).cdr_ctrl1[0]) & 0xffff)
#define BCMI_TSC_XGXS_CDR_CTRL1r_CDR_FREQ_OVERRIDE_VALf_SET(r,f) (r).cdr_ctrl1[0]=(((r).cdr_ctrl1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access CDR_CTRL1.
 *
 */
#define BCMI_TSC_XGXS_READ_CDR_CTRL1r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CDR_CTRL1r,(_r._cdr_ctrl1))
#define BCMI_TSC_XGXS_WRITE_CDR_CTRL1r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CDR_CTRL1r,(_r._cdr_ctrl1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CDR_CTRL1r BCMI_TSC_XGXS_CDR_CTRL1r
#define CDR_CTRL1r_SIZE BCMI_TSC_XGXS_CDR_CTRL1r_SIZE
typedef BCMI_TSC_XGXS_CDR_CTRL1r_t CDR_CTRL1r_t;
#define CDR_CTRL1r_CLR BCMI_TSC_XGXS_CDR_CTRL1r_CLR
#define CDR_CTRL1r_SET BCMI_TSC_XGXS_CDR_CTRL1r_SET
#define CDR_CTRL1r_GET BCMI_TSC_XGXS_CDR_CTRL1r_GET
#define CDR_CTRL1r_CDR_FREQ_OVERRIDE_VALf_GET BCMI_TSC_XGXS_CDR_CTRL1r_CDR_FREQ_OVERRIDE_VALf_GET
#define CDR_CTRL1r_CDR_FREQ_OVERRIDE_VALf_SET BCMI_TSC_XGXS_CDR_CTRL1r_CDR_FREQ_OVERRIDE_VALf_SET
#define READ_CDR_CTRL1r BCMI_TSC_XGXS_READ_CDR_CTRL1r
#define WRITE_CDR_CTRL1r BCMI_TSC_XGXS_WRITE_CDR_CTRL1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CDR_CTRL1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CDR_CTRL2
 * BLOCKS:   DSC1B0
 * REGADDR:  0xc202
 * DESC:     CDR Control 2 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     CDRBR_PHASE_ERR_OFFSET 
 *     CDROS_PHASE_ERR_OFFSET 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CDR_CTRL2r (0x0000c202 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CDR_CTRL2r_SIZE 4

/*
 * This structure should be used to declare and program CDR_CTRL2.
 *
 */
typedef union BCMI_TSC_XGXS_CDR_CTRL2r_s {
	uint32_t v[1];
	uint32_t cdr_ctrl2[1];
	uint32_t _cdr_ctrl2;
} BCMI_TSC_XGXS_CDR_CTRL2r_t;

#define BCMI_TSC_XGXS_CDR_CTRL2r_CLR(r) (r).cdr_ctrl2[0] = 0
#define BCMI_TSC_XGXS_CDR_CTRL2r_SET(r,d) (r).cdr_ctrl2[0] = d
#define BCMI_TSC_XGXS_CDR_CTRL2r_GET(r) (r).cdr_ctrl2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CDR_CTRL2r_RESERVED0f_GET(r) ((((r).cdr_ctrl2[0]) >> 10) & 0x3f)
#define BCMI_TSC_XGXS_CDR_CTRL2r_RESERVED0f_SET(r,f) (r).cdr_ctrl2[0]=(((r).cdr_ctrl2[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))
#define BCMI_TSC_XGXS_CDR_CTRL2r_CDROS_PHASE_ERR_OFFSETf_GET(r) ((((r).cdr_ctrl2[0]) >> 6) & 0xf)
#define BCMI_TSC_XGXS_CDR_CTRL2r_CDROS_PHASE_ERR_OFFSETf_SET(r,f) (r).cdr_ctrl2[0]=(((r).cdr_ctrl2[0] & ~((uint32_t)0xf << 6)) | ((((uint32_t)f) & 0xf) << 6))
#define BCMI_TSC_XGXS_CDR_CTRL2r_CDRBR_PHASE_ERR_OFFSETf_GET(r) (((r).cdr_ctrl2[0]) & 0x3f)
#define BCMI_TSC_XGXS_CDR_CTRL2r_CDRBR_PHASE_ERR_OFFSETf_SET(r,f) (r).cdr_ctrl2[0]=(((r).cdr_ctrl2[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))

/*
 * These macros can be used to access CDR_CTRL2.
 *
 */
#define BCMI_TSC_XGXS_READ_CDR_CTRL2r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CDR_CTRL2r,(_r._cdr_ctrl2))
#define BCMI_TSC_XGXS_WRITE_CDR_CTRL2r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CDR_CTRL2r,(_r._cdr_ctrl2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CDR_CTRL2r BCMI_TSC_XGXS_CDR_CTRL2r
#define CDR_CTRL2r_SIZE BCMI_TSC_XGXS_CDR_CTRL2r_SIZE
typedef BCMI_TSC_XGXS_CDR_CTRL2r_t CDR_CTRL2r_t;
#define CDR_CTRL2r_CLR BCMI_TSC_XGXS_CDR_CTRL2r_CLR
#define CDR_CTRL2r_SET BCMI_TSC_XGXS_CDR_CTRL2r_SET
#define CDR_CTRL2r_GET BCMI_TSC_XGXS_CDR_CTRL2r_GET
#define CDR_CTRL2r_RESERVED0f_GET BCMI_TSC_XGXS_CDR_CTRL2r_RESERVED0f_GET
#define CDR_CTRL2r_RESERVED0f_SET BCMI_TSC_XGXS_CDR_CTRL2r_RESERVED0f_SET
#define CDR_CTRL2r_CDROS_PHASE_ERR_OFFSETf_GET BCMI_TSC_XGXS_CDR_CTRL2r_CDROS_PHASE_ERR_OFFSETf_GET
#define CDR_CTRL2r_CDROS_PHASE_ERR_OFFSETf_SET BCMI_TSC_XGXS_CDR_CTRL2r_CDROS_PHASE_ERR_OFFSETf_SET
#define CDR_CTRL2r_CDRBR_PHASE_ERR_OFFSETf_GET BCMI_TSC_XGXS_CDR_CTRL2r_CDRBR_PHASE_ERR_OFFSETf_GET
#define CDR_CTRL2r_CDRBR_PHASE_ERR_OFFSETf_SET BCMI_TSC_XGXS_CDR_CTRL2r_CDRBR_PHASE_ERR_OFFSETf_SET
#define READ_CDR_CTRL2r BCMI_TSC_XGXS_READ_CDR_CTRL2r
#define WRITE_CDR_CTRL2r BCMI_TSC_XGXS_WRITE_CDR_CTRL2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CDR_CTRL2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  PI_CTRL0
 * BLOCKS:   DSC1B0
 * REGADDR:  0xc203
 * DESC:     Phase Interpolator Control 0 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     PI_PHASE_STEP_MULT 
 *     PI_PHASE_INVERT  
 *     RESERVED0        
 *     INTERP_CTRL_CAP  
 *     INTERP_CTRL_DSEL 
 *     PI_CW_RST        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_PI_CTRL0r (0x0000c203 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_PI_CTRL0r_SIZE 4

/*
 * This structure should be used to declare and program PI_CTRL0.
 *
 */
typedef union BCMI_TSC_XGXS_PI_CTRL0r_s {
	uint32_t v[1];
	uint32_t pi_ctrl0[1];
	uint32_t _pi_ctrl0;
} BCMI_TSC_XGXS_PI_CTRL0r_t;

#define BCMI_TSC_XGXS_PI_CTRL0r_CLR(r) (r).pi_ctrl0[0] = 0
#define BCMI_TSC_XGXS_PI_CTRL0r_SET(r,d) (r).pi_ctrl0[0] = d
#define BCMI_TSC_XGXS_PI_CTRL0r_GET(r) (r).pi_ctrl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_PI_CTRL0r_PI_CW_RSTf_GET(r) ((((r).pi_ctrl0[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_PI_CTRL0r_PI_CW_RSTf_SET(r,f) (r).pi_ctrl0[0]=(((r).pi_ctrl0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_PI_CTRL0r_INTERP_CTRL_DSELf_GET(r) ((((r).pi_ctrl0[0]) >> 12) & 0x7)
#define BCMI_TSC_XGXS_PI_CTRL0r_INTERP_CTRL_DSELf_SET(r,f) (r).pi_ctrl0[0]=(((r).pi_ctrl0[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCMI_TSC_XGXS_PI_CTRL0r_INTERP_CTRL_CAPf_GET(r) ((((r).pi_ctrl0[0]) >> 11) & 0x1)
#define BCMI_TSC_XGXS_PI_CTRL0r_INTERP_CTRL_CAPf_SET(r,f) (r).pi_ctrl0[0]=(((r).pi_ctrl0[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCMI_TSC_XGXS_PI_CTRL0r_RESERVED0f_GET(r) ((((r).pi_ctrl0[0]) >> 2) & 0x1ff)
#define BCMI_TSC_XGXS_PI_CTRL0r_RESERVED0f_SET(r,f) (r).pi_ctrl0[0]=(((r).pi_ctrl0[0] & ~((uint32_t)0x1ff << 2)) | ((((uint32_t)f) & 0x1ff) << 2))
#define BCMI_TSC_XGXS_PI_CTRL0r_PI_PHASE_INVERTf_GET(r) ((((r).pi_ctrl0[0]) >> 1) & 0x1)
#define BCMI_TSC_XGXS_PI_CTRL0r_PI_PHASE_INVERTf_SET(r,f) (r).pi_ctrl0[0]=(((r).pi_ctrl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCMI_TSC_XGXS_PI_CTRL0r_PI_PHASE_STEP_MULTf_GET(r) (((r).pi_ctrl0[0]) & 0x1)
#define BCMI_TSC_XGXS_PI_CTRL0r_PI_PHASE_STEP_MULTf_SET(r,f) (r).pi_ctrl0[0]=(((r).pi_ctrl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access PI_CTRL0.
 *
 */
#define BCMI_TSC_XGXS_READ_PI_CTRL0r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_PI_CTRL0r,(_r._pi_ctrl0))
#define BCMI_TSC_XGXS_WRITE_PI_CTRL0r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_PI_CTRL0r,(_r._pi_ctrl0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PI_CTRL0r BCMI_TSC_XGXS_PI_CTRL0r
#define PI_CTRL0r_SIZE BCMI_TSC_XGXS_PI_CTRL0r_SIZE
typedef BCMI_TSC_XGXS_PI_CTRL0r_t PI_CTRL0r_t;
#define PI_CTRL0r_CLR BCMI_TSC_XGXS_PI_CTRL0r_CLR
#define PI_CTRL0r_SET BCMI_TSC_XGXS_PI_CTRL0r_SET
#define PI_CTRL0r_GET BCMI_TSC_XGXS_PI_CTRL0r_GET
#define PI_CTRL0r_PI_CW_RSTf_GET BCMI_TSC_XGXS_PI_CTRL0r_PI_CW_RSTf_GET
#define PI_CTRL0r_PI_CW_RSTf_SET BCMI_TSC_XGXS_PI_CTRL0r_PI_CW_RSTf_SET
#define PI_CTRL0r_INTERP_CTRL_DSELf_GET BCMI_TSC_XGXS_PI_CTRL0r_INTERP_CTRL_DSELf_GET
#define PI_CTRL0r_INTERP_CTRL_DSELf_SET BCMI_TSC_XGXS_PI_CTRL0r_INTERP_CTRL_DSELf_SET
#define PI_CTRL0r_INTERP_CTRL_CAPf_GET BCMI_TSC_XGXS_PI_CTRL0r_INTERP_CTRL_CAPf_GET
#define PI_CTRL0r_INTERP_CTRL_CAPf_SET BCMI_TSC_XGXS_PI_CTRL0r_INTERP_CTRL_CAPf_SET
#define PI_CTRL0r_RESERVED0f_GET BCMI_TSC_XGXS_PI_CTRL0r_RESERVED0f_GET
#define PI_CTRL0r_RESERVED0f_SET BCMI_TSC_XGXS_PI_CTRL0r_RESERVED0f_SET
#define PI_CTRL0r_PI_PHASE_INVERTf_GET BCMI_TSC_XGXS_PI_CTRL0r_PI_PHASE_INVERTf_GET
#define PI_CTRL0r_PI_PHASE_INVERTf_SET BCMI_TSC_XGXS_PI_CTRL0r_PI_PHASE_INVERTf_SET
#define PI_CTRL0r_PI_PHASE_STEP_MULTf_GET BCMI_TSC_XGXS_PI_CTRL0r_PI_PHASE_STEP_MULTf_GET
#define PI_CTRL0r_PI_PHASE_STEP_MULTf_SET BCMI_TSC_XGXS_PI_CTRL0r_PI_PHASE_STEP_MULTf_SET
#define READ_PI_CTRL0r BCMI_TSC_XGXS_READ_PI_CTRL0r
#define WRITE_PI_CTRL0r BCMI_TSC_XGXS_WRITE_PI_CTRL0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_PI_CTRL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  PI_CTRL1
 * BLOCKS:   DSC1B0
 * REGADDR:  0xc204
 * DESC:     Phase Interpolator Control 1 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     PI_DUAL_PHASE_OVERRIDE 
 *     PI_CLK90_OFFSET_OVERRIDE 
 *     PI_PHASE_ROTATE_OVERRIDE 
 *     PI_PHASE_STROBE  
 *     PI_PHASE_DELTA   
 *     PI_PHASE_STEP    
 *     PI_PHASE_STEP_DIR 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_PI_CTRL1r (0x0000c204 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_PI_CTRL1r_SIZE 4

/*
 * This structure should be used to declare and program PI_CTRL1.
 *
 */
typedef union BCMI_TSC_XGXS_PI_CTRL1r_s {
	uint32_t v[1];
	uint32_t pi_ctrl1[1];
	uint32_t _pi_ctrl1;
} BCMI_TSC_XGXS_PI_CTRL1r_t;

#define BCMI_TSC_XGXS_PI_CTRL1r_CLR(r) (r).pi_ctrl1[0] = 0
#define BCMI_TSC_XGXS_PI_CTRL1r_SET(r,d) (r).pi_ctrl1[0] = d
#define BCMI_TSC_XGXS_PI_CTRL1r_GET(r) (r).pi_ctrl1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_PI_CTRL1r_RESERVED0f_GET(r) ((((r).pi_ctrl1[0]) >> 12) & 0xf)
#define BCMI_TSC_XGXS_PI_CTRL1r_RESERVED0f_SET(r,f) (r).pi_ctrl1[0]=(((r).pi_ctrl1[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCMI_TSC_XGXS_PI_CTRL1r_PI_PHASE_STEP_DIRf_GET(r) ((((r).pi_ctrl1[0]) >> 11) & 0x1)
#define BCMI_TSC_XGXS_PI_CTRL1r_PI_PHASE_STEP_DIRf_SET(r,f) (r).pi_ctrl1[0]=(((r).pi_ctrl1[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCMI_TSC_XGXS_PI_CTRL1r_PI_PHASE_STEPf_GET(r) ((((r).pi_ctrl1[0]) >> 9) & 0x3)
#define BCMI_TSC_XGXS_PI_CTRL1r_PI_PHASE_STEPf_SET(r,f) (r).pi_ctrl1[0]=(((r).pi_ctrl1[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9))
#define BCMI_TSC_XGXS_PI_CTRL1r_PI_PHASE_DELTAf_GET(r) ((((r).pi_ctrl1[0]) >> 4) & 0x1f)
#define BCMI_TSC_XGXS_PI_CTRL1r_PI_PHASE_DELTAf_SET(r,f) (r).pi_ctrl1[0]=(((r).pi_ctrl1[0] & ~((uint32_t)0x1f << 4)) | ((((uint32_t)f) & 0x1f) << 4))
#define BCMI_TSC_XGXS_PI_CTRL1r_PI_PHASE_STROBEf_GET(r) ((((r).pi_ctrl1[0]) >> 3) & 0x1)
#define BCMI_TSC_XGXS_PI_CTRL1r_PI_PHASE_STROBEf_SET(r,f) (r).pi_ctrl1[0]=(((r).pi_ctrl1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCMI_TSC_XGXS_PI_CTRL1r_PI_PHASE_ROTATE_OVERRIDEf_GET(r) ((((r).pi_ctrl1[0]) >> 2) & 0x1)
#define BCMI_TSC_XGXS_PI_CTRL1r_PI_PHASE_ROTATE_OVERRIDEf_SET(r,f) (r).pi_ctrl1[0]=(((r).pi_ctrl1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCMI_TSC_XGXS_PI_CTRL1r_PI_CLK90_OFFSET_OVERRIDEf_GET(r) ((((r).pi_ctrl1[0]) >> 1) & 0x1)
#define BCMI_TSC_XGXS_PI_CTRL1r_PI_CLK90_OFFSET_OVERRIDEf_SET(r,f) (r).pi_ctrl1[0]=(((r).pi_ctrl1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCMI_TSC_XGXS_PI_CTRL1r_PI_DUAL_PHASE_OVERRIDEf_GET(r) (((r).pi_ctrl1[0]) & 0x1)
#define BCMI_TSC_XGXS_PI_CTRL1r_PI_DUAL_PHASE_OVERRIDEf_SET(r,f) (r).pi_ctrl1[0]=(((r).pi_ctrl1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access PI_CTRL1.
 *
 */
#define BCMI_TSC_XGXS_READ_PI_CTRL1r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_PI_CTRL1r,(_r._pi_ctrl1))
#define BCMI_TSC_XGXS_WRITE_PI_CTRL1r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_PI_CTRL1r,(_r._pi_ctrl1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PI_CTRL1r BCMI_TSC_XGXS_PI_CTRL1r
#define PI_CTRL1r_SIZE BCMI_TSC_XGXS_PI_CTRL1r_SIZE
typedef BCMI_TSC_XGXS_PI_CTRL1r_t PI_CTRL1r_t;
#define PI_CTRL1r_CLR BCMI_TSC_XGXS_PI_CTRL1r_CLR
#define PI_CTRL1r_SET BCMI_TSC_XGXS_PI_CTRL1r_SET
#define PI_CTRL1r_GET BCMI_TSC_XGXS_PI_CTRL1r_GET
#define PI_CTRL1r_RESERVED0f_GET BCMI_TSC_XGXS_PI_CTRL1r_RESERVED0f_GET
#define PI_CTRL1r_RESERVED0f_SET BCMI_TSC_XGXS_PI_CTRL1r_RESERVED0f_SET
#define PI_CTRL1r_PI_PHASE_STEP_DIRf_GET BCMI_TSC_XGXS_PI_CTRL1r_PI_PHASE_STEP_DIRf_GET
#define PI_CTRL1r_PI_PHASE_STEP_DIRf_SET BCMI_TSC_XGXS_PI_CTRL1r_PI_PHASE_STEP_DIRf_SET
#define PI_CTRL1r_PI_PHASE_STEPf_GET BCMI_TSC_XGXS_PI_CTRL1r_PI_PHASE_STEPf_GET
#define PI_CTRL1r_PI_PHASE_STEPf_SET BCMI_TSC_XGXS_PI_CTRL1r_PI_PHASE_STEPf_SET
#define PI_CTRL1r_PI_PHASE_DELTAf_GET BCMI_TSC_XGXS_PI_CTRL1r_PI_PHASE_DELTAf_GET
#define PI_CTRL1r_PI_PHASE_DELTAf_SET BCMI_TSC_XGXS_PI_CTRL1r_PI_PHASE_DELTAf_SET
#define PI_CTRL1r_PI_PHASE_STROBEf_GET BCMI_TSC_XGXS_PI_CTRL1r_PI_PHASE_STROBEf_GET
#define PI_CTRL1r_PI_PHASE_STROBEf_SET BCMI_TSC_XGXS_PI_CTRL1r_PI_PHASE_STROBEf_SET
#define PI_CTRL1r_PI_PHASE_ROTATE_OVERRIDEf_GET BCMI_TSC_XGXS_PI_CTRL1r_PI_PHASE_ROTATE_OVERRIDEf_GET
#define PI_CTRL1r_PI_PHASE_ROTATE_OVERRIDEf_SET BCMI_TSC_XGXS_PI_CTRL1r_PI_PHASE_ROTATE_OVERRIDEf_SET
#define PI_CTRL1r_PI_CLK90_OFFSET_OVERRIDEf_GET BCMI_TSC_XGXS_PI_CTRL1r_PI_CLK90_OFFSET_OVERRIDEf_GET
#define PI_CTRL1r_PI_CLK90_OFFSET_OVERRIDEf_SET BCMI_TSC_XGXS_PI_CTRL1r_PI_CLK90_OFFSET_OVERRIDEf_SET
#define PI_CTRL1r_PI_DUAL_PHASE_OVERRIDEf_GET BCMI_TSC_XGXS_PI_CTRL1r_PI_DUAL_PHASE_OVERRIDEf_GET
#define PI_CTRL1r_PI_DUAL_PHASE_OVERRIDEf_SET BCMI_TSC_XGXS_PI_CTRL1r_PI_DUAL_PHASE_OVERRIDEf_SET
#define READ_PI_CTRL1r BCMI_TSC_XGXS_READ_PI_CTRL1r
#define WRITE_PI_CTRL1r BCMI_TSC_XGXS_WRITE_PI_CTRL1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_PI_CTRL1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  DFE_VGA_CTRL0
 * BLOCKS:   DSC1B0
 * REGADDR:  0xc205
 * DESC:     DFE VGA Control 0 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     DFE_VGA_CLKEN    
 *     TRNSUM_EN        
 *     SUM_M1ERR        
 *     TRNSUM_TAP0_ONLY 
 *     DFE_POLARITY     
 *     VGA_POLARITY     
 *     COR_NEG1_EN      
 *     COR_NEG2_EN      
 *     RANDOM_TAPSEL_DISABLE 
 *     DFE_ABS_SUM_MAX  
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_DFE_VGA_CTRL0r (0x0000c205 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_DFE_VGA_CTRL0r_SIZE 4

/*
 * This structure should be used to declare and program DFE_VGA_CTRL0.
 *
 */
typedef union BCMI_TSC_XGXS_DFE_VGA_CTRL0r_s {
	uint32_t v[1];
	uint32_t dfe_vga_ctrl0[1];
	uint32_t _dfe_vga_ctrl0;
} BCMI_TSC_XGXS_DFE_VGA_CTRL0r_t;

#define BCMI_TSC_XGXS_DFE_VGA_CTRL0r_CLR(r) (r).dfe_vga_ctrl0[0] = 0
#define BCMI_TSC_XGXS_DFE_VGA_CTRL0r_SET(r,d) (r).dfe_vga_ctrl0[0] = d
#define BCMI_TSC_XGXS_DFE_VGA_CTRL0r_GET(r) (r).dfe_vga_ctrl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_DFE_VGA_CTRL0r_DFE_ABS_SUM_MAXf_GET(r) ((((r).dfe_vga_ctrl0[0]) >> 9) & 0x7f)
#define BCMI_TSC_XGXS_DFE_VGA_CTRL0r_DFE_ABS_SUM_MAXf_SET(r,f) (r).dfe_vga_ctrl0[0]=(((r).dfe_vga_ctrl0[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))
#define BCMI_TSC_XGXS_DFE_VGA_CTRL0r_RANDOM_TAPSEL_DISABLEf_GET(r) ((((r).dfe_vga_ctrl0[0]) >> 8) & 0x1)
#define BCMI_TSC_XGXS_DFE_VGA_CTRL0r_RANDOM_TAPSEL_DISABLEf_SET(r,f) (r).dfe_vga_ctrl0[0]=(((r).dfe_vga_ctrl0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCMI_TSC_XGXS_DFE_VGA_CTRL0r_COR_NEG2_ENf_GET(r) ((((r).dfe_vga_ctrl0[0]) >> 7) & 0x1)
#define BCMI_TSC_XGXS_DFE_VGA_CTRL0r_COR_NEG2_ENf_SET(r,f) (r).dfe_vga_ctrl0[0]=(((r).dfe_vga_ctrl0[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCMI_TSC_XGXS_DFE_VGA_CTRL0r_COR_NEG1_ENf_GET(r) ((((r).dfe_vga_ctrl0[0]) >> 6) & 0x1)
#define BCMI_TSC_XGXS_DFE_VGA_CTRL0r_COR_NEG1_ENf_SET(r,f) (r).dfe_vga_ctrl0[0]=(((r).dfe_vga_ctrl0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCMI_TSC_XGXS_DFE_VGA_CTRL0r_VGA_POLARITYf_GET(r) ((((r).dfe_vga_ctrl0[0]) >> 5) & 0x1)
#define BCMI_TSC_XGXS_DFE_VGA_CTRL0r_VGA_POLARITYf_SET(r,f) (r).dfe_vga_ctrl0[0]=(((r).dfe_vga_ctrl0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCMI_TSC_XGXS_DFE_VGA_CTRL0r_DFE_POLARITYf_GET(r) ((((r).dfe_vga_ctrl0[0]) >> 4) & 0x1)
#define BCMI_TSC_XGXS_DFE_VGA_CTRL0r_DFE_POLARITYf_SET(r,f) (r).dfe_vga_ctrl0[0]=(((r).dfe_vga_ctrl0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCMI_TSC_XGXS_DFE_VGA_CTRL0r_TRNSUM_TAP0_ONLYf_GET(r) ((((r).dfe_vga_ctrl0[0]) >> 3) & 0x1)
#define BCMI_TSC_XGXS_DFE_VGA_CTRL0r_TRNSUM_TAP0_ONLYf_SET(r,f) (r).dfe_vga_ctrl0[0]=(((r).dfe_vga_ctrl0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCMI_TSC_XGXS_DFE_VGA_CTRL0r_SUM_M1ERRf_GET(r) ((((r).dfe_vga_ctrl0[0]) >> 2) & 0x1)
#define BCMI_TSC_XGXS_DFE_VGA_CTRL0r_SUM_M1ERRf_SET(r,f) (r).dfe_vga_ctrl0[0]=(((r).dfe_vga_ctrl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCMI_TSC_XGXS_DFE_VGA_CTRL0r_TRNSUM_ENf_GET(r) ((((r).dfe_vga_ctrl0[0]) >> 1) & 0x1)
#define BCMI_TSC_XGXS_DFE_VGA_CTRL0r_TRNSUM_ENf_SET(r,f) (r).dfe_vga_ctrl0[0]=(((r).dfe_vga_ctrl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCMI_TSC_XGXS_DFE_VGA_CTRL0r_DFE_VGA_CLKENf_GET(r) (((r).dfe_vga_ctrl0[0]) & 0x1)
#define BCMI_TSC_XGXS_DFE_VGA_CTRL0r_DFE_VGA_CLKENf_SET(r,f) (r).dfe_vga_ctrl0[0]=(((r).dfe_vga_ctrl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access DFE_VGA_CTRL0.
 *
 */
#define BCMI_TSC_XGXS_READ_DFE_VGA_CTRL0r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_DFE_VGA_CTRL0r,(_r._dfe_vga_ctrl0))
#define BCMI_TSC_XGXS_WRITE_DFE_VGA_CTRL0r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_DFE_VGA_CTRL0r,(_r._dfe_vga_ctrl0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DFE_VGA_CTRL0r BCMI_TSC_XGXS_DFE_VGA_CTRL0r
#define DFE_VGA_CTRL0r_SIZE BCMI_TSC_XGXS_DFE_VGA_CTRL0r_SIZE
typedef BCMI_TSC_XGXS_DFE_VGA_CTRL0r_t DFE_VGA_CTRL0r_t;
#define DFE_VGA_CTRL0r_CLR BCMI_TSC_XGXS_DFE_VGA_CTRL0r_CLR
#define DFE_VGA_CTRL0r_SET BCMI_TSC_XGXS_DFE_VGA_CTRL0r_SET
#define DFE_VGA_CTRL0r_GET BCMI_TSC_XGXS_DFE_VGA_CTRL0r_GET
#define DFE_VGA_CTRL0r_DFE_ABS_SUM_MAXf_GET BCMI_TSC_XGXS_DFE_VGA_CTRL0r_DFE_ABS_SUM_MAXf_GET
#define DFE_VGA_CTRL0r_DFE_ABS_SUM_MAXf_SET BCMI_TSC_XGXS_DFE_VGA_CTRL0r_DFE_ABS_SUM_MAXf_SET
#define DFE_VGA_CTRL0r_RANDOM_TAPSEL_DISABLEf_GET BCMI_TSC_XGXS_DFE_VGA_CTRL0r_RANDOM_TAPSEL_DISABLEf_GET
#define DFE_VGA_CTRL0r_RANDOM_TAPSEL_DISABLEf_SET BCMI_TSC_XGXS_DFE_VGA_CTRL0r_RANDOM_TAPSEL_DISABLEf_SET
#define DFE_VGA_CTRL0r_COR_NEG2_ENf_GET BCMI_TSC_XGXS_DFE_VGA_CTRL0r_COR_NEG2_ENf_GET
#define DFE_VGA_CTRL0r_COR_NEG2_ENf_SET BCMI_TSC_XGXS_DFE_VGA_CTRL0r_COR_NEG2_ENf_SET
#define DFE_VGA_CTRL0r_COR_NEG1_ENf_GET BCMI_TSC_XGXS_DFE_VGA_CTRL0r_COR_NEG1_ENf_GET
#define DFE_VGA_CTRL0r_COR_NEG1_ENf_SET BCMI_TSC_XGXS_DFE_VGA_CTRL0r_COR_NEG1_ENf_SET
#define DFE_VGA_CTRL0r_VGA_POLARITYf_GET BCMI_TSC_XGXS_DFE_VGA_CTRL0r_VGA_POLARITYf_GET
#define DFE_VGA_CTRL0r_VGA_POLARITYf_SET BCMI_TSC_XGXS_DFE_VGA_CTRL0r_VGA_POLARITYf_SET
#define DFE_VGA_CTRL0r_DFE_POLARITYf_GET BCMI_TSC_XGXS_DFE_VGA_CTRL0r_DFE_POLARITYf_GET
#define DFE_VGA_CTRL0r_DFE_POLARITYf_SET BCMI_TSC_XGXS_DFE_VGA_CTRL0r_DFE_POLARITYf_SET
#define DFE_VGA_CTRL0r_TRNSUM_TAP0_ONLYf_GET BCMI_TSC_XGXS_DFE_VGA_CTRL0r_TRNSUM_TAP0_ONLYf_GET
#define DFE_VGA_CTRL0r_TRNSUM_TAP0_ONLYf_SET BCMI_TSC_XGXS_DFE_VGA_CTRL0r_TRNSUM_TAP0_ONLYf_SET
#define DFE_VGA_CTRL0r_SUM_M1ERRf_GET BCMI_TSC_XGXS_DFE_VGA_CTRL0r_SUM_M1ERRf_GET
#define DFE_VGA_CTRL0r_SUM_M1ERRf_SET BCMI_TSC_XGXS_DFE_VGA_CTRL0r_SUM_M1ERRf_SET
#define DFE_VGA_CTRL0r_TRNSUM_ENf_GET BCMI_TSC_XGXS_DFE_VGA_CTRL0r_TRNSUM_ENf_GET
#define DFE_VGA_CTRL0r_TRNSUM_ENf_SET BCMI_TSC_XGXS_DFE_VGA_CTRL0r_TRNSUM_ENf_SET
#define DFE_VGA_CTRL0r_DFE_VGA_CLKENf_GET BCMI_TSC_XGXS_DFE_VGA_CTRL0r_DFE_VGA_CLKENf_GET
#define DFE_VGA_CTRL0r_DFE_VGA_CLKENf_SET BCMI_TSC_XGXS_DFE_VGA_CTRL0r_DFE_VGA_CLKENf_SET
#define READ_DFE_VGA_CTRL0r BCMI_TSC_XGXS_READ_DFE_VGA_CTRL0r
#define WRITE_DFE_VGA_CTRL0r BCMI_TSC_XGXS_WRITE_DFE_VGA_CTRL0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_DFE_VGA_CTRL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  DFE_VGA_CTRL1
 * BLOCKS:   DSC1B0
 * REGADDR:  0xc206
 * DESC:     DFE VGA Control 1 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     DFE_TAP_1_DE     
 *     DFE_TAP_1_DO     
 *     DFE_TAP_2_DCD    
 *     DFE_CDROS_QPHASE_MULT_EN 
 *     DFE_LLMS_EN      
 *     DFE_LLMS_UPDATE_COUNT_SEL 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_DFE_VGA_CTRL1r (0x0000c206 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_DFE_VGA_CTRL1r_SIZE 4

/*
 * This structure should be used to declare and program DFE_VGA_CTRL1.
 *
 */
typedef union BCMI_TSC_XGXS_DFE_VGA_CTRL1r_s {
	uint32_t v[1];
	uint32_t dfe_vga_ctrl1[1];
	uint32_t _dfe_vga_ctrl1;
} BCMI_TSC_XGXS_DFE_VGA_CTRL1r_t;

#define BCMI_TSC_XGXS_DFE_VGA_CTRL1r_CLR(r) (r).dfe_vga_ctrl1[0] = 0
#define BCMI_TSC_XGXS_DFE_VGA_CTRL1r_SET(r,d) (r).dfe_vga_ctrl1[0] = d
#define BCMI_TSC_XGXS_DFE_VGA_CTRL1r_GET(r) (r).dfe_vga_ctrl1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_DFE_VGA_CTRL1r_RESERVED0f_GET(r) ((((r).dfe_vga_ctrl1[0]) >> 14) & 0x3)
#define BCMI_TSC_XGXS_DFE_VGA_CTRL1r_RESERVED0f_SET(r,f) (r).dfe_vga_ctrl1[0]=(((r).dfe_vga_ctrl1[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCMI_TSC_XGXS_DFE_VGA_CTRL1r_DFE_LLMS_UPDATE_COUNT_SELf_GET(r) ((((r).dfe_vga_ctrl1[0]) >> 12) & 0x3)
#define BCMI_TSC_XGXS_DFE_VGA_CTRL1r_DFE_LLMS_UPDATE_COUNT_SELf_SET(r,f) (r).dfe_vga_ctrl1[0]=(((r).dfe_vga_ctrl1[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCMI_TSC_XGXS_DFE_VGA_CTRL1r_DFE_LLMS_ENf_GET(r) ((((r).dfe_vga_ctrl1[0]) >> 11) & 0x1)
#define BCMI_TSC_XGXS_DFE_VGA_CTRL1r_DFE_LLMS_ENf_SET(r,f) (r).dfe_vga_ctrl1[0]=(((r).dfe_vga_ctrl1[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCMI_TSC_XGXS_DFE_VGA_CTRL1r_DFE_CDROS_QPHASE_MULT_ENf_GET(r) ((((r).dfe_vga_ctrl1[0]) >> 10) & 0x1)
#define BCMI_TSC_XGXS_DFE_VGA_CTRL1r_DFE_CDROS_QPHASE_MULT_ENf_SET(r,f) (r).dfe_vga_ctrl1[0]=(((r).dfe_vga_ctrl1[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCMI_TSC_XGXS_DFE_VGA_CTRL1r_DFE_TAP_2_DCDf_GET(r) ((((r).dfe_vga_ctrl1[0]) >> 6) & 0xf)
#define BCMI_TSC_XGXS_DFE_VGA_CTRL1r_DFE_TAP_2_DCDf_SET(r,f) (r).dfe_vga_ctrl1[0]=(((r).dfe_vga_ctrl1[0] & ~((uint32_t)0xf << 6)) | ((((uint32_t)f) & 0xf) << 6))
#define BCMI_TSC_XGXS_DFE_VGA_CTRL1r_DFE_TAP_1_DOf_GET(r) ((((r).dfe_vga_ctrl1[0]) >> 3) & 0x7)
#define BCMI_TSC_XGXS_DFE_VGA_CTRL1r_DFE_TAP_1_DOf_SET(r,f) (r).dfe_vga_ctrl1[0]=(((r).dfe_vga_ctrl1[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCMI_TSC_XGXS_DFE_VGA_CTRL1r_DFE_TAP_1_DEf_GET(r) (((r).dfe_vga_ctrl1[0]) & 0x7)
#define BCMI_TSC_XGXS_DFE_VGA_CTRL1r_DFE_TAP_1_DEf_SET(r,f) (r).dfe_vga_ctrl1[0]=(((r).dfe_vga_ctrl1[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))

/*
 * These macros can be used to access DFE_VGA_CTRL1.
 *
 */
#define BCMI_TSC_XGXS_READ_DFE_VGA_CTRL1r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_DFE_VGA_CTRL1r,(_r._dfe_vga_ctrl1))
#define BCMI_TSC_XGXS_WRITE_DFE_VGA_CTRL1r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_DFE_VGA_CTRL1r,(_r._dfe_vga_ctrl1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DFE_VGA_CTRL1r BCMI_TSC_XGXS_DFE_VGA_CTRL1r
#define DFE_VGA_CTRL1r_SIZE BCMI_TSC_XGXS_DFE_VGA_CTRL1r_SIZE
typedef BCMI_TSC_XGXS_DFE_VGA_CTRL1r_t DFE_VGA_CTRL1r_t;
#define DFE_VGA_CTRL1r_CLR BCMI_TSC_XGXS_DFE_VGA_CTRL1r_CLR
#define DFE_VGA_CTRL1r_SET BCMI_TSC_XGXS_DFE_VGA_CTRL1r_SET
#define DFE_VGA_CTRL1r_GET BCMI_TSC_XGXS_DFE_VGA_CTRL1r_GET
#define DFE_VGA_CTRL1r_RESERVED0f_GET BCMI_TSC_XGXS_DFE_VGA_CTRL1r_RESERVED0f_GET
#define DFE_VGA_CTRL1r_RESERVED0f_SET BCMI_TSC_XGXS_DFE_VGA_CTRL1r_RESERVED0f_SET
#define DFE_VGA_CTRL1r_DFE_LLMS_UPDATE_COUNT_SELf_GET BCMI_TSC_XGXS_DFE_VGA_CTRL1r_DFE_LLMS_UPDATE_COUNT_SELf_GET
#define DFE_VGA_CTRL1r_DFE_LLMS_UPDATE_COUNT_SELf_SET BCMI_TSC_XGXS_DFE_VGA_CTRL1r_DFE_LLMS_UPDATE_COUNT_SELf_SET
#define DFE_VGA_CTRL1r_DFE_LLMS_ENf_GET BCMI_TSC_XGXS_DFE_VGA_CTRL1r_DFE_LLMS_ENf_GET
#define DFE_VGA_CTRL1r_DFE_LLMS_ENf_SET BCMI_TSC_XGXS_DFE_VGA_CTRL1r_DFE_LLMS_ENf_SET
#define DFE_VGA_CTRL1r_DFE_CDROS_QPHASE_MULT_ENf_GET BCMI_TSC_XGXS_DFE_VGA_CTRL1r_DFE_CDROS_QPHASE_MULT_ENf_GET
#define DFE_VGA_CTRL1r_DFE_CDROS_QPHASE_MULT_ENf_SET BCMI_TSC_XGXS_DFE_VGA_CTRL1r_DFE_CDROS_QPHASE_MULT_ENf_SET
#define DFE_VGA_CTRL1r_DFE_TAP_2_DCDf_GET BCMI_TSC_XGXS_DFE_VGA_CTRL1r_DFE_TAP_2_DCDf_GET
#define DFE_VGA_CTRL1r_DFE_TAP_2_DCDf_SET BCMI_TSC_XGXS_DFE_VGA_CTRL1r_DFE_TAP_2_DCDf_SET
#define DFE_VGA_CTRL1r_DFE_TAP_1_DOf_GET BCMI_TSC_XGXS_DFE_VGA_CTRL1r_DFE_TAP_1_DOf_GET
#define DFE_VGA_CTRL1r_DFE_TAP_1_DOf_SET BCMI_TSC_XGXS_DFE_VGA_CTRL1r_DFE_TAP_1_DOf_SET
#define DFE_VGA_CTRL1r_DFE_TAP_1_DEf_GET BCMI_TSC_XGXS_DFE_VGA_CTRL1r_DFE_TAP_1_DEf_GET
#define DFE_VGA_CTRL1r_DFE_TAP_1_DEf_SET BCMI_TSC_XGXS_DFE_VGA_CTRL1r_DFE_TAP_1_DEf_SET
#define READ_DFE_VGA_CTRL1r BCMI_TSC_XGXS_READ_DFE_VGA_CTRL1r
#define WRITE_DFE_VGA_CTRL1r BCMI_TSC_XGXS_WRITE_DFE_VGA_CTRL1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_DFE_VGA_CTRL1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  DFE_VGA_CTRL2
 * BLOCKS:   DSC1B0
 * REGADDR:  0xc207
 * DESC:     DFE VGA Control 2 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     DFE_VGA_WRITE_EN 
 *     DFE_VGA_WRITE_VAL 
 *     DFE_VGA_WRITE_TAPSEL 
 *     RESERVED0        
 *     VGA3_OVERRIDE_EN 
 *     VGA3_OVERRIDE_VAL 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_DFE_VGA_CTRL2r (0x0000c207 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_DFE_VGA_CTRL2r_SIZE 4

/*
 * This structure should be used to declare and program DFE_VGA_CTRL2.
 *
 */
typedef union BCMI_TSC_XGXS_DFE_VGA_CTRL2r_s {
	uint32_t v[1];
	uint32_t dfe_vga_ctrl2[1];
	uint32_t _dfe_vga_ctrl2;
} BCMI_TSC_XGXS_DFE_VGA_CTRL2r_t;

#define BCMI_TSC_XGXS_DFE_VGA_CTRL2r_CLR(r) (r).dfe_vga_ctrl2[0] = 0
#define BCMI_TSC_XGXS_DFE_VGA_CTRL2r_SET(r,d) (r).dfe_vga_ctrl2[0] = d
#define BCMI_TSC_XGXS_DFE_VGA_CTRL2r_GET(r) (r).dfe_vga_ctrl2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_DFE_VGA_CTRL2r_VGA3_OVERRIDE_VALf_GET(r) ((((r).dfe_vga_ctrl2[0]) >> 12) & 0xf)
#define BCMI_TSC_XGXS_DFE_VGA_CTRL2r_VGA3_OVERRIDE_VALf_SET(r,f) (r).dfe_vga_ctrl2[0]=(((r).dfe_vga_ctrl2[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCMI_TSC_XGXS_DFE_VGA_CTRL2r_VGA3_OVERRIDE_ENf_GET(r) ((((r).dfe_vga_ctrl2[0]) >> 11) & 0x1)
#define BCMI_TSC_XGXS_DFE_VGA_CTRL2r_VGA3_OVERRIDE_ENf_SET(r,f) (r).dfe_vga_ctrl2[0]=(((r).dfe_vga_ctrl2[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCMI_TSC_XGXS_DFE_VGA_CTRL2r_RESERVED0f_GET(r) ((((r).dfe_vga_ctrl2[0]) >> 10) & 0x1)
#define BCMI_TSC_XGXS_DFE_VGA_CTRL2r_RESERVED0f_SET(r,f) (r).dfe_vga_ctrl2[0]=(((r).dfe_vga_ctrl2[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCMI_TSC_XGXS_DFE_VGA_CTRL2r_DFE_VGA_WRITE_TAPSELf_GET(r) ((((r).dfe_vga_ctrl2[0]) >> 7) & 0x7)
#define BCMI_TSC_XGXS_DFE_VGA_CTRL2r_DFE_VGA_WRITE_TAPSELf_SET(r,f) (r).dfe_vga_ctrl2[0]=(((r).dfe_vga_ctrl2[0] & ~((uint32_t)0x7 << 7)) | ((((uint32_t)f) & 0x7) << 7))
#define BCMI_TSC_XGXS_DFE_VGA_CTRL2r_DFE_VGA_WRITE_VALf_GET(r) ((((r).dfe_vga_ctrl2[0]) >> 1) & 0x3f)
#define BCMI_TSC_XGXS_DFE_VGA_CTRL2r_DFE_VGA_WRITE_VALf_SET(r,f) (r).dfe_vga_ctrl2[0]=(((r).dfe_vga_ctrl2[0] & ~((uint32_t)0x3f << 1)) | ((((uint32_t)f) & 0x3f) << 1))
#define BCMI_TSC_XGXS_DFE_VGA_CTRL2r_DFE_VGA_WRITE_ENf_GET(r) (((r).dfe_vga_ctrl2[0]) & 0x1)
#define BCMI_TSC_XGXS_DFE_VGA_CTRL2r_DFE_VGA_WRITE_ENf_SET(r,f) (r).dfe_vga_ctrl2[0]=(((r).dfe_vga_ctrl2[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access DFE_VGA_CTRL2.
 *
 */
#define BCMI_TSC_XGXS_READ_DFE_VGA_CTRL2r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_DFE_VGA_CTRL2r,(_r._dfe_vga_ctrl2))
#define BCMI_TSC_XGXS_WRITE_DFE_VGA_CTRL2r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_DFE_VGA_CTRL2r,(_r._dfe_vga_ctrl2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DFE_VGA_CTRL2r BCMI_TSC_XGXS_DFE_VGA_CTRL2r
#define DFE_VGA_CTRL2r_SIZE BCMI_TSC_XGXS_DFE_VGA_CTRL2r_SIZE
typedef BCMI_TSC_XGXS_DFE_VGA_CTRL2r_t DFE_VGA_CTRL2r_t;
#define DFE_VGA_CTRL2r_CLR BCMI_TSC_XGXS_DFE_VGA_CTRL2r_CLR
#define DFE_VGA_CTRL2r_SET BCMI_TSC_XGXS_DFE_VGA_CTRL2r_SET
#define DFE_VGA_CTRL2r_GET BCMI_TSC_XGXS_DFE_VGA_CTRL2r_GET
#define DFE_VGA_CTRL2r_VGA3_OVERRIDE_VALf_GET BCMI_TSC_XGXS_DFE_VGA_CTRL2r_VGA3_OVERRIDE_VALf_GET
#define DFE_VGA_CTRL2r_VGA3_OVERRIDE_VALf_SET BCMI_TSC_XGXS_DFE_VGA_CTRL2r_VGA3_OVERRIDE_VALf_SET
#define DFE_VGA_CTRL2r_VGA3_OVERRIDE_ENf_GET BCMI_TSC_XGXS_DFE_VGA_CTRL2r_VGA3_OVERRIDE_ENf_GET
#define DFE_VGA_CTRL2r_VGA3_OVERRIDE_ENf_SET BCMI_TSC_XGXS_DFE_VGA_CTRL2r_VGA3_OVERRIDE_ENf_SET
#define DFE_VGA_CTRL2r_RESERVED0f_GET BCMI_TSC_XGXS_DFE_VGA_CTRL2r_RESERVED0f_GET
#define DFE_VGA_CTRL2r_RESERVED0f_SET BCMI_TSC_XGXS_DFE_VGA_CTRL2r_RESERVED0f_SET
#define DFE_VGA_CTRL2r_DFE_VGA_WRITE_TAPSELf_GET BCMI_TSC_XGXS_DFE_VGA_CTRL2r_DFE_VGA_WRITE_TAPSELf_GET
#define DFE_VGA_CTRL2r_DFE_VGA_WRITE_TAPSELf_SET BCMI_TSC_XGXS_DFE_VGA_CTRL2r_DFE_VGA_WRITE_TAPSELf_SET
#define DFE_VGA_CTRL2r_DFE_VGA_WRITE_VALf_GET BCMI_TSC_XGXS_DFE_VGA_CTRL2r_DFE_VGA_WRITE_VALf_GET
#define DFE_VGA_CTRL2r_DFE_VGA_WRITE_VALf_SET BCMI_TSC_XGXS_DFE_VGA_CTRL2r_DFE_VGA_WRITE_VALf_SET
#define DFE_VGA_CTRL2r_DFE_VGA_WRITE_ENf_GET BCMI_TSC_XGXS_DFE_VGA_CTRL2r_DFE_VGA_WRITE_ENf_GET
#define DFE_VGA_CTRL2r_DFE_VGA_WRITE_ENf_SET BCMI_TSC_XGXS_DFE_VGA_CTRL2r_DFE_VGA_WRITE_ENf_SET
#define READ_DFE_VGA_CTRL2r BCMI_TSC_XGXS_READ_DFE_VGA_CTRL2r
#define WRITE_DFE_VGA_CTRL2r BCMI_TSC_XGXS_WRITE_DFE_VGA_CTRL2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_DFE_VGA_CTRL2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  DFE_VGA_CTRL3
 * BLOCKS:   DSC1B0
 * REGADDR:  0xc208
 * DESC:     DFE VGA Control 3 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     TRNSUM_ETAP_EN   
 *     TRNSUM_OTAP_EN   
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_DFE_VGA_CTRL3r (0x0000c208 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_DFE_VGA_CTRL3r_SIZE 4

/*
 * This structure should be used to declare and program DFE_VGA_CTRL3.
 *
 */
typedef union BCMI_TSC_XGXS_DFE_VGA_CTRL3r_s {
	uint32_t v[1];
	uint32_t dfe_vga_ctrl3[1];
	uint32_t _dfe_vga_ctrl3;
} BCMI_TSC_XGXS_DFE_VGA_CTRL3r_t;

#define BCMI_TSC_XGXS_DFE_VGA_CTRL3r_CLR(r) (r).dfe_vga_ctrl3[0] = 0
#define BCMI_TSC_XGXS_DFE_VGA_CTRL3r_SET(r,d) (r).dfe_vga_ctrl3[0] = d
#define BCMI_TSC_XGXS_DFE_VGA_CTRL3r_GET(r) (r).dfe_vga_ctrl3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_DFE_VGA_CTRL3r_TRNSUM_OTAP_ENf_GET(r) ((((r).dfe_vga_ctrl3[0]) >> 8) & 0xff)
#define BCMI_TSC_XGXS_DFE_VGA_CTRL3r_TRNSUM_OTAP_ENf_SET(r,f) (r).dfe_vga_ctrl3[0]=(((r).dfe_vga_ctrl3[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCMI_TSC_XGXS_DFE_VGA_CTRL3r_TRNSUM_ETAP_ENf_GET(r) (((r).dfe_vga_ctrl3[0]) & 0xff)
#define BCMI_TSC_XGXS_DFE_VGA_CTRL3r_TRNSUM_ETAP_ENf_SET(r,f) (r).dfe_vga_ctrl3[0]=(((r).dfe_vga_ctrl3[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access DFE_VGA_CTRL3.
 *
 */
#define BCMI_TSC_XGXS_READ_DFE_VGA_CTRL3r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_DFE_VGA_CTRL3r,(_r._dfe_vga_ctrl3))
#define BCMI_TSC_XGXS_WRITE_DFE_VGA_CTRL3r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_DFE_VGA_CTRL3r,(_r._dfe_vga_ctrl3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DFE_VGA_CTRL3r BCMI_TSC_XGXS_DFE_VGA_CTRL3r
#define DFE_VGA_CTRL3r_SIZE BCMI_TSC_XGXS_DFE_VGA_CTRL3r_SIZE
typedef BCMI_TSC_XGXS_DFE_VGA_CTRL3r_t DFE_VGA_CTRL3r_t;
#define DFE_VGA_CTRL3r_CLR BCMI_TSC_XGXS_DFE_VGA_CTRL3r_CLR
#define DFE_VGA_CTRL3r_SET BCMI_TSC_XGXS_DFE_VGA_CTRL3r_SET
#define DFE_VGA_CTRL3r_GET BCMI_TSC_XGXS_DFE_VGA_CTRL3r_GET
#define DFE_VGA_CTRL3r_TRNSUM_OTAP_ENf_GET BCMI_TSC_XGXS_DFE_VGA_CTRL3r_TRNSUM_OTAP_ENf_GET
#define DFE_VGA_CTRL3r_TRNSUM_OTAP_ENf_SET BCMI_TSC_XGXS_DFE_VGA_CTRL3r_TRNSUM_OTAP_ENf_SET
#define DFE_VGA_CTRL3r_TRNSUM_ETAP_ENf_GET BCMI_TSC_XGXS_DFE_VGA_CTRL3r_TRNSUM_ETAP_ENf_GET
#define DFE_VGA_CTRL3r_TRNSUM_ETAP_ENf_SET BCMI_TSC_XGXS_DFE_VGA_CTRL3r_TRNSUM_ETAP_ENf_SET
#define READ_DFE_VGA_CTRL3r BCMI_TSC_XGXS_READ_DFE_VGA_CTRL3r
#define WRITE_DFE_VGA_CTRL3r BCMI_TSC_XGXS_WRITE_DFE_VGA_CTRL3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_DFE_VGA_CTRL3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  DFE_VGA_CTRL4
 * BLOCKS:   DSC1B0
 * REGADDR:  0xc209
 * DESC:     DFE VGA Control 4 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     TRNSUM_ETAP_SIGN 
 *     TRNSUM_OTAP_SIGN 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_DFE_VGA_CTRL4r (0x0000c209 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_DFE_VGA_CTRL4r_SIZE 4

/*
 * This structure should be used to declare and program DFE_VGA_CTRL4.
 *
 */
typedef union BCMI_TSC_XGXS_DFE_VGA_CTRL4r_s {
	uint32_t v[1];
	uint32_t dfe_vga_ctrl4[1];
	uint32_t _dfe_vga_ctrl4;
} BCMI_TSC_XGXS_DFE_VGA_CTRL4r_t;

#define BCMI_TSC_XGXS_DFE_VGA_CTRL4r_CLR(r) (r).dfe_vga_ctrl4[0] = 0
#define BCMI_TSC_XGXS_DFE_VGA_CTRL4r_SET(r,d) (r).dfe_vga_ctrl4[0] = d
#define BCMI_TSC_XGXS_DFE_VGA_CTRL4r_GET(r) (r).dfe_vga_ctrl4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_DFE_VGA_CTRL4r_TRNSUM_OTAP_SIGNf_GET(r) ((((r).dfe_vga_ctrl4[0]) >> 8) & 0xff)
#define BCMI_TSC_XGXS_DFE_VGA_CTRL4r_TRNSUM_OTAP_SIGNf_SET(r,f) (r).dfe_vga_ctrl4[0]=(((r).dfe_vga_ctrl4[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCMI_TSC_XGXS_DFE_VGA_CTRL4r_TRNSUM_ETAP_SIGNf_GET(r) (((r).dfe_vga_ctrl4[0]) & 0xff)
#define BCMI_TSC_XGXS_DFE_VGA_CTRL4r_TRNSUM_ETAP_SIGNf_SET(r,f) (r).dfe_vga_ctrl4[0]=(((r).dfe_vga_ctrl4[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access DFE_VGA_CTRL4.
 *
 */
#define BCMI_TSC_XGXS_READ_DFE_VGA_CTRL4r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_DFE_VGA_CTRL4r,(_r._dfe_vga_ctrl4))
#define BCMI_TSC_XGXS_WRITE_DFE_VGA_CTRL4r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_DFE_VGA_CTRL4r,(_r._dfe_vga_ctrl4))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DFE_VGA_CTRL4r BCMI_TSC_XGXS_DFE_VGA_CTRL4r
#define DFE_VGA_CTRL4r_SIZE BCMI_TSC_XGXS_DFE_VGA_CTRL4r_SIZE
typedef BCMI_TSC_XGXS_DFE_VGA_CTRL4r_t DFE_VGA_CTRL4r_t;
#define DFE_VGA_CTRL4r_CLR BCMI_TSC_XGXS_DFE_VGA_CTRL4r_CLR
#define DFE_VGA_CTRL4r_SET BCMI_TSC_XGXS_DFE_VGA_CTRL4r_SET
#define DFE_VGA_CTRL4r_GET BCMI_TSC_XGXS_DFE_VGA_CTRL4r_GET
#define DFE_VGA_CTRL4r_TRNSUM_OTAP_SIGNf_GET BCMI_TSC_XGXS_DFE_VGA_CTRL4r_TRNSUM_OTAP_SIGNf_GET
#define DFE_VGA_CTRL4r_TRNSUM_OTAP_SIGNf_SET BCMI_TSC_XGXS_DFE_VGA_CTRL4r_TRNSUM_OTAP_SIGNf_SET
#define DFE_VGA_CTRL4r_TRNSUM_ETAP_SIGNf_GET BCMI_TSC_XGXS_DFE_VGA_CTRL4r_TRNSUM_ETAP_SIGNf_GET
#define DFE_VGA_CTRL4r_TRNSUM_ETAP_SIGNf_SET BCMI_TSC_XGXS_DFE_VGA_CTRL4r_TRNSUM_ETAP_SIGNf_SET
#define READ_DFE_VGA_CTRL4r BCMI_TSC_XGXS_READ_DFE_VGA_CTRL4r
#define WRITE_DFE_VGA_CTRL4r BCMI_TSC_XGXS_WRITE_DFE_VGA_CTRL4r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_DFE_VGA_CTRL4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  DFE_VGA_CTRL5
 * BLOCKS:   DSC1B0
 * REGADDR:  0xc20a
 * DESC:     DFE VGA Control 5 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     VGA_COR_SEL_O    
 *     VGA_COR_SEL_E    
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_DFE_VGA_CTRL5r (0x0000c20a | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_DFE_VGA_CTRL5r_SIZE 4

/*
 * This structure should be used to declare and program DFE_VGA_CTRL5.
 *
 */
typedef union BCMI_TSC_XGXS_DFE_VGA_CTRL5r_s {
	uint32_t v[1];
	uint32_t dfe_vga_ctrl5[1];
	uint32_t _dfe_vga_ctrl5;
} BCMI_TSC_XGXS_DFE_VGA_CTRL5r_t;

#define BCMI_TSC_XGXS_DFE_VGA_CTRL5r_CLR(r) (r).dfe_vga_ctrl5[0] = 0
#define BCMI_TSC_XGXS_DFE_VGA_CTRL5r_SET(r,d) (r).dfe_vga_ctrl5[0] = d
#define BCMI_TSC_XGXS_DFE_VGA_CTRL5r_GET(r) (r).dfe_vga_ctrl5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_DFE_VGA_CTRL5r_RESERVED0f_GET(r) ((((r).dfe_vga_ctrl5[0]) >> 10) & 0x3f)
#define BCMI_TSC_XGXS_DFE_VGA_CTRL5r_RESERVED0f_SET(r,f) (r).dfe_vga_ctrl5[0]=(((r).dfe_vga_ctrl5[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))
#define BCMI_TSC_XGXS_DFE_VGA_CTRL5r_VGA_COR_SEL_Ef_GET(r) ((((r).dfe_vga_ctrl5[0]) >> 5) & 0x1f)
#define BCMI_TSC_XGXS_DFE_VGA_CTRL5r_VGA_COR_SEL_Ef_SET(r,f) (r).dfe_vga_ctrl5[0]=(((r).dfe_vga_ctrl5[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5))
#define BCMI_TSC_XGXS_DFE_VGA_CTRL5r_VGA_COR_SEL_Of_GET(r) (((r).dfe_vga_ctrl5[0]) & 0x1f)
#define BCMI_TSC_XGXS_DFE_VGA_CTRL5r_VGA_COR_SEL_Of_SET(r,f) (r).dfe_vga_ctrl5[0]=(((r).dfe_vga_ctrl5[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))

/*
 * These macros can be used to access DFE_VGA_CTRL5.
 *
 */
#define BCMI_TSC_XGXS_READ_DFE_VGA_CTRL5r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_DFE_VGA_CTRL5r,(_r._dfe_vga_ctrl5))
#define BCMI_TSC_XGXS_WRITE_DFE_VGA_CTRL5r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_DFE_VGA_CTRL5r,(_r._dfe_vga_ctrl5))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DFE_VGA_CTRL5r BCMI_TSC_XGXS_DFE_VGA_CTRL5r
#define DFE_VGA_CTRL5r_SIZE BCMI_TSC_XGXS_DFE_VGA_CTRL5r_SIZE
typedef BCMI_TSC_XGXS_DFE_VGA_CTRL5r_t DFE_VGA_CTRL5r_t;
#define DFE_VGA_CTRL5r_CLR BCMI_TSC_XGXS_DFE_VGA_CTRL5r_CLR
#define DFE_VGA_CTRL5r_SET BCMI_TSC_XGXS_DFE_VGA_CTRL5r_SET
#define DFE_VGA_CTRL5r_GET BCMI_TSC_XGXS_DFE_VGA_CTRL5r_GET
#define DFE_VGA_CTRL5r_RESERVED0f_GET BCMI_TSC_XGXS_DFE_VGA_CTRL5r_RESERVED0f_GET
#define DFE_VGA_CTRL5r_RESERVED0f_SET BCMI_TSC_XGXS_DFE_VGA_CTRL5r_RESERVED0f_SET
#define DFE_VGA_CTRL5r_VGA_COR_SEL_Ef_GET BCMI_TSC_XGXS_DFE_VGA_CTRL5r_VGA_COR_SEL_Ef_GET
#define DFE_VGA_CTRL5r_VGA_COR_SEL_Ef_SET BCMI_TSC_XGXS_DFE_VGA_CTRL5r_VGA_COR_SEL_Ef_SET
#define DFE_VGA_CTRL5r_VGA_COR_SEL_Of_GET BCMI_TSC_XGXS_DFE_VGA_CTRL5r_VGA_COR_SEL_Of_GET
#define DFE_VGA_CTRL5r_VGA_COR_SEL_Of_SET BCMI_TSC_XGXS_DFE_VGA_CTRL5r_VGA_COR_SEL_Of_SET
#define READ_DFE_VGA_CTRL5r BCMI_TSC_XGXS_READ_DFE_VGA_CTRL5r
#define WRITE_DFE_VGA_CTRL5r BCMI_TSC_XGXS_WRITE_DFE_VGA_CTRL5r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_DFE_VGA_CTRL5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  DFE_VGA_CTRL6
 * BLOCKS:   DSC1B0
 * REGADDR:  0xc20b
 * DESC:     DFE VGA Control 6 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     DFE_COR_SEL_O    
 *     DFE_COR_SEL_E    
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_DFE_VGA_CTRL6r (0x0000c20b | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_DFE_VGA_CTRL6r_SIZE 4

/*
 * This structure should be used to declare and program DFE_VGA_CTRL6.
 *
 */
typedef union BCMI_TSC_XGXS_DFE_VGA_CTRL6r_s {
	uint32_t v[1];
	uint32_t dfe_vga_ctrl6[1];
	uint32_t _dfe_vga_ctrl6;
} BCMI_TSC_XGXS_DFE_VGA_CTRL6r_t;

#define BCMI_TSC_XGXS_DFE_VGA_CTRL6r_CLR(r) (r).dfe_vga_ctrl6[0] = 0
#define BCMI_TSC_XGXS_DFE_VGA_CTRL6r_SET(r,d) (r).dfe_vga_ctrl6[0] = d
#define BCMI_TSC_XGXS_DFE_VGA_CTRL6r_GET(r) (r).dfe_vga_ctrl6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_DFE_VGA_CTRL6r_RESERVED0f_GET(r) ((((r).dfe_vga_ctrl6[0]) >> 10) & 0x3f)
#define BCMI_TSC_XGXS_DFE_VGA_CTRL6r_RESERVED0f_SET(r,f) (r).dfe_vga_ctrl6[0]=(((r).dfe_vga_ctrl6[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))
#define BCMI_TSC_XGXS_DFE_VGA_CTRL6r_DFE_COR_SEL_Ef_GET(r) ((((r).dfe_vga_ctrl6[0]) >> 5) & 0x1f)
#define BCMI_TSC_XGXS_DFE_VGA_CTRL6r_DFE_COR_SEL_Ef_SET(r,f) (r).dfe_vga_ctrl6[0]=(((r).dfe_vga_ctrl6[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5))
#define BCMI_TSC_XGXS_DFE_VGA_CTRL6r_DFE_COR_SEL_Of_GET(r) (((r).dfe_vga_ctrl6[0]) & 0x1f)
#define BCMI_TSC_XGXS_DFE_VGA_CTRL6r_DFE_COR_SEL_Of_SET(r,f) (r).dfe_vga_ctrl6[0]=(((r).dfe_vga_ctrl6[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))

/*
 * These macros can be used to access DFE_VGA_CTRL6.
 *
 */
#define BCMI_TSC_XGXS_READ_DFE_VGA_CTRL6r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_DFE_VGA_CTRL6r,(_r._dfe_vga_ctrl6))
#define BCMI_TSC_XGXS_WRITE_DFE_VGA_CTRL6r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_DFE_VGA_CTRL6r,(_r._dfe_vga_ctrl6))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DFE_VGA_CTRL6r BCMI_TSC_XGXS_DFE_VGA_CTRL6r
#define DFE_VGA_CTRL6r_SIZE BCMI_TSC_XGXS_DFE_VGA_CTRL6r_SIZE
typedef BCMI_TSC_XGXS_DFE_VGA_CTRL6r_t DFE_VGA_CTRL6r_t;
#define DFE_VGA_CTRL6r_CLR BCMI_TSC_XGXS_DFE_VGA_CTRL6r_CLR
#define DFE_VGA_CTRL6r_SET BCMI_TSC_XGXS_DFE_VGA_CTRL6r_SET
#define DFE_VGA_CTRL6r_GET BCMI_TSC_XGXS_DFE_VGA_CTRL6r_GET
#define DFE_VGA_CTRL6r_RESERVED0f_GET BCMI_TSC_XGXS_DFE_VGA_CTRL6r_RESERVED0f_GET
#define DFE_VGA_CTRL6r_RESERVED0f_SET BCMI_TSC_XGXS_DFE_VGA_CTRL6r_RESERVED0f_SET
#define DFE_VGA_CTRL6r_DFE_COR_SEL_Ef_GET BCMI_TSC_XGXS_DFE_VGA_CTRL6r_DFE_COR_SEL_Ef_GET
#define DFE_VGA_CTRL6r_DFE_COR_SEL_Ef_SET BCMI_TSC_XGXS_DFE_VGA_CTRL6r_DFE_COR_SEL_Ef_SET
#define DFE_VGA_CTRL6r_DFE_COR_SEL_Of_GET BCMI_TSC_XGXS_DFE_VGA_CTRL6r_DFE_COR_SEL_Of_GET
#define DFE_VGA_CTRL6r_DFE_COR_SEL_Of_SET BCMI_TSC_XGXS_DFE_VGA_CTRL6r_DFE_COR_SEL_Of_SET
#define READ_DFE_VGA_CTRL6r BCMI_TSC_XGXS_READ_DFE_VGA_CTRL6r
#define WRITE_DFE_VGA_CTRL6r BCMI_TSC_XGXS_WRITE_DFE_VGA_CTRL6r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_DFE_VGA_CTRL6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  DFE_VGA_CTRL7
 * BLOCKS:   DSC1B0
 * REGADDR:  0xc20c
 * DESC:     DFE VGA Control 7 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     PATTERN_EN       
 *     PATTERN_BIT_EN   
 *     PATTERN          
 *     DISABLE_CL72_RCVING_CTRL_FRAME 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_DFE_VGA_CTRL7r (0x0000c20c | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_DFE_VGA_CTRL7r_SIZE 4

/*
 * This structure should be used to declare and program DFE_VGA_CTRL7.
 *
 */
typedef union BCMI_TSC_XGXS_DFE_VGA_CTRL7r_s {
	uint32_t v[1];
	uint32_t dfe_vga_ctrl7[1];
	uint32_t _dfe_vga_ctrl7;
} BCMI_TSC_XGXS_DFE_VGA_CTRL7r_t;

#define BCMI_TSC_XGXS_DFE_VGA_CTRL7r_CLR(r) (r).dfe_vga_ctrl7[0] = 0
#define BCMI_TSC_XGXS_DFE_VGA_CTRL7r_SET(r,d) (r).dfe_vga_ctrl7[0] = d
#define BCMI_TSC_XGXS_DFE_VGA_CTRL7r_GET(r) (r).dfe_vga_ctrl7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_DFE_VGA_CTRL7r_DISABLE_CL72_RCVING_CTRL_FRAMEf_GET(r) ((((r).dfe_vga_ctrl7[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_DFE_VGA_CTRL7r_DISABLE_CL72_RCVING_CTRL_FRAMEf_SET(r,f) (r).dfe_vga_ctrl7[0]=(((r).dfe_vga_ctrl7[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_DFE_VGA_CTRL7r_PATTERNf_GET(r) ((((r).dfe_vga_ctrl7[0]) >> 8) & 0x7f)
#define BCMI_TSC_XGXS_DFE_VGA_CTRL7r_PATTERNf_SET(r,f) (r).dfe_vga_ctrl7[0]=(((r).dfe_vga_ctrl7[0] & ~((uint32_t)0x7f << 8)) | ((((uint32_t)f) & 0x7f) << 8))
#define BCMI_TSC_XGXS_DFE_VGA_CTRL7r_PATTERN_BIT_ENf_GET(r) ((((r).dfe_vga_ctrl7[0]) >> 1) & 0x7f)
#define BCMI_TSC_XGXS_DFE_VGA_CTRL7r_PATTERN_BIT_ENf_SET(r,f) (r).dfe_vga_ctrl7[0]=(((r).dfe_vga_ctrl7[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))
#define BCMI_TSC_XGXS_DFE_VGA_CTRL7r_PATTERN_ENf_GET(r) (((r).dfe_vga_ctrl7[0]) & 0x1)
#define BCMI_TSC_XGXS_DFE_VGA_CTRL7r_PATTERN_ENf_SET(r,f) (r).dfe_vga_ctrl7[0]=(((r).dfe_vga_ctrl7[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access DFE_VGA_CTRL7.
 *
 */
#define BCMI_TSC_XGXS_READ_DFE_VGA_CTRL7r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_DFE_VGA_CTRL7r,(_r._dfe_vga_ctrl7))
#define BCMI_TSC_XGXS_WRITE_DFE_VGA_CTRL7r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_DFE_VGA_CTRL7r,(_r._dfe_vga_ctrl7))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DFE_VGA_CTRL7r BCMI_TSC_XGXS_DFE_VGA_CTRL7r
#define DFE_VGA_CTRL7r_SIZE BCMI_TSC_XGXS_DFE_VGA_CTRL7r_SIZE
typedef BCMI_TSC_XGXS_DFE_VGA_CTRL7r_t DFE_VGA_CTRL7r_t;
#define DFE_VGA_CTRL7r_CLR BCMI_TSC_XGXS_DFE_VGA_CTRL7r_CLR
#define DFE_VGA_CTRL7r_SET BCMI_TSC_XGXS_DFE_VGA_CTRL7r_SET
#define DFE_VGA_CTRL7r_GET BCMI_TSC_XGXS_DFE_VGA_CTRL7r_GET
#define DFE_VGA_CTRL7r_DISABLE_CL72_RCVING_CTRL_FRAMEf_GET BCMI_TSC_XGXS_DFE_VGA_CTRL7r_DISABLE_CL72_RCVING_CTRL_FRAMEf_GET
#define DFE_VGA_CTRL7r_DISABLE_CL72_RCVING_CTRL_FRAMEf_SET BCMI_TSC_XGXS_DFE_VGA_CTRL7r_DISABLE_CL72_RCVING_CTRL_FRAMEf_SET
#define DFE_VGA_CTRL7r_PATTERNf_GET BCMI_TSC_XGXS_DFE_VGA_CTRL7r_PATTERNf_GET
#define DFE_VGA_CTRL7r_PATTERNf_SET BCMI_TSC_XGXS_DFE_VGA_CTRL7r_PATTERNf_SET
#define DFE_VGA_CTRL7r_PATTERN_BIT_ENf_GET BCMI_TSC_XGXS_DFE_VGA_CTRL7r_PATTERN_BIT_ENf_GET
#define DFE_VGA_CTRL7r_PATTERN_BIT_ENf_SET BCMI_TSC_XGXS_DFE_VGA_CTRL7r_PATTERN_BIT_ENf_SET
#define DFE_VGA_CTRL7r_PATTERN_ENf_GET BCMI_TSC_XGXS_DFE_VGA_CTRL7r_PATTERN_ENf_GET
#define DFE_VGA_CTRL7r_PATTERN_ENf_SET BCMI_TSC_XGXS_DFE_VGA_CTRL7r_PATTERN_ENf_SET
#define READ_DFE_VGA_CTRL7r BCMI_TSC_XGXS_READ_DFE_VGA_CTRL7r
#define WRITE_DFE_VGA_CTRL7r BCMI_TSC_XGXS_WRITE_DFE_VGA_CTRL7r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_DFE_VGA_CTRL7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  DSC_DIAG_CTRL0
 * BLOCKS:   DSC1B0
 * REGADDR:  0xc20d
 * DESC:     DSC Diagnostics Control 0 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     DIAGNOSTICS_EN   
 *     HOFFSET          
 *     VOFFSET          
 *     OSX2_DIAG_CTRL   
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_DSC_DIAG_CTRL0r (0x0000c20d | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_DSC_DIAG_CTRL0r_SIZE 4

/*
 * This structure should be used to declare and program DSC_DIAG_CTRL0.
 *
 */
typedef union BCMI_TSC_XGXS_DSC_DIAG_CTRL0r_s {
	uint32_t v[1];
	uint32_t dsc_diag_ctrl0[1];
	uint32_t _dsc_diag_ctrl0;
} BCMI_TSC_XGXS_DSC_DIAG_CTRL0r_t;

#define BCMI_TSC_XGXS_DSC_DIAG_CTRL0r_CLR(r) (r).dsc_diag_ctrl0[0] = 0
#define BCMI_TSC_XGXS_DSC_DIAG_CTRL0r_SET(r,d) (r).dsc_diag_ctrl0[0] = d
#define BCMI_TSC_XGXS_DSC_DIAG_CTRL0r_GET(r) (r).dsc_diag_ctrl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_DSC_DIAG_CTRL0r_RESERVED0f_GET(r) ((((r).dsc_diag_ctrl0[0]) >> 12) & 0xf)
#define BCMI_TSC_XGXS_DSC_DIAG_CTRL0r_RESERVED0f_SET(r,f) (r).dsc_diag_ctrl0[0]=(((r).dsc_diag_ctrl0[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCMI_TSC_XGXS_DSC_DIAG_CTRL0r_OSX2_DIAG_CTRLf_GET(r) ((((r).dsc_diag_ctrl0[0]) >> 11) & 0x1)
#define BCMI_TSC_XGXS_DSC_DIAG_CTRL0r_OSX2_DIAG_CTRLf_SET(r,f) (r).dsc_diag_ctrl0[0]=(((r).dsc_diag_ctrl0[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCMI_TSC_XGXS_DSC_DIAG_CTRL0r_VOFFSETf_GET(r) ((((r).dsc_diag_ctrl0[0]) >> 7) & 0xf)
#define BCMI_TSC_XGXS_DSC_DIAG_CTRL0r_VOFFSETf_SET(r,f) (r).dsc_diag_ctrl0[0]=(((r).dsc_diag_ctrl0[0] & ~((uint32_t)0xf << 7)) | ((((uint32_t)f) & 0xf) << 7))
#define BCMI_TSC_XGXS_DSC_DIAG_CTRL0r_HOFFSETf_GET(r) ((((r).dsc_diag_ctrl0[0]) >> 1) & 0x3f)
#define BCMI_TSC_XGXS_DSC_DIAG_CTRL0r_HOFFSETf_SET(r,f) (r).dsc_diag_ctrl0[0]=(((r).dsc_diag_ctrl0[0] & ~((uint32_t)0x3f << 1)) | ((((uint32_t)f) & 0x3f) << 1))
#define BCMI_TSC_XGXS_DSC_DIAG_CTRL0r_DIAGNOSTICS_ENf_GET(r) (((r).dsc_diag_ctrl0[0]) & 0x1)
#define BCMI_TSC_XGXS_DSC_DIAG_CTRL0r_DIAGNOSTICS_ENf_SET(r,f) (r).dsc_diag_ctrl0[0]=(((r).dsc_diag_ctrl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access DSC_DIAG_CTRL0.
 *
 */
#define BCMI_TSC_XGXS_READ_DSC_DIAG_CTRL0r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_DSC_DIAG_CTRL0r,(_r._dsc_diag_ctrl0))
#define BCMI_TSC_XGXS_WRITE_DSC_DIAG_CTRL0r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_DSC_DIAG_CTRL0r,(_r._dsc_diag_ctrl0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_DIAG_CTRL0r BCMI_TSC_XGXS_DSC_DIAG_CTRL0r
#define DSC_DIAG_CTRL0r_SIZE BCMI_TSC_XGXS_DSC_DIAG_CTRL0r_SIZE
typedef BCMI_TSC_XGXS_DSC_DIAG_CTRL0r_t DSC_DIAG_CTRL0r_t;
#define DSC_DIAG_CTRL0r_CLR BCMI_TSC_XGXS_DSC_DIAG_CTRL0r_CLR
#define DSC_DIAG_CTRL0r_SET BCMI_TSC_XGXS_DSC_DIAG_CTRL0r_SET
#define DSC_DIAG_CTRL0r_GET BCMI_TSC_XGXS_DSC_DIAG_CTRL0r_GET
#define DSC_DIAG_CTRL0r_RESERVED0f_GET BCMI_TSC_XGXS_DSC_DIAG_CTRL0r_RESERVED0f_GET
#define DSC_DIAG_CTRL0r_RESERVED0f_SET BCMI_TSC_XGXS_DSC_DIAG_CTRL0r_RESERVED0f_SET
#define DSC_DIAG_CTRL0r_OSX2_DIAG_CTRLf_GET BCMI_TSC_XGXS_DSC_DIAG_CTRL0r_OSX2_DIAG_CTRLf_GET
#define DSC_DIAG_CTRL0r_OSX2_DIAG_CTRLf_SET BCMI_TSC_XGXS_DSC_DIAG_CTRL0r_OSX2_DIAG_CTRLf_SET
#define DSC_DIAG_CTRL0r_VOFFSETf_GET BCMI_TSC_XGXS_DSC_DIAG_CTRL0r_VOFFSETf_GET
#define DSC_DIAG_CTRL0r_VOFFSETf_SET BCMI_TSC_XGXS_DSC_DIAG_CTRL0r_VOFFSETf_SET
#define DSC_DIAG_CTRL0r_HOFFSETf_GET BCMI_TSC_XGXS_DSC_DIAG_CTRL0r_HOFFSETf_GET
#define DSC_DIAG_CTRL0r_HOFFSETf_SET BCMI_TSC_XGXS_DSC_DIAG_CTRL0r_HOFFSETf_SET
#define DSC_DIAG_CTRL0r_DIAGNOSTICS_ENf_GET BCMI_TSC_XGXS_DSC_DIAG_CTRL0r_DIAGNOSTICS_ENf_GET
#define DSC_DIAG_CTRL0r_DIAGNOSTICS_ENf_SET BCMI_TSC_XGXS_DSC_DIAG_CTRL0r_DIAGNOSTICS_ENf_SET
#define READ_DSC_DIAG_CTRL0r BCMI_TSC_XGXS_READ_DSC_DIAG_CTRL0r
#define WRITE_DSC_DIAG_CTRL0r BCMI_TSC_XGXS_WRITE_DSC_DIAG_CTRL0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_DSC_DIAG_CTRL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  UC_CTRL
 * BLOCKS:   DSC1B0
 * REGADDR:  0xc20e
 * DESC:     DSC to uController Control Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     GP_UC_REQ        
 *     CMD_INFO         
 *     ERROR_FOUND      
 *     READY_FOR_CMD    
 *     SUPPLEMENT_INFO  
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_UC_CTRLr (0x0000c20e | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_UC_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program UC_CTRL.
 *
 */
typedef union BCMI_TSC_XGXS_UC_CTRLr_s {
	uint32_t v[1];
	uint32_t uc_ctrl[1];
	uint32_t _uc_ctrl;
} BCMI_TSC_XGXS_UC_CTRLr_t;

#define BCMI_TSC_XGXS_UC_CTRLr_CLR(r) (r).uc_ctrl[0] = 0
#define BCMI_TSC_XGXS_UC_CTRLr_SET(r,d) (r).uc_ctrl[0] = d
#define BCMI_TSC_XGXS_UC_CTRLr_GET(r) (r).uc_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_UC_CTRLr_SUPPLEMENT_INFOf_GET(r) ((((r).uc_ctrl[0]) >> 8) & 0xff)
#define BCMI_TSC_XGXS_UC_CTRLr_SUPPLEMENT_INFOf_SET(r,f) (r).uc_ctrl[0]=(((r).uc_ctrl[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCMI_TSC_XGXS_UC_CTRLr_READY_FOR_CMDf_GET(r) ((((r).uc_ctrl[0]) >> 7) & 0x1)
#define BCMI_TSC_XGXS_UC_CTRLr_READY_FOR_CMDf_SET(r,f) (r).uc_ctrl[0]=(((r).uc_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCMI_TSC_XGXS_UC_CTRLr_ERROR_FOUNDf_GET(r) ((((r).uc_ctrl[0]) >> 6) & 0x1)
#define BCMI_TSC_XGXS_UC_CTRLr_ERROR_FOUNDf_SET(r,f) (r).uc_ctrl[0]=(((r).uc_ctrl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCMI_TSC_XGXS_UC_CTRLr_CMD_INFOf_GET(r) ((((r).uc_ctrl[0]) >> 4) & 0x3)
#define BCMI_TSC_XGXS_UC_CTRLr_CMD_INFOf_SET(r,f) (r).uc_ctrl[0]=(((r).uc_ctrl[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCMI_TSC_XGXS_UC_CTRLr_GP_UC_REQf_GET(r) (((r).uc_ctrl[0]) & 0xf)
#define BCMI_TSC_XGXS_UC_CTRLr_GP_UC_REQf_SET(r,f) (r).uc_ctrl[0]=(((r).uc_ctrl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access UC_CTRL.
 *
 */
#define BCMI_TSC_XGXS_READ_UC_CTRLr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_UC_CTRLr,(_r._uc_ctrl))
#define BCMI_TSC_XGXS_WRITE_UC_CTRLr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_UC_CTRLr,(_r._uc_ctrl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define UC_CTRLr BCMI_TSC_XGXS_UC_CTRLr
#define UC_CTRLr_SIZE BCMI_TSC_XGXS_UC_CTRLr_SIZE
typedef BCMI_TSC_XGXS_UC_CTRLr_t UC_CTRLr_t;
#define UC_CTRLr_CLR BCMI_TSC_XGXS_UC_CTRLr_CLR
#define UC_CTRLr_SET BCMI_TSC_XGXS_UC_CTRLr_SET
#define UC_CTRLr_GET BCMI_TSC_XGXS_UC_CTRLr_GET
#define UC_CTRLr_SUPPLEMENT_INFOf_GET BCMI_TSC_XGXS_UC_CTRLr_SUPPLEMENT_INFOf_GET
#define UC_CTRLr_SUPPLEMENT_INFOf_SET BCMI_TSC_XGXS_UC_CTRLr_SUPPLEMENT_INFOf_SET
#define UC_CTRLr_READY_FOR_CMDf_GET BCMI_TSC_XGXS_UC_CTRLr_READY_FOR_CMDf_GET
#define UC_CTRLr_READY_FOR_CMDf_SET BCMI_TSC_XGXS_UC_CTRLr_READY_FOR_CMDf_SET
#define UC_CTRLr_ERROR_FOUNDf_GET BCMI_TSC_XGXS_UC_CTRLr_ERROR_FOUNDf_GET
#define UC_CTRLr_ERROR_FOUNDf_SET BCMI_TSC_XGXS_UC_CTRLr_ERROR_FOUNDf_SET
#define UC_CTRLr_CMD_INFOf_GET BCMI_TSC_XGXS_UC_CTRLr_CMD_INFOf_GET
#define UC_CTRLr_CMD_INFOf_SET BCMI_TSC_XGXS_UC_CTRLr_CMD_INFOf_SET
#define UC_CTRLr_GP_UC_REQf_GET BCMI_TSC_XGXS_UC_CTRLr_GP_UC_REQf_GET
#define UC_CTRLr_GP_UC_REQf_SET BCMI_TSC_XGXS_UC_CTRLr_GP_UC_REQf_SET
#define READ_UC_CTRLr BCMI_TSC_XGXS_READ_UC_CTRLr
#define WRITE_UC_CTRLr BCMI_TSC_XGXS_WRITE_UC_CTRLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_UC_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  ACQ_SM_CTRL0
 * BLOCKS:   DSC2B0
 * REGADDR:  0xc210
 * DESC:     DSC State Machine Control 0 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     ACQCDR_TIMEOUT   
 *     ACQ1_TIMEOUT     
 *     ACQ2_TIMEOUT     
 *     CL72_TIMER_EN    
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_ACQ_SM_CTRL0r (0x0000c210 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_ACQ_SM_CTRL0r_SIZE 4

/*
 * This structure should be used to declare and program ACQ_SM_CTRL0.
 *
 */
typedef union BCMI_TSC_XGXS_ACQ_SM_CTRL0r_s {
	uint32_t v[1];
	uint32_t acq_sm_ctrl0[1];
	uint32_t _acq_sm_ctrl0;
} BCMI_TSC_XGXS_ACQ_SM_CTRL0r_t;

#define BCMI_TSC_XGXS_ACQ_SM_CTRL0r_CLR(r) (r).acq_sm_ctrl0[0] = 0
#define BCMI_TSC_XGXS_ACQ_SM_CTRL0r_SET(r,d) (r).acq_sm_ctrl0[0] = d
#define BCMI_TSC_XGXS_ACQ_SM_CTRL0r_GET(r) (r).acq_sm_ctrl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_ACQ_SM_CTRL0r_CL72_TIMER_ENf_GET(r) ((((r).acq_sm_ctrl0[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_ACQ_SM_CTRL0r_CL72_TIMER_ENf_SET(r,f) (r).acq_sm_ctrl0[0]=(((r).acq_sm_ctrl0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_ACQ_SM_CTRL0r_ACQ2_TIMEOUTf_GET(r) ((((r).acq_sm_ctrl0[0]) >> 10) & 0x1f)
#define BCMI_TSC_XGXS_ACQ_SM_CTRL0r_ACQ2_TIMEOUTf_SET(r,f) (r).acq_sm_ctrl0[0]=(((r).acq_sm_ctrl0[0] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10))
#define BCMI_TSC_XGXS_ACQ_SM_CTRL0r_ACQ1_TIMEOUTf_GET(r) ((((r).acq_sm_ctrl0[0]) >> 5) & 0x1f)
#define BCMI_TSC_XGXS_ACQ_SM_CTRL0r_ACQ1_TIMEOUTf_SET(r,f) (r).acq_sm_ctrl0[0]=(((r).acq_sm_ctrl0[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5))
#define BCMI_TSC_XGXS_ACQ_SM_CTRL0r_ACQCDR_TIMEOUTf_GET(r) (((r).acq_sm_ctrl0[0]) & 0x1f)
#define BCMI_TSC_XGXS_ACQ_SM_CTRL0r_ACQCDR_TIMEOUTf_SET(r,f) (r).acq_sm_ctrl0[0]=(((r).acq_sm_ctrl0[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))

/*
 * These macros can be used to access ACQ_SM_CTRL0.
 *
 */
#define BCMI_TSC_XGXS_READ_ACQ_SM_CTRL0r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_ACQ_SM_CTRL0r,(_r._acq_sm_ctrl0))
#define BCMI_TSC_XGXS_WRITE_ACQ_SM_CTRL0r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_ACQ_SM_CTRL0r,(_r._acq_sm_ctrl0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define ACQ_SM_CTRL0r BCMI_TSC_XGXS_ACQ_SM_CTRL0r
#define ACQ_SM_CTRL0r_SIZE BCMI_TSC_XGXS_ACQ_SM_CTRL0r_SIZE
typedef BCMI_TSC_XGXS_ACQ_SM_CTRL0r_t ACQ_SM_CTRL0r_t;
#define ACQ_SM_CTRL0r_CLR BCMI_TSC_XGXS_ACQ_SM_CTRL0r_CLR
#define ACQ_SM_CTRL0r_SET BCMI_TSC_XGXS_ACQ_SM_CTRL0r_SET
#define ACQ_SM_CTRL0r_GET BCMI_TSC_XGXS_ACQ_SM_CTRL0r_GET
#define ACQ_SM_CTRL0r_CL72_TIMER_ENf_GET BCMI_TSC_XGXS_ACQ_SM_CTRL0r_CL72_TIMER_ENf_GET
#define ACQ_SM_CTRL0r_CL72_TIMER_ENf_SET BCMI_TSC_XGXS_ACQ_SM_CTRL0r_CL72_TIMER_ENf_SET
#define ACQ_SM_CTRL0r_ACQ2_TIMEOUTf_GET BCMI_TSC_XGXS_ACQ_SM_CTRL0r_ACQ2_TIMEOUTf_GET
#define ACQ_SM_CTRL0r_ACQ2_TIMEOUTf_SET BCMI_TSC_XGXS_ACQ_SM_CTRL0r_ACQ2_TIMEOUTf_SET
#define ACQ_SM_CTRL0r_ACQ1_TIMEOUTf_GET BCMI_TSC_XGXS_ACQ_SM_CTRL0r_ACQ1_TIMEOUTf_GET
#define ACQ_SM_CTRL0r_ACQ1_TIMEOUTf_SET BCMI_TSC_XGXS_ACQ_SM_CTRL0r_ACQ1_TIMEOUTf_SET
#define ACQ_SM_CTRL0r_ACQCDR_TIMEOUTf_GET BCMI_TSC_XGXS_ACQ_SM_CTRL0r_ACQCDR_TIMEOUTf_GET
#define ACQ_SM_CTRL0r_ACQCDR_TIMEOUTf_SET BCMI_TSC_XGXS_ACQ_SM_CTRL0r_ACQCDR_TIMEOUTf_SET
#define READ_ACQ_SM_CTRL0r BCMI_TSC_XGXS_READ_ACQ_SM_CTRL0r
#define WRITE_ACQ_SM_CTRL0r BCMI_TSC_XGXS_WRITE_ACQ_SM_CTRL0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_ACQ_SM_CTRL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  ACQ_SM_CTRL1
 * BLOCKS:   DSC2B0
 * REGADDR:  0xc211
 * DESC:     DSC State Machine Control 1 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     DSC_CLR_FRC      
 *     DSC_CLR_VAL      
 *     VGA_FRCFRZ       
 *     VGA_FRZVAL       
 *     DFE_FRCFRZ       
 *     DFE_FRZVAL       
 *     BYPASS_OS_INTEG_XFER 
 *     ACQVGA_TIMEOUT   
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_ACQ_SM_CTRL1r (0x0000c211 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_ACQ_SM_CTRL1r_SIZE 4

/*
 * This structure should be used to declare and program ACQ_SM_CTRL1.
 *
 */
typedef union BCMI_TSC_XGXS_ACQ_SM_CTRL1r_s {
	uint32_t v[1];
	uint32_t acq_sm_ctrl1[1];
	uint32_t _acq_sm_ctrl1;
} BCMI_TSC_XGXS_ACQ_SM_CTRL1r_t;

#define BCMI_TSC_XGXS_ACQ_SM_CTRL1r_CLR(r) (r).acq_sm_ctrl1[0] = 0
#define BCMI_TSC_XGXS_ACQ_SM_CTRL1r_SET(r,d) (r).acq_sm_ctrl1[0] = d
#define BCMI_TSC_XGXS_ACQ_SM_CTRL1r_GET(r) (r).acq_sm_ctrl1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_ACQ_SM_CTRL1r_ACQVGA_TIMEOUTf_GET(r) ((((r).acq_sm_ctrl1[0]) >> 11) & 0x1f)
#define BCMI_TSC_XGXS_ACQ_SM_CTRL1r_ACQVGA_TIMEOUTf_SET(r,f) (r).acq_sm_ctrl1[0]=(((r).acq_sm_ctrl1[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))
#define BCMI_TSC_XGXS_ACQ_SM_CTRL1r_BYPASS_OS_INTEG_XFERf_GET(r) ((((r).acq_sm_ctrl1[0]) >> 10) & 0x1)
#define BCMI_TSC_XGXS_ACQ_SM_CTRL1r_BYPASS_OS_INTEG_XFERf_SET(r,f) (r).acq_sm_ctrl1[0]=(((r).acq_sm_ctrl1[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCMI_TSC_XGXS_ACQ_SM_CTRL1r_DFE_FRZVALf_GET(r) ((((r).acq_sm_ctrl1[0]) >> 5) & 0x1f)
#define BCMI_TSC_XGXS_ACQ_SM_CTRL1r_DFE_FRZVALf_SET(r,f) (r).acq_sm_ctrl1[0]=(((r).acq_sm_ctrl1[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5))
#define BCMI_TSC_XGXS_ACQ_SM_CTRL1r_DFE_FRCFRZf_GET(r) ((((r).acq_sm_ctrl1[0]) >> 4) & 0x1)
#define BCMI_TSC_XGXS_ACQ_SM_CTRL1r_DFE_FRCFRZf_SET(r,f) (r).acq_sm_ctrl1[0]=(((r).acq_sm_ctrl1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCMI_TSC_XGXS_ACQ_SM_CTRL1r_VGA_FRZVALf_GET(r) ((((r).acq_sm_ctrl1[0]) >> 3) & 0x1)
#define BCMI_TSC_XGXS_ACQ_SM_CTRL1r_VGA_FRZVALf_SET(r,f) (r).acq_sm_ctrl1[0]=(((r).acq_sm_ctrl1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCMI_TSC_XGXS_ACQ_SM_CTRL1r_VGA_FRCFRZf_GET(r) ((((r).acq_sm_ctrl1[0]) >> 2) & 0x1)
#define BCMI_TSC_XGXS_ACQ_SM_CTRL1r_VGA_FRCFRZf_SET(r,f) (r).acq_sm_ctrl1[0]=(((r).acq_sm_ctrl1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCMI_TSC_XGXS_ACQ_SM_CTRL1r_DSC_CLR_VALf_GET(r) ((((r).acq_sm_ctrl1[0]) >> 1) & 0x1)
#define BCMI_TSC_XGXS_ACQ_SM_CTRL1r_DSC_CLR_VALf_SET(r,f) (r).acq_sm_ctrl1[0]=(((r).acq_sm_ctrl1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCMI_TSC_XGXS_ACQ_SM_CTRL1r_DSC_CLR_FRCf_GET(r) (((r).acq_sm_ctrl1[0]) & 0x1)
#define BCMI_TSC_XGXS_ACQ_SM_CTRL1r_DSC_CLR_FRCf_SET(r,f) (r).acq_sm_ctrl1[0]=(((r).acq_sm_ctrl1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access ACQ_SM_CTRL1.
 *
 */
#define BCMI_TSC_XGXS_READ_ACQ_SM_CTRL1r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_ACQ_SM_CTRL1r,(_r._acq_sm_ctrl1))
#define BCMI_TSC_XGXS_WRITE_ACQ_SM_CTRL1r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_ACQ_SM_CTRL1r,(_r._acq_sm_ctrl1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define ACQ_SM_CTRL1r BCMI_TSC_XGXS_ACQ_SM_CTRL1r
#define ACQ_SM_CTRL1r_SIZE BCMI_TSC_XGXS_ACQ_SM_CTRL1r_SIZE
typedef BCMI_TSC_XGXS_ACQ_SM_CTRL1r_t ACQ_SM_CTRL1r_t;
#define ACQ_SM_CTRL1r_CLR BCMI_TSC_XGXS_ACQ_SM_CTRL1r_CLR
#define ACQ_SM_CTRL1r_SET BCMI_TSC_XGXS_ACQ_SM_CTRL1r_SET
#define ACQ_SM_CTRL1r_GET BCMI_TSC_XGXS_ACQ_SM_CTRL1r_GET
#define ACQ_SM_CTRL1r_ACQVGA_TIMEOUTf_GET BCMI_TSC_XGXS_ACQ_SM_CTRL1r_ACQVGA_TIMEOUTf_GET
#define ACQ_SM_CTRL1r_ACQVGA_TIMEOUTf_SET BCMI_TSC_XGXS_ACQ_SM_CTRL1r_ACQVGA_TIMEOUTf_SET
#define ACQ_SM_CTRL1r_BYPASS_OS_INTEG_XFERf_GET BCMI_TSC_XGXS_ACQ_SM_CTRL1r_BYPASS_OS_INTEG_XFERf_GET
#define ACQ_SM_CTRL1r_BYPASS_OS_INTEG_XFERf_SET BCMI_TSC_XGXS_ACQ_SM_CTRL1r_BYPASS_OS_INTEG_XFERf_SET
#define ACQ_SM_CTRL1r_DFE_FRZVALf_GET BCMI_TSC_XGXS_ACQ_SM_CTRL1r_DFE_FRZVALf_GET
#define ACQ_SM_CTRL1r_DFE_FRZVALf_SET BCMI_TSC_XGXS_ACQ_SM_CTRL1r_DFE_FRZVALf_SET
#define ACQ_SM_CTRL1r_DFE_FRCFRZf_GET BCMI_TSC_XGXS_ACQ_SM_CTRL1r_DFE_FRCFRZf_GET
#define ACQ_SM_CTRL1r_DFE_FRCFRZf_SET BCMI_TSC_XGXS_ACQ_SM_CTRL1r_DFE_FRCFRZf_SET
#define ACQ_SM_CTRL1r_VGA_FRZVALf_GET BCMI_TSC_XGXS_ACQ_SM_CTRL1r_VGA_FRZVALf_GET
#define ACQ_SM_CTRL1r_VGA_FRZVALf_SET BCMI_TSC_XGXS_ACQ_SM_CTRL1r_VGA_FRZVALf_SET
#define ACQ_SM_CTRL1r_VGA_FRCFRZf_GET BCMI_TSC_XGXS_ACQ_SM_CTRL1r_VGA_FRCFRZf_GET
#define ACQ_SM_CTRL1r_VGA_FRCFRZf_SET BCMI_TSC_XGXS_ACQ_SM_CTRL1r_VGA_FRCFRZf_SET
#define ACQ_SM_CTRL1r_DSC_CLR_VALf_GET BCMI_TSC_XGXS_ACQ_SM_CTRL1r_DSC_CLR_VALf_GET
#define ACQ_SM_CTRL1r_DSC_CLR_VALf_SET BCMI_TSC_XGXS_ACQ_SM_CTRL1r_DSC_CLR_VALf_SET
#define ACQ_SM_CTRL1r_DSC_CLR_FRCf_GET BCMI_TSC_XGXS_ACQ_SM_CTRL1r_DSC_CLR_FRCf_GET
#define ACQ_SM_CTRL1r_DSC_CLR_FRCf_SET BCMI_TSC_XGXS_ACQ_SM_CTRL1r_DSC_CLR_FRCf_SET
#define READ_ACQ_SM_CTRL1r BCMI_TSC_XGXS_READ_ACQ_SM_CTRL1r
#define WRITE_ACQ_SM_CTRL1r BCMI_TSC_XGXS_WRITE_ACQ_SM_CTRL1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_ACQ_SM_CTRL1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  ACQ_SM_CTRL2
 * BLOCKS:   DSC2B0
 * REGADDR:  0xc212
 * DESC:     DSC State Machine Control 2 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     TRAIN_MODE_EN    
 *     SOFT_ACK         
 *     TRAIN1_REQ       
 *     TRAIN2_REQ       
 *     SKIP_ACQ         
 *     EEE_ACQ_PHASE_TIMEOUT 
 *     EEE_ACQ_2_TIMEOUT 
 *     SW_HANDOVER      
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_ACQ_SM_CTRL2r (0x0000c212 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_ACQ_SM_CTRL2r_SIZE 4

/*
 * This structure should be used to declare and program ACQ_SM_CTRL2.
 *
 */
typedef union BCMI_TSC_XGXS_ACQ_SM_CTRL2r_s {
	uint32_t v[1];
	uint32_t acq_sm_ctrl2[1];
	uint32_t _acq_sm_ctrl2;
} BCMI_TSC_XGXS_ACQ_SM_CTRL2r_t;

#define BCMI_TSC_XGXS_ACQ_SM_CTRL2r_CLR(r) (r).acq_sm_ctrl2[0] = 0
#define BCMI_TSC_XGXS_ACQ_SM_CTRL2r_SET(r,d) (r).acq_sm_ctrl2[0] = d
#define BCMI_TSC_XGXS_ACQ_SM_CTRL2r_GET(r) (r).acq_sm_ctrl2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_ACQ_SM_CTRL2r_SW_HANDOVERf_GET(r) ((((r).acq_sm_ctrl2[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_ACQ_SM_CTRL2r_SW_HANDOVERf_SET(r,f) (r).acq_sm_ctrl2[0]=(((r).acq_sm_ctrl2[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_ACQ_SM_CTRL2r_EEE_ACQ_2_TIMEOUTf_GET(r) ((((r).acq_sm_ctrl2[0]) >> 10) & 0x1f)
#define BCMI_TSC_XGXS_ACQ_SM_CTRL2r_EEE_ACQ_2_TIMEOUTf_SET(r,f) (r).acq_sm_ctrl2[0]=(((r).acq_sm_ctrl2[0] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10))
#define BCMI_TSC_XGXS_ACQ_SM_CTRL2r_EEE_ACQ_PHASE_TIMEOUTf_GET(r) ((((r).acq_sm_ctrl2[0]) >> 5) & 0x1f)
#define BCMI_TSC_XGXS_ACQ_SM_CTRL2r_EEE_ACQ_PHASE_TIMEOUTf_SET(r,f) (r).acq_sm_ctrl2[0]=(((r).acq_sm_ctrl2[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5))
#define BCMI_TSC_XGXS_ACQ_SM_CTRL2r_SKIP_ACQf_GET(r) ((((r).acq_sm_ctrl2[0]) >> 4) & 0x1)
#define BCMI_TSC_XGXS_ACQ_SM_CTRL2r_SKIP_ACQf_SET(r,f) (r).acq_sm_ctrl2[0]=(((r).acq_sm_ctrl2[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCMI_TSC_XGXS_ACQ_SM_CTRL2r_TRAIN2_REQf_GET(r) ((((r).acq_sm_ctrl2[0]) >> 3) & 0x1)
#define BCMI_TSC_XGXS_ACQ_SM_CTRL2r_TRAIN2_REQf_SET(r,f) (r).acq_sm_ctrl2[0]=(((r).acq_sm_ctrl2[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCMI_TSC_XGXS_ACQ_SM_CTRL2r_TRAIN1_REQf_GET(r) ((((r).acq_sm_ctrl2[0]) >> 2) & 0x1)
#define BCMI_TSC_XGXS_ACQ_SM_CTRL2r_TRAIN1_REQf_SET(r,f) (r).acq_sm_ctrl2[0]=(((r).acq_sm_ctrl2[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCMI_TSC_XGXS_ACQ_SM_CTRL2r_SOFT_ACKf_GET(r) ((((r).acq_sm_ctrl2[0]) >> 1) & 0x1)
#define BCMI_TSC_XGXS_ACQ_SM_CTRL2r_SOFT_ACKf_SET(r,f) (r).acq_sm_ctrl2[0]=(((r).acq_sm_ctrl2[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCMI_TSC_XGXS_ACQ_SM_CTRL2r_TRAIN_MODE_ENf_GET(r) (((r).acq_sm_ctrl2[0]) & 0x1)
#define BCMI_TSC_XGXS_ACQ_SM_CTRL2r_TRAIN_MODE_ENf_SET(r,f) (r).acq_sm_ctrl2[0]=(((r).acq_sm_ctrl2[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access ACQ_SM_CTRL2.
 *
 */
#define BCMI_TSC_XGXS_READ_ACQ_SM_CTRL2r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_ACQ_SM_CTRL2r,(_r._acq_sm_ctrl2))
#define BCMI_TSC_XGXS_WRITE_ACQ_SM_CTRL2r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_ACQ_SM_CTRL2r,(_r._acq_sm_ctrl2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define ACQ_SM_CTRL2r BCMI_TSC_XGXS_ACQ_SM_CTRL2r
#define ACQ_SM_CTRL2r_SIZE BCMI_TSC_XGXS_ACQ_SM_CTRL2r_SIZE
typedef BCMI_TSC_XGXS_ACQ_SM_CTRL2r_t ACQ_SM_CTRL2r_t;
#define ACQ_SM_CTRL2r_CLR BCMI_TSC_XGXS_ACQ_SM_CTRL2r_CLR
#define ACQ_SM_CTRL2r_SET BCMI_TSC_XGXS_ACQ_SM_CTRL2r_SET
#define ACQ_SM_CTRL2r_GET BCMI_TSC_XGXS_ACQ_SM_CTRL2r_GET
#define ACQ_SM_CTRL2r_SW_HANDOVERf_GET BCMI_TSC_XGXS_ACQ_SM_CTRL2r_SW_HANDOVERf_GET
#define ACQ_SM_CTRL2r_SW_HANDOVERf_SET BCMI_TSC_XGXS_ACQ_SM_CTRL2r_SW_HANDOVERf_SET
#define ACQ_SM_CTRL2r_EEE_ACQ_2_TIMEOUTf_GET BCMI_TSC_XGXS_ACQ_SM_CTRL2r_EEE_ACQ_2_TIMEOUTf_GET
#define ACQ_SM_CTRL2r_EEE_ACQ_2_TIMEOUTf_SET BCMI_TSC_XGXS_ACQ_SM_CTRL2r_EEE_ACQ_2_TIMEOUTf_SET
#define ACQ_SM_CTRL2r_EEE_ACQ_PHASE_TIMEOUTf_GET BCMI_TSC_XGXS_ACQ_SM_CTRL2r_EEE_ACQ_PHASE_TIMEOUTf_GET
#define ACQ_SM_CTRL2r_EEE_ACQ_PHASE_TIMEOUTf_SET BCMI_TSC_XGXS_ACQ_SM_CTRL2r_EEE_ACQ_PHASE_TIMEOUTf_SET
#define ACQ_SM_CTRL2r_SKIP_ACQf_GET BCMI_TSC_XGXS_ACQ_SM_CTRL2r_SKIP_ACQf_GET
#define ACQ_SM_CTRL2r_SKIP_ACQf_SET BCMI_TSC_XGXS_ACQ_SM_CTRL2r_SKIP_ACQf_SET
#define ACQ_SM_CTRL2r_TRAIN2_REQf_GET BCMI_TSC_XGXS_ACQ_SM_CTRL2r_TRAIN2_REQf_GET
#define ACQ_SM_CTRL2r_TRAIN2_REQf_SET BCMI_TSC_XGXS_ACQ_SM_CTRL2r_TRAIN2_REQf_SET
#define ACQ_SM_CTRL2r_TRAIN1_REQf_GET BCMI_TSC_XGXS_ACQ_SM_CTRL2r_TRAIN1_REQf_GET
#define ACQ_SM_CTRL2r_TRAIN1_REQf_SET BCMI_TSC_XGXS_ACQ_SM_CTRL2r_TRAIN1_REQf_SET
#define ACQ_SM_CTRL2r_SOFT_ACKf_GET BCMI_TSC_XGXS_ACQ_SM_CTRL2r_SOFT_ACKf_GET
#define ACQ_SM_CTRL2r_SOFT_ACKf_SET BCMI_TSC_XGXS_ACQ_SM_CTRL2r_SOFT_ACKf_SET
#define ACQ_SM_CTRL2r_TRAIN_MODE_ENf_GET BCMI_TSC_XGXS_ACQ_SM_CTRL2r_TRAIN_MODE_ENf_GET
#define ACQ_SM_CTRL2r_TRAIN_MODE_ENf_SET BCMI_TSC_XGXS_ACQ_SM_CTRL2r_TRAIN_MODE_ENf_SET
#define READ_ACQ_SM_CTRL2r BCMI_TSC_XGXS_READ_ACQ_SM_CTRL2r
#define WRITE_ACQ_SM_CTRL2r BCMI_TSC_XGXS_WRITE_ACQ_SM_CTRL2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_ACQ_SM_CTRL2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  ACQ_SM_CTRL3
 * BLOCKS:   DSC2B0
 * REGADDR:  0xc213
 * DESC:     DSC State Machine Control 3 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     VGA_GAIN_ACQVGA  
 *     VGA_GAIN_ACQCDR  
 *     VGA_GAIN_ACQ1    
 *     VGA_GAIN_ACQ2    
 *     DFE_GAIN_ACQ1    
 *     DFE_GAIN_ACQ2    
 *     DFE_TAPS2_5_EN   
 *     OS_DFE_EN        
 *     RESERVED0        
 *     PAUSE_LEVEL_TRIGGER_EN 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_ACQ_SM_CTRL3r (0x0000c213 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_ACQ_SM_CTRL3r_SIZE 4

/*
 * This structure should be used to declare and program ACQ_SM_CTRL3.
 *
 */
typedef union BCMI_TSC_XGXS_ACQ_SM_CTRL3r_s {
	uint32_t v[1];
	uint32_t acq_sm_ctrl3[1];
	uint32_t _acq_sm_ctrl3;
} BCMI_TSC_XGXS_ACQ_SM_CTRL3r_t;

#define BCMI_TSC_XGXS_ACQ_SM_CTRL3r_CLR(r) (r).acq_sm_ctrl3[0] = 0
#define BCMI_TSC_XGXS_ACQ_SM_CTRL3r_SET(r,d) (r).acq_sm_ctrl3[0] = d
#define BCMI_TSC_XGXS_ACQ_SM_CTRL3r_GET(r) (r).acq_sm_ctrl3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_ACQ_SM_CTRL3r_PAUSE_LEVEL_TRIGGER_ENf_GET(r) ((((r).acq_sm_ctrl3[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_ACQ_SM_CTRL3r_PAUSE_LEVEL_TRIGGER_ENf_SET(r,f) (r).acq_sm_ctrl3[0]=(((r).acq_sm_ctrl3[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_ACQ_SM_CTRL3r_RESERVED0f_GET(r) ((((r).acq_sm_ctrl3[0]) >> 14) & 0x1)
#define BCMI_TSC_XGXS_ACQ_SM_CTRL3r_RESERVED0f_SET(r,f) (r).acq_sm_ctrl3[0]=(((r).acq_sm_ctrl3[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCMI_TSC_XGXS_ACQ_SM_CTRL3r_OS_DFE_ENf_GET(r) ((((r).acq_sm_ctrl3[0]) >> 13) & 0x1)
#define BCMI_TSC_XGXS_ACQ_SM_CTRL3r_OS_DFE_ENf_SET(r,f) (r).acq_sm_ctrl3[0]=(((r).acq_sm_ctrl3[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCMI_TSC_XGXS_ACQ_SM_CTRL3r_DFE_TAPS2_5_ENf_GET(r) ((((r).acq_sm_ctrl3[0]) >> 12) & 0x1)
#define BCMI_TSC_XGXS_ACQ_SM_CTRL3r_DFE_TAPS2_5_ENf_SET(r,f) (r).acq_sm_ctrl3[0]=(((r).acq_sm_ctrl3[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCMI_TSC_XGXS_ACQ_SM_CTRL3r_DFE_GAIN_ACQ2f_GET(r) ((((r).acq_sm_ctrl3[0]) >> 10) & 0x3)
#define BCMI_TSC_XGXS_ACQ_SM_CTRL3r_DFE_GAIN_ACQ2f_SET(r,f) (r).acq_sm_ctrl3[0]=(((r).acq_sm_ctrl3[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCMI_TSC_XGXS_ACQ_SM_CTRL3r_DFE_GAIN_ACQ1f_GET(r) ((((r).acq_sm_ctrl3[0]) >> 8) & 0x3)
#define BCMI_TSC_XGXS_ACQ_SM_CTRL3r_DFE_GAIN_ACQ1f_SET(r,f) (r).acq_sm_ctrl3[0]=(((r).acq_sm_ctrl3[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCMI_TSC_XGXS_ACQ_SM_CTRL3r_VGA_GAIN_ACQ2f_GET(r) ((((r).acq_sm_ctrl3[0]) >> 6) & 0x3)
#define BCMI_TSC_XGXS_ACQ_SM_CTRL3r_VGA_GAIN_ACQ2f_SET(r,f) (r).acq_sm_ctrl3[0]=(((r).acq_sm_ctrl3[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCMI_TSC_XGXS_ACQ_SM_CTRL3r_VGA_GAIN_ACQ1f_GET(r) ((((r).acq_sm_ctrl3[0]) >> 4) & 0x3)
#define BCMI_TSC_XGXS_ACQ_SM_CTRL3r_VGA_GAIN_ACQ1f_SET(r,f) (r).acq_sm_ctrl3[0]=(((r).acq_sm_ctrl3[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCMI_TSC_XGXS_ACQ_SM_CTRL3r_VGA_GAIN_ACQCDRf_GET(r) ((((r).acq_sm_ctrl3[0]) >> 2) & 0x3)
#define BCMI_TSC_XGXS_ACQ_SM_CTRL3r_VGA_GAIN_ACQCDRf_SET(r,f) (r).acq_sm_ctrl3[0]=(((r).acq_sm_ctrl3[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCMI_TSC_XGXS_ACQ_SM_CTRL3r_VGA_GAIN_ACQVGAf_GET(r) (((r).acq_sm_ctrl3[0]) & 0x3)
#define BCMI_TSC_XGXS_ACQ_SM_CTRL3r_VGA_GAIN_ACQVGAf_SET(r,f) (r).acq_sm_ctrl3[0]=(((r).acq_sm_ctrl3[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))

/*
 * These macros can be used to access ACQ_SM_CTRL3.
 *
 */
#define BCMI_TSC_XGXS_READ_ACQ_SM_CTRL3r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_ACQ_SM_CTRL3r,(_r._acq_sm_ctrl3))
#define BCMI_TSC_XGXS_WRITE_ACQ_SM_CTRL3r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_ACQ_SM_CTRL3r,(_r._acq_sm_ctrl3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define ACQ_SM_CTRL3r BCMI_TSC_XGXS_ACQ_SM_CTRL3r
#define ACQ_SM_CTRL3r_SIZE BCMI_TSC_XGXS_ACQ_SM_CTRL3r_SIZE
typedef BCMI_TSC_XGXS_ACQ_SM_CTRL3r_t ACQ_SM_CTRL3r_t;
#define ACQ_SM_CTRL3r_CLR BCMI_TSC_XGXS_ACQ_SM_CTRL3r_CLR
#define ACQ_SM_CTRL3r_SET BCMI_TSC_XGXS_ACQ_SM_CTRL3r_SET
#define ACQ_SM_CTRL3r_GET BCMI_TSC_XGXS_ACQ_SM_CTRL3r_GET
#define ACQ_SM_CTRL3r_PAUSE_LEVEL_TRIGGER_ENf_GET BCMI_TSC_XGXS_ACQ_SM_CTRL3r_PAUSE_LEVEL_TRIGGER_ENf_GET
#define ACQ_SM_CTRL3r_PAUSE_LEVEL_TRIGGER_ENf_SET BCMI_TSC_XGXS_ACQ_SM_CTRL3r_PAUSE_LEVEL_TRIGGER_ENf_SET
#define ACQ_SM_CTRL3r_RESERVED0f_GET BCMI_TSC_XGXS_ACQ_SM_CTRL3r_RESERVED0f_GET
#define ACQ_SM_CTRL3r_RESERVED0f_SET BCMI_TSC_XGXS_ACQ_SM_CTRL3r_RESERVED0f_SET
#define ACQ_SM_CTRL3r_OS_DFE_ENf_GET BCMI_TSC_XGXS_ACQ_SM_CTRL3r_OS_DFE_ENf_GET
#define ACQ_SM_CTRL3r_OS_DFE_ENf_SET BCMI_TSC_XGXS_ACQ_SM_CTRL3r_OS_DFE_ENf_SET
#define ACQ_SM_CTRL3r_DFE_TAPS2_5_ENf_GET BCMI_TSC_XGXS_ACQ_SM_CTRL3r_DFE_TAPS2_5_ENf_GET
#define ACQ_SM_CTRL3r_DFE_TAPS2_5_ENf_SET BCMI_TSC_XGXS_ACQ_SM_CTRL3r_DFE_TAPS2_5_ENf_SET
#define ACQ_SM_CTRL3r_DFE_GAIN_ACQ2f_GET BCMI_TSC_XGXS_ACQ_SM_CTRL3r_DFE_GAIN_ACQ2f_GET
#define ACQ_SM_CTRL3r_DFE_GAIN_ACQ2f_SET BCMI_TSC_XGXS_ACQ_SM_CTRL3r_DFE_GAIN_ACQ2f_SET
#define ACQ_SM_CTRL3r_DFE_GAIN_ACQ1f_GET BCMI_TSC_XGXS_ACQ_SM_CTRL3r_DFE_GAIN_ACQ1f_GET
#define ACQ_SM_CTRL3r_DFE_GAIN_ACQ1f_SET BCMI_TSC_XGXS_ACQ_SM_CTRL3r_DFE_GAIN_ACQ1f_SET
#define ACQ_SM_CTRL3r_VGA_GAIN_ACQ2f_GET BCMI_TSC_XGXS_ACQ_SM_CTRL3r_VGA_GAIN_ACQ2f_GET
#define ACQ_SM_CTRL3r_VGA_GAIN_ACQ2f_SET BCMI_TSC_XGXS_ACQ_SM_CTRL3r_VGA_GAIN_ACQ2f_SET
#define ACQ_SM_CTRL3r_VGA_GAIN_ACQ1f_GET BCMI_TSC_XGXS_ACQ_SM_CTRL3r_VGA_GAIN_ACQ1f_GET
#define ACQ_SM_CTRL3r_VGA_GAIN_ACQ1f_SET BCMI_TSC_XGXS_ACQ_SM_CTRL3r_VGA_GAIN_ACQ1f_SET
#define ACQ_SM_CTRL3r_VGA_GAIN_ACQCDRf_GET BCMI_TSC_XGXS_ACQ_SM_CTRL3r_VGA_GAIN_ACQCDRf_GET
#define ACQ_SM_CTRL3r_VGA_GAIN_ACQCDRf_SET BCMI_TSC_XGXS_ACQ_SM_CTRL3r_VGA_GAIN_ACQCDRf_SET
#define ACQ_SM_CTRL3r_VGA_GAIN_ACQVGAf_GET BCMI_TSC_XGXS_ACQ_SM_CTRL3r_VGA_GAIN_ACQVGAf_GET
#define ACQ_SM_CTRL3r_VGA_GAIN_ACQVGAf_SET BCMI_TSC_XGXS_ACQ_SM_CTRL3r_VGA_GAIN_ACQVGAf_SET
#define READ_ACQ_SM_CTRL3r BCMI_TSC_XGXS_READ_ACQ_SM_CTRL3r
#define WRITE_ACQ_SM_CTRL3r BCMI_TSC_XGXS_WRITE_ACQ_SM_CTRL3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_ACQ_SM_CTRL3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  ACQ_SM_CTRL4
 * BLOCKS:   DSC2B0
 * REGADDR:  0xc214
 * DESC:     DSC State Machine Control 4 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     CDROS_BWSEL_PROP_ACQVGA 
 *     CDROS_BWSEL_PROP_ACQCDR 
 *     CDROS_BWSEL_PROP_ACQ1_2 
 *     CDROS38_BWSEL_PROP_OFFSET 
 *     CDROS45_BWSEL_PROP_OFFSET 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_ACQ_SM_CTRL4r (0x0000c214 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_ACQ_SM_CTRL4r_SIZE 4

/*
 * This structure should be used to declare and program ACQ_SM_CTRL4.
 *
 */
typedef union BCMI_TSC_XGXS_ACQ_SM_CTRL4r_s {
	uint32_t v[1];
	uint32_t acq_sm_ctrl4[1];
	uint32_t _acq_sm_ctrl4;
} BCMI_TSC_XGXS_ACQ_SM_CTRL4r_t;

#define BCMI_TSC_XGXS_ACQ_SM_CTRL4r_CLR(r) (r).acq_sm_ctrl4[0] = 0
#define BCMI_TSC_XGXS_ACQ_SM_CTRL4r_SET(r,d) (r).acq_sm_ctrl4[0] = d
#define BCMI_TSC_XGXS_ACQ_SM_CTRL4r_GET(r) (r).acq_sm_ctrl4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_ACQ_SM_CTRL4r_CDROS45_BWSEL_PROP_OFFSETf_GET(r) ((((r).acq_sm_ctrl4[0]) >> 14) & 0x3)
#define BCMI_TSC_XGXS_ACQ_SM_CTRL4r_CDROS45_BWSEL_PROP_OFFSETf_SET(r,f) (r).acq_sm_ctrl4[0]=(((r).acq_sm_ctrl4[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCMI_TSC_XGXS_ACQ_SM_CTRL4r_CDROS38_BWSEL_PROP_OFFSETf_GET(r) ((((r).acq_sm_ctrl4[0]) >> 12) & 0x3)
#define BCMI_TSC_XGXS_ACQ_SM_CTRL4r_CDROS38_BWSEL_PROP_OFFSETf_SET(r,f) (r).acq_sm_ctrl4[0]=(((r).acq_sm_ctrl4[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCMI_TSC_XGXS_ACQ_SM_CTRL4r_CDROS_BWSEL_PROP_ACQ1_2f_GET(r) ((((r).acq_sm_ctrl4[0]) >> 8) & 0xf)
#define BCMI_TSC_XGXS_ACQ_SM_CTRL4r_CDROS_BWSEL_PROP_ACQ1_2f_SET(r,f) (r).acq_sm_ctrl4[0]=(((r).acq_sm_ctrl4[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCMI_TSC_XGXS_ACQ_SM_CTRL4r_CDROS_BWSEL_PROP_ACQCDRf_GET(r) ((((r).acq_sm_ctrl4[0]) >> 4) & 0xf)
#define BCMI_TSC_XGXS_ACQ_SM_CTRL4r_CDROS_BWSEL_PROP_ACQCDRf_SET(r,f) (r).acq_sm_ctrl4[0]=(((r).acq_sm_ctrl4[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCMI_TSC_XGXS_ACQ_SM_CTRL4r_CDROS_BWSEL_PROP_ACQVGAf_GET(r) (((r).acq_sm_ctrl4[0]) & 0xf)
#define BCMI_TSC_XGXS_ACQ_SM_CTRL4r_CDROS_BWSEL_PROP_ACQVGAf_SET(r,f) (r).acq_sm_ctrl4[0]=(((r).acq_sm_ctrl4[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access ACQ_SM_CTRL4.
 *
 */
#define BCMI_TSC_XGXS_READ_ACQ_SM_CTRL4r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_ACQ_SM_CTRL4r,(_r._acq_sm_ctrl4))
#define BCMI_TSC_XGXS_WRITE_ACQ_SM_CTRL4r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_ACQ_SM_CTRL4r,(_r._acq_sm_ctrl4))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define ACQ_SM_CTRL4r BCMI_TSC_XGXS_ACQ_SM_CTRL4r
#define ACQ_SM_CTRL4r_SIZE BCMI_TSC_XGXS_ACQ_SM_CTRL4r_SIZE
typedef BCMI_TSC_XGXS_ACQ_SM_CTRL4r_t ACQ_SM_CTRL4r_t;
#define ACQ_SM_CTRL4r_CLR BCMI_TSC_XGXS_ACQ_SM_CTRL4r_CLR
#define ACQ_SM_CTRL4r_SET BCMI_TSC_XGXS_ACQ_SM_CTRL4r_SET
#define ACQ_SM_CTRL4r_GET BCMI_TSC_XGXS_ACQ_SM_CTRL4r_GET
#define ACQ_SM_CTRL4r_CDROS45_BWSEL_PROP_OFFSETf_GET BCMI_TSC_XGXS_ACQ_SM_CTRL4r_CDROS45_BWSEL_PROP_OFFSETf_GET
#define ACQ_SM_CTRL4r_CDROS45_BWSEL_PROP_OFFSETf_SET BCMI_TSC_XGXS_ACQ_SM_CTRL4r_CDROS45_BWSEL_PROP_OFFSETf_SET
#define ACQ_SM_CTRL4r_CDROS38_BWSEL_PROP_OFFSETf_GET BCMI_TSC_XGXS_ACQ_SM_CTRL4r_CDROS38_BWSEL_PROP_OFFSETf_GET
#define ACQ_SM_CTRL4r_CDROS38_BWSEL_PROP_OFFSETf_SET BCMI_TSC_XGXS_ACQ_SM_CTRL4r_CDROS38_BWSEL_PROP_OFFSETf_SET
#define ACQ_SM_CTRL4r_CDROS_BWSEL_PROP_ACQ1_2f_GET BCMI_TSC_XGXS_ACQ_SM_CTRL4r_CDROS_BWSEL_PROP_ACQ1_2f_GET
#define ACQ_SM_CTRL4r_CDROS_BWSEL_PROP_ACQ1_2f_SET BCMI_TSC_XGXS_ACQ_SM_CTRL4r_CDROS_BWSEL_PROP_ACQ1_2f_SET
#define ACQ_SM_CTRL4r_CDROS_BWSEL_PROP_ACQCDRf_GET BCMI_TSC_XGXS_ACQ_SM_CTRL4r_CDROS_BWSEL_PROP_ACQCDRf_GET
#define ACQ_SM_CTRL4r_CDROS_BWSEL_PROP_ACQCDRf_SET BCMI_TSC_XGXS_ACQ_SM_CTRL4r_CDROS_BWSEL_PROP_ACQCDRf_SET
#define ACQ_SM_CTRL4r_CDROS_BWSEL_PROP_ACQVGAf_GET BCMI_TSC_XGXS_ACQ_SM_CTRL4r_CDROS_BWSEL_PROP_ACQVGAf_GET
#define ACQ_SM_CTRL4r_CDROS_BWSEL_PROP_ACQVGAf_SET BCMI_TSC_XGXS_ACQ_SM_CTRL4r_CDROS_BWSEL_PROP_ACQVGAf_SET
#define READ_ACQ_SM_CTRL4r BCMI_TSC_XGXS_READ_ACQ_SM_CTRL4r
#define WRITE_ACQ_SM_CTRL4r BCMI_TSC_XGXS_WRITE_ACQ_SM_CTRL4r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_ACQ_SM_CTRL4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  ACQ_SM_CTRL5
 * BLOCKS:   DSC2B0
 * REGADDR:  0xc215
 * DESC:     DSC State Machine Control 5 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     CDROS_BWSEL_INTEG_ACQVGA 
 *     CDROS_BWSEL_INTEG_ACQCDR 
 *     CDROS_BWSEL_INTEG_ACQ1_2 
 *     CDROS_BWSEL_INTEG_EEE_ACQ2 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_ACQ_SM_CTRL5r (0x0000c215 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_ACQ_SM_CTRL5r_SIZE 4

/*
 * This structure should be used to declare and program ACQ_SM_CTRL5.
 *
 */
typedef union BCMI_TSC_XGXS_ACQ_SM_CTRL5r_s {
	uint32_t v[1];
	uint32_t acq_sm_ctrl5[1];
	uint32_t _acq_sm_ctrl5;
} BCMI_TSC_XGXS_ACQ_SM_CTRL5r_t;

#define BCMI_TSC_XGXS_ACQ_SM_CTRL5r_CLR(r) (r).acq_sm_ctrl5[0] = 0
#define BCMI_TSC_XGXS_ACQ_SM_CTRL5r_SET(r,d) (r).acq_sm_ctrl5[0] = d
#define BCMI_TSC_XGXS_ACQ_SM_CTRL5r_GET(r) (r).acq_sm_ctrl5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_ACQ_SM_CTRL5r_CDROS_BWSEL_INTEG_EEE_ACQ2f_GET(r) ((((r).acq_sm_ctrl5[0]) >> 12) & 0xf)
#define BCMI_TSC_XGXS_ACQ_SM_CTRL5r_CDROS_BWSEL_INTEG_EEE_ACQ2f_SET(r,f) (r).acq_sm_ctrl5[0]=(((r).acq_sm_ctrl5[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCMI_TSC_XGXS_ACQ_SM_CTRL5r_CDROS_BWSEL_INTEG_ACQ1_2f_GET(r) ((((r).acq_sm_ctrl5[0]) >> 8) & 0xf)
#define BCMI_TSC_XGXS_ACQ_SM_CTRL5r_CDROS_BWSEL_INTEG_ACQ1_2f_SET(r,f) (r).acq_sm_ctrl5[0]=(((r).acq_sm_ctrl5[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCMI_TSC_XGXS_ACQ_SM_CTRL5r_CDROS_BWSEL_INTEG_ACQCDRf_GET(r) ((((r).acq_sm_ctrl5[0]) >> 4) & 0xf)
#define BCMI_TSC_XGXS_ACQ_SM_CTRL5r_CDROS_BWSEL_INTEG_ACQCDRf_SET(r,f) (r).acq_sm_ctrl5[0]=(((r).acq_sm_ctrl5[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCMI_TSC_XGXS_ACQ_SM_CTRL5r_CDROS_BWSEL_INTEG_ACQVGAf_GET(r) (((r).acq_sm_ctrl5[0]) & 0xf)
#define BCMI_TSC_XGXS_ACQ_SM_CTRL5r_CDROS_BWSEL_INTEG_ACQVGAf_SET(r,f) (r).acq_sm_ctrl5[0]=(((r).acq_sm_ctrl5[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access ACQ_SM_CTRL5.
 *
 */
#define BCMI_TSC_XGXS_READ_ACQ_SM_CTRL5r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_ACQ_SM_CTRL5r,(_r._acq_sm_ctrl5))
#define BCMI_TSC_XGXS_WRITE_ACQ_SM_CTRL5r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_ACQ_SM_CTRL5r,(_r._acq_sm_ctrl5))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define ACQ_SM_CTRL5r BCMI_TSC_XGXS_ACQ_SM_CTRL5r
#define ACQ_SM_CTRL5r_SIZE BCMI_TSC_XGXS_ACQ_SM_CTRL5r_SIZE
typedef BCMI_TSC_XGXS_ACQ_SM_CTRL5r_t ACQ_SM_CTRL5r_t;
#define ACQ_SM_CTRL5r_CLR BCMI_TSC_XGXS_ACQ_SM_CTRL5r_CLR
#define ACQ_SM_CTRL5r_SET BCMI_TSC_XGXS_ACQ_SM_CTRL5r_SET
#define ACQ_SM_CTRL5r_GET BCMI_TSC_XGXS_ACQ_SM_CTRL5r_GET
#define ACQ_SM_CTRL5r_CDROS_BWSEL_INTEG_EEE_ACQ2f_GET BCMI_TSC_XGXS_ACQ_SM_CTRL5r_CDROS_BWSEL_INTEG_EEE_ACQ2f_GET
#define ACQ_SM_CTRL5r_CDROS_BWSEL_INTEG_EEE_ACQ2f_SET BCMI_TSC_XGXS_ACQ_SM_CTRL5r_CDROS_BWSEL_INTEG_EEE_ACQ2f_SET
#define ACQ_SM_CTRL5r_CDROS_BWSEL_INTEG_ACQ1_2f_GET BCMI_TSC_XGXS_ACQ_SM_CTRL5r_CDROS_BWSEL_INTEG_ACQ1_2f_GET
#define ACQ_SM_CTRL5r_CDROS_BWSEL_INTEG_ACQ1_2f_SET BCMI_TSC_XGXS_ACQ_SM_CTRL5r_CDROS_BWSEL_INTEG_ACQ1_2f_SET
#define ACQ_SM_CTRL5r_CDROS_BWSEL_INTEG_ACQCDRf_GET BCMI_TSC_XGXS_ACQ_SM_CTRL5r_CDROS_BWSEL_INTEG_ACQCDRf_GET
#define ACQ_SM_CTRL5r_CDROS_BWSEL_INTEG_ACQCDRf_SET BCMI_TSC_XGXS_ACQ_SM_CTRL5r_CDROS_BWSEL_INTEG_ACQCDRf_SET
#define ACQ_SM_CTRL5r_CDROS_BWSEL_INTEG_ACQVGAf_GET BCMI_TSC_XGXS_ACQ_SM_CTRL5r_CDROS_BWSEL_INTEG_ACQVGAf_GET
#define ACQ_SM_CTRL5r_CDROS_BWSEL_INTEG_ACQVGAf_SET BCMI_TSC_XGXS_ACQ_SM_CTRL5r_CDROS_BWSEL_INTEG_ACQVGAf_SET
#define READ_ACQ_SM_CTRL5r BCMI_TSC_XGXS_READ_ACQ_SM_CTRL5r
#define WRITE_ACQ_SM_CTRL5r BCMI_TSC_XGXS_WRITE_ACQ_SM_CTRL5r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_ACQ_SM_CTRL5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  ACQ_SM_CTRL6
 * BLOCKS:   DSC2B0
 * REGADDR:  0xc216
 * DESC:     DSC State Machine Control 6 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     CDRBR_BWSEL_PROP_ACQPHASE 
 *     CDRBR_BWSEL_PROP_ACQCDR 
 *     CDRBR_BWSEL_PROP_ACQ1 
 *     CDRBR_BWSEL_PROP_ACQ2 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_ACQ_SM_CTRL6r (0x0000c216 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_ACQ_SM_CTRL6r_SIZE 4

/*
 * This structure should be used to declare and program ACQ_SM_CTRL6.
 *
 */
typedef union BCMI_TSC_XGXS_ACQ_SM_CTRL6r_s {
	uint32_t v[1];
	uint32_t acq_sm_ctrl6[1];
	uint32_t _acq_sm_ctrl6;
} BCMI_TSC_XGXS_ACQ_SM_CTRL6r_t;

#define BCMI_TSC_XGXS_ACQ_SM_CTRL6r_CLR(r) (r).acq_sm_ctrl6[0] = 0
#define BCMI_TSC_XGXS_ACQ_SM_CTRL6r_SET(r,d) (r).acq_sm_ctrl6[0] = d
#define BCMI_TSC_XGXS_ACQ_SM_CTRL6r_GET(r) (r).acq_sm_ctrl6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_ACQ_SM_CTRL6r_RESERVED0f_GET(r) ((((r).acq_sm_ctrl6[0]) >> 12) & 0xf)
#define BCMI_TSC_XGXS_ACQ_SM_CTRL6r_RESERVED0f_SET(r,f) (r).acq_sm_ctrl6[0]=(((r).acq_sm_ctrl6[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCMI_TSC_XGXS_ACQ_SM_CTRL6r_CDRBR_BWSEL_PROP_ACQ2f_GET(r) ((((r).acq_sm_ctrl6[0]) >> 9) & 0x7)
#define BCMI_TSC_XGXS_ACQ_SM_CTRL6r_CDRBR_BWSEL_PROP_ACQ2f_SET(r,f) (r).acq_sm_ctrl6[0]=(((r).acq_sm_ctrl6[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCMI_TSC_XGXS_ACQ_SM_CTRL6r_CDRBR_BWSEL_PROP_ACQ1f_GET(r) ((((r).acq_sm_ctrl6[0]) >> 6) & 0x7)
#define BCMI_TSC_XGXS_ACQ_SM_CTRL6r_CDRBR_BWSEL_PROP_ACQ1f_SET(r,f) (r).acq_sm_ctrl6[0]=(((r).acq_sm_ctrl6[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCMI_TSC_XGXS_ACQ_SM_CTRL6r_CDRBR_BWSEL_PROP_ACQCDRf_GET(r) ((((r).acq_sm_ctrl6[0]) >> 3) & 0x7)
#define BCMI_TSC_XGXS_ACQ_SM_CTRL6r_CDRBR_BWSEL_PROP_ACQCDRf_SET(r,f) (r).acq_sm_ctrl6[0]=(((r).acq_sm_ctrl6[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCMI_TSC_XGXS_ACQ_SM_CTRL6r_CDRBR_BWSEL_PROP_ACQPHASEf_GET(r) (((r).acq_sm_ctrl6[0]) & 0x7)
#define BCMI_TSC_XGXS_ACQ_SM_CTRL6r_CDRBR_BWSEL_PROP_ACQPHASEf_SET(r,f) (r).acq_sm_ctrl6[0]=(((r).acq_sm_ctrl6[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))

/*
 * These macros can be used to access ACQ_SM_CTRL6.
 *
 */
#define BCMI_TSC_XGXS_READ_ACQ_SM_CTRL6r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_ACQ_SM_CTRL6r,(_r._acq_sm_ctrl6))
#define BCMI_TSC_XGXS_WRITE_ACQ_SM_CTRL6r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_ACQ_SM_CTRL6r,(_r._acq_sm_ctrl6))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define ACQ_SM_CTRL6r BCMI_TSC_XGXS_ACQ_SM_CTRL6r
#define ACQ_SM_CTRL6r_SIZE BCMI_TSC_XGXS_ACQ_SM_CTRL6r_SIZE
typedef BCMI_TSC_XGXS_ACQ_SM_CTRL6r_t ACQ_SM_CTRL6r_t;
#define ACQ_SM_CTRL6r_CLR BCMI_TSC_XGXS_ACQ_SM_CTRL6r_CLR
#define ACQ_SM_CTRL6r_SET BCMI_TSC_XGXS_ACQ_SM_CTRL6r_SET
#define ACQ_SM_CTRL6r_GET BCMI_TSC_XGXS_ACQ_SM_CTRL6r_GET
#define ACQ_SM_CTRL6r_RESERVED0f_GET BCMI_TSC_XGXS_ACQ_SM_CTRL6r_RESERVED0f_GET
#define ACQ_SM_CTRL6r_RESERVED0f_SET BCMI_TSC_XGXS_ACQ_SM_CTRL6r_RESERVED0f_SET
#define ACQ_SM_CTRL6r_CDRBR_BWSEL_PROP_ACQ2f_GET BCMI_TSC_XGXS_ACQ_SM_CTRL6r_CDRBR_BWSEL_PROP_ACQ2f_GET
#define ACQ_SM_CTRL6r_CDRBR_BWSEL_PROP_ACQ2f_SET BCMI_TSC_XGXS_ACQ_SM_CTRL6r_CDRBR_BWSEL_PROP_ACQ2f_SET
#define ACQ_SM_CTRL6r_CDRBR_BWSEL_PROP_ACQ1f_GET BCMI_TSC_XGXS_ACQ_SM_CTRL6r_CDRBR_BWSEL_PROP_ACQ1f_GET
#define ACQ_SM_CTRL6r_CDRBR_BWSEL_PROP_ACQ1f_SET BCMI_TSC_XGXS_ACQ_SM_CTRL6r_CDRBR_BWSEL_PROP_ACQ1f_SET
#define ACQ_SM_CTRL6r_CDRBR_BWSEL_PROP_ACQCDRf_GET BCMI_TSC_XGXS_ACQ_SM_CTRL6r_CDRBR_BWSEL_PROP_ACQCDRf_GET
#define ACQ_SM_CTRL6r_CDRBR_BWSEL_PROP_ACQCDRf_SET BCMI_TSC_XGXS_ACQ_SM_CTRL6r_CDRBR_BWSEL_PROP_ACQCDRf_SET
#define ACQ_SM_CTRL6r_CDRBR_BWSEL_PROP_ACQPHASEf_GET BCMI_TSC_XGXS_ACQ_SM_CTRL6r_CDRBR_BWSEL_PROP_ACQPHASEf_GET
#define ACQ_SM_CTRL6r_CDRBR_BWSEL_PROP_ACQPHASEf_SET BCMI_TSC_XGXS_ACQ_SM_CTRL6r_CDRBR_BWSEL_PROP_ACQPHASEf_SET
#define READ_ACQ_SM_CTRL6r BCMI_TSC_XGXS_READ_ACQ_SM_CTRL6r
#define WRITE_ACQ_SM_CTRL6r BCMI_TSC_XGXS_WRITE_ACQ_SM_CTRL6r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_ACQ_SM_CTRL6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  ACQ_SM_CTRL7
 * BLOCKS:   DSC2B0
 * REGADDR:  0xc217
 * DESC:     DSC State Machine Control 7 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     CDRBR_BWSEL_INTEG_ACQPHASE 
 *     CDRBR_BWSEL_INTEG_ACQCDR 
 *     CDRBR_BWSEL_INTEG_ACQ1 
 *     CDRBR_BWSEL_INTEG_ACQ2 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_ACQ_SM_CTRL7r (0x0000c217 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_ACQ_SM_CTRL7r_SIZE 4

/*
 * This structure should be used to declare and program ACQ_SM_CTRL7.
 *
 */
typedef union BCMI_TSC_XGXS_ACQ_SM_CTRL7r_s {
	uint32_t v[1];
	uint32_t acq_sm_ctrl7[1];
	uint32_t _acq_sm_ctrl7;
} BCMI_TSC_XGXS_ACQ_SM_CTRL7r_t;

#define BCMI_TSC_XGXS_ACQ_SM_CTRL7r_CLR(r) (r).acq_sm_ctrl7[0] = 0
#define BCMI_TSC_XGXS_ACQ_SM_CTRL7r_SET(r,d) (r).acq_sm_ctrl7[0] = d
#define BCMI_TSC_XGXS_ACQ_SM_CTRL7r_GET(r) (r).acq_sm_ctrl7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_ACQ_SM_CTRL7r_RESERVED0f_GET(r) ((((r).acq_sm_ctrl7[0]) >> 12) & 0xf)
#define BCMI_TSC_XGXS_ACQ_SM_CTRL7r_RESERVED0f_SET(r,f) (r).acq_sm_ctrl7[0]=(((r).acq_sm_ctrl7[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCMI_TSC_XGXS_ACQ_SM_CTRL7r_CDRBR_BWSEL_INTEG_ACQ2f_GET(r) ((((r).acq_sm_ctrl7[0]) >> 9) & 0x7)
#define BCMI_TSC_XGXS_ACQ_SM_CTRL7r_CDRBR_BWSEL_INTEG_ACQ2f_SET(r,f) (r).acq_sm_ctrl7[0]=(((r).acq_sm_ctrl7[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCMI_TSC_XGXS_ACQ_SM_CTRL7r_CDRBR_BWSEL_INTEG_ACQ1f_GET(r) ((((r).acq_sm_ctrl7[0]) >> 6) & 0x7)
#define BCMI_TSC_XGXS_ACQ_SM_CTRL7r_CDRBR_BWSEL_INTEG_ACQ1f_SET(r,f) (r).acq_sm_ctrl7[0]=(((r).acq_sm_ctrl7[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCMI_TSC_XGXS_ACQ_SM_CTRL7r_CDRBR_BWSEL_INTEG_ACQCDRf_GET(r) ((((r).acq_sm_ctrl7[0]) >> 3) & 0x7)
#define BCMI_TSC_XGXS_ACQ_SM_CTRL7r_CDRBR_BWSEL_INTEG_ACQCDRf_SET(r,f) (r).acq_sm_ctrl7[0]=(((r).acq_sm_ctrl7[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCMI_TSC_XGXS_ACQ_SM_CTRL7r_CDRBR_BWSEL_INTEG_ACQPHASEf_GET(r) (((r).acq_sm_ctrl7[0]) & 0x7)
#define BCMI_TSC_XGXS_ACQ_SM_CTRL7r_CDRBR_BWSEL_INTEG_ACQPHASEf_SET(r,f) (r).acq_sm_ctrl7[0]=(((r).acq_sm_ctrl7[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))

/*
 * These macros can be used to access ACQ_SM_CTRL7.
 *
 */
#define BCMI_TSC_XGXS_READ_ACQ_SM_CTRL7r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_ACQ_SM_CTRL7r,(_r._acq_sm_ctrl7))
#define BCMI_TSC_XGXS_WRITE_ACQ_SM_CTRL7r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_ACQ_SM_CTRL7r,(_r._acq_sm_ctrl7))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define ACQ_SM_CTRL7r BCMI_TSC_XGXS_ACQ_SM_CTRL7r
#define ACQ_SM_CTRL7r_SIZE BCMI_TSC_XGXS_ACQ_SM_CTRL7r_SIZE
typedef BCMI_TSC_XGXS_ACQ_SM_CTRL7r_t ACQ_SM_CTRL7r_t;
#define ACQ_SM_CTRL7r_CLR BCMI_TSC_XGXS_ACQ_SM_CTRL7r_CLR
#define ACQ_SM_CTRL7r_SET BCMI_TSC_XGXS_ACQ_SM_CTRL7r_SET
#define ACQ_SM_CTRL7r_GET BCMI_TSC_XGXS_ACQ_SM_CTRL7r_GET
#define ACQ_SM_CTRL7r_RESERVED0f_GET BCMI_TSC_XGXS_ACQ_SM_CTRL7r_RESERVED0f_GET
#define ACQ_SM_CTRL7r_RESERVED0f_SET BCMI_TSC_XGXS_ACQ_SM_CTRL7r_RESERVED0f_SET
#define ACQ_SM_CTRL7r_CDRBR_BWSEL_INTEG_ACQ2f_GET BCMI_TSC_XGXS_ACQ_SM_CTRL7r_CDRBR_BWSEL_INTEG_ACQ2f_GET
#define ACQ_SM_CTRL7r_CDRBR_BWSEL_INTEG_ACQ2f_SET BCMI_TSC_XGXS_ACQ_SM_CTRL7r_CDRBR_BWSEL_INTEG_ACQ2f_SET
#define ACQ_SM_CTRL7r_CDRBR_BWSEL_INTEG_ACQ1f_GET BCMI_TSC_XGXS_ACQ_SM_CTRL7r_CDRBR_BWSEL_INTEG_ACQ1f_GET
#define ACQ_SM_CTRL7r_CDRBR_BWSEL_INTEG_ACQ1f_SET BCMI_TSC_XGXS_ACQ_SM_CTRL7r_CDRBR_BWSEL_INTEG_ACQ1f_SET
#define ACQ_SM_CTRL7r_CDRBR_BWSEL_INTEG_ACQCDRf_GET BCMI_TSC_XGXS_ACQ_SM_CTRL7r_CDRBR_BWSEL_INTEG_ACQCDRf_GET
#define ACQ_SM_CTRL7r_CDRBR_BWSEL_INTEG_ACQCDRf_SET BCMI_TSC_XGXS_ACQ_SM_CTRL7r_CDRBR_BWSEL_INTEG_ACQCDRf_SET
#define ACQ_SM_CTRL7r_CDRBR_BWSEL_INTEG_ACQPHASEf_GET BCMI_TSC_XGXS_ACQ_SM_CTRL7r_CDRBR_BWSEL_INTEG_ACQPHASEf_GET
#define ACQ_SM_CTRL7r_CDRBR_BWSEL_INTEG_ACQPHASEf_SET BCMI_TSC_XGXS_ACQ_SM_CTRL7r_CDRBR_BWSEL_INTEG_ACQPHASEf_SET
#define READ_ACQ_SM_CTRL7r BCMI_TSC_XGXS_READ_ACQ_SM_CTRL7r
#define WRITE_ACQ_SM_CTRL7r BCMI_TSC_XGXS_WRITE_ACQ_SM_CTRL7r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_ACQ_SM_CTRL7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  ACQ_SM_CTRL8
 * BLOCKS:   DSC2B0
 * REGADDR:  0xc218
 * DESC:     DSC State Machine Control 8 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     CDROS_BWSEL_PROP_100FX 
 *     CDROS_BWSEL_INTEG_100FX 
 *     PI_PHASE_STEP_MULT_100FX 
 *     PHASE_SAT_CTRL_100FX 
 *     CDROS_BWSEL_PROP_EEE_ACQPHASE 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_ACQ_SM_CTRL8r (0x0000c218 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_ACQ_SM_CTRL8r_SIZE 4

/*
 * This structure should be used to declare and program ACQ_SM_CTRL8.
 *
 */
typedef union BCMI_TSC_XGXS_ACQ_SM_CTRL8r_s {
	uint32_t v[1];
	uint32_t acq_sm_ctrl8[1];
	uint32_t _acq_sm_ctrl8;
} BCMI_TSC_XGXS_ACQ_SM_CTRL8r_t;

#define BCMI_TSC_XGXS_ACQ_SM_CTRL8r_CLR(r) (r).acq_sm_ctrl8[0] = 0
#define BCMI_TSC_XGXS_ACQ_SM_CTRL8r_SET(r,d) (r).acq_sm_ctrl8[0] = d
#define BCMI_TSC_XGXS_ACQ_SM_CTRL8r_GET(r) (r).acq_sm_ctrl8[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_ACQ_SM_CTRL8r_RESERVED0f_GET(r) ((((r).acq_sm_ctrl8[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_ACQ_SM_CTRL8r_RESERVED0f_SET(r,f) (r).acq_sm_ctrl8[0]=(((r).acq_sm_ctrl8[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_ACQ_SM_CTRL8r_CDROS_BWSEL_PROP_EEE_ACQPHASEf_GET(r) ((((r).acq_sm_ctrl8[0]) >> 11) & 0xf)
#define BCMI_TSC_XGXS_ACQ_SM_CTRL8r_CDROS_BWSEL_PROP_EEE_ACQPHASEf_SET(r,f) (r).acq_sm_ctrl8[0]=(((r).acq_sm_ctrl8[0] & ~((uint32_t)0xf << 11)) | ((((uint32_t)f) & 0xf) << 11))
#define BCMI_TSC_XGXS_ACQ_SM_CTRL8r_PHASE_SAT_CTRL_100FXf_GET(r) ((((r).acq_sm_ctrl8[0]) >> 9) & 0x3)
#define BCMI_TSC_XGXS_ACQ_SM_CTRL8r_PHASE_SAT_CTRL_100FXf_SET(r,f) (r).acq_sm_ctrl8[0]=(((r).acq_sm_ctrl8[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9))
#define BCMI_TSC_XGXS_ACQ_SM_CTRL8r_PI_PHASE_STEP_MULT_100FXf_GET(r) ((((r).acq_sm_ctrl8[0]) >> 8) & 0x1)
#define BCMI_TSC_XGXS_ACQ_SM_CTRL8r_PI_PHASE_STEP_MULT_100FXf_SET(r,f) (r).acq_sm_ctrl8[0]=(((r).acq_sm_ctrl8[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCMI_TSC_XGXS_ACQ_SM_CTRL8r_CDROS_BWSEL_INTEG_100FXf_GET(r) ((((r).acq_sm_ctrl8[0]) >> 4) & 0xf)
#define BCMI_TSC_XGXS_ACQ_SM_CTRL8r_CDROS_BWSEL_INTEG_100FXf_SET(r,f) (r).acq_sm_ctrl8[0]=(((r).acq_sm_ctrl8[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCMI_TSC_XGXS_ACQ_SM_CTRL8r_CDROS_BWSEL_PROP_100FXf_GET(r) (((r).acq_sm_ctrl8[0]) & 0xf)
#define BCMI_TSC_XGXS_ACQ_SM_CTRL8r_CDROS_BWSEL_PROP_100FXf_SET(r,f) (r).acq_sm_ctrl8[0]=(((r).acq_sm_ctrl8[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access ACQ_SM_CTRL8.
 *
 */
#define BCMI_TSC_XGXS_READ_ACQ_SM_CTRL8r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_ACQ_SM_CTRL8r,(_r._acq_sm_ctrl8))
#define BCMI_TSC_XGXS_WRITE_ACQ_SM_CTRL8r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_ACQ_SM_CTRL8r,(_r._acq_sm_ctrl8))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define ACQ_SM_CTRL8r BCMI_TSC_XGXS_ACQ_SM_CTRL8r
#define ACQ_SM_CTRL8r_SIZE BCMI_TSC_XGXS_ACQ_SM_CTRL8r_SIZE
typedef BCMI_TSC_XGXS_ACQ_SM_CTRL8r_t ACQ_SM_CTRL8r_t;
#define ACQ_SM_CTRL8r_CLR BCMI_TSC_XGXS_ACQ_SM_CTRL8r_CLR
#define ACQ_SM_CTRL8r_SET BCMI_TSC_XGXS_ACQ_SM_CTRL8r_SET
#define ACQ_SM_CTRL8r_GET BCMI_TSC_XGXS_ACQ_SM_CTRL8r_GET
#define ACQ_SM_CTRL8r_RESERVED0f_GET BCMI_TSC_XGXS_ACQ_SM_CTRL8r_RESERVED0f_GET
#define ACQ_SM_CTRL8r_RESERVED0f_SET BCMI_TSC_XGXS_ACQ_SM_CTRL8r_RESERVED0f_SET
#define ACQ_SM_CTRL8r_CDROS_BWSEL_PROP_EEE_ACQPHASEf_GET BCMI_TSC_XGXS_ACQ_SM_CTRL8r_CDROS_BWSEL_PROP_EEE_ACQPHASEf_GET
#define ACQ_SM_CTRL8r_CDROS_BWSEL_PROP_EEE_ACQPHASEf_SET BCMI_TSC_XGXS_ACQ_SM_CTRL8r_CDROS_BWSEL_PROP_EEE_ACQPHASEf_SET
#define ACQ_SM_CTRL8r_PHASE_SAT_CTRL_100FXf_GET BCMI_TSC_XGXS_ACQ_SM_CTRL8r_PHASE_SAT_CTRL_100FXf_GET
#define ACQ_SM_CTRL8r_PHASE_SAT_CTRL_100FXf_SET BCMI_TSC_XGXS_ACQ_SM_CTRL8r_PHASE_SAT_CTRL_100FXf_SET
#define ACQ_SM_CTRL8r_PI_PHASE_STEP_MULT_100FXf_GET BCMI_TSC_XGXS_ACQ_SM_CTRL8r_PI_PHASE_STEP_MULT_100FXf_GET
#define ACQ_SM_CTRL8r_PI_PHASE_STEP_MULT_100FXf_SET BCMI_TSC_XGXS_ACQ_SM_CTRL8r_PI_PHASE_STEP_MULT_100FXf_SET
#define ACQ_SM_CTRL8r_CDROS_BWSEL_INTEG_100FXf_GET BCMI_TSC_XGXS_ACQ_SM_CTRL8r_CDROS_BWSEL_INTEG_100FXf_GET
#define ACQ_SM_CTRL8r_CDROS_BWSEL_INTEG_100FXf_SET BCMI_TSC_XGXS_ACQ_SM_CTRL8r_CDROS_BWSEL_INTEG_100FXf_SET
#define ACQ_SM_CTRL8r_CDROS_BWSEL_PROP_100FXf_GET BCMI_TSC_XGXS_ACQ_SM_CTRL8r_CDROS_BWSEL_PROP_100FXf_GET
#define ACQ_SM_CTRL8r_CDROS_BWSEL_PROP_100FXf_SET BCMI_TSC_XGXS_ACQ_SM_CTRL8r_CDROS_BWSEL_PROP_100FXf_SET
#define READ_ACQ_SM_CTRL8r BCMI_TSC_XGXS_READ_ACQ_SM_CTRL8r
#define WRITE_ACQ_SM_CTRL8r BCMI_TSC_XGXS_WRITE_ACQ_SM_CTRL8r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_ACQ_SM_CTRL8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  DSC_ANA_CTRL0
 * BLOCKS:   DSC2B0
 * REGADDR:  0xc219
 * DESC:     DSC Analog Control 0 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     P1_EVN_CTRL      
 *     P1_ODD_CTRL      
 *     FORCE_P1_EVN_CTRL 
 *     FORCE_P1_ODD_CTRL 
 *     FORCE_P1_CTRL_STROBE 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_DSC_ANA_CTRL0r (0x0000c219 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_DSC_ANA_CTRL0r_SIZE 4

/*
 * This structure should be used to declare and program DSC_ANA_CTRL0.
 *
 */
typedef union BCMI_TSC_XGXS_DSC_ANA_CTRL0r_s {
	uint32_t v[1];
	uint32_t dsc_ana_ctrl0[1];
	uint32_t _dsc_ana_ctrl0;
} BCMI_TSC_XGXS_DSC_ANA_CTRL0r_t;

#define BCMI_TSC_XGXS_DSC_ANA_CTRL0r_CLR(r) (r).dsc_ana_ctrl0[0] = 0
#define BCMI_TSC_XGXS_DSC_ANA_CTRL0r_SET(r,d) (r).dsc_ana_ctrl0[0] = d
#define BCMI_TSC_XGXS_DSC_ANA_CTRL0r_GET(r) (r).dsc_ana_ctrl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_DSC_ANA_CTRL0r_RESERVED0f_GET(r) ((((r).dsc_ana_ctrl0[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_DSC_ANA_CTRL0r_RESERVED0f_SET(r,f) (r).dsc_ana_ctrl0[0]=(((r).dsc_ana_ctrl0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_DSC_ANA_CTRL0r_FORCE_P1_CTRL_STROBEf_GET(r) ((((r).dsc_ana_ctrl0[0]) >> 14) & 0x1)
#define BCMI_TSC_XGXS_DSC_ANA_CTRL0r_FORCE_P1_CTRL_STROBEf_SET(r,f) (r).dsc_ana_ctrl0[0]=(((r).dsc_ana_ctrl0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCMI_TSC_XGXS_DSC_ANA_CTRL0r_FORCE_P1_ODD_CTRLf_GET(r) ((((r).dsc_ana_ctrl0[0]) >> 13) & 0x1)
#define BCMI_TSC_XGXS_DSC_ANA_CTRL0r_FORCE_P1_ODD_CTRLf_SET(r,f) (r).dsc_ana_ctrl0[0]=(((r).dsc_ana_ctrl0[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCMI_TSC_XGXS_DSC_ANA_CTRL0r_FORCE_P1_EVN_CTRLf_GET(r) ((((r).dsc_ana_ctrl0[0]) >> 12) & 0x1)
#define BCMI_TSC_XGXS_DSC_ANA_CTRL0r_FORCE_P1_EVN_CTRLf_SET(r,f) (r).dsc_ana_ctrl0[0]=(((r).dsc_ana_ctrl0[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCMI_TSC_XGXS_DSC_ANA_CTRL0r_P1_ODD_CTRLf_GET(r) ((((r).dsc_ana_ctrl0[0]) >> 6) & 0x3f)
#define BCMI_TSC_XGXS_DSC_ANA_CTRL0r_P1_ODD_CTRLf_SET(r,f) (r).dsc_ana_ctrl0[0]=(((r).dsc_ana_ctrl0[0] & ~((uint32_t)0x3f << 6)) | ((((uint32_t)f) & 0x3f) << 6))
#define BCMI_TSC_XGXS_DSC_ANA_CTRL0r_P1_EVN_CTRLf_GET(r) (((r).dsc_ana_ctrl0[0]) & 0x3f)
#define BCMI_TSC_XGXS_DSC_ANA_CTRL0r_P1_EVN_CTRLf_SET(r,f) (r).dsc_ana_ctrl0[0]=(((r).dsc_ana_ctrl0[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))

/*
 * These macros can be used to access DSC_ANA_CTRL0.
 *
 */
#define BCMI_TSC_XGXS_READ_DSC_ANA_CTRL0r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_DSC_ANA_CTRL0r,(_r._dsc_ana_ctrl0))
#define BCMI_TSC_XGXS_WRITE_DSC_ANA_CTRL0r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_DSC_ANA_CTRL0r,(_r._dsc_ana_ctrl0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_ANA_CTRL0r BCMI_TSC_XGXS_DSC_ANA_CTRL0r
#define DSC_ANA_CTRL0r_SIZE BCMI_TSC_XGXS_DSC_ANA_CTRL0r_SIZE
typedef BCMI_TSC_XGXS_DSC_ANA_CTRL0r_t DSC_ANA_CTRL0r_t;
#define DSC_ANA_CTRL0r_CLR BCMI_TSC_XGXS_DSC_ANA_CTRL0r_CLR
#define DSC_ANA_CTRL0r_SET BCMI_TSC_XGXS_DSC_ANA_CTRL0r_SET
#define DSC_ANA_CTRL0r_GET BCMI_TSC_XGXS_DSC_ANA_CTRL0r_GET
#define DSC_ANA_CTRL0r_RESERVED0f_GET BCMI_TSC_XGXS_DSC_ANA_CTRL0r_RESERVED0f_GET
#define DSC_ANA_CTRL0r_RESERVED0f_SET BCMI_TSC_XGXS_DSC_ANA_CTRL0r_RESERVED0f_SET
#define DSC_ANA_CTRL0r_FORCE_P1_CTRL_STROBEf_GET BCMI_TSC_XGXS_DSC_ANA_CTRL0r_FORCE_P1_CTRL_STROBEf_GET
#define DSC_ANA_CTRL0r_FORCE_P1_CTRL_STROBEf_SET BCMI_TSC_XGXS_DSC_ANA_CTRL0r_FORCE_P1_CTRL_STROBEf_SET
#define DSC_ANA_CTRL0r_FORCE_P1_ODD_CTRLf_GET BCMI_TSC_XGXS_DSC_ANA_CTRL0r_FORCE_P1_ODD_CTRLf_GET
#define DSC_ANA_CTRL0r_FORCE_P1_ODD_CTRLf_SET BCMI_TSC_XGXS_DSC_ANA_CTRL0r_FORCE_P1_ODD_CTRLf_SET
#define DSC_ANA_CTRL0r_FORCE_P1_EVN_CTRLf_GET BCMI_TSC_XGXS_DSC_ANA_CTRL0r_FORCE_P1_EVN_CTRLf_GET
#define DSC_ANA_CTRL0r_FORCE_P1_EVN_CTRLf_SET BCMI_TSC_XGXS_DSC_ANA_CTRL0r_FORCE_P1_EVN_CTRLf_SET
#define DSC_ANA_CTRL0r_P1_ODD_CTRLf_GET BCMI_TSC_XGXS_DSC_ANA_CTRL0r_P1_ODD_CTRLf_GET
#define DSC_ANA_CTRL0r_P1_ODD_CTRLf_SET BCMI_TSC_XGXS_DSC_ANA_CTRL0r_P1_ODD_CTRLf_SET
#define DSC_ANA_CTRL0r_P1_EVN_CTRLf_GET BCMI_TSC_XGXS_DSC_ANA_CTRL0r_P1_EVN_CTRLf_GET
#define DSC_ANA_CTRL0r_P1_EVN_CTRLf_SET BCMI_TSC_XGXS_DSC_ANA_CTRL0r_P1_EVN_CTRLf_SET
#define READ_DSC_ANA_CTRL0r BCMI_TSC_XGXS_READ_DSC_ANA_CTRL0r
#define WRITE_DSC_ANA_CTRL0r BCMI_TSC_XGXS_WRITE_DSC_ANA_CTRL0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_DSC_ANA_CTRL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  DSC_ANA_CTRL1
 * BLOCKS:   DSC2B0
 * REGADDR:  0xc21a
 * DESC:     DSC Analog Control 1 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     D_EVN_CTRL       
 *     D_ODD_CTRL       
 *     FORCE_D_EVN_CTRL 
 *     FORCE_D_ODD_CTRL 
 *     FORCE_D_CTRL_STROBE 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_DSC_ANA_CTRL1r (0x0000c21a | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_DSC_ANA_CTRL1r_SIZE 4

/*
 * This structure should be used to declare and program DSC_ANA_CTRL1.
 *
 */
typedef union BCMI_TSC_XGXS_DSC_ANA_CTRL1r_s {
	uint32_t v[1];
	uint32_t dsc_ana_ctrl1[1];
	uint32_t _dsc_ana_ctrl1;
} BCMI_TSC_XGXS_DSC_ANA_CTRL1r_t;

#define BCMI_TSC_XGXS_DSC_ANA_CTRL1r_CLR(r) (r).dsc_ana_ctrl1[0] = 0
#define BCMI_TSC_XGXS_DSC_ANA_CTRL1r_SET(r,d) (r).dsc_ana_ctrl1[0] = d
#define BCMI_TSC_XGXS_DSC_ANA_CTRL1r_GET(r) (r).dsc_ana_ctrl1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_DSC_ANA_CTRL1r_RESERVED0f_GET(r) ((((r).dsc_ana_ctrl1[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_DSC_ANA_CTRL1r_RESERVED0f_SET(r,f) (r).dsc_ana_ctrl1[0]=(((r).dsc_ana_ctrl1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_DSC_ANA_CTRL1r_FORCE_D_CTRL_STROBEf_GET(r) ((((r).dsc_ana_ctrl1[0]) >> 14) & 0x1)
#define BCMI_TSC_XGXS_DSC_ANA_CTRL1r_FORCE_D_CTRL_STROBEf_SET(r,f) (r).dsc_ana_ctrl1[0]=(((r).dsc_ana_ctrl1[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCMI_TSC_XGXS_DSC_ANA_CTRL1r_FORCE_D_ODD_CTRLf_GET(r) ((((r).dsc_ana_ctrl1[0]) >> 13) & 0x1)
#define BCMI_TSC_XGXS_DSC_ANA_CTRL1r_FORCE_D_ODD_CTRLf_SET(r,f) (r).dsc_ana_ctrl1[0]=(((r).dsc_ana_ctrl1[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCMI_TSC_XGXS_DSC_ANA_CTRL1r_FORCE_D_EVN_CTRLf_GET(r) ((((r).dsc_ana_ctrl1[0]) >> 12) & 0x1)
#define BCMI_TSC_XGXS_DSC_ANA_CTRL1r_FORCE_D_EVN_CTRLf_SET(r,f) (r).dsc_ana_ctrl1[0]=(((r).dsc_ana_ctrl1[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCMI_TSC_XGXS_DSC_ANA_CTRL1r_D_ODD_CTRLf_GET(r) ((((r).dsc_ana_ctrl1[0]) >> 6) & 0x3f)
#define BCMI_TSC_XGXS_DSC_ANA_CTRL1r_D_ODD_CTRLf_SET(r,f) (r).dsc_ana_ctrl1[0]=(((r).dsc_ana_ctrl1[0] & ~((uint32_t)0x3f << 6)) | ((((uint32_t)f) & 0x3f) << 6))
#define BCMI_TSC_XGXS_DSC_ANA_CTRL1r_D_EVN_CTRLf_GET(r) (((r).dsc_ana_ctrl1[0]) & 0x3f)
#define BCMI_TSC_XGXS_DSC_ANA_CTRL1r_D_EVN_CTRLf_SET(r,f) (r).dsc_ana_ctrl1[0]=(((r).dsc_ana_ctrl1[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))

/*
 * These macros can be used to access DSC_ANA_CTRL1.
 *
 */
#define BCMI_TSC_XGXS_READ_DSC_ANA_CTRL1r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_DSC_ANA_CTRL1r,(_r._dsc_ana_ctrl1))
#define BCMI_TSC_XGXS_WRITE_DSC_ANA_CTRL1r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_DSC_ANA_CTRL1r,(_r._dsc_ana_ctrl1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_ANA_CTRL1r BCMI_TSC_XGXS_DSC_ANA_CTRL1r
#define DSC_ANA_CTRL1r_SIZE BCMI_TSC_XGXS_DSC_ANA_CTRL1r_SIZE
typedef BCMI_TSC_XGXS_DSC_ANA_CTRL1r_t DSC_ANA_CTRL1r_t;
#define DSC_ANA_CTRL1r_CLR BCMI_TSC_XGXS_DSC_ANA_CTRL1r_CLR
#define DSC_ANA_CTRL1r_SET BCMI_TSC_XGXS_DSC_ANA_CTRL1r_SET
#define DSC_ANA_CTRL1r_GET BCMI_TSC_XGXS_DSC_ANA_CTRL1r_GET
#define DSC_ANA_CTRL1r_RESERVED0f_GET BCMI_TSC_XGXS_DSC_ANA_CTRL1r_RESERVED0f_GET
#define DSC_ANA_CTRL1r_RESERVED0f_SET BCMI_TSC_XGXS_DSC_ANA_CTRL1r_RESERVED0f_SET
#define DSC_ANA_CTRL1r_FORCE_D_CTRL_STROBEf_GET BCMI_TSC_XGXS_DSC_ANA_CTRL1r_FORCE_D_CTRL_STROBEf_GET
#define DSC_ANA_CTRL1r_FORCE_D_CTRL_STROBEf_SET BCMI_TSC_XGXS_DSC_ANA_CTRL1r_FORCE_D_CTRL_STROBEf_SET
#define DSC_ANA_CTRL1r_FORCE_D_ODD_CTRLf_GET BCMI_TSC_XGXS_DSC_ANA_CTRL1r_FORCE_D_ODD_CTRLf_GET
#define DSC_ANA_CTRL1r_FORCE_D_ODD_CTRLf_SET BCMI_TSC_XGXS_DSC_ANA_CTRL1r_FORCE_D_ODD_CTRLf_SET
#define DSC_ANA_CTRL1r_FORCE_D_EVN_CTRLf_GET BCMI_TSC_XGXS_DSC_ANA_CTRL1r_FORCE_D_EVN_CTRLf_GET
#define DSC_ANA_CTRL1r_FORCE_D_EVN_CTRLf_SET BCMI_TSC_XGXS_DSC_ANA_CTRL1r_FORCE_D_EVN_CTRLf_SET
#define DSC_ANA_CTRL1r_D_ODD_CTRLf_GET BCMI_TSC_XGXS_DSC_ANA_CTRL1r_D_ODD_CTRLf_GET
#define DSC_ANA_CTRL1r_D_ODD_CTRLf_SET BCMI_TSC_XGXS_DSC_ANA_CTRL1r_D_ODD_CTRLf_SET
#define DSC_ANA_CTRL1r_D_EVN_CTRLf_GET BCMI_TSC_XGXS_DSC_ANA_CTRL1r_D_EVN_CTRLf_GET
#define DSC_ANA_CTRL1r_D_EVN_CTRLf_SET BCMI_TSC_XGXS_DSC_ANA_CTRL1r_D_EVN_CTRLf_SET
#define READ_DSC_ANA_CTRL1r BCMI_TSC_XGXS_READ_DSC_ANA_CTRL1r
#define WRITE_DSC_ANA_CTRL1r BCMI_TSC_XGXS_WRITE_DSC_ANA_CTRL1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_DSC_ANA_CTRL1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  DSC_ANA_CTRL2
 * BLOCKS:   DSC2B0
 * REGADDR:  0xc21b
 * DESC:     DSC Analog Control 2 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     M1_EVN_CTRL      
 *     M1_ODD_CTRL      
 *     FORCE_M1_EVN_CTRL 
 *     FORCE_M1_ODD_CTRL 
 *     FORCE_M1_CTRL_STROBE 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_DSC_ANA_CTRL2r (0x0000c21b | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_DSC_ANA_CTRL2r_SIZE 4

/*
 * This structure should be used to declare and program DSC_ANA_CTRL2.
 *
 */
typedef union BCMI_TSC_XGXS_DSC_ANA_CTRL2r_s {
	uint32_t v[1];
	uint32_t dsc_ana_ctrl2[1];
	uint32_t _dsc_ana_ctrl2;
} BCMI_TSC_XGXS_DSC_ANA_CTRL2r_t;

#define BCMI_TSC_XGXS_DSC_ANA_CTRL2r_CLR(r) (r).dsc_ana_ctrl2[0] = 0
#define BCMI_TSC_XGXS_DSC_ANA_CTRL2r_SET(r,d) (r).dsc_ana_ctrl2[0] = d
#define BCMI_TSC_XGXS_DSC_ANA_CTRL2r_GET(r) (r).dsc_ana_ctrl2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_DSC_ANA_CTRL2r_RESERVED0f_GET(r) ((((r).dsc_ana_ctrl2[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_DSC_ANA_CTRL2r_RESERVED0f_SET(r,f) (r).dsc_ana_ctrl2[0]=(((r).dsc_ana_ctrl2[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_DSC_ANA_CTRL2r_FORCE_M1_CTRL_STROBEf_GET(r) ((((r).dsc_ana_ctrl2[0]) >> 14) & 0x1)
#define BCMI_TSC_XGXS_DSC_ANA_CTRL2r_FORCE_M1_CTRL_STROBEf_SET(r,f) (r).dsc_ana_ctrl2[0]=(((r).dsc_ana_ctrl2[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCMI_TSC_XGXS_DSC_ANA_CTRL2r_FORCE_M1_ODD_CTRLf_GET(r) ((((r).dsc_ana_ctrl2[0]) >> 13) & 0x1)
#define BCMI_TSC_XGXS_DSC_ANA_CTRL2r_FORCE_M1_ODD_CTRLf_SET(r,f) (r).dsc_ana_ctrl2[0]=(((r).dsc_ana_ctrl2[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCMI_TSC_XGXS_DSC_ANA_CTRL2r_FORCE_M1_EVN_CTRLf_GET(r) ((((r).dsc_ana_ctrl2[0]) >> 12) & 0x1)
#define BCMI_TSC_XGXS_DSC_ANA_CTRL2r_FORCE_M1_EVN_CTRLf_SET(r,f) (r).dsc_ana_ctrl2[0]=(((r).dsc_ana_ctrl2[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCMI_TSC_XGXS_DSC_ANA_CTRL2r_M1_ODD_CTRLf_GET(r) ((((r).dsc_ana_ctrl2[0]) >> 6) & 0x3f)
#define BCMI_TSC_XGXS_DSC_ANA_CTRL2r_M1_ODD_CTRLf_SET(r,f) (r).dsc_ana_ctrl2[0]=(((r).dsc_ana_ctrl2[0] & ~((uint32_t)0x3f << 6)) | ((((uint32_t)f) & 0x3f) << 6))
#define BCMI_TSC_XGXS_DSC_ANA_CTRL2r_M1_EVN_CTRLf_GET(r) (((r).dsc_ana_ctrl2[0]) & 0x3f)
#define BCMI_TSC_XGXS_DSC_ANA_CTRL2r_M1_EVN_CTRLf_SET(r,f) (r).dsc_ana_ctrl2[0]=(((r).dsc_ana_ctrl2[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))

/*
 * These macros can be used to access DSC_ANA_CTRL2.
 *
 */
#define BCMI_TSC_XGXS_READ_DSC_ANA_CTRL2r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_DSC_ANA_CTRL2r,(_r._dsc_ana_ctrl2))
#define BCMI_TSC_XGXS_WRITE_DSC_ANA_CTRL2r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_DSC_ANA_CTRL2r,(_r._dsc_ana_ctrl2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_ANA_CTRL2r BCMI_TSC_XGXS_DSC_ANA_CTRL2r
#define DSC_ANA_CTRL2r_SIZE BCMI_TSC_XGXS_DSC_ANA_CTRL2r_SIZE
typedef BCMI_TSC_XGXS_DSC_ANA_CTRL2r_t DSC_ANA_CTRL2r_t;
#define DSC_ANA_CTRL2r_CLR BCMI_TSC_XGXS_DSC_ANA_CTRL2r_CLR
#define DSC_ANA_CTRL2r_SET BCMI_TSC_XGXS_DSC_ANA_CTRL2r_SET
#define DSC_ANA_CTRL2r_GET BCMI_TSC_XGXS_DSC_ANA_CTRL2r_GET
#define DSC_ANA_CTRL2r_RESERVED0f_GET BCMI_TSC_XGXS_DSC_ANA_CTRL2r_RESERVED0f_GET
#define DSC_ANA_CTRL2r_RESERVED0f_SET BCMI_TSC_XGXS_DSC_ANA_CTRL2r_RESERVED0f_SET
#define DSC_ANA_CTRL2r_FORCE_M1_CTRL_STROBEf_GET BCMI_TSC_XGXS_DSC_ANA_CTRL2r_FORCE_M1_CTRL_STROBEf_GET
#define DSC_ANA_CTRL2r_FORCE_M1_CTRL_STROBEf_SET BCMI_TSC_XGXS_DSC_ANA_CTRL2r_FORCE_M1_CTRL_STROBEf_SET
#define DSC_ANA_CTRL2r_FORCE_M1_ODD_CTRLf_GET BCMI_TSC_XGXS_DSC_ANA_CTRL2r_FORCE_M1_ODD_CTRLf_GET
#define DSC_ANA_CTRL2r_FORCE_M1_ODD_CTRLf_SET BCMI_TSC_XGXS_DSC_ANA_CTRL2r_FORCE_M1_ODD_CTRLf_SET
#define DSC_ANA_CTRL2r_FORCE_M1_EVN_CTRLf_GET BCMI_TSC_XGXS_DSC_ANA_CTRL2r_FORCE_M1_EVN_CTRLf_GET
#define DSC_ANA_CTRL2r_FORCE_M1_EVN_CTRLf_SET BCMI_TSC_XGXS_DSC_ANA_CTRL2r_FORCE_M1_EVN_CTRLf_SET
#define DSC_ANA_CTRL2r_M1_ODD_CTRLf_GET BCMI_TSC_XGXS_DSC_ANA_CTRL2r_M1_ODD_CTRLf_GET
#define DSC_ANA_CTRL2r_M1_ODD_CTRLf_SET BCMI_TSC_XGXS_DSC_ANA_CTRL2r_M1_ODD_CTRLf_SET
#define DSC_ANA_CTRL2r_M1_EVN_CTRLf_GET BCMI_TSC_XGXS_DSC_ANA_CTRL2r_M1_EVN_CTRLf_GET
#define DSC_ANA_CTRL2r_M1_EVN_CTRLf_SET BCMI_TSC_XGXS_DSC_ANA_CTRL2r_M1_EVN_CTRLf_SET
#define READ_DSC_ANA_CTRL2r BCMI_TSC_XGXS_READ_DSC_ANA_CTRL2r
#define WRITE_DSC_ANA_CTRL2r BCMI_TSC_XGXS_WRITE_DSC_ANA_CTRL2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_DSC_ANA_CTRL2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  DSC_ANA_CTRL3
 * BLOCKS:   DSC2B0
 * REGADDR:  0xc21c
 * DESC:     DSC Analog Control 3 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     RX_PF_CTRL       
 *     FORCE_RX_PF_CTRL 
 *     RX_THRESH_SEL    
 *     RX_M1_THRESH_ZERO 
 *     FORCE_RX_M1_THRESH_ZERO 
 *     RX_PF_HIZ        
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_DSC_ANA_CTRL3r (0x0000c21c | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_DSC_ANA_CTRL3r_SIZE 4

/*
 * This structure should be used to declare and program DSC_ANA_CTRL3.
 *
 */
typedef union BCMI_TSC_XGXS_DSC_ANA_CTRL3r_s {
	uint32_t v[1];
	uint32_t dsc_ana_ctrl3[1];
	uint32_t _dsc_ana_ctrl3;
} BCMI_TSC_XGXS_DSC_ANA_CTRL3r_t;

#define BCMI_TSC_XGXS_DSC_ANA_CTRL3r_CLR(r) (r).dsc_ana_ctrl3[0] = 0
#define BCMI_TSC_XGXS_DSC_ANA_CTRL3r_SET(r,d) (r).dsc_ana_ctrl3[0] = d
#define BCMI_TSC_XGXS_DSC_ANA_CTRL3r_GET(r) (r).dsc_ana_ctrl3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_DSC_ANA_CTRL3r_RESERVED0f_GET(r) ((((r).dsc_ana_ctrl3[0]) >> 10) & 0x3f)
#define BCMI_TSC_XGXS_DSC_ANA_CTRL3r_RESERVED0f_SET(r,f) (r).dsc_ana_ctrl3[0]=(((r).dsc_ana_ctrl3[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))
#define BCMI_TSC_XGXS_DSC_ANA_CTRL3r_RX_PF_HIZf_GET(r) ((((r).dsc_ana_ctrl3[0]) >> 9) & 0x1)
#define BCMI_TSC_XGXS_DSC_ANA_CTRL3r_RX_PF_HIZf_SET(r,f) (r).dsc_ana_ctrl3[0]=(((r).dsc_ana_ctrl3[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCMI_TSC_XGXS_DSC_ANA_CTRL3r_FORCE_RX_M1_THRESH_ZEROf_GET(r) ((((r).dsc_ana_ctrl3[0]) >> 8) & 0x1)
#define BCMI_TSC_XGXS_DSC_ANA_CTRL3r_FORCE_RX_M1_THRESH_ZEROf_SET(r,f) (r).dsc_ana_ctrl3[0]=(((r).dsc_ana_ctrl3[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCMI_TSC_XGXS_DSC_ANA_CTRL3r_RX_M1_THRESH_ZEROf_GET(r) ((((r).dsc_ana_ctrl3[0]) >> 7) & 0x1)
#define BCMI_TSC_XGXS_DSC_ANA_CTRL3r_RX_M1_THRESH_ZEROf_SET(r,f) (r).dsc_ana_ctrl3[0]=(((r).dsc_ana_ctrl3[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCMI_TSC_XGXS_DSC_ANA_CTRL3r_RX_THRESH_SELf_GET(r) ((((r).dsc_ana_ctrl3[0]) >> 5) & 0x3)
#define BCMI_TSC_XGXS_DSC_ANA_CTRL3r_RX_THRESH_SELf_SET(r,f) (r).dsc_ana_ctrl3[0]=(((r).dsc_ana_ctrl3[0] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5))
#define BCMI_TSC_XGXS_DSC_ANA_CTRL3r_FORCE_RX_PF_CTRLf_GET(r) ((((r).dsc_ana_ctrl3[0]) >> 4) & 0x1)
#define BCMI_TSC_XGXS_DSC_ANA_CTRL3r_FORCE_RX_PF_CTRLf_SET(r,f) (r).dsc_ana_ctrl3[0]=(((r).dsc_ana_ctrl3[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCMI_TSC_XGXS_DSC_ANA_CTRL3r_RX_PF_CTRLf_GET(r) (((r).dsc_ana_ctrl3[0]) & 0xf)
#define BCMI_TSC_XGXS_DSC_ANA_CTRL3r_RX_PF_CTRLf_SET(r,f) (r).dsc_ana_ctrl3[0]=(((r).dsc_ana_ctrl3[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access DSC_ANA_CTRL3.
 *
 */
#define BCMI_TSC_XGXS_READ_DSC_ANA_CTRL3r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_DSC_ANA_CTRL3r,(_r._dsc_ana_ctrl3))
#define BCMI_TSC_XGXS_WRITE_DSC_ANA_CTRL3r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_DSC_ANA_CTRL3r,(_r._dsc_ana_ctrl3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_ANA_CTRL3r BCMI_TSC_XGXS_DSC_ANA_CTRL3r
#define DSC_ANA_CTRL3r_SIZE BCMI_TSC_XGXS_DSC_ANA_CTRL3r_SIZE
typedef BCMI_TSC_XGXS_DSC_ANA_CTRL3r_t DSC_ANA_CTRL3r_t;
#define DSC_ANA_CTRL3r_CLR BCMI_TSC_XGXS_DSC_ANA_CTRL3r_CLR
#define DSC_ANA_CTRL3r_SET BCMI_TSC_XGXS_DSC_ANA_CTRL3r_SET
#define DSC_ANA_CTRL3r_GET BCMI_TSC_XGXS_DSC_ANA_CTRL3r_GET
#define DSC_ANA_CTRL3r_RESERVED0f_GET BCMI_TSC_XGXS_DSC_ANA_CTRL3r_RESERVED0f_GET
#define DSC_ANA_CTRL3r_RESERVED0f_SET BCMI_TSC_XGXS_DSC_ANA_CTRL3r_RESERVED0f_SET
#define DSC_ANA_CTRL3r_RX_PF_HIZf_GET BCMI_TSC_XGXS_DSC_ANA_CTRL3r_RX_PF_HIZf_GET
#define DSC_ANA_CTRL3r_RX_PF_HIZf_SET BCMI_TSC_XGXS_DSC_ANA_CTRL3r_RX_PF_HIZf_SET
#define DSC_ANA_CTRL3r_FORCE_RX_M1_THRESH_ZEROf_GET BCMI_TSC_XGXS_DSC_ANA_CTRL3r_FORCE_RX_M1_THRESH_ZEROf_GET
#define DSC_ANA_CTRL3r_FORCE_RX_M1_THRESH_ZEROf_SET BCMI_TSC_XGXS_DSC_ANA_CTRL3r_FORCE_RX_M1_THRESH_ZEROf_SET
#define DSC_ANA_CTRL3r_RX_M1_THRESH_ZEROf_GET BCMI_TSC_XGXS_DSC_ANA_CTRL3r_RX_M1_THRESH_ZEROf_GET
#define DSC_ANA_CTRL3r_RX_M1_THRESH_ZEROf_SET BCMI_TSC_XGXS_DSC_ANA_CTRL3r_RX_M1_THRESH_ZEROf_SET
#define DSC_ANA_CTRL3r_RX_THRESH_SELf_GET BCMI_TSC_XGXS_DSC_ANA_CTRL3r_RX_THRESH_SELf_GET
#define DSC_ANA_CTRL3r_RX_THRESH_SELf_SET BCMI_TSC_XGXS_DSC_ANA_CTRL3r_RX_THRESH_SELf_SET
#define DSC_ANA_CTRL3r_FORCE_RX_PF_CTRLf_GET BCMI_TSC_XGXS_DSC_ANA_CTRL3r_FORCE_RX_PF_CTRLf_GET
#define DSC_ANA_CTRL3r_FORCE_RX_PF_CTRLf_SET BCMI_TSC_XGXS_DSC_ANA_CTRL3r_FORCE_RX_PF_CTRLf_SET
#define DSC_ANA_CTRL3r_RX_PF_CTRLf_GET BCMI_TSC_XGXS_DSC_ANA_CTRL3r_RX_PF_CTRLf_GET
#define DSC_ANA_CTRL3r_RX_PF_CTRLf_SET BCMI_TSC_XGXS_DSC_ANA_CTRL3r_RX_PF_CTRLf_SET
#define READ_DSC_ANA_CTRL3r BCMI_TSC_XGXS_READ_DSC_ANA_CTRL3r
#define WRITE_DSC_ANA_CTRL3r BCMI_TSC_XGXS_WRITE_DSC_ANA_CTRL3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_DSC_ANA_CTRL3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  DSC_ANA_CTRL4
 * BLOCKS:   DSC2B0
 * REGADDR:  0xc21d
 * DESC:     DSC Analog Control 4 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     OSR_PD_CH_P1     
 *     OSR_EN_DFE_CLK   
 *     OSR_EN_HGAIN     
 *     OSR_OFFSET_PD    
 *     BR_PD_CH_P1      
 *     BR_EN_DFE_CLK    
 *     BR_EN_HGAIN      
 *     BR_OFFSET_PD     
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_DSC_ANA_CTRL4r (0x0000c21d | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_DSC_ANA_CTRL4r_SIZE 4

/*
 * This structure should be used to declare and program DSC_ANA_CTRL4.
 *
 */
typedef union BCMI_TSC_XGXS_DSC_ANA_CTRL4r_s {
	uint32_t v[1];
	uint32_t dsc_ana_ctrl4[1];
	uint32_t _dsc_ana_ctrl4;
} BCMI_TSC_XGXS_DSC_ANA_CTRL4r_t;

#define BCMI_TSC_XGXS_DSC_ANA_CTRL4r_CLR(r) (r).dsc_ana_ctrl4[0] = 0
#define BCMI_TSC_XGXS_DSC_ANA_CTRL4r_SET(r,d) (r).dsc_ana_ctrl4[0] = d
#define BCMI_TSC_XGXS_DSC_ANA_CTRL4r_GET(r) (r).dsc_ana_ctrl4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_DSC_ANA_CTRL4r_RESERVED0f_GET(r) ((((r).dsc_ana_ctrl4[0]) >> 8) & 0xff)
#define BCMI_TSC_XGXS_DSC_ANA_CTRL4r_RESERVED0f_SET(r,f) (r).dsc_ana_ctrl4[0]=(((r).dsc_ana_ctrl4[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCMI_TSC_XGXS_DSC_ANA_CTRL4r_BR_OFFSET_PDf_GET(r) ((((r).dsc_ana_ctrl4[0]) >> 7) & 0x1)
#define BCMI_TSC_XGXS_DSC_ANA_CTRL4r_BR_OFFSET_PDf_SET(r,f) (r).dsc_ana_ctrl4[0]=(((r).dsc_ana_ctrl4[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCMI_TSC_XGXS_DSC_ANA_CTRL4r_BR_EN_HGAINf_GET(r) ((((r).dsc_ana_ctrl4[0]) >> 6) & 0x1)
#define BCMI_TSC_XGXS_DSC_ANA_CTRL4r_BR_EN_HGAINf_SET(r,f) (r).dsc_ana_ctrl4[0]=(((r).dsc_ana_ctrl4[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCMI_TSC_XGXS_DSC_ANA_CTRL4r_BR_EN_DFE_CLKf_GET(r) ((((r).dsc_ana_ctrl4[0]) >> 5) & 0x1)
#define BCMI_TSC_XGXS_DSC_ANA_CTRL4r_BR_EN_DFE_CLKf_SET(r,f) (r).dsc_ana_ctrl4[0]=(((r).dsc_ana_ctrl4[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCMI_TSC_XGXS_DSC_ANA_CTRL4r_BR_PD_CH_P1f_GET(r) ((((r).dsc_ana_ctrl4[0]) >> 4) & 0x1)
#define BCMI_TSC_XGXS_DSC_ANA_CTRL4r_BR_PD_CH_P1f_SET(r,f) (r).dsc_ana_ctrl4[0]=(((r).dsc_ana_ctrl4[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCMI_TSC_XGXS_DSC_ANA_CTRL4r_OSR_OFFSET_PDf_GET(r) ((((r).dsc_ana_ctrl4[0]) >> 3) & 0x1)
#define BCMI_TSC_XGXS_DSC_ANA_CTRL4r_OSR_OFFSET_PDf_SET(r,f) (r).dsc_ana_ctrl4[0]=(((r).dsc_ana_ctrl4[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCMI_TSC_XGXS_DSC_ANA_CTRL4r_OSR_EN_HGAINf_GET(r) ((((r).dsc_ana_ctrl4[0]) >> 2) & 0x1)
#define BCMI_TSC_XGXS_DSC_ANA_CTRL4r_OSR_EN_HGAINf_SET(r,f) (r).dsc_ana_ctrl4[0]=(((r).dsc_ana_ctrl4[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCMI_TSC_XGXS_DSC_ANA_CTRL4r_OSR_EN_DFE_CLKf_GET(r) ((((r).dsc_ana_ctrl4[0]) >> 1) & 0x1)
#define BCMI_TSC_XGXS_DSC_ANA_CTRL4r_OSR_EN_DFE_CLKf_SET(r,f) (r).dsc_ana_ctrl4[0]=(((r).dsc_ana_ctrl4[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCMI_TSC_XGXS_DSC_ANA_CTRL4r_OSR_PD_CH_P1f_GET(r) (((r).dsc_ana_ctrl4[0]) & 0x1)
#define BCMI_TSC_XGXS_DSC_ANA_CTRL4r_OSR_PD_CH_P1f_SET(r,f) (r).dsc_ana_ctrl4[0]=(((r).dsc_ana_ctrl4[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access DSC_ANA_CTRL4.
 *
 */
#define BCMI_TSC_XGXS_READ_DSC_ANA_CTRL4r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_DSC_ANA_CTRL4r,(_r._dsc_ana_ctrl4))
#define BCMI_TSC_XGXS_WRITE_DSC_ANA_CTRL4r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_DSC_ANA_CTRL4r,(_r._dsc_ana_ctrl4))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_ANA_CTRL4r BCMI_TSC_XGXS_DSC_ANA_CTRL4r
#define DSC_ANA_CTRL4r_SIZE BCMI_TSC_XGXS_DSC_ANA_CTRL4r_SIZE
typedef BCMI_TSC_XGXS_DSC_ANA_CTRL4r_t DSC_ANA_CTRL4r_t;
#define DSC_ANA_CTRL4r_CLR BCMI_TSC_XGXS_DSC_ANA_CTRL4r_CLR
#define DSC_ANA_CTRL4r_SET BCMI_TSC_XGXS_DSC_ANA_CTRL4r_SET
#define DSC_ANA_CTRL4r_GET BCMI_TSC_XGXS_DSC_ANA_CTRL4r_GET
#define DSC_ANA_CTRL4r_RESERVED0f_GET BCMI_TSC_XGXS_DSC_ANA_CTRL4r_RESERVED0f_GET
#define DSC_ANA_CTRL4r_RESERVED0f_SET BCMI_TSC_XGXS_DSC_ANA_CTRL4r_RESERVED0f_SET
#define DSC_ANA_CTRL4r_BR_OFFSET_PDf_GET BCMI_TSC_XGXS_DSC_ANA_CTRL4r_BR_OFFSET_PDf_GET
#define DSC_ANA_CTRL4r_BR_OFFSET_PDf_SET BCMI_TSC_XGXS_DSC_ANA_CTRL4r_BR_OFFSET_PDf_SET
#define DSC_ANA_CTRL4r_BR_EN_HGAINf_GET BCMI_TSC_XGXS_DSC_ANA_CTRL4r_BR_EN_HGAINf_GET
#define DSC_ANA_CTRL4r_BR_EN_HGAINf_SET BCMI_TSC_XGXS_DSC_ANA_CTRL4r_BR_EN_HGAINf_SET
#define DSC_ANA_CTRL4r_BR_EN_DFE_CLKf_GET BCMI_TSC_XGXS_DSC_ANA_CTRL4r_BR_EN_DFE_CLKf_GET
#define DSC_ANA_CTRL4r_BR_EN_DFE_CLKf_SET BCMI_TSC_XGXS_DSC_ANA_CTRL4r_BR_EN_DFE_CLKf_SET
#define DSC_ANA_CTRL4r_BR_PD_CH_P1f_GET BCMI_TSC_XGXS_DSC_ANA_CTRL4r_BR_PD_CH_P1f_GET
#define DSC_ANA_CTRL4r_BR_PD_CH_P1f_SET BCMI_TSC_XGXS_DSC_ANA_CTRL4r_BR_PD_CH_P1f_SET
#define DSC_ANA_CTRL4r_OSR_OFFSET_PDf_GET BCMI_TSC_XGXS_DSC_ANA_CTRL4r_OSR_OFFSET_PDf_GET
#define DSC_ANA_CTRL4r_OSR_OFFSET_PDf_SET BCMI_TSC_XGXS_DSC_ANA_CTRL4r_OSR_OFFSET_PDf_SET
#define DSC_ANA_CTRL4r_OSR_EN_HGAINf_GET BCMI_TSC_XGXS_DSC_ANA_CTRL4r_OSR_EN_HGAINf_GET
#define DSC_ANA_CTRL4r_OSR_EN_HGAINf_SET BCMI_TSC_XGXS_DSC_ANA_CTRL4r_OSR_EN_HGAINf_SET
#define DSC_ANA_CTRL4r_OSR_EN_DFE_CLKf_GET BCMI_TSC_XGXS_DSC_ANA_CTRL4r_OSR_EN_DFE_CLKf_GET
#define DSC_ANA_CTRL4r_OSR_EN_DFE_CLKf_SET BCMI_TSC_XGXS_DSC_ANA_CTRL4r_OSR_EN_DFE_CLKf_SET
#define DSC_ANA_CTRL4r_OSR_PD_CH_P1f_GET BCMI_TSC_XGXS_DSC_ANA_CTRL4r_OSR_PD_CH_P1f_GET
#define DSC_ANA_CTRL4r_OSR_PD_CH_P1f_SET BCMI_TSC_XGXS_DSC_ANA_CTRL4r_OSR_PD_CH_P1f_SET
#define READ_DSC_ANA_CTRL4r BCMI_TSC_XGXS_READ_DSC_ANA_CTRL4r
#define WRITE_DSC_ANA_CTRL4r BCMI_TSC_XGXS_WRITE_DSC_ANA_CTRL4r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_DSC_ANA_CTRL4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  DSC_MISC_CTRL0
 * BLOCKS:   DSC2B0
 * REGADDR:  0xc21e
 * DESC:     DSC Misc Control 0 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     TEST_BUS_SEL     
 *     OSR_MODE_FORCE_VAL 
 *     OSR_MODE_FORCE   
 *     CDRBR_SEL_FORCE_VAL 
 *     CDRBR_SEL_FORCE  
 *     TEST_BUS_SEL_BIT4 
 *     RXSEQSTART_AN_DISABLE 
 *     FORCERXSEQDONE_VAL 
 *     RESERVED0        
 *     FORCERXSEQDONE   
 *     RXSEQSTART       
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_DSC_MISC_CTRL0r (0x0000c21e | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_DSC_MISC_CTRL0r_SIZE 4

/*
 * This structure should be used to declare and program DSC_MISC_CTRL0.
 *
 */
typedef union BCMI_TSC_XGXS_DSC_MISC_CTRL0r_s {
	uint32_t v[1];
	uint32_t dsc_misc_ctrl0[1];
	uint32_t _dsc_misc_ctrl0;
} BCMI_TSC_XGXS_DSC_MISC_CTRL0r_t;

#define BCMI_TSC_XGXS_DSC_MISC_CTRL0r_CLR(r) (r).dsc_misc_ctrl0[0] = 0
#define BCMI_TSC_XGXS_DSC_MISC_CTRL0r_SET(r,d) (r).dsc_misc_ctrl0[0] = d
#define BCMI_TSC_XGXS_DSC_MISC_CTRL0r_GET(r) (r).dsc_misc_ctrl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_DSC_MISC_CTRL0r_RXSEQSTARTf_GET(r) ((((r).dsc_misc_ctrl0[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_DSC_MISC_CTRL0r_RXSEQSTARTf_SET(r,f) (r).dsc_misc_ctrl0[0]=(((r).dsc_misc_ctrl0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_DSC_MISC_CTRL0r_FORCERXSEQDONEf_GET(r) ((((r).dsc_misc_ctrl0[0]) >> 14) & 0x1)
#define BCMI_TSC_XGXS_DSC_MISC_CTRL0r_FORCERXSEQDONEf_SET(r,f) (r).dsc_misc_ctrl0[0]=(((r).dsc_misc_ctrl0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCMI_TSC_XGXS_DSC_MISC_CTRL0r_RESERVED0f_GET(r) ((((r).dsc_misc_ctrl0[0]) >> 13) & 0x1)
#define BCMI_TSC_XGXS_DSC_MISC_CTRL0r_RESERVED0f_SET(r,f) (r).dsc_misc_ctrl0[0]=(((r).dsc_misc_ctrl0[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCMI_TSC_XGXS_DSC_MISC_CTRL0r_FORCERXSEQDONE_VALf_GET(r) ((((r).dsc_misc_ctrl0[0]) >> 12) & 0x1)
#define BCMI_TSC_XGXS_DSC_MISC_CTRL0r_FORCERXSEQDONE_VALf_SET(r,f) (r).dsc_misc_ctrl0[0]=(((r).dsc_misc_ctrl0[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCMI_TSC_XGXS_DSC_MISC_CTRL0r_RXSEQSTART_AN_DISABLEf_GET(r) ((((r).dsc_misc_ctrl0[0]) >> 11) & 0x1)
#define BCMI_TSC_XGXS_DSC_MISC_CTRL0r_RXSEQSTART_AN_DISABLEf_SET(r,f) (r).dsc_misc_ctrl0[0]=(((r).dsc_misc_ctrl0[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCMI_TSC_XGXS_DSC_MISC_CTRL0r_TEST_BUS_SEL_BIT4f_GET(r) ((((r).dsc_misc_ctrl0[0]) >> 10) & 0x1)
#define BCMI_TSC_XGXS_DSC_MISC_CTRL0r_TEST_BUS_SEL_BIT4f_SET(r,f) (r).dsc_misc_ctrl0[0]=(((r).dsc_misc_ctrl0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCMI_TSC_XGXS_DSC_MISC_CTRL0r_CDRBR_SEL_FORCEf_GET(r) ((((r).dsc_misc_ctrl0[0]) >> 9) & 0x1)
#define BCMI_TSC_XGXS_DSC_MISC_CTRL0r_CDRBR_SEL_FORCEf_SET(r,f) (r).dsc_misc_ctrl0[0]=(((r).dsc_misc_ctrl0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCMI_TSC_XGXS_DSC_MISC_CTRL0r_CDRBR_SEL_FORCE_VALf_GET(r) ((((r).dsc_misc_ctrl0[0]) >> 8) & 0x1)
#define BCMI_TSC_XGXS_DSC_MISC_CTRL0r_CDRBR_SEL_FORCE_VALf_SET(r,f) (r).dsc_misc_ctrl0[0]=(((r).dsc_misc_ctrl0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCMI_TSC_XGXS_DSC_MISC_CTRL0r_OSR_MODE_FORCEf_GET(r) ((((r).dsc_misc_ctrl0[0]) >> 7) & 0x1)
#define BCMI_TSC_XGXS_DSC_MISC_CTRL0r_OSR_MODE_FORCEf_SET(r,f) (r).dsc_misc_ctrl0[0]=(((r).dsc_misc_ctrl0[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCMI_TSC_XGXS_DSC_MISC_CTRL0r_OSR_MODE_FORCE_VALf_GET(r) ((((r).dsc_misc_ctrl0[0]) >> 4) & 0x7)
#define BCMI_TSC_XGXS_DSC_MISC_CTRL0r_OSR_MODE_FORCE_VALf_SET(r,f) (r).dsc_misc_ctrl0[0]=(((r).dsc_misc_ctrl0[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4))
#define BCMI_TSC_XGXS_DSC_MISC_CTRL0r_TEST_BUS_SELf_GET(r) (((r).dsc_misc_ctrl0[0]) & 0xf)
#define BCMI_TSC_XGXS_DSC_MISC_CTRL0r_TEST_BUS_SELf_SET(r,f) (r).dsc_misc_ctrl0[0]=(((r).dsc_misc_ctrl0[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access DSC_MISC_CTRL0.
 *
 */
#define BCMI_TSC_XGXS_READ_DSC_MISC_CTRL0r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_DSC_MISC_CTRL0r,(_r._dsc_misc_ctrl0))
#define BCMI_TSC_XGXS_WRITE_DSC_MISC_CTRL0r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_DSC_MISC_CTRL0r,(_r._dsc_misc_ctrl0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_MISC_CTRL0r BCMI_TSC_XGXS_DSC_MISC_CTRL0r
#define DSC_MISC_CTRL0r_SIZE BCMI_TSC_XGXS_DSC_MISC_CTRL0r_SIZE
typedef BCMI_TSC_XGXS_DSC_MISC_CTRL0r_t DSC_MISC_CTRL0r_t;
#define DSC_MISC_CTRL0r_CLR BCMI_TSC_XGXS_DSC_MISC_CTRL0r_CLR
#define DSC_MISC_CTRL0r_SET BCMI_TSC_XGXS_DSC_MISC_CTRL0r_SET
#define DSC_MISC_CTRL0r_GET BCMI_TSC_XGXS_DSC_MISC_CTRL0r_GET
#define DSC_MISC_CTRL0r_RXSEQSTARTf_GET BCMI_TSC_XGXS_DSC_MISC_CTRL0r_RXSEQSTARTf_GET
#define DSC_MISC_CTRL0r_RXSEQSTARTf_SET BCMI_TSC_XGXS_DSC_MISC_CTRL0r_RXSEQSTARTf_SET
#define DSC_MISC_CTRL0r_FORCERXSEQDONEf_GET BCMI_TSC_XGXS_DSC_MISC_CTRL0r_FORCERXSEQDONEf_GET
#define DSC_MISC_CTRL0r_FORCERXSEQDONEf_SET BCMI_TSC_XGXS_DSC_MISC_CTRL0r_FORCERXSEQDONEf_SET
#define DSC_MISC_CTRL0r_RESERVED0f_GET BCMI_TSC_XGXS_DSC_MISC_CTRL0r_RESERVED0f_GET
#define DSC_MISC_CTRL0r_RESERVED0f_SET BCMI_TSC_XGXS_DSC_MISC_CTRL0r_RESERVED0f_SET
#define DSC_MISC_CTRL0r_FORCERXSEQDONE_VALf_GET BCMI_TSC_XGXS_DSC_MISC_CTRL0r_FORCERXSEQDONE_VALf_GET
#define DSC_MISC_CTRL0r_FORCERXSEQDONE_VALf_SET BCMI_TSC_XGXS_DSC_MISC_CTRL0r_FORCERXSEQDONE_VALf_SET
#define DSC_MISC_CTRL0r_RXSEQSTART_AN_DISABLEf_GET BCMI_TSC_XGXS_DSC_MISC_CTRL0r_RXSEQSTART_AN_DISABLEf_GET
#define DSC_MISC_CTRL0r_RXSEQSTART_AN_DISABLEf_SET BCMI_TSC_XGXS_DSC_MISC_CTRL0r_RXSEQSTART_AN_DISABLEf_SET
#define DSC_MISC_CTRL0r_TEST_BUS_SEL_BIT4f_GET BCMI_TSC_XGXS_DSC_MISC_CTRL0r_TEST_BUS_SEL_BIT4f_GET
#define DSC_MISC_CTRL0r_TEST_BUS_SEL_BIT4f_SET BCMI_TSC_XGXS_DSC_MISC_CTRL0r_TEST_BUS_SEL_BIT4f_SET
#define DSC_MISC_CTRL0r_CDRBR_SEL_FORCEf_GET BCMI_TSC_XGXS_DSC_MISC_CTRL0r_CDRBR_SEL_FORCEf_GET
#define DSC_MISC_CTRL0r_CDRBR_SEL_FORCEf_SET BCMI_TSC_XGXS_DSC_MISC_CTRL0r_CDRBR_SEL_FORCEf_SET
#define DSC_MISC_CTRL0r_CDRBR_SEL_FORCE_VALf_GET BCMI_TSC_XGXS_DSC_MISC_CTRL0r_CDRBR_SEL_FORCE_VALf_GET
#define DSC_MISC_CTRL0r_CDRBR_SEL_FORCE_VALf_SET BCMI_TSC_XGXS_DSC_MISC_CTRL0r_CDRBR_SEL_FORCE_VALf_SET
#define DSC_MISC_CTRL0r_OSR_MODE_FORCEf_GET BCMI_TSC_XGXS_DSC_MISC_CTRL0r_OSR_MODE_FORCEf_GET
#define DSC_MISC_CTRL0r_OSR_MODE_FORCEf_SET BCMI_TSC_XGXS_DSC_MISC_CTRL0r_OSR_MODE_FORCEf_SET
#define DSC_MISC_CTRL0r_OSR_MODE_FORCE_VALf_GET BCMI_TSC_XGXS_DSC_MISC_CTRL0r_OSR_MODE_FORCE_VALf_GET
#define DSC_MISC_CTRL0r_OSR_MODE_FORCE_VALf_SET BCMI_TSC_XGXS_DSC_MISC_CTRL0r_OSR_MODE_FORCE_VALf_SET
#define DSC_MISC_CTRL0r_TEST_BUS_SELf_GET BCMI_TSC_XGXS_DSC_MISC_CTRL0r_TEST_BUS_SELf_GET
#define DSC_MISC_CTRL0r_TEST_BUS_SELf_SET BCMI_TSC_XGXS_DSC_MISC_CTRL0r_TEST_BUS_SELf_SET
#define READ_DSC_MISC_CTRL0r BCMI_TSC_XGXS_READ_DSC_MISC_CTRL0r
#define WRITE_DSC_MISC_CTRL0r BCMI_TSC_XGXS_WRITE_DSC_MISC_CTRL0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_DSC_MISC_CTRL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CDR_STATUS0
 * BLOCKS:   DSC3B0
 * REGADDR:  0xc220
 * DESC:     CDR Status 0 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     INTEG_REG        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CDR_STATUS0r (0x0000c220 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CDR_STATUS0r_SIZE 4

/*
 * This structure should be used to declare and program CDR_STATUS0.
 *
 */
typedef union BCMI_TSC_XGXS_CDR_STATUS0r_s {
	uint32_t v[1];
	uint32_t cdr_status0[1];
	uint32_t _cdr_status0;
} BCMI_TSC_XGXS_CDR_STATUS0r_t;

#define BCMI_TSC_XGXS_CDR_STATUS0r_CLR(r) (r).cdr_status0[0] = 0
#define BCMI_TSC_XGXS_CDR_STATUS0r_SET(r,d) (r).cdr_status0[0] = d
#define BCMI_TSC_XGXS_CDR_STATUS0r_GET(r) (r).cdr_status0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CDR_STATUS0r_INTEG_REGf_GET(r) (((r).cdr_status0[0]) & 0xffff)
#define BCMI_TSC_XGXS_CDR_STATUS0r_INTEG_REGf_SET(r,f) (r).cdr_status0[0]=(((r).cdr_status0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access CDR_STATUS0.
 *
 */
#define BCMI_TSC_XGXS_READ_CDR_STATUS0r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CDR_STATUS0r,(_r._cdr_status0))
#define BCMI_TSC_XGXS_WRITE_CDR_STATUS0r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CDR_STATUS0r,(_r._cdr_status0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CDR_STATUS0r BCMI_TSC_XGXS_CDR_STATUS0r
#define CDR_STATUS0r_SIZE BCMI_TSC_XGXS_CDR_STATUS0r_SIZE
typedef BCMI_TSC_XGXS_CDR_STATUS0r_t CDR_STATUS0r_t;
#define CDR_STATUS0r_CLR BCMI_TSC_XGXS_CDR_STATUS0r_CLR
#define CDR_STATUS0r_SET BCMI_TSC_XGXS_CDR_STATUS0r_SET
#define CDR_STATUS0r_GET BCMI_TSC_XGXS_CDR_STATUS0r_GET
#define CDR_STATUS0r_INTEG_REGf_GET BCMI_TSC_XGXS_CDR_STATUS0r_INTEG_REGf_GET
#define CDR_STATUS0r_INTEG_REGf_SET BCMI_TSC_XGXS_CDR_STATUS0r_INTEG_REGf_SET
#define READ_CDR_STATUS0r BCMI_TSC_XGXS_READ_CDR_STATUS0r
#define WRITE_CDR_STATUS0r BCMI_TSC_XGXS_WRITE_CDR_STATUS0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CDR_STATUS0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CDR_STATUS1
 * BLOCKS:   DSC3B0
 * REGADDR:  0xc221
 * DESC:     CDR Status 1 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     INTEG_REG_XFER   
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CDR_STATUS1r (0x0000c221 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CDR_STATUS1r_SIZE 4

/*
 * This structure should be used to declare and program CDR_STATUS1.
 *
 */
typedef union BCMI_TSC_XGXS_CDR_STATUS1r_s {
	uint32_t v[1];
	uint32_t cdr_status1[1];
	uint32_t _cdr_status1;
} BCMI_TSC_XGXS_CDR_STATUS1r_t;

#define BCMI_TSC_XGXS_CDR_STATUS1r_CLR(r) (r).cdr_status1[0] = 0
#define BCMI_TSC_XGXS_CDR_STATUS1r_SET(r,d) (r).cdr_status1[0] = d
#define BCMI_TSC_XGXS_CDR_STATUS1r_GET(r) (r).cdr_status1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CDR_STATUS1r_INTEG_REG_XFERf_GET(r) (((r).cdr_status1[0]) & 0xffff)
#define BCMI_TSC_XGXS_CDR_STATUS1r_INTEG_REG_XFERf_SET(r,f) (r).cdr_status1[0]=(((r).cdr_status1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access CDR_STATUS1.
 *
 */
#define BCMI_TSC_XGXS_READ_CDR_STATUS1r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CDR_STATUS1r,(_r._cdr_status1))
#define BCMI_TSC_XGXS_WRITE_CDR_STATUS1r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CDR_STATUS1r,(_r._cdr_status1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CDR_STATUS1r BCMI_TSC_XGXS_CDR_STATUS1r
#define CDR_STATUS1r_SIZE BCMI_TSC_XGXS_CDR_STATUS1r_SIZE
typedef BCMI_TSC_XGXS_CDR_STATUS1r_t CDR_STATUS1r_t;
#define CDR_STATUS1r_CLR BCMI_TSC_XGXS_CDR_STATUS1r_CLR
#define CDR_STATUS1r_SET BCMI_TSC_XGXS_CDR_STATUS1r_SET
#define CDR_STATUS1r_GET BCMI_TSC_XGXS_CDR_STATUS1r_GET
#define CDR_STATUS1r_INTEG_REG_XFERf_GET BCMI_TSC_XGXS_CDR_STATUS1r_INTEG_REG_XFERf_GET
#define CDR_STATUS1r_INTEG_REG_XFERf_SET BCMI_TSC_XGXS_CDR_STATUS1r_INTEG_REG_XFERf_SET
#define READ_CDR_STATUS1r BCMI_TSC_XGXS_READ_CDR_STATUS1r
#define WRITE_CDR_STATUS1r BCMI_TSC_XGXS_WRITE_CDR_STATUS1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CDR_STATUS1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CDR_STATUS2
 * BLOCKS:   DSC3B0
 * REGADDR:  0xc222
 * DESC:     CDR Status 2 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     PHASE_ERR        
 *     OSCDR_MODE       
 *     BR_CDR_ENABLED   
 *     SM_BR_CDR_ENABLED 
 *     RX_FIFO_OS8_ERROR 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CDR_STATUS2r (0x0000c222 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CDR_STATUS2r_SIZE 4

/*
 * This structure should be used to declare and program CDR_STATUS2.
 *
 */
typedef union BCMI_TSC_XGXS_CDR_STATUS2r_s {
	uint32_t v[1];
	uint32_t cdr_status2[1];
	uint32_t _cdr_status2;
} BCMI_TSC_XGXS_CDR_STATUS2r_t;

#define BCMI_TSC_XGXS_CDR_STATUS2r_CLR(r) (r).cdr_status2[0] = 0
#define BCMI_TSC_XGXS_CDR_STATUS2r_SET(r,d) (r).cdr_status2[0] = d
#define BCMI_TSC_XGXS_CDR_STATUS2r_GET(r) (r).cdr_status2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CDR_STATUS2r_RESERVED0f_GET(r) ((((r).cdr_status2[0]) >> 12) & 0xf)
#define BCMI_TSC_XGXS_CDR_STATUS2r_RESERVED0f_SET(r,f) (r).cdr_status2[0]=(((r).cdr_status2[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCMI_TSC_XGXS_CDR_STATUS2r_RX_FIFO_OS8_ERRORf_GET(r) ((((r).cdr_status2[0]) >> 11) & 0x1)
#define BCMI_TSC_XGXS_CDR_STATUS2r_RX_FIFO_OS8_ERRORf_SET(r,f) (r).cdr_status2[0]=(((r).cdr_status2[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCMI_TSC_XGXS_CDR_STATUS2r_SM_BR_CDR_ENABLEDf_GET(r) ((((r).cdr_status2[0]) >> 10) & 0x1)
#define BCMI_TSC_XGXS_CDR_STATUS2r_SM_BR_CDR_ENABLEDf_SET(r,f) (r).cdr_status2[0]=(((r).cdr_status2[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCMI_TSC_XGXS_CDR_STATUS2r_BR_CDR_ENABLEDf_GET(r) ((((r).cdr_status2[0]) >> 9) & 0x1)
#define BCMI_TSC_XGXS_CDR_STATUS2r_BR_CDR_ENABLEDf_SET(r,f) (r).cdr_status2[0]=(((r).cdr_status2[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCMI_TSC_XGXS_CDR_STATUS2r_OSCDR_MODEf_GET(r) ((((r).cdr_status2[0]) >> 6) & 0x7)
#define BCMI_TSC_XGXS_CDR_STATUS2r_OSCDR_MODEf_SET(r,f) (r).cdr_status2[0]=(((r).cdr_status2[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCMI_TSC_XGXS_CDR_STATUS2r_PHASE_ERRf_GET(r) (((r).cdr_status2[0]) & 0x3f)
#define BCMI_TSC_XGXS_CDR_STATUS2r_PHASE_ERRf_SET(r,f) (r).cdr_status2[0]=(((r).cdr_status2[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))

/*
 * These macros can be used to access CDR_STATUS2.
 *
 */
#define BCMI_TSC_XGXS_READ_CDR_STATUS2r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CDR_STATUS2r,(_r._cdr_status2))
#define BCMI_TSC_XGXS_WRITE_CDR_STATUS2r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CDR_STATUS2r,(_r._cdr_status2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CDR_STATUS2r BCMI_TSC_XGXS_CDR_STATUS2r
#define CDR_STATUS2r_SIZE BCMI_TSC_XGXS_CDR_STATUS2r_SIZE
typedef BCMI_TSC_XGXS_CDR_STATUS2r_t CDR_STATUS2r_t;
#define CDR_STATUS2r_CLR BCMI_TSC_XGXS_CDR_STATUS2r_CLR
#define CDR_STATUS2r_SET BCMI_TSC_XGXS_CDR_STATUS2r_SET
#define CDR_STATUS2r_GET BCMI_TSC_XGXS_CDR_STATUS2r_GET
#define CDR_STATUS2r_RESERVED0f_GET BCMI_TSC_XGXS_CDR_STATUS2r_RESERVED0f_GET
#define CDR_STATUS2r_RESERVED0f_SET BCMI_TSC_XGXS_CDR_STATUS2r_RESERVED0f_SET
#define CDR_STATUS2r_RX_FIFO_OS8_ERRORf_GET BCMI_TSC_XGXS_CDR_STATUS2r_RX_FIFO_OS8_ERRORf_GET
#define CDR_STATUS2r_RX_FIFO_OS8_ERRORf_SET BCMI_TSC_XGXS_CDR_STATUS2r_RX_FIFO_OS8_ERRORf_SET
#define CDR_STATUS2r_SM_BR_CDR_ENABLEDf_GET BCMI_TSC_XGXS_CDR_STATUS2r_SM_BR_CDR_ENABLEDf_GET
#define CDR_STATUS2r_SM_BR_CDR_ENABLEDf_SET BCMI_TSC_XGXS_CDR_STATUS2r_SM_BR_CDR_ENABLEDf_SET
#define CDR_STATUS2r_BR_CDR_ENABLEDf_GET BCMI_TSC_XGXS_CDR_STATUS2r_BR_CDR_ENABLEDf_GET
#define CDR_STATUS2r_BR_CDR_ENABLEDf_SET BCMI_TSC_XGXS_CDR_STATUS2r_BR_CDR_ENABLEDf_SET
#define CDR_STATUS2r_OSCDR_MODEf_GET BCMI_TSC_XGXS_CDR_STATUS2r_OSCDR_MODEf_GET
#define CDR_STATUS2r_OSCDR_MODEf_SET BCMI_TSC_XGXS_CDR_STATUS2r_OSCDR_MODEf_SET
#define CDR_STATUS2r_PHASE_ERRf_GET BCMI_TSC_XGXS_CDR_STATUS2r_PHASE_ERRf_GET
#define CDR_STATUS2r_PHASE_ERRf_SET BCMI_TSC_XGXS_CDR_STATUS2r_PHASE_ERRf_SET
#define READ_CDR_STATUS2r BCMI_TSC_XGXS_READ_CDR_STATUS2r
#define WRITE_CDR_STATUS2r BCMI_TSC_XGXS_WRITE_CDR_STATUS2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CDR_STATUS2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  PI_STATUS0
 * BLOCKS:   DSC3B0
 * REGADDR:  0xc223
 * DESC:     Phase Interpolator Status 0 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     PHASE_CNTR       
 *     CLK90_PHASE_OFFSET 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_PI_STATUS0r (0x0000c223 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_PI_STATUS0r_SIZE 4

/*
 * This structure should be used to declare and program PI_STATUS0.
 *
 */
typedef union BCMI_TSC_XGXS_PI_STATUS0r_s {
	uint32_t v[1];
	uint32_t pi_status0[1];
	uint32_t _pi_status0;
} BCMI_TSC_XGXS_PI_STATUS0r_t;

#define BCMI_TSC_XGXS_PI_STATUS0r_CLR(r) (r).pi_status0[0] = 0
#define BCMI_TSC_XGXS_PI_STATUS0r_SET(r,d) (r).pi_status0[0] = d
#define BCMI_TSC_XGXS_PI_STATUS0r_GET(r) (r).pi_status0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_PI_STATUS0r_RESERVED0f_GET(r) ((((r).pi_status0[0]) >> 14) & 0x3)
#define BCMI_TSC_XGXS_PI_STATUS0r_RESERVED0f_SET(r,f) (r).pi_status0[0]=(((r).pi_status0[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCMI_TSC_XGXS_PI_STATUS0r_CLK90_PHASE_OFFSETf_GET(r) ((((r).pi_status0[0]) >> 7) & 0x7f)
#define BCMI_TSC_XGXS_PI_STATUS0r_CLK90_PHASE_OFFSETf_SET(r,f) (r).pi_status0[0]=(((r).pi_status0[0] & ~((uint32_t)0x7f << 7)) | ((((uint32_t)f) & 0x7f) << 7))
#define BCMI_TSC_XGXS_PI_STATUS0r_PHASE_CNTRf_GET(r) (((r).pi_status0[0]) & 0x7f)
#define BCMI_TSC_XGXS_PI_STATUS0r_PHASE_CNTRf_SET(r,f) (r).pi_status0[0]=(((r).pi_status0[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f))

/*
 * These macros can be used to access PI_STATUS0.
 *
 */
#define BCMI_TSC_XGXS_READ_PI_STATUS0r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_PI_STATUS0r,(_r._pi_status0))
#define BCMI_TSC_XGXS_WRITE_PI_STATUS0r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_PI_STATUS0r,(_r._pi_status0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PI_STATUS0r BCMI_TSC_XGXS_PI_STATUS0r
#define PI_STATUS0r_SIZE BCMI_TSC_XGXS_PI_STATUS0r_SIZE
typedef BCMI_TSC_XGXS_PI_STATUS0r_t PI_STATUS0r_t;
#define PI_STATUS0r_CLR BCMI_TSC_XGXS_PI_STATUS0r_CLR
#define PI_STATUS0r_SET BCMI_TSC_XGXS_PI_STATUS0r_SET
#define PI_STATUS0r_GET BCMI_TSC_XGXS_PI_STATUS0r_GET
#define PI_STATUS0r_RESERVED0f_GET BCMI_TSC_XGXS_PI_STATUS0r_RESERVED0f_GET
#define PI_STATUS0r_RESERVED0f_SET BCMI_TSC_XGXS_PI_STATUS0r_RESERVED0f_SET
#define PI_STATUS0r_CLK90_PHASE_OFFSETf_GET BCMI_TSC_XGXS_PI_STATUS0r_CLK90_PHASE_OFFSETf_GET
#define PI_STATUS0r_CLK90_PHASE_OFFSETf_SET BCMI_TSC_XGXS_PI_STATUS0r_CLK90_PHASE_OFFSETf_SET
#define PI_STATUS0r_PHASE_CNTRf_GET BCMI_TSC_XGXS_PI_STATUS0r_PHASE_CNTRf_GET
#define PI_STATUS0r_PHASE_CNTRf_SET BCMI_TSC_XGXS_PI_STATUS0r_PHASE_CNTRf_SET
#define READ_PI_STATUS0r BCMI_TSC_XGXS_READ_PI_STATUS0r
#define WRITE_PI_STATUS0r BCMI_TSC_XGXS_WRITE_PI_STATUS0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_PI_STATUS0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  PI_STATUS1
 * BLOCKS:   DSC3B0
 * REGADDR:  0xc224
 * DESC:     Phase Interpolator Status 1 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     PHS_INTERP_STATUS 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_PI_STATUS1r (0x0000c224 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_PI_STATUS1r_SIZE 4

/*
 * This structure should be used to declare and program PI_STATUS1.
 *
 */
typedef union BCMI_TSC_XGXS_PI_STATUS1r_s {
	uint32_t v[1];
	uint32_t pi_status1[1];
	uint32_t _pi_status1;
} BCMI_TSC_XGXS_PI_STATUS1r_t;

#define BCMI_TSC_XGXS_PI_STATUS1r_CLR(r) (r).pi_status1[0] = 0
#define BCMI_TSC_XGXS_PI_STATUS1r_SET(r,d) (r).pi_status1[0] = d
#define BCMI_TSC_XGXS_PI_STATUS1r_GET(r) (r).pi_status1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_PI_STATUS1r_PHS_INTERP_STATUSf_GET(r) (((r).pi_status1[0]) & 0xffff)
#define BCMI_TSC_XGXS_PI_STATUS1r_PHS_INTERP_STATUSf_SET(r,f) (r).pi_status1[0]=(((r).pi_status1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PI_STATUS1.
 *
 */
#define BCMI_TSC_XGXS_READ_PI_STATUS1r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_PI_STATUS1r,(_r._pi_status1))
#define BCMI_TSC_XGXS_WRITE_PI_STATUS1r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_PI_STATUS1r,(_r._pi_status1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PI_STATUS1r BCMI_TSC_XGXS_PI_STATUS1r
#define PI_STATUS1r_SIZE BCMI_TSC_XGXS_PI_STATUS1r_SIZE
typedef BCMI_TSC_XGXS_PI_STATUS1r_t PI_STATUS1r_t;
#define PI_STATUS1r_CLR BCMI_TSC_XGXS_PI_STATUS1r_CLR
#define PI_STATUS1r_SET BCMI_TSC_XGXS_PI_STATUS1r_SET
#define PI_STATUS1r_GET BCMI_TSC_XGXS_PI_STATUS1r_GET
#define PI_STATUS1r_PHS_INTERP_STATUSf_GET BCMI_TSC_XGXS_PI_STATUS1r_PHS_INTERP_STATUSf_GET
#define PI_STATUS1r_PHS_INTERP_STATUSf_SET BCMI_TSC_XGXS_PI_STATUS1r_PHS_INTERP_STATUSf_SET
#define READ_PI_STATUS1r BCMI_TSC_XGXS_READ_PI_STATUS1r
#define WRITE_PI_STATUS1r BCMI_TSC_XGXS_WRITE_PI_STATUS1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_PI_STATUS1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  DFE_VGA_STATUS0
 * BLOCKS:   DSC3B0
 * REGADDR:  0xc225
 * DESC:     DFE VGA Status 0 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     VGA_SUM          
 *     DFE_TAP_1_BIN    
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_DFE_VGA_STATUS0r (0x0000c225 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_DFE_VGA_STATUS0r_SIZE 4

/*
 * This structure should be used to declare and program DFE_VGA_STATUS0.
 *
 */
typedef union BCMI_TSC_XGXS_DFE_VGA_STATUS0r_s {
	uint32_t v[1];
	uint32_t dfe_vga_status0[1];
	uint32_t _dfe_vga_status0;
} BCMI_TSC_XGXS_DFE_VGA_STATUS0r_t;

#define BCMI_TSC_XGXS_DFE_VGA_STATUS0r_CLR(r) (r).dfe_vga_status0[0] = 0
#define BCMI_TSC_XGXS_DFE_VGA_STATUS0r_SET(r,d) (r).dfe_vga_status0[0] = d
#define BCMI_TSC_XGXS_DFE_VGA_STATUS0r_GET(r) (r).dfe_vga_status0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_DFE_VGA_STATUS0r_RESERVED0f_GET(r) ((((r).dfe_vga_status0[0]) >> 12) & 0xf)
#define BCMI_TSC_XGXS_DFE_VGA_STATUS0r_RESERVED0f_SET(r,f) (r).dfe_vga_status0[0]=(((r).dfe_vga_status0[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCMI_TSC_XGXS_DFE_VGA_STATUS0r_DFE_TAP_1_BINf_GET(r) ((((r).dfe_vga_status0[0]) >> 6) & 0x3f)
#define BCMI_TSC_XGXS_DFE_VGA_STATUS0r_DFE_TAP_1_BINf_SET(r,f) (r).dfe_vga_status0[0]=(((r).dfe_vga_status0[0] & ~((uint32_t)0x3f << 6)) | ((((uint32_t)f) & 0x3f) << 6))
#define BCMI_TSC_XGXS_DFE_VGA_STATUS0r_VGA_SUMf_GET(r) (((r).dfe_vga_status0[0]) & 0x3f)
#define BCMI_TSC_XGXS_DFE_VGA_STATUS0r_VGA_SUMf_SET(r,f) (r).dfe_vga_status0[0]=(((r).dfe_vga_status0[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))

/*
 * These macros can be used to access DFE_VGA_STATUS0.
 *
 */
#define BCMI_TSC_XGXS_READ_DFE_VGA_STATUS0r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_DFE_VGA_STATUS0r,(_r._dfe_vga_status0))
#define BCMI_TSC_XGXS_WRITE_DFE_VGA_STATUS0r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_DFE_VGA_STATUS0r,(_r._dfe_vga_status0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DFE_VGA_STATUS0r BCMI_TSC_XGXS_DFE_VGA_STATUS0r
#define DFE_VGA_STATUS0r_SIZE BCMI_TSC_XGXS_DFE_VGA_STATUS0r_SIZE
typedef BCMI_TSC_XGXS_DFE_VGA_STATUS0r_t DFE_VGA_STATUS0r_t;
#define DFE_VGA_STATUS0r_CLR BCMI_TSC_XGXS_DFE_VGA_STATUS0r_CLR
#define DFE_VGA_STATUS0r_SET BCMI_TSC_XGXS_DFE_VGA_STATUS0r_SET
#define DFE_VGA_STATUS0r_GET BCMI_TSC_XGXS_DFE_VGA_STATUS0r_GET
#define DFE_VGA_STATUS0r_RESERVED0f_GET BCMI_TSC_XGXS_DFE_VGA_STATUS0r_RESERVED0f_GET
#define DFE_VGA_STATUS0r_RESERVED0f_SET BCMI_TSC_XGXS_DFE_VGA_STATUS0r_RESERVED0f_SET
#define DFE_VGA_STATUS0r_DFE_TAP_1_BINf_GET BCMI_TSC_XGXS_DFE_VGA_STATUS0r_DFE_TAP_1_BINf_GET
#define DFE_VGA_STATUS0r_DFE_TAP_1_BINf_SET BCMI_TSC_XGXS_DFE_VGA_STATUS0r_DFE_TAP_1_BINf_SET
#define DFE_VGA_STATUS0r_VGA_SUMf_GET BCMI_TSC_XGXS_DFE_VGA_STATUS0r_VGA_SUMf_GET
#define DFE_VGA_STATUS0r_VGA_SUMf_SET BCMI_TSC_XGXS_DFE_VGA_STATUS0r_VGA_SUMf_SET
#define READ_DFE_VGA_STATUS0r BCMI_TSC_XGXS_READ_DFE_VGA_STATUS0r
#define WRITE_DFE_VGA_STATUS0r BCMI_TSC_XGXS_WRITE_DFE_VGA_STATUS0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_DFE_VGA_STATUS0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  DFE_VGA_STATUS1
 * BLOCKS:   DSC3B0
 * REGADDR:  0xc226
 * DESC:     DFE VGA Status 1 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     DFE_TAP_2_BIN    
 *     DFE_TAP_3_BIN    
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_DFE_VGA_STATUS1r (0x0000c226 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_DFE_VGA_STATUS1r_SIZE 4

/*
 * This structure should be used to declare and program DFE_VGA_STATUS1.
 *
 */
typedef union BCMI_TSC_XGXS_DFE_VGA_STATUS1r_s {
	uint32_t v[1];
	uint32_t dfe_vga_status1[1];
	uint32_t _dfe_vga_status1;
} BCMI_TSC_XGXS_DFE_VGA_STATUS1r_t;

#define BCMI_TSC_XGXS_DFE_VGA_STATUS1r_CLR(r) (r).dfe_vga_status1[0] = 0
#define BCMI_TSC_XGXS_DFE_VGA_STATUS1r_SET(r,d) (r).dfe_vga_status1[0] = d
#define BCMI_TSC_XGXS_DFE_VGA_STATUS1r_GET(r) (r).dfe_vga_status1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_DFE_VGA_STATUS1r_RESERVED0f_GET(r) ((((r).dfe_vga_status1[0]) >> 12) & 0xf)
#define BCMI_TSC_XGXS_DFE_VGA_STATUS1r_RESERVED0f_SET(r,f) (r).dfe_vga_status1[0]=(((r).dfe_vga_status1[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCMI_TSC_XGXS_DFE_VGA_STATUS1r_DFE_TAP_3_BINf_GET(r) ((((r).dfe_vga_status1[0]) >> 6) & 0x3f)
#define BCMI_TSC_XGXS_DFE_VGA_STATUS1r_DFE_TAP_3_BINf_SET(r,f) (r).dfe_vga_status1[0]=(((r).dfe_vga_status1[0] & ~((uint32_t)0x3f << 6)) | ((((uint32_t)f) & 0x3f) << 6))
#define BCMI_TSC_XGXS_DFE_VGA_STATUS1r_DFE_TAP_2_BINf_GET(r) (((r).dfe_vga_status1[0]) & 0x3f)
#define BCMI_TSC_XGXS_DFE_VGA_STATUS1r_DFE_TAP_2_BINf_SET(r,f) (r).dfe_vga_status1[0]=(((r).dfe_vga_status1[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))

/*
 * These macros can be used to access DFE_VGA_STATUS1.
 *
 */
#define BCMI_TSC_XGXS_READ_DFE_VGA_STATUS1r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_DFE_VGA_STATUS1r,(_r._dfe_vga_status1))
#define BCMI_TSC_XGXS_WRITE_DFE_VGA_STATUS1r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_DFE_VGA_STATUS1r,(_r._dfe_vga_status1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DFE_VGA_STATUS1r BCMI_TSC_XGXS_DFE_VGA_STATUS1r
#define DFE_VGA_STATUS1r_SIZE BCMI_TSC_XGXS_DFE_VGA_STATUS1r_SIZE
typedef BCMI_TSC_XGXS_DFE_VGA_STATUS1r_t DFE_VGA_STATUS1r_t;
#define DFE_VGA_STATUS1r_CLR BCMI_TSC_XGXS_DFE_VGA_STATUS1r_CLR
#define DFE_VGA_STATUS1r_SET BCMI_TSC_XGXS_DFE_VGA_STATUS1r_SET
#define DFE_VGA_STATUS1r_GET BCMI_TSC_XGXS_DFE_VGA_STATUS1r_GET
#define DFE_VGA_STATUS1r_RESERVED0f_GET BCMI_TSC_XGXS_DFE_VGA_STATUS1r_RESERVED0f_GET
#define DFE_VGA_STATUS1r_RESERVED0f_SET BCMI_TSC_XGXS_DFE_VGA_STATUS1r_RESERVED0f_SET
#define DFE_VGA_STATUS1r_DFE_TAP_3_BINf_GET BCMI_TSC_XGXS_DFE_VGA_STATUS1r_DFE_TAP_3_BINf_GET
#define DFE_VGA_STATUS1r_DFE_TAP_3_BINf_SET BCMI_TSC_XGXS_DFE_VGA_STATUS1r_DFE_TAP_3_BINf_SET
#define DFE_VGA_STATUS1r_DFE_TAP_2_BINf_GET BCMI_TSC_XGXS_DFE_VGA_STATUS1r_DFE_TAP_2_BINf_GET
#define DFE_VGA_STATUS1r_DFE_TAP_2_BINf_SET BCMI_TSC_XGXS_DFE_VGA_STATUS1r_DFE_TAP_2_BINf_SET
#define READ_DFE_VGA_STATUS1r BCMI_TSC_XGXS_READ_DFE_VGA_STATUS1r
#define WRITE_DFE_VGA_STATUS1r BCMI_TSC_XGXS_WRITE_DFE_VGA_STATUS1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_DFE_VGA_STATUS1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  DFE_VGA_STATUS2
 * BLOCKS:   DSC3B0
 * REGADDR:  0xc227
 * DESC:     DFE VGA Status 2 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     DFE_TAP_4_BIN    
 *     DFE_TAP_5_BIN    
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_DFE_VGA_STATUS2r (0x0000c227 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_DFE_VGA_STATUS2r_SIZE 4

/*
 * This structure should be used to declare and program DFE_VGA_STATUS2.
 *
 */
typedef union BCMI_TSC_XGXS_DFE_VGA_STATUS2r_s {
	uint32_t v[1];
	uint32_t dfe_vga_status2[1];
	uint32_t _dfe_vga_status2;
} BCMI_TSC_XGXS_DFE_VGA_STATUS2r_t;

#define BCMI_TSC_XGXS_DFE_VGA_STATUS2r_CLR(r) (r).dfe_vga_status2[0] = 0
#define BCMI_TSC_XGXS_DFE_VGA_STATUS2r_SET(r,d) (r).dfe_vga_status2[0] = d
#define BCMI_TSC_XGXS_DFE_VGA_STATUS2r_GET(r) (r).dfe_vga_status2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_DFE_VGA_STATUS2r_RESERVED0f_GET(r) ((((r).dfe_vga_status2[0]) >> 10) & 0x3f)
#define BCMI_TSC_XGXS_DFE_VGA_STATUS2r_RESERVED0f_SET(r,f) (r).dfe_vga_status2[0]=(((r).dfe_vga_status2[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))
#define BCMI_TSC_XGXS_DFE_VGA_STATUS2r_DFE_TAP_5_BINf_GET(r) ((((r).dfe_vga_status2[0]) >> 5) & 0x1f)
#define BCMI_TSC_XGXS_DFE_VGA_STATUS2r_DFE_TAP_5_BINf_SET(r,f) (r).dfe_vga_status2[0]=(((r).dfe_vga_status2[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5))
#define BCMI_TSC_XGXS_DFE_VGA_STATUS2r_DFE_TAP_4_BINf_GET(r) (((r).dfe_vga_status2[0]) & 0x1f)
#define BCMI_TSC_XGXS_DFE_VGA_STATUS2r_DFE_TAP_4_BINf_SET(r,f) (r).dfe_vga_status2[0]=(((r).dfe_vga_status2[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))

/*
 * These macros can be used to access DFE_VGA_STATUS2.
 *
 */
#define BCMI_TSC_XGXS_READ_DFE_VGA_STATUS2r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_DFE_VGA_STATUS2r,(_r._dfe_vga_status2))
#define BCMI_TSC_XGXS_WRITE_DFE_VGA_STATUS2r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_DFE_VGA_STATUS2r,(_r._dfe_vga_status2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DFE_VGA_STATUS2r BCMI_TSC_XGXS_DFE_VGA_STATUS2r
#define DFE_VGA_STATUS2r_SIZE BCMI_TSC_XGXS_DFE_VGA_STATUS2r_SIZE
typedef BCMI_TSC_XGXS_DFE_VGA_STATUS2r_t DFE_VGA_STATUS2r_t;
#define DFE_VGA_STATUS2r_CLR BCMI_TSC_XGXS_DFE_VGA_STATUS2r_CLR
#define DFE_VGA_STATUS2r_SET BCMI_TSC_XGXS_DFE_VGA_STATUS2r_SET
#define DFE_VGA_STATUS2r_GET BCMI_TSC_XGXS_DFE_VGA_STATUS2r_GET
#define DFE_VGA_STATUS2r_RESERVED0f_GET BCMI_TSC_XGXS_DFE_VGA_STATUS2r_RESERVED0f_GET
#define DFE_VGA_STATUS2r_RESERVED0f_SET BCMI_TSC_XGXS_DFE_VGA_STATUS2r_RESERVED0f_SET
#define DFE_VGA_STATUS2r_DFE_TAP_5_BINf_GET BCMI_TSC_XGXS_DFE_VGA_STATUS2r_DFE_TAP_5_BINf_GET
#define DFE_VGA_STATUS2r_DFE_TAP_5_BINf_SET BCMI_TSC_XGXS_DFE_VGA_STATUS2r_DFE_TAP_5_BINf_SET
#define DFE_VGA_STATUS2r_DFE_TAP_4_BINf_GET BCMI_TSC_XGXS_DFE_VGA_STATUS2r_DFE_TAP_4_BINf_GET
#define DFE_VGA_STATUS2r_DFE_TAP_4_BINf_SET BCMI_TSC_XGXS_DFE_VGA_STATUS2r_DFE_TAP_4_BINf_SET
#define READ_DFE_VGA_STATUS2r BCMI_TSC_XGXS_READ_DFE_VGA_STATUS2r
#define WRITE_DFE_VGA_STATUS2r BCMI_TSC_XGXS_WRITE_DFE_VGA_STATUS2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_DFE_VGA_STATUS2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  DFE_VGA_STATUS3
 * BLOCKS:   DSC3B0
 * REGADDR:  0xc228
 * DESC:     DFE VGA Status 3 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     TRNSUM           
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_DFE_VGA_STATUS3r (0x0000c228 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_DFE_VGA_STATUS3r_SIZE 4

/*
 * This structure should be used to declare and program DFE_VGA_STATUS3.
 *
 */
typedef union BCMI_TSC_XGXS_DFE_VGA_STATUS3r_s {
	uint32_t v[1];
	uint32_t dfe_vga_status3[1];
	uint32_t _dfe_vga_status3;
} BCMI_TSC_XGXS_DFE_VGA_STATUS3r_t;

#define BCMI_TSC_XGXS_DFE_VGA_STATUS3r_CLR(r) (r).dfe_vga_status3[0] = 0
#define BCMI_TSC_XGXS_DFE_VGA_STATUS3r_SET(r,d) (r).dfe_vga_status3[0] = d
#define BCMI_TSC_XGXS_DFE_VGA_STATUS3r_GET(r) (r).dfe_vga_status3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_DFE_VGA_STATUS3r_RESERVED0f_GET(r) ((((r).dfe_vga_status3[0]) >> 11) & 0x1f)
#define BCMI_TSC_XGXS_DFE_VGA_STATUS3r_RESERVED0f_SET(r,f) (r).dfe_vga_status3[0]=(((r).dfe_vga_status3[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))
#define BCMI_TSC_XGXS_DFE_VGA_STATUS3r_TRNSUMf_GET(r) (((r).dfe_vga_status3[0]) & 0x7ff)
#define BCMI_TSC_XGXS_DFE_VGA_STATUS3r_TRNSUMf_SET(r,f) (r).dfe_vga_status3[0]=(((r).dfe_vga_status3[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))

/*
 * These macros can be used to access DFE_VGA_STATUS3.
 *
 */
#define BCMI_TSC_XGXS_READ_DFE_VGA_STATUS3r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_DFE_VGA_STATUS3r,(_r._dfe_vga_status3))
#define BCMI_TSC_XGXS_WRITE_DFE_VGA_STATUS3r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_DFE_VGA_STATUS3r,(_r._dfe_vga_status3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DFE_VGA_STATUS3r BCMI_TSC_XGXS_DFE_VGA_STATUS3r
#define DFE_VGA_STATUS3r_SIZE BCMI_TSC_XGXS_DFE_VGA_STATUS3r_SIZE
typedef BCMI_TSC_XGXS_DFE_VGA_STATUS3r_t DFE_VGA_STATUS3r_t;
#define DFE_VGA_STATUS3r_CLR BCMI_TSC_XGXS_DFE_VGA_STATUS3r_CLR
#define DFE_VGA_STATUS3r_SET BCMI_TSC_XGXS_DFE_VGA_STATUS3r_SET
#define DFE_VGA_STATUS3r_GET BCMI_TSC_XGXS_DFE_VGA_STATUS3r_GET
#define DFE_VGA_STATUS3r_RESERVED0f_GET BCMI_TSC_XGXS_DFE_VGA_STATUS3r_RESERVED0f_GET
#define DFE_VGA_STATUS3r_RESERVED0f_SET BCMI_TSC_XGXS_DFE_VGA_STATUS3r_RESERVED0f_SET
#define DFE_VGA_STATUS3r_TRNSUMf_GET BCMI_TSC_XGXS_DFE_VGA_STATUS3r_TRNSUMf_GET
#define DFE_VGA_STATUS3r_TRNSUMf_SET BCMI_TSC_XGXS_DFE_VGA_STATUS3r_TRNSUMf_SET
#define READ_DFE_VGA_STATUS3r BCMI_TSC_XGXS_READ_DFE_VGA_STATUS3r
#define WRITE_DFE_VGA_STATUS3r BCMI_TSC_XGXS_WRITE_DFE_VGA_STATUS3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_DFE_VGA_STATUS3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  ACQ_SM_STATUS0
 * BLOCKS:   DSC3B0
 * REGADDR:  0xc229
 * DESC:     ACQ State Machine Status 0 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     DSC_STATE        
 *     RESERVED1        
 *     DSC_STATE_EEE_ACQ_2 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_ACQ_SM_STATUS0r (0x0000c229 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_ACQ_SM_STATUS0r_SIZE 4

/*
 * This structure should be used to declare and program ACQ_SM_STATUS0.
 *
 */
typedef union BCMI_TSC_XGXS_ACQ_SM_STATUS0r_s {
	uint32_t v[1];
	uint32_t acq_sm_status0[1];
	uint32_t _acq_sm_status0;
} BCMI_TSC_XGXS_ACQ_SM_STATUS0r_t;

#define BCMI_TSC_XGXS_ACQ_SM_STATUS0r_CLR(r) (r).acq_sm_status0[0] = 0
#define BCMI_TSC_XGXS_ACQ_SM_STATUS0r_SET(r,d) (r).acq_sm_status0[0] = d
#define BCMI_TSC_XGXS_ACQ_SM_STATUS0r_GET(r) (r).acq_sm_status0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_ACQ_SM_STATUS0r_RESERVED0f_GET(r) ((((r).acq_sm_status0[0]) >> 9) & 0x7f)
#define BCMI_TSC_XGXS_ACQ_SM_STATUS0r_RESERVED0f_SET(r,f) (r).acq_sm_status0[0]=(((r).acq_sm_status0[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))
#define BCMI_TSC_XGXS_ACQ_SM_STATUS0r_DSC_STATE_EEE_ACQ_2f_GET(r) ((((r).acq_sm_status0[0]) >> 8) & 0x1)
#define BCMI_TSC_XGXS_ACQ_SM_STATUS0r_DSC_STATE_EEE_ACQ_2f_SET(r,f) (r).acq_sm_status0[0]=(((r).acq_sm_status0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCMI_TSC_XGXS_ACQ_SM_STATUS0r_RESERVED1f_GET(r) ((((r).acq_sm_status0[0]) >> 5) & 0x7)
#define BCMI_TSC_XGXS_ACQ_SM_STATUS0r_RESERVED1f_SET(r,f) (r).acq_sm_status0[0]=(((r).acq_sm_status0[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))
#define BCMI_TSC_XGXS_ACQ_SM_STATUS0r_DSC_STATEf_GET(r) (((r).acq_sm_status0[0]) & 0x1f)
#define BCMI_TSC_XGXS_ACQ_SM_STATUS0r_DSC_STATEf_SET(r,f) (r).acq_sm_status0[0]=(((r).acq_sm_status0[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))

/*
 * These macros can be used to access ACQ_SM_STATUS0.
 *
 */
#define BCMI_TSC_XGXS_READ_ACQ_SM_STATUS0r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_ACQ_SM_STATUS0r,(_r._acq_sm_status0))
#define BCMI_TSC_XGXS_WRITE_ACQ_SM_STATUS0r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_ACQ_SM_STATUS0r,(_r._acq_sm_status0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define ACQ_SM_STATUS0r BCMI_TSC_XGXS_ACQ_SM_STATUS0r
#define ACQ_SM_STATUS0r_SIZE BCMI_TSC_XGXS_ACQ_SM_STATUS0r_SIZE
typedef BCMI_TSC_XGXS_ACQ_SM_STATUS0r_t ACQ_SM_STATUS0r_t;
#define ACQ_SM_STATUS0r_CLR BCMI_TSC_XGXS_ACQ_SM_STATUS0r_CLR
#define ACQ_SM_STATUS0r_SET BCMI_TSC_XGXS_ACQ_SM_STATUS0r_SET
#define ACQ_SM_STATUS0r_GET BCMI_TSC_XGXS_ACQ_SM_STATUS0r_GET
#define ACQ_SM_STATUS0r_RESERVED0f_GET BCMI_TSC_XGXS_ACQ_SM_STATUS0r_RESERVED0f_GET
#define ACQ_SM_STATUS0r_RESERVED0f_SET BCMI_TSC_XGXS_ACQ_SM_STATUS0r_RESERVED0f_SET
#define ACQ_SM_STATUS0r_DSC_STATE_EEE_ACQ_2f_GET BCMI_TSC_XGXS_ACQ_SM_STATUS0r_DSC_STATE_EEE_ACQ_2f_GET
#define ACQ_SM_STATUS0r_DSC_STATE_EEE_ACQ_2f_SET BCMI_TSC_XGXS_ACQ_SM_STATUS0r_DSC_STATE_EEE_ACQ_2f_SET
#define ACQ_SM_STATUS0r_RESERVED1f_GET BCMI_TSC_XGXS_ACQ_SM_STATUS0r_RESERVED1f_GET
#define ACQ_SM_STATUS0r_RESERVED1f_SET BCMI_TSC_XGXS_ACQ_SM_STATUS0r_RESERVED1f_SET
#define ACQ_SM_STATUS0r_DSC_STATEf_GET BCMI_TSC_XGXS_ACQ_SM_STATUS0r_DSC_STATEf_GET
#define ACQ_SM_STATUS0r_DSC_STATEf_SET BCMI_TSC_XGXS_ACQ_SM_STATUS0r_DSC_STATEf_SET
#define READ_ACQ_SM_STATUS0r BCMI_TSC_XGXS_READ_ACQ_SM_STATUS0r
#define WRITE_ACQ_SM_STATUS0r BCMI_TSC_XGXS_WRITE_ACQ_SM_STATUS0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_ACQ_SM_STATUS0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  ACQ_SM_STATUS1
 * BLOCKS:   DSC3B0
 * REGADDR:  0xc22a
 * DESC:     ACQ State Machine Status 1 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     DSC_STATE_INIT   
 *     DSC_STATE_PAUSE  
 *     DSC_STATE_SETUP  
 *     DSC_STATE_ACQ_VGA 
 *     DSC_STATE_OS_INTEG_XFER 
 *     DSC_STATE_ACQ_CDRBR_PHASE 
 *     DSC_STATE_ACQ_CDR 
 *     DSC_STATE_ACQ_1  
 *     DSC_STATE_ACQ_2  
 *     DSC_STATE_SOFT_ACK 
 *     DSC_STATE_TRAIN_1 
 *     DSC_STATE_TRAIN_2 
 *     DSC_STATE_MEASURE 
 *     DSC_STATE_DONE   
 *     DSC_STATE_EEE_QUIET 
 *     DSC_STATE_EEE_ACQ_CDR_PHASE 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_ACQ_SM_STATUS1r (0x0000c22a | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_ACQ_SM_STATUS1r_SIZE 4

/*
 * This structure should be used to declare and program ACQ_SM_STATUS1.
 *
 */
typedef union BCMI_TSC_XGXS_ACQ_SM_STATUS1r_s {
	uint32_t v[1];
	uint32_t acq_sm_status1[1];
	uint32_t _acq_sm_status1;
} BCMI_TSC_XGXS_ACQ_SM_STATUS1r_t;

#define BCMI_TSC_XGXS_ACQ_SM_STATUS1r_CLR(r) (r).acq_sm_status1[0] = 0
#define BCMI_TSC_XGXS_ACQ_SM_STATUS1r_SET(r,d) (r).acq_sm_status1[0] = d
#define BCMI_TSC_XGXS_ACQ_SM_STATUS1r_GET(r) (r).acq_sm_status1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_ACQ_SM_STATUS1r_DSC_STATE_EEE_ACQ_CDR_PHASEf_GET(r) ((((r).acq_sm_status1[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_ACQ_SM_STATUS1r_DSC_STATE_EEE_ACQ_CDR_PHASEf_SET(r,f) (r).acq_sm_status1[0]=(((r).acq_sm_status1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_ACQ_SM_STATUS1r_DSC_STATE_EEE_QUIETf_GET(r) ((((r).acq_sm_status1[0]) >> 14) & 0x1)
#define BCMI_TSC_XGXS_ACQ_SM_STATUS1r_DSC_STATE_EEE_QUIETf_SET(r,f) (r).acq_sm_status1[0]=(((r).acq_sm_status1[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCMI_TSC_XGXS_ACQ_SM_STATUS1r_DSC_STATE_DONEf_GET(r) ((((r).acq_sm_status1[0]) >> 13) & 0x1)
#define BCMI_TSC_XGXS_ACQ_SM_STATUS1r_DSC_STATE_DONEf_SET(r,f) (r).acq_sm_status1[0]=(((r).acq_sm_status1[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCMI_TSC_XGXS_ACQ_SM_STATUS1r_DSC_STATE_MEASUREf_GET(r) ((((r).acq_sm_status1[0]) >> 12) & 0x1)
#define BCMI_TSC_XGXS_ACQ_SM_STATUS1r_DSC_STATE_MEASUREf_SET(r,f) (r).acq_sm_status1[0]=(((r).acq_sm_status1[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCMI_TSC_XGXS_ACQ_SM_STATUS1r_DSC_STATE_TRAIN_2f_GET(r) ((((r).acq_sm_status1[0]) >> 11) & 0x1)
#define BCMI_TSC_XGXS_ACQ_SM_STATUS1r_DSC_STATE_TRAIN_2f_SET(r,f) (r).acq_sm_status1[0]=(((r).acq_sm_status1[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCMI_TSC_XGXS_ACQ_SM_STATUS1r_DSC_STATE_TRAIN_1f_GET(r) ((((r).acq_sm_status1[0]) >> 10) & 0x1)
#define BCMI_TSC_XGXS_ACQ_SM_STATUS1r_DSC_STATE_TRAIN_1f_SET(r,f) (r).acq_sm_status1[0]=(((r).acq_sm_status1[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCMI_TSC_XGXS_ACQ_SM_STATUS1r_DSC_STATE_SOFT_ACKf_GET(r) ((((r).acq_sm_status1[0]) >> 9) & 0x1)
#define BCMI_TSC_XGXS_ACQ_SM_STATUS1r_DSC_STATE_SOFT_ACKf_SET(r,f) (r).acq_sm_status1[0]=(((r).acq_sm_status1[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCMI_TSC_XGXS_ACQ_SM_STATUS1r_DSC_STATE_ACQ_2f_GET(r) ((((r).acq_sm_status1[0]) >> 8) & 0x1)
#define BCMI_TSC_XGXS_ACQ_SM_STATUS1r_DSC_STATE_ACQ_2f_SET(r,f) (r).acq_sm_status1[0]=(((r).acq_sm_status1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCMI_TSC_XGXS_ACQ_SM_STATUS1r_DSC_STATE_ACQ_1f_GET(r) ((((r).acq_sm_status1[0]) >> 7) & 0x1)
#define BCMI_TSC_XGXS_ACQ_SM_STATUS1r_DSC_STATE_ACQ_1f_SET(r,f) (r).acq_sm_status1[0]=(((r).acq_sm_status1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCMI_TSC_XGXS_ACQ_SM_STATUS1r_DSC_STATE_ACQ_CDRf_GET(r) ((((r).acq_sm_status1[0]) >> 6) & 0x1)
#define BCMI_TSC_XGXS_ACQ_SM_STATUS1r_DSC_STATE_ACQ_CDRf_SET(r,f) (r).acq_sm_status1[0]=(((r).acq_sm_status1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCMI_TSC_XGXS_ACQ_SM_STATUS1r_DSC_STATE_ACQ_CDRBR_PHASEf_GET(r) ((((r).acq_sm_status1[0]) >> 5) & 0x1)
#define BCMI_TSC_XGXS_ACQ_SM_STATUS1r_DSC_STATE_ACQ_CDRBR_PHASEf_SET(r,f) (r).acq_sm_status1[0]=(((r).acq_sm_status1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCMI_TSC_XGXS_ACQ_SM_STATUS1r_DSC_STATE_OS_INTEG_XFERf_GET(r) ((((r).acq_sm_status1[0]) >> 4) & 0x1)
#define BCMI_TSC_XGXS_ACQ_SM_STATUS1r_DSC_STATE_OS_INTEG_XFERf_SET(r,f) (r).acq_sm_status1[0]=(((r).acq_sm_status1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCMI_TSC_XGXS_ACQ_SM_STATUS1r_DSC_STATE_ACQ_VGAf_GET(r) ((((r).acq_sm_status1[0]) >> 3) & 0x1)
#define BCMI_TSC_XGXS_ACQ_SM_STATUS1r_DSC_STATE_ACQ_VGAf_SET(r,f) (r).acq_sm_status1[0]=(((r).acq_sm_status1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCMI_TSC_XGXS_ACQ_SM_STATUS1r_DSC_STATE_SETUPf_GET(r) ((((r).acq_sm_status1[0]) >> 2) & 0x1)
#define BCMI_TSC_XGXS_ACQ_SM_STATUS1r_DSC_STATE_SETUPf_SET(r,f) (r).acq_sm_status1[0]=(((r).acq_sm_status1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCMI_TSC_XGXS_ACQ_SM_STATUS1r_DSC_STATE_PAUSEf_GET(r) ((((r).acq_sm_status1[0]) >> 1) & 0x1)
#define BCMI_TSC_XGXS_ACQ_SM_STATUS1r_DSC_STATE_PAUSEf_SET(r,f) (r).acq_sm_status1[0]=(((r).acq_sm_status1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCMI_TSC_XGXS_ACQ_SM_STATUS1r_DSC_STATE_INITf_GET(r) (((r).acq_sm_status1[0]) & 0x1)
#define BCMI_TSC_XGXS_ACQ_SM_STATUS1r_DSC_STATE_INITf_SET(r,f) (r).acq_sm_status1[0]=(((r).acq_sm_status1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access ACQ_SM_STATUS1.
 *
 */
#define BCMI_TSC_XGXS_READ_ACQ_SM_STATUS1r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_ACQ_SM_STATUS1r,(_r._acq_sm_status1))
#define BCMI_TSC_XGXS_WRITE_ACQ_SM_STATUS1r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_ACQ_SM_STATUS1r,(_r._acq_sm_status1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define ACQ_SM_STATUS1r BCMI_TSC_XGXS_ACQ_SM_STATUS1r
#define ACQ_SM_STATUS1r_SIZE BCMI_TSC_XGXS_ACQ_SM_STATUS1r_SIZE
typedef BCMI_TSC_XGXS_ACQ_SM_STATUS1r_t ACQ_SM_STATUS1r_t;
#define ACQ_SM_STATUS1r_CLR BCMI_TSC_XGXS_ACQ_SM_STATUS1r_CLR
#define ACQ_SM_STATUS1r_SET BCMI_TSC_XGXS_ACQ_SM_STATUS1r_SET
#define ACQ_SM_STATUS1r_GET BCMI_TSC_XGXS_ACQ_SM_STATUS1r_GET
#define ACQ_SM_STATUS1r_DSC_STATE_EEE_ACQ_CDR_PHASEf_GET BCMI_TSC_XGXS_ACQ_SM_STATUS1r_DSC_STATE_EEE_ACQ_CDR_PHASEf_GET
#define ACQ_SM_STATUS1r_DSC_STATE_EEE_ACQ_CDR_PHASEf_SET BCMI_TSC_XGXS_ACQ_SM_STATUS1r_DSC_STATE_EEE_ACQ_CDR_PHASEf_SET
#define ACQ_SM_STATUS1r_DSC_STATE_EEE_QUIETf_GET BCMI_TSC_XGXS_ACQ_SM_STATUS1r_DSC_STATE_EEE_QUIETf_GET
#define ACQ_SM_STATUS1r_DSC_STATE_EEE_QUIETf_SET BCMI_TSC_XGXS_ACQ_SM_STATUS1r_DSC_STATE_EEE_QUIETf_SET
#define ACQ_SM_STATUS1r_DSC_STATE_DONEf_GET BCMI_TSC_XGXS_ACQ_SM_STATUS1r_DSC_STATE_DONEf_GET
#define ACQ_SM_STATUS1r_DSC_STATE_DONEf_SET BCMI_TSC_XGXS_ACQ_SM_STATUS1r_DSC_STATE_DONEf_SET
#define ACQ_SM_STATUS1r_DSC_STATE_MEASUREf_GET BCMI_TSC_XGXS_ACQ_SM_STATUS1r_DSC_STATE_MEASUREf_GET
#define ACQ_SM_STATUS1r_DSC_STATE_MEASUREf_SET BCMI_TSC_XGXS_ACQ_SM_STATUS1r_DSC_STATE_MEASUREf_SET
#define ACQ_SM_STATUS1r_DSC_STATE_TRAIN_2f_GET BCMI_TSC_XGXS_ACQ_SM_STATUS1r_DSC_STATE_TRAIN_2f_GET
#define ACQ_SM_STATUS1r_DSC_STATE_TRAIN_2f_SET BCMI_TSC_XGXS_ACQ_SM_STATUS1r_DSC_STATE_TRAIN_2f_SET
#define ACQ_SM_STATUS1r_DSC_STATE_TRAIN_1f_GET BCMI_TSC_XGXS_ACQ_SM_STATUS1r_DSC_STATE_TRAIN_1f_GET
#define ACQ_SM_STATUS1r_DSC_STATE_TRAIN_1f_SET BCMI_TSC_XGXS_ACQ_SM_STATUS1r_DSC_STATE_TRAIN_1f_SET
#define ACQ_SM_STATUS1r_DSC_STATE_SOFT_ACKf_GET BCMI_TSC_XGXS_ACQ_SM_STATUS1r_DSC_STATE_SOFT_ACKf_GET
#define ACQ_SM_STATUS1r_DSC_STATE_SOFT_ACKf_SET BCMI_TSC_XGXS_ACQ_SM_STATUS1r_DSC_STATE_SOFT_ACKf_SET
#define ACQ_SM_STATUS1r_DSC_STATE_ACQ_2f_GET BCMI_TSC_XGXS_ACQ_SM_STATUS1r_DSC_STATE_ACQ_2f_GET
#define ACQ_SM_STATUS1r_DSC_STATE_ACQ_2f_SET BCMI_TSC_XGXS_ACQ_SM_STATUS1r_DSC_STATE_ACQ_2f_SET
#define ACQ_SM_STATUS1r_DSC_STATE_ACQ_1f_GET BCMI_TSC_XGXS_ACQ_SM_STATUS1r_DSC_STATE_ACQ_1f_GET
#define ACQ_SM_STATUS1r_DSC_STATE_ACQ_1f_SET BCMI_TSC_XGXS_ACQ_SM_STATUS1r_DSC_STATE_ACQ_1f_SET
#define ACQ_SM_STATUS1r_DSC_STATE_ACQ_CDRf_GET BCMI_TSC_XGXS_ACQ_SM_STATUS1r_DSC_STATE_ACQ_CDRf_GET
#define ACQ_SM_STATUS1r_DSC_STATE_ACQ_CDRf_SET BCMI_TSC_XGXS_ACQ_SM_STATUS1r_DSC_STATE_ACQ_CDRf_SET
#define ACQ_SM_STATUS1r_DSC_STATE_ACQ_CDRBR_PHASEf_GET BCMI_TSC_XGXS_ACQ_SM_STATUS1r_DSC_STATE_ACQ_CDRBR_PHASEf_GET
#define ACQ_SM_STATUS1r_DSC_STATE_ACQ_CDRBR_PHASEf_SET BCMI_TSC_XGXS_ACQ_SM_STATUS1r_DSC_STATE_ACQ_CDRBR_PHASEf_SET
#define ACQ_SM_STATUS1r_DSC_STATE_OS_INTEG_XFERf_GET BCMI_TSC_XGXS_ACQ_SM_STATUS1r_DSC_STATE_OS_INTEG_XFERf_GET
#define ACQ_SM_STATUS1r_DSC_STATE_OS_INTEG_XFERf_SET BCMI_TSC_XGXS_ACQ_SM_STATUS1r_DSC_STATE_OS_INTEG_XFERf_SET
#define ACQ_SM_STATUS1r_DSC_STATE_ACQ_VGAf_GET BCMI_TSC_XGXS_ACQ_SM_STATUS1r_DSC_STATE_ACQ_VGAf_GET
#define ACQ_SM_STATUS1r_DSC_STATE_ACQ_VGAf_SET BCMI_TSC_XGXS_ACQ_SM_STATUS1r_DSC_STATE_ACQ_VGAf_SET
#define ACQ_SM_STATUS1r_DSC_STATE_SETUPf_GET BCMI_TSC_XGXS_ACQ_SM_STATUS1r_DSC_STATE_SETUPf_GET
#define ACQ_SM_STATUS1r_DSC_STATE_SETUPf_SET BCMI_TSC_XGXS_ACQ_SM_STATUS1r_DSC_STATE_SETUPf_SET
#define ACQ_SM_STATUS1r_DSC_STATE_PAUSEf_GET BCMI_TSC_XGXS_ACQ_SM_STATUS1r_DSC_STATE_PAUSEf_GET
#define ACQ_SM_STATUS1r_DSC_STATE_PAUSEf_SET BCMI_TSC_XGXS_ACQ_SM_STATUS1r_DSC_STATE_PAUSEf_SET
#define ACQ_SM_STATUS1r_DSC_STATE_INITf_GET BCMI_TSC_XGXS_ACQ_SM_STATUS1r_DSC_STATE_INITf_GET
#define ACQ_SM_STATUS1r_DSC_STATE_INITf_SET BCMI_TSC_XGXS_ACQ_SM_STATUS1r_DSC_STATE_INITf_SET
#define READ_ACQ_SM_STATUS1r BCMI_TSC_XGXS_READ_ACQ_SM_STATUS1r
#define WRITE_ACQ_SM_STATUS1r BCMI_TSC_XGXS_WRITE_ACQ_SM_STATUS1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_ACQ_SM_STATUS1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  ANA_STATUS0
 * BLOCKS:   DSC3B0
 * REGADDR:  0xc22b
 * DESC:     DSC Analog Status 0 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     PF_CTRL_BIN      
 *     OFFSET_PD        
 *     EN_HGAIN         
 *     EN_DFE_CLK       
 *     PD_CH_P1         
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_ANA_STATUS0r (0x0000c22b | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_ANA_STATUS0r_SIZE 4

/*
 * This structure should be used to declare and program ANA_STATUS0.
 *
 */
typedef union BCMI_TSC_XGXS_ANA_STATUS0r_s {
	uint32_t v[1];
	uint32_t ana_status0[1];
	uint32_t _ana_status0;
} BCMI_TSC_XGXS_ANA_STATUS0r_t;

#define BCMI_TSC_XGXS_ANA_STATUS0r_CLR(r) (r).ana_status0[0] = 0
#define BCMI_TSC_XGXS_ANA_STATUS0r_SET(r,d) (r).ana_status0[0] = d
#define BCMI_TSC_XGXS_ANA_STATUS0r_GET(r) (r).ana_status0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_ANA_STATUS0r_RESERVED0f_GET(r) ((((r).ana_status0[0]) >> 8) & 0xff)
#define BCMI_TSC_XGXS_ANA_STATUS0r_RESERVED0f_SET(r,f) (r).ana_status0[0]=(((r).ana_status0[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCMI_TSC_XGXS_ANA_STATUS0r_PD_CH_P1f_GET(r) ((((r).ana_status0[0]) >> 7) & 0x1)
#define BCMI_TSC_XGXS_ANA_STATUS0r_PD_CH_P1f_SET(r,f) (r).ana_status0[0]=(((r).ana_status0[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCMI_TSC_XGXS_ANA_STATUS0r_EN_DFE_CLKf_GET(r) ((((r).ana_status0[0]) >> 6) & 0x1)
#define BCMI_TSC_XGXS_ANA_STATUS0r_EN_DFE_CLKf_SET(r,f) (r).ana_status0[0]=(((r).ana_status0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCMI_TSC_XGXS_ANA_STATUS0r_EN_HGAINf_GET(r) ((((r).ana_status0[0]) >> 5) & 0x1)
#define BCMI_TSC_XGXS_ANA_STATUS0r_EN_HGAINf_SET(r,f) (r).ana_status0[0]=(((r).ana_status0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCMI_TSC_XGXS_ANA_STATUS0r_OFFSET_PDf_GET(r) ((((r).ana_status0[0]) >> 4) & 0x1)
#define BCMI_TSC_XGXS_ANA_STATUS0r_OFFSET_PDf_SET(r,f) (r).ana_status0[0]=(((r).ana_status0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCMI_TSC_XGXS_ANA_STATUS0r_PF_CTRL_BINf_GET(r) (((r).ana_status0[0]) & 0xf)
#define BCMI_TSC_XGXS_ANA_STATUS0r_PF_CTRL_BINf_SET(r,f) (r).ana_status0[0]=(((r).ana_status0[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access ANA_STATUS0.
 *
 */
#define BCMI_TSC_XGXS_READ_ANA_STATUS0r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_ANA_STATUS0r,(_r._ana_status0))
#define BCMI_TSC_XGXS_WRITE_ANA_STATUS0r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_ANA_STATUS0r,(_r._ana_status0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define ANA_STATUS0r BCMI_TSC_XGXS_ANA_STATUS0r
#define ANA_STATUS0r_SIZE BCMI_TSC_XGXS_ANA_STATUS0r_SIZE
typedef BCMI_TSC_XGXS_ANA_STATUS0r_t ANA_STATUS0r_t;
#define ANA_STATUS0r_CLR BCMI_TSC_XGXS_ANA_STATUS0r_CLR
#define ANA_STATUS0r_SET BCMI_TSC_XGXS_ANA_STATUS0r_SET
#define ANA_STATUS0r_GET BCMI_TSC_XGXS_ANA_STATUS0r_GET
#define ANA_STATUS0r_RESERVED0f_GET BCMI_TSC_XGXS_ANA_STATUS0r_RESERVED0f_GET
#define ANA_STATUS0r_RESERVED0f_SET BCMI_TSC_XGXS_ANA_STATUS0r_RESERVED0f_SET
#define ANA_STATUS0r_PD_CH_P1f_GET BCMI_TSC_XGXS_ANA_STATUS0r_PD_CH_P1f_GET
#define ANA_STATUS0r_PD_CH_P1f_SET BCMI_TSC_XGXS_ANA_STATUS0r_PD_CH_P1f_SET
#define ANA_STATUS0r_EN_DFE_CLKf_GET BCMI_TSC_XGXS_ANA_STATUS0r_EN_DFE_CLKf_GET
#define ANA_STATUS0r_EN_DFE_CLKf_SET BCMI_TSC_XGXS_ANA_STATUS0r_EN_DFE_CLKf_SET
#define ANA_STATUS0r_EN_HGAINf_GET BCMI_TSC_XGXS_ANA_STATUS0r_EN_HGAINf_GET
#define ANA_STATUS0r_EN_HGAINf_SET BCMI_TSC_XGXS_ANA_STATUS0r_EN_HGAINf_SET
#define ANA_STATUS0r_OFFSET_PDf_GET BCMI_TSC_XGXS_ANA_STATUS0r_OFFSET_PDf_GET
#define ANA_STATUS0r_OFFSET_PDf_SET BCMI_TSC_XGXS_ANA_STATUS0r_OFFSET_PDf_SET
#define ANA_STATUS0r_PF_CTRL_BINf_GET BCMI_TSC_XGXS_ANA_STATUS0r_PF_CTRL_BINf_GET
#define ANA_STATUS0r_PF_CTRL_BINf_SET BCMI_TSC_XGXS_ANA_STATUS0r_PF_CTRL_BINf_SET
#define READ_ANA_STATUS0r BCMI_TSC_XGXS_READ_ANA_STATUS0r
#define WRITE_ANA_STATUS0r BCMI_TSC_XGXS_WRITE_ANA_STATUS0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_ANA_STATUS0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  ANA_STATUS1
 * BLOCKS:   DSC3B0
 * REGADDR:  0xc22c
 * DESC:     DSC Analog Status 1 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     SLICER_OFFSET_PE 
 *     SLICER_OFFSET_PO 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_ANA_STATUS1r (0x0000c22c | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_ANA_STATUS1r_SIZE 4

/*
 * This structure should be used to declare and program ANA_STATUS1.
 *
 */
typedef union BCMI_TSC_XGXS_ANA_STATUS1r_s {
	uint32_t v[1];
	uint32_t ana_status1[1];
	uint32_t _ana_status1;
} BCMI_TSC_XGXS_ANA_STATUS1r_t;

#define BCMI_TSC_XGXS_ANA_STATUS1r_CLR(r) (r).ana_status1[0] = 0
#define BCMI_TSC_XGXS_ANA_STATUS1r_SET(r,d) (r).ana_status1[0] = d
#define BCMI_TSC_XGXS_ANA_STATUS1r_GET(r) (r).ana_status1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_ANA_STATUS1r_RESERVED0f_GET(r) ((((r).ana_status1[0]) >> 12) & 0xf)
#define BCMI_TSC_XGXS_ANA_STATUS1r_RESERVED0f_SET(r,f) (r).ana_status1[0]=(((r).ana_status1[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCMI_TSC_XGXS_ANA_STATUS1r_SLICER_OFFSET_POf_GET(r) ((((r).ana_status1[0]) >> 6) & 0x3f)
#define BCMI_TSC_XGXS_ANA_STATUS1r_SLICER_OFFSET_POf_SET(r,f) (r).ana_status1[0]=(((r).ana_status1[0] & ~((uint32_t)0x3f << 6)) | ((((uint32_t)f) & 0x3f) << 6))
#define BCMI_TSC_XGXS_ANA_STATUS1r_SLICER_OFFSET_PEf_GET(r) (((r).ana_status1[0]) & 0x3f)
#define BCMI_TSC_XGXS_ANA_STATUS1r_SLICER_OFFSET_PEf_SET(r,f) (r).ana_status1[0]=(((r).ana_status1[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))

/*
 * These macros can be used to access ANA_STATUS1.
 *
 */
#define BCMI_TSC_XGXS_READ_ANA_STATUS1r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_ANA_STATUS1r,(_r._ana_status1))
#define BCMI_TSC_XGXS_WRITE_ANA_STATUS1r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_ANA_STATUS1r,(_r._ana_status1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define ANA_STATUS1r BCMI_TSC_XGXS_ANA_STATUS1r
#define ANA_STATUS1r_SIZE BCMI_TSC_XGXS_ANA_STATUS1r_SIZE
typedef BCMI_TSC_XGXS_ANA_STATUS1r_t ANA_STATUS1r_t;
#define ANA_STATUS1r_CLR BCMI_TSC_XGXS_ANA_STATUS1r_CLR
#define ANA_STATUS1r_SET BCMI_TSC_XGXS_ANA_STATUS1r_SET
#define ANA_STATUS1r_GET BCMI_TSC_XGXS_ANA_STATUS1r_GET
#define ANA_STATUS1r_RESERVED0f_GET BCMI_TSC_XGXS_ANA_STATUS1r_RESERVED0f_GET
#define ANA_STATUS1r_RESERVED0f_SET BCMI_TSC_XGXS_ANA_STATUS1r_RESERVED0f_SET
#define ANA_STATUS1r_SLICER_OFFSET_POf_GET BCMI_TSC_XGXS_ANA_STATUS1r_SLICER_OFFSET_POf_GET
#define ANA_STATUS1r_SLICER_OFFSET_POf_SET BCMI_TSC_XGXS_ANA_STATUS1r_SLICER_OFFSET_POf_SET
#define ANA_STATUS1r_SLICER_OFFSET_PEf_GET BCMI_TSC_XGXS_ANA_STATUS1r_SLICER_OFFSET_PEf_GET
#define ANA_STATUS1r_SLICER_OFFSET_PEf_SET BCMI_TSC_XGXS_ANA_STATUS1r_SLICER_OFFSET_PEf_SET
#define READ_ANA_STATUS1r BCMI_TSC_XGXS_READ_ANA_STATUS1r
#define WRITE_ANA_STATUS1r BCMI_TSC_XGXS_WRITE_ANA_STATUS1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_ANA_STATUS1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  ANA_STATUS2
 * BLOCKS:   DSC3B0
 * REGADDR:  0xc22d
 * DESC:     DSC Analog Status 2 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     SLICER_OFFSET_ZE 
 *     SLICER_OFFSET_ZO 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_ANA_STATUS2r (0x0000c22d | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_ANA_STATUS2r_SIZE 4

/*
 * This structure should be used to declare and program ANA_STATUS2.
 *
 */
typedef union BCMI_TSC_XGXS_ANA_STATUS2r_s {
	uint32_t v[1];
	uint32_t ana_status2[1];
	uint32_t _ana_status2;
} BCMI_TSC_XGXS_ANA_STATUS2r_t;

#define BCMI_TSC_XGXS_ANA_STATUS2r_CLR(r) (r).ana_status2[0] = 0
#define BCMI_TSC_XGXS_ANA_STATUS2r_SET(r,d) (r).ana_status2[0] = d
#define BCMI_TSC_XGXS_ANA_STATUS2r_GET(r) (r).ana_status2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_ANA_STATUS2r_RESERVED0f_GET(r) ((((r).ana_status2[0]) >> 12) & 0xf)
#define BCMI_TSC_XGXS_ANA_STATUS2r_RESERVED0f_SET(r,f) (r).ana_status2[0]=(((r).ana_status2[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCMI_TSC_XGXS_ANA_STATUS2r_SLICER_OFFSET_ZOf_GET(r) ((((r).ana_status2[0]) >> 6) & 0x3f)
#define BCMI_TSC_XGXS_ANA_STATUS2r_SLICER_OFFSET_ZOf_SET(r,f) (r).ana_status2[0]=(((r).ana_status2[0] & ~((uint32_t)0x3f << 6)) | ((((uint32_t)f) & 0x3f) << 6))
#define BCMI_TSC_XGXS_ANA_STATUS2r_SLICER_OFFSET_ZEf_GET(r) (((r).ana_status2[0]) & 0x3f)
#define BCMI_TSC_XGXS_ANA_STATUS2r_SLICER_OFFSET_ZEf_SET(r,f) (r).ana_status2[0]=(((r).ana_status2[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))

/*
 * These macros can be used to access ANA_STATUS2.
 *
 */
#define BCMI_TSC_XGXS_READ_ANA_STATUS2r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_ANA_STATUS2r,(_r._ana_status2))
#define BCMI_TSC_XGXS_WRITE_ANA_STATUS2r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_ANA_STATUS2r,(_r._ana_status2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define ANA_STATUS2r BCMI_TSC_XGXS_ANA_STATUS2r
#define ANA_STATUS2r_SIZE BCMI_TSC_XGXS_ANA_STATUS2r_SIZE
typedef BCMI_TSC_XGXS_ANA_STATUS2r_t ANA_STATUS2r_t;
#define ANA_STATUS2r_CLR BCMI_TSC_XGXS_ANA_STATUS2r_CLR
#define ANA_STATUS2r_SET BCMI_TSC_XGXS_ANA_STATUS2r_SET
#define ANA_STATUS2r_GET BCMI_TSC_XGXS_ANA_STATUS2r_GET
#define ANA_STATUS2r_RESERVED0f_GET BCMI_TSC_XGXS_ANA_STATUS2r_RESERVED0f_GET
#define ANA_STATUS2r_RESERVED0f_SET BCMI_TSC_XGXS_ANA_STATUS2r_RESERVED0f_SET
#define ANA_STATUS2r_SLICER_OFFSET_ZOf_GET BCMI_TSC_XGXS_ANA_STATUS2r_SLICER_OFFSET_ZOf_GET
#define ANA_STATUS2r_SLICER_OFFSET_ZOf_SET BCMI_TSC_XGXS_ANA_STATUS2r_SLICER_OFFSET_ZOf_SET
#define ANA_STATUS2r_SLICER_OFFSET_ZEf_GET BCMI_TSC_XGXS_ANA_STATUS2r_SLICER_OFFSET_ZEf_GET
#define ANA_STATUS2r_SLICER_OFFSET_ZEf_SET BCMI_TSC_XGXS_ANA_STATUS2r_SLICER_OFFSET_ZEf_SET
#define READ_ANA_STATUS2r BCMI_TSC_XGXS_READ_ANA_STATUS2r
#define WRITE_ANA_STATUS2r BCMI_TSC_XGXS_WRITE_ANA_STATUS2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_ANA_STATUS2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  ANA_STATUS3
 * BLOCKS:   DSC3B0
 * REGADDR:  0xc22e
 * DESC:     DSC Analog Status 3 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     SLICER_OFFSET_ME 
 *     SLICER_OFFSET_MO 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_ANA_STATUS3r (0x0000c22e | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_ANA_STATUS3r_SIZE 4

/*
 * This structure should be used to declare and program ANA_STATUS3.
 *
 */
typedef union BCMI_TSC_XGXS_ANA_STATUS3r_s {
	uint32_t v[1];
	uint32_t ana_status3[1];
	uint32_t _ana_status3;
} BCMI_TSC_XGXS_ANA_STATUS3r_t;

#define BCMI_TSC_XGXS_ANA_STATUS3r_CLR(r) (r).ana_status3[0] = 0
#define BCMI_TSC_XGXS_ANA_STATUS3r_SET(r,d) (r).ana_status3[0] = d
#define BCMI_TSC_XGXS_ANA_STATUS3r_GET(r) (r).ana_status3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_ANA_STATUS3r_RESERVED0f_GET(r) ((((r).ana_status3[0]) >> 12) & 0xf)
#define BCMI_TSC_XGXS_ANA_STATUS3r_RESERVED0f_SET(r,f) (r).ana_status3[0]=(((r).ana_status3[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCMI_TSC_XGXS_ANA_STATUS3r_SLICER_OFFSET_MOf_GET(r) ((((r).ana_status3[0]) >> 6) & 0x3f)
#define BCMI_TSC_XGXS_ANA_STATUS3r_SLICER_OFFSET_MOf_SET(r,f) (r).ana_status3[0]=(((r).ana_status3[0] & ~((uint32_t)0x3f << 6)) | ((((uint32_t)f) & 0x3f) << 6))
#define BCMI_TSC_XGXS_ANA_STATUS3r_SLICER_OFFSET_MEf_GET(r) (((r).ana_status3[0]) & 0x3f)
#define BCMI_TSC_XGXS_ANA_STATUS3r_SLICER_OFFSET_MEf_SET(r,f) (r).ana_status3[0]=(((r).ana_status3[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))

/*
 * These macros can be used to access ANA_STATUS3.
 *
 */
#define BCMI_TSC_XGXS_READ_ANA_STATUS3r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_ANA_STATUS3r,(_r._ana_status3))
#define BCMI_TSC_XGXS_WRITE_ANA_STATUS3r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_ANA_STATUS3r,(_r._ana_status3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define ANA_STATUS3r BCMI_TSC_XGXS_ANA_STATUS3r
#define ANA_STATUS3r_SIZE BCMI_TSC_XGXS_ANA_STATUS3r_SIZE
typedef BCMI_TSC_XGXS_ANA_STATUS3r_t ANA_STATUS3r_t;
#define ANA_STATUS3r_CLR BCMI_TSC_XGXS_ANA_STATUS3r_CLR
#define ANA_STATUS3r_SET BCMI_TSC_XGXS_ANA_STATUS3r_SET
#define ANA_STATUS3r_GET BCMI_TSC_XGXS_ANA_STATUS3r_GET
#define ANA_STATUS3r_RESERVED0f_GET BCMI_TSC_XGXS_ANA_STATUS3r_RESERVED0f_GET
#define ANA_STATUS3r_RESERVED0f_SET BCMI_TSC_XGXS_ANA_STATUS3r_RESERVED0f_SET
#define ANA_STATUS3r_SLICER_OFFSET_MOf_GET BCMI_TSC_XGXS_ANA_STATUS3r_SLICER_OFFSET_MOf_GET
#define ANA_STATUS3r_SLICER_OFFSET_MOf_SET BCMI_TSC_XGXS_ANA_STATUS3r_SLICER_OFFSET_MOf_SET
#define ANA_STATUS3r_SLICER_OFFSET_MEf_GET BCMI_TSC_XGXS_ANA_STATUS3r_SLICER_OFFSET_MEf_GET
#define ANA_STATUS3r_SLICER_OFFSET_MEf_SET BCMI_TSC_XGXS_ANA_STATUS3r_SLICER_OFFSET_MEf_SET
#define READ_ANA_STATUS3r BCMI_TSC_XGXS_READ_ANA_STATUS3r
#define WRITE_ANA_STATUS3r BCMI_TSC_XGXS_WRITE_ANA_STATUS3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_ANA_STATUS3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  TUNING_SM_CTRL0
 * BLOCKS:   DSC4B0
 * REGADDR:  0xc230
 * DESC:     State Machine Control 0 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     TUNING_SM_EN     
 *     RESTART_TUNING   
 *     BYPASS_OS_DATA_SLICER_CAL 
 *     BYPASS_BR_DATA_SLICER_CAL 
 *     BYPASS_PHASE_SLICER_CAL 
 *     BYPASS_OSX45_SLICER_CAL 
 *     BYPASS_DATA_SLICER_RECAL 
 *     BYPASS_OSX1_PF_CAL 
 *     BYPASS_OSX2_PF_CAL 
 *     BYPASS_BR_PF_CAL 
 *     SLICER_CAL_LINEAR_SRCH 
 *     HYSTERESIS_EN    
 *     POSTC_METRIC_CTRL 
 *     BYPASS_BR_VGA    
 *     BYPASS_TX_POSTC_CAL 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_TUNING_SM_CTRL0r (0x0000c230 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_TUNING_SM_CTRL0r_SIZE 4

/*
 * This structure should be used to declare and program TUNING_SM_CTRL0.
 *
 */
typedef union BCMI_TSC_XGXS_TUNING_SM_CTRL0r_s {
	uint32_t v[1];
	uint32_t tuning_sm_ctrl0[1];
	uint32_t _tuning_sm_ctrl0;
} BCMI_TSC_XGXS_TUNING_SM_CTRL0r_t;

#define BCMI_TSC_XGXS_TUNING_SM_CTRL0r_CLR(r) (r).tuning_sm_ctrl0[0] = 0
#define BCMI_TSC_XGXS_TUNING_SM_CTRL0r_SET(r,d) (r).tuning_sm_ctrl0[0] = d
#define BCMI_TSC_XGXS_TUNING_SM_CTRL0r_GET(r) (r).tuning_sm_ctrl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_TUNING_SM_CTRL0r_RESERVED0f_GET(r) ((((r).tuning_sm_ctrl0[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_TUNING_SM_CTRL0r_RESERVED0f_SET(r,f) (r).tuning_sm_ctrl0[0]=(((r).tuning_sm_ctrl0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_TUNING_SM_CTRL0r_BYPASS_TX_POSTC_CALf_GET(r) ((((r).tuning_sm_ctrl0[0]) >> 14) & 0x1)
#define BCMI_TSC_XGXS_TUNING_SM_CTRL0r_BYPASS_TX_POSTC_CALf_SET(r,f) (r).tuning_sm_ctrl0[0]=(((r).tuning_sm_ctrl0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCMI_TSC_XGXS_TUNING_SM_CTRL0r_BYPASS_BR_VGAf_GET(r) ((((r).tuning_sm_ctrl0[0]) >> 13) & 0x1)
#define BCMI_TSC_XGXS_TUNING_SM_CTRL0r_BYPASS_BR_VGAf_SET(r,f) (r).tuning_sm_ctrl0[0]=(((r).tuning_sm_ctrl0[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCMI_TSC_XGXS_TUNING_SM_CTRL0r_POSTC_METRIC_CTRLf_GET(r) ((((r).tuning_sm_ctrl0[0]) >> 12) & 0x1)
#define BCMI_TSC_XGXS_TUNING_SM_CTRL0r_POSTC_METRIC_CTRLf_SET(r,f) (r).tuning_sm_ctrl0[0]=(((r).tuning_sm_ctrl0[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCMI_TSC_XGXS_TUNING_SM_CTRL0r_HYSTERESIS_ENf_GET(r) ((((r).tuning_sm_ctrl0[0]) >> 11) & 0x1)
#define BCMI_TSC_XGXS_TUNING_SM_CTRL0r_HYSTERESIS_ENf_SET(r,f) (r).tuning_sm_ctrl0[0]=(((r).tuning_sm_ctrl0[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCMI_TSC_XGXS_TUNING_SM_CTRL0r_SLICER_CAL_LINEAR_SRCHf_GET(r) ((((r).tuning_sm_ctrl0[0]) >> 10) & 0x1)
#define BCMI_TSC_XGXS_TUNING_SM_CTRL0r_SLICER_CAL_LINEAR_SRCHf_SET(r,f) (r).tuning_sm_ctrl0[0]=(((r).tuning_sm_ctrl0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCMI_TSC_XGXS_TUNING_SM_CTRL0r_BYPASS_BR_PF_CALf_GET(r) ((((r).tuning_sm_ctrl0[0]) >> 9) & 0x1)
#define BCMI_TSC_XGXS_TUNING_SM_CTRL0r_BYPASS_BR_PF_CALf_SET(r,f) (r).tuning_sm_ctrl0[0]=(((r).tuning_sm_ctrl0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCMI_TSC_XGXS_TUNING_SM_CTRL0r_BYPASS_OSX2_PF_CALf_GET(r) ((((r).tuning_sm_ctrl0[0]) >> 8) & 0x1)
#define BCMI_TSC_XGXS_TUNING_SM_CTRL0r_BYPASS_OSX2_PF_CALf_SET(r,f) (r).tuning_sm_ctrl0[0]=(((r).tuning_sm_ctrl0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCMI_TSC_XGXS_TUNING_SM_CTRL0r_BYPASS_OSX1_PF_CALf_GET(r) ((((r).tuning_sm_ctrl0[0]) >> 7) & 0x1)
#define BCMI_TSC_XGXS_TUNING_SM_CTRL0r_BYPASS_OSX1_PF_CALf_SET(r,f) (r).tuning_sm_ctrl0[0]=(((r).tuning_sm_ctrl0[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCMI_TSC_XGXS_TUNING_SM_CTRL0r_BYPASS_DATA_SLICER_RECALf_GET(r) ((((r).tuning_sm_ctrl0[0]) >> 6) & 0x1)
#define BCMI_TSC_XGXS_TUNING_SM_CTRL0r_BYPASS_DATA_SLICER_RECALf_SET(r,f) (r).tuning_sm_ctrl0[0]=(((r).tuning_sm_ctrl0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCMI_TSC_XGXS_TUNING_SM_CTRL0r_BYPASS_OSX45_SLICER_CALf_GET(r) ((((r).tuning_sm_ctrl0[0]) >> 5) & 0x1)
#define BCMI_TSC_XGXS_TUNING_SM_CTRL0r_BYPASS_OSX45_SLICER_CALf_SET(r,f) (r).tuning_sm_ctrl0[0]=(((r).tuning_sm_ctrl0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCMI_TSC_XGXS_TUNING_SM_CTRL0r_BYPASS_PHASE_SLICER_CALf_GET(r) ((((r).tuning_sm_ctrl0[0]) >> 4) & 0x1)
#define BCMI_TSC_XGXS_TUNING_SM_CTRL0r_BYPASS_PHASE_SLICER_CALf_SET(r,f) (r).tuning_sm_ctrl0[0]=(((r).tuning_sm_ctrl0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCMI_TSC_XGXS_TUNING_SM_CTRL0r_BYPASS_BR_DATA_SLICER_CALf_GET(r) ((((r).tuning_sm_ctrl0[0]) >> 3) & 0x1)
#define BCMI_TSC_XGXS_TUNING_SM_CTRL0r_BYPASS_BR_DATA_SLICER_CALf_SET(r,f) (r).tuning_sm_ctrl0[0]=(((r).tuning_sm_ctrl0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCMI_TSC_XGXS_TUNING_SM_CTRL0r_BYPASS_OS_DATA_SLICER_CALf_GET(r) ((((r).tuning_sm_ctrl0[0]) >> 2) & 0x1)
#define BCMI_TSC_XGXS_TUNING_SM_CTRL0r_BYPASS_OS_DATA_SLICER_CALf_SET(r,f) (r).tuning_sm_ctrl0[0]=(((r).tuning_sm_ctrl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCMI_TSC_XGXS_TUNING_SM_CTRL0r_RESTART_TUNINGf_GET(r) ((((r).tuning_sm_ctrl0[0]) >> 1) & 0x1)
#define BCMI_TSC_XGXS_TUNING_SM_CTRL0r_RESTART_TUNINGf_SET(r,f) (r).tuning_sm_ctrl0[0]=(((r).tuning_sm_ctrl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCMI_TSC_XGXS_TUNING_SM_CTRL0r_TUNING_SM_ENf_GET(r) (((r).tuning_sm_ctrl0[0]) & 0x1)
#define BCMI_TSC_XGXS_TUNING_SM_CTRL0r_TUNING_SM_ENf_SET(r,f) (r).tuning_sm_ctrl0[0]=(((r).tuning_sm_ctrl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access TUNING_SM_CTRL0.
 *
 */
#define BCMI_TSC_XGXS_READ_TUNING_SM_CTRL0r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_TUNING_SM_CTRL0r,(_r._tuning_sm_ctrl0))
#define BCMI_TSC_XGXS_WRITE_TUNING_SM_CTRL0r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_TUNING_SM_CTRL0r,(_r._tuning_sm_ctrl0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TUNING_SM_CTRL0r BCMI_TSC_XGXS_TUNING_SM_CTRL0r
#define TUNING_SM_CTRL0r_SIZE BCMI_TSC_XGXS_TUNING_SM_CTRL0r_SIZE
typedef BCMI_TSC_XGXS_TUNING_SM_CTRL0r_t TUNING_SM_CTRL0r_t;
#define TUNING_SM_CTRL0r_CLR BCMI_TSC_XGXS_TUNING_SM_CTRL0r_CLR
#define TUNING_SM_CTRL0r_SET BCMI_TSC_XGXS_TUNING_SM_CTRL0r_SET
#define TUNING_SM_CTRL0r_GET BCMI_TSC_XGXS_TUNING_SM_CTRL0r_GET
#define TUNING_SM_CTRL0r_RESERVED0f_GET BCMI_TSC_XGXS_TUNING_SM_CTRL0r_RESERVED0f_GET
#define TUNING_SM_CTRL0r_RESERVED0f_SET BCMI_TSC_XGXS_TUNING_SM_CTRL0r_RESERVED0f_SET
#define TUNING_SM_CTRL0r_BYPASS_TX_POSTC_CALf_GET BCMI_TSC_XGXS_TUNING_SM_CTRL0r_BYPASS_TX_POSTC_CALf_GET
#define TUNING_SM_CTRL0r_BYPASS_TX_POSTC_CALf_SET BCMI_TSC_XGXS_TUNING_SM_CTRL0r_BYPASS_TX_POSTC_CALf_SET
#define TUNING_SM_CTRL0r_BYPASS_BR_VGAf_GET BCMI_TSC_XGXS_TUNING_SM_CTRL0r_BYPASS_BR_VGAf_GET
#define TUNING_SM_CTRL0r_BYPASS_BR_VGAf_SET BCMI_TSC_XGXS_TUNING_SM_CTRL0r_BYPASS_BR_VGAf_SET
#define TUNING_SM_CTRL0r_POSTC_METRIC_CTRLf_GET BCMI_TSC_XGXS_TUNING_SM_CTRL0r_POSTC_METRIC_CTRLf_GET
#define TUNING_SM_CTRL0r_POSTC_METRIC_CTRLf_SET BCMI_TSC_XGXS_TUNING_SM_CTRL0r_POSTC_METRIC_CTRLf_SET
#define TUNING_SM_CTRL0r_HYSTERESIS_ENf_GET BCMI_TSC_XGXS_TUNING_SM_CTRL0r_HYSTERESIS_ENf_GET
#define TUNING_SM_CTRL0r_HYSTERESIS_ENf_SET BCMI_TSC_XGXS_TUNING_SM_CTRL0r_HYSTERESIS_ENf_SET
#define TUNING_SM_CTRL0r_SLICER_CAL_LINEAR_SRCHf_GET BCMI_TSC_XGXS_TUNING_SM_CTRL0r_SLICER_CAL_LINEAR_SRCHf_GET
#define TUNING_SM_CTRL0r_SLICER_CAL_LINEAR_SRCHf_SET BCMI_TSC_XGXS_TUNING_SM_CTRL0r_SLICER_CAL_LINEAR_SRCHf_SET
#define TUNING_SM_CTRL0r_BYPASS_BR_PF_CALf_GET BCMI_TSC_XGXS_TUNING_SM_CTRL0r_BYPASS_BR_PF_CALf_GET
#define TUNING_SM_CTRL0r_BYPASS_BR_PF_CALf_SET BCMI_TSC_XGXS_TUNING_SM_CTRL0r_BYPASS_BR_PF_CALf_SET
#define TUNING_SM_CTRL0r_BYPASS_OSX2_PF_CALf_GET BCMI_TSC_XGXS_TUNING_SM_CTRL0r_BYPASS_OSX2_PF_CALf_GET
#define TUNING_SM_CTRL0r_BYPASS_OSX2_PF_CALf_SET BCMI_TSC_XGXS_TUNING_SM_CTRL0r_BYPASS_OSX2_PF_CALf_SET
#define TUNING_SM_CTRL0r_BYPASS_OSX1_PF_CALf_GET BCMI_TSC_XGXS_TUNING_SM_CTRL0r_BYPASS_OSX1_PF_CALf_GET
#define TUNING_SM_CTRL0r_BYPASS_OSX1_PF_CALf_SET BCMI_TSC_XGXS_TUNING_SM_CTRL0r_BYPASS_OSX1_PF_CALf_SET
#define TUNING_SM_CTRL0r_BYPASS_DATA_SLICER_RECALf_GET BCMI_TSC_XGXS_TUNING_SM_CTRL0r_BYPASS_DATA_SLICER_RECALf_GET
#define TUNING_SM_CTRL0r_BYPASS_DATA_SLICER_RECALf_SET BCMI_TSC_XGXS_TUNING_SM_CTRL0r_BYPASS_DATA_SLICER_RECALf_SET
#define TUNING_SM_CTRL0r_BYPASS_OSX45_SLICER_CALf_GET BCMI_TSC_XGXS_TUNING_SM_CTRL0r_BYPASS_OSX45_SLICER_CALf_GET
#define TUNING_SM_CTRL0r_BYPASS_OSX45_SLICER_CALf_SET BCMI_TSC_XGXS_TUNING_SM_CTRL0r_BYPASS_OSX45_SLICER_CALf_SET
#define TUNING_SM_CTRL0r_BYPASS_PHASE_SLICER_CALf_GET BCMI_TSC_XGXS_TUNING_SM_CTRL0r_BYPASS_PHASE_SLICER_CALf_GET
#define TUNING_SM_CTRL0r_BYPASS_PHASE_SLICER_CALf_SET BCMI_TSC_XGXS_TUNING_SM_CTRL0r_BYPASS_PHASE_SLICER_CALf_SET
#define TUNING_SM_CTRL0r_BYPASS_BR_DATA_SLICER_CALf_GET BCMI_TSC_XGXS_TUNING_SM_CTRL0r_BYPASS_BR_DATA_SLICER_CALf_GET
#define TUNING_SM_CTRL0r_BYPASS_BR_DATA_SLICER_CALf_SET BCMI_TSC_XGXS_TUNING_SM_CTRL0r_BYPASS_BR_DATA_SLICER_CALf_SET
#define TUNING_SM_CTRL0r_BYPASS_OS_DATA_SLICER_CALf_GET BCMI_TSC_XGXS_TUNING_SM_CTRL0r_BYPASS_OS_DATA_SLICER_CALf_GET
#define TUNING_SM_CTRL0r_BYPASS_OS_DATA_SLICER_CALf_SET BCMI_TSC_XGXS_TUNING_SM_CTRL0r_BYPASS_OS_DATA_SLICER_CALf_SET
#define TUNING_SM_CTRL0r_RESTART_TUNINGf_GET BCMI_TSC_XGXS_TUNING_SM_CTRL0r_RESTART_TUNINGf_GET
#define TUNING_SM_CTRL0r_RESTART_TUNINGf_SET BCMI_TSC_XGXS_TUNING_SM_CTRL0r_RESTART_TUNINGf_SET
#define TUNING_SM_CTRL0r_TUNING_SM_ENf_GET BCMI_TSC_XGXS_TUNING_SM_CTRL0r_TUNING_SM_ENf_GET
#define TUNING_SM_CTRL0r_TUNING_SM_ENf_SET BCMI_TSC_XGXS_TUNING_SM_CTRL0r_TUNING_SM_ENf_SET
#define READ_TUNING_SM_CTRL0r BCMI_TSC_XGXS_READ_TUNING_SM_CTRL0r
#define WRITE_TUNING_SM_CTRL0r BCMI_TSC_XGXS_WRITE_TUNING_SM_CTRL0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_TUNING_SM_CTRL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  TUNING_SM_CTRL1
 * BLOCKS:   DSC4B0
 * REGADDR:  0xc231
 * DESC:     State Machine Control 1 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     PF_CTRL_OS_INIT  
 *     PF_CTRL_BR_INIT  
 *     PF_CTRL_OSX2_OFFSET 
 *     PF_CTRL_OSX1_OFFSET 
 *     PF_CTRL_BR_OFFSET 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_TUNING_SM_CTRL1r (0x0000c231 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_TUNING_SM_CTRL1r_SIZE 4

/*
 * This structure should be used to declare and program TUNING_SM_CTRL1.
 *
 */
typedef union BCMI_TSC_XGXS_TUNING_SM_CTRL1r_s {
	uint32_t v[1];
	uint32_t tuning_sm_ctrl1[1];
	uint32_t _tuning_sm_ctrl1;
} BCMI_TSC_XGXS_TUNING_SM_CTRL1r_t;

#define BCMI_TSC_XGXS_TUNING_SM_CTRL1r_CLR(r) (r).tuning_sm_ctrl1[0] = 0
#define BCMI_TSC_XGXS_TUNING_SM_CTRL1r_SET(r,d) (r).tuning_sm_ctrl1[0] = d
#define BCMI_TSC_XGXS_TUNING_SM_CTRL1r_GET(r) (r).tuning_sm_ctrl1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_TUNING_SM_CTRL1r_RESERVED0f_GET(r) ((((r).tuning_sm_ctrl1[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_TUNING_SM_CTRL1r_RESERVED0f_SET(r,f) (r).tuning_sm_ctrl1[0]=(((r).tuning_sm_ctrl1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_TUNING_SM_CTRL1r_PF_CTRL_BR_OFFSETf_GET(r) ((((r).tuning_sm_ctrl1[0]) >> 12) & 0x7)
#define BCMI_TSC_XGXS_TUNING_SM_CTRL1r_PF_CTRL_BR_OFFSETf_SET(r,f) (r).tuning_sm_ctrl1[0]=(((r).tuning_sm_ctrl1[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCMI_TSC_XGXS_TUNING_SM_CTRL1r_PF_CTRL_OSX1_OFFSETf_GET(r) ((((r).tuning_sm_ctrl1[0]) >> 9) & 0x7)
#define BCMI_TSC_XGXS_TUNING_SM_CTRL1r_PF_CTRL_OSX1_OFFSETf_SET(r,f) (r).tuning_sm_ctrl1[0]=(((r).tuning_sm_ctrl1[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCMI_TSC_XGXS_TUNING_SM_CTRL1r_PF_CTRL_OSX2_OFFSETf_GET(r) ((((r).tuning_sm_ctrl1[0]) >> 6) & 0x7)
#define BCMI_TSC_XGXS_TUNING_SM_CTRL1r_PF_CTRL_OSX2_OFFSETf_SET(r,f) (r).tuning_sm_ctrl1[0]=(((r).tuning_sm_ctrl1[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCMI_TSC_XGXS_TUNING_SM_CTRL1r_PF_CTRL_BR_INITf_GET(r) ((((r).tuning_sm_ctrl1[0]) >> 3) & 0x7)
#define BCMI_TSC_XGXS_TUNING_SM_CTRL1r_PF_CTRL_BR_INITf_SET(r,f) (r).tuning_sm_ctrl1[0]=(((r).tuning_sm_ctrl1[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCMI_TSC_XGXS_TUNING_SM_CTRL1r_PF_CTRL_OS_INITf_GET(r) (((r).tuning_sm_ctrl1[0]) & 0x7)
#define BCMI_TSC_XGXS_TUNING_SM_CTRL1r_PF_CTRL_OS_INITf_SET(r,f) (r).tuning_sm_ctrl1[0]=(((r).tuning_sm_ctrl1[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))

/*
 * These macros can be used to access TUNING_SM_CTRL1.
 *
 */
#define BCMI_TSC_XGXS_READ_TUNING_SM_CTRL1r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_TUNING_SM_CTRL1r,(_r._tuning_sm_ctrl1))
#define BCMI_TSC_XGXS_WRITE_TUNING_SM_CTRL1r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_TUNING_SM_CTRL1r,(_r._tuning_sm_ctrl1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TUNING_SM_CTRL1r BCMI_TSC_XGXS_TUNING_SM_CTRL1r
#define TUNING_SM_CTRL1r_SIZE BCMI_TSC_XGXS_TUNING_SM_CTRL1r_SIZE
typedef BCMI_TSC_XGXS_TUNING_SM_CTRL1r_t TUNING_SM_CTRL1r_t;
#define TUNING_SM_CTRL1r_CLR BCMI_TSC_XGXS_TUNING_SM_CTRL1r_CLR
#define TUNING_SM_CTRL1r_SET BCMI_TSC_XGXS_TUNING_SM_CTRL1r_SET
#define TUNING_SM_CTRL1r_GET BCMI_TSC_XGXS_TUNING_SM_CTRL1r_GET
#define TUNING_SM_CTRL1r_RESERVED0f_GET BCMI_TSC_XGXS_TUNING_SM_CTRL1r_RESERVED0f_GET
#define TUNING_SM_CTRL1r_RESERVED0f_SET BCMI_TSC_XGXS_TUNING_SM_CTRL1r_RESERVED0f_SET
#define TUNING_SM_CTRL1r_PF_CTRL_BR_OFFSETf_GET BCMI_TSC_XGXS_TUNING_SM_CTRL1r_PF_CTRL_BR_OFFSETf_GET
#define TUNING_SM_CTRL1r_PF_CTRL_BR_OFFSETf_SET BCMI_TSC_XGXS_TUNING_SM_CTRL1r_PF_CTRL_BR_OFFSETf_SET
#define TUNING_SM_CTRL1r_PF_CTRL_OSX1_OFFSETf_GET BCMI_TSC_XGXS_TUNING_SM_CTRL1r_PF_CTRL_OSX1_OFFSETf_GET
#define TUNING_SM_CTRL1r_PF_CTRL_OSX1_OFFSETf_SET BCMI_TSC_XGXS_TUNING_SM_CTRL1r_PF_CTRL_OSX1_OFFSETf_SET
#define TUNING_SM_CTRL1r_PF_CTRL_OSX2_OFFSETf_GET BCMI_TSC_XGXS_TUNING_SM_CTRL1r_PF_CTRL_OSX2_OFFSETf_GET
#define TUNING_SM_CTRL1r_PF_CTRL_OSX2_OFFSETf_SET BCMI_TSC_XGXS_TUNING_SM_CTRL1r_PF_CTRL_OSX2_OFFSETf_SET
#define TUNING_SM_CTRL1r_PF_CTRL_BR_INITf_GET BCMI_TSC_XGXS_TUNING_SM_CTRL1r_PF_CTRL_BR_INITf_GET
#define TUNING_SM_CTRL1r_PF_CTRL_BR_INITf_SET BCMI_TSC_XGXS_TUNING_SM_CTRL1r_PF_CTRL_BR_INITf_SET
#define TUNING_SM_CTRL1r_PF_CTRL_OS_INITf_GET BCMI_TSC_XGXS_TUNING_SM_CTRL1r_PF_CTRL_OS_INITf_GET
#define TUNING_SM_CTRL1r_PF_CTRL_OS_INITf_SET BCMI_TSC_XGXS_TUNING_SM_CTRL1r_PF_CTRL_OS_INITf_SET
#define READ_TUNING_SM_CTRL1r BCMI_TSC_XGXS_READ_TUNING_SM_CTRL1r
#define WRITE_TUNING_SM_CTRL1r BCMI_TSC_XGXS_WRITE_TUNING_SM_CTRL1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_TUNING_SM_CTRL1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  TUNING_SM_CTRL2
 * BLOCKS:   DSC4B0
 * REGADDR:  0xc232
 * DESC:     State Machine Control 2 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     VGA_MIN_VAL      
 *     VGA_MAX_VAL      
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_TUNING_SM_CTRL2r (0x0000c232 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_TUNING_SM_CTRL2r_SIZE 4

/*
 * This structure should be used to declare and program TUNING_SM_CTRL2.
 *
 */
typedef union BCMI_TSC_XGXS_TUNING_SM_CTRL2r_s {
	uint32_t v[1];
	uint32_t tuning_sm_ctrl2[1];
	uint32_t _tuning_sm_ctrl2;
} BCMI_TSC_XGXS_TUNING_SM_CTRL2r_t;

#define BCMI_TSC_XGXS_TUNING_SM_CTRL2r_CLR(r) (r).tuning_sm_ctrl2[0] = 0
#define BCMI_TSC_XGXS_TUNING_SM_CTRL2r_SET(r,d) (r).tuning_sm_ctrl2[0] = d
#define BCMI_TSC_XGXS_TUNING_SM_CTRL2r_GET(r) (r).tuning_sm_ctrl2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_TUNING_SM_CTRL2r_RESERVED0f_GET(r) ((((r).tuning_sm_ctrl2[0]) >> 12) & 0xf)
#define BCMI_TSC_XGXS_TUNING_SM_CTRL2r_RESERVED0f_SET(r,f) (r).tuning_sm_ctrl2[0]=(((r).tuning_sm_ctrl2[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCMI_TSC_XGXS_TUNING_SM_CTRL2r_VGA_MAX_VALf_GET(r) ((((r).tuning_sm_ctrl2[0]) >> 6) & 0x3f)
#define BCMI_TSC_XGXS_TUNING_SM_CTRL2r_VGA_MAX_VALf_SET(r,f) (r).tuning_sm_ctrl2[0]=(((r).tuning_sm_ctrl2[0] & ~((uint32_t)0x3f << 6)) | ((((uint32_t)f) & 0x3f) << 6))
#define BCMI_TSC_XGXS_TUNING_SM_CTRL2r_VGA_MIN_VALf_GET(r) (((r).tuning_sm_ctrl2[0]) & 0x3f)
#define BCMI_TSC_XGXS_TUNING_SM_CTRL2r_VGA_MIN_VALf_SET(r,f) (r).tuning_sm_ctrl2[0]=(((r).tuning_sm_ctrl2[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))

/*
 * These macros can be used to access TUNING_SM_CTRL2.
 *
 */
#define BCMI_TSC_XGXS_READ_TUNING_SM_CTRL2r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_TUNING_SM_CTRL2r,(_r._tuning_sm_ctrl2))
#define BCMI_TSC_XGXS_WRITE_TUNING_SM_CTRL2r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_TUNING_SM_CTRL2r,(_r._tuning_sm_ctrl2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TUNING_SM_CTRL2r BCMI_TSC_XGXS_TUNING_SM_CTRL2r
#define TUNING_SM_CTRL2r_SIZE BCMI_TSC_XGXS_TUNING_SM_CTRL2r_SIZE
typedef BCMI_TSC_XGXS_TUNING_SM_CTRL2r_t TUNING_SM_CTRL2r_t;
#define TUNING_SM_CTRL2r_CLR BCMI_TSC_XGXS_TUNING_SM_CTRL2r_CLR
#define TUNING_SM_CTRL2r_SET BCMI_TSC_XGXS_TUNING_SM_CTRL2r_SET
#define TUNING_SM_CTRL2r_GET BCMI_TSC_XGXS_TUNING_SM_CTRL2r_GET
#define TUNING_SM_CTRL2r_RESERVED0f_GET BCMI_TSC_XGXS_TUNING_SM_CTRL2r_RESERVED0f_GET
#define TUNING_SM_CTRL2r_RESERVED0f_SET BCMI_TSC_XGXS_TUNING_SM_CTRL2r_RESERVED0f_SET
#define TUNING_SM_CTRL2r_VGA_MAX_VALf_GET BCMI_TSC_XGXS_TUNING_SM_CTRL2r_VGA_MAX_VALf_GET
#define TUNING_SM_CTRL2r_VGA_MAX_VALf_SET BCMI_TSC_XGXS_TUNING_SM_CTRL2r_VGA_MAX_VALf_SET
#define TUNING_SM_CTRL2r_VGA_MIN_VALf_GET BCMI_TSC_XGXS_TUNING_SM_CTRL2r_VGA_MIN_VALf_GET
#define TUNING_SM_CTRL2r_VGA_MIN_VALf_SET BCMI_TSC_XGXS_TUNING_SM_CTRL2r_VGA_MIN_VALf_SET
#define READ_TUNING_SM_CTRL2r BCMI_TSC_XGXS_READ_TUNING_SM_CTRL2r
#define WRITE_TUNING_SM_CTRL2r BCMI_TSC_XGXS_WRITE_TUNING_SM_CTRL2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_TUNING_SM_CTRL2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  TUNING_SM_CTRL3
 * BLOCKS:   DSC4B0
 * REGADDR:  0xc233
 * DESC:     State Machine Control 3 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     DFE_MIN_VAL      
 *     DFE_MAX_VAL      
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_TUNING_SM_CTRL3r (0x0000c233 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_TUNING_SM_CTRL3r_SIZE 4

/*
 * This structure should be used to declare and program TUNING_SM_CTRL3.
 *
 */
typedef union BCMI_TSC_XGXS_TUNING_SM_CTRL3r_s {
	uint32_t v[1];
	uint32_t tuning_sm_ctrl3[1];
	uint32_t _tuning_sm_ctrl3;
} BCMI_TSC_XGXS_TUNING_SM_CTRL3r_t;

#define BCMI_TSC_XGXS_TUNING_SM_CTRL3r_CLR(r) (r).tuning_sm_ctrl3[0] = 0
#define BCMI_TSC_XGXS_TUNING_SM_CTRL3r_SET(r,d) (r).tuning_sm_ctrl3[0] = d
#define BCMI_TSC_XGXS_TUNING_SM_CTRL3r_GET(r) (r).tuning_sm_ctrl3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_TUNING_SM_CTRL3r_RESERVED0f_GET(r) ((((r).tuning_sm_ctrl3[0]) >> 12) & 0xf)
#define BCMI_TSC_XGXS_TUNING_SM_CTRL3r_RESERVED0f_SET(r,f) (r).tuning_sm_ctrl3[0]=(((r).tuning_sm_ctrl3[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCMI_TSC_XGXS_TUNING_SM_CTRL3r_DFE_MAX_VALf_GET(r) ((((r).tuning_sm_ctrl3[0]) >> 6) & 0x3f)
#define BCMI_TSC_XGXS_TUNING_SM_CTRL3r_DFE_MAX_VALf_SET(r,f) (r).tuning_sm_ctrl3[0]=(((r).tuning_sm_ctrl3[0] & ~((uint32_t)0x3f << 6)) | ((((uint32_t)f) & 0x3f) << 6))
#define BCMI_TSC_XGXS_TUNING_SM_CTRL3r_DFE_MIN_VALf_GET(r) (((r).tuning_sm_ctrl3[0]) & 0x3f)
#define BCMI_TSC_XGXS_TUNING_SM_CTRL3r_DFE_MIN_VALf_SET(r,f) (r).tuning_sm_ctrl3[0]=(((r).tuning_sm_ctrl3[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))

/*
 * These macros can be used to access TUNING_SM_CTRL3.
 *
 */
#define BCMI_TSC_XGXS_READ_TUNING_SM_CTRL3r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_TUNING_SM_CTRL3r,(_r._tuning_sm_ctrl3))
#define BCMI_TSC_XGXS_WRITE_TUNING_SM_CTRL3r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_TUNING_SM_CTRL3r,(_r._tuning_sm_ctrl3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TUNING_SM_CTRL3r BCMI_TSC_XGXS_TUNING_SM_CTRL3r
#define TUNING_SM_CTRL3r_SIZE BCMI_TSC_XGXS_TUNING_SM_CTRL3r_SIZE
typedef BCMI_TSC_XGXS_TUNING_SM_CTRL3r_t TUNING_SM_CTRL3r_t;
#define TUNING_SM_CTRL3r_CLR BCMI_TSC_XGXS_TUNING_SM_CTRL3r_CLR
#define TUNING_SM_CTRL3r_SET BCMI_TSC_XGXS_TUNING_SM_CTRL3r_SET
#define TUNING_SM_CTRL3r_GET BCMI_TSC_XGXS_TUNING_SM_CTRL3r_GET
#define TUNING_SM_CTRL3r_RESERVED0f_GET BCMI_TSC_XGXS_TUNING_SM_CTRL3r_RESERVED0f_GET
#define TUNING_SM_CTRL3r_RESERVED0f_SET BCMI_TSC_XGXS_TUNING_SM_CTRL3r_RESERVED0f_SET
#define TUNING_SM_CTRL3r_DFE_MAX_VALf_GET BCMI_TSC_XGXS_TUNING_SM_CTRL3r_DFE_MAX_VALf_GET
#define TUNING_SM_CTRL3r_DFE_MAX_VALf_SET BCMI_TSC_XGXS_TUNING_SM_CTRL3r_DFE_MAX_VALf_SET
#define TUNING_SM_CTRL3r_DFE_MIN_VALf_GET BCMI_TSC_XGXS_TUNING_SM_CTRL3r_DFE_MIN_VALf_GET
#define TUNING_SM_CTRL3r_DFE_MIN_VALf_SET BCMI_TSC_XGXS_TUNING_SM_CTRL3r_DFE_MIN_VALf_SET
#define READ_TUNING_SM_CTRL3r BCMI_TSC_XGXS_READ_TUNING_SM_CTRL3r
#define WRITE_TUNING_SM_CTRL3r BCMI_TSC_XGXS_WRITE_TUNING_SM_CTRL3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_TUNING_SM_CTRL3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  TUNING_SM_CTRL4
 * BLOCKS:   DSC4B0
 * REGADDR:  0xc234
 * DESC:     State Machine Control 4 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     OSX1_PF_TAP_EN   
 *     BR_PF_TAP_EN     
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_TUNING_SM_CTRL4r (0x0000c234 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_TUNING_SM_CTRL4r_SIZE 4

/*
 * This structure should be used to declare and program TUNING_SM_CTRL4.
 *
 */
typedef union BCMI_TSC_XGXS_TUNING_SM_CTRL4r_s {
	uint32_t v[1];
	uint32_t tuning_sm_ctrl4[1];
	uint32_t _tuning_sm_ctrl4;
} BCMI_TSC_XGXS_TUNING_SM_CTRL4r_t;

#define BCMI_TSC_XGXS_TUNING_SM_CTRL4r_CLR(r) (r).tuning_sm_ctrl4[0] = 0
#define BCMI_TSC_XGXS_TUNING_SM_CTRL4r_SET(r,d) (r).tuning_sm_ctrl4[0] = d
#define BCMI_TSC_XGXS_TUNING_SM_CTRL4r_GET(r) (r).tuning_sm_ctrl4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_TUNING_SM_CTRL4r_RESERVED0f_GET(r) ((((r).tuning_sm_ctrl4[0]) >> 14) & 0x3)
#define BCMI_TSC_XGXS_TUNING_SM_CTRL4r_RESERVED0f_SET(r,f) (r).tuning_sm_ctrl4[0]=(((r).tuning_sm_ctrl4[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCMI_TSC_XGXS_TUNING_SM_CTRL4r_BR_PF_TAP_ENf_GET(r) ((((r).tuning_sm_ctrl4[0]) >> 7) & 0x7f)
#define BCMI_TSC_XGXS_TUNING_SM_CTRL4r_BR_PF_TAP_ENf_SET(r,f) (r).tuning_sm_ctrl4[0]=(((r).tuning_sm_ctrl4[0] & ~((uint32_t)0x7f << 7)) | ((((uint32_t)f) & 0x7f) << 7))
#define BCMI_TSC_XGXS_TUNING_SM_CTRL4r_OSX1_PF_TAP_ENf_GET(r) (((r).tuning_sm_ctrl4[0]) & 0x7f)
#define BCMI_TSC_XGXS_TUNING_SM_CTRL4r_OSX1_PF_TAP_ENf_SET(r,f) (r).tuning_sm_ctrl4[0]=(((r).tuning_sm_ctrl4[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f))

/*
 * These macros can be used to access TUNING_SM_CTRL4.
 *
 */
#define BCMI_TSC_XGXS_READ_TUNING_SM_CTRL4r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_TUNING_SM_CTRL4r,(_r._tuning_sm_ctrl4))
#define BCMI_TSC_XGXS_WRITE_TUNING_SM_CTRL4r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_TUNING_SM_CTRL4r,(_r._tuning_sm_ctrl4))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TUNING_SM_CTRL4r BCMI_TSC_XGXS_TUNING_SM_CTRL4r
#define TUNING_SM_CTRL4r_SIZE BCMI_TSC_XGXS_TUNING_SM_CTRL4r_SIZE
typedef BCMI_TSC_XGXS_TUNING_SM_CTRL4r_t TUNING_SM_CTRL4r_t;
#define TUNING_SM_CTRL4r_CLR BCMI_TSC_XGXS_TUNING_SM_CTRL4r_CLR
#define TUNING_SM_CTRL4r_SET BCMI_TSC_XGXS_TUNING_SM_CTRL4r_SET
#define TUNING_SM_CTRL4r_GET BCMI_TSC_XGXS_TUNING_SM_CTRL4r_GET
#define TUNING_SM_CTRL4r_RESERVED0f_GET BCMI_TSC_XGXS_TUNING_SM_CTRL4r_RESERVED0f_GET
#define TUNING_SM_CTRL4r_RESERVED0f_SET BCMI_TSC_XGXS_TUNING_SM_CTRL4r_RESERVED0f_SET
#define TUNING_SM_CTRL4r_BR_PF_TAP_ENf_GET BCMI_TSC_XGXS_TUNING_SM_CTRL4r_BR_PF_TAP_ENf_GET
#define TUNING_SM_CTRL4r_BR_PF_TAP_ENf_SET BCMI_TSC_XGXS_TUNING_SM_CTRL4r_BR_PF_TAP_ENf_SET
#define TUNING_SM_CTRL4r_OSX1_PF_TAP_ENf_GET BCMI_TSC_XGXS_TUNING_SM_CTRL4r_OSX1_PF_TAP_ENf_GET
#define TUNING_SM_CTRL4r_OSX1_PF_TAP_ENf_SET BCMI_TSC_XGXS_TUNING_SM_CTRL4r_OSX1_PF_TAP_ENf_SET
#define READ_TUNING_SM_CTRL4r BCMI_TSC_XGXS_READ_TUNING_SM_CTRL4r
#define WRITE_TUNING_SM_CTRL4r BCMI_TSC_XGXS_WRITE_TUNING_SM_CTRL4r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_TUNING_SM_CTRL4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  TUNING_SM_CTRL5
 * BLOCKS:   DSC4B0
 * REGADDR:  0xc235
 * DESC:     State Machine Control 5 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     MSR_POSTC_TIMEOUT 
 *     HYSTERESIS_TIMEOUT 
 *     MSR_BR_VGA_TIMEOUT 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_TUNING_SM_CTRL5r (0x0000c235 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_TUNING_SM_CTRL5r_SIZE 4

/*
 * This structure should be used to declare and program TUNING_SM_CTRL5.
 *
 */
typedef union BCMI_TSC_XGXS_TUNING_SM_CTRL5r_s {
	uint32_t v[1];
	uint32_t tuning_sm_ctrl5[1];
	uint32_t _tuning_sm_ctrl5;
} BCMI_TSC_XGXS_TUNING_SM_CTRL5r_t;

#define BCMI_TSC_XGXS_TUNING_SM_CTRL5r_CLR(r) (r).tuning_sm_ctrl5[0] = 0
#define BCMI_TSC_XGXS_TUNING_SM_CTRL5r_SET(r,d) (r).tuning_sm_ctrl5[0] = d
#define BCMI_TSC_XGXS_TUNING_SM_CTRL5r_GET(r) (r).tuning_sm_ctrl5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_TUNING_SM_CTRL5r_RESERVED0f_GET(r) ((((r).tuning_sm_ctrl5[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_TUNING_SM_CTRL5r_RESERVED0f_SET(r,f) (r).tuning_sm_ctrl5[0]=(((r).tuning_sm_ctrl5[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_TUNING_SM_CTRL5r_MSR_BR_VGA_TIMEOUTf_GET(r) ((((r).tuning_sm_ctrl5[0]) >> 10) & 0x1f)
#define BCMI_TSC_XGXS_TUNING_SM_CTRL5r_MSR_BR_VGA_TIMEOUTf_SET(r,f) (r).tuning_sm_ctrl5[0]=(((r).tuning_sm_ctrl5[0] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10))
#define BCMI_TSC_XGXS_TUNING_SM_CTRL5r_HYSTERESIS_TIMEOUTf_GET(r) ((((r).tuning_sm_ctrl5[0]) >> 5) & 0x1f)
#define BCMI_TSC_XGXS_TUNING_SM_CTRL5r_HYSTERESIS_TIMEOUTf_SET(r,f) (r).tuning_sm_ctrl5[0]=(((r).tuning_sm_ctrl5[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5))
#define BCMI_TSC_XGXS_TUNING_SM_CTRL5r_MSR_POSTC_TIMEOUTf_GET(r) (((r).tuning_sm_ctrl5[0]) & 0x1f)
#define BCMI_TSC_XGXS_TUNING_SM_CTRL5r_MSR_POSTC_TIMEOUTf_SET(r,f) (r).tuning_sm_ctrl5[0]=(((r).tuning_sm_ctrl5[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))

/*
 * These macros can be used to access TUNING_SM_CTRL5.
 *
 */
#define BCMI_TSC_XGXS_READ_TUNING_SM_CTRL5r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_TUNING_SM_CTRL5r,(_r._tuning_sm_ctrl5))
#define BCMI_TSC_XGXS_WRITE_TUNING_SM_CTRL5r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_TUNING_SM_CTRL5r,(_r._tuning_sm_ctrl5))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TUNING_SM_CTRL5r BCMI_TSC_XGXS_TUNING_SM_CTRL5r
#define TUNING_SM_CTRL5r_SIZE BCMI_TSC_XGXS_TUNING_SM_CTRL5r_SIZE
typedef BCMI_TSC_XGXS_TUNING_SM_CTRL5r_t TUNING_SM_CTRL5r_t;
#define TUNING_SM_CTRL5r_CLR BCMI_TSC_XGXS_TUNING_SM_CTRL5r_CLR
#define TUNING_SM_CTRL5r_SET BCMI_TSC_XGXS_TUNING_SM_CTRL5r_SET
#define TUNING_SM_CTRL5r_GET BCMI_TSC_XGXS_TUNING_SM_CTRL5r_GET
#define TUNING_SM_CTRL5r_RESERVED0f_GET BCMI_TSC_XGXS_TUNING_SM_CTRL5r_RESERVED0f_GET
#define TUNING_SM_CTRL5r_RESERVED0f_SET BCMI_TSC_XGXS_TUNING_SM_CTRL5r_RESERVED0f_SET
#define TUNING_SM_CTRL5r_MSR_BR_VGA_TIMEOUTf_GET BCMI_TSC_XGXS_TUNING_SM_CTRL5r_MSR_BR_VGA_TIMEOUTf_GET
#define TUNING_SM_CTRL5r_MSR_BR_VGA_TIMEOUTf_SET BCMI_TSC_XGXS_TUNING_SM_CTRL5r_MSR_BR_VGA_TIMEOUTf_SET
#define TUNING_SM_CTRL5r_HYSTERESIS_TIMEOUTf_GET BCMI_TSC_XGXS_TUNING_SM_CTRL5r_HYSTERESIS_TIMEOUTf_GET
#define TUNING_SM_CTRL5r_HYSTERESIS_TIMEOUTf_SET BCMI_TSC_XGXS_TUNING_SM_CTRL5r_HYSTERESIS_TIMEOUTf_SET
#define TUNING_SM_CTRL5r_MSR_POSTC_TIMEOUTf_GET BCMI_TSC_XGXS_TUNING_SM_CTRL5r_MSR_POSTC_TIMEOUTf_GET
#define TUNING_SM_CTRL5r_MSR_POSTC_TIMEOUTf_SET BCMI_TSC_XGXS_TUNING_SM_CTRL5r_MSR_POSTC_TIMEOUTf_SET
#define READ_TUNING_SM_CTRL5r BCMI_TSC_XGXS_READ_TUNING_SM_CTRL5r
#define WRITE_TUNING_SM_CTRL5r BCMI_TSC_XGXS_WRITE_TUNING_SM_CTRL5r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_TUNING_SM_CTRL5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  TUNING_SM_CTRL6
 * BLOCKS:   DSC4B0
 * REGADDR:  0xc236
 * DESC:     State Machine Control 6 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     MSR_PF_TIMEOUT   
 *     CDR_PHASE_INVERSION_TIMEOUT 
 *     POSTC_DFE_LMS_GAIN 
 *     BR_VGA_LMS_GAIN  
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_TUNING_SM_CTRL6r (0x0000c236 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_TUNING_SM_CTRL6r_SIZE 4

/*
 * This structure should be used to declare and program TUNING_SM_CTRL6.
 *
 */
typedef union BCMI_TSC_XGXS_TUNING_SM_CTRL6r_s {
	uint32_t v[1];
	uint32_t tuning_sm_ctrl6[1];
	uint32_t _tuning_sm_ctrl6;
} BCMI_TSC_XGXS_TUNING_SM_CTRL6r_t;

#define BCMI_TSC_XGXS_TUNING_SM_CTRL6r_CLR(r) (r).tuning_sm_ctrl6[0] = 0
#define BCMI_TSC_XGXS_TUNING_SM_CTRL6r_SET(r,d) (r).tuning_sm_ctrl6[0] = d
#define BCMI_TSC_XGXS_TUNING_SM_CTRL6r_GET(r) (r).tuning_sm_ctrl6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_TUNING_SM_CTRL6r_RESERVED0f_GET(r) ((((r).tuning_sm_ctrl6[0]) >> 14) & 0x3)
#define BCMI_TSC_XGXS_TUNING_SM_CTRL6r_RESERVED0f_SET(r,f) (r).tuning_sm_ctrl6[0]=(((r).tuning_sm_ctrl6[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCMI_TSC_XGXS_TUNING_SM_CTRL6r_BR_VGA_LMS_GAINf_GET(r) ((((r).tuning_sm_ctrl6[0]) >> 12) & 0x3)
#define BCMI_TSC_XGXS_TUNING_SM_CTRL6r_BR_VGA_LMS_GAINf_SET(r,f) (r).tuning_sm_ctrl6[0]=(((r).tuning_sm_ctrl6[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCMI_TSC_XGXS_TUNING_SM_CTRL6r_POSTC_DFE_LMS_GAINf_GET(r) ((((r).tuning_sm_ctrl6[0]) >> 10) & 0x3)
#define BCMI_TSC_XGXS_TUNING_SM_CTRL6r_POSTC_DFE_LMS_GAINf_SET(r,f) (r).tuning_sm_ctrl6[0]=(((r).tuning_sm_ctrl6[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCMI_TSC_XGXS_TUNING_SM_CTRL6r_CDR_PHASE_INVERSION_TIMEOUTf_GET(r) ((((r).tuning_sm_ctrl6[0]) >> 5) & 0x1f)
#define BCMI_TSC_XGXS_TUNING_SM_CTRL6r_CDR_PHASE_INVERSION_TIMEOUTf_SET(r,f) (r).tuning_sm_ctrl6[0]=(((r).tuning_sm_ctrl6[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5))
#define BCMI_TSC_XGXS_TUNING_SM_CTRL6r_MSR_PF_TIMEOUTf_GET(r) (((r).tuning_sm_ctrl6[0]) & 0x1f)
#define BCMI_TSC_XGXS_TUNING_SM_CTRL6r_MSR_PF_TIMEOUTf_SET(r,f) (r).tuning_sm_ctrl6[0]=(((r).tuning_sm_ctrl6[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))

/*
 * These macros can be used to access TUNING_SM_CTRL6.
 *
 */
#define BCMI_TSC_XGXS_READ_TUNING_SM_CTRL6r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_TUNING_SM_CTRL6r,(_r._tuning_sm_ctrl6))
#define BCMI_TSC_XGXS_WRITE_TUNING_SM_CTRL6r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_TUNING_SM_CTRL6r,(_r._tuning_sm_ctrl6))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TUNING_SM_CTRL6r BCMI_TSC_XGXS_TUNING_SM_CTRL6r
#define TUNING_SM_CTRL6r_SIZE BCMI_TSC_XGXS_TUNING_SM_CTRL6r_SIZE
typedef BCMI_TSC_XGXS_TUNING_SM_CTRL6r_t TUNING_SM_CTRL6r_t;
#define TUNING_SM_CTRL6r_CLR BCMI_TSC_XGXS_TUNING_SM_CTRL6r_CLR
#define TUNING_SM_CTRL6r_SET BCMI_TSC_XGXS_TUNING_SM_CTRL6r_SET
#define TUNING_SM_CTRL6r_GET BCMI_TSC_XGXS_TUNING_SM_CTRL6r_GET
#define TUNING_SM_CTRL6r_RESERVED0f_GET BCMI_TSC_XGXS_TUNING_SM_CTRL6r_RESERVED0f_GET
#define TUNING_SM_CTRL6r_RESERVED0f_SET BCMI_TSC_XGXS_TUNING_SM_CTRL6r_RESERVED0f_SET
#define TUNING_SM_CTRL6r_BR_VGA_LMS_GAINf_GET BCMI_TSC_XGXS_TUNING_SM_CTRL6r_BR_VGA_LMS_GAINf_GET
#define TUNING_SM_CTRL6r_BR_VGA_LMS_GAINf_SET BCMI_TSC_XGXS_TUNING_SM_CTRL6r_BR_VGA_LMS_GAINf_SET
#define TUNING_SM_CTRL6r_POSTC_DFE_LMS_GAINf_GET BCMI_TSC_XGXS_TUNING_SM_CTRL6r_POSTC_DFE_LMS_GAINf_GET
#define TUNING_SM_CTRL6r_POSTC_DFE_LMS_GAINf_SET BCMI_TSC_XGXS_TUNING_SM_CTRL6r_POSTC_DFE_LMS_GAINf_SET
#define TUNING_SM_CTRL6r_CDR_PHASE_INVERSION_TIMEOUTf_GET BCMI_TSC_XGXS_TUNING_SM_CTRL6r_CDR_PHASE_INVERSION_TIMEOUTf_GET
#define TUNING_SM_CTRL6r_CDR_PHASE_INVERSION_TIMEOUTf_SET BCMI_TSC_XGXS_TUNING_SM_CTRL6r_CDR_PHASE_INVERSION_TIMEOUTf_SET
#define TUNING_SM_CTRL6r_MSR_PF_TIMEOUTf_GET BCMI_TSC_XGXS_TUNING_SM_CTRL6r_MSR_PF_TIMEOUTf_GET
#define TUNING_SM_CTRL6r_MSR_PF_TIMEOUTf_SET BCMI_TSC_XGXS_TUNING_SM_CTRL6r_MSR_PF_TIMEOUTf_SET
#define READ_TUNING_SM_CTRL6r BCMI_TSC_XGXS_READ_TUNING_SM_CTRL6r
#define WRITE_TUNING_SM_CTRL6r BCMI_TSC_XGXS_WRITE_TUNING_SM_CTRL6r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_TUNING_SM_CTRL6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  TUNING_SM_CTRL7
 * BLOCKS:   DSC4B0
 * REGADDR:  0xc237
 * DESC:     State Machine Control 7 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     BR_PF_TRN1_TIMEOUT 
 *     BR_PF_TRN2_TIMEOUT 
 *     BR_VGA_TRN2_TIMEOUT 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_TUNING_SM_CTRL7r (0x0000c237 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_TUNING_SM_CTRL7r_SIZE 4

/*
 * This structure should be used to declare and program TUNING_SM_CTRL7.
 *
 */
typedef union BCMI_TSC_XGXS_TUNING_SM_CTRL7r_s {
	uint32_t v[1];
	uint32_t tuning_sm_ctrl7[1];
	uint32_t _tuning_sm_ctrl7;
} BCMI_TSC_XGXS_TUNING_SM_CTRL7r_t;

#define BCMI_TSC_XGXS_TUNING_SM_CTRL7r_CLR(r) (r).tuning_sm_ctrl7[0] = 0
#define BCMI_TSC_XGXS_TUNING_SM_CTRL7r_SET(r,d) (r).tuning_sm_ctrl7[0] = d
#define BCMI_TSC_XGXS_TUNING_SM_CTRL7r_GET(r) (r).tuning_sm_ctrl7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_TUNING_SM_CTRL7r_RESERVED0f_GET(r) ((((r).tuning_sm_ctrl7[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_TUNING_SM_CTRL7r_RESERVED0f_SET(r,f) (r).tuning_sm_ctrl7[0]=(((r).tuning_sm_ctrl7[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_TUNING_SM_CTRL7r_BR_VGA_TRN2_TIMEOUTf_GET(r) ((((r).tuning_sm_ctrl7[0]) >> 10) & 0x1f)
#define BCMI_TSC_XGXS_TUNING_SM_CTRL7r_BR_VGA_TRN2_TIMEOUTf_SET(r,f) (r).tuning_sm_ctrl7[0]=(((r).tuning_sm_ctrl7[0] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10))
#define BCMI_TSC_XGXS_TUNING_SM_CTRL7r_BR_PF_TRN2_TIMEOUTf_GET(r) ((((r).tuning_sm_ctrl7[0]) >> 5) & 0x1f)
#define BCMI_TSC_XGXS_TUNING_SM_CTRL7r_BR_PF_TRN2_TIMEOUTf_SET(r,f) (r).tuning_sm_ctrl7[0]=(((r).tuning_sm_ctrl7[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5))
#define BCMI_TSC_XGXS_TUNING_SM_CTRL7r_BR_PF_TRN1_TIMEOUTf_GET(r) (((r).tuning_sm_ctrl7[0]) & 0x1f)
#define BCMI_TSC_XGXS_TUNING_SM_CTRL7r_BR_PF_TRN1_TIMEOUTf_SET(r,f) (r).tuning_sm_ctrl7[0]=(((r).tuning_sm_ctrl7[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))

/*
 * These macros can be used to access TUNING_SM_CTRL7.
 *
 */
#define BCMI_TSC_XGXS_READ_TUNING_SM_CTRL7r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_TUNING_SM_CTRL7r,(_r._tuning_sm_ctrl7))
#define BCMI_TSC_XGXS_WRITE_TUNING_SM_CTRL7r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_TUNING_SM_CTRL7r,(_r._tuning_sm_ctrl7))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TUNING_SM_CTRL7r BCMI_TSC_XGXS_TUNING_SM_CTRL7r
#define TUNING_SM_CTRL7r_SIZE BCMI_TSC_XGXS_TUNING_SM_CTRL7r_SIZE
typedef BCMI_TSC_XGXS_TUNING_SM_CTRL7r_t TUNING_SM_CTRL7r_t;
#define TUNING_SM_CTRL7r_CLR BCMI_TSC_XGXS_TUNING_SM_CTRL7r_CLR
#define TUNING_SM_CTRL7r_SET BCMI_TSC_XGXS_TUNING_SM_CTRL7r_SET
#define TUNING_SM_CTRL7r_GET BCMI_TSC_XGXS_TUNING_SM_CTRL7r_GET
#define TUNING_SM_CTRL7r_RESERVED0f_GET BCMI_TSC_XGXS_TUNING_SM_CTRL7r_RESERVED0f_GET
#define TUNING_SM_CTRL7r_RESERVED0f_SET BCMI_TSC_XGXS_TUNING_SM_CTRL7r_RESERVED0f_SET
#define TUNING_SM_CTRL7r_BR_VGA_TRN2_TIMEOUTf_GET BCMI_TSC_XGXS_TUNING_SM_CTRL7r_BR_VGA_TRN2_TIMEOUTf_GET
#define TUNING_SM_CTRL7r_BR_VGA_TRN2_TIMEOUTf_SET BCMI_TSC_XGXS_TUNING_SM_CTRL7r_BR_VGA_TRN2_TIMEOUTf_SET
#define TUNING_SM_CTRL7r_BR_PF_TRN2_TIMEOUTf_GET BCMI_TSC_XGXS_TUNING_SM_CTRL7r_BR_PF_TRN2_TIMEOUTf_GET
#define TUNING_SM_CTRL7r_BR_PF_TRN2_TIMEOUTf_SET BCMI_TSC_XGXS_TUNING_SM_CTRL7r_BR_PF_TRN2_TIMEOUTf_SET
#define TUNING_SM_CTRL7r_BR_PF_TRN1_TIMEOUTf_GET BCMI_TSC_XGXS_TUNING_SM_CTRL7r_BR_PF_TRN1_TIMEOUTf_GET
#define TUNING_SM_CTRL7r_BR_PF_TRN1_TIMEOUTf_SET BCMI_TSC_XGXS_TUNING_SM_CTRL7r_BR_PF_TRN1_TIMEOUTf_SET
#define READ_TUNING_SM_CTRL7r BCMI_TSC_XGXS_READ_TUNING_SM_CTRL7r
#define WRITE_TUNING_SM_CTRL7r BCMI_TSC_XGXS_WRITE_TUNING_SM_CTRL7r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_TUNING_SM_CTRL7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  TUNING_SM_CTRL8
 * BLOCKS:   DSC4B0
 * REGADDR:  0xc238
 * DESC:     State Machine Control 8 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     OSX2_PF_TAP_EN   
 *     BR_POSTC_TAP_EN  
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_TUNING_SM_CTRL8r (0x0000c238 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_TUNING_SM_CTRL8r_SIZE 4

/*
 * This structure should be used to declare and program TUNING_SM_CTRL8.
 *
 */
typedef union BCMI_TSC_XGXS_TUNING_SM_CTRL8r_s {
	uint32_t v[1];
	uint32_t tuning_sm_ctrl8[1];
	uint32_t _tuning_sm_ctrl8;
} BCMI_TSC_XGXS_TUNING_SM_CTRL8r_t;

#define BCMI_TSC_XGXS_TUNING_SM_CTRL8r_CLR(r) (r).tuning_sm_ctrl8[0] = 0
#define BCMI_TSC_XGXS_TUNING_SM_CTRL8r_SET(r,d) (r).tuning_sm_ctrl8[0] = d
#define BCMI_TSC_XGXS_TUNING_SM_CTRL8r_GET(r) (r).tuning_sm_ctrl8[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_TUNING_SM_CTRL8r_RESERVED0f_GET(r) ((((r).tuning_sm_ctrl8[0]) >> 14) & 0x3)
#define BCMI_TSC_XGXS_TUNING_SM_CTRL8r_RESERVED0f_SET(r,f) (r).tuning_sm_ctrl8[0]=(((r).tuning_sm_ctrl8[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCMI_TSC_XGXS_TUNING_SM_CTRL8r_BR_POSTC_TAP_ENf_GET(r) ((((r).tuning_sm_ctrl8[0]) >> 7) & 0x7f)
#define BCMI_TSC_XGXS_TUNING_SM_CTRL8r_BR_POSTC_TAP_ENf_SET(r,f) (r).tuning_sm_ctrl8[0]=(((r).tuning_sm_ctrl8[0] & ~((uint32_t)0x7f << 7)) | ((((uint32_t)f) & 0x7f) << 7))
#define BCMI_TSC_XGXS_TUNING_SM_CTRL8r_OSX2_PF_TAP_ENf_GET(r) (((r).tuning_sm_ctrl8[0]) & 0x7f)
#define BCMI_TSC_XGXS_TUNING_SM_CTRL8r_OSX2_PF_TAP_ENf_SET(r,f) (r).tuning_sm_ctrl8[0]=(((r).tuning_sm_ctrl8[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f))

/*
 * These macros can be used to access TUNING_SM_CTRL8.
 *
 */
#define BCMI_TSC_XGXS_READ_TUNING_SM_CTRL8r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_TUNING_SM_CTRL8r,(_r._tuning_sm_ctrl8))
#define BCMI_TSC_XGXS_WRITE_TUNING_SM_CTRL8r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_TUNING_SM_CTRL8r,(_r._tuning_sm_ctrl8))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TUNING_SM_CTRL8r BCMI_TSC_XGXS_TUNING_SM_CTRL8r
#define TUNING_SM_CTRL8r_SIZE BCMI_TSC_XGXS_TUNING_SM_CTRL8r_SIZE
typedef BCMI_TSC_XGXS_TUNING_SM_CTRL8r_t TUNING_SM_CTRL8r_t;
#define TUNING_SM_CTRL8r_CLR BCMI_TSC_XGXS_TUNING_SM_CTRL8r_CLR
#define TUNING_SM_CTRL8r_SET BCMI_TSC_XGXS_TUNING_SM_CTRL8r_SET
#define TUNING_SM_CTRL8r_GET BCMI_TSC_XGXS_TUNING_SM_CTRL8r_GET
#define TUNING_SM_CTRL8r_RESERVED0f_GET BCMI_TSC_XGXS_TUNING_SM_CTRL8r_RESERVED0f_GET
#define TUNING_SM_CTRL8r_RESERVED0f_SET BCMI_TSC_XGXS_TUNING_SM_CTRL8r_RESERVED0f_SET
#define TUNING_SM_CTRL8r_BR_POSTC_TAP_ENf_GET BCMI_TSC_XGXS_TUNING_SM_CTRL8r_BR_POSTC_TAP_ENf_GET
#define TUNING_SM_CTRL8r_BR_POSTC_TAP_ENf_SET BCMI_TSC_XGXS_TUNING_SM_CTRL8r_BR_POSTC_TAP_ENf_SET
#define TUNING_SM_CTRL8r_OSX2_PF_TAP_ENf_GET BCMI_TSC_XGXS_TUNING_SM_CTRL8r_OSX2_PF_TAP_ENf_GET
#define TUNING_SM_CTRL8r_OSX2_PF_TAP_ENf_SET BCMI_TSC_XGXS_TUNING_SM_CTRL8r_OSX2_PF_TAP_ENf_SET
#define READ_TUNING_SM_CTRL8r BCMI_TSC_XGXS_READ_TUNING_SM_CTRL8r
#define WRITE_TUNING_SM_CTRL8r BCMI_TSC_XGXS_WRITE_TUNING_SM_CTRL8r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_TUNING_SM_CTRL8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  TUNING_SM_CTRL9
 * BLOCKS:   DSC4B0
 * REGADDR:  0xc239
 * DESC:     State Machine Control 9 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     OSX1_POSTC_TAP_EN 
 *     OSX2_POSTC_TAP_EN 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_TUNING_SM_CTRL9r (0x0000c239 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_TUNING_SM_CTRL9r_SIZE 4

/*
 * This structure should be used to declare and program TUNING_SM_CTRL9.
 *
 */
typedef union BCMI_TSC_XGXS_TUNING_SM_CTRL9r_s {
	uint32_t v[1];
	uint32_t tuning_sm_ctrl9[1];
	uint32_t _tuning_sm_ctrl9;
} BCMI_TSC_XGXS_TUNING_SM_CTRL9r_t;

#define BCMI_TSC_XGXS_TUNING_SM_CTRL9r_CLR(r) (r).tuning_sm_ctrl9[0] = 0
#define BCMI_TSC_XGXS_TUNING_SM_CTRL9r_SET(r,d) (r).tuning_sm_ctrl9[0] = d
#define BCMI_TSC_XGXS_TUNING_SM_CTRL9r_GET(r) (r).tuning_sm_ctrl9[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_TUNING_SM_CTRL9r_RESERVED0f_GET(r) ((((r).tuning_sm_ctrl9[0]) >> 14) & 0x3)
#define BCMI_TSC_XGXS_TUNING_SM_CTRL9r_RESERVED0f_SET(r,f) (r).tuning_sm_ctrl9[0]=(((r).tuning_sm_ctrl9[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCMI_TSC_XGXS_TUNING_SM_CTRL9r_OSX2_POSTC_TAP_ENf_GET(r) ((((r).tuning_sm_ctrl9[0]) >> 7) & 0x7f)
#define BCMI_TSC_XGXS_TUNING_SM_CTRL9r_OSX2_POSTC_TAP_ENf_SET(r,f) (r).tuning_sm_ctrl9[0]=(((r).tuning_sm_ctrl9[0] & ~((uint32_t)0x7f << 7)) | ((((uint32_t)f) & 0x7f) << 7))
#define BCMI_TSC_XGXS_TUNING_SM_CTRL9r_OSX1_POSTC_TAP_ENf_GET(r) (((r).tuning_sm_ctrl9[0]) & 0x7f)
#define BCMI_TSC_XGXS_TUNING_SM_CTRL9r_OSX1_POSTC_TAP_ENf_SET(r,f) (r).tuning_sm_ctrl9[0]=(((r).tuning_sm_ctrl9[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f))

/*
 * These macros can be used to access TUNING_SM_CTRL9.
 *
 */
#define BCMI_TSC_XGXS_READ_TUNING_SM_CTRL9r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_TUNING_SM_CTRL9r,(_r._tuning_sm_ctrl9))
#define BCMI_TSC_XGXS_WRITE_TUNING_SM_CTRL9r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_TUNING_SM_CTRL9r,(_r._tuning_sm_ctrl9))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TUNING_SM_CTRL9r BCMI_TSC_XGXS_TUNING_SM_CTRL9r
#define TUNING_SM_CTRL9r_SIZE BCMI_TSC_XGXS_TUNING_SM_CTRL9r_SIZE
typedef BCMI_TSC_XGXS_TUNING_SM_CTRL9r_t TUNING_SM_CTRL9r_t;
#define TUNING_SM_CTRL9r_CLR BCMI_TSC_XGXS_TUNING_SM_CTRL9r_CLR
#define TUNING_SM_CTRL9r_SET BCMI_TSC_XGXS_TUNING_SM_CTRL9r_SET
#define TUNING_SM_CTRL9r_GET BCMI_TSC_XGXS_TUNING_SM_CTRL9r_GET
#define TUNING_SM_CTRL9r_RESERVED0f_GET BCMI_TSC_XGXS_TUNING_SM_CTRL9r_RESERVED0f_GET
#define TUNING_SM_CTRL9r_RESERVED0f_SET BCMI_TSC_XGXS_TUNING_SM_CTRL9r_RESERVED0f_SET
#define TUNING_SM_CTRL9r_OSX2_POSTC_TAP_ENf_GET BCMI_TSC_XGXS_TUNING_SM_CTRL9r_OSX2_POSTC_TAP_ENf_GET
#define TUNING_SM_CTRL9r_OSX2_POSTC_TAP_ENf_SET BCMI_TSC_XGXS_TUNING_SM_CTRL9r_OSX2_POSTC_TAP_ENf_SET
#define TUNING_SM_CTRL9r_OSX1_POSTC_TAP_ENf_GET BCMI_TSC_XGXS_TUNING_SM_CTRL9r_OSX1_POSTC_TAP_ENf_GET
#define TUNING_SM_CTRL9r_OSX1_POSTC_TAP_ENf_SET BCMI_TSC_XGXS_TUNING_SM_CTRL9r_OSX1_POSTC_TAP_ENf_SET
#define READ_TUNING_SM_CTRL9r BCMI_TSC_XGXS_READ_TUNING_SM_CTRL9r
#define WRITE_TUNING_SM_CTRL9r BCMI_TSC_XGXS_WRITE_TUNING_SM_CTRL9r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_TUNING_SM_CTRL9r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  TUNING_SM_CTRL10
 * BLOCKS:   DSC4B0
 * REGADDR:  0xc23a
 * DESC:     State Machine Control 10 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     DEFAULT_TRN2_TIMEOUT 
 *     MSR_SLICER_FAST_TIMEOUT 
 *     MSR_SLICER_SLOW_TIMEOUT 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_TUNING_SM_CTRL10r (0x0000c23a | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_TUNING_SM_CTRL10r_SIZE 4

/*
 * This structure should be used to declare and program TUNING_SM_CTRL10.
 *
 */
typedef union BCMI_TSC_XGXS_TUNING_SM_CTRL10r_s {
	uint32_t v[1];
	uint32_t tuning_sm_ctrl10[1];
	uint32_t _tuning_sm_ctrl10;
} BCMI_TSC_XGXS_TUNING_SM_CTRL10r_t;

#define BCMI_TSC_XGXS_TUNING_SM_CTRL10r_CLR(r) (r).tuning_sm_ctrl10[0] = 0
#define BCMI_TSC_XGXS_TUNING_SM_CTRL10r_SET(r,d) (r).tuning_sm_ctrl10[0] = d
#define BCMI_TSC_XGXS_TUNING_SM_CTRL10r_GET(r) (r).tuning_sm_ctrl10[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_TUNING_SM_CTRL10r_RESERVED0f_GET(r) ((((r).tuning_sm_ctrl10[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_TUNING_SM_CTRL10r_RESERVED0f_SET(r,f) (r).tuning_sm_ctrl10[0]=(((r).tuning_sm_ctrl10[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_TUNING_SM_CTRL10r_MSR_SLICER_SLOW_TIMEOUTf_GET(r) ((((r).tuning_sm_ctrl10[0]) >> 10) & 0x1f)
#define BCMI_TSC_XGXS_TUNING_SM_CTRL10r_MSR_SLICER_SLOW_TIMEOUTf_SET(r,f) (r).tuning_sm_ctrl10[0]=(((r).tuning_sm_ctrl10[0] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10))
#define BCMI_TSC_XGXS_TUNING_SM_CTRL10r_MSR_SLICER_FAST_TIMEOUTf_GET(r) ((((r).tuning_sm_ctrl10[0]) >> 5) & 0x1f)
#define BCMI_TSC_XGXS_TUNING_SM_CTRL10r_MSR_SLICER_FAST_TIMEOUTf_SET(r,f) (r).tuning_sm_ctrl10[0]=(((r).tuning_sm_ctrl10[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5))
#define BCMI_TSC_XGXS_TUNING_SM_CTRL10r_DEFAULT_TRN2_TIMEOUTf_GET(r) (((r).tuning_sm_ctrl10[0]) & 0x1f)
#define BCMI_TSC_XGXS_TUNING_SM_CTRL10r_DEFAULT_TRN2_TIMEOUTf_SET(r,f) (r).tuning_sm_ctrl10[0]=(((r).tuning_sm_ctrl10[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))

/*
 * These macros can be used to access TUNING_SM_CTRL10.
 *
 */
#define BCMI_TSC_XGXS_READ_TUNING_SM_CTRL10r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_TUNING_SM_CTRL10r,(_r._tuning_sm_ctrl10))
#define BCMI_TSC_XGXS_WRITE_TUNING_SM_CTRL10r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_TUNING_SM_CTRL10r,(_r._tuning_sm_ctrl10))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TUNING_SM_CTRL10r BCMI_TSC_XGXS_TUNING_SM_CTRL10r
#define TUNING_SM_CTRL10r_SIZE BCMI_TSC_XGXS_TUNING_SM_CTRL10r_SIZE
typedef BCMI_TSC_XGXS_TUNING_SM_CTRL10r_t TUNING_SM_CTRL10r_t;
#define TUNING_SM_CTRL10r_CLR BCMI_TSC_XGXS_TUNING_SM_CTRL10r_CLR
#define TUNING_SM_CTRL10r_SET BCMI_TSC_XGXS_TUNING_SM_CTRL10r_SET
#define TUNING_SM_CTRL10r_GET BCMI_TSC_XGXS_TUNING_SM_CTRL10r_GET
#define TUNING_SM_CTRL10r_RESERVED0f_GET BCMI_TSC_XGXS_TUNING_SM_CTRL10r_RESERVED0f_GET
#define TUNING_SM_CTRL10r_RESERVED0f_SET BCMI_TSC_XGXS_TUNING_SM_CTRL10r_RESERVED0f_SET
#define TUNING_SM_CTRL10r_MSR_SLICER_SLOW_TIMEOUTf_GET BCMI_TSC_XGXS_TUNING_SM_CTRL10r_MSR_SLICER_SLOW_TIMEOUTf_GET
#define TUNING_SM_CTRL10r_MSR_SLICER_SLOW_TIMEOUTf_SET BCMI_TSC_XGXS_TUNING_SM_CTRL10r_MSR_SLICER_SLOW_TIMEOUTf_SET
#define TUNING_SM_CTRL10r_MSR_SLICER_FAST_TIMEOUTf_GET BCMI_TSC_XGXS_TUNING_SM_CTRL10r_MSR_SLICER_FAST_TIMEOUTf_GET
#define TUNING_SM_CTRL10r_MSR_SLICER_FAST_TIMEOUTf_SET BCMI_TSC_XGXS_TUNING_SM_CTRL10r_MSR_SLICER_FAST_TIMEOUTf_SET
#define TUNING_SM_CTRL10r_DEFAULT_TRN2_TIMEOUTf_GET BCMI_TSC_XGXS_TUNING_SM_CTRL10r_DEFAULT_TRN2_TIMEOUTf_GET
#define TUNING_SM_CTRL10r_DEFAULT_TRN2_TIMEOUTf_SET BCMI_TSC_XGXS_TUNING_SM_CTRL10r_DEFAULT_TRN2_TIMEOUTf_SET
#define READ_TUNING_SM_CTRL10r BCMI_TSC_XGXS_READ_TUNING_SM_CTRL10r
#define WRITE_TUNING_SM_CTRL10r BCMI_TSC_XGXS_WRITE_TUNING_SM_CTRL10r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_TUNING_SM_CTRL10r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  TUNING_SM_CTRL11
 * BLOCKS:   DSC4B0
 * REGADDR:  0xc23b
 * DESC:     State Machine Control 11 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     BYPASS_OSX2_SLICER_CAL 
 *     BYPASS_OSX1_SLICER_CAL 
 *     PF_MAX_VAL       
 *     RESERVED1        
 *     PF_FINE_EN       
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_TUNING_SM_CTRL11r (0x0000c23b | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_TUNING_SM_CTRL11r_SIZE 4

/*
 * This structure should be used to declare and program TUNING_SM_CTRL11.
 *
 */
typedef union BCMI_TSC_XGXS_TUNING_SM_CTRL11r_s {
	uint32_t v[1];
	uint32_t tuning_sm_ctrl11[1];
	uint32_t _tuning_sm_ctrl11;
} BCMI_TSC_XGXS_TUNING_SM_CTRL11r_t;

#define BCMI_TSC_XGXS_TUNING_SM_CTRL11r_CLR(r) (r).tuning_sm_ctrl11[0] = 0
#define BCMI_TSC_XGXS_TUNING_SM_CTRL11r_SET(r,d) (r).tuning_sm_ctrl11[0] = d
#define BCMI_TSC_XGXS_TUNING_SM_CTRL11r_GET(r) (r).tuning_sm_ctrl11[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_TUNING_SM_CTRL11r_RESERVED0f_GET(r) ((((r).tuning_sm_ctrl11[0]) >> 8) & 0xff)
#define BCMI_TSC_XGXS_TUNING_SM_CTRL11r_RESERVED0f_SET(r,f) (r).tuning_sm_ctrl11[0]=(((r).tuning_sm_ctrl11[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCMI_TSC_XGXS_TUNING_SM_CTRL11r_PF_FINE_ENf_GET(r) ((((r).tuning_sm_ctrl11[0]) >> 7) & 0x1)
#define BCMI_TSC_XGXS_TUNING_SM_CTRL11r_PF_FINE_ENf_SET(r,f) (r).tuning_sm_ctrl11[0]=(((r).tuning_sm_ctrl11[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCMI_TSC_XGXS_TUNING_SM_CTRL11r_RESERVED1f_GET(r) ((((r).tuning_sm_ctrl11[0]) >> 6) & 0x1)
#define BCMI_TSC_XGXS_TUNING_SM_CTRL11r_RESERVED1f_SET(r,f) (r).tuning_sm_ctrl11[0]=(((r).tuning_sm_ctrl11[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCMI_TSC_XGXS_TUNING_SM_CTRL11r_PF_MAX_VALf_GET(r) ((((r).tuning_sm_ctrl11[0]) >> 2) & 0xf)
#define BCMI_TSC_XGXS_TUNING_SM_CTRL11r_PF_MAX_VALf_SET(r,f) (r).tuning_sm_ctrl11[0]=(((r).tuning_sm_ctrl11[0] & ~((uint32_t)0xf << 2)) | ((((uint32_t)f) & 0xf) << 2))
#define BCMI_TSC_XGXS_TUNING_SM_CTRL11r_BYPASS_OSX1_SLICER_CALf_GET(r) ((((r).tuning_sm_ctrl11[0]) >> 1) & 0x1)
#define BCMI_TSC_XGXS_TUNING_SM_CTRL11r_BYPASS_OSX1_SLICER_CALf_SET(r,f) (r).tuning_sm_ctrl11[0]=(((r).tuning_sm_ctrl11[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCMI_TSC_XGXS_TUNING_SM_CTRL11r_BYPASS_OSX2_SLICER_CALf_GET(r) (((r).tuning_sm_ctrl11[0]) & 0x1)
#define BCMI_TSC_XGXS_TUNING_SM_CTRL11r_BYPASS_OSX2_SLICER_CALf_SET(r,f) (r).tuning_sm_ctrl11[0]=(((r).tuning_sm_ctrl11[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access TUNING_SM_CTRL11.
 *
 */
#define BCMI_TSC_XGXS_READ_TUNING_SM_CTRL11r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_TUNING_SM_CTRL11r,(_r._tuning_sm_ctrl11))
#define BCMI_TSC_XGXS_WRITE_TUNING_SM_CTRL11r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_TUNING_SM_CTRL11r,(_r._tuning_sm_ctrl11))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TUNING_SM_CTRL11r BCMI_TSC_XGXS_TUNING_SM_CTRL11r
#define TUNING_SM_CTRL11r_SIZE BCMI_TSC_XGXS_TUNING_SM_CTRL11r_SIZE
typedef BCMI_TSC_XGXS_TUNING_SM_CTRL11r_t TUNING_SM_CTRL11r_t;
#define TUNING_SM_CTRL11r_CLR BCMI_TSC_XGXS_TUNING_SM_CTRL11r_CLR
#define TUNING_SM_CTRL11r_SET BCMI_TSC_XGXS_TUNING_SM_CTRL11r_SET
#define TUNING_SM_CTRL11r_GET BCMI_TSC_XGXS_TUNING_SM_CTRL11r_GET
#define TUNING_SM_CTRL11r_RESERVED0f_GET BCMI_TSC_XGXS_TUNING_SM_CTRL11r_RESERVED0f_GET
#define TUNING_SM_CTRL11r_RESERVED0f_SET BCMI_TSC_XGXS_TUNING_SM_CTRL11r_RESERVED0f_SET
#define TUNING_SM_CTRL11r_PF_FINE_ENf_GET BCMI_TSC_XGXS_TUNING_SM_CTRL11r_PF_FINE_ENf_GET
#define TUNING_SM_CTRL11r_PF_FINE_ENf_SET BCMI_TSC_XGXS_TUNING_SM_CTRL11r_PF_FINE_ENf_SET
#define TUNING_SM_CTRL11r_RESERVED1f_GET BCMI_TSC_XGXS_TUNING_SM_CTRL11r_RESERVED1f_GET
#define TUNING_SM_CTRL11r_RESERVED1f_SET BCMI_TSC_XGXS_TUNING_SM_CTRL11r_RESERVED1f_SET
#define TUNING_SM_CTRL11r_PF_MAX_VALf_GET BCMI_TSC_XGXS_TUNING_SM_CTRL11r_PF_MAX_VALf_GET
#define TUNING_SM_CTRL11r_PF_MAX_VALf_SET BCMI_TSC_XGXS_TUNING_SM_CTRL11r_PF_MAX_VALf_SET
#define TUNING_SM_CTRL11r_BYPASS_OSX1_SLICER_CALf_GET BCMI_TSC_XGXS_TUNING_SM_CTRL11r_BYPASS_OSX1_SLICER_CALf_GET
#define TUNING_SM_CTRL11r_BYPASS_OSX1_SLICER_CALf_SET BCMI_TSC_XGXS_TUNING_SM_CTRL11r_BYPASS_OSX1_SLICER_CALf_SET
#define TUNING_SM_CTRL11r_BYPASS_OSX2_SLICER_CALf_GET BCMI_TSC_XGXS_TUNING_SM_CTRL11r_BYPASS_OSX2_SLICER_CALf_GET
#define TUNING_SM_CTRL11r_BYPASS_OSX2_SLICER_CALf_SET BCMI_TSC_XGXS_TUNING_SM_CTRL11r_BYPASS_OSX2_SLICER_CALf_SET
#define READ_TUNING_SM_CTRL11r BCMI_TSC_XGXS_READ_TUNING_SM_CTRL11r
#define WRITE_TUNING_SM_CTRL11r BCMI_TSC_XGXS_WRITE_TUNING_SM_CTRL11r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_TUNING_SM_CTRL11r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  ACQ_SM_CTRL9
 * BLOCKS:   DSC4B0
 * REGADDR:  0xc23c
 * DESC:     Acquisition State Machine Control 9 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     EEE_LFSR_CNT     
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_ACQ_SM_CTRL9r (0x0000c23c | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_ACQ_SM_CTRL9r_SIZE 4

/*
 * This structure should be used to declare and program ACQ_SM_CTRL9.
 *
 */
typedef union BCMI_TSC_XGXS_ACQ_SM_CTRL9r_s {
	uint32_t v[1];
	uint32_t acq_sm_ctrl9[1];
	uint32_t _acq_sm_ctrl9;
} BCMI_TSC_XGXS_ACQ_SM_CTRL9r_t;

#define BCMI_TSC_XGXS_ACQ_SM_CTRL9r_CLR(r) (r).acq_sm_ctrl9[0] = 0
#define BCMI_TSC_XGXS_ACQ_SM_CTRL9r_SET(r,d) (r).acq_sm_ctrl9[0] = d
#define BCMI_TSC_XGXS_ACQ_SM_CTRL9r_GET(r) (r).acq_sm_ctrl9[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_ACQ_SM_CTRL9r_RESERVED0f_GET(r) ((((r).acq_sm_ctrl9[0]) >> 13) & 0x7)
#define BCMI_TSC_XGXS_ACQ_SM_CTRL9r_RESERVED0f_SET(r,f) (r).acq_sm_ctrl9[0]=(((r).acq_sm_ctrl9[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))
#define BCMI_TSC_XGXS_ACQ_SM_CTRL9r_EEE_LFSR_CNTf_GET(r) (((r).acq_sm_ctrl9[0]) & 0x1fff)
#define BCMI_TSC_XGXS_ACQ_SM_CTRL9r_EEE_LFSR_CNTf_SET(r,f) (r).acq_sm_ctrl9[0]=(((r).acq_sm_ctrl9[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))

/*
 * These macros can be used to access ACQ_SM_CTRL9.
 *
 */
#define BCMI_TSC_XGXS_READ_ACQ_SM_CTRL9r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_ACQ_SM_CTRL9r,(_r._acq_sm_ctrl9))
#define BCMI_TSC_XGXS_WRITE_ACQ_SM_CTRL9r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_ACQ_SM_CTRL9r,(_r._acq_sm_ctrl9))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define ACQ_SM_CTRL9r BCMI_TSC_XGXS_ACQ_SM_CTRL9r
#define ACQ_SM_CTRL9r_SIZE BCMI_TSC_XGXS_ACQ_SM_CTRL9r_SIZE
typedef BCMI_TSC_XGXS_ACQ_SM_CTRL9r_t ACQ_SM_CTRL9r_t;
#define ACQ_SM_CTRL9r_CLR BCMI_TSC_XGXS_ACQ_SM_CTRL9r_CLR
#define ACQ_SM_CTRL9r_SET BCMI_TSC_XGXS_ACQ_SM_CTRL9r_SET
#define ACQ_SM_CTRL9r_GET BCMI_TSC_XGXS_ACQ_SM_CTRL9r_GET
#define ACQ_SM_CTRL9r_RESERVED0f_GET BCMI_TSC_XGXS_ACQ_SM_CTRL9r_RESERVED0f_GET
#define ACQ_SM_CTRL9r_RESERVED0f_SET BCMI_TSC_XGXS_ACQ_SM_CTRL9r_RESERVED0f_SET
#define ACQ_SM_CTRL9r_EEE_LFSR_CNTf_GET BCMI_TSC_XGXS_ACQ_SM_CTRL9r_EEE_LFSR_CNTf_GET
#define ACQ_SM_CTRL9r_EEE_LFSR_CNTf_SET BCMI_TSC_XGXS_ACQ_SM_CTRL9r_EEE_LFSR_CNTf_SET
#define READ_ACQ_SM_CTRL9r BCMI_TSC_XGXS_READ_ACQ_SM_CTRL9r
#define WRITE_ACQ_SM_CTRL9r BCMI_TSC_XGXS_WRITE_ACQ_SM_CTRL9r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_ACQ_SM_CTRL9r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  TUNING_SM_STATUS0
 * BLOCKS:   DSC5B0
 * REGADDR:  0xc240
 * DESC:     State Machine Status 0 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     DSC_STATE        
 *     TUNING_STATE     
 *     SRCH_STATE       
 *     TUNING_DONE      
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_TUNING_SM_STATUS0r (0x0000c240 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_TUNING_SM_STATUS0r_SIZE 4

/*
 * This structure should be used to declare and program TUNING_SM_STATUS0.
 *
 */
typedef union BCMI_TSC_XGXS_TUNING_SM_STATUS0r_s {
	uint32_t v[1];
	uint32_t tuning_sm_status0[1];
	uint32_t _tuning_sm_status0;
} BCMI_TSC_XGXS_TUNING_SM_STATUS0r_t;

#define BCMI_TSC_XGXS_TUNING_SM_STATUS0r_CLR(r) (r).tuning_sm_status0[0] = 0
#define BCMI_TSC_XGXS_TUNING_SM_STATUS0r_SET(r,d) (r).tuning_sm_status0[0] = d
#define BCMI_TSC_XGXS_TUNING_SM_STATUS0r_GET(r) (r).tuning_sm_status0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_TUNING_SM_STATUS0r_RESERVED0f_GET(r) ((((r).tuning_sm_status0[0]) >> 14) & 0x3)
#define BCMI_TSC_XGXS_TUNING_SM_STATUS0r_RESERVED0f_SET(r,f) (r).tuning_sm_status0[0]=(((r).tuning_sm_status0[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCMI_TSC_XGXS_TUNING_SM_STATUS0r_TUNING_DONEf_GET(r) ((((r).tuning_sm_status0[0]) >> 13) & 0x1)
#define BCMI_TSC_XGXS_TUNING_SM_STATUS0r_TUNING_DONEf_SET(r,f) (r).tuning_sm_status0[0]=(((r).tuning_sm_status0[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCMI_TSC_XGXS_TUNING_SM_STATUS0r_SRCH_STATEf_GET(r) ((((r).tuning_sm_status0[0]) >> 9) & 0xf)
#define BCMI_TSC_XGXS_TUNING_SM_STATUS0r_SRCH_STATEf_SET(r,f) (r).tuning_sm_status0[0]=(((r).tuning_sm_status0[0] & ~((uint32_t)0xf << 9)) | ((((uint32_t)f) & 0xf) << 9))
#define BCMI_TSC_XGXS_TUNING_SM_STATUS0r_TUNING_STATEf_GET(r) ((((r).tuning_sm_status0[0]) >> 4) & 0x1f)
#define BCMI_TSC_XGXS_TUNING_SM_STATUS0r_TUNING_STATEf_SET(r,f) (r).tuning_sm_status0[0]=(((r).tuning_sm_status0[0] & ~((uint32_t)0x1f << 4)) | ((((uint32_t)f) & 0x1f) << 4))
#define BCMI_TSC_XGXS_TUNING_SM_STATUS0r_DSC_STATEf_GET(r) (((r).tuning_sm_status0[0]) & 0xf)
#define BCMI_TSC_XGXS_TUNING_SM_STATUS0r_DSC_STATEf_SET(r,f) (r).tuning_sm_status0[0]=(((r).tuning_sm_status0[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access TUNING_SM_STATUS0.
 *
 */
#define BCMI_TSC_XGXS_READ_TUNING_SM_STATUS0r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_TUNING_SM_STATUS0r,(_r._tuning_sm_status0))
#define BCMI_TSC_XGXS_WRITE_TUNING_SM_STATUS0r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_TUNING_SM_STATUS0r,(_r._tuning_sm_status0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TUNING_SM_STATUS0r BCMI_TSC_XGXS_TUNING_SM_STATUS0r
#define TUNING_SM_STATUS0r_SIZE BCMI_TSC_XGXS_TUNING_SM_STATUS0r_SIZE
typedef BCMI_TSC_XGXS_TUNING_SM_STATUS0r_t TUNING_SM_STATUS0r_t;
#define TUNING_SM_STATUS0r_CLR BCMI_TSC_XGXS_TUNING_SM_STATUS0r_CLR
#define TUNING_SM_STATUS0r_SET BCMI_TSC_XGXS_TUNING_SM_STATUS0r_SET
#define TUNING_SM_STATUS0r_GET BCMI_TSC_XGXS_TUNING_SM_STATUS0r_GET
#define TUNING_SM_STATUS0r_RESERVED0f_GET BCMI_TSC_XGXS_TUNING_SM_STATUS0r_RESERVED0f_GET
#define TUNING_SM_STATUS0r_RESERVED0f_SET BCMI_TSC_XGXS_TUNING_SM_STATUS0r_RESERVED0f_SET
#define TUNING_SM_STATUS0r_TUNING_DONEf_GET BCMI_TSC_XGXS_TUNING_SM_STATUS0r_TUNING_DONEf_GET
#define TUNING_SM_STATUS0r_TUNING_DONEf_SET BCMI_TSC_XGXS_TUNING_SM_STATUS0r_TUNING_DONEf_SET
#define TUNING_SM_STATUS0r_SRCH_STATEf_GET BCMI_TSC_XGXS_TUNING_SM_STATUS0r_SRCH_STATEf_GET
#define TUNING_SM_STATUS0r_SRCH_STATEf_SET BCMI_TSC_XGXS_TUNING_SM_STATUS0r_SRCH_STATEf_SET
#define TUNING_SM_STATUS0r_TUNING_STATEf_GET BCMI_TSC_XGXS_TUNING_SM_STATUS0r_TUNING_STATEf_GET
#define TUNING_SM_STATUS0r_TUNING_STATEf_SET BCMI_TSC_XGXS_TUNING_SM_STATUS0r_TUNING_STATEf_SET
#define TUNING_SM_STATUS0r_DSC_STATEf_GET BCMI_TSC_XGXS_TUNING_SM_STATUS0r_DSC_STATEf_GET
#define TUNING_SM_STATUS0r_DSC_STATEf_SET BCMI_TSC_XGXS_TUNING_SM_STATUS0r_DSC_STATEf_SET
#define READ_TUNING_SM_STATUS0r BCMI_TSC_XGXS_READ_TUNING_SM_STATUS0r
#define WRITE_TUNING_SM_STATUS0r BCMI_TSC_XGXS_WRITE_TUNING_SM_STATUS0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_TUNING_SM_STATUS0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  TUNING_SM_STATUS1
 * BLOCKS:   DSC5B0
 * REGADDR:  0xc241
 * DESC:     State Machine Status 1 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     POSTC_METRIC     
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_TUNING_SM_STATUS1r (0x0000c241 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_TUNING_SM_STATUS1r_SIZE 4

/*
 * This structure should be used to declare and program TUNING_SM_STATUS1.
 *
 */
typedef union BCMI_TSC_XGXS_TUNING_SM_STATUS1r_s {
	uint32_t v[1];
	uint32_t tuning_sm_status1[1];
	uint32_t _tuning_sm_status1;
} BCMI_TSC_XGXS_TUNING_SM_STATUS1r_t;

#define BCMI_TSC_XGXS_TUNING_SM_STATUS1r_CLR(r) (r).tuning_sm_status1[0] = 0
#define BCMI_TSC_XGXS_TUNING_SM_STATUS1r_SET(r,d) (r).tuning_sm_status1[0] = d
#define BCMI_TSC_XGXS_TUNING_SM_STATUS1r_GET(r) (r).tuning_sm_status1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_TUNING_SM_STATUS1r_RESERVED0f_GET(r) ((((r).tuning_sm_status1[0]) >> 11) & 0x1f)
#define BCMI_TSC_XGXS_TUNING_SM_STATUS1r_RESERVED0f_SET(r,f) (r).tuning_sm_status1[0]=(((r).tuning_sm_status1[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))
#define BCMI_TSC_XGXS_TUNING_SM_STATUS1r_POSTC_METRICf_GET(r) (((r).tuning_sm_status1[0]) & 0x7ff)
#define BCMI_TSC_XGXS_TUNING_SM_STATUS1r_POSTC_METRICf_SET(r,f) (r).tuning_sm_status1[0]=(((r).tuning_sm_status1[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))

/*
 * These macros can be used to access TUNING_SM_STATUS1.
 *
 */
#define BCMI_TSC_XGXS_READ_TUNING_SM_STATUS1r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_TUNING_SM_STATUS1r,(_r._tuning_sm_status1))
#define BCMI_TSC_XGXS_WRITE_TUNING_SM_STATUS1r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_TUNING_SM_STATUS1r,(_r._tuning_sm_status1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TUNING_SM_STATUS1r BCMI_TSC_XGXS_TUNING_SM_STATUS1r
#define TUNING_SM_STATUS1r_SIZE BCMI_TSC_XGXS_TUNING_SM_STATUS1r_SIZE
typedef BCMI_TSC_XGXS_TUNING_SM_STATUS1r_t TUNING_SM_STATUS1r_t;
#define TUNING_SM_STATUS1r_CLR BCMI_TSC_XGXS_TUNING_SM_STATUS1r_CLR
#define TUNING_SM_STATUS1r_SET BCMI_TSC_XGXS_TUNING_SM_STATUS1r_SET
#define TUNING_SM_STATUS1r_GET BCMI_TSC_XGXS_TUNING_SM_STATUS1r_GET
#define TUNING_SM_STATUS1r_RESERVED0f_GET BCMI_TSC_XGXS_TUNING_SM_STATUS1r_RESERVED0f_GET
#define TUNING_SM_STATUS1r_RESERVED0f_SET BCMI_TSC_XGXS_TUNING_SM_STATUS1r_RESERVED0f_SET
#define TUNING_SM_STATUS1r_POSTC_METRICf_GET BCMI_TSC_XGXS_TUNING_SM_STATUS1r_POSTC_METRICf_GET
#define TUNING_SM_STATUS1r_POSTC_METRICf_SET BCMI_TSC_XGXS_TUNING_SM_STATUS1r_POSTC_METRICf_SET
#define READ_TUNING_SM_STATUS1r BCMI_TSC_XGXS_READ_TUNING_SM_STATUS1r
#define WRITE_TUNING_SM_STATUS1r BCMI_TSC_XGXS_WRITE_TUNING_SM_STATUS1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_TUNING_SM_STATUS1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  TUNING_SM_STATUS2
 * BLOCKS:   DSC5B0
 * REGADDR:  0xc242
 * DESC:     State Machine Status 2 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     PF_MIN           
 *     PF_MAX           
 *     VGA_MIN          
 *     VGA_MAX          
 *     DFE_MIN          
 *     DFE_MAX          
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_TUNING_SM_STATUS2r (0x0000c242 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_TUNING_SM_STATUS2r_SIZE 4

/*
 * This structure should be used to declare and program TUNING_SM_STATUS2.
 *
 */
typedef union BCMI_TSC_XGXS_TUNING_SM_STATUS2r_s {
	uint32_t v[1];
	uint32_t tuning_sm_status2[1];
	uint32_t _tuning_sm_status2;
} BCMI_TSC_XGXS_TUNING_SM_STATUS2r_t;

#define BCMI_TSC_XGXS_TUNING_SM_STATUS2r_CLR(r) (r).tuning_sm_status2[0] = 0
#define BCMI_TSC_XGXS_TUNING_SM_STATUS2r_SET(r,d) (r).tuning_sm_status2[0] = d
#define BCMI_TSC_XGXS_TUNING_SM_STATUS2r_GET(r) (r).tuning_sm_status2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_TUNING_SM_STATUS2r_RESERVED0f_GET(r) ((((r).tuning_sm_status2[0]) >> 6) & 0x3ff)
#define BCMI_TSC_XGXS_TUNING_SM_STATUS2r_RESERVED0f_SET(r,f) (r).tuning_sm_status2[0]=(((r).tuning_sm_status2[0] & ~((uint32_t)0x3ff << 6)) | ((((uint32_t)f) & 0x3ff) << 6))
#define BCMI_TSC_XGXS_TUNING_SM_STATUS2r_DFE_MAXf_GET(r) ((((r).tuning_sm_status2[0]) >> 5) & 0x1)
#define BCMI_TSC_XGXS_TUNING_SM_STATUS2r_DFE_MAXf_SET(r,f) (r).tuning_sm_status2[0]=(((r).tuning_sm_status2[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCMI_TSC_XGXS_TUNING_SM_STATUS2r_DFE_MINf_GET(r) ((((r).tuning_sm_status2[0]) >> 4) & 0x1)
#define BCMI_TSC_XGXS_TUNING_SM_STATUS2r_DFE_MINf_SET(r,f) (r).tuning_sm_status2[0]=(((r).tuning_sm_status2[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCMI_TSC_XGXS_TUNING_SM_STATUS2r_VGA_MAXf_GET(r) ((((r).tuning_sm_status2[0]) >> 3) & 0x1)
#define BCMI_TSC_XGXS_TUNING_SM_STATUS2r_VGA_MAXf_SET(r,f) (r).tuning_sm_status2[0]=(((r).tuning_sm_status2[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCMI_TSC_XGXS_TUNING_SM_STATUS2r_VGA_MINf_GET(r) ((((r).tuning_sm_status2[0]) >> 2) & 0x1)
#define BCMI_TSC_XGXS_TUNING_SM_STATUS2r_VGA_MINf_SET(r,f) (r).tuning_sm_status2[0]=(((r).tuning_sm_status2[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCMI_TSC_XGXS_TUNING_SM_STATUS2r_PF_MAXf_GET(r) ((((r).tuning_sm_status2[0]) >> 1) & 0x1)
#define BCMI_TSC_XGXS_TUNING_SM_STATUS2r_PF_MAXf_SET(r,f) (r).tuning_sm_status2[0]=(((r).tuning_sm_status2[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCMI_TSC_XGXS_TUNING_SM_STATUS2r_PF_MINf_GET(r) (((r).tuning_sm_status2[0]) & 0x1)
#define BCMI_TSC_XGXS_TUNING_SM_STATUS2r_PF_MINf_SET(r,f) (r).tuning_sm_status2[0]=(((r).tuning_sm_status2[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access TUNING_SM_STATUS2.
 *
 */
#define BCMI_TSC_XGXS_READ_TUNING_SM_STATUS2r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_TUNING_SM_STATUS2r,(_r._tuning_sm_status2))
#define BCMI_TSC_XGXS_WRITE_TUNING_SM_STATUS2r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_TUNING_SM_STATUS2r,(_r._tuning_sm_status2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TUNING_SM_STATUS2r BCMI_TSC_XGXS_TUNING_SM_STATUS2r
#define TUNING_SM_STATUS2r_SIZE BCMI_TSC_XGXS_TUNING_SM_STATUS2r_SIZE
typedef BCMI_TSC_XGXS_TUNING_SM_STATUS2r_t TUNING_SM_STATUS2r_t;
#define TUNING_SM_STATUS2r_CLR BCMI_TSC_XGXS_TUNING_SM_STATUS2r_CLR
#define TUNING_SM_STATUS2r_SET BCMI_TSC_XGXS_TUNING_SM_STATUS2r_SET
#define TUNING_SM_STATUS2r_GET BCMI_TSC_XGXS_TUNING_SM_STATUS2r_GET
#define TUNING_SM_STATUS2r_RESERVED0f_GET BCMI_TSC_XGXS_TUNING_SM_STATUS2r_RESERVED0f_GET
#define TUNING_SM_STATUS2r_RESERVED0f_SET BCMI_TSC_XGXS_TUNING_SM_STATUS2r_RESERVED0f_SET
#define TUNING_SM_STATUS2r_DFE_MAXf_GET BCMI_TSC_XGXS_TUNING_SM_STATUS2r_DFE_MAXf_GET
#define TUNING_SM_STATUS2r_DFE_MAXf_SET BCMI_TSC_XGXS_TUNING_SM_STATUS2r_DFE_MAXf_SET
#define TUNING_SM_STATUS2r_DFE_MINf_GET BCMI_TSC_XGXS_TUNING_SM_STATUS2r_DFE_MINf_GET
#define TUNING_SM_STATUS2r_DFE_MINf_SET BCMI_TSC_XGXS_TUNING_SM_STATUS2r_DFE_MINf_SET
#define TUNING_SM_STATUS2r_VGA_MAXf_GET BCMI_TSC_XGXS_TUNING_SM_STATUS2r_VGA_MAXf_GET
#define TUNING_SM_STATUS2r_VGA_MAXf_SET BCMI_TSC_XGXS_TUNING_SM_STATUS2r_VGA_MAXf_SET
#define TUNING_SM_STATUS2r_VGA_MINf_GET BCMI_TSC_XGXS_TUNING_SM_STATUS2r_VGA_MINf_GET
#define TUNING_SM_STATUS2r_VGA_MINf_SET BCMI_TSC_XGXS_TUNING_SM_STATUS2r_VGA_MINf_SET
#define TUNING_SM_STATUS2r_PF_MAXf_GET BCMI_TSC_XGXS_TUNING_SM_STATUS2r_PF_MAXf_GET
#define TUNING_SM_STATUS2r_PF_MAXf_SET BCMI_TSC_XGXS_TUNING_SM_STATUS2r_PF_MAXf_SET
#define TUNING_SM_STATUS2r_PF_MINf_GET BCMI_TSC_XGXS_TUNING_SM_STATUS2r_PF_MINf_GET
#define TUNING_SM_STATUS2r_PF_MINf_SET BCMI_TSC_XGXS_TUNING_SM_STATUS2r_PF_MINf_SET
#define READ_TUNING_SM_STATUS2r BCMI_TSC_XGXS_READ_TUNING_SM_STATUS2r
#define WRITE_TUNING_SM_STATUS2r BCMI_TSC_XGXS_WRITE_TUNING_SM_STATUS2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_TUNING_SM_STATUS2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  TUNING_SM_STATUS3
 * BLOCKS:   DSC5B0
 * REGADDR:  0xc243
 * DESC:     State Machine Status 3 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     TRNSUM_BR_VGA    
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_TUNING_SM_STATUS3r (0x0000c243 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_TUNING_SM_STATUS3r_SIZE 4

/*
 * This structure should be used to declare and program TUNING_SM_STATUS3.
 *
 */
typedef union BCMI_TSC_XGXS_TUNING_SM_STATUS3r_s {
	uint32_t v[1];
	uint32_t tuning_sm_status3[1];
	uint32_t _tuning_sm_status3;
} BCMI_TSC_XGXS_TUNING_SM_STATUS3r_t;

#define BCMI_TSC_XGXS_TUNING_SM_STATUS3r_CLR(r) (r).tuning_sm_status3[0] = 0
#define BCMI_TSC_XGXS_TUNING_SM_STATUS3r_SET(r,d) (r).tuning_sm_status3[0] = d
#define BCMI_TSC_XGXS_TUNING_SM_STATUS3r_GET(r) (r).tuning_sm_status3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_TUNING_SM_STATUS3r_RESERVED0f_GET(r) ((((r).tuning_sm_status3[0]) >> 11) & 0x1f)
#define BCMI_TSC_XGXS_TUNING_SM_STATUS3r_RESERVED0f_SET(r,f) (r).tuning_sm_status3[0]=(((r).tuning_sm_status3[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))
#define BCMI_TSC_XGXS_TUNING_SM_STATUS3r_TRNSUM_BR_VGAf_GET(r) (((r).tuning_sm_status3[0]) & 0x7ff)
#define BCMI_TSC_XGXS_TUNING_SM_STATUS3r_TRNSUM_BR_VGAf_SET(r,f) (r).tuning_sm_status3[0]=(((r).tuning_sm_status3[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))

/*
 * These macros can be used to access TUNING_SM_STATUS3.
 *
 */
#define BCMI_TSC_XGXS_READ_TUNING_SM_STATUS3r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_TUNING_SM_STATUS3r,(_r._tuning_sm_status3))
#define BCMI_TSC_XGXS_WRITE_TUNING_SM_STATUS3r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_TUNING_SM_STATUS3r,(_r._tuning_sm_status3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TUNING_SM_STATUS3r BCMI_TSC_XGXS_TUNING_SM_STATUS3r
#define TUNING_SM_STATUS3r_SIZE BCMI_TSC_XGXS_TUNING_SM_STATUS3r_SIZE
typedef BCMI_TSC_XGXS_TUNING_SM_STATUS3r_t TUNING_SM_STATUS3r_t;
#define TUNING_SM_STATUS3r_CLR BCMI_TSC_XGXS_TUNING_SM_STATUS3r_CLR
#define TUNING_SM_STATUS3r_SET BCMI_TSC_XGXS_TUNING_SM_STATUS3r_SET
#define TUNING_SM_STATUS3r_GET BCMI_TSC_XGXS_TUNING_SM_STATUS3r_GET
#define TUNING_SM_STATUS3r_RESERVED0f_GET BCMI_TSC_XGXS_TUNING_SM_STATUS3r_RESERVED0f_GET
#define TUNING_SM_STATUS3r_RESERVED0f_SET BCMI_TSC_XGXS_TUNING_SM_STATUS3r_RESERVED0f_SET
#define TUNING_SM_STATUS3r_TRNSUM_BR_VGAf_GET BCMI_TSC_XGXS_TUNING_SM_STATUS3r_TRNSUM_BR_VGAf_GET
#define TUNING_SM_STATUS3r_TRNSUM_BR_VGAf_SET BCMI_TSC_XGXS_TUNING_SM_STATUS3r_TRNSUM_BR_VGAf_SET
#define READ_TUNING_SM_STATUS3r BCMI_TSC_XGXS_READ_TUNING_SM_STATUS3r
#define WRITE_TUNING_SM_STATUS3r BCMI_TSC_XGXS_WRITE_TUNING_SM_STATUS3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_TUNING_SM_STATUS3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  TUNING_SM_STATUS4
 * BLOCKS:   DSC5B0
 * REGADDR:  0xc244
 * DESC:     State Machine Status 4 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     TRNSUM_PF        
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_TUNING_SM_STATUS4r (0x0000c244 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_TUNING_SM_STATUS4r_SIZE 4

/*
 * This structure should be used to declare and program TUNING_SM_STATUS4.
 *
 */
typedef union BCMI_TSC_XGXS_TUNING_SM_STATUS4r_s {
	uint32_t v[1];
	uint32_t tuning_sm_status4[1];
	uint32_t _tuning_sm_status4;
} BCMI_TSC_XGXS_TUNING_SM_STATUS4r_t;

#define BCMI_TSC_XGXS_TUNING_SM_STATUS4r_CLR(r) (r).tuning_sm_status4[0] = 0
#define BCMI_TSC_XGXS_TUNING_SM_STATUS4r_SET(r,d) (r).tuning_sm_status4[0] = d
#define BCMI_TSC_XGXS_TUNING_SM_STATUS4r_GET(r) (r).tuning_sm_status4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_TUNING_SM_STATUS4r_RESERVED0f_GET(r) ((((r).tuning_sm_status4[0]) >> 11) & 0x1f)
#define BCMI_TSC_XGXS_TUNING_SM_STATUS4r_RESERVED0f_SET(r,f) (r).tuning_sm_status4[0]=(((r).tuning_sm_status4[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))
#define BCMI_TSC_XGXS_TUNING_SM_STATUS4r_TRNSUM_PFf_GET(r) (((r).tuning_sm_status4[0]) & 0x7ff)
#define BCMI_TSC_XGXS_TUNING_SM_STATUS4r_TRNSUM_PFf_SET(r,f) (r).tuning_sm_status4[0]=(((r).tuning_sm_status4[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))

/*
 * These macros can be used to access TUNING_SM_STATUS4.
 *
 */
#define BCMI_TSC_XGXS_READ_TUNING_SM_STATUS4r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_TUNING_SM_STATUS4r,(_r._tuning_sm_status4))
#define BCMI_TSC_XGXS_WRITE_TUNING_SM_STATUS4r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_TUNING_SM_STATUS4r,(_r._tuning_sm_status4))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TUNING_SM_STATUS4r BCMI_TSC_XGXS_TUNING_SM_STATUS4r
#define TUNING_SM_STATUS4r_SIZE BCMI_TSC_XGXS_TUNING_SM_STATUS4r_SIZE
typedef BCMI_TSC_XGXS_TUNING_SM_STATUS4r_t TUNING_SM_STATUS4r_t;
#define TUNING_SM_STATUS4r_CLR BCMI_TSC_XGXS_TUNING_SM_STATUS4r_CLR
#define TUNING_SM_STATUS4r_SET BCMI_TSC_XGXS_TUNING_SM_STATUS4r_SET
#define TUNING_SM_STATUS4r_GET BCMI_TSC_XGXS_TUNING_SM_STATUS4r_GET
#define TUNING_SM_STATUS4r_RESERVED0f_GET BCMI_TSC_XGXS_TUNING_SM_STATUS4r_RESERVED0f_GET
#define TUNING_SM_STATUS4r_RESERVED0f_SET BCMI_TSC_XGXS_TUNING_SM_STATUS4r_RESERVED0f_SET
#define TUNING_SM_STATUS4r_TRNSUM_PFf_GET BCMI_TSC_XGXS_TUNING_SM_STATUS4r_TRNSUM_PFf_GET
#define TUNING_SM_STATUS4r_TRNSUM_PFf_SET BCMI_TSC_XGXS_TUNING_SM_STATUS4r_TRNSUM_PFf_SET
#define READ_TUNING_SM_STATUS4r BCMI_TSC_XGXS_READ_TUNING_SM_STATUS4r
#define WRITE_TUNING_SM_STATUS4r BCMI_TSC_XGXS_WRITE_TUNING_SM_STATUS4r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_TUNING_SM_STATUS4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  TUNING_SM_STATUS5
 * BLOCKS:   DSC5B0
 * REGADDR:  0xc245
 * DESC:     State Machine Status 5 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     TUNING_STATE_WAIT_FOR_LOCK 
 *     TUNING_STATE_OS_SLICER_DE 
 *     TUNING_STATE_OS_SLICER_DO 
 *     TUNING_STATE_OS_SLICER_ME 
 *     TUNING_STATE_OS_SLICER_MO 
 *     TUNING_STATE_OS_PF 
 *     TUNING_STATE_OS_TX_POSTC 
 *     TUNING_STATE_BR_SLICER_DE 
 *     TUNING_STATE_BR_SLICER_DO 
 *     TUNING_STATE_BR_SLICER_ME 
 *     TUNING_STATE_BR_SLICER_MO 
 *     TUNING_STATE_BR_SLICER_PE 
 *     TUNING_STATE_BR_SLICER_PO 
 *     TUNING_STATE_BR_VGA 
 *     TUNING_STATE_BR_PF 
 *     TUNING_STATE_BR_TX_POSTC 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_TUNING_SM_STATUS5r (0x0000c245 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_TUNING_SM_STATUS5r_SIZE 4

/*
 * This structure should be used to declare and program TUNING_SM_STATUS5.
 *
 */
typedef union BCMI_TSC_XGXS_TUNING_SM_STATUS5r_s {
	uint32_t v[1];
	uint32_t tuning_sm_status5[1];
	uint32_t _tuning_sm_status5;
} BCMI_TSC_XGXS_TUNING_SM_STATUS5r_t;

#define BCMI_TSC_XGXS_TUNING_SM_STATUS5r_CLR(r) (r).tuning_sm_status5[0] = 0
#define BCMI_TSC_XGXS_TUNING_SM_STATUS5r_SET(r,d) (r).tuning_sm_status5[0] = d
#define BCMI_TSC_XGXS_TUNING_SM_STATUS5r_GET(r) (r).tuning_sm_status5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_TUNING_SM_STATUS5r_TUNING_STATE_BR_TX_POSTCf_GET(r) ((((r).tuning_sm_status5[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_TUNING_SM_STATUS5r_TUNING_STATE_BR_TX_POSTCf_SET(r,f) (r).tuning_sm_status5[0]=(((r).tuning_sm_status5[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_TUNING_SM_STATUS5r_TUNING_STATE_BR_PFf_GET(r) ((((r).tuning_sm_status5[0]) >> 14) & 0x1)
#define BCMI_TSC_XGXS_TUNING_SM_STATUS5r_TUNING_STATE_BR_PFf_SET(r,f) (r).tuning_sm_status5[0]=(((r).tuning_sm_status5[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCMI_TSC_XGXS_TUNING_SM_STATUS5r_TUNING_STATE_BR_VGAf_GET(r) ((((r).tuning_sm_status5[0]) >> 13) & 0x1)
#define BCMI_TSC_XGXS_TUNING_SM_STATUS5r_TUNING_STATE_BR_VGAf_SET(r,f) (r).tuning_sm_status5[0]=(((r).tuning_sm_status5[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCMI_TSC_XGXS_TUNING_SM_STATUS5r_TUNING_STATE_BR_SLICER_POf_GET(r) ((((r).tuning_sm_status5[0]) >> 12) & 0x1)
#define BCMI_TSC_XGXS_TUNING_SM_STATUS5r_TUNING_STATE_BR_SLICER_POf_SET(r,f) (r).tuning_sm_status5[0]=(((r).tuning_sm_status5[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCMI_TSC_XGXS_TUNING_SM_STATUS5r_TUNING_STATE_BR_SLICER_PEf_GET(r) ((((r).tuning_sm_status5[0]) >> 11) & 0x1)
#define BCMI_TSC_XGXS_TUNING_SM_STATUS5r_TUNING_STATE_BR_SLICER_PEf_SET(r,f) (r).tuning_sm_status5[0]=(((r).tuning_sm_status5[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCMI_TSC_XGXS_TUNING_SM_STATUS5r_TUNING_STATE_BR_SLICER_MOf_GET(r) ((((r).tuning_sm_status5[0]) >> 10) & 0x1)
#define BCMI_TSC_XGXS_TUNING_SM_STATUS5r_TUNING_STATE_BR_SLICER_MOf_SET(r,f) (r).tuning_sm_status5[0]=(((r).tuning_sm_status5[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCMI_TSC_XGXS_TUNING_SM_STATUS5r_TUNING_STATE_BR_SLICER_MEf_GET(r) ((((r).tuning_sm_status5[0]) >> 9) & 0x1)
#define BCMI_TSC_XGXS_TUNING_SM_STATUS5r_TUNING_STATE_BR_SLICER_MEf_SET(r,f) (r).tuning_sm_status5[0]=(((r).tuning_sm_status5[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCMI_TSC_XGXS_TUNING_SM_STATUS5r_TUNING_STATE_BR_SLICER_DOf_GET(r) ((((r).tuning_sm_status5[0]) >> 8) & 0x1)
#define BCMI_TSC_XGXS_TUNING_SM_STATUS5r_TUNING_STATE_BR_SLICER_DOf_SET(r,f) (r).tuning_sm_status5[0]=(((r).tuning_sm_status5[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCMI_TSC_XGXS_TUNING_SM_STATUS5r_TUNING_STATE_BR_SLICER_DEf_GET(r) ((((r).tuning_sm_status5[0]) >> 7) & 0x1)
#define BCMI_TSC_XGXS_TUNING_SM_STATUS5r_TUNING_STATE_BR_SLICER_DEf_SET(r,f) (r).tuning_sm_status5[0]=(((r).tuning_sm_status5[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCMI_TSC_XGXS_TUNING_SM_STATUS5r_TUNING_STATE_OS_TX_POSTCf_GET(r) ((((r).tuning_sm_status5[0]) >> 6) & 0x1)
#define BCMI_TSC_XGXS_TUNING_SM_STATUS5r_TUNING_STATE_OS_TX_POSTCf_SET(r,f) (r).tuning_sm_status5[0]=(((r).tuning_sm_status5[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCMI_TSC_XGXS_TUNING_SM_STATUS5r_TUNING_STATE_OS_PFf_GET(r) ((((r).tuning_sm_status5[0]) >> 5) & 0x1)
#define BCMI_TSC_XGXS_TUNING_SM_STATUS5r_TUNING_STATE_OS_PFf_SET(r,f) (r).tuning_sm_status5[0]=(((r).tuning_sm_status5[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCMI_TSC_XGXS_TUNING_SM_STATUS5r_TUNING_STATE_OS_SLICER_MOf_GET(r) ((((r).tuning_sm_status5[0]) >> 4) & 0x1)
#define BCMI_TSC_XGXS_TUNING_SM_STATUS5r_TUNING_STATE_OS_SLICER_MOf_SET(r,f) (r).tuning_sm_status5[0]=(((r).tuning_sm_status5[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCMI_TSC_XGXS_TUNING_SM_STATUS5r_TUNING_STATE_OS_SLICER_MEf_GET(r) ((((r).tuning_sm_status5[0]) >> 3) & 0x1)
#define BCMI_TSC_XGXS_TUNING_SM_STATUS5r_TUNING_STATE_OS_SLICER_MEf_SET(r,f) (r).tuning_sm_status5[0]=(((r).tuning_sm_status5[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCMI_TSC_XGXS_TUNING_SM_STATUS5r_TUNING_STATE_OS_SLICER_DOf_GET(r) ((((r).tuning_sm_status5[0]) >> 2) & 0x1)
#define BCMI_TSC_XGXS_TUNING_SM_STATUS5r_TUNING_STATE_OS_SLICER_DOf_SET(r,f) (r).tuning_sm_status5[0]=(((r).tuning_sm_status5[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCMI_TSC_XGXS_TUNING_SM_STATUS5r_TUNING_STATE_OS_SLICER_DEf_GET(r) ((((r).tuning_sm_status5[0]) >> 1) & 0x1)
#define BCMI_TSC_XGXS_TUNING_SM_STATUS5r_TUNING_STATE_OS_SLICER_DEf_SET(r,f) (r).tuning_sm_status5[0]=(((r).tuning_sm_status5[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCMI_TSC_XGXS_TUNING_SM_STATUS5r_TUNING_STATE_WAIT_FOR_LOCKf_GET(r) (((r).tuning_sm_status5[0]) & 0x1)
#define BCMI_TSC_XGXS_TUNING_SM_STATUS5r_TUNING_STATE_WAIT_FOR_LOCKf_SET(r,f) (r).tuning_sm_status5[0]=(((r).tuning_sm_status5[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access TUNING_SM_STATUS5.
 *
 */
#define BCMI_TSC_XGXS_READ_TUNING_SM_STATUS5r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_TUNING_SM_STATUS5r,(_r._tuning_sm_status5))
#define BCMI_TSC_XGXS_WRITE_TUNING_SM_STATUS5r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_TUNING_SM_STATUS5r,(_r._tuning_sm_status5))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TUNING_SM_STATUS5r BCMI_TSC_XGXS_TUNING_SM_STATUS5r
#define TUNING_SM_STATUS5r_SIZE BCMI_TSC_XGXS_TUNING_SM_STATUS5r_SIZE
typedef BCMI_TSC_XGXS_TUNING_SM_STATUS5r_t TUNING_SM_STATUS5r_t;
#define TUNING_SM_STATUS5r_CLR BCMI_TSC_XGXS_TUNING_SM_STATUS5r_CLR
#define TUNING_SM_STATUS5r_SET BCMI_TSC_XGXS_TUNING_SM_STATUS5r_SET
#define TUNING_SM_STATUS5r_GET BCMI_TSC_XGXS_TUNING_SM_STATUS5r_GET
#define TUNING_SM_STATUS5r_TUNING_STATE_BR_TX_POSTCf_GET BCMI_TSC_XGXS_TUNING_SM_STATUS5r_TUNING_STATE_BR_TX_POSTCf_GET
#define TUNING_SM_STATUS5r_TUNING_STATE_BR_TX_POSTCf_SET BCMI_TSC_XGXS_TUNING_SM_STATUS5r_TUNING_STATE_BR_TX_POSTCf_SET
#define TUNING_SM_STATUS5r_TUNING_STATE_BR_PFf_GET BCMI_TSC_XGXS_TUNING_SM_STATUS5r_TUNING_STATE_BR_PFf_GET
#define TUNING_SM_STATUS5r_TUNING_STATE_BR_PFf_SET BCMI_TSC_XGXS_TUNING_SM_STATUS5r_TUNING_STATE_BR_PFf_SET
#define TUNING_SM_STATUS5r_TUNING_STATE_BR_VGAf_GET BCMI_TSC_XGXS_TUNING_SM_STATUS5r_TUNING_STATE_BR_VGAf_GET
#define TUNING_SM_STATUS5r_TUNING_STATE_BR_VGAf_SET BCMI_TSC_XGXS_TUNING_SM_STATUS5r_TUNING_STATE_BR_VGAf_SET
#define TUNING_SM_STATUS5r_TUNING_STATE_BR_SLICER_POf_GET BCMI_TSC_XGXS_TUNING_SM_STATUS5r_TUNING_STATE_BR_SLICER_POf_GET
#define TUNING_SM_STATUS5r_TUNING_STATE_BR_SLICER_POf_SET BCMI_TSC_XGXS_TUNING_SM_STATUS5r_TUNING_STATE_BR_SLICER_POf_SET
#define TUNING_SM_STATUS5r_TUNING_STATE_BR_SLICER_PEf_GET BCMI_TSC_XGXS_TUNING_SM_STATUS5r_TUNING_STATE_BR_SLICER_PEf_GET
#define TUNING_SM_STATUS5r_TUNING_STATE_BR_SLICER_PEf_SET BCMI_TSC_XGXS_TUNING_SM_STATUS5r_TUNING_STATE_BR_SLICER_PEf_SET
#define TUNING_SM_STATUS5r_TUNING_STATE_BR_SLICER_MOf_GET BCMI_TSC_XGXS_TUNING_SM_STATUS5r_TUNING_STATE_BR_SLICER_MOf_GET
#define TUNING_SM_STATUS5r_TUNING_STATE_BR_SLICER_MOf_SET BCMI_TSC_XGXS_TUNING_SM_STATUS5r_TUNING_STATE_BR_SLICER_MOf_SET
#define TUNING_SM_STATUS5r_TUNING_STATE_BR_SLICER_MEf_GET BCMI_TSC_XGXS_TUNING_SM_STATUS5r_TUNING_STATE_BR_SLICER_MEf_GET
#define TUNING_SM_STATUS5r_TUNING_STATE_BR_SLICER_MEf_SET BCMI_TSC_XGXS_TUNING_SM_STATUS5r_TUNING_STATE_BR_SLICER_MEf_SET
#define TUNING_SM_STATUS5r_TUNING_STATE_BR_SLICER_DOf_GET BCMI_TSC_XGXS_TUNING_SM_STATUS5r_TUNING_STATE_BR_SLICER_DOf_GET
#define TUNING_SM_STATUS5r_TUNING_STATE_BR_SLICER_DOf_SET BCMI_TSC_XGXS_TUNING_SM_STATUS5r_TUNING_STATE_BR_SLICER_DOf_SET
#define TUNING_SM_STATUS5r_TUNING_STATE_BR_SLICER_DEf_GET BCMI_TSC_XGXS_TUNING_SM_STATUS5r_TUNING_STATE_BR_SLICER_DEf_GET
#define TUNING_SM_STATUS5r_TUNING_STATE_BR_SLICER_DEf_SET BCMI_TSC_XGXS_TUNING_SM_STATUS5r_TUNING_STATE_BR_SLICER_DEf_SET
#define TUNING_SM_STATUS5r_TUNING_STATE_OS_TX_POSTCf_GET BCMI_TSC_XGXS_TUNING_SM_STATUS5r_TUNING_STATE_OS_TX_POSTCf_GET
#define TUNING_SM_STATUS5r_TUNING_STATE_OS_TX_POSTCf_SET BCMI_TSC_XGXS_TUNING_SM_STATUS5r_TUNING_STATE_OS_TX_POSTCf_SET
#define TUNING_SM_STATUS5r_TUNING_STATE_OS_PFf_GET BCMI_TSC_XGXS_TUNING_SM_STATUS5r_TUNING_STATE_OS_PFf_GET
#define TUNING_SM_STATUS5r_TUNING_STATE_OS_PFf_SET BCMI_TSC_XGXS_TUNING_SM_STATUS5r_TUNING_STATE_OS_PFf_SET
#define TUNING_SM_STATUS5r_TUNING_STATE_OS_SLICER_MOf_GET BCMI_TSC_XGXS_TUNING_SM_STATUS5r_TUNING_STATE_OS_SLICER_MOf_GET
#define TUNING_SM_STATUS5r_TUNING_STATE_OS_SLICER_MOf_SET BCMI_TSC_XGXS_TUNING_SM_STATUS5r_TUNING_STATE_OS_SLICER_MOf_SET
#define TUNING_SM_STATUS5r_TUNING_STATE_OS_SLICER_MEf_GET BCMI_TSC_XGXS_TUNING_SM_STATUS5r_TUNING_STATE_OS_SLICER_MEf_GET
#define TUNING_SM_STATUS5r_TUNING_STATE_OS_SLICER_MEf_SET BCMI_TSC_XGXS_TUNING_SM_STATUS5r_TUNING_STATE_OS_SLICER_MEf_SET
#define TUNING_SM_STATUS5r_TUNING_STATE_OS_SLICER_DOf_GET BCMI_TSC_XGXS_TUNING_SM_STATUS5r_TUNING_STATE_OS_SLICER_DOf_GET
#define TUNING_SM_STATUS5r_TUNING_STATE_OS_SLICER_DOf_SET BCMI_TSC_XGXS_TUNING_SM_STATUS5r_TUNING_STATE_OS_SLICER_DOf_SET
#define TUNING_SM_STATUS5r_TUNING_STATE_OS_SLICER_DEf_GET BCMI_TSC_XGXS_TUNING_SM_STATUS5r_TUNING_STATE_OS_SLICER_DEf_GET
#define TUNING_SM_STATUS5r_TUNING_STATE_OS_SLICER_DEf_SET BCMI_TSC_XGXS_TUNING_SM_STATUS5r_TUNING_STATE_OS_SLICER_DEf_SET
#define TUNING_SM_STATUS5r_TUNING_STATE_WAIT_FOR_LOCKf_GET BCMI_TSC_XGXS_TUNING_SM_STATUS5r_TUNING_STATE_WAIT_FOR_LOCKf_GET
#define TUNING_SM_STATUS5r_TUNING_STATE_WAIT_FOR_LOCKf_SET BCMI_TSC_XGXS_TUNING_SM_STATUS5r_TUNING_STATE_WAIT_FOR_LOCKf_SET
#define READ_TUNING_SM_STATUS5r BCMI_TSC_XGXS_READ_TUNING_SM_STATUS5r
#define WRITE_TUNING_SM_STATUS5r BCMI_TSC_XGXS_WRITE_TUNING_SM_STATUS5r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_TUNING_SM_STATUS5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  TUNING_SM_STATUS6
 * BLOCKS:   DSC5B0
 * REGADDR:  0xc246
 * DESC:     State Machine Status 6 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     SRCH_STATE_SRCH_DISABLE 
 *     SRCH_STATE_SRCH_SETUP 
 *     SRCH_STATE_SRCH_WAIT 
 *     SRCH_STATE_SRCH_SET_TRN 
 *     SRCH_STATE_SRCH_WAIT_TRN 
 *     SRCH_STATE_SRCH_SET_MSR 
 *     SRCH_STATE_SRCH_WAIT_MSR 
 *     SRCH_STATE_SRCH_UNDO_SETUP 
 *     SRCH_STATE_SRCH_WAIT_UNDO_SETUP 
 *     SRCH_STATE_SRCH_DONE 
 *     TUNING_STATE_TUNING_DONE 
 *     TUNING_STATE_HYSTERESIS 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_TUNING_SM_STATUS6r (0x0000c246 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_TUNING_SM_STATUS6r_SIZE 4

/*
 * This structure should be used to declare and program TUNING_SM_STATUS6.
 *
 */
typedef union BCMI_TSC_XGXS_TUNING_SM_STATUS6r_s {
	uint32_t v[1];
	uint32_t tuning_sm_status6[1];
	uint32_t _tuning_sm_status6;
} BCMI_TSC_XGXS_TUNING_SM_STATUS6r_t;

#define BCMI_TSC_XGXS_TUNING_SM_STATUS6r_CLR(r) (r).tuning_sm_status6[0] = 0
#define BCMI_TSC_XGXS_TUNING_SM_STATUS6r_SET(r,d) (r).tuning_sm_status6[0] = d
#define BCMI_TSC_XGXS_TUNING_SM_STATUS6r_GET(r) (r).tuning_sm_status6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_TUNING_SM_STATUS6r_RESERVED0f_GET(r) ((((r).tuning_sm_status6[0]) >> 12) & 0xf)
#define BCMI_TSC_XGXS_TUNING_SM_STATUS6r_RESERVED0f_SET(r,f) (r).tuning_sm_status6[0]=(((r).tuning_sm_status6[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCMI_TSC_XGXS_TUNING_SM_STATUS6r_TUNING_STATE_HYSTERESISf_GET(r) ((((r).tuning_sm_status6[0]) >> 11) & 0x1)
#define BCMI_TSC_XGXS_TUNING_SM_STATUS6r_TUNING_STATE_HYSTERESISf_SET(r,f) (r).tuning_sm_status6[0]=(((r).tuning_sm_status6[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCMI_TSC_XGXS_TUNING_SM_STATUS6r_TUNING_STATE_TUNING_DONEf_GET(r) ((((r).tuning_sm_status6[0]) >> 10) & 0x1)
#define BCMI_TSC_XGXS_TUNING_SM_STATUS6r_TUNING_STATE_TUNING_DONEf_SET(r,f) (r).tuning_sm_status6[0]=(((r).tuning_sm_status6[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCMI_TSC_XGXS_TUNING_SM_STATUS6r_SRCH_STATE_SRCH_DONEf_GET(r) ((((r).tuning_sm_status6[0]) >> 9) & 0x1)
#define BCMI_TSC_XGXS_TUNING_SM_STATUS6r_SRCH_STATE_SRCH_DONEf_SET(r,f) (r).tuning_sm_status6[0]=(((r).tuning_sm_status6[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCMI_TSC_XGXS_TUNING_SM_STATUS6r_SRCH_STATE_SRCH_WAIT_UNDO_SETUPf_GET(r) ((((r).tuning_sm_status6[0]) >> 8) & 0x1)
#define BCMI_TSC_XGXS_TUNING_SM_STATUS6r_SRCH_STATE_SRCH_WAIT_UNDO_SETUPf_SET(r,f) (r).tuning_sm_status6[0]=(((r).tuning_sm_status6[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCMI_TSC_XGXS_TUNING_SM_STATUS6r_SRCH_STATE_SRCH_UNDO_SETUPf_GET(r) ((((r).tuning_sm_status6[0]) >> 7) & 0x1)
#define BCMI_TSC_XGXS_TUNING_SM_STATUS6r_SRCH_STATE_SRCH_UNDO_SETUPf_SET(r,f) (r).tuning_sm_status6[0]=(((r).tuning_sm_status6[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCMI_TSC_XGXS_TUNING_SM_STATUS6r_SRCH_STATE_SRCH_WAIT_MSRf_GET(r) ((((r).tuning_sm_status6[0]) >> 6) & 0x1)
#define BCMI_TSC_XGXS_TUNING_SM_STATUS6r_SRCH_STATE_SRCH_WAIT_MSRf_SET(r,f) (r).tuning_sm_status6[0]=(((r).tuning_sm_status6[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCMI_TSC_XGXS_TUNING_SM_STATUS6r_SRCH_STATE_SRCH_SET_MSRf_GET(r) ((((r).tuning_sm_status6[0]) >> 5) & 0x1)
#define BCMI_TSC_XGXS_TUNING_SM_STATUS6r_SRCH_STATE_SRCH_SET_MSRf_SET(r,f) (r).tuning_sm_status6[0]=(((r).tuning_sm_status6[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCMI_TSC_XGXS_TUNING_SM_STATUS6r_SRCH_STATE_SRCH_WAIT_TRNf_GET(r) ((((r).tuning_sm_status6[0]) >> 4) & 0x1)
#define BCMI_TSC_XGXS_TUNING_SM_STATUS6r_SRCH_STATE_SRCH_WAIT_TRNf_SET(r,f) (r).tuning_sm_status6[0]=(((r).tuning_sm_status6[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCMI_TSC_XGXS_TUNING_SM_STATUS6r_SRCH_STATE_SRCH_SET_TRNf_GET(r) ((((r).tuning_sm_status6[0]) >> 3) & 0x1)
#define BCMI_TSC_XGXS_TUNING_SM_STATUS6r_SRCH_STATE_SRCH_SET_TRNf_SET(r,f) (r).tuning_sm_status6[0]=(((r).tuning_sm_status6[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCMI_TSC_XGXS_TUNING_SM_STATUS6r_SRCH_STATE_SRCH_WAITf_GET(r) ((((r).tuning_sm_status6[0]) >> 2) & 0x1)
#define BCMI_TSC_XGXS_TUNING_SM_STATUS6r_SRCH_STATE_SRCH_WAITf_SET(r,f) (r).tuning_sm_status6[0]=(((r).tuning_sm_status6[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCMI_TSC_XGXS_TUNING_SM_STATUS6r_SRCH_STATE_SRCH_SETUPf_GET(r) ((((r).tuning_sm_status6[0]) >> 1) & 0x1)
#define BCMI_TSC_XGXS_TUNING_SM_STATUS6r_SRCH_STATE_SRCH_SETUPf_SET(r,f) (r).tuning_sm_status6[0]=(((r).tuning_sm_status6[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCMI_TSC_XGXS_TUNING_SM_STATUS6r_SRCH_STATE_SRCH_DISABLEf_GET(r) (((r).tuning_sm_status6[0]) & 0x1)
#define BCMI_TSC_XGXS_TUNING_SM_STATUS6r_SRCH_STATE_SRCH_DISABLEf_SET(r,f) (r).tuning_sm_status6[0]=(((r).tuning_sm_status6[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access TUNING_SM_STATUS6.
 *
 */
#define BCMI_TSC_XGXS_READ_TUNING_SM_STATUS6r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_TUNING_SM_STATUS6r,(_r._tuning_sm_status6))
#define BCMI_TSC_XGXS_WRITE_TUNING_SM_STATUS6r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_TUNING_SM_STATUS6r,(_r._tuning_sm_status6))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TUNING_SM_STATUS6r BCMI_TSC_XGXS_TUNING_SM_STATUS6r
#define TUNING_SM_STATUS6r_SIZE BCMI_TSC_XGXS_TUNING_SM_STATUS6r_SIZE
typedef BCMI_TSC_XGXS_TUNING_SM_STATUS6r_t TUNING_SM_STATUS6r_t;
#define TUNING_SM_STATUS6r_CLR BCMI_TSC_XGXS_TUNING_SM_STATUS6r_CLR
#define TUNING_SM_STATUS6r_SET BCMI_TSC_XGXS_TUNING_SM_STATUS6r_SET
#define TUNING_SM_STATUS6r_GET BCMI_TSC_XGXS_TUNING_SM_STATUS6r_GET
#define TUNING_SM_STATUS6r_RESERVED0f_GET BCMI_TSC_XGXS_TUNING_SM_STATUS6r_RESERVED0f_GET
#define TUNING_SM_STATUS6r_RESERVED0f_SET BCMI_TSC_XGXS_TUNING_SM_STATUS6r_RESERVED0f_SET
#define TUNING_SM_STATUS6r_TUNING_STATE_HYSTERESISf_GET BCMI_TSC_XGXS_TUNING_SM_STATUS6r_TUNING_STATE_HYSTERESISf_GET
#define TUNING_SM_STATUS6r_TUNING_STATE_HYSTERESISf_SET BCMI_TSC_XGXS_TUNING_SM_STATUS6r_TUNING_STATE_HYSTERESISf_SET
#define TUNING_SM_STATUS6r_TUNING_STATE_TUNING_DONEf_GET BCMI_TSC_XGXS_TUNING_SM_STATUS6r_TUNING_STATE_TUNING_DONEf_GET
#define TUNING_SM_STATUS6r_TUNING_STATE_TUNING_DONEf_SET BCMI_TSC_XGXS_TUNING_SM_STATUS6r_TUNING_STATE_TUNING_DONEf_SET
#define TUNING_SM_STATUS6r_SRCH_STATE_SRCH_DONEf_GET BCMI_TSC_XGXS_TUNING_SM_STATUS6r_SRCH_STATE_SRCH_DONEf_GET
#define TUNING_SM_STATUS6r_SRCH_STATE_SRCH_DONEf_SET BCMI_TSC_XGXS_TUNING_SM_STATUS6r_SRCH_STATE_SRCH_DONEf_SET
#define TUNING_SM_STATUS6r_SRCH_STATE_SRCH_WAIT_UNDO_SETUPf_GET BCMI_TSC_XGXS_TUNING_SM_STATUS6r_SRCH_STATE_SRCH_WAIT_UNDO_SETUPf_GET
#define TUNING_SM_STATUS6r_SRCH_STATE_SRCH_WAIT_UNDO_SETUPf_SET BCMI_TSC_XGXS_TUNING_SM_STATUS6r_SRCH_STATE_SRCH_WAIT_UNDO_SETUPf_SET
#define TUNING_SM_STATUS6r_SRCH_STATE_SRCH_UNDO_SETUPf_GET BCMI_TSC_XGXS_TUNING_SM_STATUS6r_SRCH_STATE_SRCH_UNDO_SETUPf_GET
#define TUNING_SM_STATUS6r_SRCH_STATE_SRCH_UNDO_SETUPf_SET BCMI_TSC_XGXS_TUNING_SM_STATUS6r_SRCH_STATE_SRCH_UNDO_SETUPf_SET
#define TUNING_SM_STATUS6r_SRCH_STATE_SRCH_WAIT_MSRf_GET BCMI_TSC_XGXS_TUNING_SM_STATUS6r_SRCH_STATE_SRCH_WAIT_MSRf_GET
#define TUNING_SM_STATUS6r_SRCH_STATE_SRCH_WAIT_MSRf_SET BCMI_TSC_XGXS_TUNING_SM_STATUS6r_SRCH_STATE_SRCH_WAIT_MSRf_SET
#define TUNING_SM_STATUS6r_SRCH_STATE_SRCH_SET_MSRf_GET BCMI_TSC_XGXS_TUNING_SM_STATUS6r_SRCH_STATE_SRCH_SET_MSRf_GET
#define TUNING_SM_STATUS6r_SRCH_STATE_SRCH_SET_MSRf_SET BCMI_TSC_XGXS_TUNING_SM_STATUS6r_SRCH_STATE_SRCH_SET_MSRf_SET
#define TUNING_SM_STATUS6r_SRCH_STATE_SRCH_WAIT_TRNf_GET BCMI_TSC_XGXS_TUNING_SM_STATUS6r_SRCH_STATE_SRCH_WAIT_TRNf_GET
#define TUNING_SM_STATUS6r_SRCH_STATE_SRCH_WAIT_TRNf_SET BCMI_TSC_XGXS_TUNING_SM_STATUS6r_SRCH_STATE_SRCH_WAIT_TRNf_SET
#define TUNING_SM_STATUS6r_SRCH_STATE_SRCH_SET_TRNf_GET BCMI_TSC_XGXS_TUNING_SM_STATUS6r_SRCH_STATE_SRCH_SET_TRNf_GET
#define TUNING_SM_STATUS6r_SRCH_STATE_SRCH_SET_TRNf_SET BCMI_TSC_XGXS_TUNING_SM_STATUS6r_SRCH_STATE_SRCH_SET_TRNf_SET
#define TUNING_SM_STATUS6r_SRCH_STATE_SRCH_WAITf_GET BCMI_TSC_XGXS_TUNING_SM_STATUS6r_SRCH_STATE_SRCH_WAITf_GET
#define TUNING_SM_STATUS6r_SRCH_STATE_SRCH_WAITf_SET BCMI_TSC_XGXS_TUNING_SM_STATUS6r_SRCH_STATE_SRCH_WAITf_SET
#define TUNING_SM_STATUS6r_SRCH_STATE_SRCH_SETUPf_GET BCMI_TSC_XGXS_TUNING_SM_STATUS6r_SRCH_STATE_SRCH_SETUPf_GET
#define TUNING_SM_STATUS6r_SRCH_STATE_SRCH_SETUPf_SET BCMI_TSC_XGXS_TUNING_SM_STATUS6r_SRCH_STATE_SRCH_SETUPf_SET
#define TUNING_SM_STATUS6r_SRCH_STATE_SRCH_DISABLEf_GET BCMI_TSC_XGXS_TUNING_SM_STATUS6r_SRCH_STATE_SRCH_DISABLEf_GET
#define TUNING_SM_STATUS6r_SRCH_STATE_SRCH_DISABLEf_SET BCMI_TSC_XGXS_TUNING_SM_STATUS6r_SRCH_STATE_SRCH_DISABLEf_SET
#define READ_TUNING_SM_STATUS6r BCMI_TSC_XGXS_READ_TUNING_SM_STATUS6r
#define WRITE_TUNING_SM_STATUS6r BCMI_TSC_XGXS_WRITE_TUNING_SM_STATUS6r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_TUNING_SM_STATUS6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CL72_XMT_CONTROL
 * BLOCKS:   CL72
 * REGADDR:  0xc250
 * DESC:     CL72 TX Coefficient Update Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     XMT_CONTROL_PAGE 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CL72_XMT_CONTROLr (0x0000c250 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CL72_XMT_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program CL72_XMT_CONTROL.
 *
 */
typedef union BCMI_TSC_XGXS_CL72_XMT_CONTROLr_s {
	uint32_t v[1];
	uint32_t cl72_xmt_control[1];
	uint32_t _cl72_xmt_control;
} BCMI_TSC_XGXS_CL72_XMT_CONTROLr_t;

#define BCMI_TSC_XGXS_CL72_XMT_CONTROLr_CLR(r) (r).cl72_xmt_control[0] = 0
#define BCMI_TSC_XGXS_CL72_XMT_CONTROLr_SET(r,d) (r).cl72_xmt_control[0] = d
#define BCMI_TSC_XGXS_CL72_XMT_CONTROLr_GET(r) (r).cl72_xmt_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CL72_XMT_CONTROLr_XMT_CONTROL_PAGEf_GET(r) (((r).cl72_xmt_control[0]) & 0xffff)
#define BCMI_TSC_XGXS_CL72_XMT_CONTROLr_XMT_CONTROL_PAGEf_SET(r,f) (r).cl72_xmt_control[0]=(((r).cl72_xmt_control[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access CL72_XMT_CONTROL.
 *
 */
#define BCMI_TSC_XGXS_READ_CL72_XMT_CONTROLr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CL72_XMT_CONTROLr,(_r._cl72_xmt_control))
#define BCMI_TSC_XGXS_WRITE_CL72_XMT_CONTROLr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CL72_XMT_CONTROLr,(_r._cl72_xmt_control))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL72_XMT_CONTROLr BCMI_TSC_XGXS_CL72_XMT_CONTROLr
#define CL72_XMT_CONTROLr_SIZE BCMI_TSC_XGXS_CL72_XMT_CONTROLr_SIZE
typedef BCMI_TSC_XGXS_CL72_XMT_CONTROLr_t CL72_XMT_CONTROLr_t;
#define CL72_XMT_CONTROLr_CLR BCMI_TSC_XGXS_CL72_XMT_CONTROLr_CLR
#define CL72_XMT_CONTROLr_SET BCMI_TSC_XGXS_CL72_XMT_CONTROLr_SET
#define CL72_XMT_CONTROLr_GET BCMI_TSC_XGXS_CL72_XMT_CONTROLr_GET
#define CL72_XMT_CONTROLr_XMT_CONTROL_PAGEf_GET BCMI_TSC_XGXS_CL72_XMT_CONTROLr_XMT_CONTROL_PAGEf_GET
#define CL72_XMT_CONTROLr_XMT_CONTROL_PAGEf_SET BCMI_TSC_XGXS_CL72_XMT_CONTROLr_XMT_CONTROL_PAGEf_SET
#define READ_CL72_XMT_CONTROLr BCMI_TSC_XGXS_READ_CL72_XMT_CONTROLr
#define WRITE_CL72_XMT_CONTROLr BCMI_TSC_XGXS_WRITE_CL72_XMT_CONTROLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CL72_XMT_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CL72_RCVD_STATUS
 * BLOCKS:   CL72
 * REGADDR:  0xc251
 * DESC:     CL72 Status Report Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     RCVD_STATUS_PAGE 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CL72_RCVD_STATUSr (0x0000c251 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CL72_RCVD_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program CL72_RCVD_STATUS.
 *
 */
typedef union BCMI_TSC_XGXS_CL72_RCVD_STATUSr_s {
	uint32_t v[1];
	uint32_t cl72_rcvd_status[1];
	uint32_t _cl72_rcvd_status;
} BCMI_TSC_XGXS_CL72_RCVD_STATUSr_t;

#define BCMI_TSC_XGXS_CL72_RCVD_STATUSr_CLR(r) (r).cl72_rcvd_status[0] = 0
#define BCMI_TSC_XGXS_CL72_RCVD_STATUSr_SET(r,d) (r).cl72_rcvd_status[0] = d
#define BCMI_TSC_XGXS_CL72_RCVD_STATUSr_GET(r) (r).cl72_rcvd_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CL72_RCVD_STATUSr_RCVD_STATUS_PAGEf_GET(r) (((r).cl72_rcvd_status[0]) & 0xffff)
#define BCMI_TSC_XGXS_CL72_RCVD_STATUSr_RCVD_STATUS_PAGEf_SET(r,f) (r).cl72_rcvd_status[0]=(((r).cl72_rcvd_status[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access CL72_RCVD_STATUS.
 *
 */
#define BCMI_TSC_XGXS_READ_CL72_RCVD_STATUSr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CL72_RCVD_STATUSr,(_r._cl72_rcvd_status))
#define BCMI_TSC_XGXS_WRITE_CL72_RCVD_STATUSr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CL72_RCVD_STATUSr,(_r._cl72_rcvd_status))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL72_RCVD_STATUSr BCMI_TSC_XGXS_CL72_RCVD_STATUSr
#define CL72_RCVD_STATUSr_SIZE BCMI_TSC_XGXS_CL72_RCVD_STATUSr_SIZE
typedef BCMI_TSC_XGXS_CL72_RCVD_STATUSr_t CL72_RCVD_STATUSr_t;
#define CL72_RCVD_STATUSr_CLR BCMI_TSC_XGXS_CL72_RCVD_STATUSr_CLR
#define CL72_RCVD_STATUSr_SET BCMI_TSC_XGXS_CL72_RCVD_STATUSr_SET
#define CL72_RCVD_STATUSr_GET BCMI_TSC_XGXS_CL72_RCVD_STATUSr_GET
#define CL72_RCVD_STATUSr_RCVD_STATUS_PAGEf_GET BCMI_TSC_XGXS_CL72_RCVD_STATUSr_RCVD_STATUS_PAGEf_GET
#define CL72_RCVD_STATUSr_RCVD_STATUS_PAGEf_SET BCMI_TSC_XGXS_CL72_RCVD_STATUSr_RCVD_STATUS_PAGEf_SET
#define READ_CL72_RCVD_STATUSr BCMI_TSC_XGXS_READ_CL72_RCVD_STATUSr
#define WRITE_CL72_RCVD_STATUSr BCMI_TSC_XGXS_WRITE_CL72_RCVD_STATUSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CL72_RCVD_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CL72_TX_FIR_TAP
 * BLOCKS:   CL72
 * REGADDR:  0xc252
 * DESC:     CL72 TX FIR Tap Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     TX_FIR_TAP_PRE   
 *     TX_FIR_TAP_MAIN  
 *     TX_FIR_TAP_POST  
 *     TX_FIR_TAP_FORCE 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CL72_TX_FIR_TAPr (0x0000c252 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CL72_TX_FIR_TAPr_SIZE 4

/*
 * This structure should be used to declare and program CL72_TX_FIR_TAP.
 *
 */
typedef union BCMI_TSC_XGXS_CL72_TX_FIR_TAPr_s {
	uint32_t v[1];
	uint32_t cl72_tx_fir_tap[1];
	uint32_t _cl72_tx_fir_tap;
} BCMI_TSC_XGXS_CL72_TX_FIR_TAPr_t;

#define BCMI_TSC_XGXS_CL72_TX_FIR_TAPr_CLR(r) (r).cl72_tx_fir_tap[0] = 0
#define BCMI_TSC_XGXS_CL72_TX_FIR_TAPr_SET(r,d) (r).cl72_tx_fir_tap[0] = d
#define BCMI_TSC_XGXS_CL72_TX_FIR_TAPr_GET(r) (r).cl72_tx_fir_tap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CL72_TX_FIR_TAPr_TX_FIR_TAP_FORCEf_GET(r) ((((r).cl72_tx_fir_tap[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_CL72_TX_FIR_TAPr_TX_FIR_TAP_FORCEf_SET(r,f) (r).cl72_tx_fir_tap[0]=(((r).cl72_tx_fir_tap[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_CL72_TX_FIR_TAPr_TX_FIR_TAP_POSTf_GET(r) ((((r).cl72_tx_fir_tap[0]) >> 10) & 0x1f)
#define BCMI_TSC_XGXS_CL72_TX_FIR_TAPr_TX_FIR_TAP_POSTf_SET(r,f) (r).cl72_tx_fir_tap[0]=(((r).cl72_tx_fir_tap[0] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10))
#define BCMI_TSC_XGXS_CL72_TX_FIR_TAPr_TX_FIR_TAP_MAINf_GET(r) ((((r).cl72_tx_fir_tap[0]) >> 4) & 0x3f)
#define BCMI_TSC_XGXS_CL72_TX_FIR_TAPr_TX_FIR_TAP_MAINf_SET(r,f) (r).cl72_tx_fir_tap[0]=(((r).cl72_tx_fir_tap[0] & ~((uint32_t)0x3f << 4)) | ((((uint32_t)f) & 0x3f) << 4))
#define BCMI_TSC_XGXS_CL72_TX_FIR_TAPr_TX_FIR_TAP_PREf_GET(r) (((r).cl72_tx_fir_tap[0]) & 0xf)
#define BCMI_TSC_XGXS_CL72_TX_FIR_TAPr_TX_FIR_TAP_PREf_SET(r,f) (r).cl72_tx_fir_tap[0]=(((r).cl72_tx_fir_tap[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access CL72_TX_FIR_TAP.
 *
 */
#define BCMI_TSC_XGXS_READ_CL72_TX_FIR_TAPr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CL72_TX_FIR_TAPr,(_r._cl72_tx_fir_tap))
#define BCMI_TSC_XGXS_WRITE_CL72_TX_FIR_TAPr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CL72_TX_FIR_TAPr,(_r._cl72_tx_fir_tap))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL72_TX_FIR_TAPr BCMI_TSC_XGXS_CL72_TX_FIR_TAPr
#define CL72_TX_FIR_TAPr_SIZE BCMI_TSC_XGXS_CL72_TX_FIR_TAPr_SIZE
typedef BCMI_TSC_XGXS_CL72_TX_FIR_TAPr_t CL72_TX_FIR_TAPr_t;
#define CL72_TX_FIR_TAPr_CLR BCMI_TSC_XGXS_CL72_TX_FIR_TAPr_CLR
#define CL72_TX_FIR_TAPr_SET BCMI_TSC_XGXS_CL72_TX_FIR_TAPr_SET
#define CL72_TX_FIR_TAPr_GET BCMI_TSC_XGXS_CL72_TX_FIR_TAPr_GET
#define CL72_TX_FIR_TAPr_TX_FIR_TAP_FORCEf_GET BCMI_TSC_XGXS_CL72_TX_FIR_TAPr_TX_FIR_TAP_FORCEf_GET
#define CL72_TX_FIR_TAPr_TX_FIR_TAP_FORCEf_SET BCMI_TSC_XGXS_CL72_TX_FIR_TAPr_TX_FIR_TAP_FORCEf_SET
#define CL72_TX_FIR_TAPr_TX_FIR_TAP_POSTf_GET BCMI_TSC_XGXS_CL72_TX_FIR_TAPr_TX_FIR_TAP_POSTf_GET
#define CL72_TX_FIR_TAPr_TX_FIR_TAP_POSTf_SET BCMI_TSC_XGXS_CL72_TX_FIR_TAPr_TX_FIR_TAP_POSTf_SET
#define CL72_TX_FIR_TAPr_TX_FIR_TAP_MAINf_GET BCMI_TSC_XGXS_CL72_TX_FIR_TAPr_TX_FIR_TAP_MAINf_GET
#define CL72_TX_FIR_TAPr_TX_FIR_TAP_MAINf_SET BCMI_TSC_XGXS_CL72_TX_FIR_TAPr_TX_FIR_TAP_MAINf_SET
#define CL72_TX_FIR_TAPr_TX_FIR_TAP_PREf_GET BCMI_TSC_XGXS_CL72_TX_FIR_TAPr_TX_FIR_TAP_PREf_GET
#define CL72_TX_FIR_TAPr_TX_FIR_TAP_PREf_SET BCMI_TSC_XGXS_CL72_TX_FIR_TAPr_TX_FIR_TAP_PREf_SET
#define READ_CL72_TX_FIR_TAPr BCMI_TSC_XGXS_READ_CL72_TX_FIR_TAPr
#define WRITE_CL72_TX_FIR_TAPr BCMI_TSC_XGXS_WRITE_CL72_TX_FIR_TAPr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CL72_TX_FIR_TAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CL72_MISC1_CONTROL
 * BLOCKS:   CL72
 * REGADDR:  0xc253
 * DESC:     CL72 Miscellaneous_1 Control Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     RX_TRAINED       
 *     TR_COARSE_LOCK   
 *     RESERVED0        
 *     TAP_DEFAULT_MUXSEL_FORCEVAL 
 *     TAP_DEFAULT_MUXSEL_FORCE 
 *     TX_FIR_TAP_MAIN_KX_INIT_VAL 
 *     LINK_CONTROL_FORCEVAL 
 *     LINK_CONTROL_FORCE 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CL72_MISC1_CONTROLr (0x0000c253 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CL72_MISC1_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program CL72_MISC1_CONTROL.
 *
 */
typedef union BCMI_TSC_XGXS_CL72_MISC1_CONTROLr_s {
	uint32_t v[1];
	uint32_t cl72_misc1_control[1];
	uint32_t _cl72_misc1_control;
} BCMI_TSC_XGXS_CL72_MISC1_CONTROLr_t;

#define BCMI_TSC_XGXS_CL72_MISC1_CONTROLr_CLR(r) (r).cl72_misc1_control[0] = 0
#define BCMI_TSC_XGXS_CL72_MISC1_CONTROLr_SET(r,d) (r).cl72_misc1_control[0] = d
#define BCMI_TSC_XGXS_CL72_MISC1_CONTROLr_GET(r) (r).cl72_misc1_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CL72_MISC1_CONTROLr_LINK_CONTROL_FORCEf_GET(r) ((((r).cl72_misc1_control[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_CL72_MISC1_CONTROLr_LINK_CONTROL_FORCEf_SET(r,f) (r).cl72_misc1_control[0]=(((r).cl72_misc1_control[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_CL72_MISC1_CONTROLr_LINK_CONTROL_FORCEVALf_GET(r) ((((r).cl72_misc1_control[0]) >> 14) & 0x1)
#define BCMI_TSC_XGXS_CL72_MISC1_CONTROLr_LINK_CONTROL_FORCEVALf_SET(r,f) (r).cl72_misc1_control[0]=(((r).cl72_misc1_control[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCMI_TSC_XGXS_CL72_MISC1_CONTROLr_TX_FIR_TAP_MAIN_KX_INIT_VALf_GET(r) ((((r).cl72_misc1_control[0]) >> 8) & 0x3f)
#define BCMI_TSC_XGXS_CL72_MISC1_CONTROLr_TX_FIR_TAP_MAIN_KX_INIT_VALf_SET(r,f) (r).cl72_misc1_control[0]=(((r).cl72_misc1_control[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define BCMI_TSC_XGXS_CL72_MISC1_CONTROLr_TAP_DEFAULT_MUXSEL_FORCEf_GET(r) ((((r).cl72_misc1_control[0]) >> 7) & 0x1)
#define BCMI_TSC_XGXS_CL72_MISC1_CONTROLr_TAP_DEFAULT_MUXSEL_FORCEf_SET(r,f) (r).cl72_misc1_control[0]=(((r).cl72_misc1_control[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCMI_TSC_XGXS_CL72_MISC1_CONTROLr_TAP_DEFAULT_MUXSEL_FORCEVALf_GET(r) ((((r).cl72_misc1_control[0]) >> 4) & 0x7)
#define BCMI_TSC_XGXS_CL72_MISC1_CONTROLr_TAP_DEFAULT_MUXSEL_FORCEVALf_SET(r,f) (r).cl72_misc1_control[0]=(((r).cl72_misc1_control[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4))
#define BCMI_TSC_XGXS_CL72_MISC1_CONTROLr_RESERVED0f_GET(r) ((((r).cl72_misc1_control[0]) >> 2) & 0x3)
#define BCMI_TSC_XGXS_CL72_MISC1_CONTROLr_RESERVED0f_SET(r,f) (r).cl72_misc1_control[0]=(((r).cl72_misc1_control[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCMI_TSC_XGXS_CL72_MISC1_CONTROLr_TR_COARSE_LOCKf_GET(r) ((((r).cl72_misc1_control[0]) >> 1) & 0x1)
#define BCMI_TSC_XGXS_CL72_MISC1_CONTROLr_TR_COARSE_LOCKf_SET(r,f) (r).cl72_misc1_control[0]=(((r).cl72_misc1_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCMI_TSC_XGXS_CL72_MISC1_CONTROLr_RX_TRAINEDf_GET(r) (((r).cl72_misc1_control[0]) & 0x1)
#define BCMI_TSC_XGXS_CL72_MISC1_CONTROLr_RX_TRAINEDf_SET(r,f) (r).cl72_misc1_control[0]=(((r).cl72_misc1_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access CL72_MISC1_CONTROL.
 *
 */
#define BCMI_TSC_XGXS_READ_CL72_MISC1_CONTROLr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CL72_MISC1_CONTROLr,(_r._cl72_misc1_control))
#define BCMI_TSC_XGXS_WRITE_CL72_MISC1_CONTROLr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CL72_MISC1_CONTROLr,(_r._cl72_misc1_control))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL72_MISC1_CONTROLr BCMI_TSC_XGXS_CL72_MISC1_CONTROLr
#define CL72_MISC1_CONTROLr_SIZE BCMI_TSC_XGXS_CL72_MISC1_CONTROLr_SIZE
typedef BCMI_TSC_XGXS_CL72_MISC1_CONTROLr_t CL72_MISC1_CONTROLr_t;
#define CL72_MISC1_CONTROLr_CLR BCMI_TSC_XGXS_CL72_MISC1_CONTROLr_CLR
#define CL72_MISC1_CONTROLr_SET BCMI_TSC_XGXS_CL72_MISC1_CONTROLr_SET
#define CL72_MISC1_CONTROLr_GET BCMI_TSC_XGXS_CL72_MISC1_CONTROLr_GET
#define CL72_MISC1_CONTROLr_LINK_CONTROL_FORCEf_GET BCMI_TSC_XGXS_CL72_MISC1_CONTROLr_LINK_CONTROL_FORCEf_GET
#define CL72_MISC1_CONTROLr_LINK_CONTROL_FORCEf_SET BCMI_TSC_XGXS_CL72_MISC1_CONTROLr_LINK_CONTROL_FORCEf_SET
#define CL72_MISC1_CONTROLr_LINK_CONTROL_FORCEVALf_GET BCMI_TSC_XGXS_CL72_MISC1_CONTROLr_LINK_CONTROL_FORCEVALf_GET
#define CL72_MISC1_CONTROLr_LINK_CONTROL_FORCEVALf_SET BCMI_TSC_XGXS_CL72_MISC1_CONTROLr_LINK_CONTROL_FORCEVALf_SET
#define CL72_MISC1_CONTROLr_TX_FIR_TAP_MAIN_KX_INIT_VALf_GET BCMI_TSC_XGXS_CL72_MISC1_CONTROLr_TX_FIR_TAP_MAIN_KX_INIT_VALf_GET
#define CL72_MISC1_CONTROLr_TX_FIR_TAP_MAIN_KX_INIT_VALf_SET BCMI_TSC_XGXS_CL72_MISC1_CONTROLr_TX_FIR_TAP_MAIN_KX_INIT_VALf_SET
#define CL72_MISC1_CONTROLr_TAP_DEFAULT_MUXSEL_FORCEf_GET BCMI_TSC_XGXS_CL72_MISC1_CONTROLr_TAP_DEFAULT_MUXSEL_FORCEf_GET
#define CL72_MISC1_CONTROLr_TAP_DEFAULT_MUXSEL_FORCEf_SET BCMI_TSC_XGXS_CL72_MISC1_CONTROLr_TAP_DEFAULT_MUXSEL_FORCEf_SET
#define CL72_MISC1_CONTROLr_TAP_DEFAULT_MUXSEL_FORCEVALf_GET BCMI_TSC_XGXS_CL72_MISC1_CONTROLr_TAP_DEFAULT_MUXSEL_FORCEVALf_GET
#define CL72_MISC1_CONTROLr_TAP_DEFAULT_MUXSEL_FORCEVALf_SET BCMI_TSC_XGXS_CL72_MISC1_CONTROLr_TAP_DEFAULT_MUXSEL_FORCEVALf_SET
#define CL72_MISC1_CONTROLr_RESERVED0f_GET BCMI_TSC_XGXS_CL72_MISC1_CONTROLr_RESERVED0f_GET
#define CL72_MISC1_CONTROLr_RESERVED0f_SET BCMI_TSC_XGXS_CL72_MISC1_CONTROLr_RESERVED0f_SET
#define CL72_MISC1_CONTROLr_TR_COARSE_LOCKf_GET BCMI_TSC_XGXS_CL72_MISC1_CONTROLr_TR_COARSE_LOCKf_GET
#define CL72_MISC1_CONTROLr_TR_COARSE_LOCKf_SET BCMI_TSC_XGXS_CL72_MISC1_CONTROLr_TR_COARSE_LOCKf_SET
#define CL72_MISC1_CONTROLr_RX_TRAINEDf_GET BCMI_TSC_XGXS_CL72_MISC1_CONTROLr_RX_TRAINEDf_GET
#define CL72_MISC1_CONTROLr_RX_TRAINEDf_SET BCMI_TSC_XGXS_CL72_MISC1_CONTROLr_RX_TRAINEDf_SET
#define READ_CL72_MISC1_CONTROLr BCMI_TSC_XGXS_READ_CL72_MISC1_CONTROLr
#define WRITE_CL72_MISC1_CONTROLr BCMI_TSC_XGXS_WRITE_CL72_MISC1_CONTROLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CL72_MISC1_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CL72_MISC2_CONTROL
 * BLOCKS:   CL72
 * REGADDR:  0xc254
 * DESC:     CL72 Miscellaneous_2 Control Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     RESERVED1        
 *     INC_DEC_VAL_SEL  
 *     NEWPG_RCVD_LOAD  
 *     NEWPG_RCVD_OVERRIDE 
 *     MAIN_TAP_ADJUST_EN 
 *     MAIN_TAP_ADJUST_FORCEVAL 
 *     MAIN_TAP_ADJUST_FORCE 
 *     SW_ACTUAL_SPEED  
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CL72_MISC2_CONTROLr (0x0000c254 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CL72_MISC2_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program CL72_MISC2_CONTROL.
 *
 */
typedef union BCMI_TSC_XGXS_CL72_MISC2_CONTROLr_s {
	uint32_t v[1];
	uint32_t cl72_misc2_control[1];
	uint32_t _cl72_misc2_control;
} BCMI_TSC_XGXS_CL72_MISC2_CONTROLr_t;

#define BCMI_TSC_XGXS_CL72_MISC2_CONTROLr_CLR(r) (r).cl72_misc2_control[0] = 0
#define BCMI_TSC_XGXS_CL72_MISC2_CONTROLr_SET(r,d) (r).cl72_misc2_control[0] = d
#define BCMI_TSC_XGXS_CL72_MISC2_CONTROLr_GET(r) (r).cl72_misc2_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CL72_MISC2_CONTROLr_RESERVED0f_GET(r) ((((r).cl72_misc2_control[0]) >> 14) & 0x3)
#define BCMI_TSC_XGXS_CL72_MISC2_CONTROLr_RESERVED0f_SET(r,f) (r).cl72_misc2_control[0]=(((r).cl72_misc2_control[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCMI_TSC_XGXS_CL72_MISC2_CONTROLr_SW_ACTUAL_SPEEDf_GET(r) ((((r).cl72_misc2_control[0]) >> 8) & 0x3f)
#define BCMI_TSC_XGXS_CL72_MISC2_CONTROLr_SW_ACTUAL_SPEEDf_SET(r,f) (r).cl72_misc2_control[0]=(((r).cl72_misc2_control[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define BCMI_TSC_XGXS_CL72_MISC2_CONTROLr_MAIN_TAP_ADJUST_FORCEf_GET(r) ((((r).cl72_misc2_control[0]) >> 7) & 0x1)
#define BCMI_TSC_XGXS_CL72_MISC2_CONTROLr_MAIN_TAP_ADJUST_FORCEf_SET(r,f) (r).cl72_misc2_control[0]=(((r).cl72_misc2_control[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCMI_TSC_XGXS_CL72_MISC2_CONTROLr_MAIN_TAP_ADJUST_FORCEVALf_GET(r) ((((r).cl72_misc2_control[0]) >> 6) & 0x1)
#define BCMI_TSC_XGXS_CL72_MISC2_CONTROLr_MAIN_TAP_ADJUST_FORCEVALf_SET(r,f) (r).cl72_misc2_control[0]=(((r).cl72_misc2_control[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCMI_TSC_XGXS_CL72_MISC2_CONTROLr_MAIN_TAP_ADJUST_ENf_GET(r) ((((r).cl72_misc2_control[0]) >> 5) & 0x1)
#define BCMI_TSC_XGXS_CL72_MISC2_CONTROLr_MAIN_TAP_ADJUST_ENf_SET(r,f) (r).cl72_misc2_control[0]=(((r).cl72_misc2_control[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCMI_TSC_XGXS_CL72_MISC2_CONTROLr_NEWPG_RCVD_OVERRIDEf_GET(r) ((((r).cl72_misc2_control[0]) >> 4) & 0x1)
#define BCMI_TSC_XGXS_CL72_MISC2_CONTROLr_NEWPG_RCVD_OVERRIDEf_SET(r,f) (r).cl72_misc2_control[0]=(((r).cl72_misc2_control[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCMI_TSC_XGXS_CL72_MISC2_CONTROLr_NEWPG_RCVD_LOADf_GET(r) ((((r).cl72_misc2_control[0]) >> 3) & 0x1)
#define BCMI_TSC_XGXS_CL72_MISC2_CONTROLr_NEWPG_RCVD_LOADf_SET(r,f) (r).cl72_misc2_control[0]=(((r).cl72_misc2_control[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCMI_TSC_XGXS_CL72_MISC2_CONTROLr_INC_DEC_VAL_SELf_GET(r) ((((r).cl72_misc2_control[0]) >> 2) & 0x1)
#define BCMI_TSC_XGXS_CL72_MISC2_CONTROLr_INC_DEC_VAL_SELf_SET(r,f) (r).cl72_misc2_control[0]=(((r).cl72_misc2_control[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCMI_TSC_XGXS_CL72_MISC2_CONTROLr_RESERVED1f_GET(r) (((r).cl72_misc2_control[0]) & 0x3)
#define BCMI_TSC_XGXS_CL72_MISC2_CONTROLr_RESERVED1f_SET(r,f) (r).cl72_misc2_control[0]=(((r).cl72_misc2_control[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))

/*
 * These macros can be used to access CL72_MISC2_CONTROL.
 *
 */
#define BCMI_TSC_XGXS_READ_CL72_MISC2_CONTROLr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CL72_MISC2_CONTROLr,(_r._cl72_misc2_control))
#define BCMI_TSC_XGXS_WRITE_CL72_MISC2_CONTROLr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CL72_MISC2_CONTROLr,(_r._cl72_misc2_control))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL72_MISC2_CONTROLr BCMI_TSC_XGXS_CL72_MISC2_CONTROLr
#define CL72_MISC2_CONTROLr_SIZE BCMI_TSC_XGXS_CL72_MISC2_CONTROLr_SIZE
typedef BCMI_TSC_XGXS_CL72_MISC2_CONTROLr_t CL72_MISC2_CONTROLr_t;
#define CL72_MISC2_CONTROLr_CLR BCMI_TSC_XGXS_CL72_MISC2_CONTROLr_CLR
#define CL72_MISC2_CONTROLr_SET BCMI_TSC_XGXS_CL72_MISC2_CONTROLr_SET
#define CL72_MISC2_CONTROLr_GET BCMI_TSC_XGXS_CL72_MISC2_CONTROLr_GET
#define CL72_MISC2_CONTROLr_RESERVED0f_GET BCMI_TSC_XGXS_CL72_MISC2_CONTROLr_RESERVED0f_GET
#define CL72_MISC2_CONTROLr_RESERVED0f_SET BCMI_TSC_XGXS_CL72_MISC2_CONTROLr_RESERVED0f_SET
#define CL72_MISC2_CONTROLr_SW_ACTUAL_SPEEDf_GET BCMI_TSC_XGXS_CL72_MISC2_CONTROLr_SW_ACTUAL_SPEEDf_GET
#define CL72_MISC2_CONTROLr_SW_ACTUAL_SPEEDf_SET BCMI_TSC_XGXS_CL72_MISC2_CONTROLr_SW_ACTUAL_SPEEDf_SET
#define CL72_MISC2_CONTROLr_MAIN_TAP_ADJUST_FORCEf_GET BCMI_TSC_XGXS_CL72_MISC2_CONTROLr_MAIN_TAP_ADJUST_FORCEf_GET
#define CL72_MISC2_CONTROLr_MAIN_TAP_ADJUST_FORCEf_SET BCMI_TSC_XGXS_CL72_MISC2_CONTROLr_MAIN_TAP_ADJUST_FORCEf_SET
#define CL72_MISC2_CONTROLr_MAIN_TAP_ADJUST_FORCEVALf_GET BCMI_TSC_XGXS_CL72_MISC2_CONTROLr_MAIN_TAP_ADJUST_FORCEVALf_GET
#define CL72_MISC2_CONTROLr_MAIN_TAP_ADJUST_FORCEVALf_SET BCMI_TSC_XGXS_CL72_MISC2_CONTROLr_MAIN_TAP_ADJUST_FORCEVALf_SET
#define CL72_MISC2_CONTROLr_MAIN_TAP_ADJUST_ENf_GET BCMI_TSC_XGXS_CL72_MISC2_CONTROLr_MAIN_TAP_ADJUST_ENf_GET
#define CL72_MISC2_CONTROLr_MAIN_TAP_ADJUST_ENf_SET BCMI_TSC_XGXS_CL72_MISC2_CONTROLr_MAIN_TAP_ADJUST_ENf_SET
#define CL72_MISC2_CONTROLr_NEWPG_RCVD_OVERRIDEf_GET BCMI_TSC_XGXS_CL72_MISC2_CONTROLr_NEWPG_RCVD_OVERRIDEf_GET
#define CL72_MISC2_CONTROLr_NEWPG_RCVD_OVERRIDEf_SET BCMI_TSC_XGXS_CL72_MISC2_CONTROLr_NEWPG_RCVD_OVERRIDEf_SET
#define CL72_MISC2_CONTROLr_NEWPG_RCVD_LOADf_GET BCMI_TSC_XGXS_CL72_MISC2_CONTROLr_NEWPG_RCVD_LOADf_GET
#define CL72_MISC2_CONTROLr_NEWPG_RCVD_LOADf_SET BCMI_TSC_XGXS_CL72_MISC2_CONTROLr_NEWPG_RCVD_LOADf_SET
#define CL72_MISC2_CONTROLr_INC_DEC_VAL_SELf_GET BCMI_TSC_XGXS_CL72_MISC2_CONTROLr_INC_DEC_VAL_SELf_GET
#define CL72_MISC2_CONTROLr_INC_DEC_VAL_SELf_SET BCMI_TSC_XGXS_CL72_MISC2_CONTROLr_INC_DEC_VAL_SELf_SET
#define CL72_MISC2_CONTROLr_RESERVED1f_GET BCMI_TSC_XGXS_CL72_MISC2_CONTROLr_RESERVED1f_GET
#define CL72_MISC2_CONTROLr_RESERVED1f_SET BCMI_TSC_XGXS_CL72_MISC2_CONTROLr_RESERVED1f_SET
#define READ_CL72_MISC2_CONTROLr BCMI_TSC_XGXS_READ_CL72_MISC2_CONTROLr
#define WRITE_CL72_MISC2_CONTROLr BCMI_TSC_XGXS_WRITE_CL72_MISC2_CONTROLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CL72_MISC2_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CL72_DEBUG_2
 * BLOCKS:   CL72
 * REGADDR:  0xc256
 * DESC:     CL72 Debug 2 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     GOOD_MARKER_CNT  
 *     BAD_MARKER_CNT   
 *     RESERVED2        
 *     TR_COARSE_LOCK_FORCE 
 *     RESERVED1        
 *     DIS_MAX_WAIT_TIMER 
 *     STRICT_DME_CHK   
 *     STRICT_MARKER_CHK 
 *     DIS_MAX_WAIT_TIMER_OVERRIDE 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CL72_DEBUG_2r (0x0000c256 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CL72_DEBUG_2r_SIZE 4

/*
 * This structure should be used to declare and program CL72_DEBUG_2.
 *
 */
typedef union BCMI_TSC_XGXS_CL72_DEBUG_2r_s {
	uint32_t v[1];
	uint32_t cl72_debug_2[1];
	uint32_t _cl72_debug_2;
} BCMI_TSC_XGXS_CL72_DEBUG_2r_t;

#define BCMI_TSC_XGXS_CL72_DEBUG_2r_CLR(r) (r).cl72_debug_2[0] = 0
#define BCMI_TSC_XGXS_CL72_DEBUG_2r_SET(r,d) (r).cl72_debug_2[0] = d
#define BCMI_TSC_XGXS_CL72_DEBUG_2r_GET(r) (r).cl72_debug_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CL72_DEBUG_2r_RESERVED0f_GET(r) ((((r).cl72_debug_2[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_CL72_DEBUG_2r_RESERVED0f_SET(r,f) (r).cl72_debug_2[0]=(((r).cl72_debug_2[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_CL72_DEBUG_2r_DIS_MAX_WAIT_TIMER_OVERRIDEf_GET(r) ((((r).cl72_debug_2[0]) >> 14) & 0x1)
#define BCMI_TSC_XGXS_CL72_DEBUG_2r_DIS_MAX_WAIT_TIMER_OVERRIDEf_SET(r,f) (r).cl72_debug_2[0]=(((r).cl72_debug_2[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCMI_TSC_XGXS_CL72_DEBUG_2r_STRICT_MARKER_CHKf_GET(r) ((((r).cl72_debug_2[0]) >> 13) & 0x1)
#define BCMI_TSC_XGXS_CL72_DEBUG_2r_STRICT_MARKER_CHKf_SET(r,f) (r).cl72_debug_2[0]=(((r).cl72_debug_2[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCMI_TSC_XGXS_CL72_DEBUG_2r_STRICT_DME_CHKf_GET(r) ((((r).cl72_debug_2[0]) >> 12) & 0x1)
#define BCMI_TSC_XGXS_CL72_DEBUG_2r_STRICT_DME_CHKf_SET(r,f) (r).cl72_debug_2[0]=(((r).cl72_debug_2[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCMI_TSC_XGXS_CL72_DEBUG_2r_DIS_MAX_WAIT_TIMERf_GET(r) ((((r).cl72_debug_2[0]) >> 11) & 0x1)
#define BCMI_TSC_XGXS_CL72_DEBUG_2r_DIS_MAX_WAIT_TIMERf_SET(r,f) (r).cl72_debug_2[0]=(((r).cl72_debug_2[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCMI_TSC_XGXS_CL72_DEBUG_2r_RESERVED1f_GET(r) ((((r).cl72_debug_2[0]) >> 8) & 0x7)
#define BCMI_TSC_XGXS_CL72_DEBUG_2r_RESERVED1f_SET(r,f) (r).cl72_debug_2[0]=(((r).cl72_debug_2[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8))
#define BCMI_TSC_XGXS_CL72_DEBUG_2r_TR_COARSE_LOCK_FORCEf_GET(r) ((((r).cl72_debug_2[0]) >> 7) & 0x1)
#define BCMI_TSC_XGXS_CL72_DEBUG_2r_TR_COARSE_LOCK_FORCEf_SET(r,f) (r).cl72_debug_2[0]=(((r).cl72_debug_2[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCMI_TSC_XGXS_CL72_DEBUG_2r_RESERVED2f_GET(r) ((((r).cl72_debug_2[0]) >> 5) & 0x3)
#define BCMI_TSC_XGXS_CL72_DEBUG_2r_RESERVED2f_SET(r,f) (r).cl72_debug_2[0]=(((r).cl72_debug_2[0] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5))
#define BCMI_TSC_XGXS_CL72_DEBUG_2r_BAD_MARKER_CNTf_GET(r) ((((r).cl72_debug_2[0]) >> 2) & 0x7)
#define BCMI_TSC_XGXS_CL72_DEBUG_2r_BAD_MARKER_CNTf_SET(r,f) (r).cl72_debug_2[0]=(((r).cl72_debug_2[0] & ~((uint32_t)0x7 << 2)) | ((((uint32_t)f) & 0x7) << 2))
#define BCMI_TSC_XGXS_CL72_DEBUG_2r_GOOD_MARKER_CNTf_GET(r) (((r).cl72_debug_2[0]) & 0x3)
#define BCMI_TSC_XGXS_CL72_DEBUG_2r_GOOD_MARKER_CNTf_SET(r,f) (r).cl72_debug_2[0]=(((r).cl72_debug_2[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))

/*
 * These macros can be used to access CL72_DEBUG_2.
 *
 */
#define BCMI_TSC_XGXS_READ_CL72_DEBUG_2r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CL72_DEBUG_2r,(_r._cl72_debug_2))
#define BCMI_TSC_XGXS_WRITE_CL72_DEBUG_2r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CL72_DEBUG_2r,(_r._cl72_debug_2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL72_DEBUG_2r BCMI_TSC_XGXS_CL72_DEBUG_2r
#define CL72_DEBUG_2r_SIZE BCMI_TSC_XGXS_CL72_DEBUG_2r_SIZE
typedef BCMI_TSC_XGXS_CL72_DEBUG_2r_t CL72_DEBUG_2r_t;
#define CL72_DEBUG_2r_CLR BCMI_TSC_XGXS_CL72_DEBUG_2r_CLR
#define CL72_DEBUG_2r_SET BCMI_TSC_XGXS_CL72_DEBUG_2r_SET
#define CL72_DEBUG_2r_GET BCMI_TSC_XGXS_CL72_DEBUG_2r_GET
#define CL72_DEBUG_2r_RESERVED0f_GET BCMI_TSC_XGXS_CL72_DEBUG_2r_RESERVED0f_GET
#define CL72_DEBUG_2r_RESERVED0f_SET BCMI_TSC_XGXS_CL72_DEBUG_2r_RESERVED0f_SET
#define CL72_DEBUG_2r_DIS_MAX_WAIT_TIMER_OVERRIDEf_GET BCMI_TSC_XGXS_CL72_DEBUG_2r_DIS_MAX_WAIT_TIMER_OVERRIDEf_GET
#define CL72_DEBUG_2r_DIS_MAX_WAIT_TIMER_OVERRIDEf_SET BCMI_TSC_XGXS_CL72_DEBUG_2r_DIS_MAX_WAIT_TIMER_OVERRIDEf_SET
#define CL72_DEBUG_2r_STRICT_MARKER_CHKf_GET BCMI_TSC_XGXS_CL72_DEBUG_2r_STRICT_MARKER_CHKf_GET
#define CL72_DEBUG_2r_STRICT_MARKER_CHKf_SET BCMI_TSC_XGXS_CL72_DEBUG_2r_STRICT_MARKER_CHKf_SET
#define CL72_DEBUG_2r_STRICT_DME_CHKf_GET BCMI_TSC_XGXS_CL72_DEBUG_2r_STRICT_DME_CHKf_GET
#define CL72_DEBUG_2r_STRICT_DME_CHKf_SET BCMI_TSC_XGXS_CL72_DEBUG_2r_STRICT_DME_CHKf_SET
#define CL72_DEBUG_2r_DIS_MAX_WAIT_TIMERf_GET BCMI_TSC_XGXS_CL72_DEBUG_2r_DIS_MAX_WAIT_TIMERf_GET
#define CL72_DEBUG_2r_DIS_MAX_WAIT_TIMERf_SET BCMI_TSC_XGXS_CL72_DEBUG_2r_DIS_MAX_WAIT_TIMERf_SET
#define CL72_DEBUG_2r_RESERVED1f_GET BCMI_TSC_XGXS_CL72_DEBUG_2r_RESERVED1f_GET
#define CL72_DEBUG_2r_RESERVED1f_SET BCMI_TSC_XGXS_CL72_DEBUG_2r_RESERVED1f_SET
#define CL72_DEBUG_2r_TR_COARSE_LOCK_FORCEf_GET BCMI_TSC_XGXS_CL72_DEBUG_2r_TR_COARSE_LOCK_FORCEf_GET
#define CL72_DEBUG_2r_TR_COARSE_LOCK_FORCEf_SET BCMI_TSC_XGXS_CL72_DEBUG_2r_TR_COARSE_LOCK_FORCEf_SET
#define CL72_DEBUG_2r_RESERVED2f_GET BCMI_TSC_XGXS_CL72_DEBUG_2r_RESERVED2f_GET
#define CL72_DEBUG_2r_RESERVED2f_SET BCMI_TSC_XGXS_CL72_DEBUG_2r_RESERVED2f_SET
#define CL72_DEBUG_2r_BAD_MARKER_CNTf_GET BCMI_TSC_XGXS_CL72_DEBUG_2r_BAD_MARKER_CNTf_GET
#define CL72_DEBUG_2r_BAD_MARKER_CNTf_SET BCMI_TSC_XGXS_CL72_DEBUG_2r_BAD_MARKER_CNTf_SET
#define CL72_DEBUG_2r_GOOD_MARKER_CNTf_GET BCMI_TSC_XGXS_CL72_DEBUG_2r_GOOD_MARKER_CNTf_GET
#define CL72_DEBUG_2r_GOOD_MARKER_CNTf_SET BCMI_TSC_XGXS_CL72_DEBUG_2r_GOOD_MARKER_CNTf_SET
#define READ_CL72_DEBUG_2r BCMI_TSC_XGXS_READ_CL72_DEBUG_2r
#define WRITE_CL72_DEBUG_2r BCMI_TSC_XGXS_WRITE_CL72_DEBUG_2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CL72_DEBUG_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CL72_DEBUG_3
 * BLOCKS:   CL72
 * REGADDR:  0xc257
 * DESC:     CL72 Debug 3 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     RANDOM_SEED      
 *     CTRL_FRAME_DLY   
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CL72_DEBUG_3r (0x0000c257 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CL72_DEBUG_3r_SIZE 4

/*
 * This structure should be used to declare and program CL72_DEBUG_3.
 *
 */
typedef union BCMI_TSC_XGXS_CL72_DEBUG_3r_s {
	uint32_t v[1];
	uint32_t cl72_debug_3[1];
	uint32_t _cl72_debug_3;
} BCMI_TSC_XGXS_CL72_DEBUG_3r_t;

#define BCMI_TSC_XGXS_CL72_DEBUG_3r_CLR(r) (r).cl72_debug_3[0] = 0
#define BCMI_TSC_XGXS_CL72_DEBUG_3r_SET(r,d) (r).cl72_debug_3[0] = d
#define BCMI_TSC_XGXS_CL72_DEBUG_3r_GET(r) (r).cl72_debug_3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CL72_DEBUG_3r_RESERVED0f_GET(r) ((((r).cl72_debug_3[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_CL72_DEBUG_3r_RESERVED0f_SET(r,f) (r).cl72_debug_3[0]=(((r).cl72_debug_3[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_CL72_DEBUG_3r_CTRL_FRAME_DLYf_GET(r) ((((r).cl72_debug_3[0]) >> 11) & 0xf)
#define BCMI_TSC_XGXS_CL72_DEBUG_3r_CTRL_FRAME_DLYf_SET(r,f) (r).cl72_debug_3[0]=(((r).cl72_debug_3[0] & ~((uint32_t)0xf << 11)) | ((((uint32_t)f) & 0xf) << 11))
#define BCMI_TSC_XGXS_CL72_DEBUG_3r_RANDOM_SEEDf_GET(r) (((r).cl72_debug_3[0]) & 0x7ff)
#define BCMI_TSC_XGXS_CL72_DEBUG_3r_RANDOM_SEEDf_SET(r,f) (r).cl72_debug_3[0]=(((r).cl72_debug_3[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))

/*
 * These macros can be used to access CL72_DEBUG_3.
 *
 */
#define BCMI_TSC_XGXS_READ_CL72_DEBUG_3r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CL72_DEBUG_3r,(_r._cl72_debug_3))
#define BCMI_TSC_XGXS_WRITE_CL72_DEBUG_3r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CL72_DEBUG_3r,(_r._cl72_debug_3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL72_DEBUG_3r BCMI_TSC_XGXS_CL72_DEBUG_3r
#define CL72_DEBUG_3r_SIZE BCMI_TSC_XGXS_CL72_DEBUG_3r_SIZE
typedef BCMI_TSC_XGXS_CL72_DEBUG_3r_t CL72_DEBUG_3r_t;
#define CL72_DEBUG_3r_CLR BCMI_TSC_XGXS_CL72_DEBUG_3r_CLR
#define CL72_DEBUG_3r_SET BCMI_TSC_XGXS_CL72_DEBUG_3r_SET
#define CL72_DEBUG_3r_GET BCMI_TSC_XGXS_CL72_DEBUG_3r_GET
#define CL72_DEBUG_3r_RESERVED0f_GET BCMI_TSC_XGXS_CL72_DEBUG_3r_RESERVED0f_GET
#define CL72_DEBUG_3r_RESERVED0f_SET BCMI_TSC_XGXS_CL72_DEBUG_3r_RESERVED0f_SET
#define CL72_DEBUG_3r_CTRL_FRAME_DLYf_GET BCMI_TSC_XGXS_CL72_DEBUG_3r_CTRL_FRAME_DLYf_GET
#define CL72_DEBUG_3r_CTRL_FRAME_DLYf_SET BCMI_TSC_XGXS_CL72_DEBUG_3r_CTRL_FRAME_DLYf_SET
#define CL72_DEBUG_3r_RANDOM_SEEDf_GET BCMI_TSC_XGXS_CL72_DEBUG_3r_RANDOM_SEEDf_GET
#define CL72_DEBUG_3r_RANDOM_SEEDf_SET BCMI_TSC_XGXS_CL72_DEBUG_3r_RANDOM_SEEDf_SET
#define READ_CL72_DEBUG_3r BCMI_TSC_XGXS_READ_CL72_DEBUG_3r
#define WRITE_CL72_DEBUG_3r BCMI_TSC_XGXS_WRITE_CL72_DEBUG_3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CL72_DEBUG_3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CL72_DEBUG_4
 * BLOCKS:   CL72
 * REGADDR:  0xc258
 * DESC:     CL72 Debug 4 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     PPM_OFFSET_EN    
 *     RESERVED2        
 *     SIGDET_FORCE     
 *     RESERVED1        
 *     TAP_V2_VAL       
 *     V2_CONSTRAINT_DIS 
 *     BRCM_MODE_FORCEVAL 
 *     BRCM_MODE_FORCE  
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CL72_DEBUG_4r (0x0000c258 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CL72_DEBUG_4r_SIZE 4

/*
 * This structure should be used to declare and program CL72_DEBUG_4.
 *
 */
typedef union BCMI_TSC_XGXS_CL72_DEBUG_4r_s {
	uint32_t v[1];
	uint32_t cl72_debug_4[1];
	uint32_t _cl72_debug_4;
} BCMI_TSC_XGXS_CL72_DEBUG_4r_t;

#define BCMI_TSC_XGXS_CL72_DEBUG_4r_CLR(r) (r).cl72_debug_4[0] = 0
#define BCMI_TSC_XGXS_CL72_DEBUG_4r_SET(r,d) (r).cl72_debug_4[0] = d
#define BCMI_TSC_XGXS_CL72_DEBUG_4r_GET(r) (r).cl72_debug_4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CL72_DEBUG_4r_RESERVED0f_GET(r) ((((r).cl72_debug_4[0]) >> 14) & 0x3)
#define BCMI_TSC_XGXS_CL72_DEBUG_4r_RESERVED0f_SET(r,f) (r).cl72_debug_4[0]=(((r).cl72_debug_4[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCMI_TSC_XGXS_CL72_DEBUG_4r_BRCM_MODE_FORCEf_GET(r) ((((r).cl72_debug_4[0]) >> 13) & 0x1)
#define BCMI_TSC_XGXS_CL72_DEBUG_4r_BRCM_MODE_FORCEf_SET(r,f) (r).cl72_debug_4[0]=(((r).cl72_debug_4[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCMI_TSC_XGXS_CL72_DEBUG_4r_BRCM_MODE_FORCEVALf_GET(r) ((((r).cl72_debug_4[0]) >> 12) & 0x1)
#define BCMI_TSC_XGXS_CL72_DEBUG_4r_BRCM_MODE_FORCEVALf_SET(r,f) (r).cl72_debug_4[0]=(((r).cl72_debug_4[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCMI_TSC_XGXS_CL72_DEBUG_4r_V2_CONSTRAINT_DISf_GET(r) ((((r).cl72_debug_4[0]) >> 11) & 0x1)
#define BCMI_TSC_XGXS_CL72_DEBUG_4r_V2_CONSTRAINT_DISf_SET(r,f) (r).cl72_debug_4[0]=(((r).cl72_debug_4[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCMI_TSC_XGXS_CL72_DEBUG_4r_TAP_V2_VALf_GET(r) ((((r).cl72_debug_4[0]) >> 6) & 0x1f)
#define BCMI_TSC_XGXS_CL72_DEBUG_4r_TAP_V2_VALf_SET(r,f) (r).cl72_debug_4[0]=(((r).cl72_debug_4[0] & ~((uint32_t)0x1f << 6)) | ((((uint32_t)f) & 0x1f) << 6))
#define BCMI_TSC_XGXS_CL72_DEBUG_4r_RESERVED1f_GET(r) ((((r).cl72_debug_4[0]) >> 4) & 0x3)
#define BCMI_TSC_XGXS_CL72_DEBUG_4r_RESERVED1f_SET(r,f) (r).cl72_debug_4[0]=(((r).cl72_debug_4[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCMI_TSC_XGXS_CL72_DEBUG_4r_SIGDET_FORCEf_GET(r) ((((r).cl72_debug_4[0]) >> 3) & 0x1)
#define BCMI_TSC_XGXS_CL72_DEBUG_4r_SIGDET_FORCEf_SET(r,f) (r).cl72_debug_4[0]=(((r).cl72_debug_4[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCMI_TSC_XGXS_CL72_DEBUG_4r_RESERVED2f_GET(r) ((((r).cl72_debug_4[0]) >> 1) & 0x3)
#define BCMI_TSC_XGXS_CL72_DEBUG_4r_RESERVED2f_SET(r,f) (r).cl72_debug_4[0]=(((r).cl72_debug_4[0] & ~((uint32_t)0x3 << 1)) | ((((uint32_t)f) & 0x3) << 1))
#define BCMI_TSC_XGXS_CL72_DEBUG_4r_PPM_OFFSET_ENf_GET(r) (((r).cl72_debug_4[0]) & 0x1)
#define BCMI_TSC_XGXS_CL72_DEBUG_4r_PPM_OFFSET_ENf_SET(r,f) (r).cl72_debug_4[0]=(((r).cl72_debug_4[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access CL72_DEBUG_4.
 *
 */
#define BCMI_TSC_XGXS_READ_CL72_DEBUG_4r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CL72_DEBUG_4r,(_r._cl72_debug_4))
#define BCMI_TSC_XGXS_WRITE_CL72_DEBUG_4r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CL72_DEBUG_4r,(_r._cl72_debug_4))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL72_DEBUG_4r BCMI_TSC_XGXS_CL72_DEBUG_4r
#define CL72_DEBUG_4r_SIZE BCMI_TSC_XGXS_CL72_DEBUG_4r_SIZE
typedef BCMI_TSC_XGXS_CL72_DEBUG_4r_t CL72_DEBUG_4r_t;
#define CL72_DEBUG_4r_CLR BCMI_TSC_XGXS_CL72_DEBUG_4r_CLR
#define CL72_DEBUG_4r_SET BCMI_TSC_XGXS_CL72_DEBUG_4r_SET
#define CL72_DEBUG_4r_GET BCMI_TSC_XGXS_CL72_DEBUG_4r_GET
#define CL72_DEBUG_4r_RESERVED0f_GET BCMI_TSC_XGXS_CL72_DEBUG_4r_RESERVED0f_GET
#define CL72_DEBUG_4r_RESERVED0f_SET BCMI_TSC_XGXS_CL72_DEBUG_4r_RESERVED0f_SET
#define CL72_DEBUG_4r_BRCM_MODE_FORCEf_GET BCMI_TSC_XGXS_CL72_DEBUG_4r_BRCM_MODE_FORCEf_GET
#define CL72_DEBUG_4r_BRCM_MODE_FORCEf_SET BCMI_TSC_XGXS_CL72_DEBUG_4r_BRCM_MODE_FORCEf_SET
#define CL72_DEBUG_4r_BRCM_MODE_FORCEVALf_GET BCMI_TSC_XGXS_CL72_DEBUG_4r_BRCM_MODE_FORCEVALf_GET
#define CL72_DEBUG_4r_BRCM_MODE_FORCEVALf_SET BCMI_TSC_XGXS_CL72_DEBUG_4r_BRCM_MODE_FORCEVALf_SET
#define CL72_DEBUG_4r_V2_CONSTRAINT_DISf_GET BCMI_TSC_XGXS_CL72_DEBUG_4r_V2_CONSTRAINT_DISf_GET
#define CL72_DEBUG_4r_V2_CONSTRAINT_DISf_SET BCMI_TSC_XGXS_CL72_DEBUG_4r_V2_CONSTRAINT_DISf_SET
#define CL72_DEBUG_4r_TAP_V2_VALf_GET BCMI_TSC_XGXS_CL72_DEBUG_4r_TAP_V2_VALf_GET
#define CL72_DEBUG_4r_TAP_V2_VALf_SET BCMI_TSC_XGXS_CL72_DEBUG_4r_TAP_V2_VALf_SET
#define CL72_DEBUG_4r_RESERVED1f_GET BCMI_TSC_XGXS_CL72_DEBUG_4r_RESERVED1f_GET
#define CL72_DEBUG_4r_RESERVED1f_SET BCMI_TSC_XGXS_CL72_DEBUG_4r_RESERVED1f_SET
#define CL72_DEBUG_4r_SIGDET_FORCEf_GET BCMI_TSC_XGXS_CL72_DEBUG_4r_SIGDET_FORCEf_GET
#define CL72_DEBUG_4r_SIGDET_FORCEf_SET BCMI_TSC_XGXS_CL72_DEBUG_4r_SIGDET_FORCEf_SET
#define CL72_DEBUG_4r_RESERVED2f_GET BCMI_TSC_XGXS_CL72_DEBUG_4r_RESERVED2f_GET
#define CL72_DEBUG_4r_RESERVED2f_SET BCMI_TSC_XGXS_CL72_DEBUG_4r_RESERVED2f_SET
#define CL72_DEBUG_4r_PPM_OFFSET_ENf_GET BCMI_TSC_XGXS_CL72_DEBUG_4r_PPM_OFFSET_ENf_GET
#define CL72_DEBUG_4r_PPM_OFFSET_ENf_SET BCMI_TSC_XGXS_CL72_DEBUG_4r_PPM_OFFSET_ENf_SET
#define READ_CL72_DEBUG_4r BCMI_TSC_XGXS_READ_CL72_DEBUG_4r
#define WRITE_CL72_DEBUG_4r BCMI_TSC_XGXS_WRITE_CL72_DEBUG_4r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CL72_DEBUG_4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CL72_LD_STATUS_PAGE
 * BLOCKS:   CL72
 * REGADDR:  0xc259
 * DESC:     : 00000000
 * SIZE:     32
 * FIELDS:
 *     LD_STATUS_PAGE   
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CL72_LD_STATUS_PAGEr (0x0000c259 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CL72_LD_STATUS_PAGEr_SIZE 4

/*
 * This structure should be used to declare and program CL72_LD_STATUS_PAGE.
 *
 */
typedef union BCMI_TSC_XGXS_CL72_LD_STATUS_PAGEr_s {
	uint32_t v[1];
	uint32_t cl72_ld_status_page[1];
	uint32_t _cl72_ld_status_page;
} BCMI_TSC_XGXS_CL72_LD_STATUS_PAGEr_t;

#define BCMI_TSC_XGXS_CL72_LD_STATUS_PAGEr_CLR(r) (r).cl72_ld_status_page[0] = 0
#define BCMI_TSC_XGXS_CL72_LD_STATUS_PAGEr_SET(r,d) (r).cl72_ld_status_page[0] = d
#define BCMI_TSC_XGXS_CL72_LD_STATUS_PAGEr_GET(r) (r).cl72_ld_status_page[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CL72_LD_STATUS_PAGEr_LD_STATUS_PAGEf_GET(r) (((r).cl72_ld_status_page[0]) & 0xffff)
#define BCMI_TSC_XGXS_CL72_LD_STATUS_PAGEr_LD_STATUS_PAGEf_SET(r,f) (r).cl72_ld_status_page[0]=(((r).cl72_ld_status_page[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access CL72_LD_STATUS_PAGE.
 *
 */
#define BCMI_TSC_XGXS_READ_CL72_LD_STATUS_PAGEr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CL72_LD_STATUS_PAGEr,(_r._cl72_ld_status_page))
#define BCMI_TSC_XGXS_WRITE_CL72_LD_STATUS_PAGEr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CL72_LD_STATUS_PAGEr,(_r._cl72_ld_status_page))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL72_LD_STATUS_PAGEr BCMI_TSC_XGXS_CL72_LD_STATUS_PAGEr
#define CL72_LD_STATUS_PAGEr_SIZE BCMI_TSC_XGXS_CL72_LD_STATUS_PAGEr_SIZE
typedef BCMI_TSC_XGXS_CL72_LD_STATUS_PAGEr_t CL72_LD_STATUS_PAGEr_t;
#define CL72_LD_STATUS_PAGEr_CLR BCMI_TSC_XGXS_CL72_LD_STATUS_PAGEr_CLR
#define CL72_LD_STATUS_PAGEr_SET BCMI_TSC_XGXS_CL72_LD_STATUS_PAGEr_SET
#define CL72_LD_STATUS_PAGEr_GET BCMI_TSC_XGXS_CL72_LD_STATUS_PAGEr_GET
#define CL72_LD_STATUS_PAGEr_LD_STATUS_PAGEf_GET BCMI_TSC_XGXS_CL72_LD_STATUS_PAGEr_LD_STATUS_PAGEf_GET
#define CL72_LD_STATUS_PAGEr_LD_STATUS_PAGEf_SET BCMI_TSC_XGXS_CL72_LD_STATUS_PAGEr_LD_STATUS_PAGEf_SET
#define READ_CL72_LD_STATUS_PAGEr BCMI_TSC_XGXS_READ_CL72_LD_STATUS_PAGEr
#define WRITE_CL72_LD_STATUS_PAGEr BCMI_TSC_XGXS_WRITE_CL72_LD_STATUS_PAGEr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CL72_LD_STATUS_PAGEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CL72_LP_CONTROL_PAGE
 * BLOCKS:   CL72
 * REGADDR:  0xc25a
 * DESC:     : 00000000
 * SIZE:     32
 * FIELDS:
 *     LP_CONTROL_PAGE  
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CL72_LP_CONTROL_PAGEr (0x0000c25a | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CL72_LP_CONTROL_PAGEr_SIZE 4

/*
 * This structure should be used to declare and program CL72_LP_CONTROL_PAGE.
 *
 */
typedef union BCMI_TSC_XGXS_CL72_LP_CONTROL_PAGEr_s {
	uint32_t v[1];
	uint32_t cl72_lp_control_page[1];
	uint32_t _cl72_lp_control_page;
} BCMI_TSC_XGXS_CL72_LP_CONTROL_PAGEr_t;

#define BCMI_TSC_XGXS_CL72_LP_CONTROL_PAGEr_CLR(r) (r).cl72_lp_control_page[0] = 0
#define BCMI_TSC_XGXS_CL72_LP_CONTROL_PAGEr_SET(r,d) (r).cl72_lp_control_page[0] = d
#define BCMI_TSC_XGXS_CL72_LP_CONTROL_PAGEr_GET(r) (r).cl72_lp_control_page[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CL72_LP_CONTROL_PAGEr_LP_CONTROL_PAGEf_GET(r) (((r).cl72_lp_control_page[0]) & 0xffff)
#define BCMI_TSC_XGXS_CL72_LP_CONTROL_PAGEr_LP_CONTROL_PAGEf_SET(r,f) (r).cl72_lp_control_page[0]=(((r).cl72_lp_control_page[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access CL72_LP_CONTROL_PAGE.
 *
 */
#define BCMI_TSC_XGXS_READ_CL72_LP_CONTROL_PAGEr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CL72_LP_CONTROL_PAGEr,(_r._cl72_lp_control_page))
#define BCMI_TSC_XGXS_WRITE_CL72_LP_CONTROL_PAGEr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CL72_LP_CONTROL_PAGEr,(_r._cl72_lp_control_page))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL72_LP_CONTROL_PAGEr BCMI_TSC_XGXS_CL72_LP_CONTROL_PAGEr
#define CL72_LP_CONTROL_PAGEr_SIZE BCMI_TSC_XGXS_CL72_LP_CONTROL_PAGEr_SIZE
typedef BCMI_TSC_XGXS_CL72_LP_CONTROL_PAGEr_t CL72_LP_CONTROL_PAGEr_t;
#define CL72_LP_CONTROL_PAGEr_CLR BCMI_TSC_XGXS_CL72_LP_CONTROL_PAGEr_CLR
#define CL72_LP_CONTROL_PAGEr_SET BCMI_TSC_XGXS_CL72_LP_CONTROL_PAGEr_SET
#define CL72_LP_CONTROL_PAGEr_GET BCMI_TSC_XGXS_CL72_LP_CONTROL_PAGEr_GET
#define CL72_LP_CONTROL_PAGEr_LP_CONTROL_PAGEf_GET BCMI_TSC_XGXS_CL72_LP_CONTROL_PAGEr_LP_CONTROL_PAGEf_GET
#define CL72_LP_CONTROL_PAGEr_LP_CONTROL_PAGEf_SET BCMI_TSC_XGXS_CL72_LP_CONTROL_PAGEr_LP_CONTROL_PAGEf_SET
#define READ_CL72_LP_CONTROL_PAGEr BCMI_TSC_XGXS_READ_CL72_LP_CONTROL_PAGEr
#define WRITE_CL72_LP_CONTROL_PAGEr BCMI_TSC_XGXS_WRITE_CL72_LP_CONTROL_PAGEr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CL72_LP_CONTROL_PAGEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CL72_NEWPG_RCVD_OVERRIDE_PAGE
 * BLOCKS:   CL72
 * REGADDR:  0xc25b
 * DESC:     : 00000000
 * SIZE:     32
 * FIELDS:
 *     OVERRIDE_LP_CONTROL_PAGE 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CL72_NEWPG_RCVD_OVERRIDE_PAGEr (0x0000c25b | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CL72_NEWPG_RCVD_OVERRIDE_PAGEr_SIZE 4

/*
 * This structure should be used to declare and program CL72_NEWPG_RCVD_OVERRIDE_PAGE.
 *
 */
typedef union BCMI_TSC_XGXS_CL72_NEWPG_RCVD_OVERRIDE_PAGEr_s {
	uint32_t v[1];
	uint32_t cl72_newpg_rcvd_override_page[1];
	uint32_t _cl72_newpg_rcvd_override_page;
} BCMI_TSC_XGXS_CL72_NEWPG_RCVD_OVERRIDE_PAGEr_t;

#define BCMI_TSC_XGXS_CL72_NEWPG_RCVD_OVERRIDE_PAGEr_CLR(r) (r).cl72_newpg_rcvd_override_page[0] = 0
#define BCMI_TSC_XGXS_CL72_NEWPG_RCVD_OVERRIDE_PAGEr_SET(r,d) (r).cl72_newpg_rcvd_override_page[0] = d
#define BCMI_TSC_XGXS_CL72_NEWPG_RCVD_OVERRIDE_PAGEr_GET(r) (r).cl72_newpg_rcvd_override_page[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CL72_NEWPG_RCVD_OVERRIDE_PAGEr_OVERRIDE_LP_CONTROL_PAGEf_GET(r) (((r).cl72_newpg_rcvd_override_page[0]) & 0xffff)
#define BCMI_TSC_XGXS_CL72_NEWPG_RCVD_OVERRIDE_PAGEr_OVERRIDE_LP_CONTROL_PAGEf_SET(r,f) (r).cl72_newpg_rcvd_override_page[0]=(((r).cl72_newpg_rcvd_override_page[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access CL72_NEWPG_RCVD_OVERRIDE_PAGE.
 *
 */
#define BCMI_TSC_XGXS_READ_CL72_NEWPG_RCVD_OVERRIDE_PAGEr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CL72_NEWPG_RCVD_OVERRIDE_PAGEr,(_r._cl72_newpg_rcvd_override_page))
#define BCMI_TSC_XGXS_WRITE_CL72_NEWPG_RCVD_OVERRIDE_PAGEr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CL72_NEWPG_RCVD_OVERRIDE_PAGEr,(_r._cl72_newpg_rcvd_override_page))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL72_NEWPG_RCVD_OVERRIDE_PAGEr BCMI_TSC_XGXS_CL72_NEWPG_RCVD_OVERRIDE_PAGEr
#define CL72_NEWPG_RCVD_OVERRIDE_PAGEr_SIZE BCMI_TSC_XGXS_CL72_NEWPG_RCVD_OVERRIDE_PAGEr_SIZE
typedef BCMI_TSC_XGXS_CL72_NEWPG_RCVD_OVERRIDE_PAGEr_t CL72_NEWPG_RCVD_OVERRIDE_PAGEr_t;
#define CL72_NEWPG_RCVD_OVERRIDE_PAGEr_CLR BCMI_TSC_XGXS_CL72_NEWPG_RCVD_OVERRIDE_PAGEr_CLR
#define CL72_NEWPG_RCVD_OVERRIDE_PAGEr_SET BCMI_TSC_XGXS_CL72_NEWPG_RCVD_OVERRIDE_PAGEr_SET
#define CL72_NEWPG_RCVD_OVERRIDE_PAGEr_GET BCMI_TSC_XGXS_CL72_NEWPG_RCVD_OVERRIDE_PAGEr_GET
#define CL72_NEWPG_RCVD_OVERRIDE_PAGEr_OVERRIDE_LP_CONTROL_PAGEf_GET BCMI_TSC_XGXS_CL72_NEWPG_RCVD_OVERRIDE_PAGEr_OVERRIDE_LP_CONTROL_PAGEf_GET
#define CL72_NEWPG_RCVD_OVERRIDE_PAGEr_OVERRIDE_LP_CONTROL_PAGEf_SET BCMI_TSC_XGXS_CL72_NEWPG_RCVD_OVERRIDE_PAGEr_OVERRIDE_LP_CONTROL_PAGEf_SET
#define READ_CL72_NEWPG_RCVD_OVERRIDE_PAGEr BCMI_TSC_XGXS_READ_CL72_NEWPG_RCVD_OVERRIDE_PAGEr
#define WRITE_CL72_NEWPG_RCVD_OVERRIDE_PAGEr BCMI_TSC_XGXS_WRITE_CL72_NEWPG_RCVD_OVERRIDE_PAGEr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CL72_NEWPG_RCVD_OVERRIDE_PAGEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CL72_READY_FOR_CMD
 * BLOCKS:   CL72
 * REGADDR:  0xc25c
 * DESC:     : 00000000
 * SIZE:     32
 * FIELDS:
 *     CL72_READY_FOR_CMD 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CL72_READY_FOR_CMDr (0x0000c25c | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CL72_READY_FOR_CMDr_SIZE 4

/*
 * This structure should be used to declare and program CL72_READY_FOR_CMD.
 *
 */
typedef union BCMI_TSC_XGXS_CL72_READY_FOR_CMDr_s {
	uint32_t v[1];
	uint32_t cl72_ready_for_cmd[1];
	uint32_t _cl72_ready_for_cmd;
} BCMI_TSC_XGXS_CL72_READY_FOR_CMDr_t;

#define BCMI_TSC_XGXS_CL72_READY_FOR_CMDr_CLR(r) (r).cl72_ready_for_cmd[0] = 0
#define BCMI_TSC_XGXS_CL72_READY_FOR_CMDr_SET(r,d) (r).cl72_ready_for_cmd[0] = d
#define BCMI_TSC_XGXS_CL72_READY_FOR_CMDr_GET(r) (r).cl72_ready_for_cmd[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CL72_READY_FOR_CMDr_RESERVED0f_GET(r) ((((r).cl72_ready_for_cmd[0]) >> 1) & 0x7fff)
#define BCMI_TSC_XGXS_CL72_READY_FOR_CMDr_RESERVED0f_SET(r,f) (r).cl72_ready_for_cmd[0]=(((r).cl72_ready_for_cmd[0] & ~((uint32_t)0x7fff << 1)) | ((((uint32_t)f) & 0x7fff) << 1))
#define BCMI_TSC_XGXS_CL72_READY_FOR_CMDr_CL72_READY_FOR_CMDf_GET(r) (((r).cl72_ready_for_cmd[0]) & 0x1)
#define BCMI_TSC_XGXS_CL72_READY_FOR_CMDr_CL72_READY_FOR_CMDf_SET(r,f) (r).cl72_ready_for_cmd[0]=(((r).cl72_ready_for_cmd[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access CL72_READY_FOR_CMD.
 *
 */
#define BCMI_TSC_XGXS_READ_CL72_READY_FOR_CMDr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CL72_READY_FOR_CMDr,(_r._cl72_ready_for_cmd))
#define BCMI_TSC_XGXS_WRITE_CL72_READY_FOR_CMDr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CL72_READY_FOR_CMDr,(_r._cl72_ready_for_cmd))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL72_READY_FOR_CMDr BCMI_TSC_XGXS_CL72_READY_FOR_CMDr
#define CL72_READY_FOR_CMDr_SIZE BCMI_TSC_XGXS_CL72_READY_FOR_CMDr_SIZE
typedef BCMI_TSC_XGXS_CL72_READY_FOR_CMDr_t CL72_READY_FOR_CMDr_t;
#define CL72_READY_FOR_CMDr_CLR BCMI_TSC_XGXS_CL72_READY_FOR_CMDr_CLR
#define CL72_READY_FOR_CMDr_SET BCMI_TSC_XGXS_CL72_READY_FOR_CMDr_SET
#define CL72_READY_FOR_CMDr_GET BCMI_TSC_XGXS_CL72_READY_FOR_CMDr_GET
#define CL72_READY_FOR_CMDr_RESERVED0f_GET BCMI_TSC_XGXS_CL72_READY_FOR_CMDr_RESERVED0f_GET
#define CL72_READY_FOR_CMDr_RESERVED0f_SET BCMI_TSC_XGXS_CL72_READY_FOR_CMDr_RESERVED0f_SET
#define CL72_READY_FOR_CMDr_CL72_READY_FOR_CMDf_GET BCMI_TSC_XGXS_CL72_READY_FOR_CMDr_CL72_READY_FOR_CMDf_GET
#define CL72_READY_FOR_CMDr_CL72_READY_FOR_CMDf_SET BCMI_TSC_XGXS_CL72_READY_FOR_CMDr_CL72_READY_FOR_CMDf_SET
#define READ_CL72_READY_FOR_CMDr BCMI_TSC_XGXS_READ_CL72_READY_FOR_CMDr
#define WRITE_CL72_READY_FOR_CMDr BCMI_TSC_XGXS_WRITE_CL72_READY_FOR_CMDr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CL72_READY_FOR_CMDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  FIRMWARE_MODE
 * BLOCKS:   UCSS_X4
 * REGADDR:  0xc260
 * DESC:     Micro-controller firmware_mode Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     FIRMWARE_MODE    
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_FIRMWARE_MODEr (0x0000c260 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_FIRMWARE_MODEr_SIZE 4

/*
 * This structure should be used to declare and program FIRMWARE_MODE.
 *
 */
typedef union BCMI_TSC_XGXS_FIRMWARE_MODEr_s {
	uint32_t v[1];
	uint32_t firmware_mode[1];
	uint32_t _firmware_mode;
} BCMI_TSC_XGXS_FIRMWARE_MODEr_t;

#define BCMI_TSC_XGXS_FIRMWARE_MODEr_CLR(r) (r).firmware_mode[0] = 0
#define BCMI_TSC_XGXS_FIRMWARE_MODEr_SET(r,d) (r).firmware_mode[0] = d
#define BCMI_TSC_XGXS_FIRMWARE_MODEr_GET(r) (r).firmware_mode[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_FIRMWARE_MODEr_RESERVED0f_GET(r) ((((r).firmware_mode[0]) >> 4) & 0xfff)
#define BCMI_TSC_XGXS_FIRMWARE_MODEr_RESERVED0f_SET(r,f) (r).firmware_mode[0]=(((r).firmware_mode[0] & ~((uint32_t)0xfff << 4)) | ((((uint32_t)f) & 0xfff) << 4))
#define BCMI_TSC_XGXS_FIRMWARE_MODEr_FIRMWARE_MODEf_GET(r) (((r).firmware_mode[0]) & 0xf)
#define BCMI_TSC_XGXS_FIRMWARE_MODEr_FIRMWARE_MODEf_SET(r,f) (r).firmware_mode[0]=(((r).firmware_mode[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access FIRMWARE_MODE.
 *
 */
#define BCMI_TSC_XGXS_READ_FIRMWARE_MODEr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_FIRMWARE_MODEr,(_r._firmware_mode))
#define BCMI_TSC_XGXS_WRITE_FIRMWARE_MODEr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_FIRMWARE_MODEr,(_r._firmware_mode))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define FIRMWARE_MODEr BCMI_TSC_XGXS_FIRMWARE_MODEr
#define FIRMWARE_MODEr_SIZE BCMI_TSC_XGXS_FIRMWARE_MODEr_SIZE
typedef BCMI_TSC_XGXS_FIRMWARE_MODEr_t FIRMWARE_MODEr_t;
#define FIRMWARE_MODEr_CLR BCMI_TSC_XGXS_FIRMWARE_MODEr_CLR
#define FIRMWARE_MODEr_SET BCMI_TSC_XGXS_FIRMWARE_MODEr_SET
#define FIRMWARE_MODEr_GET BCMI_TSC_XGXS_FIRMWARE_MODEr_GET
#define FIRMWARE_MODEr_RESERVED0f_GET BCMI_TSC_XGXS_FIRMWARE_MODEr_RESERVED0f_GET
#define FIRMWARE_MODEr_RESERVED0f_SET BCMI_TSC_XGXS_FIRMWARE_MODEr_RESERVED0f_SET
#define FIRMWARE_MODEr_FIRMWARE_MODEf_GET BCMI_TSC_XGXS_FIRMWARE_MODEr_FIRMWARE_MODEf_GET
#define FIRMWARE_MODEr_FIRMWARE_MODEf_SET BCMI_TSC_XGXS_FIRMWARE_MODEr_FIRMWARE_MODEf_SET
#define READ_FIRMWARE_MODEr BCMI_TSC_XGXS_READ_FIRMWARE_MODEr
#define WRITE_FIRMWARE_MODEr BCMI_TSC_XGXS_WRITE_FIRMWARE_MODEr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_FIRMWARE_MODEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  GPIO_CTRL
 * BLOCKS:   UCSS_X4
 * REGADDR:  0xc261
 * DESC:     Micro-controller GPIO Control Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     GPIO_CTRL        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_GPIO_CTRLr (0x0000c261 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_GPIO_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program GPIO_CTRL.
 *
 */
typedef union BCMI_TSC_XGXS_GPIO_CTRLr_s {
	uint32_t v[1];
	uint32_t gpio_ctrl[1];
	uint32_t _gpio_ctrl;
} BCMI_TSC_XGXS_GPIO_CTRLr_t;

#define BCMI_TSC_XGXS_GPIO_CTRLr_CLR(r) (r).gpio_ctrl[0] = 0
#define BCMI_TSC_XGXS_GPIO_CTRLr_SET(r,d) (r).gpio_ctrl[0] = d
#define BCMI_TSC_XGXS_GPIO_CTRLr_GET(r) (r).gpio_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_GPIO_CTRLr_GPIO_CTRLf_GET(r) (((r).gpio_ctrl[0]) & 0xffff)
#define BCMI_TSC_XGXS_GPIO_CTRLr_GPIO_CTRLf_SET(r,f) (r).gpio_ctrl[0]=(((r).gpio_ctrl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access GPIO_CTRL.
 *
 */
#define BCMI_TSC_XGXS_READ_GPIO_CTRLr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_GPIO_CTRLr,(_r._gpio_ctrl))
#define BCMI_TSC_XGXS_WRITE_GPIO_CTRLr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_GPIO_CTRLr,(_r._gpio_ctrl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define GPIO_CTRLr BCMI_TSC_XGXS_GPIO_CTRLr
#define GPIO_CTRLr_SIZE BCMI_TSC_XGXS_GPIO_CTRLr_SIZE
typedef BCMI_TSC_XGXS_GPIO_CTRLr_t GPIO_CTRLr_t;
#define GPIO_CTRLr_CLR BCMI_TSC_XGXS_GPIO_CTRLr_CLR
#define GPIO_CTRLr_SET BCMI_TSC_XGXS_GPIO_CTRLr_SET
#define GPIO_CTRLr_GET BCMI_TSC_XGXS_GPIO_CTRLr_GET
#define GPIO_CTRLr_GPIO_CTRLf_GET BCMI_TSC_XGXS_GPIO_CTRLr_GPIO_CTRLf_GET
#define GPIO_CTRLr_GPIO_CTRLf_SET BCMI_TSC_XGXS_GPIO_CTRLr_GPIO_CTRLf_SET
#define READ_GPIO_CTRLr BCMI_TSC_XGXS_READ_GPIO_CTRLr
#define WRITE_GPIO_CTRLr BCMI_TSC_XGXS_WRITE_GPIO_CTRLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_GPIO_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  GPIO_STS
 * BLOCKS:   UCSS_X4
 * REGADDR:  0xc262
 * DESC:     Micro-controller GPIO Status Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     GPIO_STS         
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_GPIO_STSr (0x0000c262 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_GPIO_STSr_SIZE 4

/*
 * This structure should be used to declare and program GPIO_STS.
 *
 */
typedef union BCMI_TSC_XGXS_GPIO_STSr_s {
	uint32_t v[1];
	uint32_t gpio_sts[1];
	uint32_t _gpio_sts;
} BCMI_TSC_XGXS_GPIO_STSr_t;

#define BCMI_TSC_XGXS_GPIO_STSr_CLR(r) (r).gpio_sts[0] = 0
#define BCMI_TSC_XGXS_GPIO_STSr_SET(r,d) (r).gpio_sts[0] = d
#define BCMI_TSC_XGXS_GPIO_STSr_GET(r) (r).gpio_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_GPIO_STSr_GPIO_STSf_GET(r) (((r).gpio_sts[0]) & 0xffff)
#define BCMI_TSC_XGXS_GPIO_STSr_GPIO_STSf_SET(r,f) (r).gpio_sts[0]=(((r).gpio_sts[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access GPIO_STS.
 *
 */
#define BCMI_TSC_XGXS_READ_GPIO_STSr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_GPIO_STSr,(_r._gpio_sts))
#define BCMI_TSC_XGXS_WRITE_GPIO_STSr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_GPIO_STSr,(_r._gpio_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define GPIO_STSr BCMI_TSC_XGXS_GPIO_STSr
#define GPIO_STSr_SIZE BCMI_TSC_XGXS_GPIO_STSr_SIZE
typedef BCMI_TSC_XGXS_GPIO_STSr_t GPIO_STSr_t;
#define GPIO_STSr_CLR BCMI_TSC_XGXS_GPIO_STSr_CLR
#define GPIO_STSr_SET BCMI_TSC_XGXS_GPIO_STSr_SET
#define GPIO_STSr_GET BCMI_TSC_XGXS_GPIO_STSr_GET
#define GPIO_STSr_GPIO_STSf_GET BCMI_TSC_XGXS_GPIO_STSr_GPIO_STSf_GET
#define GPIO_STSr_GPIO_STSf_SET BCMI_TSC_XGXS_GPIO_STSr_GPIO_STSf_SET
#define READ_GPIO_STSr BCMI_TSC_XGXS_READ_GPIO_STSr
#define WRITE_GPIO_STSr BCMI_TSC_XGXS_WRITE_GPIO_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_GPIO_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  GPR_TYPE
 * BLOCKS:   UCSS_X4
 * REGADDR:  0xc263
 * DESC:     Micro-controller GPR Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     UC_GPR           
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_GPR_TYPEr (0x0000c263 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_GPR_TYPEr_SIZE 4

/*
 * This structure should be used to declare and program GPR_TYPE.
 *
 */
typedef union BCMI_TSC_XGXS_GPR_TYPEr_s {
	uint32_t v[1];
	uint32_t gpr_type[1];
	uint32_t _gpr_type;
} BCMI_TSC_XGXS_GPR_TYPEr_t;

#define BCMI_TSC_XGXS_GPR_TYPEr_CLR(r) (r).gpr_type[0] = 0
#define BCMI_TSC_XGXS_GPR_TYPEr_SET(r,d) (r).gpr_type[0] = d
#define BCMI_TSC_XGXS_GPR_TYPEr_GET(r) (r).gpr_type[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_GPR_TYPEr_UC_GPRf_GET(r) (((r).gpr_type[0]) & 0xffff)
#define BCMI_TSC_XGXS_GPR_TYPEr_UC_GPRf_SET(r,f) (r).gpr_type[0]=(((r).gpr_type[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access GPR_TYPE.
 *
 */
#define BCMI_TSC_XGXS_READ_GPR_TYPEr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_GPR_TYPEr,(_r._gpr_type))
#define BCMI_TSC_XGXS_WRITE_GPR_TYPEr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_GPR_TYPEr,(_r._gpr_type))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define GPR_TYPEr BCMI_TSC_XGXS_GPR_TYPEr
#define GPR_TYPEr_SIZE BCMI_TSC_XGXS_GPR_TYPEr_SIZE
typedef BCMI_TSC_XGXS_GPR_TYPEr_t GPR_TYPEr_t;
#define GPR_TYPEr_CLR BCMI_TSC_XGXS_GPR_TYPEr_CLR
#define GPR_TYPEr_SET BCMI_TSC_XGXS_GPR_TYPEr_SET
#define GPR_TYPEr_GET BCMI_TSC_XGXS_GPR_TYPEr_GET
#define GPR_TYPEr_UC_GPRf_GET BCMI_TSC_XGXS_GPR_TYPEr_UC_GPRf_GET
#define GPR_TYPEr_UC_GPRf_SET BCMI_TSC_XGXS_GPR_TYPEr_UC_GPRf_SET
#define READ_GPR_TYPEr BCMI_TSC_XGXS_READ_GPR_TYPEr
#define WRITE_GPR_TYPEr BCMI_TSC_XGXS_WRITE_GPR_TYPEr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_GPR_TYPEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CONTROL1000X1
 * BLOCKS:   DIGITAL
 * REGADDR:  0xc300
 * DESC:     1000X control 1 register: 00000000
 * SIZE:     32
 * FIELDS:
 *     RESERVED1        
 *     COMMA_DET_EN     
 *     ZERO_COMMA_DETECTOR_PHASE 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CONTROL1000X1r (0x0000c300 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CONTROL1000X1r_SIZE 4

/*
 * This structure should be used to declare and program CONTROL1000X1.
 *
 */
typedef union BCMI_TSC_XGXS_CONTROL1000X1r_s {
	uint32_t v[1];
	uint32_t control1000x1[1];
	uint32_t _control1000x1;
} BCMI_TSC_XGXS_CONTROL1000X1r_t;

#define BCMI_TSC_XGXS_CONTROL1000X1r_CLR(r) (r).control1000x1[0] = 0
#define BCMI_TSC_XGXS_CONTROL1000X1r_SET(r,d) (r).control1000x1[0] = d
#define BCMI_TSC_XGXS_CONTROL1000X1r_GET(r) (r).control1000x1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CONTROL1000X1r_RESERVED0f_GET(r) ((((r).control1000x1[0]) >> 10) & 0x3f)
#define BCMI_TSC_XGXS_CONTROL1000X1r_RESERVED0f_SET(r,f) (r).control1000x1[0]=(((r).control1000x1[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))
#define BCMI_TSC_XGXS_CONTROL1000X1r_ZERO_COMMA_DETECTOR_PHASEf_GET(r) ((((r).control1000x1[0]) >> 9) & 0x1)
#define BCMI_TSC_XGXS_CONTROL1000X1r_ZERO_COMMA_DETECTOR_PHASEf_SET(r,f) (r).control1000x1[0]=(((r).control1000x1[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCMI_TSC_XGXS_CONTROL1000X1r_COMMA_DET_ENf_GET(r) ((((r).control1000x1[0]) >> 8) & 0x1)
#define BCMI_TSC_XGXS_CONTROL1000X1r_COMMA_DET_ENf_SET(r,f) (r).control1000x1[0]=(((r).control1000x1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCMI_TSC_XGXS_CONTROL1000X1r_RESERVED1f_GET(r) (((r).control1000x1[0]) & 0xff)
#define BCMI_TSC_XGXS_CONTROL1000X1r_RESERVED1f_SET(r,f) (r).control1000x1[0]=(((r).control1000x1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access CONTROL1000X1.
 *
 */
#define BCMI_TSC_XGXS_READ_CONTROL1000X1r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CONTROL1000X1r,(_r._control1000x1))
#define BCMI_TSC_XGXS_WRITE_CONTROL1000X1r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CONTROL1000X1r,(_r._control1000x1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CONTROL1000X1r BCMI_TSC_XGXS_CONTROL1000X1r
#define CONTROL1000X1r_SIZE BCMI_TSC_XGXS_CONTROL1000X1r_SIZE
typedef BCMI_TSC_XGXS_CONTROL1000X1r_t CONTROL1000X1r_t;
#define CONTROL1000X1r_CLR BCMI_TSC_XGXS_CONTROL1000X1r_CLR
#define CONTROL1000X1r_SET BCMI_TSC_XGXS_CONTROL1000X1r_SET
#define CONTROL1000X1r_GET BCMI_TSC_XGXS_CONTROL1000X1r_GET
#define CONTROL1000X1r_RESERVED0f_GET BCMI_TSC_XGXS_CONTROL1000X1r_RESERVED0f_GET
#define CONTROL1000X1r_RESERVED0f_SET BCMI_TSC_XGXS_CONTROL1000X1r_RESERVED0f_SET
#define CONTROL1000X1r_ZERO_COMMA_DETECTOR_PHASEf_GET BCMI_TSC_XGXS_CONTROL1000X1r_ZERO_COMMA_DETECTOR_PHASEf_GET
#define CONTROL1000X1r_ZERO_COMMA_DETECTOR_PHASEf_SET BCMI_TSC_XGXS_CONTROL1000X1r_ZERO_COMMA_DETECTOR_PHASEf_SET
#define CONTROL1000X1r_COMMA_DET_ENf_GET BCMI_TSC_XGXS_CONTROL1000X1r_COMMA_DET_ENf_GET
#define CONTROL1000X1r_COMMA_DET_ENf_SET BCMI_TSC_XGXS_CONTROL1000X1r_COMMA_DET_ENf_SET
#define CONTROL1000X1r_RESERVED1f_GET BCMI_TSC_XGXS_CONTROL1000X1r_RESERVED1f_GET
#define CONTROL1000X1r_RESERVED1f_SET BCMI_TSC_XGXS_CONTROL1000X1r_RESERVED1f_SET
#define READ_CONTROL1000X1r BCMI_TSC_XGXS_READ_CONTROL1000X1r
#define WRITE_CONTROL1000X1r BCMI_TSC_XGXS_WRITE_CONTROL1000X1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CONTROL1000X1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CONTROL1000X2
 * BLOCKS:   DIGITAL
 * REGADDR:  0xc301
 * DESC:     1000X control 2 register: 00000000
 * SIZE:     32
 * FIELDS:
 *     RESERVED2        
 *     FILTER_FORCE_LINK 
 *     ENABLE_AUTONEG_ERR_TIMER 
 *     DISABLE_REMOTE_FAULT_REPORTING 
 *     RESERVED1        
 *     DISABLE_CARRIER_EXTEND 
 *     DISABLE_TRRR_GENERATION 
 *     RESERVED0        
 *     CLEAR_BER_COUNTER 
 *     DISABLE_EXTEND_FDX_ONLY 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CONTROL1000X2r (0x0000c301 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CONTROL1000X2r_SIZE 4

/*
 * This structure should be used to declare and program CONTROL1000X2.
 *
 */
typedef union BCMI_TSC_XGXS_CONTROL1000X2r_s {
	uint32_t v[1];
	uint32_t control1000x2[1];
	uint32_t _control1000x2;
} BCMI_TSC_XGXS_CONTROL1000X2r_t;

#define BCMI_TSC_XGXS_CONTROL1000X2r_CLR(r) (r).control1000x2[0] = 0
#define BCMI_TSC_XGXS_CONTROL1000X2r_SET(r,d) (r).control1000x2[0] = d
#define BCMI_TSC_XGXS_CONTROL1000X2r_GET(r) (r).control1000x2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CONTROL1000X2r_DISABLE_EXTEND_FDX_ONLYf_GET(r) ((((r).control1000x2[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_CONTROL1000X2r_DISABLE_EXTEND_FDX_ONLYf_SET(r,f) (r).control1000x2[0]=(((r).control1000x2[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_CONTROL1000X2r_CLEAR_BER_COUNTERf_GET(r) ((((r).control1000x2[0]) >> 14) & 0x1)
#define BCMI_TSC_XGXS_CONTROL1000X2r_CLEAR_BER_COUNTERf_SET(r,f) (r).control1000x2[0]=(((r).control1000x2[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCMI_TSC_XGXS_CONTROL1000X2r_RESERVED0f_GET(r) ((((r).control1000x2[0]) >> 9) & 0x1f)
#define BCMI_TSC_XGXS_CONTROL1000X2r_RESERVED0f_SET(r,f) (r).control1000x2[0]=(((r).control1000x2[0] & ~((uint32_t)0x1f << 9)) | ((((uint32_t)f) & 0x1f) << 9))
#define BCMI_TSC_XGXS_CONTROL1000X2r_DISABLE_TRRR_GENERATIONf_GET(r) ((((r).control1000x2[0]) >> 8) & 0x1)
#define BCMI_TSC_XGXS_CONTROL1000X2r_DISABLE_TRRR_GENERATIONf_SET(r,f) (r).control1000x2[0]=(((r).control1000x2[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCMI_TSC_XGXS_CONTROL1000X2r_DISABLE_CARRIER_EXTENDf_GET(r) ((((r).control1000x2[0]) >> 7) & 0x1)
#define BCMI_TSC_XGXS_CONTROL1000X2r_DISABLE_CARRIER_EXTENDf_SET(r,f) (r).control1000x2[0]=(((r).control1000x2[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCMI_TSC_XGXS_CONTROL1000X2r_RESERVED1f_GET(r) ((((r).control1000x2[0]) >> 5) & 0x3)
#define BCMI_TSC_XGXS_CONTROL1000X2r_RESERVED1f_SET(r,f) (r).control1000x2[0]=(((r).control1000x2[0] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5))
#define BCMI_TSC_XGXS_CONTROL1000X2r_DISABLE_REMOTE_FAULT_REPORTINGf_GET(r) ((((r).control1000x2[0]) >> 4) & 0x1)
#define BCMI_TSC_XGXS_CONTROL1000X2r_DISABLE_REMOTE_FAULT_REPORTINGf_SET(r,f) (r).control1000x2[0]=(((r).control1000x2[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCMI_TSC_XGXS_CONTROL1000X2r_ENABLE_AUTONEG_ERR_TIMERf_GET(r) ((((r).control1000x2[0]) >> 3) & 0x1)
#define BCMI_TSC_XGXS_CONTROL1000X2r_ENABLE_AUTONEG_ERR_TIMERf_SET(r,f) (r).control1000x2[0]=(((r).control1000x2[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCMI_TSC_XGXS_CONTROL1000X2r_FILTER_FORCE_LINKf_GET(r) ((((r).control1000x2[0]) >> 2) & 0x1)
#define BCMI_TSC_XGXS_CONTROL1000X2r_FILTER_FORCE_LINKf_SET(r,f) (r).control1000x2[0]=(((r).control1000x2[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCMI_TSC_XGXS_CONTROL1000X2r_RESERVED2f_GET(r) (((r).control1000x2[0]) & 0x3)
#define BCMI_TSC_XGXS_CONTROL1000X2r_RESERVED2f_SET(r,f) (r).control1000x2[0]=(((r).control1000x2[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))

/*
 * These macros can be used to access CONTROL1000X2.
 *
 */
#define BCMI_TSC_XGXS_READ_CONTROL1000X2r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CONTROL1000X2r,(_r._control1000x2))
#define BCMI_TSC_XGXS_WRITE_CONTROL1000X2r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CONTROL1000X2r,(_r._control1000x2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CONTROL1000X2r BCMI_TSC_XGXS_CONTROL1000X2r
#define CONTROL1000X2r_SIZE BCMI_TSC_XGXS_CONTROL1000X2r_SIZE
typedef BCMI_TSC_XGXS_CONTROL1000X2r_t CONTROL1000X2r_t;
#define CONTROL1000X2r_CLR BCMI_TSC_XGXS_CONTROL1000X2r_CLR
#define CONTROL1000X2r_SET BCMI_TSC_XGXS_CONTROL1000X2r_SET
#define CONTROL1000X2r_GET BCMI_TSC_XGXS_CONTROL1000X2r_GET
#define CONTROL1000X2r_DISABLE_EXTEND_FDX_ONLYf_GET BCMI_TSC_XGXS_CONTROL1000X2r_DISABLE_EXTEND_FDX_ONLYf_GET
#define CONTROL1000X2r_DISABLE_EXTEND_FDX_ONLYf_SET BCMI_TSC_XGXS_CONTROL1000X2r_DISABLE_EXTEND_FDX_ONLYf_SET
#define CONTROL1000X2r_CLEAR_BER_COUNTERf_GET BCMI_TSC_XGXS_CONTROL1000X2r_CLEAR_BER_COUNTERf_GET
#define CONTROL1000X2r_CLEAR_BER_COUNTERf_SET BCMI_TSC_XGXS_CONTROL1000X2r_CLEAR_BER_COUNTERf_SET
#define CONTROL1000X2r_RESERVED0f_GET BCMI_TSC_XGXS_CONTROL1000X2r_RESERVED0f_GET
#define CONTROL1000X2r_RESERVED0f_SET BCMI_TSC_XGXS_CONTROL1000X2r_RESERVED0f_SET
#define CONTROL1000X2r_DISABLE_TRRR_GENERATIONf_GET BCMI_TSC_XGXS_CONTROL1000X2r_DISABLE_TRRR_GENERATIONf_GET
#define CONTROL1000X2r_DISABLE_TRRR_GENERATIONf_SET BCMI_TSC_XGXS_CONTROL1000X2r_DISABLE_TRRR_GENERATIONf_SET
#define CONTROL1000X2r_DISABLE_CARRIER_EXTENDf_GET BCMI_TSC_XGXS_CONTROL1000X2r_DISABLE_CARRIER_EXTENDf_GET
#define CONTROL1000X2r_DISABLE_CARRIER_EXTENDf_SET BCMI_TSC_XGXS_CONTROL1000X2r_DISABLE_CARRIER_EXTENDf_SET
#define CONTROL1000X2r_RESERVED1f_GET BCMI_TSC_XGXS_CONTROL1000X2r_RESERVED1f_GET
#define CONTROL1000X2r_RESERVED1f_SET BCMI_TSC_XGXS_CONTROL1000X2r_RESERVED1f_SET
#define CONTROL1000X2r_DISABLE_REMOTE_FAULT_REPORTINGf_GET BCMI_TSC_XGXS_CONTROL1000X2r_DISABLE_REMOTE_FAULT_REPORTINGf_GET
#define CONTROL1000X2r_DISABLE_REMOTE_FAULT_REPORTINGf_SET BCMI_TSC_XGXS_CONTROL1000X2r_DISABLE_REMOTE_FAULT_REPORTINGf_SET
#define CONTROL1000X2r_ENABLE_AUTONEG_ERR_TIMERf_GET BCMI_TSC_XGXS_CONTROL1000X2r_ENABLE_AUTONEG_ERR_TIMERf_GET
#define CONTROL1000X2r_ENABLE_AUTONEG_ERR_TIMERf_SET BCMI_TSC_XGXS_CONTROL1000X2r_ENABLE_AUTONEG_ERR_TIMERf_SET
#define CONTROL1000X2r_FILTER_FORCE_LINKf_GET BCMI_TSC_XGXS_CONTROL1000X2r_FILTER_FORCE_LINKf_GET
#define CONTROL1000X2r_FILTER_FORCE_LINKf_SET BCMI_TSC_XGXS_CONTROL1000X2r_FILTER_FORCE_LINKf_SET
#define CONTROL1000X2r_RESERVED2f_GET BCMI_TSC_XGXS_CONTROL1000X2r_RESERVED2f_GET
#define CONTROL1000X2r_RESERVED2f_SET BCMI_TSC_XGXS_CONTROL1000X2r_RESERVED2f_SET
#define READ_CONTROL1000X2r BCMI_TSC_XGXS_READ_CONTROL1000X2r
#define WRITE_CONTROL1000X2r BCMI_TSC_XGXS_WRITE_CONTROL1000X2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CONTROL1000X2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CONTROL1000X4
 * BLOCKS:   DIGITAL
 * REGADDR:  0xc303
 * DESC:     1000X control 4 register: 00000000
 * SIZE:     32
 * FIELDS:
 *     MISCRXSTATUS_SEL 
 *     RESERVED2        
 *     LINK_FORCE       
 *     LATCH_LINKDOWN_ENABLE 
 *     CLEAR_LINKDOWN   
 *     RESERVED1        
 *     TX_CONFIG_REG_SEL 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CONTROL1000X4r (0x0000c303 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CONTROL1000X4r_SIZE 4

/*
 * This structure should be used to declare and program CONTROL1000X4.
 *
 */
typedef union BCMI_TSC_XGXS_CONTROL1000X4r_s {
	uint32_t v[1];
	uint32_t control1000x4[1];
	uint32_t _control1000x4;
} BCMI_TSC_XGXS_CONTROL1000X4r_t;

#define BCMI_TSC_XGXS_CONTROL1000X4r_CLR(r) (r).control1000x4[0] = 0
#define BCMI_TSC_XGXS_CONTROL1000X4r_SET(r,d) (r).control1000x4[0] = d
#define BCMI_TSC_XGXS_CONTROL1000X4r_GET(r) (r).control1000x4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CONTROL1000X4r_RESERVED0f_GET(r) ((((r).control1000x4[0]) >> 12) & 0xf)
#define BCMI_TSC_XGXS_CONTROL1000X4r_RESERVED0f_SET(r,f) (r).control1000x4[0]=(((r).control1000x4[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCMI_TSC_XGXS_CONTROL1000X4r_TX_CONFIG_REG_SELf_GET(r) ((((r).control1000x4[0]) >> 11) & 0x1)
#define BCMI_TSC_XGXS_CONTROL1000X4r_TX_CONFIG_REG_SELf_SET(r,f) (r).control1000x4[0]=(((r).control1000x4[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCMI_TSC_XGXS_CONTROL1000X4r_RESERVED1f_GET(r) ((((r).control1000x4[0]) >> 10) & 0x1)
#define BCMI_TSC_XGXS_CONTROL1000X4r_RESERVED1f_SET(r,f) (r).control1000x4[0]=(((r).control1000x4[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCMI_TSC_XGXS_CONTROL1000X4r_CLEAR_LINKDOWNf_GET(r) ((((r).control1000x4[0]) >> 9) & 0x1)
#define BCMI_TSC_XGXS_CONTROL1000X4r_CLEAR_LINKDOWNf_SET(r,f) (r).control1000x4[0]=(((r).control1000x4[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCMI_TSC_XGXS_CONTROL1000X4r_LATCH_LINKDOWN_ENABLEf_GET(r) ((((r).control1000x4[0]) >> 8) & 0x1)
#define BCMI_TSC_XGXS_CONTROL1000X4r_LATCH_LINKDOWN_ENABLEf_SET(r,f) (r).control1000x4[0]=(((r).control1000x4[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCMI_TSC_XGXS_CONTROL1000X4r_LINK_FORCEf_GET(r) ((((r).control1000x4[0]) >> 7) & 0x1)
#define BCMI_TSC_XGXS_CONTROL1000X4r_LINK_FORCEf_SET(r,f) (r).control1000x4[0]=(((r).control1000x4[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCMI_TSC_XGXS_CONTROL1000X4r_RESERVED2f_GET(r) ((((r).control1000x4[0]) >> 3) & 0xf)
#define BCMI_TSC_XGXS_CONTROL1000X4r_RESERVED2f_SET(r,f) (r).control1000x4[0]=(((r).control1000x4[0] & ~((uint32_t)0xf << 3)) | ((((uint32_t)f) & 0xf) << 3))
#define BCMI_TSC_XGXS_CONTROL1000X4r_MISCRXSTATUS_SELf_GET(r) (((r).control1000x4[0]) & 0x7)
#define BCMI_TSC_XGXS_CONTROL1000X4r_MISCRXSTATUS_SELf_SET(r,f) (r).control1000x4[0]=(((r).control1000x4[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))

/*
 * These macros can be used to access CONTROL1000X4.
 *
 */
#define BCMI_TSC_XGXS_READ_CONTROL1000X4r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CONTROL1000X4r,(_r._control1000x4))
#define BCMI_TSC_XGXS_WRITE_CONTROL1000X4r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CONTROL1000X4r,(_r._control1000x4))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CONTROL1000X4r BCMI_TSC_XGXS_CONTROL1000X4r
#define CONTROL1000X4r_SIZE BCMI_TSC_XGXS_CONTROL1000X4r_SIZE
typedef BCMI_TSC_XGXS_CONTROL1000X4r_t CONTROL1000X4r_t;
#define CONTROL1000X4r_CLR BCMI_TSC_XGXS_CONTROL1000X4r_CLR
#define CONTROL1000X4r_SET BCMI_TSC_XGXS_CONTROL1000X4r_SET
#define CONTROL1000X4r_GET BCMI_TSC_XGXS_CONTROL1000X4r_GET
#define CONTROL1000X4r_RESERVED0f_GET BCMI_TSC_XGXS_CONTROL1000X4r_RESERVED0f_GET
#define CONTROL1000X4r_RESERVED0f_SET BCMI_TSC_XGXS_CONTROL1000X4r_RESERVED0f_SET
#define CONTROL1000X4r_TX_CONFIG_REG_SELf_GET BCMI_TSC_XGXS_CONTROL1000X4r_TX_CONFIG_REG_SELf_GET
#define CONTROL1000X4r_TX_CONFIG_REG_SELf_SET BCMI_TSC_XGXS_CONTROL1000X4r_TX_CONFIG_REG_SELf_SET
#define CONTROL1000X4r_RESERVED1f_GET BCMI_TSC_XGXS_CONTROL1000X4r_RESERVED1f_GET
#define CONTROL1000X4r_RESERVED1f_SET BCMI_TSC_XGXS_CONTROL1000X4r_RESERVED1f_SET
#define CONTROL1000X4r_CLEAR_LINKDOWNf_GET BCMI_TSC_XGXS_CONTROL1000X4r_CLEAR_LINKDOWNf_GET
#define CONTROL1000X4r_CLEAR_LINKDOWNf_SET BCMI_TSC_XGXS_CONTROL1000X4r_CLEAR_LINKDOWNf_SET
#define CONTROL1000X4r_LATCH_LINKDOWN_ENABLEf_GET BCMI_TSC_XGXS_CONTROL1000X4r_LATCH_LINKDOWN_ENABLEf_GET
#define CONTROL1000X4r_LATCH_LINKDOWN_ENABLEf_SET BCMI_TSC_XGXS_CONTROL1000X4r_LATCH_LINKDOWN_ENABLEf_SET
#define CONTROL1000X4r_LINK_FORCEf_GET BCMI_TSC_XGXS_CONTROL1000X4r_LINK_FORCEf_GET
#define CONTROL1000X4r_LINK_FORCEf_SET BCMI_TSC_XGXS_CONTROL1000X4r_LINK_FORCEf_SET
#define CONTROL1000X4r_RESERVED2f_GET BCMI_TSC_XGXS_CONTROL1000X4r_RESERVED2f_GET
#define CONTROL1000X4r_RESERVED2f_SET BCMI_TSC_XGXS_CONTROL1000X4r_RESERVED2f_SET
#define CONTROL1000X4r_MISCRXSTATUS_SELf_GET BCMI_TSC_XGXS_CONTROL1000X4r_MISCRXSTATUS_SELf_GET
#define CONTROL1000X4r_MISCRXSTATUS_SELf_SET BCMI_TSC_XGXS_CONTROL1000X4r_MISCRXSTATUS_SELf_SET
#define READ_CONTROL1000X4r BCMI_TSC_XGXS_READ_CONTROL1000X4r
#define WRITE_CONTROL1000X4r BCMI_TSC_XGXS_WRITE_CONTROL1000X4r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CONTROL1000X4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  STATUS1000X1
 * BLOCKS:   DIGITAL
 * REGADDR:  0xc304
 * DESC:     1000X status 1 register: 00000000
 * SIZE:     32
 * FIELDS:
 *     RESERVED2        
 *     LINK_STATUS_CHANGE 
 *     RESERVED1        
 *     RX_ERR_DETECTED  
 *     TX_ERR_DETECTED  
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_STATUS1000X1r (0x0000c304 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_STATUS1000X1r_SIZE 4

/*
 * This structure should be used to declare and program STATUS1000X1.
 *
 */
typedef union BCMI_TSC_XGXS_STATUS1000X1r_s {
	uint32_t v[1];
	uint32_t status1000x1[1];
	uint32_t _status1000x1;
} BCMI_TSC_XGXS_STATUS1000X1r_t;

#define BCMI_TSC_XGXS_STATUS1000X1r_CLR(r) (r).status1000x1[0] = 0
#define BCMI_TSC_XGXS_STATUS1000X1r_SET(r,d) (r).status1000x1[0] = d
#define BCMI_TSC_XGXS_STATUS1000X1r_GET(r) (r).status1000x1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_STATUS1000X1r_RESERVED0f_GET(r) ((((r).status1000x1[0]) >> 12) & 0xf)
#define BCMI_TSC_XGXS_STATUS1000X1r_RESERVED0f_SET(r,f) (r).status1000x1[0]=(((r).status1000x1[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCMI_TSC_XGXS_STATUS1000X1r_TX_ERR_DETECTEDf_GET(r) ((((r).status1000x1[0]) >> 11) & 0x1)
#define BCMI_TSC_XGXS_STATUS1000X1r_TX_ERR_DETECTEDf_SET(r,f) (r).status1000x1[0]=(((r).status1000x1[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCMI_TSC_XGXS_STATUS1000X1r_RX_ERR_DETECTEDf_GET(r) ((((r).status1000x1[0]) >> 10) & 0x1)
#define BCMI_TSC_XGXS_STATUS1000X1r_RX_ERR_DETECTEDf_SET(r,f) (r).status1000x1[0]=(((r).status1000x1[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCMI_TSC_XGXS_STATUS1000X1r_RESERVED1f_GET(r) ((((r).status1000x1[0]) >> 8) & 0x3)
#define BCMI_TSC_XGXS_STATUS1000X1r_RESERVED1f_SET(r,f) (r).status1000x1[0]=(((r).status1000x1[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCMI_TSC_XGXS_STATUS1000X1r_LINK_STATUS_CHANGEf_GET(r) ((((r).status1000x1[0]) >> 7) & 0x1)
#define BCMI_TSC_XGXS_STATUS1000X1r_LINK_STATUS_CHANGEf_SET(r,f) (r).status1000x1[0]=(((r).status1000x1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCMI_TSC_XGXS_STATUS1000X1r_RESERVED2f_GET(r) (((r).status1000x1[0]) & 0x7f)
#define BCMI_TSC_XGXS_STATUS1000X1r_RESERVED2f_SET(r,f) (r).status1000x1[0]=(((r).status1000x1[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f))

/*
 * These macros can be used to access STATUS1000X1.
 *
 */
#define BCMI_TSC_XGXS_READ_STATUS1000X1r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_STATUS1000X1r,(_r._status1000x1))
#define BCMI_TSC_XGXS_WRITE_STATUS1000X1r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_STATUS1000X1r,(_r._status1000x1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define STATUS1000X1r BCMI_TSC_XGXS_STATUS1000X1r
#define STATUS1000X1r_SIZE BCMI_TSC_XGXS_STATUS1000X1r_SIZE
typedef BCMI_TSC_XGXS_STATUS1000X1r_t STATUS1000X1r_t;
#define STATUS1000X1r_CLR BCMI_TSC_XGXS_STATUS1000X1r_CLR
#define STATUS1000X1r_SET BCMI_TSC_XGXS_STATUS1000X1r_SET
#define STATUS1000X1r_GET BCMI_TSC_XGXS_STATUS1000X1r_GET
#define STATUS1000X1r_RESERVED0f_GET BCMI_TSC_XGXS_STATUS1000X1r_RESERVED0f_GET
#define STATUS1000X1r_RESERVED0f_SET BCMI_TSC_XGXS_STATUS1000X1r_RESERVED0f_SET
#define STATUS1000X1r_TX_ERR_DETECTEDf_GET BCMI_TSC_XGXS_STATUS1000X1r_TX_ERR_DETECTEDf_GET
#define STATUS1000X1r_TX_ERR_DETECTEDf_SET BCMI_TSC_XGXS_STATUS1000X1r_TX_ERR_DETECTEDf_SET
#define STATUS1000X1r_RX_ERR_DETECTEDf_GET BCMI_TSC_XGXS_STATUS1000X1r_RX_ERR_DETECTEDf_GET
#define STATUS1000X1r_RX_ERR_DETECTEDf_SET BCMI_TSC_XGXS_STATUS1000X1r_RX_ERR_DETECTEDf_SET
#define STATUS1000X1r_RESERVED1f_GET BCMI_TSC_XGXS_STATUS1000X1r_RESERVED1f_GET
#define STATUS1000X1r_RESERVED1f_SET BCMI_TSC_XGXS_STATUS1000X1r_RESERVED1f_SET
#define STATUS1000X1r_LINK_STATUS_CHANGEf_GET BCMI_TSC_XGXS_STATUS1000X1r_LINK_STATUS_CHANGEf_GET
#define STATUS1000X1r_LINK_STATUS_CHANGEf_SET BCMI_TSC_XGXS_STATUS1000X1r_LINK_STATUS_CHANGEf_SET
#define STATUS1000X1r_RESERVED2f_GET BCMI_TSC_XGXS_STATUS1000X1r_RESERVED2f_GET
#define STATUS1000X1r_RESERVED2f_SET BCMI_TSC_XGXS_STATUS1000X1r_RESERVED2f_SET
#define READ_STATUS1000X1r BCMI_TSC_XGXS_READ_STATUS1000X1r
#define WRITE_STATUS1000X1r BCMI_TSC_XGXS_WRITE_STATUS1000X1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_STATUS1000X1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  BADCODEGROUP
 * BLOCKS:   DIGITAL
 * REGADDR:  0xc307
 * DESC:     Invalid code group count register: 00000000
 * SIZE:     32
 * FIELDS:
 *     RESERVED0        
 *     BADCODEGROUPS    
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_BADCODEGROUPr (0x0000c307 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_BADCODEGROUPr_SIZE 4

/*
 * This structure should be used to declare and program BADCODEGROUP.
 *
 */
typedef union BCMI_TSC_XGXS_BADCODEGROUPr_s {
	uint32_t v[1];
	uint32_t badcodegroup[1];
	uint32_t _badcodegroup;
} BCMI_TSC_XGXS_BADCODEGROUPr_t;

#define BCMI_TSC_XGXS_BADCODEGROUPr_CLR(r) (r).badcodegroup[0] = 0
#define BCMI_TSC_XGXS_BADCODEGROUPr_SET(r,d) (r).badcodegroup[0] = d
#define BCMI_TSC_XGXS_BADCODEGROUPr_GET(r) (r).badcodegroup[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_BADCODEGROUPr_BADCODEGROUPSf_GET(r) ((((r).badcodegroup[0]) >> 8) & 0xff)
#define BCMI_TSC_XGXS_BADCODEGROUPr_BADCODEGROUPSf_SET(r,f) (r).badcodegroup[0]=(((r).badcodegroup[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCMI_TSC_XGXS_BADCODEGROUPr_RESERVED0f_GET(r) (((r).badcodegroup[0]) & 0xff)
#define BCMI_TSC_XGXS_BADCODEGROUPr_RESERVED0f_SET(r,f) (r).badcodegroup[0]=(((r).badcodegroup[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access BADCODEGROUP.
 *
 */
#define BCMI_TSC_XGXS_READ_BADCODEGROUPr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_BADCODEGROUPr,(_r._badcodegroup))
#define BCMI_TSC_XGXS_WRITE_BADCODEGROUPr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_BADCODEGROUPr,(_r._badcodegroup))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define BADCODEGROUPr BCMI_TSC_XGXS_BADCODEGROUPr
#define BADCODEGROUPr_SIZE BCMI_TSC_XGXS_BADCODEGROUPr_SIZE
typedef BCMI_TSC_XGXS_BADCODEGROUPr_t BADCODEGROUPr_t;
#define BADCODEGROUPr_CLR BCMI_TSC_XGXS_BADCODEGROUPr_CLR
#define BADCODEGROUPr_SET BCMI_TSC_XGXS_BADCODEGROUPr_SET
#define BADCODEGROUPr_GET BCMI_TSC_XGXS_BADCODEGROUPr_GET
#define BADCODEGROUPr_BADCODEGROUPSf_GET BCMI_TSC_XGXS_BADCODEGROUPr_BADCODEGROUPSf_GET
#define BADCODEGROUPr_BADCODEGROUPSf_SET BCMI_TSC_XGXS_BADCODEGROUPr_BADCODEGROUPSf_SET
#define BADCODEGROUPr_RESERVED0f_GET BCMI_TSC_XGXS_BADCODEGROUPr_RESERVED0f_GET
#define BADCODEGROUPr_RESERVED0f_SET BCMI_TSC_XGXS_BADCODEGROUPr_RESERVED0f_SET
#define READ_BADCODEGROUPr BCMI_TSC_XGXS_READ_BADCODEGROUPr
#define WRITE_BADCODEGROUPr BCMI_TSC_XGXS_WRITE_BADCODEGROUPr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_BADCODEGROUPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  MISC2
 * BLOCKS:   DIGITAL
 * REGADDR:  0xc309
 * DESC:     Miscellaneous 2 control register: 00000000
 * SIZE:     32
 * FIELDS:
 *     RESERVED2        
 *     AN_TXDISABLEPHASE 
 *     RESERVED1        
 *     CLK41_BYPASS     
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_MISC2r (0x0000c309 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_MISC2r_SIZE 4

/*
 * This structure should be used to declare and program MISC2.
 *
 */
typedef union BCMI_TSC_XGXS_MISC2r_s {
	uint32_t v[1];
	uint32_t misc2[1];
	uint32_t _misc2;
} BCMI_TSC_XGXS_MISC2r_t;

#define BCMI_TSC_XGXS_MISC2r_CLR(r) (r).misc2[0] = 0
#define BCMI_TSC_XGXS_MISC2r_SET(r,d) (r).misc2[0] = d
#define BCMI_TSC_XGXS_MISC2r_GET(r) (r).misc2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_MISC2r_RESERVED0f_GET(r) ((((r).misc2[0]) >> 10) & 0x3f)
#define BCMI_TSC_XGXS_MISC2r_RESERVED0f_SET(r,f) (r).misc2[0]=(((r).misc2[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))
#define BCMI_TSC_XGXS_MISC2r_CLK41_BYPASSf_GET(r) ((((r).misc2[0]) >> 9) & 0x1)
#define BCMI_TSC_XGXS_MISC2r_CLK41_BYPASSf_SET(r,f) (r).misc2[0]=(((r).misc2[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCMI_TSC_XGXS_MISC2r_RESERVED1f_GET(r) ((((r).misc2[0]) >> 4) & 0x1f)
#define BCMI_TSC_XGXS_MISC2r_RESERVED1f_SET(r,f) (r).misc2[0]=(((r).misc2[0] & ~((uint32_t)0x1f << 4)) | ((((uint32_t)f) & 0x1f) << 4))
#define BCMI_TSC_XGXS_MISC2r_AN_TXDISABLEPHASEf_GET(r) ((((r).misc2[0]) >> 3) & 0x1)
#define BCMI_TSC_XGXS_MISC2r_AN_TXDISABLEPHASEf_SET(r,f) (r).misc2[0]=(((r).misc2[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCMI_TSC_XGXS_MISC2r_RESERVED2f_GET(r) (((r).misc2[0]) & 0x7)
#define BCMI_TSC_XGXS_MISC2r_RESERVED2f_SET(r,f) (r).misc2[0]=(((r).misc2[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))

/*
 * These macros can be used to access MISC2.
 *
 */
#define BCMI_TSC_XGXS_READ_MISC2r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_MISC2r,(_r._misc2))
#define BCMI_TSC_XGXS_WRITE_MISC2r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_MISC2r,(_r._misc2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MISC2r BCMI_TSC_XGXS_MISC2r
#define MISC2r_SIZE BCMI_TSC_XGXS_MISC2r_SIZE
typedef BCMI_TSC_XGXS_MISC2r_t MISC2r_t;
#define MISC2r_CLR BCMI_TSC_XGXS_MISC2r_CLR
#define MISC2r_SET BCMI_TSC_XGXS_MISC2r_SET
#define MISC2r_GET BCMI_TSC_XGXS_MISC2r_GET
#define MISC2r_RESERVED0f_GET BCMI_TSC_XGXS_MISC2r_RESERVED0f_GET
#define MISC2r_RESERVED0f_SET BCMI_TSC_XGXS_MISC2r_RESERVED0f_SET
#define MISC2r_CLK41_BYPASSf_GET BCMI_TSC_XGXS_MISC2r_CLK41_BYPASSf_GET
#define MISC2r_CLK41_BYPASSf_SET BCMI_TSC_XGXS_MISC2r_CLK41_BYPASSf_SET
#define MISC2r_RESERVED1f_GET BCMI_TSC_XGXS_MISC2r_RESERVED1f_GET
#define MISC2r_RESERVED1f_SET BCMI_TSC_XGXS_MISC2r_RESERVED1f_SET
#define MISC2r_AN_TXDISABLEPHASEf_GET BCMI_TSC_XGXS_MISC2r_AN_TXDISABLEPHASEf_GET
#define MISC2r_AN_TXDISABLEPHASEf_SET BCMI_TSC_XGXS_MISC2r_AN_TXDISABLEPHASEf_SET
#define MISC2r_RESERVED2f_GET BCMI_TSC_XGXS_MISC2r_RESERVED2f_GET
#define MISC2r_RESERVED2f_SET BCMI_TSC_XGXS_MISC2r_RESERVED2f_SET
#define READ_MISC2r BCMI_TSC_XGXS_READ_MISC2r
#define WRITE_MISC2r BCMI_TSC_XGXS_WRITE_MISC2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_MISC2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  SPARE
 * BLOCKS:   DIGITAL
 * REGADDR:  0xc30a
 * DESC:     spare register: 00000000
 * SIZE:     32
 * FIELDS:
 *     SPARE            
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_SPAREr (0x0000c30a | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_SPAREr_SIZE 4

/*
 * This structure should be used to declare and program SPARE.
 *
 */
typedef union BCMI_TSC_XGXS_SPAREr_s {
	uint32_t v[1];
	uint32_t spare[1];
	uint32_t _spare;
} BCMI_TSC_XGXS_SPAREr_t;

#define BCMI_TSC_XGXS_SPAREr_CLR(r) (r).spare[0] = 0
#define BCMI_TSC_XGXS_SPAREr_SET(r,d) (r).spare[0] = d
#define BCMI_TSC_XGXS_SPAREr_GET(r) (r).spare[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_SPAREr_RESERVED0f_GET(r) ((((r).spare[0]) >> 8) & 0xff)
#define BCMI_TSC_XGXS_SPAREr_RESERVED0f_SET(r,f) (r).spare[0]=(((r).spare[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCMI_TSC_XGXS_SPAREr_SPAREf_GET(r) (((r).spare[0]) & 0xff)
#define BCMI_TSC_XGXS_SPAREr_SPAREf_SET(r,f) (r).spare[0]=(((r).spare[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access SPARE.
 *
 */
#define BCMI_TSC_XGXS_READ_SPAREr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_SPAREr,(_r._spare))
#define BCMI_TSC_XGXS_WRITE_SPAREr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_SPAREr,(_r._spare))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SPAREr BCMI_TSC_XGXS_SPAREr
#define SPAREr_SIZE BCMI_TSC_XGXS_SPAREr_SIZE
typedef BCMI_TSC_XGXS_SPAREr_t SPAREr_t;
#define SPAREr_CLR BCMI_TSC_XGXS_SPAREr_CLR
#define SPAREr_SET BCMI_TSC_XGXS_SPAREr_SET
#define SPAREr_GET BCMI_TSC_XGXS_SPAREr_GET
#define SPAREr_RESERVED0f_GET BCMI_TSC_XGXS_SPAREr_RESERVED0f_GET
#define SPAREr_RESERVED0f_SET BCMI_TSC_XGXS_SPAREr_RESERVED0f_SET
#define SPAREr_SPAREf_GET BCMI_TSC_XGXS_SPAREr_SPAREf_GET
#define SPAREr_SPAREf_SET BCMI_TSC_XGXS_SPAREr_SPAREf_SET
#define READ_SPAREr BCMI_TSC_XGXS_READ_SPAREr
#define WRITE_SPAREr BCMI_TSC_XGXS_WRITE_SPAREr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_SPAREr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  MISC6
 * BLOCKS:   DIGITAL5
 * REGADDR:  0xc310
 * DESC:     Misc6: 00000000
 * SIZE:     32
 * FIELDS:
 *     RESERVED2        
 *     RX_OS8_OS3_ALT_BITS_CYA 
 *     RESERVED1        
 *     RX_OS8_FRST_SM   
 *     RESERVED0        
 *     BRCM6466_CL49_IN_ALL_MODE_CYA 
 *     INDCH_AN_CKSWITCH_TMR_DIS 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_MISC6r (0x0000c310 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_MISC6r_SIZE 4

/*
 * This structure should be used to declare and program MISC6.
 *
 */
typedef union BCMI_TSC_XGXS_MISC6r_s {
	uint32_t v[1];
	uint32_t misc6[1];
	uint32_t _misc6;
} BCMI_TSC_XGXS_MISC6r_t;

#define BCMI_TSC_XGXS_MISC6r_CLR(r) (r).misc6[0] = 0
#define BCMI_TSC_XGXS_MISC6r_SET(r,d) (r).misc6[0] = d
#define BCMI_TSC_XGXS_MISC6r_GET(r) (r).misc6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_MISC6r_INDCH_AN_CKSWITCH_TMR_DISf_GET(r) ((((r).misc6[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_MISC6r_INDCH_AN_CKSWITCH_TMR_DISf_SET(r,f) (r).misc6[0]=(((r).misc6[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_MISC6r_BRCM6466_CL49_IN_ALL_MODE_CYAf_GET(r) ((((r).misc6[0]) >> 14) & 0x1)
#define BCMI_TSC_XGXS_MISC6r_BRCM6466_CL49_IN_ALL_MODE_CYAf_SET(r,f) (r).misc6[0]=(((r).misc6[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCMI_TSC_XGXS_MISC6r_RESERVED0f_GET(r) ((((r).misc6[0]) >> 9) & 0x1f)
#define BCMI_TSC_XGXS_MISC6r_RESERVED0f_SET(r,f) (r).misc6[0]=(((r).misc6[0] & ~((uint32_t)0x1f << 9)) | ((((uint32_t)f) & 0x1f) << 9))
#define BCMI_TSC_XGXS_MISC6r_RX_OS8_FRST_SMf_GET(r) ((((r).misc6[0]) >> 8) & 0x1)
#define BCMI_TSC_XGXS_MISC6r_RX_OS8_FRST_SMf_SET(r,f) (r).misc6[0]=(((r).misc6[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCMI_TSC_XGXS_MISC6r_RESERVED1f_GET(r) ((((r).misc6[0]) >> 5) & 0x7)
#define BCMI_TSC_XGXS_MISC6r_RESERVED1f_SET(r,f) (r).misc6[0]=(((r).misc6[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))
#define BCMI_TSC_XGXS_MISC6r_RX_OS8_OS3_ALT_BITS_CYAf_GET(r) ((((r).misc6[0]) >> 4) & 0x1)
#define BCMI_TSC_XGXS_MISC6r_RX_OS8_OS3_ALT_BITS_CYAf_SET(r,f) (r).misc6[0]=(((r).misc6[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCMI_TSC_XGXS_MISC6r_RESERVED2f_GET(r) (((r).misc6[0]) & 0xf)
#define BCMI_TSC_XGXS_MISC6r_RESERVED2f_SET(r,f) (r).misc6[0]=(((r).misc6[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access MISC6.
 *
 */
#define BCMI_TSC_XGXS_READ_MISC6r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_MISC6r,(_r._misc6))
#define BCMI_TSC_XGXS_WRITE_MISC6r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_MISC6r,(_r._misc6))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MISC6r BCMI_TSC_XGXS_MISC6r
#define MISC6r_SIZE BCMI_TSC_XGXS_MISC6r_SIZE
typedef BCMI_TSC_XGXS_MISC6r_t MISC6r_t;
#define MISC6r_CLR BCMI_TSC_XGXS_MISC6r_CLR
#define MISC6r_SET BCMI_TSC_XGXS_MISC6r_SET
#define MISC6r_GET BCMI_TSC_XGXS_MISC6r_GET
#define MISC6r_INDCH_AN_CKSWITCH_TMR_DISf_GET BCMI_TSC_XGXS_MISC6r_INDCH_AN_CKSWITCH_TMR_DISf_GET
#define MISC6r_INDCH_AN_CKSWITCH_TMR_DISf_SET BCMI_TSC_XGXS_MISC6r_INDCH_AN_CKSWITCH_TMR_DISf_SET
#define MISC6r_BRCM6466_CL49_IN_ALL_MODE_CYAf_GET BCMI_TSC_XGXS_MISC6r_BRCM6466_CL49_IN_ALL_MODE_CYAf_GET
#define MISC6r_BRCM6466_CL49_IN_ALL_MODE_CYAf_SET BCMI_TSC_XGXS_MISC6r_BRCM6466_CL49_IN_ALL_MODE_CYAf_SET
#define MISC6r_RESERVED0f_GET BCMI_TSC_XGXS_MISC6r_RESERVED0f_GET
#define MISC6r_RESERVED0f_SET BCMI_TSC_XGXS_MISC6r_RESERVED0f_SET
#define MISC6r_RX_OS8_FRST_SMf_GET BCMI_TSC_XGXS_MISC6r_RX_OS8_FRST_SMf_GET
#define MISC6r_RX_OS8_FRST_SMf_SET BCMI_TSC_XGXS_MISC6r_RX_OS8_FRST_SMf_SET
#define MISC6r_RESERVED1f_GET BCMI_TSC_XGXS_MISC6r_RESERVED1f_GET
#define MISC6r_RESERVED1f_SET BCMI_TSC_XGXS_MISC6r_RESERVED1f_SET
#define MISC6r_RX_OS8_OS3_ALT_BITS_CYAf_GET BCMI_TSC_XGXS_MISC6r_RX_OS8_OS3_ALT_BITS_CYAf_GET
#define MISC6r_RX_OS8_OS3_ALT_BITS_CYAf_SET BCMI_TSC_XGXS_MISC6r_RX_OS8_OS3_ALT_BITS_CYAf_SET
#define MISC6r_RESERVED2f_GET BCMI_TSC_XGXS_MISC6r_RESERVED2f_GET
#define MISC6r_RESERVED2f_SET BCMI_TSC_XGXS_MISC6r_RESERVED2f_SET
#define READ_MISC6r BCMI_TSC_XGXS_READ_MISC6r
#define WRITE_MISC6r BCMI_TSC_XGXS_WRITE_MISC6r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_MISC6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CL49_BERCNT
 * BLOCKS:   CL49
 * REGADDR:  0xc324
 * DESC:     BER fsm - ber counter: 00000000
 * SIZE:     32
 * FIELDS:
 *     RESERVED1        
 *     IDLEERRORCOUNT_EN 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CL49_BERCNTr (0x0000c324 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CL49_BERCNTr_SIZE 4

/*
 * This structure should be used to declare and program CL49_BERCNT.
 *
 */
typedef union BCMI_TSC_XGXS_CL49_BERCNTr_s {
	uint32_t v[1];
	uint32_t cl49_bercnt[1];
	uint32_t _cl49_bercnt;
} BCMI_TSC_XGXS_CL49_BERCNTr_t;

#define BCMI_TSC_XGXS_CL49_BERCNTr_CLR(r) (r).cl49_bercnt[0] = 0
#define BCMI_TSC_XGXS_CL49_BERCNTr_SET(r,d) (r).cl49_bercnt[0] = d
#define BCMI_TSC_XGXS_CL49_BERCNTr_GET(r) (r).cl49_bercnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CL49_BERCNTr_RESERVED0f_GET(r) ((((r).cl49_bercnt[0]) >> 11) & 0x1f)
#define BCMI_TSC_XGXS_CL49_BERCNTr_RESERVED0f_SET(r,f) (r).cl49_bercnt[0]=(((r).cl49_bercnt[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))
#define BCMI_TSC_XGXS_CL49_BERCNTr_IDLEERRORCOUNT_ENf_GET(r) ((((r).cl49_bercnt[0]) >> 10) & 0x1)
#define BCMI_TSC_XGXS_CL49_BERCNTr_IDLEERRORCOUNT_ENf_SET(r,f) (r).cl49_bercnt[0]=(((r).cl49_bercnt[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCMI_TSC_XGXS_CL49_BERCNTr_RESERVED1f_GET(r) (((r).cl49_bercnt[0]) & 0x3ff)
#define BCMI_TSC_XGXS_CL49_BERCNTr_RESERVED1f_SET(r,f) (r).cl49_bercnt[0]=(((r).cl49_bercnt[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))

/*
 * These macros can be used to access CL49_BERCNT.
 *
 */
#define BCMI_TSC_XGXS_READ_CL49_BERCNTr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CL49_BERCNTr,(_r._cl49_bercnt))
#define BCMI_TSC_XGXS_WRITE_CL49_BERCNTr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CL49_BERCNTr,(_r._cl49_bercnt))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL49_BERCNTr BCMI_TSC_XGXS_CL49_BERCNTr
#define CL49_BERCNTr_SIZE BCMI_TSC_XGXS_CL49_BERCNTr_SIZE
typedef BCMI_TSC_XGXS_CL49_BERCNTr_t CL49_BERCNTr_t;
#define CL49_BERCNTr_CLR BCMI_TSC_XGXS_CL49_BERCNTr_CLR
#define CL49_BERCNTr_SET BCMI_TSC_XGXS_CL49_BERCNTr_SET
#define CL49_BERCNTr_GET BCMI_TSC_XGXS_CL49_BERCNTr_GET
#define CL49_BERCNTr_RESERVED0f_GET BCMI_TSC_XGXS_CL49_BERCNTr_RESERVED0f_GET
#define CL49_BERCNTr_RESERVED0f_SET BCMI_TSC_XGXS_CL49_BERCNTr_RESERVED0f_SET
#define CL49_BERCNTr_IDLEERRORCOUNT_ENf_GET BCMI_TSC_XGXS_CL49_BERCNTr_IDLEERRORCOUNT_ENf_GET
#define CL49_BERCNTr_IDLEERRORCOUNT_ENf_SET BCMI_TSC_XGXS_CL49_BERCNTr_IDLEERRORCOUNT_ENf_SET
#define CL49_BERCNTr_RESERVED1f_GET BCMI_TSC_XGXS_CL49_BERCNTr_RESERVED1f_GET
#define CL49_BERCNTr_RESERVED1f_SET BCMI_TSC_XGXS_CL49_BERCNTr_RESERVED1f_SET
#define READ_CL49_BERCNTr BCMI_TSC_XGXS_READ_CL49_BERCNTr
#define WRITE_CL49_BERCNTr BCMI_TSC_XGXS_WRITE_CL49_BERCNTr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CL49_BERCNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CL73_UCTRL1
 * BLOCKS:   CL73
 * REGADDR:  0xc340
 * DESC:     Clause 73 user control: 00000000
 * SIZE:     32
 * FIELDS:
 *     RESERVED1        
 *     CL73_NONCE_MATCH_VAL 
 *     CL73_NONCE_MATCH_OVER 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CL73_UCTRL1r (0x0000c340 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CL73_UCTRL1r_SIZE 4

/*
 * This structure should be used to declare and program CL73_UCTRL1.
 *
 */
typedef union BCMI_TSC_XGXS_CL73_UCTRL1r_s {
	uint32_t v[1];
	uint32_t cl73_uctrl1[1];
	uint32_t _cl73_uctrl1;
} BCMI_TSC_XGXS_CL73_UCTRL1r_t;

#define BCMI_TSC_XGXS_CL73_UCTRL1r_CLR(r) (r).cl73_uctrl1[0] = 0
#define BCMI_TSC_XGXS_CL73_UCTRL1r_SET(r,d) (r).cl73_uctrl1[0] = d
#define BCMI_TSC_XGXS_CL73_UCTRL1r_GET(r) (r).cl73_uctrl1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CL73_UCTRL1r_RESERVED0f_GET(r) ((((r).cl73_uctrl1[0]) >> 7) & 0x1ff)
#define BCMI_TSC_XGXS_CL73_UCTRL1r_RESERVED0f_SET(r,f) (r).cl73_uctrl1[0]=(((r).cl73_uctrl1[0] & ~((uint32_t)0x1ff << 7)) | ((((uint32_t)f) & 0x1ff) << 7))
#define BCMI_TSC_XGXS_CL73_UCTRL1r_CL73_NONCE_MATCH_OVERf_GET(r) ((((r).cl73_uctrl1[0]) >> 6) & 0x1)
#define BCMI_TSC_XGXS_CL73_UCTRL1r_CL73_NONCE_MATCH_OVERf_SET(r,f) (r).cl73_uctrl1[0]=(((r).cl73_uctrl1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCMI_TSC_XGXS_CL73_UCTRL1r_CL73_NONCE_MATCH_VALf_GET(r) ((((r).cl73_uctrl1[0]) >> 5) & 0x1)
#define BCMI_TSC_XGXS_CL73_UCTRL1r_CL73_NONCE_MATCH_VALf_SET(r,f) (r).cl73_uctrl1[0]=(((r).cl73_uctrl1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCMI_TSC_XGXS_CL73_UCTRL1r_RESERVED1f_GET(r) (((r).cl73_uctrl1[0]) & 0x1f)
#define BCMI_TSC_XGXS_CL73_UCTRL1r_RESERVED1f_SET(r,f) (r).cl73_uctrl1[0]=(((r).cl73_uctrl1[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))

/*
 * These macros can be used to access CL73_UCTRL1.
 *
 */
#define BCMI_TSC_XGXS_READ_CL73_UCTRL1r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CL73_UCTRL1r,(_r._cl73_uctrl1))
#define BCMI_TSC_XGXS_WRITE_CL73_UCTRL1r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CL73_UCTRL1r,(_r._cl73_uctrl1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL73_UCTRL1r BCMI_TSC_XGXS_CL73_UCTRL1r
#define CL73_UCTRL1r_SIZE BCMI_TSC_XGXS_CL73_UCTRL1r_SIZE
typedef BCMI_TSC_XGXS_CL73_UCTRL1r_t CL73_UCTRL1r_t;
#define CL73_UCTRL1r_CLR BCMI_TSC_XGXS_CL73_UCTRL1r_CLR
#define CL73_UCTRL1r_SET BCMI_TSC_XGXS_CL73_UCTRL1r_SET
#define CL73_UCTRL1r_GET BCMI_TSC_XGXS_CL73_UCTRL1r_GET
#define CL73_UCTRL1r_RESERVED0f_GET BCMI_TSC_XGXS_CL73_UCTRL1r_RESERVED0f_GET
#define CL73_UCTRL1r_RESERVED0f_SET BCMI_TSC_XGXS_CL73_UCTRL1r_RESERVED0f_SET
#define CL73_UCTRL1r_CL73_NONCE_MATCH_OVERf_GET BCMI_TSC_XGXS_CL73_UCTRL1r_CL73_NONCE_MATCH_OVERf_GET
#define CL73_UCTRL1r_CL73_NONCE_MATCH_OVERf_SET BCMI_TSC_XGXS_CL73_UCTRL1r_CL73_NONCE_MATCH_OVERf_SET
#define CL73_UCTRL1r_CL73_NONCE_MATCH_VALf_GET BCMI_TSC_XGXS_CL73_UCTRL1r_CL73_NONCE_MATCH_VALf_GET
#define CL73_UCTRL1r_CL73_NONCE_MATCH_VALf_SET BCMI_TSC_XGXS_CL73_UCTRL1r_CL73_NONCE_MATCH_VALf_SET
#define CL73_UCTRL1r_RESERVED1f_GET BCMI_TSC_XGXS_CL73_UCTRL1r_RESERVED1f_GET
#define CL73_UCTRL1r_RESERVED1f_SET BCMI_TSC_XGXS_CL73_UCTRL1r_RESERVED1f_SET
#define READ_CL73_UCTRL1r BCMI_TSC_XGXS_READ_CL73_UCTRL1r
#define WRITE_CL73_UCTRL1r BCMI_TSC_XGXS_WRITE_CL73_UCTRL1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CL73_UCTRL1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CL73_USTAT1
 * BLOCKS:   CL73
 * REGADDR:  0xc341
 * DESC:     Clause 73 user status: 00000000
 * SIZE:     32
 * FIELDS:
 *     ARB_FSM          
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CL73_USTAT1r (0x0000c341 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CL73_USTAT1r_SIZE 4

/*
 * This structure should be used to declare and program CL73_USTAT1.
 *
 */
typedef union BCMI_TSC_XGXS_CL73_USTAT1r_s {
	uint32_t v[1];
	uint32_t cl73_ustat1[1];
	uint32_t _cl73_ustat1;
} BCMI_TSC_XGXS_CL73_USTAT1r_t;

#define BCMI_TSC_XGXS_CL73_USTAT1r_CLR(r) (r).cl73_ustat1[0] = 0
#define BCMI_TSC_XGXS_CL73_USTAT1r_SET(r,d) (r).cl73_ustat1[0] = d
#define BCMI_TSC_XGXS_CL73_USTAT1r_GET(r) (r).cl73_ustat1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CL73_USTAT1r_RESERVED0f_GET(r) ((((r).cl73_ustat1[0]) >> 12) & 0xf)
#define BCMI_TSC_XGXS_CL73_USTAT1r_RESERVED0f_SET(r,f) (r).cl73_ustat1[0]=(((r).cl73_ustat1[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCMI_TSC_XGXS_CL73_USTAT1r_ARB_FSMf_GET(r) (((r).cl73_ustat1[0]) & 0xfff)
#define BCMI_TSC_XGXS_CL73_USTAT1r_ARB_FSMf_SET(r,f) (r).cl73_ustat1[0]=(((r).cl73_ustat1[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))

/*
 * These macros can be used to access CL73_USTAT1.
 *
 */
#define BCMI_TSC_XGXS_READ_CL73_USTAT1r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CL73_USTAT1r,(_r._cl73_ustat1))
#define BCMI_TSC_XGXS_WRITE_CL73_USTAT1r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CL73_USTAT1r,(_r._cl73_ustat1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL73_USTAT1r BCMI_TSC_XGXS_CL73_USTAT1r
#define CL73_USTAT1r_SIZE BCMI_TSC_XGXS_CL73_USTAT1r_SIZE
typedef BCMI_TSC_XGXS_CL73_USTAT1r_t CL73_USTAT1r_t;
#define CL73_USTAT1r_CLR BCMI_TSC_XGXS_CL73_USTAT1r_CLR
#define CL73_USTAT1r_SET BCMI_TSC_XGXS_CL73_USTAT1r_SET
#define CL73_USTAT1r_GET BCMI_TSC_XGXS_CL73_USTAT1r_GET
#define CL73_USTAT1r_RESERVED0f_GET BCMI_TSC_XGXS_CL73_USTAT1r_RESERVED0f_GET
#define CL73_USTAT1r_RESERVED0f_SET BCMI_TSC_XGXS_CL73_USTAT1r_RESERVED0f_SET
#define CL73_USTAT1r_ARB_FSMf_GET BCMI_TSC_XGXS_CL73_USTAT1r_ARB_FSMf_GET
#define CL73_USTAT1r_ARB_FSMf_SET BCMI_TSC_XGXS_CL73_USTAT1r_ARB_FSMf_SET
#define READ_CL73_USTAT1r BCMI_TSC_XGXS_READ_CL73_USTAT1r
#define WRITE_CL73_USTAT1r BCMI_TSC_XGXS_WRITE_CL73_USTAT1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CL73_USTAT1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CL73_UCTRL2
 * BLOCKS:   CL73
 * REGADDR:  0xc342
 * DESC:     Clause 73 user control2: 00000000
 * SIZE:     32
 * FIELDS:
 *     RESERVED1        
 *     USELINK          
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CL73_UCTRL2r (0x0000c342 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CL73_UCTRL2r_SIZE 4

/*
 * This structure should be used to declare and program CL73_UCTRL2.
 *
 */
typedef union BCMI_TSC_XGXS_CL73_UCTRL2r_s {
	uint32_t v[1];
	uint32_t cl73_uctrl2[1];
	uint32_t _cl73_uctrl2;
} BCMI_TSC_XGXS_CL73_UCTRL2r_t;

#define BCMI_TSC_XGXS_CL73_UCTRL2r_CLR(r) (r).cl73_uctrl2[0] = 0
#define BCMI_TSC_XGXS_CL73_UCTRL2r_SET(r,d) (r).cl73_uctrl2[0] = d
#define BCMI_TSC_XGXS_CL73_UCTRL2r_GET(r) (r).cl73_uctrl2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CL73_UCTRL2r_RESERVED0f_GET(r) ((((r).cl73_uctrl2[0]) >> 12) & 0xf)
#define BCMI_TSC_XGXS_CL73_UCTRL2r_RESERVED0f_SET(r,f) (r).cl73_uctrl2[0]=(((r).cl73_uctrl2[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCMI_TSC_XGXS_CL73_UCTRL2r_USELINKf_GET(r) ((((r).cl73_uctrl2[0]) >> 11) & 0x1)
#define BCMI_TSC_XGXS_CL73_UCTRL2r_USELINKf_SET(r,f) (r).cl73_uctrl2[0]=(((r).cl73_uctrl2[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCMI_TSC_XGXS_CL73_UCTRL2r_RESERVED1f_GET(r) (((r).cl73_uctrl2[0]) & 0x7ff)
#define BCMI_TSC_XGXS_CL73_UCTRL2r_RESERVED1f_SET(r,f) (r).cl73_uctrl2[0]=(((r).cl73_uctrl2[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))

/*
 * These macros can be used to access CL73_UCTRL2.
 *
 */
#define BCMI_TSC_XGXS_READ_CL73_UCTRL2r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CL73_UCTRL2r,(_r._cl73_uctrl2))
#define BCMI_TSC_XGXS_WRITE_CL73_UCTRL2r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CL73_UCTRL2r,(_r._cl73_uctrl2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL73_UCTRL2r BCMI_TSC_XGXS_CL73_UCTRL2r
#define CL73_UCTRL2r_SIZE BCMI_TSC_XGXS_CL73_UCTRL2r_SIZE
typedef BCMI_TSC_XGXS_CL73_UCTRL2r_t CL73_UCTRL2r_t;
#define CL73_UCTRL2r_CLR BCMI_TSC_XGXS_CL73_UCTRL2r_CLR
#define CL73_UCTRL2r_SET BCMI_TSC_XGXS_CL73_UCTRL2r_SET
#define CL73_UCTRL2r_GET BCMI_TSC_XGXS_CL73_UCTRL2r_GET
#define CL73_UCTRL2r_RESERVED0f_GET BCMI_TSC_XGXS_CL73_UCTRL2r_RESERVED0f_GET
#define CL73_UCTRL2r_RESERVED0f_SET BCMI_TSC_XGXS_CL73_UCTRL2r_RESERVED0f_SET
#define CL73_UCTRL2r_USELINKf_GET BCMI_TSC_XGXS_CL73_UCTRL2r_USELINKf_GET
#define CL73_UCTRL2r_USELINKf_SET BCMI_TSC_XGXS_CL73_UCTRL2r_USELINKf_SET
#define CL73_UCTRL2r_RESERVED1f_GET BCMI_TSC_XGXS_CL73_UCTRL2r_RESERVED1f_GET
#define CL73_UCTRL2r_RESERVED1f_SET BCMI_TSC_XGXS_CL73_UCTRL2r_RESERVED1f_SET
#define READ_CL73_UCTRL2r BCMI_TSC_XGXS_READ_CL73_UCTRL2r
#define WRITE_CL73_UCTRL2r BCMI_TSC_XGXS_WRITE_CL73_UCTRL2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CL73_UCTRL2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  VERSION
 * BLOCKS:   UC_INFO_B1
 * REGADDR:  0xf010
 * DESC:     Micro-controller Version Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     VERSION          
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_VERSIONr (0x0010f010 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_VERSIONr_SIZE 4

/*
 * This structure should be used to declare and program VERSION.
 *
 */
typedef union BCMI_TSC_XGXS_VERSIONr_s {
	uint32_t v[1];
	uint32_t version[1];
	uint32_t _version;
} BCMI_TSC_XGXS_VERSIONr_t;

#define BCMI_TSC_XGXS_VERSIONr_CLR(r) (r).version[0] = 0
#define BCMI_TSC_XGXS_VERSIONr_SET(r,d) (r).version[0] = d
#define BCMI_TSC_XGXS_VERSIONr_GET(r) (r).version[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_VERSIONr_VERSIONf_GET(r) (((r).version[0]) & 0xffff)
#define BCMI_TSC_XGXS_VERSIONr_VERSIONf_SET(r,f) (r).version[0]=(((r).version[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access VERSION.
 *
 */
#define BCMI_TSC_XGXS_READ_VERSIONr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_VERSIONr,(_r._version))
#define BCMI_TSC_XGXS_WRITE_VERSIONr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_VERSIONr,(_r._version))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define VERSIONr BCMI_TSC_XGXS_VERSIONr
#define VERSIONr_SIZE BCMI_TSC_XGXS_VERSIONr_SIZE
typedef BCMI_TSC_XGXS_VERSIONr_t VERSIONr_t;
#define VERSIONr_CLR BCMI_TSC_XGXS_VERSIONr_CLR
#define VERSIONr_SET BCMI_TSC_XGXS_VERSIONr_SET
#define VERSIONr_GET BCMI_TSC_XGXS_VERSIONr_GET
#define VERSIONr_VERSIONf_GET BCMI_TSC_XGXS_VERSIONr_VERSIONf_GET
#define VERSIONr_VERSIONf_SET BCMI_TSC_XGXS_VERSIONr_VERSIONf_SET
#define READ_VERSIONr BCMI_TSC_XGXS_READ_VERSIONr
#define WRITE_VERSIONr BCMI_TSC_XGXS_WRITE_VERSIONr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_VERSIONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  TARGET
 * BLOCKS:   UC_INFO_B1
 * REGADDR:  0xf011
 * DESC:     Micro-controller Target Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     TARGET           
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_TARGETr (0x0010f011 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_TARGETr_SIZE 4

/*
 * This structure should be used to declare and program TARGET.
 *
 */
typedef union BCMI_TSC_XGXS_TARGETr_s {
	uint32_t v[1];
	uint32_t target[1];
	uint32_t _target;
} BCMI_TSC_XGXS_TARGETr_t;

#define BCMI_TSC_XGXS_TARGETr_CLR(r) (r).target[0] = 0
#define BCMI_TSC_XGXS_TARGETr_SET(r,d) (r).target[0] = d
#define BCMI_TSC_XGXS_TARGETr_GET(r) (r).target[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_TARGETr_TARGETf_GET(r) (((r).target[0]) & 0xffff)
#define BCMI_TSC_XGXS_TARGETr_TARGETf_SET(r,f) (r).target[0]=(((r).target[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access TARGET.
 *
 */
#define BCMI_TSC_XGXS_READ_TARGETr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_TARGETr,(_r._target))
#define BCMI_TSC_XGXS_WRITE_TARGETr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_TARGETr,(_r._target))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TARGETr BCMI_TSC_XGXS_TARGETr
#define TARGETr_SIZE BCMI_TSC_XGXS_TARGETr_SIZE
typedef BCMI_TSC_XGXS_TARGETr_t TARGETr_t;
#define TARGETr_CLR BCMI_TSC_XGXS_TARGETr_CLR
#define TARGETr_SET BCMI_TSC_XGXS_TARGETr_SET
#define TARGETr_GET BCMI_TSC_XGXS_TARGETr_GET
#define TARGETr_TARGETf_GET BCMI_TSC_XGXS_TARGETr_TARGETf_GET
#define TARGETr_TARGETf_SET BCMI_TSC_XGXS_TARGETr_TARGETf_SET
#define READ_TARGETr BCMI_TSC_XGXS_READ_TARGETr
#define WRITE_TARGETr BCMI_TSC_XGXS_WRITE_TARGETr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_TARGETr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  TUNING_STATE_BYPASS
 * BLOCKS:   UC_INFO_B1
 * REGADDR:  0xf013
 * DESC:     Micro Tuning states Bypass Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     BYPASS_OS_VGA_TUNING 
 *     BYPASS_CLK90_TUNING 
 *     BYPASS_PF_TUNING 
 *     BYPASS_VGA_BIAS_TUNING 
 *     BYPASS_SLICER_TARGET_TUNING 
 *     BYPASS_SLICER_OFFSET_TUNING 
 *     BYPASS_DCD_TUNING 
 *     BYPASS_CDR_LOCK_MONITOR 
 *     BYPASS_STEADY_STATE_TUNING 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_TUNING_STATE_BYPASSr (0x0010f013 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_TUNING_STATE_BYPASSr_SIZE 4

/*
 * This structure should be used to declare and program TUNING_STATE_BYPASS.
 *
 */
typedef union BCMI_TSC_XGXS_TUNING_STATE_BYPASSr_s {
	uint32_t v[1];
	uint32_t tuning_state_bypass[1];
	uint32_t _tuning_state_bypass;
} BCMI_TSC_XGXS_TUNING_STATE_BYPASSr_t;

#define BCMI_TSC_XGXS_TUNING_STATE_BYPASSr_CLR(r) (r).tuning_state_bypass[0] = 0
#define BCMI_TSC_XGXS_TUNING_STATE_BYPASSr_SET(r,d) (r).tuning_state_bypass[0] = d
#define BCMI_TSC_XGXS_TUNING_STATE_BYPASSr_GET(r) (r).tuning_state_bypass[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_TUNING_STATE_BYPASSr_RESERVED0f_GET(r) ((((r).tuning_state_bypass[0]) >> 9) & 0x7f)
#define BCMI_TSC_XGXS_TUNING_STATE_BYPASSr_RESERVED0f_SET(r,f) (r).tuning_state_bypass[0]=(((r).tuning_state_bypass[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))
#define BCMI_TSC_XGXS_TUNING_STATE_BYPASSr_BYPASS_STEADY_STATE_TUNINGf_GET(r) ((((r).tuning_state_bypass[0]) >> 8) & 0x1)
#define BCMI_TSC_XGXS_TUNING_STATE_BYPASSr_BYPASS_STEADY_STATE_TUNINGf_SET(r,f) (r).tuning_state_bypass[0]=(((r).tuning_state_bypass[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCMI_TSC_XGXS_TUNING_STATE_BYPASSr_BYPASS_CDR_LOCK_MONITORf_GET(r) ((((r).tuning_state_bypass[0]) >> 7) & 0x1)
#define BCMI_TSC_XGXS_TUNING_STATE_BYPASSr_BYPASS_CDR_LOCK_MONITORf_SET(r,f) (r).tuning_state_bypass[0]=(((r).tuning_state_bypass[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCMI_TSC_XGXS_TUNING_STATE_BYPASSr_BYPASS_DCD_TUNINGf_GET(r) ((((r).tuning_state_bypass[0]) >> 6) & 0x1)
#define BCMI_TSC_XGXS_TUNING_STATE_BYPASSr_BYPASS_DCD_TUNINGf_SET(r,f) (r).tuning_state_bypass[0]=(((r).tuning_state_bypass[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCMI_TSC_XGXS_TUNING_STATE_BYPASSr_BYPASS_SLICER_OFFSET_TUNINGf_GET(r) ((((r).tuning_state_bypass[0]) >> 5) & 0x1)
#define BCMI_TSC_XGXS_TUNING_STATE_BYPASSr_BYPASS_SLICER_OFFSET_TUNINGf_SET(r,f) (r).tuning_state_bypass[0]=(((r).tuning_state_bypass[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCMI_TSC_XGXS_TUNING_STATE_BYPASSr_BYPASS_SLICER_TARGET_TUNINGf_GET(r) ((((r).tuning_state_bypass[0]) >> 4) & 0x1)
#define BCMI_TSC_XGXS_TUNING_STATE_BYPASSr_BYPASS_SLICER_TARGET_TUNINGf_SET(r,f) (r).tuning_state_bypass[0]=(((r).tuning_state_bypass[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCMI_TSC_XGXS_TUNING_STATE_BYPASSr_BYPASS_VGA_BIAS_TUNINGf_GET(r) ((((r).tuning_state_bypass[0]) >> 3) & 0x1)
#define BCMI_TSC_XGXS_TUNING_STATE_BYPASSr_BYPASS_VGA_BIAS_TUNINGf_SET(r,f) (r).tuning_state_bypass[0]=(((r).tuning_state_bypass[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCMI_TSC_XGXS_TUNING_STATE_BYPASSr_BYPASS_PF_TUNINGf_GET(r) ((((r).tuning_state_bypass[0]) >> 2) & 0x1)
#define BCMI_TSC_XGXS_TUNING_STATE_BYPASSr_BYPASS_PF_TUNINGf_SET(r,f) (r).tuning_state_bypass[0]=(((r).tuning_state_bypass[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCMI_TSC_XGXS_TUNING_STATE_BYPASSr_BYPASS_CLK90_TUNINGf_GET(r) ((((r).tuning_state_bypass[0]) >> 1) & 0x1)
#define BCMI_TSC_XGXS_TUNING_STATE_BYPASSr_BYPASS_CLK90_TUNINGf_SET(r,f) (r).tuning_state_bypass[0]=(((r).tuning_state_bypass[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCMI_TSC_XGXS_TUNING_STATE_BYPASSr_BYPASS_OS_VGA_TUNINGf_GET(r) (((r).tuning_state_bypass[0]) & 0x1)
#define BCMI_TSC_XGXS_TUNING_STATE_BYPASSr_BYPASS_OS_VGA_TUNINGf_SET(r,f) (r).tuning_state_bypass[0]=(((r).tuning_state_bypass[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access TUNING_STATE_BYPASS.
 *
 */
#define BCMI_TSC_XGXS_READ_TUNING_STATE_BYPASSr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_TUNING_STATE_BYPASSr,(_r._tuning_state_bypass))
#define BCMI_TSC_XGXS_WRITE_TUNING_STATE_BYPASSr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_TUNING_STATE_BYPASSr,(_r._tuning_state_bypass))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TUNING_STATE_BYPASSr BCMI_TSC_XGXS_TUNING_STATE_BYPASSr
#define TUNING_STATE_BYPASSr_SIZE BCMI_TSC_XGXS_TUNING_STATE_BYPASSr_SIZE
typedef BCMI_TSC_XGXS_TUNING_STATE_BYPASSr_t TUNING_STATE_BYPASSr_t;
#define TUNING_STATE_BYPASSr_CLR BCMI_TSC_XGXS_TUNING_STATE_BYPASSr_CLR
#define TUNING_STATE_BYPASSr_SET BCMI_TSC_XGXS_TUNING_STATE_BYPASSr_SET
#define TUNING_STATE_BYPASSr_GET BCMI_TSC_XGXS_TUNING_STATE_BYPASSr_GET
#define TUNING_STATE_BYPASSr_RESERVED0f_GET BCMI_TSC_XGXS_TUNING_STATE_BYPASSr_RESERVED0f_GET
#define TUNING_STATE_BYPASSr_RESERVED0f_SET BCMI_TSC_XGXS_TUNING_STATE_BYPASSr_RESERVED0f_SET
#define TUNING_STATE_BYPASSr_BYPASS_STEADY_STATE_TUNINGf_GET BCMI_TSC_XGXS_TUNING_STATE_BYPASSr_BYPASS_STEADY_STATE_TUNINGf_GET
#define TUNING_STATE_BYPASSr_BYPASS_STEADY_STATE_TUNINGf_SET BCMI_TSC_XGXS_TUNING_STATE_BYPASSr_BYPASS_STEADY_STATE_TUNINGf_SET
#define TUNING_STATE_BYPASSr_BYPASS_CDR_LOCK_MONITORf_GET BCMI_TSC_XGXS_TUNING_STATE_BYPASSr_BYPASS_CDR_LOCK_MONITORf_GET
#define TUNING_STATE_BYPASSr_BYPASS_CDR_LOCK_MONITORf_SET BCMI_TSC_XGXS_TUNING_STATE_BYPASSr_BYPASS_CDR_LOCK_MONITORf_SET
#define TUNING_STATE_BYPASSr_BYPASS_DCD_TUNINGf_GET BCMI_TSC_XGXS_TUNING_STATE_BYPASSr_BYPASS_DCD_TUNINGf_GET
#define TUNING_STATE_BYPASSr_BYPASS_DCD_TUNINGf_SET BCMI_TSC_XGXS_TUNING_STATE_BYPASSr_BYPASS_DCD_TUNINGf_SET
#define TUNING_STATE_BYPASSr_BYPASS_SLICER_OFFSET_TUNINGf_GET BCMI_TSC_XGXS_TUNING_STATE_BYPASSr_BYPASS_SLICER_OFFSET_TUNINGf_GET
#define TUNING_STATE_BYPASSr_BYPASS_SLICER_OFFSET_TUNINGf_SET BCMI_TSC_XGXS_TUNING_STATE_BYPASSr_BYPASS_SLICER_OFFSET_TUNINGf_SET
#define TUNING_STATE_BYPASSr_BYPASS_SLICER_TARGET_TUNINGf_GET BCMI_TSC_XGXS_TUNING_STATE_BYPASSr_BYPASS_SLICER_TARGET_TUNINGf_GET
#define TUNING_STATE_BYPASSr_BYPASS_SLICER_TARGET_TUNINGf_SET BCMI_TSC_XGXS_TUNING_STATE_BYPASSr_BYPASS_SLICER_TARGET_TUNINGf_SET
#define TUNING_STATE_BYPASSr_BYPASS_VGA_BIAS_TUNINGf_GET BCMI_TSC_XGXS_TUNING_STATE_BYPASSr_BYPASS_VGA_BIAS_TUNINGf_GET
#define TUNING_STATE_BYPASSr_BYPASS_VGA_BIAS_TUNINGf_SET BCMI_TSC_XGXS_TUNING_STATE_BYPASSr_BYPASS_VGA_BIAS_TUNINGf_SET
#define TUNING_STATE_BYPASSr_BYPASS_PF_TUNINGf_GET BCMI_TSC_XGXS_TUNING_STATE_BYPASSr_BYPASS_PF_TUNINGf_GET
#define TUNING_STATE_BYPASSr_BYPASS_PF_TUNINGf_SET BCMI_TSC_XGXS_TUNING_STATE_BYPASSr_BYPASS_PF_TUNINGf_SET
#define TUNING_STATE_BYPASSr_BYPASS_CLK90_TUNINGf_GET BCMI_TSC_XGXS_TUNING_STATE_BYPASSr_BYPASS_CLK90_TUNINGf_GET
#define TUNING_STATE_BYPASSr_BYPASS_CLK90_TUNINGf_SET BCMI_TSC_XGXS_TUNING_STATE_BYPASSr_BYPASS_CLK90_TUNINGf_SET
#define TUNING_STATE_BYPASSr_BYPASS_OS_VGA_TUNINGf_GET BCMI_TSC_XGXS_TUNING_STATE_BYPASSr_BYPASS_OS_VGA_TUNINGf_GET
#define TUNING_STATE_BYPASSr_BYPASS_OS_VGA_TUNINGf_SET BCMI_TSC_XGXS_TUNING_STATE_BYPASSr_BYPASS_OS_VGA_TUNINGf_SET
#define READ_TUNING_STATE_BYPASSr BCMI_TSC_XGXS_READ_TUNING_STATE_BYPASSr
#define WRITE_TUNING_STATE_BYPASSr BCMI_TSC_XGXS_WRITE_TUNING_STATE_BYPASSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_TUNING_STATE_BYPASSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  TEMPERATURE
 * BLOCKS:   UC_INFO_B1
 * REGADDR:  0xf014
 * DESC:     Die-Temperature Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     TEMPERATURE      
 *     TEMP_IDX         
 *     RESERVED0        
 *     FORCE_TEMPERATURE 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_TEMPERATUREr (0x0010f014 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_TEMPERATUREr_SIZE 4

/*
 * This structure should be used to declare and program TEMPERATURE.
 *
 */
typedef union BCMI_TSC_XGXS_TEMPERATUREr_s {
	uint32_t v[1];
	uint32_t temperature[1];
	uint32_t _temperature;
} BCMI_TSC_XGXS_TEMPERATUREr_t;

#define BCMI_TSC_XGXS_TEMPERATUREr_CLR(r) (r).temperature[0] = 0
#define BCMI_TSC_XGXS_TEMPERATUREr_SET(r,d) (r).temperature[0] = d
#define BCMI_TSC_XGXS_TEMPERATUREr_GET(r) (r).temperature[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_TEMPERATUREr_FORCE_TEMPERATUREf_GET(r) ((((r).temperature[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_TEMPERATUREr_FORCE_TEMPERATUREf_SET(r,f) (r).temperature[0]=(((r).temperature[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_TEMPERATUREr_RESERVED0f_GET(r) ((((r).temperature[0]) >> 14) & 0x1)
#define BCMI_TSC_XGXS_TEMPERATUREr_RESERVED0f_SET(r,f) (r).temperature[0]=(((r).temperature[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCMI_TSC_XGXS_TEMPERATUREr_TEMP_IDXf_GET(r) ((((r).temperature[0]) >> 10) & 0xf)
#define BCMI_TSC_XGXS_TEMPERATUREr_TEMP_IDXf_SET(r,f) (r).temperature[0]=(((r).temperature[0] & ~((uint32_t)0xf << 10)) | ((((uint32_t)f) & 0xf) << 10))
#define BCMI_TSC_XGXS_TEMPERATUREr_TEMPERATUREf_GET(r) (((r).temperature[0]) & 0x3ff)
#define BCMI_TSC_XGXS_TEMPERATUREr_TEMPERATUREf_SET(r,f) (r).temperature[0]=(((r).temperature[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))

/*
 * These macros can be used to access TEMPERATURE.
 *
 */
#define BCMI_TSC_XGXS_READ_TEMPERATUREr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_TEMPERATUREr,(_r._temperature))
#define BCMI_TSC_XGXS_WRITE_TEMPERATUREr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_TEMPERATUREr,(_r._temperature))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TEMPERATUREr BCMI_TSC_XGXS_TEMPERATUREr
#define TEMPERATUREr_SIZE BCMI_TSC_XGXS_TEMPERATUREr_SIZE
typedef BCMI_TSC_XGXS_TEMPERATUREr_t TEMPERATUREr_t;
#define TEMPERATUREr_CLR BCMI_TSC_XGXS_TEMPERATUREr_CLR
#define TEMPERATUREr_SET BCMI_TSC_XGXS_TEMPERATUREr_SET
#define TEMPERATUREr_GET BCMI_TSC_XGXS_TEMPERATUREr_GET
#define TEMPERATUREr_FORCE_TEMPERATUREf_GET BCMI_TSC_XGXS_TEMPERATUREr_FORCE_TEMPERATUREf_GET
#define TEMPERATUREr_FORCE_TEMPERATUREf_SET BCMI_TSC_XGXS_TEMPERATUREr_FORCE_TEMPERATUREf_SET
#define TEMPERATUREr_RESERVED0f_GET BCMI_TSC_XGXS_TEMPERATUREr_RESERVED0f_GET
#define TEMPERATUREr_RESERVED0f_SET BCMI_TSC_XGXS_TEMPERATUREr_RESERVED0f_SET
#define TEMPERATUREr_TEMP_IDXf_GET BCMI_TSC_XGXS_TEMPERATUREr_TEMP_IDXf_GET
#define TEMPERATUREr_TEMP_IDXf_SET BCMI_TSC_XGXS_TEMPERATUREr_TEMP_IDXf_SET
#define TEMPERATUREr_TEMPERATUREf_GET BCMI_TSC_XGXS_TEMPERATUREr_TEMPERATUREf_GET
#define TEMPERATUREr_TEMPERATUREf_SET BCMI_TSC_XGXS_TEMPERATUREr_TEMPERATUREf_SET
#define READ_TEMPERATUREr BCMI_TSC_XGXS_READ_TEMPERATUREr
#define WRITE_TEMPERATUREr BCMI_TSC_XGXS_WRITE_TEMPERATUREr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_TEMPERATUREr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  CRC
 * BLOCKS:   UC_INFO_B1
 * REGADDR:  0xf015
 * DESC:     Micro-controller code-ram crc Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     CRC              
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_CRCr (0x0010f015 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_CRCr_SIZE 4

/*
 * This structure should be used to declare and program CRC.
 *
 */
typedef union BCMI_TSC_XGXS_CRCr_s {
	uint32_t v[1];
	uint32_t crc[1];
	uint32_t _crc;
} BCMI_TSC_XGXS_CRCr_t;

#define BCMI_TSC_XGXS_CRCr_CLR(r) (r).crc[0] = 0
#define BCMI_TSC_XGXS_CRCr_SET(r,d) (r).crc[0] = d
#define BCMI_TSC_XGXS_CRCr_GET(r) (r).crc[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_CRCr_CRCf_GET(r) (((r).crc[0]) & 0xffff)
#define BCMI_TSC_XGXS_CRCr_CRCf_SET(r,f) (r).crc[0]=(((r).crc[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access CRC.
 *
 */
#define BCMI_TSC_XGXS_READ_CRCr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_CRCr,(_r._crc))
#define BCMI_TSC_XGXS_WRITE_CRCr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_CRCr,(_r._crc))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CRCr BCMI_TSC_XGXS_CRCr
#define CRCr_SIZE BCMI_TSC_XGXS_CRCr_SIZE
typedef BCMI_TSC_XGXS_CRCr_t CRCr_t;
#define CRCr_CLR BCMI_TSC_XGXS_CRCr_CLR
#define CRCr_SET BCMI_TSC_XGXS_CRCr_SET
#define CRCr_GET BCMI_TSC_XGXS_CRCr_GET
#define CRCr_CRCf_GET BCMI_TSC_XGXS_CRCr_CRCf_GET
#define CRCr_CRCf_SET BCMI_TSC_XGXS_CRCr_CRCf_SET
#define READ_CRCr BCMI_TSC_XGXS_READ_CRCr
#define WRITE_CRCr BCMI_TSC_XGXS_WRITE_CRCr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_CRCr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  TSC_12_TIMER_CONTROL
 * BLOCKS:   UC_INFO_B1
 * REGADDR:  0xf016
 * DESC:     TSC_12 Micro-controller TIMER CONTROLS: 00000000
 * SIZE:     32
 * FIELDS:
 *     TIMER_ENABLE     
 *     TIMER_MUX_SEL    
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_TSC_12_TIMER_CONTROLr (0x0010f016 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_TSC_12_TIMER_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program TSC_12_TIMER_CONTROL.
 *
 */
typedef union BCMI_TSC_XGXS_TSC_12_TIMER_CONTROLr_s {
	uint32_t v[1];
	uint32_t tsc_12_timer_control[1];
	uint32_t _tsc_12_timer_control;
} BCMI_TSC_XGXS_TSC_12_TIMER_CONTROLr_t;

#define BCMI_TSC_XGXS_TSC_12_TIMER_CONTROLr_CLR(r) (r).tsc_12_timer_control[0] = 0
#define BCMI_TSC_XGXS_TSC_12_TIMER_CONTROLr_SET(r,d) (r).tsc_12_timer_control[0] = d
#define BCMI_TSC_XGXS_TSC_12_TIMER_CONTROLr_GET(r) (r).tsc_12_timer_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_TSC_12_TIMER_CONTROLr_TIMER_MUX_SELf_GET(r) ((((r).tsc_12_timer_control[0]) >> 12) & 0xf)
#define BCMI_TSC_XGXS_TSC_12_TIMER_CONTROLr_TIMER_MUX_SELf_SET(r,f) (r).tsc_12_timer_control[0]=(((r).tsc_12_timer_control[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCMI_TSC_XGXS_TSC_12_TIMER_CONTROLr_TIMER_ENABLEf_GET(r) (((r).tsc_12_timer_control[0]) & 0xfff)
#define BCMI_TSC_XGXS_TSC_12_TIMER_CONTROLr_TIMER_ENABLEf_SET(r,f) (r).tsc_12_timer_control[0]=(((r).tsc_12_timer_control[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))

/*
 * These macros can be used to access TSC_12_TIMER_CONTROL.
 *
 */
#define BCMI_TSC_XGXS_READ_TSC_12_TIMER_CONTROLr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_TSC_12_TIMER_CONTROLr,(_r._tsc_12_timer_control))
#define BCMI_TSC_XGXS_WRITE_TSC_12_TIMER_CONTROLr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_TSC_12_TIMER_CONTROLr,(_r._tsc_12_timer_control))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TSC_12_TIMER_CONTROLr BCMI_TSC_XGXS_TSC_12_TIMER_CONTROLr
#define TSC_12_TIMER_CONTROLr_SIZE BCMI_TSC_XGXS_TSC_12_TIMER_CONTROLr_SIZE
typedef BCMI_TSC_XGXS_TSC_12_TIMER_CONTROLr_t TSC_12_TIMER_CONTROLr_t;
#define TSC_12_TIMER_CONTROLr_CLR BCMI_TSC_XGXS_TSC_12_TIMER_CONTROLr_CLR
#define TSC_12_TIMER_CONTROLr_SET BCMI_TSC_XGXS_TSC_12_TIMER_CONTROLr_SET
#define TSC_12_TIMER_CONTROLr_GET BCMI_TSC_XGXS_TSC_12_TIMER_CONTROLr_GET
#define TSC_12_TIMER_CONTROLr_TIMER_MUX_SELf_GET BCMI_TSC_XGXS_TSC_12_TIMER_CONTROLr_TIMER_MUX_SELf_GET
#define TSC_12_TIMER_CONTROLr_TIMER_MUX_SELf_SET BCMI_TSC_XGXS_TSC_12_TIMER_CONTROLr_TIMER_MUX_SELf_SET
#define TSC_12_TIMER_CONTROLr_TIMER_ENABLEf_GET BCMI_TSC_XGXS_TSC_12_TIMER_CONTROLr_TIMER_ENABLEf_GET
#define TSC_12_TIMER_CONTROLr_TIMER_ENABLEf_SET BCMI_TSC_XGXS_TSC_12_TIMER_CONTROLr_TIMER_ENABLEf_SET
#define READ_TSC_12_TIMER_CONTROLr BCMI_TSC_XGXS_READ_TSC_12_TIMER_CONTROLr
#define WRITE_TSC_12_TIMER_CONTROLr BCMI_TSC_XGXS_WRITE_TSC_12_TIMER_CONTROLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_TSC_12_TIMER_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RAMWORD
 * BLOCKS:   UC
 * REGADDR:  0xffc0
 * DESC:     ramWord Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     RAM_COUNT        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RAMWORDr (0x0010ffc0 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RAMWORDr_SIZE 4

/*
 * This structure should be used to declare and program RAMWORD.
 *
 */
typedef union BCMI_TSC_XGXS_RAMWORDr_s {
	uint32_t v[1];
	uint32_t ramword[1];
	uint32_t _ramword;
} BCMI_TSC_XGXS_RAMWORDr_t;

#define BCMI_TSC_XGXS_RAMWORDr_CLR(r) (r).ramword[0] = 0
#define BCMI_TSC_XGXS_RAMWORDr_SET(r,d) (r).ramword[0] = d
#define BCMI_TSC_XGXS_RAMWORDr_GET(r) (r).ramword[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RAMWORDr_RAM_COUNTf_GET(r) (((r).ramword[0]) & 0xffff)
#define BCMI_TSC_XGXS_RAMWORDr_RAM_COUNTf_SET(r,f) (r).ramword[0]=(((r).ramword[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access RAMWORD.
 *
 */
#define BCMI_TSC_XGXS_READ_RAMWORDr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RAMWORDr,(_r._ramword))
#define BCMI_TSC_XGXS_WRITE_RAMWORDr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RAMWORDr,(_r._ramword))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RAMWORDr BCMI_TSC_XGXS_RAMWORDr
#define RAMWORDr_SIZE BCMI_TSC_XGXS_RAMWORDr_SIZE
typedef BCMI_TSC_XGXS_RAMWORDr_t RAMWORDr_t;
#define RAMWORDr_CLR BCMI_TSC_XGXS_RAMWORDr_CLR
#define RAMWORDr_SET BCMI_TSC_XGXS_RAMWORDr_SET
#define RAMWORDr_GET BCMI_TSC_XGXS_RAMWORDr_GET
#define RAMWORDr_RAM_COUNTf_GET BCMI_TSC_XGXS_RAMWORDr_RAM_COUNTf_GET
#define RAMWORDr_RAM_COUNTf_SET BCMI_TSC_XGXS_RAMWORDr_RAM_COUNTf_SET
#define READ_RAMWORDr BCMI_TSC_XGXS_READ_RAMWORDr
#define WRITE_RAMWORDr BCMI_TSC_XGXS_WRITE_RAMWORDr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RAMWORDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  ADDRESS
 * BLOCKS:   UC
 * REGADDR:  0xffc1
 * DESC:     Adress Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     RAM_ADDRESS      
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_ADDRESSr (0x0010ffc1 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_ADDRESSr_SIZE 4

/*
 * This structure should be used to declare and program ADDRESS.
 *
 */
typedef union BCMI_TSC_XGXS_ADDRESSr_s {
	uint32_t v[1];
	uint32_t address[1];
	uint32_t _address;
} BCMI_TSC_XGXS_ADDRESSr_t;

#define BCMI_TSC_XGXS_ADDRESSr_CLR(r) (r).address[0] = 0
#define BCMI_TSC_XGXS_ADDRESSr_SET(r,d) (r).address[0] = d
#define BCMI_TSC_XGXS_ADDRESSr_GET(r) (r).address[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_ADDRESSr_RAM_ADDRESSf_GET(r) (((r).address[0]) & 0xffff)
#define BCMI_TSC_XGXS_ADDRESSr_RAM_ADDRESSf_SET(r,f) (r).address[0]=(((r).address[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access ADDRESS.
 *
 */
#define BCMI_TSC_XGXS_READ_ADDRESSr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_ADDRESSr,(_r._address))
#define BCMI_TSC_XGXS_WRITE_ADDRESSr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_ADDRESSr,(_r._address))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define ADDRESSr BCMI_TSC_XGXS_ADDRESSr
#define ADDRESSr_SIZE BCMI_TSC_XGXS_ADDRESSr_SIZE
typedef BCMI_TSC_XGXS_ADDRESSr_t ADDRESSr_t;
#define ADDRESSr_CLR BCMI_TSC_XGXS_ADDRESSr_CLR
#define ADDRESSr_SET BCMI_TSC_XGXS_ADDRESSr_SET
#define ADDRESSr_GET BCMI_TSC_XGXS_ADDRESSr_GET
#define ADDRESSr_RAM_ADDRESSf_GET BCMI_TSC_XGXS_ADDRESSr_RAM_ADDRESSf_GET
#define ADDRESSr_RAM_ADDRESSf_SET BCMI_TSC_XGXS_ADDRESSr_RAM_ADDRESSf_SET
#define READ_ADDRESSr BCMI_TSC_XGXS_READ_ADDRESSr
#define WRITE_ADDRESSr BCMI_TSC_XGXS_WRITE_ADDRESSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_ADDRESSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  COMMAND
 * BLOCKS:   UC
 * REGADDR:  0xffc2
 * DESC:     Command Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     RUN              
 *     STOP             
 *     READ             
 *     WRITE            
 *     MDIO_UC_RESET_N  
 *     RESERVED0        
 *     BYTE_MODE        
 *     MDIO_AUTOWAKEUP  
 *     MDIO_RAM_CS_FORCE 
 *     MDIO_RAM_CS_FORCE_VAL 
 *     UC_MD_EN_OVERRIDE_VALUE 
 *     UC_MD_EN_OVERRIDE 
 *     INIT_CMD         
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_COMMANDr (0x0010ffc2 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_COMMANDr_SIZE 4

/*
 * This structure should be used to declare and program COMMAND.
 *
 */
typedef union BCMI_TSC_XGXS_COMMANDr_s {
	uint32_t v[1];
	uint32_t command[1];
	uint32_t _command;
} BCMI_TSC_XGXS_COMMANDr_t;

#define BCMI_TSC_XGXS_COMMANDr_CLR(r) (r).command[0] = 0
#define BCMI_TSC_XGXS_COMMANDr_SET(r,d) (r).command[0] = d
#define BCMI_TSC_XGXS_COMMANDr_GET(r) (r).command[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_COMMANDr_INIT_CMDf_GET(r) ((((r).command[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_COMMANDr_INIT_CMDf_SET(r,f) (r).command[0]=(((r).command[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_COMMANDr_UC_MD_EN_OVERRIDEf_GET(r) ((((r).command[0]) >> 14) & 0x1)
#define BCMI_TSC_XGXS_COMMANDr_UC_MD_EN_OVERRIDEf_SET(r,f) (r).command[0]=(((r).command[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCMI_TSC_XGXS_COMMANDr_UC_MD_EN_OVERRIDE_VALUEf_GET(r) ((((r).command[0]) >> 13) & 0x1)
#define BCMI_TSC_XGXS_COMMANDr_UC_MD_EN_OVERRIDE_VALUEf_SET(r,f) (r).command[0]=(((r).command[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCMI_TSC_XGXS_COMMANDr_MDIO_RAM_CS_FORCE_VALf_GET(r) ((((r).command[0]) >> 12) & 0x1)
#define BCMI_TSC_XGXS_COMMANDr_MDIO_RAM_CS_FORCE_VALf_SET(r,f) (r).command[0]=(((r).command[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCMI_TSC_XGXS_COMMANDr_MDIO_RAM_CS_FORCEf_GET(r) ((((r).command[0]) >> 11) & 0x1)
#define BCMI_TSC_XGXS_COMMANDr_MDIO_RAM_CS_FORCEf_SET(r,f) (r).command[0]=(((r).command[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCMI_TSC_XGXS_COMMANDr_MDIO_AUTOWAKEUPf_GET(r) ((((r).command[0]) >> 10) & 0x1)
#define BCMI_TSC_XGXS_COMMANDr_MDIO_AUTOWAKEUPf_SET(r,f) (r).command[0]=(((r).command[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCMI_TSC_XGXS_COMMANDr_BYTE_MODEf_GET(r) ((((r).command[0]) >> 9) & 0x1)
#define BCMI_TSC_XGXS_COMMANDr_BYTE_MODEf_SET(r,f) (r).command[0]=(((r).command[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCMI_TSC_XGXS_COMMANDr_RESERVED0f_GET(r) ((((r).command[0]) >> 5) & 0xf)
#define BCMI_TSC_XGXS_COMMANDr_RESERVED0f_SET(r,f) (r).command[0]=(((r).command[0] & ~((uint32_t)0xf << 5)) | ((((uint32_t)f) & 0xf) << 5))
#define BCMI_TSC_XGXS_COMMANDr_MDIO_UC_RESET_Nf_GET(r) ((((r).command[0]) >> 4) & 0x1)
#define BCMI_TSC_XGXS_COMMANDr_MDIO_UC_RESET_Nf_SET(r,f) (r).command[0]=(((r).command[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCMI_TSC_XGXS_COMMANDr_WRITEf_GET(r) ((((r).command[0]) >> 3) & 0x1)
#define BCMI_TSC_XGXS_COMMANDr_WRITEf_SET(r,f) (r).command[0]=(((r).command[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCMI_TSC_XGXS_COMMANDr_READf_GET(r) ((((r).command[0]) >> 2) & 0x1)
#define BCMI_TSC_XGXS_COMMANDr_READf_SET(r,f) (r).command[0]=(((r).command[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCMI_TSC_XGXS_COMMANDr_STOPf_GET(r) ((((r).command[0]) >> 1) & 0x1)
#define BCMI_TSC_XGXS_COMMANDr_STOPf_SET(r,f) (r).command[0]=(((r).command[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCMI_TSC_XGXS_COMMANDr_RUNf_GET(r) (((r).command[0]) & 0x1)
#define BCMI_TSC_XGXS_COMMANDr_RUNf_SET(r,f) (r).command[0]=(((r).command[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access COMMAND.
 *
 */
#define BCMI_TSC_XGXS_READ_COMMANDr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_COMMANDr,(_r._command))
#define BCMI_TSC_XGXS_WRITE_COMMANDr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_COMMANDr,(_r._command))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define COMMANDr BCMI_TSC_XGXS_COMMANDr
#define COMMANDr_SIZE BCMI_TSC_XGXS_COMMANDr_SIZE
typedef BCMI_TSC_XGXS_COMMANDr_t COMMANDr_t;
#define COMMANDr_CLR BCMI_TSC_XGXS_COMMANDr_CLR
#define COMMANDr_SET BCMI_TSC_XGXS_COMMANDr_SET
#define COMMANDr_GET BCMI_TSC_XGXS_COMMANDr_GET
#define COMMANDr_INIT_CMDf_GET BCMI_TSC_XGXS_COMMANDr_INIT_CMDf_GET
#define COMMANDr_INIT_CMDf_SET BCMI_TSC_XGXS_COMMANDr_INIT_CMDf_SET
#define COMMANDr_UC_MD_EN_OVERRIDEf_GET BCMI_TSC_XGXS_COMMANDr_UC_MD_EN_OVERRIDEf_GET
#define COMMANDr_UC_MD_EN_OVERRIDEf_SET BCMI_TSC_XGXS_COMMANDr_UC_MD_EN_OVERRIDEf_SET
#define COMMANDr_UC_MD_EN_OVERRIDE_VALUEf_GET BCMI_TSC_XGXS_COMMANDr_UC_MD_EN_OVERRIDE_VALUEf_GET
#define COMMANDr_UC_MD_EN_OVERRIDE_VALUEf_SET BCMI_TSC_XGXS_COMMANDr_UC_MD_EN_OVERRIDE_VALUEf_SET
#define COMMANDr_MDIO_RAM_CS_FORCE_VALf_GET BCMI_TSC_XGXS_COMMANDr_MDIO_RAM_CS_FORCE_VALf_GET
#define COMMANDr_MDIO_RAM_CS_FORCE_VALf_SET BCMI_TSC_XGXS_COMMANDr_MDIO_RAM_CS_FORCE_VALf_SET
#define COMMANDr_MDIO_RAM_CS_FORCEf_GET BCMI_TSC_XGXS_COMMANDr_MDIO_RAM_CS_FORCEf_GET
#define COMMANDr_MDIO_RAM_CS_FORCEf_SET BCMI_TSC_XGXS_COMMANDr_MDIO_RAM_CS_FORCEf_SET
#define COMMANDr_MDIO_AUTOWAKEUPf_GET BCMI_TSC_XGXS_COMMANDr_MDIO_AUTOWAKEUPf_GET
#define COMMANDr_MDIO_AUTOWAKEUPf_SET BCMI_TSC_XGXS_COMMANDr_MDIO_AUTOWAKEUPf_SET
#define COMMANDr_BYTE_MODEf_GET BCMI_TSC_XGXS_COMMANDr_BYTE_MODEf_GET
#define COMMANDr_BYTE_MODEf_SET BCMI_TSC_XGXS_COMMANDr_BYTE_MODEf_SET
#define COMMANDr_RESERVED0f_GET BCMI_TSC_XGXS_COMMANDr_RESERVED0f_GET
#define COMMANDr_RESERVED0f_SET BCMI_TSC_XGXS_COMMANDr_RESERVED0f_SET
#define COMMANDr_MDIO_UC_RESET_Nf_GET BCMI_TSC_XGXS_COMMANDr_MDIO_UC_RESET_Nf_GET
#define COMMANDr_MDIO_UC_RESET_Nf_SET BCMI_TSC_XGXS_COMMANDr_MDIO_UC_RESET_Nf_SET
#define COMMANDr_WRITEf_GET BCMI_TSC_XGXS_COMMANDr_WRITEf_GET
#define COMMANDr_WRITEf_SET BCMI_TSC_XGXS_COMMANDr_WRITEf_SET
#define COMMANDr_READf_GET BCMI_TSC_XGXS_COMMANDr_READf_GET
#define COMMANDr_READf_SET BCMI_TSC_XGXS_COMMANDr_READf_SET
#define COMMANDr_STOPf_GET BCMI_TSC_XGXS_COMMANDr_STOPf_GET
#define COMMANDr_STOPf_SET BCMI_TSC_XGXS_COMMANDr_STOPf_SET
#define COMMANDr_RUNf_GET BCMI_TSC_XGXS_COMMANDr_RUNf_GET
#define COMMANDr_RUNf_SET BCMI_TSC_XGXS_COMMANDr_RUNf_SET
#define READ_COMMANDr BCMI_TSC_XGXS_READ_COMMANDr
#define WRITE_COMMANDr BCMI_TSC_XGXS_WRITE_COMMANDr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_COMMANDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  WRDATA
 * BLOCKS:   UC
 * REGADDR:  0xffc3
 * DESC:     Write Data Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     WRDATA           
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_WRDATAr (0x0010ffc3 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_WRDATAr_SIZE 4

/*
 * This structure should be used to declare and program WRDATA.
 *
 */
typedef union BCMI_TSC_XGXS_WRDATAr_s {
	uint32_t v[1];
	uint32_t wrdata[1];
	uint32_t _wrdata;
} BCMI_TSC_XGXS_WRDATAr_t;

#define BCMI_TSC_XGXS_WRDATAr_CLR(r) (r).wrdata[0] = 0
#define BCMI_TSC_XGXS_WRDATAr_SET(r,d) (r).wrdata[0] = d
#define BCMI_TSC_XGXS_WRDATAr_GET(r) (r).wrdata[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_WRDATAr_WRDATAf_GET(r) (((r).wrdata[0]) & 0xffff)
#define BCMI_TSC_XGXS_WRDATAr_WRDATAf_SET(r,f) (r).wrdata[0]=(((r).wrdata[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access WRDATA.
 *
 */
#define BCMI_TSC_XGXS_READ_WRDATAr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_WRDATAr,(_r._wrdata))
#define BCMI_TSC_XGXS_WRITE_WRDATAr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_WRDATAr,(_r._wrdata))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define WRDATAr BCMI_TSC_XGXS_WRDATAr
#define WRDATAr_SIZE BCMI_TSC_XGXS_WRDATAr_SIZE
typedef BCMI_TSC_XGXS_WRDATAr_t WRDATAr_t;
#define WRDATAr_CLR BCMI_TSC_XGXS_WRDATAr_CLR
#define WRDATAr_SET BCMI_TSC_XGXS_WRDATAr_SET
#define WRDATAr_GET BCMI_TSC_XGXS_WRDATAr_GET
#define WRDATAr_WRDATAf_GET BCMI_TSC_XGXS_WRDATAr_WRDATAf_GET
#define WRDATAr_WRDATAf_SET BCMI_TSC_XGXS_WRDATAr_WRDATAf_SET
#define READ_WRDATAr BCMI_TSC_XGXS_READ_WRDATAr
#define WRITE_WRDATAr BCMI_TSC_XGXS_WRITE_WRDATAr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_WRDATAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  RDDATA
 * BLOCKS:   UC
 * REGADDR:  0xffc4
 * DESC:     Read Data Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     RDDATA           
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_RDDATAr (0x0010ffc4 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_RDDATAr_SIZE 4

/*
 * This structure should be used to declare and program RDDATA.
 *
 */
typedef union BCMI_TSC_XGXS_RDDATAr_s {
	uint32_t v[1];
	uint32_t rddata[1];
	uint32_t _rddata;
} BCMI_TSC_XGXS_RDDATAr_t;

#define BCMI_TSC_XGXS_RDDATAr_CLR(r) (r).rddata[0] = 0
#define BCMI_TSC_XGXS_RDDATAr_SET(r,d) (r).rddata[0] = d
#define BCMI_TSC_XGXS_RDDATAr_GET(r) (r).rddata[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_RDDATAr_RDDATAf_GET(r) (((r).rddata[0]) & 0xffff)
#define BCMI_TSC_XGXS_RDDATAr_RDDATAf_SET(r,f) (r).rddata[0]=(((r).rddata[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access RDDATA.
 *
 */
#define BCMI_TSC_XGXS_READ_RDDATAr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_RDDATAr,(_r._rddata))
#define BCMI_TSC_XGXS_WRITE_RDDATAr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_RDDATAr,(_r._rddata))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define RDDATAr BCMI_TSC_XGXS_RDDATAr
#define RDDATAr_SIZE BCMI_TSC_XGXS_RDDATAr_SIZE
typedef BCMI_TSC_XGXS_RDDATAr_t RDDATAr_t;
#define RDDATAr_CLR BCMI_TSC_XGXS_RDDATAr_CLR
#define RDDATAr_SET BCMI_TSC_XGXS_RDDATAr_SET
#define RDDATAr_GET BCMI_TSC_XGXS_RDDATAr_GET
#define RDDATAr_RDDATAf_GET BCMI_TSC_XGXS_RDDATAr_RDDATAf_GET
#define RDDATAr_RDDATAf_SET BCMI_TSC_XGXS_RDDATAr_RDDATAf_SET
#define READ_RDDATAr BCMI_TSC_XGXS_READ_RDDATAr
#define WRITE_RDDATAr BCMI_TSC_XGXS_WRITE_RDDATAr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_RDDATAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  DOWNLOAD_STATUS
 * BLOCKS:   UC
 * REGADDR:  0xffc5
 * DESC:     MDIO to 8051 FSM Status Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     ERR0             
 *     ERR1             
 *     FSM              
 *     RESERVED0        
 *     INIT_DONE        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_DOWNLOAD_STATUSr (0x0010ffc5 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_DOWNLOAD_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program DOWNLOAD_STATUS.
 *
 */
typedef union BCMI_TSC_XGXS_DOWNLOAD_STATUSr_s {
	uint32_t v[1];
	uint32_t download_status[1];
	uint32_t _download_status;
} BCMI_TSC_XGXS_DOWNLOAD_STATUSr_t;

#define BCMI_TSC_XGXS_DOWNLOAD_STATUSr_CLR(r) (r).download_status[0] = 0
#define BCMI_TSC_XGXS_DOWNLOAD_STATUSr_SET(r,d) (r).download_status[0] = d
#define BCMI_TSC_XGXS_DOWNLOAD_STATUSr_GET(r) (r).download_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_DOWNLOAD_STATUSr_INIT_DONEf_GET(r) ((((r).download_status[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_DOWNLOAD_STATUSr_INIT_DONEf_SET(r,f) (r).download_status[0]=(((r).download_status[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_DOWNLOAD_STATUSr_RESERVED0f_GET(r) ((((r).download_status[0]) >> 6) & 0x1ff)
#define BCMI_TSC_XGXS_DOWNLOAD_STATUSr_RESERVED0f_SET(r,f) (r).download_status[0]=(((r).download_status[0] & ~((uint32_t)0x1ff << 6)) | ((((uint32_t)f) & 0x1ff) << 6))
#define BCMI_TSC_XGXS_DOWNLOAD_STATUSr_FSMf_GET(r) ((((r).download_status[0]) >> 2) & 0xf)
#define BCMI_TSC_XGXS_DOWNLOAD_STATUSr_FSMf_SET(r,f) (r).download_status[0]=(((r).download_status[0] & ~((uint32_t)0xf << 2)) | ((((uint32_t)f) & 0xf) << 2))
#define BCMI_TSC_XGXS_DOWNLOAD_STATUSr_ERR1f_GET(r) ((((r).download_status[0]) >> 1) & 0x1)
#define BCMI_TSC_XGXS_DOWNLOAD_STATUSr_ERR1f_SET(r,f) (r).download_status[0]=(((r).download_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCMI_TSC_XGXS_DOWNLOAD_STATUSr_ERR0f_GET(r) (((r).download_status[0]) & 0x1)
#define BCMI_TSC_XGXS_DOWNLOAD_STATUSr_ERR0f_SET(r,f) (r).download_status[0]=(((r).download_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access DOWNLOAD_STATUS.
 *
 */
#define BCMI_TSC_XGXS_READ_DOWNLOAD_STATUSr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_DOWNLOAD_STATUSr,(_r._download_status))
#define BCMI_TSC_XGXS_WRITE_DOWNLOAD_STATUSr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_DOWNLOAD_STATUSr,(_r._download_status))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DOWNLOAD_STATUSr BCMI_TSC_XGXS_DOWNLOAD_STATUSr
#define DOWNLOAD_STATUSr_SIZE BCMI_TSC_XGXS_DOWNLOAD_STATUSr_SIZE
typedef BCMI_TSC_XGXS_DOWNLOAD_STATUSr_t DOWNLOAD_STATUSr_t;
#define DOWNLOAD_STATUSr_CLR BCMI_TSC_XGXS_DOWNLOAD_STATUSr_CLR
#define DOWNLOAD_STATUSr_SET BCMI_TSC_XGXS_DOWNLOAD_STATUSr_SET
#define DOWNLOAD_STATUSr_GET BCMI_TSC_XGXS_DOWNLOAD_STATUSr_GET
#define DOWNLOAD_STATUSr_INIT_DONEf_GET BCMI_TSC_XGXS_DOWNLOAD_STATUSr_INIT_DONEf_GET
#define DOWNLOAD_STATUSr_INIT_DONEf_SET BCMI_TSC_XGXS_DOWNLOAD_STATUSr_INIT_DONEf_SET
#define DOWNLOAD_STATUSr_RESERVED0f_GET BCMI_TSC_XGXS_DOWNLOAD_STATUSr_RESERVED0f_GET
#define DOWNLOAD_STATUSr_RESERVED0f_SET BCMI_TSC_XGXS_DOWNLOAD_STATUSr_RESERVED0f_SET
#define DOWNLOAD_STATUSr_FSMf_GET BCMI_TSC_XGXS_DOWNLOAD_STATUSr_FSMf_GET
#define DOWNLOAD_STATUSr_FSMf_SET BCMI_TSC_XGXS_DOWNLOAD_STATUSr_FSMf_SET
#define DOWNLOAD_STATUSr_ERR1f_GET BCMI_TSC_XGXS_DOWNLOAD_STATUSr_ERR1f_GET
#define DOWNLOAD_STATUSr_ERR1f_SET BCMI_TSC_XGXS_DOWNLOAD_STATUSr_ERR1f_SET
#define DOWNLOAD_STATUSr_ERR0f_GET BCMI_TSC_XGXS_DOWNLOAD_STATUSr_ERR0f_GET
#define DOWNLOAD_STATUSr_ERR0f_SET BCMI_TSC_XGXS_DOWNLOAD_STATUSr_ERR0f_SET
#define READ_DOWNLOAD_STATUSr BCMI_TSC_XGXS_READ_DOWNLOAD_STATUSr
#define WRITE_DOWNLOAD_STATUSr BCMI_TSC_XGXS_WRITE_DOWNLOAD_STATUSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_DOWNLOAD_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  SFR_STATUS
 * BLOCKS:   UC
 * REGADDR:  0xffc6
 * DESC:     8051 SFR FSM status: 00000000
 * SIZE:     32
 * FIELDS:
 *     DW8051_TO_PCB_FSM_U_DW8051_TO_PCB_FSM_U 
 *     DW8051_TO_PCB_FSM_L_DW8051_TO_PCB_FSM_L 
 *     ECC_ERROR_COUNTERS_ECC_ERROR_COUNTERS 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_SFR_STATUSr (0x0010ffc6 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_SFR_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program SFR_STATUS.
 *
 */
typedef union BCMI_TSC_XGXS_SFR_STATUSr_s {
	uint32_t v[1];
	uint32_t sfr_status[1];
	uint32_t _sfr_status;
} BCMI_TSC_XGXS_SFR_STATUSr_t;

#define BCMI_TSC_XGXS_SFR_STATUSr_CLR(r) (r).sfr_status[0] = 0
#define BCMI_TSC_XGXS_SFR_STATUSr_SET(r,d) (r).sfr_status[0] = d
#define BCMI_TSC_XGXS_SFR_STATUSr_GET(r) (r).sfr_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_SFR_STATUSr_DW8051_TO_PCB_FSM_U_DW8051_TO_PCB_FSM_Uf_GET(r) (((r).sfr_status[0]) & 0xffff)
#define BCMI_TSC_XGXS_SFR_STATUSr_DW8051_TO_PCB_FSM_U_DW8051_TO_PCB_FSM_Uf_SET(r,f) (r).sfr_status[0]=(((r).sfr_status[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCMI_TSC_XGXS_SFR_STATUSr_ECC_ERROR_COUNTERS_ECC_ERROR_COUNTERSf_GET(r) (((r).sfr_status[0]) & 0xffff)
#define BCMI_TSC_XGXS_SFR_STATUSr_ECC_ERROR_COUNTERS_ECC_ERROR_COUNTERSf_SET(r,f) (r).sfr_status[0]=(((r).sfr_status[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCMI_TSC_XGXS_SFR_STATUSr_DW8051_TO_PCB_FSM_L_DW8051_TO_PCB_FSM_Lf_GET(r) (((r).sfr_status[0]) & 0xffff)
#define BCMI_TSC_XGXS_SFR_STATUSr_DW8051_TO_PCB_FSM_L_DW8051_TO_PCB_FSM_Lf_SET(r,f) (r).sfr_status[0]=(((r).sfr_status[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access SFR_STATUS.
 *
 */
#define BCMI_TSC_XGXS_READ_SFR_STATUSr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_SFR_STATUSr,(_r._sfr_status))
#define BCMI_TSC_XGXS_WRITE_SFR_STATUSr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_SFR_STATUSr,(_r._sfr_status))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SFR_STATUSr BCMI_TSC_XGXS_SFR_STATUSr
#define SFR_STATUSr_SIZE BCMI_TSC_XGXS_SFR_STATUSr_SIZE
typedef BCMI_TSC_XGXS_SFR_STATUSr_t SFR_STATUSr_t;
#define SFR_STATUSr_CLR BCMI_TSC_XGXS_SFR_STATUSr_CLR
#define SFR_STATUSr_SET BCMI_TSC_XGXS_SFR_STATUSr_SET
#define SFR_STATUSr_GET BCMI_TSC_XGXS_SFR_STATUSr_GET
#define SFR_STATUSr_DW8051_TO_PCB_FSM_U_DW8051_TO_PCB_FSM_Uf_GET BCMI_TSC_XGXS_SFR_STATUSr_DW8051_TO_PCB_FSM_U_DW8051_TO_PCB_FSM_Uf_GET
#define SFR_STATUSr_DW8051_TO_PCB_FSM_U_DW8051_TO_PCB_FSM_Uf_SET BCMI_TSC_XGXS_SFR_STATUSr_DW8051_TO_PCB_FSM_U_DW8051_TO_PCB_FSM_Uf_SET
#define SFR_STATUSr_ECC_ERROR_COUNTERS_ECC_ERROR_COUNTERSf_GET BCMI_TSC_XGXS_SFR_STATUSr_ECC_ERROR_COUNTERS_ECC_ERROR_COUNTERSf_GET
#define SFR_STATUSr_ECC_ERROR_COUNTERS_ECC_ERROR_COUNTERSf_SET BCMI_TSC_XGXS_SFR_STATUSr_ECC_ERROR_COUNTERS_ECC_ERROR_COUNTERSf_SET
#define SFR_STATUSr_DW8051_TO_PCB_FSM_L_DW8051_TO_PCB_FSM_Lf_GET BCMI_TSC_XGXS_SFR_STATUSr_DW8051_TO_PCB_FSM_L_DW8051_TO_PCB_FSM_Lf_GET
#define SFR_STATUSr_DW8051_TO_PCB_FSM_L_DW8051_TO_PCB_FSM_Lf_SET BCMI_TSC_XGXS_SFR_STATUSr_DW8051_TO_PCB_FSM_L_DW8051_TO_PCB_FSM_Lf_SET
#define READ_SFR_STATUSr BCMI_TSC_XGXS_READ_SFR_STATUSr
#define WRITE_SFR_STATUSr BCMI_TSC_XGXS_WRITE_SFR_STATUSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_SFR_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  COMMAND4
 * BLOCKS:   UC
 * REGADDR:  0xffc7
 * DESC:     Command Register 4: 00000000
 * SIZE:     32
 * FIELDS:
 *     MDIO_EITU_INT0   
 *     MDIO_EITU_INT1   
 *     MDIO_EITU_INT2   
 *     MDIO_EITU_INT3   
 *     MDIO_EITU_INT4   
 *     MDIO_EITU_INT5   
 *     TM_REGISTER_RAM  
 *     TM_DATA_RAM      
 *     DATA_RAM_R_W     
 *     DATA_RAM_ACCESS  
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_COMMAND4r (0x0010ffc7 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_COMMAND4r_SIZE 4

/*
 * This structure should be used to declare and program COMMAND4.
 *
 */
typedef union BCMI_TSC_XGXS_COMMAND4r_s {
	uint32_t v[1];
	uint32_t command4[1];
	uint32_t _command4;
} BCMI_TSC_XGXS_COMMAND4r_t;

#define BCMI_TSC_XGXS_COMMAND4r_CLR(r) (r).command4[0] = 0
#define BCMI_TSC_XGXS_COMMAND4r_SET(r,d) (r).command4[0] = d
#define BCMI_TSC_XGXS_COMMAND4r_GET(r) (r).command4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_COMMAND4r_DATA_RAM_ACCESSf_GET(r) ((((r).command4[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_COMMAND4r_DATA_RAM_ACCESSf_SET(r,f) (r).command4[0]=(((r).command4[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_COMMAND4r_DATA_RAM_R_Wf_GET(r) ((((r).command4[0]) >> 14) & 0x1)
#define BCMI_TSC_XGXS_COMMAND4r_DATA_RAM_R_Wf_SET(r,f) (r).command4[0]=(((r).command4[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCMI_TSC_XGXS_COMMAND4r_TM_DATA_RAMf_GET(r) ((((r).command4[0]) >> 8) & 0x3f)
#define BCMI_TSC_XGXS_COMMAND4r_TM_DATA_RAMf_SET(r,f) (r).command4[0]=(((r).command4[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define BCMI_TSC_XGXS_COMMAND4r_TM_REGISTER_RAMf_GET(r) ((((r).command4[0]) >> 6) & 0x3)
#define BCMI_TSC_XGXS_COMMAND4r_TM_REGISTER_RAMf_SET(r,f) (r).command4[0]=(((r).command4[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCMI_TSC_XGXS_COMMAND4r_MDIO_EITU_INT5f_GET(r) ((((r).command4[0]) >> 5) & 0x1)
#define BCMI_TSC_XGXS_COMMAND4r_MDIO_EITU_INT5f_SET(r,f) (r).command4[0]=(((r).command4[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCMI_TSC_XGXS_COMMAND4r_MDIO_EITU_INT4f_GET(r) ((((r).command4[0]) >> 4) & 0x1)
#define BCMI_TSC_XGXS_COMMAND4r_MDIO_EITU_INT4f_SET(r,f) (r).command4[0]=(((r).command4[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCMI_TSC_XGXS_COMMAND4r_MDIO_EITU_INT3f_GET(r) ((((r).command4[0]) >> 3) & 0x1)
#define BCMI_TSC_XGXS_COMMAND4r_MDIO_EITU_INT3f_SET(r,f) (r).command4[0]=(((r).command4[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCMI_TSC_XGXS_COMMAND4r_MDIO_EITU_INT2f_GET(r) ((((r).command4[0]) >> 2) & 0x1)
#define BCMI_TSC_XGXS_COMMAND4r_MDIO_EITU_INT2f_SET(r,f) (r).command4[0]=(((r).command4[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCMI_TSC_XGXS_COMMAND4r_MDIO_EITU_INT1f_GET(r) ((((r).command4[0]) >> 1) & 0x1)
#define BCMI_TSC_XGXS_COMMAND4r_MDIO_EITU_INT1f_SET(r,f) (r).command4[0]=(((r).command4[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCMI_TSC_XGXS_COMMAND4r_MDIO_EITU_INT0f_GET(r) (((r).command4[0]) & 0x1)
#define BCMI_TSC_XGXS_COMMAND4r_MDIO_EITU_INT0f_SET(r,f) (r).command4[0]=(((r).command4[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access COMMAND4.
 *
 */
#define BCMI_TSC_XGXS_READ_COMMAND4r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_COMMAND4r,(_r._command4))
#define BCMI_TSC_XGXS_WRITE_COMMAND4r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_COMMAND4r,(_r._command4))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define COMMAND4r BCMI_TSC_XGXS_COMMAND4r
#define COMMAND4r_SIZE BCMI_TSC_XGXS_COMMAND4r_SIZE
typedef BCMI_TSC_XGXS_COMMAND4r_t COMMAND4r_t;
#define COMMAND4r_CLR BCMI_TSC_XGXS_COMMAND4r_CLR
#define COMMAND4r_SET BCMI_TSC_XGXS_COMMAND4r_SET
#define COMMAND4r_GET BCMI_TSC_XGXS_COMMAND4r_GET
#define COMMAND4r_DATA_RAM_ACCESSf_GET BCMI_TSC_XGXS_COMMAND4r_DATA_RAM_ACCESSf_GET
#define COMMAND4r_DATA_RAM_ACCESSf_SET BCMI_TSC_XGXS_COMMAND4r_DATA_RAM_ACCESSf_SET
#define COMMAND4r_DATA_RAM_R_Wf_GET BCMI_TSC_XGXS_COMMAND4r_DATA_RAM_R_Wf_GET
#define COMMAND4r_DATA_RAM_R_Wf_SET BCMI_TSC_XGXS_COMMAND4r_DATA_RAM_R_Wf_SET
#define COMMAND4r_TM_DATA_RAMf_GET BCMI_TSC_XGXS_COMMAND4r_TM_DATA_RAMf_GET
#define COMMAND4r_TM_DATA_RAMf_SET BCMI_TSC_XGXS_COMMAND4r_TM_DATA_RAMf_SET
#define COMMAND4r_TM_REGISTER_RAMf_GET BCMI_TSC_XGXS_COMMAND4r_TM_REGISTER_RAMf_GET
#define COMMAND4r_TM_REGISTER_RAMf_SET BCMI_TSC_XGXS_COMMAND4r_TM_REGISTER_RAMf_SET
#define COMMAND4r_MDIO_EITU_INT5f_GET BCMI_TSC_XGXS_COMMAND4r_MDIO_EITU_INT5f_GET
#define COMMAND4r_MDIO_EITU_INT5f_SET BCMI_TSC_XGXS_COMMAND4r_MDIO_EITU_INT5f_SET
#define COMMAND4r_MDIO_EITU_INT4f_GET BCMI_TSC_XGXS_COMMAND4r_MDIO_EITU_INT4f_GET
#define COMMAND4r_MDIO_EITU_INT4f_SET BCMI_TSC_XGXS_COMMAND4r_MDIO_EITU_INT4f_SET
#define COMMAND4r_MDIO_EITU_INT3f_GET BCMI_TSC_XGXS_COMMAND4r_MDIO_EITU_INT3f_GET
#define COMMAND4r_MDIO_EITU_INT3f_SET BCMI_TSC_XGXS_COMMAND4r_MDIO_EITU_INT3f_SET
#define COMMAND4r_MDIO_EITU_INT2f_GET BCMI_TSC_XGXS_COMMAND4r_MDIO_EITU_INT2f_GET
#define COMMAND4r_MDIO_EITU_INT2f_SET BCMI_TSC_XGXS_COMMAND4r_MDIO_EITU_INT2f_SET
#define COMMAND4r_MDIO_EITU_INT1f_GET BCMI_TSC_XGXS_COMMAND4r_MDIO_EITU_INT1f_GET
#define COMMAND4r_MDIO_EITU_INT1f_SET BCMI_TSC_XGXS_COMMAND4r_MDIO_EITU_INT1f_SET
#define COMMAND4r_MDIO_EITU_INT0f_GET BCMI_TSC_XGXS_COMMAND4r_MDIO_EITU_INT0f_GET
#define COMMAND4r_MDIO_EITU_INT0f_SET BCMI_TSC_XGXS_COMMAND4r_MDIO_EITU_INT0f_SET
#define READ_COMMAND4r BCMI_TSC_XGXS_READ_COMMAND4r
#define WRITE_COMMAND4r BCMI_TSC_XGXS_WRITE_COMMAND4r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_COMMAND4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  MDIO_UC_MAILBOX
 * BLOCKS:   UC
 * REGADDR:  0xffc8
 * DESC:     External station to uC mailbox: 00000000
 * SIZE:     32
 * FIELDS:
 *     MDIO_UC_MAILBOX  
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_MDIO_UC_MAILBOXr (0x0010ffc8 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_MDIO_UC_MAILBOXr_SIZE 4

/*
 * This structure should be used to declare and program MDIO_UC_MAILBOX.
 *
 */
typedef union BCMI_TSC_XGXS_MDIO_UC_MAILBOXr_s {
	uint32_t v[1];
	uint32_t mdio_uc_mailbox[1];
	uint32_t _mdio_uc_mailbox;
} BCMI_TSC_XGXS_MDIO_UC_MAILBOXr_t;

#define BCMI_TSC_XGXS_MDIO_UC_MAILBOXr_CLR(r) (r).mdio_uc_mailbox[0] = 0
#define BCMI_TSC_XGXS_MDIO_UC_MAILBOXr_SET(r,d) (r).mdio_uc_mailbox[0] = d
#define BCMI_TSC_XGXS_MDIO_UC_MAILBOXr_GET(r) (r).mdio_uc_mailbox[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_MDIO_UC_MAILBOXr_MDIO_UC_MAILBOXf_GET(r) (((r).mdio_uc_mailbox[0]) & 0xffff)
#define BCMI_TSC_XGXS_MDIO_UC_MAILBOXr_MDIO_UC_MAILBOXf_SET(r,f) (r).mdio_uc_mailbox[0]=(((r).mdio_uc_mailbox[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access MDIO_UC_MAILBOX.
 *
 */
#define BCMI_TSC_XGXS_READ_MDIO_UC_MAILBOXr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_MDIO_UC_MAILBOXr,(_r._mdio_uc_mailbox))
#define BCMI_TSC_XGXS_WRITE_MDIO_UC_MAILBOXr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_MDIO_UC_MAILBOXr,(_r._mdio_uc_mailbox))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MDIO_UC_MAILBOXr BCMI_TSC_XGXS_MDIO_UC_MAILBOXr
#define MDIO_UC_MAILBOXr_SIZE BCMI_TSC_XGXS_MDIO_UC_MAILBOXr_SIZE
typedef BCMI_TSC_XGXS_MDIO_UC_MAILBOXr_t MDIO_UC_MAILBOXr_t;
#define MDIO_UC_MAILBOXr_CLR BCMI_TSC_XGXS_MDIO_UC_MAILBOXr_CLR
#define MDIO_UC_MAILBOXr_SET BCMI_TSC_XGXS_MDIO_UC_MAILBOXr_SET
#define MDIO_UC_MAILBOXr_GET BCMI_TSC_XGXS_MDIO_UC_MAILBOXr_GET
#define MDIO_UC_MAILBOXr_MDIO_UC_MAILBOXf_GET BCMI_TSC_XGXS_MDIO_UC_MAILBOXr_MDIO_UC_MAILBOXf_GET
#define MDIO_UC_MAILBOXr_MDIO_UC_MAILBOXf_SET BCMI_TSC_XGXS_MDIO_UC_MAILBOXr_MDIO_UC_MAILBOXf_SET
#define READ_MDIO_UC_MAILBOXr BCMI_TSC_XGXS_READ_MDIO_UC_MAILBOXr
#define WRITE_MDIO_UC_MAILBOXr BCMI_TSC_XGXS_WRITE_MDIO_UC_MAILBOXr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_MDIO_UC_MAILBOXr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  UC_MDIO_MAILBOX
 * BLOCKS:   UC
 * REGADDR:  0xffc9
 * DESC:     uC to external station mailbox: 00000000
 * SIZE:     32
 * FIELDS:
 *     UC_MDIO_MAILBOX  
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_UC_MDIO_MAILBOXr (0x0010ffc9 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_UC_MDIO_MAILBOXr_SIZE 4

/*
 * This structure should be used to declare and program UC_MDIO_MAILBOX.
 *
 */
typedef union BCMI_TSC_XGXS_UC_MDIO_MAILBOXr_s {
	uint32_t v[1];
	uint32_t uc_mdio_mailbox[1];
	uint32_t _uc_mdio_mailbox;
} BCMI_TSC_XGXS_UC_MDIO_MAILBOXr_t;

#define BCMI_TSC_XGXS_UC_MDIO_MAILBOXr_CLR(r) (r).uc_mdio_mailbox[0] = 0
#define BCMI_TSC_XGXS_UC_MDIO_MAILBOXr_SET(r,d) (r).uc_mdio_mailbox[0] = d
#define BCMI_TSC_XGXS_UC_MDIO_MAILBOXr_GET(r) (r).uc_mdio_mailbox[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_UC_MDIO_MAILBOXr_UC_MDIO_MAILBOXf_GET(r) (((r).uc_mdio_mailbox[0]) & 0xffff)
#define BCMI_TSC_XGXS_UC_MDIO_MAILBOXr_UC_MDIO_MAILBOXf_SET(r,f) (r).uc_mdio_mailbox[0]=(((r).uc_mdio_mailbox[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access UC_MDIO_MAILBOX.
 *
 */
#define BCMI_TSC_XGXS_READ_UC_MDIO_MAILBOXr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_UC_MDIO_MAILBOXr,(_r._uc_mdio_mailbox))
#define BCMI_TSC_XGXS_WRITE_UC_MDIO_MAILBOXr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_UC_MDIO_MAILBOXr,(_r._uc_mdio_mailbox))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define UC_MDIO_MAILBOXr BCMI_TSC_XGXS_UC_MDIO_MAILBOXr
#define UC_MDIO_MAILBOXr_SIZE BCMI_TSC_XGXS_UC_MDIO_MAILBOXr_SIZE
typedef BCMI_TSC_XGXS_UC_MDIO_MAILBOXr_t UC_MDIO_MAILBOXr_t;
#define UC_MDIO_MAILBOXr_CLR BCMI_TSC_XGXS_UC_MDIO_MAILBOXr_CLR
#define UC_MDIO_MAILBOXr_SET BCMI_TSC_XGXS_UC_MDIO_MAILBOXr_SET
#define UC_MDIO_MAILBOXr_GET BCMI_TSC_XGXS_UC_MDIO_MAILBOXr_GET
#define UC_MDIO_MAILBOXr_UC_MDIO_MAILBOXf_GET BCMI_TSC_XGXS_UC_MDIO_MAILBOXr_UC_MDIO_MAILBOXf_GET
#define UC_MDIO_MAILBOXr_UC_MDIO_MAILBOXf_SET BCMI_TSC_XGXS_UC_MDIO_MAILBOXr_UC_MDIO_MAILBOXf_SET
#define READ_UC_MDIO_MAILBOXr BCMI_TSC_XGXS_READ_UC_MDIO_MAILBOXr
#define WRITE_UC_MDIO_MAILBOXr BCMI_TSC_XGXS_WRITE_UC_MDIO_MAILBOXr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_UC_MDIO_MAILBOXr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  COMMAND2
 * BLOCKS:   UC
 * REGADDR:  0xffca
 * DESC:     Command Register 2: 00000000
 * SIZE:     32
 * FIELDS:
 *     TMR_EN           
 *     WDOG_EN          
 *     REFDIV2_TMR_EN   
 *     REFDIV4_TMR_EN   
 *     WDOG_DISABLE     
 *     TIMER_MUX_SEL    
 *     RESERVED0        
 *     ZERO_ROM_DATAOUT 
 *     FIRMWARE_RESET_DISABLE 
 *     M8051_TO_PCB_RESET 
 *     MDIO_TO_8051_RESET 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_COMMAND2r (0x0010ffca | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_COMMAND2r_SIZE 4

/*
 * This structure should be used to declare and program COMMAND2.
 *
 */
typedef union BCMI_TSC_XGXS_COMMAND2r_s {
	uint32_t v[1];
	uint32_t command2[1];
	uint32_t _command2;
} BCMI_TSC_XGXS_COMMAND2r_t;

#define BCMI_TSC_XGXS_COMMAND2r_CLR(r) (r).command2[0] = 0
#define BCMI_TSC_XGXS_COMMAND2r_SET(r,d) (r).command2[0] = d
#define BCMI_TSC_XGXS_COMMAND2r_GET(r) (r).command2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_COMMAND2r_MDIO_TO_8051_RESETf_GET(r) ((((r).command2[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_COMMAND2r_MDIO_TO_8051_RESETf_SET(r,f) (r).command2[0]=(((r).command2[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_COMMAND2r_M8051_TO_PCB_RESETf_GET(r) ((((r).command2[0]) >> 14) & 0x1)
#define BCMI_TSC_XGXS_COMMAND2r_M8051_TO_PCB_RESETf_SET(r,f) (r).command2[0]=(((r).command2[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCMI_TSC_XGXS_COMMAND2r_FIRMWARE_RESET_DISABLEf_GET(r) ((((r).command2[0]) >> 13) & 0x1)
#define BCMI_TSC_XGXS_COMMAND2r_FIRMWARE_RESET_DISABLEf_SET(r,f) (r).command2[0]=(((r).command2[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCMI_TSC_XGXS_COMMAND2r_ZERO_ROM_DATAOUTf_GET(r) ((((r).command2[0]) >> 12) & 0x1)
#define BCMI_TSC_XGXS_COMMAND2r_ZERO_ROM_DATAOUTf_SET(r,f) (r).command2[0]=(((r).command2[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCMI_TSC_XGXS_COMMAND2r_RESERVED0f_GET(r) ((((r).command2[0]) >> 10) & 0x3)
#define BCMI_TSC_XGXS_COMMAND2r_RESERVED0f_SET(r,f) (r).command2[0]=(((r).command2[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCMI_TSC_XGXS_COMMAND2r_TIMER_MUX_SELf_GET(r) ((((r).command2[0]) >> 8) & 0x3)
#define BCMI_TSC_XGXS_COMMAND2r_TIMER_MUX_SELf_SET(r,f) (r).command2[0]=(((r).command2[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCMI_TSC_XGXS_COMMAND2r_WDOG_DISABLEf_GET(r) ((((r).command2[0]) >> 7) & 0x1)
#define BCMI_TSC_XGXS_COMMAND2r_WDOG_DISABLEf_SET(r,f) (r).command2[0]=(((r).command2[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCMI_TSC_XGXS_COMMAND2r_REFDIV4_TMR_ENf_GET(r) ((((r).command2[0]) >> 6) & 0x1)
#define BCMI_TSC_XGXS_COMMAND2r_REFDIV4_TMR_ENf_SET(r,f) (r).command2[0]=(((r).command2[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCMI_TSC_XGXS_COMMAND2r_REFDIV2_TMR_ENf_GET(r) ((((r).command2[0]) >> 5) & 0x1)
#define BCMI_TSC_XGXS_COMMAND2r_REFDIV2_TMR_ENf_SET(r,f) (r).command2[0]=(((r).command2[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCMI_TSC_XGXS_COMMAND2r_WDOG_ENf_GET(r) ((((r).command2[0]) >> 4) & 0x1)
#define BCMI_TSC_XGXS_COMMAND2r_WDOG_ENf_SET(r,f) (r).command2[0]=(((r).command2[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCMI_TSC_XGXS_COMMAND2r_TMR_ENf_GET(r) (((r).command2[0]) & 0xf)
#define BCMI_TSC_XGXS_COMMAND2r_TMR_ENf_SET(r,f) (r).command2[0]=(((r).command2[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access COMMAND2.
 *
 */
#define BCMI_TSC_XGXS_READ_COMMAND2r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_COMMAND2r,(_r._command2))
#define BCMI_TSC_XGXS_WRITE_COMMAND2r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_COMMAND2r,(_r._command2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define COMMAND2r BCMI_TSC_XGXS_COMMAND2r
#define COMMAND2r_SIZE BCMI_TSC_XGXS_COMMAND2r_SIZE
typedef BCMI_TSC_XGXS_COMMAND2r_t COMMAND2r_t;
#define COMMAND2r_CLR BCMI_TSC_XGXS_COMMAND2r_CLR
#define COMMAND2r_SET BCMI_TSC_XGXS_COMMAND2r_SET
#define COMMAND2r_GET BCMI_TSC_XGXS_COMMAND2r_GET
#define COMMAND2r_MDIO_TO_8051_RESETf_GET BCMI_TSC_XGXS_COMMAND2r_MDIO_TO_8051_RESETf_GET
#define COMMAND2r_MDIO_TO_8051_RESETf_SET BCMI_TSC_XGXS_COMMAND2r_MDIO_TO_8051_RESETf_SET
#define COMMAND2r_M8051_TO_PCB_RESETf_GET BCMI_TSC_XGXS_COMMAND2r_M8051_TO_PCB_RESETf_GET
#define COMMAND2r_M8051_TO_PCB_RESETf_SET BCMI_TSC_XGXS_COMMAND2r_M8051_TO_PCB_RESETf_SET
#define COMMAND2r_FIRMWARE_RESET_DISABLEf_GET BCMI_TSC_XGXS_COMMAND2r_FIRMWARE_RESET_DISABLEf_GET
#define COMMAND2r_FIRMWARE_RESET_DISABLEf_SET BCMI_TSC_XGXS_COMMAND2r_FIRMWARE_RESET_DISABLEf_SET
#define COMMAND2r_ZERO_ROM_DATAOUTf_GET BCMI_TSC_XGXS_COMMAND2r_ZERO_ROM_DATAOUTf_GET
#define COMMAND2r_ZERO_ROM_DATAOUTf_SET BCMI_TSC_XGXS_COMMAND2r_ZERO_ROM_DATAOUTf_SET
#define COMMAND2r_RESERVED0f_GET BCMI_TSC_XGXS_COMMAND2r_RESERVED0f_GET
#define COMMAND2r_RESERVED0f_SET BCMI_TSC_XGXS_COMMAND2r_RESERVED0f_SET
#define COMMAND2r_TIMER_MUX_SELf_GET BCMI_TSC_XGXS_COMMAND2r_TIMER_MUX_SELf_GET
#define COMMAND2r_TIMER_MUX_SELf_SET BCMI_TSC_XGXS_COMMAND2r_TIMER_MUX_SELf_SET
#define COMMAND2r_WDOG_DISABLEf_GET BCMI_TSC_XGXS_COMMAND2r_WDOG_DISABLEf_GET
#define COMMAND2r_WDOG_DISABLEf_SET BCMI_TSC_XGXS_COMMAND2r_WDOG_DISABLEf_SET
#define COMMAND2r_REFDIV4_TMR_ENf_GET BCMI_TSC_XGXS_COMMAND2r_REFDIV4_TMR_ENf_GET
#define COMMAND2r_REFDIV4_TMR_ENf_SET BCMI_TSC_XGXS_COMMAND2r_REFDIV4_TMR_ENf_SET
#define COMMAND2r_REFDIV2_TMR_ENf_GET BCMI_TSC_XGXS_COMMAND2r_REFDIV2_TMR_ENf_GET
#define COMMAND2r_REFDIV2_TMR_ENf_SET BCMI_TSC_XGXS_COMMAND2r_REFDIV2_TMR_ENf_SET
#define COMMAND2r_WDOG_ENf_GET BCMI_TSC_XGXS_COMMAND2r_WDOG_ENf_GET
#define COMMAND2r_WDOG_ENf_SET BCMI_TSC_XGXS_COMMAND2r_WDOG_ENf_SET
#define COMMAND2r_TMR_ENf_GET BCMI_TSC_XGXS_COMMAND2r_TMR_ENf_GET
#define COMMAND2r_TMR_ENf_SET BCMI_TSC_XGXS_COMMAND2r_TMR_ENf_SET
#define READ_COMMAND2r BCMI_TSC_XGXS_READ_COMMAND2r
#define WRITE_COMMAND2r BCMI_TSC_XGXS_WRITE_COMMAND2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_COMMAND2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  WDOG_EVNT_CNT
 * BLOCKS:   UC
 * REGADDR:  0xffcb
 * DESC:     wdog_evnt_cnt Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     WDOG_EVNT_CNT    
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_WDOG_EVNT_CNTr (0x0010ffcb | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_WDOG_EVNT_CNTr_SIZE 4

/*
 * This structure should be used to declare and program WDOG_EVNT_CNT.
 *
 */
typedef union BCMI_TSC_XGXS_WDOG_EVNT_CNTr_s {
	uint32_t v[1];
	uint32_t wdog_evnt_cnt[1];
	uint32_t _wdog_evnt_cnt;
} BCMI_TSC_XGXS_WDOG_EVNT_CNTr_t;

#define BCMI_TSC_XGXS_WDOG_EVNT_CNTr_CLR(r) (r).wdog_evnt_cnt[0] = 0
#define BCMI_TSC_XGXS_WDOG_EVNT_CNTr_SET(r,d) (r).wdog_evnt_cnt[0] = d
#define BCMI_TSC_XGXS_WDOG_EVNT_CNTr_GET(r) (r).wdog_evnt_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_WDOG_EVNT_CNTr_WDOG_EVNT_CNTf_GET(r) (((r).wdog_evnt_cnt[0]) & 0xffff)
#define BCMI_TSC_XGXS_WDOG_EVNT_CNTr_WDOG_EVNT_CNTf_SET(r,f) (r).wdog_evnt_cnt[0]=(((r).wdog_evnt_cnt[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access WDOG_EVNT_CNT.
 *
 */
#define BCMI_TSC_XGXS_READ_WDOG_EVNT_CNTr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_WDOG_EVNT_CNTr,(_r._wdog_evnt_cnt))
#define BCMI_TSC_XGXS_WRITE_WDOG_EVNT_CNTr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_WDOG_EVNT_CNTr,(_r._wdog_evnt_cnt))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define WDOG_EVNT_CNTr BCMI_TSC_XGXS_WDOG_EVNT_CNTr
#define WDOG_EVNT_CNTr_SIZE BCMI_TSC_XGXS_WDOG_EVNT_CNTr_SIZE
typedef BCMI_TSC_XGXS_WDOG_EVNT_CNTr_t WDOG_EVNT_CNTr_t;
#define WDOG_EVNT_CNTr_CLR BCMI_TSC_XGXS_WDOG_EVNT_CNTr_CLR
#define WDOG_EVNT_CNTr_SET BCMI_TSC_XGXS_WDOG_EVNT_CNTr_SET
#define WDOG_EVNT_CNTr_GET BCMI_TSC_XGXS_WDOG_EVNT_CNTr_GET
#define WDOG_EVNT_CNTr_WDOG_EVNT_CNTf_GET BCMI_TSC_XGXS_WDOG_EVNT_CNTr_WDOG_EVNT_CNTf_GET
#define WDOG_EVNT_CNTr_WDOG_EVNT_CNTf_SET BCMI_TSC_XGXS_WDOG_EVNT_CNTr_WDOG_EVNT_CNTf_SET
#define READ_WDOG_EVNT_CNTr BCMI_TSC_XGXS_READ_WDOG_EVNT_CNTr
#define WRITE_WDOG_EVNT_CNTr BCMI_TSC_XGXS_WRITE_WDOG_EVNT_CNTr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_WDOG_EVNT_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  COMMAND3
 * BLOCKS:   UC
 * REGADDR:  0xffcc
 * DESC:     Command Register 3: 00000000
 * SIZE:     32
 * FIELDS:
 *     RESERVED0        
 *     EXT_CLK_ENABLE   
 *     IN_STAGING_FLOP_BYPASS 
 *     ENABLE_PM_OVERRIDE 
 *     PM_OVERRIDE_VALUE 
 *     TM               
 *     OUT_STAGING_FLOP_BYPASS 
 *     DISABLE_ECC      
 *     GEN_STATUS_SEL   
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_COMMAND3r (0x0010ffcc | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_COMMAND3r_SIZE 4

/*
 * This structure should be used to declare and program COMMAND3.
 *
 */
typedef union BCMI_TSC_XGXS_COMMAND3r_s {
	uint32_t v[1];
	uint32_t command3[1];
	uint32_t _command3;
} BCMI_TSC_XGXS_COMMAND3r_t;

#define BCMI_TSC_XGXS_COMMAND3r_CLR(r) (r).command3[0] = 0
#define BCMI_TSC_XGXS_COMMAND3r_SET(r,d) (r).command3[0] = d
#define BCMI_TSC_XGXS_COMMAND3r_GET(r) (r).command3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_COMMAND3r_GEN_STATUS_SELf_GET(r) ((((r).command3[0]) >> 12) & 0xf)
#define BCMI_TSC_XGXS_COMMAND3r_GEN_STATUS_SELf_SET(r,f) (r).command3[0]=(((r).command3[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCMI_TSC_XGXS_COMMAND3r_DISABLE_ECCf_GET(r) ((((r).command3[0]) >> 11) & 0x1)
#define BCMI_TSC_XGXS_COMMAND3r_DISABLE_ECCf_SET(r,f) (r).command3[0]=(((r).command3[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCMI_TSC_XGXS_COMMAND3r_OUT_STAGING_FLOP_BYPASSf_GET(r) ((((r).command3[0]) >> 10) & 0x1)
#define BCMI_TSC_XGXS_COMMAND3r_OUT_STAGING_FLOP_BYPASSf_SET(r,f) (r).command3[0]=(((r).command3[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCMI_TSC_XGXS_COMMAND3r_TMf_GET(r) ((((r).command3[0]) >> 5) & 0x1f)
#define BCMI_TSC_XGXS_COMMAND3r_TMf_SET(r,f) (r).command3[0]=(((r).command3[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5))
#define BCMI_TSC_XGXS_COMMAND3r_PM_OVERRIDE_VALUEf_GET(r) ((((r).command3[0]) >> 4) & 0x1)
#define BCMI_TSC_XGXS_COMMAND3r_PM_OVERRIDE_VALUEf_SET(r,f) (r).command3[0]=(((r).command3[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCMI_TSC_XGXS_COMMAND3r_ENABLE_PM_OVERRIDEf_GET(r) ((((r).command3[0]) >> 3) & 0x1)
#define BCMI_TSC_XGXS_COMMAND3r_ENABLE_PM_OVERRIDEf_SET(r,f) (r).command3[0]=(((r).command3[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCMI_TSC_XGXS_COMMAND3r_IN_STAGING_FLOP_BYPASSf_GET(r) ((((r).command3[0]) >> 2) & 0x1)
#define BCMI_TSC_XGXS_COMMAND3r_IN_STAGING_FLOP_BYPASSf_SET(r,f) (r).command3[0]=(((r).command3[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCMI_TSC_XGXS_COMMAND3r_EXT_CLK_ENABLEf_GET(r) ((((r).command3[0]) >> 1) & 0x1)
#define BCMI_TSC_XGXS_COMMAND3r_EXT_CLK_ENABLEf_SET(r,f) (r).command3[0]=(((r).command3[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCMI_TSC_XGXS_COMMAND3r_RESERVED0f_GET(r) (((r).command3[0]) & 0x1)
#define BCMI_TSC_XGXS_COMMAND3r_RESERVED0f_SET(r,f) (r).command3[0]=(((r).command3[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access COMMAND3.
 *
 */
#define BCMI_TSC_XGXS_READ_COMMAND3r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_COMMAND3r,(_r._command3))
#define BCMI_TSC_XGXS_WRITE_COMMAND3r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_COMMAND3r,(_r._command3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define COMMAND3r BCMI_TSC_XGXS_COMMAND3r
#define COMMAND3r_SIZE BCMI_TSC_XGXS_COMMAND3r_SIZE
typedef BCMI_TSC_XGXS_COMMAND3r_t COMMAND3r_t;
#define COMMAND3r_CLR BCMI_TSC_XGXS_COMMAND3r_CLR
#define COMMAND3r_SET BCMI_TSC_XGXS_COMMAND3r_SET
#define COMMAND3r_GET BCMI_TSC_XGXS_COMMAND3r_GET
#define COMMAND3r_GEN_STATUS_SELf_GET BCMI_TSC_XGXS_COMMAND3r_GEN_STATUS_SELf_GET
#define COMMAND3r_GEN_STATUS_SELf_SET BCMI_TSC_XGXS_COMMAND3r_GEN_STATUS_SELf_SET
#define COMMAND3r_DISABLE_ECCf_GET BCMI_TSC_XGXS_COMMAND3r_DISABLE_ECCf_GET
#define COMMAND3r_DISABLE_ECCf_SET BCMI_TSC_XGXS_COMMAND3r_DISABLE_ECCf_SET
#define COMMAND3r_OUT_STAGING_FLOP_BYPASSf_GET BCMI_TSC_XGXS_COMMAND3r_OUT_STAGING_FLOP_BYPASSf_GET
#define COMMAND3r_OUT_STAGING_FLOP_BYPASSf_SET BCMI_TSC_XGXS_COMMAND3r_OUT_STAGING_FLOP_BYPASSf_SET
#define COMMAND3r_TMf_GET BCMI_TSC_XGXS_COMMAND3r_TMf_GET
#define COMMAND3r_TMf_SET BCMI_TSC_XGXS_COMMAND3r_TMf_SET
#define COMMAND3r_PM_OVERRIDE_VALUEf_GET BCMI_TSC_XGXS_COMMAND3r_PM_OVERRIDE_VALUEf_GET
#define COMMAND3r_PM_OVERRIDE_VALUEf_SET BCMI_TSC_XGXS_COMMAND3r_PM_OVERRIDE_VALUEf_SET
#define COMMAND3r_ENABLE_PM_OVERRIDEf_GET BCMI_TSC_XGXS_COMMAND3r_ENABLE_PM_OVERRIDEf_GET
#define COMMAND3r_ENABLE_PM_OVERRIDEf_SET BCMI_TSC_XGXS_COMMAND3r_ENABLE_PM_OVERRIDEf_SET
#define COMMAND3r_IN_STAGING_FLOP_BYPASSf_GET BCMI_TSC_XGXS_COMMAND3r_IN_STAGING_FLOP_BYPASSf_GET
#define COMMAND3r_IN_STAGING_FLOP_BYPASSf_SET BCMI_TSC_XGXS_COMMAND3r_IN_STAGING_FLOP_BYPASSf_SET
#define COMMAND3r_EXT_CLK_ENABLEf_GET BCMI_TSC_XGXS_COMMAND3r_EXT_CLK_ENABLEf_GET
#define COMMAND3r_EXT_CLK_ENABLEf_SET BCMI_TSC_XGXS_COMMAND3r_EXT_CLK_ENABLEf_SET
#define COMMAND3r_RESERVED0f_GET BCMI_TSC_XGXS_COMMAND3r_RESERVED0f_GET
#define COMMAND3r_RESERVED0f_SET BCMI_TSC_XGXS_COMMAND3r_RESERVED0f_SET
#define READ_COMMAND3r BCMI_TSC_XGXS_READ_COMMAND3r
#define WRITE_COMMAND3r BCMI_TSC_XGXS_WRITE_COMMAND3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_COMMAND3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  TIMER_LOWER16
 * BLOCKS:   UC
 * REGADDR:  0xffcd
 * DESC:     Muxed Micro Timer (lower timer[15:0]): 00000000
 * SIZE:     32
 * FIELDS:
 *     TIMER_LOWER16BITS 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_TIMER_LOWER16r (0x0010ffcd | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_TIMER_LOWER16r_SIZE 4

/*
 * This structure should be used to declare and program TIMER_LOWER16.
 *
 */
typedef union BCMI_TSC_XGXS_TIMER_LOWER16r_s {
	uint32_t v[1];
	uint32_t timer_lower16[1];
	uint32_t _timer_lower16;
} BCMI_TSC_XGXS_TIMER_LOWER16r_t;

#define BCMI_TSC_XGXS_TIMER_LOWER16r_CLR(r) (r).timer_lower16[0] = 0
#define BCMI_TSC_XGXS_TIMER_LOWER16r_SET(r,d) (r).timer_lower16[0] = d
#define BCMI_TSC_XGXS_TIMER_LOWER16r_GET(r) (r).timer_lower16[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_TIMER_LOWER16r_TIMER_LOWER16BITSf_GET(r) (((r).timer_lower16[0]) & 0xffff)
#define BCMI_TSC_XGXS_TIMER_LOWER16r_TIMER_LOWER16BITSf_SET(r,f) (r).timer_lower16[0]=(((r).timer_lower16[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access TIMER_LOWER16.
 *
 */
#define BCMI_TSC_XGXS_READ_TIMER_LOWER16r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_TIMER_LOWER16r,(_r._timer_lower16))
#define BCMI_TSC_XGXS_WRITE_TIMER_LOWER16r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_TIMER_LOWER16r,(_r._timer_lower16))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TIMER_LOWER16r BCMI_TSC_XGXS_TIMER_LOWER16r
#define TIMER_LOWER16r_SIZE BCMI_TSC_XGXS_TIMER_LOWER16r_SIZE
typedef BCMI_TSC_XGXS_TIMER_LOWER16r_t TIMER_LOWER16r_t;
#define TIMER_LOWER16r_CLR BCMI_TSC_XGXS_TIMER_LOWER16r_CLR
#define TIMER_LOWER16r_SET BCMI_TSC_XGXS_TIMER_LOWER16r_SET
#define TIMER_LOWER16r_GET BCMI_TSC_XGXS_TIMER_LOWER16r_GET
#define TIMER_LOWER16r_TIMER_LOWER16BITSf_GET BCMI_TSC_XGXS_TIMER_LOWER16r_TIMER_LOWER16BITSf_GET
#define TIMER_LOWER16r_TIMER_LOWER16BITSf_SET BCMI_TSC_XGXS_TIMER_LOWER16r_TIMER_LOWER16BITSf_SET
#define READ_TIMER_LOWER16r BCMI_TSC_XGXS_READ_TIMER_LOWER16r
#define WRITE_TIMER_LOWER16r BCMI_TSC_XGXS_WRITE_TIMER_LOWER16r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_TIMER_LOWER16r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  TIMER_UPPER16
 * BLOCKS:   UC
 * REGADDR:  0xffce
 * DESC:     Muxed Micro Timer (upper timer[31:16]): 00000000
 * SIZE:     32
 * FIELDS:
 *     TIMER_UPPER16BITS 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_TIMER_UPPER16r (0x0010ffce | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_TIMER_UPPER16r_SIZE 4

/*
 * This structure should be used to declare and program TIMER_UPPER16.
 *
 */
typedef union BCMI_TSC_XGXS_TIMER_UPPER16r_s {
	uint32_t v[1];
	uint32_t timer_upper16[1];
	uint32_t _timer_upper16;
} BCMI_TSC_XGXS_TIMER_UPPER16r_t;

#define BCMI_TSC_XGXS_TIMER_UPPER16r_CLR(r) (r).timer_upper16[0] = 0
#define BCMI_TSC_XGXS_TIMER_UPPER16r_SET(r,d) (r).timer_upper16[0] = d
#define BCMI_TSC_XGXS_TIMER_UPPER16r_GET(r) (r).timer_upper16[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_TIMER_UPPER16r_TIMER_UPPER16BITSf_GET(r) (((r).timer_upper16[0]) & 0xffff)
#define BCMI_TSC_XGXS_TIMER_UPPER16r_TIMER_UPPER16BITSf_SET(r,f) (r).timer_upper16[0]=(((r).timer_upper16[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access TIMER_UPPER16.
 *
 */
#define BCMI_TSC_XGXS_READ_TIMER_UPPER16r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_TIMER_UPPER16r,(_r._timer_upper16))
#define BCMI_TSC_XGXS_WRITE_TIMER_UPPER16r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_TIMER_UPPER16r,(_r._timer_upper16))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TIMER_UPPER16r BCMI_TSC_XGXS_TIMER_UPPER16r
#define TIMER_UPPER16r_SIZE BCMI_TSC_XGXS_TIMER_UPPER16r_SIZE
typedef BCMI_TSC_XGXS_TIMER_UPPER16r_t TIMER_UPPER16r_t;
#define TIMER_UPPER16r_CLR BCMI_TSC_XGXS_TIMER_UPPER16r_CLR
#define TIMER_UPPER16r_SET BCMI_TSC_XGXS_TIMER_UPPER16r_SET
#define TIMER_UPPER16r_GET BCMI_TSC_XGXS_TIMER_UPPER16r_GET
#define TIMER_UPPER16r_TIMER_UPPER16BITSf_GET BCMI_TSC_XGXS_TIMER_UPPER16r_TIMER_UPPER16BITSf_GET
#define TIMER_UPPER16r_TIMER_UPPER16BITSf_SET BCMI_TSC_XGXS_TIMER_UPPER16r_TIMER_UPPER16BITSf_SET
#define READ_TIMER_UPPER16r BCMI_TSC_XGXS_READ_TIMER_UPPER16r
#define WRITE_TIMER_UPPER16r BCMI_TSC_XGXS_WRITE_TIMER_UPPER16r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_TIMER_UPPER16r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  ADDRESSEXPANSION
 * BLOCKS:   AER
 * REGADDR:  0xffde
 * DESC:     Address Expansion Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     PORT_MODE        
 *     RESERVED0        
 *     MMD_DEVICETYPE   
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_ADDRESSEXPANSIONr (0x0000ffde | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_ADDRESSEXPANSIONr_SIZE 4

/*
 * This structure should be used to declare and program ADDRESSEXPANSION.
 *
 */
typedef union BCMI_TSC_XGXS_ADDRESSEXPANSIONr_s {
	uint32_t v[1];
	uint32_t addressexpansion[1];
	uint32_t _addressexpansion;
} BCMI_TSC_XGXS_ADDRESSEXPANSIONr_t;

#define BCMI_TSC_XGXS_ADDRESSEXPANSIONr_CLR(r) (r).addressexpansion[0] = 0
#define BCMI_TSC_XGXS_ADDRESSEXPANSIONr_SET(r,d) (r).addressexpansion[0] = d
#define BCMI_TSC_XGXS_ADDRESSEXPANSIONr_GET(r) (r).addressexpansion[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_ADDRESSEXPANSIONr_MMD_DEVICETYPEf_GET(r) ((((r).addressexpansion[0]) >> 11) & 0x1f)
#define BCMI_TSC_XGXS_ADDRESSEXPANSIONr_MMD_DEVICETYPEf_SET(r,f) (r).addressexpansion[0]=(((r).addressexpansion[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))
#define BCMI_TSC_XGXS_ADDRESSEXPANSIONr_RESERVED0f_GET(r) ((((r).addressexpansion[0]) >> 3) & 0xff)
#define BCMI_TSC_XGXS_ADDRESSEXPANSIONr_RESERVED0f_SET(r,f) (r).addressexpansion[0]=(((r).addressexpansion[0] & ~((uint32_t)0xff << 3)) | ((((uint32_t)f) & 0xff) << 3))
#define BCMI_TSC_XGXS_ADDRESSEXPANSIONr_PORT_MODEf_GET(r) (((r).addressexpansion[0]) & 0x7)
#define BCMI_TSC_XGXS_ADDRESSEXPANSIONr_PORT_MODEf_SET(r,f) (r).addressexpansion[0]=(((r).addressexpansion[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))

/*
 * These macros can be used to access ADDRESSEXPANSION.
 *
 */
#define BCMI_TSC_XGXS_READ_ADDRESSEXPANSIONr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_ADDRESSEXPANSIONr,(_r._addressexpansion))
#define BCMI_TSC_XGXS_WRITE_ADDRESSEXPANSIONr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_ADDRESSEXPANSIONr,(_r._addressexpansion))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define ADDRESSEXPANSIONr BCMI_TSC_XGXS_ADDRESSEXPANSIONr
#define ADDRESSEXPANSIONr_SIZE BCMI_TSC_XGXS_ADDRESSEXPANSIONr_SIZE
typedef BCMI_TSC_XGXS_ADDRESSEXPANSIONr_t ADDRESSEXPANSIONr_t;
#define ADDRESSEXPANSIONr_CLR BCMI_TSC_XGXS_ADDRESSEXPANSIONr_CLR
#define ADDRESSEXPANSIONr_SET BCMI_TSC_XGXS_ADDRESSEXPANSIONr_SET
#define ADDRESSEXPANSIONr_GET BCMI_TSC_XGXS_ADDRESSEXPANSIONr_GET
#define ADDRESSEXPANSIONr_MMD_DEVICETYPEf_GET BCMI_TSC_XGXS_ADDRESSEXPANSIONr_MMD_DEVICETYPEf_GET
#define ADDRESSEXPANSIONr_MMD_DEVICETYPEf_SET BCMI_TSC_XGXS_ADDRESSEXPANSIONr_MMD_DEVICETYPEf_SET
#define ADDRESSEXPANSIONr_RESERVED0f_GET BCMI_TSC_XGXS_ADDRESSEXPANSIONr_RESERVED0f_GET
#define ADDRESSEXPANSIONr_RESERVED0f_SET BCMI_TSC_XGXS_ADDRESSEXPANSIONr_RESERVED0f_SET
#define ADDRESSEXPANSIONr_PORT_MODEf_GET BCMI_TSC_XGXS_ADDRESSEXPANSIONr_PORT_MODEf_GET
#define ADDRESSEXPANSIONr_PORT_MODEf_SET BCMI_TSC_XGXS_ADDRESSEXPANSIONr_PORT_MODEf_SET
#define READ_ADDRESSEXPANSIONr BCMI_TSC_XGXS_READ_ADDRESSEXPANSIONr
#define WRITE_ADDRESSEXPANSIONr BCMI_TSC_XGXS_WRITE_ADDRESSEXPANSIONr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_ADDRESSEXPANSIONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  COMBO_PHYID2
 * BLOCKS:   COMBO_IEEE
 * REGADDR:  0xffe2
 * DESC:     IEEE phyID2 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     REGID1           
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_COMBO_PHYID2r (0x0000ffe2 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_COMBO_PHYID2r_SIZE 4

/*
 * This structure should be used to declare and program COMBO_PHYID2.
 *
 */
typedef union BCMI_TSC_XGXS_COMBO_PHYID2r_s {
	uint32_t v[1];
	uint32_t combo_phyid2[1];
	uint32_t _combo_phyid2;
} BCMI_TSC_XGXS_COMBO_PHYID2r_t;

#define BCMI_TSC_XGXS_COMBO_PHYID2r_CLR(r) (r).combo_phyid2[0] = 0
#define BCMI_TSC_XGXS_COMBO_PHYID2r_SET(r,d) (r).combo_phyid2[0] = d
#define BCMI_TSC_XGXS_COMBO_PHYID2r_GET(r) (r).combo_phyid2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_COMBO_PHYID2r_REGID1f_GET(r) (((r).combo_phyid2[0]) & 0xffff)
#define BCMI_TSC_XGXS_COMBO_PHYID2r_REGID1f_SET(r,f) (r).combo_phyid2[0]=(((r).combo_phyid2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access COMBO_PHYID2.
 *
 */
#define BCMI_TSC_XGXS_READ_COMBO_PHYID2r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_COMBO_PHYID2r,(_r._combo_phyid2))
#define BCMI_TSC_XGXS_WRITE_COMBO_PHYID2r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_COMBO_PHYID2r,(_r._combo_phyid2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define COMBO_PHYID2r BCMI_TSC_XGXS_COMBO_PHYID2r
#define COMBO_PHYID2r_SIZE BCMI_TSC_XGXS_COMBO_PHYID2r_SIZE
typedef BCMI_TSC_XGXS_COMBO_PHYID2r_t COMBO_PHYID2r_t;
#define COMBO_PHYID2r_CLR BCMI_TSC_XGXS_COMBO_PHYID2r_CLR
#define COMBO_PHYID2r_SET BCMI_TSC_XGXS_COMBO_PHYID2r_SET
#define COMBO_PHYID2r_GET BCMI_TSC_XGXS_COMBO_PHYID2r_GET
#define COMBO_PHYID2r_REGID1f_GET BCMI_TSC_XGXS_COMBO_PHYID2r_REGID1f_GET
#define COMBO_PHYID2r_REGID1f_SET BCMI_TSC_XGXS_COMBO_PHYID2r_REGID1f_SET
#define READ_COMBO_PHYID2r BCMI_TSC_XGXS_READ_COMBO_PHYID2r
#define WRITE_COMBO_PHYID2r BCMI_TSC_XGXS_WRITE_COMBO_PHYID2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_COMBO_PHYID2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  COMBO_PHYID3
 * BLOCKS:   COMBO_IEEE
 * REGADDR:  0xffe3
 * DESC:     IEEE phyID3 Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     REGID2           
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_COMBO_PHYID3r (0x0000ffe3 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_COMBO_PHYID3r_SIZE 4

/*
 * This structure should be used to declare and program COMBO_PHYID3.
 *
 */
typedef union BCMI_TSC_XGXS_COMBO_PHYID3r_s {
	uint32_t v[1];
	uint32_t combo_phyid3[1];
	uint32_t _combo_phyid3;
} BCMI_TSC_XGXS_COMBO_PHYID3r_t;

#define BCMI_TSC_XGXS_COMBO_PHYID3r_CLR(r) (r).combo_phyid3[0] = 0
#define BCMI_TSC_XGXS_COMBO_PHYID3r_SET(r,d) (r).combo_phyid3[0] = d
#define BCMI_TSC_XGXS_COMBO_PHYID3r_GET(r) (r).combo_phyid3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_COMBO_PHYID3r_REGID2f_GET(r) (((r).combo_phyid3[0]) & 0xffff)
#define BCMI_TSC_XGXS_COMBO_PHYID3r_REGID2f_SET(r,f) (r).combo_phyid3[0]=(((r).combo_phyid3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access COMBO_PHYID3.
 *
 */
#define BCMI_TSC_XGXS_READ_COMBO_PHYID3r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_COMBO_PHYID3r,(_r._combo_phyid3))
#define BCMI_TSC_XGXS_WRITE_COMBO_PHYID3r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_COMBO_PHYID3r,(_r._combo_phyid3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define COMBO_PHYID3r BCMI_TSC_XGXS_COMBO_PHYID3r
#define COMBO_PHYID3r_SIZE BCMI_TSC_XGXS_COMBO_PHYID3r_SIZE
typedef BCMI_TSC_XGXS_COMBO_PHYID3r_t COMBO_PHYID3r_t;
#define COMBO_PHYID3r_CLR BCMI_TSC_XGXS_COMBO_PHYID3r_CLR
#define COMBO_PHYID3r_SET BCMI_TSC_XGXS_COMBO_PHYID3r_SET
#define COMBO_PHYID3r_GET BCMI_TSC_XGXS_COMBO_PHYID3r_GET
#define COMBO_PHYID3r_REGID2f_GET BCMI_TSC_XGXS_COMBO_PHYID3r_REGID2f_GET
#define COMBO_PHYID3r_REGID2f_SET BCMI_TSC_XGXS_COMBO_PHYID3r_REGID2f_SET
#define READ_COMBO_PHYID3r BCMI_TSC_XGXS_READ_COMBO_PHYID3r
#define WRITE_COMBO_PHYID3r BCMI_TSC_XGXS_WRITE_COMBO_PHYID3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_COMBO_PHYID3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  COMBO_MMDACCESSCONTROL
 * BLOCKS:   COMBO_IEEE
 * REGADDR:  0xffed
 * DESC:     IEEE MMD Access Control Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     DEVAD            
 *     RESERVED0        
 *     INCREMENT_CONTROL 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_COMBO_MMDACCESSCONTROLr (0x0000ffed | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_COMBO_MMDACCESSCONTROLr_SIZE 4

/*
 * This structure should be used to declare and program COMBO_MMDACCESSCONTROL.
 *
 */
typedef union BCMI_TSC_XGXS_COMBO_MMDACCESSCONTROLr_s {
	uint32_t v[1];
	uint32_t combo_mmdaccesscontrol[1];
	uint32_t _combo_mmdaccesscontrol;
} BCMI_TSC_XGXS_COMBO_MMDACCESSCONTROLr_t;

#define BCMI_TSC_XGXS_COMBO_MMDACCESSCONTROLr_CLR(r) (r).combo_mmdaccesscontrol[0] = 0
#define BCMI_TSC_XGXS_COMBO_MMDACCESSCONTROLr_SET(r,d) (r).combo_mmdaccesscontrol[0] = d
#define BCMI_TSC_XGXS_COMBO_MMDACCESSCONTROLr_GET(r) (r).combo_mmdaccesscontrol[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_COMBO_MMDACCESSCONTROLr_INCREMENT_CONTROLf_GET(r) ((((r).combo_mmdaccesscontrol[0]) >> 14) & 0x3)
#define BCMI_TSC_XGXS_COMBO_MMDACCESSCONTROLr_INCREMENT_CONTROLf_SET(r,f) (r).combo_mmdaccesscontrol[0]=(((r).combo_mmdaccesscontrol[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCMI_TSC_XGXS_COMBO_MMDACCESSCONTROLr_RESERVED0f_GET(r) ((((r).combo_mmdaccesscontrol[0]) >> 5) & 0x1ff)
#define BCMI_TSC_XGXS_COMBO_MMDACCESSCONTROLr_RESERVED0f_SET(r,f) (r).combo_mmdaccesscontrol[0]=(((r).combo_mmdaccesscontrol[0] & ~((uint32_t)0x1ff << 5)) | ((((uint32_t)f) & 0x1ff) << 5))
#define BCMI_TSC_XGXS_COMBO_MMDACCESSCONTROLr_DEVADf_GET(r) (((r).combo_mmdaccesscontrol[0]) & 0x1f)
#define BCMI_TSC_XGXS_COMBO_MMDACCESSCONTROLr_DEVADf_SET(r,f) (r).combo_mmdaccesscontrol[0]=(((r).combo_mmdaccesscontrol[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))

/*
 * These macros can be used to access COMBO_MMDACCESSCONTROL.
 *
 */
#define BCMI_TSC_XGXS_READ_COMBO_MMDACCESSCONTROLr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_COMBO_MMDACCESSCONTROLr,(_r._combo_mmdaccesscontrol))
#define BCMI_TSC_XGXS_WRITE_COMBO_MMDACCESSCONTROLr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_COMBO_MMDACCESSCONTROLr,(_r._combo_mmdaccesscontrol))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define COMBO_MMDACCESSCONTROLr BCMI_TSC_XGXS_COMBO_MMDACCESSCONTROLr
#define COMBO_MMDACCESSCONTROLr_SIZE BCMI_TSC_XGXS_COMBO_MMDACCESSCONTROLr_SIZE
typedef BCMI_TSC_XGXS_COMBO_MMDACCESSCONTROLr_t COMBO_MMDACCESSCONTROLr_t;
#define COMBO_MMDACCESSCONTROLr_CLR BCMI_TSC_XGXS_COMBO_MMDACCESSCONTROLr_CLR
#define COMBO_MMDACCESSCONTROLr_SET BCMI_TSC_XGXS_COMBO_MMDACCESSCONTROLr_SET
#define COMBO_MMDACCESSCONTROLr_GET BCMI_TSC_XGXS_COMBO_MMDACCESSCONTROLr_GET
#define COMBO_MMDACCESSCONTROLr_INCREMENT_CONTROLf_GET BCMI_TSC_XGXS_COMBO_MMDACCESSCONTROLr_INCREMENT_CONTROLf_GET
#define COMBO_MMDACCESSCONTROLr_INCREMENT_CONTROLf_SET BCMI_TSC_XGXS_COMBO_MMDACCESSCONTROLr_INCREMENT_CONTROLf_SET
#define COMBO_MMDACCESSCONTROLr_RESERVED0f_GET BCMI_TSC_XGXS_COMBO_MMDACCESSCONTROLr_RESERVED0f_GET
#define COMBO_MMDACCESSCONTROLr_RESERVED0f_SET BCMI_TSC_XGXS_COMBO_MMDACCESSCONTROLr_RESERVED0f_SET
#define COMBO_MMDACCESSCONTROLr_DEVADf_GET BCMI_TSC_XGXS_COMBO_MMDACCESSCONTROLr_DEVADf_GET
#define COMBO_MMDACCESSCONTROLr_DEVADf_SET BCMI_TSC_XGXS_COMBO_MMDACCESSCONTROLr_DEVADf_SET
#define READ_COMBO_MMDACCESSCONTROLr BCMI_TSC_XGXS_READ_COMBO_MMDACCESSCONTROLr
#define WRITE_COMBO_MMDACCESSCONTROLr BCMI_TSC_XGXS_WRITE_COMBO_MMDACCESSCONTROLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_COMBO_MMDACCESSCONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  COMBO_MMDACCESSADDRESSDATA
 * BLOCKS:   COMBO_IEEE
 * REGADDR:  0xffee
 * DESC:     IEEE MMD Address Data Register: 00000000
 * SIZE:     32
 * FIELDS:
 *     ADDRESSDATA      
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_COMBO_MMDACCESSADDRESSDATAr (0x0000ffee | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_COMBO_MMDACCESSADDRESSDATAr_SIZE 4

/*
 * This structure should be used to declare and program COMBO_MMDACCESSADDRESSDATA.
 *
 */
typedef union BCMI_TSC_XGXS_COMBO_MMDACCESSADDRESSDATAr_s {
	uint32_t v[1];
	uint32_t combo_mmdaccessaddressdata[1];
	uint32_t _combo_mmdaccessaddressdata;
} BCMI_TSC_XGXS_COMBO_MMDACCESSADDRESSDATAr_t;

#define BCMI_TSC_XGXS_COMBO_MMDACCESSADDRESSDATAr_CLR(r) (r).combo_mmdaccessaddressdata[0] = 0
#define BCMI_TSC_XGXS_COMBO_MMDACCESSADDRESSDATAr_SET(r,d) (r).combo_mmdaccessaddressdata[0] = d
#define BCMI_TSC_XGXS_COMBO_MMDACCESSADDRESSDATAr_GET(r) (r).combo_mmdaccessaddressdata[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_COMBO_MMDACCESSADDRESSDATAr_ADDRESSDATAf_GET(r) (((r).combo_mmdaccessaddressdata[0]) & 0xffff)
#define BCMI_TSC_XGXS_COMBO_MMDACCESSADDRESSDATAr_ADDRESSDATAf_SET(r,f) (r).combo_mmdaccessaddressdata[0]=(((r).combo_mmdaccessaddressdata[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access COMBO_MMDACCESSADDRESSDATA.
 *
 */
#define BCMI_TSC_XGXS_READ_COMBO_MMDACCESSADDRESSDATAr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_COMBO_MMDACCESSADDRESSDATAr,(_r._combo_mmdaccessaddressdata))
#define BCMI_TSC_XGXS_WRITE_COMBO_MMDACCESSADDRESSDATAr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_COMBO_MMDACCESSADDRESSDATAr,(_r._combo_mmdaccessaddressdata))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define COMBO_MMDACCESSADDRESSDATAr BCMI_TSC_XGXS_COMBO_MMDACCESSADDRESSDATAr
#define COMBO_MMDACCESSADDRESSDATAr_SIZE BCMI_TSC_XGXS_COMBO_MMDACCESSADDRESSDATAr_SIZE
typedef BCMI_TSC_XGXS_COMBO_MMDACCESSADDRESSDATAr_t COMBO_MMDACCESSADDRESSDATAr_t;
#define COMBO_MMDACCESSADDRESSDATAr_CLR BCMI_TSC_XGXS_COMBO_MMDACCESSADDRESSDATAr_CLR
#define COMBO_MMDACCESSADDRESSDATAr_SET BCMI_TSC_XGXS_COMBO_MMDACCESSADDRESSDATAr_SET
#define COMBO_MMDACCESSADDRESSDATAr_GET BCMI_TSC_XGXS_COMBO_MMDACCESSADDRESSDATAr_GET
#define COMBO_MMDACCESSADDRESSDATAr_ADDRESSDATAf_GET BCMI_TSC_XGXS_COMBO_MMDACCESSADDRESSDATAr_ADDRESSDATAf_GET
#define COMBO_MMDACCESSADDRESSDATAr_ADDRESSDATAf_SET BCMI_TSC_XGXS_COMBO_MMDACCESSADDRESSDATAr_ADDRESSDATAf_SET
#define READ_COMBO_MMDACCESSADDRESSDATAr BCMI_TSC_XGXS_READ_COMBO_MMDACCESSADDRESSDATAr
#define WRITE_COMBO_MMDACCESSADDRESSDATAr BCMI_TSC_XGXS_WRITE_COMBO_MMDACCESSADDRESSDATAr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_COMBO_MMDACCESSADDRESSDATAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  AN_IEEEID1
 * BLOCKS:   DEV1_IEEE0
 * REGADDR:  0x0002
 * DEVAD:    1
 * DESC:     AN Device ID [15:0]: 00000000
 * SIZE:     32
 * FIELDS:
 *     IEEEID1          
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_AN_IEEEID1r (0x00010002 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_AN_IEEEID1r_SIZE 4

/*
 * This structure should be used to declare and program AN_IEEEID1.
 *
 */
typedef union BCMI_TSC_XGXS_AN_IEEEID1r_s {
	uint32_t v[1];
	uint32_t an_ieeeid1[1];
	uint32_t _an_ieeeid1;
} BCMI_TSC_XGXS_AN_IEEEID1r_t;

#define BCMI_TSC_XGXS_AN_IEEEID1r_CLR(r) (r).an_ieeeid1[0] = 0
#define BCMI_TSC_XGXS_AN_IEEEID1r_SET(r,d) (r).an_ieeeid1[0] = d
#define BCMI_TSC_XGXS_AN_IEEEID1r_GET(r) (r).an_ieeeid1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_AN_IEEEID1r_IEEEID1f_GET(r) (((r).an_ieeeid1[0]) & 0xffff)
#define BCMI_TSC_XGXS_AN_IEEEID1r_IEEEID1f_SET(r,f) (r).an_ieeeid1[0]=(((r).an_ieeeid1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access AN_IEEEID1.
 *
 */
#define BCMI_TSC_XGXS_READ_AN_IEEEID1r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_AN_IEEEID1r,(_r._an_ieeeid1))
#define BCMI_TSC_XGXS_WRITE_AN_IEEEID1r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_AN_IEEEID1r,(_r._an_ieeeid1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_IEEEID1r BCMI_TSC_XGXS_AN_IEEEID1r
#define AN_IEEEID1r_SIZE BCMI_TSC_XGXS_AN_IEEEID1r_SIZE
typedef BCMI_TSC_XGXS_AN_IEEEID1r_t AN_IEEEID1r_t;
#define AN_IEEEID1r_CLR BCMI_TSC_XGXS_AN_IEEEID1r_CLR
#define AN_IEEEID1r_SET BCMI_TSC_XGXS_AN_IEEEID1r_SET
#define AN_IEEEID1r_GET BCMI_TSC_XGXS_AN_IEEEID1r_GET
#define AN_IEEEID1r_IEEEID1f_GET BCMI_TSC_XGXS_AN_IEEEID1r_IEEEID1f_GET
#define AN_IEEEID1r_IEEEID1f_SET BCMI_TSC_XGXS_AN_IEEEID1r_IEEEID1f_SET
#define READ_AN_IEEEID1r BCMI_TSC_XGXS_READ_AN_IEEEID1r
#define WRITE_AN_IEEEID1r BCMI_TSC_XGXS_WRITE_AN_IEEEID1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_AN_IEEEID1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  AN_IEEEID2
 * BLOCKS:   DEV1_IEEE0
 * REGADDR:  0x0003
 * DEVAD:    1
 * DESC:     AN Device ID [31:16]: 00000000
 * SIZE:     32
 * FIELDS:
 *     IEEEID2          
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_AN_IEEEID2r (0x00010003 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_AN_IEEEID2r_SIZE 4

/*
 * This structure should be used to declare and program AN_IEEEID2.
 *
 */
typedef union BCMI_TSC_XGXS_AN_IEEEID2r_s {
	uint32_t v[1];
	uint32_t an_ieeeid2[1];
	uint32_t _an_ieeeid2;
} BCMI_TSC_XGXS_AN_IEEEID2r_t;

#define BCMI_TSC_XGXS_AN_IEEEID2r_CLR(r) (r).an_ieeeid2[0] = 0
#define BCMI_TSC_XGXS_AN_IEEEID2r_SET(r,d) (r).an_ieeeid2[0] = d
#define BCMI_TSC_XGXS_AN_IEEEID2r_GET(r) (r).an_ieeeid2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_AN_IEEEID2r_IEEEID2f_GET(r) (((r).an_ieeeid2[0]) & 0xffff)
#define BCMI_TSC_XGXS_AN_IEEEID2r_IEEEID2f_SET(r,f) (r).an_ieeeid2[0]=(((r).an_ieeeid2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access AN_IEEEID2.
 *
 */
#define BCMI_TSC_XGXS_READ_AN_IEEEID2r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_AN_IEEEID2r,(_r._an_ieeeid2))
#define BCMI_TSC_XGXS_WRITE_AN_IEEEID2r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_AN_IEEEID2r,(_r._an_ieeeid2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_IEEEID2r BCMI_TSC_XGXS_AN_IEEEID2r
#define AN_IEEEID2r_SIZE BCMI_TSC_XGXS_AN_IEEEID2r_SIZE
typedef BCMI_TSC_XGXS_AN_IEEEID2r_t AN_IEEEID2r_t;
#define AN_IEEEID2r_CLR BCMI_TSC_XGXS_AN_IEEEID2r_CLR
#define AN_IEEEID2r_SET BCMI_TSC_XGXS_AN_IEEEID2r_SET
#define AN_IEEEID2r_GET BCMI_TSC_XGXS_AN_IEEEID2r_GET
#define AN_IEEEID2r_IEEEID2f_GET BCMI_TSC_XGXS_AN_IEEEID2r_IEEEID2f_GET
#define AN_IEEEID2r_IEEEID2f_SET BCMI_TSC_XGXS_AN_IEEEID2r_IEEEID2f_SET
#define READ_AN_IEEEID2r BCMI_TSC_XGXS_READ_AN_IEEEID2r
#define WRITE_AN_IEEEID2r BCMI_TSC_XGXS_WRITE_AN_IEEEID2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_AN_IEEEID2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  PMD_10GBASE_KR_PMD_CONTROL_150
 * BLOCKS:   DEV1_IEEE9
 * REGADDR:  0x0096
 * DEVAD:    1
 * DESC:     TenGBASE_KR PMD control register 150: 00000000
 * SIZE:     32
 * FIELDS:
 *     RESTART_TRAINING 
 *     TRAINING_ENABLE  
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_PMD_10GBASE_KR_PMD_CONTROL_150r (0x00010096 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_PMD_10GBASE_KR_PMD_CONTROL_150r_SIZE 4

/*
 * This structure should be used to declare and program PMD_10GBASE_KR_PMD_CONTROL_150.
 *
 */
typedef union BCMI_TSC_XGXS_PMD_10GBASE_KR_PMD_CONTROL_150r_s {
	uint32_t v[1];
	uint32_t pmd_10gbase_kr_pmd_control_150[1];
	uint32_t _pmd_10gbase_kr_pmd_control_150;
} BCMI_TSC_XGXS_PMD_10GBASE_KR_PMD_CONTROL_150r_t;

#define BCMI_TSC_XGXS_PMD_10GBASE_KR_PMD_CONTROL_150r_CLR(r) (r).pmd_10gbase_kr_pmd_control_150[0] = 0
#define BCMI_TSC_XGXS_PMD_10GBASE_KR_PMD_CONTROL_150r_SET(r,d) (r).pmd_10gbase_kr_pmd_control_150[0] = d
#define BCMI_TSC_XGXS_PMD_10GBASE_KR_PMD_CONTROL_150r_GET(r) (r).pmd_10gbase_kr_pmd_control_150[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_PMD_10GBASE_KR_PMD_CONTROL_150r_RESERVED0f_GET(r) ((((r).pmd_10gbase_kr_pmd_control_150[0]) >> 2) & 0x3fff)
#define BCMI_TSC_XGXS_PMD_10GBASE_KR_PMD_CONTROL_150r_RESERVED0f_SET(r,f) (r).pmd_10gbase_kr_pmd_control_150[0]=(((r).pmd_10gbase_kr_pmd_control_150[0] & ~((uint32_t)0x3fff << 2)) | ((((uint32_t)f) & 0x3fff) << 2))
#define BCMI_TSC_XGXS_PMD_10GBASE_KR_PMD_CONTROL_150r_TRAINING_ENABLEf_GET(r) ((((r).pmd_10gbase_kr_pmd_control_150[0]) >> 1) & 0x1)
#define BCMI_TSC_XGXS_PMD_10GBASE_KR_PMD_CONTROL_150r_TRAINING_ENABLEf_SET(r,f) (r).pmd_10gbase_kr_pmd_control_150[0]=(((r).pmd_10gbase_kr_pmd_control_150[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCMI_TSC_XGXS_PMD_10GBASE_KR_PMD_CONTROL_150r_RESTART_TRAININGf_GET(r) (((r).pmd_10gbase_kr_pmd_control_150[0]) & 0x1)
#define BCMI_TSC_XGXS_PMD_10GBASE_KR_PMD_CONTROL_150r_RESTART_TRAININGf_SET(r,f) (r).pmd_10gbase_kr_pmd_control_150[0]=(((r).pmd_10gbase_kr_pmd_control_150[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access PMD_10GBASE_KR_PMD_CONTROL_150.
 *
 */
#define BCMI_TSC_XGXS_READ_PMD_10GBASE_KR_PMD_CONTROL_150r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_PMD_10GBASE_KR_PMD_CONTROL_150r,(_r._pmd_10gbase_kr_pmd_control_150))
#define BCMI_TSC_XGXS_WRITE_PMD_10GBASE_KR_PMD_CONTROL_150r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_PMD_10GBASE_KR_PMD_CONTROL_150r,(_r._pmd_10gbase_kr_pmd_control_150))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PMD_10GBASE_KR_PMD_CONTROL_150r BCMI_TSC_XGXS_PMD_10GBASE_KR_PMD_CONTROL_150r
#define PMD_10GBASE_KR_PMD_CONTROL_150r_SIZE BCMI_TSC_XGXS_PMD_10GBASE_KR_PMD_CONTROL_150r_SIZE
typedef BCMI_TSC_XGXS_PMD_10GBASE_KR_PMD_CONTROL_150r_t PMD_10GBASE_KR_PMD_CONTROL_150r_t;
#define PMD_10GBASE_KR_PMD_CONTROL_150r_CLR BCMI_TSC_XGXS_PMD_10GBASE_KR_PMD_CONTROL_150r_CLR
#define PMD_10GBASE_KR_PMD_CONTROL_150r_SET BCMI_TSC_XGXS_PMD_10GBASE_KR_PMD_CONTROL_150r_SET
#define PMD_10GBASE_KR_PMD_CONTROL_150r_GET BCMI_TSC_XGXS_PMD_10GBASE_KR_PMD_CONTROL_150r_GET
#define PMD_10GBASE_KR_PMD_CONTROL_150r_RESERVED0f_GET BCMI_TSC_XGXS_PMD_10GBASE_KR_PMD_CONTROL_150r_RESERVED0f_GET
#define PMD_10GBASE_KR_PMD_CONTROL_150r_RESERVED0f_SET BCMI_TSC_XGXS_PMD_10GBASE_KR_PMD_CONTROL_150r_RESERVED0f_SET
#define PMD_10GBASE_KR_PMD_CONTROL_150r_TRAINING_ENABLEf_GET BCMI_TSC_XGXS_PMD_10GBASE_KR_PMD_CONTROL_150r_TRAINING_ENABLEf_GET
#define PMD_10GBASE_KR_PMD_CONTROL_150r_TRAINING_ENABLEf_SET BCMI_TSC_XGXS_PMD_10GBASE_KR_PMD_CONTROL_150r_TRAINING_ENABLEf_SET
#define PMD_10GBASE_KR_PMD_CONTROL_150r_RESTART_TRAININGf_GET BCMI_TSC_XGXS_PMD_10GBASE_KR_PMD_CONTROL_150r_RESTART_TRAININGf_GET
#define PMD_10GBASE_KR_PMD_CONTROL_150r_RESTART_TRAININGf_SET BCMI_TSC_XGXS_PMD_10GBASE_KR_PMD_CONTROL_150r_RESTART_TRAININGf_SET
#define READ_PMD_10GBASE_KR_PMD_CONTROL_150r BCMI_TSC_XGXS_READ_PMD_10GBASE_KR_PMD_CONTROL_150r
#define WRITE_PMD_10GBASE_KR_PMD_CONTROL_150r BCMI_TSC_XGXS_WRITE_PMD_10GBASE_KR_PMD_CONTROL_150r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_PMD_10GBASE_KR_PMD_CONTROL_150r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  PMD_10GBASE_KR_PMD_STATUS_151
 * BLOCKS:   DEV1_IEEE9
 * REGADDR:  0x0097
 * DEVAD:    1
 * DESC:     TenGBASE_KR PMD status register 151: 00000000
 * SIZE:     32
 * FIELDS:
 *     RECEIVER_STATUS  
 *     FRAME_LOCK       
 *     TRAINING_STATUS  
 *     TRAINING_FAILURE 
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_PMD_10GBASE_KR_PMD_STATUS_151r (0x00010097 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_PMD_10GBASE_KR_PMD_STATUS_151r_SIZE 4

/*
 * This structure should be used to declare and program PMD_10GBASE_KR_PMD_STATUS_151.
 *
 */
typedef union BCMI_TSC_XGXS_PMD_10GBASE_KR_PMD_STATUS_151r_s {
	uint32_t v[1];
	uint32_t pmd_10gbase_kr_pmd_status_151[1];
	uint32_t _pmd_10gbase_kr_pmd_status_151;
} BCMI_TSC_XGXS_PMD_10GBASE_KR_PMD_STATUS_151r_t;

#define BCMI_TSC_XGXS_PMD_10GBASE_KR_PMD_STATUS_151r_CLR(r) (r).pmd_10gbase_kr_pmd_status_151[0] = 0
#define BCMI_TSC_XGXS_PMD_10GBASE_KR_PMD_STATUS_151r_SET(r,d) (r).pmd_10gbase_kr_pmd_status_151[0] = d
#define BCMI_TSC_XGXS_PMD_10GBASE_KR_PMD_STATUS_151r_GET(r) (r).pmd_10gbase_kr_pmd_status_151[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_PMD_10GBASE_KR_PMD_STATUS_151r_RESERVED0f_GET(r) ((((r).pmd_10gbase_kr_pmd_status_151[0]) >> 4) & 0xfff)
#define BCMI_TSC_XGXS_PMD_10GBASE_KR_PMD_STATUS_151r_RESERVED0f_SET(r,f) (r).pmd_10gbase_kr_pmd_status_151[0]=(((r).pmd_10gbase_kr_pmd_status_151[0] & ~((uint32_t)0xfff << 4)) | ((((uint32_t)f) & 0xfff) << 4))
#define BCMI_TSC_XGXS_PMD_10GBASE_KR_PMD_STATUS_151r_TRAINING_FAILUREf_GET(r) ((((r).pmd_10gbase_kr_pmd_status_151[0]) >> 3) & 0x1)
#define BCMI_TSC_XGXS_PMD_10GBASE_KR_PMD_STATUS_151r_TRAINING_FAILUREf_SET(r,f) (r).pmd_10gbase_kr_pmd_status_151[0]=(((r).pmd_10gbase_kr_pmd_status_151[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCMI_TSC_XGXS_PMD_10GBASE_KR_PMD_STATUS_151r_TRAINING_STATUSf_GET(r) ((((r).pmd_10gbase_kr_pmd_status_151[0]) >> 2) & 0x1)
#define BCMI_TSC_XGXS_PMD_10GBASE_KR_PMD_STATUS_151r_TRAINING_STATUSf_SET(r,f) (r).pmd_10gbase_kr_pmd_status_151[0]=(((r).pmd_10gbase_kr_pmd_status_151[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCMI_TSC_XGXS_PMD_10GBASE_KR_PMD_STATUS_151r_FRAME_LOCKf_GET(r) ((((r).pmd_10gbase_kr_pmd_status_151[0]) >> 1) & 0x1)
#define BCMI_TSC_XGXS_PMD_10GBASE_KR_PMD_STATUS_151r_FRAME_LOCKf_SET(r,f) (r).pmd_10gbase_kr_pmd_status_151[0]=(((r).pmd_10gbase_kr_pmd_status_151[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCMI_TSC_XGXS_PMD_10GBASE_KR_PMD_STATUS_151r_RECEIVER_STATUSf_GET(r) (((r).pmd_10gbase_kr_pmd_status_151[0]) & 0x1)
#define BCMI_TSC_XGXS_PMD_10GBASE_KR_PMD_STATUS_151r_RECEIVER_STATUSf_SET(r,f) (r).pmd_10gbase_kr_pmd_status_151[0]=(((r).pmd_10gbase_kr_pmd_status_151[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access PMD_10GBASE_KR_PMD_STATUS_151.
 *
 */
#define BCMI_TSC_XGXS_READ_PMD_10GBASE_KR_PMD_STATUS_151r(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_PMD_10GBASE_KR_PMD_STATUS_151r,(_r._pmd_10gbase_kr_pmd_status_151))
#define BCMI_TSC_XGXS_WRITE_PMD_10GBASE_KR_PMD_STATUS_151r(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_PMD_10GBASE_KR_PMD_STATUS_151r,(_r._pmd_10gbase_kr_pmd_status_151))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PMD_10GBASE_KR_PMD_STATUS_151r BCMI_TSC_XGXS_PMD_10GBASE_KR_PMD_STATUS_151r
#define PMD_10GBASE_KR_PMD_STATUS_151r_SIZE BCMI_TSC_XGXS_PMD_10GBASE_KR_PMD_STATUS_151r_SIZE
typedef BCMI_TSC_XGXS_PMD_10GBASE_KR_PMD_STATUS_151r_t PMD_10GBASE_KR_PMD_STATUS_151r_t;
#define PMD_10GBASE_KR_PMD_STATUS_151r_CLR BCMI_TSC_XGXS_PMD_10GBASE_KR_PMD_STATUS_151r_CLR
#define PMD_10GBASE_KR_PMD_STATUS_151r_SET BCMI_TSC_XGXS_PMD_10GBASE_KR_PMD_STATUS_151r_SET
#define PMD_10GBASE_KR_PMD_STATUS_151r_GET BCMI_TSC_XGXS_PMD_10GBASE_KR_PMD_STATUS_151r_GET
#define PMD_10GBASE_KR_PMD_STATUS_151r_RESERVED0f_GET BCMI_TSC_XGXS_PMD_10GBASE_KR_PMD_STATUS_151r_RESERVED0f_GET
#define PMD_10GBASE_KR_PMD_STATUS_151r_RESERVED0f_SET BCMI_TSC_XGXS_PMD_10GBASE_KR_PMD_STATUS_151r_RESERVED0f_SET
#define PMD_10GBASE_KR_PMD_STATUS_151r_TRAINING_FAILUREf_GET BCMI_TSC_XGXS_PMD_10GBASE_KR_PMD_STATUS_151r_TRAINING_FAILUREf_GET
#define PMD_10GBASE_KR_PMD_STATUS_151r_TRAINING_FAILUREf_SET BCMI_TSC_XGXS_PMD_10GBASE_KR_PMD_STATUS_151r_TRAINING_FAILUREf_SET
#define PMD_10GBASE_KR_PMD_STATUS_151r_TRAINING_STATUSf_GET BCMI_TSC_XGXS_PMD_10GBASE_KR_PMD_STATUS_151r_TRAINING_STATUSf_GET
#define PMD_10GBASE_KR_PMD_STATUS_151r_TRAINING_STATUSf_SET BCMI_TSC_XGXS_PMD_10GBASE_KR_PMD_STATUS_151r_TRAINING_STATUSf_SET
#define PMD_10GBASE_KR_PMD_STATUS_151r_FRAME_LOCKf_GET BCMI_TSC_XGXS_PMD_10GBASE_KR_PMD_STATUS_151r_FRAME_LOCKf_GET
#define PMD_10GBASE_KR_PMD_STATUS_151r_FRAME_LOCKf_SET BCMI_TSC_XGXS_PMD_10GBASE_KR_PMD_STATUS_151r_FRAME_LOCKf_SET
#define PMD_10GBASE_KR_PMD_STATUS_151r_RECEIVER_STATUSf_GET BCMI_TSC_XGXS_PMD_10GBASE_KR_PMD_STATUS_151r_RECEIVER_STATUSf_GET
#define PMD_10GBASE_KR_PMD_STATUS_151r_RECEIVER_STATUSf_SET BCMI_TSC_XGXS_PMD_10GBASE_KR_PMD_STATUS_151r_RECEIVER_STATUSf_SET
#define READ_PMD_10GBASE_KR_PMD_STATUS_151r BCMI_TSC_XGXS_READ_PMD_10GBASE_KR_PMD_STATUS_151r
#define WRITE_PMD_10GBASE_KR_PMD_STATUS_151r BCMI_TSC_XGXS_WRITE_PMD_10GBASE_KR_PMD_STATUS_151r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_PMD_10GBASE_KR_PMD_STATUS_151r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  PMD_CORRECTEDBLKSL
 * BLOCKS:   DEV1_IEEE10
 * REGADDR:  0x00ac
 * DEVAD:    1
 * DESC:     "FEC corrected blocks counter [15:0]": 00000000
 * SIZE:     32
 * FIELDS:
 *     CORCOUNTL        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_PMD_CORRECTEDBLKSLr (0x000100ac | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_PMD_CORRECTEDBLKSLr_SIZE 4

/*
 * This structure should be used to declare and program PMD_CORRECTEDBLKSL.
 *
 */
typedef union BCMI_TSC_XGXS_PMD_CORRECTEDBLKSLr_s {
	uint32_t v[1];
	uint32_t pmd_correctedblksl[1];
	uint32_t _pmd_correctedblksl;
} BCMI_TSC_XGXS_PMD_CORRECTEDBLKSLr_t;

#define BCMI_TSC_XGXS_PMD_CORRECTEDBLKSLr_CLR(r) (r).pmd_correctedblksl[0] = 0
#define BCMI_TSC_XGXS_PMD_CORRECTEDBLKSLr_SET(r,d) (r).pmd_correctedblksl[0] = d
#define BCMI_TSC_XGXS_PMD_CORRECTEDBLKSLr_GET(r) (r).pmd_correctedblksl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_PMD_CORRECTEDBLKSLr_CORCOUNTLf_GET(r) (((r).pmd_correctedblksl[0]) & 0xffff)
#define BCMI_TSC_XGXS_PMD_CORRECTEDBLKSLr_CORCOUNTLf_SET(r,f) (r).pmd_correctedblksl[0]=(((r).pmd_correctedblksl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PMD_CORRECTEDBLKSL.
 *
 */
#define BCMI_TSC_XGXS_READ_PMD_CORRECTEDBLKSLr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_PMD_CORRECTEDBLKSLr,(_r._pmd_correctedblksl))
#define BCMI_TSC_XGXS_WRITE_PMD_CORRECTEDBLKSLr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_PMD_CORRECTEDBLKSLr,(_r._pmd_correctedblksl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PMD_CORRECTEDBLKSLr BCMI_TSC_XGXS_PMD_CORRECTEDBLKSLr
#define PMD_CORRECTEDBLKSLr_SIZE BCMI_TSC_XGXS_PMD_CORRECTEDBLKSLr_SIZE
typedef BCMI_TSC_XGXS_PMD_CORRECTEDBLKSLr_t PMD_CORRECTEDBLKSLr_t;
#define PMD_CORRECTEDBLKSLr_CLR BCMI_TSC_XGXS_PMD_CORRECTEDBLKSLr_CLR
#define PMD_CORRECTEDBLKSLr_SET BCMI_TSC_XGXS_PMD_CORRECTEDBLKSLr_SET
#define PMD_CORRECTEDBLKSLr_GET BCMI_TSC_XGXS_PMD_CORRECTEDBLKSLr_GET
#define PMD_CORRECTEDBLKSLr_CORCOUNTLf_GET BCMI_TSC_XGXS_PMD_CORRECTEDBLKSLr_CORCOUNTLf_GET
#define PMD_CORRECTEDBLKSLr_CORCOUNTLf_SET BCMI_TSC_XGXS_PMD_CORRECTEDBLKSLr_CORCOUNTLf_SET
#define READ_PMD_CORRECTEDBLKSLr BCMI_TSC_XGXS_READ_PMD_CORRECTEDBLKSLr
#define WRITE_PMD_CORRECTEDBLKSLr BCMI_TSC_XGXS_WRITE_PMD_CORRECTEDBLKSLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_PMD_CORRECTEDBLKSLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  PMD_CORRECTEDBLKSH
 * BLOCKS:   DEV1_IEEE10
 * REGADDR:  0x00ad
 * DEVAD:    1
 * DESC:     "FEC corrected blocks counter [31:16]": 00000000
 * SIZE:     32
 * FIELDS:
 *     CORCOUNTH        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_PMD_CORRECTEDBLKSHr (0x000100ad | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_PMD_CORRECTEDBLKSHr_SIZE 4

/*
 * This structure should be used to declare and program PMD_CORRECTEDBLKSH.
 *
 */
typedef union BCMI_TSC_XGXS_PMD_CORRECTEDBLKSHr_s {
	uint32_t v[1];
	uint32_t pmd_correctedblksh[1];
	uint32_t _pmd_correctedblksh;
} BCMI_TSC_XGXS_PMD_CORRECTEDBLKSHr_t;

#define BCMI_TSC_XGXS_PMD_CORRECTEDBLKSHr_CLR(r) (r).pmd_correctedblksh[0] = 0
#define BCMI_TSC_XGXS_PMD_CORRECTEDBLKSHr_SET(r,d) (r).pmd_correctedblksh[0] = d
#define BCMI_TSC_XGXS_PMD_CORRECTEDBLKSHr_GET(r) (r).pmd_correctedblksh[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_PMD_CORRECTEDBLKSHr_CORCOUNTHf_GET(r) (((r).pmd_correctedblksh[0]) & 0xffff)
#define BCMI_TSC_XGXS_PMD_CORRECTEDBLKSHr_CORCOUNTHf_SET(r,f) (r).pmd_correctedblksh[0]=(((r).pmd_correctedblksh[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PMD_CORRECTEDBLKSH.
 *
 */
#define BCMI_TSC_XGXS_READ_PMD_CORRECTEDBLKSHr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_PMD_CORRECTEDBLKSHr,(_r._pmd_correctedblksh))
#define BCMI_TSC_XGXS_WRITE_PMD_CORRECTEDBLKSHr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_PMD_CORRECTEDBLKSHr,(_r._pmd_correctedblksh))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PMD_CORRECTEDBLKSHr BCMI_TSC_XGXS_PMD_CORRECTEDBLKSHr
#define PMD_CORRECTEDBLKSHr_SIZE BCMI_TSC_XGXS_PMD_CORRECTEDBLKSHr_SIZE
typedef BCMI_TSC_XGXS_PMD_CORRECTEDBLKSHr_t PMD_CORRECTEDBLKSHr_t;
#define PMD_CORRECTEDBLKSHr_CLR BCMI_TSC_XGXS_PMD_CORRECTEDBLKSHr_CLR
#define PMD_CORRECTEDBLKSHr_SET BCMI_TSC_XGXS_PMD_CORRECTEDBLKSHr_SET
#define PMD_CORRECTEDBLKSHr_GET BCMI_TSC_XGXS_PMD_CORRECTEDBLKSHr_GET
#define PMD_CORRECTEDBLKSHr_CORCOUNTHf_GET BCMI_TSC_XGXS_PMD_CORRECTEDBLKSHr_CORCOUNTHf_GET
#define PMD_CORRECTEDBLKSHr_CORCOUNTHf_SET BCMI_TSC_XGXS_PMD_CORRECTEDBLKSHr_CORCOUNTHf_SET
#define READ_PMD_CORRECTEDBLKSHr BCMI_TSC_XGXS_READ_PMD_CORRECTEDBLKSHr
#define WRITE_PMD_CORRECTEDBLKSHr BCMI_TSC_XGXS_WRITE_PMD_CORRECTEDBLKSHr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_PMD_CORRECTEDBLKSHr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  PMD_UNCORRECTEDBLKSL
 * BLOCKS:   DEV1_IEEE10
 * REGADDR:  0x00ae
 * DEVAD:    1
 * DESC:     "FEC uncorrected blocks counter [15:0]": 00000000
 * SIZE:     32
 * FIELDS:
 *     UNCORCOUNTL      
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_PMD_UNCORRECTEDBLKSLr (0x000100ae | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_PMD_UNCORRECTEDBLKSLr_SIZE 4

/*
 * This structure should be used to declare and program PMD_UNCORRECTEDBLKSL.
 *
 */
typedef union BCMI_TSC_XGXS_PMD_UNCORRECTEDBLKSLr_s {
	uint32_t v[1];
	uint32_t pmd_uncorrectedblksl[1];
	uint32_t _pmd_uncorrectedblksl;
} BCMI_TSC_XGXS_PMD_UNCORRECTEDBLKSLr_t;

#define BCMI_TSC_XGXS_PMD_UNCORRECTEDBLKSLr_CLR(r) (r).pmd_uncorrectedblksl[0] = 0
#define BCMI_TSC_XGXS_PMD_UNCORRECTEDBLKSLr_SET(r,d) (r).pmd_uncorrectedblksl[0] = d
#define BCMI_TSC_XGXS_PMD_UNCORRECTEDBLKSLr_GET(r) (r).pmd_uncorrectedblksl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_PMD_UNCORRECTEDBLKSLr_UNCORCOUNTLf_GET(r) (((r).pmd_uncorrectedblksl[0]) & 0xffff)
#define BCMI_TSC_XGXS_PMD_UNCORRECTEDBLKSLr_UNCORCOUNTLf_SET(r,f) (r).pmd_uncorrectedblksl[0]=(((r).pmd_uncorrectedblksl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PMD_UNCORRECTEDBLKSL.
 *
 */
#define BCMI_TSC_XGXS_READ_PMD_UNCORRECTEDBLKSLr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_PMD_UNCORRECTEDBLKSLr,(_r._pmd_uncorrectedblksl))
#define BCMI_TSC_XGXS_WRITE_PMD_UNCORRECTEDBLKSLr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_PMD_UNCORRECTEDBLKSLr,(_r._pmd_uncorrectedblksl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PMD_UNCORRECTEDBLKSLr BCMI_TSC_XGXS_PMD_UNCORRECTEDBLKSLr
#define PMD_UNCORRECTEDBLKSLr_SIZE BCMI_TSC_XGXS_PMD_UNCORRECTEDBLKSLr_SIZE
typedef BCMI_TSC_XGXS_PMD_UNCORRECTEDBLKSLr_t PMD_UNCORRECTEDBLKSLr_t;
#define PMD_UNCORRECTEDBLKSLr_CLR BCMI_TSC_XGXS_PMD_UNCORRECTEDBLKSLr_CLR
#define PMD_UNCORRECTEDBLKSLr_SET BCMI_TSC_XGXS_PMD_UNCORRECTEDBLKSLr_SET
#define PMD_UNCORRECTEDBLKSLr_GET BCMI_TSC_XGXS_PMD_UNCORRECTEDBLKSLr_GET
#define PMD_UNCORRECTEDBLKSLr_UNCORCOUNTLf_GET BCMI_TSC_XGXS_PMD_UNCORRECTEDBLKSLr_UNCORCOUNTLf_GET
#define PMD_UNCORRECTEDBLKSLr_UNCORCOUNTLf_SET BCMI_TSC_XGXS_PMD_UNCORRECTEDBLKSLr_UNCORCOUNTLf_SET
#define READ_PMD_UNCORRECTEDBLKSLr BCMI_TSC_XGXS_READ_PMD_UNCORRECTEDBLKSLr
#define WRITE_PMD_UNCORRECTEDBLKSLr BCMI_TSC_XGXS_WRITE_PMD_UNCORRECTEDBLKSLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_PMD_UNCORRECTEDBLKSLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  PMD_UNCORRECTEDBLKSH
 * BLOCKS:   DEV1_IEEE10
 * REGADDR:  0x00af
 * DEVAD:    1
 * DESC:     "FEC uncorrected blocks counter [31:16]": 00000000
 * SIZE:     32
 * FIELDS:
 *     UNCORCOUNTH      
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_PMD_UNCORRECTEDBLKSHr (0x000100af | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_PMD_UNCORRECTEDBLKSHr_SIZE 4

/*
 * This structure should be used to declare and program PMD_UNCORRECTEDBLKSH.
 *
 */
typedef union BCMI_TSC_XGXS_PMD_UNCORRECTEDBLKSHr_s {
	uint32_t v[1];
	uint32_t pmd_uncorrectedblksh[1];
	uint32_t _pmd_uncorrectedblksh;
} BCMI_TSC_XGXS_PMD_UNCORRECTEDBLKSHr_t;

#define BCMI_TSC_XGXS_PMD_UNCORRECTEDBLKSHr_CLR(r) (r).pmd_uncorrectedblksh[0] = 0
#define BCMI_TSC_XGXS_PMD_UNCORRECTEDBLKSHr_SET(r,d) (r).pmd_uncorrectedblksh[0] = d
#define BCMI_TSC_XGXS_PMD_UNCORRECTEDBLKSHr_GET(r) (r).pmd_uncorrectedblksh[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_PMD_UNCORRECTEDBLKSHr_UNCORCOUNTHf_GET(r) (((r).pmd_uncorrectedblksh[0]) & 0xffff)
#define BCMI_TSC_XGXS_PMD_UNCORRECTEDBLKSHr_UNCORCOUNTHf_SET(r,f) (r).pmd_uncorrectedblksh[0]=(((r).pmd_uncorrectedblksh[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PMD_UNCORRECTEDBLKSH.
 *
 */
#define BCMI_TSC_XGXS_READ_PMD_UNCORRECTEDBLKSHr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_PMD_UNCORRECTEDBLKSHr,(_r._pmd_uncorrectedblksh))
#define BCMI_TSC_XGXS_WRITE_PMD_UNCORRECTEDBLKSHr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_PMD_UNCORRECTEDBLKSHr,(_r._pmd_uncorrectedblksh))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PMD_UNCORRECTEDBLKSHr BCMI_TSC_XGXS_PMD_UNCORRECTEDBLKSHr
#define PMD_UNCORRECTEDBLKSHr_SIZE BCMI_TSC_XGXS_PMD_UNCORRECTEDBLKSHr_SIZE
typedef BCMI_TSC_XGXS_PMD_UNCORRECTEDBLKSHr_t PMD_UNCORRECTEDBLKSHr_t;
#define PMD_UNCORRECTEDBLKSHr_CLR BCMI_TSC_XGXS_PMD_UNCORRECTEDBLKSHr_CLR
#define PMD_UNCORRECTEDBLKSHr_SET BCMI_TSC_XGXS_PMD_UNCORRECTEDBLKSHr_SET
#define PMD_UNCORRECTEDBLKSHr_GET BCMI_TSC_XGXS_PMD_UNCORRECTEDBLKSHr_GET
#define PMD_UNCORRECTEDBLKSHr_UNCORCOUNTHf_GET BCMI_TSC_XGXS_PMD_UNCORRECTEDBLKSHr_UNCORCOUNTHf_GET
#define PMD_UNCORRECTEDBLKSHr_UNCORCOUNTHf_SET BCMI_TSC_XGXS_PMD_UNCORRECTEDBLKSHr_UNCORCOUNTHf_SET
#define READ_PMD_UNCORRECTEDBLKSHr BCMI_TSC_XGXS_READ_PMD_UNCORRECTEDBLKSHr
#define WRITE_PMD_UNCORRECTEDBLKSHr BCMI_TSC_XGXS_WRITE_PMD_UNCORRECTEDBLKSHr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_PMD_UNCORRECTEDBLKSHr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  TSC_12_PMD_FECABIL
 * BLOCKS:   DEV1_IEEE10
 * REGADDR:  0x00ba
 * DEVAD:    1
 * DESC:     "FEC ability register": 00000000
 * SIZE:     32
 * FIELDS:
 *     FEC_ABLE         
 *     ERRORCNT_ABLE    
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_TSC_12_PMD_FECABILr (0x000100ba | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_TSC_12_PMD_FECABILr_SIZE 4

/*
 * This structure should be used to declare and program TSC_12_PMD_FECABIL.
 *
 */
typedef union BCMI_TSC_XGXS_TSC_12_PMD_FECABILr_s {
	uint32_t v[1];
	uint32_t tsc_12_pmd_fecabil[1];
	uint32_t _tsc_12_pmd_fecabil;
} BCMI_TSC_XGXS_TSC_12_PMD_FECABILr_t;

#define BCMI_TSC_XGXS_TSC_12_PMD_FECABILr_CLR(r) (r).tsc_12_pmd_fecabil[0] = 0
#define BCMI_TSC_XGXS_TSC_12_PMD_FECABILr_SET(r,d) (r).tsc_12_pmd_fecabil[0] = d
#define BCMI_TSC_XGXS_TSC_12_PMD_FECABILr_GET(r) (r).tsc_12_pmd_fecabil[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_TSC_12_PMD_FECABILr_RESERVED0f_GET(r) ((((r).tsc_12_pmd_fecabil[0]) >> 2) & 0x3fff)
#define BCMI_TSC_XGXS_TSC_12_PMD_FECABILr_RESERVED0f_SET(r,f) (r).tsc_12_pmd_fecabil[0]=(((r).tsc_12_pmd_fecabil[0] & ~((uint32_t)0x3fff << 2)) | ((((uint32_t)f) & 0x3fff) << 2))
#define BCMI_TSC_XGXS_TSC_12_PMD_FECABILr_ERRORCNT_ABLEf_GET(r) ((((r).tsc_12_pmd_fecabil[0]) >> 1) & 0x1)
#define BCMI_TSC_XGXS_TSC_12_PMD_FECABILr_ERRORCNT_ABLEf_SET(r,f) (r).tsc_12_pmd_fecabil[0]=(((r).tsc_12_pmd_fecabil[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCMI_TSC_XGXS_TSC_12_PMD_FECABILr_FEC_ABLEf_GET(r) (((r).tsc_12_pmd_fecabil[0]) & 0x1)
#define BCMI_TSC_XGXS_TSC_12_PMD_FECABILr_FEC_ABLEf_SET(r,f) (r).tsc_12_pmd_fecabil[0]=(((r).tsc_12_pmd_fecabil[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access TSC_12_PMD_FECABIL.
 *
 */
#define BCMI_TSC_XGXS_READ_TSC_12_PMD_FECABILr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_TSC_12_PMD_FECABILr,(_r._tsc_12_pmd_fecabil))
#define BCMI_TSC_XGXS_WRITE_TSC_12_PMD_FECABILr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_TSC_12_PMD_FECABILr,(_r._tsc_12_pmd_fecabil))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TSC_12_PMD_FECABILr BCMI_TSC_XGXS_TSC_12_PMD_FECABILr
#define TSC_12_PMD_FECABILr_SIZE BCMI_TSC_XGXS_TSC_12_PMD_FECABILr_SIZE
typedef BCMI_TSC_XGXS_TSC_12_PMD_FECABILr_t TSC_12_PMD_FECABILr_t;
#define TSC_12_PMD_FECABILr_CLR BCMI_TSC_XGXS_TSC_12_PMD_FECABILr_CLR
#define TSC_12_PMD_FECABILr_SET BCMI_TSC_XGXS_TSC_12_PMD_FECABILr_SET
#define TSC_12_PMD_FECABILr_GET BCMI_TSC_XGXS_TSC_12_PMD_FECABILr_GET
#define TSC_12_PMD_FECABILr_RESERVED0f_GET BCMI_TSC_XGXS_TSC_12_PMD_FECABILr_RESERVED0f_GET
#define TSC_12_PMD_FECABILr_RESERVED0f_SET BCMI_TSC_XGXS_TSC_12_PMD_FECABILr_RESERVED0f_SET
#define TSC_12_PMD_FECABILr_ERRORCNT_ABLEf_GET BCMI_TSC_XGXS_TSC_12_PMD_FECABILr_ERRORCNT_ABLEf_GET
#define TSC_12_PMD_FECABILr_ERRORCNT_ABLEf_SET BCMI_TSC_XGXS_TSC_12_PMD_FECABILr_ERRORCNT_ABLEf_SET
#define TSC_12_PMD_FECABILr_FEC_ABLEf_GET BCMI_TSC_XGXS_TSC_12_PMD_FECABILr_FEC_ABLEf_GET
#define TSC_12_PMD_FECABILr_FEC_ABLEf_SET BCMI_TSC_XGXS_TSC_12_PMD_FECABILr_FEC_ABLEf_SET
#define READ_TSC_12_PMD_FECABILr BCMI_TSC_XGXS_READ_TSC_12_PMD_FECABILr
#define WRITE_TSC_12_PMD_FECABILr BCMI_TSC_XGXS_WRITE_TSC_12_PMD_FECABILr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_TSC_12_PMD_FECABILr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  TSC_12_PMD_FECCONTROL
 * BLOCKS:   DEV1_IEEE10
 * REGADDR:  0x00bb
 * DEVAD:    1
 * DESC:     "FEC control register": 00000000
 * SIZE:     32
 * FIELDS:
 *     FEC_EN           
 *     ERRORCNT_EN      
 *     RESERVED0        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_TSC_12_PMD_FECCONTROLr (0x000100bb | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_TSC_12_PMD_FECCONTROLr_SIZE 4

/*
 * This structure should be used to declare and program TSC_12_PMD_FECCONTROL.
 *
 */
typedef union BCMI_TSC_XGXS_TSC_12_PMD_FECCONTROLr_s {
	uint32_t v[1];
	uint32_t tsc_12_pmd_feccontrol[1];
	uint32_t _tsc_12_pmd_feccontrol;
} BCMI_TSC_XGXS_TSC_12_PMD_FECCONTROLr_t;

#define BCMI_TSC_XGXS_TSC_12_PMD_FECCONTROLr_CLR(r) (r).tsc_12_pmd_feccontrol[0] = 0
#define BCMI_TSC_XGXS_TSC_12_PMD_FECCONTROLr_SET(r,d) (r).tsc_12_pmd_feccontrol[0] = d
#define BCMI_TSC_XGXS_TSC_12_PMD_FECCONTROLr_GET(r) (r).tsc_12_pmd_feccontrol[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_TSC_12_PMD_FECCONTROLr_RESERVED0f_GET(r) ((((r).tsc_12_pmd_feccontrol[0]) >> 2) & 0x3fff)
#define BCMI_TSC_XGXS_TSC_12_PMD_FECCONTROLr_RESERVED0f_SET(r,f) (r).tsc_12_pmd_feccontrol[0]=(((r).tsc_12_pmd_feccontrol[0] & ~((uint32_t)0x3fff << 2)) | ((((uint32_t)f) & 0x3fff) << 2))
#define BCMI_TSC_XGXS_TSC_12_PMD_FECCONTROLr_ERRORCNT_ENf_GET(r) ((((r).tsc_12_pmd_feccontrol[0]) >> 1) & 0x1)
#define BCMI_TSC_XGXS_TSC_12_PMD_FECCONTROLr_ERRORCNT_ENf_SET(r,f) (r).tsc_12_pmd_feccontrol[0]=(((r).tsc_12_pmd_feccontrol[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCMI_TSC_XGXS_TSC_12_PMD_FECCONTROLr_FEC_ENf_GET(r) (((r).tsc_12_pmd_feccontrol[0]) & 0x1)
#define BCMI_TSC_XGXS_TSC_12_PMD_FECCONTROLr_FEC_ENf_SET(r,f) (r).tsc_12_pmd_feccontrol[0]=(((r).tsc_12_pmd_feccontrol[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access TSC_12_PMD_FECCONTROL.
 *
 */
#define BCMI_TSC_XGXS_READ_TSC_12_PMD_FECCONTROLr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_TSC_12_PMD_FECCONTROLr,(_r._tsc_12_pmd_feccontrol))
#define BCMI_TSC_XGXS_WRITE_TSC_12_PMD_FECCONTROLr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_TSC_12_PMD_FECCONTROLr,(_r._tsc_12_pmd_feccontrol))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TSC_12_PMD_FECCONTROLr BCMI_TSC_XGXS_TSC_12_PMD_FECCONTROLr
#define TSC_12_PMD_FECCONTROLr_SIZE BCMI_TSC_XGXS_TSC_12_PMD_FECCONTROLr_SIZE
typedef BCMI_TSC_XGXS_TSC_12_PMD_FECCONTROLr_t TSC_12_PMD_FECCONTROLr_t;
#define TSC_12_PMD_FECCONTROLr_CLR BCMI_TSC_XGXS_TSC_12_PMD_FECCONTROLr_CLR
#define TSC_12_PMD_FECCONTROLr_SET BCMI_TSC_XGXS_TSC_12_PMD_FECCONTROLr_SET
#define TSC_12_PMD_FECCONTROLr_GET BCMI_TSC_XGXS_TSC_12_PMD_FECCONTROLr_GET
#define TSC_12_PMD_FECCONTROLr_RESERVED0f_GET BCMI_TSC_XGXS_TSC_12_PMD_FECCONTROLr_RESERVED0f_GET
#define TSC_12_PMD_FECCONTROLr_RESERVED0f_SET BCMI_TSC_XGXS_TSC_12_PMD_FECCONTROLr_RESERVED0f_SET
#define TSC_12_PMD_FECCONTROLr_ERRORCNT_ENf_GET BCMI_TSC_XGXS_TSC_12_PMD_FECCONTROLr_ERRORCNT_ENf_GET
#define TSC_12_PMD_FECCONTROLr_ERRORCNT_ENf_SET BCMI_TSC_XGXS_TSC_12_PMD_FECCONTROLr_ERRORCNT_ENf_SET
#define TSC_12_PMD_FECCONTROLr_FEC_ENf_GET BCMI_TSC_XGXS_TSC_12_PMD_FECCONTROLr_FEC_ENf_GET
#define TSC_12_PMD_FECCONTROLr_FEC_ENf_SET BCMI_TSC_XGXS_TSC_12_PMD_FECCONTROLr_FEC_ENf_SET
#define READ_TSC_12_PMD_FECCONTROLr BCMI_TSC_XGXS_READ_TSC_12_PMD_FECCONTROLr
#define WRITE_TSC_12_PMD_FECCONTROLr BCMI_TSC_XGXS_WRITE_TSC_12_PMD_FECCONTROLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_TSC_12_PMD_FECCONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  TSC_12_PMD_CORRECTEDBLKSL
 * BLOCKS:   DEV1_IEEE10
 * REGADDR:  0x00bc
 * DEVAD:    1
 * DESC:     "FEC corrected blocks counter [15:0]": 00000000
 * SIZE:     32
 * FIELDS:
 *     CORCOUNTL        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_TSC_12_PMD_CORRECTEDBLKSLr (0x000100bc | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_TSC_12_PMD_CORRECTEDBLKSLr_SIZE 4

/*
 * This structure should be used to declare and program TSC_12_PMD_CORRECTEDBLKSL.
 *
 */
typedef union BCMI_TSC_XGXS_TSC_12_PMD_CORRECTEDBLKSLr_s {
	uint32_t v[1];
	uint32_t tsc_12_pmd_correctedblksl[1];
	uint32_t _tsc_12_pmd_correctedblksl;
} BCMI_TSC_XGXS_TSC_12_PMD_CORRECTEDBLKSLr_t;

#define BCMI_TSC_XGXS_TSC_12_PMD_CORRECTEDBLKSLr_CLR(r) (r).tsc_12_pmd_correctedblksl[0] = 0
#define BCMI_TSC_XGXS_TSC_12_PMD_CORRECTEDBLKSLr_SET(r,d) (r).tsc_12_pmd_correctedblksl[0] = d
#define BCMI_TSC_XGXS_TSC_12_PMD_CORRECTEDBLKSLr_GET(r) (r).tsc_12_pmd_correctedblksl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_TSC_12_PMD_CORRECTEDBLKSLr_CORCOUNTLf_GET(r) (((r).tsc_12_pmd_correctedblksl[0]) & 0xffff)
#define BCMI_TSC_XGXS_TSC_12_PMD_CORRECTEDBLKSLr_CORCOUNTLf_SET(r,f) (r).tsc_12_pmd_correctedblksl[0]=(((r).tsc_12_pmd_correctedblksl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access TSC_12_PMD_CORRECTEDBLKSL.
 *
 */
#define BCMI_TSC_XGXS_READ_TSC_12_PMD_CORRECTEDBLKSLr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_TSC_12_PMD_CORRECTEDBLKSLr,(_r._tsc_12_pmd_correctedblksl))
#define BCMI_TSC_XGXS_WRITE_TSC_12_PMD_CORRECTEDBLKSLr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_TSC_12_PMD_CORRECTEDBLKSLr,(_r._tsc_12_pmd_correctedblksl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TSC_12_PMD_CORRECTEDBLKSLr BCMI_TSC_XGXS_TSC_12_PMD_CORRECTEDBLKSLr
#define TSC_12_PMD_CORRECTEDBLKSLr_SIZE BCMI_TSC_XGXS_TSC_12_PMD_CORRECTEDBLKSLr_SIZE
typedef BCMI_TSC_XGXS_TSC_12_PMD_CORRECTEDBLKSLr_t TSC_12_PMD_CORRECTEDBLKSLr_t;
#define TSC_12_PMD_CORRECTEDBLKSLr_CLR BCMI_TSC_XGXS_TSC_12_PMD_CORRECTEDBLKSLr_CLR
#define TSC_12_PMD_CORRECTEDBLKSLr_SET BCMI_TSC_XGXS_TSC_12_PMD_CORRECTEDBLKSLr_SET
#define TSC_12_PMD_CORRECTEDBLKSLr_GET BCMI_TSC_XGXS_TSC_12_PMD_CORRECTEDBLKSLr_GET
#define TSC_12_PMD_CORRECTEDBLKSLr_CORCOUNTLf_GET BCMI_TSC_XGXS_TSC_12_PMD_CORRECTEDBLKSLr_CORCOUNTLf_GET
#define TSC_12_PMD_CORRECTEDBLKSLr_CORCOUNTLf_SET BCMI_TSC_XGXS_TSC_12_PMD_CORRECTEDBLKSLr_CORCOUNTLf_SET
#define READ_TSC_12_PMD_CORRECTEDBLKSLr BCMI_TSC_XGXS_READ_TSC_12_PMD_CORRECTEDBLKSLr
#define WRITE_TSC_12_PMD_CORRECTEDBLKSLr BCMI_TSC_XGXS_WRITE_TSC_12_PMD_CORRECTEDBLKSLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_TSC_12_PMD_CORRECTEDBLKSLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  TSC_12_PMD_CORRECTEDBLKSH
 * BLOCKS:   DEV1_IEEE10
 * REGADDR:  0x00bd
 * DEVAD:    1
 * DESC:     "FEC corrected blocks counter [31:16]": 00000000
 * SIZE:     32
 * FIELDS:
 *     CORCOUNTH        
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_TSC_12_PMD_CORRECTEDBLKSHr (0x000100bd | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_TSC_12_PMD_CORRECTEDBLKSHr_SIZE 4

/*
 * This structure should be used to declare and program TSC_12_PMD_CORRECTEDBLKSH.
 *
 */
typedef union BCMI_TSC_XGXS_TSC_12_PMD_CORRECTEDBLKSHr_s {
	uint32_t v[1];
	uint32_t tsc_12_pmd_correctedblksh[1];
	uint32_t _tsc_12_pmd_correctedblksh;
} BCMI_TSC_XGXS_TSC_12_PMD_CORRECTEDBLKSHr_t;

#define BCMI_TSC_XGXS_TSC_12_PMD_CORRECTEDBLKSHr_CLR(r) (r).tsc_12_pmd_correctedblksh[0] = 0
#define BCMI_TSC_XGXS_TSC_12_PMD_CORRECTEDBLKSHr_SET(r,d) (r).tsc_12_pmd_correctedblksh[0] = d
#define BCMI_TSC_XGXS_TSC_12_PMD_CORRECTEDBLKSHr_GET(r) (r).tsc_12_pmd_correctedblksh[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_TSC_12_PMD_CORRECTEDBLKSHr_CORCOUNTHf_GET(r) (((r).tsc_12_pmd_correctedblksh[0]) & 0xffff)
#define BCMI_TSC_XGXS_TSC_12_PMD_CORRECTEDBLKSHr_CORCOUNTHf_SET(r,f) (r).tsc_12_pmd_correctedblksh[0]=(((r).tsc_12_pmd_correctedblksh[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access TSC_12_PMD_CORRECTEDBLKSH.
 *
 */
#define BCMI_TSC_XGXS_READ_TSC_12_PMD_CORRECTEDBLKSHr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_TSC_12_PMD_CORRECTEDBLKSHr,(_r._tsc_12_pmd_correctedblksh))
#define BCMI_TSC_XGXS_WRITE_TSC_12_PMD_CORRECTEDBLKSHr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_TSC_12_PMD_CORRECTEDBLKSHr,(_r._tsc_12_pmd_correctedblksh))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TSC_12_PMD_CORRECTEDBLKSHr BCMI_TSC_XGXS_TSC_12_PMD_CORRECTEDBLKSHr
#define TSC_12_PMD_CORRECTEDBLKSHr_SIZE BCMI_TSC_XGXS_TSC_12_PMD_CORRECTEDBLKSHr_SIZE
typedef BCMI_TSC_XGXS_TSC_12_PMD_CORRECTEDBLKSHr_t TSC_12_PMD_CORRECTEDBLKSHr_t;
#define TSC_12_PMD_CORRECTEDBLKSHr_CLR BCMI_TSC_XGXS_TSC_12_PMD_CORRECTEDBLKSHr_CLR
#define TSC_12_PMD_CORRECTEDBLKSHr_SET BCMI_TSC_XGXS_TSC_12_PMD_CORRECTEDBLKSHr_SET
#define TSC_12_PMD_CORRECTEDBLKSHr_GET BCMI_TSC_XGXS_TSC_12_PMD_CORRECTEDBLKSHr_GET
#define TSC_12_PMD_CORRECTEDBLKSHr_CORCOUNTHf_GET BCMI_TSC_XGXS_TSC_12_PMD_CORRECTEDBLKSHr_CORCOUNTHf_GET
#define TSC_12_PMD_CORRECTEDBLKSHr_CORCOUNTHf_SET BCMI_TSC_XGXS_TSC_12_PMD_CORRECTEDBLKSHr_CORCOUNTHf_SET
#define READ_TSC_12_PMD_CORRECTEDBLKSHr BCMI_TSC_XGXS_READ_TSC_12_PMD_CORRECTEDBLKSHr
#define WRITE_TSC_12_PMD_CORRECTEDBLKSHr BCMI_TSC_XGXS_WRITE_TSC_12_PMD_CORRECTEDBLKSHr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_TSC_12_PMD_CORRECTEDBLKSHr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  TSC_12_PMD_UNCORRECTEDBLKSL
 * BLOCKS:   DEV1_IEEE10
 * REGADDR:  0x00be
 * DEVAD:    1
 * DESC:     "FEC uncorrected blocks counter [15:0]": 00000000
 * SIZE:     32
 * FIELDS:
 *     UNCORCOUNTL      
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_TSC_12_PMD_UNCORRECTEDBLKSLr (0x000100be | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_TSC_12_PMD_UNCORRECTEDBLKSLr_SIZE 4

/*
 * This structure should be used to declare and program TSC_12_PMD_UNCORRECTEDBLKSL.
 *
 */
typedef union BCMI_TSC_XGXS_TSC_12_PMD_UNCORRECTEDBLKSLr_s {
	uint32_t v[1];
	uint32_t tsc_12_pmd_uncorrectedblksl[1];
	uint32_t _tsc_12_pmd_uncorrectedblksl;
} BCMI_TSC_XGXS_TSC_12_PMD_UNCORRECTEDBLKSLr_t;

#define BCMI_TSC_XGXS_TSC_12_PMD_UNCORRECTEDBLKSLr_CLR(r) (r).tsc_12_pmd_uncorrectedblksl[0] = 0
#define BCMI_TSC_XGXS_TSC_12_PMD_UNCORRECTEDBLKSLr_SET(r,d) (r).tsc_12_pmd_uncorrectedblksl[0] = d
#define BCMI_TSC_XGXS_TSC_12_PMD_UNCORRECTEDBLKSLr_GET(r) (r).tsc_12_pmd_uncorrectedblksl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_TSC_12_PMD_UNCORRECTEDBLKSLr_UNCORCOUNTLf_GET(r) (((r).tsc_12_pmd_uncorrectedblksl[0]) & 0xffff)
#define BCMI_TSC_XGXS_TSC_12_PMD_UNCORRECTEDBLKSLr_UNCORCOUNTLf_SET(r,f) (r).tsc_12_pmd_uncorrectedblksl[0]=(((r).tsc_12_pmd_uncorrectedblksl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access TSC_12_PMD_UNCORRECTEDBLKSL.
 *
 */
#define BCMI_TSC_XGXS_READ_TSC_12_PMD_UNCORRECTEDBLKSLr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_TSC_12_PMD_UNCORRECTEDBLKSLr,(_r._tsc_12_pmd_uncorrectedblksl))
#define BCMI_TSC_XGXS_WRITE_TSC_12_PMD_UNCORRECTEDBLKSLr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_TSC_12_PMD_UNCORRECTEDBLKSLr,(_r._tsc_12_pmd_uncorrectedblksl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TSC_12_PMD_UNCORRECTEDBLKSLr BCMI_TSC_XGXS_TSC_12_PMD_UNCORRECTEDBLKSLr
#define TSC_12_PMD_UNCORRECTEDBLKSLr_SIZE BCMI_TSC_XGXS_TSC_12_PMD_UNCORRECTEDBLKSLr_SIZE
typedef BCMI_TSC_XGXS_TSC_12_PMD_UNCORRECTEDBLKSLr_t TSC_12_PMD_UNCORRECTEDBLKSLr_t;
#define TSC_12_PMD_UNCORRECTEDBLKSLr_CLR BCMI_TSC_XGXS_TSC_12_PMD_UNCORRECTEDBLKSLr_CLR
#define TSC_12_PMD_UNCORRECTEDBLKSLr_SET BCMI_TSC_XGXS_TSC_12_PMD_UNCORRECTEDBLKSLr_SET
#define TSC_12_PMD_UNCORRECTEDBLKSLr_GET BCMI_TSC_XGXS_TSC_12_PMD_UNCORRECTEDBLKSLr_GET
#define TSC_12_PMD_UNCORRECTEDBLKSLr_UNCORCOUNTLf_GET BCMI_TSC_XGXS_TSC_12_PMD_UNCORRECTEDBLKSLr_UNCORCOUNTLf_GET
#define TSC_12_PMD_UNCORRECTEDBLKSLr_UNCORCOUNTLf_SET BCMI_TSC_XGXS_TSC_12_PMD_UNCORRECTEDBLKSLr_UNCORCOUNTLf_SET
#define READ_TSC_12_PMD_UNCORRECTEDBLKSLr BCMI_TSC_XGXS_READ_TSC_12_PMD_UNCORRECTEDBLKSLr
#define WRITE_TSC_12_PMD_UNCORRECTEDBLKSLr BCMI_TSC_XGXS_WRITE_TSC_12_PMD_UNCORRECTEDBLKSLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_TSC_12_PMD_UNCORRECTEDBLKSLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  TSC_12_PMD_UNCORRECTEDBLKSH
 * BLOCKS:   DEV1_IEEE10
 * REGADDR:  0x00bf
 * DEVAD:    1
 * DESC:     "FEC uncorrected blocks counter [31:16]": 00000000
 * SIZE:     32
 * FIELDS:
 *     UNCORCOUNTH      
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_TSC_12_PMD_UNCORRECTEDBLKSHr (0x000100bf | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_TSC_12_PMD_UNCORRECTEDBLKSHr_SIZE 4

/*
 * This structure should be used to declare and program TSC_12_PMD_UNCORRECTEDBLKSH.
 *
 */
typedef union BCMI_TSC_XGXS_TSC_12_PMD_UNCORRECTEDBLKSHr_s {
	uint32_t v[1];
	uint32_t tsc_12_pmd_uncorrectedblksh[1];
	uint32_t _tsc_12_pmd_uncorrectedblksh;
} BCMI_TSC_XGXS_TSC_12_PMD_UNCORRECTEDBLKSHr_t;

#define BCMI_TSC_XGXS_TSC_12_PMD_UNCORRECTEDBLKSHr_CLR(r) (r).tsc_12_pmd_uncorrectedblksh[0] = 0
#define BCMI_TSC_XGXS_TSC_12_PMD_UNCORRECTEDBLKSHr_SET(r,d) (r).tsc_12_pmd_uncorrectedblksh[0] = d
#define BCMI_TSC_XGXS_TSC_12_PMD_UNCORRECTEDBLKSHr_GET(r) (r).tsc_12_pmd_uncorrectedblksh[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_TSC_12_PMD_UNCORRECTEDBLKSHr_UNCORCOUNTHf_GET(r) (((r).tsc_12_pmd_uncorrectedblksh[0]) & 0xffff)
#define BCMI_TSC_XGXS_TSC_12_PMD_UNCORRECTEDBLKSHr_UNCORCOUNTHf_SET(r,f) (r).tsc_12_pmd_uncorrectedblksh[0]=(((r).tsc_12_pmd_uncorrectedblksh[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access TSC_12_PMD_UNCORRECTEDBLKSH.
 *
 */
#define BCMI_TSC_XGXS_READ_TSC_12_PMD_UNCORRECTEDBLKSHr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_TSC_12_PMD_UNCORRECTEDBLKSHr,(_r._tsc_12_pmd_uncorrectedblksh))
#define BCMI_TSC_XGXS_WRITE_TSC_12_PMD_UNCORRECTEDBLKSHr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_TSC_12_PMD_UNCORRECTEDBLKSHr,(_r._tsc_12_pmd_uncorrectedblksh))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TSC_12_PMD_UNCORRECTEDBLKSHr BCMI_TSC_XGXS_TSC_12_PMD_UNCORRECTEDBLKSHr
#define TSC_12_PMD_UNCORRECTEDBLKSHr_SIZE BCMI_TSC_XGXS_TSC_12_PMD_UNCORRECTEDBLKSHr_SIZE
typedef BCMI_TSC_XGXS_TSC_12_PMD_UNCORRECTEDBLKSHr_t TSC_12_PMD_UNCORRECTEDBLKSHr_t;
#define TSC_12_PMD_UNCORRECTEDBLKSHr_CLR BCMI_TSC_XGXS_TSC_12_PMD_UNCORRECTEDBLKSHr_CLR
#define TSC_12_PMD_UNCORRECTEDBLKSHr_SET BCMI_TSC_XGXS_TSC_12_PMD_UNCORRECTEDBLKSHr_SET
#define TSC_12_PMD_UNCORRECTEDBLKSHr_GET BCMI_TSC_XGXS_TSC_12_PMD_UNCORRECTEDBLKSHr_GET
#define TSC_12_PMD_UNCORRECTEDBLKSHr_UNCORCOUNTHf_GET BCMI_TSC_XGXS_TSC_12_PMD_UNCORRECTEDBLKSHr_UNCORCOUNTHf_GET
#define TSC_12_PMD_UNCORRECTEDBLKSHr_UNCORCOUNTHf_SET BCMI_TSC_XGXS_TSC_12_PMD_UNCORRECTEDBLKSHr_UNCORCOUNTHf_SET
#define READ_TSC_12_PMD_UNCORRECTEDBLKSHr BCMI_TSC_XGXS_READ_TSC_12_PMD_UNCORRECTEDBLKSHr
#define WRITE_TSC_12_PMD_UNCORRECTEDBLKSHr BCMI_TSC_XGXS_WRITE_TSC_12_PMD_UNCORRECTEDBLKSHr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_TSC_12_PMD_UNCORRECTEDBLKSHr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSC_XGXS
 * REGISTER:  PCS_ERRORED_BLOCKS_HO
 * BLOCKS:   DEV3_IEEE2
 * REGADDR:  0x002d
 * DEVAD:    3
 * DESC:     40G/100GBASE-R Errored blocks high order counter: 00000000
 * SIZE:     32
 * FIELDS:
 *     ERRORED_BLOCKS_HO 
 *     RESERVED0        
 *     ERRORED_BLOCKS_HO_PRESENT 
 *
 ******************************************************************************/
#define BCMI_TSC_XGXS_PCS_ERRORED_BLOCKS_HOr (0x0003002d | PHY_REG_ACC_TSC_IBLK)

#define BCMI_TSC_XGXS_PCS_ERRORED_BLOCKS_HOr_SIZE 4

/*
 * This structure should be used to declare and program PCS_ERRORED_BLOCKS_HO.
 *
 */
typedef union BCMI_TSC_XGXS_PCS_ERRORED_BLOCKS_HOr_s {
	uint32_t v[1];
	uint32_t pcs_errored_blocks_ho[1];
	uint32_t _pcs_errored_blocks_ho;
} BCMI_TSC_XGXS_PCS_ERRORED_BLOCKS_HOr_t;

#define BCMI_TSC_XGXS_PCS_ERRORED_BLOCKS_HOr_CLR(r) (r).pcs_errored_blocks_ho[0] = 0
#define BCMI_TSC_XGXS_PCS_ERRORED_BLOCKS_HOr_SET(r,d) (r).pcs_errored_blocks_ho[0] = d
#define BCMI_TSC_XGXS_PCS_ERRORED_BLOCKS_HOr_GET(r) (r).pcs_errored_blocks_ho[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSC_XGXS_PCS_ERRORED_BLOCKS_HOr_ERRORED_BLOCKS_HO_PRESENTf_GET(r) ((((r).pcs_errored_blocks_ho[0]) >> 15) & 0x1)
#define BCMI_TSC_XGXS_PCS_ERRORED_BLOCKS_HOr_ERRORED_BLOCKS_HO_PRESENTf_SET(r,f) (r).pcs_errored_blocks_ho[0]=(((r).pcs_errored_blocks_ho[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCMI_TSC_XGXS_PCS_ERRORED_BLOCKS_HOr_RESERVED0f_GET(r) ((((r).pcs_errored_blocks_ho[0]) >> 14) & 0x1)
#define BCMI_TSC_XGXS_PCS_ERRORED_BLOCKS_HOr_RESERVED0f_SET(r,f) (r).pcs_errored_blocks_ho[0]=(((r).pcs_errored_blocks_ho[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCMI_TSC_XGXS_PCS_ERRORED_BLOCKS_HOr_ERRORED_BLOCKS_HOf_GET(r) (((r).pcs_errored_blocks_ho[0]) & 0x3fff)
#define BCMI_TSC_XGXS_PCS_ERRORED_BLOCKS_HOr_ERRORED_BLOCKS_HOf_SET(r,f) (r).pcs_errored_blocks_ho[0]=(((r).pcs_errored_blocks_ho[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access PCS_ERRORED_BLOCKS_HO.
 *
 */
#define BCMI_TSC_XGXS_READ_PCS_ERRORED_BLOCKS_HOr(_pc,_r) phy_tsc_iblk_read(_pc,BCMI_TSC_XGXS_PCS_ERRORED_BLOCKS_HOr,(_r._pcs_errored_blocks_ho))
#define BCMI_TSC_XGXS_WRITE_PCS_ERRORED_BLOCKS_HOr(_pc,_r) phy_tsc_iblk_write(_pc,BCMI_TSC_XGXS_PCS_ERRORED_BLOCKS_HOr,(_r._pcs_errored_blocks_ho))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PCS_ERRORED_BLOCKS_HOr BCMI_TSC_XGXS_PCS_ERRORED_BLOCKS_HOr
#define PCS_ERRORED_BLOCKS_HOr_SIZE BCMI_TSC_XGXS_PCS_ERRORED_BLOCKS_HOr_SIZE
typedef BCMI_TSC_XGXS_PCS_ERRORED_BLOCKS_HOr_t PCS_ERRORED_BLOCKS_HOr_t;
#define PCS_ERRORED_BLOCKS_HOr_CLR BCMI_TSC_XGXS_PCS_ERRORED_BLOCKS_HOr_CLR
#define PCS_ERRORED_BLOCKS_HOr_SET BCMI_TSC_XGXS_PCS_ERRORED_BLOCKS_HOr_SET
#define PCS_ERRORED_BLOCKS_HOr_GET BCMI_TSC_XGXS_PCS_ERRORED_BLOCKS_HOr_GET
#define PCS_ERRORED_BLOCKS_HOr_ERRORED_BLOCKS_HO_PRESENTf_GET BCMI_TSC_XGXS_PCS_ERRORED_BLOCKS_HOr_ERRORED_BLOCKS_HO_PRESENTf_GET
#define PCS_ERRORED_BLOCKS_HOr_ERRORED_BLOCKS_HO_PRESENTf_SET BCMI_TSC_XGXS_PCS_ERRORED_BLOCKS_HOr_ERRORED_BLOCKS_HO_PRESENTf_SET
#define PCS_ERRORED_BLOCKS_HOr_RESERVED0f_GET BCMI_TSC_XGXS_PCS_ERRORED_BLOCKS_HOr_RESERVED0f_GET
#define PCS_ERRORED_BLOCKS_HOr_RESERVED0f_SET BCMI_TSC_XGXS_PCS_ERRORED_BLOCKS_HOr_RESERVED0f_SET
#define PCS_ERRORED_BLOCKS_HOr_ERRORED_BLOCKS_HOf_GET BCMI_TSC_XGXS_PCS_ERRORED_BLOCKS_HOr_ERRORED_BLOCKS_HOf_GET
#define PCS_ERRORED_BLOCKS_HOr_ERRORED_BLOCKS_HOf_SET BCMI_TSC_XGXS_PCS_ERRORED_BLOCKS_HOr_ERRORED_BLOCKS_HOf_SET
#define READ_PCS_ERRORED_BLOCKS_HOr BCMI_TSC_XGXS_READ_PCS_ERRORED_BLOCKS_HOr
#define WRITE_PCS_ERRORED_BLOCKS_HOr BCMI_TSC_XGXS_WRITE_PCS_ERRORED_BLOCKS_HOr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSC_XGXS_PCS_ERRORED_BLOCKS_HOr'
 ******************************************************************************/




#endif /* __BCMI_TSC_XGXS_DEFS_H__ */
