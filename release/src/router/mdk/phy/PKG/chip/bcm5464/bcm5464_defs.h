#ifndef __BCM5464_DEFS_H__
#define __BCM5464_DEFS_H__
/*******************************************************************************
 *
 * $Copyright: Copyright 2013 Broadcom Corporation.
 * This program is the proprietary software of Broadcom Corporation
 * and/or its licensors, and may only be used, duplicated, modified
 * or distributed pursuant to the terms and conditions of a separate,
 * written license agreement executed between you and Broadcom
 * (an "Authorized License").  Except as set forth in an Authorized
 * License, Broadcom grants no license (express or implied), right
 * to use, or waiver of any kind with respect to the Software, and
 * Broadcom expressly reserves all rights in and to the Software
 * and all intellectual property rights therein.  IF YOU HAVE
 * NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
 * IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
 * ALL USE OF THE SOFTWARE.  
 *  
 * Except as expressly set forth in the Authorized License,
 *  
 * 1.     This program, including its structure, sequence and organization,
 * constitutes the valuable trade secrets of Broadcom, and you shall use
 * all reasonable efforts to protect the confidentiality thereof,
 * and to use this information only in connection with your use of
 * Broadcom integrated circuit products.
 *  
 * 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
 * PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
 * REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
 * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
 * DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
 * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
 * ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
 * CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
 * OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
 * 
 * 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
 * BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
 * INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
 * ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
 * TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
 * THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR USD 1.00,
 * WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
 * ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated from the registers file.
 * Edits to this file will be lost when it is regenerated.
 *
 * Definition file for the BCM5464.
 * This file provides all basic definitions required to program the BCM5464.
 *
 * This file is autogenerated. Please do not edit.
 *
 ******************************************************************************/

#include <phy/phy_brcm_shadow.h>

/*******************************************************************************
 *
 *                    CHIP DEFINITIONS BEGIN HERE
 *
 ******************************************************************************/



/*******************************************************************************
 * CHIP:  BCM5464
 * REGISTER:  MII_CTRL
 * BLOCKS:   IEEE
 * REGADDR:  0x0000
 * DESC:     1000BASE-T/100BASE-TX/10BASE-T MII Control Register (Addr 00h)
 * SIZE:     32
 * FIELDS:
 *     SPEED_SEL1       Speed selection (MSB).
 *     COLL_TEST_EN     Enable collision test mode.
 *     FULL_DUPLEX      Full duplex operation.
 *     RESTART_AN       Restart auto-negotiation.
 *     ISOLATE          Isolate PHY from GMII/RGMII/RTBI.
 *     POWER_DOWN       Power down.
 *     AUTONEG          Auto-negotiation enabled.
 *     SPEED_SEL0       Speed selection (LSB).
 *     LOOPBACK         Loopback mode.
 *     RESET            PHY reset.
 *
 ******************************************************************************/
#define BCM5464_MII_CTRLr (0x00000000 | PHY_REG_ACC_RAW)

#define BCM5464_MII_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program MII_CTRL.
 *
 */
typedef union BCM5464_MII_CTRLr_s {
	uint32_t v[1];
	uint32_t mii_ctrl[1];
	uint32_t _mii_ctrl;
} BCM5464_MII_CTRLr_t;

#define BCM5464_MII_CTRLr_CLR(r) (r).mii_ctrl[0] = 0
#define BCM5464_MII_CTRLr_SET(r,d) (r).mii_ctrl[0] = d
#define BCM5464_MII_CTRLr_GET(r) (r).mii_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM5464_MII_CTRLr_RESETf_GET(r) ((((r).mii_ctrl[0]) >> 15) & 0x1)
#define BCM5464_MII_CTRLr_RESETf_SET(r,f) (r).mii_ctrl[0]=(((r).mii_ctrl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM5464_MII_CTRLr_LOOPBACKf_GET(r) ((((r).mii_ctrl[0]) >> 14) & 0x1)
#define BCM5464_MII_CTRLr_LOOPBACKf_SET(r,f) (r).mii_ctrl[0]=(((r).mii_ctrl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM5464_MII_CTRLr_SPEED_SEL0f_GET(r) ((((r).mii_ctrl[0]) >> 13) & 0x1)
#define BCM5464_MII_CTRLr_SPEED_SEL0f_SET(r,f) (r).mii_ctrl[0]=(((r).mii_ctrl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM5464_MII_CTRLr_AUTONEGf_GET(r) ((((r).mii_ctrl[0]) >> 12) & 0x1)
#define BCM5464_MII_CTRLr_AUTONEGf_SET(r,f) (r).mii_ctrl[0]=(((r).mii_ctrl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM5464_MII_CTRLr_POWER_DOWNf_GET(r) ((((r).mii_ctrl[0]) >> 11) & 0x1)
#define BCM5464_MII_CTRLr_POWER_DOWNf_SET(r,f) (r).mii_ctrl[0]=(((r).mii_ctrl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM5464_MII_CTRLr_ISOLATEf_GET(r) ((((r).mii_ctrl[0]) >> 10) & 0x1)
#define BCM5464_MII_CTRLr_ISOLATEf_SET(r,f) (r).mii_ctrl[0]=(((r).mii_ctrl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM5464_MII_CTRLr_RESTART_ANf_GET(r) ((((r).mii_ctrl[0]) >> 9) & 0x1)
#define BCM5464_MII_CTRLr_RESTART_ANf_SET(r,f) (r).mii_ctrl[0]=(((r).mii_ctrl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM5464_MII_CTRLr_FULL_DUPLEXf_GET(r) ((((r).mii_ctrl[0]) >> 8) & 0x1)
#define BCM5464_MII_CTRLr_FULL_DUPLEXf_SET(r,f) (r).mii_ctrl[0]=(((r).mii_ctrl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM5464_MII_CTRLr_COLL_TEST_ENf_GET(r) ((((r).mii_ctrl[0]) >> 7) & 0x1)
#define BCM5464_MII_CTRLr_COLL_TEST_ENf_SET(r,f) (r).mii_ctrl[0]=(((r).mii_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM5464_MII_CTRLr_SPEED_SEL1f_GET(r) ((((r).mii_ctrl[0]) >> 6) & 0x1)
#define BCM5464_MII_CTRLr_SPEED_SEL1f_SET(r,f) (r).mii_ctrl[0]=(((r).mii_ctrl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))

/*
 * These macros can be used to access MII_CTRL.
 *
 */
#define BCM5464_READ_MII_CTRLr(_pc,_r) PHY_REG_READ(_pc,BCM5464_MII_CTRLr,_r._mii_ctrl)
#define BCM5464_WRITE_MII_CTRLr(_pc,_r) PHY_REG_WRITE(_pc,BCM5464_MII_CTRLr,_r._mii_ctrl)

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MII_CTRLr BCM5464_MII_CTRLr
#define MII_CTRLr_SIZE BCM5464_MII_CTRLr_SIZE
typedef BCM5464_MII_CTRLr_t MII_CTRLr_t;
#define MII_CTRLr_CLR BCM5464_MII_CTRLr_CLR
#define MII_CTRLr_SET BCM5464_MII_CTRLr_SET
#define MII_CTRLr_GET BCM5464_MII_CTRLr_GET
#define MII_CTRLr_RESETf_GET BCM5464_MII_CTRLr_RESETf_GET
#define MII_CTRLr_RESETf_SET BCM5464_MII_CTRLr_RESETf_SET
#define MII_CTRLr_LOOPBACKf_GET BCM5464_MII_CTRLr_LOOPBACKf_GET
#define MII_CTRLr_LOOPBACKf_SET BCM5464_MII_CTRLr_LOOPBACKf_SET
#define MII_CTRLr_SPEED_SEL0f_GET BCM5464_MII_CTRLr_SPEED_SEL0f_GET
#define MII_CTRLr_SPEED_SEL0f_SET BCM5464_MII_CTRLr_SPEED_SEL0f_SET
#define MII_CTRLr_AUTONEGf_GET BCM5464_MII_CTRLr_AUTONEGf_GET
#define MII_CTRLr_AUTONEGf_SET BCM5464_MII_CTRLr_AUTONEGf_SET
#define MII_CTRLr_POWER_DOWNf_GET BCM5464_MII_CTRLr_POWER_DOWNf_GET
#define MII_CTRLr_POWER_DOWNf_SET BCM5464_MII_CTRLr_POWER_DOWNf_SET
#define MII_CTRLr_ISOLATEf_GET BCM5464_MII_CTRLr_ISOLATEf_GET
#define MII_CTRLr_ISOLATEf_SET BCM5464_MII_CTRLr_ISOLATEf_SET
#define MII_CTRLr_RESTART_ANf_GET BCM5464_MII_CTRLr_RESTART_ANf_GET
#define MII_CTRLr_RESTART_ANf_SET BCM5464_MII_CTRLr_RESTART_ANf_SET
#define MII_CTRLr_FULL_DUPLEXf_GET BCM5464_MII_CTRLr_FULL_DUPLEXf_GET
#define MII_CTRLr_FULL_DUPLEXf_SET BCM5464_MII_CTRLr_FULL_DUPLEXf_SET
#define MII_CTRLr_COLL_TEST_ENf_GET BCM5464_MII_CTRLr_COLL_TEST_ENf_GET
#define MII_CTRLr_COLL_TEST_ENf_SET BCM5464_MII_CTRLr_COLL_TEST_ENf_SET
#define MII_CTRLr_SPEED_SEL1f_GET BCM5464_MII_CTRLr_SPEED_SEL1f_GET
#define MII_CTRLr_SPEED_SEL1f_SET BCM5464_MII_CTRLr_SPEED_SEL1f_SET
#define READ_MII_CTRLr BCM5464_READ_MII_CTRLr
#define WRITE_MII_CTRLr BCM5464_WRITE_MII_CTRLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM5464_MII_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM5464
 * REGISTER:  MII_STAT
 * BLOCKS:   IEEE
 * REGADDR:  0x0001
 * DESC:     1000BASE-T/100BASE-TX/10BASE-T MII Status Register (Addr 01h)
 * SIZE:     32
 * FIELDS:
 *     EXT_CAPABILITY   Extended register capabilities.
 *     JABBER_DETECT    Jabber condition detected.
 *     LINK             Link is up.
 *     AUTONEG_ABILITY  Auto-negotiation capable.
 *     REMOTE_FAULT     Remote fault detected.
 *     AUTONEG_DONE     Auto-negotiation complete.
 *     MF_PREAMBLE_SUP  Preamble can be suppressed.
 *     EXT_STATUS       Extended status information in register 0Fh.
 *     CAP_100BASE_T2_HD 100BASE-T2 half-duplex capable.
 *     CAP_100BASE_T2_FD 100BASE-T2 full-duplex capable.
 *     CAP_10BASE_T_HD  10BASE-T half-duplex capable.
 *     CAP_10BASE_T_FD  10BASE-T full-duplex capable.
 *     CAP_100BASE_X_HD 100BASE-X half-duplex capable.
 *     CAP_100BASE_X_FD 100BASE-X full-duplex capable.
 *     CAP_100BASE_T4   100BASE-T4 capable.
 *
 ******************************************************************************/
#define BCM5464_MII_STATr (0x00000001 | PHY_REG_ACC_RAW)

#define BCM5464_MII_STATr_SIZE 4

/*
 * This structure should be used to declare and program MII_STAT.
 *
 */
typedef union BCM5464_MII_STATr_s {
	uint32_t v[1];
	uint32_t mii_stat[1];
	uint32_t _mii_stat;
} BCM5464_MII_STATr_t;

#define BCM5464_MII_STATr_CLR(r) (r).mii_stat[0] = 0
#define BCM5464_MII_STATr_SET(r,d) (r).mii_stat[0] = d
#define BCM5464_MII_STATr_GET(r) (r).mii_stat[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM5464_MII_STATr_CAP_100BASE_T4f_GET(r) ((((r).mii_stat[0]) >> 15) & 0x1)
#define BCM5464_MII_STATr_CAP_100BASE_T4f_SET(r,f) (r).mii_stat[0]=(((r).mii_stat[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM5464_MII_STATr_CAP_100BASE_X_FDf_GET(r) ((((r).mii_stat[0]) >> 14) & 0x1)
#define BCM5464_MII_STATr_CAP_100BASE_X_FDf_SET(r,f) (r).mii_stat[0]=(((r).mii_stat[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM5464_MII_STATr_CAP_100BASE_X_HDf_GET(r) ((((r).mii_stat[0]) >> 13) & 0x1)
#define BCM5464_MII_STATr_CAP_100BASE_X_HDf_SET(r,f) (r).mii_stat[0]=(((r).mii_stat[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM5464_MII_STATr_CAP_10BASE_T_FDf_GET(r) ((((r).mii_stat[0]) >> 12) & 0x1)
#define BCM5464_MII_STATr_CAP_10BASE_T_FDf_SET(r,f) (r).mii_stat[0]=(((r).mii_stat[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM5464_MII_STATr_CAP_10BASE_T_HDf_GET(r) ((((r).mii_stat[0]) >> 11) & 0x1)
#define BCM5464_MII_STATr_CAP_10BASE_T_HDf_SET(r,f) (r).mii_stat[0]=(((r).mii_stat[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM5464_MII_STATr_CAP_100BASE_T2_FDf_GET(r) ((((r).mii_stat[0]) >> 10) & 0x1)
#define BCM5464_MII_STATr_CAP_100BASE_T2_FDf_SET(r,f) (r).mii_stat[0]=(((r).mii_stat[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM5464_MII_STATr_CAP_100BASE_T2_HDf_GET(r) ((((r).mii_stat[0]) >> 9) & 0x1)
#define BCM5464_MII_STATr_CAP_100BASE_T2_HDf_SET(r,f) (r).mii_stat[0]=(((r).mii_stat[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM5464_MII_STATr_EXT_STATUSf_GET(r) ((((r).mii_stat[0]) >> 8) & 0x1)
#define BCM5464_MII_STATr_EXT_STATUSf_SET(r,f) (r).mii_stat[0]=(((r).mii_stat[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM5464_MII_STATr_MF_PREAMBLE_SUPf_GET(r) ((((r).mii_stat[0]) >> 6) & 0x1)
#define BCM5464_MII_STATr_MF_PREAMBLE_SUPf_SET(r,f) (r).mii_stat[0]=(((r).mii_stat[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM5464_MII_STATr_AUTONEG_DONEf_GET(r) ((((r).mii_stat[0]) >> 5) & 0x1)
#define BCM5464_MII_STATr_AUTONEG_DONEf_SET(r,f) (r).mii_stat[0]=(((r).mii_stat[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM5464_MII_STATr_REMOTE_FAULTf_GET(r) ((((r).mii_stat[0]) >> 4) & 0x1)
#define BCM5464_MII_STATr_REMOTE_FAULTf_SET(r,f) (r).mii_stat[0]=(((r).mii_stat[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM5464_MII_STATr_AUTONEG_ABILITYf_GET(r) ((((r).mii_stat[0]) >> 3) & 0x1)
#define BCM5464_MII_STATr_AUTONEG_ABILITYf_SET(r,f) (r).mii_stat[0]=(((r).mii_stat[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM5464_MII_STATr_LINKf_GET(r) ((((r).mii_stat[0]) >> 2) & 0x1)
#define BCM5464_MII_STATr_LINKf_SET(r,f) (r).mii_stat[0]=(((r).mii_stat[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM5464_MII_STATr_JABBER_DETECTf_GET(r) ((((r).mii_stat[0]) >> 1) & 0x1)
#define BCM5464_MII_STATr_JABBER_DETECTf_SET(r,f) (r).mii_stat[0]=(((r).mii_stat[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM5464_MII_STATr_EXT_CAPABILITYf_GET(r) (((r).mii_stat[0]) & 0x1)
#define BCM5464_MII_STATr_EXT_CAPABILITYf_SET(r,f) (r).mii_stat[0]=(((r).mii_stat[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access MII_STAT.
 *
 */
#define BCM5464_READ_MII_STATr(_pc,_r) PHY_REG_READ(_pc,BCM5464_MII_STATr,_r._mii_stat)
#define BCM5464_WRITE_MII_STATr(_pc,_r) PHY_REG_WRITE(_pc,BCM5464_MII_STATr,_r._mii_stat)

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MII_STATr BCM5464_MII_STATr
#define MII_STATr_SIZE BCM5464_MII_STATr_SIZE
typedef BCM5464_MII_STATr_t MII_STATr_t;
#define MII_STATr_CLR BCM5464_MII_STATr_CLR
#define MII_STATr_SET BCM5464_MII_STATr_SET
#define MII_STATr_GET BCM5464_MII_STATr_GET
#define MII_STATr_CAP_100BASE_T4f_GET BCM5464_MII_STATr_CAP_100BASE_T4f_GET
#define MII_STATr_CAP_100BASE_T4f_SET BCM5464_MII_STATr_CAP_100BASE_T4f_SET
#define MII_STATr_CAP_100BASE_X_FDf_GET BCM5464_MII_STATr_CAP_100BASE_X_FDf_GET
#define MII_STATr_CAP_100BASE_X_FDf_SET BCM5464_MII_STATr_CAP_100BASE_X_FDf_SET
#define MII_STATr_CAP_100BASE_X_HDf_GET BCM5464_MII_STATr_CAP_100BASE_X_HDf_GET
#define MII_STATr_CAP_100BASE_X_HDf_SET BCM5464_MII_STATr_CAP_100BASE_X_HDf_SET
#define MII_STATr_CAP_10BASE_T_FDf_GET BCM5464_MII_STATr_CAP_10BASE_T_FDf_GET
#define MII_STATr_CAP_10BASE_T_FDf_SET BCM5464_MII_STATr_CAP_10BASE_T_FDf_SET
#define MII_STATr_CAP_10BASE_T_HDf_GET BCM5464_MII_STATr_CAP_10BASE_T_HDf_GET
#define MII_STATr_CAP_10BASE_T_HDf_SET BCM5464_MII_STATr_CAP_10BASE_T_HDf_SET
#define MII_STATr_CAP_100BASE_T2_FDf_GET BCM5464_MII_STATr_CAP_100BASE_T2_FDf_GET
#define MII_STATr_CAP_100BASE_T2_FDf_SET BCM5464_MII_STATr_CAP_100BASE_T2_FDf_SET
#define MII_STATr_CAP_100BASE_T2_HDf_GET BCM5464_MII_STATr_CAP_100BASE_T2_HDf_GET
#define MII_STATr_CAP_100BASE_T2_HDf_SET BCM5464_MII_STATr_CAP_100BASE_T2_HDf_SET
#define MII_STATr_EXT_STATUSf_GET BCM5464_MII_STATr_EXT_STATUSf_GET
#define MII_STATr_EXT_STATUSf_SET BCM5464_MII_STATr_EXT_STATUSf_SET
#define MII_STATr_MF_PREAMBLE_SUPf_GET BCM5464_MII_STATr_MF_PREAMBLE_SUPf_GET
#define MII_STATr_MF_PREAMBLE_SUPf_SET BCM5464_MII_STATr_MF_PREAMBLE_SUPf_SET
#define MII_STATr_AUTONEG_DONEf_GET BCM5464_MII_STATr_AUTONEG_DONEf_GET
#define MII_STATr_AUTONEG_DONEf_SET BCM5464_MII_STATr_AUTONEG_DONEf_SET
#define MII_STATr_REMOTE_FAULTf_GET BCM5464_MII_STATr_REMOTE_FAULTf_GET
#define MII_STATr_REMOTE_FAULTf_SET BCM5464_MII_STATr_REMOTE_FAULTf_SET
#define MII_STATr_AUTONEG_ABILITYf_GET BCM5464_MII_STATr_AUTONEG_ABILITYf_GET
#define MII_STATr_AUTONEG_ABILITYf_SET BCM5464_MII_STATr_AUTONEG_ABILITYf_SET
#define MII_STATr_LINKf_GET BCM5464_MII_STATr_LINKf_GET
#define MII_STATr_LINKf_SET BCM5464_MII_STATr_LINKf_SET
#define MII_STATr_JABBER_DETECTf_GET BCM5464_MII_STATr_JABBER_DETECTf_GET
#define MII_STATr_JABBER_DETECTf_SET BCM5464_MII_STATr_JABBER_DETECTf_SET
#define MII_STATr_EXT_CAPABILITYf_GET BCM5464_MII_STATr_EXT_CAPABILITYf_GET
#define MII_STATr_EXT_CAPABILITYf_SET BCM5464_MII_STATr_EXT_CAPABILITYf_SET
#define READ_MII_STATr BCM5464_READ_MII_STATr
#define WRITE_MII_STATr BCM5464_WRITE_MII_STATr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM5464_MII_STATr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM5464
 * REGISTER:  MII_PHY_ID0
 * BLOCKS:   IEEE
 * REGADDR:  0x0002
 * DESC:     1000BASE-T/100BASE-TX/10BASE-T PHY Identifier Register (Addr 02h)
 * SIZE:     32
 * FIELDS:
 *     REGID            16 MSBs of PHY identifier.
 *
 ******************************************************************************/
#define BCM5464_MII_PHY_ID0r (0x00000002 | PHY_REG_ACC_RAW)

#define BCM5464_MII_PHY_ID0r_SIZE 4

/*
 * This structure should be used to declare and program MII_PHY_ID0.
 *
 */
typedef union BCM5464_MII_PHY_ID0r_s {
	uint32_t v[1];
	uint32_t mii_phy_id0[1];
	uint32_t _mii_phy_id0;
} BCM5464_MII_PHY_ID0r_t;

#define BCM5464_MII_PHY_ID0r_CLR(r) (r).mii_phy_id0[0] = 0
#define BCM5464_MII_PHY_ID0r_SET(r,d) (r).mii_phy_id0[0] = d
#define BCM5464_MII_PHY_ID0r_GET(r) (r).mii_phy_id0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM5464_MII_PHY_ID0r_REGIDf_GET(r) (((r).mii_phy_id0[0]) & 0xffff)
#define BCM5464_MII_PHY_ID0r_REGIDf_SET(r,f) (r).mii_phy_id0[0]=(((r).mii_phy_id0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access MII_PHY_ID0.
 *
 */
#define BCM5464_READ_MII_PHY_ID0r(_pc,_r) PHY_REG_READ(_pc,BCM5464_MII_PHY_ID0r,_r._mii_phy_id0)
#define BCM5464_WRITE_MII_PHY_ID0r(_pc,_r) PHY_REG_WRITE(_pc,BCM5464_MII_PHY_ID0r,_r._mii_phy_id0)

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MII_PHY_ID0r BCM5464_MII_PHY_ID0r
#define MII_PHY_ID0r_SIZE BCM5464_MII_PHY_ID0r_SIZE
typedef BCM5464_MII_PHY_ID0r_t MII_PHY_ID0r_t;
#define MII_PHY_ID0r_CLR BCM5464_MII_PHY_ID0r_CLR
#define MII_PHY_ID0r_SET BCM5464_MII_PHY_ID0r_SET
#define MII_PHY_ID0r_GET BCM5464_MII_PHY_ID0r_GET
#define MII_PHY_ID0r_REGIDf_GET BCM5464_MII_PHY_ID0r_REGIDf_GET
#define MII_PHY_ID0r_REGIDf_SET BCM5464_MII_PHY_ID0r_REGIDf_SET
#define READ_MII_PHY_ID0r BCM5464_READ_MII_PHY_ID0r
#define WRITE_MII_PHY_ID0r BCM5464_WRITE_MII_PHY_ID0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM5464_MII_PHY_ID0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM5464
 * REGISTER:  MII_PHY_ID1
 * BLOCKS:   IEEE
 * REGADDR:  0x0003
 * DESC:     1000BASE-T/100BASE-TX/10BASE-T PHY Identifier Register (Addr 03h)
 * SIZE:     32
 * FIELDS:
 *     REGID            16 LSBs of PHY identifier.
 *
 ******************************************************************************/
#define BCM5464_MII_PHY_ID1r (0x00000003 | PHY_REG_ACC_RAW)

#define BCM5464_MII_PHY_ID1r_SIZE 4

/*
 * This structure should be used to declare and program MII_PHY_ID1.
 *
 */
typedef union BCM5464_MII_PHY_ID1r_s {
	uint32_t v[1];
	uint32_t mii_phy_id1[1];
	uint32_t _mii_phy_id1;
} BCM5464_MII_PHY_ID1r_t;

#define BCM5464_MII_PHY_ID1r_CLR(r) (r).mii_phy_id1[0] = 0
#define BCM5464_MII_PHY_ID1r_SET(r,d) (r).mii_phy_id1[0] = d
#define BCM5464_MII_PHY_ID1r_GET(r) (r).mii_phy_id1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM5464_MII_PHY_ID1r_REGIDf_GET(r) (((r).mii_phy_id1[0]) & 0xffff)
#define BCM5464_MII_PHY_ID1r_REGIDf_SET(r,f) (r).mii_phy_id1[0]=(((r).mii_phy_id1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access MII_PHY_ID1.
 *
 */
#define BCM5464_READ_MII_PHY_ID1r(_pc,_r) PHY_REG_READ(_pc,BCM5464_MII_PHY_ID1r,_r._mii_phy_id1)
#define BCM5464_WRITE_MII_PHY_ID1r(_pc,_r) PHY_REG_WRITE(_pc,BCM5464_MII_PHY_ID1r,_r._mii_phy_id1)

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MII_PHY_ID1r BCM5464_MII_PHY_ID1r
#define MII_PHY_ID1r_SIZE BCM5464_MII_PHY_ID1r_SIZE
typedef BCM5464_MII_PHY_ID1r_t MII_PHY_ID1r_t;
#define MII_PHY_ID1r_CLR BCM5464_MII_PHY_ID1r_CLR
#define MII_PHY_ID1r_SET BCM5464_MII_PHY_ID1r_SET
#define MII_PHY_ID1r_GET BCM5464_MII_PHY_ID1r_GET
#define MII_PHY_ID1r_REGIDf_GET BCM5464_MII_PHY_ID1r_REGIDf_GET
#define MII_PHY_ID1r_REGIDf_SET BCM5464_MII_PHY_ID1r_REGIDf_SET
#define READ_MII_PHY_ID1r BCM5464_READ_MII_PHY_ID1r
#define WRITE_MII_PHY_ID1r BCM5464_WRITE_MII_PHY_ID1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM5464_MII_PHY_ID1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM5464
 * REGISTER:  MII_ANA
 * BLOCKS:   IEEE
 * REGADDR:  0x0004
 * DESC:     1000BASE-T/100BASE-TX/10BASE-T Auto-Negotiation Advertisment Register (Addr 04h)
 * SIZE:     32
 * FIELDS:
 *     PROTOCOL         Advertise protocol selector field.
 *     CAP_10BASE_T_HD  10BASE-T half-duplex capable.
 *     CAP_10BASE_T_FD  10BASE-T full-duplex capable.
 *     CAP_100BASE_TX_HD 100BASE-TX half-duplex capable.
 *     CAP_100BASE_TX_FD 100BASE-TX full-duplex capable.
 *     CAP_100BASE_T4   100BASE-T4 capable.
 *     PAUSE            Pause capable.
 *     ASYM_PAUSE       Advertise asymmetric pause.
 *     REMOTE_FAULT     Advertise remote fault detected.
 *     NEXT_PAGE        Next Page ability supported.
 *
 ******************************************************************************/
#define BCM5464_MII_ANAr (0x00000004 | PHY_REG_ACC_RAW)

#define BCM5464_MII_ANAr_SIZE 4

/*
 * This structure should be used to declare and program MII_ANA.
 *
 */
typedef union BCM5464_MII_ANAr_s {
	uint32_t v[1];
	uint32_t mii_ana[1];
	uint32_t _mii_ana;
} BCM5464_MII_ANAr_t;

#define BCM5464_MII_ANAr_CLR(r) (r).mii_ana[0] = 0
#define BCM5464_MII_ANAr_SET(r,d) (r).mii_ana[0] = d
#define BCM5464_MII_ANAr_GET(r) (r).mii_ana[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM5464_MII_ANAr_NEXT_PAGEf_GET(r) ((((r).mii_ana[0]) >> 15) & 0x1)
#define BCM5464_MII_ANAr_NEXT_PAGEf_SET(r,f) (r).mii_ana[0]=(((r).mii_ana[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM5464_MII_ANAr_REMOTE_FAULTf_GET(r) ((((r).mii_ana[0]) >> 13) & 0x1)
#define BCM5464_MII_ANAr_REMOTE_FAULTf_SET(r,f) (r).mii_ana[0]=(((r).mii_ana[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM5464_MII_ANAr_ASYM_PAUSEf_GET(r) ((((r).mii_ana[0]) >> 11) & 0x1)
#define BCM5464_MII_ANAr_ASYM_PAUSEf_SET(r,f) (r).mii_ana[0]=(((r).mii_ana[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM5464_MII_ANAr_PAUSEf_GET(r) ((((r).mii_ana[0]) >> 10) & 0x1)
#define BCM5464_MII_ANAr_PAUSEf_SET(r,f) (r).mii_ana[0]=(((r).mii_ana[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM5464_MII_ANAr_CAP_100BASE_T4f_GET(r) ((((r).mii_ana[0]) >> 9) & 0x1)
#define BCM5464_MII_ANAr_CAP_100BASE_T4f_SET(r,f) (r).mii_ana[0]=(((r).mii_ana[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM5464_MII_ANAr_CAP_100BASE_TX_FDf_GET(r) ((((r).mii_ana[0]) >> 8) & 0x1)
#define BCM5464_MII_ANAr_CAP_100BASE_TX_FDf_SET(r,f) (r).mii_ana[0]=(((r).mii_ana[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM5464_MII_ANAr_CAP_100BASE_TX_HDf_GET(r) ((((r).mii_ana[0]) >> 7) & 0x1)
#define BCM5464_MII_ANAr_CAP_100BASE_TX_HDf_SET(r,f) (r).mii_ana[0]=(((r).mii_ana[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM5464_MII_ANAr_CAP_10BASE_T_FDf_GET(r) ((((r).mii_ana[0]) >> 6) & 0x1)
#define BCM5464_MII_ANAr_CAP_10BASE_T_FDf_SET(r,f) (r).mii_ana[0]=(((r).mii_ana[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM5464_MII_ANAr_CAP_10BASE_T_HDf_GET(r) ((((r).mii_ana[0]) >> 5) & 0x1)
#define BCM5464_MII_ANAr_CAP_10BASE_T_HDf_SET(r,f) (r).mii_ana[0]=(((r).mii_ana[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM5464_MII_ANAr_PROTOCOLf_GET(r) (((r).mii_ana[0]) & 0x1f)
#define BCM5464_MII_ANAr_PROTOCOLf_SET(r,f) (r).mii_ana[0]=(((r).mii_ana[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))

/*
 * These macros can be used to access MII_ANA.
 *
 */
#define BCM5464_READ_MII_ANAr(_pc,_r) PHY_REG_READ(_pc,BCM5464_MII_ANAr,_r._mii_ana)
#define BCM5464_WRITE_MII_ANAr(_pc,_r) PHY_REG_WRITE(_pc,BCM5464_MII_ANAr,_r._mii_ana)

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MII_ANAr BCM5464_MII_ANAr
#define MII_ANAr_SIZE BCM5464_MII_ANAr_SIZE
typedef BCM5464_MII_ANAr_t MII_ANAr_t;
#define MII_ANAr_CLR BCM5464_MII_ANAr_CLR
#define MII_ANAr_SET BCM5464_MII_ANAr_SET
#define MII_ANAr_GET BCM5464_MII_ANAr_GET
#define MII_ANAr_NEXT_PAGEf_GET BCM5464_MII_ANAr_NEXT_PAGEf_GET
#define MII_ANAr_NEXT_PAGEf_SET BCM5464_MII_ANAr_NEXT_PAGEf_SET
#define MII_ANAr_REMOTE_FAULTf_GET BCM5464_MII_ANAr_REMOTE_FAULTf_GET
#define MII_ANAr_REMOTE_FAULTf_SET BCM5464_MII_ANAr_REMOTE_FAULTf_SET
#define MII_ANAr_ASYM_PAUSEf_GET BCM5464_MII_ANAr_ASYM_PAUSEf_GET
#define MII_ANAr_ASYM_PAUSEf_SET BCM5464_MII_ANAr_ASYM_PAUSEf_SET
#define MII_ANAr_PAUSEf_GET BCM5464_MII_ANAr_PAUSEf_GET
#define MII_ANAr_PAUSEf_SET BCM5464_MII_ANAr_PAUSEf_SET
#define MII_ANAr_CAP_100BASE_T4f_GET BCM5464_MII_ANAr_CAP_100BASE_T4f_GET
#define MII_ANAr_CAP_100BASE_T4f_SET BCM5464_MII_ANAr_CAP_100BASE_T4f_SET
#define MII_ANAr_CAP_100BASE_TX_FDf_GET BCM5464_MII_ANAr_CAP_100BASE_TX_FDf_GET
#define MII_ANAr_CAP_100BASE_TX_FDf_SET BCM5464_MII_ANAr_CAP_100BASE_TX_FDf_SET
#define MII_ANAr_CAP_100BASE_TX_HDf_GET BCM5464_MII_ANAr_CAP_100BASE_TX_HDf_GET
#define MII_ANAr_CAP_100BASE_TX_HDf_SET BCM5464_MII_ANAr_CAP_100BASE_TX_HDf_SET
#define MII_ANAr_CAP_10BASE_T_FDf_GET BCM5464_MII_ANAr_CAP_10BASE_T_FDf_GET
#define MII_ANAr_CAP_10BASE_T_FDf_SET BCM5464_MII_ANAr_CAP_10BASE_T_FDf_SET
#define MII_ANAr_CAP_10BASE_T_HDf_GET BCM5464_MII_ANAr_CAP_10BASE_T_HDf_GET
#define MII_ANAr_CAP_10BASE_T_HDf_SET BCM5464_MII_ANAr_CAP_10BASE_T_HDf_SET
#define MII_ANAr_PROTOCOLf_GET BCM5464_MII_ANAr_PROTOCOLf_GET
#define MII_ANAr_PROTOCOLf_SET BCM5464_MII_ANAr_PROTOCOLf_SET
#define READ_MII_ANAr BCM5464_READ_MII_ANAr
#define WRITE_MII_ANAr BCM5464_WRITE_MII_ANAr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM5464_MII_ANAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM5464
 * REGISTER:  MII_ANP
 * BLOCKS:   IEEE
 * REGADDR:  0x0005
 * DESC:     1000BASE-T/100BASE-TX/10BASE-T Auto-Negotiation Link Partner Ability (Addr 05h)
 * SIZE:     32
 * FIELDS:
 *     PROTOCOL         Link partner is protocol selector field.
 *     CAP_10BASE_T_HD  Link partner is 10BASE-T half-duplex capable.
 *     CAP_10BASE_T_FD  Link partner is 10BASE-T full-duplex capable.
 *     CAP_100BASE_TX_HD Link partner is 100BASE-TX half-duplex capable.
 *     CAP_100BASE_TX_FD Link partner is 100BASE-TX full-duplex capable.
 *     CAP_100BASE_T4   Link partner is 100BASE-T4 capable.
 *     PAUSE            Link partner is capable of pause operation.
 *     ASYM_PAUSE       Link partner wants asymmetric pause.
 *     REMOTE_FAULT     Link partner has detected remote fault.
 *     ACK              Link partner has received link code word.
 *     NEXT_PAGE        Link partner has Next Page ability.
 *
 ******************************************************************************/
#define BCM5464_MII_ANPr (0x00000005 | PHY_REG_ACC_RAW)

#define BCM5464_MII_ANPr_SIZE 4

/*
 * This structure should be used to declare and program MII_ANP.
 *
 */
typedef union BCM5464_MII_ANPr_s {
	uint32_t v[1];
	uint32_t mii_anp[1];
	uint32_t _mii_anp;
} BCM5464_MII_ANPr_t;

#define BCM5464_MII_ANPr_CLR(r) (r).mii_anp[0] = 0
#define BCM5464_MII_ANPr_SET(r,d) (r).mii_anp[0] = d
#define BCM5464_MII_ANPr_GET(r) (r).mii_anp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM5464_MII_ANPr_NEXT_PAGEf_GET(r) ((((r).mii_anp[0]) >> 15) & 0x1)
#define BCM5464_MII_ANPr_NEXT_PAGEf_SET(r,f) (r).mii_anp[0]=(((r).mii_anp[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM5464_MII_ANPr_ACKf_GET(r) ((((r).mii_anp[0]) >> 14) & 0x1)
#define BCM5464_MII_ANPr_ACKf_SET(r,f) (r).mii_anp[0]=(((r).mii_anp[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM5464_MII_ANPr_REMOTE_FAULTf_GET(r) ((((r).mii_anp[0]) >> 13) & 0x1)
#define BCM5464_MII_ANPr_REMOTE_FAULTf_SET(r,f) (r).mii_anp[0]=(((r).mii_anp[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM5464_MII_ANPr_ASYM_PAUSEf_GET(r) ((((r).mii_anp[0]) >> 11) & 0x1)
#define BCM5464_MII_ANPr_ASYM_PAUSEf_SET(r,f) (r).mii_anp[0]=(((r).mii_anp[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM5464_MII_ANPr_PAUSEf_GET(r) ((((r).mii_anp[0]) >> 10) & 0x1)
#define BCM5464_MII_ANPr_PAUSEf_SET(r,f) (r).mii_anp[0]=(((r).mii_anp[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM5464_MII_ANPr_CAP_100BASE_T4f_GET(r) ((((r).mii_anp[0]) >> 9) & 0x1)
#define BCM5464_MII_ANPr_CAP_100BASE_T4f_SET(r,f) (r).mii_anp[0]=(((r).mii_anp[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM5464_MII_ANPr_CAP_100BASE_TX_FDf_GET(r) ((((r).mii_anp[0]) >> 8) & 0x1)
#define BCM5464_MII_ANPr_CAP_100BASE_TX_FDf_SET(r,f) (r).mii_anp[0]=(((r).mii_anp[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM5464_MII_ANPr_CAP_100BASE_TX_HDf_GET(r) ((((r).mii_anp[0]) >> 7) & 0x1)
#define BCM5464_MII_ANPr_CAP_100BASE_TX_HDf_SET(r,f) (r).mii_anp[0]=(((r).mii_anp[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM5464_MII_ANPr_CAP_10BASE_T_FDf_GET(r) ((((r).mii_anp[0]) >> 6) & 0x1)
#define BCM5464_MII_ANPr_CAP_10BASE_T_FDf_SET(r,f) (r).mii_anp[0]=(((r).mii_anp[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM5464_MII_ANPr_CAP_10BASE_T_HDf_GET(r) ((((r).mii_anp[0]) >> 5) & 0x1)
#define BCM5464_MII_ANPr_CAP_10BASE_T_HDf_SET(r,f) (r).mii_anp[0]=(((r).mii_anp[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM5464_MII_ANPr_PROTOCOLf_GET(r) (((r).mii_anp[0]) & 0x1f)
#define BCM5464_MII_ANPr_PROTOCOLf_SET(r,f) (r).mii_anp[0]=(((r).mii_anp[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))

/*
 * These macros can be used to access MII_ANP.
 *
 */
#define BCM5464_READ_MII_ANPr(_pc,_r) PHY_REG_READ(_pc,BCM5464_MII_ANPr,_r._mii_anp)
#define BCM5464_WRITE_MII_ANPr(_pc,_r) PHY_REG_WRITE(_pc,BCM5464_MII_ANPr,_r._mii_anp)

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MII_ANPr BCM5464_MII_ANPr
#define MII_ANPr_SIZE BCM5464_MII_ANPr_SIZE
typedef BCM5464_MII_ANPr_t MII_ANPr_t;
#define MII_ANPr_CLR BCM5464_MII_ANPr_CLR
#define MII_ANPr_SET BCM5464_MII_ANPr_SET
#define MII_ANPr_GET BCM5464_MII_ANPr_GET
#define MII_ANPr_NEXT_PAGEf_GET BCM5464_MII_ANPr_NEXT_PAGEf_GET
#define MII_ANPr_NEXT_PAGEf_SET BCM5464_MII_ANPr_NEXT_PAGEf_SET
#define MII_ANPr_ACKf_GET BCM5464_MII_ANPr_ACKf_GET
#define MII_ANPr_ACKf_SET BCM5464_MII_ANPr_ACKf_SET
#define MII_ANPr_REMOTE_FAULTf_GET BCM5464_MII_ANPr_REMOTE_FAULTf_GET
#define MII_ANPr_REMOTE_FAULTf_SET BCM5464_MII_ANPr_REMOTE_FAULTf_SET
#define MII_ANPr_ASYM_PAUSEf_GET BCM5464_MII_ANPr_ASYM_PAUSEf_GET
#define MII_ANPr_ASYM_PAUSEf_SET BCM5464_MII_ANPr_ASYM_PAUSEf_SET
#define MII_ANPr_PAUSEf_GET BCM5464_MII_ANPr_PAUSEf_GET
#define MII_ANPr_PAUSEf_SET BCM5464_MII_ANPr_PAUSEf_SET
#define MII_ANPr_CAP_100BASE_T4f_GET BCM5464_MII_ANPr_CAP_100BASE_T4f_GET
#define MII_ANPr_CAP_100BASE_T4f_SET BCM5464_MII_ANPr_CAP_100BASE_T4f_SET
#define MII_ANPr_CAP_100BASE_TX_FDf_GET BCM5464_MII_ANPr_CAP_100BASE_TX_FDf_GET
#define MII_ANPr_CAP_100BASE_TX_FDf_SET BCM5464_MII_ANPr_CAP_100BASE_TX_FDf_SET
#define MII_ANPr_CAP_100BASE_TX_HDf_GET BCM5464_MII_ANPr_CAP_100BASE_TX_HDf_GET
#define MII_ANPr_CAP_100BASE_TX_HDf_SET BCM5464_MII_ANPr_CAP_100BASE_TX_HDf_SET
#define MII_ANPr_CAP_10BASE_T_FDf_GET BCM5464_MII_ANPr_CAP_10BASE_T_FDf_GET
#define MII_ANPr_CAP_10BASE_T_FDf_SET BCM5464_MII_ANPr_CAP_10BASE_T_FDf_SET
#define MII_ANPr_CAP_10BASE_T_HDf_GET BCM5464_MII_ANPr_CAP_10BASE_T_HDf_GET
#define MII_ANPr_CAP_10BASE_T_HDf_SET BCM5464_MII_ANPr_CAP_10BASE_T_HDf_SET
#define MII_ANPr_PROTOCOLf_GET BCM5464_MII_ANPr_PROTOCOLf_GET
#define MII_ANPr_PROTOCOLf_SET BCM5464_MII_ANPr_PROTOCOLf_SET
#define READ_MII_ANPr BCM5464_READ_MII_ANPr
#define WRITE_MII_ANPr BCM5464_WRITE_MII_ANPr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM5464_MII_ANPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM5464
 * REGISTER:  MII_AN_EXP
 * BLOCKS:   IEEE
 * REGADDR:  0x0006
 * DESC:     1000BASE-T/100BASE-TX/10BASE-T Auto-Negotiation Expansion Register (Addr 06h)
 * SIZE:     32
 * FIELDS:
 *     LP_AN_ABIL       Link partner has auto-negotiation ability.
 *     PAGE_RECEIVED    New page has been receive from link partner.
 *     NEXT_PAGE        Local Next Page capability.
 *     LP_NEXT_PAGE     Link partner has Next Page capability.
 *     PARDET_FAULT     Parallel link fault detected.
 *
 ******************************************************************************/
#define BCM5464_MII_AN_EXPr (0x00000006 | PHY_REG_ACC_RAW)

#define BCM5464_MII_AN_EXPr_SIZE 4

/*
 * This structure should be used to declare and program MII_AN_EXP.
 *
 */
typedef union BCM5464_MII_AN_EXPr_s {
	uint32_t v[1];
	uint32_t mii_an_exp[1];
	uint32_t _mii_an_exp;
} BCM5464_MII_AN_EXPr_t;

#define BCM5464_MII_AN_EXPr_CLR(r) (r).mii_an_exp[0] = 0
#define BCM5464_MII_AN_EXPr_SET(r,d) (r).mii_an_exp[0] = d
#define BCM5464_MII_AN_EXPr_GET(r) (r).mii_an_exp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM5464_MII_AN_EXPr_PARDET_FAULTf_GET(r) ((((r).mii_an_exp[0]) >> 4) & 0x1)
#define BCM5464_MII_AN_EXPr_PARDET_FAULTf_SET(r,f) (r).mii_an_exp[0]=(((r).mii_an_exp[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM5464_MII_AN_EXPr_LP_NEXT_PAGEf_GET(r) ((((r).mii_an_exp[0]) >> 3) & 0x1)
#define BCM5464_MII_AN_EXPr_LP_NEXT_PAGEf_SET(r,f) (r).mii_an_exp[0]=(((r).mii_an_exp[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM5464_MII_AN_EXPr_NEXT_PAGEf_GET(r) ((((r).mii_an_exp[0]) >> 2) & 0x1)
#define BCM5464_MII_AN_EXPr_NEXT_PAGEf_SET(r,f) (r).mii_an_exp[0]=(((r).mii_an_exp[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM5464_MII_AN_EXPr_PAGE_RECEIVEDf_GET(r) ((((r).mii_an_exp[0]) >> 1) & 0x1)
#define BCM5464_MII_AN_EXPr_PAGE_RECEIVEDf_SET(r,f) (r).mii_an_exp[0]=(((r).mii_an_exp[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM5464_MII_AN_EXPr_LP_AN_ABILf_GET(r) (((r).mii_an_exp[0]) & 0x1)
#define BCM5464_MII_AN_EXPr_LP_AN_ABILf_SET(r,f) (r).mii_an_exp[0]=(((r).mii_an_exp[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access MII_AN_EXP.
 *
 */
#define BCM5464_READ_MII_AN_EXPr(_pc,_r) PHY_REG_READ(_pc,BCM5464_MII_AN_EXPr,_r._mii_an_exp)
#define BCM5464_WRITE_MII_AN_EXPr(_pc,_r) PHY_REG_WRITE(_pc,BCM5464_MII_AN_EXPr,_r._mii_an_exp)

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MII_AN_EXPr BCM5464_MII_AN_EXPr
#define MII_AN_EXPr_SIZE BCM5464_MII_AN_EXPr_SIZE
typedef BCM5464_MII_AN_EXPr_t MII_AN_EXPr_t;
#define MII_AN_EXPr_CLR BCM5464_MII_AN_EXPr_CLR
#define MII_AN_EXPr_SET BCM5464_MII_AN_EXPr_SET
#define MII_AN_EXPr_GET BCM5464_MII_AN_EXPr_GET
#define MII_AN_EXPr_PARDET_FAULTf_GET BCM5464_MII_AN_EXPr_PARDET_FAULTf_GET
#define MII_AN_EXPr_PARDET_FAULTf_SET BCM5464_MII_AN_EXPr_PARDET_FAULTf_SET
#define MII_AN_EXPr_LP_NEXT_PAGEf_GET BCM5464_MII_AN_EXPr_LP_NEXT_PAGEf_GET
#define MII_AN_EXPr_LP_NEXT_PAGEf_SET BCM5464_MII_AN_EXPr_LP_NEXT_PAGEf_SET
#define MII_AN_EXPr_NEXT_PAGEf_GET BCM5464_MII_AN_EXPr_NEXT_PAGEf_GET
#define MII_AN_EXPr_NEXT_PAGEf_SET BCM5464_MII_AN_EXPr_NEXT_PAGEf_SET
#define MII_AN_EXPr_PAGE_RECEIVEDf_GET BCM5464_MII_AN_EXPr_PAGE_RECEIVEDf_GET
#define MII_AN_EXPr_PAGE_RECEIVEDf_SET BCM5464_MII_AN_EXPr_PAGE_RECEIVEDf_SET
#define MII_AN_EXPr_LP_AN_ABILf_GET BCM5464_MII_AN_EXPr_LP_AN_ABILf_GET
#define MII_AN_EXPr_LP_AN_ABILf_SET BCM5464_MII_AN_EXPr_LP_AN_ABILf_SET
#define READ_MII_AN_EXPr BCM5464_READ_MII_AN_EXPr
#define WRITE_MII_AN_EXPr BCM5464_WRITE_MII_AN_EXPr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM5464_MII_AN_EXPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM5464
 * REGISTER:  MII_GB_CTRL
 * BLOCKS:   IEEE
 * REGADDR:  0x0009
 * DESC:     1000BASE-T Control Register (Addr 09h)
 * SIZE:     32
 * FIELDS:
 *     CAP_1000BASE_T_HD Advertise 1000BASE-T half-duplex capability.
 *     CAP_1000BASE_T_FD Advertise 1000BASE-T full-duplex capability.
 *     SWITCH_DEV       Repeater/DTE device mode.
 *     MASTER           Configure PHY as master.
 *     MS_MAN           Enable manual master/slave configuration.
 *     TEST_MODE        Test mode.
 *
 ******************************************************************************/
#define BCM5464_MII_GB_CTRLr (0x00000009 | PHY_REG_ACC_RAW)

#define BCM5464_MII_GB_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program MII_GB_CTRL.
 *
 */
typedef union BCM5464_MII_GB_CTRLr_s {
	uint32_t v[1];
	uint32_t mii_gb_ctrl[1];
	uint32_t _mii_gb_ctrl;
} BCM5464_MII_GB_CTRLr_t;

#define BCM5464_MII_GB_CTRLr_CLR(r) (r).mii_gb_ctrl[0] = 0
#define BCM5464_MII_GB_CTRLr_SET(r,d) (r).mii_gb_ctrl[0] = d
#define BCM5464_MII_GB_CTRLr_GET(r) (r).mii_gb_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM5464_MII_GB_CTRLr_TEST_MODEf_GET(r) ((((r).mii_gb_ctrl[0]) >> 13) & 0x7)
#define BCM5464_MII_GB_CTRLr_TEST_MODEf_SET(r,f) (r).mii_gb_ctrl[0]=(((r).mii_gb_ctrl[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))
#define BCM5464_MII_GB_CTRLr_MS_MANf_GET(r) ((((r).mii_gb_ctrl[0]) >> 12) & 0x1)
#define BCM5464_MII_GB_CTRLr_MS_MANf_SET(r,f) (r).mii_gb_ctrl[0]=(((r).mii_gb_ctrl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM5464_MII_GB_CTRLr_MASTERf_GET(r) ((((r).mii_gb_ctrl[0]) >> 11) & 0x1)
#define BCM5464_MII_GB_CTRLr_MASTERf_SET(r,f) (r).mii_gb_ctrl[0]=(((r).mii_gb_ctrl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM5464_MII_GB_CTRLr_SWITCH_DEVf_GET(r) ((((r).mii_gb_ctrl[0]) >> 10) & 0x1)
#define BCM5464_MII_GB_CTRLr_SWITCH_DEVf_SET(r,f) (r).mii_gb_ctrl[0]=(((r).mii_gb_ctrl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM5464_MII_GB_CTRLr_CAP_1000BASE_T_FDf_GET(r) ((((r).mii_gb_ctrl[0]) >> 9) & 0x1)
#define BCM5464_MII_GB_CTRLr_CAP_1000BASE_T_FDf_SET(r,f) (r).mii_gb_ctrl[0]=(((r).mii_gb_ctrl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM5464_MII_GB_CTRLr_CAP_1000BASE_T_HDf_GET(r) ((((r).mii_gb_ctrl[0]) >> 8) & 0x1)
#define BCM5464_MII_GB_CTRLr_CAP_1000BASE_T_HDf_SET(r,f) (r).mii_gb_ctrl[0]=(((r).mii_gb_ctrl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))

/*
 * These macros can be used to access MII_GB_CTRL.
 *
 */
#define BCM5464_READ_MII_GB_CTRLr(_pc,_r) PHY_REG_READ(_pc,BCM5464_MII_GB_CTRLr,_r._mii_gb_ctrl)
#define BCM5464_WRITE_MII_GB_CTRLr(_pc,_r) PHY_REG_WRITE(_pc,BCM5464_MII_GB_CTRLr,_r._mii_gb_ctrl)

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MII_GB_CTRLr BCM5464_MII_GB_CTRLr
#define MII_GB_CTRLr_SIZE BCM5464_MII_GB_CTRLr_SIZE
typedef BCM5464_MII_GB_CTRLr_t MII_GB_CTRLr_t;
#define MII_GB_CTRLr_CLR BCM5464_MII_GB_CTRLr_CLR
#define MII_GB_CTRLr_SET BCM5464_MII_GB_CTRLr_SET
#define MII_GB_CTRLr_GET BCM5464_MII_GB_CTRLr_GET
#define MII_GB_CTRLr_TEST_MODEf_GET BCM5464_MII_GB_CTRLr_TEST_MODEf_GET
#define MII_GB_CTRLr_TEST_MODEf_SET BCM5464_MII_GB_CTRLr_TEST_MODEf_SET
#define MII_GB_CTRLr_MS_MANf_GET BCM5464_MII_GB_CTRLr_MS_MANf_GET
#define MII_GB_CTRLr_MS_MANf_SET BCM5464_MII_GB_CTRLr_MS_MANf_SET
#define MII_GB_CTRLr_MASTERf_GET BCM5464_MII_GB_CTRLr_MASTERf_GET
#define MII_GB_CTRLr_MASTERf_SET BCM5464_MII_GB_CTRLr_MASTERf_SET
#define MII_GB_CTRLr_SWITCH_DEVf_GET BCM5464_MII_GB_CTRLr_SWITCH_DEVf_GET
#define MII_GB_CTRLr_SWITCH_DEVf_SET BCM5464_MII_GB_CTRLr_SWITCH_DEVf_SET
#define MII_GB_CTRLr_CAP_1000BASE_T_FDf_GET BCM5464_MII_GB_CTRLr_CAP_1000BASE_T_FDf_GET
#define MII_GB_CTRLr_CAP_1000BASE_T_FDf_SET BCM5464_MII_GB_CTRLr_CAP_1000BASE_T_FDf_SET
#define MII_GB_CTRLr_CAP_1000BASE_T_HDf_GET BCM5464_MII_GB_CTRLr_CAP_1000BASE_T_HDf_GET
#define MII_GB_CTRLr_CAP_1000BASE_T_HDf_SET BCM5464_MII_GB_CTRLr_CAP_1000BASE_T_HDf_SET
#define READ_MII_GB_CTRLr BCM5464_READ_MII_GB_CTRLr
#define WRITE_MII_GB_CTRLr BCM5464_WRITE_MII_GB_CTRLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM5464_MII_GB_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM5464
 * REGISTER:  MII_GB_STAT
 * BLOCKS:   IEEE
 * REGADDR:  0x000a
 * DESC:     1000BASE-T Status Register (Addr 0Ah)
 * SIZE:     32
 * FIELDS:
 *     IDLE_ERRORS      Number of idle errors since last read.
 *     LP_1000BASE_T_HD Link partner is 1000BASE-T half-duplex capable.
 *     LP_1000BASE_T_FD Link partner is 1000BASE-T full-duplex capable.
 *     REMOTE_RCV_OK    Remote receiver OK.
 *     LOCAL_RCV_OK     Local receiver OK.
 *     LOCAL_MASTER     Local transmitter is master.
 *     MS_CFG_FAULT     Master/slave configuration fault detected.
 *
 ******************************************************************************/
#define BCM5464_MII_GB_STATr (0x0000000a | PHY_REG_ACC_RAW)

#define BCM5464_MII_GB_STATr_SIZE 4

/*
 * This structure should be used to declare and program MII_GB_STAT.
 *
 */
typedef union BCM5464_MII_GB_STATr_s {
	uint32_t v[1];
	uint32_t mii_gb_stat[1];
	uint32_t _mii_gb_stat;
} BCM5464_MII_GB_STATr_t;

#define BCM5464_MII_GB_STATr_CLR(r) (r).mii_gb_stat[0] = 0
#define BCM5464_MII_GB_STATr_SET(r,d) (r).mii_gb_stat[0] = d
#define BCM5464_MII_GB_STATr_GET(r) (r).mii_gb_stat[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM5464_MII_GB_STATr_MS_CFG_FAULTf_GET(r) ((((r).mii_gb_stat[0]) >> 15) & 0x1)
#define BCM5464_MII_GB_STATr_MS_CFG_FAULTf_SET(r,f) (r).mii_gb_stat[0]=(((r).mii_gb_stat[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM5464_MII_GB_STATr_LOCAL_MASTERf_GET(r) ((((r).mii_gb_stat[0]) >> 14) & 0x1)
#define BCM5464_MII_GB_STATr_LOCAL_MASTERf_SET(r,f) (r).mii_gb_stat[0]=(((r).mii_gb_stat[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM5464_MII_GB_STATr_LOCAL_RCV_OKf_GET(r) ((((r).mii_gb_stat[0]) >> 13) & 0x1)
#define BCM5464_MII_GB_STATr_LOCAL_RCV_OKf_SET(r,f) (r).mii_gb_stat[0]=(((r).mii_gb_stat[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM5464_MII_GB_STATr_REMOTE_RCV_OKf_GET(r) ((((r).mii_gb_stat[0]) >> 12) & 0x1)
#define BCM5464_MII_GB_STATr_REMOTE_RCV_OKf_SET(r,f) (r).mii_gb_stat[0]=(((r).mii_gb_stat[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM5464_MII_GB_STATr_LP_1000BASE_T_FDf_GET(r) ((((r).mii_gb_stat[0]) >> 11) & 0x1)
#define BCM5464_MII_GB_STATr_LP_1000BASE_T_FDf_SET(r,f) (r).mii_gb_stat[0]=(((r).mii_gb_stat[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM5464_MII_GB_STATr_LP_1000BASE_T_HDf_GET(r) ((((r).mii_gb_stat[0]) >> 10) & 0x1)
#define BCM5464_MII_GB_STATr_LP_1000BASE_T_HDf_SET(r,f) (r).mii_gb_stat[0]=(((r).mii_gb_stat[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM5464_MII_GB_STATr_IDLE_ERRORSf_GET(r) (((r).mii_gb_stat[0]) & 0xff)
#define BCM5464_MII_GB_STATr_IDLE_ERRORSf_SET(r,f) (r).mii_gb_stat[0]=(((r).mii_gb_stat[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access MII_GB_STAT.
 *
 */
#define BCM5464_READ_MII_GB_STATr(_pc,_r) PHY_REG_READ(_pc,BCM5464_MII_GB_STATr,_r._mii_gb_stat)
#define BCM5464_WRITE_MII_GB_STATr(_pc,_r) PHY_REG_WRITE(_pc,BCM5464_MII_GB_STATr,_r._mii_gb_stat)

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MII_GB_STATr BCM5464_MII_GB_STATr
#define MII_GB_STATr_SIZE BCM5464_MII_GB_STATr_SIZE
typedef BCM5464_MII_GB_STATr_t MII_GB_STATr_t;
#define MII_GB_STATr_CLR BCM5464_MII_GB_STATr_CLR
#define MII_GB_STATr_SET BCM5464_MII_GB_STATr_SET
#define MII_GB_STATr_GET BCM5464_MII_GB_STATr_GET
#define MII_GB_STATr_MS_CFG_FAULTf_GET BCM5464_MII_GB_STATr_MS_CFG_FAULTf_GET
#define MII_GB_STATr_MS_CFG_FAULTf_SET BCM5464_MII_GB_STATr_MS_CFG_FAULTf_SET
#define MII_GB_STATr_LOCAL_MASTERf_GET BCM5464_MII_GB_STATr_LOCAL_MASTERf_GET
#define MII_GB_STATr_LOCAL_MASTERf_SET BCM5464_MII_GB_STATr_LOCAL_MASTERf_SET
#define MII_GB_STATr_LOCAL_RCV_OKf_GET BCM5464_MII_GB_STATr_LOCAL_RCV_OKf_GET
#define MII_GB_STATr_LOCAL_RCV_OKf_SET BCM5464_MII_GB_STATr_LOCAL_RCV_OKf_SET
#define MII_GB_STATr_REMOTE_RCV_OKf_GET BCM5464_MII_GB_STATr_REMOTE_RCV_OKf_GET
#define MII_GB_STATr_REMOTE_RCV_OKf_SET BCM5464_MII_GB_STATr_REMOTE_RCV_OKf_SET
#define MII_GB_STATr_LP_1000BASE_T_FDf_GET BCM5464_MII_GB_STATr_LP_1000BASE_T_FDf_GET
#define MII_GB_STATr_LP_1000BASE_T_FDf_SET BCM5464_MII_GB_STATr_LP_1000BASE_T_FDf_SET
#define MII_GB_STATr_LP_1000BASE_T_HDf_GET BCM5464_MII_GB_STATr_LP_1000BASE_T_HDf_GET
#define MII_GB_STATr_LP_1000BASE_T_HDf_SET BCM5464_MII_GB_STATr_LP_1000BASE_T_HDf_SET
#define MII_GB_STATr_IDLE_ERRORSf_GET BCM5464_MII_GB_STATr_IDLE_ERRORSf_GET
#define MII_GB_STATr_IDLE_ERRORSf_SET BCM5464_MII_GB_STATr_IDLE_ERRORSf_SET
#define READ_MII_GB_STATr BCM5464_READ_MII_GB_STATr
#define WRITE_MII_GB_STATr BCM5464_WRITE_MII_GB_STATr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM5464_MII_GB_STATr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM5464
 * REGISTER:  MII_ESR
 * BLOCKS:   IEEE
 * REGADDR:  0x000f
 * DESC:     1000BASE-T/100BASE-TX/10BASE-T IEEE Extended Status Register (Addr 0Fh)
 * SIZE:     32
 * FIELDS:
 *     CAP_1000BASE_T_HD 1000BASE-T half-duplex capable.
 *     CAP_1000BASE_T_FD 1000BASE-T full-duplex capable.
 *     CAP_1000BASE_X_HD 1000BASE-X half-duplex capable.
 *     CAP_1000BASE_X_FD 1000BASE-X full-duplex capable.
 *
 ******************************************************************************/
#define BCM5464_MII_ESRr (0x0000000f | PHY_REG_ACC_RAW)

#define BCM5464_MII_ESRr_SIZE 4

/*
 * This structure should be used to declare and program MII_ESR.
 *
 */
typedef union BCM5464_MII_ESRr_s {
	uint32_t v[1];
	uint32_t mii_esr[1];
	uint32_t _mii_esr;
} BCM5464_MII_ESRr_t;

#define BCM5464_MII_ESRr_CLR(r) (r).mii_esr[0] = 0
#define BCM5464_MII_ESRr_SET(r,d) (r).mii_esr[0] = d
#define BCM5464_MII_ESRr_GET(r) (r).mii_esr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM5464_MII_ESRr_CAP_1000BASE_X_FDf_GET(r) ((((r).mii_esr[0]) >> 15) & 0x1)
#define BCM5464_MII_ESRr_CAP_1000BASE_X_FDf_SET(r,f) (r).mii_esr[0]=(((r).mii_esr[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM5464_MII_ESRr_CAP_1000BASE_X_HDf_GET(r) ((((r).mii_esr[0]) >> 14) & 0x1)
#define BCM5464_MII_ESRr_CAP_1000BASE_X_HDf_SET(r,f) (r).mii_esr[0]=(((r).mii_esr[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM5464_MII_ESRr_CAP_1000BASE_T_FDf_GET(r) ((((r).mii_esr[0]) >> 13) & 0x1)
#define BCM5464_MII_ESRr_CAP_1000BASE_T_FDf_SET(r,f) (r).mii_esr[0]=(((r).mii_esr[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM5464_MII_ESRr_CAP_1000BASE_T_HDf_GET(r) ((((r).mii_esr[0]) >> 12) & 0x1)
#define BCM5464_MII_ESRr_CAP_1000BASE_T_HDf_SET(r,f) (r).mii_esr[0]=(((r).mii_esr[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))

/*
 * These macros can be used to access MII_ESR.
 *
 */
#define BCM5464_READ_MII_ESRr(_pc,_r) PHY_REG_READ(_pc,BCM5464_MII_ESRr,_r._mii_esr)
#define BCM5464_WRITE_MII_ESRr(_pc,_r) PHY_REG_WRITE(_pc,BCM5464_MII_ESRr,_r._mii_esr)

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MII_ESRr BCM5464_MII_ESRr
#define MII_ESRr_SIZE BCM5464_MII_ESRr_SIZE
typedef BCM5464_MII_ESRr_t MII_ESRr_t;
#define MII_ESRr_CLR BCM5464_MII_ESRr_CLR
#define MII_ESRr_SET BCM5464_MII_ESRr_SET
#define MII_ESRr_GET BCM5464_MII_ESRr_GET
#define MII_ESRr_CAP_1000BASE_X_FDf_GET BCM5464_MII_ESRr_CAP_1000BASE_X_FDf_GET
#define MII_ESRr_CAP_1000BASE_X_FDf_SET BCM5464_MII_ESRr_CAP_1000BASE_X_FDf_SET
#define MII_ESRr_CAP_1000BASE_X_HDf_GET BCM5464_MII_ESRr_CAP_1000BASE_X_HDf_GET
#define MII_ESRr_CAP_1000BASE_X_HDf_SET BCM5464_MII_ESRr_CAP_1000BASE_X_HDf_SET
#define MII_ESRr_CAP_1000BASE_T_FDf_GET BCM5464_MII_ESRr_CAP_1000BASE_T_FDf_GET
#define MII_ESRr_CAP_1000BASE_T_FDf_SET BCM5464_MII_ESRr_CAP_1000BASE_T_FDf_SET
#define MII_ESRr_CAP_1000BASE_T_HDf_GET BCM5464_MII_ESRr_CAP_1000BASE_T_HDf_GET
#define MII_ESRr_CAP_1000BASE_T_HDf_SET BCM5464_MII_ESRr_CAP_1000BASE_T_HDf_SET
#define READ_MII_ESRr BCM5464_READ_MII_ESRr
#define WRITE_MII_ESRr BCM5464_WRITE_MII_ESRr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM5464_MII_ESRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM5464
 * REGISTER:  MII_PHY_ECR
 * BLOCKS:   USER
 * REGADDR:  0x0010
 * DESC:     1000BASE-T/100BASE-TX/10BASE-T PHY Extended Control Register (Addr 10h)
 * SIZE:     32
 * FIELDS:
 *     MII_PHY_ECR      MII_PHY_ECR
 *
 ******************************************************************************/
#define BCM5464_MII_PHY_ECRr (0x00000010 | PHY_REG_ACC_RAW)

#define BCM5464_MII_PHY_ECRr_SIZE 4

/*
 * This structure should be used to declare and program MII_PHY_ECR.
 *
 */
typedef union BCM5464_MII_PHY_ECRr_s {
	uint32_t v[1];
	uint32_t mii_phy_ecr[1];
	uint32_t _mii_phy_ecr;
} BCM5464_MII_PHY_ECRr_t;

#define BCM5464_MII_PHY_ECRr_CLR(r) (r).mii_phy_ecr[0] = 0
#define BCM5464_MII_PHY_ECRr_SET(r,d) (r).mii_phy_ecr[0] = d
#define BCM5464_MII_PHY_ECRr_GET(r) (r).mii_phy_ecr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM5464_MII_PHY_ECRr_MII_PHY_ECRf_GET(r) (((r).mii_phy_ecr[0]) & 0xffff)
#define BCM5464_MII_PHY_ECRr_MII_PHY_ECRf_SET(r,f) (r).mii_phy_ecr[0]=(((r).mii_phy_ecr[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access MII_PHY_ECR.
 *
 */
#define BCM5464_READ_MII_PHY_ECRr(_pc,_r) PHY_REG_READ(_pc,BCM5464_MII_PHY_ECRr,_r._mii_phy_ecr)
#define BCM5464_WRITE_MII_PHY_ECRr(_pc,_r) PHY_REG_WRITE(_pc,BCM5464_MII_PHY_ECRr,_r._mii_phy_ecr)

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MII_PHY_ECRr BCM5464_MII_PHY_ECRr
#define MII_PHY_ECRr_SIZE BCM5464_MII_PHY_ECRr_SIZE
typedef BCM5464_MII_PHY_ECRr_t MII_PHY_ECRr_t;
#define MII_PHY_ECRr_CLR BCM5464_MII_PHY_ECRr_CLR
#define MII_PHY_ECRr_SET BCM5464_MII_PHY_ECRr_SET
#define MII_PHY_ECRr_GET BCM5464_MII_PHY_ECRr_GET
#define MII_PHY_ECRr_MII_PHY_ECRf_GET BCM5464_MII_PHY_ECRr_MII_PHY_ECRf_GET
#define MII_PHY_ECRr_MII_PHY_ECRf_SET BCM5464_MII_PHY_ECRr_MII_PHY_ECRf_SET
#define READ_MII_PHY_ECRr BCM5464_READ_MII_PHY_ECRr
#define WRITE_MII_PHY_ECRr BCM5464_WRITE_MII_PHY_ECRr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM5464_MII_PHY_ECRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM5464
 * REGISTER:  MII_PHY_ESR
 * BLOCKS:   USER
 * REGADDR:  0x0011
 * DESC:     1000BASE-T/100BASE-TX/10BASE-T PHY Extended Status Register (Addr 11h)
 * SIZE:     32
 * FIELDS:
 *     MII_PHY_ESR      MII_PHY_ESR
 *
 ******************************************************************************/
#define BCM5464_MII_PHY_ESRr (0x00000011 | PHY_REG_ACC_RAW)

#define BCM5464_MII_PHY_ESRr_SIZE 4

/*
 * This structure should be used to declare and program MII_PHY_ESR.
 *
 */
typedef union BCM5464_MII_PHY_ESRr_s {
	uint32_t v[1];
	uint32_t mii_phy_esr[1];
	uint32_t _mii_phy_esr;
} BCM5464_MII_PHY_ESRr_t;

#define BCM5464_MII_PHY_ESRr_CLR(r) (r).mii_phy_esr[0] = 0
#define BCM5464_MII_PHY_ESRr_SET(r,d) (r).mii_phy_esr[0] = d
#define BCM5464_MII_PHY_ESRr_GET(r) (r).mii_phy_esr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM5464_MII_PHY_ESRr_MII_PHY_ESRf_GET(r) (((r).mii_phy_esr[0]) & 0xffff)
#define BCM5464_MII_PHY_ESRr_MII_PHY_ESRf_SET(r,f) (r).mii_phy_esr[0]=(((r).mii_phy_esr[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access MII_PHY_ESR.
 *
 */
#define BCM5464_READ_MII_PHY_ESRr(_pc,_r) PHY_REG_READ(_pc,BCM5464_MII_PHY_ESRr,_r._mii_phy_esr)
#define BCM5464_WRITE_MII_PHY_ESRr(_pc,_r) PHY_REG_WRITE(_pc,BCM5464_MII_PHY_ESRr,_r._mii_phy_esr)

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MII_PHY_ESRr BCM5464_MII_PHY_ESRr
#define MII_PHY_ESRr_SIZE BCM5464_MII_PHY_ESRr_SIZE
typedef BCM5464_MII_PHY_ESRr_t MII_PHY_ESRr_t;
#define MII_PHY_ESRr_CLR BCM5464_MII_PHY_ESRr_CLR
#define MII_PHY_ESRr_SET BCM5464_MII_PHY_ESRr_SET
#define MII_PHY_ESRr_GET BCM5464_MII_PHY_ESRr_GET
#define MII_PHY_ESRr_MII_PHY_ESRf_GET BCM5464_MII_PHY_ESRr_MII_PHY_ESRf_GET
#define MII_PHY_ESRr_MII_PHY_ESRf_SET BCM5464_MII_PHY_ESRr_MII_PHY_ESRf_SET
#define READ_MII_PHY_ESRr BCM5464_READ_MII_PHY_ESRr
#define WRITE_MII_PHY_ESRr BCM5464_WRITE_MII_PHY_ESRr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM5464_MII_PHY_ESRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM5464
 * REGISTER:  MII_AUX_CTRL
 * BLOCKS:   USER
 * REGADDR:  0x0018
 * DESC:     1000BASE-T/100BASE-TX/10BASE-T Auxiliary Control Reg (Addr 18h Shadow 000b)
 * SIZE:     32
 * FIELDS:
 *     MII_AUX_CTRL     MII_AUX_CTRL
 *
 ******************************************************************************/
#define BCM5464_MII_AUX_CTRLr (0x00000018 | PHY_REG_ACC_BRCM_SHADOW)

#define BCM5464_MII_AUX_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program MII_AUX_CTRL.
 *
 */
typedef union BCM5464_MII_AUX_CTRLr_s {
	uint32_t v[1];
	uint32_t mii_aux_ctrl[1];
	uint32_t _mii_aux_ctrl;
} BCM5464_MII_AUX_CTRLr_t;

#define BCM5464_MII_AUX_CTRLr_CLR(r) (r).mii_aux_ctrl[0] = 0
#define BCM5464_MII_AUX_CTRLr_SET(r,d) (r).mii_aux_ctrl[0] = d
#define BCM5464_MII_AUX_CTRLr_GET(r) (r).mii_aux_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM5464_MII_AUX_CTRLr_MII_AUX_CTRLf_GET(r) (((r).mii_aux_ctrl[0]) & 0xffff)
#define BCM5464_MII_AUX_CTRLr_MII_AUX_CTRLf_SET(r,f) (r).mii_aux_ctrl[0]=(((r).mii_aux_ctrl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access MII_AUX_CTRL.
 *
 */
#define BCM5464_READ_MII_AUX_CTRLr(_pc,_r) phy_brcm_shadow_read(_pc,BCM5464_MII_AUX_CTRLr,(_r._mii_aux_ctrl))
#define BCM5464_WRITE_MII_AUX_CTRLr(_pc,_r) phy_brcm_shadow_write(_pc,BCM5464_MII_AUX_CTRLr,(_r._mii_aux_ctrl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MII_AUX_CTRLr BCM5464_MII_AUX_CTRLr
#define MII_AUX_CTRLr_SIZE BCM5464_MII_AUX_CTRLr_SIZE
typedef BCM5464_MII_AUX_CTRLr_t MII_AUX_CTRLr_t;
#define MII_AUX_CTRLr_CLR BCM5464_MII_AUX_CTRLr_CLR
#define MII_AUX_CTRLr_SET BCM5464_MII_AUX_CTRLr_SET
#define MII_AUX_CTRLr_GET BCM5464_MII_AUX_CTRLr_GET
#define MII_AUX_CTRLr_MII_AUX_CTRLf_GET BCM5464_MII_AUX_CTRLr_MII_AUX_CTRLf_GET
#define MII_AUX_CTRLr_MII_AUX_CTRLf_SET BCM5464_MII_AUX_CTRLr_MII_AUX_CTRLf_SET
#define READ_MII_AUX_CTRLr BCM5464_READ_MII_AUX_CTRLr
#define WRITE_MII_AUX_CTRLr BCM5464_WRITE_MII_AUX_CTRLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM5464_MII_AUX_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM5464
 * REGISTER:  MII_10BASE_T
 * BLOCKS:   USER
 * REGADDR:  0x0018
 * DESC:     10BASE-T Register (Addr 18h Shadow 001b)
 * SIZE:     32
 * FIELDS:
 *     MII_10BASE_T     MII_10BASE_T
 *
 ******************************************************************************/
#define BCM5464_MII_10BASE_Tr (0x00000118 | PHY_REG_ACC_BRCM_SHADOW)

#define BCM5464_MII_10BASE_Tr_SIZE 4

/*
 * This structure should be used to declare and program MII_10BASE_T.
 *
 */
typedef union BCM5464_MII_10BASE_Tr_s {
	uint32_t v[1];
	uint32_t mii_10base_t[1];
	uint32_t _mii_10base_t;
} BCM5464_MII_10BASE_Tr_t;

#define BCM5464_MII_10BASE_Tr_CLR(r) (r).mii_10base_t[0] = 0
#define BCM5464_MII_10BASE_Tr_SET(r,d) (r).mii_10base_t[0] = d
#define BCM5464_MII_10BASE_Tr_GET(r) (r).mii_10base_t[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM5464_MII_10BASE_Tr_MII_10BASE_Tf_GET(r) (((r).mii_10base_t[0]) & 0xffff)
#define BCM5464_MII_10BASE_Tr_MII_10BASE_Tf_SET(r,f) (r).mii_10base_t[0]=(((r).mii_10base_t[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access MII_10BASE_T.
 *
 */
#define BCM5464_READ_MII_10BASE_Tr(_pc,_r) phy_brcm_shadow_read(_pc,BCM5464_MII_10BASE_Tr,(_r._mii_10base_t))
#define BCM5464_WRITE_MII_10BASE_Tr(_pc,_r) phy_brcm_shadow_write(_pc,BCM5464_MII_10BASE_Tr,(_r._mii_10base_t))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MII_10BASE_Tr BCM5464_MII_10BASE_Tr
#define MII_10BASE_Tr_SIZE BCM5464_MII_10BASE_Tr_SIZE
typedef BCM5464_MII_10BASE_Tr_t MII_10BASE_Tr_t;
#define MII_10BASE_Tr_CLR BCM5464_MII_10BASE_Tr_CLR
#define MII_10BASE_Tr_SET BCM5464_MII_10BASE_Tr_SET
#define MII_10BASE_Tr_GET BCM5464_MII_10BASE_Tr_GET
#define MII_10BASE_Tr_MII_10BASE_Tf_GET BCM5464_MII_10BASE_Tr_MII_10BASE_Tf_GET
#define MII_10BASE_Tr_MII_10BASE_Tf_SET BCM5464_MII_10BASE_Tr_MII_10BASE_Tf_SET
#define READ_MII_10BASE_Tr BCM5464_READ_MII_10BASE_Tr
#define WRITE_MII_10BASE_Tr BCM5464_WRITE_MII_10BASE_Tr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM5464_MII_10BASE_Tr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM5464
 * REGISTER:  MII_POWER_CTRL
 * BLOCKS:   USER
 * REGADDR:  0x0018
 * DESC:     1000BASE-T/100BASE-TX/10BASE-T Power/MII Control Reg (Addr 18h Shadow 010b)
 * SIZE:     32
 * FIELDS:
 *     MII_POWER_CTRL   MII_POWER_CTRL
 *
 ******************************************************************************/
#define BCM5464_MII_POWER_CTRLr (0x00000218 | PHY_REG_ACC_BRCM_SHADOW)

#define BCM5464_MII_POWER_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program MII_POWER_CTRL.
 *
 */
typedef union BCM5464_MII_POWER_CTRLr_s {
	uint32_t v[1];
	uint32_t mii_power_ctrl[1];
	uint32_t _mii_power_ctrl;
} BCM5464_MII_POWER_CTRLr_t;

#define BCM5464_MII_POWER_CTRLr_CLR(r) (r).mii_power_ctrl[0] = 0
#define BCM5464_MII_POWER_CTRLr_SET(r,d) (r).mii_power_ctrl[0] = d
#define BCM5464_MII_POWER_CTRLr_GET(r) (r).mii_power_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM5464_MII_POWER_CTRLr_MII_POWER_CTRLf_GET(r) (((r).mii_power_ctrl[0]) & 0xffff)
#define BCM5464_MII_POWER_CTRLr_MII_POWER_CTRLf_SET(r,f) (r).mii_power_ctrl[0]=(((r).mii_power_ctrl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access MII_POWER_CTRL.
 *
 */
#define BCM5464_READ_MII_POWER_CTRLr(_pc,_r) phy_brcm_shadow_read(_pc,BCM5464_MII_POWER_CTRLr,(_r._mii_power_ctrl))
#define BCM5464_WRITE_MII_POWER_CTRLr(_pc,_r) phy_brcm_shadow_write(_pc,BCM5464_MII_POWER_CTRLr,(_r._mii_power_ctrl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MII_POWER_CTRLr BCM5464_MII_POWER_CTRLr
#define MII_POWER_CTRLr_SIZE BCM5464_MII_POWER_CTRLr_SIZE
typedef BCM5464_MII_POWER_CTRLr_t MII_POWER_CTRLr_t;
#define MII_POWER_CTRLr_CLR BCM5464_MII_POWER_CTRLr_CLR
#define MII_POWER_CTRLr_SET BCM5464_MII_POWER_CTRLr_SET
#define MII_POWER_CTRLr_GET BCM5464_MII_POWER_CTRLr_GET
#define MII_POWER_CTRLr_MII_POWER_CTRLf_GET BCM5464_MII_POWER_CTRLr_MII_POWER_CTRLf_GET
#define MII_POWER_CTRLr_MII_POWER_CTRLf_SET BCM5464_MII_POWER_CTRLr_MII_POWER_CTRLf_SET
#define READ_MII_POWER_CTRLr BCM5464_READ_MII_POWER_CTRLr
#define WRITE_MII_POWER_CTRLr BCM5464_WRITE_MII_POWER_CTRLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM5464_MII_POWER_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM5464
 * REGISTER:  MII_MISC_TEST
 * BLOCKS:   USER
 * REGADDR:  0x0018
 * DESC:     1000BASE-T/100BASE-TX/10BASE-T Misc Test Register (Addr 18h Shadow 100b)
 * SIZE:     32
 * FIELDS:
 *     MII_MISC_TEST    MII_MISC_TEST
 *
 ******************************************************************************/
#define BCM5464_MII_MISC_TESTr (0x00000418 | PHY_REG_ACC_BRCM_SHADOW)

#define BCM5464_MII_MISC_TESTr_SIZE 4

/*
 * This structure should be used to declare and program MII_MISC_TEST.
 *
 */
typedef union BCM5464_MII_MISC_TESTr_s {
	uint32_t v[1];
	uint32_t mii_misc_test[1];
	uint32_t _mii_misc_test;
} BCM5464_MII_MISC_TESTr_t;

#define BCM5464_MII_MISC_TESTr_CLR(r) (r).mii_misc_test[0] = 0
#define BCM5464_MII_MISC_TESTr_SET(r,d) (r).mii_misc_test[0] = d
#define BCM5464_MII_MISC_TESTr_GET(r) (r).mii_misc_test[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM5464_MII_MISC_TESTr_MII_MISC_TESTf_GET(r) (((r).mii_misc_test[0]) & 0xffff)
#define BCM5464_MII_MISC_TESTr_MII_MISC_TESTf_SET(r,f) (r).mii_misc_test[0]=(((r).mii_misc_test[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access MII_MISC_TEST.
 *
 */
#define BCM5464_READ_MII_MISC_TESTr(_pc,_r) phy_brcm_shadow_read(_pc,BCM5464_MII_MISC_TESTr,(_r._mii_misc_test))
#define BCM5464_WRITE_MII_MISC_TESTr(_pc,_r) phy_brcm_shadow_write(_pc,BCM5464_MII_MISC_TESTr,(_r._mii_misc_test))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MII_MISC_TESTr BCM5464_MII_MISC_TESTr
#define MII_MISC_TESTr_SIZE BCM5464_MII_MISC_TESTr_SIZE
typedef BCM5464_MII_MISC_TESTr_t MII_MISC_TESTr_t;
#define MII_MISC_TESTr_CLR BCM5464_MII_MISC_TESTr_CLR
#define MII_MISC_TESTr_SET BCM5464_MII_MISC_TESTr_SET
#define MII_MISC_TESTr_GET BCM5464_MII_MISC_TESTr_GET
#define MII_MISC_TESTr_MII_MISC_TESTf_GET BCM5464_MII_MISC_TESTr_MII_MISC_TESTf_GET
#define MII_MISC_TESTr_MII_MISC_TESTf_SET BCM5464_MII_MISC_TESTr_MII_MISC_TESTf_SET
#define READ_MII_MISC_TESTr BCM5464_READ_MII_MISC_TESTr
#define WRITE_MII_MISC_TESTr BCM5464_WRITE_MII_MISC_TESTr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM5464_MII_MISC_TESTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM5464
 * REGISTER:  MII_MISC_CTRL
 * BLOCKS:   USER
 * REGADDR:  0x0018
 * DESC:     1000BASE-T/100BASE-TX/10BASE-T Misc Control Register (Addr 18h Shadow 111b)
 * SIZE:     32
 * FIELDS:
 *     MII_MISC_CTRL    MII_MISC_CTRL
 *
 ******************************************************************************/
#define BCM5464_MII_MISC_CTRLr (0x00000718 | PHY_REG_ACC_BRCM_SHADOW)

#define BCM5464_MII_MISC_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program MII_MISC_CTRL.
 *
 */
typedef union BCM5464_MII_MISC_CTRLr_s {
	uint32_t v[1];
	uint32_t mii_misc_ctrl[1];
	uint32_t _mii_misc_ctrl;
} BCM5464_MII_MISC_CTRLr_t;

#define BCM5464_MII_MISC_CTRLr_CLR(r) (r).mii_misc_ctrl[0] = 0
#define BCM5464_MII_MISC_CTRLr_SET(r,d) (r).mii_misc_ctrl[0] = d
#define BCM5464_MII_MISC_CTRLr_GET(r) (r).mii_misc_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM5464_MII_MISC_CTRLr_MII_MISC_CTRLf_GET(r) (((r).mii_misc_ctrl[0]) & 0xffff)
#define BCM5464_MII_MISC_CTRLr_MII_MISC_CTRLf_SET(r,f) (r).mii_misc_ctrl[0]=(((r).mii_misc_ctrl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access MII_MISC_CTRL.
 *
 */
#define BCM5464_READ_MII_MISC_CTRLr(_pc,_r) phy_brcm_shadow_read(_pc,BCM5464_MII_MISC_CTRLr,(_r._mii_misc_ctrl))
#define BCM5464_WRITE_MII_MISC_CTRLr(_pc,_r) phy_brcm_shadow_write(_pc,BCM5464_MII_MISC_CTRLr,(_r._mii_misc_ctrl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MII_MISC_CTRLr BCM5464_MII_MISC_CTRLr
#define MII_MISC_CTRLr_SIZE BCM5464_MII_MISC_CTRLr_SIZE
typedef BCM5464_MII_MISC_CTRLr_t MII_MISC_CTRLr_t;
#define MII_MISC_CTRLr_CLR BCM5464_MII_MISC_CTRLr_CLR
#define MII_MISC_CTRLr_SET BCM5464_MII_MISC_CTRLr_SET
#define MII_MISC_CTRLr_GET BCM5464_MII_MISC_CTRLr_GET
#define MII_MISC_CTRLr_MII_MISC_CTRLf_GET BCM5464_MII_MISC_CTRLr_MII_MISC_CTRLf_GET
#define MII_MISC_CTRLr_MII_MISC_CTRLf_SET BCM5464_MII_MISC_CTRLr_MII_MISC_CTRLf_SET
#define READ_MII_MISC_CTRLr BCM5464_READ_MII_MISC_CTRLr
#define WRITE_MII_MISC_CTRLr BCM5464_WRITE_MII_MISC_CTRLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM5464_MII_MISC_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM5464
 * REGISTER:  SPARE_CTRL
 * BLOCKS:   USER
 * REGADDR:  0x001c
 * DESC:     1000BASE-T/100BASE-TX/10BASE-T Spare Ctrl Reg (Addr 1Ch shadow 00010b)
 * SIZE:     32
 * FIELDS:
 *     SPARE_CTRL       SPARE_CTRL
 *
 ******************************************************************************/
#define BCM5464_SPARE_CTRLr (0x0000021c | PHY_REG_ACC_BRCM_SHADOW)

#define BCM5464_SPARE_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program SPARE_CTRL.
 *
 */
typedef union BCM5464_SPARE_CTRLr_s {
	uint32_t v[1];
	uint32_t spare_ctrl[1];
	uint32_t _spare_ctrl;
} BCM5464_SPARE_CTRLr_t;

#define BCM5464_SPARE_CTRLr_CLR(r) (r).spare_ctrl[0] = 0
#define BCM5464_SPARE_CTRLr_SET(r,d) (r).spare_ctrl[0] = d
#define BCM5464_SPARE_CTRLr_GET(r) (r).spare_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM5464_SPARE_CTRLr_SPARE_CTRLf_GET(r) (((r).spare_ctrl[0]) & 0xffff)
#define BCM5464_SPARE_CTRLr_SPARE_CTRLf_SET(r,f) (r).spare_ctrl[0]=(((r).spare_ctrl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access SPARE_CTRL.
 *
 */
#define BCM5464_READ_SPARE_CTRLr(_pc,_r) phy_brcm_shadow_read(_pc,BCM5464_SPARE_CTRLr,(_r._spare_ctrl))
#define BCM5464_WRITE_SPARE_CTRLr(_pc,_r) phy_brcm_shadow_write(_pc,BCM5464_SPARE_CTRLr,(_r._spare_ctrl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SPARE_CTRLr BCM5464_SPARE_CTRLr
#define SPARE_CTRLr_SIZE BCM5464_SPARE_CTRLr_SIZE
typedef BCM5464_SPARE_CTRLr_t SPARE_CTRLr_t;
#define SPARE_CTRLr_CLR BCM5464_SPARE_CTRLr_CLR
#define SPARE_CTRLr_SET BCM5464_SPARE_CTRLr_SET
#define SPARE_CTRLr_GET BCM5464_SPARE_CTRLr_GET
#define SPARE_CTRLr_SPARE_CTRLf_GET BCM5464_SPARE_CTRLr_SPARE_CTRLf_GET
#define SPARE_CTRLr_SPARE_CTRLf_SET BCM5464_SPARE_CTRLr_SPARE_CTRLf_SET
#define READ_SPARE_CTRLr BCM5464_READ_SPARE_CTRLr
#define WRITE_SPARE_CTRLr BCM5464_WRITE_SPARE_CTRLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM5464_SPARE_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM5464
 * REGISTER:  CLK_ALIGN_CTRL
 * BLOCKS:   USER
 * REGADDR:  0x001c
 * DESC:     1000BASE-T/100BASE-TX/10BASE-T Clk Alignment Ctrl (Addr 1Ch shadow 00011b)
 * SIZE:     32
 * FIELDS:
 *     CLK_ALIGN_CTRL   CLK_ALIGN_CTRL
 *
 ******************************************************************************/
#define BCM5464_CLK_ALIGN_CTRLr (0x0000031c | PHY_REG_ACC_BRCM_SHADOW)

#define BCM5464_CLK_ALIGN_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program CLK_ALIGN_CTRL.
 *
 */
typedef union BCM5464_CLK_ALIGN_CTRLr_s {
	uint32_t v[1];
	uint32_t clk_align_ctrl[1];
	uint32_t _clk_align_ctrl;
} BCM5464_CLK_ALIGN_CTRLr_t;

#define BCM5464_CLK_ALIGN_CTRLr_CLR(r) (r).clk_align_ctrl[0] = 0
#define BCM5464_CLK_ALIGN_CTRLr_SET(r,d) (r).clk_align_ctrl[0] = d
#define BCM5464_CLK_ALIGN_CTRLr_GET(r) (r).clk_align_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM5464_CLK_ALIGN_CTRLr_CLK_ALIGN_CTRLf_GET(r) (((r).clk_align_ctrl[0]) & 0xffff)
#define BCM5464_CLK_ALIGN_CTRLr_CLK_ALIGN_CTRLf_SET(r,f) (r).clk_align_ctrl[0]=(((r).clk_align_ctrl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access CLK_ALIGN_CTRL.
 *
 */
#define BCM5464_READ_CLK_ALIGN_CTRLr(_pc,_r) phy_brcm_shadow_read(_pc,BCM5464_CLK_ALIGN_CTRLr,(_r._clk_align_ctrl))
#define BCM5464_WRITE_CLK_ALIGN_CTRLr(_pc,_r) phy_brcm_shadow_write(_pc,BCM5464_CLK_ALIGN_CTRLr,(_r._clk_align_ctrl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CLK_ALIGN_CTRLr BCM5464_CLK_ALIGN_CTRLr
#define CLK_ALIGN_CTRLr_SIZE BCM5464_CLK_ALIGN_CTRLr_SIZE
typedef BCM5464_CLK_ALIGN_CTRLr_t CLK_ALIGN_CTRLr_t;
#define CLK_ALIGN_CTRLr_CLR BCM5464_CLK_ALIGN_CTRLr_CLR
#define CLK_ALIGN_CTRLr_SET BCM5464_CLK_ALIGN_CTRLr_SET
#define CLK_ALIGN_CTRLr_GET BCM5464_CLK_ALIGN_CTRLr_GET
#define CLK_ALIGN_CTRLr_CLK_ALIGN_CTRLf_GET BCM5464_CLK_ALIGN_CTRLr_CLK_ALIGN_CTRLf_GET
#define CLK_ALIGN_CTRLr_CLK_ALIGN_CTRLf_SET BCM5464_CLK_ALIGN_CTRLr_CLK_ALIGN_CTRLf_SET
#define READ_CLK_ALIGN_CTRLr BCM5464_READ_CLK_ALIGN_CTRLr
#define WRITE_CLK_ALIGN_CTRLr BCM5464_WRITE_CLK_ALIGN_CTRLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM5464_CLK_ALIGN_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM5464
 * REGISTER:  SPARE_CTRL_2
 * BLOCKS:   USER
 * REGADDR:  0x001c
 * DESC:     1000BASE-T/100BASE-TX/10BASE-T Spare Ctrl 2 Reg (Addr 1Ch shadow 00100b)
 * SIZE:     32
 * FIELDS:
 *     SPARE_CTRL_2     SPARE_CTRL_2
 *
 ******************************************************************************/
#define BCM5464_SPARE_CTRL_2r (0x0000041c | PHY_REG_ACC_BRCM_SHADOW)

#define BCM5464_SPARE_CTRL_2r_SIZE 4

/*
 * This structure should be used to declare and program SPARE_CTRL_2.
 *
 */
typedef union BCM5464_SPARE_CTRL_2r_s {
	uint32_t v[1];
	uint32_t spare_ctrl_2[1];
	uint32_t _spare_ctrl_2;
} BCM5464_SPARE_CTRL_2r_t;

#define BCM5464_SPARE_CTRL_2r_CLR(r) (r).spare_ctrl_2[0] = 0
#define BCM5464_SPARE_CTRL_2r_SET(r,d) (r).spare_ctrl_2[0] = d
#define BCM5464_SPARE_CTRL_2r_GET(r) (r).spare_ctrl_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM5464_SPARE_CTRL_2r_SPARE_CTRL_2f_GET(r) (((r).spare_ctrl_2[0]) & 0xffff)
#define BCM5464_SPARE_CTRL_2r_SPARE_CTRL_2f_SET(r,f) (r).spare_ctrl_2[0]=(((r).spare_ctrl_2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access SPARE_CTRL_2.
 *
 */
#define BCM5464_READ_SPARE_CTRL_2r(_pc,_r) phy_brcm_shadow_read(_pc,BCM5464_SPARE_CTRL_2r,(_r._spare_ctrl_2))
#define BCM5464_WRITE_SPARE_CTRL_2r(_pc,_r) phy_brcm_shadow_write(_pc,BCM5464_SPARE_CTRL_2r,(_r._spare_ctrl_2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SPARE_CTRL_2r BCM5464_SPARE_CTRL_2r
#define SPARE_CTRL_2r_SIZE BCM5464_SPARE_CTRL_2r_SIZE
typedef BCM5464_SPARE_CTRL_2r_t SPARE_CTRL_2r_t;
#define SPARE_CTRL_2r_CLR BCM5464_SPARE_CTRL_2r_CLR
#define SPARE_CTRL_2r_SET BCM5464_SPARE_CTRL_2r_SET
#define SPARE_CTRL_2r_GET BCM5464_SPARE_CTRL_2r_GET
#define SPARE_CTRL_2r_SPARE_CTRL_2f_GET BCM5464_SPARE_CTRL_2r_SPARE_CTRL_2f_GET
#define SPARE_CTRL_2r_SPARE_CTRL_2f_SET BCM5464_SPARE_CTRL_2r_SPARE_CTRL_2f_SET
#define READ_SPARE_CTRL_2r BCM5464_READ_SPARE_CTRL_2r
#define WRITE_SPARE_CTRL_2r BCM5464_WRITE_SPARE_CTRL_2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM5464_SPARE_CTRL_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM5464
 * REGISTER:  SPARE_CTRL_3
 * BLOCKS:   USER
 * REGADDR:  0x001c
 * DESC:     1000BASE-T/100BASE-TX/10BASE-T Spare Ctrl 3 Reg (Addr 1Ch shadow 00101b)
 * SIZE:     32
 * FIELDS:
 *     SPARE_CTRL_3     SPARE_CTRL_3
 *
 ******************************************************************************/
#define BCM5464_SPARE_CTRL_3r (0x0000051c | PHY_REG_ACC_BRCM_SHADOW)

#define BCM5464_SPARE_CTRL_3r_SIZE 4

/*
 * This structure should be used to declare and program SPARE_CTRL_3.
 *
 */
typedef union BCM5464_SPARE_CTRL_3r_s {
	uint32_t v[1];
	uint32_t spare_ctrl_3[1];
	uint32_t _spare_ctrl_3;
} BCM5464_SPARE_CTRL_3r_t;

#define BCM5464_SPARE_CTRL_3r_CLR(r) (r).spare_ctrl_3[0] = 0
#define BCM5464_SPARE_CTRL_3r_SET(r,d) (r).spare_ctrl_3[0] = d
#define BCM5464_SPARE_CTRL_3r_GET(r) (r).spare_ctrl_3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM5464_SPARE_CTRL_3r_SPARE_CTRL_3f_GET(r) (((r).spare_ctrl_3[0]) & 0xffff)
#define BCM5464_SPARE_CTRL_3r_SPARE_CTRL_3f_SET(r,f) (r).spare_ctrl_3[0]=(((r).spare_ctrl_3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access SPARE_CTRL_3.
 *
 */
#define BCM5464_READ_SPARE_CTRL_3r(_pc,_r) phy_brcm_shadow_read(_pc,BCM5464_SPARE_CTRL_3r,(_r._spare_ctrl_3))
#define BCM5464_WRITE_SPARE_CTRL_3r(_pc,_r) phy_brcm_shadow_write(_pc,BCM5464_SPARE_CTRL_3r,(_r._spare_ctrl_3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SPARE_CTRL_3r BCM5464_SPARE_CTRL_3r
#define SPARE_CTRL_3r_SIZE BCM5464_SPARE_CTRL_3r_SIZE
typedef BCM5464_SPARE_CTRL_3r_t SPARE_CTRL_3r_t;
#define SPARE_CTRL_3r_CLR BCM5464_SPARE_CTRL_3r_CLR
#define SPARE_CTRL_3r_SET BCM5464_SPARE_CTRL_3r_SET
#define SPARE_CTRL_3r_GET BCM5464_SPARE_CTRL_3r_GET
#define SPARE_CTRL_3r_SPARE_CTRL_3f_GET BCM5464_SPARE_CTRL_3r_SPARE_CTRL_3f_GET
#define SPARE_CTRL_3r_SPARE_CTRL_3f_SET BCM5464_SPARE_CTRL_3r_SPARE_CTRL_3f_SET
#define READ_SPARE_CTRL_3r BCM5464_READ_SPARE_CTRL_3r
#define WRITE_SPARE_CTRL_3r BCM5464_WRITE_SPARE_CTRL_3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM5464_SPARE_CTRL_3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM5464
 * REGISTER:  LED_STAT
 * BLOCKS:   USER
 * REGADDR:  0x001c
 * DESC:     1000BASE-T/100BASE-TX/10BASE-T LED Status Reg (Addr 1Ch shadow 01000b)
 * SIZE:     32
 * FIELDS:
 *     LED_STAT         LED_STAT
 *
 ******************************************************************************/
#define BCM5464_LED_STATr (0x0000081c | PHY_REG_ACC_BRCM_SHADOW)

#define BCM5464_LED_STATr_SIZE 4

/*
 * This structure should be used to declare and program LED_STAT.
 *
 */
typedef union BCM5464_LED_STATr_s {
	uint32_t v[1];
	uint32_t led_stat[1];
	uint32_t _led_stat;
} BCM5464_LED_STATr_t;

#define BCM5464_LED_STATr_CLR(r) (r).led_stat[0] = 0
#define BCM5464_LED_STATr_SET(r,d) (r).led_stat[0] = d
#define BCM5464_LED_STATr_GET(r) (r).led_stat[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM5464_LED_STATr_LED_STATf_GET(r) (((r).led_stat[0]) & 0xffff)
#define BCM5464_LED_STATr_LED_STATf_SET(r,f) (r).led_stat[0]=(((r).led_stat[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access LED_STAT.
 *
 */
#define BCM5464_READ_LED_STATr(_pc,_r) phy_brcm_shadow_read(_pc,BCM5464_LED_STATr,(_r._led_stat))
#define BCM5464_WRITE_LED_STATr(_pc,_r) phy_brcm_shadow_write(_pc,BCM5464_LED_STATr,(_r._led_stat))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define LED_STATr BCM5464_LED_STATr
#define LED_STATr_SIZE BCM5464_LED_STATr_SIZE
typedef BCM5464_LED_STATr_t LED_STATr_t;
#define LED_STATr_CLR BCM5464_LED_STATr_CLR
#define LED_STATr_SET BCM5464_LED_STATr_SET
#define LED_STATr_GET BCM5464_LED_STATr_GET
#define LED_STATr_LED_STATf_GET BCM5464_LED_STATr_LED_STATf_GET
#define LED_STATr_LED_STATf_SET BCM5464_LED_STATr_LED_STATf_SET
#define READ_LED_STATr BCM5464_READ_LED_STATr
#define WRITE_LED_STATr BCM5464_WRITE_LED_STATr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM5464_LED_STATr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM5464
 * REGISTER:  LED_CTRL
 * BLOCKS:   USER
 * REGADDR:  0x001c
 * DESC:     1000BASE-T/100BASE-TX/10BASE-T LED Ctrl Reg (Addr 1Ch shadow 01001b)
 * SIZE:     32
 * FIELDS:
 *     LED_CTRL         LED_CTRL
 *
 ******************************************************************************/
#define BCM5464_LED_CTRLr (0x0000091c | PHY_REG_ACC_BRCM_SHADOW)

#define BCM5464_LED_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program LED_CTRL.
 *
 */
typedef union BCM5464_LED_CTRLr_s {
	uint32_t v[1];
	uint32_t led_ctrl[1];
	uint32_t _led_ctrl;
} BCM5464_LED_CTRLr_t;

#define BCM5464_LED_CTRLr_CLR(r) (r).led_ctrl[0] = 0
#define BCM5464_LED_CTRLr_SET(r,d) (r).led_ctrl[0] = d
#define BCM5464_LED_CTRLr_GET(r) (r).led_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM5464_LED_CTRLr_LED_CTRLf_GET(r) (((r).led_ctrl[0]) & 0xffff)
#define BCM5464_LED_CTRLr_LED_CTRLf_SET(r,f) (r).led_ctrl[0]=(((r).led_ctrl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access LED_CTRL.
 *
 */
#define BCM5464_READ_LED_CTRLr(_pc,_r) phy_brcm_shadow_read(_pc,BCM5464_LED_CTRLr,(_r._led_ctrl))
#define BCM5464_WRITE_LED_CTRLr(_pc,_r) phy_brcm_shadow_write(_pc,BCM5464_LED_CTRLr,(_r._led_ctrl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define LED_CTRLr BCM5464_LED_CTRLr
#define LED_CTRLr_SIZE BCM5464_LED_CTRLr_SIZE
typedef BCM5464_LED_CTRLr_t LED_CTRLr_t;
#define LED_CTRLr_CLR BCM5464_LED_CTRLr_CLR
#define LED_CTRLr_SET BCM5464_LED_CTRLr_SET
#define LED_CTRLr_GET BCM5464_LED_CTRLr_GET
#define LED_CTRLr_LED_CTRLf_GET BCM5464_LED_CTRLr_LED_CTRLf_GET
#define LED_CTRLr_LED_CTRLf_SET BCM5464_LED_CTRLr_LED_CTRLf_SET
#define READ_LED_CTRLr BCM5464_READ_LED_CTRLr
#define WRITE_LED_CTRLr BCM5464_WRITE_LED_CTRLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM5464_LED_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM5464
 * REGISTER:  AUTO_POWER_DOWN
 * BLOCKS:   USER
 * REGADDR:  0x001c
 * DESC:     Auto Power-Down Reg (Addr 1Ch shadow 01010b)
 * SIZE:     32
 * FIELDS:
 *     AUTO_POWER_DOWN  AUTO_POWER_DOWN
 *
 ******************************************************************************/
#define BCM5464_AUTO_POWER_DOWNr (0x00000a1c | PHY_REG_ACC_BRCM_SHADOW)

#define BCM5464_AUTO_POWER_DOWNr_SIZE 4

/*
 * This structure should be used to declare and program AUTO_POWER_DOWN.
 *
 */
typedef union BCM5464_AUTO_POWER_DOWNr_s {
	uint32_t v[1];
	uint32_t auto_power_down[1];
	uint32_t _auto_power_down;
} BCM5464_AUTO_POWER_DOWNr_t;

#define BCM5464_AUTO_POWER_DOWNr_CLR(r) (r).auto_power_down[0] = 0
#define BCM5464_AUTO_POWER_DOWNr_SET(r,d) (r).auto_power_down[0] = d
#define BCM5464_AUTO_POWER_DOWNr_GET(r) (r).auto_power_down[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM5464_AUTO_POWER_DOWNr_AUTO_POWER_DOWNf_GET(r) (((r).auto_power_down[0]) & 0xffff)
#define BCM5464_AUTO_POWER_DOWNr_AUTO_POWER_DOWNf_SET(r,f) (r).auto_power_down[0]=(((r).auto_power_down[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access AUTO_POWER_DOWN.
 *
 */
#define BCM5464_READ_AUTO_POWER_DOWNr(_pc,_r) phy_brcm_shadow_read(_pc,BCM5464_AUTO_POWER_DOWNr,(_r._auto_power_down))
#define BCM5464_WRITE_AUTO_POWER_DOWNr(_pc,_r) phy_brcm_shadow_write(_pc,BCM5464_AUTO_POWER_DOWNr,(_r._auto_power_down))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AUTO_POWER_DOWNr BCM5464_AUTO_POWER_DOWNr
#define AUTO_POWER_DOWNr_SIZE BCM5464_AUTO_POWER_DOWNr_SIZE
typedef BCM5464_AUTO_POWER_DOWNr_t AUTO_POWER_DOWNr_t;
#define AUTO_POWER_DOWNr_CLR BCM5464_AUTO_POWER_DOWNr_CLR
#define AUTO_POWER_DOWNr_SET BCM5464_AUTO_POWER_DOWNr_SET
#define AUTO_POWER_DOWNr_GET BCM5464_AUTO_POWER_DOWNr_GET
#define AUTO_POWER_DOWNr_AUTO_POWER_DOWNf_GET BCM5464_AUTO_POWER_DOWNr_AUTO_POWER_DOWNf_GET
#define AUTO_POWER_DOWNr_AUTO_POWER_DOWNf_SET BCM5464_AUTO_POWER_DOWNr_AUTO_POWER_DOWNf_SET
#define READ_AUTO_POWER_DOWNr BCM5464_READ_AUTO_POWER_DOWNr
#define WRITE_AUTO_POWER_DOWNr BCM5464_WRITE_AUTO_POWER_DOWNr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM5464_AUTO_POWER_DOWNr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM5464
 * REGISTER:  LED_SELECTOR_1
 * BLOCKS:   USER
 * REGADDR:  0x001c
 * DESC:     1000BASE-T/100BASE-TX/10BASE-T LED Selector 1 Reg (Addr 1Ch shadow 01101b)
 * SIZE:     32
 * FIELDS:
 *     LED_SELECTOR_1   LED_SELECTOR_1
 *
 ******************************************************************************/
#define BCM5464_LED_SELECTOR_1r (0x00000d1c | PHY_REG_ACC_BRCM_SHADOW)

#define BCM5464_LED_SELECTOR_1r_SIZE 4

/*
 * This structure should be used to declare and program LED_SELECTOR_1.
 *
 */
typedef union BCM5464_LED_SELECTOR_1r_s {
	uint32_t v[1];
	uint32_t led_selector_1[1];
	uint32_t _led_selector_1;
} BCM5464_LED_SELECTOR_1r_t;

#define BCM5464_LED_SELECTOR_1r_CLR(r) (r).led_selector_1[0] = 0
#define BCM5464_LED_SELECTOR_1r_SET(r,d) (r).led_selector_1[0] = d
#define BCM5464_LED_SELECTOR_1r_GET(r) (r).led_selector_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM5464_LED_SELECTOR_1r_LED_SELECTOR_1f_GET(r) (((r).led_selector_1[0]) & 0xffff)
#define BCM5464_LED_SELECTOR_1r_LED_SELECTOR_1f_SET(r,f) (r).led_selector_1[0]=(((r).led_selector_1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access LED_SELECTOR_1.
 *
 */
#define BCM5464_READ_LED_SELECTOR_1r(_pc,_r) phy_brcm_shadow_read(_pc,BCM5464_LED_SELECTOR_1r,(_r._led_selector_1))
#define BCM5464_WRITE_LED_SELECTOR_1r(_pc,_r) phy_brcm_shadow_write(_pc,BCM5464_LED_SELECTOR_1r,(_r._led_selector_1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define LED_SELECTOR_1r BCM5464_LED_SELECTOR_1r
#define LED_SELECTOR_1r_SIZE BCM5464_LED_SELECTOR_1r_SIZE
typedef BCM5464_LED_SELECTOR_1r_t LED_SELECTOR_1r_t;
#define LED_SELECTOR_1r_CLR BCM5464_LED_SELECTOR_1r_CLR
#define LED_SELECTOR_1r_SET BCM5464_LED_SELECTOR_1r_SET
#define LED_SELECTOR_1r_GET BCM5464_LED_SELECTOR_1r_GET
#define LED_SELECTOR_1r_LED_SELECTOR_1f_GET BCM5464_LED_SELECTOR_1r_LED_SELECTOR_1f_GET
#define LED_SELECTOR_1r_LED_SELECTOR_1f_SET BCM5464_LED_SELECTOR_1r_LED_SELECTOR_1f_SET
#define READ_LED_SELECTOR_1r BCM5464_READ_LED_SELECTOR_1r
#define WRITE_LED_SELECTOR_1r BCM5464_WRITE_LED_SELECTOR_1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM5464_LED_SELECTOR_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM5464
 * REGISTER:  LED_SELECTOR_2
 * BLOCKS:   USER
 * REGADDR:  0x001c
 * DESC:     1000BASE-T/100BASE-TX/10BASE-T LED Selector 2 Reg (Addr 1Ch shadow 01110b)
 * SIZE:     32
 * FIELDS:
 *     LED_SELECTOR_2   LED_SELECTOR_2
 *
 ******************************************************************************/
#define BCM5464_LED_SELECTOR_2r (0x00000e1c | PHY_REG_ACC_BRCM_SHADOW)

#define BCM5464_LED_SELECTOR_2r_SIZE 4

/*
 * This structure should be used to declare and program LED_SELECTOR_2.
 *
 */
typedef union BCM5464_LED_SELECTOR_2r_s {
	uint32_t v[1];
	uint32_t led_selector_2[1];
	uint32_t _led_selector_2;
} BCM5464_LED_SELECTOR_2r_t;

#define BCM5464_LED_SELECTOR_2r_CLR(r) (r).led_selector_2[0] = 0
#define BCM5464_LED_SELECTOR_2r_SET(r,d) (r).led_selector_2[0] = d
#define BCM5464_LED_SELECTOR_2r_GET(r) (r).led_selector_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM5464_LED_SELECTOR_2r_LED_SELECTOR_2f_GET(r) (((r).led_selector_2[0]) & 0xffff)
#define BCM5464_LED_SELECTOR_2r_LED_SELECTOR_2f_SET(r,f) (r).led_selector_2[0]=(((r).led_selector_2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access LED_SELECTOR_2.
 *
 */
#define BCM5464_READ_LED_SELECTOR_2r(_pc,_r) phy_brcm_shadow_read(_pc,BCM5464_LED_SELECTOR_2r,(_r._led_selector_2))
#define BCM5464_WRITE_LED_SELECTOR_2r(_pc,_r) phy_brcm_shadow_write(_pc,BCM5464_LED_SELECTOR_2r,(_r._led_selector_2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define LED_SELECTOR_2r BCM5464_LED_SELECTOR_2r
#define LED_SELECTOR_2r_SIZE BCM5464_LED_SELECTOR_2r_SIZE
typedef BCM5464_LED_SELECTOR_2r_t LED_SELECTOR_2r_t;
#define LED_SELECTOR_2r_CLR BCM5464_LED_SELECTOR_2r_CLR
#define LED_SELECTOR_2r_SET BCM5464_LED_SELECTOR_2r_SET
#define LED_SELECTOR_2r_GET BCM5464_LED_SELECTOR_2r_GET
#define LED_SELECTOR_2r_LED_SELECTOR_2f_GET BCM5464_LED_SELECTOR_2r_LED_SELECTOR_2f_GET
#define LED_SELECTOR_2r_LED_SELECTOR_2f_SET BCM5464_LED_SELECTOR_2r_LED_SELECTOR_2f_SET
#define READ_LED_SELECTOR_2r BCM5464_READ_LED_SELECTOR_2r
#define WRITE_LED_SELECTOR_2r BCM5464_WRITE_LED_SELECTOR_2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM5464_LED_SELECTOR_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM5464
 * REGISTER:  LED_GPIO_CTRL
 * BLOCKS:   USER
 * REGADDR:  0x001c
 * DESC:     1000BASE-T/100BASE-TX/10BASE-T LED GPIO Ctrl/Stat (Addr 1Ch shadow 01111b)
 * SIZE:     32
 * FIELDS:
 *     LED_GPIO_CTRL    LED_GPIO_CTRL
 *
 ******************************************************************************/
#define BCM5464_LED_GPIO_CTRLr (0x00000f1c | PHY_REG_ACC_BRCM_SHADOW)

#define BCM5464_LED_GPIO_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program LED_GPIO_CTRL.
 *
 */
typedef union BCM5464_LED_GPIO_CTRLr_s {
	uint32_t v[1];
	uint32_t led_gpio_ctrl[1];
	uint32_t _led_gpio_ctrl;
} BCM5464_LED_GPIO_CTRLr_t;

#define BCM5464_LED_GPIO_CTRLr_CLR(r) (r).led_gpio_ctrl[0] = 0
#define BCM5464_LED_GPIO_CTRLr_SET(r,d) (r).led_gpio_ctrl[0] = d
#define BCM5464_LED_GPIO_CTRLr_GET(r) (r).led_gpio_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM5464_LED_GPIO_CTRLr_LED_GPIO_CTRLf_GET(r) (((r).led_gpio_ctrl[0]) & 0xffff)
#define BCM5464_LED_GPIO_CTRLr_LED_GPIO_CTRLf_SET(r,f) (r).led_gpio_ctrl[0]=(((r).led_gpio_ctrl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access LED_GPIO_CTRL.
 *
 */
#define BCM5464_READ_LED_GPIO_CTRLr(_pc,_r) phy_brcm_shadow_read(_pc,BCM5464_LED_GPIO_CTRLr,(_r._led_gpio_ctrl))
#define BCM5464_WRITE_LED_GPIO_CTRLr(_pc,_r) phy_brcm_shadow_write(_pc,BCM5464_LED_GPIO_CTRLr,(_r._led_gpio_ctrl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define LED_GPIO_CTRLr BCM5464_LED_GPIO_CTRLr
#define LED_GPIO_CTRLr_SIZE BCM5464_LED_GPIO_CTRLr_SIZE
typedef BCM5464_LED_GPIO_CTRLr_t LED_GPIO_CTRLr_t;
#define LED_GPIO_CTRLr_CLR BCM5464_LED_GPIO_CTRLr_CLR
#define LED_GPIO_CTRLr_SET BCM5464_LED_GPIO_CTRLr_SET
#define LED_GPIO_CTRLr_GET BCM5464_LED_GPIO_CTRLr_GET
#define LED_GPIO_CTRLr_LED_GPIO_CTRLf_GET BCM5464_LED_GPIO_CTRLr_LED_GPIO_CTRLf_GET
#define LED_GPIO_CTRLr_LED_GPIO_CTRLf_SET BCM5464_LED_GPIO_CTRLr_LED_GPIO_CTRLf_SET
#define READ_LED_GPIO_CTRLr BCM5464_READ_LED_GPIO_CTRLr
#define WRITE_LED_GPIO_CTRLr BCM5464_WRITE_LED_GPIO_CTRLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM5464_LED_GPIO_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM5464
 * REGISTER:  MISC_1000X_CTRL
 * BLOCKS:   USER
 * REGADDR:  0x001c
 * DESC:     1000BASE-X Misc 1000BASE-X Control Reg (Addr 1Ch shadow 10111b)
 * SIZE:     32
 * FIELDS:
 *     MISC_1000X_CTRL  MISC_1000X_CTRL
 *
 ******************************************************************************/
#define BCM5464_MISC_1000X_CTRLr (0x0000171c | PHY_REG_ACC_BRCM_SHADOW)

#define BCM5464_MISC_1000X_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program MISC_1000X_CTRL.
 *
 */
typedef union BCM5464_MISC_1000X_CTRLr_s {
	uint32_t v[1];
	uint32_t misc_1000x_ctrl[1];
	uint32_t _misc_1000x_ctrl;
} BCM5464_MISC_1000X_CTRLr_t;

#define BCM5464_MISC_1000X_CTRLr_CLR(r) (r).misc_1000x_ctrl[0] = 0
#define BCM5464_MISC_1000X_CTRLr_SET(r,d) (r).misc_1000x_ctrl[0] = d
#define BCM5464_MISC_1000X_CTRLr_GET(r) (r).misc_1000x_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM5464_MISC_1000X_CTRLr_MISC_1000X_CTRLf_GET(r) (((r).misc_1000x_ctrl[0]) & 0xffff)
#define BCM5464_MISC_1000X_CTRLr_MISC_1000X_CTRLf_SET(r,f) (r).misc_1000x_ctrl[0]=(((r).misc_1000x_ctrl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access MISC_1000X_CTRL.
 *
 */
#define BCM5464_READ_MISC_1000X_CTRLr(_pc,_r) phy_brcm_shadow_read(_pc,BCM5464_MISC_1000X_CTRLr,(_r._misc_1000x_ctrl))
#define BCM5464_WRITE_MISC_1000X_CTRLr(_pc,_r) phy_brcm_shadow_write(_pc,BCM5464_MISC_1000X_CTRLr,(_r._misc_1000x_ctrl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MISC_1000X_CTRLr BCM5464_MISC_1000X_CTRLr
#define MISC_1000X_CTRLr_SIZE BCM5464_MISC_1000X_CTRLr_SIZE
typedef BCM5464_MISC_1000X_CTRLr_t MISC_1000X_CTRLr_t;
#define MISC_1000X_CTRLr_CLR BCM5464_MISC_1000X_CTRLr_CLR
#define MISC_1000X_CTRLr_SET BCM5464_MISC_1000X_CTRLr_SET
#define MISC_1000X_CTRLr_GET BCM5464_MISC_1000X_CTRLr_GET
#define MISC_1000X_CTRLr_MISC_1000X_CTRLf_GET BCM5464_MISC_1000X_CTRLr_MISC_1000X_CTRLf_GET
#define MISC_1000X_CTRLr_MISC_1000X_CTRLf_SET BCM5464_MISC_1000X_CTRLr_MISC_1000X_CTRLf_SET
#define READ_MISC_1000X_CTRLr BCM5464_READ_MISC_1000X_CTRLr
#define WRITE_MISC_1000X_CTRLr BCM5464_WRITE_MISC_1000X_CTRLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM5464_MISC_1000X_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM5464
 * REGISTER:  AUTO_DETECT_SGMII_MEDIA
 * BLOCKS:   USER
 * REGADDR:  0x001c
 * DESC:     1000BASE-X Auto-Detect SGMII/Media Converter Reg (Addr 1Ch shadow 11000b)
 * SIZE:     32
 * FIELDS:
 *     AUTO_DETECT_SGMII_MEDIA AUTO_DETECT_SGMII_MEDIA
 *
 ******************************************************************************/
#define BCM5464_AUTO_DETECT_SGMII_MEDIAr (0x0000181c | PHY_REG_ACC_BRCM_SHADOW)

#define BCM5464_AUTO_DETECT_SGMII_MEDIAr_SIZE 4

/*
 * This structure should be used to declare and program AUTO_DETECT_SGMII_MEDIA.
 *
 */
typedef union BCM5464_AUTO_DETECT_SGMII_MEDIAr_s {
	uint32_t v[1];
	uint32_t auto_detect_sgmii_media[1];
	uint32_t _auto_detect_sgmii_media;
} BCM5464_AUTO_DETECT_SGMII_MEDIAr_t;

#define BCM5464_AUTO_DETECT_SGMII_MEDIAr_CLR(r) (r).auto_detect_sgmii_media[0] = 0
#define BCM5464_AUTO_DETECT_SGMII_MEDIAr_SET(r,d) (r).auto_detect_sgmii_media[0] = d
#define BCM5464_AUTO_DETECT_SGMII_MEDIAr_GET(r) (r).auto_detect_sgmii_media[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM5464_AUTO_DETECT_SGMII_MEDIAr_AUTO_DETECT_SGMII_MEDIAf_GET(r) (((r).auto_detect_sgmii_media[0]) & 0xffff)
#define BCM5464_AUTO_DETECT_SGMII_MEDIAr_AUTO_DETECT_SGMII_MEDIAf_SET(r,f) (r).auto_detect_sgmii_media[0]=(((r).auto_detect_sgmii_media[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access AUTO_DETECT_SGMII_MEDIA.
 *
 */
#define BCM5464_READ_AUTO_DETECT_SGMII_MEDIAr(_pc,_r) phy_brcm_shadow_read(_pc,BCM5464_AUTO_DETECT_SGMII_MEDIAr,(_r._auto_detect_sgmii_media))
#define BCM5464_WRITE_AUTO_DETECT_SGMII_MEDIAr(_pc,_r) phy_brcm_shadow_write(_pc,BCM5464_AUTO_DETECT_SGMII_MEDIAr,(_r._auto_detect_sgmii_media))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AUTO_DETECT_SGMII_MEDIAr BCM5464_AUTO_DETECT_SGMII_MEDIAr
#define AUTO_DETECT_SGMII_MEDIAr_SIZE BCM5464_AUTO_DETECT_SGMII_MEDIAr_SIZE
typedef BCM5464_AUTO_DETECT_SGMII_MEDIAr_t AUTO_DETECT_SGMII_MEDIAr_t;
#define AUTO_DETECT_SGMII_MEDIAr_CLR BCM5464_AUTO_DETECT_SGMII_MEDIAr_CLR
#define AUTO_DETECT_SGMII_MEDIAr_SET BCM5464_AUTO_DETECT_SGMII_MEDIAr_SET
#define AUTO_DETECT_SGMII_MEDIAr_GET BCM5464_AUTO_DETECT_SGMII_MEDIAr_GET
#define AUTO_DETECT_SGMII_MEDIAr_AUTO_DETECT_SGMII_MEDIAf_GET BCM5464_AUTO_DETECT_SGMII_MEDIAr_AUTO_DETECT_SGMII_MEDIAf_GET
#define AUTO_DETECT_SGMII_MEDIAr_AUTO_DETECT_SGMII_MEDIAf_SET BCM5464_AUTO_DETECT_SGMII_MEDIAr_AUTO_DETECT_SGMII_MEDIAf_SET
#define READ_AUTO_DETECT_SGMII_MEDIAr BCM5464_READ_AUTO_DETECT_SGMII_MEDIAr
#define WRITE_AUTO_DETECT_SGMII_MEDIAr BCM5464_WRITE_AUTO_DETECT_SGMII_MEDIAr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM5464_AUTO_DETECT_SGMII_MEDIAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM5464
 * REGISTER:  MII_1000X_AN_DEBUG
 * BLOCKS:   USER
 * REGADDR:  0x001c
 * DESC:     1000BASE-X Auto-Negotiation Debug Reg (Addr 1Ch shadow 11010b)
 * SIZE:     32
 * FIELDS:
 *     MII_1000X_AN_DEBUG MII_1000X_AN_DEBUG
 *
 ******************************************************************************/
#define BCM5464_MII_1000X_AN_DEBUGr (0x00001a1c | PHY_REG_ACC_BRCM_SHADOW)

#define BCM5464_MII_1000X_AN_DEBUGr_SIZE 4

/*
 * This structure should be used to declare and program MII_1000X_AN_DEBUG.
 *
 */
typedef union BCM5464_MII_1000X_AN_DEBUGr_s {
	uint32_t v[1];
	uint32_t mii_1000x_an_debug[1];
	uint32_t _mii_1000x_an_debug;
} BCM5464_MII_1000X_AN_DEBUGr_t;

#define BCM5464_MII_1000X_AN_DEBUGr_CLR(r) (r).mii_1000x_an_debug[0] = 0
#define BCM5464_MII_1000X_AN_DEBUGr_SET(r,d) (r).mii_1000x_an_debug[0] = d
#define BCM5464_MII_1000X_AN_DEBUGr_GET(r) (r).mii_1000x_an_debug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM5464_MII_1000X_AN_DEBUGr_MII_1000X_AN_DEBUGf_GET(r) (((r).mii_1000x_an_debug[0]) & 0xffff)
#define BCM5464_MII_1000X_AN_DEBUGr_MII_1000X_AN_DEBUGf_SET(r,f) (r).mii_1000x_an_debug[0]=(((r).mii_1000x_an_debug[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access MII_1000X_AN_DEBUG.
 *
 */
#define BCM5464_READ_MII_1000X_AN_DEBUGr(_pc,_r) phy_brcm_shadow_read(_pc,BCM5464_MII_1000X_AN_DEBUGr,(_r._mii_1000x_an_debug))
#define BCM5464_WRITE_MII_1000X_AN_DEBUGr(_pc,_r) phy_brcm_shadow_write(_pc,BCM5464_MII_1000X_AN_DEBUGr,(_r._mii_1000x_an_debug))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MII_1000X_AN_DEBUGr BCM5464_MII_1000X_AN_DEBUGr
#define MII_1000X_AN_DEBUGr_SIZE BCM5464_MII_1000X_AN_DEBUGr_SIZE
typedef BCM5464_MII_1000X_AN_DEBUGr_t MII_1000X_AN_DEBUGr_t;
#define MII_1000X_AN_DEBUGr_CLR BCM5464_MII_1000X_AN_DEBUGr_CLR
#define MII_1000X_AN_DEBUGr_SET BCM5464_MII_1000X_AN_DEBUGr_SET
#define MII_1000X_AN_DEBUGr_GET BCM5464_MII_1000X_AN_DEBUGr_GET
#define MII_1000X_AN_DEBUGr_MII_1000X_AN_DEBUGf_GET BCM5464_MII_1000X_AN_DEBUGr_MII_1000X_AN_DEBUGf_GET
#define MII_1000X_AN_DEBUGr_MII_1000X_AN_DEBUGf_SET BCM5464_MII_1000X_AN_DEBUGr_MII_1000X_AN_DEBUGf_SET
#define READ_MII_1000X_AN_DEBUGr BCM5464_READ_MII_1000X_AN_DEBUGr
#define WRITE_MII_1000X_AN_DEBUGr BCM5464_WRITE_MII_1000X_AN_DEBUGr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM5464_MII_1000X_AN_DEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM5464
 * REGISTER:  AUX_1000X_CTRL
 * BLOCKS:   USER
 * REGADDR:  0x001c
 * DESC:     Auxiliary 1000BASE-X Control Reg (Addr 1Ch shadow 11011b)
 * SIZE:     32
 * FIELDS:
 *     AUX_1000X_CTRL   AUX_1000X_CTRL
 *
 ******************************************************************************/
#define BCM5464_AUX_1000X_CTRLr (0x00001b1c | PHY_REG_ACC_BRCM_SHADOW)

#define BCM5464_AUX_1000X_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program AUX_1000X_CTRL.
 *
 */
typedef union BCM5464_AUX_1000X_CTRLr_s {
	uint32_t v[1];
	uint32_t aux_1000x_ctrl[1];
	uint32_t _aux_1000x_ctrl;
} BCM5464_AUX_1000X_CTRLr_t;

#define BCM5464_AUX_1000X_CTRLr_CLR(r) (r).aux_1000x_ctrl[0] = 0
#define BCM5464_AUX_1000X_CTRLr_SET(r,d) (r).aux_1000x_ctrl[0] = d
#define BCM5464_AUX_1000X_CTRLr_GET(r) (r).aux_1000x_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM5464_AUX_1000X_CTRLr_AUX_1000X_CTRLf_GET(r) (((r).aux_1000x_ctrl[0]) & 0xffff)
#define BCM5464_AUX_1000X_CTRLr_AUX_1000X_CTRLf_SET(r,f) (r).aux_1000x_ctrl[0]=(((r).aux_1000x_ctrl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access AUX_1000X_CTRL.
 *
 */
#define BCM5464_READ_AUX_1000X_CTRLr(_pc,_r) phy_brcm_shadow_read(_pc,BCM5464_AUX_1000X_CTRLr,(_r._aux_1000x_ctrl))
#define BCM5464_WRITE_AUX_1000X_CTRLr(_pc,_r) phy_brcm_shadow_write(_pc,BCM5464_AUX_1000X_CTRLr,(_r._aux_1000x_ctrl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AUX_1000X_CTRLr BCM5464_AUX_1000X_CTRLr
#define AUX_1000X_CTRLr_SIZE BCM5464_AUX_1000X_CTRLr_SIZE
typedef BCM5464_AUX_1000X_CTRLr_t AUX_1000X_CTRLr_t;
#define AUX_1000X_CTRLr_CLR BCM5464_AUX_1000X_CTRLr_CLR
#define AUX_1000X_CTRLr_SET BCM5464_AUX_1000X_CTRLr_SET
#define AUX_1000X_CTRLr_GET BCM5464_AUX_1000X_CTRLr_GET
#define AUX_1000X_CTRLr_AUX_1000X_CTRLf_GET BCM5464_AUX_1000X_CTRLr_AUX_1000X_CTRLf_GET
#define AUX_1000X_CTRLr_AUX_1000X_CTRLf_SET BCM5464_AUX_1000X_CTRLr_AUX_1000X_CTRLf_SET
#define READ_AUX_1000X_CTRLr BCM5464_READ_AUX_1000X_CTRLr
#define WRITE_AUX_1000X_CTRLr BCM5464_WRITE_AUX_1000X_CTRLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM5464_AUX_1000X_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM5464
 * REGISTER:  AUX_1000X_STAT
 * BLOCKS:   USER
 * REGADDR:  0x001c
 * DESC:     Auxiliary 1000BASE-X Status Reg (Addr 1Ch shadow 11100b)
 * SIZE:     32
 * FIELDS:
 *     AUX_1000X_STAT   AUX_1000X_STAT
 *
 ******************************************************************************/
#define BCM5464_AUX_1000X_STATr (0x00001c1c | PHY_REG_ACC_BRCM_SHADOW)

#define BCM5464_AUX_1000X_STATr_SIZE 4

/*
 * This structure should be used to declare and program AUX_1000X_STAT.
 *
 */
typedef union BCM5464_AUX_1000X_STATr_s {
	uint32_t v[1];
	uint32_t aux_1000x_stat[1];
	uint32_t _aux_1000x_stat;
} BCM5464_AUX_1000X_STATr_t;

#define BCM5464_AUX_1000X_STATr_CLR(r) (r).aux_1000x_stat[0] = 0
#define BCM5464_AUX_1000X_STATr_SET(r,d) (r).aux_1000x_stat[0] = d
#define BCM5464_AUX_1000X_STATr_GET(r) (r).aux_1000x_stat[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM5464_AUX_1000X_STATr_AUX_1000X_STATf_GET(r) (((r).aux_1000x_stat[0]) & 0xffff)
#define BCM5464_AUX_1000X_STATr_AUX_1000X_STATf_SET(r,f) (r).aux_1000x_stat[0]=(((r).aux_1000x_stat[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access AUX_1000X_STAT.
 *
 */
#define BCM5464_READ_AUX_1000X_STATr(_pc,_r) phy_brcm_shadow_read(_pc,BCM5464_AUX_1000X_STATr,(_r._aux_1000x_stat))
#define BCM5464_WRITE_AUX_1000X_STATr(_pc,_r) phy_brcm_shadow_write(_pc,BCM5464_AUX_1000X_STATr,(_r._aux_1000x_stat))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AUX_1000X_STATr BCM5464_AUX_1000X_STATr
#define AUX_1000X_STATr_SIZE BCM5464_AUX_1000X_STATr_SIZE
typedef BCM5464_AUX_1000X_STATr_t AUX_1000X_STATr_t;
#define AUX_1000X_STATr_CLR BCM5464_AUX_1000X_STATr_CLR
#define AUX_1000X_STATr_SET BCM5464_AUX_1000X_STATr_SET
#define AUX_1000X_STATr_GET BCM5464_AUX_1000X_STATr_GET
#define AUX_1000X_STATr_AUX_1000X_STATf_GET BCM5464_AUX_1000X_STATr_AUX_1000X_STATf_GET
#define AUX_1000X_STATr_AUX_1000X_STATf_SET BCM5464_AUX_1000X_STATr_AUX_1000X_STATf_SET
#define READ_AUX_1000X_STATr BCM5464_READ_AUX_1000X_STATr
#define WRITE_AUX_1000X_STATr BCM5464_WRITE_AUX_1000X_STATr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM5464_AUX_1000X_STATr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM5464
 * REGISTER:  MISC_1000X_STAT
 * BLOCKS:   USER
 * REGADDR:  0x001c
 * DESC:     Misc 1000BASE-X Status Reg (Addr 1Ch shadow 11101b)
 * SIZE:     32
 * FIELDS:
 *     MISC_1000X_STAT  MISC_1000X_STAT
 *
 ******************************************************************************/
#define BCM5464_MISC_1000X_STATr (0x00001d1c | PHY_REG_ACC_BRCM_SHADOW)

#define BCM5464_MISC_1000X_STATr_SIZE 4

/*
 * This structure should be used to declare and program MISC_1000X_STAT.
 *
 */
typedef union BCM5464_MISC_1000X_STATr_s {
	uint32_t v[1];
	uint32_t misc_1000x_stat[1];
	uint32_t _misc_1000x_stat;
} BCM5464_MISC_1000X_STATr_t;

#define BCM5464_MISC_1000X_STATr_CLR(r) (r).misc_1000x_stat[0] = 0
#define BCM5464_MISC_1000X_STATr_SET(r,d) (r).misc_1000x_stat[0] = d
#define BCM5464_MISC_1000X_STATr_GET(r) (r).misc_1000x_stat[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM5464_MISC_1000X_STATr_MISC_1000X_STATf_GET(r) (((r).misc_1000x_stat[0]) & 0xffff)
#define BCM5464_MISC_1000X_STATr_MISC_1000X_STATf_SET(r,f) (r).misc_1000x_stat[0]=(((r).misc_1000x_stat[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access MISC_1000X_STAT.
 *
 */
#define BCM5464_READ_MISC_1000X_STATr(_pc,_r) phy_brcm_shadow_read(_pc,BCM5464_MISC_1000X_STATr,(_r._misc_1000x_stat))
#define BCM5464_WRITE_MISC_1000X_STATr(_pc,_r) phy_brcm_shadow_write(_pc,BCM5464_MISC_1000X_STATr,(_r._misc_1000x_stat))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MISC_1000X_STATr BCM5464_MISC_1000X_STATr
#define MISC_1000X_STATr_SIZE BCM5464_MISC_1000X_STATr_SIZE
typedef BCM5464_MISC_1000X_STATr_t MISC_1000X_STATr_t;
#define MISC_1000X_STATr_CLR BCM5464_MISC_1000X_STATr_CLR
#define MISC_1000X_STATr_SET BCM5464_MISC_1000X_STATr_SET
#define MISC_1000X_STATr_GET BCM5464_MISC_1000X_STATr_GET
#define MISC_1000X_STATr_MISC_1000X_STATf_GET BCM5464_MISC_1000X_STATr_MISC_1000X_STATf_GET
#define MISC_1000X_STATr_MISC_1000X_STATf_SET BCM5464_MISC_1000X_STATr_MISC_1000X_STATf_SET
#define READ_MISC_1000X_STATr BCM5464_READ_MISC_1000X_STATr
#define WRITE_MISC_1000X_STATr BCM5464_WRITE_MISC_1000X_STATr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM5464_MISC_1000X_STATr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM5464
 * REGISTER:  AUTO_DETECT_MEDIUM
 * BLOCKS:   USER
 * REGADDR:  0x001c
 * DESC:     Copper/Fiber Auto-Detect Medium Reg (Addr 1Ch shadow 11110b)
 * SIZE:     32
 * FIELDS:
 *     AUTO_DETECT_MEDIUM AUTO_DETECT_MEDIUM
 *
 ******************************************************************************/
#define BCM5464_AUTO_DETECT_MEDIUMr (0x00001e1c | PHY_REG_ACC_BRCM_SHADOW)

#define BCM5464_AUTO_DETECT_MEDIUMr_SIZE 4

/*
 * This structure should be used to declare and program AUTO_DETECT_MEDIUM.
 *
 */
typedef union BCM5464_AUTO_DETECT_MEDIUMr_s {
	uint32_t v[1];
	uint32_t auto_detect_medium[1];
	uint32_t _auto_detect_medium;
} BCM5464_AUTO_DETECT_MEDIUMr_t;

#define BCM5464_AUTO_DETECT_MEDIUMr_CLR(r) (r).auto_detect_medium[0] = 0
#define BCM5464_AUTO_DETECT_MEDIUMr_SET(r,d) (r).auto_detect_medium[0] = d
#define BCM5464_AUTO_DETECT_MEDIUMr_GET(r) (r).auto_detect_medium[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM5464_AUTO_DETECT_MEDIUMr_AUTO_DETECT_MEDIUMf_GET(r) (((r).auto_detect_medium[0]) & 0xffff)
#define BCM5464_AUTO_DETECT_MEDIUMr_AUTO_DETECT_MEDIUMf_SET(r,f) (r).auto_detect_medium[0]=(((r).auto_detect_medium[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access AUTO_DETECT_MEDIUM.
 *
 */
#define BCM5464_READ_AUTO_DETECT_MEDIUMr(_pc,_r) phy_brcm_shadow_read(_pc,BCM5464_AUTO_DETECT_MEDIUMr,(_r._auto_detect_medium))
#define BCM5464_WRITE_AUTO_DETECT_MEDIUMr(_pc,_r) phy_brcm_shadow_write(_pc,BCM5464_AUTO_DETECT_MEDIUMr,(_r._auto_detect_medium))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AUTO_DETECT_MEDIUMr BCM5464_AUTO_DETECT_MEDIUMr
#define AUTO_DETECT_MEDIUMr_SIZE BCM5464_AUTO_DETECT_MEDIUMr_SIZE
typedef BCM5464_AUTO_DETECT_MEDIUMr_t AUTO_DETECT_MEDIUMr_t;
#define AUTO_DETECT_MEDIUMr_CLR BCM5464_AUTO_DETECT_MEDIUMr_CLR
#define AUTO_DETECT_MEDIUMr_SET BCM5464_AUTO_DETECT_MEDIUMr_SET
#define AUTO_DETECT_MEDIUMr_GET BCM5464_AUTO_DETECT_MEDIUMr_GET
#define AUTO_DETECT_MEDIUMr_AUTO_DETECT_MEDIUMf_GET BCM5464_AUTO_DETECT_MEDIUMr_AUTO_DETECT_MEDIUMf_GET
#define AUTO_DETECT_MEDIUMr_AUTO_DETECT_MEDIUMf_SET BCM5464_AUTO_DETECT_MEDIUMr_AUTO_DETECT_MEDIUMf_SET
#define READ_AUTO_DETECT_MEDIUMr BCM5464_READ_AUTO_DETECT_MEDIUMr
#define WRITE_AUTO_DETECT_MEDIUMr BCM5464_WRITE_AUTO_DETECT_MEDIUMr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM5464_AUTO_DETECT_MEDIUMr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM5464
 * REGISTER:  MODE_CTRL
 * BLOCKS:   USER
 * REGADDR:  0x001c
 * DESC:     Mode Control Reg (Addr 1Ch shadow 11111b)
 * SIZE:     32
 * FIELDS:
 *     MODE_CTRL        MODE_CTRL
 *
 ******************************************************************************/
#define BCM5464_MODE_CTRLr (0x00001f1c | PHY_REG_ACC_BRCM_SHADOW)

#define BCM5464_MODE_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program MODE_CTRL.
 *
 */
typedef union BCM5464_MODE_CTRLr_s {
	uint32_t v[1];
	uint32_t mode_ctrl[1];
	uint32_t _mode_ctrl;
} BCM5464_MODE_CTRLr_t;

#define BCM5464_MODE_CTRLr_CLR(r) (r).mode_ctrl[0] = 0
#define BCM5464_MODE_CTRLr_SET(r,d) (r).mode_ctrl[0] = d
#define BCM5464_MODE_CTRLr_GET(r) (r).mode_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM5464_MODE_CTRLr_MODE_CTRLf_GET(r) (((r).mode_ctrl[0]) & 0xffff)
#define BCM5464_MODE_CTRLr_MODE_CTRLf_SET(r,f) (r).mode_ctrl[0]=(((r).mode_ctrl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access MODE_CTRL.
 *
 */
#define BCM5464_READ_MODE_CTRLr(_pc,_r) phy_brcm_shadow_read(_pc,BCM5464_MODE_CTRLr,(_r._mode_ctrl))
#define BCM5464_WRITE_MODE_CTRLr(_pc,_r) phy_brcm_shadow_write(_pc,BCM5464_MODE_CTRLr,(_r._mode_ctrl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MODE_CTRLr BCM5464_MODE_CTRLr
#define MODE_CTRLr_SIZE BCM5464_MODE_CTRLr_SIZE
typedef BCM5464_MODE_CTRLr_t MODE_CTRLr_t;
#define MODE_CTRLr_CLR BCM5464_MODE_CTRLr_CLR
#define MODE_CTRLr_SET BCM5464_MODE_CTRLr_SET
#define MODE_CTRLr_GET BCM5464_MODE_CTRLr_GET
#define MODE_CTRLr_MODE_CTRLf_GET BCM5464_MODE_CTRLr_MODE_CTRLf_GET
#define MODE_CTRLr_MODE_CTRLf_SET BCM5464_MODE_CTRLr_MODE_CTRLf_SET
#define READ_MODE_CTRLr BCM5464_READ_MODE_CTRLr
#define WRITE_MODE_CTRLr BCM5464_WRITE_MODE_CTRLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM5464_MODE_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM5464
 * REGISTER:  TEST1
 * BLOCKS:   USER
 * REGADDR:  0x001e
 * DESC:     1000BASE-T/100BASE-TX/10BASE-T Test Register 1 (Addr 1Eh)
 * SIZE:     32
 * FIELDS:
 *     TEST1            TEST1
 *
 ******************************************************************************/
#define BCM5464_TEST1r (0x0000001e | PHY_REG_ACC_RAW)

#define BCM5464_TEST1r_SIZE 4

/*
 * This structure should be used to declare and program TEST1.
 *
 */
typedef union BCM5464_TEST1r_s {
	uint32_t v[1];
	uint32_t test1[1];
	uint32_t _test1;
} BCM5464_TEST1r_t;

#define BCM5464_TEST1r_CLR(r) (r).test1[0] = 0
#define BCM5464_TEST1r_SET(r,d) (r).test1[0] = d
#define BCM5464_TEST1r_GET(r) (r).test1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM5464_TEST1r_TEST1f_GET(r) (((r).test1[0]) & 0xffff)
#define BCM5464_TEST1r_TEST1f_SET(r,f) (r).test1[0]=(((r).test1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access TEST1.
 *
 */
#define BCM5464_READ_TEST1r(_pc,_r) PHY_REG_READ(_pc,BCM5464_TEST1r,_r._test1)
#define BCM5464_WRITE_TEST1r(_pc,_r) PHY_REG_WRITE(_pc,BCM5464_TEST1r,_r._test1)

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TEST1r BCM5464_TEST1r
#define TEST1r_SIZE BCM5464_TEST1r_SIZE
typedef BCM5464_TEST1r_t TEST1r_t;
#define TEST1r_CLR BCM5464_TEST1r_CLR
#define TEST1r_SET BCM5464_TEST1r_SET
#define TEST1r_GET BCM5464_TEST1r_GET
#define TEST1r_TEST1f_GET BCM5464_TEST1r_TEST1f_GET
#define TEST1r_TEST1f_SET BCM5464_TEST1r_TEST1f_SET
#define READ_TEST1r BCM5464_READ_TEST1r
#define WRITE_TEST1r BCM5464_WRITE_TEST1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM5464_TEST1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM5464
 * REGISTER:  MII_1000X_CTRL
 * BLOCKS:   IEEE
 * REGADDR:  0x0000
 * DESC:     1000BASE-X MII Control Register (Addr 00h)
 * SIZE:     32
 * FIELDS:
 *     RESERVED         Write as 1, ignore on read.
 *     COLL_TEST_EN     Enable collision test mode.
 *     FULL_DUPLEX      Full duplex operation.
 *     RESTART_AN       Restart auto-negotiation.
 *     ISOLATE          Isolate PHY from GMII/RGMII/RTBI.
 *     POWER_DOWN       Power down.
 *     AUTONEG          Auto-negotiation enabled.
 *     LOOPBACK         Loopback mode.
 *     RESET            PHY reset.
 *
 ******************************************************************************/
#define BCM5464_MII_1000X_CTRLr (0x00000000 | PHY_REG_ACC_BRCM_1000X)

#define BCM5464_MII_1000X_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program MII_1000X_CTRL.
 *
 */
typedef union BCM5464_MII_1000X_CTRLr_s {
	uint32_t v[1];
	uint32_t mii_1000x_ctrl[1];
	uint32_t _mii_1000x_ctrl;
} BCM5464_MII_1000X_CTRLr_t;

#define BCM5464_MII_1000X_CTRLr_CLR(r) (r).mii_1000x_ctrl[0] = 0
#define BCM5464_MII_1000X_CTRLr_SET(r,d) (r).mii_1000x_ctrl[0] = d
#define BCM5464_MII_1000X_CTRLr_GET(r) (r).mii_1000x_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM5464_MII_1000X_CTRLr_RESETf_GET(r) ((((r).mii_1000x_ctrl[0]) >> 15) & 0x1)
#define BCM5464_MII_1000X_CTRLr_RESETf_SET(r,f) (r).mii_1000x_ctrl[0]=(((r).mii_1000x_ctrl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM5464_MII_1000X_CTRLr_LOOPBACKf_GET(r) ((((r).mii_1000x_ctrl[0]) >> 14) & 0x1)
#define BCM5464_MII_1000X_CTRLr_LOOPBACKf_SET(r,f) (r).mii_1000x_ctrl[0]=(((r).mii_1000x_ctrl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM5464_MII_1000X_CTRLr_AUTONEGf_GET(r) ((((r).mii_1000x_ctrl[0]) >> 12) & 0x1)
#define BCM5464_MII_1000X_CTRLr_AUTONEGf_SET(r,f) (r).mii_1000x_ctrl[0]=(((r).mii_1000x_ctrl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM5464_MII_1000X_CTRLr_POWER_DOWNf_GET(r) ((((r).mii_1000x_ctrl[0]) >> 11) & 0x1)
#define BCM5464_MII_1000X_CTRLr_POWER_DOWNf_SET(r,f) (r).mii_1000x_ctrl[0]=(((r).mii_1000x_ctrl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM5464_MII_1000X_CTRLr_ISOLATEf_GET(r) ((((r).mii_1000x_ctrl[0]) >> 10) & 0x1)
#define BCM5464_MII_1000X_CTRLr_ISOLATEf_SET(r,f) (r).mii_1000x_ctrl[0]=(((r).mii_1000x_ctrl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM5464_MII_1000X_CTRLr_RESTART_ANf_GET(r) ((((r).mii_1000x_ctrl[0]) >> 9) & 0x1)
#define BCM5464_MII_1000X_CTRLr_RESTART_ANf_SET(r,f) (r).mii_1000x_ctrl[0]=(((r).mii_1000x_ctrl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM5464_MII_1000X_CTRLr_FULL_DUPLEXf_GET(r) ((((r).mii_1000x_ctrl[0]) >> 8) & 0x1)
#define BCM5464_MII_1000X_CTRLr_FULL_DUPLEXf_SET(r,f) (r).mii_1000x_ctrl[0]=(((r).mii_1000x_ctrl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM5464_MII_1000X_CTRLr_COLL_TEST_ENf_GET(r) ((((r).mii_1000x_ctrl[0]) >> 7) & 0x1)
#define BCM5464_MII_1000X_CTRLr_COLL_TEST_ENf_SET(r,f) (r).mii_1000x_ctrl[0]=(((r).mii_1000x_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM5464_MII_1000X_CTRLr_RESERVEDf_GET(r) ((((r).mii_1000x_ctrl[0]) >> 6) & 0x1)
#define BCM5464_MII_1000X_CTRLr_RESERVEDf_SET(r,f) (r).mii_1000x_ctrl[0]=(((r).mii_1000x_ctrl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))

/*
 * These macros can be used to access MII_1000X_CTRL.
 *
 */
#define BCM5464_READ_MII_1000X_CTRLr(_pc,_r) phy_brcm_1000x_read(_pc,BCM5464_MII_1000X_CTRLr,(_r._mii_1000x_ctrl))
#define BCM5464_WRITE_MII_1000X_CTRLr(_pc,_r) phy_brcm_1000x_write(_pc,BCM5464_MII_1000X_CTRLr,(_r._mii_1000x_ctrl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MII_1000X_CTRLr BCM5464_MII_1000X_CTRLr
#define MII_1000X_CTRLr_SIZE BCM5464_MII_1000X_CTRLr_SIZE
typedef BCM5464_MII_1000X_CTRLr_t MII_1000X_CTRLr_t;
#define MII_1000X_CTRLr_CLR BCM5464_MII_1000X_CTRLr_CLR
#define MII_1000X_CTRLr_SET BCM5464_MII_1000X_CTRLr_SET
#define MII_1000X_CTRLr_GET BCM5464_MII_1000X_CTRLr_GET
#define MII_1000X_CTRLr_RESETf_GET BCM5464_MII_1000X_CTRLr_RESETf_GET
#define MII_1000X_CTRLr_RESETf_SET BCM5464_MII_1000X_CTRLr_RESETf_SET
#define MII_1000X_CTRLr_LOOPBACKf_GET BCM5464_MII_1000X_CTRLr_LOOPBACKf_GET
#define MII_1000X_CTRLr_LOOPBACKf_SET BCM5464_MII_1000X_CTRLr_LOOPBACKf_SET
#define MII_1000X_CTRLr_AUTONEGf_GET BCM5464_MII_1000X_CTRLr_AUTONEGf_GET
#define MII_1000X_CTRLr_AUTONEGf_SET BCM5464_MII_1000X_CTRLr_AUTONEGf_SET
#define MII_1000X_CTRLr_POWER_DOWNf_GET BCM5464_MII_1000X_CTRLr_POWER_DOWNf_GET
#define MII_1000X_CTRLr_POWER_DOWNf_SET BCM5464_MII_1000X_CTRLr_POWER_DOWNf_SET
#define MII_1000X_CTRLr_ISOLATEf_GET BCM5464_MII_1000X_CTRLr_ISOLATEf_GET
#define MII_1000X_CTRLr_ISOLATEf_SET BCM5464_MII_1000X_CTRLr_ISOLATEf_SET
#define MII_1000X_CTRLr_RESTART_ANf_GET BCM5464_MII_1000X_CTRLr_RESTART_ANf_GET
#define MII_1000X_CTRLr_RESTART_ANf_SET BCM5464_MII_1000X_CTRLr_RESTART_ANf_SET
#define MII_1000X_CTRLr_FULL_DUPLEXf_GET BCM5464_MII_1000X_CTRLr_FULL_DUPLEXf_GET
#define MII_1000X_CTRLr_FULL_DUPLEXf_SET BCM5464_MII_1000X_CTRLr_FULL_DUPLEXf_SET
#define MII_1000X_CTRLr_COLL_TEST_ENf_GET BCM5464_MII_1000X_CTRLr_COLL_TEST_ENf_GET
#define MII_1000X_CTRLr_COLL_TEST_ENf_SET BCM5464_MII_1000X_CTRLr_COLL_TEST_ENf_SET
#define MII_1000X_CTRLr_RESERVEDf_GET BCM5464_MII_1000X_CTRLr_RESERVEDf_GET
#define MII_1000X_CTRLr_RESERVEDf_SET BCM5464_MII_1000X_CTRLr_RESERVEDf_SET
#define READ_MII_1000X_CTRLr BCM5464_READ_MII_1000X_CTRLr
#define WRITE_MII_1000X_CTRLr BCM5464_WRITE_MII_1000X_CTRLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM5464_MII_1000X_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM5464
 * REGISTER:  MII_1000X_STAT
 * BLOCKS:   IEEE
 * REGADDR:  0x0001
 * DESC:     1000BASE-X MII Status Register (Addr 01h)
 * SIZE:     32
 * FIELDS:
 *     EXT_CAPABILITY   Extended register capabilities.
 *     JABBER_DETECT    Jabber condition detected.
 *     LINK             Link is up.
 *     AUTONEG_ABILITY  Auto-negotiation capable.
 *     REMOTE_FAULT     Remote fault detected.
 *     AUTONEG_DONE     Auto-negotiation complete.
 *     MF_PREAMBLE_SUP  Preamble can be suppressed.
 *     EXT_STATUS       Extended status information in register 0Fh.
 *     CAP_100BASE_T2_HD 100BASE-T2 half-duplex capable.
 *     CAP_100BASE_T2_FD 100BASE-T2 full-duplex capable.
 *     CAP_10BASE_T_HD  10BASE-T half-duplex capable.
 *     CAP_10BASE_T_FD  10BASE-T full-duplex capable.
 *     CAP_100BASE_X_HD 100BASE-X half-duplex capable.
 *     CAP_100BASE_X_FD 100BASE-X full-duplex capable.
 *     CAP_100BASE_T4   100BASE-T4 capable.
 *
 ******************************************************************************/
#define BCM5464_MII_1000X_STATr (0x00000001 | PHY_REG_ACC_BRCM_1000X)

#define BCM5464_MII_1000X_STATr_SIZE 4

/*
 * This structure should be used to declare and program MII_1000X_STAT.
 *
 */
typedef union BCM5464_MII_1000X_STATr_s {
	uint32_t v[1];
	uint32_t mii_1000x_stat[1];
	uint32_t _mii_1000x_stat;
} BCM5464_MII_1000X_STATr_t;

#define BCM5464_MII_1000X_STATr_CLR(r) (r).mii_1000x_stat[0] = 0
#define BCM5464_MII_1000X_STATr_SET(r,d) (r).mii_1000x_stat[0] = d
#define BCM5464_MII_1000X_STATr_GET(r) (r).mii_1000x_stat[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM5464_MII_1000X_STATr_CAP_100BASE_T4f_GET(r) ((((r).mii_1000x_stat[0]) >> 15) & 0x1)
#define BCM5464_MII_1000X_STATr_CAP_100BASE_T4f_SET(r,f) (r).mii_1000x_stat[0]=(((r).mii_1000x_stat[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM5464_MII_1000X_STATr_CAP_100BASE_X_FDf_GET(r) ((((r).mii_1000x_stat[0]) >> 14) & 0x1)
#define BCM5464_MII_1000X_STATr_CAP_100BASE_X_FDf_SET(r,f) (r).mii_1000x_stat[0]=(((r).mii_1000x_stat[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM5464_MII_1000X_STATr_CAP_100BASE_X_HDf_GET(r) ((((r).mii_1000x_stat[0]) >> 13) & 0x1)
#define BCM5464_MII_1000X_STATr_CAP_100BASE_X_HDf_SET(r,f) (r).mii_1000x_stat[0]=(((r).mii_1000x_stat[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM5464_MII_1000X_STATr_CAP_10BASE_T_FDf_GET(r) ((((r).mii_1000x_stat[0]) >> 12) & 0x1)
#define BCM5464_MII_1000X_STATr_CAP_10BASE_T_FDf_SET(r,f) (r).mii_1000x_stat[0]=(((r).mii_1000x_stat[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM5464_MII_1000X_STATr_CAP_10BASE_T_HDf_GET(r) ((((r).mii_1000x_stat[0]) >> 11) & 0x1)
#define BCM5464_MII_1000X_STATr_CAP_10BASE_T_HDf_SET(r,f) (r).mii_1000x_stat[0]=(((r).mii_1000x_stat[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM5464_MII_1000X_STATr_CAP_100BASE_T2_FDf_GET(r) ((((r).mii_1000x_stat[0]) >> 10) & 0x1)
#define BCM5464_MII_1000X_STATr_CAP_100BASE_T2_FDf_SET(r,f) (r).mii_1000x_stat[0]=(((r).mii_1000x_stat[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM5464_MII_1000X_STATr_CAP_100BASE_T2_HDf_GET(r) ((((r).mii_1000x_stat[0]) >> 9) & 0x1)
#define BCM5464_MII_1000X_STATr_CAP_100BASE_T2_HDf_SET(r,f) (r).mii_1000x_stat[0]=(((r).mii_1000x_stat[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM5464_MII_1000X_STATr_EXT_STATUSf_GET(r) ((((r).mii_1000x_stat[0]) >> 8) & 0x1)
#define BCM5464_MII_1000X_STATr_EXT_STATUSf_SET(r,f) (r).mii_1000x_stat[0]=(((r).mii_1000x_stat[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM5464_MII_1000X_STATr_MF_PREAMBLE_SUPf_GET(r) ((((r).mii_1000x_stat[0]) >> 6) & 0x1)
#define BCM5464_MII_1000X_STATr_MF_PREAMBLE_SUPf_SET(r,f) (r).mii_1000x_stat[0]=(((r).mii_1000x_stat[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM5464_MII_1000X_STATr_AUTONEG_DONEf_GET(r) ((((r).mii_1000x_stat[0]) >> 5) & 0x1)
#define BCM5464_MII_1000X_STATr_AUTONEG_DONEf_SET(r,f) (r).mii_1000x_stat[0]=(((r).mii_1000x_stat[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM5464_MII_1000X_STATr_REMOTE_FAULTf_GET(r) ((((r).mii_1000x_stat[0]) >> 4) & 0x1)
#define BCM5464_MII_1000X_STATr_REMOTE_FAULTf_SET(r,f) (r).mii_1000x_stat[0]=(((r).mii_1000x_stat[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM5464_MII_1000X_STATr_AUTONEG_ABILITYf_GET(r) ((((r).mii_1000x_stat[0]) >> 3) & 0x1)
#define BCM5464_MII_1000X_STATr_AUTONEG_ABILITYf_SET(r,f) (r).mii_1000x_stat[0]=(((r).mii_1000x_stat[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM5464_MII_1000X_STATr_LINKf_GET(r) ((((r).mii_1000x_stat[0]) >> 2) & 0x1)
#define BCM5464_MII_1000X_STATr_LINKf_SET(r,f) (r).mii_1000x_stat[0]=(((r).mii_1000x_stat[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM5464_MII_1000X_STATr_JABBER_DETECTf_GET(r) ((((r).mii_1000x_stat[0]) >> 1) & 0x1)
#define BCM5464_MII_1000X_STATr_JABBER_DETECTf_SET(r,f) (r).mii_1000x_stat[0]=(((r).mii_1000x_stat[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM5464_MII_1000X_STATr_EXT_CAPABILITYf_GET(r) (((r).mii_1000x_stat[0]) & 0x1)
#define BCM5464_MII_1000X_STATr_EXT_CAPABILITYf_SET(r,f) (r).mii_1000x_stat[0]=(((r).mii_1000x_stat[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access MII_1000X_STAT.
 *
 */
#define BCM5464_READ_MII_1000X_STATr(_pc,_r) phy_brcm_1000x_read(_pc,BCM5464_MII_1000X_STATr,(_r._mii_1000x_stat))
#define BCM5464_WRITE_MII_1000X_STATr(_pc,_r) phy_brcm_1000x_write(_pc,BCM5464_MII_1000X_STATr,(_r._mii_1000x_stat))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MII_1000X_STATr BCM5464_MII_1000X_STATr
#define MII_1000X_STATr_SIZE BCM5464_MII_1000X_STATr_SIZE
typedef BCM5464_MII_1000X_STATr_t MII_1000X_STATr_t;
#define MII_1000X_STATr_CLR BCM5464_MII_1000X_STATr_CLR
#define MII_1000X_STATr_SET BCM5464_MII_1000X_STATr_SET
#define MII_1000X_STATr_GET BCM5464_MII_1000X_STATr_GET
#define MII_1000X_STATr_CAP_100BASE_T4f_GET BCM5464_MII_1000X_STATr_CAP_100BASE_T4f_GET
#define MII_1000X_STATr_CAP_100BASE_T4f_SET BCM5464_MII_1000X_STATr_CAP_100BASE_T4f_SET
#define MII_1000X_STATr_CAP_100BASE_X_FDf_GET BCM5464_MII_1000X_STATr_CAP_100BASE_X_FDf_GET
#define MII_1000X_STATr_CAP_100BASE_X_FDf_SET BCM5464_MII_1000X_STATr_CAP_100BASE_X_FDf_SET
#define MII_1000X_STATr_CAP_100BASE_X_HDf_GET BCM5464_MII_1000X_STATr_CAP_100BASE_X_HDf_GET
#define MII_1000X_STATr_CAP_100BASE_X_HDf_SET BCM5464_MII_1000X_STATr_CAP_100BASE_X_HDf_SET
#define MII_1000X_STATr_CAP_10BASE_T_FDf_GET BCM5464_MII_1000X_STATr_CAP_10BASE_T_FDf_GET
#define MII_1000X_STATr_CAP_10BASE_T_FDf_SET BCM5464_MII_1000X_STATr_CAP_10BASE_T_FDf_SET
#define MII_1000X_STATr_CAP_10BASE_T_HDf_GET BCM5464_MII_1000X_STATr_CAP_10BASE_T_HDf_GET
#define MII_1000X_STATr_CAP_10BASE_T_HDf_SET BCM5464_MII_1000X_STATr_CAP_10BASE_T_HDf_SET
#define MII_1000X_STATr_CAP_100BASE_T2_FDf_GET BCM5464_MII_1000X_STATr_CAP_100BASE_T2_FDf_GET
#define MII_1000X_STATr_CAP_100BASE_T2_FDf_SET BCM5464_MII_1000X_STATr_CAP_100BASE_T2_FDf_SET
#define MII_1000X_STATr_CAP_100BASE_T2_HDf_GET BCM5464_MII_1000X_STATr_CAP_100BASE_T2_HDf_GET
#define MII_1000X_STATr_CAP_100BASE_T2_HDf_SET BCM5464_MII_1000X_STATr_CAP_100BASE_T2_HDf_SET
#define MII_1000X_STATr_EXT_STATUSf_GET BCM5464_MII_1000X_STATr_EXT_STATUSf_GET
#define MII_1000X_STATr_EXT_STATUSf_SET BCM5464_MII_1000X_STATr_EXT_STATUSf_SET
#define MII_1000X_STATr_MF_PREAMBLE_SUPf_GET BCM5464_MII_1000X_STATr_MF_PREAMBLE_SUPf_GET
#define MII_1000X_STATr_MF_PREAMBLE_SUPf_SET BCM5464_MII_1000X_STATr_MF_PREAMBLE_SUPf_SET
#define MII_1000X_STATr_AUTONEG_DONEf_GET BCM5464_MII_1000X_STATr_AUTONEG_DONEf_GET
#define MII_1000X_STATr_AUTONEG_DONEf_SET BCM5464_MII_1000X_STATr_AUTONEG_DONEf_SET
#define MII_1000X_STATr_REMOTE_FAULTf_GET BCM5464_MII_1000X_STATr_REMOTE_FAULTf_GET
#define MII_1000X_STATr_REMOTE_FAULTf_SET BCM5464_MII_1000X_STATr_REMOTE_FAULTf_SET
#define MII_1000X_STATr_AUTONEG_ABILITYf_GET BCM5464_MII_1000X_STATr_AUTONEG_ABILITYf_GET
#define MII_1000X_STATr_AUTONEG_ABILITYf_SET BCM5464_MII_1000X_STATr_AUTONEG_ABILITYf_SET
#define MII_1000X_STATr_LINKf_GET BCM5464_MII_1000X_STATr_LINKf_GET
#define MII_1000X_STATr_LINKf_SET BCM5464_MII_1000X_STATr_LINKf_SET
#define MII_1000X_STATr_JABBER_DETECTf_GET BCM5464_MII_1000X_STATr_JABBER_DETECTf_GET
#define MII_1000X_STATr_JABBER_DETECTf_SET BCM5464_MII_1000X_STATr_JABBER_DETECTf_SET
#define MII_1000X_STATr_EXT_CAPABILITYf_GET BCM5464_MII_1000X_STATr_EXT_CAPABILITYf_GET
#define MII_1000X_STATr_EXT_CAPABILITYf_SET BCM5464_MII_1000X_STATr_EXT_CAPABILITYf_SET
#define READ_MII_1000X_STATr BCM5464_READ_MII_1000X_STATr
#define WRITE_MII_1000X_STATr BCM5464_WRITE_MII_1000X_STATr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM5464_MII_1000X_STATr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM5464
 * REGISTER:  MII_1000X_ANA
 * BLOCKS:   IEEE
 * REGADDR:  0x0004
 * DESC:     1000BASE-X MII Auto-Negotiation Advertise Register (Addr 04h)
 * SIZE:     32
 * FIELDS:
 *     CAP_1000BASE_X_FD 1000BASE-X full-duplex capable.
 *     CAP_1000BASE_X_HD 1000BASE-X half-duplex capable.
 *     PAUSE            Pause capable.
 *     REMOTE_FAULT     Advertise remote fault detected.
 *
 ******************************************************************************/
#define BCM5464_MII_1000X_ANAr (0x00000004 | PHY_REG_ACC_BRCM_1000X)

#define BCM5464_MII_1000X_ANAr_SIZE 4

/*
 * This structure should be used to declare and program MII_1000X_ANA.
 *
 */
typedef union BCM5464_MII_1000X_ANAr_s {
	uint32_t v[1];
	uint32_t mii_1000x_ana[1];
	uint32_t _mii_1000x_ana;
} BCM5464_MII_1000X_ANAr_t;

#define BCM5464_MII_1000X_ANAr_CLR(r) (r).mii_1000x_ana[0] = 0
#define BCM5464_MII_1000X_ANAr_SET(r,d) (r).mii_1000x_ana[0] = d
#define BCM5464_MII_1000X_ANAr_GET(r) (r).mii_1000x_ana[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM5464_MII_1000X_ANAr_REMOTE_FAULTf_GET(r) ((((r).mii_1000x_ana[0]) >> 13) & 0x1)
#define BCM5464_MII_1000X_ANAr_REMOTE_FAULTf_SET(r,f) (r).mii_1000x_ana[0]=(((r).mii_1000x_ana[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM5464_MII_1000X_ANAr_PAUSEf_GET(r) ((((r).mii_1000x_ana[0]) >> 7) & 0x3)
#define BCM5464_MII_1000X_ANAr_PAUSEf_SET(r,f) (r).mii_1000x_ana[0]=(((r).mii_1000x_ana[0] & ~((uint32_t)0x3 << 7)) | ((((uint32_t)f) & 0x3) << 7))
#define BCM5464_MII_1000X_ANAr_CAP_1000BASE_X_HDf_GET(r) ((((r).mii_1000x_ana[0]) >> 6) & 0x1)
#define BCM5464_MII_1000X_ANAr_CAP_1000BASE_X_HDf_SET(r,f) (r).mii_1000x_ana[0]=(((r).mii_1000x_ana[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM5464_MII_1000X_ANAr_CAP_1000BASE_X_FDf_GET(r) ((((r).mii_1000x_ana[0]) >> 5) & 0x1)
#define BCM5464_MII_1000X_ANAr_CAP_1000BASE_X_FDf_SET(r,f) (r).mii_1000x_ana[0]=(((r).mii_1000x_ana[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))

/*
 * These macros can be used to access MII_1000X_ANA.
 *
 */
#define BCM5464_READ_MII_1000X_ANAr(_pc,_r) phy_brcm_1000x_read(_pc,BCM5464_MII_1000X_ANAr,(_r._mii_1000x_ana))
#define BCM5464_WRITE_MII_1000X_ANAr(_pc,_r) phy_brcm_1000x_write(_pc,BCM5464_MII_1000X_ANAr,(_r._mii_1000x_ana))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MII_1000X_ANAr BCM5464_MII_1000X_ANAr
#define MII_1000X_ANAr_SIZE BCM5464_MII_1000X_ANAr_SIZE
typedef BCM5464_MII_1000X_ANAr_t MII_1000X_ANAr_t;
#define MII_1000X_ANAr_CLR BCM5464_MII_1000X_ANAr_CLR
#define MII_1000X_ANAr_SET BCM5464_MII_1000X_ANAr_SET
#define MII_1000X_ANAr_GET BCM5464_MII_1000X_ANAr_GET
#define MII_1000X_ANAr_REMOTE_FAULTf_GET BCM5464_MII_1000X_ANAr_REMOTE_FAULTf_GET
#define MII_1000X_ANAr_REMOTE_FAULTf_SET BCM5464_MII_1000X_ANAr_REMOTE_FAULTf_SET
#define MII_1000X_ANAr_PAUSEf_GET BCM5464_MII_1000X_ANAr_PAUSEf_GET
#define MII_1000X_ANAr_PAUSEf_SET BCM5464_MII_1000X_ANAr_PAUSEf_SET
#define MII_1000X_ANAr_CAP_1000BASE_X_HDf_GET BCM5464_MII_1000X_ANAr_CAP_1000BASE_X_HDf_GET
#define MII_1000X_ANAr_CAP_1000BASE_X_HDf_SET BCM5464_MII_1000X_ANAr_CAP_1000BASE_X_HDf_SET
#define MII_1000X_ANAr_CAP_1000BASE_X_FDf_GET BCM5464_MII_1000X_ANAr_CAP_1000BASE_X_FDf_GET
#define MII_1000X_ANAr_CAP_1000BASE_X_FDf_SET BCM5464_MII_1000X_ANAr_CAP_1000BASE_X_FDf_SET
#define READ_MII_1000X_ANAr BCM5464_READ_MII_1000X_ANAr
#define WRITE_MII_1000X_ANAr BCM5464_WRITE_MII_1000X_ANAr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM5464_MII_1000X_ANAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM5464
 * REGISTER:  MII_1000X_ANP
 * BLOCKS:   IEEE
 * REGADDR:  0x0005
 * DESC:     1000BASE-X MII Auto-Negotiation Link Partner Ability Register (Addr 05h)
 * SIZE:     32
 * FIELDS:
 *     CAP_1000BASE_X_FD 1000BASE-X full-duplex capable.
 *     CAP_1000BASE_X_HD 1000BASE-X half-duplex capable.
 *     PAUSE            Pause capable.
 *     REMOTE_FAULT     Link partner has detected remote fault.
 *     ACK              Link partner has received link code word.
 *     NEXT_PAGE        Link partner has Next Page ability.
 *
 ******************************************************************************/
#define BCM5464_MII_1000X_ANPr (0x00000005 | PHY_REG_ACC_BRCM_1000X)

#define BCM5464_MII_1000X_ANPr_SIZE 4

/*
 * This structure should be used to declare and program MII_1000X_ANP.
 *
 */
typedef union BCM5464_MII_1000X_ANPr_s {
	uint32_t v[1];
	uint32_t mii_1000x_anp[1];
	uint32_t _mii_1000x_anp;
} BCM5464_MII_1000X_ANPr_t;

#define BCM5464_MII_1000X_ANPr_CLR(r) (r).mii_1000x_anp[0] = 0
#define BCM5464_MII_1000X_ANPr_SET(r,d) (r).mii_1000x_anp[0] = d
#define BCM5464_MII_1000X_ANPr_GET(r) (r).mii_1000x_anp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM5464_MII_1000X_ANPr_NEXT_PAGEf_GET(r) ((((r).mii_1000x_anp[0]) >> 15) & 0x1)
#define BCM5464_MII_1000X_ANPr_NEXT_PAGEf_SET(r,f) (r).mii_1000x_anp[0]=(((r).mii_1000x_anp[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM5464_MII_1000X_ANPr_ACKf_GET(r) ((((r).mii_1000x_anp[0]) >> 14) & 0x1)
#define BCM5464_MII_1000X_ANPr_ACKf_SET(r,f) (r).mii_1000x_anp[0]=(((r).mii_1000x_anp[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM5464_MII_1000X_ANPr_REMOTE_FAULTf_GET(r) ((((r).mii_1000x_anp[0]) >> 13) & 0x1)
#define BCM5464_MII_1000X_ANPr_REMOTE_FAULTf_SET(r,f) (r).mii_1000x_anp[0]=(((r).mii_1000x_anp[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM5464_MII_1000X_ANPr_PAUSEf_GET(r) ((((r).mii_1000x_anp[0]) >> 7) & 0x3)
#define BCM5464_MII_1000X_ANPr_PAUSEf_SET(r,f) (r).mii_1000x_anp[0]=(((r).mii_1000x_anp[0] & ~((uint32_t)0x3 << 7)) | ((((uint32_t)f) & 0x3) << 7))
#define BCM5464_MII_1000X_ANPr_CAP_1000BASE_X_HDf_GET(r) ((((r).mii_1000x_anp[0]) >> 6) & 0x1)
#define BCM5464_MII_1000X_ANPr_CAP_1000BASE_X_HDf_SET(r,f) (r).mii_1000x_anp[0]=(((r).mii_1000x_anp[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM5464_MII_1000X_ANPr_CAP_1000BASE_X_FDf_GET(r) ((((r).mii_1000x_anp[0]) >> 5) & 0x1)
#define BCM5464_MII_1000X_ANPr_CAP_1000BASE_X_FDf_SET(r,f) (r).mii_1000x_anp[0]=(((r).mii_1000x_anp[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))

/*
 * These macros can be used to access MII_1000X_ANP.
 *
 */
#define BCM5464_READ_MII_1000X_ANPr(_pc,_r) phy_brcm_1000x_read(_pc,BCM5464_MII_1000X_ANPr,(_r._mii_1000x_anp))
#define BCM5464_WRITE_MII_1000X_ANPr(_pc,_r) phy_brcm_1000x_write(_pc,BCM5464_MII_1000X_ANPr,(_r._mii_1000x_anp))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MII_1000X_ANPr BCM5464_MII_1000X_ANPr
#define MII_1000X_ANPr_SIZE BCM5464_MII_1000X_ANPr_SIZE
typedef BCM5464_MII_1000X_ANPr_t MII_1000X_ANPr_t;
#define MII_1000X_ANPr_CLR BCM5464_MII_1000X_ANPr_CLR
#define MII_1000X_ANPr_SET BCM5464_MII_1000X_ANPr_SET
#define MII_1000X_ANPr_GET BCM5464_MII_1000X_ANPr_GET
#define MII_1000X_ANPr_NEXT_PAGEf_GET BCM5464_MII_1000X_ANPr_NEXT_PAGEf_GET
#define MII_1000X_ANPr_NEXT_PAGEf_SET BCM5464_MII_1000X_ANPr_NEXT_PAGEf_SET
#define MII_1000X_ANPr_ACKf_GET BCM5464_MII_1000X_ANPr_ACKf_GET
#define MII_1000X_ANPr_ACKf_SET BCM5464_MII_1000X_ANPr_ACKf_SET
#define MII_1000X_ANPr_REMOTE_FAULTf_GET BCM5464_MII_1000X_ANPr_REMOTE_FAULTf_GET
#define MII_1000X_ANPr_REMOTE_FAULTf_SET BCM5464_MII_1000X_ANPr_REMOTE_FAULTf_SET
#define MII_1000X_ANPr_PAUSEf_GET BCM5464_MII_1000X_ANPr_PAUSEf_GET
#define MII_1000X_ANPr_PAUSEf_SET BCM5464_MII_1000X_ANPr_PAUSEf_SET
#define MII_1000X_ANPr_CAP_1000BASE_X_HDf_GET BCM5464_MII_1000X_ANPr_CAP_1000BASE_X_HDf_GET
#define MII_1000X_ANPr_CAP_1000BASE_X_HDf_SET BCM5464_MII_1000X_ANPr_CAP_1000BASE_X_HDf_SET
#define MII_1000X_ANPr_CAP_1000BASE_X_FDf_GET BCM5464_MII_1000X_ANPr_CAP_1000BASE_X_FDf_GET
#define MII_1000X_ANPr_CAP_1000BASE_X_FDf_SET BCM5464_MII_1000X_ANPr_CAP_1000BASE_X_FDf_SET
#define READ_MII_1000X_ANPr BCM5464_READ_MII_1000X_ANPr
#define WRITE_MII_1000X_ANPr BCM5464_WRITE_MII_1000X_ANPr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM5464_MII_1000X_ANPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM5464
 * REGISTER:  MII_1000X_AN_EXP
 * BLOCKS:   IEEE
 * REGADDR:  0x0006
 * DESC:     1000BASE-X MII Auto-Negotiation Extended Status Register (Addr 06h)
 * SIZE:     32
 * FIELDS:
 *     PAGE_RECEIVED    New page has been receive from link partner.
 *     NEXT_PAGE        Local Next Page capability.
 *
 ******************************************************************************/
#define BCM5464_MII_1000X_AN_EXPr (0x00000006 | PHY_REG_ACC_BRCM_1000X)

#define BCM5464_MII_1000X_AN_EXPr_SIZE 4

/*
 * This structure should be used to declare and program MII_1000X_AN_EXP.
 *
 */
typedef union BCM5464_MII_1000X_AN_EXPr_s {
	uint32_t v[1];
	uint32_t mii_1000x_an_exp[1];
	uint32_t _mii_1000x_an_exp;
} BCM5464_MII_1000X_AN_EXPr_t;

#define BCM5464_MII_1000X_AN_EXPr_CLR(r) (r).mii_1000x_an_exp[0] = 0
#define BCM5464_MII_1000X_AN_EXPr_SET(r,d) (r).mii_1000x_an_exp[0] = d
#define BCM5464_MII_1000X_AN_EXPr_GET(r) (r).mii_1000x_an_exp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM5464_MII_1000X_AN_EXPr_NEXT_PAGEf_GET(r) ((((r).mii_1000x_an_exp[0]) >> 2) & 0x1)
#define BCM5464_MII_1000X_AN_EXPr_NEXT_PAGEf_SET(r,f) (r).mii_1000x_an_exp[0]=(((r).mii_1000x_an_exp[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM5464_MII_1000X_AN_EXPr_PAGE_RECEIVEDf_GET(r) ((((r).mii_1000x_an_exp[0]) >> 1) & 0x1)
#define BCM5464_MII_1000X_AN_EXPr_PAGE_RECEIVEDf_SET(r,f) (r).mii_1000x_an_exp[0]=(((r).mii_1000x_an_exp[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access MII_1000X_AN_EXP.
 *
 */
#define BCM5464_READ_MII_1000X_AN_EXPr(_pc,_r) phy_brcm_1000x_read(_pc,BCM5464_MII_1000X_AN_EXPr,(_r._mii_1000x_an_exp))
#define BCM5464_WRITE_MII_1000X_AN_EXPr(_pc,_r) phy_brcm_1000x_write(_pc,BCM5464_MII_1000X_AN_EXPr,(_r._mii_1000x_an_exp))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MII_1000X_AN_EXPr BCM5464_MII_1000X_AN_EXPr
#define MII_1000X_AN_EXPr_SIZE BCM5464_MII_1000X_AN_EXPr_SIZE
typedef BCM5464_MII_1000X_AN_EXPr_t MII_1000X_AN_EXPr_t;
#define MII_1000X_AN_EXPr_CLR BCM5464_MII_1000X_AN_EXPr_CLR
#define MII_1000X_AN_EXPr_SET BCM5464_MII_1000X_AN_EXPr_SET
#define MII_1000X_AN_EXPr_GET BCM5464_MII_1000X_AN_EXPr_GET
#define MII_1000X_AN_EXPr_NEXT_PAGEf_GET BCM5464_MII_1000X_AN_EXPr_NEXT_PAGEf_GET
#define MII_1000X_AN_EXPr_NEXT_PAGEf_SET BCM5464_MII_1000X_AN_EXPr_NEXT_PAGEf_SET
#define MII_1000X_AN_EXPr_PAGE_RECEIVEDf_GET BCM5464_MII_1000X_AN_EXPr_PAGE_RECEIVEDf_GET
#define MII_1000X_AN_EXPr_PAGE_RECEIVEDf_SET BCM5464_MII_1000X_AN_EXPr_PAGE_RECEIVEDf_SET
#define READ_MII_1000X_AN_EXPr BCM5464_READ_MII_1000X_AN_EXPr
#define WRITE_MII_1000X_AN_EXPr BCM5464_WRITE_MII_1000X_AN_EXPr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM5464_MII_1000X_AN_EXPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM5464
 * REGISTER:  MII_1000X_EXT_STAT
 * BLOCKS:   IEEE
 * REGADDR:  0x000f
 * DESC:     1000BASE-X MII IEEE Extended Status Register (Addr 0fh)
 * SIZE:     32
 * FIELDS:
 *     CAP_1000BASE_T_FD 1000BASE-T full-duplex capable.
 *     CAP_1000BASE_T_HD 1000BASE-T half-duplex capable.
 *     CAP_1000BASE_X_HD 1000BASE-X half-duplex capable.
 *     CAP_1000BASE_X_FD 1000BASE-X full-duplex capable.
 *
 ******************************************************************************/
#define BCM5464_MII_1000X_EXT_STATr (0x0000000f | PHY_REG_ACC_BRCM_1000X)

#define BCM5464_MII_1000X_EXT_STATr_SIZE 4

/*
 * This structure should be used to declare and program MII_1000X_EXT_STAT.
 *
 */
typedef union BCM5464_MII_1000X_EXT_STATr_s {
	uint32_t v[1];
	uint32_t mii_1000x_ext_stat[1];
	uint32_t _mii_1000x_ext_stat;
} BCM5464_MII_1000X_EXT_STATr_t;

#define BCM5464_MII_1000X_EXT_STATr_CLR(r) (r).mii_1000x_ext_stat[0] = 0
#define BCM5464_MII_1000X_EXT_STATr_SET(r,d) (r).mii_1000x_ext_stat[0] = d
#define BCM5464_MII_1000X_EXT_STATr_GET(r) (r).mii_1000x_ext_stat[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM5464_MII_1000X_EXT_STATr_CAP_1000BASE_X_FDf_GET(r) ((((r).mii_1000x_ext_stat[0]) >> 15) & 0x1)
#define BCM5464_MII_1000X_EXT_STATr_CAP_1000BASE_X_FDf_SET(r,f) (r).mii_1000x_ext_stat[0]=(((r).mii_1000x_ext_stat[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM5464_MII_1000X_EXT_STATr_CAP_1000BASE_X_HDf_GET(r) ((((r).mii_1000x_ext_stat[0]) >> 14) & 0x1)
#define BCM5464_MII_1000X_EXT_STATr_CAP_1000BASE_X_HDf_SET(r,f) (r).mii_1000x_ext_stat[0]=(((r).mii_1000x_ext_stat[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM5464_MII_1000X_EXT_STATr_CAP_1000BASE_T_FDf_GET(r) ((((r).mii_1000x_ext_stat[0]) >> 5) & 0x1ff)
#define BCM5464_MII_1000X_EXT_STATr_CAP_1000BASE_T_FDf_SET(r,f) (r).mii_1000x_ext_stat[0]=(((r).mii_1000x_ext_stat[0] & ~((uint32_t)0x1ff << 5)) | ((((uint32_t)f) & 0x1ff) << 5))
#define BCM5464_MII_1000X_EXT_STATr_CAP_1000BASE_T_HDf_GET(r) ((((r).mii_1000x_ext_stat[0]) >> 12) & 0x1)
#define BCM5464_MII_1000X_EXT_STATr_CAP_1000BASE_T_HDf_SET(r,f) (r).mii_1000x_ext_stat[0]=(((r).mii_1000x_ext_stat[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))

/*
 * These macros can be used to access MII_1000X_EXT_STAT.
 *
 */
#define BCM5464_READ_MII_1000X_EXT_STATr(_pc,_r) phy_brcm_1000x_read(_pc,BCM5464_MII_1000X_EXT_STATr,(_r._mii_1000x_ext_stat))
#define BCM5464_WRITE_MII_1000X_EXT_STATr(_pc,_r) phy_brcm_1000x_write(_pc,BCM5464_MII_1000X_EXT_STATr,(_r._mii_1000x_ext_stat))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MII_1000X_EXT_STATr BCM5464_MII_1000X_EXT_STATr
#define MII_1000X_EXT_STATr_SIZE BCM5464_MII_1000X_EXT_STATr_SIZE
typedef BCM5464_MII_1000X_EXT_STATr_t MII_1000X_EXT_STATr_t;
#define MII_1000X_EXT_STATr_CLR BCM5464_MII_1000X_EXT_STATr_CLR
#define MII_1000X_EXT_STATr_SET BCM5464_MII_1000X_EXT_STATr_SET
#define MII_1000X_EXT_STATr_GET BCM5464_MII_1000X_EXT_STATr_GET
#define MII_1000X_EXT_STATr_CAP_1000BASE_X_FDf_GET BCM5464_MII_1000X_EXT_STATr_CAP_1000BASE_X_FDf_GET
#define MII_1000X_EXT_STATr_CAP_1000BASE_X_FDf_SET BCM5464_MII_1000X_EXT_STATr_CAP_1000BASE_X_FDf_SET
#define MII_1000X_EXT_STATr_CAP_1000BASE_X_HDf_GET BCM5464_MII_1000X_EXT_STATr_CAP_1000BASE_X_HDf_GET
#define MII_1000X_EXT_STATr_CAP_1000BASE_X_HDf_SET BCM5464_MII_1000X_EXT_STATr_CAP_1000BASE_X_HDf_SET
#define MII_1000X_EXT_STATr_CAP_1000BASE_T_FDf_GET BCM5464_MII_1000X_EXT_STATr_CAP_1000BASE_T_FDf_GET
#define MII_1000X_EXT_STATr_CAP_1000BASE_T_FDf_SET BCM5464_MII_1000X_EXT_STATr_CAP_1000BASE_T_FDf_SET
#define MII_1000X_EXT_STATr_CAP_1000BASE_T_HDf_GET BCM5464_MII_1000X_EXT_STATr_CAP_1000BASE_T_HDf_GET
#define MII_1000X_EXT_STATr_CAP_1000BASE_T_HDf_SET BCM5464_MII_1000X_EXT_STATr_CAP_1000BASE_T_HDf_SET
#define READ_MII_1000X_EXT_STATr BCM5464_READ_MII_1000X_EXT_STATr
#define WRITE_MII_1000X_EXT_STATr BCM5464_WRITE_MII_1000X_EXT_STATr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM5464_MII_1000X_EXT_STATr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM5464
 * REGISTER:  EXP_PKT_COUNTER
 * BLOCKS:   USER
 * REGADDR:  0x0015
 * DESC:     Receive/Transmit Packet Counter Register (Addr 00h)
 * SIZE:     32
 * FIELDS:
 *     EXP_PKT_COUNTER  EXP_PKT_COUNTER
 *
 ******************************************************************************/
#define BCM5464_EXP_PKT_COUNTERr (0x000f0015 | PHY_REG_ACC_BRCM_SHADOW)

#define BCM5464_EXP_PKT_COUNTERr_SIZE 4

/*
 * This structure should be used to declare and program EXP_PKT_COUNTER.
 *
 */
typedef union BCM5464_EXP_PKT_COUNTERr_s {
	uint32_t v[1];
	uint32_t exp_pkt_counter[1];
	uint32_t _exp_pkt_counter;
} BCM5464_EXP_PKT_COUNTERr_t;

#define BCM5464_EXP_PKT_COUNTERr_CLR(r) (r).exp_pkt_counter[0] = 0
#define BCM5464_EXP_PKT_COUNTERr_SET(r,d) (r).exp_pkt_counter[0] = d
#define BCM5464_EXP_PKT_COUNTERr_GET(r) (r).exp_pkt_counter[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM5464_EXP_PKT_COUNTERr_EXP_PKT_COUNTERf_GET(r) (((r).exp_pkt_counter[0]) & 0xffff)
#define BCM5464_EXP_PKT_COUNTERr_EXP_PKT_COUNTERf_SET(r,f) (r).exp_pkt_counter[0]=(((r).exp_pkt_counter[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access EXP_PKT_COUNTER.
 *
 */
#define BCM5464_READ_EXP_PKT_COUNTERr(_pc,_r) phy_brcm_shadow_read(_pc,BCM5464_EXP_PKT_COUNTERr,(_r._exp_pkt_counter))
#define BCM5464_WRITE_EXP_PKT_COUNTERr(_pc,_r) phy_brcm_shadow_write(_pc,BCM5464_EXP_PKT_COUNTERr,(_r._exp_pkt_counter))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define EXP_PKT_COUNTERr BCM5464_EXP_PKT_COUNTERr
#define EXP_PKT_COUNTERr_SIZE BCM5464_EXP_PKT_COUNTERr_SIZE
typedef BCM5464_EXP_PKT_COUNTERr_t EXP_PKT_COUNTERr_t;
#define EXP_PKT_COUNTERr_CLR BCM5464_EXP_PKT_COUNTERr_CLR
#define EXP_PKT_COUNTERr_SET BCM5464_EXP_PKT_COUNTERr_SET
#define EXP_PKT_COUNTERr_GET BCM5464_EXP_PKT_COUNTERr_GET
#define EXP_PKT_COUNTERr_EXP_PKT_COUNTERf_GET BCM5464_EXP_PKT_COUNTERr_EXP_PKT_COUNTERf_GET
#define EXP_PKT_COUNTERr_EXP_PKT_COUNTERf_SET BCM5464_EXP_PKT_COUNTERr_EXP_PKT_COUNTERf_SET
#define READ_EXP_PKT_COUNTERr BCM5464_READ_EXP_PKT_COUNTERr
#define WRITE_EXP_PKT_COUNTERr BCM5464_WRITE_EXP_PKT_COUNTERr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM5464_EXP_PKT_COUNTERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM5464
 * REGISTER:  EXP_INTERRUPT_STAT
 * BLOCKS:   USER
 * REGADDR:  0x0015
 * DESC:     Expansion Interrupt Status Register (Addr 01h)
 * SIZE:     32
 * FIELDS:
 *     EXP_INTERRUPT_STAT EXP_INTERRUPT_STAT
 *
 ******************************************************************************/
#define BCM5464_EXP_INTERRUPT_STATr (0x000f0115 | PHY_REG_ACC_BRCM_SHADOW)

#define BCM5464_EXP_INTERRUPT_STATr_SIZE 4

/*
 * This structure should be used to declare and program EXP_INTERRUPT_STAT.
 *
 */
typedef union BCM5464_EXP_INTERRUPT_STATr_s {
	uint32_t v[1];
	uint32_t exp_interrupt_stat[1];
	uint32_t _exp_interrupt_stat;
} BCM5464_EXP_INTERRUPT_STATr_t;

#define BCM5464_EXP_INTERRUPT_STATr_CLR(r) (r).exp_interrupt_stat[0] = 0
#define BCM5464_EXP_INTERRUPT_STATr_SET(r,d) (r).exp_interrupt_stat[0] = d
#define BCM5464_EXP_INTERRUPT_STATr_GET(r) (r).exp_interrupt_stat[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM5464_EXP_INTERRUPT_STATr_EXP_INTERRUPT_STATf_GET(r) (((r).exp_interrupt_stat[0]) & 0xffff)
#define BCM5464_EXP_INTERRUPT_STATr_EXP_INTERRUPT_STATf_SET(r,f) (r).exp_interrupt_stat[0]=(((r).exp_interrupt_stat[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access EXP_INTERRUPT_STAT.
 *
 */
#define BCM5464_READ_EXP_INTERRUPT_STATr(_pc,_r) phy_brcm_shadow_read(_pc,BCM5464_EXP_INTERRUPT_STATr,(_r._exp_interrupt_stat))
#define BCM5464_WRITE_EXP_INTERRUPT_STATr(_pc,_r) phy_brcm_shadow_write(_pc,BCM5464_EXP_INTERRUPT_STATr,(_r._exp_interrupt_stat))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define EXP_INTERRUPT_STATr BCM5464_EXP_INTERRUPT_STATr
#define EXP_INTERRUPT_STATr_SIZE BCM5464_EXP_INTERRUPT_STATr_SIZE
typedef BCM5464_EXP_INTERRUPT_STATr_t EXP_INTERRUPT_STATr_t;
#define EXP_INTERRUPT_STATr_CLR BCM5464_EXP_INTERRUPT_STATr_CLR
#define EXP_INTERRUPT_STATr_SET BCM5464_EXP_INTERRUPT_STATr_SET
#define EXP_INTERRUPT_STATr_GET BCM5464_EXP_INTERRUPT_STATr_GET
#define EXP_INTERRUPT_STATr_EXP_INTERRUPT_STATf_GET BCM5464_EXP_INTERRUPT_STATr_EXP_INTERRUPT_STATf_GET
#define EXP_INTERRUPT_STATr_EXP_INTERRUPT_STATf_SET BCM5464_EXP_INTERRUPT_STATr_EXP_INTERRUPT_STATf_SET
#define READ_EXP_INTERRUPT_STATr BCM5464_READ_EXP_INTERRUPT_STATr
#define WRITE_EXP_INTERRUPT_STATr BCM5464_WRITE_EXP_INTERRUPT_STATr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM5464_EXP_INTERRUPT_STATr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM5464
 * REGISTER:  EXP_INTERRUPT_MASK
 * BLOCKS:   USER
 * REGADDR:  0x0015
 * DESC:     Expansion Interrupt Mask Register (Addr 02h)
 * SIZE:     32
 * FIELDS:
 *     EXP_INTERRUPT_MASK EXP_INTERRUPT_MASK
 *
 ******************************************************************************/
#define BCM5464_EXP_INTERRUPT_MASKr (0x000f0215 | PHY_REG_ACC_BRCM_SHADOW)

#define BCM5464_EXP_INTERRUPT_MASKr_SIZE 4

/*
 * This structure should be used to declare and program EXP_INTERRUPT_MASK.
 *
 */
typedef union BCM5464_EXP_INTERRUPT_MASKr_s {
	uint32_t v[1];
	uint32_t exp_interrupt_mask[1];
	uint32_t _exp_interrupt_mask;
} BCM5464_EXP_INTERRUPT_MASKr_t;

#define BCM5464_EXP_INTERRUPT_MASKr_CLR(r) (r).exp_interrupt_mask[0] = 0
#define BCM5464_EXP_INTERRUPT_MASKr_SET(r,d) (r).exp_interrupt_mask[0] = d
#define BCM5464_EXP_INTERRUPT_MASKr_GET(r) (r).exp_interrupt_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM5464_EXP_INTERRUPT_MASKr_EXP_INTERRUPT_MASKf_GET(r) (((r).exp_interrupt_mask[0]) & 0xffff)
#define BCM5464_EXP_INTERRUPT_MASKr_EXP_INTERRUPT_MASKf_SET(r,f) (r).exp_interrupt_mask[0]=(((r).exp_interrupt_mask[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access EXP_INTERRUPT_MASK.
 *
 */
#define BCM5464_READ_EXP_INTERRUPT_MASKr(_pc,_r) phy_brcm_shadow_read(_pc,BCM5464_EXP_INTERRUPT_MASKr,(_r._exp_interrupt_mask))
#define BCM5464_WRITE_EXP_INTERRUPT_MASKr(_pc,_r) phy_brcm_shadow_write(_pc,BCM5464_EXP_INTERRUPT_MASKr,(_r._exp_interrupt_mask))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define EXP_INTERRUPT_MASKr BCM5464_EXP_INTERRUPT_MASKr
#define EXP_INTERRUPT_MASKr_SIZE BCM5464_EXP_INTERRUPT_MASKr_SIZE
typedef BCM5464_EXP_INTERRUPT_MASKr_t EXP_INTERRUPT_MASKr_t;
#define EXP_INTERRUPT_MASKr_CLR BCM5464_EXP_INTERRUPT_MASKr_CLR
#define EXP_INTERRUPT_MASKr_SET BCM5464_EXP_INTERRUPT_MASKr_SET
#define EXP_INTERRUPT_MASKr_GET BCM5464_EXP_INTERRUPT_MASKr_GET
#define EXP_INTERRUPT_MASKr_EXP_INTERRUPT_MASKf_GET BCM5464_EXP_INTERRUPT_MASKr_EXP_INTERRUPT_MASKf_GET
#define EXP_INTERRUPT_MASKr_EXP_INTERRUPT_MASKf_SET BCM5464_EXP_INTERRUPT_MASKr_EXP_INTERRUPT_MASKf_SET
#define READ_EXP_INTERRUPT_MASKr BCM5464_READ_EXP_INTERRUPT_MASKr
#define WRITE_EXP_INTERRUPT_MASKr BCM5464_WRITE_EXP_INTERRUPT_MASKr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM5464_EXP_INTERRUPT_MASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM5464
 * REGISTER:  EXP_SERDES_PASSTHRU_EN
 * BLOCKS:   USER
 * REGADDR:  0x0015
 * DESC:     Expansion SerDes Pass-Through Enable (Addr 03h)
 * SIZE:     32
 * FIELDS:
 *     EXP_SERDES_PASSTHRU_EN EXP_SERDES_PASSTHRU_EN
 *
 ******************************************************************************/
#define BCM5464_EXP_SERDES_PASSTHRU_ENr (0x000f0315 | PHY_REG_ACC_BRCM_SHADOW)

#define BCM5464_EXP_SERDES_PASSTHRU_ENr_SIZE 4

/*
 * This structure should be used to declare and program EXP_SERDES_PASSTHRU_EN.
 *
 */
typedef union BCM5464_EXP_SERDES_PASSTHRU_ENr_s {
	uint32_t v[1];
	uint32_t exp_serdes_passthru_en[1];
	uint32_t _exp_serdes_passthru_en;
} BCM5464_EXP_SERDES_PASSTHRU_ENr_t;

#define BCM5464_EXP_SERDES_PASSTHRU_ENr_CLR(r) (r).exp_serdes_passthru_en[0] = 0
#define BCM5464_EXP_SERDES_PASSTHRU_ENr_SET(r,d) (r).exp_serdes_passthru_en[0] = d
#define BCM5464_EXP_SERDES_PASSTHRU_ENr_GET(r) (r).exp_serdes_passthru_en[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM5464_EXP_SERDES_PASSTHRU_ENr_EXP_SERDES_PASSTHRU_ENf_GET(r) (((r).exp_serdes_passthru_en[0]) & 0xffff)
#define BCM5464_EXP_SERDES_PASSTHRU_ENr_EXP_SERDES_PASSTHRU_ENf_SET(r,f) (r).exp_serdes_passthru_en[0]=(((r).exp_serdes_passthru_en[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access EXP_SERDES_PASSTHRU_EN.
 *
 */
#define BCM5464_READ_EXP_SERDES_PASSTHRU_ENr(_pc,_r) phy_brcm_shadow_read(_pc,BCM5464_EXP_SERDES_PASSTHRU_ENr,(_r._exp_serdes_passthru_en))
#define BCM5464_WRITE_EXP_SERDES_PASSTHRU_ENr(_pc,_r) phy_brcm_shadow_write(_pc,BCM5464_EXP_SERDES_PASSTHRU_ENr,(_r._exp_serdes_passthru_en))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define EXP_SERDES_PASSTHRU_ENr BCM5464_EXP_SERDES_PASSTHRU_ENr
#define EXP_SERDES_PASSTHRU_ENr_SIZE BCM5464_EXP_SERDES_PASSTHRU_ENr_SIZE
typedef BCM5464_EXP_SERDES_PASSTHRU_ENr_t EXP_SERDES_PASSTHRU_ENr_t;
#define EXP_SERDES_PASSTHRU_ENr_CLR BCM5464_EXP_SERDES_PASSTHRU_ENr_CLR
#define EXP_SERDES_PASSTHRU_ENr_SET BCM5464_EXP_SERDES_PASSTHRU_ENr_SET
#define EXP_SERDES_PASSTHRU_ENr_GET BCM5464_EXP_SERDES_PASSTHRU_ENr_GET
#define EXP_SERDES_PASSTHRU_ENr_EXP_SERDES_PASSTHRU_ENf_GET BCM5464_EXP_SERDES_PASSTHRU_ENr_EXP_SERDES_PASSTHRU_ENf_GET
#define EXP_SERDES_PASSTHRU_ENr_EXP_SERDES_PASSTHRU_ENf_SET BCM5464_EXP_SERDES_PASSTHRU_ENr_EXP_SERDES_PASSTHRU_ENf_SET
#define READ_EXP_SERDES_PASSTHRU_ENr BCM5464_READ_EXP_SERDES_PASSTHRU_ENr
#define WRITE_EXP_SERDES_PASSTHRU_ENr BCM5464_WRITE_EXP_SERDES_PASSTHRU_ENr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM5464_EXP_SERDES_PASSTHRU_ENr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM5464
 * REGISTER:  EXP_LED_SELECTOR
 * BLOCKS:   USER
 * REGADDR:  0x0015
 * DESC:     Multicolor LED Selector Register (Addr 04h)
 * SIZE:     32
 * FIELDS:
 *     EXP_LED_SELECTOR EXP_LED_SELECTOR
 *
 ******************************************************************************/
#define BCM5464_EXP_LED_SELECTORr (0x000f0415 | PHY_REG_ACC_BRCM_SHADOW)

#define BCM5464_EXP_LED_SELECTORr_SIZE 4

/*
 * This structure should be used to declare and program EXP_LED_SELECTOR.
 *
 */
typedef union BCM5464_EXP_LED_SELECTORr_s {
	uint32_t v[1];
	uint32_t exp_led_selector[1];
	uint32_t _exp_led_selector;
} BCM5464_EXP_LED_SELECTORr_t;

#define BCM5464_EXP_LED_SELECTORr_CLR(r) (r).exp_led_selector[0] = 0
#define BCM5464_EXP_LED_SELECTORr_SET(r,d) (r).exp_led_selector[0] = d
#define BCM5464_EXP_LED_SELECTORr_GET(r) (r).exp_led_selector[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM5464_EXP_LED_SELECTORr_EXP_LED_SELECTORf_GET(r) (((r).exp_led_selector[0]) & 0xffff)
#define BCM5464_EXP_LED_SELECTORr_EXP_LED_SELECTORf_SET(r,f) (r).exp_led_selector[0]=(((r).exp_led_selector[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access EXP_LED_SELECTOR.
 *
 */
#define BCM5464_READ_EXP_LED_SELECTORr(_pc,_r) phy_brcm_shadow_read(_pc,BCM5464_EXP_LED_SELECTORr,(_r._exp_led_selector))
#define BCM5464_WRITE_EXP_LED_SELECTORr(_pc,_r) phy_brcm_shadow_write(_pc,BCM5464_EXP_LED_SELECTORr,(_r._exp_led_selector))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define EXP_LED_SELECTORr BCM5464_EXP_LED_SELECTORr
#define EXP_LED_SELECTORr_SIZE BCM5464_EXP_LED_SELECTORr_SIZE
typedef BCM5464_EXP_LED_SELECTORr_t EXP_LED_SELECTORr_t;
#define EXP_LED_SELECTORr_CLR BCM5464_EXP_LED_SELECTORr_CLR
#define EXP_LED_SELECTORr_SET BCM5464_EXP_LED_SELECTORr_SET
#define EXP_LED_SELECTORr_GET BCM5464_EXP_LED_SELECTORr_GET
#define EXP_LED_SELECTORr_EXP_LED_SELECTORf_GET BCM5464_EXP_LED_SELECTORr_EXP_LED_SELECTORf_GET
#define EXP_LED_SELECTORr_EXP_LED_SELECTORf_SET BCM5464_EXP_LED_SELECTORr_EXP_LED_SELECTORf_SET
#define READ_EXP_LED_SELECTORr BCM5464_READ_EXP_LED_SELECTORr
#define WRITE_EXP_LED_SELECTORr BCM5464_WRITE_EXP_LED_SELECTORr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM5464_EXP_LED_SELECTORr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM5464
 * REGISTER:  EXP_LED_FLASH_CTRL
 * BLOCKS:   USER
 * REGADDR:  0x0015
 * DESC:     Multicolor LED Flash Rate Controls Register (Addr 05h)
 * SIZE:     32
 * FIELDS:
 *     EXP_LED_FLASH_CTRL EXP_LED_FLASH_CTRL
 *
 ******************************************************************************/
#define BCM5464_EXP_LED_FLASH_CTRLr (0x000f0515 | PHY_REG_ACC_BRCM_SHADOW)

#define BCM5464_EXP_LED_FLASH_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program EXP_LED_FLASH_CTRL.
 *
 */
typedef union BCM5464_EXP_LED_FLASH_CTRLr_s {
	uint32_t v[1];
	uint32_t exp_led_flash_ctrl[1];
	uint32_t _exp_led_flash_ctrl;
} BCM5464_EXP_LED_FLASH_CTRLr_t;

#define BCM5464_EXP_LED_FLASH_CTRLr_CLR(r) (r).exp_led_flash_ctrl[0] = 0
#define BCM5464_EXP_LED_FLASH_CTRLr_SET(r,d) (r).exp_led_flash_ctrl[0] = d
#define BCM5464_EXP_LED_FLASH_CTRLr_GET(r) (r).exp_led_flash_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM5464_EXP_LED_FLASH_CTRLr_EXP_LED_FLASH_CTRLf_GET(r) (((r).exp_led_flash_ctrl[0]) & 0xffff)
#define BCM5464_EXP_LED_FLASH_CTRLr_EXP_LED_FLASH_CTRLf_SET(r,f) (r).exp_led_flash_ctrl[0]=(((r).exp_led_flash_ctrl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access EXP_LED_FLASH_CTRL.
 *
 */
#define BCM5464_READ_EXP_LED_FLASH_CTRLr(_pc,_r) phy_brcm_shadow_read(_pc,BCM5464_EXP_LED_FLASH_CTRLr,(_r._exp_led_flash_ctrl))
#define BCM5464_WRITE_EXP_LED_FLASH_CTRLr(_pc,_r) phy_brcm_shadow_write(_pc,BCM5464_EXP_LED_FLASH_CTRLr,(_r._exp_led_flash_ctrl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define EXP_LED_FLASH_CTRLr BCM5464_EXP_LED_FLASH_CTRLr
#define EXP_LED_FLASH_CTRLr_SIZE BCM5464_EXP_LED_FLASH_CTRLr_SIZE
typedef BCM5464_EXP_LED_FLASH_CTRLr_t EXP_LED_FLASH_CTRLr_t;
#define EXP_LED_FLASH_CTRLr_CLR BCM5464_EXP_LED_FLASH_CTRLr_CLR
#define EXP_LED_FLASH_CTRLr_SET BCM5464_EXP_LED_FLASH_CTRLr_SET
#define EXP_LED_FLASH_CTRLr_GET BCM5464_EXP_LED_FLASH_CTRLr_GET
#define EXP_LED_FLASH_CTRLr_EXP_LED_FLASH_CTRLf_GET BCM5464_EXP_LED_FLASH_CTRLr_EXP_LED_FLASH_CTRLf_GET
#define EXP_LED_FLASH_CTRLr_EXP_LED_FLASH_CTRLf_SET BCM5464_EXP_LED_FLASH_CTRLr_EXP_LED_FLASH_CTRLf_SET
#define READ_EXP_LED_FLASH_CTRLr BCM5464_READ_EXP_LED_FLASH_CTRLr
#define WRITE_EXP_LED_FLASH_CTRLr BCM5464_WRITE_EXP_LED_FLASH_CTRLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM5464_EXP_LED_FLASH_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM5464
 * REGISTER:  EXP_LED_BLINK_CTRL
 * BLOCKS:   USER
 * REGADDR:  0x0015
 * DESC:     Multicolor LED Programmable Blink Controls Register (Addr 06h)
 * SIZE:     32
 * FIELDS:
 *     EXP_LED_BLINK_CTRL EXP_LED_BLINK_CTRL
 *
 ******************************************************************************/
#define BCM5464_EXP_LED_BLINK_CTRLr (0x000f0615 | PHY_REG_ACC_BRCM_SHADOW)

#define BCM5464_EXP_LED_BLINK_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program EXP_LED_BLINK_CTRL.
 *
 */
typedef union BCM5464_EXP_LED_BLINK_CTRLr_s {
	uint32_t v[1];
	uint32_t exp_led_blink_ctrl[1];
	uint32_t _exp_led_blink_ctrl;
} BCM5464_EXP_LED_BLINK_CTRLr_t;

#define BCM5464_EXP_LED_BLINK_CTRLr_CLR(r) (r).exp_led_blink_ctrl[0] = 0
#define BCM5464_EXP_LED_BLINK_CTRLr_SET(r,d) (r).exp_led_blink_ctrl[0] = d
#define BCM5464_EXP_LED_BLINK_CTRLr_GET(r) (r).exp_led_blink_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM5464_EXP_LED_BLINK_CTRLr_EXP_LED_BLINK_CTRLf_GET(r) (((r).exp_led_blink_ctrl[0]) & 0xffff)
#define BCM5464_EXP_LED_BLINK_CTRLr_EXP_LED_BLINK_CTRLf_SET(r,f) (r).exp_led_blink_ctrl[0]=(((r).exp_led_blink_ctrl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access EXP_LED_BLINK_CTRL.
 *
 */
#define BCM5464_READ_EXP_LED_BLINK_CTRLr(_pc,_r) phy_brcm_shadow_read(_pc,BCM5464_EXP_LED_BLINK_CTRLr,(_r._exp_led_blink_ctrl))
#define BCM5464_WRITE_EXP_LED_BLINK_CTRLr(_pc,_r) phy_brcm_shadow_write(_pc,BCM5464_EXP_LED_BLINK_CTRLr,(_r._exp_led_blink_ctrl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define EXP_LED_BLINK_CTRLr BCM5464_EXP_LED_BLINK_CTRLr
#define EXP_LED_BLINK_CTRLr_SIZE BCM5464_EXP_LED_BLINK_CTRLr_SIZE
typedef BCM5464_EXP_LED_BLINK_CTRLr_t EXP_LED_BLINK_CTRLr_t;
#define EXP_LED_BLINK_CTRLr_CLR BCM5464_EXP_LED_BLINK_CTRLr_CLR
#define EXP_LED_BLINK_CTRLr_SET BCM5464_EXP_LED_BLINK_CTRLr_SET
#define EXP_LED_BLINK_CTRLr_GET BCM5464_EXP_LED_BLINK_CTRLr_GET
#define EXP_LED_BLINK_CTRLr_EXP_LED_BLINK_CTRLf_GET BCM5464_EXP_LED_BLINK_CTRLr_EXP_LED_BLINK_CTRLf_GET
#define EXP_LED_BLINK_CTRLr_EXP_LED_BLINK_CTRLf_SET BCM5464_EXP_LED_BLINK_CTRLr_EXP_LED_BLINK_CTRLf_SET
#define READ_EXP_LED_BLINK_CTRLr BCM5464_READ_EXP_LED_BLINK_CTRLr
#define WRITE_EXP_LED_BLINK_CTRLr BCM5464_WRITE_EXP_LED_BLINK_CTRLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM5464_EXP_LED_BLINK_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM5464
 * REGISTER:  EXP_PASSTHRU_LED_MODE
 * BLOCKS:   USER
 * REGADDR:  0x0015
 * DESC:     SerDes Passthrough LED Mode Reg (Addr fdh)
 * SIZE:     32
 * FIELDS:
 *     EXP_PASSTHRU_LED_MODE EXP_PASSTHRU_LED_MODE
 *
 ******************************************************************************/
#define BCM5464_EXP_PASSTHRU_LED_MODEr (0x000ff915 | PHY_REG_ACC_BRCM_SHADOW)

#define BCM5464_EXP_PASSTHRU_LED_MODEr_SIZE 4

/*
 * This structure should be used to declare and program EXP_PASSTHRU_LED_MODE.
 *
 */
typedef union BCM5464_EXP_PASSTHRU_LED_MODEr_s {
	uint32_t v[1];
	uint32_t exp_passthru_led_mode[1];
	uint32_t _exp_passthru_led_mode;
} BCM5464_EXP_PASSTHRU_LED_MODEr_t;

#define BCM5464_EXP_PASSTHRU_LED_MODEr_CLR(r) (r).exp_passthru_led_mode[0] = 0
#define BCM5464_EXP_PASSTHRU_LED_MODEr_SET(r,d) (r).exp_passthru_led_mode[0] = d
#define BCM5464_EXP_PASSTHRU_LED_MODEr_GET(r) (r).exp_passthru_led_mode[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM5464_EXP_PASSTHRU_LED_MODEr_EXP_PASSTHRU_LED_MODEf_GET(r) (((r).exp_passthru_led_mode[0]) & 0xffff)
#define BCM5464_EXP_PASSTHRU_LED_MODEr_EXP_PASSTHRU_LED_MODEf_SET(r,f) (r).exp_passthru_led_mode[0]=(((r).exp_passthru_led_mode[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access EXP_PASSTHRU_LED_MODE.
 *
 */
#define BCM5464_READ_EXP_PASSTHRU_LED_MODEr(_pc,_r) phy_brcm_shadow_read(_pc,BCM5464_EXP_PASSTHRU_LED_MODEr,(_r._exp_passthru_led_mode))
#define BCM5464_WRITE_EXP_PASSTHRU_LED_MODEr(_pc,_r) phy_brcm_shadow_write(_pc,BCM5464_EXP_PASSTHRU_LED_MODEr,(_r._exp_passthru_led_mode))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define EXP_PASSTHRU_LED_MODEr BCM5464_EXP_PASSTHRU_LED_MODEr
#define EXP_PASSTHRU_LED_MODEr_SIZE BCM5464_EXP_PASSTHRU_LED_MODEr_SIZE
typedef BCM5464_EXP_PASSTHRU_LED_MODEr_t EXP_PASSTHRU_LED_MODEr_t;
#define EXP_PASSTHRU_LED_MODEr_CLR BCM5464_EXP_PASSTHRU_LED_MODEr_CLR
#define EXP_PASSTHRU_LED_MODEr_SET BCM5464_EXP_PASSTHRU_LED_MODEr_SET
#define EXP_PASSTHRU_LED_MODEr_GET BCM5464_EXP_PASSTHRU_LED_MODEr_GET
#define EXP_PASSTHRU_LED_MODEr_EXP_PASSTHRU_LED_MODEf_GET BCM5464_EXP_PASSTHRU_LED_MODEr_EXP_PASSTHRU_LED_MODEf_GET
#define EXP_PASSTHRU_LED_MODEr_EXP_PASSTHRU_LED_MODEf_SET BCM5464_EXP_PASSTHRU_LED_MODEr_EXP_PASSTHRU_LED_MODEf_SET
#define READ_EXP_PASSTHRU_LED_MODEr BCM5464_READ_EXP_PASSTHRU_LED_MODEr
#define WRITE_EXP_PASSTHRU_LED_MODEr BCM5464_WRITE_EXP_PASSTHRU_LED_MODEr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM5464_EXP_PASSTHRU_LED_MODEr'
 ******************************************************************************/




#endif /* __BCM5464_DEFS_H__ */
