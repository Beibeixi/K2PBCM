#ifndef __BCM54684_DEFS_H__
#define __BCM54684_DEFS_H__
/*******************************************************************************
 *
 * $Copyright: Copyright 2013 Broadcom Corporation.
 * This program is the proprietary software of Broadcom Corporation
 * and/or its licensors, and may only be used, duplicated, modified
 * or distributed pursuant to the terms and conditions of a separate,
 * written license agreement executed between you and Broadcom
 * (an "Authorized License").  Except as set forth in an Authorized
 * License, Broadcom grants no license (express or implied), right
 * to use, or waiver of any kind with respect to the Software, and
 * Broadcom expressly reserves all rights in and to the Software
 * and all intellectual property rights therein.  IF YOU HAVE
 * NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
 * IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
 * ALL USE OF THE SOFTWARE.  
 *  
 * Except as expressly set forth in the Authorized License,
 *  
 * 1.     This program, including its structure, sequence and organization,
 * constitutes the valuable trade secrets of Broadcom, and you shall use
 * all reasonable efforts to protect the confidentiality thereof,
 * and to use this information only in connection with your use of
 * Broadcom integrated circuit products.
 *  
 * 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
 * PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
 * REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
 * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
 * DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
 * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
 * ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
 * CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
 * OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
 * 
 * 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
 * BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
 * INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
 * ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
 * TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
 * THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR USD 1.00,
 * WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
 * ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated from the registers file.
 * Edits to this file will be lost when it is regenerated.
 *
 * Definition file for the BCM54684.
 * This file provides all basic definitions required to program the BCM54684.
 *
 * This file is autogenerated. Please do not edit.
 *
 ******************************************************************************/

#include <phy/phy_brcm_shadow.h>

/*******************************************************************************
 *
 *                    CHIP DEFINITIONS BEGIN HERE
 *
 ******************************************************************************/



/*******************************************************************************
 * CHIP:  BCM54684
 * REGISTER:  MII_CTRL
 * BLOCKS:   IEEE
 * REGADDR:  0x0000
 * DESC:     1000BASE-T/100BASE-TX/10BASE-T MII Control Register (Addr 00h)
 * SIZE:     32
 * FIELDS:
 *     SPEED_SEL1       Speed selection (MSB).
 *     COLL_TEST_EN     Enable collision test mode.
 *     FULL_DUPLEX      Full duplex operation.
 *     RESTART_AN       Restart auto-negotiation.
 *     ISOLATE          Isolate PHY from GMII/RGMII/RTBI.
 *     POWER_DOWN       Power down.
 *     AUTONEG          Auto-negotiation enabled.
 *     SPEED_SEL0       Speed selection (LSB).
 *     LOOPBACK         Loopback mode.
 *     RESET            PHY reset.
 *
 ******************************************************************************/
#define BCM54684_MII_CTRLr (0x00000000 | PHY_REG_ACC_RAW)

#define BCM54684_MII_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program MII_CTRL.
 *
 */
typedef union BCM54684_MII_CTRLr_s {
	uint32_t v[1];
	uint32_t mii_ctrl[1];
	uint32_t _mii_ctrl;
} BCM54684_MII_CTRLr_t;

#define BCM54684_MII_CTRLr_CLR(r) (r).mii_ctrl[0] = 0
#define BCM54684_MII_CTRLr_SET(r,d) (r).mii_ctrl[0] = d
#define BCM54684_MII_CTRLr_GET(r) (r).mii_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM54684_MII_CTRLr_RESETf_GET(r) ((((r).mii_ctrl[0]) >> 15) & 0x1)
#define BCM54684_MII_CTRLr_RESETf_SET(r,f) (r).mii_ctrl[0]=(((r).mii_ctrl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM54684_MII_CTRLr_LOOPBACKf_GET(r) ((((r).mii_ctrl[0]) >> 14) & 0x1)
#define BCM54684_MII_CTRLr_LOOPBACKf_SET(r,f) (r).mii_ctrl[0]=(((r).mii_ctrl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM54684_MII_CTRLr_SPEED_SEL0f_GET(r) ((((r).mii_ctrl[0]) >> 13) & 0x1)
#define BCM54684_MII_CTRLr_SPEED_SEL0f_SET(r,f) (r).mii_ctrl[0]=(((r).mii_ctrl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM54684_MII_CTRLr_AUTONEGf_GET(r) ((((r).mii_ctrl[0]) >> 12) & 0x1)
#define BCM54684_MII_CTRLr_AUTONEGf_SET(r,f) (r).mii_ctrl[0]=(((r).mii_ctrl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM54684_MII_CTRLr_POWER_DOWNf_GET(r) ((((r).mii_ctrl[0]) >> 11) & 0x1)
#define BCM54684_MII_CTRLr_POWER_DOWNf_SET(r,f) (r).mii_ctrl[0]=(((r).mii_ctrl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM54684_MII_CTRLr_ISOLATEf_GET(r) ((((r).mii_ctrl[0]) >> 10) & 0x1)
#define BCM54684_MII_CTRLr_ISOLATEf_SET(r,f) (r).mii_ctrl[0]=(((r).mii_ctrl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM54684_MII_CTRLr_RESTART_ANf_GET(r) ((((r).mii_ctrl[0]) >> 9) & 0x1)
#define BCM54684_MII_CTRLr_RESTART_ANf_SET(r,f) (r).mii_ctrl[0]=(((r).mii_ctrl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM54684_MII_CTRLr_FULL_DUPLEXf_GET(r) ((((r).mii_ctrl[0]) >> 8) & 0x1)
#define BCM54684_MII_CTRLr_FULL_DUPLEXf_SET(r,f) (r).mii_ctrl[0]=(((r).mii_ctrl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM54684_MII_CTRLr_COLL_TEST_ENf_GET(r) ((((r).mii_ctrl[0]) >> 7) & 0x1)
#define BCM54684_MII_CTRLr_COLL_TEST_ENf_SET(r,f) (r).mii_ctrl[0]=(((r).mii_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM54684_MII_CTRLr_SPEED_SEL1f_GET(r) ((((r).mii_ctrl[0]) >> 6) & 0x1)
#define BCM54684_MII_CTRLr_SPEED_SEL1f_SET(r,f) (r).mii_ctrl[0]=(((r).mii_ctrl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))

/*
 * These macros can be used to access MII_CTRL.
 *
 */
#define BCM54684_READ_MII_CTRLr(_pc,_r) PHY_REG_READ(_pc,BCM54684_MII_CTRLr,_r._mii_ctrl)
#define BCM54684_WRITE_MII_CTRLr(_pc,_r) PHY_REG_WRITE(_pc,BCM54684_MII_CTRLr,_r._mii_ctrl)

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MII_CTRLr BCM54684_MII_CTRLr
#define MII_CTRLr_SIZE BCM54684_MII_CTRLr_SIZE
typedef BCM54684_MII_CTRLr_t MII_CTRLr_t;
#define MII_CTRLr_CLR BCM54684_MII_CTRLr_CLR
#define MII_CTRLr_SET BCM54684_MII_CTRLr_SET
#define MII_CTRLr_GET BCM54684_MII_CTRLr_GET
#define MII_CTRLr_RESETf_GET BCM54684_MII_CTRLr_RESETf_GET
#define MII_CTRLr_RESETf_SET BCM54684_MII_CTRLr_RESETf_SET
#define MII_CTRLr_LOOPBACKf_GET BCM54684_MII_CTRLr_LOOPBACKf_GET
#define MII_CTRLr_LOOPBACKf_SET BCM54684_MII_CTRLr_LOOPBACKf_SET
#define MII_CTRLr_SPEED_SEL0f_GET BCM54684_MII_CTRLr_SPEED_SEL0f_GET
#define MII_CTRLr_SPEED_SEL0f_SET BCM54684_MII_CTRLr_SPEED_SEL0f_SET
#define MII_CTRLr_AUTONEGf_GET BCM54684_MII_CTRLr_AUTONEGf_GET
#define MII_CTRLr_AUTONEGf_SET BCM54684_MII_CTRLr_AUTONEGf_SET
#define MII_CTRLr_POWER_DOWNf_GET BCM54684_MII_CTRLr_POWER_DOWNf_GET
#define MII_CTRLr_POWER_DOWNf_SET BCM54684_MII_CTRLr_POWER_DOWNf_SET
#define MII_CTRLr_ISOLATEf_GET BCM54684_MII_CTRLr_ISOLATEf_GET
#define MII_CTRLr_ISOLATEf_SET BCM54684_MII_CTRLr_ISOLATEf_SET
#define MII_CTRLr_RESTART_ANf_GET BCM54684_MII_CTRLr_RESTART_ANf_GET
#define MII_CTRLr_RESTART_ANf_SET BCM54684_MII_CTRLr_RESTART_ANf_SET
#define MII_CTRLr_FULL_DUPLEXf_GET BCM54684_MII_CTRLr_FULL_DUPLEXf_GET
#define MII_CTRLr_FULL_DUPLEXf_SET BCM54684_MII_CTRLr_FULL_DUPLEXf_SET
#define MII_CTRLr_COLL_TEST_ENf_GET BCM54684_MII_CTRLr_COLL_TEST_ENf_GET
#define MII_CTRLr_COLL_TEST_ENf_SET BCM54684_MII_CTRLr_COLL_TEST_ENf_SET
#define MII_CTRLr_SPEED_SEL1f_GET BCM54684_MII_CTRLr_SPEED_SEL1f_GET
#define MII_CTRLr_SPEED_SEL1f_SET BCM54684_MII_CTRLr_SPEED_SEL1f_SET
#define READ_MII_CTRLr BCM54684_READ_MII_CTRLr
#define WRITE_MII_CTRLr BCM54684_WRITE_MII_CTRLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM54684_MII_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM54684
 * REGISTER:  MII_STAT
 * BLOCKS:   IEEE
 * REGADDR:  0x0001
 * DESC:     1000BASE-T/100BASE-TX/10BASE-T MII Status Register (Addr 01h)
 * SIZE:     32
 * FIELDS:
 *     EXT_CAPABILITY   Extended register capabilities.
 *     JABBER_DETECT    Jabber condition detected.
 *     LINK             Link is up.
 *     AUTONEG_ABILITY  Auto-negotiation capable.
 *     REMOTE_FAULT     Remote fault detected.
 *     AUTONEG_DONE     Auto-negotiation complete.
 *     MF_PREAMBLE_SUP  Preamble can be suppressed.
 *     EXT_STATUS       Extended status information in register 0Fh.
 *     CAP_100BASE_T2_HD 100BASE-T2 half-duplex capable.
 *     CAP_100BASE_T2_FD 100BASE-T2 full-duplex capable.
 *     CAP_10BASE_T_HD  10BASE-T half-duplex capable.
 *     CAP_10BASE_T_FD  10BASE-T full-duplex capable.
 *     CAP_100BASE_X_HD 100BASE-X half-duplex capable.
 *     CAP_100BASE_X_FD 100BASE-X full-duplex capable.
 *     CAP_100BASE_T4   100BASE-T4 capable.
 *
 ******************************************************************************/
#define BCM54684_MII_STATr (0x00000001 | PHY_REG_ACC_RAW)

#define BCM54684_MII_STATr_SIZE 4

/*
 * This structure should be used to declare and program MII_STAT.
 *
 */
typedef union BCM54684_MII_STATr_s {
	uint32_t v[1];
	uint32_t mii_stat[1];
	uint32_t _mii_stat;
} BCM54684_MII_STATr_t;

#define BCM54684_MII_STATr_CLR(r) (r).mii_stat[0] = 0
#define BCM54684_MII_STATr_SET(r,d) (r).mii_stat[0] = d
#define BCM54684_MII_STATr_GET(r) (r).mii_stat[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM54684_MII_STATr_CAP_100BASE_T4f_GET(r) ((((r).mii_stat[0]) >> 15) & 0x1)
#define BCM54684_MII_STATr_CAP_100BASE_T4f_SET(r,f) (r).mii_stat[0]=(((r).mii_stat[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM54684_MII_STATr_CAP_100BASE_X_FDf_GET(r) ((((r).mii_stat[0]) >> 14) & 0x1)
#define BCM54684_MII_STATr_CAP_100BASE_X_FDf_SET(r,f) (r).mii_stat[0]=(((r).mii_stat[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM54684_MII_STATr_CAP_100BASE_X_HDf_GET(r) ((((r).mii_stat[0]) >> 13) & 0x1)
#define BCM54684_MII_STATr_CAP_100BASE_X_HDf_SET(r,f) (r).mii_stat[0]=(((r).mii_stat[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM54684_MII_STATr_CAP_10BASE_T_FDf_GET(r) ((((r).mii_stat[0]) >> 12) & 0x1)
#define BCM54684_MII_STATr_CAP_10BASE_T_FDf_SET(r,f) (r).mii_stat[0]=(((r).mii_stat[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM54684_MII_STATr_CAP_10BASE_T_HDf_GET(r) ((((r).mii_stat[0]) >> 11) & 0x1)
#define BCM54684_MII_STATr_CAP_10BASE_T_HDf_SET(r,f) (r).mii_stat[0]=(((r).mii_stat[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM54684_MII_STATr_CAP_100BASE_T2_FDf_GET(r) ((((r).mii_stat[0]) >> 10) & 0x1)
#define BCM54684_MII_STATr_CAP_100BASE_T2_FDf_SET(r,f) (r).mii_stat[0]=(((r).mii_stat[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM54684_MII_STATr_CAP_100BASE_T2_HDf_GET(r) ((((r).mii_stat[0]) >> 9) & 0x1)
#define BCM54684_MII_STATr_CAP_100BASE_T2_HDf_SET(r,f) (r).mii_stat[0]=(((r).mii_stat[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM54684_MII_STATr_EXT_STATUSf_GET(r) ((((r).mii_stat[0]) >> 8) & 0x1)
#define BCM54684_MII_STATr_EXT_STATUSf_SET(r,f) (r).mii_stat[0]=(((r).mii_stat[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM54684_MII_STATr_MF_PREAMBLE_SUPf_GET(r) ((((r).mii_stat[0]) >> 6) & 0x1)
#define BCM54684_MII_STATr_MF_PREAMBLE_SUPf_SET(r,f) (r).mii_stat[0]=(((r).mii_stat[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM54684_MII_STATr_AUTONEG_DONEf_GET(r) ((((r).mii_stat[0]) >> 5) & 0x1)
#define BCM54684_MII_STATr_AUTONEG_DONEf_SET(r,f) (r).mii_stat[0]=(((r).mii_stat[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM54684_MII_STATr_REMOTE_FAULTf_GET(r) ((((r).mii_stat[0]) >> 4) & 0x1)
#define BCM54684_MII_STATr_REMOTE_FAULTf_SET(r,f) (r).mii_stat[0]=(((r).mii_stat[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM54684_MII_STATr_AUTONEG_ABILITYf_GET(r) ((((r).mii_stat[0]) >> 3) & 0x1)
#define BCM54684_MII_STATr_AUTONEG_ABILITYf_SET(r,f) (r).mii_stat[0]=(((r).mii_stat[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM54684_MII_STATr_LINKf_GET(r) ((((r).mii_stat[0]) >> 2) & 0x1)
#define BCM54684_MII_STATr_LINKf_SET(r,f) (r).mii_stat[0]=(((r).mii_stat[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM54684_MII_STATr_JABBER_DETECTf_GET(r) ((((r).mii_stat[0]) >> 1) & 0x1)
#define BCM54684_MII_STATr_JABBER_DETECTf_SET(r,f) (r).mii_stat[0]=(((r).mii_stat[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM54684_MII_STATr_EXT_CAPABILITYf_GET(r) (((r).mii_stat[0]) & 0x1)
#define BCM54684_MII_STATr_EXT_CAPABILITYf_SET(r,f) (r).mii_stat[0]=(((r).mii_stat[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access MII_STAT.
 *
 */
#define BCM54684_READ_MII_STATr(_pc,_r) PHY_REG_READ(_pc,BCM54684_MII_STATr,_r._mii_stat)
#define BCM54684_WRITE_MII_STATr(_pc,_r) PHY_REG_WRITE(_pc,BCM54684_MII_STATr,_r._mii_stat)

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MII_STATr BCM54684_MII_STATr
#define MII_STATr_SIZE BCM54684_MII_STATr_SIZE
typedef BCM54684_MII_STATr_t MII_STATr_t;
#define MII_STATr_CLR BCM54684_MII_STATr_CLR
#define MII_STATr_SET BCM54684_MII_STATr_SET
#define MII_STATr_GET BCM54684_MII_STATr_GET
#define MII_STATr_CAP_100BASE_T4f_GET BCM54684_MII_STATr_CAP_100BASE_T4f_GET
#define MII_STATr_CAP_100BASE_T4f_SET BCM54684_MII_STATr_CAP_100BASE_T4f_SET
#define MII_STATr_CAP_100BASE_X_FDf_GET BCM54684_MII_STATr_CAP_100BASE_X_FDf_GET
#define MII_STATr_CAP_100BASE_X_FDf_SET BCM54684_MII_STATr_CAP_100BASE_X_FDf_SET
#define MII_STATr_CAP_100BASE_X_HDf_GET BCM54684_MII_STATr_CAP_100BASE_X_HDf_GET
#define MII_STATr_CAP_100BASE_X_HDf_SET BCM54684_MII_STATr_CAP_100BASE_X_HDf_SET
#define MII_STATr_CAP_10BASE_T_FDf_GET BCM54684_MII_STATr_CAP_10BASE_T_FDf_GET
#define MII_STATr_CAP_10BASE_T_FDf_SET BCM54684_MII_STATr_CAP_10BASE_T_FDf_SET
#define MII_STATr_CAP_10BASE_T_HDf_GET BCM54684_MII_STATr_CAP_10BASE_T_HDf_GET
#define MII_STATr_CAP_10BASE_T_HDf_SET BCM54684_MII_STATr_CAP_10BASE_T_HDf_SET
#define MII_STATr_CAP_100BASE_T2_FDf_GET BCM54684_MII_STATr_CAP_100BASE_T2_FDf_GET
#define MII_STATr_CAP_100BASE_T2_FDf_SET BCM54684_MII_STATr_CAP_100BASE_T2_FDf_SET
#define MII_STATr_CAP_100BASE_T2_HDf_GET BCM54684_MII_STATr_CAP_100BASE_T2_HDf_GET
#define MII_STATr_CAP_100BASE_T2_HDf_SET BCM54684_MII_STATr_CAP_100BASE_T2_HDf_SET
#define MII_STATr_EXT_STATUSf_GET BCM54684_MII_STATr_EXT_STATUSf_GET
#define MII_STATr_EXT_STATUSf_SET BCM54684_MII_STATr_EXT_STATUSf_SET
#define MII_STATr_MF_PREAMBLE_SUPf_GET BCM54684_MII_STATr_MF_PREAMBLE_SUPf_GET
#define MII_STATr_MF_PREAMBLE_SUPf_SET BCM54684_MII_STATr_MF_PREAMBLE_SUPf_SET
#define MII_STATr_AUTONEG_DONEf_GET BCM54684_MII_STATr_AUTONEG_DONEf_GET
#define MII_STATr_AUTONEG_DONEf_SET BCM54684_MII_STATr_AUTONEG_DONEf_SET
#define MII_STATr_REMOTE_FAULTf_GET BCM54684_MII_STATr_REMOTE_FAULTf_GET
#define MII_STATr_REMOTE_FAULTf_SET BCM54684_MII_STATr_REMOTE_FAULTf_SET
#define MII_STATr_AUTONEG_ABILITYf_GET BCM54684_MII_STATr_AUTONEG_ABILITYf_GET
#define MII_STATr_AUTONEG_ABILITYf_SET BCM54684_MII_STATr_AUTONEG_ABILITYf_SET
#define MII_STATr_LINKf_GET BCM54684_MII_STATr_LINKf_GET
#define MII_STATr_LINKf_SET BCM54684_MII_STATr_LINKf_SET
#define MII_STATr_JABBER_DETECTf_GET BCM54684_MII_STATr_JABBER_DETECTf_GET
#define MII_STATr_JABBER_DETECTf_SET BCM54684_MII_STATr_JABBER_DETECTf_SET
#define MII_STATr_EXT_CAPABILITYf_GET BCM54684_MII_STATr_EXT_CAPABILITYf_GET
#define MII_STATr_EXT_CAPABILITYf_SET BCM54684_MII_STATr_EXT_CAPABILITYf_SET
#define READ_MII_STATr BCM54684_READ_MII_STATr
#define WRITE_MII_STATr BCM54684_WRITE_MII_STATr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM54684_MII_STATr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM54684
 * REGISTER:  MII_PHY_ID0
 * BLOCKS:   IEEE
 * REGADDR:  0x0002
 * DESC:     1000BASE-T/100BASE-TX/10BASE-T PHY Identifier Register (Addr 02h)
 * SIZE:     32
 * FIELDS:
 *     REGID            16 MSBs of PHY identifier.
 *
 ******************************************************************************/
#define BCM54684_MII_PHY_ID0r (0x00000002 | PHY_REG_ACC_RAW)

#define BCM54684_MII_PHY_ID0r_SIZE 4

/*
 * This structure should be used to declare and program MII_PHY_ID0.
 *
 */
typedef union BCM54684_MII_PHY_ID0r_s {
	uint32_t v[1];
	uint32_t mii_phy_id0[1];
	uint32_t _mii_phy_id0;
} BCM54684_MII_PHY_ID0r_t;

#define BCM54684_MII_PHY_ID0r_CLR(r) (r).mii_phy_id0[0] = 0
#define BCM54684_MII_PHY_ID0r_SET(r,d) (r).mii_phy_id0[0] = d
#define BCM54684_MII_PHY_ID0r_GET(r) (r).mii_phy_id0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM54684_MII_PHY_ID0r_REGIDf_GET(r) (((r).mii_phy_id0[0]) & 0xffff)
#define BCM54684_MII_PHY_ID0r_REGIDf_SET(r,f) (r).mii_phy_id0[0]=(((r).mii_phy_id0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access MII_PHY_ID0.
 *
 */
#define BCM54684_READ_MII_PHY_ID0r(_pc,_r) PHY_REG_READ(_pc,BCM54684_MII_PHY_ID0r,_r._mii_phy_id0)
#define BCM54684_WRITE_MII_PHY_ID0r(_pc,_r) PHY_REG_WRITE(_pc,BCM54684_MII_PHY_ID0r,_r._mii_phy_id0)

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MII_PHY_ID0r BCM54684_MII_PHY_ID0r
#define MII_PHY_ID0r_SIZE BCM54684_MII_PHY_ID0r_SIZE
typedef BCM54684_MII_PHY_ID0r_t MII_PHY_ID0r_t;
#define MII_PHY_ID0r_CLR BCM54684_MII_PHY_ID0r_CLR
#define MII_PHY_ID0r_SET BCM54684_MII_PHY_ID0r_SET
#define MII_PHY_ID0r_GET BCM54684_MII_PHY_ID0r_GET
#define MII_PHY_ID0r_REGIDf_GET BCM54684_MII_PHY_ID0r_REGIDf_GET
#define MII_PHY_ID0r_REGIDf_SET BCM54684_MII_PHY_ID0r_REGIDf_SET
#define READ_MII_PHY_ID0r BCM54684_READ_MII_PHY_ID0r
#define WRITE_MII_PHY_ID0r BCM54684_WRITE_MII_PHY_ID0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM54684_MII_PHY_ID0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM54684
 * REGISTER:  MII_PHY_ID1
 * BLOCKS:   IEEE
 * REGADDR:  0x0003
 * DESC:     1000BASE-T/100BASE-TX/10BASE-T PHY Identifier Register (Addr 03h)
 * SIZE:     32
 * FIELDS:
 *     REGID            16 LSBs of PHY identifier.
 *
 ******************************************************************************/
#define BCM54684_MII_PHY_ID1r (0x00000003 | PHY_REG_ACC_RAW)

#define BCM54684_MII_PHY_ID1r_SIZE 4

/*
 * This structure should be used to declare and program MII_PHY_ID1.
 *
 */
typedef union BCM54684_MII_PHY_ID1r_s {
	uint32_t v[1];
	uint32_t mii_phy_id1[1];
	uint32_t _mii_phy_id1;
} BCM54684_MII_PHY_ID1r_t;

#define BCM54684_MII_PHY_ID1r_CLR(r) (r).mii_phy_id1[0] = 0
#define BCM54684_MII_PHY_ID1r_SET(r,d) (r).mii_phy_id1[0] = d
#define BCM54684_MII_PHY_ID1r_GET(r) (r).mii_phy_id1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM54684_MII_PHY_ID1r_REGIDf_GET(r) (((r).mii_phy_id1[0]) & 0xffff)
#define BCM54684_MII_PHY_ID1r_REGIDf_SET(r,f) (r).mii_phy_id1[0]=(((r).mii_phy_id1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access MII_PHY_ID1.
 *
 */
#define BCM54684_READ_MII_PHY_ID1r(_pc,_r) PHY_REG_READ(_pc,BCM54684_MII_PHY_ID1r,_r._mii_phy_id1)
#define BCM54684_WRITE_MII_PHY_ID1r(_pc,_r) PHY_REG_WRITE(_pc,BCM54684_MII_PHY_ID1r,_r._mii_phy_id1)

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MII_PHY_ID1r BCM54684_MII_PHY_ID1r
#define MII_PHY_ID1r_SIZE BCM54684_MII_PHY_ID1r_SIZE
typedef BCM54684_MII_PHY_ID1r_t MII_PHY_ID1r_t;
#define MII_PHY_ID1r_CLR BCM54684_MII_PHY_ID1r_CLR
#define MII_PHY_ID1r_SET BCM54684_MII_PHY_ID1r_SET
#define MII_PHY_ID1r_GET BCM54684_MII_PHY_ID1r_GET
#define MII_PHY_ID1r_REGIDf_GET BCM54684_MII_PHY_ID1r_REGIDf_GET
#define MII_PHY_ID1r_REGIDf_SET BCM54684_MII_PHY_ID1r_REGIDf_SET
#define READ_MII_PHY_ID1r BCM54684_READ_MII_PHY_ID1r
#define WRITE_MII_PHY_ID1r BCM54684_WRITE_MII_PHY_ID1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM54684_MII_PHY_ID1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM54684
 * REGISTER:  MII_ANA
 * BLOCKS:   IEEE
 * REGADDR:  0x0004
 * DESC:     1000BASE-T/100BASE-TX/10BASE-T Auto-Negotiation Advertisment Register (Addr 04h)
 * SIZE:     32
 * FIELDS:
 *     PROTOCOL         Advertise protocol selector field.
 *     CAP_10BASE_T_HD  10BASE-T half-duplex capable.
 *     CAP_10BASE_T_FD  10BASE-T full-duplex capable.
 *     CAP_100BASE_TX_HD 100BASE-TX half-duplex capable.
 *     CAP_100BASE_TX_FD 100BASE-TX full-duplex capable.
 *     CAP_100BASE_T4   100BASE-T4 capable.
 *     PAUSE            Pause capable.
 *     ASYM_PAUSE       Advertise asymmetric pause.
 *     REMOTE_FAULT     Advertise remote fault detected.
 *     NEXT_PAGE        Next Page ability supported.
 *
 ******************************************************************************/
#define BCM54684_MII_ANAr (0x00000004 | PHY_REG_ACC_RAW)

#define BCM54684_MII_ANAr_SIZE 4

/*
 * This structure should be used to declare and program MII_ANA.
 *
 */
typedef union BCM54684_MII_ANAr_s {
	uint32_t v[1];
	uint32_t mii_ana[1];
	uint32_t _mii_ana;
} BCM54684_MII_ANAr_t;

#define BCM54684_MII_ANAr_CLR(r) (r).mii_ana[0] = 0
#define BCM54684_MII_ANAr_SET(r,d) (r).mii_ana[0] = d
#define BCM54684_MII_ANAr_GET(r) (r).mii_ana[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM54684_MII_ANAr_NEXT_PAGEf_GET(r) ((((r).mii_ana[0]) >> 15) & 0x1)
#define BCM54684_MII_ANAr_NEXT_PAGEf_SET(r,f) (r).mii_ana[0]=(((r).mii_ana[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM54684_MII_ANAr_REMOTE_FAULTf_GET(r) ((((r).mii_ana[0]) >> 13) & 0x1)
#define BCM54684_MII_ANAr_REMOTE_FAULTf_SET(r,f) (r).mii_ana[0]=(((r).mii_ana[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM54684_MII_ANAr_ASYM_PAUSEf_GET(r) ((((r).mii_ana[0]) >> 11) & 0x1)
#define BCM54684_MII_ANAr_ASYM_PAUSEf_SET(r,f) (r).mii_ana[0]=(((r).mii_ana[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM54684_MII_ANAr_PAUSEf_GET(r) ((((r).mii_ana[0]) >> 10) & 0x1)
#define BCM54684_MII_ANAr_PAUSEf_SET(r,f) (r).mii_ana[0]=(((r).mii_ana[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM54684_MII_ANAr_CAP_100BASE_T4f_GET(r) ((((r).mii_ana[0]) >> 9) & 0x1)
#define BCM54684_MII_ANAr_CAP_100BASE_T4f_SET(r,f) (r).mii_ana[0]=(((r).mii_ana[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM54684_MII_ANAr_CAP_100BASE_TX_FDf_GET(r) ((((r).mii_ana[0]) >> 8) & 0x1)
#define BCM54684_MII_ANAr_CAP_100BASE_TX_FDf_SET(r,f) (r).mii_ana[0]=(((r).mii_ana[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM54684_MII_ANAr_CAP_100BASE_TX_HDf_GET(r) ((((r).mii_ana[0]) >> 7) & 0x1)
#define BCM54684_MII_ANAr_CAP_100BASE_TX_HDf_SET(r,f) (r).mii_ana[0]=(((r).mii_ana[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM54684_MII_ANAr_CAP_10BASE_T_FDf_GET(r) ((((r).mii_ana[0]) >> 6) & 0x1)
#define BCM54684_MII_ANAr_CAP_10BASE_T_FDf_SET(r,f) (r).mii_ana[0]=(((r).mii_ana[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM54684_MII_ANAr_CAP_10BASE_T_HDf_GET(r) ((((r).mii_ana[0]) >> 5) & 0x1)
#define BCM54684_MII_ANAr_CAP_10BASE_T_HDf_SET(r,f) (r).mii_ana[0]=(((r).mii_ana[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM54684_MII_ANAr_PROTOCOLf_GET(r) (((r).mii_ana[0]) & 0x1f)
#define BCM54684_MII_ANAr_PROTOCOLf_SET(r,f) (r).mii_ana[0]=(((r).mii_ana[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))

/*
 * These macros can be used to access MII_ANA.
 *
 */
#define BCM54684_READ_MII_ANAr(_pc,_r) PHY_REG_READ(_pc,BCM54684_MII_ANAr,_r._mii_ana)
#define BCM54684_WRITE_MII_ANAr(_pc,_r) PHY_REG_WRITE(_pc,BCM54684_MII_ANAr,_r._mii_ana)

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MII_ANAr BCM54684_MII_ANAr
#define MII_ANAr_SIZE BCM54684_MII_ANAr_SIZE
typedef BCM54684_MII_ANAr_t MII_ANAr_t;
#define MII_ANAr_CLR BCM54684_MII_ANAr_CLR
#define MII_ANAr_SET BCM54684_MII_ANAr_SET
#define MII_ANAr_GET BCM54684_MII_ANAr_GET
#define MII_ANAr_NEXT_PAGEf_GET BCM54684_MII_ANAr_NEXT_PAGEf_GET
#define MII_ANAr_NEXT_PAGEf_SET BCM54684_MII_ANAr_NEXT_PAGEf_SET
#define MII_ANAr_REMOTE_FAULTf_GET BCM54684_MII_ANAr_REMOTE_FAULTf_GET
#define MII_ANAr_REMOTE_FAULTf_SET BCM54684_MII_ANAr_REMOTE_FAULTf_SET
#define MII_ANAr_ASYM_PAUSEf_GET BCM54684_MII_ANAr_ASYM_PAUSEf_GET
#define MII_ANAr_ASYM_PAUSEf_SET BCM54684_MII_ANAr_ASYM_PAUSEf_SET
#define MII_ANAr_PAUSEf_GET BCM54684_MII_ANAr_PAUSEf_GET
#define MII_ANAr_PAUSEf_SET BCM54684_MII_ANAr_PAUSEf_SET
#define MII_ANAr_CAP_100BASE_T4f_GET BCM54684_MII_ANAr_CAP_100BASE_T4f_GET
#define MII_ANAr_CAP_100BASE_T4f_SET BCM54684_MII_ANAr_CAP_100BASE_T4f_SET
#define MII_ANAr_CAP_100BASE_TX_FDf_GET BCM54684_MII_ANAr_CAP_100BASE_TX_FDf_GET
#define MII_ANAr_CAP_100BASE_TX_FDf_SET BCM54684_MII_ANAr_CAP_100BASE_TX_FDf_SET
#define MII_ANAr_CAP_100BASE_TX_HDf_GET BCM54684_MII_ANAr_CAP_100BASE_TX_HDf_GET
#define MII_ANAr_CAP_100BASE_TX_HDf_SET BCM54684_MII_ANAr_CAP_100BASE_TX_HDf_SET
#define MII_ANAr_CAP_10BASE_T_FDf_GET BCM54684_MII_ANAr_CAP_10BASE_T_FDf_GET
#define MII_ANAr_CAP_10BASE_T_FDf_SET BCM54684_MII_ANAr_CAP_10BASE_T_FDf_SET
#define MII_ANAr_CAP_10BASE_T_HDf_GET BCM54684_MII_ANAr_CAP_10BASE_T_HDf_GET
#define MII_ANAr_CAP_10BASE_T_HDf_SET BCM54684_MII_ANAr_CAP_10BASE_T_HDf_SET
#define MII_ANAr_PROTOCOLf_GET BCM54684_MII_ANAr_PROTOCOLf_GET
#define MII_ANAr_PROTOCOLf_SET BCM54684_MII_ANAr_PROTOCOLf_SET
#define READ_MII_ANAr BCM54684_READ_MII_ANAr
#define WRITE_MII_ANAr BCM54684_WRITE_MII_ANAr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM54684_MII_ANAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM54684
 * REGISTER:  MII_ANP
 * BLOCKS:   IEEE
 * REGADDR:  0x0005
 * DESC:     1000BASE-T/100BASE-TX/10BASE-T Auto-Negotiation Link Partner Ability (Addr 05h)
 * SIZE:     32
 * FIELDS:
 *     PROTOCOL         Link partner is protocol selector field.
 *     CAP_10BASE_T_HD  Link partner is 10BASE-T half-duplex capable.
 *     CAP_10BASE_T_FD  Link partner is 10BASE-T full-duplex capable.
 *     CAP_100BASE_TX_HD Link partner is 100BASE-TX half-duplex capable.
 *     CAP_100BASE_TX_FD Link partner is 100BASE-TX full-duplex capable.
 *     CAP_100BASE_T4   Link partner is 100BASE-T4 capable.
 *     PAUSE            Link partner is capable of pause operation.
 *     ASYM_PAUSE       Link partner wants asymmetric pause.
 *     REMOTE_FAULT     Link partner has detected remote fault.
 *     ACK              Link partner has received link code word.
 *     NEXT_PAGE        Link partner has Next Page ability.
 *
 ******************************************************************************/
#define BCM54684_MII_ANPr (0x00000005 | PHY_REG_ACC_RAW)

#define BCM54684_MII_ANPr_SIZE 4

/*
 * This structure should be used to declare and program MII_ANP.
 *
 */
typedef union BCM54684_MII_ANPr_s {
	uint32_t v[1];
	uint32_t mii_anp[1];
	uint32_t _mii_anp;
} BCM54684_MII_ANPr_t;

#define BCM54684_MII_ANPr_CLR(r) (r).mii_anp[0] = 0
#define BCM54684_MII_ANPr_SET(r,d) (r).mii_anp[0] = d
#define BCM54684_MII_ANPr_GET(r) (r).mii_anp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM54684_MII_ANPr_NEXT_PAGEf_GET(r) ((((r).mii_anp[0]) >> 15) & 0x1)
#define BCM54684_MII_ANPr_NEXT_PAGEf_SET(r,f) (r).mii_anp[0]=(((r).mii_anp[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM54684_MII_ANPr_ACKf_GET(r) ((((r).mii_anp[0]) >> 14) & 0x1)
#define BCM54684_MII_ANPr_ACKf_SET(r,f) (r).mii_anp[0]=(((r).mii_anp[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM54684_MII_ANPr_REMOTE_FAULTf_GET(r) ((((r).mii_anp[0]) >> 13) & 0x1)
#define BCM54684_MII_ANPr_REMOTE_FAULTf_SET(r,f) (r).mii_anp[0]=(((r).mii_anp[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM54684_MII_ANPr_ASYM_PAUSEf_GET(r) ((((r).mii_anp[0]) >> 11) & 0x1)
#define BCM54684_MII_ANPr_ASYM_PAUSEf_SET(r,f) (r).mii_anp[0]=(((r).mii_anp[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM54684_MII_ANPr_PAUSEf_GET(r) ((((r).mii_anp[0]) >> 10) & 0x1)
#define BCM54684_MII_ANPr_PAUSEf_SET(r,f) (r).mii_anp[0]=(((r).mii_anp[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM54684_MII_ANPr_CAP_100BASE_T4f_GET(r) ((((r).mii_anp[0]) >> 9) & 0x1)
#define BCM54684_MII_ANPr_CAP_100BASE_T4f_SET(r,f) (r).mii_anp[0]=(((r).mii_anp[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM54684_MII_ANPr_CAP_100BASE_TX_FDf_GET(r) ((((r).mii_anp[0]) >> 8) & 0x1)
#define BCM54684_MII_ANPr_CAP_100BASE_TX_FDf_SET(r,f) (r).mii_anp[0]=(((r).mii_anp[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM54684_MII_ANPr_CAP_100BASE_TX_HDf_GET(r) ((((r).mii_anp[0]) >> 7) & 0x1)
#define BCM54684_MII_ANPr_CAP_100BASE_TX_HDf_SET(r,f) (r).mii_anp[0]=(((r).mii_anp[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM54684_MII_ANPr_CAP_10BASE_T_FDf_GET(r) ((((r).mii_anp[0]) >> 6) & 0x1)
#define BCM54684_MII_ANPr_CAP_10BASE_T_FDf_SET(r,f) (r).mii_anp[0]=(((r).mii_anp[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM54684_MII_ANPr_CAP_10BASE_T_HDf_GET(r) ((((r).mii_anp[0]) >> 5) & 0x1)
#define BCM54684_MII_ANPr_CAP_10BASE_T_HDf_SET(r,f) (r).mii_anp[0]=(((r).mii_anp[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM54684_MII_ANPr_PROTOCOLf_GET(r) (((r).mii_anp[0]) & 0x1f)
#define BCM54684_MII_ANPr_PROTOCOLf_SET(r,f) (r).mii_anp[0]=(((r).mii_anp[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))

/*
 * These macros can be used to access MII_ANP.
 *
 */
#define BCM54684_READ_MII_ANPr(_pc,_r) PHY_REG_READ(_pc,BCM54684_MII_ANPr,_r._mii_anp)
#define BCM54684_WRITE_MII_ANPr(_pc,_r) PHY_REG_WRITE(_pc,BCM54684_MII_ANPr,_r._mii_anp)

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MII_ANPr BCM54684_MII_ANPr
#define MII_ANPr_SIZE BCM54684_MII_ANPr_SIZE
typedef BCM54684_MII_ANPr_t MII_ANPr_t;
#define MII_ANPr_CLR BCM54684_MII_ANPr_CLR
#define MII_ANPr_SET BCM54684_MII_ANPr_SET
#define MII_ANPr_GET BCM54684_MII_ANPr_GET
#define MII_ANPr_NEXT_PAGEf_GET BCM54684_MII_ANPr_NEXT_PAGEf_GET
#define MII_ANPr_NEXT_PAGEf_SET BCM54684_MII_ANPr_NEXT_PAGEf_SET
#define MII_ANPr_ACKf_GET BCM54684_MII_ANPr_ACKf_GET
#define MII_ANPr_ACKf_SET BCM54684_MII_ANPr_ACKf_SET
#define MII_ANPr_REMOTE_FAULTf_GET BCM54684_MII_ANPr_REMOTE_FAULTf_GET
#define MII_ANPr_REMOTE_FAULTf_SET BCM54684_MII_ANPr_REMOTE_FAULTf_SET
#define MII_ANPr_ASYM_PAUSEf_GET BCM54684_MII_ANPr_ASYM_PAUSEf_GET
#define MII_ANPr_ASYM_PAUSEf_SET BCM54684_MII_ANPr_ASYM_PAUSEf_SET
#define MII_ANPr_PAUSEf_GET BCM54684_MII_ANPr_PAUSEf_GET
#define MII_ANPr_PAUSEf_SET BCM54684_MII_ANPr_PAUSEf_SET
#define MII_ANPr_CAP_100BASE_T4f_GET BCM54684_MII_ANPr_CAP_100BASE_T4f_GET
#define MII_ANPr_CAP_100BASE_T4f_SET BCM54684_MII_ANPr_CAP_100BASE_T4f_SET
#define MII_ANPr_CAP_100BASE_TX_FDf_GET BCM54684_MII_ANPr_CAP_100BASE_TX_FDf_GET
#define MII_ANPr_CAP_100BASE_TX_FDf_SET BCM54684_MII_ANPr_CAP_100BASE_TX_FDf_SET
#define MII_ANPr_CAP_100BASE_TX_HDf_GET BCM54684_MII_ANPr_CAP_100BASE_TX_HDf_GET
#define MII_ANPr_CAP_100BASE_TX_HDf_SET BCM54684_MII_ANPr_CAP_100BASE_TX_HDf_SET
#define MII_ANPr_CAP_10BASE_T_FDf_GET BCM54684_MII_ANPr_CAP_10BASE_T_FDf_GET
#define MII_ANPr_CAP_10BASE_T_FDf_SET BCM54684_MII_ANPr_CAP_10BASE_T_FDf_SET
#define MII_ANPr_CAP_10BASE_T_HDf_GET BCM54684_MII_ANPr_CAP_10BASE_T_HDf_GET
#define MII_ANPr_CAP_10BASE_T_HDf_SET BCM54684_MII_ANPr_CAP_10BASE_T_HDf_SET
#define MII_ANPr_PROTOCOLf_GET BCM54684_MII_ANPr_PROTOCOLf_GET
#define MII_ANPr_PROTOCOLf_SET BCM54684_MII_ANPr_PROTOCOLf_SET
#define READ_MII_ANPr BCM54684_READ_MII_ANPr
#define WRITE_MII_ANPr BCM54684_WRITE_MII_ANPr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM54684_MII_ANPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM54684
 * REGISTER:  MII_AN_EXP
 * BLOCKS:   IEEE
 * REGADDR:  0x0006
 * DESC:     1000BASE-T/100BASE-TX/10BASE-T Auto-Negotiation Expansion Register (Addr 06h)
 * SIZE:     32
 * FIELDS:
 *     LP_AN_ABIL       Link partner has auto-negotiation ability.
 *     PAGE_RECEIVED    New page has been receive from link partner.
 *     NEXT_PAGE        Local Next Page capability.
 *     LP_NEXT_PAGE     Link partner has Next Page capability.
 *     PARDET_FAULT     Parallel link fault detected.
 *
 ******************************************************************************/
#define BCM54684_MII_AN_EXPr (0x00000006 | PHY_REG_ACC_RAW)

#define BCM54684_MII_AN_EXPr_SIZE 4

/*
 * This structure should be used to declare and program MII_AN_EXP.
 *
 */
typedef union BCM54684_MII_AN_EXPr_s {
	uint32_t v[1];
	uint32_t mii_an_exp[1];
	uint32_t _mii_an_exp;
} BCM54684_MII_AN_EXPr_t;

#define BCM54684_MII_AN_EXPr_CLR(r) (r).mii_an_exp[0] = 0
#define BCM54684_MII_AN_EXPr_SET(r,d) (r).mii_an_exp[0] = d
#define BCM54684_MII_AN_EXPr_GET(r) (r).mii_an_exp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM54684_MII_AN_EXPr_PARDET_FAULTf_GET(r) ((((r).mii_an_exp[0]) >> 4) & 0x1)
#define BCM54684_MII_AN_EXPr_PARDET_FAULTf_SET(r,f) (r).mii_an_exp[0]=(((r).mii_an_exp[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM54684_MII_AN_EXPr_LP_NEXT_PAGEf_GET(r) ((((r).mii_an_exp[0]) >> 3) & 0x1)
#define BCM54684_MII_AN_EXPr_LP_NEXT_PAGEf_SET(r,f) (r).mii_an_exp[0]=(((r).mii_an_exp[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM54684_MII_AN_EXPr_NEXT_PAGEf_GET(r) ((((r).mii_an_exp[0]) >> 2) & 0x1)
#define BCM54684_MII_AN_EXPr_NEXT_PAGEf_SET(r,f) (r).mii_an_exp[0]=(((r).mii_an_exp[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM54684_MII_AN_EXPr_PAGE_RECEIVEDf_GET(r) ((((r).mii_an_exp[0]) >> 1) & 0x1)
#define BCM54684_MII_AN_EXPr_PAGE_RECEIVEDf_SET(r,f) (r).mii_an_exp[0]=(((r).mii_an_exp[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM54684_MII_AN_EXPr_LP_AN_ABILf_GET(r) (((r).mii_an_exp[0]) & 0x1)
#define BCM54684_MII_AN_EXPr_LP_AN_ABILf_SET(r,f) (r).mii_an_exp[0]=(((r).mii_an_exp[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access MII_AN_EXP.
 *
 */
#define BCM54684_READ_MII_AN_EXPr(_pc,_r) PHY_REG_READ(_pc,BCM54684_MII_AN_EXPr,_r._mii_an_exp)
#define BCM54684_WRITE_MII_AN_EXPr(_pc,_r) PHY_REG_WRITE(_pc,BCM54684_MII_AN_EXPr,_r._mii_an_exp)

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MII_AN_EXPr BCM54684_MII_AN_EXPr
#define MII_AN_EXPr_SIZE BCM54684_MII_AN_EXPr_SIZE
typedef BCM54684_MII_AN_EXPr_t MII_AN_EXPr_t;
#define MII_AN_EXPr_CLR BCM54684_MII_AN_EXPr_CLR
#define MII_AN_EXPr_SET BCM54684_MII_AN_EXPr_SET
#define MII_AN_EXPr_GET BCM54684_MII_AN_EXPr_GET
#define MII_AN_EXPr_PARDET_FAULTf_GET BCM54684_MII_AN_EXPr_PARDET_FAULTf_GET
#define MII_AN_EXPr_PARDET_FAULTf_SET BCM54684_MII_AN_EXPr_PARDET_FAULTf_SET
#define MII_AN_EXPr_LP_NEXT_PAGEf_GET BCM54684_MII_AN_EXPr_LP_NEXT_PAGEf_GET
#define MII_AN_EXPr_LP_NEXT_PAGEf_SET BCM54684_MII_AN_EXPr_LP_NEXT_PAGEf_SET
#define MII_AN_EXPr_NEXT_PAGEf_GET BCM54684_MII_AN_EXPr_NEXT_PAGEf_GET
#define MII_AN_EXPr_NEXT_PAGEf_SET BCM54684_MII_AN_EXPr_NEXT_PAGEf_SET
#define MII_AN_EXPr_PAGE_RECEIVEDf_GET BCM54684_MII_AN_EXPr_PAGE_RECEIVEDf_GET
#define MII_AN_EXPr_PAGE_RECEIVEDf_SET BCM54684_MII_AN_EXPr_PAGE_RECEIVEDf_SET
#define MII_AN_EXPr_LP_AN_ABILf_GET BCM54684_MII_AN_EXPr_LP_AN_ABILf_GET
#define MII_AN_EXPr_LP_AN_ABILf_SET BCM54684_MII_AN_EXPr_LP_AN_ABILf_SET
#define READ_MII_AN_EXPr BCM54684_READ_MII_AN_EXPr
#define WRITE_MII_AN_EXPr BCM54684_WRITE_MII_AN_EXPr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM54684_MII_AN_EXPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM54684
 * REGISTER:  MII_GB_CTRL
 * BLOCKS:   IEEE
 * REGADDR:  0x0009
 * DESC:     1000BASE-T Control Register (Addr 09h)
 * SIZE:     32
 * FIELDS:
 *     CAP_1000BASE_T_HD Advertise 1000BASE-T half-duplex capability.
 *     CAP_1000BASE_T_FD Advertise 1000BASE-T full-duplex capability.
 *     SWITCH_DEV       Repeater/DTE device mode.
 *     MASTER           Configure PHY as master.
 *     MS_MAN           Enable manual master/slave configuration.
 *     TEST_MODE        Test mode.
 *
 ******************************************************************************/
#define BCM54684_MII_GB_CTRLr (0x00000009 | PHY_REG_ACC_RAW)

#define BCM54684_MII_GB_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program MII_GB_CTRL.
 *
 */
typedef union BCM54684_MII_GB_CTRLr_s {
	uint32_t v[1];
	uint32_t mii_gb_ctrl[1];
	uint32_t _mii_gb_ctrl;
} BCM54684_MII_GB_CTRLr_t;

#define BCM54684_MII_GB_CTRLr_CLR(r) (r).mii_gb_ctrl[0] = 0
#define BCM54684_MII_GB_CTRLr_SET(r,d) (r).mii_gb_ctrl[0] = d
#define BCM54684_MII_GB_CTRLr_GET(r) (r).mii_gb_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM54684_MII_GB_CTRLr_TEST_MODEf_GET(r) ((((r).mii_gb_ctrl[0]) >> 13) & 0x7)
#define BCM54684_MII_GB_CTRLr_TEST_MODEf_SET(r,f) (r).mii_gb_ctrl[0]=(((r).mii_gb_ctrl[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))
#define BCM54684_MII_GB_CTRLr_MS_MANf_GET(r) ((((r).mii_gb_ctrl[0]) >> 12) & 0x1)
#define BCM54684_MII_GB_CTRLr_MS_MANf_SET(r,f) (r).mii_gb_ctrl[0]=(((r).mii_gb_ctrl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM54684_MII_GB_CTRLr_MASTERf_GET(r) ((((r).mii_gb_ctrl[0]) >> 11) & 0x1)
#define BCM54684_MII_GB_CTRLr_MASTERf_SET(r,f) (r).mii_gb_ctrl[0]=(((r).mii_gb_ctrl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM54684_MII_GB_CTRLr_SWITCH_DEVf_GET(r) ((((r).mii_gb_ctrl[0]) >> 10) & 0x1)
#define BCM54684_MII_GB_CTRLr_SWITCH_DEVf_SET(r,f) (r).mii_gb_ctrl[0]=(((r).mii_gb_ctrl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM54684_MII_GB_CTRLr_CAP_1000BASE_T_FDf_GET(r) ((((r).mii_gb_ctrl[0]) >> 9) & 0x1)
#define BCM54684_MII_GB_CTRLr_CAP_1000BASE_T_FDf_SET(r,f) (r).mii_gb_ctrl[0]=(((r).mii_gb_ctrl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM54684_MII_GB_CTRLr_CAP_1000BASE_T_HDf_GET(r) ((((r).mii_gb_ctrl[0]) >> 8) & 0x1)
#define BCM54684_MII_GB_CTRLr_CAP_1000BASE_T_HDf_SET(r,f) (r).mii_gb_ctrl[0]=(((r).mii_gb_ctrl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))

/*
 * These macros can be used to access MII_GB_CTRL.
 *
 */
#define BCM54684_READ_MII_GB_CTRLr(_pc,_r) PHY_REG_READ(_pc,BCM54684_MII_GB_CTRLr,_r._mii_gb_ctrl)
#define BCM54684_WRITE_MII_GB_CTRLr(_pc,_r) PHY_REG_WRITE(_pc,BCM54684_MII_GB_CTRLr,_r._mii_gb_ctrl)

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MII_GB_CTRLr BCM54684_MII_GB_CTRLr
#define MII_GB_CTRLr_SIZE BCM54684_MII_GB_CTRLr_SIZE
typedef BCM54684_MII_GB_CTRLr_t MII_GB_CTRLr_t;
#define MII_GB_CTRLr_CLR BCM54684_MII_GB_CTRLr_CLR
#define MII_GB_CTRLr_SET BCM54684_MII_GB_CTRLr_SET
#define MII_GB_CTRLr_GET BCM54684_MII_GB_CTRLr_GET
#define MII_GB_CTRLr_TEST_MODEf_GET BCM54684_MII_GB_CTRLr_TEST_MODEf_GET
#define MII_GB_CTRLr_TEST_MODEf_SET BCM54684_MII_GB_CTRLr_TEST_MODEf_SET
#define MII_GB_CTRLr_MS_MANf_GET BCM54684_MII_GB_CTRLr_MS_MANf_GET
#define MII_GB_CTRLr_MS_MANf_SET BCM54684_MII_GB_CTRLr_MS_MANf_SET
#define MII_GB_CTRLr_MASTERf_GET BCM54684_MII_GB_CTRLr_MASTERf_GET
#define MII_GB_CTRLr_MASTERf_SET BCM54684_MII_GB_CTRLr_MASTERf_SET
#define MII_GB_CTRLr_SWITCH_DEVf_GET BCM54684_MII_GB_CTRLr_SWITCH_DEVf_GET
#define MII_GB_CTRLr_SWITCH_DEVf_SET BCM54684_MII_GB_CTRLr_SWITCH_DEVf_SET
#define MII_GB_CTRLr_CAP_1000BASE_T_FDf_GET BCM54684_MII_GB_CTRLr_CAP_1000BASE_T_FDf_GET
#define MII_GB_CTRLr_CAP_1000BASE_T_FDf_SET BCM54684_MII_GB_CTRLr_CAP_1000BASE_T_FDf_SET
#define MII_GB_CTRLr_CAP_1000BASE_T_HDf_GET BCM54684_MII_GB_CTRLr_CAP_1000BASE_T_HDf_GET
#define MII_GB_CTRLr_CAP_1000BASE_T_HDf_SET BCM54684_MII_GB_CTRLr_CAP_1000BASE_T_HDf_SET
#define READ_MII_GB_CTRLr BCM54684_READ_MII_GB_CTRLr
#define WRITE_MII_GB_CTRLr BCM54684_WRITE_MII_GB_CTRLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM54684_MII_GB_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM54684
 * REGISTER:  MII_GB_STAT
 * BLOCKS:   IEEE
 * REGADDR:  0x000a
 * DESC:     1000BASE-T Status Register (Addr 0Ah)
 * SIZE:     32
 * FIELDS:
 *     IDLE_ERRORS      Number of idle errors since last read.
 *     LP_1000BASE_T_HD Link partner is 1000BASE-T half-duplex capable.
 *     LP_1000BASE_T_FD Link partner is 1000BASE-T full-duplex capable.
 *     REMOTE_RCV_OK    Remote receiver OK.
 *     LOCAL_RCV_OK     Local receiver OK.
 *     LOCAL_MASTER     Local transmitter is master.
 *     MS_CFG_FAULT     Master/slave configuration fault detected.
 *
 ******************************************************************************/
#define BCM54684_MII_GB_STATr (0x0000000a | PHY_REG_ACC_RAW)

#define BCM54684_MII_GB_STATr_SIZE 4

/*
 * This structure should be used to declare and program MII_GB_STAT.
 *
 */
typedef union BCM54684_MII_GB_STATr_s {
	uint32_t v[1];
	uint32_t mii_gb_stat[1];
	uint32_t _mii_gb_stat;
} BCM54684_MII_GB_STATr_t;

#define BCM54684_MII_GB_STATr_CLR(r) (r).mii_gb_stat[0] = 0
#define BCM54684_MII_GB_STATr_SET(r,d) (r).mii_gb_stat[0] = d
#define BCM54684_MII_GB_STATr_GET(r) (r).mii_gb_stat[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM54684_MII_GB_STATr_MS_CFG_FAULTf_GET(r) ((((r).mii_gb_stat[0]) >> 15) & 0x1)
#define BCM54684_MII_GB_STATr_MS_CFG_FAULTf_SET(r,f) (r).mii_gb_stat[0]=(((r).mii_gb_stat[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM54684_MII_GB_STATr_LOCAL_MASTERf_GET(r) ((((r).mii_gb_stat[0]) >> 14) & 0x1)
#define BCM54684_MII_GB_STATr_LOCAL_MASTERf_SET(r,f) (r).mii_gb_stat[0]=(((r).mii_gb_stat[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM54684_MII_GB_STATr_LOCAL_RCV_OKf_GET(r) ((((r).mii_gb_stat[0]) >> 13) & 0x1)
#define BCM54684_MII_GB_STATr_LOCAL_RCV_OKf_SET(r,f) (r).mii_gb_stat[0]=(((r).mii_gb_stat[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM54684_MII_GB_STATr_REMOTE_RCV_OKf_GET(r) ((((r).mii_gb_stat[0]) >> 12) & 0x1)
#define BCM54684_MII_GB_STATr_REMOTE_RCV_OKf_SET(r,f) (r).mii_gb_stat[0]=(((r).mii_gb_stat[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM54684_MII_GB_STATr_LP_1000BASE_T_FDf_GET(r) ((((r).mii_gb_stat[0]) >> 11) & 0x1)
#define BCM54684_MII_GB_STATr_LP_1000BASE_T_FDf_SET(r,f) (r).mii_gb_stat[0]=(((r).mii_gb_stat[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM54684_MII_GB_STATr_LP_1000BASE_T_HDf_GET(r) ((((r).mii_gb_stat[0]) >> 10) & 0x1)
#define BCM54684_MII_GB_STATr_LP_1000BASE_T_HDf_SET(r,f) (r).mii_gb_stat[0]=(((r).mii_gb_stat[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM54684_MII_GB_STATr_IDLE_ERRORSf_GET(r) (((r).mii_gb_stat[0]) & 0xff)
#define BCM54684_MII_GB_STATr_IDLE_ERRORSf_SET(r,f) (r).mii_gb_stat[0]=(((r).mii_gb_stat[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access MII_GB_STAT.
 *
 */
#define BCM54684_READ_MII_GB_STATr(_pc,_r) PHY_REG_READ(_pc,BCM54684_MII_GB_STATr,_r._mii_gb_stat)
#define BCM54684_WRITE_MII_GB_STATr(_pc,_r) PHY_REG_WRITE(_pc,BCM54684_MII_GB_STATr,_r._mii_gb_stat)

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MII_GB_STATr BCM54684_MII_GB_STATr
#define MII_GB_STATr_SIZE BCM54684_MII_GB_STATr_SIZE
typedef BCM54684_MII_GB_STATr_t MII_GB_STATr_t;
#define MII_GB_STATr_CLR BCM54684_MII_GB_STATr_CLR
#define MII_GB_STATr_SET BCM54684_MII_GB_STATr_SET
#define MII_GB_STATr_GET BCM54684_MII_GB_STATr_GET
#define MII_GB_STATr_MS_CFG_FAULTf_GET BCM54684_MII_GB_STATr_MS_CFG_FAULTf_GET
#define MII_GB_STATr_MS_CFG_FAULTf_SET BCM54684_MII_GB_STATr_MS_CFG_FAULTf_SET
#define MII_GB_STATr_LOCAL_MASTERf_GET BCM54684_MII_GB_STATr_LOCAL_MASTERf_GET
#define MII_GB_STATr_LOCAL_MASTERf_SET BCM54684_MII_GB_STATr_LOCAL_MASTERf_SET
#define MII_GB_STATr_LOCAL_RCV_OKf_GET BCM54684_MII_GB_STATr_LOCAL_RCV_OKf_GET
#define MII_GB_STATr_LOCAL_RCV_OKf_SET BCM54684_MII_GB_STATr_LOCAL_RCV_OKf_SET
#define MII_GB_STATr_REMOTE_RCV_OKf_GET BCM54684_MII_GB_STATr_REMOTE_RCV_OKf_GET
#define MII_GB_STATr_REMOTE_RCV_OKf_SET BCM54684_MII_GB_STATr_REMOTE_RCV_OKf_SET
#define MII_GB_STATr_LP_1000BASE_T_FDf_GET BCM54684_MII_GB_STATr_LP_1000BASE_T_FDf_GET
#define MII_GB_STATr_LP_1000BASE_T_FDf_SET BCM54684_MII_GB_STATr_LP_1000BASE_T_FDf_SET
#define MII_GB_STATr_LP_1000BASE_T_HDf_GET BCM54684_MII_GB_STATr_LP_1000BASE_T_HDf_GET
#define MII_GB_STATr_LP_1000BASE_T_HDf_SET BCM54684_MII_GB_STATr_LP_1000BASE_T_HDf_SET
#define MII_GB_STATr_IDLE_ERRORSf_GET BCM54684_MII_GB_STATr_IDLE_ERRORSf_GET
#define MII_GB_STATr_IDLE_ERRORSf_SET BCM54684_MII_GB_STATr_IDLE_ERRORSf_SET
#define READ_MII_GB_STATr BCM54684_READ_MII_GB_STATr
#define WRITE_MII_GB_STATr BCM54684_WRITE_MII_GB_STATr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM54684_MII_GB_STATr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM54684
 * REGISTER:  MII_ESR
 * BLOCKS:   IEEE
 * REGADDR:  0x000f
 * DESC:     1000BASE-T/100BASE-TX/10BASE-T IEEE Extended Status Register (Addr 0Fh)
 * SIZE:     32
 * FIELDS:
 *     CAP_1000BASE_T_HD 1000BASE-T half-duplex capable.
 *     CAP_1000BASE_T_FD 1000BASE-T full-duplex capable.
 *     CAP_1000BASE_X_HD 1000BASE-X half-duplex capable.
 *     CAP_1000BASE_X_FD 1000BASE-X full-duplex capable.
 *
 ******************************************************************************/
#define BCM54684_MII_ESRr (0x0000000f | PHY_REG_ACC_RAW)

#define BCM54684_MII_ESRr_SIZE 4

/*
 * This structure should be used to declare and program MII_ESR.
 *
 */
typedef union BCM54684_MII_ESRr_s {
	uint32_t v[1];
	uint32_t mii_esr[1];
	uint32_t _mii_esr;
} BCM54684_MII_ESRr_t;

#define BCM54684_MII_ESRr_CLR(r) (r).mii_esr[0] = 0
#define BCM54684_MII_ESRr_SET(r,d) (r).mii_esr[0] = d
#define BCM54684_MII_ESRr_GET(r) (r).mii_esr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM54684_MII_ESRr_CAP_1000BASE_X_FDf_GET(r) ((((r).mii_esr[0]) >> 15) & 0x1)
#define BCM54684_MII_ESRr_CAP_1000BASE_X_FDf_SET(r,f) (r).mii_esr[0]=(((r).mii_esr[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM54684_MII_ESRr_CAP_1000BASE_X_HDf_GET(r) ((((r).mii_esr[0]) >> 14) & 0x1)
#define BCM54684_MII_ESRr_CAP_1000BASE_X_HDf_SET(r,f) (r).mii_esr[0]=(((r).mii_esr[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM54684_MII_ESRr_CAP_1000BASE_T_FDf_GET(r) ((((r).mii_esr[0]) >> 13) & 0x1)
#define BCM54684_MII_ESRr_CAP_1000BASE_T_FDf_SET(r,f) (r).mii_esr[0]=(((r).mii_esr[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM54684_MII_ESRr_CAP_1000BASE_T_HDf_GET(r) ((((r).mii_esr[0]) >> 12) & 0x1)
#define BCM54684_MII_ESRr_CAP_1000BASE_T_HDf_SET(r,f) (r).mii_esr[0]=(((r).mii_esr[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))

/*
 * These macros can be used to access MII_ESR.
 *
 */
#define BCM54684_READ_MII_ESRr(_pc,_r) PHY_REG_READ(_pc,BCM54684_MII_ESRr,_r._mii_esr)
#define BCM54684_WRITE_MII_ESRr(_pc,_r) PHY_REG_WRITE(_pc,BCM54684_MII_ESRr,_r._mii_esr)

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MII_ESRr BCM54684_MII_ESRr
#define MII_ESRr_SIZE BCM54684_MII_ESRr_SIZE
typedef BCM54684_MII_ESRr_t MII_ESRr_t;
#define MII_ESRr_CLR BCM54684_MII_ESRr_CLR
#define MII_ESRr_SET BCM54684_MII_ESRr_SET
#define MII_ESRr_GET BCM54684_MII_ESRr_GET
#define MII_ESRr_CAP_1000BASE_X_FDf_GET BCM54684_MII_ESRr_CAP_1000BASE_X_FDf_GET
#define MII_ESRr_CAP_1000BASE_X_FDf_SET BCM54684_MII_ESRr_CAP_1000BASE_X_FDf_SET
#define MII_ESRr_CAP_1000BASE_X_HDf_GET BCM54684_MII_ESRr_CAP_1000BASE_X_HDf_GET
#define MII_ESRr_CAP_1000BASE_X_HDf_SET BCM54684_MII_ESRr_CAP_1000BASE_X_HDf_SET
#define MII_ESRr_CAP_1000BASE_T_FDf_GET BCM54684_MII_ESRr_CAP_1000BASE_T_FDf_GET
#define MII_ESRr_CAP_1000BASE_T_FDf_SET BCM54684_MII_ESRr_CAP_1000BASE_T_FDf_SET
#define MII_ESRr_CAP_1000BASE_T_HDf_GET BCM54684_MII_ESRr_CAP_1000BASE_T_HDf_GET
#define MII_ESRr_CAP_1000BASE_T_HDf_SET BCM54684_MII_ESRr_CAP_1000BASE_T_HDf_SET
#define READ_MII_ESRr BCM54684_READ_MII_ESRr
#define WRITE_MII_ESRr BCM54684_WRITE_MII_ESRr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM54684_MII_ESRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM54684
 * REGISTER:  MII_PHY_ECR
 * BLOCKS:   USER
 * REGADDR:  0x0010
 * DESC:     1000BASE-T/100BASE-TX/10BASE-T PHY Extended Control Register (Addr 10h)
 * SIZE:     32
 * FIELDS:
 *     MII_PHY_ECR      MII_PHY_ECR
 *
 ******************************************************************************/
#define BCM54684_MII_PHY_ECRr (0x00000010 | PHY_REG_ACC_RAW)

#define BCM54684_MII_PHY_ECRr_SIZE 4

/*
 * This structure should be used to declare and program MII_PHY_ECR.
 *
 */
typedef union BCM54684_MII_PHY_ECRr_s {
	uint32_t v[1];
	uint32_t mii_phy_ecr[1];
	uint32_t _mii_phy_ecr;
} BCM54684_MII_PHY_ECRr_t;

#define BCM54684_MII_PHY_ECRr_CLR(r) (r).mii_phy_ecr[0] = 0
#define BCM54684_MII_PHY_ECRr_SET(r,d) (r).mii_phy_ecr[0] = d
#define BCM54684_MII_PHY_ECRr_GET(r) (r).mii_phy_ecr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM54684_MII_PHY_ECRr_MII_PHY_ECRf_GET(r) (((r).mii_phy_ecr[0]) & 0xffff)
#define BCM54684_MII_PHY_ECRr_MII_PHY_ECRf_SET(r,f) (r).mii_phy_ecr[0]=(((r).mii_phy_ecr[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access MII_PHY_ECR.
 *
 */
#define BCM54684_READ_MII_PHY_ECRr(_pc,_r) PHY_REG_READ(_pc,BCM54684_MII_PHY_ECRr,_r._mii_phy_ecr)
#define BCM54684_WRITE_MII_PHY_ECRr(_pc,_r) PHY_REG_WRITE(_pc,BCM54684_MII_PHY_ECRr,_r._mii_phy_ecr)

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MII_PHY_ECRr BCM54684_MII_PHY_ECRr
#define MII_PHY_ECRr_SIZE BCM54684_MII_PHY_ECRr_SIZE
typedef BCM54684_MII_PHY_ECRr_t MII_PHY_ECRr_t;
#define MII_PHY_ECRr_CLR BCM54684_MII_PHY_ECRr_CLR
#define MII_PHY_ECRr_SET BCM54684_MII_PHY_ECRr_SET
#define MII_PHY_ECRr_GET BCM54684_MII_PHY_ECRr_GET
#define MII_PHY_ECRr_MII_PHY_ECRf_GET BCM54684_MII_PHY_ECRr_MII_PHY_ECRf_GET
#define MII_PHY_ECRr_MII_PHY_ECRf_SET BCM54684_MII_PHY_ECRr_MII_PHY_ECRf_SET
#define READ_MII_PHY_ECRr BCM54684_READ_MII_PHY_ECRr
#define WRITE_MII_PHY_ECRr BCM54684_WRITE_MII_PHY_ECRr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM54684_MII_PHY_ECRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM54684
 * REGISTER:  MII_PHY_ESR
 * BLOCKS:   USER
 * REGADDR:  0x0011
 * DESC:     1000BASE-T/100BASE-TX/10BASE-T PHY Extended Status Register (Addr 11h)
 * SIZE:     32
 * FIELDS:
 *     MII_PHY_ESR      MII_PHY_ESR
 *
 ******************************************************************************/
#define BCM54684_MII_PHY_ESRr (0x00000011 | PHY_REG_ACC_RAW)

#define BCM54684_MII_PHY_ESRr_SIZE 4

/*
 * This structure should be used to declare and program MII_PHY_ESR.
 *
 */
typedef union BCM54684_MII_PHY_ESRr_s {
	uint32_t v[1];
	uint32_t mii_phy_esr[1];
	uint32_t _mii_phy_esr;
} BCM54684_MII_PHY_ESRr_t;

#define BCM54684_MII_PHY_ESRr_CLR(r) (r).mii_phy_esr[0] = 0
#define BCM54684_MII_PHY_ESRr_SET(r,d) (r).mii_phy_esr[0] = d
#define BCM54684_MII_PHY_ESRr_GET(r) (r).mii_phy_esr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM54684_MII_PHY_ESRr_MII_PHY_ESRf_GET(r) (((r).mii_phy_esr[0]) & 0xffff)
#define BCM54684_MII_PHY_ESRr_MII_PHY_ESRf_SET(r,f) (r).mii_phy_esr[0]=(((r).mii_phy_esr[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access MII_PHY_ESR.
 *
 */
#define BCM54684_READ_MII_PHY_ESRr(_pc,_r) PHY_REG_READ(_pc,BCM54684_MII_PHY_ESRr,_r._mii_phy_esr)
#define BCM54684_WRITE_MII_PHY_ESRr(_pc,_r) PHY_REG_WRITE(_pc,BCM54684_MII_PHY_ESRr,_r._mii_phy_esr)

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MII_PHY_ESRr BCM54684_MII_PHY_ESRr
#define MII_PHY_ESRr_SIZE BCM54684_MII_PHY_ESRr_SIZE
typedef BCM54684_MII_PHY_ESRr_t MII_PHY_ESRr_t;
#define MII_PHY_ESRr_CLR BCM54684_MII_PHY_ESRr_CLR
#define MII_PHY_ESRr_SET BCM54684_MII_PHY_ESRr_SET
#define MII_PHY_ESRr_GET BCM54684_MII_PHY_ESRr_GET
#define MII_PHY_ESRr_MII_PHY_ESRf_GET BCM54684_MII_PHY_ESRr_MII_PHY_ESRf_GET
#define MII_PHY_ESRr_MII_PHY_ESRf_SET BCM54684_MII_PHY_ESRr_MII_PHY_ESRf_SET
#define READ_MII_PHY_ESRr BCM54684_READ_MII_PHY_ESRr
#define WRITE_MII_PHY_ESRr BCM54684_WRITE_MII_PHY_ESRr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM54684_MII_PHY_ESRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM54684
 * REGISTER:  MII_AUX_CTRL
 * BLOCKS:   USER
 * REGADDR:  0x0018
 * DESC:     1000BASE-T/100BASE-TX/10BASE-T Auxiliary Control Reg (Addr 18h Shadow 000b)
 * SIZE:     32
 * FIELDS:
 *     MII_AUX_CTRL     MII_AUX_CTRL
 *
 ******************************************************************************/
#define BCM54684_MII_AUX_CTRLr (0x00000018 | PHY_REG_ACC_BRCM_SHADOW)

#define BCM54684_MII_AUX_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program MII_AUX_CTRL.
 *
 */
typedef union BCM54684_MII_AUX_CTRLr_s {
	uint32_t v[1];
	uint32_t mii_aux_ctrl[1];
	uint32_t _mii_aux_ctrl;
} BCM54684_MII_AUX_CTRLr_t;

#define BCM54684_MII_AUX_CTRLr_CLR(r) (r).mii_aux_ctrl[0] = 0
#define BCM54684_MII_AUX_CTRLr_SET(r,d) (r).mii_aux_ctrl[0] = d
#define BCM54684_MII_AUX_CTRLr_GET(r) (r).mii_aux_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM54684_MII_AUX_CTRLr_MII_AUX_CTRLf_GET(r) (((r).mii_aux_ctrl[0]) & 0xffff)
#define BCM54684_MII_AUX_CTRLr_MII_AUX_CTRLf_SET(r,f) (r).mii_aux_ctrl[0]=(((r).mii_aux_ctrl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access MII_AUX_CTRL.
 *
 */
#define BCM54684_READ_MII_AUX_CTRLr(_pc,_r) phy_brcm_shadow_read(_pc,BCM54684_MII_AUX_CTRLr,(_r._mii_aux_ctrl))
#define BCM54684_WRITE_MII_AUX_CTRLr(_pc,_r) phy_brcm_shadow_write(_pc,BCM54684_MII_AUX_CTRLr,(_r._mii_aux_ctrl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MII_AUX_CTRLr BCM54684_MII_AUX_CTRLr
#define MII_AUX_CTRLr_SIZE BCM54684_MII_AUX_CTRLr_SIZE
typedef BCM54684_MII_AUX_CTRLr_t MII_AUX_CTRLr_t;
#define MII_AUX_CTRLr_CLR BCM54684_MII_AUX_CTRLr_CLR
#define MII_AUX_CTRLr_SET BCM54684_MII_AUX_CTRLr_SET
#define MII_AUX_CTRLr_GET BCM54684_MII_AUX_CTRLr_GET
#define MII_AUX_CTRLr_MII_AUX_CTRLf_GET BCM54684_MII_AUX_CTRLr_MII_AUX_CTRLf_GET
#define MII_AUX_CTRLr_MII_AUX_CTRLf_SET BCM54684_MII_AUX_CTRLr_MII_AUX_CTRLf_SET
#define READ_MII_AUX_CTRLr BCM54684_READ_MII_AUX_CTRLr
#define WRITE_MII_AUX_CTRLr BCM54684_WRITE_MII_AUX_CTRLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM54684_MII_AUX_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM54684
 * REGISTER:  MII_10BASE_T
 * BLOCKS:   USER
 * REGADDR:  0x0018
 * DESC:     10BASE-T Register (Addr 18h Shadow 001b)
 * SIZE:     32
 * FIELDS:
 *     MII_10BASE_T     MII_10BASE_T
 *
 ******************************************************************************/
#define BCM54684_MII_10BASE_Tr (0x00000118 | PHY_REG_ACC_BRCM_SHADOW)

#define BCM54684_MII_10BASE_Tr_SIZE 4

/*
 * This structure should be used to declare and program MII_10BASE_T.
 *
 */
typedef union BCM54684_MII_10BASE_Tr_s {
	uint32_t v[1];
	uint32_t mii_10base_t[1];
	uint32_t _mii_10base_t;
} BCM54684_MII_10BASE_Tr_t;

#define BCM54684_MII_10BASE_Tr_CLR(r) (r).mii_10base_t[0] = 0
#define BCM54684_MII_10BASE_Tr_SET(r,d) (r).mii_10base_t[0] = d
#define BCM54684_MII_10BASE_Tr_GET(r) (r).mii_10base_t[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM54684_MII_10BASE_Tr_MII_10BASE_Tf_GET(r) (((r).mii_10base_t[0]) & 0xffff)
#define BCM54684_MII_10BASE_Tr_MII_10BASE_Tf_SET(r,f) (r).mii_10base_t[0]=(((r).mii_10base_t[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access MII_10BASE_T.
 *
 */
#define BCM54684_READ_MII_10BASE_Tr(_pc,_r) phy_brcm_shadow_read(_pc,BCM54684_MII_10BASE_Tr,(_r._mii_10base_t))
#define BCM54684_WRITE_MII_10BASE_Tr(_pc,_r) phy_brcm_shadow_write(_pc,BCM54684_MII_10BASE_Tr,(_r._mii_10base_t))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MII_10BASE_Tr BCM54684_MII_10BASE_Tr
#define MII_10BASE_Tr_SIZE BCM54684_MII_10BASE_Tr_SIZE
typedef BCM54684_MII_10BASE_Tr_t MII_10BASE_Tr_t;
#define MII_10BASE_Tr_CLR BCM54684_MII_10BASE_Tr_CLR
#define MII_10BASE_Tr_SET BCM54684_MII_10BASE_Tr_SET
#define MII_10BASE_Tr_GET BCM54684_MII_10BASE_Tr_GET
#define MII_10BASE_Tr_MII_10BASE_Tf_GET BCM54684_MII_10BASE_Tr_MII_10BASE_Tf_GET
#define MII_10BASE_Tr_MII_10BASE_Tf_SET BCM54684_MII_10BASE_Tr_MII_10BASE_Tf_SET
#define READ_MII_10BASE_Tr BCM54684_READ_MII_10BASE_Tr
#define WRITE_MII_10BASE_Tr BCM54684_WRITE_MII_10BASE_Tr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM54684_MII_10BASE_Tr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM54684
 * REGISTER:  MII_POWER_CTRL
 * BLOCKS:   USER
 * REGADDR:  0x0018
 * DESC:     1000BASE-T/100BASE-TX/10BASE-T Power/MII Control Reg (Addr 18h Shadow 010b)
 * SIZE:     32
 * FIELDS:
 *     MII_POWER_CTRL   MII_POWER_CTRL
 *
 ******************************************************************************/
#define BCM54684_MII_POWER_CTRLr (0x00000218 | PHY_REG_ACC_BRCM_SHADOW)

#define BCM54684_MII_POWER_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program MII_POWER_CTRL.
 *
 */
typedef union BCM54684_MII_POWER_CTRLr_s {
	uint32_t v[1];
	uint32_t mii_power_ctrl[1];
	uint32_t _mii_power_ctrl;
} BCM54684_MII_POWER_CTRLr_t;

#define BCM54684_MII_POWER_CTRLr_CLR(r) (r).mii_power_ctrl[0] = 0
#define BCM54684_MII_POWER_CTRLr_SET(r,d) (r).mii_power_ctrl[0] = d
#define BCM54684_MII_POWER_CTRLr_GET(r) (r).mii_power_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM54684_MII_POWER_CTRLr_MII_POWER_CTRLf_GET(r) (((r).mii_power_ctrl[0]) & 0xffff)
#define BCM54684_MII_POWER_CTRLr_MII_POWER_CTRLf_SET(r,f) (r).mii_power_ctrl[0]=(((r).mii_power_ctrl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access MII_POWER_CTRL.
 *
 */
#define BCM54684_READ_MII_POWER_CTRLr(_pc,_r) phy_brcm_shadow_read(_pc,BCM54684_MII_POWER_CTRLr,(_r._mii_power_ctrl))
#define BCM54684_WRITE_MII_POWER_CTRLr(_pc,_r) phy_brcm_shadow_write(_pc,BCM54684_MII_POWER_CTRLr,(_r._mii_power_ctrl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MII_POWER_CTRLr BCM54684_MII_POWER_CTRLr
#define MII_POWER_CTRLr_SIZE BCM54684_MII_POWER_CTRLr_SIZE
typedef BCM54684_MII_POWER_CTRLr_t MII_POWER_CTRLr_t;
#define MII_POWER_CTRLr_CLR BCM54684_MII_POWER_CTRLr_CLR
#define MII_POWER_CTRLr_SET BCM54684_MII_POWER_CTRLr_SET
#define MII_POWER_CTRLr_GET BCM54684_MII_POWER_CTRLr_GET
#define MII_POWER_CTRLr_MII_POWER_CTRLf_GET BCM54684_MII_POWER_CTRLr_MII_POWER_CTRLf_GET
#define MII_POWER_CTRLr_MII_POWER_CTRLf_SET BCM54684_MII_POWER_CTRLr_MII_POWER_CTRLf_SET
#define READ_MII_POWER_CTRLr BCM54684_READ_MII_POWER_CTRLr
#define WRITE_MII_POWER_CTRLr BCM54684_WRITE_MII_POWER_CTRLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM54684_MII_POWER_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM54684
 * REGISTER:  MII_MISC_TEST
 * BLOCKS:   USER
 * REGADDR:  0x0018
 * DESC:     1000BASE-T/100BASE-TX/10BASE-T Misc Test Register (Addr 18h Shadow 100b)
 * SIZE:     32
 * FIELDS:
 *     MII_MISC_TEST    MII_MISC_TEST
 *
 ******************************************************************************/
#define BCM54684_MII_MISC_TESTr (0x00000418 | PHY_REG_ACC_BRCM_SHADOW)

#define BCM54684_MII_MISC_TESTr_SIZE 4

/*
 * This structure should be used to declare and program MII_MISC_TEST.
 *
 */
typedef union BCM54684_MII_MISC_TESTr_s {
	uint32_t v[1];
	uint32_t mii_misc_test[1];
	uint32_t _mii_misc_test;
} BCM54684_MII_MISC_TESTr_t;

#define BCM54684_MII_MISC_TESTr_CLR(r) (r).mii_misc_test[0] = 0
#define BCM54684_MII_MISC_TESTr_SET(r,d) (r).mii_misc_test[0] = d
#define BCM54684_MII_MISC_TESTr_GET(r) (r).mii_misc_test[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM54684_MII_MISC_TESTr_MII_MISC_TESTf_GET(r) (((r).mii_misc_test[0]) & 0xffff)
#define BCM54684_MII_MISC_TESTr_MII_MISC_TESTf_SET(r,f) (r).mii_misc_test[0]=(((r).mii_misc_test[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access MII_MISC_TEST.
 *
 */
#define BCM54684_READ_MII_MISC_TESTr(_pc,_r) phy_brcm_shadow_read(_pc,BCM54684_MII_MISC_TESTr,(_r._mii_misc_test))
#define BCM54684_WRITE_MII_MISC_TESTr(_pc,_r) phy_brcm_shadow_write(_pc,BCM54684_MII_MISC_TESTr,(_r._mii_misc_test))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MII_MISC_TESTr BCM54684_MII_MISC_TESTr
#define MII_MISC_TESTr_SIZE BCM54684_MII_MISC_TESTr_SIZE
typedef BCM54684_MII_MISC_TESTr_t MII_MISC_TESTr_t;
#define MII_MISC_TESTr_CLR BCM54684_MII_MISC_TESTr_CLR
#define MII_MISC_TESTr_SET BCM54684_MII_MISC_TESTr_SET
#define MII_MISC_TESTr_GET BCM54684_MII_MISC_TESTr_GET
#define MII_MISC_TESTr_MII_MISC_TESTf_GET BCM54684_MII_MISC_TESTr_MII_MISC_TESTf_GET
#define MII_MISC_TESTr_MII_MISC_TESTf_SET BCM54684_MII_MISC_TESTr_MII_MISC_TESTf_SET
#define READ_MII_MISC_TESTr BCM54684_READ_MII_MISC_TESTr
#define WRITE_MII_MISC_TESTr BCM54684_WRITE_MII_MISC_TESTr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM54684_MII_MISC_TESTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM54684
 * REGISTER:  MII_MISC_CTRL
 * BLOCKS:   USER
 * REGADDR:  0x0018
 * DESC:     1000BASE-T/100BASE-TX/10BASE-T Misc Control Register (Addr 18h Shadow 111b)
 * SIZE:     32
 * FIELDS:
 *     MII_MISC_CTRL    MII_MISC_CTRL
 *
 ******************************************************************************/
#define BCM54684_MII_MISC_CTRLr (0x00000718 | PHY_REG_ACC_BRCM_SHADOW)

#define BCM54684_MII_MISC_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program MII_MISC_CTRL.
 *
 */
typedef union BCM54684_MII_MISC_CTRLr_s {
	uint32_t v[1];
	uint32_t mii_misc_ctrl[1];
	uint32_t _mii_misc_ctrl;
} BCM54684_MII_MISC_CTRLr_t;

#define BCM54684_MII_MISC_CTRLr_CLR(r) (r).mii_misc_ctrl[0] = 0
#define BCM54684_MII_MISC_CTRLr_SET(r,d) (r).mii_misc_ctrl[0] = d
#define BCM54684_MII_MISC_CTRLr_GET(r) (r).mii_misc_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM54684_MII_MISC_CTRLr_MII_MISC_CTRLf_GET(r) (((r).mii_misc_ctrl[0]) & 0xffff)
#define BCM54684_MII_MISC_CTRLr_MII_MISC_CTRLf_SET(r,f) (r).mii_misc_ctrl[0]=(((r).mii_misc_ctrl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access MII_MISC_CTRL.
 *
 */
#define BCM54684_READ_MII_MISC_CTRLr(_pc,_r) phy_brcm_shadow_read(_pc,BCM54684_MII_MISC_CTRLr,(_r._mii_misc_ctrl))
#define BCM54684_WRITE_MII_MISC_CTRLr(_pc,_r) phy_brcm_shadow_write(_pc,BCM54684_MII_MISC_CTRLr,(_r._mii_misc_ctrl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MII_MISC_CTRLr BCM54684_MII_MISC_CTRLr
#define MII_MISC_CTRLr_SIZE BCM54684_MII_MISC_CTRLr_SIZE
typedef BCM54684_MII_MISC_CTRLr_t MII_MISC_CTRLr_t;
#define MII_MISC_CTRLr_CLR BCM54684_MII_MISC_CTRLr_CLR
#define MII_MISC_CTRLr_SET BCM54684_MII_MISC_CTRLr_SET
#define MII_MISC_CTRLr_GET BCM54684_MII_MISC_CTRLr_GET
#define MII_MISC_CTRLr_MII_MISC_CTRLf_GET BCM54684_MII_MISC_CTRLr_MII_MISC_CTRLf_GET
#define MII_MISC_CTRLr_MII_MISC_CTRLf_SET BCM54684_MII_MISC_CTRLr_MII_MISC_CTRLf_SET
#define READ_MII_MISC_CTRLr BCM54684_READ_MII_MISC_CTRLr
#define WRITE_MII_MISC_CTRLr BCM54684_WRITE_MII_MISC_CTRLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM54684_MII_MISC_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM54684
 * REGISTER:  SPARE_CTRL
 * BLOCKS:   USER
 * REGADDR:  0x001c
 * DESC:     1000BASE-T/100BASE-TX/10BASE-T Spare Ctrl Reg (Addr 1Ch shadow 00010b)
 * SIZE:     32
 * FIELDS:
 *     SPARE_CTRL       SPARE_CTRL
 *
 ******************************************************************************/
#define BCM54684_SPARE_CTRLr (0x0000021c | PHY_REG_ACC_BRCM_SHADOW)

#define BCM54684_SPARE_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program SPARE_CTRL.
 *
 */
typedef union BCM54684_SPARE_CTRLr_s {
	uint32_t v[1];
	uint32_t spare_ctrl[1];
	uint32_t _spare_ctrl;
} BCM54684_SPARE_CTRLr_t;

#define BCM54684_SPARE_CTRLr_CLR(r) (r).spare_ctrl[0] = 0
#define BCM54684_SPARE_CTRLr_SET(r,d) (r).spare_ctrl[0] = d
#define BCM54684_SPARE_CTRLr_GET(r) (r).spare_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM54684_SPARE_CTRLr_SPARE_CTRLf_GET(r) (((r).spare_ctrl[0]) & 0xffff)
#define BCM54684_SPARE_CTRLr_SPARE_CTRLf_SET(r,f) (r).spare_ctrl[0]=(((r).spare_ctrl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access SPARE_CTRL.
 *
 */
#define BCM54684_READ_SPARE_CTRLr(_pc,_r) phy_brcm_shadow_read(_pc,BCM54684_SPARE_CTRLr,(_r._spare_ctrl))
#define BCM54684_WRITE_SPARE_CTRLr(_pc,_r) phy_brcm_shadow_write(_pc,BCM54684_SPARE_CTRLr,(_r._spare_ctrl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SPARE_CTRLr BCM54684_SPARE_CTRLr
#define SPARE_CTRLr_SIZE BCM54684_SPARE_CTRLr_SIZE
typedef BCM54684_SPARE_CTRLr_t SPARE_CTRLr_t;
#define SPARE_CTRLr_CLR BCM54684_SPARE_CTRLr_CLR
#define SPARE_CTRLr_SET BCM54684_SPARE_CTRLr_SET
#define SPARE_CTRLr_GET BCM54684_SPARE_CTRLr_GET
#define SPARE_CTRLr_SPARE_CTRLf_GET BCM54684_SPARE_CTRLr_SPARE_CTRLf_GET
#define SPARE_CTRLr_SPARE_CTRLf_SET BCM54684_SPARE_CTRLr_SPARE_CTRLf_SET
#define READ_SPARE_CTRLr BCM54684_READ_SPARE_CTRLr
#define WRITE_SPARE_CTRLr BCM54684_WRITE_SPARE_CTRLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM54684_SPARE_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM54684
 * REGISTER:  SPARE_CTRL_2
 * BLOCKS:   USER
 * REGADDR:  0x001c
 * DESC:     1000BASE-T/100BASE-TX/10BASE-T Spare Ctrl 2 Reg (Addr 1Ch shadow 00100b)
 * SIZE:     32
 * FIELDS:
 *     SPARE_CTRL_2     SPARE_CTRL_2
 *
 ******************************************************************************/
#define BCM54684_SPARE_CTRL_2r (0x0000041c | PHY_REG_ACC_BRCM_SHADOW)

#define BCM54684_SPARE_CTRL_2r_SIZE 4

/*
 * This structure should be used to declare and program SPARE_CTRL_2.
 *
 */
typedef union BCM54684_SPARE_CTRL_2r_s {
	uint32_t v[1];
	uint32_t spare_ctrl_2[1];
	uint32_t _spare_ctrl_2;
} BCM54684_SPARE_CTRL_2r_t;

#define BCM54684_SPARE_CTRL_2r_CLR(r) (r).spare_ctrl_2[0] = 0
#define BCM54684_SPARE_CTRL_2r_SET(r,d) (r).spare_ctrl_2[0] = d
#define BCM54684_SPARE_CTRL_2r_GET(r) (r).spare_ctrl_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM54684_SPARE_CTRL_2r_SPARE_CTRL_2f_GET(r) (((r).spare_ctrl_2[0]) & 0xffff)
#define BCM54684_SPARE_CTRL_2r_SPARE_CTRL_2f_SET(r,f) (r).spare_ctrl_2[0]=(((r).spare_ctrl_2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access SPARE_CTRL_2.
 *
 */
#define BCM54684_READ_SPARE_CTRL_2r(_pc,_r) phy_brcm_shadow_read(_pc,BCM54684_SPARE_CTRL_2r,(_r._spare_ctrl_2))
#define BCM54684_WRITE_SPARE_CTRL_2r(_pc,_r) phy_brcm_shadow_write(_pc,BCM54684_SPARE_CTRL_2r,(_r._spare_ctrl_2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SPARE_CTRL_2r BCM54684_SPARE_CTRL_2r
#define SPARE_CTRL_2r_SIZE BCM54684_SPARE_CTRL_2r_SIZE
typedef BCM54684_SPARE_CTRL_2r_t SPARE_CTRL_2r_t;
#define SPARE_CTRL_2r_CLR BCM54684_SPARE_CTRL_2r_CLR
#define SPARE_CTRL_2r_SET BCM54684_SPARE_CTRL_2r_SET
#define SPARE_CTRL_2r_GET BCM54684_SPARE_CTRL_2r_GET
#define SPARE_CTRL_2r_SPARE_CTRL_2f_GET BCM54684_SPARE_CTRL_2r_SPARE_CTRL_2f_GET
#define SPARE_CTRL_2r_SPARE_CTRL_2f_SET BCM54684_SPARE_CTRL_2r_SPARE_CTRL_2f_SET
#define READ_SPARE_CTRL_2r BCM54684_READ_SPARE_CTRL_2r
#define WRITE_SPARE_CTRL_2r BCM54684_WRITE_SPARE_CTRL_2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM54684_SPARE_CTRL_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM54684
 * REGISTER:  SPARE_CTRL_3
 * BLOCKS:   USER
 * REGADDR:  0x001c
 * DESC:     1000BASE-T/100BASE-TX/10BASE-T Spare Ctrl 3 Reg (Addr 1Ch shadow 00101b)
 * SIZE:     32
 * FIELDS:
 *     SPARE_CTRL_3     SPARE_CTRL_3
 *
 ******************************************************************************/
#define BCM54684_SPARE_CTRL_3r (0x0000051c | PHY_REG_ACC_BRCM_SHADOW)

#define BCM54684_SPARE_CTRL_3r_SIZE 4

/*
 * This structure should be used to declare and program SPARE_CTRL_3.
 *
 */
typedef union BCM54684_SPARE_CTRL_3r_s {
	uint32_t v[1];
	uint32_t spare_ctrl_3[1];
	uint32_t _spare_ctrl_3;
} BCM54684_SPARE_CTRL_3r_t;

#define BCM54684_SPARE_CTRL_3r_CLR(r) (r).spare_ctrl_3[0] = 0
#define BCM54684_SPARE_CTRL_3r_SET(r,d) (r).spare_ctrl_3[0] = d
#define BCM54684_SPARE_CTRL_3r_GET(r) (r).spare_ctrl_3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM54684_SPARE_CTRL_3r_SPARE_CTRL_3f_GET(r) (((r).spare_ctrl_3[0]) & 0xffff)
#define BCM54684_SPARE_CTRL_3r_SPARE_CTRL_3f_SET(r,f) (r).spare_ctrl_3[0]=(((r).spare_ctrl_3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access SPARE_CTRL_3.
 *
 */
#define BCM54684_READ_SPARE_CTRL_3r(_pc,_r) phy_brcm_shadow_read(_pc,BCM54684_SPARE_CTRL_3r,(_r._spare_ctrl_3))
#define BCM54684_WRITE_SPARE_CTRL_3r(_pc,_r) phy_brcm_shadow_write(_pc,BCM54684_SPARE_CTRL_3r,(_r._spare_ctrl_3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SPARE_CTRL_3r BCM54684_SPARE_CTRL_3r
#define SPARE_CTRL_3r_SIZE BCM54684_SPARE_CTRL_3r_SIZE
typedef BCM54684_SPARE_CTRL_3r_t SPARE_CTRL_3r_t;
#define SPARE_CTRL_3r_CLR BCM54684_SPARE_CTRL_3r_CLR
#define SPARE_CTRL_3r_SET BCM54684_SPARE_CTRL_3r_SET
#define SPARE_CTRL_3r_GET BCM54684_SPARE_CTRL_3r_GET
#define SPARE_CTRL_3r_SPARE_CTRL_3f_GET BCM54684_SPARE_CTRL_3r_SPARE_CTRL_3f_GET
#define SPARE_CTRL_3r_SPARE_CTRL_3f_SET BCM54684_SPARE_CTRL_3r_SPARE_CTRL_3f_SET
#define READ_SPARE_CTRL_3r BCM54684_READ_SPARE_CTRL_3r
#define WRITE_SPARE_CTRL_3r BCM54684_WRITE_SPARE_CTRL_3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM54684_SPARE_CTRL_3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM54684
 * REGISTER:  LED_STAT
 * BLOCKS:   USER
 * REGADDR:  0x001c
 * DESC:     1000BASE-T/100BASE-TX/10BASE-T LED Status Reg (Addr 1Ch shadow 01000b)
 * SIZE:     32
 * FIELDS:
 *     LED_STAT         LED_STAT
 *
 ******************************************************************************/
#define BCM54684_LED_STATr (0x0000081c | PHY_REG_ACC_BRCM_SHADOW)

#define BCM54684_LED_STATr_SIZE 4

/*
 * This structure should be used to declare and program LED_STAT.
 *
 */
typedef union BCM54684_LED_STATr_s {
	uint32_t v[1];
	uint32_t led_stat[1];
	uint32_t _led_stat;
} BCM54684_LED_STATr_t;

#define BCM54684_LED_STATr_CLR(r) (r).led_stat[0] = 0
#define BCM54684_LED_STATr_SET(r,d) (r).led_stat[0] = d
#define BCM54684_LED_STATr_GET(r) (r).led_stat[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM54684_LED_STATr_LED_STATf_GET(r) (((r).led_stat[0]) & 0xffff)
#define BCM54684_LED_STATr_LED_STATf_SET(r,f) (r).led_stat[0]=(((r).led_stat[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access LED_STAT.
 *
 */
#define BCM54684_READ_LED_STATr(_pc,_r) phy_brcm_shadow_read(_pc,BCM54684_LED_STATr,(_r._led_stat))
#define BCM54684_WRITE_LED_STATr(_pc,_r) phy_brcm_shadow_write(_pc,BCM54684_LED_STATr,(_r._led_stat))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define LED_STATr BCM54684_LED_STATr
#define LED_STATr_SIZE BCM54684_LED_STATr_SIZE
typedef BCM54684_LED_STATr_t LED_STATr_t;
#define LED_STATr_CLR BCM54684_LED_STATr_CLR
#define LED_STATr_SET BCM54684_LED_STATr_SET
#define LED_STATr_GET BCM54684_LED_STATr_GET
#define LED_STATr_LED_STATf_GET BCM54684_LED_STATr_LED_STATf_GET
#define LED_STATr_LED_STATf_SET BCM54684_LED_STATr_LED_STATf_SET
#define READ_LED_STATr BCM54684_READ_LED_STATr
#define WRITE_LED_STATr BCM54684_WRITE_LED_STATr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM54684_LED_STATr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM54684
 * REGISTER:  LED_CTRL
 * BLOCKS:   USER
 * REGADDR:  0x001c
 * DESC:     1000BASE-T/100BASE-TX/10BASE-T LED Ctrl Reg (Addr 1Ch shadow 01001b)
 * SIZE:     32
 * FIELDS:
 *     LED_CTRL         LED_CTRL
 *
 ******************************************************************************/
#define BCM54684_LED_CTRLr (0x0000091c | PHY_REG_ACC_BRCM_SHADOW)

#define BCM54684_LED_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program LED_CTRL.
 *
 */
typedef union BCM54684_LED_CTRLr_s {
	uint32_t v[1];
	uint32_t led_ctrl[1];
	uint32_t _led_ctrl;
} BCM54684_LED_CTRLr_t;

#define BCM54684_LED_CTRLr_CLR(r) (r).led_ctrl[0] = 0
#define BCM54684_LED_CTRLr_SET(r,d) (r).led_ctrl[0] = d
#define BCM54684_LED_CTRLr_GET(r) (r).led_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM54684_LED_CTRLr_LED_CTRLf_GET(r) (((r).led_ctrl[0]) & 0xffff)
#define BCM54684_LED_CTRLr_LED_CTRLf_SET(r,f) (r).led_ctrl[0]=(((r).led_ctrl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access LED_CTRL.
 *
 */
#define BCM54684_READ_LED_CTRLr(_pc,_r) phy_brcm_shadow_read(_pc,BCM54684_LED_CTRLr,(_r._led_ctrl))
#define BCM54684_WRITE_LED_CTRLr(_pc,_r) phy_brcm_shadow_write(_pc,BCM54684_LED_CTRLr,(_r._led_ctrl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define LED_CTRLr BCM54684_LED_CTRLr
#define LED_CTRLr_SIZE BCM54684_LED_CTRLr_SIZE
typedef BCM54684_LED_CTRLr_t LED_CTRLr_t;
#define LED_CTRLr_CLR BCM54684_LED_CTRLr_CLR
#define LED_CTRLr_SET BCM54684_LED_CTRLr_SET
#define LED_CTRLr_GET BCM54684_LED_CTRLr_GET
#define LED_CTRLr_LED_CTRLf_GET BCM54684_LED_CTRLr_LED_CTRLf_GET
#define LED_CTRLr_LED_CTRLf_SET BCM54684_LED_CTRLr_LED_CTRLf_SET
#define READ_LED_CTRLr BCM54684_READ_LED_CTRLr
#define WRITE_LED_CTRLr BCM54684_WRITE_LED_CTRLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM54684_LED_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM54684
 * REGISTER:  AUTO_POWER_DOWN
 * BLOCKS:   USER
 * REGADDR:  0x001c
 * DESC:     Auto Power-Down Reg (Addr 1Ch shadow 01010b)
 * SIZE:     32
 * FIELDS:
 *     AUTO_POWER_DOWN  AUTO_POWER_DOWN
 *
 ******************************************************************************/
#define BCM54684_AUTO_POWER_DOWNr (0x00000a1c | PHY_REG_ACC_BRCM_SHADOW)

#define BCM54684_AUTO_POWER_DOWNr_SIZE 4

/*
 * This structure should be used to declare and program AUTO_POWER_DOWN.
 *
 */
typedef union BCM54684_AUTO_POWER_DOWNr_s {
	uint32_t v[1];
	uint32_t auto_power_down[1];
	uint32_t _auto_power_down;
} BCM54684_AUTO_POWER_DOWNr_t;

#define BCM54684_AUTO_POWER_DOWNr_CLR(r) (r).auto_power_down[0] = 0
#define BCM54684_AUTO_POWER_DOWNr_SET(r,d) (r).auto_power_down[0] = d
#define BCM54684_AUTO_POWER_DOWNr_GET(r) (r).auto_power_down[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM54684_AUTO_POWER_DOWNr_AUTO_POWER_DOWNf_GET(r) (((r).auto_power_down[0]) & 0xffff)
#define BCM54684_AUTO_POWER_DOWNr_AUTO_POWER_DOWNf_SET(r,f) (r).auto_power_down[0]=(((r).auto_power_down[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access AUTO_POWER_DOWN.
 *
 */
#define BCM54684_READ_AUTO_POWER_DOWNr(_pc,_r) phy_brcm_shadow_read(_pc,BCM54684_AUTO_POWER_DOWNr,(_r._auto_power_down))
#define BCM54684_WRITE_AUTO_POWER_DOWNr(_pc,_r) phy_brcm_shadow_write(_pc,BCM54684_AUTO_POWER_DOWNr,(_r._auto_power_down))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AUTO_POWER_DOWNr BCM54684_AUTO_POWER_DOWNr
#define AUTO_POWER_DOWNr_SIZE BCM54684_AUTO_POWER_DOWNr_SIZE
typedef BCM54684_AUTO_POWER_DOWNr_t AUTO_POWER_DOWNr_t;
#define AUTO_POWER_DOWNr_CLR BCM54684_AUTO_POWER_DOWNr_CLR
#define AUTO_POWER_DOWNr_SET BCM54684_AUTO_POWER_DOWNr_SET
#define AUTO_POWER_DOWNr_GET BCM54684_AUTO_POWER_DOWNr_GET
#define AUTO_POWER_DOWNr_AUTO_POWER_DOWNf_GET BCM54684_AUTO_POWER_DOWNr_AUTO_POWER_DOWNf_GET
#define AUTO_POWER_DOWNr_AUTO_POWER_DOWNf_SET BCM54684_AUTO_POWER_DOWNr_AUTO_POWER_DOWNf_SET
#define READ_AUTO_POWER_DOWNr BCM54684_READ_AUTO_POWER_DOWNr
#define WRITE_AUTO_POWER_DOWNr BCM54684_WRITE_AUTO_POWER_DOWNr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM54684_AUTO_POWER_DOWNr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM54684
 * REGISTER:  SLED_1
 * BLOCKS:   USER
 * REGADDR:  0x001c
 * DESC:     SLED 1 (Addr 1Ch shadow 01011b)
 * SIZE:     32
 * FIELDS:
 *     SLED_1           SLED_1
 *
 ******************************************************************************/
#define BCM54684_SLED_1r (0x00000b1c | PHY_REG_ACC_BRCM_SHADOW)

#define BCM54684_SLED_1r_SIZE 4

/*
 * This structure should be used to declare and program SLED_1.
 *
 */
typedef union BCM54684_SLED_1r_s {
	uint32_t v[1];
	uint32_t sled_1[1];
	uint32_t _sled_1;
} BCM54684_SLED_1r_t;

#define BCM54684_SLED_1r_CLR(r) (r).sled_1[0] = 0
#define BCM54684_SLED_1r_SET(r,d) (r).sled_1[0] = d
#define BCM54684_SLED_1r_GET(r) (r).sled_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM54684_SLED_1r_SLED_1f_GET(r) (((r).sled_1[0]) & 0xffff)
#define BCM54684_SLED_1r_SLED_1f_SET(r,f) (r).sled_1[0]=(((r).sled_1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access SLED_1.
 *
 */
#define BCM54684_READ_SLED_1r(_pc,_r) phy_brcm_shadow_read(_pc,BCM54684_SLED_1r,(_r._sled_1))
#define BCM54684_WRITE_SLED_1r(_pc,_r) phy_brcm_shadow_write(_pc,BCM54684_SLED_1r,(_r._sled_1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SLED_1r BCM54684_SLED_1r
#define SLED_1r_SIZE BCM54684_SLED_1r_SIZE
typedef BCM54684_SLED_1r_t SLED_1r_t;
#define SLED_1r_CLR BCM54684_SLED_1r_CLR
#define SLED_1r_SET BCM54684_SLED_1r_SET
#define SLED_1r_GET BCM54684_SLED_1r_GET
#define SLED_1r_SLED_1f_GET BCM54684_SLED_1r_SLED_1f_GET
#define SLED_1r_SLED_1f_SET BCM54684_SLED_1r_SLED_1f_SET
#define READ_SLED_1r BCM54684_READ_SLED_1r
#define WRITE_SLED_1r BCM54684_WRITE_SLED_1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM54684_SLED_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM54684
 * REGISTER:  SLED_2
 * BLOCKS:   USER
 * REGADDR:  0x001c
 * DESC:     SLED 2 (Addr 1Ch shadow 01100b)
 * SIZE:     32
 * FIELDS:
 *     SLED_2           SLED_2
 *
 ******************************************************************************/
#define BCM54684_SLED_2r (0x00000c1c | PHY_REG_ACC_BRCM_SHADOW)

#define BCM54684_SLED_2r_SIZE 4

/*
 * This structure should be used to declare and program SLED_2.
 *
 */
typedef union BCM54684_SLED_2r_s {
	uint32_t v[1];
	uint32_t sled_2[1];
	uint32_t _sled_2;
} BCM54684_SLED_2r_t;

#define BCM54684_SLED_2r_CLR(r) (r).sled_2[0] = 0
#define BCM54684_SLED_2r_SET(r,d) (r).sled_2[0] = d
#define BCM54684_SLED_2r_GET(r) (r).sled_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM54684_SLED_2r_SLED_2f_GET(r) (((r).sled_2[0]) & 0xffff)
#define BCM54684_SLED_2r_SLED_2f_SET(r,f) (r).sled_2[0]=(((r).sled_2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access SLED_2.
 *
 */
#define BCM54684_READ_SLED_2r(_pc,_r) phy_brcm_shadow_read(_pc,BCM54684_SLED_2r,(_r._sled_2))
#define BCM54684_WRITE_SLED_2r(_pc,_r) phy_brcm_shadow_write(_pc,BCM54684_SLED_2r,(_r._sled_2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SLED_2r BCM54684_SLED_2r
#define SLED_2r_SIZE BCM54684_SLED_2r_SIZE
typedef BCM54684_SLED_2r_t SLED_2r_t;
#define SLED_2r_CLR BCM54684_SLED_2r_CLR
#define SLED_2r_SET BCM54684_SLED_2r_SET
#define SLED_2r_GET BCM54684_SLED_2r_GET
#define SLED_2r_SLED_2f_GET BCM54684_SLED_2r_SLED_2f_GET
#define SLED_2r_SLED_2f_SET BCM54684_SLED_2r_SLED_2f_SET
#define READ_SLED_2r BCM54684_READ_SLED_2r
#define WRITE_SLED_2r BCM54684_WRITE_SLED_2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM54684_SLED_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM54684
 * REGISTER:  LED_SELECTOR_1
 * BLOCKS:   USER
 * REGADDR:  0x001c
 * DESC:     1000BASE-T/100BASE-TX/10BASE-T LED Selector 1 Reg (Addr 1Ch shadow 01101b)
 * SIZE:     32
 * FIELDS:
 *     LED_SELECTOR_1   LED_SELECTOR_1
 *
 ******************************************************************************/
#define BCM54684_LED_SELECTOR_1r (0x00000d1c | PHY_REG_ACC_BRCM_SHADOW)

#define BCM54684_LED_SELECTOR_1r_SIZE 4

/*
 * This structure should be used to declare and program LED_SELECTOR_1.
 *
 */
typedef union BCM54684_LED_SELECTOR_1r_s {
	uint32_t v[1];
	uint32_t led_selector_1[1];
	uint32_t _led_selector_1;
} BCM54684_LED_SELECTOR_1r_t;

#define BCM54684_LED_SELECTOR_1r_CLR(r) (r).led_selector_1[0] = 0
#define BCM54684_LED_SELECTOR_1r_SET(r,d) (r).led_selector_1[0] = d
#define BCM54684_LED_SELECTOR_1r_GET(r) (r).led_selector_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM54684_LED_SELECTOR_1r_LED_SELECTOR_1f_GET(r) (((r).led_selector_1[0]) & 0xffff)
#define BCM54684_LED_SELECTOR_1r_LED_SELECTOR_1f_SET(r,f) (r).led_selector_1[0]=(((r).led_selector_1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access LED_SELECTOR_1.
 *
 */
#define BCM54684_READ_LED_SELECTOR_1r(_pc,_r) phy_brcm_shadow_read(_pc,BCM54684_LED_SELECTOR_1r,(_r._led_selector_1))
#define BCM54684_WRITE_LED_SELECTOR_1r(_pc,_r) phy_brcm_shadow_write(_pc,BCM54684_LED_SELECTOR_1r,(_r._led_selector_1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define LED_SELECTOR_1r BCM54684_LED_SELECTOR_1r
#define LED_SELECTOR_1r_SIZE BCM54684_LED_SELECTOR_1r_SIZE
typedef BCM54684_LED_SELECTOR_1r_t LED_SELECTOR_1r_t;
#define LED_SELECTOR_1r_CLR BCM54684_LED_SELECTOR_1r_CLR
#define LED_SELECTOR_1r_SET BCM54684_LED_SELECTOR_1r_SET
#define LED_SELECTOR_1r_GET BCM54684_LED_SELECTOR_1r_GET
#define LED_SELECTOR_1r_LED_SELECTOR_1f_GET BCM54684_LED_SELECTOR_1r_LED_SELECTOR_1f_GET
#define LED_SELECTOR_1r_LED_SELECTOR_1f_SET BCM54684_LED_SELECTOR_1r_LED_SELECTOR_1f_SET
#define READ_LED_SELECTOR_1r BCM54684_READ_LED_SELECTOR_1r
#define WRITE_LED_SELECTOR_1r BCM54684_WRITE_LED_SELECTOR_1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM54684_LED_SELECTOR_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM54684
 * REGISTER:  LED_SELECTOR_2
 * BLOCKS:   USER
 * REGADDR:  0x001c
 * DESC:     1000BASE-T/100BASE-TX/10BASE-T LED Selector 2 Reg (Addr 1Ch shadow 01110b)
 * SIZE:     32
 * FIELDS:
 *     LED_SELECTOR_2   LED_SELECTOR_2
 *
 ******************************************************************************/
#define BCM54684_LED_SELECTOR_2r (0x00000e1c | PHY_REG_ACC_BRCM_SHADOW)

#define BCM54684_LED_SELECTOR_2r_SIZE 4

/*
 * This structure should be used to declare and program LED_SELECTOR_2.
 *
 */
typedef union BCM54684_LED_SELECTOR_2r_s {
	uint32_t v[1];
	uint32_t led_selector_2[1];
	uint32_t _led_selector_2;
} BCM54684_LED_SELECTOR_2r_t;

#define BCM54684_LED_SELECTOR_2r_CLR(r) (r).led_selector_2[0] = 0
#define BCM54684_LED_SELECTOR_2r_SET(r,d) (r).led_selector_2[0] = d
#define BCM54684_LED_SELECTOR_2r_GET(r) (r).led_selector_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM54684_LED_SELECTOR_2r_LED_SELECTOR_2f_GET(r) (((r).led_selector_2[0]) & 0xffff)
#define BCM54684_LED_SELECTOR_2r_LED_SELECTOR_2f_SET(r,f) (r).led_selector_2[0]=(((r).led_selector_2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access LED_SELECTOR_2.
 *
 */
#define BCM54684_READ_LED_SELECTOR_2r(_pc,_r) phy_brcm_shadow_read(_pc,BCM54684_LED_SELECTOR_2r,(_r._led_selector_2))
#define BCM54684_WRITE_LED_SELECTOR_2r(_pc,_r) phy_brcm_shadow_write(_pc,BCM54684_LED_SELECTOR_2r,(_r._led_selector_2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define LED_SELECTOR_2r BCM54684_LED_SELECTOR_2r
#define LED_SELECTOR_2r_SIZE BCM54684_LED_SELECTOR_2r_SIZE
typedef BCM54684_LED_SELECTOR_2r_t LED_SELECTOR_2r_t;
#define LED_SELECTOR_2r_CLR BCM54684_LED_SELECTOR_2r_CLR
#define LED_SELECTOR_2r_SET BCM54684_LED_SELECTOR_2r_SET
#define LED_SELECTOR_2r_GET BCM54684_LED_SELECTOR_2r_GET
#define LED_SELECTOR_2r_LED_SELECTOR_2f_GET BCM54684_LED_SELECTOR_2r_LED_SELECTOR_2f_GET
#define LED_SELECTOR_2r_LED_SELECTOR_2f_SET BCM54684_LED_SELECTOR_2r_LED_SELECTOR_2f_SET
#define READ_LED_SELECTOR_2r BCM54684_READ_LED_SELECTOR_2r
#define WRITE_LED_SELECTOR_2r BCM54684_WRITE_LED_SELECTOR_2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM54684_LED_SELECTOR_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM54684
 * REGISTER:  LED_GPIO_CTRL
 * BLOCKS:   USER
 * REGADDR:  0x001c
 * DESC:     1000BASE-T/100BASE-TX/10BASE-T LED GPIO Ctrl/Stat (Addr 1Ch shadow 01111b)
 * SIZE:     32
 * FIELDS:
 *     LED_GPIO_CTRL    LED_GPIO_CTRL
 *
 ******************************************************************************/
#define BCM54684_LED_GPIO_CTRLr (0x00000f1c | PHY_REG_ACC_BRCM_SHADOW)

#define BCM54684_LED_GPIO_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program LED_GPIO_CTRL.
 *
 */
typedef union BCM54684_LED_GPIO_CTRLr_s {
	uint32_t v[1];
	uint32_t led_gpio_ctrl[1];
	uint32_t _led_gpio_ctrl;
} BCM54684_LED_GPIO_CTRLr_t;

#define BCM54684_LED_GPIO_CTRLr_CLR(r) (r).led_gpio_ctrl[0] = 0
#define BCM54684_LED_GPIO_CTRLr_SET(r,d) (r).led_gpio_ctrl[0] = d
#define BCM54684_LED_GPIO_CTRLr_GET(r) (r).led_gpio_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM54684_LED_GPIO_CTRLr_LED_GPIO_CTRLf_GET(r) (((r).led_gpio_ctrl[0]) & 0xffff)
#define BCM54684_LED_GPIO_CTRLr_LED_GPIO_CTRLf_SET(r,f) (r).led_gpio_ctrl[0]=(((r).led_gpio_ctrl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access LED_GPIO_CTRL.
 *
 */
#define BCM54684_READ_LED_GPIO_CTRLr(_pc,_r) phy_brcm_shadow_read(_pc,BCM54684_LED_GPIO_CTRLr,(_r._led_gpio_ctrl))
#define BCM54684_WRITE_LED_GPIO_CTRLr(_pc,_r) phy_brcm_shadow_write(_pc,BCM54684_LED_GPIO_CTRLr,(_r._led_gpio_ctrl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define LED_GPIO_CTRLr BCM54684_LED_GPIO_CTRLr
#define LED_GPIO_CTRLr_SIZE BCM54684_LED_GPIO_CTRLr_SIZE
typedef BCM54684_LED_GPIO_CTRLr_t LED_GPIO_CTRLr_t;
#define LED_GPIO_CTRLr_CLR BCM54684_LED_GPIO_CTRLr_CLR
#define LED_GPIO_CTRLr_SET BCM54684_LED_GPIO_CTRLr_SET
#define LED_GPIO_CTRLr_GET BCM54684_LED_GPIO_CTRLr_GET
#define LED_GPIO_CTRLr_LED_GPIO_CTRLf_GET BCM54684_LED_GPIO_CTRLr_LED_GPIO_CTRLf_GET
#define LED_GPIO_CTRLr_LED_GPIO_CTRLf_SET BCM54684_LED_GPIO_CTRLr_LED_GPIO_CTRLf_SET
#define READ_LED_GPIO_CTRLr BCM54684_READ_LED_GPIO_CTRLr
#define WRITE_LED_GPIO_CTRLr BCM54684_WRITE_LED_GPIO_CTRLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM54684_LED_GPIO_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM54684
 * REGISTER:  FAST_LINK_DROP_DETECT
 * BLOCKS:   USER
 * REGADDR:  0x001c
 * DESC:     1000BASE-T Fast Link Drop Detection Reg (Addr 1Ch shadow 10000b)
 * SIZE:     32
 * FIELDS:
 *     FAST_LINK_DROP_DETECT FAST_LINK_DROP_DETECT
 *
 ******************************************************************************/
#define BCM54684_FAST_LINK_DROP_DETECTr (0x0000101c | PHY_REG_ACC_BRCM_SHADOW)

#define BCM54684_FAST_LINK_DROP_DETECTr_SIZE 4

/*
 * This structure should be used to declare and program FAST_LINK_DROP_DETECT.
 *
 */
typedef union BCM54684_FAST_LINK_DROP_DETECTr_s {
	uint32_t v[1];
	uint32_t fast_link_drop_detect[1];
	uint32_t _fast_link_drop_detect;
} BCM54684_FAST_LINK_DROP_DETECTr_t;

#define BCM54684_FAST_LINK_DROP_DETECTr_CLR(r) (r).fast_link_drop_detect[0] = 0
#define BCM54684_FAST_LINK_DROP_DETECTr_SET(r,d) (r).fast_link_drop_detect[0] = d
#define BCM54684_FAST_LINK_DROP_DETECTr_GET(r) (r).fast_link_drop_detect[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM54684_FAST_LINK_DROP_DETECTr_FAST_LINK_DROP_DETECTf_GET(r) (((r).fast_link_drop_detect[0]) & 0xffff)
#define BCM54684_FAST_LINK_DROP_DETECTr_FAST_LINK_DROP_DETECTf_SET(r,f) (r).fast_link_drop_detect[0]=(((r).fast_link_drop_detect[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access FAST_LINK_DROP_DETECT.
 *
 */
#define BCM54684_READ_FAST_LINK_DROP_DETECTr(_pc,_r) phy_brcm_shadow_read(_pc,BCM54684_FAST_LINK_DROP_DETECTr,(_r._fast_link_drop_detect))
#define BCM54684_WRITE_FAST_LINK_DROP_DETECTr(_pc,_r) phy_brcm_shadow_write(_pc,BCM54684_FAST_LINK_DROP_DETECTr,(_r._fast_link_drop_detect))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define FAST_LINK_DROP_DETECTr BCM54684_FAST_LINK_DROP_DETECTr
#define FAST_LINK_DROP_DETECTr_SIZE BCM54684_FAST_LINK_DROP_DETECTr_SIZE
typedef BCM54684_FAST_LINK_DROP_DETECTr_t FAST_LINK_DROP_DETECTr_t;
#define FAST_LINK_DROP_DETECTr_CLR BCM54684_FAST_LINK_DROP_DETECTr_CLR
#define FAST_LINK_DROP_DETECTr_SET BCM54684_FAST_LINK_DROP_DETECTr_SET
#define FAST_LINK_DROP_DETECTr_GET BCM54684_FAST_LINK_DROP_DETECTr_GET
#define FAST_LINK_DROP_DETECTr_FAST_LINK_DROP_DETECTf_GET BCM54684_FAST_LINK_DROP_DETECTr_FAST_LINK_DROP_DETECTf_GET
#define FAST_LINK_DROP_DETECTr_FAST_LINK_DROP_DETECTf_SET BCM54684_FAST_LINK_DROP_DETECTr_FAST_LINK_DROP_DETECTf_SET
#define READ_FAST_LINK_DROP_DETECTr BCM54684_READ_FAST_LINK_DROP_DETECTr
#define WRITE_FAST_LINK_DROP_DETECTr BCM54684_WRITE_FAST_LINK_DROP_DETECTr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM54684_FAST_LINK_DROP_DETECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM54684
 * REGISTER:  REG_100FX_STAT
 * BLOCKS:   USER
 * REGADDR:  0x001c
 * DESC:     SerDes 100BASE-FX Status Reg (ADDR 1ch shadow 10001)
 * SIZE:     32
 * FIELDS:
 *     REG_100FX_STAT   REG_100FX_STAT
 *
 ******************************************************************************/
#define BCM54684_REG_100FX_STATr (0x0000111c | PHY_REG_ACC_BRCM_SHADOW)

#define BCM54684_REG_100FX_STATr_SIZE 4

/*
 * This structure should be used to declare and program REG_100FX_STAT.
 *
 */
typedef union BCM54684_REG_100FX_STATr_s {
	uint32_t v[1];
	uint32_t reg_100fx_stat[1];
	uint32_t _reg_100fx_stat;
} BCM54684_REG_100FX_STATr_t;

#define BCM54684_REG_100FX_STATr_CLR(r) (r).reg_100fx_stat[0] = 0
#define BCM54684_REG_100FX_STATr_SET(r,d) (r).reg_100fx_stat[0] = d
#define BCM54684_REG_100FX_STATr_GET(r) (r).reg_100fx_stat[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM54684_REG_100FX_STATr_REG_100FX_STATf_GET(r) (((r).reg_100fx_stat[0]) & 0xffff)
#define BCM54684_REG_100FX_STATr_REG_100FX_STATf_SET(r,f) (r).reg_100fx_stat[0]=(((r).reg_100fx_stat[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access REG_100FX_STAT.
 *
 */
#define BCM54684_READ_REG_100FX_STATr(_pc,_r) phy_brcm_shadow_read(_pc,BCM54684_REG_100FX_STATr,(_r._reg_100fx_stat))
#define BCM54684_WRITE_REG_100FX_STATr(_pc,_r) phy_brcm_shadow_write(_pc,BCM54684_REG_100FX_STATr,(_r._reg_100fx_stat))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define REG_100FX_STATr BCM54684_REG_100FX_STATr
#define REG_100FX_STATr_SIZE BCM54684_REG_100FX_STATr_SIZE
typedef BCM54684_REG_100FX_STATr_t REG_100FX_STATr_t;
#define REG_100FX_STATr_CLR BCM54684_REG_100FX_STATr_CLR
#define REG_100FX_STATr_SET BCM54684_REG_100FX_STATr_SET
#define REG_100FX_STATr_GET BCM54684_REG_100FX_STATr_GET
#define REG_100FX_STATr_REG_100FX_STATf_GET BCM54684_REG_100FX_STATr_REG_100FX_STATf_GET
#define REG_100FX_STATr_REG_100FX_STATf_SET BCM54684_REG_100FX_STATr_REG_100FX_STATf_SET
#define READ_REG_100FX_STATr BCM54684_READ_REG_100FX_STATr
#define WRITE_REG_100FX_STATr BCM54684_WRITE_REG_100FX_STATr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM54684_REG_100FX_STATr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM54684
 * REGISTER:  REG_100FX_CTRL
 * BLOCKS:   USER
 * REGADDR:  0x001c
 * DESC:     SerDes 100BASE-FX Control Reg (ADDR 1ch shadow 10011)
 * SIZE:     32
 * FIELDS:
 *     REG_100FX_CTRL   REG_100FX_CTRL
 *
 ******************************************************************************/
#define BCM54684_REG_100FX_CTRLr (0x0000131c | PHY_REG_ACC_BRCM_SHADOW)

#define BCM54684_REG_100FX_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program REG_100FX_CTRL.
 *
 */
typedef union BCM54684_REG_100FX_CTRLr_s {
	uint32_t v[1];
	uint32_t reg_100fx_ctrl[1];
	uint32_t _reg_100fx_ctrl;
} BCM54684_REG_100FX_CTRLr_t;

#define BCM54684_REG_100FX_CTRLr_CLR(r) (r).reg_100fx_ctrl[0] = 0
#define BCM54684_REG_100FX_CTRLr_SET(r,d) (r).reg_100fx_ctrl[0] = d
#define BCM54684_REG_100FX_CTRLr_GET(r) (r).reg_100fx_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM54684_REG_100FX_CTRLr_REG_100FX_CTRLf_GET(r) (((r).reg_100fx_ctrl[0]) & 0xffff)
#define BCM54684_REG_100FX_CTRLr_REG_100FX_CTRLf_SET(r,f) (r).reg_100fx_ctrl[0]=(((r).reg_100fx_ctrl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access REG_100FX_CTRL.
 *
 */
#define BCM54684_READ_REG_100FX_CTRLr(_pc,_r) phy_brcm_shadow_read(_pc,BCM54684_REG_100FX_CTRLr,(_r._reg_100fx_ctrl))
#define BCM54684_WRITE_REG_100FX_CTRLr(_pc,_r) phy_brcm_shadow_write(_pc,BCM54684_REG_100FX_CTRLr,(_r._reg_100fx_ctrl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define REG_100FX_CTRLr BCM54684_REG_100FX_CTRLr
#define REG_100FX_CTRLr_SIZE BCM54684_REG_100FX_CTRLr_SIZE
typedef BCM54684_REG_100FX_CTRLr_t REG_100FX_CTRLr_t;
#define REG_100FX_CTRLr_CLR BCM54684_REG_100FX_CTRLr_CLR
#define REG_100FX_CTRLr_SET BCM54684_REG_100FX_CTRLr_SET
#define REG_100FX_CTRLr_GET BCM54684_REG_100FX_CTRLr_GET
#define REG_100FX_CTRLr_REG_100FX_CTRLf_GET BCM54684_REG_100FX_CTRLr_REG_100FX_CTRLf_GET
#define REG_100FX_CTRLr_REG_100FX_CTRLf_SET BCM54684_REG_100FX_CTRLr_REG_100FX_CTRLf_SET
#define READ_REG_100FX_CTRLr BCM54684_READ_REG_100FX_CTRLr
#define WRITE_REG_100FX_CTRLr BCM54684_WRITE_REG_100FX_CTRLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM54684_REG_100FX_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM54684
 * REGISTER:  SGMII_SLAVE
 * BLOCKS:   USER
 * REGADDR:  0x001c
 * DESC:     SGMII Slave Reg (ADDR 1ch shadow 10101)
 * SIZE:     32
 * FIELDS:
 *     SGMII_SLAVE      SGMII_SLAVE
 *
 ******************************************************************************/
#define BCM54684_SGMII_SLAVEr (0x0000151c | PHY_REG_ACC_BRCM_SHADOW)

#define BCM54684_SGMII_SLAVEr_SIZE 4

/*
 * This structure should be used to declare and program SGMII_SLAVE.
 *
 */
typedef union BCM54684_SGMII_SLAVEr_s {
	uint32_t v[1];
	uint32_t sgmii_slave[1];
	uint32_t _sgmii_slave;
} BCM54684_SGMII_SLAVEr_t;

#define BCM54684_SGMII_SLAVEr_CLR(r) (r).sgmii_slave[0] = 0
#define BCM54684_SGMII_SLAVEr_SET(r,d) (r).sgmii_slave[0] = d
#define BCM54684_SGMII_SLAVEr_GET(r) (r).sgmii_slave[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM54684_SGMII_SLAVEr_SGMII_SLAVEf_GET(r) (((r).sgmii_slave[0]) & 0xffff)
#define BCM54684_SGMII_SLAVEr_SGMII_SLAVEf_SET(r,f) (r).sgmii_slave[0]=(((r).sgmii_slave[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access SGMII_SLAVE.
 *
 */
#define BCM54684_READ_SGMII_SLAVEr(_pc,_r) phy_brcm_shadow_read(_pc,BCM54684_SGMII_SLAVEr,(_r._sgmii_slave))
#define BCM54684_WRITE_SGMII_SLAVEr(_pc,_r) phy_brcm_shadow_write(_pc,BCM54684_SGMII_SLAVEr,(_r._sgmii_slave))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SGMII_SLAVEr BCM54684_SGMII_SLAVEr
#define SGMII_SLAVEr_SIZE BCM54684_SGMII_SLAVEr_SIZE
typedef BCM54684_SGMII_SLAVEr_t SGMII_SLAVEr_t;
#define SGMII_SLAVEr_CLR BCM54684_SGMII_SLAVEr_CLR
#define SGMII_SLAVEr_SET BCM54684_SGMII_SLAVEr_SET
#define SGMII_SLAVEr_GET BCM54684_SGMII_SLAVEr_GET
#define SGMII_SLAVEr_SGMII_SLAVEf_GET BCM54684_SGMII_SLAVEr_SGMII_SLAVEf_GET
#define SGMII_SLAVEr_SGMII_SLAVEf_SET BCM54684_SGMII_SLAVEr_SGMII_SLAVEf_SET
#define READ_SGMII_SLAVEr BCM54684_READ_SGMII_SLAVEr
#define WRITE_SGMII_SLAVEr BCM54684_WRITE_SGMII_SLAVEr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM54684_SGMII_SLAVEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM54684
 * REGISTER:  MISC_1000X_CTRL_2
 * BLOCKS:   USER
 * REGADDR:  0x001c
 * DESC:     1000BASE-X Misc 1000BASE-X Control Reg (Addr 1Ch shadow 10110b)
 * SIZE:     32
 * FIELDS:
 *     MISC_1000X_CTRL_2 MISC_1000X_CTRL_2
 *
 ******************************************************************************/
#define BCM54684_MISC_1000X_CTRL_2r (0x0000161c | PHY_REG_ACC_BRCM_SHADOW)

#define BCM54684_MISC_1000X_CTRL_2r_SIZE 4

/*
 * This structure should be used to declare and program MISC_1000X_CTRL_2.
 *
 */
typedef union BCM54684_MISC_1000X_CTRL_2r_s {
	uint32_t v[1];
	uint32_t misc_1000x_ctrl_2[1];
	uint32_t _misc_1000x_ctrl_2;
} BCM54684_MISC_1000X_CTRL_2r_t;

#define BCM54684_MISC_1000X_CTRL_2r_CLR(r) (r).misc_1000x_ctrl_2[0] = 0
#define BCM54684_MISC_1000X_CTRL_2r_SET(r,d) (r).misc_1000x_ctrl_2[0] = d
#define BCM54684_MISC_1000X_CTRL_2r_GET(r) (r).misc_1000x_ctrl_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM54684_MISC_1000X_CTRL_2r_MISC_1000X_CTRL_2f_GET(r) (((r).misc_1000x_ctrl_2[0]) & 0xffff)
#define BCM54684_MISC_1000X_CTRL_2r_MISC_1000X_CTRL_2f_SET(r,f) (r).misc_1000x_ctrl_2[0]=(((r).misc_1000x_ctrl_2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access MISC_1000X_CTRL_2.
 *
 */
#define BCM54684_READ_MISC_1000X_CTRL_2r(_pc,_r) phy_brcm_shadow_read(_pc,BCM54684_MISC_1000X_CTRL_2r,(_r._misc_1000x_ctrl_2))
#define BCM54684_WRITE_MISC_1000X_CTRL_2r(_pc,_r) phy_brcm_shadow_write(_pc,BCM54684_MISC_1000X_CTRL_2r,(_r._misc_1000x_ctrl_2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MISC_1000X_CTRL_2r BCM54684_MISC_1000X_CTRL_2r
#define MISC_1000X_CTRL_2r_SIZE BCM54684_MISC_1000X_CTRL_2r_SIZE
typedef BCM54684_MISC_1000X_CTRL_2r_t MISC_1000X_CTRL_2r_t;
#define MISC_1000X_CTRL_2r_CLR BCM54684_MISC_1000X_CTRL_2r_CLR
#define MISC_1000X_CTRL_2r_SET BCM54684_MISC_1000X_CTRL_2r_SET
#define MISC_1000X_CTRL_2r_GET BCM54684_MISC_1000X_CTRL_2r_GET
#define MISC_1000X_CTRL_2r_MISC_1000X_CTRL_2f_GET BCM54684_MISC_1000X_CTRL_2r_MISC_1000X_CTRL_2f_GET
#define MISC_1000X_CTRL_2r_MISC_1000X_CTRL_2f_SET BCM54684_MISC_1000X_CTRL_2r_MISC_1000X_CTRL_2f_SET
#define READ_MISC_1000X_CTRL_2r BCM54684_READ_MISC_1000X_CTRL_2r
#define WRITE_MISC_1000X_CTRL_2r BCM54684_WRITE_MISC_1000X_CTRL_2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM54684_MISC_1000X_CTRL_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM54684
 * REGISTER:  AUTO_DETECT_SGMII_MEDIA
 * BLOCKS:   USER
 * REGADDR:  0x001c
 * DESC:     1000BASE-X Auto-Detect SGMII/Media Converter Reg (Addr 1Ch shadow 11000b)
 * SIZE:     32
 * FIELDS:
 *     AUTO_DETECT_SGMII_MEDIA AUTO_DETECT_SGMII_MEDIA
 *
 ******************************************************************************/
#define BCM54684_AUTO_DETECT_SGMII_MEDIAr (0x0000181c | PHY_REG_ACC_BRCM_SHADOW)

#define BCM54684_AUTO_DETECT_SGMII_MEDIAr_SIZE 4

/*
 * This structure should be used to declare and program AUTO_DETECT_SGMII_MEDIA.
 *
 */
typedef union BCM54684_AUTO_DETECT_SGMII_MEDIAr_s {
	uint32_t v[1];
	uint32_t auto_detect_sgmii_media[1];
	uint32_t _auto_detect_sgmii_media;
} BCM54684_AUTO_DETECT_SGMII_MEDIAr_t;

#define BCM54684_AUTO_DETECT_SGMII_MEDIAr_CLR(r) (r).auto_detect_sgmii_media[0] = 0
#define BCM54684_AUTO_DETECT_SGMII_MEDIAr_SET(r,d) (r).auto_detect_sgmii_media[0] = d
#define BCM54684_AUTO_DETECT_SGMII_MEDIAr_GET(r) (r).auto_detect_sgmii_media[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM54684_AUTO_DETECT_SGMII_MEDIAr_AUTO_DETECT_SGMII_MEDIAf_GET(r) (((r).auto_detect_sgmii_media[0]) & 0xffff)
#define BCM54684_AUTO_DETECT_SGMII_MEDIAr_AUTO_DETECT_SGMII_MEDIAf_SET(r,f) (r).auto_detect_sgmii_media[0]=(((r).auto_detect_sgmii_media[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access AUTO_DETECT_SGMII_MEDIA.
 *
 */
#define BCM54684_READ_AUTO_DETECT_SGMII_MEDIAr(_pc,_r) phy_brcm_shadow_read(_pc,BCM54684_AUTO_DETECT_SGMII_MEDIAr,(_r._auto_detect_sgmii_media))
#define BCM54684_WRITE_AUTO_DETECT_SGMII_MEDIAr(_pc,_r) phy_brcm_shadow_write(_pc,BCM54684_AUTO_DETECT_SGMII_MEDIAr,(_r._auto_detect_sgmii_media))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AUTO_DETECT_SGMII_MEDIAr BCM54684_AUTO_DETECT_SGMII_MEDIAr
#define AUTO_DETECT_SGMII_MEDIAr_SIZE BCM54684_AUTO_DETECT_SGMII_MEDIAr_SIZE
typedef BCM54684_AUTO_DETECT_SGMII_MEDIAr_t AUTO_DETECT_SGMII_MEDIAr_t;
#define AUTO_DETECT_SGMII_MEDIAr_CLR BCM54684_AUTO_DETECT_SGMII_MEDIAr_CLR
#define AUTO_DETECT_SGMII_MEDIAr_SET BCM54684_AUTO_DETECT_SGMII_MEDIAr_SET
#define AUTO_DETECT_SGMII_MEDIAr_GET BCM54684_AUTO_DETECT_SGMII_MEDIAr_GET
#define AUTO_DETECT_SGMII_MEDIAr_AUTO_DETECT_SGMII_MEDIAf_GET BCM54684_AUTO_DETECT_SGMII_MEDIAr_AUTO_DETECT_SGMII_MEDIAf_GET
#define AUTO_DETECT_SGMII_MEDIAr_AUTO_DETECT_SGMII_MEDIAf_SET BCM54684_AUTO_DETECT_SGMII_MEDIAr_AUTO_DETECT_SGMII_MEDIAf_SET
#define READ_AUTO_DETECT_SGMII_MEDIAr BCM54684_READ_AUTO_DETECT_SGMII_MEDIAr
#define WRITE_AUTO_DETECT_SGMII_MEDIAr BCM54684_WRITE_AUTO_DETECT_SGMII_MEDIAr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM54684_AUTO_DETECT_SGMII_MEDIAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM54684
 * REGISTER:  AUX_1000X_CTRL
 * BLOCKS:   USER
 * REGADDR:  0x001c
 * DESC:     Auxiliary 1000BASE-X Control Reg (Addr 1Ch shadow 11011b)
 * SIZE:     32
 * FIELDS:
 *     AUX_1000X_CTRL   AUX_1000X_CTRL
 *
 ******************************************************************************/
#define BCM54684_AUX_1000X_CTRLr (0x00001b1c | PHY_REG_ACC_BRCM_SHADOW)

#define BCM54684_AUX_1000X_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program AUX_1000X_CTRL.
 *
 */
typedef union BCM54684_AUX_1000X_CTRLr_s {
	uint32_t v[1];
	uint32_t aux_1000x_ctrl[1];
	uint32_t _aux_1000x_ctrl;
} BCM54684_AUX_1000X_CTRLr_t;

#define BCM54684_AUX_1000X_CTRLr_CLR(r) (r).aux_1000x_ctrl[0] = 0
#define BCM54684_AUX_1000X_CTRLr_SET(r,d) (r).aux_1000x_ctrl[0] = d
#define BCM54684_AUX_1000X_CTRLr_GET(r) (r).aux_1000x_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM54684_AUX_1000X_CTRLr_AUX_1000X_CTRLf_GET(r) (((r).aux_1000x_ctrl[0]) & 0xffff)
#define BCM54684_AUX_1000X_CTRLr_AUX_1000X_CTRLf_SET(r,f) (r).aux_1000x_ctrl[0]=(((r).aux_1000x_ctrl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access AUX_1000X_CTRL.
 *
 */
#define BCM54684_READ_AUX_1000X_CTRLr(_pc,_r) phy_brcm_shadow_read(_pc,BCM54684_AUX_1000X_CTRLr,(_r._aux_1000x_ctrl))
#define BCM54684_WRITE_AUX_1000X_CTRLr(_pc,_r) phy_brcm_shadow_write(_pc,BCM54684_AUX_1000X_CTRLr,(_r._aux_1000x_ctrl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AUX_1000X_CTRLr BCM54684_AUX_1000X_CTRLr
#define AUX_1000X_CTRLr_SIZE BCM54684_AUX_1000X_CTRLr_SIZE
typedef BCM54684_AUX_1000X_CTRLr_t AUX_1000X_CTRLr_t;
#define AUX_1000X_CTRLr_CLR BCM54684_AUX_1000X_CTRLr_CLR
#define AUX_1000X_CTRLr_SET BCM54684_AUX_1000X_CTRLr_SET
#define AUX_1000X_CTRLr_GET BCM54684_AUX_1000X_CTRLr_GET
#define AUX_1000X_CTRLr_AUX_1000X_CTRLf_GET BCM54684_AUX_1000X_CTRLr_AUX_1000X_CTRLf_GET
#define AUX_1000X_CTRLr_AUX_1000X_CTRLf_SET BCM54684_AUX_1000X_CTRLr_AUX_1000X_CTRLf_SET
#define READ_AUX_1000X_CTRLr BCM54684_READ_AUX_1000X_CTRLr
#define WRITE_AUX_1000X_CTRLr BCM54684_WRITE_AUX_1000X_CTRLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM54684_AUX_1000X_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM54684
 * REGISTER:  MODE_CTRL
 * BLOCKS:   USER
 * REGADDR:  0x001c
 * DESC:     Mode Control Reg (Addr 1Ch shadow 11111b)
 * SIZE:     32
 * FIELDS:
 *     MODE_CTRL        MODE_CTRL
 *
 ******************************************************************************/
#define BCM54684_MODE_CTRLr (0x00001f1c | PHY_REG_ACC_BRCM_SHADOW)

#define BCM54684_MODE_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program MODE_CTRL.
 *
 */
typedef union BCM54684_MODE_CTRLr_s {
	uint32_t v[1];
	uint32_t mode_ctrl[1];
	uint32_t _mode_ctrl;
} BCM54684_MODE_CTRLr_t;

#define BCM54684_MODE_CTRLr_CLR(r) (r).mode_ctrl[0] = 0
#define BCM54684_MODE_CTRLr_SET(r,d) (r).mode_ctrl[0] = d
#define BCM54684_MODE_CTRLr_GET(r) (r).mode_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM54684_MODE_CTRLr_MODE_CTRLf_GET(r) (((r).mode_ctrl[0]) & 0xffff)
#define BCM54684_MODE_CTRLr_MODE_CTRLf_SET(r,f) (r).mode_ctrl[0]=(((r).mode_ctrl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access MODE_CTRL.
 *
 */
#define BCM54684_READ_MODE_CTRLr(_pc,_r) phy_brcm_shadow_read(_pc,BCM54684_MODE_CTRLr,(_r._mode_ctrl))
#define BCM54684_WRITE_MODE_CTRLr(_pc,_r) phy_brcm_shadow_write(_pc,BCM54684_MODE_CTRLr,(_r._mode_ctrl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MODE_CTRLr BCM54684_MODE_CTRLr
#define MODE_CTRLr_SIZE BCM54684_MODE_CTRLr_SIZE
typedef BCM54684_MODE_CTRLr_t MODE_CTRLr_t;
#define MODE_CTRLr_CLR BCM54684_MODE_CTRLr_CLR
#define MODE_CTRLr_SET BCM54684_MODE_CTRLr_SET
#define MODE_CTRLr_GET BCM54684_MODE_CTRLr_GET
#define MODE_CTRLr_MODE_CTRLf_GET BCM54684_MODE_CTRLr_MODE_CTRLf_GET
#define MODE_CTRLr_MODE_CTRLf_SET BCM54684_MODE_CTRLr_MODE_CTRLf_SET
#define READ_MODE_CTRLr BCM54684_READ_MODE_CTRLr
#define WRITE_MODE_CTRLr BCM54684_WRITE_MODE_CTRLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM54684_MODE_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM54684
 * REGISTER:  TEST1
 * BLOCKS:   USER
 * REGADDR:  0x001e
 * DESC:     1000BASE-T/100BASE-TX/10BASE-T Test Register 1 (ADDR 1eh)
 * SIZE:     32
 * FIELDS:
 *     TEST1            TEST1
 *
 ******************************************************************************/
#define BCM54684_TEST1r (0x0000001e | PHY_REG_ACC_RAW)

#define BCM54684_TEST1r_SIZE 4

/*
 * This structure should be used to declare and program TEST1.
 *
 */
typedef union BCM54684_TEST1r_s {
	uint32_t v[1];
	uint32_t test1[1];
	uint32_t _test1;
} BCM54684_TEST1r_t;

#define BCM54684_TEST1r_CLR(r) (r).test1[0] = 0
#define BCM54684_TEST1r_SET(r,d) (r).test1[0] = d
#define BCM54684_TEST1r_GET(r) (r).test1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM54684_TEST1r_TEST1f_GET(r) (((r).test1[0]) & 0xffff)
#define BCM54684_TEST1r_TEST1f_SET(r,f) (r).test1[0]=(((r).test1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access TEST1.
 *
 */
#define BCM54684_READ_TEST1r(_pc,_r) PHY_REG_READ(_pc,BCM54684_TEST1r,_r._test1)
#define BCM54684_WRITE_TEST1r(_pc,_r) PHY_REG_WRITE(_pc,BCM54684_TEST1r,_r._test1)

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TEST1r BCM54684_TEST1r
#define TEST1r_SIZE BCM54684_TEST1r_SIZE
typedef BCM54684_TEST1r_t TEST1r_t;
#define TEST1r_CLR BCM54684_TEST1r_CLR
#define TEST1r_SET BCM54684_TEST1r_SET
#define TEST1r_GET BCM54684_TEST1r_GET
#define TEST1r_TEST1f_GET BCM54684_TEST1r_TEST1f_GET
#define TEST1r_TEST1f_SET BCM54684_TEST1r_TEST1f_SET
#define READ_TEST1r BCM54684_READ_TEST1r
#define WRITE_TEST1r BCM54684_WRITE_TEST1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM54684_TEST1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM54684
 * REGISTER:  MII_1000X_CTRL
 * BLOCKS:   IEEE
 * REGADDR:  0x0000
 * DESC:     1000BASE-X MII Control Register (Addr 00h)
 * SIZE:     32
 * FIELDS:
 *     RESERVED         Write as 1, ignore on read.
 *     COLL_TEST_EN     Enable collision test mode.
 *     FULL_DUPLEX      Full duplex operation.
 *     RESTART_AN       Restart auto-negotiation.
 *     ISOLATE          Isolate PHY from GMII/RGMII/RTBI.
 *     POWER_DOWN       Power down.
 *     AUTONEG          Auto-negotiation enabled.
 *     LOOPBACK         Loopback mode.
 *     RESET            PHY reset.
 *
 ******************************************************************************/
#define BCM54684_MII_1000X_CTRLr (0x00000000 | PHY_REG_ACC_BRCM_1000X)

#define BCM54684_MII_1000X_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program MII_1000X_CTRL.
 *
 */
typedef union BCM54684_MII_1000X_CTRLr_s {
	uint32_t v[1];
	uint32_t mii_1000x_ctrl[1];
	uint32_t _mii_1000x_ctrl;
} BCM54684_MII_1000X_CTRLr_t;

#define BCM54684_MII_1000X_CTRLr_CLR(r) (r).mii_1000x_ctrl[0] = 0
#define BCM54684_MII_1000X_CTRLr_SET(r,d) (r).mii_1000x_ctrl[0] = d
#define BCM54684_MII_1000X_CTRLr_GET(r) (r).mii_1000x_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM54684_MII_1000X_CTRLr_RESETf_GET(r) ((((r).mii_1000x_ctrl[0]) >> 15) & 0x1)
#define BCM54684_MII_1000X_CTRLr_RESETf_SET(r,f) (r).mii_1000x_ctrl[0]=(((r).mii_1000x_ctrl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM54684_MII_1000X_CTRLr_LOOPBACKf_GET(r) ((((r).mii_1000x_ctrl[0]) >> 14) & 0x1)
#define BCM54684_MII_1000X_CTRLr_LOOPBACKf_SET(r,f) (r).mii_1000x_ctrl[0]=(((r).mii_1000x_ctrl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM54684_MII_1000X_CTRLr_AUTONEGf_GET(r) ((((r).mii_1000x_ctrl[0]) >> 12) & 0x1)
#define BCM54684_MII_1000X_CTRLr_AUTONEGf_SET(r,f) (r).mii_1000x_ctrl[0]=(((r).mii_1000x_ctrl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM54684_MII_1000X_CTRLr_POWER_DOWNf_GET(r) ((((r).mii_1000x_ctrl[0]) >> 11) & 0x1)
#define BCM54684_MII_1000X_CTRLr_POWER_DOWNf_SET(r,f) (r).mii_1000x_ctrl[0]=(((r).mii_1000x_ctrl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM54684_MII_1000X_CTRLr_ISOLATEf_GET(r) ((((r).mii_1000x_ctrl[0]) >> 10) & 0x1)
#define BCM54684_MII_1000X_CTRLr_ISOLATEf_SET(r,f) (r).mii_1000x_ctrl[0]=(((r).mii_1000x_ctrl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM54684_MII_1000X_CTRLr_RESTART_ANf_GET(r) ((((r).mii_1000x_ctrl[0]) >> 9) & 0x1)
#define BCM54684_MII_1000X_CTRLr_RESTART_ANf_SET(r,f) (r).mii_1000x_ctrl[0]=(((r).mii_1000x_ctrl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM54684_MII_1000X_CTRLr_FULL_DUPLEXf_GET(r) ((((r).mii_1000x_ctrl[0]) >> 8) & 0x1)
#define BCM54684_MII_1000X_CTRLr_FULL_DUPLEXf_SET(r,f) (r).mii_1000x_ctrl[0]=(((r).mii_1000x_ctrl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM54684_MII_1000X_CTRLr_COLL_TEST_ENf_GET(r) ((((r).mii_1000x_ctrl[0]) >> 7) & 0x1)
#define BCM54684_MII_1000X_CTRLr_COLL_TEST_ENf_SET(r,f) (r).mii_1000x_ctrl[0]=(((r).mii_1000x_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM54684_MII_1000X_CTRLr_RESERVEDf_GET(r) ((((r).mii_1000x_ctrl[0]) >> 6) & 0x1)
#define BCM54684_MII_1000X_CTRLr_RESERVEDf_SET(r,f) (r).mii_1000x_ctrl[0]=(((r).mii_1000x_ctrl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))

/*
 * These macros can be used to access MII_1000X_CTRL.
 *
 */
#define BCM54684_READ_MII_1000X_CTRLr(_pc,_r) phy_brcm_1000x_read(_pc,BCM54684_MII_1000X_CTRLr,(_r._mii_1000x_ctrl))
#define BCM54684_WRITE_MII_1000X_CTRLr(_pc,_r) phy_brcm_1000x_write(_pc,BCM54684_MII_1000X_CTRLr,(_r._mii_1000x_ctrl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MII_1000X_CTRLr BCM54684_MII_1000X_CTRLr
#define MII_1000X_CTRLr_SIZE BCM54684_MII_1000X_CTRLr_SIZE
typedef BCM54684_MII_1000X_CTRLr_t MII_1000X_CTRLr_t;
#define MII_1000X_CTRLr_CLR BCM54684_MII_1000X_CTRLr_CLR
#define MII_1000X_CTRLr_SET BCM54684_MII_1000X_CTRLr_SET
#define MII_1000X_CTRLr_GET BCM54684_MII_1000X_CTRLr_GET
#define MII_1000X_CTRLr_RESETf_GET BCM54684_MII_1000X_CTRLr_RESETf_GET
#define MII_1000X_CTRLr_RESETf_SET BCM54684_MII_1000X_CTRLr_RESETf_SET
#define MII_1000X_CTRLr_LOOPBACKf_GET BCM54684_MII_1000X_CTRLr_LOOPBACKf_GET
#define MII_1000X_CTRLr_LOOPBACKf_SET BCM54684_MII_1000X_CTRLr_LOOPBACKf_SET
#define MII_1000X_CTRLr_AUTONEGf_GET BCM54684_MII_1000X_CTRLr_AUTONEGf_GET
#define MII_1000X_CTRLr_AUTONEGf_SET BCM54684_MII_1000X_CTRLr_AUTONEGf_SET
#define MII_1000X_CTRLr_POWER_DOWNf_GET BCM54684_MII_1000X_CTRLr_POWER_DOWNf_GET
#define MII_1000X_CTRLr_POWER_DOWNf_SET BCM54684_MII_1000X_CTRLr_POWER_DOWNf_SET
#define MII_1000X_CTRLr_ISOLATEf_GET BCM54684_MII_1000X_CTRLr_ISOLATEf_GET
#define MII_1000X_CTRLr_ISOLATEf_SET BCM54684_MII_1000X_CTRLr_ISOLATEf_SET
#define MII_1000X_CTRLr_RESTART_ANf_GET BCM54684_MII_1000X_CTRLr_RESTART_ANf_GET
#define MII_1000X_CTRLr_RESTART_ANf_SET BCM54684_MII_1000X_CTRLr_RESTART_ANf_SET
#define MII_1000X_CTRLr_FULL_DUPLEXf_GET BCM54684_MII_1000X_CTRLr_FULL_DUPLEXf_GET
#define MII_1000X_CTRLr_FULL_DUPLEXf_SET BCM54684_MII_1000X_CTRLr_FULL_DUPLEXf_SET
#define MII_1000X_CTRLr_COLL_TEST_ENf_GET BCM54684_MII_1000X_CTRLr_COLL_TEST_ENf_GET
#define MII_1000X_CTRLr_COLL_TEST_ENf_SET BCM54684_MII_1000X_CTRLr_COLL_TEST_ENf_SET
#define MII_1000X_CTRLr_RESERVEDf_GET BCM54684_MII_1000X_CTRLr_RESERVEDf_GET
#define MII_1000X_CTRLr_RESERVEDf_SET BCM54684_MII_1000X_CTRLr_RESERVEDf_SET
#define READ_MII_1000X_CTRLr BCM54684_READ_MII_1000X_CTRLr
#define WRITE_MII_1000X_CTRLr BCM54684_WRITE_MII_1000X_CTRLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM54684_MII_1000X_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM54684
 * REGISTER:  MII_1000X_STAT
 * BLOCKS:   IEEE
 * REGADDR:  0x0001
 * DESC:     1000BASE-X MII Status Register (Addr 01h)
 * SIZE:     32
 * FIELDS:
 *     EXT_CAPABILITY   Extended register capabilities.
 *     JABBER_DETECT    Jabber condition detected.
 *     LINK             Link is up.
 *     AUTONEG_ABILITY  Auto-negotiation capable.
 *     REMOTE_FAULT     Remote fault detected.
 *     AUTONEG_DONE     Auto-negotiation complete.
 *     MF_PREAMBLE_SUP  Preamble can be suppressed.
 *     EXT_STATUS       Extended status information in register 0Fh.
 *     CAP_100BASE_T2_HD 100BASE-T2 half-duplex capable.
 *     CAP_100BASE_T2_FD 100BASE-T2 full-duplex capable.
 *     CAP_10BASE_T_HD  10BASE-T half-duplex capable.
 *     CAP_10BASE_T_FD  10BASE-T full-duplex capable.
 *     CAP_100BASE_X_HD 100BASE-X half-duplex capable.
 *     CAP_100BASE_X_FD 100BASE-X full-duplex capable.
 *     CAP_100BASE_T4   100BASE-T4 capable.
 *
 ******************************************************************************/
#define BCM54684_MII_1000X_STATr (0x00000001 | PHY_REG_ACC_BRCM_1000X)

#define BCM54684_MII_1000X_STATr_SIZE 4

/*
 * This structure should be used to declare and program MII_1000X_STAT.
 *
 */
typedef union BCM54684_MII_1000X_STATr_s {
	uint32_t v[1];
	uint32_t mii_1000x_stat[1];
	uint32_t _mii_1000x_stat;
} BCM54684_MII_1000X_STATr_t;

#define BCM54684_MII_1000X_STATr_CLR(r) (r).mii_1000x_stat[0] = 0
#define BCM54684_MII_1000X_STATr_SET(r,d) (r).mii_1000x_stat[0] = d
#define BCM54684_MII_1000X_STATr_GET(r) (r).mii_1000x_stat[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM54684_MII_1000X_STATr_CAP_100BASE_T4f_GET(r) ((((r).mii_1000x_stat[0]) >> 15) & 0x1)
#define BCM54684_MII_1000X_STATr_CAP_100BASE_T4f_SET(r,f) (r).mii_1000x_stat[0]=(((r).mii_1000x_stat[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM54684_MII_1000X_STATr_CAP_100BASE_X_FDf_GET(r) ((((r).mii_1000x_stat[0]) >> 14) & 0x1)
#define BCM54684_MII_1000X_STATr_CAP_100BASE_X_FDf_SET(r,f) (r).mii_1000x_stat[0]=(((r).mii_1000x_stat[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM54684_MII_1000X_STATr_CAP_100BASE_X_HDf_GET(r) ((((r).mii_1000x_stat[0]) >> 13) & 0x1)
#define BCM54684_MII_1000X_STATr_CAP_100BASE_X_HDf_SET(r,f) (r).mii_1000x_stat[0]=(((r).mii_1000x_stat[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM54684_MII_1000X_STATr_CAP_10BASE_T_FDf_GET(r) ((((r).mii_1000x_stat[0]) >> 12) & 0x1)
#define BCM54684_MII_1000X_STATr_CAP_10BASE_T_FDf_SET(r,f) (r).mii_1000x_stat[0]=(((r).mii_1000x_stat[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM54684_MII_1000X_STATr_CAP_10BASE_T_HDf_GET(r) ((((r).mii_1000x_stat[0]) >> 11) & 0x1)
#define BCM54684_MII_1000X_STATr_CAP_10BASE_T_HDf_SET(r,f) (r).mii_1000x_stat[0]=(((r).mii_1000x_stat[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM54684_MII_1000X_STATr_CAP_100BASE_T2_FDf_GET(r) ((((r).mii_1000x_stat[0]) >> 10) & 0x1)
#define BCM54684_MII_1000X_STATr_CAP_100BASE_T2_FDf_SET(r,f) (r).mii_1000x_stat[0]=(((r).mii_1000x_stat[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM54684_MII_1000X_STATr_CAP_100BASE_T2_HDf_GET(r) ((((r).mii_1000x_stat[0]) >> 9) & 0x1)
#define BCM54684_MII_1000X_STATr_CAP_100BASE_T2_HDf_SET(r,f) (r).mii_1000x_stat[0]=(((r).mii_1000x_stat[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM54684_MII_1000X_STATr_EXT_STATUSf_GET(r) ((((r).mii_1000x_stat[0]) >> 8) & 0x1)
#define BCM54684_MII_1000X_STATr_EXT_STATUSf_SET(r,f) (r).mii_1000x_stat[0]=(((r).mii_1000x_stat[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM54684_MII_1000X_STATr_MF_PREAMBLE_SUPf_GET(r) ((((r).mii_1000x_stat[0]) >> 6) & 0x1)
#define BCM54684_MII_1000X_STATr_MF_PREAMBLE_SUPf_SET(r,f) (r).mii_1000x_stat[0]=(((r).mii_1000x_stat[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM54684_MII_1000X_STATr_AUTONEG_DONEf_GET(r) ((((r).mii_1000x_stat[0]) >> 5) & 0x1)
#define BCM54684_MII_1000X_STATr_AUTONEG_DONEf_SET(r,f) (r).mii_1000x_stat[0]=(((r).mii_1000x_stat[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM54684_MII_1000X_STATr_REMOTE_FAULTf_GET(r) ((((r).mii_1000x_stat[0]) >> 4) & 0x1)
#define BCM54684_MII_1000X_STATr_REMOTE_FAULTf_SET(r,f) (r).mii_1000x_stat[0]=(((r).mii_1000x_stat[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM54684_MII_1000X_STATr_AUTONEG_ABILITYf_GET(r) ((((r).mii_1000x_stat[0]) >> 3) & 0x1)
#define BCM54684_MII_1000X_STATr_AUTONEG_ABILITYf_SET(r,f) (r).mii_1000x_stat[0]=(((r).mii_1000x_stat[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM54684_MII_1000X_STATr_LINKf_GET(r) ((((r).mii_1000x_stat[0]) >> 2) & 0x1)
#define BCM54684_MII_1000X_STATr_LINKf_SET(r,f) (r).mii_1000x_stat[0]=(((r).mii_1000x_stat[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM54684_MII_1000X_STATr_JABBER_DETECTf_GET(r) ((((r).mii_1000x_stat[0]) >> 1) & 0x1)
#define BCM54684_MII_1000X_STATr_JABBER_DETECTf_SET(r,f) (r).mii_1000x_stat[0]=(((r).mii_1000x_stat[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM54684_MII_1000X_STATr_EXT_CAPABILITYf_GET(r) (((r).mii_1000x_stat[0]) & 0x1)
#define BCM54684_MII_1000X_STATr_EXT_CAPABILITYf_SET(r,f) (r).mii_1000x_stat[0]=(((r).mii_1000x_stat[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access MII_1000X_STAT.
 *
 */
#define BCM54684_READ_MII_1000X_STATr(_pc,_r) phy_brcm_1000x_read(_pc,BCM54684_MII_1000X_STATr,(_r._mii_1000x_stat))
#define BCM54684_WRITE_MII_1000X_STATr(_pc,_r) phy_brcm_1000x_write(_pc,BCM54684_MII_1000X_STATr,(_r._mii_1000x_stat))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MII_1000X_STATr BCM54684_MII_1000X_STATr
#define MII_1000X_STATr_SIZE BCM54684_MII_1000X_STATr_SIZE
typedef BCM54684_MII_1000X_STATr_t MII_1000X_STATr_t;
#define MII_1000X_STATr_CLR BCM54684_MII_1000X_STATr_CLR
#define MII_1000X_STATr_SET BCM54684_MII_1000X_STATr_SET
#define MII_1000X_STATr_GET BCM54684_MII_1000X_STATr_GET
#define MII_1000X_STATr_CAP_100BASE_T4f_GET BCM54684_MII_1000X_STATr_CAP_100BASE_T4f_GET
#define MII_1000X_STATr_CAP_100BASE_T4f_SET BCM54684_MII_1000X_STATr_CAP_100BASE_T4f_SET
#define MII_1000X_STATr_CAP_100BASE_X_FDf_GET BCM54684_MII_1000X_STATr_CAP_100BASE_X_FDf_GET
#define MII_1000X_STATr_CAP_100BASE_X_FDf_SET BCM54684_MII_1000X_STATr_CAP_100BASE_X_FDf_SET
#define MII_1000X_STATr_CAP_100BASE_X_HDf_GET BCM54684_MII_1000X_STATr_CAP_100BASE_X_HDf_GET
#define MII_1000X_STATr_CAP_100BASE_X_HDf_SET BCM54684_MII_1000X_STATr_CAP_100BASE_X_HDf_SET
#define MII_1000X_STATr_CAP_10BASE_T_FDf_GET BCM54684_MII_1000X_STATr_CAP_10BASE_T_FDf_GET
#define MII_1000X_STATr_CAP_10BASE_T_FDf_SET BCM54684_MII_1000X_STATr_CAP_10BASE_T_FDf_SET
#define MII_1000X_STATr_CAP_10BASE_T_HDf_GET BCM54684_MII_1000X_STATr_CAP_10BASE_T_HDf_GET
#define MII_1000X_STATr_CAP_10BASE_T_HDf_SET BCM54684_MII_1000X_STATr_CAP_10BASE_T_HDf_SET
#define MII_1000X_STATr_CAP_100BASE_T2_FDf_GET BCM54684_MII_1000X_STATr_CAP_100BASE_T2_FDf_GET
#define MII_1000X_STATr_CAP_100BASE_T2_FDf_SET BCM54684_MII_1000X_STATr_CAP_100BASE_T2_FDf_SET
#define MII_1000X_STATr_CAP_100BASE_T2_HDf_GET BCM54684_MII_1000X_STATr_CAP_100BASE_T2_HDf_GET
#define MII_1000X_STATr_CAP_100BASE_T2_HDf_SET BCM54684_MII_1000X_STATr_CAP_100BASE_T2_HDf_SET
#define MII_1000X_STATr_EXT_STATUSf_GET BCM54684_MII_1000X_STATr_EXT_STATUSf_GET
#define MII_1000X_STATr_EXT_STATUSf_SET BCM54684_MII_1000X_STATr_EXT_STATUSf_SET
#define MII_1000X_STATr_MF_PREAMBLE_SUPf_GET BCM54684_MII_1000X_STATr_MF_PREAMBLE_SUPf_GET
#define MII_1000X_STATr_MF_PREAMBLE_SUPf_SET BCM54684_MII_1000X_STATr_MF_PREAMBLE_SUPf_SET
#define MII_1000X_STATr_AUTONEG_DONEf_GET BCM54684_MII_1000X_STATr_AUTONEG_DONEf_GET
#define MII_1000X_STATr_AUTONEG_DONEf_SET BCM54684_MII_1000X_STATr_AUTONEG_DONEf_SET
#define MII_1000X_STATr_REMOTE_FAULTf_GET BCM54684_MII_1000X_STATr_REMOTE_FAULTf_GET
#define MII_1000X_STATr_REMOTE_FAULTf_SET BCM54684_MII_1000X_STATr_REMOTE_FAULTf_SET
#define MII_1000X_STATr_AUTONEG_ABILITYf_GET BCM54684_MII_1000X_STATr_AUTONEG_ABILITYf_GET
#define MII_1000X_STATr_AUTONEG_ABILITYf_SET BCM54684_MII_1000X_STATr_AUTONEG_ABILITYf_SET
#define MII_1000X_STATr_LINKf_GET BCM54684_MII_1000X_STATr_LINKf_GET
#define MII_1000X_STATr_LINKf_SET BCM54684_MII_1000X_STATr_LINKf_SET
#define MII_1000X_STATr_JABBER_DETECTf_GET BCM54684_MII_1000X_STATr_JABBER_DETECTf_GET
#define MII_1000X_STATr_JABBER_DETECTf_SET BCM54684_MII_1000X_STATr_JABBER_DETECTf_SET
#define MII_1000X_STATr_EXT_CAPABILITYf_GET BCM54684_MII_1000X_STATr_EXT_CAPABILITYf_GET
#define MII_1000X_STATr_EXT_CAPABILITYf_SET BCM54684_MII_1000X_STATr_EXT_CAPABILITYf_SET
#define READ_MII_1000X_STATr BCM54684_READ_MII_1000X_STATr
#define WRITE_MII_1000X_STATr BCM54684_WRITE_MII_1000X_STATr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM54684_MII_1000X_STATr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM54684
 * REGISTER:  MII_1000X_ANA
 * BLOCKS:   IEEE
 * REGADDR:  0x0004
 * DESC:     1000BASE-X MII Auto-Negotiation Advertise Register (Addr 04h)
 * SIZE:     32
 * FIELDS:
 *     CAP_1000BASE_X_FD 1000BASE-X full-duplex capable.
 *     CAP_1000BASE_X_HD 1000BASE-X half-duplex capable.
 *     PAUSE            Pause capable.
 *     REMOTE_FAULT     Advertise remote fault detected.
 *
 ******************************************************************************/
#define BCM54684_MII_1000X_ANAr (0x00000004 | PHY_REG_ACC_BRCM_1000X)

#define BCM54684_MII_1000X_ANAr_SIZE 4

/*
 * This structure should be used to declare and program MII_1000X_ANA.
 *
 */
typedef union BCM54684_MII_1000X_ANAr_s {
	uint32_t v[1];
	uint32_t mii_1000x_ana[1];
	uint32_t _mii_1000x_ana;
} BCM54684_MII_1000X_ANAr_t;

#define BCM54684_MII_1000X_ANAr_CLR(r) (r).mii_1000x_ana[0] = 0
#define BCM54684_MII_1000X_ANAr_SET(r,d) (r).mii_1000x_ana[0] = d
#define BCM54684_MII_1000X_ANAr_GET(r) (r).mii_1000x_ana[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM54684_MII_1000X_ANAr_REMOTE_FAULTf_GET(r) ((((r).mii_1000x_ana[0]) >> 13) & 0x1)
#define BCM54684_MII_1000X_ANAr_REMOTE_FAULTf_SET(r,f) (r).mii_1000x_ana[0]=(((r).mii_1000x_ana[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM54684_MII_1000X_ANAr_PAUSEf_GET(r) ((((r).mii_1000x_ana[0]) >> 7) & 0x3)
#define BCM54684_MII_1000X_ANAr_PAUSEf_SET(r,f) (r).mii_1000x_ana[0]=(((r).mii_1000x_ana[0] & ~((uint32_t)0x3 << 7)) | ((((uint32_t)f) & 0x3) << 7))
#define BCM54684_MII_1000X_ANAr_CAP_1000BASE_X_HDf_GET(r) ((((r).mii_1000x_ana[0]) >> 6) & 0x1)
#define BCM54684_MII_1000X_ANAr_CAP_1000BASE_X_HDf_SET(r,f) (r).mii_1000x_ana[0]=(((r).mii_1000x_ana[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM54684_MII_1000X_ANAr_CAP_1000BASE_X_FDf_GET(r) ((((r).mii_1000x_ana[0]) >> 5) & 0x1)
#define BCM54684_MII_1000X_ANAr_CAP_1000BASE_X_FDf_SET(r,f) (r).mii_1000x_ana[0]=(((r).mii_1000x_ana[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))

/*
 * These macros can be used to access MII_1000X_ANA.
 *
 */
#define BCM54684_READ_MII_1000X_ANAr(_pc,_r) phy_brcm_1000x_read(_pc,BCM54684_MII_1000X_ANAr,(_r._mii_1000x_ana))
#define BCM54684_WRITE_MII_1000X_ANAr(_pc,_r) phy_brcm_1000x_write(_pc,BCM54684_MII_1000X_ANAr,(_r._mii_1000x_ana))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MII_1000X_ANAr BCM54684_MII_1000X_ANAr
#define MII_1000X_ANAr_SIZE BCM54684_MII_1000X_ANAr_SIZE
typedef BCM54684_MII_1000X_ANAr_t MII_1000X_ANAr_t;
#define MII_1000X_ANAr_CLR BCM54684_MII_1000X_ANAr_CLR
#define MII_1000X_ANAr_SET BCM54684_MII_1000X_ANAr_SET
#define MII_1000X_ANAr_GET BCM54684_MII_1000X_ANAr_GET
#define MII_1000X_ANAr_REMOTE_FAULTf_GET BCM54684_MII_1000X_ANAr_REMOTE_FAULTf_GET
#define MII_1000X_ANAr_REMOTE_FAULTf_SET BCM54684_MII_1000X_ANAr_REMOTE_FAULTf_SET
#define MII_1000X_ANAr_PAUSEf_GET BCM54684_MII_1000X_ANAr_PAUSEf_GET
#define MII_1000X_ANAr_PAUSEf_SET BCM54684_MII_1000X_ANAr_PAUSEf_SET
#define MII_1000X_ANAr_CAP_1000BASE_X_HDf_GET BCM54684_MII_1000X_ANAr_CAP_1000BASE_X_HDf_GET
#define MII_1000X_ANAr_CAP_1000BASE_X_HDf_SET BCM54684_MII_1000X_ANAr_CAP_1000BASE_X_HDf_SET
#define MII_1000X_ANAr_CAP_1000BASE_X_FDf_GET BCM54684_MII_1000X_ANAr_CAP_1000BASE_X_FDf_GET
#define MII_1000X_ANAr_CAP_1000BASE_X_FDf_SET BCM54684_MII_1000X_ANAr_CAP_1000BASE_X_FDf_SET
#define READ_MII_1000X_ANAr BCM54684_READ_MII_1000X_ANAr
#define WRITE_MII_1000X_ANAr BCM54684_WRITE_MII_1000X_ANAr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM54684_MII_1000X_ANAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM54684
 * REGISTER:  MII_1000X_ANP
 * BLOCKS:   IEEE
 * REGADDR:  0x0005
 * DESC:     1000BASE-X MII Auto-Negotiation Link Partner Ability Register (Addr 05h)
 * SIZE:     32
 * FIELDS:
 *     CAP_1000BASE_X_FD 1000BASE-X full-duplex capable.
 *     CAP_1000BASE_X_HD 1000BASE-X half-duplex capable.
 *     PAUSE            Pause capable.
 *     REMOTE_FAULT     Link partner has detected remote fault.
 *     ACK              Link partner has received link code word.
 *     NEXT_PAGE        Link partner has Next Page ability.
 *
 ******************************************************************************/
#define BCM54684_MII_1000X_ANPr (0x00000005 | PHY_REG_ACC_BRCM_1000X)

#define BCM54684_MII_1000X_ANPr_SIZE 4

/*
 * This structure should be used to declare and program MII_1000X_ANP.
 *
 */
typedef union BCM54684_MII_1000X_ANPr_s {
	uint32_t v[1];
	uint32_t mii_1000x_anp[1];
	uint32_t _mii_1000x_anp;
} BCM54684_MII_1000X_ANPr_t;

#define BCM54684_MII_1000X_ANPr_CLR(r) (r).mii_1000x_anp[0] = 0
#define BCM54684_MII_1000X_ANPr_SET(r,d) (r).mii_1000x_anp[0] = d
#define BCM54684_MII_1000X_ANPr_GET(r) (r).mii_1000x_anp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM54684_MII_1000X_ANPr_NEXT_PAGEf_GET(r) ((((r).mii_1000x_anp[0]) >> 15) & 0x1)
#define BCM54684_MII_1000X_ANPr_NEXT_PAGEf_SET(r,f) (r).mii_1000x_anp[0]=(((r).mii_1000x_anp[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM54684_MII_1000X_ANPr_ACKf_GET(r) ((((r).mii_1000x_anp[0]) >> 14) & 0x1)
#define BCM54684_MII_1000X_ANPr_ACKf_SET(r,f) (r).mii_1000x_anp[0]=(((r).mii_1000x_anp[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM54684_MII_1000X_ANPr_REMOTE_FAULTf_GET(r) ((((r).mii_1000x_anp[0]) >> 13) & 0x1)
#define BCM54684_MII_1000X_ANPr_REMOTE_FAULTf_SET(r,f) (r).mii_1000x_anp[0]=(((r).mii_1000x_anp[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM54684_MII_1000X_ANPr_PAUSEf_GET(r) ((((r).mii_1000x_anp[0]) >> 7) & 0x3)
#define BCM54684_MII_1000X_ANPr_PAUSEf_SET(r,f) (r).mii_1000x_anp[0]=(((r).mii_1000x_anp[0] & ~((uint32_t)0x3 << 7)) | ((((uint32_t)f) & 0x3) << 7))
#define BCM54684_MII_1000X_ANPr_CAP_1000BASE_X_HDf_GET(r) ((((r).mii_1000x_anp[0]) >> 6) & 0x1)
#define BCM54684_MII_1000X_ANPr_CAP_1000BASE_X_HDf_SET(r,f) (r).mii_1000x_anp[0]=(((r).mii_1000x_anp[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM54684_MII_1000X_ANPr_CAP_1000BASE_X_FDf_GET(r) ((((r).mii_1000x_anp[0]) >> 5) & 0x1)
#define BCM54684_MII_1000X_ANPr_CAP_1000BASE_X_FDf_SET(r,f) (r).mii_1000x_anp[0]=(((r).mii_1000x_anp[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))

/*
 * These macros can be used to access MII_1000X_ANP.
 *
 */
#define BCM54684_READ_MII_1000X_ANPr(_pc,_r) phy_brcm_1000x_read(_pc,BCM54684_MII_1000X_ANPr,(_r._mii_1000x_anp))
#define BCM54684_WRITE_MII_1000X_ANPr(_pc,_r) phy_brcm_1000x_write(_pc,BCM54684_MII_1000X_ANPr,(_r._mii_1000x_anp))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MII_1000X_ANPr BCM54684_MII_1000X_ANPr
#define MII_1000X_ANPr_SIZE BCM54684_MII_1000X_ANPr_SIZE
typedef BCM54684_MII_1000X_ANPr_t MII_1000X_ANPr_t;
#define MII_1000X_ANPr_CLR BCM54684_MII_1000X_ANPr_CLR
#define MII_1000X_ANPr_SET BCM54684_MII_1000X_ANPr_SET
#define MII_1000X_ANPr_GET BCM54684_MII_1000X_ANPr_GET
#define MII_1000X_ANPr_NEXT_PAGEf_GET BCM54684_MII_1000X_ANPr_NEXT_PAGEf_GET
#define MII_1000X_ANPr_NEXT_PAGEf_SET BCM54684_MII_1000X_ANPr_NEXT_PAGEf_SET
#define MII_1000X_ANPr_ACKf_GET BCM54684_MII_1000X_ANPr_ACKf_GET
#define MII_1000X_ANPr_ACKf_SET BCM54684_MII_1000X_ANPr_ACKf_SET
#define MII_1000X_ANPr_REMOTE_FAULTf_GET BCM54684_MII_1000X_ANPr_REMOTE_FAULTf_GET
#define MII_1000X_ANPr_REMOTE_FAULTf_SET BCM54684_MII_1000X_ANPr_REMOTE_FAULTf_SET
#define MII_1000X_ANPr_PAUSEf_GET BCM54684_MII_1000X_ANPr_PAUSEf_GET
#define MII_1000X_ANPr_PAUSEf_SET BCM54684_MII_1000X_ANPr_PAUSEf_SET
#define MII_1000X_ANPr_CAP_1000BASE_X_HDf_GET BCM54684_MII_1000X_ANPr_CAP_1000BASE_X_HDf_GET
#define MII_1000X_ANPr_CAP_1000BASE_X_HDf_SET BCM54684_MII_1000X_ANPr_CAP_1000BASE_X_HDf_SET
#define MII_1000X_ANPr_CAP_1000BASE_X_FDf_GET BCM54684_MII_1000X_ANPr_CAP_1000BASE_X_FDf_GET
#define MII_1000X_ANPr_CAP_1000BASE_X_FDf_SET BCM54684_MII_1000X_ANPr_CAP_1000BASE_X_FDf_SET
#define READ_MII_1000X_ANPr BCM54684_READ_MII_1000X_ANPr
#define WRITE_MII_1000X_ANPr BCM54684_WRITE_MII_1000X_ANPr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM54684_MII_1000X_ANPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM54684
 * REGISTER:  EXP_PKT_COUNTER
 * BLOCKS:   USER
 * REGADDR:  0x0015
 * DESC:     Receive/Transmit Packet Counter Register (Addr 00h)
 * SIZE:     32
 * FIELDS:
 *     EXP_PKT_COUNTER  EXP_PKT_COUNTER
 *
 ******************************************************************************/
#define BCM54684_EXP_PKT_COUNTERr (0x000f0015 | PHY_REG_ACC_BRCM_SHADOW)

#define BCM54684_EXP_PKT_COUNTERr_SIZE 4

/*
 * This structure should be used to declare and program EXP_PKT_COUNTER.
 *
 */
typedef union BCM54684_EXP_PKT_COUNTERr_s {
	uint32_t v[1];
	uint32_t exp_pkt_counter[1];
	uint32_t _exp_pkt_counter;
} BCM54684_EXP_PKT_COUNTERr_t;

#define BCM54684_EXP_PKT_COUNTERr_CLR(r) (r).exp_pkt_counter[0] = 0
#define BCM54684_EXP_PKT_COUNTERr_SET(r,d) (r).exp_pkt_counter[0] = d
#define BCM54684_EXP_PKT_COUNTERr_GET(r) (r).exp_pkt_counter[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM54684_EXP_PKT_COUNTERr_EXP_PKT_COUNTERf_GET(r) (((r).exp_pkt_counter[0]) & 0xffff)
#define BCM54684_EXP_PKT_COUNTERr_EXP_PKT_COUNTERf_SET(r,f) (r).exp_pkt_counter[0]=(((r).exp_pkt_counter[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access EXP_PKT_COUNTER.
 *
 */
#define BCM54684_READ_EXP_PKT_COUNTERr(_pc,_r) phy_brcm_shadow_read(_pc,BCM54684_EXP_PKT_COUNTERr,(_r._exp_pkt_counter))
#define BCM54684_WRITE_EXP_PKT_COUNTERr(_pc,_r) phy_brcm_shadow_write(_pc,BCM54684_EXP_PKT_COUNTERr,(_r._exp_pkt_counter))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define EXP_PKT_COUNTERr BCM54684_EXP_PKT_COUNTERr
#define EXP_PKT_COUNTERr_SIZE BCM54684_EXP_PKT_COUNTERr_SIZE
typedef BCM54684_EXP_PKT_COUNTERr_t EXP_PKT_COUNTERr_t;
#define EXP_PKT_COUNTERr_CLR BCM54684_EXP_PKT_COUNTERr_CLR
#define EXP_PKT_COUNTERr_SET BCM54684_EXP_PKT_COUNTERr_SET
#define EXP_PKT_COUNTERr_GET BCM54684_EXP_PKT_COUNTERr_GET
#define EXP_PKT_COUNTERr_EXP_PKT_COUNTERf_GET BCM54684_EXP_PKT_COUNTERr_EXP_PKT_COUNTERf_GET
#define EXP_PKT_COUNTERr_EXP_PKT_COUNTERf_SET BCM54684_EXP_PKT_COUNTERr_EXP_PKT_COUNTERf_SET
#define READ_EXP_PKT_COUNTERr BCM54684_READ_EXP_PKT_COUNTERr
#define WRITE_EXP_PKT_COUNTERr BCM54684_WRITE_EXP_PKT_COUNTERr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM54684_EXP_PKT_COUNTERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM54684
 * REGISTER:  EXP_LED_SELECTOR
 * BLOCKS:   USER
 * REGADDR:  0x0015
 * DESC:     Multicolor LED Selector Register (Addr 04h)
 * SIZE:     32
 * FIELDS:
 *     EXP_LED_SELECTOR EXP_LED_SELECTOR
 *
 ******************************************************************************/
#define BCM54684_EXP_LED_SELECTORr (0x000f0415 | PHY_REG_ACC_BRCM_SHADOW)

#define BCM54684_EXP_LED_SELECTORr_SIZE 4

/*
 * This structure should be used to declare and program EXP_LED_SELECTOR.
 *
 */
typedef union BCM54684_EXP_LED_SELECTORr_s {
	uint32_t v[1];
	uint32_t exp_led_selector[1];
	uint32_t _exp_led_selector;
} BCM54684_EXP_LED_SELECTORr_t;

#define BCM54684_EXP_LED_SELECTORr_CLR(r) (r).exp_led_selector[0] = 0
#define BCM54684_EXP_LED_SELECTORr_SET(r,d) (r).exp_led_selector[0] = d
#define BCM54684_EXP_LED_SELECTORr_GET(r) (r).exp_led_selector[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM54684_EXP_LED_SELECTORr_EXP_LED_SELECTORf_GET(r) (((r).exp_led_selector[0]) & 0xffff)
#define BCM54684_EXP_LED_SELECTORr_EXP_LED_SELECTORf_SET(r,f) (r).exp_led_selector[0]=(((r).exp_led_selector[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access EXP_LED_SELECTOR.
 *
 */
#define BCM54684_READ_EXP_LED_SELECTORr(_pc,_r) phy_brcm_shadow_read(_pc,BCM54684_EXP_LED_SELECTORr,(_r._exp_led_selector))
#define BCM54684_WRITE_EXP_LED_SELECTORr(_pc,_r) phy_brcm_shadow_write(_pc,BCM54684_EXP_LED_SELECTORr,(_r._exp_led_selector))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define EXP_LED_SELECTORr BCM54684_EXP_LED_SELECTORr
#define EXP_LED_SELECTORr_SIZE BCM54684_EXP_LED_SELECTORr_SIZE
typedef BCM54684_EXP_LED_SELECTORr_t EXP_LED_SELECTORr_t;
#define EXP_LED_SELECTORr_CLR BCM54684_EXP_LED_SELECTORr_CLR
#define EXP_LED_SELECTORr_SET BCM54684_EXP_LED_SELECTORr_SET
#define EXP_LED_SELECTORr_GET BCM54684_EXP_LED_SELECTORr_GET
#define EXP_LED_SELECTORr_EXP_LED_SELECTORf_GET BCM54684_EXP_LED_SELECTORr_EXP_LED_SELECTORf_GET
#define EXP_LED_SELECTORr_EXP_LED_SELECTORf_SET BCM54684_EXP_LED_SELECTORr_EXP_LED_SELECTORf_SET
#define READ_EXP_LED_SELECTORr BCM54684_READ_EXP_LED_SELECTORr
#define WRITE_EXP_LED_SELECTORr BCM54684_WRITE_EXP_LED_SELECTORr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM54684_EXP_LED_SELECTORr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM54684
 * REGISTER:  EXP_LED_FLASH_CTRL
 * BLOCKS:   USER
 * REGADDR:  0x0015
 * DESC:     Multicolor LED Flash Rate Controls Register (Addr 05h)
 * SIZE:     32
 * FIELDS:
 *     EXP_LED_FLASH_CTRL EXP_LED_FLASH_CTRL
 *
 ******************************************************************************/
#define BCM54684_EXP_LED_FLASH_CTRLr (0x000f0515 | PHY_REG_ACC_BRCM_SHADOW)

#define BCM54684_EXP_LED_FLASH_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program EXP_LED_FLASH_CTRL.
 *
 */
typedef union BCM54684_EXP_LED_FLASH_CTRLr_s {
	uint32_t v[1];
	uint32_t exp_led_flash_ctrl[1];
	uint32_t _exp_led_flash_ctrl;
} BCM54684_EXP_LED_FLASH_CTRLr_t;

#define BCM54684_EXP_LED_FLASH_CTRLr_CLR(r) (r).exp_led_flash_ctrl[0] = 0
#define BCM54684_EXP_LED_FLASH_CTRLr_SET(r,d) (r).exp_led_flash_ctrl[0] = d
#define BCM54684_EXP_LED_FLASH_CTRLr_GET(r) (r).exp_led_flash_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM54684_EXP_LED_FLASH_CTRLr_EXP_LED_FLASH_CTRLf_GET(r) (((r).exp_led_flash_ctrl[0]) & 0xffff)
#define BCM54684_EXP_LED_FLASH_CTRLr_EXP_LED_FLASH_CTRLf_SET(r,f) (r).exp_led_flash_ctrl[0]=(((r).exp_led_flash_ctrl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access EXP_LED_FLASH_CTRL.
 *
 */
#define BCM54684_READ_EXP_LED_FLASH_CTRLr(_pc,_r) phy_brcm_shadow_read(_pc,BCM54684_EXP_LED_FLASH_CTRLr,(_r._exp_led_flash_ctrl))
#define BCM54684_WRITE_EXP_LED_FLASH_CTRLr(_pc,_r) phy_brcm_shadow_write(_pc,BCM54684_EXP_LED_FLASH_CTRLr,(_r._exp_led_flash_ctrl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define EXP_LED_FLASH_CTRLr BCM54684_EXP_LED_FLASH_CTRLr
#define EXP_LED_FLASH_CTRLr_SIZE BCM54684_EXP_LED_FLASH_CTRLr_SIZE
typedef BCM54684_EXP_LED_FLASH_CTRLr_t EXP_LED_FLASH_CTRLr_t;
#define EXP_LED_FLASH_CTRLr_CLR BCM54684_EXP_LED_FLASH_CTRLr_CLR
#define EXP_LED_FLASH_CTRLr_SET BCM54684_EXP_LED_FLASH_CTRLr_SET
#define EXP_LED_FLASH_CTRLr_GET BCM54684_EXP_LED_FLASH_CTRLr_GET
#define EXP_LED_FLASH_CTRLr_EXP_LED_FLASH_CTRLf_GET BCM54684_EXP_LED_FLASH_CTRLr_EXP_LED_FLASH_CTRLf_GET
#define EXP_LED_FLASH_CTRLr_EXP_LED_FLASH_CTRLf_SET BCM54684_EXP_LED_FLASH_CTRLr_EXP_LED_FLASH_CTRLf_SET
#define READ_EXP_LED_FLASH_CTRLr BCM54684_READ_EXP_LED_FLASH_CTRLr
#define WRITE_EXP_LED_FLASH_CTRLr BCM54684_WRITE_EXP_LED_FLASH_CTRLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM54684_EXP_LED_FLASH_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM54684
 * REGISTER:  EXP_LED_BLINK_CTRL
 * BLOCKS:   USER
 * REGADDR:  0x0015
 * DESC:     Multicolor LED Programmable Blink Controls Register (Addr 06h)
 * SIZE:     32
 * FIELDS:
 *     EXP_LED_BLINK_CTRL EXP_LED_BLINK_CTRL
 *
 ******************************************************************************/
#define BCM54684_EXP_LED_BLINK_CTRLr (0x000f0615 | PHY_REG_ACC_BRCM_SHADOW)

#define BCM54684_EXP_LED_BLINK_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program EXP_LED_BLINK_CTRL.
 *
 */
typedef union BCM54684_EXP_LED_BLINK_CTRLr_s {
	uint32_t v[1];
	uint32_t exp_led_blink_ctrl[1];
	uint32_t _exp_led_blink_ctrl;
} BCM54684_EXP_LED_BLINK_CTRLr_t;

#define BCM54684_EXP_LED_BLINK_CTRLr_CLR(r) (r).exp_led_blink_ctrl[0] = 0
#define BCM54684_EXP_LED_BLINK_CTRLr_SET(r,d) (r).exp_led_blink_ctrl[0] = d
#define BCM54684_EXP_LED_BLINK_CTRLr_GET(r) (r).exp_led_blink_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM54684_EXP_LED_BLINK_CTRLr_EXP_LED_BLINK_CTRLf_GET(r) (((r).exp_led_blink_ctrl[0]) & 0xffff)
#define BCM54684_EXP_LED_BLINK_CTRLr_EXP_LED_BLINK_CTRLf_SET(r,f) (r).exp_led_blink_ctrl[0]=(((r).exp_led_blink_ctrl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access EXP_LED_BLINK_CTRL.
 *
 */
#define BCM54684_READ_EXP_LED_BLINK_CTRLr(_pc,_r) phy_brcm_shadow_read(_pc,BCM54684_EXP_LED_BLINK_CTRLr,(_r._exp_led_blink_ctrl))
#define BCM54684_WRITE_EXP_LED_BLINK_CTRLr(_pc,_r) phy_brcm_shadow_write(_pc,BCM54684_EXP_LED_BLINK_CTRLr,(_r._exp_led_blink_ctrl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define EXP_LED_BLINK_CTRLr BCM54684_EXP_LED_BLINK_CTRLr
#define EXP_LED_BLINK_CTRLr_SIZE BCM54684_EXP_LED_BLINK_CTRLr_SIZE
typedef BCM54684_EXP_LED_BLINK_CTRLr_t EXP_LED_BLINK_CTRLr_t;
#define EXP_LED_BLINK_CTRLr_CLR BCM54684_EXP_LED_BLINK_CTRLr_CLR
#define EXP_LED_BLINK_CTRLr_SET BCM54684_EXP_LED_BLINK_CTRLr_SET
#define EXP_LED_BLINK_CTRLr_GET BCM54684_EXP_LED_BLINK_CTRLr_GET
#define EXP_LED_BLINK_CTRLr_EXP_LED_BLINK_CTRLf_GET BCM54684_EXP_LED_BLINK_CTRLr_EXP_LED_BLINK_CTRLf_GET
#define EXP_LED_BLINK_CTRLr_EXP_LED_BLINK_CTRLf_SET BCM54684_EXP_LED_BLINK_CTRLr_EXP_LED_BLINK_CTRLf_SET
#define READ_EXP_LED_BLINK_CTRLr BCM54684_READ_EXP_LED_BLINK_CTRLr
#define WRITE_EXP_LED_BLINK_CTRLr BCM54684_WRITE_EXP_LED_BLINK_CTRLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM54684_EXP_LED_BLINK_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM54684
 * REGISTER:  EXT_CABLE_DIAG_RESULT
 * BLOCKS:   USER
 * REGADDR:  0x0015
 * DESC:     Cable Diagnostics Results (Addr 11h)
 * SIZE:     32
 * FIELDS:
 *     EXT_CABLE_DIAG_RESULT EXT_CABLE_DIAG_RESULT
 *
 ******************************************************************************/
#define BCM54684_EXT_CABLE_DIAG_RESULTr (0x000f1115 | PHY_REG_ACC_BRCM_SHADOW)

#define BCM54684_EXT_CABLE_DIAG_RESULTr_SIZE 4

/*
 * This structure should be used to declare and program EXT_CABLE_DIAG_RESULT.
 *
 */
typedef union BCM54684_EXT_CABLE_DIAG_RESULTr_s {
	uint32_t v[1];
	uint32_t ext_cable_diag_result[1];
	uint32_t _ext_cable_diag_result;
} BCM54684_EXT_CABLE_DIAG_RESULTr_t;

#define BCM54684_EXT_CABLE_DIAG_RESULTr_CLR(r) (r).ext_cable_diag_result[0] = 0
#define BCM54684_EXT_CABLE_DIAG_RESULTr_SET(r,d) (r).ext_cable_diag_result[0] = d
#define BCM54684_EXT_CABLE_DIAG_RESULTr_GET(r) (r).ext_cable_diag_result[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM54684_EXT_CABLE_DIAG_RESULTr_EXT_CABLE_DIAG_RESULTf_GET(r) (((r).ext_cable_diag_result[0]) & 0xffff)
#define BCM54684_EXT_CABLE_DIAG_RESULTr_EXT_CABLE_DIAG_RESULTf_SET(r,f) (r).ext_cable_diag_result[0]=(((r).ext_cable_diag_result[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access EXT_CABLE_DIAG_RESULT.
 *
 */
#define BCM54684_READ_EXT_CABLE_DIAG_RESULTr(_pc,_r) phy_brcm_shadow_read(_pc,BCM54684_EXT_CABLE_DIAG_RESULTr,(_r._ext_cable_diag_result))
#define BCM54684_WRITE_EXT_CABLE_DIAG_RESULTr(_pc,_r) phy_brcm_shadow_write(_pc,BCM54684_EXT_CABLE_DIAG_RESULTr,(_r._ext_cable_diag_result))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define EXT_CABLE_DIAG_RESULTr BCM54684_EXT_CABLE_DIAG_RESULTr
#define EXT_CABLE_DIAG_RESULTr_SIZE BCM54684_EXT_CABLE_DIAG_RESULTr_SIZE
typedef BCM54684_EXT_CABLE_DIAG_RESULTr_t EXT_CABLE_DIAG_RESULTr_t;
#define EXT_CABLE_DIAG_RESULTr_CLR BCM54684_EXT_CABLE_DIAG_RESULTr_CLR
#define EXT_CABLE_DIAG_RESULTr_SET BCM54684_EXT_CABLE_DIAG_RESULTr_SET
#define EXT_CABLE_DIAG_RESULTr_GET BCM54684_EXT_CABLE_DIAG_RESULTr_GET
#define EXT_CABLE_DIAG_RESULTr_EXT_CABLE_DIAG_RESULTf_GET BCM54684_EXT_CABLE_DIAG_RESULTr_EXT_CABLE_DIAG_RESULTf_GET
#define EXT_CABLE_DIAG_RESULTr_EXT_CABLE_DIAG_RESULTf_SET BCM54684_EXT_CABLE_DIAG_RESULTr_EXT_CABLE_DIAG_RESULTf_SET
#define READ_EXT_CABLE_DIAG_RESULTr BCM54684_READ_EXT_CABLE_DIAG_RESULTr
#define WRITE_EXT_CABLE_DIAG_RESULTr BCM54684_WRITE_EXT_CABLE_DIAG_RESULTr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM54684_EXT_CABLE_DIAG_RESULTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM54684
 * REGISTER:  EXT_CABLE_DIAG_LEN_1
 * BLOCKS:   USER
 * REGADDR:  0x0015
 * DESC:     Cable Diagnostics Lengths 1 (Addr 12h)
 * SIZE:     32
 * FIELDS:
 *     EXT_CABLE_DIAG_LEN_1 EXT_CABLE_DIAG_LEN_1
 *
 ******************************************************************************/
#define BCM54684_EXT_CABLE_DIAG_LEN_1r (0x000f1215 | PHY_REG_ACC_BRCM_SHADOW)

#define BCM54684_EXT_CABLE_DIAG_LEN_1r_SIZE 4

/*
 * This structure should be used to declare and program EXT_CABLE_DIAG_LEN_1.
 *
 */
typedef union BCM54684_EXT_CABLE_DIAG_LEN_1r_s {
	uint32_t v[1];
	uint32_t ext_cable_diag_len_1[1];
	uint32_t _ext_cable_diag_len_1;
} BCM54684_EXT_CABLE_DIAG_LEN_1r_t;

#define BCM54684_EXT_CABLE_DIAG_LEN_1r_CLR(r) (r).ext_cable_diag_len_1[0] = 0
#define BCM54684_EXT_CABLE_DIAG_LEN_1r_SET(r,d) (r).ext_cable_diag_len_1[0] = d
#define BCM54684_EXT_CABLE_DIAG_LEN_1r_GET(r) (r).ext_cable_diag_len_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM54684_EXT_CABLE_DIAG_LEN_1r_EXT_CABLE_DIAG_LEN_1f_GET(r) (((r).ext_cable_diag_len_1[0]) & 0xffff)
#define BCM54684_EXT_CABLE_DIAG_LEN_1r_EXT_CABLE_DIAG_LEN_1f_SET(r,f) (r).ext_cable_diag_len_1[0]=(((r).ext_cable_diag_len_1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access EXT_CABLE_DIAG_LEN_1.
 *
 */
#define BCM54684_READ_EXT_CABLE_DIAG_LEN_1r(_pc,_r) phy_brcm_shadow_read(_pc,BCM54684_EXT_CABLE_DIAG_LEN_1r,(_r._ext_cable_diag_len_1))
#define BCM54684_WRITE_EXT_CABLE_DIAG_LEN_1r(_pc,_r) phy_brcm_shadow_write(_pc,BCM54684_EXT_CABLE_DIAG_LEN_1r,(_r._ext_cable_diag_len_1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define EXT_CABLE_DIAG_LEN_1r BCM54684_EXT_CABLE_DIAG_LEN_1r
#define EXT_CABLE_DIAG_LEN_1r_SIZE BCM54684_EXT_CABLE_DIAG_LEN_1r_SIZE
typedef BCM54684_EXT_CABLE_DIAG_LEN_1r_t EXT_CABLE_DIAG_LEN_1r_t;
#define EXT_CABLE_DIAG_LEN_1r_CLR BCM54684_EXT_CABLE_DIAG_LEN_1r_CLR
#define EXT_CABLE_DIAG_LEN_1r_SET BCM54684_EXT_CABLE_DIAG_LEN_1r_SET
#define EXT_CABLE_DIAG_LEN_1r_GET BCM54684_EXT_CABLE_DIAG_LEN_1r_GET
#define EXT_CABLE_DIAG_LEN_1r_EXT_CABLE_DIAG_LEN_1f_GET BCM54684_EXT_CABLE_DIAG_LEN_1r_EXT_CABLE_DIAG_LEN_1f_GET
#define EXT_CABLE_DIAG_LEN_1r_EXT_CABLE_DIAG_LEN_1f_SET BCM54684_EXT_CABLE_DIAG_LEN_1r_EXT_CABLE_DIAG_LEN_1f_SET
#define READ_EXT_CABLE_DIAG_LEN_1r BCM54684_READ_EXT_CABLE_DIAG_LEN_1r
#define WRITE_EXT_CABLE_DIAG_LEN_1r BCM54684_WRITE_EXT_CABLE_DIAG_LEN_1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM54684_EXT_CABLE_DIAG_LEN_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM54684
 * REGISTER:  EXT_CABLE_DIAG_LEN_2
 * BLOCKS:   USER
 * REGADDR:  0x0015
 * DESC:     Cable Diagnostics Lengths 2 (Addr 13h)
 * SIZE:     32
 * FIELDS:
 *     EXT_CABLE_DIAG_LEN_2 EXT_CABLE_DIAG_LEN_2
 *
 ******************************************************************************/
#define BCM54684_EXT_CABLE_DIAG_LEN_2r (0x000f1315 | PHY_REG_ACC_BRCM_SHADOW)

#define BCM54684_EXT_CABLE_DIAG_LEN_2r_SIZE 4

/*
 * This structure should be used to declare and program EXT_CABLE_DIAG_LEN_2.
 *
 */
typedef union BCM54684_EXT_CABLE_DIAG_LEN_2r_s {
	uint32_t v[1];
	uint32_t ext_cable_diag_len_2[1];
	uint32_t _ext_cable_diag_len_2;
} BCM54684_EXT_CABLE_DIAG_LEN_2r_t;

#define BCM54684_EXT_CABLE_DIAG_LEN_2r_CLR(r) (r).ext_cable_diag_len_2[0] = 0
#define BCM54684_EXT_CABLE_DIAG_LEN_2r_SET(r,d) (r).ext_cable_diag_len_2[0] = d
#define BCM54684_EXT_CABLE_DIAG_LEN_2r_GET(r) (r).ext_cable_diag_len_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM54684_EXT_CABLE_DIAG_LEN_2r_EXT_CABLE_DIAG_LEN_2f_GET(r) (((r).ext_cable_diag_len_2[0]) & 0xffff)
#define BCM54684_EXT_CABLE_DIAG_LEN_2r_EXT_CABLE_DIAG_LEN_2f_SET(r,f) (r).ext_cable_diag_len_2[0]=(((r).ext_cable_diag_len_2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access EXT_CABLE_DIAG_LEN_2.
 *
 */
#define BCM54684_READ_EXT_CABLE_DIAG_LEN_2r(_pc,_r) phy_brcm_shadow_read(_pc,BCM54684_EXT_CABLE_DIAG_LEN_2r,(_r._ext_cable_diag_len_2))
#define BCM54684_WRITE_EXT_CABLE_DIAG_LEN_2r(_pc,_r) phy_brcm_shadow_write(_pc,BCM54684_EXT_CABLE_DIAG_LEN_2r,(_r._ext_cable_diag_len_2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define EXT_CABLE_DIAG_LEN_2r BCM54684_EXT_CABLE_DIAG_LEN_2r
#define EXT_CABLE_DIAG_LEN_2r_SIZE BCM54684_EXT_CABLE_DIAG_LEN_2r_SIZE
typedef BCM54684_EXT_CABLE_DIAG_LEN_2r_t EXT_CABLE_DIAG_LEN_2r_t;
#define EXT_CABLE_DIAG_LEN_2r_CLR BCM54684_EXT_CABLE_DIAG_LEN_2r_CLR
#define EXT_CABLE_DIAG_LEN_2r_SET BCM54684_EXT_CABLE_DIAG_LEN_2r_SET
#define EXT_CABLE_DIAG_LEN_2r_GET BCM54684_EXT_CABLE_DIAG_LEN_2r_GET
#define EXT_CABLE_DIAG_LEN_2r_EXT_CABLE_DIAG_LEN_2f_GET BCM54684_EXT_CABLE_DIAG_LEN_2r_EXT_CABLE_DIAG_LEN_2f_GET
#define EXT_CABLE_DIAG_LEN_2r_EXT_CABLE_DIAG_LEN_2f_SET BCM54684_EXT_CABLE_DIAG_LEN_2r_EXT_CABLE_DIAG_LEN_2f_SET
#define READ_EXT_CABLE_DIAG_LEN_2r BCM54684_READ_EXT_CABLE_DIAG_LEN_2r
#define WRITE_EXT_CABLE_DIAG_LEN_2r BCM54684_WRITE_EXT_CABLE_DIAG_LEN_2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM54684_EXT_CABLE_DIAG_LEN_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM54684
 * REGISTER:  EXP_OPT_MODE_STAT
 * BLOCKS:   USER
 * REGADDR:  0x0015
 * DESC:     Operating Mode Status Register (Addr 42h)
 * SIZE:     32
 * FIELDS:
 *     EXP_OPT_MODE_STAT EXP_OPT_MODE_STAT
 *
 ******************************************************************************/
#define BCM54684_EXP_OPT_MODE_STATr (0x000f4215 | PHY_REG_ACC_BRCM_SHADOW)

#define BCM54684_EXP_OPT_MODE_STATr_SIZE 4

/*
 * This structure should be used to declare and program EXP_OPT_MODE_STAT.
 *
 */
typedef union BCM54684_EXP_OPT_MODE_STATr_s {
	uint32_t v[1];
	uint32_t exp_opt_mode_stat[1];
	uint32_t _exp_opt_mode_stat;
} BCM54684_EXP_OPT_MODE_STATr_t;

#define BCM54684_EXP_OPT_MODE_STATr_CLR(r) (r).exp_opt_mode_stat[0] = 0
#define BCM54684_EXP_OPT_MODE_STATr_SET(r,d) (r).exp_opt_mode_stat[0] = d
#define BCM54684_EXP_OPT_MODE_STATr_GET(r) (r).exp_opt_mode_stat[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM54684_EXP_OPT_MODE_STATr_EXP_OPT_MODE_STATf_GET(r) (((r).exp_opt_mode_stat[0]) & 0xffff)
#define BCM54684_EXP_OPT_MODE_STATr_EXP_OPT_MODE_STATf_SET(r,f) (r).exp_opt_mode_stat[0]=(((r).exp_opt_mode_stat[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access EXP_OPT_MODE_STAT.
 *
 */
#define BCM54684_READ_EXP_OPT_MODE_STATr(_pc,_r) phy_brcm_shadow_read(_pc,BCM54684_EXP_OPT_MODE_STATr,(_r._exp_opt_mode_stat))
#define BCM54684_WRITE_EXP_OPT_MODE_STATr(_pc,_r) phy_brcm_shadow_write(_pc,BCM54684_EXP_OPT_MODE_STATr,(_r._exp_opt_mode_stat))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define EXP_OPT_MODE_STATr BCM54684_EXP_OPT_MODE_STATr
#define EXP_OPT_MODE_STATr_SIZE BCM54684_EXP_OPT_MODE_STATr_SIZE
typedef BCM54684_EXP_OPT_MODE_STATr_t EXP_OPT_MODE_STATr_t;
#define EXP_OPT_MODE_STATr_CLR BCM54684_EXP_OPT_MODE_STATr_CLR
#define EXP_OPT_MODE_STATr_SET BCM54684_EXP_OPT_MODE_STATr_SET
#define EXP_OPT_MODE_STATr_GET BCM54684_EXP_OPT_MODE_STATr_GET
#define EXP_OPT_MODE_STATr_EXP_OPT_MODE_STATf_GET BCM54684_EXP_OPT_MODE_STATr_EXP_OPT_MODE_STATf_GET
#define EXP_OPT_MODE_STATr_EXP_OPT_MODE_STATf_SET BCM54684_EXP_OPT_MODE_STATr_EXP_OPT_MODE_STATf_SET
#define READ_EXP_OPT_MODE_STATr BCM54684_READ_EXP_OPT_MODE_STATr
#define WRITE_EXP_OPT_MODE_STATr BCM54684_WRITE_EXP_OPT_MODE_STATr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM54684_EXP_OPT_MODE_STATr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM54684
 * REGISTER:  EXP_AMP_CTRL
 * BLOCKS:   USER
 * REGADDR:  0x0015
 * DESC:     Amplitude Control Register (Addr 51h)
 * SIZE:     32
 * FIELDS:
 *     EXP_AMP_CTRL     EXP_AMP_CTRL
 *
 ******************************************************************************/
#define BCM54684_EXP_AMP_CTRLr (0x000f5215 | PHY_REG_ACC_BRCM_SHADOW)

#define BCM54684_EXP_AMP_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program EXP_AMP_CTRL.
 *
 */
typedef union BCM54684_EXP_AMP_CTRLr_s {
	uint32_t v[1];
	uint32_t exp_amp_ctrl[1];
	uint32_t _exp_amp_ctrl;
} BCM54684_EXP_AMP_CTRLr_t;

#define BCM54684_EXP_AMP_CTRLr_CLR(r) (r).exp_amp_ctrl[0] = 0
#define BCM54684_EXP_AMP_CTRLr_SET(r,d) (r).exp_amp_ctrl[0] = d
#define BCM54684_EXP_AMP_CTRLr_GET(r) (r).exp_amp_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM54684_EXP_AMP_CTRLr_EXP_AMP_CTRLf_GET(r) (((r).exp_amp_ctrl[0]) & 0xffff)
#define BCM54684_EXP_AMP_CTRLr_EXP_AMP_CTRLf_SET(r,f) (r).exp_amp_ctrl[0]=(((r).exp_amp_ctrl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access EXP_AMP_CTRL.
 *
 */
#define BCM54684_READ_EXP_AMP_CTRLr(_pc,_r) phy_brcm_shadow_read(_pc,BCM54684_EXP_AMP_CTRLr,(_r._exp_amp_ctrl))
#define BCM54684_WRITE_EXP_AMP_CTRLr(_pc,_r) phy_brcm_shadow_write(_pc,BCM54684_EXP_AMP_CTRLr,(_r._exp_amp_ctrl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define EXP_AMP_CTRLr BCM54684_EXP_AMP_CTRLr
#define EXP_AMP_CTRLr_SIZE BCM54684_EXP_AMP_CTRLr_SIZE
typedef BCM54684_EXP_AMP_CTRLr_t EXP_AMP_CTRLr_t;
#define EXP_AMP_CTRLr_CLR BCM54684_EXP_AMP_CTRLr_CLR
#define EXP_AMP_CTRLr_SET BCM54684_EXP_AMP_CTRLr_SET
#define EXP_AMP_CTRLr_GET BCM54684_EXP_AMP_CTRLr_GET
#define EXP_AMP_CTRLr_EXP_AMP_CTRLf_GET BCM54684_EXP_AMP_CTRLr_EXP_AMP_CTRLf_GET
#define EXP_AMP_CTRLr_EXP_AMP_CTRLf_SET BCM54684_EXP_AMP_CTRLr_EXP_AMP_CTRLf_SET
#define READ_EXP_AMP_CTRLr BCM54684_READ_EXP_AMP_CTRLr
#define WRITE_EXP_AMP_CTRLr BCM54684_WRITE_EXP_AMP_CTRLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM54684_EXP_AMP_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM54684
 * REGISTER:  EXP_SGOUT_CTRL
 * BLOCKS:   USER
 * REGADDR:  0x0015
 * DESC:     SGOUT Control Register (Addr 52h)
 * SIZE:     32
 * FIELDS:
 *     EXP_SGOUT_CTRL   EXP_SGOUT_CTRL
 *
 ******************************************************************************/
#define BCM54684_EXP_SGOUT_CTRLr (0x000f5215 | PHY_REG_ACC_BRCM_SHADOW)

#define BCM54684_EXP_SGOUT_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program EXP_SGOUT_CTRL.
 *
 */
typedef union BCM54684_EXP_SGOUT_CTRLr_s {
	uint32_t v[1];
	uint32_t exp_sgout_ctrl[1];
	uint32_t _exp_sgout_ctrl;
} BCM54684_EXP_SGOUT_CTRLr_t;

#define BCM54684_EXP_SGOUT_CTRLr_CLR(r) (r).exp_sgout_ctrl[0] = 0
#define BCM54684_EXP_SGOUT_CTRLr_SET(r,d) (r).exp_sgout_ctrl[0] = d
#define BCM54684_EXP_SGOUT_CTRLr_GET(r) (r).exp_sgout_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM54684_EXP_SGOUT_CTRLr_EXP_SGOUT_CTRLf_GET(r) (((r).exp_sgout_ctrl[0]) & 0xffff)
#define BCM54684_EXP_SGOUT_CTRLr_EXP_SGOUT_CTRLf_SET(r,f) (r).exp_sgout_ctrl[0]=(((r).exp_sgout_ctrl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access EXP_SGOUT_CTRL.
 *
 */
#define BCM54684_READ_EXP_SGOUT_CTRLr(_pc,_r) phy_brcm_shadow_read(_pc,BCM54684_EXP_SGOUT_CTRLr,(_r._exp_sgout_ctrl))
#define BCM54684_WRITE_EXP_SGOUT_CTRLr(_pc,_r) phy_brcm_shadow_write(_pc,BCM54684_EXP_SGOUT_CTRLr,(_r._exp_sgout_ctrl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define EXP_SGOUT_CTRLr BCM54684_EXP_SGOUT_CTRLr
#define EXP_SGOUT_CTRLr_SIZE BCM54684_EXP_SGOUT_CTRLr_SIZE
typedef BCM54684_EXP_SGOUT_CTRLr_t EXP_SGOUT_CTRLr_t;
#define EXP_SGOUT_CTRLr_CLR BCM54684_EXP_SGOUT_CTRLr_CLR
#define EXP_SGOUT_CTRLr_SET BCM54684_EXP_SGOUT_CTRLr_SET
#define EXP_SGOUT_CTRLr_GET BCM54684_EXP_SGOUT_CTRLr_GET
#define EXP_SGOUT_CTRLr_EXP_SGOUT_CTRLf_GET BCM54684_EXP_SGOUT_CTRLr_EXP_SGOUT_CTRLf_GET
#define EXP_SGOUT_CTRLr_EXP_SGOUT_CTRLf_SET BCM54684_EXP_SGOUT_CTRLr_EXP_SGOUT_CTRLf_SET
#define READ_EXP_SGOUT_CTRLr BCM54684_READ_EXP_SGOUT_CTRLr
#define WRITE_EXP_SGOUT_CTRLr BCM54684_WRITE_EXP_SGOUT_CTRLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM54684_EXP_SGOUT_CTRLr'
 ******************************************************************************/




#endif /* __BCM54684_DEFS_H__ */
